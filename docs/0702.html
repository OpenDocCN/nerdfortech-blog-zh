<html>
<head>
<title>My Experience with ActiveRecord Macros for Self-Referential Associations (Family Tree)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">我用ActiveRecord宏进行自我参照关联的经验(家谱)</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/my-experience-with-activerecord-macros-for-self-referential-associations-family-tree-a0fc70faf506?source=collection_archive---------1-----------------------#2021-02-06">https://medium.com/nerd-for-tech/my-experience-with-activerecord-macros-for-self-referential-associations-family-tree-a0fc70faf506?source=collection_archive---------1-----------------------#2021-02-06</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div class="er es if"><img src="../Images/d603d8f10917509424f781b9941de31f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1024/format:webp/1*ILE3bDTu1s6PgfMmtZRFog.png"/></div></figure><p id="97cf" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">使用Ruby和ActiveRecord，我试图创建一个家谱的域模型。在这个过程中，我学到了一些新东西，<em class="jk">包括但不限于</em>:</p><ul class=""><li id="5cd2" class="jl jm hi io b ip iq it iu ix jn jb jo jf jp jj jq jr js jt bi translated">“孝顺”是一个俏皮的小词，用来形容父母和孩子之间的关系。</li><li id="a6cb" class="jl jm hi io b ip ju it jv ix jw jb jx jf jy jj jq jr js jt bi translated">这里<strong class="io hj">没有</strong>俏皮的“lil”一词来表示中性版本的阿姨和叔叔！(像爸爸妈妈→父母；但是阿姨和叔叔→？？？)最后我用了“auntcles”这个词。</li><li id="44e9" class="jl jm hi io b ip ju it jv ix jw jb jx jf jy jj jq jr js jt bi translated">侄女和侄子也存在同样的问题，因此zak创造了另一个新词:“niephcews”。Gesundheit。是啊，我也不喜欢看到这个词，但要怪英语，而不是我。</li><li id="6878" class="jl jm hi io b ip ju it jv ix jw jb jx jf jy jj jq jr js jt bi translated">如何拼写“Gesundheit”</li></ul><p id="3f2b" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">好了，关于英语和德语已经说得够多了，回到另一种语言:Ruby。对此建模的一个挑战是<strong class="io hj"> <em class="jk">自我参照</em> </strong>的想法，这是我以前没有遇到过的。如果你不熟悉这个术语，这是一个时髦的面向对象编程(面向对象编程)词汇，指的是对象与同类对象之间的关系。所以，如果你对一辆卡车和它的许多轮子感到好奇，那种关系是<em class="jk">而不是</em>自我参照——卡车和轮子是<em class="jk">不同的东西。</em>但是一个人和另一个人(兄弟姐妹、同学/同学、老板/雇员、同事/同事、学生/老师等)之间的任何关系都是<em class="jk">自指</em>，因为这两个对象都属于<em class="jk">人</em>类型。</p><p id="3ba6" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">你可以通过创建一个老板类和一个雇员类来避免这种自我引用的想法，而不是使用Person和Person。这在许多情况下可能会很有效…直到你有一个老板，他也为别人工作，你的员工现在是经理，现在老板有老板，员工有员工，员工是老板…你开始看到问题了。你的老师和学生班级工作得非常好，直到你的老师决定回去攻读第二个学位，现在是一名学生，同时还是一名教师。所以，当我们需要表现这些更健壮的情况，以及多个同时发生的关系时，我们需要让人们成为人，而不是仅仅由他们的一个关系来定义。</p><p id="579c" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">所以在我的家谱中，有各种各样的关系(父母/孩子、兄弟姐妹、婚姻等)，一个人的父母也是另一个人的孩子，你的兄弟姐妹也是某人的丈夫，等等。但是这些关系中的每一个都是两个 <strong class="io hj"> <em class="jk">人</em> </strong>物<em class="jk">物</em>之间的<em class="jk">:于是<strong class="io hj">自指物</strong>。</em></p><p id="fcf4" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">好了，我们现在明白了自我指涉的概念。但是为什么自我参照的场景比非自我参照的场景更难编程呢？我遇到的困难是在ActiveRecord中设置宏来恰当地模拟关系。如果我们有教师和学生两个班级，我们可以这样做:</p><pre class="jz ka kb kc fd kd ke kf kg aw kh bi"><span id="84ae" class="ki kj hi ke b fi kk kl l km kn">class Teacher &lt; ActiveRecord::Base<br/>   has_many :grades<br/>   has_many :students, through: :grades<br/>end</span><span id="5efe" class="ki kj hi ke b fi ko kl l km kn">class Student &lt; ActiveRecord::Base<br/>   has_many :grades<br/>   has_many :teachers, through: :grades<br/>end</span></pre><p id="f2ac" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">但是，正如我们已经讨论过的，我们不能对我的家谱做同样的事情。</p><pre class="jz ka kb kc fd kd ke kf kg aw kh bi"><span id="7420" class="ki kj hi ke b fi kk kl l km kn">class Person &lt; ActiveRecord::Base<br/>   has_many :people ??<br/>   has_many :people, through: :people   ???<br/>   belongs_to :some_more_people<br/>   #what is going on <br/>   #i have no idea<br/>end</span></pre><p id="ea3a" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">是的……这看起来一团糟。好的，有一点并不完全错误，那就是在家谱中，人们确实有很多人。每当A有很多B，B有很多A时，我们就需要某种joiner模型。在这种情况下，关系本身将充当参与者。对于我的树，我决定只建模“横向关系”(婚姻)和“纵向关系”(“子女”关系——父母/子女)。使用实例方法，所有其他类型的关系都可以从这两种关系中推导出来。(例如，如果您想要所有兄弟姐妹的列表，请查询所有人的列表，以找到与您共享父母的人；爷爷奶奶只是你父母的父母；等等)。</p><p id="258b" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">酷毙了。这就是我们目前正在烹饪的东西:</p><pre class="jz ka kb kc fd kd ke kf kg aw kh bi"><span id="8ac3" class="ki kj hi ke b fi kk kl l km kn">class Marriage &lt; ApplicationRecord<br/>end</span><span id="4b47" class="ki kj hi ke b fi ko kl l km kn">class Filial &lt; ApplicationRecord<br/>end</span><span id="c4eb" class="ki kj hi ke b fi ko kl l km kn">class Person &lt;ApplicationRecord<br/>end</span></pre><p id="9249" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">现在是这篇文章的高潮:宏。嗯，不严格地说，我想要一些属于家庭和婚姻的东西。这是因为没有结婚的两个人，婚姻就无法存在；没有父母和孩子，父母和孩子的关系也无法存在。所以这些依赖于他们所属的人的存在。所以，以孝顺为例，我可以说:</p><pre class="jz ka kb kc fd kd ke kf kg aw kh bi"><span id="a5b8" class="ki kj hi ke b fi kk kl l km kn">class Filial &lt; ApplicationRecord<br/>   belongs_to :parent<br/>   belongs_to :child<br/>end</span></pre><p id="dcee" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">但是我们没有亲子类这种东西。所以，那是不行的。好吧，我们可以试试这个:</p><pre class="jz ka kb kc fd kd ke kf kg aw kh bi"><span id="7f67" class="ki kj hi ke b fi kk kl l km kn">class Filial &lt; ApplicationRecord<br/>   belongs_to :person<br/>   belongs_to :person<br/>end</span></pre><p id="94ef" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">好吧，我是说，这更合理了。毕竟，我们有一个人类，一个子关系实际上属于两个不同的人对象。那么问题呢？哪个是哪个？你如何区分作为父母的人和作为孩子的人？我们需要某种方法把以前的想法和这个想法融合在一起。</p><p id="dab8" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">这就是:</p><pre class="jz ka kb kc fd kd ke kf kg aw kh bi"><span id="becd" class="ki kj hi ke b fi kk kl l km kn">class Filial &lt; ApplicationRecord<br/>   belongs_to :child, class_name: "Person", foreign_key: "child_id"<br/>   belongs_to :parent, class_name: "Person", foreign_key: "parent_id"<br/>end</span></pre><p id="d2c2" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">在这里，我们拥有两个世界的精华。现在，我们能够跟踪哪个对象是父对象，哪个是子对象，<em class="jk">和</em>都是<em class="jk"> </em>人对象。此外，因为它们都是Person对象，所以一个特定的人可能在一个子关系中被标识为父，而在其他子关系中被标识为子，这没有任何问题。完美。</p><p id="dbbf" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">现在我们已经解决了所有的关系(至少在这个模型中，没有人提到IRL)，最后一部分是在Person类中解决问题。并不是每个人都有婚姻、孩子，甚至是父母关系。所以既然一个人的存在并不依赖于这些关系中的某一个的存在，那么一个归属就不合适了。一个人可以有几个孩子和至少两个父母(如果我们包括继父母和养父母，则不止两个)，因此合适的关联宏应该是:</p><pre class="jz ka kb kc fd kd ke kf kg aw kh bi"><span id="fab3" class="ki kj hi ke b fi kk kl l km kn">class Person &lt;ApplicationRecord<br/>   has_many :parents<br/>   has_many :children<br/>end</span></pre><p id="afb3" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">但是，再说一次，那是行不通的。AR不太清楚这些是什么意思，因为没有父对象和子对象。我们可以做的是:</p><pre class="jz ka kb kc fd kd ke kf kg aw kh bi"><span id="037c" class="ki kj hi ke b fi kk kl l km kn">class Person &lt;ApplicationRecord<br/>   has_many :filials<br/>end</span></pre><p id="0641" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">虽然AR现在会认识到这一点，但尝试my_guy.filials将总是没有结果，因为当翻阅子对象时，它将通过parent_id和child_id进行查找，这不会按照我们想要的方式与一个人的person_id进行比较。因此，我们需要这样做:</p><pre class="jz ka kb kc fd kd ke kf kg aw kh bi"><span id="4d13" class="ki kj hi ke b fi kk kl l km kn">class Filial &lt; ApplicationRecord<br/>   belongs_to :child, class_name: "Person", foreign_key: "child_id"<br/>   belongs_to :parent, class_name: "Person", foreign_key: "parent_id"<br/>end</span><span id="a94b" class="ki kj hi ke b fi ko kl l km kn">class Person &lt;ApplicationRecord<br/>   has_many :parent_relationships, class_name: "Filial", foreign_key: :child_id, dependent: :destroy<br/>   has_many :parents, through: :parent_relationships, source: :parent<br/>   has_many :child_relationships, class_name: "Filial", foreign_key: :parent_id, dependent: :destroy<br/>   has_many :children, through: :child_relationships, source: :child<br/>end</span></pre><p id="6355" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">通过这种方式，我们明确地告诉AR，当它查找我父母的子文件时，将我的person_id与那些child_id进行比较，以查看我是孩子的关系，从而找到我的parent_relationships列表，并通过它找到我父母的列表。</p><p id="db26" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">棘手的事情！但最终，掌握这一概念将帮助你驾驭ActiveRecord通过其神奇的关联宏给予我们的众多礼物。</p></div></div>    
</body>
</html>