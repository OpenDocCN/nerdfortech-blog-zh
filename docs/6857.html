<html>
<head>
<title>What are Observables in Angular?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">有哪些可观察的角度？</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/what-are-observables-in-angular-5e89d159a4e6?source=collection_archive---------0-----------------------#2022-05-30">https://medium.com/nerd-for-tech/what-are-observables-in-angular-5e89d159a4e6?source=collection_archive---------0-----------------------#2022-05-30</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/8d25d1cacc81e16d6879bc8e54836714.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*hm5Tm9_y3HAFN-wh.png"/></div></div></figure><p id="0372" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi jo translated">在本教程的中，我将解释<strong class="is hj">什么是可观测的，以及何时何地使用它</strong>。我们使用 Observable 来执行异步操作和处理异步数据。处理异步的另一种方式是使用承诺。我们可以使用承诺或可观察值来处理异步操作。</p><h2 id="1712" class="jx jy hi bd jz ka kb kc kd ke kf kg kh jb ki kj kk jf kl km kn jj ko kp kq kr bi translated">什么是异步操作和异步数据？</h2><p id="2d02" class="pw-post-body-paragraph iq ir hi is b it ks iv iw ix kt iz ja jb ku jd je jf kv jh ji jj kw jl jm jn hb bi translated">我们已经知道 JavaScript 是一种<strong class="is hj">单线程语言</strong>。这意味着代码被逐行执行<strong class="is hj">并且一旦一个代码的执行完成，那么只有程序的下一个代码将被执行。当我们向 HTTP 服务器发出请求时，会花费更多的时间。所以 HTTP 请求后的下一条语句必须等待执行。只有当 HTTP 请求完成时，它才会被执行。我们可以说同步的<strong class="is hj">代码在本质上是阻塞的</strong>。这就是异步程序出现的方式。在后台执行的异步代码<strong class="is hj">不会阻塞主线程中代码</strong>的执行。异步代码是非阻塞的。这意味着我们可以异步发出 HTTP 请求。</strong></p><p id="fdd6" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">使用异步程序，我们可以在不阻塞主线程的情况下执行长时间的网络请求。有两种方法可以做到这一点。</p><ul class=""><li id="2e8b" class="kx ky hi is b it iu ix iy jb kz jf la jj lb jn lc ld le lf bi translated">使用可观测量</li><li id="e007" class="kx ky hi is b it lg ix lh jb li jf lj jj lk jn lc ld le lf bi translated">利用承诺</li></ul><h2 id="83be" class="jx jy hi bd jz ka kb kc kd ke kf kg kh jb ki kj kk jf kl km kn jj ko kp kq kr bi translated">承诺和可观察到的有什么区别？</h2><figure class="lm ln lo lp fd ij er es paragraph-image"><div class="er es ll"><img src="../Images/05967993fff81c0de10d3cd056bb87c2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1090/format:webp/0*ytKR4OKeQJM1uErI.png"/></div></figure><p id="8113" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">假设我们从服务器请求一个用户列表。从浏览器中，我们向服务器发送一个请求，服务器将从数据库中获取数据。假设我们请求的数据非常庞大。在这种情况下，服务器需要一些时间从数据库中获取数据。一旦数据准备好，数据将从服务器发送到客户端。在这里，服务器收集所有的数据，当数据准备好了，就会发送回客户端。这就是实现承诺的方法。它承诺在一段时间内提供数据。一旦完整的数据准备就绪，Promise 就会向我们提供数据。该数据可以是我们请求的实际数据，也可以是错误数据。如果没有互联网连接。在这种情况下，还承诺返回一些数据。该数据将是错误消息或错误对象。</p><p id="73fe" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">可观测量<strong class="is hj">不等待完整数据可用</strong>。一个可观察的数据流。当数据部分可用时，它将发送给客户端。</p><p id="31fb" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">承诺</strong></p><ol class=""><li id="3d19" class="kx ky hi is b it iu ix iy jb kz jf la jj lb jn lq ld le lf bi translated">帮助您异步运行函数，并使用它们的返回值(或异常)，但在执行时只使用一次<strong class="is hj"/>。</li><li id="83ee" class="kx ky hi is b it lg ix lh jb li jf lj jj lk jn lq ld le lf bi translated">不懒。</li><li id="31c0" class="kx ky hi is b it lg ix lh jb li jf lj jj lk jn lq ld le lf bi translated">不可取消(有一些 Promise 库支持取消，但 ES6 Promise 目前还不支持)。两个可能的决定是<strong class="is hj">拒绝和解决</strong>。</li><li id="3671" class="kx ky hi is b it lg ix lh jb li jf lj jj lk jn lq ld le lf bi translated">不能<strong class="is hj">重试</strong>(承诺应该能够访问返回承诺的原始函数，以具有重试能力，这是一种不好的做法)</li><li id="a3a0" class="kx ky hi is b it lg ix lh jb li jf lj jj lk jn lq ld le lf bi translated">由 JavaScript 语言提供。</li></ol><p id="33e0" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">可观测量</strong></p><ol class=""><li id="b724" class="kx ky hi is b it iu ix iy jb kz jf la jj lb jn lq ld le lf bi translated">帮助您异步运行函数，并在执行时以连续的顺序使用它们的返回值(<strong class="is hj">多次</strong>)。</li><li id="a472" class="kx ky hi is b it lg ix lh jb li jf lj jj lk jn lq ld le lf bi translated">默认情况下，它是<em class="lr">惰性的</em>，因为它会随着时间的推移发出值。</li><li id="0a69" class="kx ky hi is b it lg ix lh jb li jf lj jj lk jn lq ld le lf bi translated">有许多操作符，这简化了编码工作。</li><li id="cbe6" class="kx ky hi is b it lg ix lh jb li jf lj jj lk jn lq ld le lf bi translated">一个操作符<strong class="is hj"> retry </strong>可以在任何需要的时候用来重试，如果我们需要基于某些条件重试可观察值<strong class="is hj">retry 什么时候可以使用</strong>。</li><li id="9dd4" class="kx ky hi is b it lg ix lh jb li jf lj jj lk jn lq ld le lf bi translated">不是 Angular 或 JavaScript 的原生特性。由另一个名为 JavaScript 库提供。</li></ol><figure class="lm ln lo lp fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ls"><img src="../Images/bb96e6edef1453b4e8f7f66e2113621f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*l_tB3jijybFxaKrT.png"/></div></div></figure><p id="993d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">一个<strong class="is hj">可观测的</strong>是一个<strong class="is hj">函数</strong>，它将普通的数据流转换成一个可观测的数据流。你可以把 Observable 想象成普通数据流的包装器。</p><p id="837f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">Rxjs(JavaScript 的反应式扩展)是一个 JavaScript 库，它允许我们处理异步数据流。</p><p id="9e0a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">从这里你可以找到所有和 Rxjs 相关的东西，</p><div class="lt lu ez fb lv lw"><a href="https://www.learnrxjs.io/" rel="noopener  ugc nofollow" target="_blank"><div class="lx ab dw"><div class="ly ab lz cl cj ma"><h2 class="bd hj fi z dy mb ea eb mc ed ef hh bi translated">介绍</h2><div class="md l"><h3 class="bd b fi z dy mb ea eb mc ed ef dx translated">编辑描述</h3></div><div class="me l"><p class="bd b fp z dy mb ea eb mc ed ef dx translated">www.learnrxjs.io</p></div></div><div class="mf l"><div class="mg l mh mi mj mf mk io lw"/></div></div></a></div><p id="02ed" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj"> Rxjs </strong>有两个主要原因。</p><ul class=""><li id="8b42" class="kx ky hi is b it iu ix iy jb kz jf la jj lb jn lc ld le lf bi translated">可观察的—数据流</li><li id="9993" class="kx ky hi is b it lg ix lh jb li jf lj jj lk jn lc ld le lf bi translated">观察者——它将使用数据</li></ul><p id="cf77" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">为了让观测者利用被观测者发出的数据。因为观察者必须认同可观察事物。</p><p id="455f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">让我们创建一个<strong class="is hj">可观察的</strong>。为了创建一个可观察对象，我们需要在我们的 Angular 应用程序中从<strong class="is hj"> Rxjs </strong>库导入可观察对象。当我们创建一个新的 Angular 项目时，这个库会自动安装到项目中。不需要单独安装 Rxjs。</p><p id="04c1" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在这里，我创建了一个名为<strong class="is hj">“my-app”</strong>的简单项目，在<strong class="is hj"> app.component.ts </strong>中，我们需要从 Rxjs 库导入 Obseravle。然后我使用 Observable 构造函数创建了一个新的 Observable 对象。在构造函数中，我们需要传递<strong class="is hj">回调</strong>函数。回调函数将接收一个参数，该参数将是<strong class="is hj">观察器</strong>。这个参数将由 Rxjs 库注入。这个观察者就是等待数据的订阅者。</p><p id="ee88" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在回调函数中，我将记录一条消息并发出一些数据。为了发出数据，我们可以使用<strong class="is hj"> observer.next() </strong>。我要发射 5 倍的数据。这是可观测物体将要发出的数据。</p><p id="398d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在我们需要一个<strong class="is hj">订阅</strong>。只有当有一个<strong class="is hj">用户</strong>时，这个可观察对象才会发出数据。如果没有订户，它将不会发出数据。为可观察对象创建订阅者。在<strong class="is hj"> ngOnInit </strong>中，我将实现订户。订户接受 3 个可选参数。这三个参数是回调函数。</p><ul class=""><li id="075f" class="kx ky hi is b it iu ix iy jb kz jf la jj lb jn lc ld le lf bi translated">然后</li><li id="ac61" class="kx ky hi is b it lg ix lh jb li jf lj jj lk jn lc ld le lf bi translated">错误</li><li id="ba0a" class="kx ky hi is b it lg ix lh jb li jf lj jj lk jn lc ld le lf bi translated">完成</li></ul><figure class="lm ln lo lp fd ij er es paragraph-image"><div class="er es ml"><img src="../Images/999e109d545492c0d64e50a42b0b35fb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1082/format:webp/0*YyyFLPdZLk2gD3mz.png"/></div></figure><p id="1c29" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这三个参数都是可选的。</p><pre class="lm ln lo lp fd mm mn mo mp aw mq bi"><span id="ab4c" class="jx jy hi mn b fi mr ms l mt mu">this.myObservable.subscribe(next, error, complete);</span></pre><p id="574a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这个下一个参数是一个<strong class="is hj">回调函数</strong>，每当可观察对象中的下一个方法返回值时，这个参数就会被执行。在这个例子中，“<strong class="is hj">next”</strong>回调函数将调用 5 次，因为我们要发出 5 次数据。基本上，下一个回调函数<strong class="is hj">将接收观察对象返回或发出的数据。</strong></p><figure class="lm ln lo lp fd ij er es paragraph-image"><div class="er es mv"><img src="../Images/dfbdad79a1af612ff747c909bcad987f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1290/format:webp/0*b1igUTET7jxeCLoE.jpg"/></div></figure><p id="344f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们转到网页，打开开发者控制台。现在你可以看到被观测者发出的数据，它已经被记录在这里。</p><pre class="lm ln lo lp fd mm mn mo mp aw mq bi"><span id="c13c" class="jx jy hi mn b fi mr ms l mt mu">import {Component, OnInit} from '@angular/core';<br/>import {Observable} from 'rxjs';</span><span id="4d69" class="jx jy hi mn b fi mw ms l mt mu">@Component({<br/>  selector: 'app-root',<br/>  templateUrl: './app.component.html',<br/>  styleUrls: ['./app.component.css']<br/>})<br/>export class AppComponent implements OnInit {<br/>  title = 'my-app';<br/>  myObservable = new Observable((observer) =&gt; {<br/>    <strong class="mn hj"><em class="lr">console</em></strong>.log('Observable Starts');<br/>    observer.next('1');<br/>    observer.next('2');<br/>    observer.next('3');<br/>    observer.next('4');<br/>    observer.next('5');<br/>  });<br/></span><span id="223b" class="jx jy hi mn b fi mw ms l mt mu">  ngOnInit(): void {<br/>    this.myObservable.subscribe((val) =&gt;{<br/>      <strong class="mn hj"><em class="lr">console</em></strong>.log(val);<br/>    });<br/>  }<br/>}</span></pre><figure class="lm ln lo lp fd ij er es paragraph-image"><div class="er es mx"><img src="../Images/ba378d50e920f16dc16dc0ece113062e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1320/format:webp/1*zn7NKk15qmq-UmP1rKEGeQ.png"/></div></figure><p id="2bc8" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这些数据已经被一个接一个地传输了。让我们从某个时间间隔发出数据。为此我们可以使用<strong class="is hj"> setTimeout() </strong>函数。我加了 1 秒作为时间间隔。</p><pre class="lm ln lo lp fd mm mn mo mp aw mq bi"><span id="9cfb" class="jx jy hi mn b fi mr ms l mt mu">myObservable = new Observable((observer) =&gt; {<br/>  <strong class="mn hj"><em class="lr">console</em></strong>.log('Observable Starts');<br/>  setTimeout(() =&gt; {<br/>    observer.next('1');<br/>  }, 1000);<br/>  setTimeout(() =&gt; {<br/>    observer.next('2');<br/>  }, 2000);<br/>  setTimeout(() =&gt; {<br/>    observer.next('3');<br/>  }, 3000);<br/>  setTimeout(() =&gt; {<br/>    observer.next('4');<br/>  }, 4000);<br/>  setTimeout(() =&gt; {<br/>    observer.next('5');<br/>  }, 5000);</span><span id="7178" class="jx jy hi mn b fi mw ms l mt mu">});</span></pre><p id="a857" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在你可以看到数据一个接一个地在一定的时间间隔(1 秒)后被发射。</p><p id="1d31" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我希望你能更好地理解和了解观察到的事物和它们的过程。还有其他方法来创造可观测量，让我们找到它们，并在下一个教程中学习它们。</p><p id="12a1" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">谢谢大家！</p></div></div>    
</body>
</html>