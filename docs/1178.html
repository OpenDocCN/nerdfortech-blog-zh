<html>
<head>
<title>What :is() the deal? Simplifying CSS with the :is() pseudo-class</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">什么:交易是()吗？用:is()伪类简化CSS</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/what-is-the-deal-simplifying-css-with-the-is-pseudo-class-e2116dbadf4f?source=collection_archive---------19-----------------------#2021-03-07">https://medium.com/nerd-for-tech/what-is-the-deal-simplifying-css-with-the-is-pseudo-class-e2116dbadf4f?source=collection_archive---------19-----------------------#2021-03-07</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div class="er es if"><img src="../Images/ea8e8eb51d220e91d1980be7405c5fb2.png" data-original-src="https://miro.medium.com/v2/resize:fit:708/format:webp/1*8KaHKzGT543zR1UiI-NiIA.png"/></div></figure><p id="ba25" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">在我们通往web-developer good的旅途中，我们中的许多人都曾在某个时候不得不面对CSS选择器的微妙的令人抓狂的本质。将元素链接在一起以获得我们想要的特定结果可能会成为这些小麻烦之一，我将向您展示如何通过一个巧妙的技巧让它变得不那么乏味。请随意点击我的代码沙盒链接，这里有更好的视觉帮助<a class="ae jk" href="https://codesandbox.io/s/is-pseudo-class-example-o0hnv?file=/README.md" rel="noopener ugc nofollow" target="_blank"/>。</p><p id="e965" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">举例来说，假设您真的希望页眉中的两个特定元素是漂亮的红色耐火砖。在我们的例子中，我们想要“你好，多么美好的一天！”和“好吧，我们开始吧！”。为了在没有多个CSS规则的情况下做到这一点，我们通常必须使用一个复合选择器，并做类似这样的事情:</p><pre class="jl jm jn jo fd jp jq jr js aw jt bi"><span id="824d" class="ju jv hi jq b fi jw jx l jy jz">--- HTML ---</span><span id="f816" class="ju jv hi jq b fi ka jx l jy jz">&lt;header&gt;<br/> &lt;h1&gt;Hello, what a wonderful day!&lt;/h1&gt;<br/> &lt;span&gt;Are you ready to learn about pseudo-classes?&lt;/span&gt;<br/> &lt;span&gt;&lt;strong&gt;Well, let's get started!&lt;/strong&gt;&lt;/span&gt; <br/>&lt;/header&gt;</span><span id="58ab" class="ju jv hi jq b fi ka jx l jy jz">&lt;section&gt;<br/> &lt;span&gt;This is another spaaaan.&lt;/span&gt;<br/>&lt;/section&gt; <br/></span><span id="4554" class="ju jv hi jq b fi ka jx l jy jz">--- CSS ---</span><span id="50fd" class="ju jv hi jq b fi ka jx l jy jz">header h1, header strong{<br/>    color: firebrick; <br/>}</span></pre><p id="f54f" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">这里，我们从header标签中获取h1，因为我们在整个页面中有多个跨度，所以我们获取header的strong标签，以便更加具体。尽管这是完全有效的CSS，而且通常非常有用，但它也存在一些问题。</p><p id="3848" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">首先，它有可能变得很长，这取决于选择器的数量和特异性的水平。其次，当将CSS选择器链接在一起时，单个错误/无效的选择器将导致整个CSS规则集中断和无法呈现。</p><pre class="jl jm jn jo fd jp jq jr js aw jt bi"><span id="43bf" class="ju jv hi jq b fi jw jx l jy jz">--- CSS ---</span><span id="32a5" class="ju jv hi jq b fi ka jx l jy jz">/* Oh no, your tired programmer brain made a typo in "strong" that messes up the entire rule! */ </span><span id="ac06" class="ju jv hi jq b fi ka jx l jy jz">header h1, header :strong{<br/>    color: firebrick; <br/>}</span><span id="5e11" class="ju jv hi jq b fi ka jx l jy jz">/* This is quite different than a CSS declaration error (what's inside the brackets). If we did something like seen below, everything up until the error (font-size) will still render. */</span><span id="89f5" class="ju jv hi jq b fi ka jx l jy jz">header h1, header strong{<br/>    color: firebrick; <br/>    margin-bottom: 10px;<br/>    font-size: "I'm LARGE!!!!"<br/>}</span></pre><p id="27d3" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">在<a class="ae jk" href="https://developer.mozilla.org/en-US/docs/Web/CSS/:is" rel="noopener ugc nofollow" target="_blank"> :is()伪类</a>出现的地方，我们可以这样写，而不是像上面那样写我们的复合选择器:</p><pre class="jl jm jn jo fd jp jq jr js aw jt bi"><span id="c0be" class="ju jv hi jq b fi jw jx l jy jz">header :is(h1, strong){<br/>    color: firebrick <br/>}</span></pre><p id="5ab3" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">但是有什么区别呢？为了进行更明显的比较，想象一下，如果最初的标题选择器有更多的后代，它可能看起来像这样:</p><pre class="jl jm jn jo fd jp jq jr js aw jt bi"><span id="ad2e" class="ju jv hi jq b fi jw jx l jy jz">/* Original Syntax */</span><span id="fa8c" class="ju jv hi jq b fi ka jx l jy jz">header h1, <br/>header strong, <br/>header img, <br/>header .btn, <br/>header p {<br/>    color: firebrick; <br/>    margin-bottom: 10px;<br/>    font-size: "Hello world!!!!"<br/>}</span><span id="d60a" class="ju jv hi jq b fi ka jx l jy jz">/* :is() Syntax, equivalent to above */</span><span id="1cf9" class="ju jv hi jq b fi ka jx l jy jz">header :is(h1, strong, img, .btn, p){<br/>    color: firebrick: <br/>    margin-bottom: 10px;<br/>}</span></pre><p id="6d14" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">使用这种语法，您只需要列出父选择器一次，然后在括号中提供您的后代。此外，即使您的后代选择器中有一个错误，其余的选择器也会正确呈现。</p><pre class="jl jm jn jo fd jp jq jr js aw jt bi"><span id="9bb1" class="ju jv hi jq b fi jw jx l jy jz">header :is(h1, strong, :img, .btn, :p){<br/>    color: firebrick: <br/>    margin-bottom: 10px;<br/>}</span><span id="d2b9" class="ju jv hi jq b fi ka jx l jy jz">/* Even though both <strong class="jq hj">img </strong>and <strong class="jq hj">p</strong> invalid selectors, the <strong class="jq hj">h1</strong>, <strong class="jq hj">strong</strong>, and <strong class="jq hj">.btn</strong> class will all still function correctly. */</span></pre><p id="eebf" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">这不仅要用于父代和后代，还可以用于单独对选择器进行分组。我认为这比上面的用途更实际。</p><pre class="jl jm jn jo fd jp jq jr js aw jt bi"><span id="7e32" class="ju jv hi jq b fi jw jx l jy jz">:is(header, .card, small) p:hover {<br/>    color: red;<br/>}</span><span id="5e6e" class="ju jv hi jq b fi ka jx l jy jz">/* code below is equivalent to the code above */</span><span id="9a94" class="ju jv hi jq b fi ka jx l jy jz">header p:hover, <br/>.card p:hover, <br/>small p:hover, {<br/>    color: red;<br/>}</span></pre><p id="41f4" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">我们在这里说，所有的p标签，无论是在一个标题标签，在一个类别的卡，或在一个小标签将是红色的悬停。本质上，is()函数将一个选择器列表作为它的参数，并将它们组合在一起，然后您可以根据需要分配属性。这是一个相对较新的CSS <a class="ae jk" href="https://www.w3schools.com/css/css_pseudo_classes.asp" rel="noopener ugc nofollow" target="_blank">伪类</a>，并且是让你的页面更加<a class="ae jk" href="https://en.wikipedia.org/wiki/Don%27t_repeat_yourself" rel="noopener ugc nofollow" target="_blank">干燥</a>和可读的一个很好的技巧。</p><p id="be72" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><strong class="io hj">注意:</strong>使用:is()语法时要记住的一件事是选择器层次结构。假设我们有一个卡片类，我们希望这个卡片中的特定选择器是绿色的。但是后来我们忘记了我们做了这些，我们试图让这些相同的元素变成不同的颜色。如果一个或多个选择器具有更高的优先级，由于选择器的层次结构，这将不起作用。</p><pre class="jl jm jn jo fd jp jq jr js aw jt bi"><span id="da1e" class="ju jv hi jq b fi jw jx l jy jz"><br/>.card :is(.title, small){<br/>    color: green;<br/>}</span><span id="950d" class="ju jv hi jq b fi ka jx l jy jz">/* Because of the 'title' class in the brackets (classes have more priority than vanilla tags), the one above takes priority. */</span><span id="6196" class="ju jv hi jq b fi ka jx l jy jz">.card small{<br/>    color: blue;<br/>}</span></pre><p id="8359" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">记住所有这些，享受让你的CSS内部和外部一样漂亮的乐趣吧！</p></div></div>    
</body>
</html>