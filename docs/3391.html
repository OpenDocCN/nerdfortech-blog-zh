<html>
<head>
<title>Day 8: Construct Binary Tree from Preorder and Inorder Traversal</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">第八天:根据前序和中序遍历构建二叉树</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/day-8-construct-binary-tree-from-preorder-and-inorder-traversal-18b5bd83115?source=collection_archive---------11-----------------------#2021-06-08">https://medium.com/nerd-for-tech/day-8-construct-binary-tree-from-preorder-and-inorder-traversal-18b5bd83115?source=collection_archive---------11-----------------------#2021-06-08</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="cd2c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> <em class="jd">问题链接:</em> </strong></p><div class="je jf ez fb jg jh"><a href="https://leetcode.com/explore/challenge/card/june-leetcoding-challenge-2021/604/week-2-june-8th-june-14th/3772/" rel="noopener  ugc nofollow" target="_blank"><div class="ji ab dw"><div class="jj ab jk cl cj jl"><h2 class="bd hj fi z dy jm ea eb jn ed ef hh bi translated">探索- LeetCode</h2><div class="jo l"><h3 class="bd b fi z dy jm ea eb jn ed ef dx translated">这个挑战是初学者友好的，对高级和非高级用户都可用。它由 30 个每日…</h3></div><div class="jp l"><p class="bd b fp z dy jm ea eb jn ed ef dx translated">leetcode.com</p></div></div><div class="jq l"><div class="jr l js jt ju jq jv jw jh"/></div></div></a></div><p id="ab16" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> <em class="jd">问题陈述:</em> </strong></p><p id="131f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">给定两个整数数组<code class="du jx jy jz ka b">preorder</code>和<code class="du jx jy jz ka b">inorder</code>，其中<code class="du jx jy jz ka b">preorder</code>是二叉树的前序遍历，<code class="du jx jy jz ka b">inorder</code>是同一棵树的有序遍历，构造并返回<em class="jd">二叉树</em>。</p><figure class="kc kd ke kf fd kg er es paragraph-image"><div class="er es kb"><img src="../Images/6c43a12208362fb3b4ee2f6096cd6058.png" data-original-src="https://miro.medium.com/v2/resize:fit:554/format:webp/0*nsanZpIWb54WOlL5.jpg"/></div></figure><p id="45ad" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> <em class="jd">例 1: </em> </strong></p><pre class="kc kd ke kf fd ki ka kj kk aw kl bi"><span id="d1dc" class="km kn hi ka b fi ko kp l kq kr"><strong class="ka hj">Input:</strong> preorder = [3,9,20,15,7], inorder = [9,3,15,20,7]<br/><strong class="ka hj">Output:</strong> [3,9,20,null,null,15,7]</span></pre><p id="1b15" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> <em class="jd">例二:</em> </strong></p><pre class="kc kd ke kf fd ki ka kj kk aw kl bi"><span id="c725" class="km kn hi ka b fi ko kp l kq kr"><strong class="ka hj">Input:</strong> preorder = [-1], inorder = [-1]<br/><strong class="ka hj">Output:</strong> [-1]</span></pre><p id="e79e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> <em class="jd">约束:</em> </strong></p><pre class="kc kd ke kf fd ki ka kj kk aw kl bi"><span id="8fed" class="km kn hi ka b fi ko kp l kq kr">- 1 &lt;= preorder.length &lt;= 3000<br/>- inorder.length == preorder.length<br/>- -3000 &lt;= preorder[i], inorder[i] &lt;= 3000<br/>- preorder<!-- --> and <!-- -->inorder<!-- --> consist of <strong class="ka hj">unique</strong> values<br/>- Each value of <!-- -->inorder<!-- --> also appears in <!-- -->preorder<br/>- preorder<!-- --> is <strong class="ka hj">guaranteed</strong> to be the preorder traversal of the tree<br/>- inorder<!-- --> is <strong class="ka hj">guaranteed</strong> to be the inorder traversal of the tree</span></pre><p id="e79d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> <em class="jd">我的解决方案:</em> </strong></p><pre class="kc kd ke kf fd ki ka kj kk aw kl bi"><span id="593c" class="km kn hi ka b fi ko kp l kq kr">class Solution:<br/>    def buildTree(self, P: List[int], I: List[int]) -&gt; TreeNode:<br/>        M = {I[i]: i for i in range(len(I))}<br/>        return self.splitTree(P, I, M, 0, 0, len(P)-1)<br/>    <br/>    def splitTree(self, P: List[int], I: List[int], M: dict, pix: int, ileft: int, iright: int) -&gt; TreeNode:<br/>        rval = P[pix]<br/>        root, imid = TreeNode(rval), M[rval]<br/>        if imid &gt; ileft:<br/>            root.left = self.splitTree(P, I, M, pix+1, ileft, imid-1)<br/>        if imid &lt; iright:<br/>            root.right = self.splitTree(P, I, M, pix+imid-ileft+1, imid+1, iright)<br/>        return root</span></pre><p id="ea25" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> <em class="jd">解释:</em> </strong></p><p id="09cd" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">对于这个问题，我们可以利用遍历中节点的顺序。前序遍历是<strong class="ih hj">【节点，左，右】</strong>，而顺序遍历是<strong class="ih hj">【左，节点，右】</strong>。</p><p id="5a48" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们知道树的<strong class="ih hj">根</strong>节点是前序数组的第一个元素(<strong class="ih hj"> P </strong>)。我们还知道，inorder 数组(<strong class="ih hj"> I </strong>)中根元素左边的每个元素都在左子树上，而<strong class="ih hj"> I </strong>中<strong class="ih hj">根</strong>元素右边的所有元素都在右子树上。</p><p id="c683" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">一旦你这样做了，你的问题现在已经减少到一个较小的范围。现在你有了左右子树的有序和前序遍历，你需要找出它们。</p><p id="ab11" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为了实现这一点，我们只需要传递定义<strong class="ih hj"> I </strong>中当前子树的子数组的左右界限(<strong class="ih hj"> ileft，iright </strong>)，以及<strong class="ih hj"> P </strong>中子树的<strong class="ih hj">根</strong>节点的索引(<strong class="ih hj"> pix </strong>)。</p><p id="aebc" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">此时，我们<em class="jd">可以</em>通过<strong class="ih hj"> I </strong>向前迭代，直到我们每次都找到<strong class="ih hj">根</strong>节点的位置(<strong class="ih hj"> imid </strong>，但是那样会把这个解推到<strong class="ih hj">O(N)</strong>的时间复杂度。</p><p id="84d7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">相反，我们可以对<strong class="ih hj"> I </strong>中的值做一个初步的<strong class="ih hj">索引映射</strong> ( <strong class="ih hj"> M </strong>，这样我们就可以在每次递归中查找<strong class="ih hj"> O(1) time </strong>中<strong class="ih hj"> imid </strong>的值。这将以<strong class="ih hj"> O(N) </strong>的<strong class="ih hj">空间复杂度</strong>为代价，将时间复杂度降低到<strong class="ih hj"> O(N) </strong>。</p><p id="a4c4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在每次递归中，如果<strong class="ih hj"> imid = ileft </strong>，那么左边没有节点，所以我们不应该为那一边调用递归。如果<strong class="ih hj"> imid = iright </strong>，这同样适用于右侧。</p><ul class=""><li id="5060" class="ks kt hi ih b ii ij im in iq ku iu kv iy kw jc kx ky kz la bi translated"><strong class="ih hj"> <em class="jd">时间复杂度:O(N) </em> </strong> <em class="jd">其中</em> <strong class="ih hj"> <em class="jd"> N </em> </strong> <em class="jd">是长度</em> <strong class="ih hj"> <em class="jd"> P </em> </strong> <em class="jd">和</em> <strong class="ih hj"> <em class="jd"> I </em> </strong></li><li id="6bb4" class="ks kt hi ih b ii lb im lc iq ld iu le iy lf jc kx ky kz la bi translated"><strong class="ih hj"> <em class="jd">空间复杂度:O(N) </em> </strong> <em class="jd">为</em> <strong class="ih hj"> <em class="jd"> M </em> </strong></li></ul><p id="a57a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">就是这样！</p><p id="ddbe" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果你有兴趣解决更多的问题，请跟随我，和我一起踏上这段旅程。</p><p id="a489" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">明天见！</p><p id="a405" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">干杯！</p></div></div>    
</body>
</html>