<html>
<head>
<title>Run EF Core Integration Tests in a repeatable and isolated way using a public Docker Image with a Real Database</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用带有真实数据库的公共Docker映像，以可重复且隔离的方式运行EF核心集成测试</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/run-ef-core-integration-tests-in-a-repeatable-and-isolated-way-using-a-public-docker-image-with-a-e912a89c7bf4?source=collection_archive---------0-----------------------#2020-12-26">https://medium.com/nerd-for-tech/run-ef-core-integration-tests-in-a-repeatable-and-isolated-way-using-a-public-docker-image-with-a-e912a89c7bf4?source=collection_archive---------0-----------------------#2020-12-26</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="393c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">集成测试是有价值的，它们不同于T2单元测试，更难达到理想状态，尤其是当你使用真实的数据库(而不是内存数据库)时。</p><p id="718c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">至少在你读到这篇文章之前是这样的😎我们将:</p><ol class=""><li id="97dc" class="je jf hi ih b ii ij im in iq jg iu jh iy ji jc jj jk jl jm bi translated">从微软eShopOnWeb ASP.NET核心参考应用程序获得一个<a class="ae jd" href="https://github.com/dotnet-architecture/eShopOnWeb/blob/master/tests/IntegrationTests/Repositories/BasketRepositoryTests/SetQuantities.cs" rel="noopener ugc nofollow" target="_blank">示例集成测试，该测试以可重复且隔离的方式在docker映像和真实数据库中运行；</a></li><li id="b5a6" class="je jf hi ih b ii jn im jo iq jp iu jq iy jr jc jj jk jl jm bi translated">在AWS CodeBuild中设置一个示例持续集成(CI)管道，以在每次我将代码推送到GitHub时提取标准/公共docker映像并运行测试。您将能够轻松地用您喜欢的另一个CI工具(如Azure DevOps或GitHub actions)替换AWS CodeBuild，而无需更改代码；</li></ol></div><div class="ab cl js jt gp ju" role="separator"><span class="jv bw bk jw jx jy"/><span class="jv bw bk jw jx jy"/><span class="jv bw bk jw jx"/></div><div class="hb hc hd he hf"><h1 id="7b73" class="jz ka hi bd kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw bi translated">首先:为什么是真正的数据库而不是内存数据库？</h1><p id="4702" class="pw-post-body-paragraph if ig hi ih b ii kx ik il im ky io ip iq kz is it iu la iw ix iy lb ja jb jc hb bi translated">在我们动手之前，您可能会问:为什么是真正的数据库而不是内存数据库？</p><p id="523f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">嗯，如果您正在运行或想要开始编写涉及实体框架(EF)核心中的内存数据库的测试，很可能在某个时间点，您可能想要对一个真实的数据库运行这些测试。你可能想进行更准确、更有价值的测试。用<a class="ae jd" href="http://Testing with the EF In-Memory Database" rel="noopener ugc nofollow" target="_blank">微软的话说</a>:</p><blockquote class="lc ld le"><p id="874f" class="if ig lf ih b ii ij ik il im in io ip lg ir is it lh iv iw ix li iz ja jb jc hb bi translated">EF内存数据库的行为通常与关系数据库不同。如<a class="ae jd" href="https://docs.microsoft.com/en-us/ef/core/testing/" rel="noopener ugc nofollow" target="_blank">使用EF内核的测试代码</a>中所讨论的，只有在充分理解相关的问题和权衡之后，才使用EF内存数据库。</p></blockquote><p id="564a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">特别是如果您正在使用SQL Server，您可能希望将InMemory数据库与SQLite一起使用，因为它非常符合常见的关系数据库行为，但仍然需要提醒的是，这并不完全相同。<a class="ae jd" href="https://docs.microsoft.com/en-us/ef/core/providers/sqlite/limitations" rel="noopener ugc nofollow" target="_blank"> SQLite提供程序有许多迁移限制。这些限制大部分是由于底层SQLite数据库引擎的限制造成的，并不是EF </a>所特有的。</p><p id="8512" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在这种情况下，您仍然可以使用InMemory DB进行有价值的集成测试，但是如果您可以在可接受的时间内对真实的数据库运行这些测试，那么您就不会有任何损失，反而会有所收获。例如，在我的例子中，我使用内置JSON支持的<a class="ae jd" href="https://www.npgsql.org/efcore/mapping/json.html?tabs=data-annotations%2Cpoco" rel="noopener ugc nofollow" target="_blank"> Postgres DB。SQLite和InMemory DB都不支持Postgres JSON类型</a>，所以我别无选择，只能使用一个真实的数据库来运行我想要的测试！</p><figure class="lk ll lm ln fd lo er es paragraph-image"><div role="button" tabindex="0" class="lp lq di lr bf ls"><div class="er es lj"><img src="../Images/a7499d84498604e12d352dcbade20b6f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dxAoL8JG9KAu8pUbR8MKRA.png"/></div></div><figcaption class="lv lw et er es lx ly bd b be z dx translated">系统。InvalidOperationException:使用Postgres内置JSON支持/column对InMemoryDb运行集成测试</figcaption></figure></div><div class="ab cl js jt gp ju" role="separator"><span class="jv bw bk jw jx jy"/><span class="jv bw bk jw jx jy"/><span class="jv bw bk jw jx"/></div><div class="hb hc hd he hf"><h1 id="99a2" class="jz ka hi bd kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw bi translated">是时候动手了！🤓</h1><p id="472d" class="pw-post-body-paragraph if ig hi ih b ii kx ik il im ky io ip iq kz is it iu la iw ix iy lb ja jb jc hb bi translated">只需克隆<a class="ae jd" href="https://github.com/dotnet-architecture/eShopOnWeb" rel="noopener ugc nofollow" target="_blank"> eShopOnWeb repo </a>并获得一个本地运行的Postgres数据库。Get <a class="ae jd" href="https://hub.docker.com/_/postgres" rel="noopener ugc nofollow" target="_blank">在本地运行Postgres DB实例就像使用docker </a>运行一个命令一样简单(如果您喜欢的话，同样的概念也适用于SQL Server ):</p><pre class="lk ll lm ln fd lz ma mb mc aw md bi"><span id="db8f" class="me ka hi ma b fi mf mg l mh mi">docker run --name some-postgres -e POSTGRES_PASSWORD=mysecretpassword -d postgres</span></pre><p id="d916" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">接下来，我只需更新<a class="ae jd" href="https://github.com/dotnet-architecture/eShopOnWeb/blob/master/tests/IntegrationTests/Repositories/BasketRepositoryTests/SetQuantities.cs#L29" rel="noopener ugc nofollow" target="_blank">设置数量。RemoveEmptyQuantities </a>集成测试使用我的本地Postgres DB(并为<a class="ae jd" href="https://www.npgsql.org/efcore/index.html" rel="noopener ugc nofollow" target="_blank"> Npgsql实体框架核心提供者</a>替换InMemoryDB):</p><figure class="lk ll lm ln fd lo"><div class="bz dy l di"><div class="mj mk l"/></div><figcaption class="lv lw et er es lx ly bd b be z dx translated">eShopOnWeb—tests/integration tests/set quantities . cs与real Postgres数据库</figcaption></figure><figure class="lk ll lm ln fd lo"><div class="bz dy l di"><div class="mj mk l"/></div><figcaption class="lv lw et er es lx ly bd b be z dx translated">eShopOnWeb —使用真实数据库测试/integration tests/integration tests . csproj</figcaption></figure><p id="0477" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果您现在运行测试(<code class="du ml mm mn ma b">dotnet test tests/IntegrationTests/IntegrationTests.csproj</code>)，<strong class="ih hj">第一次成功</strong>，但是<strong class="ih hj">在连续执行</strong>时失败，无论您重试多少次。它之所以失败，是因为与InMemoryDB不同，数据库在测试运行后并没有被销毁，所以它被影响新运行的来自以前运行的数据所污染。换句话说，测试是不可重复的。</p><p id="74f9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在继续前进之前，<a class="ae jd" href="https://ardalis.com/running-integration-tests-in-build-pipelines-with-a-real-database/" rel="noopener ugc nofollow" target="_blank">让我们一致认为</a>:</p><blockquote class="lc ld le"><p id="0aab" class="if ig lf ih b ii ij ik il im in io ip lg ir is it lh iv iw ix li iz ja jb jc hb bi translated">首先，让我们同意，在所有条件相同的情况下，我们希望我们的自动化测试是隔离的、可重复的和快速的。我们以什么顺序运行它们并不重要。如果我们并行运行它们，应该没有问题。我们什么时候运行它们应该没关系。每一个测试都应该存在于它自己的现实的小分支中，并且建立和破坏这个现实应该不需要时间和资源。</p><p id="8961" class="if ig lf ih b ii ij ik il im in io ip lg ir is it lh iv iw ix li iz ja jb jc hb bi translated">我们不太可能达到这种理想状态，但在我们评估不同选项时，有必要提出一些我们追求的目标。</p></blockquote><p id="3607" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">达到理想状态的一个方法是在我每次运行集成测试时旋转并关闭一个新的数据库。它们肯定是独立的和可重复的，我们稍后将评估“有多快”。所以，让我们首先创建一个<code class="du ml mm mn ma b">BaseEfRepoTestFixture</code>:</p><figure class="lk ll lm ln fd lo"><div class="bz dy l di"><div class="mj mk l"/></div><figcaption class="lv lw et er es lx ly bd b be z dx translated">eShopOnWeb—tests/integration tests/baseefrotestfixture . cs</figcaption></figure><p id="2c72" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们的<code class="du ml mm mn ma b">SetQuantities</code>集成测试现在扩展了<code class="du ml mm mn ma b">BaseEfRepoTestFixture</code>:</p><figure class="lk ll lm ln fd lo"><div class="bz dy l di"><div class="mj mk l"/></div><figcaption class="lv lw et er es lx ly bd b be z dx translated">eShopOnWeb—tests/integration tests/set quantities . cs扩展BaseEfRepoTestFixture.cs</figcaption></figure><p id="beaa" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如你所见:</p><ol class=""><li id="fe7a" class="je jf hi ih b ii ij im in iq jg iu jh iy ji jc jj jk jl jm bi translated"><code class="du ml mm mn ma b">BaseEfRepoTestFixture.cs</code>它将始终确保为每个测试类创建一个新的唯一数据库(<code class="du ml mm mn ma b">var dbSuffix = $"{testName}_{Guid.NewGuid()}"</code>)；</li><li id="37ee" class="je jf hi ih b ii jn im jo iq jp iu jq iy jr jc jj jk jl jm bi translated">当测试运行结束时，这个数据库会被自动删除，这样就不会污染您的本地数据库实例。这仅在您本地运行时相关，因为在AWS CodeBuild中，像在许多其他CI工具中一样，包含数据库的容器将在构建结束后被销毁(见下文)；</li></ol><p id="959e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">在这一点上，我们有办法以一种隔离的&amp;可重复的方式运行我们的数据库集成测试，而不管您最终可能使用的CI工具是什么</strong>。然而，<strong class="ih hj">测试的大部分价值在于以自动方式在我们的CI/CD管道中运行</strong>(就像每次有人推送代码一样)。</p><h1 id="6fce" class="jz ka hi bd kb kc mo ke kf kg mp ki kj kk mq km kn ko mr kq kr ks ms ku kv kw bi translated">让它在AWS CodeBuild(或您喜欢的另一个CI工具)中自动运行🚀</h1><p id="c551" class="pw-post-body-paragraph if ig hi ih b ii kx ik il im ky io ip iq kz is it iu la iw ix iy lb ja jb jc hb bi translated">简单！😎。我们所需要的只是在安装了Postgres DB的服务器上运行<code class="du ml mm mn ma b">dotnet test tests/IntegrationTests/IntegrationTests.csproj</code>!大多数CI工具允许您配置用于运行您的构建的服务器/主机。在AWS代码构建中，有多种方式:</p><ol class=""><li id="a16c" class="je jf hi ih b ii ij im in iq jg iu jh iy ji jc jj jk jl jm bi translated">通过<a class="ae jd" href="https://aws.amazon.com/codebuild/features/?nc=sn&amp;loc=1" rel="noopener ugc nofollow" target="_blank">定制构建环境</a>:</li></ol><blockquote class="lc ld le"><p id="95e2" class="if ig lf ih b ii ij ik il im in io ip lg ir is it lh iv iw ix li iz ja jb jc hb bi translated">您可以将自己的构建环境与AWS CodeBuild一起使用，例如Microsoft。NET框架。您可以将用于构建的运行时和工具打包到Docker映像中，并将其上传到公共Docker Hub存储库或Amazon EC2 Container Registry(Amazon ECR)。当您创建一个新的构建项目时，您可以指定Docker映像的位置，CodeBuild将提取该映像并将其用作构建项目配置。</p></blockquote><p id="558a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">2.通过<a class="ae jd" href="https://aws.amazon.com/codebuild/features/?nc=sn&amp;loc=2" rel="noopener ugc nofollow" target="_blank">指定构建命令</a>，确保Postgres DB已安装并运行:</p><blockquote class="lc ld le"><p id="5c6a" class="if ig lf ih b ii ij ik il im in io ip lg ir is it lh iv iw ix li iz ja jb jc hb bi translated">您可以定义希望AWS CodeBuild执行的特定命令，例如安装构建工具包、运行单元测试和打包代码。构建规范是一个YAML文件，允许您选择在构建的每个阶段运行的命令和其他设置。CodeBuild帮助您快速了解常见场景的示例构建规范文件，例如使用Apache Maven、Gradle或npm的构建。</p></blockquote><p id="b337" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我选1。因为:</p><ul class=""><li id="6b4d" class="je jf hi ih b ii ij im in iq jg iu jh iy ji jc mt jk jl jm bi translated"><strong class="ih hj">如果你想在你喜欢的另一个CI工具中做这件事</strong>，你有更多的东西可以重用。例如，<a class="ae jd" href="https://ardalis.com/running-integration-tests-in-build-pipelines-with-a-real-database/" rel="noopener ugc nofollow" target="_blank"> Ardalis也在使用docker镜像在Azure DevOps </a>中运行集成测试；</li><li id="71db" class="je jf hi ih b ii jn im jo iq jp iu jq iy jr jc mt jk jl jm bi translated">在我写作的时候，AWS CodeBuild <a class="ae jd" href="https://docs.aws.amazon.com/codebuild/latest/userguide/build-spec-ref.html#build-spec.phases.install.runtime-versions" rel="noopener ugc nofollow" target="_blank">不支持。NET 5作为一个运行时</a>，所以如果我用2，我必须手动安装。<a class="ae jd" href="https://aws.amazon.com/blogs/developer/net-5-on-aws/" rel="noopener ugc nofollow" target="_blank">支持。NET 5即将到来</a>；</li><li id="983d" class="je jf hi ih b ii jn im jo iq jp iu jq iy jr jc mt jk jl jm bi translated">它比构建命令等更灵活；</li></ul><p id="4fdf" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">因此，让我们创建一个AWS代码构建项目:</p><figure class="lk ll lm ln fd lo er es paragraph-image"><div role="button" tabindex="0" class="lp lq di lr bf ls"><div class="er es mu"><img src="../Images/9b1e84671c2e9d67c01ba95558c5d38a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GMuFmhjiI6bGsrgWJbAWNQ.png"/></div></div><figcaption class="lv lw et er es lx ly bd b be z dx translated">AWS代码构建—源代码配置</figcaption></figure><p id="8540" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在这一步，您可以配置webhooks来自动触发构建，以响应类似于<code class="du ml mm mn ma b">push</code>或<code class="du ml mm mn ma b">pull request</code>的事件(为了简洁起见，我省略了这些事件)。接下来，在环境步骤，确保您选择了一个<a class="ae jd" href="https://hub.docker.com/_/microsoft-dotnet-sdk" rel="noopener ugc nofollow" target="_blank">官方的微软Ubuntu docker映像，它包含。NET 5 SDK安装</a>。这个映像不包含Postgres DB，所以我们将在下一步中安装一个。不太重要但仍然值得一提的是，docker图像是公开的，因此您不需要设置任何凭证就可以下载:</p><figure class="lk ll lm ln fd lo er es paragraph-image"><div role="button" tabindex="0" class="lp lq di lr bf ls"><div class="er es mv"><img src="../Images/924ee3142d401fde83f57467121ae92c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BX8h2C1Ul-IUVBa2lJ6Q3g.png"/></div></div><figcaption class="lv lw et er es lx ly bd b be z dx translated">AWS代码构建—环境配置</figcaption></figure><p id="6c61" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">最后但同样重要的是，我们需要指定一个构建规范文件，我们将在该文件中告诉AWS CodeBuild运行我们的测试:</p><blockquote class="lc ld le"><p id="4574" class="if ig lf ih b ii ij ik il im in io ip lg ir is it lh iv iw ix li iz ja jb jc hb bi translated">构建规范是一个YAML文件，允许您选择在构建的每个阶段运行的命令和其他设置</p></blockquote><figure class="lk ll lm ln fd lo er es paragraph-image"><div role="button" tabindex="0" class="lp lq di lr bf ls"><div class="er es mw"><img src="../Images/4d5c01031dc0876e2de4b94d8b82d079.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lCAUbBKPfO7mVuhlzmK8Ew.png"/></div></div><figcaption class="lv lw et er es lx ly bd b be z dx translated">AWS代码构建—构建规范配置</figcaption></figure><figure class="lk ll lm ln fd lo"><div class="bz dy l di"><div class="mj mk l"/></div><figcaption class="lv lw et er es lx ly bd b be z dx translated">eShopOnWeb—tests/integration tests/<a class="ae jd" href="https://gist.github.com/rfpedrosa/299da67aa2e8090f375411c82b20c0fb#file-integration-tests-buildspec-yml" rel="noopener ugc nofollow" target="_blank">integration-tests-build spec . yml</a></figcaption></figure><p id="58bb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如你所见，我(按此顺序):</p><ol class=""><li id="cdff" class="je jf hi ih b ii ij im in iq jg iu jh iy ji jc jj jk jl jm bi translated">安装Postgres数据库。这需要时间，所以在未来，我可能会想使用一个docker图像已经安装了Postgres数据库😉</li><li id="10fd" class="je jf hi ih b ii jn im jo iq jp iu jq iy jr jc jj jk jl jm bi translated">确保数据库正在运行，并且<code class="du ml mm mn ma b">postgres</code>用户拥有连接字符串中的密码；</li><li id="dce8" class="je jf hi ih b ii jn im jo iq jp iu jq iy jr jc jj jk jl jm bi translated">运行测试！</li></ol><p id="9610" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">瞧！如果现在触发生成，测试将成功运行。每次做的时候！不管你做多少次。因为它们是可重复的，并且通过每次测试使用一个独立的真实数据库来隔离。恭喜你。👏👏🚀</p><figure class="lk ll lm ln fd lo er es paragraph-image"><div role="button" tabindex="0" class="lp lq di lr bf ls"><div class="er es mx"><img src="../Images/dd6d828f51e4587c853012e8cd3c9e66.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*q5MY9zor2vJpNM_ek3dVzQ.png"/></div></div><figcaption class="lv lw et er es lx ly bd b be z dx translated">AWS代码构建—成功构建</figcaption></figure><figure class="lk ll lm ln fd lo er es paragraph-image"><div role="button" tabindex="0" class="lp lq di lr bf ls"><div class="er es my"><img src="../Images/992ab5e70daa76dae2252bf8b058f0c7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*T-yjraRUekOK07FvGkU3yw.png"/></div></div><figcaption class="lv lw et er es lx ly bd b be z dx translated">AWS代码构建—测试成功</figcaption></figure><h1 id="b867" class="jz ka hi bd kb kc mo ke kf kg mp ki kj kk mq km kn ko mr kq kr ks ms ku kv kw bi translated">大概有多快？</h1><p id="643c" class="pw-post-body-paragraph if ig hi ih b ii kx ik il im ky io ip iq kz is it iu la iw ix iy lb ja jb jc hb bi translated">嗯，<a class="ae jd" href="https://docs.microsoft.com/en-us/aspnet/core/test/integration-tests?view=aspnetcore-5.0#introduction-to-integration-tests" rel="noopener ugc nofollow" target="_blank">首先是</a>:</p><blockquote class="lc ld le"><p id="9397" class="if ig lf ih b ii ij ik il im in io ip lg ir is it lh iv iw ix li iz ja jb jc hb bi translated">不要为数据库和文件系统的数据和文件访问的每一种可能的排列编写集成测试。不管应用程序中有多少地方与数据库和文件系统交互，一组集中的读取、写入、更新和删除集成测试通常能够充分测试数据库和文件系统组件。使用单元测试对与这些组件交互的方法逻辑进行常规测试。在单元测试中，使用基础设施伪造品/模拟会导致更快的测试执行。</p></blockquote><p id="bdb0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">其次，从上面的截图可以看出，在15 GB内存、8个vCPUs的AWS CodeBuild实例中运行2次集成测试只需要不到3.5s的时间。通过简单的数学计算，并假设在未来的集成测试中有类似的复杂性，我猜想运行100次大约需要175秒。</p><p id="818b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">第三，您还应该考虑服务器是否能够并行运行所有这些测试(默认情况下是这样的)。例如，我有一个客户/项目有35个测试，在我的2，3 GHz 8核Intel Core i9 / 32GB mac上本地运行这些测试很快，但当我试图在AWS CodeBuild 15 GB内存、8个vCPUs实例上运行这些测试时，构建因超时而失败！它们只能在AWS CodeBuild 145 GB内存和72个vCPUs实例中运行，但很自然，这很昂贵，并且表明我没有走上正确的道路。解决方案？嗯，我刚刚给<a class="ae jd" href="https://stackoverflow.com/questions/1408175/execute-unit-tests-serially-rather-than-in-parallel" rel="noopener ugc nofollow" target="_blank">项目添加了一个<code class="du ml mm mn ma b">xunit.runner.json</code>文件，确保测试按顺序(也不是并行)运行</a>。对我来说，他们仍然在一个可接受的时间内执行，在每一个稳定的分支。对你来说还是太久了？你有很多测试吗？替代品？<a class="ae jd" href="https://github.com/ardalis/Specification/blob/master/ArdalisSpecificationEF/tests/Ardalis.Specification.EF.IntegrationTests/SpecificationTests.cs" rel="noopener ugc nofollow" target="_blank">有些人使用共享数据库</a>，你也可以考虑将集成测试拆分到一个单独的测试套件中，并可能在不同于我的单元测试套件的时间表上运行它们(例如，每晚而不是每次提交)，等等，但所有这些解决方案看起来都像是B计划，因为在测试可重复且孤立的状态下更难实现。</p><h1 id="ade2" class="jz ka hi bd kb kc mo ke kf kg mp ki kj kk mq km kn ko mr kq kr ks ms ku kv kw bi translated">综上</h1><p id="1f3f" class="pw-post-body-paragraph if ig hi ih b ii kx ik il im ky io ip iq kz is it iu la iw ix iy lb ja jb jc hb bi translated">我希望通过展示一种方法来帮助您:</p><ol class=""><li id="ac75" class="je jf hi ih b ii ij im in iq jg iu jh iy ji jc jj jk jl jm bi translated">编写以可重复和隔离的方式运行的EF核心集成测试(不管您使用什么CI工具)；</li><li id="8c31" class="je jf hi ih b ii jn im jo iq jp iu jq iy jr jc jj jk jl jm bi translated">让它在一个CI工具(AWS CodeBuild)中运行，以一种可以移植到您喜欢的另一个CI工具的方式；</li><li id="7eb6" class="je jf hi ih b ii jn im jo iq jp iu jq iy jr jc jj jk jl jm bi translated">围绕集成测试讨论一些常见问题(和解决方案)；</li></ol><p id="46e1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><a class="ae jd" href="https://github.com/rfpedrosa/eShopOnWeb/tree/integration_test_aws_codebuild" rel="noopener ugc nofollow" target="_blank">所有代码都在我的GitHub账号</a>里。这意味着一些小的改进，比如<a class="ae jd" href="https://github.com/rfpedrosa/eShopOnWeb/blob/integration_test_aws_codebuild/tests/IntegrationTests/Repositories/BaseEfRepoTestFixture.cs#L43" rel="noopener ugc nofollow" target="_blank">为每个环境设置不同的连接字符串</a>。</p><figure class="lk ll lm ln fd lo er es paragraph-image"><div role="button" tabindex="0" class="lp lq di lr bf ls"><div class="er es mz"><img src="../Images/318f2a5cc531d10d6be3f158b8176e64.png" data-original-src="https://miro.medium.com/v2/resize:fit:1240/format:webp/0*M5xVSBbna5F4b9MT.jpeg"/></div></div><figcaption class="lv lw et er es lx ly bd b be z dx translated">反馈</figcaption></figure></div></div>    
</body>
</html>