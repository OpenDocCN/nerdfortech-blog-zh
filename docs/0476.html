<html>
<head>
<title>Run EF Core Integration Tests in a repeatable and isolated way using a public Docker Image with a Real Database</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用带有真实数据库的公共 Docker 映像，以可重复且隔离的方式运行 EF 核心集成测试</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/run-ef-core-integration-tests-in-a-repeatable-and-isolated-way-using-a-public-docker-image-with-a-e912a89c7bf4?source=collection_archive---------0-----------------------#2020-12-26">https://medium.com/nerd-for-tech/run-ef-core-integration-tests-in-a-repeatable-and-isolated-way-using-a-public-docker-image-with-a-e912a89c7bf4?source=collection_archive---------0-----------------------#2020-12-26</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="393c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">集成测试是有价值的，它们不同于 T2 单元测试，更难达到理想状态，尤其是当你使用真实的数据库(而不是内存数据库)时。</p><p id="718c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">至少在你读到这篇文章之前是这样的😎我们将:</p><ol class=""><li id="97dc" class="je jf hi ih b ii ij im in iq jg iu jh iy ji jc jj jk jl jm bi translated">从微软 eShopOnWeb ASP.NET 核心参考应用程序获得一个<a class="ae jd" href="https://github.com/dotnet-architecture/eShopOnWeb/blob/master/tests/IntegrationTests/Repositories/BasketRepositoryTests/SetQuantities.cs" rel="noopener ugc nofollow" target="_blank">示例集成测试，该测试以可重复且隔离的方式在 docker 映像和真实数据库中运行；</a></li><li id="b5a6" class="je jf hi ih b ii jn im jo iq jp iu jq iy jr jc jj jk jl jm bi translated">在 AWS CodeBuild 中设置一个示例持续集成(CI)管道，以在每次我将代码推送到 GitHub 时提取标准/公共 docker 映像并运行测试。您将能够轻松地用您喜欢的另一个 CI 工具(如 Azure DevOps 或 GitHub actions)替换 AWS CodeBuild，而无需更改代码；</li></ol></div><div class="ab cl js jt gp ju" role="separator"><span class="jv bw bk jw jx jy"/><span class="jv bw bk jw jx jy"/><span class="jv bw bk jw jx"/></div><div class="hb hc hd he hf"><h1 id="7b73" class="jz ka hi bd kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw bi translated">首先:为什么是真正的数据库而不是内存数据库？</h1><p id="4702" class="pw-post-body-paragraph if ig hi ih b ii kx ik il im ky io ip iq kz is it iu la iw ix iy lb ja jb jc hb bi translated">在我们动手之前，您可能会问:为什么是真正的数据库而不是内存数据库？</p><p id="523f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">嗯，如果您正在运行或想要开始编写涉及实体框架(EF)核心中的内存数据库的测试，很可能在某个时间点，您可能想要对一个真实的数据库运行这些测试。你可能想进行更准确、更有价值的测试。用<a class="ae jd" href="http://Testing with the EF In-Memory Database" rel="noopener ugc nofollow" target="_blank">微软的话说</a>:</p><blockquote class="lc ld le"><p id="874f" class="if ig lf ih b ii ij ik il im in io ip lg ir is it lh iv iw ix li iz ja jb jc hb bi translated">EF 内存数据库的行为通常与关系数据库不同。如<a class="ae jd" href="https://docs.microsoft.com/en-us/ef/core/testing/" rel="noopener ugc nofollow" target="_blank">使用 EF 内核的测试代码</a>中所讨论的，只有在充分理解相关的问题和权衡之后，才使用 EF 内存数据库。</p></blockquote><p id="564a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">特别是如果您正在使用 SQL Server，您可能希望将 InMemory 数据库与 SQLite 一起使用，因为它非常符合常见的关系数据库行为，但仍然需要提醒的是，这并不完全相同。<a class="ae jd" href="https://docs.microsoft.com/en-us/ef/core/providers/sqlite/limitations" rel="noopener ugc nofollow" target="_blank"> SQLite 提供程序有许多迁移限制。这些限制大部分是由于底层 SQLite 数据库引擎的限制造成的，并不是 EF </a>所特有的。</p><p id="8512" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在这种情况下，您仍然可以使用 InMemory DB 进行有价值的集成测试，但是如果您可以在可接受的时间内对真实的数据库运行这些测试，那么您就不会有任何损失，反而会有所收获。例如，在我的例子中，我使用内置 JSON 支持的<a class="ae jd" href="https://www.npgsql.org/efcore/mapping/json.html?tabs=data-annotations%2Cpoco" rel="noopener ugc nofollow" target="_blank"> Postgres DB。SQLite 和 InMemory DB 都不支持 Postgres JSON 类型</a>，所以我别无选择，只能使用一个真实的数据库来运行我想要的测试！</p><figure class="lk ll lm ln fd lo er es paragraph-image"><div role="button" tabindex="0" class="lp lq di lr bf ls"><div class="er es lj"><img src="../Images/a7499d84498604e12d352dcbade20b6f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dxAoL8JG9KAu8pUbR8MKRA.png"/></div></div><figcaption class="lv lw et er es lx ly bd b be z dx translated">系统。InvalidOperationException:使用 Postgres 内置 JSON 支持/column 对 InMemoryDb 运行集成测试</figcaption></figure></div><div class="ab cl js jt gp ju" role="separator"><span class="jv bw bk jw jx jy"/><span class="jv bw bk jw jx jy"/><span class="jv bw bk jw jx"/></div><div class="hb hc hd he hf"><h1 id="99a2" class="jz ka hi bd kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw bi translated">是时候动手了！🤓</h1><p id="472d" class="pw-post-body-paragraph if ig hi ih b ii kx ik il im ky io ip iq kz is it iu la iw ix iy lb ja jb jc hb bi translated">只需克隆<a class="ae jd" href="https://github.com/dotnet-architecture/eShopOnWeb" rel="noopener ugc nofollow" target="_blank"> eShopOnWeb repo </a>并获得一个本地运行的 Postgres 数据库。Get <a class="ae jd" href="https://hub.docker.com/_/postgres" rel="noopener ugc nofollow" target="_blank">在本地运行 Postgres DB 实例就像使用 docker </a>运行一个命令一样简单(如果您喜欢的话，同样的概念也适用于 SQL Server ):</p><pre class="lk ll lm ln fd lz ma mb mc aw md bi"><span id="db8f" class="me ka hi ma b fi mf mg l mh mi">docker run --name some-postgres -e POSTGRES_PASSWORD=mysecretpassword -d postgres</span></pre><p id="d916" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">接下来，我只需更新<a class="ae jd" href="https://github.com/dotnet-architecture/eShopOnWeb/blob/master/tests/IntegrationTests/Repositories/BasketRepositoryTests/SetQuantities.cs#L29" rel="noopener ugc nofollow" target="_blank">设置数量。RemoveEmptyQuantities </a>集成测试使用我的本地 Postgres DB(并为<a class="ae jd" href="https://www.npgsql.org/efcore/index.html" rel="noopener ugc nofollow" target="_blank"> Npgsql 实体框架核心提供者</a>替换 InMemoryDB):</p><figure class="lk ll lm ln fd lo"><div class="bz dy l di"><div class="mj mk l"/></div><figcaption class="lv lw et er es lx ly bd b be z dx translated">eShopOnWeb—tests/integration tests/set quantities . cs 与 real Postgres 数据库</figcaption></figure><figure class="lk ll lm ln fd lo"><div class="bz dy l di"><div class="mj mk l"/></div><figcaption class="lv lw et er es lx ly bd b be z dx translated">eShopOnWeb —使用真实数据库测试/integration tests/integration tests . csproj</figcaption></figure><p id="0477" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果您现在运行测试(<code class="du ml mm mn ma b">dotnet test tests/IntegrationTests/IntegrationTests.csproj</code>)，<strong class="ih hj">第一次成功</strong>，但是<strong class="ih hj">在连续执行</strong>时失败，无论您重试多少次。它之所以失败，是因为与 InMemoryDB 不同，数据库在测试运行后并没有被销毁，所以它被影响新运行的来自以前运行的数据所污染。换句话说，测试是不可重复的。</p><p id="74f9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在继续前进之前，<a class="ae jd" href="https://ardalis.com/running-integration-tests-in-build-pipelines-with-a-real-database/" rel="noopener ugc nofollow" target="_blank">让我们一致认为</a>:</p><blockquote class="lc ld le"><p id="0aab" class="if ig lf ih b ii ij ik il im in io ip lg ir is it lh iv iw ix li iz ja jb jc hb bi translated">首先，让我们同意，在所有条件相同的情况下，我们希望我们的自动化测试是隔离的、可重复的和快速的。我们以什么顺序运行它们并不重要。如果我们并行运行它们，应该没有问题。我们什么时候运行它们应该没关系。每一个测试都应该存在于它自己的现实的小分支中，并且建立和破坏这个现实应该不需要时间和资源。</p><p id="8961" class="if ig lf ih b ii ij ik il im in io ip lg ir is it lh iv iw ix li iz ja jb jc hb bi translated">我们不太可能达到这种理想状态，但在我们评估不同选项时，有必要提出一些我们追求的目标。</p></blockquote><p id="3607" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">达到理想状态的一个方法是在我每次运行集成测试时旋转并关闭一个新的数据库。它们肯定是独立的和可重复的，我们稍后将评估“有多快”。所以，让我们首先创建一个<code class="du ml mm mn ma b">BaseEfRepoTestFixture</code>:</p><figure class="lk ll lm ln fd lo"><div class="bz dy l di"><div class="mj mk l"/></div><figcaption class="lv lw et er es lx ly bd b be z dx translated">eShopOnWeb—tests/integration tests/baseefrotestfixture . cs</figcaption></figure><p id="2c72" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们的<code class="du ml mm mn ma b">SetQuantities</code>集成测试现在扩展了<code class="du ml mm mn ma b">BaseEfRepoTestFixture</code>:</p><figure class="lk ll lm ln fd lo"><div class="bz dy l di"><div class="mj mk l"/></div><figcaption class="lv lw et er es lx ly bd b be z dx translated">eShopOnWeb—tests/integration tests/set quantities . cs 扩展 BaseEfRepoTestFixture.cs</figcaption></figure><p id="beaa" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如你所见:</p><ol class=""><li id="fe7a" class="je jf hi ih b ii ij im in iq jg iu jh iy ji jc jj jk jl jm bi translated"><code class="du ml mm mn ma b">BaseEfRepoTestFixture.cs</code>它将始终确保为每个测试类创建一个新的唯一数据库(<code class="du ml mm mn ma b">var dbSuffix = $"{testName}_{Guid.NewGuid()}"</code>)；</li><li id="37ee" class="je jf hi ih b ii jn im jo iq jp iu jq iy jr jc jj jk jl jm bi translated">当测试运行结束时，这个数据库会被自动删除，这样就不会污染您的本地数据库实例。这仅在您本地运行时相关，因为在 AWS CodeBuild 中，像在许多其他 CI 工具中一样，包含数据库的容器将在构建结束后被销毁(见下文)；</li></ol><p id="959e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">在这一点上，我们有办法以一种隔离的&amp;可重复的方式运行我们的数据库集成测试，而不管您最终可能使用的 CI 工具是什么</strong>。然而，<strong class="ih hj">测试的大部分价值在于以自动方式在我们的 CI/CD 管道中运行</strong>(就像每次有人推送代码一样)。</p><h1 id="6fce" class="jz ka hi bd kb kc mo ke kf kg mp ki kj kk mq km kn ko mr kq kr ks ms ku kv kw bi translated">让它在 AWS CodeBuild(或您喜欢的另一个 CI 工具)中自动运行🚀</h1><p id="c551" class="pw-post-body-paragraph if ig hi ih b ii kx ik il im ky io ip iq kz is it iu la iw ix iy lb ja jb jc hb bi translated">简单！😎。我们所需要的只是在安装了 Postgres DB 的服务器上运行<code class="du ml mm mn ma b">dotnet test tests/IntegrationTests/IntegrationTests.csproj</code>!大多数 CI 工具允许您配置用于运行您的构建的服务器/主机。在 AWS 代码构建中，有多种方式:</p><ol class=""><li id="a16c" class="je jf hi ih b ii ij im in iq jg iu jh iy ji jc jj jk jl jm bi translated">通过<a class="ae jd" href="https://aws.amazon.com/codebuild/features/?nc=sn&amp;loc=1" rel="noopener ugc nofollow" target="_blank">定制构建环境</a>:</li></ol><blockquote class="lc ld le"><p id="95e2" class="if ig lf ih b ii ij ik il im in io ip lg ir is it lh iv iw ix li iz ja jb jc hb bi translated">您可以将自己的构建环境与 AWS CodeBuild 一起使用，例如 Microsoft。NET 框架。您可以将用于构建的运行时和工具打包到 Docker 映像中，并将其上传到公共 Docker Hub 存储库或 Amazon EC2 Container Registry(Amazon ECR)。当您创建一个新的构建项目时，您可以指定 Docker 映像的位置，CodeBuild 将提取该映像并将其用作构建项目配置。</p></blockquote><p id="558a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">2.通过<a class="ae jd" href="https://aws.amazon.com/codebuild/features/?nc=sn&amp;loc=2" rel="noopener ugc nofollow" target="_blank">指定构建命令</a>，确保 Postgres DB 已安装并运行:</p><blockquote class="lc ld le"><p id="5c6a" class="if ig lf ih b ii ij ik il im in io ip lg ir is it lh iv iw ix li iz ja jb jc hb bi translated">您可以定义希望 AWS CodeBuild 执行的特定命令，例如安装构建工具包、运行单元测试和打包代码。构建规范是一个 YAML 文件，允许您选择在构建的每个阶段运行的命令和其他设置。CodeBuild 帮助您快速了解常见场景的示例构建规范文件，例如使用 Apache Maven、Gradle 或 npm 的构建。</p></blockquote><p id="b337" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我选 1。因为:</p><ul class=""><li id="6b4d" class="je jf hi ih b ii ij im in iq jg iu jh iy ji jc mt jk jl jm bi translated"><strong class="ih hj">如果你想在你喜欢的另一个 CI 工具中做这件事</strong>，你有更多的东西可以重用。例如，<a class="ae jd" href="https://ardalis.com/running-integration-tests-in-build-pipelines-with-a-real-database/" rel="noopener ugc nofollow" target="_blank"> Ardalis 也在使用 docker 镜像在 Azure DevOps </a>中运行集成测试；</li><li id="71db" class="je jf hi ih b ii jn im jo iq jp iu jq iy jr jc mt jk jl jm bi translated">在我写作的时候，AWS CodeBuild <a class="ae jd" href="https://docs.aws.amazon.com/codebuild/latest/userguide/build-spec-ref.html#build-spec.phases.install.runtime-versions" rel="noopener ugc nofollow" target="_blank">不支持。NET 5 作为一个运行时</a>，所以如果我用 2，我必须手动安装。<a class="ae jd" href="https://aws.amazon.com/blogs/developer/net-5-on-aws/" rel="noopener ugc nofollow" target="_blank">支持。NET 5 即将到来</a>；</li><li id="983d" class="je jf hi ih b ii jn im jo iq jp iu jq iy jr jc mt jk jl jm bi translated">它比构建命令等更灵活；</li></ul><p id="4fdf" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">因此，让我们创建一个 AWS 代码构建项目:</p><figure class="lk ll lm ln fd lo er es paragraph-image"><div role="button" tabindex="0" class="lp lq di lr bf ls"><div class="er es mu"><img src="../Images/9b1e84671c2e9d67c01ba95558c5d38a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GMuFmhjiI6bGsrgWJbAWNQ.png"/></div></div><figcaption class="lv lw et er es lx ly bd b be z dx translated">AWS 代码构建—源代码配置</figcaption></figure><p id="8540" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在这一步，您可以配置 webhooks 来自动触发构建，以响应类似于<code class="du ml mm mn ma b">push</code>或<code class="du ml mm mn ma b">pull request</code>的事件(为了简洁起见，我省略了这些事件)。接下来，在环境步骤，确保您选择了一个<a class="ae jd" href="https://hub.docker.com/_/microsoft-dotnet-sdk" rel="noopener ugc nofollow" target="_blank">官方的微软 Ubuntu docker 映像，它包含。NET 5 SDK 安装</a>。这个映像不包含 Postgres DB，所以我们将在下一步中安装一个。不太重要但仍然值得一提的是，docker 图像是公开的，因此您不需要设置任何凭证就可以下载:</p><figure class="lk ll lm ln fd lo er es paragraph-image"><div role="button" tabindex="0" class="lp lq di lr bf ls"><div class="er es mv"><img src="../Images/924ee3142d401fde83f57467121ae92c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BX8h2C1Ul-IUVBa2lJ6Q3g.png"/></div></div><figcaption class="lv lw et er es lx ly bd b be z dx translated">AWS 代码构建—环境配置</figcaption></figure><p id="6c61" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">最后但同样重要的是，我们需要指定一个构建规范文件，我们将在该文件中告诉 AWS CodeBuild 运行我们的测试:</p><blockquote class="lc ld le"><p id="4574" class="if ig lf ih b ii ij ik il im in io ip lg ir is it lh iv iw ix li iz ja jb jc hb bi translated">构建规范是一个 YAML 文件，允许您选择在构建的每个阶段运行的命令和其他设置</p></blockquote><figure class="lk ll lm ln fd lo er es paragraph-image"><div role="button" tabindex="0" class="lp lq di lr bf ls"><div class="er es mw"><img src="../Images/4d5c01031dc0876e2de4b94d8b82d079.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lCAUbBKPfO7mVuhlzmK8Ew.png"/></div></div><figcaption class="lv lw et er es lx ly bd b be z dx translated">AWS 代码构建—构建规范配置</figcaption></figure><figure class="lk ll lm ln fd lo"><div class="bz dy l di"><div class="mj mk l"/></div><figcaption class="lv lw et er es lx ly bd b be z dx translated">eShopOnWeb—tests/integration tests/<a class="ae jd" href="https://gist.github.com/rfpedrosa/299da67aa2e8090f375411c82b20c0fb#file-integration-tests-buildspec-yml" rel="noopener ugc nofollow" target="_blank">integration-tests-build spec . yml</a></figcaption></figure><p id="58bb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如你所见，我(按此顺序):</p><ol class=""><li id="cdff" class="je jf hi ih b ii ij im in iq jg iu jh iy ji jc jj jk jl jm bi translated">安装 Postgres 数据库。这需要时间，所以在未来，我可能会想使用一个 docker 图像已经安装了 Postgres 数据库😉</li><li id="10fd" class="je jf hi ih b ii jn im jo iq jp iu jq iy jr jc jj jk jl jm bi translated">确保数据库正在运行，并且<code class="du ml mm mn ma b">postgres</code>用户拥有连接字符串中的密码；</li><li id="dce8" class="je jf hi ih b ii jn im jo iq jp iu jq iy jr jc jj jk jl jm bi translated">运行测试！</li></ol><p id="9610" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">瞧！如果现在触发生成，测试将成功运行。每次做的时候！不管你做多少次。因为它们是可重复的，并且通过每次测试使用一个独立的真实数据库来隔离。恭喜你。👏👏🚀</p><figure class="lk ll lm ln fd lo er es paragraph-image"><div role="button" tabindex="0" class="lp lq di lr bf ls"><div class="er es mx"><img src="../Images/dd6d828f51e4587c853012e8cd3c9e66.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*q5MY9zor2vJpNM_ek3dVzQ.png"/></div></div><figcaption class="lv lw et er es lx ly bd b be z dx translated">AWS 代码构建—成功构建</figcaption></figure><figure class="lk ll lm ln fd lo er es paragraph-image"><div role="button" tabindex="0" class="lp lq di lr bf ls"><div class="er es my"><img src="../Images/992ab5e70daa76dae2252bf8b058f0c7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*T-yjraRUekOK07FvGkU3yw.png"/></div></div><figcaption class="lv lw et er es lx ly bd b be z dx translated">AWS 代码构建—测试成功</figcaption></figure><h1 id="b867" class="jz ka hi bd kb kc mo ke kf kg mp ki kj kk mq km kn ko mr kq kr ks ms ku kv kw bi translated">大概有多快？</h1><p id="643c" class="pw-post-body-paragraph if ig hi ih b ii kx ik il im ky io ip iq kz is it iu la iw ix iy lb ja jb jc hb bi translated">嗯，<a class="ae jd" href="https://docs.microsoft.com/en-us/aspnet/core/test/integration-tests?view=aspnetcore-5.0#introduction-to-integration-tests" rel="noopener ugc nofollow" target="_blank">首先是</a>:</p><blockquote class="lc ld le"><p id="9397" class="if ig lf ih b ii ij ik il im in io ip lg ir is it lh iv iw ix li iz ja jb jc hb bi translated">不要为数据库和文件系统的数据和文件访问的每一种可能的排列编写集成测试。不管应用程序中有多少地方与数据库和文件系统交互，一组集中的读取、写入、更新和删除集成测试通常能够充分测试数据库和文件系统组件。使用单元测试对与这些组件交互的方法逻辑进行常规测试。在单元测试中，使用基础设施伪造品/模拟会导致更快的测试执行。</p></blockquote><p id="bdb0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">其次，从上面的截图可以看出，在 15 GB 内存、8 个 vCPUs 的 AWS CodeBuild 实例中运行 2 次集成测试只需要不到 3.5s 的时间。通过简单的数学计算，并假设在未来的集成测试中有类似的复杂性，我猜想运行 100 次大约需要 175 秒。</p><p id="818b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">第三，您还应该考虑服务器是否能够并行运行所有这些测试(默认情况下是这样的)。例如，我有一个客户/项目有 35 个测试，在我的 2，3 GHz 8 核 Intel Core i9 / 32GB mac 上本地运行这些测试很快，但当我试图在 AWS CodeBuild 15 GB 内存、8 个 vCPUs 实例上运行这些测试时，构建因超时而失败！它们只能在 AWS CodeBuild 145 GB 内存和 72 个 vCPUs 实例中运行，但很自然，这很昂贵，并且表明我没有走上正确的道路。解决方案？嗯，我刚刚给<a class="ae jd" href="https://stackoverflow.com/questions/1408175/execute-unit-tests-serially-rather-than-in-parallel" rel="noopener ugc nofollow" target="_blank">项目添加了一个<code class="du ml mm mn ma b">xunit.runner.json</code>文件，确保测试按顺序(也不是并行)运行</a>。对我来说，他们仍然在一个可接受的时间内执行，在每一个稳定的分支。对你来说还是太久了？你有很多测试吗？替代品？<a class="ae jd" href="https://github.com/ardalis/Specification/blob/master/ArdalisSpecificationEF/tests/Ardalis.Specification.EF.IntegrationTests/SpecificationTests.cs" rel="noopener ugc nofollow" target="_blank">有些人使用共享数据库</a>，你也可以考虑将集成测试拆分到一个单独的测试套件中，并可能在不同于我的单元测试套件的时间表上运行它们(例如，每晚而不是每次提交)，等等，但所有这些解决方案看起来都像是 B 计划，因为在测试可重复且孤立的状态下更难实现。</p><h1 id="ade2" class="jz ka hi bd kb kc mo ke kf kg mp ki kj kk mq km kn ko mr kq kr ks ms ku kv kw bi translated">综上</h1><p id="1f3f" class="pw-post-body-paragraph if ig hi ih b ii kx ik il im ky io ip iq kz is it iu la iw ix iy lb ja jb jc hb bi translated">我希望通过展示一种方法来帮助您:</p><ol class=""><li id="ac75" class="je jf hi ih b ii ij im in iq jg iu jh iy ji jc jj jk jl jm bi translated">编写以可重复和隔离的方式运行的 EF 核心集成测试(不管您使用什么 CI 工具)；</li><li id="8c31" class="je jf hi ih b ii jn im jo iq jp iu jq iy jr jc jj jk jl jm bi translated">让它在一个 CI 工具(AWS CodeBuild)中运行，以一种可以移植到您喜欢的另一个 CI 工具的方式；</li><li id="7eb6" class="je jf hi ih b ii jn im jo iq jp iu jq iy jr jc jj jk jl jm bi translated">围绕集成测试讨论一些常见问题(和解决方案)；</li></ol><p id="46e1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><a class="ae jd" href="https://github.com/rfpedrosa/eShopOnWeb/tree/integration_test_aws_codebuild" rel="noopener ugc nofollow" target="_blank">所有代码都在我的 GitHub 账号</a>里。这意味着一些小的改进，比如<a class="ae jd" href="https://github.com/rfpedrosa/eShopOnWeb/blob/integration_test_aws_codebuild/tests/IntegrationTests/Repositories/BaseEfRepoTestFixture.cs#L43" rel="noopener ugc nofollow" target="_blank">为每个环境设置不同的连接字符串</a>。</p><figure class="lk ll lm ln fd lo er es paragraph-image"><div role="button" tabindex="0" class="lp lq di lr bf ls"><div class="er es mz"><img src="../Images/318f2a5cc531d10d6be3f158b8176e64.png" data-original-src="https://miro.medium.com/v2/resize:fit:1240/format:webp/0*M5xVSBbna5F4b9MT.jpeg"/></div></div><figcaption class="lv lw et er es lx ly bd b be z dx translated">反馈</figcaption></figure></div></div>    
</body>
</html>