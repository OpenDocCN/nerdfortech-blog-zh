<html>
<head>
<title>Understanding TypeScript Generics</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">了解类型脚本泛型</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/understanding-typescript-generics-f71495588d91?source=collection_archive---------4-----------------------#2021-08-11">https://medium.com/nerd-for-tech/understanding-typescript-generics-f71495588d91?source=collection_archive---------4-----------------------#2021-08-11</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/8254cd67b67523b17a3d4a421b672f14.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7nMs_0tzji8h3uwcWxMPPw.png"/></div></div></figure><p id="3e08" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在之前的一篇文章中，我谈到了如何在函数上创建显式类型来更好地控制输入。简单回顾一下，您可以通过在参数后添加一个冒号并指定类型来做到这一点。</p><figure class="jq jr js jt fd ij er es paragraph-image"><div class="er es jp"><img src="../Images/4c9a63986f3577fd2ac9bd2d95f164cc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1312/format:webp/1*1Cu02HVLh98NH4CtLjcCVA.png"/></div></figure><p id="6fdf" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">实际上你可以用另一种方法，用泛型。在上面的例子中，我将用数组<number>替换数字[]。我在小于()符号中指定的任何类型都将是TypeScript编译器为该参数设置的类型。</number></p><figure class="jq jr js jt fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ju"><img src="../Images/a29f3ff3a01ec8e1e8ec79ab1532bd5a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*06fNwHYguaV8_gBqdxY7Ag.png"/></div></div></figure><p id="e73c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">你可能想知道“这有什么用？”我要说的是，在这种特殊情况下，它不是。关于如何使用泛型的更多上下文，让我们看另一个例子。</p></div><div class="ab cl jv jw gp jx" role="separator"><span class="jy bw bk jz ka kb"/><span class="jy bw bk jz ka kb"/><span class="jy bw bk jz ka"/></div><div class="hb hc hd he hf"><p id="bfcb" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我创建了一个名为addDate的函数，它接受一个对象并返回一个添加了日期属性的新对象。</p><figure class="jq jr js jt fd ij er es paragraph-image"><div class="er es kc"><img src="../Images/8c30e8468ca3d7e3e2bd940ab9f1f8f8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1020/format:webp/1*fKMGeF0lQOZC7J9GH_idPQ.png"/></div></figure><p id="b23c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">TypeScript允许我们在倒数第二行控制台记录对象，它将准确地显示我们所期望的内容，一个具有属性名称、数量和日期的对象。然而，当我们试图访问最后一行对象的name属性时，编译器会抛出一个错误。这是为什么呢？</p><p id="5968" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们只告诉编译器我们传入了一个对象。它不知道该对象的属性。为了让它访问这些属性，我们需要使用一个泛型。</p><figure class="jq jr js jt fd ij er es paragraph-image"><div class="er es kd"><img src="../Images/da3ac2cd6740085f3d56891b280a27b9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1018/format:webp/1*PyEtx8aQEgwvcQ_7LYdOug.png"/></div></figure><p id="750b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">通过在参数列表前添加<t>,并指定T将是为变量order传递的类型，我们消除了这个错误。TypeScript编译器现在知道我们传递给函数的对象有一个name属性。</t></p><p id="5253" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">重要的是要注意，没有选择<t>的任何具体原因，如果你想，你可以使用<generic>。你通常会发现人们使用<t>，所以我继续使用这个标准。</t></generic></t></p><p id="8c22" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">所以回到手边的函数，我们目前的实现到目前为止工作得很好，但是我们只传递对象。假设我们忘记了这段代码，想在6个月后使用它，但不小心传入了一个数字而不是一个对象。如果我们编写这个函数的意图是它只能处理具有特定属性的对象，那么TypeScript会给我们发送一个错误吗？</p><figure class="jq jr js jt fd ij er es paragraph-image"><div class="er es ke"><img src="../Images/7da2bb0b4e4be3ecbf7ed01c97741a91.png" data-original-src="https://miro.medium.com/v2/resize:fit:652/format:webp/1*xhdR8uKVMzO3tRDb4EQQ1A.png"/></div></figure><p id="fb4f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">没有。我将返回一个只有日期属性的新对象。</p><p id="8bdb" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如果我们想避免这种行为，我们必须比仅仅<t>更具体。我们可以通过几种方式做到这一点:</t></p><h2 id="2a35" class="kf kg hi bd kh ki kj kk kl km kn ko kp jb kq kr ks jf kt ku kv jj kw kx ky kz bi translated">扩展对象</h2><p id="e608" class="pw-post-body-paragraph iq ir hi is b it la iv iw ix lb iz ja jb lc jd je jf ld jh ji jj le jl jm jn hb bi translated">我们可以告诉TypeScript编译器<t>将是一个带有<em class="lf">扩展对象</em>的对象。</t></p><figure class="jq jr js jt fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lg"><img src="../Images/302a755f6374aff568778b97cac2b7be.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JMeL0W4a3T8sIQuvdxZXfw.png"/></div></div></figure><p id="24d6" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这使得任何旧的对象进入函数，在这种情况下，我们会说这不是预期的功能。让我们说得更具体些。</p><h2 id="d03d" class="kf kg hi bd kh ki kj kk kl km kn ko kp jb kq kr ks jf kt ku kv jj kw kx ky kz bi translated">扩展特定对象</h2><p id="f6e1" class="pw-post-body-paragraph iq ir hi is b it la iv iw ix lb iz ja jb lc jd je jf ld jh ji jj le jl jm jn hb bi translated">我们也可以通过写内联来直接指定对象。</p><figure class="jq jr js jt fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lh"><img src="../Images/6c2aaaa742e5100ee85e3c4ad8aaae44.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qf1le1niKu6Cgq8eNOoTMQ.png"/></div></div></figure><p id="6c67" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">然而，如果我们在多个地方使用同一个对象，那么一旦该对象发生变化，管理起来将会非常繁琐和困难。所以让我们用一个接口来代替。</p><h2 id="7a66" class="kf kg hi bd kh ki kj kk kl km kn ko kp jb kq kr ks jf kt ku kv jj kw kx ky kz bi translated">扩展接口</h2><figure class="jq jr js jt fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es li"><img src="../Images/3a3cbdfc7a4a3fdc550e7f6d64e9f0aa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nsQ_b4oz9vRnPDO35CzfKQ.png"/></div></div></figure><p id="651b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在，我们的addDate函数只能接受订单类型，这是我们从一开始就想要的行为。</p><figure class="jq jr js jt fd ij er es paragraph-image"><div class="er es lj"><img src="../Images/838373999fe3c0697671696d3ac49195.png" data-original-src="https://miro.medium.com/v2/resize:fit:924/format:webp/1*2O-xdEodd7tFTJd23NKTDA.png"/></div></figure><h1 id="549e" class="lk kg hi bd kh ll lm ln kl lo lp lq kp lr ls lt ks lu lv lw kv lx ly lz ky ma bi translated">了解更多信息</h1><p id="b166" class="pw-post-body-paragraph iq ir hi is b it la iv iw ix lb iz ja jb lc jd je jf ld jh ji jj le jl jm jn hb bi translated">这篇博文旨在介绍泛型，老实说还有很多。查看这些免费资源，继续学习:</p><p id="b1d6" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><a class="ae jo" href="https://www.typescriptlang.org/docs/handbook/2/generics.html" rel="noopener ugc nofollow" target="_blank">官方仿制药文档</a></p><figure class="jq jr js jt fd ij"><div class="bz dy l di"><div class="mb mc l"/></div></figure><figure class="jq jr js jt fd ij"><div class="bz dy l di"><div class="mb mc l"/></div></figure></div></div>    
</body>
</html>