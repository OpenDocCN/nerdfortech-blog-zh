<html>
<head>
<title>Scopes And Closures Re-Explained: Part 2</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">重新解释作用域和闭包:第 2 部分</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/scopes-closures-re-explained-part-2-8f1092837781?source=collection_archive---------23-----------------------#2021-04-10">https://medium.com/nerd-for-tech/scopes-closures-re-explained-part-2-8f1092837781?source=collection_archive---------23-----------------------#2021-04-10</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="5e7f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">欢迎回到困惑:第 2 部分。我指的是作用域和闭包:第 2 部分。如果你错过了我谈到示波器的第一部分，你可以在这里找到它<a class="ae jd" rel="noopener" href="/geekculture/scopes-closures-re-explained-part-1-aea4d5fe5e8"/>。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es je"><img src="../Images/ee3bdaf999be8b65b886f8d64e6a1cea.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*udnYWau46KxfrxKm"/></div></div></figure><p id="be7c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在这一部分，我将讨论闭包！闭包可能是一个令人害怕的话题。看看<a class="ae jd" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Closures" rel="noopener ugc nofollow" target="_blank"> MDN </a>是怎么定义的:</p><blockquote class="jq jr js"><p id="fccf" class="if ig jt ih b ii ij ik il im in io ip ju ir is it jv iv iw ix jw iz ja jb jc hb bi translated">一个<strong class="ih hj">闭包</strong>是一个函数的组合，该函数被捆绑在一起(被封闭)并引用其周围的状态(即<strong class="ih hj">词法环境</strong>)。</p></blockquote><p id="2f05" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在这篇文章中，我将用一些例子来分解这个概念。闭包是一个如此重要的概念，以至于我们作为开发人员每天都在代码中使用它，不管我们是否知道！</p></div><div class="ab cl jx jy gp jz" role="separator"><span class="ka bw bk kb kc kd"/><span class="ka bw bk kb kc kd"/><span class="ka bw bk kb kc"/></div><div class="hb hc hd he hf"><h2 id="e2dd" class="ke kf hi bd kg kh ki kj kk kl km kn ko iq kp kq kr iu ks kt ku iy kv kw kx ky bi translated">简化的闭包定义</h2><p id="fafd" class="pw-post-body-paragraph if ig hi ih b ii kz ik il im la io ip iq lb is it iu lc iw ix iy ld ja jb jc hb bi translated"><strong class="ih hj">闭包</strong>是指内部函数<strong class="ih hj"> <em class="jt">可以访问外部函数作用域</em> </strong>中的变量的特性，即使在它已经被执行之后。每当在 JavaScript 中创建一个函数时，也会创建一个闭包。</p><p id="fc92" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">闭包有三个作用域:</p><ul class=""><li id="12f6" class="le lf hi ih b ii ij im in iq lg iu lh iy li jc lj lk ll lm bi translated">局部范围—访问自己的变量。</li><li id="54b7" class="le lf hi ih b ii ln im lo iq lp iu lq iy lr jc lj lk ll lm bi translated">父函数范围—使用外部函数访问变量。</li><li id="2073" class="le lf hi ih b ii ln im lo iq lp iu lq iy lr jc lj lk ll lm bi translated">全局范围—对全局变量的访问。</li></ul><h1 id="63b2" class="ls kf hi bd kg lt lu lv kk lw lx ly ko lz ma mb kr mc md me ku mf mg mh kx mi bi translated">让我们仔细看看</h1><p id="0f4f" class="pw-post-body-paragraph if ig hi ih b ii kz ik il im la io ip iq lb is it iu lc iw ix iy ld ja jb jc hb bi translated">这里有一个简单的例子。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div class="er es mj"><img src="../Images/f638bf7262f729524787d522900a3185.png" data-original-src="https://miro.medium.com/v2/resize:fit:1222/format:webp/1*xQ-KBtmw9baAPwM3rT6WtA.png"/></div></figure><p id="d4d7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这里我们有一个包含已定义变量<code class="du mk ml mm mn b">name</code>的父函数。它还创建了一个内部函数。</p><p id="0001" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">内部函数有一个局部变量<code class="du mk ml mm mn b">greeting </code>。内部函数可以访问父函数中的变量，这就是它能够在控制台中输出变量的原因。</p><h2 id="ba3e" class="ke kf hi bd kg kh ki kj kk kl km kn ko iq kp kq kr iu ks kt ku iy kv kw kx ky bi translated">故障</h2><p id="de90" class="pw-post-body-paragraph if ig hi ih b ii kz ik il im la io ip iq lb is it iu lc iw ix iy ld ja jb jc hb bi translated">在第 12 行，外部函数第一次被调用。让我们从顶部开始看看这里发生了什么:</p><ol class=""><li id="6564" class="le lf hi ih b ii ij im in iq lg iu lh iy li jc mo lk ll lm bi translated">创建了<code class="du mk ml mm mn b">name</code>变量，其值为“塞勒涅”。</li><li id="354d" class="le lf hi ih b ii ln im lo iq lp iu lq iy lr jc mo lk ll lm bi translated">第 5 行声明并返回了内部函数。</li><li id="2908" class="le lf hi ih b ii ln im lo iq lp iu lq iy lr jc mo lk ll lm bi translated">内部函数的内容存储在变量<code class="du mk ml mm mn b">greet</code>中。</li><li id="5183" class="le lf hi ih b ii ln im lo iq lp iu lq iy lr jc mo lk ll lm bi translated">存储后，外部函数完成执行，其作用域不再存在。(局部变量只在其功能持续期间存在)。一旦函数返回，任何局部变量都会被删除。</li><li id="6f7e" class="le lf hi ih b ii ln im lo iq lp iu lq iy lr jc mo lk ll lm bi translated">然而，当 greet 被调用时，name 变量仍然可以被访问和使用。这就是为什么我们的输出是“你好，塞勒涅”。</li></ol><p id="bb85" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">怎么会？闭包！内部函数是在调用外部函数时创建的。在这一点上形成了一个封闭。</p><p id="c3b0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们回到 MDN 的定义。</p><p id="9702" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">闭包是函数和它的<strong class="ih hj">词法环境、</strong>或者对它周围状态的引用的组合。</p><p id="1b83" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">当内部函数被创建时，它保存一个对其父词法环境的引用，变量<code class="du mk ml mm mn b">name</code>就存在于该环境中。它“记住”创建它的环境，这将包括范围内考虑的任何局部变量。</p><p id="04b9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这就是闭包的力量！</p></div><div class="ab cl jx jy gp jz" role="separator"><span class="ka bw bk kb kc kd"/><span class="ka bw bk kb kc kd"/><span class="ka bw bk kb kc"/></div><div class="hb hc hd he hf"><h1 id="e6a7" class="ls kf hi bd kg lt mp lv kk lw mq ly ko lz mr mb kr mc ms me ku mf mt mh kx mi bi translated">结论</h1><p id="7ea4" class="pw-post-body-paragraph if ig hi ih b ii kz ik il im la io ip iq lb is it iu lc iw ix iy ld ja jb jc hb bi translated">闭包是 JavaScript 和其他编程语言中的一个关键特性。我们在日常编程生活中使用它，但是很难完全掌握。但是通过了解它的实际功能，我们可以更好地控制我们的代码。</p><h1 id="71ce" class="ls kf hi bd kg lt lu lv kk lw lx ly ko lz ma mb kr mc md me ku mf mg mh kx mi bi translated">来源</h1><p id="312e" class="pw-post-body-paragraph if ig hi ih b ii kz ik il im la io ip iq lb is it iu lc iw ix iy ld ja jb jc hb bi translated"><a class="ae jd" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Closures" rel="noopener ugc nofollow" target="_blank"> MDN —闭包</a></p><p id="2c55" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><a class="ae jd" href="https://www.freecodecamp.org/news/closures-in-javascript-explained-with-examples/" rel="noopener ugc nofollow" target="_blank">用例子解释 JavaScript 中的闭包</a></p></div></div>    
</body>
</html>