<html>
<head>
<title>Support Vector Machine for Hand Written Alphabet Recognition</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用于手写字母识别的支持向量机</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/support-vector-machine-for-hand-written-alphabet-recognition-ba12716263a1?source=collection_archive---------10-----------------------#2021-02-21">https://medium.com/nerd-for-tech/support-vector-machine-for-hand-written-alphabet-recognition-ba12716263a1?source=collection_archive---------10-----------------------#2021-02-21</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="e694" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">写这篇文章的目的是使用非常粗糙的方法做图像分类，在这种情况下是手写文本的图像。虽然我们从头开始使用卷积神经网络模型，或者在 MNIST 数据集上使用预先训练的模型，但它更适合这项工作。我们使用迁移学习，在这个过程中，作为一名学生，我错过了最基本的东西。这就好像我在驾驶一辆自动汽车，我知道动力传动系统、离合器、油门和刹车是干什么的，但除此之外我一无所知。我们试图将手写字母图像识别的问题分解成一个简单的过程，而不是使用沉重的包。这是一种创建数据，然后使用支持向量机建立分类模型的尝试。</p><h1 id="283b" class="jd je hi bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">准备数据</h1><p id="360a" class="pw-post-body-paragraph if ig hi ih b ii kb ik il im kc io ip iq kd is it iu ke iw ix iy kf ja jb jc hb bi translated">我们将手动准备数据，而不是从网上下载。这将允许我们从初始阶段就理解我们的数据。我们将在一张白纸上手动写几个字母，并从我们的照相手机中拍摄图像。然后我们会把它移植到我们的硬盘上。因为这是一个实验，我不想在最初的运行中花费太多时间，所以我会为两个或三个不同的字母创建数据进行演示。建议你对所有的字母尝试这种机制，看看效率。当您添加更多的字母表类时，您可能需要修改您的代码，但这是学习部分将开始的地方。我们现在正处于培训阶段。</p><h1 id="654c" class="jd je hi bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">数据存储结构</h1><p id="745c" class="pw-post-body-paragraph if ig hi ih b ii kb ik il im kc io ip iq kd is it iu ke iw ix iy kf ja jb jc hb bi translated">我们可以在白纸上写下字母，然后使用手机摄像头提取，或者直接使用绘图工具，如 paint，使用钢笔工具进行书写。我创建了两个文件夹 train 和 test。在 train 文件夹中，我们可以保存带有字母名称的文件夹，而在 test 文件夹中，我们可以转储我们希望最终对其实例进行分类的图像。保留培训子文件夹的目的是将子文件夹名称作为培训标签。测试文件夹并没有像我们这里打算做的分类那样以相同的形式保存。</p><figure class="kh ki kj kk fd kl er es paragraph-image"><div class="er es kg"><img src="../Images/8be22d76aea08796aca63b11fd5809e8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/format:webp/0*0n6gk7GDuO0zOoXw.jpg"/></div><figcaption class="ko kp et er es kq kr bd b be z dx translated">图 1:手写图像的文件模式</figcaption></figure><p id="dded" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">或者，如果您想下载我使用过的数据，右键单击此<a class="ae ks" href="http://www.imurgence.com//uploads/thumbnails/sample_data/alphabet_folder.zip" rel="noopener ugc nofollow" target="_blank">下载数据</a>链接，并在新的选项卡或窗口中打开。然后解压文件夹，你应该能够在下载文件夹中看到与上面相同的结构和数据。</p><p id="3207" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">稍后，您应该创建自己的数据，并再次执行整个过程。这将暴露出完整的循环。</p><h1 id="91b1" class="jd je hi bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">下载 RStudio 中的依赖包</h1><p id="1175" class="pw-post-body-paragraph if ig hi ih b ii kb ik il im kc io ip iq kd is it iu ke iw ix iy kf ja jb jc hb bi translated">我们将使用 R 中的 jpeg 包进行图像处理，并使用 kernlab 包中的支持向量机实现。这将是一次性安装。我们还确保图像数据的尺寸为 200 x 200 像素，水平和垂直分辨率为 120dpi。在当前表单中实现之后，您可以尝试颜色通道和分辨率的变化。</p><pre class="kh ki kj kk fd kt ku kv kw aw kx bi"><span id="f3f3" class="ky je hi ku b fi kz la l lb lc"># install package "jpeg"<br/>  install.packages("jpeg", dependencies = TRUE)</span><span id="314d" class="ky je hi ku b fi ld la l lb lc"># install the "kernlab" package for building the model using support vector machines<br/>  install.packages("kernlab", dependencies  = TRUE)</span></pre><h1 id="3341" class="jd je hi bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">加载训练数据集</h1><pre class="kh ki kj kk fd kt ku kv kw aw kx bi"><span id="49c3" class="ky je hi ku b fi kz la l lb lc"># load the "jpeg" package for reading the JPEG format files<br/>  library(jpeg)<br/># set the working directory for reading the training image data set<br/>  setwd("C:/Users/mohan/Desktop/alphabet_folder/Train")<br/> <br/># extract the directory names for using as image labels <br/>  f_train&lt;-list.files()</span><span id="9063" class="ky je hi ku b fi ld la l lb lc"># Create an empty data frame to store the image data labels and the extracted new features in training environment<br/>  df_train&lt;- data.frame(matrix(nrow=0,ncol=5))</span></pre><h1 id="7638" class="jd je hi bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">特征工程</h1><p id="867a" class="pw-post-body-paragraph if ig hi ih b ii kb ik il im kc io ip iq kd is it iu ke iw ix iy kf ja jb jc hb bi translated">由于我们的目的是不使用典型的 CNN 方法，我们将使用白色，灰色和黑色像素值来创建新的功能。我们打算使用图像实例的所有像素值的总和，并将其保存在一个称为“sum”的特征中，所有像素的计数评估为零为“零”，所有像素的计数评估为“1”，所有像素的总和评估为除 0 和 1 之外的值为“中间值”。“标签”特征是从文件夹名称中提取的。</p><pre class="kh ki kj kk fd kt ku kv kw aw kx bi"><span id="464f" class="ky je hi ku b fi kz la l lb lc"># names the columns of the data frame as per the feature name schema<br/>  names(df_train)&lt;- c("sum","zero","one","in_between","label")</span><span id="aa4a" class="ky je hi ku b fi ld la l lb lc"># loop to compute as per the logic  <br/>  counter&lt;-1</span><span id="ffc7" class="ky je hi ku b fi ld la l lb lc">for(i in 1:length(f_train))<br/>  {<br/>    setwd(paste("C:/Users/mohan/Desktop/alphabet_folder/Train/",f_train[i],sep=""))<br/>  <br/>    data_list&lt;-list.files()<br/>  <br/>    for(j in 1:length(data_list))<br/>    {<br/>      temp&lt;- readJPEG(data_list[j])<br/>      df_train[counter,1]&lt;- sum(temp)<br/>      df_train[counter,2]&lt;- sum(temp==0)<br/>      df_train[counter,3]&lt;- sum(temp==1)<br/>      df_train[counter,4]&lt;- sum(temp &gt; 0 &amp; temp &lt; 1)<br/>      df_train[counter,5]&lt;- f_train[i]<br/>      counter=counter+1<br/>    }<br/>  }</span><span id="f24d" class="ky je hi ku b fi ld la l lb lc"># Convert the labels from text to factor form<br/>  df_train$label&lt;- factor(df_train$label)</span></pre><h1 id="d165" class="jd je hi bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">建立支持向量机模型</h1><pre class="kh ki kj kk fd kt ku kv kw aw kx bi"><span id="92b0" class="ky je hi ku b fi kz la l lb lc"># load the "kernlab" package for accessing the support vector machine implementation<br/>  library(kernlab)</span><span id="da2d" class="ky je hi ku b fi ld la l lb lc"># build the model using the training data<br/>  image_classifier &lt;- ksvm(label~.,data=df_train)</span></pre><h1 id="26d4" class="jd je hi bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">加载测试数据集</h1><pre class="kh ki kj kk fd kt ku kv kw aw kx bi"><span id="b426" class="ky je hi ku b fi kz la l lb lc"># set the working directory for reading the testing image data set<br/>  setwd("C:/Users/mohan/Desktop/alphabet_folder/Test")<br/>  <br/># extract the directory names for using as image labels<br/>  f_test &lt;- list.files()</span><span id="8659" class="ky je hi ku b fi ld la l lb lc"># Create an empty data frame to store the image data labels and the extracted new features in training environment<br/>  df_test&lt;- data.frame(matrix(nrow=0,ncol=5))<br/>  <br/># Repeat of feature extraction in test data<br/>  names(df_test)&lt;- c("sum","zero","one","in_between","label")<br/>  <br/># loop to compute as per the logic  <br/>  for(i in 1:length(f_test))<br/>    {<br/>      temp&lt;- readJPEG(f_test[i])<br/>      df_test[i,1]&lt;- sum(temp)<br/>      df_test[i,2]&lt;- sum(temp==0)<br/>      df_test[i,3]&lt;- sum(temp==1)<br/>      df_train[counter,4]&lt;- sum(temp &gt; 0 &amp; temp &lt; 1)<br/>      df_test[i,5]&lt;- strsplit(x = f_test[i],split = "[.]")[[1]][1]<br/>    }</span><span id="26ab" class="ky je hi ku b fi ld la l lb lc"># Use the classifier named "image_classifier" built in train environment to predict the outcomes on features in Test environment<br/>  df_test$label_predicted&lt;- predict(image_classifier,df_test)</span><span id="5773" class="ky je hi ku b fi ld la l lb lc"># Cross Tab for Classification Metric evaluation<br/>  table(Actual_data=df_test$label,Predicted_data=df_test$label_predicted)</span></pre><p id="4159" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我鼓励你通过点击我的<a class="ae ks" href="https://www.imurgence.com/home/courses" rel="noopener ugc nofollow" target="_blank">免费数据科学和机器学习视频课程</a>的链接来学习本文无法完全探究的支持向量机的概念。虽然我们已经使用了 kernlab 包并创建了分类器，但是从向量空间到内核技巧，还涉及到许多数学知识。我们已经研究了分类器的实现，但是你当然应该学习支持向量机的概念部分和其他有趣的算法。</p></div><div class="ab cl le lf gp lg" role="separator"><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj"/></div><div class="hb hc hd he hf"><p id="a125" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="ll">原载于 https://imurgence.com/</em><a class="ae ks" href="https://www.imurgence.com/home/blog/support-vector-machine-for-hand-written-text-recognition" rel="noopener ugc nofollow" target="_blank"/></p></div></div>    
</body>
</html>