<html>
<head>
<title>Postgres — Good for Queuing implementation?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">postgres——适合队列实现吗？</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/postgres-good-for-queuing-implementation-8b7980b6409b?source=collection_archive---------4-----------------------#2021-04-09">https://medium.com/nerd-for-tech/postgres-good-for-queuing-implementation-8b7980b6409b?source=collection_archive---------4-----------------------#2021-04-09</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/d2e26a44fce0ecc7f872f22f9ff725bd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*CAWNM053XJrgVuRj.png"/></div></div></figure><p id="1af4" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">几天前，我们收到了一个CloudWatch警报，警告Amazon Aurora上托管的一个Postgres数据库的CPU利用率。查看性能分析，我们得到了消耗CPU最多的查询。</p><pre class="jo jp jq jr fd js jt ju jv aw jw bi"><span id="85e0" class="jx jy hi jt b fi jz ka l kb kc">UPDATE events_tab1 <br/>SET    locked_by = $1, <br/>       last_updated_by = $2, <br/>       last_updated=$3, <br/>       locked_at=$4, <br/>       rtcount = rtcount + ? <br/>WHERE  id                       IN ( <br/>       ( <br/>              SELECT id <br/>              FROM   events_tab1 <br/>              WHERE  rtcount &lt; $5 <br/>              AND    locked_at &lt; $6) FOR UPDATE skip locked limit $7 ) returning *</span><span id="1472" class="jx jy hi jt b fi kd ka l kb kc">Indexes on events_tab1:<br/>    "events_tab1_pk" PRIMARY KEY, btree (id)<br/>    "events_tab1_la_rcnt" btree (locked_at, rtcount)</span></pre><p id="101b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">实际上，CPU消耗最高的5个查询都与不同表上的“FOR UPDATE skip locked”相关。我对更新跳过锁定的语法<strong class="is hj">很陌生，很快在谷歌上搜索，我开始知道关于Postgres中的<a class="ae ke" href="https://www.2ndquadrant.com/en/blog/what-is-select-skip-locked-for-in-postgresql-9-5/" rel="noopener ugc nofollow" target="_blank">排队实现</a>。</strong></p><p id="2a2c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">那很好。</strong>我见过有人使用像SQS这样的消息服务来实现队列，从而构建解耦架构。这里Postgres提供了内置的排队特性。</p><p id="ba4a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">回到CPU峰值问题，在进一步的检查中，我注意到与所有这5个表的行数相比，死元组很高，尽管autovacuum定期在这些表上运行。这就是索引碎片化的原因(查询计划正在经历索引扫描)。</p><pre class="jo jp jq jr fd js jt ju jv aw jw bi"><span id="5dec" class="jx jy hi jt b fi jz ka l kb kc">select n_live_tup,n_dead_tup,last_autovacuum,current_time from pg_stat_user_tables where relname='events_tab1';</span><span id="6417" class="jx jy hi jt b fi kd ka l kb kc">n_live_tup | n_dead_tup |        last_autovacuum        |   timetz<br/>------------+------------+-------------------------------+----------<br/>        51 |     797750 | 2021-04-03 14:30:32            | 14:49:29</span><span id="3cb9" class="jx jy hi jt b fi kd ka l kb kc">select count(*) from events_tab1;<br/> count<br/>-------<br/>    25</span></pre><p id="8afe" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">经过进一步检查，我发现有一个会话运行了24小时以上，并且处于活动状态。现在，清空的一个条件是，它不会在最早运行的事务的xmin之后清理死元组，这意味着在过去24小时内生成的死元组不会被所有表清理。</p><p id="b2af" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">然而，这在Postgres中是众所周知的事情，我们应该关注长时间运行的事务，尤其是“事务中空闲”的事务。</p><p id="9d72" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我之前也遇到过这个问题，但是有一点我不明白，为什么一个在其他表上长时间运行的查询会阻塞所有其他表的清空过程。我在Postgres社区提出了这个问题，看到社区成员的快速回复，我很高兴。</p><blockquote class="kf kg kh"><p id="ef26" class="iq ir ki is b it iu iv iw ix iy iz ja kj jc jd je kk jg jh ji kl jk jl jm jn hb bi translated"><strong class="is hj">你可以在这里阅读更多相关内容</strong>—<a class="ae ke" href="https://www.postgresql.org/message-id/19474.1572022017%40sss.pgh.pa.us" rel="noopener ugc nofollow" target="_blank">https://www . PostgreSQL . org/message-id/19474.1572022017% 40 SSS . pgh . pa . us</a></p></blockquote><p id="aca9" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">老实说，我仍然需要坐下来理解为什么table2上的查询阻塞了table1上的vacuuming，然后还要比较其他RDBMS在这方面是如何工作的。</p><p id="4dec" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这里另一个有趣的事情是，如果相应的表上没有发生清空，那么只有事件表上的这5个查询(用于排队机制)消耗了更多的CPU(CPU随着事件表中死元组的增加而增加)。其他表的工作负载不会受到太大影响。这可能是因为在那些排队表上进行了太多的删除/更新/选择，然后可能是Postgres中队列机制的内部工作方式(更多的cpu周期？).</p><p id="53ba" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">不管怎样，在杀死那个长时间运行的会话(来自用户生成的会话的手动查询)之后，CPU下降到40%(在96 vCPU机器上)。</p><blockquote class="kf kg kh"><p id="fb70" class="iq ir ki is b it iu iv iw ix iy iz ja kj jc jd je kk jg jh ji kl jk jl jm jn hb bi translated">要终止一个长时间运行的事务/查询，我们可以在仔细考虑工作量后设置<strong class="is hj">语句_超时</strong>和<strong class="is hj">T3】空闲_ in _事务_会话_超时和</strong>参数。</p></blockquote><p id="b24d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">为什么CPU还是40%？</strong>我在顶级CPU消耗查询中看到相同的事件表查询。还有许多其他应用程序生成的查询，它们通常运行2-3个小时(这些查询是为了在Reader实例上进行报告，hot_standby_feedback在Aurora上总是打开的)。因此，在这种情况下，我们不能做太多事情，这意味着在过去的2-3小时内，所有表上总会累积死元组。</p><p id="761f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">出于好奇，我又做了一些测试，看看当其他事务正在进行时，数据清除是如何工作的。</p><pre class="jo jp jq jr fd js jt ju jv aw jw bi"><span id="36b1" class="jx jy hi jt b fi jz ka l kb kc"><strong class="jt hj">Session 1:</strong><br/>create table test (age int);<br/>CREATE TABLE<br/>insert into test select generate_series(1,100000);<br/>INSERT 0 100000<br/>create index idx on test(age);<br/>CREATE INDEX</span><span id="cbca" class="jx jy hi jt b fi kd ka l kb kc"><strong class="jt hj">Session2: (starts a transaction but does not end)</strong></span><span id="4e87" class="jx jy hi jt b fi kd ka l kb kc">create table test2(age int);<br/>CREATE TABLE</span><span id="f88c" class="jx jy hi jt b fi kd ka l kb kc">BEGIN;<br/>BEGIN<br/>select count(*) from test2;<br/> count<br/>-------<br/>     0</span></pre><p id="458b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在，再次在会话1中，运行delete语句，我们可以看到vacuum并没有清理死行。SELECT按预期提供了0行，但未清除死元组。</p><pre class="jo jp jq jr fd js jt ju jv aw jw bi"><span id="7c1e" class="jx jy hi jt b fi jz ka l kb kc">delete from test;<br/>DELETE 100000<br/><br/>vacuum verbose test;<br/>INFO:  vacuuming "public.test"<br/>INFO:  index "idx" now contains 100000 row versions in 276 pages<br/>DETAIL:  0 index row versions were removed.<br/>0 index pages have been deleted, 0 are currently reusable.<br/>CPU 0.00s/0.00u sec elapsed 0.00 sec.<br/><strong class="jt hj">INFO:  "test": found 0 removable, 100000 nonremovable row versions in 443 out of 443 pages</strong><br/>DETAIL:  100000 dead row versions cannot be removed yet.<br/>There were 0 unused item pointers.<br/>Skipped 0 pages due to buffer pins.<br/>0 pages are entirely empty.<br/>CPU 0.00s/0.00u sec elapsed 0.00 sec.</span><span id="5f9c" class="jx jy hi jt b fi kd ka l kb kc">select count(*) from test;<br/> count<br/>-------<br/>     0</span></pre><p id="f78c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我试图创建另一个索引，也做了全真空，但正如所料，它们也遵循相同的规则(在新的索引和表中引入死元组，它们的大小保持不变)。</p><pre class="jo jp jq jr fd js jt ju jv aw jw bi"><span id="b5cf" class="jx jy hi jt b fi jz ka l kb kc">\dt+ test<br/>                    <br/> Schema | Name | Type  |     Owner     | Persistence |  Size   | <br/>--------+------+-------+---------------+-------------+---------+----<br/> public | test | table | fintech_admin | permanent   | 3568 kB |</span><span id="9223" class="jx jy hi jt b fi kd ka l kb kc">\di+ idx<br/>                                <br/> Schema | Name | Type  |     Owner     | Table | Persistence |  Size   <br/>--------+------+-------+---------------+-------+-------------+------<br/> public | idx  | index | fintech_admin | test  | permanent  | 2208 kB </span><span id="a611" class="jx jy hi jt b fi kd ka l kb kc">select count(*) from test;<br/> count<br/>-------<br/>     0</span><span id="7724" class="jx jy hi jt b fi kd ka l kb kc">create index idx1 on test(age);<br/>CREATE INDEX</span><span id="d4b1" class="jx jy hi jt b fi kd ka l kb kc">\di+ idx1<br/>                                  <br/> Schema | Name | Type  |     Owner     | Table | Persistence |  Size   <br/>--------+------+-------+---------------+-------+-------------+------<br/> public | idx1 | index | fintech_admin | test  | permanent  | 2208 kB </span><span id="7aae" class="jx jy hi jt b fi kd ka l kb kc">vacuum full test;<br/>VACUUM</span><span id="4ba5" class="jx jy hi jt b fi kd ka l kb kc">\dt+ test<br/>                           <br/> Schema | Name | Type  |     Owner     | Persistence |  Size   | <br/>--------+------+-------+---------------+-------------+---------+---<br/> public | test | table | fintech_admin | permanent   | 3576 kB |</span></pre><p id="551f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">可能的解决方案(探索):</strong></p><ul class=""><li id="bdc2" class="km kn hi is b it iu ix iy jb ko jf kp jj kq jn kr ks kt ku bi translated">PG_REPACK实用程序在这里可以方便地删除碎片/死元组。当它创建一个新表并切换表名时，它应该只复制那些没有死元组的相关行(这是正常的vacuum无法清理的)。然而，pg_repack需要频繁地进行调度，可能每小时一次(暂时锁定可能是另一个问题)。</li><li id="5311" class="km kn hi is b it kv ix kw jb kx jf ky jj kz jn kr ks kt ku bi translated">应用程序团队还希望调整一些队列参数，如并行线程、睡眠时间(多次轮询之间的等待时间)以及批量大小(单次轮询中有多少条记录)。</li></ul><p id="74f4" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">结束语:</strong> <br/>乍一看，Postgres中内置的队列实现看起来相当不错，尽管我们看到由于其他长时间运行的查询，CPU利用率很高。实际上，这可能与排队机制不完全相关，但总体而言，任何具有非常高的DML和高访问率的表都是如此。但归根结底，这就是为什么要为？</p><p id="e36c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">有什么想法和经历吗？恳请分享。</p></div></div>    
</body>
</html>