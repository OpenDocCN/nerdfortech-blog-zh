<html>
<head>
<title>Postgres VACUUM — Questionnaire deep dive</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Postgres真空-问卷深潜</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/postgres-vacuum-questionnaire-deep-dive-d4c89a311139?source=collection_archive---------5-----------------------#2021-04-09">https://medium.com/nerd-for-tech/postgres-vacuum-questionnaire-deep-dive-d4c89a311139?source=collection_archive---------5-----------------------#2021-04-09</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/ff38d0aaa6e2d5f2eda48eb4572770d7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*vFcm5I17R2sH8L2C.jpg"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">大象吸尘器</figcaption></figure><p id="98aa" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">PostgreSQL的核心概念之一是它的清空过程。我读过一些博客帖子，在这些帖子中，人们谈到了由于事务绕回问题而发生的大规模停机，在某些情况下，停机时间长达几个小时。由于真空过程是非常关键的，因此人们应该了解它的进出。万一我们碰到那些危险的吸尘/缠绕问题，至少我们有更好的装备来处理它。在阅读吸尘概念时，出现了一些问题，我在这里对它们进行了总结。</p><p id="12f6" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw hj">问:运行真空作业有并行选项吗？</strong> <br/> <strong class="iw hj"> A. </strong>拖延但不否认。最后，Postgres13引入了这个非常需要的特性。现在，真空活动可以由并行工作器运行。看了一些博客，我知道只有索引清空/清理是以并行方式发生的，而且每个索引只有一个工作人员。有了这个特性，在具有多个索引的大表上，总的真空运行时间将会有巨大的改进。</p><pre class="js jt ju jv fd jw jx jy jz aw ka bi"><span id="baeb" class="kb kc hi jx b fi kd ke l kf kg">VACUUM (PARALLEL 3) TESTTABLE;</span></pre><p id="83dd" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">谁知道后来的Postgres版本引入了偶数堆和单索引真空/清除并行工作线程(Postgres11已经引入了并行索引扫描)</p><p id="b673" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw hj">问:如果我终止一个正在运行的真空作业会怎样？会恢复吗？</strong> <br/> <strong class="iw hj"> A. </strong> Postgres在可见性映射中跟踪增量块变化(死元组和冻结块)以避免全表扫描。我们可以通过pg_visibility扩展看到这个可见性地图信息。在真空运行期间，这种可见性图检查点经常出现。</p><pre class="js jt ju jv fd jw jx jy jz aw ka bi"><span id="547c" class="kb kc hi jx b fi kd ke l kf kg">create extension pg_visibility;<br/>CREATE EXTENSION</span><span id="c4ae" class="kb kc hi jx b fi kh ke l kf kg">create table test (age int);<br/>CREATE TABLE</span><span id="42a3" class="kb kc hi jx b fi kh ke l kf kg">insert into test select generate_Series(1,1000000);<br/>INSERT 0 1000000</span><span id="0fad" class="kb kc hi jx b fi kh ke l kf kg">select * from pg_visibility_map_summary('test');<br/> all_visible | all_frozen<br/>-------------+------------<br/>           0 |          0<br/>vacuum test; --&gt; Killed from another session<br/>VACUUM<br/>select * from pg_visibility_map_summary('test');<br/> all_visible | all_frozen<br/>-------------+------------<br/>        8850 |          0</span></pre><p id="8423" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">在反环绕真空的情况下，要前进<code class="du ki kj kk jx b"><em class="kl">relfrozenxid,</em></code>，真空必须在一次成功通过中扫描可见性图中的所有页面。</p><blockquote class="km kn ko"><p id="74cb" class="iu iv kl iw b ix iy iz ja jb jc jd je kp jg jh ji kq jk jl jm kr jo jp jq jr hb bi translated"><code class="du ki kj kk jx b"><em class="hi">VACUUM</em></code>通常只扫描自上次清空后修改过的页面，但只有当扫描完表格中可能包含未冻结xid的每一页时，<code class="du ki kj kk jx b"><em class="hi">relfrozenxid</em></code>才能前进。当<code class="du ki kj kk jx b"><em class="hi">relfrozenxid</em></code>比<code class="du ki kj kk jx b"><em class="hi">vacuum_freeze_table_age</em></code>事务更老时，当<code class="du ki kj kk jx b"><em class="hi">VACUUM</em></code>的<code class="du ki kj kk jx b"><em class="hi">FREEZE</em></code>选项被使用时，或者当所有还没有完全冻结的页面碰巧需要清空来移除死行版本时，就会发生这种情况。</p><p id="e214" class="iu iv kl iw b ix iy iz ja jb jc jd je kp jg jh ji kq jk jl jm kr jo jp jq jr hb bi translated">我还在社区中发起了一个讨论，看看Postgres是否可以为每个元组拥有事务id(可能是一个愚蠢的想法？).社区中关于进一步改进的更多讨论，<a class="ae ks" href="https://www.postgresql-archive.org/vacuum-freeze-possible-improvements-td6193674.html" rel="noopener ugc nofollow" target="_blank"> 1 </a>和<a class="ae ks" href="https://www.postgresql-archive.org/vacuum-freeze-possible-improvements-td6193674.html" rel="noopener ugc nofollow" target="_blank"> 2 </a>。</p></blockquote><p id="5c75" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw hj">问:分配更多的维护_工作_内存，VACUUM可以运行得更快吗？如果我在系统级别(动态参数)更改它，是否会影响已经运行的真空作业？</strong> <br/> <strong class="iw hj"> A. </strong>我做了一些增加maintenance_work_mem参数的测试，但是我没有看到已经运行的真空作业有任何改进。当然，新的真空作业会受益。注意vacuum可以使用的最大内存为1 GB。</p><p id="f27a" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw hj">问:正常真空(未满)是否会独占锁定工作台？</strong> <br/> <strong class="iw hj"> A. </strong>这可能需要，这取决于表的末尾是否有空块。然后真空试图释放那些块。如果有任何查询正在访问writer节点上的表，它会跳过排他锁，但是如果查询正在Reader节点上运行，它不会等待/确认(即使hot_standby_feedback为on)。这意味着正常的真空会导致读取器节点上的查询取消。这里，另一个参数max_standby_streaming_delay来拯救(折衷副本同步)。</p><p id="5278" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">Postgres12引入了一个特性来禁用这种截断行为。我们可以利用这一点来避免查询取消/延迟问题。</p><pre class="js jt ju jv fd jw jx jy jz aw ka bi"><span id="0251" class="kb kc hi jx b fi kd ke l kf kg">alter table testtable set (vacuum_truncate=false);</span></pre><p id="3f83" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw hj">问:真空作业总是清理死元组吗？</strong> <br/> <strong class="iw hj"> A. </strong>不总是，数据库中长时间运行的事务块通过真空进程删除死元组。在这种情况下，VACUUM job运行良好，没有任何抱怨，但它不会清除死元组。如果发生这种情况，VACUUM verbose选项会给出详细信息。</p><pre class="js jt ju jv fd jw jx jy jz aw ka bi"><span id="f1b3" class="kb kc hi jx b fi kd ke l kf kg">postgres=&gt; vacuum verbose testtable;</span><span id="b60b" class="kb kc hi jx b fi kh ke l kf kg">INFO:  "testtable": found 224972 removable, 1255345 nonremovable row versions in 367291 out of 8370336 pages<br/>DETAIL:  1255191 dead row versions cannot be removed yet.</span></pre><blockquote class="km kn ko"><p id="74b9" class="iu iv kl iw b ix iy iz ja jb jc jd je kp jg jh ji kq jk jl jm kr jo jp jq jr hb bi translated">这种行为可能会在非常繁忙的系统中产生问题。我已经在另一篇<a class="ae ks" rel="noopener" href="/nerd-for-tech/postgres-good-for-queuing-implementation-8b7980b6409b">帖子</a>中详细解释了这个场景。我也在社区里提出了<a class="ae ks" href="https://www.postgresql.org/message-id/19474.1572022017%40sss.pgh.pa.us" rel="noopener ugc nofollow" target="_blank">问题</a>来理解这种行为。</p></blockquote><p id="4326" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">问:只插入表(没有更新/删除)也需要真空吗？ <br/> <strong class="iw hj">答:</strong>是的，只插入表格需要真空有两个原因——</p><ul class=""><li id="ae63" class="kt ku hi iw b ix iy jb jc jf kv jj kw jn kx jr ky kz la lb bi translated">冻结元组以避免事务绕回问题。</li><li id="2b0b" class="kt ku hi iw b ix lc jb ld jf le jj lf jn lg jr ky kz la lb bi translated">为了避免仅索引扫描的性能问题(因为仅索引扫描需要检查可见性映射以查看页面是否全部可见)。</li></ul><p id="1ed7" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">Postgres13引入了插入触发自动真空的特性。</p><p id="86fb" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw hj">问:如何降低桌子上的真空频率？</strong> <br/> <strong class="iw hj"> A. </strong>在更新查询的情况下，Postgres有一个称为HOT(仅堆元组)的特性，它在其中添加了一个指针来定位新的行版本。这使得迷你块级真空对表本身。为了利用这个特性，我们应该适当地设置表格填充因子值。我已经在另一篇<a class="ae ks" rel="noopener" href="/nerd-for-tech/postgres-fillfactor-baf3117aca0a">帖子</a>中详细解释了FILLFACTOR。</p><p id="f04c" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw hj">问:真空冷冻只存在吗？</strong> <br/> <strong class="iw hj">答:</strong>当我们即将面临交易回绕问题时，仅冻结真空会很有用。那时候我们只担心冻结元组，死元组可以以后再清理。我看到过一些讨论这个话题的帖子，但没有发现这个功能(如果我错了，请纠正我)。这意味着在“真空冻结”操作期间，它还会清除表中的死元组。然而，相反的情况不成立，可能存在仅清理死元组但不冻结元组的真空作业。</p><p id="8d69" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw hj">更新:</strong>通过Postgres12中的index_cleanup defer特性，vacuum延迟了步进清理阶段，因此对于防缠绕vacuum来说非常快。</p><pre class="js jt ju jv fd jw jx jy jz aw ka bi"><span id="faa6" class="kb kc hi jx b fi kd ke l kf kg">VACUUM (INDEX_CLEANUP False, VERBOSE) testtable;</span></pre><p id="746a" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw hj">问:如何加快真空作业的速度？</strong> <br/> <strong class="iw hj"> A. </strong>有自动真空参数，可以根据需要进行调谐/调整。For Ex —自动真空_真空_成本_延迟、自动真空_真空_成本_限制、自动真空_维护_工作_记忆</p><p id="322e" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">删除表上未使用的索引有助于加速真空作业。因此，如果事务回绕就在附近，那么为了整个数据库正常运行，可以删除/截断索引或甚至表(对于日志/归档表)。</p><p id="9393" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">Postgre12引入了不清理索引条目的真空操作。Postgres13引入了一个与并行工作人员一起运行的真空作业。</p><p id="5eaa" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">参数vacuum_freeze_min_age可以增加，因此正常的真空作业将做更少的工作，因为它必须冻结更少的元组。</p><p id="232d" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw hj">问:我们如何跟踪真空吸尘器的运行进度？</strong><br/>T22】a .Postgres中有检查真空进度的目录对象——pg _ stat _ progress _ vacuum。在这些元数据对象(www.google.com)的基础上构建了一些很好的查询。</p><p id="5dee" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">有时，我还会检查表中的总块数(pg_freespace ),然后检查all_visible块数(pg_visibility_map_summary)是如何随着运行真空而增加的。这给出了还剩多少块的大致想法。</p><pre class="js jt ju jv fd jw jx jy jz aw ka bi"><span id="1d50" class="kb kc hi jx b fi kd ke l kf kg">select count(*) from pg_freespace(‘testtable’); --total blocks<br/> count<br/> — — — — -<br/>1706691</span><span id="2506" class="kb kc hi jx b fi kh ke l kf kg">--see how many all_visible blocks are there.</span><span id="9682" class="kb kc hi jx b fi kh ke l kf kg">select a.*,current_timestamp from  pg_visibility_map_summary(‘testtable’) a<br/> all_visible | all_frozen | now<br/> — — — — — — -+ — — — — — — + — — — — — — — — — — — — — — — -<br/> 1706691 | 727685 | 2021–04–13 12:25:09.908857+00</span></pre></div></div>    
</body>
</html>