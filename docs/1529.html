<html>
<head>
<title>Android Tutorial Part 3: Using Apollo library to fetch data from a GraphQL endpoint</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Android教程第3部分:使用Apollo库从GraphQL端点获取数据</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/android-tutorial-part-3-using-apollo-library-to-fetch-data-from-a-graphql-endpoint-616fda869560?source=collection_archive---------3-----------------------#2021-03-24">https://medium.com/nerd-for-tech/android-tutorial-part-3-using-apollo-library-to-fetch-data-from-a-graphql-endpoint-616fda869560?source=collection_archive---------3-----------------------#2021-03-24</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/94f7ac890ed7a1ce6c25de7b15781730.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kRfQ_qluaF58b8Ddd88dhw.jpeg"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">美国宇航局在<a class="ae iu" rel="noopener ugc nofollow" target="_blank" href="/s/photos/astronaut?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText"> Unsplash </a>拍摄的照片</figcaption></figure><p id="34f2" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在<a class="ae iu" rel="noopener" href="/nerd-for-tech/android-tutorial-part-2-using-apollo-library-to-fetch-data-from-a-graphql-endpoint-96dad8a58639">第2部分</a>中，我们将<strong class="ix hj"> schema.sdl </strong>添加到项目中，并开始开发应用程序。我们完成了创建<strong class="ix hj"><em class="jt">RickAndMortyApi</em></strong>类。</p><h1 id="bd4b" class="ju jv hi bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">依赖注入的句柄模块</h1><p id="d4be" class="pw-post-body-paragraph iv iw hi ix b iy ks ja jb jc kt je jf jg ku ji jj jk kv jm jn jo kw jq jr js hb bi translated">由于我们现在已经在我们的<strong class="ix hj"><em class="jt">RickAndMortyApi</em></strong>中有了Apollo客户端实例，我们现在可以使用Hilt将它注入到<strong class="ix hj"><em class="jt">character repositoryimpl</em></strong>中。创建一个新的包，命名为<strong class="ix hj"> di </strong>。在包<strong class="ix hj"> di </strong>中创建对象<strong class="ix hj"> <em class="jt"> RepoModule </em> </strong>。用<em class="jt">模块</em>对其进行注释，用<em class="jt"> InstallIn </em>对其进行注释，并将其传递给<em class="jt"> SingletonComponent </em>类。从Dagger 2你可能知道<em class="jt">模块</em>被传入<em class="jt">组件</em>。与此相反，你将<em class="jt">组件</em>传递到<em class="jt">模块</em>。<em class="jt">需要SingletonComponent </em>，因为它需要比Activity和ViewModel更长寿。有关组件的更多信息，请点击<a class="ae iu" href="https://dagger.dev/hilt/components" rel="noopener ugc nofollow" target="_blank">此处</a>。然后用<em class="jt"> Singleton </em> &amp; <em class="jt">标注的create方法提供</em>并返回一个<strong class="ix hj"> <em class="jt"> RickAndMortyApi的实例。</em>T53】</strong></p><pre class="kx ky kz la fd lb lc ld le aw lf bi"><span id="c4fe" class="lg jv hi lc b fi lh li l lj lk">@Module<br/>@InstallIn(SingletonComponent::class)<br/>object RepoModule {<br/><br/>    @Singleton<br/>    @Provides<br/>    fun provideWebService() = RickAndMortyApi()<br/><br/>}</span></pre><h1 id="39d7" class="ju jv hi bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">存储库模式</h1><p id="a922" class="pw-post-body-paragraph iv iw hi ix b iy ks ja jb jc kt je jf jg ku ji jj jk kv jm jn jo kw jq jr js hb bi translated">还记得我们在上一部分创建的类<strong class="ix hj"><em class="jt">CharacterRepositoryImpl</em></strong>吗？现在去打开它。At用<strong class="ix hj"><em class="jt">RickAndMortyApi</em></strong>的实例注入构造函数。然后使用方法<em class="jt"> queryCharactersList( ) </em>内的属性查询<strong class="ix hj"><em class="jt">characters list query</em></strong>。</p><figure class="kx ky kz la fd ij"><div class="bz dy l di"><div class="ll lm l"/></div></figure><h1 id="9485" class="ju jv hi bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated"><strong class="ak">ViewModel的另一个模块</strong></h1><p id="a18d" class="pw-post-body-paragraph iv iw hi ix b iy ks ja jb jc kt je jf jg ku ji jj jk kv jm jn jo kw jq jr js hb bi translated">在<strong class="ix hj"> di </strong>里面新建一个文件，命名为<strong class="ix hj"> <em class="jt"> ViewModelModule </em> </strong>。用安装在中的<em class="jt">模块</em>和<em class="jt">对其进行注释，并向其传递<em class="jt">视图模型组件</em>类。因为它需要比活动更长久。创建一个方法，用<em class="jt">绑定</em>和<em class="jt"> ViewModelScoped </em>，传递一个参数<strong class="ix hj"><em class="jt">CharacterRepositoryImpl</em></strong>，给它一个返回类型<strong class="ix hj"><em class="jt">character repository</em></strong>。</em></p><figure class="kx ky kz la fd ij"><div class="bz dy l di"><div class="ll lm l"/></div></figure><h1 id="fc5a" class="ju jv hi bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">处理视图状态</h1><p id="9d4c" class="pw-post-body-paragraph iv iw hi ix b iy ks ja jb jc kt je jf jg ku ji jj jk kv jm jn jo kw jq jr js hb bi translated">创建新的包<strong class="ix hj">视图</strong>。在<strong class="ix hj">视图</strong>中创建另一个包，并将其命名为<strong class="ix hj">状态</strong>。在<strong class="ix hj">状态下</strong>包创建<strong class="ix hj">文件<em class="jt">视图状态</em>文件</strong>。这个类将处理加载、显示数据或错误消息的视图。</p><figure class="kx ky kz la fd ij"><div class="bz dy l di"><div class="ll lm l"/></div></figure><h1 id="0720" class="ju jv hi bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">为MVVM创建的最后一个类</h1><p id="f92c" class="pw-post-body-paragraph iv iw hi ix b iy ks ja jb jc kt je jf jg ku ji jj jk kv jm jn jo kw jq jr js hb bi translated">创建一个新的包<strong class="ix hj">视图模型</strong>。在<strong class="ix hj"> viewmodel </strong>内部创建类<strong class="ix hj">角色<em class="jt">viewmodel</em>角色</strong>。用<em class="jt">experimental routinesapi</em>和<em class="jt"> HiltViewModel </em>对其进行注释。添加注入构造函数给构造函数传递一个<strong class="ix hj"><em class="jt">character repository</em></strong>的实例。最后一步，别忘了从<em class="jt"> ViewModel继承。</em></p><pre class="kx ky kz la fd lb lc ld le aw lf bi"><span id="7673" class="lg jv hi lc b fi lh li l lj lk">@ExperimentalCoroutinesApi<br/>@HiltViewModel<br/>class CharacterViewModel @Inject constructor(<br/>    private val repository: CharacterRepository,<br/>) : ViewModel() {<br/>}</span></pre><p id="3791" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">接下来，为<em class="jt">视图模型</em>创建私有字段<em class="jt">可变数据</em>，并在<em class="jt">视图模型</em>之外创建公共<em class="jt">活动数据</em>属性。</p><pre class="kx ky kz la fd lb lc ld le aw lf bi"><span id="d08d" class="lg jv hi lc b fi lh li l lj lk">private val _charactersList by <em class="jt">lazy </em><strong class="lc hj">{ </strong>MutableLiveData&lt;ViewState&lt;Response&lt;CharactersListQuery.Data&gt;&gt;&gt;() <strong class="lc hj">}</strong></span><span id="ba3e" class="lg jv hi lc b fi ln li l lj lk">val charactersList: LiveData&lt;ViewState&lt;Response&lt;CharactersListQuery.Data&gt;&gt;&gt;<br/>    get() = _charactersList</span></pre><p id="6811" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">之后，我们需要一个方法，在调用时首先设置视图状态加载，然后设置<strong class="ix hj"> _charactersList </strong>的数据，或者设置一个视图状态错误情况，如果发生异常。</p><figure class="kx ky kz la fd ij"><div class="bz dy l di"><div class="ll lm l"/></div></figure><h1 id="1bfc" class="ju jv hi bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">移动到适配器上</h1><p id="7848" class="pw-post-body-paragraph iv iw hi ix b iy ks ja jb jc kt je jf jg ku ji jj jk kv jm jn jo kw jq jr js hb bi translated">在<strong class="ix hj">视图</strong>包内创建包<strong class="ix hj">适配器</strong>。然后创建文件<strong class="ix hj"><em class="jt">character adapter</em></strong>。首先，我们需要一个<em class="jt"> DiffUtil </em>类，稍后用于<em class="jt"> ListAdapter </em>。<em class="jt"> DiffUtil </em>和<em class="jt"> ListAdapter </em>将提升<em class="jt"> RecyclerView </em>的性能。</p><pre class="kx ky kz la fd lb lc ld le aw lf bi"><span id="184f" class="lg jv hi lc b fi lh li l lj lk">class CharacterDiffUtil : DiffUtil.ItemCallback&lt;CharactersListQuery.Result&gt;() {<br/><br/>    override fun areItemsTheSame(<br/>        oldItem: CharactersListQuery.Result,<br/>        newItem: CharactersListQuery.Result<br/>    ): Boolean {<br/>        return oldItem.id == newItem.id<br/>    }<br/><br/>    override fun areContentsTheSame(<br/>        oldItem: CharactersListQuery.Result,<br/>        newItem: CharactersListQuery.Result<br/>    ): Boolean {<br/>        return oldItem == newItem<br/>    }<br/><br/>}</span></pre><p id="0be3" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">现在跳转到<strong class="ix hj">RES</strong>-&gt;-<strong class="ix hj">layout</strong>，创建资源文件:<strong class="ix hj"> item_character.xml </strong>。这个布局将保存一个字符，该字符被提取。</p><figure class="kx ky kz la fd ij"><div class="bz dy l di"><div class="ll lm l"/></div></figure><h1 id="2a68" class="ju jv hi bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">用于存储和缓存数据的视图保持器</h1><p id="4cfd" class="pw-post-body-paragraph iv iw hi ix b iy ks ja jb jc kt je jf jg ku ji jj jk kv jm jn jo kw jq jr js hb bi translated">时间跳转回文件<strong class="ix hj"><em class="jt"/></strong>。创建一个新的ViewHolder类，其参数为<strong class="ix hj"><em class="jt">item character binding</em></strong>，并从<strong class="ix hj"> <em class="jt"> RecyclerView继承。</em>取景框</strong>。</p><pre class="kx ky kz la fd lb lc ld le aw lf bi"><span id="9e28" class="lg jv hi lc b fi lh li l lj lk">class CharacterViewHolder(val binding: ItemCharacterBinding) : RecyclerView.ViewHolder(binding.<em class="jt">root</em>)</span></pre><h1 id="7962" class="ju jv hi bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">用于显示数据的适配器</h1><p id="97e5" class="pw-post-body-paragraph iv iw hi ix b iy ks ja jb jc kt je jf jg ku ji jj jk kv jm jn jo kw jq jr js hb bi translated">我建议在上面的<strong class="ix hj"><em class="jt">character viewcholder</em></strong>中创建类<strong class="ix hj"><em class="jt">character adapter</em></strong>。<strong class="ix hj"><em class="jt">character adapter</em></strong>继承自:</p><pre class="kx ky kz la fd lb lc ld le aw lf bi"><span id="2185" class="lg jv hi lc b fi lh li l lj lk">ListAdapter&lt;<br/>CharactersListQuery.Result, <br/>CharacterViewHolder<br/>&gt;(CharacterDiffUtil())</span></pre><p id="a567" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">现在，我们必须重写onCreateViewHolder()和onBindViewHolder()方法。</p><p id="c279" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">onCreateViewHolder()只创建<strong class="ix hj"><em class="jt">character view holder</em></strong>并返回。</p><pre class="kx ky kz la fd lb lc ld le aw lf bi"><span id="d2ea" class="lg jv hi lc b fi lh li l lj lk">override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): CharacterViewHolder {<br/>    val binding: ItemCharacterBinding = DataBindingUtil.inflate(<br/>        LayoutInflater.from(parent.<em class="jt">context</em>),<br/>        R.layout.<em class="jt">item_character</em>,<br/>        parent,<br/>        false<br/>    )<br/>    return CharacterViewHolder(binding)<br/>}</span></pre><p id="edc2" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">onBindViewHolder()传递一个<strong class="ix hj"> <em class="jt"> CharactersListQuery的an对象。结果</em>到数据绑定布局</strong>。</p><pre class="kx ky kz la fd lb lc ld le aw lf bi"><span id="6ab9" class="lg jv hi lc b fi lh li l lj lk">override fun onBindViewHolder(holder: CharacterViewHolder, position: Int) {<br/>    holder.binding.<em class="jt">character </em>= getItem(position)<br/>}</span></pre><p id="2fcb" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这里总结一下<strong class="ix hj">文件<em class="jt"> CharacterAdapter。</em> </strong></p><figure class="kx ky kz la fd ij"><div class="bz dy l di"><div class="ll lm l"/></div></figure><p id="a49c" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">应用程序导航的片段组件</p><p id="99a7" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">打开<strong class="ix hj"> activity_main.xml </strong>，用<strong class="ix hj"><em class="jt">FragmentContainerView</em></strong>替换默认的<em class="jt"> TextView </em>，这样每个片段都会被加载到那里。</p><pre class="kx ky kz la fd lb lc ld le aw lf bi"><span id="5921" class="lg jv hi lc b fi lh li l lj lk">&lt;androidx.fragment.app.FragmentContainerView<br/>    android:id="@+id/nav_host_fragment"<br/>    android:name="androidx.navigation.fragment.NavHostFragment"<br/>    android:layout_width="0dp"<br/>    android:layout_height="0dp"<br/>    app:defaultNavHost="true"<br/>    app:layout_constraintBottom_toBottomOf="parent"<br/>    app:layout_constraintEnd_toEndOf="parent"<br/>    app:layout_constraintStart_toStartOf="parent"<br/>    app:layout_constraintTop_toTopOf="parent"<br/>    app:navGraph="@navigation/nav_main" /&gt;</span></pre><p id="c7f0" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">你会注意到最后一行:<em class="jt">app:nav graph = " @ navigation/nav _ main "</em>会是红色的。将光标放在这一行，按下<strong class="ix hj"> ALT + Enter </strong> (MacOS)，然后<strong class="ix hj">创建导航资源文件‘nav _ main . XML’</strong>。</p><p id="7874" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">打开<strong class="ix hj"> <em class="jt"> MainActivity </em> </strong>用<strong class="ix hj">andr identity point</strong>对其进行注释，并创建<strong class="ix hj"><em class="jt">activity main binding</em></strong>的一个属性和<strong class="ix hj"><em class="jt">nav controller</em></strong>的一个属性。然后在<em class="jt"> onCreate() </em>的主体中实例化这两个属性。在<strong class="ix hj">视图</strong>中创建包<strong class="ix hj"> ui。</strong>然后将<strong class="ix hj"> <em class="jt">主活动</em> </strong>移动到<strong class="ix hj">视图</strong>-&gt;-<strong class="ix hj">ui</strong>包中</p><figure class="kx ky kz la fd ij"><div class="bz dy l di"><div class="ll lm l"/></div></figure><p id="7982" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">第18行的方法<em class="jt">setupActionBarWithNavController(nav controller)</em>和方法<em class="jt"> onSupportNavigateUp() </em>在我们在下一部分添加另一个<em class="jt">片段</em>作为子片段时，将需要用于后退导航。动作栏中的后退箭头需要这两种方法。</p><h1 id="ea69" class="ju jv hi bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">用于显示字符列表的片段</h1><p id="e0e9" class="pw-post-body-paragraph iv iw hi ix b iy ks ja jb jc kt je jf jg ku ji jj jk kv jm jn jo kw jq jr js hb bi translated">转到<strong class="ix hj">RES</strong>-&gt;<strong class="ix hj">layout</strong>，创建一个名为<strong class="ix hj">fragment _ characters _ list . XML</strong>的新布局文件。该布局将显示字符列表。</p><figure class="kx ky kz la fd ij"><div class="bz dy l di"><div class="ll lm l"/></div></figure><p id="7166" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">跳转到套餐<strong class="ix hj">查看</strong>-&gt;-<strong class="ix hj">ui</strong>。创建文件<strong class="ix hj"><em class="jt">characters list Fragment</em></strong>并用<em class="jt">experimental routinesapi</em>和<em class="jt">andr identify point</em>对其进行注释，然后从<em class="jt"> Fragment </em>中继承。</p><pre class="kx ky kz la fd lb lc ld le aw lf bi"><span id="2530" class="lg jv hi lc b fi lh li l lj lk">@ExperimentalCoroutinesApi<br/>@AndroidEntryPoint<br/>class CharactersListFragment : Fragment()</span></pre><p id="38e4" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们需要三个属性:一个是<strong class="ix hj"><em class="jt">fragmentcharactersistbinding</em></strong>，一个是<strong class="ix hj"><em class="jt">character adapter</em></strong>，一个是<strong class="ix hj"><em class="jt">character viewmodel</em></strong>。</p><pre class="kx ky kz la fd lb lc ld le aw lf bi"><span id="5f90" class="lg jv hi lc b fi lh li l lj lk">private lateinit var binding: FragmentCharactersListBinding<br/>private val characterAdapter by <em class="jt">lazy </em><strong class="lc hj">{ </strong>CharacterAdapter() <strong class="lc hj">}<br/></strong>private val viewModel by <em class="jt">viewModels</em>&lt;CharacterViewModel&gt;()</span></pre><p id="c9c5" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">覆盖方法<em class="jt"> onCreateView() </em>，在那里实例化<strong class="ix hj"> <em class="jt">绑定</em> </strong>字段，返回<strong class="ix hj"> <em class="jt">绑定</em> </strong>的<em class="jt">根</em>字段。</p><pre class="kx ky kz la fd lb lc ld le aw lf bi"><span id="5668" class="lg jv hi lc b fi lh li l lj lk">override fun onCreateView(<br/>    inflater: LayoutInflater, container: ViewGroup?,<br/>    savedInstanceState: Bundle?<br/>): View {<br/>    binding = FragmentCharactersListBinding.inflate(inflater)<br/>    return binding.<em class="jt">root<br/></em>}</span></pre><p id="715e" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在主体中覆盖方法<em class="jt"> onViewCreated() </em>将<strong class="ix hj"><em class="jt">character Adapter</em></strong>分配给RecyclverView适配器。之后，从您的<strong class="ix hj"> <em class="jt">视图模型中调用<em class="jt"> queryCharactersList() </em>方法。</em> </strong>断行，写<strong class="ix hj"><em class="jt"/></strong>observe livedata()。</p><pre class="kx ky kz la fd lb lc ld le aw lf bi"><span id="9370" class="lg jv hi lc b fi lh li l lj lk">override fun onViewCreated(view: View, savedInstanceState: Bundle?) {<br/>    super.onViewCreated(view, savedInstanceState)<br/><br/>    binding.charactersRv.<em class="jt">adapter </em>= characterAdapter<br/>    viewModel.queryCharactersList()<br/>    observeLiveData()<br/>}</span></pre><p id="f072" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">方法<em class="jt"> observeLiveData() </em>将处理何时显示加载进度条、何时显示将列表分配给RecyclerView以及何时在显示屏上显示错误文本的逻辑。</p><figure class="kx ky kz la fd ij"><div class="bz dy l di"><div class="ll lm l"/></div></figure><h1 id="dc9b" class="ju jv hi bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">不要忘记在main_nav.xml中添加片段</h1><p id="e595" class="pw-post-body-paragraph iv iw hi ix b iy ks ja jb jc kt je jf jg ku ji jj jk kv jm jn jo kw jq jr js hb bi translated">在<strong class="ix hj"> nav_main.xml </strong>中添加<strong class="ix hj"><em class="jt">characters list分段</em> </strong>并设置为<em class="jt"> startDestination </em>。</p><figure class="kx ky kz la fd ij"><div class="bz dy l di"><div class="ll lm l"/></div></figure><p id="7a3f" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">最后，运行应用程序，看看你的结果</p><figure class="kx ky kz la fd ij er es paragraph-image"><div class="er es lo"><img src="../Images/6009388c30f5efa029ac46bd1a875313.png" data-original-src="https://miro.medium.com/v2/resize:fit:394/format:webp/1*BJfjmrffJz7cE-YFRXVtxw.png"/></div></figure><p id="5b2e" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">好了，第三部分到此为止。如果你喜欢这篇文章，请鼓掌。下面是<a class="ae iu" href="https://fahri-c93.medium.com/android-tutorial-part-4-using-apollo-library-to-fetch-data-from-a-graphql-endpoint-a621dfd98564" rel="noopener">第四部分</a>。</p><p id="324a" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这里是已完成的项目，检查分支<strong class="ix hj"> part_three </strong></p><p id="2434" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><a class="ae iu" href="https://github.com/fahrican/ApolloGraphQlTutorial/tree/part_three" rel="noopener ugc nofollow" target="_blank">https://github . com/fah Rican/apollographql tutorial/tree/part _ three</a></p></div></div>    
</body>
</html>