<html>
<head>
<title>LeetCode — Find First and Last Position of Element in Sorted Array</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">LeetCode —查找排序数组中元素的第一个和最后一个位置</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/leetcode-find-first-and-last-position-of-element-in-sorted-array-946c8eff533d?source=collection_archive---------28-----------------------#2021-06-06">https://medium.com/nerd-for-tech/leetcode-find-first-and-last-position-of-element-in-sorted-array-946c8eff533d?source=collection_archive---------28-----------------------#2021-06-06</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div class="er es if"><img src="../Images/88cb0e49c0bc8f9b981d7087f45b8844.png" data-original-src="https://miro.medium.com/v2/resize:fit:744/format:webp/0*fap57cCCY7ExkZW6.png"/></div></figure><h1 id="700e" class="im in hi bd io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj bi translated">问题陈述</h1><p id="1052" class="pw-post-body-paragraph jk jl hi jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh hb bi translated">给定一个按升序排序的整数数组<strong class="jm hj">num</strong>，找出给定<strong class="jm hj">目标</strong>值的起始和结束位置。</p><p id="c875" class="pw-post-body-paragraph jk jl hi jm b jn ki jp jq jr kj jt ju jv kk jx jy jz kl kb kc kd km kf kg kh hb bi translated">如果在数组中没有找到<strong class="jm hj">目标</strong>，返回<strong class="jm hj"> [-1，-1】</strong>。</p><p id="495b" class="pw-post-body-paragraph jk jl hi jm b jn ki jp jq jr kj jt ju jv kk jx jy jz kl kb kc kd km kf kg kh hb bi translated">问题陈述摘自:<a class="ae kn" href="https://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array" rel="noopener ugc nofollow" target="_blank">https://leet code . com/problems/find-first-and-last-position-of-element-in-sorted-array</a></p><p id="cec3" class="pw-post-body-paragraph jk jl hi jm b jn ki jp jq jr kj jt ju jv kk jx jy jz kl kb kc kd km kf kg kh hb bi translated"><strong class="jm hj">例1: </strong></p><pre class="ko kp kq kr fd ks kt ku kv aw kw bi"><span id="1709" class="kx in hi kt b fi ky kz l la lb">Input: nums = [5, 7, 7, 8, 8, 10], target = 8<br/>Output: [3, 4]</span></pre><p id="a305" class="pw-post-body-paragraph jk jl hi jm b jn ki jp jq jr kj jt ju jv kk jx jy jz kl kb kc kd km kf kg kh hb bi translated"><strong class="jm hj">例2: </strong></p><pre class="ko kp kq kr fd ks kt ku kv aw kw bi"><span id="8afa" class="kx in hi kt b fi ky kz l la lb">Input: nums = [5, 7, 7, 8, 8, 10], target = 6<br/>Output: [-1, -1]</span></pre><p id="ee25" class="pw-post-body-paragraph jk jl hi jm b jn ki jp jq jr kj jt ju jv kk jx jy jz kl kb kc kd km kf kg kh hb bi translated"><strong class="jm hj">例3: </strong></p><pre class="ko kp kq kr fd ks kt ku kv aw kw bi"><span id="8477" class="kx in hi kt b fi ky kz l la lb">Input: nums = [], target = 0<br/>Output: [-1, -1]</span></pre><p id="1ebc" class="pw-post-body-paragraph jk jl hi jm b jn ki jp jq jr kj jt ju jv kk jx jy jz kl kb kc kd km kf kg kh hb bi translated"><strong class="jm hj">约束:</strong></p><pre class="ko kp kq kr fd ks kt ku kv aw kw bi"><span id="2d55" class="kx in hi kt b fi ky kz l la lb">- 0 &lt;= nums.length &lt;= 10^5<br/>- -10^9 &lt;= nums[i] &lt;= 10^9<br/>- nums is a non-decreasing array.<br/>- -10^9 &lt;= target &lt;= 10^9</span></pre><h1 id="1836" class="im in hi bd io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj bi translated">说明</h1><h2 id="12e0" class="kx in hi bd io lc ld le is lf lg lh iw jv li lj ja jz lk ll je kd lm ln ji lo bi translated">强力</h2><p id="7c7b" class="pw-post-body-paragraph jk jl hi jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh hb bi translated">强力方法是对阵列进行线性扫描。我们使用两个指针<strong class="jm hj"> leftIndex </strong>和<strong class="jm hj"> rightIndex </strong>从第一个数组元素开始。</p><p id="8bc3" class="pw-post-body-paragraph jk jl hi jm b jn ki jp jq jr kj jt ju jv kk jx jy jz kl kb kc kd km kf kg kh hb bi translated">当找到第一个出现的<strong class="jm hj">目标</strong>元素时，我们将该索引分配给<strong class="jm hj"> leftIndex </strong>变量。我们继续迭代，直到元素与目标不同。我们将当前的<strong class="jm hj">索引-1</strong>值分配给<strong class="jm hj">右索引</strong>。</p><p id="5054" class="pw-post-body-paragraph jk jl hi jm b jn ki jp jq jr kj jt ju jv kk jx jy jz kl kb kc kd km kf kg kh hb bi translated">上述逻辑的C++代码片段如下:</p><pre class="ko kp kq kr fd ks kt ku kv aw kw bi"><span id="fd00" class="kx in hi kt b fi ky kz l la lb">int firstIndex = -1, lastIndex = -1;<br/>for (int i = 0; i &lt; n; i++) {<br/>    if (x != arr[i])<br/>        continue;<br/><br/>    if (firstIndex == -1)<br/>        firstIndex = i;<br/>    lastIndex = i;<br/>}</span></pre><h2 id="e58c" class="kx in hi bd io lc ld le is lf lg lh iw jv li lj ja jz lk ll je kd lm ln ji lo bi translated">二分搜索法溶液</h2><p id="a7f2" class="pw-post-body-paragraph jk jl hi jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh hb bi translated">解决这个问题的有效方法是使用二分搜索法。让我们检查下面的算法:</p><pre class="ko kp kq kr fd ks kt ku kv aw kw bi"><span id="8df7" class="kx in hi kt b fi ky kz l la lb">- set i = 0, j = nums.size() - 1<br/>- set leftIndex and rightIndex to -1<br/><br/>- loop while i &lt;= j<br/>  - set mid = i + (j - i)/2<br/><br/>  - if nums[mid] &gt; target<br/>    - set j = mid - 1<br/>  - else if nums[mid] &lt; target<br/>    - set i = mid + 1<br/>  - else<br/>    - leftIndex = mid<br/>    - set j = mid - 1<br/><br/>- set i = 0, j = nums.size() - 1<br/><br/>- loop while i &lt;= j<br/>  - set mid = i + (j - i)/2<br/><br/>  - if nums[mid] &gt; target<br/>    - set j = mid - 1<br/>  - else if nums[mid] &lt; target<br/>    - set i = mid + 1<br/>  - else<br/>    - rightIndex = mid<br/>    - set i = mid + 1<br/><br/>- return [leftIndex, rightIndex]</span></pre><p id="9489" class="pw-post-body-paragraph jk jl hi jm b jn ki jp jq jr kj jt ju jv kk jx jy jz kl kb kc kd km kf kg kh hb bi translated">上述方法的时间复杂度为<strong class="jm hj">O(log(N)】</strong>，空间复杂度为<strong class="jm hj"> O(1) </strong>。</p><p id="ed73" class="pw-post-body-paragraph jk jl hi jm b jn ki jp jq jr kj jt ju jv kk jx jy jz kl kb kc kd km kf kg kh hb bi translated"><strong class="jm hj"> C++解决方案</strong></p><pre class="ko kp kq kr fd ks kt ku kv aw kw bi"><span id="07ce" class="kx in hi kt b fi ky kz l la lb">class Solution {<br/>public:<br/>    vector&lt;int&gt; searchRange(vector&lt;int&gt;&amp; nums, int target) {<br/>        int i, j, mid;<br/>        i = 0;<br/>        j = nums.size() - 1;<br/>        int leftIndex = -1, rightIndex = -1;<br/><br/>        while(i &lt;= j){<br/>            mid = (i + j)/2;<br/>            if(nums[mid] &gt; target){<br/>                j = mid - 1;<br/>            } else if (nums[mid] &lt; target){<br/>                i = mid + 1;<br/>            } else {<br/>                leftIndex = mid;<br/>                j = mid - 1;<br/>            }<br/>        }<br/><br/>        i = 0; j = nums.size() - 1;<br/>        while(i &lt;= j){<br/>            mid = (i + j)/2;<br/>            if(nums[mid] &gt; target){<br/>                j = mid - 1;<br/>            } else if (nums[mid] &lt; target){<br/>                i = mid + 1;<br/>            } else {<br/>                rightIndex = mid;<br/>                i = mid + 1;<br/>            }<br/>        }<br/><br/>        vector&lt;int&gt; ans;<br/>        ans.push_back(leftIndex);<br/>        ans.push_back(rightIndex);<br/><br/>        return ans;<br/>    }<br/>};</span></pre><p id="87ba" class="pw-post-body-paragraph jk jl hi jm b jn ki jp jq jr kj jt ju jv kk jx jy jz kl kb kc kd km kf kg kh hb bi translated"><strong class="jm hj">戈朗解决方案</strong></p><pre class="ko kp kq kr fd ks kt ku kv aw kw bi"><span id="f909" class="kx in hi kt b fi ky kz l la lb">func searchRange(nums []int, target int) []int {<br/>    i, j := 0, len(nums) - 1<br/>    leftIndex, rightIndex := -1, -1<br/><br/>    for i &lt;= j {<br/>        mid := i + (j - i)/2<br/><br/>        if nums[mid] &gt; target {<br/>            j = mid - 1<br/>        } else if nums[mid] &lt; target {<br/>            i = mid + 1<br/>        } else {<br/>            leftIndex = mid<br/>            j = mid - 1<br/>        }<br/>    }<br/><br/>    i, j = 0, len(nums) - 1<br/><br/>    for i &lt;= j {<br/>        mid := i + (j - i)/2<br/><br/>        if nums[mid] &gt; target {<br/>            j = mid - 1<br/>        } else if nums[mid] &lt; target {<br/>            i = mid + 1<br/>        } else {<br/>            rightIndex = mid<br/>            i = mid + 1<br/>        }<br/>    }<br/><br/>    return []int{leftIndex, rightIndex}<br/>}</span></pre><p id="d2cf" class="pw-post-body-paragraph jk jl hi jm b jn ki jp jq jr kj jt ju jv kk jx jy jz kl kb kc kd km kf kg kh hb bi translated"><strong class="jm hj"> Javascript解决方案</strong></p><pre class="ko kp kq kr fd ks kt ku kv aw kw bi"><span id="a0ad" class="kx in hi kt b fi ky kz l la lb">var searchRange = function(nums, target) {<br/>    let i = 0, j = nums.length - 1, mid;<br/>    let leftIndex = -1, rightIndex = -1;<br/><br/>    while(i &lt;= j){<br/>        mid = ~~(i + (j - i) / 2);<br/><br/>        if(nums[mid] &gt; target){<br/>            j = mid - 1;<br/>        } else if (nums[mid] &lt; target){<br/>            i = mid + 1;<br/>        } else {<br/>            leftIndex = mid;<br/>            j = mid - 1;<br/>        }<br/>    }<br/><br/>    i = 0;<br/>    j = nums.length - 1;<br/><br/>    while(i &lt;= j){<br/>        mid = ~~(i + (j - i) / 2);<br/><br/>        if(nums[mid] &gt; target){<br/>            j = mid - 1;<br/>        } else if (nums[mid] &lt; target){<br/>            i = mid + 1;<br/>        } else {<br/>            rightIndex = mid;<br/>            i = mid + 1;<br/>        }<br/>    }<br/><br/>    return [leftIndex, rightIndex];<br/>};</span></pre><p id="39a1" class="pw-post-body-paragraph jk jl hi jm b jn ki jp jq jr kj jt ju jv kk jx jy jz kl kb kc kd km kf kg kh hb bi translated">让我们试运行一下我们的算法，看看解决方案是如何工作的。</p><pre class="ko kp kq kr fd ks kt ku kv aw kw bi"><span id="e4f7" class="kx in hi kt b fi ky kz l la lb">nums = [5, 7, 7, 8, 8, 10]<br/>target = 8<br/><br/>Step 1: i = 0<br/>        j = nums.size() - 1<br/>          = 6 - 1<br/>          = 5<br/><br/>Step 2: leftIndex = -1<br/>        rightIndex = -1<br/><br/>Step 3: loop while i &lt;= j<br/>        0 &lt;= 5<br/>        mid = 2<br/><br/>        nums[2] &gt; 8<br/>        7 &gt; 8<br/>        false<br/><br/>        nums[2] &lt; 8<br/>        7 &lt; 8<br/>        true<br/>        i = mid + 1<br/>          = 3<br/><br/>Step 4: loop while i &lt;= j<br/>        3 &lt;= 5<br/>        mid = 4<br/><br/>        nums[4] &gt; 8<br/>        8 &gt; 8<br/>        false<br/><br/>        nums[4] &lt; 8<br/>        8 &lt; 8<br/>        false<br/><br/>        nums[4] == 8<br/>        8 == 8<br/>        true<br/>        leftIndex = 4<br/>        j = 4 - 1<br/>          = 3<br/><br/>Step 5: loop while i &lt;= j<br/>        3 &lt;= 3<br/>        mid = 3<br/><br/>        nums[3] &gt; 8<br/>        8 &gt; 8<br/>        false<br/><br/>        nums[3] &lt; 8<br/>        8 &lt; 8<br/>        false<br/><br/>        nums[4] == 8<br/>        8 == 8<br/>        true<br/>        leftIndex = 3<br/>        j = 3 - 1<br/>          = 2<br/><br/>Step 6: loop while i &lt;= j<br/>        3 &lt;= 2<br/>        false<br/><br/>Step 7: i = 0<br/>        j = nums.size() - 1<br/>          = 6 - 1<br/>          = 5<br/><br/>Step 8: loop while i &lt;= j<br/>        0 &lt;= 5<br/>        mid = 2<br/><br/>        nums[2] &gt; 8<br/>        7 &gt; 8<br/>        false<br/><br/>        nums[2] &lt; 8<br/>        7 &lt; 8<br/>        true<br/>        i = mid + 1<br/>          = 3<br/><br/>Step 9: loop while i &lt;= j<br/>        3 &lt;= 5<br/>        mid = 4<br/><br/>        nums[4] &gt; 8<br/>        8 &gt; 8<br/>        false<br/><br/>        nums[4] &lt; 8<br/>        8 &lt; 8<br/>        false<br/><br/>        nums[4] == 8<br/>        8 == 8<br/>        true<br/>        rightIndex = 4<br/>        i = mid + 1<br/>          = 5<br/><br/>Step 10: loop while i &lt;= j<br/>         5 &lt;= 5<br/>         mid = 5<br/><br/>         nums[5] &gt; 8<br/>         10 &gt; 8<br/>         true<br/>         j = mid - 1<br/>           = 5 - 1<br/>           = 4<br/><br/>Step 11: loop while i &lt;= j<br/>         5 &lt;= 4<br/>         false<br/><br/>Step 12: return [3, 4]</span></pre></div><div class="ab cl lp lq gp lr" role="separator"><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu"/></div><div class="hb hc hd he hf"><p id="16aa" class="pw-post-body-paragraph jk jl hi jm b jn ki jp jq jr kj jt ju jv kk jx jy jz kl kb kc kd km kf kg kh hb bi translated"><em class="lw">原载于</em><a class="ae kn" href="https://alkeshghorpade.me/post/leetcode-find-first-and-last-position-of-element-in-sorted-array" rel="noopener ugc nofollow" target="_blank"><em class="lw">https://alkeshghorpade . me</em></a><em class="lw">。</em></p></div></div>    
</body>
</html>