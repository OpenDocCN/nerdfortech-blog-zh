<html>
<head>
<title>Stacked Package — Service Location, Routing &amp; Logging</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">堆叠包装—服务位置、路线和记录</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/stacked-package-service-location-routing-logging-b8bdc1e6c839?source=collection_archive---------5-----------------------#2021-07-19">https://medium.com/nerd-for-tech/stacked-package-service-location-routing-logging-b8bdc1e6c839?source=collection_archive---------5-----------------------#2021-07-19</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="c4c7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">大家好，我已经写了一篇文章，关于我们如何用堆叠包轻松处理加载状态和错误。</p><p id="a567" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="jd">在本文中，我们将了解堆叠包提供的各种服务。</em></p><p id="2283" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">堆叠包提供各种功能，如<strong class="ih hj">服务定位、路由、记录</strong>等。它通过代码生成使它们变得非常简单，你需要做的只是用<code class="du je jf jg jh b">@StackedApp </code>注释一个类并指定你想要的服务。</p><p id="ced7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">首先，在您的<code class="du je jf jg jh b">pubspec.yaml</code>中声明依赖项，</p><pre class="ji jj jk jl fd jm jh jn jo aw jp bi"><span id="1d84" class="jq jr hi jh b fi js jt l ju jv">dependencies:<br/>  <strong class="jh hj">stacked: ^2.2.2</strong><br/>  <strong class="jh hj">stacked_services: ^0.8.10</strong></span><span id="1322" class="jq jr hi jh b fi jw jt l ju jv">dev_dependencies:<br/>  <strong class="jh hj">build_runner: <br/>  stacked_generator:</strong></span></pre><h1 id="dc3a" class="jx jr hi bd jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt bi translated">按指定路线发送</h1><figure class="ji jj jk jl fd kv er es paragraph-image"><div role="button" tabindex="0" class="kw kx di ky bf kz"><div class="er es ku"><img src="../Images/4ba2ac2b77bda0055ded5cf722c69f72.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kO4V3dXa78gTPsqe6w_FYQ.jpeg"/></div></div><figcaption class="lc ld et er es le lf bd b be z dx translated">何塞·马丁·拉米雷斯·卡拉斯科在<a class="ae lg" href="https://unsplash.com/s/photos/route?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><h2 id="b046" class="jq jr hi bd jy lh li lj kc lk ll lm kg iq ln lo kk iu lp lq ko iy lr ls ks lt bi translated"><strong class="ak">设置</strong></h2><ol class=""><li id="0261" class="lu lv hi ih b ii lw im lx iq ly iu lz iy ma jc mb mc md me bi translated"><strong class="ih hj">用@StackedApp </strong>注释一个类</li></ol><p id="c01c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">创建一个文件，名字由你选择🙃，我把它命名为<code class="du je jf jg jh b">app.dart</code></p><p id="4354" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">然后，让我们为我们的应用程序指定一些<strong class="ih hj">路线</strong>，</p><pre class="ji jj jk jl fd jm jh jn jo aw jp bi"><span id="5c64" class="jq jr hi jh b fi js jt l ju jv"><strong class="jh hj">@StackedApp(<br/>  routes:[<br/>    </strong>MaterialRoute(page: HomePage,initial: true),<br/>    MaterialRoute(page: LoginPage),<strong class="jh hj"><br/>  ]<br/>)</strong><br/>class <strong class="jh hj">App</strong>{<br/>   //empty class, will be filled after code generation<br/>}</span></pre><ul class=""><li id="e687" class="lu lv hi ih b ii ij im in iq mf iu mg iy mh jc mi mc md me bi translated">我们刚刚宣布了两条路线，并将我们的主页设置为我们的初始路线。</li><li id="17a5" class="lu lv hi ih b ii mj im mk iq ml iu mm iy mn jc mi mc md me bi translated">这也支持嵌套路由(<a class="ae lg" href="https://pub.dev/packages/stacked" rel="noopener ugc nofollow" target="_blank"> docs </a>)</li></ul><p id="9f3a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> 2。运行代码生成器命令</strong></p><pre class="ji jj jk jl fd jm jh jn jo aw jp bi"><span id="498f" class="jq jr hi jh b fi js jt l ju jv">flutter pub<em class="jd"> </em>run<em class="jd"> build_runner build --delete-conflicting-outputs</em></span></pre><p id="2e51" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这将产生</p><blockquote class="mo mp mq"><p id="d29f" class="if ig jd ih b ii ij ik il im in io ip mr ir is it ms iv iw ix mt iz ja jb jc hb bi translated"><code class="du je jf jg jh b"><em class="hi">app.router.dart</em></code>:由<strong class="ih hj">路线</strong>参数自动生成。</p><p id="fc0d" class="if ig jd ih b ii ij ik il im in io ip mr ir is it ms iv iw ix mt iz ja jb jc hb bi translated"><code class="du je jf jg jh b"><em class="hi">app.locator.dart</em></code>:由<strong class="ih hj">依赖关系</strong>参数自动生成。</p><p id="23f2" class="if ig jd ih b ii ij ik il im in io ip mr ir is it ms iv iw ix mt iz ja jb jc hb bi translated"><code class="du je jf jg jh b"><em class="hi">app.logger.dart</em></code>:由<strong class="ih hj">记录器</strong>参数自动生成。</p></blockquote><blockquote class="mu"><p id="b188" class="mv mw hi bd mx my mz na nb nc nd jc dx translated">每次对@StackedApp 进行一些更改时，都必须运行这个命令</p></blockquote><p id="37d5" class="pw-post-body-paragraph if ig hi ih b ii ne ik il im nf io ip iq ng is it iu nh iw ix iy ni ja jb jc hb bi translated"><strong class="ih hj"> 3。在您的 MaterialApp </strong>中指定 onGenerateRoute，navigatorKey</p><pre class="ji jj jk jl fd jm jh jn jo aw jp bi"><span id="0086" class="jq jr hi jh b fi js jt l ju jv">class MyApp extends StatelessWidget {<br/>  @override<br/>  Widget build(BuildContext context) {<br/>    return MaterialApp(<br/>        title: 'My APP',<br/>        <strong class="jh hj">navigatorKey: StackedService.<em class="jd">navigatorKey</em>,<br/>        onGenerateRoute: StackedRouter().onGenerateRoute</strong>,<br/>    );<br/>  }<br/>}</span></pre><ul class=""><li id="5b2c" class="lu lv hi ih b ii ij im in iq mf iu mg iy mh jc mi mc md me bi translated">Navigator 键非常重要，它使我们能够在不明确使用上下文的情况下浏览页面。</li><li id="6ddb" class="lu lv hi ih b ii mj im mk iq ml iu mm iy mn jc mi mc md me bi translated">StackedApp 使用 auto_route 生成<code class="du je jf jg jh b">app.router.dart </code>文件。最棒的是，它为每条路由创建了一个路由器参数类(在构造函数中有相同的参数)，您可以在导航到目标类时使用它。</li></ul><p id="d9eb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">假设我们的 LoginPage 如下所示，</p><pre class="ji jj jk jl fd jm jh jn jo aw jp bi"><span id="dd6b" class="jq jr hi jh b fi js jt l ju jv">class LoginPage extends StatelessWidget {<br/>  <strong class="jh hj">String id;<br/>  LoginPage(this.id);</strong><br/>  //...<br/>}</span></pre><p id="9487" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><code class="du je jf jg jh b">app.router.dart</code>有一个<code class="du je jf jg jh b"><strong class="ih hj">LoginArguments </strong></code>类，作为构造函数参数的持有者，</p><pre class="ji jj jk jl fd jm jh jn jo aw jp bi"><span id="e3a0" class="jq jr hi jh b fi js jt l ju jv">class LoginPageArguments {<br/>  final String id;<br/>  LoginPageArguments({required this.id});<br/>}</span></pre><p id="65c4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们如何使用它？假设我们在一个视图模型中</p><pre class="ji jj jk jl fd jm jh jn jo aw jp bi"><span id="adbb" class="jq jr hi jh b fi js jt l ju jv"><em class="jd">//within a viewModel<br/></em>void move(){<br/>     //after registering navigationService as dependency(more on this later)<br/>     <strong class="jh hj">locator.get&lt;NavigationService()</strong><br/>            .navigateTo(<br/>                Routes.<em class="jd">loginPage</em>,<br/>                 <strong class="jh hj">arguments:</strong> <strong class="jh hj">LoginPageArguments(id: '1')</strong>);<br/>    <br/>    /* #### Equivalent to #####<br/>     <em class="jd">Navigator.of(context)<br/>              .pushNamed(Routes.loginPage,<br/>                  arguments:{id:1});<br/></em>    */ <br/>}</span></pre><p id="925d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这将把我们导航到带有传递的参数的 Loginpage。参数解组将由堆叠的包完成。</p><ul class=""><li id="6a23" class="lu lv hi ih b ii ij im in iq mf iu mg iy mh jc mi mc md me bi translated">当使用 LoginPageArguments 时，我们不能跳过任何<code class="du je jf jg jh b">required</code>参数，这为传递参数提供了<strong class="ih hj">编译时安全性</strong>。</li></ul><pre class="ji jj jk jl fd jm jh jn jo aw jp bi"><span id="b623" class="jq jr hi jh b fi js jt l ju jv"><strong class="jh hj">arguments:</strong> <strong class="jh hj">LoginPageArguments() //error, must pass 'id'</strong></span></pre><ul class=""><li id="7ea7" class="lu lv hi ih b ii ij im in iq mf iu mg iy mh jc mi mc md me bi translated">如您所见，我们在业务逻辑层中不使用任何上下文进行导航。这是使用堆叠服务的主要好处之一。</li></ul></div><div class="ab cl nj nk gp nl" role="separator"><span class="nm bw bk nn no np"/><span class="nm bw bk nn no np"/><span class="nm bw bk nn no"/></div><div class="hb hc hd he hf"><figure class="ji jj jk jl fd kv er es paragraph-image"><div role="button" tabindex="0" class="kw kx di ky bf kz"><div class="er es nq"><img src="../Images/c14f2637b1695941e9f459b93b5c52f6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*y7v50z18isGx7adfhWVKWQ.jpeg"/></div></div><figcaption class="lc ld et er es le lf bd b be z dx translated">Diana Polekhina 在<a class="ae lg" href="https://unsplash.com/s/photos/injection?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><h2 id="087a" class="jq jr hi bd jy lh li lj kc lk ll lm kg iq ln lo kk iu lp lq ko iy lr ls ks lt bi translated">2.依赖性注册</h2><p id="03db" class="pw-post-body-paragraph if ig hi ih b ii lw ik il im lx io ip iq nr is it iu ns iw ix iy nt ja jb jc hb bi translated">您可以在 stackedApp 注释中注册您的依赖项，它减少了<code class="du je jf jg jh b">get_it</code>包的大部分注册样板代码。我写了一篇关于 get_it 的文章，如果你有兴趣可以在这里<a class="ae lg" rel="noopener" href="/nerd-for-tech/implement-service-locator-design-pattern-with-get-it-flutter-5e50671bbbcb">阅读。</a></p><h2 id="c951" class="jq jr hi bd jy lh li lj kc lk ll lm kg iq ln lo kk iu lp lq ko iy lr ls ks lt bi translated">1.在@StackedApp 中指定依赖项</h2><pre class="ji jj jk jl fd jm jh jn jo aw jp bi"><span id="beb3" class="jq jr hi jh b fi js jt l ju jv">//code snippet from the official docs<br/><strong class="jh hj">@StackedApp</strong>(<br/>routes : [ ... ],<br/><strong class="jh hj">dependencies</strong>: [<br/>    <strong class="jh hj">LazySingleton</strong>(classType: ThemeService, resolveUsing: ThemeService.getInstance),</span><span id="2e2e" class="jq jr hi jh b fi jw jt l ju jv"><em class="jd">// abstracted class type support</em><br/>    <strong class="jh hj">LazySingleton</strong>(classType: FirebaseAuthService, asType: AuthService),</span><span id="d651" class="jq jr hi jh b fi jw jt l ju jv">    <strong class="jh hj">Singleton</strong>(classType: NavigationService),</span><span id="6d79" class="jq jr hi jh b fi jw jt l ju jv"><strong class="jh hj">Factory</strong>( classType: Counter)<strong class="jh hj">,</strong></span><span id="02d4" class="jq jr hi jh b fi jw jt l ju jv"><strong class="jh hj">Presolve</strong>(<br/>      classType: SharedPreferencesService,<br/>      presolveUsing: SharedPreferencesService.getInstance,<br/>    ),<br/>  ],<br/>)</span></pre><h2 id="0269" class="jq jr hi bd jy lh li lj kc lk ll lm kg iq ln lo kk iu lp lq ko iy lr ls ks lt bi translated">2.运行命令</h2><p id="00a8" class="pw-post-body-paragraph if ig hi ih b ii lw ik il im lx io ip iq nr is it iu ns iw ix iy nt ja jb jc hb bi translated">不要忘记运行命令，</p><pre class="ji jj jk jl fd jm jh jn jo aw jp bi"><span id="9635" class="jq jr hi jh b fi js jt l ju jv"><strong class="jh hj">flutter pub<em class="jd"> </em>run<em class="jd"> build_runner build --delete-conflicting-outputs</em></strong></span></pre><blockquote class="mo mp mq"><p id="8e1c" class="if ig jd ih b ii ij ik il im in io ip mr ir is it ms iv iw ix mt iz ja jb jc hb bi translated">这将生成<strong class="ih hj"> app.locator.dart </strong>，其中包含您指定的所有依赖项。</p></blockquote><h2 id="6d4b" class="jq jr hi bd jy lh li lj kc lk ll lm kg iq ln lo kk iu lp lq ko iy lr ls ks lt bi translated">3.从 runApp()调用 setupLocator()</h2><p id="bbd5" class="pw-post-body-paragraph if ig hi ih b ii lw ik il im lx io ip iq nr is it iu ns iw ix iy nt ja jb jc hb bi translated">另外，不要忘记从 runApp()调用 setupLocator()，</p><pre class="ji jj jk jl fd jm jh jn jo aw jp bi"><span id="aadc" class="jq jr hi jh b fi js jt l ju jv">import './<strong class="jh hj">app.locator.dart</strong>';<br/>void main() {<br/>  <strong class="jh hj">setupLocator()</strong>; //this function is inside the <strong class="jh hj"><em class="jd">app.router.dart</em></strong> file<br/>  runApp(MyApp());<br/>}</span></pre><p id="0166" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">4 种注册类型</strong></p><h2 id="6cb9" class="jq jr hi bd jy lh li lj kc lk ll lm kg iq ln lo kk iu lp lq ko iy lr ls ks lt bi translated">1.辛格尔顿&amp;拉兹辛格尔顿</h2><ul class=""><li id="d0aa" class="lu lv hi ih b ii lw im lx iq ly iu lz iy ma jc mi mc md me bi translated">Singleton —始终只创建和重用一个实例。</li><li id="50c5" class="lu lv hi ih b ii mj im mk iq ml iu mm iy mn jc mi mc md me bi translated">LazySingleton——类似于 Singleton，但实例仅在用户第一次请求时创建，而不是在应用程序启动时创建，这可以节省一些启动时间。</li></ul><p id="237d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">参数:</strong></p><ul class=""><li id="617c" class="lu lv hi ih b ii ij im in iq mf iu mg iy mh jc mi mc md me bi translated"><strong class="ih hj"> classType </strong>:要初始化的类的类型。</li><li id="9fb7" class="lu lv hi ih b ii mj im mk iq ml iu mm iy mn jc mi mc md me bi translated"><strong class="ih hj"> asType </strong>:要公开的类的类型。</li><li id="da90" class="lu lv hi ih b ii mj im mk iq ml iu mm iy mn jc mi mc md me bi translated"><strong class="ih hj"> resolveUsing </strong>:这里需要传递一个静态函数，这个函数可以返回<code class="du je jf jg jh b">classType</code>的实例。</li></ul><p id="edaa" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">示例:</p><pre class="ji jj jk jl fd jm jh jn jo aw jp bi"><span id="48d4" class="jq jr hi jh b fi js jt l ju jv">//abstract parent class<br/><strong class="jh hj">abstract class AuthService</strong> {<br/>    bool get isLoggedIn;<br/>    void login();<br/>    void logout();<br/>    void register();<br/>}</span></pre><p id="1d21" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们的 AuthService 实现</p><pre class="ji jj jk jl fd jm jh jn jo aw jp bi"><span id="58cc" class="jq jr hi jh b fi js jt l ju jv"><strong class="jh hj">class FirebaseAuthService extends AuthService</strong> {<br/>    //implements all the required methods of AuthService<br/>}</span></pre><p id="03d6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在我们要启动 FirebaseAuthService 并将其类型公开为其父类型(AuthService)，</p><pre class="ji jj jk jl fd jm jh jn jo aw jp bi"><span id="39ed" class="jq jr hi jh b fi js jt l ju jv"><strong class="jh hj">AuthService </strong>authService = <strong class="jh hj">FirebaseAuthService</strong>();</span></pre><p id="f183" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们可以使用相同的逻辑注册服务，</p><pre class="ji jj jk jl fd jm jh jn jo aw jp bi"><span id="2da4" class="jq jr hi jh b fi js jt l ju jv">LazySingleton(<strong class="jh hj">classType</strong>: <strong class="jh hj">FirebaseAuthService</strong>, <strong class="jh hj">asType</strong>: <strong class="jh hj">AuthService</strong>)</span></pre><h2 id="948d" class="jq jr hi bd jy lh li lj kc lk ll lm kg iq ln lo kk iu lp lq ko iy lr ls ks lt bi translated">2.工厂()</h2><p id="932a" class="pw-post-body-paragraph if ig hi ih b ii lw ik il im lx io ip iq nr is it iu ns iw ix iy nt ja jb jc hb bi translated">有时我们不想要单例，我们希望每次调用<code class="du je jf jg jh b">locator.get&lt;T&gt;()</code>时都有一个新的实例。可以使用 Factory()注册来实现。</p><pre class="ji jj jk jl fd jm jh jn jo aw jp bi"><span id="8b58" class="jq jr hi jh b fi js jt l ju jv"><strong class="jh hj">Factory</strong>(classType: Dog,asType: Animal,);</span></pre><p id="5fef" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">相当于</p><pre class="ji jj jk jl fd jm jh jn jo aw jp bi"><span id="fe79" class="jq jr hi jh b fi js jt l ju jv">Animal animal = new Dog();</span></pre><p id="d378" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在 get_it 中，它相当于，</p><pre class="ji jj jk jl fd jm jh jn jo aw jp bi"><span id="7e71" class="jq jr hi jh b fi js jt l ju jv">locator.registerFactory&lt;Animal&gt;(() =&gt; Dog());</span></pre><p id="e044" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">3.预求解()</p><p id="cd11" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">假设我们说你想在注册对象之前做一些<strong class="ih hj"> <em class="jd">未来</em> </strong>的计算，可以用<em class="jd"> Presolve() </em>。</p><pre class="ji jj jk jl fd jm jh jn jo aw jp bi"><span id="89b6" class="jq jr hi jh b fi js jt l ju jv">Presolve(<br/>      classType: SharedPreferencesService,<br/>      <strong class="jh hj"><em class="jd">presolveUsing: SharedPreferencesService.getInstance</em></strong>,<br/>    ),</span></pre><ul class=""><li id="dd04" class="lu lv hi ih b ii ij im in iq mf iu mg iy mh jc mi mc md me bi translated">presolveUsing:它也采用类似于<code class="du je jf jg jh b">resolveUsing </code>的静态方法，但是它<code class="du je jf jg jh b"> </code>必须返回指定类型的未来。<code class="du je jf jg jh b">Future&lt;classType&gt;</code></li></ul><pre class="ji jj jk jl fd jm jh jn jo aw jp bi"><span id="ddd2" class="jq jr hi jh b fi js jt l ju jv"><strong class="jh hj">static</strong> Future&lt;SharedPreferencesService&gt; getInstance() <strong class="jh hj">async</strong> {<br/>  <strong class="jh hj">//...</strong><br/>}</span></pre><p id="7e94" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如你所见，<code class="du je jf jg jh b">getInstance() </code>是一个静态方法，返回指定类型的未来值<code class="du je jf jg jh b">SharedPreferencesService.</code></p><ul class=""><li id="f2e4" class="lu lv hi ih b ii ij im in iq mf iu mg iy mh jc mi mc md me bi translated">如果我们尝试在没有预解的情况下注册，它将注册<code class="du je jf jg jh b">Future&lt;SharedPreferencesService&gt; </code>而不是<code class="du je jf jg jh b">SharedPreferencesService.</code>的类型</li><li id="7b90" class="lu lv hi ih b ii mj im mk iq ml iu mm iy mn jc mi mc md me bi translated">预解决'<strong class="ih hj">等待'</strong>,直到将来完成并注册实例。</li></ul><blockquote class="mo mp mq"><p id="23ce" class="if ig jd ih b ii ij ik il im in io ip mr ir is it ms iv iw ix mt iz ja jb jc hb bi translated">如果您注册了任何需要预先解决的依赖项，那么您必须将主函数更改为<strong class="ih hj"> Future，并等待 setupLocator </strong>调用。</p></blockquote><pre class="ji jj jk jl fd jm jh jn jo aw jp bi"><span id="cbbb" class="jq jr hi jh b fi js jt l ju jv">Future main() <strong class="jh hj">async</strong> {<br/>  <strong class="jh hj">await</strong> setupLocator();<br/>  runApp(MyApp());<br/>}</span></pre></div><div class="ab cl nj nk gp nl" role="separator"><span class="nm bw bk nn no np"/><span class="nm bw bk nn no np"/><span class="nm bw bk nn no"/></div><div class="hb hc hd he hf"><h2 id="294d" class="jq jr hi bd jy lh li lj kc lk ll lm kg iq ln lo kk iu lp lq ko iy lr ls ks lt bi translated">3.记录</h2><p id="eb05" class="pw-post-body-paragraph if ig hi ih b ii lw ik il im lx io ip iq nr is it iu ns iw ix iy nt ja jb jc hb bi translated">你如何调试你的程序？使用 print()，是时候改变了。堆叠封装提供开箱即用的<code class="du je jf jg jh b">logger </code>。</p><p id="4e0a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> 1。在@StackedApp </strong>中指定记录器</p><pre class="ji jj jk jl fd jm jh jn jo aw jp bi"><span id="441d" class="jq jr hi jh b fi js jt l ju jv"><strong class="jh hj">@StackedApp</strong>(<br/>routes: [..],<br/><strong class="jh hj">logger: StackedLogger()<br/></strong>)</span></pre><p id="2382" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> 2。安装记录器包</strong></p><pre class="ji jj jk jl fd jm jh jn jo aw jp bi"><span id="ec02" class="jq jr hi jh b fi js jt l ju jv">dependencies:<br/>  ...<br/>  logger:</span></pre><p id="d487" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">您可以调用 getLogger()，它返回一个 Logger，它更像一个 print()，但是它巧妙地格式化了消息，并赋予它一定的重要性。</p><pre class="ji jj jk jl fd jm jh jn jo aw jp bi"><span id="fd1f" class="jq jr hi jh b fi js jt l ju jv"><strong class="jh hj">class</strong> <strong class="jh hj">MyViewModel</strong> {<br/><strong class="jh hj">final</strong> logger = getLogger('MyViewModel');<br/><strong class="jh hj">void</strong> move() {<br/>    //importance level from low to high<br/>    logger.<strong class="jh hj">v</strong>("Verbose log");  //verbose<br/>    logger.<strong class="jh hj">d</strong>("Debug log");    //debug<br/>    logger.<strong class="jh hj">i</strong>("Info log");     //info<br/>    logger.<strong class="jh hj">w</strong>("Warning log");  //warning<br/>    logger.<strong class="jh hj">e</strong>("Error log");    //error<br/>    logger.<strong class="jh hj">wtf</strong>("What a terrible failure log"); //you know this<br/>  }<br/>}</span></pre><blockquote class="mo mp mq"><p id="62cc" class="if ig jd ih b ii ij ik il im in io ip mr ir is it ms iv iw ix mt iz ja jb jc hb bi translated">确保你传递给 getLogger()的类名与你所在的类相同。这将帮助记录器自动打印方法名。(本例中为 move())</p></blockquote><p id="029c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这将在您的控制台上打印以下消息</p><figure class="ji jj jk jl fd kv er es paragraph-image"><div role="button" tabindex="0" class="kw kx di ky bf kz"><div class="er es nu"><img src="../Images/bca36aa5b4d6d750d198d073c6890984.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*I8dezhcVGQjT82YMOaRWlA.png"/></div></div><figcaption class="lc ld et er es le lf bd b be z dx translated">表情类名|方法名—错误消息</figcaption></figure><p id="b168" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">您还可以过滤日志级别的日志，假设您只想打印日志级别为'<em class="jd">警告'</em>'的日志。你能做的，</p><pre class="ji jj jk jl fd jm jh jn jo aw jp bi"><span id="29c5" class="jq jr hi jh b fi js jt l ju jv">void main() {<br/>  runApp(MyApp());<br/>  <strong class="jh hj">Logger.<em class="jd">level </em>= Level.warning;<br/> </strong>//prints only ['warning','error','wtf'] logs<br/>}</span></pre><figure class="ji jj jk jl fd kv er es paragraph-image"><div role="button" tabindex="0" class="kw kx di ky bf kz"><div class="er es nv"><img src="../Images/d724577f5fd1d693ddcf9d94673a59f9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rnqX8C5a9x_aTYmsJfyaGA.png"/></div></div></figure><p id="5e0d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果你想用其他方法而不是<code class="du je jf jg jh b">getLogger()</code>来获取日志，你可以在<code class="du je jf jg jh b">StackedLogger</code>中覆盖它。</p><pre class="ji jj jk jl fd jm jh jn jo aw jp bi"><span id="6d96" class="jq jr hi jh b fi js jt l ju jv">@StackedApp(<br/>  routes:[..],<br/>  logger: StackedLogger(<br/>    <strong class="jh hj">logHelperName: 'getMyLogger' </strong>//default: 'getLogger'<br/>  )<br/>)</span></pre><p id="b4db" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">您可以使用以下命令调用记录器:</p><pre class="ji jj jk jl fd jm jh jn jo aw jp bi"><span id="9ec5" class="jq jr hi jh b fi js jt l ju jv">getMyLogger(‘className);</span></pre><p id="b79d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">有了<code class="du je jf jg jh b">Stacked </code>包，你就可以<strong class="ih hj">自动生成表单</strong>另外，要了解更多信息，可以去看看<a class="ae lg" href="https://pub.dev/packages/stacked" rel="noopener ugc nofollow" target="_blank">官方文档</a>，在我看来，它写得非常好。感谢您的阅读。拍手声👏如果你喜欢这篇文章。</p></div></div>    
</body>
</html>