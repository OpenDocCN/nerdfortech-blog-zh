<html>
<head>
<title>Thinking Recursively #1</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">递归思考#1</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/thinking-recursively-1-with-python-ac48ae78201a?source=collection_archive---------10-----------------------#2021-08-17">https://medium.com/nerd-for-tech/thinking-recursively-1-with-python-ac48ae78201a?source=collection_archive---------10-----------------------#2021-08-17</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="2743" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">递归是编程中很难理解的概念之一。尽管我们都是通过编写递归阶乘函数开始我们的编程之旅，但在此之后，我们大多数人都采用迭代方法(循环)来解决问题。连我也做过同样的事。但是在学习了 Haskell 课程后，我发现递归函数是多么迷人。所以我想和你分享一下。</p><p id="e147" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我决定用 python 复制 Haskell 递归函数。我还将提供伪代码，以便任何人都可以理解其中的逻辑。</p><p id="19d9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">本文将向您介绍一些基本的递归函数，这些函数对于掌握递归概念非常重要，我将在以后的文章中介绍更高级的函数。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es jd"><img src="../Images/088cd71f6dd67ccf888875868a820f26.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5DCww_beoZoJCNE3cCk7ug.jpeg"/></div></div><figcaption class="jp jq et er es jr js bd b be z dx translated">在<a class="ae jt" href="https://unsplash.com/s/photos/infinite-spiral?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上由<a class="ae jt" href="https://unsplash.com/@luddelorentz?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Ludde Lorentz </a>拍摄的照片</figcaption></figure></div><div class="ab cl ju jv gp jw" role="separator"><span class="jx bw bk jy jz ka"/><span class="jx bw bk jy jz ka"/><span class="jx bw bk jy jz"/></div><div class="hb hc hd he hf"><h2 id="b6c6" class="kb kc hi bd kd ke kf kg kh ki kj kk kl iq km kn ko iu kp kq kr iy ks kt ku kv bi translated">基础案例</h2><p id="912e" class="pw-post-body-paragraph if ig hi ih b ii kw ik il im kx io ip iq ky is it iu kz iw ix iy la ja jb jc hb bi translated">递归只不过是一个调用自身的函数。但是一个函数怎么知道是时候停止调用自己了呢？那就是所谓的<strong class="ih hj">基地案例</strong>。每个递归函数都有<strong class="ih hj">至少一个基础用例</strong>。</p><h2 id="9ca1" class="kb kc hi bd kd ke kf kg kh ki kj kk kl iq km kn ko iu kp kq kr iy ks kt ku kv bi translated">我们如何知道什么是基本情况？</h2><p id="d23f" class="pw-post-body-paragraph if ig hi ih b ii kw ik il im kx io ip iq ky is it iu kz iw ix iy la ja jb jc hb bi translated">它们是递归函数的最小单元，我们预先知道递归函数的输出。例如</p><blockquote class="lb lc ld"><p id="68bd" class="if ig le ih b ii ij ik il im in io ip lf ir is it lg iv iw ix lh iz ja jb jc hb bi translated">我们知道 0 的阶乘是 1，所以它是阶乘函数的基本情况。</p><p id="98af" class="if ig le ih b ii ij ik il im in io ip lf ir is it lg iv iw ix lh iz ja jb jc hb bi translated">我们知道第一个斐波那契数列是 1，第二个斐波那契数列也是 1。所以它们是求第 n 个斐波那契数递归函数的基础条件。</p></blockquote><p id="6384" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在本文中，我们将看到如何递归地解决下面给出的问题</p><blockquote class="li"><p id="12bb" class="lj lk hi bd ll lm ln lo lp lq lr jc dx translated">1.阶乘</p><p id="c6cc" class="lj lk hi bd ll lm ln lo lp lq lr jc dx translated">2.数字的 GCD</p><p id="447d" class="lj lk hi bd ll lm ln lo lp lq lr jc dx translated">3.反转一个数字</p><p id="ba2a" class="lj lk hi bd ll lm ln lo lp lq lr jc dx translated">4.以 K 为底的整数对数</p><p id="40a1" class="lj lk hi bd ll lm ln lo lp lq lr jc dx translated">5.一个数的最大除数</p><p id="ae04" class="lj lk hi bd ll lm ln lo lp lq lr jc dx translated">6.列表的长度</p></blockquote><h2 id="651c" class="kb kc hi bd kd ke ls kg kh ki lt kk kl iq lu kn ko iu lv kq kr iy lw kt ku kv bi translated">1.阶乘</h2><p id="a0bb" class="pw-post-body-paragraph if ig hi ih b ii kw ik il im kx io ip iq ky is it iu kz iw ix iy la ja jb jc hb bi translated">考虑下面的递归阶乘函数，</p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="lx ly l"/></div></figure><pre class="je jf jg jh fd lz ma mb mc aw md bi"><span id="dea1" class="kb kc hi ma b fi me mf l mg mh">&gt;&gt; factorial(5)<br/><strong class="ma hj">120</strong></span></pre><p id="fed2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果您查看函数调用是如何发生的，它将类似于</p><pre class="je jf jg jh fd lz ma mb mc aw md bi"><span id="d076" class="kb kc hi ma b fi me mf l mg mh">factorial(5)<br/>5*factorial(4)<br/>5*(<strong class="ma hj">4*factorial(3)</strong>)<br/>5*(4*<strong class="ma hj">(3*factorial(2))</strong>)<br/>5*(4*(3*<strong class="ma hj">(2*factorial(1))</strong>))<br/>5*(4*(3*(2*<strong class="ma hj">(1*factorial(0))</strong>))) //base-case<br/>5*(4*(3*(2*(1*<strong class="ma hj">1</strong>))))   //factorial(0) returns 1<br/>5*(4*(3*(2*1)))<br/>5*(4*(3*2))<br/>5*(4*6)<br/>5* 24<br/>120</span></pre><p id="d414" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果我不指定基本情况，函数会继续调用自己，这将导致堆栈溢出。</p><pre class="je jf jg jh fd lz ma mb mc aw md bi"><span id="c1af" class="kb kc hi ma b fi me mf l mg mh">#if base case isn't specified<br/>5*(4*(3*(2*(1*<strong class="ma hj">(0*factorial(-1))</strong>))))<br/>5*(4*(3*(2*(1*(0*(-1*<strong class="ma hj">factorial(-2)))</strong>))))<br/>...<br/>...</span></pre></div><div class="ab cl ju jv gp jw" role="separator"><span class="jx bw bk jy jz ka"/><span class="jx bw bk jy jz ka"/><span class="jx bw bk jy jz"/></div><div class="hb hc hd he hf"><h2 id="c5a6" class="kb kc hi bd kd ke kf kg kh ki kj kk kl iq km kn ko iu kp kq kr iy ks kt ku kv bi translated"><strong class="ak"> 2。计算 GCD </strong></h2><p id="45cf" class="pw-post-body-paragraph if ig hi ih b ii kw ik il im kx io ip iq ky is it iu kz iw ix iy la ja jb jc hb bi translated">你知道我们如何递归计算一个数的 gcd 吗？这很简单</p><pre class="je jf jg jh fd lz ma mb mc aw md bi"><span id="2379" class="kb kc hi ma b fi me mf l mg mh">FUNCTION INTEGER GCD (INTEGER NUM1, INTEGER NUM2)<br/>        if NUM1==0 <br/>            RETURN NUM2<br/>        else<br/>            RETURN GCD(NUM2, NUM2 MOD NUM1)</span></pre><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="lx ly l"/></div><figcaption class="jp jq et er es jr js bd b be z dx translated">gcd 的 python 代码</figcaption></figure><pre class="je jf jg jh fd lz ma mb mc aw md bi"><span id="d013" class="kb kc hi ma b fi me mf l mg mh">gcd(20,25)  <br/>gcd(25%20,20) =&gt; gcd(5,20)  <br/>gcd(20%5,5)  =&gt;  gcd(0,5)<br/><strong class="ma hj">5 is returned  since basecase is met (num1=0)</strong></span></pre></div><div class="ab cl ju jv gp jw" role="separator"><span class="jx bw bk jy jz ka"/><span class="jx bw bk jy jz ka"/><span class="jx bw bk jy jz"/></div><div class="hb hc hd he hf"><h2 id="b911" class="kb kc hi bd kd ke kf kg kh ki kj kk kl iq km kn ko iu kp kq kr iy ks kt ku kv bi translated">3.反转一个数字</h2><p id="dbef" class="pw-post-body-paragraph if ig hi ih b ii kw ik il im kx io ip iq ky is it iu kz iw ix iy la ja jb jc hb bi translated">给定一个数字“1234 ”,我们的目标是将它反转为“4321 ”,我们如何递归地做到这一点？</p><pre class="je jf jg jh fd lz ma mb mc aw md bi"><span id="fb06" class="kb kc hi ma b fi me mf l mg mh">//PSEUDOCODE<br/>FUNCTION INTEGER <strong class="ma hj">REVERSENUMBER</strong>(INTEGER N)<br/>     return REVERSENUMBER_UTIL(N,0)</span><span id="c892" class="kb kc hi ma b fi mi mf l mg mh">FUNCTION INTEGER <strong class="ma hj">REVERSENUMBER_UTIL</strong>(INTEGER N, INTEGER RES)<br/>     IF N==0<br/>         RETURN RES <br/>     ELSE<br/>         INTEGER REM = N MOD 10<br/>         INTEGER QUOTIENT = N DIV 10<br/>         RETURN REVERSENUMBER_UTIL(QUOTIENT, RES*10 + REM ))</span></pre><p id="66b4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果你看伪代码，我把 reverse()函数分成了<code class="du mj mk ml ma b"><strong class="ih hj">reverse(n)</strong></code>和<code class="du mj mk ml ma b"><strong class="ih hj">reverseUtil(n,res)</strong></code> <strong class="ih hj"> </strong>这在递归函数中很常见。在<code class="du mj mk ml ma b">reverse()</code>函数(用户调用的函数)中，我们可以进行配置更改，比如设置默认值，做一些验证检查等，然后从函数中调用实用函数，这是真正的递归函数。</p><ul class=""><li id="1118" class="mm mn hi ih b ii ij im in iq mo iu mp iy mq jc mr ms mt mu bi translated">我将默认值作为<strong class="ih hj"> 0 传递给参数‘RES’。</strong>以便用户可以用<code class="du mj mk ml ma b"> reverse(n)</code>而不是<code class="du mj mk ml ma b">reverse(n,0)</code>调用该函数(我们在这里隐藏了实现细节)</li><li id="af78" class="mm mn hi ih b ii mv im mw iq mx iu my iy mz jc mr ms mt mu bi translated"><strong class="ih hj">验证检查</strong> —如果我们传递负值，我们的函数将失败。所以在调用实际的递归函数之前。如果传递的值是一个负数，我们可以抛出一个错误，或者我们可以把它变成一个正数，然后把它传递给实用函数。</li></ul><pre class="je jf jg jh fd lz ma mb mc aw md bi"><span id="734a" class="kb kc hi ma b fi me mf l mg mh">FUNCTION INTEGER <strong class="ma hj">REVERSENUMBER</strong>(INTEGER N)<br/>    IF N&gt;=0<br/>        return REVERSENUMBER_UTIL(N,0)<br/>    ELSE<br/>        return <strong class="ma hj">-1 * REVERSENUMBER(-N)</strong></span></pre><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="lx ly l"/></div><figcaption class="jp jq et er es jr js bd b be z dx translated">Python 代码</figcaption></figure><p id="9907" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在 python 中，我们有一个叫做默认参数的概念。如果没有为该参数指定值，将使用其默认值。所以你可以用</p><pre class="je jf jg jh fd lz ma mb mc aw md bi"><span id="b7df" class="kb kc hi ma b fi me mf l mg mh">&gt;&gt;&gt; reverse(1234)   <br/>4321</span></pre><p id="c8e7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们看看这些功能是如何在幕后分解的，</p><pre class="je jf jg jh fd lz ma mb mc aw md bi"><span id="84e9" class="kb kc hi ma b fi me mf l mg mh">1.<strong class="ma hj">reverse(1234)</strong></span><span id="e0a2" class="kb kc hi ma b fi mi mf l mg mh">2.reverse(1234/10, 0*10+ 1234%10) <br/>  reverse(123, 0+4)<br/>  <strong class="ma hj">reverse(123, 4)</strong></span><span id="83f8" class="kb kc hi ma b fi mi mf l mg mh">3.reverse(123/10, 4*10 + 123%10)<br/>  reverse(12, 4*10 + 3)<br/>  <strong class="ma hj">reverse(12,43)</strong></span><span id="36d0" class="kb kc hi ma b fi mi mf l mg mh">4.reverse(12/10, 43*10 + 12%10)<br/>  reverse(1, 430+2)<br/>  <strong class="ma hj">reverse(1,432)</strong></span><span id="62b3" class="kb kc hi ma b fi mi mf l mg mh">5.reverse(1/10,432*10 + 1%10)<br/>  reverse(0, 4320 + 1)<br/>  reverse(0,4321)</span><span id="f485" class="kb kc hi ma b fi mi mf l mg mh">6. Base case hit (n=0)<br/>   so, return 4321 </span></pre></div><div class="ab cl ju jv gp jw" role="separator"><span class="jx bw bk jy jz ka"/><span class="jx bw bk jy jz ka"/><span class="jx bw bk jy jz"/></div><div class="hb hc hd he hf"><h2 id="07fe" class="kb kc hi bd kd ke kf kg kh ki kj kk kl iq km kn ko iu kp kq kr iy ks kt ku kv bi translated">4.计算以 k 为底的整数对数</h2><blockquote class="li"><p id="e176" class="lj lk hi bd ll lm ln lo lp lq lr jc dx translated"><em class="na">一个数的对数是该数的底数的幂。</em></p></blockquote><p id="0758" class="pw-post-body-paragraph if ig hi ih b ii nb ik il im nc io ip iq nd is it iu ne iw ix iy nf ja jb jc hb bi translated">例如，Logₖ(N) = x。该表达式表示“<strong class="ih hj"> k”的 x 次方等于 n。</strong></p><pre class="je jf jg jh fd lz ma mb mc aw md bi"><span id="c741" class="kb kc hi ma b fi me mf l mg mh">log₂(8) = 3<br/>2³ will give 8</span></pre><p id="e1b8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">例如，在整数 Log 中，我们将对结果取整</p><blockquote class="lb lc ld"><p id="66f0" class="if ig le ih b ii ij ik il im in io ip lf ir is it lg iv iw ix lh iz ja jb jc hb bi translated">log₂(9) = <strong class="ih hj"> 3.169925 </strong></p></blockquote><p id="ea1f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们填充 floor 并返回结果 3</p><pre class="je jf jg jh fd lz ma mb mc aw md bi"><span id="e071" class="kb kc hi ma b fi me mf l mg mh">FUNCTION INTEGER_LOG(INTEGER N, INTEGER BASE)</span><span id="2d81" class="kb kc hi ma b fi mi mf l mg mh">        IF N&lt;BASE OR BASE&lt;=1:<br/>              RETURN 0</span><span id="d5f5" class="kb kc hi ma b fi mi mf l mg mh">        ELSE<br/>            RETURN 1 + INTEGER_LOG(N DIV 10, BASE)</span></pre><p id="f5db" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">基本条件是</p><ol class=""><li id="3d35" class="mm mn hi ih b ii ij im in iq mo iu mp iy mq jc ng ms mt mu bi translated"><code class="du mj mk ml ma b">N&lt;Base</code>这意味着如果数字小于<code class="du mj mk ml ma b">base </code>，则返回 0，因为<code class="du mj mk ml ma b">base </code>的任意次幂(≥1)将总是产生大于 n 的值。例如 logₙ(1),logₙ(2),…logₙ(n-1)将总是产生 0。</li><li id="f429" class="mm mn hi ih b ii mv im mw iq mx iu my iy mz jc ng ms mt mu bi translated"><code class="du mj mk ml ma b">Base≤1</code>这是非常明显的，对于任何 k≤1，logₖ(n) =未定义。</li></ol><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="lx ly l"/></div></figure><pre class="je jf jg jh fd lz ma mb mc aw md bi"><span id="4e5b" class="kb kc hi ma b fi me mf l mg mh">intLog(20,2)<br/>= <strong class="ma hj">1+intLog(10,2)</strong><br/>= 1+<strong class="ma hj">(1+intLog(5,2))</strong><br/>= 1+(1+<strong class="ma hj">(1+(intLog(2,2))</strong>))<br/>= 1+(1+(1+<strong class="ma hj">(1+(intLog(1,2))</strong>))<br/>= 1+(1+(1+(1+<strong class="ma hj">0</strong>))))  #base-case hit, n&lt;base, 1&lt;2<br/>= 4</span></pre><h2 id="d640" class="kb kc hi bd kd ke kf kg kh ki kj kk kl iq km kn ko iu kp kq kr iy ks kt ku kv bi translated">5.最大除数</h2><p id="c5d0" class="pw-post-body-paragraph if ig hi ih b ii kw ik il im kx io ip iq ky is it iu kz iw ix iy la ja jb jc hb bi translated">给定一个数，求该数的最大除数。</p><blockquote class="lb lc ld"><p id="28e2" class="if ig le ih b ii ij ik il im in io ip lf ir is it lg iv iw ix lh iz ja jb jc hb bi translated">例如</p><p id="3659" class="if ig le ih b ii ij ik il im in io ip lf ir is it lg iv iw ix lh iz ja jb jc hb bi translated">50 的最大除数是 25</p><p id="4efa" class="if ig le ih b ii ij ik il im in io ip lf ir is it lg iv iw ix lh iz ja jb jc hb bi translated">25 的最大除数是 5</p><p id="31bd" class="if ig le ih b ii ij ik il im in io ip lf ir is it lg iv iw ix lh iz ja jb jc hb bi translated">17 的最大除数是 1</p></blockquote><p id="25ed" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">伪代码是</p><pre class="je jf jg jh fd lz ma mb mc aw md bi"><span id="d402" class="kb kc hi ma b fi me mf l mg mh">FUNCTION INTEGER <strong class="ma hj">LARGESTDIVISOR</strong>(INTEGER N)<br/>     IF N&gt;=0 <br/>         RETURN LARGESTDIVISOR_UTIL(N, N DIV 2)<br/>     ELSE<br/>        RETURN LARGESTDIVISOR(-N)<br/>-----------------------------------------------------<br/>FUNCTION INTEGER <strong class="ma hj">LARGESTDIVISOR_UTIL</strong>(INTEGER num, INTEGER divisor)<br/>     IF (divisor==1) OR ((num MOD divisor)==0)<br/>         RETURN B  <br/>     ELSE<br/>         RETURN <strong class="ma hj">LARGESTDIVISOR_UTIL</strong>(num,divisor-1)</span></pre><ol class=""><li id="f5a7" class="mm mn hi ih b ii ij im in iq mo iu mp iy mq jc ng ms mt mu bi translated">如果 N≥0，我们调用 N 和 N/2 的效用函数。N/2 的原因是，它是最大除数的上界，意味着任何数的最大除数是该数的一半<code class="du mj mk ml ma b">n</code>例如</li></ol><pre class="je jf jg jh fd lz ma mb mc aw md bi"><span id="a1ad" class="kb kc hi ma b fi me mf l mg mh">Divisor of 30 is  2,3,5,6,10,15.<br/>Divisor of 15 is  3,5. </span></pre><p id="d132" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">因为对于 N/2 之后的任意一个数 k，<code class="du mj mk ml ma b">k*2&gt;N</code>所以在 N/2 之后搜索只是浪费计算，因为总是会失败。</p><p id="27f8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">2.如果 N&lt;0，我们将负数转换为正数，并再次传递给同一个函数。例如</p><pre class="je jf jg jh fd lz ma mb mc aw md bi"><span id="0e50" class="kb kc hi ma b fi me mf l mg mh">LARGESTDIVISOR(<strong class="ma hj">-5</strong>) WILL CALL<strong class="ma hj"> LARGESTDIVISOR(5)</strong></span></pre><p id="84eb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Util 函数背后的逻辑是我们正在尝试从<code class="du mj mk ml ma b">N/2 … 1</code>开始的所有数字，所以第一个除数应该是最大的除数。</p><p id="2d4f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在 Util 函数中，基本条件是</p><ol class=""><li id="e601" class="mm mn hi ih b ii ij im in iq mo iu mp iy mq jc ng ms mt mu bi translated">如果<code class="du mj mk ml ma b">divisor</code>参数达到 1，这意味着它不能被任何其他数整除，所以它是一个质数。任何素数的约数都是<strong class="ih hj"> 1 &amp;本身</strong>。所以最大的除数是 1。(我们不能把数字本身作为它的最大除数)</li><li id="7d07" class="mm mn hi ih b ii mv im mw iq mx iu my iy mz jc ng ms mt mu bi translated">当'<strong class="ih hj"> num '对' divisor '取模为 0 </strong>时，这意味着<code class="du mj mk ml ma b">divisor</code>变量是该数字的一个除数。然后我们就可以返回<code class="du mj mk ml ma b">divisor</code>了。</li></ol><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="lx ly l"/></div><figcaption class="jp jq et er es jr js bd b be z dx translated">python 代码</figcaption></figure><pre class="je jf jg jh fd lz ma mb mc aw md bi"><span id="ccb8" class="kb kc hi ma b fi me mf l mg mh">largestDivisor(15) <br/>= largest_div_util(15,15/2)<br/>largest_div_util(15,7)<br/>largest_div_util(15,6)<br/><strong class="ma hj">largest_div_util(15,5)</strong>  #base-condition met: a%b==0 so return 5<br/>5</span></pre><h2 id="6e1d" class="kb kc hi bd kd ke kf kg kh ki kj kk kl iq km kn ko iu kp kq kr iy ks kt ku kv bi translated">6.列表的长度</h2><p id="5f14" class="pw-post-body-paragraph if ig hi ih b ii kw ik il im kx io ip iq ky is it iu kz iw ix iy la ja jb jc hb bi translated">你有没有想过我们如何递归地找到一个列表的长度？让我们看看</p><pre class="je jf jg jh fd lz ma mb mc aw md bi"><span id="32b0" class="kb kc hi ma b fi me mf l mg mh">FUNCTION INTEGER LENGTH(LIST L)<br/>     IF L.ISEMPTY() <br/>           RETURN 0<br/>     ELSE<br/>          RETURN 1 + LENGTH[1..n]  </span></pre><p id="1e79" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">基本条件:我们知道空列表的长度是 0</p><p id="609b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">逻辑:非空列表的长度是，1 加上除第一个元素之外的其余元素的长度<strong class="ih hj">。我们称之为列表的<strong class="ih hj">尾部</strong>。</strong></p><pre class="je jf jg jh fd lz ma mb mc aw md bi"><span id="bf64" class="kb kc hi ma b fi me mf l mg mh">tail of [1,2,3,4] is [2,3,4] </span></pre><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="lx ly l"/></div></figure><pre class="je jf jg jh fd lz ma mb mc aw md bi"><span id="ebc7" class="kb kc hi ma b fi me mf l mg mh">length([1,2,3,4,5])<br/>=1+length([2,3,4,5])<br/>=1+(<strong class="ma hj">1+ length([3,4,5]))</strong><br/>=1+(1+<strong class="ma hj">(1+length([4,5]))</strong>)<br/>=1+(1+(1+<strong class="ma hj">(1+length([5]))</strong>))<br/>=1+(1+(1+(1+<strong class="ma hj">(1+length([]))</strong>)))<br/>=1+(1+(1+(1+(1+<strong class="ma hj">0</strong>))))  #base condition: length([]) = 0<br/><strong class="ma hj">output: 5</strong></span></pre></div><div class="ab cl ju jv gp jw" role="separator"><span class="jx bw bk jy jz ka"/><span class="jx bw bk jy jz ka"/><span class="jx bw bk jy jz"/></div><div class="hb hc hd he hf"><p id="44c8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">迭代方法比递归方法更优化，但是作为一个程序员，我们都需要体验递归的魔力，因为这个世界正在慢慢地从面向对象转向函数式编程，学习递归地解决一个程序肯定会使你成为一个更好的函数式程序员。</p><p id="49c2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">感谢您阅读这篇文章，我们已经看到了一些初级递归函数，在我的下一篇文章中，我们将探索一些更复杂的递归函数，我觉得它们非常有用和优雅。拍手声👏如果你喜欢这篇文章。</p></div></div>    
</body>
</html>