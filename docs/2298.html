<html>
<head>
<title>Dockerize and deploy Node.js applications using GitHub Actions and Packages</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用GitHub操作和包来整理和部署Node.js应用程序</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/dockerize-and-deploy-node-js-applications-using-github-actions-and-packages-a523daf587a0?source=collection_archive---------6-----------------------#2021-04-30">https://medium.com/nerd-for-tech/dockerize-and-deploy-node-js-applications-using-github-actions-and-packages-a523daf587a0?source=collection_archive---------6-----------------------#2021-04-30</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/2226cd749904ab67fb95543859a567f7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wr-pTA4_CDWVZ5TuFq4aGw.jpeg"/></div></div></figure><h1 id="e77e" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">先决条件</h1><ul class=""><li id="72ec" class="jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf bi translated">已安装<a class="ae kg" href="https://nodejs.org/en/" rel="noopener ugc nofollow" target="_blank"> Node.js </a>和npm</li><li id="92e9" class="jo jp hi jq b jr kh jt ki jv kj jx kk jz kl kb kc kd ke kf bi translated">安装和配置<a class="ae kg" href="https://www.docker.com/" rel="noopener ugc nofollow" target="_blank"> Docker </a></li><li id="b9c5" class="jo jp hi jq b jr kh jt ki jv kj jx kk jz kl kb kc kd ke kf bi translated"><a class="ae kg" href="https://github.com/" rel="noopener ugc nofollow" target="_blank"> Github </a>上的现有存储库</li><li id="8894" class="jo jp hi jq b jr kh jt ki jv kj jx kk jz kl kb kc kd ke kf bi translated">在<a class="ae kg" href="https://www.digitalocean.com/" rel="noopener ugc nofollow" target="_blank">数字海洋</a>上配置液滴</li></ul><h2 id="be7d" class="km ir hi bd is kn ko kp iw kq kr ks ja jv kt ku je jx kv kw ji jz kx ky jm kz bi translated">什么是Github动作？</h2><ul class=""><li id="030f" class="jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf bi translated"><strong class="jq hj"> GitHub Actions </strong>是GitHub上的一个因果API:编排任何工作流，基于任何事件，而GitHub管理执行，提供丰富的反馈，并保护过程中的每一步。</li></ul><h2 id="9946" class="km ir hi bd is kn ko kp iw kq kr ks ja jv kt ku je jx kv kw ji jz kx ky jm kz bi translated">Docker是什么？</h2><ul class=""><li id="abe1" class="jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf bi translated">Docker是一个开发、发布和运行应用程序的开放平台。Docker使您能够将应用程序从基础设施中分离出来，这样您就可以快速交付软件。使用Docker，您可以像管理应用程序一样管理基础设施。</li></ul><h2 id="2aed" class="km ir hi bd is kn ko kp iw kq kr ks ja jv kt ku je jx kv kw ji jz kx ky jm kz bi translated">什么是数字海洋水滴？</h2><ul class=""><li id="8010" class="jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf bi translated">数字海洋水滴是基于Linux的虚拟机，运行在虚拟化硬件之上。您创建的每个Droplet都是一个新的服务器，可以单独使用，也可以作为更大的基于云的基础架构的一部分。</li></ul><p id="e3d9" class="pw-post-body-paragraph la lb hi jq b jr lc ld le jt lf lg lh jv li lj lk jx ll lm ln jz lo lp lq kb hb bi translated">在本教程中，我们将使用Github包作为docker映像的容器注册表。</p><blockquote class="lr ls lt"><p id="96ca" class="la lb lu jq b jr lc ld le jt lf lg lh lv li lj lk lw ll lm ln lx lo lp lq kb hb bi translated"><em class="hi">注意:GitHub容器注册中心目前处于公开测试阶段，可能会有变化。在测试期间，存储和带宽是免费的。要使用GitHub容器注册表，您必须启用功能预览。有关更多信息，请参见“关于GitHub容器注册表”和“启用改进的容器支持”</em></p></blockquote></div><div class="ab cl ly lz gp ma" role="separator"><span class="mb bw bk mc md me"/><span class="mb bw bk mc md me"/><span class="mb bw bk mc md"/></div><div class="hb hc hd he hf"><h1 id="3d29" class="iq ir hi bd is it mf iv iw ix mg iz ja jb mh jd je jf mi jh ji jj mj jl jm jn bi translated">准备我们的Node.js应用程序</h1><h2 id="087f" class="km ir hi bd is kn ko kp iw kq kr ks ja jv kt ku je jx kv kw ji jz kx ky jm kz bi translated">安装依赖项</h2><p id="da48" class="pw-post-body-paragraph la lb hi jq b jr js ld le jt ju lg lh jv mk lj lk jx ml lm ln jz mm lp lq kb hb bi translated">首先，我们需要创建一个<code class="du mn mo mp mq b">package.json</code>文件。</p><p id="cfd8" class="pw-post-body-paragraph la lb hi jq b jr lc ld le jt lf lg lh jv li lj lk jx ll lm ln jz lo lp lq kb hb bi translated"><code class="du mn mo mp mq b">package.json</code>文件定义了应用程序应该安装的依赖项。要为应用程序创建package.json文件，请在应用程序的根目录中运行npm init命令。它将引导您创建package.json文件。您可以通过将提示留空来跳过任何提示。</p><figure class="mr ms mt mu fd ij"><div class="bz dy l di"><div class="mv mw l"/></div></figure><figure class="mr ms mt mu fd ij"><div class="bz dy l di"><div class="mv mw l"/></div></figure><p id="b75b" class="pw-post-body-paragraph la lb hi jq b jr lc ld le jt lf lg lh jv li lj lk jx ll lm ln jz lo lp lq kb hb bi translated">生成的package.json文件如下所示:</p><figure class="mr ms mt mu fd ij"><div class="bz dy l di"><div class="mv mw l"/></div></figure><p id="3822" class="pw-post-body-paragraph la lb hi jq b jr lc ld le jt lf lg lh jv li lj lk jx ll lm ln jz lo lp lq kb hb bi translated">要安装依赖项，请使用<code class="du mn mo mp mq b">npm install &lt;pkg&gt;</code>。它安装这个包，并把它作为一个依赖项添加到<code class="du mn mo mp mq b">package.json</code>文件中。例如，要安装<code class="du mn mo mp mq b">express</code>，你可以输入<code class="du mn mo mp mq b">npm install express</code>。</p><figure class="mr ms mt mu fd ij"><div class="bz dy l di"><div class="mv mw l"/></div></figure><p id="d48a" class="pw-post-body-paragraph la lb hi jq b jr lc ld le jt lf lg lh jv li lj lk jx ll lm ln jz lo lp lq kb hb bi translated">现在您的<code class="du mn mo mp mq b">package.json</code>文件应该是这样的:</p><figure class="mr ms mt mu fd ij"><div class="bz dy l di"><div class="mv mw l"/></div></figure><h2 id="0aa0" class="km ir hi bd is kn ko kp iw kq kr ks ja jv kt ku je jx kv kw ji jz kx ky jm kz bi translated">创建<code class="du mn mo mp mq b">server.js</code>文件</h2><p id="7936" class="pw-post-body-paragraph la lb hi jq b jr js ld le jt ju lg lh jv mk lj lk jx ml lm ln jz mm lp lq kb hb bi translated">正如您可能看到的，我们声明我们的入口点是一个<code class="du mn mo mp mq b">server.js</code>文件。让我们创建一个。</p><p id="e2d2" class="pw-post-body-paragraph la lb hi jq b jr lc ld le jt lf lg lh jv li lj lk jx ll lm ln jz lo lp lq kb hb bi translated">这个文件将包含一个带有简单的<code class="du mn mo mp mq b">GET</code>端点的<code class="du mn mo mp mq b">express</code>应用程序，这将允许我们测试部署。</p><p id="df03" class="pw-post-body-paragraph la lb hi jq b jr lc ld le jt lf lg lh jv li lj lk jx ll lm ln jz lo lp lq kb hb bi translated">首先，让我们导入<code class="du mn mo mp mq b">express</code>并声明我们的端点:</p><figure class="mr ms mt mu fd ij"><div class="bz dy l di"><div class="mv mw l"/></div></figure><figure class="mr ms mt mu fd ij"><div class="bz dy l di"><div class="mv mw l"/></div></figure><figure class="mr ms mt mu fd ij"><div class="bz dy l di"><div class="mv mw l"/></div></figure><p id="8030" class="pw-post-body-paragraph la lb hi jq b jr lc ld le jt lf lg lh jv li lj lk jx ll lm ln jz lo lp lq kb hb bi translated">现在让我们通过访问<a class="ae kg" href="http://localhost:8080" rel="noopener ugc nofollow" target="_blank"> http://localhost:8080 </a>来检查我们的应用程序是否正在监听请求。为此，我将使用<a class="ae kg" href="https://www.postman.com/" rel="noopener ugc nofollow" target="_blank">邮递员</a>。</p><figure class="mr ms mt mu fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mx"><img src="../Images/ece392072d4909ac248435cb3291dea0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yqOJCcmQKQPle9HjbqHKqg.png"/></div></div></figure><p id="b5a4" class="pw-post-body-paragraph la lb hi jq b jr lc ld le jt lf lg lh jv li lj lk jx ll lm ln jz lo lp lq kb hb bi translated">而且很管用！</p><p id="0fc7" class="pw-post-body-paragraph la lb hi jq b jr lc ld le jt lf lg lh jv li lj lk jx ll lm ln jz lo lp lq kb hb bi translated">现在我们可以开始整理我们的申请了。</p></div><div class="ab cl ly lz gp ma" role="separator"><span class="mb bw bk mc md me"/><span class="mb bw bk mc md me"/><span class="mb bw bk mc md"/></div><div class="hb hc hd he hf"><h1 id="90ac" class="iq ir hi bd is it mf iv iw ix mg iz ja jb mh jd je jf mi jh ji jj mj jl jm jn bi translated">Dockerize Node.js应用程序</h1><p id="d723" class="pw-post-body-paragraph la lb hi jq b jr js ld le jt ju lg lh jv mk lj lk jx ml lm ln jz mm lp lq kb hb bi translated">为了实现我们的目标，首先，我们需要创造出<code class="du mn mo mp mq b">Dockerfile</code>。根据该文档，Dockerfile是一个文本文档，它包含用户可以在命令行上调用的所有命令来组合一个图像。</p><h2 id="bd41" class="km ir hi bd is kn ko kp iw kq kr ks ja jv kt ku je jx kv kw ji jz kx ky jm kz bi translated">简单Dockerfile文件</h2><figure class="mr ms mt mu fd ij"><div class="bz dy l di"><div class="mv mw l"/></div></figure><p id="be5a" class="pw-post-body-paragraph la lb hi jq b jr lc ld le jt lf lg lh jv li lj lk jx ll lm ln jz lo lp lq kb hb bi translated">你已经可以构建并运行你的容器，它会工作，但也许我们可以做得更好？当然啦！</p><p id="eacb" class="pw-post-body-paragraph la lb hi jq b jr lc ld le jt lf lg lh jv li lj lk jx ll lm ln jz lo lp lq kb hb bi translated">让我们指定基础映像的版本:</p><figure class="mr ms mt mu fd ij"><div class="bz dy l di"><div class="mv mw l"/></div></figure><p id="05a9" class="pw-post-body-paragraph la lb hi jq b jr lc ld le jt lf lg lh jv li lj lk jx ll lm ln jz lo lp lq kb hb bi translated">然后我们来看看依赖安装。我们正在准备应用程序的生产版本，所以我们不需要安装开发依赖项。我们可以通过将<code class="du mn mo mp mq b">RUN npm install</code>改为:</p><figure class="mr ms mt mu fd ij"><div class="bz dy l di"><div class="mv mw l"/></div></figure><p id="1de4" class="pw-post-body-paragraph la lb hi jq b jr lc ld le jt lf lg lh jv li lj lk jx ll lm ln jz lo lp lq kb hb bi translated">另一个步骤是确保所有的框架和库都使用最佳的生产配置。我们可以将这一行添加到我们的<code class="du mn mo mp mq b">Dockerfile</code>中:</p><figure class="mr ms mt mu fd ij"><div class="bz dy l di"><div class="mv mw l"/></div></figure><h2 id="2736" class="km ir hi bd is kn ko kp iw kq kr ks ja jv kt ku je jx kv kw ji jz kx ky jm kz bi translated"><a class="ae kg" rel="noopener" href="/@mccode/processes-in-containers-should-not-run-as-root-2feae3f0df3b#:~:text=Containers%20are%20not%20trust%20boundaries,a%20container%20on%20your%20server.">不要以根用户身份运行容器</a></h2><p id="9127" class="pw-post-body-paragraph la lb hi jq b jr js ld le jt ju lg lh jv mk lj lk jx ml lm ln jz mm lp lq kb hb bi translated">保持您的流程没有安全风险真的很重要！</p><p id="d5f0" class="pw-post-body-paragraph la lb hi jq b jr lc ld le jt lf lg lh jv li lj lk jx ll lm ln jz lo lp lq kb hb bi translated"><strong class="jq hj">朋友不让朋友以root身份运行容器！</strong></p><p id="6088" class="pw-post-body-paragraph la lb hi jq b jr lc ld le jt lf lg lh jv li lj lk jx ll lm ln jz lo lp lq kb hb bi translated">所以，让我们在我们的<code class="du mn mo mp mq b">Dockerfile</code>中多修改几行:</p><figure class="mr ms mt mu fd ij"><div class="bz dy l di"><div class="mv mw l"/></div></figure><p id="0b1b" class="pw-post-body-paragraph la lb hi jq b jr lc ld le jt lf lg lh jv li lj lk jx ll lm ln jz lo lp lq kb hb bi translated">我们的应用程序正在监听端口8080，因此我们需要从容器中公开这个端口:</p><figure class="mr ms mt mu fd ij"><div class="bz dy l di"><div class="mv mw l"/></div></figure><p id="0887" class="pw-post-body-paragraph la lb hi jq b jr lc ld le jt lf lg lh jv li lj lk jx ll lm ln jz lo lp lq kb hb bi translated">此时我们的<code class="du mn mo mp mq b">Dockerfile</code>看起来是这样的:</p><figure class="mr ms mt mu fd ij"><div class="bz dy l di"><div class="mv mw l"/></div></figure><p id="3cf1" class="pw-post-body-paragraph la lb hi jq b jr lc ld le jt lf lg lh jv li lj lk jx ll lm ln jz lo lp lq kb hb bi translated">让我们建立并运行我们的形象:</p><figure class="mr ms mt mu fd ij"><div class="bz dy l di"><div class="mv mw l"/></div></figure><p id="eec2" class="pw-post-body-paragraph la lb hi jq b jr lc ld le jt lf lg lh jv li lj lk jx ll lm ln jz lo lp lq kb hb bi translated">您可以通过键入以下命令来检查它是否正在运行:</p><figure class="mr ms mt mu fd ij"><div class="bz dy l di"><div class="mv mw l"/></div></figure><p id="d379" class="pw-post-body-paragraph la lb hi jq b jr lc ld le jt lf lg lh jv li lj lk jx ll lm ln jz lo lp lq kb hb bi translated">您可以使用以下命令查看容器的日志:</p><figure class="mr ms mt mu fd ij"><div class="bz dy l di"><div class="mv mw l"/></div></figure></div><div class="ab cl ly lz gp ma" role="separator"><span class="mb bw bk mc md me"/><span class="mb bw bk mc md me"/><span class="mb bw bk mc md"/></div><div class="hb hc hd he hf"><h1 id="6d93" class="iq ir hi bd is it mf iv iw ix mg iz ja jb mh jd je jf mi jh ji jj mj jl jm jn bi translated">正常关机</h1><p id="ca49" class="pw-post-body-paragraph la lb hi jq b jr js ld le jt ju lg lh jv mk lj lk jx ml lm ln jz mm lp lq kb hb bi translated">Node.js集成了web服务器功能。另外，有了Express，这些可以扩展得更多。</p><p id="36a8" class="pw-post-body-paragraph la lb hi jq b jr lc ld le jt lf lg lh jv li lj lk jx ll lm ln jz lo lp lq kb hb bi translated">不幸的是，Node.js不能很好地处理开箱即用的自我关闭。这导致了集装箱系统的许多问题。</p><p id="d171" class="pw-post-body-paragraph la lb hi jq b jr lc ld le jt lf lg lh jv li lj lk jx ll lm ln jz lo lp lq kb hb bi translated">当Node.js应用程序收到一个中断信号(也称为<code class="du mn mo mp mq b">SIGINT</code>或<code class="du mn mo mp mq b">CTRL+C</code>)时，它将导致突然的进程终止，当然，除非设置了任何事件处理程序来以不同的行为处理它。这意味着连接到web应用程序的客户端将立即断开连接。</p><p id="04cc" class="pw-post-body-paragraph la lb hi jq b jr lc ld le jt lf lg lh jv li lj lk jx ll lm ln jz lo lp lq kb hb bi translated">让我们通过创建另一个具有延迟响应的端点来模拟这个问题:</p><figure class="mr ms mt mu fd ij"><div class="bz dy l di"><div class="mv mw l"/></div></figure><p id="e0ff" class="pw-post-body-paragraph la lb hi jq b jr lc ld le jt lf lg lh jv li lj lk jx ll lm ln jz lo lp lq kb hb bi translated">运行这个应用程序，一旦它开始运行，就向这个端点发送一个简单的HTTP请求。</p><p id="cc5f" class="pw-post-body-paragraph la lb hi jq b jr lc ld le jt lf lg lh jv li lj lk jx ll lm ln jz lo lp lq kb hb bi translated">在正在运行的Node.js控制台窗口中点击<code class="du mn mo mp mq b">CTRL+C</code>,您会看到curl请求突然退出。这模拟了当容器拆除时，用户将会得到的相同体验。</p><h2 id="702c" class="km ir hi bd is kn ko kp iw kq kr ks ja jv kt ku je jx kv kw ji jz kx ky jm kz bi translated">第一部分</h2><p id="652d" class="pw-post-body-paragraph la lb hi jq b jr js ld le jt ju lg lh jv mk lj lk jx ml lm ln jz mm lp lq kb hb bi translated">要解决这个问题，我们需要允许请求完成。让我们向Node.js服务器解释一下:</p><figure class="mr ms mt mu fd ij"><div class="bz dy l di"><div class="mv mw l"/></div></figure><p id="8e7c" class="pw-post-body-paragraph la lb hi jq b jr lc ld le jt lf lg lh jv li lj lk jx ll lm ln jz lo lp lq kb hb bi translated">这将调用<code class="du mn mo mp mq b">server.close()</code>，它将指示Node.js HTTP服务器:</p><ul class=""><li id="d5d9" class="jo jp hi jq b jr lc jt lf jv my jx mz jz na kb kc kd ke kf bi translated">不再接受任何请求。</li><li id="4ecb" class="jo jp hi jq b jr kh jt ki jv kj jx kk jz kl kb kc kd ke kf bi translated">完成所有正在运行的请求。</li></ul><p id="b2de" class="pw-post-body-paragraph la lb hi jq b jr lc ld le jt lf lg lh jv li lj lk jx ll lm ln jz lo lp lq kb hb bi translated">它将在<code class="du mn mo mp mq b">SIGINT</code>(当您按下<code class="du mn mo mp mq b">CTRL+C</code>)或<code class="du mn mo mp mq b">SIGTERM</code>(一个进程终止的标准信号)上执行此操作。</p><p id="ee4b" class="pw-post-body-paragraph la lb hi jq b jr lc ld le jt lf lg lh jv li lj lk jx ll lm ln jz lo lp lq kb hb bi translated">你可能会有一个问题“如果一个请求花费太多时间怎么办？”。因此，如果容器没有停止，Docker和Kubernetes将在几秒钟(通常是30秒)后运行一个<code class="du mn mo mp mq b">SIGKILL</code>，这是进程本身无法处理的，所以这不是我们所关心的。</p><h2 id="c383" class="km ir hi bd is kn ko kp iw kq kr ks ja jv kt ku je jx kv kw ji jz kx ky jm kz bi translated">第二部分</h2><p id="e075" class="pw-post-body-paragraph la lb hi jq b jr js ld le jt ju lg lh jv mk lj lk jx ml lm ln jz mm lp lq kb hb bi translated">现在在我们的<code class="du mn mo mp mq b">Dockerfile</code>中，我们用命令<code class="du mn mo mp mq b">npm start</code>启动我们的应用程序。不幸的是，这有一个大问题:</p><p id="055f" class="pw-post-body-paragraph la lb hi jq b jr lc ld le jt lf lg lh jv li lj lk jx ll lm ln jz lo lp lq kb hb bi translated">如果<code class="du mn mo mp mq b">yarn</code>或<code class="du mn mo mp mq b">npm</code>收到一个<code class="du mn mo mp mq b">SIGINT</code>或<code class="du mn mo mp mq b">SIGTERM</code>信号，它们会正确地将信号转发给衍生的子进程(在本例中为<code class="du mn mo mp mq b">node server.js</code>)。但是，它不会等待子进程停止。相反，<code class="du mn mo mp mq b">yarn</code> / <code class="du mn mo mp mq b">npm</code>立即停止自己。</p><p id="0e9b" class="pw-post-body-paragraph la lb hi jq b jr lc ld le jt lf lg lh jv li lj lk jx ll lm ln jz lo lp lq kb hb bi translated">解决方案不是使用npm运行应用程序，而是直接使用<code class="du mn mo mp mq b">node</code>:</p><figure class="mr ms mt mu fd ij"><div class="bz dy l di"><div class="mv mw l"/></div></figure><p id="85ee" class="pw-post-body-paragraph la lb hi jq b jr lc ld le jt lf lg lh jv li lj lk jx ll lm ln jz lo lp lq kb hb bi translated">但是仍然有一个问题。Docker作为<code class="du mn mo mp mq b">PID 1</code>运行我们的流程。根据<a class="ae kg" href="https://github.com/nodejs/docker-node/blob/main/docs/BestPractices.md#handling-kernel-signals" rel="noopener ugc nofollow" target="_blank"> Node.js Docker工作组建议</a>:</p><blockquote class="lr ls lt"><p id="ad6e" class="la lb lu jq b jr lc ld le jt lf lg lh lv li lj lk lw ll lm ln lx lo lp lq kb hb bi translated"><em class="hi"> Node.js没有被设计成以PID 1运行，这导致在Docker内部运行时出现意外行为。比如一个运行为PID 1的Node.js进程，不会响应</em> <code class="du mn mo mp mq b"><em class="hi">SIGINT</em></code> <em class="hi"> ( </em> <code class="du mn mo mp mq b"><em class="hi">CTRL-C</em></code> <em class="hi">)以及类似的信号。</em></p></blockquote><p id="703c" class="pw-post-body-paragraph la lb hi jq b jr lc ld le jt lf lg lh jv li lj lk jx ll lm ln jz lo lp lq kb hb bi translated">我们可以使用一种叫做<code class="du mn mo mp mq b">dumb-init</code>的工具来修复它。它将作为<code class="du mn mo mp mq b">PID 1</code>被调用，然后将生成我们的node.js流程作为另一个流程。让我们来补充一下我们的<code class="du mn mo mp mq b">Dockerfile</code>:</p><figure class="mr ms mt mu fd ij"><div class="bz dy l di"><div class="mv mw l"/></div></figure><p id="ca08" class="pw-post-body-paragraph la lb hi jq b jr lc ld le jt lf lg lh jv li lj lk jx ll lm ln jz lo lp lq kb hb bi translated">所以我们的<code class="du mn mo mp mq b">Dockerfile</code>的最终版本看起来是这样的:</p><figure class="mr ms mt mu fd ij"><div class="bz dy l di"><div class="mv mw l"/></div></figure><p id="22aa" class="pw-post-body-paragraph la lb hi jq b jr lc ld le jt lf lg lh jv li lj lk jx ll lm ln jz lo lp lq kb hb bi translated">现在我们可以继续我们的Github行动了！</p></div><div class="ab cl ly lz gp ma" role="separator"><span class="mb bw bk mc md me"/><span class="mb bw bk mc md me"/><span class="mb bw bk mc md"/></div><div class="hb hc hd he hf"><h1 id="7200" class="iq ir hi bd is it mf iv iw ix mg iz ja jb mh jd je jf mi jh ji jj mj jl jm jn bi translated">配置Github操作</h1><h2 id="db9a" class="km ir hi bd is kn ko kp iw kq kr ks ja jv kt ku je jx kv kw ji jz kx ky jm kz bi translated">介绍</h2><p id="e1de" class="pw-post-body-paragraph la lb hi jq b jr js ld le jt ju lg lh jv mk lj lk jx ml lm ln jz mm lp lq kb hb bi translated">转到您的存储库，选择<code class="du mn mo mp mq b">Actions</code>选项卡。你会看到GitHub向你提出了不同的工作流程，但这不是我们的方法。点击<code class="du mn mo mp mq b">set up a workflow yourself</code>。</p><figure class="mr ms mt mu fd ij er es paragraph-image"><div class="er es nb"><img src="../Images/c1ff95936b6a2f28588ed1368e41aee4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/format:webp/1*iJQweU8oBOCq0lPufbLjrw.png"/></div></figure><p id="6dd8" class="pw-post-body-paragraph la lb hi jq b jr lc ld le jt lf lg lh jv li lj lk jx ll lm ln jz lo lp lq kb hb bi translated">我们将被重定向到具有初始配置的页面，当我们完成配置时，它将被提交给<code class="du mn mo mp mq b">main</code> ( <code class="du mn mo mp mq b">master</code>)。</p><p id="1db7" class="pw-post-body-paragraph la lb hi jq b jr lc ld le jt lf lg lh jv li lj lk jx ll lm ln jz lo lp lq kb hb bi translated">让我们来谈谈初始配置，它应该是这样的:</p><figure class="mr ms mt mu fd ij"><div class="bz dy l di"><div class="mv mw l"/></div></figure><ul class=""><li id="df30" class="jo jp hi jq b jr lc jt lf jv my jx mz jz na kb kc kd ke kf bi translated"><code class="du mn mo mp mq b">name</code> -是我们工作流程的名称</li><li id="7ea7" class="jo jp hi jq b jr kh jt ki jv kj jx kk jz kl kb kc kd ke kf bi translated"><code class="du mn mo mp mq b">on</code> -是我们描述触发工作流的块。默认情况下，当对<code class="du mn mo mp mq b">master</code>分支执行<code class="du mn mo mp mq b">push</code>时(本例中为访问<code class="du mn mo mp mq b">master</code>分支)或对<code class="du mn mo mp mq b">master</code>分支执行<code class="du mn mo mp mq b">Pull Request</code>时(本例中为访问源分支，例如。<code class="du mn mo mp mq b">feature/TASK-1</code>)。而且我们可以手动触发，这是<code class="du mn mo mp mq b">workflow_dispatch</code>属性允许的。</li><li id="83f3" class="jo jp hi jq b jr kh jt ki jv kj jx kk jz kl kb kc kd ke kf bi translated"><code class="du mn mo mp mq b">jobs</code> -是配置我们作业的模块。它们可以一个接一个运行，也可以同时运行(例如在mono repo中同时部署后端和前端)。</li><li id="329d" class="jo jp hi jq b jr kh jt ki jv kj jx kk jz kl kb kc kd ke kf bi translated"><code class="du mn mo mp mq b">runs-on</code> -运行作业的机器类型。该机器可以是GitHub托管的运行程序，也可以是自托管的运行程序。</li><li id="53be" class="jo jp hi jq b jr kh jt ki jv kj jx kk jz kl kb kc kd ke kf bi translated"><code class="du mn mo mp mq b">steps</code>——我们逻辑生活的地方。每个步骤都在runner环境中运行，并且可以访问工作区和文件系统。</li><li id="0908" class="jo jp hi jq b jr kh jt ki jv kj jx kk jz kl kb kc kd ke kf bi translated"><code class="du mn mo mp mq b">uses</code> -选择作为工作步骤的一部分运行的操作。动作是可重用的代码单元。在这种情况下，被GitHub调用的预定义动作<code class="du mn mo mp mq b">actions/checkout@v2</code>允许我们<code class="du mn mo mp mq b">checkout</code>源分支(<code class="du mn mo mp mq b">master</code>或另一个触发工作流的分支)</li><li id="29ef" class="jo jp hi jq b jr kh jt ki jv kj jx kk jz kl kb kc kd ke kf bi translated"><code class="du mn mo mp mq b">name</code>——是这一步的名字。它将显示在工作流执行的进度中。</li><li id="c1af" class="jo jp hi jq b jr kh jt ki jv kj jx kk jz kl kb kc kd ke kf bi translated"><code class="du mn mo mp mq b">run</code> -使用操作系统的外壳运行命令行程序。如果不提供<code class="du mn mo mp mq b">name</code>，步骤名称将默认为<code class="du mn mo mp mq b">run</code>命令中指定的文本。它可以执行单行命令，也可以执行多行命令。</li></ul><p id="479e" class="pw-post-body-paragraph la lb hi jq b jr lc ld le jt lf lg lh jv li lj lk jx ll lm ln jz lo lp lq kb hb bi translated">您可以通过访问<a class="ae kg" href="https://docs.github.com/en/actions/reference/workflow-syntax-for-github-actions" rel="noopener ugc nofollow" target="_blank">工作流语法文档</a>找到更详细的文档</p><h2 id="da95" class="km ir hi bd is kn ko kp iw kq kr ks ja jv kt ku je jx kv kw ji jz kx ky jm kz bi translated">构建和推动</h2><p id="7b1d" class="pw-post-body-paragraph la lb hi jq b jr js ld le jt ju lg lh jv mk lj lk jx ml lm ln jz mm lp lq kb hb bi translated">现在我们有足够的知识来开始我们的配置工作。让我们定义工作流的名称以及何时触发它。在我们的例子中，工作流应该只在<code class="du mn mo mp mq b">master</code>分支中的变更上执行，或者手动执行，所以我们的声明应该是这样的:</p><figure class="mr ms mt mu fd ij"><div class="bz dy l di"><div class="mv mw l"/></div></figure><p id="b822" class="pw-post-body-paragraph la lb hi jq b jr lc ld le jt lf lg lh jv li lj lk jx ll lm ln jz lo lp lq kb hb bi translated">现在我们需要声明一些<code class="du mn mo mp mq b">env</code>变量，以便能够在我们的配置中重用它们，避免重复同样的事情:</p><figure class="mr ms mt mu fd ij"><div class="bz dy l di"><div class="mv mw l"/></div></figure><p id="60be" class="pw-post-body-paragraph la lb hi jq b jr lc ld le jt lf lg lh jv li lj lk jx ll lm ln jz lo lp lq kb hb bi translated">是时候定义我们的工作了。在我们的例子中，将有两个作业，一个将构建图像并将其推送到注册表，另一个将在我们的droplet上拉出并运行容器。</p><p id="9bcb" class="pw-post-body-paragraph la lb hi jq b jr lc ld le jt lf lg lh jv li lj lk jx ll lm ln jz lo lp lq kb hb bi translated">为了构建容器并将其推送到注册表，我们将使用<code class="du mn mo mp mq b">docker/build-push-action@v1</code>动作，您可以在这里找到详细的文档<a class="ae kg" href="https://github.com/docker/build-push-action" rel="noopener ugc nofollow" target="_blank">。</a></p><figure class="mr ms mt mu fd ij"><div class="bz dy l di"><div class="mv mw l"/></div></figure><p id="4e46" class="pw-post-body-paragraph la lb hi jq b jr lc ld le jt lf lg lh jv li lj lk jx ll lm ln jz lo lp lq kb hb bi translated">此时，我们的工作流配置应该如下所示:</p><figure class="mr ms mt mu fd ij"><div class="bz dy l di"><div class="mv mw l"/></div></figure><p id="2440" class="pw-post-body-paragraph la lb hi jq b jr lc ld le jt lf lg lh jv li lj lk jx ll lm ln jz lo lp lq kb hb bi translated">如你所见，我们使用了<code class="du mn mo mp mq b">github.actor</code>和<code class="du mn mo mp mq b">secrets.GITHUB_TOKEN</code>，你可能会问，我们在哪里声明了这些变量。回答:我们没有。</p><p id="0150" class="pw-post-body-paragraph la lb hi jq b jr lc ld le jt lf lg lh jv li lj lk jx ll lm ln jz lo lp lq kb hb bi translated">这些变量是由GitHub预定义的。</p><ul class=""><li id="fc10" class="jo jp hi jq b jr lc jt lf jv my jx mz jz na kb kc kd ke kf bi translated"><code class="du mn mo mp mq b">github.actor</code> -是启动工作流运行并参与<code class="du mn mo mp mq b">github</code>上下文的用户的登录。你可以在这里阅读更多信息<a class="ae kg" href="https://docs.github.com/en/actions/reference/context-and-expression-syntax-for-github-actions" rel="noopener ugc nofollow" target="_blank"/></li><li id="89f4" class="jo jp hi jq b jr kh jt ki jv kj jx kk jz kl kb kc kd ke kf bi translated"><code class="du mn mo mp mq b">secrets.GITHUB_TOKEN</code> -是GitHub提供的令牌。它是在每次工作流运行时创建的。您可以使用GITHUB_TOKEN在工作流运行中进行身份验证。点击了解更多<a class="ae kg" href="https://docs.github.com/en/actions/reference/authentication-in-a-workflow" rel="noopener ugc nofollow" target="_blank">。</a></li></ul><p id="43ba" class="pw-post-body-paragraph la lb hi jq b jr lc ld le jt lf lg lh jv li lj lk jx ll lm ln jz lo lp lq kb hb bi translated">如果您只想构建和推送您的容器，这个操作已经可以使用了。如果你只是在一个docker-image上工作，它是合适的，它应该只存储在注册表中，当你需要它的时候，你需要能够取出它。</p><p id="ee75" class="pw-post-body-paragraph la lb hi jq b jr lc ld le jt lf lg lh jv li lj lk jx ll lm ln jz lo lp lq kb hb bi translated">但是在我们的例子中，我们还需要部署它，所以让我们配置第二个作业。</p><h2 id="1e27" class="km ir hi bd is kn ko kp iw kq kr ks ja jv kt ku je jx kv kw ji jz kx ky jm kz bi translated">部署:拉动并运行</h2><p id="c5ce" class="pw-post-body-paragraph la lb hi jq b jr js ld le jt ju lg lh jv mk lj lk jx ml lm ln jz mm lp lq kb hb bi translated">我们的第二个任务负责通过ssh连接到我们的droplet，拉容器并运行docker容器。它也将运行在<code class="du mn mo mp mq b">ubuntu-latest</code>亚军，它应该只在我们之前的工作称为<code class="du mn mo mp mq b">push_to_registry</code>后开始。因此，我们的工作宣言将是这样的:</p><figure class="mr ms mt mu fd ij"><div class="bz dy l di"><div class="mv mw l"/></div></figure><p id="6f7f" class="pw-post-body-paragraph la lb hi jq b jr lc ld le jt lf lg lh jv li lj lk jx ll lm ln jz lo lp lq kb hb bi translated">在步骤配置之前，我们需要添加一些变量，即<code class="du mn mo mp mq b">SSH_KEY</code>、<code class="du mn mo mp mq b">SSH_USER</code>和<code class="du mn mo mp mq b">SSH_HOST</code>。这些变量将用于验证我们到droplet的ssh连接。但是像我们应用程序的其他秘密一样，将它们存储在存储库文件中是一个非常糟糕的主意，所以我们需要另一种更安全的方式来声明它们。GitHub提供了一个——名为<code class="du mn mo mp mq b">Secrets</code>,你可以在GitHub的库的<code class="du mn mo mp mq b">Settings</code>标签中找到它们。</p><p id="6dd4" class="pw-post-body-paragraph la lb hi jq b jr lc ld le jt lf lg lh jv li lj lk jx ll lm ln jz lo lp lq kb hb bi translated">机密有两种类型:存储库和环境机密。你可以在<a class="ae kg" href="https://docs.github.com/en/actions/reference/encrypted-secrets" rel="noopener ugc nofollow" target="_blank">文档</a>中了解更多。在我们的例子中，我们将使用存储库机密，因此转到配置页面并单击<code class="du mn mo mp mq b">New repository secret</code>。</p><p id="1f05" class="pw-post-body-paragraph la lb hi jq b jr lc ld le jt lf lg lh jv li lj lk jx ll lm ln jz lo lp lq kb hb bi translated">如前所述，我们需要三个变量:</p><ul class=""><li id="fa88" class="jo jp hi jq b jr lc jt lf jv my jx mz jz na kb kc kd ke kf bi translated"><code class="du mn mo mp mq b">SSH_KEY</code> -这是您用来访问droplet的私人密钥。</li><li id="c9f9" class="jo jp hi jq b jr kh jt ki jv kj jx kk jz kl kb kc kd ke kf bi translated"><code class="du mn mo mp mq b">SSH_USER</code> -用于通过<code class="du mn mo mp mq b">ssh</code>访问droplet的用户名</li><li id="d357" class="jo jp hi jq b jr kh jt ki jv kj jx kk jz kl kb kc kd ke kf bi translated"><code class="du mn mo mp mq b">SSH_HOST</code> -你滴宿主</li></ul><p id="706d" class="pw-post-body-paragraph la lb hi jq b jr lc ld le jt lf lg lh jv li lj lk jx ll lm ln jz lo lp lq kb hb bi translated">一旦它们被设置，您将会看到下面的结果。这些秘密甚至不能被仓库所有者再次看到，它们只能被<strong class="jq hj">更新</strong>或<strong class="jq hj">删除</strong>。</p><p id="ee5e" class="pw-post-body-paragraph la lb hi jq b jr lc ld le jt lf lg lh jv li lj lk jx ll lm ln jz lo lp lq kb hb bi translated">现在我们可以继续我们的<code class="du mn mo mp mq b">steps</code>配置。为了执行<code class="du mn mo mp mq b">SSH</code>连接，我们将使用<code class="du mn mo mp mq b">webfactory/ssh-agent</code>动作。更多细节和描述你可以在这里找到<a class="ae kg" href="https://github.com/marketplace/actions/webfactory-ssh-agent" rel="noopener ugc nofollow" target="_blank"/>。</p><p id="172d" class="pw-post-body-paragraph la lb hi jq b jr lc ld le jt lf lg lh jv li lj lk jx ll lm ln jz lo lp lq kb hb bi translated">让我们配置<code class="du mn mo mp mq b">SSH</code>连接:</p><figure class="mr ms mt mu fd ij"><div class="bz dy l di"><div class="mv mw l"/></div></figure><p id="b910" class="pw-post-body-paragraph la lb hi jq b jr lc ld le jt lf lg lh jv li lj lk jx ll lm ln jz lo lp lq kb hb bi translated">根据文档，这些操作不会为我们更新<code class="du mn mo mp mq b">.known-hosts</code>文件，所以让我们声明另一个使用<code class="du mn mo mp mq b">ssh-keyscan</code>更新该文件的步骤。</p><figure class="mr ms mt mu fd ij"><div class="bz dy l di"><div class="mv mw l"/></div></figure><p id="b9e5" class="pw-post-body-paragraph la lb hi jq b jr lc ld le jt lf lg lh jv li lj lk jx ll lm ln jz lo lp lq kb hb bi translated">现在是时候添加一个命令，将我们的图像拖放到droplet中:</p><figure class="mr ms mt mu fd ij"><div class="bz dy l di"><div class="mv mw l"/></div></figure><p id="d182" class="pw-post-body-paragraph la lb hi jq b jr lc ld le jt lf lg lh jv li lj lk jx ll lm ln jz lo lp lq kb hb bi translated">在这个命令中，我们指定需要使用我们的<code class="du mn mo mp mq b">user</code>和<code class="du mn mo mp mq b">host</code>通过<code class="du mn mo mp mq b">ssh</code>连接，并运行这个命令来获取最新版本的docker映像。</p><p id="e036" class="pw-post-body-paragraph la lb hi jq b jr lc ld le jt lf lg lh jv li lj lk jx ll lm ln jz lo lp lq kb hb bi translated">现在我们需要运行我们的容器:</p><figure class="mr ms mt mu fd ij"><div class="bz dy l di"><div class="mv mw l"/></div></figure><p id="58cd" class="pw-post-body-paragraph la lb hi jq b jr lc ld le jt lf lg lh jv li lj lk jx ll lm ln jz lo lp lq kb hb bi translated">在这一步，我们也通过<code class="du mn mo mp mq b">ssh</code>连接，但是让我们更仔细地看看docker命令</p><ul class=""><li id="4695" class="jo jp hi jq b jr lc jt lf jv my jx mz jz na kb kc kd ke kf bi translated"><code class="du mn mo mp mq b">docker run</code> -运行容器本身</li><li id="f97c" class="jo jp hi jq b jr kh jt ki jv kj jx kk jz kl kb kc kd ke kf bi translated"><code class="du mn mo mp mq b">-p 8080:8080</code> -指定我们需要将从容器端口(<code class="du mn mo mp mq b">8080</code>)暴露的内容绑定到机器的本地端口(droplet)。</li><li id="a0d3" class="jo jp hi jq b jr kh jt ki jv kj jx kk jz kl kb kc kd ke kf bi translated"><code class="du mn mo mp mq b">-d</code> -标志用于在分离模式下运行容器</li><li id="c159" class="jo jp hi jq b jr kh jt ki jv kj jx kk jz kl kb kc kd ke kf bi translated"><code class="du mn mo mp mq b">--restart unless-stopped</code> -指定除非手动停止，否则应该重新启动容器。它也将在机器启动时启动。</li><li id="d2ca" class="jo jp hi jq b jr kh jt ki jv kj jx kk jz kl kb kc kd ke kf bi translated"><code class="du mn mo mp mq b">--name=${{env.CONTAINER}}</code> -指定启动容器的名称</li><li id="ae50" class="jo jp hi jq b jr kh jt ki jv kj jx kk jz kl kb kc kd ke kf bi translated"><code class="du mn mo mp mq b">${{env.REGISTRY}}/${{env.REPO}}:latest</code> -指定我们需要将哪个图像作为容器运行</li></ul><p id="ccc9" class="pw-post-body-paragraph la lb hi jq b jr lc ld le jt lf lg lh jv li lj lk jx ll lm ln jz lo lp lq kb hb bi translated">此时，我们的配置将如下所示:</p><figure class="mr ms mt mu fd ij"><div class="bz dy l di"><div class="mv mw l"/></div></figure><p id="6e21" class="pw-post-body-paragraph la lb hi jq b jr lc ld le jt lf lg lh jv li lj lk jx ll lm ln jz lo lp lq kb hb bi translated">现在看起来很好，不是吗？但是如果我们现在运行它，它有一些问题会使我们的工作流程失败。</p><p id="d374" class="pw-post-body-paragraph la lb hi jq b jr lc ld le jt lf lg lh jv li lj lk jx ll lm ln jz lo lp lq kb hb bi translated">为了从GitHub容器注册表中提取容器，我们需要对这个容器进行认证。我们也将使用<code class="du mn mo mp mq b">github.actor</code>和<code class="du mn mo mp mq b">secrets.GITHUB_TOKEN</code>变量。因此，让我们在拉集装箱之前再增加一个步骤:</p><figure class="mr ms mt mu fd ij"><div class="bz dy l di"><div class="mv mw l"/></div></figure><p id="5c46" class="pw-post-body-paragraph la lb hi jq b jr lc ld le jt lf lg lh jv li lj lk jx ll lm ln jz lo lp lq kb hb bi translated">但是出于安全原因，将docker的身份验证留给远程机器上的注册中心并不是一个好主意，因此我们需要在工作流的末尾添加从注册中心注销:</p><figure class="mr ms mt mu fd ij"><div class="bz dy l di"><div class="mv mw l"/></div></figure><p id="c052" class="pw-post-body-paragraph la lb hi jq b jr lc ld le jt lf lg lh jv li lj lk jx ll lm ln jz lo lp lq kb hb bi translated">通过这些步骤，我们解决了认证问题，但是还有一个问题。在第二次运行时，我们的工作流将会失败。</p><p id="4424" class="pw-post-body-paragraph la lb hi jq b jr lc ld le jt lf lg lh jv li lj lk jx ll lm ln jz lo lp lq kb hb bi translated"><strong class="jq hj">为什么？原因很简单，因为我们的容器的端口和名称已经在上次运行中使用过了。</strong></p><p id="cc2f" class="pw-post-body-paragraph la lb hi jq b jr lc ld le jt lf lg lh jv li lj lk jx ll lm ln jz lo lp lq kb hb bi translated"><strong class="jq hj">怎么修？修复非常简单，我们只需要停止并移除之前的容器。让我们在启动容器之前再添加两个步骤:</strong></p><figure class="mr ms mt mu fd ij"><div class="bz dy l di"><div class="mv mw l"/></div></figure><p id="f03b" class="pw-post-body-paragraph la lb hi jq b jr lc ld le jt lf lg lh jv li lj lk jx ll lm ln jz lo lp lq kb hb bi translated">你大概有个疑问:“<em class="lu">为什么我们这里需要</em> <code class="du mn mo mp mq b"><em class="lu">continue-on-error</em></code> <em class="lu">属性？</em>”。原因是，如果没有任何运行的或现有的容器与我们的容器同名，这些命令将抛出一个错误。这对我们的工作流来说不是问题，所以我们将跳过这些错误。</p><p id="01c5" class="pw-post-body-paragraph la lb hi jq b jr lc ld le jt lf lg lh jv li lj lk jx ll lm ln jz lo lp lq kb hb bi translated">我们的工作流配置的最终版本将如下所示:</p><figure class="mr ms mt mu fd ij"><div class="bz dy l di"><div class="mv mw l"/></div></figure><p id="284e" class="pw-post-body-paragraph la lb hi jq b jr lc ld le jt lf lg lh jv li lj lk jx ll lm ln jz lo lp lq kb hb bi translated">现在我们可以提交并推动您的工作流运行到<code class="du mn mo mp mq b">master</code>分支！</p><p id="853f" class="pw-post-body-paragraph la lb hi jq b jr lc ld le jt lf lg lh jv li lj lk jx ll lm ln jz lo lp lq kb hb bi translated">由于我们对<code class="du mn mo mp mq b">master</code>分支执行了<code class="du mn mo mp mq b">push</code>操作，工作流应该会自动触发。</p><p id="91e5" class="pw-post-body-paragraph la lb hi jq b jr lc ld le jt lf lg lh jv li lj lk jx ll lm ln jz lo lp lq kb hb bi translated">如果你做的一切都是正确的，你将不会在执行中得到任何错误:</p><figure class="mr ms mt mu fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es nc"><img src="../Images/8d8638253ea468bc003c34465262581b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hpqDnzeWuVRTNdH_TnNV7Q.png"/></div></div></figure><p id="f9eb" class="pw-post-body-paragraph la lb hi jq b jr lc ld le jt lf lg lh jv li lj lk jx ll lm ln jz lo lp lq kb hb bi translated">现在是时候检查我们在远程服务器上部署的应用程序的工作情况了。让我们对您的<code class="du mn mo mp mq b">host:8080</code>或域(如果它在您的机器上配置了)运行一个查询:</p><figure class="mr ms mt mu fd ij er es paragraph-image"><div class="er es nd"><img src="../Images/bfd1e443c4510cc57c366c4cc34f0557.png" data-original-src="https://miro.medium.com/v2/resize:fit:832/format:webp/1*b6mnY0QcehkxdmSA6SWFAw.png"/></div></figure><p id="e0d8" class="pw-post-body-paragraph la lb hi jq b jr lc ld le jt lf lg lh jv li lj lk jx ll lm ln jz lo lp lq kb hb bi translated">如你所见，一切都很好！</p></div><div class="ab cl ly lz gp ma" role="separator"><span class="mb bw bk mc md me"/><span class="mb bw bk mc md me"/><span class="mb bw bk mc md"/></div><div class="hb hc hd he hf"><h1 id="b4f1" class="iq ir hi bd is it mf iv iw ix mg iz ja jb mh jd je jf mi jh ji jj mj jl jm jn bi translated">结论</h1><p id="c072" class="pw-post-body-paragraph la lb hi jq b jr js ld le jt ju lg lh jv mk lj lk jx ml lm ln jz mm lp lq kb hb bi translated">在本教程中，我们创建了一个Node.js，并根据最佳实践对其进行了dockerized，然后使用GitHub操作、GitHub包和DigitalOcean droplet对其进行了部署。</p><blockquote class="lr ls lt"><p id="3c54" class="la lb lu jq b jr lc ld le jt lf lg lh lv li lj lk lw ll lm ln lx lo lp lq kb hb bi translated"><em class="hi">注意:</em> <code class="du mn mo mp mq b"><em class="hi">GitHub Packages</em></code> <em class="hi">可以根据动作文档用另一个容器注册表代替，也可以用另一个</em> <code class="du mn mo mp mq b"><em class="hi">VPS</em></code> <em class="hi">代替</em> <code class="du mn mo mp mq b"><em class="hi">DigitalOcean</em></code> <em class="hi">。您可以根据需要自由定制这种配置。</em></p></blockquote><p id="7c5a" class="pw-post-body-paragraph la lb hi jq b jr lc ld le jt lf lg lh jv li lj lk jx ll lm ln jz lo lp lq kb hb bi translated">在<a class="ae kg" href="https://github.com/tfarras/nodejs-deploy" rel="noopener ugc nofollow" target="_blank"> GitHub </a>上找到样板文件</p><p id="fb02" class="pw-post-body-paragraph la lb hi jq b jr lc ld le jt lf lg lh jv li lj lk jx ll lm ln jz lo lp lq kb hb bi translated">在<a class="ae kg" href="https://github.com/tfarras" rel="noopener ugc nofollow" target="_blank"> GitHub </a>和<a class="ae kg" href="https://www.linkedin.com/in/taimoor-farras/" rel="noopener ugc nofollow" target="_blank"> LinkedIn </a>找到我</p></div></div>    
</body>
</html>