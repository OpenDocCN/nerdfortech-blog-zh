<html>
<head>
<title>LeetCode — Pascal’s Triangle</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">李特码——帕斯卡三角形</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/leetcode-pascals-triangle-75d41f2fd973?source=collection_archive---------6-----------------------#2021-10-10">https://medium.com/nerd-for-tech/leetcode-pascals-triangle-75d41f2fd973?source=collection_archive---------6-----------------------#2021-10-10</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><h1 id="e33f" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">问题陈述</h1><p id="3478" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">给定一个整数<strong class="jf hj"> numRows </strong>，返回<strong class="jf hj">帕斯卡三角形</strong>的前numRows。</p><p id="73d9" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">在<strong class="jf hj">帕斯卡三角形</strong>中，每个数字都是它正上方的两个数字之和，如图所示:</p><p id="31a1" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">问题陈述摘自:<a class="ae kg" href="https://leetcode.com/problems/pascals-triangle" rel="noopener ugc nofollow" target="_blank">https://leetcode.com/problems/pascals-triangle</a></p><figure class="ki kj kk kl fd km er es paragraph-image"><div class="er es kh"><img src="../Images/35fa0631f2a3c0494bcd9829a46940d7.png" data-original-src="https://miro.medium.com/v2/resize:fit:520/0*17iRbnlqi49bd5WU.gif"/></div></figure><p id="e16a" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated"><strong class="jf hj">例1: </strong></p><pre class="ki kj kk kl fd kp kq kr ks aw kt bi"><span id="5c1e" class="ku ig hi kq b fi kv kw l kx ky">Input: numRows = 5<br/>Output: [ [1], [1, 1], [1, 2, 1], [1, 3, 3, 1], [1, 4, 6, 4, 1] ]</span></pre><p id="2ae6" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated"><strong class="jf hj">例2: </strong></p><pre class="ki kj kk kl fd kp kq kr ks aw kt bi"><span id="b80f" class="ku ig hi kq b fi kv kw l kx ky">Input: numRows = 1<br/>Output: [[1]]</span></pre><p id="a0a2" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated"><strong class="jf hj">约束:</strong></p><pre class="ki kj kk kl fd kp kq kr ks aw kt bi"><span id="9a1c" class="ku ig hi kq b fi kv kw l kx ky">- 1 &lt;= numRows &lt;= 30</span></pre><h1 id="3a4a" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">说明</h1><h2 id="bbc1" class="ku ig hi bd ih kz la lb il lc ld le ip jo lf lg it js lh li ix jw lj lk jb ll bi translated">强力方法</h2><p id="fe74" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">一个简单的方法是运行两个循环，计算内循环中二项式系数的值。</p><p id="f49c" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">例如，第一行有<strong class="jf hj"> 1 </strong>，第二行有<strong class="jf hj"> 1 1 </strong>，第三行有<strong class="jf hj"> 1 2 1 </strong>，..诸如此类。一行中的每一项都是二项式系数的值。行号line中第I个条目的值是C(line，I)。可以使用以下公式计算该值。</p><pre class="ki kj kk kl fd kp kq kr ks aw kt bi"><span id="5fea" class="ku ig hi kq b fi kv kw l kx ky">C(line, i) = line! / ( (line-i)! * i! )</span></pre><p id="a4fe" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">上述逻辑的一小段C++代码是:</p><pre class="ki kj kk kl fd kp kq kr ks aw kt bi"><span id="9b78" class="ku ig hi kq b fi kv kw l kx ky">void printPascal(int n)<br/>{<br/>    for (int line = 0; line &lt; n; line++){<br/>        for (int i = 0; i &lt;= line; i++)<br/>            cout &lt;&lt;" "&lt;&lt; binomialCoefficient(line, i);<br/>        cout &lt;&lt;"\n";<br/>    }<br/>}<br/><br/>int binomialCoefficient(int n, int k)<br/>{<br/>    int result = 1;<br/><br/>    if (k &gt; n - k)<br/>        k = n - k;<br/><br/>    for (int i = 0; i &lt; k; ++i){<br/>        result *= (n - i);<br/>        result /= (i + 1);<br/>    }<br/><br/>    return result;<br/>}</span></pre><p id="2080" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">因为我们为每次迭代生成一个系数，所以上述问题的时间复杂度是O(N ) 。</p><h2 id="6bea" class="ku ig hi bd ih kz la lb il lc ld le ip jo lf lg it js lh li ix jw lj lk jb ll bi translated">优化的解决方案(O(N)时间和O(N)额外空间)</h2><p id="12e2" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">如果我们看一看帕斯卡三角形，我们可以看到每个条目都是它上面两个值的和。所以我们创建了一个2D数组来存储之前生成的值。</p><p id="71bd" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">上述逻辑的一小段C++代码是:</p><pre class="ki kj kk kl fd kp kq kr ks aw kt bi"><span id="a6f3" class="ku ig hi kq b fi kv kw l kx ky">for (int line = 0; line &lt; n; line++) {<br/>    for (int i = 0; i &lt;= line; i++) {<br/>        if (line == i || i == 0)<br/>            arr[line][i] = 1;<br/>        else<br/>            arr[line][i] = arr[line - 1][i - 1] + arr[line - 1][i];<br/>        cout &lt;&lt; arr[line][i] &lt;&lt; " ";<br/>    }<br/>    cout &lt;&lt; "\n";<br/>}</span></pre><h2 id="780d" class="ku ig hi bd ih kz la lb il lc ld le ip jo lf lg it js lh li ix jw lj lk jb ll bi translated">优化的解决方案(O(N)时间和O(1)额外空间)</h2><p id="6de7" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">这种方法基于暴力方法。具有条目的<em class="lm">的二项式系数可以表示为<strong class="jf hj"> C(line，i) </strong>并且所有行都以值1开始。这里的思路是用<strong class="jf hj"> C(line，i — 1) </strong>计算<strong class="jf hj"> C(line，i) </strong>。可以使用以下公式在O(1)时间内计算。</em></p><pre class="ki kj kk kl fd kp kq kr ks aw kt bi"><span id="0a22" class="ku ig hi kq b fi kv kw l kx ky">C(line, i)     = line! / ( (line - i)! * i! )<br/>C(line, i - 1) = line! / ( (line - i + 1)! * (i - 1)! )<br/><br/>So using the above approach we  can change the formula as below:<br/>C(line, i)     = C(line, i - 1) * (line - i + 1) / i<br/><br/>C(line, i) can be calculated from C(line, i - 1) in O(1) time.</span></pre><p id="f3da" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">让我们检查算法:</p><pre class="ki kj kk kl fd kp kq kr ks aw kt bi"><span id="fa6e" class="ku ig hi kq b fi kv kw l kx ky">- initialize vector&lt;vector&lt;int&gt;&gt; result<br/><br/>- loop for line = 1; line &lt;= n; line++<br/>  - initialize vector&lt;int&gt; temp<br/>  - set C = 1<br/><br/>  - loop for i = 1; i &lt;= line; i++<br/>    - temp.push_back(C)<br/>    - C = C * (line - i) / i<br/><br/>  - result.push_back(temp)<br/><br/>- return result</span></pre><p id="ea56" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated"><strong class="jf hj"> C++解决方案</strong></p><pre class="ki kj kk kl fd kp kq kr ks aw kt bi"><span id="f3f3" class="ku ig hi kq b fi kv kw l kx ky">class Solution {<br/>public:<br/>    vector&lt;vector&lt;int&gt;&gt; generate(int numRows) {<br/>        vector&lt;vector&lt;int&gt;&gt; result;<br/><br/>        for (int line = 1; line &lt;= numRows; line++){<br/>            vector&lt;int&gt; temp;<br/>            int C = 1;<br/><br/>            for (int i = 1; i &lt;= line; i++){<br/>                temp.push_back(C);<br/>                C = C * (line - i) / i;<br/>            }<br/><br/>            result.push_back(temp);<br/>        }<br/><br/>        return result;<br/>    }<br/>};</span></pre><p id="75d2" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated"><strong class="jf hj"> Golang解决方案</strong></p><pre class="ki kj kk kl fd kp kq kr ks aw kt bi"><span id="5b0b" class="ku ig hi kq b fi kv kw l kx ky">func generate(numRows int) [][]int {<br/>    var result [][]int<br/><br/>    for line := 1; line &lt;= numRows; line++ {<br/>        var temp []int<br/>        C := 1<br/><br/>        for i := 1; i &lt;= line; i++ {<br/>            temp = append(temp, C);<br/>            C = C * (line - i) / i;<br/>        }<br/><br/>        result = append(result, temp)<br/>    }<br/><br/>    return result<br/>}</span></pre><p id="ad82" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated"><strong class="jf hj"> Javascript解决方案</strong></p><pre class="ki kj kk kl fd kp kq kr ks aw kt bi"><span id="e55a" class="ku ig hi kq b fi kv kw l kx ky">var generate = function(numRows) {<br/>    var result = [];<br/><br/>    for(let line = 1; line &lt;= numRows; line++){<br/>        var temp = [];<br/>        let C = 1;<br/><br/>        for(let i = 1; i &lt;= line; i++){<br/>            temp.push(C);<br/>            C = C * (line - i) / i;<br/>        }<br/><br/>        result.push(temp);<br/>    }<br/><br/>    return result;<br/>};</span></pre><p id="3114" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">让我们试运行一下我们的算法，看看解决方案是如何工作的。</p><pre class="ki kj kk kl fd kp kq kr ks aw kt bi"><span id="8792" class="ku ig hi kq b fi kv kw l kx ky">Input: numRows = 3<br/><br/>Step 1: initialize vector&lt;vector&lt;int&gt;&gt; result<br/><br/>Step 2: loop for line = 1; line &lt;= numRows<br/>        1 &lt;= 3<br/>        true<br/><br/>        initialize vector&lt;int&gt; temp<br/><br/>        C = 1<br/><br/>        loop for i = 1; i &lt;= line<br/>        1 &lt;= 1<br/>        true<br/><br/>        temp.push_back(C);<br/>        temp = [1]<br/><br/>        C = C * (line - i) / i;<br/>        C = 1 * (1  - 1) / 1<br/>        C = 0<br/><br/>        i++<br/>        i = 2<br/><br/>        loop for i &lt;= line<br/>        2 &lt;= 1<br/>        false<br/><br/>        result.push_back(temp)<br/><br/>        result = [[1]]<br/><br/>        line++<br/>        line = 2<br/><br/>Step 3: loop for line &lt;= numRows<br/>        2 &lt;= 3<br/>        true<br/><br/>        initialize vector&lt;int&gt; temp<br/><br/>        C = 1<br/><br/>        loop for i = 1; i &lt;= line<br/>        1 &lt;= 2<br/>        true<br/><br/>        temp.push_back(C);<br/>        temp = [1]<br/><br/>        C = C * (line - i) / i<br/>        C = 1 * (2  - 1) / 1<br/>        C = 1 * 1 / 1<br/><br/>        i++<br/>        i = 2<br/><br/>        loop for i &lt;= line<br/>        2 &lt;= 2<br/>        true<br/><br/>        loop for i &lt;= line<br/>        2 &lt;= 2<br/>        true<br/><br/>        temp.push_back(C);<br/>        temp = [1, 1]<br/><br/>        C = C * (line - i) / i<br/>        C = 1 * (2  - 2) / 1<br/>        C = 1 * 0 / 1<br/>        C = 0<br/><br/>        i++<br/>        i = 3<br/><br/>        loop for i &lt;= line<br/>        3 &lt;= 2<br/>        false<br/><br/>        result.push_back(temp)<br/><br/>        result = [[1], [1, 1]]<br/><br/>        line++<br/>        line = 3<br/><br/>Step 4: loop for line &lt;= numRows<br/>        3 &lt;= 3<br/>        true<br/><br/>        initialize vector&lt;int&gt; temp<br/><br/>        C = 1<br/><br/>        loop for i = 1; i &lt;= line<br/>        1 &lt;= 3<br/>        true<br/><br/>        temp.push_back(C);<br/>        temp = [1]<br/><br/>        C = C * (line - i) / i<br/>        C = 1 * (3 - 1) / 1<br/>        C = 1 * 2 / 1<br/>        C = 2<br/><br/>        i++<br/>        i = 2<br/><br/>        loop for i &lt;= line<br/>        2 &lt;= 3<br/>        true<br/><br/>        temp.push_back(C);<br/>        temp = [1, 2]<br/><br/>        C = C * (line - i) / i<br/>        C = 2 * (3 - 2) / 2<br/>        C = 2 * 1 / 2<br/>        C = 1<br/><br/>        i++<br/>        i = 3<br/><br/>        loop for i &lt;= line<br/>        3 &lt;= 3<br/>        true<br/><br/>        temp.push_back(C);<br/>        temp = [1, 2, 1]<br/><br/>        C = C * (line - i) / i<br/>        C = 1 * (3 - 3) / 3<br/>        C = 1 * 0 / 3<br/>        C = 0<br/><br/>        i++<br/>        i = 4<br/><br/>        loop for i &lt;= line<br/>        4 &lt;= 3<br/>        false<br/><br/>        result.push_back(temp)<br/>        result = [[1], [1, 1], [1, 2, 1]]<br/><br/>        line++<br/>        line = 4<br/><br/>Step 5: loop for line &lt;= numRows<br/>        4 &lt;= 3<br/>        false<br/><br/>Step 6: return result<br/><br/>So the result is [[1], [1, 1], [1, 2, 1]].</span></pre></div><div class="ab cl ln lo gp lp" role="separator"><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls"/></div><div class="hb hc hd he hf"><p id="d8c3" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated"><em class="lm">原载于</em><a class="ae kg" href="https://alkeshghorpade.me/post/leetcode-pascals-triangle" rel="noopener ugc nofollow" target="_blank"><em class="lm">https://alkeshghorpade . me</em></a><em class="lm">。</em></p></div></div>    
</body>
</html>