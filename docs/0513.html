<html>
<head>
<title>Continuous Deployment of AWS Lambda with Java Runtime</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Java运行时持续部署AWS Lambda</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/continuous-deployment-of-aws-lambda-with-java-runtime-7b6d6188607?source=collection_archive---------0-----------------------#2021-01-06">https://medium.com/nerd-for-tech/continuous-deployment-of-aws-lambda-with-java-runtime-7b6d6188607?source=collection_archive---------0-----------------------#2021-01-06</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><figure class="hh hi ez fb hj hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es hg"><img src="../Images/f15e2f6539d1b7f1791a73455fe5d548.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WoQpbeBX76V2ZbnasdaOyA.jpeg"/></div></div></figure><div class=""/><blockquote class="iq ir is"><p id="1cb9" class="it iu iv iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">这是我自己写的一篇关于如何为用Java编写的Lambda设置CI/CD的笔记。</p></blockquote><p id="b857" class="pw-post-body-paragraph it iu ht iw b ix iy iz ja jb jc jd je js jg jh ji jt jk jl jm ju jo jp jq jr hb bi translated">如今，只需要证明的想法和概念的实现可以使用无服务器方法来完成。这种方法有很多好处:没有基础设施管理和现收现付的支付模式，等等。但是在开始编写业务逻辑代码之前，您需要确保尽可能快地构建和交付代码更改。</p><p id="4996" class="pw-post-body-paragraph it iu ht iw b ix iy iz ja jb jc jd je js jg jh ji jt jk jl jm ju jo jp jq jr hb bi translated">AWS CodePipeline是一项服务，它编排连续交付无服务器应用程序所需的步骤。基本上，这些步骤包括从CodeCommit中提取代码，用CodeBuild编译和打包代码，最后用CodeDeploy部署包。但在AWS Lambda的情况下，部署过程略有不同，还涉及亚马逊S3、CloudFormation和AWS无服务器应用模型。</p><p id="cf29" class="pw-post-body-paragraph it iu ht iw b ix iy iz ja jb jc jd je js jg jh ji jt jk jl jm ju jo jp jq jr hb bi translated">假设我们的目标是在每次提交时使用CodeCommit中托管的Java代码库执行Lambda函数的自动部署。AWS提供的代码管道教程很少。描述如何<a class="ae jv" href="https://docs.aws.amazon.com/codepipeline/latest/userguide/tutorials-serverlessrepo-auto-publish.html" rel="noopener ugc nofollow" target="_blank">将无服务器应用程序发布到AWS无服务器应用程序库</a>的版本是最接近帮助实现我们目标的版本，但是它需要一些小的更新和注释来使其适用于Lambda和Java代码。</p><h2 id="e17b" class="jw jx ht bd jy jz ka kb kc kd ke kf kg js kh ki kj jt kk kl km ju kn ko kp kq bi translated">开始之前</h2><p id="08e4" class="pw-post-body-paragraph it iu ht iw b ix kr iz ja jb ks jd je js kt jh ji jt ku jl jm ju kv jp jq jr hb bi translated">您必须已经拥有或按照本教程创建:</p><ul class=""><li id="a69a" class="kw kx ht iw b ix iy jb jc js ky jt kz ju la jr lb lc ld le bi translated">一个CodeCommit存储库，里面有一些用Java编写的Lambda示例代码，你可以使用AWS 提供的<a class="ae jv" href="https://github.com/awsdocs/aws-lambda-developer-guide/tree/main/sample-apps/java-basic" rel="noopener ugc nofollow" target="_blank">示例。您还可以在为本文创建的GitHub </a>资源库中使用<a class="ae jv" href="https://github.com/antonbakalets/demo-aws-lambda-ci-cd" rel="noopener ugc nofollow" target="_blank">代码示例。</a></li><li id="ee21" class="kw kx ht iw b ix lf jb lg js lh jt li ju lj jr lb lc ld le bi translated">存储代码部署包的S3桶。</li><li id="83a6" class="kw kx ht iw b ix lf jb lg js lh jt li ju lj jr lb lc ld le bi translated">您应该熟悉AWS CloudFormation和AWS无服务器应用程序模型(AWS SAM)</li></ul><h2 id="e026" class="jw jx ht bd jy jz ka kb kc kd ke kf kg js kh ki kj jt kk kl km ju kn ko kp kq bi translated">步骤1:创建一个buildspec.yml文件</h2><p id="d31b" class="pw-post-body-paragraph it iu ht iw b ix kr iz ja jb ks jd je js kt jh ji jt ku jl jm ju kv jp jq jr hb bi translated">使用以下内容创建一个<code class="du lk ll lm ln b">buildspec.yml</code>文件，并将其添加到CodeCommit存储库的根文件夹中。<code class="du lk ll lm ln b">sam-template.yml</code>是您的应用程序的AWS SAM模板，<code class="du lk ll lm ln b">bucketname</code>是您打包的应用程序将被存储的S3桶。</p><pre class="lo lp lq lr fd ls ln lt lu aw lv bi"><span id="98e6" class="jw jx ht ln b fi lw lx l ly lz"><strong class="ln hu">version</strong>: 0.2<br/><br/><strong class="ln hu">phases</strong>:<br/>  <strong class="ln hu">install</strong>:<br/>    <strong class="ln hu">runtime-versions</strong>:<br/>      <strong class="ln hu">java</strong>: corretto11<br/>  <strong class="ln hu">build</strong>:<br/>    <strong class="ln hu">commands</strong>:<br/>      - mvn package<br/>      - sam package <br/>        --template-file <em class="iv">sam-template.yml</em> <br/>        --s3-bucket <em class="iv">bucketname</em> <br/>        --output-template-file packaged-template.yml<br/><strong class="ln hu">artifacts</strong>:<br/>  <strong class="ln hu">files</strong>:<br/>    - packaged-template.yml</span></pre><p id="b503" class="pw-post-body-paragraph it iu ht iw b ix iy iz ja jb jc jd je js jg jh ji jt jk jl jm ju jo jp jq jr hb bi translated">这里最重要的是理解<code class="du lk ll lm ln b">sam-template.yml</code>和<code class="du lk ll lm ln b">packaged-template.yml</code>文件的区别。<code class="du lk ll lm ln b">sam package</code>命令为你的代码创建一个. zip文件，并上传到S3。然后它返回AWS SAM模板的副本(<code class="du lk ll lm ln b">packaged-template.yml</code>，用亚马逊S3的位置替换对本地工件的引用。</p><p id="fbfe" class="pw-post-body-paragraph it iu ht iw b ix iy iz ja jb jc jd je js jg jh ji jt jk jl jm ju jo jp jq jr hb bi translated">这里需要注意的其他几个项目:</p><ul class=""><li id="323f" class="kw kx ht iw b ix iy jb jc js ky jt kz ju la jr lb lc ld le bi translated">您可能已经注意到Maven用于构建包含所有必需依赖项的阴影jar，但是Gradle也可以使用。</li><li id="828c" class="kw kx ht iw b ix lf jb lg js lh jt li ju lj jr lb lc ld le bi translated"><code class="du lk ll lm ln b">runtime-versions</code>部分指定了Java的版本11。亚马逊推荐亚马逊Linux 2标准镜像使用<code class="du lk ll lm ln b">correto11</code>，Ubuntu标准镜像使用<code class="du lk ll lm ln b">openjdk11</code>。</li><li id="f571" class="kw kx ht iw b ix lf jb lg js lh jt li ju lj jr lb lc ld le bi translated">请注意<code class="du lk ll lm ln b">buildspec.yml</code>0.1版不支持<code class="du lk ll lm ln b">runtime-versions</code>部分。</li></ul><h2 id="10df" class="jw jx ht bd jy jz ka kb kc kd ke kf kg js kh ki kj jt kk kl km ju kn ko kp kq bi translated">步骤2:创建并配置您的管道</h2><p id="3a3c" class="pw-post-body-paragraph it iu ht iw b ix kr iz ja jb ks jd je js kt jh ji jt ku jl jm ju kv jp jq jr hb bi translated">这一步完全重复教程中的步骤2:创建和配置您的管道。如果你用的是CodeCommit而不是GitHub，用的是Amazon Linux 2操作系统而不是Ubuntu，只要做适当的改动就可以了。</p><p id="142a" class="pw-post-body-paragraph it iu ht iw b ix iy iz ja jb jc jd je js jg jh ji jt jk jl jm ju jo jp jq jr hb bi translated">只是不要忘记添加一个新的策略声明，允许CodeBuild将对象放入存储打包应用程序的S3桶中。</p><h2 id="bc0a" class="jw jx ht bd jy jz ka kb kc kd ke kf kg js kh ki kj jt kk kl km ju kn ko kp kq bi translated">步骤3:创建部署操作</h2><p id="0183" class="pw-post-body-paragraph it iu ht iw b ix kr iz ja jb ks jd je js kt jh ji jt ku jl jm ju kv jp jq jr hb bi translated">按照以下步骤设置负责创建包含Lambda函数的CloudFormation堆栈的管道操作。</p><ol class=""><li id="9367" class="kw kx ht iw b ix iy jb jc js ky jt kz ju la jr ma lc ld le bi translated">打开代码管道控制台。</li><li id="fc1b" class="kw kx ht iw b ix lf jb lg js lh jt li ju lj jr ma lc ld le bi translated">在左侧导航部分，选择要编辑的管道。</li><li id="cce8" class="kw kx ht iw b ix lf jb lg js lh jt li ju lj jr ma lc ld le bi translated">选择<strong class="iw hu">编辑</strong>。</li><li id="a64d" class="kw kx ht iw b ix lf jb lg js lh jt li ju lj jr ma lc ld le bi translated">在当前管道的最后一个阶段之后，选择<strong class="iw hu"> +添加阶段</strong>。在<strong class="iw hu">阶段名称</strong>中输入一个名称，如<code class="du lk ll lm ln b"><strong class="iw hu">Deploy</strong></code>，选择<strong class="iw hu">添加阶段</strong>。</li><li id="39c7" class="kw kx ht iw b ix lf jb lg js lh jt li ju lj jr ma lc ld le bi translated">在新阶段，选择<strong class="iw hu"> +添加行动组</strong>。</li><li id="6b4a" class="kw kx ht iw b ix lf jb lg js lh jt li ju lj jr ma lc ld le bi translated">输入操作名称。从<strong class="iw hu">动作提供器</strong>中，在<strong class="iw hu">调用</strong>中，选择<strong class="iw hu"> AWS CloudFormation </strong>。</li><li id="a8a2" class="kw kx ht iw b ix lf jb lg js lh jt li ju lj jr ma lc ld le bi translated">从<strong class="iw hu">输入工件</strong>，选择<strong class="iw hu">构建工件</strong>。</li><li id="fbe4" class="kw kx ht iw b ix lf jb lg js lh jt li ju lj jr ma lc ld le bi translated">从<strong class="iw hu">动作模式</strong>中，选择<strong class="iw hu">创建或更新堆栈</strong>。</li><li id="158f" class="kw kx ht iw b ix lf jb lg js lh jt li ju lj jr ma lc ld le bi translated">选择您的<strong class="iw hu">堆栈名称</strong>。</li><li id="84e8" class="kw kx ht iw b ix lf jb lg js lh jt li ju lj jr ma lc ld le bi translated">在<strong class="iw hu">工件名称</strong>的<strong class="iw hu">模板</strong>部分，选择<strong class="iw hu"> BuildArtifact </strong>并且<strong class="iw hu">文件名</strong>应该是前面提到的SAM转换的结果<code class="du lk ll lm ln b">packaged-template.yml</code>。</li><li id="ee6f" class="kw kx ht iw b ix lf jb lg js lh jt li ju lj jr ma lc ld le bi translated">您需要添加两个<strong class="iw hu">功能</strong> : <strong class="iw hu"> CAPABILITY_IAM </strong>来确认您希望允许Cloudformation修改IAM项，以及<strong class="iw hu"> CAPABILITY_AUTO_EXPAND </strong>因为模板包含AWS::Serverless transforms，这是一个由AWS CloudFormation托管的宏。</li><li id="93c2" class="kw kx ht iw b ix lf jb lg js lh jt li ju lj jr ma lc ld le bi translated">您需要创建一个角色来允许CloudFormation执行所需的操作:从S3下载工件，创建变更集，创建Lambda函数，并为模板文件中定义的Lambda函数创建一个角色。</li></ol><pre class="lo lp lq lr fd ls ln lt lu aw lv bi"><span id="f936" class="jw jx ht ln b fi lw lx l ly lz">{<br/>  <strong class="ln hu">"Version"</strong>: <strong class="ln hu">"2012-10-17"</strong>,<br/>  <strong class="ln hu">"Statement"</strong>: [<br/>    {<br/>      <strong class="ln hu">"Action"</strong>: [<br/>        <strong class="ln hu">"lambda:CreateFunction"</strong>,<br/>        <strong class="ln hu">"lambda:GetFunction"</strong>,<br/>        <strong class="ln hu">"lambda:DeleteFunction"</strong>,<br/>        <strong class="ln hu">"lambda:UpdateFunctionCode"</strong>,<br/>        <strong class="ln hu">"lambda:UpdateFunctionConfiguration"</strong>,<br/>        <strong class="ln hu">"lambda:ListTags"</strong>,<br/>        <strong class="ln hu">"lambda:TagResource"</strong>,<br/>        <strong class="ln hu">"lambda:UntagResource"</strong>,<br/>        <strong class="ln hu">"cloudformation:CreateChangeSet"</strong>,<br/>        <strong class="ln hu">"iam:GetRole"</strong>,<br/>        <strong class="ln hu">"iam:CreateRole"</strong>,<br/>        <strong class="ln hu">"iam:DeleteRole"</strong>,<br/>        <strong class="ln hu">"iam:PutRolePolicy"</strong>,<br/>        <strong class="ln hu">"iam:AttachRolePolicy"</strong>,<br/>        <strong class="ln hu">"iam:DeleteRolePolicy"</strong>,<br/>        <strong class="ln hu">"iam:DetachRolePolicy"</strong>,<br/>        <strong class="ln hu">"iam:PassRole"</strong>,<br/>        <strong class="ln hu">"s3:GetObject"<br/>      </strong>],<br/>      <strong class="ln hu">"Resource"</strong>: <strong class="ln hu">"*"</strong>,<br/>      <strong class="ln hu">"Effect"</strong>: <strong class="ln hu">"Allow"<br/>    </strong>}<br/>  ]<br/>}</span></pre><p id="c376" class="pw-post-body-paragraph it iu ht iw b ix iy iz ja jb jc jd je js jg jh ji jt jk jl jm ju jo jp jq jr hb bi translated">13.选择<strong class="iw hu">完成</strong>动作。</p><p id="7577" class="pw-post-body-paragraph it iu ht iw b ix iy iz ja jb jc jd je js jg jh ji jt jk jl jm ju jo jp jq jr hb bi translated">14.为舞台选择<strong class="iw hu"> Done </strong>。</p><p id="092c" class="pw-post-body-paragraph it iu ht iw b ix iy iz ja jb jc jd je js jg jh ji jt jk jl jm ju jo jp jq jr hb bi translated">为了验证您的管道，提交并将更改推送到您的代码库中。当管道完成时，您可以检查由CloudFormation stack创建的资源，并找到您的Lambda函数。</p><h2 id="8ef4" class="jw jx ht bd jy jz ka kb kc kd ke kf kg js kh ki kj jt kk kl km ju kn ko kp kq bi translated">演员表</h2><p id="ef19" class="pw-post-body-paragraph it iu ht iw b ix kr iz ja jb ks jd je js kt jh ji jt ku jl jm ju kv jp jq jr hb bi translated">既然您的管道已经设置好了，Lambda函数也已经部署好了，那么您可能想知道运行这个基础设施的成本是多少。根据计费服务收取下一次服务费用:</p><ul class=""><li id="9ce1" class="kw kx ht iw b ix iy jb jc js ky jt kz ju la jr lb lc ld le bi translated">每个用户的代码提交费用。</li><li id="f7b9" class="kw kx ht iw b ix lf jb lg js lh jt li ju lj jr lb lc ld le bi translated">每构建分钟的代码构建费用。</li><li id="43e7" class="kw kx ht iw b ix lf jb lg js lh jt li ju lj jr lb lc ld le bi translated">S3按不同类型的请求和存储量收费。</li><li id="0f66" class="kw kx ht iw b ix lf jb lg js lh jt li ju lj jr lb lc ld le bi translated">CloudWatch按日志数据量收费。</li><li id="1a3b" class="kw kx ht iw b ix lf jb lg js lh jt li ju lj jr lb lc ld le bi translated">Lambda每次调用收费。</li></ul><p id="8ed3" class="pw-post-body-paragraph it iu ht iw b ix iy iz ja jb jc jd je js jg jh ji jt jk jl jm ju jo jp jq jr hb bi translated">因此，您使用现收现付模式进行收费。对于列表中的每一项资源，您只需在使用时付费:当您触发构建或调用Lambda函数时。当然，在执行快速原型时，您可以设法将所有费用保持在免费使用层限制之下。</p><h2 id="31cf" class="jw jx ht bd jy jz ka kb kc kd ke kf kg js kh ki kj jt kk kl km ju kn ko kp kq bi translated">打扫</h2><p id="48bf" class="pw-post-body-paragraph it iu ht iw b ix kr iz ja jb ks jd je js kt jh ji jt ku jl jm ju kv jp jq jr hb bi translated">通过删除存储在S3存储桶中的构建包，可以减少S3存储的使用量。最简单的方法是在bucket上声明<a class="ae jv" href="https://docs.aws.amazon.com/AmazonS3/latest/dev/object-lifecycle-mgmt.html" rel="noopener ugc nofollow" target="_blank">生命周期管理</a>规则，不需要任何额外的服务调用和IAM配置。</p><p id="44ec" class="pw-post-body-paragraph it iu ht iw b ix iy iz ja jb jc jd je js jg jh ji jt jk jl jm ju jo jp jq jr hb bi translated">即使成本真的很低，您也可能希望删除所有创建的资源，以避免任何额外的费用。只需删除CloudFormation堆栈，它将删除所有资源，如Lambda函数和与其相关的IAM角色。</p><p id="cadc" class="pw-post-body-paragraph it iu ht iw b ix iy iz ja jb jc jd je js jg jh ji jt jk jl jm ju jo jp jq jr hb bi translated">既然您的栈模板已经在<a class="ae jv" href="https://github.com/antonbakalets/demo-aws-lambda-ci-cd" rel="noopener ugc nofollow" target="_blank">源代码</a>中，您可以根据基础设施作为代码原则添加新的资源，对业务逻辑或栈模板的每个更改都将由管道自动部署。</p></div></div>    
</body>
</html>