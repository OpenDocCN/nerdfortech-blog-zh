<html>
<head>
<title>Named Constructor vs Factory Constructor in Dart</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Dart中的命名构造函数与工厂构造函数</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/named-constructor-vs-factory-constructor-in-dart-ba28250b2747?source=collection_archive---------0-----------------------#2021-06-28">https://medium.com/nerd-for-tech/named-constructor-vs-factory-constructor-in-dart-ba28250b2747?source=collection_archive---------0-----------------------#2021-06-28</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="94f7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这也是dart初学者和刚接触面向对象编程的人最困惑的话题之一。他们就像<strong class="ih hj"> <em class="jd">“我们为什么需要这些？”</em> </strong> <em class="jd"> </em> <strong class="ih hj"> <em class="jd">“两者看起来几乎相似”“什么时候我应该更喜欢一个而不是另一个？”如果你有任何疑问，我在这里为你解答。</em></strong></p><h2 id="3161" class="je jf hi bd jg jh ji jj jk jl jm jn jo iq jp jq jr iu js jt ju iy jv jw jx jy bi translated"><strong class="ak"> <em class="jz">当我们调用一个构造函数时？</em>T13】</strong></h2><p id="c5ae" class="pw-post-body-paragraph if ig hi ih b ii ka ik il im kb io ip iq kc is it iu kd iw ix iy ke ja jb jc hb bi translated">当我们需要一个类的对象时，我们调用一个构造函数。有时我们不关心它是一个新实例还是一个已经存在的实例或者一个子类型实例，我们所需要的是一个与<strong class="ih hj">兼容的</strong>实例，但是有时，我们需要一个<strong class="ih hj">新实例和一个确切的类型</strong>(不是上面也不是下面)。这就是两个构造函数的区别所在。如果你不明白，让我解释得更清楚些。</p><h1 id="2b3b" class="kf jf hi bd jg kg kh ki jk kj kk kl jo km kn ko jr kp kq kr ju ks kt ku jx kv bi translated"><strong class="ak">命名构造器</strong></h1><p id="7ff5" class="pw-post-body-paragraph if ig hi ih b ii ka ik il im kb io ip iq kc is it iu kd iw ix iy ke ja jb jc hb bi translated">命名构造函数只不过是一个有名字的构造函数。你可能会问为什么我们需要一个有名字的构造函数？</p><p id="b50d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果你来自任何其他面向对象的编程语言，比如Java，C++，只要参数不同，你就可以用不止一个构造函数来编写一个类。遗憾的是，我们在Dart中没有该功能😥但是命名构造函数支持我们😃而且我觉得比Java，C++等那些重载的构造函数强多了。</p><p id="747c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们看一个例子</p><figure class="kw kx ky kz fd la"><div class="bz dy l di"><div class="lb lc l"/></div></figure><p id="6afa" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在这个例子中，我们从Json()创建一个命名的构造函数，它接受一个map作为它的参数，并从map生成一个对象。</p><p id="e2cc" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们还可以将JSON解码逻辑移到类本身，</p><figure class="kw kx ky kz fd la"><div class="bz dy l di"><div class="lb lc l"/></div></figure><figure class="kw kx ky kz fd la"><div class="bz dy l di"><div class="lb lc l"/></div></figure><p id="8dd9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">正如你在第5行看到的，我们使用了命名构造函数，类似于普通的构造函数，但是有一个名字。</p><h2 id="1b2d" class="je jf hi bd jg jh ji jj jk jl jm jn jo iq jp jq jr iu js jt ju iy jv jw jx jy bi translated"><strong class="ak">命名构造函数有什么用？</strong></h2><ol class=""><li id="de1b" class="ld le hi ih b ii ka im kb iq lf iu lg iy lh jc li lj lk ll bi translated"><strong class="ih hj">提高了可读性，</strong>正如你所看到的，Person.fromJson()构造函数使得我们从Json创建一个实例变得非常明显。</li><li id="3a0a" class="ld le hi ih b ii lm im ln iq lo iu lp iy lq jc li lj lk ll bi translated">支持重载的构造函数，现在我们可以为我们的类拥有任意多的构造函数。</li><li id="7bda" class="ld le hi ih b ii lm im ln iq lo iu lp iy lq jc li lj lk ll bi translated">它总是像默认构造函数一样返回精确类型(本例中为Person)<strong class="ih hj"/>的新实例。</li></ol></div><div class="ab cl lr ls gp lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="hb hc hd he hf"><h1 id="c718" class="kf jf hi bd jg kg ly ki jk kj lz kl jo km ma ko jr kp mb kr ju ks mc ku jx kv bi translated"><strong class="ak"> <em class="jz">工厂构造器</em> </strong></h1><p id="1de4" class="pw-post-body-paragraph if ig hi ih b ii ka ik il im kb io ip iq kc is it iu kd iw ix iy ke ja jb jc hb bi translated">我已经就这个话题写了两篇文章(<a class="ae md" href="https://imsaravananm.medium.com/factory-constructor-in-dart-part-1-1bbdf0d0f7f0" rel="noopener"> part-1 </a>、<a class="ae md" href="https://imsaravananm.medium.com/factory-constructor-in-dart-part-2-7db2a5981ac3" rel="noopener"> part-2 </a>)。所以我就简单说一下这个。</p><p id="d13e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">当我们需要时，我们使用工厂构造函数</p><ol class=""><li id="6df0" class="ld le hi ih b ii ij im in iq me iu mf iy mg jc li lj lk ll bi translated">决定在运行时返回哪个实例(<a class="ae md" href="https://imsaravananm.medium.com/factory-constructor-in-dart-part-1-1bbdf0d0f7f0" rel="noopener"> <em class="jd">见本文</em> </a>)</li><li id="4063" class="ld le hi ih b ii lm im ln iq lo iu lp iy lq jc li lj lk ll bi translated">缓存实例以供重用。</li></ol></div><div class="ab cl lr ls gp lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="hb hc hd he hf"><p id="0603" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">所以读完了他们两个，让我们来理解他们之间真正的区别</p><figure class="kw kx ky kz fd la"><div class="bz dy l di"><div class="mh lc l"/></div></figure><h2 id="e2d8" class="je jf hi bd jg jh ji jj jk jl jm jn jo iq jp jq jr iu js jt ju iy jv jw jx jy bi translated">1.对实例成员的访问</h2><ul class=""><li id="7c47" class="ld le hi ih b ii ka im kb iq lf iu lg iy lh jc mi lj lk ll bi translated">一个命名的构造函数可以访问<strong class="ih hj"> <em class="jd">这个</em> </strong> <em class="jd">关键字，因此它可以访问任何成员变量和方法。</em></li><li id="a288" class="ld le hi ih b ii lm im ln iq lo iu lp iy lq jc mi lj lk ll bi translated">工厂构造函数是静态的，所以它不能访问<strong class="ih hj">这个</strong>关键字。</li></ul><h2 id="e386" class="je jf hi bd jg jh ji jj jk jl jm jn jo iq jp jq jr iu js jt ju iy jv jw jx jy bi translated">2.退货单</h2><ul class=""><li id="d52f" class="ld le hi ih b ii ka im kb iq lf iu lg iy lh jc mi lj lk ll bi translated">命名构造函数像普通构造函数一样工作，它不需要显式返回实例。(不需要return语句)你见过末尾有return语句的构造函数吗？</li><li id="0acd" class="ld le hi ih b ii lm im ln iq lo iu lp iy lq jc mi lj lk ll bi translated">工厂构造函数应该显式返回一个实例。看所有的工厂构造函数，最后总有一个return语句。</li></ul><h2 id="2330" class="je jf hi bd jg jh ji jj jk jl jm jn jo iq jp jq jr iu js jt ju iy jv jw jx jy bi translated">3.返回的实例类型</h2><ul class=""><li id="198b" class="ld le hi ih b ii ka im kb iq lf iu lg iy lh jc mi lj lk ll bi translated">命名构造函数只能生成当前类的实例。</li><li id="83f7" class="ld le hi ih b ii lm im ln iq lo iu lp iy lq jc mi lj lk ll bi translated">工厂构造函数可以决定在运行时返回哪个实例，它可以返回当前类的实例，也可以返回其后代类的任何实例。</li></ul><h2 id="0c96" class="je jf hi bd jg jh ji jj jk jl jm jn jo iq jp jq jr iu js jt ju iy jv jw jx jy bi translated">4.新的或旧的实例</h2><ul class=""><li id="e81a" class="ld le hi ih b ii ka im kb iq lf iu lg iy lh jc mi lj lk ll bi translated">这可能是一个小问题，但是命名构造函数总是会返回一个新的实例。</li><li id="de40" class="ld le hi ih b ii lm im ln iq lo iu lp iy lq jc mi lj lk ll bi translated">工厂构造函数可以基于我们的实现返回一个新的实例或者一个缓存的实例(更多关于这个<a class="ae md" href="https://imsaravananm.medium.com/factory-constructor-in-dart-part-2-7db2a5981ac3" rel="noopener">在这里</a></li></ul><p id="44cd" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我希望，现在你已经很清楚什么时候应该选择哪一个。竖起大拇指👍如果你喜欢这篇文章，你也可以在评论区分享你的想法。谢谢你。</p></div></div>    
</body>
</html>