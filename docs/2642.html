<html>
<head>
<title>Lets make a hook series part 1 — Debounce Hook</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">让我们做一个钩子系列第一部分——去抖钩子</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/lets-make-a-hook-series-part-1-debounce-hook-b6c4697f39d7?source=collection_archive---------13-----------------------#2021-05-14">https://medium.com/nerd-for-tech/lets-make-a-hook-series-part-1-debounce-hook-b6c4697f39d7?source=collection_archive---------13-----------------------#2021-05-14</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/282004038522cbc21c1b36994e0bee79.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YwdSmnHx9RGXpyeWlj5jOQ.png"/></div></div></figure><p id="ade5" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">钩子真的很神奇。它们使您能够分离组件的状态和逻辑。这确实有助于使用定制钩子编写可重用的逻辑。</p><p id="b97e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">因此，在我最近的 React 项目中，我为去抖动和消费 axios 请求定制了钩子。我想我们还能用钩子做什么。所以，我会与你分享我的钩子，然后你可以写一个评论，如果你想实现一些其他的钩子，我会非常乐意合作，把它们添加到这个系列中，或者只是给我一个挑战。</p></div><div class="ab cl jo jp gp jq" role="separator"><span class="jr bw bk js jt ju"/><span class="jr bw bk js jt ju"/><span class="jr bw bk js jt"/></div><div class="hb hc hd he hf"><h1 id="8128" class="jv jw hi bd jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks bi translated">什么是去抖？</h1><p id="043c" class="pw-post-body-paragraph iq ir hi is b it kt iv iw ix ku iz ja jb kv jd je jf kw jh ji jj kx jl jm jn hb bi translated">大多数人对去抖都很熟悉。这是一个限制函数被调用的速率的过程。例如，实现一个文本搜索，调用一个 API 来获得结果。您不希望在每次击键时都调用 API，因此您可以通过设置一个时间段来限制调用 API 的频率，在该时间段之后，将使用最后一次文本输入来调用 API。</p><h1 id="9122" class="jv jw hi bd jx jy ky ka kb kc kz ke kf kg la ki kj kk lb km kn ko lc kq kr ks bi translated">去抖钩</h1><p id="1f6f" class="pw-post-body-paragraph iq ir hi is b it kt iv iw ix ku iz ja jb kv jd je jf kw jh ji jj kx jl jm jn hb bi translated">我们可以通过使用 NodeJS setTimeout 函数来实现去抖行为。NodeJS setTimeout 函数返回一个数字，该数字可用于通过清除“我们的意思是它将在超时时间段后不再运行”来清除超时。因此，我们要做的是在调用函数时创建一个 NodeJS 超时，如果函数在超时前再次被调用，我们清除以前的超时并创建一个新的超时。这样，先前的函数调用将被丢弃，一段时间后将调用新的函数。因此，如果用户在去抖时间段内输入“America ”,该函数将只对整个文本“America”调用一次，而不是对每个字母都调用该函数。让我们开始实施吧。</p><h2 id="626e" class="ld jw hi bd jx le lf lg kb lh li lj kf jb lk ll kj jf lm ln kn jj lo lp kr lq bi translated">第一步</h2><p id="9688" class="pw-post-body-paragraph iq ir hi is b it kt iv iw ix ku iz ja jb kv jd je jf kw jh ji jj kx jl jm jn hb bi translated">创建一个状态来记住由 setTimeout 函数返回的 NodeJS setTimeout id。</p><figure class="lr ls lt lu fd ij"><div class="bz dy l di"><div class="lv lw l"/></div></figure><h2 id="94d1" class="ld jw hi bd jx le lf lg kb lh li lj kf jb lk ll kj jf lm ln kn jj lo lp kr lq bi translated">第二步</h2><p id="12c7" class="pw-post-body-paragraph iq ir hi is b it kt iv iw ix ku iz ja jb kv jd je jf kw jh ji jj kx jl jm jn hb bi translated">创建去抖功能。我们将使用 useCallback，所以如果反跳函数出现在钩子的依赖数组中，它不会导致任何不必要的渲染。</p><figure class="lr ls lt lu fd ij"><div class="bz dy l di"><div class="lv lw l"/></div></figure><h2 id="6166" class="ld jw hi bd jx le lf lg kb lh li lj kf jb lk ll kj jf lm ln kn jj lo lp kr lq bi translated">第三步</h2><p id="3006" class="pw-post-body-paragraph iq ir hi is b it kt iv iw ix ku iz ja jb kv jd je jf kw jh ji jj kx jl jm jn hb bi translated">再次调用该函数时清除超时。</p><figure class="lr ls lt lu fd ij"><div class="bz dy l di"><div class="lv lw l"/></div></figure><p id="7149" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在这里，您可以看到我们正在清除超时。但是你会看到我们在 useEffect 的返回函数中清除它，而不是在 useEffect 块中。这是因为从 useEffect 返回的函数在下一次 useEffect 运行之前运行，这是我们希望在设置新计时器之前清除计时器的功能。在 useEffect 块中写它将清除新的超时，这不是我们想要的。</p><h2 id="dddf" class="ld jw hi bd jx le lf lg kb lh li lj kf jb lk ll kj jf lm ln kn jj lo lp kr lq bi translated">第四步</h2><p id="2a22" class="pw-post-body-paragraph iq ir hi is b it kt iv iw ix ku iz ja jb kv jd je jf kw jh ji jj kx jl jm jn hb bi translated">在任何你想的地方使用钩子。</p><figure class="lr ls lt lu fd ij"><div class="bz dy l di"><div class="lv lw l"/></div></figure><h2 id="f843" class="ld jw hi bd jx le lf lg kb lh li lj kf jb lk ll kj jf lm ln kn jj lo lp kr lq bi translated">完全解</h2><figure class="lr ls lt lu fd ij"><div class="bz dy l di"><div class="lv lw l"/></div></figure><figure class="lr ls lt lu fd ij"><div class="bz dy l di"><div class="lx lw l"/></div></figure><p id="f101" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">正如您所看到的性能优势。写 Tommie 不会触发对 Tommie 的每个字母的 API 调用，这将是 6 次。它只在单词 Tommie 完成时调用，这为我们节省了五次 API 调用。</p></div></div>    
</body>
</html>