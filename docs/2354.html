<html>
<head>
<title>LeetCode Container With Most Water</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">盛水最多的LeetCode容器</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/leetcode-container-with-most-water-ae97eafd016b?source=collection_archive---------21-----------------------#2021-05-02">https://medium.com/nerd-for-tech/leetcode-container-with-most-water-ae97eafd016b?source=collection_archive---------21-----------------------#2021-05-02</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><h1 id="0b7f" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">问题陈述</h1><p id="89f7" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">给定<strong class="jf hj"> N </strong>个非负整数<strong class="jf hj"> a1，a2，…，an </strong>，其中每个代表坐标<strong class="jf hj"> (i，ai) </strong>上的一个点。<strong class="jf hj">画N条</strong>垂直线，使得线<strong class="jf hj"> i </strong>的两个端点在<strong class="jf hj"> (i，ai) </strong>和<strong class="jf hj"> (i，0) </strong>。找出两条线，它们和x轴一起形成一个容器，这样容器中的水最多。</p><p id="6bdd" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">问题陈述摘自:<a class="ae kg" href="https://leetcode.com/problems/container-with-most-water" rel="noopener ugc nofollow" target="_blank">https://leetcode.com/problems/container-with-most-water</a></p><p id="6846" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated"><strong class="jf hj">例1: </strong></p><figure class="ki kj kk kl fd km er es paragraph-image"><div role="button" tabindex="0" class="kn ko di kp bf kq"><div class="er es kh"><img src="../Images/e9345eac724fb67e47bd43ef091b1dfd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*40XB83Rd1CI172-E.png"/></div></div></figure><pre class="ki kj kk kl fd kt ku kv kw aw kx bi"><span id="55f0" class="ky ig hi ku b fi kz la l lb lc">Input: height = [1, 8, 6, 2, 5, 4, 8, 3, 7]<br/>Output: 49</span></pre><p id="81c9" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated"><strong class="jf hj">例2: </strong></p><pre class="ki kj kk kl fd kt ku kv kw aw kx bi"><span id="9af1" class="ky ig hi ku b fi kz la l lb lc">Input: height = [1, 1] <br/>Output: 1</span></pre><p id="3705" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">例3: </p><pre class="ki kj kk kl fd kt ku kv kw aw kx bi"><span id="916e" class="ky ig hi ku b fi kz la l lb lc">Input: height = [4, 3, 2, 1, 4] <br/>Output: 16</span></pre><p id="37d3" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated"><strong class="jf hj">例4: </strong></p><pre class="ki kj kk kl fd kt ku kv kw aw kx bi"><span id="bac1" class="ky ig hi ku b fi kz la l lb lc">Input: height = [1, 2, 1] <br/>Output: 2</span></pre><p id="d20e" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated"><strong class="jf hj">约束:</strong></p><pre class="ki kj kk kl fd kt ku kv kw aw kx bi"><span id="b2e6" class="ky ig hi ku b fi kz la l lb lc">- N == height.length <br/>- 2 &lt;= N &lt;= 10^5 <br/>- 0 &lt;= height[i] &lt;= 10^4</span></pre><h1 id="2c2c" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">说明</h1><h2 id="431d" class="ky ig hi bd ih ld le lf il lg lh li ip jo lj lk it js ll lm ix jw ln lo jb lp bi translated">强力</h2><p id="2721" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">一种强力方法是考虑每一对可能的线的面积，并找出其中的最大值。</p><p id="b310" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">该方法的C++代码片段如下所示:</p><pre class="ki kj kk kl fd kt ku kv kw aw kx bi"><span id="2fda" class="ky ig hi ku b fi kz la l lb lc">public class Solution {<br/>    public int maxArea(int[] height) {<br/>        int ans = 0;<br/><br/>        for (int i = 0; i &lt; height.length; i++)<br/>            for (int j = i + 1; j &lt; height.length; j++)<br/>                ans = Math.max(ans, Math.min(height[i], height[j]) * (j - i));<br/><br/>        return ans;<br/>    }<br/>}</span></pre><p id="08c3" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">这种方法的时间复杂度是O(N ) ，因为我们运行两个嵌套的for循环并考虑数组的每个子集。</p><h2 id="feb1" class="ky ig hi bd ih ld le lf il lg lh li ip jo lj lk it js ll lm ix jw ln lo jb lp bi translated">双指针</h2><p id="5848" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">通过使用两个指针可以降低时间复杂度。我们知道线越远，获得的面积就越大。但是线之间形成的区域将受到较短线的高度的限制。</p><p id="cc6a" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated"><strong class="jf hj">算法</strong></p><pre class="ki kj kk kl fd kt ku kv kw aw kx bi"><span id="1cdf" class="ky ig hi ku b fi kz la l lb lc">- set left and right pointer to 0 and last index of array height<br/>- set ans = 0. Variable ans holds the max area of our solution<br/><br/>// Iterate array from both ends and<br/>- Loop while left &lt; right<br/>  - get the area between to indices<br/>    - area = min(height[left], height[right])*(right - left)<br/>  - get the maximum of ans and area and update ans<br/>    - ans = max(ans, area)<br/>  - increment left or right based on which of the index value is minimum.<br/>    - if height[left] &lt; height[right]<br/>      - increment left++<br/>    - else<br/>      - increment right++<br/><br/>- return ans</span></pre><p id="7c2d" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated"><strong class="jf hj"> C++解决方案</strong></p><pre class="ki kj kk kl fd kt ku kv kw aw kx bi"><span id="ee65" class="ky ig hi ku b fi kz la l lb lc">class Solution {<br/>public:<br/>    int maxArea(vector&lt;int&gt;&amp; height) {<br/>        int left = 0;<br/>        int right = height.size() - 1;<br/><br/>        int ans = 0;<br/><br/>        while(left &lt; right){<br/>            ans = max(ans, min(height[left], height[right])*(right-left));<br/><br/>            if(height[left] &lt; height[right]){<br/>                left += 1;<br/>            } else {<br/>                right -= 1;<br/>            }<br/>        }<br/><br/>        return ans;<br/>    }<br/>};</span></pre><p id="54e8" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated"><strong class="jf hj"> Golang解决方案</strong></p><pre class="ki kj kk kl fd kt ku kv kw aw kx bi"><span id="d724" class="ky ig hi ku b fi kz la l lb lc">func maxArea(height []int) int {<br/>    left, right := 0, len(height) - 1<br/>    area := 0<br/><br/>    for left &lt; right {<br/>        area = max(area, min(height[left], height[right])*(right - left))<br/><br/>        if height[left] &lt; height[right] {<br/>            left++<br/>        } else {<br/>            right--<br/>        }<br/>    }<br/><br/>    return int(area)<br/>}<br/><br/>func max(a, b int) int{<br/>    if a &gt; b {<br/>        return a<br/>    }<br/>    return b<br/>}<br/><br/>func min(a, b int) int{<br/>    if a &lt; b {<br/>        return a<br/>    }<br/>    return b<br/>}</span></pre><p id="7892" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated"><strong class="jf hj"> JavaScript解决方案</strong></p><pre class="ki kj kk kl fd kt ku kv kw aw kx bi"><span id="974f" class="ky ig hi ku b fi kz la l lb lc">var maxArea = function(height) {<br/>    if (height.length &lt; 2){<br/>        return 0;<br/>    }<br/><br/>    let left = 0;<br/>    let right = height.length - 1;<br/>    let ans = 0;<br/><br/>    while (left &lt; right) {<br/>        ans = Math.max(ans, Math.min(height[left], height[right]) * (right - left) );<br/><br/>        if (height[left] &lt; height[right]){<br/>            left += 1;<br/>        } else {<br/>            right -= 1;<br/>        }<br/>    }<br/><br/>    return ans;<br/>};</span></pre><p id="15f8" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">让我们试运行一下我们的算法，看看解决方案是如何工作的。</p><pre class="ki kj kk kl fd kt ku kv kw aw kx bi"><span id="5b9d" class="ky ig hi ku b fi kz la l lb lc">height = [1, 8, 6, 2, 5, 4, 8, 3, 7]<br/>left = 0<br/>right = height.size() - 1<br/>      = 9<br/>ans = 0<br/><br/>Step 1: left &lt; right<br/>        0 &lt; 8<br/>        true<br/><br/>        ans = max(ans, min(height[left], height[right])*(right-left));<br/>            = max(0, min(1, 7)*(8-0))<br/>            = max(0, 1*8)<br/>            = max(0, 8)<br/>            = 8<br/><br/>        height[left] &lt; height[right]<br/>        1 &lt; 7<br/>        true<br/>        left++ = 1<br/><br/>Step 2: left &lt; right<br/>        1 &lt; 8<br/>        true<br/><br/>        ans = max(ans, min(height[left], height[right])*(right-left));<br/>            = max(8, min(8, 7)*(8-1))<br/>            = max(8, 7*7)<br/>            = max(8, 49)<br/>            = 49<br/><br/>        height[left] &lt; height[right]<br/>        8 &lt; 7<br/>        false<br/>        right-- = 7<br/><br/>Step 3: left &lt; right<br/>        1 &lt; 7<br/>        true<br/><br/>        ans = max(ans, min(height[left], height[right])*(right-left));<br/>            = max(49, min(8, 3)*(7-1))<br/>            = max(49, 3*6)<br/>            = max(49, 18)<br/>            = 49<br/><br/>        height[left] &lt; height[right]<br/>        8 &lt; 3<br/>        false<br/>        right-- = 6<br/><br/>Step 4: left &lt; right<br/>        1 &lt; 6<br/>        true<br/><br/>        ans = max(ans, min(height[left], height[right])*(right-left));<br/>            = max(49, min(8, 8)*(6-1))<br/>            = max(49, 8*5)<br/>            = max(49, 40)<br/>            = 49<br/><br/>        height[left] &lt; height[right]<br/>        8 &lt; 8<br/>        false<br/>        right-- = 5<br/><br/>Step 5: left &lt; right<br/>        1 &lt; 5<br/>        true<br/><br/>        ans = max(ans, min(height[left], height[right])*(right-left));<br/>            = max(49, min(8, 4)*(5-1))<br/>            = max(49, 4*4)<br/>            = max(49, 16)<br/>            = 49<br/><br/>        height[left] &lt; height[right]<br/>        8 &lt; 4<br/>        false<br/>        right-- = 4<br/><br/>Step 6: left &lt; right<br/>        1 &lt; 4<br/>        true<br/><br/>        ans = max(ans, min(height[left], height[right])*(right-left));<br/>            = max(49, min(8, 5)*(4-1))<br/>            = max(49, 5*3)<br/>            = max(49, 15)<br/>            = 49<br/><br/>        height[left] &lt; height[right]<br/>        8 &lt; 5<br/>        false<br/>        right-- = 3<br/><br/>Step 7: left &lt; right<br/>        1 &lt; 3<br/>        true<br/><br/>        ans = max(ans, min(height[left], height[right])*(right-left));<br/>            = max(49, min(8, 2)*(3-1))<br/>            = max(49, 2*2)<br/>            = max(49, 4)<br/>            = 49<br/><br/>        height[left] &lt; height[right]<br/>        8 &lt; 2<br/>        false<br/>        right-- = 2<br/><br/>Step 8: left &lt; right<br/>        1 &lt; 2<br/>        true<br/><br/>        ans = max(ans, min(height[left], height[right])*(right-left));<br/>            = max(49, min(8, 6)*(2-1))<br/>            = max(49, 6*1)<br/>            = max(49, 6)<br/>            = 49<br/><br/>        height[left] &lt; height[right]<br/>        8 &lt; 6<br/>        false<br/>        right-- = 1<br/><br/>Step 9: left &lt; right<br/>        1 &lt; 1<br/>        false<br/><br/>return ans as 49</span></pre></div><div class="ab cl lq lr gp ls" role="separator"><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv"/></div><div class="hb hc hd he hf"><p id="68d3" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated"><em class="lx">原载于</em><a class="ae kg" href="https://alkeshghorpade.me/post/leetcode-container-with-most-water" rel="noopener ugc nofollow" target="_blank"><em class="lx">https://alkeshghorpade . me</em></a><em class="lx">。</em></p></div></div>    
</body>
</html>