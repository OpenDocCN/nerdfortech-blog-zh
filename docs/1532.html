<html>
<head>
<title>Graph Traversal in Python: Breadth First Search (BFS)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python中的图遍历:广度优先搜索(BFS)</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/graph-traversal-in-python-breadth-first-search-bfs-b6cff138d516?source=collection_archive---------6-----------------------#2021-03-24">https://medium.com/nerd-for-tech/graph-traversal-in-python-breadth-first-search-bfs-b6cff138d516?source=collection_archive---------6-----------------------#2021-03-24</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="62e0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">广度优先搜索(BFS)，也称为广度优先遍历(BFT)，是最基本的图遍历算法之一。这些算法广泛应用于物流配送路径选择、地图路径选择、迷宫路径寻找等领域。</p><p id="570c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">所谓的“广度”如下图所示:你首先扫描B和C，而不是B-&gt;D或B-&gt;E或B-&gt;F或C-&gt;F。在你完成图表的“浅层”之前，你不能进一步深入到其他顶点。(如果您先深入，这将是深度优先搜索)</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es jd"><img src="../Images/5d97c17e67b1f5d298f170e6bce4c3b8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UC-huE6mxE2YTZoZBDK0PQ.png"/></div></div></figure><p id="4ac7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">具体来说，B和C是a的直接子节点。BFS扫描起始节点的所有直接子节点，并进一步到达子节点的子子节点。如下图所示:</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es jp"><img src="../Images/93773a970c96a99cd038d25fcd6b9ead.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fNRe9PPcu3GirDZad1bImQ.png"/></div></div></figure><p id="37be" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">理解了这一点，下一步就是用代码实现它。</p><p id="09ae" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在的关键任务是确保扫描所有子节点，然后继续前进。这项任务是由一种称为“队列”的数据结构来完成的，它具有“先入先出”原则的特性，如下所示:</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es jq"><img src="../Images/e5fe622942fb1a928d001b129ad1b13f.png" data-original-src="https://miro.medium.com/v2/resize:fit:940/format:webp/1*AYnoWAoMRF01jEfatEcc_Q.png"/></div></figure><p id="5768" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">“队列”结构可以确保你扫描的所有节点都按照先来先服务的顺序排列出来。您可以安全地使用一个循环来扫描整个图，并将这些返回的节点推到队列中。</p><p id="c259" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在让我们看一个“dictionary”形式的图表示例，这样您就可以使用graph['A']来检索包含' B '和' C '的列表。在此尝试一下:</p><pre class="je jf jg jh fd jr js jt ju aw jv bi"><span id="9119" class="jw jx hi js b fi jy jz l ka kb">graph={<br/> ‘A’:[‘B’,’C’],<br/> ‘B’:[‘D’,’E’],<br/> ‘C’:[‘F’],<br/> ‘D’:[],<br/> ‘E’:[‘F’],<br/> ‘F’:[]<br/>}</span><span id="6b1c" class="jw jx hi js b fi kc jz l ka kb">graph[‘A’]<br/># this should gives you ['B','C']</span></pre><p id="bc79" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">上面的python代码表示如下图所示:</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es kd"><img src="../Images/c09bff380c29ea4d90624794f4f67ded.png" data-original-src="https://miro.medium.com/v2/resize:fit:694/format:webp/1*Alxy0bGB9TTI1qTzdzr0uA.png"/></div></figure><p id="5602" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">下面是Python中的BFS实现。队列是一个普通的列表，但是我们将使用。append()和。pop(0)方法将其模拟为一个“队列”结构。更具体地说。append()将元素添加到列表的右侧，并将。pop(0)方法取出列表左边的第一个元素。</p><pre class="je jf jg jh fd jr js jt ju aw jv bi"><span id="55e3" class="jw jx hi js b fi jy jz l ka kb">def bfs(graph,node):</span><span id="d78f" class="jw jx hi js b fi kc jz l ka kb">    # node is the starting position<br/>    # graph is the graph in dictionary format<br/>    visited=[]<br/>    queue=[]</span><span id="bf48" class="jw jx hi js b fi kc jz l ka kb">    visited.append(node)<br/>    queue.append(node)<br/>    <br/>    while queue:<br/>        s=queue.pop(0)<br/>        <br/>        for x in graph[s]:<br/>            if x not in visited:<br/>                visited.append(x)<br/>                queue.append(x)<br/>    return visited</span><span id="8d2a" class="jw jx hi js b fi kc jz l ka kb">bfs(graph,'A')<br/># you should get ['A','B','C','D','E','F']</span></pre><p id="0863" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们浏览整个算法，看看它对图做了什么:它接受了一个图和一个节点作为输入。图是字典，节点是字符串。然后，它创建了两个容器:一个名为visited的容器存储扫描序列，另一个名为queue的容器临时存储先进先出的节点序列。</p><p id="9f49" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">输入节点是它处理的第一个节点。比如我们把A放进去。现在队列不为空，while循环开始。“A”立即弹出，并馈入图形[“A”]以检索“B”和“C”。这两个被附加到队列的末尾。由于队列是以“先入先出”的方式弹出的，所以在接下来的while循环中，“D”、“E”、“F”将无法跳到队列的前面。在下一轮while循环中，它确保' B '被弹出，而' D '，' E '被注入队列。在第三轮中，“C”被弹出，“F”被附加到队列中。第四轮“D”弹出，没有从图形返回任何内容。接下来，“E”弹出，“F”再次返回！现在我们在队列中有一个重复的' F ',所以我们需要添加一个检查来防止它加入。</p><p id="df66" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">尝试以下示例来查看代码的效果:</p><pre class="je jf jg jh fd jr js jt ju aw jv bi"><span id="b294" class="jw jx hi js b fi jy jz l ka kb">graph={<br/>    'A':['C','E'],<br/>    'B':[],<br/>    'C':['B','G'],<br/>    'D':[],<br/>    'E':['H'],<br/>    'H':['D'],<br/>    'G':[]<br/>}<br/>bfs(graph,'A')<br/># you should get ['A','C','E','B','G','H','D']</span></pre><p id="9d66" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">上图表示:我们可以很容易地用肉眼验证它的正确性。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es ke"><img src="../Images/f4a6e722b9a31571b4709de9af7f3cf7.png" data-original-src="https://miro.medium.com/v2/resize:fit:656/format:webp/1*PjID3mTEoZ5HuyzKnHde1Q.png"/></div></figure><p id="d8ee" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在接下来的文章中，我们将继续讨论深度优先搜索、Dijkstra搜索和类似方法中的A*搜索。最后，我们将并行比较这些算法，以便更好地理解它们。</p><p id="62bb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">阅读参考链接:</strong></p><div class="kf kg ez fb kh ki"><a href="https://www.geeksforgeeks.org/breadth-first-search-or-bfs-for-a-graph/" rel="noopener  ugc nofollow" target="_blank"><div class="kj ab dw"><div class="kk ab kl cl cj km"><h2 class="bd hj fi z dy kn ea eb ko ed ef hh bi translated">广度优先搜索或BFS图</h2><div class="kp l"><h3 class="bd b fi z dy kn ea eb ko ed ef dx translated">图的广度优先遍历(或搜索)类似于树的广度优先遍历(参见本…</h3></div><div class="kq l"><p class="bd b fp z dy kn ea eb ko ed ef dx translated">www.geeksforgeeks.org</p></div></div><div class="kr l"><div class="ks l kt ku kv kr kw jn ki"/></div></div></a></div><div class="kf kg ez fb kh ki"><a href="https://www.educative.io/edpresso/how-to-implement-a-breadth-first-search-in-python" rel="noopener  ugc nofollow" target="_blank"><div class="kj ab dw"><div class="kk ab kl cl cj km"><h2 class="bd hj fi z dy kn ea eb ko ed ef hh bi translated">如何在Python中实现广度优先搜索</h2><div class="kp l"><h3 class="bd b fi z dy kn ea eb ko ed ef dx translated">如何在Python中实现广度优先搜索</h3></div><div class="kq l"><p class="bd b fp z dy kn ea eb ko ed ef dx translated">如何在Pythonwww.educative.io中实现广度优先搜索</p></div></div><div class="kr l"><div class="kx l kt ku kv kr kw jn ki"/></div></div></a></div></div></div>    
</body>
</html>