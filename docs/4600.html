<html>
<head>
<title>Breaking Up the God Service Using Heroku</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Heroku打破神的服务</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/breaking-up-the-god-service-using-heroku-61e27613538a?source=collection_archive---------11-----------------------#2021-07-28">https://medium.com/nerd-for-tech/breaking-up-the-god-service-using-heroku-61e27613538a?source=collection_archive---------11-----------------------#2021-07-28</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/68443156b3106c3448dde8c0f9a6020d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*J8Ja0ZrwT_9wsnAjvIne0w.jpeg"/></div></div></figure><p id="225d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在过去的十年中，我参与了被我归类为“应用程序现代化计划”的项目这种努力的目标是使用更新的(通常更受支持的)框架、设计模式和语言来替换遗留的应用程序或服务。</p><p id="487a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在每一种情况下，以下三个教训中至少有两个被证明是正确的:</p><ol class=""><li id="ada3" class="jo jp hi is b it iu ix iy jb jq jf jr jj js jn jt ju jv jw bi translated">不要用另一个伪装成现代化服务的整体来代替一个整体。</li><li id="d11e" class="jo jp hi is b it jx ix jy jb jz jf ka jj kb jn jt ju jv jw bi translated">避免接受包含在现代化系统中的不良数据模型。</li><li id="17af" class="jo jp hi is b it jx ix jy jb jz jf ka jj kb jn jt ju jv jw bi translated">永远不要假设现有的程序逻辑是100%正确的。</li></ol><p id="fafa" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这让我想起了我购买一辆几年前的皮卡的时候。我为我的购买感到自豪，这辆卡车开起来很有趣。事实上，我和我父亲谈过想对卡车做些改进。你知道，改变会使它看起来真的很好…甚至增加一个改进的音响系统。</p><p id="bc47" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">父亲饶有兴趣地听我讲述宏伟的计划。当我完成时，他确认我可以做所有这些事情。然而，最后他说我将“仍然有一辆旧卡车。”</p><p id="e55e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">他的观点很明确。我可以花很多钱让卡车看起来更好——但是如果我不更换下面的部件，我仍然会有同样的卡车。这意味着我可能会面临车主和他们的旧车经常遇到的挑战。</p><p id="bf1c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我觉得很多“应用程序现代化”项目很快就做出了保守的决定，最终导致这些“新”解决方案不那么新颖和改进。与我的“旧卡车”示例一样，这些遗留设计决策开始给新应用程序带来挑战只是时间问题。</p><p id="d8f8" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这三个经验教训中的每一个都可以成为单独出版物的主题。在这篇文章中，我将集中讨论如何避免用另一个伪装成现代化应用程序的monolith替换一个遗留的monolith应用程序。</p><h1 id="1ed7" class="kc kd hi bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated">事情偏离轨道的地方</h1><p id="8e17" class="pw-post-body-paragraph iq ir hi is b it la iv iw ix lb iz ja jb lc jd je jf ld jh ji jj le jl jm jn hb bi translated">考虑一个非常简单的商业解决方案，它允许客户提交订单。原始应用程序包含一个带有三个表的数据库:</p><figure class="lg lh li lj fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lf"><img src="../Images/d63d98fab3f59542863228331126ea1b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wZhRpGimCegxvER_2YiZ1Q.png"/></div></div></figure><p id="29cd" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">CUSTOMERS表维护客户信息。表中的ID列链接到ORDERS表，将订单与客户相匹配。客户的ID列也链接到付款表。</p><p id="c30c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">通常，决定将所有内容保存在一个数据库中。这导致创建了一个新的服务，它包括在这些完全相同的表之间交互的组件和服务。</p><p id="5ee0" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">下图旨在展示一个设计，它仅仅是用RESTful API替换了单一的应用程序。这项工作的结果是数据库保持不变。</p><figure class="lg lh li lj fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lk"><img src="../Images/fad074b8ecb3885e6829515e67d3bf0e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0pIpv-TRrm9TaURRSIksdw.png"/></div></div></figure><p id="9612" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">虽然这个想法在理论上听起来不错，但这通常会导致一个新的服务，它与原始系统一样复杂…如果不是更复杂的话。这就是通常所说的上帝服务。</p><p id="8151" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">使问题更加复杂的是，为了满足客户需求而进行的扩展需要所有的API(如上所述)一致地进行扩展。根据底层设计，扩展选项甚至可能仅限于垂直扩展，这将调用“解决问题的硬件”解决方案。</p><p id="b900" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这就是“<em class="ll">不要用伪装成现代化服务的另一个整体来取代另一个整体”的教训得到验证的地方。</em></p><h1 id="3f21" class="kc kd hi bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated">做得更好</h1><p id="f024" class="pw-post-body-paragraph iq ir hi is b it la iv iw ix lb iz ja jb lc jd je jf ld jh ji jj le jl jm jn hb bi translated">使用同一个例子，考虑一下:如果下面的设计用于应用程序现代化计划会怎么样？</p><figure class="lg lh li lj fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lm"><img src="../Images/e00f8514859969e7bf6ab11be1e651ee.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*e7T2BATH5JflxnfleWksag.png"/></div></div></figure><p id="ef19" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在这种设计中，引入了三种新的微服务来容纳应用程序的域所有权。最重要的是，每个微服务及其专用对象都有自己的数据库。</p><p id="13c3" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这些服务之间的连接将利用消息服务，通常采用<a class="ae ln" href="https://en.wikipedia.org/wiki/Request%E2%80%93response" rel="noopener ugc nofollow" target="_blank">请求-响应</a>模式。</p><p id="5aad" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">作为一个例子，考虑下订单的用例。订单使用消息向客户API提供已知的客户数据。客户API将处理请求，或者返回一个现有的<code class="du lo lp lq lr b"> CustomerDto</code> (DTO是一个<a class="ae ln" href="https://en.wikipedia.org/wiki/Data_transfer_object" rel="noopener ugc nofollow" target="_blank">数据传输对象</a>)或者通过对原始请求的响应创建一个新的<code class="du lo lp lq lr b"> CustomerDto</code>。</p><p id="28cc" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">然后，客户的标识符可以与订单和使用支付API进行支付的请求相关联。这里，遵循相同的模式，但是将利用从客户API请求中获得的信息。</p><p id="057d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">当支付API做出响应时，新订单可以保存到相应的数据库中，并由发出请求的客户进行确认。</p><p id="7529" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">由于每个微服务都是独立的，因此满足客户需求的扩展和缩减仅限于当前识别较高(或较低)请求级别的服务。</p><h1 id="c1ba" class="kc kd hi bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated">利用Heroku来逃避上帝的服务</h1><p id="5634" class="pw-post-body-paragraph iq ir hi is b it la iv iw ix lb iz ja jb lc jd je jf ld jh ji jj le jl jm jn hb bi translated">我想看看在Heroku 中创建想要的图案有多容易。几分钟之内，我就能够在Heroku中建立三个应用程序来模拟以下设计:</p><figure class="lg lh li lj fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ls"><img src="../Images/adb05a53ba4308c128568a4c01d2ad2a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*81PM1y0G4EN4OUNIdHXSBg.png"/></div></div></figure><p id="b700" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这三个服务都包含他们自己的<a class="ae ln" href="https://www.heroku.com/postgres" rel="noopener ugc nofollow" target="_blank"> Heroku Postgres </a>数据库和一个<a class="ae ln" href="https://spring.io/projects/spring-boot" rel="noopener ugc nofollow" target="_blank"> Spring Boot </a>服务。为了使这个例子尽可能简单，将<a class="ae ln" href="https://elements.heroku.com/addons/cloudamqp" rel="noopener ugc nofollow" target="_blank"> CloudAMQP </a> (RabbitMQ)服务添加到jvc-order应用程序中。<a class="ae ln" href="https://elements.heroku.com/addons/wso2apicloud" rel="noopener ugc nofollow" target="_blank"> WSO2 API Cloud </a>是设计的一部分，但不会在本文中记录。</p><p id="3697" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在Heroku仪表板上，三个应用程序如下所示:</p><figure class="lg lh li lj fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lt"><img src="../Images/cd85c20bad1c98f0521e4fa0b7cd07ca.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vxreBZ5N478RzJano_b1JA.png"/></div></div></figure><h2 id="61c7" class="lu kd hi bd ke lv lw lx ki ly lz ma km jb mb mc kq jf md me ku jj mf mg ky mh bi translated">创建示例表</h2><p id="2baa" class="pw-post-body-paragraph iq ir hi is b it la iv iw ix lb iz ja jb lc jd je jf ld jh ji jj le jl jm jn hb bi translated">下面的SQL被用来创建基本表。这些可用于验证这些服务的功能:</p><pre class="lg lh li lj fd mi lr mj mk aw ml bi"><span id="a037" class="lu kd hi lr b fi mm mn l mo mp">CREATE TABLE orders (<br/> id INT PRIMARY KEY NOT NULL,<br/> customer_id INT NOT NULL,<br/> payment_id INT NOT NULL,<br/> order_date timestamp NOT NULL,<br/> description VARCHAR(255) <br/>);<br/>​<br/>CREATE TABLE customers (<br/> id INT PRIMARY KEY NOT NULL,<br/> email_address VARCHAR(255) NOT NULL,<br/> name VARCHAR(255),<br/> UNIQUE (email_address)<br/>);<br/>​<br/>CREATE TABLE payments (<br/> id INT PRIMARY KEY NOT NULL,<br/> transaction_id VARCHAR(36) NOT NULL,<br/> amount DECIMAL(12,2),<br/> customer_id INT NOT NULL<br/>);</span></pre><p id="4a26" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">请记住，每个CREATE TABLE命令都是针对与相应微服务相关联的PostgreSQL数据库执行的。</p><h2 id="6c2b" class="lu kd hi bd ke lv lw lx ki ly lz ma km jb mb mc kq jf md me ku jj mf mg ky mh bi translated">处理订单请求</h2><p id="9293" class="pw-post-body-paragraph iq ir hi is b it la iv iw ix lb iz ja jb lc jd je jf ld jh ji jj le jl jm jn hb bi translated">考虑以下OrderRequest负载:</p><pre class="lg lh li lj fd mi lr mj mk aw ml bi"><span id="df9f" class="lu kd hi lr b fi mm mn l mo mp">{<br/> “description” : “Sample Order #4”,<br/> “emailAddress” : “<a class="ae ln" href="mailto:bjohnson@example.com" rel="noopener ugc nofollow" target="_blank">bjohnson@example.com</a>”,<br/> “name” : “Brian Johnson”,<br/> “amount” : 19.99<br/>}</span></pre><p id="cba2" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">正常情况下，一个真正的订单将包含其他几个属性，但是目标是遵循“保持简单”的方法，而是关注设计原则。</p><p id="a69a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">作为订单的一部分，系统需要知道下订单的客户的标识符和请求的交易。</p><h2 id="49c2" class="lu kd hi bd ke lv lw lx ki ly lz ma km jb mb mc kq jf md me ku jj mf mg ky mh bi translated">请求客户</h2><p id="9b3c" class="pw-post-body-paragraph iq ir hi is b it la iv iw ix lb iz ja jb lc jd je jf ld jh ji jj le jl jm jn hb bi translated">为了请求客户信息，可以将以下<code class="du lo lp lq lr b">CustomerDto</code>有效负载放在请求队列中:</p><pre class="lg lh li lj fd mi lr mj mk aw ml bi"><span id="0cae" class="lu kd hi lr b fi mm mn l mo mp">{<br/> “emailAddress” : “<a class="ae ln" href="mailto:bjohnson@example.com" rel="noopener ugc nofollow" target="_blank">bjohnson@example.com</a>”,<br/> “name” : “Brian Johnson”<br/>}</span></pre><p id="9658" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在Order API中，以下方法利用了Heroku的云AMQP、直接交换的概念和Spring Boot的spring-boot-starter-amqp:</p><pre class="lg lh li lj fd mi lr mj mk aw ml bi"><span id="fc86" class="lu kd hi lr b fi mm mn l mo mp">public CustomerDto getCustomer(String emailAddress, String name) {<br/> CustomerDto customerDto = new CustomerDto();<br/> customerDto.setEmailAddress(emailAddress);<br/> customerDto.setName(name);<br/>​<br/> return rabbitTemplate.convertSendAndReceiveAsType(customerDirectExchange.getName(),<br/> messagingConfigurationProperties.getCustomerRoutingKey(),<br/> customerDto,<br/> new ParameterizedTypeReference&lt;&gt;() {});<br/>}</span></pre><p id="1b52" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在本例中，这个请求是一个阻塞请求——这意味着订单API的处理会一直等到客户API提供响应。</p><p id="2ba6" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在客户API中，有一个侦听器正在等待customerDirectExchange上的请求:</p><pre class="lg lh li lj fd mi lr mj mk aw ml bi"><span id="fe56" class="lu kd hi lr b fi mm mn l mo mp"><a class="ae ln" href="http://twitter.com/RabbitListener" rel="noopener ugc nofollow" target="_blank">@RabbitListener</a>(queues = “#{messagingConfigurationProperties.customerRequestQueue}”)<br/><a class="ae ln" href="http://twitter.com/Transactional" rel="noopener ugc nofollow" target="_blank">@Transactional</a>(propagation = Propagation.REQUIRES_NEW)<br/>public CustomerDto receive(CustomerDto customerDto) {<br/> log.debug(“CustomerProcessor: receive(customerDto={})”, customerDto);<br/>​<br/> Customer customer = customerRepository.findByEmailAddressEquals(customerDto.getEmailAddress());<br/>​<br/> if (customer != null) {<br/>   log.debug(“Found existing customer={}”, customer);<br/>   // return customer as a CustomerDto<br/> } else {<br/>   log.info(“Creating new customer={}”, customerDto);<br/>   // return new customer as a CustomerDto<br/> }<br/>​<br/> log.debug(“customerDto={}”, customerDto);<br/> return customerDto;<br/>}<br/></span></pre><p id="3afe" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在此示例中，customerDto对象包含以下信息:</p><pre class="lg lh li lj fd mi lr mj mk aw ml bi"><span id="77aa" class="lu kd hi lr b fi mm mn l mo mp"><a class="ae ln" href="http://twitter.com/AllArgsConstructor" rel="noopener ugc nofollow" target="_blank">@AllArgsConstructor</a><br/><a class="ae ln" href="http://twitter.com/NoArgsConstructor" rel="noopener ugc nofollow" target="_blank">@NoArgsConstructor</a><br/><a class="ae ln" href="http://twitter.com/Data" rel="noopener ugc nofollow" target="_blank">@Data</a><br/>public class CustomerDto {<br/> private int id;<br/> private String emailAddress;<br/> private String Name;<br/>}</span></pre><h2 id="f035" class="lu kd hi bd ke lv lw lx ki ly lz ma km jb mb mc kq jf md me ku jj mf mg ky mh bi translated">请求付款</h2><p id="cf9c" class="pw-post-body-paragraph iq ir hi is b it la iv iw ix lb iz ja jb lc jd je jf ld jh ji jj le jl jm jn hb bi translated">通过利用<code class="du lo lp lq lr b">PaymentDto</code>，可以使用相同的模式来请求付款:</p><pre class="lg lh li lj fd mi lr mj mk aw ml bi"><span id="e3e4" class="lu kd hi lr b fi mm mn l mo mp"><a class="ae ln" href="http://twitter.com/AllArgsConstructor" rel="noopener ugc nofollow" target="_blank">@AllArgsConstructor</a><br/><a class="ae ln" href="http://twitter.com/NoArgsConstructor" rel="noopener ugc nofollow" target="_blank">@NoArgsConstructor</a><br/><a class="ae ln" href="http://twitter.com/Data" rel="noopener ugc nofollow" target="_blank">@Data</a><br/>public class PaymentDto {<br/> private int id;<br/> private String transactionId;<br/> private BigDecimal amount;<br/> private int customerId;<br/>}</span></pre><p id="d26f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">customerId属性是请求/响应模式的结果。当然，在付款API完成处理之前，不会设置id属性，付款API使用另一个非常简单的付款示例:</p><pre class="lg lh li lj fd mi lr mj mk aw ml bi"><span id="0af6" class="lu kd hi lr b fi mm mn l mo mp"><a class="ae ln" href="http://twitter.com/RabbitListener" rel="noopener ugc nofollow" target="_blank">@RabbitListener</a>(queues = “#{messagingConfigurationProperties.paymentRequestQueue}”)<br/><a class="ae ln" href="http://twitter.com/Transactional" rel="noopener ugc nofollow" target="_blank">@Transactional</a>(propagation = Propagation.REQUIRES_NEW)<br/>public PaymentDto receive(PaymentDto paymentDto) {<br/> log.debug(“PaymentProcessor: receive(paymentDto={})”, paymentDto);<br/>​<br/> Payment payment = new Payment();<br/> payment.setAmount(paymentDto.getAmount());<br/> payment.setCustomerId(paymentDto.getCustomerId());<br/> payment.setTransactionId(UUID.randomUUID().toString());<br/> paymentRepository.save(payment);<br/> paymentDto.setId(payment.getId());<br/> paymentDto.setTransactionId(payment.getTransactionId());<br/> return paymentDto;<br/>}</span></pre><h2 id="e1f6" class="lu kd hi bd ke lv lw lx ki ly lz ma km jb mb mc kq jf md me ku jj mf mg ky mh bi translated">提交订单并完成交易</h2><p id="a1ec" class="pw-post-body-paragraph iq ir hi is b it la iv iw ix lb iz ja jb lc jd je jf ld jh ji jj le jl jm jn hb bi translated">完成交易后，可以使用Postman客户端甚至一个简单的cURL命令来完成下订单的过程:</p><pre class="lg lh li lj fd mi lr mj mk aw ml bi"><span id="4f92" class="lu kd hi lr b fi mm mn l mo mp">curl — location — request POST ‘<a class="ae ln" href="https://jvc-order.herokuapp.com/orders'" rel="noopener ugc nofollow" target="_blank">https://jvc-order.herokuapp.com/orders'</a> \<br/> — header ‘Content-Type: application/json’ \<br/> — data-raw ‘{<br/> “description” : “Sample Order #4”,<br/> “emailAddress” : “<a class="ae ln" href="mailto:bjohnson@example.com" rel="noopener ugc nofollow" target="_blank">bjohnson@example.com</a>”,<br/> “name” : “Brian Johnson”,<br/> “amount” : 19.99<br/>}’</span></pre><p id="1a67" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">订单API将接受POST请求，并返回HTTP 201(已创建)状态以及以下有效负载:</p><pre class="lg lh li lj fd mi lr mj mk aw ml bi"><span id="0bb5" class="lu kd hi lr b fi mm mn l mo mp">{<br/> “id”: 4,<br/> “customerId”: 4,<br/> “paymentId”: 4,<br/> “orderDate”: “2021–06–07T04:31:52.497082”,<br/> “description”: “Sample Order #4”<br/>}</span></pre><p id="0c10" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">三个微服务中的每一个都有标准的RESTful APIs，允许检索完整的有效负载数据结果。</p><p id="10f9" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">下面是调用客户API的示例:</p><pre class="lg lh li lj fd mi lr mj mk aw ml bi"><span id="1b9d" class="lu kd hi lr b fi mm mn l mo mp">GET <a class="ae ln" href="https://jvc-customer.herokuapp.com/customers/4`" rel="noopener ugc nofollow" target="_blank">https://jvc-customer.herokuapp.com/customers/4</a></span></pre><p id="fef3" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这将返回以下有效负载和HTTP 200 (OK)状态:</p><pre class="lg lh li lj fd mi lr mj mk aw ml bi"><span id="fb13" class="lu kd hi lr b fi mm mn l mo mp">{<br/> “id”: 4,<br/> “emailAddress”: “<a class="ae ln" href="mailto:bjohnson@example.com" rel="noopener ugc nofollow" target="_blank">bjohnson@example.com</a>”,<br/> “name”: “Brian Johnson”<br/>}</span></pre><p id="df23" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">以下是调用付款API的示例:</p><pre class="lg lh li lj fd mi lr mj mk aw ml bi"><span id="99c0" class="lu kd hi lr b fi mm mn l mo mp">GET <a class="ae ln" href="https://jvc-payment.herokuapp.com/payments/4`" rel="noopener ugc nofollow" target="_blank">https://jvc-payment.herokuapp.com/payments/4</a></span></pre><p id="1d23" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这还会返回HTTP 200 (OK)状态和以下有效负载:</p><pre class="lg lh li lj fd mi lr mj mk aw ml bi"><span id="0036" class="lu kd hi lr b fi mm mn l mo mp">{<br/> “id”: 4,<br/> “transactionId”: “3fcb379e-cb89–4013-a141-c6fad4b55f6b”,<br/> “amount”: 19.99,<br/> “customerId”: 4<br/>}</span></pre><p id="e8a8" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">最后，调用订单API的示例如下所示:</p><pre class="lg lh li lj fd mi lr mj mk aw ml bi"><span id="b841" class="lu kd hi lr b fi mm mn l mo mp">GET <a class="ae ln" href="https://jvc-order.herokuapp.com/orders/4`" rel="noopener ugc nofollow" target="_blank">https://jvc-order.herokuapp.com/orders/4</a></span></pre><p id="95c0" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这里返回一个HTTP 200 (OK)状态，并带有以下有效负载:</p><pre class="lg lh li lj fd mi lr mj mk aw ml bi"><span id="26b6" class="lu kd hi lr b fi mm mn l mo mp">{<br/> “id”: 4,<br/> “customerId”: 4,<br/> “paymentId”: 4,<br/> “orderDate”: “2021–06–07T04:31:52.497082”,<br/> “description”: “Sample Order #4”<br/>}</span></pre><h1 id="7d07" class="kc kd hi bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated">结论</h1><p id="7d8c" class="pw-post-body-paragraph iq ir hi is b it la iv iw ix lb iz ja jb lc jd je jf ld jh ji jj le jl jm jn hb bi translated">从2021年开始，我开始关注以下我认为适用于任何IT专业人士的使命宣言:</p><blockquote class="mq mr ms"><p id="f58b" class="iq ir ll is b it iu iv iw ix iy iz ja mt jc jd je mu jg jh ji mv jk jl jm jn hb bi translated">“将您的时间集中在提供扩展您知识产权价值的特性/功能上。将框架、产品和服务用于其他一切。”<br/>—j·维斯特</p></blockquote><p id="925b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">Heroku生态系统使得坚持使命宣言变得非常容易。在几个小时的时间里，我完全构建出了三个包含Spring Boot RESTful API和Heroku Postgres数据库的微服务原型。在同样长的时间内，云AMQP被添加、集成到解决方案中并得到验证。</p><p id="a7d6" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如果我使用标准的云服务提供商，我无法想象这需要多长时间。附加PostgreSQL数据库和基于云的AMQP实例的能力，加上处理权限，将会消耗掉我所有的可用时间——让我没有时间来证明这个功能。</p><p id="7006" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如果您有兴趣查看该项目的实际源代码，请查看GitLab上的以下资源库:</p><p id="1cb8" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><a class="ae ln" href="https://gitlab.com/johnjvester/jvc-customer" rel="noopener ugc nofollow" target="_blank">JVC-客户</a></p><p id="6763" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><a class="ae ln" href="https://gitlab.com/johnjvester/jvc-order" rel="noopener ugc nofollow" target="_blank"> jvc订单</a></p><p id="2ee4" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><a class="ae ln" href="https://gitlab.com/johnjvester/jvc-payment" rel="noopener ugc nofollow" target="_blank">JVC-支付</a></p><p id="10c9" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">祝你今天过得愉快！</p></div></div>    
</body>
</html>