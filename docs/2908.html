<html>
<head>
<title>Understanding the Factory Method Design Pattern ✨😎</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">理解工厂方法设计模式✨😎</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/understanding-the-factory-method-design-pattern-b5cac235cc37?source=collection_archive---------18-----------------------#2021-05-23">https://medium.com/nerd-for-tech/understanding-the-factory-method-design-pattern-b5cac235cc37?source=collection_archive---------18-----------------------#2021-05-23</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/f06e5030cc4884598384fe404b5a55e0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*8G1izpFvfoiQJrgadTGWUQ.gif"/></div></div></figure><p id="1d3c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">✷工厂法设计模式属于创造性设计模式。</p><blockquote class="jo jp jq"><p id="9fd7" class="iq ir jr is b it iu iv iw ix iy iz ja js jc jd je jt jg jh ji ju jk jl jm jn hb bi translated">工厂方法设计模式通过让子类决定创建什么对象来封装对象的创建。</p></blockquote><figure class="jw jx jy jz fd ij er es paragraph-image"><div class="er es jv"><img src="../Images/d9a4486e428d8af6784fd92d130e63de.png" data-original-src="https://miro.medium.com/v2/resize:fit:1282/format:webp/1*2XJ5kMj2_VFErZeuyL_X9Q.png"/></div></figure><figure class="jw jx jy jz fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ka"><img src="../Images/2a67c2c36c0f5c95e985c51ae19d0fea.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FJLopsQUiMZUJYqzQKOw0A.png"/></div></div></figure><h1 id="9d84" class="kb kc hi bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated">♨️ <strong class="ak">让我们比较一下工厂方法设计模式和单体设计模式。</strong></h1><p id="b863" class="pw-post-body-paragraph iq ir hi is b it kz iv iw ix la iz ja jb lb jd je jf lc jh ji jj ld jl jm jn hb bi translated">✵在单例设计模式中，我们不使用参数来创建实例。但是当涉及到工厂方法模式时，我们总是使用参数来决定您需要获得哪个实例。(有时也可以有不带参数的默认构造函数)</p><p id="1a03" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">✵在单例设计模式中，你总是知道你想要得到的实例的类型。但是当谈到工厂方法设计模式时，可能你不知道或者你不知道你将得到什么样的实例。(因为这是由你的输入决定的)有时你会得到一些子实例而不是父实例。</p><p id="c4a6" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">✵不像在 Singleton 的设计模式中，我们在工厂方法设计模式中看不到实例化的逻辑，你总是只能看到你得到的。</p><p id="266e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">✵在工厂方法设计模式中，更高的类可以指接口和其他具体的类。但是作为用户，你不会知道它还被其他什么父类继承或实现。</p><p id="679c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">✵其实，工厂方法设计模式用在一个更高层次的框架中。然后是较低的级别，最终用户或开发人员是调用它的人。</p><p id="52e2" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">✵在单例设计模式中，通常我们不创建接口。但是与工厂方法设计模式相比，您可以使用接口。</p><h2 id="bc01" class="le kc hi bd kd lf lg lh kh li lj lk kl jb ll lm kp jf ln lo kt jj lp lq kx lr bi translated">请看下面🕵的例子🏼</h2><figure class="jw jx jy jz fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ls"><img src="../Images/feea84eae30f4c31b7638bd8e0655054.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*__lI95QG_vPlPhfJfoa5Dg.png"/></div></div></figure><p id="3b1b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在上图中突出显示的部分，您可以看到 getInstance、getNumberInstance、getCurrencyInstance 等等。您可以向构造函数传递一些参数来确定您需要返回哪个实例。</p><p id="4176" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">让我们通过下面的场景来理解工厂方法设计模式。</p><h1 id="2543" class="kb kc hi bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated">💥场景 1:</h1><blockquote class="jo jp jq"><p id="b848" class="iq ir jr is b it iu iv iw ix iy iz ja js jc jd je jt jg jh ji ju jk jl jm jn hb bi translated">假设您需要为花店实现一个系统或用例。这家花店应该有包装。根据您传递的参数，您需要创建一个工厂方法模式来返回所需的包。</p></blockquote><p id="3f97" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">下面是上述场景的 UML 图。</p><figure class="jw jx jy jz fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lt"><img src="../Images/c776565ef40fa31cf090e0d272526aea.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Jmo77xOR529qG5kknw8w1Q.png"/></div></div></figure><p id="6609" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">你有一个装饰类，它是一个抽象类，如下图所示。</p><figure class="jw jx jy jz fd ij"><div class="bz dy l di"><div class="lu lv l"/></div></figure><p id="101c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">从装饰来看，你有不同种类的装饰。例如，BridalDeco 是一种装饰，BridalDeco 类扩展了装饰类。(如下图所示)</p><figure class="jw jx jy jz fd ij"><div class="bz dy l di"><div class="lu lv l"/></div></figure><p id="506c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">像这样，你会有 ParentDeco 类和伴娘 Deco 类，它们扩展了 Decoration 类。</p><p id="0bea" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">所以现在你需要一个名为 package 的类来添加这些装饰。这里的包装是装饰品的集合。</p><figure class="jw jx jy jz fd ij"><div class="bz dy l di"><div class="lu lv l"/></div></figure><p id="75a1" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">所以下面是“PackageFactory”类的代码片段。工厂是我们创建真正的包的地方。</p><figure class="jw jx jy jz fd ij"><div class="bz dy l di"><div class="lu lv l"/></div></figure><p id="100b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">所以在这里，Factory 所做的是，根据传入的参数，切换它返回的实例。</p><p id="0275" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">主要类别:</p><figure class="jw jx jy jz fd ij"><div class="bz dy l di"><div class="lu lv l"/></div></figure><p id="b94b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">输出:</p><pre class="jw jx jy jz fd lw lx ly lz aw ma bi"><span id="ec71" class="le kc hi lx b fi mb mc l md me"><strong class="lx hj">Package{decorations=[BridalDeco, BridesmaidDeco]}</strong></span><span id="3dc4" class="le kc hi lx b fi mf mc l md me"><strong class="lx hj">Package{decorations=[BridalDeco, BridesmaidDeco, FlowergirlDeco, ParentDeco]}</strong></span></pre><p id="f240" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">因此，我们可以看到，工厂方法设计模式总是根据它得到的参数返回多个实例。</p><h1 id="0e6b" class="kb kc hi bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated">何时使用这种工厂方法模式？</h1><p id="99c3" class="pw-post-body-paragraph iq ir hi is b it kz iv iw ix la iz ja jb lb jd je jf lc jh ji jj ld jl jm jn hb bi translated">✹当我们有许多实现一个公共协议的类时，我们可以使用这个工厂方法设计模式。(比如，从同一个基类派生的。)</p><p id="5a69" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">✹还有，当你事先真的不知道你的代码应该处理的对象的类型和依赖关系时，可以使用工厂方法设计模式。</p><h1 id="c9ac" class="kb kc hi bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated">💥场景 2:</h1><blockquote class="jo jp jq"><p id="068a" class="iq ir jr is b it iu iv iw ix iy iz ja js jc jd je jt jg jh ji ju jk jl jm jn hb bi translated">有一种叫做“微笑食品”的在线食品订购系统。该系统包含一些产品，如<strong class="is hj">、【蔬菜产品】、</strong>、<strong class="is hj">、【混合产品】。</strong>这些产品下面都有米饭和一些菜肴(点餐时)。所以当顾客输入他想要的产品时，系统应该在每个产品里面生成想要的东西。</p><p id="badc" class="iq ir jr is b it iu iv iw ix iy iz ja js jc jd je jt jg jh ji ju jk jl jm jn hb bi translated">这里，</p><p id="16f0" class="iq ir jr is b it iu iv iw ix iy iz ja js jc jd je jt jg jh ji ju jk jl jm jn hb bi translated"><strong class="is hj"> <em class="hi"> VegProduct 包含:NormalRice </em> </strong></p><p id="2c81" class="iq ir jr is b it iu iv iw ix iy iz ja js jc jd je jt jg jh ji ju jk jl jm jn hb bi translated"><strong class="is hj"> <em class="hi">鸡肉产品包含:鸡肉</em> </strong></p><p id="6295" class="iq ir jr is b it iu iv iw ix iy iz ja js jc jd je jt jg jh ji ju jk jl jm jn hb bi translated"><strong class="is hj"> <em class="hi"> MixProduct 包含:鸡饭、蛋饭、脆皮菜</em> </strong></p></blockquote><p id="bcbc" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><em class="jr">让我们看看为上面的场景</em> ☛绘制的 UML 图</p><p id="0a42" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">(这里的“食物”是一个抽象类。“CrispyDish”类、“ChickenRice”类、“EggRice”类、“VegDish”类和“NormalRice”类扩展了“Food”类。此外，“VegProduct”类、“ChickenProduct”类和“MixPrdoduct”类扩展了“Package”类。)</p><figure class="jw jx jy jz fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mg"><img src="../Images/8ad5ad88ac57aec6dc3a811f77ff7236.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CkqWYPGBwdM_y4ChK7TpMg.png"/></div></div></figure><p id="5b96" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">所以首先我们必须创建一个抽象类叫做 Food，如下图所示，然后子类可以扩展 Food 类。</p><figure class="jw jx jy jz fd ij"><div class="bz dy l di"><div class="lu lv l"/></div></figure><p id="c5da" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如下所示，您可以扩展“CrispyChicken”类、“ChickenRice”类、“EggRice”类、“VegDish”类和“NormalRice”类。</p><figure class="jw jx jy jz fd ij"><div class="bz dy l di"><div class="lu lv l"/></div></figure><p id="7cfa" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">然后，我们应该创建如下所示的包类，这样我们就可以通过其他产品类来扩展这个类。</p><figure class="jw jx jy jz fd ij"><div class="bz dy l di"><div class="lu lv l"/></div></figure><p id="78af" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">下面是通过子类扩展产品类的方法。(在下面的代码示例中，我只提到了一个类。)</p><figure class="jw jx jy jz fd ij"><div class="bz dy l di"><div class="lu lv l"/></div></figure><p id="f474" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">因此，我们必须创建工厂类(如下所示)。所以工厂所做的依赖于进来的参数，它切换它返回的实例。</p><figure class="jw jx jy jz fd ij"><div class="bz dy l di"><div class="lu lv l"/></div></figure><p id="3f79" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">最后，下面是该应用的主要方法:</p><figure class="jw jx jy jz fd ij"><div class="bz dy l di"><div class="lu lv l"/></div></figure><p id="6df8" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">上述场景的输出:</p><figure class="jw jx jy jz fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mh"><img src="../Images/1eaf05be1b98278627363932a4ff4c93.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TGfImIki4AkyqiTg177lxg.png"/></div></div></figure><p id="40ae" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">请点击下面的 Github 链接查看上述 scenario➜的完整源代码(java)</p><div class="mi mj ez fb mk ml"><a href="https://github.com/Irushinie/Krish-LP-Training/tree/main/FactoryMethodDesignPattern" rel="noopener  ugc nofollow" target="_blank"><div class="mm ab dw"><div class="mn ab mo cl cj mp"><h2 class="bd hj fi z dy mq ea eb mr ed ef hh bi translated">irushinie/Krish-LP-培训</h2><div class="ms l"><h3 class="bd b fi z dy mq ea eb mr ed ef dx translated">在 GitHub 上创建一个帐户，为 Irushinie/Krish-LP-Training 的发展做出贡献。</h3></div><div class="mt l"><p class="bd b fp z dy mq ea eb mr ed ef dx translated">github.com</p></div></div><div class="mu l"><div class="mv l mw mx my mu mz io ml"/></div></div></a></div><h1 id="3504" class="kb kc hi bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated">➖工厂法的优缺点 Pattern➖</h1><blockquote class="jo jp jq"><p id="e91b" class="iq ir jr is b it iu iv iw ix iy iz ja js jc jd je jt jg jh ji ju jk jl jm jn hb bi translated"><strong class="is hj"> <em class="hi">工厂法的优点:</em> </strong></p></blockquote><p id="d1df" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">✹当使用工厂方法模式时，我们可以创建对象而不向用户显示实例化的逻辑。</p><p id="85d7" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">✹工厂方法模式允许子类选择要创建的对象种类。</p><p id="5507" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">✹松耦合，易于扩展。</p><p id="3759" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">✹工厂方法设计模式易于使用。</p><blockquote class="jo jp jq"><p id="2e19" class="iq ir jr is b it iu iv iw ix iy iz ja js jc jd je jt jg jh ji ju jk jl jm jn hb bi translated"><strong class="is hj"> <em class="hi">工厂法的缺点:</em> </strong></p></blockquote><p id="1c45" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">✹它使得代码更难阅读。</p></div><div class="ab cl na nb gp nc" role="separator"><span class="nd bw bk ne nf ng"/><span class="nd bw bk ne nf ng"/><span class="nd bw bk ne nf"/></div><div class="hb hc hd he hf"><h1 id="ccea" class="kb kc hi bd kd ke nh kg kh ki ni kk kl km nj ko kp kq nk ks kt ku nl kw kx ky bi translated">参考</h1><figure class="jw jx jy jz fd ij"><div class="bz dy l di"><div class="nm lv l"/></div></figure><p id="a4ba" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">工厂方法设计模式—Java point”、<a class="ae nn" href="http://www.javatpoint.com," rel="noopener ugc nofollow" target="_blank">T5、、</a> 2021。【在线】。可用:<a class="ae nn" href="https://www.javatpoint.com/factory-method-design-pattern." rel="noopener ugc nofollow" target="_blank">https://www.javatpoint.com/factory-method-design-pattern.</a></p><p id="b59e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">设计模式与重构”，<em class="jr">Sourcemaking.com</em>，2021。【在线】。可用:<a class="ae nn" href="https://sourcemaking.com/design_patterns/factory_method." rel="noopener ugc nofollow" target="_blank">https://sourcemaking.com/design_patterns/factory_method.</a></p><p id="584a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">设计模式—工厂模式—教程要点”，<em class="jr">Tutorialspoint.com</em>，2021。【在线】。可用:<a class="ae nn" href="https://www.tutorialspoint.com/design_pattern/factory_pattern.htm." rel="noopener ugc nofollow" target="_blank">https://www . tutorialspoint . com/design _ pattern/factory _ pattern . htm</a></p><p id="6ff9" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">D.模式，《设计模式——工厂设计模式的优缺点》，<em class="jr">Buggybread.com</em>，2021。【在线】。可用:<a class="ae nn" href="https://www.buggybread.com/2016/12/design-pattern-advantages-and.html." rel="noopener ugc nofollow" target="_blank">https://www . buggy bread . com/2016/12/design-pattern-advantages-and . html .</a></p></div></div>    
</body>
</html>