<html>
<head>
<title>LeetCode — Maximum Product Subarray</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">LeetCode —最大乘积子阵列</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/leetcode-maximum-product-subarray-44c169d05c2b?source=collection_archive---------5-----------------------#2022-02-06">https://medium.com/nerd-for-tech/leetcode-maximum-product-subarray-44c169d05c2b?source=collection_archive---------5-----------------------#2022-02-06</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><h1 id="b0a0" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">问题陈述</h1><p id="7ff1" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">给定一个整数数组<em class="kb"> nums </em>，在数组中找到一个具有最大乘积的连续非空子数组，并将乘积返回给<em class="kb">。</em></p><p id="49b1" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated">测试用例的生成是为了让答案符合一个 32 位的<strong class="jf hj">整数。</strong></p><p id="3829" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated">一个<strong class="jf hj">子数组</strong>是数组的一个连续子序列。</p><p id="b51b" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated">问题陈述摘自:<a class="ae kh" href="https://leetcode.com/problems/maximum-product-subarray" rel="noopener ugc nofollow" target="_blank">https://leetcode.com/problems/maximum-product-subarray</a>。</p><p id="cdb9" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated"><strong class="jf hj">例 1: </strong></p><pre class="ki kj kk kl fd km kn ko kp aw kq bi"><span id="fdd7" class="kr ig hi kn b fi ks kt l ku kv">Input: nums = [2, 3, -2, 4] <br/>Output: 6 <br/>Explanation: [2, 3] has the largest product 6.</span></pre><p id="80fc" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated"><strong class="jf hj">例 2: </strong></p><pre class="ki kj kk kl fd km kn ko kp aw kq bi"><span id="eca9" class="kr ig hi kn b fi ks kt l ku kv">Input: nums = [-2, 0, -1] <br/>Output: 0 <br/>Explanation: The result cannot be 2, because [-2, -1] is not a subarray.</span></pre><p id="f832" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated"><strong class="jf hj">约束:</strong></p><pre class="ki kj kk kl fd km kn ko kp aw kq bi"><span id="acb5" class="kr ig hi kn b fi ks kt l ku kv">- 1 &lt;= nums.length &lt;= 2 * 10^4 <br/>- -10 &lt;= nums[i] &lt;= 10 <br/>- The product of any prefix or suffix of nums is guaranteed to fit in a 32-bit integer.</span></pre><h1 id="6211" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">说明</h1><h2 id="839b" class="kr ig hi bd ih kw kx ky il kz la lb ip jo lc ld it js le lf ix jw lg lh jb li bi translated">强力方法</h2><p id="8e12" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">一种简单的方法是考虑所有子阵列并返回最大乘积。</p><p id="9997" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated">该方法的 C++代码片段如下所示:</p><pre class="ki kj kk kl fd km kn ko kp aw kq bi"><span id="dca0" class="kr ig hi kn b fi ks kt l ku kv">int result = arr[0];<br/><br/>for (int i = 0; i &lt; n; i++) {<br/>    int mul = arr[i];<br/><br/>    for (int j = i + 1; j &lt; n; j++) {<br/>        result = max(result, mul);<br/>        mul *= arr[j];<br/>    }<br/><br/>    result = max(result, mul);<br/>}<br/><br/>return result;</span></pre><p id="d42e" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated">上述方法的时间复杂度为<strong class="jf hj"> O(N ) </strong>，空间复杂度为<strong class="jf hj"> O(1) </strong>。</p><h2 id="b80b" class="kr ig hi bd ih kw kx ky il kz la lb ip jo lc ld it js le lf ix jw lg lh jb li bi translated">有效的方法</h2><p id="f541" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">这种高效的方法类似于我们在之前的博客文章<a class="ae kh" href="https://alkeshghorpade.me/post/leetcode-maximum-subarray" rel="noopener ugc nofollow" target="_blank">最大子阵列</a>中使用的方法。这里需要注意的一点是，数组可以包含正数、负数和零。最大子阵列问题使用了 Kadane 的算法。我们调整了这种方法，改为使用三个变量，称为<em class="kb"> max_so_far </em>、<em class="kb"> max_ending_here </em>和<em class="kb"> min_ending_here </em>。对于每个索引，结束于该索引的最大数将是<em class="kb"> maximum(arr[i]，max_ending_here * arr[i]，min_ending_here * arr[i]) </em>。同样，这里结束的最小数字将是这 3 个中的最小值。</p><p id="7e6d" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated">我们先检查一下算法。</p><pre class="ki kj kk kl fd km kn ko kp aw kq bi"><span id="cd7e" class="kr ig hi kn b fi ks kt l ku kv">- set max_ending_here, min_ending_here and max_so_far to nums[0]<br/>  initialize temp_maximum<br/><br/>- loop for i = 1; i &lt; nums.size(); i++<br/>  - temp_maximum = max(nums[i], nums[i] * max_ending_here, nums[i] * min_ending_here)<br/>  - min_ending_here = min(nums[i], nums[i] * max_ending_here, nums[i] * min_ending_here)<br/>  - max_ending_here = temp_maximum<br/>  - max_so_far = max(max_so_far, max_ending_here)<br/><br/>- return max_so_far</span></pre><p id="5935" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated">让我们来看看我们在<strong class="jf hj"> C++ </strong>、<strong class="jf hj"> Golang </strong>和<strong class="jf hj"> Javascript </strong>中的解决方案。</p><h2 id="8a4e" class="kr ig hi bd ih kw kx ky il kz la lb ip jo lc ld it js le lf ix jw lg lh jb li bi translated">C++解决方案</h2><pre class="ki kj kk kl fd km kn ko kp aw kq bi"><span id="86df" class="kr ig hi kn b fi ks kt l ku kv">class Solution {<br/>public:<br/>    int maxProduct(vector&lt;int&gt;&amp; nums) {<br/>        int max_ending_here = nums[0];<br/>        int min_ending_here = nums[0];<br/>        int max_so_far = nums[0];<br/>        int temp_maximum;<br/><br/>        for(int i = 1; i &lt; nums.size(); i++) {<br/>            temp_maximum = max({nums[i], nums[i] * max_ending_here, nums[i] * min_ending_here});<br/>            min_ending_here = min({nums[i], nums[i] * max_ending_here, nums[i] * min_ending_here});<br/>            max_ending_here = temp_maximum;<br/>            max_so_far = max(max_so_far, max_ending_here);<br/>        }<br/><br/>        return max_so_far;<br/>    }<br/>};</span></pre><h2 id="98c5" class="kr ig hi bd ih kw kx ky il kz la lb ip jo lc ld it js le lf ix jw lg lh jb li bi translated">戈朗溶液</h2><pre class="ki kj kk kl fd km kn ko kp aw kq bi"><span id="2f4f" class="kr ig hi kn b fi ks kt l ku kv">func max(a, b int) int {<br/>    if a &gt; b {<br/>        return a<br/>    }<br/><br/>    return b<br/>}<br/><br/>func min(a, b int) int {<br/>    if a &lt; b {<br/>        return a<br/>    }<br/><br/>    return b<br/>}<br/><br/>func maxProduct(nums []int) int {<br/>    max_ending_here, min_ending_here, max_so_far := nums[0], nums[0], nums[0]<br/>    var temp_maximum int<br/><br/>    for i := 1; i &lt; len(nums); i++ {<br/>        temp_maximum = max(nums[i], max(max_ending_here * nums[i], min_ending_here * nums[i]))<br/>        min_ending_here = min(nums[i], min(max_ending_here * nums[i], min_ending_here * nums[i]))<br/>        max_ending_here = temp_maximum<br/>        max_so_far = max(max_so_far, max_ending_here)<br/>    }<br/><br/>    return max_so_far<br/>}</span></pre><h2 id="d932" class="kr ig hi bd ih kw kx ky il kz la lb ip jo lc ld it js le lf ix jw lg lh jb li bi translated">Javascript 解决方案</h2><pre class="ki kj kk kl fd km kn ko kp aw kq bi"><span id="5f23" class="kr ig hi kn b fi ks kt l ku kv">var maxProduct = function(nums) {<br/>    let max_ending_here = nums[0], min_ending_here = nums[0], max_so_far = nums[0];<br/>    let temp_maximum<br/><br/>    for(let i = 1; i &lt; nums.length; i++) {<br/>        temp_maximum = Math.max(nums[i], Math.max(max_ending_here * nums[i], min_ending_here * nums[i]));<br/><br/>        min_ending_here = Math.min(nums[i], Math.min(max_ending_here * nums[i], min_ending_here * nums[i]));<br/><br/>        max_ending_here = temp_maximum;<br/>        max_so_far = Math.max(max_so_far, max_ending_here)<br/>    }<br/><br/>    return max_so_far;<br/>};</span></pre><p id="aae4" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated">让我们试运行一下我们的算法，看看解决方案是如何工作的。</p><pre class="ki kj kk kl fd km kn ko kp aw kq bi"><span id="3c9e" class="kr ig hi kn b fi ks kt l ku kv">Input: nums = [2, 3, -2, 4]<br/><br/>Step 1: max_ending_here, min_ending_here, max_so_far = nums[0], nums[0], nums[0]<br/>        max_ending_here = 2<br/>        min_ending_here = 2<br/>        max_so_far = 2<br/><br/>        initialize temp_maximum<br/><br/>Step 2: loop for i = 1; i &lt; nums.size()<br/>        i &lt; nums.size()<br/>        1 &lt; 4<br/>        true<br/><br/>        temp_maximum = max(nums[i], nums[i] * max_ending_here, nums[i] * min_ending_here)<br/>                     = max(nums[1], nums[1] * 2, nums[1] * 2)<br/>                     = max(3, 3 * 2, 3 * 2)<br/>                     = max(3, 6, 6)<br/>                     = 6<br/><br/>        min_ending_here = min(nums[i], nums[i] * max_ending_here, nums[i] * min_ending_here)<br/>                        = min(nums[1], nums[1] * 2, nums[1] * 2)<br/>                        = min(3, 3 * 2, 3 * 2)<br/>                        = min(3, 6, 6)<br/>                        = 3<br/><br/>        max_ending_here = temp_maximum<br/>                        = 6<br/><br/>        max_so_far = max(max_so_far, max_ending_here)<br/>                   = max(2, 6)<br/>                   = 6<br/><br/>        i++<br/>        i = 2<br/><br/>Step 3: loop for i &lt; nums.size()<br/>        i &lt; nums.size()<br/>        2 &lt; 4<br/>        true<br/><br/>        temp_maximum = max(nums[i], nums[i] * max_ending_here, nums[i] * min_ending_here)<br/>                     = max(nums[2], nums[2] * 6, nums[2] * 3)<br/>                     = max(-2, -2 * 6, -2 * 3)<br/>                     = max(-2, -12, -6)<br/>                     = -2<br/><br/>        min_ending_here = min(nums[i], nums[i] * max_ending_here, nums[i] * min_ending_here)<br/>                        = min(nums[2], nums[2] * 6, nums[2] * 3)<br/>                        = min(-2, -2 * 6, -2 * 3)<br/>                        = min(-2, -12, -6)<br/>                        = -12<br/><br/>        max_ending_here = temp_maximum<br/>                        = -2<br/><br/>        max_so_far = max(max_so_far, max_ending_here)<br/>                   = max(6, -2)<br/>                   = 6<br/><br/>        i++<br/>        i = 3<br/><br/>Step 4: loop for i &lt; nums.size()<br/>        i &lt; nums.size()<br/>        3 &lt; 4<br/>        true<br/><br/>        temp_maximum = max(nums[i], nums[i] * max_ending_here, nums[i] * min_ending_here)<br/>                     = max(nums[3], nums[3] * -2, nums[3] * -12)<br/>                     = max(4, 4 * -2, 4 * -12)<br/>                     = max(4, -8, -48)<br/>                     = 4<br/><br/>        min_ending_here = min(nums[i], nums[i] * max_ending_here, nums[i] * min_ending_here)<br/>                        = min(nums[3], nums[3] * -2, nums[3] * -12)<br/>                        = min(4, 4 * -2, 4 * -12)<br/>                        = min(4, -8, -48)<br/>                        = -48<br/><br/>        max_ending_here = temp_maximum<br/>                        = 4<br/><br/>        max_so_far = max(max_so_far, max_ending_here)<br/>                   = max(6, 4)<br/>                   = 6<br/><br/>        i++<br/>        i = 4<br/><br/>Step 5: loop for i &lt; nums.size()<br/>        i &lt; nums.size()<br/>        4 &lt; 4<br/>        false<br/><br/>Step 6: return max_so_far<br/><br/>So we return the answer as 6.</span></pre></div><div class="ab cl lj lk gp ll" role="separator"><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo"/></div><div class="hb hc hd he hf"><p id="d55f" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated"><em class="kb">原载于</em><a class="ae kh" href="https://alkeshghorpade.me/post/leetcode-maximum-product-subarray" rel="noopener ugc nofollow" target="_blank"><em class="kb">https://alkeshghorpade . me</em></a><em class="kb">。</em></p></div></div>    
</body>
</html>