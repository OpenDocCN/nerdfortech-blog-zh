<html>
<head>
<title>Debugging a Raspberry Pi 4 Automotive Grade Linux with Visual Studio Code</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用 Visual Studio 代码调试 Raspberry Pi 4 汽车级 Linux</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/debugging-a-raspberry-pi-4-automotive-grade-linux-with-visual-studio-code-ceab83f36b66?source=collection_archive---------2-----------------------#2021-03-04">https://medium.com/nerd-for-tech/debugging-a-raspberry-pi-4-automotive-grade-linux-with-visual-studio-code-ceab83f36b66?source=collection_archive---------2-----------------------#2021-03-04</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/de77cad7006acd8ffc58da47637297b1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Bp9QKVW6Q8CJLbuKMckHeQ.png"/></div></div></figure><p id="518b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><em class="jo"> TL，DR: AGL 岩石坚硬。安装 VSCode 和 C/C++扩展包，抢到一个 debug enabled AGL SDK，得到一个我酝酿的</em> <a class="ae jp" href="https://github.com/pauloasherring/template-vscode-agl-crossgdb" rel="noopener ugc nofollow" target="_blank"> <em class="jo">模板项目</em> </a> <em class="jo">的副本，按照 README.md 上的说明:构建，部署，调试，盈利。</em></p><p id="67c3" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">调试能力是开发过程中至关重要的一部分。Linux 系统中的大多数调试都是使用<a class="ae jp" href="https://en.wikipedia.org/wiki/GNU_Debugger" rel="noopener ugc nofollow" target="_blank"> gdb </a>或<a class="ae jp" href="//en.wikipedia.org/wiki/LLDB_(debugger)" rel="noopener ugc nofollow" target="_blank"> lldb </a>进行的。在本文中，我将向您介绍我使用几个关键工具远程调试嵌入式 Linux 应用程序的过程:</p><ul class=""><li id="995f" class="jq jr hi is b it iu ix iy jb js jf jt jj ju jn jv jw jx jy bi translated">微软的 Visual Studio 代码(vs Code)；</li><li id="a715" class="jq jr hi is b it jz ix ka jb kb jf kc jj kd jn jv jw jx jy bi translated">VSCode 的 C/C++扩展包；</li><li id="d7fa" class="jq jr hi is b it jz ix ka jb kb jf kc jj kd jn jv jw jx jy bi translated">汽车级 Linux 和(AGL)软件开发套件(SDK)；</li><li id="eec8" class="jq jr hi is b it jz ix ka jb kb jf kc jj kd jn jv jw jx jy bi translated">sshpass:内联密码传递所必需的— <em class="jo">注意安全！</em>；</li><li id="e768" class="jq jr hi is b it jz ix ka jb kb jf kc jj kd jn jv jw jx jy bi translated">树莓 Pi 4。</li></ul><p id="5876" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">你会得到一个关于如何设置微软的 Visual Studio 代码以实现远程调试的一步一步的过程——使<em class="jo">变得有些容易</em>——使用一个我酝酿并在这里提供的模板项目。</p><p id="3799" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><em class="jo">预先声明:交叉编译和远程调试本身对于新手来说并不是微不足道的任务，所以，如果你有什么不明白的地方，请给我留言和/或通读其他关于交叉编译的资料。</em></p><h1 id="8f51" class="ke kf hi bd kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb bi translated">1.得到好东西</h1><p id="4c42" class="pw-post-body-paragraph iq ir hi is b it lc iv iw ix ld iz ja jb le jd je jf lf jh ji jj lg jl jm jn hb bi translated">在这一步中，我们将建立开始所需的基本设置。我不会讲得太深，但是，这里有一些关于从哪里得到什么的一般性建议。</p><ul class=""><li id="ba95" class="jq jr hi is b it iu ix iy jb js jf jt jj ju jn jv jw jx jy bi translated">Ubuntu 上的 vs code<em class="jo"/>:<code class="du lh li lj lk b">sudo snap install --classic code</code></li><li id="5f2e" class="jq jr hi is b it jz ix ka jb kb jf kc jj kd jn jv jw jx jy bi translated">VSCode 的 C/C++扩展包:</li></ul><figure class="lm ln lo lp fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ll"><img src="../Images/55ab0d3202e0b26e668e5197ea2596f9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*4ilNL_Im_7gvq6Ea"/></div></div></figure><ul class=""><li id="fd32" class="jq jr hi is b it iu ix iy jb js jf jt jj ju jn jv jw jx jy bi translated">汽车级 Linux (AGL)和软件开发套件(SDK):请参考之前的<a class="ae jp" href="https://theuppernibble.wordpress.com/2021/02/24/cross-compiling-a-sample-application-using-automotive-grade-linux/" rel="noopener ugc nofollow" target="_blank">岗位#1 </a>和<a class="ae jp" href="https://theuppernibble.wordpress.com/2021/02/13/running-automotive-grade-linux-on-a-raspberry-pi-4/" rel="noopener ugc nofollow" target="_blank">岗位#2 </a>。</li><li id="d44a" class="jq jr hi is b it jz ix ka jb kb jf kc jj kd jn jv jw jx jy bi translated">sshpass: <code class="du lh li lj lk b">sudo apt instal sshpass</code></li><li id="882b" class="jq jr hi is b it jz ix ka jb kb jf kc jj kd jn jv jw jx jy bi translated">你真正的<a class="ae jp" href="https://github.com/pauloasherring/template-vscode-agl-crossgdb" rel="noopener ugc nofollow" target="_blank">模板工程</a> : <br/> <code class="du lh li lj lk b">git clone <a class="ae jp" href="https://github.com/pauloasherring/template-vscode-agl-crossgdb" rel="noopener ugc nofollow" target="_blank">https://github.com/pauloasherring/template-vscode-agl-crossgdb</a></code></li></ul><p id="355b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">应该差不多了。继续前进。</p><h1 id="ad96" class="ke kf hi bd kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb bi translated">2.使用好东西</h1><h1 id="532e" class="ke kf hi bd kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb bi translated">启动 IDE</h1><p id="1649" class="pw-post-body-paragraph iq ir hi is b it lc iv iw ix ld iz ja jb le jd je jf lf jh ji jj lg jl jm jn hb bi translated">正如我在以前的帖子中提到的，使用 AGL 的 SDK 需要您获取一个环境文件，导出所有类型的环境变量，让 CMake <em class="jo"> et al </em>。到达你的 SDK。为了实现自动化，您可以从终端获取它，然后运行<code class="du lh li lj lk b">code .</code>来启动一个包含所有变量的 VSCode 实例。</p><p id="2b93" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">然而，更方便的方法是运行模板项目提供的<code class="du lh li lj lk b">configAndCode.sh</code>。因此，继续运行它，从您在步骤 1 中克隆的文件夹(<em class="jo">您可能会被 CMake 的扩展提示从一个编译器列表中选择。如果你不确定选择什么，请参考</em> <a class="ae jp" href="https://theuppernibble.wordpress.com/2021/02/13/running-automotive-grade-linux-on-a-raspberry-pi-4/" rel="noopener ugc nofollow" target="_blank">帖子#2 </a> <em class="jo">，在那里会有更详细的讨论</em>。</p><h1 id="8303" class="ke kf hi bd kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb bi translated">针对您的目标进行配置</h1><p id="c3b1" class="pw-post-body-paragraph iq ir hi is b it lc iv iw ix ld iz ja jb le jd je jf lf jh ji jj lg jl jm jn hb bi translated">为了使用 gdb，必须定义几件事，即:调试什么；将它部署到哪里；以及如何部署它，即使用什么凭证。配置在<code class="du lh li lj lk b">.vscode/settings.json</code>完成。从 VSCode 中，导航到它并输入所需的输入:</p><ul class=""><li id="c921" class="jq jr hi is b it iu ix iy jb js jf jt jj ju jn jv jw jx jy bi translated">你的目标的 IP(target IP)；</li><li id="8520" class="jq jr hi is b it jz ix ka jb kb jf kc jj kd jn jv jw jx jy bi translated">你的目标的用户名(target user)；</li><li id="2b84" class="jq jr hi is b it jz ix ka jb kb jf kc jj kd jn jv jw jx jy bi translated">你的目标的用户名的密码(target password)；</li><li id="0912" class="jq jr hi is b it jz ix ka jb kb jf kc jj kd jn jv jw jx jy bi translated">目标的目标文件夹，用于远程部署(targetDestFolder)；</li><li id="a424" class="jq jr hi is b it jz ix ka jb kb jf kc jj kd jn jv jw jx jy bi translated">二进制文件的文件名(target appname)；</li><li id="f86e" class="jq jr hi is b it jz ix ka jb kb jf kc jj kd jn jv jw jx jy bi translated">二进制文件的路径(targetInFolder)。</li></ul><p id="92ba" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这些配置在<code class="du lh li lj lk b">tasks.json</code>中用于驱动在开始调试之前发生的部署过程。确保你做对了:你应该能够使用你输入的配置<code class="du lh li lj lk b">scp</code>和<code class="du lh li lj lk b">ssh</code>。如果你做不到这一点，你将无法调试，因为这些是用来驱动调试会话的机制。</p><h1 id="2687" class="ke kf hi bd kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb bi translated">构建和调试</h1><p id="56c2" class="pw-post-body-paragraph iq ir hi is b it lc iv iw ix ld iz ja jb le jd je jf lf jh ji jj lg jl jm jn hb bi translated">在建筑部门，模板项目提供了三个任务，由<code class="du lh li lj lk b">CTRL + SHIFT + B</code>触发:</p><ul class=""><li id="dbf7" class="jq jr hi is b it iu ix iy jb js jf jt jj ju jn jv jw jx jy bi translated">CMake Build:运行 CMake configure，Build，并运行生成的构建系统。</li><li id="8787" class="jq jr hi is b it jz ix ka jb kb jf kc jj kd jn jv jw jx jy bi translated">CMake Clean:删除所有构建的文件，但保留缓存和其他；</li><li id="d396" class="jq jr hi is b it jz ix ka jb kb jf kc jj kd jn jv jw jx jy bi translated">删除构建文件夹:永久删除构建文件夹，进行更严格的重置。</li><li id="a472" class="jq jr hi is b it jz ix ka jb kb jf kc jj kd jn jv jw jx jy bi translated"><em class="jo">Extra:</em>Kill remote gdbserver:这是一种便捷的方法，可以杀死在目标上运行的已停止的 gdb server 实例。</li></ul><p id="1236" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">对于调试，<code class="du lh li lj lk b">CTRL + SHIFT + B</code>并选择 CMake Build。如果您没有更改 CMake 文件，那么应该已经生成了一个二进制文件，并在<code class="du lh li lj lk b">./build/SampleApp</code>时可用。</p><p id="281e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">之后，按<code class="du lh li lj lk b">F5</code>开始调试。这应该需要几秒钟才能开始。</p><p id="33aa" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">整个过程描述如下:</p><figure class="lm ln lo lp fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lq"><img src="../Images/76bce97467951271ad785fb8c599db92.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*WYlWWDnpouMGpMrUw7Vmaw.gif"/></div></div></figure><h1 id="12d5" class="ke kf hi bd kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb bi translated">在引擎盖下寻找</h1><p id="5438" class="pw-post-body-paragraph iq ir hi is b it lc iv iw ix ld iz ja jb le jd je jf lf jh ji jj lg jl jm jn hb bi translated">构建过程非常传统，唯一真正的区别是在启动任何 CMake 实例之前获取 AGL 的 SDK 配置文件:这允许 CMake 正确地识别成功交叉编译所需的一切。在目前的方法中，源需要在启动 VSCode 之前完成:CMake 将继承它的环境变量。</p><p id="51ac" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">至于调试，则需要更多的努力。有几个有趣的链接，要么 a)一般的想法；b)瞄准其他硬件和工具链；c)瞄准其他方法，如 gdb -tui 或 eclipse。其中有几个是:<a class="ae jp" rel="noopener" href="/@karel.l.vermeiren/cross-architecture-remote-debugging-using-gdb-with-visual-studio-code-vscode-on-linux-c0572794b4ef">【1】</a><a class="ae jp" href="https://gojimmypi.blogspot.com/2017/05/vscode-remote-debugging-of-embedded.html" rel="noopener ugc nofollow" target="_blank">【2】</a><a class="ae jp" href="https://elinux.org/ECE497_Notes_on_Installing_the_Eclipse_IDE" rel="noopener ugc nofollow" target="_blank">【3】</a><a class="ae jp" href="https://eastrivervillage.com/debugging-application-with-cross-gdb-yocto/" rel="noopener ugc nofollow" target="_blank">【4】</a>。</p><p id="57ca" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">简要描述一下发生的情况，涉及的步骤如下:</p><ol class=""><li id="1a09" class="jq jr hi is b it iu ix iy jb js jf jt jj ju jn lr jw jx jy bi translated">将二进制文件复制到目标——这里用<code class="du lh li lj lk b">scp</code>完成，这是一个<em class="jo">复制 ssh </em>工具；</li><li id="bff6" class="jq jr hi is b it jz ix ka jb kb jf kc jj kd jn lr jw jx jy bi translated">让二进制文件成为可执行文件——这里是通过 ssh 会话用<code class="du lh li lj lk b">chmod +x binaryName</code>完成的；</li><li id="b10c" class="jq jr hi is b it jz ix ka jb kb jf kc jj kd jn lr jw jx jy bi translated">在目标上启动 gdbserver 在这里通过 ssh 会话用<code class="du lh li lj lk b">gdbserver :3000 binaryName</code>完成；</li><li id="faff" class="jq jr hi is b it jz ix ka jb kb jf kc jj kd jn lr jw jx jy bi translated">使用 SDK 提供的 gdb 二进制文件连接到正在运行的 gdbserver 会话——这里由 VSCode 自己完成。</li><li id="637b" class="jq jr hi is b it jz ix ka jb kb jf kc jj kd jn lr jw jx jy bi translated">连接后，使用</li></ol><p id="c06d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">为了实现这一点，我设计了一些长的一行命令，在<code class="du lh li lj lk b">tasks.json</code>上使用。</p><h1 id="7981" class="ke kf hi bd kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb bi translated">3.结论</h1><p id="b0e2" class="pw-post-body-paragraph iq ir hi is b it lc iv iw ix ld iz ja jb le jd je jf lf jh ji jj lg jl jm jn hb bi translated">微软的 Visual Studio 代码是一个令人难以置信的免费 IDE，被许多人选择作为首选解决方案。很明显，它走过了漫长的道路，并随着时间的推移不断改进。</p><p id="e7e2" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在，对于像你我这样的嵌入式开发人员来说，它仍然有些缺乏，因为通常使用 IDE 进行开发，使用其他工具进行构建和调试。</p><p id="d5c1" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在本文中，我介绍了一个自酿的 VSCode 模板项目，用于支持嵌入式 Linux 目标的开发、构建和调试。虽然我关注的是汽车级 Linux，但是所介绍的方法可以很容易地适用于任何基于 Yocto 的项目。</p><p id="919b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">希望对你有帮助:)</p><p id="2472" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如果有，请告诉我。此外，反馈将非常感谢，提高我的博客技能。</p><p id="116b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><em class="jo">这个原来贴在这里:</em> <a class="ae jp" href="https://theuppernibble.wordpress.com/2021/03/04/debugging-automotive-grade-linux-with-visual-studio-code/" rel="noopener ugc nofollow" target="_blank"> <em class="jo">上半字节</em> </a> <em class="jo">。</em></p></div></div>    
</body>
</html>