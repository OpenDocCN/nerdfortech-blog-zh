<html>
<head>
<title>Build a Microservice App Using gRPC, Python, and Golang (Part 2)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用gRPC、Python和Golang构建微服务应用程序(第2部分)</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/build-a-microservice-app-using-grpc-python-and-golang-part-2-ac93541e4d0d?source=collection_archive---------4-----------------------#2021-04-05">https://medium.com/nerd-for-tech/build-a-microservice-app-using-grpc-python-and-golang-part-2-ac93541e4d0d?source=collection_archive---------4-----------------------#2021-04-05</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/abe3e2240be763c0d871ec2ff9c0775d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*tbi7WZoDwdsaLpMc"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">照片由<a class="ae iu" href="https://unsplash.com/@omidvisuals?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> OMID视觉效果</a>在<a class="ae iu" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="a31f" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">欢迎回到本教程的第二部分。我们将继续使用gRPC、Python和Golang学习和构建应用程序的旅程。这一次，我们重点关注身份验证服务的实现细节。让我们开始…</p></div><div class="ab cl jt ju gp jv" role="separator"><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy"/></div><div class="hb hc hd he hf"><h1 id="2627" class="ka kb hi bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated">认证服务器</h1><p id="014e" class="pw-post-body-paragraph iv iw hi ix b iy ky ja jb jc kz je jf jg la ji jj jk lb jm jn jo lc jq jr js hb bi translated">首先，我们必须创建认证服务，我们使用的语言将是Golang。然后，我们将这个服务连接到主服务。现在，确保您在根文件夹中。顺便说一下，如果您更喜欢将这个项目的服务分离到它自己的存储库中，那也没问题。在这种情况下，为了方便起见，我将它们放在一个存储库中。</p><p id="2bab" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">让我们将这个服务命名为<code class="du ld le lf lg b">auth</code>，初始化golang项目并安装所需的依赖项，或者您可以在这里查看如何设置项目<a class="ae iu" href="https://grpc.io/docs/languages/go/quickstart/" rel="noopener ugc nofollow" target="_blank">https://grpc.io/docs/languages/go/quickstart/</a>。</p><pre class="lh li lj lk fd ll lg lm ln aw lo bi"><span id="625c" class="lp kb hi lg b fi lq lr l ls lt">go mod init auth      # the name will be auth<br/>go <!-- -->get google.golang.org/protobuf/cmd/protoc-gen-go <strong class="lg hj">\<br/></strong>         google.golang.org/grpc/cmd/protoc-gen-go-grpc</span></pre><p id="f06b" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">现在，创建<em class="lu"> main.go </em>文件，然后编写某种占位符来确保我们已经正确初始化了应用程序。</p><figure class="lh li lj lk fd ij"><div class="bz dy l di"><div class="lv lw l"/></div></figure><p id="264b" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这么原始的权利？:)</p><p id="67c9" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在我们开始在proto文件中编写一些代码并在Golang中生成相应的代码之前，我们必须设置一些配置和数据库。</p><p id="55ed" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">现在，创建一个名为<code class="du ld le lf lg b">grpc_auth</code>的数据库，我们将这个服务连接到<code class="du ld le lf lg b">grpc_auth</code>数据库。然后，创建一个名为<code class="du ld le lf lg b">users</code>的表。这是每次注册新用户时用户数据的存放位置。你可以使用这个查询来创建<code class="du ld le lf lg b">users</code>表。</p><pre class="lh li lj lk fd ll lg lm ln aw lo bi"><span id="842a" class="lp kb hi lg b fi lq lr l ls lt">CREATE TABLE public.users (</span><span id="f1ad" class="lp kb hi lg b fi lx lr l ls lt">id serial NOT NULL,</span><span id="7e2b" class="lp kb hi lg b fi lx lr l ls lt">username varchar(128) NULL,</span><span id="6efa" class="lp kb hi lg b fi lx lr l ls lt">"password" varchar(256) NULL,</span><span id="0384" class="lp kb hi lg b fi lx lr l ls lt">CONSTRAINT users_pkey PRIMARY KEY (id)</span><span id="a1cb" class="lp kb hi lg b fi lx lr l ls lt">);</span></pre><p id="b050" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">创建一个名为config的文件夹，并在其中创建一个名为<code class="du ld le lf lg b">database.go</code>的文件。</p><figure class="lh li lj lk fd ij"><div class="bz dy l di"><div class="lv lw l"/></div></figure><p id="271a" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">函数<code class="du ld le lf lg b">getDBConnection</code>负责建立数据库，函数<code class="du ld le lf lg b">ConnectDB</code>将被导入到主文件中，并被调用来建立与数据库的连接。</p><p id="30c2" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">接下来，创建一个名为repository的文件夹，并在其中创建一个名为<code class="du ld le lf lg b">user.go</code>的文件。这样做的目的是作为我们用来对数据库进行一些改变或查询的接口。通过这样做，我想在我的代码中实现关注点分离的概念。</p><figure class="lh li lj lk fd ij"><div class="bz dy l di"><div class="lv lw l"/></div></figure><p id="fa4e" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在这个文件中，我们创建了一个名为<code class="du ld le lf lg b">userRepository</code>的结构和一个名为<code class="du ld le lf lg b">UserRepository</code>的接口。然后我们定义了它下面的接口方法(<code class="du ld le lf lg b">CreateUser</code>和<code class="du ld le lf lg b">GetUserByUsername</code>)。请注意，我们在这些方法中不做任何事情，所以我们必须在稍后定义proto文件后回到这里。但是，在跳到下一部分之前，在第31行我们有<code class="du ld le lf lg b">models.User</code>，但是这是什么东西呢？让我们创造这个“东西”。</p><p id="d245" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">创建一个名为models的文件夹，并在其中创建一个名为<code class="du ld le lf lg b">user.go</code>的文件。</p><figure class="lh li lj lk fd ij"><div class="bz dy l di"><div class="lv lw l"/></div></figure><p id="582b" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这么短的一段代码，对吧？这里，我们刚刚定义了表示用户的结构。</p><p id="a133" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在那之后，另一段用于分离关注点的代码是<code class="du ld le lf lg b">usecase</code>。创建一个名为<code class="du ld le lf lg b">usecase</code>的文件夹，并在其中创建一个名为<code class="du ld le lf lg b">user.go</code>的文件。和<code class="du ld le lf lg b">repository</code>差不多，但是任务不同，你会看到的。</p><figure class="lh li lj lk fd ij"><div class="bz dy l di"><div class="lv lw l"/></div></figure><p id="85cc" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">现在，我们让这个<code class="du ld le lf lg b">usecase</code>文件保持原样，稍后我们将回到这里实现真正的东西。</p><p id="12dd" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">现在，是时候定义proto文件并在Golang中生成相应的代码了。生成的代码将被用作gRPC的服务器部分，当我们从客户端(main-service)调用某个过程时，它会给出我们需要的响应。</p><p id="ea6f" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在根文件夹中创建一个名为<code class="du ld le lf lg b">auth.proto</code>的文件。</p><figure class="lh li lj lk fd ij"><div class="bz dy l di"><div class="lv lw l"/></div></figure><p id="7575" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">以上是<code class="du ld le lf lg b">auth.proto</code>的内容。我们用的是protobuf语言版本3，包的名字是<code class="du ld le lf lg b">auth</code>。可能你不需要<code class="du ld le lf lg b">option</code>，但是在这种情况下，我需要它，否则它会给我一个错误。</p><p id="6cb4" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">简单地说，我们必须定义一个过程看起来是什么样子，以及它需要的参数和返回值。我们将使用这个原型文件来生成服务的服务器和客户机。例如，在客户端，我们想调用<code class="du ld le lf lg b">Register</code>(基本上是一个远程过程)，然后我们必须给它一个参数(<code class="du ld le lf lg b">RegisterRequest</code>)，它将返回<code class="du ld le lf lg b">RegisterResponse</code>。</p><p id="29df" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">要生成过程代码，我们必须运行以下命令。但是在此之前，创建一个名为<code class="du ld le lf lg b">auth</code>的文件夹，它将是所生成代码的输出目标。</p><pre class="lh li lj lk fd ll lg lm ln aw lo bi"><span id="c0c3" class="lp kb hi lg b fi lq lr l ls lt">protoc --go_out=./auth --go_opt=paths=source_relative \</span><span id="7832" class="lp kb hi lg b fi lx lr l ls lt">--go-grpc_out=./auth --go-grpc_opt=paths=source_relative \</span><span id="5580" class="lp kb hi lg b fi lx lr l ls lt">./auth.proto</span></pre><p id="8761" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">原型编译器将在当前目录中查找名为<code class="du ld le lf lg b">auth.proto</code>的文件，并将输出返回到名为<code class="du ld le lf lg b">auth</code>的文件夹中。</p><p id="236a" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">运行这个命令后，您将拥有两个名为<code class="du ld le lf lg b">auth.pb.go</code>和<code class="du ld le lf lg b">auth_grpc.pb.go</code>的文件。我们不会直接使用这段代码或者改变里面的任何东西，事实上，你会在文件顶部看到一个警告<code class="du ld le lf lg b">DO NOT EDIT</code>。</p><p id="3685" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">接下来，在<code class="du ld le lf lg b">auth</code>文件夹中创建一个名为<code class="du ld le lf lg b">auth.go</code>的文件。在这里，我们将定义这些过程是如何工作的。</p><figure class="lh li lj lk fd ij"><div class="bz dy l di"><div class="lv lw l"/></div></figure><p id="c921" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">同样，因为我们一点一点地提供服务，所以我们必须回到这里定义真实的东西。在这个文件中，我们定义了三个与proto文件定义中相同的过程，因为基本上在这里我们将生成的代码实现成我们需要的样子。注意我放了<code class="du ld le lf lg b">UnimplementedAuthServiceServer</code>，原因是为了向前兼容的实现。</p><p id="2bf2" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">现在，让我们改变一下<code class="du ld le lf lg b">main.go</code>。</p><figure class="lh li lj lk fd ij"><div class="bz dy l di"><div class="lv lw l"/></div></figure><p id="eba3" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这里，我们连接到数据库，初始化<code class="du ld le lf lg b">repository</code>、<code class="du ld le lf lg b">usecase</code>和<code class="du ld le lf lg b">server</code>，在第25行注册服务服务器，在第27行打开<code class="du ld le lf lg b">tcp</code>连接，在第33行服务服务器。此时，希望您可以通过键入<code class="du ld le lf lg b">go run main.go</code>命令来运行这个程序。</p></div><div class="ab cl jt ju gp jv" role="separator"><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy"/></div><div class="hb hc hd he hf"><h1 id="8676" class="ka kb hi bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated">授权客户端</h1><p id="5fa3" class="pw-post-body-paragraph iv iw hi ix b iy ky ja jb jc kz je jf jg la ji jj jk lb jm jn jo lc jq jr js hb bi translated">现在，我们转移到客户端(主服务)。首先，我们必须安装依赖项，稍后将使用它在Python中生成gRPC代码。</p><p id="1352" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在我们的主服务根目录中(确保首先激活您的虚拟环境)，在您的终端上键入以下命令。</p><pre class="lh li lj lk fd ll lg lm ln aw lo bi"><span id="0673" class="lp kb hi lg b fi lq lr l ls lt">pip install grpcio</span></pre><p id="09b5" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">接下来，我们需要来自我们的<code class="du ld le lf lg b">auth</code>服务的相同的原型文件。您可以将其复制到主服务根文件夹中。然后通过运行以下命令生成gRPC代码。</p><pre class="lh li lj lk fd ll lg lm ln aw lo bi"><span id="9b63" class="lp kb hi lg b fi lq lr l ls lt">python -m grpc_tools.protoc -I. --python_out=./auth --grpc_python_out=./auth ./auth.proto</span></pre><p id="76c5" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">该命令编译主服务根目录(<code class="du ld le lf lg b">auth.proto</code>)中的proto文件，输出放在<code class="du ld le lf lg b">auth</code>文件夹中。</p><p id="e4eb" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在我们运行这个命令之后，我们有两个新生成的文件，名为<code class="du ld le lf lg b">auth_pb2.py</code>和<code class="du ld le lf lg b">auth_pb2_grpc.py</code>。与之前的Golang服务类似，我们必须在另一个文件中定义真正的过程，我们称之为<code class="du ld le lf lg b">client.py</code>并将其放在<code class="du ld le lf lg b">auth</code>文件夹中。</p><figure class="lh li lj lk fd ij"><div class="bz dy l di"><div class="lv lw l"/></div></figure><p id="48d9" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这是主服务中的一部分，我们用它来调用认证服务中的一些过程。这是客户端部分，认证服务是服务器部分。请注意，我们还定义了与在proto文件中编写的相同的函数。</p><p id="8c47" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">让我们在视图文件中使用<code class="du ld le lf lg b">AuthClient</code>。在上一篇文章中，我们已经定义了auth view函数，它仍然是一种基本形式。现在，让我们改变它，使它实现其真正的工作。</p><figure class="lh li lj lk fd ij"><div class="bz dy l di"><div class="lv lw l"/></div></figure><p id="ae79" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">为了方便起见，我们的应用程序将混合使用gRPC和REST，但是在上一篇文章中，我们将把<code class="du ld le lf lg b">templates</code>用于Jinja2。gRPC被用作连接服务之间的桥梁，REST被用作连接应用程序和用户之间的桥梁。</p></div><div class="ab cl jt ju gp jv" role="separator"><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy"/></div><div class="hb hc hd he hf"><h1 id="0acd" class="ka kb hi bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated">授权服务(重新访问)</h1><p id="dd04" class="pw-post-body-paragraph iv iw hi ix b iy ky ja jb jc kz je jf jg la ji jj jk lb jm jn jo lc jq jr js hb bi translated">现在，让我们完成我们的认证服务。我们需要更改几个部分，分别是<code class="du ld le lf lg b">repository</code>、<code class="du ld le lf lg b">usecase</code>和<code class="du ld le lf lg b">server</code>，然后创建一些新的实用程序文件。</p><p id="3271" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">首先更改存储库。</p><figure class="lh li lj lk fd ij"><div class="bz dy l di"><div class="lv lw l"/></div></figure><p id="09b7" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">改变用例。</p><figure class="lh li lj lk fd ij"><div class="bz dy l di"><div class="lv lw l"/></div></figure><p id="8599" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">为了让上面的代码正常工作，我们必须创建用于散列密码、检查密码、生成令牌和解析令牌的实用函数。</p><p id="2adb" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">让我们更新我们的依赖项，这样我们就可以生成一个散列密码和JSON令牌。</p><pre class="lh li lj lk fd ll lg lm ln aw lo bi"><span id="0b1a" class="lp kb hi lg b fi lq lr l ls lt">go get golang.org/x/crypto/bcrypt</span><span id="cb18" class="lp kb hi lg b fi lx lr l ls lt">go get github.com/dgrijalva/jwt-go</span></pre><p id="a697" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">创建一个名为<code class="du ld le lf lg b">utils</code>的文件夹，并在其中创建一个名为<code class="du ld le lf lg b">hash_password.go</code>的文件。</p><figure class="lh li lj lk fd ij"><div class="bz dy l di"><div class="lv lw l"/></div></figure><p id="3312" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">接下来，在<code class="du ld le lf lg b">utils</code>文件夹中创建一个名为<code class="du ld le lf lg b">token.go</code>的文件。</p><figure class="lh li lj lk fd ij"><div class="bz dy l di"><div class="lv lw l"/></div></figure><p id="21c8" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><code class="du ld le lf lg b">GenerateToken</code>函数如其名，用于生成JSON令牌，而<code class="du ld le lf lg b">ParseToken</code>用于验证令牌并返回登录的用户数据。</p><p id="28d4" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">现在，在<code class="du ld le lf lg b">auth</code>文件夹中修改服务器文件<code class="du ld le lf lg b">auth.go</code>。</p><figure class="lh li lj lk fd ij"><div class="bz dy l di"><div class="lv lw l"/></div></figure><p id="4b7c" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这里，我们使用已经更新的用例。</p><p id="e2ea" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们的认证服务即将完成。以确保一切正常运行。让我们运行这两个服务，并使用Postman测试它们。</p><pre class="lh li lj lk fd ll lg lm ln aw lo bi"><span id="4a08" class="lp kb hi lg b fi lq lr l ls lt">python app.py        # for main service<br/>go run main.go       # for auth service</span></pre><figure class="lh li lj lk fd ij er es paragraph-image"><div class="er es ly"><img src="../Images/a40a0a9ecb3c4aedebb9d4cd6d53f201.png" data-original-src="https://miro.medium.com/v2/resize:fit:1278/format:webp/1*sbezM8Iq3wghhcfVDINgKQ.png"/></div></figure><figure class="lh li lj lk fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lz"><img src="../Images/83d0df9ed458606f9110893d104a0c02.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*h9WF0yVRGfd1k0WY3gK_CA.png"/></div></div></figure><p id="8c80" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">太棒了，现在认证服务完成了。我们将在下一篇文章中继续讨论如何实现todo服务。您可以在这里找到本文的代码<a class="ae iu" href="https://github.com/agusrichard/python-golang-grpc/tree/part2" rel="noopener ugc nofollow" target="_blank">https://github . com/agusrichard/python-golang-grpc/tree/part 2</a>。</p><p id="6d46" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如果您有任何问题或反馈，请随时留下评论或通过电子邮件联系我，agus.richard21@gmail.com。另外，如果你认为这篇文章对你有帮助，请不要犹豫，给这篇文章鼓掌。</p><p id="81ae" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">感谢您的阅读，下一篇文章再见。</p></div></div>    
</body>
</html>