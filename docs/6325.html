<html>
<head>
<title>LeetCode — Triangle</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">LeetCode —三角形</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/leetcode-triangle-f60f3bce622a?source=collection_archive---------4-----------------------#2022-02-03">https://medium.com/nerd-for-tech/leetcode-triangle-f60f3bce622a?source=collection_archive---------4-----------------------#2022-02-03</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><h1 id="66ca" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">问题陈述</h1><p id="83d2" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">给定一个三角形数组，返回<em class="kb">从上到下的最小路径和</em>。</p><p id="fde9" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated">对于每一步，您可以移动到下一行的相邻数字。更正式地说，如果您在当前行的索引 I 上，您可以移动到下一行的索引 I 或索引 i + 1。</p><p id="66cb" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated">问题陈述摘自:【https://leetcode.com/problems/triangle<a class="ae kh" href="https://leetcode.com/problems/triangle" rel="noopener ugc nofollow" target="_blank">。</a></p><p id="c683" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated"><strong class="jf hj">例一:</strong></p><pre class="ki kj kk kl fd km kn ko kp aw kq bi"><span id="a79b" class="kr ig hi kn b fi ks kt l ku kv">Input: triangle = [[2], [3, 4], [6, 5, 7], [4, 1, 8, 3]]<br/>Output: 11<br/>Explanation: The triangle looks like:<br/>   2<br/>  3 4<br/> 6 5 7<br/>4 1 8 3<br/>The minimum path sum from top to bottom is 2 + 3 + 5 + 1 = 11 (underlined above).</span></pre><p id="d53e" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated"><strong class="jf hj">例 2: </strong></p><pre class="ki kj kk kl fd km kn ko kp aw kq bi"><span id="7475" class="kr ig hi kn b fi ks kt l ku kv">Input: triangle = [[-10]] <br/>Output: -10</span></pre><p id="0d33" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated"><strong class="jf hj">约束:</strong></p><pre class="ki kj kk kl fd km kn ko kp aw kq bi"><span id="fe21" class="kr ig hi kn b fi ks kt l ku kv">- 1 &lt;= triangle.length &lt;= 200 <br/>- triangle[0].length == 1 <br/>- triangle[i].length == triangle[i - 1].length + 1 <br/>- -10^4 &lt;= triangle[i][j] &lt;= 10^4</span></pre><h1 id="ff48" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">说明</h1><h2 id="151d" class="kr ig hi bd ih kw kx ky il kz la lb ip jo lc ld it js le lf ix jw lg lh jb li bi translated">动态规划</h2><p id="2609" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">乍一看，我们可能首先想到 DFS 遍历。但是如果我们仔细观察，我们可以用动态规划来解决这个问题。我们只能在下一个向量集中选取索引<strong class="jf hj"> i </strong>或<strong class="jf hj"> i + 1 </strong>。这使得很容易存储子问题的解，并使用这些重叠的子问题来获得最小和路径。</p><p id="cd40" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated">我们可以遵循自顶向下的方法或自底向上的方法来获得我们需要的解决方案。自底向上的方法非常简单。我们将最下面一行的节点存储在一个数组中。我们逐行移动到最上面的节点，以及它下面的两个数字中较小的一个。</p><p id="acfe" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated">我们先检查一下算法。</p><pre class="ki kj kk kl fd km kn ko kp aw kq bi"><span id="e5f9" class="kr ig hi kn b fi ks kt l ku kv">- set n = triangle.size()<br/><br/>- set pathSums array size to bottom-most row size<br/>  vector&lt;int&gt; pathSums(triangle.back())<br/><br/>- loop for layer = n - 2; layer &gt;=0; layer--<br/>  - loop for i = 0; i &lt;= layer; i++<br/>    - set pathSums[i] = min(pathSums[i], pathSums[i + 1]) + triangle[layer][i]<br/><br/>- return pathSums[0]</span></pre><p id="783b" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated">让我们看看我们在<strong class="jf hj"> C++ </strong>、<strong class="jf hj"> Golang </strong>和<strong class="jf hj"> Javascript </strong>中的解决方案。</p><h2 id="d657" class="kr ig hi bd ih kw kx ky il kz la lb ip jo lc ld it js le lf ix jw lg lh jb li bi translated">C++解决方案</h2><pre class="ki kj kk kl fd km kn ko kp aw kq bi"><span id="7901" class="kr ig hi kn b fi ks kt l ku kv">class Solution {<br/>public:<br/>    int minimumTotal(vector&lt;vector&lt;int&gt;&gt;&amp; triangle) {<br/>        int n = triangle.size();<br/>        vector&lt;int&gt; pathSums(triangle.back());<br/><br/>        for (int layer = n - 2; layer &gt;= 0; layer--) {<br/>            for (int i = 0; i &lt;= layer; i++) {<br/>                pathSums[i] = min(pathSums[i], pathSums[i + 1]) + triangle[layer][i];<br/>            }<br/>        }<br/><br/>        return pathSums[0];<br/>    }<br/>};</span></pre><h2 id="2144" class="kr ig hi bd ih kw kx ky il kz la lb ip jo lc ld it js le lf ix jw lg lh jb li bi translated">戈朗溶液</h2><pre class="ki kj kk kl fd km kn ko kp aw kq bi"><span id="ba4c" class="kr ig hi kn b fi ks kt l ku kv">func min(a, b int) int {<br/>    if a &lt; b {<br/>        return a<br/>    }<br/><br/>    return b<br/>}<br/><br/>func minimumTotal(triangle [][]int) int {<br/>    n := len(triangle)<br/>    pathSums := triangle[n - 1]<br/><br/>    for layer := n - 2; layer &gt;= 0; layer-- {<br/>        for i := 0; i &lt;= layer; i++ {<br/>            pathSums[i] = min(pathSums[i], pathSums[i+1]) + triangle[layer][i]<br/>        }<br/>    }<br/><br/>    return pathSums[0]<br/>}</span></pre><h2 id="9fa4" class="kr ig hi bd ih kw kx ky il kz la lb ip jo lc ld it js le lf ix jw lg lh jb li bi translated">Javascript 解决方案</h2><pre class="ki kj kk kl fd km kn ko kp aw kq bi"><span id="4ea9" class="kr ig hi kn b fi ks kt l ku kv">var minimumTotal = function(triangle) {<br/>    let n = triangle.length;<br/>    let pathSums = triangle[n - 1];<br/><br/>    for (let layer = n - 2; layer &gt;= 0; layer--) {<br/>        for (let i = 0; i &lt;= layer; i++) {<br/>            pathSums[i] = Math.min(pathSums[i], pathSums[i + 1]) + triangle[layer][i];<br/>        }<br/>    }<br/><br/>    return pathSums[0];<br/>};</span></pre><p id="4958" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated">让我们试运行一下我们的算法，看看解决方案是如何工作的。</p><pre class="ki kj kk kl fd km kn ko kp aw kq bi"><span id="24d0" class="kr ig hi kn b fi ks kt l ku kv">Input: triangle = [[2], [3, 4], [6, 5, 7], [4, 1, 8, 3]]<br/><br/>Step 1: n = triangle.size()<br/>          = 4<br/><br/>        vector&lt;int&gt; pathSums(triangle.back())<br/>        pathSums = [4, 1, 8, 3]<br/><br/>Step 2: loop for layer = n - 2; layer &gt;= 0<br/>          layer = 4 - 2<br/>                = 2<br/><br/>          layer &gt;= 0<br/>          2 &gt;= 0<br/>          true<br/><br/>          loop i = 0; i &lt;= layer<br/>            0 &lt;= 2<br/>            true<br/><br/>            pathSums[i] = min(pathSums[i], pathSums[i + 1]) + triangle[layer][i]<br/>            pathSums[0] = min(pathSums[0], pathSums[1]) + triangle[2][0]<br/>                        = min(4, 1) + 6<br/>                        = 1 + 6<br/>                        = 7<br/><br/>            i++<br/>            1 &lt;= 2<br/>            true<br/><br/>            pathSums[i] = min(pathSums[i], pathSums[i + 1]) + triangle[layer][i]<br/>            pathSums[1] = min(pathSums[1], pathSums[2]) + triangle[2][1]<br/>                        = min(1, 8) + 5<br/>                        = 1 + 5<br/>                        = 6<br/><br/>            i++<br/>            i = 2<br/>            2 &lt;= 2<br/>            true<br/><br/>            pathSums[i] = min(pathSums[i], pathSums[i + 1]) + triangle[layer][i]<br/>            pathSums[2] = min(pathSums[2], pathSums[3]) + triangle[2][2]<br/>                        = min(8, 3) + 7<br/>                        = 3 + 7<br/>                        = 10<br/><br/>            i++<br/>            i = 3<br/>            3 &lt;= 2<br/>            false<br/><br/>          layer--<br/>          layer = 1<br/><br/>          pathSums = [7, 6, 10, 3]<br/><br/>Step 3: loop for layer &gt;= 0<br/>          1 &gt;= 0<br/>          true<br/><br/>          loop i = 0; i &lt;= layer<br/>            0 &lt;= 1<br/>            true<br/><br/>            pathSums[i] = min(pathSums[i], pathSums[i + 1]) + triangle[layer][i]<br/>            pathSums[0] = min(pathSums[0], pathSums[1]) + triangle[1][0]<br/>                        = min(7, 6) + 3<br/>                        = 6 + 3<br/>                        = 9<br/><br/>            i++<br/>            i = 1<br/>            i &lt;= layer<br/>            1 &lt;= 1<br/>            true<br/><br/>            pathSums[i] = min(pathSums[i], pathSums[i + 1]) + triangle[layer][i]<br/>            pathSums[1] = min(pathSums[1], pathSums[2]) + triangle[1][1]<br/>                        = min(6, 10) + 4<br/>                        = 6 + 4<br/>                        = 10<br/><br/>            i++<br/>            i = 2<br/>            i &lt;= layer<br/>            2 &lt;= 1<br/>            false<br/><br/>          layer--<br/>          layer = 0<br/><br/>          pathSums = [9, 10, 10, 3]<br/><br/>Step 4: loop for layer &gt;= 0<br/>          0 &gt;= 0<br/>          true<br/><br/>          loop i = 0; i &lt;= layer<br/>            0 &lt;= 0<br/>            true<br/><br/>            pathSums[i] = min(pathSums[i], pathSums[i + 1]) + triangle[layer][i]<br/>            pathSums[0] = min(pathSums[0], pathSums[1]) + triangle[0][0]<br/>                        = min(9, 10) + 2<br/>                        = 9 + 2<br/>                        = 11<br/><br/>            i++<br/>            i = 1<br/>            i &lt;= layer<br/>            1 &lt;= 0<br/>            false<br/><br/>        layer--<br/>        layer = -1<br/><br/>Step 5: loop for layer &gt;= 0<br/>          -1 &gt;= 0<br/>          false<br/><br/>Step 6: return pathSums[0]<br/><br/>So we return the answer as 11.</span></pre></div><div class="ab cl lj lk gp ll" role="separator"><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo"/></div><div class="hb hc hd he hf"><p id="461a" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated"><em class="kb">原载于</em><a class="ae kh" href="https://alkeshghorpade.me/post/leetcode-triangle" rel="noopener ugc nofollow" target="_blank"><em class="kb">https://alkeshghorpade . me</em></a><em class="kb">。</em></p></div></div>    
</body>
</html>