<html>
<head>
<title>What Are Common Collections in Rust?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Rust里有哪些常见的收藏？</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/what-are-common-collections-in-rust-e6411ece24f0?source=collection_archive---------6-----------------------#2021-10-13">https://medium.com/nerd-for-tech/what-are-common-collections-in-rust-e6411ece24f0?source=collection_archive---------6-----------------------#2021-10-13</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/15fdc727fb1e4ee932ba51f03e8c9072.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wM2HFAcSTfVLf1_9hQHaxw.png"/></div></div></figure><h1 id="a896" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">常见收藏</h1><p id="44a1" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">Rust的标准库包括许多非常有用的数据结构，称为集合。大多数其他数据类型表示一个特定值，但集合可能包含多个值。我们将讨论在<a class="ae km" href="https://www.technologiesinindustry4.com/" rel="noopener ugc nofollow" target="_blank"> Rust </a>程序中最常用的三个集合:<br/> 1。一个矢量<br/> 2。一串<br/> 3。哈希映射</p><h2 id="4dd8" class="kn ir hi bd is ko kp kq iw kr ks kt ja jz ku kv je kd kw kx ji kh ky kz jm la bi translated">1.向量:</h2><p id="10b4" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">允许我们相邻存储可变数量的值。</p><h2 id="efc0" class="kn ir hi bd is ko kp kq iw kr ks kt ja jz ku kv je kd kw kx ji kh ky kz jm la bi translated">2.字符串:</h2><p id="6f3f" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">是字符的集合。</p><h2 id="e600" class="kn ir hi bd is ko kp kq iw kr ks kt ja jz ku kv je kd kw kx ji kh ky kz jm la bi translated">3.哈希映射:</h2><p id="8895" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">允许我们将一个值与一个特定的键相关联。这是更一般的数据结构(称为映射)的一个特殊实现。</p><h1 id="e412" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">存储值列表</h1><p id="8ee8" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">我们将研究的是Vec <t>，也被称为第一个集合的向量。</t></p><h2 id="3dd2" class="kn ir hi bd is ko kp kq iw kr ks kt ja jz ku kv je kd kw kx ji kh ky kz jm la bi translated">向量</h2><p id="1695" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">向量允许我们在一个数据结构中存储不止一个值，这个数据结构将所有的值一个接一个地放在内存中。<a class="ae km" href="https://www.technologiesinindustry4.com/" rel="noopener ugc nofollow" target="_blank">向量只能存储相同类型的值。当我们有一个项目列表时，它们很有用。</a></p><pre class="lb lc ld le fd lf lg lh li aw lj bi"><span id="efcb" class="kn ir hi lg b fi lk ll l lm ln"><strong class="lg hj">Creating The Empty Vector:</strong><br/>fn main() {<br/>let v: Vec&lt;i32&gt; = Vec::new():<br/>}<br/>Creating The Vector Containing Values:<br/>fn main() {<br/>let v = vec![1,2,3];<br/>println!("The First Value is = {},<br/>Second Value is = {},Third Value is<br/>= {} ",v[0], v[1], v[2]);<br/>}</span><span id="7171" class="kn ir hi lg b fi lo ll l lm ln"><strong class="lg hj">Updating the Vector</strong><br/>fn main() {                          // Generating The Empty Vector and Pushing The Value<br/>let mut v1 = Vec::new();<br/>v1.push(5);<br/>v1.push(6);<br/>v1.push(7);<br/>v1.push(8);<br/>println!("Empty Vector v1 having no value after</span><span id="44fb" class="kn ir hi lg b fi lo ll l lm ln">Value pushing in Vector v1 {}, {} , {}, {}",<br/>v1[0], v1[1], v1[2], v1[3]);<br/>}</span><span id="0873" class="kn ir hi lg b fi lo ll l lm ln">fn main() {<br/>// Creating Vector Having Some Value<br/>let mut v = vec![1, 2, 3];<br/>v.push(4);<br/>v.push(5);<br/>v.push(6);<br/>v.push(7);<br/>println!("The Vector having Value is {}, {}, {}</span><span id="e328" class="kn ir hi lg b fi lo ll l lm ln">After Value pushing The Vector v Value is {}, {}, {}, {} ",<br/>v[0], v[1], v[2], v[3], v[4], v[5], v[6]);<br/>}</span></pre><h2 id="b442" class="kn ir hi bd is ko kp kq iw kr ks kt ja jz ku kv je kd kw kx ji kh ky kz jm la bi translated">读取向量的元素:</h2><pre class="lb lc ld le fd lf lg lh li aw lj bi"><span id="303a" class="kn ir hi lg b fi lk ll l lm ln">fn main() {<br/>let v = vec![1, 2, 3, 4, 5];<br/>let third: &amp;i32 = &amp;v[2];<br/>println!("The third element is {}", third);<br/>match v.get(2) {<br/>Some(third) =&gt; println!("The third element is {}",<br/>third),<br/>None =&gt; println!("There is no third element."),<br/>}<br/>}</span></pre><h2 id="d5b8" class="kn ir hi bd is ko kp kq iw kr ks kt ja jz ku kv je kd kw kx ji kh ky kz jm la bi translated">阅读元素(惊慌失措):</h2><pre class="lb lc ld le fd lf lg lh li aw lj bi"><span id="2bd0" class="kn ir hi lg b fi lk ll l lm ln">fn main() {<br/>let v = vec![1, 2, 3, 4, 5];<br/>let does_not_exist = &amp;v[100];<br/>let does_not_exist = v.get(100);<br/>}</span></pre><h2 id="f58c" class="kn ir hi bd is ko kp kq iw kr ks kt ja jz ku kv je kd kw kx ji kh ky kz jm la bi translated">读取元素(错误):</h2><pre class="lb lc ld le fd lf lg lh li aw lj bi"><span id="22f1" class="kn ir hi lg b fi lk ll l lm ln">fn main() {<br/>let v = vec![1, 2, 3, 4, 5];<br/>Let first = &amp;v[0];<br/>v.push(6);<br/>println!(“The First Element is: {}, First);<br/>}</span></pre><h2 id="c04f" class="kn ir hi bd is ko kp kq iw kr ks kt ja jz ku kv je kd kw kx ji kh ky kz jm la bi translated">迭代向量中的值:</h2><pre class="lb lc ld le fd lf lg lh li aw lj bi"><span id="1a89" class="kn ir hi lg b fi lk ll l lm ln">fn<br/>main() {<br/>let v = vec![100, 32, 57];<br/>for i in &amp;v {<br/>println!(“{}”,i);<br/>}<br/>}</span></pre><h2 id="ba6b" class="kn ir hi bd is ko kp kq iw kr ks kt ja jz ku kv je kd kw kx ji kh ky kz jm la bi translated">迭代向量中的可变引用:</h2><pre class="lb lc ld le fd lf lg lh li aw lj bi"><span id="bd05" class="kn ir hi lg b fi lk ll l lm ln">fn main() {<br/>let v = vec![10, 20, 30];<br/>for i in &amp;mut v6 {<br/>*i += 50;<br/>println!(“{}”,i);<br/>}<br/>}</span></pre><h2 id="6336" class="kn ir hi bd is ko kp kq iw kr ks kt ja jz ku kv je kd kw kx ji kh ky kz jm la bi translated">使用枚举存储多个</h2><p id="d84b" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">向量只能存储相同类型的值。这可能是可访问的类型；肯定有需要存储不同类型的项目列表的用例。<a class="ae km" href="https://www.technologiesinindustry4.com/" rel="noopener ugc nofollow" target="_blank">一个enum的可变变量是在同一个enum类型下定义的</a>，所以当我们需要在一个vector中存储不同类型的元素时，我们可以定义并使用一个enum！</p><h2 id="98d7" class="kn ir hi bd is ko kp kq iw kr ks kt ja jz ku kv je kd kw kx ji kh ky kz jm la bi translated">用字符串存储UTF-8编码的文本</h2><p id="b253" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">什么是字符串？</p><p id="7b87" class="pw-post-body-paragraph jo jp hi jq b jr lp jt ju jv lq jx jy jz lr kb kc kd ls kf kg kh lt kj kk kl hb bi translated">在Rust中，有两种类型的字符串:String和&amp;str。这是堆分配的，flourishale的，不是空终止的。&amp;str是一个片段(&amp;[u8])，它指向一个有效的UTF-8序列，可以用来查看一个字符串，就像&amp;[T]是一个Vec <t>的视图一样。</t></p><p id="c2b8" class="pw-post-body-paragraph jo jp hi jq b jr lp jt ju jv lq jx jy jz lr kb kc kd ls kf kg kh lt kj kk kl hb bi translated">核心语言中的<a class="ae km" href="https://www.technologiesinindustry4.com/" rel="noopener ugc nofollow" target="_blank"> Rust </a>只有一种字符串类型，就是通常在其借用形式&amp; str中看到的字符串切片str。我们已经讨论了字符串片段，它们是对存储在其他地方的一些UTF-8编码的字符串数据的引用。例如，字符串文字存储在程序的二进制文件中，因此是字符串片。</p><h2 id="64a5" class="kn ir hi bd is ko kp kq iw kr ks kt ja jz ku kv je kd kw kx ji kh ky kz jm la bi translated">创建字符串:</h2><pre class="lb lc ld le fd lf lg lh li aw lj bi"><span id="296d" class="kn ir hi lg b fi lk ll l lm ln">fn main() {<br/>let s = String::new();<br/>println!("Creating a Empty String: {}", s);<br/>let data = "initial contents";<br/>let s = data.to_string();<br/>println!("The Value of s: {}", s);<br/>{<br/>// method do works on a literal directly:<br/>let d = String::from(“initial contents);<br/>println!("The Value of d: {}", d);<br/>}<br/>}</span></pre><h2 id="be7b" class="kn ir hi bd is ko kp kq iw kr ks kt ja jz ku kv je kd kw kx ji kh ky kz jm la bi translated">更新字符串:</h2><pre class="lb lc ld le fd lf lg lh li aw lj bi"><span id="7632" class="kn ir hi lg b fi lk ll l lm ln">#![allow(unused_variables)]<br/>fn main() {<br/>let mut s1 = String::from("foo");<br/>let s2 = "bar";<br/>s1.push_str(s2);<br/>println!("s2 is {}", s2);<br/>}</span></pre><h2 id="47cd" class="kn ir hi bd is ko kp kq iw kr ks kt ja jz ku kv je kd kw kx ji kh ky kz jm la bi translated">运算符串联:</h2><pre class="lb lc ld le fd lf lg lh li aw lj bi"><span id="3063" class="kn ir hi lg b fi lk ll l lm ln">fn main(){<br/>let s1 = String::from("Hello, ");<br/>let s2 = String::from("world!");<br/>let s3 = s1 + &amp;s2;<br/>println!("{}",s3);<br/>}</span><span id="6a32" class="kn ir hi lg b fi lo ll l lm ln"> fn main (){<br/>let s1 = String::from("tic");<br/>let s2 = String::from("tac");<br/>let s3 = String::from("toe");<br/>let s = s1 + "-" + &amp;s2 + "-" + &amp;s3;<br/>println!("{}",s);<br/>}</span></pre><h2 id="de2d" class="kn ir hi bd is ko kp kq iw kr ks kt ja jz ku kv je kd kw kx ji kh ky kz jm la bi translated">与格式宏连接</h2><pre class="lb lc ld le fd lf lg lh li aw lj bi"><span id="ace2" class="kn ir hi lg b fi lk ll l lm ln">fn main() {<br/>let s1 = String::from("tic");<br/>let s2 = String::from("tac");<br/>let s3 = String::from("toe");<br/>let s = format!("{}-{}-{}", s1, s2, s3);<br/>}</span></pre><h2 id="a29b" class="kn ir hi bd is ko kp kq iw kr ks kt ja jz ku kv je kd kw kx ji kh ky kz jm la bi translated">编入字符串的索引:</h2><pre class="lb lc ld le fd lf lg lh li aw lj bi"><span id="aaf6" class="kn ir hi lg b fi lk ll l lm ln">fn main (){<br/>let s1 = String::from("hello");<br/>let h = s1[0];<br/>}<br/>This code will result error:<br/>Rust strings don’t support indexing. <a class="ae km" href="https://www.technologiesinindustry4.com/" rel="noopener ugc nofollow" target="_blank">But why not? </a>We need to discuss how Rust stores strings in memory to answer the question.</span></pre><h2 id="4e8c" class="kn ir hi bd is ko kp kq iw kr ks kt ja jz ku kv je kd kw kx ji kh ky kz jm la bi translated">字符串字节存储:</h2><pre class="lb lc ld le fd lf lg lh li aw lj bi"><span id="4739" class="kn ir hi lg b fi lk ll l lm ln">fn main (){<br/>let len = String::from("Hola").len();<br/>println!("{}",len);<br/>{<br/>let len = String::from("Здравствуйте").len();<br/>println!("{}",len);<br/>}<br/>}</span></pre><h2 id="769b" class="kn ir hi bd is ko kp kq iw kr ks kt ja jz ku kv je kd kw kx ji kh ky kz jm la bi translated">字节、标量值和字形簇:</h2><p id="8f82" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">在《UTF-8》中，有三种方法可以从Rust的角度来看待弦乐:<br/> 1。按字节<br/> 2。按标量<br/> 3。按字形聚类</p><pre class="lb lc ld le fd lf lg lh li aw lj bi"><span id="4649" class="kn ir hi lg b fi lk ll l lm ln"><strong class="lg hj">SLICING STRING:</strong><br/>fn main (){<br/>let hello = "Здравствуйте";<br/>let s = &amp;hello[0..4];<br/>println!("{}",s)<br/>}</span><span id="2aa1" class="kn ir hi lg b fi lo ll l lm ln"><strong class="lg hj">ITERATING OVER STRING:</strong><br/>fn main (){<br/>for c in "नमस्ते ".chars(){<br/>println!("{}", c);}<br/>{<br/>for b in "नमस्ते ".bytes() {<br/>println!("{}", b);}<br/>}<br/>}</span></pre><h2 id="3194" class="kn ir hi bd is ko kp kq iw kr ks kt ja jz ku kv je kd kw kx ji kh ky kz jm la bi translated">H A S H M A P</h2><p id="c9eb" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">类型K的键到类型V的值的映射存储在类型HashMap <k v="">中。<a class="ae km" href="https://www.technologiesinindustry4.com/" rel="noopener ugc nofollow" target="_blank">这一切都是通过哈希函数</a>完成的，哈希函数决定了如何将这些键和值放入内存。当我们不想像使用向量那样使用索引而是使用任何类型的键来查找数据时，Hashmap就很有用。</k></p><h2 id="76ab" class="kn ir hi bd is ko kp kq iw kr ks kt ja jz ku kv je kd kw kx ji kh ky kz jm la bi translated">创建新的哈希映射</h2><pre class="lb lc ld le fd lf lg lh li aw lj bi"><span id="8e9c" class="kn ir hi lg b fi lk ll l lm ln">use std::collections::HashMap;<br/>fn main() {<br/>let mut scores = HashMap::new();<br/>scores.insert(String::from("Blue"), 10);<br/>scores.insert(String::from("Yellow"), 50);<br/>for (key, value) in &amp;scores {<br/>println!("{}: {}", key, value);<br/>}<br/>println!("{:?}", scores);<br/>}</span></pre><h2 id="71cd" class="kn ir hi bd is ko kp kq iw kr ks kt ja jz ku kv je kd kw kx ji kh ky kz jm la bi translated">创建新散列图的另一种方法</h2><pre class="lb lc ld le fd lf lg lh li aw lj bi"><span id="2ae9" class="kn ir hi lg b fi lk ll l lm ln">use std::collections::HashMap;<br/>fn main() {<br/>let teams = vec![String::from("Blue"), String::from("Yellow")];<br/>let initial_scores = vec![10, 50];<br/>let scores: HashMap&lt;_, _&gt; = teams.iter().zip(initial_scores.iter()).collect();<br/>for (key, value) in &amp;scores {<br/>println!("{}: {}", key, value);<br/>}<br/>println!("{:?}", scores);<br/>}</span></pre><h2 id="abdb" class="kn ir hi bd is ko kp kq iw kr ks kt ja jz ku kv je kd kw kx ji kh ky kz jm la bi translated">哈希映射和所有权</h2><pre class="lb lc ld le fd lf lg lh li aw lj bi"><span id="7715" class="kn ir hi lg b fi lk ll l lm ln">use std::collections::HashMap;<br/>fn main() {<br/>let field_name = String::from("Favorite color");<br/>let field_value = String::from("Blue");<br/>let mut map = HashMap::new();<br/>map.insert(field_name, field_value);<br/>println!("{:?}", map);<br/>}</span></pre><h2 id="5f59" class="kn ir hi bd is ko kp kq iw kr ks kt ja jz ku kv je kd kw kx ji kh ky kz jm la bi translated">访问哈希映射中的值</h2><pre class="lb lc ld le fd lf lg lh li aw lj bi"><span id="9055" class="kn ir hi lg b fi lk ll l lm ln">use std::collections::HashMap;<br/>fn main(){<br/>let mut scores = HashMap::new();<br/>scores.insert(String::from("Blue"), 10);<br/>scores.insert(String::from("Yellow"), 50);<br/>let team_name = String::from("Blue");<br/>let score = scores.get(&amp;team_name);<br/>for (key, value) in &amp;scores {<br/>println!("{}: {}", key, value);<br/>}<br/>println!("{:?}", score);<br/>}</span></pre><h2 id="f30b" class="kn ir hi bd is ko kp kq iw kr ks kt ja jz ku kv je kd kw kx ji kh ky kz jm la bi translated">更新哈希映射覆盖值:</h2><pre class="lb lc ld le fd lf lg lh li aw lj bi"><span id="f998" class="kn ir hi lg b fi lk ll l lm ln">use std::collections::HashMap;<br/>fn main()<br/>{<br/>let mut scores = HashMap::new();<br/>scores.insert(String::from("Blue"), 10);<br/>println!("{:?}", scores);<br/>scores.insert(String::from("Blue"), 25);<br/>println!("{:?}", scores);<br/>}</span></pre><h2 id="b3c9" class="kn ir hi bd is ko kp kq iw kr ks kt ja jz ku kv je kd kw kx ji kh ky kz jm la bi translated">更新哈希映射插入值:</h2><pre class="lb lc ld le fd lf lg lh li aw lj bi"><span id="7dfe" class="kn ir hi lg b fi lk ll l lm ln">use std::collections::HashMap;<br/>fn main(){<br/>let mut scores = HashMap::new();<br/>scores.insert(String::from("Blue"), 10);<br/>scores.entry(String::from("Yellow")).or_insert(50);<br/>scores.entry(String::from("Blue")).or_insert(50);<br/>println!("{:?}", scores);<br/>}</span></pre><h2 id="53e6" class="kn ir hi bd is ko kp kq iw kr ks kt ja jz ku kv je kd kw kx ji kh ky kz jm la bi translated">更新哈希映射更新值:</h2><pre class="lb lc ld le fd lf lg lh li aw lj bi"><span id="f5c0" class="kn ir hi lg b fi lk ll l lm ln">use std::collections::HashMap;<br/>fn main(){<br/>let text = "hello world wonderful world";<br/>let mut map = HashMap::new();<br/>for word in text.split_whitespace() {<br/>let count = map.entry(word).or_insert(0);<br/>*count += 1;<br/>}<br/>println!("{:?}", map);<br/>}</span></pre><p id="b390" class="pw-post-body-paragraph jo jp hi jq b jr lp jt ju jv lq jx jy jz lr kb kc kd ls kf kg kh lt kj kk kl hb bi translated">更多详情请访问:<a class="ae km" href="https://www.technologiesinindustry4.com/2020/11/what-are-common-collections-in-rust.html" rel="noopener ugc nofollow" target="_blank">https://www . technologiesinindustry 4 . com/2020/11/what-are-common-collections-in-rust . html</a></p></div></div>    
</body>
</html>