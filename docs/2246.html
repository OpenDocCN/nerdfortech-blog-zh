<html>
<head>
<title>Experimental Math — Computing Units of Modular Rings</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">实验数学模环的计算单位</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/experimental-math-computing-units-of-modular-rings-12bc4276fa74?source=collection_archive---------4-----------------------#2021-04-28">https://medium.com/nerd-for-tech/experimental-math-computing-units-of-modular-rings-12bc4276fa74?source=collection_archive---------4-----------------------#2021-04-28</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/75cd2a520bfda297c08a9e2dc68411f2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*M_oDOOFAOEZhXrTXeyDRbg.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">图片由<a class="ae iu" href="https://pixabay.com/?utm_source=link-attribution&amp;amp;utm_medium=referral&amp;amp;utm_campaign=image&amp;amp;utm_content=2574943" rel="noopener ugc nofollow" target="_blank">皮克斯拜</a>的Gerd Altmann 提供</figcaption></figure><p id="1ce2" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">一个<em class="jt">环</em>是一个模仿整数及其算术属性的代数结构。形式上，环被定义为由非空集、<strong class="ix hj"> S </strong>和两个运算组成的结构；对于<strong class="ix hj"> S </strong>中的所有<em class="jt"> x </em>、<em class="jt"> y </em>、<em class="jt"> z </em>，加法(<strong class="ix hj"> + </strong>)和乘法(<strong class="ix hj"> * </strong>)满足以下性质:</p><ol class=""><li id="4f7f" class="ju jv hi ix b iy iz jc jd jg jw jk jx jo jy js jz ka kb kc bi translated"><em class="jt"> x </em> + <em class="jt"> y </em>也是<strong class="ix hj"> S </strong> ( <em class="jt">追加</em>关闭)的成员</li><li id="c89d" class="ju jv hi ix b iy kd jc ke jg kf jk kg jo kh js jz ka kb kc bi translated"><em class="jt">x</em>+<em class="jt">y</em>=<em class="jt">y</em>+<em class="jt">x</em>(加法<em class="jt">交换性</em>)</li><li id="550c" class="ju jv hi ix b iy kd jc ke jg kf jk kg jo kh js jz ka kb kc bi translated"><em class="jt">x</em>+(<em class="jt">y</em>+<em class="jt">z</em>)=(<em class="jt">x</em>+<em class="jt">y</em>)+<em class="jt">z</em>(<em class="jt">相对于加法的关联性</em>)</li><li id="9d29" class="ju jv hi ix b iy kd jc ke jg kf jk kg jo kh js jz ka kb kc bi translated">有一个元素<strong class="ix hj"> 0 </strong>，使得<em class="jt">x</em>+<strong class="ix hj">0</strong>=<strong class="ix hj">0</strong>+<em class="jt">x</em>=<em class="jt">x</em>对于<strong class="ix hj"> S </strong>中的所有<em class="jt"> x </em>(相对于加法的<em class="jt">标识元素)</em></li><li id="8310" class="ju jv hi ix b iy kd jc ke jg kf jk kg jo kh js jz ka kb kc bi translated">有一个元素<strong class="ix hj"> - </strong> <em class="jt"> x </em>，这样<em class="jt">x</em>+(<em class="jt">-x</em>)=<strong class="ix hj">0</strong>(<em class="jt">加法逆</em>)</li><li id="4565" class="ju jv hi ix b iy kd jc ke jg kf jk kg jo kh js jz ka kb kc bi translated"><em class="jt"> x </em> * <em class="jt"> y </em>也是S ( <em class="jt">乘法下的闭包</em>)的成员</li><li id="ca3e" class="ju jv hi ix b iy kd jc ke jg kf jk kg jo kh js jz ka kb kc bi translated"><em class="jt">x</em>*(<em class="jt">y</em>* z)=(x * y)* z(结合性)</li><li id="2035" class="ju jv hi ix b iy kd jc ke jg kf jk kg jo kh js jz ka kb kc bi translated">有一个元素<strong class="ix hj"> 1 </strong>，使得<strong class="ix hj"> S <br/> </strong>中的<em class="jt">x</em>*<strong class="ix hj">1</strong>=<strong class="ix hj">1</strong>*<em class="jt">x</em>=<em class="jt">x</em>(乘法<em class="jt">恒等式</em>)</li><li id="317d" class="ju jv hi ix b iy kd jc ke jg kf jk kg jo kh js jz ka kb kc bi translated"><em class="jt">x</em>*(<em class="jt">y</em>+<em class="jt">z</em>)=(<em class="jt">x</em>*<em class="jt">y</em>)+(<em class="jt">x</em>*<em class="jt">z</em>)(<em class="jt">左分配性</em>)</li><li id="d4fc" class="ju jv hi ix b iy kd jc ke jg kf jk kg jo kh js jz ka kb kc bi translated">(<em class="jt">y</em>+<em class="jt">z</em>)*<em class="jt">x</em>=(<em class="jt">y</em>*<em class="jt">x</em>)+(<em class="jt">z</em>*<em class="jt">x</em>)(<em class="jt">右分配性</em>)</li><li id="7713" class="ju jv hi ix b iy kd jc ke jg kf jk kg jo kh js jz ka kb kc bi translated"><em class="jt">x</em>*<em class="jt">y</em>=<em class="jt">y</em>*<em class="jt">x</em>(<em class="jt">乘法可换性</em> —可选)</li></ol><p id="7a8a" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">好长的房产清单啊？嗯，我们可以简单地说:环是这样的代数结构(<strong class="ix hj"> S </strong>，<strong class="ix hj"> + </strong>，<strong class="ix hj"> * </strong>)使得(<strong class="ix hj"> S </strong>，<strong class="ix hj"> + </strong>)是阿贝尔<a class="ae iu" href="https://tundeayodele.medium.com/a-first-look-at-groups-314ebb452005" rel="noopener">群</a> ( <em class="jt">性质1到5 </em>)并且(<strong class="ix hj"> S </strong>，<strong class="ix hj"> * </strong>)是<a class="ae iu" href="https://tundeayodele.medium.com/a-first-look-at-groups-314ebb452005" rel="noopener">幺半群</a> ( <em class="jt">性质)</em></p><p id="6410" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">由于环是以整数为模型的，显然，环的原型例子是整数的集合以及加法和乘法的通常算术运算。这组整数通常由字母<strong class="ix hj"> Z </strong>表示，来自于<strong class="ix hj"> Zahlen </strong>，德语中的数字。<br/> <strong class="ix hj"> Z </strong> = {… -5，-4，-3，-2，-1，0，1，2，3，4，5，6，7，…}。<br/> ( <strong class="ix hj"> Z </strong>、<strong class="ix hj"> + </strong>、<strong class="ix hj"> * </strong>)是一个环。作为一个练习，你可以确认这一点。</p><p id="ea5b" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">具有简单结构的环的另一个例子是由<strong class="ix hj"> Z/nZ </strong>或<strong class="ix hj"> Zₙ </strong>表示的模n 整数的集合。这只是当<strong class="ix hj"> n </strong>除以另一个整数时可能的余数的集合。例如<strong class="ix hj"> Z/6Z </strong> = <strong class="ix hj"> </strong> {0，1，2，3，4，5}。<br/>一般情况下，<strong class="ix hj"> Z/nZ </strong> ={0，1，2，.。。，<strong class="ix hj">n</strong>—1 }。进行环操作的是<em class="jt">mod</em><strong class="ix hj"><em class="jt">n</em></strong>。让我们称这种环为模环。您可以验证是否满足环属性集。</p><p id="9d97" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">还有许多其他环的例子，但我们想在本文中集中讨论<em class="jt">模块化环</em>。</p><h2 id="3bce" class="ki kj hi bd kk kl km kn ko kp kq kr ks jg kt ku kv jk kw kx ky jo kz la lb lc bi translated">环形单位</h2><p id="99cd" class="pw-post-body-paragraph iv iw hi ix b iy ld ja jb jc le je jf jg lf ji jj jk lg jm jn jo lh jq jr js hb bi translated">考虑以下乘法:2 *(1/2)= 1<br/>3 *(1/3)= 1<br/>4 *(1/4)= 1等等。<br/>我们看到，一个数乘以它的<em class="jt">倒数</em>得到<strong class="ix hj"> 1 </strong>(乘法恒等式)，这当然是倒数的定义所期望的，但事实是，倒数(或者更专业地说，<em class="jt">乘法倒数</em>)并不总是对所有的数都存在。整数环(<strong class="ix hj"> Z </strong>、<strong class="ix hj"> + </strong>、<strong class="ix hj"> * </strong>)中，3的倒数或乘逆是什么？(1/3)?编号(1/3)不是<strong class="ix hj"> Z </strong>的元素，因此不被接受。原来(<strong class="ix hj"> Z </strong>、<strong class="ix hj"> + </strong>、<strong class="ix hj"> * </strong>)中唯一有乘法逆运算的数是<strong class="ix hj"> -1 </strong>和<strong class="ix hj"> 1、</strong>，它们恰好是自己的逆运算；<strong class="ix hj"/><br/><strong class="ix hj">-1</strong>*-1 = 1<br/>T34】1* 1 = 1</p><p id="8470" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">具有乘法逆的环的元素被称为<strong class="ix hj">单位</strong>。环的单位集具有有趣的结构和一些重要的应用，例如，计算某些环的单位等价于寻找某些<a class="ae iu" href="https://en.wikipedia.org/wiki/Diophantine_equation" rel="noopener ugc nofollow" target="_blank">丢番图方程</a>的解。</p><h2 id="ec2d" class="ki kj hi bd kk kl km kn ko kp kq kr ks jg kt ku kv jk kw kx ky jo kz la lb lc bi translated">Z/nZ的计算单位</h2><p id="28a0" class="pw-post-body-paragraph iv iw hi ix b iy ld ja jb jc le je jf jg lf ji jj jk lg jm jn jo lh jq jr js hb bi translated">现在，让我们开始计算模环的单位，<strong class="ix hj"> Z/nZ </strong>。我们从一个特定的戒指开始，比如说<strong class="ix hj"> Z/9Z </strong>。似乎我们现在找到这些单位的唯一可用方法实际上是在<strong class="ix hj"> Z/9Z </strong>中执行所有可能的乘法，并检查哪些被乘数产生1。<br/> <strong class="ix hj"> Z/9Z </strong> ={0，1，2，3，4，5，6，7，8}。<br/>Z/9Z的乘法表如下所示。记住乘法是进行<em class="jt"> mod 9 </em>。</p><figure class="lj lk ll lm fd ij er es paragraph-image"><div class="er es li"><img src="../Images/2daf8ddb8c9d4a9b93ecf358b231e8d3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1068/format:webp/1*OhPsfxHN0tjBA8FViSQFuA.png"/></div></figure><p id="8f22" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">从表中我们可以看出，圆环的单位<strong class="ix hj"> Z/9Z </strong>是数字<br/> <strong class="ix hj"> 1 </strong>、<strong class="ix hj"> 2 </strong>、<strong class="ix hj"> 4 </strong>、<strong class="ix hj"> 5 </strong>、<strong class="ix hj"> 7 </strong>、<strong class="ix hj"> 8 </strong>。举个例子，从表中可以看出，<strong class="ix hj">2</strong>T17】*T19】5=<strong class="ix hj">1</strong>，所以<strong class="ix hj"> 2 </strong>和<strong class="ix hj"> 5 </strong>都是单位。<br/>表格中有64(8的平方)个非零结果单元格，意味着我们执行了64次乘法。通常，计算<strong class="ix hj"> Z/nZ </strong>的单位需要进行<strong class="ix hj"> (n-1) </strong>模乘运算。</p><p id="bd3b" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">当<strong class="ix hj"> n </strong>很大时，如果需要计算<strong class="ix hj"> Z/nZ </strong>的单位怎么办？手动构造乘法表是不可行的。这就是计算机代码的用武之地。我们将在Julia中写一个程序来帮助计算任意n的单位。程序逻辑遵循上述程序；在<strong class="ix hj"> Z/nZ </strong>中执行所有可能的乘法，并记录(存储在数组U中)产生1的被乘数。所以，我们需要两个循环——嵌套的；一个外循环用于顶行，一个内循环用于前导列(反之亦然)。我们将从1开始，不包括0，因为乘以0总会得到0。</p><figure class="lj lk ll lm fd ij"><div class="bz dy l di"><div class="ln lo l"/></div></figure><p id="0e25" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">下面是在<a class="ae iu" href="https://docs.julialang.org/en/v1/stdlib/REPL/" rel="noopener ugc nofollow" target="_blank">号上测试朱莉娅·REPL</a>的代码:</p><figure class="lj lk ll lm fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lp"><img src="../Images/56f991ab367f042d9be08767633a1fb0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8vajV0vUl4XggY5xxC6UeQ.png"/></div></div></figure><p id="7124" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">该代码将单位数组U显示为垂直列表，并指示数组中元素的数量。为了更好地格式化数组，我们可以使用<strong class="ix hj"> <em class="jt"> show() </em> </strong>函数，但是这次我们需要添加一个计数器来跟踪数组中元素的数量:</p><figure class="lj lk ll lm fd ij"><div class="bz dy l di"><div class="ln lo l"/></div></figure><figure class="lj lk ll lm fd ij er es paragraph-image"><div class="er es lq"><img src="../Images/af4bbffe39a8e4e3f2a6b597e9ccb819.png" data-original-src="https://miro.medium.com/v2/resize:fit:1394/format:webp/1*ZG2W3nOIphmKqSMSfN7QfQ.png"/></div></figure><p id="e8fe" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">所以，我们现在有了一个在Z/nZ中计算单位的程序。利用乘法在环中可交换的事实，可以提高程序的效率。有些多余的乘法运算我们可以省去；<br/> <strong class="ix hj"> 2 * 3 </strong>和<strong class="ix hj"> 3 * 2 </strong>是一个东西，我们只取一个，不用费心计算另一个。下图显示了冗余是如何产生的，并有助于确定节省的计算步骤，以及我们如何从代码中排除冗余。</p><figure class="lj lk ll lm fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lr"><img src="../Images/c301304373d906feae4dc66939dc7512.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nQbREwXITYRLi3Y5BRfmMA.png"/></div></div></figure><p id="6658" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在<em class="jt">块1，</em>循环的第一个周期，没有冗余。在<em class="jt">块2 </em>，<br/>，<strong class="ix hj"> 2 * 1 </strong>是多余的，因为<strong class="ix hj"> 1 * 2 </strong>已经在前一个块中计算过了。<br/>在<em class="jt">块3 </em>处，由于前两个块的操作，有2个冗余。一个块从每个前面的块获得一个冗余；在<em class="jt">块</em> <strong class="ix hj"> <em class="jt"> n </em> </strong>处，会有<strong class="ix hj"> <em class="jt"> n </em> -1 </strong>冗余。</p><p id="acc0" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">一般来说，对于<strong class="ix hj"> Z/nZ </strong>，会有<strong class="ix hj"> n-1 </strong>个块或循环周期，最后一个块(<strong class="ix hj"> n-1 </strong> ) <em class="jt">第</em>个块会有(<strong class="ix hj">n-1</strong>)-<strong class="ix hj">1</strong>=<strong class="ix hj">n-2</strong>个冗余。所以冗余总数将是:<br/>T =<strong class="ix hj">1+2+3+…+n-2</strong><br/>这是一个算术级数，有<strong class="ix hj"> n-2 </strong>项，第一项1，公差带1，最后一项<strong class="ix hj"> n-2 </strong>。利用等差数列的求和公式，我们得到:<br/>T =((n-2)/2)(1+n-2)=((n-2)/2)(n-1)</p><figure class="lj lk ll lm fd ij er es paragraph-image"><div class="er es ls"><img src="../Images/5079263863905499aed136597c44e0c5.png" data-original-src="https://miro.medium.com/v2/resize:fit:498/format:webp/1*Qvigx9rcTL80r0LcvdisOw.png"/></div></figure><p id="cf7b" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这代表了当我们修改程序时，计算步骤的节省。修改后的程序现在将进行<strong class="ix hj"> (n-1) -T </strong>模乘运算。</p><p id="66f1" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们如何修改我们的代码来免除多余的操作？我想把它作为一个练习。</p><p id="15b9" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们改进的单位计算算法还有改进的空间吗？即使去掉了多余的运算，感觉还是蛮力算法，更像是改进的“试乘法”。也许更多的理论会有所帮助。</p><p id="e4f2" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">根据单位的定义，<strong class="ix hj"> u </strong>是<strong class="ix hj"> Z/nZ </strong>的一个单位，如果有<strong class="ix hj"> Z/nZ </strong>的一个元素<strong class="ix hj">T5】IT7】，这样<strong class="ix hj">u<em class="jt">I</em>T13】≡1(mod<strong class="ix hj">n</strong>)。同余意味着有一个整数<strong class="ix hj"> <em class="jt"> k </em> </strong>使得<strong class="ix hj">u<em class="jt">I</em>-1 =<em class="jt">k</em>n</strong>或<strong class="ix hj">u<em class="jt">I</em>-<em class="jt">k</em>n = 1</strong>。设<strong class="ix hj"> <em class="jt"> d </em> </strong>为<strong class="ix hj"> u </strong>和<strong class="ix hj"> n </strong>的最大公约数(<em class="jt"> gcd </em>，也就是说<strong class="ix hj"> <em class="jt"> d </em> </strong>除以<strong class="ix hj"><em class="jt"/></strong>和<strong class="ix hj"> <em class="jt"> n </em> </strong>，因此除以<strong class="ix hj"> u <em class="jt"> i </em> - <em class="jt"> k而且由于<strong class="ix hj">u<em class="jt">I</em>-<em class="jt">k</em>n = 1</strong>，除数<strong class="ix hj"> <em class="jt"> d </em> </strong>必然等于1。如果两个数的<em class="jt"> gcd </em>为1，则这两个数<em class="jt">互质</em>，它们除了1没有公因数或除数。我们刚刚证明了<strong class="ix hj"> u </strong>和<strong class="ix hj"> n </strong>互质，这是<strong class="ix hj"> Z/nZ </strong>中单位的一个定义性质；<strong class="ix hj"> Z/nZ </strong>的单位与<strong class="ix hj"> n </strong>互质。但是每一个与<strong class="ix hj"> n </strong>互质的元素都是单位吗？我们也需要证明这一点。</em></strong></strong></strong></p><pre class="lj lk ll lm fd lt lu lv lw aw lx bi"><span id="b119" class="ki kj hi lu b fi ly lz l ma mb">Let <strong class="lu hj">v</strong> be an arbitrary element of <strong class="lu hj">Z/nZ</strong> that is relatively prime to <strong class="lu hj">n</strong>.<br/>That means gcd(<strong class="lu hj">v</strong>,<strong class="lu hj">n</strong>) = 1. <br/>Then, by <a class="ae iu" href="https://en.wikipedia.org/wiki/B%C3%A9zout%27s_identity" rel="noopener ugc nofollow" target="_blank">Bézout’s lemma</a>, there exist integers <em class="jt">x</em> and <em class="jt">y</em> such that<br/>vx + ny = 1<br/>ny = 1 - vx<br/>Since y is an integer, the last equation implies n divides 1 - vx (with a remainder of 0), in the language of congruences:<br/>1 - vx ≡ 0(mod n)<br/>1 ≡ vx(mod n)<br/><strong class="lu hj">vx ≡ 1(mod n)</strong>.<strong class="lu hj"> </strong>This implies<strong class="lu hj"> v </strong>is a unit in<strong class="lu hj"> Z/nZ </strong>which is what we wanted to prove.</span></pre><p id="7103" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">上述结果为我们提供了另一种计算<strong class="ix hj"> Z/nZ </strong>单位的方法；找出那些与<strong class="ix hj"> n </strong>互质的元素。如前所述，如果两个数字的最大公约数(gcd)等于1，则这两个数字是互质的，因此，我们的新算法将在通过<strong class="ix hj"> Z/nZ </strong>元素的循环中使用<em class="jt"> gcd </em>函数来检查互质性。<br/> Julia内置了<em class="jt"> gcd </em>函数，但是为了不显得我们在作弊，我们准备自己写<em class="jt"> gcd </em>函数，姑且称之为<strong class="ix hj"><em class="jt">ourowngcd</em></strong><em class="jt">。</em>它基于欧几里德算法计算gcd。</p><figure class="lj lk ll lm fd ij"><div class="bz dy l di"><div class="ln lo l"/></div></figure><p id="64f2" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">名为<em class="jt"> computeunitswithgcd </em>的新单位计算算法如下所示。</p><figure class="lj lk ll lm fd ij"><div class="bz dy l di"><div class="ln lo l"/></div></figure><p id="92c4" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这种新算法的一个明显的改进是不涉及乘法，只涉及模运算，而以前的算法既涉及乘法又涉及模运算。我们可以进一步加入一点智能优化，它只对偶数有效(<em class="jt">偶数大约有一半的时间出现，对吗？</em>)。如果<strong class="ix hj"> n </strong>是偶数，那么它不可能是偶数的互质，所以我们懒得去检查<strong class="ix hj"> Z/nZ </strong>的偶数元素是否互质。我们跳过偶数，循环1，3，5，7…而不是循环1，2，3，4…<br/>这大约减少了50%的循环周期。优化后的代码如下所示。检查<strong class="ix hj"> n </strong>在开始时是否是偶数，如果是，则将循环步长设置为2，而不是默认的1。</p><figure class="lj lk ll lm fd ij"><div class="bz dy l di"><div class="ln lo l"/></div></figure><p id="747d" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><em class="jt"> computeunitswithgcd(n) </em>是否是比<em class="jt"> computeunits(n) </em>更高效的算法？您可以通过比较两种算法对于几个相当大的<em class="jt"> n </em>的执行时间来找到实验结果。</p><h2 id="edc6" class="ki kj hi bd kk kl km kn ko kp kq kr ks jg kt ku kv jk kw kx ky jo kz la lb lc bi translated">单位组</h2><p id="16bd" class="pw-post-body-paragraph iv iw hi ix b iy ld ja jb jc le je jf jg lf ji jj jk lg jm jn jo lh jq jr js hb bi translated">环的单位的一个有趣的性质是它们在乘法下形成一个群。前面算出的环<strong class="ix hj"> Z/9Z </strong>的单位集是{ <strong class="ix hj"> 1 </strong>，<strong class="ix hj"> 2 </strong>，<strong class="ix hj"> 4 </strong>，<strong class="ix hj"> 5 </strong>，<strong class="ix hj"> 7 </strong>，<strong class="ix hj"> 8 </strong> }，可以验证它满足闭性、结合律、恒等式和逆的群性质。</p><p id="4398" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">现在，让我们证明一般模环<strong class="ix hj"> Z/nZ </strong>或任何一种环的单位集<strong class="ix hj"> U </strong>构成一个群。运算就是乘法，<strong class="ix hj"> * </strong>。</p><p id="3978" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj"> <em class="jt">关闭</em> </strong>。我们想证明对于U的任意元素<strong class="ix hj"> a </strong>和<strong class="ix hj"> b </strong>，它们的乘积<br/><strong class="ix hj">a</strong>*<strong class="ix hj">b</strong><em class="jt"/>也在U中，换句话说我们想证明<strong class="ix hj">a</strong>*<strong class="ix hj">b</strong><em class="jt"/>也是一个单位，即它有一个乘法逆。</p><pre class="lj lk ll lm fd lt lu lv lw aw lx bi"><span id="3e9c" class="ki kj hi lu b fi ly lz l ma mb">Let A and B be the multiplicative inverses of a and b respectively. Then,<br/>(a*b)*(B*A)= a*(b*B)*A = a*1*A = a*A = 1<br/>(B*A)*(a*b)= B*(A*a)*b = B*1*b = B*b = 1<br/>[The above statements made use of the associative property of rings and the fact that the product of an element and its inverse is 1].<br/> <br/>From the two statements above, we can see that a*b has a multiplicative inverse, B*A, and is therefore a unit.</span></pre><p id="9c3a" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj"> <em class="jt">结合律。</em> </strong>结合性继承自环<strong class="ix hj"> Z/nZ </strong> <em class="jt">。</em></p><p id="e7ba" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj"> <em class="jt">认同。</em> </strong>标识元素1继承自环<strong class="ix hj"> Z/nZ </strong>。</p><p id="dc49" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj"> <em class="jt">逆。</em> </strong>顾名思义每个单位都有一个乘法逆。</p></div></div>    
</body>
</html>