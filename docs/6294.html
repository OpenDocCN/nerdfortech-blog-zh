<html>
<head>
<title>LeetCode — Subsets II</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">LeetCode —子集II</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/leetcode-subsets-ii-80dc4c8edf64?source=collection_archive---------1-----------------------#2022-01-30">https://medium.com/nerd-for-tech/leetcode-subsets-ii-80dc4c8edf64?source=collection_archive---------1-----------------------#2022-01-30</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><h1 id="0076" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">问题陈述</h1><p id="761a" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">给定一个可能包含重复项的整数数组<em class="kb"> nums </em>，返回<em class="kb">所有可能的子集(幂集)</em>。</p><p id="d0fc" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated">解集<strong class="jf hj">不能</strong>包含重复的子集。以<strong class="jf hj">任意顺序</strong>返回解决方案。</p><p id="8511" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated">问题陈述摘自:<a class="ae kh" href="https://leetcode.com/problems/subsets-ii" rel="noopener ugc nofollow" target="_blank">https://leetcode.com/problems/subsets-ii</a>。</p><p id="0e98" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated"><strong class="jf hj">例1: </strong></p><pre class="ki kj kk kl fd km kn ko kp aw kq bi"><span id="b8a0" class="kr ig hi kn b fi ks kt l ku kv">Input: nums = [1, 2, 2]<br/>Output: [[], [1], [1, 2], [1, 2, 2], [2], [2, 2]]</span></pre><p id="3f15" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated"><strong class="jf hj">例2: </strong></p><pre class="ki kj kk kl fd km kn ko kp aw kq bi"><span id="a418" class="kr ig hi kn b fi ks kt l ku kv">Input: nums = [0]<br/>Output: [[], [0]]</span></pre><p id="6259" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated"><strong class="jf hj">约束:</strong></p><pre class="ki kj kk kl fd km kn ko kp aw kq bi"><span id="92d2" class="kr ig hi kn b fi ks kt l ku kv">- 1 &lt;= nums.length &lt;= 10<br/>- -10 &lt;= nums[i] &lt;= 10</span></pre><h1 id="0b1b" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">说明</h1><h2 id="89eb" class="kr ig hi bd ih kw kx ky il kz la lb ip jo lc ld it js le lf ix jw lg lh jb li bi translated">追踪</h2><p id="66ac" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">解决这个问题的方法类似于我们之前的博客<a class="ae kh" href="https://alkeshghorpade.me/post/leetcode-generate-subsets" rel="noopener ugc nofollow" target="_blank"> LeetCode子集</a>。唯一的区别是，在生成子集时，我们需要排除重复的元素。</p><p id="40fd" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated">首先，我们将对nums数组进行排序。我们可以在递归调用子集生成器函数时排除重复的元素，也可以将子集标记为集合(集合是一种抽象数据类型，可以存储唯一的值)。</p><p id="424b" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated">我们先检查一下算法。</p><pre class="ki kj kk kl fd km kn ko kp aw kq bi"><span id="f6c4" class="kr ig hi kn b fi ks kt l ku kv">// subsetsWithDup(nums) function<br/>- sort nums array sort(nums.begin(),nums.end())</span><span id="9dc3" class="kr ig hi kn b fi lj kt l ku kv">- initialize vector&lt;int&gt; subset<br/>             set&lt;vector&lt;int&gt;&gt; result<br/>             vector&lt;vector&lt;int&gt;&gt; answer</span><span id="c482" class="kr ig hi kn b fi lj kt l ku kv">- call util function subsetsUtil(nums, result, subset, 0)</span><span id="676e" class="kr ig hi kn b fi lj kt l ku kv">- push set result in vector array<br/>  loop for(auto it:result)<br/>         answer.push_back(it)</span><span id="2a12" class="kr ig hi kn b fi lj kt l ku kv">- return answer</span><span id="43fc" class="kr ig hi kn b fi lj kt l ku kv">// subsetsUtil(nums, result, subset, index) function<br/>- insert subset in result<br/>  result.insert(subset)</span><span id="d2b2" class="kr ig hi kn b fi lj kt l ku kv">- loop for i = index; i &lt; nums.size(); i++<br/>  - subset.push_back(nums[i])</span><span id="828b" class="kr ig hi kn b fi lj kt l ku kv">  - subsetsUtil(nums, result, subset, i + 1)</span><span id="a8ee" class="kr ig hi kn b fi lj kt l ku kv">  - subset.pop_back()</span></pre><p id="d1b0" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated">让我们看看我们在<strong class="jf hj"> C++ </strong>、<strong class="jf hj"> Golang </strong>和<strong class="jf hj"> Javascript </strong>中的解决方案。<strong class="jf hj">注意:</strong>在C++解决方案中，子集是一个集合，而在Golang和Javascript中，它是一个普通的数组，我们忽略了重复的数组。</p><h2 id="9e62" class="kr ig hi bd ih kw kx ky il kz la lb ip jo lc ld it js le lf ix jw lg lh jb li bi translated">C++解决方案</h2><pre class="ki kj kk kl fd km kn ko kp aw kq bi"><span id="4a6f" class="kr ig hi kn b fi ks kt l ku kv">class Solution {<br/>public:<br/>    vector&lt;vector&lt;int&gt;&gt; subsetsWithDup(vector&lt;int&gt;&amp; nums) {<br/>        sort(nums.begin(),nums.end());<br/>        vector&lt;int&gt; subset;<br/>        set&lt;vector&lt;int&gt;&gt; result;</span><span id="820d" class="kr ig hi kn b fi lj kt l ku kv">        subsetsUtil(nums, result, subset, 0);</span><span id="af57" class="kr ig hi kn b fi lj kt l ku kv">        vector&lt;vector&lt;int&gt;&gt; answer;</span><span id="4df8" class="kr ig hi kn b fi lj kt l ku kv">        for(auto it:result){<br/>            answer.push_back(it);<br/>        }</span><span id="9a72" class="kr ig hi kn b fi lj kt l ku kv">        return answer;<br/>    }</span><span id="cbed" class="kr ig hi kn b fi lj kt l ku kv">public:<br/>    void subsetsUtil(vector&lt;int&gt;&amp; nums, set&lt;vector&lt;int&gt;&gt;&amp; result, vector&lt;int&gt;&amp; subset, int index) {<br/>        result.insert(subset);</span><span id="984a" class="kr ig hi kn b fi lj kt l ku kv">        for(int i = index; i &lt; nums.size(); i++){<br/>            subset.push_back(nums[i]);</span><span id="a6d3" class="kr ig hi kn b fi lj kt l ku kv">            subsetsUtil(nums, result, subset, i + 1);</span><span id="49c8" class="kr ig hi kn b fi lj kt l ku kv">            subset.pop_back();<br/>        }</span><span id="dec2" class="kr ig hi kn b fi lj kt l ku kv">        return;<br/>    }<br/>};</span></pre><h2 id="3b6c" class="kr ig hi bd ih kw kx ky il kz la lb ip jo lc ld it js le lf ix jw lg lh jb li bi translated">戈朗溶液</h2><pre class="ki kj kk kl fd km kn ko kp aw kq bi"><span id="cdf8" class="kr ig hi kn b fi ks kt l ku kv">func subsetsUtils(nums, subset []int, result *[][]int) {<br/>    cp := make([]int, len(subset))<br/>    copy(cp, subset)</span><span id="5e6f" class="kr ig hi kn b fi lj kt l ku kv">    *result = append(*result, cp)</span><span id="01d2" class="kr ig hi kn b fi lj kt l ku kv">    for i := 0; i &lt; len(nums); i++ {<br/>        subsetsUtils(nums[i+1:], append(subset, nums[i]), result)</span><span id="08b4" class="kr ig hi kn b fi lj kt l ku kv">        for ; i &lt; len(nums)-1 &amp;&amp; nums[i] == nums[i+1]; i++ {<br/>        }<br/>    }<br/>}</span><span id="27d9" class="kr ig hi kn b fi lj kt l ku kv">func subsetsWithDup(nums []int) [][]int {<br/>    sort.Ints(nums)</span><span id="04e8" class="kr ig hi kn b fi lj kt l ku kv">    var result [][]int<br/>    subset := make([]int, 0, len(nums))</span><span id="9ade" class="kr ig hi kn b fi lj kt l ku kv">    subsetsUtils(nums, subset, &amp;result)</span><span id="63c6" class="kr ig hi kn b fi lj kt l ku kv">    return result<br/>}</span></pre><h2 id="7dce" class="kr ig hi bd ih kw kx ky il kz la lb ip jo lc ld it js le lf ix jw lg lh jb li bi translated">Javascript解决方案</h2><pre class="ki kj kk kl fd km kn ko kp aw kq bi"><span id="7756" class="kr ig hi kn b fi ks kt l ku kv">var subsetsWithDup = function(nums) {<br/>    nums.sort((a, b) =&gt; a - b);</span><span id="d703" class="kr ig hi kn b fi lj kt l ku kv">    const result = [];</span><span id="1464" class="kr ig hi kn b fi lj kt l ku kv">    subsetsUtils(0, []);</span><span id="6ada" class="kr ig hi kn b fi lj kt l ku kv">    return result;</span><span id="a33a" class="kr ig hi kn b fi lj kt l ku kv">    function subsetsUtils (index, array) {<br/>        result.push([...array]);</span><span id="3b29" class="kr ig hi kn b fi lj kt l ku kv">        for (let i = index; i &lt; nums.length; i++) {<br/>            if (i &gt; index &amp;&amp; nums[i] == nums[i - 1]) {<br/>                continue;<br/>            }</span><span id="8db4" class="kr ig hi kn b fi lj kt l ku kv">            array.push(nums[i]);<br/>            subsetsUtils(i + 1, array);<br/>            array.pop();<br/>        }<br/>    }<br/>};</span></pre><p id="cc7f" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated">让我们试运行一下我们的算法，看看解决方案是如何工作的。</p><pre class="ki kj kk kl fd km kn ko kp aw kq bi"><span id="cf78" class="kr ig hi kn b fi ks kt l ku kv">Input: nums = [1, 2, 2]</span><span id="ea49" class="kr ig hi kn b fi lj kt l ku kv">Step 1: sort(nums.begin(),nums.end())<br/>        nums = [1, 2, 3]</span><span id="54fe" class="kr ig hi kn b fi lj kt l ku kv">Step 2: initialize vector&lt;int&gt; subset<br/>                   set&lt;vector&lt;int&gt;&gt; result</span><span id="32cc" class="kr ig hi kn b fi lj kt l ku kv">Step 3: subsetsUtil(nums, result, subset, 0)</span><span id="8023" class="kr ig hi kn b fi lj kt l ku kv">// in subsetsUtils function<br/>Step 4: result.push_back(subset)<br/>        result.push_back([])</span><span id="d2aa" class="kr ig hi kn b fi lj kt l ku kv">        result = [[]]</span><span id="8ce7" class="kr ig hi kn b fi lj kt l ku kv">        loop for i = index, i &lt; nums.size()<br/>        i = 0<br/>        0 &lt; 3<br/>        true</span><span id="e79e" class="kr ig hi kn b fi lj kt l ku kv">        subset.push_back(nums[i])<br/>        subset.push_back(nums[0])<br/>        subset.push_back(1)</span><span id="090b" class="kr ig hi kn b fi lj kt l ku kv">        subset = [1]</span><span id="8c42" class="kr ig hi kn b fi lj kt l ku kv">        subsetsUtil(nums, res, subset, i + 1)<br/>        subsetsUtil([1, 2, 2], [[]], [1], 0 + 1)<br/>        subsetsUtil([1, 2, 2], [[]], [1], 1)</span><span id="d088" class="kr ig hi kn b fi lj kt l ku kv">Step 5: result.push_back(subset)<br/>        result.push_back([1])</span><span id="df92" class="kr ig hi kn b fi lj kt l ku kv">        result = [[], [1]]</span><span id="ed31" class="kr ig hi kn b fi lj kt l ku kv">        loop for i = index, i &lt; nums.size()<br/>        i = 1<br/>        1 &lt; 3<br/>        true</span><span id="fff7" class="kr ig hi kn b fi lj kt l ku kv">        subset.push_back(nums[i])<br/>        subset.push_back(nums[1])<br/>        subset.push_back(2)</span><span id="a914" class="kr ig hi kn b fi lj kt l ku kv">        subset = [1, 2]</span><span id="314e" class="kr ig hi kn b fi lj kt l ku kv">        subsetsUtil(nums, res, subset, i + 1)<br/>        subsetsUtil([1, 2, 2], [[], [1]], [1, 2], 1 + 1)<br/>        subsetsUtil([1, 2, 2], [[], [1]], [1, 2], 2)</span><span id="da40" class="kr ig hi kn b fi lj kt l ku kv">Step 6: result.push_back(subset)<br/>        result.push_back([1, 2])</span><span id="30b6" class="kr ig hi kn b fi lj kt l ku kv">        result = [[], [1], [1, 2]]</span><span id="564a" class="kr ig hi kn b fi lj kt l ku kv">        loop for i = index, i &lt; nums.size()<br/>        i = 2<br/>        2 &lt; 3<br/>        true</span><span id="7050" class="kr ig hi kn b fi lj kt l ku kv">        subset.push_back(nums[i])<br/>        subset.push_back(nums[2])<br/>        subset.push_back(2)</span><span id="a26d" class="kr ig hi kn b fi lj kt l ku kv">        subset = [1, 2, 2]</span><span id="073c" class="kr ig hi kn b fi lj kt l ku kv">        subsetsUtil(nums, res, subset, i + 1)<br/>        subsetsUtil([1, 2, 2], [[], [1], [1, 2]], [1, 2, 2], 2 + 1)<br/>        subsetsUtil([1, 2, 2], [[], [1], [1, 2]], [1, 2, 2], 3)</span><span id="1c7d" class="kr ig hi kn b fi lj kt l ku kv">Step 7: result.push_back(subset)<br/>        result.push_back([1, 2, 3])</span><span id="ec6e" class="kr ig hi kn b fi lj kt l ku kv">        result = [[], [1], [1, 2], [1, 2, 3]]</span><span id="7b09" class="kr ig hi kn b fi lj kt l ku kv">        loop for i = index, i &lt; nums.size()<br/>        i = 3<br/>        3 &lt; 3<br/>        false</span><span id="8044" class="kr ig hi kn b fi lj kt l ku kv">Step 8: Here we backtrack to last line of Step 6 where<br/>        i = 2<br/>        subset = [1, 2, 2]</span><span id="d8a3" class="kr ig hi kn b fi lj kt l ku kv">        We execute the next line<br/>        subset.pop()</span><span id="32fc" class="kr ig hi kn b fi lj kt l ku kv">        subset = [1, 2]</span><span id="e12a" class="kr ig hi kn b fi lj kt l ku kv">Step 9: We backtrack to last line of Step 5 where<br/>        i = 1<br/>        subset = [1, 2]</span><span id="0e4e" class="kr ig hi kn b fi lj kt l ku kv">        We execute the next line<br/>        subset.pop()</span><span id="4246" class="kr ig hi kn b fi lj kt l ku kv">        subset = [1]</span><span id="8d46" class="kr ig hi kn b fi lj kt l ku kv">Step 10: For loop continues where we execute<br/>        loop for i = index, i &lt; nums.size()<br/>        i = 2<br/>        i &lt; nums.size()<br/>        2 &lt; 3<br/>        true</span><span id="a9b7" class="kr ig hi kn b fi lj kt l ku kv">        subset.push_back(nums[i])<br/>        subset.push_back(nums[2])<br/>        subset.push_back(2)</span><span id="8de9" class="kr ig hi kn b fi lj kt l ku kv">        subset = [1, 2]</span><span id="b4f6" class="kr ig hi kn b fi lj kt l ku kv">        subsetsUtil(nums, res, subset, i + 1)<br/>        subsetsUtil([1, 2, 2], [[], [1], [1, 2]], [1, 2], 2 + 1)<br/>        subsetsUtil([1, 2, 2], [[], [1], [1, 2]], [1, 2], 3)</span><span id="58ef" class="kr ig hi kn b fi lj kt l ku kv">Step 11: result.push_back(subset)<br/>         result.push_back([1, 2])</span><span id="c8c2" class="kr ig hi kn b fi lj kt l ku kv">         result = [[], [1], [1, 2], [1, 2, 2]]</span><span id="fcd3" class="kr ig hi kn b fi lj kt l ku kv">         loop for i = index, i &lt; nums.size()<br/>         i = 3<br/>         3 &lt; 3<br/>         false</span><span id="0b01" class="kr ig hi kn b fi lj kt l ku kv">Step 12: Here we backtrack to last line of Step 3 where<br/>         i = 0<br/>         subset = [1]</span><span id="4f65" class="kr ig hi kn b fi lj kt l ku kv">         We execute the next line<br/>         subset.pop()</span><span id="5dc9" class="kr ig hi kn b fi lj kt l ku kv">         subset = []</span><span id="6889" class="kr ig hi kn b fi lj kt l ku kv">Step 13: For loop continues where we execute<br/>         loop for i = index, i &lt; nums.size()<br/>         i = 1<br/>         i &lt; nums.size()<br/>         1 &lt; 3<br/>         true</span><span id="174f" class="kr ig hi kn b fi lj kt l ku kv">         subset.push_back(nums[i])<br/>         subset.push_back(nums[1])<br/>         subset.push_back(2)</span><span id="d88b" class="kr ig hi kn b fi lj kt l ku kv">         subset = [2]</span><span id="59a1" class="kr ig hi kn b fi lj kt l ku kv">         subsetsUtil(nums, res, subset, i + 1)<br/>         subsetsUtil([1, 2, 2], [[], [1], [1, 2]], [2], 1 + 1)<br/>         subsetsUtil([1, 2, 2], [[], [1], [1, 2]], [2], 2)</span><span id="a850" class="kr ig hi kn b fi lj kt l ku kv">Step 14: result.push_back(subset)<br/>         result.push_back([2])</span><span id="7dcc" class="kr ig hi kn b fi lj kt l ku kv">         result = [[], [1], [1, 2], [1, 2, 2], [1, 2], [2]]</span><span id="178f" class="kr ig hi kn b fi lj kt l ku kv">         loop for i = index, i &lt; nums.size()<br/>         i = 2<br/>         2 &lt; 3<br/>         true</span><span id="4c1f" class="kr ig hi kn b fi lj kt l ku kv">         subset.push_back(nums[i])<br/>         subset.push_back(nums[2])<br/>         subset.push_back(2)</span><span id="982e" class="kr ig hi kn b fi lj kt l ku kv">         subset = [2, 2]</span><span id="8fe9" class="kr ig hi kn b fi lj kt l ku kv">         subsetsUtil(nums, res, subset, i + 1)<br/>         subsetsUtil([1, 2, 2], [[], [1], [1, 2], [2]], [2, 2], 2 + 1)<br/>         subsetsUtil([1, 2, 2], [[], [1], [1, 2], [2]], [2, 2], 3)</span><span id="48de" class="kr ig hi kn b fi lj kt l ku kv">Step 15: result.push_back(subset)<br/>         result.push_back([2, 2])</span><span id="720b" class="kr ig hi kn b fi lj kt l ku kv">         result = [[], [1], [1, 2], [1, 2, 2], [2], [2, 2]]</span><span id="d00f" class="kr ig hi kn b fi lj kt l ku kv">         loop for i = index, i &lt; nums.size()<br/>         i = 3<br/>         3 &lt; 3<br/>         false</span><span id="8145" class="kr ig hi kn b fi lj kt l ku kv">Step 16: Here we backtrack to last line of Step 14 where<br/>         i = 2<br/>         subset = [2, 2]</span><span id="d2ed" class="kr ig hi kn b fi lj kt l ku kv">         We execute the next line<br/>         subset.pop()</span><span id="08ee" class="kr ig hi kn b fi lj kt l ku kv">         subset = [2]</span><span id="19bf" class="kr ig hi kn b fi lj kt l ku kv">Step 17: Here we backtrack to last line of Step 13 where<br/>         i = 1<br/>         subset = [2]</span><span id="1c4a" class="kr ig hi kn b fi lj kt l ku kv">         We execute the next line<br/>         subset.pop()</span><span id="3666" class="kr ig hi kn b fi lj kt l ku kv">         subset = []</span><span id="2f47" class="kr ig hi kn b fi lj kt l ku kv">Step 18: For loop continues where we execute<br/>         loop for i = index, i &lt; nums.size()<br/>         i = 2<br/>         i &lt; nums.size()<br/>         2 &lt; 3<br/>         true</span><span id="00ed" class="kr ig hi kn b fi lj kt l ku kv">         subset.push_back(nums[i])<br/>         subset.push_back(nums[2])<br/>         subset.push_back(2)</span><span id="af2f" class="kr ig hi kn b fi lj kt l ku kv">         subset = [2]</span><span id="219c" class="kr ig hi kn b fi lj kt l ku kv">         subsetsUtil(nums, res, subset, i + 1)<br/>         subsetsUtil([1, 2, 2], [[], [1], [1, 2], [2], [2, 2]], [2], 2 + 1)<br/>         subsetsUtil([1, 2, 2], [[], [1], [1, 2], [2], [2, 2]], [2], 3)</span><span id="63c3" class="kr ig hi kn b fi lj kt l ku kv">Step 19: result.push_back(subset)<br/>         result.push_back([2])</span><span id="d174" class="kr ig hi kn b fi lj kt l ku kv">         result = [[], [1], [1, 2], [1, 2, 2], [2], [2, 2]]</span><span id="65fd" class="kr ig hi kn b fi lj kt l ku kv">         loop for i = index, i &lt; nums.size()<br/>         i = 3<br/>         3 &lt; 3<br/>         false</span><span id="ae7f" class="kr ig hi kn b fi lj kt l ku kv">Step 20: We have no more stack entries left. We return to the main function.</span><span id="a15b" class="kr ig hi kn b fi lj kt l ku kv">Step 21: for(auto it:result){<br/>            answer.push_back(it);<br/>        }</span><span id="77a8" class="kr ig hi kn b fi lj kt l ku kv">        We push result Set to answer Vector.</span><span id="5dfe" class="kr ig hi kn b fi lj kt l ku kv">Step 22: return answer</span><span id="5b63" class="kr ig hi kn b fi lj kt l ku kv">So we return the answer as [[], [1], [1, 2], [1, 2, 2], [2], [2, 2]].</span></pre></div><div class="ab cl lk ll gp lm" role="separator"><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp"/></div><div class="hb hc hd he hf"><p id="2259" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated"><em class="kb">原载于</em><a class="ae kh" href="https://alkeshghorpade.me/post/leetcode-subsets-ii" rel="noopener ugc nofollow" target="_blank"><em class="kb">https://alkeshghorpade . me</em></a><em class="kb">。</em></p></div></div>    
</body>
</html>