<html>
<head>
<title>Android Tutorial Part 4: Using Apollo library to fetch data from a GraphQL endpoint</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Android 教程第 4 部分:使用 Apollo 库从 GraphQL 端点获取数据</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/android-tutorial-part-4-using-apollo-library-to-fetch-data-from-a-graphql-endpoint-a621dfd98564?source=collection_archive---------3-----------------------#2021-03-29">https://medium.com/nerd-for-tech/android-tutorial-part-4-using-apollo-library-to-fetch-data-from-a-graphql-endpoint-a621dfd98564?source=collection_archive---------3-----------------------#2021-03-29</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/94f7ac890ed7a1ce6c25de7b15781730.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kRfQ_qluaF58b8Ddd88dhw.jpeg"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">美国宇航局在<a class="ae iu" rel="noopener ugc nofollow" target="_blank" href="/s/photos/astronaut?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText"> Unsplash </a>拍摄的照片</figcaption></figure><p id="9436" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在<a class="ae iu" rel="noopener" href="/nerd-for-tech/android-tutorial-part-3-using-apollo-library-to-fetch-data-from-a-graphql-endpoint-616fda869560">第三部</a>中，我们完全实现了获取角色列表的屏幕。在这一部分，我们将为列表中的每个角色创建详细信息屏幕。</p><h1 id="5b19" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">回到 GraphQL 游乐场</h1><p id="e3df" class="pw-post-body-paragraph iv iw hi ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated">首先，显然对于字符细节屏幕，需要一个新的 GraphQL 查询。再次打开<a class="ae iu" href="https://www.graphqlbin.com/v2/new" rel="noopener ugc nofollow" target="_blank">https://www.graphqlbin.com/v2/new</a>然后再把瑞克&amp;莫蒂·格拉 QL 端点<a class="ae iu" href="https://rickandmortyapi.com/graphql" rel="noopener ugc nofollow" target="_blank">https://rickandmortyapi.com/graphql</a>放在那里。</p><p id="7673" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">再次查看文档选项卡。在那里您将找到对<strong class="ix hj">字符(…):字符</strong>的查询</p><figure class="kx ky kz la fd ij er es paragraph-image"><div class="er es kw"><img src="../Images/27fd077b733c5a15a31001ac1aeb8cd0.png" data-original-src="https://miro.medium.com/v2/resize:fit:762/format:webp/1*UQJFhGcg3Z6EguJfmKqOsw.png"/></div></figure><p id="d4cb" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">您会看到一个字符查询需要一个类型为<strong class="ix hj"> ID 为</strong>的参数。您是否注意到在类型<strong class="ix hj"> ID </strong>后面有一个感叹号。这意味着参数不是可选的，默认情况下 GraphQL 中的每个参数都是可选的。当有感叹号时，它不是可选的。如果你现在问自己，这个<strong class="ix hj"> ID </strong>类型长什么样。然后点击 id 字段下方的<strong class="ix hj">类型详细信息</strong>。</p><figure class="kx ky kz la fd ij er es paragraph-image"><div class="er es lb"><img src="../Images/fdc7870eace7f185981db5513441d5e0.png" data-original-src="https://miro.medium.com/v2/resize:fit:972/format:webp/1*-VCUws21xXg3iZ43ph45Cg.png"/></div></figure><p id="36c5" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在那里你可以得到更多的信息。ID 类型可以是字符串或整数。你可以决定通过什么。如果你问自己<strong class="ix hj"> ID </strong>的范围是多少。然后运行应用程序，看看字符列表，你会看到我们有一个从 1 到 20 的范围。当你再次查看<strong class="ix hj">类型的详细信息</strong>时，你会看到我们可以查询<em class="lc">名称</em>、<em class="lc">状态</em>、<em class="lc">物种</em>等等。</p><h1 id="a563" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">编写第二个 GraphQL 查询</h1><p id="e7d4" class="pw-post-body-paragraph iv iw hi ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated">是时候编写下一个 GraphQL 查询了。再次跳到左边的面板上。在左下方，您将看到另一个面板，其中有两个选项卡。打开<strong class="ix hj">选项卡查询变量</strong>。将有为字符查询保存的<strong class="ix hj"> ID </strong>参数。以一个大括号开始，然后用<strong class="ix hj"> <em class="lc">【字符化】:" 7" </em> </strong>表示将在查询中使用的变量名。数字 7 是角色的 id。如前所述，您可以编写 1 到 20 之间的任何整数(或字符串形式的数字)。然后用右花括号将它括起来。</p><pre class="kx ky kz la fd ld le lf lg aw lh bi"><span id="8d63" class="li ju hi le b fi lj lk l ll lm">{<br/> "characterId": "7"<br/>}</span></pre><p id="d0fd" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">之后，再次单击上面的面板以编写角色详细信息查询。</p><pre class="kx ky kz la fd ld le lf lg aw lh bi"><span id="461e" class="li ju hi le b fi lj lk l ll lm">query Character($characterId: ID!) {<br/>    character(id: $characterId) {<br/>        id<br/>        name<br/>        status<br/>        species<br/>        type<br/>        gender<br/>        image<br/>    }<br/>}</span></pre><p id="1d86" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">当你点击播放按钮，你应该会看到关于“阿布拉多夫林肯勒”的信息。请注意，我们在字符查询中访问带有<strong class="ix hj"> $ </strong>的查询变量<strong class="ix hj">，并且不要忘记在类型<strong class="ix hj"> ID </strong>后写一个感叹号。因为 ID<strong class="ix hj">不能是可选的，所以我们必须提供一个值。</strong></strong></p><figure class="kx ky kz la fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ln"><img src="../Images/15fc50f0aa136513dc874f21ddace968.png" data-original-src="https://miro.medium.com/v2/resize:fit:624/format:webp/1*xCQHm4Wyh9Y6KIZmSOrK7Q.png"/></div></div></figure><p id="b7a3" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">现在，我们知道查询工作正常，没有错误。复制<em class="lc">查询字符</em>，再次打开 Android Studio。确保您再次选择了<strong class="ix hj">项目</strong>视图。再次导航到<strong class="ix hj">graph QL</strong>-&gt;<strong class="ix hj">com</strong>-&gt;<strong class="ix hj">example</strong>-&gt;<strong class="ix hj">apollographql tutorial</strong>，在那里创建一个新的<strong class="ix hj"> Character.graphql </strong>文件。在该文件中粘贴查询字符。</p><figure class="kx ky kz la fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lo"><img src="../Images/76caf4bf5f9496e946db8b0cf12f1050.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6kDEdLnAXGagXIey5OZc4A.png"/></div></div></figure><p id="e678" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">再次点击<strong class="ix hj">构建</strong>-&gt;-<strong class="ix hj">清理项目</strong>，然后点击<strong class="ix hj">构建</strong>-&gt;-<strong class="ix hj">重建项目</strong>。之后，搜索生成的类<strong class="ix hj"> <em class="lc">字符查询</em> </strong>。在这个类中，您可以看到为查询生成的代码。</p><h1 id="de1e" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">使用<strong class="ak"> <em class="lp">字符查询 MVVM 建筑</em> </strong></h1><p id="f27e" class="pw-post-body-paragraph iv iw hi ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated">现在将生成的类<strong class="ix hj"><em class="lc">character query</em></strong>添加到 MVVM 架构中的每一层。从界面<strong class="ix hj"> <em class="lc">字符库</em> </strong>开始。添加一个通过字符串类型的 id 获取字符的方法。</p><pre class="kx ky kz la fd ld le lf lg aw lh bi"><span id="d5f0" class="li ju hi le b fi lj lk l ll lm">suspend fun queryCharacter(id: String): Response&lt;CharacterQuery.Data&gt;</span></pre><p id="f71c" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">现在<strong class="ix hj"><em class="lc">CharacterRepositoryImpl</em></strong>类会显示一个错误。因为我们必须实现这个方法。该方法的实现看起来很像<em class="lc"> queryCharactersList() </em>。唯一的区别是在<em class="lc"> query() </em>传递<strong class="ix hj"><em class="lc">character query(id)</em></strong></p><figure class="kx ky kz la fd ij"><div class="bz dy l di"><div class="lq lr l"/></div></figure><p id="277c" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">下一站是<strong class="ix hj"><em class="lc">character viewmodel</em>T3。在<strong class="ix hj"> <em class="lc">中添加 character viewmodel</em></strong><strong class="ix hj">LiveData</strong>进行<strong class="ix hj"> <em class="lc">字符查询。数据</em> </strong>。</strong></p><pre class="kx ky kz la fd ld le lf lg aw lh bi"><span id="d908" class="li ju hi le b fi lj lk l ll lm">private val _character by <em class="lc">lazy </em><strong class="le hj">{ </strong>MutableLiveData&lt;ViewState&lt;Response&lt;CharacterQuery.Data&gt;&gt;&gt;() <strong class="le hj">}<br/></strong>val character: LiveData&lt;ViewState&lt;Response&lt;CharacterQuery.Data&gt;&gt;&gt;<br/>    get() = _character</span></pre><p id="930f" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在<em class="lc"> queryCharactersList() </em>下面添加另一个方法，将结果传递给属性<em class="lc"> _character </em>。</p><figure class="kx ky kz la fd ij"><div class="bz dy l di"><div class="lq lr l"/></div></figure><h2 id="8e88" class="li ju hi bd jv ls lt lu jz lv lw lx kd jg ly lz kh jk ma mb kl jo mc md kp me bi translated">差不多完成了，只差设置视图了</h2><p id="a65d" class="pw-post-body-paragraph iv iw hi ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated">再次打开 CharacterAdapter，这里我们需要一个回调属性来知道打开哪个角色细节。</p><pre class="kx ky kz la fd ld le lf lg aw lh bi"><span id="1e53" class="li ju hi le b fi lj lk l ll lm">var onItemClicked: ((CharactersListQuery.Result) -&gt; Unit)? = null</span></pre><p id="b769" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">不要忘记在 RecyclerView 中为每张卡添加一个点击监听器。这个点击监听器将使用回调<strong class="ix hj"> onItemClicked </strong>来打开角色细节屏幕。</p><pre class="kx ky kz la fd ld le lf lg aw lh bi"><span id="44be" class="li ju hi le b fi lj lk l ll lm">override fun onBindViewHolder(holder: CharacterViewHolder, position: Int) {<br/>    holder.binding.<em class="lc">character </em>= getItem(position)<br/><br/>    val character = getItem(position)<br/>    holder.binding.<em class="lc">root</em>.setOnClickListener <strong class="le hj">{<br/>        </strong>onItemClicked?.invoke(character)<br/>    <strong class="le hj">}<br/><br/></strong>}</span></pre><h2 id="c654" class="li ju hi bd jv ls lt lu jz lv lw lx kd jg ly lz kh jk ma mb kl jo mc md kp me bi translated">创建 CharacterDetailsFragment 片段</h2><p id="987e" class="pw-post-body-paragraph iv iw hi ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated">进入<strong class="ix hj">包查看</strong>-&gt;-T22】ui。然后点击<strong class="ix hj">新建</strong>-&gt;-<strong class="ix hj">kot Lin 文件/类</strong>并创建<strong class="ix hj"><em class="lc">character details fragment</em></strong>。</p><pre class="kx ky kz la fd ld le lf lg aw lh bi"><span id="daad" class="li ju hi le b fi lj lk l ll lm">@ExperimentalCoroutinesApi<br/>@AndroidEntryPoint<br/>class CharacterDetailsFragment: Fragment() {<br/>   <br/>}</span></pre><p id="76ca" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们稍后将实现片段，现在让我们创建布局。进入<strong class="ix hj">RES</strong>T80】T34】布局。创建<strong class="ix hj">fragment _ character _ details . XML</strong>。</p><figure class="kx ky kz la fd ij"><div class="bz dy l di"><div class="lq lr l"/></div></figure><p id="2327" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如果你在 ImageView 上查看第 18 行，在 23 <strong class="ix hj"> app 上有这一行:imageUrl = " @ { query . character . image } "</strong>属性<em class="lc"> imageUrl </em>是自定义的。我们将在接下来的步骤中定义它。</p><p id="2298" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">再次打开<strong class="ix hj"><em class="lc">character adapter</em></strong>，在文件底部添加使用<strong class="ix hj"> </strong> <a class="ae iu" href="https://github.com/coil-kt/coil" rel="noopener ugc nofollow" target="_blank">线圈库</a> <strong class="ix hj">在<strong class="ix hj"> ImageView </strong>上设置图像 URL 的方法。</strong></p><pre class="kx ky kz la fd ld le lf lg aw lh bi"><span id="8364" class="li ju hi le b fi lj lk l ll lm">@BindingAdapter("imageUrl")<br/>fun setImageUrl(imageView: ImageView, url: String?) {<br/>    imageView.<em class="lc">load</em>(url) <strong class="le hj">{ </strong>crossfade(true) <strong class="le hj">}<br/></strong>}</span></pre><h2 id="86f7" class="li ju hi bd jv ls lt lu jz lv lw lx kd jg ly lz kh jk ma mb kl jo mc md kp me bi translated">启用从字符列表重定向以打开特定字符</h2><p id="ed8f" class="pw-post-body-paragraph iv iw hi ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated">为了打开一个特定的字符，我们必须在<strong class="ix hj"> <em class="lc"> nav_main.xml </em> </strong>中声明它。这里我们将向<strong class="ix hj"><em class="lc">character details fragment</em></strong>声明一个动作。在带有<strong class="ix hj">characters _ list _ fragment</strong>的片段标签中，将定义重定向的动作。</p><figure class="kx ky kz la fd ij"><div class="bz dy l di"><div class="lq lr l"/></div></figure><p id="f481" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">id<strong class="ix hj">character _ details _ fragment</strong>将会是红色的，因为当前没有具有该 id 的片段标签。</p><p id="226c" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在标签<strong class="ix hj">characters _ list _ fragment</strong>下面，创建 id 为<strong class="ix hj">character _ details _ fragment</strong>的片段标签，并带有一个字符串类型和名称 id 的参数。</p><figure class="kx ky kz la fd ij"><div class="bz dy l di"><div class="lq lr l"/></div></figure><p id="d0a2" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">下面是<strong class="ix hj"> <em class="lc"> nav_main.xml </em> </strong>的总结</p><figure class="kx ky kz la fd ij"><div class="bz dy l di"><div class="lq lr l"/></div></figure><h2 id="0732" class="li ju hi bd jv ls lt lu jz lv lw lx kd jg ly lz kh jk ma mb kl jo mc md kp me bi translated">实现 character details fragment<strong class="ak"><em class="lp">的时间。</em>T77】</strong></h2><p id="d65b" class="pw-post-body-paragraph iv iw hi ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated">再次打开<strong class="ix hj"><em class="lc">character details fragment</em></strong>，添加三个属性。一个<strong class="ix hj"> <em class="lc">类型的 FragmentCharacterDetailsBinding</em></strong>，一个<strong class="ix hj"> <em class="lc">类型的 CharacterDetailsFragmentArgs</em></strong>和一个<strong class="ix hj"> <em class="lc">类型的 CharacterViewModel </em> </strong>。</p><pre class="kx ky kz la fd ld le lf lg aw lh bi"><span id="d832" class="li ju hi le b fi lj lk l ll lm">private lateinit var binding: FragmentCharacterDetailsBinding<br/>private val args: CharacterDetailsFragmentArgs by <em class="lc">navArgs</em>()<br/>private val viewModel by <em class="lc">viewModels</em>&lt;CharacterViewModel&gt;()</span></pre><p id="e162" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">实现<em class="lc"> onCreateView() </em>并在那里使用视图绑定。</p><pre class="kx ky kz la fd ld le lf lg aw lh bi"><span id="ae69" class="li ju hi le b fi lj lk l ll lm">override fun onCreateView(<br/>    inflater: LayoutInflater, container: ViewGroup?,<br/>    savedInstanceState: Bundle?<br/>): View {<br/>    binding = FragmentCharacterDetailsBinding.inflate(inflater)<br/>    return binding.<em class="lc">root<br/></em>}</span></pre><p id="1c08" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">然后覆盖<em class="lc"> onViewCreated() </em>首先从 ViewModel 调用<em class="lc"> queryCharacter() </em>方法。<em class="lc"> queryCharacter() </em>的参数是<strong class="ix hj"> args </strong>属性的<strong class="ix hj"> id </strong>属性。最后但同样重要的是，再次创建一个<em class="lc"> observeLiveData() </em>方法。</p><pre class="kx ky kz la fd ld le lf lg aw lh bi"><span id="51ae" class="li ju hi le b fi lj lk l ll lm">override fun onViewCreated(view: View, savedInstanceState: Bundle?) {<br/>    super.onViewCreated(view, savedInstanceState)<br/><br/>    viewModel.queryCharacter(args.id)<br/>    observeLiveData()<br/>}</span></pre><p id="61da" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><em class="lc"> observeLiveData() </em>方法包含与<strong class="ix hj"><em class="lc">characters list fragment</em></strong>类几乎相同的逻辑。加载数据时首先显示进度条，然后显示数据或显示错误文本。</p><figure class="kx ky kz la fd ij"><div class="bz dy l di"><div class="lq lr l"/></div></figure><h1 id="4ee1" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">最后要实现的东西</h1><p id="5900" class="pw-post-body-paragraph iv iw hi ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated">只差一个实现了。打开最后一次 CharactersListFragment，转到<em class="lc"> observeLiveData() </em>下面的方法 onViewCreated()调用<strong class="ix hj"> characterAdapter </strong>的回调属性<strong class="ix hj"> onItemClicked </strong>。在那里，您必须管理到 CharacterDetailsFragment 的导航。</p><figure class="kx ky kz la fd ij"><div class="bz dy l di"><div class="lq lr l"/></div></figure><p id="1af0" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">当您现在运行应用程序并点击其中一个卡片项目时。</p><figure class="kx ky kz la fd ij er es paragraph-image"><div class="er es mf"><img src="../Images/9812554f783b2216894ab78fd09e37b2.png" data-original-src="https://miro.medium.com/v2/resize:fit:450/format:webp/1*8XR-WFUDmiyyib6b03Gimg.png"/></div></figure><p id="3463" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">当点击列表中的第一张卡片时，您应该会看到这样的结果。</p><p id="ab35" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">就是这样！祝贺迄今为止的成绩！我希望这篇教程对你有用。如果你喜欢，别忘了给我鼓掌。这里是已完成的项目，你可以结帐分公司<strong class="ix hj"> part_four </strong>:</p><div class="mg mh ez fb mi mj"><a href="https://github.com/fahrican/ApolloGraphQlTutorial/tree/part_four" rel="noopener  ugc nofollow" target="_blank"><div class="mk ab dw"><div class="ml ab mm cl cj mn"><h2 class="bd hj fi z dy mo ea eb mp ed ef hh bi translated">fahrican/apollographql 教程</h2><div class="mq l"><h3 class="bd b fi z dy mo ea eb mp ed ef dx translated">在 GitHub 上创建一个帐户，为 fahrican/apollographqlturtutorial 开发做贡献。</h3></div><div class="mr l"><p class="bd b fp z dy mo ea eb mp ed ef dx translated">github.com</p></div></div><div class="ms l"><div class="mt l mu mv mw ms mx io mj"/></div></div></a></div><h1 id="eb5a" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">感谢</h1><p id="7259" class="pw-post-body-paragraph iv iw hi ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated">特别感谢<a class="ae iu" href="https://rickandmortyapi.com/" rel="noopener ugc nofollow" target="_blank">Rick 和 Morty API </a>为他们的<a class="ae iu" href="https://rickandmortyapi.com/documentation/#graphql" rel="noopener ugc nofollow" target="_blank"> GraphQL API </a>和<a class="ae iu" href="https://rickandmortyapi.com/graphql" rel="noopener ugc nofollow" target="_blank"> GraphQL Playground </a>提供文档。</p></div></div>    
</body>
</html>