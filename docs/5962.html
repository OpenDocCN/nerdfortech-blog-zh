<html>
<head>
<title>CQRS Pattern Implementation</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">CQRS 模式实现</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/cqrs-pattern-implementation-64fd88b96720?source=collection_archive---------1-----------------------#2021-12-12">https://medium.com/nerd-for-tech/cqrs-pattern-implementation-64fd88b96720?source=collection_archive---------1-----------------------#2021-12-12</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="84c2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们假设你有一个加密的股票市场平台。你有很多客户，你存储他们所有的交易。您使用相同的数据库表进行读取和写入。这是传统方法。但在这种情况下，这可能不是一个好的解决方案。因为写作是一个详细的操作，当你阅读人们当前的股票价值时，你不需要小细节。好吧，你可以用同一张桌子。大家猜猜，用同一个数据库表，会看到什么样的问题？我可以用一句话解释。你的数据库表将有很多数据，你会慢慢地读取数据。好吧，也许你可以等几秒钟来获得当前值，但是客户不喜欢这种事情。别担心。你不会失去你的客户。你可以把写作和阅读模式分开。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es jd"><img src="../Images/7afa8a4eef622e3e363182196d06e8a6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*aq7xk9GshSxdtY_A"/></div></div><figcaption class="jp jq et er es jr js bd b be z dx translated">照片由<a class="ae jt" href="https://unsplash.com/@emtm17?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">玛丽莎&amp;埃里克</a>在<a class="ae jt" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="0511" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">CQRS(命令和查询责任分离)是一种分离数据库读写操作的模式。在 CQRS 你会读到两种不同的东西。命令和查询。</p><ul class=""><li id="0a77" class="ju jv hi ih b ii ij im in iq jw iu jx iy jy jc jz ka kb kc bi translated">命令在数据库中写入写模型表。</li><li id="dc34" class="ju jv hi ih b ii kd im ke iq kf iu kg iy kh jc jz ka kb kc bi translated">查询从数据库的读取模型表中读取数据。</li></ul><p id="c58d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">您可以查看此图表。如果你什么都不懂，不用担心。我们会一步一步解释。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es ki"><img src="../Images/d4ba0521f6c307b2c1f8671928e1c8cd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1222/format:webp/1*-VjZASVNde5TQVvO3gRoTw.png"/></div><figcaption class="jp jq et er es jr js bd b be z dx translated">CQRS</figcaption></figure><ol class=""><li id="7bdc" class="ju jv hi ih b ii ij im in iq jw iu jx iy jy jc kj ka kb kc bi translated">命令写入数据存储。考虑对数据库表的插入操作。</li><li id="f38d" class="ju jv hi ih b ii kd im ke iq kf iu kg iy kh jc kj ka kb kc bi translated">更改写模型表后，我们必须更新读模型表以保持一致性。我们可以发布关于数据更改的事件，并且可以更新订阅服务器中的读取模型。如果你不理解这个事件或订户，你可以研究事件驱动架构。你也可以阅读这篇<a class="ae jt" href="https://levelup.gitconnected.com/event-driven-architectures-in-software-design-757d92b85df5" rel="noopener ugc nofollow" target="_blank">文章</a>。另外，我们简单解释一下。</li></ol><p id="6c5c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">事件是携带信息的消息。当你需要通知什么的时候，你发布事件。</p><p id="21cd" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">订户(消费者)正在读取事件。当您发布消息时，订阅者会收到该消息。你可以在阅读事件后做你想做的事情。您可以查看此图表。看完这个图表后，你可能会清楚地理解第 2 步。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es kk"><img src="../Images/591e8bc3a7d6631b657d6173a9457dfe.png" data-original-src="https://miro.medium.com/v2/resize:fit:908/format:webp/1*26F6Hhz83GdgxP-LiZ1ZOw.png"/></div></figure><p id="5095" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">3.它正在从读取模型数据库表中获取数据。</p><p id="94d0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们为 CQRS 准备了一个简单的项目。你会学到项目的一些部分。这里可以看到项目<a class="ae jt" href="https://github.com/emreerkoca/article-samples/tree/master/ArticleSamples/DotnetCoreCqrsMediatR" rel="noopener ugc nofollow" target="_blank">。您可以在新标签页中打开项目。当然，你会在这里看到这个项目的细节，但不是每个细节。</a></p><p id="989a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">是 Dotnet 核心应用。它包含了<a class="ae jt" href="https://github.com/jbogard/MediatR" rel="noopener ugc nofollow" target="_blank">mediator</a>库。mediator 库正在实现<strong class="ih hj">中介模式</strong>。我们将简单解释一下这个项目。</p><p id="2653" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">项目中没有真正的数据库连接。您不需要安装新的数据库来运行项目。我们有一个假的数据存储和假的数据。您可以查看下面的代码块。</p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="kl km l"/></div></figure><p id="6f7d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">方法:</strong></p><p id="1275" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> AddWallet(…) </strong>:添加一个新的 WalletWriteModel 来写模型数据库表。</p><p id="171d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> GetWalletReadModels(…):从读取模型数据库表中读取</strong> WalletReadModel。</p><p id="982c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> SetPublishedEvent(…): </strong>当一条新记录添加到写数据库表时，会发布一条消息来通知消费者。在此示例中，消息名为<strong class="ih hj"> WalletChangedNotification。</strong>我们将在下面看到这一点。发布新消息后，此方法将 WalletWriteModel 标记为已发布。在这个方法之后，我们可以确定关于消息的发布是为了一个新的写操作。</p><p id="ba39" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">UpdateWalletReadModel(…):</strong>项目中有<strong class="ih hj">WalletReadModelUpdaterNotificationHandler</strong>类。这是一个消费者。我们将在下面看到这个。当消费者收到消息时，它通过<strong class="ih hj">UpdateWalletReadModel(…)</strong>方法更新读取的模型数据库表。</p><p id="08f0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们现在可以回顾控制器动作方法。</p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="kl km l"/></div></figure><p id="4300" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Post 方法发送<strong class="ih hj"> AddWalletCommand。</strong>发送命令后，它发布<strong class="ih hj">WalletChangedNotification</strong>并调用<strong class="ih hj"> SetPublishedEvent(…) </strong>方法。您可以在这里看到该命令。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es kn"><img src="../Images/74e82e3318c1b52eecd0029cb1086e87.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*b0fpzWyfvPnU2adhoWqkzQ.png"/></div></div></figure><p id="f212" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">项目中有一个命令处理程序(<strong class="ih hj"> AddWalletHandler </strong>)。它处理<strong class="ih hj"> AddWalletCommand </strong>命令，调用<strong class="ih hj"> AddWallet(…) </strong>方法，并写入写模型表。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es ko"><img src="../Images/b04284c34659efebd05ac87fe1d41871.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EYhJF4mqzkVu97NMuZOYjg.png"/></div></div></figure><p id="15b3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> Get(…) </strong> action 方法发送<strong class="ih hj"> GetWalletQuery。GetWalletHandler </strong>处理<strong class="ih hj"> GetWalletQuery </strong>。它调用<strong class="ih hj"> GetWalletReadModel(…) </strong>方法，并返回读取模型表的结果。您可以在项目存储库中看到这一点。</p><p id="7025" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">您可能会想，在改变写模型之后，我们如何更新读模型表。发布动作方法<strong class="ih hj">WalletChangedNotification</strong>(消息，事件)<strong class="ih hj"> </strong>和<strong class="ih hj">WalletReadModelUpdaterNotificationHandler</strong>(消费者)<strong class="ih hj"> </strong>处理消息并更新读取的模型表。你可以看到下面的消费者。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es ko"><img src="../Images/b284b57af827058f1f62bd28b0dd5339.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CLwwinclTkxoAvlmHgF58A.png"/></div></div></figure><p id="1b41" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这是一个简单的场景。如果你在这篇文章中看到任何错误，你可以告诉我。希望能有所帮助。</p></div></div>    
</body>
</html>