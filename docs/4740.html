<html>
<head>
<title>Docker, Heroku Container Registry, and GitHub Actions: Building Fast, Performant Streamlit Apps</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Docker、Heroku Container Registry 和 GitHub Actions:构建快速、高性能的简化应用程序</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/docker-heroku-container-registry-and-github-actions-building-fast-performant-streamlit-apps-77ab62f4db75?source=collection_archive---------3-----------------------#2021-08-05">https://medium.com/nerd-for-tech/docker-heroku-container-registry-and-github-actions-building-fast-performant-streamlit-apps-77ab62f4db75?source=collection_archive---------3-----------------------#2021-08-05</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="2cb3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="jd">本文假设您熟悉使用 Streamlit 构建您的数据应用程序和仪表板，或者至少以前听说过 Streamlit。</em></p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es je"><img src="../Images/348cf317a80d188b4d5d96fe3919782d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NOCiCirWkbTiNX_rITuR9w.jpeg"/></div></div><figcaption class="jq jr et er es js jt bd b be z dx translated"><a class="ae ju" href="https://unsplash.com/photos/DhoCVkssJjs" rel="noopener ugc nofollow" target="_blank">un splash 上的 Siora</a></figcaption></figure><p id="4ace" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">不久前，我被分配到一个仪表板上工作，该仪表板将我公司开发工作流程的一部分自动化。作为一个 Streamlit 的非官方支持者——在大约 6 或 7 个国际会议上做了无数次关于 Streamlit 的演讲——我很自然会在这个项目中使用 Streamlit。</p><p id="66d2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Streamlit 使用起来总是简单明了，但是 Heroku 上的性能往往是一个复杂的问题。这让我开始研究如何尽可能快地加载我的 Streamlit 应用程序，而不必牺牲任何东西。</p><p id="ce85" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">下面列出了我尝试过的所有技术，我会深入研究为什么你会考虑使用它们，这样你就不会遇到我遇到的所有琐碎问题。</p><ul class=""><li id="18e4" class="jv jw hi ih b ii ij im in iq jx iu jy iy jz jc ka kb kc kd bi translated">构建简化的应用程序</li><li id="d75d" class="jv jw hi ih b ii ke im kf iq kg iu kh iy ki jc ka kb kc kd bi translated">不要直接推进到 Heroku，用 Docker</li><li id="3d53" class="jv jw hi ih b ii ke im kf iq kg iu kh iy ki jc ka kb kc kd bi translated">缩小图像尺寸:如果是 Streamlit，就不要用 Alpine！</li><li id="a609" class="jv jw hi ih b ii ke im kf iq kg iu kh iy ki jc ka kb kc kd bi translated">使用 GitHub Actions 工作流自动化后续部署</li><li id="7e09" class="jv jw hi ih b ii ke im kf iq kg iu kh iy ki jc ka kb kc kd bi translated">其他有用的技术(Streamlit 的内部)</li></ul><p id="30d5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">*鼓声**</p><h2 id="befa" class="kj kk hi bd kl km kn ko kp kq kr ks kt iq ku kv kw iu kx ky kz iy la lb lc ld bi translated">构建简化的应用程序</h2><p id="b515" class="pw-post-body-paragraph if ig hi ih b ii le ik il im lf io ip iq lg is it iu lh iw ix iy li ja jb jc hb bi translated">如果您已经熟悉了 Streamlit，那么您会知道使用 Streamlit 创建 web 应用程序就像编写简单的 Python 脚本一样简单，只需要在这里或那里进行一些 API 调用。出于我们的目的，下面是一个示例脚本:</p><figure class="jf jg jh ji fd jj"><div class="bz dy l di"><div class="lj lk l"/></div></figure><p id="3d20" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这是一个简单的脚本，它接受用户输入，并根据用户输入满足的条件创建一个折线图。</p><p id="e260" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">要在本地服务器上运行它，就像在终端/命令提示符下运行下面的命令一样简单；</p><pre class="jf jg jh ji fd ll lm ln lo aw lp bi"><span id="e99c" class="kj kk hi lm b fi lq lr l ls lt">$ streamlit run app.py</span></pre><h2 id="0658" class="kj kk hi bd kl km kn ko kp kq kr ks kt iq ku kv kw iu kx ky kz iy la lb lc ld bi translated">不要直接推进到 Heroku，用 Docker</h2><p id="b31d" class="pw-post-body-paragraph if ig hi ih b ii le ik il im lf io ip iq lg is it iu lh iw ix iy li ja jb jc hb bi translated">一旦我们有了网络应用，下一个合乎逻辑的步骤就是推进到云端，Heroku 是一个很好的免费选择。这就是问题可能开始出现的地方。</p><p id="bfa5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">通常的技术是创建 requirements.txt、Procfile 和 setup.sh 文件，然后使用 Git 推送到 Heroku 应用程序，该应用程序作为远程应用程序添加到您现有的 Git 存储库中。但是 Streamlit 应用程序在 Heroku 服务器上加载速度非常慢。</p><p id="1610" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">一个很好的理论是 Streamlit 有很多包依赖关系(考虑到它抽象了很多东西，这在某种程度上是可以理解的)，这些依赖关系可能会占用 Heroku 的大量内存。因此，如果你的应用程序包含一大堆占用内存的功能，加载速度肯定会变慢。</p><p id="fcf6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">解决这个问题的一个好方法是使用 Docker。Docker 是一个平台，可以非常快速地构建、发布和运行应用程序，而不用太担心基础设施的依赖性。我的一个队友在她的机器上安装 Streamlit 时遇到了一个问题(怪无数的依赖项吧！)Docker 是避免这种不便的好方法。</p><p id="0319" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">除了代码目录之外，您需要的只是 requirements.txt 文件，之后您将创建 Dockerfile。一旦构建了 web 应用程序的 Docker 映像，就可以很容易地推送到 Heroku Container Registry 来开始从外部访问 web 应用程序。</p><figure class="jf jg jh ji fd jj"><div class="bz dy l di"><div class="lj lk l"/></div></figure><p id="78e4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">第一行代码使用 Python 图像作为基础图像。然后，我们复制并安装 requirements.txt 中列出的依赖项。之后，我们将目录内容复制到一个名为/app 的新目录中，并将其初始化为我们的工作目录。最后，最后一行代码启动了 Streamlit 应用程序。</p><p id="4e7e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为了在本地测试 Docker 映像，下面的两行命令将构建 Docker 映像并运行容器；</p><pre class="jf jg jh ji fd ll lm ln lo aw lp bi"><span id="9838" class="kj kk hi lm b fi lq lr l ls lt">$ docker build -t app:latest .<br/>$ docker run app:latest</span></pre><p id="af02" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这将在本地启动 Docker 容器，您可以通过显示的网络 URL 访问它。</p><p id="6936" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">部署到 Heroku 容器注册中心</strong></p><p id="b370" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">要部署到 Heroku，需要以下命令；</p><pre class="jf jg jh ji fd ll lm ln lo aw lp bi"><span id="91fe" class="kj kk hi lm b fi lq lr l ls lt">$ heroku login<br/>$ heroku container:login<br/>$ heroku create app_name<br/>$ heroku container:push web<br/>$ heroku container:release web<br/>$ heroku open</span></pre><p id="cd02" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">分别登录 Heroku 和 Heroku 容器需要前两行命令。下一行命令使用指定的名称在 Heroku 上创建应用程序。下一行构建图像并将其推送到容器注册表。以下命令行将图像发布到应用程序，而最后一行在浏览器中打开现在部署的应用程序。</p><p id="0e51" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">但是即使为我的项目做了这些，我的 Docker 图像大小仍然是 3GB+,并且加载部署的 web 应用程序需要花费很长时间。:(</p><h2 id="dec1" class="kj kk hi bd kl km kn ko kp kq kr ks kt iq ku kv kw iu kx ky kz iy la lb lc ld bi translated">缩小图像尺寸:如果是 Streamlit，就不要用 Alpine！</h2><p id="6b74" class="pw-post-body-paragraph if ig hi ih b ii le ik il im lf io ip iq lg is it iu lh iw ix iy li ja jb jc hb bi translated">在研究如何解决这个瓶颈时，几乎所有资源都推荐使用 Alpine Linux。所以我用了它，但我的 Docker 形象就是建不起来。它无法安装 Streamlit 的某些依赖项。</p><p id="37bc" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我研究了为什么“美国队长，但对于较小的图像尺寸”不能在我最需要它的时候拯救我，我偶然发现了<a class="ae ju" href="https://pythonspeed.com/articles/alpine-docker-python/" rel="noopener ugc nofollow" target="_blank">这篇很棒的文章</a>，关于为什么 Alpine 不是 Python Docker 的较小图像尺寸的最佳人选。事实证明，标准的 PyPi 车轮在 Alpine 和 Streamlit 上不起作用，它们有很多可爱的车轮。:(</p><p id="bfcd" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">所以我把“Alpine Linux”换成了“Python-slim”作为我的基础镜像。我还在“pip install”中使用了“— no-cache-dir”标志，这样它就不会在安装完软件包后将它们的安装文件存储在缓存中。</p><figure class="jf jg jh ji fd jj"><div class="bz dy l di"><div class="lj lk l"/></div></figure><p id="fdfb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这样做极大地减少了我的项目的 docker 图像大小，从将近 4GB 减少到 300MB 多一点。喔喔喔！</p><h2 id="3394" class="kj kk hi bd kl km kn ko kp kq kr ks kt iq ku kv kw iu kx ky kz iy la lb lc ld bi translated">使用 GitHub 动作自动化后续部署</h2><p id="e69a" class="pw-post-body-paragraph if ig hi ih b ii le ik il im lf io ip iq lg is it iu lh iw ix iy li ja jb jc hb bi translated">如果你想不断修改你的 web 应用程序，而不必每次都使用“heroku container:push”和“heroku container:release ”, GitHub Actions workflow 是下一个可以利用的 DevOps 工具。GitHub 动作可以用来自动化开发工作流的部署部分，这意味着在第一次初始推送后，您不必再次手动推送至 Heroku。</p><p id="741e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">您需要做的就是在您的项目目录中创建 CI.yml 文件，格式如下；</p><p id="9419" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="jd">。github - &gt;工作流- &gt; CI.yml </em></p><p id="a818" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">CI.yml 将包含如下代码行:</p><figure class="jf jg jh ji fd jj"><div class="bz dy l di"><div class="lj lk l"/></div></figure><p id="c12d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">“name”键描述 CI.yml 文件的用途。“on”键在主存储库被推送时触发工作流。在“job”键中是 Heroku 命令，用于登录、推送新的构建，以及将新的构建发布到 web 应用程序。</p><p id="57d6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">最后，为了允许访问 Heroku，应该在 GitHub Secrets 中添加一个访问密钥。要生成身份验证密钥，下面的代码行将会这样做；</p><pre class="jf jg jh ji fd ll lm ln lo aw lp bi"><span id="c59b" class="kj kk hi lm b fi lq lr l ls lt">$ heroku authorizations:create</span></pre><p id="b645" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">复制生成的密钥，并通过导航到设置→密码→新建存储库密码将其保存在 GitHub 存储库中。我将密钥命名为“HEROKU_API_KEY ”,以匹配 HEROKU 使用的变量名，尽管您可以将名称改为您喜欢的任何单词。您应该确保在工作流文件中使用相同的名称。</p><h2 id="e9e7" class="kj kk hi bd kl km kn ko kp kq kr ks kt iq ku kv kw iu kx ky kz iy la lb lc ld bi translated">其他有用的提示</h2><p id="a2cc" class="pw-post-body-paragraph if ig hi ih b ii le ik il im lf io ip iq lg is it iu lh iw ix iy li ja jb jc hb bi translated">我不想让这篇文章变得太长，下面的提示与部署没有特别的关系，因为它们是 Streamlit 的内部技术，使应用程序的内存大小更有效。所以我只是在这里提到他们，但我可能会写一篇关于他们的文章。</p><ul class=""><li id="6515" class="jv jw hi ih b ii ij im in iq jx iu jy iy jz jc ka kb kc kd bi translated">从项目目录中删除静态文件，因为它们会添加到文件中。如果这些静态文件保存在 Amazon s3 上，并通过 URL 加载到你的应用程序中，你的应用程序会更好，这就引出了我们的下一个技巧；</li><li id="f7b9" class="jv jw hi ih b ii ke im kf iq kg iu kh iy ki jc ka kb kc kd bi translated">尽可能使用<strong class="ih hj">圣缓存</strong>。不经常使用的文件或函数，比如 pd.read_csv，应该虔诚地缓存。这意味着每次与 web 应用程序交互时，不会重新加载缓存的文件。</li><li id="2000" class="jv jw hi ih b ii ke im kf iq kg iu kh iy ki jc ka kb kc kd bi translated">使用<strong class="ih hj">会话状态</strong>在重新运行时存储变量。除了有助于减少重新加载的时间之外，这确实节省了我编写大量函数以确保我的变量被永久存储以供重用所带来的压力。</li></ul><h2 id="4235" class="kj kk hi bd kl km kn ko kp kq kr ks kt iq ku kv kw iu kx ky kz iy la lb lc ld bi translated">总之；</h2><p id="afb6" class="pw-post-body-paragraph if ig hi ih b ii le ik il im lf io ip iq lg is it iu lh iw ix iy li ja jb jc hb bi translated">在这篇文章中，</p><ul class=""><li id="aecd" class="jv jw hi ih b ii ij im in iq jx iu jy iy jz jc ka kb kc kd bi translated">我解释了为什么您应该使用 Docker 在 Heroku 上部署，而不是直接在 Heroku 上部署您的 web 应用程序。</li><li id="30b5" class="jv jw hi ih b ii ke im kf iq kg iu kh iy ki jc ka kb kc kd bi translated">我还阐述了如何通过使用 Python-slim 作为基本图像来减小 Docker 图像的大小。</li><li id="3c81" class="jv jw hi ih b ii ke im kf iq kg iu kh iy ki jc ka kb kc kd bi translated">我们还探索了如何使用 GitHub 动作来自动化后续部署。</li><li id="4f85" class="jv jw hi ih b ii ke im kf iq kg iu kh iy ki jc ka kb kc kd bi translated">最后，我们使用了其他有用的技术来帮助我们缩小应用程序的大小。</li></ul><p id="d7e5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">感谢你远道而来。快乐流线型！</p><p id="0657" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">请随时在 LinkedIn 和 Twitter 上与我联系。我很乐意回答你的任何问题或简化自由职业者的工作:)</p></div></div>    
</body>
</html>