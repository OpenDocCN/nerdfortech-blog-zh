# “承诺”模型，在科特林-第 2 部分-错误处理与“捕捉”

> 原文：<https://medium.com/nerd-for-tech/the-promise-model-in-kotlin-part-2-error-handling-ebb5b66bb745?source=collection_archive---------10----------------------->

## 移动应用中的反应式编程——一次旅行

恰当而优雅地处理错误是“Promise”模型的一个主要优点。“catch”条款还允许通过提供一个新的值甚至一个新的*承诺*来恢复这个链，以便从*异常*中恢复。
这是[“承诺模型”](/@gguymi/the-promise-model-in-kotlin-1c121f22d35a)的第二部分。

**简介** 在[第一章](/@gguymi/the-promise-model-in-kotlin-1c121f22d35a)中，我们介绍了在 *Kotlin* 中创建 *Promise* 模型的基础知识，该模型允许*JavaScript*——类似于 *Promise* 的用法，但是具有额外的特性，例如线程处理和多平台能力。在本章中，我们将讨论错误处理，也就是“catch”子句。
下一章——*Android apro mise*——将涵盖 *APromise* 模型，这是一个扩展类，通过提供 *Android* ' *主线程*'和*视图*特性，专门支持 *Android* 平台。

![](img/fa8ed2fe3f82036a534fa5e3e37ab79a.png)

找到错误，找到沃尔多

# “catch”从句，引言

*Promise* 模型中的‘Catch’子句基本上是任务链的一个 *onError* 回调，除了它还可以恢复(回到`then`链以从*异常*中恢复。您可以在链中的任何地方使用任意多的' catch' ，甚至可以在内部链中使用(一个在`then`子句中返回的`Promise`)。它们被调用的顺序——在*异常*被*抛出的情况下—* 是至关重要的，并且应该与那些`catch`被写入的顺序相同。

为了理解我对“catch”的实现，让我们首先考虑这个*承诺*链，以理解我们期望我们的*承诺*如何处理错误:

具有多种 catch 用法的多承诺链

现在让我们考虑可能的“捕获”流:

1.  *ofDelay(5000)失败:*
    我们期望*第一档*和*第三档*按此顺序触发(被调用)。
    我们确实*不*期望*第二次捕捉*被调用，因为如果*异常*被*抛出*到链上的任何地方，则`thenAwait`不会开始，并且*第二次捕捉*属于内链，*不是*属于“原始”外链。
    事实上，整个`Promise.ofDelay(10000)`链可以用一个单独的方法来写——它与外、*上游* (up the)链无关；这是一个重要的规则。
2.  *ofDelay(10000)失败:* 我们期望*第二档*和*第三档*按此顺序触发。
    这是因为*第二档*属于引发*异常*的实际(内)链条，*第三档*放置在*(在*的*下游)* `thenAwait`之后——一个失效的内链条(*抛出*一个*异常*)导致*整个*链条失效。这也是一个重要的规则。

注意:除了“catch”子句的调用顺序之外，这里的要点是，虽然内部链与#1 中看到的(外部)*上游*链无关(当然，除了通过“then”接收其结果之外)，但是*对(外部)*下游*链影响很大， 正如在#2 中看到的——当一个*异常*被*抛出*(‘catch’链)时，以及通过*映射*结果/结果类型(‘then’链)时，都会影响它，例如从`T`到`R`，正如在本文的前一章中看到的。*

## “捕捉”实现方法

现在，本能地，实现我们的“catch”的最简单方法是让它使用 *rx Single* 的`doOnError`——这是一个副作用回调，可以在一个链中使用多次，就像我们希望的“catch”一样。
问题是，它可能有意想不到的调用顺序，这取决于我们将使用的确切流。在上面的*承诺*-链示例中，例如，如果 Delay(10000) 的*失败，*第三抓*将在* *第二抓(！).*
我不会在这篇文章中深入探讨 *rx* 的细节/原因，但底线是:
*我们不能指望* `*doOnError*` *完全按照我们所期望的“catch”的方式行事。*

为了克服这一点，我们要做的是*而不是*使用*单个*的`doOnError`。相反，我们将使用我们的`Single`的*订阅*(在*承诺*的`execute`方法内，[见上一章](/@gguymi/the-promise-model-in-kotlin-1c121f22d35a#85c7) ) 来订阅错误，我们将定义我们自己的*错误处理链*，我们将仅从那个*订阅*中调用它。别担心，一切都会解释清楚的。

顺便说一下，如果有人提出一个更“单一”的方法，一个包含更少“定制”代码的方法，我会非常乐意倾听。这个 Promise 实现的优势在于它是一个 `*Single*` *的事实，每一个“额外”的代码都会使它变得不那么重要。也就是说，这种错误处理在两个生产应用中完美地工作，带有一些非常复杂的承诺链。效果很好。*

我们开始吧。基本上，我们只需要记住我们需要多个`catch`(使用[上面的例子](#3746))以正确的顺序被调用。
我们将重复[到目前为止我们已经介绍过的完全相同的步骤](/@gguymi/the-promise-model-in-kotlin-1c121f22d35a#35f1)，但是使用更多的代码。*标题与前一章中的步骤相对应。*

## 通过错误处理建立承诺

我们先从*承诺*类定义开始。还记得只有两个成员吗，`promiseSubscriber`和`single`？这是另一个 2:

简化的 Promise 类声明，这次使用了错误处理程序。

如您所见，每个*承诺*都有一个用于简单操作的错误处理程序(比如‘then’)，以及一个用于异步任务的错误处理程序(比如‘then wait’)。
现阶段很难解释原因，所以我们会边走边解释。
简单地说，这样做是因为异步操作的复杂性需要一个专门的错误处理器，否则`catch`调用的顺序会被打乱(如上面的`promise.ofDelay()`示例所示)。

## 创建带有错误处理的新 Promise 实例

现在，让我们回到`createInstance`方法，这次是错误处理代码:

每当我们创建一个新的`Promise` 实例时(例如，对于一个新的‘then’动作)，我们将把‘当前’*承诺*的*错误处理程序*传递给新的/下一个*承诺。*这样做是因为链中的最后一个*承诺*是处理错误(实际上是成功)的唯一*承诺* *承诺*。这是因为最后一个*承诺*的`Single`是我们*订阅*的链中唯一的*单个*。还有一个不订阅的*单*不*不*跑，记得吗？下一步显示更新的`execute`方法，这将使它更加清晰。

*注:这是谈论房间里的大象的好时机。最后的承诺是唯一重要的承诺。有点像 rx 链中的最后一个单曲是唯一重要的单曲。所有其他承诺都是为了方便使用(构建链)而存在的，并将被垃圾收集。最后一个承诺持有唯一订阅的* `*Single*` *，因此持有整个单个操作链。如果你确定你有一个更有效的方法，不损害反应式方法和易用性，请让我知道。*

## 执行承诺，并进行错误处理

下面是新的`execute`方法，增加了*错误处理*代码:

如你所见，*单个*的`subscribe`方法有两个参数，一个*成功处理程序*和一个*错误处理程序*。*成功处理程序*并不重要，因为我们使用‘然后’和‘最终’，它们直接和立即影响*单链*。
然而*错误处理程序*是我们实际处理错误的地方——它们是*而不是*在*单个*自己的成功链内处理。让这种想法停留一会儿，然后继续阅读。
现在，为了使这一点更加清楚，请回到第一章中的[简单‘then’代码。如你所见，它使用了`this.single.map`(通过`singleOfConsumer()`)，这意味着它已经影响了*单*链。
尽管‘catch’条款，*而非*是否影响*单链*。继续读。](/@gguymi/the-promise-model-in-kotlin-1c121f22d35a#5c24)

# “Catch”子句的实现

现在，我们终于理解了更多并改进了以前的代码。
注意`catch`如何影响*而非*单*链条，与`then`相反。*

这真的很简单——如果没有先前的*错误处理程序*，我们只需保存新的*消费者*(新的*错误处理程序*参数传递给`catch`)。
如果有先前的错误处理程序(来自先前的`catch`调用)，创建并替换为新的*错误处理程序—* ，以正确的顺序调用先前的错误处理程序和新的错误处理程序。有点类似于链表，一般意义上的。

回到*单个*的讨论——这个`catch`实现根本不会*而*影响*承诺*的`Single`，因此不会创建新的`Promise`。
它只是*回报* `this` ( *承诺*)。
原因，如果你记得的话，与“等待”有关——如果不处理内部*承诺*链(就像上面的[例子中那样)，我们可以只使用 *Single 的* `doOnError`方法。但有了它，就会打乱“catch”调用的正确顺序。](#3746)

# 然后等待，并进行错误处理

最后我们到了最后一部分。真正棘手的是。这种“然后等待”是“捕捉”与“然后”工作不同的全部原因；该“catches”不影响*承诺*的`Single`并保存在`onErrorConsumer`中；这就是为什么我们从*承诺*的`execute`方法内部，从`single.subscribe()`内部执行*错误*链。
这就是为什么我们经历了一切(从 [*【军规】条款开始，介绍*](#9ceb) *)* 。

让我们看看新的`thenAwait`和它的`singleOfAsync`，这次是正确的*错误处理*:

为了理解这里发生了什么，让我们提醒自己这一节开始的例子:

我们将把`Promise.ofDelay(5000)`—*promises 5 和*—*promises 10 称为。而*我们的任务就是让*承诺 10* 的*第二抓*火在*第三抓*、*、*失败(拒绝)的时候。

当这个*承诺*链被创建时，`thenAwait`在*承诺 5* 上运行并调用`singleOfAsync`(如上面的实现所示)。在它里面，当`flatMap`计算的时候(也只有那时！)，*promises 10*的(`nextPromise` ) *错误处理程序*保存为*promises 5*的*异步错误处理程序。*

回到`thenAwait`。它调用*promises 5*自己的`catch`(姑且称之为 *catch1.5* )来处理*第三次 catch、*之前的任何错误，这是妙处:

当`singleOfAsync`的`flatMap`计算时，它创建*promises 10*(`function.apply(t)`)*，并将其*错误处理程序*保存为*promises 5*的*异步错误处理程序。* 当 *promise10* 失败时， *catch1.5* 被调用，其中 *promise5* 的*异步错误处理程序*为 *not null* 并且已经持有 *promise10* 的*错误处理程序*被*调用*秩序恢复:)*

*请注意，如果某些错误发生在`thenAsync`之前(例如被*第一次捕捉*捕捉到)，*承诺 10* 尚不存在(！)，因为它是一个延迟初始化的*承诺*，它只在`thenAwait`开始时初始化，也就是在`flatMap`计算的时候。在那之前，*promises 5*的*异步错误处理器*仍然是 *null* 。
同样，由于 *promise10* 是*而不是*链中的最后一个 *Promise* ，它将不会处理任何错误(因为我们的`catch`实现不会影响`single`，我们执行*错误处理程序*的唯一地方是在`execute`内部)。*

**注意:现在名称* `*asyncErrorConsumer*` *有意义了——它是处理异步任务的错误链的错误处理程序，意思是另一个* `*Promise*` *。**

*就是这样，真的:)
让我们再来看几个“catch”类型的用法，比如“catchResume”。我们将不会进入细节，因为他们几乎有相同的实现，或者使用一个简单的(像' catchReturn '它只是使用了 *Single* 的`onErrorReturn`方法)。*

# *更有用的“catch”类型*

*下面是一些更有趣的“catch”从句。
它们还提供了从*异常*中恢复的方法，否则该异常会阻止链继续运行。*

## *' catchReturn '*

*该子句通过提供替代选项`T`来帮助从错误中恢复，非常类似于‘then’:*

## *'捕捉简历'*

*该子句通过提供另一种选择`Promise<T>`来帮助从错误中恢复，很像‘thenAwait’:*

## *'捕捉忽略'*

*这一条用得较少，但仍值得一提。当你想继续某个链时，它会有所帮助，不管它“到目前为止”是否成功——它总是映射到一个`Unit`。
注意:除非有更多相关的“然后”和“抓住”向下链，通常最好是在*承诺*完成时使用`finally`做动作，不管成功/失败。*

## *然后映射或取消'，'然后映射或弹出'*

*在我们结束之前，我还想介绍一些“那时”的版本。这些版本也可以很容易地为“catch”子句创建，但是由于我从来不需要它们，它们还没有出现在源代码中:)
像“thenMapOrCancel”、“thenAwaitOrReject”(等等。)当你不能预先知道你是否能够提供一个价值(或一个*承诺*)时，你可以通过取消或拒绝来打破这个链条:*

## *“终于”*

*正因为我不能写一篇关于一个*承诺*的文章而不展示这个(虽然已经在一些例子中展示过)，这里是‘最终’，它被称为*总是*，不管取消、成功还是拒绝:*

# *摘要*

*所以这就结束了纯 Kotlin 的 *Promise* 模型。我真的希望你喜欢它，它教会了你一些新的东西。请在下面的评论中写下你的想法。*

*下一章将关注 *APromise* ，它是一个扩展类，支持 *Android* 上下文(*视图，活动*)。这相当于使用 *Kotlin 协程*的*【Scope】*来自动*取消*一个不再相关的*上下文链。*希望未来的版本也能支持 iOS(IPromise)——前提是底层的*承诺*是用纯 *Kotlin* 编写的。*

*在这下一章之后，我们将结束反应式架构的*承诺*部分，并深入到核心库 *Reactdroid。* 正如他们所说…这只是开始…*

*过得好；)*

*编辑:[下一部出来了！](/@gguymi/9522adda8b5a)*