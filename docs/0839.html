<html>
<head>
<title>Stack &amp; Queue with (Singly) Linked List</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">带有(单)链表的堆栈和队列</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/stack-queue-with-singly-linked-list-3ba42db98d87?source=collection_archive---------0-----------------------#2021-02-18">https://medium.com/nerd-for-tech/stack-queue-with-singly-linked-list-3ba42db98d87?source=collection_archive---------0-----------------------#2021-02-18</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="6a52" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">链表，科技面试常见数据结构问题的话题之一。我将带你们探索栈和链表队列的概念！</h2></div><p id="1336" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi jt translated">(免责声明:本文需要预先了解链表，代码将用Javascript编写。)</p><figure class="jv jw jx jy fd jz er es paragraph-image"><div role="button" tabindex="0" class="ka kb di kc bf kd"><div class="er es ju"><img src="../Images/fd0096823960a8f07b171481610a3f31.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*ZjWta104KojLXSqp"/></div></div><figcaption class="kg kh et er es ki kj bd b be z dx translated">照片由<a class="ae kk" href="https://unsplash.com/@thoughtcatalog?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">思想目录</a>在<a class="ae kk" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="9783" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi jt translated"><span class="l kl km kn bm ko kp kq kr ks di">我</span>花了两周时间学习链表。我不得不说，在与排序算法(那些冒泡、插入、合并，只是——aaahh)斗争之后，我发现链表比<em class="kt">更容易掌握。我最终会回到排序算法。此时此刻，我生活在链表的<em class="kt">泡泡</em>中(向排序算法脱帽致敬🎩).</em></p><p id="dd5b" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="iz hj">目录:</strong></p><ul class=""><li id="764d" class="ku kv hi iz b ja jb jd je jg kw jk kx jo ky js kz la lb lc bi translated"><a class="ae kk" href="#d524" rel="noopener ugc nofollow"> <strong class="iz hj">快速浏览链表</strong> </a></li><li id="1ac1" class="ku kv hi iz b ja ld jd le jg lf jk lg jo lh js kz la lb lc bi translated"><a class="ae kk" href="#d67e" rel="noopener ugc nofollow"> <strong class="iz hj">堆栈</strong> </a></li><li id="10b0" class="ku kv hi iz b ja ld jd le jg lf jk lg jo lh js kz la lb lc bi translated"><a class="ae kk" href="#12e2" rel="noopener ugc nofollow"> <strong class="iz hj">队列</strong> </a></li><li id="dea9" class="ku kv hi iz b ja ld jd le jg lf jk lg jo lh js kz la lb lc bi translated"><a class="ae kk" href="#2bd3" rel="noopener ugc nofollow"> <strong class="iz hj">堆栈和队列的大O</strong></a></li><li id="2f62" class="ku kv hi iz b ja ld jd le jg lf jk lg jo lh js kz la lb lc bi translated"><a class="ae kk" href="#3165" rel="noopener ugc nofollow"> <strong class="iz hj">重述:并排比较:堆栈与队列</strong> </a></li></ul><p id="8916" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在我们深入堆栈和队列之前，让我们快速回顾一下什么是链表。</p></div><div class="ab cl li lj gp lk" role="separator"><span class="ll bw bk lm ln lo"/><span class="ll bw bk lm ln lo"/><span class="ll bw bk lm ln"/></div><div class="hb hc hd he hf"><h2 id="d524" class="lp lq hi bd lr ls lt lu lv lw lx ly lz jg ma mb mc jk md me mf jo mg mh mi mj bi translated">快速浏览链接列表</h2><p id="4229" class="pw-post-body-paragraph ix iy hi iz b ja mk ij jc jd ml im jf jg mm ji jj jk mn jm jn jo mo jq jr js hb bi jt translated"><span class="l kl km kn bm ko kp kq kr ks di"> L </span>链表是一种线性数据结构，就像数组一样。你可能知道也可能不知道，有两种类型的链表:单向链表和双向链表。啊，连名字都这么可爱。主要区别是什么？</p><p id="3cfb" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="iz hj">单链表</strong>:通常提供头部(第一个节点)，不提供尾部。</p><figure class="jv jw jx jy fd jz er es paragraph-image"><div role="button" tabindex="0" class="ka kb di kc bf kd"><div class="er es mp"><img src="../Images/65659c5903e500368c4696300b6ad38f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*pnPBwu_k1xRa08CR.png"/></div></div><figcaption class="kg kh et er es ki kj bd b be z dx translated">信用:<a class="ae kk" href="https://www.geeksforgeeks.org/linked-list-vs-array/" rel="noopener ugc nofollow" target="_blank">极客对极客——链表vs数组</a></figcaption></figure><p id="c060" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="iz hj">双向链表</strong>:头部和尾部都会被提供。</p><figure class="jv jw jx jy fd jz er es paragraph-image"><div role="button" tabindex="0" class="ka kb di kc bf kd"><div class="er es mq"><img src="../Images/7f45fbe5bdd7b4d3baa377fefa419006.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*Gwpv2XYfgBA7dD-p.png"/></div></div><figcaption class="kg kh et er es ki kj bd b be z dx translated">鸣谢:<a class="ae kk" href="https://www.geeksforgeeks.org/doubly-linked-list/" rel="noopener ugc nofollow" target="_blank">极客帮极客—双向链表| Set 1 </a></figcaption></figure><p id="7e48" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">为什么我们要使用链表而不是数组？</p><p id="65a1" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">因为</p><ul class=""><li id="7bf6" class="ku kv hi iz b ja jb jd je jg kw jk kx jo ky js kz la lb lc bi translated">从一个数组中插入/移除元素是很昂贵的，因为需要空间来移动或插入一个元素，而在链表中，添加头部或尾部，甚至在中间插入/移除都很容易。O(n)与O(1)的区别。</li><li id="96a7" class="ku kv hi iz b ja ld jd le jg lf jk lg jo lh js kz la lb lc bi translated">链表的动态大小使事情变得更容易，因为链表的长度可以根据需要增加或减少。</li></ul><p id="be73" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">然而</p><ul class=""><li id="0284" class="ku kv hi iz b ja jb jd je jg kw jk kx jo ky js kz la lb lc bi translated">由于指针的原因，链表往往比数组占用更多的内存空间；</li><li id="0dee" class="ku kv hi iz b ja ld jd le jg lf jk lg jo lh js kz la lb lc bi translated">由于指针系统，随机访问元素似乎是不可能的。</li></ul><p id="bbfe" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">不管怎样，我不打算用我文章的一半来解释什么是链表。我假设你想更好地理解栈和队列，这就是你在这里的原因。在本文中，我们将着重使用单链表的概念来解释堆栈和队列。</p></div><div class="ab cl li lj gp lk" role="separator"><span class="ll bw bk lm ln lo"/><span class="ll bw bk lm ln lo"/><span class="ll bw bk lm ln"/></div><div class="hb hc hd he hf"><p id="7d2e" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">好吧，什么是栈，什么是队列？</p><h1 id="d67e" class="mr lq hi bd lr ms mt mu lv mv mw mx lz io my ip mc ir mz is mf iu na iv mi nb bi translated">堆</h1><p id="d5be" class="pw-post-body-paragraph ix iy hi iz b ja mk ij jc jd ml im jf jg mm ji jj jk mn jm jn jo mo jq jr js hb bi translated">在我们开始之前，这里是我们的两个类的起始代码:Stack和Nodes。</p><p id="4da9" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">(《新女孩》第三季第19集9:39——Stack的绝佳例子)</p><figure class="jv jw jx jy fd jz"><div class="bz dy l di"><div class="nc nd l"/></div></figure><p id="1d4b" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">快速解释:我们将这个列表设置为一个空列表。无头(第一)无尾(最后)。</p><p id="2fe9" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi jt translated"><span class="l kl km kn bm ko kp kq kr ks di">把书架想象成…你放在椅子上的一堆脏衣服，又名椅柜。</span></p><figure class="jv jw jx jy fd jz er es paragraph-image"><div class="er es ne"><img src="../Images/b9209e0346727013baad6e642a4ec453.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/0*XTPymCohyVeFT8hR.png"/></div><figcaption class="kg kh et er es ki kj bd b be z dx translated">信用:<a class="ae kk" href="https://me.me/i/chair-drobe-a-chair-piled-with-dirty-olothing-which-acts-6262313" rel="noopener ugc nofollow" target="_blank"> me.me </a></figcaption></figure><p id="f9c7" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">现在是早上7:30，你正准备去上班/上学。你懒得在衣柜里找新衣服，你知道今天还不是洗衣服的日子，你知道吗？椅子上的衣服也不太脏。所以你拿起你在这堆衣服中找到的第一件上衣(你昨晚穿的),闻闻，深深地闻闻……是的，闻起来不太脏，所以你穿上了它。那你管这叫什么？<strong class="iz hj"> LIFO </strong>，又名<strong class="iz hj">L</strong>ast-<strong class="iz hj">I</strong>n-<strong class="iz hj">F</strong>first-<strong class="iz hj">O</strong>ut。这差不多就是堆栈。你会经常看到那种情况，包括<strong class="iz hj">递归</strong>。</p><p id="0804" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">stacks中有两种方法(以数组的形式):<code class="du nf ng nh ni b">unshift</code>(到头的项)和<code class="du nf ng nh ni b">shift</code>(从头的第一项)。我会用代码解释。</p><h2 id="aa3a" class="lp lq hi bd lr ls lt lu lv lw lx ly lz jg ma mb mc jk md me mf jo mg mh mi mj bi translated"><code class="du nf ng nh ni b">push(val)</code></h2><figure class="jv jw jx jy fd jz er es paragraph-image"><div class="er es nj"><img src="../Images/ea3c4c909047763501020746129bbcf8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/1*xwzQCoJTCDj-O8BcpVcS6g.gif"/></div><figcaption class="kg kh et er es ki kj bd b be z dx translated">信用:<a class="ae kk" href="https://visualgo.net/en/list" rel="noopener ugc nofollow" target="_blank"> VisuAlgo </a></figcaption></figure><p id="64f0" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在这种情况下，53的值需要被<strong class="iz hj">推到</strong>列表的开头。因为这不是一个数组，所以没有内置的方法将值“推入”我们的列表。相反，让我们写一个函数:</p><figure class="jv jw jx jy fd jz"><div class="bz dy l di"><div class="nc nd l"/></div></figure><p id="2c9a" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">事情是这样的:</p><ol class=""><li id="3359" class="ku kv hi iz b ja jb jd je jg kw jk kx jo ky js nk la lb lc bi translated">我们首先创建一个值为53的节点。</li><li id="7028" class="ku kv hi iz b ja ld jd le jg lf jk lg jo lh js nk la lb lc bi translated">然后我们创建一个条件语句:</li></ol><ul class=""><li id="bd58" class="ku kv hi iz b ja jb jd je jg kw jk kx jo ky js kz la lb lc bi translated"><code class="du nf ng nh ni b">If</code>列表是空的，我们的新节点将是列表的头和尾。</li><li id="59d0" class="ku kv hi iz b ja ld jd le jg lf jk lg jo lh js kz la lb lc bi translated"><strong class="iz hj">或者</strong> <code class="du nf ng nh ni b">else</code>，既然不想让我们原来的头完全变异，我们就把原来的头设置成一个新变量<code class="du nf ng nh ni b">temp</code>。然后我们把我们的新节点设置为新的头，我们原来的头成为下一个带<code class="du nf ng nh ni b">this.first.next</code>的节点。</li></ul><p id="09d0" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">3.最后但同样重要的是，我们将列表的大小增加1。</p><p id="cb6e" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">很酷，对吧？接下来，让我们从列表中“弹出”53个(比如你的衣服)。</p><h2 id="4d1b" class="lp lq hi bd lr ls lt lu lv lw lx ly lz jg ma mb mc jk md me mf jo mg mh mi mj bi translated">流行()</h2><figure class="jv jw jx jy fd jz er es paragraph-image"><div class="er es nj"><img src="../Images/9e71f80f84f32c2e1484df3347ae2329.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/1*_WfaYL7hZeewKX2DLsMHHA.gif"/></div><figcaption class="kg kh et er es ki kj bd b be z dx translated">信用:<a class="ae kk" href="https://visualgo.net/en/list" rel="noopener ugc nofollow" target="_blank"> VisuAlgo </a></figcaption></figure><p id="353e" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">类似于我们的<code class="du nf ng nh ni b">push</code>方法，没有内置的方法将值“弹出”列表。所以我们需要写一个:</p><figure class="jv jw jx jy fd jz"><div class="bz dy l di"><div class="nc nd l"/></div></figure><ol class=""><li id="31b9" class="ku kv hi iz b ja jb jd je jg kw jk kx jo ky js nk la lb lc bi translated">边缘情况:<code class="du nf ng nh ni b">if</code>列表为空，我们什么都不用做，直接返回<code class="du nf ng nh ni b">null</code>。</li><li id="2877" class="ku kv hi iz b ja ld jd le jg lf jk lg jo lh js nk la lb lc bi translated">将当前头(53)设置为变量<code class="du nf ng nh ni b">temp</code>。如果头部和尾部(即列表的大小为1)相同，我们可以将尾部设置为<code class="du nf ng nh ni b">null</code>，因为我们不需要遍历整个列表。如果我们的列表不满足条件语句，我们可以忽略它。</li></ol><p id="69d3" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">3.然后，我们将头设置到下一个节点(因为我们正在删除当前的头)。将列表的大小减1。</p><p id="4e3c" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">4.最后但同样重要的是，该函数返回当前头<code class="du nf ng nh ni b">temp</code>的<code class="du nf ng nh ni b">value</code>。</p><h2 id="0f56" class="lp lq hi bd lr ls lt lu lv lw lx ly lz jg ma mb mc jk md me mf jo mg mh mi mj bi translated">长队</h2><p id="7590" class="pw-post-body-paragraph ix iy hi iz b ja mk ij jc jd ml im jf jg mm ji jj jk mn jm jn jo mo jq jr js hb bi translated">我们队列的起始代码</p><figure class="jv jw jx jy fd jz"><div class="bz dy l di"><div class="nc nd l"/></div><figcaption class="kg kh et er es ki kj bd b be z dx translated">代码与stack非常相似，除了我们将类名从Stack改为Queue。</figcaption></figure><p id="265a" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi jt translated">Queue……发音像字母“Q”，这个“-ueue”是什么意思？不管怎样，我们不是在学习英语，而是在学习计算机语言。在英式英语中，queue是队列。在美式英语中，queue的意思是排队。所以“队列”是什么就不言自明了。</p><p id="31b3" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在我们的日常生活中，我们排队…几乎所有的事情。好吧，想想办公室的斯坦利，他喜欢椒盐卷饼日。</p><figure class="jv jw jx jy fd jz er es paragraph-image"><div class="er es nl"><img src="../Images/6f221484ae8e4b25bf57e524a63969cd.png" data-original-src="https://miro.medium.com/v2/resize:fit:920/format:webp/0*nTSz1qI7YBRWDpLC.jpg"/></div><figcaption class="kg kh et er es ki kj bd b be z dx translated">《信用:办公室——椒盐卷饼日》(第三季第五集)</figcaption></figure><p id="e124" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">今天是椒盐卷饼日，每个人都要排队领取免费椒盐卷饼。队列的概念是<strong class="iz hj"> FIFO </strong>，又名<strong class="iz hj">F</strong>first-<strong class="iz hj">I</strong>n-<strong class="iz hj">F</strong>first-<strong class="iz hj">O</strong>ut。在数组方面，有两种方法可以满足条件:<code class="du nf ng nh ni b">push</code>和<code class="du nf ng nh ni b">shift</code>。在队列中，push称为<code class="du nf ng nh ni b">enqueue</code>，shift称为<code class="du nf ng nh ni b">dequeue</code>。因为没有内置的方法，所以让我们构建自己的函数。</p><h2 id="7d5c" class="lp lq hi bd lr ls lt lu lv lw lx ly lz jg ma mb mc jk md me mf jo mg mh mi mj bi translated">排队(val)</h2><figure class="jv jw jx jy fd jz er es paragraph-image"><div class="er es nm"><img src="../Images/23a73d4f9c6d8d5848fca44bc1829296.png" data-original-src="https://miro.medium.com/v2/resize:fit:856/1*nQd7RB2fAYbv_fxUY6J0wA.gif"/></div><figcaption class="kg kh et er es ki kj bd b be z dx translated">信用:<a class="ae kk" href="https://visualgo.net/en/list" rel="noopener ugc nofollow" target="_blank"> VisuAlgo </a></figcaption></figure><p id="b529" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">斯坦利兴奋地等着轮到他拿免费的椒盐卷饼。但是当斯坦利认为菲利斯因为鲍勃而试图插队时，不行。斯坦利疯了！菲利斯必须到队伍后面去。</p><figure class="jv jw jx jy fd jz er es paragraph-image"><div role="button" tabindex="0" class="ka kb di kc bf kd"><div class="er es nn"><img src="../Images/4184895a20403492a63944cd18953ffe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*USl-IrKWVduOS_On.jpg"/></div></div><figcaption class="kg kh et er es ki kj bd b be z dx translated">信用:<a class="ae kk" href="https://www.reddit.com/r/DunderMifflin/comments/a7mjmx/getting_between_stanley_and_pretzel_day_might_be/" rel="noopener ugc nofollow" target="_blank">Reddit</a>/办公室</figcaption></figure><p id="a186" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">为此，我们的函数如下所示:</p><figure class="jv jw jx jy fd jz"><div class="bz dy l di"><div class="nc nd l"/></div></figure><p id="2044" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">事情是这样的:</p><ol class=""><li id="8933" class="ku kv hi iz b ja jb jd je jg kw jk kx jo ky js nk la lb lc bi translated">我们首先用参数中接受的值创建新节点(在我们的例子中是Phyllis)。</li><li id="acad" class="ku kv hi iz b ja ld jd le jg lf jk lg jo lh js nk la lb lc bi translated">然后我们创建一个条件语句:</li></ol><ul class=""><li id="a288" class="ku kv hi iz b ja jb jd je jg kw jk kx jo ky js kz la lb lc bi translated">我们首先检查是否有标题(即列表是否为空)。头部不存在，我们的新节点将是列表的头部和尾部。</li><li id="9744" class="ku kv hi iz b ja ld jd le jg lf jk lg jo lh js kz la lb lc bi translated"><code class="du nf ng nh ni b">else</code>，我们将当前tail的下一个节点设置为我们的新节点<code class="du nf ng nh ni b">newNode</code>，因此，我们的<code class="du nf ng nh ni b">newNode</code>将成为我们列表的新tail。</li></ul><p id="daec" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">3.最后但同样重要的是，将列表的大小增加1。</p><h2 id="a0ae" class="lp lq hi bd lr ls lt lu lv lw lx ly lz jg ma mb mc jk md me mf jo mg mh mi mj bi translated">出列()</h2><figure class="jv jw jx jy fd jz er es paragraph-image"><div class="er es nm"><img src="../Images/3e0fd01aa9e3df186347c0ddf5ea4e60.png" data-original-src="https://miro.medium.com/v2/resize:fit:856/1*zCODkwQOzmPPMxweUAXEXQ.gif"/></div><figcaption class="kg kh et er es ki kj bd b be z dx translated">信用:<a class="ae kk" href="https://visualgo.net/en/list" rel="noopener ugc nofollow" target="_blank"> VisuAlgo </a></figcaption></figure><figure class="jv jw jx jy fd jz er es paragraph-image"><div role="button" tabindex="0" class="ka kb di kc bf kd"><div class="er es no"><img src="../Images/06640dc49729ef1bc98ba4820d616e50.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*edz3gNHu4mDC-XBR.jpg"/></div></div><figcaption class="kg kh et er es ki kj bd b be z dx translated">我需要一张斯坦利拿着椒盐卷饼做填字游戏时的截图。这是第九季第18集。请忽略字幕！</figcaption></figure><p id="db9f" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">耶！斯坦利终于得到了他的椒盐卷饼！让我们<code class="du nf ng nh ni b">dequeue</code>/把他从我们的队列中弹出来。</p><figure class="jv jw jx jy fd jz"><div class="bz dy l di"><div class="nc nd l"/></div></figure><p id="154c" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这与<code class="du nf ng nh ni b">Stack</code>中的<code class="du nf ng nh ni b">pop</code>函数代码完全相同。如果你需要提醒的话，以下是步骤:</p><ol class=""><li id="7d10" class="ku kv hi iz b ja jb jd je jg kw jk kx jo ky js nk la lb lc bi translated">边缘情况:<code class="du nf ng nh ni b">if</code>列表为空，我们什么都不用做，只需返回<code class="du nf ng nh ni b">null</code>。</li><li id="72f6" class="ku kv hi iz b ja ld jd le jg lf jk lg jo lh js nk la lb lc bi translated">将我们当前的头(Stanley)设置为变量<code class="du nf ng nh ni b">temp</code>。如果头部和尾部(即列表的大小为1)相同，我们可以将尾部设置为<code class="du nf ng nh ni b">null</code>，因为我们不需要遍历整个列表。如果我们的列表不满足条件语句，我们可以忽略它。</li></ol><p id="f397" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">3.然后，我们将头设置到下一个节点(因为我们正在删除当前的头)。将列表的大小减1。</p><p id="eb1a" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">4.最后但同样重要的是，该函数返回当前头<code class="du nf ng nh ni b">temp</code>的<code class="du nf ng nh ni b">value</code>。</p><p id="b9f1" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">那就差不多了<code class="du nf ng nh ni b">Queue</code>！相当令人兴奋的东西和相当直观的我会说！</p></div><div class="ab cl li lj gp lk" role="separator"><span class="ll bw bk lm ln lo"/><span class="ll bw bk lm ln lo"/><span class="ll bw bk lm ln"/></div><div class="hb hc hd he hf"><h2 id="2bd3" class="lp lq hi bd lr ls lt lu lv lw lx ly lz jg ma mb mc jk md me mf jo mg mh mi mj bi translated">堆栈和队列的大O</h2><p id="6681" class="pw-post-body-paragraph ix iy hi iz b ja mk ij jc jd ml im jf jg mm ji jj jk mn jm jn jo mo jq jr js hb bi jt translated"><span class="l kl km kn bm ko kp kq kr ks di">正如前面在链表部分提到的</span>，与数组相比，链表更适合于插入和移除。就时间复杂度而言，链表中的<strong class="iz hj">插入和移除是O(1) </strong>，而数组中的<strong class="iz hj">插入和移除是O(n) </strong>，因为数组需要遍历链表来遍历元素的索引等。</p><p id="cb41" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">然而，<strong class="iz hj">搜索和访问</strong>并不是链表的最佳选择，因为计算机必须遍历每个节点才能找到那个特定的。因此，<strong class="iz hj">链表的时间复杂度为O(n) </strong>。但是在array中，计算机可以简单地搜索和访问元素，因为元素是用索引“标记”的(例如。数组[1])。因此，<strong class="iz hj">数组的时间复杂度为O(1) </strong>。</p></div><div class="ab cl li lj gp lk" role="separator"><span class="ll bw bk lm ln lo"/><span class="ll bw bk lm ln lo"/><span class="ll bw bk lm ln"/></div><div class="hb hc hd he hf"><h2 id="3165" class="lp lq hi bd lr ls lt lu lv lw lx ly lz jg ma mb mc jk md me mf jo mg mh mi mj bi translated">总结:堆栈和队列之间的比较</h2><p id="85a7" class="pw-post-body-paragraph ix iy hi iz b ja mk ij jc jd ml im jf jg mm ji jj jk mn jm jn jo mo jq jr js hb bi jt translated"><span class="l kl km kn bm ko kp kq kr ks di">到</span>结束这篇文章，让我们比较一下堆栈和队列的区别。</p><ul class=""><li id="119b" class="ku kv hi iz b ja jb jd je jg kw jk kx jo ky js kz la lb lc bi translated"><strong class="iz hj">堆栈</strong>基于<strong class="iz hj">后进先出</strong>原则，即<strong class="iz hj"> </strong>最后插入的<strong class="iz hj">最后一个</strong>元素将是<strong class="iz hj">第一个</strong>元素以“离开”列表</li><li id="417c" class="ku kv hi iz b ja ld jd le jg lf jk lg jo lh js kz la lb lc bi translated">在<strong class="iz hj">堆栈</strong>中，插入和删除从顶部开始，而在<strong class="iz hj">队列</strong>中，插入和删除从列表的另一端开始——插入发生在列表的后面，删除发生在列表的前面。</li><li id="6029" class="ku kv hi iz b ja ld jd le jg lf jk lg jo lh js kz la lb lc bi translated"><strong class="iz hj">堆栈:</strong>插入- &gt;推送和删除- &gt;弹出vs <strong class="iz hj">队列</strong>:插入- &gt;入队和删除- &gt;出列</li></ul></div><div class="ab cl li lj gp lk" role="separator"><span class="ll bw bk lm ln lo"/><span class="ll bw bk lm ln lo"/><span class="ll bw bk lm ln"/></div><div class="hb hc hd he hf"><p id="d795" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">感谢阅读这篇文章！如果你期待一些非常专业的术语和解释，我很抱歉。我写这篇文章就好像我试图向一个不完全理解计算机科学如何工作的朋友解释这一点，这种方法帮助我更直观地理解概念。我希望你喜欢这篇文章！</p></div><div class="ab cl li lj gp lk" role="separator"><span class="ll bw bk lm ln lo"/><span class="ll bw bk lm ln lo"/><span class="ll bw bk lm ln"/></div><div class="hb hc hd he hf"><h1 id="2d1f" class="mr lq hi bd lr ms np mu lv mv nq mx lz io nr ip mc ir ns is mf iu nt iv mi nb bi translated">资源</h1><p id="eb49" class="pw-post-body-paragraph ix iy hi iz b ja mk ij jc jd ml im jf jg mm ji jj jk mn jm jn jo mo jq jr js hb bi translated">要理解堆栈和队列:</p><div class="nu nv ez fb nw nx"><a href="https://www.geeksforgeeks.org/difference-between-stack-and-queue-data-structures/" rel="noopener  ugc nofollow" target="_blank"><div class="ny ab dw"><div class="nz ab oa cl cj ob"><h2 class="bd hj fi z dy oc ea eb od ed ef hh bi translated">堆栈和队列数据结构的区别</h2><div class="oe l"><h3 class="bd b fi z dy oc ea eb od ed ef dx translated">堆栈和队列数据结构的区别堆栈是一种线性数据结构，其中的元素可以是…</h3></div><div class="of l"><p class="bd b fp z dy oc ea eb od ed ef dx translated">www.geeksforgeeks.org</p></div></div><div class="og l"><div class="oh l oi oj ok og ol ke nx"/></div></div></a></div><p id="f98b" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">对于视觉学习者:</p><div class="nu nv ez fb nw nx"><a href="https://visualgo.net/en/list" rel="noopener  ugc nofollow" target="_blank"><div class="ny ab dw"><div class="nz ab oa cl cj ob"><h2 class="bd hj fi z dy oc ea eb od ed ef hh bi translated">链表(单链表，双链表)，堆栈，队列，队列</h2><div class="oe l"><h3 class="bd b fi z dy oc ea eb od ed ef dx translated">链表是一种数据结构，由一组顶点(节点)组成，它们共同代表一个序列。在…下面</h3></div><div class="of l"><p class="bd b fp z dy oc ea eb od ed ef dx translated">visualgo.net</p></div></div><div class="og l"><div class="om l oi oj ok og ol ke nx"/></div></div></a></div><p id="8628" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">关于链表的更多信息:</p><div class="nu nv ez fb nw nx"><a href="https://blog.usejournal.com/linked-list-a64cd53edf43" rel="noopener  ugc nofollow" target="_blank"><div class="ny ab dw"><div class="nz ab oa cl cj ob"><h2 class="bd hj fi z dy oc ea eb od ed ef hh bi translated">链表</h2><div class="oe l"><h3 class="bd b fi z dy oc ea eb od ed ef dx translated">各位程序员好！我写的上一篇博客是关于一个叫做动态编程的数据结构概念…</h3></div><div class="of l"><p class="bd b fp z dy oc ea eb od ed ef dx translated">blog.usejournal.com</p></div></div><div class="og l"><div class="on l oi oj ok og ol ke nx"/></div></div></a></div><div class="nu nv ez fb nw nx"><a href="https://www.geeksforgeeks.org/data-structures/linked-list/" rel="noopener  ugc nofollow" target="_blank"><div class="ny ab dw"><div class="nz ab oa cl cj ob"><h2 class="bd hj fi z dy oc ea eb od ed ef hh bi translated">链表数据结构- GeeksforGeeks</h2><div class="oe l"><h3 class="bd b fi z dy oc ea eb od ed ef dx translated">链表是一种线性数据结构，其中的元素不是存储在连续的内存位置。的…</h3></div><div class="of l"><p class="bd b fp z dy oc ea eb od ed ef dx translated">www.geeksforgeeks.org</p></div></div><div class="og l"><div class="oo l oi oj ok og ol ke nx"/></div></div></a></div><p id="9de9" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">根据我对数据结构和算法的基本概念的理解，我了解到:</p><div class="nu nv ez fb nw nx"><a href="https://www.udemy.com/course/js-algorithms-and-data-structures-masterclass/" rel="noopener  ugc nofollow" target="_blank"><div class="ny ab dw"><div class="nz ab oa cl cj ob"><h2 class="bd hj fi z dy oc ea eb od ed ef hh bi translated">JavaScript (JS)算法和数据结构大师班</h2><div class="oe l"><h3 class="bd b fi z dy oc ea eb od ed ef dx translated">嗨！我是柯尔特。我是一名热爱教学的开发人员。过去几年我一直在教人们…</h3></div><div class="of l"><p class="bd b fp z dy oc ea eb od ed ef dx translated">www.udemy.com</p></div></div><div class="og l"><div class="op l oi oj ok og ol ke nx"/></div></div></a></div><p id="51e4" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">还有花生漫画里的一点幽默:</p><figure class="jv jw jx jy fd jz er es paragraph-image"><div class="er es oq"><img src="../Images/26682fe8563d8b4b0924b0027ad2d23d.png" data-original-src="https://miro.medium.com/v2/resize:fit:790/format:webp/0*7DRyrAqdqn7wT8hb.jpg"/></div><figcaption class="kg kh et er es ki kj bd b be z dx translated">查理·布朗向精神病医生露西寻求帮助</figcaption></figure></div></div>    
</body>
</html>