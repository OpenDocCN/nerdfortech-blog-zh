<html>
<head>
<title>Using the animation system | Unity</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用动画系统| Unity</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/using-the-animation-system-unity-d80c8be71f87?source=collection_archive---------14-----------------------#2021-07-19">https://medium.com/nerd-for-tech/using-the-animation-system-unity-d80c8be71f87?source=collection_archive---------14-----------------------#2021-07-19</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><h2 id="a78e" class="hg hh hi bd b fp hj hk hl hm hn ho dx hp translated" aria-label="kicker paragraph">统一指南</h2><div class=""/><div class=""><h2 id="e124" class="pw-subtitle-paragraph io hr hi bd b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf dx translated">如何在 Unity 中使用动画系统的快速指南</h2></div><figure class="jh ji jj jk fd jl er es paragraph-image"><div role="button" tabindex="0" class="jm jn di jo bf jp"><div class="er es jg"><img src="../Images/a0a59f0b644b272d3f4b828ab5650d0d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*ilrlVr_IS9vVdPJlHFgpUg.gif"/></div></div></figure><p id="77c9" class="pw-post-body-paragraph js jt hi ju b jv jw is jx jy jz iv ka kb kc kd ke kf kg kh ki kj kk kl km kn hb bi translated"><strong class="ju hs">目标</strong>:使用 Unity 的动画系统在移动的 3D 模型中实现一对动画。</p><p id="0ad0" class="pw-post-body-paragraph js jt hi ju b jv jw is jx jy jz iv ka kb kc kd ke kf kg kh ki kj kk kl km kn hb bi translated">在上一篇文章中，我介绍了<a class="ae ko" rel="noopener" href="/nerd-for-tech/point-click-to-move-unity-6e2a0ab858fc">如何用 Unity </a>点击移动角色。现在，是时候使用 Unity 的动画系统在玩家移动或等待时实现各自的动画了。</p><h1 id="7d0c" class="kp kq hi bd kr ks kt ku kv kw kx ky kz ix la iy lb ja lc jb ld jd le je lf lg bi translated">玩家</h1><p id="3c2c" class="pw-post-body-paragraph js jt hi ju b jv lh is jx jy li iv ka kb lj kd ke kf lk kh ki kj ll kl km kn hb bi translated">我们已经用场景中相应的 3D 模型替换了原始的胶囊游戏对象:</p><figure class="jh ji jj jk fd jl er es paragraph-image"><div role="button" tabindex="0" class="jm jn di jo bf jp"><div class="er es lm"><img src="../Images/dd347e74608c40a03f6999e5c344ab90.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nnPTvSO3hNoMISFkToVdJw.png"/></div></div></figure><p id="e240" class="pw-post-body-paragraph js jt hi ju b jv jw is jx jy jz iv ka kb kc kd ke kf kg kh ki kj kk kl km kn hb bi translated">这个模型是一个预置，它是玩家游戏对象的子对象。为了开始制作模型的动画，让我们选择它，然后通过检查器给它附加一个新的<strong class="ju hs">动画师</strong>组件:</p><div class="jh ji jj jk fd ab cb"><figure class="ln jl lo lp lq lr ls paragraph-image"><div role="button" tabindex="0" class="jm jn di jo bf jp"><img src="../Images/7a4a566796da4db5ba9a54cc88188bdb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1004/format:webp/1*6bE-gF76B-oSEMJO5oE6-A.png"/></div></figure><figure class="ln jl lt lp lq lr ls paragraph-image"><div role="button" tabindex="0" class="jm jn di jo bf jp"><img src="../Images/60c58efe8d41a33b8e13aee12a9d4e42.png" data-original-src="https://miro.medium.com/v2/resize:fit:998/1*AnERP0DKV05ZIT2-_izNcQ.gif"/></div></figure></div><p id="2389" class="pw-post-body-paragraph js jt hi ju b jv jw is jx jy jz iv ka kb kc kd ke kf kg kh ki kj kk kl km kn hb bi translated">这个模型有 3 个不同的动画剪辑:</p><ul class=""><li id="ca14" class="lu lv hi ju b jv jw jy jz kb lw kf lx kj ly kn lz ma mb mc bi translated">闲置的</li><li id="a47a" class="lu lv hi ju b jv md jy me kb mf kf mg kj mh kn lz ma mb mc bi translated">扔</li><li id="fc08" class="lu lv hi ju b jv md jy me kb mf kf mg kj mh kn lz ma mb mc bi translated">步行</li></ul><figure class="jh ji jj jk fd jl er es paragraph-image"><div class="er es mi"><img src="../Images/ec560799c4a3306d955d0f043566214c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1028/1*QVVDOUP9DaWdrK1CLcArIw.gif"/></div></figure><p id="185c" class="pw-post-body-paragraph js jt hi ju b jv jw is jx jy jz iv ka kb kc kd ke kf kg kh ki kj kk kl km kn hb bi translated">现在，为了控制动画剪辑，让我们创建一个新的<strong class="ju hs">动画控制器</strong>并将其拖动到我们模型中的<strong class="ju hs"> Animator </strong>组件:</p><div class="jh ji jj jk fd ab cb"><figure class="ln jl mj lp lq lr ls paragraph-image"><div role="button" tabindex="0" class="jm jn di jo bf jp"><img src="../Images/2a493a76a06c7dc2e96b171fede9f22b.png" data-original-src="https://miro.medium.com/v2/resize:fit:872/1*4Hp5xB8Nk9jDZhyRyaXShA.gif"/></div></figure><figure class="ln jl mk lp lq lr ls paragraph-image"><div role="button" tabindex="0" class="jm jn di jo bf jp"><img src="../Images/7768919d83d4f062757bb7deee89db53.png" data-original-src="https://miro.medium.com/v2/resize:fit:1130/1*vwHL7wT_o59YvqyU3REgmg.gif"/></div></figure></div><h1 id="216b" class="kp kq hi bd kr ks kt ku kv kw kx ky kz ix la iy lb ja lc jb ld jd le je lf lg bi translated">动画</h1><p id="9d04" class="pw-post-body-paragraph js jt hi ju b jv lh is jx jy li iv ka kb lj kd ke kf lk kh ki kj ll kl km kn hb bi translated">然后，让我们双击控制器来提示<strong class="ju hs"> Animator 窗口</strong>:</p><div class="jh ji jj jk fd ab cb"><figure class="ln jl ml lp lq lr ls paragraph-image"><div role="button" tabindex="0" class="jm jn di jo bf jp"><img src="../Images/c8e711b141468e8d2e1af5dc78f69c54.png" data-original-src="https://miro.medium.com/v2/resize:fit:1558/format:webp/1*Ltm4yZzLq8Yj8FuC9EEZBA.png"/></div></figure><figure class="ln jl mm lp lq lr ls paragraph-image"><div role="button" tabindex="0" class="jm jn di jo bf jp"><img src="../Images/497b80102d41f1ed34dc8d6cd689ff71.png" data-original-src="https://miro.medium.com/v2/resize:fit:444/1*S80FEGWMWkpSAbnxbO7LyA.gif"/></div></figure></div><p id="c906" class="pw-post-body-paragraph js jt hi ju b jv jw is jx jy jz iv ka kb kc kd ke kf kg kh ki kj kk kl km kn hb bi translated">在<strong class="ju hs">动画窗口</strong>中，我们将能够定义模型的不同状态。它基本上作为一个 FSM(有限状态机)工作，控制我们的模型在不同状态下的动画。首先，让我们将<em class="mn">空闲</em>和<em class="mn">行走</em>动画剪辑拖入窗口:</p><div class="jh ji jj jk fd ab cb"><figure class="ln jl ml lp lq lr ls paragraph-image"><div role="button" tabindex="0" class="jm jn di jo bf jp"><img src="../Images/96a3c446c850516cf17db89ab8ab0ea5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1558/1*Aylv2FfJ_Bso6QO9cDH3VQ.gif"/></div></figure><figure class="ln jl mm lp lq lr ls paragraph-image"><div role="button" tabindex="0" class="jm jn di jo bf jp"><img src="../Images/44434b4fec20666d3d1303357d7bdd79.png" data-original-src="https://miro.medium.com/v2/resize:fit:444/1*dNjCws7ZOFALYn3b_77zrg.gif"/></div></figure></div><p id="05ef" class="pw-post-body-paragraph js jt hi ju b jv jw is jx jy jz iv ka kb kc kd ke kf kg kh ki kj kk kl km kn hb bi translated">如您所见，我们添加的第一个动画剪辑被设置为默认状态。如果我们尝试像这样运行游戏，我们将能够看到<em class="mn">空闲</em>动画在我们的模型中默认播放:</p><figure class="jh ji jj jk fd jl er es paragraph-image"><div role="button" tabindex="0" class="jm jn di jo bf jp"><div class="er es lm"><img src="../Images/8745e0f5d6385eb7610e553da7d341ed.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*DW81VcjdWJhgKSJ5GxRcLw.gif"/></div></div></figure><figure class="jh ji jj jk fd jl er es paragraph-image"><div role="button" tabindex="0" class="jm jn di jo bf jp"><div class="er es lm"><img src="../Images/264332a5b1b0eae4217116088fe2f17d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*e8GMdJj_vBHlHJ45Rz-B7A.gif"/></div></div></figure><p id="3cff" class="pw-post-body-paragraph js jt hi ju b jv jw is jx jy jz iv ka kb kc kd ke kf kg kh ki kj kk kl km kn hb bi translated">因此，为了进入和离开另一个状态，让我们创建一个双向的新转换:</p><figure class="jh ji jj jk fd jl er es paragraph-image"><div role="button" tabindex="0" class="jm jn di jo bf jp"><div class="er es lm"><img src="../Images/79eeeb20fa2ba684d767d5c1881235f5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*tSi-GFvHoGlGtXH9yJQY3w.gif"/></div></div></figure><p id="968e" class="pw-post-body-paragraph js jt hi ju b jv jw is jx jy jz iv ka kb kc kd ke kf kg kh ki kj kk kl km kn hb bi translated">现在，为了控制过渡，我们需要创建一个新的 bool 参数来确定玩家是否在行走:</p><figure class="jh ji jj jk fd jl er es paragraph-image"><div role="button" tabindex="0" class="jm jn di jo bf jp"><div class="er es lm"><img src="../Images/9eb834a870edcdd60016240da4df977e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*TO0SrRnQ-fq_0lOqfq4gHQ.gif"/></div></div></figure><p id="60a8" class="pw-post-body-paragraph js jt hi ju b jv jw is jx jy jz iv ka kb kc kd ke kf kg kh ki kj kk kl km kn hb bi translated">然后，要在转场中分配新参数，让我们选择相应的箭头。选中后，让我们禁用<strong class="ju hs"> <em class="mn">具有退出时间</em> </strong>属性(无需等待动画结束即可更改状态)，并添加一个新条件来检查以下布尔值:</p><figure class="jh ji jj jk fd jl er es paragraph-image"><div role="button" tabindex="0" class="jm jn di jo bf jp"><div class="er es lm"><img src="../Images/de3c83f31b1317ab861421ca97e0c799.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*0-IbMmOB7DrrRzyUTpLSLQ.gif"/></div></div></figure><div class="jh ji jj jk fd ab cb"><figure class="ln jl mo lp lq lr ls paragraph-image"><div role="button" tabindex="0" class="jm jn di jo bf jp"><img src="../Images/760fafa32ff1135cec08aa1779c8bb48.png" data-original-src="https://miro.medium.com/v2/resize:fit:1002/1*yVcH9RFE5BGS_iHodgojEA.gif"/></div></figure><figure class="ln jl mp lp lq lr ls paragraph-image"><div role="button" tabindex="0" class="jm jn di jo bf jp"><img src="../Images/111f799d1b09c323bb971e589dbb8646.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/1*nCpM7dBc_F2VVXOqsBMemA.gif"/></div></figure></div><h1 id="8e4b" class="kp kq hi bd kr ks kt ku kv kw kx ky kz ix la iy lb ja lc jb ld jd le je lf lg bi translated">触发动画</h1><p id="7e7f" class="pw-post-body-paragraph js jt hi ju b jv lh is jx jy li iv ka kb lj kd ke kf lk kh ki kj ll kl km kn hb bi translated">现在，为了通过代码触发动画，让我们打开<strong class="ju hs"> Player </strong>脚本并创建一个新的<strong class="ju hs"> Animator </strong>变量来存储模型中组件的引用:</p><figure class="jh ji jj jk fd jl er es paragraph-image"><div class="er es mq"><img src="../Images/8a42f0d161bab5dc7ee99d68921a941a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1026/format:webp/1*6qYwnrH1JEj37-fPq8JPLw.png"/></div></figure><p id="764a" class="pw-post-body-paragraph js jt hi ju b jv jw is jx jy jz iv ka kb kc kd ke kf kg kh ki kj kk kl km kn hb bi translated">然后，在<strong class="ju hs"> Start </strong>方法中，我们使用<strong class="ju hs"> GetComponentInChildren </strong>方法初始化变量(因为 Animator 组件在子模型中):</p><figure class="jh ji jj jk fd jl er es paragraph-image"><div role="button" tabindex="0" class="jm jn di jo bf jp"><div class="er es mr"><img src="../Images/b4f52f380c3fc00acd3698f370eb91e7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oZdyXdUlmExofD3dStDUgA.png"/></div></div></figure><p id="8e18" class="pw-post-body-paragraph js jt hi ju b jv jw is jx jy jz iv ka kb kc kd ke kf kg kh ki kj kk kl km kn hb bi translated">最后，为了触发动画，我们将使用<strong class="ju hs"> <em class="mn">导航网格代理</em> </strong>的速度。如果你读了<a class="ae ko" rel="noopener" href="/nerd-for-tech/point-click-to-move-unity-6e2a0ab858fc">的上一篇文章</a>，你会记得这个组件是附在玩家身上的，目的是控制它在场景中的移动。</p><p id="15af" class="pw-post-body-paragraph js jt hi ju b jv jw is jx jy jz iv ka kb kc kd ke kf kg kh ki kj kk kl km kn hb bi translated">由于<strong class="ju hs"> <em class="mn">导航网格代理</em> </strong>的速度用 Vector3 表示，我们将使用<strong class="ju hs"> sqrmagnitude </strong>来比较一个简单的 float 值。如果该值小于 1，我们将把我们的 Animator 组件中的 bool 设置为<strong class="ju hs">假</strong>，否则，bool 将被设置为<strong class="ju hs">真</strong>:</p><figure class="jh ji jj jk fd jl er es paragraph-image"><div class="er es ms"><img src="../Images/8972e8eb8b76d163fd30e484dc4db186.png" data-original-src="https://miro.medium.com/v2/resize:fit:1324/format:webp/1*XB-WWDpMQhpa0ztZYZBzPg.png"/></div></figure><p id="9987" class="pw-post-body-paragraph js jt hi ju b jv jw is jx jy jz iv ka kb kc kd ke kf kg kh ki kj kk kl km kn hb bi translated">如果您想了解更多关于<strong class="ju hs"><em class="mn">Nav Mesh Agent</em></strong>velocity 的信息，您可以访问 Unity 文档:</p><div class="mt mu ez fb mv mw"><a href="https://docs.unity3d.com/es/2018.4/ScriptReference/AI.NavMeshAgent-velocity.html" rel="noopener  ugc nofollow" target="_blank"><div class="mx ab dw"><div class="my ab mz cl cj na"><h2 class="bd hs fi z dy nb ea eb nc ed ef hr bi translated">艾。NavMeshAgent-velocity - Unity 脚本 API</h2><div class="nd l"><h3 class="bd b fi z dy nb ea eb nc ed ef dx translated">读取变量将返回基于人群模拟的代理的当前速度。正在设置变量…</h3></div><div class="ne l"><p class="bd b fp z dy nb ea eb nc ed ef dx translated">docs.unity3d.com</p></div></div></div></a></div><p id="9cb8" class="pw-post-body-paragraph js jt hi ju b jv jw is jx jy jz iv ka kb kc kd ke kf kg kh ki kj kk kl km kn hb bi translated">这样，我们可以确定当玩家的<strong class="ju hs"> <em class="mn">导航网格代理</em> </strong>停止时，我们将返回到空闲状态动画。如果我们在 Unity 中运行游戏，我们会注意到动画按预期工作:</p><figure class="jh ji jj jk fd jl er es paragraph-image"><div role="button" tabindex="0" class="jm jn di jo bf jp"><div class="er es jg"><img src="../Images/112b54d29ec577eb881a9f7f227272a6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*btGEOamdA-Gw7MXuMSNPYw.gif"/></div></div></figure><p id="800b" class="pw-post-body-paragraph js jt hi ju b jv jw is jx jy jz iv ka kb kc kd ke kf kg kh ki kj kk kl km kn hb bi translated">仅此而已，我们可以用 Unity 的动画系统！我会在下一篇文章中看到你，在那里我将展示如何用 Unity 创建一个模块化的航点系统。</p></div><div class="ab cl nf ng gp nh" role="separator"><span class="ni bw bk nj nk nl"/><span class="ni bw bk nj nk nl"/><span class="ni bw bk nj nk"/></div><div class="hb hc hd he hf"><blockquote class="nm nn no"><p id="696c" class="js jt mn ju b jv jw is jx jy jz iv ka np kc kd ke nq kg kh ki nr kk kl km kn hb bi translated"><em class="hi">如果你想了解我更多，欢迎登陆</em><a class="ae ko" href="https://www.linkedin.com/in/fas444/" rel="noopener ugc nofollow" target="_blank"><strong class="ju hs"><em class="hi">LinkedIn</em></strong></a><strong class="ju hs"><em class="hi"/></strong><em class="hi">或访问我的</em> <a class="ae ko" href="http://fernandoalcasan.com/" rel="noopener ugc nofollow" target="_blank"> <strong class="ju hs"> <em class="hi">网站</em> </strong> </a> <em class="hi"> :D </em></p></blockquote></div></div>    
</body>
</html>