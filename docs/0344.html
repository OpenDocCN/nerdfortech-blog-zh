<html>
<head>
<title>Serialization/Deserialization with Protobufs</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用 Protobufs 进行序列化/反序列化</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/serialization-deserialization-with-protobufs-223d401f621d?source=collection_archive---------0-----------------------#2020-10-12">https://medium.com/nerd-for-tech/serialization-deserialization-with-protobufs-223d401f621d?source=collection_archive---------0-----------------------#2020-10-12</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/d1d24a04742d015d7899c843813b4280.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7lIirhxrmCjg5pSeHch8lg.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">图片由 Girija Shankar Behera 提供</figcaption></figure><p id="838a" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">在这篇文章中，我将写一下<strong class="iw hj">谷歌</strong>以特定格式<strong class="iw hj">序列化和反序列化</strong>数据的方式。它最初是由谷歌开发人员开发的，作为他们自己通过网络发送数据的内部机制，着眼于提高网络性能和使用率。它主要被设计得比 XML 更简单，但在存储和传输方面更小更快。</p><p id="316c" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">这篇文章简要介绍了了解<strong class="iw hj">协议缓冲区</strong>的必要性。它也作为下一个的基础，因为那将是关于<strong class="iw hj">张量流记录</strong>。理解 protobufs 也使得使用 tfrecords 变得更加容易。</p><h2 id="f96c" class="js jt hi bd ju jv jw jx jy jz ka kb kc jf kd ke kf jj kg kh ki jn kj kk kl km bi translated">什么是协议缓冲区？</h2><p id="1e6f" class="pw-post-body-paragraph iu iv hi iw b ix kn iz ja jb ko jd je jf kp jh ji jj kq jl jm jn kr jp jq jr hb bi translated">根据 Google Protobuf 文档，</p><blockquote class="ks"><p id="3043" class="kt ku hi bd kv kw kx ky kz la lb jr dx translated">协议缓冲区是 Google 的语言中立、平台中立、可扩展的机制，用于序列化结构化数据——想想 XML，但是更小、更快、更简单。</p></blockquote><p id="45fe" class="pw-post-body-paragraph iu iv hi iw b ix lc iz ja jb ld jd je jf le jh ji jj lf jl jm jn lg jp jq jr hb bi translated">简单地说，protobufs 只是将消息序列化为二进制格式的另一种方式。序列化的输出是一个字节序列，非常密集，努力节省空间。然后，字节通过线路传输，这比以<strong class="iw hj"> XML 或 JSON </strong>格式发送相同的数据花费的时间要少得多。用 protobufs 序列化和反序列化数据甚至更快。</p><h2 id="93a4" class="js jt hi bd ju jv jw jx jy jz ka kb kc jf kd ke kf jj kg kh ki jn kj kk kl km bi translated">为什么我们需要协议缓冲区？</h2><p id="3d86" class="pw-post-body-paragraph iu iv hi iw b ix kn iz ja jb ko jd je jf kp jh ji jj kq jl jm jn kr jp jq jr hb bi translated">Protobufs 只是使用 XML 或 JSON 传输消息的传统方式的替代品。当网络中的性能或负载是应用程序的主要关注点时，这是首选。让我们来看一个例子，看看所有这些格式的消息有多大。我这里有一个字符串“Medium”要序列化。</p><figure class="lh li lj lk fd ij"><div class="bz dy l di"><div class="ll lm l"/></div></figure><p id="b6cd" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">这些格式的唯一区别是文本在 XML 和 JSON 中是可读的，但在 protobuf 格式中是不可读的。但是如果可读性不是问题，那么我们可以看到 protobufs 占用的空间比它的 XML 和 JSON 变体少得多。与 XML 和 JSON 相比，它允许我们通过网络发送大块的数据，占用更少的空间。</p><h2 id="96b4" class="js jt hi bd ju jv jw jx jy jz ka kb kc jf kd ke kf jj kg kh ki jn kj kk kl km bi translated">协议缓冲格式</h2><blockquote class="ln lo lp"><p id="9899" class="iu iv lq iw b ix iy iz ja jb jc jd je lr jg jh ji ls jk jl jm lt jo jp jq jr hb bi translated">protobuf 的工作从声明我们想要在<strong class="iw hj"> protofile </strong>中传输的数据结构开始，然后用<strong class="iw hj">protocol</strong>对其进行编译。这就在发送方和接收方产生了编译的代码，该代码作为传输数据的数据结构的源。</p></blockquote><figure class="lh li lj lk fd ij"><div class="bz dy l di"><div class="ll lm l"/></div></figure><p id="aa15" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">这里有一个小的原型文件，包含一个带有两个字段的消息类型。原型文件的扩展名是“”。proto”。这里的第一个字段是字符串字段“name ”,第二个字段是 int32 类型的“age”。右边的数字是标签，在反序列化数据时很有用。反序列化器在解密数据时使用我们明确定义的标记中的编号方案。现在这个 proto 可以用代码中提到的 protoc 编译器编译，这将产生类似于<a class="ae lu" href="https://gist.github.com/girija2204/06f25205af185ca15b1f5bc7135c6b4f" rel="noopener ugc nofollow" target="_blank"> this </a>的编译后的类输出。我用 python 格式进行了编译，作为输出，这将允许我们将消息类型用作普通的 Python 类，并且可以如下所示进行实例化。</p><h2 id="4eca" class="js jt hi bd ju jv jw jx jy jz ka kb kc jf kd ke kf jj kg kh ki jn kj kk kl km bi translated"><strong class="ak">用法</strong></h2><p id="7412" class="pw-post-body-paragraph iu iv hi iw b ix kn iz ja jb ko jd je jf kp jh ji jj kq jl jm jn kr jp jq jr hb bi translated">下面的代码使用来自 protofile 的消息作为一个类，并实例化它。然后，它为其属性赋值。这类似于我们在 Python 中实例化一个类的方式。</p><figure class="lh li lj lk fd ij"><div class="bz dy l di"><div class="ll lm l"/></div></figure><p id="c64b" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">序列化过程也很简单。只需调用方法 SerializeToString 来获取它的二进制，可以用 bytes 格式传输。</p><p id="79fa" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">理解整个序列化过程超出了这里的范围，它使用<strong class="iw hj"> <em class="lq"> Varints </em> </strong> 的<a class="ae lu" href="https://developers.google.com/protocol-buffers/docs/encoding" rel="noopener ugc nofollow" target="_blank">序列化过程对数据进行编码。</a></p><p id="8d33" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">那么，后端到底发生了什么让我们可以创建一个 Person 类的实例呢？我们刚刚创建了一个名为 proto 的文件，其中包含一种消息类型。然后我们用 protoc 编译器编译它，它创建了一个名为 person_pb2.py 的文件，这个文件被导入到这里来访问消息类型 person 作为一个类。为了了解后端发生了什么，我分析了下面的编译文件。</p><h2 id="5df1" class="js jt hi bd ju jv jw jx jy jz ka kb kc jf kd ke kf jj kg kh ki jn kj kk kl km bi translated">内幕</h2><p id="a722" class="pw-post-body-paragraph iu iv hi iw b ix kn iz ja jb ko jd je jf kp jh ji jj kq jl jm jn kr jp jq jr hb bi translated">所以它从一个叫做描述符的东西开始，顾名思义，它给出了关于写在 proto 文件中的消息类型的基本信息。有不同类型的描述符，<strong class="iw hj">文件描述符，字段描述符，枚举描述符，枚举值描述符，描述符</strong>等。</p><figure class="lh li lj lk fd ij"><div class="bz dy l di"><div class="ll lm l"/></div></figure><p id="c9eb" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">这是一个<strong class="iw hj">文件描述符</strong>，它捕获关于文件内容的信息。它包含了 proto 文件的名称、中声明的包、表明它遵循 proto3 版本的语法以及一些其他信息。</p><figure class="lh li lj lk fd ij"><div class="bz dy l di"><div class="ll lm l"/></div></figure><p id="91d9" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">生成的编译代码的下一部分是 proto 文件中定义的实际消息类型的描述符。描述符的名称以下划线开头，后跟全大写的消息类型名称。它包含消息类型的名称、全名(包括范围)，以及字段的描述符。文件的描述符是上面的<strong class="iw hj">文件描述符</strong>，消息的描述符是<strong class="iw hj">描述符</strong>，字段的描述符是<strong class="iw hj">字段描述符</strong>。FieldDescriptor 使用:</p><ul class=""><li id="6ccc" class="lv lw hi iw b ix iy jb jc jf lx jj ly jn lz jr ma mb mc md bi translated"><strong class="iw hj">索引</strong> —指示原型文件中字段的顺序</li><li id="3aac" class="lv lw hi iw b ix me jb mf jf mg jj mh jn mi jr ma mb mc md bi translated"><strong class="iw hj">编号</strong> —表示标签</li><li id="07fe" class="lv lw hi iw b ix me jb mf jf mg jj mh jn mi jr ma mb mc md bi translated"><strong class="iw hj"> type </strong> —表示用数字表示的变量的数据类型(9 表示字符串，3 表示 int32)</li><li id="d8b9" class="lv lw hi iw b ix me jb mf jf mg jj mh jn mi jr ma mb mc md bi translated"><strong class="iw hj"> has_default_value </strong> —指示是否已提供默认值的布尔字段</li><li id="61fa" class="lv lw hi iw b ix me jb mf jf mg jj mh jn mi jr ma mb mc md bi translated"><strong class="iw hj"> default_value </strong> —表示缺省情况下提供的值，如果未提供，则 protobuf 具有为每种数据类型定义的缺省值。请继续到底部找到默认值<strong class="iw hj"> <em class="lq">。</em>T19】</strong></li><li id="8fb7" class="lv lw hi iw b ix me jb mf jf mg jj mh jn mi jr ma mb mc md bi translated"><strong class="iw hj">标签</strong> —指示该字段是必填字段、可选字段还是重复字段。请继续阅读底部，了解有关这些标签<strong class="iw hj"> <em class="lq">的更多信息。</em>T25】</strong></li></ul><p id="6802" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">好了，到目前为止，我们已经看到了文件、消息和字段类型的描述符。但是我们还没有看到一个地方正在创造“人”的阶级。</p><p id="d27b" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">我们知道，当我们实例化一个类时，一个对象就被创建了。类似地，当我们实例化一个<strong class="iw hj"> <em class="lq">元类</em> </strong>时，就创建了一个类。</p><figure class="lh li lj lk fd ij"><div class="bz dy l di"><div class="ll lm l"/></div></figure><p id="1600" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">Google protobuf 提供了一个元类'<strong class="iw hj">GeneratedProtocolMessageType</strong>'，它负责在运行时从协议消息描述符创建类。它还将字段描述符注入到类输出中。这允许我们使用 person_pb2 作为包含 person 类及其属性的模块。</p><p id="7629" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">但是，仍然有一样东西似乎不见了。在名为 descriptor 的文件描述符和消息 descriptor _PERSON 之间还没有映射。</p><figure class="lh li lj lk fd ij"><div class="bz dy l di"><div class="ll lm l"/></div></figure><p id="d0ef" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">这就是这里显示的内容。文件描述符通过其名称与消息描述符进行映射。除此之外，它还显示了注册到 protobuf 中维护的符号数据库的消息。文件描述符和消息描述符都在数据库中注册为符号。</p><p id="a669" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw hj">枚举、嵌套类型和作为字段类型的消息</strong></p><figure class="lh li lj lk fd ij"><div class="bz dy l di"><div class="ll lm l"/></div></figure><p id="c996" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">我们可以有一个预定义值列表的枚举，例如，如果我们希望一个地址是家庭类型或办公室类型，那么我们可以创建一个枚举，将这两种类型都作为它的可能值。枚举必须以 0 值开始，因为如果没有显式提供，它将用作字段的默认值。</p><p id="b17c" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">我们也可以使用嵌套的消息类型，在另一个消息类型中声明一个消息类型。这里，我们在雇员消息类型中添加了地址消息类型。</p><p id="ffaf" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">我们也可以使用一种消息类型作为另一种消息中使用的字段类型。这里，部门使用雇员作为其现场雇员的类型。这允许我们为字段使用自定义数据类型。</p><p id="49c1" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">编译好的 python 文件可以在这里找到<a class="ae lu" href="https://gist.github.com/girija2204/06ab5f9745e6b7b8dca7f7ae2a4b3717" rel="noopener ugc nofollow" target="_blank">。枚举类型和枚举值的描述符是<strong class="iw hj">枚举描述符</strong>和<strong class="iw hj">枚举值描述符</strong>。</a></p><p id="5864" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw hj">默认值</strong></p><p id="a1f3" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">从类初始化实例时，每种消息类型都可以接受默认值。如果没有初始化，那么 protobuf 会自己提供这些默认值。</p><ul class=""><li id="eb11" class="lv lw hi iw b ix iy jb jc jf lx jj ly jn lz jr ma mb mc md bi translated">对于整数，默认值为 0</li><li id="907f" class="lv lw hi iw b ix me jb mf jf mg jj mh jn mi jr ma mb mc md bi translated">对于字符串，默认值为空字符串</li><li id="0f2c" class="lv lw hi iw b ix me jb mf jf mg jj mh jn mi jr ma mb mc md bi translated">对于字节，默认值为空字节</li><li id="a359" class="lv lw hi iw b ix me jb mf jf mg jj mh jn mi jr ma mb mc md bi translated">对于 bool，默认值是 bool</li><li id="2601" class="lv lw hi iw b ix me jb mf jf mg jj mh jn mi jr ma mb mc md bi translated">对于枚举，默认值是值为 0 的值</li><li id="48bd" class="lv lw hi iw b ix me jb mf jf mg jj mh jn mi jr ma mb mc md bi translated">对于消息类型，不设置默认值。</li></ul><p id="220f" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw hj">标签</strong></p><ul class=""><li id="c153" class="lv lw hi iw b ix iy jb jc jf lx jj ly jn lz jr ma mb mc md bi translated">Required 是必须提供的值，如果没有提供，那么序列化没有值的字段将引发异常。</li><li id="d6bd" class="lv lw hi iw b ix me jb mf jf mg jj mh jn mi jr ma mb mc md bi translated">可选是指可以提供或不提供值。如果没有提供，那么将使用默认值。</li><li id="b4d5" class="lv lw hi iw b ix me jb mf jf mg jj mh jn mi jr ma mb mc md bi translated">重复是指字段可以重复任意次。</li></ul><p id="8b32" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">在 proto3 中，Required 不可用，因为默认情况下所有字段都是可选的。这个帖子遵循 proto3 版本，因此没有字段是必需的或可选的。</p><h2 id="e18a" class="js jt hi bd ju jv jw jx jy jz ka kb kc jf kd ke kf jj kg kh ki jn kj kk kl km bi translated"><strong class="ak">扩展 protobufs </strong></h2><p id="b79d" class="pw-post-body-paragraph iu iv hi iw b ix kn iz ja jb ko jd je jf kp jh ji jj kq jl jm jn kr jp jq jr hb bi translated">可能会有这样的情况，我们会在使用一段时间后修改现有的 protobuf。在这种情况下，我们将需要处理一些事情，因为更改需要向后兼容。如果我们想要添加一个新的字段，那么这个字段必须使用一个新的标签。我们不能更新现有字段的标签。由于 proto2 有必填字段，我们不应该在更新时删除必填字段。但是，可以删除可选或重复的字段。按照这些步骤，可以很容易地扩展 protobuf 消息类型。</p><h2 id="5287" class="js jt hi bd ju jv jw jx jy jz ka kb kc jf kd ke kf jj kg kh ki jn kj kk kl km bi translated">何时不使用协议缓冲区</h2><p id="c3b3" class="pw-post-body-paragraph iu iv hi iw b ix kn iz ja jb ko jd je jf kp jh ji jj kq jl jm jn kr jp jq jr hb bi translated">Protobufs 将数据序列化为二进制格式，然后以字节传输，数据看起来非常密集和小。通过网络传输、序列化和反序列化它们会更快。但是，如果底层应用程序是 web 浏览器，并且数据是直接提供给它的，就不打算使用它们。如果需要可读性，就不要使用它们。XML 和 JSON 都是可读的，甚至不需要知道模式，也是可编辑的。编辑 protobuf 序列化数据是不明智的，因为它会妨碍数据的整体结构和意义。</p></div><div class="ab cl mj mk gp ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="hb hc hd he hf"><h2 id="515e" class="js jt hi bd ju jv jw jx jy jz ka kb kc jf kd ke kf jj kg kh ki jn kj kk kl km bi translated">结论</h2><p id="0f73" class="pw-post-body-paragraph iu iv hi iw b ix kn iz ja jb ko jd je jf kp jh ji jj kq jl jm jn kr jp jq jr hb bi translated">所以，这都是关于原蟾蜍的。虽然它看起来很吸引人，但人们需要知道什么时候使用，什么时候不使用。总的来说，如果性能、网络负载或向后兼容性是问题的话，它们是很好的选择。</p><p id="b198" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw hj"> <em class="lq">参考文献</em> </strong></p><ul class=""><li id="77fe" class="lv lw hi iw b ix iy jb jc jf lx jj ly jn lz jr ma mb mc md bi translated">要了解更多关于 ProtoBuf 的信息，请关注<a class="ae lu" href="https://developers.google.com/protocol-buffers" rel="noopener ugc nofollow" target="_blank">谷歌 proto buf 文档</a>。</li></ul></div></div>    
</body>
</html>