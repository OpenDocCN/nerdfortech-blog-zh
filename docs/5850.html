<html>
<head>
<title>Timely optimization, part 2</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">适时优化，第 2 部分</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/timely-optimization-part-2-ce5f3bdf6636?source=collection_archive---------8-----------------------#2021-11-24">https://medium.com/nerd-for-tech/timely-optimization-part-2-ce5f3bdf6636?source=collection_archive---------8-----------------------#2021-11-24</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="f246" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">扰流板:7x 加速，工作两小时</h2></div><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ix"><img src="../Images/d0d099ab4e4eeed8919d1f96853b1fa7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*MFXXAuQeC6e_X5wJ"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">照片由<a class="ae jn" href="https://unsplash.com/@marcojodoin?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Marc-Olivier Jodoin </a>在<a class="ae jn" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="49c3" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">在上一篇文章中，我谈到了切换到一种数据结构，这种数据结构旨在为最常见的访问提供更好的支持。在这种情况下，是一个四叉树，用于使用 XY 坐标中的边界框对二维对象进行索引。</p><p id="713c" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">我们从 O[n]列表搜索到 O[log n]树查找。通过将一些查询工作转移到数据结构遍历中，而不是将一个集合返回给调用者并在那里进行工作，这实现了一个有价值的改进。</p><p id="2434" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">通常情况下，这引发了一种认识，即类似的技术可能会加速“地形”的创建，我们使用“地形”在更实际的环境中指示道路。</p><p id="b10d" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">地形生成的工作原理是递归地对 XY 空间进行细分，并在每一个阶段推导出该区域的最低点，这样我们就可以渲染一直位于道路下方的地形。我花了一些时间思考是否可以将现有的树结构转换成景观，但这不够灵活，因为地形生成会“适应”道路的实际位置。</p><p id="3ebd" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">尽管如此，我们仍会为每个分部发出查询。很像前面的例子，它返回一个点的列表，只为我们计算最低的海拔和聚合边界框；总的来说，这些驱动地形。我们可以将这个计算推入数据结构中，以避免传递回结果集吗？</p><p id="a483" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">是的，我们当然可以，但这是<code class="du kk kl km kn b">fold</code>而不是<code class="du kk kl km kn b">filter</code>。</p><pre class="iy iz ja jb fd ko kn kp kq aw kr bi"><span id="6177" class="ks kt hi kn b fi ku kv l kw kx"><strong class="kn hj">queryWithFold </strong>:<br/>    <strong class="kn hj">SpatialNode contentType units coords<br/>    </strong>-&gt; <strong class="kn hj">BoundingBox2d.BoundingBox2d units coords<br/>    </strong>-&gt; (<strong class="kn hj">SpatialContent contentType units coords </strong>-&gt; <strong class="kn hj">accum </strong>-&gt; <strong class="kn hj">accum</strong>)<br/>    -&gt; <strong class="kn hj">accum<br/>    </strong>-&gt; <strong class="kn hj">accum<br/>queryWithFold </strong>current queryArea folder accumulator =<br/>    case current of<br/>        <strong class="kn hj">Blank </strong>-&gt;<br/>            accumulator<br/><br/>        <strong class="kn hj">SpatialNode </strong>node -&gt;<br/>            let<br/>                <strong class="kn hj">fromThisNode </strong>: <strong class="kn hj">List </strong>(<strong class="kn hj">SpatialContent contentType units coords</strong>)<br/>                <strong class="kn hj">fromThisNode </strong>=<br/>                    node.contents |&gt; List.filter (<em class="ky">.box </em>&gt;&gt; BoundingBox2d.intersects queryArea)<br/>            in<br/>            if node.box |&gt; BoundingBox2d.intersects queryArea then<br/>                List.foldl folder accumulator fromThisNode<br/>                    |&gt; queryWithFold node.nw queryArea folder<br/>                    |&gt; queryWithFold node.ne queryArea folder<br/>                    |&gt; queryWithFold node.se queryArea folder<br/>                    |&gt; queryWithFold node.sw queryArea folder<br/>            else<br/>                accumulator</span></pre><p id="e558" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">我们用调用方提供的<code class="du kk kl km kn b">folder</code>函数扩展了<code class="du kk kl km kn b">query</code>调用，将查询结果“动态”聚合到最终的<code class="du kk kl km kn b">accumulator</code>参数中。</p><p id="1912" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">这是否让我们的调用代码变得很模糊？我想没有。</p><pre class="iy iz ja jb fd ko kn kp kq aw kr bi"><span id="2060" class="ks kt hi kn b fi ku kv l kw kx"><strong class="kn hj">initialFoldState </strong>: <strong class="kn hj">TerrainFoldState<br/>initialFoldState </strong>=<br/>    { minAltitude = Quantity.positiveInfinity<br/>    , resultBox = BoundingBox2d.singleton centre<br/>    , count = 0<br/>    }<br/><br/><strong class="kn hj">queryFoldFunction </strong>:<br/>    <strong class="kn hj">SpatialContent IndexEntry Meters LocalCoords<br/>    </strong>-&gt; <strong class="kn hj">TerrainFoldState<br/>    </strong>-&gt; <strong class="kn hj">TerrainFoldState<br/>queryFoldFunction </strong>entry accum =<br/>    { minAltitude = Quantity.min accum.minAltitude entry.content.elevation<br/>    , resultBox = BoundingBox2d.union accum.resultBox entry.box<br/>    , count = accum.count + 1<br/>    }<br/><br/>{ <strong class="kn hj">minAltitude</strong>, <strong class="kn hj">resultBox</strong>, <strong class="kn hj">count </strong>} =<br/>    SpatialIndex.queryWithFold index myBox queryFoldFunction initialFoldState</span></pre><p id="6379" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">这三件事是什么？首先，一个用于积累结果的小数据结构。其次，做积累的功能；为每个结果调用。第三，对<code class="du kk kl km kn b">queryWithFold</code>的实际调用。我认为这是对工作的一种相当简洁的表达，一种令人愉悦的分工，以及容易获得的结果。几乎不需要任何其他的改变。</p><p id="8442" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">值得吗？早餐后，我花了大约一个小时编写<code class="du kk kl km kn b">queryWithFold</code>函数，晚上，我花了大约一个小时编写调用代码，同时观看烘烤决赛。我的测试用例有 23000 个跟踪点，渲染地形需要大约 7 秒钟。这下降到只有一秒钟左右。</p><p id="2400" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">这就是我喜欢的优化方式。有针对性，及时，有效。</p></div></div>    
</body>
</html>