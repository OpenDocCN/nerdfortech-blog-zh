<html>
<head>
<title>Pythonic Data Model: Overloading dicts or lists</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Pythonic 数据模型:重载字典或列表</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/pythonic-data-model-overloading-dicts-or-lists-e0aa87c75096?source=collection_archive---------10-----------------------#2021-04-14">https://medium.com/nerd-for-tech/pythonic-data-model-overloading-dicts-or-lists-e0aa87c75096?source=collection_archive---------10-----------------------#2021-04-14</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="f998" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Python 和 web 开发的一个常见用例是需要将一堆数据强制放入 Python 字典或列表中，最终通过 JSON、Protobuf、YAML 等在网络上传输。</p><p id="472d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">当然，您可以验证您的数据，并手动将它放入字典中，但是如果我们用我们的验证规则创建一个类，然后将该类配置为直接从“dict”或“list”继承呢？</p><p id="9173" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">例如:</p><figure class="jd je jf jg fd jh"><div class="bz dy l di"><div class="ji jj l"/></div></figure><p id="f93a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">除了看起来有点尴尬，上面的工作还不错。您可以随时追加、更新和弹出条目，它将按预期工作(当然，验证只发生在初始化时)。这个类可以完全像字典一样对待。那么问题出在哪里？让我们看一个稍微复杂一点的例子:</p><figure class="jd je jf jg fd jh"><div class="bz dy l di"><div class="ji jj l"/></div></figure><p id="b131" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我以为你说的是“更复杂”？稍等一下！这个类使用一个字典，并在每个值的前面加上字符串“摄取的:”作为前缀。如果我们希望我们的“摄取”类能够在实例化后处理新记录，该怎么办？很明显，答案是重写“__setitem__ ”:</p><figure class="jd je jf jg fd jh"><div class="bz dy l di"><div class="ji jj l"/></div></figure><p id="3dab" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如上所示，我们再次得到了我们所期望的。很简单。让我们继续，用一个新项目更新我们的字典/类:</p><figure class="jd je jf jg fd jh"><div class="bz dy l di"><div class="ji jj l"/></div></figure><p id="0a7a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">等一下。！这看起来不对…您可能会认为，在幕后，每当调用类似“update”的方法时，Python 仍然会调用“__setitem__ ”,但不幸的是，情况并非如此。重载“__delitem__”时，类似“clear”、“pop”、“del”的方法也会出现同样的问题。类似地，试图扩展一个“列表”也会遇到这种意想不到的问题。当然，您可以扩展底层 dict 类中的每一个方法，但是此时，您几乎没有从零开始构建自己的类。这种不一致的原因很可能是由于 dict 和 list 类最初是如何实现的历史原因。为了向后兼容，这可能不会改变。但是，如果有更好的方法呢？</p><p id="2c00" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">幸运的是，有，这就是本文的关键。请遵守以下代码:</p><figure class="jd je jf jg fd jh"><div class="bz dy l di"><div class="ji jj l"/></div></figure><p id="ea2b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">可以看到，输出正是我们之前想要的。还有一个类似的“UserList”方法，可用于扩展列表类型对象。通过从“UserDict”继承，我们只需要覆盖“__setitem__”来修改在我们的字典中添加/更新内容的行为。要删除内容，我们只需覆盖“__delitem__”。与 dict 不同，所有其他在字典中插入、修改或删除条目的方法最终都会使用这两个方法。此外，代码更加简洁。我们不需要在任何地方导致“super()”调用，因为定义了一个“self.data”字典，它实际上保存了当前存储的值的字典。这使得修改变得容易，并且使得代码清晰易读。</p><p id="0e0f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">最后，让我们来看一下我们的第一个例子，但是使用“UserDict”进行了重写:</p><figure class="jd je jf jg fd jh"><div class="bz dy l di"><div class="ji jj l"/></div></figure><p id="0191" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如你所见，即使在我们不需要重载“__setitem__”或“__delitem__”的这种退化情况下，代码看起来也更好一些。需要注意的是，如果我们要在“__init__”方法中给“self.data”赋值，必须先声明“data”，否则此时它不存在。</p><p id="1d62" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">希望从这篇文章中，您会发现一些对 Python 中的数据建模有用的概念，而不会落入试图直接从“dict”或“list”继承的陷阱。要更深入地了解这个问题以及更多的历史背景，请查看这篇文章，我从这篇文章中获得了很多灵感:<a class="ae jk" href="https://treyhunner.com/2019/04/why-you-shouldnt-inherit-from-list-and-dict-in-python/" rel="noopener ugc nofollow" target="_blank">https://trey hunner . com/2019/04/why-you-should-not-inherit-from-list-and-dict-in-python/</a></p></div></div>    
</body>
</html>