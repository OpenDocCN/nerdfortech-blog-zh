<html>
<head>
<title>What Is Big-O programming?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">什么是Big-O编程？</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/what-is-big-o-programming-b0bfff15aa2c?source=collection_archive---------11-----------------------#2021-04-01">https://medium.com/nerd-for-tech/what-is-big-o-programming-b0bfff15aa2c?source=collection_archive---------11-----------------------#2021-04-01</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><figure class="hh hi ez fb hj hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es hg"><img src="../Images/80726bdce353ac84b0a13a0946f91e71.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FkQzWqqIMlAHZ_xNrEPKeA.png"/></div></div></figure><div class=""/><p id="012e" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">大O编程哇，听起来很可怕吧。好吧，我有好消息告诉你，大O其实很容易理解。简单来说Big-O只是一种谈论算法效率的方式。让我给你举一个大O符号的例子。</p><pre class="jo jp jq jr fd js jt ju jv aw jw bi"><span id="b845" class="jx jy ht jt b fi jz ka l kb kc">let number = 10</span></pre><p id="b72b" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">最重要的是。为什么是<code class="du kd ke kf jt b">O(1)</code>？让我再详细解释一下。<code class="du kd ke kf jt b">O = the number of operations in a given function.</code>因为我们上面的代码只运行一次等于1的操作。很简单对吧。好吧，让我们更进一步。</p><pre class="jo jp jq jr fd js jt ju jv aw jw bi"><span id="2b25" class="jx jy ht jt b fi jz ka l kb kc">const myArray = ["a", "b", "c", "d"]</span><span id="5ebb" class="jx jy ht jt b fi kg ka l kb kc">const findCharacter = (char, array) =&gt; {<br/>    for(let i = 0; i &lt; array.length; i++){<br/>        if(array[i] === char){<br/>            return true<br/>        }<br/>    }<br/>    return false<br/>}</span></pre><p id="e0b0" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">你认为<code class="du kd ke kf jt b">findCharacter</code>的大-O会是什么？这个函数是做什么的？</p><pre class="jo jp jq jr fd js jt ju jv aw jw bi"><span id="390c" class="jx jy ht jt b fi jz ka l kb kc">const myArray = ["a", "b", "c", "d"]//we already know that this will be O(1) because it will only run once.</span><span id="603e" class="jx jy ht jt b fi kg ka l kb kc">//here we say. for each elemant in the array check to see if char exsits, if it does stop running and return true.<br/>//if none of the characters return true then we'll finish the loop and return false.<br/>const findCharacter = (char, array) =&gt; {<br/>    for(let i = 0; i &lt; array.length; i++){ <br/>// the number of operations is equal to the size of the array.<br/>        if(array[i] === char){<br/>            return true<br/>        }<br/>    }<br/>    return false<br/>}</span><span id="60e2" class="jx jy ht jt b fi kg ka l kb kc">myArray.length<br/>//=&gt; 4<br/>//if the size of the array is 4 and that means the total number of operations would depend on the size of our array.</span></pre><p id="5374" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">所以由于<code class="du kd ke kf jt b">n</code>的运算次数取决于数组或数据的大小，我们将<code class="du kd ke kf jt b">O(n)</code>。其中<code class="du kd ke kf jt b">n</code>代表我们的数据。你可以说也是<code class="du kd ke kf jt b">O(4)</code>。因为数组有4个元素，所以操作数也是4。让我们看另一个例子。</p><pre class="jo jp jq jr fd js jt ju jv aw jw bi"><span id="0b5c" class="jx jy ht jt b fi jz ka l kb kc">//compare to arrays<br/>const array1 = ["a", "b", "c", "d",]<br/>const array2 = ["x", "y", "z", "c"]<br/>//we want to check if any of that character in array1 are also in array two.<br/>//I'm justing going to code out the brute force solution first.</span><span id="2522" class="jx jy ht jt b fi kg ka l kb kc">const compareArrays = (arr1, arr2) =&gt; {<br/>    for(let i = 0; i &lt; arr1.length; i++){<br/>        for(let j = 0; j &lt; arr2.length; j++){<br/>            if(arr1[i] === arr2[j]){<br/>                return true<br/>            }<br/>        }<br/>    }<br/>    return false<br/>}</span></pre><p id="3f15" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这有点棘手。如果我们说bot <code class="du kd ke kf jt b">array1</code>和<code class="du kd ke kf jt b">array2</code>将总是具有相同的大小，那么我们将得到<code class="du kd ke kf jt b">O(n^2)</code>。这样做的原因是因为我们的第一个数组<code class="du kd ke kf jt b">n</code>将与我们的第二个数组长度相同。让我再给你讲一遍。</p><pre class="jo jp jq jr fd js jt ju jv aw jw bi"><span id="75d3" class="jx jy ht jt b fi jz ka l kb kc">const compareArrays = (arr1, arr2) =&gt; {<br/> for(let i = 0; i &lt; arr1.length; i++){// the array is length is 4 <br/>   for(let j = 0; j &lt; arr2.length; j++){ //and for every item in array2 which is 4 run the code 4 times.<br/>     if(arr1[i] === arr2[j]){ //4*4 16 and 4^2 is also 16 therfore we get O(n^2)<br/>       return true<br/>      }<br/>    }<br/>  }<br/> return false<br/>}</span></pre><p id="0beb" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">很简单对吧。但是如果数组有不同的长度，那么bigO就是<code class="du kd ke kf jt b">O(n*b)</code>假设数组1的长度是2，数组1的长度是10。然后，如果我们插入这些值，操作的次数是<code class="du kd ke kf jt b">2*10</code>我们循环数组1两次，对于数组1中的每个元素，我们循环数组2十次。操作总数现在是20，这就是为什么我们把它记为<code class="du kd ke kf jt b">O(n*b)</code>，其中<code class="du kd ke kf jt b">n</code>是数组1的数据长度，<code class="du kd ke kf jt b">b</code>是数组2的数据长度。</p><p id="d32c" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">Big-O可能看起来很可怕，但一旦你理解它是什么以及我们为什么使用它，它就真的很简单了。</p></div></div>    
</body>
</html>