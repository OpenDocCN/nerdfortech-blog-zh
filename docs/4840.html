<html>
<head>
<title>Tuning Elasticsearch: Garbage Collection Algorithms</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">调优弹性搜索:垃圾收集算法</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/tuning-elasticsearch-garbage-collection-algorithms-e37b19f7dacd?source=collection_archive---------18-----------------------#2021-08-09">https://medium.com/nerd-for-tech/tuning-elasticsearch-garbage-collection-algorithms-e37b19f7dacd?source=collection_archive---------18-----------------------#2021-08-09</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="9618" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">我们的专家已经着手寻找哪种JVM GC算法最适合Elasticsearch。应该使用G1 GC还是并行GC？所有工作负载的建议都一样吗？</h2></div><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ix"><img src="../Images/d86bd6ee2c2e881a8bbd2d7b5856d8b9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*QydkExvpQX_qDW7V.png"/></div></div></figure><p id="2607" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated"><em class="kf">本文是</em> <a class="ae kg" href="https://blog.bigdataboutique.com/series/tuning%20elasticsearch" rel="noopener ugc nofollow" target="_blank"> <em class="kf">调音弹力搜索</em> </a> <em class="kf">系列的一部分。如果你有兴趣，请订阅我们的</em> <a class="ae kg" href="http://bigdataboutique.hubspotpagebuilder.com/subscribe" rel="noopener ugc nofollow" target="_blank"> <em class="kf">简讯</em> </a> <em class="kf">保持联系。</em></p></div><div class="ab cl kh ki gp kj" role="separator"><span class="kk bw bk kl km kn"/><span class="kk bw bk kl km kn"/><span class="kk bw bk kl km"/></div><div class="hb hc hd he hf"><p id="9448" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">在这一系列文章中，我们将探讨用于调整弹性搜索集群的杠杆和开关，并讨论如何找到最佳值。在本文中，我们将讨论垃圾收集算法，以及使用哪种算法。</p><p id="1c8d" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">在<a class="ae kg" href="https://blog.bigdataboutique.com/2021/07/tuning-elasticsearch-the-ideal-java-heap-size-2toq2j" rel="noopener ugc nofollow" target="_blank">之前的文章</a>中，我们讨论了大小合适的堆大小如何对Elasticsearch的整体查询性能产生巨大影响。</p><p id="55eb" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated"><strong class="jl hj">垃圾收集频率更加细致入微。一方面，较小的堆会导致更频繁的垃圾收集。如果响应单个查询需要Elasticsearch多次运行垃圾收集器，这会严重降低集群的性能。另一方面，更大的堆意味着每次垃圾收集需要更长的时间，这些更长的暂停也会导致性能下降。</strong></p><p id="d12b" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">大小合适的缓存会对整体查询性能以及弹性搜索集群的稳定性产生巨大影响。</p><h1 id="c3dd" class="ko kp hi bd kq kr ks kt ku kv kw kx ky io kz ip la ir lb is lc iu ld iv le lf bi translated">垃圾收集算法</h1><p id="a132" class="pw-post-body-paragraph jj jk hi jl b jm lg ij jo jp lh im jr js li ju jv jw lj jy jz ka lk kc kd ke hb bi translated">多年来，Java已经试验了几种不同的垃圾收集算法，在现代版本中，有两种算法与Elasticsearch相关:并行和垃圾优先(G1)。</p><p id="27cb" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">如果你已经熟悉Java垃圾收集，你可能听说过并发标记和清除(CMS ),但是在Java 14 <a class="ae kg" href="https://openjdk.java.net/jeps/363" rel="noopener ugc nofollow" target="_blank">中它已经被移除</a>,取而代之的是G1垃圾收集。</p><p id="0402" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">有许多很棒的文章详细介绍了这些垃圾收集算法是如何工作的，详细介绍超出了本文的范围。我们今天要看的是为什么你会选择一种算法而不是另一种。最重要的是:您应该对您的实际工作负载进行基准测试，因为这两种方法可以有非常不同的性能特征，而工作负载只有微小的变化。</p><h1 id="d7cc" class="ko kp hi bd kq kr ks kt ku kv kw kx ky io kz ip la ir lb is lc iu ld iv le lf bi translated">我们的基准</h1><p id="ce7c" class="pw-post-body-paragraph jj jk hi jl b jm lg ij jo jp lh im jr js li ju jv jw lj jy jz ka lk kc kd ke hb bi translated">我们已经开始寻找哪种GC最适合Elasticseach。与我们之前所做的类似，我们运行了一个包括一些不同工作负载的基准测试。</p><p id="3326" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">对于这个基准测试，我们将再次使用从带有EBS驱动器的c5.large机器构建的单节点集群。该机器具有2个vCPUs和4 GB内存，并且驱动器是具有5000 IOPS的100 GB io2驱动器。该软件是Elasticsearch 7.8.0，所有配置都设置为默认值，除了堆大小(设置为500 MB)和垃圾收集算法。我们将再次对geonames轨道进行基准测试。</p><p id="b5ff" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">下面是每个挑战执行情况的概述(1.0是并行GC，G1 GC以百分比的形式与其进行比较)。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ll"><img src="../Images/2dc7b89d0eb71a0542a4670d5d908b67.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*sW-RhxGN86tKLpv1.png"/></div></div></figure><p id="2eff" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">正如我们所见，G1 GC通常比并行GC快，最多比并行GC快40%，但在某些情况下会差30%以上。让我们详细研究一下其中的一些案例。</p><p id="523b" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">对于名称中带有sort的所有挑战，挑战选择了索引中的所有文档，并对它们进行了不同的排序。这些结果在不同的GC算法之间差异很大，这突出了在您的特定工作负载上比较这些算法的重要性。特别注意asc _排序_地理名称和asc _排序_地理名称挑战，它们一起代表了最好的改进和几乎最坏的损失，仅仅是通过改变排序的顺序。</p><p id="653b" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">还要注意无痛_*、*_script_score和表达式挑战。这些都使用Elasticsearch script_score对结果进行排名，并且都在G1 GC下表现更好。与decay_gauss_function_score相比，decay _ gauss _ function _ score使用本地gauss函数进行评分，在并行GC下执行速度更快。这当然与在每种类型的操作中在堆上创建的对象数量及其大小有关。每个用例都有自己的行为和模式，所以使用的GC算法应该与集群的行为模式相匹配。</p><p id="fda1" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">Elasticsearch中的一些操作(比如聚合查询)比其他操作(比如脚本查询)需要更少的堆中对象。集群运行的基于堆的操作越多，用不同的GC算法测试哪种性能更好就越重要。</p><h1 id="d92d" class="ko kp hi bd kq kr ks kt ku kv kw kx ky io kz ip la ir lb is lc iu ld iv le lf bi translated">关闭</h1><p id="67c3" class="pw-post-body-paragraph jj jk hi jl b jm lg ij jo jp lh im jr js li ju jv jw lj jy jz ka lk kc kd ke hb bi translated">从我们的基准测试中得出的主要结论是，G1 GC通常是一个不错的选择，但是在某些工作负载中，它的性能实际上比并行GC差。</p><p id="4541" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">像以前一样，这里显示的基准只是为了说明一点。显然，对于任何实际的工作负载，您都将使用更大的机器来存储数据节点。</p><p id="f06f" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">另一件要注意的事情是机器拥有的总内存、使用的堆大小和选择的GC算法之间的紧密关联。改变一个会影响其他的，所以您应该用几个排列来运行基准测试，找出理想的组合。</p><p id="6710" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">我们的团队专门对您的生产工作负载进行详细测量，并为您的环境创建专门定制的基准。我们之前已经做了很多次，对于每个客户，我们都运行了这个基准测试，因为不同的用例、使用模式以及数据形状和大小，我们找到了不同的最佳点。</p><p id="8d10" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">为您的环境运行类似的基准测试，提前支付一点费用，这将为您节省成本，并在以后的道路上解决问题。</p></div><div class="ab cl kh ki gp kj" role="separator"><span class="kk bw bk kl km kn"/><span class="kk bw bk kl km kn"/><span class="kk bw bk kl km"/></div><div class="hb hc hd he hf"><p id="29a0" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated"><em class="kf">原载于2021年8月9日</em><a class="ae kg" href="https://blog.bigdataboutique.com/2021/08/tuning-elasticsearch-garbage-collection-algorithms-1toq2j" rel="noopener ugc nofollow" target="_blank"><em class="kf">【https://blog.bigdataboutique.com】</em></a><em class="kf">。</em></p></div></div>    
</body>
</html>