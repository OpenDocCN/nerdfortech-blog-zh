<html>
<head>
<title>Convert BST to Greater Tree — Day 72(Python)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">将 BST 转换为更大的树-第 72 天(Python)</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/convert-bst-to-greater-tree-day-72-python-1d1e4c7e3364?source=collection_archive---------4-----------------------#2021-02-10">https://medium.com/nerd-for-tech/convert-bst-to-greater-tree-day-72-python-1d1e4c7e3364?source=collection_archive---------4-----------------------#2021-02-10</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/8f88654873ffede674e80bff52c822ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*sOgqnCaAlJ2beA1G"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">照片由<a class="ae iu" href="https://unsplash.com/@toddquackenbush?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">托德·夸肯布什</a>在<a class="ae iu" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄</figcaption></figure><p id="a495" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">今天的问题摘自 leetcode 的每日编码挑战二月版。这个问题不经常被问到，但是这个问题将测试我们对递归的理解。</p></div><div class="ab cl jt ju gp jv" role="separator"><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy"/></div><div class="hb hc hd he hf"><p id="6d3e" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><a class="ae iu" href="https://leetcode.com/problems/convert-bst-to-greater-tree/" rel="noopener ugc nofollow" target="_blank">T9】538</a><strong class="ix hj">。将 BST 转换为更大的树</strong></p><p id="10ce" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">给定一个二叉查找树(BST)的<code class="du ka kb kc kd b">root</code>，将其转换成一个更大的树，使得原始 BST 的每个键都变成原始键加上大于 BST 中原始键的所有键的总和。</p><p id="5d04" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">提醒一下，<em class="ke">二叉查找树</em>是满足这些约束的树:</p><ul class=""><li id="1f15" class="kf kg hi ix b iy iz jc jd jg kh jk ki jo kj js kk kl km kn bi translated">节点的左子树只包含键<strong class="ix hj">小于节点键</strong>的节点。</li><li id="1b2f" class="kf kg hi ix b iy ko jc kp jg kq jk kr jo ks js kk kl km kn bi translated">节点的右边子树只包含键<strong class="ix hj">大于节点键</strong>的节点。</li><li id="6ff4" class="kf kg hi ix b iy ko jc kp jg kq jk kr jo ks js kk kl km kn bi translated">左右子树也必须是二分搜索法树。</li></ul><p id="b4d1" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">注:</strong>此问题同 1038:<a class="ae iu" href="https://leetcode.com/problems/binary-search-tree-to-greater-sum-tree/" rel="noopener ugc nofollow" target="_blank">https://leet code . com/problems/binary-search-tree-to-greater-sum-tree/</a></p><p id="1f3b" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">例 1: </strong></p><figure class="ku kv kw kx fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es kt"><img src="../Images/c87069a49621535ab07892d9e59d94c6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*Psnw9fbCLwaGwWgX.png"/></div></div></figure><pre class="ku kv kw kx fd ky kd kz la aw lb bi"><span id="bfec" class="lc ld hi kd b fi le lf l lg lh"><strong class="kd hj">Input:</strong> root = [4,1,6,0,2,5,7,null,null,null,3,null,null,null,8]<br/><strong class="kd hj">Output:</strong> [30,36,21,36,35,26,15,null,null,null,33,null,null,null,8]</span></pre><p id="b7d0" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">例二:</strong></p><pre class="ku kv kw kx fd ky kd kz la aw lb bi"><span id="8f13" class="lc ld hi kd b fi le lf l lg lh"><strong class="kd hj">Input:</strong> root = [0,null,1]<br/><strong class="kd hj">Output:</strong> [1,null,1]</span></pre><p id="c45e" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">例 3: </strong></p><pre class="ku kv kw kx fd ky kd kz la aw lb bi"><span id="b57d" class="lc ld hi kd b fi le lf l lg lh"><strong class="kd hj">Input:</strong> root = [1,0,2]<br/><strong class="kd hj">Output:</strong> [3,3,2]</span></pre><p id="cec7" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">例 4: </strong></p><pre class="ku kv kw kx fd ky kd kz la aw lb bi"><span id="997e" class="lc ld hi kd b fi le lf l lg lh"><strong class="kd hj">Input:</strong> root = [3,2,4,1]<br/><strong class="kd hj">Output:</strong> [7,9,4,10]</span></pre><p id="567e" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">约束:</strong></p><ul class=""><li id="d552" class="kf kg hi ix b iy iz jc jd jg kh jk ki jo kj js kk kl km kn bi translated">树中的节点数量在范围<code class="du ka kb kc kd b">[0, 104]</code>内。</li><li id="f492" class="kf kg hi ix b iy ko jc kp jg kq jk kr jo ks js kk kl km kn bi translated"><code class="du ka kb kc kd b">-104 &lt;= Node.val &lt;= 104</code></li><li id="72bf" class="kf kg hi ix b iy ko jc kp jg kq jk kr jo ks js kk kl km kn bi translated">树中的所有值都是唯一的。</li><li id="e0ac" class="kf kg hi ix b iy ko jc kp jg kq jk kr jo ks js kk kl km kn bi translated"><code class="du ka kb kc kd b">root</code>保证是有效的二叉查找树。</li></ul></div><div class="ab cl jt ju gp jv" role="separator"><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy"/></div><div class="hb hc hd he hf"><p id="5ab2" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在我们开始之前，让我们了解什么是更大的树。更大树中的节点将具有该节点的当前值和所有节点的当前值之和，该值大于当前节点的值。</p><figure class="ku kv kw kx fd ij er es paragraph-image"><div class="er es li"><img src="../Images/82688dd59f38fbf70cd9ee8f7b4b9d1f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1188/format:webp/1*hrPsItHO1BGNWyrMeftFFQ.png"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">大树</figcaption></figure><p id="6d55" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">让我们来解决这个问题。</p><p id="3dd0" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们得到了一个二叉查找树。在二叉查找树中，当前节点左侧的所有节点的值都小于当前节点的值。当前节点右侧的所有节点的值都将大于当前节点。这意味着最左边的节点权重最小，而最右边的节点权重最大。</p><p id="5947" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们如何利用这些知识来解决这个问题？</p><p id="3a36" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们可以使用 reverse inorder 遍历来到达树中最右边的节点，然后有一个变量可以保存添加的节点，直到当前点。这听起来是不是很混乱？</p><p id="7a87" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">让我们举一个例子。</p><figure class="ku kv kw kx fd ij er es paragraph-image"><div class="er es lj"><img src="../Images/ca94c77116673a182f0200fb3f196c23.png" data-original-src="https://miro.medium.com/v2/resize:fit:1118/format:webp/1*UOj86hjJ4No-W4pCj9tnag.png"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">输入 BST</figcaption></figure><figure class="ku kv kw kx fd ij er es paragraph-image"><div class="er es lk"><img src="../Images/f4e9219150b39636378e19e681497dc5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1102/format:webp/1*KQyUh6aIFvuscqgEy5svzw.png"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">反向有序遍历</figcaption></figure><figure class="ku kv kw kx fd ij er es paragraph-image"><div class="er es ll"><img src="../Images/aec1a357ee9c61d88accc424fcf5cd3a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1050/format:webp/1*toCuw5NjnxiGj6Elqj7QhA.png"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">最右边节点的初始总计</figcaption></figure><figure class="ku kv kw kx fd ij er es paragraph-image"><div class="er es lm"><img src="../Images/80f7d30a7c05c3ba69406a80c0769c23.png" data-original-src="https://miro.medium.com/v2/resize:fit:1048/format:webp/1*06AWROFk7mdWYoKJZ8upDw.png"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">将总计与当前节点的值相加后</figcaption></figure><figure class="ku kv kw kx fd ij er es paragraph-image"><div class="er es ln"><img src="../Images/e6fb4f4ace9ce6bc00095870cde72fce.png" data-original-src="https://miro.medium.com/v2/resize:fit:1078/format:webp/1*nQ_DdEVWjLbRyaAliqjSiw.png"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">填充其他节点</figcaption></figure><p id="bbc6" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">让我们来看看代码片段。</p><pre class="ku kv kw kx fd ky kd kz la aw lb bi"><span id="9d25" class="lc ld hi kd b fi le lf l lg lh">class BSTToGSTConverter:<br/>    def convertBST(self, root: TreeNode) -&gt; TreeNode:<br/>        self.addition = 0<br/>        def convert(node):<br/>            if node != None:<br/>                convert(node.right)<br/>                self.addition += node.val<br/>                node.val = self.addition<br/>                convert(node.left)<br/>            return node<br/>        return convert(root)</span></pre><p id="a51b" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">复杂性分析。</strong></p><p id="f498" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">时间复杂度</strong></p><p id="6581" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们正在访问树中的每个节点。因此，时间复杂度是 O(N)，其中 N 是节点的数量。</p><p id="9007" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">空间复杂性。</strong></p><p id="e3db" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们为每个节点递归调用函数，递归函数在内部使用堆栈。因此，空间复杂度是 O(N)，其中 N 是节点的数量。</p></div></div>    
</body>
</html>