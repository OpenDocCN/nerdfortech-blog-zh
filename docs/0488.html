<html>
<head>
<title>Analysis of ChEMBL COVID-19 Dataset using basic ML Techniques</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用基本ML技术分析ChEMBL新冠肺炎数据集</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/analysis-of-chembl-covid-19-dataset-using-basic-ml-techniques-c89a6b79088a?source=collection_archive---------0-----------------------#2020-12-30">https://medium.com/nerd-for-tech/analysis-of-chembl-covid-19-dataset-using-basic-ml-techniques-c89a6b79088a?source=collection_archive---------0-----------------------#2020-12-30</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="7356" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">本文旨在用python语言建立传统的机器学习模型，如随机森林和线性回归，以从ChEMBL数据集预测分子的生物活性值。</p><h1 id="a872" class="jd je hi bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated"><strong class="ak">你将学到什么</strong></h1><ul class=""><li id="9c6f" class="kb kc hi ih b ii kd im ke iq kf iu kg iy kh jc ki kj kk kl bi translated">如何使用<a class="ae km" href="https://github.com/chembl/chembl_webresource_client" rel="noopener ugc nofollow" target="_blank"> ChEMBL Python API </a>进行数据收集</li><li id="f985" class="kb kc hi ih b ii kn im ko iq kp iu kq iy kr jc ki kj kk kl bi translated">利平斯基描述符的实际应用。</li><li id="b998" class="kb kc hi ih b ii kn im ko iq kp iu kq iy kr jc ki kj kk kl bi translated">使用<em class="ks"> rdkit python库</em></li></ul></div><div class="ab cl kt ku gp kv" role="separator"><span class="kw bw bk kx ky kz"/><span class="kw bw bk kx ky kz"/><span class="kw bw bk kx ky"/></div><div class="hb hc hd he hf"><h1 id="d95c" class="jd je hi bd jf jg la ji jj jk lb jm jn jo lc jq jr js ld ju jv jw le jy jz ka bi translated">安装所需的库</h1><pre class="lf lg lh li fd lj lk ll lm aw ln bi"><span id="b437" class="lo je hi lk b fi lp lq l lr ls">pip install pandas<br/>pip install np<br/>pip install matplotlib<br/>pip install sklearn<br/>pip install chembl_webresource_client<br/>pip install seaborn</span><span id="3229" class="lo je hi lk b fi lt lq l lr ls">##Now in order to install <em class="ks">rkdit</em> use <br/>conda install -c conda-forge rdkit</span></pre><p id="411c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果您遇到任何错误，请访问<a class="ae km" href="http://www.rdkit.org/docs/Install.html#installation" rel="noopener ugc nofollow" target="_blank">此链接。</a></p><p id="d22c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">还有，注意你必须有python 2.7-3.6版本；否则rkdit就不行了。</p><h1 id="ce4f" class="jd je hi bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">导入库</h1><pre class="lf lg lh li fd lj lk ll lm aw ln bi"><span id="9447" class="lo je hi lk b fi lp lq l lr ls"><em class="ks">a and for One-Hot Encoding</em><br/><strong class="lk hj">import</strong> <strong class="lk hj">numpy</strong> <strong class="lk hj">as</strong> <strong class="lk hj">np</strong> <em class="ks"># numpy is used to calculate the mean and standard deviation</em><br/><strong class="lk hj">import</strong> <strong class="lk hj">matplotlib.pyplot</strong> <strong class="lk hj">as</strong> <strong class="lk hj">plt</strong> <em class="ks"># matplotlib is for drawing graphs</em><br/><strong class="lk hj">import</strong> <strong class="lk hj">matplotlib.colors</strong> <strong class="lk hj">as</strong> <strong class="lk hj">colors</strong><br/><strong class="lk hj">from</strong> <strong class="lk hj">sklearn.model_selection</strong> <strong class="lk hj">import</strong> train_test_split <em class="ks"># split  data into training and testing sets</em><br/><strong class="lk hj">from</strong> <strong class="lk hj">sklearn.preprocessing</strong> <strong class="lk hj">import</strong> scale <em class="ks"># scale and center data</em><br/><strong class="lk hj">from</strong> <strong class="lk hj">sklearn.svm</strong> <strong class="lk hj">import</strong> SVC <em class="ks"># this will make a support vector machine for classificaiton</em><br/><strong class="lk hj">from</strong> <strong class="lk hj">sklearn.model_selection</strong> <strong class="lk hj">import</strong> GridSearchCV <em class="ks"># this will do cross validation</em><br/><strong class="lk hj">from</strong> <strong class="lk hj">sklearn.metrics</strong> <strong class="lk hj">import</strong> confusion_matrix <em class="ks"># this creates a confusion matrix</em><br/><strong class="lk hj">from</strong> <strong class="lk hj">sklearn.metrics</strong> <strong class="lk hj">import</strong> plot_confusion_matrix <em class="ks"># draws a confusion matrix</em><br/><strong class="lk hj">from</strong> <strong class="lk hj">sklearn.decomposition</strong> <strong class="lk hj">import</strong> PCA <em class="ks"># to perform PCA to plot the data</em><br/><strong class="lk hj">from</strong> <strong class="lk hj">rdkit</strong> <strong class="lk hj">import</strong> Chem<br/><strong class="lk hj">from</strong> <strong class="lk hj">chembl_webresource_client.new_client</strong> <strong class="lk hj">import</strong> new_client<br/><strong class="lk hj">from</strong> <strong class="lk hj">chembl_webresource_client</strong> <strong class="lk hj">import</strong> *<br/><strong class="lk hj">from</strong> <strong class="lk hj">collections</strong> <strong class="lk hj">import</strong> Counter<br/><strong class="lk hj">from</strong> <strong class="lk hj">operator</strong> <strong class="lk hj">import</strong> itemgetter<br/><strong class="lk hj">from</strong> <strong class="lk hj">chembl_webresource_client.new_client</strong> <strong class="lk hj">import</strong> new_client<br/><strong class="lk hj">from</strong> <strong class="lk hj">rdkit</strong> <strong class="lk hj">import</strong> Chem<br/><strong class="lk hj">from</strong> <strong class="lk hj">rdkit.Chem</strong> <strong class="lk hj">import</strong> Descriptors, Lipinski<br/><strong class="lk hj">import</strong> <strong class="lk hj">seaborn</strong> <strong class="lk hj">as</strong> <strong class="lk hj">sns</strong><br/><strong class="lk hj">from</strong> <strong class="lk hj">scipy.stats</strong> <strong class="lk hj">import</strong> skew<br/><strong class="lk hj">import</strong> <strong class="lk hj">pandas_profiling</strong><br/>%matplotlib inline<br/><strong class="lk hj">from</strong> <strong class="lk hj">sklearn.ensemble</strong> <strong class="lk hj">import</strong> RandomForestRegressor<br/><em class="ks"># data visualization</em><br/><strong class="lk hj">import</strong> <strong class="lk hj">seaborn</strong> <strong class="lk hj">as</strong> <strong class="lk hj">sns</strong><br/>%matplotlib inline<br/><strong class="lk hj">from</strong> <strong class="lk hj">matplotlib</strong> <strong class="lk hj">import</strong> pyplot <strong class="lk hj">as</strong> plt<br/><strong class="lk hj">from</strong> <strong class="lk hj">matplotlib</strong> <strong class="lk hj">import</strong> style<br/><br/><em class="ks"># Algorithms</em><br/><strong class="lk hj">from</strong> <strong class="lk hj">sklearn</strong> <strong class="lk hj">import</strong> linear_model<br/><strong class="lk hj">from</strong> <strong class="lk hj">sklearn.linear_model</strong> <strong class="lk hj">import</strong> LogisticRegression<br/><strong class="lk hj">from</strong> <strong class="lk hj">sklearn.ensemble</strong> <strong class="lk hj">import</strong> RandomForestClassifier<br/><strong class="lk hj">from</strong> <strong class="lk hj">sklearn.linear_model</strong> <strong class="lk hj">import</strong> Perceptron<br/><strong class="lk hj">from</strong> <strong class="lk hj">sklearn.linear_model</strong> <strong class="lk hj">import</strong> SGDClassifier<br/><strong class="lk hj">from</strong> <strong class="lk hj">sklearn.tree</strong> <strong class="lk hj">import</strong> DecisionTreeClassifier<br/><strong class="lk hj">from</strong> <strong class="lk hj">sklearn.neighbors</strong> <strong class="lk hj">import</strong> KNeighborsClassifier<br/><strong class="lk hj">from</strong> <strong class="lk hj">sklearn.svm</strong> <strong class="lk hj">import</strong> SVC, LinearSVC<br/><strong class="lk hj">from</strong> <strong class="lk hj">sklearn.naive_bayes</strong> <strong class="lk hj">import</strong> GaussianNB</span></pre><h1 id="bb92" class="jd je hi bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">数据收集</h1><p id="dbee" class="pw-post-body-paragraph if ig hi ih b ii kd ik il im ke io ip iq lu is it iu lv iw ix iy lw ja jb jc hb bi translated">在本节中，我已经解释了如何使用ChEMBL API从ChEMBL数据库中为您的模型收集相关数据，即<em class="ks">chem bl _ web resource _ client</em></p><p id="0fbb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">首先，您必须下载一个<a class="ae km" href="https://github.com/AslanDevbrat/Covid-Drug-Discovery/blob/master/covid.csv" rel="noopener ugc nofollow" target="_blank">样本数据集</a>。让我谈谈这个数据集。从<a class="ae km" href="https://www.ebi.ac.uk/chembl/g/#browse/compounds/filter/_metadata.compound_records.src_id%3A52" rel="noopener ugc nofollow" target="_blank"> ChEMBL官网</a>下载。这是一个由6900个与新冠肺炎相关的分子组成的数据集，这些分子具有它们的内在属性，如<em class="ks">“名称”、“同义词”、“类型”、“最大相位”、“RO5违例数”、“可旋转键数”、“CX ApKa”、“CX BpKa”、“结构类型”、“无机标志”、“RO5违例数(Lipinski)”、“分子量(单同位素)”、“分子种类”、“分子式”、“通过Ro3”、“分子量”、“目标”、“生物活性”、“QED加权”、“CX LogP”、“CX LogD”、“芳香环”、“重原子”、“HBA Lipinski”、“HBD Lipinski”</em></p><p id="640b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">不要惊慌</strong>我们只对几列感兴趣，即<em class="ks">“微笑”、“化学标识”、“阿洛普”、“HBD”、“HBA”、“PSA”、“分子量”… </em></p><p id="b3bc" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">您可以使用以下代码处理数据集；它将<em class="ks">微笑</em>转化为他们的结构性表征。这部分是可选的。</p><pre class="lf lg lh li fd lj lk ll lm aw ln bi"><span id="c4c4" class="lo je hi lk b fi lp lq l lr ls">df = pd.read_csv('covid\covid.csv',sep=';')<br/><br/>m =Chem.MolFromSmiles(df['Smiles'][1])<br/>m</span></pre><figure class="lf lg lh li fd ly er es paragraph-image"><div role="button" tabindex="0" class="lz ma di mb bf mc"><div class="er es lx"><img src="../Images/be31db4e6782358db3e6bb0b75bddaac.png" data-original-src="https://miro.medium.com/v2/resize:fit:816/format:webp/1*dSchi4lofdxPElA6jJq_kA.png"/></div></div><figcaption class="mf mg et er es mh mi bd b be z dx translated">图一</figcaption></figure><pre class="lf lg lh li fd lj lk ll lm aw ln bi"><span id="b7b9" class="lo je hi lk b fi lp lq l lr ls">m =Chem.MolFromSmiles(df['Smiles'][2098])<br/>m</span></pre><figure class="lf lg lh li fd ly er es paragraph-image"><div class="er es mj"><img src="../Images/29a5f2243aeee3a18d41b3232e310cf4.png" data-original-src="https://miro.medium.com/v2/resize:fit:582/format:webp/1*aVrc7MT9C7zy2FIBQCGlng.png"/></div><figcaption class="mf mg et er es mh mi bd b be z dx translated">图2</figcaption></figure><pre class="lf lg lh li fd lj lk ll lm aw ln bi"><span id="7d44" class="lo je hi lk b fi lp lq l lr ls">m =Chem.MolFromSmiles(df['Smiles'][34])<br/>m</span></pre><figure class="lf lg lh li fd ly er es paragraph-image"><div class="er es mk"><img src="../Images/3e3e52e7a75e77d6e9afe2a5c90b5d5c.png" data-original-src="https://miro.medium.com/v2/resize:fit:702/format:webp/1*W3n443J9P3ykfc_XpQiUYg.png"/></div><figcaption class="mf mg et er es mh mi bd b be z dx translated">图3</figcaption></figure><pre class="lf lg lh li fd lj lk ll lm aw ln bi"><span id="afd6" class="lo je hi lk b fi lp lq l lr ls">m =Chem.MolFromSmiles(df['Smiles'][61]) <br/>m</span></pre><figure class="lf lg lh li fd ly er es paragraph-image"><div class="er es ml"><img src="../Images/eba23757d3075e801b8633601be237ad.png" data-original-src="https://miro.medium.com/v2/resize:fit:422/format:webp/1*TerlhTPJT9HzZvJFpicjQg.png"/></div><figcaption class="mf mg et er es mh mi bd b be z dx translated">图4</figcaption></figure><pre class="lf lg lh li fd lj lk ll lm aw ln bi"><span id="9761" class="lo je hi lk b fi lp lq l lr ls">m =Chem.MolFromSmiles(df['Smiles'][60])<br/>m</span></pre><figure class="lf lg lh li fd ly er es paragraph-image"><div class="er es mm"><img src="../Images/c4ff1730cce3e198092fc7c2b11e3bff.png" data-original-src="https://miro.medium.com/v2/resize:fit:964/format:webp/1*dDKwDWdoenIBcx8sZA65bA.png"/></div><figcaption class="mf mg et er es mh mi bd b be z dx translated">图5</figcaption></figure><p id="4ad0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们的目标变量是'<strong class="ih hj">生物活性</strong>，'在数据集中有一列，但它实际上不是实际的生物活性值。相反，它只是一个分子具有的生物活性数量的频率。所以这里棘手的部分是<strong class="ih hj">如何获得正确的生物活性值？</strong></p><p id="0527" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">生物活性有几种类型，但我们感兴趣的是标准类型"<strong class="ih hj"> ic50" </strong>和标准单位"<strong class="ih hj"> nM。</strong>”</p><p id="9b53" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="ks">以下函数使用chembl的API检索具有所需标准类型和标准单位的分子的生物活性。这里为了简单起见，我将standard_units的值硬编码为‘nM’。<br/>这个函数从互联网上取值需要相当长的时间。</em></p><pre class="lf lg lh li fd lj lk ll lm aw ln bi"><span id="9630" class="lo je hi lk b fi lp lq l lr ls"><em class="ks">Argument:</em><br/><em class="ks">        chembl_id : chemble id of the molecule</em><br/><em class="ks">        standard_type : IC50, ec50 etc</em><br/><em class="ks">        </em><br/><em class="ks">    return: </em><br/><em class="ks">        A (chembl_id, Bioactivity of the molecule)-tuple</em><br/><em class="ks">"""</em><br/><strong class="lk hj">def</strong> get_standard_value(chembl_id, standard_type):<br/>    records = new_client.activity.filter(molecule_chembl_id=chembl_id).filter(standard_units='nM').filter(standard_type=standard_type)<br/>    df = pd.DataFrame.from_dict(records)<br/>    <strong class="lk hj">if</strong> len(df)&gt;0:<br/>        <strong class="lk hj">return</strong> (chembl_id,df['standard_value'][0])</span></pre><p id="c5e7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">上面声明的函数是从下面的代码调用的。这里我们在数据帧的包含chembl ids的列上有一个循环。为每个id调用上面的函数，上面的函数检查对于那个chembl_id是否存在所要求的值。如果是，则返回chembl_id和生物活性值的元组。</p><pre class="lf lg lh li fd lj lk ll lm aw ln bi"><span id="7d3a" class="lo je hi lk b fi lp lq l lr ls">x_list = list()<br/>i=1<br/><strong class="lk hj">for</strong> chem_id <strong class="lk hj">in</strong> df['ChEMBL ID']:<br/>    f=get_standard_value(chem_id,'IC50')<br/>    <strong class="lk hj">if</strong> f!= <strong class="lk hj">None</strong>:<br/>        x_list.append(f)<br/>        print(x_list[-1])<br/>        print(f"<strong class="lk hj">{</strong>i<strong class="lk hj">}</strong>/<strong class="lk hj">{</strong>len(df['ChEMBL ID'])<strong class="lk hj">}</strong>")<br/>    i+=1<br/>    print('----------------')</span></pre><p id="6dcb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在上面的循环中，我们需要一些时间，所以我已经把我的<a class="ae km" href="https://github.com/AslanDevbrat/Covid-Drug-Discovery/blob/master/bioactivity.csv" rel="noopener ugc nofollow" target="_blank">文件保存在</a>这里了。</p><p id="695a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在我们必须检查刚刚取出的化合物，它们和<strong class="ih hj">是否激活</strong>。最简单的方法是检查我们之前获取的标准值是否小于1000。如果超过1000，那么分子对我们就没用了。</p><pre class="lf lg lh li fd lj lk ll lm aw ln bi"><span id="e4ff" class="lo je hi lk b fi lp lq l lr ls">i=0<br/><strong class="lk hj">for</strong> num <strong class="lk hj">in</strong> sd['standard_value']:<br/>    <strong class="lk hj">if</strong> num&lt;=1000:<br/>        i+=1<br/>print(f"Number of the active class is <strong class="lk hj">{</strong>i<strong class="lk hj">}</strong>")</span><span id="84cd" class="lo je hi lk b fi lt lq l lr ls">&gt;&gt;&gt;Number of the active class is 502</span></pre><h1 id="dd30" class="jd je hi bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">特征选择</h1><p id="4922" class="pw-post-body-paragraph if ig hi ih b ii kd ik il im ke io ip iq lu is it iu lv iw ix iy lw ja jb jc hb bi translated">包含CHembl ID、Alogp、HBD、HBA、Smiles的列是我们感兴趣的列。因此，我们将删除所有其他列。</p><pre class="lf lg lh li fd lj lk ll lm aw ln bi"><span id="b995" class="lo je hi lk b fi lp lq l lr ls">new_df = df.drop(['Name','Synonyms','Type','Max Phase','#RO5 Violations','#Rotatable Bonds','CX ApKa','CX BpKa','Structure Type','Inorganic Flag','#RO5 Violations (Lipinski)','Molecular Weight (Monoisotopic)','Molecular Species','Molecular Formula','Passes Ro3','Molecular Weight','Targets','Bioactivities','QED Weighted','CX LogP','CX LogD','Aromatic Rings','Heavy Atoms','HBA Lipinski','HBD Lipinski'],axis=1).copy()<br/>new_df.head()</span></pre><p id="3bfc" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">以下是生成的数据帧:</p><figure class="lf lg lh li fd ly er es paragraph-image"><div role="button" tabindex="0" class="lz ma di mb bf mc"><div class="er es mn"><img src="../Images/fa274c57f1e2451413f93651dcacc193.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NQegpjQVjPVZf2UG5GJW3w.png"/></div></div></figure><p id="65a6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在ChEMBL ID列上合并以下两个CSV文件:</p><ul class=""><li id="0869" class="kb kc hi ih b ii ij im in iq mo iu mp iy mq jc ki kj kk kl bi translated">covid.csv</li><li id="d95b" class="kb kc hi ih b ii kn im ko iq kp iu kq iy kr jc ki kj kk kl bi translated">生物活性. csv</li></ul><figure class="lf lg lh li fd ly er es paragraph-image"><div role="button" tabindex="0" class="lz ma di mb bf mc"><div class="er es mn"><img src="../Images/fa274c57f1e2451413f93651dcacc193.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NQegpjQVjPVZf2UG5GJW3w.png"/></div></div><figcaption class="mf mg et er es mh mi bd b be z dx translated">最终_df</figcaption></figure><h1 id="c787" class="jd je hi bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">数据预处理</h1><p id="53f4" class="pw-post-body-paragraph if ig hi ih b ii kd ik il im ke io ip iq lu is it iu lv iw ix iy lw ja jb jc hb bi translated">这样做的目的是删除任何列包含“none”、“Nan”或“None”的行</p><h2 id="9f60" class="lo je hi bd jf mr ms mt jj mu mv mw jn iq mx my jr iu mz na jv iy nb nc jz nd bi translated">检查final_df中的None值</h2><p id="6bef" class="pw-post-body-paragraph if ig hi ih b ii kd ik il im ke io ip iq lu is it iu lv iw ix iy lw ja jb jc hb bi translated">从HBD列中删除none、Nan、None值</p><pre class="lf lg lh li fd lj lk ll lm aw ln bi"><span id="bcbd" class="lo je hi lk b fi lp lq l lr ls">print('Unique value in HBD column',final_df['HBD'].unique())</span><span id="33f7" class="lo je hi lk b fi lt lq l lr ls">&gt;&gt;&gt;Unique value in HBD column ['2' '0' '1' '5' '3' '4' '12' 'None' '9' '6' nan '7' '8' '10' '11']</span><span id="926c" class="lo je hi lk b fi lt lq l lr ls">final_df = final_df.replace(['None','NONE','none'],np.nan)<br/>final_df = final_df.dropna()<br/>print('Unique value in HBD column',final_df['HBD'].unique())<br/>len(final_df)</span><span id="92d0" class="lo je hi lk b fi lt lq l lr ls">&gt;&gt;&gt;Unique value in HBD column ['2' '0' '1' '5' '3' '4' '12' '9' '6' '7' '8' '10' '11']<br/>&gt;&gt;&gt;989</span></pre><p id="f59d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在让我们检查一下<em class="ks"> Alog </em>列是否没有none、Nan或None值。</p><pre class="lf lg lh li fd lj lk ll lm aw ln bi"><span id="7359" class="lo je hi lk b fi lp lq l lr ls">print('Unique value in AlogP column',final_df['AlogP'].unique())</span></pre><p id="8f5a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">幸运的是，AlogP没有空值，所以不需要删除行。</p><p id="0ed1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">删除PSA列中包含none、Nan、None值的行</p><pre class="lf lg lh li fd lj lk ll lm aw ln bi"><span id="30da" class="lo je hi lk b fi lp lq l lr ls">print('Unique value in PSA column',final_df['PSA'].unique())</span></pre><p id="c965" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">PSA没有空值，因此不需要删除该行。</p><h1 id="ca1d" class="jd je hi bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">计算Lipinski描述符</h1><p id="6707" class="pw-post-body-paragraph if ig hi ih b ii kd ik il im ke io ip iq lu is it iu lv iw ix iy lw ja jb jc hb bi translated">辉瑞公司的科学家Christopher Lipinski提出了一套评估化合物药物相似性的经验法则。这种药物相似性是基于吸收、分布、代谢和排泄(ADME)，也称为药代动力学特征。Lipinski分析了所有FDA批准的口服活性药物，以制定所谓的<strong class="ih hj">五法则</strong>或<strong class="ih hj"> Lipinski法则</strong>。</p><p id="7c8b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">利平斯基的规则陈述如下:</p><ul class=""><li id="ecda" class="kb kc hi ih b ii ij im in iq mo iu mp iy mq jc ki kj kk kl bi translated">分子量&lt; 500道尔顿</li><li id="daf2" class="kb kc hi ih b ii kn im ko iq kp iu kq iy kr jc ki kj kk kl bi translated">辛醇-水分配系数(LogP) &lt; 5</li><li id="b379" class="kb kc hi ih b ii kn im ko iq kp iu kq iy kr jc ki kj kk kl bi translated">氢键给体&lt; 5</li><li id="3276" class="kb kc hi ih b ii kn im ko iq kp iu kq iy kr jc ki kj kk kl bi translated">氢键受体&lt; 10</li></ul><h1 id="2c71" class="jd je hi bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">用李平斯基法则计算分子量</h1><p id="381f" class="pw-post-body-paragraph if ig hi ih b ii kd ik il im ke io ip iq lu is it iu lv iw ix iy lw ja jb jc hb bi translated">我们将使用利普斯基法则，只得到那些活性化合物的分子量，这意味着它们有摩尔。重量&lt; 500道尔顿</p><pre class="lf lg lh li fd lj lk ll lm aw ln bi"><span id="05e1" class="lo je hi lk b fi lp lq l lr ls"># Inspired by: <a class="ae km" href="https://codeocean.com/explore/capsules?query=tag:data-curation" rel="noopener ugc nofollow" target="_blank">https://codeocean.com/explore/capsules?query=tag:data-curation</a></span><span id="1d68" class="lo je hi lk b fi lt lq l lr ls">def lipinski(smiles, verbose=False):</span><span id="c36a" class="lo je hi lk b fi lt lq l lr ls">moldata= []<br/>    for elem in smiles:<br/>        mol=Chem.MolFromSmiles(elem) <br/>        moldata.append(mol)<br/>       <br/>    baseData= np.arange(1,1)<br/>    i=0  <br/>    for mol in moldata:        <br/>       <br/>        desc_MolWt = Descriptors.MolWt(mol)<br/>        #desc_MolLogP = Descriptors.MolLogP(mol)<br/>        #desc_NumHDonors = Lipinski.NumHDonors(mol)<br/>        #desc_NumHAcceptors = Lipinski.NumHAcceptors(mol)<br/>           <br/>        row = np.array([desc_MolWt,<br/>                      ])   <br/>    <br/>        if(i==0):<br/>            baseData=row<br/>        else:<br/>            baseData=np.vstack([baseData, row])<br/>        i=i+1      <br/>    <br/>    columnNames=["MW"]   <br/>    descriptors = pd.DataFrame(data=baseData,columns=columnNames)<br/>    <br/>    return descriptors</span><span id="3d74" class="lo je hi lk b fi lt lq l lr ls">df_lipinski = lipinski(final_df.Smiles)<br/>df_lipinski.head()</span></pre><figure class="lf lg lh li fd ly er es paragraph-image"><div class="er es ne"><img src="../Images/ca791fc3a25e30db06978d48149cdd48.png" data-original-src="https://miro.medium.com/v2/resize:fit:304/format:webp/1*ULbj3KC1eBD9naotTGr51g.png"/></div><figcaption class="mf mg et er es mh mi bd b be z dx translated">df _利平斯基</figcaption></figure><p id="4537" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">合并mol。根据我们之前的数据进行加权</p><pre class="lf lg lh li fd lj lk ll lm aw ln bi"><span id="f1de" class="lo je hi lk b fi lp lq l lr ls">final_df_combined = pd.concat([final_df, df_lipinski],axis=1)<br/>final_df_combined.head()</span></pre><figure class="lf lg lh li fd ly er es paragraph-image"><div role="button" tabindex="0" class="lz ma di mb bf mc"><div class="er es nf"><img src="../Images/7aef1cf4ae621d71abff72668bba751d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Lq_szzb5hkUc2f8zSpf9gA.png"/></div></div><figcaption class="mf mg et er es mh mi bd b be z dx translated">最终_ df _组合</figcaption></figure><p id="b0f1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">删除包含MW为None，Nan …的行。</p><pre class="lf lg lh li fd lj lk ll lm aw ln bi"><span id="60a4" class="lo je hi lk b fi lp lq l lr ls">final_df_combined = final_df_combined.replace(['None','NONE','none'],np.nan)<br/>final_df_combined = final_df_combined.dropna()<br/>#print('Unique value in MW column',final_df_combined['MW'].unique())<br/>len(final_df_combined)</span><span id="5390" class="lo je hi lk b fi lt lq l lr ls">&gt;&gt;&gt;978</span></pre><h1 id="f7bd" class="jd je hi bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">将IC50转换为pIC50</h1><p id="65f1" class="pw-post-body-paragraph if ig hi ih b ii kd ik il im ke io ip iq lu is it iu lv iw ix iy lw ja jb jc hb bi translated">为了让<strong class="ih hj"> IC50 </strong>数据分布更加均匀，我们将<strong class="ih hj"> IC50 </strong>转换为负对数刻度，这是必不可少的<strong class="ih hj"> -log10(IC50) </strong>。</p><p id="371b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这个自定义函数pIC50()将接受一个数据帧作为输入，并将:</p><ul class=""><li id="71bc" class="kb kc hi ih b ii ij im in iq mo iu mp iy mq jc ki kj kk kl bi translated">从<code class="du ng nh ni lk b">standard_value</code>栏中取出IC50值，通过将该值乘以1099，将其从nM转换为M</li><li id="28bb" class="kb kc hi ih b ii kn im ko iq kp iu kq iy kr jc ki kj kk kl bi translated">取摩尔值并应用-log10</li><li id="fd0e" class="kb kc hi ih b ii kn im ko iq kp iu kq iy kr jc ki kj kk kl bi translated">删除<code class="du ng nh ni lk b">standard_value</code>列并创建一个新的<code class="du ng nh ni lk b">pIC50</code>列</li></ul><pre class="lf lg lh li fd lj lk ll lm aw ln bi"><span id="7451" class="lo je hi lk b fi lp lq l lr ls">import numpy as np</span><span id="9e7c" class="lo je hi lk b fi lt lq l lr ls">def pIC50(input):<br/>    pIC50 = []</span><span id="d328" class="lo je hi lk b fi lt lq l lr ls">for i in input['standard_value_norm']:<br/>        molar = i*(10**-9) # Converts nM to M<br/>        pIC50.append(-np.log10(molar))</span><span id="c591" class="lo je hi lk b fi lt lq l lr ls">input['pIC50'] = pIC50<br/>    x = input.drop('standard_value_norm', 1)<br/>        <br/>    return x</span><span id="e255" class="lo je hi lk b fi lt lq l lr ls">def norm_value(input):<br/>    norm = []</span><span id="8b84" class="lo je hi lk b fi lt lq l lr ls">for i in input['standard_value']:<br/>        if i &gt; 100000000:<br/>          i = 100000000<br/>        norm.append(i)</span><span id="0d5b" class="lo je hi lk b fi lt lq l lr ls">input['standard_value_norm'] = norm<br/>    x = input.drop('standard_value', 1)<br/>        <br/>    return x</span></pre><p id="3489" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们将首先应用norm_value()函数来规范化standard_value列中的值。</p><pre class="lf lg lh li fd lj lk ll lm aw ln bi"><span id="6557" class="lo je hi lk b fi lp lq l lr ls">df_norm = norm_value(final_df_combined)<br/>df_norm</span></pre><figure class="lf lg lh li fd ly er es paragraph-image"><div role="button" tabindex="0" class="lz ma di mb bf mc"><div class="er es nj"><img src="../Images/77abf6c2d57f65154eee81aea718a8da.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2AtN3Up3H9kkCMpHsmYK0g.png"/></div></div><figcaption class="mf mg et er es mh mi bd b be z dx translated">df_norm</figcaption></figure><p id="6890" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">最终确定数据框架</p><pre class="lf lg lh li fd lj lk ll lm aw ln bi"><span id="850d" class="lo je hi lk b fi lp lq l lr ls">df_final = pIC50(df_norm)<br/>df_final</span></pre><figure class="lf lg lh li fd ly er es paragraph-image"><div role="button" tabindex="0" class="lz ma di mb bf mc"><div class="er es nk"><img src="../Images/6ea982864d5bafbeadc274adc2ecf8b2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YwdHh_S0HL3_H_PwsH6RLg.png"/></div></div><figcaption class="mf mg et er es mh mi bd b be z dx translated">df_final</figcaption></figure><p id="472f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">请注意，pIC50列替换了IC50列。</p><h1 id="d969" class="jd je hi bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">数据可视化</h1><p id="d523" class="pw-post-body-paragraph if ig hi ih b ii kd ik il im ke io ip iq lu is it iu lv iw ix iy lw ja jb jc hb bi translated"><strong class="ih hj">特征与生物活性的关系</strong></p><p id="1e4b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">下图显示了ALogP、PSA与pIC50值的关系。</p><p id="0844" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">注意:由于seaborn库中的错误，第一个图是空白的。</strong>你可以在这里查看<a class="ae km" href="https://github.com/mwaskom/seaborn/issues" rel="noopener ugc nofollow" target="_blank">。</a></p><pre class="lf lg lh li fd lj lk ll lm aw ln bi"><span id="db17" class="lo je hi lk b fi lp lq l lr ls">sns.pairplot(df_final, x_vars=['AlogP','AlogP','PSA'], y_vars='pIC50', height=7, aspect=0.7);</span></pre><figure class="lf lg lh li fd ly er es paragraph-image"><div role="button" tabindex="0" class="lz ma di mb bf mc"><div class="er es nl"><img src="../Images/088fb3de419bcef564f5c91b3e7a353e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2xIJCV2Cw79DyI9umwb3vQ.png"/></div></div></figure><p id="63ce" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">下图显示了HBD、HBA、MW与pIC50值的关系。</p><pre class="lf lg lh li fd lj lk ll lm aw ln bi"><span id="bf9b" class="lo je hi lk b fi lp lq l lr ls">ns.pairplot(df_final, x_vars=['AlogP','HBD','HBA','MW'], y_vars='pIC50', height=7, aspect=0.7);</span></pre><figure class="lf lg lh li fd ly er es paragraph-image"><div role="button" tabindex="0" class="lz ma di mb bf mc"><div class="er es nm"><img src="../Images/6a0e013d1981e794499b4df696bd93bd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kK9OQU_AnfN2eH2NSGqpzg.png"/></div></div></figure><h1 id="2306" class="jd je hi bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">生成数据的详细报告</h1><p id="3684" class="pw-post-body-paragraph if ig hi ih b ii kd ik il im ke io ip iq lu is it iu lv iw ix iy lw ja jb jc hb bi translated">下面的单元格包含数据的详细报告，如每个特征、计数、空单元格等之间的关系</p><pre class="lf lg lh li fd lj lk ll lm aw ln bi"><span id="bdf3" class="lo je hi lk b fi lp lq l lr ls">df_final.profile_report(title="Data Report")<br/>profile = pandas_profiling.ProfileReport(df_final) <br/>profile.to_file("Data Report.html")</span></pre><p id="6544" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">上述命令将创建一个包含数据详细分析的HTML文件；你可以从<a class="ae km" href="https://github.com/AslanDevbrat/Covid-Drug-Discovery/blob/master/Data%20Report.html" rel="noopener ugc nofollow" target="_blank">这里</a>下载那个文件。请在进一步移动之前检查一次。下面也是Phik相关性</p><figure class="lf lg lh li fd ly er es paragraph-image"><div class="er es nn"><img src="../Images/6ba3357afafab3d5ef0899e9fc432dcf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1398/format:webp/1*W3CpIvhRefk4IXg4usL4Ag.png"/></div><figcaption class="mf mg et er es mh mi bd b be z dx translated">相互关系</figcaption></figure><p id="f86b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> <em class="ks">形成以上所有图形；很容易看出pIC50和其他特征之间没有明确的线性多项式关系。</em> </strong></p><h1 id="d593" class="jd je hi bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">应用不同的模型</h1><h2 id="3d5f" class="lo je hi bd jf mr ms mt jj mu mv mw jn iq mx my jr iu mz na jv iy nb nc jz nd bi translated">多元线性回归</h2><pre class="lf lg lh li fd lj lk ll lm aw ln bi"><span id="69a7" class="lo je hi lk b fi lp lq l lr ls">from sklearn.linear_model import LinearRegression<br/>feature_cols = ['AlogP','HBA','HBD','MW','PSA']<br/>X = df_final[feature_cols]<br/>y = df_final.pIC50</span><span id="cd01" class="lo je hi lk b fi lt lq l lr ls"># instantiate and fit<br/>lm1 = LinearRegression()<br/>lm1.fit(X, y)</span><span id="52a1" class="lo je hi lk b fi lt lq l lr ls"># print the coefficients<br/>print(lm1.intercept_)<br/>print(lm1.coef_)</span><span id="23ca" class="lo je hi lk b fi lt lq l lr ls"># pair the feature names with the coefficients<br/>list(zip(feature_cols, lm1.coef_))</span></pre><p id="71c8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">以下是输出:</p><figure class="lf lg lh li fd ly er es paragraph-image"><div class="er es no"><img src="../Images/dd0f268908a9dd2e39d02b271da3a3f7.png" data-original-src="https://miro.medium.com/v2/resize:fit:736/format:webp/1*mCPDcq2mG25bh9h7y1SScQ.png"/></div><figcaption class="mf mg et er es mh mi bd b be z dx translated">列表(zip(feature_cols，lm1.coef_))</figcaption></figure><p id="ee9c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">以上结果的意义是</p><p id="33eb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> <em class="ks">生物活性=(0.25 * a logp)+(0.106 * HBA)——(0.105 * HBD)+(0.00052 * MW)+(0.0039 * PSA)</em></strong></p><p id="48af" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">但是这种方法在训练数据集本身上效率不高，这与我们在上面的图表中看到的直觉有些相似。</p><h1 id="3164" class="jd je hi bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">线性回归</h1><pre class="lf lg lh li fd lj lk ll lm aw ln bi"><span id="b0c0" class="lo je hi lk b fi lp lq l lr ls">from sklearn.model_selection import train_test_split<br/>from sklearn.metrics import mean_squared_error</span><span id="ca62" class="lo je hi lk b fi lt lq l lr ls">X_train, X_test, y_train, y_test = train_test_split(X, y, random_state = 1)</span><span id="1355" class="lo je hi lk b fi lt lq l lr ls">lm4 = LinearRegression()<br/>lm4.fit(X_train, y_train)<br/>lm4_preds = lm4.predict(X_test)</span><span id="d8e8" class="lo je hi lk b fi lt lq l lr ls">print("RMSE :", np.sqrt(mean_squared_error(y_test, lm4_preds)))<br/>print("R^2: ", r2_score(y_test, lm4_preds))</span><span id="5d79" class="lo je hi lk b fi lt lq l lr ls">from yellowbrick.regressor import PredictionError, ResidualsPlot<br/>visualizer = PredictionError(lm4)</span><span id="aa70" class="lo je hi lk b fi lt lq l lr ls">visualizer.fit(X_train, y_train)  # Fit the training data to the visualizer<br/>visualizer.score(X_test, y_test)  # Evaluate the model on the test data<br/>visualizer.poof()</span><span id="839d" class="lo je hi lk b fi lt lq l lr ls">visualizer = ResidualsPlot(lm4)<br/>visualizer.fit(X_train, y_train)  <br/>visualizer.score(X_test, y_test) <br/>visualizer.poof()</span></pre><p id="68f8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这一次，我尝试将数据集分为训练数据集和测试数据集，并尝试进行线性拟合。即使在这种方法中，测试数据集上的r2分数是0.12，这证实了线性模型不能适合该数据集。下面是一些与这种方法相关的图表</p><figure class="lf lg lh li fd ly er es paragraph-image"><div class="er es np"><img src="../Images/062f6b1169c82c06fdb582e6cf16ba6f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1170/format:webp/1*FI55u0fIkHBi56PB3JFngg.png"/></div></figure><figure class="lf lg lh li fd ly er es paragraph-image"><div class="er es nq"><img src="../Images/f059c76dc55f96ebc58d741e2d89ee54.png" data-original-src="https://miro.medium.com/v2/resize:fit:1366/format:webp/1*jAWrRLK0tNjf8xIv10Dpug.png"/></div></figure><p id="8c40" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在到了最后一部分</p><h1 id="1cc0" class="jd je hi bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">帕德尔描述符</h1><p id="d81a" class="pw-post-body-paragraph if ig hi ih b ii kd ik il im ke io ip iq lu is it iu lv iw ix iy lw ja jb jc hb bi translated">我已经使用padel.sh和一个zip文件夹计算了PaDEL描述符。要首先获得PaDEL描述符，您必须创建。只包含Smile和CHEMBL_id的smi文件。一旦有了这个文件，就需要在工作目录中有padel.sh和解压后的padel文件夹。然后运行padel.sh终端。一旦完成，这将需要一些时间；您将在工作目录中找到一个“descriptors_output.csv ”;它看起来会像这样。</p><pre class="lf lg lh li fd lj lk ll lm aw ln bi"><span id="35fb" class="lo je hi lk b fi lp lq l lr ls">df_final.to_csv(r'extracted_data.csv', index = False)<br/>df3 = pd.read_csv('extracted_data.csv')<br/>df3.head()</span></pre><p id="78c2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">制作一个以Smiles和Chenmbl_id为两列的molecule.smi文件</p><pre class="lf lg lh li fd lj lk ll lm aw ln bi"><span id="496f" class="lo je hi lk b fi lp lq l lr ls">selection = ['Smiles','ChEMBL ID']<br/>df3_selection = df3[selection]<br/>df3_selection.to_csv('molecule.smi', sep='\t', index=False, header=False)</span><span id="f776" class="lo je hi lk b fi lt lq l lr ls">df3_X = pd.read_csv('descriptors_output.csv')<br/>df3_X.head(-5)<br/>df_final2=pd.merge(df_final, df3_X, on='ChEMBL ID')<br/>df_final2.head()<br/>df3_X = df_final2.drop(columns=['ChEMBL ID','AlogP','PSA','HBD','HBA','Smiles','MW','pIC50'])<br/>df3_X.head()<br/>df3_Y = df_final2['pIC50']<br/>df3_Y</span><span id="c2ab" class="lo je hi lk b fi lt lq l lr ls">dataset3 = pd.concat([df3_X,df3_Y], axis=1)<br/>dataset3.head(-10)</span><span id="5273" class="lo je hi lk b fi lt lq l lr ls">dataset3 = dataset3.dropna()</span><span id="8cfe" class="lo je hi lk b fi lt lq l lr ls">dataset3.head()</span></pre><figure class="lf lg lh li fd ly er es paragraph-image"><div role="button" tabindex="0" class="lz ma di mb bf mc"><div class="er es nr"><img src="../Images/ace6d28b6a678d19c0657ea660e6db74.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bZn_4Fdc0nZnxUfLsCFiNA.png"/></div></div><figcaption class="mf mg et er es mh mi bd b be z dx translated">数据集3</figcaption></figure><p id="89b6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在，我已经使用dataset3应用了<strong class="ih hj"> RandomForestRegressor </strong>，得到了<strong class="ih hj"> 0.62，</strong>的分数，这相当不错。</p><h1 id="af4f" class="jd je hi bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">随机森林回归量</h1><pre class="lf lg lh li fd lj lk ll lm aw ln bi"><span id="af75" class="lo je hi lk b fi lp lq l lr ls">X_train, X_test, Y_train, Y_test = train_test_split(df3_X, df3_Y, test_size=0</span><span id="02df" class="lo je hi lk b fi lt lq l lr ls">i=0<br/>for i in range(10):<br/>    model = RandomForestRegressor(n_estimators=100)<br/>    model.fit(X_train, Y_train)<br/>    r2 = model.score(X_test, Y_test)<br/>    #print(r2)<br/>    i+=1<br/>Y_pred = model.predict(X_test)<br/>print('R2 score of this model is',r2_score(Y_test, Y_pred))</span><span id="6376" class="lo je hi lk b fi lt lq l lr ls">import seaborn as sns<br/>import matplotlib.pyplot as plt</span><span id="6e14" class="lo je hi lk b fi lt lq l lr ls">sns.set(color_codes=True)<br/>sns.set_style("white")</span><span id="5115" class="lo je hi lk b fi lt lq l lr ls">ax = sns.regplot(Y_test, Y_pred, scatter_kws={'alpha':0.4})<br/>ax.set_xlabel('Experimental pIC50', fontsize='large', fontweight='bold')<br/>ax.set_ylabel('Predicted pIC50', fontsize='large', fontweight='bold')<br/>ax.set_xlim(0, 12)<br/>ax.set_ylim(0, 12)<br/>ax.figure.set_size_inches(5, 5)<br/>plt.show</span></pre><figure class="lf lg lh li fd ly er es paragraph-image"><div class="er es ns"><img src="../Images/a074045e87c66f8ca84b4d6395321f7b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1134/format:webp/1*pL25zyk4RPKZms46f9hKOw.png"/></div></figure><h1 id="71a0" class="jd je hi bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">结论</h1><p id="05f1" class="pw-post-body-paragraph if ig hi ih b ii kd ik il im ke io ip iq lu is it iu lv iw ix iy lw ja jb jc hb bi translated">与其他方法相比，随机森林回归器工作良好。但是由于描述符和生物活性之间没有明确的关系，传统的方法不足以高精度地预测生物活性，我们需要比传统的机器学习方法更强大的方法，如我们需要CNN、神经网络或GANs来更准确地预测这些值。</p><p id="37ac" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">你可以从<a class="ae km" href="https://github.com/AslanDevbrat/Covid-Drug-Discovery" rel="noopener ugc nofollow" target="_blank"> Github </a>获得全部代码</p></div></div>    
</body>
</html>