<html>
<head>
<title>LeetCode — Single Number III</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">LeetCode —单个数字 III</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/leetcode-single-number-iii-2ec93f71c71a?source=collection_archive---------7-----------------------#2022-12-25">https://medium.com/nerd-for-tech/leetcode-single-number-iii-2ec93f71c71a?source=collection_archive---------7-----------------------#2022-12-25</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><h1 id="4c01" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">问题陈述</h1><p id="822a" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">给定一个整数数组<em class="kb"> nums </em>，其中恰好两个元素只出现一次，所有其他元素恰好出现两次。找出只出现一次的两个元素。可以任意顺序返回答案。</p><p id="54bf" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated">您必须编写一个算法，该算法以线性运行时复杂性运行，并且只使用恒定的额外空间。</p><p id="0be1" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated">问题陈述摘自:【https://leetcode.com/problems/single-number-iii】T2</p><p id="dbd5" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated"><strong class="jf hj">例一:</strong></p><pre class="ki kj kk kl fd km kn ko bn kp kq bi"><span id="dff3" class="kr ig hi kn b be ks kt l ku kv">Input: nums = [1, 2, 1, 3, 2, 5]<br/>Output: [3, 5]<br/>Explanation:  [5, 3] is also a valid answer.</span></pre><p id="5c08" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated"><strong class="jf hj">例 2: </strong></p><pre class="ki kj kk kl fd km kn ko bn kp kq bi"><span id="881f" class="kr ig hi kn b be ks kt l kw kv">Input: nums = [-1, 0]<br/>Output: [-1, 0]</span></pre><p id="6af5" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated"><strong class="jf hj">例 3: </strong></p><pre class="ki kj kk kl fd km kn ko bn kp kq bi"><span id="ca90" class="kr ig hi kn b be ks kt l kw kv">Input: nums = [0, 1]<br/>Output: [0, 1]</span></pre><p id="0e36" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated"><strong class="jf hj">约束:</strong></p><pre class="ki kj kk kl fd km kn ko bn kp kq bi"><span id="33c7" class="kr ig hi kn b be ks kt l ku kv">- 2 &lt;= nums.length &lt;= 3 * 10^4<br/>- 2^31 &lt;= nums[i] &lt;= 2^31 - 1<br/>- Each integer in nums will appear twice, only two integers will appear once.</span></pre><h1 id="c826" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">说明</h1><h2 id="7689" class="kx ig hi bd ih ky kz la il lb lc ld ip jo le lf it js lg lh ix jw li lj jb lk bi translated">整理</h2><p id="e003" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">我们对数组元素进行排序，并比较相邻的元素。使用上面的方法，我们可以很容易地得到非重复元素。</p><p id="7b7f" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated">上述方法的一个 C++片段如下:</p><pre class="ki kj kk kl fd km kn ko bn kp kq bi"><span id="620a" class="kr ig hi kn b be ks kt l kw kv">sort(nums, nums + n);<br/>vector&lt;int&gt; result;<br/>for (int i = 0; i &lt; n - 1; i = i + 2) {<br/>    if (nums[i] != nums[i + 1]) {<br/>        result.push_back(nums[i]);<br/>        i = i - 1;<br/>    }<br/>}<br/>if (result.size() == 1)<br/>    result.push_back(nums[n - 1]);<br/>return result;</span></pre><p id="be5c" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated">程序的时间复杂度为<strong class="jf hj"> O(nlog(n)) </strong>，空间复杂度为<strong class="jf hj"> O(1) </strong>。</p><h2 id="9716" class="kx ig hi bd ih ky kz la il lb lc ld ip jo le lf it js lg lh ix jw li lj jb lk bi translated">散列表</h2><p id="d52b" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">这个问题可以用 HashMap 在<strong class="jf hj"> O(n) </strong>中解决。我们在数组上运行一个循环，并计算数组中每个元素出现的次数。</p><p id="b2c1" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated">我们迭代散列并打印出只出现过一次的两个数字。</p><p id="ec8f" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated">上述方法的一个 C++片段如下:</p><pre class="ki kj kk kl fd km kn ko bn kp kq bi"><span id="7b11" class="kr ig hi kn b be ks kt l kw kv">int n = nums.size();<br/>vector&lt;int&gt; result;<br/><br/>if(n == 0) {<br/>    return result;<br/>}<br/><br/>map&lt;int, int&gt; m;<br/><br/>for(int i = 0; i &lt; n; i++) {<br/>    m[nums[i]]++;<br/>}<br/><br/>vector&lt;int&gt; result;<br/><br/>for(auto i = m.begin(); i != m.end(); i++) {<br/>    if(i-&gt;second == 1) {<br/>        result.push_back(i-&gt;first);<br/>    }<br/>}<br/><br/>return result;</span></pre><p id="c852" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated">程序的时间复杂度为<strong class="jf hj"> O(n) </strong>，空间复杂度为<strong class="jf hj"> O(n) </strong>。</p><h2 id="7547" class="kx ig hi bd ih ky kz la il lb lc ld ip jo le lf it js lg lh ix jw li lj jb lk bi translated">异或运算符</h2><p id="78be" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">使用异或运算，可以在时间复杂度为<strong class="jf hj"> O(n) </strong>和空间复杂度为<strong class="jf hj"> O(1) </strong>条件下求解该程序。</p><p id="0e4e" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated">设 a 和 b 是在 nums 数组中恰好出现一次的元素。我们首先计算所有数组元素的异或。</p><pre class="ki kj kk kl fd km kn ko bn kp kq bi"><span id="2bb8" class="kr ig hi kn b be ks kt l kw kv">xor = nums[0]^nums[1]^nums[2]....nums[n - 1]</span></pre><p id="8fd4" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated">在上述<em class="kb"> xor </em>变量中设置的所有位将被设置在一个非重复元素 a 或 b 中。</p><p id="0d67" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated">我们取<em class="kb"> xor </em>的任意设置位，并将数组的元素分成两组。一组元素设置了相同的位，而另一组元素没有设置相同的位。</p><p id="e3c3" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated">我们对第一个集合中的所有元素进行 XOR 运算，将返回第一个非重复元素，对另一个集合进行同样的运算，将返回第二个非重复元素。</p><p id="3268" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated">我们先检查一下算法。</p><pre class="ki kj kk kl fd km kn ll lm aw ln bi"><span id="cce4" class="kx ig hi kn b fi lo lp l ku kv">- set xorResult = nums[0]<br/>  a = 0, b = 0, i = 0<br/>  vector&lt;int&gt; result</span><span id="7a5c" class="kx ig hi kn b fi lq lp l ku kv">- loop for i = 1; i &lt; nums.size(); i++<br/>  - xorResult ^= nums[i]</span><span id="de87" class="kx ig hi kn b fi lq lp l ku kv">- set setBitNo = xorResult == INT_MIN ? 0 : xorResult &amp; ~(xorResult - 1)</span><span id="276d" class="kx ig hi kn b fi lq lp l ku kv">- loop for i = 0; i &lt; nums.size(); i+=<br/>  - if nums[i] &amp; setBitNo<br/>    - a ^= nums[i]<br/>  - else<br/>    - b ^= nums[i]</span><span id="e6b7" class="kx ig hi kn b fi lq lp l ku kv">- result.push_back(a)<br/>- result.push_back(b)</span><span id="38ed" class="kx ig hi kn b fi lq lp l ku kv">- return result</span></pre><p id="ebaa" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated">上述方法的时间复杂度为<strong class="jf hj"> O(n) </strong>，空间复杂度为<strong class="jf hj"> O(1) </strong>。</p><p id="003f" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated">让我们在<strong class="jf hj"> C++ </strong>、<strong class="jf hj"> Golang </strong>、<strong class="jf hj"> Javascript </strong>中检查一下我们的算法。</p><h2 id="edb4" class="kx ig hi bd ih ky kz la il lb lc ld ip jo le lf it js lg lh ix jw li lj jb lk bi translated">C++解决方案</h2><pre class="ki kj kk kl fd km kn ko bn kp kq bi"><span id="9d61" class="kr ig hi kn b be ks kt l kw kv">class Solution {<br/>public:<br/>    vector&lt;int&gt; singleNumber(vector&lt;int&gt;&amp; nums) {<br/>        int xorResult = nums[0];<br/>        int a = 0, b = 0, i;<br/>        vector&lt;int&gt; result;<br/><br/>        for(i = 1; i &lt; nums.size(); i++) {<br/>            xorResult ^= nums[i];<br/>        }<br/><br/>        int setBitNo = xorResult == INT_MIN ? 0 : xorResult &amp; ~(xorResult - 1);<br/>        for(i = 0; i &lt; nums.size(); i++) {<br/>            if(nums[i] &amp; setBitNo) {<br/>                a ^= nums[i];<br/>            } else {<br/>                b ^= nums[i];<br/>            }<br/>        }<br/>        result.push_back(a);<br/>        result.push_back(b);<br/>        return result;<br/>    }<br/>};</span></pre><h2 id="83ea" class="kx ig hi bd ih ky kz la il lb lc ld ip jo le lf it js lg lh ix jw li lj jb lk bi translated">戈朗溶液</h2><pre class="ki kj kk kl fd km kn ko bn kp kq bi"><span id="eb6d" class="kr ig hi kn b be ks kt l kw kv">func singleNumber(nums []int) []int {<br/>    xorResult := 0<br/><br/>    for _, num := range nums {<br/>        xorResult = xorResult ^ num<br/>    }<br/>    setBitNo := xorResult &amp; (-xorResult)<br/>    result := make([]int, 2)<br/>    for _, num := range nums {<br/>        if num &amp; setBitNo == 0 {<br/>            result[0] ^= num<br/>        } else {<br/>            result[1] ^= num<br/>        }<br/>    }<br/>    return result<br/>}</span></pre><h2 id="d646" class="kx ig hi bd ih ky kz la il lb lc ld ip jo le lf it js lg lh ix jw li lj jb lk bi translated">Javascript 解决方案</h2><pre class="ki kj kk kl fd km kn ko bn kp kq bi"><span id="eef8" class="kr ig hi kn b be ks kt l kw kv">var singleNumber = function(nums) {<br/>    let xorResult = 0;<br/>    let a = 0, b = 0, i = 0;<br/><br/>    for(i = 0; i &lt; nums.length; i++){<br/>        xorResult ^= nums[i];<br/>    }<br/><br/>    let setBitNo = xorResult &amp; ~(xorResult - 1);<br/><br/>    for(i = 0; i &lt; nums.length; i++) {<br/>        if((nums[i] &amp; setBitNo) === 0)<br/>            a ^= nums[i];<br/>        else<br/>            b ^= nums[i];<br/>    }<br/><br/>    return [a, b];<br/>};</span></pre><p id="5da2" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated">让我们为<strong class="jf hj">示例 1 </strong>预演我们的算法。</p><pre class="ki kj kk kl fd km kn ko bn kp kq bi"><span id="d1e5" class="kr ig hi kn b be ks kt l ku kv">Input: nums = [1, 2, 1, 3, 2, 5]<br/><br/>Step 1: xorResult = nums[0]<br/>                  = 1<br/><br/>Step 2: int a = 0, b = 0, i<br/>        vector&lt;int&gt; result<br/><br/>Step 3: loop for i = 1; i &lt; nums.size(); i++<br/>            xorResult ^= nums[i]<br/>        The xorResult is 6 (0110)<br/><br/>Step 4: setBitNo = xorResult == INT_MIN ? 0 : xorResult &amp; ~(xorResult - 1)<br/>                 = 6 == INT_MIN ? 0 : xorResult &amp; ~(xorResult - 1)<br/>                 = false ? 0 : xorResult &amp; ~(xorResult - 1)<br/>                 = xorResult &amp; ~(xorResult - 1)<br/>                 = 6 &amp; ~(6 - 1)<br/>                 = 6 &amp; ~5<br/>                 = 6 &amp; -6<br/>                 = 2<br/><br/>Step 5: loop for i = 0; i &lt; nums.size()<br/>            0 &lt; 6<br/>            true<br/>            if nums[i] &amp; setBitNo<br/>               nums[0] &amp; 2<br/>               1 &amp; 2<br/>               0001 &amp; 0010<br/>               0<br/>               false<br/>            else<br/>               b ^= nums[i]<br/>                  = b ^ nums[i]<br/>                  = 0 ^ nums[0]<br/>                  = 0 ^ 1<br/>                  = 1<br/>        i++<br/>        i = 1<br/><br/>Step 6: loop i &lt; nums.size()<br/>            1 &lt; 6<br/>            true<br/>            if nums[i] &amp; setBitNo<br/>               nums[1] &amp; 2<br/>               2 &amp; 2<br/>               0010 &amp; 0010<br/>               2<br/>               true<br/>               a ^= nums[i]<br/>                  = a ^ nums[1]<br/>                  = 0 ^ 2<br/>                  = 2<br/>        i++<br/>        i = 2<br/><br/>Step 7: loop i &lt; nums.size()<br/>            2 &lt; 6<br/>            true<br/>            if nums[i] &amp; setBitNo<br/>               nums[2] &amp; 2<br/>               1 &amp; 2<br/>               0001 &amp; 0010<br/>               0<br/>               false<br/>            else<br/>               b ^= nums[i]<br/>                  = b ^ nums[i]<br/>                  = 1 ^ nums[2]<br/>                  = 1 ^ 1<br/>                  = 0<br/>        i++<br/>        i = 3<br/><br/>Step 8: loop i &lt; nums.size()<br/>            3 &lt; 6<br/>            true<br/>            if nums[i] &amp; setBitNo<br/>               nums[3] &amp; 2<br/>               3 &amp; 2<br/>               0011 &amp; 0010<br/>               2<br/>               true<br/>                a ^= nums[i]<br/>                  = a ^ nums[3]<br/>                  = 2 ^ 3<br/>                  = 1<br/>        i++<br/>        i = 4<br/><br/>Step 9: loop i &lt; nums.size()<br/>            4 &lt; 6<br/>            true<br/>            if nums[i] &amp; setBitNo<br/>               nums[4] &amp; 2<br/>               2 &amp; 2<br/>               0010 &amp; 0010<br/>               2<br/>               true<br/>               a ^= nums[i]<br/>                  = a ^ nums[4]<br/>                  = 1 ^ 2<br/>                  = 3<br/>        i++<br/>        i = 5<br/><br/>Step 10: loop i &lt; nums.size()<br/>            5 &lt; 6<br/>            true<br/>            if nums[i] &amp; setBitNo<br/>               nums[5] &amp; 2<br/>               5 &amp; 2<br/>               0101 &amp; 0010<br/>               0<br/>               false<br/>            else<br/>              b ^= nums[i]<br/>                  = b ^ nums[i]<br/>                  = 0 ^ nums[5]<br/>                  = 0 ^ 5<br/>                  = 5<br/>        i++<br/>        i = 6<br/><br/>Step 11: loop i &lt; nums.size()<br/>            6 &lt; 6<br/>            false<br/><br/>Step 12: result.push_back(a)<br/>         result.push_back(3)<br/>         result = [3]<br/><br/>         result.push_back(b)<br/>         result.push_back(5)<br/>         result = [3, 5]<br/><br/>         return result<br/>We return the result as [3, 5].</span></pre></div><div class="ab cl lr ls gp lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="hb hc hd he hf"><p id="8603" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated"><em class="kb">原载于</em><a class="ae kh" href="https://alkeshghorpade.me/post/leetcode-single-number-iii" rel="noopener ugc nofollow" target="_blank"><em class="kb">https://alkeshghorpade . me</em></a><em class="kb">。</em></p></div></div>    
</body>
</html>