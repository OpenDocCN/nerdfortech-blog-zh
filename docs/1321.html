<html>
<head>
<title>Build the Forest in Python Series: Binary Search Tree</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用 Python 建造森林系列:二叉查找树</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/build-the-forest-in-python-series-binary-search-tree-43fdf3ddfd47?source=collection_archive---------25-----------------------#2021-03-13">https://medium.com/nerd-for-tech/build-the-forest-in-python-series-binary-search-tree-43fdf3ddfd47?source=collection_archive---------25-----------------------#2021-03-13</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="9c65" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">构建软件项目是困难的，它还需要广泛的知识，如编写代码、理解算法、设置环境、测试和部署。此外，每种语言都有其实现事物的方式，即使所有的语言都是面向对象的编程语言。养成从各种角度思考软件开发的习惯需要时间。这个项目，Build the Forest Series，试图通过用 Python 的方式用面向对象编程构建一些树数据结构(the Forest)来提供一个学习软件开发和树数据结构的不同视角。</p><p id="2a75" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为什么是树？</p><p id="58e0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">树是解决软件中许多问题的基本数据结构。此外，几乎所有的软件工程师职位面试都会问到与树相关的问题。尽管我们在日常工作中可能不需要从头开始实现树数据结构，但是对树数据结构有一个坚实的理解有助于我们解决许多问题。</p><h1 id="6c08" class="jd je hi bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">假定</h1><p id="5daf" class="pw-post-body-paragraph if ig hi ih b ii kb ik il im kc io ip iq kd is it iu ke iw ix iy kf ja jb jc hb bi translated">该项目假设 Python 3.9 或更新版本，读者对 Python 编程和数据结构有基本的了解。此外，为了简单起见，实现没有考虑多线程，即不是线程安全的。</p><h1 id="eb66" class="jd je hi bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">项目设置</h1><p id="1800" class="pw-post-body-paragraph if ig hi ih b ii kb ik il im kc io ip iq kd is it iu ke iw ix iy kf ja jb jc hb bi translated">该项目有以下基本布局。</p><pre class="kg kh ki kj fd kk kl km kn aw ko bi"><span id="31e6" class="kp je hi kl b fi kq kr l ks kt">forest-python<br/>├── forest<br/>│   ├── __init__.py<br/>│   ├── binary_trees<br/>│   │   ├── __init__.py<br/>│   │   └── binary_search_tree.py<br/>│   └── tree_exceptions.py<br/>└── tests<br/>    ├── __init__.py<br/>    ├── conftest.py<br/>    └── test_binary_search_tree.py</span></pre><p id="8cf2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">(该项目可在<a class="ae ku" href="https://github.com/shunsvineyard/forest-python" rel="noopener ugc nofollow" target="_blank"> forest-python </a>获得)</p><p id="8636" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">与编译语言(如 C++和 Java)不同，Python 没有为我们检查错误的编译器，所以我们需要使用额外的工具。在这个项目中，我们使用以下工具来确保代码的质量。</p><ul class=""><li id="1ee6" class="kv kw hi ih b ii ij im in iq kx iu ky iy kz jc la lb lc ld bi translated"><a class="ae ku" href="https://flake8.pycqa.org/en/latest/index.html" rel="noopener ugc nofollow" target="_blank"> Flake8 </a>是一款在 Python 源代码中寻找 bug 和风格问题的工具。</li><li id="5184" class="kv kw hi ih b ii le im lf iq lg iu lh iy li jc la lb lc ld bi translated"><a class="ae ku" href="http://mypy-lang.org/" rel="noopener ugc nofollow" target="_blank"> Mypy </a>是 Python 程序的静态类型检查器。尽管 Python 是一种动态语言，但类型检查有助于防止潜在的错误和问题。</li><li id="e74b" class="kv kw hi ih b ii le im lf iq lg iu lh iy li jc la lb lc ld bi translated"><a class="ae ku" href="https://pypi.org/project/pydocstyle/" rel="noopener ugc nofollow" target="_blank"> Pydocstyle </a>用于文档样式检查</li><li id="47a7" class="kv kw hi ih b ii le im lf iq lg iu lh iy li jc la lb lc ld bi translated"><a class="ae ku" href="https://black.readthedocs.io/en/stable/" rel="noopener ugc nofollow" target="_blank">黑色</a>用于编码风格检查</li><li id="6155" class="kv kw hi ih b ii le im lf iq lg iu lh iy li jc la lb lc ld bi translated"><a class="ae ku" href="https://docs.pytest.org/en/stable/" rel="noopener ugc nofollow" target="_blank"> pytest </a>用于单元测试</li></ul><p id="6305" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">此外，代码还遵循了<a class="ae ku" href="https://shunsvineyard.info/2019/01/05/my-python-coding-style-and-principles/" rel="noopener ugc nofollow" target="_blank">我的 Python 编码风格和原则</a>。</p><h1 id="2ea5" class="jd je hi bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">什么是二叉查找树？</h1><p id="1c39" class="pw-post-body-paragraph if ig hi ih b ii kb ik il im kc io ip iq kd is it iu ke iw ix iy kf ja jb jc hb bi translated">二叉查找树是一棵二叉树，其关键字总是满足二进制搜索树属性:</p><ul class=""><li id="4dbf" class="kv kw hi ih b ii ij im in iq kx iu ky iy kz jc la lb lc ld bi translated">设 x 是二叉查找树中的一个节点。</li><li id="1404" class="kv kw hi ih b ii le im lf iq lg iu lh iy li jc la lb lc ld bi translated">如果 y 是 x 的左子树中的一个节点，那么 y.key &lt; x.key.</li><li id="d2cd" class="kv kw hi ih b ii le im lf iq lg iu lh iy li jc la lb lc ld bi translated">If y is a node in the right subtree of x, then y.key &gt; x.key。</li></ul><p id="5a6b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">请注意，如果二叉查找树允许重复键，y.key = x.key 是一种特殊情况。为了简单起见，这个项目不允许重复的键，即所有的键必须是唯一的。</p><p id="fa42" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">二叉查找树数据结构支持许多动态操作。最基本的功能是<em class="lj">搜索</em>、<em class="lj">插入</em>、<em class="lj">删除</em>。还可以支持其他辅助操作，包括获取最小键、最大键、节点的前任和继任者。</p><h1 id="f47e" class="jd je hi bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">建造二叉查找树</h1><p id="2a18" class="pw-post-body-paragraph if ig hi ih b ii kb ik il im kc io ip iq kd is it iu ke iw ix iy kf ja jb jc hb bi translated">本节将介绍实现以及实现选择背后的一些想法。</p><h1 id="9326" class="jd je hi bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">结节</h1><p id="0282" class="pw-post-body-paragraph if ig hi ih b ii kb ik il im kc io ip iq kd is it iu ke iw ix iy kf ja jb jc hb bi translated">二叉查找树节点是二叉查找树的组成部分。</p><figure class="kg kh ki kj fd ll er es paragraph-image"><div class="er es lk"><img src="../Images/41fe41a0225a7a483f59fbcc061ab465.png" data-original-src="https://miro.medium.com/v2/resize:fit:564/format:webp/0*oJpvICWSvzhp3hdM.png"/></div></figure><p id="c7d7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">树节点可以出现在上图中，并具有以下属性:</p><ul class=""><li id="f7d8" class="kv kw hi ih b ii ij im in iq kx iu ky iy kz jc la lb lc ld bi translated"><strong class="ih hj">键</strong>是构建二叉查找树的基本字段，必须满足二叉查找树属性，其值必须具有可比性。</li><li id="d7cc" class="kv kw hi ih b ii le im lf iq lg iu lh iy li jc la lb lc ld bi translated"><strong class="ih hj">左侧</strong>属性指向左侧节点，</li><li id="d877" class="kv kw hi ih b ii le im lf iq lg iu lh iy li jc la lb lc ld bi translated"><strong class="ih hj">右</strong>属性指向右节点，</li><li id="586d" class="kv kw hi ih b ii le im lf iq lg iu lh iy li jc la lb lc ld bi translated"><strong class="ih hj">父</strong>属性指向父节点，并且</li><li id="7eb7" class="kv kw hi ih b ii le im lf iq lg iu lh iy li jc la lb lc ld bi translated"><strong class="ih hj">数据</strong>字段用于包含任何数据。</li></ul><p id="5500" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">数据结构的目的是管理数据。尽管许多教科书为了简单起见省略了数据字段，但在现实世界中，如果一个树节点不包含任何数据，那么它就没有什么用处。这就是为什么我们的节点定义有数据字段。</p><p id="b42f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为什么是父母？根据二叉查找树定义，父节点不是必需的，但是它简化了实现，所以我们在进行树操作时不需要跟踪父节点。如果考虑空间使用，可以用没有父字段的树节点来实现二叉查找树。</p><p id="ba77" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">有了上述想法，我们可以用下面的方式定义节点类。</p><pre class="kg kh ki kj fd kk kl km kn aw ko bi"><span id="b9ab" class="kp je hi kl b fi kq kr l ks kt">@dataclasses.dataclass<br/>class Node:<br/>    key: Any<br/>    data: Any<br/>    left: Optional["Node"] = None<br/>    right: Optional["Node"] = None<br/>    parent: Optional["Node"] = None</span></pre><p id="a989" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为什么使用 dataclass？</p><p id="ebf7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Python 在 3.7 版本中引入了<a class="ae ku" href="https://www.python.org/dev/peps/pep-0557/" rel="noopener ugc nofollow" target="_blank"> dataclass </a>，它主要用于只包含数据的类。当一个类被定义为 dataclass 时，dataclass decorator 为我们提供了一些基本的功能，比如<em class="lj"> __init__() </em>和<em class="lj"> __repr__() </em>函数。因此，dataclass 提供了一种方便的方法来定义一个主要用于数据的类，并增加可读性。因为我们的树节点仅用于数据，所以我们将其定义为 dataclass 是有意义的。</p><h1 id="d3b0" class="jd je hi bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">例外</h1><p id="1514" class="pw-post-body-paragraph if ig hi ih b ii kb ik il im kc io ip iq kd is it iu ke iw ix iy kf ja jb jc hb bi translated">在我们的二叉查找树中，有一种情况我们想引发一个异常，当我们试图插入一个键已经存在于树中的节点时就会发生这种情况。Python 提供了几个内置的异常。然而，它们都没有解决复制密钥的情况。因此，我们为此定义了异常。在<em class="lj"> tree_exceptions.py </em>中，我们添加异常。</p><pre class="kg kh ki kj fd kk kl km kn aw ko bi"><span id="c099" class="kp je hi kl b fi kq kr l ks kt">class DuplicateKeyError(Exception):<br/>    def __init__(self, key: str) -&gt; None:<br/>        Exception.__init__(self, f"{key} already exists.")</span></pre><p id="ada4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这个对象清楚地说明了异常的原因，并告诉我们哪个键是重复的。</p><h1 id="21ea" class="jd je hi bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">核心功能</h1><p id="e821" class="pw-post-body-paragraph if ig hi ih b ii kb ik il im kc io ip iq kd is it iu ke iw ix iy kf ja jb jc hb bi translated">就像一棵真正的有根、有枝、有叶的树一样，我们把树当作一个物体。因此，我们将二叉查找树定义为一个类，并用它来声明二叉查找树对象。<em class="lj"> BinarySearchTree </em>类应该具有最少的功能——插入、删除和搜索，这样我们就可以增长、修剪和查找树。</p><pre class="kg kh ki kj fd kk kl km kn aw ko bi"><span id="72a7" class="kp je hi kl b fi kq kr l ks kt">class BinarySearchTree:<br/><br/>    def __init__(self) -&gt; None:<br/>        self.root: Optional[Node] = None<br/><br/>    def search(self, key: Any) -&gt; Optional[Node]:<br/>        …<br/><br/>    def insert(self, key: Any, data: Any) -&gt; None:<br/>        …<br/><br/>    def delete(self, key: Any) -&gt; None:<br/>        …</span></pre><h2 id="b13d" class="kp je hi bd jf lo lp lq jj lr ls lt jn iq lu lv jr iu lw lx jv iy ly lz jz ma bi translated">插入</h2><p id="5c1b" class="pw-post-body-paragraph if ig hi ih b ii kb ik il im kc io ip iq kd is it iu ke iw ix iy kf ja jb jc hb bi translated">为了构建<em class="lj"> BinarySearchTree </em>，我们首先需要在树中插入一个树节点，新节点总是被添加到叶子级别。以下步骤总结了插入算法。</p><pre class="kg kh ki kj fd kk kl km kn aw ko bi"><span id="0edc" class="kp je hi kl b fi kq kr l ks kt">1. Find the proper location (i.e., the new node's parent) to insert the new node by walking through the tree from the root and comparing the new node's key with each node's key along the way.<br/>2. After finding the parent node, update the parent's left (or right depends on the location) to point to the new node.<br/>3. Update the new node's parent attribute to point to the parent node.</span></pre><p id="dcaf" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">下图可视化了插入算法的每一步。</p><figure class="kg kh ki kj fd ll er es paragraph-image"><div class="er es mb"><img src="../Images/414ae8d68e8e52e9b73cbe7b2817e27b.png" data-original-src="https://miro.medium.com/v2/resize:fit:962/0*xbfQRIKr9AsL5_-4.gif"/></div></figure><p id="e5dc" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">该接口将<em class="lj">键</em>和<em class="lj">数据</em>作为参数，并使用它们来构造一个新的树节点。然后，根据二叉搜索树属性找到合适的位置来插入节点。因此，我们以下面的方式实现插入函数。</p><pre class="kg kh ki kj fd kk kl km kn aw ko bi"><span id="08de" class="kp je hi kl b fi kq kr l ks kt">def insert(self, key: Any, data: Any) -&gt; None:<br/>    new_node = Node(key=key, data=data)<br/>    parent: Optional[Node] = None<br/>    current: Optional[Node] = self.root<br/>    while current:<br/>        parent = current<br/>        if new_node.key &lt; current.key:<br/>            current = current.left<br/>        elif new_node.key &gt; current.key:<br/>            current = current.right<br/>        else:<br/>            raise<br/>                tree_exceptions.DuplicateKeyError(key=new_node.key)<br/>    new_node.parent = parent<br/>    # If the tree is empty<br/>    if parent is None:<br/>        self.root = new_node<br/>    elif new_node.key &lt; parent.key:<br/>        parent.left = new_node<br/>    else:<br/>        parent.right = new_node</span></pre><h2 id="c697" class="kp je hi bd jf lo lp lq jj lr ls lt jn iq lu lv jr iu lw lx jv iy ly lz jz ma bi translated">搜索</h2><p id="c38f" class="pw-post-body-paragraph if ig hi ih b ii kb ik il im kc io ip iq kd is it iu ke iw ix iy kf ja jb jc hb bi translated">搜索算法类似于插入。我们通过给定的键寻找节点。</p><pre class="kg kh ki kj fd kk kl km kn aw ko bi"><span id="cf79" class="kp je hi kl b fi kq kr l ks kt">1. Walk through the tree from the root and compare the key with each node's key along the tree walk<br/>2. If a key matches, we found the node. <br/>3. If no key matches after we reach the leaf level, the node does not exist in the tree.</span></pre><p id="c788" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们可以通过下面的图片来形象化搜索步骤。</p><figure class="kg kh ki kj fd ll er es paragraph-image"><div class="er es mb"><img src="../Images/f23dd6f3a90faf569878dfcd9fe75692.png" data-original-src="https://miro.medium.com/v2/resize:fit:962/0*28K59NXZEwJHf_RM.gif"/></div></figure><p id="a77e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">并按如下方式实现搜索方法。</p><pre class="kg kh ki kj fd kk kl km kn aw ko bi"><span id="1319" class="kp je hi kl b fi kq kr l ks kt">def search(self, key: Any) -&gt; Optional[Node]:<br/>    current = self.root<br/><br/>    while current:<br/>        if key &lt; current.key:<br/>            current = current.left<br/>        elif key &gt; current.key:<br/>            current = current.right<br/>        else:<br/>            return current<br/>    return None</span></pre><p id="6a68" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">需要注意的一点是，如果节点不存在，我们返回<em class="lj"> None </em>。检查搜索函数是否返回<em class="lj"> None </em>是客户端的责任，给定的键不在树中是正常的。</p><h2 id="16bc" class="kp je hi bd jf lo lp lq jj lr ls lt jn iq lu lv jr iu lw lx jv iy ly lz jz ma bi translated">删除</h2><p id="2756" class="pw-post-body-paragraph if ig hi ih b ii kb ik il im kc io ip iq kd is it iu ke iw ix iy kf ja jb jc hb bi translated">二叉查找树的删除有三种情况—要删除的节点没有子节点、一个子节点或两个子节点。</p><p id="c1ff" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">删除节点的想法是用要删除的节点替换子树。该技术来自<a class="ae ku" href="https://en.wikipedia.org/wiki/Introduction_to_Algorithms" rel="noopener ugc nofollow" target="_blank">算法简介</a>。在本书中，作者定义了一个<em class="lj">移植</em>方法来在二叉查找树中移动子树。使用<em class="lj">移植</em>方法，我们可以利用该方法实现三种删除情况。因此，本节从移植函数开始，然后是三个删除案例。</p><p id="4eaf" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">移植</strong></p><p id="d3ec" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="lj">移植</em>方法用根在节点<em class="lj">替换 _ 节点</em>的子树替换根在节点<em class="lj">删除 _ 节点</em>的子树。在<em class="lj">替换 _ 节点</em>替换<em class="lj">删除 _ 节点</em>后，<em class="lj">删除 _ 节点</em>的父节点成为<em class="lj">替换 _ 节点</em>的父节点，<em class="lj">删除 _ 节点</em>的父节点最终以<em class="lj">替换 _ 节点</em>为其子节点。由于函数是内部的，我们用前导下划线定义函数，即<em class="lj"> _transplant </em>。</p><pre class="kg kh ki kj fd kk kl km kn aw ko bi"><span id="d573" class="kp je hi kl b fi kq kr l ks kt">def _transplant(self, deleting_node: Node, replacing_node: Optional[Node]) -&gt; None:<br/>    if deleting_node.parent is None:<br/>        self.root = replacing_node<br/>    elif deleting_node == deleting_node.parent.left:<br/>        deleting_node.parent.left = replacing_node<br/>    else:<br/>        deleting_node.parent.right = replacing_node<br/><br/>    if replacing_node:<br/>        replacing_node.parent = deleting_node.parent</span></pre><p id="834d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">案例 1:没有孩子</p><p id="703e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果要删除的节点没有子节点，使用<em class="lj">移植</em>功能将节点替换为<em class="lj">无</em>。</p><figure class="kg kh ki kj fd ll er es paragraph-image"><div role="button" tabindex="0" class="md me di mf bf mg"><div class="er es mc"><img src="../Images/9e24035992f602a23909587746c1619f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*RdT0OJWMM2Z2d4ll.png"/></div></div></figure><p id="4471" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">案例二:只有一个孩子</p><p id="5296" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果要删除的节点只有一个子节点，不管这个子节点是左还是右，使用<em class="lj">移植</em>功能替换子节点。</p><p id="25c4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">留下一个孩子</strong></p><figure class="kg kh ki kj fd ll er es paragraph-image"><div role="button" tabindex="0" class="md me di mf bf mg"><div class="er es mh"><img src="../Images/bd21e104674429ed2e802c1346462b37.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*r3fh5kKalnE5QADd.png"/></div></div></figure><p id="b427" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">一个右孩子</strong></p><figure class="kg kh ki kj fd ll er es paragraph-image"><div role="button" tabindex="0" class="md me di mf bf mg"><div class="er es mh"><img src="../Images/abe0bb07be3d1c64ad80979433bfea9d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*lL0wCnFmYktRJLUs.png"/></div></div></figure><p id="530a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">案例 3:两个孩子</p><p id="28bf" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">要删除的节点有两个子节点的情况可以分解为两个子情况:</p><p id="8090" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">3.a 删除节点的右边子节点也是右边子树中最左边的节点。</p><p id="e3a5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在这种情况下，正确的孩子必须只有一个正确的孩子。否则，它不能是最左边的节点。因此，我们可以将删除节点替换为它的右子节点，如下图所示。</p><figure class="kg kh ki kj fd ll er es paragraph-image"><div class="er es mi"><img src="../Images/83d5d151d55b0f7a4a623815daabe157.png" data-original-src="https://miro.medium.com/v2/resize:fit:900/format:webp/0*e7wFJiix1wQeQKPy.png"/></div></figure><p id="0d8c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">3.b .删除节点的右子节点也有两个子节点。</p><p id="db55" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在这种情况下，我们从右边的子树中找到最左边的节点来替换要删除的节点。注意，当我们从右边的子树中取出最左边的节点时，它也属于删除情况:情况 1:没有子节点或情况 2:只有一个右边的子节点。否则，它不能是最左边的节点。</p><p id="0676" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">因此，我们使用了两次<em class="lj">移植</em>函数:一次是取出最左边的节点，另一次是用原来最左边的节点替换删除的节点。下图演示了这个案例的步骤。</p><figure class="kg kh ki kj fd ll er es paragraph-image"><div class="er es mj"><img src="../Images/aa87968779db2c03e072b4261a6c32fd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1004/format:webp/0*q_MkAwr9xSlnmNHT.png"/></div></figure><p id="6fc7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">以下是删除过程的步骤:</p><pre class="kg kh ki kj fd kk kl km kn aw ko bi"><span id="a805" class="kp je hi kl b fi kq kr l ks kt">1. Find the node to be deleted<br/>2. If the deleting node has no child, replace the node with None<br/>3. If the deleting node has only one child, replace the node with its child<br/>4. If the deleting node has two children,<br/>    a. Find the leftmost node from the right subtree<br/>    b. If the leftmost node is also the direct child of the deleting node, replace the deleting node with the child<br/>    c. If the right child also has two children, do <br/>        1. Take out the leftmost node by doing the same thing as cases: no child or only one right child. <br/>        2. Take the leftmost node as the new root of the right subtree. <br/>        3. Replace the deleting node with the new root of the right subtree</span></pre><p id="853d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">使用该算法，我们可以如下实现删除方法。</p><pre class="kg kh ki kj fd kk kl km kn aw ko bi"><span id="2d95" class="kp je hi kl b fi kq kr l ks kt">def delete(self, key: Any) -&gt; None:<br/>    if self.root and (deleting_node := self.search(key=key)):<br/><br/>        # Case 1: no child or Case 2a: only one right child<br/>        if deleting_node.left is None:<br/>            self._transplant(<br/>                deleting_node=deleting_node, replacing_node=deleting_node.right<br/>            )<br/><br/>        # Case 2b: only one left left child<br/>        elif deleting_node.right is None:<br/>            self._transplant(<br/>                deleting_node=deleting_node, replacing_node=deleting_node.left<br/>            )<br/><br/>        # Case 3: two children<br/>        else:<br/>            replacing_node = BinarySearchTree.get_leftmost(node=deleting_node.right)<br/>            # The leftmost node is not the direct child of the deleting node<br/>            if replacing_node.parent != deleting_node:<br/>                self._transplant(<br/>                    deleting_node=replacing_node,<br/>                    replacing_node=replacing_node.right,<br/>                )<br/>                replacing_node.right = deleting_node.right<br/>                replacing_node.right.parent = replacing_node<br/>            self._transplant(<br/>                deleting_node=deleting_node, replacing_node=replacing_node<br/>            )<br/>            replacing_node.left = deleting_node.left<br/>            replacing_node.left.parent = replacing_node</span></pre><h1 id="340b" class="jd je hi bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">辅助功能</h1><p id="e577" class="pw-post-body-paragraph if ig hi ih b ii kb ik il im kc io ip iq kd is it iu ke iw ix iy kf ja jb jc hb bi translated">除了核心功能，二叉查找树可能还有其他有用的功能，如获取最左边的节点，获取节点的后继节点，以及获取树的高度。这些函数不依赖于特定的树对象。相反，它们可以应用于任何树和任何给定的子树。因此，我们将这些函数定义为独立的函数，而不是<em class="lj"> BinarySearchTree </em>类的方法。</p><p id="2226" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在这个项目中，我们将辅助函数实现为<em class="lj"> BinarySearchTree </em>类的静态方法。</p><p id="8475" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为什么<a class="ae ku" href="https://docs.python.org/3/library/functions.html#staticmethod" rel="noopener ugc nofollow" target="_blank"> @staticmethod </a>？</p><p id="4c1d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">当一个方法被定义为静态方法时，意味着这个方法执行一些与类相关的功能，但是不需要任何类实例来完成这些工作。静态方法定义完美地匹配了执行绑定到<em class="lj"> BinarySearchTree </em>类而不是<em class="lj"> BinarySearchTree </em>对象的操作的辅助函数的情况。</p><p id="4af8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为什么不直接定义一个正则函数呢？</p><p id="cbbf" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">使用静态方法不仅在逻辑上有意义，而且提高了可读性。当客户端(即人类)读取代码时，函数定义告诉客户端该函数绑定到任何类型为<em class="lj"> BinarySearchTree </em>的对象。</p><p id="4e06" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">下一节重点介绍这些辅助功能。</p><h2 id="36ed" class="kp je hi bd jf lo lp lq jj lr ls lt jn iq lu lv jr iu lw lx jv iy ly lz jz ma bi translated">获得高度</h2><p id="dd64" class="pw-post-body-paragraph if ig hi ih b ii kb ik il im kc io ip iq kd is it iu ke iw ix iy kf ja jb jc hb bi translated">树(子树)的高度是从根部到叶子的最大长度。同样，一棵树只有一个节点，它的高度为零。例如，下图显示树的高度为 4，根为 11 和 30 的子树的高度分别为 2 和 1。</p><figure class="kg kh ki kj fd ll er es paragraph-image"><div class="er es mk"><img src="../Images/e1d9f2d4b31bf1d367c6b4cc63f37fa9.png" data-original-src="https://miro.medium.com/v2/resize:fit:882/format:webp/0*jSiaBciQ-92_-6pu.png"/></div></figure><p id="9b74" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">采油树高度是决定二叉查找树作业绩效的关键因素(详见分析部分)。</p><p id="a22b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为了计算树的高度，我们可以为每个孩子的高度递归地增加 1。如果一个节点有两个子节点，我们使用<a class="ae ku" href="https://docs.python.org/3/library/functions.html#max" rel="noopener ugc nofollow" target="_blank"> max </a>函数从子节点中获取较大的高度，并将最大值增加 1。</p><pre class="kg kh ki kj fd kk kl km kn aw ko bi"><span id="f995" class="kp je hi kl b fi kq kr l ks kt">@staticmethod<br/>def get_height(node: Node) -&gt; int:<br/>    if node.left and node.right:<br/>        return max(<br/>            BinarySearchTree.get_height(node=node.left),<br/>            BinarySearchTree.get_height(node=node.right),<br/>        ) + 1<br/><br/>    if node.left:<br/>        return BinarySearchTree.get_height(node=node.left) + 1<br/><br/>    if node.right:<br/>        return BinarySearchTree.get_height(node=node.right) + 1<br/><br/>    # If reach here, it means the node is a leaf node.<br/>    return 0</span></pre><h2 id="4f57" class="kp je hi bd jf lo lp lq jj lr ls lt jn iq lu lv jr iu lw lx jv iy ly lz jz ma bi translated">获取最左边和最右边的节点</h2><p id="d6d2" class="pw-post-body-paragraph if ig hi ih b ii kb ik il im kc io ip iq kd is it iu ke iw ix iy kf ja jb jc hb bi translated">由于二进制搜索树属性，最左边的节点包含给定(子)树中的最小键。类似地，最右边节点的键是给定(sub)中的最大值。找到最左边和最右边很简单——沿着路径走。</p><figure class="kg kh ki kj fd ll er es paragraph-image"><div class="er es mb"><img src="../Images/74268f607c819be7ca5d5e2b95818a71.png" data-original-src="https://miro.medium.com/v2/resize:fit:962/format:webp/0*d6JyONXbBnGBfQmo.png"/></div></figure><p id="117c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">因为我们可以从任何给定的子树(如果不是整个树)中检索最左边或最右边的节点，所以参数是给定(子)树的根。</p><p id="e4c3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">得到最左边的</strong></p><pre class="kg kh ki kj fd kk kl km kn aw ko bi"><span id="ba78" class="kp je hi kl b fi kq kr l ks kt">@staticmethod<br/>def get_leftmost(node: Node) -&gt; Node:<br/>    current_node = node<br/>    while current_node.left:<br/>        current_node = current_node.left<br/>    return current_node</span></pre><p id="05e1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">获取最右边的</strong></p><pre class="kg kh ki kj fd kk kl km kn aw ko bi"><span id="62b1" class="kp je hi kl b fi kq kr l ks kt">@staticmethod<br/>def get_rightmost(node: Node) -&gt; Node:<br/>    current_node = node<br/>    while current_node.right:<br/>        current_node = current_node.right<br/>    return current_node</span></pre><h2 id="98c8" class="kp je hi bd jf lo lp lq jj lr ls lt jn iq lu lv jr iu lw lx jv iy ly lz jz ma bi translated">前任和继任者</h2><p id="0cc9" class="pw-post-body-paragraph if ig hi ih b ii kb ik il im kc io ip iq kd is it iu ke iw ix iy kf ja jb jc hb bi translated">当我们遍历二叉查找树时，节点的<strong class="ih hj">前任</strong>是位于给定节点之前的节点，而<strong class="ih hj">继任</strong>是正好位于给定节点之后的节点。穿越二叉查找树有很多方法。在这个项目中，前置任务和后续任务是按顺序遍历的。有序遍历以排序的方式遍历二叉查找树。因此，该节点的前任节点将是排序顺序中恰好在给定节点之前的节点，而后继节点将是排序顺序中恰好在给定节点之后的节点。因为按序遍历产生排序的结果，所以使用给定节点的按序前导和后继是最有用的。</p><p id="c1b3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">前任</strong></p><p id="0f7c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">查找给定节点的前任有两种情况:</p><ul class=""><li id="b5bd" class="kv kw hi ih b ii ij im in iq kx iu ky iy kz jc la lb lc ld bi translated">如果给定节点的左侧子节点不为空，则左侧子树的最右侧节点是其前任。</li><li id="27d2" class="kv kw hi ih b ii le im lf iq lg iu lh iy li jc la lb lc ld bi translated">如果给定节点(x)的左子节点是空的，那么我们从给定节点(x)向上，直到我们遇到一个节点(y ),它是其父节点(z)的右子节点。父节点(z)是给定节点(x)的前身。</li></ul><p id="b717" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">下图显示了这两种情况。</p><figure class="kg kh ki kj fd ll er es paragraph-image"><div class="er es ml"><img src="../Images/7e03c282f2cecf7aa5d28d34c3727282.png" data-original-src="https://miro.medium.com/v2/resize:fit:1122/format:webp/0*q92DE85nuo2v9Fvt.png"/></div></figure><p id="b3ac" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">案例 1 很简单。对于情况 2，让我们以节点 24 和节点 34 为例。</p><p id="ec4f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在节点 24 的前身的情况下，节点 24 是 x。由于节点 24 (x)没有左子节点，我们从节点 24 (x)向上，我们发现节点 30 (y)是其父节点 23 (z)的右子节点。该算法告诉我们，节点 23 (z)是节点 24 (x)的前身。</p><p id="c382" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">关于节点 34 的前任的情况，节点 34 是 x。由于节点 34 (x)没有左孩子，我们从节点 34 (x)向上，我们发现节点 34 (y)也是其父节点 30 (z)的右孩子。因此，节点 34 (x)的前身是节点 30 (z)。注意，如果一个节点是正确的子节点，它可以同时是 x 和 y。</p><p id="a4b7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">获取前任</strong></p><pre class="kg kh ki kj fd kk kl km kn aw ko bi"><span id="77cd" class="kp je hi kl b fi kq kr l ks kt">@staticmethod<br/>def get_predecessor(node: Node) -&gt; Optional[Node]:<br/>    if node.left:  # Case 1: left child is not empty<br/>        return BinarySearchTree.get_rightmost(node=node.left)<br/>    # Case 2: left child is empty<br/>    parent = node.parent<br/>    while parent and (node == parent.left):<br/>        node = parent<br/>        parent = parent.parent<br/>    return parent</span></pre><p id="c423" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">继任者</strong></p><p id="ed70" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">获得后继的算法与获得前任的算法是对称的，并且它也有两种寻找给定节点的后继的情况:</p><ul class=""><li id="6adb" class="kv kw hi ih b ii ij im in iq kx iu ky iy kz jc la lb lc ld bi translated">如果给定节点的右子节点不为空，那么右子树最左边的节点就是后继节点。</li><li id="6130" class="kv kw hi ih b ii le im lf iq lg iu lh iy li jc la lb lc ld bi translated">如果给定节点(x)的右子节点为空，那么我们从节点(x)向上，直到遇到一个节点(y ),它是其父节点(z)的左子节点。父节点(z)是给定节点(x)的后继节点。</li></ul><p id="5341" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">下图显示了这两种情况。</p><figure class="kg kh ki kj fd ll er es paragraph-image"><div class="er es ml"><img src="../Images/126a4138020348bef3f0ab8e4c5db749.png" data-original-src="https://miro.medium.com/v2/resize:fit:1122/format:webp/0*bidp_kMsl7YOn4h0.png"/></div></figure><p id="a6a9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">与前一种情况一样，如果一个节点是左子节点，则该节点可以同时是 x 和 y。</p><p id="05bf" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在节点 15 的后继节点的情况下，节点 15 是 x 和 y，节点 20 是 z，它是节点 15 的后继节点。</p><p id="608b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">对于节点 22 的后继，节点 22 是 x，节点 4 是 y，节点 23 是 z。所以节点 23 是节点 22 (x)的后继。</p><p id="432f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">得到接班人</strong></p><pre class="kg kh ki kj fd kk kl km kn aw ko bi"><span id="df7f" class="kp je hi kl b fi kq kr l ks kt">@staticmethod<br/>def get_successor(node: Node) -&gt; Optional[Node]:<br/>    if node.right:  # Case 1: right child is not empty<br/>        return BinarySearchTree.get_leftmost(node=node.right)<br/>    # Case 2: right child is empty<br/>    parent = node.parent<br/>    while parent and (node == parent.right):<br/>        node = parent<br/>        parent = parent.parent<br/>    return parent</span></pre><h1 id="8bae" class="jd je hi bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">特殊函数</h1><p id="4a1c" class="pw-post-body-paragraph if ig hi ih b ii kb ik il im kc io ip iq kd is it iu ke iw ix iy kf ja jb jc hb bi translated">根据 Python 文档，<a class="ae ku" href="https://docs.python.org/3.9/reference/datamodel.html#object.__repr__" rel="noopener ugc nofollow" target="_blank"> __repr__() </a>用于计算对象的正式字符串表示。文档还说，“这通常用于调试，…”。因此，在我们的<em class="lj"> BinarySearchTree </em>类中，我们利用这个函数来提供树细节，这将帮助我们调试问题。</p><pre class="kg kh ki kj fd kk kl km kn aw ko bi"><span id="c591" class="kp je hi kl b fi kq kr l ks kt">def __repr__(self) -&gt; str:<br/>    if self.root:<br/>        return (<br/>            f"{type(self)}, root={self.root}, "<br/>            f"tree_height={str(self.get_height(self.root))}"<br/>        )<br/>    return "empty tree"</span></pre><p id="fa33" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">当我们在一个<em class="lj"> BinarySearchTree </em>对象上打印<a class="ae ku" href="https://docs.python.org/3.9/library/functions.html#repr" rel="noopener ugc nofollow" target="_blank"> repr() </a>时，我们可以查看如下所示的树细节。</p><pre class="kg kh ki kj fd kk kl km kn aw ko bi"><span id="cab4" class="kp je hi kl b fi kq kr l ks kt">&lt;class '__main__.BinarySearchTree'&gt;, root=Node(key=23, data='23', left=Node(key=4, data='4', left=Node(key=1, data='1', left=None, right=None, parent=...), right=Node(key=11, data='11', left=Node(key=7, data='7', left=None, right=None, parent=...), right=Node(key=20, data='20', left=Node(key=15, data='15', left=None, right=None, parent=...), right=Node(key=22, data='22', left=None, right=None, parent=...), parent=...), parent=...), parent=...), right=Node(key=30, data='30', left=Node(key=24, data='24', left=None, right=None, parent=...), right=Node(key=34, data='34', left=None, right=None, parent=...), parent=...), parent=None), tree_height=4</span></pre><p id="697e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这些信息可以帮助我们调试问题。</p><h1 id="572e" class="jd je hi bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">试验</h1><p id="b6e3" class="pw-post-body-paragraph if ig hi ih b ii kb ik il im kc io ip iq kd is it iu ke iw ix iy kf ja jb jc hb bi translated">单元测试是软件项目保证质量的最低要求。pytest 框架是 Python 程序的一个流行的测试框架。在我们的项目中，我们在以下设置中使用它:</p><p id="f74a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">请查看每个链接了解详细信息。</p><h1 id="dd9a" class="jd je hi bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">分析</h1><p id="dada" class="pw-post-body-paragraph if ig hi ih b ii kb ik il im kc io ip iq kd is it iu ke iw ix iy kf ja jb jc hb bi translated">一个能够工作的软件程序，正确性和性能都是必要的。然而，我认为正确性比性能更重要。当我们实现一个软件程序时，我们应该总是确保程序正常工作，然后调整它的性能。没有正确性，程序就没有用。这也是为什么本文是按这个顺序写的:测试部分在分析部分之前。在测试部分(并确保<em class="lj">二进制搜索树</em>工作)之后，这一部分重点关注它的性能。本节的分析适用于一般的二叉查找树(不仅仅是我们实现的<em class="lj">二进制搜索树</em>)。</p><p id="abc3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">二叉查找树的空间复杂度是 O(n)，其中 n 是节点的总数。</p><p id="cc01" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">二叉查找树每次操作的运行时间高度依赖于树的高度。如果树的高度是 h，我们可以得到每个操作的运行时间如下:</p><p id="f3da" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">对于插入操作，我们首先需要找到从根到叶层插入节点的位置，这需要运行时间 T(h)对树高 h，然后更新节点属性，这需要恒定的运行时间。因此，插入操作的总运行时间是 T(h) +常数，这也相当于 O(h)，因为 big-O 符号是运行时间的上限。</p><p id="f429" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">类似地，搜索和删除操作也需要从根开始遍历树，直到找到节点或要删除的节点。因此，它们的运行时间也是 O(h)其中 h 是树高。</p><p id="1f4b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为了找到最左边和最右边的节点，我们还需要从给定节点到叶层遍历树，因为最左边和最右边的节点必须在叶层中。运行时间也是 O(h ),其中 h 是(子)树的高度。</p><p id="4b49" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">给定节点的前任有两种情况:1 .给定节点有一个左子节点，2。给定节点的左子节点为空。</p><p id="e2f8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">由于如果给定的节点有一个左子节点，那么左子树最右边的节点就是前任节点，所以情况 1 的运行时间相当于得到最左边的节点，也就是 O(h)其中 h 是树高。</p><p id="40be" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">对于案例 2，我们需要找到父节点的右子节点。换句话说，如果前一个在最顶层，它的代价可能是 O(h)。</p><p id="64b0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">所以前任的运行时间是两种情况的组合:O(h) + O(h) = 2 * O(h) = O(h)。</p><p id="56b9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">后继者与前任是对称的，它也有运行时间 O(h ),其中 h 是树的高度。</p><p id="6e15" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在，我们知道每个操作的运行时间取决于树的高度。接下来我们想知道的是，当一棵树有 n 个节点时，它能有多高。</p><p id="f965" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果一棵树是完整的，那么它的高度是 O(lg n)。但是，如果二叉树是线性链式的，那么它的高度就变成 O(n)。</p><figure class="kg kh ki kj fd ll er es paragraph-image"><div role="button" tabindex="0" class="md me di mf bf mg"><div class="er es mm"><img src="../Images/16e5bb0f73215ab2c208bc116d8063e7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*1G3CZZB4IPPdyHL3.png"/></div></div></figure><p id="cab0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">基于定理“在 n 个不同的键上随机构造的二叉查找树的期望高度是 O(lg n)”，平均情况下每个操作的时间复杂度为 O(lg n)。这个定理的细节和证明在<a class="ae ku" href="https://en.wikipedia.org/wiki/Introduction_to_Algorithms" rel="noopener ugc nofollow" target="_blank">算法介绍</a>第 12.4 章中讨论。</p><p id="2009" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">因此，我们可以在表中总结每个操作的运行时间。n 是节点的数量。</p><figure class="kg kh ki kj fd ll er es paragraph-image"><div role="button" tabindex="0" class="md me di mf bf mg"><div class="er es mn"><img src="../Images/c7171c597763750ce272153c31072de1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xW9XFNtRfyH6RVFyHH37GQ.png"/></div></div></figure><h1 id="8824" class="jd je hi bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">例子</h1><p id="3027" class="pw-post-body-paragraph if ig hi ih b ii kb ik il im kc io ip iq kd is it iu ke iw ix iy kf ja jb jc hb bi translated">树数据结构在软件中被广泛使用，包括实现其他数据结构。例如，<em class="lj"> BinarySearchTree </em>提供的操作允许我们使用搜索树作为键值映射。本节通过使用我们在这个项目中实现的<em class="lj"> BinarySearchTree </em>演示了一个键值<em class="lj">映射</em>。</p><p id="0bff" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">key-value <em class="lj"> Map </em>类支持插入一个 key-value 项、通过键获取一个项以及通过键删除一个项等操作。为了支持这些操作，我们需要实现用于插入键值项的<a class="ae ku" href="https://docs.python.org/3/reference/datamodel.html#object.__setitem__" rel="noopener ugc nofollow" target="_blank"> __setitem__ </a>函数、用于按键检索项的<a class="ae ku" href="https://docs.python.org/3/reference/datamodel.html#object.__getitem__" rel="noopener ugc nofollow" target="_blank"> __getitem__ </a>函数和用于按键删除项的<a class="ae ku" href="https://docs.python.org/3/reference/datamodel.html#object.__delitem__" rel="noopener ugc nofollow" target="_blank"> __delitem__ </a>函数。因此，我们有如下的实现:</p><pre class="kg kh ki kj fd kk kl km kn aw ko bi"><span id="a418" class="kp je hi kl b fi kq kr l ks kt">from typing import Any, Optional<br/><br/>from forest.binary_trees import binary_search_tree<br/><br/>class Map:<br/>    """Key-value Map implemented by the Binary Search Tree."""<br/><br/>    def __init__(self) -&gt; None:<br/>        self._bst = binary_search_tree.BinarySearchTree()<br/><br/>    def __setitem__(self, key: Any, value: Any) -&gt; None:<br/>        self._bst.insert(key=key, data=value)<br/><br/>    def __getitem__(self, key: Any) -&gt; Optional[Any]:<br/>        node = self._bst.search(key=key)<br/>        if node:<br/>            return node.data<br/>        return None<br/><br/>    def __delitem__(self, key: Any) -&gt; None:<br/>        self._bst.delete(key=key)<br/><br/>    @property<br/>    def empty(self) -&gt; bool:<br/>        """Return `True` if the map is empty; `False` otherwise."""<br/>        return self._bst.empty<br/><br/>if __name__ == "__main__":<br/><br/>    # Initialize the Map instance.<br/>    contacts = Map()<br/><br/>    # Add some items.<br/>    contacts["Mark"] = "mark@email.com"<br/>    contacts["John"] = "john@email.com"<br/>    contacts["Luke"] = "luke@email.com"<br/><br/>    # Retrieve an email<br/>    print(contacts["Mark"])<br/><br/>    # Delete one item.<br/>    del contacts["John"]<br/><br/>    # Check the deleted item.<br/>    print(contacts["John"])  # This will print None</span></pre><p id="30cf" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">(完整示例可从<a class="ae ku" href="https://github.com/shunsvineyard/forest-python/blob/main/examples/bst_map.py" rel="noopener ugc nofollow" target="_blank"> bst_map.py </a>获得)</p><h1 id="4244" class="jd je hi bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">摘要</h1><p id="daa6" class="pw-post-body-paragraph if ig hi ih b ii kb ik il im kc io ip iq kd is it iu ke iw ix iy kf ja jb jc hb bi translated">在一般情况下，二叉查找树提供了良好的空间利用率和相对较好的操作性能，比如插入、搜索和删除。然而，我们不能保证树在大多数情况下是平衡的。正因为如此，二叉查找树没有被广泛用于解决现实世界的问题。为了解决不平衡问题和提高某些操作的性能，引入了二叉查找树的几种变体，例如红黑树和 AVL 树。因此，充分理解二叉查找树是高级树数据结构的坚实基础。</p></div><div class="ab cl mo mp gp mq" role="separator"><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt"/></div><div class="hb hc hd he hf"><p id="9885" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="lj">原载于 2021 年 3 月 13 日</em><a class="ae ku" href="https://shunsvineyard.info/2021/03/12/build-the-forest-in-python-series-binary-search-tree/" rel="noopener ugc nofollow" target="_blank"><em class="lj">https://shunsvineyard . info</em></a><em class="lj">。</em></p></div></div>    
</body>
</html>