<html>
<head>
<title>LSTM based malware detection (Python &amp; Tensorflow)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">基于LSTM的恶意软件检测(Python和Tensorflow)</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/lstm-based-malware-detection-python-tensorflow-9d047cfe8766?source=collection_archive---------2-----------------------#2021-04-09">https://medium.com/nerd-for-tech/lstm-based-malware-detection-python-tensorflow-9d047cfe8766?source=collection_archive---------2-----------------------#2021-04-09</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/73b6462219bbd1c85aa726bc2fc18cf5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DbzpEg77lJr5r_ZKgXfALw.png"/></div></div></figure><p id="acde" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在我们以前的一篇帖子中，我们展示了如何通过将可执行文件转换为灰度图像，使用卷积神经网络来创建恶意软件检测器。在这篇文章中，我们将看到如何探索一个可执行文件的汇编代码来分析它的恶意内容。</p><h1 id="8df2" class="jo jp hi bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">从中间开始…</h1><p id="006f" class="pw-post-body-paragraph iq ir hi is b it km iv iw ix kn iz ja jb ko jd je jf kp jh ji jj kq jl jm jn hb bi translated">我们可以用它的指令序列来表示一个可执行程序，N个指令的每个序列被认为是用汇编语言编写的N个单词的文本。因此，我们将处理语言为汇编的文本分类问题。后者在其字典(词汇表)中包含1600多条指令。每个指令可以用一个向量来表示。我们可以通过使用一个热点矢量表示来实现。简单地说，一个热向量是这样的向量，其中除了一个被设置为1之外，每个条目都被设置为0。它也是一个来自n维空间的标准基的向量。</p><p id="c380" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在1600指令上使用规范表示有很多缺点。首先，用大小为1600的稀疏向量表示每个指令会降低神经网络的性能。第二，使用规范向量应该只适用于基底，这意味着单词应该足以生成语言<strong class="is hj">中的任何表达式(含义),而基底</strong>的组件之间没有相关性，这在汇编语言中肯定是不满足的，因为一些指令之间存在相关性。为了克服这个问题，我们将把指令重新分组，每个组包含一组相同用途的指令:算术指令、数据传输指令……这样我们将增加一个组内指令的相关性，减少不同组之间的相关性，从而减少空间维度。</p><p id="5909" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在我所做的工作中，我将汇编语言的不同指令映射到49个系列中，为此我使用了英特尔在其文档中给出的分类。以下是指令的组合:</p><figure class="kr ks kt ku fd ij"><div class="bz dy l di"><div class="kv kw l"/></div><figcaption class="kx ky et er es kz la bd b be z dx translated">我没有发疯，把所有指令分类，所以这不是汇编语言的全部字典</figcaption></figure><p id="556a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我知道这不是一件令人愉快的事情，但幸运的是，我做到了，所以没有人必须这样做。</p><h1 id="a2ff" class="jo jp hi bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">然后是LSTM</h1><p id="a0ca" class="pw-post-body-paragraph iq ir hi is b it km iv iw ix kn iz ja jb ko jd je jf kp jh ji jj kq jl jm jn hb bi translated">因为我们是在合理维度的空间中处理序列分析的问题，所以使用LSTM模型是头脑中一个直观的想法。</p><p id="74e6" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">LSTM模型在序列分析方面非常强大，但使用起来也很棘手。为了确保我们为网络选择了正确的参数，我改变了网络的多个参数，并预测了所有值的平均性能。</p><p id="8715" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">出于本研究的目的，使用大小为128、序列长度为128的3层指令(映射到系列中)是最佳架构。</p><figure class="kr ks kt ku fd ij er es paragraph-image"><div class="er es lb"><img src="../Images/b6f41850a16e36a474469effb9d1b139.png" data-original-src="https://miro.medium.com/v2/resize:fit:950/format:webp/1*ypD1HNt90m7YBN50XS_6xQ.png"/></div><figcaption class="kx ky et er es kz la bd b be z dx translated">三层LSTM模型</figcaption></figure><h1 id="07ef" class="jo jp hi bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">直接实施</h1><figure class="kr ks kt ku fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lc"><img src="../Images/ac90e86bfa8a307675c466dc8c7b710f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OXtktyCS6wQb0Y4w7HG_tw.png"/></div></div></figure><p id="ff30" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">为了实现我们的想法，我们首先需要反汇编一个可执行文件。幸运的是，我已经在我以前的一篇文章中解释了如何用python创建一个反汇编器(<a class="ae ld" href="https://isleem.medium.com/create-your-own-disassembler-in-python-pefile-capstone-754f863b2e1c" rel="noopener">https://isleem . medium . com/create-your-own-disassembler-in-python-pefile-capstone-754 f 863 B2 E1 c</a>)。</p><p id="f901" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">但是，如果您没有时间看它，请不要担心，我有一个完整的python脚本来从exe文件中获取指令序列，尽管我鼓励您理解它是如何工作的，以便您可以维护它。您可以在我的GitHub中找到完整的python脚本，位置如下:</p><div class="le lf ez fb lg lh"><a href="https://github.com/islem-esi/DeepMalwareDetector/blob/master/Features%20Extractor/OPcodes%20Sequences%20Extractor.ipynb" rel="noopener  ugc nofollow" target="_blank"><div class="li ab dw"><div class="lj ab lk cl cj ll"><h2 class="bd hj fi z dy lm ea eb ln ed ef hh bi translated">islem-esi/DeepMalwareDetector</h2><div class="lo l"><h3 class="bd b fi z dy lm ea eb ln ed ef dx translated">分析Windows PE文件以检测恶意软件的深度学习框架。- islem-esi/DeepMalwareDetector</h3></div><div class="lp l"><p class="bd b fp z dy lm ea eb ln ed ef dx translated">github.com</p></div></div><div class="lq l"><div class="lr l ls lt lu lq lv io lh"/></div></div></a></div><p id="245d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如果你打开那个脚本，真正重要的是最后一个块，它是执行提取的循环，你必须在那里改变exe文件文件夹的路径。还要删除3或行，因为它们不重要，可能会引发错误。</p><p id="0a55" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">一旦分解完成，我们需要为我们的神经网络编码数据并创建模型，就像这样:</p><figure class="kr ks kt ku fd ij"><div class="bz dy l di"><div class="kv kw l"/></div></figure><p id="2a6b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在，你想看演示，没问题！参考我之前的帖子:<a class="ae ld" rel="noopener" href="/analytics-vidhya/deep-learning-based-malware-detection-demo-d545c5653200">https://medium . com/analytics-vid hya/deep-learning-based-malware-detection-demo-d545c 5653200</a></p><p id="81c7" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在上一篇文章中，您可以找到kaggle笔记本的链接，其中包含所有导出的模型，因此您可以下载并重用它们。您还可以找到演示的完整代码，您可以将它链接到您选择的漂亮的仪表板。我已经选择使用Anvil.works，试一试，简单易行。</p><p id="6fca" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这就是LSTMs的全部内容。我将很快与你分享用于汇编指令序列训练的数据集。</p><h2 id="1b97" class="lw jp hi bd jq lx ly lz ju ma mb mc jy jb md me kc jf mf mg kg jj mh mi kk mj bi translated">更新:</h2><p id="bc30" class="pw-post-body-paragraph iq ir hi is b it km iv iw ix kn iz ja jb ko jd je jf kp jh ji jj kq jl jm jn hb bi translated">你可以在https://github.com/islem-esi/DeepMalwareDetector的<a class="ae ld" href="https://github.com/islem-esi/DeepMalwareDetector" rel="noopener ugc nofollow" target="_blank"> GitHub repo </a> : <a class="ae ld" href="https://github.com/islem-esi/DeepMalwareDetector" rel="noopener ugc nofollow" target="_blank">上找到完整的实现、模型和更多信息</a></p></div></div>    
</body>
</html>