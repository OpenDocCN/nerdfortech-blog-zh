<html>
<head>
<title>Swift Leetcode Series: Binary Tree Level Order Traversal</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Swift Leetcode 系列:二叉树层次顺序遍历</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/swift-leetcode-series-binary-tree-level-order-traversal-db7603af1bb3?source=collection_archive---------14-----------------------#2021-05-20">https://medium.com/nerd-for-tech/swift-leetcode-series-binary-tree-level-order-traversal-db7603af1bb3?source=collection_archive---------14-----------------------#2021-05-20</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="b810" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">像专家一样快速穿过树林🚀 🚀 🚀</h2></div><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ix"><img src="../Images/576fc0f76f113398d6e99db61c2d42aa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FYVAeuLk_QUgMzF3tiGJQw.png"/></div></div></figure><div class="jj jk ez fb jl jm"><a href="https://theswiftnerd.com/binary-tree-level-order-traversal/" rel="noopener  ugc nofollow" target="_blank"><div class="jn ab dw"><div class="jo ab jp cl cj jq"><h2 class="bd hj fi z dy jr ea eb js ed ef hh bi translated">二叉树层次顺序遍历(Leetcode 102)</h2><div class="jt l"><h3 class="bd b fi z dy jr ea eb js ed ef dx translated">难度:链接:第 12 天:五月 Leetcode 挑战给定二叉树的根，返回遍历的层次顺序…</h3></div><div class="ju l"><p class="bd b fp z dy jr ea eb js ed ef dx translated">theswiftnerd.com</p></div></div><div class="jv l"><div class="jw l jx jy jz jv ka jh jm"/></div></div></a></div><p id="97cb" class="pw-post-body-paragraph kb kc hi kd b ke kf ij kg kh ki im kj kk kl km kn ko kp kq kr ks kt ku kv kw hb bi translated">你可以通过上面的链接在 Swift Nerd 博客上阅读完整的故事。</p><h1 id="9159" class="kx ky hi bd kz la lb lc ld le lf lg lh io li ip lj ir lk is ll iu lm iv ln lo bi translated">问题描述</h1><p id="e199" class="pw-post-body-paragraph kb kc hi kd b ke lp ij kg kh lq im kj kk lr km kn ko ls kq kr ks lt ku kv kw hb bi translated">给定二叉树的<code class="du lu lv lw lx b">root</code>，返回<em class="ly">其节点值</em>的层次顺序遍历。(即从左到右，逐层)。</p><h1 id="70c2" class="kx ky hi bd kz la lb lc ld le lf lg lh io li ip lj ir lk is ll iu lm iv ln lo bi translated">例子</h1><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es lz"><img src="../Images/b998db024f18014af3a48340574a8fd3.png" data-original-src="https://miro.medium.com/v2/resize:fit:554/format:webp/0*Bv6XuxYBu7v8a0W1.jpg"/></div></figure><pre class="iy iz ja jb fd ma lx mb mc aw md bi"><span id="b88f" class="me ky hi lx b fi mf mg l mh mi"><strong class="lx hj">Input:</strong> root = [3,9,20,null,null,15,7]<br/><strong class="lx hj">Output:</strong> [[3],[9,20],[15,7]]</span><span id="0c2e" class="me ky hi lx b fi mj mg l mh mi"><strong class="lx hj">Input:</strong> root = [1]<br/><strong class="lx hj">Output:</strong> [[1]]</span><span id="e188" class="me ky hi lx b fi mj mg l mh mi"><strong class="lx hj">Input:</strong> root = []<br/><strong class="lx hj">Output:</strong> []</span></pre><h1 id="0afe" class="kx ky hi bd kz la lb lc ld le lf lg lh io li ip lj ir lk is ll iu lm iv ln lo bi translated">限制</h1><ul class=""><li id="88e9" class="mk ml hi kd b ke lp kh lq kk mm ko mn ks mo kw mp mq mr ms bi translated">树中的节点数量在范围<code class="du lu lv lw lx b">[0, 2000]</code>内。</li><li id="6a88" class="mk ml hi kd b ke mt kh mu kk mv ko mw ks mx kw mp mq mr ms bi translated"><code class="du lu lv lw lx b">-1000 &lt;= Node.val &lt;= 1000</code></li></ul><h1 id="f22e" class="kx ky hi bd kz la lb lc ld le lf lg lh io li ip lj ir lk is ll iu lm iv ln lo bi translated">解决办法</h1><h1 id="705a" class="kx ky hi bd kz la lb lc ld le lf lg lh io li ip lj ir lk is ll iu lm iv ln lo bi translated">广度优先搜索</h1><p id="99e9" class="pw-post-body-paragraph kb kc hi kd b ke lp ij kg kh lq im kj kk lr km kn ko ls kq kr ks lt ku kv kw hb bi translated">BFS 方法包括使用一种叫做<strong class="kd hj"> Queue(q) </strong>的数据结构，这样我们就可以按照正确的顺序处理树的节点。队列按照先进先出(<strong class="kd hj"> FIFO </strong>)的顺序运行，所以插入会在末尾，从前面移除。我们可以使用该属性，并通过在每次迭代后查找队列中的元素计数来计算下一级要处理的项目数。</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="my mz l"/></div></figure><h1 id="7c46" class="kx ky hi bd kz la lb lc ld le lf lg lh io li ip lj ir lk is ll iu lm iv ln lo bi translated">复杂性分析</h1><ul class=""><li id="059e" class="mk ml hi kd b ke lp kh lq kk mm ko mn ks mo kw mp mq mr ms bi translated"><strong class="kd hj">时间复杂度= O(N) </strong>因为每个节点恰好被处理一次。</li><li id="7ee3" class="mk ml hi kd b ke mt kh mu kk mv ko mw ks mx kw mp mq mr ms bi translated"><strong class="kd hj">空间复杂度= O(N) </strong>保持包含<code class="du lu lv lw lx b">N</code>节点值的输出结构</li></ul></div><div class="ab cl na nb gp nc" role="separator"><span class="nd bw bk ne nf ng"/><span class="nd bw bk ne nf ng"/><span class="nd bw bk ne nf"/></div><div class="hb hc hd he hf"><p id="ae48" class="pw-post-body-paragraph kb kc hi kd b ke kf ij kg kh ki im kj kk kl km kn ko kp kq kr ks kt ku kv kw hb bi translated">感谢您的阅读。如果你喜欢这篇文章，并发现它很有用，请分享并像野火一样传播它！</p><p id="b867" class="pw-post-body-paragraph kb kc hi kd b ke kf ij kg kh ki im kj kk kl km kn ko kp kq kr ks kt ku kv kw hb bi translated">你可以在<a class="ae nh" href="https://theswiftnerd.com/" rel="noopener ugc nofollow" target="_blank">the swift nerd</a>|<a class="ae nh" href="https://www.linkedin.com/in/varunrathi28/" rel="noopener ugc nofollow" target="_blank">LinkedIn</a>|<a class="ae nh" href="https://github.com/varunrathi28" rel="noopener ugc nofollow" target="_blank">Github</a>上找到我</p></div></div>    
</body>
</html>