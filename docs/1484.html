<html>
<head>
<title>JWT, JWS and JWE in nodejs</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">nodejs 的 JWT、JWS 和 JWE</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/jwt-jws-and-jwe-in-nodejs-7595542565d0?source=collection_archive---------0-----------------------#2021-03-22">https://medium.com/nerd-for-tech/jwt-jws-and-jwe-in-nodejs-7595542565d0?source=collection_archive---------0-----------------------#2021-03-22</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/247d71500fcaa51124f5d4fced631ec2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9HB99u7Cq4pBcArZPZ7oEQ.jpeg"/></div></div></figure><p id="0aad" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">JSON Web Token (JWT 读作“jot”)是 IETF 标准，用于以安全和紧凑的方式在相关方之间传输 JSON 格式声明。JWT 已经成为基于令牌授权的开放标准。</p><blockquote class="jo jp jq"><p id="c31c" class="iq ir jr is b it iu iv iw ix iy iz ja js jc jd je jt jg jh ji ju jk jl jm jn hb bi translated">JSON Web Token (JWT)是一种简洁的、URL 安全的方式，用于表示在双方之间传输的<br/>声明。JWT <br/>中的声明被编码为一个 JSON 对象，该对象被用作 JSON <br/> Web 签名(JWS)结构的有效载荷，或者作为 JSON Web <br/>加密(JWE)结构的明文，使得声明能够被数字<br/>签名或者用消息认证码<br/> (MAC)进行完整性保护和/或加密。</p></blockquote><h2 id="99b6" class="jw jx hi bd jy jz ka kb kc kd ke kf kg jb kh ki kj jf kk kl km jj kn ko kp kq bi translated">JWT 的属性</h2><ul class=""><li id="2352" class="kr ks hi is b it kt ix ku jb kv jf kw jj kx jn ky kz la lb bi translated">小型的，紧凑的</li><li id="dd1e" class="kr ks hi is b it lc ix ld jb le jf lf jj lg jn ky kz la lb bi translated">声明是 JSON 编码的</li><li id="d31c" class="kr ks hi is b it lc ix ld jb le jf lf jj lg jn ky kz la lb bi translated">URL 安全(base 64 URL 编码)</li><li id="110e" class="kr ks hi is b it lc ix ld jb le jf lf jj lg jn ky kz la lb bi translated">自包含(因此实现无状态授权是可能的)</li></ul></div><div class="ab cl lh li gp lj" role="separator"><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm"/></div><div class="hb hc hd he hf"><h2 id="27e7" class="jw jx hi bd jy jz ka kb kc kd ke kf kg jb kh ki kj jf kk kl km jj kn ko kp kq bi translated">使用 JWT 的授权</h2><p id="5ea6" class="pw-post-body-paragraph iq ir hi is b it kt iv iw ix ku iz ja jb lo jd je jf lp jh ji jj lq jl jm jn hb bi translated">说到授权，有两种主要方法</p><ol class=""><li id="4e4c" class="kr ks hi is b it iu ix iy jb lr jf ls jj lt jn lu kz la lb bi translated">基于无会话令牌(JWT)</li><li id="bd48" class="kr ks hi is b it lc ix ld jb le jf lf jj lg jn lu kz la lb bi translated">基于会话(cookies)</li></ol><p id="f6d9" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">重要的是首先要详细理解基于会话的授权机制，以确定使用无会话的基于令牌的授权的优势。基于会话的授权方法有两个部分。</p><ol class=""><li id="aaec" class="kr ks hi is b it iu ix iy jb lr jf ls jj lt jn lu kz la lb bi translated">服务器根据会话 id 存储引用对象</li><li id="1274" class="kr ks hi is b it lc ix ld jb le jf lf jj lg jn lu kz la lb bi translated">客户端将会话(cookie)保存在应用程序中，其中包含服务器的详细信息，如域</li></ol><p id="68f2" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">当客户机需要访问服务器资源时，它发送带有 HTTP 请求的会话(cookie)。服务器验证会话以授予对资源的访问权。服务器必须读取与会话相关的引用对象，以进一步识别请求者。基于 JWT 令牌的授权系统解决了这一过程的一些限制。</p><p id="2970" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">基于令牌授权的优势</strong></p><ul class=""><li id="1016" class="kr ks hi is b it iu ix iy jb lr jf ls jj lt jn ky kz la lb bi translated">无国籍的</li><li id="1525" class="kr ks hi is b it lc ix ld jb le jf lf jj lg jn ky kz la lb bi translated">分散授权(微服务友好)</li><li id="4b4c" class="kr ks hi is b it lc ix ld jb le jf lf jj lg jn ky kz la lb bi translated">混合，单页应用友好</li><li id="6f78" class="kr ks hi is b it lc ix ld jb le jf lf jj lg jn ky kz la lb bi translated">移动应用友好</li><li id="453e" class="kr ks hi is b it lc ix ld jb le jf lf jj lg jn ky kz la lb bi translated">不需要集中式令牌存储</li></ul></div><div class="ab cl lh li gp lj" role="separator"><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm"/></div><div class="hb hc hd he hf"><h2 id="4c89" class="jw jx hi bd jy jz ka kb kc kd ke kf kg jb kh ki kj jf kk kl km jj kn ko kp kq bi translated">JWT 变奏</h2><p id="40c2" class="pw-post-body-paragraph iq ir hi is b it kt iv iw ix ku iz ja jb lo jd je jf lp jh ji jj lq jl jm jn hb bi translated">以下是摘自(https://OpenID . net/specs/draft-Jones-JSON-we B- signature-04 . html)的 JWT 示例。这有三个部分，由句点(.)是 base64 URL 编码的纯文本值。</p><blockquote class="jo jp jq"><p id="f680" class="iq ir jr is b it iu iv iw ix iy iz ja js jc jd je jt jg jh ji ju jk jl jm jn hb bi translated">eyj 0 exaioijkv 1 qilcjhbgcioijiuzi 1 nij 9 . eyjpc 3 mioijqb 2 uilchlehaiojezmda 4 MTK zodasimh 0 DHA 6 ly 9 legftcgxllmnvbs 9 PC 19 Yb 290 ijp 0 cnvlfq . KD 7k 33 MK 6 GL 5 nlsy 6-C5 xzkvbzxcf 4 l5 S6 umwtnsg</p></blockquote><p id="0b9c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">jwt.io 用于解码这个令牌并检查内容。</p><figure class="lw lx ly lz fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lv"><img src="../Images/b29cd11e182d9a01859a0bbd653f5dbf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZQaAk4269N5D5Bt8SqY39A.png"/></div></div><figcaption class="ma mb et er es mc md bd b be z dx translated">来自 jwt.io 的 JWT 示例</figcaption></figure><h2 id="2de9" class="jw jx hi bd jy jz ka kb kc kd ke kf kg jb kh ki kj jf kk kl km jj kn ko kp kq bi translated">令牌的“三个部分”</h2><p id="8408" class="pw-post-body-paragraph iq ir hi is b it kt iv iw ix ku iz ja jb lo jd je jf lp jh ji jj lq jl jm jn hb bi translated"><strong class="is hj"> Header: { "typ": "JWT "，" alg": "HS256"} </strong></p><p id="6c04" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这个头被称为<strong class="is hj"> JOSE </strong> (Javascript 对象签名和加密)包含有关生成令牌的签名和/或加密算法的信息。上面的例子是用对称算法<strong class="is hj"> HS256 </strong> (HMAC 和 SHA-256)签名的。</p><p id="f794" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">有效载荷:</strong></p><p id="75e7" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">有效载荷包含两种类型的声明，称为<em class="jr">注册声明</em>和<em class="jr">自定义声明</em> <em class="jr">。</em>RFC 中明确定义了注册声明。其中有<strong class="is hj"> iss </strong>(发行人)<strong class="is hj"> exp </strong>(到期时间)<strong class="is hj"> sub </strong>(主体)<strong class="is hj"> aud </strong>(受众)。更多详情可在 RFC <a class="ae jv" href="https://tools.ietf.org/html/rfc7519#section-4.1" rel="noopener ugc nofollow" target="_blank">文件</a> <a class="ae jv" href="https://tools.ietf.org/html/rfc7519#section-4.1." rel="noopener ugc nofollow" target="_blank">中找到。</a>注册声明可用作令牌的额外验证。自定义声明可以是基于应用程序需求定义的任何键/值对。</p><p id="09b6" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">签名:</strong></p><p id="47d6" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">签名是通过将签名算法应用于报头和有效载荷组合来创建的。这可以防止在令牌发布给客户端后对其进行修改。</p><figure class="lw lx ly lz fd ij er es paragraph-image"><div class="er es me"><img src="../Images/a308590391a684252ae61a67ebd03df2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1292/format:webp/1*COcXTo9x9qyWelWppDrXLQ.png"/></div><figcaption class="ma mb et er es mc md bd b be z dx translated">jwt.io 的签名部分</figcaption></figure></div><div class="ab cl lh li gp lj" role="separator"><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm"/></div><div class="hb hc hd he hf"><h2 id="c7a4" class="jw jx hi bd jy jz ka kb kc kd ke kf kg jb kh ki kj jf kk kl km jj kn ko kp kq bi translated">JWT 变奏曲 JWS 和 JWE</h2><p id="450d" class="pw-post-body-paragraph iq ir hi is b it kt iv iw ix ku iz ja jb lo jd je jf lp jh ji jj lq jl jm jn hb bi translated"><strong class="is hj"> JWT </strong>被称为<strong class="is hj"> JWS </strong> (JSON Web Signature)当令牌按照上面的例子签名时。<strong class="is hj"> JWS </strong>令牌具有完整性(不可能在不使签名无效的情况下修改令牌)。使用 base64 编码器可以很容易地解码<strong class="is hj"> JWS </strong>令牌，因此它不是传输敏感数据的好选择。JWE(JSON Web Encryption)通过将加密引入 JWT 来解决这个问题。JWS 是 JWT 实现的著名变体。有库和大量的样本可用于验证，解码和生成 JWS 令牌。因此，我们将使用示例代码详细讨论 JWE。</p><h2 id="9538" class="jw jx hi bd jy jz ka kb kc kd ke kf kg jb kh ki kj jf kk kl km jj kn ko kp kq bi translated">JWE</h2><p id="22da" class="pw-post-body-paragraph iq ir hi is b it kt iv iw ix ku iz ja jb lo jd je jf lp jh ji jj lq jl jm jn hb bi translated">JWE 是加密 JWT 令牌声明的标准方式。代码段解释了如何加载密钥、加密令牌和解密令牌。这些代码是使用 cisco <a class="ae jv" href="https://github.com/cisco/node-jose#readme" rel="noopener ugc nofollow" target="_blank"> node-jose </a>库在 node js 中编写的。</p><p id="1f6c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">node-jose 库提供了一个 JWK 名称空间来生成、导入和导出密钥。在此示例中，非对称密钥对用于加密有效负载。</p><p id="43c4" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">使用开放 SSL 命令生成密钥对</strong></p><p id="91f0" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><code class="du mf mg mh mi b">openssl genrsa -des3 -out private.pem 2048</code>T39<code class="du mf mg mh mi b">openssl rsa -in private.pem -outform PEM -pubout -out public.pem</code>T40<code class="du mf mg mh mi b">openssl rsa -in private.pem -out plain_private.pem</code></p><p id="6960" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><code class="du mf mg mh mi b">cat plain_private.pem</code></p><figure class="lw lx ly lz fd ij er es paragraph-image"><div class="er es mj"><img src="../Images/ff852d2948de8fcaef857e9b9140335d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1230/format:webp/1*o0dQVhgrxeaWW6dH8-q3tg.png"/></div><figcaption class="ma mb et er es mc md bd b be z dx translated">私人密钥</figcaption></figure><p id="6a37" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><code class="du mf mg mh mi b">cat public.pem</code></p><figure class="lw lx ly lz fd ij er es paragraph-image"><div class="er es mk"><img src="../Images/934841755b6d58f0f35688dcc0f26121.png" data-original-src="https://miro.medium.com/v2/resize:fit:1218/format:webp/1*G4e3cbifC8kbdSCQlYAW1w.png"/></div><figcaption class="ma mb et er es mc md bd b be z dx translated">公开密钥</figcaption></figure><p id="d9b5" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">关键导入样本代码:</strong></p><pre class="lw lx ly lz fd ml mi mm mn aw mo bi"><span id="8a2e" class="jw jx hi mi b fi mp mq l mr ms">const { JWK } = require('node-jose');<br/>let makeKeys = async () =&gt; {<br/>    let privateKey = `-----BEGIN RSA PRIVATE KEY-----<br/>MIIEowIBAAKCAQEAwiSxcx5xFsNCjfDTOXz0M6RivgPXTTKb/PH6/x4vYl1xg/vI<br/>rG1yDGyFuyAizxNaGtA+qo2CvM3iATyDWQg3/8vDWiD4cIvUD2WE3XXewjyeGzQs<br/>o26DceRxopI2tlSgvznjifetGCp+oj4BWrTCqLF1AsR2ioUS7vuXMlpxXFhJfyEG<br/>oWuQaZDwoz7CZv1KrQwlRTtkqtn4IeXpVcgWhg/1r0iRsvNJDokyiMVY8hrrvza2<br/>j31JGaKYqCNYSC8Jf5EV7ONQhYGgQeRVxn8jS8UhLOFXDdNtgHwKi02tF1bmb3Ko<br/>/s3vzPvFB8C7CsYRtHAzcx/xor2/CbT0QGYfUQIDAQABAoIBADgdoQj0UJ3SvKcI<br/>aBViz7cpmbzwoUfYDAx16SXalLmq5sfOfDeSvvdmWtU2ubj/D/lWHfbwRkzKebv/<br/>wLt4S69tNz8S7pyhXh9BKcFVc5jTKqQUVZ67r9S4wjvKZXQYTApZ8jIL3AVzKv08<br/>TOnp+6YE/RxaqyToyAs5v383czLMdSM9bThDw+IZHfKFcl2iyUI4XVaPLDZPzUlG<br/>MW13ypwFQXbdro9pnMs9v2573WumIVvbiLqIdxK1anag0KbCnCY2hDmoLNv7Mohz<br/>1pFiqEStI6DQsYfEm/geIIL9nLhA8QJ28B9DtLKqRN7oWl2w5BiMEDCrmVK/4niM<br/>lsqF1ZECgYEA5zVsjoJzRCBgZ5dRx9BOu9MKXQ+h00LS3+JaApEzW+QV0DplTvb5<br/>aRUHhTIhUig2WdQVrEiBVXKg9eYmOBXOpX5pgDO5XJ16KcjdHcwMwoYAcUPIT5Y2<br/>tMgoX+jCgTt95cnLKhAnSlH9cCyq+nmcdfDNuvNx8HJO7P33MaVDHCUCgYEA1vXX<br/>cBWM+sGkUxpJNwlgA8bO7xq2kpbM3gqa0z6SKQhxnnmPyoKsZSHdwQMUCKIWBLjU<br/>n27STmXm2SblT1cT39MCED2t0U7N2D1KUQfZkFaN4gImF77iZBWIfDLObAom6JKg<br/>gER0glakAjbDMKq90mVzrKrR6XsD3az+AJE1eL0CgYBbHKB04E9QD3ouGGFv3lTI<br/>i3fQCHL676Bt/aL+0/1rPsyhzAFURtsuX80g3gpnd9VDPOJ1i/T7mTp47IMvItjW<br/>OqSUks1/A8e6Y59POLPmjCvsdoufYVCZmS7f7LeJeco5HXZkUw1Iqlq3M8MFBZt0<br/>lrpb68eAu2sC1WnuNHPnyQKBgQC1LFb7vO4pmnOpJwp2PIyUIkfe9qDSRA8/Rajg<br/>Smhd9SPt8X7jq+cpBbYlKzcDX7k3GaD7DyhpszEx7LpweG/jwbCHh7SsKMMNcfrk<br/>+LzCDnFe/3ijotqkiBGUvC2GmbfZZVupQAkCoYtx4j35Eq8SWTd5XC+3nVrQxzD9<br/>wWVT8QKBgBylVSsVeU7H/RT3RZ/qgWnpllBzGJic8X6lfyTHVD/9dO9XMzuD7R+/<br/>VFc9Ib71QPzyq39BX+YiCI+xwDGARgO3GGA4vxvF46Tq0rYUpZ1LiC4raO4I5xrl<br/>NxZCLVlhLWU27FR7xu8YN18mRCCwz1FCcsEtNU4nrBK2IIIwGLCf<br/>-----END RSA PRIVATE KEY-----`;<br/>    let publicKey = `-----BEGIN PUBLIC KEY-----<br/>MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAwiSxcx5xFsNCjfDTOXz0<br/>M6RivgPXTTKb/PH6/x4vYl1xg/vIrG1yDGyFuyAizxNaGtA+qo2CvM3iATyDWQg3<br/>/8vDWiD4cIvUD2WE3XXewjyeGzQso26DceRxopI2tlSgvznjifetGCp+oj4BWrTC<br/>qLF1AsR2ioUS7vuXMlpxXFhJfyEGoWuQaZDwoz7CZv1KrQwlRTtkqtn4IeXpVcgW<br/>hg/1r0iRsvNJDokyiMVY8hrrvza2j31JGaKYqCNYSC8Jf5EV7ONQhYGgQeRVxn8j<br/>S8UhLOFXDdNtgHwKi02tF1bmb3Ko/s3vzPvFB8C7CsYRtHAzcx/xor2/CbT0QGYf<br/>UQIDAQAB<br/>-----END PUBLIC KEY-----`<br/>    const jwKeys = await Promise.all([<br/>        JWK.asKey(privateKey, "pem"),<br/>        JWK.asKey(publicKey, "pem")<br/>    ]);<br/>    let keystore = JWK.createKeyStore();<br/>    await keystore.add(jwKeys[0]);<br/>    await keystore.add(jwKeys[1]);<br/>}<br/>makeKeys();</span></pre><p id="4233" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">方法<code class="du mf mg mh mi b">JWK.asKey</code>用于从 PEM 格式的字符串中导入密钥。密钥格式可以作为第二个参数传递给该方法，它返回 JWK 格式的密钥作为输出。可以将导入的密钥添加到密钥库中，稍后在加密和解密 JWE 令牌时传递。</p><p id="5b45" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj"> JWE 代样本代码:</strong></p><pre class="lw lx ly lz fd ml mi mm mn aw mo bi"><span id="3091" class="jw jx hi mi b fi mp mq l mr ms">const { JWK, JWE } = require('node-jose');<br/>encrypt = async (raw, format = 'compact', contentAlg = "A256GCM", alg = "RSA-OAEP") =&gt; {<br/>    let _publicKey = `-----BEGIN PUBLIC KEY-----<br/>MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAwiSxcx5xFsNCjfDTOXz0<br/>M6RivgPXTTKb/PH6/x4vYl1xg/vIrG1yDGyFuyAizxNaGtA+qo2CvM3iATyDWQg3<br/>/8vDWiD4cIvUD2WE3XXewjyeGzQso26DceRxopI2tlSgvznjifetGCp+oj4BWrTC<br/>qLF1AsR2ioUS7vuXMlpxXFhJfyEGoWuQaZDwoz7CZv1KrQwlRTtkqtn4IeXpVcgW<br/>hg/1r0iRsvNJDokyiMVY8hrrvza2j31JGaKYqCNYSC8Jf5EV7ONQhYGgQeRVxn8j<br/>S8UhLOFXDdNtgHwKi02tF1bmb3Ko/s3vzPvFB8C7CsYRtHAzcx/xor2/CbT0QGYf<br/>UQIDAQAB<br/>-----END PUBLIC KEY-----`<br/>    let publicKey = await JWK.asKey(_publicKey, "pem");<br/>    const buffer = Buffer.from(JSON.stringify(raw))<br/>    const encrypted = await JWE.createEncrypt({ format: format, contentAlg: contentAlg, fields: { alg: alg } }, publicKey)<br/>        .update(buffer).final();<br/>    return encrypted;<br/>}<br/>let raw = {<br/>    "mobileNumber": "1234567890",<br/>    "customerId": "000000000",<br/>    "sessionId": "3a600342-a7a3-4c66-bbd3-f67de5d7096f",<br/>    "exp": 1645544094,<br/>    "jti": "f3902a08-0e24-4dcc-bed1-f4cd9611bfad"<br/>};<br/>encrypt(raw);</span></pre><p id="79c8" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">JWE 是用加载的公钥加密的，下面一行可以用来解释加密过程。理解加密过程以弄清楚这些参数的用法是很重要的</p><pre class="lw lx ly lz fd ml mi mm mn aw mo bi"><span id="02f1" class="jw jx hi mi b fi mp mq l mr ms">const encrypted = await JWE.createEncrypt({ format: format, contentAlg: contentAlg, fields: { alg: alg } }, publicKey).update(buffer).final()</span></pre><p id="c34a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj"> <em class="jr">格式</em> </strong>:序列化格式，JWE 有两种序列化格式叫做<em class="jr">紧凑序列化</em>和<em class="jr"> JSON 序列化</em>，代表加密的有效载荷。</p><p id="b9d6" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj"> <em class="jr"> contentAlg </em> </strong>:内容加密算法(A256GCM)</p><p id="cb50" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj"> <em class="jr"> alg </em> </strong> : CEK 密钥加密算法(RSA-OAEP)</p></div><div class="ab cl lh li gp lj" role="separator"><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm"/></div><div class="hb hc hd he hf"><h2 id="b5cf" class="jw jx hi bd jy jz ka kb kc kd ke kf kg jb kh ki kj jf kk kl km jj kn ko kp kq bi translated">加密过程:</h2><p id="721b" class="pw-post-body-paragraph iq ir hi is b it kt iv iw ix ku iz ja jb lo jd je jf lp jh ji jj lq jl jm jn hb bi translated"><strong class="is hj"><em class="jr">contentAlg</em></strong>(a 256 GCM)是内容加密算法，是<strong class="is hj"> AES </strong>(高级加密标准<strong class="is hj"><em class="jr"/></strong>)<strong class="is hj">GCM</strong>(伽罗瓦计数器模式)算法，密钥为 256 位。这是一个对称密钥，在大型内容加密中速度更快。<strong class="is hj"> CEK </strong>(内容加密密钥)是由加密有效载荷的库生成的随机 256 位密钥。加密密钥也使用由<strong class="is hj">算法</strong>属性定义的算法加密。</p><p id="c2e4" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">非对称加密使用的<strong class="is hj"><em class="jr">algo</em></strong>(RSA-OAEP)RSA 算法与<strong class="is hj"> OAEP </strong>(最优非对称加密填充)方法。加密的 CEK 也放在 JWE 令牌中，接收者可以用它来解密有效载荷。这种方法称为密钥加密或密钥包装。更多细节可以在<a class="ae jv" href="https://tools.ietf.org/html/draft-ietf-jose-json-web-algorithms-40#section-4.1" rel="noopener ugc nofollow" target="_blank"> RFC </a>中找到</p><p id="2b89" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">上面的代码产生的 JWE 令牌:</strong></p><blockquote class="jo jp jq"><p id="5049" class="iq ir jr is b it iu iv iw ix iy iz ja js jc jd je jt jg jh ji ju jk jl jm jn hb bi translated">eyjhbgcioijsu 0 ett 0 ffucisimvuyyyi 6 ikeyntzhq 00 ilcrawqioijjuhz 0 tfn 3s 29 bmtj 1 aw 9 xc 3 izewhhdwnjwg 12 rvubwnucxk 1 QS 1 ebvzzin 0 . ai 5j 5k 43 skqp lwr 0 Cu 1 ziywotuplfkcn 5 cuzzxhdp 0 exqjylgpj 8 jywu 8 ytu 9 rwzqen 9 ey 0 _ 81 hqhxezmqgfcsrm 0 hxjcew' HRhA5nn8HLsvYf8F-BzQew '</p></blockquote><p id="3506" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">生成的<em class="jr">紧凑序列化</em>令牌由五个 base64 URL 编码部分组成，由句点(.).</p><p id="6923" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">那些是… </strong></p><ol class=""><li id="3f3b" class="kr ks hi is b it iu ix iy jb lr jf ls jj lt jn lu kz la lb bi translated">JOSE header: {"alg":"RSA-OAEP "，" enc":"A256GCM "，" kid ":" gpvtlswkoa 12 uiowsr 3 yhaucixmvdutmct qy5a-DmVs " }</li><li id="2cd2" class="kr ks hi is b it lc ix ld jb le jf lf jj lg jn lu kz la lb bi translated">加密 CEK</li><li id="c3e8" class="kr ks hi is b it lc ix ld jb le jf lf jj lg jn lu kz la lb bi translated">加密有效载荷(CEK)</li><li id="3f14" class="kr ks hi is b it lc ix ld jb le jf lf jj lg jn lu kz la lb bi translated">初始化向量</li><li id="b556" class="kr ks hi is b it lc ix ld jb le jf lf jj lg jn lu kz la lb bi translated">认证标签</li></ol><p id="54d0" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">等价的 JSON 序列化如下图所示。</strong></p><figure class="lw lx ly lz fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mt"><img src="../Images/89dfe813f2e76b48fd03ad36cd7b4bf6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CgZLnu0YM1QUtiOv4K6GUg.png"/></div></div><figcaption class="ma mb et er es mc md bd b be z dx translated">JSON 序列化令牌</figcaption></figure><p id="e17f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">解密和验证:</strong></p><p id="b086" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">示例代码解密并返回来自前面步骤中生成的<em class="jr">紧凑序列化</em> JWE 令牌的纯文本声明。观察如何使用私钥来解密使用公钥加密的令牌。</p><pre class="lw lx ly lz fd ml mi mm mn aw mo bi"><span id="df59" class="jw jx hi mi b fi mp mq l mr ms">const { JWK, JWE, parse } = require('node-jose');<br/>decrypt = async (encryptedBody) =&gt; {<br/>    let _privateKey = `-----BEGIN RSA PRIVATE KEY-----<br/>MIIEowIBAAKCAQEAwiSxcx5xFsNCjfDTOXz0M6RivgPXTTKb/PH6/x4vYl1xg/vI<br/>rG1yDGyFuyAizxNaGtA+qo2CvM3iATyDWQg3/8vDWiD4cIvUD2WE3XXewjyeGzQs<br/>o26DceRxopI2tlSgvznjifetGCp+oj4BWrTCqLF1AsR2ioUS7vuXMlpxXFhJfyEG<br/>oWuQaZDwoz7CZv1KrQwlRTtkqtn4IeXpVcgWhg/1r0iRsvNJDokyiMVY8hrrvza2<br/>j31JGaKYqCNYSC8Jf5EV7ONQhYGgQeRVxn8jS8UhLOFXDdNtgHwKi02tF1bmb3Ko<br/>/s3vzPvFB8C7CsYRtHAzcx/xor2/CbT0QGYfUQIDAQABAoIBADgdoQj0UJ3SvKcI<br/>aBViz7cpmbzwoUfYDAx16SXalLmq5sfOfDeSvvdmWtU2ubj/D/lWHfbwRkzKebv/<br/>wLt4S69tNz8S7pyhXh9BKcFVc5jTKqQUVZ67r9S4wjvKZXQYTApZ8jIL3AVzKv08<br/>TOnp+6YE/RxaqyToyAs5v383czLMdSM9bThDw+IZHfKFcl2iyUI4XVaPLDZPzUlG<br/>MW13ypwFQXbdro9pnMs9v2573WumIVvbiLqIdxK1anag0KbCnCY2hDmoLNv7Mohz<br/>1pFiqEStI6DQsYfEm/geIIL9nLhA8QJ28B9DtLKqRN7oWl2w5BiMEDCrmVK/4niM<br/>lsqF1ZECgYEA5zVsjoJzRCBgZ5dRx9BOu9MKXQ+h00LS3+JaApEzW+QV0DplTvb5<br/>aRUHhTIhUig2WdQVrEiBVXKg9eYmOBXOpX5pgDO5XJ16KcjdHcwMwoYAcUPIT5Y2<br/>tMgoX+jCgTt95cnLKhAnSlH9cCyq+nmcdfDNuvNx8HJO7P33MaVDHCUCgYEA1vXX<br/>cBWM+sGkUxpJNwlgA8bO7xq2kpbM3gqa0z6SKQhxnnmPyoKsZSHdwQMUCKIWBLjU<br/>n27STmXm2SblT1cT39MCED2t0U7N2D1KUQfZkFaN4gImF77iZBWIfDLObAom6JKg<br/>gER0glakAjbDMKq90mVzrKrR6XsD3az+AJE1eL0CgYBbHKB04E9QD3ouGGFv3lTI<br/>i3fQCHL676Bt/aL+0/1rPsyhzAFURtsuX80g3gpnd9VDPOJ1i/T7mTp47IMvItjW<br/>OqSUks1/A8e6Y59POLPmjCvsdoufYVCZmS7f7LeJeco5HXZkUw1Iqlq3M8MFBZt0<br/>lrpb68eAu2sC1WnuNHPnyQKBgQC1LFb7vO4pmnOpJwp2PIyUIkfe9qDSRA8/Rajg<br/>Smhd9SPt8X7jq+cpBbYlKzcDX7k3GaD7DyhpszEx7LpweG/jwbCHh7SsKMMNcfrk<br/>+LzCDnFe/3ijotqkiBGUvC2GmbfZZVupQAkCoYtx4j35Eq8SWTd5XC+3nVrQxzD9<br/>wWVT8QKBgBylVSsVeU7H/RT3RZ/qgWnpllBzGJic8X6lfyTHVD/9dO9XMzuD7R+/<br/>VFc9Ib71QPzyq39BX+YiCI+xwDGARgO3GGA4vxvF46Tq0rYUpZ1LiC4raO4I5xrl<br/>NxZCLVlhLWU27FR7xu8YN18mRCCwz1FCcsEtNU4nrBK2IIIwGLCf<br/>-----END RSA PRIVATE KEY-----`;</span><span id="8d74" class="jw jx hi mi b fi mu mq l mr ms">    let keystore = JWK.createKeyStore();<br/>    await keystore.add(await JWK.asKey(_privateKey, "pem"));<br/>    let outPut = parse.compact(encryptedBody);<br/>    let decryptedVal = await outPut.perform(keystore);<br/>    let claims = Buffer.from(decryptedVal.plaintext).toString();<br/>    return claims;<br/>}</span><span id="95a8" class="jw jx hi mi b fi mu mq l mr ms">decrypt('eyJhbGciOiJSU0EtT0FFUCIsImVuYyI6IkEyNTZHQ00iLCJraWQiOiJHUHZ0TFN3S29BMTJ1aW9Xc3IzeWhhdWNJWG12RHVUbWNUcXk1QS1EbVZzIn0.ai5j5Kk43skqPLwR0Cu1ZIyWOTUpLFKCN5cuZzxHdp0eXQjYLGpj8jYvU8yTu9rwZQeN9EY0_81hQHXEzMQgfCsRm0HXjcEwXIny-FH8N2WtYCjWrQubAIbnrqnNP-8TeCNZaShEMwYcVLUls8Yik2s6LiHTb9FTNfbMxyBlaQ4v8Q2rnKQ4tto5IG7D_dRC59WDmN2XkVfw3DWNbOxb34wgKHq0Zb7YcflQyXYxqkOAU9Xeuv_urFAhUyCzHt8W2vbqUtSosmHGoLf64QKUwqKietOVEI8tAruj-JTHUTR4P_-ZHy9jEgTNQLfZlkBDEDnXme2tcYqHj9XiidiXpw.thh69dp0Pz73kycQ.eF5bjuqtF60gW8O8cXKiYyDsBPX8OL0GQfhOxwGWUmYtHOds7FJWTNoSFnv5E6A_Bgn_2W2JUD1kniYUR1yOPnEJfHQ_SXMLJECZ8mBpHlYZWl3-39nGESxfdx1oXP1pO_ahP9eWtBCeS3X8DgPV0sLu1N-0ox6iZxTQ_PU314yTiUobhemNfT9ORghnOSApHi_HCKk9G1ABklbP82flcBfzA1tWKBw.HRhA5nn8HLsvYf8F-BzQew');</span></pre><h2 id="31fd" class="jw jx hi bd jy jz ka kb kc kd ke kf kg jb kh ki kj jf kk kl km jj kn ko kp kq bi translated">结论</h2><p id="a8c7" class="pw-post-body-paragraph iq ir hi is b it kt iv iw ix ku iz ja jb lo jd je jf lp jh ji jj lq jl jm jn hb bi translated">这篇文章解释了 JWT 的基本知识，主要是 JWE 如何工作。添加的代码示例有硬编码的密钥和证书，主要是为了解释事情是如何工作的。不建议在代码中硬编码敏感信息，请采取必要的措施，如 KMS 或保险库来存储和访问密钥/证书。</p></div></div>    
</body>
</html>