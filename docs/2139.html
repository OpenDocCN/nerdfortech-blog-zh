<html>
<head>
<title>Intro to Apache Beam</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Apache Beam 简介</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/intro-to-apache-beam-496ae64662f5?source=collection_archive---------8-----------------------#2021-04-23">https://medium.com/nerd-for-tech/intro-to-apache-beam-496ae64662f5?source=collection_archive---------8-----------------------#2021-04-23</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/cb6965964a7f0d59f5df627d1bc26851.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VAwKTeTijbai6Z5DUj0GBQ.png"/></div></div></figure><p id="8862" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">Apache beam 是一个开源数据处理工具，它为批处理和流式数据管道提供了统一的模型。</p><p id="6a3c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">Beam 对于并行数据处理任务非常有用，在并行数据处理任务中，问题可以分解为许多更小的数据束，这些数据束可以独立地并行处理。它也可以用于 ETL 任务。</p><p id="6afc" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">Apache beam 构建于 Scala 之上，但它支持 Java、Python 和 GO SDKs。beam SDKs 提供了统一的编程模型，可用于有界(批处理)或无界(流)数据集。</p><p id="f365" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">使用一个开源的 Beam SDKs，我们可以构建一个定义管道的程序。然后这个管道被 Beam runners 翻译成与我们选择的<strong class="is hj">分布式处理后端</strong>兼容的 API。</p><p id="2206" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">Beam 目前支持 Direct runner、Apache Flink runner、Apache Spark runner、Google Cloud Data Flow runner、Apache Nemo runner、Apache Samza runner、Hazlecast Jet runner 和 Twister2 runner。</p><p id="ae61" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">Direct runner 用于本地测试和调试目的。</p><h1 id="3f58" class="jo jp hi bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">阿帕奇波束的组成部分</h1><figure class="kn ko kp kq fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es km"><img src="../Images/d4911a9aee924972e1be80f3a437f456.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AS9GnhNCmU74g5FEaITxqw.png"/></div></div></figure><ul class=""><li id="9a3c" class="kr ks hi is b it iu ix iy jb kt jf ku jj kv jn kw kx ky kz bi translated"><strong class="is hj">p 集合</strong> —表示一个数据集，可以是固定的批处理或流数据。</li><li id="ea4d" class="kr ks hi is b it la ix lb jb lc jf ld jj le jn kw kx ky kz bi translated"><strong class="is hj"> PTransform </strong> —采用一个或多个 p collection 并输出零个或多个 p collection 的数据处理操作。</li><li id="db97" class="kr ks hi is b it la ix lb jb lc jf ld jj le jn kw kx ky kz bi translated"><strong class="is hj"> Pipeline </strong> —表示 PCollection 和 Transform 的有向无环图，因此封装了整个数据处理作业。</li><li id="dce2" class="kr ks hi is b it la ix lb jb lc jf ld jj le jn kw kx ky kz bi translated"><strong class="is hj"> I/O 转换</strong> —读取或写入数据的 p 转换。</li></ul><h1 id="453a" class="jo jp hi bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">beam 是如何工作的？</h1><ul class=""><li id="b103" class="kr ks hi is b it lf ix lg jb lh jf li jj lj jn kw kx ky kz bi translated">创建一个<strong class="is hj">管道</strong>对象并设置管道执行选项，包括管道运行器。</li><li id="20cb" class="kr ks hi is b it la ix lb jb lc jf ld jj le jn kw kx ky kz bi translated">为管道数据创建一个初始的<strong class="is hj">p 集合</strong>。</li><li id="8527" class="kr ks hi is b it la ix lb jb lc jf ld jj le jn kw kx ky kz bi translated">将<strong class="is hj">p 变换</strong>应用于每个 p 集合</li><li id="425d" class="kr ks hi is b it la ix lb jb lc jf ld jj le jn kw kx ky kz bi translated">使用<strong class="is hj"> IOs </strong>将最终转换的 PCollection 写入外部源。</li><li id="fea6" class="kr ks hi is b it la ix lb jb lc jf ld jj le jn kw kx ky kz bi translated">使用指定的管道运行器运行管道。</li></ul><h1 id="746d" class="jo jp hi bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">示例 python 代码</h1><p id="c95c" class="pw-post-body-paragraph iq ir hi is b it lf iv iw ix lg iz ja jb lk jd je jf ll jh ji jj lm jl jm jn hb bi translated">下面是计算文本字数的 python 代码示例。</p><pre class="kn ko kp kq fd ln lo lp lq aw lr bi"><span id="e3d8" class="ls jp hi lo b fi lt lu l lv lw">with beam.Pipeline(options=PipelineOptions()) as p:</span><span id="c098" class="ls jp hi lo b fi lx lu l lv lw">file = '../data/kinglear.txt'</span><span id="cac2" class="ls jp hi lo b fi lx lu l lv lw">output_file = '../data/output.txt'</span><span id="50ec" class="ls jp hi lo b fi lx lu l lv lw"># Read the text file[pattern] into a PCollection.</span><span id="77db" class="ls jp hi lo b fi lx lu l lv lw">lines = p | 'Read' &gt;&gt; ReadFromText(file)</span><span id="6155" class="ls jp hi lo b fi lx lu l lv lw">split_lines = lines | 'Split' &gt;&gt; beam.FlatMap(lambda x: re.findall(r'[A-Za-z\']+', x))</span><span id="e9ce" class="ls jp hi lo b fi lx lu l lv lw">counts = split_lines | 'PairWithOne' &gt;&gt; beam.Map(lambda x: (x, 1)) | beam.CombinePerKey(sum)</span><span id="0aeb" class="ls jp hi lo b fi lx lu l lv lw">output = counts | 'Format' &gt;&gt; beam.MapTuple(format_result)</span><span id="f7ad" class="ls jp hi lo b fi lx lu l lv lw"># Write the output using a "Write" transform that has side effects.</span><span id="6eb5" class="ls jp hi lo b fi lx lu l lv lw"># pylint: disable=expression-not-assigned</span><span id="79b6" class="ls jp hi lo b fi lx lu l lv lw">output | 'Write' &gt;&gt; WriteToText(output_file)</span></pre><ol class=""><li id="80d1" class="kr ks hi is b it iu ix iy jb kt jf ku jj kv jn ly kx ky kz bi translated">我们首先使用管道选项创建管道，并且从头到尾的所有代码都包含在其中。</li></ol><pre class="kn ko kp kq fd ln lo lp lq aw lr bi"><span id="32b4" class="ls jp hi lo b fi lt lu l lv lw">with beam.Pipeline(options=PipelineOptions()) as p:</span></pre><p id="566e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如果没有提到流道，则默认选择直接流道。</p><p id="80e0" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">2.接下来，我们读取输入文件并创建<code class="du lz ma mb lo b">lines</code> PCollection。</p><pre class="kn ko kp kq fd ln lo lp lq aw lr bi"><span id="4f8c" class="ls jp hi lo b fi lt lu l lv lw">lines = p | 'Read' &gt;&gt; ReadFromText(file)</span></pre><p id="3880" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">3.这个转换拆分了<code class="du lz ma mb lo b">PCollection&lt;String&gt;</code>中的行，其中每个元素都是文本中的一个单词。</p><pre class="kn ko kp kq fd ln lo lp lq aw lr bi"><span id="7634" class="ls jp hi lo b fi lt lu l lv lw">split_lines = lines | 'Split' &gt;&gt; beam.FlatMap(lambda x: re.findall(r'[A-Za-z\']+', x))</span></pre><p id="29c6" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">4.接下来，应用两个转换，一个合并每个单词，另一个计算每个键的每个单词。</p><pre class="kn ko kp kq fd ln lo lp lq aw lr bi"><span id="df98" class="ls jp hi lo b fi lt lu l lv lw">counts = split_lines | 'PairWithOne' &gt;&gt; beam.Map(lambda x: (x, 1)) | beam.CombinePerKey(sum)</span></pre><p id="19d9" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">5.最后，我们执行 IO 转换，获取单词元组及其计数并存储在输出文本中。</p><pre class="kn ko kp kq fd ln lo lp lq aw lr bi"><span id="f207" class="ls jp hi lo b fi lt lu l lv lw">output | 'Write' &gt;&gt; WriteToText(output_file)</span></pre><p id="9a46" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">输出文件将在目标路径中可用。</p><h1 id="6cb0" class="jo jp hi bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">光束的优点</h1><ul class=""><li id="3ad2" class="kr ks hi is b it lf ix lg jb lh jf li jj lj jn kw kx ky kz bi translated">在单个 API 下统一批处理和流式 API——通过最少的代码更改，我们使相同的代码适用于流式和批处理数据管道。</li><li id="28ee" class="kr ks hi is b it la ix lb jb lc jf ld jj le jn kw kx ky kz bi translated">跨运行时的可移植性——最初，如果 beam 任务在 Spark runner 中运行，那么切换到 Google Data Flow runner 非常简单。</li><li id="ec6e" class="kr ks hi is b it la ix lb jb lc jf ld jj le jn kw kx ky kz bi translated">提高抽象层次的 APIs 关注我们的逻辑而不是底层细节。</li></ul><p id="e64a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">GitHub 上的<a class="ae mc" href="https://github.com/Shari18/beam_tutorialhttps://github.com/Shari18/beam_tutorial" rel="noopener ugc nofollow" target="_blank">提供了这方面的代码。</a></p><p id="e4d6" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><em class="md">快乐学习！。</em></p></div></div>    
</body>
</html>