<html>
<head>
<title>Java Virtual Machine (JVM) Architecture Explained for Beginners</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">为初学者解释的 Java 虚拟机(JVM)架构</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/jvm-java-virtual-machine-architecture-explained-for-beginners-776eea4215ab?source=collection_archive---------2-----------------------#2021-05-08">https://medium.com/nerd-for-tech/jvm-java-virtual-machine-architecture-explained-for-beginners-776eea4215ab?source=collection_archive---------2-----------------------#2021-05-08</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/6b518efad346d07c3ff6fcfde00b4cad.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*of1uMQIg96n7ni6fSteimw.jpeg"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">图片:signifytechnology.com</figcaption></figure><p id="a5fb" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">作为一名 Java 开发人员，理解 Java 虚拟机(JVM)架构以及 Java 如何高效地发挥其最大作用非常重要。看完这篇文章你会对 JVM 有一个基本的了解。</p><h1 id="9448" class="js jt hi bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">Java 是什么？</h1><p id="4d52" class="pw-post-body-paragraph iu iv hi iw b ix kq iz ja jb kr jd je jf ks jh ji jj kt jl jm jn ku jp jq jr hb bi translated">Java 是一种跨平台面向对象的编程语言，由太阳微系统公司于 1995 年发布。现在，Java 应用于各个领域，如 Android 应用程序、Java Web 应用程序、交易应用程序、大数据技术等等。</p><p id="4cb9" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">它首先将源代码编译成字节码。然后在 Java 虚拟机(JVM)中，将字节码编译成机器码。</p><figure class="kw kx ky kz fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es kv"><img src="../Images/4330e51fab08b6e497ff6d69388e3560.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LuKOZMDCX8e1zDyGyMUu_w.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">Java 架构(图片:javacodemonk.com)</figcaption></figure><p id="257a" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">JAVA 架构包括上图中提到的 3 个主要组件，</p><ul class=""><li id="a9ab" class="la lb hi iw b ix iy jb jc jf lc jj ld jn le jr lf lg lh li bi translated">Java 开发工具包(JDK)</li><li id="ced4" class="la lb hi iw b ix lj jb lk jf ll jj lm jn ln jr lf lg lh li bi translated">Java 运行时环境</li><li id="fc8a" class="la lb hi iw b ix lj jb lk jf ll jj lm jn ln jr lf lg lh li bi translated">Java 虚拟机(JVM)</li></ul><h2 id="1edb" class="lo jt hi bd ju lp lq lr jy ls lt lu kc jf lv lw kg jj lx ly kk jn lz ma ko mb bi translated"><strong class="ak"> Java 开发工具包(JDK) </strong></h2><p id="e8b2" class="pw-post-body-paragraph iu iv hi iw b ix kq iz ja jb kr jd je jf ks jh ji jj kt jl jm jn ku jp jq jr hb bi translated">它是一个用于开发 java 应用程序的软件开发环境。包含 JRE 和 javac、jheap、jconsole 等开发工具。</p><h2 id="d56f" class="lo jt hi bd ju lp lq lr jy ls lt lu kc jf lv lw kg jj lx ly kk jn lz ma ko mb bi translated">Java 运行时环境</h2><p id="6276" class="pw-post-body-paragraph iu iv hi iw b ix kq iz ja jb kr jd je jf ks jh ji jj kt jl jm jn ku jp jq jr hb bi translated">JRE 是 JDK 的一部分，它构建了一个可以执行 Java 程序的运行时环境。它包含 Java 程序运行所需的库和软件。它获取 Java 代码并与所需的库集成，然后启动 JVM 来执行它。基于操作系统，JRE 将部署 JVM 的相关代码。</p></div><div class="ab cl mc md gp me" role="separator"><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh"/></div><div class="hb hc hd he hf"><h2 id="ae5c" class="lo jt hi bd ju lp lq lr jy ls lt lu kc jf lv lw kg jj lx ly kk jn lz ma ko mb bi translated">Java 虚拟机(JVM)</h2><figure class="kw kx ky kz fd ij er es paragraph-image"><div class="er es mj"><img src="../Images/4aa4a12467a2aa8529de20ec632e7ed0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1002/format:webp/1*GTYEv9dEQU9hNv-3C2HPJg.jpeg"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">虚拟机的类型</figcaption></figure><p id="db55" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">在进入 JVM 之前，我们先来看看 VM(虚拟机)。基本上，在物理硬件系统上，虚拟机(VM)是一个虚拟环境，充当虚拟操作系统，拥有自己的 CPU、内存、网络接口和存储。VM 中主要有两个类别，如上图所示，</p><ol class=""><li id="848c" class="la lb hi iw b ix iy jb jc jf lc jj ld jn le jr mk lg lh li bi translated">基于系统的虚拟机(SVM)</li></ol><ul class=""><li id="42d7" class="la lb hi iw b ix iy jb jc jf lc jj ld jn le jr lf lg lh li bi translated">它是一个系统平台，允许共享主机的物理资源，同时各自运行自己的操作系统副本。</li></ul><p id="5091" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">2.基于应用程序的虚拟机(AVM)或基于流程的虚拟机</p><ul class=""><li id="8db6" class="la lb hi iw b ix iy jb jc jf lc jj ld jn le jr lf lg lh li bi translated">在这里，它将允许在主机上作为应用程序运行单个进程。</li></ul><h1 id="1415" class="js jt hi bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">JVM 是什么？</h1><p id="91ea" class="pw-post-body-paragraph iu iv hi iw b ix kq iz ja jb kr jd je jf ks jh ji jj kt jl jm jn ku jp jq jr hb bi translated">它是一个引擎，提供运行 Java 应用程序的运行时环境，是 JRE 的一部分。我们都知道像<strong class="iw hj"> C/C++ </strong>这样的编程语言被称为<strong class="iw hj">编译语言</strong>是因为在这里，代码首先被编译成机器码。当我们谈到像<strong class="iw hj"> JavaScript </strong>和<strong class="iw hj"> Python </strong>这样的语言时，系统执行指令而不编译，所以这些被称为<strong class="iw hj">解释语言。</strong></p><p id="eb48" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">但是在 Java 中，使用两者的组合(编译器和解释器)。源代码(<code class="du ml mm mn mo b">.java</code>文件)先编译成字节码，生成一个类文件(<code class="du ml mm mn mo b">.class </code>文件)。然后 JVM 将编译好的二进制字节码转换成特定的机器语言。最终，JVM 是一个软件程序的<strong class="iw hj">规范</strong>，它执行代码并为代码提供运行时环境。</p><p id="7865" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">例如，考虑有一个名为“<strong class="iw hj"><em class="mp">【Test.java】</em></strong>”的 Java 文件。为了编译这个源代码文件，我们需要使用下面的命令。</p><pre class="kw kx ky kz fd mq mo mr ms aw mt bi"><span id="dddc" class="lo jt hi mo b fi mu mv l mw mx">javac Test.java</span></pre><p id="76b3" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">这里，当在命令提示符中调用“<strong class="iw hj"> javac </strong>”时，它将读取 java 代码，然后编译成字节码类文件。所以要运行这段代码，我们需要使用如下带有关键字“<strong class="iw hj"> java </strong>”的类名。</p><pre class="kw kx ky kz fd mq mo mr ms aw mt bi"><span id="e8f8" class="lo jt hi mo b fi mu mv l mw mx">java Test</span></pre><p id="97bc" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">当“<strong class="iw hj"> java </strong>关键字被调用时，它会请求操作系统创建一个 JVM 实例(<strong class="iw hj">类应该是</strong><code class="du ml mm mn mo b"><strong class="iw hj">public</strong></code><strong class="iw hj"/><code class="du ml mm mn mo b"><strong class="iw hj">void</strong></code>)并在 JVM 中，进入各个步骤，最后在执行引擎中，字节码会被编译成机器码。</p><p id="b9eb" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">对于每个程序，将有一个 JVM 实例将被创建。所以当程序结束时，JVM 实例将被销毁。与此同时，JVM 将创建一个非守护进程(用户线程)线程来执行 java 应用程序。</p><p id="9912" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">JVM 将在两种情况下被销毁，例如:</p><ol class=""><li id="a158" class="la lb hi iw b ix iy jb jc jf lc jj ld jn le jr mk lg lh li bi translated">如果没有运行非守护线程。此时，JVM 将强制终止所有活动的守护进程线程。</li><li id="5375" class="la lb hi iw b ix lj jb lk jf ll jj lm jn ln jr mk lg lh li bi translated">如果 Java app 杀了自己(通过调用 System.exit()方法)。</li></ol><p id="f656" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">而且很明显，JVM 一旦崩溃就会被摧毁。</p><h1 id="765c" class="js jt hi bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">JVM 架构</h1><figure class="kw kx ky kz fd ij er es paragraph-image"><div class="er es my"><img src="../Images/67b560a43ec38b8bf609ed7326af8965.png" data-original-src="https://miro.medium.com/v2/resize:fit:1338/format:webp/1*d3iiqc2AFfphG-fN4Xictg.png"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">JVM 架构图(图片:dzone.com)</figcaption></figure><p id="c8b8" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">JVM 中主要有三个子系统，如上图所示，</p><ol class=""><li id="8760" class="la lb hi iw b ix iy jb jc jf lc jj ld jn le jr mk lg lh li bi translated">类加载器</li><li id="3369" class="la lb hi iw b ix lj jb lk jf ll jj lm jn ln jr mk lg lh li bi translated">运行时内存/数据区</li><li id="5f3e" class="la lb hi iw b ix lj jb lk jf ll jj lm jn ln jr mk lg lh li bi translated">执行引擎</li></ol><h1 id="8af6" class="js jt hi bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">类加载器</h1><p id="f803" class="pw-post-body-paragraph iu iv hi iw b ix kq iz ja jb kr jd je jf ks jh ji jj kt jl jm jn ku jp jq jr hb bi translated">这个组件负责将类文件放到 RAM 中，因为 JVM 驻留在 RAM 中，它执行三个功能，比如加载、链接和初始化。</p><h1 id="34d1" class="js jt hi bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">装货</h1><p id="653f" class="pw-post-body-paragraph iu iv hi iw b ix kq iz ja jb kr jd je jf ks jh ji jj kt jl jm jn ku jp jq jr hb bi translated">这个过程通常从加载主类开始(使用<code class="du ml mm mn mo b">main()</code>方法的类)。ClassLoader 读取<code class="du ml mm mn mo b">.class</code>文件，然后 JVM 在方法区域存储以下信息。</p><ul class=""><li id="93c9" class="la lb hi iw b ix iy jb jc jf lc jj ld jn le jr lf lg lh li bi translated">加载的类的完全限定名</li><li id="5cad" class="la lb hi iw b ix lj jb lk jf ll jj lm jn ln jr lf lg lh li bi translated">可变信息</li><li id="0dc1" class="la lb hi iw b ix lj jb lk jf ll jj lm jn ln jr lf lg lh li bi translated">直接父信息</li><li id="08b4" class="la lb hi iw b ix lj jb lk jf ll jj lm jn ln jr lf lg lh li bi translated">无论是类、接口还是枚举</li></ul><blockquote class="mz na nb"><p id="b82b" class="iu iv mp iw b ix iy iz ja jb jc jd je nc jg jh ji nd jk jl jm ne jo jp jq jr hb bi translated">注意——JVM 第一次从一个<strong class="iw hj">类</strong>类型的对象为每个加载的 java 类创建一个对象，并将该对象存储在堆中。</p></blockquote><p id="06af" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">JVM 中的三个主要的类装入器，</p><ol class=""><li id="db1a" class="la lb hi iw b ix iy jb jc jf lc jj ld jn le jr mk lg lh li bi translated"><strong class="iw hj">引导类加载器— </strong>这是根类加载器，是扩展类加载器的超类。这将加载位于<code class="du ml mm mn mo b">rt.jar</code>文件和一些其他核心库内的标准 java 包。</li><li id="a3e5" class="la lb hi iw b ix lj jb lk jf ll jj lm jn ln jr mk lg lh li bi translated"><strong class="iw hj">扩展类加载器— </strong>这是引导类加载器的子类，也是应用类加载器的超类。这负责加载目录中存在的类(<code class="du ml mm mn mo b">jre/lib/ext</code>)</li><li id="e4db" class="la lb hi iw b ix lj jb lk jf ll jj lm jn ln jr mk lg lh li bi translated"><strong class="iw hj">应用程序类加载器— </strong>这是扩展类加载器的子类，负责从类路径加载类文件(类路径可以通过添加<code class="du ml mm mn mo b">-classpath </code>命令行选项来修改)</li></ol><p id="dd60" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw hj">JVM 中的四个主要原则，</strong></p><ol class=""><li id="cff6" class="la lb hi iw b ix iy jb jc jf lc jj ld jn le jr mk lg lh li bi translated"><strong class="iw hj">可见性原则— </strong>这个原则规定子类的类加载器可以看到父类加载的类，但是父类的类加载器却找不到子类加载的类。</li><li id="55f5" class="la lb hi iw b ix lj jb lk jf ll jj lm jn ln jr mk lg lh li bi translated"><strong class="iw hj">唯一性原则— </strong>这个原则声明由父类装入器装入的类不应该被子类再次装入。这确保了没有重复的类。</li><li id="2fcd" class="la lb hi iw b ix lj jb lk jf ll jj lm jn ln jr mk lg lh li bi translated"><strong class="iw hj">委托层次原则— </strong>该规则规定 JVM 遵循委托层次来为每个类加载请求选择类加载器。这里，从最低的子级开始，应用程序类加载器将收到的类加载请求委托给扩展类加载器，然后扩展类加载器将请求委托给引导程序类加载器。如果在引导路径中找到请求的类，则加载该类。否则，请求会再次传输回扩展类加载器级别，从扩展路径或自定义路径中查找类。如果它也失败了，请求返回到应用程序类加载器，从系统类路径中查找类，如果应用程序类加载器也未能加载所请求的类，那么我们得到运行时异常— <code class="du ml mm mn mo b">ClassNotFoundException</code>。</li><li id="e617" class="la lb hi iw b ix lj jb lk jf ll jj lm jn ln jr mk lg lh li bi translated"><strong class="iw hj">无卸载原则— </strong>这表明类装入器不能卸载一个类，即使它可以装入一个类。可以通过删除现有的类加载器来创建新的类加载器，而不是卸载。</li></ol><h1 id="2750" class="js jt hi bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">连接</h1><p id="3e2d" class="pw-post-body-paragraph iu iv hi iw b ix kq iz ja jb kr jd je jf ks jh ji jj kt jl jm jn ku jp jq jr hb bi translated">这个过程可以分为三个主要部分，它们是:</p><h2 id="5368" class="lo jt hi bd ju lp lq lr jy ls lt lu kc jf lv lw kg jj lx ly kk jn lz ma ko mb bi translated">1.确认</h2><p id="ea45" class="pw-post-body-paragraph iu iv hi iw b ix kq iz ja jb kr jd je jf ks jh ji jj kt jl jm jn ku jp jq jr hb bi translated">这个阶段检查<code class="du ml mm mn mo b">.class</code>文件的正确性。字节码检验器将检查以下内容:</p><ul class=""><li id="fb1e" class="la lb hi iw b ix iy jb jc jf lc jj ld jn le jr lf lg lh li bi translated">无论它是否来自有效的编译器(因为任何人都可以创建自己的编译器)。</li><li id="0bab" class="la lb hi iw b ix lj jb lk jf ll jj lm jn ln jr lf lg lh li bi translated">代码是否具有正确的结构和格式。</li></ul><p id="3cd9" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">如果缺少其中任何一个，JVM 将抛出一个名为“<code class="du ml mm mn mo b">java.lang.VerifyError</code>”的运行时异常。如果没有，那么将进行准备过程。</p><h2 id="95fd" class="lo jt hi bd ju lp lq lr jy ls lt lu kc jf lv lw kg jj lx ly kk jn lz ma ko mb bi translated">2.准备</h2><p id="62f2" class="pw-post-body-paragraph iu iv hi iw b ix kq iz ja jb kr jd je jf ks jh ji jj kt jl jm jn ku jp jq jr hb bi translated">在这一阶段，对于所有静态变量，将根据数据类型分配内存并赋予默认值。</p><blockquote class="nf"><p id="fafe" class="ng nh hi bd ni nj nk nl nm nn no jr dx translated">object-null<br/>int-0<br/>boolean-false</p></blockquote><p id="e0f9" class="pw-post-body-paragraph iu iv hi iw b ix np iz ja jb nq jd je jf nr jh ji jj ns jl jm jn nt jp jq jr hb bi translated">例如，让我们考虑下面的代码行，</p><pre class="kw kx ky kz fd mq mo mr ms aw mt bi"><span id="fcf5" class="lo jt hi mo b fi mu mv l mw mx">boolean status=true;</span></pre><p id="cfc6" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">所以在这个阶段，它将检查布尔类型的代码和变量状态，因此 JVM 将 false 赋给该变量。(如上所述，布尔值的默认值为 false)</p><h2 id="8c49" class="lo jt hi bd ju lp lq lr jy ls lt lu kc jf lv lw kg jj lx ly kk jn lz ma ko mb bi translated">3.解决</h2><p id="725f" class="pw-post-body-paragraph iu iv hi iw b ix kq iz ja jb kr jd je jf ks jh ji jj kt jl jm jn ku jp jq jr hb bi translated">这是用直接引用替换符号引用的过程，它是通过搜索方法区域来定位被引用的实体来完成的。机器不理解我们给创建对象起的名字。因此 JVM 将通过用直接链接替换它们的符号链接来为这些对象分配内存位置。</p><h1 id="2a7d" class="js jt hi bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">初始化</h1><p id="5195" class="pw-post-body-paragraph iu iv hi iw b ix kq iz ja jb kr jd je jf ks jh ji jj kt jl jm jn ku jp jq jr hb bi translated">在这个阶段，原始值将被赋回代码中提到的静态变量，一个静态块将被执行(在 any 中)。在一个类中从上到下执行，在类层次结构中从父级到子级执行。最重要的是，JVM 有一条规则，规定初始化过程必须在<strong class="iw hj"> </strong>类成为<strong class="iw hj">活动使用之前完成。</strong></p><p id="7e31" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">主动使用的一类有，<br/> 1。使用<code class="du ml mm mn mo b">new</code>关键字。(例如:<code class="du ml mm mn mo b">Vehicle van=new Vehicle();</code>)。</p><p id="d179" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">2.调用静态方法。</p><p id="d991" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">3.给静态字段赋值。</p><p id="357e" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">4.如果一个类是初始类(用<code class="du ml mm mn mo b">main()</code>方法的类)。</p><p id="14e4" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">5.使用反射 API ( <code class="du ml mm mn mo b">getInstance()</code>方法)。</p><p id="3306" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">6.从当前类初始化子类。</p><p id="8f5d" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">有四种初始化类的方法，</p><ol class=""><li id="b196" class="la lb hi iw b ix iy jb jc jf lc jj ld jn le jr mk lg lh li bi translated">使用<code class="du ml mm mn mo b">new</code>关键字—这将经历初始化过程。</li><li id="1b3c" class="la lb hi iw b ix lj jb lk jf ll jj lm jn ln jr mk lg lh li bi translated">使用<code class="du ml mm mn mo b">clone();</code>方法——这将从父对象(源对象)获取信息。</li><li id="6861" class="la lb hi iw b ix lj jb lk jf ll jj lm jn ln jr mk lg lh li bi translated">使用反射 API(getInstance())；)—这将经历初始化过程。</li><li id="f03e" class="la lb hi iw b ix lj jb lk jf ll jj lm jn ln jr mk lg lh li bi translated">使用 IO。ObjectInputStream()；—这将把来自 InputStream 的初始值分配给所有非瞬态变量</li></ol></div><div class="ab cl mc md gp me" role="separator"><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh"/></div><div class="hb hc hd he hf"><h1 id="bb5c" class="js jt hi bd ju jv nu jx jy jz nv kb kc kd nw kf kg kh nx kj kk kl ny kn ko kp bi translated">运行时数据区</h1><p id="cac2" class="pw-post-body-paragraph iu iv hi iw b ix kq iz ja jb kr jd je jf ks jh ji jj kt jl jm jn ku jp jq jr hb bi translated">JVM 内存基本上分为以下五个部分:</p><figure class="kw kx ky kz fd ij er es paragraph-image"><div class="er es nz"><img src="../Images/1dcce692d28a9d209785abc45fee4db1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1262/format:webp/1*K_zR8z8HOs9elY5cE7JHrQ.jpeg"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">存储区</figcaption></figure><h2 id="c19d" class="lo jt hi bd ju lp lq lr jy ls lt lu kc jf lv lw kg jj lx ly kk jn lz ma ko mb bi translated">方法区域</h2><p id="cf77" class="pw-post-body-paragraph iu iv hi iw b ix kq iz ja jb kr jd je jf ks jh ji jj kt jl jm jn ku jp jq jr hb bi translated">这是在代码执行期间存储类数据的地方，它保存静态变量、静态方法、静态块、实例方法、类名和直接父类名(如果有的话)的信息。这是共享资源。</p><h2 id="633f" class="lo jt hi bd ju lp lq lr jy ls lt lu kc jf lv lw kg jj lx ly kk jn lz ma ko mb bi translated">堆区域</h2><p id="52e4" class="pw-post-body-paragraph iu iv hi iw b ix kq iz ja jb kr jd je jf ks jh ji jj kt jl jm jn ku jp jq jr hb bi translated">这是存储所有对象信息的地方，它是一个共享资源，就像方法区域一样。</p><p id="2e0c" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">让我们以下面的代码示例为例，</p><pre class="kw kx ky kz fd mq mo mr ms aw mt bi"><span id="5441" class="lo jt hi mo b fi mu mv l mw mx">Book book = new Book();</span></pre><p id="7388" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">所以在这里，有一个<code class="du ml mm mn mo b">Book</code>的实例被创建，它将被加载到堆区域。</p><blockquote class="mz na nb"><p id="a738" class="iu iv mp iw b ix iy iz ja jb jc jd je nc jg jh ji nd jk jl jm ne jo jp jq jr hb bi translated">注意——每个 JVM 只有一个方法区域和一个堆区域。</p></blockquote><h2 id="4101" class="lo jt hi bd ju lp lq lr jy ls lt lu kc jf lv lw kg jj lx ly kk jn lz ma ko mb bi translated">堆栈区</h2><p id="eb54" class="pw-post-body-paragraph iu iv hi iw b ix kq iz ja jb kr jd je jf ks jh ji jj kt jl jm jn ku jp jq jr hb bi translated">所有的局部变量、方法调用和程序的部分结果(不是本地方法)都存储在堆栈区域。对于每个线程，将创建一个运行时堆栈。堆栈区的一块被称为“<strong class="iw hj">堆栈帧</strong>，它保存方法调用的局部变量。因此，只要方法调用完成，框架就会被移除(POP)。因为这是一个堆栈，所以它使用了后进先出的结构。</p><h2 id="4720" class="lo jt hi bd ju lp lq lr jy ls lt lu kc jf lv lw kg jj lx ly kk jn lz ma ko mb bi translated">PC 寄存器(程序计数器寄存器)</h2><p id="67bc" class="pw-post-body-paragraph iu iv hi iw b ix kq iz ja jb kr jd je jf ks jh ji jj kt jl jm jn ku jp jq jr hb bi translated">这将保存线程的执行信息。每个线程都有自己的 PC 寄存器来保存当前执行信息的地址，一旦当前执行完成，它将在下一次执行时更新。</p><h2 id="78f7" class="lo jt hi bd ju lp lq lr jy ls lt lu kc jf lv lw kg jj lx ly kk jn lz ma ko mb bi translated">本机方法区域</h2><p id="be99" class="pw-post-body-paragraph iu iv hi iw b ix kq iz ja jb kr jd je jf ks jh ji jj kt jl jm jn ku jp jq jr hb bi translated">这将保存关于本地方法的信息，这些方法是用 Java 以外的语言编写的，比如 C/C++。就像堆栈和 PC 寄存器一样，将为每个新线程创建一个单独的本机方法堆栈。</p><p id="9063" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">请看下图，</p><figure class="kw kx ky kz fd ij er es paragraph-image"><div class="er es oa"><img src="../Images/dd5ec2a4bdc98a1f12bdcfd670ca99b0.png" data-original-src="https://miro.medium.com/v2/resize:fit:922/format:webp/1*R7X5-D9-LxRTtegdrVqS1g.jpeg"/></div></figure><p id="41a5" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">让我们看看下面的示例代码，作为线程 1 (T1)的场景，</p><pre class="kw kx ky kz fd mq mo mr ms aw mt bi"><span id="d822" class="lo jt hi mo b fi mu mv l mw mx">M1(){<br/>   M2();<br/>}<br/>-----------------<br/> M2(){<br/>      M3();<br/> }</span></pre><p id="b764" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">当 M1 方法被调用时，第一个框架将在 T1 线程中创建，并从那里转到 M2 方法，此时第二个框架将被创建，并从那里转到 M3 方法，如上面的演示代码所示，因此一个新的框架将在 M2 下创建。</p><p id="b1ea" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">每当方法退出时，堆栈帧将被分别销毁。</p><p id="7072" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">但是在堆栈中的 T4 线程中，方法 M2 正在访问本机方法。因此，此时，PC 寄存器中的 T4 将为空或未定义，但它将保存所有其他 3 个线程的信息，如上图所示。</p><h1 id="d78a" class="js jt hi bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">执行引擎</h1><p id="e12c" class="pw-post-body-paragraph iu iv hi iw b ix kq iz ja jb kr jd je jf ks jh ji jj kt jl jm jn ku jp jq jr hb bi translated">这是执行字节码(<code class="du ml mm mn mo b">.class</code>)的地方，它逐行执行字节码。在运行程序之前，字节码应该被转换成机器码。让我们看看哪个部分负责这项任务。</p><p id="b4cd" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">主要地，执行引擎有三个主要组件用于执行 Java 类，</p><figure class="kw kx ky kz fd ij er es paragraph-image"><div class="er es ob"><img src="../Images/9b2bc83040e6278b14c3ae2ae4446c40.png" data-original-src="https://miro.medium.com/v2/resize:fit:802/format:webp/1*Aias6-p7q72AMvT91iMO_Q.jpeg"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">执行引擎的组件</figcaption></figure><h2 id="7f90" class="lo jt hi bd ju lp lq lr jy ls lt lu kc jf lv lw kg jj lx ly kk jn lz ma ko mb bi translated">解释者</h2><p id="d8e3" class="pw-post-body-paragraph iu iv hi iw b ix kq iz ja jb kr jd je jf ks jh ji jj kt jl jm jn ku jp jq jr hb bi translated">它负责将字节码转换成机器码。这是缓慢的，因为逐行执行，即使这解释字节码很快。解释器的主要缺点是，当同一个方法被多次调用时，每次都需要新的解释，这将降低系统的性能。这就是 JIT 编译器与解释器并行运行的原因。</p><h2 id="80ac" class="lo jt hi bd ju lp lq lr jy ls lt lu kc jf lv lw kg jj lx ly kk jn lz ma ko mb bi translated">JIT 编译器(实时编译器)</h2><p id="f9f9" class="pw-post-body-paragraph iu iv hi iw b ix kq iz ja jb kr jd je jf ks jh ji jj kt jl jm jn ku jp jq jr hb bi translated">这克服了解释器的缺点。执行引擎首先使用解释器逐行执行字节码，当它发现一些重复的代码时，它将使用 JIT 编译器。(例如:多次调用同一个方法)。那时，JIT 编译器将整个字节码编译成本机代码(机器码)。这些本机代码将存储在缓存中。因此，每当调用重复的方法时，这将提供本机代码。因为用本机代码执行比解释指令更快，所以性能会得到提高。</p><h2 id="aa61" class="lo jt hi bd ju lp lq lr jy ls lt lu kc jf lv lw kg jj lx ly kk jn lz ma ko mb bi translated">垃圾收集工</h2><p id="d2ec" class="pw-post-body-paragraph iu iv hi iw b ix kq iz ja jb kr jd je jf ks jh ji jj kt jl jm jn ku jp jq jr hb bi translated">这将检查堆区域是否有任何未被引用的对象，并销毁这些对象来回收内存。所以它为新的物体腾出了空间。这在后台运行，它使 Java 内存高效。这个过程包括两个阶段，</p><ol class=""><li id="a84a" class="la lb hi iw b ix iy jb jc jf lc jj ld jn le jr mk lg lh li bi translated"><strong class="iw hj">标记— </strong>在这个区域中，垃圾收集器识别堆区域中未被使用的对象。</li><li id="9f64" class="la lb hi iw b ix lj jb lk jf ll jj lm jn ln jr mk lg lh li bi translated"><strong class="iw hj"> Sweep — </strong>在这里，垃圾收集器从<strong class="iw hj">标记中移除对象。</strong></li></ol><p id="7c72" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">这个过程由 JVM 定期完成，也可以通过调用<code class="du ml mm mn mo b">System.gc()</code>方法来触发。</p></div><div class="ab cl mc md gp me" role="separator"><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh"/></div><div class="hb hc hd he hf"><h1 id="d2d1" class="js jt hi bd ju jv nu jx jy jz nv kb kc kd nw kf kg kh nx kj kk kl ny kn ko kp bi translated">Java 本地接口(JNI)</h1><p id="9099" class="pw-post-body-paragraph iu iv hi iw b ix kq iz ja jb kr jd je jf ks jh ji jj kt jl jm jn ku jp jq jr hb bi translated">这用于与执行所需的本地(非 java)方法库(C/C++)进行交互。这将允许 JVM 调用这些库来克服 Java 中的性能约束和内存管理。</p></div><div class="ab cl mc md gp me" role="separator"><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh"/></div><div class="hb hc hd he hf"><h1 id="0887" class="js jt hi bd ju jv nu jx jy jz nv kb kc kd nw kf kg kh nx kj kk kl ny kn ko kp bi translated">本机方法库</h1><p id="153b" class="pw-post-body-paragraph iu iv hi iw b ix kq iz ja jb kr jd je jf ks jh ji jj kt jl jm jn ku jp jq jr hb bi translated">这些是用其他编程语言(非 java)编写的库，如执行引擎所需的 C 和 C++。这可以通过 JNI 访问，这些图书馆的藏书大多以<code class="du ml mm mn mo b">.dll</code>或<code class="du ml mm mn mo b">.so</code>文件扩展名的形式。</p></div><div class="ab cl mc md gp me" role="separator"><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh"/></div><div class="hb hc hd he hf"><h1 id="f963" class="js jt hi bd ju jv nu jx jy jz nv kb kc kd nw kf kg kh nx kj kk kl ny kn ko kp bi translated">参考</h1><p id="bf7e" class="pw-post-body-paragraph iu iv hi iw b ix kq iz ja jb kr jd je jf ks jh ji jj kt jl jm jn ku jp jq jr hb bi translated">我参考了下面的 YouTube 播放列表来写这篇文章，它是由<a class="oc od ge" href="https://medium.com/u/26403c4bd160?source=post_page-----776eea4215ab--------------------------------" rel="noopener" target="_blank"> Krishantha Dinesh </a>制作的。</p><figure class="kw kx ky kz fd ij"><div class="bz dy l di"><div class="oe of l"/></div></figure><p id="c71d" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">我还引用了以下内容来完成这篇文章，</p><div class="og oh ez fb oi oj"><a rel="noopener follow" target="_blank" href="/platform-engineer/understanding-jvm-architecture-22c0ddf09722"><div class="ok ab dw"><div class="ol ab om cl cj on"><h2 class="bd hj fi z dy oo ea eb op ed ef hh bi translated">理解 JVM 架构</h2><div class="oq l"><h3 class="bd b fi z dy oo ea eb op ed ef dx translated">理解 JVM 架构和 Java 在幕后是如何工作的，对每个 Java 来说都是一项重要的学习…</h3></div><div class="or l"><p class="bd b fp z dy oo ea eb op ed ef dx translated">medium.com</p></div></div><div class="os l"><div class="ot l ou ov ow os ox io oj"/></div></div></a></div><div class="og oh ez fb oi oj"><a href="https://www.geeksforgeeks.org/jvm-works-jvm-architecture/" rel="noopener  ugc nofollow" target="_blank"><div class="ok ab dw"><div class="ol ab om cl cj on"><h2 class="bd hj fi z dy oo ea eb op ed ef hh bi translated">JVM 如何工作- JVM 架构？- GeeksforGeeks</h2><div class="oq l"><h3 class="bd b fi z dy oo ea eb op ed ef dx translated">JVM(Java 虚拟机)充当运行 Java 应用程序的运行时引擎。JVM 实际上是调用…</h3></div><div class="or l"><p class="bd b fp z dy oo ea eb op ed ef dx translated">www.geeksforgeeks.org</p></div></div><div class="os l"><div class="oy l ou ov ow os ox io oj"/></div></div></a></div><div class="og oh ez fb oi oj"><a href="https://www.freecodecamp.org/news/jvm-tutorial-java-virtual-machine-architecture-explained-for-beginners/" rel="noopener  ugc nofollow" target="_blank"><div class="ok ab dw"><div class="ol ab om cl cj on"><h2 class="bd hj fi z dy oo ea eb op ed ef hh bi translated">JVM 教程-为初学者讲解的 Java 虚拟机架构</h2><div class="oq l"><h3 class="bd b fi z dy oo ea eb op ed ef dx translated">无论您是否使用过 Java 开发程序，您都可能听说过 Java 虚拟机(JVM ),网址是…</h3></div><div class="or l"><p class="bd b fp z dy oo ea eb op ed ef dx translated">www.freecodecamp.org</p></div></div><div class="os l"><div class="oz l ou ov ow os ox io oj"/></div></div></a></div></div></div>    
</body>
</html>