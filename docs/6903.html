<html>
<head>
<title>Why Android ViewModels are obsolete in KMM</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">为什么 Android 视图模型在 KMM 过时了</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/why-android-viewmodels-are-obsolete-in-kmm-ecbd0124fad1?source=collection_archive---------0-----------------------#2022-06-15">https://medium.com/nerd-for-tech/why-android-viewmodels-are-obsolete-in-kmm-ecbd0124fad1?source=collection_archive---------0-----------------------#2022-06-15</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex if ig ih ii er es paragraph-image"><div class="ab fe cl ij"><img src="../Images/5e2a07f0b557b4d3a92cd13978fab8fe.png" data-original-src="https://miro.medium.com/v2/format:webp/1*HvKqTjPsKIe8kW1JrAWgPA.png"/></div></figure><h1 id="d28f" class="im in hi bd io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj bi translated">问题是</h1><p id="687a" class="pw-post-body-paragraph jk jl hi jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh hb bi translated">Android 上的一个挑战是，当发生屏幕旋转等配置更改时，需要保存和恢复 UI 状态。Android <code class="du ki kj kk kl b"><a class="ae km" href="https://developer.android.com/reference/androidx/lifecycle/ViewModel" rel="noopener ugc nofollow" target="_blank">ViewModels</a></code>的引入是为了让这个过程尽可能的无痛。</p><blockquote class="kn ko kp"><p id="706a" class="jk jl kq jm b jn kr jp jq jr ks jt ju kt ku jx jy kv kw kb kc kx ky kf kg kh hb bi translated"><code class="du ki kj kk kl b"><a class="ae km" href="https://developer.android.com/reference/androidx/lifecycle/ViewModel" rel="noopener ugc nofollow" target="_blank"><em class="hi">ViewModel</em></a></code>类旨在以生命周期意识的方式存储和管理 UI 相关的数据。<code class="du ki kj kk kl b"><a class="ae km" href="https://developer.android.com/reference/androidx/lifecycle/ViewModel" rel="noopener ugc nofollow" target="_blank"><em class="hi">ViewModel</em></a></code>类允许数据在屏幕旋转等配置变化后仍然存在。(<a class="ae km" href="https://developer.android.com/topic/libraries/architecture/viewmodel" rel="noopener ugc nofollow" target="_blank">https://developer . Android . com/topic/libraries/architecture/viewmodel</a>)</p></blockquote><p id="1b4e" class="pw-post-body-paragraph jk jl hi jm b jn kr jp jq jr ks jt ju jv ku jx jy jz kw kb kc kd ky kf kg kh hb bi translated">在设计和实现 Kotlin 多平台的 UI 框架时，我发现现有的框架使用两种方法之一来解决(Android 特有的)UI 状态保持问题:</p><ol class=""><li id="1054" class="kz la hi jm b jn kr jr ks jv lb jz lc kd ld kh le lf lg lh bi translated">在 Android 上使用一个<code class="du ki kj kk kl b">ViewModel</code>，它从 UI 代理到实现业务逻辑的组件(姑且称之为 bloc = business logic component)。<code class="du ki kj kk kl b">ViewModel</code>存在的唯一原因是意识到生命周期并在配置变更时保持状态。<br/> Touchlab 在他们的<a class="ae km" href="https://github.com/touchlab/KaMPKit" rel="noopener ugc nofollow" target="_blank"> KaMPKit </a>中利用了这一点，创建了一个共享的<code class="du ki kj kk kl b">ViewModel</code>平台特定实现，这样所有的业务逻辑都可以放入共享的<code class="du ki kj kk kl b">ViewModel</code>中。</li><li id="09ba" class="kz la hi jm b jn li jr lj jv lk jz ll kd lm kh le lf lg lh bi translated">在 bloc = business logic 组件中添加保留状态/保留实例的功能。<a class="ae km" href="https://arkivanov.github.io/Decompose/" rel="noopener ugc nofollow" target="_blank">分解</a>，例如正在使用<a class="ae km" href="https://github.com/arkivanov/Essenty" rel="noopener ugc nofollow" target="_blank">essentity 的</a> StateKeeper 和 InstanceKeeper。这使得 bloc 独立于 Android <code class="du ki kj kk kl b">ViewModel</code>(至少在表面上)但是现在它需要显式地保存和恢复状态。在我看来，这是一个不太理想的解决方案，尤其是因为这是一个只存在于单个平台上的问题的解决方案。</li></ol><h1 id="6c3b" class="im in hi bd io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj bi translated">“更好”的解决方案</h1><p id="d3af" class="pw-post-body-paragraph jk jl hi jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh hb bi translated">还有第三条路。</p><p id="10ce" class="pw-post-body-paragraph jk jl hi jm b jn kr jp jq jr ks jt ju jv ku jx jy jz kw kb kc kd ky kf kg kh hb bi translated">简单回顾一下，我们需要一个块/业务逻辑组件，它是生命周期感知的，并在配置更改时保留。这是我的解决方案在<code class="du ki kj kk kl b">Activity</code>或<code class="du ki kj kk kl b">Fragment</code>中的样子:</p><pre class="ln lo lp lq fd lr kl ls lt aw lu bi"><span id="6150" class="lv in hi kl b fi lw lx l ly lz">val bloc by getOrCreate { bloc(it) } // `it` is an Essenty lifecycle</span></pre><p id="3903" class="pw-post-body-paragraph jk jl hi jm b jn kr jp jq jr ks jt ju jv ku jx jy jz kw kb kc kd ky kf kg kh hb bi translated">我们使用的是<a class="ae km" href="https://github.com/arkivanov/Essenty" rel="noopener ugc nofollow" target="_blank">essentity</a>生命周期，它是<a class="ae km" href="https://developer.android.com/reference/androidx/lifecycle/Lifecycle" rel="noopener ugc nofollow" target="_blank"> Android 生命周期</a>的平台独立版本。它作为参数传递给 bloc，业务逻辑可以使用它来启动、停止和在销毁时清理资源(调用 onDestroy())。</p><p id="20d2" class="pw-post-body-paragraph jk jl hi jm b jn kr jp jq jr ks jt ju jv ku jx jy jz kw kb kc kd ky kf kg kh hb bi translated">让我们看看引擎盖下是什么:</p><figure class="ln lo lp lq fd ii"><div class="bz dy l di"><div class="ma mb l"/></div></figure><p id="c0f9" class="pw-post-body-paragraph jk jl hi jm b jn kr jp jq jr ks jt ju jv ku jx jy jz kw kb kc kd ky kf kg kh hb bi translated"><code class="du ki kj kk kl b">getOrCreate</code>是<code class="du ki kj kk kl b">ViewModelStoreOwner</code>的一个扩展函数，使用构建器函数<code class="du ki kj kk kl b">(lifecycle: Lifecycle) -&gt; Component</code>惰性地创建一个组件。活动和片段都是<code class="du ki kj kk kl b">ViewModelStoreOwner</code>，所以我们可以从其中任何一个调用它。</p><p id="8ff3" class="pw-post-body-paragraph jk jl hi jm b jn kr jp jq jr ks jt ju jv ku jx jy jz kw kb kc kd ky kf kg kh hb bi translated"><code class="du ki kj kk kl b">ComponentLazy</code>有点难以理解:</p><figure class="ln lo lp lq fd ii"><div class="bz dy l di"><div class="ma mb l"/></div></figure><p id="2d0a" class="pw-post-body-paragraph jk jl hi jm b jn kr jp jq jr ks jt ju jv ku jx jy jz kw kb kc kd ky kf kg kh hb bi translated">(注意:在<code class="du ki kj kk kl b">androidx.lifecycle</code> 2.5 中，create 函数的签名稍微改变为:<br/> <code class="du ki kj kk kl b">override fun &lt;T : ViewModel&gt; create(modelClass: Class&lt;T&gt;): T</code> <br/> - &gt; T 不再可空)</p><p id="c338" class="pw-post-body-paragraph jk jl hi jm b jn kr jp jq jr ks jt ju jv ku jx jy jz kw kb kc kd ky kf kg kh hb bi translated">使用<code class="du ki kj kk kl b">ViewModelStoreOwner</code>我们创建一个<code class="du ki kj kk kl b"><a class="ae km" href="https://developer.android.com/reference/androidx/lifecycle/ViewModelProvider" rel="noopener ugc nofollow" target="_blank">ViewModelProvider</a></code>，它将创建<code class="du ki kj kk kl b">ViewModels</code>并将它们保留在给定<code class="du ki kj kk kl b">ViewModelStoreOwner</code>的商店中。<code class="du ki kj kk kl b">get</code>函数返回一个现有的<code class="du ki kj kk kl b">ViewModel</code>或在作用域(片段或活动)中创建新的<code class="du ki kj kk kl b">ViewModel</code>，与此<code class="du ki kj kk kl b">ViewModelProvider</code>相关联。创建的<code class="du ki kj kk kl b">ViewModel</code>与给定的作用域相关联，并且只要该作用域是活动的，就会被保留(例如，如果它是一个活动，直到它完成或进程被终止):</p><figure class="ln lo lp lq fd ii"><div class="bz dy l di"><div class="ma mb l"/></div></figure><ul class=""><li id="7f76" class="kz la hi jm b jn kr jr ks jv lb jz lc kd ld kh mc lf lg lh bi translated">创建的视图模型是一个<code class="du ki kj kk kl b">BlocViewModel</code>，它包含一个要素<code class="du ki kj kk kl b">Lifecycle</code>和一个要素<code class="du ki kj kk kl b">InstanceKeeper</code>:</li></ul><figure class="ln lo lp lq fd ii"><div class="bz dy l di"><div class="ma mb l"/></div></figure><ul class=""><li id="3747" class="kz la hi jm b jn kr jr ks jv lb jz lc kd ld kh mc lf lg lh bi translated">现在我们使用这个<code class="du ki kj kk kl b">InstanceKeeper</code>来检索或创建<code class="du ki kj kk kl b">Component</code>。与实现<code class="du ki kj kk kl b">InstanceKeeper.Instance</code>相比，<code class="du ki kj kk kl b">Component</code>被包装成一个类，因为只有那些可以存储在<code class="du ki kj kk kl b">InstanceKeeper:</code>中</li></ul><figure class="ln lo lp lq fd ii"><div class="bz dy l di"><div class="ma mb l"/></div></figure><p id="b99d" class="pw-post-body-paragraph jk jl hi jm b jn kr jp jq jr ks jt ju jv ku jx jy jz kw kb kc kd ky kf kg kh hb bi translated">概括地说:</p><ul class=""><li id="332c" class="kz la hi jm b jn kr jr ks jv lb jz lc kd ld kh mc lf lg lh bi translated"><code class="du ki kj kk kl b">Component</code>存储在<code class="du ki kj kk kl b">InstanceKeeper</code>中</li><li id="1e3a" class="kz la hi jm b jn li jr lj jv lk jz ll kd lm kh mc lf lg lh bi translated"><code class="du ki kj kk kl b">InstanceKeeper</code>存储在一个机器人<code class="du ki kj kk kl b">ViewModel</code>的<code class="du ki kj kk kl b">BlocViewModel</code>中</li><li id="7cd7" class="kz la hi jm b jn li jr lj jv lk jz ll kd lm kh mc lf lg lh bi translated"><code class="du ki kj kk kl b">BlocViewModel</code>持有一个与其自身生命周期相关联的<code class="du ki kj kk kl b">Lifecycle</code>。这个生命周期被<code class="du ki kj kk kl b">Component</code>用来管理其内部资源(协程、流程、通道等)。)</li><li id="c776" class="kz la hi jm b jn li jr lj jv lk jz ll kd lm kh mc lf lg lh bi translated">只要<code class="du ki kj kk kl b">BlocViewModel</code>的所有者还活着，它就会存储在<code class="du ki kj kk kl b">ViewModelStore</code>中，这意味着它将在配置更改时被保留</li></ul><h1 id="b81d" class="im in hi bd io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj bi translated">摘要</h1><p id="6f0e" class="pw-post-body-paragraph jk jl hi jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh hb bi translated">我们可以创建一个共享的/独立于平台的业务逻辑组件，并通过一行代码在 Android 上实现 it 生命周期感知:</p><pre class="ln lo lp lq fd lr kl ls lt aw lu bi"><span id="0c8b" class="lv in hi kl b fi lw lx l ly lz">val bloc by getOrCreate { bloc(it) }</span></pre><p id="db54" class="pw-post-body-paragraph jk jl hi jm b jn kr jp jq jr ks jt ju jv ku jx jy jz kw kb kc kd ky kf kg kh hb bi translated">使这成为可能的代码可以驻留在一个共享模块中(<code class="du ki kj kk kl b">androidMain)</code>)。最近发布的用于 Kotlin 多平台的 UI 框架<code class="du ki kj kk kl b"><a class="ae km" href="https://1gravity.github.io/Kotlin-Bloc" rel="noopener ugc nofollow" target="_blank">Kotlin Bloc</a></code>实现了这种机制。</p><p id="8278" class="pw-post-body-paragraph jk jl hi jm b jn kr jp jq jr ks jt ju jv ku jx jy jz kw kb kc kd ky kf kg kh hb bi translated">感谢您的阅读和反馈。</p><h2 id="a599" class="lv in hi bd io md me mf is mg mh mi iw jv mj mk ja jz ml mm je kd mn mo ji mp bi translated">附录</h2><p id="12b2" class="pw-post-body-paragraph jk jl hi jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh hb bi translated">请注意，虽然在底层使用 ViewModel 可以确保跨配置更改保留阻塞，但它不会在进程死亡后继续存在。</p><p id="3c10" class="pw-post-body-paragraph jk jl hi jm b jn kr jp jq jr ks jt ju jv ku jx jy jz kw kb kc kd ky kf kg kh hb bi translated">为了避免系统启动的进程死亡，您仍然必须使用一个<code class="du ki kj kk kl b"><a class="ae km" href="https://developer.android.com/reference/androidx/lifecycle/SavedStateHandle" rel="noopener ugc nofollow" target="_blank">SavedStateHandle</a></code>:</p><figure class="ln lo lp lq fd ii er es paragraph-image"><div role="button" tabindex="0" class="mr ms di mt bf mu"><div class="er es mq"><img src="../Images/0ce8df17bdcae18144378273fcacd30f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pq5R2Tw6zRJ9J-rP52E-Uw.png"/></div></div><figcaption class="mv mw et er es mx my bd b be z dx translated"><a class="ae km" href="https://developer.android.com/topic/libraries/architecture/saving-states" rel="noopener ugc nofollow" target="_blank">https://developer . Android . com/topic/libraries/architecture/saving-States</a></figcaption></figure><p id="d06c" class="pw-post-body-paragraph jk jl hi jm b jn kr jp jq jr ks jt ju jv ku jx jy jz kw kb kc kd ky kf kg kh hb bi translated">你的 UI 是否需要那种“留存”取决于你的应用。根据用户采取的操作，他们要么希望清除活动状态，要么希望保留状态。</p></div></div>    
</body>
</html>