# 戈兰语界面

> 原文：<https://medium.com/nerd-for-tech/interfaces-in-golang-f9df59b0b71e?source=collection_archive---------6----------------------->

![](img/fad7768bc4149c00189d5ce6f35e91cb.png)

在我使用 Golang 的几年中，我遇到过几次涉及接口使用的讨论。参数范围从:

> 为什么我们不像 C++、Java 等典型的静态语言那样用类型定义来定义接口呢？
> 
> 此包是否应导出接口以及实现该接口的公开类型？
> 
> 这个函数应该返回一个接口而不是具体类型吗？

让我们试着逐一解决这些问题。

## 为什么我们不像 C++、Java 等典型的静态语言那样用类型定义来定义接口呢？

在 C++、Java 等语言中，需要指定一个类型实现一个接口，如下面给出的代码所示:

在这样的语言中，为对象定义接口使得编译器能够为指向函数的对象形成调度表。

Go 没有传统的调度表，在方法调度期间可以依赖接口值。它实际上更像是一种自由式调度机制，需要在接口值赋值期间做一些工作——它为所指向的具体类型生成一个小型查找哈希表。如果你想进一步阅读，这里有一篇很棒的博文。

尽管有点贵，但这使得 go 有一个更干净的类型系统，没有为每种类型定义接口的负担。

对于开发者来说，这意味着**实现的对象*不需要*显式地*说它实现了它，***如下面的代码所示:

因此，任何结构都可以简单地通过实现其方法签名来满足接口。它有几个优点，如:

*   使得在单元测试中使用模拟对象代替真实对象更加容易。
*   有助于增强代码库各部分之间的分离。

## 此包是否应导出接口以及实现该接口的公开类型？

简短的回答是:

> 除非必要，否则不要导出任何接口。

如果您的包的消费者需要某种程度的“控制反转”，他们可以在自己的范围内定义接口。

然而，在某些情况下，人们可能希望标准化某项功能的使用方式。以 golang 错误界面为例。

```
type error interface { Error() string}
```

它是标准库中的内置接口，用于标准化错误行为。社区中还有其他关于标准化某些行为的讨论，例如拥有一个通用的[登录](https://groups.google.com/g/golang-dev/c/F3l9Iz1JX4g/discussion)界面。类似地，在公司范围内表示一些常见行为以提供一致性和代码可重用性可能是有用的。然而，在这种情况下，要确保接口很小，也就是 1-2 个方法。

## 这个包应该返回一个接口而不是具体类型吗？

根据 CodeReviewComments， [Go 接口通常属于使用接口类型值的包，而不是实现那些值的包。](https://github.com/golang/go/wiki/CodeReviewComments#interfaces)

然而[有效 go](https://golang.org/doc/effective_go#generality) docs 也补充说

> 如果某个类型的存在只是为了实现某个接口，并且永远不会在该接口之外导出方法，则没有必要导出该类型本身。

但问题是你如何识别这样的场景？你怎么知道该类型在将来没有附加值？以我的经验，答案是“等”。不要一开始就返回接口，而是等到你的代码发展到需要它们的时候。正如罗布·派克所说:

> “不要用界面来设计，要发现它们。”

当您的包中有多个类型实现相同的方法签名时，公开接口的一个很好的提示是**。如果你看看标准库中的`http`包，你会发现它内部有多个`http.Handler`接口的实现。**

在混乱的情况下，寻找一些**危险信号是有帮助的，这些信号可以表明你可能使用了错误的接口**。有些是:

## 你的接口没有将 API 从变化中分离出来。

想象一个用于发送电子邮件的第三方 api 客户端包的实现，例如 [SendGrid](https://sendgrid.com/)

现在想象一下，`SendGrid`会有新的实现吗？
如果 SendGrid 被比如说`Mailjet`所取代，很可能会有一个不同的电子邮件发送服务的新实现。因此，您可以重写代码来返回具体的类型。

再想象一下，你想给这个被很多人使用的接口添加一个新方法，你如何在不破坏代码的情况下给它添加一个新方法呢？

通过公开结构类型本身，您可以向结构本身添加新方法，而无需密集的重构

## 你的接口有不止一两个方法。

你的界面有太多的方法会降低它的可用性。以`fmt.Stringer`接口为例，它只有一个方法签名，即

```
type Stringer interface { String() string}
```

并且在标准库中的 30 个地方使用，不包括测试。您可以在标准库中找到类似的其他示例，如`http.Handler`、`io.Reader`等。

现在想象一个有 5-6 个方法的接口，它实际上只能在 1-2 个地方使用，因为不是所有的类型都能实现大量的方法。

> 接口越大，抽象性越弱。

## 结论:

Golang 中的接口可能很难掌握，一般建议遵循经验法则。在一般规则有例外的情况下，等着看你的代码如何发展，并做出相应的调整。