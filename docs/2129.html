<html>
<head>
<title>Palindramatic</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">回文的</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/palindramatic-99ce8712101a?source=collection_archive---------13-----------------------#2021-04-22">https://medium.com/nerd-for-tech/palindramatic-99ce8712101a?source=collection_archive---------13-----------------------#2021-04-22</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="2bde" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">深入探究寻找回文的戏剧。</h2></div><p id="4e31" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如果你曾经在市场上寻找软件工程方面的工作(就像我写这篇文章的时候一样)，并且遵循似乎每个人的建议来温习你的数据结构、算法以及如何驯服它们的知识，你肯定会遇到关于一个叫做回文的人的问题。</p><p id="b50f" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">她是谁？一位穿着相配的帽子和鞋子，颜色与每件衣服从裙子到上衣到腰带都很协调的漂亮女士。也就是说，如果你上下上下打量她，她看起来还是一样的。<br/>在编程术语中，回文是一个字符串(单个单词或短语),从每一端到中点有相同顺序的相同字母。举几个例子:“赛车”、“安娜”、“塔可猫”，你就明白了。</p><figure class="ju jv jw jx fd jy er es paragraph-image"><div class="er es jt"><img src="../Images/770b7eb5a79ef2d22aca43d57796e63a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1392/format:webp/0*lduQy6-0oG2UdVPQ.jpg"/></div></figure><p id="321c" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">既然我们在面对回文这个词时都在同一页上，我们被要求理解什么，让我们想想为什么使用回文很有趣(不管是好是坏)。这里要认识的关键是，回文单词中的任何字母都不应该没有对应的字母。而如果有，也应该只有一个，即:《赛车》中的“e”。当我们讨论一些解决回文问题的策略时，请记住这一点。</p></div><div class="ab cl kb kc gp kd" role="separator"><span class="ke bw bk kf kg kh"/><span class="ke bw bk kf kg kh"/><span class="ke bw bk kf kg"/></div><div class="hb hc hd he hf"><p id="725b" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这些问题有几种不同的表达方式，它们将决定最有意义的策略。</p><h1 id="1dda" class="ki kj hi bd kk kl km kn ko kp kq kr ks io kt ip ku ir kv is kw iu kx iv ky kz bi translated">"写一个函数来判断一个字符串是否是回文"</h1><p id="879b" class="pw-post-body-paragraph ix iy hi iz b ja la ij jc jd lb im jf jg lc ji jj jk ld jm jn jo le jq jr js hb bi translated">从这个问题的措辞中，我们可以有把握地假设，如果给定的字符串实际上是一个回文，那么它的字母已经按照适当的顺序排列好了。这里一个有趣的策略是使用递归来确定字符串是否是回文。</p><ol class=""><li id="1495" class="lf lg hi iz b ja jb jd je jg lh jk li jo lj js lk ll lm ln bi translated">检查字符串的长度，看它是 1 还是 0，如果是，返回 true。从技术上讲，这将是我们的基本情况，因为一旦字符串变得这么小，它将满足所有的回文标准！更多关于为什么接下来…</li><li id="5528" class="lf lg hi iz b ja lo jd lp jg lq jk lr jo ls js lk ll lm ln bi translated">接下来，如果字符串的长度是 2 或更多，我们确定第一个和最后一个字母是否相同。如果不是，我们知道可以立即返回 false，因为这是回文的基本标准之一。</li><li id="782e" class="lf lg hi iz b ja lo jd lp jg lq jk lr jo ls js lk ll lm ln bi translated">现在，如果字符串的长度都大于 1，并且第一个和最后一个字母相等，我们需要检查其余的字母是否有对应的字母。幸运的是，我们已经在编写的函数可以为我们做到这一点！我们可以简单地用一个新字符串调用<code class="du lt lu lv lw b">isPalindrome</code>，这个新字符串是旧字符串减去它的第一个和最后一个字母。然后，该函数将递归运行，直到我们剩下一个长度为 0 或 1 的字符串，我们已经确定该字符串将返回 true。</li></ol><p id="5460" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">最终的代码可能如下所示:</p><figure class="ju jv jw jx fd jy er es paragraph-image"><div class="er es lx"><img src="../Images/010e037f234a675b308064cb707b96b2.png" data-original-src="https://miro.medium.com/v2/resize:fit:888/format:webp/1*eIts27P_TxQoi3nsOLnKWQ.png"/></div><figcaption class="ly lz et er es ma mb bd b be z dx translated">递归策略</figcaption></figure><p id="e9f4" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">像老板一样解决了！</p><figure class="ju jv jw jx fd jy"><div class="bz dy l di"><div class="mc md l"/></div></figure><h1 id="06ef" class="ki kj hi bd kk kl km kn ko kp kq kr ks io kt ip ku ir kv is kw iu kx iv ky kz bi translated">"写一个函数来确定一个给定的字符串是否是一个回文的排列"</h1><p id="779a" class="pw-post-body-paragraph ix iy hi iz b ja la ij jc jd lb im jf jg lc ji jj jk ld jm jn jo le jq jr js hb bi translated">这个问题不是问字符串是否已经是一个回文，而是问它的字母是否可能被重新排列来创建一个。不幸的是，这意味着我们将无法使用递归策略(可悲，我知道)。是时候记住我们之前说过的，没有偶数个字母的回文不会超过一个字母。</p><p id="fe32" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这里要采取的策略是:</p><ol class=""><li id="74bb" class="lf lg hi iz b ja jb jd je jg lh jk li jo lj js lk ll lm ln bi translated">删除字符串中的空格，这样我们的函数就可以处理回文短语。</li></ol><p id="94e1" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">2.初始化一个我们称之为<code class="du lt lu lv lw b">charCount</code>的空对象</p><p id="5285" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">3.将<code class="du lt lu lv lw b">oddCount</code>变量设置为 0</p><p id="d636" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">4.遍历字符串并创建字母-数字-键值对来计算每个字母的出现次数。当我们迭代时，如果每个字母已经存在，我们将更新它的值，如果不存在，我们将添加一个新的对。</p><p id="8249" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">5.下一项工作可以在第一项工作完成后在另一个循环中完成，或者作为我们已经开始的循环的第二部分。我把它写成第二种方式，因为它在我的大脑中更有意义，但是两种方式在时间复杂度方面都没有优势(它们都是线性 O(n)复杂度)。<br/>实际发生的是，我们对每个值进行均匀性检查，方法是对其取 2 的模，如果余数等于 1(表示奇数),则将<code class="du lt lu lv lw b">oddCount</code>加 1。如果值能被 2 整除，因此是偶数，则我们递减<code class="du lt lu lv lw b">oddCount</code>。</p><p id="4f5c" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">6.最后，我们返回一个表达式，该表达式将解析为真/假值，指示 count 是否大于 1 <code class="du lt lu lv lw b">oddCount &lt;= 1</code>。</p><p id="d06b" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">也许您的最终代码如下所示:</p><figure class="ju jv jw jx fd jy er es paragraph-image"><div class="er es me"><img src="../Images/6a163e21d8e998e526669984833c870b.png" data-original-src="https://miro.medium.com/v2/resize:fit:842/format:webp/1*RK7EtbUajaDPiyM2sVUdnA.png"/></div><figcaption class="ly lz et er es ma mb bd b be z dx translated">计数和取模策略</figcaption></figure><p id="983f" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">嘣！</p></div><div class="ab cl kb kc gp kd" role="separator"><span class="ke bw bk kf kg kh"/><span class="ke bw bk kf kg kh"/><span class="ke bw bk kf kg"/></div><div class="hb hc hd he hf"><p id="d366" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">将来当你遇到关于回文的问题时，你可以…</p><figure class="ju jv jw jx fd jy"><div class="bz dy l di"><div class="mf md l"/></div></figure></div></div>    
</body>
</html>