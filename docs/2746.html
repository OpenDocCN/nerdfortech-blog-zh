<html>
<head>
<title>Interoperability Feature in C#</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">C#中的互操作性特性</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/interoperability-feature-in-c-9f3230c0f6cf?source=collection_archive---------15-----------------------#2021-05-18">https://medium.com/nerd-for-tech/interoperability-feature-in-c-9f3230c0f6cf?source=collection_archive---------15-----------------------#2021-05-18</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/1b45d2bab99a2fbe602a1d5865f8aab5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gzVRoz5vRdawCngZ9giAaw.jpeg"/></div></div></figure><p id="2598" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">互操作性是指一个系统与另一个系统的组件进行通信的能力。为了详细理解它，让我们考虑一个电子商务系统的后端，其中有两个核心功能</p><ul class=""><li id="7602" class="jo jp hi is b it iu ix iy jb jq jf jr jj js jn jt ju jv jw bi translated">维护不同订单的历史数据</li><li id="3b33" class="jo jp hi is b it jx ix jy jb jz jf ka jj kb jn jt ju jv jw bi translated">根据包裹的位置和运送地点自动包装和隔离物品。</li></ul><p id="ca5c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在让我们假设订单信息的维护是使用C#语言完成的。另一方面，打包和分离工具是用C++开发的。</p><p id="2ea7" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">每当订单准备发货时，物品被放置在流经包装系统的传送带上。随后根据位置数据的需要对其进行分离。为了跟踪传送带中的包裹，一旦包裹通过传送带，包装系统必须更新状态。因此，打包系统是一个独立的系统，它需要向运行在服务器上的基于C#的主代码发送更新。</p><p id="761d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">此外，当包裹到达隔离系统时，隔离系统需要包裹需要移动到的位置。所以，现在，打包系统需要从C++系统到C#系统的通信。类似地，隔离系统需要将数据从C++系统发送到C#系统。这意味着我们需要用一种支持多个系统的编程语言来开发我们的应用程序，并为公司完成工作。幸运的是，C#的互操作性使得实现这一点变得很容易。让我们详细看看C#中的互操作性特性是什么，以及它是如何有用的。</p><p id="20fa" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">目录</strong></p><ol class=""><li id="d17f" class="jo jp hi is b it iu ix iy jb jq jf jr jj js jn kc ju jv jw bi translated">C#中的互操作性是什么？</li><li id="e5fe" class="jo jp hi is b it jx ix jy jb jz jf ka jj kb jn kc ju jv jw bi translated">C#中的互操作性可能性</li><li id="5b9b" class="jo jp hi is b it jx ix jy jb jz jf ka jj kb jn kc ju jv jw bi translated">结论</li></ol><h1 id="a50f" class="kd ke hi bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">C#中的互操作性是什么？</h1><p id="d0e5" class="pw-post-body-paragraph iq ir hi is b it lb iv iw ix lc iz ja jb ld jd je jf le jh ji jj lf jl jm jn hb bi translated">互操作性是使不同的编程语言能够在同一系统中交互的属性。这有助于实现一个共同的目标，并利用已有的代码。在C#中，当涉及到互操作性时，使用C#语言编写的代码将由IDE附带的编译器进行验证，并且代码的内存管理也将得到关注。</p><p id="9963" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">此外，如果DLL被称为外部引用，并且外部包是用可以自我管理的编程语言编写的，则它被视为托管代码。如果不是这样，C#编译器会将它视为非托管代码。C#允许以DLL的形式包含托管和非托管代码作为外部引用。</p><h1 id="ac3c" class="kd ke hi bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">C#中的互操作性可能性</h1><h2 id="f512" class="lg ke hi bd kf lh li lj kj lk ll lm kn jb ln lo kr jf lp lq kv jj lr ls kz lt bi translated">使用托管代码</h2><p id="622a" class="pw-post-body-paragraph iq ir hi is b it lb iv iw ix lc iz ja jb ld jd je jf le jh ji jj lf jl jm jn hb bi translated">托管代码是指互相使用用VB.Net或C#编写的代码。例如，正在用C#开发一个功能，而在VB中也需要同样的功能。Net项目。尽管它们来自不同的编程语言。Net通过DLL(动态链接库)的概念交换它们被开发的位置，提供了引用它们的选项。</p><p id="2a81" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">。Net提供了创建类库的选项，方法是添加类库项目并在其中编写代码逻辑。一旦构建完成，C#或built代码就会生成该功能的DLL。这个DLL可以很容易地作为引用添加到这两个地方，从而达到代码重用的目的。它提供了用原始语言完成功能的额外成本优势。</p><h2 id="a12d" class="lg ke hi bd kf lh li lj kj lk ll lm kn jb ln lo kr jf lp lq kv jj lr ls kz lt bi translated">使用非托管代码</h2><p id="8deb" class="pw-post-body-paragraph iq ir hi is b it lb iv iw ix lc iz ja jb ld jd je jf le jh ji jj lf jl jm jn hb bi translated">为了理解C#中非托管代码可用的互操作性选项，我们需要了解关于COM的一切。组件对象模型，通常称为COM，是最早发明的允许组件二进制重用的技术之一。它使得为用不同编程语言编写的程序提供接口成为可能。COM使用GUID来标识捆绑在一起的唯一成员。它允许为每个GUID注册一个DLL。</p><p id="ddb3" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">从使用COM组件。Net项目:正如我们在上面看到的，COM公开接口来进行通信。但是，基于. Net的客户端无法直接使用COM公开的接口，因为它无法理解该接口。因此，必须围绕COM组件定义一个包装器，以使代码对于。Net客户端。这里，包装器被称为运行时可调用包装器(RCW)。可以通过VS.NET生成RCW，当客户端调用COM中的功能时，调用将通过RCW，并转换为本机COM调用过程。此外，当涉及到COM组件时，继承、参数化构造函数等功能。不能被利用。</p><p id="b8c2" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">吞噬。来自COM客户端的. Net组件</strong>:让我们考虑相反的场景。就像运行时可调用包装器一样。Net客户端来识别。在这种情况下，必须创建COM可调用包装(CCW)。它可以使用作为的一部分提供的RegAsm.exe来创建。净效用。当从COM组件发出调用时，该调用通过CCW进行路由，CCW又将本机COM调用转换为。Net可理解的格式，并以类似方式转换响应。</p><h1 id="0873" class="kd ke hi bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">结论</h1><p id="ff06" class="pw-post-body-paragraph iq ir hi is b it lb iv iw ix lc iz ja jb ld jd je jf le jh ji jj lf jl jm jn hb bi translated">。Net提供了在托管代码和非托管代码之间进行通信的选项。托管代码中的通信是通过直接引用dll实现的，而在非托管代码中，它是通过RCW和CCW的概念实现的。</p></div><div class="ab cl lu lv gp lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="hb hc hd he hf"><p id="8d14" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><em class="mb">原载于</em><a class="ae mc" href="https://www.partech.nl/nl/publicaties/2021/03/interoperability-feature-in-c-sharp" rel="noopener ugc nofollow" target="_blank"><em class="mb">https://www . partech . nl</em></a><em class="mb">。</em></p></div></div>    
</body>
</html>