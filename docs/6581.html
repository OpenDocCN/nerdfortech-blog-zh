<html>
<head>
<title>Kernels and Logging in Linux</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Linux 中的内核和日志</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/kernels-and-logging-in-linux-b3cba6345356?source=collection_archive---------8-----------------------#2022-03-26">https://medium.com/nerd-for-tech/kernels-and-logging-in-linux-b3cba6345356?source=collection_archive---------8-----------------------#2022-03-26</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="d0ea" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Linux 系统中的引导过程是一个相当完整的旅程，它有一系列完成特定任务的阶段，只是为了以一种有效的方式调优您的工作站或服务器。</p><p id="1495" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">整个想法是写一个非常简洁的概述，介绍在 Linux 系统中，特别是在 CentOS 版本中，内核是如何被触发的，日志是如何执行的。我将非常直接地使用一些术语，因为这方面有很多可用的信息，但是，我将尝试以简洁明了的方式涵盖尽可能多的内容。</p><h1 id="1a61" class="jd je hi bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">引导系统</h1><p id="b303" class="pw-post-body-paragraph if ig hi ih b ii kb ik il im kc io ip iq kd is it iu ke iw ix iy kf ja jb jc hb bi translated">从固件代码执行开始，到引导加载程序、内核、内存磁盘初始化，直到任何流程管理系统，您的服务器或工作站都需要执行所有周期/阶段，以便为系统工作做好准备。</p><p id="eca5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">先预热一下，我们可以设置固件以两种方式执行代码。在旧系统中，计算机在 BIOS 中执行代码，实际上，这种方法在遗留系统中很常见。另一方面，较新的计算机在<code class="du kg kh ki kj b">UEFI</code>固件中执行代码。</p><p id="68be" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这里常见的方法是两者都在被称为<code class="du kg kh ki kj b">POST</code>过程的<code class="du kg kh ki kj b">power-on-self-test</code>中执行</p><p id="e2e3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为了更好的理解这一点，可以参考<a class="ae kk" href="https://www.geeksforgeeks.org/what-is-postpower-on-self-test/" rel="noopener ugc nofollow" target="_blank">这篇</a>文章定义文章来自<a class="ae kk" href="https://www.geeksforgeeks.org/" rel="noopener ugc nofollow" target="_blank"> Geeksforgeeks </a>。</p><p id="d690" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">一旦<code class="du kg kh ki kj b">POST</code>流程成功执行，<code class="du kg kh ki kj b">Bootloader</code>就开始了。此时，固件在驱动器上执行著名的引导加载程序<code class="du kg kh ki kj b">grub2</code>代码，<code class="du kg kh ki kj b">Bootloader</code>读取其配置并引导 Linux 内核。</p><p id="abf3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在有<code class="du kg kh ki kj b">BIOS</code>的情况下，<code class="du kg kh ki kj b">grub</code>的配置文件将位于<code class="du kg kh ki kj b">/boot/grub2/grub.cfg</code>，在其他基于<code class="du kg kh ki kj b">UEFI</code>的系统情况下，您应该查看一下<code class="du kg kh ki kj b">/boot/efi/EFI/red/grub.efi</code></p><p id="3151" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在此之后，下一件大事是<code class="du kg kh ki kj b">Kernel</code>初始化，在这一步中<code class="du kg kh ki kj b">ramdisk</code>被加载到 RAM 内存中，<code class="du kg kh ki kj b">ramdisk</code>作为一个临时文件系统，包含重要的内核模块、驱动程序和一些 Kickstarter 文件，之后，内核自己卸载<code class="du kg kh ki kj b">ramdisk</code>并挂载实际的根文件系统。</p><p id="9512" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">你可以在这里找到更多关于 ramdisk <a class="ae kk" href="https://www.novell.com/documentation/suse91/suselinux-adminguide/html/ch12s03.html" rel="noopener ugc nofollow" target="_blank">的信息</a>。</p><p id="a6e7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">一旦文件系统被挂载，初始化阶段就开始了。在这里，你会被某种服务管理系统所统治，无论是使用<code class="du kg kh ki kj b">SysV init</code>、<code class="du kg kh ki kj b">launchd</code>、<code class="du kg kh ki kj b">upStart</code>还是<code class="du kg kh ki kj b">Systemd</code></p><h1 id="6d67" class="jd je hi bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">简单的 grub 概述</h1><p id="7d0c" class="pw-post-body-paragraph if ig hi ih b ii kb ik il im kc io ip iq kd is it iu ke iw ix iy kf ja jb jc hb bi translated">你可能知道，CentOS 7 使用<code class="du kg kh ki kj b">grub2</code>作为他们的引导加载程序。</p><p id="a5c4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">您可以在<code class="du kg kh ki kj b">/boot/grub2/grub.cfg</code>文件中查看 grub 加载程序的完整配置。这里有几行代码值得一提</p><ol class=""><li id="b8cc" class="kl km hi ih b ii ij im in iq kn iu ko iy kp jc kq kr ks kt bi translated"><code class="du kg kh ki kj b">## BEGIN /etc/grub.d/00_header</code>内部创建 GRUB 菜单标题并为其设置屏幕</li><li id="5d62" class="kl km hi ih b ii ku im kv iq kw iu kx iy ky jc kq kr ks kt bi translated">包含我们在启动时看到的实际内核选择。所有条目都以菜单项开始，并包括引导加载程序和内核的选项</li><li id="09d8" class="kl km hi ih b ii ku im kv iq kw iu kx iy ky jc kq kr ks kt bi translated"><code class="du kg kh ki kj b">linux16 /vmlinuz-3-10.0 …</code>是实际的 Linux 默认系统，这包括到根文件系统的路径。</li><li id="d2c8" class="kl km hi ih b ii ku im kv iq kw iu kx iy ky jc kq kr ks kt bi translated"><code class="du kg kh ki kj b">initrd16 /initramsfs-3.10.0 …</code>指定与内核匹配的<code class="du kg kh ki kj b">ramdisk</code>。这是挂载根文件系统之前的前一步</li><li id="3500" class="kl km hi ih b ii ku im kv iq kw iu kx iy ky jc kq kr ks kt bi translated"><code class="du kg kh ki kj b">### BEGIN /etc/grub.d/30_os-prober</code>如果您在驱动器上有不同的分区，这个选项会很有用，<code class="du kg kh ki kj b">os-probe</code>会找到它并为它创建一个启动条目。</li><li id="ef07" class="kl km hi ih b ii ku im kv iq kw iu kx iy ky jc kq kr ks kt bi translated"><code class="du kg kh ki kj b">### BEGIN /etc/grub.d/40_custom</code>这个用于自定义菜单项</li></ol><p id="c314" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为了修改执行的排序顺序，可以更改所有的名称。如果您执行任何更改，您将需要通过运行<code class="du kg kh ki kj b">grub2-mkconfig</code>命令来保存<code class="du kg kh ki kj b">grub</code>配置。</p><p id="fabc" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">此外，我们有位于<code class="du kg kh ki kj b">/etc/default/grub</code>的默认 grub 设置文件，它包含用于正确设置<code class="du kg kh ki kj b">grub</code>的完整转储内容。一个很酷的例子是<code class="du kg kh ki kj b">GRUB_TIMEOUT</code>属性，它在自动引导默认内核条目之前为显示的菜单设置超时</p><p id="f858" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">默认的内核配置位于<code class="du kg kh ki kj b">/boot/grub2/grubenv</code>，为此，值得一提的是<code class="du kg kh ki kj b">saved_entry</code>列表，它只不过是<code class="du kg kh ki kj b">grub.cfg</code>文件的菜单项。</p><p id="d58b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为了改变默认的<code class="du kg kh ki kj b">grub2</code>加载程序，您可以通过添加内核列表号来使用<code class="du kg kh ki kj b">grub2-set-default</code>命令。</p><p id="7145" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">类似于:<code class="du kg kh ki kj b">grub2-set-default 1</code></p><p id="e26e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">之后，您需要重新配置 grub 配置文件，使用:</p><ol class=""><li id="21b0" class="kl km hi ih b ii ij im in iq kn iu ko iy kp jc kq kr ks kt bi translated"><code class="du kg kh ki kj b">BIOS</code>方法:<code class="du kg kh ki kj b">grub2-mkconfig -o /boot/grub2/grub.cfg</code></li><li id="ed37" class="kl km hi ih b ii ku im kv iq kw iu kx iy ky jc kq kr ks kt bi translated"><code class="du kg kh ki kj b">UEFI</code>方法:<code class="du kg kh ki kj b">grub2-mkconfig -o /boot/efi/EFI/redhat/grub.cfg</code></li></ol><h1 id="de8e" class="jd je hi bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">内核概述</h1><p id="107f" class="pw-post-body-paragraph if ig hi ih b ii kb ik il im kc io ip iq kd is it iu ke iw ix iy kf ja jb jc hb bi translated">理解语义版本将有助于了解什么类型的内核更新可以适用于特定的系统。在 CentOS 系统中，您可以通过运行:<code class="du kg kh ki kj b">sudo yum -q install list kernel-*</code>来检查已安装内核的列表</p><p id="505b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">下面是一个内核示例版本输出:<code class="du kg kh ki kj b">kernel.x86_64 3.10.0–514.el7</code></p><p id="3eb4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">其中:</p><ol class=""><li id="ba13" class="kl km hi ih b ii ij im in iq kn iu ko iy kp jc kq kr ks kt bi translated">3:是主要版本</li><li id="bd5e" class="kl km hi ih b ii ku im kv iq kw iu kx iy ky jc kq kr ks kt bi translated">10:是主要修订版</li><li id="7da0" class="kl km hi ih b ii ku im kv iq kw iu kx iy ky jc kq kr ks kt bi translated">0:是内核补丁</li><li id="a1e7" class="kl km hi ih b ii ku im kv iq kw iu kx iy ky jc kq kr ks kt bi translated">514:指红帽版</li><li id="ba27" class="kl km hi ih b ii ku im kv iq kw iu kx iy ky jc kq kr ks kt bi translated">el7:指企业版 Linux 7</li></ol><p id="76fa" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">内核文件驻留在<code class="du kg kh ki kj b">/boot</code>目录中，因此，当您列出它时，您会发现代表 Linux 内核本身的<code class="du kg kh ki kj b">vmlinuz</code>文件，<code class="du kg kh ki kj b">initramfs</code>是 ramdisk 目录，此外，还有一些与 grub 相关的目录。</p><p id="2107" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">另一个重要的目录是<code class="du kg kh ki kj b">/proc</code>,它是在系统启动时在内存中创建的，当机器关闭时被删除。<code class="du kg kh ki kj b">/proc</code>目录作为内核本身的直接接口。在内部，您将看到一堆数字文件夹，它们代表每个运行的 PID 和执行细节，非数字文件夹包含关于内存系统的信息，这些信息以文本文件的形式表示。</p><h2 id="0806" class="kz je hi bd jf la lb lc jj ld le lf jn iq lg lh jr iu li lj jv iy lk ll jz lm bi translated">附加模块</h2><p id="4c0a" class="pw-post-body-paragraph if ig hi ih b ii kb ik il im kc io ip iq kd is it iu ke iw ix iy kf ja jb jc hb bi translated">除了内核之外，Linux 还有必须与内核版本相匹配的模块，这些模块为内核增加了功能，包括文件系统和驱动程序。您可以在<code class="du kg kh ki kj b">/lib</code>和<code class="du kg kh ki kj b">/lib64</code>目录中找到它</p><p id="cff8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">下面是你如何过滤它:<code class="du kg kh ki kj b">ls /lib/modules/$(uname -r)/kernel</code>内部有用于架构、加密、驱动、文件系统、内核、网络等等的库，然而，你可以用这些 util 命令检查其中的一些。</p><ol class=""><li id="baa0" class="kl km hi ih b ii ij im in iq kn iu ko iy kp jc kq kr ks kt bi translated"><code class="du kg kh ki kj b">lsmod</code>用于显示加载到内存中的模块</li><li id="e79f" class="kl km hi ih b ii ku im kv iq kw iu kx iy ky jc kq kr ks kt bi translated"><code class="du kg kh ki kj b">modinfo [module]</code>向特定模块显示信息</li><li id="2f62" class="kl km hi ih b ii ku im kv iq kw iu kx iy ky jc kq kr ks kt bi translated"><code class="du kg kh ki kj b">modprobe -v [module]</code>输出信息及其依赖关系</li></ol><p id="ad84" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">诸如此类。</p><p id="abdb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Linux 自动处理硬件驱动程序，但有时需要强制解决问题，这是因为通过网络寻址的设备无法知道那里有什么，这是存储区域、网络和打印机的常见情况，但如果硬件是本地的，还有另一个名为<code class="du kg kh ki kj b">depmod</code>的实用工具，因此，为了在引导时自动加载，您必须:</p><ol class=""><li id="1e0c" class="kl km hi ih b ii ij im in iq kn iu ko iy kp jc kq kr ks kt bi translated"><code class="du kg kh ki kj b">mkdir /etc/modules-load.d</code>(应包括模块名称)</li><li id="e3c8" class="kl km hi ih b ii ku im kv iq kw iu kx iy ky jc kq kr ks kt bi translated">然后:<code class="du kg kh ki kj b">sudo vi /etc/modules-load.d/dm_mirror.conf</code>(每个文件对应一个模块)，在里面输入模块的名字:<code class="du kg kh ki kj b">dm_mirror</code>就这样</li></ol><p id="6774" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">对于反向列表(相反):</p><ol class=""><li id="82fb" class="kl km hi ih b ii ij im in iq kn iu ko iy kp jc kq kr ks kt bi translated"><code class="du kg kh ki kj b">sudo vi /etc/modprobe.d/ctxfi.conf</code>在里面你应该输入模块的名字:<code class="du kg kh ki kj b">blacklist [module]</code>，就这样</li><li id="0211" class="kl km hi ih b ii ku im kv iq kw iu kx iy ky jc kq kr ks kt bi translated">引导时，不会加载该模块。</li></ol><h1 id="8651" class="jd je hi bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">服务</h1><p id="f61e" class="pw-post-body-paragraph if ig hi ih b ii kb ik il im kc io ip iq kd is it iu ke iw ix iy kf ja jb jc hb bi translated">简而言之，服务是由操作系统启动的进程，由不太新但很有名的<code class="du kg kh ki kj b">systemctl</code>管理。<code class="du kg kh ki kj b">systemctl</code>命令让你管理(启动、停止、重启、启用、禁用等)服务。</p><p id="25d0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在 CentOS 系统中,<code class="du kg kh ki kj b">SystemD</code>管理服务和其他对象，如设备、定时器和目标，其中每个对象都被称为<code class="du kg kh ki kj b">Units</code>,每个单元都有一个配置文件。</p><p id="dfdc" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">以下是一些例子:</p><ol class=""><li id="e338" class="kl km hi ih b ii ij im in iq kn iu ko iy kp jc kq kr ks kt bi translated"><code class="du kg kh ki kj b">systemctl list-unit-files -at service</code>这基本上显示所有启用的单元文件，服务配置为自动启动</li><li id="b963" class="kl km hi ih b ii ku im kv iq kw iu kx iy ky jc kq kr ks kt bi translated"><code class="du kg kh ki kj b">systemctl list-units -at service</code>显示已启用的运行服务</li></ol><p id="2f3a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">公共输出信息由服务名、单元文件状态、生成状态、当前状态和描述组成。可以过滤为:<code class="du kg kh ki kj b">systemctl list-units -t service --state running</code></p><p id="3f52" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">然而，您可以输出如下的详细信息:<code class="du kg kh ki kj b">systemctl cat [service]</code>这将显示关于服务的详细信息，包括依赖性、命令执行、失败等等。</p><p id="d85b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">出于管理目的，我们举了以下例子:</p><ol class=""><li id="7539" class="kl km hi ih b ii ij im in iq kn iu ko iy kp jc kq kr ks kt bi translated"><code class="du kg kh ki kj b">sudo systemctl stop atd</code>其中<code class="du kg kh ki kj b">atd</code>是流程的名称</li><li id="bb65" class="kl km hi ih b ii ku im kv iq kw iu kx iy ky jc kq kr ks kt bi translated"><code class="du kg kh ki kj b">sudo systemctl status [process]</code>用于了解状态</li><li id="f45d" class="kl km hi ih b ii ku im kv iq kw iu kx iy ky jc kq kr ks kt bi translated"><code class="du kg kh ki kj b">sudo systemctl start [process]</code>开始一个流程</li></ol><p id="2582" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">同样的模式适用于任何其他东西，你也可以运行:</p><ol class=""><li id="4072" class="kl km hi ih b ii ij im in iq kn iu ko iy kp jc kq kr ks kt bi translated"><code class="du kg kh ki kj b">sudo systemctl is-active [service]</code>了解服务是否启动</li><li id="52df" class="kl km hi ih b ii ku im kv iq kw iu kx iy ky jc kq kr ks kt bi translated"><code class="du kg kh ki kj b">sudo systemctl disable [service]</code>去禁用</li><li id="60c7" class="kl km hi ih b ii ku im kv iq kw iu kx iy ky jc kq kr ks kt bi translated">要启用一项服务，基本上，这使它成为永久性的</li></ol><h1 id="44d9" class="jd je hi bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">记录</h1><p id="8af5" class="pw-post-body-paragraph if ig hi ih b ii kb ik il im kc io ip iq kd is it iu ke iw ix iy kf ja jb jc hb bi translated">日志基本上是一个包含关于系统的消息的文件，不同的任务有不同的日志，您可以找到关于严重错误、失败错误、cronjobs 规约等等的日志。</p><p id="b701" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">CentOS 系统有两个记录系统<code class="du kg kh ki kj b">rsyslog</code>和<code class="du kg kh ki kj b">journald</code></p><ol class=""><li id="edc6" class="kl km hi ih b ii ij im in iq kn iu ko iy kp jc kq kr ks kt bi translated"><code class="du kg kh ki kj b">rsyslog</code>它与<code class="du kg kh ki kj b">sysklogd</code>兼容，用于持久日志。这些类型的日志是长文本文件，可以通过<code class="du kg kh ki kj b">TCP</code>或<code class="du kg kh ki kj b">UDP</code>远程捕获</li><li id="2770" class="kl km hi ih b ii ku im kv iq kw iu kx iy ky jc kq kr ks kt bi translated">默认情况下,<code class="du kg kh ki kj b">journald</code>是非持久的，它们不会存活到重启。它们是二进制格式的，存储在 RAM 中，也有固定的大小。但是可以通过一些策略来坚持</li></ol><p id="8020" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">您可以在<code class="du kg kh ki kj b">systemctl</code>命令的帮助下与<code class="du kg kh ki kj b">rsyslog</code>服务进行交互。所有的配置设置将在<code class="du kg kh ki kj b">/etc/rsyslog.conf</code></p><p id="d81e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><code class="du kg kh ki kj b">rsyslog</code>有一些规则，您可以设置哪个子系统可以生成系统消息及其标准(优先级)。此外，所有信息都将被写入<code class="du kg kh ki kj b">/var/log/messages</code></p><p id="56ee" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">另一方面，<code class="du kg kh ki kj b">journalctl</code>日志服务的处理方式不同。这里有一堆命令执行的例子</p><ol class=""><li id="8d8c" class="kl km hi ih b ii ij im in iq kn iu ko iy kp jc kq kr ks kt bi translated"><code class="du kg kh ki kj b">sudo journalctl</code>(所有条目)</li><li id="0d00" class="kl km hi ih b ii ku im kv iq kw iu kx iy ky jc kq kr ks kt bi translated"><code class="du kg kh ki kj b">sudo journalctl -k</code></li><li id="ff00" class="kl km hi ih b ii ku im kv iq kw iu kx iy ky jc kq kr ks kt bi translated"><code class="du kg kh ki kj b">sudo journalctl /sbin/crond</code></li><li id="3b27" class="kl km hi ih b ii ku im kv iq kw iu kx iy ky jc kq kr ks kt bi translated"><code class="du kg kh ki kj b">sudo journalctl -u crond</code></li></ol><p id="eecc" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为了使它永久保存，您需要为它创建一个特定的目录</p><pre class="ln lo lp lq fd lr kj ls lt aw lu bi"><span id="1e0d" class="kz je hi kj b fi lv lw l lx ly">[directory]<br/>sudo mkdir -p /var/log/journal<br/>[service]<br/>sudo systemctl restart systemd-journald<br/>[listing logs]<br/>ls -l /var/log/journal</span></pre><p id="7098" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">暂时就这些了。我敢肯定，更多的概念在这个时候失踪，所以请保持关注，这可能会定期更新。</p><p id="2bc3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">所有这些概念对于 Linux 管理员来说都是必须知道的，所以您可以把它看作是一个复习或学习材料。</p><p id="ee98" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">快乐编码:)</p></div></div>    
</body>
</html>