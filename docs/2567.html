<html>
<head>
<title>Super Palindrome — Google interview problem</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">超级回文——谷歌面试问题</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/super-palindrome-daily-challenge-may-c77eda18ed0f?source=collection_archive---------16-----------------------#2021-05-11">https://medium.com/nerd-for-tech/super-palindrome-daily-challenge-may-c77eda18ed0f?source=collection_archive---------16-----------------------#2021-05-11</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><figure class="hh hi ez fb hj hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es hg"><img src="../Images/10d715a434ff680a9579f88df7697f16.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*L_I-Jn8dxe8Q2j0-nJtyAg.jpeg"/></div></div></figure><div class=""/><p id="41a3" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">今天的问题来自每日 Leetcode 编码挑战赛——五月版。这是一个难以回答的问题。在过去的六个月里，这个问题已经被谷歌采访了 10 次。</p><h2 id="79b0" class="jo jp ht bd jq jr js jt ju jv jw jx jy jb jz ka kb jf kc kd ke jj kf kg kh ki bi translated"><a class="ae kj" href="https://leetcode.com/problems/super-palindromes/" rel="noopener ugc nofollow" target="_blank"> 906。</a>超级回文</h2><p id="c535" class="pw-post-body-paragraph iq ir ht is b it kk iv iw ix kl iz ja jb km jd je jf kn jh ji jj ko jl jm jn hb bi translated">假设一个正整数如果是回文，就是一个<strong class="is hu">超回文</strong>，也是一个回文的平方。</p><p id="89ce" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">给定两个正整数<code class="du kp kq kr ks b">left</code>和<code class="du kp kq kr ks b">right</code>表示为字符串，返回<em class="kt">包含范围</em> <code class="du kp kq kr ks b">[left, right]</code>内 <strong class="is hu"> <em class="kt">超级回文</em> </strong> <em class="kt">整数的个数。</em></p><h2 id="b28d" class="jo jp ht bd jq jr js jt ju jv jw jx jy jb jz ka kb jf kc kd ke jj kf kg kh ki bi translated">示例:</h2><pre class="ku kv kw kx fd ky ks kz la aw lb bi"><span id="c66d" class="jo jp ht ks b fi lc ld l le lf"><strong class="ks hu">Input:</strong> left = "4", right = "1000"<br/><strong class="ks hu">Output:</strong> 4<br/><strong class="ks hu">Explanation</strong>: 4, 9, 121, and 484 are superpalindromes.<br/>Note that 676 is not a superpalindrome: 26 * 26 = 676, but 26 is not a palindrome.</span></pre><h2 id="3721" class="jo jp ht bd jq jr js jt ju jv jw jx jy jb jz ka kb jf kc kd ke jj kf kg kh ki bi translated">理解问题:</h2><p id="f147" class="pw-post-body-paragraph iq ir ht is b it kk iv iw ix kl iz ja jb km jd je jf kn jh ji jj ko jl jm jn hb bi translated">回文不那么频繁。所以我们不是找到它们，而是建造它们。这有助于降低时间复杂度。对于任何给定的数字，我们都可以从中构建 11 个回文。例如，使用 24，我们可以构建 2442 或 24 个{0..9}42.所以一个回文有偶数个数字，另外 10 个有奇数个数字。在生成回文的过程中，我们检查回文是否超出了 sqrt 的范围(上限)。</p><p id="50a5" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">代码实现:</p><pre class="ku kv kw kx fd ky ks kz la aw lb bi"><span id="5be1" class="jo jp ht ks b fi lc ld l le lf">def check(n):<br/>    return int(str(n)[::-1]) == n<br/>    <br/>def superpalindromesInRange(left, right):<br/>    res = 0;<br/>    l = int(left)<br/>    r = int(right)<br/>    palindrome = []<br/>    for i in range(1, 10):<br/>        palindrome.append(i)<br/>    for i in range(1, 10000):<br/>        s1 = str(i)<br/>        s2 = str(i);<br/>        s2 = "".join(reversed(s2))<br/>        p = int(s1+s2)<br/>        if p &gt; math.sqrt(r):<br/>            break<br/>        else:<br/>            palindrome.append(int(s1+s2))<br/>        for j in range(10):<br/>            temp = s1<br/>            temp += str(j)<br/>            temp += s2;<br/>            if int(temp) &gt; math.sqrt(r):<br/>                break<br/>            else:<br/>                palindrome.append(int(temp))<br/>    for item in palindrome:<br/>        num = item * item<br/>        if(num &lt;= r and num &gt;=l and check(num)):<br/>            res += 1<br/>    return res</span></pre><h2 id="f5ef" class="jo jp ht bd jq jr js jt ju jv jw jx jy jb jz ka kb jf kc kd ke jj kf kg kh ki bi translated">复杂性分析:</h2><p id="422b" class="pw-post-body-paragraph iq ir ht is b it kk iv iw ix kl iz ja jb km jd je jf kn jh ji jj ko jl jm jn hb bi translated">时间复杂度:这个解决方案本质上是对数的。正如我们所看到的，对于范围 1-100，外部循环只运行一次。对于 10⁶，它运行 100 次。对于 10 ⁰它运行约 200 次。</p><p id="79c8" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">当我们存储回文时，空间复杂度也是对数的。</p><h2 id="2ba1" class="jo jp ht bd jq jr js jt ju jv jw jx jy jb jz ka kb jf kc kd ke jj kf kg kh ki bi translated">洞察力</h2><p id="5b7c" class="pw-post-body-paragraph iq ir ht is b it kk iv iw ix kl iz ja jb km jd je jf kn jh ji jj ko jl jm jn hb bi translated">让我们从基础开始，做一个回文的垂直乘法。如果数字是 abba，那么下图解释了垂直乘法。</p><figure class="ku kv kw kx fd hk er es paragraph-image"><div class="er es lg"><img src="../Images/168d651bae1bbb19a12d889a8214f41c.png" data-original-src="https://miro.medium.com/v2/resize:fit:978/format:webp/1*PFLRfAKHzSAgMb8hLIJNzA.png"/></div></figure><p id="fbd9" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">对于每个数字，平方值的位数将是(a，2ab，2ab+b，2a +2b，2ab+b，2ab，a)。所有数字中最大的是 2a +2b。只要这个数字小于 10，乘积就是一个回文。如果它大于 10，那么将有一个结转，两端的数字将不会相同。这将导致正方形不变色。</p><p id="bdbb" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们需要将数字空间减少到只有[0，1，2，3]，因为这些数字的平方不会导致进位。超级回文的平方根包含数字 3 的唯一情况是 3，因为否则，添加到 3 的平方的任何其他数字都将导致进位(3*3 + 1*1)。所以我们甚至可以把它的数字空间减少到[0，1，2]。</p><p id="9d06" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">代码实现:</p><pre class="ku kv kw kx fd ky ks kz la aw lb bi"><span id="105b" class="jo jp ht ks b fi lc ld l le lf">class Solution:<br/>    def superpalindromesInRange(self, left, right):<br/>        l, r, self.ans = int(left) ** 0.5, int(right) ** 0.5, 0<br/>        def helper(s):<br/>            if len(s) &lt; 5:<br/>                for d in '012': <br/>                    helper(s + d)<br/>            elif s != '0' * 5:<br/>                left = str(int(s))<br/>                coeff = 2 * sum(int(x) ** 2 for x in left)<br/>                if coeff &lt; 10 and l &lt;= int(left + left[::-1]) &lt;= r:<br/>                    self.ans += 1<br/>                coeff -= int(left[-1]) ** 2<br/>                if coeff &lt; 10 and l &lt;= int(left + left[-2::-1]) &lt;= r:<br/>                    self.ans += 1<br/>            return self.ans<br/>        return helper('') + (l &lt;= 3 &lt;= r)<br/>s = Solution()<br/>print(s.superpalindromesInRange(4, 1000 ))</span></pre><p id="b64b" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">编码快乐！！</p></div></div>    
</body>
</html>