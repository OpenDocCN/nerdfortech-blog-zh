<html>
<head>
<title>Rotate CloudEndure Access Keys for an IAM user in Multiple Accounts!</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在多个帐户中为一个 IAM 用户轮换 cloud bearing 访问密钥！</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/rotate-cloudendure-access-keys-for-an-iam-user-in-multiple-accounts-b21563d23d0d?source=collection_archive---------0-----------------------#2020-11-10">https://medium.com/nerd-for-tech/rotate-cloudendure-access-keys-for-an-iam-user-in-multiple-accounts-b21563d23d0d?source=collection_archive---------0-----------------------#2020-11-10</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="63fc" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">一个完全自动化的指南+ Lambda 代码，用于在多个 AWS 帐户之间轮换 IAM 密钥。</h2></div><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ix"><img src="../Images/5eb7830a6d09e7e7f521a352e8e51b7a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*wX6rC2G8qcaHi3N5"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx translated"><a class="ae jn" href="https://unsplash.com/@brookelark" rel="noopener ugc nofollow" target="_blank">https://unsplash.com/@brookelark</a></figcaption></figure><h2 id="216d" class="jo jp hi bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">背景</h2><p id="be06" class="pw-post-body-paragraph km kn hi ko b kp kq ij kr ks kt im ku jz kv kw kx kd ky kz la kh lb lc ld le hb bi translated">如果您在 EC2 上运行需要访问 AWS 服务的应用程序，AWS 强烈建议定期更改访问密钥(由访问密钥 ID 和秘密访问密钥组成)。这是一个众所周知的安全最佳实践，因为它缩短了访问密钥的有效时间，因此减少了它们被破坏时的业务影响。</p><p id="c5e9" class="pw-post-body-paragraph km kn hi ko b kp lf ij kr ks lg im ku jz lh kw kx kd li kz la kh lj lc ld le hb bi translated">因此，请定期更换访问密钥，并确保您帐户中的所有 IAM 用户都这样做。这样，如果访问密钥在您不知情的情况下遭到破坏，您就限制了凭据可用于访问您的资源的时间。您还可以选择他们必须这样做的频率。</p><p id="4aa4" class="pw-post-body-paragraph km kn hi ko b kp lf ij kr ks lg im ku jz lh kw kx kd li kz la kh lj lc ld le hb bi translated">也就是说，角色使用自动过期和自动更新的临时安全凭证，因此您不必担心访问密钥轮换——AWS 会为您完成这项工作。<strong class="ko hj">但是，如果您在 EC2 之外的地方运行应用程序，您应该将访问密钥轮换添加到您的应用程序管理过程中。</strong></p><p id="553c" class="pw-post-body-paragraph km kn hi ko b kp lf ij kr ks lg im ku jz lh kw kx kd li kz la kh lj lc ld le hb bi translated">这就是麻烦的开始。因为要为一个 EC2 手动执行此操作，您需要遵循以下步骤:</p><ol class=""><li id="7a33" class="lk ll hi ko b kp lf ks lg jz lm kd ln kh lo le lp lq lr ls bi translated">除了正在使用的访问密钥之外，创建第二个访问密钥。</li><li id="04af" class="lk ll hi ko b kp lt ks lu jz lv kd lw kh lx le lp lq lr ls bi translated">更新您的所有应用程序以使用新的访问密钥，并验证应用程序正在工作。</li><li id="a391" class="lk ll hi ko b kp lt ks lu jz lv kd lw kh lx le lp lq lr ls bi translated">将先前访问键的状态更改为非活动状态。</li><li id="f668" class="lk ll hi ko b kp lt ks lu jz lv kd lw kh lx le lp lq lr ls bi translated">验证您的应用程序是否仍按预期工作。</li><li id="c4cf" class="lk ll hi ko b kp lt ks lu jz lv kd lw kh lx le lp lq lr ls bi translated">删除不活动的访问键。</li></ol><p id="0ca5" class="pw-post-body-paragraph km kn hi ko b kp lf ij kr ks lg im ku jz lh kw kx kd li kz la kh lj lc ld le hb bi translated">想象一下，对 1000 个 ec2 和多个帐户执行上述所有操作！</p><p id="6847" class="pw-post-body-paragraph km kn hi ko b kp lf ij kr ks lg im ku jz lh kw kx kd li kz la kh lj lc ld le hb bi translated"><strong class="ko hj">自动化就是答案！</strong></p><p id="b160" class="pw-post-body-paragraph km kn hi ko b kp lf ij kr ks lg im ku jz lh kw kx kd li kz la kh lj lc ld le hb bi translated">令人欣慰的是，cloud bearing 提供了 API 来编排创建、列出和更新现有键的整个过程。这个文档<a class="ae jn" href="https://console.cloudendure.com/api_doc/apis.html" rel="noopener ugc nofollow" target="_blank">这里</a>有详细的东西解释。这些 API 托管在 web 服务器上，以 JSON 格式存储所有数据。</p><p id="9cfe" class="pw-post-body-paragraph km kn hi ko b kp lf ij kr ks lg im ku jz lh kw kx kd li kz la kh lj lc ld le hb bi translated"><strong class="ko hj">代码在哪里？</strong></p><p id="050e" class="pw-post-body-paragraph km kn hi ko b kp lf ij kr ks lg im ku jz lh kw kx kd li kz la kh lj lc ld le hb bi translated">在我们进入编码部分之前，让我们先来看看我是如何实现的。我用 postman 做了几天的实验，才得出最终的解决方案。从<strong class="ko hj">开始，在</strong>登录:</p><pre class="iy iz ja jb fd ly lz ma mb aw mc bi"><span id="eff0" class="jo jp hi lz b fi md me l mf mg">session = requests.Session()<br/>session.headers.update({'Content-type': 'application/json', 'Accept': 'text/plain'})</span><span id="5424" class="jo jp hi lz b fi mh me l mf mg">login_data = {'userApiToken': api_token}<br/>resp = session.post(url=HOST+ENDPOINT.format('login'),<br/>data = json.dumps(login_data))</span></pre><p id="0c9f" class="pw-post-body-paragraph km kn hi ko b kp lf ij kr ks lg im ku jz lh kw kx kd li kz la kh lj lc ld le hb bi translated">我使用请求库中的会话来持久化 cookies，这样我就可以再次使用同一个会话进行多次请求。通过这样做，我们可以持久化令牌</p><pre class="iy iz ja jb fd ly lz ma mb aw mc bi"><span id="c5b5" class="jo jp hi lz b fi md me l mf mg">session.headers['X-XSRF-TOKEN'] = session.cookies.get('XSRF-TOKEN')</span></pre><p id="8048" class="pw-post-body-paragraph km kn hi ko b kp lf ij kr ks lg im ku jz lh kw kx kd li kz la kh lj lc ld le hb bi translated">因此，为了更新和管理两个不同的控制台，我用登录 api 创建了两个单独的会话，如下所示。</p><pre class="iy iz ja jb fd ly lz ma mb aw mc bi"><span id="205d" class="jo jp hi lz b fi md me l mf mg">a_session = _login(userapi_token['a'])<br/>b_session = _login(userapi_token['b'])</span></pre><p id="88eb" class="pw-post-body-paragraph km kn hi ko b kp lf ij kr ks lg im ku jz lh kw kx kd li kz la kh lj lc ld le hb bi translated">然后使用<strong class="ko hj"> cloudCredentials </strong>来获取每个 cloud bearing 项目的 creds id。</p><pre class="iy iz ja jb fd ly lz ma mb aw mc bi"><span id="7fc7" class="jo jp hi lz b fi md me l mf mg">url = "https://console.cloudendure.com/api/latest/cloudCredentials"<br/>a_response = a_session.get(url).json()['items']<br/>b_response = b_session.get(url).json()['items']</span><span id="ad05" class="jo jp hi lz b fi mh me l mf mg">for item in a_response:<br/>    item.update({"ce_session":'a'})</span><span id="9ce2" class="jo jp hi lz b fi mh me l mf mg">for item in b_response:<br/>    item.update({"ce_session":'b'})</span><span id="8203" class="jo jp hi lz b fi mh me l mf mg">return a_response + b_response</span></pre><p id="46ca" class="pw-post-body-paragraph km kn hi ko b kp lf ij kr ks lg im ku jz lh kw kx kd li kz la kh lj lc ld le hb bi translated">但是想法是将它们合并在一起，创建一个单一的 json。为了稍后识别哪个会话将用于更新，我添加了一个名为<strong class="ko hj"> ce_session </strong>的额外键来识别它。</p><p id="7f8e" class="pw-post-body-paragraph km kn hi ko b kp lf ij kr ks lg im ku jz lh kw kx kd li kz la kh lj lc ld le hb bi translated">最初的 json 结果是这样的:</p><pre class="iy iz ja jb fd ly lz ma mb aw mc bi"><span id="c023" class="jo jp hi lz b fi md me l mf mg">[<br/>            {<br/>                "accountIdentifier": "xxx1",<br/>                "cloud": "xxx-xxx-xxx",<br/>                "id": "abcde",<br/>                "publicKey": "XXXX"<br/>            },<br/>            {<br/>                "accountIdentifier": "xxx2",<br/>                "cloud": "xxx-xxx-xxx",<br/>                "id": "vwxyz",<br/>                "publicKey": "YYYY"<br/>            }<br/>]</span></pre><p id="52c9" class="pw-post-body-paragraph km kn hi ko b kp lf ij kr ks lg im ku jz lh kw kx kd li kz la kh lj lc ld le hb bi translated">请注意，云 id 在此范围内保持不变，因为我只使用了 AWS 帐户。</p><p id="21f5" class="pw-post-body-paragraph km kn hi ko b kp lf ij kr ks lg im ku jz lh kw kx kd li kz la kh lj lc ld le hb bi translated"><strong class="ko hj">账户标识符</strong>是账户 id。<br/><strong class="ko hj">云</strong>是分配给云的 id。AWS/AZURE/GCP <br/></p><p id="364f" class="pw-post-body-paragraph km kn hi ko b kp lf ij kr ks lg im ku jz lh kw kx kd li kz la kh lj lc ld le hb bi translated">有了这些信息后，我创建了一个需要访问的 AWS 帐户列表。</p><p id="5496" class="pw-post-body-paragraph km kn hi ko b kp lf ij kr ks lg im ku jz lh kw kx kd li kz la kh lj lc ld le hb bi translated">下一步是创造新的信用。为此，我循环了之前的 AWS 帐户列表，并为每个帐户创建了一个会话。请注意，这是一个<strong class="ko hj"> boto3 </strong>会话。</p><p id="a7e1" class="pw-post-body-paragraph km kn hi ko b kp lf ij kr ks lg im ku jz lh kw kx kd li kz la kh lj lc ld le hb bi translated">在这个方法的第一部分，对于每个帐户，我列出了 IAM 密钥，检查它们是否超过 90 天，删除它们，并创建新的。</p><pre class="iy iz ja jb fd ly lz ma mb aw mc bi"><span id="cf73" class="jo jp hi lz b fi md me l mf mg">aws_creds = {}<br/>    new_creds = []<br/>    failed_accounts = []<br/>    for account in accounts_in_ce:<br/>        aws_session = create_session(account)<br/>        user = 'YourUserName'<br/>        user_iam_details, iam_client=list_access_key(aws_session, user)<br/>        if user_iam_details != None:<br/>            for _ in user_iam_details:<br/>                if _['days'] &gt;= 90:<br/>                    temp_creds_item = {}<br/>                    disable_key(iam_client=iam_client, access_key = _['AccessKeyId'], username=_['UserName'])<br/>                    delete_key(iam_client=iam_client, access_key = _['AccessKeyId'], username=_['UserName'])<br/>                    access_key, secret_access_key = create_key(iam_client=iam_client, username=_['UserName'])<br/>                    temp_creds_item['access_key'] = access_key<br/>                    temp_creds_item['secret_access_key'] = secret_access_key<br/>                    aws_creds[account]=temp_creds_item</span></pre><p id="150c" class="pw-post-body-paragraph km kn hi ko b kp lf ij kr ks lg im ku jz lh kw kx kd li kz la kh lj lc ld le hb bi translated">所有这些新的凭证都存储在一个 dict 结构中，以便进一步访问。</p><p id="91a1" class="pw-post-body-paragraph km kn hi ko b kp lf ij kr ks lg im ku jz lh kw kx kd li kz la kh lj lc ld le hb bi translated">下一部分将它们添加回 cloud bearing 的早期 json 中，以保持内容的一致性。</p><pre class="iy iz ja jb fd ly lz ma mb aw mc bi"><span id="178b" class="jo jp hi lz b fi md me l mf mg">for item in ce_creds:<br/>        temp_item = {}<br/>        temp_item['accountIdentifier'] = item['accountIdentifier']<br/>        temp_item['cloud'] = item['cloud']<br/>        temp_item['id'] = item['id']<br/>        temp_item['old_access_key'] = item['publicKey']<br/>        temp_item['ce_session'] = item['ce_session']<br/>        try:<br/>            temp_item['access_key'] = aws_creds[item['accountIdentifier']]['access_key']<br/>            temp_item['secret_access_key'] = aws_creds[item['accountIdentifier']]['secret_access_key']<br/>            new_creds.append(temp_item)<br/>        except:<br/>            print("Possible Key Error. Check List Access Keys for {}".format(item['accountIdentifier']))<br/>            failed_accounts.append(item['accountIdentifier'])<br/>            continue<br/>        <br/>return new_creds, list(set(failed_accounts))</span></pre><p id="151c" class="pw-post-body-paragraph km kn hi ko b kp lf ij kr ks lg im ku jz lh kw kx kd li kz la kh lj lc ld le hb bi translated">现在，我有了<strong class="ko hj">新的信用记录</strong>和一组<strong class="ko hj">失败的账户</strong>，我可以将它们报告给另一个团队进行纠正。</p><p id="8da8" class="pw-post-body-paragraph km kn hi ko b kp lf ij kr ks lg im ku jz lh kw kx kd li kz la kh lj lc ld le hb bi translated">因此，有了新的信用凭证，我这样做了:</p><pre class="iy iz ja jb fd ly lz ma mb aw mc bi"><span id="1d40" class="jo jp hi lz b fi md me l mf mg">for item in new_creds:<br/>        if item['ce_session']=='a':<br/>            set_cloudEndureCredentials(a_session, item['access_key'], item['secret_access_key'], item['id'], item['cloud'])<br/>        if item['ce_session']=='b':<br/>            set_cloudEndureCredentials(b_session, item['access_key'], item['secret_access_key'], item['id'], item['cloud'])</span></pre><p id="9b54" class="pw-post-body-paragraph km kn hi ko b kp lf ij kr ks lg im ku jz lh kw kx kd li kz la kh lj lc ld le hb bi translated">因为在更新两个不同的控制台时，它需要通过正确的会话。这就是我添加会话标识符的原因。(<strong class="ko hj"> ce_session </strong>)在代码的前面。</p><p id="7894" class="pw-post-body-paragraph km kn hi ko b kp lf ij kr ks lg im ku jz lh kw kx kd li kz la kh lj lc ld le hb bi translated">set_cloudEndureCredentials 使用补丁请求来更新 Cloud Endure Console 中的 creds。</p><pre class="iy iz ja jb fd ly lz ma mb aw mc bi"><span id="9ede" class="jo jp hi lz b fi md me l mf mg">creds = {<br/>        "cloudId":cloud_id,<br/>        "privateKey":base64.b64encode(bytes(private_key, 'utf-8')).decode('utf-8'),<br/>        "publicKey":public_key,<br/>        "id":creds_id<br/>    }<br/>    <br/>    resp = session.patch(url=HOST+ENDPOINT.format('cloudCredentials/{}'.format(creds_id)), data=json.dumps(creds))<br/>    <br/>    if resp.status_code != 200:<br/>        print('Failed setting credentails for project. Creds id - {}'.format(id))<br/>    else:<br/>        print('Credentials for project were set successfully')</span></pre><p id="15f8" class="pw-post-body-paragraph km kn hi ko b kp lf ij kr ks lg im ku jz lh kw kx kd li kz la kh lj lc ld le hb bi translated">这个请求需要 creds_id 作为端点和有效负载数据。使用保持不变的<strong class="ko hj"> CloudId </strong>、作为秘密访问密钥的<strong class="ko hj"> privateKey </strong>、<strong class="ko hj"> publicKey </strong>和<strong class="ko hj"> id </strong>即 creds_id 来构造有效载荷数据。</p><p id="7568" class="pw-post-body-paragraph km kn hi ko b kp lf ij kr ks lg im ku jz lh kw kx kd li kz la kh lj lc ld le hb bi translated">就是这样。如果您计划每 30 天使用一次，这将自动为 CloudEndure 的多个帐户轮换 IAM 密钥。</p><p id="ed9d" class="pw-post-body-paragraph km kn hi ko b kp lf ij kr ks lg im ku jz lh kw kx kd li kz la kh lj lc ld le hb bi translated">我知道 a 使用了很多小函数，我到现在还没有解释，因为它们是不言自明的。下面是完整的 lambda 代码。</p><p id="2a23" class="pw-post-body-paragraph km kn hi ko b kp lf ij kr ks lg im ku jz lh kw kx kd li kz la kh lj lc ld le hb bi translated"><strong class="ko hj">大码</strong></p><pre class="iy iz ja jb fd ly lz ma mb aw mc bi"><span id="aced" class="jo jp hi lz b fi md me l mf mg">import boto3<br/>from boto3.session import Session<br/>from botocore.exceptions import ClientError<br/>from email.mime.multipart import MIMEMultipart<br/>from email.mime.text import MIMEText<br/>import datetime<br/>import json<br/>import requests<br/>import base64</span><span id="cf11" class="jo jp hi lz b fi mh me l mf mg">HOST = '<a class="ae jn" href="https://console.cloudendure.com'" rel="noopener ugc nofollow" target="_blank">https://console.cloudendure.com'</a><br/>ENDPOINT = '/api/latest/{}'</span><span id="4682" class="jo jp hi lz b fi mh me l mf mg">def list_access_key(session, user, secret_access_key=None):<br/>    iam_client = session.client('iam')<br/>    account_id = session.client('sts').get_caller_identity().get('Account')<br/>    try:<br/>        keydetails = iam_client.list_access_keys(UserName=user)<br/>    except Exception as e:<br/>        print("Not able to list keys for {}".format(account_id))<br/>        print(e)<br/>        return None, None<br/>    <br/>    key_details = {}<br/>    user_iam_details = []<br/>    # Some user may have 2 access keys. So iterating over them and listing the details of active access key.<br/>    for keys in keydetails['AccessKeyMetadata']:<br/>        days=time_diff(keys['CreateDate'])<br/>        if days &gt;= 0:<br/>            key_details['UserName']=keys['UserName']<br/>            key_details['AccessKeyId']=keys['AccessKeyId']<br/>            key_details['SecretAccessKeyId']=secret_access_key<br/>            key_details['days']=days<br/>            key_details['status']=keys['Status']<br/>            user_iam_details.append(key_details)<br/>            key_details={}<br/>    <br/>    return user_iam_details, iam_client</span><span id="d009" class="jo jp hi lz b fi mh me l mf mg">def time_diff(keycreatedtime):<br/>    now=datetime.datetime.now(datetime.timezone.utc)<br/>    diff=now-keycreatedtime<br/>    return diff.days</span><span id="e5b5" class="jo jp hi lz b fi mh me l mf mg">def create_key(iam_client, username):<br/>    access_key_metadata = iam_client.create_access_key(UserName=username)<br/>    access_key = access_key_metadata['AccessKey']['AccessKeyId']<br/>    secret_key = access_key_metadata['AccessKey']['SecretAccessKey']<br/>    return access_key,secret_key</span><span id="e10d" class="jo jp hi lz b fi mh me l mf mg">def disable_key(iam_client, access_key, username):<br/>    try:<br/>        iam_client.update_access_key(UserName=username, AccessKeyId=access_key, Status="Inactive")<br/>        print(access_key + " has been disabled.")<br/>    except ClientError as e:<br/>        print("The access key with id %s cannot be found" % access_key)</span><span id="e4c6" class="jo jp hi lz b fi mh me l mf mg">def delete_key(iam_client, access_key, username):<br/>    try:<br/>        iam_client.delete_access_key(UserName=username, AccessKeyId=access_key)<br/>        print (access_key + " has been deleted.")<br/>    except ClientError as e:<br/>        print("The access key with id %s cannot be found" % access_key)</span><span id="c29d" class="jo jp hi lz b fi mh me l mf mg">def _login(api_token):</span><span id="b406" class="jo jp hi lz b fi mh me l mf mg">global ENDPOINT</span><span id="2031" class="jo jp hi lz b fi mh me l mf mg">session = requests.Session()<br/> session.headers.update({'Content-type': 'application/json', 'Accept': 'text/plain'})<br/>    #  print ( 'Logging in...' )</span><span id="767f" class="jo jp hi lz b fi mh me l mf mg">login_data = {'userApiToken': api_token}<br/> resp = session.post(url=HOST+ENDPOINT.format('login'),<br/>      data=json.dumps(login_data))</span><span id="1d59" class="jo jp hi lz b fi mh me l mf mg">if resp.status_code != 200 and resp.status_code != 307:<br/>  print ( 'Could not login!' )</span><span id="11d6" class="jo jp hi lz b fi mh me l mf mg"># check if need to use a different API entry point<br/> if resp.history:<br/>  print ( 'URL Redirected...' )<br/>  ENDPOINT = '/' + '/'.join(resp.url.split('/')[3:-1]) + '/{}'<br/>  resp = session.post(url=HOST+ENDPOINT.format('login'),<br/>      data=json.dumps(login_data))</span><span id="4ad8" class="jo jp hi lz b fi mh me l mf mg">if session.cookies.get('XSRF-TOKEN'):<br/>  session.headers['X-XSRF-TOKEN'] = session.cookies.get('XSRF-TOKEN')</span><span id="1f72" class="jo jp hi lz b fi mh me l mf mg">return session</span><span id="7bd7" class="jo jp hi lz b fi mh me l mf mg">def get_cloudEndureCredentials(a_session, b_session):<br/>    url = "<a class="ae jn" href="https://console.cloudendure.com/api/latest/cloudCredentials" rel="noopener ugc nofollow" target="_blank">https://console.cloudendure.com/api/latest/cloudCredentials</a>"<br/>    a_response = a_session.get(url).json()['items']<br/>    b_response = b_session.get(url).json()['items']<br/>    <br/>    for item in a_response:<br/>        item.update({"ce_session":'a'})</span><span id="a56d" class="jo jp hi lz b fi mh me l mf mg">for item in b_response:<br/>         item.update({"ce_session":'b'})<br/>    <br/>    return a_response + b_response<br/>    <br/>def set_cloudEndureCredentials(session, public_key, private_key, creds_id, cloud_id):<br/>    creds = {<br/>        "cloudId":cloud_id,<br/>        "privateKey":base64.b64encode(bytes(private_key, 'utf-8')).decode('utf-8'),<br/>        "publicKey":public_key,<br/>        "id":creds_id<br/>    }<br/>    <br/>    resp = session.patch(url=HOST+ENDPOINT.format('cloudCredentials/{}'.format(creds_id)), data=json.dumps(creds))<br/>    <br/>    if resp.status_code != 200:<br/>        print('Failed setting credentails for project. Creds id - {}'.format(id))<br/>    else:<br/>        print('Credentials for project were set successfully')</span><span id="afc7" class="jo jp hi lz b fi mh me l mf mg">def create_session(target_account_id):<br/>    <br/>    sts_client = boto3.client('sts')<br/>    target_role_name = "target_role_name"<br/>    <br/>    resp = sts_client.assume_role(<br/>        RoleArn=f"arn:aws:iam::{target_account_id}:role/{target_role_name}",<br/>        RoleSessionName="CE"+str(target_account_id)<br/>    )<br/>    <br/>    # Now we have a session under assumed role<br/>    session = Session(<br/>        aws_access_key_id=resp['Credentials']['AccessKeyId'],<br/>        aws_secret_access_key=resp['Credentials']['SecretAccessKey'],<br/>        aws_session_token=resp['Credentials']['SessionToken']<br/>    )<br/>    <br/>    return session</span><span id="3d48" class="jo jp hi lz b fi mh me l mf mg">def get_accounts(ce_creds_json):<br/>    accounts = []<br/>    for item in ce_creds_json:<br/>        accounts.append(item['accountIdentifier'])<br/>    <br/>    return list(set(accounts))</span><span id="8726" class="jo jp hi lz b fi mh me l mf mg">def create_new_creds(accounts_in_ce, ce_creds):<br/>    aws_creds = {}<br/>    new_creds = []<br/>    failed_accounts = []<br/>    for account in accounts_in_ce:<br/>        aws_session = create_session(account)<br/>        user = 'YourUserName'<br/>        user_iam_details, iam_client=list_access_key(aws_session, user)<br/>        if user_iam_details != None:<br/>            for _ in user_iam_details:<br/>                if _['days'] &gt;= 90:<br/>                    temp_creds_item = {}<br/>                    disable_key(iam_client=iam_client, access_key = _['AccessKeyId'], username=_['UserName'])<br/>                    delete_key(iam_client=iam_client, access_key = _['AccessKeyId'], username=_['UserName'])<br/>                    access_key, secret_access_key = create_key(iam_client=iam_client, username=_['UserName'])<br/>                    temp_creds_item['access_key'] = access_key<br/>                    temp_creds_item['secret_access_key'] = secret_access_key<br/>                    aws_creds[account]=temp_creds_item<br/>    <br/>    for item in ce_creds:<br/>        temp_item = {}<br/>        temp_item['accountIdentifier'] = item['accountIdentifier']<br/>        temp_item['cloud'] = item['cloud']<br/>        temp_item['id'] = item['id']<br/>        temp_item['old_access_key'] = item['publicKey']<br/>        temp_item['ce_session'] = item['ce_session']<br/>        try:<br/>            temp_item['access_key'] = aws_creds[item['accountIdentifier']]['access_key']<br/>            temp_item['secret_access_key'] = aws_creds[item['accountIdentifier']]['secret_access_key']<br/>            new_creds.append(temp_item)<br/>        except:<br/>            print("Possible Key Error. Check List Access Keys for {}".format(item['accountIdentifier']))<br/>            failed_accounts.append(item['accountIdentifier'])<br/>            continue<br/>        <br/>    return new_creds, list(set(failed_accounts))<br/>        <br/>def lambda_handler(event, context):<br/>    userapi_token = {'a':'xxx', 'b':'yyy'}<br/>    a_session = _login(userapi_token['a'])<br/>    b_session = _login(userapi_token['b']) <br/>    <br/>    cloud_endure_credentials = get_cloudEndureCredentials(a_session, b_session)<br/>    <br/>    all_accounts_in_ce = get_accounts(cloud_endure_credentials)    <br/>    <br/>    new_creds, failed_accounts = create_new_creds(all_accounts_in_ce, cloud_endure_credentials)<br/>    <br/>    for item in new_creds:<br/>        if item['ce_session']=='a':<br/>            set_cloudEndureCredentials(a_session, item['access_key'], item['secret_access_key'], item['id'], item['cloud'])<br/>        if item['ce_session']=='b':<br/>            set_cloudEndureCredentials(b_session, item['access_key'], item['secret_access_key'], item['id'], item['cloud'])</span></pre><p id="7d30" class="pw-post-body-paragraph km kn hi ko b kp lf ij kr ks lg im ku jz lh kw kx kd li kz la kh lj lc ld le hb bi translated">使用您需要的代码，sts 承担访问多个帐户的角色，允许列出、创建、删除和禁用访问密钥。</p><p id="0c72" class="pw-post-body-paragraph km kn hi ko b kp lf ij kr ks lg im ku jz lh kw kx kd li kz la kh lj lc ld le hb bi translated">仅此而已。我希望你自己尝试一下，然后按下拍手键。如果您有任何问题，请随时写在下面。我会很乐意解决像我的其他职位。</p></div></div>    
</body>
</html>