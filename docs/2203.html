<html>
<head>
<title>JavaScript Promises. Part 3 — Promise Chaining</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript承诺。第3部分—承诺链</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/javascript-promises-part-3-promise-chaining-707ab6f1bbfc?source=collection_archive---------6-----------------------#2021-04-26">https://medium.com/nerd-for-tech/javascript-promises-part-3-promise-chaining-707ab6f1bbfc?source=collection_archive---------6-----------------------#2021-04-26</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/642de39b4247771c8cbd0d06e1507f0d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*BtnJxlZa2SN-IDlN"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">照片由<a class="ae iu" href="https://unsplash.com/@aidamarie_photography?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Aida L </a>在<a class="ae iu" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="05da" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在本系列的第<a class="ae iu" rel="noopener" href="/nerd-for-tech/javascript-promises-part-1-why-promises-d54ed05bdc9f"> 1 </a>和<a class="ae iu" rel="noopener" href="/nerd-for-tech/javascript-promises-part-2-fundamentals-e51e36c42fac"> 2 </a>部分中，我们了解了为什么要引入承诺，承诺是什么，以及如何创建承诺。在这一部分中，我们将通过理解如何将多个承诺链接在一起或简单地<strong class="ix hj">承诺链接</strong>来建立这一点。</p><p id="d291" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这是一个需要理解的重要概念，它是进一步异步JS概念的基础，如<strong class="ix hj"> async/await </strong>。</p><p id="8c25" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">到目前为止，我们只讨论了正在执行的单个异步任务。但是，如果我们必须连续执行多个异步任务，并且每个任务都是在前一个任务完成之后执行的，那该怎么办呢？</p><p id="8d24" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">为了理解这一点，我们必须绝对清楚一件事</p><blockquote class="jt"><p id="c301" class="ju jv hi bd jw jx jy jz ka kb kc js dx translated">从承诺的处理程序返回的任何值都将被包装为承诺</p></blockquote><p id="a978" class="pw-post-body-paragraph iv iw hi ix b iy kd ja jb jc ke je jf jg kf ji jj jk kg jm jn jo kh jq jr js hb bi translated">这意味着，如果我们从类似于<code class="du ki kj kk kl b">then</code>、<code class="du ki kj kk kl b">catch</code>或<code class="du ki kj kk kl b">finally</code>的承诺处理器返回一个值，它将被包装成一个承诺。</p><p id="b125" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">让我们试一个例子。尝试在控制台中编写以下代码摘录。</p><figure class="kn ko kp kq fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es km"><img src="../Images/7d9ef7a47e11c5f72408442967d19160.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EmjORF5r66aYPr-4VcW1Eg.png"/></div></div></figure><p id="f8a2" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">尝试在控制台中记录变量<code class="du ki kj kk kl b">secondObject</code>，以检查其类型。您将获得以下输出</p><figure class="kn ko kp kq fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es kr"><img src="../Images/7015e875115aa9ea09497f5d68a64631.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Bsz-hnOyciYio6I-B284gg.png"/></div></div></figure><p id="d278" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">从这个例子可以清楚地看出，<code class="du ki kj kk kl b">secondObject</code>不是一个数字，事实上是一个承诺，重申了我们之前的观点:</p><blockquote class="ks kt ku"><p id="2d7d" class="iv iw kv ix b iy iz ja jb jc jd je jf kw jh ji jj kx jl jm jn ky jp jq jr js hb bi translated">从承诺的处理程序返回的任何值都将被包装为承诺</p></blockquote><p id="563d" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">那么，我们如何消费处理程序返回的承诺呢？简单。就像我们用<code class="du ki kj kk kl b">then/catch/finally</code>处理程序消费任何其他承诺一样。</p><p id="b635" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">因此，如果我们想从前面的例子中得到值2，那么就对promise <code class="du ki kj kk kl b">secondObject</code>应用另一个<code class="du ki kj kk kl b">then</code>处理程序，或者更好的方法是，简单地将新的<code class="du ki kj kk kl b">then</code>处理程序添加到前面的<code class="du ki kj kk kl b">then</code>处理程序中，如下所示</p><figure class="kn ko kp kq fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es km"><img src="../Images/6ba470b4635f7d42e1dca7fc4875c483.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZHH3J43ZhqZStvOqFXF7ww.png"/></div></div></figure><p id="11aa" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">现在将打印2。</p><p id="43c1" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">将多个承诺链接在一起的过程称为<strong class="ix hj">承诺链接。</strong></p><p id="4b22" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">使用<strong class="ix hj">承诺链</strong>，我们可以处理多个连续的异步操作，因为每个处理程序只有在它的前一个完成后才会被执行。</p></div><div class="ab cl kz la gp lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="hb hc hd he hf"><p id="6af8" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">让我们看一个真实世界的例子。</p><p id="9a5d" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">假设您正在构建一个社交媒体应用程序，用户可以在其中创建帖子、添加评论。有点像脸书。但没有毒性:d .作为管理员用户，您希望在您的仪表板中看到系统中的所有用户和第一个用户的所有帖子。</p><p id="4999" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">你必须连续做两件事:</p><ol class=""><li id="0aca" class="lg lh hi ix b iy iz jc jd jg li jk lj jo lk js ll lm ln lo bi translated">获取所有用户</li><li id="5452" class="lg lh hi ix b iy lp jc lq jg lr jk ls jo lt js ll lm ln lo bi translated">获取与第一个用户相关的所有帖子</li></ol><p id="0f63" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们将使用<code class="du ki kj kk kl b">fetch</code> API来发出HTTP请求，并且我们将使用`<a class="ae iu" href="https://jsonplaceholder.typicode.com/" rel="noopener ugc nofollow" target="_blank">https://jsonplaceholder.typicode.com/</a>'作为这个例子的API提供者。</p><p id="6439" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">要获取所有用户，我们可以使用下面的代码</p><figure class="kn ko kp kq fd ij"><div class="bz dy l di"><div class="lu lv l"/></div></figure><p id="2150" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">很正常的东西。我们将检索用户列表的URL传递给<code class="du ki kj kk kl b">fetch</code>方法。<code class="du ki kj kk kl b">fetch</code>进行网络调用并返回一个承诺，我们使用<code class="du ki kj kk kl b">then</code>处理程序访问该承诺。</p><p id="d3af" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">但是请注意我们在这里是如何使用承诺链的。<br/>这是因为来自<code class="du ki kj kk kl b">fetch</code> API的响应将属于<a class="ae iu" href="https://developer.mozilla.org/en-US/docs/Web/API/Response" rel="noopener ugc nofollow" target="_blank">响应</a>类型。<br/>为了从响应中提取JSON主体内容，我们使用了<code class="du ki kj kk kl b"><a class="ae iu" href="https://developer.mozilla.org/en-US/docs/Web/API/Body/json" rel="noopener ugc nofollow" target="_blank">.json()</a></code>方法，该方法返回一个承诺，包装JSON主体。所以我们的<code class="du ki kj kk kl b">users</code>数组将在第二个<code class="du ki kj kk kl b">then</code>处理程序中可用。</p><p id="33e3" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">现在让我们看一下用户访问不同帖子的代码</p><figure class="kn ko kp kq fd ij"><div class="bz dy l di"><div class="lu lv l"/></div></figure><p id="08c8" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">类似于前面的代码。唯一的区别是在箭头函数中使用了隐式返回。</p><p id="a12e" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">现在我们有两个独立的承诺链，它们执行两种不同的异步操作。我们需要将它们结合在一起以实现我们的目标。你是怎么做到的？</p><figure class="kn ko kp kq fd ij"><div class="bz dy l di"><div class="lu lv l"/></div></figure><p id="297d" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在我们的第二个then处理程序中，我们将获取操作返回给用户获取帖子(第6行)。通过使用这个简单的步骤，我们可以连续地链接和执行多个异步操作。</p></div><div class="ab cl kz la gp lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="hb hc hd he hf"><h1 id="b207" class="lw lx hi bd ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt bi translated">错误处理</h1><p id="fb55" class="pw-post-body-paragraph iv iw hi ix b iy mu ja jb jc mv je jf jg mw ji jj jk mx jm jn jo my jq jr js hb bi translated">出了问题怎么办？如何处理承诺链中的错误？</p><p id="8608" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">记得在本系列的第二部分<a class="ae iu" rel="noopener" href="/nerd-for-tech/javascript-promises-part-2-fundamentals-e51e36c42fac">中，我们已经提到过。如果你还没看过，就去看看吧。</a></p><blockquote class="ks kt ku"><p id="3a5c" class="iv iw kv ix b iy iz ja jb jc jd je jf kw jh ji jj kx jl jm jn ky jp jq jr js hb bi translated">是否使用<code class="du ki kj kk kl b">catch </code>块，或者在<code class="du ki kj kk kl b">then</code>块中处理错误，取决于我们的需求和承诺是否链接在一起。我们将在下一节深入探讨承诺链。现在，只要记住在<code class="du ki kj kk kl b">then</code>块本身中处理错误是可能的。</p></blockquote><p id="908b" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在一个承诺链中，如果在一个<code class="du ki kj kk kl b">then</code>块中出现错误，可以在一个 <code class="du ki kj kk kl b">then</code>块之后的<strong class="ix hj">或一个<code class="du ki kj kk kl b">catch</code>块中处理。但是应该选哪个呢？这取决于问题的答案</strong></p><blockquote class="ks kt ku"><p id="4a21" class="iv iw kv ix b iy iz ja jb jc jd je jf kw jh ji jj kx jl jm jn ky jp jq jr js hb bi translated">错误应该打破整个承诺链吗？</p></blockquote><p id="791b" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如果错误不会中断链，则在以下<code class="du ki kj kk kl b">then</code>块之一中处理错误。<br/>如果错误导致链中断，不要在<code class="du ki kj kk kl b">then </code>模块中添加故障处理程序，而是提供一个<code class="du ki kj kk kl b">catch</code>模块。</p><p id="dc9f" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">让我们看看两者的实际应用</p><p id="83cf" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">首先，让我们产生一个错误。用一个不存在的URL替换我们之前的承诺链中的URL。因此初始提取本身会失败。执行代码。您将得到以下错误。</p><figure class="kn ko kp kq fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mz"><img src="../Images/e8d1f9ec6ef4d45d0f0f24ab1f21c1ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Zh2Er6oi-kHBLm7YDwzELQ.png"/></div></div></figure><p id="1e58" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们没有处理错误，所以在错误发生后，不会执行任何<code class="du ki kj kk kl b">then</code>处理程序。</p><p id="6931" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">现在让我们来处理错误。</p><h2 id="b1a7" class="na lx hi bd ly nb nc nd mc ne nf ng mg jg nh ni mk jk nj nk mo jo nl nm ms nn bi translated">通过不打破承诺链来处理错误</h2><p id="a042" class="pw-post-body-paragraph iv iw hi ix b iy mu ja jb jc mv je jf jg mw ji jj jk mx jm jn jo my jq jr js hb bi translated">如果在获取用户时发生错误，那么不是由第一个用户获取帖子，而是您想要获取系统中的所有帖子。换句话说，如果在此之前发生了错误，我们希望承诺链从某一点恢复。你是怎么做到的？</p><figure class="kn ko kp kq fd ij"><div class="bz dy l di"><div class="lu lv l"/></div></figure><p id="9768" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们添加一个函数(第7行)来处理链中第2个<code class="du ki kj kk kl b">then</code>(第3行)的错误情况。</p><p id="7b9e" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如果您观察，错误不会在直接的<code class="du ki kj kk kl b">then</code>块中处理。也就是说，如果promise链中发生了错误(在我们的例子中是在获取用户时)，错误将会在整个链中传播，直到到达错误处理函数(如果有的话)，然后执行该函数并恢复正常的链执行。</p><p id="2e69" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">执行代码，您将看到正常的链执行被恢复。</p><figure class="kn ko kp kq fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es no"><img src="../Images/75a98c028b1c9af3e2684583d6ba7c41.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sSGfjxKyHYcAEtreyCrM9A.png"/></div></div></figure><h2 id="1054" class="na lx hi bd ly nb nc nd mc ne nf ng mg jg nh ni mk jk nj nk mo jo nl nm ms nn bi translated">通过打破承诺链来处理错误</h2><p id="97f8" class="pw-post-body-paragraph iv iw hi ix b iy mu ja jb jc mv je jf jg mw ji jj jk mx jm jn jo my jq jr js hb bi translated">但是，如果一旦发生错误，我们不希望任何块被执行，该怎么办呢？<br/>为此，在链的末尾添加一个catch块，作为promise链的全局错误处理程序。</p><figure class="kn ko kp kq fd ij"><div class="bz dy l di"><div class="lu lv l"/></div></figure><p id="8a53" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这里，我们在链的末端使用catch块来处理promise链中的任何错误。</p><p id="864d" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">执行代码，一旦出现错误，就会看到链断开。</p><figure class="kn ko kp kq fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es np"><img src="../Images/aed1591da0d2be4745c1e2218163ec62.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EPEUcSFftqUTvgpSe6k0Xg.png"/></div></div></figure></div><div class="ab cl kz la gp lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="hb hc hd he hf"><p id="c978" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在本文中，我们学习了什么是承诺链，如何将承诺链在一起，以及承诺链中不同的错误处理方法。</p><p id="1cf3" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如果你觉得这篇文章很有帮助，请鼓掌并分享给你的朋友。如果你有任何建议/意见，请告诉我。请务必关注我，因为我们将通过了解不同的承诺方法<strong class="ix hj"> Promise.any() </strong>、<strong class="ix hj"> Promise.all() </strong>以及<strong class="ix hj"> async/await </strong>来构建这个平台。</p></div></div>    
</body>
</html>