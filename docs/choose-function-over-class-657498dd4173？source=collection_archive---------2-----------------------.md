# 选择函数而不是类

> 原文：<https://medium.com/nerd-for-tech/choose-function-over-class-657498dd4173?source=collection_archive---------2----------------------->

![](img/230713038c030bfe3fdcd7b0454dcb21.png)

杰克·吉文斯在 [Unsplash](https://unsplash.com?utm_source=medium&utm_medium=referral) 上的照片

> 声明:我绝不声称函数总是比类好，这是函数比类更重要的案例研究。

> 一段时间以前，我开始在我目前的组织中提倡使用函数式编程，并卷入了一场关于开发人员倾向于使用类来实现功能的争论。当时，我无法推理，因此我们使用类。这个博客是一个案例研究，我们如何应用一个类解决方案，后来意识到函数更好。

我们构建 Firebase 包装器时考虑到了以下几点:
1 .封装 firebase 功能的包装器。
2。确保我们没有多次初始化 firebase，并且类作为事实的单一来源。

我相信有多种方法可以做到这一点，比如，有一个名为登录的界面，并确保所有的授权码都使用它，但这是一个稍后的故事。让我们保持简单。

还有，“Firebase.class.ts”不是约定俗成的；为了便于本文的讨论，将其命名为。

一如既往地工作，只有当你看得更深时，你才会面对一个问题。几周后，我们将该应用程序部署到生产环境中(顺便说一句，我不能告诉你是哪种产品，但我可以告诉你，这是一个受欢迎的合作空间),我的经理打电话说它很慢。我不能为此责怪任何人，因为建造它的时间总是很可笑。

像其他开发一样，我生成了一个 lighthouse 报告，并开始分析 treemap 上的包，令我惊讶的是，所有的东西最初都是下载的。所以我偷懒加载了所有东西，但是我可以在 FCP 之前找到 firebase 加载，操！

为了解决这个问题，你可能会尝试这样做

哎呀，真倒霉。你不能因为构造函数总是被认为是同步的。因此，为了解决这个问题，您需要执行以下操作:

Class fanboys 可能会对上面的解决方案感到高兴，但是它很复杂，因为你让 Class 做了一些不应该做的事情。

上述方法的问题:
1。用异步构造函数扩展一个类会有一个限制。如果你需要在派生类的构造函数中调用`super`，你必须在没有`await`的情况下调用它。如果需要用`await`调用超级构造函数，会遇到 TypeScript 错误 2337: `Super calls are not permitted outside constructors or in nested functions inside constructors.`
2。有人认为让构造函数返回承诺是一种“不好的做法”。

正如埃里克·埃利奥特[所说](/javascript-scene/the-dao-of-immutability-9f91a70c88cd#4226)它:

> *“有时候，优雅的实现只是一个函数。不是方法。不是一个班。不是框架。只是一个功能。”*

因此，救援功能。