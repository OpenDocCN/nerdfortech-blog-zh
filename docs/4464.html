<html>
<head>
<title>How does Change Detection mechanism work in Angular today?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如今 Angular 中的变化检测机制是如何工作的？</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/how-does-change-detection-mechanism-work-in-angular-today-d2363a375fb5?source=collection_archive---------1-----------------------#2021-07-22">https://medium.com/nerd-for-tech/how-does-change-detection-mechanism-work-in-angular-today-d2363a375fb5?source=collection_archive---------1-----------------------#2021-07-22</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/db3c870a12d620bca6cb339bf61b83a2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*kzYWXOZg52xUG7-v"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">劳拉·奥克尔在<a class="ae iu" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><p id="3542" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">大多数 Angular 开发人员认为变化检测(以后我会将其命名为 CD)是对象，但这不是真的。当我们的应用程序启动时，Angular 通过两个部分的初始化阶段:</p><ul class=""><li id="124b" class="jt ju hi ix b iy iz jc jd jg jv jk jw jo jx js jy jz ka kb bi translated">构建组件树</li><li id="fa3b" class="jt ju hi ix b iy kc jc kd jg ke jk kf jo kg js jy jz ka kb bi translated">运行变化检测</li></ul><p id="e848" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">组件树是增量树，其节点是类别<strong class="ix hj">视图的对象。 </strong> Angular 为每个组件创建一个视图。类视图对象扮演了一个容器的角色，它包含了所有需要的信息和逻辑来寻找应用程序的状态，并在我们的屏幕上反映这些变化。变化检测机制是每个视图对象的一部分。</p><h1 id="55df" class="ki kj hi bd kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf bi translated">视图状态</h1><p id="a5b9" class="pw-post-body-paragraph iv iw hi ix b iy lg ja jb jc lh je jf jg li ji jj jk lj jm jn jo lk jq jr js hb bi translated">每个视图都有一个状态，这个状态起着非常重要的作用，因为根据它的值，CD 决定是对视图及其所有子视图运行变更检测，还是跳过它。视图状态可以有以下值(您不需要记住它们，因为它们可以随版本的不同而变化):</p><ol class=""><li id="0b57" class="jt ju hi ix b iy iz jc jd jg jv jk jw jo jx js ll jz ka kb bi translated">首次检查</li><li id="5ded" class="jt ju hi ix b iy kc jc kd jg ke jk kf jo kg js ll jz ka kb bi translated">已启用检查</li><li id="384f" class="jt ju hi ix b iy kc jc kd jg ke jk kf jo kg js ll jz ka kb bi translated">出错</li><li id="313e" class="jt ju hi ix b iy kc jc kd jg ke jk kf jo kg js ll jz ka kb bi translated">破坏</li></ol><p id="8c19" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如果 ChecksEnabled 为 false 或者视图处于 Errored 或 Destroyed 状态，则更改检测会跳过视图及其子视图。默认情况下，所有视图都用 ChecksEnabled 进行初始化，除非 ChangeDetectionStrategy。使用 OnPush。这些状态可以组合在一起，例如，一个视图可以同时设置错误和销毁标志。CD 由以下事件触发:</p><ol class=""><li id="c3a6" class="jt ju hi ix b iy iz jc jd jg jv jk jw jo jx js ll jz ka kb bi translated">微任务(例如 Promise)</li><li id="ec9e" class="jt ju hi ix b iy kc jc kd jg ke jk kf jo kg js ll jz ka kb bi translated">宏任务(例如 setTimeout)</li><li id="c3e3" class="jt ju hi ix b iy kc jc kd jg ke jk kf jo kg js ll jz ka kb bi translated">浏览器事件(例如点击)</li></ol><p id="6700" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">得益于 zone.js 库，实现了对浏览器环境打补丁，跟踪所有上述事件。ng zone(zone . js 的 Angular wrapper)用它来自动调用 CD 机制。如果没有它，我们会手动调用 CD。不幸的是，大多数开发人员认为<strong class="ix hj">输入</strong>值的改变也会调用 CD。这不是真的。</p><h1 id="2285" class="ki kj hi bd kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf bi translated">变化检测逻辑</h1><p id="3ad4" class="pw-post-body-paragraph iv iw hi ix b iy lg ja jb jc lh je jf jg li ji jj jk lj jm jn jo lk jq jr js hb bi translated">正如我上面提到的，每个视图对象中都有一个包含 CD 逻辑的方法。该方法名称和该逻辑的步骤顺序是不相关的，因为它们在版本之间是变化的。我们的目标是理解主旨。</p><ol class=""><li id="0ed4" class="jt ju hi ix b iy iz jc jd jg jv jk jw jo jx js ll jz ka kb bi translated">检查视图状态。ChecksEnabled(如果为 false，则 CD 不处理该对象及其后代)</li><li id="d24d" class="jt ju hi ix b iy kc jc kd jg ke jk kf jo kg js ll jz ka kb bi translated">设置视图状态。如果视图是第一次被检查，则 FirstState 为 true，如果之前已经被检查过，则为 false</li><li id="67be" class="jt ju hi ix b iy kc jc kd jg ke jk kf jo kg js ll jz ka kb bi translated">检查和更新子组件/指令实例的输入属性</li><li id="1e38" class="jt ju hi ix b iy kc jc kd jg ke jk kf jo kg js ll jz ka kb bi translated">更新子视图更改检测状态</li><li id="6d6f" class="jt ju hi ix b iy kc jc kd jg ke jk kf jo kg js ll jz ka kb bi translated">为嵌入式视图运行 CD(重复列表中的步骤)</li><li id="7efd" class="jt ju hi ix b iy kc jc kd jg ke jk kf jo kg js ll jz ka kb bi translated">如果绑定更改，调用子组件上的 OnChanges 生命周期挂钩</li><li id="ab15" class="jt ju hi ix b iy kc jc kd jg ke jk kf jo kg js ll jz ka kb bi translated">对子组件调用 OnInit 和 ngDoCheck(on init 仅在第一次检查时调用)</li><li id="d7dc" class="jt ju hi ix b iy kc jc kd jg ke jk kf jo kg js ll jz ka kb bi translated">更新子视图组件实例上的 ContentChildren 查询列表</li><li id="47bc" class="jt ju hi ix b iy kc jc kd jg ke jk kf jo kg js ll jz ka kb bi translated">在子组件实例上调用 AfterContentInit 和 AfterContentChecked 生命周期挂钩(仅在第一次检查时调用 AfterContentInit)</li><li id="09c3" class="jt ju hi ix b iy kc jc kd jg ke jk kf jo kg js ll jz ka kb bi translated">如果<strong class="ix hj">当前视图(</strong>组件实例)中的属性发生变化，则更新<strong class="ix hj">当前视图</strong>的 DOM 插值</li><li id="5d4b" class="jt ju hi ix b iy kc jc kd jg ke jk kf jo kg js ll jz ka kb bi translated">为子视图运行 CD(重复此列表中的步骤)</li><li id="f125" class="jt ju hi ix b iy kc jc kd jg ke jk kf jo kg js ll jz ka kb bi translated">更新当前视图组件实例上的 ViewChildren 查询列表</li><li id="9f15" class="jt ju hi ix b iy kc jc kd jg ke jk kf jo kg js ll jz ka kb bi translated">在子组件实例上调用 AfterViewInit 和 AfterViewChecked 生命周期挂钩(仅在第一次检查时调用 AfterViewInit)</li><li id="eedd" class="jt ju hi ix b iy kc jc kd jg ke jk kf jo kg js ll jz ka kb bi translated">禁用对当前视图的检查</li></ol><p id="5727" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我想强调的事情不多。</p><p id="90b9" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">首先，我想提醒你注意数字 4 下面的台阶。CD 设置视图状态。checks 仅当其输入属性被更改时才在子视图中启用，否则不执行任何操作。</p><p id="8a7d" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">其次，我们可以提一下数字 6 下的步骤，说 ngOnChanges()甚至可以调用 ViewState。CheckesEnabled 设置为 false</p><p id="a4f7" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">第三，DOM 更新(数字 10 以下的步骤)一个元素一个元素地进行。在更新绑定了某个类属性 Angular 的每个元素之前，将该属性的当前值与属性<strong class="ix hj"> oldValues </strong>中存储的值进行比较。如果这些值是不同的角度，则更新该元素(通过参考值进行比较)。</p><p id="8897" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">最后，只有当我们使用 ChangeDetectionStrategy 时，CD 才会禁用对当前视图的检查(数字 14 下的步骤)。<strong class="ix hj"> OnPush </strong>。这是两种策略之间的一个区别。正是因为这个原因，默认策略每次被触发时都会遍历整个树，而 OnPush 则不会。</p><h2 id="6a45" class="lm kj hi bd kk ln lo lp ko lq lr ls ks jg lt lu kw jk lv lw la jo lx ly le lz bi translated">发展模式</h2><p id="b08d" class="pw-post-body-paragraph iv iw hi ix b iy lg ja jb jc lh je jf jg li ji jj jk lj jm jn jo lk jq jr js hb bi translated">在开发模式下，Angular 运行 CD 两次，以检查自第一次运行以来该值是否发生了变化。在生产模式下，更改检测仅运行一次，以获得更好的性能。为了避免这种情况，我们必须明白第二个 CD 调用是放在包含 CD 逻辑的函数中的，所以我们无法中断第二个循环来更新旧值。为了避免错误<strong class="ix hj">ExpressionChangedAfterCheckedError</strong>我们可以<strong class="ix hj"> : </strong></p><ol class=""><li id="509f" class="jt ju hi ix b iy iz jc jd jg jv jk jw jo jx js ll jz ka kb bi translated">在第二个循环中递归调用 CD 来更新属性<strong class="ix hj"> oldValues </strong>。(例如 detectChanges())</li><li id="d5f3" class="jt ju hi ix b iy kc jc kd jg ke jk kf jo kg js ll jz ka kb bi translated">CD 为获得当前值而必须执行的指令，使其成为微任务或宏任务。在这些情况下，第二个循环没有得到新的值，所以它使用了上次循环中存储在变量中的值，这是我们需要的</li><li id="eb03" class="jt ju hi ix b iy kc jc kd jg ke jk kf jo kg js ll jz ka kb bi translated">更改应用程序逻辑，使这种情况不存在</li></ol><h2 id="8ae4" class="lm kj hi bd kk ln lo lp ko lq lr ls ks jg lt lu kw jk lv lw la jo lx ly le lz bi translated">ChangeDetectionRef 方法</h2><p id="3f93" class="pw-post-body-paragraph iv iw hi ix b iy lg ja jb jc lh je jf jg li ji jj jk lj jm jn jo lk jq jr js hb bi translated">假设我们有以下组件树:</p><figure class="mb mc md me fd ij er es paragraph-image"><div class="er es ma"><img src="../Images/b946929a7f983d9ca3d7720a0b5e3a27.png" data-original-src="https://miro.medium.com/v2/resize:fit:1096/format:webp/1*3MttPB9GjdGhv5SWuUSIiA.png"/></div></figure><p id="f17b" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如上所述，每个组件都与一个组件视图相关联。每个视图都用 ViewState 初始化。启用检查，这意味着当角度运行变化检测时，将检查树中的每个组件。</p><p id="c828" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">假设我们想要禁用组件及其子组件的变更检测。这很容易做到，我们只需要设置视图状态。ChecksEnabled 为 false。Angular 提供了使用 ChangeDetectionRef 对象作为接口，我们可以用它来解决我们的任务。</p><pre class="mb mc md me fd mf mg mh mi aw mj bi"><span id="4bc3" class="lm kj hi mg b fi mk ml l mm mn">class ChangeDetectorRef {<br/>  markForCheck (): void<br/>  detach (): void<br/>  reattach (): void<br/><br/>  detectChanges (): void<br/>  checkNoChanges (): void<br/>}</span></pre><p id="a62f" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">让我们来看看如何使用它。</p><h2 id="d598" class="lm kj hi bd kk ln lo lp ko lq lr ls ks jg lt lu kw jk lv lw la jo lx ly le lz bi translated">方法分离()</h2><p id="c14d" class="pw-post-body-paragraph iv iw hi ix b iy lg ja jb jc lh je jf jg li ji jj jk lj jm jn jo lk jq jr js hb bi translated">此方法只是禁用对当前视图的检查，设置视图状态。ChecksEnabled 为 false。我想提一下，那个视图的子视图也不会被检查。</p><h2 id="ab85" class="lm kj hi bd kk ln lo lp ko lq lr ls ks jg lt lu kw jk lv lw la jo lx ly le lz bi translated">方法重附属()</h2><p id="cf57" class="pw-post-body-paragraph iv iw hi ix b iy lg ja jb jc lh je jf jg li ji jj jk lj jm jn jo lk jq jr js hb bi translated">此方法只是启用对当前视图的检查，设置视图状态。ChecksEnabled 为 true。</p><h2 id="cdd2" class="lm kj hi bd kk ln lo lp ko lq lr ls ks jg lt lu kw jk lv lw la jo lx ly le lz bi translated">方法 markForCheck()</h2><p id="3036" class="pw-post-body-paragraph iv iw hi ix b iy lg ja jb jc lh je jf jg li ji jj jk lj jm jn jo lk jq jr js hb bi translated">attach 方法只对当前组件启用检查，但如果没有对其父组件启用更改检测，则不会影响。这意味着重附属方法只对禁用分支中最顶层的组件有用。方法<strong class="ix hj"> markForCheck() </strong>允许检查所有父组件，直到根组件。</p><h2 id="3e71" class="lm kj hi bd kk ln lo lp ko lq lr ls ks jg lt lu kw jk lv lw la jo lx ly le lz bi translated">方法检测更改()</h2><p id="9e05" class="pw-post-body-paragraph iv iw hi ix b iy lg ja jb jc lh je jf jg li ji jj jk lj jm jn jo lk jq jr js hb bi translated">该方法为当前组件及其所有子组件运行一次变更检测<strong class="ix hj"/>。此方法对当前组件视图运行更改检测，而不管其状态如何，这意味着对当前视图的检查可能保持禁用，并且在随后的常规更改检测运行期间不会检查组件</p><h2 id="4fb6" class="lm kj hi bd kk ln lo lp ko lq lr ls ks jg lt lu kw jk lv lw la jo lx ly le lz bi translated">方法 checkNoChanges()</h2><p id="cbab" class="pw-post-body-paragraph iv iw hi ix b iy lg ja jb jc lh je jf jg li ji jj jk lj jm jn jo lk jq jr js hb bi translated">最后一个方法确保值不被更改(它检查视图状态。ChecksEnabled)。如果发现已更改的绑定或确定应该更新 DOM，将引发异常。</p><p id="b654" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">感谢您的关注。我希望这篇文章能帮助你理解 Angular 中的变化检测机制。</p></div></div>    
</body>
</html>