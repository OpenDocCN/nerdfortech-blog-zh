<html>
<head>
<title>Implementing hitbox detection for melee combat | Unity</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">为近战战斗实现击中目标检测| Unity</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/implementing-hitbox-detection-for-melee-combat-unity-bc1912178e63?source=collection_archive---------2-----------------------#2021-10-15">https://medium.com/nerd-for-tech/implementing-hitbox-detection-for-melee-combat-unity-bc1912178e63?source=collection_archive---------2-----------------------#2021-10-15</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><h2 id="b21e" class="hg hh hi bd b fp hj hk hl hm hn ho dx hp translated" aria-label="kicker paragraph">统一指南</h2><div class=""/><div class=""><h2 id="e124" class="pw-subtitle-paragraph io hr hi bd b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf dx translated">关于如何在 Unity 的近战中实现一个识别生命盒的系统的快速指南</h2></div><figure class="jh ji jj jk fd jl er es paragraph-image"><div role="button" tabindex="0" class="jm jn di jo bf jp"><div class="er es jg"><img src="../Images/872f499a45a9906d74b69c23b8eb40a2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*yYU-ESUYG2BqVzzebHNijA.gif"/></div></div></figure><p id="b064" class="pw-post-body-paragraph js jt hi ju b jv jw is jx jy jz iv ka kb kc kd ke kf kg kh ki kj kk kl km kn hb bi translated">目标:在 Unity 的 2D 游戏中，实现一个系统来检测近战中易损坏的游戏对象的生命值。</p><p id="a59b" class="pw-post-body-paragraph js jt hi ju b jv jw is jx jy jz iv ka kb kc kd ke kf kg kh ki kj kk kl km kn hb bi translated">在上一篇文章中，我介绍了<a class="ae ko" href="https://fas444.medium.com/idamageable-interface-unity-45bf961d141" rel="noopener">如何在 Unity </a>中实现一个 IDamageable 接口。现在，是时候实现一个系统来识别近战中易受伤害的游戏对象的生命值，以便对它们造成伤害。</p><p id="ef2b" class="pw-post-body-paragraph js jt hi ju b jv jw is jx jy jz iv ka kb kc kd ke kf kg kh ki kj kk kl km kn hb bi translated">如果你还没有看到最后一个帖子，请花点时间来看看，因为它是 hitbox 检测机制的一个重要组成部分:</p><div class="kp kq ez fb kr ks"><a href="https://fas444.medium.com/idamageable-interface-unity-45bf961d141" rel="noopener follow" target="_blank"><div class="kt ab dw"><div class="ku ab kv cl cj kw"><h2 class="bd hs fi z dy kx ea eb ky ed ef hr bi translated">I 可成像界面| Unity</h2><div class="kz l"><h3 class="bd b fi z dy kx ea eb ky ed ef dx translated">关于如何在 Unity 中实现 IDamageable 接口的快速指南</h3></div><div class="la l"><p class="bd b fp z dy kx ea eb ky ed ef dx translated">fas444.medium.com</p></div></div><div class="lb l"><div class="lc l ld le lf lb lg jq ks"/></div></div></a></div><h1 id="5f23" class="lh li hi bd lj lk ll lm ln lo lp lq lr ix ls iy lt ja lu jb lv jd lw je lx ly bi translated">进攻时机</h1><p id="d868" class="pw-post-body-paragraph js jt hi ju b jv lz is jx jy ma iv ka kb mb kd ke kf mc kh ki kj md kl km kn hb bi translated">为了开始开发我们的 hitbox 检测系统，让我们在我们的玩家中创建一个新的游戏对象，它将代表剑攻击的起源:</p><div class="jh ji jj jk fd ab cb"><figure class="me jl mf mg mh mi mj paragraph-image"><div role="button" tabindex="0" class="jm jn di jo bf jp"><img src="../Images/9d6c7b1fc7659c164adc43a1612f7578.png" data-original-src="https://miro.medium.com/v2/resize:fit:988/1*HwQt5YjVdkT4GMyeDFMIBw.gif"/></div></figure><figure class="me jl mk mg mh mi mj paragraph-image"><img src="../Images/5a1bcfd09c7a2fe8bb1d12b0642b71c0.png" data-original-src="https://miro.medium.com/v2/resize:fit:980/1*C0ZKiFP-H_invmjpS85LEA.gif"/></figure></div><p id="6990" class="pw-post-body-paragraph js jt hi ju b jv jw is jx jy jz iv ka kb kc kd ke kf kg kh ki kj kk kl km kn hb bi translated">如果我们播放攻击动画，我们会看到该点位于攻击的中心:</p><figure class="jh ji jj jk fd jl er es paragraph-image"><div class="er es ml"><img src="../Images/33ebd408c00533aa9bdfc9a4a6d20866.png" data-original-src="https://miro.medium.com/v2/resize:fit:908/1*rrB9gGx96tAuQjWfK3Hi1A.gif"/></div></figure><h1 id="6824" class="lh li hi bd lj lk ll lm ln lo lp lq lr ix ls iy lt ja lu jb lv jd lw je lx ly bi translated">敌人层</h1><p id="44ca" class="pw-post-body-paragraph js jt hi ju b jv lz is jx jy ma iv ka kb mb kd ke kf mc kh ki kj md kl km kn hb bi translated">然后，为了在识别点击框时保持有序和简单，让我们为游戏中的敌人创建一个新层:</p><div class="jh ji jj jk fd ab cb"><figure class="me jl mm mg mh mi mj paragraph-image"><div role="button" tabindex="0" class="jm jn di jo bf jp"><img src="../Images/140504aa14cd7d384a39e118a82cf522.png" data-original-src="https://miro.medium.com/v2/resize:fit:1324/format:webp/1*obeCLg7QKp5T2fYpoU3vrg.png"/></div></figure><figure class="me jl mn mg mh mi mj paragraph-image"><div role="button" tabindex="0" class="jm jn di jo bf jp"><img src="../Images/212fdf1a87eefcd067708bc48ce871ac.png" data-original-src="https://miro.medium.com/v2/resize:fit:678/1*cldQvlRtKiHRqPbGP6w1Jg.gif"/></div></figure></div><h1 id="7cce" class="lh li hi bd lj lk ll lm ln lo lp lq lr ix ls iy lt ja lu jb lv jd lw je lx ly bi translated">攻击范围</h1><p id="2cf0" class="pw-post-body-paragraph js jt hi ju b jv lz is jx jy ma iv ka kb mb kd ke kf mc kh ki kj md kl km kn hb bi translated">接下来，为了确定我们攻击的范围，让我们打开玩家脚本并创建下一个变量:</p><ul class=""><li id="5f46" class="mo mp hi ju b jv jw jy jz kb mq kf mr kj ms kn mt mu mv mw bi translated">进攻时机</li></ul><p id="574c" class="pw-post-body-paragraph js jt hi ju b jv jw is jx jy jz iv ka kb kc kd ke kf kg kh ki kj kk kl km kn hb bi translated">该变量将存储一个对攻击源转换的引用，以便了解每个攻击的位置。</p><ul class=""><li id="001f" class="mo mp hi ju b jv jw jy jz kb mq kf mr kj ms kn mt mu mv mw bi translated">攻击范围</li></ul><p id="2d06" class="pw-post-body-paragraph js jt hi ju b jv jw is jx jy jz iv ka kb kc kd ke kf kg kh ki kj kk kl km kn hb bi translated">这个变量将决定我们从攻击起点开始的攻击范围。</p><ul class=""><li id="93c7" class="mo mp hi ju b jv jw jy jz kb mq kf mr kj ms kn mt mu mv mw bi translated">攻击面具</li></ul><p id="0ff9" class="pw-post-body-paragraph js jt hi ju b jv jw is jx jy jz iv ka kb kc kd ke kf kg kh ki kj kk kl km kn hb bi translated">这个变量将指示在执行攻击时我们将在哪一层识别碰撞体。</p><figure class="jh ji jj jk fd jl er es paragraph-image"><div class="er es mx"><img src="../Images/ec35a4504beb07b3779a042d95fe6fc5.png" data-original-src="https://miro.medium.com/v2/resize:fit:912/format:webp/1*EbmlDkdV9HRlF2mcei3hHw.png"/></div></figure><p id="4f19" class="pw-post-body-paragraph js jt hi ju b jv jw is jx jy jz iv ka kb kc kd ke kf kg kh ki kj kk kl km kn hb bi translated">如果我们想要可视化攻击范围，我们可以利用<strong class="ju hs">小发明中的变量。在<strong class="ju hs"> OnDrawGizmos </strong>方法处绘制 WireSphere </strong>方法:</p><figure class="jh ji jj jk fd jl er es paragraph-image"><div role="button" tabindex="0" class="jm jn di jo bf jp"><div class="er es my"><img src="../Images/58760f0091e5cf275f550694b34dce8d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*30HfzbkzfnwLR7LwASUOkg.png"/></div></div></figure><p id="78d9" class="pw-post-body-paragraph js jt hi ju b jv jw is jx jy jz iv ka kb kc kd ke kf kg kh ki kj kk kl km kn hb bi translated">一旦我们通过检查器为变量分配了各自的值，我们就能够在场景视图中可视化攻击范围:</p><div class="jh ji jj jk fd ab cb"><figure class="me jl mz mg mh mi mj paragraph-image"><div role="button" tabindex="0" class="jm jn di jo bf jp"><img src="../Images/0b2d7b43dff308aa4b4edf1da642d22d.png" data-original-src="https://miro.medium.com/v2/resize:fit:942/1*DVeOpPrGHnE8kWFsSk9WVw.gif"/></div></figure><figure class="me jl na mg mh mi mj paragraph-image"><img src="../Images/a48f565a5cf4b3da4dce07b80b48812a.png" data-original-src="https://miro.medium.com/v2/resize:fit:850/1*HVcQc2QacSrI_iFG3pNe3w.gif"/></figure></div><p id="0738" class="pw-post-body-paragraph js jt hi ju b jv jw is jx jy jz iv ka kb kc kd ke kf kg kh ki kj kk kl km kn hb bi translated">这样，当我们执行攻击时，我们攻击范围内的所有东西都会受到影响:</p><figure class="jh ji jj jk fd jl er es paragraph-image"><div role="button" tabindex="0" class="jm jn di jo bf jp"><div class="er es jg"><img src="../Images/d3907981eef9bb3d6de4daf8bbded10c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*uuVeFW2lw_6dUR5h5fF1yQ.gif"/></div></div></figure><h1 id="4aee" class="lh li hi bd lj lk ll lm ln lo lp lq lr ix ls iy lt ja lu jb lv jd lw je lx ly bi translated">识别 hitboxes</h1><p id="6c66" class="pw-post-body-paragraph js jt hi ju b jv lz is jx jy ma iv ka kb mb kd ke kf mc kh ki kj md kl km kn hb bi translated">现在，为了识别我们攻击范围内的生命值，让我们在玩家脚本中创建一个新方法，我们将:</p><ul class=""><li id="4d2f" class="mo mp hi ju b jv jw jy jz kb mq kf mr kj ms kn mt mu mv mw bi translated">使用<strong class="ju hs"> Physics2D 储存攻击范围内的所有对撞机。OverlapCircleAll </strong>方法，带有各自的参数(攻击来源、范围和层掩码)。</li><li id="265e" class="mo mp hi ju b jv nb jy nc kb nd kf ne kj nf kn mt mu mv mw bi translated">搜索每个碰撞器中的<strong class="ju hs">id 可损坏的</strong>组件，以了解它是否可损坏。</li><li id="e8b0" class="mo mp hi ju b jv nb jy nc kb nd kf ne kj nf kn mt mu mv mw bi translated">如果是这种情况，从组件调用<strong class="ju hs">损害</strong>方法来应用各自的损害。</li></ul><figure class="jh ji jj jk fd jl er es paragraph-image"><div role="button" tabindex="0" class="jm jn di jo bf jp"><div class="er es ng"><img src="../Images/197b740145fe36b8f7b814389635712c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5CGdwqAQof8r3YURVxIGPA.png"/></div></div></figure><p id="5c39" class="pw-post-body-paragraph js jt hi ju b jv jw is jx jy jz iv ka kb kc kd ke kf kg kh ki kj kk kl km kn hb bi translated">如果我们看一下<strong class="ju hs">伤害</strong>方法(由于<strong class="ju hs">idamagable</strong>接口而在敌人脚本中实现)我们会看到它从生命值中减去一个单位并触发相应的动画:</p><figure class="jh ji jj jk fd jl er es paragraph-image"><div class="er es nh"><img src="../Images/3ddbbe7b20d043b86f7568752a7106da.png" data-original-src="https://miro.medium.com/v2/resize:fit:1184/format:webp/1*GgGu86yknZbnoUzdr1JEjA.png"/></div></figure><p id="1286" class="pw-post-body-paragraph js jt hi ju b jv jw is jx jy jz iv ka kb kc kd ke kf kg kh ki kj kk kl km kn hb bi translated">最后，为了执行我们的<strong class="ju hs">攻击</strong>方法，让我们打开动画窗口，在攻击动画中剑攻击的确切帧处通过一个<strong class="ju hs">动画事件</strong>调用它:</p><div class="jh ji jj jk fd ab cb"><figure class="me jl ni mg mh mi mj paragraph-image"><div role="button" tabindex="0" class="jm jn di jo bf jp"><img src="../Images/a0cbe7257c193a5fa755f3918b035590.png" data-original-src="https://miro.medium.com/v2/resize:fit:1162/1*oza1fE7MJvyjTs_bLyE-YQ.gif"/></div></figure><figure class="me jl nj mg mh mi mj paragraph-image"><div role="button" tabindex="0" class="jm jn di jo bf jp"><img src="../Images/38aabec3baf5aaa950a3d32d3a210c0d.png" data-original-src="https://miro.medium.com/v2/resize:fit:840/1*WpnzArf-9aJ-eDyXkiI0OA.gif"/></div></figure></div><p id="24e1" class="pw-post-body-paragraph js jt hi ju b jv jw is jx jy jz iv ka kb kc kd ke kf kg kh ki kj kk kl km kn hb bi translated">如果我们在 Unity 中运行游戏，我们将能够看到攻击以预期的结果执行:</p><figure class="jh ji jj jk fd jl er es paragraph-image"><div role="button" tabindex="0" class="jm jn di jo bf jp"><div class="er es jg"><img src="../Images/917e6e4023ce2ced303e9a5cf8b2b9fe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*ofOinCeueheGZGZnPG9CDg.gif"/></div></div></figure><p id="0239" class="pw-post-body-paragraph js jt hi ju b jv jw is jx jy jz iv ka kb kc kd ke kf kg kh ki kj kk kl km kn hb bi translated">就这样，我们在 Unity 中实现了一个在近战中检测生命盒的系统！我会在下一篇文章中看到你，在那里我会展示如何在 Unity 中创建一个战利品系统。</p></div><div class="ab cl nk nl gp nm" role="separator"><span class="nn bw bk no np nq"/><span class="nn bw bk no np nq"/><span class="nn bw bk no np"/></div><div class="hb hc hd he hf"><blockquote class="nr ns nt"><p id="4311" class="js jt nu ju b jv jw is jx jy jz iv ka nv kc kd ke nw kg kh ki nx kk kl km kn hb bi translated"><em class="hi">如果你想了解我更多，欢迎登陆</em><a class="ae ko" href="https://www.linkedin.com/in/fas444/" rel="noopener ugc nofollow" target="_blank"><strong class="ju hs"><em class="hi">LinkedIn</em></strong></a><strong class="ju hs"><em class="hi"/></strong><em class="hi">或访问我的</em> <a class="ae ko" href="http://fernandoalcasan.com/" rel="noopener ugc nofollow" target="_blank"> <strong class="ju hs"> <em class="hi">网站</em> </strong> </a> <em class="hi"> :D </em></p></blockquote></div></div>    
</body>
</html>