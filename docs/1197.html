<html>
<head>
<title>Postgres FILLFACTOR — deep dive</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Postgres填充因子—深潜</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/postgres-fillfactor-baf3117aca0a?source=collection_archive---------1-----------------------#2021-03-09">https://medium.com/nerd-for-tech/postgres-fillfactor-baf3117aca0a?source=collection_archive---------1-----------------------#2021-03-09</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/b3affb7099c0d33a13eaf1d4207916fa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*VrqOGYPCskXMLnM1.png"/></div></div></figure><p id="0032" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在上一篇<a class="ae jo" href="https://virender-cse.medium.com/moving-oracle-to-postgres-be-aware-of-fillfactor-and-indexing-implications-fcec6596827a" rel="noopener">帖子</a>中，我们了解了Oracle与Postgres在MVCC性质上的差异，以及如何在Postgres中设置适当的填充因子值是有益的。让我们对此进行更深入的探讨。</p><p id="030a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">完全紧凑的表(FILLFACTOR = 100)将导致糟糕的更新性能，还可能导致索引碎片。而低填充因子值会导致表上的顺序扫描变慢，因为它必须读取更多部分填充的块。</p><p id="1df8" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj"> FILLFACTOR依赖因素:</strong></p><p id="db40" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">为了获得最佳的FILLFACTOR值，应该知道表上完整的更新模式，以及一个块可能需要多少空间来存储新版本的元组。</p><ul class=""><li id="946b" class="jp jq hi is b it iu ix iy jb jr jf js jj jt jn ju jv jw jx bi translated">更新是批量行更新还是单行更新？批量更新意味着可以在一个块中更新所有行。</li><li id="f2f3" class="jp jq hi is b it jy ix jz jb ka jf kb jj kc jn ju jv jw jx bi translated">新的更新数据扩展了行的大小？如果row的新版本比旧版本大，那么块将需要更多的空间来容纳它。</li><li id="cfab" class="jp jq hi is b it jy ix jz jb ka jf kb jj kc jn ju jv jw jx bi translated">一行在其生命周期中被更新一次还是多次？如果我们期望一行被多次更新，VACUUM应该频繁运行以清除死元组，从而为新的/更新的行腾出空间。</li><li id="ee56" class="jp jq hi is b it jy ix jz jb ka jf kb jj kc jn ju jv jw jx bi translated">长时间运行的SQL延迟真空清理死元组。如果VACUUM在一个表上延迟，死元组将不会被清除。</li></ul><p id="91ba" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">为简单起见，我们以OLTP系统中最常见的例子为例，在该系统中，更新查询通常只影响几行。让我们获取数据库中更新最多的表。</p><pre class="kd ke kf kg fd kh ki kj kk aw kl bi"><span id="4bc9" class="km kn hi ki b fi ko kp l kq kr">select<br/>   schemaname,<br/>   relname,<br/>   pg_size_pretty(pg_total_relation_size (relname::regclass)) as full_size,<br/>   pg_size_pretty(pg_relation_size(relname::regclass)) as table_size,<br/>   pg_size_pretty(pg_total_relation_size (relname::regclass) - pg_relation_size(relname::regclass)) as index_size,<br/>   n_tup_upd,<br/>   n_tup_hot_upd <br/>from<br/>   pg_stat_user_tables <br/>order by<br/>   n_tup_upd desc limit 10;</span><span id="fd9b" class="km kn hi ki b fi ks kp l kq kr">schemaname | relname | full_size | table_size | index_size | n_tup_upd | n_tup_hot_upd<br/>------------+----------+-----------+------------+------------+------<br/> public     | test     | 297 MB    | 182 MB     | 115 MB     |  46171448 |         13382<br/> public     | testtd   | 334 MB    | 244 MB     | 90 MB      |    260900 |             0</span></pre><p id="71f0" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">表FILACTLFOR: </strong></p><p id="17a6" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">表填充因子默认值为100。我们将采用两个用例:</p><ol class=""><li id="4127" class="jp jq hi is b it iu ix iy jb jr jf js jj jt jn kt jv jw jx bi translated">如果UPDATE query没有更新属于表上相应索引一部分的任何列。</li></ol><pre class="kd ke kf kg fd kh ki kj kk aw kl bi"><span id="c05d" class="km kn hi ki b fi ko kp l kq kr">postgres=&gt; create table test(id bigint) with (fillfactor = 90);<br/>CREATE TABLE</span><span id="f393" class="km kn hi ki b fi ks kp l kq kr">postgres=&gt; ALTER TABLE test SET (autovacuum_enabled = false);<br/>ALTER TABLE</span><span id="b0ad" class="km kn hi ki b fi ks kp l kq kr">postgres=&gt; insert into test SELECT temp.id from generate_series(1, 10000000) AS temp (id);<br/>INSERT 0 10000000</span><span id="1bed" class="km kn hi ki b fi ks kp l kq kr">postgres=&gt; \dt+ test<br/>Schema | Name | Type  |  Owner   |  Size  |--------+------+-------+----------+--------+<br/>public | test | table | postgres | 383 MB |</span><span id="2818" class="km kn hi ki b fi ks kp l kq kr">postgres=&gt; update test set id=id where id % 11 = 0;</span><span id="84e7" class="km kn hi ki b fi ks kp l kq kr">UPDATE 909090</span><span id="8692" class="km kn hi ki b fi ks kp l kq kr">postgres=&gt; \dt+ test<br/>Schema | Name | Type  |  Owner   |  Size  |--------+------+-------+----------+--------+<br/>public | test | table | postgres | 383 MB |</span><span id="3a4d" class="km kn hi ki b fi ks kp l kq kr">postgres=&gt; update test set id=id where id % 11 = 0;<br/>UPDATE 909090</span><span id="221b" class="km kn hi ki b fi ks kp l kq kr">postgres=&gt; \dt+ test<br/>Schema | Name | Type  |  Owner   |  Size  | Description<br/>--------+------+-------+----------+--------+-------------<br/>public | test | table | postgres | 383 MB |</span><span id="951a" class="km kn hi ki b fi ks kp l kq kr">postgres=&gt; update test set id=id where id % 11 = 0;<br/>UPDATE 909090</span><span id="d891" class="km kn hi ki b fi ks kp l kq kr">postgres=&gt; \dt+ test<br/>Schema | Name | Type  |  Owner   |  Size  | Description<br/>--------+------+-------+----------+--------+-------------<br/>public | test | table | postgres | 383 MB |</span></pre><p id="6e16" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在这种情况下，如果UPDATE query正在更新一些记录，那么我们可以将FILLFACTOR值保持在较高的值，比如90–95。这种更新方式适用于HOT，即使ctid改变也不会更新索引条目。随后，由于该块上的空间压力，小型块级真空将自动处理死元组，从而为块中新更新的行腾出空间。</p><p id="70b6" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">2.如果UPDATE query正在更新任何索引列，那么索引条目当然需要进行更改。因此，这里的低FILLFACTOR只对使UPADTE查询稍微快一点有用，因为它不需要寻找另一个空闲块并将新的行版本迁移到那里。</p><p id="e9c3" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在这样的表上设置填充因子的权衡是:</p><blockquote class="ku kv kw"><p id="7333" class="iq ir kx is b it iu iv iw ix iy iz ja ky jc jd je kz jg jh ji la jk jl jm jn hb bi translated"><strong class="is hj">更快的更新与更慢的顺序扫描和浪费的空间(部分填充的块)</strong></p></blockquote><p id="b37a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这种表的FILLFACTOR可以从一个值开始，该值是我们怀疑要更新的表中的行的百分比计算值(只是一个大概的数字)。</p><p id="e842" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj"> For Ex </strong> —应用程序被设计为每一行都需要在创建后不久更新。在这种情况下，FILLFACTOR值可以设置为50。</p><p id="c7b6" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这里的另一个方面是，我们需要确保VACUUM经常在这些表上运行，以便它删除死元组，并为块中新的更新行腾出空间。</p><p id="71f3" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">注意:</strong>表格创建后，填充因子值可以更改(增加或减少)。如果我们增加FILLFACTOR值，它也将被添加到空闲空间映射(FSM)中，因此有资格获得新的行。虽然稍后减少填充因子值，但不会影响已经填充超过新的填充因子值的块。</p><p id="e216" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj"> B树索引填充因子:</strong></p><p id="0c90" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">Postgres索引填充因子默认值为90。索引填充因子的功能与表填充因子不同。这里的区别在于新行是如何产生的——直接插入还是由更新引起的插入(删除然后插入)。</p><p id="cd09" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在表的情况下，新行插入服从FILLFACTOR值，Postgres不允许新行进入FILLFACTOR值以上的块，而在由更新引起的插入的情况下，它也允许那些新的版本化的行进入fill factor值以上的块(仅在可能的情况下在同一块内)。</p><p id="eaa4" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在使用索引FILLFACTOR的另一侧，两种类型的插入以相同的方式处理，即使设置FILLFACTOR值为90，新行也将适合FILLFACTOR值以上的块(单调增加的列除外)。</p><p id="e253" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">让我们举一个新数据进入索引叶块的例子</p><ol class=""><li id="8ff4" class="jp jq hi is b it iu ix iy jb jr jf js jj jt jn kt jv jw jx bi translated"><strong class="is hj">单调递增插入:</strong></li></ol><p id="c7e9" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如果新列值与现有键相比是最大的，则它不会填充FILLFACTOR值以上的块。发生块分割，新条目将进入新块。</p><p id="a20c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在下面的示例中，我们看到了两个索引之间的大小差异，因为FILLFACTOR值为90的索引将在块中保留10%的空间用于进一步的更新，因此当更新发生在该索引上时，其大小保持不变。</p><pre class="kd ke kf kg fd kh ki kj kk aw kl bi"><span id="6fdc" class="km kn hi ki b fi ko kp l kq kr">postgres=&gt; create table test(id bigint);<br/>CREATE TABLE</span><span id="b52c" class="km kn hi ki b fi ks kp l kq kr">postgres=&gt; CREATE INDEX idx1_test ON test (id) with (fillfactor = 100);<br/>CREATE INDEX</span><span id="8feb" class="km kn hi ki b fi ks kp l kq kr">postgres=&gt; CREATE INDEX idx2_test ON test (id); --fillfactor = 90 <br/>CREATE INDEX</span><span id="081e" class="km kn hi ki b fi ks kp l kq kr">postgres=&gt; insert into test SELECT temp.id from generate_series(1, 10000000) AS temp (id) ;<br/>INSERT 0 10000000</span><span id="adba" class="km kn hi ki b fi ks kp l kq kr">postgres=&gt; \di+ idx1_test<br/>Schema |   Name    | Type  |  Owner   | Table |  Size  |--------+-----------+-------+----------+-------+--------+<br/>public | idx1_test | index | postgres | test  | 193 MB |</span><span id="0b75" class="km kn hi ki b fi ks kp l kq kr">postgres=&gt; \di+ idx2_test<br/>Schema |   Name    | Type  |  Owner   | Table |  Size  |<br/>--------+-----------+-------+----------+-------+--------+<br/>public | idx2_test | index | postgres | test  | 214 MB |</span><span id="6408" class="km kn hi ki b fi ks kp l kq kr">postgres=&gt; update test set id = id+1 where id%100=0;<br/>UPDATE 100000</span><span id="db56" class="km kn hi ki b fi ks kp l kq kr">postgres=&gt; \di+ idx1_test<br/>Schema |   Name    | Type  |  Owner   | Table |  Size  |<br/>--------+-----------+-------+----------+-------+--------+<br/>public | idx1_test | index | postgres | test  | 386 MB |</span><span id="268c" class="km kn hi ki b fi ks kp l kq kr">postgres=&gt; \di+ idx2_test<br/>Schema |   Name    | Type  |  Owner   | Table |  Size  |<br/>--------+-----------+-------+----------+-------+--------+<br/>public | idx2_test | index | postgres | test  | 214 MB |</span></pre><p id="1450" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj"> 2。随机插入:</strong></p><p id="2093" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如果一个新的列值以随机顺序出现，那么它将填充块直到100%,然后发生50-50分割。</p><p id="b4d2" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在下面的例子中，我们看到，填充因子值为90和100的索引大小几乎相同。</p><p id="d440" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这里的索引大小与上一个示例中的100%压缩索引相比更大，因为50–50分割，因此许多块被部分填充。</p><pre class="kd ke kf kg fd kh ki kj kk aw kl bi"><span id="a1cb" class="km kn hi ki b fi ko kp l kq kr">postgres=&gt; insert into test SELECT ceil(random() * 10000000) from generate_series(1, 10000000) AS temp (id) ;<br/>INSERT 0 10000000</span><span id="f2e6" class="km kn hi ki b fi ks kp l kq kr">postgres=&gt; \di+ idx1_test<br/>Schema |   Name    | Type  |  Owner   | Table |  Size --------+-----------+-------+----------+-------+--------+<br/>public | idx1_test | index | postgres | test  | 278 MB |</span><span id="f933" class="km kn hi ki b fi ks kp l kq kr">postgres=&gt; \di+ idx2_test<br/>Schema |   Name    | Type  |  Owner   | Table |  Size  |<br/>--------+-----------+-------+----------+-------+--------+<br/>public | idx2_test | index | postgres | test  | 280 MB |</span><span id="54ad" class="km kn hi ki b fi ks kp l kq kr">postgres=&gt; update test set id = id+1 where id%100=0;<br/>UPDATE 99671</span><span id="0e82" class="km kn hi ki b fi ks kp l kq kr">postgres=&gt; \di+ idx1_test<br/>Schema |   Name    | Type  |  Owner   | Table |  Size  |--------+-----------+-------+----------+-------+--------+<br/>public | idx1_test | index | postgres | test  | 281 MB |</span><span id="5b03" class="km kn hi ki b fi ks kp l kq kr">postgres=&gt; \di+ idx2_test<br/>Schema |   Name    | Type  |  Owner   | Table |  Size  |<br/>--------+-----------+-------+----------+-------+--------+<br/>public | idx2_test | index | postgres | test  | 282 MB |</span></pre><p id="5438" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在，如果我们重新索引这些索引，它们将服从FILLFACTOR值。这就像在数据单调增加的表上创建一个新索引。</p><pre class="kd ke kf kg fd kh ki kj kk aw kl bi"><span id="81d3" class="km kn hi ki b fi ko kp l kq kr">postgres=&gt; Reindex index idx2_test;<br/>REINDEX</span><span id="b0ec" class="km kn hi ki b fi ks kp l kq kr">postgres=&gt; \di+ idx2_test     --fillfactor 90<br/>Schema |   Name    | Type  |  Owner   | Table |  Size  |--------+-----------+-------+----------+-------+--------+<br/>public | idx2_test | index | postgres | test  | 214 MB |</span><span id="812e" class="km kn hi ki b fi ks kp l kq kr">postgres=&gt; Reindex index idx1_test;<br/>REINDEX</span><span id="cd5b" class="km kn hi ki b fi ks kp l kq kr">postgres=&gt; \di+ idx1_test    --fillfactor 100<br/>Schema |   Name    | Type  |  Owner   | Table |  Size  |<br/>--------+-----------+-------+----------+-------+--------+<br/>public | idx1_test | index | postgres | test  | 193 MB |</span></pre><p id="c184" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">通过以上解释，我们看到索引填充因子在以下情况下是有用的:</p><ul class=""><li id="dce1" class="jp jq hi is b it iu ix iy jb jr jf js jj jt jn ju jv jw jx bi translated">存在一个预填充的表，我们需要创建一个新的索引，然后期望对表索引列进行大量更新(即使更新的列是其他索引的一部分，因为ctid的更改将传播到所有索引)。</li><li id="9980" class="jp jq hi is b it jy ix jz jb ka jf kb jj kc jn ju jv jw jx bi translated">索引在右侧扩展的表(最大的键值)，我们希望对表索引列进行许多更新。</li></ul><p id="9b3c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">结束语:</strong>我看到Oracle对表和索引的PCTFREE默认值分别是90和100，而Postgres对表和索引分别选择FILLFACTOR值为100和90。</p><p id="61a0" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">对于需要在许多表上使用DML的OLTP用例，您认为表和索引的默认值90和100更有意义吗？<strong class="is hj">欢迎在评论区提出建议、反馈和体验。</strong></p></div></div>    
</body>
</html>