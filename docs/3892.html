<html>
<head>
<title>React Context API in functional components using Hooks</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用钩子在功能组件中反应上下文API</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/react-context-api-in-functional-components-using-hooks-c80777bda5e3?source=collection_archive---------2-----------------------#2021-06-28">https://medium.com/nerd-for-tech/react-context-api-in-functional-components-using-hooks-c80777bda5e3?source=collection_archive---------2-----------------------#2021-06-28</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="d59b" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">了解React中的术语prop drilling，以及上下文API如何在React应用程序中避免prop drilling。</h2></div><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ix"><img src="../Images/4c0c61b2312620358ac26b4e097fdb25.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0RuS274IYfhOJm4x88NE2w.jpeg"/></div></div></figure><p id="011c" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">正如我在文章的副标题中提到的，上下文API有助于在我们的React应用程序中避免<strong class="jl hj">道具钻</strong>，如果你不知道术语<strong class="jl hj"> <em class="kf">道具钻</em> </strong>，这并没有什么错。所以让我们先了解一下。</p><p id="fdcf" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">在React中，我们只能单向传递数据，即通过props从上到下(从父到子)。Prop drilling是一个过程，在这个过程中，我们需要在一个深度嵌套的组件树中向下传递每个级别的Prop，以便我们可以在最低级别的组件中访问它们。让我们用一个例子来理解这一点，</p><p id="01df" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">考虑下图中给出的组件嵌套结构，我们有一个应用程序组件，然后与它嵌套，我们有另一个组件A。进一步的组件A有一个子组件B，然后组件B有一个子组件c。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es kg"><img src="../Images/2bc51524d79514ccd88a9e3b549745e0.png" data-original-src="https://miro.medium.com/v2/resize:fit:966/format:webp/1*PWB86aC_-a3dp0ldepyfzA.jpeg"/></div><figcaption class="kh ki et er es kj kk bd b be z dx translated">组件树</figcaption></figure><p id="fe2b" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">假设组件C需要来自App组件的一些数据(例如用户名),因此为了使其在组件C中可用，prop(用户名)也必须通过所有其他子组件传递，即我们必须将prop从App组件向下传递到组件A， 必须向下传递组件B中的属性，然后它通过组件B向下传递到组件c。即使组件A和组件B不需要属性用户名，但我们仍然必须通过它们传递属性，以便能够将其传递到树中更下面的组件。</p><p id="4bd4" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">但是这里有一个问题，为什么要将数据传递给所有那些中间组件，而它们根本不需要这些数据，只是帮助数据通过树传递呢？这就是我们在React中需要<strong class="jl hj">上下文API </strong>的地方。</p><blockquote class="kl km kn"><p id="c479" class="jj jk kf jl b jm jn ij jo jp jq im jr ko jt ju jv kp jx jy jz kq kb kc kd ke hb bi translated">React中的<strong class="jl hj"> <em class="hi"> Context </em> </strong>只是提供了一种将数据直接传递给所需组件的方式，而不是通过组件树的每一层来传递数据。</p></blockquote><p id="9f5a" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">因此，使用React上下文，我们不必向所有不需要道具的中间组件传递不必要的道具。因此，我们已经讨论了为什么需要上下文，现在让我们了解上下文API的一步一步的工作，以解决这个问题的道具钻井。</p><p id="8d4f" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated"><strong class="jl hj">注意:在我们深入研究上下文API的工作之前，建议先了解一下<em class="kf"> React </em> <em class="kf">钩子，如useState、useContext等。</em> </strong></p><p id="4eb5" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">让我们考虑这个非常基本的例子来理解React Context API的工作，其中我们在我们的<strong class="jl hj"> App.js </strong>中有一个<strong class="jl hj">博客</strong>集合，我们需要将这些数据传递给其他一些<strong class="jl hj">组件C </strong>(显然不是App.js的子组件)来呈现给浏览器。</p><p id="27f9" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">最初<strong class="jl hj"> App.js的代码结构— </strong></p><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es kr"><img src="../Images/9ff56b2599df572330846a91bd8e5db3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1374/format:webp/1*DtLbB27jZlyffY30QcyblA.jpeg"/></div><figcaption class="kh ki et er es kj kk bd b be z dx translated">App.js文件</figcaption></figure><p id="8a18" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated"><strong class="jl hj">组件A，</strong>也就是<strong class="jl hj">组件T5】只是渲染组件B，</strong></p><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es ks"><img src="../Images/6ce8e9be1be14694f9806b513de85512.png" data-original-src="https://miro.medium.com/v2/resize:fit:994/format:webp/1*_mB0zY9aaNlYgiqh3TqkUA.jpeg"/></div><figcaption class="kh ki et er es kj kk bd b be z dx translated">ComponentA.js文件</figcaption></figure><p id="e95e" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated"><strong class="jl hj">组件B </strong>，渲染组件C，</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es kt"><img src="../Images/8128c546189a09c7910d3badb8cdee55.png" data-original-src="https://miro.medium.com/v2/resize:fit:952/format:webp/1*7OziuLZfFmS1cFRKguhDvA.jpeg"/></div><figcaption class="kh ki et er es kj kk bd b be z dx translated">ComponentB.js文件</figcaption></figure><p id="fd7b" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">而<strong class="jl hj">组件C </strong>负责将所有数据渲染到与那些博客相关的浏览器上；</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ku"><img src="../Images/a571b57925ceaa3a560739376c5f56e5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mCQdCRRN04ZSJQi6l4E3nw.jpeg"/></div></div><figcaption class="kh ki et er es kj kk bd b be z dx translated">ComponentC.js文件</figcaption></figure><p id="e6eb" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">在这种情况下，一遍又一遍地通过props传递博客的数据可能会给应用程序带来问题。传递道具对开发者来说也很困难，因为有时你可能传递了比你需要的更多的道具，甚至忘记传递你确实需要的道具，等等。因此，在这种情况下，我们可以选择使用上下文API。</p><p id="8387" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated"><strong class="jl hj">步骤1:创建上下文— </strong></p><p id="0992" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">第一步是使用React的<strong class="jl hj"> createContext() </strong>方法创建一个上下文对象。所以在<strong class="jl hj"> BlogContext.js中，</strong>我们将创建一个上下文<strong class="jl hj"> BlogContext </strong>像这样</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es kv"><img src="../Images/e5ea43b59e0b0e56e0a17493fdf9eacf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*R9FLCSR7eyo3DOOIwa-GSQ.jpeg"/></div></div></figure><p id="ab65" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">这个createContext()方法接受一个参数作为状态或数据的默认值。虽然此默认参数值不是必需的，但只有当组件在树中没有任何匹配的提供程序时，才会使用它。</p><p id="ae3d" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">现在，我们已经创建了上下文，来自createContext的上下文对象总是带有另外两个React组件— <strong class="jl hj">提供者和消费者</strong>。接下来，我们将创建一个提供者组件。</p><p id="9135" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated"><strong class="jl hj">步骤2:创建一个提供者组件— </strong></p><p id="0b48" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">一个提供者组件基本上包含了我们希望与使用上下文的其他组件共享的所有状态或数据。这意味着在我们的例子中，我们需要将博客状态从我们的应用程序组件放到提供者组件中，</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es kw"><img src="../Images/ddf0ec672121af386b06500c77cf065b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1350/format:webp/1*PI7lSs-AojbiBwGRJuApuA.jpeg"/></div><figcaption class="kh ki et er es kj kk bd b be z dx translated">博客上下文. js文件</figcaption></figure><p id="64e2" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated"><strong class="jl hj">步骤3:包装组件并提供要传递的值- </strong></p><p id="26b2" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">使用context对象和provider组件，我们将包装所有想要共享数据的组件。但是我们不会从Context.js中呈现它们，而是使用它们的父组件(在本例中为App.js)来包装所有需要这些数据的子组件(在本例中仅为组件C)。</p><p id="f0cf" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">现在我们的<strong class="jl hj"> App.js </strong>看起来会像这样—</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es kx"><img src="../Images/fcedbdc11765f5806f461af214a9c72f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZQpcSyqLlZSbq6FAFohSsw.jpeg"/></div></div><figcaption class="kh ki et er es kj kk bd b be z dx translated">App.js文件</figcaption></figure><p id="e903" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">在BlogContext.js中，我们可以通过props从App.js访问这些子组件，因此这里我们将简单地在Provider组件中呈现<em class="kf"> {props.children} </em>，其中需要一个prop作为<em class="kf">值</em>，我们需要传递想要共享的数据，即我们案例中的博客状态。注意，只有当我们通过这个<em class="kf">值</em>属性传递上下文(数据)时，我们才能共享它。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es ky"><img src="../Images/b87780b4c45a62d8aa074bd3cb6a3b0d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1276/format:webp/1*5iYqRsVqe0lfzxLD1A99BQ.jpeg"/></div><figcaption class="kh ki et er es kj kk bd b be z dx translated">博客上下文. js文件</figcaption></figure><p id="efb8" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated"><strong class="jl hj">第四步:消费所需组件中的数据— </strong></p><p id="aa30" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">现在最后一步是使用<strong class="jl hj"> <em class="kf"> useContext </em> </strong>钩子消耗所需组件中的上下文值。</p><h2 id="ddd8" class="kz la hi bd lb lc ld le lf lg lh li lj js lk ll lm jw ln lo lp ka lq lr ls lt bi translated">使用上下文的步骤:</h2><p id="39d0" class="pw-post-body-paragraph jj jk hi jl b jm lu ij jo jp lv im jr js lw ju jv jw lx jy jz ka ly kc kd ke hb bi translated">转到所需组件并从React导入<em class="kf"> useContext </em>钩子，从BlogContext.js导入BlogContext</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es lz"><img src="../Images/3b0018214c79ed88000ad579c32fa025.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*X2zE8v-4CtZxf7gioUcsBQ.jpeg"/></div></div><figcaption class="kh ki et er es kj kk bd b be z dx translated">ComponentC.js</figcaption></figure><p id="e14d" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">我们使用上下文对象(BlogContext)通过使用context方法从Provider组件中获取上下文值(即数据)。此useContext方法接受上下文对象作为其参数，并返回当前上下文值。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es ma"><img src="../Images/c3a8b7f81b1653437783e7ec1f210160.png" data-original-src="https://miro.medium.com/v2/resize:fit:1174/format:webp/1*wcEVKHOZ8ZRAe6YmMQjHmw.jpeg"/></div><figcaption class="kh ki et er es kj kk bd b be z dx translated">ComponentC.js</figcaption></figure><p id="c45a" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">这就是我们如何单独创建上下文，并使用useContext钩子在我们的应用程序中任意使用它。</p><h2 id="4caa" class="kz la hi bd lb lc ld le lf lg lh li lj js lk ll lm jw ln lo lp ka lq lr ls lt bi translated">结论:</h2><ul class=""><li id="9af4" class="mb mc hi jl b jm lu jp lv js md jw me ka mf ke mg mh mi mj bi translated">使用反应的<strong class="jl hj"> createContext() </strong>方法，我们创建了上下文对象。</li><li id="f63f" class="mb mc hi jl b jm mk jp ml js mm jw mn ka mo ke mg mh mi mj bi translated">从上下文对象中拉出<strong class="jl hj">提供程序</strong>。</li><li id="6bc1" class="mb mc hi jl b jm mk jp ml js mm jw mn ka mo ke mg mh mi mj bi translated">用<strong class="jl hj">供应商包装父组件中的所有必需组件。</strong></li><li id="5699" class="mb mc hi jl b jm mk jp ml js mm jw mn ka mo ke mg mh mi mj bi translated">最后，使用<strong class="jl hj"> useContext() </strong>钩子来使用上下文，并按照您想要的方式使用它。</li></ul></div><div class="ab cl mp mq gp mr" role="separator"><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu"/></div><div class="hb hc hd he hf"><p id="e06b" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated"><strong class="jl hj">希望本文内容翔实。如果您认为内容有帮助，请鼓掌</strong>👏<strong class="jl hj">并在下面的评论部分自由发送您的反馈和任何与React Context API相关的查询。</strong></p><p id="16d0" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated"><strong class="jl hj">感谢您的阅读。祝您愉快:</strong></p></div></div>    
</body>
</html>