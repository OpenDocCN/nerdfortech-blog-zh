<html>
<head>
<title>10 JavaScript array methods you should know with Tips, Tricks, and examples</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">你应该知道的10种JavaScript数组方法，包括提示、技巧和示例</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/10-javascript-array-methods-you-should-know-with-tips-tricks-2c55d5fab251?source=collection_archive---------12-----------------------#2021-03-16">https://medium.com/nerd-for-tech/10-javascript-array-methods-you-should-know-with-tips-tricks-2c55d5fab251?source=collection_archive---------12-----------------------#2021-03-16</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/115cab1ab147783dded7ba4a6b6a3940.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DPuF2TiDZg1dHan4Z8qjUw.png"/></div></div></figure><p id="539c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">数组是JavaScript中广泛使用的数据结构。您可以在数组上执行的操作(迭代、插入项、删除项等)数量很大。数组对象提供了大量有用的方法，比如<code class="du jo jp jq jr b">array.forEach()</code>、<code class="du jo jp jq jr b">array.map()</code>等等。</p><p id="e21c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我经常不知所措，当使用哪种方法时，在哪种情况下哪种方法有用，所有的数组方法都带有特定的参数或签名，我将逐一解释所有的数组方法，以便我们在数组上执行各种操作以及日常操作</p><h1 id="03da" class="js jt hi bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">1.重复</h1><p id="9299" class="pw-post-body-paragraph iq ir hi is b it kq iv iw ix kr iz ja jb ks jd je jf kt jh ji jj ku jl jm jn hb bi translated">我们使用迭代来打印1到100个数字，或者说执行重复的动作，直到满足特定的条件</p><h2 id="8ebd" class="kv jt hi bd ju kw kx ky jy kz la lb kc jb lc ld kg jf le lf kk jj lg lh ko li bi translated"><strong class="ak"> 1.1对于..周期</strong></h2><p id="f3a2" class="pw-post-body-paragraph iq ir hi is b it kq iv iw ix kr iz ja jb ks jd je jf kt jh ji jj ku jl jm jn hb bi translated"><code class="du jo jp jq jr b">for(const item of items)</code>循环迭代数组项。</p><p id="5875" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">让我们遍历一个<code class="du jo jp jq jr b">colors</code>列表:</p><pre class="lj lk ll lm fd ln jr lo lp aw lq bi"><span id="61c9" class="kv jt hi jr b fi lr ls l lt lu">const colors = ['blue', 'green', 'white'];<br/><br/>for (const color of colors) {<br/>  console.log(color);<br/>}<br/>//output<br/>// 'blue'<br/>// 'green'<br/>// 'white'</span></pre><p id="53a0" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">让我们再举一个例子，使用中断并继续关键字</p><pre class="lj lk ll lm fd ln jr lo lp aw lq bi"><span id="3389" class="kv jt hi jr b fi lr ls l lt lu">const numbers = [1,2,3,4,5];</span><span id="7b8c" class="kv jt hi jr b fi lv ls l lt lu">for (const number of numbers) {<br/>if (number == 2) {<br/>continue;<br/>}<br/>if (number == 4) {<br/>break;<br/>}<br/>console.log(number);<br/>}<br/>//output</span><span id="773f" class="kv jt hi jr b fi lv ls l lt lu">//1<br/>//3</span></pre><p id="1391" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">小贴士:</p><ul class=""><li id="6df1" class="lw lx hi is b it iu ix iy jb ly jf lz jj ma jn mb mc md me bi translated">你可以在任何时候使用<code class="du jo jp jq jr b">break</code>语句停止迭代。</li><li id="904f" class="lw lx hi is b it mf ix mg jb mh jf mi jj mj jn mb mc md me bi translated">您可以通过使用<code class="du jo jp jq jr b">continue</code>语句来停止一次迭代。</li></ul><h2 id="1067" class="kv jt hi bd ju kw kx ky jy kz la lb kc jb lc ld kg jf le lf kk jj lg lh ko li bi translated">1.2对于..循环的</h2><p id="c84b" class="pw-post-body-paragraph iq ir hi is b it kq iv iw ix kr iz ja jb ks jd je jf kt jh ji jj ku jl jm jn hb bi translated"><code class="du jo jp jq jr b">for(let i; i &lt; array.length; i++) </code>使用递增的索引变量循环遍历数组项。</p><p id="7877" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><code class="du jo jp jq jr b">for</code>通常需要在每个周期递增的<code class="du jo jp jq jr b">index</code>变量:</p><pre class="lj lk ll lm fd ln jr lo lp aw lq bi"><span id="6f56" class="kv jt hi jr b fi lr ls l lt lu">const colors = ['blue', 'green', 'white'];<br/><br/>for (let index = 0; index &lt; colors.length-1; index++) {<br/>  const color = colors[index];<br/>  console.log(color);<br/>}<br/>// 'blue'<br/>// 'green'<br/>// 'white'</span></pre><p id="7fd7" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><code class="du jo jp jq jr b">index</code>变量从<code class="du jo jp jq jr b">0</code>到<code class="du jo jp jq jr b">colors.length - 1</code>递增。该变量用于通过索引访问项目:<code class="du jo jp jq jr b">colors[index]</code>。</p><h2 id="3e78" class="kv jt hi bd ju kw kx ky jy kz la lb kc jb lc ld kg jf le lf kk jj lg lh ko li bi translated">1.3 array.forEach()方法</h2><p id="e34b" class="pw-post-body-paragraph iq ir hi is b it kq iv iw ix kr iz ja jb ks jd je jf kt jh ji jj ku jl jm jn hb bi translated">为每个数组元素调用一次函数。在每次迭代中，使用参数调用<code class="du jo jp jq jr b">callback(item [, index [, array]])</code>:迭代项、索引和数组本身。</p><p id="d240" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">让我们迭代<code class="du jo jp jq jr b">colors</code>数组:</p><pre class="lj lk ll lm fd ln jr lo lp aw lq bi"><span id="ac87" class="kv jt hi jr b fi lr ls l lt lu">const colors = ['blue', 'green', 'white'];<br/><br/>colors.forEach(function callback(value, index) {<br/>  console.log(value, index);<br/>});<br/>// 'blue', 0<br/>// 'green', 1<br/>// 'white', 2</span></pre><p id="0aab" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><code class="du jo jp jq jr b">array.forEach(callback)</code>对数组中的每一项调用<code class="du jo jp jq jr b">callback</code> 3次:<code class="du jo jp jq jr b">'blue'</code>、<code class="du jo jp jq jr b">'green'</code>和<code class="du jo jp jq jr b">'white'</code>。</p><p id="1b3d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">让我们为每种方法再举一个例子</p><pre class="lj lk ll lm fd ln jr lo lp aw lq bi"><span id="703e" class="kv jt hi jr b fi lr ls l lt lu">var a = [1, 2, 3, 4, 5];</span><span id="4d9e" class="kv jt hi jr b fi lv ls l lt lu">var totalSum = 0;</span><span id="b060" class="kv jt hi jr b fi lv ls l lt lu">a.forEach(x =&gt; {</span><span id="e8e7" class="kv jt hi jr b fi lv ls l lt lu">totalSum += x;</span><span id="d454" class="kv jt hi jr b fi lv ls l lt lu">console.log(totalSum);</span><span id="4862" class="kv jt hi jr b fi lv ls l lt lu">});</span><span id="079b" class="kv jt hi jr b fi lv ls l lt lu">//output<br/>//1<br/>//3<br/>//6<br/>//10<br/>//15</span></pre><p id="3b30" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">小贴士:</p><ul class=""><li id="b814" class="lw lx hi is b it iu ix iy jb ly jf lz jj ma jn mb mc md me bi translated">您不能中断<code class="du jo jp jq jr b">array.forEach()</code>迭代。</li></ul><h1 id="bdfc" class="js jt hi bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">2.地图</h1><h2 id="1b07" class="kv jt hi bd ju kw kx ky jy kz la lb kc jb lc ld kg jf le lf kk jj lg lh ko li bi translated">2.1 array.map()方法</h2><p id="4c56" class="pw-post-body-paragraph iq ir hi is b it kq iv iw ix kr iz ja jb ks jd je jf kt jh ji jj ku jl jm jn hb bi translated"><code class="du jo jp jq jr b">array.map(callback)</code>方法通过对每个数组项使用<code class="du jo jp jq jr b">callback</code>调用结果来创建一个新数组。</p><p id="657c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在每一次迭代中，<code class="du jo jp jq jr b">callback(item[, index[, array]])</code>都是通过参数调用的:当前项、索引和数组本身。它应该返回新的项目。</p><p id="d736" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">让我们递增数组的编号:</p><pre class="lj lk ll lm fd ln jr lo lp aw lq bi"><span id="cb2a" class="kv jt hi jr b fi lr ls l lt lu">const numbers = [0, 2, 4];</span><span id="f88d" class="kv jt hi jr b fi lv ls l lt lu">const newNumbers = numbers.map(function increment(number) {<br/>  return number + 1;<br/>});</span><span id="b19c" class="kv jt hi jr b fi lv ls l lt lu">newNumbers; // =&gt; [1, 3, 5]</span></pre><p id="01f1" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><code class="du jo jp jq jr b">numbers.map(increment)</code>用λ表达</p><pre class="lj lk ll lm fd ln jr lo lp aw lq bi"><span id="d542" class="kv jt hi jr b fi lr ls l lt lu">const arr = [1, 2, 3, 4, 5, 6];<br/><br/>  // add one to every element<br/>  const oneAdded = arr.map(num =&gt; num + 1);<br/>  console.log(oneAdded); // output [2, 3, 4, 5, 6, 7]<br/><br/>  console.log(arr); // output: [1, 2, 3, 4, 5, 6]</span></pre><p id="6970" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">使用映射功能动态添加对象</p><pre class="lj lk ll lm fd ln jr lo lp aw lq bi"><span id="a807" class="kv jt hi jr b fi lr ls l lt lu">const appleColor = ['white', 'black', 'red'];<br/>const apple = appleColor.map(x =&gt; {<br/>return {<br/>appleColor: x,<br/>applePrice: 50<br/>}});<br/>console.log(appleColor);<br/>// output<br/>// 0: "white"<br/>// 1: "black"<br/>// 2: "red"</span><span id="3d7e" class="kv jt hi jr b fi lv ls l lt lu">console.log(apple);<br/>// output// 0: {appleColor: "white", applePrice: 50}<br/>// 1{appleColor: "black", applePrice: 50}<br/>// 2: {appleColor: "red", applePrice: 50}<br/>// length: 3</span></pre><p id="8356" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">小贴士:</p><ul class=""><li id="c1c3" class="lw lx hi is b it iu ix iy jb ly jf lz jj ma jn mb mc md me bi translated"><code class="du jo jp jq jr b">array.map()</code>创建一个新的映射数组，不改变原来的数组。</li></ul><h2 id="ee06" class="kv jt hi bd ju kw kx ky jy kz la lb kc jb lc ld kg jf le lf kk jj lg lh ko li bi translated">2.1 array.from()方法</h2><p id="2f3c" class="pw-post-body-paragraph iq ir hi is b it kq iv iw ix kr iz ja jb ks jd je jf kt jh ji jj ku jl jm jn hb bi translated"><code class="du jo jp jq jr b">Array.from(arrayLike[, callback])</code>方法通过使用<code class="du jo jp jq jr b">callback</code>在每个数组项上调用结果来创建一个新数组。</p><p id="028a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在每一次迭代中，<code class="du jo jp jq jr b">callback(item[, index[, array]])</code>都是通过参数调用的:当前项、索引和数组本身。它应该返回新的项目。</p><p id="514a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">让我们递增数组的编号:</p><pre class="lj lk ll lm fd ln jr lo lp aw lq bi"><span id="f01b" class="kv jt hi jr b fi lr ls l lt lu">const numbers = [0, 2, 4];</span><span id="04ff" class="kv jt hi jr b fi lv ls l lt lu">const newNumbers = Array.from(numbers,<br/>  function increment(number) {<br/>    return number + 1;<br/>  }<br/>);</span><span id="3d57" class="kv jt hi jr b fi lv ls l lt lu">newNumbers; // =&gt; [1, 3, 5]</span></pre><p id="5696" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><code class="du jo jp jq jr b">Array.from(numbers, increment)</code>从<code class="du jo jp jq jr b">numbers</code>创建一个新的数组，增加每个数组项。</p><p id="d87a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这将所有类似数组或可迭代的东西变成真正的数组，尤其是在使用DOM时。</p><pre class="lj lk ll lm fd ln jr lo lp aw lq bi"><span id="6962" class="kv jt hi jr b fi lr ls l lt lu">const name = 'frugence';<br/>  const nameArray = Array.from(name);<br/><br/>  console.log(name); // output: frugence<br/>  console.log(nameArray); // output: ['f', 'r', 'u', 'g', 'e', 'n', 'c', 'e']</span></pre><p id="7441" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">小贴士:</p><ul class=""><li id="f5e2" class="lw lx hi is b it iu ix iy jb ly jf lz jj ma jn mb mc md me bi translated"><code class="du jo jp jq jr b">Array.from()</code>创建新的映射数组，而不改变原始数组</li><li id="847d" class="lw lx hi is b it mf ix mg jb mh jf mi jj mj jn mb mc md me bi translated"><code class="du jo jp jq jr b">Array.from()</code>更适合从<a class="ae mk" href="https://dmitripavlutin.com/javascript-array-from-applications/#2-transform-array-like-into-an-array" rel="noopener ugc nofollow" target="_blank">阵列状物体</a>映射。</li></ul><h1 id="3a07" class="js jt hi bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">3.减少</h1><h2 id="54bd" class="kv jt hi bd ju kw kx ky jy kz la lb kc jb lc ld kg jf le lf kk jj lg lh ko li bi translated">3.1 array.reduce()方法</h2><p id="1800" class="pw-post-body-paragraph iq ir hi is b it kq iv iw ix kr iz ja jb ks jd je jf kt jh ji jj ku jl jm jn hb bi translated"><code class="du jo jp jq jr b">array.reduce(callback[, initialValue])</code>通过调用<code class="du jo jp jq jr b">callback</code>函数作为缩减器，将数组缩减为一个值。</p><p id="c442" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在每一次迭代中，<code class="du jo jp jq jr b">callback(accumulator, item[, index[, array]])</code>被带参数调用:累加器、当前项、索引和数组本身。它应该返回累加器。</p><p id="9746" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">经典的例子是对一组数字求和:</p><pre class="lj lk ll lm fd ln jr lo lp aw lq bi"><span id="45bf" class="kv jt hi jr b fi lr ls l lt lu">const numbers = [2, 0, 4];</span><span id="0d47" class="kv jt hi jr b fi lv ls l lt lu">function summarize(accumulator, number) {<br/>  return accumulator + number;<br/>}</span><span id="6b0f" class="kv jt hi jr b fi lv ls l lt lu">const sum = numbers.reduce(summarize, 0);</span><span id="30bc" class="kv jt hi jr b fi lv ls l lt lu">sum; // =&gt; 6</span><span id="077f" class="kv jt hi jr b fi lv ls l lt lu">const arr = [1, 2, 3, 4, 5, 6];<br/><br/>  const sum = arr.reduce((total, value) =&gt; total + value, 0);<br/>  console.log(sum); // 21</span></pre><p id="68ce" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在第一步<code class="du jo jp jq jr b">accumulator</code>用<code class="du jo jp jq jr b">0</code>初始化。然后在每个数组项上调用<code class="du jo jp jq jr b">summarize</code>函数，累加数字的和。</p><p id="3fb5" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">小贴士:</p><ul class=""><li id="17f8" class="lw lx hi is b it iu ix iy jb ly jf lz jj ma jn mb mc md me bi translated">如果跳过<code class="du jo jp jq jr b">initialValue</code>参数，第一个数组项将成为初始值。</li></ul><h1 id="f066" class="js jt hi bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">4.串联</h1><h2 id="ae72" class="kv jt hi bd ju kw kx ky jy kz la lb kc jb lc ld kg jf le lf kk jj lg lh ko li bi translated">4.1 array.concat()方法</h2><p id="66d4" class="pw-post-body-paragraph iq ir hi is b it kq iv iw ix kr iz ja jb ks jd je jf kt jh ji jj ku jl jm jn hb bi translated"><code class="du jo jp jq jr b">array.concat(array1[, array2, ...])</code>将一个或多个数组连接到原始数组。</p><p id="d9bc" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">让我们连接两个名称数组:</p><pre class="lj lk ll lm fd ln jr lo lp aw lq bi"><span id="afaa" class="kv jt hi jr b fi lr ls l lt lu">const heroes = ['Batman', 'Robin'];<br/>const villains = ['Joker', 'Bane'];</span><span id="5874" class="kv jt hi jr b fi lv ls l lt lu">const everyone = heroes.concat(villains);</span><span id="2a82" class="kv jt hi jr b fi lv ls l lt lu">everyone; // =&gt; ['Batman', 'Robin', 'Joker', 'Bane']</span></pre><p id="819a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><code class="du jo jp jq jr b">heroes.concat(villains)</code>通过连接<code class="du jo jp jq jr b">heroes</code>和<code class="du jo jp jq jr b">villains</code>数组创建一个新数组。</p><p id="443a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">小贴士:</p><ul class=""><li id="dd33" class="lw lx hi is b it iu ix iy jb ly jf lz jj ma jn mb mc md me bi translated"><code class="du jo jp jq jr b">array.concat()</code>创建一个新数组，不改变原来的数组</li><li id="c17a" class="lw lx hi is b it mf ix mg jb mh jf mi jj mj jn mb mc md me bi translated"><code class="du jo jp jq jr b">array.concat(array1[, array2, ...])</code>接受多个数组进行连接。</li></ul><h2 id="8be2" class="kv jt hi bd ju kw kx ky jy kz la lb kc jb lc ld kg jf le lf kk jj lg lh ko li bi translated">4.2扩展运算符</h2><p id="dc3b" class="pw-post-body-paragraph iq ir hi is b it kq iv iw ix kr iz ja jb ks jd je jf kt jh ji jj ku jl jm jn hb bi translated">您可以使用带有数组文字的spread运算符来连接数组:<code class="du jo jp jq jr b">[...array1, ...array2]</code>。</p><p id="69e1" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">让我们连接两个名称数组:</p><pre class="lj lk ll lm fd ln jr lo lp aw lq bi"><span id="6be2" class="kv jt hi jr b fi lr ls l lt lu">const heroes = ['Batman', 'Catwoman'];<br/>const villains = ['Joker', 'Bane'];</span><span id="2e86" class="kv jt hi jr b fi lv ls l lt lu">const names = [...heroes, ...villains];</span><span id="e5e0" class="kv jt hi jr b fi lv ls l lt lu">names; // =&gt; ['Batman', 'Catwoman', 'Joker', 'Bane']</span></pre><p id="dc41" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><code class="du jo jp jq jr b">[...heroes, ...villains]</code>展开<code class="du jo jp jq jr b">heroes</code>和<code class="du jo jp jq jr b">villains</code>项，然后创建一个包含所有展开项的新数组。</p><ul class=""><li id="e6c5" class="lw lx hi is b it iu ix iy jb ly jf lz jj ma jn mb mc md me bi translated"><code class="du jo jp jq jr b">[...arr1, ...arr2, ...arrN]</code>:您可以使用spread运算符连接任意数量的数组。</li></ul><h1 id="f1b0" class="js jt hi bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">5.薄片</h1><h2 id="7fff" class="kv jt hi bd ju kw kx ky jy kz la lb kc jb lc ld kg jf le lf kk jj lg lh ko li bi translated">5.1 array.slice()方法</h2><p id="b17f" class="pw-post-body-paragraph iq ir hi is b it kq iv iw ix kr iz ja jb ks jd je jf kt jh ji jj ku jl jm jn hb bi translated"><code class="du jo jp jq jr b">array.slice([fromIndex[, toIndex]])</code>返回从<code class="du jo jp jq jr b">fromIndex</code>开始到<code class="du jo jp jq jr b">toIndex</code>结束的数组切片(不包括<code class="du jo jp jq jr b">toIndex</code>本身)。<code class="du jo jp jq jr b">fromIndex</code>可选参数默认为<code class="du jo jp jq jr b">0</code>，<code class="du jo jp jq jr b">toIndex</code>可选参数默认为<code class="du jo jp jq jr b">array.length</code>。</p><p id="4e76" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">让我们来看一些数组切片:</p><pre class="lj lk ll lm fd ln jr lo lp aw lq bi"><span id="b965" class="kv jt hi jr b fi lr ls l lt lu">const names = ['Batman', 'Catwoman', 'Joker', 'Bane'];</span><span id="1b1e" class="kv jt hi jr b fi lv ls l lt lu">const heroes = names.slice(0, 2);<br/>const villains = names.slice(2);</span><span id="a77f" class="kv jt hi jr b fi lv ls l lt lu">heroes; // =&gt; ['Batman', 'Catwoman']<br/>villains; // =&gt; ['Joker', 'Bane']</span></pre><p id="e3e5" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><code class="du jo jp jq jr b">names.slice(0, 2)</code>从<code class="du jo jp jq jr b">names</code>数组返回2个项目的切片。</p><p id="22d6" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><code class="du jo jp jq jr b">names.slice(2)</code>返回2个项目的切片。<code class="du jo jp jq jr b">end</code>参数默认为<code class="du jo jp jq jr b">names.length</code>。</p><p id="d162" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">小贴士:</p><ul class=""><li id="b071" class="lw lx hi is b it iu ix iy jb ly jf lz jj ma jn mb mc md me bi translated">创建一个新数组，而不改变原来的数组。</li></ul><h1 id="09fa" class="js jt hi bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">6.克隆</h1><h2 id="2472" class="kv jt hi bd ju kw kx ky jy kz la lb kc jb lc ld kg jf le lf kk jj lg lh ko li bi translated">6.1扩展运算符</h2><p id="8e68" class="pw-post-body-paragraph iq ir hi is b it kq iv iw ix kr iz ja jb ks jd je jf kt jh ji jj ku jl jm jn hb bi translated">克隆数组的一个简单方法是使用spread操作符:<code class="du jo jp jq jr b">const clone = [...array]</code>；</p><p id="41f2" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">让我们克隆一个<code class="du jo jp jq jr b">colors</code>数组:</p><pre class="lj lk ll lm fd ln jr lo lp aw lq bi"><span id="07f9" class="kv jt hi jr b fi lr ls l lt lu">const colors = ['white', 'black', 'gray'];</span><span id="18d3" class="kv jt hi jr b fi lv ls l lt lu">const clone = [...colors];</span><span id="9873" class="kv jt hi jr b fi lv ls l lt lu">clone; // =&gt; ['white', 'black', 'gray']<br/>colors === clone; // =&gt; false</span></pre><p id="7495" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><code class="du jo jp jq jr b">[...colors]</code>创建一个<code class="du jo jp jq jr b">colors</code>数组的克隆。</p><p id="c24f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">小贴士:</p><ul class=""><li id="3060" class="lw lx hi is b it iu ix iy jb ly jf lz jj ma jn mb mc md me bi translated"><code class="du jo jp jq jr b">[...array]</code>创建浅拷贝。</li></ul><h2 id="3835" class="kv jt hi bd ju kw kx ky jy kz la lb kc jb lc ld kg jf le lf kk jj lg lh ko li bi translated">6.2 array.concat()方法</h2><p id="004c" class="pw-post-body-paragraph iq ir hi is b it kq iv iw ix kr iz ja jb ks jd je jf kt jh ji jj ku jl jm jn hb bi translated"><code class="du jo jp jq jr b">[].concat(array)</code>是关于如何克隆<code class="du jo jp jq jr b">array</code>的另一种方法。</p><pre class="lj lk ll lm fd ln jr lo lp aw lq bi"><span id="01e5" class="kv jt hi jr b fi lr ls l lt lu">const colors = ['white', 'black', 'gray'];</span><span id="4aa9" class="kv jt hi jr b fi lv ls l lt lu">const clone = [].concat(colors);</span><span id="be62" class="kv jt hi jr b fi lv ls l lt lu">clone; // =&gt; ['white', 'black', 'gray']<br/>colors === clone; // =&gt; false</span></pre><p id="e6d5" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><code class="du jo jp jq jr b">[].concat(colors)</code>创建一个<code class="du jo jp jq jr b">colors</code>数组的克隆。</p><p id="0c9d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">小贴士:</p><ul class=""><li id="379d" class="lw lx hi is b it iu ix iy jb ly jf lz jj ma jn mb mc md me bi translated">创建一个浅拷贝。</li></ul><h2 id="3d53" class="kv jt hi bd ju kw kx ky jy kz la lb kc jb lc ld kg jf le lf kk jj lg lh ko li bi translated">6.3 array.slice()方法</h2><p id="2613" class="pw-post-body-paragraph iq ir hi is b it kq iv iw ix kr iz ja jb ks jd je jf kt jh ji jj ku jl jm jn hb bi translated"><code class="du jo jp jq jr b">array.slice()</code>是关于如何克隆<code class="du jo jp jq jr b">array</code>的另一种方法。</p><pre class="lj lk ll lm fd ln jr lo lp aw lq bi"><span id="34d4" class="kv jt hi jr b fi lr ls l lt lu">const colors = ['white', 'black', 'gray'];</span><span id="2bf6" class="kv jt hi jr b fi lv ls l lt lu">const clone = colors.slice();</span><span id="4ae8" class="kv jt hi jr b fi lv ls l lt lu">clone; // =&gt; ['white', 'black', 'gray']<br/>colors === clone; // =&gt; false</span></pre><p id="9613" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><code class="du jo jp jq jr b">colors.slice()</code>创建<code class="du jo jp jq jr b">colors</code>数组的克隆。</p><p id="772c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">小贴士:</p><ul class=""><li id="b909" class="lw lx hi is b it iu ix iy jb ly jf lz jj ma jn mb mc md me bi translated"><code class="du jo jp jq jr b">colors.slice()</code>创建浅层副本。</li></ul><h1 id="2471" class="js jt hi bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">7.搜索</h1><h2 id="1dbc" class="kv jt hi bd ju kw kx ky jy kz la lb kc jb lc ld kg jf le lf kk jj lg lh ko li bi translated">7.1 array.includes()方法</h2><p id="e3e8" class="pw-post-body-paragraph iq ir hi is b it kq iv iw ix kr iz ja jb ks jd je jf kt jh ji jj ku jl jm jn hb bi translated"><code class="du jo jp jq jr b">array.includes(itemToSearch[, fromIndex])</code>返回一个布尔值，判断<code class="du jo jp jq jr b">array</code>是否包含<code class="du jo jp jq jr b">itemToSearch</code>。可选参数<code class="du jo jp jq jr b">fromIndex</code>，默认为<code class="du jo jp jq jr b">0</code>，指示开始搜索的索引。</p><p id="5365" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">让我们确定<code class="du jo jp jq jr b">2</code>和<code class="du jo jp jq jr b">99</code>是否存在于数字数组中:</p><pre class="lj lk ll lm fd ln jr lo lp aw lq bi"><span id="06a9" class="kv jt hi jr b fi lr ls l lt lu">const numbers = [1, 2, 3, 4, 5];</span><span id="06c4" class="kv jt hi jr b fi lv ls l lt lu">numbers.includes(2);  // =&gt; true<br/>numbers.includes(99); // =&gt; false</span></pre><p id="7b6a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><code class="du jo jp jq jr b">numbers.includes(2)</code>返回<code class="du jo jp jq jr b">true</code>，因为<code class="du jo jp jq jr b">2</code>存在于<code class="du jo jp jq jr b">numbers</code>数组中。</p><p id="48df" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">然而<code class="du jo jp jq jr b">numbers.includes(99)</code>是<code class="du jo jp jq jr b">false</code>，因为<code class="du jo jp jq jr b">numbers</code>不包含<code class="du jo jp jq jr b">99</code>。</p><h2 id="a959" class="kv jt hi bd ju kw kx ky jy kz la lb kc jb lc ld kg jf le lf kk jj lg lh ko li bi translated">7.2 array.find()方法</h2><p id="8ca3" class="pw-post-body-paragraph iq ir hi is b it kq iv iw ix kr iz ja jb ks jd je jf kt jh ji jj ku jl jm jn hb bi translated"><code class="du jo jp jq jr b">array.find(predicate)</code>方法返回满足<code class="du jo jp jq jr b">predicate</code>函数的第一个数组项。</p><p id="8382" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在每次迭代中<code class="du jo jp jq jr b">predicate(item[, index[, array]])</code>函数被参数调用:迭代项、索引和数组本身。</p><p id="1144" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">例如，让我们找到第一个偶数:</p><pre class="lj lk ll lm fd ln jr lo lp aw lq bi"><span id="8221" class="kv jt hi jr b fi lr ls l lt lu">const numbers = [1, 2, 3, 4, 5];</span><span id="3a46" class="kv jt hi jr b fi lv ls l lt lu">function isEven(number) {<br/>  return number % 2 === 0;<br/>}</span><span id="95cc" class="kv jt hi jr b fi lv ls l lt lu">const evenNumber = numbers.find(isEven);</span><span id="047b" class="kv jt hi jr b fi lv ls l lt lu">evenNumber; // =&gt; 2</span></pre><p id="747b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><code class="du jo jp jq jr b">numbers.find(isEven)</code>返回<code class="du jo jp jq jr b">numbers</code>内的第一个偶数，即<code class="du jo jp jq jr b">2</code>。</p><p id="011f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">小贴士:</p><ul class=""><li id="fbe0" class="lw lx hi is b it iu ix iy jb ly jf lz jj ma jn mb mc md me bi translated">如果没有项目满足谓词，则<code class="du jo jp jq jr b">array.find()</code>返回<code class="du jo jp jq jr b">undefined</code>。</li></ul><h2 id="0fcd" class="kv jt hi bd ju kw kx ky jy kz la lb kc jb lc ld kg jf le lf kk jj lg lh ko li bi translated">7.3 array.indexOf()方法</h2><p id="7498" class="pw-post-body-paragraph iq ir hi is b it kq iv iw ix kr iz ja jb ks jd je jf kt jh ji jj ku jl jm jn hb bi translated"><code class="du jo jp jq jr b">array.indexOf(itemToSearch[, fromIndex])</code>返回<code class="du jo jp jq jr b">array</code>中第一次出现<code class="du jo jp jq jr b">itemToSearch</code>的索引。可选参数<code class="du jo jp jq jr b">fromIndex</code>，默认为<code class="du jo jp jq jr b">0</code>，是开始搜索的索引。</p><p id="c0c4" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">让我们找到<code class="du jo jp jq jr b">'Joker'</code>的索引:</p><pre class="lj lk ll lm fd ln jr lo lp aw lq bi"><span id="4775" class="kv jt hi jr b fi lr ls l lt lu">const names = ['Batman', 'Catwoman', 'Joker', 'Bane'];</span><span id="9a61" class="kv jt hi jr b fi lv ls l lt lu">const index = names.indexOf('Joker');</span><span id="685a" class="kv jt hi jr b fi lv ls l lt lu">index; // =&gt; 2</span></pre><p id="3158" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><code class="du jo jp jq jr b">names</code>内<code class="du jo jp jq jr b">'Joker'</code>的索引为<code class="du jo jp jq jr b">2</code>。</p><p id="5ffb" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">小贴士:</p><ul class=""><li id="f4ac" class="lw lx hi is b it iu ix iy jb ly jf lz jj ma jn mb mc md me bi translated"><code class="du jo jp jq jr b">array.indexOf(itemToSearch)</code>如果没有找到物品，返回<code class="du jo jp jq jr b">-1</code></li><li id="f17d" class="lw lx hi is b it mf ix mg jb mh jf mi jj mj jn mb mc md me bi translated"><code class="du jo jp jq jr b">array.findIndex(predicate)</code>是使用谓词函数查找索引的替代方法。</li></ul><h1 id="c46b" class="js jt hi bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">8.询问</h1><h2 id="7f69" class="kv jt hi bd ju kw kx ky jy kz la lb kc jb lc ld kg jf le lf kk jj lg lh ko li bi translated">8.1 array.every()方法</h2><p id="d103" class="pw-post-body-paragraph iq ir hi is b it kq iv iw ix kr iz ja jb ks jd je jf kt jh ji jj ku jl jm jn hb bi translated">如果每个项目都通过了<code class="du jo jp jq jr b">predicate</code>检查，则<code class="du jo jp jq jr b">array.every(predicate)</code>方法返回<code class="du jo jp jq jr b">true</code>。</p><p id="5e61" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在每一次迭代中，谓词函数被参数调用:迭代项、索引和数组本身。</p><p id="79e8" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">让我们确定数组<code class="du jo jp jq jr b">evens</code>和<code class="du jo jp jq jr b">mix</code>是否只包含偶数:</p><pre class="lj lk ll lm fd ln jr lo lp aw lq bi"><span id="a264" class="kv jt hi jr b fi lr ls l lt lu">const evens = [0, 2, 4, 6];<br/>const numbers = [0, 1, 4, 6];</span><span id="6278" class="kv jt hi jr b fi lv ls l lt lu">function isEven(number) {<br/>  return number % 2 === 0;<br/>}</span><span id="4d58" class="kv jt hi jr b fi lv ls l lt lu">evens.every(isEven); // =&gt; true<br/>numbers.every(isEven); // =&gt; false</span></pre><p id="86d0" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><code class="du jo jp jq jr b">evens.every(isEven)</code>是<code class="du jo jp jq jr b">true</code>，因为<code class="du jo jp jq jr b">evens</code>中的<em class="ml">都是偶数。</em></p><p id="5b0d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">但是，<code class="du jo jp jq jr b">numbers.every(isEven)</code>的计算结果是<code class="du jo jp jq jr b">false</code>，因为<code class="du jo jp jq jr b">numbers</code>包含一个奇数<code class="du jo jp jq jr b">1</code>。</p><h2 id="efea" class="kv jt hi bd ju kw kx ky jy kz la lb kc jb lc ld kg jf le lf kk jj lg lh ko li bi translated">8.2 array.some()方法</h2><p id="7a4b" class="pw-post-body-paragraph iq ir hi is b it kq iv iw ix kr iz ja jb ks jd je jf kt jh ji jj ku jl jm jn hb bi translated">如果至少有一项通过了<code class="du jo jp jq jr b">predicate</code>检查，则<code class="du jo jp jq jr b">array.some(predicate)</code>方法返回<code class="du jo jp jq jr b">true</code>。<br/>在每次迭代中<code class="du jo jp jq jr b">predicate(item[, index[, array]])</code>函数被参数调用:迭代项、索引和数组本身。</p><p id="d143" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">让我们确定数组是否包含至少一个偶数:</p><pre class="lj lk ll lm fd ln jr lo lp aw lq bi"><span id="9a69" class="kv jt hi jr b fi lr ls l lt lu">const numbers = [1, 5, 7, 10];<br/>const odds = [1, 3, 3, 3];</span><span id="e119" class="kv jt hi jr b fi lv ls l lt lu">function isEven(number) {<br/>  return number % 2 === 0;<br/>}</span><span id="83cc" class="kv jt hi jr b fi lv ls l lt lu">numbers.some(isEven); // =&gt; true<br/>odds.some(isEven);   // =&gt; false</span></pre><p id="1d7a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><code class="du jo jp jq jr b">numbers.some(isEven)</code>是<code class="du jo jp jq jr b">true</code>，因为<code class="du jo jp jq jr b">numbers</code>中至少存在一个偶数<code class="du jo jp jq jr b">10</code>。</p><p id="de0e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">但是<code class="du jo jp jq jr b">odds.some(isEven)</code>是<code class="du jo jp jq jr b">false</code>，因为<code class="du jo jp jq jr b">odds</code>只包含奇数。</p><h1 id="c24c" class="js jt hi bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">9.过滤器</h1><h2 id="6281" class="kv jt hi bd ju kw kx ky jy kz la lb kc jb lc ld kg jf le lf kk jj lg lh ko li bi translated">9.1 array.filter()</h2><p id="c844" class="pw-post-body-paragraph iq ir hi is b it kq iv iw ix kr iz ja jb ks jd je jf kt jh ji jj ku jl jm jn hb bi translated"><code class="du jo jp jq jr b">array.filter(predicate)</code>方法返回一个包含通过<code class="du jo jp jq jr b">predicate</code>检查的项目的新数组。</p><p id="7c09" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在每次迭代中，使用参数调用函数:迭代项、索引和数组本身。</p><p id="1e94" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">让我们过滤一个只有偶数的数组:</p><pre class="lj lk ll lm fd ln jr lo lp aw lq bi"><span id="4c67" class="kv jt hi jr b fi lr ls l lt lu">const numbers = [1, 5, 7, 10];</span><span id="631d" class="kv jt hi jr b fi lv ls l lt lu">function isEven(number) {<br/>  return number % 2 === 0;<br/>}</span><span id="aebe" class="kv jt hi jr b fi lv ls l lt lu">const evens = numbers.filter(isEven);</span><span id="e27a" class="kv jt hi jr b fi lv ls l lt lu">evens; // =&gt; [10]</span></pre><p id="6178" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><code class="du jo jp jq jr b">numbers.filter(isEven)</code>通过过滤<code class="du jo jp jq jr b">numbers</code>创建一个新的数组<code class="du jo jp jq jr b">evens</code>，使其只包含偶数。</p><p id="75a2" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">小贴士:</p><ul class=""><li id="6fbf" class="lw lx hi is b it iu ix iy jb ly jf lz jj ma jn mb mc md me bi translated">创建一个新数组，而不改变原来的数组。</li></ul><h1 id="47cc" class="js jt hi bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">10.插入</h1><h2 id="83c4" class="kv jt hi bd ju kw kx ky jy kz la lb kc jb lc ld kg jf le lf kk jj lg lh ko li bi translated">10.1 array.push()方法</h2><p id="c902" class="pw-post-body-paragraph iq ir hi is b it kq iv iw ix kr iz ja jb ks jd je jf kt jh ji jj ku jl jm jn hb bi translated">方法将一个或多个项目附加到数组的末尾，返回新的长度。</p><p id="60e3" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">让我们将<code class="du jo jp jq jr b">'Joker'</code>追加到<code class="du jo jp jq jr b">names</code>数组的末尾:</p><pre class="lj lk ll lm fd ln jr lo lp aw lq bi"><span id="b5fb" class="kv jt hi jr b fi lr ls l lt lu">const names = ['Batman'];</span><span id="d22a" class="kv jt hi jr b fi lv ls l lt lu">names.push('Joker');</span><span id="e8dd" class="kv jt hi jr b fi lv ls l lt lu">names; // ['Batman', 'Joker']</span></pre><p id="a251" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><code class="du jo jp jq jr b">names.push('Joker')</code>在<code class="du jo jp jq jr b">names</code>数组的末尾插入一个新项目<code class="du jo jp jq jr b">'Joker'</code>。</p><p id="8178" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">小贴士:</p><ul class=""><li id="cdbf" class="lw lx hi is b it iu ix iy jb ly jf lz jj ma jn mb mc md me bi translated"><code class="du jo jp jq jr b">array.push()</code>原地变异阵列</li><li id="12bd" class="lw lx hi is b it mf ix mg jb mh jf mi jj mj jn mb mc md me bi translated"><code class="du jo jp jq jr b">array.push(item1, item2, ..., itemN)</code>可以推送多个项目。</li></ul><h2 id="b2ef" class="kv jt hi bd ju kw kx ky jy kz la lb kc jb lc ld kg jf le lf kk jj lg lh ko li bi translated">10.2 array.unshift()方法</h2><p id="3148" class="pw-post-body-paragraph iq ir hi is b it kq iv iw ix kr iz ja jb ks jd je jf kt jh ji jj ku jl jm jn hb bi translated">方法将一个或多个项目追加到数组的开头，返回数组的新长度。</p><p id="978f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">让我们在<code class="du jo jp jq jr b">names</code>数组的开头追加<code class="du jo jp jq jr b">'Catwoman'</code>:</p><pre class="lj lk ll lm fd ln jr lo lp aw lq bi"><span id="74ca" class="kv jt hi jr b fi lr ls l lt lu">const names = ['Batman'];</span><span id="4a44" class="kv jt hi jr b fi lv ls l lt lu">names.unshift('Catwoman');</span><span id="5570" class="kv jt hi jr b fi lv ls l lt lu">names; // ['Catwoman', 'Batman']</span></pre><p id="948a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><code class="du jo jp jq jr b">names.unshift('Catwoman')</code>在<code class="du jo jp jq jr b">names</code>数组的开头插入一个新项<code class="du jo jp jq jr b">'Catwoman'</code>。</p><p id="74f1" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">小贴士:</p><ul class=""><li id="91a6" class="lw lx hi is b it iu ix iy jb ly jf lz jj ma jn mb mc md me bi translated"><code class="du jo jp jq jr b">array.unshift()</code>就地变异阵列。</li><li id="1e74" class="lw lx hi is b it mf ix mg jb mh jf mi jj mj jn mb mc md me bi translated"><code class="du jo jp jq jr b">array.unshift(item1, item2, ..., itemN)</code>可以插入多个项目。</li></ul><h2 id="b6ba" class="kv jt hi bd ju kw kx ky jy kz la lb kc jb lc ld kg jf le lf kk jj lg lh ko li bi translated">10.3扩展运算符</h2><p id="ef6a" class="pw-post-body-paragraph iq ir hi is b it kq iv iw ix kr iz ja jb ks jd je jf kt jh ji jj ku jl jm jn hb bi translated">通过将spread运算符与数组文字相结合，可以以不可变的方式在数组中插入项。</p><p id="33d8" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在数组的<em class="ml">末端追加一个项目:</em></p><pre class="lj lk ll lm fd ln jr lo lp aw lq bi"><span id="76ec" class="kv jt hi jr b fi lr ls l lt lu">const names = ['Joker', 'Bane'];</span><span id="1c76" class="kv jt hi jr b fi lv ls l lt lu">const names2 = [<br/>  ...names,<br/>  'Batman',<br/>];</span><span id="8363" class="kv jt hi jr b fi lv ls l lt lu">names2; // =&gt; ['Joker', 'Bane', 'Batman'];</span></pre><p id="0bfc" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在数组的<em class="ml">开头追加一个项目:</em></p><pre class="lj lk ll lm fd ln jr lo lp aw lq bi"><span id="4f31" class="kv jt hi jr b fi lr ls l lt lu">const names = ['Joker', 'Bane'];</span><span id="57f3" class="kv jt hi jr b fi lv ls l lt lu">const names2 = [<br/>  'Batman',<br/>  ...names<br/>];</span><span id="5736" class="kv jt hi jr b fi lv ls l lt lu">names2; // =&gt; ['Batman', 'Joker', 'Bane'];</span></pre><p id="9f7a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在任一索引处插入一个项目<em class="ml">:</em></p><pre class="lj lk ll lm fd ln jr lo lp aw lq bi"><span id="a0e8" class="kv jt hi jr b fi lr ls l lt lu">const names = ['Joker', 'Bane'];<br/>const indexToInsert = 1;</span><span id="45b6" class="kv jt hi jr b fi lv ls l lt lu">const names2 = [<br/>  ...names.slice(0, indexToInsert),<br/>  'Batman',<br/>  ...names.slice(indexToInsert)<br/>];</span><span id="ccf0" class="kv jt hi jr b fi lv ls l lt lu">names2; // =&gt; ['Joker', 'Batman', 'Bane'];</span></pre><h1 id="2686" class="js jt hi bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">11.去除</h1><h2 id="7578" class="kv jt hi bd ju kw kx ky jy kz la lb kc jb lc ld kg jf le lf kk jj lg lh ko li bi translated">11.1 array.pop()方法</h2><p id="27a6" class="pw-post-body-paragraph iq ir hi is b it kq iv iw ix kr iz ja jb ks jd je jf kt jh ji jj ku jl jm jn hb bi translated">方法从数组中移除最后一项，然后返回该项。</p><p id="fe91" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">例如，让我们删除<code class="du jo jp jq jr b">colors</code>数组的最后一个元素:</p><pre class="lj lk ll lm fd ln jr lo lp aw lq bi"><span id="a104" class="kv jt hi jr b fi lr ls l lt lu">const colors = ['blue', 'green', 'black'];</span><span id="2099" class="kv jt hi jr b fi lv ls l lt lu">const lastColor = colors.pop();</span><span id="6a59" class="kv jt hi jr b fi lv ls l lt lu">lastColor; // =&gt; 'black'<br/>colors; // =&gt; ['blue', 'green']</span></pre><p id="4e0c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><code class="du jo jp jq jr b">colors.pop()</code>删除<code class="du jo jp jq jr b">colors</code>的最后一个元素并返回。</p><p id="2ae6" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">小贴士:</p><ul class=""><li id="9033" class="lw lx hi is b it iu ix iy jb ly jf lz jj ma jn mb mc md me bi translated"><code class="du jo jp jq jr b">array.pop()</code>就地变异数组。</li></ul><h2 id="d55a" class="kv jt hi bd ju kw kx ky jy kz la lb kc jb lc ld kg jf le lf kk jj lg lh ko li bi translated">11.2 array.shift()方法</h2><p id="b34e" class="pw-post-body-paragraph iq ir hi is b it kq iv iw ix kr iz ja jb ks jd je jf kt jh ji jj ku jl jm jn hb bi translated"><code class="du jo jp jq jr b">array.shift()</code>方法从数组中移除第一项，然后返回该项。</p><p id="0ad0" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">例如，让我们删除<code class="du jo jp jq jr b">colors</code>数组的第一个元素:</p><pre class="lj lk ll lm fd ln jr lo lp aw lq bi"><span id="dc0d" class="kv jt hi jr b fi lr ls l lt lu">const colors = ['blue', 'green', 'black'];</span><span id="7544" class="kv jt hi jr b fi lv ls l lt lu">const firstColor = colors.shift();</span><span id="94ef" class="kv jt hi jr b fi lv ls l lt lu">firstColor; // =&gt; 'blue'<br/>colors; // =&gt; ['green', 'black']</span></pre><p id="591c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><code class="du jo jp jq jr b">colors.shift()</code>删除<code class="du jo jp jq jr b">colors</code>的第一个元素<code class="du jo jp jq jr b">'blue'</code>并返回。</p><p id="2272" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">小贴士:</p><ul class=""><li id="045f" class="lw lx hi is b it iu ix iy jb ly jf lz jj ma jn mb mc md me bi translated"><code class="du jo jp jq jr b">array.shift()</code>就地变异数组</li><li id="1943" class="lw lx hi is b it mf ix mg jb mh jf mi jj mj jn mb mc md me bi translated"><code class="du jo jp jq jr b">array.shift()</code>具有O(n)复杂度。</li></ul><h2 id="5822" class="kv jt hi bd ju kw kx ky jy kz la lb kc jb lc ld kg jf le lf kk jj lg lh ko li bi translated">11.3 array.splice()方法</h2><p id="43e5" class="pw-post-body-paragraph iq ir hi is b it kq iv iw ix kr iz ja jb ks jd je jf kt jh ji jj ku jl jm jn hb bi translated"><code class="du jo jp jq jr b">array.splice(fromIndex[, removeCount[, item1[, item2[, ...]]]])</code>从数组中删除项目并插入新项目。</p><p id="86b5" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">例如，让我们从索引<code class="du jo jp jq jr b">1</code>中删除2项:</p><pre class="lj lk ll lm fd ln jr lo lp aw lq bi"><span id="0c33" class="kv jt hi jr b fi lr ls l lt lu">const names = ['Batman', 'Catwoman', 'Joker', 'Bane'];</span><span id="0e10" class="kv jt hi jr b fi lv ls l lt lu">names.splice(1, 2);</span><span id="eb47" class="kv jt hi jr b fi lv ls l lt lu">names; // =&gt; ['Batman', 'Bane']</span></pre><p id="fa17" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><code class="du jo jp jq jr b">names.splice(1, 2)</code>删除元素<code class="du jo jp jq jr b">'Catwoman'</code>和<code class="du jo jp jq jr b">'Joker'</code>。</p><p id="ece1" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><code class="du jo jp jq jr b">names.splice()</code>可以插入新的物品代替已删除的物品。让我们替换索引<code class="du jo jp jq jr b">1</code>中的2个项目，并插入一个新项目<code class="du jo jp jq jr b">'Alfred'</code>:</p><pre class="lj lk ll lm fd ln jr lo lp aw lq bi"><span id="0fc9" class="kv jt hi jr b fi lr ls l lt lu">const names = ['Batman', 'Catwoman', 'Joker', 'Bane'];</span><span id="fa04" class="kv jt hi jr b fi lv ls l lt lu">names.splice(1, 2, 'Alfred');</span><span id="a091" class="kv jt hi jr b fi lv ls l lt lu">names; // =&gt; ['Batman', 'Alfred' ,'Bane']</span></pre><p id="a58c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">小贴士:</p><ul class=""><li id="ebf0" class="lw lx hi is b it iu ix iy jb ly jf lz jj ma jn mb mc md me bi translated"><code class="du jo jp jq jr b">array.splice()</code>原地变异阵列。</li></ul><h2 id="ea36" class="kv jt hi bd ju kw kx ky jy kz la lb kc jb lc ld kg jf le lf kk jj lg lh ko li bi translated">11.4扩展运算符</h2><p id="fa78" class="pw-post-body-paragraph iq ir hi is b it kq iv iw ix kr iz ja jb ks jd je jf kt jh ji jj ku jl jm jn hb bi translated">通过将spread运算符与数组文字相结合，可以以不可变的方式从数组中移除项。</p><p id="ad13" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">让我们删除一些项目:</p><pre class="lj lk ll lm fd ln jr lo lp aw lq bi"><span id="58b9" class="kv jt hi jr b fi lr ls l lt lu">const names = ['Batman', 'Catwoman', 'Joker', 'Bane'];<br/>const fromIndex = 1;<br/>const removeCount = 2;</span><span id="5234" class="kv jt hi jr b fi lv ls l lt lu">const newNames = [<br/>  ...names.slice(0, fromIndex),<br/>  ...names.slice(fromIndex + removeCount)<br/>];</span><span id="4c84" class="kv jt hi jr b fi lv ls l lt lu">newNames; // =&gt; ['Batman', 'Bane']</span></pre><p id="1742" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><code class="du jo jp jq jr b">newNames</code>包含<code class="du jo jp jq jr b">names</code>的项目，但没有被删除的2个。</p><h1 id="e3d1" class="js jt hi bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">12.空的</h1><h2 id="9018" class="kv jt hi bd ju kw kx ky jy kz la lb kc jb lc ld kg jf le lf kk jj lg lh ko li bi translated">12.1数组长度属性</h2><p id="232f" class="pw-post-body-paragraph iq ir hi is b it kq iv iw ix kr iz ja jb ks jd je jf kt jh ji jj ku jl jm jn hb bi translated"><code class="du jo jp jq jr b">array.length</code>是保存数组长度的属性。不止如此，<code class="du jo jp jq jr b">array.length</code>是可写的。</p><p id="2d82" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如果你写一个小于当前长度的<code class="du jo jp jq jr b">array.length = newLength</code>，多余的元素将从数组中移除。</p><p id="bdd9" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">让我们使用<code class="du jo jp jq jr b">array.length = 0</code>来移除数组中的所有项目:</p><pre class="lj lk ll lm fd ln jr lo lp aw lq bi"><span id="6436" class="kv jt hi jr b fi lr ls l lt lu">const colors = ['blue', 'green', 'black'];</span><span id="fcdd" class="kv jt hi jr b fi lv ls l lt lu">colors.length = 0;</span><span id="51e2" class="kv jt hi jr b fi lv ls l lt lu">colors; // []</span></pre><p id="6641" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><code class="du jo jp jq jr b">colors.length = 0</code>从<code class="du jo jp jq jr b">colors</code>数组中移除所有项目。</p><h2 id="36a9" class="kv jt hi bd ju kw kx ky jy kz la lb kc jb lc ld kg jf le lf kk jj lg lh ko li bi translated">12.2 array.splice()方法</h2><p id="bfee" class="pw-post-body-paragraph iq ir hi is b it kq iv iw ix kr iz ja jb ks jd je jf kt jh ji jj ku jl jm jn hb bi translated"><code class="du jo jp jq jr b">array.splice(fromIndex[, removeCount[, item1[, item2[, ...]]]])</code>从数组中删除项目并插入新项目。</p><p id="d392" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如果省略了<code class="du jo jp jq jr b">removeCount</code>参数，那么<code class="du jo jp jq jr b">array.splice()</code>将删除从<code class="du jo jp jq jr b">fromIndex</code>开始的数组的所有元素。</p><p id="708e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">让我们用它来删除数组中的所有元素:</p><pre class="lj lk ll lm fd ln jr lo lp aw lq bi"><span id="2f95" class="kv jt hi jr b fi lr ls l lt lu">const colors = ['blue', 'green', 'black'];</span><span id="5d49" class="kv jt hi jr b fi lv ls l lt lu">colors.splice(0);</span><span id="8b3a" class="kv jt hi jr b fi lv ls l lt lu">colors; // []</span></pre><p id="03b9" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><code class="du jo jp jq jr b">colors.splice(0)</code>删除<code class="du jo jp jq jr b">colors</code>数组的所有元素。</p><h1 id="92be" class="js jt hi bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">13.充满</h1><h2 id="4986" class="kv jt hi bd ju kw kx ky jy kz la lb kc jb lc ld kg jf le lf kk jj lg lh ko li bi translated">13.1数组.填充()方法</h2><p id="e97e" class="pw-post-body-paragraph iq ir hi is b it kq iv iw ix kr iz ja jb ks jd je jf kt jh ji jj ku jl jm jn hb bi translated"><code class="du jo jp jq jr b">array.fill(value[, fromIndex[, toIndex]])</code>从<code class="du jo jp jq jr b">fromIndex</code>开始到<code class="du jo jp jq jr b">toIndex</code>用<code class="du jo jp jq jr b">value</code>填充数组(不包括<code class="du jo jp jq jr b">toIndex</code>本身)。<code class="du jo jp jq jr b">fromIndex</code>可选参数默认为<code class="du jo jp jq jr b">0</code>，<code class="du jo jp jq jr b">toIndex</code>可选参数默认为<code class="du jo jp jq jr b">array.length</code>。</p><p id="e67e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">例如，让我们用零值填充一个数组:</p><pre class="lj lk ll lm fd ln jr lo lp aw lq bi"><span id="286e" class="kv jt hi jr b fi lr ls l lt lu">const numbers = [1, 2, 3, 4];</span><span id="a09e" class="kv jt hi jr b fi lv ls l lt lu">numbers.fill(0);</span><span id="de63" class="kv jt hi jr b fi lv ls l lt lu">numbers; // =&gt; [0, 0, 0, 0]</span></pre><p id="f2c3" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">用零填充数组。</p><p id="6b1f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">不仅如此，您还可以使用<code class="du jo jp jq jr b">Array(length).fill(initial)</code>初始化特定长度和初始值的数组:</p><pre class="lj lk ll lm fd ln jr lo lp aw lq bi"><span id="a0e7" class="kv jt hi jr b fi lr ls l lt lu">const length = 3;<br/>const zeros = Array(length).fill(0);</span><span id="4480" class="kv jt hi jr b fi lv ls l lt lu">zeros; // [0, 0, 0]</span></pre><p id="7aea" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">创建一个由3个零组成的数组。</p><p id="68be" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">小贴士:</p><ul class=""><li id="3d04" class="lw lx hi is b it iu ix iy jb ly jf lz jj ma jn mb mc md me bi translated"><code class="du jo jp jq jr b">array.fill()</code>就地变异阵列。</li></ul><h2 id="d909" class="kv jt hi bd ju kw kx ky jy kz la lb kc jb lc ld kg jf le lf kk jj lg lh ko li bi translated">13.2 Array.from()函数</h2><p id="95fe" class="pw-post-body-paragraph iq ir hi is b it kq iv iw ix kr iz ja jb ks jd je jf kt jh ji jj ku jl jm jn hb bi translated"><code class="du jo jp jq jr b">Array.from()</code>可以用对象来初始化一个一定长度的数组:</p><pre class="lj lk ll lm fd ln jr lo lp aw lq bi"><span id="0a9e" class="kv jt hi jr b fi lr ls l lt lu">const length = 4;<br/>const emptyObjects = Array.from(Array(length), function() {<br/>  return {};<br/>});</span><span id="2dfe" class="kv jt hi jr b fi lv ls l lt lu">emptyObjects; // [{}, {}, {}, {}]</span></pre><p id="6d88" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><code class="du jo jp jq jr b">emptyObjects</code>是用空对象的不同实例初始化的数组。</p><h1 id="b579" class="js jt hi bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">14.变平</h1><h2 id="2d6f" class="kv jt hi bd ju kw kx ky jy kz la lb kc jb lc ld kg jf le lf kk jj lg lh ko li bi translated">14.1 array.flat()方法</h2><p id="a7f7" class="pw-post-body-paragraph iq ir hi is b it kq iv iw ix kr iz ja jb ks jd je jf kt jh ji jj ku jl jm jn hb bi translated"><code class="du jo jp jq jr b">array.flat([depth])</code>方法通过递归平坦化数组中的项目来创建一个新的数组，直到某个<code class="du jo jp jq jr b">depth</code>。<code class="du jo jp jq jr b">depth</code>可选参数默认为<code class="du jo jp jq jr b">1</code>。</p><p id="3aea" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">让我们展平数组的数组:</p><pre class="lj lk ll lm fd ln jr lo lp aw lq bi"><span id="1bea" class="kv jt hi jr b fi lr ls l lt lu">const arrays = [0, [1, 3, 5], [2, 4, 6]];</span><span id="bae0" class="kv jt hi jr b fi lv ls l lt lu">const flatArray = arrays.flat();</span><span id="6426" class="kv jt hi jr b fi lv ls l lt lu">flatArray; // [0, 1, 3, 5, 2, 4, 6]</span></pre><p id="0e55" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><code class="du jo jp jq jr b">arrays</code>包含数字和数字数组的混合。<code class="du jo jp jq jr b">arrays.flat()</code>平坦化数组，使其只包含数字。</p><p id="ea43" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">小贴士:</p><ul class=""><li id="d49a" class="lw lx hi is b it iu ix iy jb ly jf lz jj ma jn mb mc md me bi translated">创建一个新数组，而不改变原来的数组。</li></ul><h1 id="5134" class="js jt hi bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">15.分类</h1><h2 id="b84f" class="kv jt hi bd ju kw kx ky jy kz la lb kc jb lc ld kg jf le lf kk jj lg lh ko li bi translated">15.1 array.sort()方法</h2><p id="5442" class="pw-post-body-paragraph iq ir hi is b it kq iv iw ix kr iz ja jb ks jd je jf kt jh ji jj ku jl jm jn hb bi translated">方法对数组中的项目进行排序。当省略compare函数时，该方法将这些项转换为字符串，然后按照UTF-16代码单位值对它们进行升序排序。</p><p id="7f9a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">可选参数<code class="du jo jp jq jr b">compare(item1, item2)</code>是一个定制项目顺序的回调函数。如果<code class="du jo jp jq jr b">compare(item1, item2)</code>返回:</p><ul class=""><li id="8067" class="lw lx hi is b it iu ix iy jb ly jf lz jj ma jn mb mc md me bi translated">在排序后的数组中，<code class="du jo jp jq jr b">-1</code>之后是<code class="du jo jp jq jr b">item1</code></li><li id="e834" class="lw lx hi is b it mf ix mg jb mh jf mi jj mj jn mb mc md me bi translated">在排序后的数组中，<code class="du jo jp jq jr b">1</code>之后是<code class="du jo jp jq jr b">item2</code></li><li id="a3eb" class="lw lx hi is b it mf ix mg jb mh jf mi jj mj jn mb mc md me bi translated"><code class="du jo jp jq jr b">0</code>那么项目的位置不会改变</li></ul><p id="a0b3" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">让我们对一组字母进行排序:</p><pre class="lj lk ll lm fd ln jr lo lp aw lq bi"><span id="44fe" class="kv jt hi jr b fi lr ls l lt lu">const letters = ['B', 'C', 'A'];</span><span id="dbb6" class="kv jt hi jr b fi lv ls l lt lu">letters.sort();</span><span id="76b5" class="kv jt hi jr b fi lv ls l lt lu">letters; // =&gt; ['A', 'B', 'C']</span></pre><p id="9723" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><code class="du jo jp jq jr b">letters.sort()</code>按升序排列字母。</p><p id="c94b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">让我们使用比较函数，使偶数后跟奇数:</p><pre class="lj lk ll lm fd ln jr lo lp aw lq bi"><span id="63c1" class="kv jt hi jr b fi lr ls l lt lu">const numbers = [4, 3, 1, 2];</span><span id="2b5c" class="kv jt hi jr b fi lv ls l lt lu">function compare(n1, n2) {<br/>  if (n1 % 2 === 0 &amp;&amp; n2 % 2 !== 0) {<br/>    return -1;<br/>  }<br/>  if (n1 % 2 !== 0 &amp;&amp; n2 % 2 === 0) {<br/>    return 1;<br/>  }<br/>  return 0;<br/>}</span><span id="385d" class="kv jt hi jr b fi lv ls l lt lu">numbers.sort(compare);</span><span id="23f2" class="kv jt hi jr b fi lv ls l lt lu">numbers; // =&gt; [4, 2, 3, 1]</span></pre><p id="3beb" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><code class="du jo jp jq jr b">numbers.sort(compare)</code>使用自定义比较功能，首先对偶数进行排序。</p><p id="1140" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">小贴士:</p><ul class=""><li id="1b5d" class="lw lx hi is b it iu ix iy jb ly jf lz jj ma jn mb mc md me bi translated"><code class="du jo jp jq jr b">array.sort()</code>就地变异数组。</li></ul></div></div>    
</body>
</html>