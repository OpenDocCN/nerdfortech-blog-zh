<html>
<head>
<title>Distributed Task Scheduler — Redis</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">分布式任务调度程序</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/distributed-task-scheduler-redis-329475df9dcf?source=collection_archive---------1-----------------------#2021-03-27">https://medium.com/nerd-for-tech/distributed-task-scheduler-redis-329475df9dcf?source=collection_archive---------1-----------------------#2021-03-27</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/b807a240b70f535a7363db3e992e1ef4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6Ji_bz2-eFljLbf6aOt9bQ.jpeg"/></div></div></figure><p id="d693" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">Redis 已经成为分布式微服务应用领域中的一个重要组件，这是由于它的简单性、性能和清晰的特性集。这篇文章是关于使用 Redis 的一些特性构建一个任务调度系统。为了定义界限和解释方式，要求选择如下。</p><h1 id="c0e0" class="jo jp hi bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">要求:</h1><ul class=""><li id="31bf" class="km kn hi is b it ko ix kp jb kq jf kr jj ks jn kt ku kv kw bi translated">该系统必须是可扩展的和分布式的</li><li id="e4bf" class="km kn hi is b it kx ix ky jb kz jf la jj lb jn kt ku kv kw bi translated">多个工作进程</li><li id="96b8" class="km kn hi is b it kx ix ky jb kz jf la jj lb jn kt ku kv kw bi translated">任务可以是实时的或延迟的</li><li id="e6c3" class="km kn hi is b it kx ix ky jb kz jf la jj lb jn kt ku kv kw bi translated">空闲时资源消耗应该最小</li></ul><h1 id="cfe5" class="jo jp hi bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">设计</h1><figure class="ld le lf lg fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lc"><img src="../Images/003b49f4756a0c877f04ffbeac662525.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4QijUwRApW3Yjd2KmanY3Q.jpeg"/></div></div><figcaption class="lh li et er es lj lk bd b be z dx translated">任务调度系统—框图</figcaption></figure><p id="15b0" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">该系统由四个<strong class="is hj">部件</strong>组成</p><ul class=""><li id="dfb4" class="km kn hi is b it iu ix iy jb ll jf lm jj ln jn kt ku kv kw bi translated">任务 API:任务生成者</li><li id="097f" class="km kn hi is b it kx ix ky jb kz jf la jj lb jn kt ku kv kw bi translated">REDIS:一种分布式数据结构，支持有序集合和 FIFO 列表</li><li id="8dce" class="km kn hi is b it kx ix ky jb kz jf la jj lb jn kt ku kv kw bi translated">任务调度器:读取任务并在精确的时间内将它们推到列表中</li><li id="df07" class="km kn hi is b it kx ix ky jb kz jf la jj lb jn kt ku kv kw bi translated">任务工作者:任务消费者</li></ul><h2 id="8c0e" class="lo jp hi bd jq lp lq lr ju ls lt lu jy jb lv lw kc jf lx ly kg jj lz ma kk mb bi translated">步骤:</h2><ol class=""><li id="1f8f" class="km kn hi is b it ko ix kp jb kq jf kr jj ks jn mc ku kv kw bi translated">任务 API 计算分数，并将任务项和分数一起添加到 ZSET 中</li><li id="5e4c" class="km kn hi is b it kx ix ky jb kz jf la jj lb jn mc ku kv kw bi translated">任务计划程序不断检查集合的第一项。</li><li id="7664" class="km kn hi is b it kx ix ky jb kz jf la jj lb jn mc ku kv kw bi translated">如果分数与当前时间匹配，该项目将被推入工作队列</li><li id="1b14" class="km kn hi is b it kx ix ky jb kz jf la jj lb jn mc ku kv kw bi translated">任务工作线程停留在阻塞队列中，一旦有项目添加到队列中，就立即执行</li></ol><h2 id="5fb7" class="lo jp hi bd jq lp lq lr ju ls lt lu jy jb lv lw kc jf lx ly kg jj lz ma kk mb bi translated">任务 API</h2><p id="c920" class="pw-post-body-paragraph iq ir hi is b it ko iv iw ix kp iz ja jb md jd je jf me jh ji jj mf jl jm jn hb bi translated">任务 API 是一个<a class="ae mg" href="http://restify.com/" rel="noopener ugc nofollow" target="_blank"> restify </a> POST 处理程序，它接受任务并根据“when”属性将其推送到 Redis。每个推送到<a class="ae mg" href="https://redis.io/commands/ZADD" rel="noopener ugc nofollow" target="_blank"> ZSET </a>的条目将是一个 JSON 编码的数组，包含三个条目(标识符、工作队列名和任务细节)。在 ZSET 中，每个成员都与一个分数相关联，该分数按照升序对集合进行排序。“when”属性经过纪元转换并被指定为分数。</p><pre class="ld le lf lg fd mh mi mj mk aw ml bi"><span id="0b7e" class="lo jp hi mi b fi mm mn l mo mp">async SaveTask(req, res, next) {<br/>        let queue = req.params.queue;<br/>        let id = uuidV4();<br/>        let time = req.body.when;<br/>        let item = [id, queue, req.body.task];<br/>        let score = 0;<br/>        let status = 'PENDING';<br/>        if (time) {<br/>            score = new Date(time).getTime()<br/>            console.log(`Push task ${id} to process later on ${time} `);<br/>            await redisHandler.AddToSortedSet(JSON.stringify(item), score);<br/>            status = 'SCHEDULED';</span><span id="7d02" class="lo jp hi mi b fi mq mn l mo mp">} else {<br/>            console.log(`Push task ${id} to execute in relatime`);<br/>            await redisHandler.AddItemToQueue(queue, JSON.stringify(item));<br/>            status = 'QUEUED';<br/>        }</span><span id="e27c" class="lo jp hi mi b fi mq mn l mo mp">res.send({ item: item, score: score, status: status });</span><span id="f01e" class="lo jp hi mi b fi mq mn l mo mp">}</span></pre><p id="ee76" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><a class="ae mg" href="https://github.com/luin/ioredis" rel="noopener ugc nofollow" target="_blank"> ioredis </a>代码段</p><pre class="ld le lf lg fd mh mi mj mk aw ml bi"><span id="8449" class="lo jp hi mi b fi mm mn l mo mp">async AddToSortedSet(item, value) {<br/>        return new Promise((resolve, reject) =&gt; {<br/>            this.redisClient.zadd(`ZSET:SCHEDULED:ITEMS`, value, item, (err, result) =&gt; {<br/>                if (err) {<br/>                    reject(err);<br/>                } else {<br/>                    resolve(result);<br/>                }<br/>            })<br/>        })<br/>    }</span></pre><figure class="ld le lf lg fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mr"><img src="../Images/f32273a4d9c066dd5fd2cae3e92f1459.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZglEETcMUXHDeni5iqSqwg.png"/></div></div><figcaption class="lh li et er es lj lk bd b be z dx translated">ZSET 值</figcaption></figure></div><div class="ab cl ms mt gp mu" role="separator"><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx"/></div><div class="hb hc hd he hf"><h2 id="49b8" class="lo jp hi bd jq lp lq lr ju ls lt lu jy jb lv lw kc jf lx ly kg jj lz ma kk mb bi translated">任务调度程序</h2><p id="5a66" class="pw-post-body-paragraph iq ir hi is b it ko iv iw ix kp iz ja jb md jd je jf me jh ji jj mf jl jm jn hb bi translated">任务调度程序获得锁，然后处理临界区。它从 ZSET 中读取第一项，并将“when”与当前时间进行比较。选定的任务从 ZSET 中删除，并推送到相关的队列进行处理。</p><pre class="ld le lf lg fd mh mi mj mk aw ml bi"><span id="1eb5" class="lo jp hi mi b fi mm mn l mo mp">async ProcessEvents() {<br/>  while (true) {<br/>    try {<br/>      await lock.acquire(`LOCK:ZSET:ITEMS`);<br/>      try {<br/>        let value = await redisHandler.GetTopFromSortedSet();<br/>        if (value &amp;&amp; value.length &gt; 0) {<br/>          let item = JSON.parse(value[0]);<br/>          let time = value[1];<br/>          if (parseFloat(time) &lt;= Date.now()) {<br/>            console.log(`Scheduled item ${item[0]} ready to process`);<br/>            await redisHandler.DeleteItemFromSet(value[0]);<br/>            await redisHandler.AddItemToQueue(item[1], value[0]);<br/>          }<br/>        }else {<br/>          //No items to work process wait 1s before check again<br/>          await lock.release();<br/>          await new Promise(r =&gt; setTimeout(r, 1000));<br/>          continue;<br/>        }<br/>      } catch (ex) {<br/>        console.log(`Error on event processing ${ex.message}`);<br/>      }<br/>      await lock.release();<br/>    } catch (ex) {<br/>      // error in acquiring or releasing the lock<br/>    }<br/>    await new Promise(r =&gt; setTimeout(r, 100));<br/>  }<br/>}</span></pre><p id="3194" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><a class="ae mg" href="https://github.com/luin/ioredis" rel="noopener ugc nofollow" target="_blank"> ioredis </a>代码段</p><pre class="ld le lf lg fd mh mi mj mk aw ml bi"><span id="4a87" class="lo jp hi mi b fi mm mn l mo mp">async GetTopFromSortedSet() {<br/>        return new Promise((resolve, reject) =&gt; {</span><span id="d615" class="lo jp hi mi b fi mq mn l mo mp">this.redisClient.zrange(`ZSET:SCHEDULED:ITEMS`, 0, 0, "WITHSCORES", (err, result) =&gt; {<br/>                if (err) {<br/>                    reject(err);<br/>                } else {<br/>                    resolve(result);<br/>                }<br/>            })<br/>        })<br/>    }</span><span id="9f90" class="lo jp hi mi b fi mq mn l mo mp">async DeleteItemFromSet(item) {<br/>        return new Promise((resolve, reject) =&gt; {</span><span id="cb52" class="lo jp hi mi b fi mq mn l mo mp">this.redisClient.zrem(`ZSET:SCHEDULED:ITEMS`, item, (err, result) =&gt; {<br/>                if (err) {<br/>                    reject(err);<br/>                } else {<br/>                    resolve(result);<br/>                }<br/>            })<br/>        })<br/>    }</span><span id="677c" class="lo jp hi mi b fi mq mn l mo mp">async AddItemToQueue(key, item) {<br/>        return new Promise((resolve, reject) =&gt; {</span><span id="07a7" class="lo jp hi mi b fi mq mn l mo mp">this.redisClient.rpush(`QUEUE:${key}`, item, (err, result) =&gt; {<br/>                if (err) {<br/>                    reject(err);<br/>                } else {<br/>                    resolve(result);<br/>                }<br/>            })<br/>        })<br/>    }</span></pre></div><div class="ab cl ms mt gp mu" role="separator"><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx"/></div><div class="hb hc hd he hf"><h2 id="d8ce" class="lo jp hi bd jq lp lq lr ju ls lt lu jy jb lv lw kc jf lx ly kg jj lz ma kk mb bi translated">任务处理器</h2><p id="93a0" class="pw-post-body-paragraph iq ir hi is b it ko iv iw ix kp iz ja jb md jd je jf me jh ji jj mf jl jm jn hb bi translated">任务处理器使用阻塞左 pop ( <strong class="is hj"> <em class="mz"> blpop </em> </strong>)方法模仿 FIFO 行为。只要列表中有一项可用，方法就会释放该进程。它<strong class="is hj">需要一个专用的 Redis 客户端来阻塞操作</strong>，因为它也阻塞其他 Redis 操作。</p><pre class="ld le lf lg fd mh mi mj mk aw ml bi"><span id="3e68" class="lo jp hi mi b fi mm mn l mo mp">async ProcessTasks(queue) {</span><span id="136c" class="lo jp hi mi b fi mq mn l mo mp">while (true) {</span><span id="1ab2" class="lo jp hi mi b fi mq mn l mo mp">let taskArray = await redisHandler.GetItemFromQueueBlocking(queue);<br/>            if (taskArray &amp;&amp; taskArray.length &gt; 1) {<br/>                let task = JSON.parse(taskArray[1]);<br/>                if (task &amp;&amp; Array.isArray(task) &amp;&amp; task.length &gt; 2) {<br/>                    let item = task[2];<br/>                    console.log(`Task ${task[0]} ready to process - action: ${item.action} params: ${item.time}`);<br/>                    await new Promise(r =&gt; setTimeout(r, item.time));<br/>                }<br/>            }<br/>        }</span><span id="ebba" class="lo jp hi mi b fi mq mn l mo mp">}</span></pre><p id="83a9" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><a class="ae mg" href="https://github.com/luin/ioredis" rel="noopener ugc nofollow" target="_blank"> ioredis </a>代码段</p><pre class="ld le lf lg fd mh mi mj mk aw ml bi"><span id="09f1" class="lo jp hi mi b fi mm mn l mo mp">async GetItemFromQueueBlocking(key) {<br/>        return new Promise((resolve, reject) =&gt; {</span><span id="c2ff" class="lo jp hi mi b fi mq mn l mo mp">this.redisClient.blpop(`QUEUE:${key}`, 5000, (err, result) =&gt; {<br/>                if (err) {<br/>                    reject(err);<br/>                } else {<br/>                    resolve(result);<br/>                }<br/>            })<br/>        })<br/>    }</span></pre><h1 id="c2c8" class="jo jp hi bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">讨论</h1><p id="1afb" class="pw-post-body-paragraph iq ir hi is b it ko iv iw ix kp iz ja jb md jd je jf me jh ji jj mf jl jm jn hb bi translated">Redis 是在微服务领域实现各种分布式模式的优秀工具。有许多数据结构可以用来实现这些模式。其中一些是分布式锁、发布和订阅、仪表板的原子计数器、使用搜索的自动完成系统。可以在<a class="ae mg" href="https://github.com/sukitha/distributed-task-scheduler" rel="noopener ugc nofollow" target="_blank"> git </a>上找到源代码。</p></div></div>    
</body>
</html>