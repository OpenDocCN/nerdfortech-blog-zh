<html>
<head>
<title>Cross-compiling a Sample Application Using Automotive Grade Linux</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用汽车级 Linux 交叉编译示例应用程序</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/cross-compiling-a-sample-application-using-automotive-grade-linux-d432effb297c?source=collection_archive---------3-----------------------#2021-02-24">https://medium.com/nerd-for-tech/cross-compiling-a-sample-application-using-automotive-grade-linux-d432effb297c?source=collection_archive---------3-----------------------#2021-02-24</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><figure class="hh hi ez fb hj hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es hg"><img src="../Images/de77cad7006acd8ffc58da47637297b1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Bp9QKVW6Q8CJLbuKMckHeQ.png"/></div></div></figure><div class=""/><p id="4b8d" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">本文的目的是描述我在汽车级 Linux (AGL)的保护伞下交叉编译和部署一个简单程序到 Raspberry Pi 4 目标的过程。您将一步一步地生成一个更具<em class="jo">开发级别的</em>生态系统，使用它交叉编译一个示例应用程序，将其部署到运行您将构建的映像的 Raspberry Pi 4 目标，并通过<code class="du jp jq jr js b">ssh</code>远程 shell 直接从您的目标运行它。</p><p id="3f24" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">对于新手来说，交叉编译本身并不是一项简单的任务，所以，如果你有什么不明白的地方，请给我留言和/或通读关于交叉编译的其他资料。</p></div><div class="ab cl jt ju gp jv" role="separator"><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy"/></div><div class="hb hc hd he hf"><h1 id="5bb4" class="ka kb ht bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated">获取开发工具</h1><p id="02a1" class="pw-post-body-paragraph iq ir ht is b it ky iv iw ix kz iz ja jb la jd je jf lb jh ji jj lc jl jm jn hb bi translated">所以，如果你在 Raspberry Pi 4 上运行汽车级 Linux<a class="ae ld" href="https://pauloasherring.medium.com/running-automotive-grade-linux-on-a-raspberry-pi-4-535490ddda82" rel="noopener">，我有一些坏消息<em class="jo">:你需要在这里和那里改变一些东西，以获得正确的工具。这是因为默认配置不包括一些基本工具，最明显的是 GDB。此外，在之前的文章中，没有生成软件开发工具包(SDK)。</em></a></p><p id="c527" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我假设您已经设置好了主机系统。如果没有，请安装 Ubuntu 16.04 或者使用我们在运行汽车级 Linux 的<a class="ae ld" href="https://pauloasherring.medium.com/running-automotive-grade-linux-on-a-raspberry-pi-4-535490ddda82" rel="noopener">上配置的 docker 镜像。</a></p><p id="947e" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">第一个变化是在<code class="du jp jq jr js b">build/conf/local.conf</code>中添加几行代码，以便将所需的内容添加到可刷新的映像和可安装的 SDK 中。在这里，大约在第 143 行，我读到了<code class="du jp jq jr js b">EXTRA_IMAGE_FEATURES ?= "debug-tweaks"</code>。在此之下，添加以下内容:</p><pre class="le lf lg lh fd li js lj lk aw ll bi"><span id="4706" class="lm kb ht js b fi ln lo l lp lq">EXTRA_IMAGE_FEATURES += "tools-sdk"<br/>EXTRA_IMAGE_FEATURES += "tools-debug"<br/>EXTRA_IMAGE_FEATURES += "eclipse-debug"</span></pre><p id="036b" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">对它们的描述就在 build/conf/local.conf 上的插入点上方，但我还是复制到了这里:</p><ul class=""><li id="7e64" class="lr ls ht is b it iu ix iy jb lt jf lu jj lv jn lw lx ly lz bi translated">“工具-SDK”——添加开发工具(gcc、make、pkgconfig 等。);</li><li id="ee58" class="lr ls ht is b it ma ix mb jb mc jf md jj me jn lw lx ly lz bi translated">“工具-调试”——添加调试工具(gdb、strace)；</li><li id="f1c5" class="lr ls ht is b it ma ix mb jb mc jf md jj me jn lw lx ly lz bi translated">“eclipse-debug”——添加 Eclipse 远程调试支持。</li></ul><p id="58b5" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">经过这些改变，我们准备好<code class="du jp jq jr js b">bitbake</code>。下面的命令行假设您正在为此使用 docker 映像，因此您可能需要修改路径以适应<em class="jo"> repo </em>工具。</p><pre class="le lf lg lh fd li js lj lk aw ll bi"><span id="829d" class="lm kb ht js b fi ln lo l lp lq">./../bin/repo init -b koi -u https://gerrit.automotivelinux.org/gerrit/AGL/AGL-repo<br/>./../bin/repo sync<br/>source meta-agl/scripts/aglsetup.sh -m raspberrypi4 agl-demo agl-appfw-smack<br/>bitbake agl-demo-platform &amp;&amp; bitbake agl-demo-platform-crosssdk</span></pre><p id="8ddc" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">注意，最后一行将为两个目标构建:<code class="du jp jq jr js b">agl-demo-platform</code>和<code class="du jp jq jr js b">agl-demo-platform-crosssdk</code>。前者将生成目标的映像，后者将生成目标的映像和可安装的 SDK。如果这是您的第一次构建，应该需要几个小时才能完成。</p><p id="7885" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">生成的映像和 SDK 安装程序可以分别在<code class="du jp jq jr js b">/build/tmp/deploy/images/raspberrypi-64</code>和<code class="du jp jq jr js b">/build/tmp/deploy/sdk</code>上找到。</p><figure class="le lf lg lh fd hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es mf"><img src="../Images/86d15e0be9d4363459b9d85ae0c257eb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*YtGLYCmE_-9-pOGp"/></div></div></figure><figure class="le lf lg lh fd hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es mf"><img src="../Images/a1afe60e89c446c4c84829594ae72327.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*VCdC_AJegJsRI_bO"/></div></div></figure><p id="d499" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">为您新生成的图像闪存 sd 卡。从终端，导航到<code class="du jp jq jr js b">~/agl/out/build/tmp/deploy/images/raspberrypi4–64</code>。在那里，你会发现一个 flashable 图像，一个用 xz 压缩的 wic 文件。要刷新您的新映像，请运行:</p><pre class="le lf lg lh fd li js lj lk aw ll bi"><span id="fd29" class="lm kb ht js b fi ln lo l lp lq">xzcat {yourimagename}.wic.xz| sudo dd of=/dev/{your-sd-disk} bs=4M status=progress<br/>sync</span></pre><p id="8a4c" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">安装 SDK。从终端，导航<code class="du jp jq jr js b">to ~/agl/out/build/tmp/deploy/sdk</code>并运行您的 SDK 安装程序文件:</p><p id="8456" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><code class="du jp jq jr js b">./poky-agl-glibc-x86_64-agl-demo-platform-crosssdk-aarch64-raspberrypi4-64-toolchain-10.93.1.sh</code></p><p id="adde" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">您必须与终端进行交互:</p><ul class=""><li id="0e64" class="lr ls ht is b it iu ix iy jb lt jf lu jj lv jn lw lx ly lz bi translated">您将被要求输入保存 SDK 的目标路径，可以选择使用默认路径，<code class="du jp jq jr js b">/opt/agl-sdk/10.93.1-aarch64</code>；</li><li id="d882" class="lr ls ht is b it ma ix mb jb mc jf md jj me jn lw lx ly lz bi translated">将询问您是否要继续安装:<code class="du jp jq jr js b">y</code>；</li><li id="1089" class="lr ls ht is b it ma ix mb jb mc jf md jj me jn lw lx ly lz bi translated">您将被要求管理员凭证:<code class="du jp jq jr js b">enter your password</code>。</li></ul><figure class="le lf lg lh fd hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es mf"><img src="../Images/b75763559813cd6426496398e4af45b9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*omBXQ16b-9nI_hdT"/></div></div></figure><p id="aa8e" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">安装程序将启动。应该需要一段时间才能完成。完成后，您会得到一个非常基本但很好的用法说明:</p><pre class="le lf lg lh fd li js lj lk aw ll bi"><span id="4c3f" class="lm kb ht js b fi ln lo l lp lq">Each time you wish to use the SDK in a new shell session, you need to source the environment setup script e.g.<br/> $ . /opt/agl-sdk2/10.93-1-aarch64/environment-setup-aarch64-agl-linux</span></pre></div><div class="ab cl jt ju gp jv" role="separator"><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy"/></div><div class="hb hc hd he hf"><h1 id="f75d" class="ka kb ht bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated">构建示例应用程序</h1><p id="b9e9" class="pw-post-body-paragraph iq ir ht is b it ky iv iw ix kz iz ja jb la jd je jf lb jh ji jj lc jl jm jn hb bi translated">要构建您的第一个应用程序，首先要初始化您的 SDK。打开终端并获取初始化脚本:<code class="du jp jq jr js b">. /opt/agl-sdk/10.93-1-aarch64/environment-setup-aarch64-agl-linux</code>。这样做之后，您应该初始化一些环境变量。你可以用<code class="du jp jq jr js b">export</code>来检查它们。</p><figure class="le lf lg lh fd hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es mf"><img src="../Images/a2e1517e5cf4e38d01545cb09cc5d53e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*MKY_DOENQy63Rxp3"/></div></div></figure><p id="3369" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">此时，您可以通过输入<code class="du jp jq jr js b">$CC</code>环境变量来访问 GCC 的交叉编译器。例如，您可以通过输入<code class="du jp jq jr js b">$CC --version:</code>来检查交叉编译器的版本</p><figure class="le lf lg lh fd hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es mg"><img src="../Images/42edd146a2cdac67d7b83ab9cfc8f40c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*m8LRU-hoQs7hAGe2"/></div></div></figure><p id="7365" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如果您使用 IDE，您需要在启动 IDE 本身之前找到这个文件。例如，获得它之后，您可以通过运行<code class="du jp jq jr js b">code</code>从获得文件的同一个终端会话中运行它来运行微软的 Visual Studio 代码。</p><p id="6289" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如果您喜欢使用 VSCode，请打开并运行它。提示一下，要从 VSCode 内部运行命令，请按<code class="du jp jq jr js b">F1</code>。也就是说，执行以下操作:</p><ul class=""><li id="ab06" class="lr ls ht is b it iu ix iy jb lt jf lu jj lv jn lw lx ly lz bi translated">打开一个空文件夹作为工作区；</li><li id="f194" class="lr ls ht is b it ma ix mb jb mc jf md jj me jn lw lx ly lz bi translated">运行 CMake 的扩展<code class="du jp jq jr js b">Cmake: Scan For Kits</code>；</li><li id="9cf4" class="lr ls ht is b it ma ix mb jb mc jf md jj me jn lw lx ly lz bi translated">运行 CMake 的扩展<code class="du jp jq jr js b">Cmake: Quick Start</code>生成一个新的模板项目；</li><li id="053e" class="lr ls ht is b it ma ix mb jb mc jf md jj me jn lw lx ly lz bi translated">从列表中选择您的交叉编译器；</li><li id="8c57" class="lr ls ht is b it ma ix mb jb mc jf md jj me jn lw lx ly lz bi translated">可能会询问您是否要创建一个<code class="du jp jq jr js b">CMakeLists.txt </code>文件。如果有，请点击创建；</li><li id="13db" class="lr ls ht is b it ma ix mb jb mc jf md jj me jn lw lx ly lz bi translated">输入示例应用程序的名称:<code class="du jp jq jr js b">SampleApp</code>；</li><li id="c6d1" class="lr ls ht is b it ma ix mb jb mc jf md jj me jn lw lx ly lz bi translated">输入输出类型:<code class="du jp jq jr js b">executable</code>；</li><li id="08ad" class="lr ls ht is b it ma ix mb jb mc jf md jj me jn lw lx ly lz bi translated">运行 CMake 的扩展<code class="du jp jq jr js b">Cmake: Build</code>。</li></ul><figure class="le lf lg lh fd hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es mh"><img src="../Images/728866d8ca0e7f92921a5378de4b9121.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*-LSrs0n_gtqv3NGzs-2d3g.gif"/></div></div><figcaption class="mi mj et er es mk ml bd b be z dx translated">从 VSCode 使用 CMake 的扩展。</figcaption></figure><p id="7e88" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">转眼间。您已经构建了交叉编译的 Hello World，生成到<code class="du jp jq jr js b">./build/SampleApp</code>(或者您给项目起的任何名字:)</p></div><div class="ab cl jt ju gp jv" role="separator"><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy"/></div><div class="hb hc hd he hf"><h1 id="ca58" class="ka kb ht bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated">在目标上运行应用程序</h1><p id="69e6" class="pw-post-body-paragraph iq ir ht is b it ky iv iw ix kz iz ja jb la jd je jf lb jh ji jj lc jl jm jn hb bi translated">现在，您已经有了一个带有适当映像的目标和与之兼容的二进制文件。你只需要把它传送到目标并运行它！这里我假设您可以通过 ssh 访问目标的 shell，并且知道它的 IP 地址。</p><p id="74a7" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">所需的步骤如下:</p><ul class=""><li id="0138" class="lr ls ht is b it iu ix iy jb lt jf lu jj lv jn lw lx ly lz bi translated">将生成的二进制文件部署到目标上；</li><li id="f81d" class="lr ls ht is b it ma ix mb jb mc jf md jj me jn lw lx ly lz bi translated">通过 SSH 访问您的目标；</li><li id="0865" class="lr ls ht is b it ma ix mb jb mc jf md jj me jn lw lx ly lz bi translated">从 SSH 运行您的应用程序。</li></ul><p id="6f0b" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">请记住，您可能需要根据需要调整目标的 IP。T11】</p><pre class="le lf lg lh fd li js lj lk aw ll bi"><span id="73d7" class="lm kb ht js b fi ln lo l lp lq">scp ./SampleApp root@192.168.5.2:/home/1001</span></pre><p id="3cff" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">部署二进制:<code class="du jp jq jr js b">scp ./SampleApp root@192.168.5.2:/home/1001</code></p><p id="14f9" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">SSH 进入你的目标:<code class="du jp jq jr js b">ssh -l root 192.168.5.2</code></p><p id="1311" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">导航到<em class="jo"> /home/1001 </em> : <code class="du jp jq jr js b">cd /home/1001</code></p><p id="8e61" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">运行您的示例应用程序:<code class="du jp jq jr js b">./SampleApp</code></p><p id="dc91" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">你应该得到你的嵌入式<code class="du jp jq jr js b">Hello World</code>。</p><figure class="le lf lg lh fd hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es mh"><img src="../Images/8769bcf758f0c45b123625837c9d3d0b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*iOEnfPzSEUjejfUAKQd8KQ.gif"/></div></div><figcaption class="mi mj et er es mk ml bd b be z dx translated">部署和运行您的 Linux 嵌入式、交叉编译、Hello World。</figcaption></figure></div><div class="ab cl jt ju gp jv" role="separator"><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy"/></div><div class="hb hc hd he hf"><h1 id="a337" class="ka kb ht bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated">结论</h1><p id="0926" class="pw-post-body-paragraph iq ir ht is b it ky iv iw ix kz iz ja jb la jd je jf lb jh ji jj lc jl jm jn hb bi translated">在本文中，您已经使用 AGL 生成了一个更加<em class="jo">开发级别的</em>生态系统，使用 VSCode、CMake 和您自己构建的 AGL 的 SDK <em class="jo">开发了一个<code class="du jp jq jr js b">Hello World</code>！您还在您的 Raspberry Pi 4 目标上部署并运行了它。</em></p><p id="c16f" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">希望对你有帮助:)</p><p id="103c" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如果有，请告诉我。此外，反馈将非常感谢，因为这是我的第二个职位。</p><p id="33d6" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我计划写另一篇关于使用 GDB 从 IDE 和命令行进行远程调试的后续文章。</p></div></div>    
</body>
</html>