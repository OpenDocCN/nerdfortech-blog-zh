# 死锁及其 4 个必要条件和代码示例

> 原文：<https://medium.com/nerd-for-tech/deadlock-and-its-4-necessary-conditions-with-code-example-a5b6657c91f0?source=collection_archive---------0----------------------->

任何读过操作系统的人都会遇到死锁的概念。我们看到几篇文章给出了死锁的定义，并列出了死锁的 4 个必要条件。我觉得缺少文章，用一个简单的代码例子来演示死锁和 4 个条件。在本文中，我将展示一个代码，演示导致死锁的 4 种情况，并给出代码的一个演练。

首先，我想先给出“死锁”的定义和导致系统发生死锁的 4 个条件。之后，我将展示代码示例，并解释它如何导致死锁。

> [**死锁**](https://en.wikipedia.org/wiki/Deadlock) 是一种状态，其中组中的每个成员等待另一个成员(包括其自身)采取行动，例如发送消息或更常见的释放锁。

如果满足以下所有必要条件，就会发生死锁(转载自[维基](https://en.wikipedia.org/wiki/Deadlock)

1.  *互斥:*必须至少有一个资源处于不可共享模式。否则，就不会阻止进程在必要时使用资源。在任何给定的时刻，只有一个进程可以使用该资源。
2.  *保持并等待*或*资源保持:*一个进程当前至少保持一个资源，并请求被其他进程保持的额外资源。
3.  *无抢占:*资源只能由持有它的进程自愿释放。
4.  *循环等待:*每个进程必须等待另一个进程占用的资源，而另一个进程又在等待第一个进程释放资源。总的来说，有一组等待过程， *P* = { *P* 1， *P* 2，…， *PN* }，这样 *P* 1 在等待 *P* 2 持有的资源， *P* 2 在等待 *P* 3 持有的资源，以此类推，直到 *PN*

下面是一个代码示例，它通过满足所有 4 个条件来演示死锁

现在，我想解释一下代码。

在上面的代码中，在第 2 行，文件“test.txt”被加锁。因为锁是在调用 fork()系统调用之前放置的，所以文件上的锁由父进程持有。在第 4 行中，调用了 fork()系统调用，这将导致创建一个新的子进程，复制 fork()系统调用之后的所有代码语句。在第 7 行，子进程试图锁定同一个文件，这个文件已经被第 2 行的父进程锁定了。因为文件已经被锁定，所以子进程必须等待父进程释放锁来获取锁。在第 12 行，父进程使用 wait()系统调用等待子进程结束。

现在，让我们看看上面的代码是如何满足死锁的 4 个必要条件的。

由于文件在任何时候只能由一个进程持有，因此文件上的锁满足**互斥**的条件。在第 2 行，父进程获得文件的锁，并等待第 12 行的子进程结束。这导致了**‘保持并等待**状态。第 7 行，子进程不能让父进程释放文件上的锁，这符合**‘不抢占’**的条件。此外，由于子进程正在等待父进程释放锁，而父进程又在等待子进程，这满足了'**循环等待'**'的条件。

我总是习惯于忘记死锁条件，但是通过使用上面的代码，我对死锁的理解不仅提高了，而且我导出了死锁的必要条件，而不是记住它们。我希望阅读这篇文章的每个人都会发现它很有用，并且现在能够使用上面的简单代码推导出死锁的必要条件。我希望你喜欢这篇文章，如果有任何更改/澄清，请留言，我将很乐意更新/澄清。感谢阅读。

进一步阅读:[维贾伊·穆希的“C”奥德赛](https://www.goodreads.com/book/show/2523069.The_C_Odyssey)