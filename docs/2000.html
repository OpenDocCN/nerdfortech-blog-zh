<html>
<head>
<title>Swift Leetcode Series :Remove All Adjacent Duplicates in String II</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Swift Leetcode系列:删除字符串II中所有相邻的重复项</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/swift-leetcode-series-remove-all-adjacent-duplicates-in-string-ii-ef696ef909e4?source=collection_archive---------9-----------------------#2021-04-16">https://medium.com/nerd-for-tech/swift-leetcode-series-remove-all-adjacent-duplicates-in-string-ii-ef696ef909e4?source=collection_archive---------9-----------------------#2021-04-16</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="b33a" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">了解堆栈如何用于复制</h2></div><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ix"><img src="../Images/b45aa049f34b29f7a745cbe5e0c2d615.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WszKVUzYlxKN0-V9SNTsbQ.png"/></div></div></figure><div class="jj jk ez fb jl jm"><a href="https://theswiftnerd.com/remove-all-adjacent-duplicates-in-string-ii-leetcode-1209/" rel="noopener  ugc nofollow" target="_blank"><div class="jn ab dw"><div class="jo ab jp cl cj jq"><h2 class="bd hj fi z dy jr ea eb js ed ef hh bi translated">删除字符串II中所有相邻的重复项(Leetcode 1209)</h2><div class="jt l"><h3 class="bd b fi z dy jr ea eb js ed ef dx translated">难度:链接:April Leetcoding挑战:第16天给定一个字符串s，一个k去重包括选择k…</h3></div><div class="ju l"><p class="bd b fp z dy jr ea eb js ed ef dx translated">theswiftnerd.com</p></div></div><div class="jv l"><div class="jw l jx jy jz jv ka jh jm"/></div></div></a></div><p id="f5bc" class="pw-post-body-paragraph kb kc hi kd b ke kf ij kg kh ki im kj kk kl km kn ko kp kq kr ks kt ku kv kw hb bi translated">你也可以通过上面的链接在Swift Nerd博客上阅读完整的故事。</p><h1 id="3a4f" class="kx ky hi bd kz la lb lc ld le lf lg lh io li ip lj ir lk is ll iu lm iv ln lo bi translated">问题</h1><p id="f8ae" class="pw-post-body-paragraph kb kc hi kd b ke lp ij kg kh lq im kj kk lr km kn ko ls kq kr ks lt ku kv kw hb bi translated">给定一个字符串<code class="du lu lv lw lx b">s</code>，一个<em class="ly"> k </em> <em class="ly">重复删除</em>包括从<code class="du lu lv lw lx b">s</code>中选择<code class="du lu lv lw lx b">k</code>个相邻且相等的字母，并删除它们，使得被删除的子字符串的左侧和右侧连接在一起。</p><p id="60e4" class="pw-post-body-paragraph kb kc hi kd b ke kf ij kg kh ki im kj kk kl km kn ko kp kq kr ks kt ku kv kw hb bi translated">我们在<code class="du lu lv lw lx b">s</code>上重复删除<code class="du lu lv lw lx b">k</code>，直到我们再也做不到。在所有这样的重复删除完成后，返回最后一个字符串。</p><p id="e213" class="pw-post-body-paragraph kb kc hi kd b ke kf ij kg kh ki im kj kk kl km kn ko kp kq kr ks kt ku kv kw hb bi translated">保证答案是唯一的。</p><h2 id="a2ca" class="lz ky hi bd kz ma mb mc ld md me mf lh kk mg mh lj ko mi mj ll ks mk ml ln mm bi translated">例子</h2><pre class="iy iz ja jb fd mn lx mo mp aw mq bi"><span id="e403" class="lz ky hi lx b fi mr ms l mt mu"><strong class="lx hj">Input:</strong> s = "abcd", k = 2<br/><strong class="lx hj">Output:</strong> "abcd"<br/><strong class="lx hj">Explanation: </strong>There's nothing to delete.</span><span id="48d3" class="lz ky hi lx b fi mv ms l mt mu"><strong class="lx hj">Input:</strong> s = "deeedbbcccbdaa", k = 3<br/><strong class="lx hj">Output:</strong> "aa"<br/><strong class="lx hj">Explanation: <br/></strong>First delete "eee" and "ccc", get "ddbbbdaa"<br/>Then delete "bbb", get "dddaa"<br/>Finally delete "ddd", get "aa"</span><span id="8a98" class="lz ky hi lx b fi mv ms l mt mu"><strong class="lx hj">Input:</strong> s = "pbbcggttciiippooaais", k = 2<br/><strong class="lx hj">Output:</strong> "ps"</span></pre><h2 id="fb45" class="lz ky hi bd kz ma mb mc ld md me mf lh kk mg mh lj ko mi mj ll ks mk ml ln mm bi translated">限制</h2><ul class=""><li id="b943" class="mw mx hi kd b ke lp kh lq kk my ko mz ks na kw nb nc nd ne bi translated"><code class="du lu lv lw lx b">1 &lt;= s.length &lt;= 10^5</code></li><li id="f06c" class="mw mx hi kd b ke nf kh ng kk nh ko ni ks nj kw nb nc nd ne bi translated"><code class="du lu lv lw lx b">2 &lt;= k &lt;= 10^4</code></li><li id="e0dc" class="mw mx hi kd b ke nf kh ng kk nh ko ni ks nj kw nb nc nd ne bi translated"><code class="du lu lv lw lx b">s</code>只包含小写英文字母。</li></ul><h1 id="fff9" class="kx ky hi bd kz la lb lc ld le lf lg lh io li ip lj ir lk is ll iu lm iv ln lo bi translated">解决办法</h1><p id="53ab" class="pw-post-body-paragraph kb kc hi kd b ke lp ij kg kh lq im kj kk lr km kn ko ls kq kr ks lt ku kv kw hb bi translated">该问题是删除字符串中所有相邻重复项问题的修改版本。这里的问题是重复移除与相邻的<strong class="kd hj">和与<strong class="kd hj">相等的</strong>的字符串元素(重点是这两个)。我们可以提出一种强力逻辑来重复检查长度为k的相等子串，并将其从串中移除。然而，时间复杂度将非常高。如果我们使用额外的空间，我们可以很容易地在O(N)中做到这一点。如果你知道一种无需额外空间和O(N)时间就能解决它的方法，请在下面评论:)。</strong></p><h2 id="930f" class="lz ky hi bd kz ma mb mc ld md me mf lh kk mg mh lj ko mi mj ll ks mk ml ln mm bi translated">堆</h2><p id="d671" class="pw-post-body-paragraph kb kc hi kd b ke lp ij kg kh lq im kj kk lr km kn ko ls kq kr ks lt ku kv kw hb bi translated">堆栈是检查最后遍历的元素并删除子串(如果子串的长度等于k)的完美工具。由于我们需要有一个字符和连续运行长度的映射，我们可以有一个类对，并在其中保存字母和计数的映射(或者也可以使用元组，但可读性较差)。这样，当字母数变为k时，就很容易删除子串。最后一步仍然是从堆栈中构造回字符串。因为堆栈可以有计数为O(N) 的重复元素</p><h2 id="0c12" class="lz ky hi bd kz ma mb mc ld md me mf lh kk mg mh lj ko mi mj ll ks mk ml ln mm bi translated">空间= <strong class="kd hj"> O(N) </strong></h2><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="nk nl l"/></div></figure><h1 id="8ab9" class="kx ky hi bd kz la lb lc ld le lf lg lh io li ip lj ir lk is ll iu lm iv ln lo bi translated">感谢您的阅读。如果你喜欢这篇文章，并发现它很有用，请分享并像野火一样传播它！</h1><p id="010b" class="pw-post-body-paragraph kb kc hi kd b ke lp ij kg kh lq im kj kk lr km kn ko ls kq kr ks lt ku kv kw hb bi translated">你可以在<a class="ae nt" href="https://theswiftnerd.com/" rel="noopener ugc nofollow" target="_blank">swift网站</a>|<a class="ae nt" href="https://www.linkedin.com/in/varunrathi28/" rel="noopener ugc nofollow" target="_blank">LinkedIn</a>|<a class="ae nt" href="https://github.com/varunrathi28" rel="noopener ugc nofollow" target="_blank">Github</a>上找到我</p><p id="4562" class="pw-post-body-paragraph kb kc hi kd b ke kf ij kg kh ki im kj kk kl km kn ko kp kq kr ks kt ku kv kw hb bi">Time = <strong class="kd hj">O(N)</strong></p><p id="d4bc" class="pw-post-body-paragraph kb kc hi kd b ke kf ij kg kh ki im kj kk kl km kn ko kp kq kr ks kt ku kv kw hb bi">Space = <strong class="kd hj">O(N)</strong></p></div><div class="ab cl nm nn gp no" role="separator"><span class="np bw bk nq nr ns"/><span class="np bw bk nq nr ns"/><span class="np bw bk nq nr"/></div><div class="hb hc hd he hf"><p id="c642" class="pw-post-body-paragraph kb kc hi kd b ke kf ij kg kh ki im kj kk kl km kn ko kp kq kr ks kt ku kv kw hb bi">Thank you for reading. If you liked this article and found it useful, share and spread it like wildfire!</p><p id="961b" class="pw-post-body-paragraph kb kc hi kd b ke kf ij kg kh ki im kj kk kl km kn ko kp kq kr ks kt ku kv kw hb bi">You can find me on <a class="ae nt" href="https://theswiftnerd.com/" rel="noopener ugc nofollow" target="_blank">TheSwiftNerd</a> | <a class="ae nt" href="https://www.linkedin.com/in/varunrathi28/" rel="noopener ugc nofollow" target="_blank">LinkedIn</a> | <a class="ae nt" href="https://github.com/varunrathi28" rel="noopener ugc nofollow" target="_blank">Github</a></p></div></div>    
</body>
</html>