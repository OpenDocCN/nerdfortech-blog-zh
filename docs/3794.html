<html>
<head>
<title>[Learn Intermediate Go] Go Modules</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">[学习中级围棋]围棋模块</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/learn-intermediate-go-go-modules-c2f88f176fa6?source=collection_archive---------7-----------------------#2021-06-24">https://medium.com/nerd-for-tech/learn-intermediate-go-go-modules-c2f88f176fa6?source=collection_archive---------7-----------------------#2021-06-24</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="5f86" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">像其他语言一样，Go 的依赖管理也随着时间的推移而发展。但是自从 v1.11 中引入了<strong class="ih hj"> Go 模块</strong>之后，社区很快将其作为主要的依赖管理系统。</p><p id="bf29" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果您相对来说是新手，您可能已经使用了一些模块，但对它们的实际工作方式还存在一些差距。我会尽我所能来填补这些空白。</p><p id="9b09" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">一般来说，Go 模块跟踪名为<code class="du jd je jf jg b">go.mod</code>和<code class="du jd je jf jg b">go.sum</code>的文件中的依赖关系。<code class="du jd je jf jg b">go.sum</code>是自动生成的，并从<code class="du jd je jf jg b">go.mod</code>派生而来，所以您通常不需要直接对该文件做任何事情。如果你熟悉 Node.js，<code class="du jd je jf jg b">go.mod</code>堪比<code class="du jd je jf jg b">package.json</code>，<code class="du jd je jf jg b">go.sum</code>堪比<code class="du jd je jf jg b">package-lock.json</code>。</p><h1 id="30fb" class="jh ji hi bd jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke bi translated">创建模块</h1><p id="f65d" class="pw-post-body-paragraph if ig hi ih b ii kf ik il im kg io ip iq kh is it iu ki iw ix iy kj ja jb jc hb bi translated">为了有一个我们想玩的例子，让我们从创建一个模块开始。要创建一个模块，您可以使用<code class="du jd je jf jg b">go mod init</code>:</p><figure class="kl km kn ko fd kp er es paragraph-image"><div role="button" tabindex="0" class="kq kr di ks bf kt"><div class="er es kk"><img src="../Images/dc4e72cbf0bcde4f14c63f4273b25890.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gBiPhKmD1updOqmEEBVOwQ.png"/></div></div></figure><p id="3de2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们暂停一下，理解一下这到底是干什么的。</p><p id="44cb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">part 应该是不言自明的——它将当前目录初始化为 Go 模块目录。事实上，它所做的只是在当前目录中创建一个名为<code class="du jd je jf jg b">go.mod</code>的文件，其内容如下:</p><pre class="kl km kn ko fd kw jg kx ky aw kz bi"><span id="ded1" class="la ji hi jg b fi lb lc l ld le">module github.com/sanggonlee/learn_intermediate_go/01_modules</span><span id="53ca" class="la ji hi jg b fi lf lc l ld le">go 1.15</span></pre><p id="792b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">也就是你的模块名和 Go 版本。</p><p id="82b3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在我们来看后面的部分:<code class="du jd je jf jg b"><a class="ae lg" href="http://github.com/sanggonlee/learn_intermediate_go/01_modules" rel="noopener ugc nofollow" target="_blank">github.com/sanggonlee/learn_intermediate_go/01_modules</a></code></p><p id="2812" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">您最初的猜测可能是它是一个路径或 URL。答案是肯定的，也是否定的。</p><ul class=""><li id="9555" class="lh li hi ih b ii ij im in iq lj iu lk iy ll jc lm ln lo lp bi translated">不，因为它只是模块的名字。你想叫它什么都可以。并且</li><li id="24d1" class="lh li hi ih b ii lq im lr iq ls iu lt iy lu jc lm ln lo lp bi translated">是的，你应该总是把它命名为你上传代码的存储库路径。这是因为当其他 Go 项目需要导入你的模块时，他们会用这个名字来查找你的模块。</li></ul><h1 id="7a90" class="jh ji hi bd jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke bi translated">添加依赖关系</h1><p id="956f" class="pw-post-body-paragraph if ig hi ih b ii kf ik il im kg io ip iq kh is it iu ki iw ix iy kj ja jb jc hb bi translated">要安装特定的依赖项，请使用<code class="du jd je jf jg b">go get</code>:</p><figure class="kl km kn ko fd kp er es paragraph-image"><div role="button" tabindex="0" class="kq kr di ks bf kt"><div class="er es kk"><img src="../Images/a7526023f3db6d06b58cb2baaa1db8cd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*x3a_XqImN4Gb0g3eSgxbVQ.jpeg"/></div></div></figure><p id="7b79" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">对于版本查询，除了五个选项之外，还有特殊的字符串:<code class="du jd je jf jg b">latest</code>、<code class="du jd je jf jg b">upgrade</code>、<code class="du jd je jf jg b">patch</code>和<code class="du jd je jf jg b">none</code>。</p><p id="5920" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><code class="du jd je jf jg b">none</code>的特别之处在于，运行它将消除依赖性。</p><h1 id="b8c4" class="jh ji hi bd jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke bi translated">当有什么不对劲的时候</h1><p id="7aff" class="pw-post-body-paragraph if ig hi ih b ii kf ik il im kg io ip iq kh is it iu ki iw ix iy kj ja jb jc hb bi translated"><code class="du jd je jf jg b">go mod tidy</code>命令是你的朋友。它修复了<code class="du jd je jf jg b">go.mod</code>和<code class="du jd je jf jg b">go.sum</code>文件中的大部分不一致，并以规范的形式更新它们。</p><p id="d642" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">一个常见的场景是您修改了<code class="du jd je jf jg b">go.mod</code>文件(可能是因为您添加了一个新的依赖项),您的队友也修改了它，因此您处于必须解决合并冲突的情况。只需解决<code class="du jd je jf jg b">go.mod</code>文件中的冲突，删除<code class="du jd je jf jg b">go.sum</code>文件，运行<code class="du jd je jf jg b">go mod tidy</code>。</p><h1 id="32f4" class="jh ji hi bd jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke bi translated">仔细查看 go.mod 文件</h1><p id="7bf8" class="pw-post-body-paragraph if ig hi ih b ii kf ik il im kg io ip iq kh is it iu ki iw ix iy kj ja jb jc hb bi translated">现在让我们看看<code class="du jd je jf jg b">go.mod</code>文件的内部。在<code class="du jd je jf jg b">go.mod</code>文件中实际上只有 5 条指令可以使用，所以非常简单！</p><figure class="kl km kn ko fd kp er es paragraph-image"><div role="button" tabindex="0" class="kq kr di ks bf kt"><div class="er es kk"><img src="../Images/050321da73d1531208dd69ec09591cd4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PdBrBRjyzOc0NxFnVbH8XQ.png"/></div></div></figure><p id="ac02" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">注:<code class="du jd je jf jg b">retract</code>是 Go 1.16 中引入的新特性。</p><h1 id="336f" class="jh ji hi bd jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke bi translated">最小版本选择(MVS)</h1><p id="6ccd" class="pw-post-body-paragraph if ig hi ih b ii kf ik il im kg io ip iq kh is it iu ki iw ix iy kj ja jb jc hb bi translated">依赖关系树很容易理解，但是当考虑到依赖关系的所有版本时就不那么简单了。</p><p id="0e83" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Go 使用最小版本选择(MVS)来准确选择要使用的依赖版本。</p><p id="b383" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">首先，递归地找到模块导入的所有依赖项(即那些依赖项的依赖项，以及它们的依赖项，等等)。</p><p id="6cd8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">然后使用每个依赖关系的最新版本来构建最终的图。</p><figure class="kl km kn ko fd kp er es paragraph-image"><div role="button" tabindex="0" class="kq kr di ks bf kt"><div class="er es lv"><img src="../Images/6c0b186f670207b9ea682598f94ffda5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1300/format:webp/1*OHF4zxEG13YCASRTzPNMDg.png"/></div></div></figure><p id="3b37" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在上面的例子中，你的模块导入了依赖项 A v1.2 和 B v2.1。但是 B v2.1 导入了 v1.3，而 A v1.3 导入了 C v3.4。所以即使你的模块导入了 v1.2 和 B v2.1，在最终的构建列表中也会用到它们(用蓝色突出显示):</p><ul class=""><li id="1963" class="lh li hi ih b ii ij im in iq lj iu lk iy ll jc lm ln lo lp bi translated">1.3 版</li><li id="7fd8" class="lh li hi ih b ii lq im lr iq ls iu lt iy lu jc lm ln lo lp bi translated">B v2.1</li><li id="92de" class="lh li hi ih b ii lq im lr iq ls iu lt iy lu jc lm ln lo lp bi translated">C v3.4</li></ul><h1 id="3005" class="jh ji hi bd jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke bi translated">Vendoring</h1><p id="764e" class="pw-post-body-paragraph if ig hi ih b ii kf ik il im kg io ip iq kh is it iu ki iw ix iy kj ja jb jc hb bi translated">Vendoring 基本上是将所有依赖项的源代码下载到您的(或任何构建环境的)文件系统中。类似于<code class="du jd je jf jg b">node_modules</code>在 Node.js 中的工作方式。</p><p id="7b9d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">默认情况下，禁用销售，并将依赖项下载到模块缓存中。您可能希望在以下情况下使用 vendoring:</p><ul class=""><li id="7516" class="lh li hi ih b ii ij im in iq lj iu lk iy ll jc lm ln lo lp bi translated">为了与旧版本的 Go 进行互操作(记住 Go 模块只是在 v1.11 中引入的！)</li><li id="6638" class="lh li hi ih b ii lq im lr iq ls iu lt iy lu jc lm ln lo lp bi translated">您的模块导入私有项目，并且您不想将您的 git 凭证注入到构建环境中(例如 CI/CD)</li><li id="21e9" class="lh li hi ih b ii lq im lr iq ls iu lt iy lu jc lm ln lo lp bi translated">如果你觉得那样更可靠(因为在早期阶段你已经拥有了你需要的一切，所以<em class="lw">会不会更可靠)</em></li></ul><p id="7fdd" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为了厂商，运行<code class="du jd je jf jg b">go mod vendor</code>命令，这将创建一个<code class="du jd je jf jg b">vendor</code>目录，并将所有的依赖源代码放在那里。</p><p id="26c3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">您的模块将使用<code class="du jd je jf jg b">vendor</code>目录中的代码，所以每当<code class="du jd je jf jg b">go.mod</code>文件改变时，您应该运行<code class="du jd je jf jg b">go mod vendor</code>来同步供应商和 Go 模块。</p><h1 id="c6e2" class="jh ji hi bd jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke bi translated">结束语</h1><p id="cacc" class="pw-post-body-paragraph if ig hi ih b ii kf ik il im kg io ip iq kh is it iu ki iw ix iy kj ja jb jc hb bi translated">我希望那有帮助。感谢您的阅读！(哦对了，你知道你可以对一篇中等的文章多次鼓掌吗？😄)</p><h1 id="e02d" class="jh ji hi bd jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke bi translated">LIG 系列是什么？</h1><p id="8440" class="pw-post-body-paragraph if ig hi ih b ii kf ik il im kg io ip iq kh is it iu ki iw ix iy kj ja jb jc hb bi translated"><em class="lw"> Learn 中级围棋系列旨在帮助你填补基础围棋教程之外的一些知识空白。它旨在包含从通常让你沮丧的事情中提取的精华，或者在基础教程之后的第一个项目中你错过了什么。目标受众:</em></p><ul class=""><li id="7ab0" class="lh li hi ih b ii ij im in iq lj iu lk iy ll jc lm ln lo lp bi translated"><em class="lw">你有学习另一种语言的经验，但是刚开始学，或者</em></li><li id="2efb" class="lh li hi ih b ii lq im lr iq ls iu lt iy lu jc lm ln lo lp bi translated"><em class="lw">你刚刚完成了一个基础教程(例如围棋之旅)，但不确定如何获得进一步的知识，或者</em></li><li id="abb2" class="lh li hi ih b ii lq im lr iq ls iu lt iy lu jc lm ln lo lp bi translated"><em class="lw">你已经写了几个月的围棋了，但是你想填补一些知识上的空白</em></li></ul><p id="f3db" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">目录(它们不是按顺序排列的——你可以按你想要的任何顺序阅读！):</p><ol class=""><li id="35a4" class="lh li hi ih b ii ij im in iq lj iu lk iy ll jc lx ln lo lp bi translated"><a class="ae lg" href="https://sanggon.medium.com/learn-intermediate-go-go-modules-c2f88f176fa6" rel="noopener"> <em class="lw"> Go 模块</em> </a></li><li id="e04b" class="lh li hi ih b ii lq im lr iq ls iu lt iy lu jc lx ln lo lp bi translated"><a class="ae lg" href="https://sanggon.medium.com/learn-intermediate-go-how-does-context-work-1898704c649b" rel="noopener"> <em class="lw">语境是如何工作的？</em> </a></li></ol></div></div>    
</body>
</html>