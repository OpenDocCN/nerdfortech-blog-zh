<html>
<head>
<title>Execution Context and Call Stack in JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript 中的执行上下文和调用堆栈</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/how-javascript-works-3b5e4054dc2d?source=collection_archive---------3-----------------------#2020-12-21">https://medium.com/nerd-for-tech/how-javascript-works-3b5e4054dc2d?source=collection_archive---------3-----------------------#2020-12-21</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div class="er es if"><img src="../Images/391ed3f35e59d7eeab7f7c25ddff6146.png" data-original-src="https://miro.medium.com/v2/resize:fit:1336/format:webp/1*tvZPQDekZU3eU13f2B7Jdg.jpeg"/></div></figure><p id="221c" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">听说过 JavaScript 但是，不知道基础知识？不知道幕后发生了什么？破解采访有困难吗？别担心。这篇文章将帮助你了解 JavaScript 的基本概念。这些概念在你的日常活动中可能会用到，也可能不会，但是如果你很好奇，想要深入 JavaScript 的世界，那么我确信你会发现这些东西真的很有趣。这篇文章将涉及 JS 最基本的主题之一——执行上下文。所以，事不宜迟，让我们开始吧。</p></div><div class="ab cl jk jl gp jm" role="separator"><span class="jn bw bk jo jp jq"/><span class="jn bw bk jo jp jq"/><span class="jn bw bk jo jp"/></div><div class="hb hc hd he hf"><h1 id="88cf" class="jr js hi bd jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko bi translated"><strong class="ak">您听说过“执行上下文”吗？</strong></h1><p id="6f3e" class="pw-post-body-paragraph im in hi io b ip kp ir is it kq iv iw ix kr iz ja jb ks jd je jf kt jh ji jj hb bi translated"><strong class="io hj">执行上下文</strong>是 JS 中最基本的概念之一。让我这么说吧。</p><blockquote class="ku"><p id="cfec" class="kv kw hi bd kx ky kz la lb lc ld jj dx translated"><strong class="ak">JS 中的一切都发生在执行上下文中。</strong></p></blockquote><p id="bc4a" class="pw-post-body-paragraph im in hi io b ip le ir is it lf iv iw ix lg iz ja jb lh jd je jf li jh ji jj hb bi translated">让我们借助一个例子来理解这一点。下面显示的代码寻找给定数字的平方。</p><figure class="lk ll lm ln fd ij er es paragraph-image"><div class="er es lj"><img src="../Images/09e3915d8bd153b9a654c93b8601a6f7.png" data-original-src="https://miro.medium.com/v2/resize:fit:672/format:webp/1*-AWlgmkliBShb1Ta1iTLQg.png"/></div><figcaption class="lo lp et er es lq lr bd b be z dx translated">一个简单的 JS 程序来理解执行上下文是如何工作的。</figcaption></figure><p id="6560" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">当我们运行一个 JS 程序时，一个<strong class="io hj">执行上下文</strong>被创建。这个过程包括两个阶段。第一阶段称为<strong class="io hj">内存创建</strong>阶段，第二阶段称为<strong class="io hj">代码执行</strong>阶段。</p><figure class="lk ll lm ln fd ij er es paragraph-image"><div role="button" tabindex="0" class="lt lu di lv bf lw"><div class="er es ls"><img src="../Images/04965476c6b783a31331427c7864ce2a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fPwQh310xA5lZ0zGq_nzuA.png"/></div></div><figcaption class="lo lp et er es lq lr bd b be z dx translated"><strong class="bd jt"> <em class="lx">存储器创建</em> </strong>阶段的表示</figcaption></figure><p id="ea1d" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">在<strong class="io hj">内存创建</strong>阶段，JS 解析程序，寻找变量和函数定义。在变量的情况下，会分配一个名为<strong class="io hj"> <em class="ly"> undefined </em> </strong>的特殊关键字，在函数的情况下，JS 会存储整个函数定义的副本。(查看图表)。</p><blockquote class="lz ma mb"><p id="9e32" class="im in ly io b ip iq ir is it iu iv iw mc iy iz ja md jc jd je me jg jh ji jj hb bi translated">注意:<strong class="io hj"> <em class="hi">未定义</em> </strong>不是数值。它是 JS 中使用的一个特殊的关键字，表示变量没有被定义或赋值。</p></blockquote><p id="0247" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">第二阶段是<strong class="io hj">代码执行</strong>阶段。在此阶段，JS 从头开始，并以<em class="ly">同步</em>的方式进行(一次一行)。</p><blockquote class="lz ma mb"><p id="6069" class="im in ly io b ip iq ir is it iu iv iw mc iy iz ja md jc jd je me jg jh ji jj hb bi translated">注意:这可能是你的第一个面试问题。<strong class="io hj">JavaScript 是同步语言还是异步语言</strong>’。我想你现在知道答案了。</p></blockquote><figure class="lk ll lm ln fd ij er es paragraph-image"><div class="er es lj"><img src="../Images/09e3915d8bd153b9a654c93b8601a6f7.png" data-original-src="https://miro.medium.com/v2/resize:fit:672/format:webp/1*-AWlgmkliBShb1Ta1iTLQg.png"/></div><figcaption class="lo lp et er es lq lr bd b be z dx translated">一个简单的 JS 程序来理解执行上下文是如何工作的。</figcaption></figure><p id="9d31" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">在第 1 行，“n”的值设置为 10，因此 JS 删除了关键字<em class="ly">未定义的</em>，并将值设置为 10 <em class="ly">。</em>现在控制转到下一个代码块。因为这是一个函数定义，这里没有代码执行，所以 JS 跳过函数定义，将控制权转移到第 8 行。JS 一遇到函数调用[<strong class="io hj"><em class="ly">square(5)</em></strong>]，就创建一个新的执行上下文，如下所示。</p><figure class="lk ll lm ln fd ij er es paragraph-image"><div role="button" tabindex="0" class="lt lu di lv bf lw"><div class="er es mf"><img src="../Images/f92b0b4c0ab6b3db2c94b172f4c48b75.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jTPEiz5psw0L-wgyHcvjmg.png"/></div></div><figcaption class="lo lp et er es lq lr bd b be z dx translated">函数调用创建了一个<strong class="bd jt">新的执行上下文</strong></figcaption></figure><p id="e35f" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">现在，执行上下文的整个过程针对该函数调用重复进行。让我们看看功能块是如何执行的。</p><figure class="lk ll lm ln fd ij er es paragraph-image"><div class="er es mg"><img src="../Images/bfb62e200f43ba7cecdea12b4c72427b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1144/format:webp/1*7myZA5GlEbT7Nwquu-SyWQ.png"/></div></figure><p id="a821" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">在内存创建阶段，我们会有两个变量，‘<em class="ly">number’</em>是你的函数参数，‘<em class="ly">ans</em>是局部变量。两者都将值设置为“<em class="ly">未定义</em>”。在这个当前执行上下文的第二阶段，JS 从这个函数声明的第一行开始。因为我们在函数调用中将 5 作为参数传递，所以 5 被指定为变量 number 的值。现在控制转到下一行。</p><figure class="lk ll lm ln fd ij er es paragraph-image"><div role="button" tabindex="0" class="lt lu di lv bf lw"><div class="er es mh"><img src="../Images/807a62785e006aff08c2e12c9212cab1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cWOBkKSroBmRZkuNc0qOJQ.png"/></div></div><figcaption class="lo lp et er es lq lr bd b be z dx translated">为 square(5)函数调用创建的执行上下文</figcaption></figure><p id="849e" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">在下一行，JS 执行[<strong class="io hj"><em class="ly">number * number</em></strong><em class="ly"/>]行的一部分，这个操作的结果(也就是 25)存储在变量‘ans’中。现在下一行有一个关键字‘return’。一旦 JS 遇到<em class="ly">‘return’关键字，</em>它就将控制移回父执行上下文。因为我们要返回“ans”的值，所以返回值 25 并存储在变量“squareOf5”中。现在记住这个。</p><p id="f65a" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><strong class="io hj">当控制移回到进行函数调用的地方时，新创建的执行上下文被删除。</strong></p><p id="7d02" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">看看下面的图表。</p><figure class="lk ll lm ln fd ij er es paragraph-image"><div role="button" tabindex="0" class="lt lu di lv bf lw"><div class="er es mi"><img src="../Images/d8f1770453515fbd9f85baa11879c762.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*R2H5YrecwHWjt8b4_lttSA.png"/></div></div><figcaption class="lo lp et er es lq lr bd b be z dx translated">函数调用中到底发生了什么的表示</figcaption></figure><p id="52f8" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">现在，控制转到下一行，这又是一个函数调用，执行上下文的整个过程再次重复。</p></div><div class="ab cl jk jl gp jm" role="separator"><span class="jn bw bk jo jp jq"/><span class="jn bw bk jo jp jq"/><span class="jn bw bk jo jp"/></div><div class="hb hc hd he hf"><h1 id="bb4d" class="jr js hi bd jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko bi translated"><strong class="ak">JS 如何跟踪这些执行上下文？</strong></h1><p id="c339" class="pw-post-body-paragraph im in hi io b ip kp ir is it kq iv iw ix kr iz ja jb ks jd je jf kt jh ji jj hb bi translated">这是通过所谓的<strong class="io hj">调用堆栈</strong>或<strong class="io hj">执行堆栈</strong>来实现的。它像一个普通的堆栈，但主要用于跟踪执行上下文。</p><figure class="lk ll lm ln fd ij er es paragraph-image"><div class="er es mj"><img src="../Images/b670ff2d86538b9be847b0df93354e80.png" data-original-src="https://miro.medium.com/v2/resize:fit:430/format:webp/1*cV3YCfFAGOQmftVoU8VW5Q.png"/></div></figure><p id="dcc0" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">当 JS 引擎第一次遇到脚本时，它会创建一个<strong class="io hj">全局执行上下文(GEC) </strong>并被推送到调用堆栈上。在 GEC 的代码执行部分，每当 JS engine 遇到函数调用时，它都会创建一个新的执行上下文，并将其推送到调用堆栈。</p><p id="1946" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">引擎执行其执行上下文位于堆栈顶部的函数。当这个函数完成时，它的执行栈从栈中弹出，这个过程继续到脚本的剩余部分。</p></div><div class="ab cl jk jl gp jm" role="separator"><span class="jn bw bk jo jp jq"/><span class="jn bw bk jo jp jq"/><span class="jn bw bk jo jp"/></div><div class="hb hc hd he hf"><p id="45f3" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><strong class="io hj">最终想法</strong></p><p id="be5a" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">我希望现在您已经很好地理解了执行上下文。如果非要用简单的语言来解释执行上下文的重要性，我可以说<strong class="io hj"> <em class="ly">执行上下文是 JS </em> </strong>的心脏。</p><p id="06a1" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">让我也提一下，我没有讲太多，但是有很多概念可以涵盖。</p><p id="f33a" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">感谢您阅读这篇文章。请在评论区告诉我你的想法。</p></div><div class="ab cl jk jl gp jm" role="separator"><span class="jn bw bk jo jp jq"/><span class="jn bw bk jo jp jq"/><span class="jn bw bk jo jp"/></div><div class="hb hc hd he hf"><p id="720e" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><strong class="io hj"> <em class="ly">参考文献:</em> </strong></p><ol class=""><li id="432b" class="mk ml hi io b ip iq it iu ix mm jb mn jf mo jj mp mq mr ms bi translated">JavaScript 代码是如何执行的？&amp; https://www.youtube.com/watch?v=iLWTnMzWtj4·阿克谢·塞尼的呼叫堆栈<a class="ae mt" href="https://www.youtube.com/watch?v=iLWTnMzWtj4" rel="noopener ugc nofollow" target="_blank"/></li><li id="7390" class="mk ml hi io b ip mu it mv ix mw jb mx jf my jj mp mq mr ms bi translated"><a class="ae mt" rel="noopener" href="/@Sukhjinder?source=post_page-----1c9ea8642dd0--------------------------------">Sukhjinder Arora</a><br/>T5】的一篇文章 https://blog . bitsrc . io/understanding-execution-context-and-execution-stack-in-JavaScript-1c 9 ea 8642 DD 0</li></ol></div></div>    
</body>
</html>