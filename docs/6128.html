<html>
<head>
<title>LeetCode — House Robber</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">leet code——入室抢劫犯</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/leetcode-house-robber-9ad635e6e58f?source=collection_archive---------1-----------------------#2022-01-02">https://medium.com/nerd-for-tech/leetcode-house-robber-9ad635e6e58f?source=collection_archive---------1-----------------------#2022-01-02</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><h1 id="6053" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">问题陈述</h1><p id="5af9" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">你是一个专业的强盗，计划沿街抢劫房屋。每栋房子都藏了一定数量的钱，阻止你抢劫每栋房子的唯一限制是相邻的房子都连接了安全系统，如果两栋相邻的房子在同一个晚上被闯入，它会自动联系警察。</p><p id="5d15" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">给定一个整数数组<em class="kg"> nums </em>代表每家的钱数，返回<em class="kg">你今晚可以抢劫的最大金额</em> <strong class="jf hj"> <em class="kg">而不惊动警察</em> </strong>。</p><p id="ade7" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated"><strong class="jf hj">例1: </strong></p><pre class="kh ki kj kk fd kl km kn ko aw kp bi"><span id="d960" class="kq ig hi km b fi kr ks l kt ku">Input: nums = [1, 2, 3, 1] <br/>Output: 4 <br/>Explanation: Rob house 1 (money = 1) and then rob house 3 (money = 3). Total amount you can rob = 1 + 3 = 4.</span></pre><p id="7704" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated"><strong class="jf hj">例2: </strong></p><pre class="kh ki kj kk fd kl km kn ko aw kp bi"><span id="cbaf" class="kq ig hi km b fi kr ks l kt ku">Input: nums = [2, 7, 9, 3, 1] <br/>Output: 12 <br/>Explanation: Rob house 1 (money = 2), rob house 3 (money = 9) and rob house 5 (money = 1). Total amount you can rob = 2 + 9 + 1 = 12.</span></pre><p id="04cf" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated"><strong class="jf hj">约束:</strong></p><pre class="kh ki kj kk fd kl km kn ko aw kp bi"><span id="1fe1" class="kq ig hi km b fi kr ks l kt ku">- 1 &lt;= nums.length &lt;= 100 <br/>- &lt;= nums[i] &lt;= 400</span></pre><h1 id="122c" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">说明</h1><h2 id="4696" class="kq ig hi bd ih kv kw kx il ky kz la ip jo lb lc it js ld le ix jw lf lg jb lh bi translated">动态规划</h2><p id="c943" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">我们可以把这个问题简化为寻找没有两个选定元素相邻的最大和子序列。解决这个问题的方法是使用动态规划。所以有两种情况。</p><ol class=""><li id="bd0d" class="li lj hi jf b jg kb jk kc jo lk js ll jw lm ka ln lo lp lq bi translated">如果选择了该元素，则无法选择下一个相邻元素。</li><li id="f7f7" class="li lj hi jf b jg lr jk ls jo lt js lu jw lv ka ln lo lp lq bi translated">如果没有选择一个元素，那么可以选择下一个元素。</li></ol><p id="5491" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">上述方法的一个C++片段如下:</p><pre class="kh ki kj kk fd kl km kn ko aw kp bi"><span id="b9bd" class="kq ig hi km b fi kr ks l kt ku">int rob(vector&lt;int&gt;&amp; nums ){<br/>    int n = nums.size();<br/><br/>    if (n == 0)<br/>        return 0;<br/>    if (n == 1)<br/>        return nums[0];<br/>    if (n == 2)<br/>        return max(nums[0], nums[1]);<br/><br/>    int dp[n];<br/><br/>    dp[0] = nums[0];<br/>    dp[1] = max(nums[0], nums[1]);<br/><br/>    for (int i = 2; i&lt;n; i++)<br/>        dp[i] = max(nums[i]+dp[i-2], dp[i-1]);<br/><br/>    return dp[n-1];<br/>}</span></pre><p id="d62e" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">上述方法的时间和空间复杂度为<strong class="jf hj"> O(N) </strong>。</p><h2 id="4dd9" class="kq ig hi bd ih kv kw kx il ky kz la ip jo lb lc it js ld le ix jw lf lg jb lh bi translated">有效的方法:使用两个变量</h2><p id="6d7a" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">如果我们仔细观察动态编程方法，我们会发现在计算一个指数的值时，前面两个指数的值很重要。我们可以用两个变量代替DP数组。</p><p id="7df4" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">我们先检查一下算法。</p><pre class="kh ki kj kk fd kl km kn ko aw kp bi"><span id="765e" class="kq ig hi km b fi kr ks l kt ku">- set evenSum, oddSum = 0, 0<br/><br/>- loop for i = 0; i &lt; nums.size(); i++<br/>  - if i % 2 == 0 // even index<br/>    - evenSum += nums[i]<br/>    - evenSum = evenSum &gt; oddSum ? evenSum : oddSum<br/>  - else<br/>    - oddSum += nums[i]<br/>    - oddSum = evenSum &gt; oddSum ? evenSum : oddSum<br/><br/>- return evenSum &gt; oddSum ? evenSum: oddSum</span></pre><p id="ec6f" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">上述方法的时间复杂度为<strong class="jf hj"> O(N) </strong>而空间复杂度则降为<strong class="jf hj"> O(1) </strong>。</p><h2 id="aa8d" class="kq ig hi bd ih kv kw kx il ky kz la ip jo lb lc it js ld le ix jw lf lg jb lh bi translated">C++解决方案</h2><pre class="kh ki kj kk fd kl km kn ko aw kp bi"><span id="68d2" class="kq ig hi km b fi kr ks l kt ku">class Solution {<br/>public:<br/>    int rob(vector&lt;int&gt;&amp; nums) {<br/>        int evenSum = 0, oddSum = 0;<br/><br/>        for(int i = 0; i &lt; nums.size(); i++){<br/>            if(i % 2 == 0){<br/>                evenSum += nums[i];<br/>                evenSum = evenSum &gt; oddSum ? evenSum : oddSum;<br/>            } else {<br/>                oddSum += nums[i];<br/>                oddSum = evenSum &gt; oddSum ? evenSum : oddSum;<br/>            }<br/>        }<br/><br/>        return evenSum &gt; oddSum ? evenSum: oddSum;<br/>    }<br/>};</span></pre><h2 id="3c37" class="kq ig hi bd ih kv kw kx il ky kz la ip jo lb lc it js ld le ix jw lf lg jb lh bi translated">戈朗溶液</h2><pre class="kh ki kj kk fd kl km kn ko aw kp bi"><span id="14d2" class="kq ig hi km b fi kr ks l kt ku">func rob(nums []int) int {<br/>    evenSum, oddSum := 0, 0<br/><br/>    for i := 0; i &lt; len(nums); i++ {<br/>        if i % 2 == 0 {<br/>            evenSum += nums[i]<br/><br/>            if evenSum &lt; oddSum {<br/>                evenSum = oddSum<br/>            }<br/>        } else {<br/>            oddSum += nums[i]<br/><br/>            if oddSum &lt; evenSum {<br/>                oddSum = evenSum<br/>            }<br/>        }<br/>    }<br/><br/>    if evenSum &gt; oddSum {<br/>        return evenSum<br/>    }<br/><br/>    return oddSum<br/>}</span></pre><h2 id="c5e8" class="kq ig hi bd ih kv kw kx il ky kz la ip jo lb lc it js ld le ix jw lf lg jb lh bi translated">Javascript解决方案</h2><pre class="kh ki kj kk fd kl km kn ko aw kp bi"><span id="433a" class="kq ig hi km b fi kr ks l kt ku">var rob = function(nums) {<br/>    let evenSum = 0, oddSum = 0;<br/><br/>    for(let i = 0; i &lt; nums.length; i++) {<br/>        if( i % 2 == 0 ) {<br/>            evenSum += nums[i];<br/>            evenSum = evenSum &gt; oddSum ? evenSum : oddSum;<br/>        } else {<br/>            oddSum += nums[i];<br/>            oddSum = evenSum &gt; oddSum ? evenSum : oddSum;<br/>        }<br/>    }<br/><br/>    return evenSum &gt; oddSum ? evenSum : oddSum;<br/>};</span></pre><p id="68d9" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">让我们试运行一下我们的算法，看看解决方案是如何工作的。</p><pre class="kh ki kj kk fd kl km kn ko aw kp bi"><span id="9912" class="kq ig hi km b fi kr ks l kt ku">Input: nums = [2, 7, 9, 3, 1]<br/><br/>Step 1: evenSum = 0<br/>        oddSum = 0<br/><br/>Step 2: loop for i = 0; i &lt; nums.size()<br/>        0 &lt; 5<br/>        true<br/><br/>        i % 2 == 0<br/>        0 % 2 == 0<br/>        true<br/><br/>        evenSum = evenSum + nums[i]<br/>                = 0 + nums[0]<br/>                = 2<br/><br/>        evenSum = evenSum &gt; oddSum ? evenSum : oddSum<br/>                = 2 &gt; 0<br/>                = true<br/>                = 2<br/><br/>        i++<br/>        i = 1<br/><br/>Step 3: loop for i &lt; nums.size()<br/>        1 &lt; 5<br/>        true<br/><br/>        i % 2 == 0<br/>        1 % 2 == 0<br/>        false<br/><br/>        oddSum = oddSum + nums[i]<br/>                = 0 + nums[1]<br/>                = 7<br/><br/>        oddSum = evenSum &gt; oddSum ? evenSum : oddSum<br/>               = 2 &gt; 7<br/>               = false<br/>               = 7<br/><br/>        i++<br/>        i = 2<br/><br/>Step 4: loop for i &lt; nums.size()<br/>        2 &lt; 5<br/>        true<br/><br/>        i % 2 == 0<br/>        2 % 2 == 0<br/>        true<br/><br/>        evenSum = evenSum + nums[i]<br/>                = 2 + nums[2]<br/>                = 2 + 9<br/>                = 11<br/><br/>        evenSum = evenSum &gt; oddSum ? evenSum : oddSum<br/>                = 11 &gt; 7<br/>                = true<br/>                = 11<br/><br/>        i++<br/>        i = 3<br/><br/>Step 5: loop for i &lt; nums.size()<br/>        3 &lt; 5<br/>        true<br/><br/>        i % 2 == 0<br/>        3 % 2 == 0<br/>        false<br/><br/>        oddSum = oddSum + nums[i]<br/>                = 7 + nums[3]<br/>                = 7 + 3<br/>                = 10<br/><br/>        oddSum = evenSum &gt; oddSum ? evenSum : oddSum<br/>               = 11 &gt; 10<br/>               = true<br/>               = 11<br/><br/>        i++<br/>        i = 4<br/><br/>Step 6: loop for i &lt; nums.size()<br/>        4 &lt; 5<br/>        true<br/><br/>        i % 2 == 0<br/>        4 % 2 == 0<br/>        true<br/><br/>        evenSum = evenSum + nums[i]<br/>                = 11 + nums[4]<br/>                = 11 + 1<br/>                = 12<br/><br/>        evenSum = evenSum &gt; oddSum ? evenSum : oddSum<br/>                = 12 &gt; 11<br/>                = true<br/>                = 12<br/><br/>        i++<br/>        i = 5<br/><br/>Step 7: loop for i &lt; nums.size()<br/>        5 &lt; 5<br/>        false<br/><br/>Step 8: return evenSum &gt; oddSum ? evenSum : oddSum<br/>        12 &gt; 11<br/>        true<br/><br/>So we return the answer as 12.</span></pre></div><div class="ab cl lw lx gp ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="hb hc hd he hf"><p id="060f" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated"><em class="kg">原载于</em><a class="ae md" href="https://alkeshghorpade.me/post/leetcode-house-robber" rel="noopener ugc nofollow" target="_blank"><em class="kg">https://alkeshghorpade . me</em></a><em class="kg">。</em></p></div></div>    
</body>
</html>