<html>
<head>
<title>Build a Microservice App Using gRPC, Python, and Golang (Part 3)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用gRPC、Python和Golang构建微服务应用程序(第3部分)</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/build-a-microservice-app-using-grpc-python-and-golang-part-3-819388a16717?source=collection_archive---------12-----------------------#2021-04-05">https://medium.com/nerd-for-tech/build-a-microservice-app-using-grpc-python-and-golang-part-3-819388a16717?source=collection_archive---------12-----------------------#2021-04-05</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/11f3aa8c15b6453e31d68b1ace21e9cd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*ug3qSq8iM8MMzV8J"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated"><a class="ae iu" href="https://unsplash.com/@minkus?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">明库斯</a>在<a class="ae iu" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="8835" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在本文中，我们将继续构建我们的应用程序，并将重点放在todo CRUD操作上。因为实现与auth服务没有太大的不同，所以希望这篇文章会更短。让我们投入进去吧！</p></div><div class="ab cl jt ju gp jv" role="separator"><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy"/></div><div class="hb hc hd he hf"><h1 id="9f03" class="ka kb hi bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated">Todo服务</h1><p id="16aa" class="pw-post-body-paragraph iv iw hi ix b iy ky ja jb jc kz je jf jg la ji jj jk lb jm jn jo lc jq jr js hb bi translated">同样，对于auth服务，在继续编写原型文件之前，首先我们必须做一些设置。</p><p id="592f" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">创建一个名为grpc_todo的数据库和一个名为todo的表。您可以使用以下查询创建该表。</p><pre class="ld le lf lg fd lh li lj lk aw ll bi"><span id="e2b2" class="lm kb hi li b fi ln lo l lp lq">CREATE TABLE public.todos (</span><span id="5fbc" class="lm kb hi li b fi lr lo l lp lq">id serial NOT NULL,</span><span id="0107" class="lm kb hi li b fi lr lo l lp lq">title varchar(64) NOT NULL,</span><span id="585b" class="lm kb hi li b fi lr lo l lp lq">description varchar(256) NULL,</span><span id="3f3b" class="lm kb hi li b fi lr lo l lp lq">user_id int4 NULL,</span><span id="db1e" class="lm kb hi li b fi lr lo l lp lq">CONSTRAINT todos_pkey PRIMARY KEY (id)</span><span id="1971" class="lm kb hi li b fi lr lo l lp lq">);</span></pre><p id="4a8d" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">做些准备。现在数据库。</p><figure class="ld le lf lg fd ij"><div class="bz dy l di"><div class="ls lt l"/></div></figure><p id="16c6" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这些配置与auth服务非常相似，不同之处在于数据库的名称。它被命名为<code class="du lu lv lw li b">grpc_todo</code>而不是<code class="du lu lv lw li b">grpc_auth</code>。接下来，定义Todo的模型。</p><figure class="ld le lf lg fd ij"><div class="bz dy l di"><div class="ls lt l"/></div></figure><p id="2611" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">Todo模型有4个字段，ID、标题、描述和用户ID。此外，我们为每个字段定义了标记。继续，定义存储库(现在只有模板)。</p><figure class="ld le lf lg fd ij"><div class="bz dy l di"><div class="ls lt l"/></div></figure><p id="a1cc" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">上面的代码没什么特别的，因为它只是一个<code class="du lu lv lw li b">repository</code>文件的模板(咄！？).我们稍后将回来实现细节。现在，创建用例。</p><figure class="ld le lf lg fd ij"><div class="bz dy l di"><div class="ls lt l"/></div></figure><p id="af8f" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这仍然是常见的事情，我们在上一篇文章中已经这样做了。接下来，这是新的东西，定义todo原型文件。创建一个名为<code class="du lu lv lw li b">todo.proto</code>的文件，放在<code class="du lu lv lw li b">todo</code>工作目录(todo服务的根目录)下。</p><figure class="ld le lf lg fd ij"><div class="bz dy l di"><div class="ls lt l"/></div></figure><p id="d684" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">之后，使用这个命令生成gRPC代码，我们将在<code class="du lu lv lw li b">todo</code>文件夹中有两个go文件。</p><pre class="ld le lf lg fd lh li lj lk aw ll bi"><span id="936f" class="lm kb hi li b fi ln lo l lp lq">protoc --go_out=./todo --go_opt=paths=source_relative \</span><span id="dbc7" class="lm kb hi li b fi lr lo l lp lq">--go-grpc_out=./todo --go-grpc_opt=paths=source_relative \</span><span id="2325" class="lm kb hi li b fi lr lo l lp lq">./todo.proto</span></pre><p id="35ba" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">从上面的proto文件中，我们定义了四个过程，分别是<code class="du lu lv lw li b">CreateTodo</code>、<code class="du lu lv lw li b">GetTodos</code>、<code class="du lu lv lw li b">UpdateTodo</code>和<code class="du lu lv lw li b">DeleteTodo</code>；基本正常的CRUD操作。对于每个过程，我们还定义了它的<code class="du lu lv lw li b">Request</code>和<code class="du lu lv lw li b">Response</code>形式。例如，<code class="du lu lv lw li b">CreateTodoRequest</code>有<code class="du lu lv lw li b">userID</code>、<code class="du lu lv lw li b">title</code>、<code class="du lu lv lw li b">descriptions</code>字段。因此，当客户端想要远程调用过程时，他必须给出正确的请求形式，然后服务器将做出适当的响应(给我们<code class="du lu lv lw li b">CreateTodoResponse</code>)。</p><p id="80d5" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在这之后，让我们定义服务器部分。</p><figure class="ld le lf lg fd ij"><div class="bz dy l di"><div class="ls lt l"/></div></figure><p id="8f08" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们的todo服务器文件仍然是基本的，所以我们将稍后回来。最后是主文件。</p><figure class="ld le lf lg fd ij"><div class="bz dy l di"><div class="ls lt l"/></div></figure><p id="bd00" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">此时，您可以运行<code class="du lu lv lw li b">go run main.go</code>命令，但是它不能正常工作，因为我们还没有创建客户端并在服务器和客户端之间建立连接。没必要担心，让我们现在就定义它。</p><h1 id="4797" class="ka kb hi bd kc kd lx kf kg kh ly kj kk kl lz kn ko kp ma kr ks kt mb kv kw kx bi translated">待办事项客户端</h1><p id="9020" class="pw-post-body-paragraph iv iw hi ix b iy ky ja jb jc kz je jf jg la ji jj jk lb jm jn jo lc jq jr js hb bi translated">现在，确保您位于主服务的正确工作目录中。之后，将同样的<code class="du lu lv lw li b">todo.proto</code>从<code class="du lu lv lw li b">todo</code>服务复制到<code class="du lu lv lw li b">main</code>服务，并使用这个命令在Python中生成gRPC代码。</p><pre class="ld le lf lg fd lh li lj lk aw ll bi"><span id="5b9e" class="lm kb hi li b fi ln lo l lp lq">python -m grpc_tools.protoc -I. --python_out=./todo --grpc_python_out=./todo ./todo.proto</span></pre><p id="cdd3" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">运行这个命令后，我们有两个生成的文件。接下来，让我们定义客户端操作。</p><figure class="ld le lf lg fd ij"><div class="bz dy l di"><div class="ls lt l"/></div></figure><p id="5ee3" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><code class="du lu lv lw li b">TodoClient</code>有四个方法(不包括构造函数),我们将在todo视图函数中使用。其中四个有各自的职责，例如，当我们想创建一个todo时，<code class="du lu lv lw li b">create_todo</code>方法会调用todo服务中的一个远程过程。</p><p id="1027" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">现在，让我们使用客户端并在视图文件中实现它们。</p><figure class="ld le lf lg fd ij"><div class="bz dy l di"><div class="ls lt l"/></div></figure><p id="bdb5" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">注意，每个视图函数的顶部都有一个装饰器。这个装饰器的工作，就像它的名字一样，是确保只有登录的用户才能访问这个函数。为此，我们必须定义一个中间件。现在，创建一个名为middleware的文件夹，并在其中创建一个名为<code class="du lu lv lw li b">middleware.py</code>的文件。</p><figure class="ld le lf lg fd ij"><div class="bz dy l di"><div class="ls lt l"/></div></figure><p id="55b3" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们的todo服务及其与主服务的连接几乎完成。最后一步，您可以使用Postman测试这个服务。一切正常吗？如果是，那么很好，我们在这里做得很好。</p><p id="7c85" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在下一篇文章中，我们将迁移到使用模板引擎，因此我们的应用程序不再使用REST框架。您可以在这里找到本文的代码<a class="ae iu" href="https://github.com/agusrichard/python-golang-grpc/tree/part3" rel="noopener ugc nofollow" target="_blank">https://github . com/agusrichard/python-golang-grpc/tree/part 3</a>。</p><p id="6d46" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如果您有任何问题或反馈，请随时留下评论或通过电子邮件联系我，agus.richard21@gmail.com。另外，如果你认为这篇文章对你有帮助，请不要犹豫，给这篇文章鼓掌。</p><p id="81ae" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">感谢您的阅读，下一篇文章再见。</p></div></div>    
</body>
</html>