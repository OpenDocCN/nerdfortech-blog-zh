<html>
<head>
<title>LeetCode — Swap Nodes in Pairs</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">LeetCode —成对交换节点</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/leetcode-swap-nodes-in-pairs-976916df0e71?source=collection_archive---------5-----------------------#2021-09-19">https://medium.com/nerd-for-tech/leetcode-swap-nodes-in-pairs-976916df0e71?source=collection_archive---------5-----------------------#2021-09-19</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div class="er es if"><img src="../Images/ea0ff361b0ec634e3a013c524ab3551a.png" data-original-src="https://miro.medium.com/v2/resize:fit:844/format:webp/0*aM_N0gAgPo2wxH-m.png"/></div></figure><h1 id="483f" class="im in hi bd io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj bi translated">问题陈述</h1><p id="2957" class="pw-post-body-paragraph jk jl hi jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh hb bi translated">给定一个链表，交换每两个相邻的节点并返回它的头。您必须在不修改列表节点中的值的情况下解决问题(即，只能更改节点本身。)</p><p id="08bd" class="pw-post-body-paragraph jk jl hi jm b jn ki jp jq jr kj jt ju jv kk jx jy jz kl kb kc kd km kf kg kh hb bi translated">问题陈述摘自:<a class="ae kn" href="https://leetcode.com/problems/swap-nodes-in-pairs" rel="noopener ugc nofollow" target="_blank">https://leetcode.com/problems/swap-nodes-in-pairs</a></p><p id="e9c3" class="pw-post-body-paragraph jk jl hi jm b jn ki jp jq jr kj jt ju jv kk jx jy jz kl kb kc kd km kf kg kh hb bi translated"><strong class="jm hj">例一:</strong></p><pre class="ko kp kq kr fd ks kt ku kv aw kw bi"><span id="cda8" class="kx in hi kt b fi ky kz l la lb">Input: head = [1, 2, 3, 4] <br/>Output: [2, 1, 4, 3]</span></pre><p id="fc26" class="pw-post-body-paragraph jk jl hi jm b jn ki jp jq jr kj jt ju jv kk jx jy jz kl kb kc kd km kf kg kh hb bi translated"><strong class="jm hj">例二:</strong></p><pre class="ko kp kq kr fd ks kt ku kv aw kw bi"><span id="b5a4" class="kx in hi kt b fi ky kz l la lb">Input: head = []<br/>Output: []</span></pre><p id="e502" class="pw-post-body-paragraph jk jl hi jm b jn ki jp jq jr kj jt ju jv kk jx jy jz kl kb kc kd km kf kg kh hb bi translated"><strong class="jm hj">例 3: </strong></p><pre class="ko kp kq kr fd ks kt ku kv aw kw bi"><span id="eb15" class="kx in hi kt b fi ky kz l la lb">Input: head = [1]<br/>Output: [1]</span></pre><p id="580f" class="pw-post-body-paragraph jk jl hi jm b jn ki jp jq jr kj jt ju jv kk jx jy jz kl kb kc kd km kf kg kh hb bi translated"><strong class="jm hj">约束:</strong></p><pre class="ko kp kq kr fd ks kt ku kv aw kw bi"><span id="de89" class="kx in hi kt b fi ky kz l la lb">- The number of nodes in the list is in the range [0, 100]. <br/>- 0 &lt;= Node.val &lt;= 100</span></pre><h1 id="e37e" class="im in hi bd io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj bi translated">说明</h1><h2 id="111e" class="kx in hi bd io lc ld le is lf lg lh iw jv li lj ja jz lk ll je kd lm ln ji lo bi translated">交换链接</h2><p id="e453" class="pw-post-body-paragraph jk jl hi jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh hb bi translated">由于节点值不能交换，通常来说，更改链接是一个更好的主意。</p><p id="de63" class="pw-post-body-paragraph jk jl hi jm b jn ki jp jq jr kj jt ju jv kk jx jy jz kl kb kc kd km kf kg kh hb bi translated"><strong class="jm hj">算法</strong></p><pre class="ko kp kq kr fd ks kt ku kv aw kw bi"><span id="8ca4" class="kx in hi kt b fi ky kz l la lb">- if head == NULL || head-&gt;next == NULL<br/>  - return head<br/><br/>- set ListNode* prev = head<br/>      ListNode* curr = head-&gt;next<br/><br/>- set head = curr and initialize ListNode* next<br/><br/>- loop while true<br/>  - set next = curr-&gt;next<br/>  - point curr-&gt;next = prev<br/><br/>  - if next == NULL || next-&gt;next == NULL<br/>    - set prev-&gt;next = next<br/>    - break // break the loop<br/><br/>  - point prev-&gt;next = next-&gt;next<br/><br/>  - set prev = next<br/><br/>  - set curr = prev-&gt;next<br/><br/>- return head</span></pre><p id="3fd3" class="pw-post-body-paragraph jk jl hi jm b jn ki jp jq jr kj jt ju jv kk jx jy jz kl kb kc kd km kf kg kh hb bi translated">上述程序的时间复杂度为<strong class="jm hj"> O(N) </strong>其中 N 是给定链表中的节点数。</p><p id="5e9a" class="pw-post-body-paragraph jk jl hi jm b jn ki jp jq jr kj jt ju jv kk jx jy jz kl kb kc kd km kf kg kh hb bi translated"><strong class="jm hj"> C++解决方案</strong></p><pre class="ko kp kq kr fd ks kt ku kv aw kw bi"><span id="1636" class="kx in hi kt b fi ky kz l la lb">class Solution {<br/>public:<br/>    ListNode* swapPairs(ListNode* head) {<br/>        if(head == NULL || head-&gt;next == NULL){<br/>            return head;<br/>        }<br/><br/>        ListNode* prev = head;<br/>        ListNode* curr = head-&gt;next;<br/><br/>        head = curr;<br/><br/>        ListNode* next;<br/>        while(true){<br/>            next = curr-&gt;next;<br/>            curr-&gt;next = prev;<br/><br/>            if(next == NULL || next-&gt;next == NULL){<br/>                prev-&gt;next = next;<br/>                break;<br/>            }<br/><br/>            prev-&gt;next = next-&gt;next;<br/><br/>            prev = next;<br/><br/>            curr = prev-&gt;next;<br/>        }<br/><br/>        return head;<br/>    }<br/>};</span></pre><p id="1be2" class="pw-post-body-paragraph jk jl hi jm b jn ki jp jq jr kj jt ju jv kk jx jy jz kl kb kc kd km kf kg kh hb bi translated"><strong class="jm hj">戈朗解决方案</strong></p><pre class="ko kp kq kr fd ks kt ku kv aw kw bi"><span id="5953" class="kx in hi kt b fi ky kz l la lb">func swapPairs(head *ListNode) *ListNode {<br/>    if head == nil || head.Next == nil {<br/>        return head<br/>    }<br/><br/>    prev := head<br/>    curr := head.Next<br/><br/>    head = curr<br/><br/>    for true {<br/>        next := curr.Next<br/>        curr.Next = prev<br/><br/>        if next == nil || next.Next == nil {<br/>            prev.Next = next;<br/>            break;<br/>        }<br/><br/>        prev.Next = next.Next;<br/><br/>        prev = next;<br/><br/>        curr = prev.Next;<br/>    }<br/><br/>    return head<br/>}</span></pre><p id="1060" class="pw-post-body-paragraph jk jl hi jm b jn ki jp jq jr kj jt ju jv kk jx jy jz kl kb kc kd km kf kg kh hb bi translated"><strong class="jm hj"> Javascript 解决方案</strong></p><pre class="ko kp kq kr fd ks kt ku kv aw kw bi"><span id="dfb8" class="kx in hi kt b fi ky kz l la lb">var swapPairs = function(head) {<br/>    if( head == null || head.next == null ){<br/>        return head;<br/>    }<br/><br/>    let prev = head;<br/>    let curr = head.next;<br/><br/>    head = curr;<br/><br/>    while(true){<br/>        let next = curr.next;<br/>        curr.next = prev;<br/><br/>        if(next == null || next.next == null){<br/>            prev.next = next;<br/>            break;<br/>        }<br/><br/>        prev.next = next.next;<br/><br/>        prev = next;<br/><br/>        curr = prev.next;<br/>    }<br/><br/>    return head;<br/>};</span></pre><p id="4d8b" class="pw-post-body-paragraph jk jl hi jm b jn ki jp jq jr kj jt ju jv kk jx jy jz kl kb kc kd km kf kg kh hb bi translated">让我们试运行一下我们的算法，看看解决方案是如何工作的。</p><pre class="ko kp kq kr fd ks kt ku kv aw kw bi"><span id="1233" class="kx in hi kt b fi ky kz l la lb">Input: head = [1, 2, 3, 4]<br/><br/>Step 1: if (head == NULL || head-&gt;next == NULL )<br/>          - false<br/><br/>Step 2: ListNode* prev = head<br/>        ListNode* curr = head-&gt;next<br/><br/>                prev<br/>                 |<br/>        head -- [1, 2, 3, 4]<br/>                    |<br/>                   curr<br/><br/>Step 3: head = curr<br/><br/>        prev<br/>         |<br/>        [1, 2, 3, 4]<br/>            |<br/>           curr,<br/>           head<br/><br/>Step 4: ListNode* next<br/><br/>Step 5: loop while true<br/>        - next = curr-&gt;next<br/>          - next = 3<br/>        - curr-&gt;next = prev<br/>          - curr-&gt;next = 1<br/><br/>        - if next == null || next-&gt;next == null<br/>          - false<br/><br/>        - prev-&gt;next = next-&gt;next<br/>          - prev-&gt;next = 4<br/><br/>        - prev = next<br/>          - prev = 3<br/><br/>        - curr = prev-&gt;next<br/>          - curr = 4<br/><br/>Step 6: loop while true<br/>        - next = curr-&gt;next<br/>          - next = nil<br/><br/>        - curr-&gt;next = prev<br/>          - curr-&gt;next = 3<br/><br/>        - if next == null || next-&gt;next == null<br/>          - true<br/>          - break<br/><br/>So the answer is 2 -&gt; 1 -&gt; 4 -&gt; 3</span></pre></div><div class="ab cl lp lq gp lr" role="separator"><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu"/></div><div class="hb hc hd he hf"><p id="6f97" class="pw-post-body-paragraph jk jl hi jm b jn ki jp jq jr kj jt ju jv kk jx jy jz kl kb kc kd km kf kg kh hb bi translated"><em class="lw">原载于</em><a class="ae kn" href="https://alkeshghorpade.me/post/leetcode-swap-nodes-in-pairs" rel="noopener ugc nofollow" target="_blank"><em class="lw">https://alkeshghorpade . me</em></a><em class="lw">。</em></p></div></div>    
</body>
</html>