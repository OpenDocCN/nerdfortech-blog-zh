<html>
<head>
<title>Writing An Integration Test With Jetpack Compose and Dagger Hilt</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用Jetpack Compose和Dagger Hilt编写集成测试</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/writing-an-integration-test-with-jetpack-compose-and-dagger-hilt-8ef888c1a23d?source=collection_archive---------0-----------------------#2021-04-16">https://medium.com/nerd-for-tech/writing-an-integration-test-with-jetpack-compose-and-dagger-hilt-8ef888c1a23d?source=collection_archive---------0-----------------------#2021-04-16</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/1fc43363bd3f1b9ccbe6a3719916e675.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*fKSp20mYCpkd2HxC"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">照片由<a class="ae iu" href="https://unsplash.com/@totempropartis?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Heri Mulyana </a>在<a class="ae iu" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="3428" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这篇文章将展示一个使用Hilt在Compose和ViewModel之间运行集成测试的简单设置。</p><p id="a2b7" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">自从Compose变成beta版后，我一直在花时间熟悉它。我选择了一个辅助项目作为我的学习媒介——一个显示库存项目列表的简单应用程序。作为一个“负责任”的工程师，我决定从初始阶段开始添加测试。Compose和Hilt的团队在记录它们方面做得非常好，所以关于测试的信息很容易找到。然而，我并没有发现太多涉及这两者的场景。</p></div><div class="ab cl jt ju gp jv" role="separator"><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy"/></div><div class="hb hc hd he hf"><h2 id="5fab" class="ka kb hi bd kc kd ke kf kg kh ki kj kk jg kl km kn jk ko kp kq jo kr ks kt ku bi translated"><strong class="ak">项目结构</strong></h2><p id="8891" class="pw-post-body-paragraph iv iw hi ix b iy kv ja jb jc kw je jf jg kx ji jj jk ky jm jn jo kz jq jr js hb bi translated">让我们假设下面的结构。</p><figure class="lb lc ld le fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es la"><img src="../Images/81ac418cf8186d87fbc0b0a6f0558158.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fZvt3uBRX3DxBm3nnT2tKQ.png"/></div></div></figure><p id="77d5" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">使用Hilt将存储库、视图模型和活动连接在一起，以管理它们的依赖关系。</p><h2 id="4d90" class="ka kb hi bd kc kd ke kf kg kh ki kj kk jg kl km kn jk ko kp kq jo kr ks kt ku bi translated"><strong class="ak">测试场景</strong></h2><p id="f689" class="pw-post-body-paragraph iv iw hi ix b iy kv ja jb jc kw je jf jg kx ji jj jk ky jm jn jo kz jq jr js hb bi translated">对于本文，我们将使用一个简单的集成测试场景，验证我们的UI显示一个库存项目列表。理想情况下，这个测试帮助我们确保我们的视图模型和组合UI按照预期的方式一起工作。</p><p id="8903" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">(<em class="lf">请记住这是一个人为的例子。可以对这种测试的价值进行争论。然而，这不是这篇文章的重点</em></p><p id="b58c" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">让我们仔细看看我们项目中的一些代码，以便更好地理解如何实现这个测试。</p><h2 id="866f" class="ka kb hi bd kc kd ke kf kg kh ki kj kk jg kl km kn jk ko kp kq jo kr ks kt ku bi translated">测试中的代码</h2><figure class="lb lc ld le fd ij"><div class="bz dy l di"><div class="lg lh l"/></div><figcaption class="iq ir et er es is it bd b be z dx translated"><strong class="ak">主要活动:</strong>作曲和刀柄的入口点。这里的InventoryViewModel由Hilt提供。</figcaption></figure><figure class="lb lc ld le fd ij"><div class="bz dy l di"><div class="lg lh l"/></div><figcaption class="iq ir et er es is it bd b be z dx translated"><strong class="ak"> InventoryViewModel: </strong>负责从存储库中读取数据并发出一个UiState。</figcaption></figure><figure class="lb lc ld le fd ij"><div class="bz dy l di"><div class="lg lh l"/></div><figcaption class="iq ir et er es is it bd b be z dx translated"><strong class="ak">清单条目:</strong>一个负责显示清单条目列表的组件。</figcaption></figure><p id="816a" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">(<em class="lf">这篇文章不会详细解释Hilt是如何工作的，但是，请注意注释</em><code class="du li lj lk ll b"><em class="lf">@AndroidEntryPoint</em></code><em class="lf"/><code class="du li lj lk ll b"><em class="lf">@HiltViewModel</em></code><em class="lf"/><code class="du li lj lk ll b"><em class="lf">@Inject</em></code><em class="lf">都与使用它进行依赖注入所需的Hilt设置有关。更多信息</em> <a class="ae iu" href="https://developer.android.com/training/dependency-injection/hilt-android" rel="noopener ugc nofollow" target="_blank"> <em class="lf">此处</em> </a> <em class="lf"> ) </em></p><p id="3056" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">查看上面的代码片段，我们可以观察到<code class="du li lj lk ll b">InventoryViewModel</code>依赖于<code class="du li lj lk ll b">InventoryRepository</code>获取数据。存储库通常负责从云中获取这些数据。</p><p id="6e51" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">测试时，我们的目标是创建一个尽可能接近生产的场景，同时仍然是可预测的和可靠的。因此，为了我们的最大利益，避免攻击任何实际的服务器来获取数据。相反，我们更愿意为测试断言提供一个硬编码的项目列表。</p><p id="3b15" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">仔细看看<code class="du li lj lk ll b">InventoryRepository</code>，我们看到它是一个接口。这很重要，因为它给了我们提供任何我们喜欢的具体实现的灵活性。</p><figure class="lb lc ld le fd ij"><div class="bz dy l di"><div class="lg lh l"/></div></figure><p id="4584" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">然而，我们希望只在测试时交换到<strong class="ix hj">。这就是Hilt及其测试能力发挥作用的地方。一会儿我们会看到这些是什么。</strong></p><p id="d67b" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">为了完成我们的测试目标，我们需要以下内容:</p><ul class=""><li id="5107" class="lm ln hi ix b iy iz jc jd jg lo jk lp jo lq js lr ls lt lu bi translated">用于测试的预定项目列表</li><li id="a786" class="lm ln hi ix b iy lv jc lw jg lx jk ly jo lz js lr ls lt lu bi translated">Hilt的测试依赖:Hilt提供了API，允许我们操作依赖注入过程来满足我们的测试需求。我们可以通过<code class="du li lj lk ll b">HiltAndroidRule, HiltTestApplication</code>和<code class="du li lj lk ll b">HiltTestRunner</code>来实现这一点</li><li id="adb9" class="lm ln hi ix b iy lv jc lw jg lx jk ly jo lz js lr ls lt lu bi translated">测试Compose的依赖关系:这提供了<code class="du li lj lk ll b">ComposeTestRule</code>，我们将使用它来“加载”我们的可组合组件并执行断言。</li><li id="fe84" class="lm ln hi ix b iy lv jc lw jg lx jk ly jo lz js lr ls lt lu bi translated">耐心😂</li></ul><p id="c9ac" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">让我们开始吧…</p><h2 id="2c78" class="ka kb hi bd kc kd ke kf kg kh ki kj kk jg kl km kn jk ko kp kq jo kr ks kt ku bi translated">添加测试依赖项</h2><p id="1eed" class="pw-post-body-paragraph iv iw hi ix b iy kv ja jb jc kw je jf jg kx ji jj jk ky jm jn jo kz jq jr js hb bi translated">下面的依赖关系让我们能够访问测试规则和其他组件来编写我们的测试。</p><figure class="lb lc ld le fd ij"><div class="bz dy l di"><div class="lg lh l"/></div></figure><h2 id="f7a2" class="ka kb hi bd kc kd ke kf kg kh ki kj kk jg kl km kn jk ko kp kq jo kr ks kt ku bi translated">提供虚假的物品清单</h2><p id="aeba" class="pw-post-body-paragraph iv iw hi ix b iy kv ja jb jc kw je jf jg kx ji jj jk ky jm jn jo kz jq jr js hb bi translated">Hilt让这变得非常容易。基本前提是通过替换用于提供依赖关系的模块，用测试版本替换真实的依赖关系。</p><figure class="lb lc ld le fd ij"><div class="bz dy l di"><div class="lg lh l"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">在测试时提供列表库的假实现的柄模块</figcaption></figure><p id="d1b9" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这段代码基本上导致了只在测试期间适用的模块的创建。使用由Hilt的测试工件提供的<code class="du li lj lk ll b">@TestInstallIn</code>注释，我们可以指定:</p><ul class=""><li id="4d88" class="lm ln hi ix b iy iz jc jd jg lo jk lp jo lq js lr ls lt lu bi translated">依赖关系的相关组件范围。这是使用<code class="du li lj lk ll b">components</code>参数完成的，</li><li id="77e6" class="lm ln hi ix b iy lv jc lw jg lx jk ly jo lz js lr ls lt lu bi translated">使用<code class="du li lj lk ll b">replaces</code>参数，该测试模块应替换的模块。</li></ul><h2 id="397a" class="ka kb hi bd kc kd ke kf kg kh ki kj kk jg kl km kn jk ko kp kq jo kr ks kt ku bi translated"><strong class="ak">安装hilttestatapplication</strong></h2><p id="2051" class="pw-post-body-paragraph iv iw hi ix b iy kv ja jb jc kw je jf jg kx ji jj jk ky jm jn jo kz jq jr js hb bi translated">使用Hilt需要一个用<code class="du li lj lk ll b">@HiltAndroidApp</code>注释的应用程序类。该注释生成一个顶级组件，由Hilt用来提供对其他组件的依赖(例如由<code class="du li lj lk ll b">@androidEntryPoint</code>注释创建的<code class="du li lj lk ll b">ActivityComponent</code>)。)</p><p id="c32a" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">同样的要求也适用于测试。幸运的是，Hilt提供了一个我们可以使用的测试应用程序，下面是设置的样子。</p><figure class="lb lc ld le fd ij"><div class="bz dy l di"><div class="lg lh l"/></div></figure><p id="e6b2" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们将使用这个测试运行程序来代替默认的测试运行程序，方法是在我们的项目级Gradle文件中指定这一行。</p><figure class="lb lc ld le fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ma"><img src="../Images/88ad6949c9e65638e0dc87beba1c11a1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lxxkm8zBQzR7SiRHREHusw.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated"><strong class="bd kc">注意:</strong>使用您的包名</figcaption></figure><h2 id="4822" class="ka kb hi bd kc kd ke kf kg kh ki kj kk jg kl km kn jk ko kp kq jo kr ks kt ku bi translated">最后，写测试。</h2><p id="8d07" class="pw-post-body-paragraph iv iw hi ix b iy kv ja jb jc kw je jf jg kx ji jj jk ky jm jn jo kz jq jr js hb bi translated">在这最后一步，我们终于准备好编写测试类了。</p><figure class="lb lc ld le fd ij"><div class="bz dy l di"><div class="lg lh l"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">使用Hilt和Compose编写的Ui测试</figcaption></figure><p id="3d2e" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在编写测试时，我们应该注意一些事情:</p><ul class=""><li id="f0b5" class="lm ln hi ix b iy iz jc jd jg lo jk lp jo lq js lr ls lt lu bi translated">为了用Hilt运行一个插装测试，我们将用<code class="du li lj lk ll b">@HiltAndroidTest</code>注释测试类。</li><li id="b5ad" class="lm ln hi ix b iy lv jc lw jg lx jk ly jo lz js lr ls lt lu bi translated"><code class="du li lj lk ll b">HiltAndroidRule</code>允许我们通过调用<code class="du li lj lk ll b">inject()</code>在测试中执行注射。这将使我们能够用我们之前定义的fake替换ViewModel的存储库依赖项。</li><li id="fbb2" class="lm ln hi ix b iy lv jc lw jg lx jk ly jo lz js lr ls lt lu bi translated"><code class="du li lj lk ll b">ComposeTestRule</code>是将主(根)组件加载到屏幕上所必需的。这是通过调用测试规则上的<code class="du li lj lk ll b">setContent</code>并传入可组合的来完成的。</li></ul><h2 id="d8d8" class="ka kb hi bd kc kd ke kf kg kh ki kj kk jg kl km kn jk ko kp kq jo kr ks kt ku bi translated">对测试规则进行排序</h2><p id="33ff" class="pw-post-body-paragraph iv iw hi ix b iy kv ja jb jc kw je jf jg kx ji jj jk ky jm jn jo kz jq jr js hb bi translated">为了成功地使用Compose和Hilt编写一个正常运行的UI测试，这两个测试规则都必须作为类级属性可访问，以允许访问上面提到的测试API。另外，Hilt要求其测试规则首先执行<strong class="ix hj"><em class="lf"/></strong>。JUnit提供了两种方法来实现这一点。</p><ul class=""><li id="ed8e" class="lm ln hi ix b iy iz jc jd jg lo jk lp jo lq js lr ls lt lu bi translated"><strong class="ix hj"> RuleChain API </strong>:使用这个API，我们可以像这样轻松地指定顺序:</li></ul><figure class="lb lc ld le fd ij"><div class="bz dy l di"><div class="lg lh l"/></div></figure><p id="7f9b" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">然而，这将阻止规则作为单独的属性被访问，从而阻止我们分别调用句柄上的<code class="du li lj lk ll b">inject()</code>和<code class="du li lj lk ll b">setContent{}</code>并编写测试规则。因此，这(👇🏽)是比较好的做法。</p><figure class="lb lc ld le fd ij"><div class="bz dy l di"><div class="lg lh l"/></div></figure><ul class=""><li id="91bf" class="lm ln hi ix b iy iz jc jd jg lo jk lp jo lq js lr ls lt lu bi translated"><strong class="ix hj"/><code class="du li lj lk ll b"><strong class="ix hj">order</strong></code><strong class="ix hj">参数</strong> : JUnit <code class="du li lj lk ll b">4.13</code>提供了一种更简单的方法，通过使用<code class="du li lj lk ll b">Rule</code>注释的<code class="du li lj lk ll b">order</code>参数来实现这些约束。您需要做的就是为每个规则提供一个数值。提供的数值用于按升序对规则进行排序。下面是使用这种方法的代码:</li></ul><figure class="lb lc ld le fd ij"><div class="bz dy l di"><div class="lg lh l"/></div></figure><p id="7d80" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">将所有东西放在一起，我们将最终完成这个琐碎但功能强大的集成测试。</p><figure class="lb lc ld le fd ij"><div class="bz dy l di"><div class="lg lh l"/></div></figure></div><div class="ab cl jt ju gp jv" role="separator"><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy"/></div><div class="hb hc hd he hf"><p id="6621" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">按照上面在我们简化的场景中描述的步骤，你应该能够为你的基于组合的UI编写一个<strong class="ix hj">集成测试，并注入依赖关系</strong>。关键的要点是确保两个测试规则都可以作为测试中的类级属性来访问，并在测试时使用Hilt的机制来提供假的实现。</p><p id="95ce" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">快乐作曲和测试。</p><p id="d951" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><em class="lf">我要感谢</em> <a class="mb mc ge" href="https://medium.com/u/8efc0359e234?source=post_page-----8ef888c1a23d--------------------------------" rel="noopener" target="_blank"> <em class="lf">乔西·沃尔夫</em></a><em class="lf"/><a class="mb mc ge" href="https://medium.com/u/cc847167b232?source=post_page-----8ef888c1a23d--------------------------------" rel="noopener" target="_blank"><em class="lf">汉尼斯·斯特鲁</em> </a> <em class="lf">和</em> <a class="mb mc ge" href="https://medium.com/u/9b0ad522a833?source=post_page-----8ef888c1a23d--------------------------------" rel="noopener" target="_blank"> <em class="lf">丽莎·翁沃迪</em> </a> <em class="lf">在撰写本文时提供的反馈。</em></p></div></div>    
</body>
</html>