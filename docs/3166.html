<html>
<head>
<title>Make the Camera Shake when the Player is Damaged</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">当播放器损坏时，使相机抖动</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/make-the-camera-shake-when-the-player-is-damaged-7034a858bc6f?source=collection_archive---------21-----------------------#2021-05-31">https://medium.com/nerd-for-tech/make-the-camera-shake-when-the-player-is-damaged-7034a858bc6f?source=collection_archive---------21-----------------------#2021-05-31</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/732e96d00914360e931c060767f8245a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*YCY64BtuG22FbG5B5TAzMQ.gif"/></div></div></figure><p id="c714" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们已经有了<a class="ae jo" rel="noopener" href="/codex/damage-vfx-using-animated-sprites-in-unity-c13e2dbb68bb">伤害VFX</a>、<a class="ae jo" href="https://levelup.gitconnected.com/creating-enemy-explosions-e2404cd45833" rel="noopener ugc nofollow" target="_blank">爆炸</a>和一个<a class="ae jo" rel="noopener" href="/codex/creating-a-lives-counter-ui-element-in-unity-9d48b485555e">生命计数器UI</a>……为什么不在玩家被击中时加入一个相机抖动来让事情变得更戏剧性呢？毕竟，视觉上表现游戏元素有助于伟大的游戏设计！</p><p id="d29e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">目标</strong>:暂时将摄像机变换到随机位置，以制造抖动的错觉。然后将位置设置回默认值，这样摄像机就不会无限移动。</p></div><div class="ab cl jp jq gp jr" role="separator"><span class="js bw bk jt ju jv"/><span class="js bw bk jt ju jv"/><span class="js bw bk jt ju"/></div><div class="hb hc hd he hf"><h1 id="0d97" class="jw jx hi bd jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt bi translated">用协程让相机抖动</h1><ol class=""><li id="1c68" class="ku kv hi is b it kw ix kx jb ky jf kz jj la jn lb lc ld le bi translated">为相机抖动行为创建一个新脚本，并相应地命名它。这需要一个单独的脚本，因为它将被附加到相机本身。</li></ol><p id="005b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">2.创建三个全局变量，稍后将用于计算抖动。</p><ul class=""><li id="a8ec" class="ku kv hi is b it iu ix iy jb lf jf lg jj lh jn li lc ld le bi translated"><strong class="is hj"> _isShaking </strong>将用于<strong class="is hj">激活</strong>摇动效果</li><li id="e5c6" class="ku kv hi is b it lj ix lk jb ll jf lm jj ln jn li lc ld le bi translated"><strong class="is hj">持续时间</strong>决定<strong class="is hj">摇晃将持续多长时间</strong>。</li><li id="d4c3" class="ku kv hi is b it lj ix lk jb ll jf lm jj ln jn li lc ld le bi translated"><strong class="is hj">震级</strong>是我们对于震动强度的<strong class="is hj">乘数</strong>。</li></ul><figure class="lp lq lr ls fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lo"><img src="../Images/bfade252f624eba792bf961cc6edefe1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*t7Xwu_i4QOQOc4lA7cZxrg.png"/></div></div></figure><p id="40af" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">3.创建一个<a class="ae jo" rel="noopener" href="/codex/coroutines-with-unity-b5a2b3fc3426">协程</a>，这个与我在之前的文章中讨论的略有不同，但是我们会一步一步来。</p><p id="7031" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">你要添加到这个协程的第一件事是一个默认的位置向量，这将是摄像机的常规<a class="ae jo" href="https://docs.unity3d.com/ScriptReference/Transform-position.html" rel="noopener ugc nofollow" target="_blank">变换。我们需要这个，这样我们就可以在震动结束后随时重置位移。</a></p><figure class="lp lq lr ls fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lt"><img src="../Images/842c2702d1dd97e2b76611d3332f4da9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*01JuoHigrw_OaD4pXywSfg.png"/></div></div></figure><p id="c642" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">4.创建一个变量来跟踪自协程开始运行以来经过的时间。您可能会发现一些代码类似于<a class="ae jo" href="https://dennisse-pd.medium.com/how-to-create-a-cooldown-system-in-unity-4156f3a842ae?source=your_stories_page-------------------------------------" rel="noopener">冷却系统</a>，但是我们不会使用Time.time，因为我们需要计算从<em class="lu">最后一帧</em>开始的时间，而不是从应用程序<em class="lu">开始运行</em>开始的时间。</p><figure class="lp lq lr ls fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lt"><img src="../Images/7a38b4671a76648e5800f0ef0c1baf9f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NqYxxZtH5YzqNmHWgI5pEA.png"/></div></div></figure><p id="bd38" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">5.创建一个while循环，它将在运行时间小于我们为shake效果设置的持续时间时运行。</p><figure class="lp lq lr ls fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lt"><img src="../Images/5a7e3d32f83003bcffb5af92d8466255.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3SZrbTO5DbXN5qK8H5ytsQ.png"/></div></div></figure><p id="557f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">6.为相机的X和Y位置指定一个随机值。这里将使用数量乘数</p><blockquote class="lv lw lx"><p id="6709" class="iq ir lu is b it iu iv iw ix iy iz ja ly jc jd je lz jg jh ji ma jk jl jm jn hb bi translated"><strong class="is hj">注意</strong>:让我们回顾一些现实生活中的知识，它们可以帮助这些代码更容易理解和记忆。一个<strong class="is hj">震级</strong>是<strong class="is hj">地震</strong>的物理大小，长度和宽度。这就是为什么我们指定的变量乘以X和Y位置的运动被命名为。</p></blockquote><figure class="lp lq lr ls fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mb"><img src="../Images/41edaa6944064fa4507550a04321bcf6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zel8rJDfGJst9tj2XXctwg.png"/></div></div></figure><p id="009d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">7.有了新添加的x和y位置变量，我们可以设置一个新的向量来接收这些信息。-10是摄像机的默认Z位置。然后，我们必须加上经过的时间，使数字相应增加。这里我们使用Time.deltaTime，因为它告诉我们自上一帧以来的时间，这正是我们所需要的。</p><figure class="lp lq lr ls fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mc"><img src="../Images/f4f7e6d3a95109dfa3f90b90c6f56a04.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PhdcxPokpUkwhp6oFiQsqQ.png"/></div></div></figure><p id="2045" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">8.为协程添加点睛之笔，即yield语句。</p><figure class="lp lq lr ls fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mc"><img src="../Images/e7f6d7f4b41d1d22f2a602d9198df535.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*U5PFf1YN5kvOjsQhdWDZOA.png"/></div></div></figure><blockquote class="lv lw lx"><p id="afa1" class="iq ir lu is b it iu iv iw ix iy iz ja ly jc jd je lz jg jh ji ma jk jl jm jn hb bi translated"><strong class="is hj">注意:为什么用return null代替0？null和0不是一回事吗？</strong>是和否。虽然两者都适用于单个帧，但return 0会分配内存，因为它有一个需要装箱和取消装箱的数值。另一方面，Null则不会，这增强了性能。</p></blockquote><p id="4469" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">9.为了用协程结束工作，我们只需要将摄像机的位置设置回默认值。</p><figure class="lp lq lr ls fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mc"><img src="../Images/8f6b895b68a4402bcd0f976bf4109aff.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tXyKKmqmk4Mi2ylHLDdhWg.png"/></div></div></figure></div><div class="ab cl jp jq gp jr" role="separator"><span class="js bw bk jt ju jv"/><span class="js bw bk jt ju jv"/><span class="js bw bk jt ju"/></div><div class="hb hc hd he hf"><h1 id="5f04" class="jw jx hi bd jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt bi translated">启动协程</h1><ol class=""><li id="607a" class="ku kv hi is b it kw ix kx jb ky jf kz jj la jn lb lc ld le bi translated">在同一个脚本中，创建一个void方法来启动协程。</li></ol><figure class="lp lq lr ls fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es md"><img src="../Images/e7f9b186d39698a115332d55f118861f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AEaXosvfHqM9ZTlB4neS4w.png"/></div></div></figure><p id="4e7e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">2.使用<a class="ae jo" rel="noopener" href="/codex/script-communication-in-unity-using-getcomponent-ca4444bfec6">脚本通信</a>从你的玩家脚本中调用新创建的void方法。理想情况下，当你的玩家受到伤害时应该调用这个函数。在减去生命后，我的将被放在damagePlayer()方法中。</p><figure class="lp lq lr ls fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es me"><img src="../Images/d139e93cf414871f64755211dfae2996.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*27QDMf4E9Ph-0_2rJut7_g.png"/></div></div></figure><h2 id="78a4" class="mf jx hi bd jy mg mh mi kc mj mk ml kg jb mm mn kk jf mo mp ko jj mq mr ks ms bi translated">结果是:</h2><figure class="lp lq lr ls fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mt"><img src="../Images/a39003da8e8b4e48c67935f3486e49f1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*RgtYoEpA3khTZDM2flBrsQ.gif"/></div></div></figure></div></div>    
</body>
</html>