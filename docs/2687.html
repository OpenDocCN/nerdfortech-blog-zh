<html>
<head>
<title>Binary Tree Cameras — Amazon Interview Question</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">二叉树相机——亚马逊面试问题</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/binary-tree-cameras-daily-challenge-may-4881a07ecd62?source=collection_archive---------14-----------------------#2021-05-16">https://medium.com/nerd-for-tech/binary-tree-cameras-daily-challenge-may-4881a07ecd62?source=collection_archive---------14-----------------------#2021-05-16</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><figure class="hh hi ez fb hj hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es hg"><img src="../Images/1e0c2e24deaa65b621c31fd94e21614a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NsGVxrvA2kiTOQPCOGsF6Q.jpeg"/></div></div><figcaption class="hr hs et er es ht hu bd b be z dx translated">照片由<a class="ae hv" href="https://unsplash.com/s/photos/survelliance?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的<a class="ae hv" href="https://unsplash.com/@rishabh?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Rishabh Varshney </a>拍摄</figcaption></figure><div class=""/><div class=""><h2 id="1045" class="pw-subtitle-paragraph iv hx hy bd b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm dx translated"><a class="ae hv" href="https://leetcode.com/problems/binary-tree-cameras/" rel="noopener ugc nofollow" target="_blank"> 968 </a>。二叉树照相机</h2></div><p id="194f" class="pw-post-body-paragraph jn jo hy jp b jq jr iz js jt ju jc jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">给定一棵二叉树，我们在树的节点上安装摄像机。</p><p id="2b22" class="pw-post-body-paragraph jn jo hy jp b jq jr iz js jt ju jc jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">节点上的每个摄像机可以监控其父节点、自身及其直接子节点。</p><p id="d68f" class="pw-post-body-paragraph jn jo hy jp b jq jr iz js jt ju jc jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">计算监控树的所有节点所需的最少摄像机数量。</p><h2 id="2fee" class="kj kk hy bd kl km kn ko kp kq kr ks kt jw ku kv kw ka kx ky kz ke la lb lc ld bi translated">示例:</h2><pre class="le lf lg lh fd li lj lk ll aw lm bi"><span id="e4af" class="kj kk hy lj b fi ln lo l lp lq"><strong class="lj hz">Input: </strong>[0,0,null,0,0]<br/><strong class="lj hz">Output: </strong>1<br/><strong class="lj hz">Explanation: </strong>One camera is enough to monitor all nodes if placed as shown.</span></pre><h2 id="7686" class="kj kk hy bd kl km kn ko kp kq kr ks kt jw ku kv kw ka kx ky kz ke la lb lc ld bi translated">理解问题:</h2><p id="a2f9" class="pw-post-body-paragraph jn jo hy jp b jq lr iz js jt ls jc jv jw lt jy jz ka lu kc kd ke lv kg kh ki hb bi translated">因为我们想要最小化摄像机的数量，有一点是清楚的，我们不在叶节点放置摄像机。这样我们就可以从树叶追踪到树根。这使得DFS成为解决该问题的最有可能的选择。但是当我们往回追溯时，我们需要在节点之间交换信息，以查看当前节点是否需要摄像机。如果前一个节点已经有一个摄像机，我们不需要摄像机。总而言之，我们需要考虑以下事项:</p><blockquote class="lw lx ly"><p id="58e2" class="jn jo lz jp b jq jr iz js jt ju jc jv ma jx jy jz mb kb kc kd mc kf kg kh ki hb bi translated">如果当前节点是叶节点，那么我们不需要摄像机。<br/>如果我们在当前节点上没有摄像机，那么父节点需要它。<br/>如果当前节点有摄像机，那么它的父节点不需要摄像机。</p></blockquote><p id="419a" class="pw-post-body-paragraph jn jo hy jp b jq jr iz js jt ju jc jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">我们可以指定不同的值来表示这些状态。-1 from children的意思是放相机。1来自任何儿童意味着没有相机。</p><figure class="le lf lg lh fd hk er es paragraph-image"><div class="er es md"><img src="../Images/e087f67c49a501ef1eccaa259038a8a3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1258/format:webp/1*Z-yoXiiahPtbfGqTcRi1Tg.png"/></div></figure><h2 id="3567" class="kj kk hy bd kl km kn ko kp kq kr ks kt jw ku kv kw ka kx ky kz ke la lb lc ld bi translated">代码实现:</h2><pre class="le lf lg lh fd li lj lk ll aw lm bi"><span id="02f6" class="kj kk hy lj b fi ln lo l lp lq"># Definition for a binary tree node.<br/># class TreeNode:<br/>#     def __init__(self, val=0, left=None, right=None):<br/>#         self.val = val<br/>#         self.left = left<br/>#         self.right = right<br/>class Solution:<br/>    def minCameraCover(self, root: TreeNode) -&gt; int:<br/>        def dfs(node):<br/>            l=0<br/>            r=0<br/>            if (node.left is None and node.right is None):<br/>                return -1<br/>            if node.left:<br/>                l = dfs(node.left)<br/>            if node.right:<br/>                r = dfs(node.right)<br/>            if(l == -1 or r == -1):<br/>                self.count += 1<br/>                return 1<br/>            if(l == 0 and r == 0):<br/>                return -1<br/>            if(l == 1 or r == 1):<br/>                return 0<br/>        self.count=0<br/>        cams = dfs(root)<br/>        if(cams == -1):<br/>            self.count += 1<br/>        return self.count</span></pre><h2 id="bb6f" class="kj kk hy bd kl km kn ko kp kq kr ks kt jw ku kv kw ka kx ky kz ke la lb lc ld bi translated">复杂性分析</h2><ul class=""><li id="1285" class="me mf hy jp b jq lr jt ls jw mg ka mh ke mi ki mj mk ml mm bi translated">时间复杂度:O(N) <em class="lz"> </em>其中<em class="lz"> N </em>是二叉树中节点的数量</li><li id="6cb8" class="me mf hy jp b jq mn jt mo jw mp ka mq ke mr ki mj mk ml mm bi translated">空间复杂度:递归调用堆栈的空间可能是n。</li></ul><p id="3145" class="pw-post-body-paragraph jn jo hy jp b jq jr iz js jt ju jc jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">编码快乐！！！</p></div></div>    
</body>
</html>