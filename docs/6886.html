<html>
<head>
<title>Optimization pt 5</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">优化 pt 5</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/when-to-stop-at-near-enough-5f0a0ad6bdd3?source=collection_archive---------1-----------------------#2022-06-07">https://medium.com/nerd-for-tech/when-to-stop-at-near-enough-5f0a0ad6bdd3?source=collection_archive---------1-----------------------#2022-06-07</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="e9fb" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">何时在足够近的地方停下来</h2></div><p id="ec52" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">GPXmagic 读写 GPX 文件，这些文件是由经度和纬度对组成的路线的 XML 表示，通常带有高度。</p><figure class="ju jv jw jx fd jy er es paragraph-image"><div role="button" tabindex="0" class="jz ka di kb bf kc"><div class="er es jt"><img src="../Images/22b555ba05ede69ed027beac8e759411.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*x4iMLeTB1vWkDbNN0QYZWw.png"/></div></div><figcaption class="kf kg et er es kh ki bd b be z dx translated">许多运动员用 GPX 档案计划和跟踪活动</figcaption></figure><p id="ba9e" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">显然，我使用 XML 解析器并处理语法树来访问数据，对吗？不。我从没为此烦恼过。当我开始的时候，我尝试正则表达式来让我快速入门。(转义<code class="du kj kk kl km b">\</code>让它看起来比实际情况更糟)。</p><pre class="ju jv jw jx fd kn km ko kp aw kq bi"><span id="7ba0" class="kr ks hi km b fi kt ku l kv kw"><strong class="km hj">let<br/>    trkpts </strong>=<br/>        Regex.find (asRegex <strong class="km hj">"(&lt;trkpt(.|\\s)*?)(trkpt&gt;|\\/&gt;)"</strong>) xml<br/><br/>    <strong class="km hj">latitude </strong>trkpt =<br/>        Regex.find (asRegex <strong class="km hj">"lat=\\\"([\\d\\.-]*)\\\""</strong>) trkpt<br/><br/>    <strong class="km hj">longitude </strong>trkpt =<br/>        Regex.find (asRegex <strong class="km hj">"lon=\\\"([\\d\\.-]*)\\\""</strong>) trkpt<br/><br/>    <strong class="km hj">elevation </strong>trkpt =<br/>        Regex.find (asRegex <strong class="km hj">"&lt;ele&gt;([\\d\\.-]*)&lt;\\/ele&gt;"</strong>) trkpt</span></pre><p id="fb94" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这很有效，我从来不觉得有必要改变它。直到最近。XML 文件在<code class="du kj kk kl km b">trkpt</code>标签列表之外有一个<code class="du kj kk kl km b">trkseg</code>标签，所以一条路线可以由多个线段组成，每个线段都有许多点，但是路线从来没有。</p><p id="77d5" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">对即将推出的 RGT 功能的支持改变了这一点。我需要用可选的<code class="du kj kk kl km b">&lt;namedSegment&gt;</code>标签提取片段。</p><p id="ad86" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">首先，我尝试用外部正则表达式来做这件事。那真的不太顺利。它“有点”起作用，但是太慢了。我想这是因为捕获的字符串大得离谱，伴随着内存抖动。</p><p id="e939" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">现在似乎是时候做“正确的事情”并使用一个完整的 XML 解析器了。就编码工作和执行时间而言，这肯定是最简单和最有效的。你会希望。</p><p id="7828" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">长话短说，它<em class="kx">似乎</em>完全没问题。我可以加载高达 84KB 的文件。我的第二大文件 93KB 无法加载。没有错误，什么都没有。几分钟过去了。没什么。没办法知道发生了什么。任何更大的文件——我有一个 22MB 的测试文件——都会以同样的方式失败。</p><p id="ffba" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我想这可能仍然是我的代码构建了太多的中间结果，尽管这无法解释灾难性的失败模式。我将所有的代码整理成一个超级高效的单次遍历，只需要最少的数据复制。同样的结果。</p><p id="ce90" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这看起来像一个节目停止。不能有低得离谱的文件大小限制，需要保留片段中轨道点的结构嵌套，并保留片段名称。</p><p id="5f7c" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">佩妮掉了。正则表达式匹配结果包括文件中匹配的偏移量。例如，我知道跟踪点标签在偏移量 652、723、781 等处，我可以简单地进行更多的正则表达式搜索:</p><pre class="ju jv jw jx fd kn km ko kp aw kq bi"><span id="3713" class="kr ks hi km b fi kt ku l kv kw"><strong class="km hj">trackSegmentStarts </strong>=<br/>    Regex.find (asRegex <strong class="km hj">"&lt;trkseg&gt;"</strong>) xml<br/>        |&gt; List.map <em class="kx">.index<br/><br/></em><strong class="km hj">namedSegments </strong>=<br/>    Regex.find <br/>        (asRegex <strong class="km hj">"namedSegment&gt;(.*)&lt;\\/.*:namedSegment"</strong>) <br/>        xml</span></pre><p id="2b68" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">那么这仅仅是一个建立两者相对位置的问题，我可以推断出结构。整洁，不完美，有点蹩脚，但它快速而稳定。</p><p id="852f" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">“够近了”，我爸爸会说。</p></div></div>    
</body>
</html>