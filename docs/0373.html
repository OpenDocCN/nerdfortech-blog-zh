<html>
<head>
<title>Tree Data Structure</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">树形数据结构</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/tree-data-structure-ce938cf157e?source=collection_archive---------2-----------------------#2020-11-08">https://medium.com/nerd-for-tech/tree-data-structure-ce938cf157e?source=collection_archive---------2-----------------------#2020-11-08</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="7ad9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">到目前为止，我们已经探索了各种数据结构，如数组和链表。今天我们将深入探讨一下<strong class="ih hj">树形数据结构</strong>。如果你还没有读过我以前的关于指针的文章，请查看并回来。</p><div class="jd je ez fb jf jg"><a href="https://vaidhyanathansm.medium.com/all-you-need-to-know-about-pointers-part-1-1470d2d24d78" rel="noopener follow" target="_blank"><div class="jh ab dw"><div class="ji ab jj cl cj jk"><h2 class="bd hj fi z dy jl ea eb jm ed ef hh bi translated">关于指针你需要知道的一切-第 1 部分</h2><div class="jn l"><h3 class="bd b fi z dy jl ea eb jm ed ef dx translated">C 语言中最重要的概念之一是指针。此外，这一概念被认为是最令人困惑和一…</h3></div><div class="jo l"><p class="bd b fp z dy jl ea eb jm ed ef dx translated">vaidhyanathansm.medium.com</p></div></div><div class="jp l"><div class="jq l jr js jt jp ju jv jg"/></div></div></a></div><div class="jd je ez fb jf jg"><a href="https://vaidhyanathansm.medium.com/all-you-need-to-know-about-pointers-part-2-b6153ed93fe" rel="noopener follow" target="_blank"><div class="jh ab dw"><div class="ji ab jj cl cj jk"><h2 class="bd hj fi z dy jl ea eb jm ed ef hh bi translated">关于指针你需要知道的一切-第 2 部分</h2><div class="jn l"><h3 class="bd b fi z dy jl ea eb jm ed ef dx translated">本文是指针系列文章的第二部分。在上一篇文章中，我们讨论了…的基础</h3></div><div class="jo l"><p class="bd b fp z dy jl ea eb jm ed ef dx translated">vaidhyanathansm.medium.com</p></div></div><div class="jp l"><div class="jw l jr js jt jp ju jv jg"/></div></div></a></div><h2 id="23b5" class="jx jy hi bd jz ka kb kc kd ke kf kg kh iq ki kj kk iu kl km kn iy ko kp kq kr bi translated">什么是树形数据结构？</h2><p id="eb7c" class="pw-post-body-paragraph if ig hi ih b ii ks ik il im kt io ip iq ku is it iu kv iw ix iy kw ja jb jc hb bi translated">树是一种<strong class="ih hj"> <em class="kx">非线性层次数据结构</em> </strong>，在各个领域都有应用。树中最顶端的节点被称为根节点。左边的分支称为<em class="kx">左子树</em>，右边的分支称为<em class="kx">右子树。</em>每个有子节点的节点称为父节点。</p><p id="8543" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">一棵树看起来像这样:</p><figure class="kz la lb lc fd ld er es paragraph-image"><div class="er es ky"><img src="../Images/24f7a0f1c71b23a0359d95605ce96497.png" data-original-src="https://miro.medium.com/v2/resize:fit:840/format:webp/1*lwaDg8aL0XtdEndSDBtyvQ.png"/></div><figcaption class="lf lg et er es lh li bd b be z dx translated">礼貌:极客为极客</figcaption></figure><p id="57ca" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">从上图可以看出，1 是树的根。2 和 3 是父节点 1 的子节点，它们本身分别是 4、5 和 6、7 的父节点。节点 8、9、10、11、13、14 被称为叶节点。</p><h2 id="3e2a" class="jx jy hi bd jz ka kb kc kd ke kf kg kh iq ki kj kk iu kl km kn iy ko kp kq kr bi translated">为什么是树？</h2><ol class=""><li id="cb33" class="lj lk hi ih b ii ks im kt iq ll iu lm iy ln jc lo lp lq lr bi translated">当我们想要存储形成层次结构的信息时，我们需要使用树数据结构。一个很好的例子是计算机上的<strong class="ih hj">文件系统</strong>。</li><li id="1f02" class="lj lk hi ih b ii ls im lt iq lu iu lv iy lw jc lo lp lq lr bi translated">访问树的元素比链表快，但比数组慢。</li></ol><p id="cfc0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">树木的一些应用包括:</strong></p><blockquote class="lx ly lz"><p id="11fa" class="if ig kx ih b ii ij ik il im in io ip ma ir is it mb iv iw ix mc iz ja jb jc hb bi translated">1.数据库中的索引。</p><p id="3684" class="if ig kx ih b ii ij ik il im in io ip ma ir is it mb iv iw ix mc iz ja jb jc hb bi translated">2.路由算法</p><p id="c3ad" class="if ig kx ih b ii ij ik il im in io ip ma ir is it mb iv iw ix mc iz ja jb jc hb bi translated">3.编译器中的语法分析</p></blockquote></div><div class="ab cl md me gp mf" role="separator"><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi"/></div><div class="hb hc hd he hf"><h2 id="ca77" class="jx jy hi bd jz ka kb kc kd ke kf kg kh iq ki kj kk iu kl km kn iy ko kp kq kr bi translated">二叉树</h2><p id="7ac4" class="pw-post-body-paragraph if ig hi ih b ii ks ik il im kt io ip iq ku is it iu kv iw ix iy kw ja jb jc hb bi translated">各种应用中最常用的树是<strong class="ih hj">二叉树</strong>。二叉树是这样一种树，其中每个父树最多有 2 个子树，即。，左边和右边的孩子。树被表示为节点的分层连接，每个节点由以下部分组成:</p><ol class=""><li id="1100" class="lj lk hi ih b ii ij im in iq mk iu ml iy mm jc lo lp lq lr bi translated">数据</li><li id="dd2f" class="lj lk hi ih b ii ls im lt iq lu iu lv iy lw jc lo lp lq lr bi translated">指向左侧子节点的指针</li><li id="e714" class="lj lk hi ih b ii ls im lt iq lu iu lv iy lw jc lo lp lq lr bi translated">指向正确子节点的指针</li></ol><figure class="kz la lb lc fd ld er es paragraph-image"><div role="button" tabindex="0" class="mo mp di mq bf mr"><div class="er es mn"><img src="../Images/f3ded1a3503f6eb6157b2aa4277cd67f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6Df7UHhN_16bat_LcVwABA.png"/></div></div></figure><p id="27fe" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">上图显示了树在内存中的结构。</p><p id="1011" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在让我们看看如何实现一个二叉树数据结构。整个演示过程中使用的语言是<strong class="ih hj"> C++ </strong>。第一步是创建一个节点。</p><figure class="kz la lb lc fd ld"><div class="bz dy l di"><div class="ms mt l"/></div></figure><p id="5256" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在让我们使用上面的节点类创建树结构。</p><figure class="kz la lb lc fd ld"><div class="bz dy l di"><div class="ms mt l"/></div></figure><p id="6c0c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在，我们如何访问元素或遍历树的元素。我们有 3 种遍历方法来完成这个任务。</p><ol class=""><li id="d059" class="lj lk hi ih b ii ij im in iq mk iu ml iy mm jc lo lp lq lr bi translated">有序遍历</li><li id="409c" class="lj lk hi ih b ii ls im lt iq lu iu lv iy lw jc lo lp lq lr bi translated">前序遍历</li><li id="870c" class="lj lk hi ih b ii ls im lt iq lu iu lv iy lw jc lo lp lq lr bi translated">后序遍历</li></ol><p id="015b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">按序遍历</strong></p><p id="904c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在这种类型的遍历中，我们首先遍历左边的子树，然后访问根，然后遍历右边的子树。</p><figure class="kz la lb lc fd ld"><div class="bz dy l di"><div class="ms mt l"/></div></figure><p id="b90a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">前序遍历</strong></p><p id="2069" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在这种类型的遍历中，我们首先访问根，然后遍历左边的子树，然后遍历右边的子树。</p><figure class="kz la lb lc fd ld"><div class="bz dy l di"><div class="ms mt l"/></div></figure><p id="9410" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">后序遍历</strong></p><p id="a6d2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在这种类型的遍历中，我们首先遍历左边的子树，然后遍历右边的子树，然后访问根。</p><figure class="kz la lb lc fd ld"><div class="bz dy l di"><div class="ms mt l"/></div></figure></div><div class="ab cl md me gp mf" role="separator"><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi"/></div><div class="hb hc hd he hf"><h2 id="485a" class="jx jy hi bd jz ka kb kc kd ke kf kg kh iq ki kj kk iu kl km kn iy ko kp kq kr bi translated">二分搜索法树</h2><p id="4b3f" class="pw-post-body-paragraph if ig hi ih b ii ks ik il im kt io ip iq ku is it iu kv iw ix iy kw ja jb jc hb bi translated">现在，让我们来看看一种特殊的二叉树，叫做<strong class="ih hj">二叉查找树(BST) </strong>。如果二叉树满足以下条件，它就有资格成为 BST:</p><ol class=""><li id="2e21" class="lj lk hi ih b ii ij im in iq mk iu ml iy mm jc lo lp lq lr bi translated">节点的左子树只包含键小于该节点键的节点。</li><li id="1c48" class="lj lk hi ih b ii ls im lt iq lu iu lv iy lw jc lo lp lq lr bi translated">节点的右边子树只包含键大于节点键的节点。</li><li id="185e" class="lj lk hi ih b ii ls im lt iq lu iu lv iy lw jc lo lp lq lr bi translated">左侧和右侧的子树都必须是二叉查找树。</li></ol><p id="8e45" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们看看实现。</p><figure class="kz la lb lc fd ld"><div class="bz dy l di"><div class="ms mt l"/></div></figure><p id="4899" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们可以从上面的类定义中看到，有 3 个成员函数，即。，insert()，contains()和 printInorder()。contains()方法用于检查或搜索 BST 中的特定键。</p><p id="d81b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">节点的插入必须在不影响 BST 属性的情况下进行。让我们看看插入是如何进行的。</p><figure class="kz la lb lc fd ld"><div class="bz dy l di"><div class="ms mt l"/></div></figure><p id="8490" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">contains()方法检查 BST 中是否存在特定的键。它返回一个<strong class="ih hj">布尔</strong>值，表明该元素是否被找到。</p><figure class="kz la lb lc fd ld"><div class="bz dy l di"><div class="ms mt l"/></div></figure><p id="e15e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们利用有序遍历来访问和打印树的元素。</p><figure class="kz la lb lc fd ld"><div class="bz dy l di"><div class="ms mt l"/></div></figure><p id="d9f2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">下面给出了测试这些方法工作的示例代码:</p><figure class="kz la lb lc fd ld"><div class="bz dy l di"><div class="ms mt l"/></div></figure><h2 id="8cc2" class="jx jy hi bd jz ka kb kc kd ke kf kg kh iq ki kj kk iu kl km kn iy ko kp kq kr bi translated">练习:</h2><ol class=""><li id="c380" class="lj lk hi ih b ii ks im kt iq ll iu lm iy ln jc lo lp lq lr bi translated">作为练习，尝试实现一个<strong class="ih hj"> delete </strong>函数，该函数将从 BST 中删除指定的元素。</li></ol><p id="5a2a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">希望你喜欢阅读这篇文章！</p><p id="16a8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果您有任何疑问，请在下面的<strong class="ih hj">评论</strong>部分发帖。在<a class="ae mu" href="https://www.linkedin.com/in/vaidhyanathansm/" rel="noopener ugc nofollow" target="_blank"> LinkedIn </a>上与我联系。此外，如果你想看看我开发的惊人的应用程序集，别忘了查看谷歌 Play 商店。</p><p id="5933" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">了解我更多<a class="ae mu" href="https://vaidhyanathansm.tech/" rel="noopener ugc nofollow" target="_blank">在这里</a>。</p><p id="7ed0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">话虽如此，感谢您阅读我的文章和<em class="kx">快乐编码！</em></p></div></div>    
</body>
</html>