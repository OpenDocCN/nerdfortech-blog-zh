<html>
<head>
<title>Social application with Vue.js and GO</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">带有Vue.js和GO的社交应用</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/social-application-with-vue-js-and-go-64978f7c381f?source=collection_archive---------2-----------------------#2021-03-29">https://medium.com/nerd-for-tech/social-application-with-vue-js-and-go-64978f7c381f?source=collection_archive---------2-----------------------#2021-03-29</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><figure class="hh hi ez fb hj hk er es paragraph-image"><div class="er es hg"><img src="../Images/4cdfb643ef90df60dcd8aaa1429ba169.png" data-original-src="https://miro.medium.com/v2/resize:fit:1088/format:webp/1*9RcvJALOdCOUBieIJCCMEg.jpeg"/></div><figcaption class="hn ho et er es hp hq bd b be z dx translated">标志归功于vuejs.org和golang.org</figcaption></figure><div class=""/><div class=""><h2 id="ec61" class="pw-subtitle-paragraph iq hs ht bd b ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh dx translated">使用vue.js和golang创建和服务一个类似twitter的应用程序第8部分:基于令牌的认证</h2></div><p id="7dd2" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">这是本系列的第八部分。在这里检查所有零件:</p><ul class=""><li id="bced" class="ke kf ht jk b jl jm jo jp jr kg jv kh jz ki kd kj kk kl km bi translated"><a class="ae kn" href="https://ivano-dalmasso.medium.com/social-application-with-vue-js-and-go-4e4db0cdde64" rel="noopener">第一部分:设置</a></li><li id="e9bc" class="ke kf ht jk b jl ko jo kp jr kq jv kr jz ks kd kj kk kl km bi translated"><a class="ae kn" href="https://ivano-dalmasso.medium.com/social-application-with-vue-js-and-go-64b3adee8dac" rel="noopener">第二部分:VUE入门</a></li><li id="8e37" class="ke kf ht jk b jl ko jo kp jr kq jv kr jz ks kd kj kk kl km bi translated"><a class="ae kn" href="https://ivano-dalmasso.medium.com/social-application-with-vue-js-and-go-24a1d1e7137d" rel="noopener">第三部分:组件&amp;插槽</a></li><li id="c040" class="ke kf ht jk b jl ko jo kp jr kq jv kr jz ks kd kj kk kl km bi translated"><a class="ae kn" rel="noopener" href="/nerd-for-tech/social-application-with-vue-js-and-go-3a11d506fc38">第4部分:Vuex首次设置</a></li><li id="5b86" class="ke kf ht jk b jl ko jo kp jr kq jv kr jz ks kd kj kk kl km bi translated"><a class="ae kn" rel="noopener" href="/nerd-for-tech/social-application-with-vue-js-and-go-ef364b572422">第5部分:Vuex终结</a></li><li id="6dcf" class="ke kf ht jk b jl ko jo kp jr kq jv kr jz ks kd kj kk kl km bi translated"><a class="ae kn" href="https://ivano-dalmasso.medium.com/social-application-with-vue-js-and-go-a22a1afb76eb" rel="noopener">第六部分:Vuex中的表格和数据</a></li><li id="572f" class="ke kf ht jk b jl ko jo kp jr kq jv kr jz ks kd kj kk kl km bi translated"><a class="ae kn" rel="noopener" href="/nerd-for-tech/social-application-with-vue-js-and-go-d9e563466b66">第七部分:与golang服务器的连接</a></li><li id="af38" class="ke kf ht jk b jl ko jo kp jr kq jv kr jz ks kd kj kk kl km bi translated">第8部分:基于令牌的认证(This)</li><li id="f506" class="ke kf ht jk b jl ko jo kp jr kq jv kr jz ks kd kj kk kl km bi translated"><a class="ae kn" href="https://ivano-dalmasso.medium.com/social-application-with-vue-js-and-go-4d0caa37ddac" rel="noopener">第9部分:存储索引为DB的认证令牌</a></li></ul><p id="3faf" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">在本课中，我们将在客户端vue应用程序和go服务器中添加一个身份验证层。另外，我们还将添加端点来获得单个用户，该用户将用于vue页面中的“用户”页面。</p><p id="0d0e" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">我们将在本次会议中更新前端和后端，您可以在这里找到代码:</p><ul class=""><li id="da86" class="ke kf ht jk b jl jm jo jp jr kg jv kh jz ki kd kj kk kl km bi translated"><a class="ae kn" href="https://github.com/idalmasso/go-vue-tutorial-backend/releases/tag/v0.8" rel="noopener ugc nofollow" target="_blank">后端</a></li><li id="689c" class="ke kf ht jk b jl ko jo kp jr kq jv kr jz ks kd kj kk kl km bi translated"><a class="ae kn" href="https://github.com/idalmasso/go-vue-tutorial-frontend/releases/tag/v0.8" rel="noopener ugc nofollow" target="_blank">前端</a></li></ul></div><div class="ab cl kt ku gp kv" role="separator"><span class="kw bw bk kx ky kz"/><span class="kw bw bk kx ky kz"/><span class="kw bw bk kx ky"/></div><div class="hb hc hd he hf"><h2 id="1fcb" class="la lb ht bd lc ld le lf lg lh li lj lk jr ll lm ln jv lo lp lq jz lr ls lt lu bi translated">管理简单的基于令牌的身份验证</h2><p id="aba4" class="pw-post-body-paragraph ji jj ht jk b jl lv iu jn jo lw ix jq jr lx jt ju jv ly jx jy jz lz kb kc kd hb bi translated">让我们开始添加一个文件，我们将在其中管理关于身份验证的路由。添加一个文件“<em class="ma">/endpoints/auth . go”</em>。在这里，我们将为用户插入注册、登录和注销操作的所有逻辑。</p><p id="6ec8" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">密码散列的生成和检查将使用标准库<em class="ma">bcrypt</em>(“<em class="ma">golang.org/x/crypto/bcrypt</em>”)来完成，而对于jwt令牌的创建和检查，我们将使用<em class="ma">dgrijalva/jwt-go</em>(“<em class="ma">github.com/dgrijalva/jwt-go</em>”)，因此只需导入它们。</p><p id="d672" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">请注意，令牌的创建需要使用服务器端机密，因此我们可以创建一个函数来从环境变量中获取它，如下所示(在"<em class="ma"> endpoints/utils.go </em>"):</p><pre class="mb mc md me fd mf mg mh mi aw mj bi"><span id="08c1" class="la lb ht mg b fi mk ml l mm mn">func getSecret() string{<br/> secret:=os.Getenv("ACCESS_SECRET")<br/> if secret==""{<br/>  //That's surely a big secret this way...<br/>  secret="sdmalncnjsdsmf"<br/> }<br/> return secret<br/>}</span></pre><p id="c0ad" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">很明显，如果这个秘密是空的，一个真实的服务器应该会在我们的真实世界中惊慌失措并抛出一个错误，但是这对于我们现在的情况来说是可以的。</p><p id="1b2d" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">现在，在auth.go中创建一个结构，用于将用户名/密码数据传递到端点，以便创建用户和登录:</p><pre class="mb mc md me fd mf mg mh mi aw mj bi"><span id="4963" class="la lb ht mg b fi mk ml l mm mn">type User struct{<br/>  Username string `json:"username"`<br/>  Password string `json:"password"`<br/>}</span></pre><p id="cff3" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">然后创建两个端点(注意，我们还创建了一个用户数组作为“内存中”数据库，现在)和一个创建新令牌的方法:</p><pre class="mb mc md me fd mf mg mh mi aw mj bi"><span id="54de" class="la lb ht mg b fi mk ml l mm mn">var users map[string][]byte = make(map[string][]byte)<br/>var idxUsers int =0<br/><br/>//getTokenUserPassword returns a jwt token for a user if the //password is ok<br/>func getTokenUserPassword(w http.ResponseWriter, r *http.Request) {<br/>  var u User<br/>  err:=json.NewDecoder(r.Body).Decode(&amp;u)<br/>  if err!=nil{<br/>    http.Error(w, "cannot decode username/password struct",http.StatusBadRequest)<br/>    return<br/>  }<br/>  //here I have a user!<br/>  //Now check if exists <br/>  passwordHash, found:= users[u.Username]<br/>  if !found{<br/>    http.Error(w, "Cannot find the username", http.StatusNotFound)<br/>  }	<br/>  err=bcrypt.CompareHashAndPassword(passwordHash, []byte(u.Password))<br/>  if err!=nil{<br/>    return<br/>  }<br/>  token, err:=createToken(u.Username)<br/>  if err!=nil{<br/>    http.Error(w, "Cannot create token", http.StatusInternalServerError)<br/>    return<br/>  }<br/>  sendJSONResponse(w, struct {Token string `json:"token"`}{ token })	<br/>}<br/><br/>func createUser(w http.ResponseWriter, r *http.Request){<br/>  var u User<br/>  err := json.NewDecoder(r.Body).Decode(&amp;u)<br/>  if err!=nil{<br/>    http.Error(w, "Cannot decode request", http.StatusBadRequest)<br/>    return<br/>  }<br/>  if _, found:= users[u.Username]; found{<br/>    http.Error(w,"User already exists", http.StatusBadRequest)<br/>    return<br/>  }<br/>  //If I'm here-&gt; add user and return a token<br/>  value, err := bcrypt.GenerateFromPassword([]byte(u.Password), bcrypt.DefaultCost)<br/>  users[u.Username]=value<br/>  token, err:=createToken(u.Username)<br/>  if err!=nil{<br/>    http.Error(w, "Cannot create token", http.StatusInternalServerError)<br/>    return<br/>  }	<br/>  sendJSONResponse(w, struct {Token string `json:"token"`}{ token })<br/>}</span><span id="3924" class="la lb ht mg b fi mo ml l mm mn">func createToken(username string) (string, error) {<br/>  var err error<br/>  //Creating Access Token  <br/>  atClaims := jwt.MapClaims{}<br/>  atClaims["authorized"] = true<br/>  atClaims["username"] = username<br/>  atClaims["exp"] = time.Now().Add(time.Minute * 15).Unix()<br/>	at := jwt.NewWithClaims(jwt.SigningMethodHS256, atClaims)<br/>	secret:= getSecret()<br/>  token, err := at.SignedString([]byte(secret))<br/>  if err != nil {<br/>     return "", err<br/>  }<br/>  return token, nil<br/>}</span></pre><p id="7c64" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">“createToken”函数获取一个字符串username，并创建一个带有一些声明的令牌，例如，该令牌应该完全由该用户使用，过期时间为15分钟。然后，该函数返回一个使用应用程序秘密创建的令牌，该令牌可用于15分钟的身份验证(但我们仍需实现这一点)。</p><p id="95e4" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">其他两个函数实际上非常相似:都将请求体解码为我们之前创建的json对象类型，然后<em class="ma"> createUser </em>尝试将其添加到“数据库”中，而<em class="ma"> getTokenUserPassword </em>实际上检查用户是否存在。然后，如果所有这些检查都成功返回，这些函数将返回一个带有新创建的令牌的“JSONified”对象。</p><p id="8770" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">这两个函数实际上是站点登录和注册函数的处理程序，所以只需在utils.go文件的<em class="ma"> AddRouterEndpoints </em>函数中添加下面两行，将它们绑定到实际的路由:</p><pre class="mb mc md me fd mf mg mh mi aw mj bi"><span id="ba88" class="la lb ht mg b fi mk ml l mm mn">r.HandleFunc("/api/auth/login",<br/>             getTokenUserPassword).Methods("POST") r.HandleFunc("/api/auth/create-user", createUser).Methods("POST")</span></pre><p id="fc80" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">我们现在有了一种实际注册和登录用户的方法。这其实是没有用的，直到我们屏蔽了服务器端的某些部分的访问。</p><p id="5517" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">让我们解决这个问题，将这两个方法添加到<em class="ma"> utils.go </em>文件中:</p><pre class="mb mc md me fd mf mg mh mi aw mj bi"><span id="960f" class="la lb ht mg b fi mk ml l mm mn">func checkTokenHandler(next http.HandlerFunc) http.HandlerFunc{<br/>  return func(w http.ResponseWriter, r *http.Request) {<br/>    header := r.Header.Get("Authorization")<br/>    bearerToken := strings.Split(header, " ")<br/>    if len(bearerToken)!=2{<br/>      http.Error(w, "Cannot read token", http.StatusBadRequest)<br/>      return<br/>    }<br/>    if bearerToken[0] != "Bearer"{<br/>      http.Error(w, "Error in authorization token. it needs to be in form of 'Bearer &lt;token&gt;'", http.StatusBadRequest)<br/>      return<br/>    }		<br/>    token, ok :=checkToken(bearerToken[1]); <br/>    if !ok{<br/>      http.Error(w, "Unauthorized", http.StatusUnauthorized)<br/>      return<br/>    }<br/>    claims, ok := token.Claims.(jwt.MapClaims)<br/>    if ok &amp;&amp; token.Valid {	<br/>      username, ok := claims["username"].(string)<br/>      if !ok {<br/>        http.Error(w, "Unauthorized", http.StatusUnauthorized)<br/>        return <br/>      }<br/>      //check if username actually exists<br/>      if _, ok := users[username]; !ok{<br/>        http.Error(w, "Unauthorized, user not exists", http.StatusUnauthorized)<br/>        return <br/>      } <br/>      //Set the username in the request, so I will use it in check after!<br/>      context.Set(r, "username", username)<br/>    }<br/>    next(w, r)<br/>  }<br/>}<br/><br/>func checkToken (tokenString string) (*jwt.Token, bool) {<br/>  token, err := jwt.Parse(tokenString, func(token *jwt.Token) (interface{}, error) {<br/>    if _, ok := token.Method.(*jwt.SigningMethodHMAC); !ok {<br/>      return nil, fmt.Errorf("unexpected signing method: %v", token.Header["alg"])<br/>    }<br/>    return []byte(getSecret()), nil<br/>  })<br/>  if err!=nil{<br/>    return nil, false<br/>  }<br/>  if _, ok := token.Claims.(jwt.Claims); !ok &amp;&amp; !token.Valid {<br/>    return nil, false<br/>  }<br/>  return token, true<br/>}</span></pre><p id="a82f" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">函数获取一个字符串令牌作为输入，并返回一个jwt。验证了其默认值后，返回令牌对象。</p><p id="d5ec" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">相反，<em class="ma"> checkTokenHandler </em>返回一个实际的http处理函数，它可以在路由的实际处理程序“之前”使用。在这个处理程序中，它从"<em class="ma">授权</em>"报头中获取令牌，它可以很容易地检查这个报头的格式(它必须是"无记名&lt;令牌&gt;")。然后，它得到jwt。来自<em class="ma"> checkToken </em>函数的令牌对象，并对数据库中令牌中用户名的存在进行额外的控制。然后，它在请求的上下文中设置用户名，因此我们也可以在实际请求中使用它，并调用我们想要调用的实际http处理程序，该处理程序被传递给<em class="ma"> checkTokenHandler </em>函数。</p><p id="59e1" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">请注意，如果任何检查失败，则不会调用真正的路由，并且会向客户端返回一个错误。我们现在只需使用这种方法，在<em class="ma"> addRouterEndpoints </em>中修饰所有我们想要通过认证过程“保护”的路由，以获得一些保护:</p><pre class="mb mc md me fd mf mg mh mi aw mj bi"><span id="9a61" class="la lb ht mg b fi mk ml l mm mn">func AddRouterEndpoints(r *mux.Router) *mux.Router {<br/>...<br/>  r.HandleFunc("/api/posts",checkTokenHandler(addPost))<br/>    .Methods("POST")<br/>  r.HandleFunc("/api/posts/{POST_ID}",checkTokenHandler(deletePost))<br/>    .Methods("DELETE")<br/>  r.HandleFunc("/api/posts/{POST_ID}/comments",<br/>    checkTokenHandler(addComment)).Methods("POST")<br/>...</span></pre><p id="3c89" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">这三个api现在实际上受到令牌认证保护。</p><p id="aef1" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">用户将不得不使用这个api发送一个包含有效用户的令牌，以便实际添加帖子。这里还有一个小问题，如果一个用户“A”用作者用户“B”发送了一个帖子，系统仍然接受它，所以让我们也做这个小修正，在posts.go文件中，添加以下函数:</p><pre class="mb mc md me fd mf mg mh mi aw mj bi"><span id="1562" class="la lb ht mg b fi mk ml l mm mn">func isUsernameContextOk(username string, r *http.Request) bool {<br/>	usernameCtx, ok:=context.Get(r, "username").(string)<br/>	if !ok{<br/>		return false<br/>	}<br/>	if usernameCtx!=username{<br/>		return false<br/>	}<br/>	return true<br/>}</span></pre><p id="bd53" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">这只是从请求中获取用户名，并将其与我们想要检查的用户名进行比较。我们可以在帖子(或评论)的反序列化之后，在“<em class="ma"> addPost </em>”、“<em class="ma"> deletePost </em>”和“<em class="ma"> addComment </em>”这三个函数中调用这个函数，以检查帖子的用户是否是请求中的实际用户，如下所示:</p><pre class="mb mc md me fd mf mg mh mi aw mj bi"><span id="a631" class="la lb ht mg b fi mk ml l mm mn">if !isUsernameContextOk(post.Username, r){<br/>  http.Error(w, "Cannot manage post for another user", http.StatusUnauthorized)<br/>  return <br/>}</span></pre><p id="3820" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">关于身份验证，可以做的最后一件事是提供一种方法，如果令牌快要过期，可以通过使用旧令牌获取新令牌来刷新令牌:</p><pre class="mb mc md me fd mf mg mh mi aw mj bi"><span id="25c4" class="la lb ht mg b fi mk ml l mm mn">func getTokenByToken(w http.ResponseWriter, r *http.Request){<br/>  //Here I already have the token checked... Just get the username from Request context<br/>  username, ok :=context.Get(r,"username").(string)<br/>  if !ok{<br/>    http.Error(w, "Cannot check username",  http.StatusInternalServerError)<br/>    return<br/>  }<br/>  token, err:=createToken(username)<br/>  if err!=nil{<br/>    http.Error(w, "Cannot create token", http.StatusInternalServerError)<br/>    return<br/>  }<br/>  sendJSONResponse(w, struct {Token string}{ token })<br/>}</span></pre><p id="6624" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">并在<em class="ma"> addRouterEndpoints </em>中实际绑定它</p><pre class="mb mc md me fd mf mg mh mi aw mj bi"><span id="c6be" class="la lb ht mg b fi mk ml l mm mn">r.HandleFunc("/api/auth/token",checkTokenHandler(getTokenByToken))<br/>  .Methods("GET")</span></pre><p id="bb06" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">显然，这实际上不是真实世界的场景。实际上，这应该与双令牌身份验证/授权风格一起使用，因此一个具有长到期时间的令牌用于身份验证，另一个令牌用于获得具有短到期时间的授权令牌。这只是关于如何做的一段演示性代码。</p><p id="50e5" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">作为本教程章节的最后一件事，我们可以添加一个受令牌认证保护的api端点，以获取用户数据显示在用户页面中。</p><p id="4f9a" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">只需添加一个新文件'<em class="ma"> /endpoints/users.go </em>，并在那里设置端点的代码:</p><pre class="mb mc md me fd mf mg mh mi aw mj bi"><span id="0e0a" class="la lb ht mg b fi mk ml l mm mn">func getUser(w http.ResponseWriter, r *http.Request) {<br/>  log.Println("getuser called")<br/>  vars := mux.Vars(r)<br/>  user, ok := vars["USERNAME"]<br/>  if !ok {<br/>    http.Error(w, "Cannot find username in request",http.StatusBadRequest)<br/>    return<br/>  }<br/>  if _, ok :=users[user]; ok{<br/>    sendJSONResponse(w, <br/>    struct{Username string `json:"username"`; <br/>       Description string `json:"description"` }{user ,  ""})<br/>    return<br/>  }<br/>  http.Error(w, "Cannot find user", http.StatusNotFound)<br/>}</span></pre><p id="e429" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">并使用我们之前使用的修饰处理程序来检查<em class="ma"> addRouterEnpoints </em>函数中的认证</p><pre class="mb mc md me fd mf mg mh mi aw mj bi"><span id="cafd" class="la lb ht mg b fi mk ml l mm mn">r.HandleFunc("/api/users/{USERNAME}",<br/>  checkTokenHandler(getUser)).Methods("GET")</span></pre><p id="686f" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">现在我们必须更新客户端vue应用程序来使用这些新功能。</p></div><div class="ab cl kt ku gp kv" role="separator"><span class="kw bw bk kx ky kz"/><span class="kw bw bk kx ky kz"/><span class="kw bw bk kx ky"/></div><div class="hb hc hd he hf"><h2 id="2633" class="la lb ht bd lc ld le lf lg lh li lj lk jr ll lm ln jv lo lp lq jz lr ls lt lu bi translated">客户端应用程序中的身份验证</h2><p id="fef2" class="pw-post-body-paragraph ji jj ht jk b jl lv iu jn jo lw ix jq jr lx jt ju jv ly jx jy jz lz kb kc kd hb bi translated">让我们开始更新客户机应用程序，以便在服务器上使用身份验证。首先编辑"<em class="ma">store/authStore/index . js</em>"文件，删除实际的默认用户名，并在状态中添加一个新的令牌空字符串。然后，我们将不得不在登录和注销突变中操纵这两种状态，如下所示:</p><pre class="mb mc md me fd mf mg mh mi aw mj bi"><span id="a712" class="la lb ht mg b fi mk ml l mm mn">LOGIN(state, { username, token }) {<br/>   state.user.loggedIn = true;<br/>   state.user.username = username;<br/>   state.user.token = token;<br/>},<br/>LOGOUT(state) {<br/>   state.user.loggedIn = false;<br/>   state.user.username = "";<br/>   state.user.token = "";<br/>}</span></pre><p id="e0bb" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">然后，我们只需更新实际操作，并确保调用正确的API(注意:注销操作实际上不会使服务器端的令牌无效，事实上，我们现在并没有管理服务器中的“令牌状态”,所以它只是从内存中删除令牌，并在客户端应用程序中清理用户)</p><pre class="mb mc md me fd mf mg mh mi aw mj bi"><span id="caa8" class="la lb ht mg b fi mk ml l mm mn">async login(context, { username, password }) {<br/>    return fetch("http://localhost:3000/api/auth/login", {<br/>      method: "POST",<br/>      body: JSON.stringify({<br/>                             username: username, <br/>                             password: password })<br/>      })<br/>      .then(response =&gt; {<br/>        if (!response.ok) {<br/>          throw new Error("Cannot login!");<br/>        }<br/>        return response.json();<br/>      }).then(data =&gt; {<br/>         context.commit("LOGIN",<br/>              { username: username, token: data.token });<br/>      }).catch(error =&gt; {<br/>          context.commit("LOGOUT");<br/>          throw error;<br/>        });<br/>    },<br/>async logout(context) {<br/>    context.commit("LOGOUT");<br/>},<br/>async signup(context, { username, password }) {<br/>    return fetch("http://localhost:3000/api/auth/create-user", {<br/>      method: "POST",<br/>      body: JSON.stringify(<br/>          { username: username, password: password })<br/>      }).then(response =&gt; {<br/>        if (!response.ok) {<br/>          throw new Error("Cannot signup!");<br/>        }<br/>        return response.json();<br/>      }).then(data =&gt; {<br/>        context.commit("LOGIN", <br/>              { username: username, token: data.token });<br/>      }).catch(error =&gt; {<br/>        context.commit("LOGOUT");<br/>        error.read().then((data, done) =&gt; {<br/>            throw Error(data);<br/>        });<br/>      });<br/>    }</span></pre><p id="9f77" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">请注意，现在任何操作都调用正确的API，如果成功，并且响应正常，它将使用调用返回的数据调用正确的变异，否则将抛出一个错误(因此操作的调用者可以相应地采取行动)。</p><p id="0839" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">最后，添加一个额外的getter，用于其他商店中的其他api:</p><pre class="mb mc md me fd mf mg mh mi aw mj bi"><span id="9796" class="la lb ht mg b fi mk ml l mm mn">getTokenHeader(state) {<br/>  return "Bearer " + state.user.token;<br/>}</span></pre><p id="7658" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">使用这个getter，其他商店将能够为调用设置正确的令牌。让我们对posts store这样做:这实际上非常简单，在我们保护的三个api中，只需更新fetch的headers参数，如下所示:</p><pre class="mb mc md me fd mf mg mh mi aw mj bi"><span id="397d" class="la lb ht mg b fi mk ml l mm mn">headers: {<br/>     "Content-Type": "application/json",<br/>     Authorization: context.rootGetters["auth/getTokenHeader"]        },</span></pre><p id="e35e" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">现在让我们也更新用户存储，删除状态中的users数组的初始化，并创建一个可以实际调用ADD_USER变异的操作</p><pre class="mb mc md me fd mf mg mh mi aw mj bi"><span id="9f2c" class="la lb ht mg b fi mk ml l mm mn">state: {<br/>    loadedUsers: []<br/>  },<br/>  .....<br/>  actions: {<br/>    async addUser(context, { username }) {<br/>      return fetch("http://localhost:3000/api/users/" + username, {<br/>        headers: {<br/>          Authorization: context.rootGetters["auth/getTokenHeader"]<br/>        }<br/>      })<br/>        .then(response =&gt; {<br/>          if (!response.ok) throw new Error("Cannot get user");<br/>          return response.json();<br/>        })<br/>        .then(data =&gt; {<br/>          context.commit("ADD_USER", data);<br/>        })<br/>        .catch(error =&gt; {<br/>          console.log(error);<br/>          throw error;<br/>        });<br/>    }</span></pre><p id="65c7" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">这实际上与我们对帖子所做的一样。</p><p id="c854" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">这些更新将自行工作，几乎不需要对组件逻辑进行更新。现在，让我们将登录页面更改为实际的登录/注册工作页面。像这样更新<em class="ma"> views/Login.vue </em>组件:</p><pre class="mb mc md me fd mf mg mh mi aw mj bi"><span id="8517" class="la lb ht mg b fi mk ml l mm mn">&lt;template&gt;<br/>  &lt;div class="content"&gt;<br/>    &lt;base-card&gt;<br/>      &lt;form @submit.prevent&gt;<br/>        &lt;label for="username"&gt;Username&lt;/label&gt;<br/>        &lt;input id="username" type="text" v-model="username" /&gt;<br/>        &lt;label for="password"&gt;Password&lt;/label&gt;<br/>        &lt;input id="password" type="password" v-model="password" /&gt;<br/>        &lt;button @click="loginButtonClicked"&gt;{{ buttonString }}&lt;/button&gt;<br/>        &lt;p v-if="error"&gt;{{ error }}&lt;/p&gt;<br/>        &lt;a href="#" @click.prevent="toggleLogin"&gt;{{ textLoginString }}&lt;/a&gt;<br/>      &lt;/form&gt;<br/>    &lt;/base-card&gt;<br/>  &lt;/div&gt;<br/>&lt;/template&gt;<br/><br/>&lt;script&gt;<br/>import { mapActions } from "vuex";<br/>import BaseCard from "../components/UI/BaseCard.vue";<br/>export default {<br/>  components: { BaseCard },<br/>  data() {<br/>    return {<br/>      loginSelected: true,<br/>      username: "",<br/>      password: "",<br/>      error: ""<br/>    };<br/>  },<br/>  methods: {<br/>    ...mapActions({ login: "auth/login", signup: "auth/signup" }),<br/>    loginButtonClicked() {<br/>      if (this.loginSelected) {<br/>        this.login({ username: this.username, password: this.password })<br/>          .then(() =&gt; {<br/>            this.$router.push({ name: "Posts" });<br/>          })<br/>          .catch(error =&gt; {<br/>            this.error = error;<br/>          });<br/>      } else {<br/>        this.signup({ username: this.username, password: this.password })<br/>          .then(() =&gt; {<br/>            this.$router.push({ name: "Posts" });<br/>          })<br/>          .catch(error =&gt; {<br/>            this.error = error;<br/>          });<br/>      }<br/>    },<br/>    toggleLogin() {<br/>      this.loginSelected = !this.loginSelected;<br/>    }<br/>  },<br/>  computed: {<br/>    buttonString() {<br/>      if (this.loginSelected) {<br/>        return "LOGIN";<br/>      } else {<br/>        return "SIGNUP";<br/>      }<br/>    },<br/>    textLoginString() {<br/>      if (this.loginSelected) {<br/>        return "Signup instead";<br/>      } else {<br/>        return "Login instead";<br/>      }<br/>    }<br/>  }<br/>};<br/>&lt;/script&gt;</span></pre><p id="5ff3" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">该页面将显示一个登录或注册请求，我们将把这个选择存储在由“toggleLogin”方法设置的“loginSelected”变量中。登录和注册操作实际上与mapActions绑定在一起，按钮单击事件实际上触发了其中一个，查看实际的“loginSelected”值。现在，当用户注册时，实际的应用程序身份验证存储调用API并创建新用户。这同样适用于登录。</p><p id="83f0" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">在User.vue视图中，我们可以调用组件挂接中的addUser:</p><pre class="mb mc md me fd mf mg mh mi aw mj bi"><span id="69fc" class="la lb ht mg b fi mk ml l mm mn">mounted() {<br/>    this.$store.dispatch("users/addUser", {username: this.userid});  <br/>}</span></pre><p id="02ad" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">当组件以用户id打开时，它将调用api获取该用户的详细信息，并将其添加到存储中。</p><p id="3088" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">同样，在SinglePost组件中，只需更新delete按钮，使其只显示经过身份验证的实际用户的帖子，如下所示:</p><pre class="mb mc md me fd mf mg mh mi aw mj bi"><span id="73aa" class="la lb ht mg b fi mk ml l mm mn">&lt;button        <br/>    v-if="loggedIn &amp;&amp; currentUser.username === post.username"<br/>    class="delete-button"<br/>    @click.prevent="deletePost"&gt;</span></pre><p id="0c86" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">最后一个更新，让我们稍微改变一下应用程序栏，这样当注销按钮被点击时，它会自动重定向到登录页面:</p><pre class="mb mc md me fd mf mg mh mi aw mj bi"><span id="3a40" class="la lb ht mg b fi mk ml l mm mn">logoutButtonClicked() {<br/>      this.logout().then(() =&gt; {<br/>        this.$router.push({ name: "Login" });<br/>      });<br/>    }</span></pre><p id="3aef" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">现在应用程序开始成形，任何用户都可以注册，添加一些帖子，然后删除自己的帖子，并看到其他用户。此外，我们还设置了一些条件，当用户可以执行一些操作时，以及当他没有被授权时(即，我们决定任何人都可以看到帖子列表，但只有登录的用户可以看到其他用户)。</p><p id="44b0" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">请注意，实际上每15分钟就会有一个用户被注销，解决这个问题的一个好方法是在客户端中定期自动更新令牌。</p><p id="8c29" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">下一个重要步骤是实际使用数据库而不是服务器端的阵列来存储我们的数据，然后我们的应用程序将几乎完全正常工作，但在此之前，我们将在用户浏览器的indexedDB中保存身份验证数据。</p></div></div>    
</body>
</html>