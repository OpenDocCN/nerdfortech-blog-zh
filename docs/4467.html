<html>
<head>
<title>Why I wrote my own serialization package for Dart/Flutter.</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">为什么我要为 Dart/Flutter 编写自己的序列化包。</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/why-i-wrote-my-own-serialization-package-for-dart-flutter-dd9d3f08d324?source=collection_archive---------4-----------------------#2021-07-22">https://medium.com/nerd-for-tech/why-i-wrote-my-own-serialization-package-for-dart-flutter-dd9d3f08d324?source=collection_archive---------4-----------------------#2021-07-22</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="2729" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">当你用 Flutter 编写了一个连接到某种 API 的应用程序时，你可能至少遇到过一次 json 序列化。如果不是，那么 json 序列化就是将数据模型转换成有效的 json，并从服务器接收或发送数据，如下例所示:</p><pre class="jd je jf jg fd jh ji jj jk aw jl bi"><span id="a3ad" class="jm jn hi ji b fi jo jp l jq jr">class Person { <br/>  String name;<br/>  int age;<br/>  Person(this.name, this.age);<br/>}</span><span id="3a4c" class="jm jn hi ji b fi js jp l jq jr">// turn this<br/>var person = Person("Thomas", 23); <br/>// into this<br/>var json = '{"name": "Thomas", "age": 23}';</span></pre><p id="83a6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在我的第一个应用程序中，我实际上是手动完成的…这是一个乏味的过程。对于每个类，您必须定义<code class="du jt ju jv ji b">fromMap</code>和<code class="du jt ju jv ji b">toMap</code>方法，创建或解析原始的<code class="du jt ju jv ji b">Map</code>，然后使用 Dart SDK 的一些内置函数(<code class="du jt ju jv ji b">jsonDecode</code>和<code class="du jt ju jv ji b">jsonEncode</code>)将它们转换成 json 字符串。</p><pre class="jd je jf jg fd jh ji jj jk aw jl bi"><span id="dc23" class="jm jn hi ji b fi jo jp l jq jr">class Person {<br/>  ...</span><span id="4ad0" class="jm jn hi ji b fi js jp l jq jr">  factory Person.fromMap(Map&lt;String, dynamic&gt; map) {<br/>    return Person(map["name"], map["age"]);<br/>  }</span><span id="db63" class="jm jn hi ji b fi js jp l jq jr">  Map&lt;String, dynamic&gt; toMap() {<br/>    return {"name": this.name, "age": this.age};<br/>  }<br/>}</span></pre><p id="3d0f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这使得每一个数据类都膨胀起来，尤其是拥有 10 个或更多属性的类。您会发现大多数时候这些实用函数比实际的类本身占用更多的代码行。此外，如果您希望反序列化是类型安全的，并处理带有有意义的错误消息的无效 json 对象，您将不得不投入更多的工作。</p><p id="e5e6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">此外，每次更改任何类属性时，都必须调整映射函数。</p><p id="e3b8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我通常更喜欢手动编写代码，而不是对所有事情都使用包，但在这种情况下，这只会增加不必要的重复工作，污染您的代码库，并增加维护成本。</p><figure class="jd je jf jg fd jx er es paragraph-image"><div role="button" tabindex="0" class="jy jz di ka bf kb"><div class="er es jw"><img src="../Images/4c2e8cf00c3cdc5531d3d5bd4fbbe878.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*wUU-2Q2_WjCTzvMt"/></div></div><figcaption class="ke kf et er es kg kh bd b be z dx translated">照片由<a class="ae ki" href="https://unsplash.com/@elisa_ventur?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Elisa Ventur </a>在<a class="ae ki" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure></div><div class="ab cl kj kk gp kl" role="separator"><span class="km bw bk kn ko kp"/><span class="km bw bk kn ko kp"/><span class="km bw bk kn ko"/></div><div class="hb hc hd he hf"><h2 id="4cec" class="jm jn hi bd kq kr ks kt ku kv kw kx ky iq kz la lb iu lc ld le iy lf lg lh li bi translated">所以让我们来看看更聪明的方法:</h2><p id="db2b" class="pw-post-body-paragraph if ig hi ih b ii lj ik il im lk io ip iq ll is it iu lm iw ix iy ln ja jb jc hb bi translated">总体思路很简单，您可能已经想到了这一点:让某个算法根据类的属性计算出如何进行序列化。在 Flutter 中，这是通过代码生成(也称为元编程)来完成的，其中一个脚本分析你的代码，并生成与它一起使用的其他代码。</p><p id="4380" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">对于 Flutter，或者更一般的 Dart，当然已经有现成的包可以实现 json 序列化。最受欢迎的是</p><ul class=""><li id="7b53" class="lo lp hi ih b ii ij im in iq lq iu lr iy ls jc lt lu lv lw bi translated"><a class="ae ki" href="https://pub.dev/packages/json_serializable" rel="noopener ugc nofollow" target="_blank"><strong class="ih hj"><em class="lx">JSON _ serializable</em></strong></a>，1160+喜欢上 pub.dev</li><li id="a19b" class="lo lp hi ih b ii ly im lz iq ma iu mb iy mc jc lt lu lv lw bi translated"><a class="ae ki" href="https://pub.dev/packages/dart_json_mapper" rel="noopener ugc nofollow" target="_blank"><strong class="ih hj"><em class="lx">dart _ JSON _ mapper</em></strong></a>，pub.dev 上 130+赞</li></ul><p id="872d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">随着一些更小的软件包，这两个共享了大量的用户，第一个甚至是谷歌团队自己制作的最受欢迎的。所以，当看这些数字时，有一些很强的选项可供选择，对吗？</p><p id="c519" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我不会说这些包本身不好，它们实际上在大多数用例中工作得很好，并且做了它们应该做的事情。但是，当我同时使用这两个工具时，总会有一些我不喜欢的或大或小的东西，或者一些不支持的用例——至少没有一些大的变通方法。</p><p id="8c40" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">总的来说足够了，以至于我有再做一遍的冲动。这是我的第一个飞镖包裹:</p><div class="md me ez fb mf mg"><a href="https://pub.dev/packages/dart_mappable" rel="noopener  ugc nofollow" target="_blank"><div class="mh ab dw"><div class="mi ab mj cl cj mk"><h2 class="bd hj fi z dy ml ea eb mm ed ef hh bi translated">dart _ mappable | Dart 包</h2><div class="mn l"><h3 class="bd b fi z dy ml ea eb mm ed ef dx translated">想象一个映射和序列化包:没有讨厌的样板代码，没有缩小/丑陋的生成文件，没有…</h3></div><div class="mo l"><p class="bd b fp z dy ml ea eb mm ed ef dx translated">公共开发</p></div></div><div class="mp l"><div class="mq l mr ms mt mp mu kc mg"/></div></div></a></div><p id="37fd" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我试图把两个包中最好的部分放在一起，去掉我不喜欢的部分，并加入一些我自己的魔法来创建这个包。</p><p id="208f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">因此，让我们来谈谈我认为这些软件包没有那么好的地方，以及我如何解决一些核心问题。</p></div><div class="ab cl kj kk gp kl" role="separator"><span class="km bw bk kn ko kp"/><span class="km bw bk kn ko kp"/><span class="km bw bk kn ko"/></div><div class="hb hc hd he hf"><h1 id="8504" class="mv jn hi bd kq mw mx my ku mz na nb ky nc nd ne lb nf ng nh le ni nj nk lh nl bi translated">丑陋的代码</h1><p id="dd63" class="pw-post-body-paragraph if ig hi ih b ii lj ik il im lk io ip iq ll is it iu lm iw ix iy ln ja jb jc hb bi translated">我把这作为第一点，因为有些人可能不认为代码风格是一个重要的因素。谁在乎代码是否好看，对吗？不对。我猜说这种话的人从来没有在大型代码库项目中工作过，或者在大型时间框架中工作过，或者在中型到大型团队中工作过。也许是一个从来没有自己写过一行代码的产品所有者会说的话。</p><p id="9787" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">好的代码确实有所不同。丑陋的样板代码糟透了，还有语言黑客或任何奇怪的语法。我不想为了使用序列化包而损害我的代码库，也不想被迫以一种奇怪的方式编写我的类。</p><p id="1c71" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">对于<em class="lx"> json_serializable </em>，这意味着没有样板代码，尤其是没有美元符号或私有混合符号(<code class="du jt ju jv ji b">_$MyMixin</code>🤢).</p><p id="de69" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">相比之下，我喜欢<em class="lx"> dart_json_mapper </em>使用一些简单的调用进行编码和解码，而没有任何样板代码。因此，您会注意到我的包的面向公众的 API 与来自<em class="lx"> dart_json_mapper </em>的 API 非常相似。</p><pre class="jd je jf jg fd jh ji jj jk aw jl bi"><span id="399b" class="jm jn hi ji b fi jo jp l jq jr">// deserialize json to type Person<br/>Person person = Mapper.fromJson(json);</span><span id="d9e9" class="jm jn hi ji b fi js jp l jq jr">// serialize a person to json<br/>String json = Mapper.toJson(person);</span></pre><h1 id="1a7d" class="mv jn hi bd kq mw nm my ku mz nn nb ky nc no ne lb nf np nh le ni nq nk lh nl bi translated">丑陋的代码</h1><p id="2fa2" class="pw-post-body-paragraph if ig hi ih b ii lj ik il im lk io ip iq ll is it iu lm iw ix iy ln ja jb jc hb bi translated">又来了？是的，但是不同。对我来说，代码的生成部分仍然是代码库的一部分。对我来说，重要的是我能够阅读和理解生成的代码，因为我重视任何其他具有良好代码质量的包。我不会接受难看的或缩小的生成代码，在那里我不知道发生了什么。我不得不相信有一个潜在的魔法在起作用，它只是做它应该做的。</p><p id="5e39" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">相反，我喜欢检查生成的代码并弄清楚它是如何工作的。</p><p id="88e4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">对于这一点，<em class="lx"> json_serializable </em>是明显的赢家，因为它为每个类生成可读的函数。<em class="lx">另一方面，dart_json_mapper </em>依赖于<a class="ae ki" href="https://pub.dev/packages/reflectable" rel="noopener ugc nofollow" target="_blank"> <em class="lx"> reflectable </em> </a>并使用反射来分析你的类并解析或构建 json。因为这是在运行时完成的，所以您无法检查任何生成的序列化函数，因为没有任何序列化函数。</p><p id="696b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">json_serializable 的另一个缺点是它为每个数据类文件生成一个文件。这将不可避免地将您的项目与一堆文件聚集在一起。您只需要为所有模型生成一个文件。虽然这个文件可能会变得相当大，但它仍然可以快速搜索，不会污染你的文件检查器。</p><h1 id="b9bf" class="mv jn hi bd kq mw nm my ku mz nn nb ky nc no ne lb nf np nh le ni nq nk lh nl bi translated">编译时检查</h1><p id="eaaa" class="pw-post-body-paragraph if ig hi ih b ii lj ik il im lk io ip iq ll is it iu lm iw ix iy ln ja jb jc hb bi translated">我非常喜欢强类型语言，因为你把代码中部分可能的错误移到了编译时。任何已经在编译时被捕获的 bug 都是很棒的，显然比运行时异常好得多。</p><p id="137d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">代码生成有很大的可能性来编写大量的，但是非常强类型的代码，因为你不必关心编写简洁的代码。如前所述，<em class="lx"> dart_json_mapper </em>在运行时使用反射，因此完全错过了这个机会。</p><h1 id="f13c" class="mv jn hi bd kq mw nm my ku mz nn nb ky nc no ne lb nf np nh le ni nq nk lh nl bi translated">实施开销</h1><p id="3696" class="pw-post-body-paragraph if ig hi ih b ii lj ik il im lk io ip iq ll is it iu lm iw ix iy ln ja jb jc hb bi translated">使用<em class="lx"> reflectable </em>，你实际上只能在一个项目中使用一次，即使它在一个包中。这是因为<em class="lx">可反射</em>静态初始化，因此任何第二次初始化都会覆盖第一次初始化。</p><p id="0915" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">另外<em class="lx"> reflectable </em>是一个相当大的图书馆。代码生成已经给了你所有的分析能力和你需要的类的元信息，<em class="lx"> dart_json_mapper </em>完全忽略它们，把问题转移到<em class="lx"> reflectable </em>上。</p><h1 id="6ce2" class="mv jn hi bd kq mw nm my ku mz nn nb ky nc no ne lb nf np nh le ni nq nk lh nl bi translated">怎么样</h1><p id="f217" class="pw-post-body-paragraph if ig hi ih b ii lj ik il im lk io ip iq ll is it iu lm iw ix iy ln ja jb jc hb bi translated">有一些特性是<strong class="ih hj">dart _ mapable</strong>所独有的。其中之一是序列化过程中内置的灵活性和可扩展性。</p><p id="ab6a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">您的模型可能会有许多自定义用例。大多数情况下，json 键到类属性的一对一映射会很好，但在少数情况下，您的序列化包应该会让您有可能做出改变。这就是为什么<strong class="ih hj">dart _ mapable</strong>带有<a class="ae ki" href="https://pub.dev/packages/dart_mappable#encoding--decoding-hooks" rel="noopener ugc nofollow" target="_blank">定制钩子</a>的原因，你可以用它来控制和修改(反)序列化过程的每一个部分。</p><p id="e376" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">另一个热门话题是泛型。这真的很难。当使用自定义泛型类型时，反序列化带来了巨大的挑战。这是因为实际上不可能从复合类型中向下钻取泛型类型信息。更具体地说，当你有一个类型<code class="du jt ju jv ji b">A&lt;B&gt;</code>时，没有办法到达类型<code class="du jt ju jv ji b">B</code>。所以当你有一个嵌套的 json 对象时，你知道把外部对象解码成什么，但是当使用像<code class="du jt ju jv ji b">fromJson&lt;A&lt;B&gt;&gt;(jsonString)</code>这样的通用解码函数时，你不知道把内部对象解码成什么。Stackoverflow 上有几个关于这个问题的问题，通常答案是“你不能”。</p><p id="4231" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">因此，每个包都有自己的技巧或解决方法来处理泛型。<em class="lx"> dart_json_mapper </em>使用 type_adapters，在很大程度上你必须为每个组合类型手动定义，因此不再是真正的“通用”了。<em class="lx"> json_serializable </em>在其文档中没有涉及泛型，但是在 Github 和 Stackoverflow 上有一些问题，以及<a class="ae ki" href="https://wamae.medium.com/generics-and-json-serialization-in-flutter-a8d335840d7b" rel="noopener">本文</a>。总的来说，在一些简单的情况下这是可能的，但是你必须手动处理内部类型。不完全是我所说的“就这么简单”。</p><p id="ec93" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">与其他的不同，<strong class="ih hj">dart _ mapable</strong>允许您自然地使用现成的泛型类，不需要任何额外的工作。是的，你只需按一下<code class="du jt ju jv ji b">A&lt;B&gt; object = Mapper.fromJson(jsonString)</code>，它就会正常工作。我知道我刚才说这是不可能的，这是从语言的角度来看，但是通过代码生成的能力和一些技巧，我可以让它工作(这是我很自豪的💪).如果人们感兴趣，我可能会写一篇单独的文章，更深入地解释这是如何工作的。</p><h1 id="d72e" class="mv jn hi bd kq mw nm my ku mz nn nb ky nc no ne lb nf np nh le ni nq nk lh nl bi translated">包裹</h1><p id="55b0" class="pw-post-body-paragraph if ig hi ih b ii lj ik il im lk io ip iq ll is it iu lm iw ix iy ln ja jb jc hb bi translated">还有一些我没有在本文中介绍的特性。我在软件包自述文件中记录了所有这些，因此如果您正在寻找更多的技术解释和使用指南，请前往<a class="ae ki" href="https://pub.dev/packages/dart_mappable" rel="noopener ugc nofollow" target="_blank">软件包发布和开发页面</a>。</p><p id="9f3f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">总的来说，这个包还在开发中，根据您的使用情况，可能还会有一些问题。然而，我在我自己的一些项目以及我目前工作的公司中使用了它，到目前为止，它表现得相当好。</p><p id="b2a5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果您对这个包有任何进一步的问题或反馈，请随时在 Github 上添加问题。欢迎任何反馈😃。</p></div></div>    
</body>
</html>