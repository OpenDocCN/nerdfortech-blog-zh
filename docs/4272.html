<html>
<head>
<title>Creating a Ledge Grab System in Unity</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在 Unity 中创建壁架抓取系统</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/creating-a-ledge-grab-system-in-unity-8d9de1fd2a93?source=collection_archive---------18-----------------------#2021-07-13">https://medium.com/nerd-for-tech/creating-a-ledge-grab-system-in-unity-8d9de1fd2a93?source=collection_archive---------18-----------------------#2021-07-13</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="089e" class="pw-post-body-paragraph ig ih hi ii b ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd hb bi translated"><strong class="ii hj">目标:</strong>让玩家抓住一个壁架，把自己拉起来。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div class="er es je"><img src="../Images/e6213d096c634891684a0567a0ba79d1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1166/1*TyzLMd5ZTjqoxf8fv_vXnQ.gif"/></div></figure><p id="279b" class="pw-post-body-paragraph ig ih hi ii b ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd hb bi translated">这个过程很棘手。首先，我们将在玩家的头部上方创建一个不可见的物体，如果他们必须抓住一个壁架，他们的手将会在那里。我们将把它标记为<em class="jm">壁架 _ 抓取 _ 检查器</em>。我们还将创建一个不可见的<em class="jm">碰撞器</em>，它的<em class="jm">被触发</em>设置为<em class="jm">真</em>。我们还将在希望玩家悬挂的位置创建一个空的游戏对象。我们在代码中将这个空对象称为<em class="jm"> _snapPosition </em>。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div class="er es jn"><img src="../Images/ed563d9cbe5610089424c76466984b4c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1246/format:webp/1*GQLccEB9tdkr-8g64sBqHw.png"/></div></figure><p id="72f1" class="pw-post-body-paragraph ig ih hi ii b ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd hb bi translated">在壁架的<em class="jm"> OnTriggerEnter </em>方法上，如果玩家的<em class="jm">壁架 _Grab_Checker </em>是触发对象，壁架将找到附加的玩家并调用其公共<em class="jm"> GrabLedge </em>方法，传入<em class="jm"> _snapPosition </em>对象的位置。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div class="er es jo"><img src="../Images/9596913d6cf2a0c969335b60dba485cb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1222/format:webp/1*9Q_igJk5MJvdGsAKs_neOg.png"/></div></figure><p id="8f2b" class="pw-post-body-paragraph ig ih hi ii b ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd hb bi translated">玩家的<em class="jm"> GrabLedge </em>方法禁用了<em class="jm">角色控制器</em>，因此玩家不能尝试行走或跳跃。然后，它会通过将<em class="jm"> IsGrabbingLedge </em>设置为<em class="jm"> true </em>来告诉动画转换到挂起状态。然后我们将播放器放在我们传入的<em class="jm"> snapPosition </em>上。最后，我们将把<em class="jm"> _isHanging </em> bool 标记为<em class="jm"> true </em>。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div class="er es jp"><img src="../Images/caa28733b5d6742190bc170a3f7b0343.png" data-original-src="https://miro.medium.com/v2/resize:fit:930/format:webp/1*bNA0HfkkMQUpupbqmqp3rw.png"/></div></figure><p id="f2aa" class="pw-post-body-paragraph ig ih hi ii b ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd hb bi translated">在玩家下一次<em class="jm">更新</em>的过程中，由于控制器被禁用，所以我们不会计算任何移动。<em class="jm"> _isHanging </em>为<em class="jm">真</em>，所以如果玩家也按下<em class="jm"> E </em>键，我们就调用<em class="jm"> ClimbUp </em>方法。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div class="er es jq"><img src="../Images/409ff29a12d897568958d766a1be66fd.png" data-original-src="https://miro.medium.com/v2/resize:fit:918/format:webp/1*dIgrkQanPCkMU307PFCFcg.png"/></div></figure><p id="ea0b" class="pw-post-body-paragraph ig ih hi ii b ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd hb bi translated"><em class="jm"> ClimbUp </em>方法会将<em class="jm">is hanging</em>设置为<em class="jm"> false </em>并触发<em class="jm"> ClimbUp </em>动画状态。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div class="er es jr"><img src="../Images/bc228338026ce8495b42f6531ca51d23.png" data-original-src="https://miro.medium.com/v2/resize:fit:714/format:webp/1*jsACR0nmk0Li-xUwFSHhSA.png"/></div></figure><p id="a655" class="pw-post-body-paragraph ig ih hi ii b ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd hb bi translated"><em class="jm"> ClimbUp </em>动画状态附有一段特殊的代码:一个<em class="jm">statemachinehavior</em>脚本。当动画剪辑到达其结尾时，它将返回到静止空闲状态。退出将触发<em class="jm">statemachinehbehavior 的 onsteexit</em>方法。这个方法将依次调用播放器的<em class="jm"> FinishStanding </em>方法。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jt ju di jv bf jw"><div class="er es js"><img src="../Images/894ebc6cb81b8d3921c51c8f83b771c1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RxaTlh86xIS1qpJ6x020RQ.png"/></div></div></figure><p id="06b0" class="pw-post-body-paragraph ig ih hi ii b ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd hb bi translated"><em class="jm"> FinishStanding </em>方法首先确保我们将一切恢复正常。当我们抓住壁架时，我们正在半空中跳跃，所以<em class="jm"> _isJumping </em>需要设置回<em class="jm"> false </em>。然后，我们将设置动画参数，以确保我们将处于站立的空闲位置。最后，我们将重新启用角色控制，给我们的玩家继续玩游戏的自由！</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div class="er es jx"><img src="../Images/76b22b4204843ba36ee05d41b7af2470.png" data-original-src="https://miro.medium.com/v2/resize:fit:954/format:webp/1*egKQ-BydyBxzQ1PCZim7GQ.png"/></div></figure></div></div>    
</body>
</html>