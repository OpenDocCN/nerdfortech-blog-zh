<html>
<head>
<title>An opinionated Kotlin backend service - Build &amp; Deployment</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">固执己见的Kotlin后端服务——构建和部署</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/an-opinionated-kotlin-backend-service-part-2-480ab5e6cdb2?source=collection_archive---------2-----------------------#2021-04-28">https://medium.com/nerd-for-tech/an-opinionated-kotlin-backend-service-part-2-480ab5e6cdb2?source=collection_archive---------2-----------------------#2021-04-28</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/e462a9e2ece88ac80dcf07717b21b4e0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*prcVa0xbVTFSB_ge"/></div></div></figure><p id="917e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这是我的基于Kotlin的后端服务系列的第二部分。<br/>如果你错过了第一部分:<a class="ae jo" rel="noopener" href="/p/87f814e3dffd">一个固执己见的Kotlin后端服务——框架</a>。</p><h1 id="b8e9" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">Gradle Build</h1><p id="040a" class="pw-post-body-paragraph iq ir hi is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hb bi translated">我对构建系统有四个主要要求:</p><ol class=""><li id="6f03" class="ks kt hi is b it iu ix iy jb ku jf kv jj kw jn kx ky kz la bi translated">我想用Gradle(不是Maven)</li><li id="6664" class="ks kt hi is b it lb ix lc jb ld jf le jj lf jn kx ky kz la bi translated">编码、配置、构建和部署(尽可能)使用单一语言</li><li id="690e" class="ks kt hi is b it lb ix lc jb ld jf le jj lf jn kx ky kz la bi translated">我想集中管理插件和依赖版本</li><li id="b425" class="ks kt hi is b it lb ix lc jb ld jf le jj lf jn kx ky kz la bi translated">我想支持一个单一的回购方法，每个后端服务是一个单独的梯度模块</li></ol><p id="5d92" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">使用Kotlin而不是Groovy支持对所有事情使用单一语言的目标。</p><p id="68c6" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">集中管理依赖版本有两种主要方法(而不是在每个模块中复制它们):</p><ul class=""><li id="7757" class="ks kt hi is b it iu ix iy jb ku jf kv jj kw jn lg ky kz la bi translated">使用gradle.properties文件</li><li id="1c00" class="ks kt hi is b it lb ix lc jb ld jf le jj lf jn lg ky kz la bi translated">使用<a class="ae jo" href="https://docs.gradle.org/current/userguide/organizing_gradle_projects.html#sec:build_sources" rel="noopener ugc nofollow" target="_blank"> buildSrc文件夹</a></li></ul><h2 id="a25f" class="lh jq hi bd jr li lj lk jv ll lm ln jz jb lo lp kd jf lq lr kh jj ls lt kl lu bi translated">属性文件</h2><p id="e393" class="pw-post-body-paragraph iq ir hi is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hb bi translated">在顶层<strong class="is hj"><em class="lv">gradle . properties</em></strong>文件中定义版本:</p><pre class="lw lx ly lz fd ma mb mc md aw me bi"><span id="3986" class="lh jq hi mb b fi mf mg l mh mi">kotlinVersion=1.4.32<br/>ktorVersion=1.5.3</span></pre><p id="d162" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">对于插件，使用<strong class="is hj"><em class="lv">settings . gradle . kts</em></strong>文件中的<a class="ae jo" href="https://docs.gradle.org/current/userguide/plugins.html" rel="noopener ugc nofollow" target="_blank"> pluginManagement </a>函数:</p><pre class="lw lx ly lz fd ma mb mc md aw me bi"><span id="dfbb" class="lh jq hi mb b fi mf mg l mh mi">pluginManagement {<br/>    val kotlinVersion: String by settings<br/>    plugins {<br/>        kotlin("jvm") version kotlinVersion<br/>    }<br/>}</span></pre><p id="e7a0" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj"><em class="lv">build . gradle . kts</em></strong>文件将如下所示:</p><pre class="lw lx ly lz fd ma mb mc md aw me bi"><span id="d13a" class="lh jq hi mb b fi mf mg l mh mi">// Plugins<br/>plugins <strong class="mb hj">{<br/>    </strong>kotlin("jvm")   /// no version needed<br/><strong class="mb hj">}</strong></span><span id="11f3" class="lh jq hi mb b fi mj mg l mh mi">/// Dependencies<br/>val kotlinVersion: String by project<br/>val ktorVersion: String by project</span><span id="62a7" class="lh jq hi mb b fi mj mg l mh mi">implementation(kotlin("stdlib", kotlinVersion))<br/>implementation("io.ktor:ktor-server-core:$ktorVersion")</span></pre><h2 id="8fae" class="lh jq hi bd jr li lj lk jv ll lm ln jz jb lo lp kd jf lq lr kh jj ls lt kl lu bi translated"><a class="ae jo" href="https://docs.gradle.org/current/userguide/organizing_gradle_projects.html#sec:build_sources" rel="noopener ugc nofollow" target="_blank"> buildSrc文件夹</a></h2><p id="1611" class="pw-post-body-paragraph iq ir hi is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hb bi translated">这是我的首选方法，因为它支持我用单一的<em class="lv">语言来统治所有的</em>方法。</p><p id="8706" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">buildSrc基本上是一个特殊的模块，在编译任何其他模块之前编译。Gradle会自动编译和测试它的代码，并将其放入您的构建脚本的类路径中。</p><p id="89e6" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">出于我们的目的，我们只使用它来管理依赖关系，并保持模块/服务构建文件简短，几乎没有冗余。所有插件和依赖项都在两个文件<a class="ae jo" href="https://github.com/1gravity/Ktor-Template/blob/main/buildSrc/src/main/kotlin/com/onegravity/Plugin.kt" rel="noopener ugc nofollow" target="_blank"> Plugin.kt </a>和<a class="ae jo" href="https://github.com/1gravity/Ktor-Template/blob/main/buildSrc/src/main/kotlin/com/onegravity/Dependency.kt" rel="noopener ugc nofollow" target="_blank"> Dependency.kt </a>中管理。</p><p id="0389" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这样，在每个模块中应用插件和定义依赖关系变得非常简单:</p><pre class="lw lx ly lz fd ma mb mc md aw me bi"><span id="3f61" class="lh jq hi mb b fi mf mg l mh mi">plugins {<br/>    Plugin.modulePlugins.<em class="lv">forEach </em>{ (n, v) -&gt; id(n) <em class="lv">version </em>v }<br/>}</span><span id="d9ac" class="lh jq hi mb b fi mj mg l mh mi"><em class="lv">dependencies </em>{<br/>    Dependency.implementation.<em class="lv">forEach</em>(::implementation)<br/>    Dependency.runtime.<em class="lv">forEach</em>(::runtimeOnly)<br/>    Dependency.testImplementation.<em class="lv">forEach</em>(::testImplementation)<br/>}</span></pre><h2 id="f871" class="lh jq hi bd jr li lj lk jv ll lm ln jz jb lo lp kd jf lq lr kh jj ls lt kl lu bi translated"><a class="ae jo" href="https://gitlab.com/barfuin/gradle-taskinfo" rel="noopener ugc nofollow" target="_blank">任务信息</a></h2><p id="9532" class="pw-post-body-paragraph iq ir hi is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hb bi translated">我添加了TaskInfo作为Gradle插件来显示任务依赖和类型。例如，运行<code class="du mk ml mm mb b">./gradlew tiTree assemble</code>会导致:</p><figure class="lw lx ly lz fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mn"><img src="../Images/a88609ba6fcd8bf0e30b35bdcfbcb9b0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yQFfbOKHJQ2yiwZL9flRYQ.png"/></div></div></figure><h1 id="a291" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">集装箱化</h1><p id="4444" class="pw-post-body-paragraph iq ir hi is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hb bi translated">Dockerization几乎是当今后端服务的标准，并提供了在几乎任何环境中部署的灵活性，无论是本地环境、内部环境、云环境、Kubernetes环境还是OpenShift环境，只要是你能想到的。</p><p id="cb89" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">挑战之一是使用Gradle在容器中构建应用程序。许多教程解释了这个过程，但是大多数教程都将安装构建工具作为构建过程的一部分，然后构建并运行应用程序(都在同一个容器中)。</p><p id="9bb1" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我更喜欢使用多阶段构建，一个映像用于构建，另一个用于运行应用程序。这样，我可以使用一个预配置的映像进行构建，而不需要安装任何东西(减少构建时间=成本),并为运行时环境使用另一个映像。构建和运行时环境的分离似乎也是一个安全的好方法。</p><h2 id="5bd6" class="lh jq hi bd jr li lj lk jv ll lm ln jz jb lo lp kd jf lq lr kh jj ls lt kl lu bi translated">建设</h2><pre class="lw lx ly lz fd ma mb mc md aw me bi"><span id="ed77" class="lh jq hi mb b fi mf mg l mh mi">FROM gradle AS <em class="lv">build</em></span><span id="bccc" class="lh jq hi mb b fi mj mg l mh mi">WORKDIR /appbuild<br/>COPY . /appbuild</span><span id="5e1f" class="lh jq hi mb b fi mj mg l mh mi">RUN gradle wrapper     # better safe than sorry<br/>RUN ./gradlew :account-service:clean :account-service:assemble</span></pre><h2 id="e606" class="lh jq hi bd jr li lj lk jv ll lm ln jz jb lo lp kd jf lq lr kh jj ls lt kl lu bi translated">部署/运行</h2><p id="b9f0" class="pw-post-body-paragraph iq ir hi is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hb bi translated">使用<code class="du mk ml mm mb b">COPY</code>命令将构建步骤中的工件复制到运行时容器中:</p><pre class="lw lx ly lz fd ma mb mc md aw me bi"><span id="cdd5" class="lh jq hi mb b fi mf mg l mh mi">FROM openjdk:8-jre-alpine<br/><br/>WORKDIR /app<br/><br/>COPY --from=<em class="lv">0 </em>appbuild/account-service/build/libs/account-service.jar application.jar<br/><br/>CMD ["java", "-server", "-jar", "application.jar"]</span></pre><p id="b29c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">要构建运行时容器，请在项目的根目录中使用以下命令:</p><pre class="lw lx ly lz fd ma mb mc md aw me bi"><span id="6a75" class="lh jq hi mb b fi mf mg l mh mi">DOCKER_BUILDKIT=1 docker build -f account-service/Dockerfile -t ktor-template/account .</span></pre><p id="34b8" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">它将创建一个带有标签<em class="lv">“ktor-template/account”(命令docker images) </em>的图像:</p><figure class="lw lx ly lz fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mo"><img src="../Images/e59bb5e0dcd611dc6e2bb4374b4917bc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Ksu-dMHiNoPN-jA-qICTKw.png"/></div></div></figure><p id="28aa" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">然后可以使用以下命令运行:</p><pre class="lw lx ly lz fd ma mb mc md aw me bi"><span id="d15f" class="lh jq hi mb b fi mf mg l mh mi">docker run ktor-template/account</span></pre><h2 id="846d" class="lh jq hi bd jr li lj lk jv ll lm ln jz jb lo lp kd jf lq lr kh jj ls lt kl lu bi translated">docker-撰写</h2><p id="482d" class="pw-post-body-paragraph iq ir hi is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hb bi translated">虽然该模板只包含一个服务，但我的意图是(如上所述)在同一个存储库中支持多个服务的单一回购方法。使用docker-compose似乎是管理多种服务(加上共享服务，如数据库、网关、消息服务、监控等)的好方法。).</p><p id="e5b4" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我不想在这里详细说明<em class="lv"> docker-compose.yml </em>文件，但是我将在本系列后面谈到数据库的设置和集成时解释一些细节。目前感兴趣的只是如何启动应用程序(这已经在本系列的第1部分中解释过了):</p><ul class=""><li id="1925" class="ks kt hi is b it iu ix iy jb ku jf kv jj kw jn lg ky kz la bi translated">在项目的根目录下运行<code class="du mk ml mm mb b">docker-compuse up</code>(或<code class="du mk ml mm mb b">sudo docker-compuse up</code>)</li><li id="cc61" class="ks kt hi is b it lb ix lc jb ld jf le jj lf jn lg ky kz la bi translated">打开<a class="ae jo" href="http://localhost:2000/" rel="noopener ugc nofollow" target="_blank"> http://localhost:2000 </a></li></ul><p id="3a7d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这就是本系列的第2部分。如果你喜欢这个跟进<a class="ae jo" rel="noopener" href="/p/1e4b02aa6245">，一个固执己见的Kotlin后端服务——API路由和文档</a>。</p><p id="955e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">像往常一样，请随时提供反馈。编码快乐！</p></div></div>    
</body>
</html>