<html>
<head>
<title>Introduction to Actors in Swift.</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Swift 中的演员简介。</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/introduction-to-actors-in-swift-93c7bb9ec1b7?source=collection_archive---------11-----------------------#2021-06-27">https://medium.com/nerd-for-tech/introduction-to-actors-in-swift-93c7bb9ec1b7?source=collection_archive---------11-----------------------#2021-06-27</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="18e1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在本文中，我们将讨论 swift 5.5 中新发布的 Actors。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es jd"><img src="../Images/283ef64442f713c778e327582531a3f1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BeDIS5zTArXlOapt2Rqcqg.png"/></div></div></figure><p id="c05f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">并发是任何移动开发平台的主要部分，我们在应用程序生命周期的几乎每个阶段都使用并发任务。例如，在我们收到来自 API 的响应后更新 UI，或者在任何指定任务完成后更新模型，等等。</p><p id="f21e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">从开发人员的角度来谈并发性，必须提到队列。队列是闭包，根据它们的顺序在不同的合适的线程上工作。如果在并发后部署在多个线程上，队列遵循(FIFO)。</p><p id="8b71" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们来谈谈我们的队列类型。<br/>队列可以分为两种基本类型。</p><p id="e266" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">排队类型:</strong></p><ol class=""><li id="baed" class="jp jq hi ih b ii ij im in iq jr iu js iy jt jc ju jv jw jx bi translated">串行队列:串行队列按顺序工作。它从队列中取出第一个任务，开始处理它，对它进行操作，直到它完成执行，然后只选择新的任务。</li><li id="832b" class="jp jq hi ih b ii jy im jz iq ka iu kb iy kc jc ju jv jw jx bi translated">并发队列:像串行队列一样，它也从队列中取出第一个任务，并在任何可用的线程中启动它的执行。<br/>如果系统看到它可以访问更多的线程，它会从队列中取出其他任务，并在另一个线程上启动它们，而不等待第一个执行完成。类似地，它可以处理队列中任意数量的任务。</li></ol><p id="7264" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">并发方式:</strong></p><p id="d815" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">使用队列时，有两种类型的方法可用</p><ol class=""><li id="3f9a" class="jp jq hi ih b ii ij im in iq jr iu js iy jt jc ju jv jw jx bi translated">Sync:在阻塞整个队列的特定任务的整个执行完成后，将控制返回到当前队列。</li><li id="c52c" class="jp jq hi ih b ii jy im jz iq ka iu kb iy kc jc ju jv jw jx bi translated">Async:在启动一个特定任务后，立即将控制返回到当前队列，而不等待它结束，因此它永远不会阻塞整个队列。</li></ol><p id="590d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在，我们已经大致讨论了并发性。假设我们有一个共享的引用在并发任务下工作，比如更新一个字符串数组。让我们来看一个用传统方法做这件事的例子。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es kd"><img src="../Images/b03ea7ac6bf925915be376e51626fb7b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rnH4GO2MfpaScvIh1mIodA.png"/></div></div></figure><p id="2d40" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在这个例子中，我们可以看到共享字符串数组被多个试图更新它的线程共享。<br/>我们无法保证哪个线程将首先完成获取并落入完成块。<br/>假设我们的第二个任务首先完成，在它完成后，我们试图从第一个位置删除一个元素，而目前我们在第一个位置没有元素，所以我们可以预期这里会崩溃。<br/>或者，如果我们正在执行另一个任务，我们可以有一个竞争条件。</p><p id="382a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> <em class="ke">数据竞争让并发变得困难。当我们有多个线程访问/修改相同的数据时，就会发生这种情况。</em> </strong></p><p id="1b6c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">例如，我们可以使用像结构这样的值类型来避免数据竞争</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es kf"><img src="../Images/7f43de65a8421df2d7ef05f6eb068fad.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5rCzHvPaCviBpG4yOi5wKA.png"/></div></div></figure><p id="837e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">虽然现在我们的代码是安全的，但行为是不正确的。</p><p id="c1e5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这就是演员的用武之地。在运行代码示例之前，让我们讨论一下 Actors 的一些主要特性。</p><h1 id="4abc" class="kg kh hi bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld bi translated"><strong class="ak">演员:</strong></h1><p id="6579" class="pw-post-body-paragraph if ig hi ih b ii le ik il im lf io ip iq lg is it iu lh iw ix iy li ja jb jc hb bi translated">概念上类似于类。在并发环境中使用是安全的，因为 Swift 确保了在任何给定的时间内，actor 中的可变状态只能被一个线程访问，这有助于消除编译器级别的各种严重错误。</p><ol class=""><li id="a610" class="jp jq hi ih b ii ij im in iq jr iu js iy jt jc ju jv jw jx bi translated">使用新的<code class="du lj lk ll lm b"><strong class="ih hj">actor</strong></code>关键字创建演员。这是 Swift 中一个新的具体的名义类型，连接结构、类和枚举。</li><li id="5851" class="jp jq hi ih b ii jy im jz iq ka iu kb iy kc jc ju jv jw jx bi translated">参与者是引用类型。</li><li id="9c9d" class="jp jq hi ih b ii jy im jz iq ka iu kb iy kc jc ju jv jw jx bi translated">Actor 隔离数据。</li></ol><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es ln"><img src="../Images/e6172fc1433c66a33d5fd4b0c242d602.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZShJedP4Op44fHCi2d817g.png"/></div></div></figure><p id="0537" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们以一个执行并发代码的类为例。这段代码在单线程环境中运行完全没问题，但是如果这段代码在多线程环境中执行，我们将会遇到竞争情况。</p><p id="aa8d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们假设在多线程环境中，两个线程同时执行<strong class="ih hj"> manageEmployeeSalary </strong>方法。我们两个线程都将把工资转给同一个雇员。</p><p id="5823" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">那肯定对员工有利，但对公司不利。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es lo"><img src="../Images/dbd38755465767382666fbc0926502eb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lviPzqUbvufJEx54Pqkxvw.jpeg"/></div></div></figure><p id="bea2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们通过演员来考虑这个问题。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es lp"><img src="../Images/e20cb4f79bbb15e8283737203ac4695e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MdD_o7nK6Qs0c3XIVFV22g.png"/></div></div></figure><p id="bd1f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这里所发生的是演员之外的另一个管理员试图在我们的第一个管理员的业务中做一些修改。我们的编译器立刻给出一个错误“嘿，你不能在 actor 之外做这个，除非你等待当前任务完成，然后你才能做。”<br/>现在我们知道我们不能有竞争条件，因为我们的编译器不允许多个线程同时访问一个资源。<br/> <strong class="ih hj">多酷啊？</strong></p><p id="2c1e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">那么如何才能解决这个问题呢？？</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es lq"><img src="../Images/d5e1c1fe64e13c7f0a9985704f657f84.png" data-original-src="https://miro.medium.com/v2/resize:fit:640/1*53W7CaxcFBgnwSahCxcZNw.gif"/></div></figure><p id="3ba8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">嗯，我们必须使用 await 关键字等待一个特定的工资转移完成，然后只有我们可以将工资转移给任何其他员工。<br/>我们确保工资已转账，并根据结果从员工名单中删除该员工。<br/>这样我们就不会把工资两次转给一个员工。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es lr"><img src="../Images/2b668dcb4e650fce5b683d96e4456c1f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*aG_bMxPD8pdLTEY-Pg9mGA.png"/></div></div></figure><p id="1518" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">所以现在我们的共享资源<em class="ke">雇员</em>永远不能同时在不同的线程中被修改。</p><p id="36db" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">演员确保一次只修改一次。</strong></p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es ls"><img src="../Images/130fb131511cf6871641014b5a7899f3.png" data-original-src="https://miro.medium.com/v2/resize:fit:960/1*HNhyM_sn8e-jStAptPVAwA.gif"/></div><figcaption class="lt lu et er es lv lw bd b be z dx translated"><em class="lx">对不起员工没好日子过了。</em></figcaption></figure><p id="0ddf" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在这个例子中有几件事需要注意。</p><ol class=""><li id="9826" class="jp jq hi ih b ii ij im in iq jr iu js iy jt jc ju jv jw jx bi translated">演员是使用新的“演员”关键字创建的</li><li id="cb75" class="jp jq hi ih b ii jy im jz iq ka iu kb iy kc jc ju jv jw jx bi translated"><strong class="ih hj"> manageEmployeeSalary </strong>方法被标记为<strong class="ih hj"> async </strong>，因为它在等待传输完成时需要暂停工作。</li><li id="eca9" class="jp jq hi ih b ii jy im jz iq ka iu kb iy kc jc ju jv jw jx bi translated">尽管<strong class="ih hj">transfersalary to employee</strong>方法是<em class="ke">而不是</em>标记的<code class="du lj lk ll lm b"><strong class="ih hj">async</strong></code>，我们仍然需要称它为<code class="du lj lk ll lm b"><strong class="ih hj">await</strong></code>，因为它将等待另一个管理角色能够处理该请求。</li></ol><p id="c4a3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Actor 和 class 都是引用类型，但是 actor 是安全的共享状态，不像 class。除了类可以被继承之外，它们在每个方面都是相同的。</p><p id="e57c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">@MainActor 是确保您的代码在主线程上运行的新关键字。此外，如果我们想确保在主线程上保存数据，也可以这样做。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es ly"><img src="../Images/9dae92d30c13636d3bef0bcce6b8785c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5NKDOv3R_Rh3PHu1p5f06A.png"/></div></div></figure><p id="18c0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我想我们现在对演员如何工作以及何时可以使用他们有了一个基本的概念。这篇文章到此为止。如果您有任何问题，请告诉我！</p><p id="c70a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">编码快乐！<br/>T2【Sheeraz Ahmed】T3】</p></div></div>    
</body>
</html>