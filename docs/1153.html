<html>
<head>
<title>Does const and let hoist in Javascript?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Javascript中const和let提升吗？</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/does-const-and-let-hoist-in-javascript-b0c4bcef32ea?source=collection_archive---------7-----------------------#2021-03-06">https://medium.com/nerd-for-tech/does-const-and-let-hoist-in-javascript-b0c4bcef32ea?source=collection_archive---------7-----------------------#2021-03-06</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/2683c8a896017725793bbed6fcb863be.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*rZRQfdqKDtcUUD9_"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">马库斯·斯皮斯克在<a class="ae iu" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="e749" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在这篇文章中，我将讨论javascript提升，并打破一些关于它的神话。</p><p id="bba2" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">每个Javascript开发人员在学习语言时都会经历术语<strong class="ix hj">提升</strong>。但大多数人都弄错了。</p><p id="043c" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">这是关于吊装的两个最流行的神话</strong></p><ul class=""><li id="90ce" class="jt ju hi ix b iy iz jc jd jg jv jk jw jo jx js jy jz ka kb bi translated">在编译过程中，所有的变量和函数声明都被移到程序的顶部</li><li id="42a7" class="jt ju hi ix b iy kc jc kd jg ke jk kf jo kg js jy jz ka kb bi translated"><code class="du kh ki kj kk b">const</code>和<code class="du kh ki kj kk b">let</code>不提升</li></ul><p id="82c5" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">让我们来谈谈第一个流言，</p><p id="5b6f" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">所有的变量和函数声明都被移到程序的顶部了吗？</p><p id="b2a0" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj"><em class="kl"/></strong>没有</p><p id="5e6e" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">什么！如果不是这样，会发生什么？</p><p id="de46" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">根据MDN <a class="ae iu" href="https://developer.mozilla.org/en-US/docs/Glossary/Hoisting#:~:text=Conceptually,code." rel="noopener ugc nofollow" target="_blank">“在<em class="kl">编译</em>阶段，变量和函数声明被放入内存，但是停留在你在代码中键入它们的地方。”</a></p><p id="b4a0" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">那么我们来看看javascript是如何运行程序的？</p><p id="f709" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在更高的层次上，运行任何JS程序都涉及到两个步骤</p><ol class=""><li id="59a4" class="jt ju hi ix b iy iz jc jd jg jv jk jw jo jx js km jz ka kb bi translated">程序编译</li><li id="7e3b" class="jt ju hi ix b iy kc jc kd jg ke jk kf jo kg js km jz ka kb bi translated">程序的执行</li></ol><p id="7a51" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">所以当我们把任何一个程序交给JS引擎，那么引擎先把它编译成机器码，然后执行。在编译程序时，JS引擎将所有的声明放入内存中。</p><ul class=""><li id="8794" class="jt ju hi ix b iy iz jc jd jg jv jk jw jo jx js jy jz ka kb bi translated">当编译器遇到任何类似<code class="du kh ki kj kk b">var someVariable = "SomeValue"</code>的语句时，它会将变量<code class="du kh ki kj kk b">someVariable</code>放入内存，并用<code class="du kh ki kj kk b">undefined</code>初始化。</li><li id="5a86" class="jt ju hi ix b iy kc jc kd jg ke jk kf jo kg js jy jz ka kb bi translated">当编译器看到任何函数声明时，它会将函数声明放入内存，并用函数定义初始化它。</li></ul><p id="5efc" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">所以我们可以注意到这里的区别，带有<code class="du kh ki kj kk b">var</code>关键字的变量被放入内存并用<code class="du kh ki kj kk b">undefined</code>初始化，而带有<code class="du kh ki kj kk b">function</code>关键字的变量被放入内存并用真正的函数定义初始化。</p><pre class="kn ko kp kq fd kr kk ks kt aw ku bi"><span id="b6f4" class="kv kw hi kk b fi kx ky l kz la">console.log(a);<br/>var a = "Hello js";<br/>foo();<br/>function foo() {<br/>  console.log("From Inside foo");<br/>}</span></pre><p id="a9fa" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">当上面的代码片段运行时，我们将得到以下输出</p><pre class="kn ko kp kq fd kr kk ks kt aw ku bi"><span id="2e3b" class="kv kw hi kk b fi kx ky l kz la">undefined<br/>From Inside foo</span></pre><ul class=""><li id="9658" class="jt ju hi ix b iy iz jc jd jg jv jk jw jo jx js jy jz ka kb bi translated">现在我们来分析一下刚刚发生了什么，当我们运行上面的代码片段Javascript首先编译程序，所以在编译过程中，它看到第2行有一个以<code class="du kh ki kj kk b">var a</code>开头的语句，于是编译器把<code class="du kh ki kj kk b">a</code>放到内存中，用<code class="du kh ki kj kk b">uneifined</code>初始化。然后它又在第4行看到一个函数声明<code class="du kh ki kj kk b">function foo() {</code>，所以编译器把<code class="du kh ki kj kk b">foo</code>声明放在内存中并用它的定义初始化它。</li><li id="e059" class="jt ju hi ix b iy kc jc kd jg ke jk kf jo kg js jy jz ka kb bi translated">现在，在执行阶段，JS引擎遇到第一行，然后检查内存中的变量<code class="du kh ki kj kk b">a</code>，发现有一个名为<code class="du kh ki kj kk b">a</code>的变量，它的值为<code class="du kh ki kj kk b">undefined</code>，所以它打印未定义的内容。然后在第2行，它将<code class="du kh ki kj kk b">a</code>赋给<code class="du kh ki kj kk b">Hello js</code>。现在在第3行，它调用<code class="du kh ki kj kk b">foo</code>，然后JS引擎再次在内存中查找<code class="du kh ki kj kk b">foo</code>，它发现它有一个函数<code class="du kh ki kj kk b">foo</code>并且有它的定义，所以它调用这个函数。</li></ul><p id="f90c" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这就是<code class="du kh ki kj kk b">var</code>和<code class="du kh ki kj kk b">functions</code>被提升的过程。</p><p id="1ae3" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">现在来看第二个流言，</p><p id="34e5" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><code class="du kh ki kj kk b"><em class="kl">const</em></code> <em class="kl">和</em> <code class="du kh ki kj kk b"><em class="kl">let</em></code> <em class="kl">不吊，真的是这样吗？</em></p><p id="ee98" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">“又一个大不了”</strong></p><p id="babb" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><code class="du kh ki kj kk b">const</code>和<code class="du kh ki kj kk b">let</code>同样，像<code class="du kh ki kj kk b">var</code>和<code class="du kh ki kj kk b">function</code>一样提升。但是与<code class="du kh ki kj kk b">var</code>和<code class="du kh ki kj kk b">function</code>不同的是，<code class="du kh ki kj kk b">const</code>和<code class="du kh ki kj kk b">let</code>不会被初始化。而且我们不能在声明它的行之前使用它，因为它会进入一个叫做<em class="kl">“时间死区(TMZ)”的特殊区域。</em></p><p id="ad0e" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">让我们用一个例子来理解:</p><pre class="kn ko kp kq fd kr kk ks kt aw ku bi"><span id="c410" class="kv kw hi kk b fi kx ky l kz la">console.log(a);<br/>var a= "hello world"<br/>var b = "again hello"<br/>console.log(b)</span></pre><p id="e3c5" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">现在你应该已经猜到了上面程序的输出，是的，你是对的</p><pre class="kn ko kp kq fd kr kk ks kt aw ku bi"><span id="0994" class="kv kw hi kk b fi kx ky l kz la">undefined<br/>again hello</span></pre><p id="0822" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">好的，现在你能猜出下面程序的输出吗</p><pre class="kn ko kp kq fd kr kk ks kt aw ku bi"><span id="434c" class="kv kw hi kk b fi kx ky l kz la">console.log(a);<br/>var a= "hello world"<br/>var b = "outer b"<br/>console.log(b)<br/>{<br/>  console.log(b); // ReferenceError: Cannot access 'b' before initialization<br/>  let b = "inner b";<br/>}</span></pre><p id="c444" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">您可能已经猜到了它会像上面的程序一样打印出来</p><pre class="kn ko kp kq fd kr kk ks kt aw ku bi"><span id="53d7" class="kv kw hi kk b fi kx ky l kz la">udefined<br/>outer b</span></pre><p id="caa4" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">但事实并非如此，因为<code class="du kh ki kj kk b">let</code>的作用域是在块级别，所以它被提升并进入<em class="kl">时间死区</em>。这就是我们得到<code class="du kh ki kj kk b">ReferenceError</code>的原因。所以事实证明<code class="du kh ki kj kk b">let</code>像<code class="du kh ki kj kk b">var</code>和<code class="du kh ki kj kk b">function</code>一样被吊起来。<code class="du kh ki kj kk b">const</code>也是如此。</p><h2 id="a6c5" class="kv kw hi bd lb lc ld le lf lg lh li lj jg lk ll lm jk ln lo lp jo lq lr ls lt bi translated">结论</h2><p id="393a" class="pw-post-body-paragraph iv iw hi ix b iy lu ja jb jc lv je jf jg lw ji jj jk lx jm jn jo ly jq jr js hb bi translated">好了，现在我们知道提升并不意味着将所有的声明移动到程序的顶部。最重要的是<code class="du kh ki kj kk b">const</code>和<code class="du kh ki kj kk b">let</code>被提升。</p><p id="f348" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">希望你喜欢这篇文章。欢迎任何建议和反馈。</p></div></div>    
</body>
</html>