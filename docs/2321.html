<html>
<head>
<title>Merge LiveData like you need it</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">按需合并 LiveData</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/merging-livedata-like-you-need-it-3abcf6b756ca?source=collection_archive---------4-----------------------#2021-05-01">https://medium.com/nerd-for-tech/merging-livedata-like-you-need-it-3abcf6b756ca?source=collection_archive---------4-----------------------#2021-05-01</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="405f" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">如何将任意类型的多个 LiveData 合并成一个 LiveData。</h2></div><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ix"><img src="../Images/fb45cdd96485e7d27f0a244062ef7d64.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Dzk-7Cz_XSpuW8qD-GLCyA.jpeg"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">信用:<a class="ae jn" href="http://s3.amazonaws.com/clarocity-wordpress/clarocity/wp-content/uploads/2017/03/20230657/road_merging-righttrim.jpg" rel="noopener ugc nofollow" target="_blank">信用</a></figcaption></figure><p id="cab0" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">在与<code class="du kk kl km kn b">LiveData</code>合作的几个项目中，我经常面临与<code class="du kk kl km kn b">MediatorLiveData</code>相关的挑战:</p><ul class=""><li id="5703" class="ko kp hi jq b jr js ju jv jx kq kb kr kf ks kj kt ku kv kw bi translated">它允许一个接一个地添加多个源，但是没有一个源知道其他源的值。如果一个源发生了变化，并不是所有的源值都可以通过相互作用来确定新值。</li><li id="ee83" class="ko kp hi jq b jr kx ju ky jx kz kb la kf lb kj kt ku kv kw bi translated">它不能用初始源和映射进行实例化。</li></ul><p id="19fe" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">在将代码块从一个项目复制到另一个项目之后——将类改为方法，然后再转回来——我最终得到了这里给出的解决方案。我们的目标是有一个通用的解决方案，它可以很容易地集成并适合每一个用例——<em class="lc">编码一次，在任何地方使用</em>。</p></div><div class="ab cl ld le gp lf" role="separator"><span class="lg bw bk lh li lj"/><span class="lg bw bk lh li lj"/><span class="lg bw bk lh li"/></div><div class="hb hc hd he hf"><p id="80a6" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><code class="du kk kl km kn b">MergerLiveData</code>，对<code class="du kk kl km kn b">MediatorLiveData</code>的扩展，解决了将一个或多个源类型转换成一个目标类型的挑战:</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="lk ll l"/></div></figure><p id="5c3b" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">当第一个观察者被连接时，<code class="du kk kl km kn b">MergerLiveData</code>订阅一个或多个源的改变，当最后一个观察者分离时，移除所有的源。通过提供一个<em class="lc">合并函数，</em>你可以很容易地将任何源类型转换成任何目标类型。<br/>只有非空值被发送到<em class="lc">合并函数</em>中，以尽可能安全地执行。通过使用<code class="du kk kl km kn b">postValue(T)</code>将合并结果异步发送到主线程上，也允许在后台服务中使用<code class="du kk kl km kn b">MergerLiveData</code>。<code class="du kk kl km kn b">DistinctUntilChanged</code>规定是过账所有值，还是仅过账与当前值不同的值。</p><p id="93ca" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">通过使用<code class="du kk kl km kn b">sealed class</code>，所有的实现都被分组到一个根下，IDE 自动完成功能可以得到最好的利用——只需输入<code class="du kk kl km kn b">MergerLiveData.</code>,所有类型都会显示出来。<br/>尽管在<code class="du kk kl km kn b">MergerLiveData.One</code>的情况下，这是一对一的映射，因此该类应该被称为<code class="du kk kl km kn b">MappingLiveData</code>。这个特例保留在<code class="du kk kl km kn b">MergerLiveData</code>组中，以保持尽可能高的一致性和易用性。它的变换函数叫做<em class="lc">映射。</em>这可能看起来不一致，但是有了<em class="lc">结尾的 lambdas </em>,这个函数基本上不会作为(命名的)参数传递，所以函数名反映了执行的动作。</p><p id="47e4" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><code class="du kk kl km kn b">MergerLiveData</code>的一个用例是观察联系人表单的多个<code class="du kk kl km kn b">LiveData</code>输入，如果满足某些条件，就启用提交按钮。</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="lk ll l"/></div></figure><p id="9735" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">在不使用<code class="du kk kl km kn b">MergerLiveData</code>的情况下，验证在布局内执行，因此业务逻辑在<em class="lc">视图模型</em>和<em class="lc">布局</em>之间分离。此外，组合布尔表达式在 XML 文件中可读性不强。</p><p id="87d1" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">通过引入一个<code class="du kk kl km kn b">MergerLiveData.Two</code>，布尔表达式可以转移到<em class="lc">视图模型</em>中。因此，所有的业务逻辑都集中在一个类中，而不是分散在两个文件中。作为一名开发人员，您只需查看视图模型<em class="lc">的内部，这将成为唯一的事实。此外，通过将复杂的布尔语句分成不同的方法或变量，可以更好地描述它们。<br/>最后，<code class="du kk kl km kn b">MergerLiveData</code>通过允许立即设置初始源和映射简化了<code class="du kk kl km kn b">MediatorLiveData</code>的创建——无需使用利用<code class="du kk kl km kn b">apply()</code>的通用工作区:</em></p><pre class="iy iz ja jb fd lm kn ln lo aw lp bi"><span id="d06c" class="lq lr hi kn b fi ls lt l lu lv">val mediatorLiveData = MediatorLiveData&lt;T&gt;().apply { <br/>       addSource(source) { value -&gt;          <br/>           // do stuff          <br/>       }     <br/>}</span></pre><p id="2ca7" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><code class="du kk kl km kn b">MergerLiveData</code>的其他用例可能是:</p><ul class=""><li id="c9d8" class="ko kp hi jq b jr js ju jv jx kq kb kr kf ks kj kt ku kv kw bi translated">将多个本地(例如使用<a class="ae jn" href="https://developer.android.com/jetpack/androidx/releases/room" rel="noopener ugc nofollow" target="_blank">房间</a>)或远程数据源转换为一个 UI 模型</li><li id="8fe6" class="ko kp hi jq b jr kx ju ky jx kz kb la kf lb kj kt ku kv kw bi translated">将多个源合并成一个代表当前 UI 状态的<code class="du kk kl km kn b"><a class="ae jn" href="https://developer.android.com/jetpack/compose" rel="noopener ugc nofollow" target="_blank">Composable</a></code></li></ul></div><div class="ab cl ld le gp lf" role="separator"><span class="lg bw bk lh li lj"/><span class="lg bw bk lh li lj"/><span class="lg bw bk lh li"/></div><div class="hb hc hd he hf"><p id="497a" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><code class="du kk kl km kn b">MergerLiveData</code>是<a class="ae jn" href="https://github.com/DanielKnauf/livedata-kit" rel="noopener ugc nofollow" target="_blank"> <em class="lc"> LiveData-Kit </em> </a>的一部分，通过<a class="ae jn" href="https://jitpack.io" rel="noopener ugc nofollow" target="_blank"> JitPack </a>可以很容易的将其包含到一个项目中。你可以在 GitHub 上找到所有必要的代码行。</p><p id="bffd" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">感谢阅读！</p><div class="lw lx ez fb ly lz"><a href="https://github.com/DanielKnauf/livedata-kit" rel="noopener  ugc nofollow" target="_blank"><div class="ma ab dw"><div class="mb ab mc cl cj md"><h2 class="bd hj fi z dy me ea eb mf ed ef hh bi translated">丹尼尔可耐福/livedata-kit</h2><div class="mg l"><h3 class="bd b fi z dy me ea eb mf ed ef dx translated">在 GitHub 上创建一个帐户，为 DanielKnauf/livedata-kit 的开发做出贡献。</h3></div><div class="mh l"><p class="bd b fp z dy me ea eb mf ed ef dx translated">github.com</p></div></div><div class="mi l"><div class="mj l mk ml mm mi mn jh lz"/></div></div></a></div></div></div>    
</body>
</html>