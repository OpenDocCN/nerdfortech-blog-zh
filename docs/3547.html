<html>
<head>
<title>Decorator functions in Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python中的装饰函数</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/decorator-functions-in-python-6407de5be383?source=collection_archive---------15-----------------------#2021-06-13">https://medium.com/nerd-for-tech/decorator-functions-in-python-6407de5be383?source=collection_archive---------15-----------------------#2021-06-13</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/5a46aa4f916ea11de6dae3bccf65fa57.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cC4io0CTH9HY7iWiFYNBmA.jpeg"/></div></div></figure><h1 id="3fa0" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">装饰函数</h1><blockquote class="jo jp jq"><p id="6d28" class="jr js jt ju b jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp hb bi translated">这篇短文是关于在非常基础的层次上使用python中的decorators，以及在哪里使用它。我们将看到装饰函数最常见的用法，然后理解如何编写自己的函数。</p></blockquote><h2 id="2944" class="kq ir hi bd is kr ks kt iw ku kv kw ja kx ky kz je la lb lc ji ld le lf jm lg bi translated">Web开发概述</h2><p id="aa8f" class="pw-post-body-paragraph jr js hi ju b jv lh jx jy jz li kb kc kx lj kf kg la lk kj kk ld ll kn ko kp hb bi translated">Web开发包括前端和后端的全栈工作。对于开发来说，除了语言的选择之外，您还可以在前端框架(如Angular或React)和后端框架(如Django、Flask或Node)之间进行选择。</p><p id="774b" class="pw-post-body-paragraph jr js hi ju b jv jw jx jy jz ka kb kc kx ke kf kg la ki kj kk ld km kn ko kp hb bi translated">框架基本上是一些工具，为许多常见的功能提供了大量的预构建。这样我们就不必总是重新发明轮子，所以我们可以用轮子来制造自行车、汽车或飞机。</p><p id="b243" class="pw-post-body-paragraph jr js hi ju b jv jw jx jy jz ka kb kc kx ke kf kg la ki kj kk ld km kn ko kp hb bi translated">在前端，HTML提供了结构，CSS提供了样式，JS提供了交互性，也构成了客户端。后端既有服务器上的业务逻辑，也有数据库上的数据。</p><p id="fb92" class="pw-post-body-paragraph jr js hi ju b jv jw jx jy jz ka kb kc kx ke kf kg la ki kj kk ld km kn ko kp hb bi translated">举一个最简单的例子，考虑餐馆，当你去那里时，你坐在用餐区(客户端)，你的食物在厨房(服务器)准备，食物的存储(数据库)可能在储藏室，如果不是冰箱的话。</p></div><div class="ab cl lm ln gp lo" role="separator"><span class="lp bw bk lq lr ls"/><span class="lp bw bk lq lr ls"/><span class="lp bw bk lq lr"/></div><div class="hb hc hd he hf"><h2 id="12f5" class="kq ir hi bd is kr ks kt iw ku kv kw ja kx ky kz je la lb lc ji ld le lf jm lg bi translated">库vs框架</h2><p id="d0e8" class="pw-post-body-paragraph jr js hi ju b jv lh jx jy jz li kb kc kx lj kf kg la lk kj kk ld ll kn ko kp hb bi translated">你可能已经使用过几次库了，当你调用一个方法时，它是你完全控制的地方，然后控制被返回。库和框架的主要区别是代码从不调用框架，而是框架调用代码。就像这种情况。</p><figure class="lt lu lv lw fd ij"><div class="bz dy l di"><div class="lx ly l"/></div></figure></div><div class="ab cl lm ln gp lo" role="separator"><span class="lp bw bk lq lr ls"/><span class="lp bw bk lq lr ls"/><span class="lp bw bk lq lr"/></div><div class="hb hc hd he hf"><h2 id="0214" class="kq ir hi bd is kr ks kt iw ku kv kw ja kx ky kz je la lb lc ji ld le lf jm lg bi translated">基本烧瓶框架应用</h2><p id="10d0" class="pw-post-body-paragraph jr js hi ju b jv lh jx jy jz li kb kc kx lj kf kg la lk kj kk ld ll kn ko kp hb bi translated">文件的名称不应与框架或库冲突。</p><figure class="lt lu lv lw fd ij"><div class="bz dy l di"><div class="lx ly l"/></div></figure><p id="45b3" class="pw-post-body-paragraph jr js hi ju b jv jw jx jy jz ka kb kc kx ke kf kg la ki kj kk ld km kn ko kp hb bi translated">然后从终端调用CLI。</p><blockquote class="jo jp jq"><p id="6e43" class="jr js jt ju b jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp hb bi translated"><em class="hi">导出FLASK _ APP = " calling _ FLASK _ framework . py "</em></p><p id="f999" class="jr js jt ju b jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp hb bi translated"><em class="hi">烧瓶运行</em></p></blockquote><p id="7da7" class="pw-post-body-paragraph jr js hi ju b jv jw jx jy jz ka kb kc kx ke kf kg la ki kj kk ld km kn ko kp hb bi translated">为了理解操作系统，把它比作开心果。所以内核是核心，是与硬件接口的实际程序，是操作系统的核心。那么外壳就是外壳，或者UI，或者CLI。</p><p id="d37a" class="pw-post-body-paragraph jr js hi ju b jv jw jx jy jz ka kb kc kx ke kf kg la ki kj kk ld km kn ko kp hb bi translated">为了理解这段代码，_name_是python中的一个特殊属性，它返回当前工作脚本的名称。@是装饰函数的语法糖，该函数将在框架内定义。装饰函数为现有函数提供了额外的功能。</p></div><div class="ab cl lm ln gp lo" role="separator"><span class="lp bw bk lq lr ls"/><span class="lp bw bk lq lr ls"/><span class="lp bw bk lq lr"/></div><div class="hb hc hd he hf"><h2 id="1559" class="kq ir hi bd is kr ks kt iw ku kv kw ja kx ky kz je la lb lc ji ld le lf jm lg bi translated">函数是python中的一等公民</h2><p id="35c9" class="pw-post-body-paragraph jr js hi ju b jv lh jx jy jz li kb kc kx lj kf kg la lk kj kk ld ll kn ko kp hb bi translated">为了理解decorators，你还需要知道，当我们把函数当作一级对象时，如果没有()，它可以作为参数传递，也可以从另一个函数返回一个函数。</p><figure class="lt lu lv lw fd ij"><div class="bz dy l di"><div class="lx ly l"/></div></figure><p id="7b85" class="pw-post-body-paragraph jr js hi ju b jv jw jx jy jz ka kb kc kx ke kf kg la ki kj kk ld km kn ko kp hb bi translated">从函数中删除括号意味着我们不再激活它。</p><h2 id="fd04" class="kq ir hi bd is kr ks kt iw ku kv kw ja kx ky kz je la lb lc ji ld le lf jm lg bi translated">嵌套函数</h2><p id="d265" class="pw-post-body-paragraph jr js hi ju b jv lh jx jy jz li kb kc kx lj kf kg la lk kj kk ld ll kn ko kp hb bi translated">在python中，我们也可以定义一个类似这样的嵌套函数。</p><figure class="lt lu lv lw fd ij"><div class="bz dy l di"><div class="lx ly l"/></div></figure></div><div class="ab cl lm ln gp lo" role="separator"><span class="lp bw bk lq lr ls"/><span class="lp bw bk lq lr ls"/><span class="lp bw bk lq lr"/></div><div class="hb hc hd he hf"><h2 id="cf72" class="kq ir hi bd is kr ks kt iw ku kv kw ja kx ky kz je la lb lc ji ld le lf jm lg bi translated">Python装饰者</h2><p id="1b4c" class="pw-post-body-paragraph jr js hi ju b jv lh jx jy jz li kb kc kx lj kf kg la lk kj kk ld ll kn ko kp hb bi translated">最后来定义python装饰器:</p><figure class="lt lu lv lw fd ij"><div class="bz dy l di"><div class="lx ly l"/></div></figure><p id="faee" class="pw-post-body-paragraph jr js hi ju b jv jw jx jy jz ka kb kc kx ke kf kg la ki kj kk ld km kn ko kp hb bi translated">装饰器包装另一个函数，并赋予它修改过的或附加的功能。第3行到第6行定义了最基本的装饰函数，它只是传递函数本身，什么也不做。</p><p id="c1db" class="pw-post-body-paragraph jr js hi ju b jv jw jx jy jz ka kb kc kx ke kf kg la ki kj kk ld km kn ko kp hb bi translated">从第15行到第19行，在调用函数之前，函数将延迟2秒被传递。因此，当我们在任何方法之前使用@调用decorator时，它被传递到方法内部，重复的代码可以在它之前和之后实现。</p><figure class="lt lu lv lw fd ij"><div class="bz dy l di"><div class="lx ly l"/></div></figure><p id="52cb" class="pw-post-body-paragraph jr js hi ju b jv jw jx jy jz ka kb kc kx ke kf kg la ki kj kk ld km kn ko kp hb bi translated">下面是一个使用python中的decorators测试各种函数速度的例子。</p><p id="1fb6" class="pw-post-body-paragraph jr js hi ju b jv jw jx jy jz ka kb kc kx ke kf kg la ki kj kk ld km kn ko kp hb bi translated">@app.route是flask框架的装饰器，每当路由被命中时，它就调用该函数。对我来说，这是一条重要的信息。希望它也能帮助你。让我知道你的想法。编码快乐！</p></div></div>    
</body>
</html>