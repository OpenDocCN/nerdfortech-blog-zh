<html>
<head>
<title>The Pipe Dream to Easy Deployment with Pipelines</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">管道梦想用管道轻松部署</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/pipeline-to-atlantis-18aa36dc6ecf?source=collection_archive---------12-----------------------#2021-05-14">https://medium.com/nerd-for-tech/pipeline-to-atlantis-18aa36dc6ecf?source=collection_archive---------12-----------------------#2021-05-14</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><blockquote class="if"><p id="fac9" class="ig ih hi bd ii ij ik il im in io ip dx translated">“你可能会说我是一个梦想家，但我不是唯一的一个”</p><p id="e36e" class="ig ih hi bd ii ij iq ir is it iu ip dx translated">约翰·列侬</p></blockquote><h1 id="9629" class="iv iw hi bd ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js bi translated">想象一下没有部署斗争</h1><p id="36be" class="pw-post-body-paragraph jt ju hi jv b jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp ip hb bi translated">想象一下，作为一名开发人员，您编写代码，在本地进行测试，然后将其推送到远程存储库。从那里，它会被自动测试，如果通过了所有测试，它就会被部署到生产服务器上。在整个过程中，您都会通过 Slack 得到任何失败的通知。想象一下，您不必担心手动配置您的生产服务器。想象一下，在生产中，就像在本地一样，一切正常。</p><p id="fa8c" class="pw-post-body-paragraph jt ju hi jv b jw kq jy jz ka kr kc kd ke ks kg kh ki kt kk kl km ku ko kp ip hb bi translated">这不是一个停留在潜意识中的梦想，这是一个需要行动、知识和意志去实现的梦想。在我自己的旅程中，我被我全心全意投入的项目所困扰，当我试图部署我的 web 应用程序并解决所有生产 bug 时，我的头撞上了柏林墙。我环顾四周，不仅是我，还有我所有的开发伙伴，都在为类似的问题而挣扎。然后我听到它在呼唤…我脑海中的那个声音，它说，“有一个更简单的方法。”</p><p id="03b1" class="pw-post-body-paragraph jt ju hi jv b jw kq jy jz ka kr kc kd ke ks kg kh ki kt kk kl km ku ko kp ip hb bi translated">下降到<a class="ae kv" href="https://searx.github.io/searx/" rel="noopener ugc nofollow" target="_blank">西尔克斯</a>兔子洞的黑暗中，DevOps 作为<a class="ae kv" href="https://en.wikipedia.org/wiki/One_true_church" rel="noopener ugc nofollow" target="_blank">一个真正的救赎教会</a>出现。根据<a class="ae kv" href="https://www.atlassian.com/devops" rel="noopener ugc nofollow" target="_blank">阿特拉斯</a>:</p><blockquote class="kw kx ky"><p id="7df5" class="jt ju kz jv b jw kq jy jz ka kr kc kd la ks kg kh lb kt kk kl lc ku ko kp ip hb bi translated">DevOps 是一组实践，用于自动化和集成软件开发和 IT 团队之间的过程，因此他们可以更快、更可靠地构建、测试和发布软件。</p></blockquote><p id="7508" class="pw-post-body-paragraph jt ju hi jv b jw kq jy jz ka kr kc kd ke ks kg kh ki kt kk kl km ku ko kp ip hb bi translated">DevOps 建立在<a class="ae kv" href="https://www.atlassian.com/agile" rel="noopener ugc nofollow" target="_blank">敏捷开发</a>的基础上，封装并自动化了从集成到持续监控生产服务器的流程的每个部分。这种自动化实践被称为<a class="ae kv" href="https://www.katalon.com/resources-center/blog/ci-cd-introduction/" rel="noopener ugc nofollow" target="_blank"> CI/CD 管道</a>或<em class="kz">管道</em>。</p><figure class="le lf lg lh fd li er es paragraph-image"><div role="button" tabindex="0" class="lj lk di ll bf lm"><div class="er es ld"><img src="../Images/c2e3aa2027884b681ed7b47e8ed29262.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*br4UZGJM0r3q6WVVeefOKQ.jpeg"/></div></div><figcaption class="lp lq et er es lr ls bd b be z dx translated">DevOps 构建敏捷开发管道，由<a class="ae kv" href="https://i.pinimg.com/originals/6e/be/14/6ebe1464624cd2bdeae9655579e7ce29.jpg" rel="noopener ugc nofollow" target="_blank">来源</a>提供</figcaption></figure><p id="d060" class="pw-post-body-paragraph jt ju hi jv b jw kq jy jz ka kr kc kd ke ks kg kh ki kt kk kl km ku ko kp ip hb bi translated">有过多的工具<a class="ae kv" href="https://www.katalon.com/resources-center/blog/ci-cd-tools/" rel="noopener ugc nofollow" target="_blank">允许人们创建这些管道。我们将尝试 GitHub Actions、CircleCI 和 TravisCI。将来，我希望将这篇文章扩展到包括 Jenkins、Bamboo 和 GitLab。</a></p><h1 id="fbf4" class="iv iw hi bd ix iy iz ja jb jc jd je jf jg lt ji jj jk lu jm jn jo lv jq jr js bi translated">想象变成计划</h1><p id="5080" class="pw-post-body-paragraph jt ju hi jv b jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp ip hb bi translated">首先，我创建了一个基础项目，它可以被克隆，以便使用上面概述的每个工具建立三个不同的管道。<a class="ae kv" href="https://github.com/starlightromero/this-is-not-financial-advice" rel="noopener ugc nofollow" target="_blank">这不是财务建议</a>，有一个没有风格的普通用户界面，但包含了一个基本节点应用程序的所有必要部分，包括 CRUD 路线和测试。此外，<a class="ae kv" href="https://invidious.tube/watch?v=Gjnup-PuquQ" rel="noopener ugc nofollow" target="_blank"> Docker </a>用于允许在独立环境中轻松部署。</p><p id="92f4" class="pw-post-body-paragraph jt ju hi jv b jw kq jy jz ka kr kc kd ke ks kg kh ki kt kk kl km ku ko kp ip hb bi translated">花点时间熟悉一下项目回购。现在，我们准备停止想象，开始实现。</p><h1 id="e760" class="iv iw hi bd ix iy iz ja jb jc jd je jf jg lt ji jj jk lu jm jn jo lv jq jr js bi translated">现实化</h1><p id="6f0f" class="pw-post-body-paragraph jt ju hi jv b jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp ip hb bi translated">我选择 GitHub Actions、CircleCI 和 TravisCI 是因为它们的流行和易于集成。我想象中的管道很简单。</p><p id="a5d5" class="pw-post-body-paragraph jt ju hi jv b jw kq jy jz ka kr kc kd ke ks kg kh ki kt kk kl km ku ko kp ip hb bi translated">在推送到<code class="du lw lx ly lz b">development</code>分支时，管道将:</p><ol class=""><li id="5ac2" class="ma mb hi jv b jw kq ka kr ke mc ki md km me ip mf mg mh mi bi translated">检查代码</li><li id="da75" class="ma mb hi jv b jw mj ka mk ke ml ki mm km mn ip mf mg mh mi bi translated">安装依赖项</li><li id="d150" class="ma mb hi jv b jw mj ka mk ke ml ki mm km mn ip mf mg mh mi bi translated">在 Node 的四个不同的主要版本(10、12、14、15)上测试代码</li></ol><p id="c65d" class="pw-post-body-paragraph jt ju hi jv b jw kq jy jz ka kr kc kd ke ks kg kh ki kt kk kl km ku ko kp ip hb bi translated">在推送到<code class="du lw lx ly lz b">production</code>分支时，管道将以与上面相同的方式启动。然后，如果代码通过了测试，管道将:</p><ol class=""><li id="ef92" class="ma mb hi jv b jw kq ka kr ke mc ki md km me ip mf mg mh mi bi translated">检查代码</li><li id="b945" class="ma mb hi jv b jw mj ka mk ke ml ki mm km mn ip mf mg mh mi bi translated">建立 Docker 形象</li><li id="c019" class="ma mb hi jv b jw mj ka mk ke ml ki mm km mn ip mf mg mh mi bi translated">把图像推给 Heroku</li></ol><p id="feaf" class="pw-post-body-paragraph jt ju hi jv b jw kq jy jz ka kr kc kd ke ks kg kh ki kt kk kl km ku ko kp ip hb bi translated">此外，我希望收到一个关于过程中任何失败的 Slack 通知，或者一个成功通知，如果管道执行时没有失败。</p><figure class="le lf lg lh fd li er es paragraph-image"><div role="button" tabindex="0" class="lj lk di ll bf lm"><div class="er es mo"><img src="../Images/fa0efe485d99156029fd8a5378a1a0aa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*aobSr55KC7PQBLLVAYKSaQ.jpeg"/></div></div></figure><h2 id="966b" class="mp iw hi bd ix mq mr ms jb mt mu mv jf ke mw mx jj ki my mz jn km na nb jr nc bi translated">文档文件</h2><p id="5926" class="pw-post-body-paragraph jt ju hi jv b jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp ip hb bi translated">这是我们将用来构建图像的 Dockerfile 文件。</p><figure class="le lf lg lh fd li"><div class="bz dy l di"><div class="nd ne l"/></div></figure><h1 id="1334" class="iv iw hi bd ix iy iz ja jb jc jd je jf jg lt ji jj jk lu jm jn jo lv jq jr js bi translated">GitHub 操作</h1><p id="4633" class="pw-post-body-paragraph jt ju hi jv b jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp ip hb bi translated">GitHub Actions 和大多数其他管道工具一样，使用 yaml 文件格式。GitHub Actions 利用了<a class="ae kv" href="https://docs.github.com/en/actions/reference/workflow-syntax-for-github-actions" rel="noopener ugc nofollow" target="_blank">工作流</a>。</p><blockquote class="kw kx ky"><p id="98ff" class="jt ju kz jv b jw kq jy jz ka kr kc kd la ks kg kh lb kt kk kl lc ku ko kp ip hb bi translated">工作流是由一个或多个作业组成的可配置自动化流程。您必须创建 YAML 文件来定义您的工作流配置。</p><p id="7870" class="jt ju kz jv b jw kq jy jz ka kr kc kd la ks kg kh lb kt kk kl lc ku ko kp ip hb bi translated">工作流运行由一个或多个作业组成。默认情况下，作业并行运行。</p><p id="e6ea" class="jt ju kz jv b jw kq jy jz ka kr kc kd la ks kg kh lb kt kk kl lc ku ko kp ip hb bi translated">作业包含一系列称为步骤的任务。</p></blockquote><p id="49e5" class="pw-post-body-paragraph jt ju hi jv b jw kq jy jz ka kr kc kd ke ks kg kh ki kt kk kl km ku ko kp ip hb bi translated">要创建一个工作流，在你的项目 repo 的根目录下创建一个文件夹，<code class="du lw lx ly lz b">.github</code>。在新创建的文件夹中创建一个文件夹，<code class="du lw lx ly lz b">workflows</code>。这些目录的名字很重要，因为 GitHub 专门在<code class="du lw lx ly lz b">.github/workflows/</code>中查看是否有应该执行的工作流。</p><p id="9ba8" class="pw-post-body-paragraph jt ju hi jv b jw kq jy jz ka kr kc kd ke ks kg kh ki kt kk kl km ku ko kp ip hb bi translated">我们将从<code class="du lw lx ly lz b">development</code>分支开始，创建一个工作流并定义一个名称<code class="du lw lx ly lz b">Test</code>。在向分支推送时，<code class="du lw lx ly lz b">test</code>作业将被触发。这项工作将在 Ubuntu 上运行。然后我们定义一个节点版本矩阵来安装和测试代码。然而，在进行实际测试之前，我们检查代码。然后，我们安装依赖项并测试代码。我们设置了 Slack 通知来提醒我们任何失败，或者是否一切顺利。</p><p id="4e0c" class="pw-post-body-paragraph jt ju hi jv b jw kq jy jz ka kr kc kd ke ks kg kh ki kt kk kl km ku ko kp ip hb bi translated">再深入一点，<code class="du lw lx ly lz b">Checkout</code>和<code class="du lw lx ly lz b">Use Node.js</code>步骤是预定义的内置动作。你可以把这些想成 JS 里的<code class="du lw lx ly lz b">Math.pow()</code>。这与我们运行自己的命令的<code class="du lw lx ly lz b">Install Dependencies</code>步骤不同。松弛通知使用<code class="du lw lx ly lz b"><a class="ae kv" href="https://github.com/voxmedia/github-action-slack-notify-build" rel="noopener ugc nofollow" target="_blank">voxmedia/github-action-slack-notify-build@v1</a></code>。你可以认为这是一个像 Express 一样的外部依赖。通过探索<a class="ae kv" href="https://github.com/marketplace?type=actions" rel="noopener ugc nofollow" target="_blank"> GitHub Marketplace </a>你可以找到各种可以在你的工作流程中使用的操作。</p><figure class="le lf lg lh fd li"><div class="bz dy l di"><div class="nd ne l"/></div><figcaption class="lp lq et er es lr ls bd b be z dx translated">这不是财务建议 GitHub 行动 yaml 文件。想象我自己的。</figcaption></figure><p id="337a" class="pw-post-body-paragraph jt ju hi jv b jw kq jy jz ka kr kc kd ke ks kg kh ki kt kk kl km ku ko kp ip hb bi translated">对于<code class="du lw lx ly lz b">production</code>工作流，在第 6 行，我们指定在推送到生产分支时触发的工作流。创建一个额外的作业<code class="du lw lx ly lz b">build</code>，它依赖于<code class="du lw lx ly lz b">test</code>首先完成。如果我们在第 44 行没有这个规范，这两个作业将并行运行。我们再次签出代码，但是这一次我们使用了别人为我们预定义的动作，以便<a class="ae kv" href="https://github.com/jctaveras/heroku-deploy" rel="noopener ugc nofollow" target="_blank">构建、推送和部署到 Heroku </a>。最后，我们有我们的 Slack 通知。</p><figure class="le lf lg lh fd li"><div class="bz dy l di"><div class="nd ne l"/></div><figcaption class="lp lq et er es lr ls bd b be z dx translated">这不是用于生产工作流程的财务建议 Github Actions yaml 文件。想象我自己的。</figcaption></figure><h2 id="e6d3" class="mp iw hi bd ix mq mr ms jb mt mu mv jf ke mw mx jj ki my mz jn km na nb jr nc bi translated"><strong class="ak">环境变量呢？</strong></h2><figure class="le lf lg lh fd li"><div class="bz dy l di"><div class="nf ne l"/></div></figure><p id="61f6" class="pw-post-body-paragraph jt ju hi jv b jw kq jy jz ka kr kc kd ke ks kg kh ki kt kk kl km ku ko kp ip hb bi translated">环境变量是任何 web 应用程序的重要组成部分。在 GitHub repo 中导航到<code class="du lw lx ly lz b">Settings</code>选项卡，然后在侧边栏上点击<code class="du lw lx ly lz b">Secrets</code>。在右上方附近可以找到<code class="du lw lx ly lz b">New repository secret</code>。输入名称和值后，您将被重定向到机密页面，列表中会显示您的新机密。正如你在上面的代码片段中看到的，我们可以通过使用语法<code class="du lw lx ly lz b">${{ secrets.NAME_OF_SECRET }}</code>来访问它，秘密将在运行时动态注入。</p><h2 id="4296" class="mp iw hi bd ix mq mr ms jb mt mu mv jf ke mw mx jj ki my mz jn km na nb jr nc bi translated">我们如何设置 Heroku？</h2><p id="7382" class="pw-post-body-paragraph jt ju hi jv b jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp ip hb bi translated">通过查看密钥，Heroku 有点简单明了。您将需要您的 Heroku 电子邮件、API 密钥和应用程序名称。我假设你知道你的邮箱。要获取应用名称，您首先需要登录并创建一个应用。要获取 API 密匙，点击右上角的忍者档案图标进入<code class="du lw lx ly lz b">Account Settings</code>。向下滚动到<code class="du lw lx ly lz b">API Key</code>部分并选择<code class="du lw lx ly lz b">Reveal</code>。现在，将此密钥与您的电子邮件和应用程序名称一起保存在您的秘密中。</p><figure class="le lf lg lh fd li er es paragraph-image"><div role="button" tabindex="0" class="lj lk di ll bf lm"><div class="er es ng"><img src="../Images/e058490b99509656403b0296f067bd23.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*F-jdX8LL_O_jdA5CpF17MA@2x.png"/></div></div></figure><p id="fab9" class="pw-post-body-paragraph jt ju hi jv b jw kq jy jz ka kr kc kd ke ks kg kh ki kt kk kl km ku ko kp ip hb bi translated">回到仪表板，点击<code class="du lw lx ly lz b">New</code>，在下拉菜单中点击<code class="du lw lx ly lz b">Create new app</code>。输入应用名称<code class="du lw lx ly lz b">tinfa-gh-actions</code>，点击<code class="du lw lx ly lz b">Create app</code>。创建应用程序后，单击该应用程序。在顶部附近，在导航栏上单击<code class="du lw lx ly lz b">Settings</code>，然后向下滚动到<code class="du lw lx ly lz b">Config Vars</code>，在该部分中单击<code class="du lw lx ly lz b">Reveal Config Vars</code>。我们将在这里输入生产所需的任何秘密变量。我们将添加<code class="du lw lx ly lz b">MONGODB_URI</code>，作为键，URI 作为值。</p><figure class="le lf lg lh fd li er es paragraph-image"><div role="button" tabindex="0" class="lj lk di ll bf lm"><div class="er es nh"><img src="../Images/30a3edfc74dd472fab5befc78199aa2c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rsek36RZYZu2Vk6C5uFmdA@2x.png"/></div></div></figure><h2 id="bc54" class="mp iw hi bd ix mq mr ms jb mt mu mv jf ke mw mx jj ki my mz jn km na nb jr nc bi translated"><strong class="ak">还有时差通知？</strong></h2><p id="106d" class="pw-post-body-paragraph jt ju hi jv b jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp ip hb bi translated">时差通知需要一些时间来设置。首先，确保您登录到 Slack，然后导航到<code class="du lw lx ly lz b"><a class="ae kv" href="https://api.slack.com/" rel="noopener ugc nofollow" target="_blank">https://api.slack.com/</a></code>并点击<code class="du lw lx ly lz b">Create Custom App</code>。接下来，点击带有文本<code class="du lw lx ly lz b">Create New App</code>的绿色按钮。当弹出窗口出现时，选择<code class="du lw lx ly lz b">From Scratch</code>。我将应用程序命名为<code class="du lw lx ly lz b">TINFA-GH-Actions</code>，并选择了合适的工作空间。</p><figure class="le lf lg lh fd li er es paragraph-image"><div role="button" tabindex="0" class="lj lk di ll bf lm"><div class="er es ni"><img src="../Images/02ccf37f62c005e7a42f941f4051907d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QTXqr2rzcECg81pVQGOIqw@2x.png"/></div></div></figure><p id="b1f7" class="pw-post-body-paragraph jt ju hi jv b jw kq jy jz ka kr kc kd ke ks kg kh ki kt kk kl km ku ko kp ip hb bi translated">一旦应用程序被创建，我们需要设置允许 Slackbot 发送通知的权限。在<code class="du lw lx ly lz b">Features</code>部分的左侧导航栏上，点击<code class="du lw lx ly lz b">OAuth &amp; Permissions</code>。向下滚动到<code class="du lw lx ly lz b">Scopes</code>，在<code class="du lw lx ly lz b">Bot Token Scopes</code>下点击<code class="du lw lx ly lz b">Add an OAuth Scope</code>。我们需要的三个示波器是<code class="du lw lx ly lz b">channels:read</code>、<code class="du lw lx ly lz b">chat:write</code>和<code class="du lw lx ly lz b">groups:read</code>。</p><figure class="le lf lg lh fd li er es paragraph-image"><div role="button" tabindex="0" class="lj lk di ll bf lm"><div class="er es nj"><img src="../Images/165ac839b339a3aa21a4d8fffdeb15c9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*shdO2rszxJM4ewgODdn5fA@2x.png"/></div></div></figure><p id="dd80" class="pw-post-body-paragraph jt ju hi jv b jw kq jy jz ka kr kc kd ke ks kg kh ki kt kk kl km ku ko kp ip hb bi translated">如果你想定制你的机器人的外观，使用侧边栏导航到<code class="du lw lx ly lz b">Basic Information</code>页面。向下滚动到<code class="du lw lx ly lz b">Display Information</code>。在这里，您可以更改应用程序名称、添加描述、更改颜色以及添加应用程序图标。</p><figure class="le lf lg lh fd li er es paragraph-image"><div role="button" tabindex="0" class="lj lk di ll bf lm"><div class="er es nk"><img src="../Images/a68f0722548f41ca7fd3b80db29c6a38.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vAxicKUhEqImHb8Jdf5GbQ@2x.png"/></div></div></figure><p id="ba60" class="pw-post-body-paragraph jt ju hi jv b jw kq jy jz ka kr kc kd ke ks kg kh ki kt kk kl km ku ko kp ip hb bi translated">bot 的下一步是将其安装到工作区。导航至<code class="du lw lx ly lz b">Install App</code>。你会看到你的<code class="du lw lx ly lz b">Bot User OAuth Token</code>和下面的按钮<code class="du lw lx ly lz b">Install to Workspace</code>。点击那个，现在，我们只需要得到<code class="du lw lx ly lz b">channel id</code>。打开 Slack 桌面应用程序，添加您刚刚创建的新应用程序。安装完成后，右击频道，选择<code class="du lw lx ly lz b">Copy Link</code>，粘贴到某个地方。它可能是 Slackbot 频道中的文本框。<code class="du lw lx ly lz b">/archives/</code>后的字母数字字符串就是<code class="du lw lx ly lz b">channel id</code>。将它添加到您的 GitHub secrets 中，以便在通知步骤中用作<code class="du lw lx ly lz b">${{ secrets.SLACK_CHANNEL_ID }}</code>。成功通知将如下图所示。</p><figure class="le lf lg lh fd li er es paragraph-image"><div role="button" tabindex="0" class="lj lk di ll bf lm"><div class="er es nl"><img src="../Images/7a2bc22787a8649decf7feabff2f1e24.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oS1g0PCoXtRelzpqDJjG4w@2x.png"/></div></div></figure><p id="e2d3" class="pw-post-body-paragraph jt ju hi jv b jw kq jy jz ka kr kc kd ke ks kg kh ki kt kk kl km ku ko kp ip hb bi translated">试一试，看看会发生什么。可以查看<a class="ae kv" href="https://github.com/starlightromero/TINFA-GH-Actions" rel="noopener ugc nofollow" target="_blank">回购</a>，查看<a class="ae kv" href="https://tinfa-gh-actions.herokuapp.com" rel="noopener ugc nofollow" target="_blank">部署 app </a>。</p><h2 id="19f2" class="mp iw hi bd ix mq mr ms jb mt mu mv jf ke mw mx jj ki my mz jn km na nb jr nc bi translated">切尔莱西</h2><p id="8e9f" class="pw-post-body-paragraph jt ju hi jv b jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp ip hb bi translated">另一个 CI/CD 工具是 CircleCI。在继续之前，注册 CircleCI 并连接您的 GitHub 帐户。如果你在这方面遇到麻烦，请查看<a class="ae kv" href="https://circleci.com/docs/2.0/first-steps/" rel="noopener ugc nofollow" target="_blank"> Circle CI 文档</a>。</p><p id="9867" class="pw-post-body-paragraph jt ju hi jv b jw kq jy jz ka kr kc kd ke ks kg kh ki kt kk kl km ku ko kp ip hb bi translated">就像 GH Actions 使用我们可以使用的预定义动作一样，CircleCI 使用 orb。我们将使用 Node、Slack 和 Heroku obs。你可以在这里找到可用的球体以及如何使用它们<a class="ae kv" href="https://circleci.com/developer/orbs" rel="noopener ugc nofollow" target="_blank">。</a></p><blockquote class="kw kx ky"><p id="5951" class="jt ju kz jv b jw kq jy jz ka kr kc kd la ks kg kh lb kt kk kl lc ku ko kp ip hb bi translated">rbs 是可重用的代码片段，有助于自动化重复的过程，加速项目设置，并使其易于与第三方工具集成。</p></blockquote><p id="dc64" class="pw-post-body-paragraph jt ju hi jv b jw kq jy jz ka kr kc kd ke ks kg kh ki kt kk kl km ku ko kp ip hb bi translated">在进入我们的<code class="du lw lx ly lz b">yml</code>文件之前，我们需要创建目录<code class="du lw lx ly lz b">.circleci</code>。在目录中我们可以创建<code class="du lw lx ly lz b">config.yml</code>。CircleCI 专门在<code class="du lw lx ly lz b">.circleci</code>目录中查找文件<code class="du lw lx ly lz b">config.yml</code>。</p><p id="0ed7" class="pw-post-body-paragraph jt ju hi jv b jw kq jy jz ka kr kc kd ke ks kg kh ki kt kk kl km ku ko kp ip hb bi translated">在我们的<code class="du lw lx ly lz b">yml</code>文件的顶部，我们将版本设置为 2.1。这很重要，因为<code class="du lw lx ly lz b">orbs</code>、<code class="du lw lx ly lz b">parameters</code>和<code class="du lw lx ly lz b">executors</code>都需要 2.1 版。接下来，我们定义我们的执行者。这仅仅意味着运行作业步骤的环境。我们可以选择在 machine、macos、windows 或 docker 上运行它。我们会选择 docker。</p><p id="0233" class="pw-post-body-paragraph jt ju hi jv b jw kq jy jz ka kr kc kd ke ks kg kh ki kt kk kl km ku ko kp ip hb bi translated">在定义 orb 之后，我们可以继续定义工作流。CircleCI 类似于 GH Actions，因为它的工作流包含包含步骤的作业。工作流在版本 2 上运行，名称为<code class="du lw lx ly lz b">test-build-and-deploy</code>。我们将有两个职位<code class="du lw lx ly lz b">test</code>和<code class="du lw lx ly lz b">build-deploy</code>。<code class="du lw lx ly lz b">test</code>设置一个上下文 Slack，它将使我们能够发送通知。接下来，我们过滤作业，使它只在<code class="du lw lx ly lz b">development</code>和<code class="du lw lx ly lz b">production</code>分支上运行。然后，我们在 Linux 操作系统上设置不同节点版本的矩阵。</p><p id="1087" class="pw-post-body-paragraph jt ju hi jv b jw kq jy jz ka kr kc kd ke ks kg kh ki kt kk kl km ku ko kp ip hb bi translated">进入<code class="du lw lx ly lz b">test</code>工作，我们设置参数。执行器将在我们在工作流部分定义的矩阵上运行。这些步骤包括检查代码、安装特定的节点版本、安装依赖项、测试代码，然后在出现任何故障时发送 Slack 通知。</p><p id="26b3" class="pw-post-body-paragraph jt ju hi jv b jw kq jy jz ka kr kc kd ke ks kg kh ki kt kk kl km ku ko kp ip hb bi translated">回到我们的工作流程，我们可以定义下一个任务<code class="du lw lx ly lz b">build-deploy</code>。需要<code class="du lw lx ly lz b">test</code>先跑。我们将上下文设置为 Slack，并且只过滤到<code class="du lw lx ly lz b">production</code>的分支。</p><p id="f110" class="pw-post-body-paragraph jt ju hi jv b jw kq jy jz ka kr kc kd ke ks kg kh ki kt kk kl km ku ko kp ip hb bi translated">在<code class="du lw lx ly lz b">build-deploy</code>作业中，我们初始化 Docker，因为我们稍后将需要它来构建我们的映像。在这些步骤中，我们检查代码，设置 Docker，安装 Heroku，构建映像并将其推送到 Heroku，然后发布映像。最后，我们通知成功或失败。</p><figure class="le lf lg lh fd li"><div class="bz dy l di"><div class="nd ne l"/></div></figure><p id="f46b" class="pw-post-body-paragraph jt ju hi jv b jw kq jy jz ka kr kc kd ke ks kg kh ki kt kk kl km ku ko kp ip hb bi translated">CircleCI 为我们提供了一个很好的可视化管道流动的方式，如下图所示。我们所有的测试都是并行运行的。在所有测试成功之后，我们接着进行构建和部署。</p><figure class="le lf lg lh fd li er es paragraph-image"><div role="button" tabindex="0" class="lj lk di ll bf lm"><div class="er es nm"><img src="../Images/7635e084916fbe5ce45fcba6ac654fa0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AGiLeYPeuKP2gRHS3ZbpNQ@2x.png"/></div></div></figure><h2 id="62e8" class="mp iw hi bd ix mq mr ms jb mt mu mv jf ke mw mx jj ki my mz jn km na nb jr nc bi translated">CircleCI 中的环境变量是如何工作的？</h2><figure class="le lf lg lh fd li er es paragraph-image"><div role="button" tabindex="0" class="lj lk di ll bf lm"><div class="er es nn"><img src="../Images/e93157ab1b108af8135538878c43e1f5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JjcTcFpq8FAEQFmqD_1Pcw@2x.png"/></div></div></figure><p id="3f95" class="pw-post-body-paragraph jt ju hi jv b jw kq jy jz ka kr kc kd ke ks kg kh ki kt kk kl km ku ko kp ip hb bi translated">登录并确保您的项目被选中后，我们可以点击<code class="du lw lx ly lz b">Project Settings</code>。在左侧，我们可以点击<code class="du lw lx ly lz b">Environment Variables</code>。一旦我们添加了环境变量，我们就可以通过在关键字前加前缀<code class="du lw lx ly lz b">PROJECT_</code>在<code class="du lw lx ly lz b">yml</code>文件中使用它们。如果我想访问我的<code class="du lw lx ly lz b">MONGODB_URI</code>，我们可以使用<code class="du lw lx ly lz b">PROJECT_MONGODB_URI</code>来完成。我们必须给它加上前缀，因为这些变量不同于定义为上下文的变量，也不同于在步骤或作业中定义的变量。</p><p id="41a6" class="pw-post-body-paragraph jt ju hi jv b jw kq jy jz ka kr kc kd ke ks kg kh ki kt kk kl km ku ko kp ip hb bi translated">注意<code class="du lw lx ly lz b">PROJECT_MONGODB_URI</code>在<code class="du lw lx ly lz b">yml</code>文件中是怎么找不到的。这是因为它在终端中的作用类似于导出变量。当运行测试或构建图像时，代码将自动寻找变量，因为它对整个项目都是可访问的。这与我们必须明确说明在给定的步骤中哪些环境变量是可用的 GH 行为正好相反。</p><h2 id="7e55" class="mp iw hi bd ix mq mr ms jb mt mu mv jf ke mw mx jj ki my mz jn km na nb jr nc bi translated">通知</h2><p id="841b" class="pw-post-body-paragraph jt ju hi jv b jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp ip hb bi translated">设置一个 Slackbot 将类似于 GH 动作。有关更多详细信息，请参见该部分。我们将在<code class="du lw lx ly lz b">OAuth &amp; Permissions</code>做一点小小的改动。我们将为<code class="du lw lx ly lz b">chat:write</code>、<code class="du lw lx ly lz b">chat:write.public</code>和<code class="du lw lx ly lz b">files:write</code>添加<code class="du lw lx ly lz b">OAuth Scopes</code>。</p><figure class="le lf lg lh fd li er es paragraph-image"><div role="button" tabindex="0" class="lj lk di ll bf lm"><div class="er es no"><img src="../Images/bb60ced0e06d6efaf448ce5d3f81411d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Hka__Hi9Vvyd1MRh4JQt7g@2x.png"/></div></div></figure><p id="9d38" class="pw-post-body-paragraph jt ju hi jv b jw kq jy jz ka kr kc kd ke ks kg kh ki kt kk kl km ku ko kp ip hb bi translated">我们可以设置一个频道，但省略它，默认频道将是 Slackbot 应用程序频道。我们需要做的就是添加 API key，将其设置为项目中的环境变量，并在<code class="du lw lx ly lz b">yml</code>文件中定义 API key。默认的成功通知将如下图所示。您可以阅读<a class="ae kv" href="https://circleci.com/developer/orbs/orb/circleci/slack" rel="noopener ugc nofollow" target="_blank"> Slack orb 文档</a>以获得定义自定义通知的指导。</p><figure class="le lf lg lh fd li er es paragraph-image"><div role="button" tabindex="0" class="lj lk di ll bf lm"><div class="er es np"><img src="../Images/9ed87402f8aa9577bc81e2c7539939b8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7uFek05AS-Zq96WdiAfrGQ@2x.png"/></div></div></figure><p id="aa7b" class="pw-post-body-paragraph jt ju hi jv b jw kq jy jz ka kr kc kd ke ks kg kh ki kt kk kl km ku ko kp ip hb bi translated">要在 Heroku 上设置，请参考 GitHub 操作部分。以下是<a class="ae kv" href="https://github.com/starlightromero/TINFA-circle-ci" rel="noopener ugc nofollow" target="_blank"> GitHub repo </a>和<a class="ae kv" href="https://tinfa-circle-ci.herokuapp.com/" rel="noopener ugc nofollow" target="_blank">部署应用</a>的链接。</p><h2 id="c4a0" class="mp iw hi bd ix mq mr ms jb mt mu mv jf ke mw mx jj ki my mz jn km na nb jr nc bi translated">特拉维斯奇</h2><p id="1ab5" class="pw-post-body-paragraph jt ju hi jv b jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp ip hb bi translated">首先，我将我的 GitHub 帐户连接到 TravisCI，并授予 OAuth 权限。TravisCI 在<code class="du lw lx ly lz b">.travis.yml</code>文件中查找构建配置。我建议查看文档<a class="ae kv" href="https://docs.travis-ci.com/user/tutorial/#to-get-started-with-travis-ci-using-github" rel="noopener ugc nofollow" target="_blank">这里</a>开始，查看<a class="ae kv" href="https://github.com/travis-ci/travis.rb#readme" rel="noopener ugc nofollow" target="_blank">这里</a>CLI。</p><p id="2a0c" class="pw-post-body-paragraph jt ju hi jv b jw kq jy jz ka kr kc kd ke ks kg kh ki kt kk kl km ku ko kp ip hb bi translated">首先我们定义了<code class="du lw lx ly lz b">os: linux</code>和 Linux(读作 Ubuntu)发行版<code class="du lw lx ly lz b">focal</code>，这只是 Ubuntu 20.04 的发布名称。接下来，我们将语言定义为 node as 集合版本矩阵。我们将 docker 设置为服务，这样我们就可以在管道中访问它。</p><h2 id="e0e0" class="mp iw hi bd ix mq mr ms jb mt mu mv jf ke mw mx jj ki my mz jn km na nb jr nc bi translated">通知</h2><p id="9df9" class="pw-post-body-paragraph jt ju hi jv b jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp ip hb bi translated">TravisCI 的通知将与我们为 GH Actions 和 CircleCI 配置的不同。配置松弛通知需要一些工作，但是我能够遵循<a class="ae kv" href="https://docs.travis-ci.com/user/notifications/#configuring-slack-notifications" rel="noopener ugc nofollow" target="_blank">文档</a>。通知不会出现在在<code class="du lw lx ly lz b">yml</code>文件中配置的频道中，如 GH Actions 或 CircleCI。相反，在登录 Slack 后，您将进入一个页面，在这里您可以配置发布到哪个频道。</p><figure class="le lf lg lh fd li er es paragraph-image"><div role="button" tabindex="0" class="lj lk di ll bf lm"><div class="er es nq"><img src="../Images/2da89736a017907f87bdbd4e7ef23d29.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ByFgVLGF9hJcPN9i_Uwg1A@2x.png"/></div></div></figure><p id="89f0" class="pw-post-body-paragraph jt ju hi jv b jw kq jy jz ka kr kc kd ke ks kg kh ki kt kk kl km ku ko kp ip hb bi translated">您需要确保使用 CLI 命令<code class="du lw lx ly lz b">travis encrypt "&lt;account&gt;:&lt;token&gt;" --add notifications.slack -- pro</code>对<code class="du lw lx ly lz b">account:token</code>进行加密。请注意，我们没有指定房间/频道。这是因为如果没有指定房间/频道，TravisCI 会自动向您发送通知。使用 travis-ci.com 作为 API 端点需要使用<code class="du lw lx ly lz b">--pro</code>命令。默认的终点是 travis-ci.org，TravisCI 已经声明他们正在远离这个地方。</p><p id="aa90" class="pw-post-body-paragraph jt ju hi jv b jw kq jy jz ka kr kc kd ke ks kg kh ki kt kk kl km ku ko kp ip hb bi translated">成功通知将如下图所示。</p><figure class="le lf lg lh fd li er es paragraph-image"><div role="button" tabindex="0" class="lj lk di ll bf lm"><div class="er es nr"><img src="../Images/407c4575e3e53df503941cfc9bd52ee7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fqncgIyeAJliaXFFCcUKoA@2x.png"/></div></div></figure><h2 id="33cf" class="mp iw hi bd ix mq mr ms jb mt mu mv jf ke mw mx jj ki my mz jn km na nb jr nc bi translated">构建阶段</h2><p id="ad3f" class="pw-post-body-paragraph jt ju hi jv b jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp ip hb bi translated">对于脚本，我们运行<code class="du lw lx ly lz b">npm test</code>。我们之前定义的节点版本矩阵将用于在每个版本上运行脚本。在脚本之后，我们定义了<code class="du lw lx ly lz b">jobs</code>，这是我们的部署阶段。我们选择跳过脚本。这一行很重要<em class="kz">，因为我们不想重新运行任何测试。</em>脚本和作业的分离允许测试运行四次(每个节点版本一次),但只部署一次。这就是特拉维斯奇所说的“构建阶段”。您可以在<a class="ae kv" href="https://docs.travis-ci.com/user/build-stages/" rel="noopener ugc nofollow" target="_blank">文档</a>中了解更多关于构建阶段的信息。</p><figure class="le lf lg lh fd li er es paragraph-image"><div role="button" tabindex="0" class="lj lk di ll bf lm"><div class="er es ns"><img src="../Images/9cfd92f402266b050edc6ad1b04768b3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sysAVF-kJGPxsYZzC-p8oQ@2x.png"/></div></div></figure><p id="837f" class="pw-post-body-paragraph jt ju hi jv b jw kq jy jz ka kr kc kd ke ks kg kh ki kt kk kl km ku ko kp ip hb bi translated">在部署作业中，我们希望部署到 Heroku。我们可以使用 CLI 通过命令<code class="du lw lx ly lz b">travis encrypt $(heroku auth:token) --add deploy.api_key --pro</code>来加密<code class="du lw lx ly lz b">api_key</code>。我们选择只在<code class="du lw lx ly lz b">production</code>分支上部署，然而测试矩阵将在所有分支上运行。最后，我们跳过任何清理。通过防止 Travis 重置工作目录，这允许<a class="ae kv" href="https://docs.travis-ci.com/user/deployment/#uploading-files-and-skip_cleanup" rel="noopener ugc nofollow" target="_blank">稍微优化管道</a>。</p><p id="f1d0" class="pw-post-body-paragraph jt ju hi jv b jw kq jy jz ka kr kc kd ke ks kg kh ki kt kk kl km ku ko kp ip hb bi translated">我们的<code class="du lw lx ly lz b">MONGODB_URI</code>环境变量呢？在 Travis dashboard 中，单击“更多选项”&gt;设置会将我们带到一个页面，在这里我们可以定义我们的环境变量。如果该值包含空格或特殊字符，请务必用引号括起来。我忘了用引号将<code class="du lw lx ly lz b">MONGODB_URI</code>括起来，这使得我的测试失败。相信我，加上引号，这个花了太长时间(几周)来调试。</p><figure class="le lf lg lh fd li er es paragraph-image"><div role="button" tabindex="0" class="lj lk di ll bf lm"><div class="er es nt"><img src="../Images/e391ce0f2b2033cb67def48928492f16.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wk4nQqxkEjl4mXBfWifz9Q@2x.png"/></div></div></figure><p id="e391" class="pw-post-body-paragraph jt ju hi jv b jw kq jy jz ka kr kc kd ke ks kg kh ki kt kk kl km ku ko kp ip hb bi translated">更多关于使用 TravisCI <a class="ae kv" href="https://docs.travis-ci.com/user/deployment/heroku/" rel="noopener ugc nofollow" target="_blank">部署到 Heroku 的信息，请点击</a>。</p><figure class="le lf lg lh fd li"><div class="bz dy l di"><div class="nd ne l"/></div></figure><p id="65a6" class="pw-post-body-paragraph jt ju hi jv b jw kq jy jz ka kr kc kd ke ks kg kh ki kt kk kl km ku ko kp ip hb bi translated">我们必须包含 Travis 的另一个文件是<code class="du lw lx ly lz b">heroku.yml</code>。这个文件声明了如何为部署构建 docker 容器。我们选择用 Docker 构建，并将 web build <code class="du lw lx ly lz b">Dockerfile</code>定义在与<code class="du lw lx ly lz b">heroku.yml</code>相同的目录中。如果<code class="du lw lx ly lz b">Dockerfile</code>在子目录中，我们将在第 3 行定义路径。最后，我们将配置设置为包含生产中所需的任何环境变量:</p><figure class="le lf lg lh fd li"><div class="bz dy l di"><div class="nd ne l"/></div></figure><p id="3ab4" class="pw-post-body-paragraph jt ju hi jv b jw kq jy jz ka kr kc kd ke ks kg kh ki kt kk kl km ku ko kp ip hb bi translated">要在 Heroku 上设置，请参考 GitHub 操作部分。请随意查看<a class="ae kv" href="https://github.com/starlightromero/TINFA-travis-ci" rel="noopener ugc nofollow" target="_blank"> GitHub 回购</a>和<a class="ae kv" href="https://tinfa-travis-ci.herokuapp.com/" rel="noopener ugc nofollow" target="_blank">现场</a>。</p><h1 id="4f7e" class="iv iw hi bd ix iy iz ja jb jc jd je jf jg lt ji jj jk lu jm jn jo lv jq jr js bi translated">比较工具</h1><p id="51f3" class="pw-post-body-paragraph jt ju hi jv b jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp ip hb bi translated">每个工具都有自己的设置和配置挑战。就难度而言，我会说 GH Actions 是最容易配置的，而 TravisCI 是最难的。</p><p id="1723" class="pw-post-body-paragraph jt ju hi jv b jw kq jy jz ka kr kc kd ke ks kg kh ki kt kk kl km ku ko kp ip hb bi translated">TravisCI 有点难，因为它要求你安装 Ruby，以便安装 TravisCI CLI，从而加密某些环境变量。我很欣赏 CircleCI 和 GitHub 在 web 应用程序中处理这些问题的做法。尽管我会说，与 GH Actions 需要的两个单独的<code class="du lw lx ly lz b">yml</code>文件相比，我很欣赏 TravisCI 简洁的<code class="du lw lx ly lz b">yml</code>文件。</p><p id="83ee" class="pw-post-body-paragraph jt ju hi jv b jw kq jy jz ka kr kc kd ke ks kg kh ki kt kk kl km ku ko kp ip hb bi translated">CircleCI 在难度、简洁性和配置能力方面处于中间位置。</p><p id="fa79" class="pw-post-body-paragraph jt ju hi jv b jw kq jy jz ka kr kc kd ke ks kg kh ki kt kk kl km ku ko kp ip hb bi translated">总的来说，我认为这三个都是很好的工具，可以极大地改进测试和部署应用程序的过程。以我现在的知识，我可能可以在更短的时间内设置和配置一个管道。</p><h1 id="f743" class="iv iw hi bd ix iy iz ja jb jc jd je jf jg lt ji jj jk lu jm jn jo lv jq jr js bi translated">反思改进</h1><p id="f887" class="pw-post-body-paragraph jt ju hi jv b jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp ip hb bi translated">正如我在本文开头提到的，我希望在不久的将来扩展到包括更多的管道。至于对现有管道的改进，我能想到几个。最好先构建 Docker 映像，然后在容器中测试代码。这可以消除在 Docker 容器中从一个节点环境到另一个节点环境的不一致。构建&gt;测试&gt;部署&gt;发布。</p><p id="dc38" class="pw-post-body-paragraph jt ju hi jv b jw kq jy jz ka kr kc kd ke ks kg kh ki kt kk kl km ku ko kp ip hb bi translated">缓存会缩短构建时间。每次管道运行都要重新开始。TravisCI 有<code class="du lw lx ly lz b">skip_cleanup</code>，但是与缓存构建映像相比，这也只是一个很小的改进。例如，在包含八个步骤的 docker 文件中，我们可以假设大部分时间我们的基本映像和依赖项不会经常改变。通过缓存这些层，我们将能够从第六步开始。</p><p id="2b9f" class="pw-post-body-paragraph jt ju hi jv b jw kq jy jz ka kr kc kd ke ks kg kh ki kt kk kl km ku ko kp ip hb bi translated">安全是我的一大兴趣。测试代码的安全缺陷，并进一步测试容器的安全缺陷，也许使用<a class="ae kv" href="https://snyk.io/" rel="noopener ugc nofollow" target="_blank"> Snyk </a>，将是一个很大的改进。这将确保即使我们的代码在工作，我们也不会部署任何可能危及用户或任何数据的代码或容器。</p><p id="22eb" class="pw-post-body-paragraph jt ju hi jv b jw kq jy jz ka kr kc kd ke ks kg kh ki kt kk kl km ku ko kp ip hb bi translated">最后一个更具挑战性的改进是在 IaaS 而不是 PaaS 服务上部署容器。我还没有研究过这个，但是我认为我们必须自己写脚本来做这件事，而不是回复预先构建的球体/动作等。</p><figure class="le lf lg lh fd li"><div class="bz dy l di"><div class="nu ne l"/></div></figure><p id="6f9e" class="pw-post-body-paragraph jt ju hi jv b jw kq jy jz ka kr kc kd ke ks kg kh ki kt kk kl km ku ko kp ip hb bi translated">你不只是一个梦想家。我希望这篇文章能帮助你进入 CI/CD 管道，并给你一个良好的开端，为你所有的应用程序创建你自己独特的管道。</p></div></div>    
</body>
</html>