<html>
<head>
<title>Scope in JavaScript (variables, hoisting, closures)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript 中的作用域(变量、提升、闭包)</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/scope-in-javascript-variables-hoisting-closures-afaa9a98d3?source=collection_archive---------5-----------------------#2021-02-17">https://medium.com/nerd-for-tech/scope-in-javascript-variables-hoisting-closures-afaa9a98d3?source=collection_archive---------5-----------------------#2021-02-17</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/91b0222c9d3f7f001a96b6af6d9d3871.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*D8HuorcPO9ZKKgoP8WNy8g.png"/></div></div></figure><p id="9543" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">理解范围对于避免在编码时可能不明显但会在以后造成大问题的问题是非常重要的。这也可能会有点混乱，所以我写这篇文章是为了让我和其他人更清楚。</p><p id="bc3f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我将讨论变量、提升和闭包。</p><h1 id="b3f3" class="jo jp hi bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated"><strong class="ak">什么是范围？</strong></h1><p id="ccfd" class="pw-post-body-paragraph iq ir hi is b it km iv iw ix kn iz ja jb ko jd je jf kp jh ji jj kq jl jm jn hb bi translated">在一本正规的字典里，你会得到这样的关于范围的定义:<em class="kr">某事物处理的或与之相关的领域或主题的范围。在 JavaScript 中，同样定义是有效的。在代码中声明变量的位置将决定如何以及从哪里访问它们。</em></p><p id="0b22" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">JavaScript 中有两种类型的作用域:全局和局部。</p><p id="f067" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">全局范围是在块或函数外部声明的。对于 JavaScript，在浏览器上运行 JavaScript 时的全局范围是“窗口”。</p><h1 id="a70f" class="jo jp hi bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">变量</h1><p id="e9d6" class="pw-post-body-paragraph iq ir hi is b it km iv iw ix kn iz ja jb ko jd je jf kp jh ji jj kq jl jm jn hb bi translated">在 JavaScript 中声明变量有不同的方式，我们如何做(不仅仅是在哪里)将影响它们的范围。那三种方式分别是<code class="du ks kt ku kv b"><strong class="is hj">var</strong></code> <strong class="is hj">、</strong>、<code class="du ks kt ku kv b"><strong class="is hj">let</strong></code>、、<strong class="is hj">、</strong>、<code class="du ks kt ku kv b"><strong class="is hj">const</strong></code>、<strong class="is hj">。就作用域而言，</strong> <code class="du ks kt ku kv b">Const</code> <strong class="is hj"> </strong>类似于<code class="du ks kt ku kv b">let</code>，不同之处在于你不能改变用 const(常量)声明的变量的值。</p><p id="0419" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">看看下面的代码，我们可以在一个函数中设置<code class="du ks kt ku kv b">var a</code>，也可以在该函数的一个块中设置。</p><pre class="kw kx ky kz fd la kv lb lc aw ld bi"><span id="ca54" class="le jp hi kv b fi lf lg l lh li">function f (){<br/>    <strong class="kv hj">var a = "a";</strong></span><span id="ef25" class="le jp hi kv b fi lj lg l lh li">    if (1 === 1){        <br/>        <strong class="kv hj">var a = "AA";</strong>    <br/>        console.log(a);<br/>    }    <br/>    console.log(a);<br/>}</span><span id="e518" class="le jp hi kv b fi lj lg l lh li">f();</span></pre><p id="ddc6" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">当我们调用该函数时，两个 console.logs 都将输出相同的内容:“AA”。<strong class="is hj">这是因为</strong> <code class="du ks kt ku kv b"><strong class="is hj">var</strong></code> <strong class="is hj">没有提供块作用域</strong>，所以 if 块内的<code class="du ks kt ku kv b">var a</code>实际上是在覆盖 if 块外的。</p><p id="3cc6" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">当我们在相同的代码上使用<code class="du ks kt ku kv b">let</code>而不是<code class="du ks kt ku kv b">var</code>时会发生什么？</p><pre class="kw kx ky kz fd la kv lb lc aw ld bi"><span id="01e3" class="le jp hi kv b fi lf lg l lh li">function f (){</span><span id="65c7" class="le jp hi kv b fi lj lg l lh li"><strong class="kv hj">    let a = "a";</strong><br/>    if (1 === 1){        <br/>        <strong class="kv hj">let a = "AA";</strong>    <br/>        console.log(a);<br/>    }    <br/>    console.log(a);<br/>}</span><span id="5d2e" class="le jp hi kv b fi lj lg l lh li">f();</span></pre><p id="bd82" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在，console.logs 将打印“AA”和“a”。<strong class="is hj">用</strong> <code class="du ks kt ku kv b"><strong class="is hj">let</strong></code> <strong class="is hj">声明变量将允许块范围</strong>。<code class="du ks kt ku kv b">Let</code>是 JavaScript 中较新的东西，所以有很多代码使用<code class="du ks kt ku kv b">var</code>来声明变量。但是，向前看，最好使用<code class="du ks kt ku kv b">let</code>或<code class="du ks kt ku kv b">const</code>。</p><p id="df4e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">函数外和函数内的一个<code class="du ks kt ku kv b">var</code>怎么样？</p><pre class="kw kx ky kz fd la kv lb lc aw ld bi"><span id="01ea" class="le jp hi kv b fi lf lg l lh li"><strong class="kv hj">var a = "A";</strong></span><span id="429d" class="le jp hi kv b fi lj lg l lh li">function f (){<br/>    <strong class="kv hj">var a = "B";</strong><br/>    if (1 === 1){<br/>        <strong class="kv hj">var a = "C";  </strong>  <br/>        console.log(a);<br/>    }    <br/>    console.log(a);<br/>}</span><span id="41f1" class="le jp hi kv b fi lj lg l lh li">f();<br/>console.log(a);</span></pre><p id="f9f9" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">上面的代码将打印:“C”，“C”，“A”。所以函数内部的代码和我们之前看到的一样，第二个赋值(“C”)覆盖了第一个(“B”)。但是，在函数外部声明的函数保留了它的原始值。</p><p id="d8fd" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在上面的代码中使用 let 而不是<code class="du ks kt ku kv b">var</code>会使每个“a”都有自己的作用域，所以这三个都将保留它们的初始值。</p><p id="6cc1" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">上述代码中在函数外部声明的变量具有全局范围，可以从网页上的所有脚本和函数中访问。</p><p id="4bde" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">当使用 JavaScript 时，确保在使用变量之前声明它们，因为如果你忘记声明一个变量而只是赋值，你将会创建全局变量。请注意以下代码之间的差异，如果没有在函数外部定义，这些代码将引发错误:</p><pre class="kw kx ky kz fd la kv lb lc aw ld bi"><span id="382c" class="le jp hi kv b fi lf lg l lh li">function f (){<br/>    <strong class="kv hj">var a = "B";</strong><br/>}</span><span id="15c6" class="le jp hi kv b fi lj lg l lh li">f();<br/>console.log(a);</span></pre><p id="dea5" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这段代码将工作并显示“B ”,因为 JavaScript 用<code class="du ks kt ku kv b">a=”B”</code>语句将变量声明为全局变量。<strong class="is hj">在 JavaScript 中，已赋值但未声明的变量将被声明为全局变量。</strong></p><pre class="kw kx ky kz fd la kv lb lc aw ld bi"><span id="6bbe" class="le jp hi kv b fi lf lg l lh li">function f (){<br/>    <strong class="kv hj">a = "B";</strong><br/>}</span><span id="7566" class="le jp hi kv b fi lj lg l lh li">f();<br/>console.log(a);</span></pre><p id="22d6" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">但是，您可以将代码设置为使用严格模式，在这种情况下，JavaScript 不会将变量创建为全局变量，而是会得到一个错误:</p><pre class="kw kx ky kz fd la kv lb lc aw ld bi"><span id="29aa" class="le jp hi kv b fi lf lg l lh li"><strong class="kv hj">"use strict";</strong></span><span id="48ca" class="le jp hi kv b fi lj lg l lh li">function f (){<br/>    a = "B";<br/>}</span><span id="5e13" class="le jp hi kv b fi lj lg l lh li">f();<br/>console.log(a);</span></pre><p id="ea5c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">注意:只有在真正需要的时候才使用全局变量。</p><p id="586d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">传递给函数的参数充当函数的局部变量。</p><pre class="kw kx ky kz fd la kv lb lc aw ld bi"><span id="0b98" class="le jp hi kv b fi lf lg l lh li">function fa (<strong class="kv hj">a</strong>){    <br/>    if (1===1){<br/>        <strong class="kv hj">var a ="C"</strong>;<br/>        console.log(<strong class="kv hj">a</strong>);<br/>    }<br/>    console.log(<strong class="kv hj">a</strong>);<br/>}</span><span id="16ca" class="le jp hi kv b fi lj lg l lh li">fa(<strong class="kv hj">"A"</strong>);</span></pre><p id="ff3d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">上面的代码将打印“C”和“C”。但是用<code class="du ks kt ku kv b">let</code>代替<code class="du ks kt ku kv b">var</code>:</p><pre class="kw kx ky kz fd la kv lb lc aw ld bi"><span id="1607" class="le jp hi kv b fi lf lg l lh li">function fa <strong class="kv hj">(a)</strong>{    <br/>    if (1===1){<br/>        <strong class="kv hj">let a ="C";</strong><br/>        console.log(a);<br/>    }<br/>    console.log(a);<br/>}</span><span id="b6b8" class="le jp hi kv b fi lj lg l lh li">fa(<strong class="kv hj">"A"</strong>);</span></pre><p id="5dd1" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">会打印“C”和“A”。</p><h1 id="f6bc" class="jo jp hi bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">提升</h1><p id="042c" class="pw-post-body-paragraph iq ir hi is b it km iv iw ix kn iz ja jb ko jd je jf kp jh ji jj kq jl jm jn hb bi translated">提升意味着 JavaScript 将变量或函数声明移动到它们上下文的顶部。这意味着在 JavaScript 中，函数和变量在声明之前就可以被访问。这个代码是可以的，它将打印 1。</p><pre class="kw kx ky kz fd la kv lb lc aw ld bi"><span id="b68b" class="le jp hi kv b fi lf lg l lh li">a = 1;<br/>console.log(a);</span><span id="e0b0" class="le jp hi kv b fi lj lg l lh li"><strong class="kv hj">var a; </strong></span></pre><p id="e4f7" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">注意，我们并不真的需要<code class="du ks kt ku kv b">var a</code>语句来运行代码，因为<code class="du ks kt ku kv b">a = 1</code>语句已经在全局范围内创建了一个变量。</p><p id="8d43" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">然而，如果我们像下面的代码那样使用<code class="du ks kt ku kv b"> let</code>而不是<code class="du ks kt ku kv b">var,</code>，我们将在<code class="du ks kt ku kv b">a=1</code>语句中得到一个引用错误(在初始化之前不能访问‘a’)。</p><pre class="kw kx ky kz fd la kv lb lc aw ld bi"><span id="6fb1" class="le jp hi kv b fi lf lg l lh li">a = 1;<br/>console.log(a);</span><span id="c877" class="le jp hi kv b fi lj lg l lh li"><strong class="kv hj">let a</strong>;</span></pre><p id="493d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">对于用</strong> <code class="du ks kt ku kv b"><strong class="is hj">let</strong></code> <strong class="is hj">或</strong> <code class="du ks kt ku kv b"><strong class="is hj">const</strong></code> <strong class="is hj">声明的变量，代码块<em class="kr">知道变量的</em>，</strong> <strong class="is hj">，但在声明</strong>之前不能使用。需要记住的一点是，在声明<code class="du ks kt ku kv b">let </code>之前使用它会导致错误，但是对<code class="du ks kt ku kv b">const </code>变量做同样的事情不会导致错误，但是它不会工作。</p><p id="4fb9" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj"> JavaScript 提升<em class="kr">声明</em>而不是<em class="kr">初始化</em> </strong>。这意味着这段代码将打印未定义的,因为变量就在那里，console.log 知道它，但不知道它的初始化:</p><pre class="kw kx ky kz fd la kv lb lc aw ld bi"><span id="5bd7" class="le jp hi kv b fi lf lg l lh li">console.log(a);</span><span id="e36f" class="le jp hi kv b fi lj lg l lh li"><strong class="kv hj">a = 1;</strong></span><span id="1d29" class="le jp hi kv b fi lj lg l lh li"><strong class="kv hj">var a;</strong></span></pre><p id="ede4" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在上面的代码中，<code class="du ks kt ku kv b">console.log(a)</code>知道有一个变量 a，并将它打印出来，但是对 1 的赋值还没有被提升，所以当<code class="du ks kt ku kv b">console.log </code>发生时，变量从<code class="du ks kt ku kv b">var a</code>开始被设置为未定义。</p><p id="cb0e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">以这种方式编码会产生问题，并使代码更难被其他人阅读，所以最好在使用变量之前声明它们。</p><h1 id="b3b8" class="jo jp hi bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">关闭</h1><p id="dc35" class="pw-post-body-paragraph iq ir hi is b it km iv iw ix kn iz ja jb ko jd je jf kp jh ji jj kq jl jm jn hb bi translated">正如我前面提到的，在函数外部声明的变量是全局变量，它们可以在网页上的任何地方被访问，所以，在函数内部，我们可以访问在全局范围内声明的变量。</p><p id="a40b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">此外，JavaScript 允许函数内部的函数(嵌套函数)。当一个函数在另一个函数中定义时，内部函数可以访问外部函数的变量范围。这就是函数闭包。</p><p id="a710" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><em class="kr">词法</em> <em class="kr">作用域</em>使用变量在源代码中声明的位置来确定该变量在哪里可用。在嵌套函数中，词法范围用于确定嵌套函数可以访问哪些变量。</p><p id="db5a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这里有一些例子来阐明这一点(请查看所有的例子来清楚地理解闭包)。</p><pre class="kw kx ky kz fd la kv lb lc aw ld bi"><span id="9057" class="le jp hi kv b fi lf lg l lh li">function <strong class="kv hj">outer()</strong> {</span><span id="1670" class="le jp hi kv b fi lj lg l lh li">  var name = 'Tiger';<br/>  function <strong class="kv hj">inner()</strong> { <br/>   console.log(name);<br/>  }<br/>}<br/>outer();</span></pre><p id="47fd" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">上面的代码是可以的，但是它不会打印任何东西，因为我们没有真正调用内部函数。</p><pre class="kw kx ky kz fd la kv lb lc aw ld bi"><span id="51bb" class="le jp hi kv b fi lf lg l lh li">function <strong class="kv hj">outer()</strong> {</span><span id="32cd" class="le jp hi kv b fi lj lg l lh li">  var name = 'Tiger';<br/>  function <strong class="kv hj">inner()</strong> { <br/>   console.log(name);<br/>  }</span><span id="df14" class="le jp hi kv b fi lj lg l lh li">  <strong class="kv hj">inner();</strong><br/>}<br/>outer();</span></pre><p id="6c2f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">上面会印“老虎”。</p><p id="31cb" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">此代码也将工作:</p><pre class="kw kx ky kz fd la kv lb lc aw ld bi"><span id="319f" class="le jp hi kv b fi lf lg l lh li">function <strong class="kv hj">outer()</strong> {</span><span id="1688" class="le jp hi kv b fi lj lg l lh li">   var name = 'Tiger';</span><span id="5708" class="le jp hi kv b fi lj lg l lh li">   <strong class="kv hj">inner();</strong><br/>  <br/>   function <strong class="kv hj">inner(</strong>) { <br/>     console.log(name);<br/>    }</span><span id="df28" class="le jp hi kv b fi lj lg l lh li">   <strong class="kv hj">inner();</strong><br/>}<br/><strong class="kv hj">outer();</strong></span></pre><p id="6012" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们在 outer 内部调用 inner 两次，一次在函数定义之前，一次在函数定义之后。它们都将工作，它将打印:“老虎”，“老虎”。</p><p id="ba3a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">请注意，inner 是在 outer 内部定义的，因此这段代码将不起作用。我们将得到一个内部未定义的错误。</p><pre class="kw kx ky kz fd la kv lb lc aw ld bi"><span id="bf55" class="le jp hi kv b fi lf lg l lh li">function outer() {</span><span id="5d25" class="le jp hi kv b fi lj lg l lh li">   var name = 'Tiger';</span><span id="10d4" class="le jp hi kv b fi lj lg l lh li">   function <strong class="kv hj">inner()</strong> { <br/>      console.log(name);<br/>   }</span><span id="ae47" class="le jp hi kv b fi lj lg l lh li">}<br/>outer();<br/><strong class="kv hj">inner();</strong></span></pre><p id="6c2c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">上面的例子很棒，但这不是我们从 JavaScript 闭包中得到的全部。</p><p id="9f0f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在上面的例子中，我们从外部函数内部调用内部函数，所以我们是在外部函数还在执行的时候调用的。但是如果外部函数返回内部函数，然后我们在外部函数完成后调用内部函数呢？</p><pre class="kw kx ky kz fd la kv lb lc aw ld bi"><span id="d83a" class="le jp hi kv b fi lf lg l lh li">function <strong class="kv hj">outer()</strong> {</span><span id="93e8" class="le jp hi kv b fi lj lg l lh li">   var name = 'Tiger';</span><span id="f00b" class="le jp hi kv b fi lj lg l lh li">   <strong class="kv hj">return function inner() { console.log(name)};</strong></span><span id="5d39" class="le jp hi kv b fi lj lg l lh li">}</span><span id="d1d5" class="le jp hi kv b fi lj lg l lh li">let <strong class="kv hj">f = outer(); //will get the inner function in the f variable</strong><br/>console.log("About to call the inner function that got returned from the outer function");<br/><strong class="kv hj">f();</strong></span></pre><p id="0b9b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">即使我们将返回的内部函数放在 f 变量中，并且外部函数已经完成，当我们用 f()调用它时，内部函数仍然可以访问那个名称值；这是因为闭包的缘故，闭包保持对函数被创建时可用的变量的访问。</p><p id="6a5c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在嵌套函数时，我们并不局限于一个层次。我们也可以有这个代码，它仍然会工作。</p><pre class="kw kx ky kz fd la kv lb lc aw ld bi"><span id="21fa" class="le jp hi kv b fi lf lg l lh li">function <strong class="kv hj">outer()</strong> {</span><span id="bed9" class="le jp hi kv b fi lj lg l lh li">   var name = 'Tiger';</span><span id="d856" class="le jp hi kv b fi lj lg l lh li">   function<strong class="kv hj"> inner()</strong> { <br/>       var name2 = " Are ";<br/>       <strong class="kv hj">return function inner2()</strong> {console.log(name + name2 +         "Awesome");}<br/>    };</span><span id="8ea5" class="le jp hi kv b fi lj lg l lh li">    <strong class="kv hj">return inner();</strong> //call inner, which returns a function and return it.</span><span id="8bcb" class="le jp hi kv b fi lj lg l lh li">}</span><span id="a0a3" class="le jp hi kv b fi lj lg l lh li">let <strong class="kv hj">f = outer();</strong></span><span id="a872" class="le jp hi kv b fi lj lg l lh li"><strong class="kv hj">f();</strong></span></pre><p id="3d71" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">上面的代码会打印出来:老虎很牛逼。</p><p id="0c9c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">谢谢你检查这个。我希望它有助于解释作用域在 JavaScript 上是如何工作的。</p><p id="f6ef" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我想过在这篇文章中加入“this”关键字，但我想我会在其他时间单独讨论这个问题。如果你认为它应该被包括在这里，请让我知道。</p></div></div>    
</body>
</html>