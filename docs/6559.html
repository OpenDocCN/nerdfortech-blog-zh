<html>
<head>
<title>Image Classification using Transfer Learning with PyTorch(Resnet18)❓</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">基于PyTorch(Resnet18)❓迁移学习的图像分类</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/image-classification-using-transfer-learning-pytorch-resnet18-32b642148cbe?source=collection_archive---------0-----------------------#2022-03-23">https://medium.com/nerd-for-tech/image-classification-using-transfer-learning-pytorch-resnet18-32b642148cbe?source=collection_archive---------0-----------------------#2022-03-23</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="abb8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在开始之前，你只需要有一些关于卷积神经网络和Jupyter-notebook的知识。众所周知，目前图像分类正变得越来越流行，其应用也在迅速增加。在本文中，我们将使用并学习如何使用PyTorch框架的预训练模型来实现自定义数据的图像分类模型。我们将从Jupyter-notebook开始，因为这是一个非常简单的数据分析和深度学习工具。此外，它有许多GUI选项，使工作变得容易。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es jd"><img src="../Images/05203afdaacebeee2da5f4ea25038113.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*eDUnZ26wfRuc7nahnA8ReA.gif"/></div></div><figcaption class="jp jq et er es jr js bd b be z dx translated"><strong class="bd jt"> RESNET18转学工作流程</strong></figcaption></figure><p id="d57d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="ju">自定义数据，这一点我在本文中要用到的可以在这里找到</em><a class="ae jv" href="https://drive.google.com/drive/folders/1Aid67MXI7ks0l3y3CsLv4om4n_5zG9dG?usp=sharing" rel="noopener ugc nofollow" target="_blank"><em class="ju"/></a><em class="ju">。只需下载并存储在特定的文件夹中。我已经解决了一个具体的格式，让我们开始实施，如果你将遵循一步一步的教程，那么将不会有任何错误。此外，确保您安装的Python版本≤3.7 </em></p></div><div class="ab cl jw jx gp jy" role="separator"><span class="jz bw bk ka kb kc"/><span class="jz bw bk ka kb kc"/><span class="jz bw bk ka kb"/></div><div class="hb hc hd he hf"><p id="6204" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">安装和使用</strong></p><p id="5d32" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">第一步</strong>:在某个驱动器中创建一个文件夹，即图像分类，在该文件夹中打开终端/命令提示符。现在，我们需要安装Jupyter笔记本(不需要安装Anaconda)，您可以使用下面的命令来安装笔记本。</p><p id="cabf" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> <em class="ju">对于Linux: </em> </strong></p><pre class="je jf jg jh fd kd ke kf kg aw kh bi"><span id="ba4c" class="ki kj hi ke b fi kk kl l km kn">sudo apt install python3-venv<br/>python3 -m venv imageclassificationvenvpytorch<br/>source imageclassificationvenvpytorch/bin/activate<br/>pip install --upgrade pip<br/>pip install jupyter</span></pre><p id="0eca" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> <em class="ju">针对Windows: </em> </strong></p><pre class="je jf jg jh fd kd ke kf kg aw kh bi"><span id="76ba" class="ki kj hi ke b fi kk kl l km kn">python3 -m venv imageclassificationvenvpytorch<br/>cd imageclassificationvenvpytorch<br/>cd Scripts<br/>activate<br/>cd ..<br/>python3 -m pip install --upgrade pip<br/>pip install jupyter</span></pre><p id="4921" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">第二步:</strong>现在，我们需要安装图像分类所需的包，然后才能导入并在笔记本中使用。您可以在已经打开的终端/命令提示符下使用以下命令来安装所需的模块。</p><pre class="je jf jg jh fd kd ke kf kg aw kh bi"><span id="8d54" class="ki kj hi ke b fi kk kl l km kn">pip install numpy<br/>pip install torch torchvision   <em class="ju">#(must be greater than 1.7, I used torch 1.10+cu11)</em><br/>pip install scikit-build<br/>pip install matplotlib</span></pre><p id="2272" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">第三步:</strong>现在，我们需要打开笔记本。您可以在已经打开的终端/命令提示符下使用下面的命令，在默认浏览器中打开笔记本。如果您尚未设置默认浏览器，您可以在终端/命令提示符下复制链接，并将其粘贴到浏览器中以运行笔记本。</p><pre class="je jf jg jh fd kd ke kf kg aw kh bi"><span id="8bdc" class="ki kj hi ke b fi kk kl l km kn">python -m notebook</span></pre><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es jd"><img src="../Images/6b777391ebc94dac5f3acc80af9d6e29.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MlL7-3INylV2f7cn8XfS8g.png"/></div></div></figure><p id="21b3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">上述命令将打开当前文件夹中的笔记本。</p><p id="7ff1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">步骤4: </strong>现在，我们需要创建一个笔记本，我们将在其中编写图像分类的代码，在笔记本的主页中，单击右上角的新建按钮，如图所示，并从下拉菜单中选择python3。这将在同一目录下创建一个新笔记本。</p><p id="e653" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">步骤5: </strong>如果步骤3成功完成，您将能够看到下图所示的屏幕。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es jd"><img src="../Images/a3858ff7f3c2a48fdc8a5cdef2c0fde2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jrbDc1fS0zl12mJjCFr_JA.png"/></div></div></figure></div><div class="ab cl jw jx gp jy" role="separator"><span class="jz bw bk ka kb kc"/><span class="jz bw bk ka kb kc"/><span class="jz bw bk ka kb"/></div><div class="hb hc hd he hf"><p id="0ace" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">基本步骤&amp;预处理</strong></p><p id="931b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">步骤6: </strong>您可以根据自己的选择更改笔记本的文件名。现在，我们需要导入图像分类所需的库。</p><pre class="je jf jg jh fd kd ke kf kg aw kh bi"><span id="21b9" class="ki kj hi ke b fi kk kl l km kn">import torch<br/>import torch.nn as nn<br/>import torch.optim as optim</span><span id="0a23" class="ki kj hi ke b fi ko kl l km kn">import torchvision<br/>from torchvision import datasets, models, transforms</span><span id="203d" class="ki kj hi ke b fi ko kl l km kn">import numpy as np<br/>import matplotlib.pyplot as plt<br/>import cv2<br/>import time<br/>import os</span><span id="bed7" class="ki kj hi ke b fi ko kl l km kn">device = torch.device("cuda:0" if torch.cuda.is_available() else "cpu") # device object</span></pre><p id="d584" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">步骤7: </strong>我们需要为我们的数据定义预处理，这将包括随机水平翻转、旋转、归一化等。图像大小必须为(224 * 224)，因为Resnet接受(224 * 224)的输入图像大小。</p><pre class="je jf jg jh fd kd ke kf kg aw kh bi"><span id="7d60" class="ki kj hi ke b fi kk kl l km kn">transforms_train = transforms.Compose([<br/>    transforms.Resize((224, 224)),   #must same as here<br/>    transforms.RandomResizedCrop(224),<br/>    transforms.RandomHorizontalFlip(), # data augmentation<br/>    transforms.ToTensor(),<br/>    transforms.Normalize([0.485, 0.456, 0.406], [0.229, 0.224, 0.225]) # normalization<br/>])</span><span id="f654" class="ki kj hi ke b fi ko kl l km kn">transforms_test = transforms.Compose([<br/>    transforms.Resize((224, 224)),   #must same as here<br/>     transforms.CenterCrop((224, 224)),<br/>    transforms.ToTensor(),<br/>    transforms.Normalize([0.485, 0.456, 0.406], [0.229, 0.224, 0.225])<br/>])</span></pre><p id="b0c8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">步骤8: </strong>现在，我们需要设置我们的培训和测试目录路径。您可以使用自己的数据，但要确保这些数据必须按照以下方式排列。</p><pre class="je jf jg jh fd kd ke kf kg aw kh bi"><span id="037e" class="ki kj hi ke b fi kk kl l km kn"><em class="ju">Datafol<br/>    ----&gt; trainfol<br/>          ----&gt;classafol<br/>          ----&gt;classbfol<br/>    ----&gt; testfol<br/>          ----&gt;classafol<br/>          ----&gt;classbfol</em></span></pre><p id="88a8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">您可以使用下面的代码来设置训练和测试数据的路径。(<em class="ju">必要步骤)</em></p><pre class="je jf jg jh fd kd ke kf kg aw kh bi"><span id="68e7" class="ki kj hi ke b fi kk kl l km kn">train_dir = "/Datafol/trainfol/"<br/>test_dir = "/Datafol/testfol/"<br/>train_classa_dir = "/Datafol/trainfol/classafol/"<br/>train_classb_dir = "/Datafol/trainfol/classbfol/"<br/>test_classa_dir = "/Datafol/testfol/classafol/"<br/>test_classb_dir = "/Datafol/testfol/classbfol/"</span></pre><p id="3ef4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">第9步:</strong>我们需要通过应用预处理，用<a class="ae jv" href="https://pytorch.org/vision/stable/generated/torchvision.datasets.ImageFolder.html#torchvision.datasets.ImageFolder" rel="noopener ugc nofollow" target="_blank"><em class="ju">torch vision . dataset . image folder</em></a>函数加载数据集。</p><pre class="je jf jg jh fd kd ke kf kg aw kh bi"><span id="042d" class="ki kj hi ke b fi kk kl l km kn">train_dataset = datasets.ImageFolder(train_dir, transforms_train)<br/>test_dataset = datasets.ImageFolder(test_dir, transforms_test)</span><span id="1045" class="ki kj hi ke b fi ko kl l km kn">train_dataloader = torch.utils.data.DataLoader(train_dataset, batch_size=12, shuffle=True, num_workers=8)<br/>test_dataloader = torch.utils.data.DataLoader(test_dataset, batch_size=12, shuffle=False, num_workers=8)</span></pre><p id="4af4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">你可以用下面的代码检查训练/测试图像的数量和它们的类名。<em class="ju">(非必要步骤)</em></p><pre class="je jf jg jh fd kd ke kf kg aw kh bi"><span id="35a7" class="ki kj hi ke b fi kk kl l km kn">print('Train dataset size:', len(train_dataset))<br/>print('Test dataset size:', len(test_dataset))</span><span id="e3a7" class="ki kj hi ke b fi ko kl l km kn">class_names = train_dataset.classes<br/>print('Class names:', class_names)</span></pre><p id="6e14" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">您可以从训练数据集<em class="ju">(非必要步骤)</em>中可视化代码下面的随机图像</p><pre class="je jf jg jh fd kd ke kf kg aw kh bi"><span id="c5df" class="ki kj hi ke b fi kk kl l km kn">plt.rcParams['figure.figsize'] = [12, 8]<br/>plt.rcParams['figure.dpi'] = 60<br/>plt.rcParams.update({'font.size': 20})</span><span id="4a82" class="ki kj hi ke b fi ko kl l km kn">def imshow(input, title):<br/>    # torch.Tensor =&gt; numpy<br/>    input = input.numpy().transpose((1, 2, 0))<br/>    # undo image normalization<br/>    mean = np.array([0.485, 0.456, 0.406])<br/>    std = np.array([0.229, 0.224, 0.225])<br/>    input = std * input + mean<br/>    input = np.clip(input, 0, 1)<br/>    # display images<br/>    plt.imshow(input)<br/>    plt.title(title)<br/>    plt.show()</span><span id="ab8c" class="ki kj hi ke b fi ko kl l km kn"># load a batch of train image<br/>iterator = iter(train_dataloader)</span><span id="8c6d" class="ki kj hi ke b fi ko kl l km kn"># visualize a batch of train image<br/>inputs, classes = next(iterator)<br/>out = torchvision.utils.make_grid(inputs[:4])<br/>imshow(out, title=[class_names[x] for x in classes[:4]])</span></pre></div><div class="ab cl jw jx gp jy" role="separator"><span class="jz bw bk ka kb kc"/><span class="jz bw bk ka kb kc"/><span class="jz bw bk ka kb"/></div><div class="hb hc hd he hf"><p id="1b37" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">训练步骤:</strong></p><p id="fb5f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> Step-10: </strong>我们需要下载resnet18预训练好的权值，并且改变它的层数，因为我们需要对具体的类进行分类，而Resnet-18是在很多类上进行训练的。你可以使用任何优化器和损失函数，我用过SGD优化器和交叉熵损失。您可以使用下面的代码下载Resnet-18模型并调整它的层。</p><pre class="je jf jg jh fd kd ke kf kg aw kh bi"><span id="7913" class="ki kj hi ke b fi kk kl l km kn">model = models.resnet18(pretrained=True)   #load resnet18 model<br/>num_features = model.fc.in_features     #extract fc layers features<br/>model.fc = nn.Linear(num_features, 2)<strong class="ke hj"> </strong>#(num_of_class == 2)<br/>model = model.to(device) <br/>criterion = nn.CrossEntropyLoss()  #(set loss function)<br/>optimizer = optim.SGD(model.parameters(), lr=0.001, momentum=0.9)</span></pre><p id="a380" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">步骤-11: </strong>现在，我们需要开始训练，如果上面的步骤工作正常，那么你可以很容易地用下面的代码开始训练。</p><pre class="je jf jg jh fd kd ke kf kg aw kh bi"><span id="1771" class="ki kj hi ke b fi kk kl l km kn">num_epochs = 60   #(set no of epochs)<br/>start_time = time.time() #(for showing time)<br/>for epoch in range(num_epochs): #(loop for every epoch)<br/>    print("Epoch {} running".format(epoch)) #(printing message)<br/>    """ Training Phase ""<strong class="ke hj">"<br/>    </strong>model.train()    #(training model)<br/>    running_loss = 0.   #(set loss 0)<br/>    running_corrects = 0 <br/>    # load a batch data of images<br/>    for i, (inputs, labels) in enumerate(train_dataloader):<br/>        inputs = inputs.to(device)<br/>        labels = labels.to(device) <br/><strong class="ke hj">   </strong>     # forward inputs and get output<br/>        optimizer.zero_grad()<br/>        outputs = model(inputs)<br/>        _, preds = torch.max(outputs, 1)<br/>        loss = criterion(outputs, labels)<br/>        # get loss value and update the network weights<br/>   <strong class="ke hj">    </strong> loss.backward()<br/>        optimizer.step()<br/>        running_loss += loss.item() * inputs.size(0)<br/>        running_corrects += torch.sum(preds == labels.data)<br/>    epoch_loss = running_loss / len(train_dataset)<br/>    epoch_acc = running_corrects / len(train_dataset) * 100.<br/>    print('[Train #{}] Loss: {:.4f} Acc: {:.4f}% Time: {:.4f}s'.format(epoch, epoch_loss, epoch_acc, time.time() -start_time))<br/>    <br/>    """ Testing Phase """<strong class="ke hj"><br/>    </strong>model.eval()<br/>    with torch.no_grad():<br/>        running_loss = 0.<br/>        running_corrects = 0<br/>        for inputs, labels in test_dataloader:<br/>            inputs = inputs.to(device)<br/>            labels = labels.to(device)<br/>            outputs = model(inputs)<br/>            _, preds = torch.max(outputs, 1)<br/>            loss = criterion(outputs, labels)<br/>            running_loss += loss.item() * inputs.size(0)<br/>            running_corrects += torch.sum(preds == labels.data)<br/>        epoch_loss = running_loss / len(test_dataset)<br/>        epoch_acc = running_corrects / len(test_dataset) * 100.<br/>        print('[Test #{}] Loss: {:.4f} Acc: {:.4f}% Time: {:.4f}s'.format(epoch, epoch_loss, epoch_acc, time.time()- start_time))</span></pre><p id="e018" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">步骤11: </strong>现在，我们需要保存我们训练好的模型，以供测试和进一步使用。您可以使用下面的代码将模型保存在文件中。</p><pre class="je jf jg jh fd kd ke kf kg aw kh bi"><span id="3a04" class="ki kj hi ke b fi kk kl l km kn">save_path = 'custom-classifier_resnet_18_final_60_last_tr_epochs.pth'<br/>torch.save(model.state_dict(), save_path)</span></pre></div><div class="ab cl jw jx gp jy" role="separator"><span class="jz bw bk ka kb kc"/><span class="jz bw bk ka kb kc"/><span class="jz bw bk ka kb"/></div><div class="hb hc hd he hf"><p id="6bf1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">测试步骤</strong></p><p id="d35e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">第12步:</strong>为了测试，我们首先需要加载经过训练的模型。您可以将下面的代码用于加载模型。</p><pre class="je jf jg jh fd kd ke kf kg aw kh bi"><span id="8a85" class="ki kj hi ke b fi kk kl l km kn">model = models.resnet18(pretrained=True)   #load resnet18 model<br/>num_features = model.fc.in_features #extract fc layers features<br/>model.fc = nn.Linear(num_features, 2)#(num_of_class == 2)<br/>model.load_state_dict(torch.load("Acne-classifier_resnet_18_final_60_last_tr_epochs.pth"))<br/>model.to(device)</span></pre><p id="b381" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在，我们可以在测试数据上测试我们的模型。</p><pre class="je jf jg jh fd kd ke kf kg aw kh bi"><span id="b5e6" class="ki kj hi ke b fi kk kl l km kn">plt.rcParams['figure.figsize'] = [12, 8]<br/>plt.rcParams['figure.dpi'] = 60<br/>plt.rcParams.update({'font.size': 20})<br/>def imshow(input, title):<br/>    # torch.Tensor =&gt; numpy<br/>   <strong class="ke hj"> </strong>input = input.numpy().transpose((1, 2, 0))<br/>    # undo image normalization<br/>   <strong class="ke hj"> </strong>mean = np.array([0.485, 0.456, 0.406])<br/>    std = np.array([0.229, 0.224, 0.225])<br/>    input = std * input + mean<br/>    input = np.clip(input, 0, 1)<br/>    # display images<br/>   <strong class="ke hj"> </strong>plt.imshow(input)<br/>    plt.title(title)<br/>    plt.show()</span><span id="b8cd" class="ki kj hi ke b fi ko kl l km kn">##Testing<br/>model.eval()<br/>start_time = time.time()<br/>criterion = nn.CrossEntropyLoss()<br/>optimizer = optim.SGD(model.parameters(), lr=0.001, momentum=0.9)<br/>with torch.no_grad():<br/>    running_loss = 0.<br/>    running_corrects = 0<br/>    for i, (inputs, labels) in enumerate(test_dataloader):<br/>        inputs = inputs.to(device)<br/>        labels = labels.to(device)<br/>        outputs = model(inputs)<br/>        _, preds = torch.max(outputs, 1)<br/>        loss = criterion(outputs, labels)<br/>        running_loss += loss.item() * inputs.size(0)<br/>        running_corrects += torch.sum(preds == labels.data)<br/>        if i == 0:<br/>            print('======&gt;RESULTS&lt;======')<br/>            images = torchvision.utils.make_grid(inputs[:4])<br/>            imshow(images.cpu(), title=[class_names[x] for x in labels[:4]])<br/>    epoch_loss = running_loss / len(test_dataset)<br/>    epoch_acc = running_corrects / len(test_dataset) * 100.<br/>    print('[Test #{}] Loss: {:.4f} Acc: {:.4f}% Time: {:.4f}s'.<br/>          format(epoch, epoch_loss, epoch_acc, time.time() - start_time))</span></pre><p id="4c19" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="ju">我已经用60个时期的皮肤癌数据训练了该模型，当我测试它时，我得到了如下所述的准确性。</em></p><pre class="je jf jg jh fd kd ke kf kg aw kh bi"><span id="ec89" class="ki kj hi ke b fi kk kl l km kn">======&gt;RESULTS&lt;======<br/>[Test #1] Loss: 0.0816 Acc: 96.9985% Time: 4.7761s</span></pre><p id="e821" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="ju">注意:纪元越多越好，但是你设置的纪元越大，就越有可能过拟合。</em></p><blockquote class="kp kq kr"><p id="98fc" class="if ig ju ih b ii ij ik il im in io ip ks ir is it kt iv iw ix ku iz ja jb jc hb bi translated">关于<strong class="ih hj">“使用迁移学习pytorch(resnet18)进行图像分类”的问题都解决了吗</strong>。您可以在自己的数据上尝试这样做。</p></blockquote><ul class=""><li id="188a" class="kv kw hi ih b ii ij im in iq kx iu ky iy kz jc la lb lc ld bi translated">利用卷积神经网络进行图像分类:<a class="ae jv" rel="noopener" href="/nerd-for-tech/image-classification-using-transfer-learning-vgg-16-2dc2221be34c"> <strong class="ih hj"> </strong> <em class="ju">文章链接</em> </a></li><li id="7e47" class="kv kw hi ih b ii le im lf iq lg iu lh iy li jc la lb lc ld bi translated">利用迁移学习进行图像分类:<a class="ae jv" rel="noopener" href="/nerd-for-tech/image-classification-using-transfer-learning-vgg-16-2dc2221be34c"> <em class="ju">文章链接</em> </a></li><li id="abf5" class="kv kw hi ih b ii le im lf iq lg iu lh iy li jc la lb lc ld bi translated">从视频创建数据集:<strong class="ih hj"> </strong> <a class="ae jv" rel="noopener" href="/nerd-for-tech/extraction-of-frames-from-a-single-video-2b9fdd901208"> <em class="ju">文章链接</em> </a></li><li id="09ef" class="kv kw hi ih b ii le im lf iq lg iu lh iy li jc la lb lc ld bi translated">自定义物体检测器训练的标注数据:<a class="ae jv" rel="noopener" href="/nerd-for-tech/labeling-data-for-object-detection-yolo-5a4fa4f05844"> <em class="ju">文章链接</em> </a></li></ul><p id="bb76" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">关于我</strong> ❓</p><p id="9494" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我有超过1年半的软件开发工作经验。目前，我是一名软件工程师，通过使用零售分析、建立大数据分析工具、创建和维护模型以及加入引人注目的新数据集，为我们的客户改进产品和服务。之前，我是Spark基金会的计算机视觉实习生，在那里我体验了来自不同开源平台(如Kaggle、google images、open images等)的视觉数据分析。)，并在该数据上训练不同的深度学习模型。</p><ul class=""><li id="1656" class="kv kw hi ih b ii ij im in iq kx iu ky iy kz jc la lb lc ld bi translated"><a class="ae jv" href="https://www.linkedin.com/in/muhammadrizwanmunawar/" rel="noopener ugc nofollow" target="_blank"> <em class="ju">在LinkedIn上联系我</em> </a></li><li id="bc4d" class="kv kw hi ih b ii le im lf iq lg iu lh iy li jc la lb lc ld bi translated"><a class="ae jv" href="https://www.upwork.com/services/product/consultation-1477666319161577472?ref=project_share" rel="noopener ugc nofollow" target="_blank"> <em class="ju">与我协商</em> </a></li><li id="2b02" class="kv kw hi ih b ii le im lf iq lg iu lh iy li jc la lb lc ld bi translated"><a class="ae jv" href="https://www.upwork.com/services/product/you-will-get-image-classification-projects-using-machine-learning-with-python-1323963101029052416?ref=project_share" rel="noopener ugc nofollow" target="_blank"> <em class="ju">我的yolov5服务</em> </a></li></ul><p id="7efe" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> <em class="ju">如有任何疑问，欢迎在下方评论</em> </strong></p></div></div>    
</body>
</html>