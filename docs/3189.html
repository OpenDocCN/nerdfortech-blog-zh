<html>
<head>
<title>Nodejs GraphQl Authentication with JWT, Apollo-server, MySql and Sequelize ORM.</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Nodejs GraphQl 认证与 JWT，阿波罗服务器，MySql 和 Sequelize ORM。</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/nodejs-graphql-authentication-with-jwt-apollo-server-mysql-and-sequelize-orm-21cf1503f7f?source=collection_archive---------4-----------------------#2021-06-01">https://medium.com/nerd-for-tech/nodejs-graphql-authentication-with-jwt-apollo-server-mysql-and-sequelize-orm-21cf1503f7f?source=collection_archive---------4-----------------------#2021-06-01</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/f057f3f8e1857c0bd123465dd1aa805d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*u3IjD13EgKyfby4MD6SAmw.jpeg"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">来自<a class="ae iu" href="https://www.pexels.com/photo/woman-writing-on-whiteboard-3861943/?utm_content=attributionCopyText&amp;utm_medium=referral&amp;utm_source=pexels" rel="noopener ugc nofollow" target="_blank"> Pexels </a>的<a class="ae iu" href="https://www.pexels.com/@thisisengineering?utm_content=attributionCopyText&amp;utm_medium=referral&amp;utm_source=pexels" rel="noopener ugc nofollow" target="_blank"> ThisIsEngineering </a>摄影</figcaption></figure><p id="1a29" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在过去的几年里，我们见证了微服务架构在一个完全不同的层面上的发展。它专注于开发软件系统，这些软件系统试图专注于构建具有良好定义的接口和操作的单一功能模块。与此同时，我们也看到了敏捷、Devops 和 API 的大规模增长。直到几年前，back REST APIs 还是行业标准和热门话题，但在 2015 年，脸书推出了 GraphQL，并在 2018 年发布了它的第一个稳定版本。我不会深入探讨它，但这里有两篇关于为什么使用 Graphql 的文章。<a class="ae iu" href="https://www.prisma.io/blog/top-5-reasons-to-use-graphql-b60cfa683511" rel="noopener ugc nofollow" target="_blank">【1】</a><a class="ae iu" rel="noopener" href="/@ajaysaini.official/why-graphql-886ba866ae75#:~:text=Here%2C%20Facebook%20team%20started%20to,to%20ask%20what%20they%20need.">【2】</a></p><p id="a678" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">GitHub 库:-<a class="ae iu" href="https://github.com/foxy17/GraphQl-Authentication" rel="noopener ugc nofollow" target="_blank">https://github.com/foxy17/GraphQl-Authentication</a></p><p id="18c7" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">你可以复制这个并按照我的解释去做。</p><p id="de89" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在本文中，我们将关注使用 JWT 令牌的本地认证。对于数据库，您可以使用任何 MySql 数据库。Apollo-server 是一个开源的 GraphQL 服务器，兼容任何种类的 GraphQL 客户端。我将使用 apollo 来公开 API，而不是 express。</p><p id="94ee" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们将进行一个简单的身份验证，其中用户将有一个名字，姓氏，电子邮件，密码，公司和唯一的雇员 Id。Company 将存储在另一个表中，这样我们就可以探索与 GraphQL 的提取关联。让我们首先安装必要的软件包:</p><blockquote class="jt ju jv"><p id="1656" class="iv iw jw ix b iy iz ja jb jc jd je jf jx jh ji jj jy jl jm jn jz jp jq jr js hb bi translated">NPM I Apollo-server bcrpytjs dotenv JSON web token sequelize MySQL 2 graph QL</p><p id="8837" class="iv iw jw ix b iy iz ja jb jc jd je jf jx jh ji jj jy jl jm jn jz jp jq jr js hb bi translated">npm i -D 序列-cli 节点</p></blockquote><pre class="ka kb kc kd fd ke kf kg kh aw ki bi"><span id="088c" class="kj kk hi kf b fi kl km l kn ko">const getUser = token =&gt; {<br/>    try {<br/>        if (token) {<br/>            return jwt.verify(token, JWT_SECRET)<br/>        }<br/>        return null<br/>    } catch (error) {<br/>        return null<br/>    }<br/>}</span></pre><p id="d66c" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这是导入后的第一行，这是我们如何定义 JWT 中间件的，它将验证我们的 JWT 令牌是否有效。</p><pre class="ka kb kc kd fd ke kf kg kh aw ki bi"><span id="2070" class="kj kk hi kf b fi kl km l kn ko">const server = new ApolloServer({<br/>    typeDefs,<br/>    resolvers,<br/>    context: ({ req }) =&gt; {<br/>        const token = req.get('Authorization') || ''<br/>        return { user: getUser(token.replace('Bearer', ''))}<br/>    },<br/>    introspection: true,<br/>    playground: true<br/>})<br/>server.listen({ port: PORT || 8080 }).then(({ url }) =&gt; {<br/>    console.log(`🚀 Server ready at ${url}`);<br/>  });</span></pre><p id="d49a" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在此之后，我们定义我们的 Apollo 服务器，我们必须传递一个包含以下内容的对象:</p><p id="0cfd" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">typeDefs:这是 graphQL API 的模式，它定义了我们可以在 API 上调用的查询和变化。</p><p id="5f47" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><em class="jw">解析器:这些是负责为各个 API 调用返回结果的函数。</em></p><p id="26a9" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><em class="jw">上下文:是一个特定执行的所有解析器共享的对象。在这里，我们从标头中检索 JWT 令牌，并运行我们之前定义的 getUser 函数来检查它是否有效，并将结果存储在任何解析器都可以访问的用户变量中。</em></p><p id="97c7" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><em class="jw">自省:它定义了我们是否可以查询模式，以获得关于它支持哪些查询及其结构的信息。(通常在生产中是错误的)</em></p><p id="7ba5" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><em class="jw"> playground:是一个图形化的、交互式的浏览器内</em><strong class="ix hj"><em class="jw">graph QL</em></strong><em class="jw">IDE，我们可以用它来运行查询。</em></p><p id="8adb" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">让我们检查我们的类型定义或模式。</p><pre class="ka kb kc kd fd ke kf kg kh aw ki bi"><span id="8dd7" class="kj kk hi kf b fi kl km l kn ko">const typeDefs = gql`<br/>    input Pagination {<br/>        page: Int!<br/>        items: Int!<br/>    }<br/>    input UserFilter {<br/>        employeeId: Int<br/>        firstName: String<br/>        lastName: String<br/>    }<br/>    type User {<br/>        employeeId: Int!<br/>        firstName: String!<br/>        lastName: String!<br/>        password: String!<br/>        email: String!<br/>        company: String!<br/>    }<br/>    type AuthPayload {<br/>        token: String!<br/>        user: User!<br/>    }<br/>    type Query {<br/>        getUserList(search:UserFilter, pagination:Pagination, sort:String): [User]<br/>    }<br/>    type Mutation {<br/>        registerUser(firstName: String!, lastName: String!, employeeId: Int!, email: String!, password: String!, company: String!): AuthPayload!<br/>        login (email: String!, password: String!): AuthPayload!<br/>    }<br/>`<br/></span></pre><p id="0a91" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><code class="du kp kq kr kf b">gql</code>模板文字标签可以用来简洁地编写一个 GraphQL 查询，该查询被解析成一个标准的 GraphQL <a class="ae iu" href="https://stackoverflow.com/questions/46163036/what-is-ast-in-graphql/46164403" rel="noopener ugc nofollow" target="_blank"> AST </a>。<code class="du kp kq kr kf b">type</code>用其参数定义一个对象。<code class="du kp kq kr kf b">!</code>标记表示参数是强制的，不能是未定义的或空的。有两种截然不同的类型，<strong class="ix hj">查询</strong>和<strong class="ix hj">突变</strong>。简单来说<strong class="ix hj">查询</strong>是选择语句<strong class="ix hj">变异</strong>是插入操作。</p><figure class="ka kb kc kd fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ks"><img src="../Images/6252dbea40e99a3bca1920509a35459b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZKAHxuZWXcgI4lRHdcYK3A.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">分解变异</figcaption></figure><p id="ba76" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">除了标量类型<code class="du kp kq kr kf b">String</code>、<code class="du kp kq kr kf b">Int</code>、<code class="du kp kq kr kf b">Float</code>、<code class="du kp kq kr kf b">Boolean</code>和<code class="du kp kq kr kf b">ID</code>之外，我们可以将它们作为一种类型直接分配给自变量或参数，也可以将我们自己定义的复杂类型作为输入。为此，我们使用输入标签。<code class="du kp kq kr kf b">UserFilter</code>输入是一个定制输入，它被传递以获取用户列表查询。<code class="du kp kq kr kf b">[User]</code>意味着将返回一个用户类型的数组。</p><p id="da09" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">所有这些都是 GraphQL 的主要外壳，现在剩下的是数据库模型，它将根据您的数据库选择和解析器函数而变化，就像您为特定路径上的 REST API 定义的函数一样。让我们看看顺序模型。</p><pre class="ka kb kc kd fd ke kf kg kh aw ki bi"><span id="0e66" class="kj kk hi kf b fi kl km l kn ko">//User.js<br/>module.exports = (sequelize, DataTypes) =&gt; {<br/>    const User = sequelize.define('User', {<br/>        firstName: { type: DataTypes.STRING, allowNull: true },<br/>        lastName: { type: DataTypes.STRING, allowNull: true },<br/>        email: { type: DataTypes.STRING, allowNull: false, unique: true },<br/>        password: {type: DataTypes.STRING,allowNull: false},<br/>        employeeId:{ type: DataTypes.INTEGER, allowNull: false, primaryKey: true, unique: true },<br/>    }, {timestamps: false,<br/>        hooks: {<br/>            beforeCreate: async (user) =&gt; {<br/>             if (user.password) {<br/>              const salt = await bcrypt.genSaltSync(10, 'a');<br/>              user.password = bcrypt.hashSync(user.password, salt);<br/>             }<br/>            },<br/>            beforeUpdate:async (user) =&gt; {<br/>             if (user.password) {<br/>              const salt = await bcrypt.genSaltSync(10, 'a');<br/>              user.password = bcrypt.hashSync(user.password, salt);<br/>             }<br/>            }<br/>           }<br/>    });<br/>    User.associate = function (models) {<br/>        User.hasOne(models.Company, { foreignKey: "employeeId" });<br/>      };<br/>    User.validPassword = async (password, hash) =&gt; {<br/>        return await bcrypt.compareSync(password, hash);<br/>       }<br/>    return User;<br/>  };<br/>//Company.js<br/>module.exports = (sequelize, DataTypes) =&gt; {<br/>    const Company = sequelize.define('Company', {<br/>        company: {type: DataTypes.STRING,allowNull: false},<br/>        employeeId:{ type: DataTypes.INTEGER, allowNull: false, primaryKey: true, unique: true },<br/>    }, {<br/>      timestamps: false,<br/>      freezeTableName: true,<br/>    });<br/>    Company.associate = function (models) {<br/>        Company.belongsTo(models.User, { foreignKey: "employeeId" });<br/>      };<br/>    return Company;<br/>  };</span></pre><p id="e6a3" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><code class="du kp kq kr kf b">beforeCreate</code>是在调用创建查询时调用的钩子。钩子包含用盐散列密码的逻辑，这样我们就不会在数据库中存储未加密的密码。<code class="du kp kq kr kf b">beforeUpdate</code>当在用户表上调用更新查询时，调用这个钩子。就像之前一样，它散列更新后的密码。<code class="du kp kq kr kf b">User.validPassword </code>是一个用户加密的类方法，用来比较存储在数据库中的散列和一个字符串，以检查两者是否相同。<code class="du kp kq kr kf b">User.associate</code>是与带有 employeeId 外键的公司表的一对一关联。<code class="du kp kq kr kf b">Timestamp:false</code>默认情况下，sequelize 在 SQL 表中包含一个 createdAt 和 updateAt 记录，但这会将其设置为 false。默认情况下，sequelize 使表名成为复数，这会导致错误，除非我们默认这样设置它们。因为我没有这样做，<code class="du kp kq kr kf b">freezeTableName</code>帮助我保持表名与我定义的完全一致，并且没有将<strong class="ix hj">用户更改为用户</strong>或者将<strong class="ix hj">公司更改为公司</strong>。Index.js 只是连接数据库的默认序列文件。它还获取 models 文件夹中定义的所有模型，并将它们应用于“db”对象。</p><pre class="ka kb kc kd fd ke kf kg kh aw ki bi"><span id="0a51" class="kj kk hi kf b fi kl km l kn ko">const resolvers = {<br/>    Query: {<br/>        async getUserList(root, args, { user }) {<br/>            try {<br/>                if(!user) throw new Error('You are not authenticated!')<br/>                const {search,pagination,sort} =args;<br/>                var query={<br/>                    offset:0,<br/>                    limit:5,<br/>                    raw: true,<br/>                    //this is done to flaten out the join command<br/>                    attributes: ['firstName','lastName','email','employeeId','Company.company',],<br/>                    include: [{ model: models.Company,attributes:[]}]<br/>                    }<br/>                    //by defaults query is paginated to limit 5 items<br/>                if(pagination){<br/>                    query.limit=pagination.items;<br/>                    query.offset=pagination.items*(pagination.page-1)<br/>                }<br/>                if(search){<br/>                    query.where={<br/>                        [Op.or]: [<br/>                            search.firstName?{ firstName: search.firstName }:null,<br/>                            search.lastName?{ lastName: search.lastName}:null,<br/>                            search.employeeId?{ employeeId: search.employeeId}:null<br/>                        ] <br/>                    }<br/>                }<br/>                if(sort){<br/>                    query.order= [<br/>                        [sort, 'ASC'],<br/>                    ];<br/>                }<br/>                return await models.User.findAll(query);<br/>            } catch (error) {<br/>                throw new Error(error.message)<br/>            }<br/>        }<br/>    },<br/><br/>    Mutation: {<br/>        async registerUser(root, { firstName, lastName, email, password, employeeId,company }) {<br/>            try {<br/>                const userCheck = await models.User.findOne({ <br/>                    where: { <br/>                        [Op.or]: [<br/>                            { email: email },<br/>                            { employeeId: employeeId }<br/>                    ] <br/>                }})<br/>                if (userCheck) {<br/>                    throw new Error('Email or Employee id already exists')<br/>                }<br/>                const user = await models.User.create({<br/>                    firstName,<br/>                    lastName,<br/>                    employeeId,<br/>                    email,<br/>                    password<br/>                })<br/>                const companyModel = await models.Company.create({<br/>                    employeeId,<br/>                    company<br/>                })<br/>                const token = jsonwebtoken.sign(<br/>                    { employeeId: user.employeeId, email: user.email},<br/>                    process.env.JWT_SECRET,<br/>                    { expiresIn: '1y' }<br/>                )<br/>                let createdUser={<br/>                    company:companyModel.company,<br/>                    employeeId: user.employeeId,<br/>                    firstName: user.firstName, <br/>                    lastName: user.lastName, <br/>                    email: user.email<br/>                }<br/><br/>                return {<br/>                    token, user:createdUser, message: "Registration succesfull"<br/>                }<br/>            } catch (error) {<br/>                throw new Error(error.message)<br/>            }<br/>        },<br/><br/>        async login(_, { email, password }) {<br/>            try {<br/>                const user = await models.User.findOne({ where: { email }})<br/><br/>                if (!user) {<br/>                    throw new Error('No user with that email')<br/>                }<br/>                const isValid = await models.User.validPassword(password, user.password)<br/>                if (!isValid) {<br/>                    throw new Error('Incorrect password')<br/>                }<br/><br/>                // return jwt<br/>                const token = jsonwebtoken.sign(<br/>                    { employeeId: user.employeeId, email: user.email},<br/>                    process.env.JWT_SECRET,<br/>                    { expiresIn: '1d'}<br/>                )<br/>                <br/>                return {<br/>                   token, user<br/>                }<br/>            } catch (error) {<br/>                throw new Error(error.message)<br/>            }<br/>        }<br/><br/>    },<br/>}</span></pre><p id="e4f0" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">解析器包含用于相应查询和变异的函数。他们接受 4 个论点</p><ol class=""><li id="73b2" class="kt ku hi ix b iy iz jc jd jg kv jk kw jo kx js ky kz la lb bi translated"><code class="du kp kq kr kf b">root</code>包含从父字段的解析器返回的结果。</li><li id="c565" class="kt ku hi ix b iy lc jc ld jg le jk lf jo lg js ky kz la lb bi translated"><code class="du kp kq kr kf b">args</code>参数传递到查询中的字段。</li><li id="5c8b" class="kt ku hi ix b iy lc jc ld jg le jk lf jo lg js ky kz la lb bi translated"><code class="du kp kq kr kf b">context</code>特定查询中所有解析器共享的对象。</li><li id="e749" class="kt ku hi ix b iy lc jc ld jg le jk lf jo lg js ky kz la lb bi translated"><code class="du kp kq kr kf b">info</code>包含关于查询的执行状态的信息。</li></ol><p id="765d" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><code class="du kp kq kr kf b">getUserList</code>中的<code class="du kp kq kr kf b">query</code>对象是一个动态对象，它根据传递给查询的参数改变值。所有参数都是可选的。所有查询都需要带有有效 jwt 令牌的授权头。这正由<code class="du kp kq kr kf b"> if(!user) throw new Error(‘You are not authenticated!’)</code>验证</p><p id="47e5" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这是从我们之前在 server.js 中传递的上下文中获取的用户变量。如果我们不希望路由被验证，我们只需删除这一行。让我们解释一下基本的查询。<code class="du kp kq kr kf b">offset </code>和<code class="du kp kq kr kf b">limit</code>是分页参数。<code class="du kp kq kr kf b">raw</code>用于返回一个 JSON 对象，而不是一个 sequelize 对象，这样更容易被 parase。属性让我们定义希望从 SQL 返回哪些列。包括我们如何在公司和用户表之间应用连接，这样我们就不能获取特定用户的公司名称。您会注意到，我们已经将 include 的属性设置为空。这意味着尽管它们将在查询中返回，但不会显示。如果返回<code class="du kp kq kr kf b">{Company.company:"name",Company.employeeId:2}</code>，它们看起来会像这样，并且当我们试图使用 graphQL 模式对其进行并行化时，会抛出一个错误，因为我们已经将用户定义为拥有 company key，而不是 Company.company 作为键。因此，为了解决这个问题，我们选择<code class="du kp kq kr kf b">’Company.company’</code>作为映射到公司的用户属性。</p><p id="4f69" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">记住，如果你使用 query，你需要像这样在头中传递 JWT 令牌。该令牌在登录或注册时返回。</p><p id="0b67" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><code class="du kp kq kr kf b">{<br/> “Authorization”:”eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJlbXBsb3llZUlkIjoyLCJlbWFpbCI6ImJAZ21haWwuY29tIiwiaWF0IjoxNjIyNTMwNTAyLCJleHAiOjE2MjI2MTY5MDJ9.3qQOHPzhKOjM6r5JNRWoMsvyt2IzwX8aa7Bj7s1zEZw”<br/>}</code></p><p id="e888" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">谢谢你坚持和我在一起，如果你喜欢这个并且想看更多的东西，你可以<strong class="ix hj"> star </strong>或者<strong class="ix hj">fork</strong>GitHub repo。</p><figure class="ka kb kc kd fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lh"><img src="../Images/0027d2d61204fa3e1060b194093e2221.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1qvxGJgDNqWCuzDCwD5iiQ.jpeg"/></div></div></figure><figure class="ka kb kc kd fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es li"><img src="../Images/cb9a430be380e286e47c5d31f3ecf142.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8oPLSdxxd9Gc7rDB7n6riQ.jpeg"/></div></div></figure><figure class="ka kb kc kd fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lj"><img src="../Images/c13a42bdf58f9fe3744e116caa610c4a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dFVLr_gTLX4WMOSU3GyDag.jpeg"/></div></div></figure></div></div>    
</body>
</html>