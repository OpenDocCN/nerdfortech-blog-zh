<html>
<head>
<title>What Will Happen If We Killed the WAL Writer Process in PostgreSQL?|Interview Q&amp;A</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如果我们在 PostgreSQL 中杀死了 WAL Writer 进程会怎么样？|采访问答</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/what-will-happen-if-we-killed-the-wal-writer-process-in-postgresql-73cc0ea0e6df?source=collection_archive---------5-----------------------#2021-02-22">https://medium.com/nerd-for-tech/what-will-happen-if-we-killed-the-wal-writer-process-in-postgresql-73cc0ea0e6df?source=collection_archive---------5-----------------------#2021-02-22</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/></div><div class="ab cl if ig gp ih" role="separator"><span class="ii bw bk ij ik il"/><span class="ii bw bk ij ik il"/><span class="ii bw bk ij ik"/></div><div class="hb hc hd he hf"><p id="c9f7" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">为了理解 WAL Writer 进程的重要性并查看手动终止 WAL Writer 进程的演示结果</p></div><div class="ab cl if ig gp ih" role="separator"><span class="ii bw bk ij ik il"/><span class="ii bw bk ij ik il"/><span class="ii bw bk ij ik"/></div><div class="hb hc hd he hf"><figure class="jl jm jn jo fd jp er es paragraph-image"><div role="button" tabindex="0" class="jq jr di js bf jt"><div class="er es jk"><img src="../Images/99853d95fd6cf90aa721730d2a2c0173.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Of3hQb3evtZG_CBaklLw7A.png"/></div></div></figure><p id="f49a" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">PostgreSQL 体系结构是一种客户端-服务器体系结构，当客户端发出请求时，服务器将对其做出响应。核心是 RDBMS，所以它将支持 SQL 和 NoSQL 数据。</p><p id="3cb9" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">该架构包含</p><ol class=""><li id="3207" class="jw jx hi io b ip iq it iu ix jy jb jz jf ka jj kb kc kd ke bi translated"><strong class="io hj">实例</strong></li><li id="d3ca" class="jw jx hi io b ip kf it kg ix kh jb ki jf kj jj kb kc kd ke bi translated"><strong class="io hj">后台进程</strong></li><li id="1782" class="jw jx hi io b ip kf it kg ix kh jb ki jf kj jj kb kc kd ke bi translated"><strong class="io hj">数据库</strong> <br/> i)物理结构<br/> ii)逻辑结构</li></ol><figure class="jl jm jn jo fd jp er es paragraph-image"><div class="er es kk"><img src="../Images/b92f10aa619d56506357614a0b176c6c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1248/format:webp/1*NxP45i2eDOMNrDhPiUZmfw.png"/></div><figcaption class="kl km et er es kn ko bd b be z dx translated">PostgreSQL 数据库概述</figcaption></figure><p id="fe49" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><strong class="io hj">实例:</strong></p><p id="8647" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">它总是向数据库打开，它总是取决于 RAM 的大小。一旦集群启动，内存将被分配给实例。</p><p id="1274" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">它包含三个主要内存:</p><ol class=""><li id="63a5" class="jw jx hi io b ip iq it iu ix jy jb jz jf ka jj kb kc kd ke bi translated"><strong class="io hj">共享内存</strong> <br/> <strong class="io hj"> i)共享缓冲<br/> ii)WAL 缓冲</strong></li><li id="d31c" class="jw jx hi io b ip kf it kg ix kh jb ki jf kj jj kb kc kd ke bi translated"><strong class="io hj">工作记忆</strong></li></ol><p id="9178" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><strong class="io hj"> 3。维护工作记忆</strong></p><p id="498b" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><strong class="io hj">共享内存:</strong></p><p id="af01" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">客户端或用户在与数据库建立成功连接后，如果请求<strong class="io hj"> PGPRocess </strong>的客户端将查看共享缓冲区中是否已有数据，或者如果共享缓冲区中已有数据，它将响应客户端，否则它将从数据文件中提取数据并复制到共享缓冲区中，并响应客户端请求。</p><figure class="jl jm jn jo fd jp er es paragraph-image"><div class="er es kp"><img src="../Images/a748fb41876c3007818ab21f402be0dc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1246/format:webp/1*D8RykuqH44NmKzWBeIfc9Q.png"/></div></figure><p id="5736" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">如果数据库发生变化，原始数据将首先被复制到 WAL 缓冲区，因为要保持数据库的一致性。一旦发生检查点事件，脏缓冲区将通过 BG writer 进程写入数据文件。在提交时，发生一个事件，数据将通过 WAL 写进程从 WAL 缓冲区写入 WAL 文件。</p><p id="6a0a" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">注意:剩下的部分将在以后的博客中讨论。</p><p id="ab16" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">让我们看看，如果我们手动终止 wal writer 进程，我们正在数据库上执行一个繁重的事务，并看看数据库端会发生什么情况。</p><p id="d50e" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">让我们连接我的 PostgreSQL 机器</p><p id="f52e" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><strong class="io hj">检查运行状态:</strong></p><pre class="jl jm jn jo fd kq kr ks kt aw ku bi"><span id="31de" class="kv kw hi kr b fi kx ky l kz la">ps -ef|grep data</span></pre><p id="6b8c" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">使用 psql 连接您的数据库，一旦我们连接到数据库中创建一个表</p><p id="06c9" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><strong class="io hj">创建表格:</strong></p><pre class="jl jm jn jo fd kq kr ks kt aw ku bi"><span id="fa11" class="kv kw hi kr b fi kx ky l kz la">Create table sales (sal_id integer);</span></pre><p id="ab3d" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><strong class="io hj">上传批量数据到数据库</strong></p><pre class="jl jm jn jo fd kq kr ks kt aw ku bi"><span id="e19c" class="kv kw hi kr b fi kx ky l kz la">Insert into sales select g.sal_id<br/>FROM generate_series(1, 10000000) AS g (sal_id);</span></pre><p id="2ed4" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">现在，我已经复制了会话来查看所有 Postgres 后台进程</p><p id="e2b9" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><strong class="io hj">检查 Postgres 流程:</strong></p><pre class="jl jm jn jo fd kq kr ks kt aw ku bi"><span id="b12f" class="kv kw hi kr b fi kx ky l kz la">$ps -ef|grep postgres<br/>postgres 831 1 0 17:38 ? 00:00:00 /usr/pgsql-12/bin/postmaster -D /var/lib/pgsql/12/data/<br/>postgres 998 831 0 17:38 ? 00:00:00 postgres: logger<br/>postgres 1054 831 0 17:38 ? 00:00:00 postgres: checkpointer<br/>postgres 1055 831 0 17:38 ? 00:00:00 postgres: background writer<br/><strong class="kr hj">postgres 1056 831 0 17:38 ? 00:00:00 postgres: walwriter</strong><br/>postgres 1057 831 0 17:38 ? 00:00:00 postgres: autovacuum launche r<br/>postgres 1058 831 0 17:38 ? 00:00:00 postgres: stats collector<br/>postgres 1059 831 0 17:38 ? 00:00:00 postgres: logical replicatio n launcher<br/>root 1627 1607 0 17:40 pts/0 00:00:00 su - postgres<br/>postgres 1628 1627 0 17:40 pts/0 00:00:00 -bash<br/>postgres 1655 1628 0 17:41 pts/0 00:00:00 psql<br/>postgres 1656 831 6 17:41 ? 00:00:20 postgres: postgres postgres [local] INSERT<br/>root 1717 1696 0 17:45 pts/1 00:00:00 su - postgres<br/>postgres 1718 1717 0 17:45 pts/1 00:00:00 -bash<br/>postgres 1742 1718 0 17:46 pts/1 00:00:00 ps -ef<br/>postgres 1743 1718 0 17:46 pts/1 00:00:00 grep - color=auto postgres</span></pre><p id="b4be" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><strong class="io hj">杀死 WAL Writer 进程:</strong></p><p id="016a" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">现在，我将使用 kill 命令终止 wal writer 进程</p><pre class="jl jm jn jo fd kq kr ks kt aw ku bi"><span id="8c06" class="kv kw hi kr b fi kx ky l kz la">kill -9 1056</span></pre><p id="a229" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">成功杀死 wal writer 进程后。</p><p id="7e52" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><strong class="io hj">验证 Postgres 流程:</strong></p><pre class="jl jm jn jo fd kq kr ks kt aw ku bi"><span id="174a" class="kv kw hi kr b fi kx ky l kz la">ps -ef |grep postgres<br/>postgres 831 1 0 17:38 ? 00:00:00 /usr/pgsql-12/bin/postmaster -D /var/lib/pgsql/12/data/<br/>postgres 998 831 0 17:38 ? 00:00:00 postgres: logger<br/>root 1627 1607 0 17:40 pts/0 00:00:00 su - postgres<br/>postgres 1628 1627 0 17:40 pts/0 00:00:00 -bash<br/>postgres 1655 1628 0 17:41 pts/0 00:00:00 psql<br/>root 1717 1696 0 17:45 pts/1 00:00:00 su - postgres<br/>postgres 1718 1717 0 17:45 pts/1 00:00:00 -bash<br/><strong class="kr hj">postgres 1745 831 86 17:47 ? 00:00:09 postgres: startup recovering 0000000100000000000000CE</strong><br/>postgres 1747 1718 0 17:47 pts/1 00:00:00 ps -ef<br/>postgres 1748 1718 0 17:47 pts/1 00:00:00 grep - color=auto postgres</span></pre><p id="7a03" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">同时，它在终端内部显示以下结果</p><pre class="jl jm jn jo fd kq kr ks kt aw ku bi"><span id="5c44" class="kv kw hi kr b fi kx ky l kz la">WARNING: terminating the connection because of crash of another server process<br/>DETAIL: <strong class="kr hj">The postmaster has commanded this server process to roll back the current transaction and exit, because another server process exited abnormally and possibly corrupted shared memory.</strong><br/>HINT: In a moment you should be able to reconnect to the database and repeat your command.<br/>server closed the connection unexpectedly<br/>This probably means the server terminated abnormally<br/>before or while processing the request.<br/>The connection to the server was lost. Attempting reset: Failed.<br/>!&gt;</span></pre><p id="6172" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">当前事务已经存在，数据库已经回滚</p><p id="c5e5" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">邮局主管已命令此服务器进程回滚当前事务并退出，因为另一个服务器进程异常退出并可能损坏了共享内存。</p><p id="3d5a" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">Postgres 本身所有的服务器进程都被终止并重新初始化。数据库从第一次重做恢复到最后一次应用的重做。一旦应用成功，数据库就准备好接受连接。</p><p id="e2c6" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><strong class="io hj">集群重启后:</strong></p><pre class="jl jm jn jo fd kq kr ks kt aw ku bi"><span id="62c7" class="kv kw hi kr b fi kx ky l kz la">$ps -ef |grep postgres<br/>postgres 831 1 0 17:38 ? 00:00:00 /usr/pgsql-12/bin/postmaster -D /var/lib/pgsql/12/data/<br/>postgres 998 831 0 17:38 ? 00:00:00 postgres: logger<br/>root 1627 1607 0 17:40 pts/0 00:00:00 su - postgres<br/>postgres 1628 1627 0 17:40 pts/0 00:00:00 -bash<br/>postgres 1655 1628 0 17:41 pts/0 00:00:00 psql<br/>root 1717 1696 0 17:45 pts/1 00:00:00 su - postgres<br/>postgres 1718 1717 0 17:45 pts/1 00:00:00 -bash<br/>postgres 1749 831 0 17:47 ? 00:00:00 postgres: checkpointer<br/>postgres 1750 831 0 17:47 ? 00:00:00 postgres: background writer<br/><strong class="kr hj">postgres 1751 831 0 17:47 ? 00:00:00 postgres: walwriter</strong><br/>postgres 1752 831 0 17:47 ? 00:00:00 postgres: autovacuum launche r<br/>postgres 1753 831 0 17:47 ? 00:00:00 postgres: stats collector<br/>postgres 1754 831 0 17:47 ? 00:00:00 postgres: logical replicatio n launcher<br/>postgres 1755 1718 0 17:48 pts/1 00:00:00 ps -ef<br/>postgres 1756 1718 0 17:48 pts/1 00:00:00 grep - color=auto postgres</span></pre><p id="af92" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><strong class="io hj">概要:</strong></p><p id="dbf7" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">在 commit 事件发生时，WAL writer 进程会定期将数据从 WAL 缓冲区写入 WAL 文件，以保持数据库的一致性，即使进程失败，postmaster 进程也会退出当前事务并回滚服务器。</p></div></div>    
</body>
</html>