<html>
<head>
<title>Legacy software series — Part 2— Software life cycles and software aging</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">遗留软件系列—第2部分—软件生命周期和软件老化</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/legacy-software-series-part-2-software-life-cycles-and-software-aging-ae3cfdbe2cc5?source=collection_archive---------5-----------------------#2022-05-17">https://medium.com/nerd-for-tech/legacy-software-series-part-2-software-life-cycles-and-software-aging-ae3cfdbe2cc5?source=collection_archive---------5-----------------------#2022-05-17</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="4146" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在本文中，我将介绍典型软件系统的传统生命周期阶段。此外，我正在描述什么是软件老化以及是什么导致了它。</p></div><div class="ab cl jd je gp jf" role="separator"><span class="jg bw bk jh ji jj"/><span class="jg bw bk jh ji jj"/><span class="jg bw bk jh ji"/></div><div class="hb hc hd he hf"><h1 id="2f25" class="jk jl hi bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">软件生命周期</h1><figure class="kj kk kl km fd kn er es paragraph-image"><div class="er es ki"><img src="../Images/9e9e18205b1595b9514007815e3fe8da.png" data-original-src="https://miro.medium.com/v2/resize:fit:998/format:webp/1*oo-p3yRwXl_AIauHcW5ubA.png"/></div><figcaption class="kq kr et er es ks kt bd b be z dx translated">生命周期:D</figcaption></figure><p id="670a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> 1。初始开发</strong></p><p id="218c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在初始开发期间，计划和开发软件的第一个版本。通常这些是概念证明类型的版本，用于证明进一步开发的合理性。</p><p id="50b3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> 2。进化</strong></p><p id="2ee8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在最初的开发阶段之后，软件产品发生了演变。在这个阶段，软件产品的能力和功能被塑造以满足客户的需求。这个阶段可能包括软件的重大升级。</p><p id="4ed8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> 3。维修和保养</strong></p><p id="fac0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">当产品已经成型，只需要微小的改变和调整，它就进入了生命周期的服务阶段。在服务阶段，没有重大升级应用，只有小的变化和错误修复。</p><p id="8ae4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> 4。逐步淘汰</strong></p><p id="63e0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在逐步淘汰阶段，维护软件产品不再具有成本效益。修复仅适用于确保核心功能。该公司本质上是在等待最后一批用户迁移到新的软件产品。</p><p id="bb17" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> 5。关闭</strong></p><p id="8e5f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">最后，软件产品被淘汰，不再使用。它将被替换或完全从市场上移除。</p><p id="ca5a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Vaclac等人(2000年)定义了这些阶段。</p></div><div class="ab cl jd je gp jf" role="separator"><span class="jg bw bk jh ji jj"/><span class="jg bw bk jh ji jj"/><span class="jg bw bk jh ji"/></div><div class="hb hc hd he hf"><h1 id="fa0b" class="jk jl hi bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">软件老化</h1><figure class="kj kk kl km fd kn er es paragraph-image"><div class="er es ku"><img src="../Images/6957e8163478ce456b34b7a9ec2d6b29.png" data-original-src="https://miro.medium.com/v2/resize:fit:1080/format:webp/1*P6fDEmglulpue9d1ixG9XA.png"/></div><figcaption class="kq kr et er es ks kt bd b be z dx translated">酒越陈越香，但代码不会。</figcaption></figure><p id="f602" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">理论上，软件是由基于数学的逻辑运算组成的，数学不变，所以软件不应该老化。然而，事实正好相反，软件确实会老化。这是由软件周围世界的变化引起的。世界在不断变化，这就要求软件也要随之变化，否则就会过时。准确的说，老化的不是物理软件。改变的是软件的目的，考虑到这一点，软件也需要改变(Parnas，1994)。</p><h2 id="7d45" class="kv jl hi bd jm kw kx ky jq kz la lb ju iq lc ld jy iu le lf kc iy lg lh kg li bi translated">老化的原因</h2><p id="5519" class="pw-post-body-paragraph if ig hi ih b ii lj ik il im lk io ip iq ll is it iu lm iw ix iy ln ja jb jc hb bi translated">软件老化有两个主要原因。首先，开发人员无法实现对软件的更改。如果软件不经常更新以满足客户的需求，客户会变得不满意，并开始寻找替代解决方案。理论上，20世纪50年代的软件可以在今天使用，但没有客户会对其性能或功能感到满意。其次，更改成功地实现到软件中，但是这些更改是由不了解软件原始设计的开发人员完成的。这将导致软件的结构降级。如果变更与最初的设计不一致，那么最终的软件将会有两个可能冲突的设计。下一个试图进行更改的开发人员现在必须理解原始设计和更改的设计。这种软件复杂性的增加会持续到软件的整个生命周期，积累复杂性并降低可维护性。缺少文件或文件不正确加剧了这一问题(Parnas，1994年)。</p></div><div class="ab cl jd je gp jf" role="separator"><span class="jg bw bk jh ji jj"/><span class="jg bw bk jh ji jj"/><span class="jg bw bk jh ji"/></div><div class="hb hc hd he hf"><p id="9325" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">感谢您的阅读！在下面留下评论！❤</p><h1 id="483f" class="jk jl hi bd jm jn lo jp jq jr lp jt ju jv lq jx jy jz lr kb kc kd ls kf kg kh bi translated">链接</h1><p id="fe6b" class="pw-post-body-paragraph if ig hi ih b ii lj ik il im lk io ip iq ll is it iu lm iw ix iy ln ja jb jc hb bi translated"><a class="ae lt" href="https://ktuusj.medium.com/legacy-software-series-part-3-modernizing-legacy-software-99ceb86ae550" rel="noopener"> <strong class="ih hj">下一篇</strong> </a></p><p id="6eaf" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><a class="ae lt" href="https://www.youtube.com/channel/UCjCeTp2PUd3cqXhEHsx9NHw?view_as=subscriber" rel="noopener ugc nofollow" target="_blank"> <strong class="ih hj">我的Youtube </strong> </a></p><p id="594f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><a class="ae lt" href="http://ktcoding.fi" rel="noopener ugc nofollow" target="_blank"> <strong class="ih hj">我的网站</strong> </a></p></div><div class="ab cl jd je gp jf" role="separator"><span class="jg bw bk jh ji jj"/><span class="jg bw bk jh ji jj"/><span class="jg bw bk jh ji"/></div><div class="hb hc hd he hf"><h2 id="e874" class="kv jl hi bd jm kw kx ky jq kz la lb ju iq lc ld jy iu le lf kc iy lg lh kg li bi translated">来源</h2><p id="fe02" class="pw-post-body-paragraph if ig hi ih b ii lj ik il im lk io ip iq ll is it iu lm iw ix iy ln ja jb jc hb bi translated">帕纳斯博士(1994年)。软件老化。IEEE。检索自<a class="ae lt" href="https://www.cs.drexel.edu/~yfcai/CS451/RequiredReadings/SoftwareAging.pdf" rel="noopener ugc nofollow" target="_blank">https://www . cs . drexel . edu/~ YF Cai/cs 451/required readings/software aging . pdf</a></p><p id="42cc" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Vaclac T. Rajlich，K. H. (2000年)。软件生命周期的分阶段模型。IEEE计算机。黄金分割指数:10.1109</p></div></div>    
</body>
</html>