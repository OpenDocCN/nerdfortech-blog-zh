<html>
<head>
<title>Modern Concepts in JavaScript(Part 2)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript 中的现代概念(第 2 部分)</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/modern-concepts-in-javascript-part-2-598bd14faed1?source=collection_archive---------22-----------------------#2021-05-31">https://medium.com/nerd-for-tech/modern-concepts-in-javascript-part-2-598bd14faed1?source=collection_archive---------22-----------------------#2021-05-31</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/0c21dd1b208f9495b240da1319f7d1d3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xiDj73t-bBDLZJ_GUlDnbw.jpeg"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">图 01: Js(来源:谷歌)</figcaption></figure><p id="bc85" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">通过这篇文章，让我们来讨论 JavaScript 中的一些新概念。这是上一篇文章的延续。因此，我建议您在继续阅读本文之前，先浏览一下本文的第 1 部分。</p><p id="2535" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">请访问上一篇文章，作者是—</p><div class="js jt ez fb ju jv"><a href="https://damsak.medium.com/modern-concepts-in-javascript-part-1-4f56ffbedbc9" rel="noopener follow" target="_blank"><div class="jw ab dw"><div class="jx ab jy cl cj jz"><h2 class="bd hj fi z dy ka ea eb kb ed ef hh bi translated">Javascript 中的现代概念—第 1 部分</h2><div class="kc l"><p class="bd b fp z dy ka ea eb kb ed ef dx translated">damsak.medium.com</p></div></div><div class="kd l"><div class="ke l kf kg kh kd ki io jv"/></div></div></a></div><h1 id="57b5" class="kj kk hi bd kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg bi translated">6.模板文字</h1><p id="63a6" class="pw-post-body-paragraph iu iv hi iw b ix lh iz ja jb li jd je jf lj jh ji jj lk jl jm jn ll jp jq jr hb bi translated">指允许嵌入表达式的字符串文字。模板文字应该用<strong class="iw hj"> ` ` </strong>括起来，而不是用<strong class="iw hj"> " " </strong>括起来。</p><p id="e755" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw hj">使用模板文字的多行字符串— </strong></p><p id="8d2c" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">无需使用“\n”即可轻松编写多行字符串</p><figure class="ln lo lp lq fd ij er es paragraph-image"><div class="er es lm"><img src="../Images/4778376849aee204f3a93e8707866dbd.png" data-original-src="https://miro.medium.com/v2/resize:fit:502/format:webp/1*2rUajvKUbME7KCHBIxA7JA.jpeg"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">图 1:多行字符串</figcaption></figure><figure class="ln lo lp lq fd ij er es paragraph-image"><div class="er es lr"><img src="../Images/d9c04af95f25ea563d95f50cd6f66c01.png" data-original-src="https://miro.medium.com/v2/resize:fit:974/format:webp/1*EZv8fGWk25soSnlL8hWaaw.jpeg"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">图 2:多行字符串输出</figcaption></figure><p id="858f" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw hj">表达式插值— </strong></p><p id="28f5" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">在普通字符串中嵌入表达式</p><figure class="ln lo lp lq fd ij"><div class="bz dy l di"><div class="ls lt l"/></div></figure><p id="bf9c" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">这会将总和打印为 13。</p><p id="eb36" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw hj">嵌套模板— </strong></p><figure class="ln lo lp lq fd ij"><div class="bz dy l di"><div class="ls lt l"/></div></figure><figure class="ln lo lp lq fd ij er es paragraph-image"><div class="er es lu"><img src="../Images/936607bee0963552d1f1073a4216f771.png" data-original-src="https://miro.medium.com/v2/resize:fit:864/format:webp/1*cBH_gFvW69tArM54p5INWg.jpeg"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">图 3:嵌套模板</figcaption></figure><p id="6a21" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">请参考参考资料一节中的文章，以了解更多关于模板文字的信息。</p><h1 id="a0ee" class="kj kk hi bd kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg bi translated">7.班级</h1><p id="fcef" class="pw-post-body-paragraph iu iv hi iw b ix lh iz ja jb li jd je jf lj jh ji jj lk jl jm jn ll jp jq jr hb bi translated">JavaScript 类的行为与 Java 类相似。然而，有一些关键的区别。</p><ul class=""><li id="aff1" class="lv lw hi iw b ix iy jb jc jf lx jj ly jn lz jr ma mb mc md bi translated">在 Javascript 中，我们必须使用关键字“constructor”而不是类名来定义构造函数。</li><li id="74bd" class="lv lw hi iw b ix me jb mf jf mg jj mh jn mi jr ma mb mc md bi translated">不需要创建一个局部变量来调用<strong class="iw hj"> "this。&lt;variablename&gt;= variablename "</strong>在构造函数内部。</li><li id="026f" class="lv lw hi iw b ix me jb mf jf mg jj mh jn mi jr ma mb mc md bi translated">轻松覆盖功能。</li></ul><p id="852d" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">让我们从一个例子来看这几点。</p><figure class="ln lo lp lq fd ij"><div class="bz dy l di"><div class="ls lt l"/></div></figure><figure class="ln lo lp lq fd ij er es paragraph-image"><div class="er es mj"><img src="../Images/dba51b54652cb248d4b96f8432e28785.png" data-original-src="https://miro.medium.com/v2/resize:fit:890/format:webp/1*xuiRBLNBBthEGy-q90S2DA.jpeg"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">图 4: Javascript 类</figcaption></figure><h1 id="73b3" class="kj kk hi bd kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg bi translated">8.解构</h1><p id="8272" class="pw-post-body-paragraph iu iv hi iw b ix lh iz ja jb li jd je jf lj jh ji jj lk jl jm jn ll jp jq jr hb bi translated">这是 JavaScript 提供的一个有用的特性，可以从对象中提取属性并绑定它们。</p><p id="1c2a" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">让我们借助一些例子来理解析构对象的行为。</p><h2 id="d676" class="mk kk hi bd kl ml mm mn kp mo mp mq kt jf mr ms kx jj mt mu lb jn mv mw lf mx bi translated"><strong class="ak">访问数值</strong></h2><figure class="ln lo lp lq fd ij"><div class="bz dy l di"><div class="ls lt l"/></div></figure><figure class="ln lo lp lq fd ij er es paragraph-image"><div class="er es my"><img src="../Images/c79af0ff66b4da40860cc082609f6de9.png" data-original-src="https://miro.medium.com/v2/resize:fit:956/format:webp/1*WHc7aLmIvvtv7yr6IB9J2g.jpeg"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">图 5:解构 1</figcaption></figure><p id="f397" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">我们可以看到，使用对象析构要简单和干净得多。</p><h2 id="d699" class="mk kk hi bd kl ml mm mn kp mo mp mq kt jf mr ms kx jj mt mu lb jn mv mw lf mx bi translated">使用析构的另一种方式</h2><figure class="ln lo lp lq fd ij"><div class="bz dy l di"><div class="ls lt l"/></div></figure><p id="9202" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">现在该方法将打印 196。我们只传递了对象 vehicle，required 方法从对象中提取了必要的属性(上面例子中的“base”)。这消除了使用整个对象的需求。</p><h2 id="af07" class="mk kk hi bd kl ml mm mn kp mo mp mq kt jf mr ms kx jj mt mu lb jn mv mw lf mx bi translated">分配默认值</h2><p id="f39c" class="pw-post-body-paragraph iu iv hi iw b ix lh iz ja jb li jd je jf lj jh ji jj lk jl jm jn ll jp jq jr hb bi translated">考虑下面的例子，</p><figure class="ln lo lp lq fd ij"><div class="bz dy l di"><div class="ls lt l"/></div></figure><figure class="ln lo lp lq fd ij er es paragraph-image"><div class="er es mz"><img src="../Images/31e586c48e29ce635a4fb2d2170eb302.png" data-original-src="https://miro.medium.com/v2/resize:fit:968/format:webp/1*0b_eWHPaLaKj1ROZ_CBWhQ.jpeg"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">图 6:默认值</figcaption></figure><p id="45be" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">该应用程序打印了 Toyota，因为“品牌”属性在车辆内部很容易获得。但是，车辆内部没有颜色属性。因此，应用程序打印了默认值“蓝色”。</p><h2 id="751f" class="mk kk hi bd kl ml mm mn kp mo mp mq kt jf mr ms kx jj mt mu lb jn mv mw lf mx bi translated">用函数进行析构</h2><p id="a1fa" class="pw-post-body-paragraph iu iv hi iw b ix lh iz ja jb li jd je jf lj jh ji jj lk jl jm jn ll jp jq jr hb bi translated">考虑一个场景，我们需要读取一个文件。</p><figure class="ln lo lp lq fd ij"><div class="bz dy l di"><div class="ls lt l"/></div></figure><p id="ed6c" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">我们可以看到，使用析构的代码更加简洁，对开发人员也更加友好。我们不需要写“fs.readFileSync”。</p><h2 id="7b3a" class="mk kk hi bd kl ml mm mn kp mo mp mq kt jf mr ms kx jj mt mu lb jn mv mw lf mx bi translated">三个点(…)</h2><p id="1501" class="pw-post-body-paragraph iu iv hi iw b ix lh iz ja jb li jd je jf lj jh ji jj lk jl jm jn ll jp jq jr hb bi translated">这是 ES6 中引入的全新功能。这可以用作 Rest 运算符或 Spread 运算符。</p><h2 id="5da2" class="mk kk hi bd kl ml mm mn kp mo mp mq kt jf mr ms kx jj mt mu lb jn mv mw lf mx bi translated">Rest 运算符</h2><p id="c95d" class="pw-post-body-paragraph iu iv hi iw b ix lh iz ja jb li jd je jf lj jh ji jj lk jl jm jn ll jp jq jr hb bi translated">基本上是将所有剩余的元素添加到一个数组中。使函数可以接受不确定数量的参数作为数组。</p><figure class="ln lo lp lq fd ij"><div class="bz dy l di"><div class="ls lt l"/></div></figure><figure class="ln lo lp lq fd ij er es paragraph-image"><div class="er es na"><img src="../Images/80b286fbda553b189e5f63b95510c887.png" data-original-src="https://miro.medium.com/v2/resize:fit:1052/format:webp/1*DHHCTxsoJuAoxlhKLmDjTQ.jpeg"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">图 6: Rest 操作符</figcaption></figure><p id="11d5" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">我们还可以使用 rest 操作符将值从一个数组复制到另一个数组。</p><figure class="ln lo lp lq fd ij"><div class="bz dy l di"><div class="ls lt l"/></div></figure><h2 id="be2b" class="mk kk hi bd kl ml mm mn kp mo mp mq kt jf mr ms kx jj mt mu lb jn mv mw lf mx bi translated">传播算子</h2><p id="be76" class="pw-post-body-paragraph iu iv hi iw b ix lh iz ja jb li jd je jf lj jh ji jj lk jl jm jn ll jp jq jr hb bi translated">考虑这样一种情况，我们需要在某种列表中包含一个对象的所有元素。在这种情况下，我们可以使用 Spread 运算符。</p><h1 id="92de" class="kj kk hi bd kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg bi translated">9.承诺</h1><p id="db94" class="pw-post-body-paragraph iu iv hi iw b ix lh iz ja jb li jd je jf lj jh ji jj lk jl jm jn ll jp jq jr hb bi translated">这是 JavaScript 中处理异步操作的一种方式。承诺基本上是我们将来要做某事的保证。承诺的价值在创造的时候是未知的。这个值将在将来的某个时候提供。</p><p id="f268" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">承诺的主要状态</p><ul class=""><li id="abaa" class="lv lw hi iw b ix iy jb jc jf lx jj ly jn lz jr ma mb mc md bi translated"><strong class="iw hj">待定</strong>:承诺成功或失败前的状态。</li><li id="6441" class="lv lw hi iw b ix me jb mf jf mg jj mh jn mi jr ma mb mc md bi translated"><strong class="iw hj">解决</strong>:操作成功完成。</li><li id="61fb" class="lv lw hi iw b ix me jb mf jf mg jj mh jn mi jr ma mb mc md bi translated"><strong class="iw hj">被拒绝</strong>:操作失败。</li></ul><figure class="ln lo lp lq fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es nb"><img src="../Images/58e8227ad2674e9b3648d5213cb4aa9b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dL1edU2x_QZekaWNViIcZw.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">图 7:承诺</figcaption></figure><p id="36e8" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">让我们试着用一些例子来理解承诺。考虑这样一种情况，我们需要从一个网站获取数据，</p><figure class="ln lo lp lq fd ij"><div class="bz dy l di"><div class="ls lt l"/></div></figure><h2 id="7b77" class="mk kk hi bd kl ml mm mn kp mo mp mq kt jf mr ms kx jj mt mu lb jn mv mw lf mx bi translated">为什么我们要用承诺来包装这个？</h2><p id="66ca" class="pw-post-body-paragraph iu iv hi iw b ix lh iz ja jb li jd je jf lj jh ji jj lk jl jm jn ll jp jq jr hb bi translated">因为 HTTP 需要时间去服务器获取响应。</p><h2 id="8735" class="mk kk hi bd kl ml mm mn kp mo mp mq kt jf mr ms kx jj mt mu lb jn mv mw lf mx bi translated">消费者-</h2><p id="8b00" class="pw-post-body-paragraph iu iv hi iw b ix lh iz ja jb li jd je jf lj jh ji jj lk jl jm jn ll jp jq jr hb bi translated"><strong class="iw hj">。然后:</strong>当响应完成时</p><p id="7051" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw hj">。catch(): </strong>记录任何错误。</p><p id="80ed" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw hj">。最后(</strong>):不管状态如何(解决或拒绝)，这个方法都会触发。</p><p id="b4bc" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">现在，为了成功获得输出，我们需要借助“await”关键字在“async”函数中调用它。</p><ul class=""><li id="bf1d" class="lv lw hi iw b ix iy jb jc jf lx jj ly jn lz jr ma mb mc md bi translated"><strong class="iw hj">wait</strong>:等待承诺的操作员。</li></ul><figure class="ln lo lp lq fd ij"><div class="bz dy l di"><div class="ls lt l"/></div></figure><p id="9b4c" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">如果我们不使用 await 关键字会怎么样？</p><p id="7c28" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">那么程序将打印未定义的。这是因为应用程序没有等待承诺的响应(直到承诺被解析)。“await”关键字仅在“async”函数中有效。</p><p id="d18f" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">我使用了 Krishntha Dinesh 先生的以下视频来收集所需的信息。</p><figure class="ln lo lp lq fd ij"><div class="bz dy l di"><div class="nd lt l"/></div></figure></div><div class="ab cl ne nf gp ng" role="separator"><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj"/></div><div class="hb hc hd he hf"><h1 id="fef3" class="kj kk hi bd kl km nl ko kp kq nm ks kt ku nn kw kx ky no la lb lc np le lf lg bi translated">参考</h1><div class="js jt ez fb ju jv"><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals" rel="noopener  ugc nofollow" target="_blank"><div class="jw ab dw"><div class="jx ab jy cl cj jz"><h2 class="bd hj fi z dy ka ea eb kb ed ef hh bi translated">模板文字(模板字符串)- JavaScript | MDN</h2><div class="nq l"><h3 class="bd b fi z dy ka ea eb kb ed ef dx translated">在 ES2015 规范的早期版本中，它们被称为“模板字符串”。模板文字用……括起来</h3></div><div class="kc l"><p class="bd b fp z dy ka ea eb kb ed ef dx translated">developer.mozilla.org</p></div></div><div class="kd l"><div class="nr l kf kg kh kd ki io jv"/></div></div></a></div><div class="js jt ez fb ju jv"><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise" rel="noopener  ugc nofollow" target="_blank"><div class="jw ab dw"><div class="jx ab jy cl cj jz"><h2 class="bd hj fi z dy ka ea eb kb ed ef hh bi translated">Promise - JavaScript | MDN</h2><div class="nq l"><h3 class="bd b fi z dy ka ea eb kb ed ef dx translated">Promise 对象表示异步操作的最终完成(或失败)及其结果…</h3></div><div class="kc l"><p class="bd b fp z dy ka ea eb kb ed ef dx translated">developer.mozilla.org</p></div></div><div class="kd l"><div class="ns l kf kg kh kd ki io jv"/></div></div></a></div><div class="js jt ez fb ju jv"><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/rest_parameters" rel="noopener  ugc nofollow" target="_blank"><div class="jw ab dw"><div class="jx ab jy cl cj jz"><h2 class="bd hj fi z dy ka ea eb kb ed ef hh bi translated">Rest 参数- JavaScript | MDN</h2><div class="nq l"><h3 class="bd b fi z dy ka ea eb kb ed ef dx translated">rest 参数语法允许函数接受不确定数量的参数作为数组，提供了一种方法…</h3></div><div class="kc l"><p class="bd b fp z dy ka ea eb kb ed ef dx translated">developer.mozilla.org</p></div></div><div class="kd l"><div class="nt l kf kg kh kd ki io jv"/></div></div></a></div></div></div>    
</body>
</html>