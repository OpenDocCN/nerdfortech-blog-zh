<html>
<head>
<title>Ranges Indices and Static Local functions in C-Sharp</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">C-Sharp 中的值域指数和静态局部函数</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/ranges-indices-and-static-local-functions-in-c-sharp-712485e1cc3e?source=collection_archive---------16-----------------------#2021-06-17">https://medium.com/nerd-for-tech/ranges-indices-and-static-local-functions-in-c-sharp-712485e1cc3e?source=collection_archive---------16-----------------------#2021-06-17</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/141c06594b84c983727965942f82e281.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*V6HKWwRmxRZgNtYg"/></div></div></figure><p id="c6fe" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">市场上有几种编程语言可以实现您的需求。在选择编程语言时，您可能最终会考虑很多外部因素。例如，这种语言应该有一个良好的生态系统，社区支持，以及可以使用它的人。</p><p id="ae16" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">除此之外，编程语言还能为开发人员提供什么也很重要。它是否能够以更快的方式实现一些常见和复杂的操作？它有强大的编程语言中常见的特性吗？这些东西让开发者的生活变得更好。</p><p id="38a0" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">说到常见的操作，Python 有一系列非常有助于处理集合和从集合中检索数据的操作。类似地，在 C#中(在版本 8 之后)，引入了一组新特性来处理集合操作。让我们详细了解一下这些特性，以及它们在实现部分有多大帮助。</p><p id="2208" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">目录</strong></p><ol class=""><li id="d4de" class="jo jp hi is b it iu ix iy jb jq jf jr jj js jn jt ju jv jw bi translated">了解范围和指数</li><li id="c2ac" class="jo jp hi is b it jx ix jy jb jz jf ka jj kb jn jt ju jv jw bi translated">理解静态局部函数</li><li id="6425" class="jo jp hi is b it jx ix jy jb jz jf ka jj kb jn jt ju jv jw bi translated">结论</li></ol><h1 id="50f4" class="kc kd hi bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated">了解范围和指数</h1><p id="aede" class="pw-post-body-paragraph iq ir hi is b it la iv iw ix lb iz ja jb lc jd je jf ld jh ji jj le jl jm jn hb bi translated">在 C#中，索引和范围用于以更快的方式访问集合中的数据。</p><p id="e137" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">索引存在于命名空间 System.Index 中。顾名思义，索引用于根据元素在集合中的位置来访问元素。让我们了解在新技术引入之前这是如何实现的，然后将其与今天可能实现的进行比较。</p><p id="6a9f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">假设我们需要访问集合中的最后一个元素。</p><p id="bc54" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">收藏</strong></p><pre class="lf lg lh li fd lj lk ll lm aw ln bi"><span id="be65" class="lo kd hi lk b fi lp lq l lr ls">var collection = new List&lt;string&gt;() { "1", "2", "3", "4", "5", "6", "7", "8" };</span></pre><p id="51fa" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">早前</strong></p><pre class="lf lg lh li fd lj lk ll lm aw ln bi"><span id="5272" class="lo kd hi lk b fi lp lq l lr ls">var data = collection[(collection.Count - 1)];</span></pre><p id="f757" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">新技术后，</strong></p><pre class="lf lg lh li fd lj lk ll lm aw ln bi"><span id="81f5" class="lo kd hi lk b fi lp lq l lr ls">var data = collection[^1];</span></pre><p id="ff3d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">此外，为了用 hat 操作符保存索引的值，可以使用 Index 类型的变量。随后该变量可用于获取特定的索引。</p><pre class="lf lg lh li fd lj lk ll lm aw ln bi"><span id="7d3d" class="lo kd hi lk b fi lp lq l lr ls">Index ind = ^4; var data = collection[ind];</span></pre><p id="8a7d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这里，hat(^运算符表示从最后一个开始的索引。当我们使用 hat 操作符时，它执行与 count-1 相同的逻辑。所以当我们使用^0 时，这意味着它会抛出一个错误，因为索引从 0 开始，以 count-1 结束。类似地，要访问倒数第二、倒数第三等等，可以使用带有相应数字的 hat 运算符。</p><p id="8471" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">到目前为止，我们已经看到了什么是指数，以及它如何帮助我们在不做任何计算的情况下从相反的方向获得元素。现在让我们来看看范围。</p><p id="cd8d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">范围来自命名空间系统。范围，领先于指数一步。如果索引用于从集合中获取特定元素，那么 Range 用于从集合中获取一系列元素。因为我们不能应用列表的范围，所以我们用一个数组来处理当前列表。</p><p id="6c7b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">例如，如果我们需要从 3 到 5 获取元素，那么在现有的代码中，我们可以用下面的代码获取数据。</p><pre class="lf lg lh li fd lj lk ll lm aw ln bi"><span id="ef44" class="lo kd hi lk b fi lp lq l lr ls">collection.Skip(3).Take(2);</span></pre><p id="5812" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">随着范围的引入，从集合中获取一系列元素变得更加容易。这是怎么做的-</p><pre class="lf lg lh li fd lj lk ll lm aw ln bi"><span id="cb02" class="lo kd hi lk b fi lp lq l lr ls">var result = collection[3..5];</span></pre><p id="7e2b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">上述范围从索引号 3 开始打印，一直打印到索引号之前的 1。这里我们从集合中得到两个元素。</p><p id="9e2e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">类似地，范围可以在开关情况下实现。比方说，如果我们有一组必须做类似工作序列，那么，</p><pre class="lf lg lh li fd lj lk ll lm aw ln bi"><span id="5b6a" class="lo kd hi lk b fi lp lq l lr ls">Switch (statement) { ​ Case 1..10: ​ //do this ​ Case 11..20: ​ //do this }</span></pre><p id="cd17" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在上面的例子中，介于 1 和 10 之间的语句将执行其下的代码。类似地，语句 11 到 20 将执行相同的代码。</p><p id="02df" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">C#并没有停止单独提供索引和范围功能。相反，它提供了在代码中一起使用它们的选项。现在让我们来看看在开发时它将如何得心应手。</p><p id="dbd6" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们在系列中看到了如何编写 Skip 3 和 Take 2。两者并用也能达到同样的效果。</p><pre class="lf lg lh li fd lj lk ll lm aw ln bi"><span id="4e5e" class="lo kd hi lk b fi lp lq l lr ls">var data = collection[3..^3];</span></pre><p id="1fbb" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这里的起始索引从 3 开始，然后一直到集合中的倒数第四个元素。</p><p id="5a9a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">类似地，下面是通过将范围和索引结合在一起可以实现的一些场景。</p><pre class="lf lg lh li fd lj lk ll lm aw ln bi"><span id="040d" class="lo kd hi lk b fi lp lq l lr ls">var data = collection[..^3];</span><span id="cbcb" class="lo kd hi lk b fi lt lq l lr ls">var data = collection[^2..^0]</span></pre><p id="f2a9" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这里，^0 不会抛出一个错误，因为我们知道在 Range 中，最后一个指定元素之前的元素将被考虑在内。</p><h1 id="5053" class="kc kd hi bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated">理解静态局部函数</h1><p id="7938" class="pw-post-body-paragraph iq ir hi is b it la iv iw ix lb iz ja jb lc jd je jf ld jh ji jj le jl jm jn hb bi translated">在 C# 7.0 中，引入了一个新特性，允许开发人员在一个方法中创建一个局部函数。这有助于开发人员从 it 中获得所需的功能。这里有一个例子-</p><pre class="lf lg lh li fd lj lk ll lm aw ln bi"><span id="5b7e" class="lo kd hi lk b fi lp lq l lr ls">String Method2() { ​ int variable; ​ LocalFunction(); ​ return variable; ​ LocalFunction() =&gt; variable = 0; }</span></pre><p id="b964" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在上面的例子中，变量将在局部函数中被覆盖，这会影响初始值和它的使用位置。为了避免这种情况，静态局部函数作为 C# 8.0 的一部分被引入。这确保了包含在方法中的变量不会因为局部函数中发生的变化而受到影响。</p><pre class="lf lg lh li fd lj lk ll lm aw ln bi"><span id="12ea" class="lo kd hi lk b fi lp lq l lr ls">String Method2() { ​ int firstVariable = 5 ; int secondVariable = 6 ; ​ return LocalFunction(firstVariable + secondVariable); ​ Static LocalFunction(int left, int right) =&gt; left + right; }</span></pre><p id="c966" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在上面的例子中，输入参数不能在包含在 Method2 中的局部函数中改变。</p><h1 id="d3bf" class="kc kd hi bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated">结论</h1><p id="eb1d" class="pw-post-body-paragraph iq ir hi is b it la iv iw ix lb iz ja jb lc jd je jf ld jh ji jj le jl jm jn hb bi translated">静态局部函数、索引和范围是作为 C# 8.0 的一部分发布的一些最有用和方便的特性。在应用程序中使用它们可以为您和您的开发人员节省大量时间。</p></div><div class="ab cl lu lv gp lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="hb hc hd he hf"><p id="b900" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><em class="mb">原载于</em><a class="ae mc" href="https://www.partech.nl/nl/publicaties/2021/06/ranges-indices-and-static-local-functions-in-c-sharp" rel="noopener ugc nofollow" target="_blank"><em class="mb">https://www . partech . nl</em></a><em class="mb">。</em></p></div></div>    
</body>
</html>