<html>
<head>
<title>What’s new in Java 14?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Java 14有什么新特性？</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/whats-new-in-java-14-907190a984d9?source=collection_archive---------24-----------------------#2021-07-04">https://medium.com/nerd-for-tech/whats-new-in-java-14-907190a984d9?source=collection_archive---------24-----------------------#2021-07-04</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="8a0f" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">让我们回顾一下Java 14的最新特性</h2></div><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es ix"><img src="../Images/5c44da7143bde32a783c4f647cf91a35.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/1*pA2gEqz8tpB1onphNsc0ZA.jpeg"/></div><figcaption class="jf jg et er es jh ji bd b be z dx translated">照片由<a class="ae jj" href="https://unsplash.com/@fahmipaping" rel="noopener ugc nofollow" target="_blank">法赫米·法克鲁丁</a>在<a class="ae jj" href="https://unsplash.com" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="02ee" class="pw-post-body-paragraph jk jl hi jm b jn jo ij jp jq jr im js jt ju jv jw jx jy jz ka kb kc kd ke kf hb bi kg translated"><span class="l kh ki kj bm kk kl km kn ko di"> J </span> ava 14 (Java SE 14)及其Java开发工具包14 (JDK 14)开源已于2020年3月17日发布。版本14中发布了大量的Java增强建议(jep)。Java 14解决了下面列出的总共16个主要增强/变化(jep)。</p></div><div class="ab cl kp kq gp kr" role="separator"><span class="ks bw bk kt ku kv"/><span class="ks bw bk kt ku kv"/><span class="ks bw bk kt ku"/></div><div class="hb hc hd he hf"><h2 id="b0e9" class="kw kx hi bd ky kz la lb lc ld le lf lg jt lh li lj jx lk ll lm kb ln lo lp lq bi translated"><strong class="ak"> <em class="lr"> JEP 305:实例的模式匹配(预览)</em> </strong></h2><p id="b0ff" class="pw-post-body-paragraph jk jl hi jm b jn ls ij jp jq lt im js jt lu jv jw jx lv jz ka kb lw kd ke kf hb bi translated">Java 14之前:</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es lx"><img src="../Images/3361c6aa58a369859c6ee81ff651060f.png" data-original-src="https://miro.medium.com/v2/resize:fit:960/format:webp/1*jhLc4GFRyFzsOFQ5G7P0uw.jpeg"/></div></figure><p id="3860" class="pw-post-body-paragraph jk jl hi jm b jn jo ij jp jq jr im js jt ju jv jw jx jy jz ka kb kc kd ke kf hb bi translated">现在，在Java 14增强之后，我们可以像这样重构上面的代码:</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es ly"><img src="../Images/2d1f033f7641b58ce76866dee5a2e5b8.png" data-original-src="https://miro.medium.com/v2/resize:fit:968/format:webp/1*65i-to8yyLhjqUiQGoINiw.jpeg"/></div></figure></div><div class="ab cl kp kq gp kr" role="separator"><span class="ks bw bk kt ku kv"/><span class="ks bw bk kt ku kv"/><span class="ks bw bk kt ku"/></div><div class="hb hc hd he hf"><h2 id="3ace" class="kw kx hi bd ky kz la lb lc ld le lf lg jt lh li lj jx lk ll lm kb ln lo lp lq bi translated"><strong class="ak"> <em class="lr"> JEP 343:包装工具(保温箱)</em> </strong></h2><p id="9b30" class="pw-post-body-paragraph jk jl hi jm b jn ls ij jp jq lt im js jt lu jv jw jx lv jz ka kb lw kd ke kf hb bi translated">JEP 343提供了一个孵化工具jpackage来打包自包含的Java应用。这个JEP是JDK 14号的一部分。jpackage将一个Java应用程序打包成一个特定于平台的包，其中包含所有必需的依赖项。它支持不同的特定于平台的包格式。</p><ul class=""><li id="7824" class="lz ma hi jm b jn jo jq jr jt mb jx mc kb md kf me mf mg mh bi translated">Linux — deb和rpm</li><li id="056a" class="lz ma hi jm b jn mi jq mj jt mk jx ml kb mm kf me mf mg mh bi translated">macOS — pkg和dmg</li><li id="3c1a" class="lz ma hi jm b jn mi jq mj jt mk jx ml kb mm kf me mf mg mh bi translated">Windows — msi和exe</li></ul></div><div class="ab cl kp kq gp kr" role="separator"><span class="ks bw bk kt ku kv"/><span class="ks bw bk kt ku kv"/><span class="ks bw bk kt ku"/></div><div class="hb hc hd he hf"><h2 id="c051" class="kw kx hi bd ky kz la lb lc ld le lf lg jt lh li lj jx lk ll lm kb ln lo lp lq bi translated"><strong class="ak"><em class="lr">JEP 345:G1的NUMA感知内存分配</em> </strong></h2><p id="cc10" class="pw-post-body-paragraph jk jl hi jm b jn ls ij jp jq lt im js jt lu jv jw jx lv jz ka kb lw kd ke kf hb bi translated">多核处理器现在是通用标准。在NUMA内存架构中，每个处理器内核接收少量本地内存，但其他内核有权访问。JEP 345计划为G1垃圾收集器配备有利地使用这种架构的可能性。其中，这是为了提高非常强大的机器的性能。</p><p id="0557" class="pw-post-body-paragraph jk jl hi jm b jn jo ij jp jq jr im js jt ju jv jw jx jy jz ka kb kc kd ke kf hb bi translated">JEP 345专门用于实现对G1垃圾收集器的NUMA支持，仅用于内存管理(内存分配)并且也仅在Linux下。这种对NUMA架构的支持是否也适用于其他垃圾收集器或者其他部分，比如任务队列窃取，还不知道。</p></div><div class="ab cl kp kq gp kr" role="separator"><span class="ks bw bk kt ku kv"/><span class="ks bw bk kt ku kv"/><span class="ks bw bk kt ku"/></div><div class="hb hc hd he hf"><h2 id="7291" class="kw kx hi bd ky kz la lb lc ld le lf lg jt lh li lj jx lk ll lm kb ln lo lp lq bi translated"><strong class="ak"> <em class="lr"> JEP 349: JFR事件流播</em> </strong></h2><p id="6c0b" class="pw-post-body-paragraph jk jl hi jm b jn ls ij jp jq lt im js jt lu jv jw jx lv jz ka kb lw kd ke kf hb bi translated">Java飞行记录器(JFR)现在是OpenJDK的一部分，因此可以免费获得。JEP 349创建了一个API，通过该API，Java飞行记录器收集的数据可用于持续监控活动和非活动的应用程序。</p></div><div class="ab cl kp kq gp kr" role="separator"><span class="ks bw bk kt ku kv"/><span class="ks bw bk kt ku kv"/><span class="ks bw bk kt ku"/></div><div class="hb hc hd he hf"><h2 id="7c89" class="kw kx hi bd ky kz la lb lc ld le lf lg jt lh li lj jx lk ll lm kb ln lo lp lq bi translated"><strong class="ak"> <em class="lr"> JEP 352:非易失性映射字节缓冲器</em> </strong></h2><p id="83a6" class="pw-post-body-paragraph jk jl hi jm b jn ls ij jp jq lt im js jt lu jv jw jx lv jz ka kb lw kd ke kf hb bi translated">改进的FileChannel API可创建访问非易失性内存(NVM)的MappedByteBuffer，这种内存即使在重启后也可以检索存储的数据。例如，该特性确保了可能仍在缓存中的任何更改都被写回到内存中。只有Linux/x64和Linux/AArch64操作系统支持这一点。</p></div><div class="ab cl kp kq gp kr" role="separator"><span class="ks bw bk kt ku kv"/><span class="ks bw bk kt ku kv"/><span class="ks bw bk kt ku"/></div><div class="hb hc hd he hf"><h2 id="05ef" class="kw kx hi bd ky kz la lb lc ld le lf lg jt lh li lj jx lk ll lm kb ln lo lp lq bi translated"><strong class="ak"> <em class="lr"> JEP 358:有用的空指针异常</em> </strong></h2><p id="e522" class="pw-post-body-paragraph jk jl hi jm b jn ls ij jp jq lt im js jt lu jv jw jx lv jz ka kb lw kd ke kf hb bi translated">通过告知哪个变量为空，改进了对NullPointerExceptions的描述。添加-XX:+ShowCodeDetailsInExceptionMessages选项以启用此功能。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="mo mp di mq bf mr"><div class="er es mn"><img src="../Images/9bf1bc2baa1be1711b6e197730cd98e6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*v1X9NIDQsTlYftxY4wD_Tg.jpeg"/></div></div></figure><p id="71d5" class="pw-post-body-paragraph jk jl hi jm b jn jo ij jp jq jr im js jt ju jv jw jx jy jz ka kb kc kd ke kf hb bi translated">Java 14之前:</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es ms"><img src="../Images/a63eddd69f989ec42b09ab356a9954a1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1354/format:webp/1*3wIn3Nfxy_yRc8dodAzcUw.jpeg"/></div></figure><p id="61ab" class="pw-post-body-paragraph jk jl hi jm b jn jo ij jp jq jr im js jt ju jv jw jx jy jz ka kb kc kd ke kf hb bi translated">带有-XX:+ShowCodeDetailsInExceptionMessages选项的Java 14:</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="mo mp di mq bf mr"><div class="er es mt"><img src="../Images/d9e6b2ec1846b14f48b61573fe700204.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*b6_9F87aAFjcROL6J8ScuA.jpeg"/></div></div></figure></div><div class="ab cl kp kq gp kr" role="separator"><span class="ks bw bk kt ku kv"/><span class="ks bw bk kt ku kv"/><span class="ks bw bk kt ku"/></div><div class="hb hc hd he hf"><h2 id="689a" class="kw kx hi bd ky kz la lb lc ld le lf lg jt lh li lj jx lk ll lm kb ln lo lp lq bi translated"><strong class="ak"> <em class="lr"> JEP 359:首辅(预览)</em> </strong></h2><p id="5770" class="pw-post-body-paragraph jk jl hi jm b jn ls ij jp jq lt im js jt lu jv jw jx lv jz ka kb lw kd ke kf hb bi translated">记录是存储纯数据的数据类。引入记录背后的想法是快速创建没有样板代码的简单明了的类。通常Java中的类需要你实现equals()，hashCode()，getters和setters方法。虽然有些ide支持自动生成这样的类，但是代码仍然很冗长。对于一个记录，你只需要用下面的方式定义一个类。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es mu"><img src="../Images/8926284582b2e5ccaed5e95124a4e618.png" data-original-src="https://miro.medium.com/v2/resize:fit:1020/format:webp/1*3EpT2B1SnBWwmrgOaLXR7Q.jpeg"/></div></figure><p id="8ad2" class="pw-post-body-paragraph jk jl hi jm b jn jo ij jp jq jr im js jt ju jv jw jx jy jz ka kb kc kd ke kf hb bi translated">Java编译器将自动生成一个构造函数、私有final字段、访问器、equals/hashCode和toString方法。上述类的自动生成的getter方法是name()和topic()。</p><p id="96b2" class="pw-post-body-paragraph jk jl hi jm b jn jo ij jp jq jr im js jt ju jv jw jx jy jz ka kb kc kd ke kf hb bi translated">我们可以通过以下方式向记录中添加额外的字段、方法和构造函数:</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="mo mp di mq bf mr"><div class="er es mv"><img src="../Images/1322b408c972c854e47ee8c0b334c236.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lQz6foqpn4do5fbEiQUtkw.jpeg"/></div></div></figure><p id="19c9" class="pw-post-body-paragraph jk jl hi jm b jn jo ij jp jq jr im js jt ju jv jw jx jy jz ka kb kc kd ke kf hb bi translated">记录中定义的附加构造函数称为紧凑构造函数。它不包含任何参数，只是规范构造函数的扩展。编译器不会将紧凑构造函数生成为单独的构造函数。相反，它用于验证案例，并将在主构造函数开始时被调用。</p><p id="f7f1" class="pw-post-body-paragraph jk jl hi jm b jn jo ij jp jq jr im js jt ju jv jw jx jy jz ka kb kc kd ke kf hb bi translated">关于记录，还有一些更重要的事情需要注意:</p><ul class=""><li id="4359" class="lz ma hi jm b jn jo jq jr jt mb jx mc kb md kf me mf mg mh bi translated">一个记录既不能扩展一个类，也不能被另一个类扩展。这是最后一门课。</li><li id="d7d9" class="lz ma hi jm b jn mi jq mj jt mk jx ml kb mm kf me mf mg mh bi translated">记录不能是抽象的</li><li id="c03f" class="lz ma hi jm b jn mi jq mj jt mk jx ml kb mm kf me mf mg mh bi translated">记录不能扩展任何其他类，也不能在主体内定义实例字段。实例字段只能在状态描述中定义</li><li id="1eb7" class="lz ma hi jm b jn mi jq mj jt mk jx ml kb mm kf me mf mg mh bi translated">声明的字段是私有的和最终的</li><li id="879e" class="lz ma hi jm b jn mi jq mj jt mk jx ml kb mm kf me mf mg mh bi translated">记录的主体允许静态字段和方法</li><li id="6e35" class="lz ma hi jm b jn mi jq mj jt mk jx ml kb mm kf me mf mg mh bi translated">记录允许修改访问器方法</li><li id="0166" class="lz ma hi jm b jn mi jq mj jt mk jx ml kb mm kf me mf mg mh bi translated">记录支持多个构造函数</li><li id="6136" class="lz ma hi jm b jn mi jq mj jt mk jx ml kb mm kf me mf mg mh bi translated">记录可以实现接口</li><li id="5ab2" class="lz ma hi jm b jn mi jq mj jt mk jx ml kb mm kf me mf mg mh bi translated">记录的引用字段内的值可以变异</li></ul><p id="9557" class="pw-post-body-paragraph jk jl hi jm b jn jo ij jp jq jr im js jt ju jv jw jx jy jz ka kb kc kd ke kf hb bi translated">此功能可以通过—启用—预览来测试。</p></div><div class="ab cl kp kq gp kr" role="separator"><span class="ks bw bk kt ku kv"/><span class="ks bw bk kt ku kv"/><span class="ks bw bk kt ku"/></div><div class="hb hc hd he hf"><h2 id="c8aa" class="kw kx hi bd ky kz la lb lc ld le lf lg jt lh li lj jx lk ll lm kb ln lo lp lq bi translated"><strong class="ak"><em class="lr">【JEP 361:开关表情(标准)</em> </strong></h2><p id="da9d" class="pw-post-body-paragraph jk jl hi jm b jn ls ij jp jq lt im js jt lu jv jw jx lv jz ka kb lw kd ke kf hb bi translated">在前两个版本中保留了预览特性之后，切换表达式——Java 12和Java 13最终在Java 14中获得了永久的地位。</p><ul class=""><li id="0231" class="lz ma hi jm b jn jo jq jr jt mb jx mc kb md kf me mf mg mh bi translated">Java 12为switch表达式引入了lambda语法，从而允许使用多个case标签进行模式匹配，并防止导致冗长代码的失败。它还强制执行了穷举的情况，如果没有覆盖所有的输入情况，就会抛出编译错误。</li><li id="6381" class="lz ma hi jm b jn mi jq mj jt mk jx ml kb mm kf me mf mg mh bi translated">Java 13的第二个预览版引入了yield语句，而不是break来从表达式返回值。</li></ul><p id="1901" class="pw-post-body-paragraph jk jl hi jm b jn jo ij jp jq jr im js jt ju jv jw jx jy jz ka kb kc kd ke kf hb bi translated">Java 14现在终于让这些特性成为了标准。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es mw"><img src="../Images/e77fa11936520f31eadbb0dd594a0d7c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1284/format:webp/1*N_EnCsN93HlrKusB7wtTFQ.jpeg"/></div></figure></div><div class="ab cl kp kq gp kr" role="separator"><span class="ks bw bk kt ku kv"/><span class="ks bw bk kt ku kv"/><span class="ks bw bk kt ku"/></div><div class="hb hc hd he hf"><h2 id="586a" class="kw kx hi bd ky kz la lb lc ld le lf lg jt lh li lj jx lk ll lm kb ln lo lp lq bi translated"><strong class="ak"> <em class="lr"> JEP 362:弃用Solaris和SPARC端口</em> </strong></h2><p id="d655" class="pw-post-body-paragraph jk jl hi jm b jn ls ij jp jq lt im js jt lu jv jw jx lv jz ka kb lw kd ke kf hb bi translated">放弃对Solaris/SPARC、Solaris/x64和Linux/SPARC端口的支持，更少的平台支持意味着新功能的交付速度更快。</p></div><div class="ab cl kp kq gp kr" role="separator"><span class="ks bw bk kt ku kv"/><span class="ks bw bk kt ku kv"/><span class="ks bw bk kt ku"/></div><div class="hb hc hd he hf"><h2 id="0146" class="kw kx hi bd ky kz la lb lc ld le lf lg jt lh li lj jx lk ll lm kb ln lo lp lq bi translated"><strong class="ak"> <em class="lr"> JEP 363:移除并发标记清扫(CMS)垃圾收集器</em> </strong></h2><p id="68bb" class="pw-post-body-paragraph jk jl hi jm b jn ls ij jp jq lt im js jt lu jv jw jx lv jz ka kb lw kd ke kf hb bi translated">Java 9 — JEP 291不赞成使用这种并发标记清除(CMS)垃圾收集器，现在它被正式删除了。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="mo mp di mq bf mr"><div class="er es mx"><img src="../Images/4ef34a1984b37f2cc0dc427bc77871c8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*q0QY60sJ8US-R_cs7g6SSg.jpeg"/></div></div></figure></div><div class="ab cl kp kq gp kr" role="separator"><span class="ks bw bk kt ku kv"/><span class="ks bw bk kt ku kv"/><span class="ks bw bk kt ku"/></div><div class="hb hc hd he hf"><h2 id="d347" class="kw kx hi bd ky kz la lb lc ld le lf lg jt lh li lj jx lk ll lm kb ln lo lp lq bi translated"><strong class="ak"><em class="lr">JEP 364:MAC OS上的ZGC(实验)</em> </strong></h2><p id="7bb9" class="pw-post-body-paragraph jk jl hi jm b jn ls ij jp jq lt im js jt lu jv jw jx lv jz ka kb lw kd ke kf hb bi translated">Java 11——JEP 333在Linux上引入了Z垃圾收集器(ZGC ),现在它可以移植到macOS。</p></div><div class="ab cl kp kq gp kr" role="separator"><span class="ks bw bk kt ku kv"/><span class="ks bw bk kt ku kv"/><span class="ks bw bk kt ku"/></div><div class="hb hc hd he hf"><h2 id="c61f" class="kw kx hi bd ky kz la lb lc ld le lf lg jt lh li lj jx lk ll lm kb ln lo lp lq bi translated"><strong class="ak"><em class="lr">JEP 365:Windows上的ZGC(实验)</em> </strong></h2><p id="2920" class="pw-post-body-paragraph jk jl hi jm b jn ls ij jp jq lt im js jt lu jv jw jx lv jz ka kb lw kd ke kf hb bi translated">Java 11 — JEP 333在Linux上引入了Z垃圾收集器(ZGC)，现在它可以移植到Windows版本&gt; = 1803。</p></div><div class="ab cl kp kq gp kr" role="separator"><span class="ks bw bk kt ku kv"/><span class="ks bw bk kt ku kv"/><span class="ks bw bk kt ku"/></div><div class="hb hc hd he hf"><h2 id="2a56" class="kw kx hi bd ky kz la lb lc ld le lf lg jt lh li lj jx lk ll lm kb ln lo lp lq bi translated"><strong class="ak"> <em class="lr"> JEP 366:反对ParallelScavenge + SerialOld GC组合</em> </strong></h2><p id="74e3" class="pw-post-body-paragraph jk jl hi jm b jn ls ij jp jq lt im js jt lu jv jw jx lv jz ka kb lw kd ke kf hb bi translated">由于较少使用和大量维护工作，Java 14不赞成并行年轻一代和串行老一代GC算法的组合。/usr/lib/JVM/JDK-14/bin/Java-XX:-useparallelloldgc测试</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="mo mp di mq bf mr"><div class="er es my"><img src="../Images/d7f96af0b2e0a1b5a2494517ba4dbba3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hMfgyi1qrJ-HsZQSqNAJ4A.jpeg"/></div></div></figure></div><div class="ab cl kp kq gp kr" role="separator"><span class="ks bw bk kt ku kv"/><span class="ks bw bk kt ku kv"/><span class="ks bw bk kt ku"/></div><div class="hb hc hd he hf"><h2 id="0916" class="kw kx hi bd ky kz la lb lc ld le lf lg jt lh li lj jx lk ll lm kb ln lo lp lq bi translated"><strong class="ak"> <em class="lr"> JEP 367:移除Pack200工具和API </em> </strong></h2><p id="0e88" class="pw-post-body-paragraph jk jl hi jm b jn ls ij jp jq lt im js jt lu jv jw jx lv jz ka kb lw kd ke kf hb bi translated">Java 11 — JEP 336弃用了pack200和unpack200工具，以及java.util.jar包中的Pack200 API，现在正式删除了。</p></div><div class="ab cl kp kq gp kr" role="separator"><span class="ks bw bk kt ku kv"/><span class="ks bw bk kt ku kv"/><span class="ks bw bk kt ku"/></div><div class="hb hc hd he hf"><h2 id="0426" class="kw kx hi bd ky kz la lb lc ld le lf lg jt lh li lj jx lk ll lm kb ln lo lp lq bi translated"><strong class="ak"> <em class="lr"> JEP 368:文字块(第二次预览)</em> </strong></h2><p id="16ab" class="pw-post-body-paragraph jk jl hi jm b jn ls ij jp jq lt im js jt lu jv jw jx lv jz ka kb lw kd ke kf hb bi translated">第一个预览版出现在Java 13 — JEP 354中，现在又增加了两个新的转义序列:</p><ul class=""><li id="561e" class="lz ma hi jm b jn jo jq jr jt mb jx mc kb md kf me mf mg mh bi translated">\ <end-of-line>取消行终止。</end-of-line></li><li id="1cdc" class="lz ma hi jm b jn mi jq mj jt mk jx ml kb mm kf me mf mg mh bi translated">\s被转换成一个空格。</li></ul><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es mz"><img src="../Images/6ec5ff89e9b0bb6bf5c01683a0c741e8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1238/format:webp/1*2szSFO2oNV3oqupAcAMVeA.jpeg"/></div></figure><p id="6c6a" class="pw-post-body-paragraph jk jl hi jm b jn jo ij jp jq jr im js jt ju jv jw jx jy jz ka kb kc kd ke kf hb bi translated">使用-启用-预览来启用该特征</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="mo mp di mq bf mr"><div class="er es na"><img src="../Images/f4a638cb8b55b8688e84db1f0f46a6de.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*n556IJ-KvWIBmK431hVivw.jpeg"/></div></div></figure><p id="7f8f" class="pw-post-body-paragraph jk jl hi jm b jn jo ij jp jq jr im js jt ju jv jw jx jy jz ka kb kc kd ke kf hb bi translated">输出:</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es nb"><img src="../Images/9ba0c0cccf7c5c9a7a6e88737b8611a9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1262/format:webp/1*vXf3nEgLpXWwxlTz9ov75A.jpeg"/></div></figure></div><div class="ab cl kp kq gp kr" role="separator"><span class="ks bw bk kt ku kv"/><span class="ks bw bk kt ku kv"/><span class="ks bw bk kt ku"/></div><div class="hb hc hd he hf"><h2 id="1621" class="kw kx hi bd ky kz la lb lc ld le lf lg jt lh li lj jx lk ll lm kb ln lo lp lq bi translated"><strong class="ak"> <em class="lr"> JEP 370:外来内存访问API(孵化器)</em> </strong></h2><p id="27e5" class="pw-post-body-paragraph jk jl hi jm b jn ls ij jp jq lt im js jt lu jv jw jx lv jz ka kb lw kd ke kf hb bi translated">一个孵化器模块，允许Java API访问Java堆之外的外部内存。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="mo mp di mq bf mr"><div class="er es nc"><img src="../Images/06176f991434de7d39fc41733478012b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*uclcApcpIaBNDkfd"/></div></div></figure><p id="498d" class="pw-post-body-paragraph jk jl hi jm b jn jo ij jp jq jr im js jt ju jv jw jx jy jz ka kb kc kd ke kf hb bi translated">编译并运行孵化器模块jdk.incubator.foreign</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="mo mp di mq bf mr"><div class="er es nd"><img src="../Images/b49ad6ee2a225f143ea093a13dfd1df8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*7mF8GUv0VaewBlMP"/></div></div></figure></div></div>    
</body>
</html>