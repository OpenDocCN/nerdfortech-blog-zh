<html>
<head>
<title>C# — Threading Summary</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">C# —线程摘要</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/c-threading-summary-758a6909e152?source=collection_archive---------0-----------------------#2022-11-13">https://medium.com/nerd-for-tech/c-threading-summary-758a6909e152?source=collection_archive---------0-----------------------#2022-11-13</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/834f189a26d743595fd1d53ee5b06d96.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xKyySfit8mALJJ8O0U71ZQ.png"/></div></div></figure><p id="fc35" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这是另一篇总结 C#线程基础的文章。包括线程和任务。也异步/等待</p><p id="3e75" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我想首先要说的是，不要从一个线程或任务中更新 UI，因为它们将在不同的线程中运行，所以它们不能真正访问 UI 元素。</p><h1 id="568c" class="jo jp hi bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">线</h1><p id="19e7" class="pw-post-body-paragraph iq ir hi is b it km iv iw ix kn iz ja jb ko jd je jf kp jh ji jj kq jl jm jn hb bi translated">线程将运行到完成，因此应用程序在线程运行时不会结束。只要线程处于活动状态，您就可以更改该线程的优先级。你也可以中止一个线程，但是资源可能会被阻塞。</p><p id="0f6f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">一个线程不能将结果传递给另一个线程，但是它可以接收数据。</p><p id="93dc" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">线程中发生的异常应该在线程内部被捕获。</p><p id="3091" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">先说一个基本的例子。该线程将等待 3 秒钟，然后将一些内容打印到控制台。main 方法将继续运行并打印“In Main ”,而不等待线程，线程运行在…不同的线程:-):</p><pre class="kr ks kt ku fd kv kw kx bn ky kz bi"><span id="2a55" class="la jp hi kw b be lb lc l ld le">using System;<br/>using System.Threading;<br/><br/>class Program {      <br/>    <br/>    public static void Main(string[] args) {           <br/>        Thread th = new Thread( () =&gt; <br/>        { <br/>            Thread.Sleep(3000);<br/>            Console.WriteLine("In Thread"); <br/>        });<br/>        <br/>        th.Start();<br/>        Console.WriteLine("In Main");<br/>    }<br/>}<br/><br/>//will display<br/>In Main<br/>In Thread</span></pre><p id="6d36" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">但是如果我们想告诉线程打印什么呢？我们可以为线程设置参数，让它拥有一些数据，并用这些数据做一些事情，然后为了创建线程，我们只需要传递这些数据。</p><p id="935e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在下面的示例中，传递的参数必须是 object，而不是您自己的对象类型。此外，不要使用匹配 MyObject 的匿名类型调用，因为这样做不起作用。</p><pre class="kr ks kt ku fd kv kw kx bn ky kz bi"><span id="3d64" class="la jp hi kw b be lb lc l ld le">public class MyObject{<br/>  public int j {get;set;}<br/>  public int k {get;set;}<br/>}<br/>    <br/>public static void Main(string[] args) {           <br/>  ParameterizedThreadStart p = new ParameterizedThreadStart((object o) =&gt; { <br/>    MyObject obj = (MyObject) o;<br/>    Console.WriteLine($"Got {obj.j} and {obj.k} to get {obj.j + obj.k}");<br/>   });   <br/>        <br/>   Thread th = new Thread(p);<br/>   MyObject mo = new MyObject();<br/>   mo.j = 10; mo.k = 20;<br/>   th.Start(mo);<br/> }</span></pre><p id="f710" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">您可以通过创建方法(而不是使用匿名方法)并传递该方法来实现同样的目的。请记住，它的参数中仍然必须有 object，所以它与 ParameterizedThreadStart 所期望的相匹配。</p><pre class="kr ks kt ku fd kv kw kx bn ky kz bi"><span id="2f32" class="la jp hi kw b be lb lc l ld le">public class MyObject{<br/>  public int j {get;set;}<br/>  public int k {get;set;}<br/>}<br/>    <br/>public static void MyMethod(object o){<br/>  MyObject obj = (MyObject) o;<br/>  Console.WriteLine($"Got {obj.j} and {obj.k} to get {obj.j + obj.k}");<br/>}<br/><br/>public static void Main(string[] args) {           <br/>  ParameterizedThreadStart p = new ParameterizedThreadStart(MyMethod);   <br/>        <br/>  Thread th = new Thread(p);<br/>  MyObject mo = new MyObject();<br/>  mo.j = 10; mo.k = 20;<br/>  th.Start(mo);<br/> }</span></pre><p id="199e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们也可以这样做:</p><pre class="kr ks kt ku fd kv kw kx bn ky kz bi"><span id="9b56" class="la jp hi kw b be lb lc l ld le">public class MyObject{<br/>  public int j {get;set;}<br/>  public int k {get;set;}<br/>}<br/>    <br/>public static void Main(string[] args) { <br/>        <br/>  Thread th = new Thread( (data) =&gt; {<br/>    MyObject obj = (MyObject) data;<br/>    Console.WriteLine($"Got {obj.j} and {obj.k} to get {obj.j + obj.k}");<br/>  } );<br/>  MyObject mo = new MyObject();<br/>  mo.j = 10; mo.k = 20;<br/>  th.Start(mo);<br/>}</span></pre><p id="3e1e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们已经看到，当我们启动一个线程时，Main 会继续处理而不会等待。线程的全部意义在于我们没有在等待，但是，如果我们想等待呢？用<code class="du lf lg lh kw b">Join()</code></p><p id="88d0" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如果我们将 Join()添加到之前显示的代码中:</p><pre class="kr ks kt ku fd kv kw kx bn ky kz bi"><span id="b03d" class="la jp hi kw b be lb lc l ld le">static void Main(string[] args) {            <br/>  Thread th = new Thread(() =&gt; {<br/>  Thread.Sleep(3000);<br/>  Console.WriteLine("In Thread"); <br/>  });<br/><br/>  th.Start();<br/>  th.Join(); //JOIN and it will print In Thread, In Main.<br/>  Console.WriteLine("In Main");<br/>}</span></pre><p id="5b82" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如果我们正在处理不同的线程，一个线程也可以等待另一个线程。</p><pre class="kr ks kt ku fd kv kw kx bn ky kz bi"><span id="8159" class="la jp hi kw b be lb lc l ld le">static void Main(string[] args) {            <br/>  Thread th_1 = new Thread(() =&gt; {<br/>    Thread.Sleep(3000);<br/>    Console.WriteLine("th_1"); <br/>  });<br/>        <br/>  Thread th_2 = new Thread(() =&gt; {             <br/>    th_1.Join();//JOIN THE OTHER THREAD<br/>    Console.WriteLine("th_2"); <br/>  });<br/>        <br/>  th_1.Start();<br/>  th_2.Start();<br/>}</span></pre><p id="b4e5" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">就像我之前说的，你不能把数据从一个线程传递到另一个线程。您可以访问相同的变量，但是在这种情况下，您应该锁定这些变量。</p><pre class="kr ks kt ku fd kv kw kx bn ky kz bi"><span id="fce7" class="la jp hi kw b be lb lc l ld le">using System;<br/>using System.Threading;<br/><br/>class Program {      <br/>    public static string _something = string.Empty;<br/>    public static object _lock = new object();<br/>                    <br/>    static void Main(string[] args) { <br/><br/>        Thread th2 = new Thread( () =&gt; { <br/>            lock(_lock){<br/>                _something = DateTime.Now.ToString();  <br/>            }<br/>        });<br/>                    <br/>        Thread th1 = new Thread( () =&gt; {     <br/>            th2.Join();<br/>            Console.WriteLine(_something); });<br/>                            <br/>        th2.Start(); //start this one first<br/>        th1.Start();<br/>                        <br/>    }<br/>}</span></pre><h1 id="e25d" class="jo jp hi bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">任务和并行运行</h1><p id="4f38" class="pw-post-body-paragraph iq ir hi is b it km iv iw ix kn iz ja jb ko jd je jf kp jh ji jj kq jl jm jn hb bi translated">任务是一个表示将要执行的工作(方法)的对象。</p><p id="1529" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">任务是作为后台进程创建的，因此如果前台进程完成，它们甚至可以在完成之前结束。任务没有优先级。</p><p id="d0b7" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这里我们创建 2 个任务动作，然后用<strong class="is hj">并行启动它们。调用</strong></p><pre class="kr ks kt ku fd kv kw kx bn ky kz bi"><span id="0365" class="la jp hi kw b be lb lc l ld le">using System;<br/>using System.Threading;<br/>using System.Threading.Tasks;<br/><br/>class Program {      <br/><br/>    static void Main(string[] args) {  <br/>        Action task1 = new Action( () =&gt; {<br/>            Thread.Sleep(2000);<br/>            Console.WriteLine("task1");<br/>        });<br/>        Action task2 = new Action( () =&gt; Console.WriteLine("task2"));<br/>        Parallel.Invoke (task1, task2);<br/>    }<br/>}<br/><br/>//displays<br/>//task2<br/>//task1</span></pre><p id="b126" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">也可以这样做:</p><pre class="kr ks kt ku fd kv kw kx bn ky kz bi"><span id="8523" class="la jp hi kw b be lb lc l ld le">static void Main(string[] args) {                 <br/>  Parallel.Invoke ( <br/>    () =&gt; { Thread.Sleep(2000); Console.WriteLine("task1");}, <br/>    () =&gt; Console.WriteLine("task2")<br/>   );<br/> }</span></pre><p id="1271" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">到目前为止，我们已经通过一些动作(可能是方法)创建了任务，并使用 Parallel.Invoke 启动它们。</p><p id="69a8" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们可以有这些方法:</p><pre class="kr ks kt ku fd kv kw kx bn ky kz bi"><span id="8d10" class="la jp hi kw b be lb lc l ld le">public static void Method11()<br/>{<br/>  Console.WriteLine("method 1");<br/>}<br/>public static void Method22()<br/>{<br/>  Console.WriteLine("method 2");<br/>}<br/>public static void Method33()<br/>{<br/>  Console.WriteLine("method 3");<br/>}</span></pre><p id="e91e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们可以用这个为这些方法创建任务:</p><pre class="kr ks kt ku fd kv kw kx bn ky kz bi"><span id="7bc9" class="la jp hi kw b be lb lc l ld le">//START will be first, but the order of the other ones we don't know.<br/>Console.WriteLine("START");<br/><br/>Task T1 = new Task(Method11);<br/>T1.Start();<br/><br/>Task T2 = Task.Factory.StartNew(Method22);<br/><br/>Task T3 = Task.Run(Method33);<br/><br/>Console.WriteLine("END");</span></pre><p id="b64e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">你可以<strong class="is hj">等待任务</strong>，就像这样。在这里你不会看到结束，直到你看到“我是新任务”。</p><pre class="kr ks kt ku fd kv kw kx bn ky kz bi"><span id="a563" class="la jp hi kw b be lb lc l ld le">Console.WriteLine("START");<br/><br/>Task newTask = new Task(() =&gt; { <br/>  Thread.Sleep(2000); Console.WriteLine("I am the new task"); });<br/><br/>newTask.Start();<br/>newTask.Wait();<br/><br/>Console.WriteLine("END");</span></pre><p id="330a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">您还可以使用<code class="du lf lg lh kw b">Task.WaitAll</code>(要等待的任务的数组或列表)来等待一个任务数组。</p><p id="e160" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">任务可以返回结果。</strong></p><pre class="kr ks kt ku fd kv kw kx bn ky kz bi"><span id="8599" class="la jp hi kw b be lb lc l ld le">Task&lt;String&gt; newTask = Task.Run(() =&gt; { <br/>  Thread.Sleep(2000); return ("I am the new task"); });<br/>newTask.Wait();<br/>Console.WriteLine(newTask.Result); //I am the new task </span></pre><p id="5c60" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们也可以用<strong class="is hj"> ContinueWith 继续一个任务。</strong></p><pre class="kr ks kt ku fd kv kw kx bn ky kz bi"><span id="b9d6" class="la jp hi kw b be lb lc l ld le">Console.WriteLine("START");<br/><br/>Task&lt;String&gt; newTask = Task.Run(() =&gt; { <br/>  Thread.Sleep(2000); return ("I am the new task"); });  <br/><br/>  newTask.ContinueWith((prevTask) =&gt;<br/>   {<br/>    Console.WriteLine("I continue from newTask and I print its result");<br/>    Console.WriteLine("Result of new task: " + prevTask.Result);<br/>    return "I am the 2nd task";<br/>   }).ContinueWith( (prevTask2) =&gt;<br/>   {<br/>    Console.WriteLine("I am the 3rd task and I print the 2nd's one result");<br/>    Console.WriteLine("Result of 2nd task: " + prevTask2.Result);<br/>   }).Wait();<br/>  <br/>  Console.WriteLine("END");<br/><br/>//displays<br/>//START<br/>//I continue from newTask and I print its result<br/>//Result of new task: I am the new task<br/>//I am the 3rd task and I print the 2nd's one result<br/>//Result of 2nd task: I am the 2nd task<br/>//END</span></pre><p id="a717" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">一个父任务可以创建<strong class="is hj">子任务</strong>。子级可以是附加的(真实子级)，也可以是不附加的(称为嵌套的)。如果它们是附加的，则在子级完成之前，任务不会完成。</p><pre class="kr ks kt ku fd kv kw kx bn ky kz bi"><span id="dd4e" class="la jp hi kw b be lb lc l ld le">Task parent = Task.Factory.StartNew(() =&gt;<br/>{<br/>   Console.WriteLine("parent task started");<br/><br/>   Console.WriteLine("starting indepdent nested task");<br/>   Task.Factory.StartNew(() =&gt; { Thread.Sleep(4000); Console.WriteLine("Indep nested task after 4 secs"); });<br/><br/>   Console.WriteLine("starting child task - attached");<br/>   Task.Factory.StartNew(() =&gt; { Thread.Sleep(2000); Console.WriteLine("attached child after 2 secs"); }, TaskCreationOptions.AttachedToParent);<br/><br/>   Console.WriteLine("parent child ending");<br/><br/>});<br/><br/>parent.Wait(); //Wait for attached<br/>Console.WriteLine("Parent Done Waiting ");</span></pre><h1 id="5f6d" class="jo jp hi bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">异步/等待</h1><p id="c206" class="pw-post-body-paragraph iq ir hi is b it km iv iw ix kn iz ja jb ko jd je jf kp jh ji jj kq jl jm jn hb bi translated">你可以等待一个任务完成，但是你要等待一个返回一些东西的任务。你不能这么做。</p><pre class="kr ks kt ku fd kv kw kx bn ky kz bi"><span id="49e3" class="la jp hi kw b be lb lc l ld le">Task t = new Task(() =&gt; { Console.Write("hey");  });<br/><br/>await t.Start();// WIll not compile</span></pre><p id="37b9" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">但这是可行的(await 应该在标记为 async 的方法中使用)。</p><pre class="kr ks kt ku fd kv kw kx bn ky kz bi"><span id="4d03" class="la jp hi kw b be lb lc l ld le">Console.WriteLine("START");<br/><br/>Task t = new Task(() =&gt; { Console.Write("hey");  });<br/><br/>await  Task.Run(() =&gt; { Thread.Sleep(2000); Console.WriteLine("Running Task"); return "hello"; });    <br/><br/>Console.WriteLine("END");<br/><br/>//displays<br/>//START<br/>//Running Task<br/>//END</span></pre><h1 id="1b07" class="jo jp hi bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">一些并行操作</h1><p id="0186" class="pw-post-body-paragraph iq ir hi is b it km iv iw ix kn iz ja jb ko jd je jf kp jh ji jj kq jl jm jn hb bi translated">就像我们有一个<strong class="is hj"> foreach </strong>一样，我们也有一个并行 foreach。它将并行运行我们想对每一项做的任何事情，但是不能保证事情发生的顺序。</p><pre class="kr ks kt ku fd kv kw kx bn ky kz bi"><span id="1c87" class="la jp hi kw b be lb lc l ld le">List&lt;string&gt; l = new List&lt;string&gt;();<br/><br/>l.Add("1");<br/>l.Add("2");<br/>l.Add("3");<br/>l.Add("4");<br/>l.Add("5");<br/><br/>Parallel.ForEach(l, (item) =&gt; Console.WriteLine(item));<br/><br/>//could print<br/>//1<br/>//4<br/>//5<br/>//3<br/>//2<br/>//or some other order</span></pre><p id="34f6" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">对于循环，我们也有同样的选择<strong class="is hj">(同样不保证订单)。</strong></p><pre class="kr ks kt ku fd kv kw kx bn ky kz bi"><span id="aa7b" class="la jp hi kw b be lb lc l ld le">//Notice that the 0 is inclusive, but the 2nd argument is EXCLUSIVE, <br/>//so don't subtract 1.<br/>Parallel.For(0, l.Count, (i) =&gt; Console.WriteLine(i + "-" + l[i]));</span></pre><p id="375d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们还可以在 for 中添加一个<strong class="is hj">停止条件</strong>。对于与上述相同的列表:</p><pre class="kr ks kt ku fd kv kw kx bn ky kz bi"><span id="c4b0" class="la jp hi kw b be lb lc l ld le">ParallelLoopResult res = Parallel.For(0, l.Count,<br/>            (int i, ParallelLoopState st) =&gt; {<br/>             Console.WriteLine(i + "-" + l[i]);<br/>             if (i == 2) { st.Stop(); }<br/>            });<br/><br/>  Console.WriteLine(res.ToString());<br/><br/>//displays<br/>//0-1<br/>//2-3<br/>//1-2<br/>//System.Threading.Tasks.ParallelLoopResult</span></pre><p id="3120" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">ParallelLoopState 也可以与 foreach 一起添加。</p><p id="8ee7" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们也可以使用<strong class="is hj"> linq </strong>进行并行编程。</p><pre class="kr ks kt ku fd kv kw kx bn ky kz bi"><span id="a2fc" class="la jp hi kw b be lb lc l ld le">var res = from item in l.AsParallel()<br/>    where (item == "2" || item == "4")<br/>    select item;</span></pre><p id="94ee" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">处理顺序没有保证，但是，您可以做<code class="du lf lg lh kw b"><strong class="is hj">.AsParallel().AsOrdered()</strong></code>来保存顺序。</p><p id="c249" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">也可以做<code class="du lf lg lh kw b"><strong class="is hj">.AsParallel().AsSequential()</strong></code> <strong class="is hj"> </strong>来顺序处理。</p><p id="858f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们也可以在结果完成之前开始迭代，如果我们这样做:<code class="du lf lg lh kw b">res.ForAll(p =&gt; { Console.WriteLine(p.Age); });</code></p><p id="3174" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如果任何查询抛出异常，它们将在最后作为 AggregateException 抛出。</p><p id="98db" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">暂时就这样了。</p></div></div>    
</body>
</html>