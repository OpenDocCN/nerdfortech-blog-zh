<html>
<head>
<title>Solving: rootOfNumber</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">求解:rootOfNumber</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/solving-rootofnumber-fe1f74134350?source=collection_archive---------19-----------------------#2021-04-05">https://medium.com/nerd-for-tech/solving-rootofnumber-fe1f74134350?source=collection_archive---------19-----------------------#2021-04-05</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div class="er es if"><img src="../Images/b14ef5c56f65ea41341ce0460d03092f.png" data-original-src="https://miro.medium.com/v2/resize:fit:920/1*H_5QXN0IOpSpcrOpmLh3Uw.gif"/></div></figure><p id="9870" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">在本文中，我将剖析Javascript中的rootOfNumber问题。我将介绍我解决这个问题的过程，并讨论它的重要性。</p><p id="15e3" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">我们开始吧！</p><h1 id="1f6e" class="jk jl hi bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">问题:</h1><h2 id="5b33" class="ki jl hi bd jm kj kk kl jq km kn ko ju ix kp kq jy jb kr ks kc jf kt ku kg kv bi translated">实现一个函数<code class="du kw kx ky kz b">root</code>，它计算一个数的<code class="du kw kx ky kz b">n’th</code>根。该函数取一个非负数<code class="du kw kx ky kz b">x</code>和一个正整数<code class="du kw kx ky kz b">n</code>，在误差<code class="du kw kx ky kz b">0.001</code>内返回<code class="du kw kx ky kz b">x</code>的正<code class="du kw kx ky kz b">n’th</code>根(即假设实根为<code class="du kw kx ky kz b">y</code>，则误差为:<code class="du kw kx ky kz b">|y-root(x,n)|</code>，且必须满足<code class="du kw kx ky kz b">|y-root(x,n)| &lt; 0.001</code>)。</h2><h2 id="9ed5" class="ki jl hi bd jm kj kk kl jq km kn ko ju ix kp kq jy jb kr ks kc jf kt ku kg kv bi translated">示例:</h2><ul class=""><li id="c5f8" class="la lb hi io b ip lc it ld ix le jb lf jf lg jj lh li lj lk bi translated">输入:x = 7，n = 3 →输出:1.913</li><li id="4c54" class="la lb hi io b ip ll it lm ix ln jb lo jf lp jj lh li lj lk bi translated">输入:x = 9，n = 2 →输出:3</li></ul><h2 id="af43" class="ki jl hi bd jm kj kk kl jq km kn ko ju ix kp kq jy jb kr ks kc jf kt ku kg kv bi translated"><strong class="ak">约束:</strong></h2><ul class=""><li id="7a48" class="la lb hi io b ip lc it ld ix le jb lf jf lg jj lh li lj lk bi translated"><strong class="io hj">【时限】5000ms </strong></li><li id="6b81" class="la lb hi io b ip ll it lm ix ln jb lo jf lp jj lh li lj lk bi translated"><strong class="io hj">【输入】浮动</strong> <code class="du kw kx ky kz b">x</code> → 0 ≤ x</li><li id="b643" class="la lb hi io b ip ll it lm ix ln jb lo jf lp jj lh li lj lk bi translated"><strong class="io hj">【输入】整数</strong> <code class="du kw kx ky kz b">n</code> → 0 &lt; n</li><li id="2bc0" class="la lb hi io b ip ll it lm ix ln jb lo jf lp jj lh li lj lk bi translated"><strong class="io hj">【输出】浮动</strong></li></ul><p id="8dda" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">让我们用自己的话来分析和重述这个问题。</p><p id="081b" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">我们被要求写一个函数来确定一个数的n次方根。这意味着什么呢？这意味着给定一个浮点数“x”和一个整数“n ”,我们可以确定数字“z ”,其中z的^ n次方将得到x</p><ul class=""><li id="71dd" class="la lb hi io b ip iq it iu ix lq jb lr jf ls jj lh li lj lk bi translated">z^nth = x</li></ul><p id="77e0" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">因此，给定x= 7，n = 3，我们想找到z，其中:</p><p id="afa5" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><strong class="io hj"> z = 7 </strong></p><p id="c612" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">我们怎样才能找到z呢？</p><p id="3aed" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">我们知道些什么？</p><p id="740c" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">我们知道z必须在0和x的范围内:</p><p id="2870" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">0 ≤ z ≤ x → 0 ≤ z ≤ 7</p><p id="555f" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">现在知道了这一点，我们就可以遍历0-x的范围，检查这些值的n次方是否等于x。</p><p id="8384" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">这是一些很好的逻辑，但也有一些问题:</p><p id="354a" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">我们需要检查所有的数字，而不仅仅是整数。这意味着包括每个整数之间的浮点值→ 1.1、1.2、1.3、1.4、1.5等。</p><p id="a7d0" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">如果我们做一个循环，并且每次将z值增加一个整数的十分之一，那将花费…非常长的时间…</p><p id="4f13" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">增加十分之一甚至可能不会给出正确的结果…那么我们如何在检查范围的同时增加我们检查的值的特异性并限制检查所有这些值所需的时间呢？</p><p id="be94" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">介绍:二分搜索法。</p><p id="f457" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><strong class="io hj">二分搜索法:</strong>通过重复将搜索区间一分为二来搜索排序后的数组。以覆盖整个阵列的间隔开始。如果搜索关键字的值小于间隔中间的项目，则将间隔缩小到下半部分。否则缩小到上半部分。重复检查，直到找到值或间隔为空。</p><p id="0b2a" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">现在，这可能对你有一些意义，但让我们打破这一点。</p><p id="d513" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">二分搜索法背后的理念包含了一些关键的思想:</p><ul class=""><li id="bcec" class="la lb hi io b ip iq it iu ix lq jb lr jf ls jj lh li lj lk bi translated">您正在搜索的数字有一个<strong class="io hj">排序的</strong>范围→在我们的例子中，它是0 ≤ z ≤ x之间的范围</li><li id="2ea0" class="la lb hi io b ip ll it lm ix ln jb lo jf lp jj lh li lj lk bi translated">在每一遍中，有一个<strong class="io hj">上界</strong>、<strong class="io hj">下界</strong>和一个<strong class="io hj">中值</strong> →每一遍我们<em class="lt">改变这些界限以缩小我们正在搜索的范围的大小</em> <em class="lt">到</em>,<em class="lt">随后改变中值</em> →在我们的例子中，第一遍将有→上界= x，下界= 0，中值=(上界+下界)/ 2 →中值= (x + 0) / 2</li><li id="bac6" class="la lb hi io b ip ll it lm ix ln jb lo jf lp jj lh li lj lk bi translated">在每一次传递中，我们将中间值与我们正在搜索的值进行比较，直到我们找到该值，在这种情况下，我们将返回它</li></ul><p id="7ace" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">既然我们已经谈到了二分搜索法，让我们回顾一下我们的游戏计划。</p><ul class=""><li id="1e6c" class="la lb hi io b ip iq it iu ix lq jb lr jf ls jj lh li lj lk bi translated">使用二分搜索法查找初始范围0 ≤ z ≤ x内的值</li><li id="b07c" class="la lb hi io b ip ll it lm ix ln jb lo jf lp jj lh li lj lk bi translated">从二分搜索法取每个值(z ),检查是否→ z^nth = x</li><li id="e044" class="la lb hi io b ip ll it lm ix ln jb lo jf lp jj lh li lj lk bi translated">如果z值小于x，我们切换我们的边界来查看上半部分，如果z值大于x，我们切换我们的边界来查看下半部分，并继续下去，直到我们发现z值在x的0.001以内</li></ul><p id="0445" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">太棒了。让我们进入一些代码。</p><figure class="lv lw lx ly fd ij er es paragraph-image"><div role="button" tabindex="0" class="lz ma di mb bf mc"><div class="er es lu"><img src="../Images/83cf980ffeb430d2aac86165128fb849.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zfZtCWDCNMVu3IMuMbyNfw.png"/></div></div></figure><p id="5276" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">在上面的代码中，我们设置了初始边界，然后遍历整个范围并更改范围的边界，直到我们达到正确的值，或者我们的近似根和下限之间的差等于或小于0.001(当满足这个条件时，我们已经达到了相对于x的0.001误差范围内的值。</p><p id="1245" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">因为我们使用的是二分搜索法，所以每次输入的大小都会减半，导致O(log(n))的时间复杂度和O(1)的空间复杂度。</p><h2 id="8f92" class="ki jl hi bd jm kj kk kl jq km kn ko ju ix kp kq jy jb kr ks kc jf kt ku kg kv bi translated">最终想法:</h2><p id="73b4" class="pw-post-body-paragraph im in hi io b ip lc ir is it ld iv iw ix md iz ja jb me jd je jf mf jh ji jj hb bi translated">这个问题让我措手不及的是，为了找到答案，需要做实际的数学运算。我的数学并不差，但是从高中开始我就不用去找一个数的n次方根了(即使那样我也不认为我擅长这个)。</p><p id="0644" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">找到解决方案的关键是想出一个极其简单的想法，这在逻辑上是合理的，并把它分解成熟悉的部分，直到意识到我需要做的只是在一个范围内寻找一个值。通过让问题对我来说更熟悉，我能够不被数学困住，而专注于解决方案。</p><p id="3043" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">利用这些信息并使用二分搜索法算法来加速这个过程，让我找到了一个时间复杂度为O(log(n))的解决方案。</p><p id="5c48" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">我希望这对你的下一个算法有所帮助，并提醒你不要被这个问题迷惑，保持你的解决方案简单而熟悉！</p></div></div>    
</body>
</html>