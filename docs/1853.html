<html>
<head>
<title>DFS &amp; BFS — Introduction</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">DFS 和 BFS —简介</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/dfs-bfs-introduction-26a65fca2344?source=collection_archive---------10-----------------------#2021-04-10">https://medium.com/nerd-for-tech/dfs-bfs-introduction-26a65fca2344?source=collection_archive---------10-----------------------#2021-04-10</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><figure class="hh hi ez fb hj hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es hg"><img src="../Images/f4f7a331374541f4eb1513b1719f2d7f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IKkuvrR_ib0DkdDkQVELkA.jpeg"/></div></div><figcaption class="hr hs et er es ht hu bd b be z dx translated"><a class="ae hv" href="https://unsplash.com/@jan_huber?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">简·侯伯</a>在<a class="ae hv" href="https://unsplash.com/s/photos/breadth-vs-depth?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍照</figcaption></figure><div class=""/><p id="ee76" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">深度优先搜索和广度优先搜索是两种非常常见的树/图遍历/搜索算法。在这篇博客中，我们将介绍这两种算法的实现。为简单起见，我们将为二分搜索法树实现它们。使用邻接矩阵可以将逻辑扩展到其他图。</p><p id="1124" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><a class="ae hv" href="https://asrathore08.medium.com/number-of-island-bfs-dfs-e4888886dbb0" rel="noopener">号<strong class="ix hz">岛:索尔与 BFS&amp;DFS</strong>T7】</a></p><p id="32bb" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">下图是我们将要遍历的树。</p><figure class="ju jv jw jx fd hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es jt"><img src="../Images/c58f6fefb9cd2c733965e33f82e0fb87.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*spN2CQISQWV5k0_J_RQvpg.png"/></div></div></figure><h1 id="9dd1" class="jy jz hy bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">BFS</h1><p id="d594" class="pw-post-body-paragraph iv iw hy ix b iy kw ja jb jc kx je jf jg ky ji jj jk kz jm jn jo la jq jr js hb bi translated">在 BFS，我们首先遍历所有连接的节点。在下图中，值为 11 的节点连接到 6 和 16。所以顺序就变成了 11-&gt;6-&gt;16。</p><figure class="ju jv jw jx fd hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es lb"><img src="../Images/f5bd7e11554b137332428b5d19f52215.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8bULlpmWrJNDrRFxelTf4g.png"/></div></div></figure><blockquote class="lc ld le"><p id="49e7" class="iv iw lf ix b iy iz ja jb jc jd je jf lg jh ji jj lh jl jm jn li jp jq jr js hb bi translated">BFS 是一种谨慎的方法，它一层一层地检查每条路径，除非它找到了当前级别的内容，否则它将深入图表。</p></blockquote><p id="7013" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">为了实现这个逻辑，我们利用了队列<strong class="ix hz">的帮助。这有助于我们跟踪已经看到的节点。我们从树根开始。对于队列中的每个节点，我们从左侧移除节点，并继续从右侧添加其连接的节点。在上面的例子中，我们从 11 开始。我们将其连接的节点添加到队列中，即我们添加 6 &amp; 11。这一直持续到我们用完了队列中的所有元素。</strong></p><pre class="ju jv jw jx fd lj lk ll lm aw ln bi"><span id="99ee" class="lo jz hy lk b fi lp lq l lr ls">def bfs(root):<br/>    bfs_q = deque([root])<br/>    path = []</span><span id="6a63" class="lo jz hy lk b fi lt lq l lr ls">    while bfs_q:<br/>        for i in range(len(bfs_q)):<br/>            out = bfs_q.popleft()<br/>            path.append(out.val)<br/>            if out.left:<br/>                bfs_q.append(out.left)<br/>            if out.right:<br/>                bfs_q.append(out.right)<br/>    return path</span></pre><p id="3c53" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">while 循环的不同迭代的队列值如下。</p><pre class="ju jv jw jx fd lj lk ll lm aw ln bi"><span id="8ad6" class="lo jz hy lk b fi lp lq l lr ls">11           #start<br/>6, 16        #removed 11 and added its connected.<br/>3, 9, 14, 19 #removed 6 and 16 added their connected nodes<br/>2, 5, 8, 10, 13, 15, 18, 20</span></pre><p id="ec92" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">结果:</p><pre class="ju jv jw jx fd lj lk ll lm aw ln bi"><span id="1f11" class="lo jz hy lk b fi lp lq l lr ls">11 -&gt; 6 -&gt; 16 -&gt; 3 -&gt; 9 -&gt; 14 -&gt; 19 -&gt; 2 -&gt; 5 -&gt; 8 -&gt; 10 -&gt; 13 -&gt; 15 -&gt; 18 -&gt; 20 -&gt; 1 -&gt; 4 -&gt; 7 -&gt; 12 -&gt; 17</span></pre><h1 id="c0c0" class="jy jz hy bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">深度优先搜索</h1><p id="e8fc" class="pw-post-body-paragraph iv iw hy ix b iy kw ja jb jc kx je jf jg ky ji jj jk kz jm jn jo la jq jr js hb bi translated">在 DFS 中，我们通过连接的节点继续向下遍历，除非我们到达终点，然后折回我们的步骤，看到没有访问的连接节点，并重复这个过程。在下面的例子中，我们从 11 开始，然后下降到 6，下降到 3，下降到 2，再进一步下降到 1。在 1 我们没有任何向下的节点。我们回溯到 3 点。这里，它下面有一个未访问的节点。所以我们在这里再次开始 DFS。到达 4 之后，我们折回 6，然后从 9 开始，继续下去。</p><figure class="ju jv jw jx fd hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es lu"><img src="../Images/c04301355a46c96a582dfc305803aae5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KhhGaoo2HwKUwtcW2ykTAg.png"/></div></div></figure><blockquote class="lc ld le"><p id="5f15" class="iv iw lf ix b iy iz ja jb jc jd je jf lg jh ji jj lh jl jm jn li jp jq jr js hb bi translated">DFS 是一种积极的算法，深入到图形中，当它到达底部时进行回溯，直到它再次到达底部</p></blockquote><p id="bf4b" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">为了实现 DFS，我们使用<strong class="ix hz">栈</strong>数据结构来跟踪被访问的节点。我们从根开始，作为栈中唯一的元素。我们从堆栈中弹出，并将弹出节点的连接节点添加到堆栈中。我们重复这个过程，直到堆栈变空。</p><pre class="ju jv jw jx fd lj lk ll lm aw ln bi"><span id="bb67" class="lo jz hy lk b fi lp lq l lr ls">def dfs(root):<br/>    stack = [root]<br/>    path = []<br/>    while stack:<br/>        out = stack.pop()<br/>        path.append(out.val)<br/>        if out.right:<br/>            stack.append(out.right)<br/>        if out.left:<br/>            stack.append(out.left)<br/>    return path</span></pre><p id="dd17" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">while 内部的 diff 迭代中堆栈的值如下:</p><pre class="ju jv jw jx fd lj lk ll lm aw ln bi"><span id="bb36" class="lo jz hy lk b fi lp lq l lr ls">|  | |  | |  | |  | |  |<br/>|  | |  | |  | | 2| | 1|<br/>|  | |  | | 3| | 5| | 5|<br/>|  | | 6| | 9| | 9| | 9|<br/>|11| |16| |16| |16| |16|</span></pre><p id="8fa4" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">结果:</p><pre class="ju jv jw jx fd lj lk ll lm aw ln bi"><span id="f263" class="lo jz hy lk b fi lp lq l lr ls">11 -&gt; 6 -&gt; 3 -&gt; 2 -&gt; 1 -&gt; 5 -&gt; 4 -&gt; 9 -&gt; 8 -&gt; 7 -&gt; 10 -&gt; 16 -&gt; 14 -&gt; 13 -&gt; 12 -&gt; 15 -&gt; 19 -&gt; 18 -&gt; 17 -&gt; 20</span></pre><p id="9df0" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">什么时候用哪个？</p><p id="0809" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如果 b 是分枝因子，d 是解所在的深度，h 是树的高度(d≤h ),那么 DFS 需要 O(b^h)时间和 O(h)空间。BFS 占用 O(b^d 的时间和 O(b^d 的空间。</p><p id="b294" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">使用的一般指南:</p><ul class=""><li id="c719" class="lv lw hy ix b iy iz jc jd jg lx jk ly jo lz js ma mb mc md bi translated">寻找最短路径— BFS</li><li id="b575" class="lv lw hy ix b iy me jc mf jg mg jk mh jo mi js ma mb mc md bi translated">测试图二分性— BFS</li><li id="72ca" class="lv lw hy ix b iy me jc mf jg mg jk mh jo mi js ma mb mc md bi translated">查找所有连接的组件-BFS</li><li id="fd31" class="lv lw hy ix b iy me jc mf jg mg jk mh jo mi js ma mb mc md bi translated">寻找连接点— DFS</li><li id="cc09" class="lv lw hy ix b iy me jc mf jg mg jk mh jo mi js ma mb mc md bi translated">决策树— DFS</li><li id="63a0" class="lv lw hy ix b iy me jc mf jg mg jk mh jo mi js ma mb mc md bi translated">搜索空间全图— DFS</li><li id="2c7a" class="lv lw hy ix b iy me jc mf jg mg jk mh jo mi js ma mb mc md bi translated">有限的孩子和无限的深度——BFS</li><li id="0f42" class="lv lw hy ix b iy me jc mf jg mg jk mh jo mi js ma mb mc md bi translated">有限深度和无限子代— DFS</li><li id="33a3" class="lv lw hy ix b iy me jc mf jg mg jk mh jo mi js ma mb mc md bi translated">密集图— DFS</li><li id="68b9" class="lv lw hy ix b iy me jc mf jg mg jk mh jo mi js ma mb mc md bi translated">稀疏图— BFS</li></ul><p id="5ebd" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hz">进一步阅读图搜索算法— </strong> <a class="ae hv" href="https://asrathore08.medium.com/shortest-path-algorithms-dijkstra-bellman-ford-3b640bdb0449" rel="noopener"> <strong class="ix hz">迪杰斯特拉&amp;贝尔曼-福特</strong> </a></p><p id="b803" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">寻找快乐！！</p></div></div>    
</body>
</html>