<html>
<head>
<title>Factory Design Pattern</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">工厂设计模式</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/factory-design-pattern-a570cc3ad804?source=collection_archive---------13-----------------------#2021-05-25">https://medium.com/nerd-for-tech/factory-design-pattern-a570cc3ad804?source=collection_archive---------13-----------------------#2021-05-25</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/25113aef1f96727dd95a59fb0e58362d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MzzXW3JNswiQ42uaJwDm5w.jpeg"/></div></div></figure><p id="b291" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在我的上一篇文章中，我已经讨论了单体设计模式。因此，如果你是设计模式的新手，你可以去学习设计模式和单体设计模式的介绍，这是我以前的文章。所以在这篇博客中，我将解释工厂设计模式。这种设计模式属于创建模式，因为这种模式提供了创建对象的最佳方式之一。让我们先看一个简单的例子，因为它容易理解。</p><figure class="jp jq jr js fd ij er es paragraph-image"><div class="er es jo"><img src="../Images/69e2f36df224795f04e0db185bb8465d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1120/format:webp/1*MgGanvd3o--sK1q9W05odw.jpeg"/></div></figure><p id="3594" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如上图所示，我们需要创建形状接口和具体的类(这里的子类是圆形、正方形、矩形)。然后我们需要创建Shapefactory类。在我们的Shape Factory类中，有一个方法调用get shape，它返回用户请求的形状的一个实例。用户请求是通过主类完成的。我们的演示类有一个main方法，它将使用ShapeFactory来获得一个Shape对象。它会将信息(圆形/矩形/正方形)传递给ShapeFactory，以获取它需要的对象类型。正如您所看到的，这是工厂设计模式的基本概念。所以我们来实现这个。我已经实现了如下的形状接口。它包含一个绘制方法。</p><figure class="jp jq jr js fd ij"><div class="bz dy l di"><div class="jt ju l"/></div></figure><p id="d56b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">然后矩形、圆形和方形类应该从Shape接口实现，并覆盖draw方法，如下所示。我只把矩形类放在下面，但是你也需要像这样实现其他类(圆形类和三角形类)。</p><figure class="jp jq jr js fd ij"><div class="bz dy l di"><div class="jt ju l"/></div></figure><p id="b356" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">然后在Shapefactory类中，我们需要实现getshape方法，该方法返回shape类型实例。您需要实现一个逻辑来检查用户是否在询问哪个形状。在这里，我使用if else来确定，并根据用户的选择，它会给用户选择的形状对象。</p><figure class="jp jq jr js fd ij"><div class="bz dy l di"><div class="jt ju l"/></div></figure><p id="f371" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在我们的主类中，我从Shapefactory创建了一个实例，并使用shapefactory实例调用get shape方法来传递我想要的形状，如下面的代码段所示。</p><figure class="jp jq jr js fd ij"><div class="bz dy l di"><div class="jt ju l"/></div></figure><p id="8b47" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">完整实现的输出如下。</p><figure class="jp jq jr js fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es jv"><img src="../Images/9b513f4bdd8f01f56380186e7d4353d3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gMyzkA61jPFj_cnnyucLww.png"/></div></div></figure></div><div class="ab cl jw jx gp jy" role="separator"><span class="jz bw bk ka kb kc"/><span class="jz bw bk ka kb kc"/><span class="jz bw bk ka kb"/></div><div class="hb hc hd he hf"><p id="216e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这是工厂设计模式的基本实现。现在让我们看一个高级的真实世界的例子。假设有健身房。基本上健身房有一些设施，如举重机，有氧健身器和交叉健身。不是每个成员都能使用那些机器。用户可以根据他们的成员类型来使用它们。有三种会员类型。那些是银的、金的和白金的。</p><ol class=""><li id="2ca5" class="kd ke hi is b it iu ix iy jb kf jf kg jj kh jn ki kj kk kl bi translated">银卡会员只允许使用举重机。</li><li id="5e38" class="kd ke hi is b it km ix kn jb ko jf kp jj kq jn ki kj kk kl bi translated">黄金会员只允许使用有氧健身器和举重机。</li><li id="c184" class="kd ke hi is b it km ix kn jb ko jf kp jj kq jn ki kj kk kl bi translated">白金会员可以使用有氧健身器、举重机和交叉健身区。</li></ol><p id="38f1" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">所以在下面你可以看到UML图。</p><figure class="jp jq jr js fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es kr"><img src="../Images/d89bc4b33feffd4d94cbe487f62861d4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jCl9P8DJ7Y3S8lqwZ1RIIg.jpeg"/></div></div></figure><p id="a6bf" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在让我们一个一个地实现这个场景。所以让我们将GymFacilities类实现为一个抽象类。</p><figure class="jp jq jr js fd ij"><div class="bz dy l di"><div class="jt ju l"/></div></figure><p id="efa3" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">然后我们需要使用健身房提供的设施。所以我创建了一个名为cardio的类，并从GymFacilities类扩展而来。实际上，这些facilities子类只是空类，只有to string()方法。如下图所示，我对所有其他的健身课程也是这样做的(交叉训练课和举重课)。</p><figure class="jp jq jr js fd ij"><div class="bz dy l di"><div class="jt ju l"/></div></figure><figure class="jp jq jr js fd ij"><div class="bz dy l di"><div class="jt ju l"/></div></figure><figure class="jp jq jr js fd ij"><div class="bz dy l di"><div class="jt ju l"/></div></figure><p id="a153" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在我创建一个成员类，并将其设置为抽象类。在会员类中，我有一个包含健身设施的受保护列表。接下来，您可以看到该类的构造函数，它调用CreateMembership()方法。然后我们有了to string方法。</p><figure class="jp jq jr js fd ij"><div class="bz dy l di"><div class="jt ju l"/></div></figure><p id="31ba" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">然后，我们可以创建银牌、金牌和白金会员级别，并从会员级别扩展这些级别。正如我前面提到的，银牌会员只能使用举重机。黄金会员只允许使用有氧健身器和举重机。白金会员可以使用有氧健身器、举重机和交叉健身区。所以你需要把那些设施相应地加入到会员设施列表中。</p><figure class="jp jq jr js fd ij"><div class="bz dy l di"><div class="jt ju l"/></div></figure><figure class="jp jq jr js fd ij"><div class="bz dy l di"><div class="jt ju l"/></div></figure><figure class="jp jq jr js fd ij"><div class="bz dy l di"><div class="jt ju l"/></div></figure><p id="918b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在我们的MembershipFactory类中，我们有一个createmembership方法，它返回成员类型实例。在该方法中，您需要实现一个逻辑来检查用户是否在询问哪个成员资格。在这里，我使用if else来确定，并根据用户的选择，它会给用户选择的成员对象。</p><figure class="jp jq jr js fd ij"><div class="bz dy l di"><div class="jt ju l"/></div></figure><p id="53ee" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在我们的main方法中，您可以从成员资格创建一个实例，并且可以使用MembershipFactory类创建成员资格。</p><figure class="jp jq jr js fd ij"><div class="bz dy l di"><div class="jt ju l"/></div></figure><figure class="jp jq jr js fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ks"><img src="../Images/34cbcff86d49515c90aab96aa5ebd501.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iJ_aK-A5W05sdSD5hm5_Ew.png"/></div></div><figcaption class="kt ku et er es kv kw bd b be z dx translated">程序的输出。</figcaption></figure><p id="3b40" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在让我们了解一下工厂设计模式的优缺点。</p><h2 id="e70e" class="kx ky hi bd kz la lb lc ld le lf lg lh jb li lj lk jf ll lm ln jj lo lp lq lr bi translated">工厂设计模式的优势</h2><ol class=""><li id="74fd" class="kd ke hi is b it ls ix lt jb lu jf lv jj lw jn ki kj kk kl bi translated">工厂方法模式允许子类选择要创建的对象类型。</li><li id="9701" class="kd ke hi is b it km ix kn jb ko jf kp jj kq jn ki kj kk kl bi translated">它消除了将特定于应用程序的类绑定到代码中的需要，从而促进了松散耦合。</li><li id="85a5" class="kd ke hi is b it km ix kn jb ko jf kp jj kq jn ki kj kk kl bi translated">允许您隐藏实现细节。</li></ol><h2 id="ff82" class="kx ky hi bd kz la lb lc ld le lf lg lh jb li lj lk jf ll lm ln jj lo lp lq lr bi translated"><strong class="ak">工厂设计模式的缺点</strong></h2><ol class=""><li id="5abd" class="kd ke hi is b it ls ix lt jb lu jf lv jj lw jn ki kj kk kl bi translated">可能很复杂，因为它会增加系统中的类的总数。</li></ol><h2 id="088d" class="kx ky hi bd kz la lb lc ld le lf lg lh jb li lj lk jf ll lm ln jj lo lp lq lr bi translated">工厂设计模式的使用</h2><ul class=""><li id="b6ec" class="kd ke hi is b it ls ix lt jb lu jf lv jj lw jn lx kj kk kl bi translated">当一个类不知道需要创建什么子类时</li><li id="63d7" class="kd ke hi is b it km ix kn jb ko jf kp jj kq jn lx kj kk kl bi translated">当一个类希望它的子类指定要创建的对象时。</li><li id="d152" class="kd ke hi is b it km ix kn jb ko jf kp jj kq jn lx kj kk kl bi translated">当父类选择创建对象到它的子类时。</li></ul><p id="dcd4" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">您已到达这篇文章的结尾。所以我希望你了解工厂设计模式。我将把git hub repository链接放在参考资料中，然后您可以遵循完整的编码示例。那就另文再见了。</p></div><div class="ab cl jw jx gp jy" role="separator"><span class="jz bw bk ka kb kc"/><span class="jz bw bk ka kb kc"/><span class="jz bw bk ka kb"/></div><div class="hb hc hd he hf"><h1 id="ef34" class="ly ky hi bd kz lz ma mb ld mc md me lh mf mg mh lk mi mj mk ln ml mm mn lq mo bi translated">参考</h1><div class="mp mq ez fb mr ms"><a href="https://github.com/Dilshanushara/Krish_LP_Training/tree/master/Design%20Patterns/Factory" rel="noopener  ugc nofollow" target="_blank"><div class="mt ab dw"><div class="mu ab mv cl cj mw"><h2 class="bd hj fi z dy mx ea eb my ed ef hh bi translated">dilshanushara/Krish _ LP _ Training</h2><div class="mz l"><h3 class="bd b fi z dy mx ea eb my ed ef dx translated">在GitHub上创建一个帐户，为Dilshanushara/Krish _ LP _ Training的发展做出贡献。</h3></div><div class="na l"><p class="bd b fp z dy mx ea eb my ed ef dx translated">github.com</p></div></div><div class="nb l"><div class="nc l nd ne nf nb ng io ms"/></div></div></a></div><figure class="jp jq jr js fd ij"><div class="bz dy l di"><div class="nh ju l"/></div></figure><div class="mp mq ez fb mr ms"><a href="https://www.tutorialspoint.com/design_pattern/factory_pattern.htm" rel="noopener  ugc nofollow" target="_blank"><div class="mt ab dw"><div class="mu ab mv cl cj mw"><h2 class="bd hj fi z dy mx ea eb my ed ef hh bi translated">设计模式-工厂模式</h2><div class="mz l"><h3 class="bd b fi z dy mx ea eb my ed ef dx translated">工厂模式是Java中最常用的设计模式之一。这种类型的设计模式属于创造性的…</h3></div><div class="na l"><p class="bd b fp z dy mx ea eb my ed ef dx translated">www.tutorialspoint.com</p></div></div><div class="nb l"><div class="ni l nd ne nf nb ng io ms"/></div></div></a></div><div class="mp mq ez fb mr ms"><a href="https://www.javatpoint.com/factory-method-design-pattern" rel="noopener  ugc nofollow" target="_blank"><div class="mt ab dw"><div class="mu ab mv cl cj mw"><h2 class="bd hj fi z dy mx ea eb my ed ef hh bi translated">工厂方法设计模式-Java point</h2><div class="mz l"><h3 class="bd b fi z dy mx ea eb my ed ef dx translated">工厂模式或工厂方法模式表示只需定义一个接口或抽象类来创建一个对象…</h3></div><div class="na l"><p class="bd b fp z dy mx ea eb my ed ef dx translated">www.javatpoint.com</p></div></div><div class="nb l"><div class="nj l nd ne nf nb ng io ms"/></div></div></a></div></div></div>    
</body>
</html>