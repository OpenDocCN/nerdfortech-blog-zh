<html>
<head>
<title>Let's talk about Queue</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">让我们来谈谈排队</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/lets-talk-about-queue-efac6a416bf1?source=collection_archive---------2-----------------------#2020-08-22">https://medium.com/nerd-for-tech/lets-talk-about-queue-efac6a416bf1?source=collection_archive---------2-----------------------#2020-08-22</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div class="er es if"><img src="../Images/d251c4719e718b45c52023c0d8158286.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/format:webp/1*GJ26mM67Z5Ha6XQmKXIjXA.jpeg"/></div><figcaption class="im in et er es io ip bd b be z dx translated">来源谷歌图片</figcaption></figure><h2 id="24da" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">队列数据结构介绍:</h2><p id="bb7b" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jb jz ka kb jf kc kd ke jj kf kg kh ki hb bi translated">它是一个列表或受限制的数组，限制是可以在一端(后端)执行插入，在另一端(前端)执行删除。它遵循FIFO排序，即首先添加的元素将首先被删除。</p><p id="ab8e" class="pw-post-body-paragraph jo jp hi jq b jr kj jt ju jv kk jx jy jb kl ka kb jf km kd ke jj kn kg kh ki hb bi translated">队列的应用包括:</p><ol class=""><li id="0986" class="ko kp hi jq b jr kj jv kk jb kq jf kr jj ks ki kt ku kv kw bi translated">一种队列由操作系统在调度进程到CPU时维护</li><li id="9d71" class="ko kp hi jq b jr kx jv ky jb kz jf la jj lb ki kt ku kv kw bi translated">树数据结构使用它来执行层次顺序遍历</li><li id="711a" class="ko kp hi jq b jr kx jv ky jb kz jf la jj lb ki kt ku kv kw bi translated">图形数据结构使用它来执行广度优先搜索。</li></ol><p id="39d7" class="pw-post-body-paragraph jo jp hi jq b jr kj jt ju jv kk jx jy jb kl ka kb jf km kd ke jj kn kg kh ki hb bi translated"><strong class="jq hj">队列上经常执行的操作:</strong></p><figure class="ld le lf lg fd ij er es paragraph-image"><div class="er es lc"><img src="../Images/176b3d99d2dd4c2f87e13a5d7849e0d6.png" data-original-src="https://miro.medium.com/v2/resize:fit:532/format:webp/1*53WTyXgpvLlQc-x7El82pQ.jpeg"/></div></figure><ol class=""><li id="4a27" class="ko kp hi jq b jr kj jv kk jb kq jf kr jj ks ki kt ku kv kw bi translated">IsFull:如果队列的当前大小等于最大大小，则队列已满。</li><li id="81b8" class="ko kp hi jq b jr kx jv ky jb kz jf la jj lb ki kt ku kv kw bi translated">IsEmpty:如果队列的当前大小为零</li><li id="168a" class="ko kp hi jq b jr kx jv ky jb kz jf la jj lb ki kt ku kv kw bi translated">Push(Enqueue):这将在后端插入一个元素。</li><li id="a128" class="ko kp hi jq b jr kx jv ky jb kz jf la jj lb ki kt ku kv kw bi translated">Pop(出列):这是从前端删除一个元素。</li></ol><h2 id="dec9" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">队列类及其操作的实现:</h2><p id="5852" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jb jz ka kb jf kc kd ke jj kf kg kh ki hb bi translated">1) <strong class="jq hj">使用数组实现循环队列:</strong></p><figure class="ld le lf lg fd ij er es paragraph-image"><div role="button" tabindex="0" class="li lj di lk bf ll"><div class="er es lh"><img src="../Images/5c80beea81e1183ba9cac2e73ff875c2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*eWzZisYrBonlZNQiB55pOw.png"/></div></div><figcaption class="im in et er es io ip bd b be z dx translated">队列类别</figcaption></figure><p id="f2a1" class="pw-post-body-paragraph jo jp hi jq b jr kj jt ju jv kk jx jy jb kl ka kb jf km kd ke jj kn kg kh ki hb bi translated">在上面的代码中，我们使用动态分配的数组实现了一个循环队列。因为我们在做动态分配，所以我们需要一个析构函数在函数调用结束后删除所有的数据成员。</p><figure class="ld le lf lg fd ij er es paragraph-image"><div class="er es lm"><img src="../Images/807cd2ca481bf5935b480461f45cda82.png" data-original-src="https://miro.medium.com/v2/resize:fit:662/format:webp/1*zScaWHenwS49VbOqsR55JQ.png"/></div><figcaption class="im in et er es io ip bd b be z dx translated">破坏者</figcaption></figure><p id="7fed" class="pw-post-body-paragraph jo jp hi jq b jr kj jt ju jv kk jx jy jb kl ka kb jf km kd ke jj kn kg kh ki hb bi translated">不同操作的实现:</p><figure class="ld le lf lg fd ij er es paragraph-image"><div role="button" tabindex="0" class="li lj di lk bf ll"><div class="er es ln"><img src="../Images/7bfb1e64598240b18b15e758bcbbed02.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WkNjvJWT9GEDJzs10VYUDA.png"/></div></div><figcaption class="im in et er es io ip bd b be z dx translated">对队列执行了不同的操作</figcaption></figure><p id="9014" class="pw-post-body-paragraph jo jp hi jq b jr kj jt ju jv kk jx jy jb kl ka kb jf km kd ke jj kn kg kh ki hb bi translated"><strong class="jq hj"> 2)使用链表stl实现队列:</strong></p><p id="ca2b" class="pw-post-body-paragraph jo jp hi jq b jr kj jt ju jv kk jx jy jb kl ka kb jf km kd ke jj kn kg kh ki hb bi translated">在这种情况下，如果我们通过在尾部插入一个节点来推动元素，那么tail就变成了使用list stl的后端，我们可以通过:<code class="du lo lp lq lr b">list&lt;int&gt;l</code>来完成</p><p id="3ac3" class="pw-post-body-paragraph jo jp hi jq b jr kj jt ju jv kk jx jy jb kl ka kb jf km kd ke jj kn kg kh ki hb bi translated"><code class="du lo lp lq lr b">if(!empty){void push(){ l.push_back(); current_size++;}}</code></p><p id="3311" class="pw-post-body-paragraph jo jp hi jq b jr kj jt ju jv kk jx jy jb kl ka kb jf km kd ke jj kn kg kh ki hb bi translated">从我们移除节点的位置开始，head成为前端。</p><p id="cb77" class="pw-post-body-paragraph jo jp hi jq b jr kj jt ju jv kk jx jy jb kl ka kb jf km kd ke jj kn kg kh ki hb bi translated"><code class="du lo lp lq lr b">if(!full){void pop(){ l.pop_front(); current_size--;}}</code></p><p id="a195" class="pw-post-body-paragraph jo jp hi jq b jr kj jt ju jv kk jx jy jb kl ka kb jf km kd ke jj kn kg kh ki hb bi translated"><strong class="jq hj"> 3)使用堆栈实现队列:</strong></p><p id="7c9f" class="pw-post-body-paragraph jo jp hi jq b jr kj jt ju jv kk jx jy jb kl ka kb jf km kd ke jj kn kg kh ki hb bi translated">我们可以使用两个栈来实现一个队列来执行推送操作，我们可以简单地将元素推入一个栈中。要从队列中执行弹出操作，首先我们必须将除最后一个元素之外的所有元素从非空堆栈推入空堆栈。然后，我们可以弹出该元素，并再次将这些元素传输回最初非空的堆栈。为了更清楚，请看一下代码。</p><figure class="ld le lf lg fd ij er es paragraph-image"><div role="button" tabindex="0" class="li lj di lk bf ll"><div class="er es ls"><img src="../Images/b4ee426518a550b606868ccdaaec17f0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EiTU551TuCbEigZtjs7DZQ.png"/></div></div><figcaption class="im in et er es io ip bd b be z dx translated">使用堆栈实现队列</figcaption></figure><h1 id="b40a" class="lt ir hi bd is lu lv lw iw lx ly lz ja ma mb mc je md me mf ji mg mh mi jm mj bi translated">出列:</h1><p id="e0af" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jb jz ka kb jf kc kd ke jj kf kg kh ki hb bi translated">→它代表双端队列。顾名思义，我们可以从两端执行插入和删除。</p><p id="afa4" class="pw-post-body-paragraph jo jp hi jq b jr kj jt ju jv kk jx jy jb kl ka kb jf km kd ke jj kn kg kh ki hb bi translated">→它的一些功能与vector相同，一些功能与list相同。它具有像向量一样的随机存取特性和像链表一样的末端增长功能。</p><p id="d490" class="pw-post-body-paragraph jo jp hi jq b jr kj jt ju jv kk jx jy jb kl ka kb jf km kd ke jj kn kg kh ki hb bi translated">→每当我们希望从两个元素中展开元素时，出列是最好的数据结构。然而，当我们想要从中间插入或删除元素时，使用向量或列表会更好。</p><p id="d390" class="pw-post-body-paragraph jo jp hi jq b jr kj jt ju jv kk jx jy jb kl ka kb jf km kd ke jj kn kg kh ki hb bi translated">文章结尾。</p><p id="df1c" class="pw-post-body-paragraph jo jp hi jq b jr kj jt ju jv kk jx jy jb kl ka kb jf km kd ke jj kn kg kh ki hb bi translated">谢谢各位读者。</p><p id="0c15" class="pw-post-body-paragraph jo jp hi jq b jr kj jt ju jv kk jx jy jb kl ka kb jf km kd ke jj kn kg kh ki hb bi translated">希望有帮助:)</p><p id="66df" class="pw-post-body-paragraph jo jp hi jq b jr kj jt ju jv kk jx jy jb kl ka kb jf km kd ke jj kn kg kh ki hb bi translated">快乐编码。</p></div></div>    
</body>
</html>