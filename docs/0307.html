<html>
<head>
<title>Effectively using python decorators and function overloading</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">有效地使用 python 装饰器和函数重载</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/effectively-using-python-decorators-and-function-overloading-14a195e76bd0?source=collection_archive---------0-----------------------#2020-09-20">https://medium.com/nerd-for-tech/effectively-using-python-decorators-and-function-overloading-14a195e76bd0?source=collection_archive---------0-----------------------#2020-09-20</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><figure class="hh hi ez fb hj hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es hg"><img src="../Images/14523c43e2f38a29dae4c3a7f32644e0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rF5-HRy1TXoJ5wfI8YXLbw.jpeg"/></div></div></figure><div class=""/><p id="04e6" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">Decorators 是 python 中使用最多的特性之一。在这个博客中，我们将讨论，</p><ul class=""><li id="356f" class="jo jp ht is b it iu ix iy jb jq jf jr jj js jn jt ju jv jw bi translated">装修工</li><li id="b69e" class="jo jp ht is b it jx ix jy jb jz jf ka jj kb jn jt ju jv jw bi translated">python 如何执行 decorators</li><li id="5264" class="jo jp ht is b it jx ix jy jb jz jf ka jj kb jn jt ju jv jw bi translated">定义装饰者的各种方式</li><li id="144b" class="jo jp ht is b it jx ix jy jb jz jf ka jj kb jn jt ju jv jw bi translated">singledispatch 是一个装饰器，用于 python 标准库中定义的函数重载。</li></ul><p id="cef3" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在这篇博客中，我们将通过烤披萨的例子来理解上面提到的概念。</p><figure class="kc kd ke kf fd hk"><div class="bz dy l di"><div class="kg kh l"/></div></figure></div><div class="ab cl ki kj gp kk" role="separator"><span class="kl bw bk km kn ko"/><span class="kl bw bk km kn ko"/><span class="kl bw bk km kn"/></div><div class="hb hc hd he hf"><h1 id="e569" class="kp kq ht bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm bi translated">装饰基础</h1><p id="ccbf" class="pw-post-body-paragraph iq ir ht is b it ln iv iw ix lo iz ja jb lp jd je jf lq jh ji jj lr jl jm jn hb bi translated">一个<a class="ae ls" href="https://en.wikipedia.org/wiki/Python_syntax_and_semantics#Decorators" rel="noopener ugc nofollow" target="_blank">装饰器</a>是一个可调用的，它作为一个包装器工作，把一个函数作为一个参数，并用被装饰的函数执行一些处理。</p><figure class="kc kd ke kf fd hk"><div class="bz dy l di"><div class="lt kh l"/></div></figure><p id="423e" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">抽样输出</p><pre class="kc kd ke kf fd lu lv lw lx aw ly bi"><span id="d974" class="lz kq ht lv b fi ma mb l mc md">Just adding more cheese here...<br/>Just baking pizza here...<br/>And Done!</span></pre><p id="4503" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在上面的代码中，我们嵌套了函数<em class="me">添加 _ 奶酪</em>和<em class="me">内部 _ 函数</em>。函数<em class="me"> adding_cheese </em>以函数为自变量，返回<em class="me"> inner_function </em>。在<em class="me"> inner_function </em>中，在调用作为参数传递给<em class="me"> adding_cheese </em>的函数前后执行打印语句。在函数<em class="me"> baking_pizza </em>之上添加<em class="me">@ add _ cheese</em>，用<em class="me">add _ cheese</em>装饰<em class="me"> baking_pizza </em>，换句话说<em class="me">add _ cheese</em>是装饰函数<em class="me"> baking_pizza </em>是装饰函数<em class="me">。</em></p><p id="8345" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">正如您在示例输出中看到的，我们看到了在<em class="me"> baking_pizza </em>和<em class="me"> inner_function </em>中定义的打印语句。</p><figure class="kc kd ke kf fd hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es mf"><img src="../Images/7cf14421166773329d13dc7725ed7952.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*93QHvClOBI2VS97bOj1-fg.jpeg"/></div></div></figure></div><div class="ab cl ki kj gp kk" role="separator"><span class="kl bw bk km kn ko"/><span class="kl bw bk km kn ko"/><span class="kl bw bk km kn"/></div><div class="hb hc hd he hf"><h1 id="3921" class="kp kq ht bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm bi translated">装饰者执行</h1><p id="037c" class="pw-post-body-paragraph iq ir ht is b it ln iv iw ix lo iz ja jb lp jd je jf lq jh ji jj lr jl jm jn hb bi translated">看看 python 如何执行 decorators 是很有趣的。下面是一个演示程序。</p><figure class="kc kd ke kf fd hk"><div class="bz dy l di"><div class="lt kh l"/></div></figure><p id="8ed3" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">抽样输出</p><pre class="kc kd ke kf fd lu lv lw lx aw ly bi"><span id="837c" class="lz kq ht lv b fi ma mb l mc md">Adding topping &lt;function adding_olives at 0x10c9cad08&gt;...<br/>Adding topping &lt;function adding_onions at 0x10c9cad90&gt;...<br/>Adding topping &lt;function adding_tomatoes at 0x10c9cae18&gt;...<br/>Stated adding toppings<br/>Toppings added so far [&lt;function adding_olives at 0x10c9cad08&gt;, &lt;function adding_onions at 0x10c9cad90&gt;, &lt;function adding_tomatoes at 0x10c9cae18&gt;]<br/>Added Olives...<br/>Added Onions...<br/>Added tomatoes...<br/>This is getting out of hand now. GET OUT!!!</span></pre><p id="db45" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在上面的代码中，decorator<em class="me">adding _ toppings</em>向 list <em class="me"> toppings </em>添加装饰函数。在主函数中，我们打印列表<em class="me">浇头</em>的内容，并调用函数<em class="me">添加橄榄</em>、<em class="me">添加洋葱</em>、<em class="me">添加番茄</em>和<em class="me">添加苹果</em>。函数<em class="me"> adding_toppings </em>打印哪个函数被修饰，然后添加到列表<em class="me"> toppings </em>中。</p><p id="36b6" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">样本输出显示了一个有趣的结果。Decorators 在模块加载后立即运行，而被修饰的函数在被调用时运行。在示例输出中，前三行用于<em class="me">添加浇头</em>装饰器执行，它被添加到函数<em class="me">添加橄榄</em>、<em class="me">添加洋葱</em>和<em class="me">添加番茄</em>的顶部。有趣的是看到<em class="me"> toppings </em>没有列出函数<em class="me"> adding_apple </em>，那是因为函数<em class="me"> adding_apple </em>没有用<em class="me"> @adding_toppings </em>修饰。</p></div><div class="ab cl ki kj gp kk" role="separator"><span class="kl bw bk km kn ko"/><span class="kl bw bk km kn ko"/><span class="kl bw bk km kn"/></div><div class="hb hc hd he hf"><h1 id="3297" class="kp kq ht bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm bi translated">堆叠装饰者</h1><p id="d2d9" class="pw-post-body-paragraph iq ir ht is b it ln iv iw ix lo iz ja jb lp jd je jf lq jh ji jj lr jl jm jn hb bi translated">我们可以将多个装饰器堆叠到一个函数中。让我们回忆一下用来介绍装饰者的在比萨饼中加入奶酪的例子。在函数<em class="me"> baking_pizza </em>中，让我们添加两个堆叠的装饰器，而不是一个。</p><figure class="kc kd ke kf fd hk"><div class="bz dy l di"><div class="lt kh l"/></div></figure><p id="f738" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">抽样输出</p><pre class="kc kd ke kf fd lu lv lw lx aw ly bi"><span id="6669" class="lz kq ht lv b fi ma mb l mc md">Just adding more cheese here...<br/>Just adding some more cheese here...<br/>Just baking pizza here...<br/>And Done!</span></pre><p id="5aef" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">当两个或更多装饰器被添加到一个函数中时，首先调用外部装饰器，然后调用其他堆叠的装饰器。从示例输出中我们可以看到，首先调用外部装饰器<em class="me">add _ cheese</em>，然后调用第二个装饰器 add _ more _ cheese。</p></div><div class="ab cl ki kj gp kk" role="separator"><span class="kl bw bk km kn ko"/><span class="kl bw bk km kn ko"/><span class="kl bw bk km kn"/></div><div class="hb hc hd he hf"><h1 id="99fe" class="kp kq ht bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm bi translated">函数参数和返回值</h1><p id="faf4" class="pw-post-body-paragraph iq ir ht is b it ln iv iw ix lo iz ja jb lp jd je jf lq jh ji jj lr jl jm jn hb bi translated">让我们考虑接受函数参数并返回一个值的修饰函数的情况。</p><figure class="kc kd ke kf fd hk"><div class="bz dy l di"><div class="lt kh l"/></div></figure><p id="06af" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">抽样输出</p><pre class="kc kd ke kf fd lu lv lw lx aw ly bi"><span id="89a4" class="lz kq ht lv b fi ma mb l mc md">Just adding more cheese here...<br/>Blah Blah baking pizza here...<br/>And done!</span></pre><p id="d4d3" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在上面的代码示例中，函数<em class="me"> baking_pizza </em>将<em class="me"> name </em>作为参数，并返回一个字符串。为了处理函数参数，我们使用<em class="me"> args </em>和<em class="me"> kwargs </em>来接受<em class="me"> input_function </em>中的输入参数。同样，<em class="me"> inner_function </em>在函数执行返回由函数<em class="me"> baking_pizza </em>返回的值后，返回变量<em class="me"> ret_val </em>。</p></div><div class="ab cl ki kj gp kk" role="separator"><span class="kl bw bk km kn ko"/><span class="kl bw bk km kn ko"/><span class="kl bw bk km kn"/></div><div class="hb hc hd he hf"><h1 id="98d4" class="kp kq ht bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm bi translated">班级中的装饰者</h1><p id="7f08" class="pw-post-body-paragraph iq ir ht is b it ln iv iw ix lo iz ja jb lp jd je jf lq jh ji jj lr jl jm jn hb bi translated">让我们考虑一下在一个类中定义 decorator 的时候，</p><figure class="kc kd ke kf fd hk"><div class="bz dy l di"><div class="lt kh l"/></div></figure><p id="53b6" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">抽样输出</p><pre class="kc kd ke kf fd lu lv lw lx aw ly bi"><span id="08e1" class="lz kq ht lv b fi ma mb l mc md">Just adding more cheese here...<br/>Blah Blah baking pizza here...<br/>And Done!</span></pre><p id="5f8f" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在上面的代码示例中，类<em class="me"> pizza </em>有一个装饰函数<em class="me">add _ cheese</em>，它装饰函数<em class="me"> baking_pizza </em>。在这种情况下，我们使用<em class="me"> @pizza.adding_cheese </em>进行装饰。</p></div><div class="ab cl ki kj gp kk" role="separator"><span class="kl bw bk km kn ko"/><span class="kl bw bk km kn ko"/><span class="kl bw bk km kn"/></div><div class="hb hc hd he hf"><h1 id="2500" class="kp kq ht bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm bi translated">参数化装饰器</h1><p id="2c79" class="pw-post-body-paragraph iq ir ht is b it ln iv iw ix lo iz ja jb lp jd je jf lq jh ji jj lr jl jm jn hb bi translated">参数为程序员提供了更大的灵活性，可以根据条件有效地使用装饰器。</p><figure class="kc kd ke kf fd hk"><div class="bz dy l di"><div class="lt kh l"/></div></figure><p id="8a26" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">抽样输出</p><pre class="kc kd ke kf fd lu lv lw lx aw ly bi"><span id="daad" class="lz kq ht lv b fi ma mb l mc md">Baking supreme_veggie_pizza pizza with thin crust<br/>Just baking pizza here...<br/>And Done!<br/>Baking farmhouse_pizza pizza with normal crust<br/>Just baking pizza here...<br/>And Done!</span></pre><p id="c709" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在上面的示例代码中，decorator <em class="me"> pizza_crust </em>将<em class="me"> crust </em>作为参数。在函数<em class="me">中，supreme_veggie_pizza </em>装饰器被设置为<em class="me">外壳</em>‘瘦’，而在函数<em class="me">中，农舍 _pizza </em>装饰器被不带参数地调用，因此装饰器选择<em class="me">外壳</em>的默认值，即‘正常’。</p></div><div class="ab cl ki kj gp kk" role="separator"><span class="kl bw bk km kn ko"/><span class="kl bw bk km kn ko"/><span class="kl bw bk km kn"/></div><div class="hb hc hd he hf"><h1 id="fac6" class="kp kq ht bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm bi translated">装饰演示</h1><p id="955d" class="pw-post-body-paragraph iq ir ht is b it ln iv iw ix lo iz ja jb lp jd je jf lq jh ji jj lr jl jm jn hb bi translated">有了关于装饰者的所有基本信息，让我们试着实现一个函数，它将根据比萨饼订单计算用户可以得到的最大折扣。这将说明我们如何在程序中利用装饰器。</p><figure class="kc kd ke kf fd hk"><div class="bz dy l di"><div class="lt kh l"/></div></figure><p id="432a" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">抽样输出</p><pre class="kc kd ke kf fd lu lv lw lx aw ly bi"><span id="b53a" class="lz kq ht lv b fi ma mb l mc md">discount = 0.2</span></pre><p id="fdad" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在上面的示例代码中，<em class="me"> order_dict </em>模仿订购比萨饼的用户的输入。函数<em class="me"> seasonal_discount </em>、<em class="me"> buy_2_pizza </em>和<em class="me"> new_customer </em>读取<em class="me"> order_dict </em>以确定折扣是否适用。在任何时候，如果我们必须删除一个类别的折扣，那么只需从函数中删除 decorator 即可。因此，通过最小的改变，我们可以在程序执行中增加或删除一个功能。</p></div><div class="ab cl ki kj gp kk" role="separator"><span class="kl bw bk km kn ko"/><span class="kl bw bk km kn ko"/><span class="kl bw bk km kn"/></div><div class="hb hc hd he hf"><h1 id="9026" class="kp kq ht bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm bi translated">使用 Singledispatch 的函数重载</h1><p id="8474" class="pw-post-body-paragraph iq ir ht is b it ln iv iw ix lo iz ja jb lp jd je jf lq jh ji jj lr jl jm jn hb bi translated">Python 在标准库中定义了一些装饰器，如<a class="ae ls" href="https://docs.python.org/3/howto/descriptor.html#properties" rel="noopener ugc nofollow" target="_blank">属性</a>、<a class="ae ls" href="https://docs.python.org/3/library/functions.html#staticmethod" rel="noopener ugc nofollow" target="_blank">静态方法</a>、<a class="ae ls" href="https://docs.python.org/3/library/functions.html#classmethod" rel="noopener ugc nofollow" target="_blank">类方法</a>、<a class="ae ls" href="https://docs.python.org/3/library/functools.html" rel="noopener ugc nofollow" target="_blank"> lru_cache </a>、<a class="ae ls" href="https://docs.python.org/3/library/functools.html#functools.singledispatch" rel="noopener ugc nofollow" target="_blank"> singledispatch </a>等。在本节中，我们将以 singledispatch 为例，它用于覆盖函数。下面是一个示例程序，其中我们覆盖了<em class="me"> get_cost </em>函数来返回不同外壳类型的成本。</p><figure class="kc kd ke kf fd hk"><div class="bz dy l di"><div class="lt kh l"/></div></figure><p id="217f" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">抽样输出</p><pre class="kc kd ke kf fd lu lv lw lx aw ly bi"><span id="4571" class="lz kq ht lv b fi ma mb l mc md">thin_crust_cost = 25</span></pre><p id="17e0" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在上面的示例代码中，我们定义了三个数据类<em class="me"> ThinCrust </em>、<em class="me"> NormalCrust </em>和<em class="me"> ThickCrust </em>。函数<em class="me"> get_cost </em>用 singledispatch 修饰，被用<em class="me"> @get_cost.register </em>修饰的函数覆盖。根据<em class="me"> get_cost </em>函数调用中的对象类型，返回的 cost 会有所不同。这是避免多个 if/elseif/else 条件的好方法。</p></div><div class="ab cl ki kj gp kk" role="separator"><span class="kl bw bk km kn ko"/><span class="kl bw bk km kn ko"/><span class="kl bw bk km kn"/></div><div class="hb hc hd he hf"><p id="0746" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我希望这对你有用。我们可以在理解 python 中的工厂类模式时扩展这些知识，我将在以后的博客中介绍。感谢您阅读博客。</p></div></div>    
</body>
</html>