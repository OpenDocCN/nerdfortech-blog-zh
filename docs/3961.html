<html>
<head>
<title>Bigger .dockerignore, Smaller Docker Images</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">更大。dockerignore，较小的Docker图像</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/bigger-dockerignore-smaller-docker-images-49fa22e51c7?source=collection_archive---------2-----------------------#2021-07-01">https://medium.com/nerd-for-tech/bigger-dockerignore-smaller-docker-images-49fa22e51c7?source=collection_archive---------2-----------------------#2021-07-01</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="36c5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="jd">这是四篇系列文章中的第一篇，尽量减少&amp;保护Docker图像。查看该系列的其他文章:<br/> 1。</em> <a class="ae je" rel="noopener" href="/nerd-for-tech/bigger-dockerignore-smaller-docker-images-49fa22e51c7"> <em class="jd">变大。更小的Docker图片</em> </a> <em class="jd"> <br/> 2。</em> <a class="ae je" rel="noopener" href="/nerd-for-tech/look-docker-no-distro-5dc87d4deb00"> <em class="jd">看Docker，看Distro </em> </a></p></div><div class="ab cl jf jg gp jh" role="separator"><span class="ji bw bk jj jk jl"/><span class="ji bw bk jj jk jl"/><span class="ji bw bk jj jk"/></div><div class="hb hc hd he hf"><p id="1616" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">每个人都想要更快的构建时间，更少的垃圾应用。通过增强我们的<code class="du jm jn jo jp b">.dockerignore</code>我们可以制作更小的Docker图像。更小的映像的好处不会停留在更快的构建时间上。较小的图像占用较少的磁盘空间，当应用程序扩展时，这确实开始显示出一些好处，可能是在自动扩展的Kubernetes集群中。最后，较小的Docker图像具有较小的攻击面。</p><figure class="jr js jt ju fd jv er es paragraph-image"><div role="button" tabindex="0" class="jw jx di jy bf jz"><div class="er es jq"><img src="../Images/f05be756bc8cf56f58faed2540847d76.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rigec5s2gIolcQDRIl68LQ.jpeg"/></div></div></figure><p id="81d4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这是关于优化Docker图像大小和安全性的四部分系列的第一部分。本文有一个相应的存储库，用来展示一个真实的例子。回购可以在<a class="ae je" href="https://github.com/starlightromero/dockerignore-example" rel="noopener ugc nofollow" target="_blank">这里</a>找到。每个分支都将建立在前面的基础上，展示我们将在文章中经历的不同阶段。</p><h1 id="c203" class="kc kd hi bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated">🔤回到基础</h1><p id="c836" class="pw-post-body-paragraph if ig hi ih b ii la ik il im lb io ip iq lc is it iu ld iw ix iy le ja jb jc hb bi translated">就像<code class="du jm jn jo jp b">.gitignore</code>文件定义了我们希望git忽略的文件一样，<code class="du jm jn jo jp b">.dockerignore</code>文件定义了我们希望Docker忽略的文件。但是为什么我们希望Docker忽略某些文件呢？回到想要更小的映像，当我们运行<code class="du jm jn jo jp b">docker run</code>或<code class="du jm jn jo jp b">docker-compose up</code>时，更小的映像意味着更快的构建时间。如果您的应用程序运行不需要某个文件，请将其放入<code class="du jm jn jo jp b">.dockerignore</code>。现在这个文件在<code class="du jm jn jo jp b">.dockerignore</code>中，它不会包含在Docker图像中，从而减小了图像的大小。Docker CLI在您的应用程序的根目录中寻找<code class="du jm jn jo jp b">.dockerignore</code>。如果它不在根文件夹中，就不会被读取。</p><p id="0806" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">放入您的<code class="du jm jn jo jp b">.gitignore</code>中的一些文件示例如下:</p><ul class=""><li id="97ac" class="lf lg hi ih b ii ij im in iq lh iu li iy lj jc lk ll lm ln bi translated"><code class="du jm jn jo jp b">.git</code></li><li id="a14b" class="lf lg hi ih b ii lo im lp iq lq iu lr iy ls jc lk ll lm ln bi translated"><code class="du jm jn jo jp b">.vscode</code></li><li id="2cb6" class="lf lg hi ih b ii lo im lp iq lq iu lr iy ls jc lk ll lm ln bi translated"><code class="du jm jn jo jp b">.gitignore</code></li><li id="9eef" class="lf lg hi ih b ii lo im lp iq lq iu lr iy ls jc lk ll lm ln bi translated"><code class="du jm jn jo jp b">build</code></li><li id="8e53" class="lf lg hi ih b ii lo im lp iq lq iu lr iy ls jc lk ll lm ln bi translated"><code class="du jm jn jo jp b">dist</code></li><li id="56b1" class="lf lg hi ih b ii lo im lp iq lq iu lr iy ls jc lk ll lm ln bi translated"><code class="du jm jn jo jp b">node_modules</code></li><li id="b82d" class="lf lg hi ih b ii lo im lp iq lq iu lr iy ls jc lk ll lm ln bi translated"><code class="du jm jn jo jp b">Makefile</code></li><li id="0834" class="lf lg hi ih b ii lo im lp iq lq iu lr iy ls jc lk ll lm ln bi translated"><code class="du jm jn jo jp b">README.md</code></li></ul><p id="0de6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">分支<code class="du jm jn jo jp b">01-Basics</code>是该部分的对应分支。克隆并运行应用程序会在端口<code class="du jm jn jo jp b">8080</code>启动一个服务器。导航到<code class="du jm jn jo jp b">localhost:8080</code>，我们可以看到文本，<code class="du jm jn jo jp b">“Hello, World! The secret is 1234”</code>。</p><p id="a83b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">深入到<code class="du jm jn jo jp b">.dockerignore</code>文件，我们可以看到我们忽略的文件:</p><figure class="jr js jt ju fd jv"><div class="bz dy l di"><div class="lt lu l"/></div></figure><p id="b55a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在<code class="du jm jn jo jp b">Dockerfile</code>的第8/9步，我们运行一个<code class="du jm jn jo jp b">ls -la</code>命令。我们可以看到下面的输出:</p><figure class="jr js jt ju fd jv"><div class="bz dy l di"><div class="lt lu l"/></div></figure><p id="b098" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这很好，但是我们还能去掉什么呢？</p><h1 id="659b" class="kc kd hi bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated">🐳码头工人的东西</h1><p id="0b52" class="pw-post-body-paragraph if ig hi ih b ii la ik il im lb io ip iq lc is it iu ld iw ix iy le ja jb jc hb bi translated">我们可以把<code class="du jm jn jo jp b">Dockerfile</code>或者<code class="du jm jn jo jp b">docker-compose.yml</code>放在<code class="du jm jn jo jp b">.dockerignore</code>文件里吗？是啊！把这些也扔进去。如果我们的应用不直接需要文件来运行，它属于<code class="du jm jn jo jp b">.dockerignore</code>。我们甚至可以将<code class="du jm jn jo jp b">.dockerignore</code>本身放入<code class="du jm jn jo jp b">.dockerignore</code>文件中！这是为什么呢？</p><figure class="jr js jt ju fd jv"><div class="bz dy l di"><div class="lt lu l"/></div></figure><p id="52d6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">是的，<code class="du jm jn jo jp b">Dockerfile</code>、<code class="du jm jn jo jp b">docker-compose.yml</code>和<code class="du jm jn jo jp b">.dockerignore</code>都是用来构建映像和旋转容器的，然而，这就是这些文件的目的所在。我们的应用程序中不使用它们。<em class="jd">如果我们不需要文件来运行没有Docker的应用程序，我们也不需要文件来运行有Docker的应用程序。我们需要文件来构建Docker映像，也需要文件来运行Docker容器。然而，Docker容器中的应用程序不需要这些文件。</em></p><figure class="jr js jt ju fd jv"><div class="bz dy l di"><div class="lt lu l"/></div></figure><h1 id="0b0d" class="kc kd hi bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated">🔒环境变量</h1><p id="ee22" class="pw-post-body-paragraph if ig hi ih b ii la ik il im lb io ip iq lc is it iu ld iw ix iy le ja jb jc hb bi translated">在Docker的上下文中，环境文件总是让我感到困惑。与<code class="du jm jn jo jp b">Dockerfile</code>不同，无论是使用Docker还是不使用Docker，应用程序都需要<code class="du jm jn jo jp b">.env</code>才能正常运行。然而，如果我们正在使用一个<code class="du jm jn jo jp b">docker-compose.yml</code>文件，就像我们在这个应用程序中一样，并且在yml文件中我们定义了一个<code class="du jm jn jo jp b">env_file</code>，那么<code class="du jm jn jo jp b">.env</code>文件可以被忽略。</p><figure class="jr js jt ju fd jv"><div class="bz dy l di"><div class="lt lu l"/></div></figure><p id="f036" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在<code class="du jm jn jo jp b">docker-compose.yml</code>中定义一个<code class="du jm jn jo jp b">env_file</code>就是<code class="du jm jn jo jp b">docker-compose --env-file ./.env</code>的声明版本。这两种方法都定义了包含秘密变量的环境文件的路径，允许docker-compose访问变量并将其传递给容器内运行的应用程序。通过将环境文件传递给docker-compose，docker本身不需要知道环境文件。这是因为docker-compose的作用类似于<code class="du jm jn jo jp b">Dockerfile</code>的包装器。Docker-compose是<code class="du jm jn jo jp b">docker run …</code>的声明版本。Docker-compose启动<code class="du jm jn jo jp b">Dockerfile</code>构建，并且能够将环境文件传递给Docker构建，而不需要<code class="du jm jn jo jp b">Dockerfile</code>直接需要<code class="du jm jn jo jp b">.env</code>。</p><figure class="jr js jt ju fd jv"><div class="bz dy l di"><div class="lt lu l"/></div></figure><h1 id="51fb" class="kc kd hi bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated">🧪路线和单元测试</h1><p id="8cf4" class="pw-post-body-paragraph if ig hi ih b ii la ik il im lb io ip iq lc is it iu ld iw ix iy le ja jb jc hb bi translated">运行应用程序不需要测试，但测试应用程序需要测试。一种选择是在Docker容器之外测试应用程序。在这种情况下，我们可以忽略测试文件。这种方法有Docker之外的任何应用程序的缺点，应用程序运行的环境不能保证有所有正确的包、包版本、配置等。</p><figure class="jr js jt ju fd jv"><div class="bz dy l di"><div class="lt lu l"/></div></figure><p id="3469" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在Docker容器中测试您的应用程序在一个标准化的环境中提供了更多的一致性。当测试文件被忽略时，我们如何测试应用程序？我们将在下面的热重装部分回到这个问题。然而，现在，我们将忽略测试文件。</p><figure class="jr js jt ju fd jv"><div class="bz dy l di"><div class="lt lu l"/></div></figure><h1 id="06b1" class="kc kd hi bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated">🐗通配符选择器</h1><p id="d846" class="pw-post-body-paragraph if ig hi ih b ii la ik il im lb io ip iq lc is it iu ld iw ix iy le ja jb jc hb bi translated">在本节中，我们不会向<code class="du jm jn jo jp b">.dockerignore</code>添加任何额外的文件。我们将通过使用通配符选择器来压缩<code class="du jm jn jo jp b">.dockerignore</code>中的行数。<code class="du jm jn jo jp b">*</code>允许我们填充不确定数量的字符。在第5行，我们有<code class="du jm jn jo jp b">docker-compose*.yml</code>。这将忽略<code class="du jm jn jo jp b">docker-compose.yml</code>、<code class="du jm jn jo jp b">docker-compose.dev.yml</code>和<code class="du jm jn jo jp b">docker-composeyou-can-put-anything-here.yml</code>。我们在第3行使用了类似的语法来忽略<code class="du jm jn jo jp b">.dockerignore</code>和<code class="du jm jn jo jp b">.gitignore</code>。第6行和第9行遵循相同的逻辑。</p><figure class="jr js jt ju fd jv"><div class="bz dy l di"><div class="lt lu l"/></div></figure><p id="9e1b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">第7行遵循不同的模式，<code class="du jm jn jo jp b">**</code>。双通配符允许我们匹配任意数量的目录(包括零)。因此<code class="du jm jn jo jp b">**/*_test.go</code>将匹配任何目录中的任何测试文件。这条小小的、强有力的线具有下面定义的所有能力(以及更多):</p><ul class=""><li id="f9f4" class="lf lg hi ih b ii ij im in iq lh iu li iy lj jc lk ll lm ln bi translated">✅ <code class="du jm jn jo jp b">./main_test.go</code></li><li id="94a4" class="lf lg hi ih b ii lo im lp iq lq iu lr iy ls jc lk ll lm ln bi translated">✅ <code class="du jm jn jo jp b">/tests/main_test.go</code></li><li id="bc4c" class="lf lg hi ih b ii lo im lp iq lq iu lr iy ls jc lk ll lm ln bi translated">✅ <code class="du jm jn jo jp b">/tests/auth_test.go</code></li><li id="6aaa" class="lf lg hi ih b ii lo im lp iq lq iu lr iy ls jc lk ll lm ln bi translated">✅ <code class="du jm jn jo jp b">/test/auth/main_test.go</code></li><li id="19eb" class="lf lg hi ih b ii lo im lp iq lq iu lr iy ls jc lk ll lm ln bi translated">✅ <code class="du jm jn jo jp b">/test/auth/login_test.go</code></li><li id="677c" class="lf lg hi ih b ii lo im lp iq lq iu lr iy ls jc lk ll lm ln bi translated">❌ <code class="du jm jn jo jp b">./mainTest.go</code></li><li id="32e7" class="lf lg hi ih b ii lo im lp iq lq iu lr iy ls jc lk ll lm ln bi translated">❌ <code class="du jm jn jo jp b">/tests/authTest.go</code></li></ul><p id="d370" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们的<code class="du jm jn jo jp b">Dockerfile</code>中的<code class="du jm jn jo jp b">ls -la</code>命令产生与前面部分相同的输出:</p><figure class="jr js jt ju fd jv"><div class="bz dy l di"><div class="lt lu l"/></div></figure><p id="bc0b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">一个很好的命令是<code class="du jm jn jo jp b">!</code>，但是我从来没有发现需要使用它。通过在<code class="du jm jn jo jp b">.dockerignore</code>中的任何一行前面放一个<code class="du jm jn jo jp b">!</code>，Docker会忽略忽略它。多拗口啊！基本上，Docker会确保将文件包含在映像中。这里有一个不实际的例子:</p><pre class="jr js jt ju fd lv jp lw lx aw ly bi"><span id="7fc4" class="lz kd hi jp b fi ma mb l mc md">*.md<br/>!README.md</span></pre><p id="7426" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们将忽略除<code class="du jm jn jo jp b">README.md</code>之外的所有降价文件。</p><h1 id="43d4" class="kc kd hi bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated">🔃热重装的利与弊</h1><p id="620f" class="pw-post-body-paragraph if ig hi ih b ii la ik il im lb io ip iq lc is it iu ld iw ix iy le ja jb jc hb bi translated">绑定挂载是docker-compose允许我们使用的一种非常有用的卷类型。它们实质上是将Docker容器外部的文件“绑定”到容器内部的文件。这允许热重装。但是，我经常看到它们被误用。说实话，我也不知道使用它们的最佳方式。起初，我会用volume <code class="du jm jn jo jp b">.:/app</code>或<code class="du jm jn jo jp b">.:/usr/src/app</code>将容器外的所有内容绑定到容器内的所有内容。</p><p id="bc3d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果我们理解操作的顺序，就可以更好地理解这种方法的问题。当我们运行<code class="du jm jn jo jp b">docker-compose up</code>或该命令的任何变体时，首先docker-compose命令被转换为<code class="du jm jn jo jp b">docker</code>命令。接下来，读取<code class="du jm jn jo jp b">.dockerignore</code>并忽略其中的任何文件。之后，读取<code class="du jm jn jo jp b">Dockerfile</code>。当然，当我们这样做时，我们只复制Docker没有忽略的文件。然后，应用任何卷，包括绑定装载。卷不符合<code class="du jm jn jo jp b">.dockerignore</code>。最后，如果<code class="du jm jn jo jp b">docker-compose.yml</code>中有指定的命令，则运行该命令。</p><p id="5e4a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">通过绑定挂载<code class="du jm jn jo jp b">.:/app</code>，我们完全覆盖了<code class="du jm jn jo jp b">.dockerignore</code>。因为绑定挂载是在映像构建之后附加的，所以即使是被忽略的文件现在也被挂载到容器中。使用绑定挂载的一个更好的方法是映射特定的文件或文件夹。下面是一个开发<code class="du jm jn jo jp b">docker-compose.dev.yml</code>的例子，我们只在<code class="du jm jn jo jp b">main.go</code>文件上设置了一个绑定挂载，并将其映射到位于<code class="du jm jn jo jp b">WORKDIR</code>位置<code class="du jm jn jo jp b">/app/main.go</code>的容器中的文件。</p><figure class="jr js jt ju fd jv"><div class="bz dy l di"><div class="lt lu l"/></div></figure><p id="f4f5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">回到测试，我们可以应用我们的新知识。由于绑定挂载是在映像构建之后应用的，所以即使我们忽略测试，我们也可以通过添加一个卷<code class="du jm jn jo jp b">./main_test.go:/app/main_test.go</code>使它们在容器中再次可访问。在这个docker-compose中，我们可以看到<code class="du jm jn jo jp b">go test</code>命令正在运行。由于docker-compose命令是在卷被映射后执行的，所以我们可以确信在运行<code class="du jm jn jo jp b">go test</code>时<code class="du jm jn jo jp b">main_test.go</code>文件将在容器内可用。</p><figure class="jr js jt ju fd jv"><div class="bz dy l di"><div class="lt lu l"/></div></figure><h1 id="7d0d" class="kc kd hi bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated">📦打包好</h1><p id="8144" class="pw-post-body-paragraph if ig hi ih b ii la ik il im lb io ip iq lc is it iu ld iw ix iy le ja jb jc hb bi translated">较小的图像大小不仅减少了构建时间和磁盘空间，还减少了我们的攻击面。<code class="du jm jn jo jp b">.dockerignore</code>文件只是优化Docker图像大小的第一步。现在你应该对<code class="du jm jn jo jp b">.dockerignore</code>有了很好的理解，知道如何使用它，以及它如何与其他Docker组件相关联。现在，在你的下一个项目中尝试这些策略，看看你能减少多少图片尺寸。</p></div></div>    
</body>
</html>