<html>
<head>
<title>Things to keep in mind while starting with React.js</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">开始使用React.js时需要记住的事项</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/things-to-keep-in-mind-while-starting-with-react-js-cde16c03e084?source=collection_archive---------10-----------------------#2021-06-12">https://medium.com/nerd-for-tech/things-to-keep-in-mind-while-starting-with-react-js-cde16c03e084?source=collection_archive---------10-----------------------#2021-06-12</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/8df0dd525c33c33dd4e14a2783816d77.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1K83xroL513qUtrkbI4Wtw.png"/></div></div></figure><p id="7adb" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">在我们用React.js开发应用程序时查看基本清单之前，我们应该先了解React.js是如何工作的</strong></p><p id="9192" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们都听说过React有虚拟DOM的概念，这有助于提高SPA(单页应用程序)的性能，所以让我们来揭开这个虚拟DOM是什么的神秘面纱</p><blockquote class="jo jp jq"><p id="e33e" class="iq ir jr is b it iu iv iw ix iy iz ja js jc jd je jt jg jh ji ju jk jl jm jn hb bi translated">虚拟DOM是React保存真实DOM的UI表示的内存</p></blockquote><p id="3348" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">下一个问题出现在脑海中，React Virtual DOM如何帮助提高性能，让我们接下来找到它</p><blockquote class="jo jp jq"><p id="cf94" class="iq ir jr is b it iu iv iw ix iy iz ja js jc jd je jt jg jh ji ju jk jl jm jn hb bi translated"><em class="hi">这些变化发生在用户界面中，而与应用程序的交互，无论是由某些事件还是某些API请求或副作用，都不会直接影响真实的DOM，而是将这些变化传递到虚拟DOM，然后使用React Diffing算法在虚拟DOM和真实DOM之间进行比较，因此存在差异的节点将反映在真实DOM中，其余节点在用户界面更新期间保持不变</em></p></blockquote><p id="b339" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在我们知道了React.js的基本功能，所以我们可以研究一下在开始使用React.js应用程序时需要记住的一些要点。我们将使事情变得非常简单，这样任何从React.js开始的人都会发现这篇文章很有帮助</p><p id="2f33" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">制造原子级别的小组件，然后将它们组合起来，构建大型组件</strong></p><p id="bc74" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><em class="jr">那么，将组件做得更小的原因是什么？</em> <br/>正如我们之前所了解的，React在虚拟DOM上工作，如果它发现组件中的差异，它将在实际DOM上重新渲染整个组件(虽然在重新渲染时有多种情况，但我们在这里保持事情简单，以便任何开始使用React的人都会发现这很有帮助)。比方说，如果我们有几百行代码的大型组件，这意味着它可能有更多的逻辑，更多的状态，这意味着如果有一些只是更新单个状态的事件，将重新呈现整个组件，因此在关注的基础上保持组件独立将有助于在单个更改时只更新组件的所需部分</p><p id="43db" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">仅在需要时提升状态</strong></p><p id="6bb4" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们应该尽可能地保持组件本身的状态，而不是提升父组件的状态，这背后的原因是，如果有一些状态传递给子组件，这是为了单个子组件的唯一目的，在这种情况下，如果该状态有任何变化，它将重新呈现作为父组件一部分的其他子组件，让我们看一个例子</p><figure class="jv jw jx jy fd ij"><div class="bz dy l di"><div class="jz ka l"/></div></figure><p id="597c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在上面的例子中，我们可以看到，如果我们增加Component1中的计数器，它不仅会重新呈现Component1，还会重新呈现父组件和Component2，因为它会改变父组件中的状态，而对于Component2，如果我们增加计数器，它只会重新呈现Component2。</p><blockquote class="jo jp jq"><p id="647b" class="iq ir jr is b it iu iv iw ix iy iz ja js jc jd je jt jg jh ji ju jk jl jm jn hb bi translated"><em class="hi">虽然有提升状态的理由和防止重新呈现其他子组件的方法，但这超出了本文的范围，我们将在下一篇博客</em>中讨论这些</p></blockquote><p id="7cc4" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">躲避道具钻</strong></p><p id="1ce0" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><em class="jr">在我们深入探究道具演练之前，我们必须知道什么是道具，什么是道具演练？</em></p><blockquote class="jo jp jq"><p id="b3f8" class="iq ir jr is b it iu iv iw ix iy iz ja js jc jd je jt jg jh ji ju jk jl jm jn hb bi translated"><em class="hi">属性是我们从一个组件传递到另一个组件的属性，而属性钻取是将属性从父组件传递到叶组件的方法，方法是将属性传递到父组件和叶组件之间所有不需要这些数据的组件</em></p></blockquote><p id="7543" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><em class="jr">现在，为什么要避免道具钻？</em></p><blockquote class="jo jp jq"><p id="2b1f" class="iq ir jr is b it iu iv iw ix iy iz ja js jc jd je jt jg jh ji ju jk jl jm jn hb bi translated"><em class="hi">避免道具钻孔的原因有很多，其中一些是，那些组件不需要道具，没有必要让那些道具穿过它们，可能会有意外改变道具的机会，或者道具在中间被修改</em></p></blockquote><p id="ce0c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">根据关注点分离上下文</strong></p><p id="27fd" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在我们研究分离上下文以及由于不小心使用而导致的问题之前，有必要了解一下React中的上下文API</p><blockquote class="jo jp jq"><p id="9f4f" class="iq ir jr is b it iu iv iw ix iy iz ja js jc jd je jt jg jh ji ju jk jl jm jn hb bi translated"><em class="hi">上下文API是使用父节点到叶节点的数据的方法，无需通过不需要它的中间组件传递属性</em></p></blockquote><p id="fce3" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在，让我们来看看上下文对于性能来说过于重要的场景</p><blockquote class="jo jp jq"><p id="4dcd" class="iq ir jr is b it iu iv iw ix iy iz ja js jc jd je jt jg jh ji ju jk jl jm jn hb bi translated"><em class="hi">如果我们在使用上下文时不小心，它会对组件进行不必要的渲染，从而影响应用程序的性能。<br/>假设我们有一个上下文，其中放置了用户和产品的数据，然后如果有任何事件更新了产品的数据，但用户数据在这种情况下没有改变，则上下文的所有消费者都会触发重新呈现，而不管它是消费产品数据还是用户，所以这就是为什么我们也应该基于关注点来尝试分离上下文。 因此，在我们的场景中，我们可以创建两个单独的上下文，一个用于用户，一个用于产品，这样，如果产品数据发生任何变化，用户的消费者就不会触发重新呈现。 <br/>通过使用Redux等各种状态管理库，有许多其他方法可以避免这种情况，但这超出了本文的范围</em></p></blockquote><p id="9bf0" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">因此，现在让我们用这些基本要点来总结这篇文章，在开发React应用程序时，我们可以记住这些要点，这不仅有助于以良好的方式组织应用程序，还有助于提高应用程序的性能。</p></div></div>    
</body>
</html>