<html>
<head>
<title>Unique Id generation in distributed systems</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">分布式系统中唯一 Id 的生成</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/unique-id-generation-in-distributed-systems-6f7aaa39c9af?source=collection_archive---------0-----------------------#2021-05-25">https://medium.com/nerd-for-tech/unique-id-generation-in-distributed-systems-6f7aaa39c9af?source=collection_archive---------0-----------------------#2021-05-25</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/2ba415f134f49497eff6118bc36fc5fe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5_2iwfg36N37yh_dkaOMnQ.png"/></div></div></figure><p id="b89e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">最近在工作中，我们一直在寻找一种方法来生成跨分布式系统的惟一 id，该 id 还可以用作 MySQL 表中的主键。</p><p id="9d5d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们知道，在单个 MySQL 数据库中，我们可以简单地使用一个自动递增的 ID 作为主键，但这在分片的 MySQL 数据库中不起作用。</p><p id="c500" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">因此，我查看了各种现有的解决方案，最终了解到了<a class="ae jo" href="https://blog.twitter.com/engineering/en_us/a/2010/announcing-snowflake.html" rel="noopener ugc nofollow" target="_blank"> Twitter 雪花</a>——一个简单的 64 位唯一 ID 生成器。</p><h1 id="f47d" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">你为什么不用 UUID？🤔</h1><p id="7cbd" class="pw-post-body-paragraph iq ir hi is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hb bi translated">UUIDs 是全球唯一的 128 位十六进制数字。同一个 UUID 产生两次的可能性微乎其微。</p><p id="5142" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">UUIDs 的问题是它们的尺寸非常大，而且索引不好。当数据集增加时，索引大小也会增加，查询性能会降低。</p><p id="8d43" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">UUIDs 的另一个问题与用户体验有关。最终，我们的用户将需要唯一的标识符。假设一个客户打电话给客户服务，被要求提供标识符。拼写一个完整的 UUID 不是一件愉快的经历。</p><h1 id="0a94" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">推特雪花❄</h1><p id="dc97" class="pw-post-body-paragraph iq ir hi is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hb bi translated">Twitter snowflake 是一个专用服务，用于为 Twitter 中的对象(如 Tweets、直接消息、列表等)生成分布式计算中使用的 64 位唯一标识符。</p><p id="5086" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这些 id 是唯一的 64 位无符号整数，基于时间。完整的 IDs 由以下组件组成:</p><ul class=""><li id="30dc" class="ks kt hi is b it iu ix iy jb ku jf kv jj kw jn kx ky kz la bi translated">以毫秒为单位的纪元时间戳— 41 位(相对于任何自定义的纪元，我们得到 69 年)</li><li id="e88d" class="ks kt hi is b it lb ix lc jb ld jf le jj lf jn kx ky kz la bi translated">已配置的机器/节点/碎片 Id — 10 位(总共最多可提供 1024 个 2^10 id)</li><li id="bf3a" class="ks kt hi is b it lb ix lc jb ld jf le jj lf jn kx ky kz la bi translated">序列号— 12 位(每台机器的本地计数器，每 4096 个值后设置为零)</li><li id="dd49" class="ks kt hi is b it lb ix lc jb ld jf le jj lf jn kx ky kz la bi translated">在开始时额外保留的 1 位被设置为 0，以使总数为正。</li></ul><figure class="lh li lj lk fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lg"><img src="../Images/61ced2de80ccad83396d388ab41c7c0e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*DXMxmLT0nP5b7n4p"/></div></div></figure><p id="57d7" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">由于这些使用时间戳作为第一部分，因此，<strong class="is hj">它们也是时间可排序的</strong>。另一个好处是其<strong class="is hj">高可用性</strong>。</p><p id="d98c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">默认情况下，64 位无符号整数(long)将生成长度为 19 的 Id，但有时它可能太长，我们的用例需要长度不大于 10 的 Id。</p><p id="f6aa" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">本文将分享惟一 ID 生成器的一个简化版本，它将基于 Twitter 雪花服务中概述的概念，适用于在分布式环境中生成惟一 ID 的任何用例。</p><h1 id="32b5" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">编码时间⌚</h1><p id="1719" class="pw-post-body-paragraph iq ir hi is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hb bi translated">在我们的例子中，完整的 ID 将由 20 位时间戳、5 位工人号和 6 位序列号组成。</p><p id="0eda" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">剩余的 1 位是带符号位，它总是设置为 0，以使最终值为正。</p><p id="adb3" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们的微服务可以使用这个随机数生成器独立生成 id。这是有效的，并且适合于<code class="du ll lm ln lo b">int</code>的大小(4 字节或 32 位)。</p><p id="758f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">下面是完整的 Java 代码(<a class="ae jo" href="https://github.com/twitter/snowflake/tree/snowflake-2010" rel="noopener ugc nofollow" target="_blank"> <em class="lp">受 Twitter 雪花</em> </a> <em class="lp">，</em> <a class="ae jo" href="https://github.com/callicoder/java-snowflake" rel="noopener ugc nofollow" target="_blank"> <em class="lp">代码演职员表</em></a>)—</p><p id="71bd" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">步骤 1 —我们初始化每个组件需要的位数</strong>:</p><pre class="lh li lj lk fd lq lo lr ls aw lt bi"><span id="2257" class="lu jq hi lo b fi lv lw l lx ly">public class Snowflake {<br/><br/>    // Sign bit, Unused (always set to 0)<br/>    private static final int UNUSED_BITS = 1; <br/><br/>    private static final int EPOCH_BITS = 20;<br/>    private static final int NODE_ID_BITS = 5;<br/>    private static final int SEQUENCE_BITS = 6;<br/><br/>    private static final int maxNodeId = (int)(Math.pow(2, NODE_ID_BITS) - 1);<br/>    private static final int maxSequence = (int)(Math.pow(2, SEQUENCE_BITS) - 1);<br/><br/>    // Custom Epoch (Fri, 21 May 2021 03:00:20 GMT)<br/>    private static final int DEFAULT_CUSTOM_EPOCH = 1621566020;<br/><br/>    private volatile int lastTimestamp = -1;<br/>    private volatile int sequence = 0;<br/><br/>    // Class Constructor<br/>    public Snowflake() {<br/>        this.nodeId = createNodeId();<br/>        this.customEpoch = DEFAULT_CUSTOM_EPOCH;<br/>    }</span></pre><blockquote class="lz ma mb"><p id="df7c" class="iq ir lp is b it iu iv iw ix iy iz ja mc jc jd je md jg jh ji me jk jl jm jn hb bi translated"><em class="hi">在这里，我们采用的是 Fri 时间，即 2021 年 5 月 21 日 03:00:20 GMT。</em></p></blockquote><p id="e549" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><code class="du ll lm ln lo b">EPOCH_BITS</code>将是 20 位，并填充以秒为单位的当前时间戳(如果每秒可能有多个请求，也可以使用毫秒)。</p><p id="c277" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><code class="du ll lm ln lo b">NODE_ID_BITS</code>为 5 位，使用 Mac 地址填充。</p><p id="e6cc" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><code class="du ll lm ln lo b">SEQUENCE_BITS</code>为 6 位，将作为本地计数器，从 0 开始，一直到 63，然后重置回 0。</p><p id="7eab" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">第二步—创建一个</strong> <code class="du ll lm ln lo b"><strong class="is hj">synchronized</strong></code> <strong class="is hj">函数来生成 id</strong>:</p><pre class="lh li lj lk fd lq lo lr ls aw lt bi"><span id="32aa" class="lu jq hi lo b fi lv lw l lx ly">public synchronized int nextId() {<br/>    int currentTimestamp = (int) (Instant.now().getEpochSecond() -    customEpoch);<br/><br/>    if(currentTimestamp &lt; lastTimestamp) {<br/>      throw new IllegalStateException("Invalid System Clock!");<br/>    }<br/><br/>    lastTimestamp = currentTimestamp;<br/><br/>    return currentTimestamp &lt;&lt; (NODE_ID_BITS + SEQUENCE_BITS) | (nodeId &lt;&lt; SEQUENCE_BITS) | sequence++;</span><span id="86d2" class="lu jq hi lo b fi mf lw l lx ly">}</span></pre><h2 id="5529" class="lu jq hi bd jr mg mh mi jv mj mk ml jz jb mm mn kd jf mo mp kh jj mq mr kl ms bi translated">等等，我们为什么要做这些<code class="du ll lm ln lo b">Left Shifts</code> &amp; <code class="du ll lm ln lo b">Logical OR</code>的操作？</h2><p id="1cac" class="pw-post-body-paragraph iq ir hi is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hb bi translated">这是因为整数由 32 位表示，并且最初都被设置为 0。为了填充这些位，我们必须分别获取每个分量，因此首先我们获取纪元时间戳，并将其移动到 5 + 6，即向左移动 11 位。这样做已经用第一个分量填充了前 21 位(记住第一位总是被设置为零以使总数为正)。剩余的 11 位仍然是 0，因此我们再次用逻辑或&amp;另外两个部分重复同样的事情，从而填充所有的 32 位并形成完整的数。</p><p id="0115" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">步骤 3 —使用系统的 MAC 地址生成节点 id 的实用函数</strong>:</p><pre class="lh li lj lk fd lq lo lr ls aw lt bi"><span id="9011" class="lu jq hi lo b fi lv lw l lx ly">private int createNodeId() {<br/>    int nodeId;<br/>    try {<br/>            StringBuilder sb = new StringBuilder();<br/>            Enumeration&lt;NetworkInterface&gt; networkInterfaces = NetworkInterface.getNetworkInterfaces();<br/>     <br/>       while (networkInterfaces.hasMoreElements()) {<br/>                NetworkInterface networkInterface = networkInterfaces.nextElement();</span><span id="d355" class="lu jq hi lo b fi mf lw l lx ly">                byte[] mac = networkInterface.getHardwareAddress();<br/>                if (Objects.nonNull(mac))<br/>                    for(byte macPort: mac)<br/>                        sb.append(String.format("%02X", macPort));<br/>            }<br/>            nodeId = sb.toString().hashCode();<br/>        } catch (Exception ex) {<br/>            nodeId = (new SecureRandom().nextInt());<br/>        }<br/>        nodeId = nodeId &amp; maxNodeId;<br/>        return nodeId;<br/>    }<br/>}</span></pre><h1 id="a189" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">它是如何工作的？💡</h1><p id="ca80" class="pw-post-body-paragraph iq ir hi is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hb bi translated">现在让我们通过一个例子来理解它的工作原理</p><p id="9f14" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">假设现在是 2021 年 5 月 23 日星期日 00:00:00 GMT。这个特定时间的纪元时间戳是 1621728000。</p><p id="3a38" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">首先，我们根据自定义纪元调整我们的时间戳-</p><p id="678b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">current timestamp = 1621728000-1621566020 = 161980(根据自定义纪元进行调整)</p><p id="7689" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">因此，为了开始我们的 ID，ID 的前 20 位(在带符号的位之后)将用纪元时间戳填充。让我们将这个值左移:</p><p id="9739" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><code class="du ll lm ln lo b">id = currentTimestamp &lt;&lt; (NODE_ID_BITS + SEQUENCE_BITS )</code></p><p id="168f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">接下来，我们获取已配置的节点 ID/碎片 ID，并用它填充接下来的 10 位</p><p id="29ba" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><code class="du ll lm ln lo b">id = id | nodeId &lt;&lt; SEQUENCE_BITS</code></p><p id="bb30" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">最后，我们取自动递增序列的下一个值，并填写剩余的 6 位</p><p id="7de0" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><code class="du ll lm ln lo b">id = id | sequence // 6149376</code></p><p id="fca7" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这给了我们最后的身份🎉</p><p id="ca42" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">就是这样！在我们的应用程序中唯一的主键！</p><h1 id="8c03" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">摘要📊</h1><p id="2323" class="pw-post-body-paragraph iq ir hi is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hb bi translated">本文向您展示了如何生成长度&gt; =7 和&lt;=10.</p><p id="0dee" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">By the way, you can adjust the bit count of the 3 components to adapt to your work.</p><blockquote class="lz ma mb"><p id="1863" class="iq ir lp is b it iu iv iw ix iy iz ja mc jc jd je md jg jh ji me jk jl jm jn hb bi translated"><em class="hi">的雪花 id 的简单解决方案。注意:我们应该将生成器保持为单例，这意味着我们应该只为每个节点创建 SequenceGenerator 的单个实例。否则，它可能会生成一些重复的 id。</em></p></blockquote><p id="fa8d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">不仅推特使用了它，<strong class="is hj"> Discord </strong>也使用了雪花，它们的纪元设定为 2015 年的第一秒。</p><p id="feb9" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj"> Instagram </strong>使用了该格式的修改版本，41 位为时间戳，13 位为碎片 ID，10 位为序列号。</p><p id="1568" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">希望这对你有帮助！感谢阅读:)</p></div><div class="ab cl mt mu gp mv" role="separator"><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my"/></div><div class="hb hc hd he hf"><h1 id="10c9" class="jp jq hi bd jr js na ju jv jw nb jy jz ka nc kc kd ke nd kg kh ki ne kk kl km bi translated"><strong class="ak">从 Web 开发开始？</strong></h1><p id="ee6d" class="pw-post-body-paragraph iq ir hi is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hb bi translated">查看<a class="ae jo" href="https://gumroad.com/a/316675187" rel="noopener ugc nofollow" target="_blank"> <strong class="is hj"> HTML 反应:终极指南</strong> </a></p><p id="98e8" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这本电子书是一个全面的学习指南，通过大量易于理解的例子和经过验证的路线图，它将教你<strong class="is hj">成为一个自信的 web 开发者所需要知道的一切</strong></p><p id="1429" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">有了这个链接，就可以打<strong class="is hj">六折。</strong></p><figure class="lh li lj lk fd ij er es paragraph-image"><a href="https://gumroad.com/a/316675187"><div class="er es nf"><img src="../Images/198b6c32d194de7f3738a144ee9e8650.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ggbWpRH6k48HHshG0sli6A.png"/></div></a><figcaption class="ng nh et er es ni nj bd b be z dx translated">HTML 反应:完整的网络开发电子书</figcaption></figure></div><div class="ab cl mt mu gp mv" role="separator"><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my"/></div><div class="hb hc hd he hf"><p id="ec70" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><em class="lp">(原载于</em><a class="ae jo" href="https://apoorvtyagi.tech/generating-unique-ids-in-a-large-scale-distributed-environment" rel="noopener ugc nofollow" target="_blank"><em class="lp">apoorvtyagi . tech</em></a><em class="lp">)</em></p></div></div>    
</body>
</html>