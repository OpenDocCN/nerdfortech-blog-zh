<html>
<head>
<title>Destructuring with JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用 JavaScript 进行析构</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/destructuring-with-javascript-es6-a194d458da4a?source=collection_archive---------12-----------------------#2021-03-24">https://medium.com/nerd-for-tech/destructuring-with-javascript-es6-a194d458da4a?source=collection_archive---------12-----------------------#2021-03-24</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/e84e990cafc54888a27393ff6ee5d570.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RDA9cW9e454EhCjzqPsaJQ.jpeg"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">图片由<a class="ae iu" href="https://unsplash.com/@lastnameeaster" rel="noopener ugc nofollow" target="_blank"> La-Rel 复活节</a>途经【unsplash.com】T2</figcaption></figure><p id="2609" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">编码者喜欢他们的代码是干巴巴的(不要重复你自己)，部分原因是因为我们懒惰，这是一种好的方式，但也因为这使我们的代码更容易阅读。谁知道谁会在你之后从事某个项目，或者你要过多久才能回到自己的项目中来？不管什么时候，什么人，重要的是代码要清晰、简洁、易于准备。</p><p id="6a84" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我给你举两个例子，让你决定哪个更好看。如果您是析构的新手，现在请相信我的话，这两个代码块实现了相同的目标，我们将很快深入细节。</p><pre class="jt ju jv jw fd jx jy jz ka aw kb bi"><span id="7915" class="kc kd hi jy b fi ke kf l kg kh">First Example</span><span id="c32d" class="kc kd hi jy b fi ki kf l kg kh">1. let team = {<br/>2.   name: "Kansas City Chiefs",<br/>3.   superbowls: 2,<br/>4.   mvp: "Patrick Mahomes"<br/>5. }</span><span id="d0e0" class="kc kd hi jy b fi ki kf l kg kh">6. let name = team.name<br/>7. let superbowls = team.superbowls<br/>8. let mvp = team.mvp</span><span id="dd69" class="kc kd hi jy b fi ki kf l kg kh">9.  console.log(name) =&gt; "Kansas City Chiefs"<br/>10. console.log(superbowls) =&gt; 2<br/>11. console.log(mvp) =&gt; "Patrick Mahomes"</span></pre><p id="bb31" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">现在是第二个问题。</p><pre class="jt ju jv jw fd jx jy jz ka aw kb bi"><span id="c5b3" class="kc kd hi jy b fi ke kf l kg kh">Second Example</span><span id="71dd" class="kc kd hi jy b fi ki kf l kg kh">1. let team = {<br/>2.   name: "Kansas City Chiefs",<br/>3.   superbowls: 2,<br/>4.   mvp: "Patrick Mahomes"<br/>5. }</span><span id="5667" class="kc kd hi jy b fi ki kf l kg kh">6. let {name, superbowls, mvp} = team</span><span id="ee86" class="kc kd hi jy b fi ki kf l kg kh">7. console.log(name) =&gt; "Kansas City Chiefs"<br/>8. console.log(superbowls) =&gt; 2<br/>9. console.log(mvp) =&gt; "Patrick Mahomes"</span></pre><p id="4598" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">你更喜欢读哪一本？好吧，这是一个有内涵的问题，第二个更简洁，假设你理解析构更快阅读，同时仍然达到相同的目标。</p><p id="1ab4" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这里到底发生了什么？在第二个例子中，我们从团队对象中创建一个名称、superbowls 和 mvp 变量，该变量等于具有匹配名称的键值。我们<em class="kj">将</em>对象解构为多个变量！</p></div><div class="ab cl kk kl gp km" role="separator"><span class="kn bw bk ko kp kq"/><span class="kn bw bk ko kp kq"/><span class="kn bw bk ko kp"/></div><div class="hb hc hd he hf"><p id="4d38" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">析构是在<a class="ae iu" href="https://262.ecma-international.org/6.0/#sec-destructuring-assignment" rel="noopener ugc nofollow" target="_blank"> ECMAScript 2015 </a>中引入的，通常被称为 ES6，对对象和数组都有效。本质上，它允许您将对象或数组中的属性或值赋给变量，而不必通过使用析构赋值来逐行写出每个变量赋值。</p><p id="f7bb" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">析构赋值应该看起来很熟悉，因为它非常类似于数组和对象文字表达式，只是它是从赋值操作符的右边翻转到左边的。</p><figure class="jt ju jv jw fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es kr"><img src="../Images/74208c91a6c98dfd7b2e0a74eb47b3f8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*D_n_eSME_5LSfSElkqMKaw.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">数组/对象文字表达式与析构赋值</figcaption></figure></div><div class="ab cl kk kl gp km" role="separator"><span class="kn bw bk ko kp kq"/><span class="kn bw bk ko kp kq"/><span class="kn bw bk ko kp"/></div><div class="hb hc hd he hf"><figure class="jt ju jv jw fd ij"><div class="bz dy l di"><div class="ks kt l"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">via<a class="ae iu" href="https://giphy.com/gifs/cbc-schittscreek-schitts-creek-fjxbR0y8fscok9UgiM" rel="noopener ugc nofollow" target="_blank">giphy.com</a></figcaption></figure><p id="e52d" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">现在我们知道了什么是析构，我想和你分享一下我是如何经常使用它的。我对 JavaScript 和 React 世界相对较新，但根据我的经验，我发现最有用的应用是在 React 中使用<em class="kj">功能组件</em>时。</p><p id="3793" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">您可以在参数中使用对象析构，并在函数中直接引用每个属性，而不是传递一个属性参数并使用点符号来深入每个属性。在编写代码时，这是一个很小的效率增益，但是我只关注小的，<em class="kj">增量改进</em>随着时间的推移累积起来！</p><p id="65de" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">让我们快速对比一下每种方法。我们将假设我们正在向每个函数传递道具<code class="du ku kv kw jy b">wave</code>和<code class="du ku kv kw jy b">sayHello</code>，并且每个道具分别有一个键<code class="du ku kv kw jy b">hand</code>和<code class="du ku kv kw jy b">greet</code>。</p><pre class="jt ju jv jw fd jx jy jz ka aw kb bi"><span id="07bb" class="kc kd hi jy b fi ke kf l kg kh">Functional Component Comparison</span><span id="11a8" class="kc kd hi jy b fi ki kf l kg kh">// Without Destructuring</span><span id="daac" class="kc kd hi jy b fi ki kf l kg kh">1. const withProps = (props) =&gt; {<br/>2.    return (<br/>3.       &lt;div&gt;<br/>4.          {props.wave.hand}<br/>5.          {props.sayHello.greet}<br/>6.       &lt;/div&gt;<br/>7.    )<br/>6. }</span><span id="627a" class="kc kd hi jy b fi ki kf l kg kh">// With Destructuring</span><span id="31e5" class="kc kd hi jy b fi ki kf l kg kh">1. const withDestructuring = ({wave, sayHello}) =&gt; {<br/>2.    return (<br/>3.       &lt;div&gt;<br/>4.          {wave.hand}<br/>5.          {sayHello.greet}<br/>6.       &lt;/div&gt;<br/>7.    )<br/>6. }</span></pre><p id="d87f" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">就像我说的，当只写两行的时候没有很大的区别，但是想象一下有五个或者十个你多次引用的道具，这就增加了。还要注意的是，在使用析构的时候，我们知道在处理<code class="du ku kv kw jy b">withDestructuring</code>的时候哪些道具是可用的。如果您是项目的新手，您可以通过快速浏览可用的道具来了解组件的意图，而不必在文件之间来回跳转。</p></div><div class="ab cl kk kl gp km" role="separator"><span class="kn bw bk ko kp kq"/><span class="kn bw bk ko kp kq"/><span class="kn bw bk ko kp"/></div><div class="hb hc hd he hf"><p id="a303" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">析构可以用在很多不同的方面，包括解构数组。其机制类似于我们用对象演示的，但是我们没有使用键作为变量名，而是创建了一个变量名。析构数组时要注意的一点是顺序很重要！让我们看一个例子。</p><pre class="jt ju jv jw fd jx jy jz ka aw kb bi"><span id="42bf" class="kc kd hi jy b fi ke kf l kg kh">1. let animals = ['dog', 'cat', 'fish']</span><span id="fd97" class="kc kd hi jy b fi ki kf l kg kh">2. let [stella, whiskers, nemo] = animals</span><span id="3452" class="kc kd hi jy b fi ki kf l kg kh">3. console.log(stella) =&gt; 'dog'<br/>4. console.log(whiskers) =&gt; 'cat'<br/>5. console.log(nemo) =&gt; 'fish'</span></pre><p id="4c5d" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这里我们按照动物指数的顺序给每个变量赋值，这就是顺序很重要的原因。这也允许我们做一些很酷的事情，比如在析构数组时跳过值，如下所示。</p><pre class="jt ju jv jw fd jx jy jz ka aw kb bi"><span id="c533" class="kc kd hi jy b fi ke kf l kg kh">1. let animals = ['dog', 'cat', 'fish']</span><span id="3278" class="kc kd hi jy b fi ki kf l kg kh">2. let [stella, , nemo] = animals</span><span id="56a9" class="kc kd hi jy b fi ki kf l kg kh">3. console.log(stella) =&gt; 'dog'<br/>4. console.log(nemo) =&gt; 'fish'</span></pre><p id="d34d" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">析构数组时要小心。因为<strong class="ix hj">数组的顺序和长度很重要</strong>，所以准确知道里面存储了什么非常关键。这将它的实际应用限制在阵列被控制并且每次都相同的情况下。</p><p id="ad26" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">还有很多其他很酷的析构应用，所以我强烈推荐你去看看关于这个问题的 MDNs 页面。像往常一样，请在下面的评论中留下一些反馈或其他你认为有用的实例！</p></div></div>    
</body>
</html>