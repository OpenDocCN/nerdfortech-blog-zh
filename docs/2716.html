<html>
<head>
<title>Basics of AutoFac How to implement it in ASP.NET application</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">AutoFac 基础知识如何在 ASP.NET 应用程序中实现它</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/basics-of-autofac-how-to-implement-it-in-asp-net-application-eee4d76412fa?source=collection_archive---------15-----------------------#2021-05-17">https://medium.com/nerd-for-tech/basics-of-autofac-how-to-implement-it-in-asp-net-application-eee4d76412fa?source=collection_archive---------15-----------------------#2021-05-17</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/c745fdcdf2e4b9ade74fcbeb7a8d05cd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ngSjrmtNmmbtDx4PqdMmGA.png"/></div></div></figure><p id="01b8" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如果您过去使用过依赖注入，您一定知道为什么它非常有用。依赖注入提供了松散耦合，有助于维护和测试应用程序。</p><p id="c097" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">依赖注入和 IoC 概念构成了大多数面向对象应用程序的核心。</p><p id="6e00" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">IoC 是一个通用术语，表示控制流是这样的:框架调用应用程序提供的实现，而不是调用框架中的方法。</p><p id="4e31" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">依赖注入为开发人员提供了对应用程序的巨大控制权，赋予了他们一些最好的特性，比如配置和类的独立性。这种依赖注入是由 ASP.NET 核心的阿迪容器提供的。它是预构建的，不需要额外安装。</p><p id="dbd8" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">但是第三方 DI 容器可以提供更多的功能。这就是开发人员在大规模应用程序中采用第三方 DI 容器而不是预建容器的主要原因。AutoFac 是一个强大的第三方 DI 容器，在 ASP.NET 核心开发人员中广泛使用。让我们更深入地了解什么是 Autofac 以及它为什么有用。</p><p id="871b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">目录</strong></p><ul class=""><li id="354f" class="jo jp hi is b it iu ix iy jb jq jf jr jj js jn jt ju jv jw bi translated">一些背景</li><li id="a290" class="jo jp hi is b it jx ix jy jb jz jf ka jj kb jn jt ju jv jw bi translated">什么是 Autofac？</li><li id="6f1d" class="jo jp hi is b it jx ix jy jb jz jf ka jj kb jn jt ju jv jw bi translated">Autofac 优于内置 DI 容器的优势</li><li id="4d9a" class="jo jp hi is b it jx ix jy jb jz jf ka jj kb jn jt ju jv jw bi translated">Autofac 的实际实现</li><li id="28a5" class="jo jp hi is b it jx ix jy jb jz jf ka jj kb jn jt ju jv jw bi translated">结论</li></ul><h1 id="faf1" class="kc kd hi bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated">背景</h1><p id="942b" class="pw-post-body-paragraph iq ir hi is b it la iv iw ix lb iz ja jb lc jd je jf ld jh ji jj le jl jm jn hb bi translated">依赖注入是 IoC(控制反转)的一种形式，在这种形式中，实现通过应用程序赖以正确运行的构造函数或设置函数来传递。</p><p id="e0b3" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">换句话说，它是一种编程技术，允许类独立于它们的依赖关系。这使得开发人员可以很好地控制多个类。这种依赖注入是由预构建的 DI 容器或第三方 DI 容器提供的。但是当涉及到开发企业级应用程序时，开发人员总是寻求第三方 DI 容器的帮助，比如 AutoFac。</p><h1 id="6b19" class="kc kd hi bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated">什么是 AutoFac？</h1><p id="6637" class="pw-post-body-paragraph iq ir hi is b it la iv iw ix lb iz ja jb lc jd je jf ld jh ji jj le jl jm jn hb bi translated">AutoFac 是一个反转的控制容器，用于解析应用程序的依赖关系。这意味着它也是一个依赖注入框架。</p><p id="af3d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如果您在面向对象的世界中不熟悉这种思想，这是一种注入其他类所依赖的依赖项的方法，通常在构造函数中。Autofac 被誉为 ASP.NET 社区中使用最广泛的框架。它是开发者中下载量最大的软件包之一。AutoFac 为 ASP.NET MVC 框架提供了更好的集成，并且是使用 Google 代码开发的。</p><p id="4e53" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">AutoFac 管理类的依赖关系，这样当应用程序的规模和复杂性增加时，它可以很容易地改变。让我们来看看为什么内置的 DI 容器被 AutoFac 所取代。</p><h1 id="f12f" class="kc kd hi bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated">AutoFac 优于内置 DI 容器的优势</h1><ol class=""><li id="8d45" class="jo jp hi is b it la ix lb jb lf jf lg jj lh jn li ju jv jw bi translated">ASP.NET DI 容器对验证配置没有帮助，很难发现常见错误配置引起的问题。在大规模应用程序中，自己很难发现错误配置。</li><li id="1dc2" class="jo jp hi is b it jx ix jy jb jz jf ka jj kb jn li ju jv jw bi translated">ASP.NET DI 容器只提供了一个构造函数注入。</li><li id="4648" class="jo jp hi is b it jx ix jy jb jz jf ka jj kb jn li ju jv jw bi translated">使用 AutoFac，可以访问内置 IoC 容器所没有的新特性，比如属性注入。</li><li id="8a96" class="jo jp hi is b it jx ix jy jb jz jf ka jj kb jn li ju jv jw bi translated">内置容器非常轻，是基本应用程序的默认容器。用户可以很容易地切换到第三方 IoC 容器，如 AutoFac 或 structuremap。</li><li id="d6b7" class="jo jp hi is b it jx ix jy jb jz jf ka jj kb jn li ju jv jw bi translated">AutoFac 支持各种各样的应用设计，只需最少的额外基础设施和集成代码，学习曲线更短。</li><li id="b2ae" class="jo jp hi is b it jx ix jy jb jz jf ka jj kb jn li ju jv jw bi translated">实现像 AutoFac 这样的第三方 IoC 容器可以产生可重用的代码、可读性更好的代码和易于测试的代码，集中了依赖关系管理的逻辑。</li><li id="93f6" class="jo jp hi is b it jx ix jy jb jz jf ka jj kb jn li ju jv jw bi translated">Autofac 涵盖了 IoC 容器提供的所有特性，以及其他一些细微的特性，这些特性有助于应用程序配置、管理组件的生命周期以及管理您所关注的多个依赖项。</li></ol><h1 id="816a" class="kc kd hi bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated">AutoFac 的实际实现</h1><p id="cdf4" class="pw-post-body-paragraph iq ir hi is b it la iv iw ix lb iz ja jb lc jd je jf ld jh ji jj le jl jm jn hb bi translated">正如我们在这个博客中不断强调的，为了释放依赖注入的全部好处，使用第三方 DI 容器总是比内置的 DI 容器更好。从管理运行时依赖到开源，Autofac 是在 ASP.NET 工作的开发人员不可或缺的资源。</p><p id="488c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在让我们使用 AutoFac 执行一个简单的依赖注入。</p><h2 id="4b38" class="lj kd hi bd ke lk ll lm ki ln lo lp km jb lq lr kq jf ls lt ku jj lu lv ky lw bi translated">第一步</h2><p id="e5ab" class="pw-post-body-paragraph iq ir hi is b it la iv iw ix lb iz ja jb lc jd je jf ld jh ji jj le jl jm jn hb bi translated">打开 Visual Studio 并创建一个新项目。选择控制台应用程序(。NET Core)从指定的运行时环境列表中删除。控制台应用程序用于创建可以在上运行的命令行界面。网芯。您还可以自由选择构建项目所基于的 web 应用程序。</p><figure class="ly lz ma mb fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lx"><img src="../Images/315c57437f53637e4f6301a2c696a646.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*xav7OYCeAfpZ_KRw"/></div></div></figure><h2 id="c0c9" class="lj kd hi bd ke lk ll lm ki ln lo lp km jb lq lr kq jf ls lt ku jj lu lv ky lw bi translated">第二步</h2><p id="e7ed" class="pw-post-body-paragraph iq ir hi is b it la iv iw ix lb iz ja jb lc jd je jf ld jh ji jj le jl jm jn hb bi translated">下一步是配置您的项目。指定项目的名称以及希望项目托管的位置。继续创建。</p><h2 id="9675" class="lj kd hi bd ke lk ll lm ki ln lo lp km jb lq lr kq jf ls lt ku jj lu lv ky lw bi translated">第三步</h2><p id="2057" class="pw-post-body-paragraph iq ir hi is b it la iv iw ix lb iz ja jb lc jd je jf ld jh ji jj le jl jm jn hb bi translated">Visual Studio 现在自动创建默认的 Hello world 程序，这是一个控制台应用程序。</p><p id="4949" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在开始我们的任务之前，有必要添加第三方 DI 容器扩展。转到项目右上角的“解决方案资源管理器”选项卡。右键单击依赖项并选择管理 NuGet 包。现在通过搜索软件包栏来安装 AutoFac 软件包。</p><figure class="ly lz ma mb fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lx"><img src="../Images/45e6093083e4bac627907a695fb94294.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*j9dGUJlgjYzPqEss"/></div></div></figure><h2 id="ea85" class="lj kd hi bd ke lk ll lm ki ln lo lp km jb lq lr kq jf ls lt ku jj lu lv ky lw bi translated">第四步</h2><p id="ae0f" class="pw-post-body-paragraph iq ir hi is b it la iv iw ix lb iz ja jb lc jd je jf ld jh ji jj le jl jm jn hb bi translated">现在 AutoFac 已经安装好了，让我们使用 AutoFac 实现依赖注入。下面是一个简单的控制台应用程序，涉及到使用 AutoFac 实现依赖注入。</p><pre class="ly lz ma mb fd mc md me mf aw mg bi"><span id="e0c8" class="lj kd hi md b fi mh mi l mj mk">using System; using System.Collections.Generic; using System.Linq; using System.Text; using Autofac; public interface IMobileServive { void Execute(); } public class SMSService : IMobileServive { public void Execute() { Console.WriteLine("Partech SMS service executing."); } } public interface IMailService { void Execute(); } public class EmailService : IMailService { public void Execute() { ​ Console.WriteLine("Partech Email service Executing."); } } public class NotificationSender { public IMobileServive _mobileSerivce = null; public IMailService _mailService = null; //injection through constructor public NotificationSender(IMobileServive tmpService) { ​ _mobileSerivce = tmpService; } //Injection through property public IMailService SetMailService { ​ set { _mailService = value; } } public void SendNotification() { ​ _mobileSerivce.Execute(); ​ _mailService.Execute(); } } namespace Client { class Program { ​ static void Main(string[] args) ​ { ​ var builder = new ContainerBuilder(); ​ builder.RegisterType&lt;SMSService&gt;().As&lt;IMobileServive&gt;(); ​ builder.RegisterType&lt;EmailService&gt;().As&lt;IMailService&gt;(); ​ var container = builder.Build(); ​ container.Resolve&lt;IMobileServive&gt;().Execute(); ​ container.Resolve&lt;IMailService&gt;().Execute(); ​ Console.ReadLine(); ​ } } }</span></pre><p id="da69" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这里我们实现了两个接口类和它们对应的具体类。</p><p id="fdfe" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">然后，我们实现了一个依赖于 mailService 和 mobileService 的通知发送者类。我们通过构造函数注入了两个类的依赖关系。查看 Main()函数，查看依赖类型的存储库并构建存储库。</p><p id="953c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这是代码的输出-</p><figure class="ly lz ma mb fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lx"><img src="../Images/ccc73d168553104decaea8178b507f3d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*uHQWjkf0IqbfNtmD"/></div></div></figure><h1 id="4540" class="kc kd hi bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated">结论</h1><p id="5f7f" class="pw-post-body-paragraph iq ir hi is b it la iv iw ix lb iz ja jb lc jd je jf ld jh ji jj le jl jm jn hb bi translated">为了使类独立于它们的依赖，使用依赖注入是明智的。它使您能够在不中断类组件或主代码的情况下替换或更改依赖项。所以对于小规模的应用，可以使用内置的 DI 容器。但是当涉及到大规模远程应用程序时，Autofac 是不二之选，因为它提供了 ASP.NET 的内置 DI 容器所缺乏的大量特性。</p></div><div class="ab cl ml mm gp mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="hb hc hd he hf"><p id="3167" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><em class="ms">原载于</em><a class="ae mt" href="https://www.partech.nl/nl/publicaties/2021/05/basics-of-autofac-how-to-implement-it-in-asp-net-application" rel="noopener ugc nofollow" target="_blank"><em class="ms">https://www . partech . nl</em></a><em class="ms">。</em></p></div></div>    
</body>
</html>