<html>
<head>
<title>Background Work in Xamarin.Forms. Part #1 — Xamarin.Android</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Xamarin.Forms中的背景工作。第1部分— Xamarin。机器人</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/background-work-in-xamarin-forms-part-1-xamarin-android-63f629e73f9?source=collection_archive---------0-----------------------#2022-04-19">https://medium.com/nerd-for-tech/background-work-in-xamarin-forms-part-1-xamarin-android-63f629e73f9?source=collection_archive---------0-----------------------#2022-04-19</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><figure class="hh hi ez fb hj hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es hg"><img src="../Images/0920a88289fbe6d0b6c5c8e7653e9c30.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*q8Povu5wCB8fDFs6oXGDIA.jpeg"/></div></div></figure><div class=""/><div class=""><h2 id="dd77" class="pw-subtitle-paragraph iq hs ht bd b ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh dx translated">如果我们需要在后台运行一些工作，我们应该选择什么？它应该是一个工人，服务或简单的任务运行。网？让我们来了解一下！</h2></div><figure class="jj jk jl jm fd hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es ji"><img src="../Images/e0387f35b2659db5da418d10e81ad4d0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Zz-o3q8lmfDjccE0ai9k4Q.png"/></div></div><figcaption class="jn jo et er es jp jq bd b be z dx translated">光荣属于乌克兰！荣耀归于英雄</figcaption></figure><p id="4265" class="pw-post-body-paragraph jr js ht jt b ju jv iu jw jx jy ix jz ka kb kc kd ke kf kg kh ki kj kk kl km hb bi translated">大家好👋！！！有时，我们的移动应用程序必须做一些工作，而不是在UI线程中，一些长或短的工作，定期或一次性的工作，我们需要确保它不会被暂停或当应用程序终止时它可以完成。Android和iOS系统为所有这些工作提供了完全不同的方式，这取决于我们希望在后台工作期间分配什么资源。在本文中，我们将只关注Android。对于iOS，我们将回到本文的第二部分，这将很快发表。</p><p id="526e" class="pw-post-body-paragraph jr js ht jt b ju jv iu jw jx jy ix jz ka kb kc kd ke kf kg kh ki kj kk kl km hb bi translated">在本文中，我们将看看并比较在后台运行工作的下一种方法，我们将尝试面对每种方法的优缺点:</p><ul class=""><li id="3454" class="kn ko ht jt b ju jv jx jy ka kp ke kq ki kr km ks kt ku kv bi translated">任务。跑--。Net在后台线程中运行工作的本机方式</li><li id="9cae" class="kn ko ht jt b ju kw jx kx ka ky ke kz ki la km ks kt ku kv bi translated">worker——在原生Android应用中持续工作的推荐解决方案</li><li id="c9b3" class="kn ko ht jt b ju kw jx kx ka ky ke kz ki la km ks kt ku kv bi translated">服务——一个可以在后台执行长时间运行操作的<a class="ae lb" href="https://developer.android.com/guide/components/fundamentals#Components" rel="noopener ugc nofollow" target="_blank">应用组件</a></li></ul><p id="1479" class="pw-post-body-paragraph jr js ht jt b ju jv iu jw jx jy ix jz ka kb kc kd ke kf kg kh ki kj kk kl km hb bi translated">这里我们有多种选择，取决于我们工作的数量和不同程度，我们可以注册多个接口并运行多个服务/工作者。但是对于我们的例子，我们将有一个与work <code class="du lc ld le lf b">Func&lt;Task&gt;</code>的通用接口，并且我们将使用来自MvvmCross的IoC容器用于Xamarin。表单NuGet包。</p><figure class="jj jk jl jm fd hk"><div class="bz dy l di"><div class="lg lh l"/></div></figure><p id="6ec3" class="pw-post-body-paragraph jr js ht jt b ju jv iu jw jx jy ix jz ka kb kc kd ke kf kg kh ki kj kk kl km hb bi translated">在Android中，我们将在后台做什么并不重要，所以让我们假设我们的<code class="du lc ld le lf b">Task</code>将检查数据库，并尝试在我们有互联网连接的情况下推送不同步的更改。再说一次，展示这部分代码太简单了，所以想象一下，我们用所有坚实的原则以正确的方式这样做，等等。</p></div><div class="ab cl li lj gp lk" role="separator"><span class="ll bw bk lm ln lo"/><span class="ll bw bk lm ln lo"/><span class="ll bw bk lm ln"/></div><div class="hb hc hd he hf"><figure class="jj jk jl jm fd hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es lp"><img src="../Images/e48987f1d972554cc0c8d1901874b9c6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VNWPj9PR2h0dHx3P6wbsOw.png"/></div></div></figure><p id="09f9" class="pw-post-body-paragraph jr js ht jt b ju jv iu jw jx jy ix jz ka kb kc kd ke kf kg kh ki kj kk kl km hb bi translated">当应用程序关闭或终止时，ℹ️工作管理器可能会运行计划的/重复的工作，但Android系统不保证这一点🤨🧐，是的，这不是保证，实际上从来没有为我预期的工作，但我发现在StackOverflow有人工作。</p></div><div class="ab cl li lj gp lk" role="separator"><span class="ll bw bk lm ln lo"/><span class="ll bw bk lm ln lo"/><span class="ll bw bk lm ln"/></div><div class="hb hc hd he hf"><h1 id="c593" class="lq lr ht bd ls lt lu lv lw lx ly lz ma iz mb ja mc jc md jd me jf mf jg mg mh bi translated">Android后台/前台服务</h1><p id="c4ca" class="pw-post-body-paragraph jr js ht jt b ju mi iu jw jx mj ix jz ka mk kc kd ke ml kg kh ki mm kk kl km hb bi translated">在我们开始之前，让我给你一个官方文档的<a class="ae lb" href="https://developer.android.com/guide/components/services" rel="noopener ugc nofollow" target="_blank">链接</a>，我们准备好了。</p><p id="515e" class="pw-post-body-paragraph jr js ht jt b ju jv iu jw jx jy ix jz ka kb kc kd ke kf kg kh ki kj kk kl km hb bi translated">首先，让我们定义一个将启动后台服务的普通工人。是的，它可以是同一个类，也可以是两个不同的类。在我的例子中，服务将通过注册为Singleton的DI和接口连接两个不同的类。在您的代码中，这可以是从本机服务和您的全局接口继承的一个接口和一个实现；由你决定😋</p><figure class="jj jk jl jm fd hk"><div class="bz dy l di"><div class="lg lh l"/></div></figure><p id="79d6" class="pw-post-body-paragraph jr js ht jt b ju jv iu jw jx jy ix jz ka kb kc kd ke kf kg kh ki kj kk kl km hb bi translated">服务本身如果<code class="du lc ld le lf b">SDK &lt; 26</code>可以是后台，如果SDK更高可以是前台。但是每个服务都需要构建一个通知块，它将向用户显示它实际在做什么。在我的例子中，我使用AppResources RESX文件来保存所有本地化的字符串。</p><p id="7d9d" class="pw-post-body-paragraph jr js ht jt b ju jv iu jw jx jy ix jz ka kb kc kd ke kf kg kh ki kj kk kl km hb bi translated">首先，我们需要用适当的<code class="du lc ld le lf b">Activity Flag</code>(在我们的例子中是<code class="du lc ld le lf b">ActivityFlags.NoUserAction</code>)来创建和意图。然后用<code class="du lc ld le lf b">Notification Builder</code>我们需要从Android资源中设置带有图标和颜色的标题和描述文本。</p><div class="hh hi ez fb hj mn"><a href="https://docs.microsoft.com/en-us/dotnet/api/android.content.activityflags?view=xamarin-android-sdk-12" rel="noopener  ugc nofollow" target="_blank"><div class="mo ab dw"><div class="mp ab mq cl cj mr"><h2 class="bd hu fi z dy ms ea eb mt ed ef hs bi translated">ActivityFlags枚举(Android。内容)</h2><div class="mu l"><h3 class="bd b fi z dy ms ea eb mt ed ef dx translated">枚举由几种类型返回并作为几种类型的参数的值。</h3></div><div class="mv l"><p class="bd b fp z dy ms ea eb mt ed ef dx translated">docs.microsoft.com</p></div></div><div class="mw l"><div class="mx l my mz na mw nb hp mn"/></div></div></a></div><p id="2c71" class="pw-post-body-paragraph jr js ht jt b ju jv iu jw jx jy ix jz ka kb kc kd ke kf kg kh ki kj kk kl km hb bi translated">如果SDK是<code class="du lc ld le lf b">26</code>或以上，我们还需要<code class="du lc ld le lf b">Notification Channel</code>，在这里我们可以设置灯光、震动、重要性等选项。</p><figure class="jj jk jl jm fd hk"><div class="bz dy l di"><div class="lg lh l"/></div></figure></div><div class="ab cl li lj gp lk" role="separator"><span class="ll bw bk lm ln lo"/><span class="ll bw bk lm ln lo"/><span class="ll bw bk lm ln"/></div><div class="hb hc hd he hf"><h1 id="c505" class="lq lr ht bd ls lt lu lv lw lx ly lz ma iz mb ja mc jc md jd me jf mf jg mg mh bi translated">带有工作管理器的Android Worker</h1><figure class="jj jk jl jm fd hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es nc"><img src="../Images/3bc6fd0b139d4c8606a2a233cf04e0ed.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mK_AIQ1x18epzTJv84dQZw.png"/></div></div><figcaption class="jn jo et er es jp jq bd b be z dx translated"><a class="ae lb" href="https://developer.android.com/topic/libraries/architecture/workmanager" rel="noopener ugc nofollow" target="_blank">https://developer . Android . com/topic/libraries/architecture/work manager</a></figcaption></figure><p id="a873" class="pw-post-body-paragraph jr js ht jt b ju jv iu jw jx jy ix jz ka kb kc kd ke kf kg kh ki kj kk kl km hb bi translated">这项工作与任务很相似。在大多数情况下，当我们需要在后台立即进行一些工作时，运行。但是，如果我们需要创建重复性工作或一些特定的长时间工作，这是推荐的解决方案。</p><p id="d54c" class="pw-post-body-paragraph jr js ht jt b ju jv iu jw jx jy ix jz ka kb kc kd ke kf kg kh ki kj kk kl km hb bi translated"><a class="ae lb" href="https://developer.android.com/topic/libraries/architecture/workmanager" rel="noopener ugc nofollow" target="_blank">工作管理器处理三种类型的持续工作</a>:</p><ul class=""><li id="b049" class="kn ko ht jt b ju jv jx jy ka kp ke kq ki kr km ks kt ku kv bi translated"><strong class="jt hu">立即</strong>:必须立即开始并尽快完成的任务。可能会加快。</li><li id="02d0" class="kn ko ht jt b ju kw jx kx ka ky ke kz ki la km ks kt ku kv bi translated"><strong class="jt hu">长时间运行</strong>:可能运行更长时间的任务，可能超过10分钟。</li><li id="b542" class="kn ko ht jt b ju kw jx kx ka ky ke kz ki la km ks kt ku kv bi translated"><strong class="jt hu">可推迟的</strong>:在稍后时间开始并可以定期运行的计划任务。</li></ul><p id="1d0e" class="pw-post-body-paragraph jr js ht jt b ju jv iu jw jx jy ix jz ka kb kc kd ke kf kg kh ki kj kk kl km hb bi translated">从<code class="du lc ld le lf b">doWork()</code>返回的<code class="du lc ld le lf b"><a class="ae lb" href="https://developer.android.com/reference/androidx/work/ListenableWorker.Result" rel="noopener ugc nofollow" target="_blank">Result</a></code>通知工作管理器服务工作是否成功，以及在失败的情况下，是否应该重试工作。</p><ul class=""><li id="4544" class="kn ko ht jt b ju jv jx jy ka kp ke kq ki kr km ks kt ku kv bi translated">工作顺利完成。</li><li id="70f9" class="kn ko ht jt b ju kw jx kx ka ky ke kz ki la km ks kt ku kv bi translated"><code class="du lc ld le lf b">Result.InvokeFailure()</code>:工作失败。</li><li id="babd" class="kn ko ht jt b ju kw jx kx ka ky ke kz ki la km ks kt ku kv bi translated"><code class="du lc ld le lf b">Result.InvokeRetry()</code>:工作失败，应根据其<a class="ae lb" href="https://developer.android.com/topic/libraries/architecture/workmanager/how-to/define-work#retries_backoff" rel="noopener ugc nofollow" target="_blank">重试策略</a>在其他时间重试。</li></ul><figure class="jj jk jl jm fd hk"><div class="bz dy l di"><div class="lg lh l"/></div></figure><p id="0aa4" class="pw-post-body-paragraph jr js ht jt b ju jv iu jw jx jy ix jz ka kb kc kd ke kf kg kh ki kj kk kl km hb bi translated">添加一些日志程序来获取在不同设备上使用的真实应用程序的一些结果，并记录我们的员工实际上是如何工作的，这真的很有用。此外，你可能想知道— <em class="nd">为什么我在等待</em> <code class="du lc ld le lf b"><em class="nd">task</em></code>？因为我们已经在由Android操作系统管理的后台线程中，并且与<code class="du lc ld le lf b">async/await</code>时有问题，所以我想只在<code class="du lc ld le lf b">work result</code>结束时才返回它。</p><p id="2589" class="pw-post-body-paragraph jr js ht jt b ju jv iu jw jx jy ix jz ka kb kc kd ke kf kg kh ki kj kk kl km hb bi translated">为了运行我们的工作，我们在周期性工作的情况下设置了所需的启动约束和间隔。有关结果政策和我们员工可观察状态的更多信息，请点击此处:</p><p id="a3c9" class="pw-post-body-paragraph jr js ht jt b ju jv iu jw jx jy ix jz ka kb kc kd ke kf kg kh ki kj kk kl km hb bi translated"><a class="ae lb" href="https://developer.android.com/topic/libraries/architecture/workmanager/how-to/states-and-observation" rel="noopener ugc nofollow" target="_blank">https://developer . Android . com/topic/libraries/architecture/work manager/how-to/States-and-observation</a></p><figure class="jj jk jl jm fd hk"><div class="bz dy l di"><div class="lg lh l"/></div></figure></div><div class="ab cl li lj gp lk" role="separator"><span class="ll bw bk lm ln lo"/><span class="ll bw bk lm ln lo"/><span class="ll bw bk lm ln"/></div><div class="hb hc hd he hf"><h1 id="f8c1" class="lq lr ht bd ls lt lu lv lw lx ly lz ma iz mb ja mc jc md jd me jf mf jg mg mh bi translated">旧好任务-&gt;运行</h1><p id="3e7a" class="pw-post-body-paragraph jr js ht jt b ju mi iu jw jx mj ix jz ka mk kc kd ke ml kg kh ki mm kk kl km hb bi translated">这是一个跨平台的实现，如果你只需要在应用程序运行时在后台任务中运行一些代码，那么<code class="du lc ld le lf b">Task.Run</code>是一个完美的解决方案。我觉得没什么好解释的，只是补充一下，如果你因为某种原因想要等待，你可以很容易地将<code class="du lc ld le lf b">void</code>改为<code class="du lc ld le lf b">Task</code></p><figure class="jj jk jl jm fd hk"><div class="bz dy l di"><div class="lg lh l"/></div></figure></div><div class="ab cl li lj gp lk" role="separator"><span class="ll bw bk lm ln lo"/><span class="ll bw bk lm ln lo"/><span class="ll bw bk lm ln"/></div><div class="hb hc hd he hf"><p id="7a40" class="pw-post-body-paragraph jr js ht jt b ju jv iu jw jx jy ix jz ka kb kc kd ke kf kg kh ki kj kk kl km hb bi translated">感谢阅读；我希望它对你有用。请在Medium上关注我，同时也关注我的<a class="ae lb" href="https://twitter.com/bbenetskyy" rel="noopener ugc nofollow" target="_blank"> Twitter账户</a></p><figure class="jj jk jl jm fd hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es ne"><img src="../Images/5cc7c45c0640db494c08c9553a747de7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*i_rKMyZjZfgN1MRmUV9rXg.png"/></div></div></figure></div></div>    
</body>
</html>