# “承诺”模型——第 3 部分——Android 支持

> 原文：<https://medium.com/nerd-for-tech/the-promise-model-part-3-android-support-9522adda8b5a?source=collection_archive---------7----------------------->

## 移动应用中的反应式编程——一次旅行

## 一个异步任务链接工具，建立在 Kotlin 的“Promise”模型之上，专门设计用于支持 Android 上下文和主线程

## 介绍

这是关于科特林的“承诺”模型[的 3 篇文章的最后一篇。
这一部分集中在一个特定的 *Promise* 扩展——一个 Android Promise 类。它将*主线程*支持和*作用域*添加到*承诺*链中，以便在作用域终止时自动*取消*——例如，一个 *Android 视图*被*分离*。](/nerd-for-tech/the-promise-model-in-kotlin-1c121f22d35a)

# 我们将在本文中做什么

假设你[阅读了第一部分](/nerd-for-tech/the-promise-model-in-kotlin-1c121f22d35a)，你将学习如何扩展我们构建的 *Promise* 模型，以便为其添加功能——在这种情况下，GitHub 上提供了 *Android* 功能([，看看吧！](https://github.com/GuyMichael/APromise))。
我们将从*作用域* ( *上下文*)开始，以*主线程*支持结束。
这意味着我们将不再停留在纯粹的*科特林-* 依赖区。
移动应用*反应式编程*系列的下一篇文章将会谈到 *Reactdroid* 架构——一个*反应式，MVI* 架构用于 *Kotlin* 和 *Android* 。

![](img/bf171f961b982610ec48ea8102f1b470.png)

范围界定(在任务链中)就像在炎热的晴天滑雪——你必须在雪化之前完成下山的任务(上下文终止)。Val Thorens 滑雪场

关于任务链的范围界定，意味着将某些任务的*绑定到*范围*的*，因此当所述*范围*不再相关时，我们期望整个任务链停止，实际上*取消了*任务链。在*安卓*中，最常见的*作用域*是一个`Context`。实际上，我认为*上下文*比*范围*更直观，但是我想把*上下文*的一般概念与 *Android* 模型`Context`区分开来。我的头已经疼了😅我想我们可以继续了。**

让我们考虑下面的例子，并讨论它来解释什么是*作用域*，特别是关于任务链和*权限*:

查看权限中绑定的简单示例

简单地说，我们希望*将*绑定*一个*到一个 *Android 视图*，这样，如果在`delay`结束之前，所述*视图*被*销毁*(或者*将*从其*上下文/活动*中分离出来)，那么`then`将不会被调用——在这种情况下，跳过动画。

重要的是细节:

1.  我们不想把`mView`放在某个全球范围内，所以不泄露它的意思，我们想让*的观点*得到破坏；我们不想在*内存*中保存它，因为在*应用程序*不再使用它之后——这被称为*泄漏*。
    即使那不是*泄露*，一个‘死’的*视图*也没有用。
2.  默认情况下， *rx* 中的*延迟*动作延续了*计算*线程上的链(记住，我们在 *rx* 的*单个*之上构建了*承诺*)。
    所以，如果你直接用 *rx 使用一些自定义*视图作用域*，那么*这个`then`调用，在`delay`之后，将被*主线程*调用，导致*崩溃*，因为你不能使用 *Android 视图*离开*主线程*😖。
    *APromise* 为您处理这个令人头疼的问题——默认情况下从您调用`delay`的线程恢复，并允许轻松地切换到任何其他线程(`thenOn`)。
3.  我们可以定义两种类型的*作用域*，一种是如果某个*上下文*终止，则*取消*所有内容，另一种是跳过特定任务，但让任务链正常继续。顺便说一下，上面的例子显示了第一种情况——如果*视图*终止，整个链将*取消*。

底线是，*作用域/上下文，*特别是当与*异步*任务结合时，会引发一些非常恼人的问题，导致代码开销和令人头疼的问题。

举个令人头疼的例子——你在 *Android 中写了多少次这种代码？*

臭名昭著的广播接收机开销

不会了。说真的。当您读完这个系列时，假设您至少采用了一些技术(更不用说整个库了)，您将永远不会在您的项目中使用这样的代码😫。我们正在进行完全反应。
哭够了。回去工作。

# “完美”模式

*创建这个工具的第一步*将只是*扩展*承诺*模型并覆盖它的 API 以返回类型*承诺*而不是仅仅*承诺*。之后，我们会添加一些很酷的功能。让我们开始吧:*

扩展 Promise 模型来添加定制特性非常容易

还记得我们谈到的的[createInstanceImpl 吗？在这里。只是一个专用于*扩展*类来重新定义(*覆盖*)返回类型的方法。](/nerd-for-tech/the-promise-model-in-kotlin-1c121f22d35a#4df8)

如你所见，我们必须*覆盖*所有(我们想要的)API，以便将它们的结果转换为*权限*。否则，用法会很难，因为类型会在链的中间从*承诺*变为*承诺*，就像这样:

当我们在扩展 Promise APIs 时没有覆盖它，会发生什么

就是这样！
-无需覆盖`execute`。它是`Promise.`
中的*最终*——无需再次进入*链接动作**——*你只需覆盖先前的 API。

😡如果这种做法让你生气，请继续阅读下面的*注释*。
😃如果你高兴，就跳过它，让我们有一些乐趣，好吗:)

愤怒的读者请注意:有一个很好的技巧可以克服这个问题——需要覆盖所有的 API。您只需用扩展该类的泛型类型来定义该类。但是在这个特殊的例子(Promise)中，我觉得这会给最终的使用增加太多的开销(在 Kotlin 不能推断出 Promise 类型的情况下，需要显式地编写泛型代码)，比它所能帮助的要多。最终，它的超级容易只是覆盖所有的方法，演员是安全的，由于 `createInstanceImpl` *，与 20 多年前的常识相反，来源于* [*并不总是低效的*](https://stackoverflow.com/questions/26335959/what-is-the-cost-of-casting-in-java-is-it-a-good-idea-to-avoid-it?lq=1) *。
无论如何，这里有一个替代方案，它省略了覆盖(和强制转换)的需要:*

承诺的替代声明，省略覆盖所有 API 的需要

# 范围'权限'

在我们的*任务*中有两种处理*范围*的方法:

1.  当*范围*终止时(如*视图脱离*)监听并立即取消*任务。*这种方法有助于*取消*整个链条。
2.  将*作用域*(例如*视图*)缓存在 [*WeakReference*](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.native.ref/-weak-reference/) 中，并检查它在下一个动作(例如“then”)时是否“活动”。这种方法有助于跳过特定的任务，而不是*取消*所有事情。

这两种方法都依赖于一些相当复杂的实用方法，但它们也非常有趣，会教会你很多关于 *Promise/APromise* 的用法和功能。
所以我们要做的是从头开始:)我们将在本文的结尾指定这些实用程序，供真正的书呆子阅读😎。

## 侦听范围终止

如果我们想在*范围*终止时自动*取消*我们的*约定*，我们需要监听/等待它终止，然后*取消*的`APromise`。让我们来看看下面的例子——一个*任务*的方法，当一个*活动*被*销毁*时，实现这样的*自动取消*到*取消*和*任务*:

APromise 的 autoCancel 方法，用于在活动被销毁时取消 APromise

解释在代码中的注释中，但是我将详细说明:

1.  它使用另一个*任务*来等待*活动*的的`onDestroy`。
    当它发生时，另一个*委托*将*取消*【我们】(`this` ) *委托*。
    `ViewUtils.waitForDestroy(Activity)`是一个(神奇的)实用方法，我们将在本文末尾介绍。
2.  它使用我们现在才看到的`APromise.doOnExecution()`来*执行*另一个`waitForDestroy()` *指令*。
    这只是另一种方法，在你的*承诺*已经实际开始运行的时候，帮助你运行一些代码(*执行*)。正如您所记得的，我们的*承诺*是异步的，并且是可以在方法之间传递的*一等公民* 。因此，我们不能假设它什么时候会执行，所以在它执行之前，我们不应该做任何动作——当有人调用你的方法时，你想做的所有动作(例如`autoCancel`或某种类型的`then`)应该放在`doOnExecution`中，就像上面的例子一样。
3.  在*活动*在【我方】*委托*完成(*解决/拒绝* ) *之前*未被*销毁的“标准”情况下，使用`finally()`到*取消*`waitForDestroy()`*委托*。*
4.  完全相同的方法用于为*视图*创建一个*自动取消*方法，除了它使用(神奇的)实用方法`ViewUtils.waitForDetach(View)`)

使用这个`autoCancel`，我们可以很容易地为我们的*委托*创建有用的‘then’，例如，一个‘delay while alive’方法，来*延迟*一些‘then’(一个*消费者*)但是*取消*如果一个*活动*终止:

延迟消费者，但如果一些活动在之前终止，则取消

现在，使用`delayWhileAlive`，我们可以，例如，*在未来某个时间向*发送一些*分析 API* ，除非*活动*在此之前终止:

除非上下文在预定时间之前终止，否则不要采取进一步的措施

很好。不需要处理*泄漏*，不需要有一些*定时器*并在 *onDestroy* 中检查它以知道是否发送*事件*。只需定义 *onCreate* 中的所有内容，然后忘掉它。
当然，您可以使用`autoCancel(View)`来完成类似的任务，使用*视图*来代替。

## 缓存范围而不是立即取消

*委托*用来处理*范围*的另一种方法是只缓存*上下文*(使用`WeakReference<T>`)，当链中的某个任务即将运行时，检查*引用*是否仍然保存*上下文*(*为空*)。
如果*对象*还在，继续任务，但如果不在( *null* ，就跳过它(或者*取消/拒绝*整个*委托*)。

*注意:一个*[*weak reference*](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.native.ref/-weak-reference/)*，基本上是一个持有另一个对象(* `*T*` *)的对象，但是如果‘没有其他人’再使用/持有它，就释放它，让垃圾收集器做它的事情。简单地说，它的意思是‘如果我是最后一个持有这个对象的人，请释放它’。防止漏水的好工具。*

让我们来看看下面的例子——一个实用方法，我们将把它注入到`WeakReference<View*>*`类中(通过使用 [*Kotlin 扩展*](https://kotlinlang.org/docs/extensions.html) )来帮助我们检查*视图*是否“活动”:

如果' alive '则获取持有的视图，否则为 null

太好了，现在我们可以轻松地持有*视图*(没有*泄露*它们)并轻松地检索它们——不需要检查它们的`Context`是否有效，甚至不需要检查它们是否被*附加到*窗口*上。*

使用`getIfAlive()`,我们可以很容易地为我们的*委托*定义更有用的“then ”,例如，一个“thenWithView”方法，它使用“缓存”方法来调用某个*消费者*,前提是一个*视图*是“活动的”,但如果它不是“活动的”,就不取消整个链——只是跳过那个*消费者*:

如果某个视图是“死的”,则跳过其消费者的“那么”

现在，使用`thenWithView`，我们可以，例如，*获取*一些 *API* 并*缓存*其结果(不管任何作用域/ *视图*)，然后*动画化*一些*视图*——仅当“活动”时——然后发送一些关于整个过程的*分析*:

如果某个视图是“死的”,只跳过特定的“然后”

很好。不需要处理*泄露*，也不需要检查我们*视图*的*上下文*状态。只要定义我们想要做什么，如果它是“活的”(并获得一个参考！)并继续建链。
当然，您可以使用`thenWithActivity(Activity)`来做类似的任务，使用*活动*来代替。

## 检查点—在我们继续之前

使用这两种方法还有许多更有趣的可能性，但是您可以尝试一下和/或看看[源代码](https://github.com/GuyMichael/APromise/blob/master/apromise/src/main/java/com/guymichael/apromise/APromise.kt)，因为这篇文章已经太长了，我们必须展示*主线程*支持，并看看我们之前谈到的那些神奇的实用程序:)

如果这对你今天来说足够了，感谢你的阅读，请不要犹豫，把你的意见写在下面！如果你像我一样是个真正的书呆子，让我们来玩玩线程和一些实用方法🤓。

# 主线程支持

你可能知道， *Android* 的*主线程*是你在处理 UI ( *活动、视图*等时唯一可以使用的线程。)和其他一些东西。当我们使用异步任务时，这是很困难的，异步任务最好运行在其他线程上。
需要记住的唯一重要的事情是，有 *rx* ( *单个*)动作自动改变链的线程(*下游*)，如果我们不想让使用*委托*变得困难和模糊，我们需要恢复到*主线程*(或一些其他线程)。

## APromise.delay()，APromise.timeout()

我们将只讨论“延迟”,因为“超时”在线程方面是一样的。

这个想法很简单——所以忽略所有那些循环和调度程序，让我们简单地说: *Promise* 的`delay(ms: Long, resumeOn: Scheduler)`为我们提供了一种在指定线程上的*延迟*之后继续的方法(因为 *Single* 的*延迟*会自动改变链以在某个*计算*线程上运行)。
所以我们要做的是，告诉 *Promise* 的 *delay* 在“当前”线程上继续，也就是说，最初调用 *delay* 的线程。
就这样。我们只是通过隐藏和修复来解决这个问题。
如果不能推断出“当前”线程，将使用*主线程*作为后备。

*注意:实际上，通常会使用主线程，因为大多数线程不会有弯针。但是这对于现在来说太高级了，而且你可能会在 99%的时间里使用主线程的指令。所以不用担心。*

## APromise.thenOnMainThread

由于 *Promise* 提供了一个`thenOn`动作，可以很容易地移动到任何你想要的 *rx 调度器*(*a Promise*也有)，我们可以创建一个 helper 方法来很容易地在*主线程*上继续一个链:

还有一些有用的 creator 方法，比如:
`APromise.delayOnMainThread(ms: Long, consumer)`在做某件事之前轻松等待(并在主线程上做)；
`APromise.postAtEndOfMainExecutionQueue(consumer)`，其行为类似于`View.post()`——做一些“现在”的事情，但是非阻塞的(一旦当前方法和先前调用的函数/任务完成)—但是不需要*视图。* 还有很多……但是你要抓住要点。

这就是线程处理！让我们以(神奇的)实用方法结束:)

# 有用的实用方法

正如我*之前答应*(呵呵)你的，下面是两个非常有用的实用方法([这里定义为](https://github.com/GuyMichael/APromise/blob/master/apromise/src/main/java/com/guymichael/apromise/ViewUtils.kt))供我们在创建令人敬畏的*命令*动作时使用，甚至直接使用:`waitForDestroy(Activity)`和`waitForDetach(View)`。
它们是使用(也)有用的*承诺*创建者`Promise.ofCallback()`创建的(也可用于*承诺*)。
所以我们将从回调的*开始，然后继续讨论它们。*

## Promise.ofCallback

这是一个*承诺*创建器，它将标准回调“转换”为*承诺*。它非常有用，你可能会经常用到。例如，它可以将 [*安卓*的*任务*](https://developer.android.com/reference/com/google/android/play/core/tasks/Task) ，或者 [*安卓的动画师*](https://developer.android.com/reference/android/animation/Animator.AnimatorListener) 转换为*任务*。
这个强大的函数可以帮助你轻松地将代码中的每一个回调转换成 *Promise/APromise* 以便在代码中只使用 *Promises* 。不会再有试镜了，永远不会。声明一次，永远使用。

下面是 Callback 的*的简化版，后面是详细解释:*

ofCallback()的简化实现，用于将回调转换为承诺

这没什么特别的，真的。一个 *rx 单*创建者给你一个*发射器*，它只是一个‘送货员’，你通知它成功和失败——它通知*单。这正是我们所做的。我们传递那个*发射器*，它基本上是一个*接口*，有两个方法: *onSuccess* 和 *onError* 。
他们将从任何“标准”回调中被调用(成功或失败时)，他们将控制*单*，因此*承诺*。很简单。
实际的实现稍微复杂一点，因为它用另一个实例(姑且称之为 *PromiseEmitter* )包装了*发射器*，以允许一些高级用法，但想法是完全一样的。*

所以现在我们可以将任何回调转换成承诺，或者在我们的例子中，转换成承诺。我们开始吧！

## ViewUtils.waitForDestroy

有多少次你想知道当一个*活动*被*销毁*——从那个*活动*之外，或者只是没有添加开销代码到它的*销毁*？
让我们创建一个助手方法，只需一行简单的代码就能完成:

等待一个活动的结束，并转化为一个承诺。简化了一点。

它看起来有点长，因为我编辑它是为了更容易解释——实际代码实际上要短得多——不过这个想法非常简单，让我们从头开始:

1.  我们准备一个 *WeakReference* 来举办*活动*
2.  我们从那个*弱引用*中创建(并且*返回*)一个*委托*。
    `ofWeakRefOrCancel`只是一个简单的*委托*创建器，它在继续*自动取消*之前检查参考是否保持*空值*。我们需要它，因为我们总是定义我们的*承诺*异步，意思是，我们假设它们不会立即被调用。所以据我们所知， *waitForDestroy* 可以在*活动*被销毁很久之后*被执行。
    这甚至不是将回调转换为*回调的一部分…* 在*内，然后等待*是实际的逻辑/call-to-ofCallback。*
3.  我们调用回调函数的*并传递两个参数:*

*   回调创建器——它创建了一个 *Android* 的*应用程序的实例。ActivityLifecycleCallback* 在*活动*被破坏时通知*发射器*。
    它还将其注册到*应用程序*中。不要担心，在*承诺*被*执行*之前，回调创建者不会被调用，所以这是一个*注册*您的回调的完美地方。
*   最后一个动作——它被称为 always，当*承诺*终止时(甚至在*取消*时),这就是我们*取消*回调的地方。

真的就是这样。在我们继续之前，让我提醒你一下 *Android* 的回调*应用。ActivityLifecycleCallback* 不是类型化的，它不会检查您收到的*活动*是否对您很重要(`A`)。事实上，每当*任何* *活动*有*任何*生命周期事件时，它都会告诉您。
在[源代码](https://github.com/GuyMichael/APromise/blob/master/apromise/src/main/java/com/guymichael/apromise/ViewUtils.kt)中，你可以看到我使用了一个专用的实现(*on activity destroyed listener*)来为我做这件事。没什么特别的。思路和上图一模一样。

从现在开始，当我们需要知道一个*活动*何时被*销毁*时，我们所需要的就是这个:

waitForDestroy 的用法示例

多酷啊。提示:与`View.waitForDetach`一起，它是我们接下来将讨论的 *Reactdroid* 架构的关键构建模块:)

## ViewUtils.waitForDetach

使用完全相同的方法，我们可以等待*视图*到*从*窗口*中分离*。这次我将展示没有所有注释的压缩版本。我也不会解释它——没有必要——这是完全相同的方法:

等待视图分离并转换为承诺

用法是:

它改变了你的生活还是什么？它确实改变了我！

# 摘要

在本文中，我们学习了如何*扩展*我们在[以前的文章](/nerd-for-tech/the-promise-model-in-kotlin-1c121f22d35a)中创建的*承诺*模型/单子——我们通过学习如何用*权限* ( *范围*和*线程处理*)专门支持 *Android* 来做到这一点，同时，我们学习了如何转换任何*回调*

这就结束了这个系列的*承诺*部分——移动应用中的*反应式编程——*，并打开了真正有趣的东西的大门:在 *Kotlin* 中的*反应式、MVI* 架构，它目前支持 *Android* ，但也可以轻松支持 *iOS* 到 *Kotlin 多平台*。

敬请关注。下次见，祝你愉快:)