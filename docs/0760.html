<html>
<head>
<title>The ‘Promise’ Model, in Kotlin — Part 2 — Error Handling with the ‘Catch’</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">“承诺”模型，在科特林-第 2 部分-错误处理与“捕捉”</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/the-promise-model-in-kotlin-part-2-error-handling-ebb5b66bb745?source=collection_archive---------10-----------------------#2021-02-11">https://medium.com/nerd-for-tech/the-promise-model-in-kotlin-part-2-error-handling-ebb5b66bb745?source=collection_archive---------10-----------------------#2021-02-11</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><h2 id="4d82" class="hg hh hi bd b fp hj hk hl hm hn ho dx hp translated" aria-label="kicker paragraph">移动应用中的反应式编程——一次旅行</h2><div class=""/><p id="2e10" class="pw-post-body-paragraph io ip hi iq b ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl hb bi translated">恰当而优雅地处理错误是“Promise”模型的一个主要优点。“catch”条款还允许通过提供一个新的值甚至一个新的<em class="jm">承诺</em>来恢复这个链，以便从<em class="jm">异常</em>中恢复。<br/>这是<a class="ae jn" rel="noopener" href="/@gguymi/the-promise-model-in-kotlin-1c121f22d35a">“承诺模型”</a>的第二部分。</p><p id="8fa2" class="pw-post-body-paragraph io ip hi iq b ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl hb bi translated"><strong class="iq hs">简介<br/> </strong>在<a class="ae jn" rel="noopener" href="/@gguymi/the-promise-model-in-kotlin-1c121f22d35a">第一章</a>中，我们介绍了在<em class="jm"> Kotlin </em>中创建<em class="jm"> Promise </em>模型的基础知识，该模型允许<em class="jm">JavaScript</em>——类似于<em class="jm"> Promise </em>的用法，但是具有额外的特性，例如线程处理和多平台能力。在本章中，我们将讨论错误处理，也就是“catch”子句。<br/>下一章——<em class="jm">Android apro mise</em>——将涵盖<em class="jm"> APromise </em>模型，这是一个扩展类，通过提供<em class="jm"> Android </em> ' <em class="jm">主线程</em>'和<em class="jm">视图</em>特性，专门支持<em class="jm"> Android </em>平台。</p><figure class="jp jq jr js fd jt er es paragraph-image"><div role="button" tabindex="0" class="ju jv di jw bf jx"><div class="er es jo"><img src="../Images/fa8ed2fe3f82036a534fa5e3e37ab79a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6jrdQbsb1xDhyOSg85kpug.jpeg"/></div></div><figcaption class="ka kb et er es kc kd bd b be z dx translated">找到错误，找到沃尔多</figcaption></figure></div><div class="ab cl ke kf gp kg" role="separator"><span class="kh bw bk ki kj kk"/><span class="kh bw bk ki kj kk"/><span class="kh bw bk ki kj"/></div><div class="hb hc hd he hf"><h1 id="b19a" class="kl km hi bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li bi translated">“catch”从句，引言</h1><p id="9e4d" class="pw-post-body-paragraph io ip hi iq b ir lj it iu iv lk ix iy iz ll jb jc jd lm jf jg jh ln jj jk jl hb bi translated"><em class="jm"> Promise </em>模型中的‘Catch’子句基本上是任务链的一个<em class="jm"> onError </em>回调，除了它还可以恢复(回到<code class="du lo lp lq lr b">then</code>链以从<em class="jm">异常</em>中恢复。您可以在链中的任何地方使用任意多的' catch' <em class="jm"> </em>，甚至可以在内部链中使用(一个在<code class="du lo lp lq lr b">then</code>子句中返回的<code class="du lo lp lq lr b">Promise</code>)。它们被调用的顺序——在<em class="jm">异常</em>被<em class="jm">抛出的情况下— </em>是至关重要的，并且应该与那些<code class="du lo lp lq lr b">catch</code>被写入的顺序相同。</p><p id="3746" class="pw-post-body-paragraph io ip hi iq b ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl hb bi translated">为了理解我对“catch”的实现，让我们首先考虑这个<em class="jm">承诺</em>链，以理解我们期望我们的<em class="jm">承诺</em>如何处理错误:</p><figure class="jp jq jr js fd jt"><div class="bz dy l di"><div class="ls lt l"/></div><figcaption class="ka kb et er es kc kd bd b be z dx translated">具有多种 catch 用法的多承诺链</figcaption></figure><p id="0c91" class="pw-post-body-paragraph io ip hi iq b ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl hb bi translated">现在让我们考虑可能的“捕获”流:</p><ol class=""><li id="d275" class="lu lv hi iq b ir is iv iw iz lw jd lx jh ly jl lz ma mb mc bi translated"><em class="jm"> ofDelay(5000)失败:</em> <br/>我们期望<em class="jm">第一档</em>和<em class="jm">第三档</em>按此顺序触发(被调用)。<br/>我们确实<em class="jm">不</em>期望<em class="jm">第二次捕捉</em>被调用，因为如果<em class="jm">异常</em>被<em class="jm">抛出</em>到链上的任何地方，则<code class="du lo lp lq lr b">thenAwait</code>不会开始，并且<em class="jm">第二次捕捉</em>属于内链，<em class="jm">不是</em>属于“原始”外链。<br/>事实上，整个<code class="du lo lp lq lr b">Promise.ofDelay(10000)</code>链可以用一个单独的方法来写——它与外、<em class="jm">上游</em> (up the)链无关；这是一个重要的规则。</li><li id="398e" class="lu lv hi iq b ir md iv me iz mf jd mg jh mh jl lz ma mb mc bi translated"><em class="jm"> ofDelay(10000)失败:<br/> </em>我们期望<em class="jm">第二档</em>和<em class="jm">第三档</em>按此顺序触发。<br/>这是因为<em class="jm">第二档</em>属于引发<em class="jm">异常</em>的实际(内)链条，<em class="jm">第三档</em>放置在<em class="jm">(在<em class="jm">的</em>下游)</em> <code class="du lo lp lq lr b">thenAwait</code>之后——一个失效的内链条(<em class="jm">抛出</em>一个<em class="jm">异常</em>)导致<em class="jm">整个</em>链条失效。这也是一个重要的规则。</li></ol><p id="23a5" class="pw-post-body-paragraph io ip hi iq b ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl hb bi translated">注意:除了“catch”子句的调用顺序之外，这里的要点是，虽然内部链与#1 中看到的(外部)<em class="jm">上游</em>链无关(当然，除了通过“then”接收其结果之外)，但是<em class="jm">对(外部)<em class="jm">下游</em>链影响很大， 正如在#2 中看到的——当一个<em class="jm">异常</em>被<em class="jm">抛出</em>(‘catch’链)时，以及通过<em class="jm">映射</em>结果/结果类型(‘then’链)时，都会影响它，例如从<code class="du lo lp lq lr b">T</code>到<code class="du lo lp lq lr b">R</code>，正如在本文的前一章中看到的。</em></p></div><div class="ab cl ke kf gp kg" role="separator"><span class="kh bw bk ki kj kk"/><span class="kh bw bk ki kj kk"/><span class="kh bw bk ki kj"/></div><div class="hb hc hd he hf"><h2 id="6261" class="mi km hi bd kn mj mk ml kr mm mn mo kv iz mp mq kz jd mr ms ld jh mt mu lh ho bi translated">“捕捉”实现方法</h2><p id="50ad" class="pw-post-body-paragraph io ip hi iq b ir lj it iu iv lk ix iy iz ll jb jc jd lm jf jg jh ln jj jk jl hb bi translated">现在，本能地，实现我们的“catch”的最简单方法是让它使用<em class="jm"> rx Single </em>的<code class="du lo lp lq lr b">doOnError</code>——这是一个副作用回调，可以在一个链中使用多次，就像我们希望的“catch”一样。<br/>问题是，它可能有意想不到的调用顺序，这取决于我们将使用的确切流。在上面的<em class="jm">承诺</em>-链示例中，例如，如果 Delay(10000) 的<em class="jm">失败，<em class="jm">第三抓</em>将在</em> <em class="jm">第二抓(！).</em> <br/>我不会在这篇文章中深入探讨<em class="jm"> rx </em>的细节/原因，但底线是:<br/> <em class="jm">我们不能指望</em> <code class="du lo lp lq lr b"><em class="jm">doOnError</em></code> <em class="jm">完全按照我们所期望的“catch”的方式行事。</em></p><p id="c812" class="pw-post-body-paragraph io ip hi iq b ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl hb bi translated">为了克服这一点，我们要做的是<em class="jm">而不是</em>使用<em class="jm">单个</em>的<code class="du lo lp lq lr b">doOnError</code>。相反，我们将使用我们的<code class="du lo lp lq lr b">Single</code>的<em class="jm">订阅</em>(在<em class="jm">承诺</em>的<code class="du lo lp lq lr b">execute</code>方法内，<a class="ae jn" rel="noopener" href="/@gguymi/the-promise-model-in-kotlin-1c121f22d35a#85c7">见上一章</a> ) <em class="jm"> </em>来订阅错误，我们将定义我们自己的<em class="jm">错误处理链</em>，我们将仅从那个<em class="jm">订阅</em>中调用它。别担心，一切都会解释清楚的。</p><p id="8cb6" class="pw-post-body-paragraph io ip hi iq b ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl hb bi translated">顺便说一下，如果有人提出一个更“单一”的方法，一个包含更少“定制”代码的方法，我会非常乐意倾听。这个 Promise 实现的优势在于它是一个 <code class="du lo lp lq lr b"><em class="jm">Single</em></code> <em class="jm">的事实，每一个“额外”的代码都会使它变得不那么重要。也就是说，这种错误处理在两个生产应用中完美地工作，带有一些非常复杂的承诺链。效果很好。</em></p><p id="0cdd" class="pw-post-body-paragraph io ip hi iq b ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl hb bi translated">我们开始吧。基本上，我们只需要记住我们需要多个<code class="du lo lp lq lr b">catch</code>(使用<a class="ae jn" href="#3746" rel="noopener ugc nofollow">上面的例子</a>)以正确的顺序被调用。<br/>我们将重复<a class="ae jn" rel="noopener" href="/@gguymi/the-promise-model-in-kotlin-1c121f22d35a#35f1">到目前为止我们已经介绍过的完全相同的步骤</a>，但是使用更多的代码。<em class="jm">标题与前一章中的步骤相对应。</em></p><h2 id="3878" class="mi km hi bd kn mj mk ml kr mm mn mo kv iz mp mq kz jd mr ms ld jh mt mu lh ho bi translated">通过错误处理建立承诺</h2><p id="d83e" class="pw-post-body-paragraph io ip hi iq b ir lj it iu iv lk ix iy iz ll jb jc jd lm jf jg jh ln jj jk jl hb bi translated">我们先从<em class="jm">承诺</em>类定义开始。还记得只有两个成员吗，<code class="du lo lp lq lr b">promiseSubscriber</code>和<code class="du lo lp lq lr b">single</code>？这是另一个 2:</p><figure class="jp jq jr js fd jt"><div class="bz dy l di"><div class="ls lt l"/></div><figcaption class="ka kb et er es kc kd bd b be z dx translated">简化的 Promise 类声明，这次使用了错误处理程序。</figcaption></figure><p id="5210" class="pw-post-body-paragraph io ip hi iq b ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl hb bi translated">如您所见，每个<em class="jm">承诺</em>都有一个用于简单操作的错误处理程序(比如‘then’)，以及一个用于异步任务的错误处理程序(比如‘then wait’)。<br/>现阶段很难解释原因，所以我们会边走边解释。<br/>简单地说，这样做是因为异步操作的复杂性需要一个专门的错误处理器，否则<code class="du lo lp lq lr b">catch</code>调用的顺序会被打乱(如上面的<code class="du lo lp lq lr b">promise.ofDelay()</code>示例所示)。</p><h2 id="8ca7" class="mi km hi bd kn mj mk ml kr mm mn mo kv iz mp mq kz jd mr ms ld jh mt mu lh ho bi translated">创建带有错误处理的新 Promise 实例</h2><p id="0f01" class="pw-post-body-paragraph io ip hi iq b ir lj it iu iv lk ix iy iz ll jb jc jd lm jf jg jh ln jj jk jl hb bi translated">现在，让我们回到<code class="du lo lp lq lr b">createInstance</code>方法，这次是错误处理代码:</p><figure class="jp jq jr js fd jt"><div class="bz dy l di"><div class="ls lt l"/></div></figure><p id="b909" class="pw-post-body-paragraph io ip hi iq b ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl hb bi translated">每当我们创建一个新的<code class="du lo lp lq lr b">Promise</code> <em class="jm"> </em>实例时(例如，对于一个新的‘then’动作)，我们将把‘当前’<em class="jm">承诺</em>的<em class="jm">错误处理程序</em>传递给新的/下一个<em class="jm">承诺。</em>这样做是因为链中的最后一个<em class="jm">承诺</em>是处理错误(实际上是成功)的唯一<em class="jm">承诺</em> <em class="jm">承诺</em>。这是因为最后一个<em class="jm">承诺</em>的<code class="du lo lp lq lr b">Single</code>是我们<em class="jm">订阅</em>的链中唯一的<em class="jm">单个</em>。还有一个不订阅的<em class="jm">单</em>不<em class="jm">不</em>跑，记得吗？下一步显示更新的<code class="du lo lp lq lr b">execute</code>方法，这将使它更加清晰。</p><p id="55e4" class="pw-post-body-paragraph io ip hi iq b ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl hb bi translated"><em class="jm">注:这是谈论房间里的大象的好时机。最后的承诺是唯一重要的承诺。有点像 rx 链中的最后一个单曲是唯一重要的单曲。所有其他承诺都是为了方便使用(构建链)而存在的，并将被垃圾收集。最后一个承诺持有唯一订阅的</em> <code class="du lo lp lq lr b"><em class="jm">Single</em></code> <em class="jm">，因此持有整个单个操作链。如果你确定你有一个更有效的方法，不损害反应式方法和易用性，请让我知道。</em></p><h2 id="6259" class="mi km hi bd kn mj mk ml kr mm mn mo kv iz mp mq kz jd mr ms ld jh mt mu lh ho bi translated">执行承诺，并进行错误处理</h2><p id="003d" class="pw-post-body-paragraph io ip hi iq b ir lj it iu iv lk ix iy iz ll jb jc jd lm jf jg jh ln jj jk jl hb bi translated">下面是新的<code class="du lo lp lq lr b">execute</code>方法，增加了<em class="jm">错误处理</em>代码:</p><figure class="jp jq jr js fd jt"><div class="bz dy l di"><div class="ls lt l"/></div></figure><p id="6087" class="pw-post-body-paragraph io ip hi iq b ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl hb bi translated">如你所见，<em class="jm">单个</em>的<code class="du lo lp lq lr b">subscribe</code>方法有两个参数，一个<em class="jm">成功处理程序</em>和一个<em class="jm">错误处理程序</em>。<em class="jm">成功处理程序</em>并不重要，因为我们使用‘然后’和‘最终’，它们直接和立即影响<em class="jm">单链</em>。<br/>然而<em class="jm">错误处理程序</em>是我们实际处理错误的地方——它们是<em class="jm">而不是</em>在<em class="jm">单个</em>自己的成功链内处理。让这种想法停留一会儿，然后继续阅读。<br/>现在，为了使这一点更加清楚，请回到第一章中的<a class="ae jn" rel="noopener" href="/@gguymi/the-promise-model-in-kotlin-1c121f22d35a#5c24">简单‘then’代码。如你所见，它使用了<code class="du lo lp lq lr b">this.single.map</code>(通过<code class="du lo lp lq lr b">singleOfConsumer()</code>)，这意味着它已经影响了<em class="jm">单</em>链。<br/>尽管‘catch’条款，<em class="jm">而非</em>是否影响<em class="jm">单链</em>。继续读。</a></p></div><div class="ab cl ke kf gp kg" role="separator"><span class="kh bw bk ki kj kk"/><span class="kh bw bk ki kj kk"/><span class="kh bw bk ki kj"/></div><div class="hb hc hd he hf"><h1 id="14ce" class="kl km hi bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li bi translated">“Catch”子句的实现</h1><p id="e853" class="pw-post-body-paragraph io ip hi iq b ir lj it iu iv lk ix iy iz ll jb jc jd lm jf jg jh ln jj jk jl hb bi translated">现在，我们终于理解了更多并改进了以前的代码。<br/>注意<code class="du lo lp lq lr b">catch</code>如何影响<em class="jm">而非</em>单<em class="jm">链条，与<code class="du lo lp lq lr b">then</code>相反。</em></p><figure class="jp jq jr js fd jt"><div class="bz dy l di"><div class="ls lt l"/></div></figure><p id="bcb0" class="pw-post-body-paragraph io ip hi iq b ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl hb bi translated">这真的很简单——如果没有先前的<em class="jm">错误处理程序</em>，我们只需保存新的<em class="jm">消费者</em>(新的<em class="jm">错误处理程序</em>参数传递给<code class="du lo lp lq lr b">catch</code>)。<br/>如果有先前的错误处理程序(来自先前的<code class="du lo lp lq lr b">catch</code>调用)，创建并替换为新的<em class="jm">错误处理程序— </em>，以正确的顺序调用先前的错误处理程序和新的错误处理程序。有点类似于链表，一般意义上的。</p><p id="f248" class="pw-post-body-paragraph io ip hi iq b ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl hb bi translated">回到<em class="jm">单个</em>的讨论——这个<code class="du lo lp lq lr b">catch</code>实现根本不会<em class="jm">而</em>影响<em class="jm">承诺</em>的<code class="du lo lp lq lr b">Single</code>，因此不会创建新的<code class="du lo lp lq lr b">Promise</code>。<br/>它只是<em class="jm">回报</em> <code class="du lo lp lq lr b">this</code> ( <em class="jm">承诺</em>)。<br/>原因，如果你记得的话，与“等待”有关——如果不处理内部<em class="jm">承诺</em>链(就像上面的<a class="ae jn" href="#3746" rel="noopener ugc nofollow">例子中那样)，我们可以只使用<em class="jm"> Single 的</em> <code class="du lo lp lq lr b">doOnError</code>方法。但有了它，就会打乱“catch”调用的正确顺序。</a></p></div><div class="ab cl ke kf gp kg" role="separator"><span class="kh bw bk ki kj kk"/><span class="kh bw bk ki kj kk"/><span class="kh bw bk ki kj"/></div><div class="hb hc hd he hf"><h1 id="74f5" class="kl km hi bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li bi translated">然后等待，并进行错误处理</h1><p id="7303" class="pw-post-body-paragraph io ip hi iq b ir lj it iu iv lk ix iy iz ll jb jc jd lm jf jg jh ln jj jk jl hb bi translated">最后我们到了最后一部分。真正棘手的是。这种“然后等待”是“捕捉”与“然后”工作不同的全部原因；该“catches”不影响<em class="jm">承诺</em>的<code class="du lo lp lq lr b">Single</code>并保存在<code class="du lo lp lq lr b">onErrorConsumer</code>中；这就是为什么我们从<em class="jm">承诺</em>的<code class="du lo lp lq lr b">execute</code>方法内部，从<code class="du lo lp lq lr b">single.subscribe()</code>内部执行<em class="jm">错误</em>链。<br/>这就是为什么我们经历了一切(从<a class="ae jn" href="#9ceb" rel="noopener ugc nofollow"> <em class="jm">【军规】条款开始，介绍</em> </a> <em class="jm"> ) </em>。</p><p id="ab41" class="pw-post-body-paragraph io ip hi iq b ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl hb bi translated">让我们看看新的<code class="du lo lp lq lr b">thenAwait</code>和它的<code class="du lo lp lq lr b">singleOfAsync</code>，这次是正确的<em class="jm">错误处理</em>:</p><figure class="jp jq jr js fd jt"><div class="bz dy l di"><div class="ls lt l"/></div></figure><p id="a600" class="pw-post-body-paragraph io ip hi iq b ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl hb bi translated">为了理解这里发生了什么，让我们提醒自己这一节开始的例子:</p><figure class="jp jq jr js fd jt"><div class="bz dy l di"><div class="ls lt l"/></div></figure><p id="87e9" class="pw-post-body-paragraph io ip hi iq b ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl hb bi translated">我们将把<code class="du lo lp lq lr b">Promise.ofDelay(5000)</code>—<em class="jm">promises 5 和</em>—<em class="jm">promises 10 称为。而</em>我们的任务就是让<em class="jm">承诺 10 </em>的<em class="jm">第二抓</em>火在<em class="jm">第三抓</em>、<em class="jm">、</em>失败(拒绝)的时候。</p><p id="44c5" class="pw-post-body-paragraph io ip hi iq b ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl hb bi translated">当这个<em class="jm">承诺</em>链被创建时，<code class="du lo lp lq lr b">thenAwait</code>在<em class="jm">承诺 5 </em>上运行并调用<code class="du lo lp lq lr b">singleOfAsync</code>(如上面的实现所示)。在它里面，当<code class="du lo lp lq lr b">flatMap</code>计算的时候(也只有那时！)，<em class="jm">promises 10</em>的(<code class="du lo lp lq lr b">nextPromise</code> ) <em class="jm">错误处理程序</em>保存为<em class="jm">promises 5</em>的<em class="jm">异步错误处理程序。</em></p><p id="f8f4" class="pw-post-body-paragraph io ip hi iq b ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl hb bi translated">回到<code class="du lo lp lq lr b">thenAwait</code>。它调用<em class="jm">promises 5</em>自己的<code class="du lo lp lq lr b">catch</code>(姑且称之为<em class="jm"> catch1.5 </em>)来处理<em class="jm">第三次 catch、</em>之前的任何错误，这是妙处:</p><p id="bfd7" class="pw-post-body-paragraph io ip hi iq b ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl hb bi translated">当<code class="du lo lp lq lr b">singleOfAsync</code>的<code class="du lo lp lq lr b">flatMap</code>计算时，它创建<em class="jm">promises 10</em>(<code class="du lo lp lq lr b">function.apply(t)</code>)<em class="jm"/>，并将其<em class="jm">错误处理程序</em>保存为<em class="jm">promises 5</em>的<em class="jm">异步错误处理程序。<br/> </em>当<em class="jm"> promise10 </em>失败时，<em class="jm"> catch1.5 </em>被调用，其中<em class="jm"> promise5 </em>的<em class="jm">异步错误处理程序</em>为<em class="jm"> not null </em>并且已经持有<em class="jm"> promise10 </em>的<em class="jm">错误处理程序</em>被<em class="jm">调用</em>秩序恢复:)</p><p id="879c" class="pw-post-body-paragraph io ip hi iq b ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl hb bi translated">请注意，如果某些错误发生在<code class="du lo lp lq lr b">thenAsync</code>之前(例如被<em class="jm">第一次捕捉</em>捕捉到)，<em class="jm">承诺 10 </em>尚不存在(！)，因为它是一个延迟初始化的<em class="jm">承诺</em>，它只在<code class="du lo lp lq lr b">thenAwait</code>开始时初始化，也就是在<code class="du lo lp lq lr b">flatMap</code>计算的时候。在那之前，<em class="jm">promises 5</em>的<em class="jm">异步错误处理器</em>仍然是<em class="jm"> null </em>。<br/>同样，由于<em class="jm"> promise10 </em>是<em class="jm">而不是</em>链中的最后一个<em class="jm"> Promise </em>，它将不会处理任何错误(因为我们的<code class="du lo lp lq lr b">catch</code>实现不会影响<code class="du lo lp lq lr b">single</code>，我们执行<em class="jm">错误处理程序</em>的唯一地方是在<code class="du lo lp lq lr b">execute</code>内部)。</p><p id="d740" class="pw-post-body-paragraph io ip hi iq b ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl hb bi translated"><em class="jm">注意:现在名称</em> <code class="du lo lp lq lr b"><em class="jm">asyncErrorConsumer</em></code> <em class="jm">有意义了——它是处理异步任务的错误链的错误处理程序，意思是另一个</em> <code class="du lo lp lq lr b"><em class="jm">Promise</em></code> <em class="jm">。</em></p><p id="1497" class="pw-post-body-paragraph io ip hi iq b ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl hb bi translated">就是这样，真的:)<br/>让我们再来看几个“catch”类型的用法，比如“catchResume”。我们将不会进入细节，因为他们几乎有相同的实现，或者使用一个简单的(像' catchReturn '它只是使用了<em class="jm"> Single </em>的<code class="du lo lp lq lr b">onErrorReturn</code>方法)。</p></div><div class="ab cl ke kf gp kg" role="separator"><span class="kh bw bk ki kj kk"/><span class="kh bw bk ki kj kk"/><span class="kh bw bk ki kj"/></div><div class="hb hc hd he hf"><h1 id="ee34" class="kl km hi bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li bi translated">更有用的“catch”类型</h1><p id="580b" class="pw-post-body-paragraph io ip hi iq b ir lj it iu iv lk ix iy iz ll jb jc jd lm jf jg jh ln jj jk jl hb bi translated">下面是一些更有趣的“catch”从句。<br/>它们还提供了从<em class="jm">异常</em>中恢复的方法，否则该异常会阻止链继续运行。</p><h2 id="4a17" class="mi km hi bd kn mj mk ml kr mm mn mo kv iz mp mq kz jd mr ms ld jh mt mu lh ho bi translated">' catchReturn '</h2><p id="2533" class="pw-post-body-paragraph io ip hi iq b ir lj it iu iv lk ix iy iz ll jb jc jd lm jf jg jh ln jj jk jl hb bi translated">该子句通过提供替代选项<code class="du lo lp lq lr b">T</code>来帮助从错误中恢复，非常类似于‘then’:</p><figure class="jp jq jr js fd jt"><div class="bz dy l di"><div class="ls lt l"/></div></figure><h2 id="f496" class="mi km hi bd kn mj mk ml kr mm mn mo kv iz mp mq kz jd mr ms ld jh mt mu lh ho bi translated">'捕捉简历'</h2><p id="c967" class="pw-post-body-paragraph io ip hi iq b ir lj it iu iv lk ix iy iz ll jb jc jd lm jf jg jh ln jj jk jl hb bi translated">该子句通过提供另一种选择<code class="du lo lp lq lr b">Promise&lt;T&gt;</code>来帮助从错误中恢复，很像‘thenAwait’:</p><figure class="jp jq jr js fd jt"><div class="bz dy l di"><div class="ls lt l"/></div></figure><h2 id="0b0f" class="mi km hi bd kn mj mk ml kr mm mn mo kv iz mp mq kz jd mr ms ld jh mt mu lh ho bi translated">'捕捉忽略'</h2><p id="c3a5" class="pw-post-body-paragraph io ip hi iq b ir lj it iu iv lk ix iy iz ll jb jc jd lm jf jg jh ln jj jk jl hb bi translated">这一条用得较少，但仍值得一提。当你想继续某个链时，它会有所帮助，不管它“到目前为止”是否成功——它总是映射到一个<code class="du lo lp lq lr b">Unit</code>。<br/>注意:除非有更多相关的“然后”和“抓住”向下链，通常最好是在<em class="jm">承诺</em>完成时使用<code class="du lo lp lq lr b">finally</code>做动作，不管成功/失败。</p><figure class="jp jq jr js fd jt"><div class="bz dy l di"><div class="ls lt l"/></div></figure></div><div class="ab cl ke kf gp kg" role="separator"><span class="kh bw bk ki kj kk"/><span class="kh bw bk ki kj kk"/><span class="kh bw bk ki kj"/></div><div class="hb hc hd he hf"><h2 id="8934" class="mi km hi bd kn mj mk ml kr mm mn mo kv iz mp mq kz jd mr ms ld jh mt mu lh ho bi translated">然后映射或取消'，'然后映射或弹出'</h2><p id="b68a" class="pw-post-body-paragraph io ip hi iq b ir lj it iu iv lk ix iy iz ll jb jc jd lm jf jg jh ln jj jk jl hb bi translated">在我们结束之前，我还想介绍一些“那时”的版本。这些版本也可以很容易地为“catch”子句创建，但是由于我从来不需要它们，它们还没有出现在源代码中:)<br/>像“thenMapOrCancel”、“thenAwaitOrReject”(等等。)当你不能预先知道你是否能够提供一个价值(或一个<em class="jm">承诺</em>)时，你可以通过取消或拒绝来打破这个链条:</p><figure class="jp jq jr js fd jt"><div class="bz dy l di"><div class="ls lt l"/></div></figure><h2 id="406e" class="mi km hi bd kn mj mk ml kr mm mn mo kv iz mp mq kz jd mr ms ld jh mt mu lh ho bi translated">“终于”</h2><p id="188f" class="pw-post-body-paragraph io ip hi iq b ir lj it iu iv lk ix iy iz ll jb jc jd lm jf jg jh ln jj jk jl hb bi translated">正因为我不能写一篇关于一个<em class="jm">承诺</em>的文章而不展示这个(虽然已经在一些例子中展示过)，这里是‘最终’，它被称为<em class="jm">总是</em>，不管取消、成功还是拒绝:</p><figure class="jp jq jr js fd jt"><div class="bz dy l di"><div class="ls lt l"/></div></figure></div><div class="ab cl ke kf gp kg" role="separator"><span class="kh bw bk ki kj kk"/><span class="kh bw bk ki kj kk"/><span class="kh bw bk ki kj"/></div><div class="hb hc hd he hf"><h1 id="0d2f" class="kl km hi bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li bi translated">摘要</h1><p id="871b" class="pw-post-body-paragraph io ip hi iq b ir lj it iu iv lk ix iy iz ll jb jc jd lm jf jg jh ln jj jk jl hb bi translated">所以这就结束了纯 Kotlin 的<em class="jm"> Promise </em>模型。我真的希望你喜欢它，它教会了你一些新的东西。请在下面的评论中写下你的想法。</p><p id="01cf" class="pw-post-body-paragraph io ip hi iq b ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl hb bi translated">下一章将关注<em class="jm"> APromise </em>，它是一个扩展类，支持<em class="jm"> Android </em>上下文(<em class="jm">视图，活动</em>)。这相当于使用<em class="jm"> Kotlin 协程</em>的<em class="jm">【Scope】</em>来自动<em class="jm">取消</em>一个不再相关的<em class="jm">上下文链。</em>希望未来的版本也能支持 iOS(IPromise)——前提是底层的<em class="jm">承诺</em>是用纯<em class="jm"> Kotlin </em>编写的。</p><p id="849e" class="pw-post-body-paragraph io ip hi iq b ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl hb bi translated">在这下一章之后，我们将结束反应式架构的<em class="jm">承诺</em>部分，并深入到核心库<em class="jm"> Reactdroid。<br/> </em>正如他们所说…这只是开始…</p><p id="e98d" class="pw-post-body-paragraph io ip hi iq b ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl hb bi translated">过得好；)</p><p id="4f56" class="pw-post-body-paragraph io ip hi iq b ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl hb bi translated">编辑:<a class="ae jn" rel="noopener" href="/@gguymi/9522adda8b5a">下一部出来了！</a></p></div></div>    
</body>
</html>