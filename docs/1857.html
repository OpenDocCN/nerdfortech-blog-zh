<html>
<head>
<title>Decodable helper that can save you some time</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">可解码的助手，可以节省你一些时间</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/decodable-helper-that-can-save-you-some-time-830e51d01fcf?source=collection_archive---------14-----------------------#2021-04-10">https://medium.com/nerd-for-tech/decodable-helper-that-can-save-you-some-time-830e51d01fcf?source=collection_archive---------14-----------------------#2021-04-10</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/39aa9840b79d1bb21e182399d3cbb471.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lNcr5FnERufAFHxtNXUWGQ.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">照片由<a class="ae iu" href="https://unsplash.com/@aronvisuals?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Aron 视觉效果</a>在<a class="ae iu" href="https://unsplash.com/s/photos/time?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure></div><div class="ab cl iv iw gp ix" role="separator"><span class="iy bw bk iz ja jb"/><span class="iy bw bk iz ja jb"/><span class="iy bw bk iz ja"/></div><div class="hb hc hd he hf"><p id="27ed" class="pw-post-body-paragraph jc jd hi je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hb bi translated">编写一个 iOS 应用程序几乎总是涉及到将来自后端响应或 JSON 文件的数据解析成我们领域的结构或类，因此，解码数据应该尽可能地干净、容易出错和透明。</p><h2 id="ea94" class="ka kb hi bd kc kd ke kf kg kh ki kj kk jn kl km kn jr ko kp kq jv kr ks kt ku bi translated">问题是</h2><pre class="kv kw kx ky fd kz la lb lc aw ld bi"><span id="bdd5" class="ka kb hi la b fi le lf l lg lh">// 1. Parsing the json (wherever it comes from) to data<br/>let jsonData = JSON.data(using: .utf8)!</span><span id="b1ea" class="ka kb hi la b fi li lf l lg lh">// 2. Decoding the data to the actual structure<br/>let fact = try! JSONDecoder().decode(CatFact.self, from: jsonData)</span></pre><p id="7d73" class="pw-post-body-paragraph jc jd hi je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hb bi translated">这是“最”常用的方法，但是，这两行是强制解包值，由于可能发生“意外”的崩溃，不建议在生产中使用。为了避免这种情况，让我们使用可选绑定以更安全的方式来实现。</p><pre class="kv kw kx ky fd kz la lb lc aw ld bi"><span id="b58b" class="ka kb hi la b fi le lf l lg lh">guard let jsonData = JSON.data(JSON.data(using: .utf8)) else {<br/>    return nil<br/>}</span><span id="0891" class="ka kb hi la b fi li lf l lg lh">do {<br/>    let fact = try JSONDecoder().decode(CatFact.self, from: jsonData)<br/>    return fact<br/>}<br/>catch {<br/>    print(error.localizedDescription)<br/>    return nil<br/>}</span></pre><p id="f5c4" class="pw-post-body-paragraph jc jd hi je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hb bi translated">是的，但不是，因为现在在项目中的每个请求或服务中编写这段代码已经变得很乏味了。然而，考虑到所有符合协议解码的结构和类都可以被重构，让我们把这个片段移到协议本身的一个静态函数中。</p><h2 id="bb4d" class="ka kb hi bd kc kd ke kf kg kh ki kj kk jn kl km kn jr ko kp kq jv kr ks kt ku bi translated">一个可能的解决方案</h2><pre class="kv kw kx ky fd kz la lb lc aw ld bi"><span id="ca02" class="ka kb hi la b fi le lf l lg lh">extension Decodable {<br/>    static func parse(from data: Data?) -&gt; Self? {<br/>        // ...<br/>        return nil<br/>    }<br/>}</span><span id="6b42" class="ka kb hi la b fi li lf l lg lh">// We can now use it as follows<br/>let fact = CatFat.parse(from: JSON.data)<br/>print(fact)</span></pre><p id="161e" class="pw-post-body-paragraph jc jd hi je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hb bi translated">这似乎只适用于数据，为了改进这一点，让我们通过接受任何类型来增加扩展的灵活性，这样我们就可以从几乎任何 JSON 内容到所需的对象解析它。让我们看看<code class="du lj lk ll la b">data(from: Any?)</code>函数的实现，它将检查不同类型的内容，并返回数据中的对等内容。</p><pre class="kv kw kx ky fd kz la lb lc aw ld bi"><span id="fd47" class="ka kb hi la b fi le lf l lg lh">extension Decodable {<br/>    static func parse(from item: Any?) -&gt; Self? {<br/>        // ...<br/>    }<br/>    <br/>    private static func data(from item: Any?) -&gt; Data? {<br/>        switch item {<br/>        case let data as Data:<br/>            return data<br/>        case let string as String:<br/>            return string.data(using: .utf8)<br/>        case let item?:<br/>            return try? JSONSerialization.data(withJSONObject: item, options: [])<br/>        default:<br/>            return nil<br/>        }<br/>    }<br/>}</span></pre><h2 id="64cd" class="ka kb hi bd kc kd ke kf kg kh ki kj kk jn kl km kn jr ko kp kq jv kr ks kt ku bi translated">改进解决方案</h2><p id="172f" class="pw-post-body-paragraph jc jd hi je b jf lm jh ji jj ln jl jm jn lo jp jq jr lp jt ju jv lq jx jy jz hb bi translated">在将所有内容放在一起之前，还有一件事需要考虑，如果 JSON 的内容中的键是用 snake case 而不是 iOS camel case 约定编写的，会发生什么情况。让我们在默认情况下用 camel case 为 parse 函数添加一个小的<code class="du lj lk ll la b">KeyDecodingStrategy</code>可选参数。</p><pre class="kv kw kx ky fd kz la lb lc aw ld bi"><span id="3dd1" class="ka kb hi la b fi le lf l lg lh">extension Decodable {<br/>    static func parse(from item: Any?, strategy: JSONDecoder.KeyDecodingStrategy = .useDefaultKeys) -&gt; Self? {<br/>        // 1. Sets the decoding strategy to the decoder<br/>        let decoder = JSONDecoder()<br/>        decoder.keyDecodingStrategy = strategy<br/>        <br/>        // ..<br/>    }<br/>    <br/>    private static func data(from item: Any?) -&gt; Data? {<br/>        // ...<br/>    }<br/>}</span></pre><h2 id="f827" class="ka kb hi bd kc kd ke kf kg kh ki kj kk jn kl km kn jr ko kp kq jv kr ks kt ku bi translated">整个扩展</h2><figure class="kv kw kx ky fd ij"><div class="bz dy l di"><div class="lr ls l"/></div></figure></div><div class="ab cl iv iw gp ix" role="separator"><span class="iy bw bk iz ja jb"/><span class="iy bw bk iz ja jb"/><span class="iy bw bk iz ja"/></div><div class="hb hc hd he hf"><h2 id="a173" class="ka kb hi bd kc kd ke kf kg kh ki kj kk jn kl km kn jr ko kp kq jv kr ks kt ku bi translated">一个简单的例子</h2><figure class="kv kw kx ky fd ij"><div class="bz dy l di"><div class="lr ls l"/></div></figure><ol class=""><li id="9e65" class="lt lu hi je b jf jg jj jk jn lv jr lw jv lx jz ly lz ma mb bi translated">结构的定义和符合可解码的协议。</li><li id="8528" class="lt lu hi je b jf mc jj md jn me jr mf jv mg jz ly lz ma mb bi translated">可以有嵌套结构，只要它们也是可解码的。</li><li id="586b" class="lt lu hi je b jf mc jj md jn me jr mf jv mg jz ly lz ma mb bi translated">SwiftUI 是二手的，但也可以是我们很好的老式 UIKit。</li><li id="ac71" class="lt lu hi je b jf mc jj md jn me jr mf jv mg jz ly lz ma mb bi translated">数据来自静态字典，但也可能来自文件、后端响应或任何其他 JSON 类型的内容。</li><li id="63e9" class="lt lu hi je b jf mc jj md jn me jr mf jv mg jz ly lz ma mb bi translated">这是我们如何使用我们漂亮的扩展，它看起来干净易懂。可解码的数组也可以解析，只是免费的😉</li></ol></div><div class="ab cl iv iw gp ix" role="separator"><span class="iy bw bk iz ja jb"/><span class="iy bw bk iz ja jb"/><span class="iy bw bk iz ja"/></div><div class="hb hc hd he hf"><p id="6065" class="pw-post-body-paragraph jc jd hi je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hb bi translated"><em class="mh">感谢阅读。我希望你喜欢这段代码，如果它对你有用，不要害羞👏关于这篇文章。下次见。</em></p></div></div>    
</body>
</html>