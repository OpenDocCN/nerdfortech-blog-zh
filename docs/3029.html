<html>
<head>
<title>Carousel slider tutorial with HTML, CSS and JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">包含 HTML、CSS 和 JavaScript 的轮播滑块教程</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/carousel-slider-tutorial-with-html-css-and-javascript-373b6d308617?source=collection_archive---------13-----------------------#2021-05-27">https://medium.com/nerd-for-tech/carousel-slider-tutorial-with-html-css-and-javascript-373b6d308617?source=collection_archive---------13-----------------------#2021-05-27</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/99ffa8b9c0922da3f8c4ca75284fd460.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*1K52YJo3Kdw9UKi3.jpg"/></div></div></figure><p id="55df" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在这篇文章中，我们将看看如何用 HTML、CSS 和 JavaScript 制作一个简单的旋转木马。我们将使用良好的代码实践，牢记可访问性，并考虑如何测试 carousel。</p><p id="227b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">传送带将是一个“移动传送带”。幻灯片将从左到右或从右到左移动，并带有过渡。它不会是一个原地旋转，一张幻灯片淡出，而另一张幻灯片淡入。</p><p id="2f82" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如果你喜欢视频版本，这就是。它比这篇文章更详细。</p><figure class="jo jp jq jr fd ij"><div class="bz dy l di"><div class="js jt l"/></div></figure><h1 id="d3df" class="ju jv hi bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">基本功能</h1><p id="83c5" class="pw-post-body-paragraph iq ir hi is b it ks iv iw ix kt iz ja jb ku jd je jf kv jh ji jj kw jl jm jn hb bi translated">我们将从基本功能开始。这就是基本的 HTML、CSS 和 JavaScript。</p><h1 id="a62d" class="ju jv hi bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">超文本标记语言</h1><p id="da08" class="pw-post-body-paragraph iq ir hi is b it ks iv iw ix kt iz ja jb ku jd je jf kv jh ji jj kw jl jm jn hb bi translated">我们将保持 HTML 相当简单。我们基本上需要:</p><ul class=""><li id="a870" class="kx ky hi is b it iu ix iy jb kz jf la jj lb jn lc ld le lf bi translated">旋转木马的容器</li><li id="b613" class="kx ky hi is b it lg ix lh jb li jf lj jj lk jn lc ld le lf bi translated">旋转式控件</li><li id="127e" class="kx ky hi is b it lg ix lh jb li jf lj jj lk jn lc ld le lf bi translated">幻灯片</li></ul><p id="9ce8" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">除了旋转木马之外，我们不会过多关注 HTML 头或任何其他东西。其余的都是标准的东西。</p><p id="6e38" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">至于实际的旋转木马，这里有一些我们可以使用的 HTML。</p><pre class="jo jp jq jr fd ll lm ln lo aw lp bi"><span id="bfd6" class="lq jv hi lm b fi lr ls l lt lu">&lt;head&gt;<br/>&lt;!-- Import font-awesome somewhere in the HTML --&gt;<br/>  &lt;link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/all.min.css" integrity="sha512-iBBXm8fW90+nuLcSKlbmrPcLa0OT92xO1BIsZ+ywDWZCvqsWgccV3gFoRBv0z+8dLJgyAHIhR35VZc2oM/gI1w==" crossorigin="anonymous" referrerpolicy="no-referrer" /&gt;<br/>  &lt;link rel="stylesheet" href="./index.css"&gt;<br/>&lt;/head&gt;<br/><br/>&lt;body&gt;<br/>  &lt;div class="carousel" data-carousel&gt;<br/>    &lt;div class="carousel-buttons"&gt;<br/>      &lt;button<br/>        class="carousel-button carousel-button_previous"<br/>        data-carousel-button-previous<br/>      &gt;<br/>        &lt;span class="fas fa-chevron-circle-left"&gt;&lt;/span&gt;<br/>      &lt;/button&gt;<br/>      &lt;button<br/>        class="carousel-button carousel-button_next"<br/>        data-carousel-button-next<br/>      &gt;<br/>        &lt;span class="fas fa-chevron-circle-right"&gt;&lt;/span&gt;<br/>      &lt;/button&gt;<br/>    &lt;/div&gt;<br/>    &lt;div class="slides" data-carousel-slides-container&gt;<br/>      &lt;div class="slide"&gt;<br/>        &lt;!-- Anything can be here. Each slide can have any content --&gt;<br/>        &lt;h2&gt;Slide 1 heading&lt;/h2&gt;<br/>        &lt;p&gt;Slide 1 content<br/>      &lt;/div&gt;<br/>      &lt;div class="slide"&gt;<br/>        &lt;!-- Anything can be here. Each slide can have any content --&gt;<br/>        &lt;h2&gt;Slide 2 heading&lt;/h2&gt;<br/>        &lt;p&gt;Slide 2 content<br/>      &lt;/div&gt;<br/>    &lt;/div&gt;<br/>  &lt;/div&gt;<br/>&lt;/body&gt;</span></pre><p id="9819" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在头部，我们链接了字体 awesome 和自定义样式 CSS 文件。</p><p id="298b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在正文中:</p><ul class=""><li id="a1ea" class="kx ky hi is b it iu ix iy jb kz jf la jj lb jn lc ld le lf bi translated">我们为整个传送带准备了一个外部<code class="du lv lw lx lm b">div</code>。</li><li id="7600" class="kx ky hi is b it lg ix lh jb li jf lj jj lk jn lc ld le lf bi translated">我们有两个按钮，一个用于“上一张幻灯片”，一个用于“下一张幻灯片”。按钮使用字体很棒的图标。</li><li id="89e8" class="kx ky hi is b it lg ix lh jb li jf lj jj lk jn lc ld le lf bi translated">我们为幻灯片准备了一个<code class="du lv lw lx lm b">div</code>。在里面，我们为每张幻灯片都准备了一个<code class="du lv lw lx lm b">div</code>。每张幻灯片中的内容与我们无关，可以是任何内容。</li></ul><p id="09dc" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">至于<code class="du lv lw lx lm b">data-</code>属性，我们将在 JavaScript 中使用它们作为选择器。</p><p id="cb6b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我个人更喜欢对 JavaScript 使用<code class="du lv lw lx lm b">data-</code>属性，因为我想分离关注点。例如，类是 CSS 的标准用法。当将来有人试图改变 carousel 的样式时，他们可能会用一个更具描述性的名称来替换类名。他们可能还会改变一些 CSS 修饰符类什么的。我不希望他们偏执地认为，如果他们改变 CSS，他们可能会破坏 JavaScript，或者自动化测试，或者异步内容插入，或者其他任何东西。我希望他们在使用 CSS 时有安全感。</p><p id="0c48" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这意味着，在 JavaScript 中，我不使用类来选择元素。</p><p id="b15f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">一个例外是如果你使用带有前缀的类，比如<code class="du lv lw lx lm b">js-</code>。例如<code class="du lv lw lx lm b">&lt;div class="js-carousel"&gt;&lt;/div&gt;</code>，专门供 JavaScript 使用。那达到同样的结果。</p><p id="0889" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">但是我的偏好是使用<code class="du lv lw lx lm b">data-</code>属性。这就是<code class="du lv lw lx lm b">data-carousel</code>和其他人的目的。</p><h1 id="511f" class="ju jv hi bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">半铸钢ˌ钢性铸铁(Cast Semi-Steel)</h1><p id="1bab" class="pw-post-body-paragraph iq ir hi is b it ks iv iw ix kt iz ja jb ku jd je jf kv jh ji jj kw jl jm jn hb bi translated">我们的 CSS:</p><ol class=""><li id="a217" class="kx ky hi is b it iu ix iy jb kz jf la jj lb jn ly ld le lf bi translated">将会是我们旋转木马的基本造型</li><li id="5f31" class="kx ky hi is b it lg ix lh jb li jf lj jj lk jn ly ld le lf bi translated">将会有更换幻灯片的机制</li></ol><p id="82df" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们的旋转木马的工作方式是让所有的幻灯片水平并排放置。但是，一次只能放映一张幻灯片。这是因为除了可见的那张幻灯片之外，每张幻灯片都将溢出顶层传送带<code class="du lv lw lx lm b">div</code>。那个<code class="du lv lw lx lm b">div</code>会有<code class="du lv lw lx lm b">overflow: hidden</code>，所以溢出的东西不会显示出来。</p><p id="42e2" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们将用线<code class="du lv lw lx lm b">transform: translateX(/* something */)</code>决定当前正在播放哪张幻灯片。这样，我们将翻译<code class="du lv lw lx lm b">slides</code> div，以便只有正确的幻灯片是可见的。</p><p id="09a5" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这是 CSS。</p><pre class="jo jp jq jr fd ll lm ln lo aw lp bi"><span id="401f" class="lq jv hi lm b fi lr ls l lt lu">.carousel {<br/>  --current-slide: 0;<br/>  /* we set position relative so absolute position works properly for the buttons */<br/>  position: relative;<br/>  overflow: hidden;<br/>}<br/><br/>.carousel-button {<br/>  /* vertically centering the buttons */<br/>  position: absolute;<br/>  top: 50%;<br/>  transform: translateY(-50%);<br/>  z-index: 1;<br/><br/>  /* basic styling */<br/>  padding: 0;<br/>  margin: 0.5rem;<br/>  border-radius: 50%;<br/>  background-color: transparent;<br/>  border: none;<br/><br/>  font-size: 1.5rem;<br/>  cursor: pointer;<br/><br/>  transition: color 0.1s;<br/>}<br/><br/>.carousel-button:hover {<br/>  color: rgba(0, 0, 0, 0.5);<br/>}<br/><br/>.carousel-button_next {<br/>  /* The "next slide button" will be at the right */<br/>  right: 0;<br/>}<br/><br/>.slides {<br/>  display: flex;<br/>  transition: transform 0.5s;<br/>  transform: translateX(calc(-100% * var(--current-slide)));<br/>}<br/><br/>.slide {<br/>  flex: 0 0 100%;<br/>}<br/><br/>@media screen and (min-width: 768px) {<br/>  .carousel-button {<br/>    font-size: 2rem;<br/>    margin: 1rem;<br/>  }<br/>}</span></pre><p id="feb1" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">有了这个 CSS，每个<code class="du lv lw lx lm b">div</code>都有默认的 100%宽度。这意味着转盘将占据其父容器的整个宽度。每个载玻片也将占据转盘的整个宽度。</p><h2 id="d945" class="lq jv hi bd jw lz ma mb ka mc md me ke jb mf mg ki jf mh mi km jj mj mk kq ml bi translated">控制</h2><p id="181a" class="pw-post-body-paragraph iq ir hi is b it ks iv iw ix kt iz ja jb ku jd je jf kv jh ji jj kw jl jm jn hb bi translated">在<code class="du lv lw lx lm b">carousel-button</code>类中，我们为按钮提供了一些简单的样式。我们使用字体很棒的图标，所以我们给它们一个字体大小，这样它们就大而可见。我们还移除了一些默认的按钮样式(比如边框和背景色)。</p><p id="4c15" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">此外，我们将按钮放置在整个转盘的中间(垂直方向)。我们通过使用<code class="du lv lw lx lm b">position: absolute; top: 50%; transform: translateY(-50%);</code>技巧来做到这一点。</p><h2 id="5b51" class="lq jv hi bd jw lz ma mb ka mc md me ke jb mf mg ki jf mh mi km jj mj mk kq ml bi translated">更换幻灯片</h2><p id="7731" class="pw-post-body-paragraph iq ir hi is b it ks iv iw ix kt iz ja jb ku jd je jf kv jh ji jj kw jl jm jn hb bi translated">转盘如何改变幻灯片的诀窍在于<code class="du lv lw lx lm b">.slides</code>和<code class="du lv lw lx lm b">.slide</code>中的 CSS。在<code class="du lv lw lx lm b">.slide</code>中，我们让每张幻灯片的宽度为转盘宽度的 100%。这是通过<code class="du lv lw lx lm b">flex</code>属性完成的。换句话说，一个载玻片将占据转盘的整个宽度。</p><p id="e19a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">由于<code class="du lv lw lx lm b">.slides</code>是<code class="du lv lw lx lm b">display: flex;</code>，所有的载玻片将彼此水平相邻。这意味着一个载玻片将占据转盘的整个宽度，所有其他载玻片将在它旁边水平溢出。转盘 div 有<code class="du lv lw lx lm b">overflow: hidden;</code>，所以溢出的幻灯片都不会显示。</p><p id="2b2f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在某个时候，使用 JavaScript，我们将把<code class="du lv lw lx lm b">.slides</code> div 移到右边或左边。这意味着载玻片会移动，因此转盘内会出现不同的载玻片。</p><p id="2d2b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">宣言<code class="du lv lw lx lm b">transform: translateX(calc(-100% * var(--current-slide)));</code>是我们的运动机制。这里我们说将幻灯片容器-100%(转盘的全宽，或幻灯片的全宽)向左移动(负号表示向左)，移动的次数与我们所在的幻灯片索引一样多。</p><p id="3553" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">例如，如果我们在幻灯片索引 0(第一张幻灯片)，<code class="du lv lw lx lm b">-100% * 0</code> = 0，那么我们根本不翻译，第一张幻灯片是可见的。</p><p id="7c31" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如果我们在幻灯片索引 1(第二张幻灯片)上，那么`-100% * 1` = -100%，所以我们向左平移 100%(一张幻灯片的宽度)。这意味着我们正在展示第二张幻灯片。</p><p id="de06" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们将使用 JavaScript 设置<code class="du lv lw lx lm b">--current-slide</code>属性。</p><h1 id="d0a8" class="ju jv hi bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">Java Script 语言</h1><p id="a046" class="pw-post-body-paragraph iq ir hi is b it ks iv iw ix kt iz ja jb ku jd je jf kv jh ji jj kw jl jm jn hb bi translated">我们的 JavaScript 需要:</p><ul class=""><li id="7df0" class="kx ky hi is b it iu ix iy jb kz jf la jj lb jn lc ld le lf bi translated">处理两个按钮的事件(切换到上一张幻灯片和下一张幻灯片)</li><li id="11a4" class="kx ky hi is b it lg ix lh jb li jf lj jj lk jn lc ld le lf bi translated">为页面上任意数量的不同转盘独立工作</li></ul><p id="7073" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这是 JavaScript 代码。</p><pre class="jo jp jq jr fd ll lm ln lo aw lp bi"><span id="837b" class="lq jv hi lm b fi lr ls l lt lu">function modulo(number, mod) {<br/>  let result = number % mod;<br/>  if (result &lt; 0) {<br/>    result += mod;<br/>  }<br/>  return result;<br/>}<br/><br/>function setUpCarousel(carousel) {<br/>  function handleNext() {<br/>    currentSlide = modulo(currentSlide + 1, numSlides);<br/>    changeSlide(currentSlide);<br/>  }<br/><br/>  function handlePrevious() {<br/>    currentSlide = modulo(currentSlide - 1, numSlides);<br/>    changeSlide(currentSlide);<br/>  }<br/><br/>  function changeSlide(slideNumber) {<br/>    carousel.style.setProperty('--current-slide', slideNumber);<br/>  }<br/><br/>  // get elements<br/>  const buttonPrevious = carousel.querySelector('[data-carousel-button-previous]');<br/>  const buttonNext = carousel.querySelector('[data-carousel-button-next]');<br/>  const slidesContainer = carousel.querySelector('[data-carousel-slides-container]');<br/><br/>  // carousel state we need to remember<br/>  let currentSlide = 0;<br/>  const numSlides = slidesContainer.children.length;<br/><br/>  // set up events<br/>  buttonPrevious.addEventListener('click', handlePrevious);<br/>  buttonNext.addEventListener('click', handleNext);<br/>}<br/><br/>const carousels = document.querySelectorAll('[data-carousel]');<br/>carousels.forEach(setUpCarousel);</span></pre><p id="b70c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">由于嵌套的函数，这段代码可能会显得有点混乱。如果你不习惯这种语法，那么这里有一个<code class="du lv lw lx lm b">setUpCarousel</code>函数的替代类，它做完全相同的事情。</p><pre class="jo jp jq jr fd ll lm ln lo aw lp bi"><span id="d93f" class="lq jv hi lm b fi lr ls l lt lu">class Carousel {<br/>  constructor(carousel) {<br/>    // find elements<br/>    this.carousel = carousel;<br/>    this.buttonPrevious = carousel.querySelector('[data-carousel-button-previous]');<br/>    this.buttonNext = carousel.querySelector('[data-carousel-button-next]');<br/>    this.slidesContainer = carousel.querySelector('[data-carousel-slides-container]');<br/><br/>    // state<br/>    this.currentSlide = 0;<br/>    this.numSlides = this.slidesContainer.children.length;<br/><br/>    // add events<br/>    this.buttonPrevious.addEventListener('click', this.handlePrevious.bind(this));<br/>    this.buttonNext.addEventListener('click', this.handleNext.bind(this));<br/>  }<br/><br/>  handleNext() {<br/>    this.currentSlide = modulo(this.currentSlide + 1, this.numSlides);<br/>    this.carousel.style.setProperty('--current-slide', this.currentSlide);<br/>  }<br/><br/>  handlePrevious() {<br/>    this.currentSlide = modulo(this.currentSlide - 1, this.numSlides);<br/>    this.carousel.style.setProperty('--current-slide', this.currentSlide);<br/>  }<br/>}<br/><br/>const carousels = document.querySelectorAll('[data-carousel]');<br/>carousels.forEach(carousel =&gt; new Carousel(carousel));</span></pre><p id="94c3" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">基本上，我们持有一些状态，<code class="du lv lw lx lm b">currentSlide</code>和<code class="du lv lw lx lm b">numSlides</code>变量。我们还保存了对一些 HTML 元素的引用，比如 carousel 元素，因为我们在更换幻灯片时会用到它们。最后，我们向按钮添加事件侦听器。</p><p id="6b85" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">当用户点击“下一张幻灯片”按钮时，我们运行<code class="du lv lw lx lm b">handleNext</code>功能。对<code class="du lv lw lx lm b">modulo(currentSlide, numSlides)</code>的调用将<code class="du lv lw lx lm b">currentSlide</code>设置为下一张幻灯片的正确索引。因此，如果有 5 张幻灯片，并且我们在幻灯片索引 0 上，它会将<code class="du lv lw lx lm b">currentSlide</code>设置为 1。但是，如果我们已经在幻灯片索引 4(第五张也是最后一张幻灯片)上，那么下一张幻灯片索引是 0，而不是 5。模函数为我们处理回 0 的包装。</p><p id="7ee1" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">实际上，我们可以使用<code class="du lv lw lx lm b">%</code>(模)操作符来实现这个目的。我们之所以有<code class="du lv lw lx lm b">modulo</code>函数，是因为<code class="du lv lw lx lm b">%</code>不擅长处理负数。<code class="du lv lw lx lm b">-1 % 5</code>评估为<code class="du lv lw lx lm b">-1</code>，而不是<code class="du lv lw lx lm b">4</code>(我们实际想要的幻灯片的索引)。我们创建了自己的<code class="du lv lw lx lm b">modulo</code>函数来处理这种情况。</p><p id="3406" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">最后，我们将 CSS 属性<code class="du lv lw lx lm b">--current-slide</code>设置为正确的数字。然后，CSS 通过适当地平移幻灯片<code class="du lv lw lx lm b">div</code>来改变可见的幻灯片。</p><p id="3981" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">页面上不同传送带的独立性是因为我们在父传送带元素上使用了<code class="du lv lw lx lm b">querySelector</code>，而不是在<code class="du lv lw lx lm b">document</code>上。这意味着，举例来说，<code class="du lv lw lx lm b">carouselElement1.querySelector([data-carousel-button-next])</code>，将只得到那个 carousel 元素里面的按钮。而<code class="du lv lw lx lm b">document.querySelector('[data-carousel-button-next]')</code>将获得它在页面上找到的第一个匹配元素，而不是目标轮播。</p><h1 id="2853" class="ju jv hi bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">易接近</h1><p id="5c81" class="pw-post-body-paragraph iq ir hi is b it ks iv iw ix kt iz ja jb ku jd je jf kv jh ji jj kw jl jm jn hb bi translated">目前，这个转盘对屏幕阅读器用户非常不友好。您将需要实际使用屏幕阅读器并亲自聆听(或观看嵌入视频的可访问性部分)，但基本上:</p><ul class=""><li id="ddc4" class="kx ky hi is b it iu ix iy jb kz jf la jj lb jn lc ld le lf bi translated">它没有提到任何关于内容是一个传送带</li><li id="05ce" class="kx ky hi is b it lg ix lh jb li jf lj jj lk jn lc ld le lf bi translated">对于按钮，它只显示“button”而没有其他内容(因为按钮没有文本或标签)</li><li id="d421" class="kx ky hi is b it lg ix lh jb li jf lj jj lk jn lc ld le lf bi translated">在“自动阅读”模式下，它会通读每张幻灯片的所有内容，就好像它是一个充满文本的普通网页一样(因为我们并没有告诉它只阅读可见的幻灯片)</li></ul><p id="3f6f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">要解决这些问题，我们需要查阅<a class="ae mm" href="https://www.w3.org/TR/wai-aria-practices-1.1/" rel="noopener ugc nofollow" target="_blank"> WAI-ARIA 创作实践文档</a>。有一个旋转木马区。我们只是去那里，并按照指示。其实也不是太难。它为我们提供了一步一步的指导。</p><p id="6b0c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">最后，我们的 HTML 看起来像这样:</p><pre class="jo jp jq jr fd ll lm ln lo aw lp bi"><span id="4224" class="lq jv hi lm b fi lr ls l lt lu">&lt;div<br/>  class="carousel"<br/>  aria-role="group"<br/>  aria-roledescription="carousel"<br/>  aria-label="Student testimonials"<br/>  data-carousel<br/>&gt;<br/>  &lt;div class="carousel-buttons"&gt;<br/>    &lt;button<br/>      class="carousel-button carousel-button_previous"<br/>      aria-label="Previous slide"<br/>      data-carousel-button-previous<br/>    &gt;<br/>      &lt;span class="fas fa-chevron-circle-left"&gt;&lt;/span&gt;<br/>    &lt;/button&gt;<br/>    &lt;button<br/>      class="carousel-button carousel-button_next"<br/>      aria-label="Next slide"<br/>      data-carousel-button-next<br/>    &gt;<br/>      &lt;span class="fas fa-chevron-circle-right"&gt;&lt;/span&gt;<br/>    &lt;/button&gt;<br/>  &lt;/div&gt;<br/>  &lt;div<br/>    class="slides"<br/>    aria-live="polite"<br/>    data-carousel-slides-container<br/>  &gt;<br/>    &lt;div<br/>      class="slide"<br/>      aria-role="group"<br/>      aria-roledescription="slide"<br/>      aria-hidden="false"<br/>      aria-labelledby="bob"<br/>    &gt;<br/>      &lt;h2 id="bob"&gt;Bob&lt;/h2&gt;<br/>    &lt;/div&gt;<br/><br/>    &lt;div<br/>      class="slide"<br/>      aria-role="group"<br/>      aria-roledescription="slide"<br/>      aria-hidden="true"<br/>      aria-labelledby="alice"<br/>    &gt;<br/>      &lt;h2 id="alice"&gt;Alice&lt;/h2&gt;<br/>    &lt;/div&gt;<br/>  &lt;/div&gt;<br/>&lt;/div&gt;</span></pre><p id="331e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们所做的事情的简要总结是:</p><ul class=""><li id="9f86" class="kx ky hi is b it iu ix iy jb kz jf la jj lb jn lc ld le lf bi translated">我们给转盘<code class="du lv lw lx lm b">div</code>增加了<code class="du lv lw lx lm b">aria-role</code>、<code class="du lv lw lx lm b">aria-roledescription</code>和<code class="du lv lw lx lm b">aria-label</code>。现在，屏幕阅读器说类似“学生奖状转盘”的东西，立即表明这是一个转盘，以及它代表什么内容。</li><li id="9595" class="kx ky hi is b it lg ix lh jb li jf lj jj lk jn lc ld le lf bi translated">对于每个按钮，我们都添加了一个<code class="du lv lw lx lm b">aria-label</code>。现在屏幕阅读器显示类似“按钮上一张幻灯片”的内容，而不仅仅是“按钮”。(这里的另一种技术是添加“仅屏幕阅读器文本”。这是存在于 HTML 中的文本，但是使用特定的方法隐藏起来。)</li><li id="05cd" class="kx ky hi is b it lg ix lh jb li jf lj jj lk jn lc ld le lf bi translated">我们给每张幻灯片添加了一个<code class="du lv lw lx lm b">aria-role</code>和<code class="du lv lw lx lm b">aria-roledescription</code>。现在屏幕阅读器知道它何时进入或离开幻灯片，并在必要时通知用户。</li><li id="4d7f" class="kx ky hi is b it lg ix lh jb li jf lj jj lk jn lc ld le lf bi translated">我们还使用<code class="du lv lw lx lm b">aria-labelledby</code>为每张幻灯片添加了一个标签。这与<code class="du lv lw lx lm b">aria-label</code>相同，只是您使用 HTML ID 将它指向页面上已经存在的一些文本。在这种情况下，由于我们的标签已经存在于页面上(每张幻灯片的标题)，我们使用了<code class="du lv lw lx lm b">aria-labelledby</code>而不是<code class="du lv lw lx lm b">aria-label</code>。</li><li id="8d3a" class="kx ky hi is b it lg ix lh jb li jf lj jj lk jn lc ld le lf bi translated">我们将<code class="du lv lw lx lm b">aria-hidden="true"</code>添加到隐藏的幻灯片中。现在屏幕阅读器不会读取它们。</li><li id="30e5" class="kx ky hi is b it lg ix lh jb li jf lj jj lk jn lc ld le lf bi translated">我们增加了一个<code class="du lv lw lx lm b">aria-live</code>区域。现在，只要有更改(当用户更改幻灯片时)，屏幕阅读器就会重新读取转盘的内容。</li></ul><p id="1b70" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">还有其他一些有用的 aria 属性，但是我现在忽略它们，因为在 WAI-ARIA 创作实践的 carousel 部分没有提到它们。一个例子是<a class="ae mm" href="https://tink.uk/using-the-aria-controls-attribute/" rel="noopener ugc nofollow" target="_blank"> aria 控件</a>。如果你想了解更多，也许值得在业余时间看看<a class="ae mm" href="https://www.w3.org/TR/wai-aria-practices-1.1/" rel="noopener ugc nofollow" target="_blank"> WAI-ARIA 创作实践</a>。如果你想了解更多关于可访问性的知识，我已经在<a class="ae mm" href="https://programmingduck.com/articles/accessibility" rel="noopener ugc nofollow" target="_blank">网页可访问性——你需要知道的一切</a>中写了一个学习指南。</p><p id="fba4" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们的 JavaScript 也需要一些更新。具体来说，当我们更改幻灯片时，我们需要为新的活动幻灯片将<code class="du lv lw lx lm b">aria-hidden</code>属性更改为<code class="du lv lw lx lm b">false</code>。我们还需要隐藏我们不再看的上一张幻灯片。</p><p id="46ef" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">下面是一些我们可以使用的示例代码:</p><pre class="jo jp jq jr fd ll lm ln lo aw lp bi"><span id="5cf8" class="lq jv hi lm b fi lr ls l lt lu">function changeSlide(slideNumber) {<br/>  // change current slide visually<br/>  carousel.style.setProperty('--current-slide', slideNumber);<br/><br/>  // handle screen reader accessibility<br/>  // here we're getting the elements for the previous slide, current slide and next slide<br/>  const previousSlideNumber = modulo(slideNumber - 1, numSlides);<br/>  const nextSlideNumber = modulo(slideNumber + 1, numSlides);<br/>  const previousSlide = slidesContainer.children[previousSlideNumber];<br/>  const currentSlideElement = slidesContainer.children[slideNumber];<br/>  const nextSlide = slidesContainer.children[nextSlideNumber];<br/><br/>  // here, we're hiding the previous and next slides and unhiding the current slide<br/>  previousSlide.setAttribute('aria-hidden', true);<br/>  nextSlide.setAttribute('aria-hidden', true);<br/>  currentSlideElement.setAttribute('aria-hidden', false);<br/>}</span></pre><h1 id="fb88" class="ju jv hi bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">测试</h1><p id="67b6" class="pw-post-body-paragraph iq ir hi is b it ks iv iw ix kt iz ja jb ku jd je jf kv jh ji jj kw jl jm jn hb bi translated">有什么方法可以测试这样的东西？</p><p id="c291" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">简而言之，我会为它编写端到端的测试。我会犹豫是否要为它编写单元测试。</p><p id="0f47" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">原因如下。</p><p id="057c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">一个端到端的测试向你展示了整个事情正常工作。</p><p id="c4e9" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">根据您的测试框架，您可以做如下事情:</p><ul class=""><li id="a934" class="kx ky hi is b it iu ix iy jb kz jf la jj lb jn lc ld le lf bi translated">检查只有特定的<code class="du lv lw lx lm b">div</code>(幻灯片)在页面上可见，其他的不可见</li><li id="ef39" class="kx ky hi is b it lg ix lh jb li jf lj jj lk jn lc ld le lf bi translated">按下下一个/上一个滑动按钮后，检查正确的<code class="du lv lw lx lm b">div</code>(滑动)是否可见</li><li id="f731" class="kx ky hi is b it lg ix lh jb li jf lj jj lk jn lc ld le lf bi translated">检查更换幻灯片的过渡是否正常工作</li></ul><p id="8e0f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">但是如果你进行单元测试，你只能检查你的 JavaScript 是否工作正常。</p><p id="6b9b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">您可以做一个测试，设置一些 HTML，然后运行您的 JavaScript，最后检查得到的 HTML 是否是您所期望的。</p><p id="606d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">或者你可以做一些类似于窥探你的 JavaScript 代码的事情，运行你的 JavaScript 并确保你的窥探被调用。</p><p id="f1e6" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">对于第一个单元测试示例(您检查最终的 HTML)，问题是，虽然您的测试可能通过了，但是您的传送带可能没有工作。例如，有人可能已经改变了 CSS 的工作方式。他们可能将属性<code class="du lv lw lx lm b">--current-slide</code>重命名为<code class="du lv lw lx lm b">--index</code>或其他名称。也许他们改变了整个 CSS 机制来改变幻灯片(例如，为了提高性能)。</p><p id="97de" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在这种情况下，您的 JavaScript 将无错误地执行，测试也将通过，但是传送带不会工作。</p><p id="02df" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">测试不会提供你的代码工作的信心。</p><p id="c465" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">他们唯一会做的就是冻结你的 JavaScript 实现。在这种情况下，您已经在浏览器中手动检查了转盘。你认为“我可以看到它在工作，让我为它写一些单元测试，检查 JavaScript 是否在执行 X”。这是为了防止任何人在将来不小心修改 JavaScript。如果他们这样做，测试将会失败。</p><p id="5822" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">但是，这也使得有意的改变更加困难。现在，如果你想在未来改变实现，你需要改变你的 CSS，JavaScript 和你的 10 个测试。这是人们不喜欢单元测试的原因之一。它们使得对实现的修改更加困难(至少对于像这样的单元测试来说)。</p><p id="4c74" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">因此，出于这些原因，我个人建议改为编写端到端测试。现在，如果你真的想防止 JavaScript 中的意外变化，这很好。你需要做你需要做的。由你来决定内心的平静是否值得这些负面影响，以及编写这些测试所花费的时间。</p><p id="45c3" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">至于单元测试的另一个场景，你检查你的间谍是否被调用，我只是看不出这有什么好处。通过这些测试，您甚至不能测试您的 JavaScript 是否如您所想的那样运行。只要您调用相同的函数，您可以在将来中断 JavaScript 实现，您的测试仍然会通过。</p><p id="7f45" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">但是，这些只是我对此事的想法。我愿意接受不同的意见。如果你认为我遗漏了什么，请在下面留下评论。</p><h1 id="9e74" class="ju jv hi bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">最终注释</h1><p id="bbd6" class="pw-post-body-paragraph iq ir hi is b it ks iv iw ix kt iz ja jb ku jd je jf kv jh ji jj kw jl jm jn hb bi translated">原来如此。我希望这篇文章对你有用。</p><p id="dd59" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如果你想更全面地了解代码，<a class="ae mm" href="https://github.com/Programming-Duck/carousel" rel="noopener ugc nofollow" target="_blank">这里是代码库</a>。</p><p id="8c05" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">请注意，这并不意味着生产就绪。代码可以清理的更多。它可能会变得更适合您的需要。等等。</p><p id="aa00" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这只是一个小教程，向你展示如何制作一个简单的旋转木马的总体思路。</p><p id="05a0" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如果您有任何反馈，任何遗漏或可以做得更好的地方，或其他任何东西，请在下面留下评论。</p><p id="fa5b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">好的，非常感谢，下次见。</p></div><div class="ab cl mn mo gp mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="hb hc hd he hf"><p id="fa63" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><em class="mu">原载于 2021 年 5 月 27 日 https://programmingduck.com</em><a class="ae mm" href="https://programmingduck.com/articles/javascript-carousel" rel="noopener ugc nofollow" target="_blank"><em class="mu"/></a><em class="mu">。</em></p></div></div>    
</body>
</html>