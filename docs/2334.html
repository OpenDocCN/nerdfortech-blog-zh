<html>
<head>
<title>ETCD - the Easy Way</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">ETCD -简单的方法</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/etcd-the-easy-way-4c01e243f285?source=collection_archive---------1-----------------------#2021-05-02">https://medium.com/nerd-for-tech/etcd-the-easy-way-4c01e243f285?source=collection_archive---------1-----------------------#2021-05-02</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="2158" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这是一个指南，将帮助您开始使用etcd，并帮助您了解如何在kubernetes设置中使用它。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es jd"><img src="../Images/68e10c0bd047da6d9785f9d9b631792d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dEdBTL_f2-isjUB6DAsUCw.png"/></div></div></figure><p id="75f6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">简言之，etcd是一个分布式的、可靠的键值存储，用于存储分布式系统中最关键的数据。</p><p id="ee2e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">集群中每个资源的每个必要细节都以键-值对的形式存储，根据资源类型(如名称空间、pod、apiservices、集群角色、配置映射、部署等)划分到不同的目录中。这些键值存储有助于kubernetes集群保持其预期状态。</p><h1 id="0f58" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">集群的大脑</h1><p id="c668" class="pw-post-body-paragraph if ig hi ih b ii kn ik il im ko io ip iq kp is it iu kq iw ix iy kr ja jb jc hb bi translated">etcd也被称为kubernetes集群的大脑，它完全了解集群中的每个资源。让我告诉你怎么做</p><h2 id="beee" class="ks jq hi bd jr kt ku kv jv kw kx ky jz iq kz la kd iu lb lc kh iy ld le kl lf bi translated">创建资源时…</h2><p id="6aae" class="pw-post-body-paragraph if ig hi ih b ii kn ik il im ko io ip iq kp is it iu kq iw ix iy kr ja jb jc hb bi translated">让我们举一个例子，我们使用类似于<code class="du lg lh li lj b">kubectl run some-pod --image=some-image</code>的命令创建一个pod，然后将发生以下步骤</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es lk"><img src="../Images/865cf47b3500b5a5cb94ab31e6a94aa2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*udBZXmiDiBucJPL242gqiQ.png"/></div></div></figure><ol class=""><li id="4120" class="ll lm hi ih b ii ij im in iq ln iu lo iy lp jc lq lr ls lt bi translated">用户使用kubectl命令行工具向kube-apiserver发送请求。然后对请求进行认证、验证和执行。创建Pod(未分配节点),并将该数据设置到etcd中。</li><li id="25e5" class="ll lm hi ih b ii lu im lv iq lw iu lx iy ly jc lq lr ls lt bi translated">向用户发回确认，表明pod已创建。</li><li id="1940" class="ll lm hi ih b ii lu im lv iq lw iu lx iy ly jc lq lr ls lt bi translated">Kube-scheduler监控api-server以发现新的请求，并在收到请求时，寻找可用的节点来调度pod。一旦找到一个节点，它就将信息传递给apiserver，API server将信息输入etcd。</li><li id="2c57" class="ll lm hi ih b ii lu im lv iq lw iu lx iy ly jc lq lr ls lt bi translated">Apiserver将pod数据发送到可用worked节点上的kubelet，后者在各自的容器运行时引擎上运行pod，并发回确认。</li><li id="5815" class="ll lm hi ih b ii lu im lv iq lw iu lx iy ly jc lq lr ls lt bi translated">Pod状态存储在etcd中。</li></ol><p id="eba1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">更新资源时，会遵循类似的过程。</p><h2 id="a5ac" class="ks jq hi bd jr kt ku kv jv kw kx ky jz iq kz la kd iu lb lc kh iy ld le kl lf bi translated">获取资源时…</h2><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es lz"><img src="../Images/5c6c6049684238d41477657fff934b6d.png" data-original-src="https://miro.medium.com/v2/resize:fit:846/format:webp/1*334buT_iV84cdls234ZRSQ.png"/></div></div></figure><p id="bf46" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">既然已经创建了pod，我们可以使用<code class="du lg lh li lj b">kubectl get pods</code>命令来获取pod细节。</p><p id="93c9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">由于etcd在所有阶段后都会更新，因此api服务器可以直接从etcd中获取数据。</p><ol class=""><li id="ff24" class="ll lm hi ih b ii ij im in iq ln iu lo iy lp jc lq lr ls lt bi translated">用户向kube-apiserver发送请求，然后对其进行认证和验证。</li><li id="061a" class="ll lm hi ih b ii lu im lv iq lw iu lx iy ly jc lq lr ls lt bi translated">Apiserver检查etcd中的pod数据</li><li id="b6c1" class="ll lm hi ih b ii lu im lv iq lw iu lx iy ly jc lq lr ls lt bi translated">数据被检索并发送给用户。</li></ol><p id="c0f7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在这里，您可以看到每个操作都在用最新状态更新etcd。这里还有一些需要注意事项</p><ul class=""><li id="2d4d" class="ll lm hi ih b ii ij im in iq ln iu lo iy lp jc ma lr ls lt bi translated">所有的<code class="du lg lh li lj b">kubectl get</code>命令直接从etcd获取数据</li><li id="bfa3" class="ll lm hi ih b ii lu im lv iq lw iu lx iy ly jc ma lr ls lt bi translated">只有kube-apiserver直接与etcd交互</li><li id="aad4" class="ll lm hi ih b ii lu im lv iq lw iu lx iy ly jc ma lr ls lt bi translated">每次更改都会在etcd中更新，只有这样才算完成。</li></ul><h1 id="8eba" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">开始使用etcd</h1><p id="57d0" class="pw-post-body-paragraph if ig hi ih b ii kn ik il im ko io ip iq kp is it iu kq iw ix iy kr ja jb jc hb bi translated">如果您已经使用kubeadm这样的工具安装了一个集群，那么您很可能会发现您的集群中已经安装了etcd。在这种情况下，您可以按如下方式查看etcd窗格</p><pre class="je jf jg jh fd mb lj mc md aw me bi"><span id="82c5" class="ks jq hi lj b fi mf mg l mh mi">controlplane $ kubectl get pods --all-namespaces</span><span id="1d8c" class="ks jq hi lj b fi mj mg l mh mi">NAMESPACE     NAME                 READY   STATUS    RESTARTS   AGE<br/>kube-system   coredns-66bff467...   1/1    Running      0        87s<br/>kube-system   coredns-66bff467...   1/1    Running      0        87s<br/><strong class="lj hj">kube-system   etcd-controlplane     1/1    Running      0        88s</strong><br/>kube-system   kube-apiserver-c...   1/1    Running      0        87s<br/>kube-system   kube-controller-...   1/1    Running      0        87s<br/>kube-system   kube-flannel-ds-...   1/1    Running      0        71s<br/>kube-system   kube-flannel-ds-...   1/1    Running      0        85s<br/>kube-system   kube-keepalived-...   1/1    Running      0        39s<br/>kube-system   kube-proxy-2dfck      1/1    Running      0        86s<br/>kube-system   kube-proxy-kqj2z      1/1    Running      0        86s</span></pre><p id="550e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果你正在从头开始建立一个集群，那么你可以简单地下载并使用<a class="ae mk" href="https://etcd.io/docs/v3.4/dl-build/" rel="noopener ugc nofollow" target="_blank">这些指令</a>进行构建。</p><p id="5e3f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">一旦etcd服务启动，它将默认监听端口<strong class="ih hj"> 2379 </strong>。现在，您可以将客户端连接到etcd服务，开始上传和检索数据。请注意，将预安装一个客户端，即etcd控制客户端<strong class="ih hj"> etcdctl </strong>。您可以使用该客户端与etcd中的数据进行交互。为此<br/> 1。设置<code class="du lg lh li lj b">ETCDCTL_API</code>环境变量来设置您将使用哪个版本的命令。默认情况下，该值为2。</p><pre class="je jf jg jh fd mb lj mc md aw me bi"><span id="8a50" class="ks jq hi lj b fi mf mg l mh mi">export ETCDCTL_API<strong class="lj hj">=3</strong></span></pre><p id="4c5c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">2.为不同的etcd节点设置端点(多节点/高可用性将在本文后面讨论)</p><pre class="je jf jg jh fd mb lj mc md aw me bi"><span id="5c50" class="ks jq hi lj b fi mf mg l mh mi">HOST_1=X.X.X.X<br/>HOST_2=Y.Y.Y.Y<br/>HOST_3=Z.Z.Z.Z<br/>ENDPOINTS<strong class="lj hj">=</strong>$HOST_1:2379,$HOST_2:2379,$HOST_3:2379</span></pre><p id="1f30" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">3.连接到etcd</p><pre class="je jf jg jh fd mb lj mc md aw me bi"><span id="bbfa" class="ks jq hi lj b fi mf mg l mh mi">etcdctl --endpoints<strong class="lj hj">=</strong>$ENDPOINTS &lt;some-command&gt;</span></pre><h1 id="d42b" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">一些方便的命令</h1><p id="4260" class="pw-post-body-paragraph if ig hi ih b ii kn ik il im ko io ip iq kp is it iu kq iw ix iy kr ja jb jc hb bi translated">首先，这些命令可以帮助您在etcd中浏览数据</p><ul class=""><li id="fadc" class="ll lm hi ih b ii ij im in iq ln iu lo iy lp jc ma lr ls lt bi translated">检查端点运行状况:</li></ul><pre class="je jf jg jh fd mb lj mc md aw me bi"><span id="3b8f" class="ks jq hi lj b fi mf mg l mh mi">etcdctl --endpoints<strong class="lj hj">=</strong>$ENDPOINTS endpoint health</span><span id="f4c3" class="ks jq hi lj b fi mj mg l mh mi">10.240.0.17:2379 is healthy: successfully committed proposal: took <strong class="lj hj">=</strong> 3.345431ms<br/>10.240.0.19:2379 is healthy: successfully committed proposal: took <strong class="lj hj">=</strong> 3.767967ms<br/>10.240.0.18:2379 is healthy: successfully committed proposal: took <strong class="lj hj">=</strong> 4.025451ms</span></pre><ul class=""><li id="6082" class="ll lm hi ih b ii ij im in iq ln iu lo iy lp jc ma lr ls lt bi translated">添加一些数据:<code class="du lg lh li lj b">etcdctl --endpoints<strong class="ih hj">=</strong>$ENDPOINTS put key1 value1</code></li><li id="e2b6" class="ll lm hi ih b ii lu im lv iq lw iu lx iy ly jc ma lr ls lt bi translated">检索数据:<code class="du lg lh li lj b">etcdctl --endpoints<strong class="ih hj">=</strong>$ENDPOINTS get key1</code></li><li id="39b4" class="ll lm hi ih b ii lu im lv iq lw iu lx iy ly jc ma lr ls lt bi translated">删除数据:<code class="du lg lh li lj b">etcdctl --endpoints<strong class="ih hj">=</strong>$ENDPOINTS del key1</code></li><li id="efc8" class="ll lm hi ih b ii lu im lv iq lw iu lx iy ly jc ma lr ls lt bi translated">监控一个按键:<code class="du lg lh li lj b">etcdctl --endpoints<strong class="ih hj">=</strong>$ENDPOINTS watch key1<br/></code>(任何关于<code class="du lg lh li lj b">key1</code>的更新都会显示在控制台上)</li><li id="b4e9" class="ll lm hi ih b ii lu im lv iq lw iu lx iy ly jc ma lr ls lt bi translated">条件/事务操作:</li></ul><pre class="je jf jg jh fd mb lj mc md aw me bi"><span id="7fd5" class="ks jq hi lj b fi mf mg l mh mi">etcdctl --endpoints<strong class="lj hj">=</strong>$ENDPOINTS txn --interactive</span><span id="fb80" class="ks jq hi lj b fi mj mg l mh mi"><strong class="lj hj">compares:</strong><br/>value<strong class="lj hj">(</strong>"key1"<strong class="lj hj">)</strong> <strong class="lj hj">=</strong> "value1"</span><span id="ef6b" class="ks jq hi lj b fi mj mg l mh mi"><strong class="lj hj">success requests (get, put, delete):</strong><br/>del key1</span><span id="d5b4" class="ks jq hi lj b fi mj mg l mh mi"><strong class="lj hj">failure requests (get, put, delete):</strong><br/>put key1 value2</span></pre><p id="9090" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在上述情况下，如果<code class="du lg lh li lj b">key1</code>的值等于<code class="du lg lh li lj b">value1</code>，则<code class="du lg lh li lj b">key1</code>被删除，否则其值被设置为<code class="du lg lh li lj b">value2</code>。当我们使用<code class="du lg lh li lj b">—-interactive</code>时，上述代码片段的粗体部分由系统提示</p><ul class=""><li id="1aaf" class="ll lm hi ih b ii ij im in iq ln iu lo iy lp jc ma lr ls lt bi translated">临时设定值:</li></ul><pre class="je jf jg jh fd mb lj mc md aw me bi"><span id="4cde" class="ks jq hi lj b fi mf mg l mh mi">etcdctl --endpoints<strong class="lj hj">=</strong>$ENDPOINTS lease grant 60<br/><strong class="lj hj">Output: lease 2be7547fbc6a5afa granted with TTL(60s)</strong></span><span id="bb33" class="ks jq hi lj b fi mj mg l mh mi">etcdctl --endpoints<strong class="lj hj">=</strong>$ENDPOINTS put key1 value1 --lease<strong class="lj hj">=</strong>2be7547fbc6a5afa<br/># key1’s value is valid for next 60s</span><span id="417e" class="ks jq hi lj b fi mj mg l mh mi">etcdctl --endpoints<strong class="lj hj">=</strong>$ENDPOINTS lease keep-alive 2be7547fbc6a5afa<br/><em class="ml"># lease timer is stopped indefinitely until aborted</em></span><span id="10ba" class="ks jq hi lj b fi mj mg l mh mi">etcdctl --endpoints<strong class="lj hj">=</strong>$ENDPOINTS lease revoke 2be7547fbc6a5afa<br/><em class="ml"># lease manually timed out</em></span></pre><ul class=""><li id="8f75" class="ll lm hi ih b ii ij im in iq ln iu lo iy lp jc ma lr ls lt bi translated">为灾难恢复拍摄快照:<code class="du lg lh li lj b">etcdctl --endpoints $ENDPOINT snapshot save snapshot.db<br/></code>您可以使用<code class="du lg lh li lj b">etcdctl snapshot restore</code>命令从该快照中恢复数据</li></ul><h1 id="a1e6" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">以高可用性运行etcd</h1><p id="15a6" class="pw-post-body-paragraph if ig hi ih b ii kn ik il im ko io ip iq kp is it iu kq iw ix iy kr ja jb jc hb bi translated">实现高可用性的最简单方法是通过分发和复制。在同一路径上，etcd可以部署为一个节点集群，以实现高可用性和弹性。</p><p id="5b7b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在这种配置中，所有节点都可以用于检索数据，但只有一个节点用于写入。使用Raft共识算法在节点中选出一个写入节点或领导者。简单地说</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es lk"><img src="../Images/3012508fec8d0d1d79d58afc8fa9b263.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DJYEJnwq4-cwd_53dt363w.png"/></div></div></figure><p id="0836" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">随机定时器被给予所有参与选举的节点。<br/>无论哪个定时器先超时，该节点都会向其他节点发出请求，要求成为它们的领导者。其他节点向领导者发回确认，得票最多的节点赢得选举。</p><p id="722a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">还不明白吗？<a class="ae mk" href="http://thesecretlivesofdata.com/raft/" rel="noopener ugc nofollow" target="_blank">查看此处</a></p><p id="5ab7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">领导者还定期向追随者发送通知，告知其将继续担任领导者角色。如果追随者在预期时间内没有收到领导者的通知，那么他们将使用raft重新选举。</p><p id="103a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在我们已经有了一个领导者，任何发送到etcd的写操作都将被转发到领导者节点，该节点写入数据并将副本发送给追随者。只有当跟随者在收到此更新后向领导者确认时，写操作才被视为完成。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es mm"><img src="../Images/07ad96c3089d6c55568b2b46ff40cc9c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mA25E96b77CUMFzIuKaBkA.png"/></div></div></figure><p id="7f8c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">可能会有一个从站停止运行的情况，在这种情况下，只有当节点总数的仲裁成功写入时，才认为写入完成</p><blockquote class="mn mo mp"><p id="7a55" class="if ig ml ih b ii ij ik il im in io ip mq ir is it mr iv iw ix ms iz ja jb jc hb bi translated">对于集群中的<strong class="ih hj"> N </strong>个节点<br/>T5】Quorum = floor(N/2+1)</p></blockquote><p id="a399" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">对于单节点或双节点群集，法定人数与n相同。此外，每个偶数M的法定人数与M+1的法定人数相同。因此，如果我们选择M+1，容错性会更好。因此，保持节点数为奇数且≥3是明智的。</p><h1 id="578a" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">离别赠言</h1><p id="bf98" class="pw-post-body-paragraph if ig hi ih b ii kn ik il im ko io ip iq kp is it iu kq iw ix iy kr ja jb jc hb bi translated">我希望您对etcd有所了解，为什么它在kubernetes集群中如此重要，以及如何开始使用它。现在是时候开始你的etcd之旅，继续创作了。</p></div></div>    
</body>
</html>