<html>
<head>
<title>Tuples and namedtuple — Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">元组和命名元组 Python</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/tuples-and-namedtuple-in-python-8df24bda15f2?source=collection_archive---------6-----------------------#2021-08-09">https://medium.com/nerd-for-tech/tuples-and-namedtuple-in-python-8df24bda15f2?source=collection_archive---------6-----------------------#2021-08-09</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div class="er es if"><img src="../Images/c0c4018e3f69e8824413973d0ca701f3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/1*7YEEP7jOgByWWTZkzQmYzQ.jpeg"/></div><figcaption class="im in et er es io ip bd b be z dx translated">照片由<a class="ae iq" href="https://unsplash.com/@pizbern?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">宝琳·伯恩菲尔德</a>在<a class="ae iq" href="https://unsplash.com/s/photos/brackets-animal?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="1707" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">我不知道元组不仅仅是一个通常在 return 语句中使用的带括号的数据结构。元组是一种非常强大的数据结构。我们将研究来自<code class="du jp jq jr js b">collections</code>库的元组和 Python 的<code class="du jp jq jr js b">namedtuple()</code>工厂函数，并举例说明。</p><p id="21e4" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">元组的语法是</p><figure class="ju jv jw jx fd ij er es paragraph-image"><div class="er es jt"><img src="../Images/0ed33eb1f7c0e96860c396652e2e52c2.png" data-original-src="https://miro.medium.com/v2/resize:fit:896/format:webp/1*u1neOY4G-iCI3liZzVKT9Q.png"/></div><figcaption class="im in et er es io ip bd b be z dx translated">元组的语法</figcaption></figure><p id="dbea" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">元素可以是任何类型—整数、字符串、列表等。</p><p id="8cc5" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">现在，让我们看看元组特定的属性，然后把它看作一个数据记录。</p><p id="ed3a" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">元组是<strong class="it hj">不可变的</strong>，这意味着一旦元组被创建，它上面的元素就不能被添加或删除。元素的<strong class="it hj">顺序</strong>也是<strong class="it hj">固定</strong>。</p><figure class="ju jv jw jx fd ij er es paragraph-image"><div role="button" tabindex="0" class="jz ka di kb bf kc"><div class="er es jy"><img src="../Images/a937cf2ccfe559b9bb188b3aa00b1f5c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ilNtkvdS3Z78qVdZTA5OMQ.png"/></div></div><figcaption class="im in et er es io ip bd b be z dx translated">元组中的元素不能更改、添加、删除，并且顺序是固定的</figcaption></figure><p id="7e57" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">我们还看到，元组变量<code class="du jp jq jr js b">usa</code>的位置有意义——<code class="du jp jq jr js b">0</code>代表一个国家的名称，<code class="du jp jq jr js b">1</code>代表一个首都城市的名称。</p><p id="70c1" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">鉴于元组这些不可变属性，它是包含数据的完美数据结构——没有副作用。</p><p id="d940" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">让我们看一个例子:</p><figure class="ju jv jw jx fd ij"><div class="bz dy l di"><div class="kd ke l"/></div></figure><p id="536c" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">这里你可以看到元组包含了关于国家的数据。我们可以使用变量来包含元组的值。我们使用<code class="du jp jq jr js b">*&lt;variable-name&gt;</code>来命名一个变量，以收集多个值，例如代码中的<code class="du jp jq jr js b">*rest</code>和<code class="du jp jq jr js b">*prev_info</code>。这个过程也被称为<strong class="it hj">元组解包</strong>。</p><p id="3fe6" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">运行该文件时，我们得到:</p><pre class="ju jv jw jx fd kf js kg kh aw ki bi"><span id="df1e" class="kj kk hi js b fi kl km l kn ko">north america: [('United States of America', 'Washington, D.C.', 'Bald Eagle'), ('Canada', 'Otaawa', 'Canada Jay')]</span><span id="c0df" class="kj kk hi js b fi kp km l kn ko">country: Swaziland, capital: Mbabane, Lobamba, national bird: Purple-crested turaco</span><span id="bb0f" class="kj kk hi js b fi kp km l kn ko">USA's national bird: Bald Eagle</span><span id="592b" class="kj kk hi js b fi kp km l kn ko">Guyana's capital: Georgetown</span><span id="339e" class="kj kk hi js b fi kp km l kn ko">usa: United States of America, rest info: ['Washington, D.C.', 'Bald Eagle']</span></pre><p id="daf6" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">现在让我们看看 Python 的<code class="du jp jq jr js b">collections</code>库中的<code class="du jp jq jr js b">namedtuple</code>工厂函数。</p><p id="e1f3" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated"><code class="du jp jq jr js b">namedtuple</code>结合了<strong class="it hj">类</strong>和<strong class="it hj">元组</strong>方法，这样我们就可以给<strong class="it hj">的<strong class="it hj">位置</strong>赋予有意义的名称</strong>。</p><p id="a26b" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">让我们看一个例子:</p><figure class="ju jv jw jx fd ij"><div class="bz dy l di"><div class="kd ke l"/></div></figure><p id="44b2" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">这里我们创建了一个名为<code class="du jp jq jr js b">Rectangle</code>的元组，它有两个字段— <code class="du jp jq jr js b">length</code>和<code class="du jp jq jr js b">breadth</code>。我们可以使用索引或通过属性来访问<code class="du jp jq jr js b">Rectangle</code>元组的值。我们也可以用正常的拆包方式拆包。</p><p id="afb9" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">我们可以使用<code class="du jp jq jr js b">_asdict()</code>获得元组的字典表示。我们可以使用现有实例的值创建一个新的<code class="du jp jq jr js b">Rectangle</code>实例。这里我们用<strong class="it hj">解包字典</strong>和<strong class="it hj">解包位置论证</strong>的方式来做。</p><p id="d013" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">运行该文件时，我们得到:</p><pre class="ju jv jw jx fd kf js kg kh aw ki bi"><span id="6cf6" class="kj kk hi js b fi kl km l kn ko">calculating area using indexing: 18</span><span id="bfe3" class="kj kk hi js b fi kp km l kn ko">calculating area using attribute: 18</span><span id="946f" class="kj kk hi js b fi kp km l kn ko">length: 9, breadth: 2</span><span id="0a68" class="kj kk hi js b fi kp km l kn ko">dict representation: {'length': 9, 'breadth': 2}</span><span id="7924" class="kj kk hi js b fi kp km l kn ko">r2's initial id: 140454374705088</span><span id="b523" class="kj kk hi js b fi kp km l kn ko">r2's  length: 9, breadth: 3</span><span id="41f9" class="kj kk hi js b fi kp km l kn ko">r2's id after replacing breadth value: 140454374705280</span><span id="5117" class="kj kk hi js b fi kp km l kn ko">r3's lenght: 9, breadth: 2</span></pre><p id="7588" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">如果我们想让<code class="du jp jq jr js b">namedtuple</code>中的字段有默认值呢？我们有两种方法可以做到——原型和使用 tuple 的<code class="du jp jq jr js b">__defaults__</code>属性。</p><p id="65f4" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">首先，让我们看看原型方式:</p><figure class="ju jv jw jx fd ij"><div class="bz dy l di"><div class="kd ke l"/></div></figure><p id="fd3f" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">运行该文件时，我们得到:</p><pre class="ju jv jw jx fd kf js kg kh aw ki bi"><span id="3d8a" class="kj kk hi js b fi kl km l kn ko">prototype circle's id: 140367016505888<br/>area: 12.57, id: 140367016746416</span></pre><p id="edaa" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">这里，当创建一个名为<code class="du jp jq jr js b">circle_zer</code>的<code class="du jp jq jr js b">Circle</code>实例时，我们向字段传递默认值。请记住，一旦我们开始传递默认值，它应该对它后面的所有剩余字段都这样做。这是为了帮助 Python 编译器消除变量赋值的歧义。如果你没有给出默认值，你会得到<code class="du jp jq jr js b">positional argument</code>错误。</p><p id="a9bd" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">因此带有默认值的实例将成为我们的原型。我们可以使用<code class="du jp jq jr js b">_replace</code>方法基于原型创建一个实例。因为元组是不可变的序列类型，所以原型对象和原型之外的新实例具有不同的 id。</p><p id="1481" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">第二种方法是使用<code class="du jp jq jr js b">__defaults__</code>属性。</p><figure class="ju jv jw jx fd ij"><div class="bz dy l di"><div class="kd ke l"/></div></figure><p id="d2aa" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">这里我们使用<code class="du jp jq jr js b">__defaults__</code>属性将默认值传递给<code class="du jp jq jr js b">Circle</code>元组中的字段。默认值从左到右传递，所以如果我们只传递 2 个值，它们将被设置为<code class="du jp jq jr js b">origin_x</code>和<code class="du jp jq jr js b">origin_y</code>字段。</p><p id="a54d" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">它在功能上也是类似的:</p><figure class="ju jv jw jx fd ij er es paragraph-image"><div role="button" tabindex="0" class="jz ka di kb bf kc"><div class="er es kq"><img src="../Images/1c6de7489b4a479327550c809a2a6de0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MQEc55p_tlE-hz0DVsHXrg.png"/></div></div></figure><p id="7e94" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">现在让我们看一个场景，我们想要扩展我们现有的 tuple，<code class="du jp jq jr js b">Circle</code>。我们希望将<code class="du jp jq jr js b">origin_z</code>字段添加到圆中，以便此圆在 3D 环境中成为球体。我们可以通过使用元组的<code class="du jp jq jr js b">_fields</code>属性从 2D <code class="du jp jq jr js b">Circle</code>中获取字段并添加一个新的<code class="du jp jq jr js b">origin_z</code>字段来实现。然后按照通常的<code class="du jp jq jr js b">namedtuple</code>方式设置和访问元组的值。</p><p id="f46e" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">让我们看一个例子:</p><figure class="ju jv jw jx fd ij"><div class="bz dy l di"><div class="kd ke l"/></div></figure><p id="442c" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">运行该文件时，我们得到:</p><pre class="ju jv jw jx fd kf js kg kh aw ki bi"><span id="507f" class="kj kk hi js b fi kl km l kn ko">circle area: 28.27 at coordinate (1, 1)<br/>sphere area: 113.10 at coordinate (1, 1, 1)</span></pre><p id="6c30" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">总之，</p><ul class=""><li id="a5e8" class="kr ks hi it b iu iv iy iz jc kt jg ku jk kv jo kw kx ky kz bi translated">元组是不可变的数据结构</li><li id="4da2" class="kr ks hi it b iu la iy lb jc lc jg ld jk le jo kw kx ky kz bi translated">元组可以作为数据记录工作</li><li id="fb84" class="kr ks hi it b iu la iy lb jc lc jg ld jk le jo kw kx ky kz bi translated">我们有<code class="du jp jq jr js b">namedtuple</code>工厂函数来创建带有命名字段的元组。</li></ul><p id="26e5" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">我希望这篇文章对您有所帮助，并让您更好地了解元组。</p><p id="8706" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">祝贺完成，感谢您的阅读！💐我的下一篇文章将讨论 Python 数据结构的可变性和不变性。到时候见。</p></div><div class="ab cl lf lg gp lh" role="separator"><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk"/></div><div class="hb hc hd he hf"><p id="f95d" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated"><strong class="it hj">灵感:</strong></p><ul class=""><li id="6c50" class="kr ks hi it b iu iv iy iz jc kt jg ku jk kv jo kw kx ky kz bi translated"><a class="ae iq" href="https://www.udemy.com/course/python-3-deep-dive-part-1/" rel="noopener ugc nofollow" target="_blank"> Python 3:深潜(功能性)</a></li></ul><p id="c8e8" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">你可以在<a class="ae iq" href="https://www.patreon.com/dkhambu" rel="noopener ugc nofollow" target="_blank"> Patreon </a>上支持我！</p></div></div>    
</body>
</html>