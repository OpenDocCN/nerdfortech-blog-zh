# Python 的原始套接字:嗅探和网络数据包注入。

> 原文：<https://medium.com/nerd-for-tech/raw-sockets-with-python-sniffing-and-network-packet-injections-486043061bd5?source=collection_archive---------0----------------------->

该元素提供了一种绕过数据包的整个网络堆栈遍历并将其直接传递给应用程序的方法。有多种方法可以创建原始套接字。这次我们将使用`PF_PACKET`接口。

在常规的套接字编程中，我们需要创建一个 **TCP / UDP 服务器**，在这里网卡将把数据包向上传递到 IP 栈(IP 处理)，这些数据包将在客户端应用程序中被接收。

简单来说，通过使用**原始套接字**，我们可以为网络堆栈生成一个快速的**快捷方式**。

做一些内存闪回:OSI 模型标准化了计算机系统远程通信的通信功能，而不考虑其底层内部结构。

OSI 模型包括:(按执行的角色分类)

*   *用户应用或应用层*
*   *插座接口*
*   *TCP/UDP 处理*
*   *IP 处理*
*   *协议族处理例程(LPF)* =从原始套接字到应用
*   *网卡驱动*

它是一个软件接口，用于在 OSI(设备驱动器)的第 2 层发送/接收数据包。所有接收到的数据包都将包含所有报头和数据。所有发送的数据包都将由内核不加修改地传输到介质。支持使用 Berkley 包过滤(BPF)进行过滤

# 了解数据包报头

为了使这个解释简单一点，我们必须确保以太网封装了一切。(我觉得这个不是 100%准确)

以太网(封装)-> IP -> TCP ->应用程序(分层方法)

前 14 个字节代表**以太网头**，具体是**以太网包数据**

0–6 =**ethd host**(目的 MAC 地址)

6–11 =**eths host**(源 MAC 地址)

12–14 =**EthType**(正在使用的 IP 或其他内部协议)

接下来的字节进入 IP 头，然后是 TCP，然后是应用程序

0–3 =版本 4–7 = IHL 8–15 =服务类型 16–31 =总长度

以及其他信息，如标识、生存时间、协议、标志、片段偏移量、报头校验和、源地址、目的地址、选项、填充等

总共大约代表 20 个字节

解析数据的顺序与发送和接收的顺序相同。

# 将二进制数据提取到变量中

当数据通过网络发送时，它实际上被转换成网络字节顺序:大端格式

当我们发送数据时，我们必须确保格式是 NBO (Big Endian)，这是解压缩并在应用程序中使用的，我们需要确保使用`struct.unpack()`进行相应的数据转换，最后一个返回元组格式的头信息，您将处理该信息以检索字符串可理解的值。

对于`rawSniffer.py`(应该作为根用户运行)，如果你有适当的权限或根用户，你可以使用原始套接字

两个副主题:*理解数据包报头*和*将二进制数据提取到变量中*代表原始套接字上的嗅探角色。

# 使用原始套接字的包注入

这提供了将原始数据包注入网络的能力，显然，您可以估计来自网络的响应。

以下代码旨在用于独立测试，事实上，原始套接字不太容易移植，使用原始套接字构造包有点困难。这是完全不可伸缩的。

为了便于追踪，您可以使用`tcpdump`或任何其他工具进行流量分析，如 Wireshark。

`tcpdump -i eth0 -vv -XX`

您可以在我的 gist 页面上查看用 Python 编写的原始嗅探器和原始数据包注入的代码示例:

使用 Python 的原始套接字:嗅探和网络数据包注入:[http://bit.ly/32i793l](http://bit.ly/32i793l)