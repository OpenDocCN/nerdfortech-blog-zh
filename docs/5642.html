<html>
<head>
<title>Waypoint-Patrolling AI With Branching Paths In Unity, Part 2</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在 Unity 中用分支路径巡逻 AI，第 2 部分</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/waypoint-patrolling-ai-with-branching-paths-in-unity-part-2-db49f90e6ea7?source=collection_archive---------7-----------------------#2021-10-26">https://medium.com/nerd-for-tech/waypoint-patrolling-ai-with-branching-paths-in-unity-part-2-db49f90e6ea7?source=collection_archive---------7-----------------------#2021-10-26</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="076b" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">为了我的秘密项目，我必须做巡逻警卫。然而，我决定混合一些随机选择的替代路径，和一个“看方向”。</h2></div><p id="a39d" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这篇文章是第 1 部分的后续，所以如果你还没有看过的话，请先阅读一下。</p><figure class="ju jv jw jx fd jy er es paragraph-image"><div role="button" tabindex="0" class="jz ka di kb bf kc"><div class="er es jt"><img src="../Images/ddb33741a97a8e45ea73f8ed0d3a1d4a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*ZMDXqUjHeZbhfwsATGe8OA.gif"/></div></div><figcaption class="kf kg et er es kh ki bd b be z dx translated">启用时，警卫随机选择一个备用航路点位置。</figcaption></figure><p id="2011" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="iz hj">今天的目标:</strong>在现有的航路点巡逻系统中添加备用航路点，允许警卫在特定航路点的 2 个点之间随机选择。</p></div><div class="ab cl kj kk gp kl" role="separator"><span class="km bw bk kn ko kp"/><span class="km bw bk kn ko kp"/><span class="km bw bk kn ko"/></div><div class="hb hc hd he hf"><h1 id="a162" class="kq kr hi bd ks kt ku kv kw kx ky kz la io lb ip lc ir ld is le iu lf iv lg lh bi translated">代码:</h1><p id="e9e5" class="pw-post-body-paragraph ix iy hi iz b ja li ij jc jd lj im jf jg lk ji jj jk ll jm jn jo lm jq jr js hb bi translated">要添加替代点，我们需要修改本文第 1 部分中创建的一些现有代码，并编写一些额外的代码。</p><p id="98ba" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">首先，在现有的<strong class="iz hj"> <em class="ln">航路点</em> </strong> <strong class="iz hj">结构</strong>下创建这个新的<strong class="iz hj">结构</strong>。<strong class="iz hj">不要覆盖航路点结构。</strong></p><figure class="ju jv jw jx fd jy er es paragraph-image"><div class="er es lo"><img src="../Images/6df521dd5fdd775ba80072d9207da5c2.png" data-original-src="https://miro.medium.com/v2/resize:fit:674/1*8s6ohEVMXDqaSNFiDgURJg.gif"/></div></figure><p id="2b95" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">现在将<strong class="iz hj">航路点列表</strong>修改为<strong class="iz hj">航路点容器列表</strong>。</p><figure class="ju jv jw jx fd jy er es paragraph-image"><div class="er es lp"><img src="../Images/7398e988c3e1cccfdf69710c2a72c68a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1134/1*IrbXg-tSens7yVGQX8uy2Q.gif"/></div></figure><p id="79e8" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">现在在现有的"<strong class="iz hj"><em class="ln">" SetDestinationAndStartWalking()</em></strong>"方法中，用更新后的代码替换现有的代码:</p><figure class="ju jv jw jx fd jy er es paragraph-image"><div role="button" tabindex="0" class="jz ka di kb bf kc"><div class="er es lq"><img src="../Images/8913dbbe54f60a2e84caf49edeed1181.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TSdta4efSFI0CDZzbQ0CZw.png"/></div></div><figcaption class="kf kg et er es kh ki bd b be z dx translated">这将随机选择主要或备用航路点作为目的地。</figcaption></figure><p id="a8aa" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">现在我将修改“<strong class="iz hj"> <em class="ln"> Wait( ) </em> </strong>”方法来添加缓慢旋转以面对航点的<strong class="iz hj"><em class="ln">look direction</em></strong>:</p><figure class="ju jv jw jx fd jy er es paragraph-image"><div role="button" tabindex="0" class="jz ka di kb bf kc"><div class="er es lr"><img src="../Images/0e6ad08394677c60b54033e89f4aa8d3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1336/1*QmU5WdAlPHSI9xUE35oKqA.gif"/></div></div></figure><h1 id="971d" class="kq kr hi bd ks kt ls kv kw kx lt kz la io lu ip lc ir lv is le iu lw iv lg lh bi translated">绘制所有场景视图调试线:</h1><p id="1407" class="pw-post-body-paragraph ix iy hi iz b ja li ij jc jd lj im jf jg lk ji jj jk ll jm jn jo lm jq jr js hb bi translated">至此，“<strong class="iz hj"><em class="ln">OnDrawGizmos()”</em></strong>方法已经变得相当大了(<em class="ln">120 行，比整个类</em>的一半还少一点)，所以我不会再展示如何绘制所有这些漂亮的调试行了。如果你跟着<strong class="iz hj"> Part 1 </strong>走，我相信你自己也能搞清楚。不过，这确实让使用<strong class="iz hj">航路点</strong>变得更加容易。</p></div><div class="ab cl kj kk gp kl" role="separator"><span class="km bw bk kn ko kp"/><span class="km bw bk kn ko kp"/><span class="km bw bk kn ko"/></div><div class="hb hc hd he hf"><h1 id="fcf4" class="kq kr hi bd ks kt ku kv kw kx ky kz la io lb ip lc ir ld is le iu lf iv lg lh bi translated">结果是:</h1><figure class="ju jv jw jx fd jy er es paragraph-image"><div class="er es lx"><img src="../Images/c51cdd1c54c8437c9d42638a99c15d74.png" data-original-src="https://miro.medium.com/v2/resize:fit:1136/format:webp/1*nXF_1f9JXEQ5acOQ8Wi0dQ.png"/></div></figure><figure class="ju jv jw jx fd jy er es paragraph-image"><div class="er es ly"><img src="../Images/9ef83fd75834b87dd0dd582e6513ba9e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1334/1*Q1RuZjamstphClIxir6cKg.gif"/></div><figcaption class="kf kg et er es kh ki bd b be z dx translated">尽管在这次测试中，他似乎特别喜欢一条路，但每个初选/备选选择都有 50%的机会。</figcaption></figure><figure class="ju jv jw jx fd jy er es paragraph-image"><div role="button" tabindex="0" class="jz ka di kb bf kc"><div class="er es lz"><img src="../Images/05f8c029cfcc27a6a0e8c50a73ef3da6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*O3NtJE2I80xf12jPN7-f-w.png"/></div></div><figcaption class="kf kg et er es kh ki bd b be z dx translated">在这里你可以看到所有的<strong class="bd ks">航路点“主要”</strong>，以及它们的“<strong class="bd ks">备用”</strong>(如果启用的话)。</figcaption></figure><p id="0caf" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">你可能已经注意到，随着每个<strong class="iz hj">航路点</strong>的<strong class="iz hj"> <em class="ln">观察方向</em> </strong>的红线和球体，也有 2 或 3 条红线部分覆盖了<strong class="iz hj">航路点</strong>之间的线。</p><p id="2ca1" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这些是我没有在这里展示的一个改变，它允许人工智能代理在实际到达<strong class="iz hj">航点</strong>之前开始转向<strong class="iz hj"> <em class="ln">观察方向</em> </strong>。这样看起来更自然。</p></div></div>    
</body>
</html>