<html>
<head>
<title>The lifecycle of Components ReactJS</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">组件的生命周期反应</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/the-lifecycle-of-components-reactjs-86a562c6e725?source=collection_archive---------1-----------------------#2020-05-12">https://medium.com/nerd-for-tech/the-lifecycle-of-components-reactjs-86a562c6e725?source=collection_archive---------1-----------------------#2020-05-12</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="6511" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">每一个React组件都有自己独特的生命周期，也就是我们所知的一系列方法，它们在组件存在的不同阶段被调用。React组件经历了生命周期的四个不同阶段，如下所示。</p><ol class=""><li id="bbcc" class="jd je hi ih b ii ij im in iq jf iu jg iy jh jc ji jj jk jl bi translated"><em class="jm">初始化</em></li><li id="d354" class="jd je hi ih b ii jn im jo iq jp iu jq iy jr jc ji jj jk jl bi translated"><em class="jm">挂载</em></li><li id="f2db" class="jd je hi ih b ii jn im jo iq jp iu jq iy jr jc ji jj jk jl bi translated"><em class="jm">更新</em></li><li id="a60f" class="jd je hi ih b ii jn im jo iq jp iu jq iy jr jc ji jj jk jl bi translated"><em class="jm">卸载</em></li></ol><figure class="jt ju jv jw fd jx er es paragraph-image"><div role="button" tabindex="0" class="jy jz di ka bf kb"><div class="er es js"><img src="../Images/14f075d5a3fbadc3570d4bbc8a6047fa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Bn4KUX_ETHLN6V8O"/></div></div></figure><h2 id="776a" class="ke kf hi bd kg kh ki kj kk kl km kn ko iq kp kq kr iu ks kt ku iy kv kw kx ky bi translated"><strong class="ak"> <em class="kz">初始化阶段</em> </strong></h2><p id="a157" class="pw-post-body-paragraph if ig hi ih b ii la ik il im lb io ip iq lc is it iu ld iw ix iy le ja jb jc hb bi translated">React docu将此称为反模式，在初始化阶段，组件是用给定的属性和状态构造的，这是在组件类的构造函数中执行的。</p><figure class="jt ju jv jw fd jx er es paragraph-image"><div role="button" tabindex="0" class="jy jz di ka bf kb"><div class="er es lf"><img src="../Images/a0667e8e54cb40f16e8d43291be718fa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zrLVDFpbWq-ezO-OnnHIHA.png"/></div></div></figure><p id="ce89" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">JSX主要依赖三种数据，</p><ol class=""><li id="409e" class="jd je hi ih b ii ij im in iq jf iu jg iy jh jc ji jj jk jl bi translated">“错误”:这是当系统中有错误或渲染中有错误时显示的标准消息。</li><li id="2fe2" class="jd je hi ih b ii jn im jo iq jp iu jq iy jr jc ji jj jk jl bi translated">“加载”:加载是指应用程序获取API数据的时候。</li><li id="cb38" class="jd je hi ih b ii jn im jo iq jp iu jq iy jr jc ji jj jk jl bi translated">“用户”:从API中检索的数据也很重要。</li></ol><h2 id="ed90" class="ke kf hi bd kg kh ki kj kk kl km kn ko iq kp kq kr iu ks kt ku iy kv kw kx ky bi translated"><strong class="ak"> <em class="kz">贴装阶段</em> </strong></h2><p id="9d98" class="pw-post-body-paragraph if ig hi ih b ii la ik il im lb io ip iq lc is it iu ld iw ix iy le ja jb jc hb bi translated">然后在渲染的挂载阶段由render方法本身返回JSX。这一阶段有3种主要方法:</p><ol class=""><li id="f511" class="jd je hi ih b ii ij im in iq jf iu jg iy jh jc ji jj jk jl bi translated">getDerivedStateFromProps()；</li><li id="a8a0" class="jd je hi ih b ii jn im jo iq jp iu jq iy jr jc ji jj jk jl bi translated">render()；</li><li id="0796" class="jd je hi ih b ii jn im jo iq jp iu jq iy jr jc ji jj jk jl bi translated">componentDidMount()</li></ol><p id="17c7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">getDerivedStateFromProps():</strong>这是一个静态方法，在生命周期中很少使用。只有当组件的状态依赖于随时间的动态变化时，才使用此方法。</p><p id="9336" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> render(): </strong> Render就是在这种状态下把组件挂载到浏览器上。这是一种经典的方法，每次提供相同的输入时都会给出相同的输出。这是ReactJS编码框架中广泛使用的标准函数。</p><p id="aefe" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> componentDidMount(): </strong>这是在组件及其子组件在DOM中呈现后执行的最后一个ReactJS钩子方法。使用这个组件可以有效地访问DOM。您还可以使用其他几个可以合并到最终输出中的库进行初始化。您还可以在此方法下进行正确的API调用，以便能够以正确的方式检索数据。</p><h2 id="d7ee" class="ke kf hi bd kg kh ki kj kk kl km kn ko iq kp kq kr iu ks kt ku iy kv kw kx ky bi translated"><strong class="ak"> <em class="kz">更新阶段</em> </strong></h2><p id="ba67" class="pw-post-body-paragraph if ig hi ih b ii la ik il im lb io ip iq lc is it iu ld iw ix iy le ja jb jc hb bi translated">更新是指更新组件状态并重新绘制应用程序的阶段。在这个阶段调用了5个方法</p><ol class=""><li id="405e" class="jd je hi ih b ii ij im in iq jf iu jg iy jh jc ji jj jk jl bi translated">getDerivedStateFromProps()</li><li id="d2e5" class="jd je hi ih b ii jn im jo iq jp iu jq iy jr jc ji jj jk jl bi translated">shouldComponentUpdate()</li><li id="3cce" class="jd je hi ih b ii jn im jo iq jp iu jq iy jr jc ji jj jk jl bi translated">渲染()</li><li id="b4bf" class="jd je hi ih b ii jn im jo iq jp iu jq iy jr jc ji jj jk jl bi translated">getSnapshotBeforeUpdate()</li><li id="6839" class="jd je hi ih b ii jn im jo iq jp iu jq iy jr jc ji jj jk jl bi translated">componentDidUpdate()</li></ol><p id="de9f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">shouldcomponentdupdate():</strong>方法告诉程序更新时的渲染状态。如果正在更新新的道具或规则，则可以完成或跳过渲染。这对于正确编码很重要，因为程序中也有不断发展的状态。将方法更新为true/false是正确的方法。这里的默认值是true，可以根据代码进行更改。</p><p id="9fe0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">getSnapshotBeforeUpdate():</strong>这是在前一个方法返回true的答案时执行的。如果在返回响应之前需要进行一些预先的计算，那么它将用于准备即将到来的渲染。对于更复杂的程序，也可以使用这种方法。</p><p id="ce50" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> componentDidUpdate(): </strong>当更新的组件也在DOM中被更新时，就会执行这个命令。然后，您可以启动新的库来重新加载，这样您就可以在整个过程中维护一个更新的程序。</p><h2 id="9d04" class="ke kf hi bd kg kh ki kj kk kl km kn ko iq kp kq kr iu ks kt ku iy kv kw kx ky bi translated"><strong class="ak">T5【卸载阶段】T6</strong></h2><p id="b28c" class="pw-post-body-paragraph if ig hi ih b ii la ik il im lb io ip iq lc is it iu ld iw ix iy le ja jb jc hb bi translated">在卸载的最后阶段:顾名思义，卸载是组件生命周期的最后一步，在这一步中，组件被从页面中删除，以通过卸载产生结果。在这个阶段只调用了一个方法，</p><p id="03da" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> componentWillUnmount(): </strong>这是生命周期中的最后一个方法，因为它与核心卸载和从DOM中删除有关。组件的清理也在这里执行。当用户想从浏览器中清除程序时，这也用于注销用户。</p><p id="ec98" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">参考文献</strong></p><p id="b723" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><a class="ae lg" href="https://www.cuelogic.com/blog/reactjs-lifecycle" rel="noopener ugc nofollow" target="_blank">https://www.cuelogic.com/blog/reactjs-lifecycle</a></p></div></div>    
</body>
</html>