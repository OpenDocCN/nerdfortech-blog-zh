<html>
<head>
<title>Build the Forest in Python Series: Binary Tree Traversal</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">构建Python系列中的森林:二叉树遍历</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/build-the-forest-in-python-series-binary-tree-traversal-e4f88bfb9ddf?source=collection_archive---------16-----------------------#2021-03-18">https://medium.com/nerd-for-tech/build-the-forest-in-python-series-binary-tree-traversal-e4f88bfb9ddf?source=collection_archive---------16-----------------------#2021-03-18</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="1d22" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">本文是<a class="ae jd" href="https://shunsvineyard.info/build-the-forest-series/" rel="noopener ugc nofollow" target="_blank">营造森林系列</a>的第二篇。在本文中，我们不打算构建一棵树。相反，我们将实现遍历二叉树的函数。当我们使用数据结构来管理数据时，一个重要的用例是检查我们管理的所有数据。这就是为什么树遍历是必不可少的。</p><p id="08db" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">遍历是一种系统地检查树的节点的方法，只访问每个节点一次。遍历二叉树有很多种方法:按序、前序、后序和层次序。这些名字来自根到其子树的相对位置。树遍历也是图遍历的一种形式。有序、前序和后序遍历是深度优先遍历的类型，而级别顺序遍历是广度优先遍历的类型。本文将以递归和迭代的方式介绍这些遍历函数的实现。</p><h1 id="c8a2" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">项目设置</h1><p id="f24c" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">与<a class="ae jd" href="https://shunsvineyard.info/2021/03/13/build-the-forest-in-python-series-binary-search-tree/" rel="noopener ugc nofollow" target="_blank">构建二叉查找树</a>相同，实现假设Python 3.9或更新版本。此外，我们在项目中添加了两个模块:<em class="kh"> traversal.py </em>用于遍历函数，以及<em class="kh"> test_traversal.py </em>用于其单元测试。添加这两个文件后，我们的项目布局如下:</p><pre class="ki kj kk kl fd km kn ko kp aw kq bi"><span id="a58b" class="kr jf hi kn b fi ks kt l ku kv">Forest-python<br/>├── forest<br/>│   ├── __init__.py<br/>│   ├── binary_trees<br/>│   │   ├── __init__.py<br/>│   │   ├── binary_search_tree.py<br/>│   │   └── traversal.py<br/>│   └── tree_exceptions.py<br/>└── tests<br/>    ├── __init__.py<br/>    ├── conftest.py<br/>    ├── test_binary_search_tree.py<br/>    └── test_traversal.py</span></pre><p id="315e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">(完整代码可从<a class="ae jd" href="https://github.com/shunsvineyard/forest-python" rel="noopener ugc nofollow" target="_blank"> forest-python </a>获得)</p><h1 id="f4e6" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">功能界面</h1><p id="4e25" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">我们在这里实现的遍历方法尽量通用。理论上，我们可以将遍历方法应用于任何二叉树，只要它们的节点有左和右域，这是正确的。然而，对于不同类型的二叉树，它们的节点可能具有附加信息。例如，一个线程二叉树节点有信息告诉我们这个节点是一片叶子还是一个线程。在这种情况下，当我们遍历一个线程二叉树时，我们需要检查额外的信息来确定我们是否到达了叶子。换句话说，我们不能只检查节点的左或右字段是否为空。</p><p id="aaf5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们没有为每个树类型的不同条件添加逻辑，而是定义了受支持的树类型，因此客户端(即，人或linter)将知道某个树类型是否受支持。我们支持的类型定义如下所示:</p><pre class="ki kj kk kl fd km kn ko kp aw kq bi"><span id="d122" class="kr jf hi kn b fi ks kt l ku kv">from typing import Union<br/>from forest.binary_trees import binary_search_tree<br/>SupportedNode = Union[None, binary_search_tree.Node]<br/>SupportedTree = Union[binary_search_tree.BinarySearchTree]</span></pre><p id="83ee" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">目前，我们对节点支持类型<em class="kh"> None </em>和<em class="kh"> Node </em>，对树只支持类型<em class="kh">BinarySearchTree</em>；当我们实现其他类型的二叉树时，我们会添加更多。</p><p id="fbb8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">有了类型定义，我们可以利用类型注释来定义我们的遍历函数(以有序遍历为例)。</p><pre class="ki kj kk kl fd km kn ko kp aw kq bi"><span id="16f9" class="kr jf hi kn b fi ks kt l ku kv">from typing import Any, Iterator, Optional<br/><br/>Pairs = Iterator[tuple[Any, Any]]<br/>"""Iterator of Key-Value pairs, yield by traversal functions. For type checking"""<br/><br/>def inorder_traverse(tree: SupportedTree, recursive: bool = True) -&gt; Pairs:<br/>    …</span></pre><p id="ca19" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">注意，我们还为return定义了一个自定义类型<em class="kh">对</em>。尽管我们需要以这种方式编写更多的代码，正如<a class="ae jd" href="https://www.python.org/dev/peps/pep-0020/" rel="noopener ugc nofollow" target="_blank">Python的禅宗</a>所建议的，“显式比隐式好。”这样，客户端可以清楚地看到输入的正确参数类型和函数返回的类型，类型检查工具(如<a class="ae jd" href="http://mypy-lang.org/" rel="noopener ugc nofollow" target="_blank"> mypy </a>)可以防止类型不匹配问题。此外，对于深度优先遍历，我们将以递归和非递归方式实现它们，这就是为什么我们有第二个参数，<em class="kh">递归</em>。</p><p id="ad9f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为什么不是<a class="ae jd" href="https://docs.python.org/3/library/typing.html#typing.overload" rel="noopener ugc nofollow" target="_blank">@过载</a>？</p><p id="519f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Python是动态类型语言，<a class="ae jd" href="https://en.wikipedia.org/wiki/Function_overloading" rel="noopener ugc nofollow" target="_blank">函数重载</a>在Python中没有太大意义。但是我们可以利用类型注释来防止类型不匹配的问题。</p><p id="df33" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">从Python 3.5开始，<a class="ae jd" href="https://www.python.org/dev/peps/pep-0484/" rel="noopener ugc nofollow" target="_blank"> PEP-484 </a>引入了@ <em class="kh">重载</em>装饰器。根据官方<a class="ae jd" href="https://docs.python.org/3/library/typing.html#typing.overload" rel="noopener ugc nofollow" target="_blank">文档</a>,“@ overload decorator允许描述支持参数类型的多种不同组合的函数和方法。”听起来很棒。然而，这只是为了类型检查器的好处。在运行时，客户端代码仍然可以向函数传递任何参数。该文档还说，“重载的一个例子给出了一个比使用联合或类型变量更精确的类型。”因此，我们使用<a class="ae jd" href="https://docs.python.org/3/library/typing.html#typing.Union" rel="noopener ugc nofollow" target="_blank">联合</a>来定义<em class="kh">支持的树</em>类型。使用<em class="kh"> SupportedTree </em>也比定义几个@overload修饰的定义代码少。</p><p id="f5ca" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为什么返回类型<em class="kh">对</em>是迭代器？</p><p id="6022" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">想法是将遍历函数实现为<a class="ae jd" href="https://docs.python.org/3/glossary.html#term-generator-iterator" rel="noopener ugc nofollow" target="_blank">生成器</a>。这样做的一个主要好处是，当生成器迭代器返回时，它从停止的地方继续。当树很大时，这种方法可以节省大量内存。遍历函数的客户端代码可以一次处理一个项目。此外，客户端代码将更简单，更容易阅读。</p><h1 id="be3d" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">有序遍历</h1><p id="578e" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">有序遍历通过以下方法访问二叉树，每个节点可以表示为子树的根。</p><ol class=""><li id="ee97" class="kw kx hi ih b ii ij im in iq ky iu kz iy la jc lb lc ld le bi translated">遍历左边的子树。</li><li id="edae" class="kw kx hi ih b ii lf im lg iq lh iu li iy lj jc lb lc ld le bi translated">访根。</li><li id="f33b" class="kw kx hi ih b ii lf im lg iq lh iu li iy lj jc lb lc ld le bi translated">遍历右边的子树。</li></ol><p id="1272" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">下图演示了有序遍历的思想。黄色部分是根23的左子树，绿色部分是根23的右子树。节点旁边的小数字(即1，2，3)表示遍历顺序。</p><figure class="ki kj kk kl fd ll er es paragraph-image"><div class="er es lk"><img src="../Images/a3bf460a4ea0a77f954980016490b121.png" data-original-src="https://miro.medium.com/v2/resize:fit:964/format:webp/0*_k5dcxFRn_5cvQlU.png"/></div></figure><p id="4d5d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果二叉树也是一个二叉查找树，二叉搜索树属性允许我们通过有序遍历产生排序的顺序键值，如上图所示。</p><p id="5ca6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">二叉树遍历可以通过使用递归或辅助堆栈来完成。如前一节所述，我们以递归和非递归的方式实现它们。</p><pre class="ki kj kk kl fd km kn ko kp aw kq bi"><span id="ad6f" class="kr jf hi kn b fi ks kt l ku kv">def inorder_traverse(tree: SupportedTree, recursive: bool = True) -&gt; Pairs:<br/>    if recursive:<br/>        return _inorder_traverse(node=tree.root)<br/>    return _inorder_traverse_non_recursive(root=tree.root)</span></pre><p id="3f4c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">因为我们想隐藏实现细节，我们用前导下划线命名实际的实现函数(<em class="kh"> _inorder_traverse </em>和<em class="kh">_ in order _ traverse _ non _ recursive</em>)，这意味着它们是内部函数。</p><p id="b809" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">递归实现</strong></p><p id="f6f7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">由于有序遍历的定义，递归遍历是遍历树的最自然的方式，可以按如下方式实现。</p><pre class="ki kj kk kl fd km kn ko kp aw kq bi"><span id="f0cd" class="kr jf hi kn b fi ks kt l ku kv">def _inorder_traverse(node: SupportedNode) -&gt; Pairs:<br/>    if node:<br/>        yield from _inorder_traverse(node.left)<br/>        yield (node.key, node.data)<br/>        yield from _inorder_traverse(node.right)</span></pre><p id="8908" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">注意，我们使用来自的<a class="ae jd" href="https://docs.python.org/3/whatsnew/3.3.html#pep-380" rel="noopener ugc nofollow" target="_blank"> yield来递归调用<em class="kh"> _inorder_traverse </em>。那是因为_ <em class="kh"> inorder_traverse </em>是生成器；为了允许一个生成器将其部分操作委托给另一个生成器，我们需要使用来自的<em class="kh"> yield。</em></a></p><p id="b672" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">非递归实现</strong></p><p id="4881" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">关于有序遍历，我们首先访问左子树，然后是根，最后是右子树。因此，在访问左子树之前，我们先推右边的子树，然后是根。推入顺序是因为堆栈是一种先入后出的数据结构。在我们访问左边的子树之后，我们弹出栈来访问根，然后再次弹出来访问右边的子树。重复这些步骤，直到堆栈为空。</p><figure class="ki kj kk kl fd ll er es paragraph-image"><div class="er es lo"><img src="../Images/4270a7780eb0c247da25fd071dc4480f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1042/0*rNmT-x92IRyBJt3J.gif"/></div></figure><p id="0f90" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为了实现有序遍历函数，我们需要一个堆栈来保存我们稍后将访问的子树的根。做非递归遍历时，关键是:1。我们什么时候把一个节点压入栈中，什么时候从栈中取出一个节点，2。当我们遍历的时候，什么时候产生(即访问)节点。</p><ol class=""><li id="85be" class="kw kx hi ih b ii ij im in iq ky iu kz iy la jc lb lc ld le bi translated">当我们正在访问的节点有一个右子节点时，我们将它的右子节点推到堆栈中，然后将该节点推到堆栈中。</li><li id="a34e" class="kw kx hi ih b ii lf im lg iq lh iu li iy lj jc lb lc ld le bi translated">当从堆栈中弹出一个节点时，如果该节点没有右子节点或者它的右子节点与顶部节点相同，我们就生成该节点。</li></ol><p id="d026" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们使用Python内置的<a class="ae jd" href="https://docs.python.org/3/tutorial/datastructures.html" rel="noopener ugc nofollow" target="_blank"> list </a>作为栈来实现非递归的有序遍历，因为内置的list具有先进后出的能力:<em class="kh"> list.append(x) </em>在list的末尾添加一项，<em class="kh"> list.pop() </em>从list中移除并返回最后一项。</p><pre class="ki kj kk kl fd km kn ko kp aw kq bi"><span id="0ee2" class="kr jf hi kn b fi ks kt l ku kv">def _inorder_traverse_non_recursive(root: SupportedNode) -&gt; Pairs:<br/>    if root is None:<br/>        raise StopIteration<br/><br/>    stack = []<br/>    if root.right:<br/>        stack.append(root.right)<br/>    stack.append(root)<br/>    current = root.left<br/><br/>    while True:<br/><br/>        if current:<br/>            if current.right:<br/>                stack.append(current.right)<br/>                stack.append(current)<br/>                current = current.left<br/>                continue<br/>            stack.append(current)<br/>            current = current.left<br/><br/>        else:  # current is None<br/><br/>            if len(stack) &gt; 0:<br/>                current = stack.pop()<br/><br/>                if current.right is None:<br/>                    yield (current.key, current.data)<br/>                    current = None<br/>                    continue<br/>                else:  # current.right is not None<br/>                    if len(stack) &gt; 0:<br/>                        if current.right == stack[-1]:<br/>                            yield (current.key, current.data)<br/>                            current = stack.pop() if len(stack) &gt; 0 else None<br/>                            continue<br/>                        else:  # current.right != stack[-1]:<br/>                            # This case means there are more nodes on the right<br/>                            # Keep the current and go back to add them.<br/>                            continue<br/><br/>            else:  # stack is empty<br/>                break</span></pre><h1 id="34f2" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">反向有序遍历</h1><p id="dd42" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">当遍历一种类型的二叉查找树时，按序遍历产生升序排序的输出。如果以反向顺序遍历的方式遍历二叉树，排序后的结果将是降序。为了以相反的顺序遍历，我们首先访问右边的子树，最后访问左边的子树。</p><ol class=""><li id="c674" class="kw kx hi ih b ii ij im in iq ky iu kz iy la jc lb lc ld le bi translated">遍历右边的子树。</li><li id="8de4" class="kw kx hi ih b ii lf im lg iq lh iu li iy lj jc lb lc ld le bi translated">访根。</li><li id="bc07" class="kw kx hi ih b ii lf im lg iq lh iu li iy lj jc lb lc ld le bi translated">遍历左边的子树。</li></ol><p id="24d8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">反向有序遍历也可以通过递归和非递归的方式实现。并且实现与按序遍历是对称的。</p><pre class="ki kj kk kl fd km kn ko kp aw kq bi"><span id="e838" class="kr jf hi kn b fi ks kt l ku kv">def reverse_inorder_traverse(tree: SupportedTree, recursive: bool = True) -&gt; Pairs:<br/>    if recursive:<br/>        return _reverse_inorder_traverse(node=tree.root)<br/>    return _reverse_inorder_traverse_non_recursive(root=tree.root)</span></pre><p id="c570" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">递归反向有序遍历</strong></p><pre class="ki kj kk kl fd km kn ko kp aw kq bi"><span id="2909" class="kr jf hi kn b fi ks kt l ku kv">def _reverse_inorder_traverse(node: SupportedNode) -&gt; Pairs:<br/>    if node:<br/>        yield from _reverse_inorder_traverse(node.right)<br/>        yield (node.key, node.data)<br/>        yield from _reverse_inorder_traverse(node.left)</span></pre><p id="47d3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">非递归反向有序遍历</strong></p><pre class="ki kj kk kl fd km kn ko kp aw kq bi"><span id="6538" class="kr jf hi kn b fi ks kt l ku kv">def _reverse_inorder_traverse_non_recursive(root: SupportedNode) -&gt; Pairs:<br/>    if root is None:<br/>        raise StopIteration<br/><br/>    stack = []<br/>    if root.left:<br/>        stack.append(root.left)<br/>    stack.append(root)<br/>    current = root.right<br/><br/>    while True:<br/><br/>        if current:<br/>            if current.left:<br/>                stack.append(current.left)<br/>                stack.append(current)<br/>                current = current.right<br/>                continue<br/>            stack.append(current)<br/>            current = current.right<br/><br/>        else:  # current is None<br/><br/>            if len(stack) &gt; 0:<br/>                current = stack.pop()<br/><br/>                if current.left is None:<br/>                    yield (current.key, current.data)<br/>                    current = None<br/>                    continue<br/>                else:  # current.right is not None<br/>                    if len(stack) &gt; 0:<br/>                        if current.left == stack[-1]:<br/>                            yield (current.key, current.data)<br/>                            current = stack.pop() if len(stack) &gt; 0 else None<br/>                            continue<br/>                        else:  # current.right != stack[-1]:<br/>                            # This case means there are more nodes on the right<br/>                            # Keep the current and go back to add them.<br/>                            continue<br/><br/>            else:  # stack is empty<br/>                break</span></pre><h1 id="f48d" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">前序遍历</h1><p id="e397" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">前序遍历通过以下方法访问二叉树。</p><ol class=""><li id="5aa8" class="kw kx hi ih b ii ij im in iq ky iu kz iy la jc lb lc ld le bi translated">访根。</li><li id="7e75" class="kw kx hi ih b ii lf im lg iq lh iu li iy lj jc lb lc ld le bi translated">遍历左边的子树。</li><li id="a12a" class="kw kx hi ih b ii lf im lg iq lh iu li iy lj jc lb lc ld le bi translated">遍历右边的子树。</li></ol><p id="60c4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">下图是前序遍历的思路。黄色部分是根23的左子树，绿色部分是根23的右子树。与按序遍历相同，节点旁边的小数字(即1、2、3)表示遍历顺序。</p><figure class="ki kj kk kl fd ll er es paragraph-image"><div class="er es lk"><img src="../Images/2890263f390ce32e8a88ad850e29b5b9.png" data-original-src="https://miro.medium.com/v2/resize:fit:964/format:webp/0*YRPnJ4ETG1zN1gjk.png"/></div></figure><p id="99a9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们还以递归和非递归的方式实现了前序遍历。</p><pre class="ki kj kk kl fd km kn ko kp aw kq bi"><span id="573e" class="kr jf hi kn b fi ks kt l ku kv">def preorder_traverse(tree: SupportedTree, recursive: bool = True) -&gt; Pairs:<br/>    if recursive:<br/>        return _preorder_traverse(node=tree.root)<br/>    return _preorder_traverse_non_recursive(root=tree.root)</span></pre><p id="777c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">递归前序遍历</strong></p><p id="0456" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">递归实现很简单，只需遵循遍历顺序。</p><pre class="ki kj kk kl fd km kn ko kp aw kq bi"><span id="1f29" class="kr jf hi kn b fi ks kt l ku kv">def _preorder_traverse(node: SupportedNode) -&gt; Pairs:<br/>    if node:<br/>        yield (node.key, node.data)<br/>        yield from _preorder_traverse(node.left)<br/>        yield from _preorder_traverse(node.right)</span></pre><p id="574d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">非递归前序遍历</strong></p><p id="355a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">关于非递归实现，下图演示了非递归前序遍历。</p><figure class="ki kj kk kl fd ll er es paragraph-image"><div class="er es lo"><img src="../Images/e3c15e75e2bd3809bd3b3aa3a1056ef8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1042/0*_Lx95CEkWS551YeW.gif"/></div></figure><p id="571d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">非递归前序遍历比非递归有序遍历简单。因为我们首先访问根，所以这个过程可以看作是以下步骤:</p><ol class=""><li id="0188" class="kw kx hi ih b ii ij im in iq ky iu kz iy la jc lb lc ld le bi translated">当我们访问一个节点时，我们将它的右子节点推到堆栈中(如果它有一个的话)，然后将它的左子节点推到堆栈中(如果它有一个的话)。</li><li id="016b" class="kw kx hi ih b ii lf im lg iq lh iu li iy lj jc lb lc ld le bi translated">当一个节点从堆栈中弹出时，我们产生这个节点。</li></ol><pre class="ki kj kk kl fd km kn ko kp aw kq bi"><span id="31b1" class="kr jf hi kn b fi ks kt l ku kv">def _preorder_traverse_non_recursive(root: SupportedNode) -&gt; Pairs:<br/>    if root is None:<br/>        raise StopIteration<br/><br/>    stack = [root]<br/><br/>    while len(stack) &gt; 0:<br/>        temp = stack.pop()<br/>        yield (temp.key, temp.data)<br/><br/>        # Because stack is FILO, insert right child before left child.<br/>        if temp.right:<br/>            stack.append(temp.right)<br/><br/>        if temp.left:<br/>            stack.append(temp.left)</span></pre><h1 id="4dd6" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">后序遍历</h1><p id="f312" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">后序遍历通过以下方法访问二叉树。</p><ol class=""><li id="9493" class="kw kx hi ih b ii ij im in iq ky iu kz iy la jc lb lc ld le bi translated">遍历左边的子树。</li><li id="1533" class="kw kx hi ih b ii lf im lg iq lh iu li iy lj jc lb lc ld le bi translated">遍历右边的子树。</li><li id="3e02" class="kw kx hi ih b ii lf im lg iq lh iu li iy lj jc lb lc ld le bi translated">访根。</li></ol><p id="56ae" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">下图是后序遍历的思路。与前面的遍历类似，节点旁边的小数字(即1、2、3)表示遍历顺序。</p><figure class="ki kj kk kl fd ll er es paragraph-image"><div class="er es lk"><img src="../Images/f1a01bf4b5c8f757484bd4b8749fff3d.png" data-original-src="https://miro.medium.com/v2/resize:fit:964/format:webp/0*NVS5kdB5e4EWY_jc.png"/></div></figure><p id="bfb5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">同样，我们用递归和非递归方法来构建后序遍历。</p><pre class="ki kj kk kl fd km kn ko kp aw kq bi"><span id="067a" class="kr jf hi kn b fi ks kt l ku kv">def postorder_traverse(tree: SupportedTree, recursive: bool = True) -&gt; Pairs:<br/>    if recursive:<br/>        return _postorder_traverse(node=tree.root)<br/>    return _postorder_traverse_non_recursive(root=tree.root)</span></pre><p id="0337" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">递归后序遍历</strong></p><p id="0596" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">类似于有序和前序遍历，递归实现很简单。</p><pre class="ki kj kk kl fd km kn ko kp aw kq bi"><span id="8097" class="kr jf hi kn b fi ks kt l ku kv">def _postorder_traverse(node: SupportedNode) -&gt; Pairs:<br/>    if node:<br/>        yield from _postorder_traverse(node.left)<br/>        yield from _postorder_traverse(node.right)<br/>        yield (node.key, node.data)</span></pre><p id="087f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">非递归后序遍历</strong></p><p id="c0a3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">然而，后序遍历的非递归实现有点复杂。下图以非递归的方式演示了后序遍历。</p><figure class="ki kj kk kl fd ll er es paragraph-image"><div class="er es lo"><img src="../Images/ae18265f4d89b0f7cd413ed1404bb05f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1042/0*K4BS1IEEkrBBmIe3.gif"/></div></figure><ol class=""><li id="08ad" class="kw kx hi ih b ii ij im in iq ky iu kz iy la jc lb lc ld le bi translated">与非递归有序遍历一样，当我们执行非递归后序遍历时，如果我们访问的节点有一个右子节点，我们将它的右子节点推送到堆栈，然后也将该节点推送到堆栈。</li><li id="9446" class="kw kx hi ih b ii lf im lg iq lh iu li iy lj jc lb lc ld le bi translated">当该节点从堆栈中弹出时，我们产生该节点，并且它没有正确的子节点，或者堆栈变空。此外，如果从堆栈中弹出的节点有一个正确的子节点，并且该子节点不同于堆栈中的顶部节点，这意味着我们已经访问了正确的子树。在这种情况下，我们可以生成节点。否则，我们将堆栈中的顶部节点与当前节点交换，并遍历右边的子树。</li></ol><pre class="ki kj kk kl fd km kn ko kp aw kq bi"><span id="9426" class="kr jf hi kn b fi ks kt l ku kv">def _postorder_traverse_non_recursive(root: SupportedNode) -&gt; Pairs:<br/>    if root is None:<br/>        raise StopIteration<br/><br/>    stack = []<br/>    if root.right:<br/>        stack.append(root.right)<br/>    stack.append(root)<br/>    current = root.left<br/><br/>    while True:<br/><br/>        if current:<br/>            if current.right:<br/>                stack.append(current.right)<br/>                stack.append(current)<br/>                current = current.left<br/>                continue<br/>            else:  # current.right is None<br/>                if current.left:<br/>                    stack.append(current)<br/>                else:<br/>                    yield (current.key, current.data)<br/><br/>                current = current.left<br/><br/>        else:  # current is None<br/>            if len(stack) &gt; 0:<br/>                current = stack.pop()<br/><br/>                if current.right is None:<br/>                    yield (current.key, current.data)<br/>                    current = None<br/>                else:  # current.right is not None<br/>                    if len(stack) &gt; 0:<br/>                        if current.right != stack[-1]:<br/>                            yield (current.key, current.data)<br/>                            current = None<br/>                        else:  # current.right == stack[-1]<br/>                            temp = stack.pop()<br/>                            stack.append(current)<br/>                            current = temp<br/><br/>                    else:  # stack is empty<br/>                        yield (current.key, current.data)<br/>                        break<br/>            else:  # stack is empty<br/>                break</span></pre><h1 id="2548" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">层次顺序遍历</h1><p id="5268" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">与前面的深度优先遍历不同，级别顺序遍历是广度优先的。在这种情况下，我们先访问一个级别上的每个节点，然后再访问下一个级别。想法如下图所示。</p><figure class="ki kj kk kl fd ll er es paragraph-image"><div class="er es lp"><img src="../Images/0448009eed5c228630b28857ef5e10b8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1044/format:webp/0*0ixnwdhusxc-Llqj.png"/></div></figure><p id="b91c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们不使用堆栈，而是使用队列来实现层次顺序遍历函数。队列是一种先进先出的数据结构。对于每个节点，首先访问该节点，然后将其子节点放入队列中。将节点从队列中出队，首先访问该节点，然后将该节点的子节点入队。重复直到队列为空。</p><p id="a35f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们还使用Python的内置<a class="ae jd" href="https://docs.python.org/3/tutorial/datastructures.html" rel="noopener ugc nofollow" target="_blank">列表</a>作为队列来实现level-order函数，因为内置列表也具有先进先出的能力:<em class="kh"> list.append(x) </em>在列表的末尾添加一项，而<em class="kh"> list.pop(0) </em>从列表中移除并返回第一项。</p><pre class="ki kj kk kl fd km kn ko kp aw kq bi"><span id="0584" class="kr jf hi kn b fi ks kt l ku kv">def levelorder_traverse(tree: SupportedTree) -&gt; Pairs:<br/>    queue = [tree.root]<br/><br/>    while len(queue) &gt; 0:<br/>        temp = queue.pop(0)<br/>        if temp:<br/>            yield (temp.key, temp.data)<br/>            if temp.left:<br/>                queue.append(temp.left)<br/><br/>            if temp.right:<br/>                queue.append(temp.right)</span></pre><h1 id="ac86" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">试验</h1><p id="ed94" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">和往常一样，我们应该尽可能多地对代码进行单元测试。这里，我们使用在<a class="ae jd" href="https://shunsvineyard.info/2021/03/13/build-the-forest-in-python-series-binary-search-tree/" rel="noopener ugc nofollow" target="_blank">构建二叉查找树</a>中创建的<a class="ae jd" href="https://github.com/shunsvineyard/forest-python/blob/main/tests/conftest.py" rel="noopener ugc nofollow" target="_blank"> conftest.py </a>中的<em class="kh"> basic_tree </em>函数来测试我们的遍历函数。在<em class="kh"> test_traversal.py </em>中，我们可以像下面这样进行单元测试:我们检查遍历输出是否和预期的一样(以test<em class="kh">post order _ traverse</em>为例)。</p><pre class="ki kj kk kl fd km kn ko kp aw kq bi"><span id="e6c8" class="kr jf hi kn b fi ks kt l ku kv">def test_binary_search_tree_traversal(basic_tree):<br/>    """Test binary search tree traversal."""<br/>    tree = binary_search_tree.BinarySearchTree()<br/><br/>    for key, data in basic_tree:<br/>        tree.insert(key=key, data=data)<br/><br/>    assert [item for item in traversal.postorder_traverse(tree)] == [<br/>        (1, "1"), (7, "7"), (15, "15"), (22, "22"), (20, "20"), (11, "11"),<br/>        (4, "4"), (24, "24"), (34, "34"), (30, "30"), (23, "23")<br/>    ]</span></pre><p id="718c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">(检查<a class="ae jd" href="https://github.com/shunsvineyard/forest-python/blob/main/tests/test_traversal.py" rel="noopener ugc nofollow" target="_blank"> test_traversal.py </a>以获得完整的单元测试)</p><h1 id="2105" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">分析</h1><h2 id="0336" class="kr jf hi bd jg lq lr ls jk lt lu lv jo iq lw lx js iu ly lz jw iy ma mb ka mc bi translated">深度优先遍历:按序、反向按序、前序和后序</h2><p id="859b" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated"><strong class="ih hj">按序运行时间、按序保留、按序前和按序后遍历</strong></p><p id="da27" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在图算法中，深度优先搜索的运行时间为O(V+E)，其中V是顶点数，E是边数。(运行时间为O(V+E)的原因，请参考<a class="ae jd" href="https://en.wikipedia.org/wiki/Introduction_to_Algorithms" rel="noopener ugc nofollow" target="_blank">算法介绍</a>第22.3章)。由于有序、逆有序、前序和后序遍历是深度优先遍历的类型，我们可以将这些遍历映射到深度优先搜索。因此，这些遍历的运行时间为O(V+E)。二叉树中的顶点是一个节点。此外，对于一棵二叉树，如果该树有n个节点，它必须有n-1条边。因此，我们可以将运行时间改写为O(n+(n-1))=O(2n-1)=O(n)，其中n是节点数。因此，它们的运行时间变成O(n)。</p><p id="20ed" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">关于空间复杂度，我们需要根据我们的方法来分析:递归或非递归。</p><p id="1ade" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">递归方法中的空间复杂度</strong></p><p id="e412" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">当我们进行递归方法时，空间使用是调用栈，即函数调用自身的深度。我们从根层到叶层遍历一棵二叉树，所以树的高度决定了函数调用自身的深度。因此，如果一棵二叉树有n个节点，我们知道当随机建立该树时，平均情况是O(LG n)；当树是线性链接时，最坏的情况是O(n)。</p><p id="7ffe" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">非递归方法中的空间复杂度</strong></p><p id="18f4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果我们使用非递归方法，空间使用量就是堆栈的大小。与递归方法相同，堆栈大小由树的高度决定。因此，对于一个有n个节点的二叉树，我们知道当树被随机建立时，平均情况是O(lg n );当树是线性链接时，最坏的情况是O(n)。</p><h2 id="4d37" class="kr jf hi bd jg lq lr ls jk lt lu lv jo iq lw lx js iu ly lz jw iy ma mb ka mc bi translated">广度优先遍历:层次顺序</h2><p id="bb7b" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">广度优先搜索算法的时间复杂度为O(V+E)，其中V为顶点数，E为边数(详见<a class="ae jd" href="https://en.wikipedia.org/wiki/Introduction_to_Algorithms" rel="noopener ugc nofollow" target="_blank">算法介绍</a>第22.2章)。所以层次顺序遍历的运行时间也是O(n)，其中n是节点数。原因与上面讨论的顺序和其余深度优先类型遍历相同。</p><p id="7535" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">因为我们使用队列来实现层次顺序遍历，所以空间开销就是队列的大小。我们在层级顺序遍历中使用队列的原因是为了跟踪同一层级的节点。可以在队列中的节点的最大数量是叶级，这是2^h，其中h是树的高度(这可以通过数学归纳法容易地证明)，并且队列大小的最坏情况发生在树平衡时，即，叶节点的最大数量。我们还知道，平衡树也是树高的最佳情况，即(lg n)，其中n是节点的数量。因此，队列大小的最坏情况变成o(2^h)=o(2^(lg n)= o(n)，其中n是节点数。</p><p id="ef50" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">然而，队列大小的最佳情况发生在每个级别只有一个节点时，即树是线性链接的。在这种情况下，空间复杂度变为常数，即O(1)。</p><p id="1ca1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">下表总结了每个遍历实现的复杂性。</p><figure class="ki kj kk kl fd ll er es paragraph-image"><div role="button" tabindex="0" class="me mf di mg bf mh"><div class="er es md"><img src="../Images/66f1ff4b7e7b30712c18466b48be61fa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DdQn5qsgH8rOzN6hDgHnbw.png"/></div></div></figure><h1 id="a7d8" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">例子</h1><p id="c354" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">既然我们已经实现了遍历例程，我们可以使用这些遍历函数来实现来自<a class="ae jd" href="https://shunsvineyard.info/2021/03/13/build-the-forest-in-python-series-binary-search-tree/#20-example" rel="noopener ugc nofollow" target="_blank">二叉查找树示例</a>的<em class="kh">地图</em>类的<em class="kh"> __iter__ </em>方法，并迭代地图对象的数据。</p><pre class="ki kj kk kl fd km kn ko kp aw kq bi"><span id="d971" class="kr jf hi kn b fi ks kt l ku kv">from typing import Any, Optional<br/><br/>from forest.binary_trees import binary_search_tree<br/>from forest.binary_trees import traversal<br/><br/>class Map:<br/>    """Key-value Map implemented by a Binary Search Tree."""<br/><br/>    def __init__(self) -&gt; None:<br/>        self._bst = binary_search_tree.BinarySearchTree()<br/><br/>    def __setitem__(self, key: Any, value: Any) -&gt; None:<br/>        """Insert (key, value) item into the map."""<br/>        self._bst.insert(key=key, data=value)<br/><br/>    def __getitem__(self, key: Any) -&gt; Optional[Any]:<br/>        """Get the data by the given key."""<br/>        node = self._bst.search(key=key)<br/>        if node:<br/>            return node.data<br/>        return None<br/><br/>    def __delitem__(self, key: Any) -&gt; None:<br/>        """Remove a (key, value) pair from the map."""<br/>        self._bst.delete(key=key)<br/><br/>    def __iter__(self) -&gt; traversal.Pairs:<br/>        """Iterate the data in the map."""<br/>        return traversal.inorder_traverse(tree=self._bst)<br/><br/>    @property<br/>    def empty(self) -&gt; bool:<br/>        """Return `True` if the map is empty; `False` otherwise."""<br/>        return self._bst.empty<br/><br/>if __name__ == "__main__":<br/><br/>    # Initialize the Map instance.<br/>    contacts = Map()<br/><br/>    # Add some items.<br/>    contacts["Mark"] = "mark@email.com"<br/>    contacts["John"] = "john@email.com"<br/>    contacts["Luke"] = "luke@email.com"<br/><br/>    # Retrieve an email<br/>    print(contacts["Mark"])<br/><br/>    # Delete one item.<br/>    del contacts["John"]<br/><br/>    # Check the deleted item.<br/>    print(contacts["John"])  # This will print None<br/><br/>    # Iterate the items.<br/>    for contact in contacts:<br/>        print(contact)</span></pre><p id="8360" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">(完整示例可从<a class="ae jd" href="https://github.com/shunsvineyard/forest-python/blob/main/examples/bst_map.py" rel="noopener ugc nofollow" target="_blank"> bst_map.py </a>获得)</p><h1 id="abc3" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">摘要</h1><p id="996e" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">二叉树遍历是系统地访问二叉树的每个节点的方法，并且每个节点只被访问一次。它们是图搜索算法的特例，例如深度优先搜索和宽度优先搜索，并且可以通过不同的方法来实现，并且每种方法都有其优点和缺点。下面的文章将介绍改进的二分搜索法树、线程二分搜索法树，它们允许我们在不使用堆栈或递归方法的情况下遍历树，即遍历的空间复杂度总是恒定的。</p></div><div class="ab cl mi mj gp mk" role="separator"><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn"/></div><div class="hb hc hd he hf"><p id="e772" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="kh">原载于2021年3月18日</em><a class="ae jd" href="https://shunsvineyard.info/2021/03/17/build-the-forest-in-python-series-binary-tree-traversal/" rel="noopener ugc nofollow" target="_blank"><em class="kh">https://shunsvineyard . info</em></a><em class="kh">。</em></p></div></div>    
</body>
</html>