<html>
<head>
<title>Seeking a Type Safe Sanctuary in JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在JavaScript中寻找类型安全避难所</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/seeking-a-type-safe-sanctuary-in-javascript-4a59bbd40d51?source=collection_archive---------12-----------------------#2021-04-03">https://medium.com/nerd-for-tech/seeking-a-type-safe-sanctuary-in-javascript-4a59bbd40d51?source=collection_archive---------12-----------------------#2021-04-03</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="101a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">越来越多的强类型脚本语言将文件转换成JavaScript，其中Typescript处于领先地位。在编译阶段捕捉类型问题的诱惑有时非常强烈，以至于我们需要一个更加类型安全的工具。但是我们可以通过另一种技术来获得类型安全(或确定性)——保护您的函数。围绕保护你的功能的概念有一些教程，很多年前我发现了Mike Stay的博客(最终进入范畴理论)。</p><p id="7631" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">熟悉不断发展的JavaScript库生态系统是一项艰巨的任务。<a class="ae jd" href="https://sanctuary.js.org/" rel="noopener ugc nofollow" target="_blank"> Sanctuary </a>是2015年推出的一个库(仍在积极开发中)，它结合了许多来自<a class="ae jd" href="http://ramdajs.com/" rel="noopener ugc nofollow" target="_blank"> Ramda </a>、<a class="ae jd" href="https://github.com/fantasyland/fantasy-land" rel="noopener ugc nofollow" target="_blank"> Fantasy Land </a>兼容类型和类型安全的“功能性”助手。</p><p id="dc7b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在我们做任何事情之前，我们需要包括各种库位:</p><pre class="je jf jg jh fd ji jj jk jl aw jm bi"><span id="72c2" class="jn jo hi jj b fi jp jq l jr js">const { cond, equals, T } = require('ramda');<br/>const { pipe, Left, Right, EitherType } = require('sanctuary');<br/>const $ = require('sanctuary-def');<br/>const def = $.create({ checkTypes: true, env: $.env });</span></pre><h1 id="3aed" class="jt jo hi bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">保护功能划分的类型</h1><p id="08b1" class="pw-post-body-paragraph if ig hi ih b ii kq ik il im kr io ip iq ks is it iu kt iw ix iy ku ja jb jc hb bi translated">这个代码片段中有趣的是<strong class="ih hj"> def </strong>函数。当我们用它来定义一个函数时，它将定义这个函数并设置类型保护。有趣的是第三和第四个参数。第三个是类型数组，数组中的最后一项是函数的返回类型。第四是执行。我们可以利用这一点来定义鸿沟:</p><pre class="je jf jg jh fd ji jj jk jl aw jm bi"><span id="6ccb" class="jn jo hi jj b fi jp jq l jr js">const divideImpl =  (n, d) =&gt; cond([<br/>    [equals(0), (_) =&gt; { throw new Error("division by zero" }) ],<br/>    [T,         (d) =&gt; n/d ]<br/>])(d)</span><span id="1241" class="jn jo hi jj b fi kv jq l jr js">//    divide =  Number -&gt; Number -&gt; Number<br/>const divide =  def(<br/>   'divide', <br/>   {}, <br/>   [$.Number, $.Number, $.Number],<br/>   divideImpl<br/>)</span></pre><p id="8365" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Divide接受一个分子和一个分母，用零来计算分母，它将抛出一个异常，否则函数返回商(令人震惊——对吗？).</p><pre class="je jf jg jh fd ji jj jk jl aw jm bi"><span id="7083" class="jn jo hi jj b fi jp jq l jr js">const x = divide(10)(2) <em class="kw">//=&gt; 5</em><br/>﻿const x = divide(10)(0) <em class="kw">//=&gt; Error: divsion by zero</em></span></pre><p id="03a6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果我们更改divide的类型签名以返回一个字符串并调用它，我们可以捕获一个详细的错误消息。</p><pre class="je jf jg jh fd ji jj jk jl aw jm bi"><span id="23db" class="jn jo hi jj b fi jp jq l jr js">//    divide =  Number -&gt; Number -&gt; String<br/>const divide =  def(<br/>   'divide', <br/>   {}, <br/>   [$.Number, $.Number, <strong class="jj hj">$.String</strong>],<br/>   divideImpl<br/>)</span><span id="21d3" class="jn jo hi jj b fi kv jq l jr js">divide(10)(2) <br/><br/><br/><em class="kw">/*<br/>TypeError: Invalid value<br/><br/>divide :: Number -&gt; Number -&gt; String<br/>                              ^^^^^^<br/>                                1<br/><br/>1)  5 :: Number<br/><br/>The value at position 1 is not a member of ‘String’.<br/><br/>*/</em></span></pre><p id="b03e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在上面的例子中，TypeError告诉我们函数试图返回数值5，但是函数签名需要一个字符串。让我们将返回类型还原为Number，并考虑抛出异常的危险。</p><h1 id="c9f7" class="jt jo hi bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">处理异常</h1><p id="ce9c" class="pw-post-body-paragraph if ig hi ih b ii kq ik il im kr io ip iq ks is it iu kt iw ix iy ku ja jb jc hb bi translated">异常的主要问题是，如果不小心处理，它们经常会带来流控制和展开问题。他们引入了退出函数的第二种方式，这违反了我们在101课程中所学的大部分内容。在修改后的方法中，二进制类型要么非常适合捕获方法的输出或异常，允许函数的单点进入和退出。我们可以创建一个更高阶的函数来调用一个函数并代表我们捕获异常，而不是将它编码到函数本身中——类似于</p><pre class="je jf jg jh fd ji jj jk jl aw jm bi"><span id="b36a" class="jn jo hi jj b fi jp jq l jr js">const a = $.TypeVariable('a');<br/>const l = $.TypeVariable('l');<br/>const r = $.TypeVariable('r');</span><span id="aa12" class="jn jo hi jj b fi kv jq l jr js">const fromThrowableImpl = (f, a) =&gt; {<br/>        try{<br/>            return Right(f.call({}, a))<br/>        }<br/>        catch(l) {<br/>            return Left(l)<br/>        }<br/>    }</span><span id="3d74" class="jn jo hi jj b fi kv jq l jr js"><em class="kw">//    fromThrowable :: ( a -&gt; r) -&gt; a -&gt; Either l r</em><br/>const fromThrowable =  def(<br/>    'fromThrowable', <br/>    {}, <br/>    [$.Function([a, r]), a, EitherType(l, r)],<br/>    fromThrowableImpl<br/>);</span></pre><p id="d1df" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">常数a、l和r表示在整个类型定义过程中保持不变的泛型类型。<strong class="ih hj"> fromThrowable </strong>试图调用一个函数，捕捉任何异常并返回。Right(通常在Success中使用的实例，封装了返回值)或。左(通常在封装了错误代码的故障中使用的任一实例)。fromThrowable本身有两个参数。第一个是接受一个类型并返回另一个类型的函数。第二个是满足该函数输入的变量。</p><pre class="je jf jg jh fd ji jj jk jl aw jm bi"><span id="6b78" class="jn jo hi jj b fi jp jq l jr js">fromThrowable(divide(10), 2) <br/>//=&gt; Right(5)</span><span id="2c5a" class="jn jo hi jj b fi kv jq l jr js">fromThrowable(divide(10), 0) <br/>//=&gt; Left(new Error("Division by zero"))</span></pre><p id="bef6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">幸运的是，通过提供<strong class="ih hj">套装</strong>，Sanctuary为我们省去了定义throubles的麻烦。需要注意的是，装箱要么需要一个额外的函数来转换任何错误。</p><pre class="je jf jg jh fd ji jj jk jl aw jm bi"><span id="bd01" class="jn jo hi jj b fi jp jq l jr js">encaseEither((x)=&gt;x, divide(10), 0) <br/>//=&gt; Left(new Error("division by zero"))</span></pre><h1 id="4143" class="jt jo hi bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">更好的守卫</h1><p id="a33e" class="pw-post-body-paragraph if ig hi ih b ii kq ik il im kr io ip iq ks is it iu kt iw ix iy ku ja jb jc hb bi translated">这很好，可以应用于任何抛出异常的函数。当利用遗留JavaScript库时，这是一个很好的选择。在这个项目中，我们可以通过使用更好的类型定义来提供更多的保护，通过在避难所环境中引入新的类型，</p><pre class="je jf jg jh fd ji jj jk jl aw jm bi"><span id="8e4f" class="jn jo hi jj b fi jp jq l jr js"><strong class="jj hj">const isIntegerNeqZero = x =&gt; $.test([], $.Integer, x) &amp;&amp; x != 0</strong></span><span id="3cff" class="jn jo hi jj b fi kv jq l jr js">const NonZeroInteger = $.NullaryType(<br/>    'my-test/NonZeroInteger',<br/>    'http://engieering.somewhere.com/my-test#NonZeroInteger',<br/>    <strong class="jj hj">isIntegerNeqZero</strong><br/>);</span></pre><p id="104b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">NonZeroInteger确保任何值都是整数并且不等于零。从这里我们可以重新定义divide，这将防止零被传入。</p><pre class="je jf jg jh fd ji jj jk jl aw jm bi"><span id="27f0" class="jn jo hi jj b fi jp jq l jr js">const divide =  def(<br/>    'divide', <br/>    {}, <br/>    [$.Number, NonZeroInteger, $.Number],<br/>    divideImpl<br/>)<br/><br/>divide(10)(0)<br/><br/><em class="kw">/*<br/>TypeError: Invalid value<br/><br/>divide :: Number -&gt; NonZeroInteger -&gt; Number<br/>                    ^^^^^^^^^^^^^^<br/>                          1<br/><br/>1)  0 :: Number<br/><br/>The value at position 1 is not a member of ‘NonZeroInteger’.<br/>*/</em></span></pre><p id="e100" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这是一件美好的事情。</p><p id="fc6c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果你对探索函数式编程感兴趣，请联系我们。跟我一起编码。</p></div><div class="ab cl kx ky gp kz" role="separator"><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc"/></div><div class="hb hc hd he hf"><div class="je jf jg jh fd le"><a href="https://www.linkedin.com/in/tb02118/" rel="noopener  ugc nofollow" target="_blank"><div class="lf ab dw"><div class="lg ab lh cl cj li"><h2 class="bd hj fi z dy lj ea eb lk ed ef hh bi translated">Todd Brown-Liberty Mutual创新和敏捷工程副总裁兼高级总监…</h2><div class="ll l"><h3 class="bd b fi z dy lj ea eb lk ed ef dx translated">Todd在软件行业有20多年的经验，专注于架构、安全和…</h3></div><div class="lm l"><p class="bd b fp z dy lj ea eb lk ed ef dx translated">www.linkedin.com</p></div></div><div class="ln l"><div class="lo l lp lq lr ln ls lt le"/></div></div></a></div></div><div class="ab cl kx ky gp kz" role="separator"><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc"/></div><div class="hb hc hd he hf"><p id="4d9f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">【https://www.linkedin.com】最初发表于<a class="ae jd" href="https://www.linkedin.com/pulse/seeking-type-safe-sancutary-javascript-todd-brown/" rel="noopener ugc nofollow" target="_blank"><em class="kw"/></a><em class="kw">。</em></p></div></div>    
</body>
</html>