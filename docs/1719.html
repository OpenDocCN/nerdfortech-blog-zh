<html>
<head>
<title>MMap’s in Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">MMap是Python中的</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/mmaps-in-python-63b044c3014a?source=collection_archive---------5-----------------------#2021-04-03">https://medium.com/nerd-for-tech/mmaps-in-python-63b044c3014a?source=collection_archive---------5-----------------------#2021-04-03</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="df5f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">是的，你读了，正确的是2米</p><h1 id="b046" class="jd je hi bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">那么MMap是什么？</h1><p id="180a" class="pw-post-body-paragraph if ig hi ih b ii kb ik il im kc io ip iq kd is it iu ke iw ix iy kf ja jb jc hb bi translated">多出来的M代表“记忆”。内存映射是一个过程，通过该过程，机器级结构被用来从磁盘直接映射文件以供程序使用。它将磁盘中的整个文件映射到计算机程序地址空间中的一系列地址。该程序可以像访问随机存储器中的数据一样访问磁盘上的文件。</p><figure class="kh ki kj kk fd kl er es paragraph-image"><div class="er es kg"><img src="../Images/7e51141cd953271f11d7952814f0c2e7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1054/format:webp/1*5zz42fTTNfioTySnTWweOg.png"/></div></figure><p id="8e18" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">mmap函数使用虚拟内存的概念，让程序看起来好像有一个大文件被加载到了主存中。</p><p id="481d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">但实际上，文件只存在于磁盘上。操作系统只是将文件的地址映射到程序的地址空间，这样程序就可以直接访问文件系统上的数据，而不是使用普通的I/O函数。内存映射通常会提高I/O性能，因为它不涉及每次访问的单独系统调用，也不需要在缓冲区之间复制数据，而是直接访问内存。</p><p id="ea59" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">根据您的需要，内存映射文件可以被视为可变字符串或类似文件的对象。映射文件支持预期的文件API方法，如close()、flush()、read()、<a class="ae ko" href="https://pymotw.com/2/readline/index.html#module-readline" rel="noopener ugc nofollow" target="_blank">、readline() </a>、seek()、tell()和write()。它还支持string API，具有切片等特性和find()等方法。</p><h1 id="dca0" class="jd je hi bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">现在让我们看看如何用Python实现mmap函数</h1><p id="5ee8" class="pw-post-body-paragraph if ig hi ih b ii kb ik il im kc io ip iq kd is it iu ke iw ix iy kf ja jb jc hb bi translated">我们可以使用mmap模块进行文件I/O，而不是简单的文件操作。</p><figure class="kh ki kj kk fd kl"><div class="bz dy l di"><div class="kp kq l"/></div></figure><ol class=""><li id="7c76" class="kr ks hi ih b ii ij im in iq kt iu ku iy kv jc kw kx ky kz bi translated">我们先<a class="ae ko" href="https://www.askpython.com/python/python-import-statement" rel="noopener ugc nofollow" target="_blank">导入</a>mmap模块</li><li id="f399" class="kr ks hi ih b ii la im lb iq lc iu ld iy le jc kw kx ky kz bi translated">然后定义文件在磁盘中的文件路径</li><li id="ec92" class="kr ks hi ih b ii la im lb iq lc iu ld iy le jc kw kx ky kz bi translated">然后我们使用<strong class="ih hj"> open() </strong>系统调用创建file_object</li><li id="b1e1" class="kr ks hi ih b ii la im lb iq lc iu ld iy le jc kw kx ky kz bi translated">在获得文件对象后，我们使用mmap函数创建文件到程序地址空间的内存映射</li><li id="4136" class="kr ks hi ih b ii la im lb iq lc iu ld iy le jc kw kx ky kz bi translated">然后我们从mmap对象中读取数据</li><li id="0434" class="kr ks hi ih b ii la im lb iq lc iu ld iy le jc kw kx ky kz bi translated">并打印数据。</li></ol><h1 id="485b" class="jd je hi bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">mmap功能描述</h1><p id="1964" class="pw-post-body-paragraph if ig hi ih b ii kb ik il im kc io ip iq kd is it iu ke iw ix iy kf ja jb jc hb bi translated"><code class="du lf lg lh li b">mmap_object<strong class="ih hj">=</strong></code> <code class="du lf lg lh li b">mmap.mmap(file_object.fileno(),length<strong class="ih hj">=</strong>0,access<strong class="ih hj">=</strong>mmap.ACCESS_READ,offset<strong class="ih hj">=</strong>0)</code></p><p id="0f90" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">mmap需要一个文件描述符作为第一个参数。</p><p id="e9f9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">参数length表示要映射的内存大小(以字节为单位),参数access通知内核程序将如何访问内存。</p><p id="ae43" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">参数offset指示程序在offset中指定的特定字节之后创建文件的内存映射。</p><ul class=""><li id="8698" class="kr ks hi ih b ii ij im in iq kt iu ku iy kv jc lj kx ky kz bi translated">第一个参数的文件描述符由file对象的<strong class="ih hj"> fileno() </strong>方法提供。</li><li id="e4c5" class="kr ks hi ih b ii la im lb iq lc iu ld iy le jc lj kx ky kz bi translated">如果我们希望系统自动选择足够的内存量来映射文件，可以指定第二个参数中的长度<strong class="ih hj"> 0 </strong>。</li><li id="6db1" class="kr ks hi ih b ii la im lb iq lc iu ld iy le jc lj kx ky kz bi translated">access参数有许多选项。<strong class="ih hj"> ACCESS_READ </strong>允许用户程序只从映射存储器中读取。<strong class="ih hj"> ACCESS_COPY </strong>和<strong class="ih hj"> ACCESS_WRITE </strong>提供写模式访问。在<strong class="ih hj"> ACCESS_WRITE </strong>模式下，程序可以更改映射内存和文件，但在<strong class="ih hj"> ACCESS_COPY </strong>模式下，只更改映射内存。</li><li id="7a5e" class="kr ks hi ih b ii la im lb iq lc iu ld iy le jc lj kx ky kz bi translated">当我们想从起始地址映射文件时，常常指定offset参数为<strong class="ih hj"> 0 </strong>。</li></ul><h1 id="edbd" class="jd je hi bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">我们已经看到了如何使用MMap读取文件，现在让我们看看如何写</h1><p id="6e11" class="pw-post-body-paragraph if ig hi ih b ii kb ik il im kc io ip iq kd is it iu ke iw ix iy kf ja jb jc hb bi translated">要将一些数据写入内存映射文件，我们可以使用ACCESS参数中的<strong class="ih hj"> ACCESS_WRITE </strong>选项，并在通过在<strong class="ih hj"> r+ </strong>模式下打开文件创建file对象后，使用<strong class="ih hj"> mmap_object.write() </strong>函数写入文件。</p><p id="237b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这里我们必须注意到，mmap不允许映射空文件。这是因为空文件不需要内存映射，因为它只是一个内存缓冲区。</p><p id="44af" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果我们将使用<strong class="ih hj">“w”</strong>模式打开一个文件，mmap将导致ValueError。</p><figure class="kh ki kj kk fd kl"><div class="bz dy l di"><div class="kp kq l"/></div></figure><p id="939f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">关于上面的例子，我们必须记住的重要一点是，在写入mmap之前，输入应该被<a class="ae ko" href="https://www.askpython.com/python/string/python-string-bytes-conversion" rel="noopener ugc nofollow" target="_blank">转换成字节</a>。</p><p id="9217" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">此外，mmap从文件的第一个地址开始写入数据，并覆盖初始数据。如果我们必须保存以前的数据，我们可以通过在mmap函数调用中指定适当的偏移量来实现。</p><h1 id="01e8" class="jd je hi bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">结论</h1><p id="533d" class="pw-post-body-paragraph if ig hi ih b ii kb ik il im kc io ip iq kd is it iu ke iw ix iy kf ja jb jc hb bi translated">简单的读/写操作在执行过程中会产生许多系统调用，这会导致在该过程中在不同的缓冲区中多次复制数据。</p><p id="2e09" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">使用mmap在性能方面为我们提供了显著的改进，因为它跳过了那些函数调用和缓冲操作，特别是在需要大量文件I/O的程序中。</p><p id="feb2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这就把我们带到了本文的结尾</p><p id="0d27" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果你已经读到这里…</p><figure class="kh ki kj kk fd kl er es paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="er es lk"><img src="../Images/dcf21bddde5fc157c9aac93e9c15ed20.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*Jf6hf9EonuGzdIN5JeZObQ.gif"/></div></div></figure></div></div>    
</body>
</html>