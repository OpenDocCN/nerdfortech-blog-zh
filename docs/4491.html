<html>
<head>
<title>Building a Vertx application with Kotlin</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用 Kotlin 构建 Vertx 应用程序</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/building-avertx-application-with-kotlin-1d55cb389f67?source=collection_archive---------8-----------------------#2021-07-23">https://medium.com/nerd-for-tech/building-avertx-application-with-kotlin-1d55cb389f67?source=collection_archive---------8-----------------------#2021-07-23</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="d233" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">正如前面的帖子中提到的，Eclipse Vertx 通过官方绑定将其 API 扩展到不同的语言，如 Kotlin、Groovy，甚至通过社区支持扩展到 Node/Typescript 和 PHP。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es jd"><img src="../Images/fe3ecba124cb84b0272f8faaa03f86ab.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fwQOVagDLdc4Yon5G-yrHA.jpeg"/></div></div><figcaption class="jp jq et er es jr js bd b be z dx translated">照片由<a class="ae jt" href="https://unsplash.com/@bengao?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">本高</a>在<a class="ae jt" href="https://unsplash.com/s/photos/china-landscape?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a></figcaption></figure><p id="4414" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在这篇文章中，我们将用 Kotlin 语言重新实现以前的 RESTful APIs。</p><p id="36d2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">打开浏览器，导航到<a class="ae jt" href="https://start.vertx.io" rel="noopener ugc nofollow" target="_blank"> Eclipse Vertx Starter </a>，生成项目框架。不要忘记在<em class="ju">语言</em>字段中选择<strong class="ih hj"> Kotlin </strong>。</p><p id="7ac1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">对于现有项目，将以下依赖项添加到<em class="ju"> pom.xml </em>文件中。</p><pre class="je jf jg jh fd jv jw jx jy aw jz bi"><span id="a09b" class="ka kb hi jw b fi kc kd l ke kf">&lt;dependency&gt;<br/>    &lt;groupId&gt;io.vertx&lt;/groupId&gt;<br/>    &lt;artifactId&gt;vertx-lang-kotlin&lt;/artifactId&gt;<br/>&lt;/dependency&gt;</span></pre><p id="6864" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">配置<code class="du kg kh ki jw b">kotlin-compiler-plugin</code>来编译 Kotlin 源代码。</p><pre class="je jf jg jh fd jv jw jx jy aw jz bi"><span id="cffb" class="ka kb hi jw b fi kc kd l ke kf">&lt;plugin&gt;<br/>    &lt;groupId&gt;org.jetbrains.kotlin&lt;/groupId&gt;<br/>    &lt;artifactId&gt;kotlin-maven-plugin&lt;/artifactId&gt;<br/>    &lt;version&gt;${kotlin.version}&lt;/version&gt;<br/>    &lt;configuration&gt;<br/>        &lt;jvmTarget&gt;16&lt;/jvmTarget&gt;<br/>    &lt;/configuration&gt;<br/>    &lt;executions&gt;<br/>        &lt;execution&gt;<br/>            &lt;id&gt;compile&lt;/id&gt;<br/>            &lt;goals&gt;<br/>                &lt;goal&gt;compile&lt;/goal&gt;<br/>            &lt;/goals&gt;<br/>        &lt;/execution&gt;<br/>        &lt;execution&gt;<br/>            &lt;id&gt;test-compile&lt;/id&gt;<br/>            &lt;goals&gt;<br/>                &lt;goal&gt;test-compile&lt;/goal&gt;<br/>            &lt;/goals&gt;<br/>        &lt;/execution&gt;<br/>    &lt;/executions&gt;<br/>&lt;/plugin&gt;</span></pre><p id="fc2b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们将使用相同的文件结构，并将<a class="ae jt" href="https://github.com/hantsy/vertx-sandbox/tree/master/post-service" rel="noopener ugc nofollow" target="_blank">原始项目(用 Java 编写)</a>迁移到 Kotlin。</p><p id="74d0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">首先让我们来看看入门级产品— <code class="du kg kh ki jw b">MainVerticle</code>。</p><pre class="je jf jg jh fd jv jw jx jy aw jz bi"><span id="1f11" class="ka kb hi jw b fi kc kd l ke kf">class MainVerticle : AbstractVerticle() {<br/>    companion object {<br/>        private val LOGGER = Logger.getLogger(MainVerticle::class.java.name)</span><span id="0f51" class="ka kb hi jw b fi kj kd l ke kf">        /**<br/>         * Configure logging from logging.properties file.<br/>         * When using custom JUL logging properties, named it to vertx-default-jul-logging.properties<br/>         * or set java.util.logging.config.file system property to locate the properties file.<br/>         */<br/>        @Throws(IOException::class)<br/>        private fun setupLogging() {<br/>            MainVerticle::class.java.getResourceAsStream("/logging.properties")<br/>                .use { f -&gt; LogManager.getLogManager().readConfiguration(f) }<br/>        }</span><span id="7eeb" class="ka kb hi jw b fi kj kd l ke kf">        init {<br/>            LOGGER.info("Customizing the built-in jackson ObjectMapper...")<br/>            val objectMapper = DatabindCodec.mapper()<br/>            objectMapper.disable(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS)<br/>            objectMapper.disable(SerializationFeature.WRITE_DATE_TIMESTAMPS_AS_NANOSECONDS)<br/>            objectMapper.disable(DeserializationFeature.READ_DATE_TIMESTAMPS_AS_NANOSECONDS)<br/>            val module = JavaTimeModule()<br/>            objectMapper.registerModule(module)<br/>        }<br/>    }</span><span id="4965" class="ka kb hi jw b fi kj kd l ke kf">    @Throws(Exception::class)<br/>    override fun start(startPromise: Promise&lt;Void&gt;) {<br/>        LOGGER.log(Level.INFO, "Starting HTTP server...")<br/>        //setupLogging();</span><span id="b42a" class="ka kb hi jw b fi kj kd l ke kf">        //Create a PgPool instance<br/>        val pgPool = pgPool()</span><span id="0ce7" class="ka kb hi jw b fi kj kd l ke kf">        //Creating PostRepository<br/>        val postRepository = PostRepository(pgPool)</span><span id="4889" class="ka kb hi jw b fi kj kd l ke kf">        //Creating PostHandler<br/>        val postHandlers = PostsHandler(postRepository)</span><span id="d9e1" class="ka kb hi jw b fi kj kd l ke kf">        // Initializing the sample data<br/>        val initializer = DataInitializer(pgPool)<br/>        initializer.run()</span><span id="18c8" class="ka kb hi jw b fi kj kd l ke kf">        // Configure routes<br/>        val router = routes(postHandlers)</span><span id="efcb" class="ka kb hi jw b fi kj kd l ke kf">        // Create the HTTP server<br/>        vertx.createHttpServer() // Handle every request using the router<br/>            .requestHandler(router) // Start listening<br/>            .listen(8888) // Print the port<br/>            .onSuccess {<br/>                startPromise.complete()<br/>                println("HTTP server started on port " + it.actualPort())<br/>            }<br/>            .onFailure {<br/>                startPromise.fail(it)<br/>                println("Failed to start HTTP server:" + it.message)<br/>            }<br/>    }</span><span id="7dff" class="ka kb hi jw b fi kj kd l ke kf">    //create routes<br/>    private fun routes(handlers: PostsHandler): Router {</span><span id="b742" class="ka kb hi jw b fi kj kd l ke kf">        // Create a Router<br/>        val router = Router.router(vertx)<br/>        // register BodyHandler globally.<br/>        //router.route().handler(BodyHandler.create());<br/>        router.get("/posts")<br/>            .produces("application/json")<br/>            .handler { handlers.all(it) }</span><span id="1dfc" class="ka kb hi jw b fi kj kd l ke kf">        router.post("/posts")<br/>            .consumes("application/json")<br/>            .handler(BodyHandler.create())<br/>            .handler { handlers.save(it) }</span><span id="9970" class="ka kb hi jw b fi kj kd l ke kf">        router.get("/posts/:id")<br/>            .produces("application/json")<br/>            .handler { handlers.getById(it) }<br/>            .failureHandler {<br/>                val error = it.failure()<br/>                if (error is PostNotFoundException) {<br/>                    it.response().setStatusCode(404).end(error.message)<br/>                }<br/>            }</span><span id="ffbe" class="ka kb hi jw b fi kj kd l ke kf">        router.put("/posts/:id")<br/>            .consumes("application/json")<br/>            .handler(BodyHandler.create())<br/>            .handler { handlers.update(it) }</span><span id="1d1d" class="ka kb hi jw b fi kj kd l ke kf">        router.delete("/posts/:id")<br/>            .handler { handlers.delete(it) }</span><span id="0083" class="ka kb hi jw b fi kj kd l ke kf">        router.get("/hello").handler { it.response().end("Hello from my route") }</span><span id="6eb1" class="ka kb hi jw b fi kj kd l ke kf">        return router<br/>    }</span><span id="3f37" class="ka kb hi jw b fi kj kd l ke kf">    private fun pgPool(): PgPool {<br/>        val connectOptions = PgConnectOptions()<br/>            .setPort(5432)<br/>            .setHost("localhost")<br/>            .setDatabase("blogdb")<br/>            .setUser("user")<br/>            .setPassword("password")</span><span id="9d65" class="ka kb hi jw b fi kj kd l ke kf">        // Pool Options<br/>        val poolOptions = PoolOptions().setMaxSize(5)</span><span id="90d8" class="ka kb hi jw b fi kj kd l ke kf">        // Create the pool from the data object<br/>        return PgPool.pool(vertx, connectOptions, poolOptions)<br/>    }<br/>}</span></pre><p id="c387" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在这个类中，我们将原来的<em class="ju">静态</em>块移动到一个<em class="ju">伴随对象</em>。</p><p id="6053" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在路由器功能中，它在路由中组装请求处理程序。让我们看看<code class="du kg kh ki jw b">PostsHandlers</code>班。</p><pre class="je jf jg jh fd jv jw jx jy aw jz bi"><span id="7785" class="ka kb hi jw b fi kc kd l ke kf">class PostsHandler(val posts: PostRepository) {<br/>    fun all(rc: RoutingContext) {<br/>//        var params = rc.queryParams();<br/>//        var q = params.get("q");<br/>//        var limit = params.get("limit") == null ? 10 : Integer.parseInt(params.get("q"));<br/>//        var offset = params.get("offset") == null ? 0 : Integer.parseInt(params.get("offset"));<br/>//        LOGGER.log(Level.INFO, " find by keyword: q={0}, limit={1}, offset={2}", new Object[]{q, limit, offset});<br/>        posts.findAll()<br/>            .onSuccess {<br/>                rc.response().end(Json.encode(it))<br/>            }</span><span id="1d47" class="ka kb hi jw b fi kj kd l ke kf">    }</span><span id="b29e" class="ka kb hi jw b fi kj kd l ke kf">    fun getById(rc: RoutingContext) {<br/>        val params = rc.pathParams()<br/>        val id = params["id"]<br/>        posts.findById(UUID.fromString(id))<br/>            .onSuccess { rc.response().end(Json.encode(it)) }<br/>            .onFailure { rc.fail(404, it) }<br/>    }</span><span id="1f3d" class="ka kb hi jw b fi kj kd l ke kf">    fun save(rc: RoutingContext) {<br/>        //rc.getBodyAsJson().mapTo(PostForm.class)<br/>        val body = rc.bodyAsJson<br/>        LOGGER.log(Level.INFO, "request body: {0}", body)<br/>        val (title, content) = body.mapTo(CreatePostCommand::class.java)<br/>        posts.save(Post(title = title, content = content))<br/>            .onSuccess { savedId: UUID -&gt;<br/>                rc.response()<br/>                    .putHeader("Location", "/posts/$savedId")<br/>                    .setStatusCode(201)<br/>                    .end()<br/>            }<br/>    }</span><span id="684b" class="ka kb hi jw b fi kj kd l ke kf">    fun update(rc: RoutingContext) {<br/>        val params = rc.pathParams()<br/>        val id = params["id"]<br/>        val body = rc.bodyAsJson<br/>        LOGGER.log(Level.INFO, "\npath param id: {0}\nrequest body: {1}", arrayOf(id, body))<br/>        var (title, content) = body.mapTo(CreatePostCommand::class.java)<br/>        posts.findById(UUID.fromString(id))<br/>            .flatMap { post: Post -&gt;<br/>                post.apply {<br/>                    title = title<br/>                    content = content<br/>                }<br/>                posts.update(post)<br/>            }<br/>            .onSuccess { rc.response().setStatusCode(204).end() }<br/>            .onFailure { rc.fail(it) }<br/>    }</span><span id="86ca" class="ka kb hi jw b fi kj kd l ke kf">    fun delete(rc: RoutingContext) {<br/>        val params = rc.pathParams()<br/>        val id = params["id"]<br/>        val uuid = UUID.fromString(id)<br/>        posts.findById(uuid)<br/>            .flatMap { posts.deleteById(uuid) }<br/>            .onSuccess { rc.response().setStatusCode(204).end() }<br/>            .onFailure { rc.fail(404, it) }<br/>    }</span><span id="64ff" class="ka kb hi jw b fi kj kd l ke kf">    companion object {<br/>        private val LOGGER = Logger.getLogger(PostsHandler::class.java.simpleName)<br/>    }<br/>}</span></pre><p id="de30" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们转到<code class="du kg kh ki jw b">PostRepository</code>类。</p><pre class="je jf jg jh fd jv jw jx jy aw jz bi"><span id="432d" class="ka kb hi jw b fi kc kd l ke kf">class PostRepository(private val client: PgPool) {</span><span id="38f6" class="ka kb hi jw b fi kj kd l ke kf">    fun findAll() = client.query("SELECT * FROM posts ORDER BY id ASC")<br/>        .execute()<br/>        .map { rs: RowSet&lt;Row?&gt; -&gt;<br/>            StreamSupport.stream(rs.spliterator(), false)<br/>                .map { mapFun(it!!) }<br/>                .toList()<br/>        }<br/></span><span id="8b73" class="ka kb hi jw b fi kj kd l ke kf">    fun findById(id: UUID) = client.preparedQuery("SELECT * FROM posts WHERE id=$1")<br/>        .execute(Tuple.of(id))<br/>        .map { it.iterator() }<br/>        .map {<br/>            if (it.hasNext()) mapFun(it.next());<br/>            throw PostNotFoundException(id)<br/>        }<br/></span><span id="a623" class="ka kb hi jw b fi kj kd l ke kf">    fun save(data: Post) = client.preparedQuery("INSERT INTO posts(title, content) VALUES ($1, $2) RETURNING (id)")<br/>        .execute(Tuple.of(data.title, data.content))<br/>        .map { it.iterator().next().getUUID("id") }<br/></span><span id="e971" class="ka kb hi jw b fi kj kd l ke kf">    fun saveAll(data: List&lt;Post&gt;): Future&lt;Int&gt; {<br/>        val tuples = data.map { Tuple.of(it.title, it.content) }</span><span id="46d0" class="ka kb hi jw b fi kj kd l ke kf">        return client.preparedQuery("INSERT INTO posts (title, content) VALUES ($1, $2)")<br/>            .executeBatch(tuples)<br/>            .map { it.rowCount() }<br/>    }</span><span id="9aa8" class="ka kb hi jw b fi kj kd l ke kf">    fun update(data: Post) = client.preparedQuery("UPDATE posts SET title=$1, content=$2 WHERE id=$3")<br/>        .execute(Tuple.of(data.title, data.content, data.id))<br/>        .map { it.rowCount() }<br/></span><span id="5503" class="ka kb hi jw b fi kj kd l ke kf">    fun deleteAll() = client.query("DELETE FROM posts").execute()<br/>        .map { it.rowCount() }<br/></span><span id="d65a" class="ka kb hi jw b fi kj kd l ke kf">    fun deleteById(id: UUID) = client.preparedQuery("DELETE FROM posts WHERE id=$1").execute(Tuple.of(id))<br/>        .map { it.rowCount() }</span><span id="66fc" class="ka kb hi jw b fi kj kd l ke kf">    companion object {<br/>        private val LOGGER = Logger.getLogger(PostRepository::class.java.name)<br/>        val mapFun: (Row) -&gt; Post = { row: Row -&gt;<br/>            Post(<br/>                row.getUUID("id"),<br/>                row.getString("title"),<br/>                row.getString("content"),<br/>                row.getLocalDateTime("created_at")<br/>            )<br/>        }</span><span id="8fed" class="ka kb hi jw b fi kj kd l ke kf">    }<br/>}</span></pre><p id="7689" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">POJO 类被转换成 Kotlin 数据类。</p><pre class="je jf jg jh fd jv jw jx jy aw jz bi"><span id="1d75" class="ka kb hi jw b fi kc kd l ke kf">//Models.kt<br/>data class Post(<br/>    var id: UUID? = null,<br/>    var title: String,<br/>    var content: String,<br/>    var createdAt: LocalDateTime? = LocalDateTime.now()<br/>)</span><span id="f0e8" class="ka kb hi jw b fi kj kd l ke kf">data class CreatePostCommand(<br/>    val title: String,<br/>    val content: String<br/>)</span></pre><p id="5701" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><code class="du kg kh ki jw b">DataIntializer</code>仍然用于在应用程序启动时插入一些样本数据。</p><pre class="je jf jg jh fd jv jw jx jy aw jz bi"><span id="135b" class="ka kb hi jw b fi kc kd l ke kf">class DataInitializer(private val client: PgPool) {</span><span id="d131" class="ka kb hi jw b fi kj kd l ke kf">    fun run() {<br/>        LOGGER.info("Data initialization is starting...")<br/>        val first = Tuple.of("Hello Quarkus", "My first post of Quarkus")<br/>        val second = Tuple.of("Hello Again, Quarkus", "My second post of Quarkus")<br/>        client<br/>            .withTransaction { conn: SqlConnection -&gt;<br/>                conn.query("DELETE FROM posts").execute()<br/>                    .flatMap {<br/>                        conn.preparedQuery("INSERT INTO posts (title, content) VALUES ($1, $2)")<br/>                            .executeBatch(listOf(first, second))<br/>                    }<br/>                    .flatMap {<br/>                        conn.query("SELECT * FROM posts").execute()<br/>                    }<br/>            }<br/>            .onSuccess { data: RowSet&lt;Row?&gt; -&gt;<br/>                StreamSupport.stream(data.spliterator(), true)<br/>                    .forEach {<br/>                        LOGGER.log(Level.INFO, "saved data:{0}", it!!.toJson())<br/>                    }<br/>            }<br/>            .onComplete {<br/>                //client.close(); will block the application.<br/>                LOGGER.info("Data initialization is done...")<br/>            }<br/>            .onFailure { LOGGER.warning("Data initialization is failed:" + it.message) }<br/>    }</span><span id="4161" class="ka kb hi jw b fi kj kd l ke kf">    companion object {<br/>        private val LOGGER = Logger.getLogger(DataInitializer::class.java.name)<br/>    }<br/>}</span></pre><p id="383d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">通过 maven 命令运行应用程序。</p><pre class="je jf jg jh fd jv jw jx jy aw jz bi"><span id="e22a" class="ka kb hi jw b fi kc kd l ke kf">mvn clean compile exec:java</span></pre><p id="ecba" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">此外，Vertx Kotlin bindings 提供了一个<code class="du kg kh ki jw b">Json</code> DSL 扩展来简化 JSON 编码。</p><pre class="je jf jg jh fd jv jw jx jy aw jz bi"><span id="bfd6" class="ka kb hi jw b fi kc kd l ke kf">it.response()<br/>     .setStatusCode(404)<br/>     .end(<br/>         json {// an example using JSON DSL<br/>             obj(<br/>                 "message" to "${it.failure().message}",<br/>                 "code" to "not_found"<br/>             )<br/>         }.toString()<br/>     )</span></pre><p id="baad" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">从我的 Github 获取源代码。</p></div></div>    
</body>
</html>