<html>
<head>
<title>Singleton Design Pattern</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">单一设计模式</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/singleton-design-pattern-4476d3204fbf?source=collection_archive---------8-----------------------#2022-06-15">https://medium.com/nerd-for-tech/singleton-design-pattern-4476d3204fbf?source=collection_archive---------8-----------------------#2022-06-15</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="c554" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Singleton，单词本身就说是单个的。这是创造性设计模式下最常用的设计模式之一。这意味着如果对象创建有问题，这种模式可以帮助开发者。那为什么说 singleton 呢，因为它只提供了一个类中的一个对象。</p><h1 id="5da6" class="jd je hi bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">让我们深入了解一下 Singleton:</h1><p id="3be1" class="pw-post-body-paragraph if ig hi ih b ii kb ik il im kc io ip iq kd is it iu ke iw ix iy kf ja jb jc hb bi translated">说到 singleton，Singleton 说一个实例。什么一个实例？<strong class="ih hj">每个容器一个实例。</strong></p><p id="57a7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在 java 中，可以简单地说为<strong class="ih hj">每个 JVM(Java 虚拟机)</strong>一个实例。</p><p id="4473" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">当实现记录器或数据库连接时，会遇到一些单例用法。</p><p id="eb48" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">当你使用这种模式时，你需要记住一些事情，尽管这是最常用和最简单的一种，但是不要试图在任何地方都使用这种模式。</p><p id="88b3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">此外，在用 singleton 创建实例时，不应该带任何参数。如果有这样的需要，请用工厂模式代替。</p><h1 id="9a87" class="jd je hi bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">如何实现 Singleton:</h1><p id="8bd0" class="pw-post-body-paragraph if ig hi ih b ii kb ik il im kc io ip iq kd is it iu ke iw ix iy kf ja jb jc hb bi translated">这是最重要的部分，因为在这里你可以清楚地看到我们如何实现 singleton。</p><p id="fa9e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在此之前，我想提一下 Singleton 中的三种实现，我希望讨论一下。光看名字可能很难。但是不用担心。念名字就行了。</p><ol class=""><li id="98a2" class="kg kh hi ih b ii ij im in iq ki iu kj iy kk jc kl km kn ko bi translated"><strong class="ih hj">单例急切实现</strong>(这是创建单例类的最简单方法)</li><li id="fbae" class="kg kh hi ih b ii kp im kq iq kr iu ks iy kt jc kl km kn ko bi translated"><strong class="ih hj">单例惰性实现</strong></li><li id="3471" class="kg kh hi ih b ii kp im kq iq kr iu ks iy kt jc kl km kn ko bi translated"><strong class="ih hj">单例双重检查</strong></li></ol><p id="211b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">请不要弄乱这些名字。我保证，理解这些比阅读那些名字更容易。</p><h2 id="3b72" class="ku je hi bd jf kv kw kx jj ky kz la jn iq lb lc jr iu ld le jv iy lf lg jz lh bi translated"><strong class="ak">实现 Singleton 的背景:</strong></h2><p id="567e" class="pw-post-body-paragraph if ig hi ih b ii kb ik il im kc io ip iq kd is it iu ke iw ix iy kf ja jb jc hb bi translated">忘记所有的事情。请记住，singleton 是<strong class="ih hj">每个容器一个实例</strong>。只要记住你可以拥有一个只提供一个对象的类。不再有任何物体创造。</p></div><div class="ab cl lj lk gp ll" role="separator"><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo"/></div><div class="hb hc hd he hf"><p id="653b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">首先，如果你希望用户不要创建一个以上的对象。<em class="li">不允许用户创建对象，</em> <em class="li">负责创建该对象。</em></p><p id="672d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">那很好。但是现在，用户怎么能得到创作对象和使用呢？好问题，对吧？</p><p id="bd3e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">你只需要<em class="li">提供一个方法用户来调用并得到创建的对象</em>。这是见过的背后的正常想法。</p></div><div class="ab cl lj lk gp ll" role="separator"><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo"/></div><div class="hb hc hd he hf"><p id="a79c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">有了这个概念，现在你需要对正常的类结构和访问修饰符有一个清晰的概念。</p><p id="0a41" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">基本上我们有两个主要的访问修饰符。</p><ol class=""><li id="2224" class="kg kh hi ih b ii ij im in iq ki iu kj iy kk jc kl km kn ko bi translated">公共-&gt;可以从任何地方访问</li><li id="b57e" class="kg kh hi ih b ii kp im kq iq kr iu ks iy kt jc kl km kn ko bi translated">private -&gt;只能在自己的类中访问</li></ol><p id="65dd" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">通常，在课堂上，我们有三样东西。</p><ol class=""><li id="4619" class="kg kh hi ih b ii ij im in iq ki iu kj iy kk jc kl km kn ko bi translated">构造函数-&gt;用于初始化对象的特殊方法</li><li id="3f77" class="kg kh hi ih b ii kp im kq iq kr iu ks iy kt jc kl km kn ko bi translated">属性-&gt;类中的字段。通常这些是“私人的”</li><li id="68f2" class="kg kh hi ih b ii kp im kq iq kr iu ks iy kt jc kl km kn ko bi translated">方法-&gt;用户调用时可以执行不同操作的代码块。</li></ol><figure class="lq lr ls lt fd lu"><div class="bz dy l di"><div class="lv lw l"/></div></figure></div><div class="ab cl lj lk gp ll" role="separator"><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo"/></div><div class="hb hc hd he hf"><h2 id="288a" class="ku je hi bd jf kv kw kx jj ky kz la jn iq lb lc jr iu ld le jv iy lf lg jz lh bi translated"><strong class="ak">实现 Singleton 的关键背景:</strong></h2><p id="c87d" class="pw-post-body-paragraph if ig hi ih b ii kb ik il im kc io ip iq kd is it iu ke iw ix iy kf ja jb jc hb bi translated">这是要记住的非常重要的事情。我更愿意问一些问题，澄清实现 singleton 的问题。</p><p id="b5bd" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="li"> 1。当我们创建对象时，类中最重要的是什么？</em></p><p id="80e5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">是的，你是正确的。那是<strong class="ih hj">构造函数</strong>，因为那是用来初始化对象的，对吗？</p><p id="3d41" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="li"> 2。没事的。但是我们可以为构造函数设置“公共”和“私有”访问修饰符。当我们实现单例时，我们需要使用什么？</em></p><p id="eb68" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">你能猜到吗？</p><p id="813e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们需要做的是，<em class="li">我们需要限制用户创建对象</em>。<strong class="ih hj"> </strong>这意味着，我们不应该给用户创建对象的权限。通常我们如何创建一个对象？</p><p id="0222" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">你将使用 new 关键字并调用构造函数，对吗？</p><figure class="lq lr ls lt fd lu"><div class="bz dy l di"><div class="lv lw l"/></div></figure><p id="bea4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在你会明白，有必要有一个‘公共’构造函数，如果你给用户一个创建对象的机会。</p><p id="d2ef" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">那么问题 2 的答案是，如果你想限制用户创建对象，<strong class="ih hj">你</strong> <strong class="ih hj">应该让你的构造函数</strong> <strong class="ih hj">成为‘私有’</strong>。</p><p id="525c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">* * *我的第一点现在实现了，确保你必须拥有带有 singleton*** </strong>的“私有构造函数”</p></div><div class="ab cl lj lk gp ll" role="separator"><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo"/></div><div class="hb hc hd he hf"><p id="05ef" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">3.之后，用户不能从类中创建任何对象，但是用户希望只有一个对象。那么，你如何实现这一点呢？</p><p id="55db" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">答案很简单。</p><p id="d10f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">你需要<strong class="ih hj"> <em class="li">提供一个方法</em> </strong>来执行这个动作。</p><p id="c658" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">4.该方法将返回什么？</p><p id="5623" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们的目标是提供创建的对象，对吗？</p><p id="b64d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">然后肯定，你会<strong class="ih hj"> <em class="li">返回一个学生对象</em> </strong>。</p><p id="67c3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">5.一切都好吗？没有权利。如果用户不能从类中创建对象，用户将如何调用该方法？</p><p id="94f8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">有<strong class="ih hj"> <em class="li">【静态法】</em> </strong>就是答案。</p><p id="ad33" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这是第二点。至此，我们实现 singleton 的基本背景制作完毕。</p><p id="c8ec" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">* * *请提供一个将返回对象的静态方法。*** </strong></p><h2 id="994f" class="ku je hi bd jf kv kw kx jj ky kz la jn iq lb lc jr iu ld le jv iy lf lg jz lh bi translated"><strong class="ak">移至单例的真实实现:</strong></h2><p id="1dbd" class="pw-post-body-paragraph if ig hi ih b ii kb ik il im kc io ip iq kd is it iu ke iw ix iy kf ja jb jc hb bi translated">到目前为止，您已经了解了实现 singleton 的关键是什么。因此，我们可以在牢记这些概念的情况下，转向真正的实现。</p><p id="16a8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">一定要记住这 2 点。</p><ol class=""><li id="fbb1" class="kg kh hi ih b ii ij im in iq ki iu kj iy kk jc kl km kn ko bi translated"><strong class="ih hj">你得有“私有构造函数”</strong></li><li id="bcfb" class="kg kh hi ih b ii kp im kq iq kr iu ks iy kt jc kl km kn ko bi translated">你需要提供一个静态方法来从类中返回一个对象。</li></ol><p id="fcdb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在上面的部分，我提到我希望讨论 3 种类型的 singleton 实现。</p><p id="6692" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们一个一个学。你准备好了吗？</p><p id="3d94" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们跳到第一个。</p><h1 id="c321" class="jd je hi bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">1.<strong class="ak">单例急切实现</strong></h1><p id="db75" class="pw-post-body-paragraph if ig hi ih b ii kb ik il im kc io ip iq kd is it iu ke iw ix iy kf ja jb jc hb bi translated">singleton 的基本实现是这样的。因此，它仅仅考虑了所提到的主要两点。</p><figure class="lq lr ls lt fd lu"><div class="bz dy l di"><div class="lv lw l"/></div></figure><p id="5a47" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">正如上面的代码，我们可以有我们的 singleton 的基本实现。这里发生的是，用户不能创建对象。</p><p id="abb8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们提供了返回对象的静态方法，在类内部，我们使用新的关键字创建对象。那只是。</p><p id="3876" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我很确定，如果你有很强的背景知识。这是理解单例的一种非常简单而有趣的方式</p><h2 id="5c00" class="ku je hi bd jf kv kw kx jj ky kz la jn iq lb lc jr iu ld le jv iy lf lg jz lh bi translated"><strong class="ak">急于实施的问题:</strong></h2><p id="d472" class="pw-post-body-paragraph if ig hi ih b ii kb ik il im kc io ip iq kd is it iu ke iw ix iy kf ja jb jc hb bi translated">这很好，但是如果我们使用这个实现，可能会出现一些问题。这个问题将用这个代码来讨论。</p><figure class="lq lr ls lt fd lu"><div class="bz dy l di"><div class="lv lw l"/></div></figure><p id="0731" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们可以调用 getInstance()方法，尽可能多地获取对象。但是，等等，什么？我们可以尽可能多地获得对象。</p><p id="db88" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">不，不，我的意思是我们可以调用和希望对象，但你可以在例子中看到，我们只得到一个对象作为' StudentEagerSingleton@5e91993f '。是的，我们的目标已经完成了。</p><p id="3942" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">但是，<strong class="ih hj">在我们使用这个实现的时候有一些限制。以及它会在每次调用时创建对象，而不考虑是否需要它。</strong></p><p id="b99d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">有一个实现怎么样，它将在需要时创建实例。就是这个时候，懒实现来了。</p><h1 id="05bc" class="jd je hi bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">2.单一惰性实现</h1><p id="679c" class="pw-post-body-paragraph if ig hi ih b ii kb ik il im kc io ip iq kd is it iu ke iw ix iy kf ja jb jc hb bi translated">如上所述，使用惰性初始化，你只在需要的时候创建实例。</p><p id="6938" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">要做到这一点，您可以简单地让<strong class="ih hj">变量只声明</strong>和<strong class="ih hj">，如果变量为空，那么当用户调用 getInstance()方法时，从类中创建一个新的实例</strong>。</p><figure class="lq lr ls lt fd lu"><div class="bz dy l di"><div class="lv lw l"/></div></figure><h2 id="7876" class="ku je hi bd jf kv kw kx jj ky kz la jn iq lb lc jr iu ld le jv iy lf lg jz lh bi translated">延迟实现的问题:</h2><p id="5b34" class="pw-post-body-paragraph if ig hi ih b ii kb ik il im kc io ip iq kd is it iu ke iw ix iy kf ja jb jc hb bi translated">这个实现有什么问题吗？我有两个答案。</p><ol class=""><li id="6402" class="kg kh hi ih b ii ij im in iq ki iu kj iy kk jc kl km kn ko bi translated"><strong class="ih hj">其实没有</strong>。如果不需要在多线程环境下使用。</li><li id="5c72" class="kg kh hi ih b ii kp im kq iq kr iu ks iy kt jc kl km kn ko bi translated"><strong class="ih hj">其实是的</strong>。如果你想要一个<strong class="ih hj"> <em class="li">线程安全的单例</em> </strong>。</li></ol><p id="f5c4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">啊，这意味着这不是一个线程安全的。对吗？</p><p id="5b80" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">但是为什么它不是线程安全的呢？</p><p id="6371" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">事情就是这样发生的。让我考虑两个线程，</p><p id="79cd" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">第一个线程进入 getInstance()方法，它将检查 student 实例是否为空。如果它是空的，它将在块内来来去去，它将创建一个新的对象。</p><p id="3b31" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">当它正在创建时，第二个线程来询问 student 实例是否为空。同时，线程一正在创建新对象。所以它说，是的，学生实例为空。</p><p id="d9d4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">因此，它将允许第二个线程创建一个新的实例。</p><p id="4299" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在您可以看到，在这种情况下，它可能会创建 2 个实例，而不是只有一个实例。</p><p id="1a49" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这就是我们称之为懒惰实现不适合多线程环境的原因。它不是线程安全的。</p><p id="b1a8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">单例双重检查来迎接我们，因为它有能力给线程安全的单例。</p><h1 id="49e9" class="jd je hi bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">3.单一双重检查</h1><p id="6089" class="pw-post-body-paragraph if ig hi ih b ii kb ik il im kc io ip iq kd is it iu ke iw ix iy kf ja jb jc hb bi translated">这里，我们使用<strong class="ih hj">同步块</strong>来生成线程安全代码。</p><figure class="lq lr ls lt fd lu"><div class="bz dy l di"><div class="lv lw l"/></div></figure><p id="cd1c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">同步块所做的是，它允许一个线程执行块内的工作，并为其他线程锁定。</p><p id="f484" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">当第一个线程来询问实例的状态时，如果它为空，那么它允许第一个线程来执行工作。但是其他线程必须等待，直到它完成代码块中的工作。</p><p id="4859" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">那么它将防止在多线程环境中创建多个实例。</p><p id="7083" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">注:</strong></p><p id="5a1a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">一些开发人员使用 getInstance()方法的同步块。但是不要那么做。因为当方法有许多操作要执行时，这可能会影响性能。</p><p id="4139" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">因为它会为其他线程锁定整个方法，而这些线程会一直等到锁被释放。因此，不建议采用这种方法。</p><figure class="lq lr ls lt fd lu"><div class="bz dy l di"><div class="lv lw l"/></div></figure><p id="8673" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Singleton 很简单对吧。祝大家学习愉快。</p><p id="a2ef" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">代码示例:</strong></p><p id="9488" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><a class="ae lx" href="https://github.com/harshani2427/learn-with-krish/tree/master/Design%20Patterns/Singleton" rel="noopener ugc nofollow" target="_blank">https://github . com/harshani 2427/learn-with-krish/tree/master/Design % 20 patterns/Singleton</a></p><h2 id="7a40" class="ku je hi bd jf kv kw kx jj ky kz la jn iq lb lc jr iu ld le jv iy lf lg jz lh bi translated"><strong class="ak">参考文献:</strong></h2><p id="8f9c" class="pw-post-body-paragraph if ig hi ih b ii kb ik il im kc io ip iq kd is it iu ke iw ix iy kf ja jb jc hb bi translated"><a class="ae lx" href="https://youtu.be/g7RfBhO-rhU" rel="noopener ugc nofollow" target="_blank">https://youtu.be/g7RfBhO-rhU</a></p><p id="9616" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><a class="ae lx" href="https://www.programiz.com/java-programming/singleton" rel="noopener ugc nofollow" target="_blank">https://www.programiz.com/java-programming/singleton</a></p><p id="9cf5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><a class="ae lx" href="https://www.journaldev.com/1377/java-singleton-design-pattern-best-practices-examples" rel="noopener ugc nofollow" target="_blank">https://www . journal dev . com/1377/Java-singleton-design-pattern-best-practices-examples</a></p></div></div>    
</body>
</html>