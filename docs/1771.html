<html>
<head>
<title>Build a Microservice App Using gRPC, Python, and Golang (Part 4)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用gRPC、Python和Golang构建微服务应用程序(第4部分)</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/build-a-microservice-app-using-grpc-python-and-golang-part-4-421bcdc3def0?source=collection_archive---------14-----------------------#2021-04-05">https://medium.com/nerd-for-tech/build-a-microservice-app-using-grpc-python-and-golang-part-4-421bcdc3def0?source=collection_archive---------14-----------------------#2021-04-05</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/696ce1732f576ce0b78dce8016d95b1c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*e4GCtvgSRa5hrk6U"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">照片由<a class="ae iu" href="https://unsplash.com/@borkography?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">亚当·博尔科夫斯基</a>在<a class="ae iu" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="dde8" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">欢迎回到使用gRPC、Python和Golang构建微服务应用程序的系列。这是我们旅程的最后一部分。如果您从一开始就关注这个系列，您可能知道这个应用程序是REST和gRPC的某种混合体。所以这一次，我们可以通过使用Jinja2模板引擎创建前端来改变这一点。让我们开始…</p></div><div class="ab cl jt ju gp jv" role="separator"><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy"/></div><div class="hb hc hd he hf"><h1 id="7518" class="ka kb hi bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated">创建布局模板并更改根视图</h1><p id="5d9f" class="pw-post-body-paragraph iv iw hi ix b iy ky ja jb jc kz je jf jg la ji jj jk lb jm jn jo lc jq jr js hb bi translated">如果你知道React或Vue，可能你已经熟悉了组件或窗口小部件的概念，但不仅仅是在React和Vue中，我们可以将HTML部分分离到它自己的文件中，我们也可以用Jinja2做到这一点，尽管实现非常不同。现在，我们需要创建一个将在每个页面上使用的布局模板。在此之前，在<code class="du ld le lf lg b">main</code>服务的根目录下做一个文件夹，命名为<code class="du ld le lf lg b">templates</code>，然后做一个文件，命名为<code class="du ld le lf lg b">layout.html</code>。Flask会在我们调用<code class="du ld le lf lg b">render_template</code>函数的时候寻找这个文件夹，寻找匹配的HTML文件。</p><figure class="lh li lj lk fd ij"><div class="bz dy l di"><div class="ll lm l"/></div></figure><p id="bf57" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">让我们仔细分析这段代码。在第7行，我们写了一个链接标签来连接HTML文件和CSS文件，注意我们使用了Jinja2提供的<code class="du ld le lf lg b">url_for</code>函数。在第8行，我们写了一个块，这是我们在使用这个布局模板时必须实现的代码部分；第13行和第14行也是一样，但是第14行非常特殊，因为这是我们主要内容将要放置的块。</p><p id="49db" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在第18到25行，我们为我们的应用程序写了一个简单的导航条。if条件将确保只有登录的用户可以获得他们的todo并创建todo，否则他们必须首先注册然后登录。</p><p id="8216" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">接下来，为我们的<code class="du ld le lf lg b">root_router</code>视图功能创建一个主页。在<code class="du ld le lf lg b">templates</code>文件夹中创建一个名为<code class="du ld le lf lg b">home.html</code>的文件。</p><figure class="lh li lj lk fd ij"><div class="bz dy l di"><div class="ll lm l"/></div></figure><p id="15ae" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在上面的代码中，我们在<code class="du ld le lf lg b">home.html</code>中使用了<code class="du ld le lf lg b">layout</code>。在第2行，我们将主页的标题设置为<code class="du ld le lf lg b">Welcome Folks</code>，将第3行的内容标题设置为<code class="du ld le lf lg b">Hello World</code>。就像我之前提到的，内容块是我们放置主要内容的地方，在这里我们只放<code class="du ld le lf lg b">lorem ipsum</code>。如果你知道在这里放什么，请随意。</p><p id="ee76" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">将根路由器视图更改为如下所示。</p><figure class="lh li lj lk fd ij"><div class="bz dy l di"><div class="ll lm l"/></div></figure><p id="8d16" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">记住你也必须从顶部的flask导入<code class="du ld le lf lg b">render_template</code>函数。</p><p id="60c7" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这个页面的结果是这样的。</p><figure class="lh li lj lk fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ln"><img src="../Images/9394c84776978973b3b3e28a15ac5b3a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cfOp93MjsC2FmW98CrrADA.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">作者形象</figcaption></figure><p id="4d8c" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">不是很好的设计对吗？没关系，因为这个系列的主要目的不是关于设计或前端:)。你可以在这里得到CSS文件<a class="ae iu" href="https://github.com/agusrichard/python-golang-grpc/blob/part4/main-service/static/styles.css" rel="noopener ugc nofollow" target="_blank">。</a></p></div><div class="ab cl jt ju gp jv" role="separator"><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy"/></div><div class="hb hc hd he hf"><h1 id="07a4" class="ka kb hi bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated">注册和登录页面</h1><p id="d82d" class="pw-post-body-paragraph iv iw hi ix b iy ky ja jb jc kz je jf jg la ji jj jk lb jm jn jo lc jq jr js hb bi translated">下一步是创建注册页面并更改其视图功能。</p><p id="c0c9" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">现在，在<code class="du ld le lf lg b">templates</code>中创建一个文件夹并命名为<code class="du ld le lf lg b">auth</code>，然后在其中创建一个文件并命名为<code class="du ld le lf lg b">register.html</code>。</p><figure class="lh li lj lk fd ij"><div class="bz dy l di"><div class="ll lm l"/></div></figure><p id="56ff" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">注意，我们需要一些东西来使它正常工作，那就是<code class="du ld le lf lg b">macros</code>。你可以把它看作是React中的一个组件，或者是一个呈现HTML某个部分的函数。让我们在<code class="du ld le lf lg b">templates</code>文件夹中创建两个名为<code class="du ld le lf lg b">forms.html</code>和<code class="du ld le lf lg b">macros.html</code>的文件。</p><figure class="lh li lj lk fd ij"><div class="bz dy l di"><div class="ll lm l"/></div></figure><figure class="lh li lj lk fd ij"><div class="bz dy l di"><div class="ll lm l"/></div></figure><p id="6b75" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">上面还定义了其他几个<code class="du ld le lf lg b">macros</code>，我们后面还需要这个<code class="du ld le lf lg b">macros</code>。正如您可能想到的，在表单部分，用户必须填写他们的用户名和密码，然后该信息将由使用该模板的视图函数处理。</p><p id="0710" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">现在，我们必须改变注册页面的视图功能。</p><figure class="lh li lj lk fd ij"><div class="bz dy l di"><div class="ll lm l"/></div></figure><p id="c16b" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们来剖析一下上面的代码。首先，这个函数决定使用哪种请求方法。如果它是GET方法，那么它将跳转到最后一行并返回注册页面的模板，而不将任何变量传递给模板。如果是POST方法，那么它将进入<code class="du ld le lf lg b">try-except</code>块，如果在这个块中出现了一些错误，那么这个视图函数将返回一个注册页面的模板，并向该模板传递一个错误变量，因此用户可以看到错误消息。这里，我们还必须检查用户是否提供了用户名和密码，因为这两个字段是必需的。如果一切顺利，用户将被重定向到登录页面。</p><p id="5323" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">接下来，让我们创建登录页面并更改其视图功能。</p><figure class="lh li lj lk fd ij"><div class="bz dy l di"><div class="ll lm l"/></div></figure><figure class="lh li lj lk fd ij"><div class="bz dy l di"><div class="ll lm l"/></div></figure><p id="e6aa" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">用于登录的模板文件与注册页面非常相似，还有它的视图功能。不同的是，当登录过程顺利时，<code class="du ld le lf lg b">auth_client.login</code>方法返回的令牌存储在<code class="du ld le lf lg b">session</code>对象中。这很重要，因为我们需要被认证来创建todo和获取我们的todo。</p><p id="8ecc" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们的注册和登录页面将如下所示。</p><figure class="lh li lj lk fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ln"><img src="../Images/d5e676971110c246af42617a346be2cb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fp5Gy8UNzvifS0Oxny3CWw.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">作者形象</figcaption></figure><figure class="lh li lj lk fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ln"><img src="../Images/9f266cf22351d5729503d82e32474d4b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Js1U9OiLAzgCcwiBNkojuw.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">作者形象</figcaption></figure><p id="ffbd" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在跳转到todo部分之前，需要创建一个注销视图函数。你可以看到navbar里面有一个注销按钮(在你登录之后)，所以当用户点击那个按钮的时候，就会触发这个查看功能，清除会话，把用户重定向到登录页面。</p><figure class="lh li lj lk fd ij"><div class="bz dy l di"><div class="ll lm l"/></div></figure></div><div class="ab cl jt ju gp jv" role="separator"><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy"/></div><div class="hb hc hd he hf"><h1 id="d20c" class="ka kb hi bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated">待办事项列表</h1><p id="ebd5" class="pw-post-body-paragraph iv iw hi ix b iy ky ja jb jc kz je jf jg la ji jj jk lb jm jn jo lc jq jr js hb bi translated">用户登录后，他们将被重定向到待办事项列表页面。所以先把这一页做出来。创建一个名为<code class="du ld le lf lg b">todo</code>的文件夹，并在其中创建一个名为<code class="du ld le lf lg b">list.html</code>的文件。</p><figure class="lh li lj lk fd ij"><div class="bz dy l di"><div class="ll lm l"/></div></figure><p id="7c05" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们还在这里扩展<code class="du ld le lf lg b">layout.html</code>。在<code class="du ld le lf lg b">div</code>标签内部，有一个if条件；如果有待办事项(列表不为空)，那么将呈现每个待办事项。但是如果列表是空的，它将呈现<code class="du ld le lf lg b">p</code>标签(没有todos)。现在，让我们看看<code class="du ld le lf lg b">get_todos</code>的视图功能。</p><figure class="lh li lj lk fd ij"><div class="bz dy l di"><div class="ll lm l"/></div></figure><p id="b252" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">上面的代码将把检索到的登录用户的todos数据传递给模板，如果有错误，它将呈现带有错误消息的模板。请注意，我们从使用<code class="du ld le lf lg b">g</code>(应用程序上下文)转移到了<code class="du ld le lf lg b">session</code>。有一个很好的理由，你可以在这里找到它。基本上，最好使用<code class="du ld le lf lg b">session</code>来存储请求之间的数据，而不是应用程序上下文<code class="du ld le lf lg b">g</code>。所以我们必须改变中间件。</p><figure class="lh li lj lk fd ij"><div class="bz dy l di"><div class="ll lm l"/></div></figure></div><div class="ab cl jt ju gp jv" role="separator"><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy"/></div><div class="hb hc hd he hf"><h1 id="a07f" class="ka kb hi bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated">创建待办事项</h1><p id="32d9" class="pw-post-body-paragraph iv iw hi ix b iy ky ja jb jc kz je jf jg la ji jj jk lb jm jn jo lc jq jr js hb bi translated">在<code class="du ld le lf lg b">templates/todo</code>目录下创建一个文件，命名为<code class="du ld le lf lg b">create.html</code>。</p><figure class="lh li lj lk fd ij"><div class="bz dy l di"><div class="ll lm l"/></div></figure><p id="27f8" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">从上面的代码中，我们看到在<code class="du ld le lf lg b">div</code>标签中有一个表单部分，用户可以在其中填写他们的todo的标题和描述；如果有一些错误，它将被呈现在表单下面。接下来，更改创建todo的视图函数。</p><figure class="lh li lj lk fd ij"><div class="bz dy l di"><div class="ll lm l"/></div></figure><p id="0604" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如果请求方法是POST，todo的标题和描述将从<code class="du ld le lf lg b">request.form</code>字典中提取，如果一切顺利，它将把用户重定向到todo列表页面。</p></div><div class="ab cl jt ju gp jv" role="separator"><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy"/></div><div class="hb hc hd he hf"><h1 id="416f" class="ka kb hi bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated">获取单个待办事项，更新并删除它</h1><p id="2397" class="pw-post-body-paragraph iv iw hi ix b iy ky ja jb jc kz je jf jg la ji jj jk lb jm jn jo lc jq jr js hb bi translated">如果你注意到了，我们没有实现任何过程来获得一个单独的todo，我们忘记这样做了。所以，让我们现在就开始吧！</p><p id="1ec6" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">有几件事我们需要改变，从<code class="du ld le lf lg b">todo</code>服务和<code class="du ld le lf lg b">main</code>服务中的<code class="du ld le lf lg b">todo.proto</code>开始。</p><figure class="lh li lj lk fd ij"><div class="bz dy l di"><div class="ll lm l"/></div></figure><p id="338b" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们添加了<code class="du ld le lf lg b">request</code>和<code class="du ld le lf lg b">response</code>来获得单个todo，以及它在<code class="du ld le lf lg b">service</code>块中的过程。然后，运行此命令重新生成gRPC代码。</p><p id="ecde" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">用于<code class="du ld le lf lg b">todo</code>服务。</p><pre class="lh li lj lk fd lo lg lp lq aw lr bi"><span id="f167" class="ls kb hi lg b fi lt lu l lv lw">protoc --go_out=./todo --go_opt=paths=source_relative \</span><span id="902f" class="ls kb hi lg b fi lx lu l lv lw">--go-grpc_out=./todo --go-grpc_opt=paths=source_relative \</span><span id="0067" class="ls kb hi lg b fi lx lu l lv lw">./todo.proto</span></pre><p id="4e12" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">为<code class="du ld le lf lg b">main</code>服务。</p><pre class="lh li lj lk fd lo lg lp lq aw lr bi"><span id="83d2" class="ls kb hi lg b fi lt lu l lv lw">python -m grpc_tools.protoc -I. --python_out=./todo --grpc_python_out=./todo ./todo.proto</span></pre><p id="5fc3" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">接下来，我们必须在<code class="du ld le lf lg b">todo</code>服务中添加实现。</p><figure class="lh li lj lk fd ij"><div class="bz dy l di"><div class="ll lm l"/></div></figure><figure class="lh li lj lk fd ij"><div class="bz dy l di"><div class="ll lm l"/></div></figure><figure class="lh li lj lk fd ij"><div class="bz dy l di"><div class="ll lm l"/></div></figure><p id="55d7" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这个处理函数的功能是根据它的ID和用户ID获取一个todo。</p><p id="8e2d" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">现在，让我们改变一下<code class="du ld le lf lg b">main</code>服务。为<code class="du ld le lf lg b">TodoClient</code>添加一个名为<code class="du ld le lf lg b">get_todo</code>的新方法。</p><figure class="lh li lj lk fd ij"><div class="bz dy l di"><div class="ll lm l"/></div></figure><figure class="lh li lj lk fd ij"><div class="bz dy l di"><div class="ll lm l"/></div></figure><p id="b523" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">从上面的代码中，我们在<code class="du ld le lf lg b">templates/todo</code>目录中使用了另一个名为<code class="du ld le lf lg b">item.html</code>的模板文件。那么，让我们创建这个文件。</p><figure class="lh li lj lk fd ij"><div class="bz dy l di"><div class="ll lm l"/></div></figure><p id="a11a" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">要访问此页面，用户必须单击待办事项列表页面上的待办事项之一。在这里，用户可以查看单个待办事项，更新和删除它，还可以返回到待办事项列表页面。</p><p id="115c" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">接下来，我们必须更改视图函数来更新和删除todo。</p><figure class="lh li lj lk fd ij"><div class="bz dy l di"><div class="ll lm l"/></div></figure><p id="bad4" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这两个视图功能的应用流程是，在用户填写指定的字段(标题和描述)后，他们将停留在带有新的更新标题或描述的详细信息页面，如果出现任何错误，将在表单下方显示一条错误消息。对于删除功能，用户将被重定向到待办事项列表页面。</p><p id="9a57" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这是这个页面的样子。</p><figure class="lh li lj lk fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ln"><img src="../Images/e1f949f5cfcc11d802ee263f4990c21b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*i_zmQc_TtthghnzIR1egwQ.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">作者形象</figcaption></figure></div><div class="ab cl jt ju gp jv" role="separator"><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy"/></div><div class="hb hc hd he hf"><p id="3a85" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">万岁，我们的申请完成了。对于一个非常简单的应用程序来说，有很多工作要做，对吗？通过阅读本系列文章，我希望您能够了解gRPC的概念、gRPC如何被认为优于REST、使用gRPC在Python和Golang中构建应用程序的体验以及更多内容。</p><p id="f481" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">你可以在这里找到这篇文章的代码<a class="ae iu" href="https://github.com/agusrichard/python-golang-grpc" rel="noopener ugc nofollow" target="_blank">https://github.com/agusrichard/python-golang-grpc</a>。</p><p id="6d46" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如果您有任何问题或反馈，请随时留下评论或通过电子邮件联系我，agus.richard21@gmail.com。另外，如果你认为这篇文章对你有帮助，请不要犹豫，给这篇文章鼓掌。</p><p id="d0e0" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如果你想在你的某个项目上与我合作，或者要求加入你的网络，你可以通过<a class="ae iu" href="http://agus.richard21@gmail.com" rel="noopener ugc nofollow" target="_blank">电子邮件</a>或<a class="ae iu" href="https://www.linkedin.com/in/agus-richard/" rel="noopener ugc nofollow" target="_blank"> LinkedIn </a>与我联系。</p><p id="3625" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">感谢您的阅读，祝您愉快。</p></div></div>    
</body>
</html>