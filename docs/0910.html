<html>
<head>
<title>What is wrong with current mobile development?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">现在的移动开发出了什么问题？</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/what-is-wrong-with-current-mobile-development-3675ce94ccf5?source=collection_archive---------3-----------------------#2021-02-22">https://medium.com/nerd-for-tech/what-is-wrong-with-current-mobile-development-3675ce94ccf5?source=collection_archive---------3-----------------------#2021-02-22</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><h2 id="8ef2" class="hg hh hi bd b fp hj hk hl hm hn ho dx hp translated" aria-label="kicker paragraph">移动应用中的反应式编程——一次旅行</h2><div class=""/><div class=""><h2 id="ceaf" class="pw-subtitle-paragraph io hr hi bd b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf dx translated">当web和混合开发架构蓬勃发展时，由于架构师从头开始创建它们，原生移动开发——Android和iOS——坐在板凳上</h2></div><h2 id="8066" class="jg jh hi bd ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc ho bi translated">介绍</h2><p id="1a07" class="pw-post-body-paragraph kd ke hi kf b kg kh is ki kj kk iv kl jr km kn ko jv kp kq kr jz ks kt ku kv hb bi translated">几年前，当我第一次被介绍到<a class="ae kw" href="https://reactjs.org/tutorial/tutorial.html#overview" rel="noopener ugc nofollow" target="_blank">脸书的<em class="kx"> React.js </em> </a>(以及<a class="ae kw" href="https://redux.js.org/tutorials/essentials/part-1-overview-concepts#what-is-redux" rel="noopener ugc nofollow" target="_blank"> <em class="kx"> Redux </em> </a>)进行web开发时，我有点震惊，我承认——这与我习惯的<em class="kx"> Android </em>开发毫无关系。<br/>没过多久，我又一次感到震惊，甚至充满了愤怒——为什么在<em class="kx"> JavaScript </em>中会有这种<em class="kx">反应式</em>、结构化、坚实的<em class="kx"> web </em>开发库，而<em class="kx"> Android/iOS </em>开发经验仍然……嗯……<strong class="kf hs">陈旧</strong>。</p><blockquote class="ky kz la"><p id="3bb3" class="kd ke kx kf b kg lb is ki kj lc iv kl ld le kn ko lf lg kq kr lh li kt ku kv hb bi translated">从这一点开始，我将专门谈论<em class="hi"> Android </em>，但我向你保证——iOS是<em class="hi">不</em>更好，哦不</p></blockquote><figure class="lk ll lm ln fd lo er es paragraph-image"><div role="button" tabindex="0" class="lp lq di lr bf ls"><div class="er es lj"><img src="../Images/b64f0853aac18f1bc1305cca66da3308.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0NWhZRmMDtB5OdJiF657Vg.jpeg"/></div></div><figcaption class="lv lw et er es lx ly bd b be z dx translated">伟大的建筑造就伟大的美。土耳其伊斯坦布尔。</figcaption></figure></div><div class="ab cl lz ma gp mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="hb hc hd he hf"><h2 id="253e" class="jg jh hi bd ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc ho bi translated">愤怒和羞耻</h2><p id="349a" class="pw-post-body-paragraph kd ke hi kf b kg kh is ki kj kk iv kl jr km kn ko jv kp kq kr jz ks kt ku kv hb bi translated">这篇文章是许多文章中的第一篇。它的主要目的是让移动开发人员<strong class="kf hs">清醒过来</strong>——直到不久前还被一个纯粹的实用程序库(<a class="ae kw" href="https://jquery.com/" rel="noopener ugc nofollow" target="_blank"> <em class="kx"> JQuery </em> </a>)所主宰的web开发，已经遥遥领先于我们。事实上，Web开发是如此领先于移动开发，以至于<em class="kx">反应本地的</em>一个<em class="kx"> JavaScript/TypeScript </em>环境，威胁接管<em class="kx">编译的</em>、<em class="kx">静态类型的</em>、<em class="kx">平滑的UX </em>移动开发。当前的移动环境太过时了，以至于整个世界都开始牺牲用户体验来开发更便宜、更容易和更快的产品。如果你问我，这是一个非常糟糕的笑话。我既是一名网络开发人员，也是一名移动开发人员，但我仍然对这种趋势感到不快。</p><blockquote class="ky kz la"><p id="46f9" class="kd ke kx kf b kg lb is ki kj lc iv kl ld le kn ko lf lg kq kr lh li kt ku kv hb bi translated">编辑:在完成这个系列的时候，Android终于发布了一个稳定版本的<a class="ae kw" href="https://developer.android.com/jetpack/compose" rel="noopener ugc nofollow" target="_blank"> JetpackCompose </a>，它基本上模仿了React的功能组件。再加上<a class="ae kw" href="https://kotlinlang.org/docs/coroutines-overview.html" rel="noopener ugc nofollow" target="_blank">协同例程</a>和<a class="ae kw" href="https://reduxkotlin.org/" rel="noopener ugc nofollow" target="_blank">科特林-Redux </a>，这是一个强大的“包”，经过一些努力，可以一起用来解决我在这里介绍的许多问题。<br/>虽然所有这些都是真的(并且您应该熟悉上面的技术)，但是我们将在本系列中学习的概念现在<strong class="kf hs"/><strong class="kf hs"/>甚至<strong class="kf hs">比以往更加相关</strong>——编写移动应用程序的“标准”方式越来越接近提到的概念。</p></blockquote></div><div class="ab cl lz ma gp mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="hb hc hd he hf"><h1 id="829d" class="mg jh hi bd ji mh mi mj jm mk ml mm jq ix mn iy ju ja mo jb jy jd mp je kc mq bi translated">我们将在这些文章中讨论什么</h1><p id="0061" class="pw-post-body-paragraph kd ke hi kf b kg kh is ki kj kk iv kl jr km kn ko jv kp kq kr jz ks kt ku kv hb bi translated">我们将快速概述一种<em class="kx">反应式</em>方法，特别是一种<em class="kx"> React-Redux </em>式的移动开发方法。<br/>我们将从<em class="kx">为什么</em>开始，继续<em class="kx">什么</em>并以一点点<em class="kx">如何</em>结束。接下来的章节将在技术上更深入，帮助我们形成一个完整的<em class="kx"/><a class="ae kw" href="https://proandroiddev.com/getting-started-with-mvi-architecture-on-android-b2c280b7023" rel="noopener ugc nofollow" target="_blank"><em class="kx"/></a><em class="kx"/><a class="ae kw" rel="noopener" href="/@grover.vinayak0611/what-is-flux-architecture-why-facebook-used-it-and-the-comparison-with-mvc-architecture-49c01ed5d2e1"><em class="kx">通量</em> </a> <em class="kx"> </em>架构。这将是一次漫长而有趣的旅行🚂。<br/>这些文章是为每一个(移动、网络)开发者准备的，并且将展示一个完整的工作架构。它目前只适用于<em class="kx"> Android </em>，但是有一个纯粹的<em class="kx"> Kotlin </em>内核，并且打算/可以为<a class="ae kw" href="https://blog.jetbrains.com/kotlin/2020/08/kotlin-multiplatform-mobile-goes-alpha/#:~:text=Kotlin%20Multiplatform%20Mobile%20(KMM)%20is,both%20iOS%20and%20Android%20applications.&amp;text=It%20includes%20the%20new%20KMM,code%20in%20the%20same%20IDE." rel="noopener ugc nofollow" target="_blank"> <em class="kx"> Kotlin多平台</em> </a> <em class="kx"> ( </em>如果有人想加入我的旅程，请随时联系我)。<br/>所以……来了<em class="kx">为什么</em>、<em class="kx">什么</em>和<em class="kx">如何。</em></p></div><div class="ab cl lz ma gp mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="hb hc hd he hf"><h1 id="fe7b" class="mg jh hi bd ji mh mi mj jm mk ml mm jq ix mn iy ju ja mo jb jy jd mp je kc mq bi translated">为什么(目前的方法还不够吗)？</h1><p id="6e17" class="pw-post-body-paragraph kd ke hi kf b kg kh is ki kj kk iv kl jr km kn ko jv kp kq kr jz ks kt ku kv hb bi translated">当前创建移动应用程序的<em class="kx">风格</em>的问题就在于此——这是一种<em class="kx">风格</em> —远不止是一种架构。它没有结构。它只是一堆UI对象、实用程序、服务和库，它们甚至没有一个严格、统一的协议来相互通信。</p><p id="f06e" class="pw-post-body-paragraph kd ke hi kf b kg lb is ki kj lc iv kl jr le kn ko jv lg kq kr jz li kt ku kv hb bi translated">我将列出我在<strong class="kf hs"> Android </strong>开发中遇到的<strong class="kf hs"> 3 </strong> <strong class="kf hs">问题</strong>(在众多问题中)<strong class="kf hs"> </strong>，并用一些代码来解释我自己:<br/>一个非常简单的<strong class="kf hs">应用</strong>、<em class="kx"> </em>的例子，由<strong class="kf hs"> 1个屏幕</strong>和<strong class="kf hs"> 1个文本</strong>组成，显示手机的当前状态<strong class="kf hs">AirplaneMode</strong>—【T23你觉得会很整洁吗？简单？准备哭吧。</p></div><div class="ab cl lz ma gp mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="hb hc hd he hf"><h2 id="fa4e" class="jg jh hi bd ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc ho bi translated">UI结构不清晰</h2><p id="6dcf" class="pw-post-body-paragraph kd ke hi kf b kg kh is ki kj kk iv kl jr km kn ko jv kp kq kr jz ks kt ku kv hb bi translated">第一个<strong class="kf hs">第一个</strong>第三个<strong class="kf hs">问题</strong>我和<em class="kx">安卓</em>开发的问题，就是缺乏清晰的UI结构。直到今天，<a class="ae kw" href="https://www.reddit.com/r/androiddev/comments/5t3s5r/help_me_understand_when_to_use_fragments_vs/" rel="noopener ugc nofollow" target="_blank">开发者仍然不理解</a><em class="kx">活动、</em>片段和<em class="kx">视图</em>之间的“正确”不同用法——原因。见鬼，我甚至不确定<em class="kx"> Android </em>的开发者是否知道😅；这只是几十年代码进化的结果，真的——是我们坐下来从头开始重新思考整个事情的时候了。</p><p id="9b79" class="pw-post-body-paragraph kd ke hi kf b kg lb is ki kj lc iv kl jr le kn ko jv lg kq kr jz li kt ku kv hb bi translated">所以让我们从我们的<strong class="kf hs"> 1屏幕1文本AirplaneMode </strong>例子开始。我们应该用什么？一个<em class="kx">视图</em>？嗯……但是我们需要监听<em class="kx"> AirplaneMode </em>的状态变化——这对于一个<em class="kx">视图</em>来说太复杂了，难以管理。一个<em class="kx">片段</em>然后呢？嗯……但是它<a class="ae kw" href="https://stackoverflow.com/questions/32379106/how-to-registerreceiver-in-fragment/32379299" rel="noopener ugc nofollow" target="_blank">甚至没有<em class="kx"> registerReceiver </em>方法</a>，它不得不使用它的<em class="kx">活动</em>来实现。<br/>好吧！所以我们会用一个<em class="kx">活动</em>！让我们准备好监听<em class="kx"> AirplaneMode </em>的变化:</p><figure class="lk ll lm ln fd lo"><div class="bz dy l di"><div class="mr ms l"/></div><figcaption class="lv lw et er es lx ly bd b be z dx translated">使用AirplaneMode广播接收器的活动</figcaption></figure><p id="2b10" class="pw-post-body-paragraph kd ke hi kf b kg lb is ki kj lc iv kl jr le kn ko jv lg kq kr jz li kt ku kv hb bi translated">很好，现在我们有了一个能够监听<em class="kx"> AirplaneMode </em>状态变化的<em class="kx">活动</em>。但是一个<em class="kx">活动</em>基本上是一个屏幕，所以如果我们希望我们应用程序中的另一个屏幕具有相同的逻辑，我们必须为此创建一些基类<em class="kx">和</em>。很快，我们的基地<em class="kx">班</em>就会做<em class="kx">很多</em>的事情，对吧？而且……我们已经打破了一个非常重要的原则——<a class="ae kw" href="https://en.wikipedia.org/wiki/Separation_of_concerns" rel="noopener ugc nofollow" target="_blank"><em class="kx">关注点分离</em></a>；我们的应用程序中甚至还没有文本😖。<br/>你可以和我争论，说你可以做得更好——但这是安卓的“标准”方法，尽管听起来很可悲——除非你是一名高级开发人员，否则你会这么做。</p><blockquote class="ky kz la"><p id="f4b1" class="kd ke kx kf b kg lb is ki kj lc iv kl ld le kn ko lf lg kq kr lh li kt ku kv hb bi translated">顺便说一下，如果你真的想知道为什么有3个UI组件(但我建议<em class="hi">不再重要了)，<em class="hi">视图</em>是实际的UI构建块，<em class="hi">活动</em>是<em class="hi">上下文</em>持有者/供应商，它们<a class="ae kw" href="https://developer.android.com/guide/components/activities/process-lifecycle" rel="noopener ugc nofollow" target="_blank">直接与<em class="hi"> Android </em> <em class="hi"> OS </em>的<em class="hi">进程</em> </a> <em class="hi">和片段</em>相关🙄这太过分了。<br/>为什么<em class="hi">活动</em>在实践中被用来直接呈现和处理UI令我困惑，但我猜这可能与官方教程用来展示<em class="hi">活动</em>中UI相关代码的事实有关，开发人员把那些例子看得太字面了。</em></p></blockquote></div><div class="ab cl lz ma gp mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="hb hc hd he hf"><h2 id="efbc" class="jg jh hi bd ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc ho bi translated">过于复杂的生命周期</h2><p id="e7db" class="pw-post-body-paragraph kd ke hi kf b kg kh is ki kj kk iv kl jr km kn ko jv kp kq kr jz ks kt ku kv hb bi translated">我在<em class="kx"> Android </em>开发中遇到的<strong class="kf hs">第二个问题</strong>是其UI组件过于复杂的生命周期；事实上他们每个人都有不同的想法。有许多生命周期回调不一定是坏事，但是当不绝对清楚做什么和什么时候做时，它很快就会变得一团糟。你们都明白(并且记得)在<em class="kx">活动</em>的<em class="kx">onStart/on stop</em>vs .<em class="kx">on resume/on pause</em>vs .<em class="kx">on create/on destroy</em>中<em class="kx">注册/注销</em> a <em class="kx"> BroadcastReceiver </em>的区别吗？那么处理与一个<em class="kx">视图</em>的大小相关的动画呢——你花了多长时间才明白一个<em class="kx">视图</em>的<em class="kx"> onFinishInflate </em>回调是在视图被测量之前<em class="kx">被调用的，所以在它被调用的时候，<em class="kx">视图</em>的大小为0？</em></p><p id="a2d0" class="pw-post-body-paragraph kd ke hi kf b kg lb is ki kj lc iv kl jr le kn ko jv lg kq kr jz li kt ku kv hb bi translated">回到我们的例子——这次是使用<em class="kx">视图</em>和适当的生命周期处理。记住，如果我们使用<em class="kx">视图</em>或<em class="kx">片段</em>，这个例子看起来会<em class="kx">完全不同，因为它们有不同的生命周期！<br/>我们要做的是添加UI相关代码(<code class="du mt mu mv mw b">TextView</code>)并将<code class="du mt mu mv mw b">super </code>调用放入我们的生命周期回调中——为什么？因为这就是安卓系统的工作方式😓。<br/>请注意，我们在<strong class="kf hs"> 3 </strong>不同的地方更新了<em class="kx">文本</em>！</em></p><figure class="lk ll lm ln fd lo"><div class="bz dy l di"><div class="mr ms l"/></div><figcaption class="lv lw et er es lx ly bd b be z dx translated">用文本视图显示手机的AirplaneMode状态的活动</figcaption></figure><p id="0f57" class="pw-post-body-paragraph kd ke hi kf b kg lb is ki kj lc iv kl jr le kn ko jv lg kq kr jz li kt ku kv hb bi translated">很好，现在我们有了<strong class="kf hs"> 1屏幕</strong>和<strong class="kf hs"> 1文本</strong>，显示手机的<strong class="kf hs">airplanemode</strong>的状态，使用<strong class="kf hs"> 3 UI调用</strong>和<strong class="kf hs"> 4回调</strong>(生命周期-方法)。我们完成了吗？！？！嗯……不！</p></div><div class="ab cl lz ma gp mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="hb hc hd he hf"><h2 id="01d2" class="jg jh hi bd ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc ho bi translated">复数数据流</h2><p id="8ca0" class="pw-post-body-paragraph kd ke hi kf b kg kh is ki kj kk iv kl jr km kn ko jv kp kq kr jz ks kt ku kv hb bi translated">我遇到的第三个<strong class="kf hs">问题</strong>是，应用程序中的数据如何流动。超级复杂。你需要<em class="kx">包、intent</em>(它也可以保存<em class="kx">包</em>)、<em class="kx">广播接收器</em>和<em class="kx">自定义设置器。</em>有<em class="kx">很多</em>地方你要<em class="kx">设置</em>它们，<em class="kx">注册</em>它们，<em class="kx">回调</em>检索它们什么的。而且都有不同的名称，甚至不同的做法。<br/>例如，一个<em class="kx">视图</em>是最基本的UI组件，但是它没有内置的方法来为它提供<em class="kx">数据</em>。有一个完整的(官方)库(<a class="ae kw" href="https://developer.android.com/topic/libraries/data-binding" rel="noopener ugc nofollow" target="_blank"> <em class="kx">数据绑定</em> </a>)就是为了这个。它需要定制的xml代码和大量的开销。<br/>让我再说一遍来强调:<em class="kx"> Android </em>发布了一个库，只是为了将<em class="kx">数据</em>传递给它最基本的UI组件😖。</p><p id="8118" class="pw-post-body-paragraph kd ke hi kf b kg lb is ki kj lc iv kl jr le kn ko jv lg kq kr jz li kt ku kv hb bi translated">回到我们的例子，我们将添加与<code class="du mt mu mv mw b">savedInstanceState</code> <em class="kx"> </em>相关的代码，这是一个<code class="du mt mu mv mw b">Bundle</code>，一个<em class="kx">活动</em>使用它来从<em class="kx">状态</em>中恢复丢失，例如屏幕旋转(是的，屏幕旋转实际上重启了整个<em class="kx">活动</em>)和内存丢失(当<em class="kx">活动</em>回到前台时)。</p><figure class="lk ll lm ln fd lo"><div class="bz dy l di"><div class="mr ms l"/></div><figcaption class="lv lw et er es lx ly bd b be z dx translated">显示AirplaneMode状态的活动，具有适当的生命周期和状态管理</figcaption></figure><p id="acfa" class="pw-post-body-paragraph kd ke hi kf b kg lb is ki kj lc iv kl jr le kn ko jv lg kq kr jz li kt ku kv hb bi translated">现在我们终于有了一个完整的<strong class="kf hs"> 1屏幕1文本</strong>和<strong class="kf hs"> AirplaneMode </strong>。<br/>是的，这是在<em class="kx"> Android </em>中编写UI代码的正确、标准的方式。<br/>是的，通常情况下，你会把<em class="kx">广播接收器</em>放在一个基类<em class="kx">中</em>并省略<em class="kx">保存实例</em>的东西，只依靠<em class="kx">许多</em>你已经设置了UI的地方来克服这些情况。但这仍然是正确的方式。悲伤的方式。</p></div><div class="ab cl lz ma gp mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="hb hc hd he hf"><p id="ef1f" class="pw-post-body-paragraph kd ke hi kf b kg lb is ki kj lc iv kl jr le kn ko jv lg kq kr jz li kt ku kv hb bi translated">你喜欢吗？你哭了吗？我知道我做到了😤。<br/>这是人们能想象到的最简单的<em class="kx">屏幕</em>——从这里开始只会变得更加复杂；Android团队并没有修复这个有根本问题的架构，而是发布了越来越多的工具和库，每一个都帮助(修补)了上面代码的某个特定区域/方面。如今，你需要成为一名高级开发人员，才能创建一个简单的Android应用程序，拥有所有‘现代’的工具和库，没有错误。难怪世界正在向本土反应转变。糟糕。</p></div><div class="ab cl lz ma gp mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="hb hc hd he hf"><h1 id="893f" class="mg jh hi bd ji mh mi mj jm mk ml mm jq ix mn iy ju ja mo jb jy jd mp je kc mq bi translated">摘要</h1><p id="a49a" class="pw-post-body-paragraph kd ke hi kf b kg kh is ki kj kk iv kl jr km kn ko jv kp kq kr jz ks kt ku kv hb bi translated">嗯，我希望我成功地叫醒了你，或者至少进入了你的梦里😵。这仅仅是个开始。现在我们必须明白对此能做些什么。什么方法可以更好地为我们服务，更重要的是，更好地为应用程序的用户服务——因为这毕竟是最重要的。</p><p id="0c8a" class="pw-post-body-paragraph kd ke hi kf b kg lb is ki kj lc iv kl jr le kn ko jv lg kq kr jz li kt ku kv hb bi translated">所以…这就是<em class="kx">的原因。<br/> </em>感谢您的阅读，欢迎在下方留下您的评论！<em class="kx"> <br/> </em>现在让我们接着来看<em class="kx"/><em class="kx"/>🙃<em class="kx">。</em></p></div></div>    
</body>
</html>