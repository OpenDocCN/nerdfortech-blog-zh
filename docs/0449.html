<html>
<head>
<title>Design Patterns</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">设计模式</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/design-patterns-f6ee70d13296?source=collection_archive---------3-----------------------#2020-12-18">https://medium.com/nerd-for-tech/design-patterns-f6ee70d13296?source=collection_archive---------3-----------------------#2020-12-18</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="6b6e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">嘿，伙计们！这篇文章可能对未来的软件工程师有用。我们将讨论模式并解释为什么使用它们。如果你不了解模式，不要担心。事不宜迟… </p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es jd"><img src="../Images/c4c9e0f9451e637131215c2bd02d1dec.png" data-original-src="https://miro.medium.com/v2/resize:fit:1276/format:webp/1*A2AcvKc2koOevA59nDbZfw.jpeg"/></div></figure><p id="09d7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在软件工程中，设计模式是对软件设计中经常出现的问题的可重复的解决方案。设计模式不是一个完整的模式；它不能直接转换成代码。模式是一个模板，可以用来解决不同情况下的问题。我们有不同的模式来实现<em class="jl">撤销</em>特性，其中之一是<strong class="ih hj">纪念</strong>模式。因此，设计模式向您展示了用户应该如何构造这些类，以及这些类应该如何相互通信。从历史上来说，软件工程师忽略了使用现有的模式，而是设计他们自己的问题解决方案。造成这种状况的原因之一是缺乏针对常见软件体系结构和设计问题的易于使用的标准解决方案。今天有许多不同类型的模式可用。</p><p id="90b1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">有 23 种设计模式最初在 90 年代被记录在一本名为<em class="jl">设计模式，可重用面向对象软件的元素</em>的书中。这本书是由四位作者写的，通常被称为“四人帮”。因此，这 23 种设计模式通常被称为四人组模式。我个人推荐你读这本书。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es jm"><img src="../Images/c9b849f8301f996a54507f186969d29b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1040/format:webp/1*neJUTHxqhEYSBS4V7U8VnQ.jpeg"/></div></figure><p id="3331" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">有 3 种设计模式类型，创造型、结构型和行为型。创造模式是关于创造对象的不同方法。结构模式是关于这些对象之间的关系。这些对象之间协商和交流的行为模式。别忘了，这些设计模式并不能代表所有的模式及其工作，有非官方的，也有未记录的，但这些都是每个软件工程师必须了解的经典模式。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jo jp di jq bf jr"><div class="er es jn"><img src="../Images/fbe6569273471c4f4755f980353539a8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ux9RbCzxelawCjKdMwQVug.png"/></div></div></figure><p id="5341" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在介绍一些模式之前，让我们看看为什么软件工程师应该研究这个主题。首先，它有助于在抽象层次上与其他开发人员交流，例如，告诉您的同事，我们需要<em class="jl">命令</em>模式来改进这段代码，只需提及它的名称。第二，它使你成为一个更好的设计者，你学习如何构建可重用、可扩展和可维护的软件。最后但同样重要的是，它们帮助你更快地学习和使用新的框架。</p><p id="9ba7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在开始学习模式之前，我恳请您学习并复习一下关于 OOP 的知识；类，接口，封装，抽象，继承，多态，UML。</p><p id="09c8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">创造性的设计模式都是关于类的实例化。</p><ul class=""><li id="38cd" class="js jt hi ih b ii ij im in iq ju iu jv iy jw jc jx jy jz ka bi translated"><a class="ae kb" href="https://sourcemaking.com/design_patterns/abstract_factory" rel="noopener ugc nofollow" target="_blank"><strong class="ih hj"/></a><br/>抽象工厂创建几个家族类的实例</li><li id="38d0" class="js jt hi ih b ii kc im kd iq ke iu kf iy kg jc jx jy jz ka bi translated"><a class="ae kb" href="https://sourcemaking.com/design_patterns/builder" rel="noopener ugc nofollow" target="_blank"> <strong class="ih hj">构建器</strong> </a> <br/>将对象构造与其表示分离</li><li id="fcb1" class="js jt hi ih b ii kc im kd iq ke iu kf iy kg jc jx jy jz ka bi translated"><a class="ae kb" href="https://sourcemaking.com/design_patterns/factory_method" rel="noopener ugc nofollow" target="_blank"> <strong class="ih hj">工厂方法</strong> </a> <br/>创建几个派生类的实例</li><li id="018e" class="js jt hi ih b ii kc im kd iq ke iu kf iy kg jc jx jy jz ka bi translated"><a class="ae kb" href="https://sourcemaking.com/design_patterns/object_pool" rel="noopener ugc nofollow" target="_blank"> <strong class="ih hj">对象池</strong> </a> <br/>通过回收不再使用的对象来避免昂贵的资源获取和释放</li><li id="850b" class="js jt hi ih b ii kc im kd iq ke iu kf iy kg jc jx jy jz ka bi translated"><a class="ae kb" href="https://sourcemaking.com/design_patterns/prototype" rel="noopener ugc nofollow" target="_blank"> <strong class="ih hj">原型</strong> </a> <br/>被复制或克隆的完全初始化的实例</li><li id="f455" class="js jt hi ih b ii kc im kd iq ke iu kf iy kg jc jx jy jz ka bi translated"><a class="ae kb" href="https://sourcemaking.com/design_patterns/singleton" rel="noopener ugc nofollow" target="_blank"><strong class="ih hj">Singleton</strong></a><br/>只有一个实例存在的类</li></ul><p id="d6d1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">结构</strong>关于类和对象如何组合的设计模式，以形成更大的<strong class="ih hj">结构</strong>。<strong class="ih hj">结构</strong>设计<strong class="ih hj">模式</strong>通过识别关系来简化<strong class="ih hj">结构</strong>。</p><ul class=""><li id="f1ca" class="js jt hi ih b ii ij im in iq ju iu jv iy jw jc jx jy jz ka bi translated"><a class="ae kb" href="https://sourcemaking.com/design_patterns/adapter" rel="noopener ugc nofollow" target="_blank"> <strong class="ih hj">适配器</strong> </a> <br/>匹配不同类的接口</li><li id="2b5e" class="js jt hi ih b ii kc im kd iq ke iu kf iy kg jc jx jy jz ka bi translated"><a class="ae kb" href="https://sourcemaking.com/design_patterns/bridge" rel="noopener ugc nofollow" target="_blank"> <strong class="ih hj">桥</strong> </a> <br/>将一个对象的接口从其实现中分离出来</li><li id="7622" class="js jt hi ih b ii kc im kd iq ke iu kf iy kg jc jx jy jz ka bi translated"><a class="ae kb" href="https://sourcemaking.com/design_patterns/composite" rel="noopener ugc nofollow" target="_blank"> <strong class="ih hj">复合</strong> </a> <br/>一个树形结构的简单复合对象</li><li id="f5df" class="js jt hi ih b ii kc im kd iq ke iu kf iy kg jc jx jy jz ka bi translated"><a class="ae kb" href="https://sourcemaking.com/design_patterns/decorator" rel="noopener ugc nofollow" target="_blank"> <strong class="ih hj">装饰者</strong> </a> <br/>动态地给对象添加职责</li><li id="fdc1" class="js jt hi ih b ii kc im kd iq ke iu kf iy kg jc jx jy jz ka bi translated"><a class="ae kb" href="https://sourcemaking.com/design_patterns/facade" rel="noopener ugc nofollow" target="_blank"> <strong class="ih hj">外观</strong> </a> <br/>代表整个子系统的单个类</li><li id="9474" class="js jt hi ih b ii kc im kd iq ke iu kf iy kg jc jx jy jz ka bi translated"><a class="ae kb" href="https://sourcemaking.com/design_patterns/flyweight" rel="noopener ugc nofollow" target="_blank"><strong class="ih hj">Flyweight</strong></a><br/>用于高效共享的细粒度实例</li><li id="0fbc" class="js jt hi ih b ii kc im kd iq ke iu kf iy kg jc jx jy jz ka bi translated"><a class="ae kb" href="https://sourcemaking.com/design_patterns/private_class_data" rel="noopener ugc nofollow" target="_blank"> <strong class="ih hj">私有类数据</strong> </a> <br/>限制访问器/赋值器的访问</li><li id="1938" class="js jt hi ih b ii kc im kd iq ke iu kf iy kg jc jx jy jz ka bi translated"><a class="ae kb" href="https://sourcemaking.com/design_patterns/proxy" rel="noopener ugc nofollow" target="_blank"> <strong class="ih hj">代理</strong> </a> <br/>一个对象代表另一个对象</li></ul><p id="deba" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">行为</strong>设计模式与算法和对象间的责任分配有关。</p><ul class=""><li id="cd6f" class="js jt hi ih b ii ij im in iq ju iu jv iy jw jc jx jy jz ka bi translated"><a class="ae kb" href="https://sourcemaking.com/design_patterns/chain_of_responsibility" rel="noopener ugc nofollow" target="_blank"> <strong class="ih hj">责任链</strong> </a> <br/>一种在对象链之间传递请求的方式</li><li id="1f79" class="js jt hi ih b ii kc im kd iq ke iu kf iy kg jc jx jy jz ka bi translated"><a class="ae kb" href="https://sourcemaking.com/design_patterns/command" rel="noopener ugc nofollow" target="_blank"> <strong class="ih hj">命令</strong> </a> <br/>将一个命令请求封装为一个对象</li><li id="a430" class="js jt hi ih b ii kc im kd iq ke iu kf iy kg jc jx jy jz ka bi translated"><a class="ae kb" href="https://sourcemaking.com/design_patterns/interpreter" rel="noopener ugc nofollow" target="_blank"> <strong class="ih hj">解释器</strong> </a> <br/>一种在程序中包含语言元素的方式</li><li id="efa0" class="js jt hi ih b ii kc im kd iq ke iu kf iy kg jc jx jy jz ka bi translated"><a class="ae kb" href="https://sourcemaking.com/design_patterns/iterator" rel="noopener ugc nofollow" target="_blank"> <strong class="ih hj">迭代器</strong> </a> <br/>顺序访问集合中的元素</li><li id="4a0a" class="js jt hi ih b ii kc im kd iq ke iu kf iy kg jc jx jy jz ka bi translated"><a class="ae kb" href="https://sourcemaking.com/design_patterns/mediator" rel="noopener ugc nofollow" target="_blank"> <strong class="ih hj">中介</strong> </a> <br/>定义了类之间的简化通信</li><li id="0b2d" class="js jt hi ih b ii kc im kd iq ke iu kf iy kg jc jx jy jz ka bi translated"><a class="ae kb" href="https://sourcemaking.com/design_patterns/memento" rel="noopener ugc nofollow" target="_blank"> <strong class="ih hj"> Memento </strong> </a> <br/>捕捉并还原一个对象的内部状态</li><li id="9138" class="js jt hi ih b ii kc im kd iq ke iu kf iy kg jc jx jy jz ka bi translated"><a class="ae kb" href="https://sourcemaking.com/design_patterns/null_object" rel="noopener ugc nofollow" target="_blank"> <strong class="ih hj">空对象</strong> </a> <br/>旨在充当对象的默认值</li><li id="e674" class="js jt hi ih b ii kc im kd iq ke iu kf iy kg jc jx jy jz ka bi translated"><a class="ae kb" href="https://sourcemaking.com/design_patterns/observer" rel="noopener ugc nofollow" target="_blank"> <strong class="ih hj">观察者</strong> </a> <br/>一种通知多个类变化的方式</li><li id="8ccf" class="js jt hi ih b ii kc im kd iq ke iu kf iy kg jc jx jy jz ka bi translated"><a class="ae kb" href="https://sourcemaking.com/design_patterns/state" rel="noopener ugc nofollow" target="_blank"> <strong class="ih hj">状态</strong> </a> <br/>当对象的状态改变时，改变其行为</li><li id="c62e" class="js jt hi ih b ii kc im kd iq ke iu kf iy kg jc jx jy jz ka bi translated"><a class="ae kb" href="https://sourcemaking.com/design_patterns/strategy" rel="noopener ugc nofollow" target="_blank"> <strong class="ih hj">策略</strong> </a> <br/>将一个算法封装在一个类里面</li><li id="7239" class="js jt hi ih b ii kc im kd iq ke iu kf iy kg jc jx jy jz ka bi translated"><a class="ae kb" href="https://sourcemaking.com/design_patterns/template_method" rel="noopener ugc nofollow" target="_blank"> <strong class="ih hj">模板方法</strong> </a> <br/>将算法的确切步骤推迟到子类</li><li id="d0bd" class="js jt hi ih b ii kc im kd iq ke iu kf iy kg jc jx jy jz ka bi translated"><a class="ae kb" href="https://sourcemaking.com/design_patterns/visitor" rel="noopener ugc nofollow" target="_blank"> <strong class="ih hj">访问者</strong> </a> <br/>定义了一个新的操作，对一个类没有改变</li></ul><p id="2f7d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">非常感谢，敬请关注新文章。Peace✌🏼</p></div><div class="ab cl kh ki gp kj" role="separator"><span class="kk bw bk kl km kn"/><span class="kk bw bk kl km kn"/><span class="kk bw bk kl km"/></div><div class="hb hc hd he hf"><div class="je jf jg jh fd ko"><a href="https://sourcemaking.com/design_patterns" rel="noopener  ugc nofollow" target="_blank"><div class="kp ab dw"><div class="kq ab kr cl cj ks"><h2 class="bd hj fi z dy kt ea eb ku ed ef hh bi translated">设计模式和重构</h2><div class="kv l"><h3 class="bd b fi z dy kt ea eb ku ed ef dx translated">在软件工程中，设计模式是对软件中常见问题的通用可重复解决方案</h3></div><div class="kw l"><p class="bd b fp z dy kt ea eb ku ed ef dx translated">sourcemaking.com</p></div></div><div class="kx l"><div class="ky l kz la lb kx lc jj ko"/></div></div></a></div><div class="ld le ez fb lf ko"><a href="https://refactoring.guru/design-patterns" rel="noopener  ugc nofollow" target="_blank"><div class="kp ab dw"><div class="kq ab kr cl cj ks"><h2 class="bd hj fi z dy kt ea eb ku ed ef hh bi translated">设计模式</h2><div class="kv l"><h3 class="bd b fi z dy kt ea eb ku ed ef dx translated">设计模式是软件设计中常见问题的典型解决方案。每个图案就像一个蓝图，你…</h3></div><div class="kw l"><p class="bd b fp z dy kt ea eb ku ed ef dx translated">重构大师</p></div></div><div class="kx l"><div class="lg l kz la lb kx lc jj ko"/></div></div></a></div><div class="ld le ez fb lf ko"><a href="https://www.tutorialspoint.com/design_pattern/design_pattern_overview.htm" rel="noopener  ugc nofollow" target="_blank"><div class="kp ab dw"><div class="kq ab kr cl cj ks"><h2 class="bd hj fi z dy kt ea eb ku ed ef hh bi translated">设计模式-概述</h2><div class="kv l"><h3 class="bd b fi z dy kt ea eb ku ed ef dx translated">设计模式代表了有经验的面向对象软件开发人员使用的最佳实践。设计模式…</h3></div><div class="kw l"><p class="bd b fp z dy kt ea eb ku ed ef dx translated">www.tutorialspoint.com</p></div></div><div class="kx l"><div class="lh l kz la lb kx lc jj ko"/></div></div></a></div><div class="ld le ez fb lf ko"><a href="https://www.freecodecamp.org/news/the-basic-design-patterns-all-developers-need-to-know/" rel="noopener  ugc nofollow" target="_blank"><div class="kp ab dw"><div class="kq ab kr cl cj ks"><h2 class="bd hj fi z dy kt ea eb ku ed ef hh bi translated">所有开发人员都应该知道的 3 种设计模式(每种模式都有代码示例)</h2><div class="kv l"><h3 class="bd b fi z dy kt ea eb ku ed ef dx translated">什么是设计模式？设计模式是针对我们软件工程师经常遇到的问题的设计级解决方案…</h3></div><div class="kw l"><p class="bd b fp z dy kt ea eb ku ed ef dx translated">www.freecodecamp.org</p></div></div><div class="kx l"><div class="li l kz la lb kx lc jj ko"/></div></div></a></div><p id="b49c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">北卡罗来纳州罗赞斯基(2014 年)。<em class="jl">软件系统架构:使用观点和视角与涉众合作</em>。出版地点不明:艾迪生-卫斯理。</p></div></div>    
</body>
</html>