<html>
<head>
<title>Shell Scripting</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">外壳脚本</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/shell-scripting-e95af96aed1b?source=collection_archive---------5-----------------------#2021-04-25">https://medium.com/nerd-for-tech/shell-scripting-e95af96aed1b?source=collection_archive---------5-----------------------#2021-04-25</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div class="er es if"><img src="../Images/fe6b3c8e40529125ec9f0b243c4f126e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1162/format:webp/0*SuLFBZ0FTHLh1mp5.png"/></div></figure><p id="f208" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">你可能会多次遇到“脚本”这个词，但是脚本的含义是什么呢？基本上，脚本是包含一系列要执行的命令的程序。这些命令由解释程序执行。任何可以放入命令行的东西，都可以放入脚本。而且，脚本非常适合自动化任务。如果你发现自己经常重复一些命令，你可以，更确切地说，你应该创建一个脚本来完成它！</p><ul class=""><li id="4f26" class="jk jl hi io b ip iq it iu ix jm jb jn jf jo jj jp jq jr js bi translated"><strong class="io hj">最后附上两个特别的剧本。</strong></li></ul><h2 id="7d4b" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ix ke kf kg jb kh ki kj jf kk kl km kn bi translated">什么是CLI和GUI？</h2><p id="3da9" class="pw-post-body-paragraph im in hi io b ip ko ir is it kp iv iw ix kq iz ja jb kr jd je jf ks jh ji jj hb bi translated">CLI是命令行界面。该用户界面使用户能够给出与设备交互的命令。</p><p id="fce9" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">GUI是一种图形用户界面。该用户界面使用户能够借助图形图标和可视指示器与设备进行交互。</p><h2 id="7faf" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ix ke kf kg jb kh ki kj jf kk kl km kn bi translated">为什么我们要使用CLI而不是GUI？</h2><ul class=""><li id="899c" class="jk jl hi io b ip ko it kp ix kt jb ku jf kv jj jp jq jr js bi translated">CLI为用户提供了更好的控制。</li><li id="554d" class="jk jl hi io b ip kw it kx ix ky jb kz jf la jj jp jq jr js bi translated">对于使用更多编程语言的专业人员来说，CLI是最佳选择。</li><li id="f0ff" class="jk jl hi io b ip kw it kx ix ky jb kz jf la jj jp jq jr js bi translated">与GUI相比，它需要更少的内存。</li><li id="c0b9" class="jk jl hi io b ip kw it kx ix ky jb kz jf la jj jp jq jr js bi translated">CLI的速度比GUI快。</li></ul><h2 id="c223" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ix ke kf kg jb kh ki kj jf kk kl km kn bi translated">壳牌是什么？</h2><p id="33c2" class="pw-post-body-paragraph im in hi io b ip ko ir is it kp iv iw ix kq iz ja jb kr jd je jf ks jh ji jj hb bi translated"><strong class="io hj"> Shell </strong>是一个UNIX术语，指用户和操作系统服务之间的接口。Shell为用户提供了一个界面，接受人类可读的命令并执行这些命令，这些命令可以自动运行，并在shell脚本中给出程序的输出。</p><p id="5cfb" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">经营由许多部分组成，但它的两个主要部分是</p><ul class=""><li id="0626" class="jk jl hi io b ip iq it iu ix jm jb jn jf jo jj jp jq jr js bi translated">核心</li><li id="c452" class="jk jl hi io b ip kw it kx ix ky jb kz jf la jj jp jq jr js bi translated">壳</li></ul><figure class="lc ld le lf fd ij er es paragraph-image"><div class="er es lb"><img src="../Images/513b258e1b8ed55ac14f5b2398f16721.png" data-original-src="https://miro.medium.com/v2/resize:fit:1070/format:webp/0*ktxaBaI7oYQ4HgC6.png"/></div></figure><p id="fa37" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><strong class="io hj"> Shell Scripting </strong>是一个开源的计算机程序，旨在由Unix/Linux shell运行。Shell脚本是一个编写一系列命令供shell执行的程序。它可以将冗长和重复的命令序列合并成一个简单的脚本，可以随时存储和执行，从而减少编程工作量。</p><ul class=""><li id="7d28" class="jk jl hi io b ip iq it iu ix jm jb jn jf jo jj jp jq jr js bi translated">/bin/bash和/bin/sh是交互式shell</li><li id="dbc1" class="jk jl hi io b ip kw it kx ix ky jb kz jf la jj jp jq jr js bi translated">/sbin/nologin shell是非交互式shell</li></ul><h2 id="c8c9" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ix ke kf kg jb kh ki kj jf kk kl km kn bi translated">Shell提示符</h2><p id="0ac6" class="pw-post-body-paragraph im in hi io b ip ko ir is it kp iv iw ix kq iz ja jb kr jd je jf ks jh ji jj hb bi translated">提示符<strong class="io hj"> $ </strong>称为<strong class="io hj">命令提示符</strong>，由shell发出。当提示符显示时，您可以键入命令。</p><p id="3aba" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">在你按下<strong class="io hj">回车</strong>后，Shell读取你的输入。它通过查看您输入的第一个单词来确定您想要执行的命令。单词是一组完整的字符。空格和制表符分隔单词。</p><p id="4c6c" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">下面是一个简单的<strong class="io hj"> date </strong>命令的例子，它显示当前的日期和时间</p><pre class="lc ld le lf fd lg lh li lj aw lk bi"><span id="5f7e" class="jt ju hi lh b fi ll lm l ln lo">$ date</span></pre><h2 id="6569" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ix ke kf kg jb kh ki kj jf kk kl km kn bi translated">如何确定外壳</h2><p id="81b1" class="pw-post-body-paragraph im in hi io b ip ko ir is it kp iv iw ix kq iz ja jb kr jd je jf ks jh ji jj hb bi translated">您可以使用以下命令获得您的shell提示符的名称:</p><pre class="lc ld le lf fd lg lh li lj aw lk bi"><span id="a332" class="jt ju hi lh b fi ll lm l ln lo">$ echo $SHELL</span></pre><p id="9b99" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">$符号代表一个shell变量，无论您输入什么，echo都会返回文本。</p><h2 id="d8d7" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ix ke kf kg jb kh ki kj jf kk kl km kn bi translated">让我们写我们的第一个剧本</h2><pre class="lc ld le lf fd lg lh li lj aw lk bi"><span id="fef0" class="jt ju hi lh b fi ll lm l ln lo">#!/bin/bash<br/>echo "My First Script!"</span></pre><p id="f753" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">要运行它，</p><pre class="lc ld le lf fd lg lh li lj aw lk bi"><span id="73c7" class="jt ju hi lh b fi ll lm l ln lo">$ chmod +x script.sh<br/>$ ./script.sh</span></pre><h2 id="9fe4" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ix ke kf kg jb kh ki kj jf kk kl km kn bi translated">事情</h2><p id="c17d" class="pw-post-body-paragraph im in hi io b ip ko ir is it kp iv iw ix kq iz ja jb kr jd je jf ks jh ji jj hb bi translated">你可能已经注意到在上面的脚本中，它以<code class="du lp lq lr lh b">#!/bin/bash</code>开始，这被称为shebang。基本上是将路径提交给解释器。有很多解释器，其中一些是:bash，zsh，csh和ksh等。</p><figure class="lc ld le lf fd ij er es paragraph-image"><div class="er es ls"><img src="../Images/f87b8bf95162ab64c43ee1c14830f65c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1100/format:webp/0*ai3K1AxGYG6k8ca2.png"/></div><figcaption class="lt lu et er es lv lw bd b be z dx translated">生活中所有优秀的人似乎都喜欢LINUX。—史蒂夫·沃兹尼亚克</figcaption></figure><p id="011f" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">使用bash: <code class="du lp lq lr lh b">#!/bin/bash</code> <br/>使用zsh: <code class="du lp lq lr lh b">#!/bin/zsh</code> <br/>使用ksh: <code class="du lp lq lr lh b">#!/bin/ksh</code> <br/>使用csh: <code class="du lp lq lr lh b">#!/bin/csh</code></p><p id="fbe7" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><strong class="io hj">为什么舍邦？<br/> </strong> <code class="du lp lq lr lh b">#</code>常被称为sharp，<code class="du lp lq lr lh b">!</code>被称为Bang，故名sharp bang，但一般人说它<strong class="io hj"> shebang </strong>而不是sharp bang。</p><p id="3f54" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><strong class="io hj"> Note* </strong>如果一个脚本不包含shebang，那么命令将使用您的shell来执行，因此代码可能会正常运行，但是这仍然不是正确的做法！</p><p id="fefd" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><strong class="io hj">注释<br/> </strong>注释以一个<code class="du lp lq lr lh b">#</code>符号开始，该行井号之后的任何内容都被忽略。</p><h2 id="fe9f" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ix ke kf kg jb kh ki kj jf kk kl km kn bi translated">外壳的类型</h2><p id="ea5f" class="pw-post-body-paragraph im in hi io b ip ko ir is it kp iv iw ix kq iz ja jb kr jd je jf ks jh ji jj hb bi translated">Linux中有两个主要的shells:</p><p id="26fe" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><strong class="io hj"> 1 </strong>。伯恩外壳(Bourne Shell):这个外壳的提示符是$并且它的派生如下:</p><ul class=""><li id="e373" class="jk jl hi io b ip iq it iu ix jm jb jn jf jo jj jp jq jr js bi translated">POSIX shell也称为sh</li><li id="fadc" class="jk jl hi io b ip kw it kx ix ky jb kz jf la jj jp jq jr js bi translated">光辉国际也被称为上海</li><li id="42f8" class="jk jl hi io b ip kw it kx ix ky jb kz jf la jj jp jq jr js bi translated">又称为bash(最流行的)</li></ul><p id="2461" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><strong class="io hj"> 2。</strong><strong class="io hj">C shell</strong>:这个shell的提示是%，它的子类是:</p><ul class=""><li id="61cc" class="jk jl hi io b ip iq it iu ix jm jb jn jf jo jj jp jq jr js bi translated">C shell也称为csh</li><li id="ffeb" class="jk jl hi io b ip kw it kx ix ky jb kz jf la jj jp jq jr js bi translated">托普斯-C-壳牌公司也被称为tcsh</li></ul><h2 id="a77f" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ix ke kf kg jb kh ki kj jf kk kl km kn bi translated">基本命令</h2><p id="2074" class="pw-post-body-paragraph im in hi io b ip ko ir is it kp iv iw ix kq iz ja jb kr jd je jf ks jh ji jj hb bi translated">列出一个目录的内容。</p><p id="3407" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">打印工作目录。</p><p id="6410" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">cd:更改目录</p><p id="f808" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">cat:连接并打印文件内容</p><p id="2e8f" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">tac:连接并打印reverese中的文件内容。</p><p id="b69f" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">rev:反转文件的行</p><p id="1fcd" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">man:显示命令的手册页</p><p id="de7b" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">cp:复制文件或目录</p><p id="6ac7" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">移动或重命名文件或目录</p><p id="3828" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">rm:删除文件或目录</p><p id="4dbf" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">mkdir:创建目录</p><p id="09ee" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">rmdir:删除“空”目录</p><p id="cfa1" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">日期:打印或设置系统日期和时间。</p><p id="1b48" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">触摸:更改文件时间戳。如果文件不存在，将会被创建。</p><p id="8923" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">更多:一次一屏打印文件内容。</p><p id="3db7" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">less:类似于more，但允许在文件中向前和向后移动。</p><p id="90dc" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">seq:打印开始和结束之间的数字序列。</p><p id="0469" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">回显:将文本行打印到标准输出(屏幕)。</p><p id="c763" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">显示日历(一个月或一整年)</p><p id="fb77" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">清除:清除终端屏幕。</p><h1 id="b463" class="lx ju hi bd jv ly lz ma jz mb mc md kd me mf mg kg mh mi mj kj mk ml mm km mn bi translated">系统管理员日常使用Shell脚本的例子</h1><ul class=""><li id="7ebe" class="jk jl hi io b ip ko it kp ix kt jb ku jf kv jj jp jq jr js bi translated">监控您的Linux系统。</li><li id="8df7" class="jk jl hi io b ip kw it kx ix ky jb kz jf la jj jp jq jr js bi translated">数据备份和创建快照。</li><li id="ea7b" class="jk jl hi io b ip kw it kx ix ky jb kz jf la jj jp jq jr js bi translated">转储Oracle或MySQL数据库进行备份。</li><li id="9647" class="jk jl hi io b ip kw it kx ix ky jb kz jf la jj jp jq jr js bi translated">创建基于电子邮件的警报系统。</li><li id="944b" class="jk jl hi io b ip kw it kx ix ky jb kz jf la jj jp jq jr js bi translated">找出哪些进程正在消耗您的系统资源。</li><li id="2411" class="jk jl hi io b ip kw it kx ix ky jb kz jf la jj jp jq jr js bi translated">找出可用和空闲内存。</li><li id="035c" class="jk jl hi io b ip kw it kx ix ky jb kz jf la jj jp jq jr js bi translated">找出所有登录的用户和他们在做什么。</li><li id="22ce" class="jk jl hi io b ip kw it kx ix ky jb kz jf la jj jp jq jr js bi translated">查明所有必要的网络服务是否正在运行。例如，如果web服务器出现故障，则通过寻呼机或电子邮件向系统管理员发送警报。</li><li id="8a70" class="jk jl hi io b ip kw it kx ix ky jb kz jf la jj jp jq jr js bi translated">找出所有失败的登录尝试，如果从同一个网络IP重复登录尝试，自动阻止所有这些IP通过防火墙访问您的网络/服务。</li><li id="4a25" class="jk jl hi io b ip kw it kx ix ky jb kz jf la jj jp jq jr js bi translated">根据您自己的安全策略进行用户管理。</li><li id="3f2e" class="jk jl hi io b ip kw it kx ix ky jb kz jf la jj jp jq jr js bi translated">找出有关本地或远程服务器的信息。</li><li id="6dbd" class="jk jl hi io b ip kw it kx ix ky jb kz jf la jj jp jq jr js bi translated">服务器配置。</li></ul><h1 id="a44e" class="lx ju hi bd jv ly lz ma jz mb mc md kd me mf mg kg mh mi mj kj mk ml mm km mn bi translated">GREP命令</h1><p id="d5e1" class="pw-post-body-paragraph im in hi io b ip ko ir is it kp iv iw ix kq iz ja jb kr jd je jf ks jh ji jj hb bi translated">grep过滤器在文件中搜索特定的字符模式，并显示包含该模式的所有行。在文件中搜索的模式称为正则表达式(grep代表全局搜索正则表达式并打印输出)。</p><pre class="lc ld le lf fd lg lh li lj aw lk bi"><span id="e054" class="jt ju hi lh b fi ll lm l ln lo"><strong class="lh hj">$ grep [options] pattern [files]</strong></span><span id="effe" class="jt ju hi lh b fi mo lm l ln lo"><strong class="lh hj">Options Description</strong><br/><strong class="lh hj">-c</strong> : This prints only a count of the lines that match a pattern<br/><strong class="lh hj">-h :</strong> Display the matched lines, but do not display the filenames.<br/><strong class="lh hj">-i :</strong> Ignores, case for matching<br/><strong class="lh hj">-l :</strong> Displays list of a filenames only.<br/><strong class="lh hj">-n :</strong> Display the matched lines and their line numbers.<br/><strong class="lh hj">-v :</strong> This prints out all the lines that do not matches the pattern<br/><strong class="lh hj">-e exp :</strong> Specifies expression with this option. Can use multiple times.<br/><strong class="lh hj">-f file :</strong> Takes patterns from file, one per line.<br/><strong class="lh hj">-E :</strong> Treats pattern as an extended regular expression (ERE)<br/><strong class="lh hj">-w :</strong> Match whole word<br/><strong class="lh hj">-o :</strong> Print only the matched parts of a matching line,<br/> with each such part on a separate output line.</span><span id="3af9" class="jt ju hi lh b fi mo lm l ln lo"><strong class="lh hj">-A n</strong> <strong class="lh hj">:</strong> Prints searched line and nlines after the result.<strong class="lh hj"><br/>-B n :</strong> Prints searched line and n line before the result.<br/><strong class="lh hj">-C n :</strong> Prints searched line and n lines after before the result.</span></pre><h1 id="95e8" class="lx ju hi bd jv ly lz ma jz mb mc md kd me mf mg kg mh mi mj kj mk ml mm km mn bi translated">一起运行多个命令</h1><p id="f8c2" class="pw-post-body-paragraph im in hi io b ip ko ir is it kp iv iw ix kq iz ja jb kr jd je jf ks jh ji jj hb bi translated">使用&amp;&amp;例如:日期&amp;&amp;呼叫。我们也可以使用||。</p><h1 id="a135" class="lx ju hi bd jv ly lz ma jz mb mc md kd me mf mg kg mh mi mj kj mk ml mm km mn bi translated">如何创建多个文本文件和目录？</h1><p id="3d56" class="pw-post-body-paragraph im in hi io b ip ko ir is it kp iv iw ix kq iz ja jb kr jd je jf ks jh ji jj hb bi translated">要创建多个文本文件，使用触摸文件名命令</p><p id="2892" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">《出埃及记》假设我们想要创建4个文件，然后我们键入#touch filename{1..4}</p><p id="fc27" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">使用{文件名}命令创建多个目录mkdir</p><p id="d3b3" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">《出埃及记》假设我们想要创建4个目录，然后我们键入mkdir filename {1..4}</p><h1 id="5b48" class="lx ju hi bd jv ly lz ma jz mb mc md kd me mf mg kg mh mi mj kj mk ml mm km mn bi translated">头尾命令有什么用？</h1><p id="03e5" class="pw-post-body-paragraph im in hi io b ip ko ir is it kp iv iw ix kq iz ja jb kr jd je jf ks jh ji jj hb bi translated">Head命令用于显示开始的10行</p><p id="cfa9" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">Tail命令用于显示开始的10行</p><h1 id="94c1" class="lx ju hi bd jv ly lz ma jz mb mc md kd me mf mg kg mh mi mj kj mk ml mm km mn bi translated">如何找到你正在使用的当前shell？</h1><p id="a008" class="pw-post-body-paragraph im in hi io b ip ko ir is it kp iv iw ix kq iz ja jb kr jd je jf ks jh ji jj hb bi translated">$echo $SHELL命令用于查找当前SHELL。</p><h1 id="41af" class="lx ju hi bd jv ly lz ma jz mb mc md kd me mf mg kg mh mi mj kj mk ml mm km mn bi translated">如何在您的系统中找到可用的shell？</h1><p id="d79a" class="pw-post-body-paragraph im in hi io b ip ko ir is it kp iv iw ix kq iz ja jb kr jd je jf ks jh ji jj hb bi translated">cat/etc/shell命令用于查找系统中可用的shell。</p><h1 id="fff0" class="lx ju hi bd jv ly lz ma jz mb mc md kd me mf mg kg mh mi mj kj mk ml mm km mn bi translated">在Linux中，如何传递和访问脚本的参数？</h1><p id="db74" class="pw-post-body-paragraph im in hi io b ip ko ir is it kp iv iw ix kq iz ja jb kr jd je jf ks jh ji jj hb bi translated">对于脚本“scriptname arg1 arg2 arg3 …”中的传递参数</p><p id="3022" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">对于访问，脚本中的参数可以在脚本中以“$1，$2..$n "</p><h1 id="536b" class="lx ju hi bd jv ly lz ma jz mb mc md kd me mf mg kg mh mi mj kj mk ml mm km mn bi translated">$#的意义是什么？</h1><p id="a91f" class="pw-post-body-paragraph im in hi io b ip ko ir is it kp iv iw ix kq iz ja jb kr jd je jf ks jh ji jj hb bi translated">它表示由字符串传递的参数总数。</p><h1 id="48f6" class="lx ju hi bd jv ly lz ma jz mb mc md kd me mf mg kg mh mi mj kj mk ml mm km mn bi translated">$*和$@有什么区别？</h1><p id="c0ec" class="pw-post-body-paragraph im in hi io b ip ko ir is it kp iv iw ix kq iz ja jb kr jd je jf ks jh ji jj hb bi translated">$*将整组位置参数视为单个字符串，但$@将每个带引号的参数视为单独的参数。</p><h1 id="f25e" class="lx ju hi bd jv ly lz ma jz mb mc md kd me mf mg kg mh mi mj kj mk ml mm km mn bi translated">Shell脚本中使用了哪些不同类型的变量？</h1><p id="e5f6" class="pw-post-body-paragraph im in hi io b ip ko ir is it kp iv iw ix kq iz ja jb kr jd je jf ks jh ji jj hb bi translated"><strong class="io hj">系统定义变量</strong>:OS自己创建的系统定义变量。这些变量通常用大写字母来定义。可以通过“set”命令查看。</p><p id="efae" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><strong class="io hj">自定义变量</strong>:由系统用户创建。可以使用“echo $variablename”命令查看变量值。</p><h1 id="78aa" class="lx ju hi bd jv ly lz ma jz mb mc md kd me mf mg kg mh mi mj kj mk ml mm km mn bi translated">=和==有什么区别？</h1><p id="df38" class="pw-post-body-paragraph im in hi io b ip ko ir is it kp iv iw ix kq iz ja jb kr jd je jf ks jh ji jj hb bi translated">=用于给变量赋值</p><p id="e128" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">==用于字符串比较</p><h1 id="1bbd" class="lx ju hi bd jv ly lz ma jz mb mc md kd me mf mg kg mh mi mj kj mk ml mm km mn bi translated">什么是外壳变量？</h1><p id="c97c" class="pw-post-body-paragraph im in hi io b ip ko ir is it kp iv iw ix kq iz ja jb kr jd je jf ks jh ji jj hb bi translated">变量以字符和数字的形式存储数据。类似地，shell变量用于存储信息，并且只能由Shell使用。</p><p id="a5ce" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">例如，以下代码创建一个shell变量，然后打印它:</p><pre class="lc ld le lf fd lg lh li lj aw lk bi"><span id="41e7" class="jt ju hi lh b fi ll lm l ln lo">variable ="Hello"<br/>echo $variable</span></pre><p id="2539" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">下面是一个使用变量的小脚本。</p><pre class="lc ld le lf fd lg lh li lj aw lk bi"><span id="cc94" class="jt ju hi lh b fi ll lm l ln lo">#!/bin/sh<br/>echo "what is your name?"<br/>read name<br/>echo "How do you do, $name?"<br/>read remark<br/>echo "I am $remark too!"</span></pre><p id="1667" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><strong class="io hj">注意:</strong>我们也可以把一个命令的输出赋值给一个变量比如:<code class="du lp lq lr lh b">LIST=$(ls)</code>，再比如:<code class="du lp lq lr lh b">SERVER_NAME=$(hostname)</code></p><p id="109d" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><strong class="io hj">一些有效的变量名:</strong></p><pre class="lc ld le lf fd lg lh li lj aw lk bi"><span id="7a6f" class="jt ju hi lh b fi ll lm l ln lo">THIS3VARIABLE=”ABC”<br/>THIS_IS_VARIABLE=”ABC”<br/>thisIsVariable=”ABC”</span></pre><p id="9583" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><strong class="io hj">一些无效的变量名:</strong></p><pre class="lc ld le lf fd lg lh li lj aw lk bi"><span id="1f51" class="jt ju hi lh b fi ll lm l ln lo">4Number=”NUM”<br/>This-Is-Var=”VAR”<br/># No special character apart from underscore is allowed!</span></pre><h1 id="c069" class="lx ju hi bd jv ly lz ma jz mb mc md kd me mf mg kg mh mi mj kj mk ml mm km mn bi translated">只读变量</h1><p id="2c9c" class="pw-post-body-paragraph im in hi io b ip ko ir is it kp iv iw ix kq iz ja jb kr jd je jf ks jh ji jj hb bi translated">Shell提供了一种通过使用read-only命令将变量标记为只读的方法。变量被标记为只读后，其值不能更改。</p><p id="d196" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">例如，以下脚本在尝试更改NAME的值时会生成错误</p><pre class="lc ld le lf fd lg lh li lj aw lk bi"><span id="5e97" class="jt ju hi lh b fi ll lm l ln lo">#!/bin/sh</span><span id="c96b" class="jt ju hi lh b fi mo lm l ln lo">NAME="Vimal Daga"<br/>readonly NAME<br/>NAME="Preeti Daga"</span></pre><p id="4f3c" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">上述脚本将生成以下结果</p><pre class="lc ld le lf fd lg lh li lj aw lk bi"><span id="72b6" class="jt ju hi lh b fi ll lm l ln lo">/bin/sh: NAME: This variable is read only.</span></pre><h1 id="ef72" class="lx ju hi bd jv ly lz ma jz mb mc md kd me mf mg kg mh mi mj kj mk ml mm km mn bi translated">取消设置变量</h1><p id="b884" class="pw-post-body-paragraph im in hi io b ip ko ir is it kp iv iw ix kq iz ja jb kr jd je jf ks jh ji jj hb bi translated">取消设置或删除变量会指示shell从它跟踪的变量列表中删除该变量。一旦取消设置变量，就不能访问变量中存储的值。</p><p id="a7e4" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">以下是使用<strong class="io hj">取消设置</strong>命令取消设置已定义变量的语法</p><pre class="lc ld le lf fd lg lh li lj aw lk bi"><span id="2c5e" class="jt ju hi lh b fi ll lm l ln lo">unset variable_name</span></pre><p id="28f5" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">上面的命令取消已定义变量的值。下面是一个简单的例子，演示了该命令是如何工作的</p><pre class="lc ld le lf fd lg lh li lj aw lk bi"><span id="58a4" class="jt ju hi lh b fi ll lm l ln lo">#!/bin/sh</span><span id="3bb2" class="jt ju hi lh b fi mo lm l ln lo">NAME="VD"<br/>unset NAME<br/>echo $NAME</span></pre><h1 id="8d8d" class="lx ju hi bd jv ly lz ma jz mb mc md kd me mf mg kg mh mi mj kj mk ml mm km mn bi translated">特殊变量</h1><p id="fbcc" class="pw-post-body-paragraph im in hi io b ip ko ir is it kp iv iw ix kq iz ja jb kr jd je jf ks jh ji jj hb bi translated"><strong class="io hj"> $ </strong>字符代表当前shell的进程ID号或PID</p><pre class="lc ld le lf fd lg lh li lj aw lk bi"><span id="630e" class="jt ju hi lh b fi ll lm l ln lo">$echo $$</span></pre><p id="de98" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">上述命令写入当前shell的PID。</p><ul class=""><li id="5bec" class="jk jl hi io b ip iq it iu ix jm jb jn jf jo jj jp jq jr js bi translated"><strong class="io hj"> $0 : </strong>当前脚本的文件名。</li><li id="8e21" class="jk jl hi io b ip kw it kx ix ky jb kz jf la jj jp jq jr js bi translated"><strong class="io hj"> $n : </strong>这些变量对应于调用脚本时使用的参数。这里<strong class="io hj"> n </strong>是一个正十进制数，对应一个自变量的位置(第一个自变量是$1，第二个自变量是$2，以此类推)。</li><li id="f9bc" class="jk jl hi io b ip kw it kx ix ky jb kz jf la jj jp jq jr js bi translated"><strong class="io hj"> $# : </strong>提供给脚本的参数个数。</li><li id="f081" class="jk jl hi io b ip kw it kx ix ky jb kz jf la jj jp jq jr js bi translated"><strong class="io hj"> $* : </strong>所有的参数都用双引号括起来。如果脚本接收两个参数，$*相当于$1 $2。</li><li id="31dc" class="jk jl hi io b ip kw it kx ix ky jb kz jf la jj jp jq jr js bi translated"><strong class="io hj"> $@ : </strong>所有的参数都分别用双引号引起来。如果脚本接收两个参数，$@相当于$1 $2。</li><li id="5db3" class="jk jl hi io b ip kw it kx ix ky jb kz jf la jj jp jq jr js bi translated"><strong class="io hj"> $？:</strong>最后执行的命令的退出状态。</li><li id="b066" class="jk jl hi io b ip kw it kx ix ky jb kz jf la jj jp jq jr js bi translated"><strong class="io hj"> $$ : </strong>当前shell的进程号。对于shell脚本，这是它们执行时使用的进程ID。</li><li id="0f3e" class="jk jl hi io b ip kw it kx ix ky jb kz jf la jj jp jq jr js bi translated"><strong class="io hj"> $！:</strong>最后一个后台命令的进程号。</li></ul><h1 id="d7da" class="lx ju hi bd jv ly lz ma jz mb mc md kd me mf mg kg mh mi mj kj mk ml mm km mn bi translated">用户输入</h1><p id="3159" class="pw-post-body-paragraph im in hi io b ip ko ir is it kp iv iw ix kq iz ja jb kr jd je jf ks jh ji jj hb bi translated"><code class="du lp lq lr lh b">read</code>命令接受标准输入(标准输入)</p><pre class="lc ld le lf fd lg lh li lj aw lk bi"><span id="fe3b" class="jt ju hi lh b fi ll lm l ln lo">read -p "PROMPT MESSAGE" VARIABLE</span></pre><p id="df77" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">此时，“提示信息”将被提示到屏幕上，无论用户下一步输入什么，都将被存储在<code class="du lp lq lr lh b">VARIABLE</code>中</p><pre class="lc ld le lf fd lg lh li lj aw lk bi"><span id="a46c" class="jt ju hi lh b fi ll lm l ln lo">#!/bin/bash<br/>read -p "Please Enter You Name: " NAME<br/>echo "Your Name Is: $NAME"</span></pre><h1 id="5ddd" class="lx ju hi bd jv ly lz ma jz mb mc md kd me mf mg kg mh mi mj kj mk ml mm km mn bi translated">外壳阵列</h1><p id="f894" class="pw-post-body-paragraph im in hi io b ip ko ir is it kp iv iw ix kq iz ja jb kr jd je jf ks jh ji jj hb bi translated">如果您使用的是<strong class="io hj"> bash </strong> shell，下面是数组初始化的语法</p><pre class="lc ld le lf fd lg lh li lj aw lk bi"><span id="eeff" class="jt ju hi lh b fi ll lm l ln lo">array_name=(value1 ... valuen)</span></pre><h2 id="45ed" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ix ke kf kg jb kh ki kj jf kk kl km kn bi translated">访问数组值</h2><p id="3c2c" class="pw-post-body-paragraph im in hi io b ip ko ir is it kp iv iw ix kq iz ja jb kr jd je jf ks jh ji jj hb bi translated">设置任何数组变量后，可以按如下方式访问它</p><pre class="lc ld le lf fd lg lh li lj aw lk bi"><span id="c17a" class="jt ju hi lh b fi ll lm l ln lo">${array_name[index]}</span></pre><ul class=""><li id="338d" class="jk jl hi io b ip iq it iu ix jm jb jn jf jo jj jp jq jr js bi translated"><strong class="io hj">打印所有数组索引:</strong></li></ul><pre class="lc ld le lf fd lg lh li lj aw lk bi"><span id="c352" class="jt ju hi lh b fi ll lm l ln lo">$ echo ${!array[@]}</span></pre><ul class=""><li id="debc" class="jk jl hi io b ip iq it iu ix jm jb jn jf jo jj jp jq jr js bi translated">从id为3的数组中移除元素</li></ul><pre class="lc ld le lf fd lg lh li lj aw lk bi"><span id="5e54" class="jt ju hi lh b fi ll lm l ln lo">$ Unset array[3]</span></pre><h1 id="8c7e" class="lx ju hi bd jv ly lz ma jz mb mc md kd me mf mg kg mh mi mj kj mk ml mm km mn bi translated">测试操作员</h1><p id="3571" class="pw-post-body-paragraph im in hi io b ip ko ir is it kp iv iw ix kq iz ja jb kr jd je jf ks jh ji jj hb bi translated">测试用于决策。<code class="du lp lq lr lh b">[ condition-to-test-for ]</code> <strong class="io hj">举例:</strong> ` <code class="du lp lq lr lh b">[ -e /etc/passwd ]</code></p><ol class=""><li id="46b3" class="jk jl hi io b ip iq it iu ix jm jb jn jf jo jj mp jq jr js bi translated"><strong class="io hj">文件测试操作</strong></li></ol><pre class="lc ld le lf fd lg lh li lj aw lk bi"><span id="99b1" class="jt ju hi lh b fi ll lm l ln lo">-d FILE_NAM  # True if FILE_NAM is a directory<br/>-e FILE_NAM  # True if FILE_NAM exists<br/>-f FILE_NAM  # True if FILE_NAM exists and is a regular file<br/>-r FILE_NAM  # True if FILE_NAM is readable<br/>-s FILE_NAM  # True if FILE_NAM exists and is not empty<br/>-w FILE_NAM  # True if FILE_NAM has write permission<br/>-x FILE_NAM  # True if FILE_NAM is executable</span></pre><p id="b154" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><strong class="io hj"> 2。字符串测试操作</strong></p><pre class="lc ld le lf fd lg lh li lj aw lk bi"><span id="0680" class="jt ju hi lh b fi ll lm l ln lo">-z STRING  # True if STRING is empty<br/>-n STRING  # True if STRING is not empty<br/>STRING1 = STRIN2 # True if strings are equal<br/>STRING1 != STRIN2 # True if strings are not equal</span></pre><p id="9d5d" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><strong class="io hj"> 3。关系运算符</strong></p><pre class="lc ld le lf fd lg lh li lj aw lk bi"><span id="b0d7" class="jt ju hi lh b fi ll lm l ln lo">var1 -eq var2  # True if var1 is equal to var2<br/>var1 -ne var2  # True if var1 not equal to var2<br/>var1 -lt var2  # True if var1 is less than var2<br/>var1 -le var2  # True if var1 is less than or equal to var2<br/>var1 -gt var2  # True if var1 is greater than var2<br/>var1 -ge var2  # True if var1 is greater than or equal to var2</span></pre><h1 id="69df" class="lx ju hi bd jv ly lz ma jz mb mc md kd me mf mg kg mh mi mj kj mk ml mm km mn bi translated">决策</h1><p id="47cf" class="pw-post-body-paragraph im in hi io b ip ko ir is it kp iv iw ix kq iz ja jb kr jd je jf ks jh ji jj hb bi translated">就像任何脚本一样，shell脚本可以根据条件做出决策。我们可以使用If-Else(或者，If-Elif-Else)和case语句进行决策。</p><ol class=""><li id="0bc9" class="jk jl hi io b ip iq it iu ix jm jb jn jf jo jj mp jq jr js bi translated"><strong class="io hj"/><code class="du lp lq lr lh b"><strong class="io hj">if</strong></code><strong class="io hj">报表</strong></li></ol><pre class="lc ld le lf fd lg lh li lj aw lk bi"><span id="b40c" class="jt ju hi lh b fi ll lm l ln lo">if [ condition-is-true ]<br/>then<br/>  command 1<br/>  command 2<br/>    ...<br/>    ...<br/>  command N<br/>fi</span></pre><p id="68d9" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><strong class="io hj">if-elif阶梯</strong></p><pre class="lc ld le lf fd lg lh li lj aw lk bi"><span id="1adb" class="jt ju hi lh b fi ll lm l ln lo">if [ condition-is-true ]<br/>then<br/>  command 1<br/>elif [ condition-is-true ]<br/>then<br/>  command 2<br/>elif [ condition-is-true ]<br/>then<br/>  command 3<br/>else<br/>  command 4<br/>fi</span></pre><p id="72f2" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><strong class="io hj"> 2。Case语句<br/></strong>case语句是if语句的替代语句，比复杂的if elif语句更容易阅读。如果您发现自己使用If语句来比较相同的变量和一些不同的/离散的值，您可以使用case语句来代替if-elif梯形。</p><p id="349d" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><strong class="io hj">语法:</strong></p><pre class="lc ld le lf fd lg lh li lj aw lk bi"><span id="cf58" class="jt ju hi lh b fi ll lm l ln lo">case "$VAR" in<br/>  pattern_1)<br/>    # commands when $VAR matches pattern 1<br/>    ;;<br/>  pattern_2)<br/>    # commands when $VAR matches pattern 2<br/>    ;;<br/>  *)<br/>    # This will run if $VAR doesnt match any of the given patterns<br/>    ;;<br/>esac</span></pre><p id="bb8f" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><strong class="io hj">例如:</strong></p><pre class="lc ld le lf fd lg lh li lj aw lk bi"><span id="cdbc" class="jt ju hi lh b fi ll lm l ln lo">#!/bin/bash<br/>read -p "Enter the answer in Y/N: " ANSWER<br/>case "$ANSWER" in<br/>  [yY] | [yY][eE][sS])<br/>    echo "The Answer is Yes :)"<br/>    ;;<br/>  [nN] | [nN][oO])<br/>    echo "The Answer is No :("<br/>    ;;<br/>  *)<br/>    echo "Invalid Answer :/"<br/>    ;;<br/>esac</span></pre><h1 id="6846" class="lx ju hi bd jv ly lz ma jz mb mc md kd me mf mg kg mh mi mj kj mk ml mm km mn bi translated">迭代语句:循环</h1><p id="6dff" class="pw-post-body-paragraph im in hi io b ip ko ir is it kp iv iw ix kq iz ja jb kr jd je jf ks jh ji jj hb bi translated">循环可以多次执行一个代码块，主要用于执行迭代。</p><p id="47ae" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><strong class="io hj"> 1。For循环</strong></p><pre class="lc ld le lf fd lg lh li lj aw lk bi"><span id="59c8" class="jt ju hi lh b fi ll lm l ln lo">for VARIABLE_NAME in ITEM_1 ITEM_N<br/>do<br/>  command 1<br/>  command 2<br/>    ...<br/>    ...<br/>  command N<br/>done</span></pre><p id="cbb0" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">例如:</p><pre class="lc ld le lf fd lg lh li lj aw lk bi"><span id="d9f5" class="jt ju hi lh b fi ll lm l ln lo">#!/bin/bash<br/>COLORS="red green blue"<br/>for COLOR in $COLORS<br/>do<br/>  echo "The Color is: ${COLOR}"<br/>done</span></pre><p id="5bca" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">for循环的另一种用法是:</p><pre class="lc ld le lf fd lg lh li lj aw lk bi"><span id="59f9" class="jt ju hi lh b fi ll lm l ln lo">for (( VAR=1;VAR&lt;N;VAR++ ))<br/>do<br/>  command 1<br/>  command 2<br/>    ...<br/>    ...<br/>  command N<br/>done</span></pre><p id="8480" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">这里有一个例子，说明了如何创建一个脚本来重命名每个文件。txt格式到新- <old-name>。文本文件（textfile）</old-name></p><pre class="lc ld le lf fd lg lh li lj aw lk bi"><span id="3dea" class="jt ju hi lh b fi ll lm l ln lo">#!/bin/bash<br/>FILES=$(ls *txt)<br/>NEW="new"<br/>for FILE in $FILES<br/>do<br/>  echo "Renaming $FILE to new-$FILE"<br/>  mv $FILE $NEW-$FILE<br/>done</span></pre><p id="bc97" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><strong class="io hj"> 2。While循环</strong></p><p id="2db8" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">只要给定的条件为真，While循环就重复一系列命令。</p><pre class="lc ld le lf fd lg lh li lj aw lk bi"><span id="f07e" class="jt ju hi lh b fi ll lm l ln lo">while [ CONNDITION_IS_TRUE ]<br/>do<br/>  # Commands will change he entry condition<br/>  command 1<br/>  command 2<br/>    ...<br/>    ...<br/>  command N<br/>done</span></pre><p id="5cc5" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">条件可以是任何测试或命令。如果测试/命令返回0退出状态，这意味着条件为真，命令将被执行。如果命令返回非零退出状态，循环将停止迭代。如果条件最初为假，那么循环中的命令将永远不会执行。</p><p id="d3fb" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><strong class="io hj">示例:</strong>逐行读取文件</p><pre class="lc ld le lf fd lg lh li lj aw lk bi"><span id="9a7d" class="jt ju hi lh b fi ll lm l ln lo">#!/bin/bash<br/>LINE=1<br/>while read CURRENT_LINE<br/>do<br/>  echo "${LINE}: $CURRENT_LINE"<br/>  ((LINE++))<br/>done &lt; /etc/passwd<br/># This script loops through the file /etc/passwd line by line</span></pre><h1 id="2280" class="lx ju hi bd jv ly lz ma jz mb mc md kd me mf mg kg mh mi mj kj mk ml mm km mn bi translated">嵌套while循环</h1><p id="9572" class="pw-post-body-paragraph im in hi io b ip ko ir is it kp iv iw ix kq iz ja jb kr jd je jf ks jh ji jj hb bi translated">可以将while循环用作另一个while循环体的一部分。</p><h1 id="16f5" class="lx ju hi bd jv ly lz ma jz mb mc md kd me mf mg kg mh mi mj kj mk ml mm km mn bi translated">句法</h1><pre class="lc ld le lf fd lg lh li lj aw lk bi"><span id="29b2" class="jt ju hi lh b fi ll lm l ln lo">while command1 ; # this is loop1, the outer loop<br/>do<br/>   Statement(s) to be executed if command1 is true</span><span id="d9ed" class="jt ju hi lh b fi mo lm l ln lo">while command2 ; # this is loop2, the inner loop<br/>   do<br/>      Statement(s) to be executed if command2 is true<br/>   done</span><span id="8bfb" class="jt ju hi lh b fi mo lm l ln lo">Statement(s) to be executed if command1 is true<br/>done</span></pre><h1 id="c278" class="lx ju hi bd jv ly lz ma jz mb mc md kd me mf mg kg mh mi mj kj mk ml mm km mn bi translated">例子</h1><p id="0fdc" class="pw-post-body-paragraph im in hi io b ip ko ir is it kp iv iw ix kq iz ja jb kr jd je jf ks jh ji jj hb bi translated">这是一个简单的循环嵌套的例子。让我们在您用来数到9的循环中添加另一个倒计时循环</p><pre class="lc ld le lf fd lg lh li lj aw lk bi"><span id="2135" class="jt ju hi lh b fi ll lm l ln lo">#!/bin/sh</span><span id="a93c" class="jt ju hi lh b fi mo lm l ln lo">a=0<br/>while [ "$a" -lt 10 ]    # this is loop1<br/>do<br/>   b="$a"<br/>   while [ "$b" -ge 0 ]  # this is loop2<br/>   do<br/>      echo -n "$b "<br/>      b=`expr $b - 1`<br/>   done<br/>   echo<br/>   a=`expr $a + 1`<br/>done</span></pre><p id="8772" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">这将产生以下结果。这里需要注意的是<strong class="io hj"> echo -n </strong>是如何工作的。这里的<strong class="io hj"> -n </strong>选项让echo避免打印新的一行字符。</p><pre class="lc ld le lf fd lg lh li lj aw lk bi"><span id="fb52" class="jt ju hi lh b fi ll lm l ln lo">0<br/>1 0<br/>2 1 0<br/>3 2 1 0<br/>4 3 2 1 0<br/>5 4 3 2 1 0<br/>6 5 4 3 2 1 0<br/>7 6 5 4 3 2 1 0<br/>8 7 6 5 4 3 2 1 0<br/>9 8 7 6 5 4 3 2 1 0</span></pre><p id="53a1" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><strong class="io hj">注意:</strong> <br/> <code class="du lp lq lr lh b">continue</code>语句用于将流程控制到下一次迭代。命中continue语句后的任何语句都不会被执行，控制流将转移到下一次迭代。<br/> <code class="du lp lq lr lh b">break</code>语句可以在while循环(或其他类似for循环的循环)中用来结束循环。一旦break语句被命中，控制流将移出循环。</p><h1 id="381a" class="lx ju hi bd jv ly lz ma jz mb mc md kd me mf mg kg mh mi mj kj mk ml mm km mn bi translated">位置参数</h1><p id="2ddb" class="pw-post-body-paragraph im in hi io b ip ko ir is it kp iv iw ix kq iz ja jb kr jd je jf ks jh ji jj hb bi translated">当我们调用脚本时，可以传递一些参数。<br/>例如:<code class="du lp lq lr lh b">$ ./script.sh param1 param2 param3 param4</code></p><p id="ce7d" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">所有参数将存储在各种变量中:</p><pre class="lc ld le lf fd lg lh li lj aw lk bi"><span id="2798" class="jt ju hi lh b fi ll lm l ln lo">$0 -- "script.sh"<br/>  $1 -- "param1"<br/>  $2 -- "param2"<br/>  $3 -- "param3"<br/>  $4 -- "param4"<br/>  $@ -- array of all positional parameters</span></pre><p id="8fa8" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">就像任何其他全局变量一样，可以在脚本中的任何地方访问这些变量。</p><h1 id="b0aa" class="lx ju hi bd jv ly lz ma jz mb mc md kd me mf mg kg mh mi mj kj mk ml mm km mn bi translated">退出状态</h1><p id="9f1a" class="pw-post-body-paragraph im in hi io b ip ko ir is it kp iv iw ix kq iz ja jb kr jd je jf ks jh ji jj hb bi translated">每个命令返回一个退出状态，也称为返回代码，范围从0到255。退出状态用于错误检查。</p><ul class=""><li id="958f" class="jk jl hi io b ip iq it iu ix jm jb jn jf jo jj jp jq jr js bi translated">0表示成功</li><li id="f8ae" class="jk jl hi io b ip kw it kx ix ky jb kz jf la jj jp jq jr js bi translated">除0之外的任何代码都意味着错误情况。</li></ul><p id="6931" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">要了解命令的退出状态意味着什么，可以使用<code class="du lp lq lr lh b">man</code>或<code class="du lp lq lr lh b">info</code>命令查找文档或手册。<br/> <code class="du lp lq lr lh b">$?</code>包含先前执行命令的返回代码。</p><p id="08b6" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><strong class="io hj">示例:</strong>使用ping命令打印<code class="du lp lq lr lh b">Reachable/Unreachable</code>主机/服务器的脚本。</p><pre class="lc ld le lf fd lg lh li lj aw lk bi"><span id="13b4" class="jt ju hi lh b fi ll lm l ln lo">#!/bin/bash<br/>HOST="google.com"<br/>ping -c 1 $HOST     # -c is used for count, it will send the request, number of times mentioned<br/>RETURN_CODE=$?<br/>if [ "$RETURN_CODE" -eq "0" ]<br/>then<br/>  echo "$HOST reachable"<br/>else<br/>  echo "$HOST unreachable"<br/>fi</span></pre><p id="7235" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><strong class="io hj">自定义退出状态<br/> </strong>退出命令用于显式定义返回代码。如果我们没有明确定义shell脚本的退出状态，那么默认情况下，最后执行的命令的退出状态将被视为脚本的退出状态。我们可以在脚本中的任何地方使用exit命令，一旦遇到exit命令，shell脚本将停止执行。</p><pre class="lc ld le lf fd lg lh li lj aw lk bi"><span id="f9ef" class="jt ju hi lh b fi ll lm l ln lo">exit 0<br/>  exit 1<br/>  exit 2<br/>    ...<br/>    ...<br/>  exit 255</span></pre><h1 id="d1e8" class="lx ju hi bd jv ly lz ma jz mb mc md kd me mf mg kg mh mi mj kj mk ml mm km mn bi translated">功能</h1><p id="0fab" class="pw-post-body-paragraph im in hi io b ip ko ir is it kp iv iw ix kq iz ja jb kr jd je jf ks jh ji jj hb bi translated">一组指令，当需要这些指令时，可以从主程序中随时重用或调用。考虑这样一种情况，你有一个特定的模块做特定的工作，现在让我们假设这个工作在主程序中要做20次(比如说)，例如计算一个数字数组中的最大数。现在，如果你为此写20次代码，你的代码会变得很大，但是，如果我们为此写一个函数，并在需要的时候调用这个函数，代码会很短，容易阅读，而且更加模块化。</p><p id="d489" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">使用函数减少了脚本的总长度/大小。此外，函数使程序更容易维护，因为它们将代码分成模块，在出现错误/错误时提供特定的地方进行编辑和故障排除。</p><p id="fcc0" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><strong class="io hj">注意:</strong><br/>——每当你发现自己在重复一组指令的时候，就为它创建一个函数。(函数必须在使用前定义)。<br/> -在启动主程序或主指令之前，最好在顶部定义所有功能。</p><p id="b770" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><strong class="io hj">语法:</strong></p><pre class="lc ld le lf fd lg lh li lj aw lk bi"><span id="386c" class="jt ju hi lh b fi ll lm l ln lo">function function_name() {<br/>    command 1<br/>    command 2<br/>    command 3<br/>      ...<br/>      ...<br/>    command N<br/>}</span></pre><p id="f40a" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><strong class="io hj">调用一个函数:</strong>只需在脚本中的一行写下它的名字。</p><pre class="lc ld le lf fd lg lh li lj aw lk bi"><span id="faae" class="jt ju hi lh b fi ll lm l ln lo">#!/bin/bash<br/>function myFunc () {<br/>    echo "Shell Scripting Is Fun!"<br/>}<br/>myFunc</span></pre><h1 id="a18d" class="lx ju hi bd jv ly lz ma jz mb mc md kd me mf mg kg mh mi mj kj mk ml mm km mn bi translated">向函数传递参数</h1><p id="b2a4" class="pw-post-body-paragraph im in hi io b ip ko ir is it kp iv iw ix kq iz ja jb kr jd je jf ks jh ji jj hb bi translated">您可以定义一个在调用函数时接受参数的函数。这些参数将由<strong class="io hj"> $1 </strong>、<strong class="io hj"> $2 </strong>等表示。</p><p id="f3ca" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">下面是一个例子，我们传递两个参数<em class="mq"> Zara </em>和<em class="mq"> Ali </em>，然后我们在函数中捕获并打印这些参数。</p><pre class="lc ld le lf fd lg lh li lj aw lk bi"><span id="171a" class="jt ju hi lh b fi ll lm l ln lo">#!/bin/sh</span><span id="3253" class="jt ju hi lh b fi mo lm l ln lo"># Define your function here<br/>Hello () {<br/>   echo "Hello World $1 $2"<br/>}</span><span id="0598" class="jt ju hi lh b fi mo lm l ln lo"># Invoke your function<br/>Hello vimal daga</span></pre><p id="b24e" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">执行后，您将收到以下结果</p><pre class="lc ld le lf fd lg lh li lj aw lk bi"><span id="03f2" class="jt ju hi lh b fi ll lm l ln lo">$./test.sh<br/>Hello World vimal daga</span></pre><p id="3e39" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">要从shell中删除函数的定义，请使用带有- <strong class="io hj"> f </strong>选项的unset命令。该命令也用于删除外壳中变量的定义。</p><pre class="lc ld le lf fd lg lh li lj aw lk bi"><span id="106d" class="jt ju hi lh b fi ll lm l ln lo">$ unset -f function_name</span></pre><h1 id="4294" class="lx ju hi bd jv ly lz ma jz mb mc md kd me mf mg kg mh mi mj kj mk ml mm km mn bi translated">函数中的位置参数</h1><p id="56ce" class="pw-post-body-paragraph im in hi io b ip ko ir is it kp iv iw ix kq iz ja jb kr jd je jf ks jh ji jj hb bi translated">就像shell脚本一样，函数也可以接受参数。第一个参数存储在$1中，第二个参数存储在$2中，依此类推。$@包含所有参数。<br/> <strong class="io hj">注意:</strong> $0还是脚本本身的名字，不是函数的名字。<br/>要提供参数，只需将它们写在函数名之后，中间留一个空格。<code class="du lp lq lr lh b">myFunc param1 param2 param3 ...</code></p><p id="21bc" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><strong class="io hj">变量范围</strong></p><p id="a845" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><strong class="io hj">全局范围:</strong>默认情况下，所有变量都有全局范围。具有全局范围意味着可以从脚本中的任何地方访问该变量的值。变量必须在使用前定义。<br/> <strong class="io hj">局部范围:</strong>局部变量只能从函数内部访问。使用关键字<code class="du lp lq lr lh b">local</code>创建局部变量，只有函数可以有局部变量。将函数中的变量保持在局部是一个好习惯。</p><h1 id="761c" class="lx ju hi bd jv ly lz ma jz mb mc md kd me mf mg kg mh mi mj kj mk ml mm km mn bi translated">通配符</h1><p id="f3f4" class="pw-post-body-paragraph im in hi io b ip ko ir is it kp iv iw ix kq iz ja jb kr jd je jf ks jh ji jj hb bi translated">用于匹配文件名和目录名的字符或字符串模式称为通配符。用于将通配符模式扩展为文件和/或目录(或基本路径)列表的过程称为Globbing。<br/>通配符可用于大多数需要文件/目录路径作为参数的命令。(例如ls、rm、cp等)。</p><h1 id="d2ef" class="lx ju hi bd jv ly lz ma jz mb mc md kd me mf mg kg mh mi mj kj mk ml mm km mn bi translated">一些常用的通配符</h1><p id="71fd" class="pw-post-body-paragraph im in hi io b ip ko ir is it kp iv iw ix kq iz ja jb kr jd je jf ks jh ji jj hb bi translated"><strong class="io hj"> * =匹配零个或多个字符<br/> </strong>例如:<code class="du lp lq lr lh b">*.txt</code> <code class="du lp lq lr lh b">hello.*</code> <code class="du lp lq lr lh b">great*.md</code></p><p id="ac94" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><strong class="io hj">？=恰好匹配一个字符<br/> </strong>例如:<code class="du lp lq lr lh b">?.md</code> <code class="du lp lq lr lh b">Hello?</code></p><p id="3d1d" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><strong class="io hj"> [ ] =一个字符类<br/> </strong>该通配符用于匹配方括号内的任何字符(只匹配一个字符)。<br/>举例:<code class="du lp lq lr lh b">He[loym]</code>，<code class="du lp lq lr lh b">[AIEOU]</code></p><p id="1da2" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><strong class="io hj">【！] =不包括在括号<br/> </strong>内的匹配字符它只匹配一个字符。<br/>示例:匹配辅音:<code class="du lp lq lr lh b">[!aeiou]</code></p><p id="0912" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><strong class="io hj">预定义的命名字符类</strong></p><ul class=""><li id="fa9e" class="jk jl hi io b ip iq it iu ix jm jb jn jf jo jj jp jq jr js bi translated">[[:alpha:]]</li><li id="ffd7" class="jk jl hi io b ip kw it kx ix ky jb kz jf la jj jp jq jr js bi translated">[[:alnum:]]</li><li id="f4e5" class="jk jl hi io b ip kw it kx ix ky jb kz jf la jj jp jq jr js bi translated">[[:空格:]]</li><li id="ae4d" class="jk jl hi io b ip kw it kx ix ky jb kz jf la jj jp jq jr js bi translated">[[:upper:]]]</li><li id="090f" class="jk jl hi io b ip kw it kx ix ky jb kz jf la jj jp jq jr js bi translated">[[:更低:]]</li><li id="2ac3" class="jk jl hi io b ip kw it kx ix ky jb kz jf la jj jp jq jr js bi translated">[[:digit:]]</li></ul><p id="8538" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><strong class="io hj">匹配通配符:</strong>如果我们必须匹配通配符本身，如<code class="du lp lq lr lh b">*</code>或<code class="du lp lq lr lh b">?</code>，我们可以使用转义符- <code class="du lp lq lr lh b">\<br/></code> <strong class="io hj">例如:</strong><code class="du lp lq lr lh b">*\?</code>–&gt;将匹配所有以问号结尾的文件。</p><h1 id="d6ea" class="lx ju hi bd jv ly lz ma jz mb mc md kd me mf mg kg mh mi mj kj mk ml mm km mn bi translated">排除故障</h1><p id="e757" class="pw-post-body-paragraph im in hi io b ip ko ir is it kp iv iw ix kq iz ja jb kr jd je jf ks jh ji jj hb bi translated">bug是计算机程序/软件中的一个错误，导致它产生一个意想不到的或不正确的结果。大多数错误都是由代码和设计中的错误引起的。要修复错误，请尝试找到意外行为的根源。</p><p id="7ad7" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">bash shell提供了一些选项，可以帮助您调试脚本。您可以通过更新脚本的第一行来使用这些选项。</p><p id="05d7" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><strong class="io hj">部分选项:</strong></p><p id="87c8" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><strong class="io hj"> 1。-x选项</strong> <br/>它在命令和参数执行时打印它们。它被称为打印调试、跟踪或x跟踪。我们可以通过修改第一行<code class="du lp lq lr lh b">#!/bin/bash -x</code>来使用它</p><p id="f3a3" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><strong class="io hj"> 2。-e选项<br/> </strong>代表“出错退出”。如果命令以非零退出状态退出，这将导致脚本立即退出。</p><p id="9133" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><strong class="io hj"> 3。-v选项<br/> </strong>它在读取时打印shell命令/输入行。</p><p id="3db6" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><strong class="io hj">注意* </strong>这些选项可以组合使用，一次可以使用多个选项！</p><pre class="lc ld le lf fd lg lh li lj aw lk bi"><span id="7b7c" class="jt ju hi lh b fi ll lm l ln lo">#!/bin/bash-xe<br/>#!/bin/bash-ex<br/>#!/bin/bash-x-e<br/>#!/bin/bash-e-x</span></pre><h1 id="e27e" class="lx ju hi bd jv ly lz ma jz mb mc md kd me mf mg kg mh mi mj kj mk ml mm km mn bi translated">外壳输入/输出重定向</h1><h2 id="d31a" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ix ke kf kg jb kh ki kj jf kk kl km kn bi translated">输出重定向</h2><p id="fd1d" class="pw-post-body-paragraph im in hi io b ip ko ir is it kp iv iw ix kq iz ja jb kr jd je jf ks jh ji jj hb bi translated">通常用于标准输出的命令输出可以很容易地转移到文件中。这种能力被称为输出重定向。</p><p id="8185" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">如果将符号&gt; file附加到任何通常将其输出写入标准输出的命令，则该命令的输出将被写入文件，而不是您的终端。</p><p id="55bd" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">检查以下<strong class="io hj"> who </strong>命令，该命令将命令的完整输出重定向到用户文件中。</p><pre class="lc ld le lf fd lg lh li lj aw lk bi"><span id="4c24" class="jt ju hi lh b fi ll lm l ln lo">$ who &gt; users</span></pre><p id="a313" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">请注意，终端上没有输出。这是因为输出已经从默认的标准输出设备(终端)重定向到指定的文件中。您可以检查用户文件以获得完整的内容</p><pre class="lc ld le lf fd lg lh li lj aw lk bi"><span id="b650" class="jt ju hi lh b fi ll lm l ln lo">$ cat users</span></pre><p id="9817" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">如果一个命令将其输出重定向到一个文件，而该文件已经包含一些数据，那么这些数据将会丢失。考虑下面的例子</p><pre class="lc ld le lf fd lg lh li lj aw lk bi"><span id="ecca" class="jt ju hi lh b fi ll lm l ln lo">$ echo line 1 &gt; users<br/>$ cat users<br/>line 1</span></pre><p id="5cf3" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">您可以使用&gt;&gt;运算符将输出附加到现有文件中，如下所示</p><pre class="lc ld le lf fd lg lh li lj aw lk bi"><span id="fbc1" class="jt ju hi lh b fi ll lm l ln lo">$ echo line 2 &gt;&gt; users<br/>$ cat users<br/>line 1<br/>line 2</span></pre><h2 id="8099" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ix ke kf kg jb kh ki kj jf kk kl km kn bi translated">输入重定向</h2><p id="a09d" class="pw-post-body-paragraph im in hi io b ip ko ir is it kp iv iw ix kq iz ja jb kr jd je jf ks jh ji jj hb bi translated">就像命令的输出可以重定向到文件一样，命令的输入也可以从文件重定向。由于<strong class="io hj">大于号&gt; </strong>用于输出重定向，所以<strong class="io hj">小于号&lt; </strong>用于重定向命令的输入。</p><p id="6394" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">通常从标准输入中获取输入的命令可以通过这种方式从文件中重定向其输入。例如，要计算上面生成的文件<em class="mq"> users </em>中的行数，可以执行如下命令</p><pre class="lc ld le lf fd lg lh li lj aw lk bi"><span id="dd83" class="jt ju hi lh b fi ll lm l ln lo">$ wc -l users<br/>2 users</span></pre><p id="07a0" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">执行后，您将收到以下输出。您可以通过从文件<em class="mq">用户</em>重定向<strong class="io hj"> wc </strong>命令的标准输入来计算文件中的行数</p><pre class="lc ld le lf fd lg lh li lj aw lk bi"><span id="00d2" class="jt ju hi lh b fi ll lm l ln lo">$ wc -l &lt; users<br/>2</span></pre><p id="0630" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">请注意，两种形式的wc命令产生的输出是不同的。在第一种情况下，文件用户的名称与行数一起列出；在第二种情况下，就不是了。</p><p id="57ab" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">在第一种情况下，wc知道它正在从文件用户那里读取输入。在第二种情况下，它只知道从标准输入中读取输入，所以不显示文件名。</p><h2 id="c39f" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ix ke kf kg jb kh ki kj jf kk kl km kn bi translated">从文件的每一行获取第5rd元素</h2><pre class="lc ld le lf fd lg lh li lj aw lk bi"><span id="6091" class="jt ju hi lh b fi ll lm l ln lo">$ awk ‘{print $5}’</span></pre><h2 id="907f" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ix ke kf kg jb kh ki kj jf kk kl km kn bi translated">从给定的文件名中找出包含单词“ABC”的行数:</h2><pre class="lc ld le lf fd lg lh li lj aw lk bi"><span id="64d4" class="jt ju hi lh b fi ll lm l ln lo">$ grep –c “ABC” filename</span></pre><h2 id="cd9f" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ix ke kf kg jb kh ki kj jf kk kl km kn bi translated">从文件的每一行获取第三个元素/列</h2><pre class="lc ld le lf fd lg lh li lj aw lk bi"><span id="ef94" class="jt ju hi lh b fi ll lm l ln lo">$ awk '{print $3}' $1</span></pre><h2 id="b956" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ix ke kf kg jb kh ki kj jf kk kl km kn bi translated">打印系统上所有用户的登录名:</h2><p id="e125" class="pw-post-body-paragraph im in hi io b ip ko ir is it kp iv iw ix kq iz ja jb kr jd je jf ks jh ji jj hb bi translated">/etc/shadow文件列出了所有用户。</p><pre class="lc ld le lf fd lg lh li lj aw lk bi"><span id="2762" class="jt ju hi lh b fi ll lm l ln lo">$ awk –F ‘:’ ‘{print $1}’ /etc/shadow|uniq –u</span></pre><h2 id="aad7" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ix ke kf kg jb kh ki kj jf kk kl km kn bi translated">在文件的每50行插入一行“ABCD”</h2><pre class="lc ld le lf fd lg lh li lj aw lk bi"><span id="9764" class="jt ju hi lh b fi ll lm l ln lo">$ sed ’50i\ABCD’ filename</span></pre><h2 id="fa08" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ix ke kf kg jb kh ki kj jf kk kl km kn bi translated">从任何文件中剪切任何字段</h2><pre class="lc ld le lf fd lg lh li lj aw lk bi"><span id="c6ba" class="jt ju hi lh b fi ll lm l ln lo">$ cut -f 6 -d “:” /etc/passwd</span></pre><p id="0e18" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">f代表字段，d代表字段分隔，etc/passwd是一个one文件。</p><h1 id="96fa" class="lx ju hi bd jv ly lz ma jz mb mc md kd me mf mg kg mh mi mj kj mk ml mm km mn bi translated">AWK司令部</h1><p id="f7d2" class="pw-post-body-paragraph im in hi io b ip ko ir is it kp iv iw ix kq iz ja jb kr jd je jf ks jh ji jj hb bi translated"><strong class="io hj"> awk命令</strong>用于Linux中的<strong class="io hj">文本处理</strong>。虽然，sed命令也用于文本处理，但是它有一些限制，所以awk命令成为文本处理的一个方便的选项。它提供了对数据的强大控制。</p><p id="e30d" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">Awk是一种强大的脚本语言，用于<strong class="io hj">文本脚本</strong>。它搜索和替换文本，并对数据库进行排序、验证和索引。</p><p id="e6aa" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">它是程序员使用最广泛的工具之一，因为他们以语句的形式编写按比例缩小的有效程序来定义文本模式和设计。</p><p id="fb0a" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">它在Linux 中充当<strong class="io hj">过滤器。在Linux中也被称为<strong class="io hj"> gawk (GNU awk) </strong>。</strong></p><h2 id="7ee6" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ix ke kf kg jb kh ki kj jf kk kl km kn bi translated">AWK是怎么命名的？</h2><p id="9c0d" class="pw-post-body-paragraph im in hi io b ip ko ir is it kp iv iw ix kq iz ja jb kr jd je jf ks jh ji jj hb bi translated">这个命令是用三个人名字的第一个字母命名的，他们在1977年编写了这个命令的最初版本。他们的名字是<strong class="io hj">阿尔弗雷德·艾侯、彼得·温伯格、</strong>和<strong class="io hj">布莱恩·克尼根</strong>，他们来自&amp; T贝尔实验室的<strong class="io hj">。</strong></p><h2 id="2760" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ix ke kf kg jb kh ki kj jf kk kl km kn bi translated">AWK司令部的特点</h2><p id="44a1" class="pw-post-body-paragraph im in hi io b ip ko ir is it kp iv iw ix kq iz ja jb kr jd je jf ks jh ji jj hb bi translated">Awk命令的各种功能如下:</p><ul class=""><li id="fcc3" class="jk jl hi io b ip iq it iu ix jm jb jn jf jo jj jp jq jr js bi translated">它逐行扫描文件。</li><li id="7689" class="jk jl hi io b ip kw it kx ix ky jb kz jf la jj jp jq jr js bi translated">它将一个文件分割成多个字段。</li><li id="14bb" class="jk jl hi io b ip kw it kx ix ky jb kz jf la jj jp jq jr js bi translated">它比较输入文本或文本文件的一部分。</li><li id="2717" class="jk jl hi io b ip kw it kx ix ky jb kz jf la jj jp jq jr js bi translated">它对文件执行各种操作，比如搜索指定的文本等等。</li><li id="ee2f" class="jk jl hi io b ip kw it kx ix ky jb kz jf la jj jp jq jr js bi translated">它格式化输出行。</li><li id="e175" class="jk jl hi io b ip kw it kx ix ky jb kz jf la jj jp jq jr js bi translated">它执行算术和字符串操作。</li><li id="0aca" class="jk jl hi io b ip kw it kx ix ky jb kz jf la jj jp jq jr js bi translated">它将条件和循环应用于输出。</li><li id="a822" class="jk jl hi io b ip kw it kx ix ky jb kz jf la jj jp jq jr js bi translated">它转换指定结构上的文件和数据。</li><li id="8e4a" class="jk jl hi io b ip kw it kx ix ky jb kz jf la jj jp jq jr js bi translated">它生成格式报告。</li></ul><p id="6b34" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><strong class="io hj">语法:</strong></p><p id="eacf" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">Awk命令的用法如下:</p><pre class="lc ld le lf fd lg lh li lj aw lk bi"><span id="b4ed" class="jt ju hi lh b fi ll lm l ln lo">$ awk options ‘selection _criteria {action }’ input-file <strong class="lh hj">&gt;</strong> output-file</span></pre><p id="15f0" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">这些选项可以是:</p><ul class=""><li id="e9e8" class="jk jl hi io b ip iq it iu ix jm jb jn jf jo jj jp jq jr js bi translated"><strong class="io hj"> -f程序文件:</strong>它读取写在awk命令上的脚本的源代码</li><li id="28e9" class="jk jl hi io b ip kw it kx ix ky jb kz jf la jj jp jq jr js bi translated"><strong class="io hj"> -F fs: </strong>用作输入字段分隔符。</li></ul><pre class="lc ld le lf fd lg lh li lj aw lk bi"><span id="8eae" class="jt ju hi lh b fi ll lm l ln lo">$ awk --help</span></pre><p id="ff9d" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">执行这段代码时，您会得到以下结果</p><pre class="lc ld le lf fd lg lh li lj aw lk bi"><span id="0c87" class="jt ju hi lh b fi ll lm l ln lo">Usage: awk [POSIX or GNU style options] -f progfile [--] file ...<br/>Usage: awk [POSIX or GNU style options] [--] 'program' file ...<br/>POSIX options : GNU long options: (standard)<br/>   -f progfile                --file=progfile<br/>   -F fs                      --field-separator=fs<br/>   -v var=val                 --assign=var=val<br/>Short options : GNU long options: (extensions)<br/>   -b                         --characters-as-bytes<br/>   -c                         --traditional<br/>   -C                         --copyright<br/>   -d[file]                   --dump-variables[=file]<br/>   -e 'program-text'          --source='program-text'<br/>   -E file                    --exec=file<br/>   -g                         --gen-pot<br/>   -h                         --help<br/>   -L [fatal]                 --lint[=fatal]<br/>   -n                         --non-decimal-data<br/>   -N                         --use-lc-numeric<br/>   -O                         --optimize<br/>   -p[file]                   --profile[=file]<br/>   -P                         --posix<br/>   -r                         --re-interval<br/>   -S                         --sandbox<br/>   -t                         --lint-old<br/>   -V                         --version</span></pre><p id="f5c5" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><strong class="io hj">Awk中的内置变量</strong></p><p id="473d" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">Awk的内置变量包括字段变量——1美元、2美元、3美元等等(0美元是整行)——这些变量将一行文本分成称为字段的单个单词或片段。</p><p id="9835" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><strong class="io hj"> NR: </strong> NR命令保存当前输入记录的数量。记住记录通常是行。Awk命令对文件中的每个记录执行一次模式/操作语句。</p><p id="b25c" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><strong class="io hj"> NF: </strong> NF命令记录当前输入记录中字段的数量。</p><p id="2d38" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><strong class="io hj"> FS: </strong> FS命令包含字段分隔符，用于分隔输入行上的字段。默认为“空白”，即空格和制表符。FS可以被重新分配给另一个字符(通常在BEGIN中)来改变字段分隔符。</p><p id="5d60" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><strong class="io hj"> RS: </strong> RS命令存储当前记录分隔符。因为默认情况下，输入行是输入记录，所以默认的记录分隔符是换行符。</p><p id="f80a" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><strong class="io hj"> OFS: </strong> OFS命令存储输出字段分隔符，当Awk打印它们时，它分隔字段。默认为空格。每当print有几个用逗号分隔的参数时，它将打印每个参数之间的OFS值。</p><p id="1994" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><strong class="io hj"> ORS: </strong> ORS命令存储输出记录分隔符，当Awk打印输出行时，分隔符将输出行分开。默认为换行符。print会在任何要打印的内容的末尾自动输出ORS的内容。</p><ul class=""><li id="034f" class="jk jl hi io b ip iq it iu ix jm jb jn jf jo jj jp jq jr js bi translated">为了在运行时传递值，我们必须以非交互的方式发出命令。例如:passwd需要密码。于是，echo<password>| passwd bob * awk“{ Print NR }”my . txt→打印记录号</password></li><li id="a62b" class="jk jl hi io b ip kw it kx ix ky jb kz jf la jj jp jq jr js bi translated">awk '{ print $(NF-1) }' my.txt →当数据是非结构化时非常有用。它从每行中检索倒数第二个值。</li><li id="5662" class="jk jl hi io b ip kw it kx ix ky jb kz jf la jj jp jq jr js bi translated">awk有END选项来打印最后的输出。</li><li id="f030" class="jk jl hi io b ip kw it kx ix ky jb kz jf la jj jp jq jr js bi translated">awk有BEGIN关键字，我们可以在那里写更多的脚本，例如:for循环等等。</li></ul><figure class="lc ld le lf fd ij er es paragraph-image"><div class="er es mr"><img src="../Images/9cde275b0e0faa9890ec43f8a98535e5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1248/format:webp/1*fooDZDjNRHFxwskP1ool1g.png"/></div></figure><h1 id="2bc5" class="lx ju hi bd jv ly lz ma jz mb mc md kd me mf mg kg mh mi mj kj mk ml mm km mn bi translated">使用AWK转置函数</h1><figure class="lc ld le lf fd ij er es paragraph-image"><div class="er es mr"><img src="../Images/9d35c2cafda1199a594a0c8ed40a8be4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1248/format:webp/1*Nj-bSE1_2D4bIkPcrF6FCQ.png"/></div></figure><h1 id="0022" class="lx ju hi bd jv ly lz ma jz mb mc md kd me mf mg kg mh mi mj kj mk ml mm km mn bi translated">编写命令以获取错误客户端命中的总数。</h1><p id="d0b8" class="pw-post-body-paragraph im in hi io b ip ko ir is it kp iv iw ix kq iz ja jb kr jd je jf ks jh ji jj hb bi translated">错误客户端命中的总数:AWS ' $ 9 = = 404 { print $ 0 ' access _ log | sort | uniq-c | WC-l</p><h1 id="ec9d" class="lx ju hi bd jv ly lz ma jz mb mc md kd me mf mg kg mh mi mj kj mk ml mm km mn bi translated">如何从日期输出中获取过滤器dd:mm:yy？</h1><p id="b6be" class="pw-post-body-paragraph im in hi io b ip ko ir is it kp iv iw ix kq iz ja jb kr jd je jf ks jh ji jj hb bi translated">使用日期+%e : %b : %G筛选dd:mm:yyyy</p><h1 id="c18f" class="lx ju hi bd jv ly lz ma jz mb mc md kd me mf mg kg mh mi mj kj mk ml mm km mn bi translated">如何对线路日志文件进行排序和统计？</h1><p id="cdc2" class="pw-post-body-paragraph im in hi io b ip ko ir is it kp iv iw ix kq iz ja jb kr jd je jf ks jh ji jj hb bi translated">awk“{ print $ 1 }”access _ log | sort | uniq-c | sort-n-k1</p><h1 id="eb68" class="lx ju hi bd jv ly lz ma jz mb mc md kd me mf mg kg mh mi mj kj mk ml mm km mn bi translated">观察命令</h1><p id="fe1f" class="pw-post-body-paragraph im in hi io b ip ko ir is it kp iv iw ix kq iz ja jb kr jd je jf ks jh ji jj hb bi translated"><code class="du lp lq lr lh b">watch</code>用于定期运行任意命令，并在终端窗口显示命令的输出。</p><p id="5871" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">当您必须重复执行一个命令并观察命令输出随时间的变化时，这很有用。例如，您可以使用<code class="du lp lq lr lh b">watch</code>命令来监控系统正常运行时间或磁盘使用情况。</p><p id="81fd" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><code class="du lp lq lr lh b">watch</code>实用程序是<code class="du lp lq lr lh b">procps</code>(或<code class="du lp lq lr lh b">procps-ng</code>)包的一部分，几乎所有的Linux发行版都预装了这个包。</p><h2 id="9f12" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ix ke kf kg jb kh ki kj jf kk kl km kn bi translated">如何使用<code class="du lp lq lr lh b">watch</code>命令</h2><p id="5c12" class="pw-post-body-paragraph im in hi io b ip ko ir is it kp iv iw ix kq iz ja jb kr jd je jf ks jh ji jj hb bi translated"><code class="du lp lq lr lh b">watch</code>命令的语法如下:</p><pre class="lc ld le lf fd lg lh li lj aw lk bi"><span id="26ee" class="jt ju hi lh b fi ll lm l ln lo">watch [OPTIONS] COMMAND</span></pre><p id="104c" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><strong class="io hj">每2秒运行一次命令</strong></p><p id="18f3" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">默认情况下，watch命令每2秒钟运行一次，并在终端上显示输出。它会一直运行，直到被用户中断。</p><pre class="lc ld le lf fd lg lh li lj aw lk bi"><span id="f7b9" class="jt ju hi lh b fi ll lm l ln lo">watch date</span></pre><p id="e4b0" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><strong class="io hj">每N秒运行一次命令</strong></p><p id="cdd7" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">可以覆盖监视命令更新间隔。这意味着您可以将更新间隔从2秒更改为您想要的间隔。</p><pre class="lc ld le lf fd lg lh li lj aw lk bi"><span id="1717" class="jt ju hi lh b fi ll lm l ln lo">watch -n &lt;interval-in-seconds&gt; &lt;command&gt;</span></pre><p id="97d3" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><strong class="io hj">突出显示更新之间的差异</strong></p><p id="76d8" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">您还可以突出显示先前输出和当前输出之间的差异。因此，您可以关注变化，而不是读取整个输出。</p><pre class="lc ld le lf fd lg lh li lj aw lk bi"><span id="9577" class="jt ju hi lh b fi ll lm l ln lo">watch -d &lt;command&gt;</span></pre><p id="c718" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><strong class="io hj">隐藏输出中的标题</strong></p><p id="292f" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">Watch命令输出显示一个标题，其中包含时间间隔、命令、系统名称和系统日期。但是，如果您不想看到这一部分，也可以将其隐藏。</p><pre class="lc ld le lf fd lg lh li lj aw lk bi"><span id="1466" class="jt ju hi lh b fi ll lm l ln lo">watch -t &lt;command&gt;</span></pre><p id="7afb" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><strong class="io hj">变更时退出</strong></p><p id="9dbb" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">默认情况下，watch命令会一直运行，直到被用户手动中断。但是，如果它也发现了输出中的变化，您可以让它退出。</p><pre class="lc ld le lf fd lg lh li lj aw lk bi"><span id="4bd1" class="jt ju hi lh b fi ll lm l ln lo">watch -g &lt;command&gt;</span><span id="54aa" class="jt ju hi lh b fi mo lm l ln lo">watch -n 10 -g date</span></pre><h1 id="4ccc" class="lx ju hi bd jv ly lz ma jz mb mc md kd me mf mg kg mh mi mj kj mk ml mm km mn bi translated">Linux中的路径</h1><p id="49ac" class="pw-post-body-paragraph im in hi io b ip ko ir is it kp iv iw ix kq iz ja jb kr jd je jf ks jh ji jj hb bi translated">PATH是一个环境变量。它是一个用冒号分隔的目录列表，当您输入命令时，您的shell会在其中进行搜索。所有可执行文件都保存在Linux和Unix等操作系统的不同目录中。</p><figure class="lc ld le lf fd ij er es paragraph-image"><div class="er es mr"><img src="../Images/b73f34102f034aec8f49aa1b1468ba52.png" data-original-src="https://miro.medium.com/v2/resize:fit:1248/format:webp/1*NIOKb6ZgpqaMZuKIbk3MuQ.png"/></div></figure><h1 id="6a9f" class="lx ju hi bd jv ly lz ma jz mb mc md kd me mf mg kg mh mi mj kj mk ml mm km mn bi translated">Linux sed命令| Linux流编辑器</h1><p id="a971" class="pw-post-body-paragraph im in hi io b ip ko ir is it kp iv iw ix kq iz ja jb kr jd je jf ks jh ji jj hb bi translated">Linux 'sed '命令代表流编辑器。它用于使用正则表达式编辑流(文件)。但是这种编辑不是永久的。它只是显示出来，但实际上，文件内容保持不变。</p><p id="af39" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">它主要用于文本替换；此外，它还可以用于其他文本操作，如插入、删除、搜索等。sed命令允许我们在不打开文件的情况下编辑文件。正则表达式支持使它成为一个更强大的文本操作工具。</p><p id="bd48" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">语法:sed[OPTION]…{ script-only-if-no-other-script }[输入文件]…</p><p id="7ce8" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">这听起来可能很疯狂，但是Linux <code class="du lp lq lr lh b">sed</code>命令是一个没有界面的文本编辑器。您可以从命令行使用它来操作文件和流中的文本。</p><p id="43e7" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><strong class="io hj">sed的威力</strong></p><p id="69b9" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">命令有点像国际象棋:学习基础知识需要一个小时，掌握它们需要一生的时间(或者，至少需要大量的练习)。我们将向您展示在<code class="du lp lq lr lh b">sed</code>功能的每个主要类别中选择的开场策略。</p><p id="e3a8" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><code class="du lp lq lr lh b">sed</code>是一个流编辑器，处理管道输入或文本文件。然而，它没有交互式文本编辑器界面。相反，当它在文本中工作时，你提供指令让它遵循。这在Bash和其他命令行shells中都有效。</p><p id="012d" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">使用<code class="du lp lq lr lh b">sed</code>，您可以执行以下所有操作:</p><ul class=""><li id="ca8d" class="jk jl hi io b ip iq it iu ix jm jb jn jf jo jj jp jq jr js bi translated">选择文本</li><li id="cc86" class="jk jl hi io b ip kw it kx ix ky jb kz jf la jj jp jq jr js bi translated">替代文本</li><li id="6ad0" class="jk jl hi io b ip kw it kx ix ky jb kz jf la jj jp jq jr js bi translated">向文本添加线条</li><li id="e9c1" class="jk jl hi io b ip kw it kx ix ky jb kz jf la jj jp jq jr js bi translated">从文本中删除行</li><li id="b846" class="jk jl hi io b ip kw it kx ix ky jb kz jf la jj jp jq jr js bi translated">修改(或保留)原始文件</li></ul><p id="a0be" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">例如:<strong class="io hj">sed-I ' 63s/bash/sh/g '/etc/passwd</strong></p><p id="44d4" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">如果我们在函数中使用，g代表全局。63是记录号，在发现bash替换为sh的地方必须更新。-i选项更新文件。</p><h1 id="6f5d" class="lx ju hi bd jv ly lz ma jz mb mc md kd me mf mg kg mh mi mj kj mk ml mm km mn bi translated">奖金！</h1><h1 id="1bd7" class="lx ju hi bd jv ly lz ma jz mb mc md kd me mf mg kg mh mi mj kj mk ml mm km mn bi translated">项目</h1><blockquote class="ms"><p id="e46a" class="mt mu hi bd mv mw mx my mz na nb jj dx translated"><strong class="ak"> 1。用户脚本</strong></p><p id="f77b" class="mt mu hi bd mv mw mx my mz na nb jj dx translated">特点:</p><p id="ca54" class="mt mu hi bd mv mw mx my mz na nb jj dx translated">* useradd:添加新用户</p><p id="b6fe" class="mt mu hi bd mv mw mx my mz na nb jj dx translated">* userdel:删除现有用户</p><p id="7442" class="mt mu hi bd mv mw mx my mz na nb jj dx translated">*用户锁定和备份:锁定用户的帐户，并创建用户工作区的备份</p><p id="83a8" class="mt mu hi bd mv mw mx my mz na nb jj dx translated"><strong class="ak"> 2。拒绝服务攻击检测预防</strong></p><p id="f3cd" class="mt mu hi bd mv mw mx my mz na nb jj dx translated">特点:</p><p id="840e" class="mt mu hi bd mv mw mx my mz na nb jj dx translated">*分析httpd服务器日志</p><p id="c55b" class="mt mu hi bd mv mw mx my mz na nb jj dx translated">*检测是否有人试图执行拒绝服务攻击，如果是，它可以采取适当的行动对付它。</p></blockquote><h2 id="151d" class="jt ju hi bd jv jw nc jy jz ka nd kc kd ix ne kf kg jb nf ki kj jf ng kl km kn bi translated">GitHub URL:<a class="ae nh" href="https://github.com/gursimarh/shell-scripting" rel="noopener ugc nofollow" target="_blank">gursimarh/shell-scripting(github.com)</a></h2></div></div>    
</body>
</html>