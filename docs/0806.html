<html>
<head>
<title>ExpressJS 101</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">ExpressJS 101</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/expressjs-101-b67171f1dbd6?source=collection_archive---------6-----------------------#2021-02-15">https://medium.com/nerd-for-tech/expressjs-101-b67171f1dbd6?source=collection_archive---------6-----------------------#2021-02-15</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="f352" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">一段时间前我就想这么做了，因为在新来的web开发人员主宰或完成流畅的HTML工作后，关于下一步该做什么有很多困惑。</p><p id="8646" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">前端开发人员应该熟悉后端活动，不管是否专业，不仅仅是工具和如何发送/接收数据，而是HTTP通信的基础等等。</p><p id="7ff8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">由于两个世界的熟练程度，越来越需要全栈工作。在我看来，仅仅学习道路的一边是不够的。</p><p id="f7a5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在NodeJS世界中，有许多工具、框架和本机内置模块用于处理HTTP通信。ExpressJS成为这种转变最流行的工具。</p><p id="3afb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这篇文章不是为了对ExpressJS进行全面的技术回顾。但是为了解释这个工具如何能够适应使用HTTP的简单性而不至于一试就死。</p><p id="3270" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">ExpressJS是一个杀手级工具，因为它可以非常容易地处理任务。</p><ol class=""><li id="0418" class="jd je hi ih b ii ij im in iq jf iu jg iy jh jc ji jj jk jl bi translated">URL参数和查询字符串解析</li><li id="9078" class="jd je hi ih b ii jm im jn iq jo iu jp iy jq jc ji jj jk jl bi translated">自动回复标题。</li><li id="8974" class="jd je hi ih b ii jm im jn iq jo iu jp iy jq jc ji jj jk jl bi translated">路线和更好的代码组织</li><li id="1e73" class="jd je hi ih b ii jm im jn iq jo iu jp iy jq jc ji jj jk jl bi translated">插件采用或中间件</li><li id="c49b" class="jd je hi ih b ii jm im jn iq jo iu jp iy jq jc ji jj jk jl bi translated">请求正文解析</li><li id="4689" class="jd je hi ih b ii jm im jn iq jo iu jp iy jq jc ji jj jk jl bi translated">身份验证、验证、会话等。</li></ol><h2 id="a53a" class="jr js hi bd jt ju jv jw jx jy jz ka kb iq kc kd ke iu kf kg kh iy ki kj kk kl bi translated">第一种配置</h2><p id="586c" class="pw-post-body-paragraph if ig hi ih b ii km ik il im kn io ip iq ko is it iu kp iw ix iy kq ja jb jc hb bi translated">查看下面的脚本，它包含一个简单配置的基本脚本和两个附加脚本。设置属性为我们的HTML脚本设置模板目录。而<code class="du kr ks kt ku b">view engine</code>设置将用于HTML站点的模板引擎</p><pre class="kv kw kx ky fd kz ku la lb aw lc bi"><span id="4e3e" class="jr js hi ku b fi ld le l lf lg">var express = require('express')<br/>var app = express()<br/>app.set('port', process.env.PORT || 3000) <br/>app.set('views', 'templates')<br/>app.set('view engine', 'jade')</span></pre><h2 id="1873" class="jr js hi bd jt ju jv jw jx jy jz ka kb iq kc kd ke iu kf kg kh iy ki kj kk kl bi translated">中间件模式</h2><p id="0774" class="pw-post-body-paragraph if ig hi ih b ii km ik il im kn io ip iq ko is it iu kp iw ix iy kq ja jb jc hb bi translated">中间件模式是一系列连接在一起的处理单元，其中一个单元的输出是下一个单元的输入。</p><p id="2705" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在NodeJS中，这通常意味着以下形式的一系列函数:</p><pre class="kv kw kx ky fd kz ku la lb aw lc bi"><span id="358d" class="jr js hi ku b fi ld le l lf lg">function(args, next) {<br/>   [Place your logic here]<br/>   next(output)<br/>}</span></pre><p id="7863" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">中间件的关键方面是在请求周期中扮演的角色及其连续性</p><p id="de3a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><code class="du kr ks kt ku b">request -&gt; middleware1 -&gt; middlewareN -&gt; route -&gt; response</code></p><p id="2c9a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Express利用框架来实现中间件功能，如下所示:</p><pre class="kv kw kx ky fd kz ku la lb aw lc bi"><span id="b57c" class="jr js hi ku b fi ld le l lf lg">var express = require('express')<br/>var app = express()</span><span id="cdb2" class="jr js hi ku b fi lh le l lf lg">// [Here goes the middleware]<br/>app.use(middleware1)<br/>app.use(middleware2)<br/>...</span></pre><p id="0e9a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">根据您想要开发的任何逻辑，执行的顺序是相关的。除了第三方中间件之外，Express还允许您创建自己的中间件，框架如下:</p><pre class="kv kw kx ky fd kz ku la lb aw lc bi"><span id="db43" class="jr js hi ku b fi ld le l lf lg">var middleware = function(req, res, next) {<br/>  [Place your logic here]<br/>  next()<br/>}</span><span id="1ec0" class="jr js hi ku b fi lh le l lf lg">app.use(middleware)</span></pre><p id="645d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">也可以匿名声明。这个是自动调用的。</p><pre class="kv kw kx ky fd kz ku la lb aw lc bi"><span id="6ca7" class="jr js hi ku b fi ld le l lf lg">app.use(function(req, res, next) {<br/>  [Place your logic here]<br/>  next()<br/>})</span></pre><p id="fa5e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在对ExpressJS服务器的单个客户机请求的生命周期中,<code class="du kr ks kt ku b">req</code>值总是相同的对象。它可以很容易地被引用，避免了需要将引用传递给中间件内部逻辑时的麻烦</p><p id="a3cb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">以下是可用的最流行和最有用的中间件。您应该在<a class="ae li" href="https://npmjs.com" rel="noopener ugc nofollow" target="_blank"> npm </a>存储库中检查它们，并评估存在性、维护率、可用版本以及开发人员和用户文档</p><ol class=""><li id="bb39" class="jd je hi ih b ii ij im in iq jf iu jg iy jh jc ji jj jk jl bi translated"><code class="du kr ks kt ku b">body-parser</code>作为请求有效载荷的机制</li><li id="94b5" class="jd je hi ih b ii jm im jn iq jo iu jp iy jq jc ji jj jk jl bi translated"><code class="du kr ks kt ku b">compression</code>具有gzip功能</li><li id="4278" class="jd je hi ih b ii jm im jn iq jo iu jp iy jq jc ji jj jk jl bi translated"><code class="du kr ks kt ku b">connect-timeout</code>设置请求超时功能</li><li id="93a0" class="jd je hi ih b ii jm im jn iq jo iu jp iy jq jc ji jj jk jl bi translated"><code class="du kr ks kt ku b">cookie-parser</code>与cookie处理相关</li><li id="0cfc" class="jd je hi ih b ii jm im jn iq jo iu jp iy jq jc ji jj jk jl bi translated"><code class="du kr ks kt ku b">cookie-session</code>通过饼干店进行会话</li><li id="5127" class="jd je hi ih b ii jm im jn iq jo iu jp iy jq jc ji jj jk jl bi translated"><code class="du kr ks kt ku b">csurf</code>进行CSRF验证</li><li id="d724" class="jd je hi ih b ii jm im jn iq jo iu jp iy jq jc ji jj jk jl bi translated"><code class="du kr ks kt ku b">express-session</code>通过内存或其他类型的存储进行会话</li><li id="76a4" class="jd je hi ih b ii jm im jn iq jo iu jp iy jq jc ji jj jk jl bi translated"><code class="du kr ks kt ku b">morgan</code>用于服务器日志</li><li id="67eb" class="jd je hi ih b ii jm im jn iq jo iu jp iy jq jc ji jj jk jl bi translated"><code class="du kr ks kt ku b">serve-static</code>为静态内容</li><li id="7516" class="jd je hi ih b ii jm im jn iq jo iu jp iy jq jc ji jj jk jl bi translated"><code class="du kr ks kt ku b">cookies</code>和<code class="du kr ks kt ku b">keygrip</code>类似于<code class="du kr ks kt ku b">cookieParser</code></li><li id="a561" class="jd je hi ih b ii jm im jn iq jo iu jp iy jq jc ji jj jk jl bi translated"><code class="du kr ks kt ku b">express-validator</code>与验证相关</li><li id="a2b7" class="jd je hi ih b ii jm im jn iq jo iu jp iy jq jc ji jj jk jl bi translated"><code class="du kr ks kt ku b">passport</code>作为认证库</li><li id="ec13" class="jd je hi ih b ii jm im jn iq jo iu jp iy jq jc ji jj jk jl bi translated"><code class="du kr ks kt ku b">helmet</code>用于安全标题</li><li id="9b8a" class="jd je hi ih b ii jm im jn iq jo iu jp iy jq jc ji jj jk jl bi translated"><code class="du kr ks kt ku b">connect-cors</code> CORS</li></ol><p id="6613" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">还有更多</p><h2 id="8c30" class="jr js hi bd jt ju jv jw jx jy jz ka kb iq kc kd ke iu kf kg kh iy ki kj kk kl bi translated">模板引擎</h2><p id="2f93" class="pw-post-body-paragraph if ig hi ih b ii km ik il im kn io ip iq ko is it iu kp iw ix iy kq ja jb jc hb bi translated">将<code class="du kr ks kt ku b">view engine</code>变量设置为<code class="du kr ks kt ku b">jade</code>实例会在内部触发以下函数调用</p><p id="1a59" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这可以通过许多不同的方式来实现。</p><p id="3535" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><code class="du kr ks kt ku b">app.set('view engine', 'jade')</code></p><p id="a471" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><code class="du kr ks kt ku b">app.engine('jade', require('jade').__express</code></p><p id="50d5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">或者使用自定义回调</p><pre class="kv kw kx ky fd kz ku la lb aw lc bi"><span id="cab2" class="jr js hi ku b fi ld le l lf lg">app.engine([format], function(path, options, callback) {<br/>  [Template parsing logic and options]<br/>})</span></pre><h2 id="dfde" class="jr js hi bd jt ju jv jw jx jy jz ka kb iq kc kd ke iu kf kg kh iy ki kj kk kl bi translated">快速启动逻辑</h2><p id="2f54" class="pw-post-body-paragraph if ig hi ih b ii km ik il im kn io ip iq ko is it iu kp iw ix iy kq ja jb jc hb bi translated">这一节很好理解，实例化Express框架的主文件，可以使用<code class="du kr ks kt ku b">http</code>内置模块委托服务器创建方法，vs使用同一个<code class="du kr ks kt ku b">express</code> app实例做同样的事情。</p><p id="efba" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">第一种方法是这样完成的:</p><pre class="kv kw kx ky fd kz ku la lb aw lc bi"><span id="b77a" class="jr js hi ku b fi ld le l lf lg">var express = require('express')<br/>var http = require('http')<br/>var port = 3000</span><span id="0b28" class="jr js hi ku b fi lh le l lf lg">var server = http.createServer(app)<br/>server.listen(port, () =&gt; {<br/>  console.log('Server up')<br/>})</span></pre><p id="3b46" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">第二种方法几乎相同。</p><pre class="kv kw kx ky fd kz ku la lb aw lc bi"><span id="eb86" class="jr js hi ku b fi ld le l lf lg">var express = require('express')<br/>var app = express()<br/>var port = 3000</span><span id="97fc" class="jr js hi ku b fi lh le l lf lg">app.listen(port, () =&gt; {<br/>  console.log('Server up')<br/>})</span></pre><h2 id="a915" class="jr js hi bd jt ju jv jw jx jy jz ka kb iq kc kd ke iu kf kg kh iy ki kj kk kl bi translated">利弊</h2><p id="623d" class="pw-post-body-paragraph if ig hi ih b ii km ik il im kn io ip iq ko is it iu kp iw ix iy kq ja jb jc hb bi translated">在传统的web应用场景中，我们可能会遇到与关注点分离、性能、代码重复等相关的瓶颈。对于本研究案例，可以关注:</p><ol class=""><li id="dac5" class="jd je hi ih b ii ij im in iq jf iu jg iy jh jc ji jj jk jl bi translated">性能可能很慢，而且是单任务的，这对于多任务或多线程场景来说不是一个有效的方法</li><li id="0dc1" class="jd je hi ih b ii jm im jn iq jo iu jp iy jq jc ji jj jk jl bi translated">可怜而迟钝的UX</li><li id="70cc" class="jd je hi ih b ii jm im jn iq jo iu jp iy jq jc ji jj jk jl bi translated">数据复制占用了HTML文件的带宽</li></ol><p id="a910" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">使用胖客户端时，视角完全变了。如果不熟悉厚的薄的客户端阅读<a class="ae li" href="https://en.wikipedia.org/wiki/Rich_client" rel="noopener ugc nofollow" target="_blank">这个</a></p><p id="c327" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">胖客户端的优势在于:</p><ol class=""><li id="fae1" class="jd je hi ih b ii ij im in iq jf iu jg iy jh jc ji jj jk jl bi translated">响应界面和UX</li><li id="7d67" class="jd je hi ih b ii jm im jn iq jo iu jp iy jq jc ji jj jk jl bi translated">只有数据通过JSON对象传输</li><li id="3682" class="jd je hi ih b ii jm im jn iq jo iu jp iy jq jc ji jj jk jl bi translated">您可以重用核心功能</li><li id="0a67" class="jd je hi ih b ii jm im jn iq jo iu jp iy jq jc ji jj jk jl bi translated">异步任务</li><li id="bb74" class="jd je hi ih b ii jm im jn iq jo iu jp iy jq jc ji jj jk jl bi translated">实时应用程序</li></ol><p id="23e5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这一新的功能浪潮彻底改变了全景。以及增强web开发客户端的新方法，剩下的就是历史了。</p><p id="1984" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">后端也以HTTP为主角改进了很多。容器化、微服务、API分解、数据库多样化等等。</p><h1 id="d6fe" class="lj js hi bd jt lk ll lm jx ln lo lp kb lq lr ls ke lt lu lv kh lw lx ly kk lz bi translated">水疗、休息和API</h1><p id="53f9" class="pw-post-body-paragraph if ig hi ih b ii km ik il im kn io ip iq ko is it iu kp iw ix iy kq ja jb jc hb bi translated">可重用性是这里的主要陈述:一次构建一个API，在任何地方使用它。</p><p id="8b81" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">无论使用哪种可用的客户机，您都可以使用相同的数据源。整个功能也是按照做什么和不做什么来划分的。由于API分解，您可以将服务用于特定的组件。</p><p id="1e3a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">此外，微服务场景出现，虚拟化和开发运维问题势头强劲。</p><h2 id="af1f" class="jr js hi bd jt ju jv jw jx jy jz ka kb iq kc kd ke iu kf kg kh iy ki kj kk kl bi translated">休息</h2><p id="bbc9" class="pw-post-body-paragraph if ig hi ih b ii km ik il im kn io ip iq ko is it iu kp iw ix iy kq ja jb jc hb bi translated">REST是一种开发网络应用程序的架构模式。REST系统的目标是在机器之间连接和交换数据时保持简单。</p><p id="f68e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">鉴于HTTP的无状态特性和客户端-服务器架构，HTTP是REST的理想协议。</p><p id="165e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">与像T21、SOAP、UDDI这样的网络服务相比，这要简单得多，因为它们都依赖复杂的词汇来进行交流。每个新操作都是一个新的词汇表条目，增加了代码的复杂性。</p><p id="03af" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">REST架构基于处理CRUD操作的HTTP动词。这就是为什么你听说过:<code class="du kr ks kt ku b">GET</code>、<code class="du kr ks kt ku b">PUT</code>、<code class="du kr ks kt ku b">POST</code>和<code class="du kr ks kt ku b">DELETE</code>，有时还有<code class="du kr ks kt ku b">PATCH</code>、<code class="du kr ks kt ku b">HEAD</code>或<code class="du kr ks kt ku b">OPTIONS</code></p><p id="b7c1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">另一个关键组件是<strong class="ih hj">REST</strong>REST<strong class="ih hj">Resources</strong>，这些是可以存储在计算机上的实体，比如文件、数据库条目或任何函数的处理输出。</p><p id="fcca" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">REST使用HTTP请求和响应来提供资源的表示。举个例子:从服务器下载一个文件，这个“文件”被认为是一种资源。</p><p id="3b0f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">当修改资源时，通过访问、改变或删除它，也将表示在<strong class="ih hj"> REST </strong>系统中改变的资源状态。</p><p id="5eb4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这是处理签名</p><pre class="kv kw kx ky fd kz ku la lb aw lc bi"><span id="0635" class="jr js hi ku b fi ld le l lf lg">// Request Handler signature</span><span id="7fa0" class="jr js hi ku b fi lh le l lf lg">function(request, response, next) {<br/>  [Something here]<br/>}</span><span id="444f" class="jr js hi ku b fi lh le l lf lg">// Error Handler signature<br/>function(error, request, response, next) {<br/>  [Something here]<br/>}</span></pre><p id="9250" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">客户端的HTTP请求可以从路由处理程序中访问，其中第一个参数是处理程序的回调。</p><h2 id="f1b9" class="jr js hi bd jt ju jv jw jx jy jz ka kb iq kc kd ke iu kf kg kh iy ki kj kk kl bi translated">获取请求</h2><p id="6b43" class="pw-post-body-paragraph if ig hi ih b ii km ik il im kn io ip iq ko is it iu kp iw ix iy kq ja jb jc hb bi translated">下面是如何用Express处理GET请求。用于检索数据。</p><pre class="kv kw kx ky fd kz ku la lb aw lc bi"><span id="d8a7" class="jr js hi ku b fi ld le l lf lg">// Root GET route<br/>app.get('/users', function(request, response) {<br/>  response.send('hello')<br/>})</span><span id="0b71" class="jr js hi ku b fi lh le l lf lg">// GET Parameter handling<br/>app.get('/users/:id', function(request, response) {<br/>  ...<br/>})<br/></span></pre><p id="450b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这些动态参数可以通过请求的param对象来访问，就像这样:<code class="du kr ks kt ku b">request.params.id</code></p><pre class="kv kw kx ky fd kz ku la lb aw lc bi"><span id="5a2b" class="jr js hi ku b fi ld le l lf lg">// GET Parameter handling<br/>app.get('/users/:id', function(request, response) {<br/>  var id = request.params.id<br/>})</span></pre><h2 id="fbcd" class="jr js hi bd jt ju jv jw jx jy jz ka kb iq kc kd ke iu kf kg kh iy ki kj kk kl bi translated">发布请求</h2><p id="32b8" class="pw-post-body-paragraph if ig hi ih b ii km ik il im kn io ip iq ko is it iu kp iw ix iy kq ja jb jc hb bi translated">POST用于创建资源。</p><pre class="kv kw kx ky fd kz ku la lb aw lc bi"><span id="e82b" class="jr js hi ku b fi ld le l lf lg">app.post('/users', function (request, response) {  <br/>  var username = request.body.username  <br/>  var email = request.body.email  <br/>  // ...  // Code to create a new user  <br/>  response.send(user) <br/>});</span></pre><h2 id="1381" class="jr js hi bd jt ju jv jw jx jy jz ka kb iq kc kd ke iu kf kg kh iy ki kj kk kl bi translated">上传请求</h2><p id="0187" class="pw-post-body-paragraph if ig hi ih b ii km ik il im kn io ip iq ko is it iu kp iw ix iy kq ja jb jc hb bi translated">这个用来更新一个资源(或者创建一个可能不存在的资源)。</p><pre class="kv kw kx ky fd kz ku la lb aw lc bi"><span id="fd2a" class="jr js hi ku b fi ld le l lf lg">app.put('/users/:id', function(request, response) {<br/>  var id = request.params.id <br/>  if(exists) {<br/>   ... <br/>  } else {<br/>   ...<br/>  }<br/>  response.send(user)<br/>})</span></pre><h2 id="b7d2" class="jr js hi bd jt ju jv jw jx jy jz ka kb iq kc kd ke iu kf kg kh iy ki kj kk kl bi translated">删除请求</h2><p id="387a" class="pw-post-body-paragraph if ig hi ih b ii km ik il im kn io ip iq ko is it iu kp iw ix iy kq ja jb jc hb bi translated">这个用于删除资源。</p><pre class="kv kw kx ky fd kz ku la lb aw lc bi"><span id="e812" class="jr js hi ku b fi ld le l lf lg">app.delete('/users/:id', function (request, response) {<br/> var id = request.params.id;  <br/> // code to delete the user  response.send(user); <br/> // or maybe the URL to create a new user? <br/>});</span></pre><p id="0501" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">处理查询字符串也可以通过请求的查询对象来访问，比如:<code class="du kr ks kt ku b">request.query.name</code></p><p id="b2fe" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在<code class="du kr ks kt ku b"><a class="ae li" href="http://localhost:3000/?name=David+Lares&amp;age=22&amp;occupation=Batman" rel="noopener ugc nofollow" target="_blank">http://localhost:3000/?name=David+Lares&amp;age=22&amp;occupation=Batman</a></code></p><p id="6dc2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">你可以根据<code class="du kr ks kt ku b">key</code>变量名得到每个值，其中:<code class="du kr ks kt ku b">request.query.name</code>是<code class="du kr ks kt ku b">David Lares</code>，然后，<code class="du kr ks kt ku b">request.query.age</code>是<code class="du kr ks kt ku b">22</code>等等。</p><h2 id="d5db" class="jr js hi bd jt ju jv jw jx jy jz ka kb iq kc kd ke iu kf kg kh iy ki kj kk kl bi translated">处理请求正文</h2><p id="ebc4" class="pw-post-body-paragraph if ig hi ih b ii km ik il im kn io ip iq ko is it iu kp iw ix iy kq ja jb jc hb bi translated">如果您正在处理<strong class="ih hj"> POST </strong>或<strong class="ih hj"> PUT </strong>请求，您可能期望从表单或异步请求中接收数据。</p><p id="c05d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">ExpressJS曾经直接从其核心功能中处理主体请求，但是这被分离到另一个名为<code class="du kr ks kt ku b">body-parser</code>的库中</p><p id="5a5f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">安装:<code class="du kr ks kt ku b">npm install body-parser --save</code></p><p id="5ec1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">导入中间件:</p><pre class="kv kw kx ky fd kz ku la lb aw lc bi"><span id="95bb" class="jr js hi ku b fi ld le l lf lg">var bodyParser = require('body-parser')</span><span id="6664" class="jr js hi ku b fi lh le l lf lg">app.use(bodyParser.json()) // for single-page apps and JSON clients<br/>app.use(bodyParser.urlencoded({extended: false})) // for web-forms</span></pre><p id="98f9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">使用<code class="du kr ks kt ku b">request.body</code>对象访问数据。</p><p id="9c8b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">从web表单上传文件需要一个<code class="du kr ks kt ku b">multipart/form-data</code>属性。这可以用<code class="du kr ks kt ku b">Multer</code>、<code class="du kr ks kt ku b">express-busboy</code>、<code class="du kr ks kt ku b">connect-busboy</code>或<code class="du kr ks kt ku b">node-multiparty</code>第三方库来解析。</p><p id="d020" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">发送原始JSON？<code class="du kr ks kt ku b">Bodyparser</code>也可以处理它，使用:</p><p id="e058" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><code class="du kr ks kt ku b">app.use(bodyParser.json({type: 'application/*+json'}))</code></p><p id="7757" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">自定义缓冲区也是如此</p><p id="c579" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><code class="du kr ks kt ku b">app.use(bodyParser.raw({ type: 'application/vnd.custom-type' }))</code></p><p id="f7a6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">和HTML</p><p id="e1cf" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><code class="du kr ks kt ku b">app.use(bodyParser.text({ type: 'text/html' })</code></p><p id="ef48" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">诸如此类。查看<a class="ae li" href="https://www.npmjs.com/package/body-parser" rel="noopener ugc nofollow" target="_blank"> <em class="ma">文档</em> </a>了解更多信息</p><h2 id="c105" class="jr js hi bd jt ju jv jw jx jy jz ka kb iq kc kd ke iu kf kg kh iy ki kj kk kl bi translated">请求对象</h2><p id="9242" class="pw-post-body-paragraph if ig hi ih b ii km ik il im kn io ip iq ko is it iu kp iw ix iy kq ja jb jc hb bi translated">请求对象有很多属性，可以补充框架的使用。请求对象具有这些属性(只是其中的一部分)</p><ol class=""><li id="96c2" class="jd je hi ih b ii ij im in iq jf iu jg iy jh jc ji jj jk jl bi translated"><code class="du kr ks kt ku b">request.params</code>:参数中间件</li><li id="398d" class="jd je hi ih b ii jm im jn iq jo iu jp iy jq jc ji jj jk jl bi translated"><code class="du kr ks kt ku b">request.param</code>:提取一个参数</li><li id="4029" class="jd je hi ih b ii jm im jn iq jo iu jp iy jq jc ji jj jk jl bi translated"><code class="du kr ks kt ku b">request.query</code>:提取查询字符串参数</li><li id="1e7e" class="jd je hi ih b ii jm im jn iq jo iu jp iy jq jc ji jj jk jl bi translated"><code class="du kr ks kt ku b">request.route</code>:返回路线字符串</li><li id="28d6" class="jd je hi ih b ii jm im jn iq jo iu jp iy jq jc ji jj jk jl bi translated"><code class="du kr ks kt ku b">request.cookies</code>:cookie，需要<code class="du kr ks kt ku b">cookieParser</code></li><li id="49ee" class="jd je hi ih b ii jm im jn iq jo iu jp iy jq jc ji jj jk jl bi translated"><code class="du kr ks kt ku b">request.signedCookies</code>:已签名的cookies，需要<code class="du kr ks kt ku b">cookieparser</code></li><li id="3037" class="jd je hi ih b ii jm im jn iq jo iu jp iy jq jc ji jj jk jl bi translated"><code class="du kr ks kt ku b">request.body</code>:有效负载，需要主体解析器</li><li id="c22f" class="jd je hi ih b ii jm im jn iq jo iu jp iy jq jc ji jj jk jl bi translated"><code class="du kr ks kt ku b">request.get(headerKey)</code>:表头键值</li><li id="eb5e" class="jd je hi ih b ii jm im jn iq jo iu jp iy jq jc ji jj jk jl bi translated"><code class="du kr ks kt ku b">request.accepts(type)</code>:检查类型是否被接受</li><li id="4014" class="jd je hi ih b ii jm im jn iq jo iu jp iy jq jc ji jj jk jl bi translated"><code class="du kr ks kt ku b">request.acceptsLanguage(language)</code>:检查语言</li><li id="6809" class="jd je hi ih b ii jm im jn iq jo iu jp iy jq jc ji jj jk jl bi translated"><code class="du kr ks kt ku b">request.acceptsCharset(charset)</code>:检查字符集</li><li id="8c28" class="jd je hi ih b ii jm im jn iq jo iu jp iy jq jc ji jj jk jl bi translated"><code class="du kr ks kt ku b">request.is(type)</code>:检查类型</li><li id="21e0" class="jd je hi ih b ii jm im jn iq jo iu jp iy jq jc ji jj jk jl bi translated"><code class="du kr ks kt ku b">request.ip</code> : IP地址</li><li id="15eb" class="jd je hi ih b ii jm im jn iq jo iu jp iy jq jc ji jj jk jl bi translated"><code class="du kr ks kt ku b">request.ips</code> : IP地址(打开<code class="du kr ks kt ku b">trust-proxy</code>)</li><li id="2e69" class="jd je hi ih b ii jm im jn iq jo iu jp iy jq jc ji jj jk jl bi translated"><code class="du kr ks kt ku b">request.path</code> : URL路径</li><li id="b022" class="jd je hi ih b ii jm im jn iq jo iu jp iy jq jc ji jj jk jl bi translated"><code class="du kr ks kt ku b">request.host</code>:没有端口号的主机</li><li id="6baa" class="jd je hi ih b ii jm im jn iq jo iu jp iy jq jc ji jj jk jl bi translated"><code class="du kr ks kt ku b">request.fresh</code>:检查新鲜度</li><li id="d7b3" class="jd je hi ih b ii jm im jn iq jo iu jp iy jq jc ji jj jk jl bi translated"><code class="du kr ks kt ku b">request.stale</code>:检查陈旧性</li><li id="cfa6" class="jd je hi ih b ii jm im jn iq jo iu jp iy jq jc ji jj jk jl bi translated"><code class="du kr ks kt ku b">request.xhr</code>:对于AJAX-y请求为真</li><li id="4392" class="jd je hi ih b ii jm im jn iq jo iu jp iy jq jc ji jj jk jl bi translated"><code class="du kr ks kt ku b">request.secure</code>:检查协议是否为<code class="du kr ks kt ku b">https</code></li><li id="42f7" class="jd je hi ih b ii jm im jn iq jo iu jp iy jq jc ji jj jk jl bi translated"><code class="du kr ks kt ku b">request.subdomains</code>:子域数组</li><li id="a301" class="jd je hi ih b ii jm im jn iq jo iu jp iy jq jc ji jj jk jl bi translated"><code class="du kr ks kt ku b">request.originalUrl</code>:原始网址</li></ol><h2 id="6488" class="jr js hi bd jt ju jv jw jx jy jz ka kb iq kc kd ke iu kf kg kh iy ki kj kk kl bi translated">响应(HTTP响应)</h2><p id="04eb" class="pw-post-body-paragraph if ig hi ih b ii km ik il im kn io ip iq ko is it iu kp iw ix iy kq ja jb jc hb bi translated">响应对象也可以通过Express中的路由处理程序来访问。在将HTTP响应发送给客户端之前，也可以使用response对象来修改HTTP响应。</p><p id="75f7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">以下是一些可以使用的响应属性:</p><ol class=""><li id="cc76" class="jd je hi ih b ii ij im in iq jf iu jg iy jh jc ji jj jk jl bi translated"><code class="du kr ks kt ku b">response.redirect(status, url)</code>:重定向请求</li><li id="38e7" class="jd je hi ih b ii jm im jn iq jo iu jp iy jq jc ji jj jk jl bi translated"><code class="du kr ks kt ku b">response.send(status, data)</code>:发送响应</li><li id="a643" class="jd je hi ih b ii jm im jn iq jo iu jp iy jq jc ji jj jk jl bi translated"><code class="du kr ks kt ku b">response.json(status, data)</code>:发送JSON并强制正确的报头</li><li id="5655" class="jd je hi ih b ii jm im jn iq jo iu jp iy jq jc ji jj jk jl bi translated"><code class="du kr ks kt ku b">response.sendfile(path, options, callback)</code>:发送文件</li><li id="9111" class="jd je hi ih b ii jm im jn iq jo iu jp iy jq jc ji jj jk jl bi translated"><code class="du kr ks kt ku b">response.render(templateName, locals, callback)</code>:渲染一个模板</li><li id="74a3" class="jd je hi ih b ii jm im jn iq jo iu jp iy jq jc ji jj jk jl bi translated"><code class="du kr ks kt ku b">response.locals</code>:将数据传递给模板</li></ol><p id="0e68" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">下面是一个用ExpressJS返回简单字符串消息的例子</p><pre class="kv kw kx ky fd kz ku la lb aw lc bi"><span id="d58b" class="jr js hi ku b fi ld le l lf lg">app.get('/', function(request, response) {<br/>  response.send('Hello world!') // resolved as text/plain<br/>  response.send([6, 8, 9]) // resolved as application/json<br/>  response.send({name: "David"}) // resolved as application/json<br/>})</span></pre><p id="6fe5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">但是<code class="du kr ks kt ku b">response</code>类型可以像这样用<code class="du kr ks kt ku b">response.set</code>硬编码</p><pre class="kv kw kx ky fd kz ku la lb aw lc bi"><span id="1e18" class="jr js hi ku b fi ld le l lf lg">app.get('/', function(request, response) {<br/>  response.set('Content-Type', 'text/plain')<br/>  response.send('Hello world!') // resolved as text/plain<br/>})</span></pre><h2 id="c612" class="jr js hi bd jt ju jv jw jx jy jz ka kb iq kc kd ke iu kf kg kh iy ki kj kk kl bi translated">会议</h2><p id="0af9" class="pw-post-body-paragraph if ig hi ih b ii km ik il im kn io ip iq ko is it iu kp iw ix iy kq ja jb jc hb bi translated">用Express处理用户会话也很容易，它需要<code class="du kr ks kt ku b">cookiesParser</code>中间件</p><p id="ef8c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这里有一个例子</p><pre class="kv kw kx ky fd kz ku la lb aw lc bi"><span id="f61e" class="jr js hi ku b fi ld le l lf lg">app.use(express.cookiesParser())<br/>app.use(express.session({secret: 'weak_secret'}))</span><span id="6ed7" class="jr js hi ku b fi lh le l lf lg">app.get('/', function(request, response) {<br/>  var session = request.session<br/>})</span></pre><h2 id="b977" class="jr js hi bd jt ju jv jw jx jy jz ka kb iq kc kd ke iu kf kg kh iy ki kj kk kl bi translated">Redis会话</h2><p id="99f8" class="pw-post-body-paragraph if ig hi ih b ii km ik il im kn io ip iq ko is it iu kp iw ix iy kq ja jb jc hb bi translated">像这样处理与<a class="ae li" href="https://redis.io/" rel="noopener ugc nofollow" target="_blank"> Redis </a>的会话</p><p id="6ca9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">您将需要安装依赖项:<code class="du kr ks kt ku b">npm install connect-redis express-session</code></p><p id="1083" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">以下是的使用方法</p><pre class="kv kw kx ky fd kz ku la lb aw lc bi"><span id="b248" class="jr js hi ku b fi ld le l lf lg">var session = require('express-session')<br/>var RedisStore = require('connect-redis')(session)</span><span id="ff99" class="jr js hi ku b fi lh le l lf lg">app.use(session({<br/>  store: new RedisStore(options)<br/>  secret: 'keyboard cat'<br/>}))</span></pre><h2 id="4e22" class="jr js hi bd jt ju jv jw jx jy jz ka kb iq kc kd ke iu kf kg kh iy ki kj kk kl bi translated">负载平衡</h2><p id="9826" class="pw-post-body-paragraph if ig hi ih b ii km ik il im kn io ip iq ko is it iu kp iw ix iy kq ja jb jc hb bi translated">根据我的经验，出于负载平衡的需要，我使用了带有<code class="du kr ks kt ku b">Clusters</code>、<code class="du kr ks kt ku b">Nginx</code>、<code class="du kr ks kt ku b">HAProxy</code>和<code class="du kr ks kt ku b">Varnish</code>的ExpressJS，但是我很确定它可以适应其他类似的工具。</p><p id="2df8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">总结一下，ExpressJS提供了很多东西，但也不是唯一可以使用的东西。令人惊叹的框架，包括Sails、Loopback、Meteor、哈比神或Restify，可以成为ExpressJS的替代方案</p><p id="d9b9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">你可以随时参考这个<a class="ae li" href="http://nodeframework.com/" rel="noopener ugc nofollow" target="_blank">站点</a>来找出NodeJs生态系统中还有哪些工具可以使用。</p></div></div>    
</body>
</html>