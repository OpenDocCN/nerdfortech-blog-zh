<html>
<head>
<title>Lets Implement Heap DS:</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">让我们实现堆 DS:</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/lets-implement-heap-ds-2a95a4853552?source=collection_archive---------3-----------------------#2020-12-23">https://medium.com/nerd-for-tech/lets-implement-heap-ds-2a95a4853552?source=collection_archive---------3-----------------------#2020-12-23</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div class="er es if"><img src="../Images/b0e80f95617b96e26cdafecaf2d8e4f0.png" data-original-src="https://miro.medium.com/v2/resize:fit:520/format:webp/1*BVTj_M-iwgd27Cai2J5yBQ.png"/></div></figure><h2 id="3f7f" class="im in hi bd io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj bi translated">简介:</h2><p id="db26" class="pw-post-body-paragraph jk jl hi jm b jn jo jp jq jr js jt ju ix jv jw jx jb jy jz ka jf kb kc kd ke hb bi translated">堆或优先级队列是一回事。于是问题出现了</p><p id="2ffb" class="pw-post-body-paragraph jk jl hi jm b jn kf jp jq jr kg jt ju ix kh jw jx jb ki jz ka jf kj kc kd ke hb bi translated">什么是优先级队列？？</p><p id="2d4b" class="pw-post-body-paragraph jk jl hi jm b jn kf jp jq jr kg jt ju ix kh jw jx jb ki jz ka jf kj kc kd ke hb bi translated">优先级队列是这样一种队列，其中有一个标准，根据该标准，哪些元素被赋予优先级，优先级最高的元素首先被弹出。</p><p id="6ef2" class="pw-post-body-paragraph jk jl hi jm b jn kf jp jq jr kg jt ju ix kh jw jx jb ki jz ka jf kj kc kd ke hb bi translated">那么，为什么我们需要一个优先级队列或堆呢？？</p><p id="b202" class="pw-post-body-paragraph jk jl hi jm b jn kf jp jq jr kg jt ju ix kh jw jx jb ki jz ka jf kj kc kd ke hb bi translated">它主要用于在比其他数据结构更好的时间复杂度下寻找最大或最小元素。</p><p id="6188" class="pw-post-body-paragraph jk jl hi jm b jn kf jp jq jr kg jt ju ix kh jw jx jb ki jz ka jf kj kc kd ke hb bi translated"><strong class="jm hj">什么时候一棵树可以被称为一堆？？</strong></p><p id="4931" class="pw-post-body-paragraph jk jl hi jm b jn kf jp jq jr kg jt ju ix kh jw jx jb ki jz ka jf kj kc kd ke hb bi translated">如果一棵树满足以下三个条件，它就可以被称为堆:</p><ol class=""><li id="f013" class="kk kl hi jm b jn kf jr kg ix km jb kn jf ko ke kp kq kr ks bi translated">该树应该有近 2 个孩子，即它应该是一个<strong class="jm hj">二叉树。</strong></li><li id="2e6f" class="kk kl hi jm b jn kt jr ku ix kv jb kw jf kx ke kp kq kr ks bi translated">它必须是一个<strong class="jm hj">完整的二叉树</strong>，也就是说，除了最后一层可以部分填充之外，所有层都必须完全填充，但是最后一层应该按照从左到右的顺序填充。</li><li id="22ae" class="kk kl hi jm b jn kt jr ku ix kv jb kw jf kx ke kp kq kr ks bi translated">它应该遵循<strong class="jm hj">堆顺序属性</strong>，即要么每个父代都应该大于其子代(最大堆)，要么每个父代都应该小于其子代(最小堆)。</li></ol><p id="2b09" class="pw-post-body-paragraph jk jl hi jm b jn kf jp jq jr kg jt ju ix kh jw jx jb ki jz ka jf kj kc kd ke hb bi translated"><strong class="jm hj">如何从给定的数组构造堆？</strong></p><p id="000a" class="pw-post-body-paragraph jk jl hi jm b jn kf jp jq jr kg jt ju ix kh jw jx jb ki jz ka jf kj kc kd ke hb bi translated">必须谨记以下规则:</p><ol class=""><li id="2888" class="kk kl hi jm b jn kf jr kg ix km jb kn jf ko ke kp kq kr ks bi translated">堆的根在数组的索引 0 处</li><li id="d832" class="kk kl hi jm b jn kt jr ku ix kv jb kw jf kx ke kp kq kr ks bi translated">第 I 个节点的左子节点是(2*i+1)</li><li id="9c79" class="kk kl hi jm b jn kt jr ku ix kv jb kw jf kx ke kp kq kr ks bi translated">第 I 个节点的右子节点是(2*i+2)</li><li id="eb53" class="kk kl hi jm b jn kt jr ku ix kv jb kw jf kx ke kp kq kr ks bi translated">第 I 个节点的父节点是(i-1)/2</li></ol><figure class="kz la lb lc fd ij er es paragraph-image"><div class="er es ky"><img src="../Images/8472cf6a94b3c1fe15e2d834c59fa34a.png" data-original-src="https://miro.medium.com/v2/resize:fit:798/1*iXudelUOGk7XGR_IvT-cpA.gif"/></div><figcaption class="ld le et er es lf lg bd b be z dx translated">图片来源- cse.hut.fi</figcaption></figure><h2 id="8a0b" class="im in hi bd io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj bi translated">使用 stl 实现最小堆和最大堆:</h2><p id="5ed1" class="pw-post-body-paragraph jk jl hi jm b jn jo jp jq jr js jt ju ix jv jw jx jb jy jz ka jf kb kc kd ke hb bi translated"><strong class="jm hj">最大堆</strong>:我们可以使用优先级队列将元素推入其中来实现。默认情况下，它会创建一个最大堆。</p><figure class="kz la lb lc fd ij er es paragraph-image"><div class="er es lh"><img src="../Images/68c67ab684347cb92e9bb447f0f10741.png" data-original-src="https://miro.medium.com/v2/resize:fit:728/format:webp/1*hBxPhC5tr2jVGtKrxrdoHg.jpeg"/></div><figcaption class="ld le et er es lf lg bd b be z dx translated">使用优先级队列的最大堆</figcaption></figure><p id="5eb6" class="pw-post-body-paragraph jk jl hi jm b jn kf jp jq jr kg jt ju ix kh jw jx jb ki jz ka jf kj kc kd ke hb bi translated"><strong class="jm hj">最小堆</strong>:从优先级队列中创建最小堆有两种方法</p><ol class=""><li id="6ac1" class="kk kl hi jm b jn kf jr kg ix km jb kn jf ko ke kp kq kr ks bi translated">除了元素类型，还要传递两个参数，即向量<type>和比较类型</type></li></ol><figure class="kz la lb lc fd ij er es paragraph-image"><div class="er es li"><img src="../Images/4075d7e6cb0a90a09b309709ac328b2e.png" data-original-src="https://miro.medium.com/v2/resize:fit:860/format:webp/1*ZtAsb0KvLRJonUneDM7-sw.jpeg"/></div><figcaption class="ld le et er es lf lg bd b be z dx translated">使用具有多个参数的优先级队列的 Min_heap</figcaption></figure><p id="a427" class="pw-post-body-paragraph jk jl hi jm b jn kf jp jq jr kg jt ju ix kh jw jx jb ki jz ka jf kj kc kd ke hb bi translated">2.只需将它构造成与 max heap 相同，只在将元素乘以-1 后传递它们，并在再次访问它们时乘以-1</p><figure class="kz la lb lc fd ij er es paragraph-image"><div class="er es lj"><img src="../Images/abdbcc16167b5d91c00e0eb10c51cfe9.png" data-original-src="https://miro.medium.com/v2/resize:fit:806/format:webp/1*YBbyqalD8fHZ-ae8i8ssNQ.jpeg"/></div><figcaption class="ld le et er es lf lg bd b be z dx translated">使用带有一个参数的优先级队列的最小堆</figcaption></figure><p id="ad55" class="pw-post-body-paragraph jk jl hi jm b jn kf jp jq jr kg jt ju ix kh jw jx jb ki jz ka jf kj kc kd ke hb bi translated">文章结尾</p><p id="819b" class="pw-post-body-paragraph jk jl hi jm b jn kf jp jq jr kg jt ju ix kh jw jx jb ki jz ka jf kj kc kd ke hb bi translated">编码快乐！！</p><p id="58de" class="pw-post-body-paragraph jk jl hi jm b jn kf jp jq jr kg jt ju ix kh jw jx jb ki jz ka jf kj kc kd ke hb bi translated">谢谢你</p></div></div>    
</body>
</html>