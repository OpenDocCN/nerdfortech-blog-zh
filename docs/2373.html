<html>
<head>
<title>Why did Google &amp; Facebook stop using the traditional network connection?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">为什么谷歌和脸书停止使用传统的网络连接？</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/why-did-google-facebook-stop-using-the-traditional-network-connection-ae936926f1ee?source=collection_archive---------12-----------------------#2021-05-03">https://medium.com/nerd-for-tech/why-did-google-facebook-stop-using-the-traditional-network-connection-ae936926f1ee?source=collection_archive---------12-----------------------#2021-05-03</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="de75" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">随着用户群的增加，google 需要一个高效的方法来处理这些请求。在我们回答为什么 google 停止使用 TCP 连接之前，让我们先了解一下基本的。</p><h1 id="ccef" class="jd je hi bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">协议层</h1><figure class="kc kd ke kf fd kg er es paragraph-image"><div role="button" tabindex="0" class="kh ki di kj bf kk"><div class="er es kb"><img src="../Images/de0273980f726d53131e037e66513c09.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*lbXUPJxYKlvCdRhq.jpg"/></div></div><figcaption class="kn ko et er es kp kq bd b be z dx translated">协议层</figcaption></figure><p id="e61a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">可以参考上图。协议层有 4 层，让我们详细了解每一层。</p><h2 id="3b37" class="kr je hi bd jf ks kt ku jj kv kw kx jn iq ky kz jr iu la lb jv iy lc ld jz le bi translated">网络接入层:</h2><p id="e4fd" class="pw-post-body-paragraph if ig hi ih b ii lf ik il im lg io ip iq lh is it iu li iw ix iy lj ja jb jc hb bi translated">这是协议层中的最底层。这一层为系统提供了向直连网络中的其它设备传送数据的方法。</p><h2 id="fb48" class="kr je hi bd jf ks kt ku jj kv kw kx jn iq ky kz jr iu la lb jv iy lc ld jz le bi translated">互联网层:</h2><p id="fa0c" class="pw-post-body-paragraph if ig hi ih b ii lf ik il im lg io ip iq lh is it iu li iw ix iy lj ja jb jc hb bi translated">这一层有一个 internet 协议，为网络上的计算机提供识别和定位系统，并在 Internet 上路由流量。</p><h2 id="4050" class="kr je hi bd jf ks kt ku jj kv kw kx jn iq ky kz jr iu la lb jv iy lc ld jz le bi translated">传输层:</h2><p id="14c4" class="pw-post-body-paragraph if ig hi ih b ii lf ik il im lg io ip iq lh is it iu li iw ix iy lj ja jb jc hb bi translated">传输层直接为运行在不同主机上的应用程序进程提供通信服务。这里我们有两种类型的协议 TCP 和 UDP。</p><ul class=""><li id="62fb" class="lk ll hi ih b ii ij im in iq lm iu ln iy lo jc lp lq lr ls bi translated"><strong class="ih hj"> TCP: </strong>这是遵循三次握手原则的协议。在这种情况下，客户端向服务器发送一个请求，服务器发送一个响应，之后客户端再次发送一个确认，表示它已经收到了响应。如果服务器没有从客户端得到确认，那么它将再次发送响应，因为它将认为客户端没有收到响应。</li><li id="9855" class="lk ll hi ih b ii lt im lu iq lv iu lw iy lx jc lp lq lr ls bi translated"><strong class="ih hj"> UDP: </strong>在这个协议中，客户端建立连接并发送请求，服务器发送响应。响应可以在多个分段中发送。客户端没有发送收到响应的确认。所以服务器不关心客户端是否得到响应，它只是发送响应。</li></ul><figure class="kc kd ke kf fd kg er es paragraph-image"><div class="er es ly"><img src="../Images/3cce6cc39b1f7db71891fbc543bbff0e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1218/format:webp/0*7v7pnvKLW6wwGRwQ.jpg"/></div></figure><h2 id="452c" class="kr je hi bd jf ks kt ku jj kv kw kx jn iq ky kz jr iu la lb jv iy lc ld jz le bi translated">应用层</h2><p id="ae26" class="pw-post-body-paragraph if ig hi ih b ii lf ik il im lg io ip iq lh is it iu li iw ix iy lj ja jb jc hb bi translated">应用层是指定通信网络中的主机所使用的共享通信协议和接口方法的抽象层。</p><h1 id="46f4" class="jd je hi bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated"><strong class="ak">了解 HTTP </strong></h1><p id="89e7" class="pw-post-body-paragraph if ig hi ih b ii lf ik il im lg io ip iq lh is it iu li iw ix iy lj ja jb jc hb bi translated">现在您对网络层有了一个基本的概念，现在让我们看看 HTTP1.1 和 HTTP2 之间有什么区别。这是应用层的一部分。HTTP 协议用于传输超媒体文档，如 HTML。它旨在使网络浏览器和网络服务器之间的通信成为可能。</p><h2 id="d9b0" class="kr je hi bd jf ks kt ku jj kv kw kx jn iq ky kz jr iu la lb jv iy lc ld jz le bi translated">HTTP 1.1 与 HTTP 2</h2><p id="23af" class="pw-post-body-paragraph if ig hi ih b ii lf ik il im lg io ip iq lh is it iu li iw ix iy lj ja jb jc hb bi translated">在 HTTP 1.1 协议中，为每个请求调用建立一个 TCP 连接。而在 HTTP 2 中，协议作为一个流工作，它建立一个 TCP 连接，在这个连接中，多个请求和响应由客户机发送和接收。</p><figure class="kc kd ke kf fd kg er es paragraph-image"><div role="button" tabindex="0" class="kh ki di kj bf kk"><div class="er es lz"><img src="../Images/8fe3f6d1df63b21769c140a0a653308b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*90iYXmagdZd1E-me.png"/></div></div></figure><h2 id="1c67" class="kr je hi bd jf ks kt ku jj kv kw kx jn iq ky kz jr iu la lb jv iy lc ld jz le bi translated">为什么是 HTTP 2？</h2><p id="00eb" class="pw-post-body-paragraph if ig hi ih b ii lf ik il im lg io ip iq lh is it iu li iw ix iy lj ja jb jc hb bi translated">在 HTTP 1.1 中，对于每个请求调用，都会建立一个连接。假设一个网站有 100 万用户，对于一个特定的页面，有 20 个请求调用需求。如果所有 100 万用户同时打开该页面，则需要同时建立 2000 万个连接。这可能导致拒绝服务攻击。</p><p id="dd16" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">因此，为了防止这种情况，浏览器将请求限制为一次 6 个请求调用，这意味着浏览器每次可以为每个打开的页面建立 6 个连接。如果任何连接被关闭，那么只会建立一个新的连接。</p><p id="c676" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">使用单个连接中的 HTTP2，可以同时发送多个请求。这意味着在单个连接中，我可以同时执行 20 个请求呼叫。因为这个页面也将在更短的时间内加载。</p><h2 id="f250" class="kr je hi bd jf ks kt ku jj kv kw kx jn iq ky kz jr iu la lb jv iy lc ld jz le bi translated">HTTP 2 的缺点</h2><p id="c106" class="pw-post-body-paragraph if ig hi ih b ii lf ik il im lg io ip iq lh is it iu li iw ix iy lj ja jb jc hb bi translated">由于 HTTP 2 使用了流的概念，一个问题是如果客户端没有收到对特定请求的响应，客户端将不会再次调用该请求。</p><h2 id="684a" class="kr je hi bd jf ks kt ku jj kv kw kx jn iq ky kz jr iu la lb jv iy lc ld jz le bi translated">HTTP 3</h2><p id="117f" class="pw-post-body-paragraph if ig hi ih b ii lf ik il im lg io ip iq lh is it iu li iw ix iy lj ja jb jc hb bi translated">转折来了，HTTP 3 是在 QUIC 上实现的。QUIC 是 Google 设计的一个协议，它充分利用了 TCP+TLS 的优点，优化了 HTTP 协议的性能。</p><figure class="kc kd ke kf fd kg er es paragraph-image"><div role="button" tabindex="0" class="kh ki di kj bf kk"><div class="er es ma"><img src="../Images/4dc88cd453eb16cbdd39449f493ea79b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*Fjxz2j6Sf2E2RZEG.png"/></div></div></figure><p id="9402" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">TCP + TLS 连接需要大约 6 次往返。另一方面，UDP 上的 QUIC 大约需要 1-2 次往返。QUIC 包括丢失控制、拥塞反馈。</p><p id="eff4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">但是由于 QUIC 是在 UDP 上实现的，你可能会在前面的点上有所劣势，如果一个包丢失了，那么它就丢失了。</p><p id="6b0a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">QUIC 还有一个特性，它不在客户机和服务器之间建立连接，而是在客户机 IP: port 和服务器 IP: port 之间建立连接。QUIC 连接独立于 IPs 的 UUID。这样做的好处是，你可以切换你的互联网连接而不会丢失数据，并且连接可以保持有效。</p><p id="ec8c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">TLS 用于加密目的。它有助于加密和解密包。</p><h2 id="b198" class="kr je hi bd jf ks kt ku jj kv kw kx jn iq ky kz jr iu la lb jv iy lc ld jz le bi translated">结论</h2><p id="21ac" class="pw-post-body-paragraph if ig hi ih b ii lf ik il im lg io ip iq lh is it iu li iw ix iy lj ja jb jc hb bi translated">谷歌和脸书转而使用 QUIC，与传统的 HTTP 连接协议相比，QUIC 更优化，速度更快，带宽更大。这自动降低了处理成本并改善了用户的性能体验。</p></div></div>    
</body>
</html>