<html>
<head>
<title>Logging Made Easy</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">伐木变得容易</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/logging-made-easy-30bd10effa65?source=collection_archive---------1-----------------------#2021-02-17">https://medium.com/nerd-for-tech/logging-made-easy-30bd10effa65?source=collection_archive---------1-----------------------#2021-02-17</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="718f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">日志已经成为任何应用程序不可或缺的一部分，无论是web服务还是独立的应用程序。适当的日志语句是调试器和程序员的金矿，他们会研究由其他开发人员开发的代码。</p><p id="82f1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">有许多使用日志的情况，但是日志的主要用途如下:</p><ul class=""><li id="6baf" class="jd je hi ih b ii ij im in iq jf iu jg iy jh jc ji jj jk jl bi translated">它有助于跟踪错误，从而节省了修复错误的时间。</li><li id="b460" class="jd je hi ih b ii jm im jn iq jo iu jp iy jq jc ji jj jk jl bi translated">当一个程序突然终止时(这不是一个理想的用例，但还是会发生！)，基于日志语句，我们可以看到在应用程序关闭之前执行了哪个方法或类。</li><li id="bc11" class="jd je hi ih b ii jm im jn iq jo iu jp iy jq jc ji jj jk jl bi translated">通过记录处理整个方法所需的时间来分析任何方法的性能。</li></ul><p id="3422" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">错误日志是最常用的日志，它们大多写在catch块中。这些包含导致应用程序终止的错误消息。</p><p id="56f9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在对于场景<strong class="ih hj">二</strong>和<strong class="ih hj">三</strong>开发人员通常在方法/块的开始写一个日志语句，然后在方法结束时结束。这个过程对类中出现的几乎所有方法都重复。如果我说我们使用Spring AOP(<strong class="ih hj">A</strong>SPECT<strong class="ih hj">O</strong>oriented<strong class="ih hj">P</strong>programming)有一个更简单的解决方案呢？。</p><p id="e250" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="jr"> Spring的面向方面编程</em>提供了一种简单的方法来包装方法或类的功能，从而充当拦截器(为了便于解释，我们称之为拦截器)，它在方法执行之前/之后实现自己。</p><figure class="jt ju jv jw fd jx er es paragraph-image"><div role="button" tabindex="0" class="jy jz di ka bf kb"><div class="er es js"><img src="../Images/0dd2f19ab68d841207a02fec3fa2bd55.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*suJ8giKdjW4adfGG.jpg"/></div></div><figcaption class="ke kf et er es kg kh bd b be z dx translated">Spring AOP术语</figcaption></figure><ul class=""><li id="1a6a" class="jd je hi ih b ii ij im in iq jf iu jg iy jh jc ji jj jk jl bi translated"><strong class="ih hj">建议</strong>——指拦截器需要实现的功能</li><li id="0758" class="jd je hi ih b ii jm im jn iq jo iu jp iy jq jc ji jj jk jl bi translated"><strong class="ih hj">点截</strong>——指拦截器需要被调用的点。</li><li id="3091" class="jd je hi ih b ii jm im jn iq jo iu jp iy jq jc ji jj jk jl bi translated"><strong class="ih hj">连接点</strong>——指特定方法或逻辑的执行发生变化的点。从而充当两个不同执行之间的连接点，因此命名为“连接点”。</li></ul><p id="7f35" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">所以现在让我们实现一个简单的Spring Boot Web服务，它使用AOP创建用户定义的注释来打印带有和不带有方法参数的入口/出口日志程序。</p></div><div class="ab cl ki kj gp kk" role="separator"><span class="kl bw bk km kn ko"/><span class="kl bw bk km kn ko"/><span class="kl bw bk km kn"/></div><div class="hb hc hd he hf"><blockquote class="kp kq kr"><p id="ab25" class="if ig jr ih b ii ij ik il im in io ip ks ir is it kt iv iw ix ku iz ja jb jc hb bi translated"><strong class="ih hj"> <em class="hi">第一步</em> </strong></p></blockquote><p id="6f0b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">首先，我们需要添加AOP依赖。我使用的是Gradle项目，相应的依赖关系可以在网上找到<a class="ae kv" href="https://mvnrepository.com/artifact/org.springframework.boot/spring-boot-starter-aop/2.2.6.RELEASE" rel="noopener ugc nofollow" target="_blank">这里</a></p><blockquote class="kp kq kr"><p id="5330" class="if ig jr ih b ii ij ik il im in io ip ks ir is it kt iv iw ix ku iz ja jb jc hb bi translated"><strong class="ih hj"> <em class="hi">第二步</em> </strong></p></blockquote><pre class="jt ju jv jw fd kw kx ky kz aw la bi"><span id="092a" class="lb lc hi kx b fi ld le l lf lg">@Target(ElementType.<em class="jr">METHOD</em>)<br/>@Retention(RetentionPolicy.<em class="jr">RUNTIME</em>)<br/>public @interface SimpleLogger {<br/>}</span></pre><ul class=""><li id="2f26" class="jd je hi ih b ii ij im in iq jf iu jg iy jh jc ji jj jk jl bi translated">我们需要定义一个用户定义的注释。</li><li id="bd6b" class="jd je hi ih b ii jm im jn iq jo iu jp iy jq jc ji jj jk jl bi translated">使用这个注释，我们可以指定哪个方法需要一个入口/出口记录器。</li></ul><blockquote class="kp kq kr"><p id="d1c4" class="if ig jr ih b ii ij ik il im in io ip ks ir is it kt iv iw ix ku iz ja jb jc hb bi translated"><strong class="ih hj"> <em class="hi">第三步</em> </strong></p></blockquote><pre class="jt ju jv jw fd kw kx ky kz aw la bi"><span id="0a30" class="lb lc hi kx b fi ld le l lf lg">@Around("@annotation(com.medium.example.logger.SimpleLogger)")<br/>public Object entryExitLog(ProceedingJoinPoint proceedingJoinPoint) throws Throwable {<br/>    final Logger logger = LoggerFactory.<em class="jr">getLogger</em>(ServiceAspect.class.getName());<br/>    logger.info("&gt;&gt;&gt; Enter {} {} ", proceedingJoinPoint.getSignature().getDeclaringTypeName(), proceedingJoinPoint.getSignature().getName());<br/>    Object proceed = proceedingJoinPoint.proceed();<br/>    logger.info("&lt;&lt;&lt; Exit {} {} ", proceedingJoinPoint.getSignature().getDeclaringTypeName(), proceedingJoinPoint.getSignature().getName());<br/>    return proceed;<br/>}</span></pre><ul class=""><li id="27ae" class="jd je hi ih b ii ij im in iq jf iu jg iy jh jc ji jj jk jl bi translated">定义建议。这是指使用上面创建的注释时需要实现的逻辑</li><li id="8a5a" class="jd je hi ih b ii jm im jn iq jo iu jp iy jq jc ji jj jk jl bi translated"><em class="jr"> '@Around' </em>这里意味着我们需要在方法(将由<em class="jr"> simpleLogger注释)、</em>执行开始时和方法执行结束前实现逻辑。因而<em class="jr">围绕</em>这个方法展开。</li><li id="6c2f" class="jd je hi ih b ii jm im jn iq jo iu jp iy jq jc ji jj jk jl bi translated">类似地，也实现了<em class="jr">参数化记录器</em>的逻辑。除了入口/出口记录器之外，这将打印传递给该方法的参数。</li><li id="83ed" class="jd je hi ih b ii jm im jn iq jo iu jp iy jq jc ji jj jk jl bi translated"><em class="jr"> proceedingJoinPoint </em>对象包含已被注释的方法的细节，因此我们可以从<em class="jr"> proceedingJoinPoint中存在的<em class="jr">签名对象</em>中导出类名(getDeclaringTypeName)和方法名(getName())。</em></li><li id="8fe4" class="jd je hi ih b ii jm im jn iq jo iu jp iy jq jc ji jj jk jl bi translated">带注释的方法的方法参数也可以从<em class="jr"> proceedingJoinPoint对象中提取。</em></li></ul><blockquote class="kp kq kr"><p id="3c85" class="if ig jr ih b ii ij ik il im in io ip ks ir is it kt iv iw ix ku iz ja jb jc hb bi translated"><strong class="ih hj"> <em class="hi">第四步</em> </strong></p></blockquote><pre class="jt ju jv jw fd kw kx ky kz aw la bi"><span id="d229" class="lb lc hi kx b fi ld le l lf lg">@Service<br/>public class LoggerService {<br/><br/>    @SimpleLogger<br/>    public void simpleLogging(){<br/><br/>    }<br/><br/>    @ParameterisedLogger<br/>    public String parameterisedLogging(String name) {<br/>        return "Hello "+name;<br/>    }<br/>}</span></pre><ul class=""><li id="a075" class="jd je hi ih b ii ij im in iq jf iu jg iy jh jc ji jj jk jl bi translated">我们使用自己创建的注释来注释这些方法。</li><li id="b365" class="jd je hi ih b ii jm im jn iq jo iu jp iy jq jc ji jj jk jl bi translated">这里我们有一个简单的服务类，它没有自己的日志记录语句，只有注释。</li></ul><blockquote class="kp kq kr"><p id="bda5" class="if ig jr ih b ii ij ik il im in io ip ks ir is it kt iv iw ix ku iz ja jb jc hb bi translated">R <strong class="ih hj"> <em class="hi">结果</em> </strong></p></blockquote><pre class="jt ju jv jw fd kw kx ky kz aw la bi"><span id="d499" class="lb lc hi kx b fi ld le l lf lg">&gt;&gt;&gt; Enter com.medium.example.service.LoggerService simpleLogging<br/>&lt;&lt;&lt; Exit com.medium.example.service.LoggerService simpleLogging<br/>&gt;&gt;&gt; Enter com.medium.example.service.LoggerService parameterisedLogging with parameters [medium]<br/>&lt;&lt;&lt; Exit com.medium.example.service.LoggerService parameterisedLogging</span></pre><ul class=""><li id="77bc" class="jd je hi ih b ii ij im in iq jf iu jg iy jh jc ji jj jk jl bi translated">可以看到，我们为服务打印了日志记录语句。</li><li id="2539" class="jd je hi ih b ii jm im jn iq jo iu jp iy jq jc ji jj jk jl bi translated">简单日志记录器和参数化日志记录器都是可见的，并且作为入口/出口日志记录器工作，服务中不存在任何日志记录器语句。</li></ul></div><div class="ab cl ki kj gp kk" role="separator"><span class="kl bw bk km kn ko"/><span class="kl bw bk km kn ko"/><span class="kl bw bk km kn"/></div><div class="hb hc hd he hf"><blockquote class="kp kq kr"><p id="7fe9" class="if ig jr ih b ii ij ik il im in io ip ks ir is it kt iv iw ix ku iz ja jb jc hb bi translated">C <strong class="ih hj"> <em class="hi">结论</em> </strong></p></blockquote><p id="af0f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">因此，我们可以通过定义简单的注释来处理入口/出口日志，从而非常容易地减少代码行。这不仅会增强代码的可读性，还会提高效率，因为我们不需要在每个类中声明logger对象。</p><p id="27d9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">类似地，我们可以使用相同的概念来分析该方法的性能。我们可以声明一个单独的注释，并用它加入一个通知。因此，无论什么时候需要，我们都可以为我们想要的任何方法使用那个性能注释。</p></div></div>    
</body>
</html>