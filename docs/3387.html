<html>
<head>
<title>Microservices (Part 4) — Design Patterns for Microservices (Circuit Breaker Pattern)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">微服务(第 4 部分)——微服务的设计模式(断路器模式)</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/microservices-part-4-design-patterns-for-microservices-circuit-breaker-pattern-5456efafba48?source=collection_archive---------7-----------------------#2021-06-08">https://medium.com/nerd-for-tech/microservices-part-4-design-patterns-for-microservices-circuit-breaker-pattern-5456efafba48?source=collection_archive---------7-----------------------#2021-06-08</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/d38402bc3f69c08e2bcf53184e1ed80e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HT4aQBB4fpv_ZQXlc2iR3Q.jpeg"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">图 1:断路器(来源:谷歌)</figcaption></figure><p id="245e" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">断路器模式是微服务架构中使用的另一种流行的设计模式。这种模式属于可持续设计模式的范畴。这意味着它有助于保持一个特定的服务不出现故障。可用性是微服务架构中的一个关键因素。因此，实现一种克服这些故障的方法是很重要的。</p><p id="f75a" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">想想微服务架构。系统中不同的服务之间有许多远程调用。与内存中的调用不同，这些远程调用在给定的实例中很有可能失败。这些故障可能是由于网络问题、超时等原因造成的。还可能有意外事件导致的故障，这些故障的修复时间会很长。有时这些服务可能会完全失败。</p><p id="c555" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">在这种情况下，<strong class="iw hj">请求服务应该接受这些失败并继续前进，而不需要等待特定的服务</strong>。</p><p id="f49b" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">有时，这些故障可能会传播并导致级联故障。</p><h1 id="6f92" class="js jt hi bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">连锁故障</h1><blockquote class="kq"><p id="c7ac" class="kr ks hi bd kt ku kv kw kx ky kz jr dx translated"><strong class="ak"> <em class="la">一个由相互关联的部分组成的系统中的一个过程，其中一个或几个部分的故障可以触发其他部分的故障，以此类推。</em> </strong></p><p id="40d5" class="kr ks hi bd kt ku kv kw kx ky kz jr dx translated"><strong class="ak"><em class="la">-维基百科</em> </strong></p></blockquote><p id="1817" class="pw-post-body-paragraph iu iv hi iw b ix lb iz ja jb lc jd je jf ld jh ji jj le jl jm jn lf jp jq jr hb bi translated">示例:</p><p id="0dca" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">考虑这样一种情况，服务 A 调用服务 B，但是服务 B 不能正常工作。现在，调用服务将等待超时，并发回一个响应，说它不可用。这没关系，因为这只是一个请求。</p><p id="66b1" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw hj">如果 B 是高要求服务怎么办？</strong></p><p id="5e47" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">服务 B 将接收大量请求。那么这个实现将导致这些并发请求被阻塞，直到超时。这会导致级联故障。</p><p id="0cd8" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw hj">为什么这是危险的？</strong></p><p id="4453" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">这些被阻塞的请求可能占用宝贵的系统资源，如线程、内存等。这可能会导致系统的其他部分出现故障。这就是为什么微服务总是遵循“<strong class="iw hj">快速失败、无声失败、回退”</strong>原则。</p><h1 id="7450" class="js jt hi bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">解决办法</h1><h2 id="5eba" class="lg jt hi bd ju lh li lj jy lk ll lm kc jf ln lo kg jj lp lq kk jn lr ls ko lt bi translated">断路器模式</h2><ul class=""><li id="b248" class="lu lv hi iw b ix lw jb lx jf ly jj lz jn ma jr mb mc md me bi translated">这是克服上述问题的有用模式。它将确保服务不会重复尝试执行可能失败的操作。使用预定义的阈值(通常为 75%)。</li></ul><p id="e0d8" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw hj">如果特定服务的失败次数超过给定阈值，请求服务将不会尝试命中失败的服务。相反，它将故障回复给消费者，并通知该特定服务不可用。</strong></p><p id="5e34" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">然后，到达特定服务的后续请求将会自动回复，而不会等待。这个过程类似于房子的断路器，因此得名。</p><ul class=""><li id="387c" class="lu lv hi iw b ix iy jb jc jf mf jj mg jn mh jr mb mc md me bi translated">Ping 请求用于检查响应时间。一旦响应时间恢复正常，电路将被接通。</li></ul><p id="0efc" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">这个断路器基本上充当在不久的将来有可能失败的服务的代理。这意味着它将基本上跟踪失败服务的数量，并使用该信息来做出决定(要么继续，要么拒绝)。有 3 种主要状态。</p><figure class="mj mk ml mm fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mi"><img src="../Images/57fe4960e4507c60f0771a729d484c21.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bQjhe5cqzya0WQajKWURRQ.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">图 2:断路器状态</figcaption></figure><p id="15e7" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw hj"> 1。关闭</strong></p><p id="6cf0" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">代理将请求路由到服务，并查看操作的状态。它跟踪最近的故障。如果特定请求不成功，它将把不成功计数加 1。</p><p id="927b" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">如果最近不成功计数的数量超过阈值水平，代理将进入<strong class="iw hj">打开</strong>状态，并且还将启动超时定时器。当超时结束时，它将进入<strong class="iw hj">半开</strong>状态。</p><p id="677c" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw hj"> 2。打开</strong></p><p id="f06b" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">通过抛出异常，请求将立即失败。</p><p id="be61" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw hj"> 3。半开</strong></p><p id="0101" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">有限数量的请求将被路由到该服务。如果成功，代理的状态将变为<strong class="iw hj">关闭</strong>。不成功的计数也将变为 0。如果请求失败，状态将变为<strong class="iw hj">打开</strong>。</p><p id="c9a7" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">考虑这样一种情况，服务试图从失败的实例中缓慢恢复。此恢复服务可能无法同时支持大量请求，因为它仍在恢复中。这种半开状态有助于避免对此服务的请求泛滥。</p><p id="791f" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">本文的下一部分阐述了另一种广泛使用的设计模式，称为代理模式。我使用了 Krishntha Dinesh 先生的以下播放列表来收集所需的信息。</p><figure class="mj mk ml mm fd ij"><div class="bz dy l di"><div class="mo mp l"/></div></figure></div><div class="ab cl mq mr gp ms" role="separator"><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv"/></div><div class="hb hc hd he hf"><h1 id="89ff" class="js jt hi bd ju jv mx jx jy jz my kb kc kd mz kf kg kh na kj kk kl nb kn ko kp bi translated">参考</h1><div class="nc nd ez fb ne nf"><a href="https://martinfowler.com/bliki/CircuitBreaker.html#:~:text=You%20wrap%20a%20protected%20function,call%20being%20made%20at%20all" rel="noopener  ugc nofollow" target="_blank"><div class="ng ab dw"><div class="nh ab ni cl cj nj"><h2 class="bd hj fi z dy nk ea eb nl ed ef hh bi translated">断路器</h2><div class="nm l"><h3 class="bd b fi z dy nk ea eb nl ed ef dx translated">软件系统对运行在不同进程中的软件进行远程调用是很常见的，可能是在不同的…</h3></div><div class="nn l"><p class="bd b fp z dy nk ea eb nl ed ef dx translated">martinfowler.com</p></div></div><div class="no l"><div class="np l nq nr ns no nt io nf"/></div></div></a></div><div class="nc nd ez fb ne nf"><a href="https://en.wikipedia.org/wiki/Cascading_failure#:~:text=A%20cascading%20failure%20is%20a,other%20parts%20and%20so%20on" rel="noopener  ugc nofollow" target="_blank"><div class="ng ab dw"><div class="nh ab ni cl cj nj"><h2 class="bd hj fi z dy nk ea eb nl ed ef hh bi translated">级联故障-维基百科</h2><div class="nm l"><h3 class="bd b fi z dy nk ea eb nl ed ef dx translated">连锁故障是一个相互关联的部件系统中的一个过程，其中一个或几个部件的故障会导致…</h3></div><div class="nn l"><p class="bd b fp z dy nk ea eb nl ed ef dx translated">en.wikipedia.org</p></div></div><div class="no l"><div class="nu l nq nr ns no nt io nf"/></div></div></a></div></div></div>    
</body>
</html>