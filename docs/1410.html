<html>
<head>
<title>Understanding “this” binding in Javascript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">理解Javascript中的“this”绑定</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/understanding-this-binding-in-javascript-86687397c76d?source=collection_archive---------7-----------------------#2021-03-17">https://medium.com/nerd-for-tech/understanding-this-binding-in-javascript-86687397c76d?source=collection_archive---------7-----------------------#2021-03-17</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="147e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为了清楚地理解“this”关键字，我们首先需要了解执行上下文是如何工作的。每次运行Javascript代码时，引擎都会创建一个全局执行上下文。每次调用一个函数时，都会为该函数创建一个全新的本地执行上下文。每个函数都有自己的执行上下文，但是它是在调用函数时创建的。一个程序中只能有一个全局执行上下文，可以有任意数量的局部执行上下文。</p><p id="f992" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">执行上下文是什么样子的？</strong></p><p id="f7b7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">执行上下文在创建阶段创建。在创建阶段会发生以下事情:</p><ol class=""><li id="6ac7" class="jd je hi ih b ii ij im in iq jf iu jg iy jh jc ji jj jk jl bi translated">创建词汇环境组件。</li><li id="fb3c" class="jd je hi ih b ii jm im jn iq jo iu jp iy jq jc ji jj jk jl bi translated">VariableEnvironment组件已创建。</li></ol><p id="f973" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">词法环境是什么样子的？</strong></p><p id="9c4a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们看下面的例子来理解词汇环境:</p><pre class="jr js jt ju fd jv jw jx jy aw jz bi"><span id="4009" class="ka kb hi jw b fi kc kd l ke kf">const person = {<br/>  name: 'yasemin',<br/>  birthYear: 1991,<br/>  calcAge: function() {<br/>    console.log(2018 - this.birthYear);<br/>  }<br/>}<br/>person.calcAge();<br/>const calculateAge = person.calcAge;<br/>calculateAge(); </span></pre><p id="44e1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">下面的代码片段展示了词法环境在概念上的样子。</p><pre class="jr js jt ju fd jv jw jx jy aw jz bi"><span id="01d8" class="ka kb hi jw b fi kc kd l ke kf">GlobalExecutionContext = {<br/>  LexicalEnvironment: {<br/>    EnvironmentRecord: {<br/>      Type: "Object",<br/>      // Identifier bindings go here<br/>    }<br/>    outer: &lt; null &gt;,<br/>    this: &lt; global object &gt;<br/>  }<br/>}<br/>FunctionExecutionContext = {<br/>   LexicalEnvironment: {<br/>      EnvironmentRecord: {<br/>        Type: "Declarative",<br/>        // Identifier bindings go here<br/>      }<br/>      outer: &lt; Global or outer function environment reference&gt;,<br/>      this: depends on how function is called<br/>    }<br/>}</span></pre><p id="be24" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">正如您在上面的例子中看到的，每个词汇环境都有三个组成部分:</p><ol class=""><li id="d8f0" class="jd je hi ih b ii ij im in iq jf iu jg iy jh jc ji jj jk jl bi translated">环境记录</li><li id="ee65" class="jd je hi ih b ii jm im jn iq jo iu jp iy jq jc ji jj jk jl bi translated">参考外部环境，</li><li id="6abf" class="jd je hi ih b ii jm im jn iq jo iu jp iy jq jc ji jj jk jl bi translated"><strong class="ih hj">本绑定</strong></li></ol><p id="6b31" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在这篇文章中，我们将解决“这个”绑定。</p></div><div class="ab cl kg kh gp ki" role="separator"><span class="kj bw bk kk kl km"/><span class="kj bw bk kk kl km"/><span class="kj bw bk kk kl"/></div><div class="hb hc hd he hf"><p id="b826" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">什么是“这个”绑定？</strong></p><p id="965b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">正如您在上面的示例中看到的，“this”绑定是执行上下文(全局、函数或eval)的一个属性。它的行为取决于执行上下文。</p><p id="004f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">全局执行上下文:</strong></p><ul class=""><li id="9820" class="jd je hi ih b ii ij im in iq jf iu jg iy jh jc kn jj jk jl bi translated">在全局执行上下文中，“this”的值指的是全局对象。(在浏览器中，这是指窗口对象)。</li></ul><p id="ee66" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">功能执行上下文:</strong></p><ul class=""><li id="8907" class="jd je hi ih b ii ij im in iq jf iu jg iy jh jc kn jj jk jl bi translated">在函数执行上下文中，“this”的值取决于如何调用函数。每个函数调用都定义了自己的上下文，因此,“this”的行为可能与您预期的不同。</li></ul><p id="c296" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在javascript中，有很多方法可以调用函数。让我们看看它们是什么。</p><p id="e1a8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">默认绑定:</strong></p><p id="ec17" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果不使用任何其他类型的绑定，就会发生默认绑定。如果我们调用任何只有括号的函数，我们将得到默认绑定。它以不同的方式表现“严格”模式。</p><p id="038d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在非严格模式下，如下调用函数时，<code class="du ko kp kq jw b">this</code>引用全局对象:</p><pre class="jr js jt ju fd jv jw jx jy aw jz bi"><span id="a5ad" class="ka kb hi jw b fi kc kd l ke kf">function show() {   <br/> console.log(this === window); <em class="kr">// true<br/></em>}  <br/>show();</span></pre><p id="6c1a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在严格模式下，Javascript将<code class="du ko kp kq jw b">this</code>设置为<code class="du ko kp kq jw b">undefined</code>。请注意，从ECMAScript 5.1开始，严格模式就可用了。<code class="du ko kp kq jw b">strict</code>模式适用于函数和函数内的内部函数。</p><pre class="jr js jt ju fd jv jw jx jy aw jz bi"><span id="561b" class="ka kb hi jw b fi kc kd l ke kf">function show() {  <br/>   "use strict";  <br/>   console.log(this === undefined); <em class="kr">// true</em>    <br/>   function display() {    <br/>      console.log(this === undefined); <em class="kr">// true</em>   <br/>   }   <br/>   bar();<br/> } <br/> show();</span></pre><p id="9996" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">隐式绑定:</strong></p><p id="c4ed" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">隐式绑定是在调用带有“.”的函数时发生的情况在它之前。换句话说，它在调用一个对象的方法。</p><pre class="jr js jt ju fd jv jw jx jy aw jz bi"><span id="ed63" class="ka kb hi jw b fi kc kd l ke kf">const obj = {<br/>  foo: function() {<br/>    console.log(this); // {foo: f}<!-- --> which is basically <!-- -->obj<!-- -->.<br/>  },<br/>};<br/><br/>obj.foo();</span></pre><p id="7f29" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">你也可以把它存储在一个变量中，通过变量调用这个方法。</p><pre class="jr js jt ju fd jv jw jx jy aw jz bi"><span id="d31f" class="ka kb hi jw b fi kc kd l ke kf">const obj = {<br/>  name: 'Obj',  <br/>  foo: function() {<br/>    console.log(this.name); // undefined<br/>  },<br/>};<br/><br/>const newObj = obj.foo();<br/>newObj.foo()</span></pre><p id="38ed" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">它记录了<code class="du ko kp kq jw b">undefined</code>,因为当你调用一个方法而没有指定它的对象时，JavaScript在非严格模式下将<code class="du ko kp kq jw b">this</code>设置为全局对象，在严格模式下将<code class="du ko kp kq jw b">undefined</code>设置为全局对象。</p><p id="c6e3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">注意:要解决这个问题，您可以使用<code class="du ko kp kq jw b">bind</code>方法。我们稍后会看一看它。</p><p id="dd8f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">新绑定:</strong></p><p id="553f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">新绑定是当你使用<code class="du ko kp kq jw b">new</code>关键字创建一个函数对象的实例时发生的事情，你使用函数作为构造函数。调用函数时可以使用<code class="du ko kp kq jw b">new</code>，比如:<code class="du ko kp kq jw b">new foo()</code></p><p id="c967" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><code class="du ko kp kq jw b">new</code>做4件事:</p><ol class=""><li id="1e3a" class="jd je hi ih b ii ij im in iq jf iu jg iy jh jc ji jj jk jl bi translated">它创建一个新的空对象。</li><li id="19d3" class="jd je hi ih b ii jm im jn iq jo iu jp iy jq jc ji jj jk jl bi translated">它使<code class="du ko kp kq jw b">this</code>成为新的对象。</li><li id="cee7" class="jd je hi ih b ii jm im jn iq jo iu jp iy jq jc ji jj jk jl bi translated">它使<code class="du ko kp kq jw b">foo.prototype</code>成为对象的原型。</li><li id="7bcc" class="jd je hi ih b ii jm im jn iq jo iu jp iy jq jc ji jj jk jl bi translated">如果函数没有返回任何东西，它将隐式返回<code class="du ko kp kq jw b">this</code>。</li></ol><pre class="jr js jt ju fd jv jw jx jy aw jz bi"><span id="6a5a" class="ka kb hi jw b fi kc kd l ke kf">function foo() {<br/>  console.log(this); // outputs an empty object<br/>}<br/><br/>new foo();</span></pre><p id="9298" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">显式绑定:</strong></p><p id="e7cc" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在JavaScript中，函数是一等公民。换句话说，函数是对象，是函数类型的实例，它有两个方法:<code class="du ko kp kq jw b"><a class="ae ks" href="https://www.javascripttutorial.net/javascript-call/" rel="noopener ugc nofollow" target="_blank">call()</a></code>和<code class="du ko kp kq jw b"><a class="ae ks" href="https://www.javascripttutorial.net/javascript-apply-method/" rel="noopener ugc nofollow" target="_blank">apply()</a></code>。如果您使用函数对象中的三个函数<code class="du ko kp kq jw b">call</code>、<code class="du ko kp kq jw b">apply</code>或<code class="du ko kp kq jw b">bind</code>之一调用一个函数，就会发生显式绑定。</p><ul class=""><li id="d97a" class="jd je hi ih b ii ij im in iq jf iu jg iy jh jc kn jj jk jl bi translated"><strong class="ih hj">调用</strong>:它接受逗号分隔的附加参数。它们将被传递给函数调用。<code class="du ko kp kq jw b">foo.call(obj, argument1, argument2)</code></li><li id="87b7" class="jd je hi ih b ii jm im jn iq jo iu jp iy jq jc kn jj jk jl bi translated"><strong class="ih hj"> apply </strong>:它与<code class="du ko kp kq jw b">call</code>非常相似，唯一的区别是它接受数组中的参数。<code class="du ko kp kq jw b">foo.apply(obj, [argument1, argument2])</code></li></ul><pre class="jr js jt ju fd jv jw jx jy aw jz bi"><span id="398c" class="ka kb hi jw b fi kc kd l ke kf">function Product(name, price) {<br/>  this.name = name;<br/>  this.price = price;<br/>}<br/><br/>function Food(name, price) {<br/>  Product.call(this, name, price);<br/>  this.category = 'food';<br/>}<br/><br/>function Toy(name, price) {<br/>  Product.call(this, name, price);<br/>  this.category = 'toy';<br/>}<br/><br/>const cheese = new Food('feta', 5);<br/>const fun = new Toy('robot', 40);<br/>console.log(`${cheese.name} is ${cheese.category}`);//feta is a food<br/>console.log(`${fun.name} is ${fun.category}`); //robot is a fun</span></pre><ul class=""><li id="50a6" class="jd je hi ih b ii ij im in iq jf iu jg iy jh jc kn jj jk jl bi translated"><strong class="ih hj"> bind </strong>:返回一个新的<a class="ae ks" href="https://www.javascripttutorial.net/javascript-function/" rel="noopener ugc nofollow" target="_blank"> f </a>函数，当被调用时，其<code class="du ko kp kq jw b"><a class="ae ks" href="https://www.javascripttutorial.net/javascript-this/" rel="noopener ugc nofollow" target="_blank">this</a></code>设置为一个特定值。<code class="du ko kp kq jw b">foo.bind(thisArg[,arg1[,arg2[,..]]])</code>与<code class="du ko kp kq jw b"><a class="ae ks" href="https://www.javascripttutorial.net/javascript-call/" rel="noopener ugc nofollow" target="_blank">call()</a></code>和<code class="du ko kp kq jw b"><a class="ae ks" href="https://www.javascripttutorial.net/javascript-apply-method/" rel="noopener ugc nofollow" target="_blank">apply()</a></code>方法不同，<code class="du ko kp kq jw b">bind()</code>方法不会立即执行函数。它只是返回一个新版本的函数，其<code class="du ko kp kq jw b">this</code>设置为<code class="du ko kp kq jw b">thisArg</code>参数。当你把一个方法对象作为回调传递给另一个函数时，<code class="du ko kp kq jw b">this</code>就丢失了。例如:</li></ul><pre class="jr js jt ju fd jv jw jx jy aw jz bi"><span id="4bad" class="ka kb hi jw b fi kc kd l ke kf">let person = { <br/>  name: ‘John Doe’,<br/>  getName: function() {<br/>   console.log(this.name); // undefined<br/>  }<br/> };<br/>setTimeout(person.getName, 1000);</span></pre><p id="f310" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">它可以改写如下:</p><pre class="jr js jt ju fd jv jw jx jy aw jz bi"><span id="2e52" class="ka kb hi jw b fi kc kd l ke kf">let f = person.getName; <br/>setTimeout(f, 1000); <em class="kr">// lost person context</em></span></pre><p id="2012" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">将方法用作回调意味着用默认绑定调用它们。(我们已经在默认绑定范围中讨论过了)。因此，当回调<code class="du ko kp kq jw b">person.getName</code>被调用时，全局对象中不存在<code class="du ko kp kq jw b">name</code>，它被设置为<code class="du ko kp kq jw b">undefined</code>。有很多方法可以解决这个问题:</p><p id="9d06" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">1.用另一个函数<br/> 2把它包起来。使用<code class="du ko kp kq jw b">bind</code>方法</p><pre class="jr js jt ju fd jv jw jx jy aw jz bi"><span id="bd57" class="ka kb hi jw b fi kc kd l ke kf">let f = person.getName.bind(person); <br/>setTimeout(f, 1000);</span></pre><p id="5ee1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">除了<code class="du ko kp kq jw b">bind</code>方法的这个好处之外。我们也可以利用<code class="du ko kp kq jw b">bind</code>方法从不同的对象借用方法，而不像<code class="du ko kp kq jw b">call</code>和<code class="du ko kp kq jw b">apply</code>那样复制那个方法。</p><pre class="jr js jt ju fd jv jw jx jy aw jz bi"><span id="89f9" class="ka kb hi jw b fi kc kd l ke kf">const person1 = {<br/>name: "John",<br/>age: 15,<br/>displayAge: function(){<br/>  console.log("He is " + this.age + " years old");<br/> }<br/>};<br/>person1.displayAge(); /*Output: He is 15 years old*/<br/>const person2 = {<br/>name: "Mike",<br/>age: 20<br/>};</span><span id="e572" class="ka kb hi jw b fi kt kd l ke kf">person1.displayAge.call(person2); //Output: He is 20 years old</span><span id="e7cd" class="ka kb hi jw b fi kt kd l ke kf">const displayAge = person1.displayAge.bind(person2)<br/>displayAge(); //Output: He is 20 years old</span><span id="8fb0" class="ka kb hi jw b fi kt kd l ke kf">person1.displayAge.apply(person2); //Output: He is 20 years old</span></pre><p id="3b5f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">箭头功能:</strong></p><p id="08e8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">arrow函数不创建自己的执行上下文，而是从定义arrow函数的外部函数继承<code class="du ko kp kq jw b">this</code>。请参见以下示例:</p><pre class="jr js jt ju fd jv jw jx jy aw jz bi"><span id="f7c9" class="ka kb hi jw b fi kc kd l ke kf">const obj = {<br/>  foo:() =&gt; console.log(this) //window object depends on strict mode  <br/>};<br/><br/>obj.foo();</span></pre><p id="ede2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这是一个使用箭头功能和<code class="du ko kp kq jw b">new</code>绑定的例子。</p><pre class="jr js jt ju fd jv jw jx jy aw jz bi"><span id="a813" class="ka kb hi jw b fi kc kd l ke kf">function Person() {<br/>  const foo = () =&gt; console.log(this.name); // Yasemin.<br/>  this.name = "yasemin";<br/>}<br/><br/>const person = new Person();<br/>person.foo();</span></pre><p id="bdaa" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们叫<code class="du ko kp kq jw b">new Person()</code>。这将创建一个新的空对象，并将其绑定为<code class="du ko kp kq jw b">this</code>的值。当我们调用foo的方法时，<code class="du ko kp kq jw b">this</code>当前指向的是<code class="du ko kp kq jw b">new</code>创建的对象。</p></div></div>    
</body>
</html>