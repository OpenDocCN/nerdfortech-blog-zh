<html>
<head>
<title>Tuple, ValueTuple in C# — A Summary</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">元组，C#中的值元组—概述</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/tuple-valuetuple-in-c-a-summary-6ddedb99c72e?source=collection_archive---------2-----------------------#2022-11-11">https://medium.com/nerd-for-tech/tuple-valuetuple-in-c-a-summary-6ddedb99c72e?source=collection_archive---------2-----------------------#2022-11-11</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="99ee" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这只是对 tuple 的一个总结，因为我的笔记似乎到处都是。</p><h1 id="3309" class="jd je hi bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">ValueTuple 和 Tuple 的区别</h1><p id="7d30" class="pw-post-body-paragraph if ig hi ih b ii kb ik il im kc io ip iq kd is it iu ke iw ix iy kf ja jb jc hb bi translated">C#中有两种类型的元组类型，System。元组和 System.ValueTuple 元组。</p><p id="fb9e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">系统。元组</strong> = &gt;引用，成员是属性，只读。</p><p id="2996" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">系统。ValueTuple </strong> = &gt;值，成员是字段，不只读。</p><p id="baa1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">两种类型的非常简单的元组:</p><pre class="kg kh ki kj fd kk kl km bn kn ko bi"><span id="ed8a" class="kp je hi kl b be kq kr l ks kt">System.Tuple&lt;Int32&gt; intTup = new Tuple&lt;Int32&gt;(100);<br/>Console.WriteLine (intTup); //display (100)<br/>Console.WriteLine (intTup.Item1); // displays 100<br/><br/>System.ValueTuple&lt;Int32&gt; intTupVal = new ValueTuple&lt;Int32&gt;(100);<br/>Console.WriteLine (intTupVal); //(100)<br/>Console.WriteLine (intTupVal.Item1); //100</span></pre><p id="5cf9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">那么有什么区别呢？</p><p id="5e58" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">对于初学者来说，尝试</strong> <code class="du ku kv kw kl b"><strong class="ih hj">intTup.Item1 = 200;</strong></code> <strong class="ih hj">会给你一个编译错误。但是</strong> <code class="du ku kv kw kl b"><strong class="ih hj">intTupVal.Item1 = 200;</strong></code> <strong class="ih hj">你可以做，而且会起作用。</strong></p><p id="b1a3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">元组类型作为引用，在内存堆和内存分配方面更加困难，因此 ValueTuple 将为您提供更好的性能。</p><p id="0d2c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">元组类型和值元组类型可以以相同的方式创建，<strong class="ih hj">但是，值元组类型有一种额外的创建方式。</strong></p><p id="4143" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">创建元组和值元组的另一种方法是使用 create 关键字:</p><pre class="kg kh ki kj fd kk kl km bn kn ko bi"><span id="717d" class="kp je hi kl b be kq kr l ks kt">var intTup = System.Tuple.Create&lt;Int32&gt;(100);<br/>var intTupVal = System.ValueTuple.Create&lt;Int32&gt;(200);</span></pre><p id="a1ce" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">对于<strong class="ih hj"> ValueTuple </strong>，有另外一种创建新值的方法:</p><pre class="kg kh ki kj fd kk kl km bn kn ko bi"><span id="5895" class="kp je hi kl b be kq kr l ks kt">(int, int, int) tup1 = (100,200, 300);<br/>var tup2 = (400,500,600);<br/><br/>//to see the type:<br/>Console.WriteLine(tup2.GetType()); <br/>//System.ValueTuple`3[System.Int32,System.Int32,System.Int32]</span></pre><p id="c631" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">此外，要访问元组或值元组的元素，我们必须访问 Item1、Item2 等，这令人困惑。但是对于 ValueTuple 类型，我们可以命名元素:</p><pre class="kg kh ki kj fd kk kl km bn kn ko bi"><span id="93fd" class="kp je hi kl b be kq kr l ks kt">(int first, int second , int third) tup1 = (100,200, 300);<br/> Console.WriteLine(tup1.first);//100<br/><br/>var tup2 = (first:100, second:200, third:300);<br/>Console.WriteLine(tup2.second); //200</span></pre><p id="4ed5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果 ValueTuple 只有 1 个值，那么试图以这种方式创建它是无法编译的。它与创建它的其他方法一起工作(已经提到)。</p><p id="11d3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">ValueTuple 类型可以保存比 Tuple 类型更多的元素。如果你有一个元组，可以用<code class="du ku kv kw kl b">ToValueTuple.</code>把它转换成 ValueTuple</p><h1 id="48d8" class="jd je hi bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">嵌套元组</h1><p id="aee9" class="pw-post-body-paragraph if ig hi ih b ii kb ik il im kc io ip iq kd is it iu ke iw ix iy kf ja jb jc hb bi translated">因为元组类型受元素数量的限制，我们可能需要一个元组而不是另一个元组，这样我们就可以传递我们需要的所有东西。</p><pre class="kg kh ki kj fd kk kl km bn kn ko bi"><span id="c5cf" class="kp je hi kl b be kq kr l ks kt">var numbers = Tuple.Create(1, 2, 3, 4, 5, 6, 7, Tuple.Create(8, 9, 10, 11, 12));<br/>Console.WriteLine(numbers.Item1); //1<br/>Console.WriteLine(numbers.Rest.Item1); //(8, 9, 10, 11, 12)<br/>Console.WriteLine(numbers.Rest.Item1.Item1);   //8</span></pre><h1 id="3e0b" class="jd je hi bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">比较值元组，元组类型</h1><p id="75a8" class="pw-post-body-paragraph if ig hi ih b ii kb ik il im kc io ip iq kd is it iu ke iw ix iy kf ja jb jc hb bi translated">对于 ValueTuple 类型，即使我们给元素取了不同的名称，比较的也是值。</p><pre class="kg kh ki kj fd kk kl km bn kn ko bi"><span id="9dbd" class="kp je hi kl b be kq kr l ks kt">(int x, int y) valtup1 = (3,4);<br/>(int i, int j) valtup2 = (3,4);<br/>       <br/>Console.Write(valtup1 == valtup2);//True</span></pre><p id="8948" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">但是，对于引用类型元组:</p><pre class="kg kh ki kj fd kk kl km bn kn ko bi"><span id="8950" class="kp je hi kl b be kq kr l ks kt">Tuple&lt;int,int&gt; tup1 = new Tuple&lt;int, int&gt;(3,4);<br/>Tuple&lt;int,int&gt; tup2 = new Tuple&lt;int, int&gt;(3,4);<br/>       <br/>Console.Write(tup1 == tup2);// False</span></pre><h1 id="6486" class="jd je hi bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">在方法中返回 ValueTuple</h1><p id="19fb" class="pw-post-body-paragraph if ig hi ih b ii kb ik il im kc io ip iq kd is it iu ke iw ix iy kf ja jb jc hb bi translated">除了返回类型 ValueTuple，我们还可以指出元素应该有什么名称。</p><pre class="kg kh ki kj fd kk kl km bn kn ko bi"><span id="baed" class="kp je hi kl b be kq kr l ks kt"> public static (int, int) GetAValueTuple(){<br/>   return (first:20, second:30);<br/> }<br/><br/> var v = GetAValueTuple();<br/> Console.WriteLine(v);<br/> //Console.WriteLine(v.first); will not find first<br/><br/> (int x, int y) w = GetAValueTuple();<br/> Console.WriteLine(w);<br/> Console.WriteLine(w.x); //will not find first but x is 20<br/><br/> //BUT, if we name the return and the return type!<br/>public static (int first, int second) GetAValueTuple(){<br/>  return (first:20, second:30);<br/>}<br/>var v = GetAValueTuple();<br/>Console.WriteLine(v.first);//20<br/><br/>//We can also do <br/>(int x, int y) = GetAValueTuple();<br/>Console.WriteLine(x);//20<br/>Console.WriteLine(y);//30</span></pre><p id="636b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这些是主要的事情。我希望它能澄清一些事情。</p></div></div>    
</body>
</html>