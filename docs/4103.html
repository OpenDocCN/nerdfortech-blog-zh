<html>
<head>
<title>TiFS, a TiKV-Based Partition Tolerant, Strictly Consistent File System</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">TiFS，一种基于TiKV的分区容忍、严格一致的文件系统</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/tifs-a-tikv-based-partition-tolerant-strictly-consistent-file-system-82c18baffdae?source=collection_archive---------7-----------------------#2021-07-07">https://medium.com/nerd-for-tech/tifs-a-tikv-based-partition-tolerant-strictly-consistent-file-system-82c18baffdae?source=collection_archive---------7-----------------------#2021-07-07</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/e197f2c66d5d8d4cb5e249c4cf779fc8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*JTJ3vIWHdPT0YXA4.jpg"/></div></div></figure><p id="74d5" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">作者:<a class="ae jo" href="https://github.com/Hexilee" rel="noopener ugc nofollow" target="_blank">河西李</a>(软件工程师平盖实习生)</p><p id="7b72" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">Transcreator: <a class="ae jo" href="https://github.com/ran-huang" rel="noopener ugc nofollow" target="_blank">黄然</a>；编辑:汤姆·万德</p><p id="5cf1" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">TiKV是一个分布式键值存储引擎，具有很强的一致性和分区容忍度。它既可以充当TiDB的存储引擎，也可以充当独立的事务性键值数据库。你知道它还能做什么吗？</p><p id="770e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在<a class="ae jo" href="https://pingcap.com/community/events/hackathon2020/" rel="noopener ugc nofollow" target="_blank"> TiDB Hackathon 2020 </a>、<strong class="is hj">上，我们的团队构建了一个基于TiKV的分布式POSIX文件系统</strong>、<a class="ae jo" href="https://github.com/Hexilee/tifs" rel="noopener ugc nofollow" target="_blank"> TiFS </a>，它继承了TiKV的强大功能，也挖掘了TiKV在数据存储之外的可能性。</p><p id="34cd" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在这篇文章中，我将带你了解TiFS的每个细节:<strong class="is hj">我们是如何想出这个主意的，我们是如何实现这个文件系统的，以及它的基准测试结果。</strong>让黑客攻击开始吧！</p><h1 id="0803" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">为什么要构建基于TiKV的文件系统？</h1><p id="5958" class="pw-post-body-paragraph iq ir hi is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hb bi translated">“分布式”系统有多个跨机器协作的进程；TiKV也有。作为一个分布式数据库，意味着它很容易向外扩展，并且本质上是容错的。</p><p id="8c4b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我的一个朋友曾经想尝试TiDB但是只有一个服务器。我告诉他，他可以在每个磁盘上运行一个TiKV实例，实现数据容灾，不再需要RAID了！</p><p id="690e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">但是，TiKV只存储数据，不存储文件，所以您仍然需要RAID来从灾难中恢复文件。但这在我心中引发了一个想法:<strong class="is hj">如果TiKV可以存储文件系统数据，那么就可以实现文件系统的容灾。因此，我们花了几天时间构建TIF。这是一个POSIX文件系统，在第一个版本中漏洞百出，容易出现死锁——但是，嘿，这个想法是可行的。</strong></p><p id="8855" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">为什么我们要这么努力？三个原因:</p><ul class=""><li id="aaf1" class="ks kt hi is b it iu ix iy jb ku jf kv jj kw jn kx ky kz la bi translated">与分布式文件系统的通用存储后端不同，<strong class="is hj"> TiKV支持符合ACID的分布式事务。</strong>因此，我们可以<strong class="is hj">保证文件系统的严格一致性。</strong></li><li id="5d3f" class="ks kt hi is b it lb ix lc jb ld jf le jj lf jn kx ky kz la bi translated">POSIX文件系统不仅涵盖了本地文件系统的需求，而且<strong class="is hj">支持跨机器的文件协作，并为其他分布式应用程序存储文件。</strong></li><li id="707b" class="ks kt hi is b it lb ix lc jb ld jf le jj lf jn kx ky kz la bi translated">更酷的是，<strong class="is hj">如果我们在TiFS上运行一个支持多实例协作的独立应用程序，它就变成了一个分布式应用程序。</strong></li></ul><p id="153e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">因此，我们开始这个项目来构建TiFS，一个像钛一样坚固的文件系统。</p><h1 id="041d" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">我们如何实施TiFS</h1><p id="4326" class="pw-post-body-paragraph iq ir hi is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hb bi translated">TiKV只提供了一个简单的键值存储，其中键和值是长度不固定的字节数组。因此，在实现文件系统之前，我们需要为键划分逻辑区域，为值构建数据结构。</p><h2 id="bbd3" class="lg jq hi bd jr lh li lj jv lk ll lm jz jb ln lo kd jf lp lq kh jj lr ls kl lt bi translated">价值观念</h2><p id="f4bf" class="pw-post-body-paragraph iq ir hi is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hb bi translated"><strong class="is hj"> TiFS在TiKV中存储七种类型的值:系统元数据、文件元数据、文件块、文件处理程序、符号链接、目录和文件索引。</strong>文件块是用户写的透明数据。符号链接只存储目标路径。其他五个值是结构化数据。</p><p id="1a0d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">系统元数据</strong></p><p id="939a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">整个文件系统只有一个<strong class="is hj">系统元数据</strong> ( <code class="du lu lv lw lx b">Meta</code>)，只在<code class="du lu lv lw lx b">mknod</code>和<code class="du lu lv lw lx b">mkdir</code>操作时更新。系统元数据仅包含一个用于生成文件信息节点编号的整数:</p><pre class="ly lz ma mb fd mc lx md me aw mf bi"><span id="25bc" class="lg jq hi lx b fi mg mh l mi mj">struct Meta {<br/>    inode_next: u64,<br/>}</span></pre><p id="9c6a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">文件元数据</strong></p><p id="5a42" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">每个文件都有一个对应的<strong class="is hj">文件元数据</strong> ( <code class="du lu lv lw lx b">Inode</code>)。在这个数据结构中:</p><ul class=""><li id="8365" class="ks kt hi is b it iu ix iy jb ku jf kv jj kw jn kx ky kz la bi translated"><code class="du lu lv lw lx b">file_attr</code>存储POSIX文件系统所需的元数据，比如文件索引节点号、文件大小和块数。详见<a class="ae jo" href="https://docs.rs/fuser/0.7.0/fuser/struct.FileAttr.html" rel="noopener ugc nofollow" target="_blank">铁锈文件属性</a>。</li><li id="ad77" class="ks kt hi is b it lb ix lc jb ld jf le jj lf jn kx ky kz la bi translated"><code class="du lu lv lw lx b">lock_state</code>跟踪当前锁状态和锁持有者，用于执行<code class="du lu lv lw lx b">flock</code>。</li><li id="9e17" class="ks kt hi is b it lb ix lc jb ld jf le jj lf jn kx ky kz la bi translated"><code class="du lu lv lw lx b">inline_data</code>存储少量文件内容，以提高微小文件的读写性能。</li><li id="ac15" class="ks kt hi is b it lb ix lc jb ld jf le jj lf jn kx ky kz la bi translated"><code class="du lu lv lw lx b">next_fn</code>是一个自动递增的整数，用于生成文件处理程序。</li><li id="2d92" class="ks kt hi is b it lb ix lc jb ld jf le jj lf jn kx ky kz la bi translated"><code class="du lu lv lw lx b">opened_fn</code>记录打开的文件处理程序的数量。</li></ul><pre class="ly lz ma mb fd mc lx md me aw mf bi"><span id="ca03" class="lg jq hi lx b fi mg mh l mi mj">struct Inode {<br/>    file_attr: FileAttr,<br/>    lock_state: LockState,<br/>    inline_data: Option&lt;Vec&lt;u8&gt;&gt;,<br/>    next_fh: u64,<br/>    opened_fh: u64,<br/>}</span></pre><p id="0d0e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">文件处理器</strong></p><p id="4c16" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">每次用户调用<code class="du lu lv lw lx b">open</code>，文件系统都会生成一个对应的文件处理程序(<code class="du lu lv lw lx b">FileHandler</code>)来存储该处理程序的读写限制:</p><pre class="ly lz ma mb fd mc lx md me aw mf bi"><span id="8387" class="lg jq hi lx b fi mg mh l mi mj">struct FileHandler {<br/>    flags: i32,<br/>}</span></pre><p id="93af" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">目录</strong></p><p id="1188" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">每个<strong class="is hj">目录</strong>存储一个子文件列表，这样它就可以实现<code class="du lu lv lw lx b">readdir</code>。在列表中，每个<code class="du lu lv lw lx b">DirItem</code>项存储文件的索引节点号、名称和类型:</p><pre class="ly lz ma mb fd mc lx md me aw mf bi"><span id="534c" class="lg jq hi lx b fi mg mh l mi mj">type Directory = Vec&lt;DirItem&gt;;</span><span id="7d7c" class="lg jq hi lx b fi mk mh l mi mj">struct DirItem {<br/>    ino: u64,<br/>    name: String,<br/>    typ: FileType,<br/>}</span></pre><p id="d750" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">文件索引</strong></p><p id="d06d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">当我们查询一个文件时，文件系统可以遍历整个文件目录；但是为了更有效地查询文件，我们为每个文件创建了一个<strong class="is hj">索引</strong> ( <code class="du lu lv lw lx b">Index</code>)。文件索引仅包含目标文件的信息节点号:</p><pre class="ly lz ma mb fd mc lx md me aw mf bi"><span id="ba1f" class="lg jq hi lx b fi mg mh l mi mj">struct Index {<br/>    ino: u64,<br/>}</span></pre><h2 id="d81c" class="lg jq hi bd jr lh li lj jv lk ll lm jz jb ln lo kd jf lp lq kh jj lr ls kl lt bi translated">钥匙</h2><p id="c3b6" class="pw-post-body-paragraph iq ir hi is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hb bi translated">TiFS有五种类型的键:系统元数据、文件元数据、文件块、文件处理程序和文件索引。其中，文件块键存储文件块数据、符号链接和目录，其他四个键存储它们对应的值。</p><p id="bd29" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">块的第一个字节，也称为作用域，标识键的类型。</strong>键的字节数组通常遵循以下模式:</p><figure class="ly lz ma mb fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ml"><img src="../Images/63c68fea2a17fef14825b03989d49959.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ELdCYumQob-mDtI5dtg2ZQ.png"/></div></div></figure><p id="c0e0" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">系统元数据范围</strong>只有一个键值对:</p><pre class="ly lz ma mb fd mc lx md me aw mf bi"><span id="2785" class="lg jq hi lx b fi mg mh l mi mj">+ 1 byte +<br/>|        |<br/>|        |<br/>|        |<br/>|        |<br/>|        |<br/>|        |<br/>|        v<br/>+--------+<br/>|        |<br/>|    0   |<br/>|        |<br/>+--------+</span></pre><p id="06fc" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">文件元数据</strong>键仅包含以大端顺序排列的索引节点号，因此所有文件元数据都按顺序存储在TiKV中。因此，对于<code class="du lu lv lw lx b"><a class="ae jo" href="https://man7.org/linux/man-pages/man2/statfs.2.html" rel="noopener ugc nofollow" target="_blank">statfs</a></code>操作，我们可以使用TiKV的<code class="du lu lv lw lx b">scan</code>接口获得所有文件元数据。</p><p id="82bb" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">文件元数据键如下:</p><figure class="ly lz ma mb fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mm"><img src="../Images/c4febe796b806663c0f4f4781b76dd27.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2E6VwARhZZDO09rRIO1eZg.png"/></div></div></figure><p id="e74d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">文件块</strong>键由文件索引节点号和块索引按大端顺序组成。单个文件的所有文件块按顺序存储在TiKV中。当我们需要读取大块的数据时，我们可以通过一个<code class="du lu lv lw lx b">scan</code>得到想要的文件块。</p><p id="2aba" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">键的数组如下所示:</p><figure class="ly lz ma mb fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ml"><img src="../Images/0cd4d58670eca8e233b1e640edb6c718.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5LuTCVCPavW2wY7J31Xkjg.png"/></div></div></figure><p id="34b9" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">文件处理程序</strong>键由文件索引节点号和文件处理程序号组成，以大端顺序排列:</p><figure class="ly lz ma mb fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mn"><img src="../Images/7c802a453f919c9f4bf6756fbc1f57ba.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EiaD55sNA4lx2DwSvmdn0A.png"/></div></div></figure><p id="5685" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">文件索引</strong>键包括其父目录的索引节点号(大端排序)和文件名(UTF-8编码):</p><figure class="ly lz ma mb fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mo"><img src="../Images/c562b69ebd61d8ba0e52f9f50b44c698.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*n9IfXOkCaLsRAr1x1pzBbQ.png"/></div></div></figure><h2 id="e984" class="lg jq hi bd jr lh li lj jv lk ll lm jz jb ln lo kd jf lp lq kh jj lr ls kl lt bi translated">一致性</h2><p id="9ece" class="pw-post-body-paragraph iq ir hi is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hb bi translated">TiKV支持乐观和悲观的交易。然而，由于Rust客户端仅在实验上支持悲观事务，并且悲观事务可能会在事务不冲突时降低性能，因此我们仅通过乐观事务来实现TIF。</p><h1 id="1fde" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">各种场景</h1><p id="d7bd" class="pw-post-body-paragraph iq ir hi is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hb bi translated">对于读写小文件或其他复杂的文件系统操作，TiFS是最有效的。虽然TiFS可以处理大文件，但与其他大文件存储解决方案相比，它的功能和效率都不如前者。</p><p id="25dc" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">以下是一些你可能会感兴趣的TIF用法:</p><ul class=""><li id="cc94" class="ks kt hi is b it iu ix iy jb ku jf kv jj kw jn kx ky kz la bi translated">Git远程存储库可以直接使用TiFS来存储项目并运行Git任务，例如<code class="du lu lv lw lx b">rebase</code>或<code class="du lu lv lw lx b">cherry-pick</code>，而无需将文件传输到本地文件系统。</li><li id="e488" class="ks kt hi is b it lb ix lc jb ld jf le jj lf jn kx ky kz la bi translated">当应用程序的多个节点读取或写入TiFS中的同一个文件时，您可以使用<code class="du lu lv lw lx b">flock</code>来解决任何冲突。</li><li id="e763" class="ks kt hi is b it lb ix lc jb ld jf le jj lf jn kx ky kz la bi translated">空间管理没有复杂的SDK或API。您只需调用文件系统API或运行一个shell脚本。</li><li id="8128" class="ks kt hi is b it lb ix lc jb ld jf le jj lf jn kx ky kz la bi translated">TiFS允许您将支持多实例协作的独立应用程序转换成分布式应用程序。例如，SQLite + TiFS =又一个分布式关系数据库。诚然，要这样使用TIF，应用程序不能依赖页面缓存或其他缓存机制来避免写入不可见。</li></ul><figure class="ly lz ma mb fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mp"><img src="../Images/9e6141ffc10a4559c9745c7c342dfffa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*fxbNjq5ka4ZhJg75.gif"/></div></div><figcaption class="mq mr et er es ms mt bd b be z dx translated"><em class="mu"> TiFS让SQLite成为另一个分布式关系数据库</em></figcaption></figure><h1 id="cb41" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">测试和基准</h1><p id="5e90" class="pw-post-body-paragraph iq ir hi is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hb bi translated">在黑客马拉松期间，我们使用<a class="ae jo" href="https://github.com/pjd/pjdfstest" rel="noopener ugc nofollow" target="_blank"> pjdfstest </a>来测试TiFS的正确性。但是因为pjdfstest没有涵盖读/写正确性或并发正确性，我们将需要添加其他测试。</p><p id="e08a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">理论上，有三个主要因素影响TiFS的读/写性能:文件系统块的大小、网络延迟和加载块的大小。这里我们将展示读/写IOPS和速度的<a class="ae jo" href="https://github.com/Hexilee/tifs.benchmark" rel="noopener ugc nofollow" target="_blank">基准测试结果</a>。</p><h2 id="2aef" class="lg jq hi bd jr lh li lj jv lk ll lm jz jb ln lo kd jf lp lq kh jj lr ls kl lt bi translated">IOPS</h2><blockquote class="mv mw mx"><p id="6ac2" class="iq ir my is b it iu iv iw ix iy iz ja mz jc jd je na jg jh ji nb jk jl jm jn hb bi translated"><em class="hi">注意:TiKV是一个复杂的系统，其中有逻辑持续时间、磁盘I/O持续时间和网络持续时间。在本文中，出于演示目的，我们将TiKV简化为单个副本。</em></p></blockquote><p id="034d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">让我们先来看看IOPS。因为顺序读取和写入线性地执行I/O操作，所以每个I/O操作都是TiKV中的一个事务。如果我们忽略每个操作之间的微小差异，一个I/O操作的持续时间<em class="my"> T </em>，是<em class="my"> IOPS </em>的倒数。另外，如果不算流处理，我们可以把<em class="my"> T </em>看成是以下四个变量的线性相加:</p><ul class=""><li id="b493" class="ks kt hi is b it iu ix iy jb ku jf kv jj kw jn kx ky kz la bi translated"><em class="my"> Tf </em>:保险丝<a class="ae jo" href="https://en.wikipedia.org/wiki/Filesystem_in_Userspace" rel="noopener ugc nofollow" target="_blank">的I/O持续时间</a>。</li><li id="00f2" class="ks kt hi is b it lb ix lc jb ld jf le jj lf jn kx ky kz la bi translated"><em class="my">Tc</em>:TiFS的逻辑持续时间。</li><li id="5edd" class="ks kt hi is b it lb ix lc jb ld jf le jj lf jn kx ky kz la bi translated"><em class="my"> Tn </em>:网络传输时间。</li><li id="ccfd" class="ks kt hi is b it lb ix lc jb ld jf le jj lf jn kx ky kz la bi translated"><em class="my">Ts</em>:TiKV的逻辑持续时间。</li></ul><p id="eb48" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">相应地，我们有这个等式:</p><figure class="ly lz ma mb fd ij er es paragraph-image"><div class="er es nc"><img src="../Images/07599db23b838d571bf85a8e64faf49a.png" data-original-src="https://miro.medium.com/v2/resize:fit:880/format:webp/0*4--Oj0m00u5bnyaF.png"/></div></figure><p id="1d4b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">阅读IOPS </strong></p><p id="9587" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">对于读取操作，<em class="my"> Tf </em>与加载块的大小正相关。每个I/O操作中TIF读取或写入的数据大小必须是文件系统块大小的整数倍。因此，<em class="my"> Tn </em>和<em class="my"> Ts </em>与加载块和文件系统块之间的较大值正相关；但是，对于较大的流量，网络和磁盘I/O可能需要更长时间。<em class="my"> Tc </em>未知。</p><p id="d0aa" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">下图显示了顺序读取IOPS如何随着加载块的大小而变化。</strong>这四行代表不同的文件系统块大小和数据副本。</p><figure class="ly lz ma mb fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es nd"><img src="../Images/2f6bb709b7d6f657ee7e7b8e53f5fdf2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*fZhb8a0HWmrcyQ9B.png"/></div></div><figcaption class="mq mr et er es ms mt bd b be z dx translated"><em class="mu">阅读IOPS基准测试结果</em></figcaption></figure><p id="2a69" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在基准测试之前，我们有以下预测:</p><ul class=""><li id="a7b6" class="ks kt hi is b it iu ix iy jb ku jf kv jj kw jn kx ky kz la bi translated">当文件块和负载块都是4 KB时，如果负载块增加，<em class="my"> Tf </em>、<em class="my"> Tn </em>、<em class="my"> Ts </em>增加；因此，<strong class="is hj"><em class="my"/></strong>减少。</li><li id="2bb6" class="ks kt hi is b it lb ix lc jb ld jf le jj lf jn kx ky kz la bi translated">当文件块为64 KB或1 MB时:<br/>如果负载块小于文件块，<em class="my"> Tn </em>和<em class="my"> Ts </em>几乎不变，而<em class="my"> Tf </em>增加；因此，<em class="my"> IOPS </em>减小。<br/>如果负载块大于文件块，<em class="my"> Tf </em>、<em class="my"> Tn </em>、<em class="my"> Ts </em>都增加；因此，<em class="my"> IOPS </em>减小。</li></ul><p id="df3f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">正如你在图表中看到的，变化几乎与我们的预测相同。</p><p id="61bc" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">写IOPS </strong></p><p id="8c5b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">当TiFS顺序写入数据时，如果加载块小于文件块，TiFS需要读取一个脏块，导致额外的<em class="my"> Tc </em>和<em class="my"> Tn </em>。当文件块很大时，额外的开销会很明显。</p><p id="efc9" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">下面的折线图显示了顺序写入IOPS如何随加载块的大小而变化。</strong>当文件块为1 MB(见黄线)时，<em class="my"> IOPS </em>最大，文件块和加载块相当。</p><figure class="ly lz ma mb fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es nd"><img src="../Images/3798511ad0802d2a605ca047dab98c81.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*taz5ZyYh24GtZ-1J.png"/></div></div><figcaption class="mq mr et er es ms mt bd b be z dx translated"><em class="mu">写出IOPS标杆的结果</em></figcaption></figure><p id="0fd0" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">而且，我们可以看到，在前两个数据点上，红线几乎与蓝线重叠。这意味着当加载块和文件块是4 KB或64 KB时，它们的<strong class="is hj"> <em class="my"> IOPS </em> </strong>值几乎相同。在这样的情况下，每秒流量最小4 KB <em class="my"> 110 = 440 KB，最大64 KB </em> 100 = 6.25 MB，对网络和磁盘的压力都不大。当流量足够小时，可以有把握地说<em class="my"> IOPS </em>达到上限，那么<em class="my"> Tn </em>的主要因素就变成了网络延迟。(在本地测试中，<em class="my"> Tn </em>被认为是0毫秒。)</p><p id="f54c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在上图中，当文件块和加载块在4 KB和64 KB之间变化时，<em class="my"> IOPS </em>几乎不受影响。在这样的配置下，<em class="my"> T </em>由<em class="my"> Tc </em>和<em class="my"> Ts </em>决定，所以我们称之为TiFS的固定系统操作延迟。<strong class="is hj">固定系统操作延迟</strong>由TiFS和TiKV的逻辑持续时间引起。如果延迟足够长，会导致小文件的读/写性能很差。我们仍在进行这种优化。</p><h2 id="200d" class="lg jq hi bd jr lh li lj jv lk ll lm jz jb ln lo kd jf lp lq kh jj lr ls kl lt bi translated">速度</h2><p id="0a2f" class="pw-post-body-paragraph iq ir hi is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hb bi translated">因为读写速度是<em class="my"> IOPS </em>乘以负载块的乘积，而<em class="my"> IOPS </em>在负载块从4 KB增加到1 MB时变化很小，所以读写速度在负载块为1 MB时达到最大值。</p><p id="712b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">以下两个条形图比较了负载块为1 MB时不同集群配置中的读写速度。蓝条代表普通TiKV，红条代表启用Titan的TiKV。</p><blockquote class="mv mw mx"><p id="7a29" class="iq ir my is b it iu iv iw ix iy iz ja mz jc jd je na jg jh ji nb jk jl jm jn hb bi translated"><a class="ae jo" href="https://github.com/tikv/titan" rel="noopener ugc nofollow" target="_blank"> <em class="hi"> Titan </em> </a> <em class="hi">是一个RocksDB插件，用于键值分离，受</em> <a class="ae jo" href="https://www.usenix.org/system/files/conference/fast16/fast16-papers-lu.pdf" rel="noopener ugc nofollow" target="_blank"> <em class="hi"> WiscKey </em> </a> <em class="hi">启发，减少写放大。</em></p></blockquote><figure class="ly lz ma mb fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es nd"><img src="../Images/d94102166bb1344409dfc8fcc901579e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*_2p8kdPCCXZtzsj0.png"/></div></div><figcaption class="mq mr et er es ms mt bd b be z dx translated"><em class="mu">读取速度基准测试结果</em></figcaption></figure><figure class="ly lz ma mb fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es nd"><img src="../Images/0e9a660836869a6454f8b1a27d51e3b2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*IEbywrQNB5VISqXt.png"/></div></div><figcaption class="mq mr et er es ms mt bd b be z dx translated"><em class="mu">写速度基准测试结果</em></figcaption></figure><p id="b331" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">从图表中，我们可以看到写入速度主要受文件块大小和是否启用Titan的影响，读取速度只是略有波动。这是因为文件块越小，TiKV写入的键值对就越多，这需要更多的时间。但是RocksDB处理大文件块的性能很差，所以启用Titan可以减少不必要的值复制，从而提高性能。</p><h1 id="0226" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">我们的下一步</h1><p id="c1de" class="pw-post-body-paragraph iq ir hi is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hb bi translated">在TiFS中，存储文件块的成本非常高，因为TiKV通过使用多个副本(默认为三个)来实现冗余。冗余率(占用空间除以写入数据量)通常为三或更多。</p><p id="520f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">然而，在其他支持通过擦除编码(EC)实现冗余的分布式文件系统中，如HDFS、CephFS和JuiceFS，冗余率低至1.2~1.5。EC冗余需要在数据写入和重建期间进行编码和解码，这会消耗额外的计算资源。<strong class="is hj">但是，EC冗余策略牺牲了部分读取性能，换取了更低的网络开销和存储成本。</strong></p><p id="6e17" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">目前，TiKV支持EC有些困难，但我们<strong class="is hj">计划支持文件块的EC冗余对象存储，以降低存储成本。</strong></p><p id="0f1c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">除此之外，<strong class="is hj">我们将重点验证正确性和调优性能:</strong></p><ul class=""><li id="f103" class="ks kt hi is b it iu ix iy jb ku jf kv jj kw jn kx ky kz la bi translated">为了确保正确性，我们将研究如何测试其他文件系统，并使用这些知识来构建我们自己的测试。</li><li id="34ca" class="ks kt hi is b it lb ix lc jb ld jf le jj lf jn kx ky kz la bi translated">对于性能，我们将涵盖TIF和TiKV，以减少固有的延迟。</li></ul><p id="1e89" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如果你对TiFS感兴趣，请随时<a class="ae jo" href="https://github.com/Hexilee/tifs" rel="noopener ugc nofollow" target="_blank">尝试一下</a>或<a class="ae jo" href="https://github.com/Hexilee/tifs/issues" rel="noopener ugc nofollow" target="_blank">加入我们的讨论</a>！</p></div><div class="ab cl ne nf gp ng" role="separator"><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj"/></div><div class="hb hc hd he hf"><p id="8f6b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><em class="my">原载于2021年5月24日</em><a class="ae jo" href="https://pingcap.com/blog/tifs-a-tikv-based-partition-tolerant-strictly-consistent-file-system#why-build-a-file-system-based-on-tikv" rel="noopener ugc nofollow" target="_blank"><em class="my">www.pingcap.com</em></a><em class="my"/></p></div></div>    
</body>
</html>