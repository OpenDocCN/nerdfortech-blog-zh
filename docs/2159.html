<html>
<head>
<title>Sample size and time series models — A case study on ARIMA() processes.</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">样本容量与时间序列模型——以ARIMA()过程为例。</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/sample-size-and-time-series-models-a-case-study-on-arima-processes-16c2afa3900d?source=collection_archive---------9-----------------------#2021-04-24">https://medium.com/nerd-for-tech/sample-size-and-time-series-models-a-case-study-on-arima-processes-16c2afa3900d?source=collection_archive---------9-----------------------#2021-04-24</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><h1 id="a6ed" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">目标和内容</h1><p id="43f0" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">作为常规商业科学课程的一部分，ARIMA时间序列模型经常在计量经济学课程中教授，因此有时会被缺乏经验的数据科学家使用。</p><p id="9a51" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">本案例研究的目的是理解简单MA(1)模型背后的数据生成过程，并说明小样本情况下估计量的弱点。</p><h1 id="c11b" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">结果</h1><p id="3d23" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">对于系数β= 0.3的测试MA(1)模型，需要至少5000个观测值的时间序列长度才能达到更窄的置信区间。</p><p id="a9b1" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">对预报质量的影响被评估，并主要取决于估计的系数。</p><h1 id="e7ce" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">情况</h1><p id="bc64" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">首先安装一些库:</p><pre class="kg kh ki kj fd kk kl km kn aw ko bi"><span id="67e3" class="kp ig hi kl b fi kq kr l ks kt">#for confidence intervals and testing<br/>library(lmtest)<br/>#for plotting<br/>library(ggplot2)</span></pre><p id="0a6d" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">现在从流程中生成一些数据。这比使用真实世界的数据要好，因为我们知道在这个实验室设置中我们的目标是什么:50个观察值，系数β=0.3的简单MA(1)模型:</p><pre class="kg kh ki kj fd kk kl km kn aw ko bi"><span id="54f6" class="kp ig hi kl b fi kq kr l ks kt">n &lt;- 50<br/>beta &lt;- 0.3<br/>eps &lt;- rnorm(n)<br/>x &lt;- vector(length = n)<br/>x[1] &lt;- eps[1]<br/>for(i in 2:n){<br/>  x[i] &lt;- eps[i]+beta*eps[i-1]<br/>}</span></pre><p id="7489" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">现在，让我们进行拟合，看看用于生成数据的系数是否未被发现:</p><pre class="kg kh ki kj fd kk kl km kn aw ko bi"><span id="2fdb" class="kp ig hi kl b fi kq kr l ks kt">#do the fitting<br/>fit &lt;- arima(x,order=c(0,0,1),include.mean=FALSE)<br/>coeftest(fit)<br/>#confidence interval around it:<br/>confint(fit, parm=c("ma1"), level=0.95)</span></pre><p id="afcb" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">系数测试的输出为:</p><pre class="kg kh ki kj fd kk kl km kn aw ko bi"><span id="4b75" class="kp ig hi kl b fi kq kr l ks kt">z test of coefficients:</span><span id="58e8" class="kp ig hi kl b fi ku kr l ks kt">Estimate Std. Error z value Pr(&gt;|z|)<br/>ma1  0.22259    0.15500   1.436    0.151</span></pre><p id="cc5a" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">置信区间:</p><pre class="kg kh ki kj fd kk kl km kn aw ko bi"><span id="e29d" class="kp ig hi kl b fi kq kr l ks kt">2.5 %    97.5 %<br/>ma1 -0.08121368 0.5263858</span></pre><p id="234c" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">经过50次观察后，置信区间相当宽，估计值略有偏差。让我们研究一下这种改进有多快:这个序列需要多长时间才能将置信区间紧紧包围在输入参数β=0.3周围。</p><pre class="kg kh ki kj fd kk kl km kn aw ko bi"><span id="41b5" class="kp ig hi kl b fi kq kr l ks kt"># generate a grid for different process lengths:<br/>n.grid &lt;- round(1.3^(2:40))<br/>summary(n.grid)<br/>n.length &lt;- length(n.grid)<br/>#reserve some space for the results<br/>uppers &lt;- vector(length = n.length)<br/>lowers &lt;- vector(length = n.length)<br/>estimates &lt;- vector(length = n.length)<br/>counter &lt;- 1<br/>#iterate through the different process lengths and save the estimator<br/>#as well as the confidence interval boundaries:<br/>for(n in n.grid){<br/>  #generate the data:<br/>  eps &lt;- rnorm(n)<br/>  x &lt;- vector(length = n)<br/>  x[1] &lt;- eps[1]<br/>  for(i in 2:n){<br/>    x[i] &lt;- eps[i]+beta*eps[i-1]<br/>  }<br/>  fit &lt;- arima(x,order=c(0,0,1),include.mean = FALSE)<br/>  conf &lt;- confint(fit, parm=c("ma1"), level=0.95)<br/>  estimates[counter] &lt;-  fit$coef[1]<br/>  uppers[counter] &lt;- conf[2]<br/>  lowers[counter] &lt;- conf[1]<br/>  <br/>  counter &lt;- counter+1<br/>}</span></pre><p id="d97e" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">现在绘制不同时间序列长度的估计量的发展表明:</p><figure class="kg kh ki kj fd kw er es paragraph-image"><div class="er es kv"><img src="../Images/3a26b84acb51f16d3bbb406b2f913c79.png" data-original-src="https://miro.medium.com/v2/resize:fit:1344/format:webp/1*4FGHWiy55A1v8fx1jGL5Qg.png"/></div></figure><p id="623c" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">奇怪的是，大量的观察甚至没有达到“真实”值。让我们通过对具有相同数量观察值的多个估计值进行平均，来看看这是虚假的还是存在估计偏差:</p><pre class="kg kh ki kj fd kk kl km kn aw ko bi"><span id="c465" class="kp ig hi kl b fi kq kr l ks kt">n &lt;- 5000<br/>n.reps &lt;- 2000<br/>coeffs &lt;- vector(length=n.reps)</span><span id="3775" class="kp ig hi kl b fi ku kr l ks kt">for(j in 1:n.reps){<br/>  #generate the data:<br/>  eps &lt;- rnorm(n)<br/>  x &lt;- vector(length = n)<br/>  x[1] &lt;- eps[1]<br/>  for(i in 2:n){<br/>    x[i] &lt;- eps[i]+beta*eps[i-1]<br/>  }<br/>  fit &lt;- arima(x,order=c(0,0,1), include.mean = FALSE)<br/>  coeffs[j] &lt;- fit$coef[1]<br/>}</span><span id="3793" class="kp ig hi kl b fi ku kr l ks kt">summary(coeffs)</span></pre><p id="1801" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">带输出:</p><pre class="kg kh ki kj fd kk kl km kn aw ko bi"><span id="6141" class="kp ig hi kl b fi kq kr l ks kt">&gt; summary(coeffs)<br/>   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. <br/> 0.2471  0.2909  0.3002  0.3003  0.3095  0.3441</span></pre><p id="8af4" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">因此，正如所料，对于大量重复，估计量是无偏的。</p><h1 id="c0a1" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">含义</h1><p id="56b4" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">为了得到足够紧的置信区间，观察值的数量需要很大，这重要吗？β=0.3和β=0.35的系数有什么区别，因为它指的是过去未观察到的随机冲击。</p><p id="0bd6" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">让我们研究一下在这些情况下的预测能力。生成一个50，000长的时间序列，对其应用MA(1)过程，并创建一个5步预测:</p><pre class="kg kh ki kj fd kk kl km kn aw ko bi"><span id="0207" class="kp ig hi kl b fi kq kr l ks kt">n &lt;- 50000<br/>eps &lt;- rnorm(n)<br/>x &lt;- vector(length = n)<br/>x[1] &lt;- eps[1]<br/>for(i in 2:n){<br/>  x[i] &lt;- eps[i]+beta*eps[i-1]<br/>}<br/>#fit the MA(1) model to the process:<br/>fit &lt;- arima(x,order=c(0,0,1),include.mean=FALSE)<br/>#generate the 5 step prediction:<br/>predict(fit, n.ahead=5)</span></pre><p id="f3a1" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">输出:</p><pre class="kg kh ki kj fd kk kl km kn aw ko bi"><span id="1679" class="kp ig hi kl b fi kq kr l ks kt">$pred<br/>Time Series:<br/>Start = 50001 <br/>End = 50005 <br/>Frequency = 1 <br/>[1] 0.1125964 0.0000000 0.0000000 0.0000000 0.0000000</span><span id="2c4d" class="kp ig hi kl b fi ku kr l ks kt">$se<br/>Time Series:<br/>Start = 50001 <br/>End = 50005 <br/>Frequency = 1 <br/>[1] 0.9961955 1.0415099 1.0415099 1.0415099 1.0415099</span></pre><h1 id="a4da" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">对不起:预测MA模型</h1><p id="8ff2" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">奇怪的是，上述模型的预测在一个周期后中断了。让我们迅速调查一下这是怎么回事。</p><p id="497e" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">我们使用的最简单形式的MA(1)模型由下式给出</p><figure class="kg kh ki kj fd kw er es paragraph-image"><div class="er es kz"><img src="../Images/24cf2fb852323a493169682ca8d9f7ce.png" data-original-src="https://miro.medium.com/v2/resize:fit:328/format:webp/1*UE-QSnK5YwdkAMD6R1CQ2g.png"/></div></figure><p id="f2a2" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">因此，一个时期的预测由下式给出</p><figure class="kg kh ki kj fd kw er es paragraph-image"><div class="er es la"><img src="../Images/b290168f7f3fe29f54f7a671ab98d26c.png" data-original-src="https://miro.medium.com/v2/resize:fit:720/format:webp/1*XOcuBymODYya5aMf6aDy5Q.png"/></div></figure><p id="5792" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">所有的预测都以过去为条件</p><figure class="kg kh ki kj fd kw er es paragraph-image"><div class="er es lb"><img src="../Images/becd05025887ae468717eac130341e08.png" data-original-src="https://miro.medium.com/v2/resize:fit:552/format:webp/1*1f-o-t3HkmZgpPAqly6uEw.png"/></div></figure><p id="e125" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">MA(p)过程的基本假设是误差项是iid。随着</p><figure class="kg kh ki kj fd kw er es paragraph-image"><div class="er es lc"><img src="../Images/b2069cb17468aa49d2adce4689ff0a2c.png" data-original-src="https://miro.medium.com/v2/resize:fit:272/format:webp/1*LIFpvzReldPzSt_BZSn7sA.png"/></div></figure><p id="4f62" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">因此，</p><figure class="kg kh ki kj fd kw er es paragraph-image"><div class="er es ld"><img src="../Images/6f74c8b33f3a110a50a0331536a2c718.png" data-original-src="https://miro.medium.com/v2/resize:fit:288/format:webp/1*pcp_XCnbEjiZjdl0953FfQ.png"/></div></figure><p id="f272" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">所以上式中的剩余项，</p><figure class="kg kh ki kj fd kw er es paragraph-image"><div class="er es le"><img src="../Images/30f19203191a5d389c24732f38fdb9cb.png" data-original-src="https://miro.medium.com/v2/resize:fit:84/format:webp/1*FJuLTpVgWQLkqdCqOlG8rQ.png"/></div></figure><p id="1603" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">可以递归计算。因此，使用滞后操作符符号(<a class="ae lf" href="https://en.wikipedia.org/wiki/Lag_operator" rel="noopener ugc nofollow" target="_blank">https://en.wikipedia.org/wiki/Lag_operator</a>)重写过程描述Xt:</p><figure class="kg kh ki kj fd kw er es paragraph-image"><div class="er es lg"><img src="../Images/f79b2ba67a6952254e6812db225c9334.png" data-original-src="https://miro.medium.com/v2/resize:fit:336/format:webp/1*_HtlV7Y1Nl5gpW0OaNA04w.png"/></div></figure><p id="fa53" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">因此</p><figure class="kg kh ki kj fd kw er es paragraph-image"><div class="er es lh"><img src="../Images/e914efe1a3b476bd048dd6dd119eb5c4.png" data-original-src="https://miro.medium.com/v2/resize:fit:252/format:webp/1*d-CQpCU0ILrH3RPPP4tRFA.png"/></div></figure><p id="84b2" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">请注意，1/(1−x)=1+x+x2+x3+⋯的级数展开可以通过用x代替x来转换</p><figure class="kg kh ki kj fd kw er es paragraph-image"><div class="er es li"><img src="../Images/718c186fbfc6e4a4a4f29cd1540fe11b.png" data-original-src="https://miro.medium.com/v2/resize:fit:616/format:webp/1*r9EDksWQFkiqYytMZ8dqcQ.png"/></div></figure><p id="97fc" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">因此，我们可以计算ϵt|It:</p><figure class="kg kh ki kj fd kw er es paragraph-image"><div class="er es lj"><img src="../Images/de3d9401c6961a53afa2697392373f38.png" data-original-src="https://miro.medium.com/v2/resize:fit:1264/format:webp/1*D03s8gJEgcDb9ozEeaCw1Q.png"/></div></figure><p id="d447" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">既然我们知道{Xt}的级数，我们也可以计算出未观测到的{ϵt}.级数还要注意，MA(1)过程只能预测一个步骤，因为</p><figure class="kg kh ki kj fd kw er es paragraph-image"><div class="er es lk"><img src="../Images/86a9f1e8a205e9b4cb5b05c60eb1de42.png" data-original-src="https://miro.medium.com/v2/resize:fit:944/format:webp/1*LBQc_9LZN9tcyLmveakF5Q.png"/></div></figure><p id="0e91" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">这是因为随机误差项是独立分布的。</p><p id="d885" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">让我们回到起点。我们这样做的原因是为了了解预测质量是否确实是预测MA(1)模型的一个问题。在我们的具体例子中，β=0.3和β=0.35之间的差异可以计算如下:</p><pre class="kg kh ki kj fd kk kl km kn aw ko bi"><span id="2cb7" class="kp ig hi kl b fi kq kr l ks kt">forecast.errors &lt;- vector(length=1000)<br/>#construct the vector of betas<br/>beta03.vec &lt;- (-0.3)^(0:(n-1)) <br/>beta035.vec &lt;- (-0.35)^(0:(n-1))<br/>for(i in 1:1000){<br/>  #one step forecast (as described above):<br/>  X03 &lt;- sum(beta03.vec*rev(x))*0.3<br/>  X035 &lt;- sum(beta035.vec*rev(x))*0.35<br/>  #percentage error:<br/>  forecast.errors[i] &lt;- (X035/X03-1)^2<br/>}<br/>mean(sqrt(forecast.errors))</span></pre><p id="7108" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">结果是0.32-因此，当β的估计略有不同时，预测会偏离32% (RMSE)。</p><h1 id="d7bb" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">外卖食品</h1><ul class=""><li id="10eb" class="ll lm hi jf b jg jh jk jl jo ln js lo jw lp ka lq lr ls lt bi translated">MA(p)模型只能预测p期间。</li><li id="6bc3" class="ll lm hi jf b jg lu jk lv jo lw js lx jw ly ka lq lr ls lt bi translated">尽管只估计了一个参数，但这些模型需要足够的样本量来获得窄的置信区间</li><li id="09db" class="ll lm hi jf b jg lu jk lv jo lw js lx jw ly ka lq lr ls lt bi translated">检查置信区间宽度并调查对预测质量的影响是很重要的</li><li id="0652" class="ll lm hi jf b jg lu jk lv jo lw js lx jw ly ka lq lr ls lt bi translated">对于经典的运筹学任务，有更好的拟合模型:通常通过调查曲线的潜在驱动因素可以更好地预测体积曲线，而不是遵循纯粹的单变量时间序列方法。</li></ul></div></div>    
</body>
</html>