<html>
<head>
<title>Support Vector Machine.</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">支持向量机。</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/support-vector-machine-92fa3c57d33b?source=collection_archive---------1-----------------------#2021-10-13">https://medium.com/nerd-for-tech/support-vector-machine-92fa3c57d33b?source=collection_archive---------1-----------------------#2021-10-13</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="6789" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">支持向量机是强大而灵活的监督机器学习算法，用于分类和回归。但一般都是用在分类问题上。</p><p id="1a34" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在20世纪60年代，支持向量机首次被引入，但后来在1990年得到了完善。与其他机器学习算法相比，支持向量机有其独特的实现方式。最近，它们非常受欢迎，因为它们能够处理多个连续和分类变量。</p><p id="f29a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">SVM模型基本上是多维空间中超平面中不同类别的表示。超平面将由SVM以迭代的方式生成，从而可以最小化误差。SVM的目标是将数据集分类以找到最大边际超平面(MMH)。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es jd"><img src="../Images/97adb24656f3450d29a999c6c7fcd66a.png" data-original-src="https://miro.medium.com/v2/resize:fit:764/format:webp/0*n54VpUEweFg2n64L.png"/></div></figure><p id="54a4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">例子:SVM可以用我们在KNN分类器中用过的例子来理解。假设我们看到一只奇怪的猫，它也具有狗的一些特征，那么如果我们想要一个能够准确识别它是猫还是狗的模型，那么这样的模型可以通过使用SVM算法来创建。</p><p id="6927" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们将首先用大量猫和狗的图像训练我们的模型，以便它可以学习猫和狗的不同特征，然后我们用这种奇怪的生物测试它。因此，当支持向量在这两个数据(猫和狗)之间创建决策边界并选择极端情况(支持向量)时，它将看到猫和狗的极端情况。在支持向量的基础上，它将把它归类为猫。考虑下图:</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es jl"><img src="../Images/4f763c7d07b3c001b8a2a259f071e060.png" data-original-src="https://miro.medium.com/v2/resize:fit:880/format:webp/0*dGdGJtyUMDXNveJE.png"/></div></figure><p id="ed1e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">SVM算法可用于人脸检测、图像分类、文本分类等。</p><h1 id="4c7b" class="jm jn hi bd jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj bi translated">SVM的类型</h1><p id="6286" class="pw-post-body-paragraph if ig hi ih b ii kk ik il im kl io ip iq km is it iu kn iw ix iy ko ja jb jc hb bi translated">SVM有两种类型:</p><p id="47e6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">线性SVM:线性SVM用于线性可分数据，这意味着如果一个数据集可以用一条直线分成两类，那么这样的数据称为线性可分数据，使用的分类器称为线性SVM分类器。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es kp"><img src="../Images/c450dc8a27199cfa4768842cdb8a1795.png" data-original-src="https://miro.medium.com/v2/resize:fit:1016/format:webp/0*xRwBCeMVtWh7MuOc.png"/></div></figure><p id="522a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">非线性SVM:非线性SVM用于非线性分离的数据，这意味着如果数据集不能通过使用直线进行分类，那么这种数据被称为非线性数据，所使用的分类器被称为非线性SVM分类器。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es kq"><img src="../Images/95082d4a1a65e70facc204e7ca82534e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1244/format:webp/0*ghi4CduwdcAuWiTW.png"/></div></figure><h1 id="1145" class="jm jn hi bd jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj bi translated">线性SVM对非线性SVM</h1><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es kr"><img src="../Images/2b54aac56adcc23f720d061b28f74621.png" data-original-src="https://miro.medium.com/v2/resize:fit:1336/format:webp/0*MyxCAAG4u2IMLaoV.png"/></div></figure><h1 id="51c7" class="jm jn hi bd jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj bi translated">SVM的概念:</h1><p id="e452" class="pw-post-body-paragraph if ig hi ih b ii kk ik il im kl io ip iq km is it iu kn iw ix iy ko ja jb jc hb bi translated"><strong class="ih hj">支持向量</strong>—最接近超平面的数据点称为支持向量。在这些数据点的帮助下，将定义一条分隔线。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es ks"><img src="../Images/b3e559d7b25c0f0c4331e1a2f1edf1c1.png" data-original-src="https://miro.medium.com/v2/resize:fit:894/format:webp/0*ugYJCbTbGXfNi77s.png"/></div></figure><p id="7e2d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">超平面</strong>——从上图中我们可以看出，它是一个决策平面或空间，在一组不同类别的对象之间进行划分。</p><p id="1ca2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">边距</strong>——它可以定义为不同类别的最近数据点上的两条线之间的间隙。它可以计算为从直线到支持向量的垂直距离。大的边距被认为是好的边距，小的边距被认为是差的边距。</p><p id="4183" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">SVM的主要目标是将数据集分类，以找到最大边际超平面(MMH ),它可以通过以下两步完成</p><p id="103a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">首先，SVM将迭代生成超平面，以最佳方式分离类。</p><p id="d2e4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">然后，它将选择正确划分类别的超平面。</p><h1 id="6766" class="jm jn hi bd jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj bi translated">SVM内核:</h1><p id="09d8" class="pw-post-body-paragraph if ig hi ih b ii kk ik il im kl io ip iq km is it iu kn iw ix iy ko ja jb jc hb bi translated">SVM算法通过将输入数据空间转换成所需形式的内核来实现。SVM使用了一种称为内核技巧的技术，内核采用低维输入空间，将其转换到高维空间。简单来说，内核通过给不可分问题增加更多的维度，把不可分问题转化为可分问题。它使SVM更加强大、灵活和准确。以下是SVM使用的一些内核类型。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="er es kt"><img src="../Images/48719456ce99c57b60f90a7e8a5489b1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*y_Jka3UbersDXnWJYVsiZw.png"/></div></div></figure><p id="6938" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">线性核:</strong></p><p id="4ce0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">它可以用作任意两个观察值之间的点积。线性核的公式如下</p><p id="a29e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">K(x，Xi)=总和(x÷Xi)</p><p id="f827" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">从上面的公式中，我们可以看到，两个矢量之间的乘积，比如𝑥 &amp; 𝑥𝑖，是每对输入值的乘积之和。</p><p id="db22" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">多项式内核:</strong></p><p id="4979" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">它是线性核的更一般化的形式，并区分弯曲或非线性输入空间。以下是多项式核的公式</p><p id="ea9e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">k(X,Xi)=1+sum(X∗Xi)^d</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es ky"><img src="../Images/4624653259ee9036059ea81d561f6141.png" data-original-src="https://miro.medium.com/v2/resize:fit:406/format:webp/0*rVF6B5ejGr0hDOoV.png"/></div></figure><p id="1ada" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这里d是多项式的次数，我们需要在学习算法中手动指定。</p><p id="3fb8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">高斯核:</strong></p><p id="ecd5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">它是一个通用内核；当没有关于数据的先验知识时使用。等式是:</p><p id="ee74" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">高斯核方程:</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="er es kz"><img src="../Images/974408deba780827f8fec332919fed0d.png" data-original-src="https://miro.medium.com/v2/resize:fit:448/format:webp/0*VApbmToIUEiR3STn.png"/></div></div></figure><p id="1dc4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">径向基函数(RBF)核:</strong></p><p id="e27c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">RBF核主要用于SVM分类，将输入空间映射到无限维空间。它是一个通用内核；当没有关于数据的先验知识时使用。</p><p id="ee41" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">下面的公式从数学上解释了这一点</p><p id="98a3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">K(x，xi)=exp(伽玛总和(x Xi))</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es la"><img src="../Images/701ef0c237f69280b84be6933b16a3d5.png" data-original-src="https://miro.medium.com/v2/resize:fit:356/format:webp/0*RMlGWdxm-KXu2wVG.png"/></div></figure><p id="f78f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这里，伽玛的范围是从0到1。我们需要在学习算法中手动指定。gamma的一个很好的默认值是0.1。</p><p id="69d4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">当我们为线性可分的数据实现SVM时，我们可以用Python为非线性可分的数据实现它。这可以通过使用内核来实现。</p><p id="1785" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">拉普拉斯RBF核</strong></p><p id="24b2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">它是一个通用内核；当没有关于数据的先验知识时使用。</p><p id="7541" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">等式是:</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es kz"><img src="../Images/6b276af6ede40fe6ba3525c23c787e30.png" data-original-src="https://miro.medium.com/v2/resize:fit:448/format:webp/0*FzTmkkUF-w3hfkJA.png"/></div></figure><p id="e630" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">双曲正切核:</strong></p><p id="faca" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们可以在神经网络中使用它。等式是:</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es lb"><img src="../Images/2baacc1811d9b7603f23112e40349224.png" data-original-src="https://miro.medium.com/v2/resize:fit:500/format:webp/0*_tZJcSO24_gT5FnI.png"/></div></figure><p id="74e0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">乙状结肠内核:</strong></p><p id="9f52" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们可以用它作为神经网络的代理。等式是:</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es lc"><img src="../Images/d88a62b3910a4cec0fabc3fbeee09298.png" data-original-src="https://miro.medium.com/v2/resize:fit:404/format:webp/0*0XWF0T9ZdSiTthsl.png"/></div></figure><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es ld"><img src="../Images/5b3c88ffafc989623f12d0f20b70a980.png" data-original-src="https://miro.medium.com/v2/resize:fit:436/format:webp/0*KzGm4vAt1ZCxkP2q.png"/></div></figure><p id="e6cd" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">第一类核的贝塞尔函数:</strong></p><p id="89e8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们可以用它来去除数学函数中的交叉项。等式是:</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es le"><img src="../Images/6c05967a7e6024e9eaa25497121f71c0.png" data-original-src="https://miro.medium.com/v2/resize:fit:412/format:webp/0*pVjJd4NuTvB2nL1T.png"/></div></figure><p id="5e65" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">方差分析径向基核:</strong></p><p id="dbae" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们可以在回归问题中使用它。等式是:</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es lf"><img src="../Images/a82ed8d36d393a96db05b5f3e2fd85d3.png" data-original-src="https://miro.medium.com/v2/resize:fit:542/format:webp/0*qx1Ug3Q38IZVkTO0.png"/></div></figure><h1 id="8013" class="jm jn hi bd jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj bi translated">SVM的利与弊:</h1><p id="cdc6" class="pw-post-body-paragraph if ig hi ih b ii kk ik il im kl io ip iq km is it iu kn iw ix iy ko ja jb jc hb bi translated"><strong class="ih hj">优点:</strong></p><p id="7dd2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">它工作得很好，有一个清晰的分离边界</p><p id="170c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在高维空间是有效的。</p><p id="1d94" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">它在维数大于样本数的情况下是有效的。</p><p id="e489" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">它在决策函数中使用训练点的子集(称为支持向量)，因此它也是内存高效的。</p><p id="9cf8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">缺点:</strong></p><p id="2627" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">当我们拥有大数据集时，它的性能并不好，因为所需的训练时间更长。</p><p id="ffe1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">当数据集有更多噪声时，即目标类重叠时，它的性能也不是很好</p><p id="a39b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">SVM没有直接提供概率估计，这些是通过昂贵的五重交叉验证计算出来的。它包含在Python scikit-learn库的相关SVC方法中。</p><h1 id="3c6d" class="jm jn hi bd jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj bi translated">SVM的指标:</h1><p id="a41e" class="pw-post-body-paragraph if ig hi ih b ii kk ik il im kl io ip iq km is it iu kn iw ix iy ko ja jb jc hb bi translated"><strong class="ih hj"> 1。混乱矩阵:</strong></p><p id="6c53" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">混淆矩阵是一个N×N矩阵，其中N是被预测的类的数量。对于手头的问题，我们有N=2，因此我们得到一个2×2矩阵。对于混淆矩阵，您需要记住以下几个定义:</p><p id="77a1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">准确性:正确预测总数的比例。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es lg"><img src="../Images/713aca4654cfba1fa4050d53a10d5bb7.png" data-original-src="https://miro.medium.com/v2/resize:fit:900/format:webp/0*rZ-xsvUEPvlSe-vz.png"/></div></figure><p id="cfce" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">阳性预测值或精确度:被正确识别的阳性病例的比例。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es lh"><img src="../Images/31778ccefdc21757a4a98e8896712d17.png" data-original-src="https://miro.medium.com/v2/resize:fit:708/format:webp/0*vHccCajwB5veN-GX.png"/></div></figure><p id="b066" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">阴性预测值:被正确识别的阴性病例的比例。</p><p id="743f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">敏感性或回忆:被正确识别的实际阳性病例的比例。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es li"><img src="../Images/2f6e954dee98fe6f5cdba02217bf6077.png" data-original-src="https://miro.medium.com/v2/resize:fit:684/format:webp/0*NtFJGNzROz3vE3dx.png"/></div></figure><p id="94f6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">特异性:被正确识别的实际阴性病例的比例。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es lj"><img src="../Images/d84d506ed3b1fa56a3c136ad5b45791b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1248/format:webp/0*I0RUOdzmj-OlfwTH.png"/></div></figure><p id="4abc" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> 2。F1得分:</strong></p><p id="c623" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这是精度和召回率的调和平均值，并且给出了比精度度量更好的错误分类情况的度量。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es lk"><img src="../Images/a8121e257394a927a50b1f50a5eff1a2.png" data-original-src="https://miro.medium.com/v2/resize:fit:940/format:webp/0*8u6zRDxfW9IN5FXt.png"/></div></figure><p id="ac9a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们使用调和平均值，因为它不利于极值。</p><p id="3298" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">总结F1分数和准确性之间的差异，</p><p id="cc07" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">当真阳性和真阴性更重要时使用准确度，而当假阴性和假阳性至关重要时使用F1分数。</p><p id="cb68" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">当类别分布相似时，可以使用精确度，而当存在不平衡的类别时，F1分数是更好的度量，如上述情况。</p><p id="507a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在大多数现实生活的分类问题中，存在不平衡的类别分布，因此F1-score是评估我们的模型的更好的度量。</p><h1 id="2311" class="jm jn hi bd jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj bi translated">SVM的应用</h1><ul class=""><li id="143a" class="ll lm hi ih b ii kk im kl iq ln iu lo iy lp jc lq lr ls lt bi translated">情感分析。</li><li id="0cc9" class="ll lm hi ih b ii lu im lv iq lw iu lx iy ly jc lq lr ls lt bi translated">垃圾邮件检测。</li><li id="38d1" class="ll lm hi ih b ii lu im lv iq lw iu lx iy ly jc lq lr ls lt bi translated">手写数字识别。</li><li id="7a10" class="ll lm hi ih b ii lu im lv iq lw iu lx iy ly jc lq lr ls lt bi translated">图像识别挑战</li></ul><p id="4028" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">参考:</strong> <a class="ae lz" href="https://www.tutorialspoint.com/machine_learning_with_python/machine_learning_with_python_classification_algorithms_support_vector_machine.htm" rel="noopener ugc nofollow" target="_blank">教程观点</a>，<a class="ae lz" href="https://www.analyticsvidhya.com/blog/2017/09/understaing-support-vector-machine-example-code/" rel="noopener ugc nofollow" target="_blank">分析观点</a>，<a class="ae lz" href="https://data-flair.training/blogs/svm-kernel-functions/" rel="noopener ugc nofollow" target="_blank">数据观点</a></p></div></div>    
</body>
</html>