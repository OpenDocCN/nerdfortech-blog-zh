<html>
<head>
<title>0–1 Knapsack Problem</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">0-1背包问题</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/0-1-knapsack-problem-85d95f8d724e?source=collection_archive---------3-----------------------#2021-11-17">https://medium.com/nerd-for-tech/0-1-knapsack-problem-85d95f8d724e?source=collection_archive---------3-----------------------#2021-11-17</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="0b9f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">你好，编码伙伴们。今天我们将研究背包问题。</p><p id="732d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">基本上，背包意味着一个袋子。我们的目标很简单。给我们N个项目，它们各自的权重为Wt[]，利润或价值为p[]。并且该袋子(背包)具有一定的容量w。我们需要以非常有效的方式将物品填充到袋子中，使得利润最大化，从而不超过容量。</p><p id="e6ca" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">0–1，此处表示该物品可以挑选0次或1次。也就是说，您可以选择整个项目，也可以根本不选择它。</p><p id="7cad" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">总而言之，</p><ol class=""><li id="4c24" class="jd je hi ih b ii ij im in iq jf iu jg iy jh jc ji jj jk jl bi translated">我们需要找到最大利润。</li><li id="9f49" class="jd je hi ih b ii jm im jn iq jo iu jp iy jq jc ji jj jk jl bi translated">物品可以挑选0或1次。</li><li id="3bc9" class="jd je hi ih b ii jm im jn iq jo iu jp iy jq jc ji jj jk jl bi translated">我们不能超过行李限额。</li></ol><p id="c1dc" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">因为我们有两个选择(选择或不选择)，所以总的组合是2*2*2*2*2……(N次)= 2pow(N)。</p><p id="4fa1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">时间复杂度= O(2次方(N))</p><p id="0767" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">提供给我们的信息包括:</p><p id="27fa" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">W =袋子中剩余的空间</p><p id="cac8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Wt[] =每个元素的重量</p><p id="7036" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">N =元素总数</p><p id="04cb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">p[] =每个要素的利润</p><figure class="js jt ju jv fd jw er es paragraph-image"><div role="button" tabindex="0" class="jx jy di jz bf ka"><div class="er es jr"><img src="../Images/79ab57bee5cf01c262c89a651e97eddf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LZf54ZGrGstrqrrP1dQWsg.png"/></div></div><figcaption class="kd ke et er es kf kg bd b be z dx translated">背包的输入</figcaption></figure><p id="3bc5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">背包问题可以用两种方法解决。一种是使用递归，另一种是使用dp表。给你。我们将使用递归来求解。</p><h1 id="73ae" class="kh ki hi bd kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le bi translated">基本条件:</h1><p id="e7c0" class="pw-post-body-paragraph if ig hi ih b ii lf ik il im lg io ip iq lh is it iu li iw ix iy lj ja jb jc hb bi translated">因为我们在这里使用递归，所以我们继续下去，直到:</p><ol class=""><li id="ec7c" class="jd je hi ih b ii ij im in iq jf iu jg iy jh jc ji jj jk jl bi translated">什么元素都没有了。(N = 0)</li><li id="4ed4" class="jd je hi ih b ii jm im jn iq jo iu jp iy jq jc ji jj jk jl bi translated">包里没有剩余的空间了。(W = 0)</li></ol><blockquote class="lk"><p id="dffa" class="ll lm hi bd ln lo lp lq lr ls lt jc dx translated"><code class="du lu lv lw lx b"><strong class="ak"><em class="ly">if</em></strong></code> <strong class="ak"> <em class="ly"> </em> </strong></p><p id="9021" class="ll lm hi bd ln lo lz ma mb mc md jc dx translated"><code class="du lu lv lw lx b"><strong class="ak"><em class="ly">return</em></strong></code><strong class="ak"><em class="ly"/></strong>T3】</p></blockquote><h1 id="ee3a" class="kh ki hi bd kj kk kl km kn ko kp kq kr ks me ku kv kw mf ky kz la mg lc ld le bi translated">决策树图表:</h1><figure class="js jt ju jv fd jw er es paragraph-image"><div role="button" tabindex="0" class="jx jy di jz bf ka"><div class="er es mh"><img src="../Images/c19ce574f12b806c96fbdd369a160656.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mGuTn26e1loI6Z5Ad2sEvA.png"/></div></div><figcaption class="kd ke et er es kf kg bd b be z dx translated">决策树图</figcaption></figure><p id="750f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在这里，我们将看到如何选择一个元素0或1次，以获得背包解决方案。</p><p id="4e62" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">首先，让我们考虑流程图的左侧。如果我们选择的元素的重量大于袋子中剩余的空间，那么很明显，我们必须跳过这个元素。</p><blockquote class="lk"><p id="6bf6" class="ll lm hi bd ln lo lz ma mb mc md jc dx translated"><code class="du lu lv lw lx b">if</code> <code class="du lu lv lw lx b">(Wt[N - 1] &gt; W)</code></p><p id="0c87" class="ll lm hi bd ln lo lz ma mb mc md jc dx translated"><code class="du lu lv lw lx b">return</code> <code class="du lu lv lw lx b">knapsack(W, Wt, p, N- 1);</code></p></blockquote><p id="02e8" class="pw-post-body-paragraph if ig hi ih b ii mi ik il im mj io ip iq mk is it iu ml iw ix iy mm ja jb jc hb bi translated">在上面的代码中，除了N之外，所有的参数都保持不变，因为我们已经访问了那个元素，并且跳过了它。所以我们把元素的数量减少了1。</p><p id="0d1c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在，考虑决策树图的右侧，当元素的权重小于或等于袋子中的剩余空间时，我们有两个选择:</p><p id="e7b6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">包含:</strong>当我们包含元素时，元素的重量会添加到包中。因此袋子里剩下的空间变成了，W-Wt，这里Wt是我们加入的元素的重量。由于元素N被访问，利润增加，元素N的数量减少1。</p><p id="1076" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> Skip: </strong>在这里，因为我们要跳过，所以除了N之外，其他所有参数都保持不变，因为N在被访问后减1。</p><p id="d94c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">从上面的两个选择中，我们将返回相加时产生最大利润的那个。我们将通过使用max函数来实现这一点。</p><blockquote class="lk"><p id="f305" class="ll lm hi bd ln lo lz ma mb mc md jc dx translated"><code class="du lu lv lw lx b">return</code> <code class="du lu lv lw lx b">max</code></p><p id="8ed7" class="ll lm hi bd ln lo lz ma mb mc md jc dx translated"><code class="du lu lv lw lx b">(p[N - 1]</code></p><p id="6fe9" class="ll lm hi bd ln lo lz ma mb mc md jc dx translated"><code class="du lu lv lw lx b">+ knapsack(W - Wt[N - 1],</code></p><p id="0cbc" class="ll lm hi bd ln lo lz ma mb mc md jc dx translated"><code class="du lu lv lw lx b">Wt, p, N- 1),</code></p><p id="dfd1" class="ll lm hi bd ln lo lz ma mb mc md jc dx translated"><code class="du lu lv lw lx b">knapsack(W, W t, p, N- 1));</code></p></blockquote><p id="213a" class="pw-post-body-paragraph if ig hi ih b ii mi ik il im mj io ip iq mk is it iu ml iw ix iy mm ja jb jc hb bi translated">我们将继续执行上述步骤，直到我们达到基本条件，即包中没有剩余空间或没有剩余元素。因此，这就是如何使用递归来解决0–1背包问题。</p><p id="6a19" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">希望你们都觉得这个博客足智多谋，如果你们能鼓掌，我会非常感激，因为这将鼓励我想出更多的这些。</p><p id="5fab" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">谢谢…..</p></div></div>    
</body>
</html>