<html>
<head>
<title>Building Unit Of Work Support for JDBI in Dropwizard Part — III</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在 Dropwizard 中为 JDBI 构建工作单元支持—第三部分</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/building-unit-of-work-support-for-jdbi-in-dropwizard-part-iii-d9d0b1e245c3?source=collection_archive---------1-----------------------#2020-06-28">https://medium.com/nerd-for-tech/building-unit-of-work-support-for-jdbi-in-dropwizard-part-iii-d9d0b1e245c3?source=collection_archive---------1-----------------------#2020-06-28</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/60152de704cb4b28c93e53115644c143.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Bu4SdrkLuBCMk3SGyYMV3w.png"/></div></div></figure><p id="8ad4" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在本文中，我们继续我们的<a class="ae jo" rel="noopener" href="/@aman_garg/building-unit-of-work-support-for-jdbi-in-dropwizard-part-ii-4857ca6c48cf">旅程</a>在 Dropwizard 中构建对 JDBI 工作单元的支持。</p><p id="47ec" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">已经描述了<code class="du jp jq jr js b">Jdbi Handle Manager</code>、<code class="du jp jq jr js b">Event listeners</code>、<code class="du jp jq jr js b">Transaction Aspect</code>和<code class="du jp jq jr js b">resource</code>层如何在联络中工作，现在我们将注意力转向<code class="du jp jq jr js b">handle</code>管理器的可能实现。</p><p id="20ba" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">回想一下，Jdbi <code class="du jp jq jr js b">Handle</code>经理的合同。</p><figure class="ju jv jw jx fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es jt"><img src="../Images/7e6d7d4dec0fbc508cb1b8201839e703.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Kf2NuZzo3MMAB_qcnsk-dw.png"/></div></div><figcaption class="jy jz et er es ka kb bd b be z dx translated">手柄管理器的合同</figcaption></figure><p id="37e4" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">虽然契约看起来很简单(<em class="kc">和实现太过</em>)，但是在这里做出了为线程提供<code class="du jp jq jr js b">handle</code>的最重要的决定。</p><figure class="ju jv jw jx fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es kd"><img src="../Images/e1b8a1994bc0a352d7f0726567ca88ce.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WuNZ6k_sy3TtUSbPBwGT6w.png"/></div></div><figcaption class="jy jz et er es ka kb bd b be z dx translated">管理器#get()的调用站点</figcaption></figure><p id="57c6" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">先说说<code class="du jp jq jr js b">HandleManager#get()</code></p><p id="3223" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们的<code class="du jp jq jr js b">proxied</code> Dao 需要获得一个活动句柄，然后才能在<code class="du jp jq jr js b">SQL Object</code>的上下文中使用它。如果它没有被提供，或者更糟，为 null，它将在调用堆栈中抛出一个异常。</p><p id="388c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">此外，我们需要提供一种方法来清除<code class="du jp jq jr js b">handle</code>，一旦任务完成，或者池可能很快用完句柄。</p><p id="45e9" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">默认 Jdbi 句柄管理器</strong></p><p id="daca" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">那么，实现这样一个句柄管理器的最简单的方法是什么呢？例如，我们可以在每次调用<code class="du jp jq jr js b">#get()</code>方法时使用数据源打开一个真实的句柄。我们的<code class="du jp jq jr js b">clear()</code>实现将会是空的或者抛出一个<code class="du jp jq jr js b">NotSupportedOperationException</code></p><figure class="ju jv jw jx fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ke"><img src="../Images/eb97be5ed0e16e7072372047d6e8242f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qcqj_9nOJGBRDIMkYbElJA.png"/></div></div><figcaption class="jy jz et er es ka kb bd b be z dx translated">默认 Jdbi 句柄管理器实现</figcaption></figure><p id="2935" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">由于每次打开并返回一个新的<code class="du jp jq jr js b">handle</code>，应用程序将很快用完<code class="du jp jq jr js b">handles</code>。</p><p id="8dbb" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">此外，当<code class="du jp jq jr js b">Dao</code>被代理时，如果一个线程对<code class="du jp jq jr js b">Dao</code>的多个方法发出请求，或者对另一个<code class="du jp jq jr js b">Dao</code>的一个方法发出请求，它将创建一个新的句柄。因此，我们没有办法用多种方法实现一个事务上下文。</p><blockquote class="kf kg kh"><p id="de64" class="iq ir kc is b it iu iv iw ix iy iz ja ki jc jd je kj jg jh ji kk jk jl jm jn hb bi translated"><em class="hi">这个实现可以用于服务那些只与单个句柄中的单个方法交互的请求。</em></p></blockquote><p id="e3c6" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">虽然显然不适合生产用例，但它可以在嵌入式数据库测试中找到自己的位置。</p><p id="3afa" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">请求范围的 Jdbi 句柄管理器</strong></p><p id="95a2" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">考虑到默认经理的局限性，我们意识到我们的<code class="du jp jq jr js b">handle</code>经理需要具备以下能力，以便整合整个画面。</p><ul class=""><li id="a253" class="kl km hi is b it iu ix iy jb kn jf ko jj kp jn kq kr ks kt bi translated">服务请求的线程所涉及的每个<code class="du jp jq jr js b">Dao</code>都需要共享一个公共的<code class="du jp jq jr js b">handle</code>。句号。</li><li id="d4d0" class="kl km hi is b it ku ix kv jb kw jf kx jj ky jn kq kr ks kt bi translated">句柄在其生存期内作用于线程。一旦线程完成处理，它应该释放句柄。</li></ul><p id="66ef" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">以上两个用例要求我们实现一个<code class="du jp jq jr js b"><a class="ae jo" href="https://docs.oracle.com/javase/7/docs/api/java/lang/ThreadLocal.html" rel="noopener ugc nofollow" target="_blank">ThreadLocal</a></code>变量，它代表与当前线程相关联的句柄。没有其他线程需要处理这个<code class="du jp jq jr js b">handle</code>(双关语)</p><figure class="ju jv jw jx fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es kz"><img src="../Images/c257fce6f73aa7db7958d6cb2be3de9f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vrDiT1IYR9xTidw14NDZbw.png"/></div></div><figcaption class="jy jz et er es ka kb bd b be z dx translated">请求范围的句柄管理器(日志省略)</figcaption></figure><p id="d286" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">所有的<code class="du jp jq jr js b">SQL objects</code>都连接到一个共同的手柄上。这使得一个事务边界跨越不同<code class="du jp jq jr js b">Dao</code>类中的多个<code class="du jp jq jr js b">Dao</code>访问方法。</p><p id="0069" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这意味着，您现在可以拥有一个跨越由不同的<code class="du jp jq jr js b">Dao</code>类支持的多个数据源/表的事务</p><p id="a26e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">这个管用。确实如此。</strong> <br/>然而，它依赖于我们恰当地调用<code class="du jp jq jr js b">#clear()</code>方法。</p><p id="6774" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们通过在<code class="du jp jq jr js b">JdbiUnitOfWorkEventListener</code>中处理的<code class="du jp jq jr js b">FINISHED</code> Jersey 请求监控事件调用的<code class="du jp jq jr js b">JdbiTransactionAspect</code>来实现这一点。这两个类在本文前面的部分都有详细的讨论。</p><figure class="ju jv jw jx fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es la"><img src="../Images/eeca9971a176e4a900a9118ecef5866f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*POIYAqUJpRvDTZzZWR4TQQ.png"/></div></div><figcaption class="jy jz et er es ka kb bd b be z dx translated">我们的事件监听器清理钩子</figcaption></figure><figure class="ju jv jw jx fd ij er es paragraph-image"><div class="er es lb"><img src="../Images/c1059e01c6573cb51bd681796f6f25cd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1120/format:webp/1*j4rpbQipQeG5tKHgaNmsjg.png"/></div><figcaption class="jy jz et er es ka kb bd b be z dx translated">通过方面，我们取消了 finally 块中句柄的引用</figcaption></figure><p id="8b9f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">虽然我们确实需要考虑这里和那里的异常，但是一个<code class="du jp jq jr js b">finally</code>块总是帮助我们清除句柄。</p><p id="a407" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">就是这样。我们现在已经实现了一个请求范围的<code class="du jp jq jr js b">handle</code>管理器，它是由请求<code class="du jp jq jr js b">thread</code>调用的代理<code class="du jp jq jr js b">Dao</code>类调用的，请求<code class="du jp jq jr js b">thread</code>的事件由事件<code class="du jp jq jr js b">listener</code>监控</p><p id="b0cb" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">请求范围的线程处理程序</strong>适用于大多数生产用例。然而，只有一个小限制。<em class="kc">看看能不能搞清楚。</em></p><p id="737d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">因为<code class="du jp jq jr js b">ThreadLocal</code> <code class="du jp jq jr js b">handle</code>被分配给了每个线程，所以单个线程永远不会产生多个并发与数据库对话的 IO 线程。</p><p id="ae3f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">为什么是</strong>？因为每个新线程都将获得一个新的句柄，而线程不能继承线程局部变量。这是连 Dropwizard 的原版<code class="du jp jq jr js b">@UnitOfWork</code>都不支持的。而且理由很充分。是不靠谱的。</p><p id="c69a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">链接请求范围的 Jdbi 句柄管理器</strong></p><p id="cc43" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">对于需要生成多个线程来从单个请求线程访问数据库的用例来说，这变得<a class="ae jo" href="https://stackoverflow.com/questions/1531073/is-java-sql-connection-thread-safe/1531103#1531103" rel="noopener ugc nofollow" target="_blank">棘手</a>。</p><p id="b872" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">然而，有一个技巧(<em class="kc">虽然不是完全安全的</em>)可以绕过这个问题，并在新线程之间共享句柄。</p><p id="2fb5" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">由于我们拥有产生多个线程的线程，我们可以使用<strong class="is hj">定制线程工厂</strong>创建新线程。这个线程工厂构造器利用当前线程的 ID <em class="kc">(唯一单调递增的数字)。</em></p><p id="afda" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们称之为<strong class="is hj">对话 ID </strong>。<code class="du jp jq jr js b">Thread Id</code>是确保唯一性的足够好的方法。我们要做的就是在父线程和子线程之间创建一个唯一的标识符。不严格地说，这就是<a class="ae jo" href="https://docs.spring.io/spring-webflow/docs/current/api/org/springframework/webflow/conversation/ConversationId.html" rel="noopener ugc nofollow" target="_blank"> Spring 使用</a>作为其组件之一的原因</p><figure class="ju jv jw jx fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lc"><img src="../Images/d6e7e912046547c6cd2063b83474bce4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*93mNS0cYC0SG7q3WQTZNcQ.png"/></div></div><figcaption class="jy jz et er es ka kb bd b be z dx translated">创建对话 ID</figcaption></figure><figure class="ju jv jw jx fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ld"><img src="../Images/4bb7a1fb521063a1b1a3f61b0616b0fc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ppU0naqK2Gz_VMe5kkv2BQ.png"/></div></div><figcaption class="jy jz et er es ka kb bd b be z dx translated">自定义线程工厂来建立对话。</figcaption></figure><p id="8a24" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在，请求线程创建了多个线程，但是它是使用自定义线程工厂来实现的。我们的名称格式如下所示。</p><figure class="ju jv jw jx fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es le"><img src="../Images/ae54e057762836563b7c1d3f702827cb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HzmNcQY8Og75GAXZNXo_tg.png"/></div></div></figure><p id="698f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们知道请求范围的实现从线程本地获取。因此，我们从<code class="du jp jq jr js b">ThreadLocal</code>切换到<code class="du jp jq jr js b">ConcurrentMap&lt;String, Handle&gt;</code></p><p id="e6a4" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">因为最初的请求线程保证有一个句柄<em class="kc">(已经通过方面事件监听器初始化)</em>，我们在映射中至少有一个条目，否则我们会崩溃。</p><p id="97ea" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">每当子线程想要获得句柄时，它就在映射中搜索键。这里有两个问题。</p><ul class=""><li id="0650" class="kl km hi is b it iu ix iy jb kn jf ko jj kp jn kq kr ks kt bi translated">我们如何知道一个线程是父线程还是子线程？<br/>  <em class="kc">穿过线厂。由于所有的请求线程都是由一个定制的线程工厂创建的，我们可以使用一些字符串逻辑来查找它们的名字，从而解决这个问题。默认情况下，所有未显式创建的线程都是父线程。</em></li></ul><figure class="ju jv jw jx fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lf"><img src="../Images/bb865cccaa3b483f7a4a52195fcaa697.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Z-llI1Oc5ie6S29PoyNI9A.png"/></div></div><figcaption class="jy jz et er es ka kb bd b be z dx translated">如果一个线程是使用我们自己的 NAME_FORMAT 创建的，它就不是父线程</figcaption></figure><ul class=""><li id="f755" class="kl km hi is b it iu ix iy jb kn jf ko jj kp jn kq kr ks kt bi translated"><strong class="is hj">一个线程最终是如何访问句柄的？<br/> </strong>通过访问以父标识符为关键字的映射。如果线程不是父线程，则返回由其父线程打开的句柄。如果它实际上是父节点，则显式打开一个句柄并将其放入映射中。</li></ul><figure class="ju jv jw jx fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lg"><img src="../Images/2c7b25ed4770bdcb47cf79e3b3bdcccb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UFf46lSUVgoVQl75qOApqQ.png"/></div></div><figcaption class="jy jz et er es ka kb bd b be z dx translated">第一次有选择地创建句柄，并为其子线程进行缓存</figcaption></figure><p id="5ec7" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这里有一个测试，它断言使用指定线程工厂创建的共享相同句柄的新线程。</p><figure class="ju jv jw jx fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lh"><img src="../Images/02ca97870f39b1ee5ab8d1ad81c126c7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QY3eMcZG59tjU2lLSogwnA.png"/></div></div><figcaption class="jy jz et er es ka kb bd b be z dx translated">6 个子线程，每个线程同时启动，共享同一个句柄。</figcaption></figure><figure class="ju jv jw jx fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es li"><img src="../Images/6f8c0733b15e4531379483441af7f128.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VSHs0z040y6h4cCbW8IcNg.png"/></div></div><figcaption class="jy jz et er es ka kb bd b be z dx translated">所有 6 个子线程共享同一个句柄。注意记录 main ID 的子线程的名称格式。句柄的 hashcode 与 109532419 相同</figcaption></figure><p id="6111" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">另一方面，如果我们不设置自定义线程工厂，测试就会失败，因为每个线程都试图获得一个句柄作为父线程。</p><figure class="ju jv jw jx fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lj"><img src="../Images/d6b0ccee8688929075ebba15240f0870.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iLiIxIxvbDJGQYhiV11GQA.png"/></div></div><figcaption class="jy jz et er es ka kb bd b be z dx translated">所有 6 个子线程都获得了一个新的句柄。没有线程的名称格式。句柄的 hashcode 是不同的</figcaption></figure><p id="ba50" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">话虽如此，<strong class="is hj">链接的 RequestScoped Jdbi 句柄管理器</strong>需要小心使用。玩和依赖一个开发者可以随意违背(难以察觉)的线程工厂格式是不可靠的。</p><p id="3009" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如果你要分发你自己版本的<code class="du jp jq jr js b">handle manager</code>，确保没有<strong class="is hj">漏洞</strong>。讨论这个实现只是为了证明<code class="du jp jq jr js b">JdbiUnitOfWork</code>可以跨从单个请求线程产生的多个线程工作。</p><p id="94cd" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">至此，我们完成了构建 Jdbi 后端的 UnitOfWork 替代品的旅程。请务必在这里查看完整的源代码。<a class="ae jo" href="https://github.com/isopropylcyanide/dropwizard-jdbi-unitofwork" rel="noopener ugc nofollow" target="_blank">https://github . com/异丙醇氰化物/drowizard-jdbi-unit of work</a></p><p id="d01f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">希望你已经找到了一些有用的东西。我确定，我做了。</p></div></div>    
</body>
</html>