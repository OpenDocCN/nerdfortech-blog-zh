<html>
<head>
<title>Destructuring Arrays in JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在JavaScript中析构数组</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/destructuring-arrays-in-javascript-9ee759210f6?source=collection_archive---------10-----------------------#2021-04-03">https://medium.com/nerd-for-tech/destructuring-arrays-in-javascript-9ee759210f6?source=collection_archive---------10-----------------------#2021-04-03</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/86afac91a1fb6de6d1d23c426e96064b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0xSHSbVrSehuvbiL2LBp-g.jpeg"/></div></div></figure><p id="f065" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">析构是ES6的一个特性，它是一种将数组中的值或对象中的属性解包到单独的e变量中的方法。</p><p id="9a42" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><em class="jo">换句话说，去结构化就是将复杂的数据结构分解成更小的数据结构，比如变量。因此，对于数组，我们使用去结构化来从数组中检索元素，并以一种非常简单的方式将它们存储到变量中。</em></p></div><div class="ab cl jp jq gp jr" role="separator"><span class="js bw bk jt ju jv"/><span class="js bw bk jt ju jv"/><span class="js bw bk jt ju"/></div><div class="hb hc hd he hf"><p id="4c49" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><em class="jo">为什么去结构化是有用的或必要的👉</em></p><p id="ea9e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><em class="jo">为ex。我们取一个非常简单的数组👉</em></p><pre class="jw jx jy jz fd ka kb kc kd aw ke bi"><span id="3988" class="kf kg hi kb b fi kh ki l kj kk"><em class="jo">const firstArray = [1, 2, 3]</em></span></pre><p id="477c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在，如果我们想在不析构的情况下将每一个都检索到变量中，我们将这样做👉</p><pre class="jw jx jy jz fd ka kb kc kd aw ke bi"><span id="d454" class="kf kg hi kb b fi kh ki l kj kk">const a = firstArray[0];</span><span id="e6cf" class="kf kg hi kb b fi kl ki l kj kk">const b = firstArray[1];</span><span id="0a02" class="kf kg hi kb b fi kl ki l kj kk">const c = firstArray[2];</span></pre><p id="fe9d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这就是我们如何在不析构的情况下从一个数组中获取所有三个元素👆这是一个非常漫长的过程。</p><p id="149c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><em class="jo">但是现在有了去结构化，我们可以以非常简单的方式使用，在方括号中同时声明所有三个变量。👉</em></p><pre class="jw jx jy jz fd ka kb kc kd aw ke bi"><span id="4d23" class="kf kg hi kb b fi kh ki l kj kk">const [a, b, c] = firstArray;</span></pre><p id="b9cf" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><em class="jo">所以这是ES6的一个好特性。它节省了我们代码中的大量混乱。左侧方括号中声明的变量看起来像数组，但它们不是。他们在破坏任务。并且在进行析构的时候不会影响到原来的数组。</em></p><p id="fa1c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><em class="jo">如果我们想析构像前2个或任何数量的元素，不要全部来自数组。我们应该声明想要析构的变量的数量，javaScript会自动析构这些元素。而不是全部。对于ex: </em></p><pre class="jw jx jy jz fd ka kb kc kd aw ke bi"><span id="f6db" class="kf kg hi kb b fi kh ki l kj kk">const dishes = [‘pizza’, ‘pasta’, ‘noodles’ ];</span><span id="6700" class="kf kg hi kb b fi kl ki l kj kk">const [first, second ] = dishes;</span><span id="c86f" class="kf kg hi kb b fi kl ki l kj kk">console.log(first, second);</span><span id="de68" class="kf kg hi kb b fi kl ki l kj kk">output will be: pizza pasta;</span></pre><p id="b1a3" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">所以它只析构了数组的前两个元素。</p><p id="e77d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">假设我们想析构一个数组的第一个元素和第三个元素。所以解构有办法做到这一点。👉</p><pre class="jw jx jy jz fd ka kb kc kd aw ke bi"><span id="041b" class="kf kg hi kb b fi kh ki l kj kk">const [first, , third] = dishes;</span><span id="0884" class="kf kg hi kb b fi kl ki l kj kk">console.log(first, third);</span><span id="3b0c" class="kf kg hi kb b fi kl ki l kj kk">output will be: pizza noodles;</span></pre><p id="be59" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">所以我们所做的，只是在析构操作符中留下一个洞，跳过我们不想析构的变量。我们不必为所有不想析构的东西赋值变量。这真的很强大。</p><p id="3ea6" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们可以使用析构来切换变量或重新赋值。这是一个非常简单的方法👉</p><p id="d862" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">对于ex:</p><pre class="jw jx jy jz fd ka kb kc kd aw ke bi"><span id="3513" class="kf kg hi kb b fi kh ki l kj kk">const numbers = [1, 2, 3, 4];</span><span id="2309" class="kf kg hi kb b fi kl ki l kj kk">let [a , b ] = numbers;</span><span id="07c3" class="kf kg hi kb b fi kl ki l kj kk">output: a = 1;b= 2;</span></pre><p id="65d6" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><em class="jo">如果我们想在不析构的情况下重新分配它们，我们要做的是:</em></p><pre class="jw jx jy jz fd ka kb kc kd aw ke bi"><span id="ab68" class="kf kg hi kb b fi kh ki l kj kk">const c = a;</span><span id="d27a" class="kf kg hi kb b fi kl ki l kj kk">a = b;</span><span id="65b9" class="kf kg hi kb b fi kl ki l kj kk">b = c;</span><span id="55a8" class="kf kg hi kb b fi kl ki l kj kk">output will be: 2 1;</span></pre><p id="1866" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">有了析构，我们可以用一种简单的方式来做</p><pre class="jw jx jy jz fd ka kb kc kd aw ke bi"><span id="be9f" class="kf kg hi kb b fi kh ki l kj kk">[a, b ] = [b , a];</span><span id="86cb" class="kf kg hi kb b fi kl ki l kj kk">output will be: 2 1;</span></pre><p id="242f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">所以它比我们以前做的更简单、更整洁。析构化节省了许多代码行，并且不需要额外的变量来重新赋值。</p><p id="f554" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">嵌套析构:如果我们在一个数组或一个嵌套数组中有一个数组，并且我们想析构那个数组，该怎么办👉</p><pre class="jw jx jy jz fd ka kb kc kd aw ke bi"><span id="647e" class="kf kg hi kb b fi kh ki l kj kk">const nested = [1, 2, [5, 6]];</span></pre><p id="048d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这样做的方法是:</p><pre class="jw jx jy jz fd ka kb kc kd aw ke bi"><span id="2ecc" class="kf kg hi kb b fi kh ki l kj kk">const [i, , [j, k]] = nested;</span><span id="6e71" class="kf kg hi kb b fi kl ki l kj kk">console.log(i, j ,k);</span><span id="70af" class="kf kg hi kb b fi kl ki l kj kk">output will be: 1 5 6;</span></pre><p id="fad9" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><em class="jo">在上面的代码中，我们通过在赋值中留下空格或整数跳过了一个元素，并析构了嵌套数组的所有其他元素。我们在解构中解构。</em></p><p id="e1be" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><em class="jo">设置默认值:我们可以在析构的时候给变量设置默认值，这在我们不知道数组长度或者从API取数据的时候使用。</em></p><p id="fbe1" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">对于ex:</p><pre class="jw jx jy jz fd ka kb kc kd aw ke bi"><span id="744c" class="kf kg hi kb b fi kh ki l kj kk">const [p , q , r] = [8 , 9 ]</span><span id="f0ad" class="kf kg hi kb b fi kl ki l kj kk">console.log(p, q , r);</span><span id="dbca" class="kf kg hi kb b fi kl ki l kj kk">output will be = 8 9 undefined;</span></pre><p id="6980" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj"> <em class="jo"> r </em> </strong> <em class="jo">未定义，因为数组中不存在值或元素。所以在这里我们可以为变量设置默认值。</em></p><pre class="jw jx jy jz fd ka kb kc kd aw ke bi"><span id="d401" class="kf kg hi kb b fi kh ki l kj kk">const [p =1 , q= 1, r = 1] = [8 , 9];</span><span id="4930" class="kf kg hi kb b fi kl ki l kj kk">console.log(p, q , r);</span><span id="ec6b" class="kf kg hi kb b fi kl ki l kj kk">output will be = 8 9 1;</span></pre><p id="22b5" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">因此在这类数组中非常有用。</p></div></div>    
</body>
</html>