<html>
<head>
<title>Constructors in C-Sharp</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">升 C 调的构造函数</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/constructors-in-c-sharp-74751cfb0543?source=collection_archive---------16-----------------------#2021-03-15">https://medium.com/nerd-for-tech/constructors-in-c-sharp-74751cfb0543?source=collection_archive---------16-----------------------#2021-03-15</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/fd237197584b32afb517d2d05bff17f1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*u5EBXNP-T6D-1jbX6NTL4A.jpeg"/></div></div></figure><p id="b38b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">要开发任何应用程序，定义变量是过程中非常关键的一部分。在。Net framework 中，简单数据类型到其默认值的定义是由 C#完成的。然而，在创建特定的类或结构时，必须决定默认值，这可以通过使用构造函数来实现。</p><p id="faad" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">构造函数通常用于初始化类的属性。它还在初始化类的数据成员时为类分配内存。</p><p id="130f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在这篇文章中，我们将了解什么是 C#中的构造函数，以及如何在 C #中定义不同类型的构造函数。</p><p id="248f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">目录</strong></p><p id="bddd" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">●什么是建造师？</p><p id="0d90" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">●构造函数的语法</p><p id="3766" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">●构造者的显著特征</p><p id="c732" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">●构造函数的类型有哪些？</p><p id="088b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">●结论</p><h1 id="3364" class="jo jp hi bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">C#中什么是构造函数？</h1><p id="44ec" class="pw-post-body-paragraph iq ir hi is b it km iv iw ix kn iz ja jb ko jd je jf kp jh ji jj kq jl jm jn hb bi translated">构造函数是在创建类或结构的实例时调用的方法。构造函数通常用于在创建类的实例时初始化类或结构中的私有字段。当程序员没有显式定义构造函数时，为类创建默认构造函数。因此，每个类总是至少有一个构造函数，即使程序员没有创建任何构造函数。这个默认的构造函数会将所有的数字数据值初始化为零，将对象和字符串初始化为 null。</p><h1 id="e514" class="jo jp hi bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">构造函数的语法</h1><p id="3f99" class="pw-post-body-paragraph iq ir hi is b it km iv iw ix kn iz ja jb ko jd je jf kp jh ji jj kq jl jm jn hb bi translated">以下是构造函数的一般语法:-</p><figure class="ks kt ku kv fd ij er es paragraph-image"><div class="er es kr"><img src="../Images/a4bbf1b99e58de598bf572e1935e249c.png" data-original-src="https://miro.medium.com/v2/resize:fit:724/0*6kVeETSid-cM1h4Z"/></div></figure><p id="683f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">以上是构造函数的一般语法，访问说明符根据程序的需要有所不同。</p><p id="f992" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">示例:-</p><figure class="ks kt ku kv fd ij er es paragraph-image"><div class="er es kw"><img src="../Images/7cf9868a2af76975ae26a275c83202ef.png" data-original-src="https://miro.medium.com/v2/resize:fit:784/0*beE0X_cpTqeVV21m"/></div></figure><p id="1863" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在上图中，你可以看到 Fruits 是一个类，在这个类中创建了一个与类名同名的构造函数。构造函数是公共的，所以对它的访问没有限制。因此，当创建类的对象时，这个构造函数的数据成员在子类中也是可访问的。</p><h1 id="3aee" class="jo jp hi bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">构造函数的显著特征</h1><p id="58ca" class="pw-post-body-paragraph iq ir hi is b it km iv iw ix kn iz ja jb ko jd je jf kp jh ji jj kq jl jm jn hb bi translated">构造函数的主要特征是:</p><ul class=""><li id="0302" class="kx ky hi is b it iu ix iy jb kz jf la jj lb jn lc ld le lf bi translated">一个类可以有任意数量的构造函数。</li><li id="4f43" class="kx ky hi is b it lg ix lh jb li jf lj jj lk jn lc ld le lf bi translated">它没有返回类型。这甚至包括无效。</li><li id="da52" class="kx ky hi is b it lg ix lh jb li jf lj jj lk jn lc ld le lf bi translated">静态类的构造函数永远不能参数化。</li><li id="42e3" class="kx ky hi is b it lg ix lh jb li jf lj jj lk jn lc ld le lf bi translated">一个类中只能创建一个静态构造函数。</li><li id="312e" class="kx ky hi is b it lg ix lh jb li jf lj jj lk jn lc ld le lf bi translated">构造函数可以被重写。</li></ul><h1 id="f7e3" class="jo jp hi bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">构造函数的类型有哪些？</h1><h1 id="22ad" class="jo jp hi bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">默认构造函数</h1><p id="8063" class="pw-post-body-paragraph iq ir hi is b it km iv iw ix kn iz ja jb ko jd je jf kp jh ji jj kq jl jm jn hb bi translated">当没有参数传递给构造函数时，该构造函数被称为默认构造函数。默认构造函数的主要缺点是我们不能用不同的值初始化类的不同实例，因为所有的实例都将使用默认构造函数中定义的相同值来创建。这个默认的构造函数会将所有的数字数据值初始化为零，将对象和字符串初始化为 null。</p><p id="81c9" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">以下是默认构造函数的示例-</p><figure class="ks kt ku kv fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ll"><img src="../Images/1debc8382c1ab3bb3b322f595d776671.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*WjdDGyMCByu90QfD"/></div></div></figure><p id="4ad9" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi">**</p><p id="59b5" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">输出:</p><figure class="ks kt ku kv fd ij er es paragraph-image"><div class="er es lm"><img src="../Images/9510b016ce86291e65ab18054dfa7c52.png" data-original-src="https://miro.medium.com/v2/resize:fit:454/0*NZctyO2ohtuLZyI8"/></div></figure><h1 id="4913" class="jo jp hi bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">参数化构造函数</h1><p id="0ba5" class="pw-post-body-paragraph iq ir hi is b it km iv iw ix kn iz ja jb ko jd je jf kp jh ji jj kq jl jm jn hb bi translated">当一个构造函数接受至少一个参数时，它被称为参数化构造函数。参数化构造函数相对于默认构造函数的优势在于，我们可以用不同的值初始化一个类的不同实例，从而使它更加动态和健壮。</p><p id="9f1b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">以下是参数化构造函数的示例:-</p><figure class="ks kt ku kv fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ln"><img src="../Images/3740fd353e0da7c406cea29945f7850c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*bBF145AJD_sLssBq"/></div></div></figure><p id="485b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">输出:-</p><figure class="ks kt ku kv fd ij er es paragraph-image"><div class="er es lo"><img src="../Images/13e2e5c194e48331b4f5e5d6ae5919cd.png" data-original-src="https://miro.medium.com/v2/resize:fit:526/0*URAQUi4XlXIzc3u0"/></div></figure><h1 id="eca9" class="jo jp hi bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">复制构造函数</h1><p id="d765" class="pw-post-body-paragraph iq ir hi is b it km iv iw ix kn iz ja jb ko jd je jf kp jh ji jj kq jl jm jn hb bi translated">复制构造函数是在创建新对象时从另一个对象复制变量的构造函数。复制构造函数主要用于用前一个实例的值初始化新的实例。</p><p id="a542" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">复制构造函数的语法如下</p><figure class="ks kt ku kv fd ij er es paragraph-image"><div class="er es lp"><img src="../Images/4d285a826866532faaa113458aed5d0b.png" data-original-src="https://miro.medium.com/v2/resize:fit:880/0*waOLUEhTn_clNAxm"/></div></figure><p id="ebd4" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在上图中，使用现有实例创建了一个复制构造函数。复制构造函数复制该现有实例的所有数据成员。</p><h1 id="6a08" class="jo jp hi bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">静态构造函数</h1><p id="3e18" class="pw-post-body-paragraph iq ir hi is b it km iv iw ix kn iz ja jb ko jd je jf kp jh ji jj kq jl jm jn hb bi translated">当使用 static 关键字定义构造函数时，对于所有实例，它只被调用一次，也就是说，当类的第一个实例被创建时。在 C#中使用静态构造函数是为了初始化应用程序的静态字段，对于所有实例只需要执行一次。</p><p id="be90" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">静态构造函数的主要特性:-</p><ul class=""><li id="770f" class="kx ky hi is b it iu ix iy jb kz jf la jj lb jn lc ld le lf bi translated">静态构造函数没有访问说明符，也没有任何参数。</li><li id="25a3" class="kx ky hi is b it lg ix lh jb li jf lj jj lk jn lc ld le lf bi translated">只有在创建类的第一个实例时，才会调用静态构造函数。</li><li id="b858" class="kx ky hi is b it lg ix lh jb li jf lj jj lk jn lc ld le lf bi translated">不能直接调用静态构造函数。</li><li id="cb7a" class="kx ky hi is b it lg ix lh jb li jf lj jj lk jn lc ld le lf bi translated">用户不能控制程序中静态构造函数的执行。</li></ul><p id="d72e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">静态构造函数的语法如下</p><figure class="ks kt ku kv fd ij er es paragraph-image"><div class="er es lq"><img src="../Images/38f140ea8357f21488d0cf1e02a21c71.png" data-original-src="https://miro.medium.com/v2/resize:fit:474/0*UUN9ptNxw2EqQyAI"/></div></figure><p id="93e8" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi">**</p><p id="1d07" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在上图中，我们可以看到一个静态关键字被用来创建一个静态构造函数。在静态构造函数中，只能有在程序执行期间只初始化一次的数据成员。</p><h1 id="8aa2" class="jo jp hi bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">私有构造函数</h1><p id="af1c" class="pw-post-body-paragraph iq ir hi is b it km iv iw ix kn iz ja jb ko jd je jf kp jh ji jj kq jl jm jn hb bi translated">当用私有访问说明符创建构造函数时，它被称为私有构造函数。只有当类的所有成员都是静态的时，才能使用这种类型的构造函数。</p><p id="5b2b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">私有构造函数的语法如下</p><figure class="ks kt ku kv fd ij er es paragraph-image"><div class="er es lr"><img src="../Images/706ef04695692a8aa7250c5d3ae9084c.png" data-original-src="https://miro.medium.com/v2/resize:fit:506/0*vz84yBUjo5NqqI8_"/></div></figure><p id="55df" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi">**</p><p id="306e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在上图中，我们可以看到 private 关键字被用来创建私有构造函数。任何实例都不能调用私有构造函数。私有构造函数只包含静态数据成员。</p><h1 id="bbb1" class="jo jp hi bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">结论</h1><p id="0199" class="pw-post-body-paragraph iq ir hi is b it km iv iw ix kn iz ja jb ko jd je jf kp jh ji jj kq jl jm jn hb bi translated">这篇文章介绍了构造函数的一些关键概念及其用法。在下一个 C#应用程序中，当创建类的实例时，只要在类或结构中定义私有字段，就要使用构造函数。</p></div><div class="ab cl ls lt gp lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="hb hc hd he hf"><p id="ff16" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><em class="lz">原载于</em><a class="ae ma" href="https://www.partech.nl/nl/publicaties/2021/03/constructors-in-c-sharp" rel="noopener ugc nofollow" target="_blank"><em class="lz">https://www . partech . nl</em></a><em class="lz">。</em></p></div></div>    
</body>
</html>