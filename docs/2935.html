<html>
<head>
<title>Persist your complex Map object with mobx-persist-store</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用 mobx-persist-store 持久化复杂的地图对象</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/persist-your-complex-map-object-with-mobx-persist-store-8530deb017aa?source=collection_archive---------11-----------------------#2021-05-24">https://medium.com/nerd-for-tech/persist-your-complex-map-object-with-mobx-persist-store-8530deb017aa?source=collection_archive---------11-----------------------#2021-05-24</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/669263c7f8e2d945bdca975795a746a8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BzNnxnLDFxQioy4kN_x2AQ.jpeg"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">图片由<a class="ae iu" href="https://unsplash.com/@johnmarkarnold" rel="noopener ugc nofollow" target="_blank">约翰·马可·阿诺</a>在<a class="ae iu" href="https://unsplash.com/" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="4b39" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如果你曾经持久化过你的 MobX 存储，那很可能是在<strong class="ix hj"> mobx-persist </strong> npm 模块的帮助下，这个模块现在已经随着<a class="ae iu" href="https://mobx.js.org/README.html" rel="noopener ugc nofollow" target="_blank"> <strong class="ix hj"> MobX 6 </strong> </a> <strong class="ix hj">的新发布而严重过时了。</strong>因此，对于目前正在使用最新 MobX 版本的人来说，持续使用上述库是一个禁区。你现在可能会说，“<em class="jt">但是我不想写我自己的代码，也不想回到那个旧版本的 MobX，用那些讨厌的装饰者；我想使用一些可爱的 npm 模块来为我做所有的工作！</em>”，你说得对，因为现在有一个模块就是专门做这个的:<a class="ae iu" href="https://github.com/quarrant/mobx-persist-store" rel="noopener ugc nofollow" target="_blank"><strong class="ix hj">mobx-persist-store</strong></a><strong class="ix hj">。</strong></p><p id="8cc2" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这个故事<strong class="ix hj">不应该</strong>成为如何开始使用这个库的指南！制作它的人写了一份关于如何开始的很好的指南。</p><p id="977c" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">但是就像每一个年轻的 npm 模块一样，总会缺少一些东西。你在他们的指南上寻找你需要的小东西，然后<strong class="ix hj">*噗*，</strong>你意识到在当前版本中它不是现成的。</p><p id="4409" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这正是最近发生在我身上的事。我不得不保留我的<code class="du ju jv jw jx b">UserStore</code>,它有一个内部有一个<code class="du ju jv jw jx b">Map</code>、以<code class="du ju jv jw jx b">Object</code>为值、以<code class="du ju jv jw jx b">enum</code>常量为键的类。你可以自己试试！我用的是<code class="du ju jv jw jx b">mobx-persist-store 1.0.0</code>。</p><p id="82b3" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">更详细地说:用户可以有一个以上的具有特定功能的角色。</p><p id="d2a8" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">所以，经过一段时间的研究(反复试验…)，我想出了解决我的问题的<strong class="ix hj">解决方案</strong>:</p><figure class="jy jz ka kb fd ij"><div class="bz dy l di"><div class="kc kd l"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">填充地图，刷新……用户还在！</figcaption></figure><p id="d2cc" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">首先，我们定义了<code class="du ju jv jw jx b">RootStore</code>、<code class="du ju jv jw jx b">StoreContext</code>、<code class="du ju jv jw jx b">StoreProvider</code>和<code class="du ju jv jw jx b">useStores</code>钩子，以确保我们得到的是<code class="du ju jv jw jx b">RootStore</code>的最新实例。其次，我们然后定义领域模型和其他存储；我的情况是<code class="du ju jv jw jx b">UserStore</code>。</p><p id="5fa2" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">现在真正的部分开始了！我们用<code class="du ju jv jw jx b">makeAutoObservable</code>使我们的<code class="du ju jv jw jx b">UserStore</code>可观察，用<code class="du ju jv jw jx b">makePersistable</code>函数可持久。如果我们的存储有内部没有任何复杂对象类型的类，我们就可以用默认的方法使我们的存储持久化。这里的情况不是这样，所以我们必须定义我们的项目<strong class="ix hj">如何存储</strong>，<strong class="ix hj">如何移除，</strong>和<strong class="ix hj">如何从选择的本地存储中读取</strong>(<code class="du ju jv jw jx b">localStorage</code>，<code class="du ju jv jw jx b">sessionStorage</code>，<code class="du ju jv jw jx b">localForage</code> …)。</p><p id="84cc" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们如何存储我们的<code class="du ju jv jw jx b">Map</code>是一个简单的方法；我们调用传递了<code class="du ju jv jw jx b">replacer</code>函数的<code class="du ju jv jw jx b">JSON.stringify</code>方法，该函数检查传递的值是否为<code class="du ju jv jw jx b">Map</code>，如果是，则在那个<code class="du ju jv jw jx b">Map</code>上再次调用它，否则返回原始值。</p><figure class="jy jz ka kb fd ij er es paragraph-image"><div class="er es ke"><img src="../Images/291f882cdecadbea7e36897f06e55b20.png" data-original-src="https://miro.medium.com/v2/resize:fit:1034/format:webp/1*btqoFDlNCXAcjWenbLCwgA.png"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">JSON.stringify 方法的 Replacer 函数</figcaption></figure><figure class="jy jz ka kb fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es kf"><img src="../Images/fcb12556e0a416e4f034724178496019.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LFpzQJ76YxZHpUIEzre0Ew.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">嵌套对象的递归帮助器</figcaption></figure><p id="f0bb" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">项目移除是使用默认方法完成的。</p><p id="5ef9" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">现在是阅读部分；如果我们要水化这样的存储，我们必须知道在所说的<code class="du ju jv jw jx b">Map</code>中存储的是什么类型的对象。不幸的是，我们不能使用<code class="du ju jv jw jx b">instance.constructor.name</code>,因为我们的类名很可能会因为代码的缩减而改变。所以为了避免这种情况，我们必须定义一个返回类名的方法(是的，我知道😬)或者创建一个<code class="du ju jv jw jx b">enum</code>来保存同样的东西(<em class="jt">挑选你的毒药</em>)。这样一来，我们现在可以创建类名的<code class="du ju jv jw jx b">Map</code>作为键，创建这些类的“空”实例作为值。</p><figure class="jy jz ka kb fd ij er es paragraph-image"><div class="er es kg"><img src="../Images/221cc868685dbec996dcef81d3304512.png" data-original-src="https://miro.medium.com/v2/resize:fit:886/format:webp/1*20s1ICP42UgGAU5gSheeEQ.png"/></div></figure><p id="579f" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">最后一步</strong>:我们调用传递了<code class="du ju jv jw jx b">reviver</code>函数的<code class="du ju jv jw jx b">JSON.parse</code>函数。该函数的工作是检查传递的名称是否与我们新创建的<code class="du ju jv jw jx b">Map</code>中的名称相匹配。如果是这样，我们可以将所有的值赋给该类的“空”实例。</p><figure class="jy jz ka kb fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es kh"><img src="../Images/48780c7fe5c0afab12e3b45ef459b072.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*e8T-lIH1_lcaOSnrH89dSw.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">JSON.parse 方法的 Reviver 函数</figcaption></figure><p id="23c2" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">🎉恭喜你。您现在正在保存您的商店😃。请在评论中分享你的想法，或者如果你知道如何做更好，请发布 codesandbox！</p></div></div>    
</body>
</html>