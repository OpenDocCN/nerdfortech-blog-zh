<html>
<head>
<title>Conditional rendering in React (jsx)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">React 中的条件渲染(jsx)</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/conditional-rendering-in-react-jsx-4aadc0f0b63f?source=collection_archive---------4-----------------------#2021-07-20">https://medium.com/nerd-for-tech/conditional-rendering-in-react-jsx-4aadc0f0b63f?source=collection_archive---------4-----------------------#2021-07-20</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="e1bd" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">我的发现…</h2></div><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ix"><img src="../Images/fc2e5221a2efda10d48bd99e892abd45.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*c-rtOMXml5QZ_R_OGvYcvg.png"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">处理文件输入</figcaption></figure><p id="0b5c" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">基本上条件必须评估为真或假。这与 js 中条件句的工作方式不同。我的意思是:</p><pre class="iy iz ja jb fd kj kk kl km aw kn bi"><span id="c17e" class="ko kp hi kk b fi kq kr l ks kt">data.length &gt; 0 &amp;&amp; &lt;div /&gt;</span></pre><p id="ee21" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">仅当左边的条件评估为真时，才呈现组件。但是从纯 js 来看，<code class="du ku kv kw kk b">&gt; 0</code>是多余的，所以我希望下面的代码行可以工作:</p><pre class="iy iz ja jb fd kj kk kl km aw kn bi"><span id="a8c1" class="ko kp hi kk b fi kq kr l ks kt">data.length &amp;&amp; &lt;div /&gt;</span></pre><p id="7902" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">结果那行不行，(如预期的)为什么—</p><p id="90cf" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">在第一种情况下，如果数组的大小为 0，<code class="du ku kv kw kk b">0 &gt; 0</code>将计算为<code class="du ku kv kw kk b">false</code>，因此<code class="du ku kv kw kk b">false &amp;&amp; [anything really]</code>计算为 false，因此组件不会被呈现。</p><p id="d856" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">然而，在第二种情况下，如果大小为 0，<code class="du ku kv kw kk b">0 &amp;&amp; &lt;div /&gt;</code>的计算结果为<code class="du ku kv kw kk b">0&lt;div /&gt;</code>。换句话说，0 和元素都将被呈现。从 js 来看，我希望<code class="du ku kv kw kk b">&amp;&amp;</code>操作符将左边的 0 强制转换为布尔值(false ),但这并没有发生，所以它们都被渲染了——这就是 jsx 的工作方式？</p><p id="b517" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">您可能希望语句<code class="du ku kv kw kk b">0 &amp;&amp; &lt;div /&gt;</code>的计算结果为<code class="du ku kv kw kk b">false</code>。实际上，在 jsx 之外就是这种情况。</p><pre class="iy iz ja jb fd kj kk kl km aw kn bi"><span id="0ce1" class="ko kp hi kk b fi kq kr l ks kt"><em class="kx">const</em> value = data.length ? 1 : 0;</span></pre><p id="3a50" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">如果大小大于 0，上面的语句给<code class="du ku kv kw kk b">value</code>赋值 1，否则赋值 0——我发现这比 jsx 更具决定性。我知道强制负值返回 true，但是长度不能是-ve——我可能是错的。</p><p id="7f7d" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">下面的陈述怎么样，你认为结果会是什么？</p><pre class="iy iz ja jb fd kj kk kl km aw kn bi"><span id="ba1b" class="ko kp hi kk b fi kq kr l ks kt">data.length ? &lt;div /&gt;: &lt;err /&gt;;</span></pre><p id="96ae" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">这就是让人困惑的地方。这往往与我们先前讨论的相矛盾。它实际上像正常 js 那样工作。</p><p id="b6d9" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">所以，我猜这归结为<code class="du ku kv kw kk b">binary (&amp;&amp;)</code>和<code class="du ku kv kw kk b">ternary (? :)</code>操作符如何处理 jsx 中的条件——一个强制(三进制),另一个不强制(二进制)。</p><p id="e500" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">如果我们交换二元运算符的操作数会怎么样</p><pre class="iy iz ja jb fd kj kk kl km aw kn bi"><span id="3a62" class="ko kp hi kk b fi kq kr l ks kt">&lt;div /&gt; &amp;&amp; data.length &gt; 0</span></pre><p id="5004" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">对于大多数初学者来说，这可能是个陷阱。不管右边的计算结果如何，组件都会被渲染！很奇怪，对吧？</p><p id="5f00" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">我认识一些人，他们远离 jsx 中的二元操作符，因为它具有不确定性。他们使用三元组，当他们不想为特定的评估渲染任何东西时，提供<code class="du ku kv kw kk b">null</code>作为操作数。</p><p id="7411" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">我还发现上面的规则同样适用于动态的。</p><p id="4860" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">假设您有一个指示流程中当前步骤的组件，并且您想赋予它不同的颜色/行为——扩展所有步骤组件的样式。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es ky"><img src="../Images/86a42abb8e7b1a4e98a86ab3add7567d.png" data-original-src="https://miro.medium.com/v2/resize:fit:396/format:webp/1*RYxczigwFpPZu8pSqUAMaA.png"/></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">我的意思是…</figcaption></figure><pre class="iy iz ja jb fd kj kk kl km aw kn bi"><span id="9455" class="ko kp hi kk b fi kq kr l ks kt">&lt;div className={`step ${<em class="kx">current</em> ? 'current' : ''}`} /&gt;</span></pre><p id="a691" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">当您在 dev tools 中检查组件时，上面的方法在 DOM 中为非当前组件创建了第二个类(作为额外的空间出现)。如果有一个<code class="du ku kv kw kk b">space</code>选择器(也许有——我不知道)会导致名称冲突。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es kz"><img src="../Images/5df5fe8ade4c8ae8ebddc7a2cb2142ee.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ffjlxY1XitXbbRZlJVjXbg.png"/></div></div></figure><p id="044b" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">使用<code class="du ku kv kw kk b">null</code>操作数进行假评估怎么样？</p><pre class="iy iz ja jb fd kj kk kl km aw kn bi"><span id="b267" class="ko kp hi kk b fi kq kr l ks kt">&lt;div className={`step ${<em class="kx">current</em> ? 'current' : null}`} /&gt;</span></pre><p id="4e39" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">嗯，你猜对了——这将把<code class="du ku kv kw kk b">null</code>添加到其余元素的空格分隔的类名列表中。更加混乱。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es la"><img src="../Images/5f24b41590034352e781dc7ed7455406.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bh_LyEB8MoJdr50E43xCrg.png"/></div></div></figure><p id="b449" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">去二进制怎么样？嗯，让我想想…</p><pre class="iy iz ja jb fd kj kk kl km aw kn bi"><span id="a71e" class="ko kp hi kk b fi kq kr l ks kt">&lt;div className={`step ${<em class="kx">current</em> &amp;&amp; 'current'}`} /&gt;</span></pre><p id="8ea4" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">事实证明，这个看似优雅的解决方案也是可行的，但是问题同上——您将<code class="du ku kv kw kk b">false</code>作为非当前项目的类名。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es lb"><img src="../Images/4ab180d7b1dacc1b7eef962be5c24977.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*U2b8MWY4Gu1YcOcjtHbNNA.png"/></div></div></figure><p id="3dfe" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">我最喜欢的还是虚评的空弦<code class="du ku kv kw kk b">''</code>。让我知道你部署的技术。</p><p id="0fd4" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">如果你设计组件的方式不会继承任何样式，就像我上面做的那样(所有当前和非当前组件都有一个父类<code class="du ku kv kw kk b">step</code>)——并且可能愿意复制一些规则(有什么损害)，那么问题会变得容易得多:</p><pre class="iy iz ja jb fd kj kk kl km aw kn bi"><span id="7a59" class="ko kp hi kk b fi kq kr l ks kt">&lt;div className={<em class="kx">current</em> ? 'current' : 'not-current'} /&gt;</span></pre><p id="2811" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">因此组件根据它们的状态采用完全不同的类。这可能需要复制几个规则，但它似乎解决了前面的问题。挑战在于保持这两个类的同步！</p><p id="09e9" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">不过，我最喜欢的还是<code class="du ku kv kw kk b">''</code>。</p></div></div>    
</body>
</html>