<html>
<head>
<title>Optimistic vs. Pessimistic Locking Strategies</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">乐观与悲观的锁定策略</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/optimistic-vs-pessimistic-locking-strategies-b5d7f4925910?source=collection_archive---------0-----------------------#2022-03-18">https://medium.com/nerd-for-tech/optimistic-vs-pessimistic-locking-strategies-b5d7f4925910?source=collection_archive---------0-----------------------#2022-03-18</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div class="er es if"><img src="../Images/35407fbee9ead4153ec7e3943f80f999.png" data-original-src="https://miro.medium.com/v2/resize:fit:1160/format:webp/1*ajXvsW0UOJdC9MWWzKMNRA.jpeg"/></div></figure><h2 id="c1da" class="im in hi bd io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj bi translated">什么是<strong class="ak">锁定？</strong></h2><blockquote class="jk jl jm"><p id="3f19" class="jn jo jp jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">锁定是一种防止同时访问系统中的数据的技术，为了允许几个用户同时修改一条记录，也为了防止无限制访问造成的不一致结果，当检索到一条记录进行更新时，可以对其进行<em class="hi">锁定</em>。由于锁定，任何试图检索同一记录进行编辑的人都被拒绝写访问。一旦记录被保存或编辑被取消，锁就被释放。记录永远不会被保存以覆盖其他更改，从而保持数据完整性。</p></blockquote><h2 id="2339" class="im in hi bd io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj bi translated">锁定一般示例</h2><blockquote class="jk jl jm"><p id="7f9a" class="jn jo jp jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">例如，您的应用程序中的每种产品都有一个库存对象，您需要下订单，并在下订单后保存订单数量</p><p id="c11e" class="jn jo jp jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">想象一下，现在你的两个客户同时请求从库存中下订单，而你的库存中有 3 件商品</p><p id="f77d" class="jn jo jp jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">第一个客户将购买 2 件商品，因此库存将检查其数量，这将是有效的，然后它将从库存中检测数量，并且在保存商品后，可用数量将是 1</p><p id="6bda" class="jn jo jp jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">第二个客户将购买 3 件商品，因此库存将检查其数量，这将是有效的，然后它将从库存中检测数量，并且在保存商品后可用数量将为 0</p><p id="b2af" class="jn jo jp jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">但是总缺陷数量为 5，因此它会将库存对象置于无效状态。这是本主题的一个简单示例，本文将使用不同的策略来解决它</p></blockquote></div><div class="ab cl km kn gp ko" role="separator"><span class="kp bw bk kq kr ks"/><span class="kp bw bk kq kr ks"/><span class="kp bw bk kq kr"/></div><div class="hb hc hd he hf"><h1 id="6626" class="kt in hi bd io ku kv kw is kx ky kz iw la lb lc ja ld le lf je lg lh li ji lj bi translated">乐观锁定</h1><figure class="ll lm ln lo fd ij er es paragraph-image"><div class="er es lk"><img src="../Images/9f777964538605c98c73129c7f712aab.png" data-original-src="https://miro.medium.com/v2/resize:fit:564/format:webp/1*ot4NBHwHdbV4RE_Qz7fy3g.png"/></div></figure><h2 id="a8e8" class="im in hi bd io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj bi translated">什么是乐观锁定？</h2><blockquote class="jk jl jm"><p id="6531" class="jn jo jp jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">在这个策略中，假设多个用户将在互不影响的情况下工作。换句话说，在进行乐观锁定时，不强制锁。我们只是验证没有其他事务修改过数据。在修改的情况下，我们将回滚我们的更改。</p></blockquote><h2 id="0673" class="im in hi bd io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj bi translated">乐观锁定不同的实现</h2><p id="524f" class="pw-post-body-paragraph jn jo hi jq b jr lp jt ju jv lq jx jy ix lr kb kc jb ls kf kg jf lt kj kk kl hb bi translated">我们可以在许多实施中使用这种策略，例如:</p><ul class=""><li id="527f" class="lu lv hi jq b jr js jv jw ix lw jb lx jf ly kl lz ma mb mc bi translated">更新前检查旧值和新值。</li><li id="ec4e" class="lu lv hi jq b jr md jv me ix mf jb mg jf mh kl lz ma mb mc bi translated">在对象中创建时间戳数据类型，并在更新时检查旧时间戳是否等于记录时间戳</li><li id="b909" class="lu lv hi jq b jr md jv me ix mf jb mg jf mh kl lz ma mb mc bi translated">向对象添加版本</li></ul><h2 id="b886" class="im in hi bd io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj bi translated">乐观锁定问题的解决方案</h2><blockquote class="jk jl jm"><p id="ff9b" class="jn jo jp jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">我们将使用版本来解决我们的问题。我们将向清单对象添加版本号，在保存对象之前，我们将检查是否存在具有此版本的清单对象，然后保存具有该版本的对象</p><p id="2822" class="jn jo jp jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">所以我们的情况会是这样的:</p><p id="475d" class="jn jo jp jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">第一个和第二个客户将在运行时向对象发出请求，但在保存时，将只保存一个，第二个客户将找不到该对象，因为它已被更改为第一个请求，如 blow 图像所解释的</p></blockquote><figure class="ll lm ln lo fd ij er es paragraph-image"><div role="button" tabindex="0" class="mj mk di ml bf mm"><div class="er es mi"><img src="../Images/e73cf88a698393fb18d4cc6263997be7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pQPtgwaJw6he0veNpbkQoA.jpeg"/></div></div></figure><p id="b770" class="pw-post-body-paragraph jn jo hi jq b jr js jt ju jv jw jx jy ix ka kb kc jb ke kf kg jf ki kj kk kl hb bi translated">用户 A 和 B 将获得库存对象，但只有用户 A 修改过的对象将被保存，用户 B 对象将被删除，因为版本已更新，并且数据库届时将只接受一个请求，因为这是同步的本质</p></div><div class="ab cl km kn gp ko" role="separator"><span class="kp bw bk kq kr ks"/><span class="kp bw bk kq kr ks"/><span class="kp bw bk kq kr"/></div><div class="hb hc hd he hf"><h1 id="8801" class="kt in hi bd io ku kv kw is kx ky kz iw la lb lc ja ld le lf je lg lh li ji lj bi translated">悲观锁定</h1><figure class="ll lm ln lo fd ij er es paragraph-image"><div class="er es mn"><img src="../Images/9c07be8a983e1e9d4021f183cbf39583.png" data-original-src="https://miro.medium.com/v2/resize:fit:516/format:webp/1*f1Q_Riyc9TY8Lt7XHOnBnw.jpeg"/></div></figure><h2 id="0789" class="im in hi bd io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj bi translated">什么是悲观锁定？</h2><blockquote class="jk jl jm"><p id="0a00" class="jn jo jp jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">在这种情况下，假设当你需要访问对象进行更新时，我们会锁定该记录供独占使用，直到你完成它。它比乐观锁定具有更好的完整性，但是需要您小心应用程序设计以避免死锁。</p></blockquote><h2 id="17f0" class="im in hi bd io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj bi translated">悲观锁定不同的实现</h2><p id="4389" class="pw-post-body-paragraph jn jo hi jq b jr lp jt ju jv lq jx jy ix lr kb kc jb ls kf kg jf lt kj kk kl hb bi translated">我们可以在许多实施中使用这种策略，例如:</p><ul class=""><li id="2e15" class="lu lv hi jq b jr js jv jw ix lw jb lx jf ly kl lz ma mb mc bi translated">获取对象后，在内存或数据库中添加对象锁</li><li id="2239" class="lu lv hi jq b jr md jv me ix mf jb mg jf mh kl lz ma mb mc bi translated">使获取和更新对象的方法在代码级别可序列化</li><li id="8ed1" class="lu lv hi jq b jr md jv me ix mf jb mg jf mh kl lz ma mb mc bi translated">使用更强的事务隔离级别</li></ul><h2 id="e422" class="im in hi bd io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj bi translated">悲观锁定问题的解决方案</h2><blockquote class="jk jl jm"><p id="3306" class="jn jo jp jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">我们将使用锁定来解决我们的问题。我们将锁定库存对象，同时让它继续进行更新，如果在此之后发送的任何获取相同对象的请求都将失败</p><p id="8867" class="jn jo jp jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">所以我们的情况会是这样的:</p><p id="ca5e" class="jn jo jp jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">第一个或第二个客户将在运行时向对象发出请求，而这个对象将有一个错误，因为这个对象被另一个请求锁定了，就像图像爆炸一样</p></blockquote><figure class="ll lm ln lo fd ij er es paragraph-image"><div role="button" tabindex="0" class="mj mk di ml bf mm"><div class="er es mo"><img src="../Images/7a4c9daaae7f7f73eb77a219f9b12763.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7HNRPwcKgG18wMqUXRZYuA.jpeg"/></div></div></figure><p id="05d7" class="pw-post-body-paragraph jn jo hi jq b jr js jt ju jv jw jx jy ix ka kb kc jb ke kf kg jf ki kj kk kl hb bi translated">用户 A 将获取库存对象并在其上添加本地，但是当用户 B 尝试获取该对象时将失败，因为它被另一个用户锁定</p><h1 id="25f2" class="kt in hi bd io ku mp kw is kx mq kz iw la mr lc ja ld ms lf je lg mt li ji lj bi translated">结论</h1><blockquote class="jk jl jm"><p id="a6d6" class="jn jo jp jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">乐观锁是一种非常有用的技术，即使在使用不太严格的隔离级别时，或者在后续事务中执行读写操作时，它也能很好地工作。</p><p id="d889" class="jn jo jp jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">乐观锁的缺点是数据访问会触发回滚，因此会丢失当前正在执行的事务所做的所有工作。</p><p id="aaae" class="jn jo jp jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">争用越多，冲突就越多，中止事务的可能性就越大。回滚对系统来说代价很高，因为它需要恢复所有当前挂起的更改，这些更改可能涉及表行和索引记录。</p><p id="6fa6" class="jn jo jp jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">因此，当冲突频繁发生时，悲观锁定可能更合适，因为它减少了回滚事务的机会。</p></blockquote></div></div>    
</body>
</html>