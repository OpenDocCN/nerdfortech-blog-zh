<html>
<head>
<title>Profunctor-lens — Exploring-purescript-modules #4</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">profuctor-lens-探索-pure script-模块#4</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/profunctor-lens-exploring-purescript-modules-4-89aba69405ef?source=collection_archive---------7-----------------------#2022-10-05">https://medium.com/nerd-for-tech/profunctor-lens-exploring-purescript-modules-4-89aba69405ef?source=collection_archive---------7-----------------------#2022-10-05</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="6533" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">假设您有以下复杂的数据结构，</p><pre class="jd je jf jg fd jh ji jj jk aw jl bi"><span id="9d77" class="jm jn hi ji b fi jo jp l jq jr">type NestedData =<br/>  Maybe (Array <br/>     { foo :: Tuple String (Either Int Boolean)<br/>     , bar :: String })</span></pre><p id="f16f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果我告诉你翻转特定索引处的深度嵌套布尔值，你会怎么做？</p><pre class="jd je jf jg fd jh ji jj jk aw jl bi"><span id="aff8" class="jm jn hi ji b fi jo jp l jq jr">flipBool :: Int -&gt; NestedData -&gt; NestedData<br/>flipBool index = case _ of <br/>    Nothing -&gt; Nothing <br/>    Just arr -&gt; modifyAt index modifyFooFoo arr<br/>    where<br/>      modifyFooFoo rec = rec { foo = modifyTuple rec.foo}<br/>      modifyTuple (Tuple first sec) = Tuple first (modifyEither sec)<br/>      modifyEither ei = not &lt;$&gt; ei</span></pre><p id="19f2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们需要写一个像上面这样的复杂函数吗？如果<code class="du js jt ju ji b">NestedData</code>的结构发生变化会怎样？我们必须再次对我们的功能进行大量的修改。那么，有什么简单的方法来修改&amp;检索这些复杂数据 structures🧐里面的数据呢？是的，有，它们叫做光学。有了光学，你可以像这样做</p><pre class="jd je jf jg fd jh ji jj jk aw jl bi"><span id="3218" class="jm jn hi ji b fi jo jp l jq jr">flipBool :: Int -&gt; NestedData -&gt; NestedData<br/>flipBool index nestedData = over boolGetter not nestedData<br/>    where<br/>       boolGetter = (_Just &lt;&lt;&lt; ix index &lt;&lt;&lt; _foo &lt;&lt;&lt; _2 &lt;&lt;&lt; _Right)</span></pre><p id="08d3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">看到代码行减少了 50%,即使我没有解释任何关于上面的语法，你可以很容易地通过查看上面的代码块图片由<a class="ae jv" href="https://unsplash.com/@jamesbold?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> James Bold </a>在<a class="ae jv" href="https://unsplash.com/s/photos/lens?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上</p><p id="527c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">以下内容主要来自于<a class="ae jv" href="https://thomashoneyman.com/articles/practical-profunctor-lenses-optics/" rel="noopener ugc nofollow" target="_blank">托马斯·霍尼曼</a>发表的这篇文章。</p><figure class="jd je jf jg fd jx er es paragraph-image"><div role="button" tabindex="0" class="jy jz di ka bf kb"><div class="er es jw"><img src="../Images/08465fb5e712f6990951eb242a9af2c3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IPVKLYshuikMtnAC8OqnYA.jpeg"/></div></div><figcaption class="ke kf et er es kg kh bd b be z dx translated">照片由<a class="ae jv" href="https://unsplash.com/@jamesbold?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">詹姆斯·博尔德</a>在<a class="ae jv" href="https://unsplash.com/s/photos/lens?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure></div><div class="ab cl ki kj gp kk" role="separator"><span class="kl bw bk km kn ko"/><span class="kl bw bk km kn ko"/><span class="kl bw bk km kn"/></div><div class="hb hc hd he hf"><h1 id="f5a3" class="kp jn hi bd kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll bi translated">光学器件的类型</h1><p id="8a7e" class="pw-post-body-paragraph if ig hi ih b ii lm ik il im ln io ip iq lo is it iu lp iw ix iy lq ja jb jc hb bi translated">在深入研究上述函数是如何工作的之前，我们先了解一下光学中的一些核心概念。</p><p id="3705" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">经常使用的光学系统有四种。分别是棱镜，镜头，遍历，Iso。每个光学元件描述一个结构<code class="du js jt ju ji b">s</code>和一个零或者多个类型<code class="du js jt ju ji b">a</code>值之间的关系。</p><pre class="jd je jf jg fd jh ji jj jk aw jl bi"><span id="0569" class="jm jn hi ji b fi jo jp l jq jr">Optic s a <br/>// s =&gt; Structure like Maybe a, Either a, Array a etc<br/>// a =&gt; (one or more) Value (the `a` inside the above types)</span></pre><p id="c682" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><code class="du js jt ju ji b">Prism</code>代表表示结构<code class="du js jt ju ji b">s </code>的光学元件，从该光学元件中我们可能得到也可能得不到<code class="du js jt ju ji b">a</code>类型的值。例如，一个可能类型。</p><p id="687c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><code class="du js jt ju ji b">Lens</code>表示光学，我们可以从结构<code class="du js jt ju ji b">s</code>中获取类型<code class="du js jt ju ji b">a </code>的值。例如，一个元组</p><p id="200f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><code class="du js jt ju ji b">Traversal</code>表示从结构<code class="du js jt ju ji b">s</code>中获取零个或多个类型<code class="du js jt ju ji b">a </code>值的光学。例如，一个数组</p><p id="3a2e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><code class="du js jt ju ji b">Iso</code>表示光学，其中结构<code class="du js jt ju ji b">s</code>和值<code class="du js jt ju ji b">a</code>彼此同构。例如，一个新类型</p><pre class="jd je jf jg fd jh ji jj jk aw jl bi"><span id="b0f5" class="jm jn hi ji b fi jo jp l jq jr">newtype Name = Name String<br/>// here `Name` and `String` are isomorphic to each other<br/>// one of them are enough to create the other</span></pre><h2 id="fa2c" class="jm jn hi bd kq lr ls lt ku lu lv lw ky iq lx ly lc iu lz ma lg iy mb mc lk md bi translated">剖析示例</h2><pre class="jd je jf jg fd jh ji jj jk aw jl bi"><span id="6bbc" class="jm jn hi ji b fi jo jp l jq jr">(_Just &lt;&lt;&lt; ix index &lt;&lt;&lt; _foo &lt;&lt;&lt; _2 &lt;&lt;&lt; _Right)</span></pre><ul class=""><li id="0bf4" class="me mf hi ih b ii ij im in iq mg iu mh iy mi jc mj mk ml mm bi translated">我们可以用光学做的一件强有力的事情就是把它们组合起来。</li><li id="1a90" class="me mf hi ih b ii mn im mo iq mp iu mq iy mr jc mj mk ml mm bi translated">光学通常以下划线为前缀，需要从左到右阅读(当我们左组合它时)。</li><li id="8ed9" class="me mf hi ih b ii mn im mo iq mp iu mq iy mr jc mj mk ml mm bi translated">当我们向右移动时，我们将深入结构的一层。从上面的光学，我们可以得出结论</li></ul><pre class="jd je jf jg fd jh ji jj jk aw jl bi"><span id="928e" class="jm jn hi ji b fi jo jp l jq jr">1st Layer - A Maybe<br/>2nd Layer - Array like structure<br/>3rd Layer - A Record<br/>4th Layer - A tuple<br/>5th Layer - An Either  </span></pre><p id="db08" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果你记得那正是我们的<code class="du js jt ju ji b">NestedData</code>，</p><pre class="jd je jf jg fd jh ji jj jk aw jl bi"><span id="dfae" class="jm jn hi ji b fi jo jp l jq jr">type NestedData =<br/>  Maybe                      -- 1 : _Just<br/>   (Array                    -- 2 : ix index<br/>     { foo ::                -- 3 : _foo<br/>        Tuple String         -- 4 : _2<br/>        (Either Int Boolean) -- 5 : _Right<br/>     , bar :: String })</span></pre><p id="3ee9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">除了<code class="du js jt ju ji b">_foo</code>也很容易定义外，上述大多数光学元件都在<a class="ae jv" href="https://pursuit.purescript.org/packages/purescript-profunctor-lenses/8.0.0" rel="noopener ugc nofollow" target="_blank">深孔透镜</a>模块中预定义。</p><pre class="jd je jf jg fd jh ji jj jk aw jl bi"><span id="d694" class="jm jn hi ji b fi jo jp l jq jr">import Data.Lens.Record(props) </span><span id="233b" class="jm jn hi ji b fi ms jp l jq jr">_foo = prop (Proxy :: Proxy "foo")</span></pre></div><div class="ab cl ki kj gp kk" role="separator"><span class="kl bw bk km kn ko"/><span class="kl bw bk km kn ko"/><span class="kl bw bk km kn"/></div><div class="hb hc hd he hf"><h1 id="6653" class="kp jn hi bd kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll bi translated">潜水深度</h1><p id="4973" class="pw-post-body-paragraph if ig hi ih b ii lm ik il im ln io ip iq lo is it iu lp iw ix iy lq ja jb jc hb bi translated">让我们逐一了解四种光学，</p><h2 id="d0c0" class="jm jn hi bd kq lr ls lt ku lu lv lw ky iq lx ly lc iu lz ma lg iy mb mc lk md bi translated">1.镜头</h2><p id="7e89" class="pw-post-body-paragraph if ig hi ih b ii lm ik il im ln io ip iq lo is it iu lp iw ix iy lq ja jb jc hb bi translated">我们对元组和记录等产品类型使用镜头。lets 让我们获得并修改类型为<code class="du js jt ju ji b">a</code>的值，当它肯定存在于结构<code class="du js jt ju ji b">s</code>中时。示例镜头<code class="du js jt ju ji b">_2</code>将获取元组的第二个元素，我们确信它总是出现在任何给定的元组中。</p><pre class="jd je jf jg fd jh ji jj jk aw jl bi"><span id="ece5" class="jm jn hi ji b fi jo jp l jq jr">-- This lens focuses on the second element of a tuple and is implemented<br/>-- in the Data.Lens.Lens.Tuple module.<br/>_2 :: forall a b. Lens' (Tuple a b) b<br/><br/>-- This lens focuses on the "name" field of a record; we have to construct<br/>-- this one ourselves.<br/>_name :: forall a r. Lens' { name :: a | r } a<br/>_name = prop (SProxy :: SProxy "name")</span></pre><p id="bf29" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">您可以使用类似于<code class="du js jt ju ji b">view</code>的函数从结构<code class="du js jt ju ji b">s</code>中获取值<code class="du js jt ju ji b">a</code>，并使用类似于<code class="du js jt ju ji b">set</code>和<code class="du js jt ju ji b">over</code>的函数修改其中的值。</p><p id="071e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">考虑到你有这种类型</p><pre class="jd je jf jg fd jh ji jj jk aw jl bi"><span id="9c27" class="jm jn hi ji b fi jo jp l jq jr">type Person = {name :: String, age :: Int}</span></pre><p id="60fb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">并且你已经创建了一个在球场上工作的镜头<code class="du js jt ju ji b">name</code></p><pre class="jd je jf jg fd jh ji jj jk aw jl bi"><span id="debf" class="jm jn hi ji b fi jo jp l jq jr">_name :: forall a r. Lens' { name :: a | r } a<br/>_name = prop (SProxy :: SProxy "name")</span></pre><p id="4460" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果你想得到<code class="du js jt ju ji b">name</code>字段的值，你可以使用<code class="du js jt ju ji b">view</code></p><pre class="jd je jf jg fd jh ji jj jk aw jl bi"><span id="35d9" class="jm jn hi ji b fi jo jp l jq jr">&gt;&gt;&gt; view _name {name : "Saravanan", age : "22"}</span></pre><p id="0082" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果您想覆盖该值，您可以使用<code class="du js jt ju ji b">set</code></p><pre class="jd je jf jg fd jh ji jj jk aw jl bi"><span id="b052" class="jm jn hi ji b fi jo jp l jq jr">setName :: Person -&gt; Person<br/>setName p = set _name "Saravanan M" p</span><span id="921f" class="jm jn hi ji b fi ms jp l jq jr">&gt;&gt;&gt; setName {name : "Saravanan", age : "22"}<br/>&gt;&gt;&gt; {name : "Saravanan M", age : "22"}</span></pre><p id="98c7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果你想覆盖先前的值，那么你可以使用<code class="du js jt ju ji b">over</code></p><pre class="jd je jf jg fd jh ji jj jk aw jl bi"><span id="11ea" class="jm jn hi ji b fi jo jp l jq jr">setName' :: Person -&gt; Person<br/>setName' p = over _name (\name -&gt; "Mr." &lt;&gt; name) p</span><span id="63c4" class="jm jn hi ji b fi ms jp l jq jr">&gt;&gt;&gt; setName' {name : "Saravanan", age : "22"}<br/>&gt;&gt;&gt; {name : "Mr.Saravanan", age : "22"}</span></pre><h2 id="2705" class="jm jn hi bd kq lr ls lt ku lu lv lw ky iq lx ly lc iu lz ma lg iy mb mc lk md bi translated">2.棱镜</h2><p id="fe81" class="pw-post-body-paragraph if ig hi ih b ii lm ik il im ln io ip iq lo is it iu lp iw ix iy lq ja jb jc hb bi translated">与透镜不同，透镜作用于产品类型，并且它所作用的结构<code class="du js jt ju ji b">s</code>总是具有值<code class="du js jt ju ji b">a</code>，棱镜作用于总和类型(如可能、任一等)，并且它所作用的结构<code class="du js jt ju ji b">s</code>可能具有也可能不具有它所要求的值<code class="du js jt ju ji b">a</code>。</p><p id="4271" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们假设我们正在处理类型</p><pre class="jd je jf jg fd jh ji jj jk aw jl bi"><span id="6a23" class="jm jn hi ji b fi jo jp l jq jr">type APIResponse = Either String Person</span></pre><p id="eaf1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">要获得左右值，您可以分别使用预定义的棱镜<code class="du js jt ju ji b">Left</code>和<code class="du js jt ju ji b">_Right</code>。</p><pre class="jd je jf jg fd jh ji jj jk aw jl bi"><span id="30e9" class="jm jn hi ji b fi jo jp l jq jr">getErrorResponse :: APIResponse -&gt; Maybe String<br/>getErrorResponse  =  preview _Left </span><span id="deee" class="jm jn hi ji b fi ms jp l jq jr">getSuccessResponse :: APIResponse -&gt; Maybe Person<br/>getSuccessResponse = preview _Right</span><span id="e48a" class="jm jn hi ji b fi ms jp l jq jr">&gt;&gt;&gt; getErrorResponse (Left "Failed")<br/>&gt;&gt;&gt; Just "Failed"</span><span id="2aa9" class="jm jn hi ji b fi ms jp l jq jr">&gt;&gt;&gt; getSuccessResponse (Left "Failed")<br/>&gt;&gt;&gt; Nothing</span></pre><blockquote class="mt mu mv"><p id="d98d" class="if ig mw ih b ii ij ik il im in io ip mx ir is it my iv iw ix mz iz ja jb jc hb bi translated">注意:从<strong class="ih hj">预览</strong>返回的值是<strong class="ih hj">可能是</strong>不像<code class="du js jt ju ji b">view</code>返回<code class="du js jt ju ji b">a</code></p></blockquote><p id="10ac" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">您也可以将<code class="du js jt ju ji b">over</code>、<code class="du js jt ju ji b">set</code>用于棱镜，就像用于镜头一样。</p></div><div class="ab cl ki kj gp kk" role="separator"><span class="kl bw bk km kn ko"/><span class="kl bw bk km kn ko"/><span class="kl bw bk km kn"/></div><div class="hb hc hd he hf"><p id="504e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果你想了解剩余的光学遍历，Iso，也想阅读更多关于这个主题的内容，我强烈建议你阅读托马斯·霍尼曼的<a class="ae jv" href="https://thomashoneyman.com/articles/practical-profunctor-lenses-optics/" rel="noopener ugc nofollow" target="_blank">这个精彩的博客</a>。</p><p id="fd6f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我希望你喜欢这个博客，拍手👏，分享👥如果你觉得这有帮助。我将在下一篇文章中看到另一个令人敬畏的 purescript 模块。</p></div></div>    
</body>
</html>