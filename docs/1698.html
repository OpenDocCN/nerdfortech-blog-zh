<html>
<head>
<title>React Redirections for Single Page Applications</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">对单页应用程序的重定向做出反应</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/react-redirections-for-single-page-applications-a7fe17cbe398?source=collection_archive---------4-----------------------#2021-04-02">https://medium.com/nerd-for-tech/react-redirections-for-single-page-applications-a7fe17cbe398?source=collection_archive---------4-----------------------#2021-04-02</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="a63b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">构建单页面 web 应用程序的最大优势之一是能够为页面上的特定组件选择更新，而不是完全重新加载一个新页面。除此之外，这消除了每次采取行动时重复服务器请求的需要，这可以显著提高程序速度。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es jd"><img src="../Images/e4f9ae86db11ff6c7a1062f84678d0cc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1170/format:webp/0*ZYm6eErqLvfCd4u4.jpg"/></div></figure><p id="6528" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">不幸的是，这种速度的提高是以跟踪浏览器历史为代价的。当你在单页应用中点击浏览器的后退按钮时，浏览器只知道最后加载的是哪个页面，而不知道应用之前的状态。</p><h1 id="a6eb" class="jl jm hi bd jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki bi translated">输入<code class="du kj kk kl km b">react-router-dom</code></h1><p id="e78b" class="pw-post-body-paragraph if ig hi ih b ii kn ik il im ko io ip iq kp is it iu kq iw ix iy kr ja jb jc hb bi translated">React Router 提供了一种在单页应用程序中声明路线导航并链接路线以呈现组件的方法。这样，您的程序可以复制单击链接查看不同页面内容的体验，同时技术上仍然保持在最初加载的 HTML 文件上。此外，该包允许您指定一个可以附加到浏览器的 URL 的路径，完成一个标准点击和重定向的外观。</p><p id="3562" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">要进行设置:</p><pre class="je jf jg jh fd ks km kt ku aw kv bi"><span id="0a13" class="kw jm hi km b fi kx ky l kz la">npm install react-router-dom</span></pre><p id="4c95" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">并声明你的路线(摘自我的<a class="ae lb" href="https://brownjer3.medium.com/gettin-nifty-with-react-js-80cb8615bc0" rel="noopener">最新项目</a>的 App.js):</p><pre class="je jf jg jh fd ks km kt ku aw kv bi"><span id="7ef7" class="kw jm hi km b fi kx ky l kz la">import { BrowserRouter as Router, Route } from 'react-router-dom'<br/>...<br/>  return (<br/>    &lt;div className="App"&gt;<br/>      &lt;Router&gt;<br/>        &lt;&gt;<br/>          &lt;NavbarContainer /&gt;<br/>          &lt;Route exact path="/" component={CalendarContainer} /&gt;<br/>          &lt;Route exact path="/tweets" component={TweetsContainer} /&gt;<br/>          &lt;Route exact path="/discover" component={DiscoverContainer} /&gt;<br/>          &lt;Route exact path="/new" component={EventFormContainer} /&gt;<br/>        &lt;/&gt;<br/>      &lt;/Router&gt;<br/>    &lt;/div&gt;<br/>  );</span></pre><p id="14d7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">然后在 navbar 组件中，您需要导入 NavLink:</p><pre class="je jf jg jh fd ks km kt ku aw kv bi"><span id="61e9" class="kw jm hi km b fi kx ky l kz la">import { NavLink } from 'react-router-dom'</span></pre><p id="31da" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">并指定每个链接的路径:</p><pre class="je jf jg jh fd ks km kt ku aw kv bi"><span id="ae19" class="kw jm hi km b fi kx ky l kz la">&lt;NavLink to="/new"&gt;Add Event&lt;/NavLink&gt;</span></pre><h1 id="7f73" class="jl jm hi bd jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki bi translated">重定向</h1><p id="c744" class="pw-post-body-paragraph if ig hi ih b ii kn ik il im ko io ip iq kp is it iu kq iw ix iy kr ja jb jc hb bi translated">现在开始有趣的部分——如何在单页 web 应用程序中重定向。在我的程序中，重定向的主要用例是在用户提交一个表单来创建一个新事件之后，应用程序应该重定向回主页，在那里他们可以查看他们新创建的事件。</p><p id="d7e4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">每个被声明的<Route/>被自动传递三个呈现方法:</p><ol class=""><li id="12a8" class="lc ld hi ih b ii ij im in iq le iu lf iy lg jc lh li lj lk bi translated">比赛</li><li id="cb8c" class="lc ld hi ih b ii ll im lm iq ln iu lo iy lp jc lh li lj lk bi translated">位置</li><li id="3260" class="lc ld hi ih b ii ll im lm iq ln iu lo iy lp jc lh li lj lk bi translated"><strong class="ih hj">历史</strong></li></ol><p id="b93f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们将关注历史来处理重定向。下面是我们呈现 EventFormContainer 时 this.props.history 的样子:</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="lr ls di lt bf lu"><div class="er es lq"><img src="../Images/e9db293c774d72cf1fa1e615d0e0628d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jQAHmNZGhPWv0iZf4R-seQ.png"/></div></div></figure><p id="4afa" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">根据<a class="ae lb" href="https://reactrouter.com/web/api/history" rel="noopener ugc nofollow" target="_blank">文档</a>，<code class="du kj kk kl km b">push(path, [state])</code>(函数)将一个新条目推入历史堆栈。换句话说，我们可以将一个路径推入历史对象来模拟重定向！</p><p id="0ca1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">最初的实现是把它放在表单提交时触发的 handleSubmit 回调函数的末尾。</p><pre class="je jf jg jh fd ks km kt ku aw kv bi"><span id="226d" class="kw jm hi km b fi kx ky l kz la">handleSubmit = (e) =&gt; {<br/>        e.preventDefault()<br/>        this.props.createEvent(this.state)<br/>        <strong class="km hj">this.props.history.push('/')</strong><br/>    }</span></pre><p id="7b73" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">厉害！我们现在在表单提交后重定向。但是，无论表单中提交的数据是否有效，这种实现都会导致重定向。为了确保重定向只在成功提交后<strong class="ih hj">发生，我们希望将其重新定位到我们的<strong class="ih hj"> createEvent 动作:</strong></strong></p><pre class="je jf jg jh fd ks km kt ku aw kv bi"><span id="6720" class="kw jm hi km b fi kx ky l kz la">export const createEvent = (<strong class="km hj">history</strong>, event) =&gt; {<br/>    return (dispatch) =&gt; {<br/>        const configObj = {<br/>            method: "POST", <br/>            headers: {<br/>                "Content-Type": "application/json", <br/>                "Accepts": "application/json"<br/>            }, <br/>            body: JSON.stringify(event)<br/>        }<br/>        fetch(url, configObj)<br/>        .then(res =&gt; res.json())<br/>        .then(data =&gt; {<br/>            dispatch({ type: 'ADD_EVENT', event: data })<br/>            <strong class="km hj">history.push('/')</strong><br/>        })<br/>    }<br/>}</span></pre><p id="c736" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">更新的 handleSubmit 回调:</p><pre class="je jf jg jh fd ks km kt ku aw kv bi"><span id="62cd" class="kw jm hi km b fi kx ky l kz la">handleSubmit = (e) =&gt; {<br/>        e.preventDefault()<br/>        this.props.createEvent(<strong class="km hj">this.props.history, </strong>this.state)<br/>    }</span></pre><p id="18ae" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在，页面只有在确认我们的 API post 请求成功后才会重定向。</p><h1 id="1158" class="jl jm hi bd jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki bi translated"><strong class="ak">嵌套组件</strong></h1><p id="9932" class="pw-post-body-paragraph if ig hi ih b ii kn ik il im ko io ip iq kp is it iu kq iw ix iy kr ja jb jc hb bi translated">如果您尝试重定向的组件是嵌套的，它不会自动接收匹配、位置和历史属性。作为通过许多组件层传递历史的替代方法，react-router-dom 提供了“withRouter”来访问历史对象的属性。</p><p id="7667" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">使用路由器导入到嵌套组件中:</p><pre class="je jf jg jh fd ks km kt ku aw kv bi"><span id="5b61" class="kw jm hi km b fi kx ky l kz la">import {withRouter} from 'react-router-dom'</span></pre><p id="547c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">然后确保包装导出的组件:</p><pre class="je jf jg jh fd ks km kt ku aw kv bi"><span id="3be9" class="kw jm hi km b fi kx ky l kz la">export default withRouter(NestedComponent)</span></pre><p id="c952" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">该组件现在可以完全访问同一个历史对象，并且可以在历史堆栈上执行相同的推送，而无需接收历史作为道具。</p><p id="267a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">虽然在我的程序的当前状态中，重定向只有一个明显的用途，但是很明显，如果项目扩展到用户注册、编辑事件细节等新功能中，这将是多么有用。</p><p id="6e44" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">你可以点击这里查看我的最新版 NFT 日历。随时提交一个新的 NFT 下降事件，体验单页重定向的魔力！</p></div></div>    
</body>
</html>