<html>
<head>
<title>Developing a Custom Plugin using Flutter</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用 Flutter 开发自定义插件</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/developing-a-custom-plugin-using-flutter-ec37cc4bbe45?source=collection_archive---------10-----------------------#2021-05-28">https://medium.com/nerd-for-tech/developing-a-custom-plugin-using-flutter-ec37cc4bbe45?source=collection_archive---------10-----------------------#2021-05-28</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/54a003c8d77943d02c842c6d3f3dc7bb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XUUqBJhU5E0XvRjXv-2xqg.png"/></div></div></figure><p id="1e60" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><a class="ae jo" href="https://flutter.dev/" rel="noopener ugc nofollow" target="_blank"> Flutter </a>是 Google 免费开源的 UI 应用开发工具包。它用于使用单一代码库在 Android 和 iOS 上构建高质量的原生界面。关于 Flutter 的一个有趣的事情是，它可以与现有的代码一起工作，并且被全世界的开发者和组织所使用。在这篇文章中，我们将学习如何使用 Flutter 开发一个自定义插件。</p><p id="e3de" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">作为我们在<a class="ae jo" href="https://rudderstack.com/" rel="noopener ugc nofollow" target="_blank"> RudderStack </a>的 SDK 路线图的一部分，我们想要开发一个 Flutter SDK。我们现有的 SDK 包括诸如在数据库中存储事件细节和持久化用户细节等功能。然而，这些功能已经在我们的 Android 和 iOS SDKs 中实现了。</p><p id="0b0c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们打算开发的 Flutter SDK 也可以在你的 Android 或 iOS 设备上运行。因此，我们希望开发一个解决方案，可以使用我们现有的 Android 和 iOS SDK，并开发 Flutter SDK。</p><p id="2967" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">所有的头脑风暴最终让我们想到在 Flutter 中开发一个自定义插件。定制插件遵循基于 Flutter 灵活系统的基本机制，允许调用 Android 上 Kotlin 或 Java 中可用的特定平台 API，或 iOS 上的 Swift 或 Objective-C 代码。</p><h1 id="fb2b" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">Flutter SDK 在不同通道上的工作</h1><p id="0bad" class="pw-post-body-paragraph iq ir hi is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hb bi translated">Flutter 内置的特定于平台的 API 支持不依赖于代码生成，而是依赖于使用平台通道的灵活的消息传递风格。为了创建一个自定义插件，让我们详细了解一下 Flutter 架构:</p><ul class=""><li id="6c86" class="ks kt hi is b it iu ix iy jb ku jf kv jj kw jn kx ky kz la bi translated">该应用程序的 Flutter 部分通过平台通道向其<em class="lb">主机</em>发送消息——该应用程序的 iOS 或 Android 部分。</li><li id="c1e1" class="ks kt hi is b it lc ix ld jb le jf lf jj lg jn kx ky kz la bi translated"><em class="lb">主机</em>监听平台信道并接收消息。然后，它调用任意数量的特定于平台的 API——使用本机编程语言——并将响应发送回应用程序的 Flutter 部分<em class="lb">客户端</em>,如下所示:</li></ul><figure class="li lj lk ll fd ij er es paragraph-image"><div class="er es lh"><img src="../Images/a2abe8b72baa388b6beb1d0b6f6d5fc9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1160/format:webp/0*fv1NjaBIBSf5VZXh.png"/></div></figure><p id="308b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">平台通道如何在不同平台间工作的架构概述</strong></p><h1 id="7c0c" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">使用 Flutter 构建自定义插件</h1><h1 id="55b5" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">入门指南</h1><p id="e6b9" class="pw-post-body-paragraph iq ir hi is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hb bi translated">下面的示例演示了如何调用特定于平台的 API 来检索和显示当前的电池电量。它使用 Android <code class="du lm ln lo lp b">BatteryManager</code> API 和 iOS <code class="du lm ln lo lp b">device.batteryLevel</code> API，通过单一平台消息<code class="du lm ln lo lp b">getBatteryLevel()</code>。</p><h1 id="7384" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">步骤 1:创建包</h1><p id="1346" class="pw-post-body-paragraph iq ir hi is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hb bi translated">要创建插件包，</p><ul class=""><li id="4370" class="ks kt hi is b it iu ix iy jb ku jf kv jj kw jn kx ky kz la bi translated">用<code class="du lm ln lo lp b">create</code>命令使用<code class="du lm ln lo lp b">--template=plugin</code>旗。</li><li id="0400" class="ks kt hi is b it lc ix ld jb le jf lf jj lg jn kx ky kz la bi translated">使用<code class="du lm ln lo lp b">--platforms=</code>选项后跟一个逗号分隔的列表来指定插件支持的平台。可用的平台有 Android、iOS、web、Linux、macOS 和 Windows。</li><li id="ce71" class="ks kt hi is b it lc ix ld jb le jf lf jj lg jn kx ky kz la bi translated">使用<code class="du lm ln lo lp b">--org</code>选项指定您的组织，使用反向域名表示法。该值用于生成的插件代码中的各种包和包标识符。</li><li id="3809" class="ks kt hi is b it lc ix ld jb le jf lf jj lg jn kx ky kz la bi translated">使用<code class="du lm ln lo lp b">-a</code>选项为 Android 指定语言，或使用<strong class="is hj"> -i </strong>选项为 iOS 指定语言。</li><li id="cff4" class="ks kt hi is b it lc ix ld jb le jf lf jj lg jn kx ky kz la bi translated">下面是使用 java for Android 和 Objective-C for iOS 为 Android、iOS 平台创建插件包的示例命令。</li></ul><pre class="li lj lk ll fd lq lp lr ls aw lt bi"><span id="6e43" class="lu jq hi lp b fi lv lw l lx ly">flutter create --org com.rudderstack --template=plugin --platforms=android,ios -a java -i objc batteryLevel</span></pre><ul class=""><li id="abf9" class="ks kt hi is b it iu ix iy jb ku jf kv jj kw jn kx ky kz la bi translated">该命令在<code class="du lm ln lo lp b">batteryLevel</code>文件夹中创建一个插件项目，具体内容如下:</li></ul><p id="a161" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><code class="du lm ln lo lp b">lib/batteryLevel.dart -</code>插件的 Dart API。</p><p id="5e01" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><code class="du lm ln lo lp b">android/src/main/java/com/rudderstack/batteryLevel/BatteryLevelPlugin.java</code>-Java 中插件 API 的 Android 平台特定实现。</p><p id="2ece" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><code class="du lm ln lo lp b">ios/Classes/BatteryLevelPlugin.m</code>-Objective-c 中插件 API 的 iOS 平台特定实现。</p><p id="21dc" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><code class="du lm ln lo lp b">example/</code> -一个依赖于插件的 Flutter 应用，演示了如何使用它。</p><p id="71a4" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在 Flutter 网站上查看不同的 dart 值在平台端是如何接收的，反之亦然。</p><h1 id="8915" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">步骤 2:创建 Flutter 平台客户端</h1><p id="0ce2" class="pw-post-body-paragraph iq ir hi is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hb bi translated">应用程序的<code class="du lm ln lo lp b">State</code>类保存当前的应用程序状态。扩展以保持当前的电池状态。</p><ul class=""><li id="d6d8" class="ks kt hi is b it iu ix iy jb ku jf kv jj kw jn kx ky kz la bi translated">首先，用返回电池电量的单平台方法使用<code class="du lm ln lo lp b">MethodChannel</code>构建通道。</li><li id="7196" class="ks kt hi is b it lc ix ld jb le jf lf jj lg jn kx ky kz la bi translated">通道的客户端和主机端通过通道构造函数中传递的通道名称连接。</li></ul><p id="5319" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">注意:单个应用程序中使用的所有频道名称必须是唯一的。</p><ul class=""><li id="2f7b" class="ks kt hi is b it iu ix iy jb ku jf kv jj kw jn kx ky kz la bi translated">用唯一的<em class="lb">域前缀</em>作为频道名称的前缀。比如<code class="du lm ln lo lp b">org.rudderstack.dev/battery</code>。</li><li id="2d99" class="ks kt hi is b it lc ix ld jb le jf lf jj lg jn kx ky kz la bi translated">打开位于<code class="du lm ln lo lp b">lib</code>文件夹中的<code class="du lm ln lo lp b">batteryLevel.dart</code>文件。</li><li id="cc2e" class="ks kt hi is b it lc ix ld jb le jf lf jj lg jn kx ky kz la bi translated">创建如下所示的<code class="du lm ln lo lp b">method</code>通道对象，通道名称为<code class="du lm ln lo lp b">org.rudderstack.dev/battery</code>。</li><li id="d1c8" class="ks kt hi is b it lc ix ld jb le jf lf jj lg jn kx ky kz la bi translated">请确保您在 Android 和 iOS 平台上使用与 Flutter 中相同的名称初始化 channel 对象。</li></ul><pre class="li lj lk ll fd lq lp lr ls aw lt bi"><span id="7cab" class="lu jq hi lp b fi lv lw l lx ly">import 'dart:async';</span><span id="40ec" class="lu jq hi lp b fi lz lw l lx ly">import 'package:flutter/services.dart';</span><span id="1c61" class="lu jq hi lp b fi lz lw l lx ly">class BatteryLevel {<br/>  static const MethodChannel _channel =<br/>      MethodChannel('org.rudderstack.dev/battery');</span><span id="1b41" class="lu jq hi lp b fi lz lw l lx ly"> // Get battery level.<br/>}</span></pre><ul class=""><li id="a5ec" class="ks kt hi is b it iu ix iy jb ku jf kv jj kw jn kx ky kz la bi translated">接下来，调用方法通道上的方法，使用字符串标识符<code class="du lm ln lo lp b">getBatteryLevel</code>指定要调用的具体方法。例如，如果平台不支持平台 API(比如在模拟器中运行)，调用可能会失败。因此，用一个<code class="du lm ln lo lp b">try-catch</code>语句来包装这个<code class="du lm ln lo lp b">invokeMethod</code>调用。</li><li id="2921" class="ks kt hi is b it lc ix ld jb le jf lf jj lg jn kx ky kz la bi translated">获得电池电量后，使用以下代码返回它:</li></ul><pre class="li lj lk ll fd lq lp lr ls aw lt bi"><span id="29dc" class="lu jq hi lp b fi lv lw l lx ly">// Get battery level.<br/>  static Future&lt;String&gt; getBatteryLevel() async {<br/>    String batteryLevel;<br/>    try {<br/>      final int result = await _channel.invokeMethod('getBatteryLevel');<br/>      batteryLevel = 'Battery level: $result%.';<br/>    } on PlatformException {<br/>      batteryLevel = 'Failed to get battery level.';<br/>    }<br/>    return batteryLevel;<br/>  }<br/>}</span></pre><ul class=""><li id="26c3" class="ks kt hi is b it iu ix iy jb ku jf kv jj kw jn kx ky kz la bi translated">现在，替换<code class="du lm ln lo lp b">example/lib/main.dart</code>文件以包含一个小的用户界面，该界面以字符串形式显示电池状态，并包含一个用于刷新值的按钮:</li></ul><pre class="li lj lk ll fd lq lp lr ls aw lt bi"><span id="3f5a" class="lu jq hi lp b fi lv lw l lx ly">import 'package:flutter/material.dart';<br/>import 'dart:async';</span><span id="b53e" class="lu jq hi lp b fi lz lw l lx ly">import 'package:flutter/services.dart';<br/>import 'package:batteryLevel/batteryLevel.dart';</span><span id="780f" class="lu jq hi lp b fi lz lw l lx ly">void main() {<br/>  runApp(MaterialApp(home: MyApp()));<br/>}</span><span id="0cb9" class="lu jq hi lp b fi lz lw l lx ly">class MyApp extends StatefulWidget {<br/>  @override<br/>  _MyAppState createState() =&gt; _MyAppState();<br/>}</span><span id="315c" class="lu jq hi lp b fi lz lw l lx ly">class _MyAppState extends State&lt;MyApp&gt; {<br/>  String _batteryLevel = 'Unknown';</span><span id="76f2" class="lu jq hi lp b fi lz lw l lx ly">  @override<br/>  void initState() {<br/>    super.initState();<br/>  }</span><span id="a7f6" class="lu jq hi lp b fi lz lw l lx ly">  // Platform messages are asynchronous, so we initialize in an async method.<br/>  Future&lt;void&gt; _getBatteryLevel() async {<br/>    String batteryLevel;<br/>    // Platform messages may fail, so we use a try/catch PlatformException.<br/>    try {<br/>      batteryLevel = await BatteryLevel.getBatteryLevel();<br/>    } on PlatformException {<br/>      batteryLevel = 'Failed to get platform version.';<br/>    }</span><span id="a28b" class="lu jq hi lp b fi lz lw l lx ly">    // If the widget was removed from the tree while the asynchronous platform<br/>    // message was in flight, and we want to discard the reply rather than calling<br/>    // setState to update our non-existent appearance.<br/>    if (!mounted) return;</span><span id="0b35" class="lu jq hi lp b fi lz lw l lx ly">    setState(() {<br/>      _batteryLevel = batteryLevel;<br/>    });<br/>  }</span><span id="b340" class="lu jq hi lp b fi lz lw l lx ly">  @override<br/>  Widget build(BuildContext context) {<br/>    return Material(<br/>      child: Center(<br/>        child: Column(<br/>          mainAxisAlignment: MainAxisAlignment.spaceEvenly,<br/>          children: [<br/>            ElevatedButton(<br/>              child: Text('Get Battery Level'),<br/>              onPressed: _getBatteryLevel,<br/>            ),<br/>            Text(_batteryLevel),<br/>          ],<br/>        ),<br/>      ),<br/>    );<br/>  }<br/>}</span></pre><h1 id="378c" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">步骤 3:添加特定于 Android 平台的实现</h1><p id="2f2f" class="pw-post-body-paragraph iq ir hi is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hb bi translated">在<code class="du lm ln lo lp b">android/src/main/java/com/rudderstack/batteryLevel/</code>内打开<code class="du lm ln lo lp b">BatteryLevelPlugin.java</code>，进行如下更改:</p><ul class=""><li id="7ce8" class="ks kt hi is b it iu ix iy jb ku jf kv jj kw jn kx ky kz la bi translated">首先，将<code class="du lm ln lo lp b">MethodChannel</code>对象初始化中的通道名改为<code class="du lm ln lo lp b">org.rudderstack.dev/battery</code>，如下所示:</li></ul><pre class="li lj lk ll fd lq lp lr ls aw lt bi"><span id="766c" class="lu jq hi lp b fi lv lw l lx ly">@Override<br/>  public void onAttachedToEngine(<br/>    @NonNull FlutterPluginBinding flutterPluginBinding<br/>  ) {<br/>    channel =<br/>      new MethodChannel(<br/>        flutterPluginBinding.getBinaryMessenger(),<br/>        "org.rudderstack.dev/battery"<br/>      );<br/>    channel.setMethodCallHandler(this);<br/>  }</span></pre><ul class=""><li id="9c0c" class="ks kt hi is b it iu ix iy jb ku jf kv jj kw jn kx ky kz la bi translated">现在，用下面显示的定义替换<code class="du lm ln lo lp b">onMethodCall</code>来处理<code class="du lm ln lo lp b">getBatteryLevel</code>调用，并用<code class="du lm ln lo lp b">batteryLevel</code>响应如下:</li></ul><pre class="li lj lk ll fd lq lp lr ls aw lt bi"><span id="f902" class="lu jq hi lp b fi lv lw l lx ly">@Override<br/>  public void onMethodCall(@NonNull MethodCall call, @NonNull Result result) {<br/>    if (call.method.equals("getBatteryLevel")) {<br/>      result.success(99);<br/>    } else {<br/>      result.notImplemented();<br/>    }<br/>  }</span></pre><h1 id="152a" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">步骤 4:添加特定于 iOS 平台的实现</h1><p id="0a8a" class="pw-post-body-paragraph iq ir hi is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hb bi translated">打开<code class="du lm ln lo lp b">ios/Classes/</code>下的<code class="du lm ln lo lp b">BatteryLevelPlugin.m</code>,进行以下更改:</p><ul class=""><li id="76ea" class="ks kt hi is b it iu ix iy jb ku jf kv jj kw jn kx ky kz la bi translated">首先，将<code class="du lm ln lo lp b">FlutterMethodChannel</code>对象初始化中的通道名称改为<code class="du lm ln lo lp b">org.rudderstack.dev/battery</code>，如下所示:</li></ul><pre class="li lj lk ll fd lq lp lr ls aw lt bi"><span id="87b5" class="lu jq hi lp b fi lv lw l lx ly">+ (void)registerWithRegistrar:(NSObject&lt;FlutterPluginRegistrar&gt;*)registrar {<br/>  FlutterMethodChannel* channel = [FlutterMethodChannel<br/>      methodChannelWithName:@"org.rudderstack.dev/battery"<br/>            binaryMessenger:[registrar messenger]];<br/>  BatteryLevelPlugin* instance = [[BatteryLevelPlugin alloc] init];<br/>  [registrar addMethodCallDelegate:instance channel:channel];<br/>}</span></pre><ul class=""><li id="85a0" class="ks kt hi is b it iu ix iy jb ku jf kv jj kw jn kx ky kz la bi translated">接下来，用下面的定义替换<code class="du lm ln lo lp b">handleMethodCall</code>方法来处理<code class="du lm ln lo lp b">getBatteryLevel</code>调用，并用<code class="du lm ln lo lp b">batteryLevel</code>响应，如下所示:</li></ul><pre class="li lj lk ll fd lq lp lr ls aw lt bi"><span id="d928" class="lu jq hi lp b fi lv lw l lx ly">- (void)handleMethodCall:(FlutterMethodCall*)call result:(FlutterResult)result {<br/>  if ([@"getBatteryLevel" isEqualToString:call.method]) {<br/>    result(@(99));<br/>  } else {<br/>    result(FlutterMethodNotImplemented);<br/>  }<br/>}</span></pre><p id="7a5d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这样，我们成功地开发了一个自定义插件。现在你可以在任何两个平台(Android 和 iOS)上运行这个插件，并了解它是如何工作的。</p><h1 id="c47f" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">发布自定义插件</h1><p id="6676" class="pw-post-body-paragraph iq ir hi is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hb bi translated">让我们快速看一下开发定制插件后需要记住的一些说明:</p><ul class=""><li id="5f69" class="ks kt hi is b it iu ix iy jb ku jf kv jj kw jn kx ky kz la bi translated">开发完自定义插件后，可以在<a class="ae jo" href="https://pub.dev/" rel="noopener ugc nofollow" target="_blank"> pub.dev </a>发布自定义插件，方便其他开发者使用。但是，在发布之前，请检查<code class="du lm ln lo lp b">pubspec.yaml</code>、<code class="du lm ln lo lp b">README.md</code>、<code class="du lm ln lo lp b">CHANGELOG.md</code>和<code class="du lm ln lo lp b">LICENSE</code>文件，以确保内容完整和正确。</li><li id="5eeb" class="ks kt hi is b it lc ix ld jb le jf lf jj lg jn kx ky kz la bi translated">接下来，在<code class="du lm ln lo lp b">dry-run</code>模式下运行发布命令，看看是否一切都通过了分析:</li></ul><p id="bd7c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj"> $ flutter 出版社出版—预演</strong></p><ul class=""><li id="ef94" class="ks kt hi is b it iu ix iy jb ku jf kv jj kw jn kx ky kz la bi translated">下一步是发布到 pub.dev，但是请确保您已经准备好了，因为发布是不可恢复的最后一步:</li></ul><p id="d1eb" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj"> $扑扑出版社发布</strong></p><p id="7f09" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">有关发布的更多细节，请查看 dart.dev 上的<a class="ae jo" href="https://dart.dev/tools/pub/publishing" rel="noopener ugc nofollow" target="_blank">发布文档</a></p><p id="be8c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">参考资料:</p><ul class=""><li id="0b28" class="ks kt hi is b it iu ix iy jb ku jf kv jj kw jn kx ky kz la bi translated"><a class="ae jo" href="https://flutter.dev/docs/development/packages-and-plugins/developing-packages" rel="noopener ugc nofollow" target="_blank">https://flutter . dev/docs/development/packages-and-plugins/developing-packages</a></li><li id="bf88" class="ks kt hi is b it lc ix ld jb le jf lf jj lg jn kx ky kz la bi translated"><a class="ae jo" href="https://flutter.dev/docs/development/platform-integration/platform-channels?tab=android-channel-java-tab" rel="noopener ugc nofollow" target="_blank">https://flutter . dev/docs/development/platform-integration/platform-channels？tab = Android-channel-Java-tab</a></li></ul><p id="a376" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">您还可以查看以下 Github 资源库:</p><ul class=""><li id="88e7" class="ks kt hi is b it iu ix iy jb ku jf kv jj kw jn kx ky kz la bi translated"><a class="ae jo" href="https://github.com/desusai7/flutter-custom-plugin" rel="noopener ugc nofollow" target="_blank">本文中创建的示例应用程序。</a></li><li id="9ede" class="ks kt hi is b it lc ix ld jb le jf lf jj lg jn kx ky kz la bi translated"><a class="ae jo" href="https://github.com/rudderlabs/rudder-sdk-flutter" rel="noopener ugc nofollow" target="_blank">舵栈的颤振 SDK </a></li></ul><p id="4dcf" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">你可以从<a class="ae jo" href="http://pub.dev/" rel="noopener ugc nofollow" target="_blank"> pub.dev </a>下载 Rudderstack 的 Flutter SDK 作为你的 Flutter 应用的依赖。</p><p id="3be0" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如果你对应用程序开发感兴趣，请查看 G2i 在 React Native 上的这篇文章，了解 React Native 开发者最重要的技能和属性。</p><h1 id="ed2b" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">免费注册并开始发送数据</h1><p id="31e6" class="pw-post-body-paragraph iq ir hi is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hb bi translated">测试我们的事件流、ELT 和反向 ETL 管道。使用我们的 HTTP 源在不到 5 分钟的时间内发送数据，或者在您的网站或应用程序中安装我们 12 个 SDK 中的一个。<a class="ae jo" href="https://app.rudderlabs.com/signup?type=freetrial" rel="noopener ugc nofollow" target="_blank">入门</a>。</p><p id="f088" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">本博客原载于</strong><a class="ae jo" href="https://rudderstack.com/blog/developing-a-custom-plugin-using-flutter" rel="noopener ugc nofollow" target="_blank"><strong class="is hj">https://rudder stack . com/blog/developing-a-custom-plugin-using-flutter</strong></a></p></div></div>    
</body>
</html>