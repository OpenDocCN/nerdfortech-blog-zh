<html>
<head>
<title>Live Streaming using OpenCV</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用OpenCV进行直播</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/live-streaming-using-opencv-c0ef28a5e497?source=collection_archive---------0-----------------------#2021-06-05">https://medium.com/nerd-for-tech/live-streaming-using-opencv-c0ef28a5e497?source=collection_archive---------0-----------------------#2021-06-05</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="c449" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">至少有一次我们使用了直播，但却想知道如何通过编程来实现。</p><p id="3dde" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">大家好，我在这里给你们带来了一些使用OpenCV和python套接字编程的乐趣</p><p id="6bda" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">今天，我们将在OpenCV和socket编程的帮助下创建一个直播应用程序，我们将从头开始为服务器和客户端开发代码。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es jd"><img src="../Images/d20f66fbfa8b8b9d91e1d040f3e63cb5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0-OJ1LGEmEj-_9oZgjh_cg.jpeg"/></div></div></figure><p id="ebd7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">Opencv是什么？</strong></p><p id="2fb6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Opencv是一个计算机视觉库。这个库具有多种功能，因此我们可以使用网络摄像头和编程来处理我们的图像和视频。</p><p id="adc0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">什么是套接字编程？</strong></p><p id="21b1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">简单地说，套接字编程意味着一个端口上的两台或多台服务器之间使用TCP或UDP等互联网协议进行通信。更多关于socket和OpenCV的内容我们将在代码中讨论</p><h2 id="1bfc" class="jp jq hi bd jr js jt ju jv jw jx jy jz iq ka kb kc iu kd ke kf iy kg kh ki kj bi translated">让我们开发一个服务器</h2><p id="a2d3" class="pw-post-body-paragraph if ig hi ih b ii kk ik il im kl io ip iq km is it iu kn iw ix iy ko ja jb jc hb bi translated">在服务器上，当客户端连接到服务器时，应用程序将使用端口号和IP地址运行，然后服务器接收数据并将其转换为流。</p><p id="dbcc" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在运行代码之前，确保您已经下载了python中的以下库</p><pre class="je jf jg jh fd kp kq kr ks aw kt bi"><span id="3ebb" class="jp jq hi kq b fi ku kv l kw kx"><strong class="kq hj">pip install packagename</strong></span></pre><p id="fee3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">opencv-python，numpy，pickle</p><pre class="je jf jg jh fd kp kq kr ks aw kt bi"><span id="8fe2" class="jp jq hi kq b fi ku kv l kw kx"><strong class="kq hj">import cv2, socket, numpy, pickle</strong></span><span id="15fb" class="jp jq hi kq b fi ky kv l kw kx"><strong class="kq hj">s=socket.socket(socket.AF_INET , socket.SOCK_DGRAM)</strong></span><span id="fd6a" class="jp jq hi kq b fi ky kv l kw kx"><strong class="kq hj">ip="192.168.1.5"</strong></span><span id="8c9f" class="jp jq hi kq b fi ky kv l kw kx"><strong class="kq hj">port=6666</strong></span><span id="1cd9" class="jp jq hi kq b fi ky kv l kw kx"><strong class="kq hj">s.bind((ip,port))</strong></span></pre><p id="fc60" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在上面的代码中，我们已经导入了任务所需的库。变量将存储socket和socket的地址。AF_INET代表我们使用ipv4作为套接字。socket.sock_DGRAM用于UDP协议，代表用户数据报协议。有时使用它是有风险的，因为假设我们的数据包没有到达用户，它不会告诉我们，所以我们有数据丢失的风险，而不是它很容易使用。我们也可以使用TCP，但是它会使我们的代码有点复杂，所以对于basic我们使用UDP</p><p id="e14f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">“ip”变量包含您计算机的IP地址,“port”号包含您运行进程的端口。您可以根据自己的选择给出任何端口号，因为它只是一个正在运行并向外界公开的进程</p><p id="9119" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">s.bind()函数会绑定我们的“ip”和“port”号并转换成socket。简单来说就是元组。现在我们已经完成了socket。</p><pre class="je jf jg jh fd kp kq kr ks aw kt bi"><span id="2a81" class="jp jq hi kq b fi ku kv l kw kx"><strong class="kq hj">while True:</strong></span><span id="7c0e" class="jp jq hi kq b fi ky kv l kw kx"><strong class="kq hj">    x=s.recvfrom(1000000)</strong></span><span id="475f" class="jp jq hi kq b fi ky kv l kw kx"><strong class="kq hj">    clientip = x[1][0]</strong></span><span id="b315" class="jp jq hi kq b fi ky kv l kw kx"><strong class="kq hj">    data=x[0]</strong></span><span id="e111" class="jp jq hi kq b fi ky kv l kw kx"><strong class="kq hj">    print(data)</strong></span><span id="fcfc" class="jp jq hi kq b fi ky kv l kw kx"><strong class="kq hj">    data=pickle.loads(data)</strong></span><span id="c07c" class="jp jq hi kq b fi ky kv l kw kx"><strong class="kq hj">    print(type(data))</strong></span><span id="5b7a" class="jp jq hi kq b fi ky kv l kw kx"><strong class="kq hj">    data = cv2.imdecode(data, cv2.IMREAD_COLOR)</strong></span><span id="1d61" class="jp jq hi kq b fi ky kv l kw kx"><strong class="kq hj">    cv2.imshow('server', data) #to open image</strong></span><span id="7f70" class="jp jq hi kq b fi ky kv l kw kx"><strong class="kq hj">    if cv2.waitKey(10) == 13:</strong></span><span id="180c" class="jp jq hi kq b fi ky kv l kw kx"><strong class="kq hj">        break</strong></span><span id="bbf2" class="jp jq hi kq b fi ky kv l kw kx"><strong class="kq hj">cv2.destroyAllWindows()</strong></span></pre><p id="5358" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">上述函数将从客户端接收的数据暂时存储到' x '变量中。在“clientip”中，我们使用切片数组和数据变量存储了客户端的ip地址。现在，我们将使用函数imdecode对数据变量中接收的数据进行解码，imshow函数将显示一个流窗口。cv2.waitkey(10)将每10毫秒点击/收集一次数据，直到您按下enter并输入has number 13。当你按回车键时，destroyAllWindows()将关闭应用程序。</p><h2 id="3330" class="jp jq hi bd jr js jt ju jv jw jx jy jz iq ka kb kc iu kd ke kf iy kg kh ki kj bi translated"><strong class="ak">我们来配置客户端</strong></h2><p id="bc2f" class="pw-post-body-paragraph if ig hi ih b ii kk ik il im kl io ip iq km is it iu kn iw ix iy ko ja jb jc hb bi translated">现在，当我们在给定的服务器IP和端口号上连接客户端时，它们之间的通信就开始了。</p><pre class="je jf jg jh fd kp kq kr ks aw kt bi"><span id="8bdf" class="jp jq hi kq b fi ku kv l kw kx"><strong class="kq hj">import cv2, socket, pickle, os  </strong></span><span id="7ef9" class="jp jq hi kq b fi ky kv l kw kx"><strong class="kq hj">s=socket.socket(socket.AF_INET,socket.SOCK_DGRAM)</strong></span><span id="d3e0" class="jp jq hi kq b fi ky kv l kw kx"><strong class="kq hj">s.setsockopt(socket.SOL_SOCKET, socket.SO_SNDBUF, 10000000)</strong></span><span id="dc23" class="jp jq hi kq b fi ky kv l kw kx"><strong class="kq hj">serverip="192.168.1.5"</strong></span><span id="a71b" class="jp jq hi kq b fi ky kv l kw kx"><strong class="kq hj">serverport=6666</strong></span></pre><p id="2fab" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在这里，我们首先导入了socket和OpenCV所需的库，并且“s”存储了<strong class="ih hj"> socket的地址。AF_INET </strong>代表IP家族v4和<strong class="ih hj">套接字。SOCK_DGRAM </strong>这个关键字是针对UDP协议的，第三行将创建一个缓冲区大小，这样我们就可以存储一个数据的缓冲区来连续传输它。“serveip”和“serverport”保存服务器的ip地址和端口号。</p><pre class="je jf jg jh fd kp kq kr ks aw kt bi"><span id="8a7c" class="jp jq hi kq b fi ku kv l kw kx"><strong class="kq hj">cap = cv2.VideoCapture(0)<br/>while True:    <br/>    ret,photo = cap.read()    <br/>    <br/>    cv2.imshow('streaming', photo)    <br/>    <br/>    ret, buffer = cv2.imencode(".jpg", photo,[int(cv2.IMWRITE_JPEG_QUALITY),30])    </strong></span><span id="e6d6" class="jp jq hi kq b fi ky kv l kw kx"><strong class="kq hj">    x_as_bytes = pickle.dumps(buffer)    <br/>    <br/>    s.sendto(x_as_bytes,(serverip , serverport))    <br/>    <br/>    if cv2.waitKey(10) == 13:        <br/>        <br/>          break  </strong></span><span id="5d4a" class="jp jq hi kq b fi ky kv l kw kx"><strong class="kq hj">cv2.destroyAllWindows()</strong></span><span id="a9f0" class="jp jq hi kq b fi ky kv l kw kx"><strong class="kq hj">cap.release()</strong></span></pre><p id="ee9c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> VedioCapture(0) </strong>存储功能地址和用于存储网络摄像头的‘0’。ret存储返回值和照片，并存储<strong class="ih hj"> cap.read( </strong>)的输出。该函数将读取图像。imshow将显示流窗口。缓冲变量将存储你的数据流，并提供给服务器。<strong class="ih hj"> pickle.dumps(buffer) </strong>该函数将数据转储到一个变量中。发送到一个函数将数据与IP和端口号绑定，这样我们就可以发送它。<strong class="ih hj">等待键</strong>将每10毫秒收集一次数据，直到我们按下enter键，输入的代码为13。<strong class="ih hj"> destroyAllWindows() </strong>会销毁Windows，<strong class="ih hj"> cap.release() </strong>会关闭我们的摄像头。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es jd"><img src="../Images/dab6cd864863d5dff2828e33dc0e8278.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*U57wFpoDGQzz8JQWIINEyA.png"/></div></div><figcaption class="kz la et er es lb lc bd b be z dx translated"><strong class="bd jr">在这里，您可以清楚地看到接收到的数据和两端发生的数据流。</strong></figcaption></figure><p id="5e37" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在这里，我将第二台机器用作虚拟机，这样您可以看到两个相同的映像。</p><p id="24d1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">你会发现完整的代码<a class="ae ld" href="https://github.com/abhikesare9/live-streaming-with-opencv" rel="noopener ugc nofollow" target="_blank"> <strong class="ih hj"> GITHUB </strong> </a></p></div></div>    
</body>
</html>