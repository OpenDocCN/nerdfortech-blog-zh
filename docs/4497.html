<html>
<head>
<title>Clustering in Machine learning.</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">机器学习中的聚类。</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/clustering-in-machine-learning-2537942d63bd?source=collection_archive---------14-----------------------#2021-07-23">https://medium.com/nerd-for-tech/clustering-in-machine-learning-2537942d63bd?source=collection_archive---------14-----------------------#2021-07-23</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/85d710fa8762f9e09742e74c8462f425.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KGgvNEzQ2Ht1-WGPhUdSQQ.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">学分:<a class="ae iu" href="https://images.unsplash.com/photo-1542838132-92c53300491e?ixid=MnwxMjA3fDB8MHxzZWFyY2h8Mnx8dmVnZXRhYmxlJTIwbWFya2V0fGVufDB8fDB8fA%3D%3D&amp;ixlib=rb-1.2.1&amp;w=1000&amp;q=80" rel="noopener ugc nofollow" target="_blank"> Unsplash </a></figcaption></figure><p id="7eda" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">让我们从一个例子开始。你可能在超市里看到过相似的蔬菜是如何被分组放在一个区<em class="jt">(上图)</em>。如果你想让机器来做，机器首先需要找到模式，识别相似的模式，并把它们放在一起。这就是聚类的含义<em class="jt">(简单来说)</em>，它识别模式并将它们分组为簇。</p><p id="d069" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">今天，我们将学习一种不同的ML方法。在ML中，我们基本上采用数据集，用数据训练模型，并预测结果。当数据被标记/监督时，这很容易。但是无监督的数据呢？在现实世界中，有很多数据集是没有标记的，我们需要方法来处理这类数据。这就是集群的用途。</p><p id="f378" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在开始聚类之前，让我们先了解一下无监督数据的实际含义。</p><h1 id="2894" class="ju jv hi bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated"><strong class="ak"> <em class="ks">无监督数据:</em> </strong></h1><p id="dd82" class="pw-post-body-paragraph iv iw hi ix b iy kt ja jb jc ku je jf jg kv ji jj jk kw jm jn jo kx jq jr js hb bi translated">正如我前面提到的，无监督的数据意味着无标签的数据。人工智能应该利用这些数据，通过自我学习来总结模式。它基本上是自己做观察，自己下结论。使用这些数据的好处是，AI可以在数据集中找到异常和缺陷。由于这没有标记数据，这使得我们的工作更容易。</p><p id="5844" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们可以用两种方式处理无监督数据:</p><ol class=""><li id="8315" class="ky kz hi ix b iy iz jc jd jg la jk lb jo lc js ld le lf lg bi translated"><strong class="ix hj"> <em class="jt">聚类</em> </strong> <em class="jt">(查找模式并将它们分组)</em></li><li id="595e" class="ky kz hi ix b iy lh jc li jg lj jk lk jo ll js ld le lf lg bi translated"><strong class="ix hj"> <em class="jt">关联</em> </strong> <em class="jt">(它发现一个数据项对另一个数据项的依赖性，并将它们映射以确定有意义的结论/洞察。)</em></li></ol><p id="a356" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">今天，我们只关注集群。</p><h1 id="24d9" class="ju jv hi bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated"><strong class="ak"> <em class="ks">聚类:</em> </strong></h1><p id="3d25" class="pw-post-body-paragraph iv iw hi ix b iy kt ja jb jc ku je jf jg kv ji jj jk kw jm jn jo kx jq jr js hb bi translated">聚类用于对数据集中的模式进行分类，并将相似的模式分组。术语<em class="jt">‘集群’</em>描述相似模式的群组。这些模式被表示为一个度量向量或多维空间中的一个点。在找到模式之后，使用各种距离度量来找到这些模式之间的不同点和相似点。</p><p id="402c" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj"> <em class="jt">聚类的阶段:</em> </strong></p><ol class=""><li id="03b6" class="ky kz hi ix b iy iz jc jd jg la jk lb jo lc js ld le lf lg bi translated">代表一种模式。</li><li id="fa4b" class="ky kz hi ix b iy lh jc li jg lj jk lk jo ll js ld le lf lg bi translated">为数据集域适当地定义模式。</li><li id="c0c6" class="ky kz hi ix b iy lh jc li jg lj jk lk jo ll js ld le lf lg bi translated">相似模式的聚类或分组。</li><li id="cbf0" class="ky kz hi ix b iy lh jc li jg lj jk lk jo ll js ld le lf lg bi translated">数据抽象<em class="jt">(如果需要)</em>。</li><li id="ff7a" class="ky kz hi ix b iy lh jc li jg lj jk lk jo ll js ld le lf lg bi translated">评估输出<em class="jt">(如果需要)</em>。</li></ol><p id="c687" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">聚类有几种类型的技术可以使用。但是没有一种普遍适用的聚类技术。任何技术的评估也依赖于领域。建议用户在选择聚类算法时充分了解所使用的技术，并具备一些领域知识。</p><p id="3077" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj"> <em class="jt">聚类可以进一步分为:</em> </strong></p><p id="6fb9" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj"> A)层次聚类算法:</strong></p><p id="15fb" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在<em class="jt">分层方法</em>中，有一个嵌套的模式分组。如果考虑单一模式，然后最终分组形成聚类，则称为<em class="jt">凝聚/自下而上</em>方法。如果一个大数据集被分解成不同的聚类，那么它被称为<em class="jt">分裂/上下</em>方法。大多数分层方法是<em class="jt">单链接</em>和<em class="jt">完全链接</em>算法的变体。最近邻算法就是一个例子。</p><p id="21fe" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj"> B)分区方法:</strong></p><p id="605c" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在这种方法中，数据集被分解成一组不相交的聚类。首先，将数据集划分为k个聚类，并对它们进行迭代改进以获得高质量的聚类。用于提高质量的功能有<em class="jt">误差平方和(SSE)、质心、</em>等。分区算法比大型数据集更有优势。著名的K均值聚类就是这种方法的一个例子。</p><p id="7859" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj"> C)基于密度的方法:</strong></p><p id="8cf1" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">基于密度的聚类或<em class="jt"> DBSCAN(带噪声的基于密度的空间聚类应用)</em>方法首先选择“最密集”区域的聚类。在选择“最密集”区域时，需要考虑两个因素；一是密集区域的半径，二是这个区域的最小邻居数。如果任何一个点对于集群来说都是不可到达的，那么这个点就被称为<em class="jt">离群点。</em>该区域的中心点称为<em class="jt">核心</em>。边界处的点称为<em class="jt">边界</em>点。从“最密集”区域，我们将它与数据集中的其他点进行比较，并定义它是否属于该区域(<em class="jt">离群值</em>不属于该聚类)。<em class="jt">边界</em>点被认为是区域的一部分)。如果没有更多的数据点属于该区域，它最终被定义为相似模式的聚类。</p><p id="2cd3" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj"> D)基于网格的方法:</strong></p><p id="108c" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">基于网格的方法将对象空间分成多个单元以获得网格状结构，并且将聚类应用于该结构。STING就是这种方法的典型例子。</p><p id="4f6e" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><em class="jt">作者，</em><strong class="ix hj"><em class="jt">SMRUTHI R paladi</em></strong></p><p id="5495" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">参考资料:</p><ol class=""><li id="7dc0" class="ky kz hi ix b iy iz jc jd jg la jk lb jo lc js ld le lf lg bi translated"><a class="ae iu" href="https://machinelearningmastery.com/clustering-algorithms-with-python/" rel="noopener ugc nofollow" target="_blank">用Python实现的10种聚类算法</a></li></ol><p id="ea0a" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">2.<a class="ae iu" href="https://www.geeksforgeeks.org/clustering-in-machine-learning/" rel="noopener ugc nofollow" target="_blank">机器学习中的聚类</a></p><p id="74bc" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">3.<a class="ae iu" href="https://knowm.org/introduction-to-clustering/" rel="noopener ugc nofollow" target="_blank"> KNOWM </a></p></div></div>    
</body>
</html>