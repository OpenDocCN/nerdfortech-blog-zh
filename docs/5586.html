<html>
<head>
<title>SwiftUI: Scroll like in UIKit using only SwiftUI _hidden APIs</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">SwiftUI:仅使用 SwiftUI _ hidden APIs 在 UIKit 中滚动</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/swiftui-scroll-like-in-uikit-using-only-swiftui-hidden-apis-8af2be0534c7?source=collection_archive---------3-----------------------#2021-10-20">https://medium.com/nerd-for-tech/swiftui-scroll-like-in-uikit-using-only-swiftui-hidden-apis-8af2be0534c7?source=collection_archive---------3-----------------------#2021-10-20</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="de28" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">想象一下你可以配置 SwiftUI <code class="du jd je jf jg b">ScrollView</code></p><figure class="ji jj jk jl fd jm er es paragraph-image"><div role="button" tabindex="0" class="jn jo di jp bf jq"><div class="er es jh"><img src="../Images/9756dc845cfd2bd38e9c565a7d8ef9be.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Z_3kFNKSKijM3OKByg3RLQ.png"/></div></div><figcaption class="jt ju et er es jv jw bd b be z dx translated">对 UIScrollView 和界面构建器的怀旧(也可能不是)。</figcaption></figure><p id="1e32" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">想象一下，您可以不经过内省就进行分页。</p><p id="28df" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">想象一下你可以用</p><ul class=""><li id="e028" class="jx jy hi ih b ii ij im in iq jz iu ka iy kb jc kc kd ke kf bi translated">内容偏移量(以编程方式将动画滚动到定义的偏移量)</li><li id="7414" class="jx jy hi ih b ii kg im kh iq ki iu kj iy kk jc kc kd ke kf bi translated">内容插入</li><li id="3f81" class="jx jy hi ih b ii kg im kh iq ki iu kj iy kk jc kc kd ke kf bi translated">指示器插图</li><li id="cb6e" class="jx jy hi ih b ii kg im kh iq ki iu kj iy kk jc kc kd ke kf bi translated">减速率</li><li id="66d9" class="jx jy hi ih b ii kg im kh iq ki iu kj iy kk jc kc kd ke kf bi translated">弹跳选项</li><li id="dcfe" class="jx jy hi ih b ii kg im kh iq ki iu kj iy kk jc kc kd ke kf bi translated">启用或禁用滚动</li><li id="e78d" class="jx jy hi ih b ii kg im kh iq ki iu kj iy kk jc kc kd ke kf bi translated">交互阻力容限</li></ul><p id="a817" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">换句话说，UIKit 中<code class="du jd je jf jg b">UIScrollView</code>的大部分可配置属性，不过用的是纯 SwiftUI。</p><p id="cd53" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">SwiftUI 实际上允许配置所有这些选项，但是为了了解它，必须找出 SwiftUI 的<code class="du jd je jf jg b">.swiftinterface</code>中隐藏的公共 SwiftUI 类型。</p><p id="8fdf" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">之前我写过 SwiftUI 中隐藏类型的另一个发现——view test 协议<a class="ae kl" rel="noopener" href="/@eugenedudnyk/behavioural-testing-of-swiftui-views-with-host-app-and-viewtest-f1343a281c5f">_ T20】。</a></p><p id="333e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这次我准备了一个专门的库<a class="ae kl" href="https://github.com/edudnyk/SolidScroll" rel="noopener ugc nofollow" target="_blank"> SolidScroll </a>解放 SwiftUI 的<code class="du jd je jf jg b">_ScrollView</code>和<code class="du jd je jf jg b">_PagingView</code>。它只包含隐藏的 SwiftUI 类型的类型别名，为了方便起见，还包含一些初始化器和 DocC 文档。</p><p id="2e88" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">下面我们就来详细了解一下这个 SwiftUI 宝吧。</p><h1 id="e231" class="km kn hi bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">_ScrollView</h1><p id="efe7" class="pw-post-body-paragraph if ig hi ih b ii lk ik il im ll io ip iq lm is it iu ln iw ix iy lo ja jb jc hb bi translated">隐藏的<code class="du jd je jf jg b">_ScrollView</code>类型代表用<code class="du jd je jf jg b">_ScrollViewConfig</code>和<code class="du jd je jf jg b">_ScrollableContentProvider.</code>配置的滚动视图</p><pre class="ji jj jk jl fd lp jg lq lr aw ls bi"><span id="6a2b" class="lt kn hi jg b fi lu lv l lw lx">public init&lt;Provider&gt;(contentProvider: Provider, config: _ScrollViewConfig = _ScrollViewConfig()) where Provider : _ScrollableContentProvider</span></pre><p id="64c7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在<code class="du jd je jf jg b">SolidScroll</code>库中，使这些类型可见的相应类型别名是:</p><ul class=""><li id="f161" class="jx jy hi ih b ii ij im in iq jz iu ka iy kb jc kc kd ke kf bi translated"><code class="du jd je jf jg b">SolidScrollView</code>(别名为<code class="du jd je jf jg b">_ScrollView</code>)</li><li id="76e4" class="jx jy hi ih b ii kg im kh iq ki iu kj iy kk jc kc kd ke kf bi translated"><code class="du jd je jf jg b">ScrollViewConfig</code>(别名为<code class="du jd je jf jg b">_ScrollViewConfig</code>)</li><li id="e8c1" class="jx jy hi ih b ii kg im kh iq ki iu kj iy kk jc kc kd ke kf bi translated"><code class="du jd je jf jg b">AligningContentProvider</code>(别名为<code class="du jd je jf jg b">_AligningContentProvider</code>)</li><li id="b853" class="jx jy hi ih b ii kg im kh iq ki iu kj iy kk jc kc kd ke kf bi translated"><code class="du jd je jf jg b">ContainedScrollViewKey</code>(偏好键，别名为<code class="du jd je jf jg b">_ContainedScrollViewKey</code>)</li><li id="5c17" class="jx jy hi ih b ii kg im kh iq ki iu kj iy kk jc kc kd ke kf bi translated"><code class="du jd je jf jg b">SolidScrollViewProxy</code>(别名为<code class="du jd je jf jg b">_ScrollViewProxy</code>)</li></ul><p id="1ac2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">处理<code class="du jd je jf jg b">SolidScrollView</code>的方式非常类似于你可能已经熟悉的常规<code class="du jd je jf jg b">ScrollViewReader</code>(或者，如果你从未听说过它，我推荐<a class="ae kl" href="https://thinkdiff.net/swiftui-how-to-create-a-chat-screen-and-scroll-automatically-d82b4984d888" rel="noopener ugc nofollow" target="_blank">这个故事</a>用于阅读)，但是我们不是创建读者，而是倾听<code class="du jd je jf jg b">ContainedScrollViewKey</code>偏好的偏好变化。</p><figure class="ji jj jk jl fd jm"><div class="bz dy l di"><div class="ly lz l"/></div><figcaption class="jt ju et er es jv jw bd b be z dx translated">SolidScrollView 使用示例。</figcaption></figure><p id="7af5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">一旦我们获得了首选项的值，并且有了滚动视图代理，我们就可以对它调用<code class="du jd je jf jg b">setContentOfsset(_:animated:completion:)</code>,以便以编程方式(有或没有动画)滚动到可滚动内容中的具体位置。</p><p id="775d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">此外，现在我们可以访问底层滚动视图的属性和方法:</p><figure class="ji jj jk jl fd jm"><div class="bz dy l di"><div class="ly lz l"/></div><figcaption class="jt ju et er es jv jw bd b be z dx translated">SwiftUI 中隐藏的<code class="du jd je jf jg b">_ScrollViewProxy</code>类型的公共接口</figcaption></figure><h1 id="8f72" class="km kn hi bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">_ 分页视图</h1><p id="6015" class="pw-post-body-paragraph if ig hi ih b ii lk ik il im ll io ip iq lm is it iu ln iw ix iy lo ja jb jc hb bi translated">隐藏的<code class="du jd je jf jg b">_PagingView</code>类型代表带有预配置分页的滚动视图。通过<code class="du jd je jf jg b">_PagingViewConfig</code>提供寻呼配置。</p><p id="5ae9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在<code class="du jd je jf jg b">SolidScroll</code>库中，使这些类型可见的相应类型别名是:</p><ul class=""><li id="78ae" class="jx jy hi ih b ii ij im in iq jz iu ka iy kb jc kc kd ke kf bi translated"><code class="du jd je jf jg b">PagingView</code>(别名为<code class="du jd je jf jg b">_PagingView</code>)</li><li id="99ce" class="jx jy hi ih b ii kg im kh iq ki iu kj iy kk jc kc kd ke kf bi translated"><code class="du jd je jf jg b">PagingViewConfig</code>(别名为<code class="du jd je jf jg b">_PagingViewConfig</code>)</li></ul><p id="c218" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">处理<code class="du jd je jf jg b">PagingView</code>的方法非常简单——只需提供您的分页视图配置和视图集合，它们将成为<code class="du jd je jf jg b">PagingView</code>的页面。</p><figure class="ji jj jk jl fd jm"><div class="bz dy l di"><div class="ly lz l"/></div><figcaption class="jt ju et er es jv jw bd b be z dx translated">PagingView 使用示例。</figcaption></figure><p id="326a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我在这里看到的可能限制是<code class="du jd je jf jg b">PagingViewConfig</code>和<code class="du jd je jf jg b">ScrollViewConfig</code>都只允许相同大小的所有页面。如果你需要不同尺寸的页面，你必须有点创意。</p><p id="81d1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我为 SolidScroll 库录制了一个小演示视频，请查看:</p><figure class="ji jj jk jl fd jm"><div class="bz dy l di"><div class="ma lz l"/></div></figure><p id="b6da" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">感谢阅读！</p></div></div>    
</body>
</html>