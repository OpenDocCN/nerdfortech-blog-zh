<html>
<head>
<title>Deploying a Server-Side App to Azure</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">将服务器端应用部署到Azure</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/deploying-a-server-side-app-to-azure-dba0ae99532b?source=collection_archive---------26-----------------------#2021-05-29">https://medium.com/nerd-for-tech/deploying-a-server-side-app-to-azure-dba0ae99532b?source=collection_archive---------26-----------------------#2021-05-29</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/77f240a51c99412d00408b0bf82d6a5c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*X-BBIDyPEqUQ-YHe"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">照片由<a class="ae iu" href="https://unsplash.com/@floriankrumm?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">弗洛里安·克拉姆</a>在<a class="ae iu" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="3d9b" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">对于我上学期间的最后一个项目，我的任务是将其部署到云，特别是Azure。现在，虽然微软有使用他们服务的OK文档，但他们很难适应我选择的项目，这是一个利用Sequelize ORM的ExpressJS SSR应用程序。</p><p id="df86" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">所以我在这里写了一个关于如何部署这样一个应用程序的简短教程。</p></div><div class="ab cl jt ju gp jv" role="separator"><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy"/></div><div class="hb hc hd he hf"><p id="bc65" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">当你初始化一个sequelize应用程序时，你会得到一些文件夹、配置、模型和种子。我们要做的第一件事是修改我们的配置。默认情况下，我们的配置如下所示:</p><pre class="ka kb kc kd fd ke kf kg kh aw ki bi"><span id="6583" class="kj kk hi kf b fi kl km l kn ko">{<br/>  "development": {<br/>    "username": "root",<br/>    "password": null,<br/>    "database": "database_development",<br/>    "host": "127.0.0.1",<br/>    "dialect": "mysql"<br/>  },<br/>  "test": {<br/>    "username": "root",<br/>    "password": null,<br/>    "database": "database_test",<br/>    "host": "127.0.0.1",<br/>    "dialect": "mysql"<br/>  },<br/>  "production": {<br/>    "username": "root",<br/>    "password": null,<br/>    "database": "database_production",<br/>    "host": "127.0.0.1",<br/>    "dialect": "mysql"<br/>  }<br/>}</span></pre><p id="7560" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这被导入到在模型文件夹中创建的<code class="du kp kq kr kf b">index.js</code>文件中。要将Sequelize与Azure一起使用，这将不起作用。为什么？因为不像在你的开发环境中，你用dotenv(或者应该用dotenv)获取你的信息，你将调用Azure KeyVault来获取秘密形式的密码。</p><p id="3fa6" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">当您执行一个Sequelize操作时，所有的魔法实际上都发生在我前面提到的<code class="du kp kq kr kf b">index.js</code>文件中。第一个序列调用我们的<code class="du kp kq kr kf b">config.js</code>文件，以及它需要导入的其他东西。当Sequelize调用<code class="du kp kq kr kf b">config.js</code>文件时，应用程序需要从保险库中调出秘密，否则需要秘密的字段将被未定义地返回，Sequelize将无法工作。为此，需要一个异步await函数。也许有一个我没有想到的替代方案，但是我已经尝试了一些更简单的方法，它们都不起作用。</p><p id="ca97" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">让我们重新配置我们的配置文件。首先，如果你还没有安装<code class="du kp kq kr kf b">@azure/identity and @azure/keyvault-secrets</code>，你需要安装它。最后，我是这样写我的config.js的:</p><pre class="ka kb kc kd fd ke kf kg kh aw ki bi"><span id="2d48" class="kj kk hi kf b fi kl km l kn ko">const { DefaultAzureCredential } = require('@azure/identity');<br/>const { SecretClient } = require('@azure/keyvault-secrets');<br/><br/>const credential = new DefaultAzureCredential();<br/>const vault = 'vault';<br/><br/>const url = `https://${vault}.vault.azure.net`;<br/><br/>const client = new SecretClient(url, credential);<br/><br/>const vaultUtility = async () =&gt; {<br/>     try {<br/>          const database = await client.getSecret('db_title');<br/>          const username = await client.getSecret('db_user');<br/>          const password = await client.getSecret('db_pass');<br/><br/>          return {<br/>               development: {<br/>                    username: username.value,<br/>                    password: password.value,<br/>                    database: database.value,<br/>                    host: '{servername}.database.windows.net', // replace {servernmame} with name of db servername<br/>                    dialect: 'mssql',<br/>                    encrypt: 'true'<br/>               },<br/>               test: {<br/>                    username: username.value,<br/>                    password: password.value,<br/>                    database: database.value,<br/>                    host: '{servername}.database.windows.net',<br/>                    dialect: 'mssql',<br/>                    encrypt: 'true'<br/>               },<br/>               production: {<br/>                    username: username.value,<br/>                    password: password.value,<br/>                    database: database.value,<br/>                    host: '{servername}.database.windows.net',<br/>                    dialect: 'mssql',<br/>                    encrypt: 'true'<br/>               },<br/>          };<br/>     } catch (err) {<br/>          <strong class="kf hj"><em class="ks">console</em></strong>.log(err);<br/>     }<br/>};<br/><br/>module.exports = vaultUtility;</span></pre><p id="c5dc" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">最终结果是一样的，它按照Sequelize的预期返回config对象，但这一次只是在它检索到机密之后。然而，这并没有完全解决我们的问题！现在，我想我们可以自动调用我们的函数，并将数据存储在一个变量中，然后我们可以导入该变量，但这有一个小小的问题…它将您的秘密暴露在代码中的时间太长了，使整个密钥库变得毫无意义。因此，我们应该只在需要的时候调用和存储秘密，在不需要的时候丢弃它。</p><p id="e93d" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">经过几个小时的争论和研究，我想到了在一个匿名异步函数中存储除db变量之外的所有内容。</p><pre class="ka kb kc kd fd ke kf kg kh aw ki bi"><span id="8972" class="kj kk hi kf b fi kl km l kn ko">'use strict';</span><span id="d224" class="kj kk hi kf b fi kt km l kn ko">const <strong class="kf hj"><em class="ks">db </em></strong>= {};<br/><br/>(async () =&gt; {<br/>    const <strong class="kf hj"><em class="ks">fs </em></strong>= require('fs');<br/>    const <strong class="kf hj"><em class="ks">path </em></strong>= require('path');<br/>    const Sequelize = require('sequelize');<br/>    const basename = <strong class="kf hj"><em class="ks">path</em></strong>.basename(__filename);<br/>    const env = <strong class="kf hj"><em class="ks">process</em></strong>.env.NODE_ENV || 'production';<br/>    const vaultUtility = require('../config/config');<br/>    let config = await vaultUtility();<br/>    config = config[env];<br/><br/>    let sequelize;<br/>    if (config.use_env_variable) {<br/>        sequelize = new Sequelize(<strong class="kf hj"><em class="ks">process</em></strong>.env[config.use_env_variable], config);<br/>    } else {<br/>        sequelize = new Sequelize(<br/>            config.database,<br/>            config.username,<br/>            config.password,<br/>            config<br/>        );<br/>    }<br/><br/>    <strong class="kf hj"><em class="ks">fs</em></strong>.readdirSync(__dirname)<br/>        .filter(file =&gt; {<br/>            return (<br/>                file.indexOf('.') !== 0 &amp;&amp;<br/>                file !== basename &amp;&amp;<br/>                file.slice(-3) === '.js'<br/>            );<br/>        })<br/>        .forEach(file =&gt; {<br/>            const model = require(<strong class="kf hj"><em class="ks">path</em></strong>.join(__dirname, file))(<br/>                sequelize,<br/>                Sequelize.DataTypes<br/>            );<br/>            <strong class="kf hj"><em class="ks">db</em></strong>[model.name] = model;<br/>        });<br/><br/>    <strong class="kf hj"><em class="ks">Object</em></strong>.keys(<strong class="kf hj"><em class="ks">db</em></strong>).forEach(modelName =&gt; {<br/>        if (<strong class="kf hj"><em class="ks">db</em></strong>[modelName].<em class="ks">associate</em>) {<br/>            <strong class="kf hj"><em class="ks">db</em></strong>[modelName].<em class="ks">associate</em>(<strong class="kf hj"><em class="ks">db</em></strong>);<br/>        }<br/>    });<br/><br/>    <strong class="kf hj"><em class="ks">db</em></strong>.sequelize = sequelize;<br/>    <strong class="kf hj"><em class="ks">db</em></strong>.Sequelize = Sequelize;<br/>})()<br/><br/>module.exports = <strong class="kf hj"><em class="ks">db</em></strong>;</span></pre></div><div class="ab cl jt ju gp jv" role="separator"><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy"/></div><div class="hb hc hd he hf"><p id="8a09" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">现在你的应用程序应该可以和Azure一起工作了。如果您使用Azure和sequelize，请告诉我是否有更好/更简单的方法来做到这一点，而不暴露任何不应该暴露的内容。我要指出，这是利用为审判提供的资源完成的。</p></div></div>    
</body>
</html>