<html>
<head>
<title>Micro-pattern: IIFE and Return-Early</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">微模式:生命与回归-早</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/micro-pattern-iife-and-return-early-2a5ce088b855?source=collection_archive---------14-----------------------#2021-03-08">https://medium.com/nerd-for-tech/micro-pattern-iife-and-return-early-2a5ce088b855?source=collection_archive---------14-----------------------#2021-03-08</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="e8e8" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">这些是什么，我们如何利用它们？</h2></div><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ix"><img src="../Images/7ef54722a8dd5606659ae796b38fe267.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*BLJIRFqcNgRMGRue"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">由<a class="ae jn" href="https://unsplash.com/@omarg247?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">奥玛·弗洛里斯</a>在<a class="ae jn" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><h1 id="a861" class="jo jp hi bd jq jr js jt ju jv jw jx jy io jz ip ka ir kb is kc iu kd iv ke kf bi translated">立即调用函数表达式(IIFE)</h1><p id="cd54" class="pw-post-body-paragraph kg kh hi ki b kj kk ij kl km kn im ko kp kq kr ks kt ku kv kw kx ky kz la lb hb bi translated">如果您来自 JavaScript 背景，您很可能会遇到这种模式。还记得 JQuery 吗？</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="lc ld l"/></div></figure><p id="8fc4" class="pw-post-body-paragraph kg kh hi ki b kj le ij kl km lf im ko kp lg kr ks kt lh kv kw kx li kz la lb hb bi translated">我记得那时我习惯把它看作是我的 JQuery 代码的“包装器”,继续我的生活，而不试图找出它实际上在做什么。所以让我们一起来解构这段代码。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es lj"><img src="../Images/57b2ce3ed6ac7587a15cade2d36c476e.png" data-original-src="https://miro.medium.com/v2/resize:fit:870/format:webp/1*zP68tsR_tbuWW_RlJ-0gQg.png"/></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">生命是一个被声明然后立即执行的函数</figcaption></figure><p id="688c" class="pw-post-body-paragraph kg kh hi ki b kj le ij kl km lf im ko kp lg kr ks kt lh kv kw kx li kz la lb hb bi translated">顾名思义，这个包装器实际上只是一个立即执行的函数。您可以看到，该函数在第一个括号内匿名声明(没有名字)，然后立即以<code class="du lk ll lm ln b">jQuery</code>作为其参数执行(在函数体内转换为<code class="du lk ll lm ln b">$</code>)。顺便提一下，该函数也是一个闭包，这意味着它可以访问其父级(声明它的那个)的所有变量。</p><p id="bb25" class="pw-post-body-paragraph kg kh hi ki b kj le ij kl km lf im ko kp lg kr ks kt lh kv kw kx li kz la lb hb bi translated">实际上，这只是实现相同代码一堆捷径:</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="lc ld l"/></div></figure><p id="d37b" class="pw-post-body-paragraph kg kh hi ki b kj le ij kl km lf im ko kp lg kr ks kt lh kv kw kx li kz la lb hb bi translated">那么，我们为什么要使用它呢？</p><p id="7145" class="pw-post-body-paragraph kg kh hi ki b kj le ij kl km lf im ko kp lg kr ks kt lh kv kw kx li kz la lb hb bi translated">我自己也不太明白为什么我要使用这种模式而不是可读性更好的对应模式，但是后来我意识到我可以这样做:</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="lc ld l"/></div></figure><p id="3fe2" class="pw-post-body-paragraph kg kh hi ki b kj le ij kl km lf im ko kp lg kr ks kt lh kv kw kx li kz la lb hb bi translated">这种模式最常用的用例可能是在任何范围内快速创建一个异步任务:</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="lc ld l"/></div></figure><p id="ff8e" class="pw-post-body-paragraph kg kh hi ki b kj le ij kl km lf im ko kp lg kr ks kt lh kv kw kx li kz la lb hb bi translated">如您所见，这是一个非常有用的一次性逻辑块。我发现它在我需要做一些非常简短和具体的逻辑时非常有用。如果我为此编写一个实用函数，我发现它可能会让读者分心，因为它会迫使他们进行上下文切换(切换到一个远处的函数，甚至可能是另一个“utils”文件)。我还需要传入参数，并在上下文切换时添加更多要记住的内容。有了 IIFE，读者可以自然地从上到下阅读代码。</p><p id="61ea" class="pw-post-body-paragraph kg kh hi ki b kj le ij kl km lf im ko kp lg kr ks kt lh kv kw kx li kz la lb hb bi translated">哦，我必须指出，无论如何这不仅仅是 JavaScript 的事情。例如，你也可以在 Go 中生活(我想大多数语言都支持闭包？).事实上，它可以在许多地方被发现。例如，下面是来自<a class="ae jn" href="https://gobyexample.com/signals" rel="noopener ugc nofollow" target="_blank"> Signals </a>的示例，演示了它用于创建监听操作系统信号的背景程序:</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="lc ld l"/></div></figure><p id="0cce" class="pw-post-body-paragraph kg kh hi ki b kj le ij kl km lf im ko kp lg kr ks kt lh kv kw kx li kz la lb hb bi translated">看到了吗？对于一个简短、简洁、具体的逻辑还是挺有用的吧？后来，如果需要在其他地方使用它，我们总是可以取出它，将其重构为单独的函数(如果需要，将任何父变量作为参数传递)。</p><h1 id="f269" class="jo jp hi bd jq jr js jt ju jv jw jx jy io jz ip ka ir kb is kc iu kd iv ke kf bi translated">提前返回模式</h1><blockquote class="lo lp lq"><p id="5696" class="kg kh lr ki b kj le ij kl km lf im ko ls lg kr ks lt lh kv kw lu li kz la lb hb bi translated">一个<strong class="ki hj">故障快速</strong>系统是一个在其接口上立即报告任何可能指示故障的条件的系统。(<a class="ae jn" href="https://en.wikipedia.org/wiki/Fail-fast" rel="noopener ugc nofollow" target="_blank">维基百科</a>)</p></blockquote><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es lv"><img src="../Images/f30aa2b95ae5911789b070fcfa92d5a2.png" data-original-src="https://miro.medium.com/v2/resize:fit:424/format:webp/1*VlI8WqWDvf2GfZqPmM-i7w.png"/></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">有时候我们必须在付出代价之前放弃。</figcaption></figure><p id="1350" class="pw-post-body-paragraph kg kh hi ki b kj le ij kl km lf im ko kp lg kr ks kt lh kv kw kx li kz la lb hb bi translated">正如马丁·福勒在<a class="ae jn" href="https://martinfowler.com/ieeeSoftware/failFast.pdf" rel="noopener ugc nofollow" target="_blank"> Fail Fast </a>中提到的，这是系统设计环境中非常常见的模式，但我发现这也可以衍生为一个很好的微模式，在任何时候都可以使用。我对此的解释很简单:当事情可能出错时，立即返回/抛出，这样我们就可以一直沿着快乐的道路前进。</p><p id="c126" class="pw-post-body-paragraph kg kh hi ki b kj le ij kl km lf im ko kp lg kr ks kt lh kv kw kx li kz la lb hb bi translated">想象我们有这样的东西(夸张的例子):</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="lc ld l"/></div></figure><p id="aca0" class="pw-post-body-paragraph kg kh hi ki b kj le ij kl km lf im ko kp lg kr ks kt lh kv kw kx li kz la lb hb bi translated">如果我们在任何可能的错误上提前返回，不是更容易理解吗？作为奖励，我们还得到更少的嵌套，更容易看到边缘情况，<em class="lr">和</em>代码向一个方向流动，更容易审查。</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="lc ld l"/></div></figure></div><div class="ab cl lw lx gp ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="hb hc hd he hf"><h1 id="4a2e" class="jo jp hi bd jq jr md jt ju jv me jx jy io mf ip ka ir mg is kc iu mh iv ke kf bi translated">结论</h1><p id="9eca" class="pw-post-body-paragraph kg kh hi ki b kj kk ij kl km kn im ko kp kq kr ks kt ku kv kw kx ky kz la lb hb bi translated">就是这样，这两个是我发现经常使用的微模式，不仅是我，还有其他人。哦，这两个并不互相排斥，他们也可以一起使用。我个人认为这种模式有助于使我们的代码更容易推理，因此它有利于我们未来的自我，也有利于那些审查我们代码的人。</p><p id="4785" class="pw-post-body-paragraph kg kh hi ki b kj le ij kl km lf im ko kp lg kr ks kt lh kv kw kx li kz la lb hb bi translated">如果你有其他常用的微模式，请告诉我！</p></div></div>    
</body>
</html>