<html>
<head>
<title>LeetCode — Remove Duplicates from Sorted Array</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">LeetCode —从排序数组中删除重复项</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/leetcode-remove-duplicates-from-sorted-array-c399cc31fe9a?source=collection_archive---------8-----------------------#2021-05-30">https://medium.com/nerd-for-tech/leetcode-remove-duplicates-from-sorted-array-c399cc31fe9a?source=collection_archive---------8-----------------------#2021-05-30</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div class="er es if"><img src="../Images/be2c9205e50b64c95b84f58916b5cf31.png" data-original-src="https://miro.medium.com/v2/resize:fit:782/format:webp/0*fztYXADomYbEEumz.png"/></div></figure><h1 id="28ec" class="im in hi bd io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj bi translated">问题陈述</h1><p id="9b00" class="pw-post-body-paragraph jk jl hi jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh hb bi translated">给定一个排序后的数组<strong class="jm hj"> nums </strong>，就地删除重复的元素，这样每个元素只出现一次，并返回新的长度。</p><p id="324a" class="pw-post-body-paragraph jk jl hi jm b jn ki jp jq jr kj jt ju jv kk jx jy jz kl kb kc kd km kf kg kh hb bi translated">不要为另一个数组分配额外的空间，必须通过用<strong class="jm hj"> O(1) </strong>额外的内存就地修改输入数组来做到这一点。</p><p id="c102" class="pw-post-body-paragraph jk jl hi jm b jn ki jp jq jr kj jt ju jv kk jx jy jz kl kb kc kd km kf kg kh hb bi translated">问题陈述摘自:<a class="ae kn" href="https://leetcode.com/problems/remove-duplicates-from-sorted-array" rel="noopener ugc nofollow" target="_blank">https://leet code . com/problems/remove-duplicates-from-sorted-array</a></p><p id="8ff6" class="pw-post-body-paragraph jk jl hi jm b jn ki jp jq jr kj jt ju jv kk jx jy jz kl kb kc kd km kf kg kh hb bi translated"><strong class="jm hj">例1: </strong></p><pre class="ko kp kq kr fd ks kt ku kv aw kw bi"><span id="29af" class="kx in hi kt b fi ky kz l la lb">Input: nums = [1, 1, 2]<br/>Output: 2, nums = [1, 2]<br/>Explanation: Your function should return length = 2, with the first two elements of nums being 1 and 2 respectively. It doesn't matter what you leave beyond the returned length.</span></pre><p id="6a33" class="pw-post-body-paragraph jk jl hi jm b jn ki jp jq jr kj jt ju jv kk jx jy jz kl kb kc kd km kf kg kh hb bi translated"><strong class="jm hj">例2: </strong></p><pre class="ko kp kq kr fd ks kt ku kv aw kw bi"><span id="bf34" class="kx in hi kt b fi ky kz l la lb">Input: nums = [0, 0, 1, 1, 1, 2, 2, 3, 3, 4]<br/>Output: 5, nums = [0, 1, 2, 3, 4]<br/>Explanation: Your function should return length = 5, with the first five elements of nums being modified to 0, 1, 2, 3, and 4 respectively. It doesn't matter what values are set beyond the returned length.</span></pre><p id="d4e8" class="pw-post-body-paragraph jk jl hi jm b jn ki jp jq jr kj jt ju jv kk jx jy jz kl kb kc kd km kf kg kh hb bi translated"><strong class="jm hj">约束:</strong></p><pre class="ko kp kq kr fd ks kt ku kv aw kw bi"><span id="59e1" class="kx in hi kt b fi ky kz l la lb">- 0 &lt;= nums.length &lt;= 3 * 10^4<br/>- -10^4 &lt;= nums[i] &lt;= 10^4<br/>- nums is sorted in ascending order.</span></pre><h1 id="ea34" class="im in hi bd io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj bi translated">说明</h1><h2 id="ebbf" class="kx in hi bd io lc ld le is lf lg lh iw jv li lj ja jz lk ll je kd lm ln ji lo bi translated">强力</h2><p id="fabe" class="pw-post-body-paragraph jk jl hi jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh hb bi translated">嗯，问题说解决它不需要任何额外的空间，但我们得到的第一个强力方法是计数不同元素的出现次数，并将其存储在一个散列(或对象)中。</p><p id="d514" class="pw-post-body-paragraph jk jl hi jm b jn ki jp jq jr kj jt ju jv kk jx jy jz kl kb kc kd km kf kg kh hb bi translated">关键字是数组元素，值是元素在数组中出现的次数。</p><p id="ee95" class="pw-post-body-paragraph jk jl hi jm b jn ki jp jq jr kj jt ju jv kk jx jy jz kl kb kc kd km kf kg kh hb bi translated">然后，我们对散列进行迭代，并将键存储在一个新的数组中。</p><p id="593f" class="pw-post-body-paragraph jk jl hi jm b jn ki jp jq jr kj jt ju jv kk jx jy jz kl kb kc kd km kf kg kh hb bi translated">该解决方案需要额外的空间来存放新数组和新散列。</p><h2 id="6fb4" class="kx in hi bd io lc ld le is lf lg lh iw jv li lj ja jz lk ll je kd lm ln ji lo bi translated">两点</h2><p id="2e07" class="pw-post-body-paragraph jk jl hi jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh hb bi translated">为了改进上面的方法，我们可以利用这里的排序数组。我们可以使用两个指针<strong class="jm hj"> i </strong>和<strong class="jm hj"> j </strong>。我们一直递增<strong class="jm hj"> j </strong>，直到时间<strong class="jm hj"> nums[i] == nums[j] </strong>。</p><p id="8784" class="pw-post-body-paragraph jk jl hi jm b jn ki jp jq jr kj jt ju jv kk jx jy jz kl kb kc kd km kf kg kh hb bi translated">让我们检查下面的算法:</p><pre class="ko kp kq kr fd ks kt ku kv aw kw bi"><span id="08e4" class="kx in hi kt b fi ky kz l la lb">- return if nums size &lt;= 1<br/><br/>- set i = 0<br/><br/>- Loop for j = 1; j &lt; nums.size(); j++<br/>  - if nums[j] != nums[i]<br/>    - i++<br/>    - nums[i] = nums[j]<br/><br/>- return i + 1</span></pre><p id="5005" class="pw-post-body-paragraph jk jl hi jm b jn ki jp jq jr kj jt ju jv kk jx jy jz kl kb kc kd km kf kg kh hb bi translated">上述方法的时间复杂度为<strong class="jm hj"> O(N) </strong>，空间复杂度为<strong class="jm hj"> O(1) </strong>。</p><p id="31ee" class="pw-post-body-paragraph jk jl hi jm b jn ki jp jq jr kj jt ju jv kk jx jy jz kl kb kc kd km kf kg kh hb bi translated"><strong class="jm hj"> C++解决方案</strong></p><pre class="ko kp kq kr fd ks kt ku kv aw kw bi"><span id="cdf5" class="kx in hi kt b fi ky kz l la lb">class Solution {<br/>public:<br/>    int removeDuplicates(vector&lt;int&gt;&amp; nums) {<br/>        if(nums.size() &lt;= 1){<br/>            return nums.size();<br/>        }<br/><br/>        int i = 0;<br/><br/>        for(int j = 1; j &lt; nums.size(); j++){<br/>            if(nums[j] != nums[i){<br/>                i++<br/>                nums[i] = nums[j];<br/>            }<br/>        }<br/><br/>        return i + 1;<br/>    }<br/>};</span></pre><p id="eb30" class="pw-post-body-paragraph jk jl hi jm b jn ki jp jq jr kj jt ju jv kk jx jy jz kl kb kc kd km kf kg kh hb bi translated"><strong class="jm hj">戈朗解</strong></p><pre class="ko kp kq kr fd ks kt ku kv aw kw bi"><span id="6691" class="kx in hi kt b fi ky kz l la lb">func removeDuplicates(nums []int) int {<br/>    length := len(nums)<br/><br/>    if length &lt;= 1 {<br/>        return length<br/>    }<br/><br/>    i := 0<br/><br/>    for j := 1; j &lt; length; j++ {<br/>        if nums[i] != nums[j] {<br/>            i++<br/>            nums[i] = nums[j]<br/>        }<br/>    }<br/><br/>    return i + 1<br/>}</span></pre><p id="a4b5" class="pw-post-body-paragraph jk jl hi jm b jn ki jp jq jr kj jt ju jv kk jx jy jz kl kb kc kd km kf kg kh hb bi translated"><strong class="jm hj"> Javascript解决方案</strong></p><pre class="ko kp kq kr fd ks kt ku kv aw kw bi"><span id="d14c" class="kx in hi kt b fi ky kz l la lb">var removeDuplicates = function(nums) {<br/>    const length = nums.length;<br/><br/>    if( length &lt;= 1 ){<br/>        return length;<br/>    }<br/><br/>    let i = 0;<br/><br/>    for(let j = 1; j &lt; length; j++){<br/>        if( nums[i] != nums[j] ){<br/>            i++;<br/>            nums[i] = nums[j];<br/>        }<br/>    }<br/><br/>    return i + 1;<br/>};</span></pre><p id="fc6a" class="pw-post-body-paragraph jk jl hi jm b jn ki jp jq jr kj jt ju jv kk jx jy jz kl kb kc kd km kf kg kh hb bi translated">让我们试运行一下我们的算法，看看解决方案是如何工作的。</p><pre class="ko kp kq kr fd ks kt ku kv aw kw bi"><span id="c461" class="kx in hi kt b fi ky kz l la lb">nums = [0, 0, 1, 1, 1, 2, 2, 3, 3, 4]<br/><br/>Step 1: length = nums.size()<br/>               = 10<br/><br/>Step 2: length &lt;= 1<br/>            10 &lt;= 1<br/>            false<br/><br/>Step 3: i = 0<br/><br/>Step 4: Loop for j = 1; 1 &lt; 10<br/>        nums[i] != nums[j]<br/>        nums[0] != nums[1]<br/>        0 != 0<br/>        false<br/><br/>        j++<br/>        j = 2<br/><br/>Step 5: Loop for j = 2; 2 &lt; 10<br/>        nums[i] != nums[j]<br/>        nums[0] != nums[2]<br/>        0 != 1<br/>        true<br/><br/>        i++<br/>        i = 1<br/><br/>        nums[i] = nums[j]<br/>        nums[1] = nums[2]<br/>        nums[1] = 1<br/><br/>        j++<br/>        j = 3<br/><br/>Step 6: Loop for j = 3; 3 &lt; 10<br/>        nums[i] != nums[j]<br/>        nums[1] != nums[3]<br/>        1 != 1<br/>        false<br/><br/>        j++<br/>        j = 4<br/><br/>Step 7: Loop for j = 4; 4 &lt; 10<br/>        nums[i] != nums[j]<br/>        nums[1] != nums[4]<br/>        1 != 1<br/>        false<br/><br/>        j++<br/>        j = 5<br/><br/>Step 8: Loop for j = 5; 5 &lt; 10<br/>        nums[i] != nums[j]<br/>        nums[1] != nums[5]<br/>        1 != 2<br/>        true<br/><br/>        i++<br/>        i = 2<br/><br/>        nums[i] = nums[j]<br/>        nums[2] = nums[5]<br/>        nums[2] = 2<br/><br/>        j++<br/>        j = 6<br/><br/>Step 9: Loop for j = 6; 6 &lt; 10<br/>        nums[i] != nums[j]<br/>        nums[2] != nums[6]<br/>        2 != 2<br/>        false<br/><br/>        j++<br/>        j = 7<br/><br/>Step 10: Loop for j = 7; 7 &lt; 10<br/>         nums[i] != nums[j]<br/>         nums[2] != nums[7]<br/>         2 != 3<br/>         true<br/><br/>         i++<br/>         i = 3<br/><br/>         nums[i] = nums[j]<br/>         nums[3] = nums[7]<br/>         nums[3] = 3<br/><br/>         j++<br/>         j = 8<br/><br/>Step 11: Loop for j = 8; 8 &lt; 10<br/>         nums[i] != nums[j]<br/>         nums[3] != nums[8]<br/>         3 != 3<br/>         false<br/><br/>         j++<br/>         j = 9<br/><br/>Step 12: Loop for j = 9; 9 &lt; 10<br/>         nums[i] != nums[j]<br/>         nums[3] != nums[9]<br/>         3 != 4<br/>         true<br/><br/>         i++<br/>         i = 4<br/><br/>         nums[i] = nums[j]<br/>         nums[4] = nums[9]<br/>         nums[4] = 4<br/><br/>         j++<br/>         j = 10<br/><br/>Step 13: Loop for j = 10; 10 &lt; 10<br/>         false<br/><br/>Step 14: return i + 1<br/>         return 4 + 1 = 5</span></pre></div><div class="ab cl lp lq gp lr" role="separator"><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu"/></div><div class="hb hc hd he hf"><p id="85fa" class="pw-post-body-paragraph jk jl hi jm b jn ki jp jq jr kj jt ju jv kk jx jy jz kl kb kc kd km kf kg kh hb bi translated"><em class="lw">原载于</em><a class="ae kn" href="https://alkeshghorpade.me/post/leetcode-remove-duplicates-from-sorted-array" rel="noopener ugc nofollow" target="_blank"><em class="lw">https://alkeshghorpade . me</em></a><em class="lw">。</em></p></div></div>    
</body>
</html>