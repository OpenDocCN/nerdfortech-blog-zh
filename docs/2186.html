<html>
<head>
<title>React — Beyond the basics (excluding hooks): Context, Errors, Refs, HOCs, Render Props.</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">React 超越基础(不包括钩子):上下文、错误、引用、hoc、渲染道具。</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/react-beyond-the-basics-excluding-hooks-context-errors-refs-hocs-render-props-52df90d61229?source=collection_archive---------15-----------------------#2021-04-25">https://medium.com/nerd-for-tech/react-beyond-the-basics-excluding-hooks-context-errors-refs-hocs-render-props-52df90d61229?source=collection_archive---------15-----------------------#2021-04-25</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="740c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">本文假设您理解 React 的基础知识，并试图阐明更高级的概念。</p><p id="59b6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我将讨论上下文、错误、引用、高阶组件和渲染道具。</p><h1 id="6c5b" class="jd je hi bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">语境</h1><p id="7b85" class="pw-post-body-paragraph if ig hi ih b ii kb ik il im kc io ip iq kd is it iu ke iw ix iy kf ja jb jc hb bi translated">我们可以使用<code class="du kg kh ki kj b">props</code>在组件之间传递数据，但是有些东西将被许多组件使用，在这种情况下，我们可以使用上下文，而不是使用<code class="du kg kh ki kj b">props</code>将相同的东西从一个组件传递到下一个组件。</p><p id="8cb7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为了能够使用上下文，我们需要一个提供者和一个消费者。当我们有一个想要使用上下文的嵌套元素时，React 将沿着链向上直到找到它，并且它将使用那个值。</p><figure class="kl km kn ko fd kp er es paragraph-image"><div role="button" tabindex="0" class="kq kr di ks bf kt"><div class="er es kk"><img src="../Images/ed60bbec0f9ea2b8bfce5364ea9c6dce.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7BEn4fCOW_zmUFU5ofevEA.png"/></div></div></figure><p id="6233" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在这个索引文件中，我创建了一个 MyContext，并将其设置为文件中嵌套代码元素的提供者。当上下文被设置为嵌套元素的提供者时，我们指出它将具有什么值。</p><figure class="kl km kn ko fd kp er es paragraph-image"><div role="button" tabindex="0" class="kq kr di ks bf kt"><div class="er es kk"><img src="../Images/9e08e3c0bcd58d93a296f1987b6e0803.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*u7TEBiqfiLgeJc1_Mj0Dtg.png"/></div></div></figure><p id="b4da" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在本例中，Hello 组件将使用所提供的上下文，并且还将为其嵌套元素创建一个上下文。</p><figure class="kl km kn ko fd kp er es paragraph-image"><div role="button" tabindex="0" class="kq kr di ks bf kt"><div class="er es kw"><img src="../Images/27bdbac18810aaca558038ecb9f11bc6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UxE8e3F3UI19IC-LK0Fr-Q.png"/></div></div></figure><p id="ac2f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们还有组件 Hello2，它将使用两种上下文:</p><figure class="kl km kn ko fd kp er es paragraph-image"><div role="button" tabindex="0" class="kq kr di ks bf kt"><div class="er es kk"><img src="../Images/ded0879237565490ce79dbbec1ba9d90.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gF0t9vQG7W-lPSrwllSUhQ.png"/></div></div></figure><p id="c7d0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">上面的代码将在浏览器中显示:</p><figure class="kl km kn ko fd kp er es paragraph-image"><div role="button" tabindex="0" class="kq kr di ks bf kt"><div class="er es kx"><img src="../Images/405f58d40abc66ad09137bc39050eb23.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*b4gm5yhTYfEd2ZJdCjPuNQ.png"/></div></div></figure><h1 id="a133" class="jd je hi bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">误差边界</h1><p id="cd13" class="pw-post-body-paragraph if ig hi ih b ii kb ik il im kc io ip iq kd is it iu ke iw ix iy kf ja jb jc hb bi translated">错误边界是 React <strong class="ih hj">组件</strong>，它们捕捉它们的<strong class="ih hj">子</strong>组件树中任何地方的 JavaScript 错误，记录它们，并显示一个回退 UI 而不是崩溃的组件树，这可能会提供太多信息。它们不能捕捉所有类型的错误(服务器端、事件处理程序、异步代码)。</p><p id="bc90" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">通过创建具有方法<strong class="ih hj">getderivedstatefromrerror</strong>()和/或<strong class="ih hj"> componentDidCatch </strong>()的类来创建错误边界。</p><figure class="kl km kn ko fd kp er es paragraph-image"><div role="button" tabindex="0" class="kq kr di ks bf kt"><div class="er es ky"><img src="../Images/bd5ae2ccc3b5752a4e097590d9310dc9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bBNu7YeSFatIL2YpI2c80Q.png"/></div></div></figure><p id="1713" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果有错误，它将显示以下内容(如果没有错误，它将按预期显示组件)。</p><figure class="kl km kn ko fd kp er es paragraph-image"><div class="er es kz"><img src="../Images/3cc6f6fa3d8be7d36c3d3b4ee56729b5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1174/format:webp/1*dQn1Y7t5rmrPYvCzbewGrw.png"/></div></figure><p id="f29d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在上面的屏幕截图中，OH NO OH NO 来自索引中使用的 Hello 中的错误，该错误具有 errob 组件:</p><pre class="kl km kn ko fd la kj lb lc aw ld bi"><span id="3b40" class="le je hi kj b fi lf lg l lh li">import React , {Component} from 'react';<br/>import {MyContext} from './index';<br/>class <strong class="kj hj">Hello </strong>extends Component{<br/>     constructor(props){<br/>          super(props);<br/>          <strong class="kj hj">throw new Error("OH NO, OH NO");</strong><br/>}<br/>render(){<br/>     return(<br/>          &lt;React.Fragment&gt;<br/>               &lt;h1 style={{color:"navy"}}&gt;I am Hello! &lt;/h1&gt;<br/>          &lt;/React.Fragment&gt;<br/>            )<br/>      }<br/>}<br/>export default Hello<br/>#########################</span><span id="9699" class="le je hi kj b fi lj lg l lh li">class App extends Component {<br/>     constructor() {<br/>          super();<br/>          this.state = {<br/>               name: 'React'<br/>           };<br/>      }<br/>render() {<br/>     return (<br/>          &lt;div&gt;<br/>               <strong class="kj hj">&lt;ErrorB&gt;</strong><br/>                    &lt;h1 style={{color:"red"}}&gt;I AM INDEX &lt;/h1&gt;<br/>                    &lt;Hello /&gt;<br/>               <strong class="kj hj"> &lt;/ErrorB&gt;</strong><br/>          &lt;/div&gt;<br/>    );<br/>   }<br/>}</span></pre><h1 id="e442" class="jd je hi bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">REFS</h1><p id="991b" class="pw-post-body-paragraph if ig hi ih b ii kb ik il im kc io ip iq kd is it iu ke iw ix iy kf ja jb jc hb bi translated">通过引用，你可以直接访问组件的<strong class="ih hj">元素。</strong></p><figure class="kl km kn ko fd kp er es paragraph-image"><div class="er es lk"><img src="../Images/b96ae8f91410d2552a3220550223d984.png" data-original-src="https://miro.medium.com/v2/resize:fit:1328/format:webp/1*XT2QOKcviI3rw12Mc4MRTw.png"/></div></figure><p id="2c0b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">你可以用回调引用完成同样的事情。注意与前一种方式的区别(下面注释掉了)。</p><figure class="kl km kn ko fd kp er es paragraph-image"><div class="er es ll"><img src="../Images/94f2751d031178f4f3444ce8fc4800d8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1022/format:webp/1*CiA09JJsRHmxNCXPBbepdA.png"/></div></figure><p id="1c18" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">注意:React 也有一个<strong class="ih hj"> this.refs </strong>可以使用，但它已经过时，不推荐使用，所以我不在这里包含它。如果你看到它，它会看起来像<code class="du kg kh ki kj b">this.refs.reference1</code></p><p id="de84" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">React 还允许您将引用从一个组件传递到其子组件。只有当接收引用的组件是用 React.forwardRef 创建的时候，这种方法才有效。</p><figure class="kl km kn ko fd kp er es paragraph-image"><div role="button" tabindex="0" class="kq kr di ks bf kt"><div class="er es lm"><img src="../Images/0f207bf9ff7aae61c6d12b684911dc62.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5bkcmmNcT0ecZOZVVtrMrg.png"/></div></div></figure><h1 id="21f8" class="jd je hi bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">高阶组件—特设</h1><p id="5d2a" class="pw-post-body-paragraph if ig hi ih b ii kb ik il im kc io ip iq kd is it iu ke iw ix iy kf ja jb jc hb bi translated">高阶分量是接受一个分量并返回一个新分量的函数。这类似于组件的继承，尽管它本身不是继承。</p><p id="1c4f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">新组件将没有来自原始组件的任何静态方法。道具将被传递给新组件，但引用不会。这个用一个例子比较好解释。</p><figure class="kl km kn ko fd kp er es paragraph-image"><div class="er es ln"><img src="../Images/02a3147d45d6160b89f68f3e716b4766.png" data-original-src="https://miro.medium.com/v2/resize:fit:1002/format:webp/1*m5PG4WXDFSmVCu6YHrMFrg.png"/></div></figure><figure class="kl km kn ko fd kp er es paragraph-image"><div role="button" tabindex="0" class="kq kr di ks bf kt"><div class="er es lo"><img src="../Images/7d0c452a1e504a5faad031dce2c2902f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WrgefGf_k65b2q1nqnjQFg.png"/></div></div></figure><figure class="kl km kn ko fd kp er es paragraph-image"><div role="button" tabindex="0" class="kq kr di ks bf kt"><div class="er es lp"><img src="../Images/7e375080732fa9fd6e4ebf9614e1545b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xsEqf0EZQK_N7ecqUDCMOA.png"/></div></div></figure><h1 id="840f" class="jd je hi bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">渲染道具</h1><p id="a9f7" class="pw-post-body-paragraph if ig hi ih b ii kb ik il im kc io ip iq kd is it iu ke iw ix iy kf ja jb jc hb bi translated">这是一种用于在 React 组件之间共享代码的技术。这是通过使用带有函数值的 prop 来完成的。传递了渲染属性的组件将接受一个函数，该函数将返回一个 React 元素。它将调用这个函数，而不是实现自己的逻辑。</p><figure class="kl km kn ko fd kp er es paragraph-image"><div role="button" tabindex="0" class="kq kr di ks bf kt"><div class="er es lq"><img src="../Images/302ca42c07e6a80649e23fd1e96ea45f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RleNPm33lmP7N77Ms0CAkg.png"/></div></div></figure><p id="aa37" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">太多了！或者至少对我来说是很多。希望这能澄清一些事情(它帮助我理解了这些概念)。</p><p id="0e7a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">感谢您的阅读，并随时评论。</p></div></div>    
</body>
</html>