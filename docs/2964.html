<html>
<head>
<title>Key-Value Observing in the age of Swift</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Swift 时代的键值观察</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/key-value-observing-in-the-age-of-swift-f509c54fa5e8?source=collection_archive---------8-----------------------#2021-05-25">https://medium.com/nerd-for-tech/key-value-observing-in-the-age-of-swift-f509c54fa5e8?source=collection_archive---------8-----------------------#2021-05-25</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="745b" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">抛弃陈旧的语法，用快捷的方式编写键值观察</h2></div><figure class="ix iy iz ja fd jb er es paragraph-image"><div class="ab fe cl jc"><img src="../Images/64c43b290cf47c5c8e0b06a65b1913bf.png" data-original-src="https://miro.medium.com/v2/format:webp/1*Y_tZ2IznQi4J5pvbzV4KNw.jpeg"/></div><figcaption class="jf jg et er es jh ji bd b be z dx translated">@titopixel 的双筒望远镜插图</figcaption></figure><p id="c12f" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated"><strong class="jl hj">键值观察</strong>模式，俗称<strong class="jl hj"> KVO </strong>模式，从 Cocoa 成立之初就已经存在。它用于通知对象有关其他对象属性的更改。</p><p id="e41f" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">当涉及到在你的应用程序的逻辑分离的部分之间交流变化时，我们有几个选择。最广泛使用的一种是<code class="du kf kg kh ki b">Delegation</code>模式，如下例所示:</p><figure class="ix iy iz ja fd jb"><div class="bz dy l di"><div class="kj kk l"/></div></figure><h2 id="18f0" class="kl km hi bd kn ko kp kq kr ks kt ku kv js kw kx ky jw kz la lb ka lc ld le lf bi translated">授权的优势</h2><ol class=""><li id="c789" class="lg lh hi jl b jm li jp lj js lk jw ll ka lm ke ln lo lp lq bi translated"><strong class="jl hj">自证</strong>。看着代码，你就会确切地知道你应该如何使用它，它做什么。</li><li id="1a21" class="lg lh hi jl b jm lr jp ls js lt jw lu ka lv ke ln lo lp lq bi translated"><strong class="jl hj">可重复使用</strong>。只要你想要一对一的关系。</li></ol><h2 id="f0e3" class="kl km hi bd kn ko kp kq kr ks kt ku kv js kw kx ky jw kz la lb ka lc ld le lf bi translated">授权的限制</h2><p id="2866" class="pw-post-body-paragraph jj jk hi jl b jm li ij jo jp lj im jr js lw ju jv jw lx jy jz ka ly kc kd ke hb bi translated">当您能够访问代码的实际实现时，委托是最有用的。在上面的例子中，我们在子类中一个非常特殊的操作点上使用了<code class="du kf kg kh ki b">delegate?.doSomething()</code>,因为我们可以访问 Child 的实现，这样我们就可以把委托调用放在我们想要的地方。</p><p id="e71a" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">然而，有些情况下授权是无法实现的。</p><p id="8301" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">例如，如果你正在使用系统提供的类，比如<code class="du kf kg kh ki b">AVFoundation</code>中常见的<code class="du kf kg kh ki b">AVPlayer</code>，我相信每个玩家都使用的特性是观察玩家的状态(播放，暂停，等等。).要做到这一点，由于我们不能修改<code class="du kf kg kh ki b">AVPlayerItem</code>的源代码，我们只能要求在<code class="du kf kg kh ki b"><a class="ae lz" href="https://developer.apple.com/documentation/avfoundation/media_playback_and_selection/observing_playback_state" rel="noopener ugc nofollow" target="_blank">addObserver(_:forKeyPath:options:context:)</a></code>之前得到通知。<em class="ma">甚至苹果官方文档代码样本也是用旧语法编写的</em></p><figure class="ix iy iz ja fd jb"><div class="bz dy l di"><div class="kj kk l"/></div></figure><p id="dcc8" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">即使是在 Swift 中的语法，我们也从老的 Objective-C 时代继承了 KVO API 的设计。即使我们写得越来越快，它也非常强大，是每个开发人员必须知道的。</p><h2 id="3446" class="kl km hi bd kn ko kp kq kr ks kt ku kv js kw kx ky jw kz la lb ka lc ld le lf bi translated">旧的键值观察</h2><p id="ef64" class="pw-post-body-paragraph jj jk hi jl b jm li ij jo jp lj im jr js lw ju jv jw lx jy jz ka ly kc kd ke hb bi translated">在上面的代码示例中，有两个难点，每个都用注释标记:</p><ol class=""><li id="00b8" class="lg lh hi jl b jm jn jp jq js mb jw mc ka md ke ln lo lp lq bi translated">观察被设置为一个单独的步骤。如果您要设置多个观察，每个观察将占用一个<code class="du kf kg kh ki b">addObserver</code>来设置。</li><li id="1ea6" class="lg lh hi jl b jm lr jp ls js lt jw lu ka lv ke ln lo lp lq bi translated">通知在一个地方处理。假设您设置了多个观察，在这里您必须用<code class="du kf kg kh ki b">if keyPath == #keyPath(Your.KeyPath)</code>检查每个通知。并且用于从通知中提取有用信息的语法写起来很乏味并且难以阅读。</li><li id="c152" class="lg lh hi jl b jm lr jp ls js lt jw lu ka lv ke ln lo lp lq bi translated">为了避免崩溃，必须明确删除您设置的任何观察值。</li></ol><h2 id="f3d2" class="kl km hi bd kn ko kp kq kr ks kt ku kv js kw kx ky jw kz la lb ka lc ld le lf bi translated">新的键值观察</h2><p id="8ecc" class="pw-post-body-paragraph jj jk hi jl b jm li ij jo jp lj im jr js lw ju jv jw lx jy jz ka ly kc kd ke hb bi translated">在 Swift 中，我们可以向旧的机制注入新的血液。</p><figure class="ix iy iz ja fd jb"><div class="bz dy l di"><div class="kj kk l"/></div></figure><p id="2d9a" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated"><em class="ma">这个“\ .”syntax 是提取 keyPath 的快速语法。约翰·桑德尔有一篇关于此</em>  <em class="ma">的</em> <a class="ae lz" href="https://www.swiftbysundell.com/articles/the-power-of-key-paths-in-swift/" rel="noopener ugc nofollow" target="_blank"> <em class="ma">优秀文章。通读文章的前半部分应该会给你足够的介绍。</em></a></p><p id="74f8" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">同样是我们添加观察者的地方，这次语法变成了<code class="du kf kg kh ki b">.observe(_keyPath:options:changeHandler:)</code>。参数<code class="du kf kg kh ki b">options</code>指定当调用<code class="du kf kg kh ki b">changeHandler</code>时，您是想要旧值、新值，还是两者都要。就像旧语法一样。</p><p id="7891" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">在回调中，您将获得两个参数供您使用:</p><ol class=""><li id="b8b6" class="lg lh hi jl b jm jn jp jq js mb jw mc ka md ke ln lo lp lq bi translated">被观察的物体。</li><li id="3be7" class="lg lh hi jl b jm lr jp ls js lt jw lu ka lv ke ln lo lp lq bi translated"><code class="du kf kg kh ki b">change</code>。将会有一个<code class="du kf kg kh ki b">change.oldValue</code>和<code class="du kf kg kh ki b">change.newValue</code>取决于你指定的选项。</li></ol><p id="6a20" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">需要记住的重要一点是:</p><blockquote class="me mf mg"><p id="83b4" class="jj jk ma jl b jm jn ij jo jp jq im jr mh jt ju jv mi jx jy jz mj kb kc kd ke hb bi translated"><em class="hi">您必须保存观察结果，因为它将从内存中释放，如果不再被引用，观察者将自动从对象中移除</em>。</p></blockquote><p id="8c89" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">因此，你可以看到我一直保存着调用<code class="du kf kg kh ki b">.observe()</code>的结果，直到视图控制器的生命周期结束。并且您不再需要显式调用 deInit 中的<code class="du kf kg kh ki b">removeObserve</code>。</p></div></div>    
</body>
</html>