# Kotlin 中的 React Redux 实现真正的原生移动开发

> 原文：<https://medium.com/nerd-for-tech/react-redux-in-kotlin-for-truly-native-mobile-development-25229937d4f?source=collection_archive---------10----------------------->

## 移动应用中的反应式编程——一次旅行

## 当前的原生移动开发已经过时，几乎被 JavaScript 框架淹没。让我们改变这种状况，从向他们学习开始

## 介绍

在第一部分的[中，我们谈到了*为什么*当前的本地移动开发方法已经过时。
这开始了我们探索本地应用的反应式架构的旅程，在*Kotlin*(](/@gguymi/3675ce94ccf5)[multi platform？](https://kotlinlang.org/docs/multiplatform.html))。

在本部分中，我们将讨论*什么是建议的方法——在 *Kotlin* 中 *React* 和 *Redux* 。
下一部分将是关于*如何*实现和使用它。*

来了*什么*和*怎么*那么！

![](img/f40ea112d4a66b52211696af3cd5f330.png)

当事情变得不容易时，停下来，放松，找一个不同的视角，一个更高的角度。

# (建议的方法)是什么？

要了解一个好的应用架构是什么样子，我建议学习 [*React*](https://reactjs.org/tutorial/tutorial.html#overview) 和[*Redux*](https://redux.js.org/introduction/core-concepts)*—*的原理，并应用它们的方法来满足我们的本地开发需求。

> 如果你已经熟悉了 *React-Redux* ，你可以直接跳到下一篇文章——这篇文章解释了*如何从头开始构建*[*React droid*](https://github.com/GuyMichael/Reactdroid)*。*

*如果你想从我这里学习，请继续阅读。*

> **编辑:在完成这个系列的时候，Android 终于发布了一个稳定版的*[*JetpackCompose*](https://developer.android.com/jetpack/compose)*，基本上模仿了 React 的功能组件。与* [*协同例程*](https://kotlinlang.org/docs/coroutines-overview.html) *和*[*Kotlin-Redux*](https://reduxkotlin.org/)*一起，它是一个强大的“包”，通过一些努力，它可以一起用于解决我在这里介绍的许多概念。
> 虽然所有这些都是真实的(并且您应该熟悉上面的技术)，我们将在这个系列中学习的概念是* *现在* *甚至***——随着编写移动应用程序的“标准”方式越来越接近提到的概念。***

## **React 和 Redux 方法**

**从高层次来说， *React* 是一个简单的 UI 架构——*基于组件的*；而 *Redux* 是一个应用状态架构，它管理单个**全局**应用状态**

***总之， *React-Redux* 为管理应用程序的 UI 和*数据* + *状态*提供了一个极好的结构。而当在 *Kotin、*中实现时，它的一无所有缺开发福佑。***

## ***简单地回答***

***由于是基于 [*组件的*](https://en.wikipedia.org/wiki/Component-based_software_engineering) 架构， *React* 主要是围绕单个*类*—*组件*及其 2 个成员——一个*状态*和一个*道具*(如果你已经熟悉*React*——我正在设置【T77***

****反应* *部件*在 *Kotlin* 中基本上会是这样的:***

***Kotlin 中 React 组件的简化声明***

## ***该组件***

****组件*是一个*类*/模型，它单独负责更新/管理/ *渲染*UI 的某个部分。它没有别的目的。像一个*安卓* *视图*但是要多得多。***

***由于*组件*是唯一管理 UI 的模型，它同时充当最底层的 UI 元素——例如一个*文本*或一个*按钮*；最上面的是一整个屏幕。像 *LinearLayouts* 和 *Android* 中的简单*视图*，只不过在这里，一切都只是一个*组件*。***

## ***组件的呈现()***

****组件*只有**一个**地方可以/应该更新 UI——方法`render()`。***

***其背后的想法既天才又荒谬:不是让单独的 UI 更新调用“躲避”在代码周围——你永远无法保证没有冲突/错误/漏洞，更不用说*轻松测试*所有可能性——而是有一个单一的地方一次性更新所有内容— `render()`。***

***你答对了——这意味着每当一个*组件* *呈现*它的 UI 部分时，它会一次更新所有的 UI 部分😱。暂时忘掉效率吧，我们稍后会谈到它——会好起来的——这就是*反应*的天才之处(的一部分)。***

***每次调用`render()` 方法时，*组件*使用其*状态+属性*模型/ *对象*来相应地更新 UI——因此，*状态+道具的特定设置，*将总是转换为屏幕上完全相同的 UI—*确定性—* 这是*函数式编程*的一个重要方面。***

***在*科特林*中，它看起来像这样:***

***Kotlin 中 React 组件的基本原理。简化了的***

## ***(自己的)国家***

****组件* *类*的第一个*成员*是(自己)*状态。* 它只是一个*类* / *对象*/模型，表示——嗯——组件*的* t 的内部状态*；*是一个(' child') *文本* / *按钮组件*的当前文本(`String`，或者是一个复杂的`Object` ，代表**屏幕上某一时刻的一切**。***

***围绕它的逻辑也很简单:每当*状态*改变时，保存它的*组件*必须更新 UI(重新*呈现*)。***

***是的，你也说对了——每次时间**任何东西**在*状态*发生变化，**整个** *组件*都要重新*——渲染*。这意味着，如果那个*组件*是整个屏幕——每当**任何东西**在屏幕的*状态*发生变化的时候**，整个**屏幕都必须重新*渲染*😱😱😱。*******

***少了什么？一种从外部与那个*组件*进行通信的方式——那个特定的*组件的 API。*这(也)是一个*Android/iOS*View 的一大缺失，顺便说一下。***

***进入时，*道具*。***

## ***道具***

***Props 只是 properties 的简称。
*Props* 是一个*组件的**API，简单地用某个*组件特有的模型来表示。*它就像*状态*，真的，除了它被外部('父')*组件*使用，与那个('子')*组件通信。* 我再重复一遍，更简单:****

***一个【拥有】*状态*是一个*私有* *对象，一个*组件*使用*知道什么+什么时候给*渲染*。***

**一个*道具*是一个*公共* *对象，*被‘外人’用来告诉一个*组件*什么+什么时候*渲染——*一个 *API* ，由一个*对象*表示，而不是很多方法。**

**而你第三次得到了这个权利:
一个*组件*响*——每当*状态*、**或** *道具*改变时，渲染*。每次都是。**

**让我们把例子变得复杂一点。这一次，让我们看看使用/ *扩展* 2 *组件*会是什么样子，其中一个是 *TextComponent* 的“父”组件，从而控制它:**

**一个包含两个组件的层次结构——一个“父”通过它的属性控制一些(“子”)文本。**

## **反应摘要**

**因此，现在我们有了完整的画面: *React* 中的
，整个 UI 是由多个*组件*以单向层次结构构建的，其中最顶层的*组件*，例如一个完整的*屏幕*，包含了它的整个*状态*，并将派生的*道具*传递给它的“孩子”(更小的 UI 元素)，以控制它们*呈现的内容*。
那些‘孩子’可以更新他们的‘父母’的一些变化(通过*回调*)，在这种情况下‘父母’可以更新其 *ownState* ，导致整个层级(从该父及以下)重新*呈现*。**

**稍后，我会告诉你为什么`ownState`应该很少被使用( *Redux* 用于营救)，所以，我们基本上只需要记住两个模型——*组件*和*道具*😉这有多简单？！**

> **一个组件可以被看作一个(无状态的)数学函数，有一个输入(Props)和一个输出(UI)，没有副作用。UI 架构中的函数式编程**

## **Redux 方法**

***React* 是一个 UI 架构，定义了 UI 组件如何相互通信， *Redux* 是一个*全局状态，* [*Flux*](/swlh/understanding-flux-architecture-9060e5a0399c) 架构，管理整个 app 的整个*状态*。从根本上说，它与 UI 没有任何关系——除非我们创建了绑定。**

***React-Redux* 背后的想法是，取代(必然性)让 UI 组件“包含”它们之间的应用程序的*状态*，我们通过一个独立于 UI 的模型( *GlobalState Object* )来分离关注点。例如，这意味着当您使用一些 *API* 从*获取*一些*数据*时，这些数据会被保存到*全局状态*，而不是保存到*组件的内部(自己)*状态*。***

***全局状态对象*由*存储*持有。没什么特别的:**

**简化的 Redux 存储，保存 GlobalState 对象。在科特林**

## **全球国家**

**所以*全局状态*只是一个(巨大的)*对象*。你可以把它想象成一个`HashMap<String, Object/Any?>`，*把状态*‘keys’(`String`)映射到(任何类型，*可空的*)值。**

***全局状态*的流程非常简单，它只是利用了围绕*道具的*反应*逻辑—* 每当*全局状态*改变时，所有监听(*连接* ) *组件*得到通知，计算/派生/ *从新的*全局状态*减少*它们的*道具*，如果它们的新*道具***

**是的，你说得没错——每次发生**任何事情**发生变化，应用程序中的**任何地方**(*全局状态*)——**所有**相关的*组件*，可能是所有组件——re*——render*😱🤯😱🤯😱🤯。是啊…别担心。**

**简化的全球状态模型，在科特林。只是一张带有字符串键的地图。**

**有了 *Redux* ，*组件*的 *Props* 通常是直接从*global state*——它保存着 app 的*数据/缓存*——而不是从它们的父 *ownState* 中派生出来的。**省略了使用 *ownState 的需要。*****

**下面是上面的**父节点和文本子节点**的例子如何使用 *Redux 存储*，而不是父节点的 *ownState* 来控制文本:**

**由两个组件组成的层次结构——一个“父级”和一些(“子级”)文本——派生自全局状态。**

**现在我们有了。 *React Redux* 在行动。最少的 UI 代码，没有逻辑代码。关注点分离。**

## **冗余摘要**

**我们将在下一篇文章中更深入地研究*Redux*——因为尽管它非常简单，而且只是*反应式编程*的术语，但在开始时它可能会让人不知所措。总体思路如上所述——一个*全局状态*，其中*组件*可以更新(例如，由于一些*按钮点击*或*文本输入*)——这又通知回所有(监听*/连接的】* *组件*，导致它们中的一些/全部/没有一个重新*——渲染***

## **React-Redux，组合**

***Redux* 方法，与 *React* 方法一起，形成了一个 *MVI* 式的架构，它能够完成伟大的事情。**

**想想其中的含义:**

*   **不是一次又一次地在屏幕(*活动、片段、视图*)之间传递和*序列化*数据，它只是存在于全局范围内(并通过*道具*，在*组件的渲染*内自动提供给你)。**
*   **这也意味着你不再关心*在屏幕旋转之间保持*一个*活动*的状态——反正状态已经在全局范围内保存了。**
*   **这意味着你不需要复杂的缓存机制(数据库)*数据*—*数据*(一旦加载)只是出现在全局状态中。**
*   **这意味着你可以在应用关闭时保存全局状态，甚至在登录时从服务器发送序列化的状态，整个应用立即处于你想要的状态，包括哪个屏幕打开，什么文本放在哪里，甚至列表的滚动位置。**
*   **您可以很容易地测试任何可能的 UI 状态，而不需要手动/编程地做任何动作来“到达那里”——您只需要注入一个特定的状态来表示您想要看到的 UI。它是*确定性的*——相同的状态将总是呈现相同的 UI。**
*   **不再有“此文本在哪里更新？”，或者“如果在此之前点击会发生什么？”问题类型——所有 UI 都放在一个方法中，每次都以完全相同的方式、完全相同的顺序执行。**
*   **由于应用程序的状态是全局的，多个 UI 元素可以并且应该在同一状态下同步。所以不需要在同一个屏幕的两个元素之间直接通信，也不需要在不同屏幕的两个元素之间(！).例如，您可以在应用程序的*设置页面*中更改应用程序的调色板——使用全局状态——整个应用程序中的所有 UI 元素(例如 back-stack *Activities* )会立即更新以反映这一点。无需自定义代码。**

**我的意思是，既然你知道所有这些(以及更多)都是可能的，你还能回到你的 Android 项目吗？我知道我不能。**

> **我向你保证，这一切只是冰山一角。这只是你通过使用*反应-还原*方法获得的直接利益的一部分。等着看 [*Reactdroid*](https://github.com/GuyMichael/Reactdroid) 和[*react droid app*](https://github.com/GuyMichael/ReactdroidApp)库能做什么吧。**

# **摘要**

**这篇文章是关于 *React-Redux* ，一个基于*组件*、 *MVI* *Flux* 的应用程序开发方法——还有一个提示——它可以在 *Kotlin* 中完成，对于真正的原生移动开发，甚至可以在 [*多平台*](https://blog.jetbrains.com/kotlin/2020/08/kotlin-multiplatform-mobile-goes-alpha/#:~:text=Kotlin%20Multiplatform%20Mobile%20(KMM)%20is,both%20iOS%20and%20Android%20applications.&text=It%20includes%20the%20new%20KMM,code%20in%20the%20same%20IDE.) 中完成。我希望你学到了一些东西。我希望它让你看到了可能性。
请在下面留下您的评论和/或问题。**

**所以…这就是*什么*。在[下一篇](https://link.medium.com/llMGhOzt0eb)中，最后我们会谈到*如何—* 如何能在*科特林*中实现，从基础开始；以及如何使用它(例如在 *Android* 中)会是什么样子。[这里是](https://link.medium.com/llMGhOzt0eb)。**