<html>
<head>
<title>Standardize Data Format for Kafka Event streams using Apache Avro and Schema Evolution</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用 Apache Avro 和 Schema Evolution 标准化 Kafka 事件流的数据格式</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/standardize-data-format-for-kafka-event-streams-using-apache-avro-and-schema-evolution-a2df6924b54c?source=collection_archive---------0-----------------------#2021-09-15">https://medium.com/nerd-for-tech/standardize-data-format-for-kafka-event-streams-using-apache-avro-and-schema-evolution-a2df6924b54c?source=collection_archive---------0-----------------------#2021-09-15</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="d0ba" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在这个故事中，我提供了 Apache Avro 和合流模式注册中心的概述。它们如何工作，它们解决的问题，以及一个 Java spring boot 和 node js 示例。</p><p id="8921" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">卡夫卡不验证传入的数据</strong></p><p id="8750" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Kafka 以字节为输入，以字节为输出。这使得卡夫卡更加强大和快速。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es jd"><img src="../Images/c12b64765d8ed1b28487b072f49a25f6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Nd5-KDMkl_D931eBBWxMJg.png"/></div></div></figure><blockquote class="jp jq jr"><p id="d352" class="if ig js ih b ii ij ik il im in io ip jt ir is it ju iv iw ix jv iz ja jb jc hb bi translated"><strong class="ih hj">卡夫卡以字节为单位输入并发布。</strong></p><p id="75c4" class="if ig js ih b ii ij ik il im in io ip jt ir is it ju iv iw ix jv iz ja jb jc hb bi translated"><strong class="ih hj">没有数据验证/确认。通常，任何类型的数据都可以发布到主题中。</strong></p></blockquote><p id="f61f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">数据具有字节以外的含义，因此消费者需要解析它，然后再解释它。当一切顺利时，它就是赢家。如果没有，你就按紧急按钮。</p><p id="3b26" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">它们主要发生在这两种情况下:</p><ul class=""><li id="7e55" class="jw jx hi ih b ii ij im in iq jy iu jz iy ka jc kb kc kd ke bi translated">您要查找的字段已不存在。</li><li id="d8cb" class="jw jx hi ih b ii kf im kg iq kh iu ki iy kj jc kb kc kd ke bi translated">字段的类型已经改变(例如，以前的<code class="du kk kl km kn b">String</code>现在是<code class="du kk kl km kn b">Integer</code>)。</li></ul><p id="96aa" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">如何克服这些情况？</strong></p><ol class=""><li id="5371" class="jw jx hi ih b ii ij im in iq jy iu jz iy ka jc ko kc kd ke bi translated">解析错误时捕捉异常，代码会变得难看并且很难维护。</li><li id="aada" class="jw jx hi ih b ii kf im kg iq kh iu ki iy kj jc ko kc kd ke bi translated">每次从生产者处保持相同的格式，这是开启的，但是在软件生命周期中，总是期望修改数据。</li><li id="6cd0" class="jw jx hi ih b ii kf im kg iq kh iu ki iy kj jc ko kc kd ke bi translated">采用一种数据格式并实施允许您执行模式演进的规则，同时保证不中断下游应用程序。</li></ol><h1 id="e3f8" class="kp kq hi bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm bi translated">需要调整数据格式和策略</h1><p id="ebc3" class="pw-post-body-paragraph if ig hi ih b ii ln ik il im lo io ip iq lp is it iu lq iw ix iy lr ja jb jc hb bi translated">有两种方法可以管理 Kafka 上的数据一致性。</p><p id="103b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">文本格式方式(JSON/XML) </strong></p><p id="6b8b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">JSON——一个非常明显的偏好。它很容易实现，由 MongoDB、PostgreSQL 等一些数据库提供本地支持。<br/>JSON 格式被大量使用，有很多优点。作为默认选择，这是最好的选择。但是维护模式是困难的。</p><p id="3d70" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">优点:</strong></p><ul class=""><li id="6eb4" class="jw jx hi ih b ii ij im in iq jy iu jz iy ka jc kb kc kd ke bi translated">数据可以采用任何形式(数组、嵌套元素)</li><li id="c0f0" class="jw jx hi ih b ii kf im kg iq kh iu ki iy kj jc kb kc kd ke bi translated">JSON 是网络上被广泛接受的格式。</li><li id="b375" class="jw jx hi ih b ii kf im kg iq kh iu ki iy kj jc kb kc kd ke bi translated">几乎任何语言都可以阅读 JSON。</li><li id="3c79" class="jw jx hi ih b ii kf im kg iq kh iu ki iy kj jc kb kc kd ke bi translated">JSON 可以很容易地在网络上共享。</li></ul><p id="8b39" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">缺点:</strong></p><ul class=""><li id="d894" class="jw jx hi ih b ii ij im in iq jy iu jz iy ka jc kb kc kd ke bi translated"><em class="js"> JSON 没有原生模式支持</em> <strong class="ih hj"> </strong> <em class="js"> (JSON 模式不是 JSON 的规范)。</em></li><li id="0dcc" class="jw jx hi ih b ii kf im kg iq kh iu ki iy kj jc kb kc kd ke bi translated">由于重复的键，JSON 对象的大小可能相当大。</li><li id="3329" class="jw jx hi ih b ii kf im kg iq kh iu ki iy kj jc kb kc kd ke bi translated">没有注释，元数据，文档。</li></ul><p id="d696" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">二进制序列化选项</strong> <br/>纯文本序列化的第一个优点是这种格式是人类可读的。从 DB 中选择一些事件并直接从查询结果中分析它们是非常方便的。二进制格式需要一个额外的步骤，将字节转换成可读的内容。</p><p id="91fd" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">显然，二进制格式的压缩程度更高，因此存储空间的使用会更低。实际利润取决于事件模型。对于较大的模型，从文本格式消息中节省至少 50%的磁盘空间。</p><p id="9ef8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">不同的序列化方式</strong></p><p id="953e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> <em class="js"> java 序列化— </em> </strong>这不是一个通用的解决方案，因为源和目标都应该将 Java 对象理解为源和目标的 Java。这实际上是不可能的，所以这不是一个选择。<br/> <strong class="ih hj"> <em class="js"> Kryo </em> </strong> —非常快，非常紧凑，但它只在 JVM 上工作，将我们的基础设施限制为只有 JVM 应用程序是没有意义的。同样同上。<br/><strong class="ih hj"><em class="js">Thrift</em></strong>—Thrift 是服务通信的序列化和 RPC 框架。Thrift 在所有主要语言中都支持这些特性，并且对 C++、Python、Hack 和 Java 都有很强的支持。这类似于 ProtoBuffer，但受脸书专利的限制。<br/> <strong class="ih hj"> <em class="js">协议缓冲区</em> </strong> — gRPC 方式。<br/> <strong class="ih hj"> <em class="js"> Avro </em> </strong> —阿帕奇连载—现在正在调查。</p><p id="0e5a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">那个数据格式是<strong class="ih hj"> Apache Avro </strong>。在这篇博客中，我将讨论为什么你需要 Avro，以及为什么它能被<strong class="ih hj">融合模式注册表很好地补充。</strong></p></div><div class="ab cl ls lt gp lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="hb hc hd he hf"><h1 id="3788" class="kp kq hi bd kr ks lz ku kv kw ma ky kz la mb lc ld le mc lg lh li md lk ll lm bi translated">阿帕奇 Avro</h1><p id="7fcc" class="pw-post-body-paragraph if ig hi ih b ii ln ik il im lo io ip iq lp is it iu lq iw ix iy lr ja jb jc hb bi translated">Avro 依赖于<em class="js">模式</em>。读取 Avro 数据时，写入数据时使用的模式始终存在。这允许写入每个数据时没有每个值的开销，使得序列化既快又小。这也有助于动态脚本语言的使用，因为数据及其模式是完全自描述的。</p><p id="695d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">当 Avro 数据存储在一个文件中时，它的模式也随之存储，因此文件可以在以后被任何程序处理。如果读取数据的程序需要不同的模式，这很容易解决，因为两种模式都存在。</p><p id="0109" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">当在 RPC 中使用 Avro 时，客户端和服务器在连接握手中交换模式。(这可以被优化，以便对于大多数调用，实际上没有模式被传输。)因为客户机和服务器都有对方的完整模式、同名字段、缺失字段、额外字段等之间的对应关系。都可以轻松解决。</p><p id="8993" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Avro 模式是用<a class="ae me" href="https://www.json.org/" rel="noopener ugc nofollow" target="_blank"> JSON </a>定义的。这有助于在已经有 JSON 库的语言中实现。</p><h1 id="a957" class="kp kq hi bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm bi translated">与其他系统的比较</h1><p id="50a6" class="pw-post-body-paragraph if ig hi ih b ii ln ik il im lo io ip iq lp is it iu lq iw ix iy lr ja jb jc hb bi translated">Avro 提供类似于系统的功能，如<a class="ae me" href="https://thrift.apache.org/" rel="noopener ugc nofollow" target="_blank">节俭</a>、<a class="ae me" href="https://code.google.com/p/protobuf/" rel="noopener ugc nofollow" target="_blank">协议缓冲</a>等。Avro 在以下基本方面不同于这些系统。</p><ul class=""><li id="28f6" class="jw jx hi ih b ii ij im in iq jy iu jz iy ka jc kb kc kd ke bi translated"><em class="js">动态类型</em> : Avro 不需要生成代码。数据总是伴随着一个模式，该模式允许在没有代码生成、静态数据类型等的情况下完全处理该数据。这促进了通用数据处理系统和语言的构建。</li><li id="4e8f" class="jw jx hi ih b ii kf im kg iq kh iu ki iy kj jc kb kc kd ke bi translated"><em class="js">未标记的数据</em>:由于在读取数据时存在模式，因此需要用数据编码的类型信息要少得多，从而导致较小的序列化大小。</li><li id="4485" class="jw jx hi ih b ii kf im kg iq kh iu ki iy kj jc kb kc kd ke bi translated"><em class="js">没有手动分配的字段 id</em>:当模式改变时，在处理数据时，旧模式和新模式总是存在，因此可以使用字段名称象征性地解决差异。</li></ul><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es mf"><img src="../Images/1a74cbadec5e55e3ce0f11860ed28d0f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qYm6rGhRyINdeysqiylU5w.png"/></div></div></figure><blockquote class="jp jq jr"><p id="e03d" class="if ig js ih b ii ij ik il im in io ip jt ir is it ju iv iw ix jv iz ja jb jc hb bi translated">Avro 在大数据社区越来越受欢迎。由于合流(由于合流模式注册)的大力推动，它也成为最受欢迎的快速数据序列化格式。</p></blockquote><p id="e041" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">Avro 如何解决我们的问题？</strong></p><p id="78dd" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这类似于 RDMS，如果不按照模式创建表，我们就不能插入数据，如果不首先提供模式，就不能创建 Avro 对象。</p><p id="3076" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Avro 具有以下特点:</p><blockquote class="jp jq jr"><p id="585b" class="if ig js ih b ii ij ik il im in io ip jt ir is it ju iv iw ix jv iz ja jb jc hb bi translated"><em class="hi"> Avro 支持原语类型</em> ( <code class="du kk kl km kn b">int</code>、<code class="du kk kl km kn b">string</code>、<code class="du kk kl km kn b">long</code>、<code class="du kk kl km kn b">bytes</code>等)、复杂类型(<code class="du kk kl km kn b">enum</code>、<code class="du kk kl km kn b">arrays</code>、<code class="du kk kl km kn b">unions</code>、可选)、逻辑类型(<code class="du kk kl km kn b">dates</code>、<code class="du kk kl km kn b">timestamp-millis</code>、<code class="du kk kl km kn b">decimal</code>)和数据记录(<code class="du kk kl km kn b">name</code>、<code class="du kk kl km kn b">namespace</code>)。</p><p id="8970" class="if ig js ih b ii ij ik il im in io ip jt ir is it ju iv iw ix jv iz ja jb jc hb bi translated"><em class="hi"> Avro 支持嵌入式文档</em>。</p><p id="f25e" class="if ig js ih b ii ij ik il im in io ip jt ir is it ju iv iw ix jv iz ja jb jc hb bi translated">使用 JSON 定义 Avro 模式。</p><p id="7a1b" class="if ig js ih b ii ij ik il im in io ip jt ir is it ju iv iw ix jv iz ja jb jc hb bi translated">Avro 对象包含模式和数据。</p></blockquote><h1 id="4291" class="kp kq hi bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm bi translated"><strong class="ak"> Avro 与 Spring Boot 一起行动</strong></h1><p id="94f1" class="pw-post-body-paragraph if ig hi ih b ii ln ik il im lo io ip iq lp is it iu lq iw ix iy lr ja jb jc hb bi translated">对于演示，我们需要以下基础设施和技术。完整源代码请访问<a class="ae me" href="https://github.com/ereshzealous/avro_playground/tree/master/spring-boot" rel="noopener ugc nofollow" target="_blank"><strong class="ih hj"><em class="js">GitHub</em></strong></a>。</p><p id="cf47" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"><em class="js">Docker:</em></strong>Docker-compose 文件有 zookeeper，Kafka，schema-registry，schema-registry-ui，kafka-rest-proxy，kafka-topics-ui，kafka-manager。</p><p id="9e99" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> <em class="js"> Java 11，IntelliJ Idea，Maven。</em> </strong></p><p id="51ed" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> Avro 生产商</strong></p><p id="7a7a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="js">下面是 Avro 文件</em></p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="mg mh l"/></div></figure><p id="5856" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="js">用下面的插件配置 maven 插件，生成 Avro 类</em></p><pre class="je jf jg jh fd mi kn mj mk aw ml bi"><span id="79b7" class="mm kq hi kn b fi mn mo l mp mq">&lt;plugin&gt;<br/>    &lt;groupId&gt;org.apache.avro&lt;/groupId&gt;<br/>    &lt;artifactId&gt;avro-maven-plugin&lt;/artifactId&gt;<br/>    &lt;version&gt;${avro.version}&lt;/version&gt;<br/>    &lt;executions&gt;<br/>        &lt;execution&gt;<br/>            &lt;phase&gt;generate-sources&lt;/phase&gt;<br/>            &lt;goals&gt;<br/>                &lt;goal&gt;schema&lt;/goal&gt;<br/>            &lt;/goals&gt;<br/>            &lt;configuration&gt;<br/>                &lt;sourceDirectory&gt;${project.basedir}/src/main/resources/avro&lt;/sourceDirectory&gt;<br/>                &lt;outputDirectory&gt;${project.basedir}/src/main/java/avro&lt;/outputDirectory&gt;<br/>            &lt;/configuration&gt;<br/>        &lt;/execution&gt;<br/>    &lt;/executions&gt;<br/>&lt;/plugin&gt;</span></pre><p id="e7f2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">要生成 Avro 类，请使用下面的 maven 目标。这将生成类，生产者使用该类发送消息。</p><pre class="je jf jg jh fd mi kn mj mk aw ml bi"><span id="3392" class="mm kq hi kn b fi mn mo l mp mq">mvn clean generate-sources</span></pre><p id="6f43" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> Producer application.yml </strong></p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="mg mh l"/></div></figure><p id="43c0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们提出这个应用程序所需的所有基础设施</p><pre class="je jf jg jh fd mi kn mj mk aw ml bi"><span id="1176" class="mm kq hi kn b fi mn mo l mp mq">$ docker-compose up -d<br/>Then check whether all processes are running or not<br/>$ docker-compose ps<br/>          Name                        Command                  State                                               Ports<br/>-----------------------------------------------------------------------------------------------------------------------------------------------------------------<br/>kafka                      /etc/confluent/docker/run        Up (healthy)   0.0.0.0:29092-&gt;29092/tcp,:::29092-&gt;29092/tcp, 0.0.0.0:9092-&gt;9092/tcp,:::9092-&gt;9092/tcp<br/>kafka-manager              /kafka-manager/bin/cmak -D ...   Up (healthy)   0.0.0.0:9000-&gt;9000/tcp,:::9000-&gt;9000/tcp<br/>kafka-rest-proxy           /etc/confluent/docker/run        Up (healthy)   0.0.0.0:8082-&gt;8082/tcp,:::8082-&gt;8082/tcp<br/>kafka-schema-registry-ui   /run.sh                          Up (healthy)   0.0.0.0:8001-&gt;8000/tcp,:::8001-&gt;8000/tcp<br/>kafka-topics-ui            /run.sh                          Up (healthy)   0.0.0.0:8085-&gt;8000/tcp,:::8085-&gt;8000/tcp<br/>schema-registry            /etc/confluent/docker/run        Up (healthy)   0.0.0.0:8081-&gt;8081/tcp,:::8081-&gt;8081/tcp<br/>zookeeper                  /etc/confluent/docker/run        Up (healthy)   0.0.0.0:2181-&gt;2181/tcp,:::2181-&gt;2181/tcp, 2888/tcp, 3888/tcp</span></pre><p id="e86d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们在这里访问模式注册 UI<a class="ae me" href="http://localhost:8001/#/" rel="noopener ugc nofollow" target="_blank"/>。没有模式，我们将在第一次发布消息时创建一个。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es mr"><img src="../Images/e6939f33a5b6d092703ffe584d46ae88.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ghwnWewTEFLxDlW0dLdRLA.png"/></div></div></figure><h1 id="3be0" class="kp kq hi bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm bi translated">开始制作</h1><p id="d04f" class="pw-post-body-paragraph if ig hi ih b ii ln ik il im lo io ip iq lp is it iu lq iw ix iy lr ja jb jc hb bi translated">导航到 avro-producer 并运行<code class="du kk kl km kn b">AvroProducerApplication.java as Java Application</code>。生成器启动并将每 15 秒发布一次消息。创建了一个版本为 1 的架构。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es ms"><img src="../Images/254c27caa9f1cf3fc2d4c278ce510984.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wBnq9SJmdECtcPj8-WbM7Q.png"/></div></div></figure><h1 id="f6b2" class="kp kq hi bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm bi translated">卡夫卡经理</h1><p id="a512" class="pw-post-body-paragraph if ig hi ih b ii ln ik il im lo io ip iq lp is it iu lq iw ix iy lr ja jb jc hb bi translated">要查看 Kafka 管理器，请单击此处的<a class="ae me" href="http://localhost:9000/" rel="noopener ugc nofollow" target="_blank">并创建一个指向本地动物园管理员的新集群。</a></p><h1 id="f95a" class="kp kq hi bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm bi translated">卡夫卡主题用户界面</h1><p id="4351" class="pw-post-body-paragraph if ig hi ih b ii ln ik il im lo io ip iq lp is it iu lq iw ix iy lr ja jb jc hb bi translated">请点击<a class="ae me" href="http://localhost:8085/#/" rel="noopener ugc nofollow" target="_blank">这里</a>看卡夫卡专题。数据由生产商以 Avro 格式生成。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es ms"><img src="../Images/b06b42b46da6a3c4fabdd7ec4313a12a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YAwvoShH9tvrzu1Y-72RVw.png"/></div></div></figure><h1 id="b2bb" class="kp kq hi bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm bi translated">开始消费</h1><p id="0d94" class="pw-post-body-paragraph if ig hi ih b ii ln ik il im lo io ip iq lp is it iu lq iw ix iy lr ja jb jc hb bi translated">同样在消费者中，我们需要同样的 Avro 生成的类来进行反序列化。在这里，它是版本 1。</p><p id="9ced" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">消费应用. yml </strong></p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="mg mh l"/></div></figure><blockquote class="jp jq jr"><p id="489f" class="if ig js ih b ii ij ik il im in io ip jt ir is it ju iv iw ix jv iz ja jb jc hb bi translated">导航至 avro-consumer 并运行<code class="du kk kl km kn b">AvroConsumerApplication.java as Java Application</code>。应用程序将使用该应用程序。</p></blockquote><pre class="je jf jg jh fd mi kn mj mk aw ml bi"><span id="6bd1" class="mm kq hi kn b fi mn mo l mp mq">Payload: {"eventId": "18cad3f1-d62d-4059-9293-aab3f637595b", "eventType": "CREATED", "eventTimestamp": 1631695376, "id": "2c3043ed-adde-4f93-8d3b-cd3e61b0f0b8", "firstName": "lrPTPHyQJS", "lastName": "ZzhmCvJkSn", "email": "<a class="ae me" href="mailto:BeNLmzerLW@gmail.com" rel="noopener ugc nofollow" target="_blank">BeNLmzerLW@gmail.com</a>", "mobileNumber": "7495292433", "city": "nKnVxWhUWD", "country": "India", "createdOn": 1631695376, "updatedOn": 1631695376}<br/>---<br/>2021-09-15 14:22:56.893  INFO 11393 --- [container-0-C-1] c.spring.kafka.avro.config.UsersStream   : <br/>---<br/>Headers: {kafka_offset=1, scst_nativeHeadersPresent=true, kafka_consumer=org.apache.kafka.clients.consumer.KafkaConsumer@e7f8ed6, deliveryAttempt=1, kafka_timestampType=CREATE_TIME, id=219a54d9-e16c-4a8d-17bf-c7e7cd27bd51, kafka_receivedPartitionId=1, contentType=application/vnd.userevent.v1+avro, kafka_receivedTopic=com.spring.kafka.avro.newuser, kafka_receivedTimestamp=1631695406702, kafka_groupId=eventServiceGroup, timestamp=1631695976893}</span><span id="94c5" class="mm kq hi kn b fi mt mo l mp mq">Payload: {"eventId": "75acc44c-f5aa-45e0-b6cf-8d826373f826", "eventType": "CREATED", "eventTimestamp": 1631695406, "id": "b296ece2-e560-4d2f-b045-37263e1299ca", "firstName": "hMoFIySCrU", "lastName": "kTFINNOGqC", "email": "<a class="ae me" href="mailto:AMFTAcUTaU@gmail.com" rel="noopener ugc nofollow" target="_blank">AMFTAcUTaU@gmail.com</a>", "mobileNumber": "8367952785", "city": "rgtjxnsgNR", "country": "India", "createdOn": 1631695406, "updatedOn": 1631695406}<br/>---<br/>2021-09-15 14:22:56.894  INFO 11393 --- [container-0-C-1] c.spring.kafka.avro.config.UsersStream   : <br/>---<br/>Headers: {kafka_offset=0, scst_nativeHeadersPresent=true, kafka_consumer=org.apache.kafka.clients.consumer.KafkaConsumer@e7f8ed6, deliveryAttempt=1, kafka_timestampType=CREATE_TIME, id=18096877-34aa-93e5-83f2-79eecb4ae7ba, kafka_receivedPartitionId=0, contentType=application/vnd.userevent.v1+avro, kafka_receivedTopic=com.spring.kafka.avro.newuser, kafka_receivedTimestamp=1631695391699, kafka_groupId=eventServiceGroup, timestamp=1631695976894}</span><span id="b77d" class="mm kq hi kn b fi mt mo l mp mq">Payload: {"eventId": "898404b9-883e-4cd9-bfa4-34d1d528582b", "eventType": "CREATED", "eventTimestamp": 1631695391, "id": "f909e341-a0ff-47e6-b373-6a2f0c1242e2", "firstName": "JcNVepDueF", "lastName": "PJaPwBzAzT", "email": "<a class="ae me" href="mailto:ccdpBNtNsx@gmail.com" rel="noopener ugc nofollow" target="_blank">ccdpBNtNsx@gmail.com</a>", "mobileNumber": "3546653340", "city": "RVwSGyEnaU", "country": "India", "createdOn": 1631695391, "updatedOn": 1631695391}<br/>---</span></pre><h1 id="791b" class="kp kq hi bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm bi translated">Avro 模式的发展和兼容性</h1><p id="1605" class="pw-post-body-paragraph if ig hi ih b ii ln ik il im lo io ip iq lp is it iu lq iw ix iy lr ja jb jc hb bi translated">数据管理的一个重要方面是模式演变。在定义了初始模式之后，应用程序可能需要随着时间的推移对其进行改进。当这种情况发生时，下游消费者能够无缝地处理用新旧模式编码的数据是至关重要的。这是一个在实践中容易被忽略的领域，直到您遇到第一个生产问题。如果没有仔细考虑数据管理和模式演化，人们通常会在以后付出更高的代价。更多详情，请访问<a class="ae me" href="https://docs.confluent.io/platform/current/schema-registry/avro.html" rel="noopener ugc nofollow" target="_blank">此处</a>。</p><p id="c62b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><code class="du kk kl km kn b"><em class="js">BACKWARD</em></code>:使用模式 X 的消费者可以处理用模式 X 或 X-1 产生的数据。这是 Avro 模式设置的默认兼容级别。</p><p id="f5af" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><code class="du kk kl km kn b">BACKWARD_TRANSITIVE</code>:使用模式 X 的消费者可以处理使用模式 X、X-1 或 X-2 生成的数据。</p><p id="e7fe" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><code class="du kk kl km kn b">FORWARD</code>:使用模式 X 生成的数据可以被使用模式 X 或 X-1 的消费者读取。</p><p id="978b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><code class="du kk kl km kn b">FORWARD_TRANSITIVE</code>:使用模式 X 生成的数据可以被使用模式 X、X-1 或 X-2 的消费者读取。</p><p id="9276" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><code class="du kk kl km kn b">FULL</code>:模式 X 和 X-1 之间向后和向前兼容。</p><p id="9f4b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><code class="du kk kl km kn b">FULL_TRANSITIVE</code>:在模式 X、X-1 和 X-2 之间向后和向前兼容。</p><p id="6f5a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><code class="du kk kl km kn b">NONE</code>兼容性类型意味着模式兼容性检查被禁用。</p><h1 id="8485" class="kp kq hi bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm bi translated">升级客户端的顺序</h1><p id="d949" class="pw-post-body-paragraph if ig hi ih b ii ln ik il im lo io ip iq lp is it iu lq iw ix iy lr ja jb jc hb bi translated">配置的兼容性类型对升级客户端应用程序的顺序有影响，即生产者使用模式将事件写入 Kafka，消费者使用模式从 Kafka 读取事件。根据兼容性类型:</p><ul class=""><li id="7c8e" class="jw jx hi ih b ii ij im in iq jy iu jz iy ka jc kb kc kd ke bi translated"><code class="du kk kl km kn b">BACKWARD</code>或<code class="du kk kl km kn b">BACKWARD_TRANSITIVE</code>:不能保证使用旧模式的消费者可以读取使用新模式产生的数据。因此，在开始生成新事件之前，请升级所有使用者。</li><li id="bf42" class="jw jx hi ih b ii kf im kg iq kh iu ki iy kj jc kb kc kd ke bi translated"><code class="du kk kl km kn b">FORWARD</code>或<code class="du kk kl km kn b">FORWARD_TRANSITIVE</code>:不能保证使用新模式的消费者能够读取使用旧模式产生的数据。因此，首先，使用新模式将所有生成器升级到，并确保使用旧模式生成的数据对使用者不可用，然后升级使用者。</li><li id="9ee9" class="jw jx hi ih b ii kf im kg iq kh iu ki iy kj jc kb kc kd ke bi translated"><code class="du kk kl km kn b">FULL</code>或<code class="du kk kl km kn b">FULL_TRANSITIVE</code>:确保使用旧模式的消费者可以读取使用新模式生成的数据，使用新模式的消费者可以读取使用旧模式生成的数据。因此，您可以独立升级生产者和消费者。</li><li id="efa3" class="jw jx hi ih b ii kf im kg iq kh iu ki iy kj jc kb kc kd ke bi translated"><code class="du kk kl km kn b">NONE</code>:兼容性检查被禁用。因此，您需要对何时升级客户端保持谨慎。</li></ul><h1 id="10ad" class="kp kq hi bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm bi translated">在上面的例子中尝试兼容性</h1><p id="4094" class="pw-post-body-paragraph if ig hi ih b ii ln ik il im lo io ip iq lp is it iu lq iw ix iy lr ja jb jc hb bi translated">让我们在模式中添加一个新字段<code class="du kk kl km kn b">active</code>，它是一个布尔类型，默认值为 true。这种变化是由生产者产生的。但是消费者没有使用最新的模式进行升级，但是消费者仍然可以使用默认情况下兼容<code class="du kk kl km kn b">BACKWARD</code>的旧模式。</p><p id="17a4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">最新的模式是版本 2</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es mu"><img src="../Images/6bb7744087b28175a19e1b3fe2e9809d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1eCwaUYiRgWHhkArWDoKjA.png"/></div></div></figure><p id="ccc0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">尽管如此，消费者仍然可以使用这些消息</p><pre class="je jf jg jh fd mi kn mj mk aw ml bi"><span id="9892" class="mm kq hi kn b fi mn mo l mp mq">---<br/>Headers: {kafka_offset=2, scst_nativeHeadersPresent=true, kafka_consumer=org.apache.kafka.clients.consumer.KafkaConsumer@57ea6a32, deliveryAttempt=1, kafka_timestampType=CREATE_TIME, id=b22504e0-a579-f3b8-000c-42ed4ff0e6db, kafka_receivedPartitionId=2, contentType=application/vnd.userevent.v2+avro, kafka_receivedTopic=com.spring.kafka.avro.newuser, kafka_receivedTimestamp=1631697283218, kafka_groupId=eventServiceGroup, timestamp=1631697283224}</span><span id="60ce" class="mm kq hi kn b fi mt mo l mp mq">Payload: {"eventId": "df29818f-3ae1-4cbb-8f24-84e8e9f6ab58", "eventType": "CREATED", "eventTimestamp": 1631697283, "id": "f49783f5-f8f9-4931-be2d-8433a60eb7da", "firstName": "ikfLuTTStC", "lastName": "RHofUQYeNk", "email": "<a class="ae me" href="mailto:EGnkrAnDug@gmail.com" rel="noopener ugc nofollow" target="_blank">EGnkrAnDug@gmail.com</a>", "mobileNumber": "5127259588", "city": "lIqWLLPnRF", "country": "India", "createdOn": 1631697283, "updatedOn": 1631697283}</span></pre></div><div class="ab cl ls lt gp lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="hb hc hd he hf"><p id="0a79" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">使用 Avro 的节点 Js 应用</strong></p><p id="1fb8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我已经在 GitHub<a class="ae me" href="https://github.com/ereshzealous/avro_playground/tree/master/node/kafka-consumer" rel="noopener ugc nofollow" target="_blank"><strong class="ih hj"/></a>页面上创建了一个示例节点 js 应用程序。请检查</p></div></div>    
</body>
</html>