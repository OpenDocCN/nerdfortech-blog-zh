<html>
<head>
<title>Adding Nested Recycler View in Android Using kotlin and MVVM with Custom Model From API With Multiple Views</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用 kotlin 和 MVVM 从带有多个视图的 API 添加嵌套回收器视图</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/adding-nested-recycler-view-in-android-using-kotlin-and-mvvm-with-custom-model-from-api-with-506bff5a1032?source=collection_archive---------8-----------------------#2021-06-10">https://medium.com/nerd-for-tech/adding-nested-recycler-view-in-android-using-kotlin-and-mvvm-with-custom-model-from-api-with-506bff5a1032?source=collection_archive---------8-----------------------#2021-06-10</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div class="er es if"><img src="../Images/5f2357619470507ca09fd0d03f233a9b.png" data-original-src="https://miro.medium.com/v2/resize:fit:842/format:webp/1*UQI6lRBHreF8M4_u4UhMPA.png"/></div></figure><p id="5100" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi jk translated"><span class="l jl jm jn bm jo jp jq jr js di">R</span>EciClarrview 是安卓系统中最重要的组件之一。同样，回收者看到的计划也日益复杂，比如回收者看到的种子种类繁多，解决了回收者看到的，解决了回收者看到的种子类型众多。</p><p id="46ac" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">我陷入了一个问题，我想在嵌套列表中显示来自 Api 的数据，因为我是 Recyclerview，所以最好的方法是做一个子-父嵌套列表，另外我有一个模型，我必须显示两个列表一个用于月，另一个用于事务数据。</p><p id="09ed" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><strong class="io hj">我用的是 MVVM，用的是 Kotlin，用的是改装版 Api！好吧，我们将在稍后讨论这个问题，现在，我们将只讨论如何在 One RecyclerView 中嵌套。</strong></p><h1 id="935d" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated"><strong class="ak">这是我从 API </strong>得到的回复</h1><figure class="ks kt ku kv fd ij er es paragraph-image"><div class="er es kr"><img src="../Images/55fa8c02475bf4fe23fa98a2112b2e65.png" data-original-src="https://miro.medium.com/v2/resize:fit:1076/format:webp/1*HlqOCM23n3CNtVnDZpduTQ.png"/></div></figure><blockquote class="kw kx ky"><p id="7104" class="im in kz io b ip iq ir is it iu iv iw la iy iz ja lb jc jd je lc jg jh ji jj hb bi translated">所以你可以看到我在每个对象列表中都有月名，所以基本上我的场景是制作其他月份的列表，并显示响应那个特定月份的数据，你可以看到，换句话说，我想用月名在 kot Lin<strong class="io hj">分组</strong></p></blockquote><h1 id="2835" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">它会是什么样子？</h1><figure class="ks kt ku kv fd ij er es paragraph-image"><div class="er es if"><img src="../Images/5f2357619470507ca09fd0d03f233a9b.png" data-original-src="https://miro.medium.com/v2/resize:fit:842/format:webp/1*UQI6lRBHreF8M4_u4UhMPA.png"/></div></figure><p id="0752" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">所以在这里，你可以看到我已经分别按照月份的清单和交易清单进行了分类和分组，并再次设定了具体的月份。</p><p id="abb9" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">这是之前的场景，有一个简单的月份名称，所有数据都在它下面。</p><h1 id="5648" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated"><strong class="ak">在</strong>之前:</h1><figure class="ks kt ku kv fd ij er es paragraph-image"><div class="er es ld"><img src="../Images/e94dc369d94fb6a59c2218b21b91c484.png" data-original-src="https://miro.medium.com/v2/resize:fit:600/format:webp/1*IGwJnui4OhWLm3Sz-MSACg.png"/></div><figcaption class="le lf et er es lg lh bd b be z dx translated">在这之前</figcaption></figure><h1 id="e3f8" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">关键理念</h1><p id="e968" class="pw-post-body-paragraph im in hi io b ip li ir is it lj iv iw ix lk iz ja jb ll jd je jf lm jh ji jj hb bi translated">在开始代码之前，让我们了解设计嵌套回收器视图所涉及的基本关键思想。因此，关键思想是，在顶层，我们将有一个卡片视图对象列表，我们将在回收器视图中显示。因此，在顶层，我们将有一个不同视图的单一回收视图。现在，每个视图都将有一个回收器视图，因为它是子视图之一，并且这个子回收器视图将充当垂直转盘。</p><h1 id="439c" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">酷，密码！</h1><p id="103c" class="pw-post-body-paragraph im in hi io b ip li ir is it lj iv iw ix lk iz ja jb ll jd je jf lm jh ji jj hb bi translated">我不会像之前那样展示完整的步骤，因为这是另一个主题，所以我们现在可以直接跳到最后的代码！</p><p id="ca30" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><strong class="io hj">数据类</strong></p><p id="763c" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">这是我的模型类，它被称为 POJO 类，现在很简单，但是在接下来的步骤中，我将告诉你我们必须在一个回收器视图中为嵌套列表视图做什么！</p><figure class="ks kt ku kv fd ij er es paragraph-image"><div role="button" tabindex="0" class="lo lp di lq bf lr"><div class="er es ln"><img src="../Images/673e791acf057b3fde6f508f4cd4a8c8.png" data-original-src="https://miro.medium.com/v2/resize:fit:644/format:webp/1*xZ-WPnGb-_6zT1i0s7Fh9g.png"/></div></div></figure><figure class="ks kt ku kv fd ij er es paragraph-image"><div class="er es ls"><img src="../Images/3ffc31907453cee1bd4b2db5edd50e49.png" data-original-src="https://miro.medium.com/v2/resize:fit:1256/format:webp/1*QOWjZmyyx8qACzRZB_V4Bg.png"/></div></figure><p id="74ac" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">我在我的同一个数据类(POJO)下面做了这个自定义响应，这是自定义的，所以通过名字你可以理解我是为了嵌套而做这个方法的</p><p id="4296" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">我在自定义响应中做了一个列表，并将列表类型作为我的来自 API 的 Pojo 类。</p><p id="b67f" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">接下来的步骤，</p><p id="cdb5" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">在我的片段中，我制作了一个 hashmap，因为从技术上来说，我将把 hashmap 的值放在列表中，所以我正在编写代码，这样它就会有一个清晰的图像</p><pre class="ks kt ku kv fd lt lu lv lw aw lx bi"><span id="6f33" class="ly ju hi lu b fi lz ma l mb mc">val hashMapMonthWise = HashMap&lt;String, ArrayList&lt;GetSaleInvoiceTransactionResponse&gt;&gt;()</span></pre><p id="e8e9" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">然后:</p><pre class="ks kt ku kv fd lt lu lv lw aw lx bi"><span id="9763" class="ly ju hi lu b fi lz ma l mb mc">fun getMonthWiseData(List: List&lt;GetSaleInvoiceTransactionResponse&gt;) {<br/><br/>    val customRepsone = ArrayList&lt;CustomRepsone&gt;()<br/>    List.<em class="kz">forEach </em><strong class="lu hj">{<br/>        </strong>if (hashMapMonthWise.<em class="kz">contains</em>(<strong class="lu hj">it</strong>.MonthName)) {<br/>            val list = hashMapMonthWise[<strong class="lu hj">it</strong>.MonthName]<br/>            list!!.add(<strong class="lu hj">it</strong>)<br/>            hashMapMonthWise[<strong class="lu hj">it</strong>.MonthName.<em class="kz">toString</em>()] = list<br/>        } else {<br/>            val consolidatedList = ArrayList&lt;GetSaleInvoiceTransactionResponse&gt;()<br/>            consolidatedList.add(<strong class="lu hj">it</strong>)<br/>            hashMapMonthWise[<strong class="lu hj">it</strong>.MonthName.<em class="kz">toString</em>()] = consolidatedList<br/>        }<br/>    <strong class="lu hj">}<br/>    </strong>Timber.d("Text ${hashMapMonthWise}")<br/><br/>    hashMapMonthWise.<em class="kz">forEach </em><strong class="lu hj">{<br/>        </strong>customRepsone.add(CustomRepsone(<strong class="lu hj">it</strong>.key, <strong class="lu hj">it</strong>.value))<br/>    <strong class="lu hj">}<br/>    </strong>listOfCustomResp.clear()<br/>    listOfCustomResp.addAll(customRepsone)<br/>    recylerViewTransactions.<em class="kz">adapter</em>?.notifyDataSetChanged()<br/>}</span></pre><p id="f6ad" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">我必须用这个方法，通过使用 Hashmap 在另一个列表中列出月份。</p><p id="dfcd" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">所以现在我们将制作两个物品和两个适配器。</p><p id="4726" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">所以对于第一个子适配器</p><pre class="ks kt ku kv fd lt lu lv lw aw lx bi"><span id="0095" class="ly ju hi lu b fi lz ma l mb mc">import android.os.Build<br/>import android.view.LayoutInflater<br/>import android.view.ViewGroup<br/>import androidx.annotation.RequiresApi<br/>import androidx.recyclerview.widget.RecyclerView<br/>import com.technosys.clubcardapp.data.models.CustomRepsone<br/>import com.technosys.clubcardapp.data.models.GetSaleInvoiceTransactionResponse<br/>import com.technosys.clubcardapp.databinding.ItemTransactionHistoryBinding<br/>import com.technosys.clubcardapp.databinding.ItemTransactionMonthWiseBinding<br/>import java.text.SimpleDateFormat<br/><em class="kz">//child<br/></em>class MonthWiseAdapter(<br/>    private val list: List&lt;GetSaleInvoiceTransactionResponse&gt;,<br/>    <em class="kz">// private val listener: ClickItemListener<br/></em>) : RecyclerView.Adapter&lt;MonthWiseAdapter.ViewHolder&gt;() {<br/><br/>    val parser = SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss")<br/>    val formateStyle8 = "dd-MMM-yyyyThh:mm:ss"<br/>    val formatter = SimpleDateFormat("dd.MMM.yyyy")<br/>    var output = formatter.format(parser.parse("2019-06-24T11:12:3"))<br/><br/><br/><em class="kz">//    interface ClickItemListener {<br/>//        fun onClicked(position: Int)<br/>//    }<br/><br/>    </em>override fun onCreateViewHolder(<br/>        parent: ViewGroup,<br/>        viewType: Int<br/>    ): MonthWiseAdapter.ViewHolder {<br/>        return ViewHolder(ItemTransactionMonthWiseBinding.inflate(LayoutInflater.from(parent.<em class="kz">context</em>)))<br/>    }<br/><br/>    override fun getItemCount(): Int {<br/>        return list.size<br/>    }<br/><br/>    @RequiresApi(Build.VERSION_CODES.<em class="kz">O</em>)<br/>    override fun onBindViewHolder(holder: ViewHolder, position: Int) {<br/>        val model = list[position]<br/>        holder.bind.tvDate.<em class="kz">text </em>= formatter.format(parser.parse(model.InvoiceDate))<br/>        holder.bind.transcationNumbers.<em class="kz">text </em>= model.InvoiceNumber.<em class="kz">toString</em>()<br/>        holder.bind.tvPoints.<em class="kz">text </em>= model.PointsEarned!!.<em class="kz">toDouble</em>().toString()<br/>        holder.bind.tvPointsRedeemed.<em class="kz">text </em>= model.PointsRedeemed.<em class="kz">toString</em>()<br/>        holder.bind.tvPointsEarned.<em class="kz">text </em>= model.PointsEarned.toString()<br/>        holder.bind.tvTotalPoints.<em class="kz">text </em>= model.TotalPoint.<em class="kz">toString</em>()<br/><br/><em class="kz">//<br/>//        Picasso.get().load(model.profile_pic).fit().centerCrop().into(holder.bind.profileImage)<br/>//        holder.bind.name.text = "${model.full_name}"<br/>//        holder.bind.commentMessage.text = "${model.comment}"<br/>//<br/>//        holder.itemView.setOnClickListener {<br/>//            listener.onClicked(position)<br/>//        }<br/><br/>    </em>}<br/><br/>    class ViewHolder(binding: ItemTransactionMonthWiseBinding) :<br/>        RecyclerView.ViewHolder(binding.<em class="kz">root</em>) {<br/>        val bind = binding<br/>    }<br/><br/>}</span></pre><p id="99a5" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">在这一点上，我做了单独的项目，我说如果我一步一步地讲，它会深入很多，所以也将是单独的主题</p><blockquote class="kw kx ky"><p id="2d01" class="im in kz io b ip iq ir is it iu iv iw la iy iz ja lb jc jd je lc jg jh ji jj hb bi translated">现在父适配器也将在<strong class="io hj"> onBindViewHolder </strong>中，我们将<strong class="io hj">实现</strong>这个:</p></blockquote><pre class="ks kt ku kv fd lt lu lv lw aw lx bi"><span id="e66c" class="ly ju hi lu b fi lz ma l mb mc">holder.itemView.recylerViewMonthData.<em class="kz">apply </em><strong class="lu hj">{<br/>    </strong><em class="kz">adapter </em>= MonthWiseAdapter(model.listOfTransctionByonthWIse)<br/>    <em class="kz">adapter</em>?.notifyDataSetChanged()<br/><strong class="lu hj">}</strong></span></pre><p id="0e19" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">因此，我们将把它放在父适配器的 OnBindViewHolder 方法的末尾</p><h1 id="e13a" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated"><strong class="ak">然后在关于成功改造 Api 的方法片段中，我们将首先这样做</strong></h1><pre class="ks kt ku kv fd lt lu lv lw aw lx bi"><span id="52ff" class="ly ju hi lu b fi lz ma l mb mc">Resource.Status.<em class="kz">SUCCESS </em>-&gt; {<br/>    <strong class="lu hj">it</strong>?.<em class="kz">let </em><strong class="lu hj">{ </strong>data <strong class="lu hj">-&gt;<br/>        </strong>loadingDialog.dismiss()<br/>        <strong class="lu hj">it</strong>.<em class="kz">let </em><strong class="lu hj">{<br/>            </strong>data.data?.<em class="kz">let </em><strong class="lu hj">{<br/>                </strong>if (<strong class="lu hj">it</strong>.isEmpty()) {<br/>                    relativeNoRecordFound.<em class="kz">visibility </em>= View.<em class="kz">VISIBLE<br/>                    </em>relativeListOfTransactions.<em class="kz">visibility </em>= View.<em class="kz">GONE<br/>                </em>} else {<br/>                    relativeListOfTransactions.<em class="kz">visibility </em>= View.<em class="kz">VISIBLE<br/>                    </em>relativeNoRecordFound.<em class="kz">visibility </em>= View.<em class="kz">GONE<br/><br/>                    //CustomList for Months<br/>                    </em>getMonthWiseData(<strong class="lu hj">it</strong>)<br/>                    ListOfTransactions.clear()<br/>                    ListOfTransactions.addAll(<strong class="lu hj">it</strong>)<br/>                }<br/><br/>            <strong class="lu hj">}</strong></span></pre><p id="684e" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">我们已经创建了那个方法，所以我们在添加列表的地方调用，所以我们也调用那个方法并传递列表。</p><h1 id="3b2e" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated"><strong class="ak">所以在最后的</strong></h1><pre class="ks kt ku kv fd lt lu lv lw aw lx bi"><span id="6bf8" class="ly ju hi lu b fi lz ma l mb mc">recylerViewTransactions.<em class="kz">adapter </em>= TransactionHistoryAdapter(listOfCustomResp)</span></pre><h1 id="ddfc" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">一切正常，点击运行！</h1><p id="e5cb" class="pw-post-body-paragraph im in hi io b ip li ir is it lj iv iw ix lk iz ja jb ll jd je jf lm jh ji jj hb bi translated">现在一切似乎都很好，点击运行，看看你美丽的最终结果。因此，您可以看到添加嵌套回收器视图是多么容易，并且使用 Kotlin 进行开发使开发变得更加有趣和容易。</p><p id="d3d3" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">注意:<strong class="io hj">我的方法是我已经使用了 hashmap 和 List，所以从这我已经做了，并解决了这个问题</strong></p><p id="f4a5" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">请欣赏它，这样我就可以在未来写更多！也</p><blockquote class="kw kx ky"><p id="ed66" class="im in kz io b ip iq ir is it iu iv iw la iy iz ja lb jc jd je lc jg jh ji jj hb bi translated"><strong class="io hj"> <em class="hi">快乐编码</em> </strong></p><p id="a74e" class="im in kz io b ip iq ir is it iu iv iw la iy iz ja lb jc jd je lc jg jh ji jj hb bi translated">请关注我并欣赏它，因为我可以在未来写更多更好的主题。</p></blockquote><p id="6b7f" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><strong class="io hj">https://github.com/SaaifKhan</strong></p></div></div>    
</body>
</html>