<html>
<head>
<title>How to easily apply Performance Management with InspectIT</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何通过InspectIT轻松应用绩效管理</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/how-to-easily-apply-performance-management-with-inspectit-7692e5c43d20?source=collection_archive---------5-----------------------#2021-04-26">https://medium.com/nerd-for-tech/how-to-easily-apply-performance-management-with-inspectit-7692e5c43d20?source=collection_archive---------5-----------------------#2021-04-26</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div class="er es if"><img src="../Images/6c1890ed837a46e4ce52e45bb3e0e399.png" data-original-src="https://miro.medium.com/v2/resize:fit:646/format:webp/1*PG9C9O2ccIggPiXk7ML54w.png"/></div></figure><p id="784b" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">今天，我们将看到一个精彩的开源工具来执行不同类型的任务，从跟踪，监控，或仪器:InspectIT。这个工具是一个Java代理，从上一篇文章中我们已经对它有所了解，你可以在这里看到。</p><p id="272e" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">这个软件试图减少两件事。一方面，使用其他应用性能管理(APM)工具所需的配置时间。如耶格、普罗米修斯、齐普金或千分尺。另一方面，如果我们想执行检测任务，就要减少对应用程序的修改。</p><p id="21ed" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">InspectIT基于OpenCensus，这是一套用不同语言制作的开放软件库，允许我们获得分布式指标和跟踪。这种软件已经有了广泛的出口，允许发送信息到其他监测工具。InspectIT支持这些出口商中的大多数。</p><p id="c6e2" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">由于所有这些原因，InspectIT是一个很好的工具。因为它是一个Java代理，所以我们不需要修改我们的应用程序来获取性能信息。通过预配置的导出器，我们可以自动获取指标和跟踪，并将它们发送到不同的目的地。</p><p id="79e9" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">通过示例，我们将能够看到如何从我们的应用程序中获取这些信息。不同示例中的操作是相似的。为了让它发挥作用，我们必须遵循以下两个步骤:</p><ul class=""><li id="cbd4" class="jk jl hi io b ip iq it iu ix jm jb jn jf jo jj jp jq jr js bi translated">通过JVM参数'-java agent:/full/path/to/library '关联存储在库中的Java代理。</li><li id="a94e" class="jk jl hi io b ip jt it ju ix jv jb jw jf jx jj jp jq jr js bi translated">通过JVM参数关联要使用的导出器属性。我们可以关联一个或多个属性，每个属性都有相应的参数。</li></ul><p id="2a14" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">对于第一个例子，我们将使用一个Jaeger导出器，通过它我们将能够获得应用程序跟踪。它的基础将是我们在以前的帖子中做过的一个例子，基于Apache Camel，你可以在这里看到<a class="ae jy" href="https://danielblancocuadrado.medium.com/apache-camel-trace-control-with-jaeger-13edf87043bc" rel="noopener"/>。请记住，Jaeger是一个工具或追踪器，它允许我们收集应用程序的痕迹信息，并在自己的图形界面中可视化它们。</p><p id="9433" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">步骤如下:</p><ul class=""><li id="1dbb" class="jk jl hi io b ip iq it iu ix jm jb jn jf jo jj jp jq jr js bi translated">一方面，我们必须下载包含java代理的库，我们可以从<a class="ae jy" href="https://github.com/inspectIT/inspectit-ocelot/releases" rel="noopener ugc nofollow" target="_blank">这里</a>下载。我们将它放在一个路径中，我们将在稍后启动应用程序时指明该路径。</li><li id="02d5" class="jk jl hi io b ip jt it ju ix jv jb jw jf jx jj jp jq jr js bi translated">启动Jaeger，例如用一个docker-compose像下面这样。</li></ul><pre class="jz ka kb kc fd kd ke kf kg aw kh bi"><span id="9e5d" class="ki kj hi ke b fi kk kl l km kn">version: '2.4'<br/>networks:<br/>  sandbox-apache-net:<br/>    ipam:<br/>      driver: default<br/>      config:<br/>        - subnet: 172.24.0.0/16</span><span id="4dcb" class="ki kj hi ke b fi ko kl l km kn">services:<br/>  mysql:<br/>    image: mysql:5.7.26<br/>    mem_limit: 2G<br/>    container_name: sandbox-apache-mysql<br/>    hostname: sandbox-apache-mysql<br/>    networks:<br/>      sandbox-apache-net:<br/>        ipv4_address: 172.24.1.1<br/>    environment:<br/>      MYSQL_HOST: sandbox-apache-mysql<br/>      MYSQL_ROOT_PASSWORD: root<br/>    ports:<br/>      - 3306:3306<br/>    volumes:<br/>      - ./configs/mysql/conf.d/custom.cnf:/etc/mysql/conf.d/custom.cnf<br/>      - ./configs/mysql/scripts:/docker-entrypoint-initdb.d</span><span id="6864" class="ki kj hi ke b fi ko kl l km kn">  jaeger:<br/>    image: jaegertracing/all-in-one:latest<br/>    ports:<br/>      - 16686:16686<br/>      - 14268:14268</span></pre><ul class=""><li id="d93f" class="jk jl hi io b ip iq it iu ix jm jb jn jf jo jj jp jq jr js bi translated">最后，启动JVM，传递允许我们配置所需导出器的参数。对于Jaeger，我们将使用以下方法:</li></ul><pre class="jz ka kb kc fd kd ke kf kg aw kh bi"><span id="b4c9" class="ki kj hi ke b fi kk kl l km kn">-javaagent:/home/deesebc/Downloads/inspectit-ocelot-agent-1.8.1.jar -Dinspectit.exporters.tracing.jaeger.url=http://127.0.0.1:14268/api/traces <br/>-Dinspectit.exporters.tracing.jaeger.service-name=inspectitJaegerExample</span></pre><p id="fd93" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">在URL属性中，我们指出Jaeger所在的地址，使用<em class="kp"> service-name </em>我们可以指出我们将注册Jaeger跟踪的名称。</p><p id="c4fd" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">作为了解Jaeger如何工作的前一步，我们将对我们的应用程序进行几个查询。以便通过检查进行登记。如果使用我的应用程序的代码，会是一个类似于这样的调用:<a class="ae jy" href="http://localhost:9090/book/1" rel="noopener ugc nofollow" target="_blank"><em class="kp">http://localhost:9090/book/1</em></a>。</p><p id="c45a" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">如果我们访问URL<a class="ae jy" href="http://localhost:16686/search" rel="noopener ugc nofollow" target="_blank"><em class="kp">http://localhost:16686/search</em></a>，我们将能够访问跟踪浏览器并搜索我们的应用程序的跟踪。</p><figure class="jz ka kb kc fd ij er es paragraph-image"><div class="er es kq"><img src="../Images/87db5bea994817cfaceb35547b15f74d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/0*HhxC074JSapp1AUQ.png"/></div></figure><p id="456f" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">在下一个例子中，为了了解InspectIT的更多潜力，并了解它如何获取指标，我们将使用Prometheus的导出器。我们将基于的例子将是这个<a class="ae jy" href="https://danielblancocuadrado.medium.com/apache-camel-create-your-own-metric-with-micrometer-b10d2db09b4f" rel="noopener">一个</a>。</p><p id="4ba0" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">我们再次开始准备一个docker-compose，允许我们部署Prometheus。我们可以基于上一个示例，它将类似于以下内容:</p><pre class="jz ka kb kc fd kd ke kf kg aw kh bi"><span id="7e7e" class="ki kj hi ke b fi kk kl l km kn">version: '2.4'<br/>networks:<br/>  sandbox-apache-net:<br/>    ipam:<br/>      driver: default<br/>      config:<br/>        - subnet: 172.24.0.0/16</span><span id="a952" class="ki kj hi ke b fi ko kl l km kn">services:<br/>  mysql:<br/>    image: mysql:5.7.26<br/>    mem_limit: 2G<br/>    container_name: sandbox-apache-mysql<br/>    hostname: sandbox-apache-mysql<br/>    networks:<br/>      sandbox-apache-net:<br/>        ipv4_address: 172.24.1.1<br/>    environment:<br/>      MYSQL_HOST: sandbox-apache-mysql<br/>      MYSQL_ROOT_PASSWORD: root<br/>    ports:<br/>      - 3306:3306<br/>    volumes:<br/>      - ./configs/mysql/conf.d/custom.cnf:/etc/mysql/conf.d/custom.cnf<br/>      - ./configs/mysql/scripts:/docker-entrypoint-initdb.d<br/>      <br/>  prometheus:<br/>    image: prom/prometheus:v2.6.1<br/>    ports:<br/>      - 9091:9090<br/>    volumes:<br/>      - ./configs/prometheus.yml:/etc/prometheus/prometheus.yml<br/>    networks:<br/>      sandbox-apache-net:<br/>        ipv4_address: 172.24.1.2<br/>    extra_hosts:<br/>      docker.host: 172.28.0.1</span></pre><blockquote class="kr ks kt"><p id="a764" class="im in kp io b ip iq ir is it iu iv iw ku iy iz ja kv jc jd je kw jg jh ji jj hb bi translated">172.28.0.1是docker网桥接口的IP。</p></blockquote><p id="9cd3" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">下一点将是从允许我们将信息导出到Prometheus的参数开始我们的应用程序。</p><pre class="jz ka kb kc fd kd ke kf kg aw kh bi"><span id="0368" class="ki kj hi ke b fi kk kl l km kn">-javaagent:/home/deesebc/Downloads/inspectit-ocelot-agent-1.8.1.jar -Dinspectit.exporters.metrics.prometheus.host=172.28.0.1 <br/>-Dinspectit.exporters.metrics.prometheus.port=8888</span></pre><p id="5636" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">让我们记住，为了让Prometheus工作，它必须从一个特定的URL读取关于应用程序的信息。因此，一方面，我们必须配置普罗米修斯从一个特定的点读取。我们将通过Prometheus配置文件(docker-compose的一部分)来实现这一点:</p><pre class="jz ka kb kc fd kd ke kf kg aw kh bi"><span id="9603" class="ki kj hi ke b fi kk kl l km kn">scrape_configs:<br/>  - job_name: 'prometheus'<br/>    scrape_interval: 1m<br/>    static_configs:<br/>      - targets: ['localhost:9090']<br/>  - job_name: 'apache_example'<br/>    scrape_interval: 1m<br/>    metrics_path: '/metrics'<br/>    static_configs:<br/>      - targets: ['172.28.0.1:8888']</span></pre><p id="f58d" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">通过JVM参数，我们将向InspectIT表明，我们希望在指示的IP和端口中公开我们的应用程序的信息。在我们所基于的例子中，是由弹簧致动器完成的。</p><p id="429f" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">一旦一切启动，我们将如上所述进行几次调用。现在我们可以访问普罗米修斯，看到已经完成的监测。</p><p id="5708" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">如果我们访问路由<a class="ae jy" href="http://localhost:8888/metrics" rel="noopener ugc nofollow" target="_blank"><em class="kp">http://localhost:8888/metrics</em></a>，我们将能够看到我们从应用程序生成的不同指标。如果我们访问Prometheus URL<a class="ae jy" href="http://localhost:9091/targets" rel="noopener ugc nofollow" target="_blank"><em class="kp">http://localhost:9091/targets</em></a>我们可以看到我们的端点是否被Prometheus正确读取。</p><figure class="jz ka kb kc fd ij er es paragraph-image"><div class="er es kq"><img src="../Images/7b15921e8f3e7d4dc3ce224b4b543921.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/0*I0UCYAUW6xE88Wjy.png"/></div></figure><p id="c482" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">下一步将访问<a class="ae jy" href="http://localhost:9091/graph" rel="noopener ugc nofollow" target="_blank"><em class="kp">http://localhost:9091/graph</em></a>并根据获得的指标制作图表。例如，一个通过参数<em class="kp"> http_in_count </em>计算我们对应用程序端点的调用次数的函数。</p><figure class="jz ka kb kc fd ij er es paragraph-image"><div class="er es kq"><img src="../Images/e5226a06f9d89a689161481ba39b464e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/0*Wc5LSpWbBZ44fAav.png"/></div></figure><p id="f3cc" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">如你所见，这真的很简单。使用InspectIT执行应用程序性能管理任务不再是借口。这只是几个例子，但你可以通过不同的出口商做得更多。</p></div></div>    
</body>
</html>