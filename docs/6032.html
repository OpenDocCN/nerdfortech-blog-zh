<html>
<head>
<title>A “reference” for Python Variables</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python变量的“参考”</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/a-reference-for-python-variables-53fafa97186f?source=collection_archive---------5-----------------------#2021-12-21">https://medium.com/nerd-for-tech/a-reference-for-python-variables-53fafa97186f?source=collection_archive---------5-----------------------#2021-12-21</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="c26a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果你期待我的VirtualBox系列的后续，我很抱歉。我有这方面的工作代码，但它不符合我的发布标准，我一直忙着清理它。相反，在本文中，我将讨论Python的一些特性，这些特性确实困扰了许多新的Python开发人员(包括我自己)。</p><p id="b639" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">经典编程语言通常通过两种方法之一将变量传递给函数:按值传递或按引用传递。按值传递，在函数复制变量并将新值提供给函数时发生。这样做的好处是，对方法中变量的任何修改都不会在函数之外产生任何所谓的“副作用”。对象和更复杂类型的数据结构通常是按引用传递的。按引用传递意味着将变量的“引用”或指针传递给函数，函数对该引用执行的任何操作都会影响对象的一个副本(可能会被其他代码段使用)，因此这种数据传递模式可能会有外部副作用。有时，这些外部副作用是一个预期的特性，引用传递更有效。</p><p id="f733" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Python做事情的方式与更经典的语言不同(但仍然相似),这些差异可能会引起混淆。让我举几个例子来说明:</p><figure class="jd je jf jg fd jh"><div class="bz dy l di"><div class="ji jj l"/></div></figure><p id="677d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">希望上面的例子不会让任何人太惊讶。传递一个简单的值，比如一个整数(或者其他值，比如bool和str ),实际上类似于按值传递。</p><p id="620a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们改变一些小事情，看看会发生什么:</p><figure class="jd je jf jg fd jh"><div class="bz dy l di"><div class="ji jj l"/></div></figure><p id="8e99" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">再次，希望这是相当直截了当的。我们引用了一个“全局”变量(同时激怒了编程之神)，突然我们看到了调用我们的测试方法的副作用。不过，希望这有直观的意义。我们明确地声明我们希望对一个“全局”(对我们来说)变量执行操作，并且我们自然地期望那些变化将在我们当前的“局部”范围之外持续。</p><p id="da77" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在我们开始尝试得出任何结论之前，让我们再看一个方法:</p><figure class="jd je jf jg fd jh"><div class="bz dy l di"><div class="ji jj l"/></div></figure><p id="645f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这个结果可能会让一些人感到惊讶。显然不是所有的东西都是按价值传递的。与我们前面的简单内置数据类型的例子不同，我们的自定义对象被有效地“按引用”传递。当您意识到像“str”(字符串)这样的“简单”数据类型不仅仅是字符串，而且有内置方法(如“lower”、“strip”等)时，这可能看起来更奇怪。)，所以即使这些“简单”的类型也是有效的对象。然而，这并不是故事的结尾。人们可能会合理地得出这样的结论:只有Python自定义对象才会有这种行为，或者内置对象总是按引用传递。让我们再看几个例子:</p><figure class="jd je jf jg fd jh"><div class="bz dy l di"><div class="ji jj l"/></div></figure><figure class="jd je jf jg fd jh"><div class="bz dy l di"><div class="ji jj l"/></div></figure><p id="04fb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">从上面两个例子可以看出，Python的dict和list内置看起来都是按引用传递的。不管出于什么原因(将在下面进一步解释)，修改这些子元素都有副作用。对于我的下一个技巧，看一下这两个例子，并将它们与上面的结果进行比较:</p><figure class="jd je jf jg fd jh"><div class="bz dy l di"><div class="ji jj l"/></div></figure><figure class="jd je jf jg fd jh"><div class="bz dy l di"><div class="ji jj l"/></div></figure><p id="04d6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">等等什么！？这看起来非常令人困惑。为什么这些例子没有引起全球性的副作用，但前两个却引起了？在我们深入研究这里到底发生了什么之前，让我们从一个通用的经验法则开始，您可以使用它来防止Python中的行为混乱:</p><p id="b266" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在Python中，如果您试图替换或修改传入的对象，此操作不会有任何全局副作用。但是，如果对象是可下标的(它有子项，如字典、列表或对象属性)，修改这些可下标的子项将会产生全局副作用。</p><p id="7559" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们拉开帷幕，以便理解为什么会出现这种“奇怪”的行为。当你将一个变量传递给一个方法时，Python实际上创建了一个新的局部变量，并传递给它一个对传入对象的引用(不管是什么类型)。如果您随后试图覆盖该变量的内容，您实际上所做的是覆盖本地<strong class="ih hj"> <em class="jk">引用</em> </strong>和<strong class="ih hj"> <em class="jk">而不是</em> </strong>的实际值。一旦你意识到这一点，一切都开始变得有意义了。在可下标项目的情况下，我们覆盖了可下标属性所指向的引用，但是由于这个引用是在一个对象内部，Python首先解析这个引用，然后覆盖子项引用，因此导致了一个全局副作用。我知道这令人困惑，所以让我用更多的例子来演示。</p><p id="2607" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Python提供了一个内置的方法调用“id ”,它返回一个整数，表示变量引用的内存地址。让我们利用这一点来理解一个类似于我们第一个案例的例子:</p><figure class="jd je jf jg fd jh"><div class="bz dy l di"><div class="ji jj l"/></div></figure><p id="9f60" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">正如您在示例中看到的，<strong class="ih hj"> var1 </strong>通过保存对与<strong class="ih hj"> a </strong>相同位置的引用开始。然而，通过给它赋值<strong class="ih hj"> ten </strong>，我们并没有真正给它赋值，而是实际上给<strong class="ih hj"> var1 </strong>赋值了<strong class="ih hj"> ten </strong>所指向的引用。因此，这组操作不会改变<strong class="ih hj"> a </strong>所指向的引用的值。</p><p id="3bd5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在让我们来看一个可下标的例子:</p><figure class="jd je jf jg fd jh"><div class="bz dy l di"><div class="ji jj l"/></div></figure><p id="61c6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">从上述结果可以看出，发生了以下一系列事件:</p><ol class=""><li id="526d" class="jl jm hi ih b ii ij im in iq jn iu jo iy jp jc jq jr js jt bi translated">对<strong class="ih hj"> a </strong>的引用被传递给<strong class="ih hj">测试</strong>并存储在<strong class="ih hj">变量1 </strong>中。</li><li id="b201" class="jl jm hi ih b ii ju im jv iq jw iu jx iy jy jc jq jr js jt bi translated"><strong class="ih hj"> test </strong>试图将“11”的值赋给字典键<strong class="ih hj"> var1 </strong> … <strong class="ih hj"> <em class="jk">中的<strong class="ih hj"> test </strong>除了</em> </strong>我们现在知道这个故事还有更多。下面是实际发生的情况:<br/> 2a。Python将引用解析为<strong class="ih hj"> var1 </strong>(因此也解析为<strong class="ih hj"> a </strong>)。<br/> 2b。Python遵循底层的日期结构来引用<strong class="ih hj"> var1 </strong> / <strong class="ih hj"> a </strong>到<strong class="ih hj">测试</strong>中的内容。<br/> 2c。Python将值“11”存储在内存中，并获取相关联的引用。<br/> 2d。Python将这个“11”引用复制到旧引用之上，旧引用是由<strong class="ih hj">var1[“test”]</strong>和<strong class="ih hj">a[“test”]</strong>指向的，因此导致了观察到的全局副作用。</li><li id="c90a" class="jl jm hi ih b ii ju im jv iq jw iu jx iy jy jc jq jr js jt bi translated">胡言乱语。突然，结果变得有意义了。</li></ol><p id="ab13" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">希望这篇文章消除了很多关于Python变量传递行为的困惑。在结束本文之前，我想为初学者介绍几个相关的陷阱。</p><p id="aac9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">将Python字典传递给一个方法，然后希望在字典上执行操作而不引起任何全局副作用，这是相对常见的。一种简单的方法可能如下所示:</p><figure class="jd je jf jg fd jh"><div class="bz dy l di"><div class="ji jj l"/></div></figure><p id="3102" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如你所见，我们称之为”。copy()"方法来克隆我们的字典，然后修改克隆，一切都按预期工作。我们能够成功地修改我们克隆的字典，而不影响原始传入的字典。一切都很好，对吗？嗯，不完全是…让我们看另一个例子来看这个微妙的问题:</p><figure class="jd je jf jg fd jh"><div class="bz dy l di"><div class="ji jj l"/></div></figure><p id="f1c2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果上面发生的事情不是很明显，让我解释一下。的”。Python中对象上的copy()”方法做的是所谓的“浅层复制”。也就是说，它只创建可下标项目中第一层的副本。对于任何“更深”的东西，它只是复制现有的引用，这将导致对原始对象的副作用。</p><p id="8e03" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在大多数情况下，试图在方法中克隆一个对象表明Python中的编程模式不好。通过创建一个全新的对象，并在循环或递归原始对象时将值复制到这个新对象中，通常会更好。也就是说，如果您确实需要完全克隆传递给方法的对象，有一个解决方案。这个解决方案是使用“copy.deepcopy”方法。下面是与上面相同的例子，但是使用这个方法来完全克隆我们的字典，得到预期的结果:</p><figure class="jd je jf jg fd jh"><div class="bz dy l di"><div class="ji jj l"/></div></figure><p id="bb5d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果您过去发现Python变量传递令人困惑，希望这篇文章对您有所启发。</p></div></div>    
</body>
</html>