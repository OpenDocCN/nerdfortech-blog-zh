<html>
<head>
<title>Perfect Squares — Python Program</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">完美正方形——Python程序</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/perfect-squares-python-program-b82fff87916f?source=collection_archive---------12-----------------------#2021-05-07">https://medium.com/nerd-for-tech/perfect-squares-python-program-b82fff87916f?source=collection_archive---------12-----------------------#2021-05-07</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/468fc1627d603eb0222b2b6ac6cfbdb9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MdiHDR06_7A9kmdS5Be8Kg.jpeg"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated"><a class="ae iu" href="https://unsplash.com/@sharonmccutcheon?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Sharon McCutcheon </a>在<a class="ae iu" href="https://unsplash.com/s/photos/squares?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><h2 id="8a92" class="iv iw hi bd ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js bi translated">问题:</h2><p id="68d9" class="pw-post-body-paragraph jt ju hi jv b jw jx jy jz ka kb kc kd jg ke kf kg jk kh ki kj jo kk kl km kn hb bi translated">给定一个整数<code class="du ko kp kq kr b">n</code>，返回<em class="ks">与</em>和<code class="du ko kp kq kr b">n</code>之和的最小的完美平方数。</p><p id="017d" class="pw-post-body-paragraph jt ju hi jv b jw kt jy jz ka ku kc kd jg kv kf kg jk kw ki kj jo kx kl km kn hb bi translated"><strong class="jv hj">完美平方</strong>是整数的平方；换句话说，它是某个整数与自身的乘积。例如，<code class="du ko kp kq kr b">1</code>、<code class="du ko kp kq kr b">4</code>、<code class="du ko kp kq kr b">9</code>和<code class="du ko kp kq kr b">16</code>是完美的正方形，而<code class="du ko kp kq kr b">3</code>和<code class="du ko kp kq kr b">11</code>不是。</p><h2 id="aff8" class="iv iw hi bd ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js bi translated">方法:</h2><p id="7eb3" class="pw-post-body-paragraph jt ju hi jv b jw jx jy jz ka kb kc kd jg ke kf kg jk kh ki kj jo kk kl km kn hb bi translated">强力方法建议使用递归函数来寻找所有完美平方的组合，这些完美平方的总和达到目标。然后找出有最小长度的组合的长度。但这只对少数人有效。对于更大的数字，它将抛出TLE。</p><p id="0198" class="pw-post-body-paragraph jt ju hi jv b jw kt jy jz ka ku kc kd jg kv kf kg jk kw ki kj jo kx kl km kn hb bi translated">我们使用自顶向下的方法来解决这个问题。我们从给定的数字开始，一直减去小于这个数字的完美平方。我们这样做，直到我们达到零。我们以12为例。所以小于12的完美平方是1，4，9。所以在任何时候，我们都可以把数字减少1，4或者9。这个过程将生成下面的决策树。</p><figure class="kz la lb lc fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ky"><img src="../Images/b8905cb8cf75ce85c2683b54b3295530.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*S4tgTSmnftRwbONZbnmBXQ.png"/></div></div></figure><p id="40a5" class="pw-post-body-paragraph jt ju hi jv b jw kt jy jz ka ku kc kd jg kv kf kg jk kw ki kj jo kx kl km kn hb bi translated">我们试着在每一层看看我们是否达到了一个数字，要么是零，要么是一个完美的平方。</p><figure class="kz la lb lc fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ld"><img src="../Images/42f18c1bc799ddd5e3a01806e3d463cb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0B-PASVBQfD2PUE0E4CeMg.png"/></div></div></figure><p id="7920" class="pw-post-body-paragraph jt ju hi jv b jw kt jy jz ka ku kc kd jg kv kf kg jk kw ki kj jo kx kl km kn hb bi translated">在生成的树中，我们注意到我们有许多重复的子问题。</p><figure class="kz la lb lc fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es le"><img src="../Images/43dbd653b60d33656e9e67cd98c8b31a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3wCM0u5Ini2Uqs-N_FNO6g.png"/></div></div></figure><p id="b856" class="pw-post-body-paragraph jt ju hi jv b jw kt jy jz ka ku kc kd jg kv kf kg jk kw ki kj jo kx kl km kn hb bi translated">如果我们去除子问题，我们得到下面的树。</p><figure class="kz la lb lc fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lf"><img src="../Images/d68ff60d9fff036cd4da88a2c490923c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QZhZisvUgdAEaEOIl9vHGA.png"/></div></div></figure><p id="33de" class="pw-post-body-paragraph jt ju hi jv b jw kt jy jz ka ku kc kd jg kv kf kg jk kw ki kj jo kx kl km kn hb bi translated">如果我们在任何水平上得到一个零或完美的平方时就中断这个过程，这将进一步减少计算量。</p><figure class="kz la lb lc fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lg"><img src="../Images/5e051c03c69be60fa99cc532e2136798.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sOOad1WPwEXYmbcE2Is0KA.png"/></div></div></figure><h2 id="7706" class="iv iw hi bd ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js bi translated">代码实现:</h2><pre class="kz la lb lc fd lh kr li lj aw lk bi"><span id="d349" class="iv iw hi kr b fi ll lm l ln lo">import math, collections<br/>def numSquares(n):<br/>    pf_sq = set([x**2 for x in range(1, math.ceil(n ** 0.5) + 1)])<br/>    if n in pf_sq:<br/>        return 1<br/>    seen = {n}<br/>    queue = collections.deque([(n, 0)])<br/>    <br/>    while queue:<br/>        target, count = queue.popleft()<br/>        if target == 0: <br/>            return count<br/>        if target in pf_sq: <br/>            return count + 1<br/>        for square in pf_sq:<br/>            new_target = target - square<br/>            if new_target == 0: <br/>                return count + 1<br/>            if new_target in pf_sq: <br/>                return count + 2<br/>            if new_target not in seen and new_target &gt; 0:<br/>                queue.append((new_target, count + 1))<br/>                seen.add(new_target)</span><span id="2f57" class="iv iw hi kr b fi lp lm l ln lo">print(numSquares(11))</span></pre><p id="724c" class="pw-post-body-paragraph jt ju hi jv b jw kt jy jz ka ku kc kd jg kv kf kg jk kw ki kj jo kx kl km kn hb bi translated">在上面的解决方案中，我们使用了一个队列来实现BFS遍历。</p><p id="74de" class="pw-post-body-paragraph jt ju hi jv b jw kt jy jz ka ku kc kd jg kv kf kg jk kw ki kj jo kx kl km kn hb bi translated">上例迭代中的队列值:</p><pre class="kz la lb lc fd lh kr li lj aw lk bi"><span id="07a4" class="iv iw hi kr b fi ll lm l ln lo">(12,0)<br/>(11,1), (8,1), (3,1)<br/>(8,1), (3,1), (10,2), (7,2), (2,2), (4,2)</span></pre><p id="cbf7" class="pw-post-body-paragraph jt ju hi jv b jw kt jy jz ka ku kc kd jg kv kf kg jk kw ki kj jo kx kl km kn hb bi translated">seen (set)是为了避免重复计算。</p><h2 id="142d" class="iv iw hi bd ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js bi translated">方法2:</h2><figure class="kz la lb lc fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lq"><img src="../Images/968818b93b86825eea1d834ba090ff88.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-NuIcf7YsvmuVgb3z0Y-Uw.png"/></div></div></figure><p id="7dd1" class="pw-post-body-paragraph jt ju hi jv b jw kt jy jz ka ku kc kd jg kv kf kg jk kw ki kj jo kx kl km kn hb bi translated">在这种方法中，我们从[0]，[1，4，9]，[2，5，10，5，8，10]开始构建，直到达到目标。</p><h2 id="37d0" class="iv iw hi bd ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js bi translated">方法2: DP</h2><p id="d5ed" class="pw-post-body-paragraph jt ju hi jv b jw jx jy jz ka kb kc kd jg ke kf kg jk kh ki kj jo kk kl km kn hb bi translated">在这种情况下，我们从较小的目标建立目标。</p><pre class="kz la lb lc fd lh kr li lj aw lk bi"><span id="ffe2" class="iv iw hi kr b fi ll lm l ln lo">def numSquares(n):<br/>    dp = [n]*(n+1)<br/>    dp[0] = 0<br/>    dp[1] = 1<br/>    <br/>    for target in range(2, n+1):<br/>        tmp = int(math.sqrt(target))<br/>        for s in range(tmp, 0, -1):<br/>            sq = s*s<br/>            dp[target] = min(dp[target], dp[target - sq] + 1)<br/>            if dp[target] == 2 or dp[target] == 1: <br/>                break<br/>    return dp[n]</span></pre><p id="df31" class="pw-post-body-paragraph jt ju hi jv b jw kt jy jz ka ku kc kd jg kv kf kg jk kw ki kj jo kx kl km kn hb bi translated">编码快乐！！</p></div></div>    
</body>
</html>