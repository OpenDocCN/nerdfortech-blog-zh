<html>
<head>
<title>Build Promotion with OneDev</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用 OneDev 构建促销</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/build-promotion-with-onedev-ce6c275aa1b8?source=collection_archive---------5-----------------------#2022-01-21">https://medium.com/nerd-for-tech/build-promotion-with-onedev-ce6c275aa1b8?source=collection_archive---------5-----------------------#2022-01-21</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/699da6feb77114ec2ae1f1962c69fe6e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wx_ecTdMIqmvipLg-N-BQA.jpeg"/></div></div></figure><p id="0eb3" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在 OneDev 中，您可以请求好的/经过验证的构建在管道中进一步处理。这是构建升级，可以从构建详细信息页面完成，如下所示:</p><figure class="jp jq jr js fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es jo"><img src="../Images/584ab96f15c508deee732b1aceac30e3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BwnWbq7MghUDX0rAGueDKQ.png"/></div></div></figure><p id="a4eb" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">上面的升级菜单列出了所有依赖于当前构建的下游作业。作业依赖可以在作业的<em class="jt">依赖&amp;服务</em>部分定义。对于上面的例子，部署作业依赖于构建作业来检索其发布的工件，以便进一步处理。过度简化的构建规范如下(需要 OneDev 6.2.3 或更高版本):</p><pre class="jp jq jr js fd ju jv jw jx aw jy bi"><span id="d75e" class="jz ka hi jv b fi kb kc l kd ke">version: 15<br/>jobs:<br/>- name: Build<br/>  steps:<br/>  - !CommandStep<br/>    name: build<br/>    runInContainer: true<br/>    image: alpine<br/>    interpreter: !DefaultInterpreter<br/>      commands:<br/>      - '# build our awesome app'<br/>      - echo <a class="ae kf" href="http://twitter.com/build_number" rel="noopener ugc nofollow" target="_blank">@build_number</a>@ &gt; app.txt<br/>    useTTY: false<br/>    condition: ALL_PREVIOUS_STEPS_WERE_SUCCESSFUL<br/>  - !PublishArtifactStep<br/>    name: publish<br/>    artifacts: app.txt<br/>    condition: ALL_PREVIOUS_STEPS_WERE_SUCCESSFUL<br/>  triggers:<br/>  - !BranchUpdateTrigger {}<br/>  retryCondition: never<br/>  maxRetries: 3<br/>  retryDelay: 30<br/>  cpuRequirement: 500<br/>  memoryRequirement: 256<br/>  timeout: 3600<br/>- name: Deploy<br/>  steps:<br/>  - !CommandStep<br/>    name: deploy<br/>    runInContainer: true<br/>    image: alpine<br/>    interpreter: !DefaultInterpreter<br/>      commands:<br/>      - '# let''s verify the app content'<br/>      - cat app.txt<br/>      - '# continue to deploy the app'<br/>    useTTY: false<br/>    condition: ALL_PREVIOUS_STEPS_WERE_SUCCESSFUL<br/>  jobDependencies:<br/>  - jobName: Build<br/>    requireSuccessful: true<br/>    artifacts: '**'<br/>  retryCondition: never<br/>  maxRetries: 3<br/>  retryDelay: 30<br/>  cpuRequirement: 500<br/>  memoryRequirement: 256<br/>  timeout: 3600</span></pre><p id="b2e2" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">您可能想知道为什么不像下面这样直接从提交中运行部署作业:</p><figure class="jp jq jr js fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es jo"><img src="../Images/29046af3f1ddbdfb5b43f171e97cc4eb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zLTFlxo_evD-MPAF56NUEA.png"/></div></div></figure><p id="a758" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">原因是在这里运行部署作业会触发一个新的管道。构建作业将在此管道中重新运行，部署作业将从这个新生成的构建中检索工件，该构建仍未经过验证。OTOH，升级一个构建继续该构建的管道。上面的构建规范示例将展示这种差异:</p><ol class=""><li id="a0d7" class="kg kh hi is b it iu ix iy jb ki jf kj jj kk jn kl km kn ko bi translated">如果从现有版本升级，部署作业将通过检索的 app.txt 打印升级版本的版本号</li><li id="6c62" class="kg kh hi is b it kp ix kq jb kr jf ks jj kt jn kl km kn ko bi translated">如果直接从提交运行部署作业，它将打印新生成的构建作业的构建号</li></ol><p id="6fee" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">仅此而已。感谢阅读！</p></div></div>    
</body>
</html>