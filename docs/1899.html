<html>
<head>
<title>JSON Serialization in Ktor</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Ktor 中的 JSON 序列化</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/json-serialization-for-ktor-feae3d06eadb?source=collection_archive---------4-----------------------#2021-04-12">https://medium.com/nerd-for-tech/json-serialization-for-ktor-feae3d06eadb?source=collection_archive---------4-----------------------#2021-04-12</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/adf7b1dbef66248abbf89505b5e29037.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*eG1hacVUOq3Rob9U.png"/></div></div></figure><h1 id="94fe" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">介绍</h1><p id="5b38" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">作为我的系列“<a class="ae km" rel="noopener" href="/p/87f814e3dffd">一个固执己见的 Kotlin 后端服务</a>”的一部分，我检查了序列化/反序列化 JSON 有效负载的不同方法。</p><p id="c5f2" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">根据 https://ktor.io/docs/serialization.html<a class="ae km" href="https://ktor.io/docs/serialization.html" rel="noopener ugc nofollow" target="_blank">的说法</a>这些是受支持的转换器:</p><ol class=""><li id="7784" class="ks kt hi jq b jr kn jv ko jz ku kd kv kh kw kl kx ky kz la bi translated"><a class="ae km" href="https://github.com/google/gson" rel="noopener ugc nofollow" target="_blank"> Gson </a></li><li id="76b6" class="ks kt hi jq b jr lb jv lc jz ld kd le kh lf kl kx ky kz la bi translated"><a class="ae km" href="https://github.com/FasterXML/jackson" rel="noopener ugc nofollow" target="_blank">杰克逊</a></li><li id="ad5f" class="ks kt hi jq b jr lb jv lc jz ld kd le kh lf kl kx ky kz la bi translated"><a class="ae km" href="https://github.com/Kotlin/kotlinx.serialization" rel="noopener ugc nofollow" target="_blank"> kotlinx.serialization </a></li></ol><p id="c87f" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">我测试了#1 和#3，因为我喜欢时不时的挑战，所以我把<a class="ae km" href="https://github.com/square/moshi" rel="noopener ugc nofollow" target="_blank">魔石</a>放入其中。我没有提到杰克逊是因为…为什么不呢；-).</p><p id="811e" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">我的测试很简单。我想序列化/反序列化此数据结构:</p><pre class="lg lh li lj fd lk ll lm ln aw lo bi"><span id="0f3f" class="lp ir hi ll b fi lq lr l ls lt">data class Customer(<br/>    var customerUUID: String,<br/>    var createdAt: Instant,<br/>    var modified: Instant,<br/>    var firstName: String,<br/>    var lastName: String,<br/>    var language: Language,<br/>    var account: Account,<br/>)</span><span id="be6b" class="lp ir hi ll b fi lu lr l ls lt">data class Account(<br/>    var accountUUID: String,<br/>    var createdAt: Instant,<br/>    var modified: Instant,<br/>    var status: AccountStatus<br/>)</span></pre><p id="ece9" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">序列化部分检索一个客户列表(ArrayList <customer>)，每个客户引用一个 account -&gt; GET。</customer></p><p id="87a9" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">反序列化部分首先创建一个帐户，然后是引用该帐户的客户-&gt; POST。</p><h1 id="f4bd" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">间奏曲</h1><p id="9656" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">自定义转换器可以很容易地注册到 Ktor。它们只是另一个<a class="ae km" href="https://ktor.io/docs/features.html" rel="noopener ugc nofollow" target="_blank"> Ktor 特性</a>，如路由、日志或错误处理:</p><figure class="lg lh li lj fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lv"><img src="../Images/d910085e0c2df3908d6324767c69d5e4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1222/format:webp/1*avIZNde5OpGpaHC31H3dYg.png"/></div></div></figure><p id="35b8" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">(在其他框架中，一个特性被称为中间件、过滤器或委托处理程序)</p><p id="a5b4" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">可以使用安装功能来安装功能。出于我们的目的，我们安装了一个<a class="ae km" href="https://api.ktor.io/1.5.3/io.ktor.features/-content-negotiation/index.html" rel="noopener ugc nofollow" target="_blank"> <em class="lw">内容协商</em> </a>特性，如下所示:</p><pre class="lg lh li lj fd lk ll lm ln aw lo bi"><span id="61a4" class="lp ir hi ll b fi lq lr l ls lt">install(ContentNegotiation) {<br/>   register(ContentType.Application.Json, CustomJsonConverter())<br/>   register(ContentType.Application.Xml, CustomXmlConverter()) <br/>}</span></pre><p id="2d61" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">所有三个经过测试的转换器都具有扩展功能来简化注册:</p><pre class="lg lh li lj fd lk ll lm ln aw lo bi"><span id="6cc6" class="lp ir hi ll b fi lq lr l ls lt">install(ContentNegotiation) {<br/>   gson()                  // Gson converter<br/>   json()                  // kotlinx.serialization converter<br/>   moshi { }               // Moshi converter<br/>}</span></pre><p id="d2c1" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">当然，你一次只能安装其中一个。</p><h1 id="0977" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">Gson</h1><h2 id="1665" class="lp ir hi bd is lx ly lz iw ma mb mc ja jz md me je kd mf mg ji kh mh mi jm mj bi translated">属国</h2><p id="9ad0" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">将此依赖项添加到您的 Gradle 构建文件中:</p><pre class="lg lh li lj fd lk ll lm ln aw lo bi"><span id="b946" class="lp ir hi ll b fi lq lr l ls lt">implementation(“io.ktor:ktor-gson:$ktor_version”)</span></pre><h2 id="2a10" class="lp ir hi bd is lx ly lz iw ma mb mc ja jz md me je kd mf mg ji kh mh mi jm mj bi translated">装置</h2><p id="c057" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">如上所述，这就是安装 GSON 转换器所需的全部内容:</p><pre class="lg lh li lj fd lk ll lm ln aw lo bi"><span id="a489" class="lp ir hi ll b fi lq lr l ls lt">install(ContentNegotiation) {<br/>   gson()<br/>}</span></pre><p id="0baa" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">通过<em class="lw"> gson </em>功能，您可以访问<a class="ae km" href="https://www.javadoc.io/doc/com.google.code.gson/gson/latest/com.google.gson/com/google/gson/GsonBuilder.html" rel="noopener ugc nofollow" target="_blank"> GsonBuilder </a>来定制转换器:</p><pre class="lg lh li lj fd lk ll lm ln aw lo bi"><span id="28af" class="lp ir hi ll b fi lq lr l ls lt">install(ContentNegotiation) {<br/>   gson {<br/>      setPrettyPrinting()<br/>      disableHtmlEscaping()<br/>      registerTypeAdapter(yourClass, yourCustomAdapter)<br/>   }<br/>}</span></pre><h2 id="b00b" class="lp ir hi bd is lx ly lz iw ma mb mc ja jz md me je kd mf mg ji kh mh mi jm mj bi translated">用户化</h2><p id="91d9" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">运行开箱即用的测试。我为客户/账户数据结构得到了这个:</p><pre class="lg lh li lj fd lk ll lm ln aw lo bi"><span id="221d" class="lp ir hi ll b fi lq lr l ls lt">[<br/>    {<br/>        "customerUUID": "bbbe4f11-c36d-49cd-a031-787d6559d3ea",<br/>        <strong class="ll hj">"createdAt": {<br/>            "seconds": 1617802016,<br/>            "nanos": 609375000<br/>        },</strong><br/>        <strong class="ll hj">"modified": {<br/>            "seconds": 1617802016,<br/>            "nanos": 609375000<br/>        },</strong><br/>        "firstName": "Emanuel",<br/>        "lastName": "Moecklin",<br/>        "language": "en",<br/>        "account": {<br/>            "accountUUID": "20836570-d4ef-420e-b500-7b7f6516e1a8",<br/>            "createdAt": {<br/>                "seconds": 1617802016,<br/>                "nanos": 415274000<br/>            },<br/>            "modified": {<br/>                "seconds": 1617903421,<br/>                "nanos": 798094000<br/>            },<br/>            "status": "Created"<br/>        }<br/>    },</span></pre><p id="3408" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">正如你所看到的，即时对象被序列化了，但是以一种非常规的方式。为了解决这个问题，我添加了一个自定义适配器:</p><pre class="lg lh li lj fd lk ll lm ln aw lo bi"><span id="9cd3" class="lp ir hi ll b fi lq lr l ls lt">object <strong class="ll hj">GsonInstantAdapter</strong>: TypeAdapter&lt;Instant&gt;() {<br/>    override fun write(writer: JsonWriter, value: Instant?) {<br/>        runCatching <strong class="ll hj">{<br/>            </strong>writer.value(value.toString())<br/>        <strong class="ll hj">}</strong>.onFailure <strong class="ll hj">{<br/>            </strong>throw IllegalArgumentException(it.message)<br/>        <strong class="ll hj">}<br/>    </strong>}<br/><br/>    override fun read(reader: JsonReader): Instant? {<br/>        return runCatching <strong class="ll hj">{<br/>            </strong>Instant.parse(reader.nextString())<br/>        <strong class="ll hj">}</strong>.throwOnFailure()<br/>    }<br/>}</span></pre><p id="498b" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">请注意，我使用了<a class="ae km" href="https://github.com/michaelbull/kotlin-result" rel="noopener ugc nofollow" target="_blank">https://github.com/michaelbull/kotlin-result</a>来处理序列化/反序列化的结果(<em class="lw"> runCatching </em>、<em class="lw"> onFailure </em>)。</p><p id="ef0b" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated"><em class="lw"> throwOnFailure </em>是我结合<a class="ae km" href="https://github.com/valiktor/valiktor" rel="noopener ugc nofollow" target="_blank"> Valiktor </a>使用的扩展函数(见我关于对象验证的文章:<a class="ae km" rel="noopener" href="/nerd-for-tech/object-validation-in-kotlin-c7e02b5dabc">https://medium . com/nerd-for-tech/object-validation-in-kot Lin-c 7 e 02 b 5 dabc</a>)。下面的代码省略了 Valiktor 部分，完整的代码将在我的主要文章“一个固执己见的 Kotlin 后端服务”中。</p><pre class="lg lh li lj fd lk ll lm ln aw lo bi"><span id="ba00" class="lp ir hi ll b fi lq lr l ls lt">fun &lt;V&gt; Result&lt;V, Throwable&gt;.throwOnFailure(): V? {<br/>    <em class="lw">onFailure </em>{<br/>        val message = it.message ?: it.<em class="lw">javaClass</em>.<em class="lw">simpleName<br/>        </em>throw IllegalArgumentException(message)<br/>    }<br/>    return component1()<br/>}</span></pre><p id="4e8f" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">现在我们需要向<a class="ae km" href="https://www.javadoc.io/doc/com.google.code.gson/gson/latest/com.google.gson/com/google/gson/GsonBuilder.html" rel="noopener ugc nofollow" target="_blank"> GsonBuilder </a>注册适配器:</p><pre class="lg lh li lj fd lk ll lm ln aw lo bi"><span id="bd66" class="lp ir hi ll b fi lq lr l ls lt">gson <strong class="ll hj">{<br/>    </strong>setPrettyPrinting()<br/>    disableHtmlEscaping()<br/><strong class="ll hj">    registerTypeAdapter(Instant::class.java, GsonInstantAdapter)<br/>}</strong></span></pre><p id="0954" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">结果是:</p><pre class="lg lh li lj fd lk ll lm ln aw lo bi"><span id="b58a" class="lp ir hi ll b fi lq lr l ls lt">"createdAt": "2021-04-09T19:55:13.571019Z",<br/>"modified": "2021-04-09T20:22:58.167671Z",</span></pre><h1 id="ad7c" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">kotlinx .序列化</h1><h2 id="f471" class="lp ir hi bd is lx ly lz iw ma mb mc ja jz md me je kd mf mg ji kh mh mi jm mj bi translated">属国</h2><p id="ec27" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">Kotlin 自己的序列化插件需要这样配置:</p><pre class="lg lh li lj fd lk ll lm ln aw lo bi"><span id="bc40" class="lp ir hi ll b fi lq lr l ls lt">plugins {<br/>    kotlin("plugin.serialization") version "1.4.32"<br/>}</span></pre><p id="1c8e" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">它也需要这种依赖性:</p><pre class="lg lh li lj fd lk ll lm ln aw lo bi"><span id="8aa4" class="lp ir hi ll b fi lq lr l ls lt">implementation("io.ktor:ktor-serialization:$ktor_version")</span></pre><h2 id="f5db" class="lp ir hi bd is lx ly lz iw ma mb mc ja jz md me je kd mf mg ji kh mh mi jm mj bi translated">装置</h2><pre class="lg lh li lj fd lk ll lm ln aw lo bi"><span id="2ca6" class="lp ir hi ll b fi lq lr l ls lt">install(ContentNegotiation) {<br/>        json(Json {<br/>            prettyPrint = true<br/>            isLenient = true<br/>        })<br/>   }</span></pre><h2 id="9e14" class="lp ir hi bd is lx ly lz iw ma mb mc ja jz md me je kd mf mg ji kh mh mi jm mj bi translated">用户化</h2><p id="a381" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">运行此命令将引发一个异常:</p><blockquote class="mk ml mm"><p id="a0cb" class="jo jp lw jq b jr kn jt ju jv ko jx jy mn kp kb kc mo kq kf kg mp kr kj kk kl hb bi translated">kot linx . serialization . serialization exception:找不到类“Customer”的序列化程序。将该类标记为<a class="ae km" href="http://twitter.com/Serializable" rel="noopener ugc nofollow" target="_blank"> @Serializable </a>或显式提供序列化程序。</p></blockquote><p id="f5fb" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">所以我们给每个数据类添加了一个<a class="ae km" href="http://twitter.com/Serializable" rel="noopener ugc nofollow" target="_blank"> @Serializable </a>注释:</p><pre class="lg lh li lj fd lk ll lm ln aw lo bi"><span id="36ff" class="lp ir hi ll b fi lq lr l ls lt">@Serializable<br/>data class Account(</span><span id="b94b" class="lp ir hi ll b fi lu lr l ls lt">@Serializable<br/>data class Customer(</span></pre><p id="59da" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">现在我们得到一个编译错误:</p><blockquote class="mk ml mm"><p id="70b3" class="jo jp lw jq b jr kn jt ju jv ko jx jy mn kp kb kc mo kq kf kg mp kr kj kk kl hb bi translated">未找到类型为“Instant？”的序列化程序。若要将上下文序列化程序用作后备，请用@Contextual 显式批注类型或属性</p></blockquote><p id="f739" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">为了解决这个问题，我为 Instant 类编写了一个序列化程序(类似 Gson):</p><pre class="lg lh li lj fd lk ll lm ln aw lo bi"><span id="f960" class="lp ir hi ll b fi lq lr l ls lt">@OptIn(ExperimentalSerializationApi::class)<br/>@Serializer(forClass = Instant::class)<br/>object InstantSerializer : KSerializer&lt;Instant&gt; {<br/>    override fun deserialize(decoder: Decoder): Instant  <br/>        = Instant.parse(decoder.decodeString())<br/><br/>    override fun serialize(encoder: Encoder, value: Instant) {<br/>        encoder.encodeString(value.toString())<br/>    }<br/>}</span></pre><p id="bc68" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">要注册序列化程序，每个属性都需要进行如下注释:</p><pre class="lg lh li lj fd lk ll lm ln aw lo bi"><span id="9767" class="lp ir hi ll b fi lq lr l ls lt">@Serializable(with = InstantSerializer::class)<br/>var createdAt: Instant?,</span><span id="d883" class="lp ir hi ll b fi lu lr l ls lt">@Serializable(with = InstantSerializer::class)<br/>var modifiedAt: Instant?,</span></pre><p id="2b09" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">或者，您可以将它添加到文件的顶部(如果您有多个属性，这样会更方便):</p><pre class="lg lh li lj fd lk ll lm ln aw lo bi"><span id="9d29" class="lp ir hi ll b fi lq lr l ls lt">@file:UseSerializers(InstantSerializer::class)</span></pre><p id="b453" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">第二个选项可用于注册多个适配器:</p><pre class="lg lh li lj fd lk ll lm ln aw lo bi"><span id="5c71" class="lp ir hi ll b fi lq lr l ls lt">@file:UseSerializers(InstantSerializer::class, AnotherSerializer::class)</span></pre><h1 id="6ceb" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">魔石</h1><p id="987e" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">Moshi 没有得到 Ktor 的官方支持，但是杰克逊支持，那么为什么不是杰克逊而是 Moshi 呢？答案很简单:我想要一个现代的库，具有简洁流畅的 API，并且明确支持 Kotlin。这两个库都是最重要的 Java 库，但是 Moshi 肯定有更好的 Kotlin 支持。</p><blockquote class="mk ml mm"><p id="14a1" class="jo jp lw jq b jr kn jt ju jv ko jx jy mn kp kb kc mo kq kf kg mp kr kj kk kl hb bi translated">Jackson 被称为“Java JSON 库”或“Java 的最佳 JSON 解析器”。或者简称为“JSON for Java”。</p></blockquote><p id="609a" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">(<a class="ae km" href="https://github.com/FasterXML/jackson" rel="noopener ugc nofollow" target="_blank">https://github.com/FasterXML/jackson</a>)</p><blockquote class="mk ml mm"><p id="ee8c" class="jo jp lw jq b jr kn jt ju jv ko jx jy mn kp kb kc mo kq kf kg mp kr kj kk kl hb bi translated">Moshi 是 Kotlin 的一个很棒的 JSON 库。它理解 Kotlin 的不可空类型和默认参数值。当你使用 Kotlin 和 Moshi 时，你可以使用 reflection，codegen，或者两者都用。</p></blockquote><p id="6e53" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">(<a class="ae km" href="https://github.com/square/moshi" rel="noopener ugc nofollow" target="_blank">https://github.com/square/moshi</a></p><h2 id="b8c3" class="lp ir hi bd is lx ly lz iw ma mb mc ja jz md me je kd mf mg ji kh mh mi jm mj bi translated">属国</h2><p id="6b47" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">设置 Moshi 不像其他两个库那样简单。TBH:制作这个作品是一个相当严峻的考验，所以让我来告诉你整个过程。</p><p id="3475" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">首先，添加标准依赖项:</p><pre class="lg lh li lj fd lk ll lm ln aw lo bi"><span id="3d44" class="lp ir hi ll b fi lq lr l ls lt">implementation("com.squareup.moshi:moshi:1.12.0")<br/>implementation("com.squareup.moshi:moshi-kotlin:1.12.0")</span></pre><p id="3a04" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">然后需要安装 Moshi 作为 Ktor 特性。我发现了这个连接莫希和 Ktor 的图书馆:【https://github.com/rharter/ktor-moshi<a class="ae km" href="https://github.com/rharter/ktor-moshi" rel="noopener ugc nofollow" target="_blank">。不幸的是，添加后我得到了一个异常:</a></p><blockquote class="mk ml mm"><p id="b13c" class="jo jp lw jq b jr kn jt ju jv ko jx jy mn kp kb kc mo kq kf kg mp kr kj kk kl hb bi translated">不允许在此调度程序上使用阻塞原语。请考虑改用异步通道或在 withContext(Dispatchers)中使用阻塞原语。IO)代替。</p></blockquote><p id="6b27" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">经过一些研究，我通过在调用线程之外运行一些转换代码来修复它:</p><figure class="lg lh li lj fd ij"><div class="bz dy l di"><div class="mq mr l"/></div></figure><p id="2cbd" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">添加此 Moshi 后，可以作为 Ktor 功能安装:</p><pre class="lg lh li lj fd lk ll lm ln aw lo bi"><span id="c6af" class="lp ir hi ll b fi lq lr l ls lt">install(ContentNegotiation) {<br/>    moshi {  }<br/>}</span></pre><p id="347f" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">当运行这个并尝试序列化时，我得到:</p><blockquote class="mk ml mm"><p id="20ad" class="jo jp lw jq b jr kn jt ju jv ko jx jy mn kp kb kc mo kq kf kg mp kr kj kk kl hb bi translated">无法序列化 Kotlin 类型客户。不使用 kotlin-reflect 的 Kotlin 类的反射序列化具有未定义和意外的行为。请使用 moshi-kotlin 工件中的 KotlinJsonAdapterFactory 或使用 moshi-kotlin-codegen 工件中的 code gen。</p></blockquote><p id="e379" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">经过一番挖掘，我发现有两种方法可以让 Moshi 自动创建适配器:</p><ol class=""><li id="dfbf" class="ks kt hi jq b jr kn jv ko jz ku kd kv kh kw kl kx ky kz la bi translated">反射</li><li id="1f1e" class="ks kt hi jq b jr lb jv lc jz ld kd le kh lf kl kx ky kz la bi translated">Codegen</li></ol><h2 id="88b9" class="lp ir hi bd is lx ly lz iw ma mb mc ja jz md me je kd mf mg ji kh mh mi jm mj bi translated">魔石反射</h2><p id="0403" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">顾名思义，它使用反射来生成适配器。你所需要做的就是添加<em class="lw"> KotlinJsonAdapterFactory </em>:</p><pre class="lg lh li lj fd lk ll lm ln aw lo bi"><span id="639e" class="lp ir hi ll b fi lq lr l ls lt"><em class="lw">moshi </em>{<br/>    addLast(KotlinJsonAdapterFactory())<br/>}</span></pre><p id="635d" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">注意，我们使用<em class="lw"> addLast </em>而不是<em class="lw"> add </em>，因为 Moshi 适配器是按优先级排序的，并且您希望自己的适配器“优先”。</p><p id="1c15" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">当然，现在我们还需要一个用于即时类的适配器:</p><pre class="lg lh li lj fd lk ll lm ln aw lo bi"><span id="3286" class="lp ir hi ll b fi lq lr l ls lt">object MoshiInstantAdapter : JsonAdapter&lt;Instant&gt;() {<br/>    @FromJson<br/>    override fun fromJson(reader: JsonReader): Instant =<br/>        Instant.parse(reader.nextString())<br/><br/>    @ToJson<br/>    override fun toJson(writer: JsonWriter, value: Instant?) {<br/>        writer.value(value.<em class="lw">toString</em>())<br/>    }<br/>}</span></pre><p id="b3c7" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">适配器需要注册:</p><pre class="lg lh li lj fd lk ll lm ln aw lo bi"><span id="4010" class="lp ir hi ll b fi lq lr l ls lt"><em class="lw">moshi </em>{<br/>    add(MoshiInstantAdapter)<br/>    addLast(KotlinJsonAdapterFactory())<br/>}</span></pre><p id="e0fe" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">你可能会想，我们已经准备好了……但是不:</p><blockquote class="mk ml mm"><p id="9fa4" class="jo jp lw jq b jr kn jt ju jv ko jx jy mn kp kb kc mo kq kf kg mp kr kj kk kl hb bi translated">java.util.ArrayList 类没有 JsonAdapter，您可能应该使用 List 而不是 ArrayList (Moshi 默认情况下只支持集合接口),或者注册一个自定义 JsonAdapter。</p></blockquote><p id="88fa" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">经过深入研究，我发现 Moshi 根本不支持开箱即用的数组列表，我在 stack overflow<a class="ae km" href="https://stackoverflow.com/a/61272734/534471" rel="noopener ugc nofollow" target="_blank">https://stackoverflow.com/a/61272734/534471</a>上找到了这个答案:</p><figure class="lg lh li lj fd ij"><div class="bz dy l di"><div class="mq mr l"/></div></figure><p id="0284" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">注册 ArrayListAdapter，我们最终真正完成了:</p><pre class="lg lh li lj fd lk ll lm ln aw lo bi"><span id="f0dc" class="lp ir hi ll b fi lq lr l ls lt"><em class="lw">moshi </em>{<br/>    add(MoshiInstantAdapter)<br/>    add(MoshiArrayListJsonAdapter.FACTORY)<br/>    addLast(KotlinJsonAdapterFactory())<br/>}</span></pre><h2 id="641a" class="lp ir hi bd is lx ly lz iw ma mb mc ja jz md me je kd mf mg ji kh mh mi jm mj bi translated">摩西法典</h2><p id="9654" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">Moshi 反射很慢，并且增加了大量的额外代码(kotlin-reflect library) -&gt;对移动应用程序很重要。另一方面，Codegen 使用注释处理器。它在编译时为每个 Kotlin 类生成一个小而快速的适配器。</p><p id="823b" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">要使用 Codegen，我们需要添加</p><p id="e4a8" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">要使用 Codegen，我们需要添加<a class="ae km" href="https://kotlinlang.org/docs/kapt.html" rel="noopener ugc nofollow" target="_blank"> Kotlin 注释处理工具</a> ( <a class="ae km" href="https://kotlinlang.org/docs/kapt.html" rel="noopener ugc nofollow" target="_blank"> kapt </a>)和 Codegen 注释处理器:</p><pre class="lg lh li lj fd lk ll lm ln aw lo bi"><span id="67c6" class="lp ir hi ll b fi lq lr l ls lt">plugins <strong class="ll hj">{<br/>    </strong><em class="lw">kotlin</em>("jvm") <em class="lw">version </em>"1.4.32" <em class="lw">apply </em>false<br/>    <em class="lw">kotlin</em>("kapt") <em class="lw">version </em>"1.4.32" <em class="lw">apply </em>false<br/><strong class="ll hj">}</strong></span><span id="65ee" class="lp ir hi ll b fi lu lr l ls lt">kapt("com.squareup.moshi:moshi-kotlin-codegen:1.12.0")</span></pre><p id="5f4f" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">请注意，<em class="lw"> kapt </em>需要在<em class="lw"> jvm </em>插件之后。还要注意，它是<em class="lw">kapt(“…”</em>而不是<em class="lw">实现(“…”</em>)。我浪费了时间，因为我使用了<em class="lw">实现</em>(复制&amp;粘贴错误)，并想知道它为什么不生成适配器类(得到“未能找到生成的 JsonAdapter 类”)。</p><p id="1f20" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">我们还需要用<em class="lw">@ JSON class(generate adapter = true)</em>注释每个数据类:</p><pre class="lg lh li lj fd lk ll lm ln aw lo bi"><span id="f003" class="lp ir hi ll b fi lq lr l ls lt">@JsonClass(generateAdapter = true)<br/>data class Account(</span><span id="29b8" class="lp ir hi ll b fi lu lr l ls lt">@JsonClass(generateAdapter = true)<br/>data class Customer(</span></pre><p id="922a" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">就是这样。</p><h1 id="9f20" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">结论</h1><ul class=""><li id="7fff" class="ks kt hi jq b jr js jv jw jz ms kd mt kh mu kl mv ky kz la bi translated"><strong class="jq hj"> Gson (19.4k 星，3.8k 叉，最后提交 2020 年 5 月 13 日):</strong> <br/>容易设置，唯一开箱即用的 lib(有点)。我绝对花了最少的时间，让 Gson 序列化启动并运行。如果你不想浪费时间，让最先进的技术发挥作用，也不关心最大性能，Gson 是一个不错的选择。</li><li id="daab" class="ks kt hi jq b jr lb jv lc jz ld kd le kh lf kl mv ky kz la bi translated"><strong class="jq hj"> kotlinx.serialization (3k 星，320 叉，最后提交 2021 年 4 月 5 日):<br/> </strong>镇上的新警长。我花了比 Gson 更长的时间来设置它，但它显然是为 Kotlin 制作的，因为 Kotlin 插件在编译时而不是运行时施展魔法。它也支持 Kotlin 多平台，你可以使用它为 Android，Ktor，Gradle/Maven，Kotlin/JS，Kotlin/Native 等..我对 kotlinx.serialization 的唯一不满是，它支持带有@Serializable 注释的类，但不支持可序列化的类(扩展可序列化接口的类)。我知道在编译时创建序列化器对于接口<em class="lw">"</em><a class="ae km" href="http://twitter.com/Serializable" rel="noopener ugc nofollow" target="_blank"><em class="lw">@ Serializable</em></a><em class="lw">来说是不可能的，注释被忽略是因为它不可能自动序列化接口或枚举。通过同伴对象等手动提供序列化程序)</em>但在运行时可能会有基于反射的接口解决方案。</li><li id="4824" class="ks kt hi jq b jr lb jv lc jz ld kd le kh lf kl mv ky kz la bi translated"><strong class="jq hj"> Moshi (7.2k stars，598 forks，最后提交 2021 年 4 月 10 日):<br/> </strong>很难设置，如果你不是针对它的默认平台(Android 和 Java)，文档会很混乱。现在我不明白为什么我会选择 Moshi 而不是其他两个库。该项目非常活跃，因此它可能会发展为 Ktor 和 Kotlin 多平台提供更好/更容易的支持。</li></ul><p id="70e0" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">我个人会使用 kotlinx.serialization。到目前为止我还没有发现任何阻碍，这似乎是一个非常活跃的项目，尽管我肯定会关注 Moshi 及其发展方向。</p><p id="af33" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated"><strong class="jq hj">注意:</strong>在研究 https://github.com/papsign/Ktor-OpenAPI-Generator<a class="ae km" href="https://github.com/papsign/Ktor-OpenAPI-Generator" rel="noopener ugc nofollow" target="_blank"/>(文章随后)时，我在 kotlinx.serialization 中发现了以下错误</p><blockquote class="mk ml mm"><p id="d811" class="jo jp lw jq b jr kn jt ju jv ko jx jy mn kp kb kc mo kq kf kg mp kr kj kk kl hb bi translated">出现异常:尚不支持序列化不同元素类型的集合</p></blockquote><p id="48d0" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">我切换回使用 Gson，一切正常。使用旧的但是久经考验的库似乎有它的优势。</p><h1 id="9cbe" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">附录:性能</h1><p id="daae" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">比较不同库的序列化/反序列化的性能似乎是一项具有挑战性的任务。我注意到不同基准之间的主要差异。有些人认为 kotlinx.serialization 是赢家，有些人认为是 Moshi，有些人认为是 Jackson:</p><ul class=""><li id="6d36" class="ks kt hi jq b jr kn jv ko jz ku kd kv kh kw kl mv ky kz la bi translated"><a class="ae km" rel="noopener" href="/stanwood/save-my-ass-benchmark-of-json-deserializers-on-android-28341c1e82df">https://medium . com/stanwood/save-my-ass-benchmark-of-JSON-deserialisers-on-Android-28341 C1 e 82 df</a><br/>-&gt;<strong class="jq hj">kotlinx . serialization</strong>&gt;Gson&gt;Moshi&gt;&gt;&gt;Jackson<br/>(对比旧版 libs，基准从 2018 年开始)</li><li id="4d56" class="ks kt hi jq b jr lb jv lc jz ld kd le kh lf kl mv ky kz la bi translated"><a class="ae km" href="https://proandroiddev.com/goodbye-gson-hello-moshi-4e591116231e" rel="noopener ugc nofollow" target="_blank">https://proandroiddev . com/goodbye-Gson-hello-Moshi-4e 591116231 e</a><br/>-&gt;<strong class="jq hj">Moshi</strong>&gt;Gson<br/>(不运行自己的基准，只是引用下一个基准)</li><li id="f421" class="ks kt hi jq b jr lb jv lc jz ld kd le kh lf kl mv ky kz la bi translated"><a class="ae km" href="https://github.com/ZacSweers/json-serialization-benchmarking/" rel="noopener ugc nofollow" target="_blank">https://github . com/zacs weers/JSON-serialization-benchmark/</a><br/><a class="ae km" href="https://zacsweers.github.io/json-serialization-benchmarking/" rel="noopener ugc nofollow" target="_blank">https://zacs weers . github . io/JSON-serialization-benchmark/</a><br/><strong class="jq hj">Moshi</strong>&gt;kot linx . serialization/Gson</li><li id="53e2" class="ks kt hi jq b jr lb jv lc jz ld kd le kh lf kl mv ky kz la bi translated"><a class="ae km" href="https://tech.olx.com/android-jetpack-benchmark-json-parsers-performance-1e76031a296b" rel="noopener ugc nofollow" target="_blank">https://tech . olx . com/Android-jetpack-benchmark-JSON-parsers-performance-1e 76031 a 296 b</a><br/><strong class="jq hj">Jackson</strong>&gt;kotlinx . serialization&gt;Gson&gt;Moshi<br/>(对比旧版 libs，2019 年的基准)</li></ul><p id="2257" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">如果性能对您很重要，您可能希望针对您的特定环境和特定用例运行自己的基准测试。令人惊讶的是，我自己的基准测试将 Gson 排在 Moshi 之前(反射比 codegen 慢)，而 kotlinx.serialization 排在最后，但由于我在这些基准测试上花了大约 15 分钟，我并不真正信任它们。我在复杂后端服务方面的经验是，网络性能/延迟通常是最耗时的方面(有时是数据库性能)，而序列化实际上可以忽略不计，所以我不会因为考虑不同序列化库的性能而失眠。</p><p id="8393" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">欢迎对文章和快乐编码提供反馈！</p></div></div>    
</body>
</html>