<html>
<head>
<title>Event-Driven Architecture with TypeScript and RabbitMQ</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用TypeScript和RabbitMQ的事件驱动架构</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/event-driven-architecture-with-typescript-and-rabbitmq-e9bafee5ab2d?source=collection_archive---------0-----------------------#2022-03-26">https://medium.com/nerd-for-tech/event-driven-architecture-with-typescript-and-rabbitmq-e9bafee5ab2d?source=collection_archive---------0-----------------------#2022-03-26</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="511f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们用TypeScript和RabbitMQ实践一下事件驱动架构</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es jd"><img src="../Images/36fe1d7c03c60264d62c7b381659d064.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*tWBbGohqNDbL1dtL"/></div></div><figcaption class="jp jq et er es jr js bd b be z dx translated">加里·本迪格在<a class="ae jt" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><p id="2a29" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">随着微服务架构的兴起，服务之间如何发送数据的问题就浮现出来了。在传统的请求驱动模式和最重要的事件驱动模式之间，我们应该选择什么样的模式？</p><p id="3584" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">而我们需要选择哪种模式取决于我们的应用程序。在本文中，我们将看到事件驱动架构背后的一些概念及其使用TypeScript和RabbitMQ构建的实现。</p></div><div class="ab cl ju jv gp jw" role="separator"><span class="jx bw bk jy jz ka"/><span class="jx bw bk jy jz ka"/><span class="jx bw bk jy jz"/></div><div class="hb hc hd he hf"><h1 id="ff7d" class="kb kc hi bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated">事件驱动架构的基本概念</h1><p id="a1f3" class="pw-post-body-paragraph if ig hi ih b ii kz ik il im la io ip iq lb is it iu lc iw ix iy ld ja jb jc hb bi translated">首先，让我们看一个请求驱动架构的真实例子。</p><p id="9d42" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">想象一下，你在麦当劳，非常想吃冰淇淋。你可能知道，有时当你在那里时，机器坏了。然后你问服务员:“机器什么时候能修好？”。服务员说“几分钟后”。然后你回到你的椅子上，吃你的汉堡。</p><p id="6cd1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">五分钟后，你问“机器修好了吗？”服务员回答“没有”。然后你空手回到你的椅子上。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es le"><img src="../Images/a5d5a8a63e5d454b269f3a28792fede2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kMzR5hkScRleKC9yKqiVEQ.jpeg"/></div></div><figcaption class="jp jq et er es jr js bd b be z dx translated">作者形象</figcaption></figure><p id="e7a2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">同样的事情你问了好几次，服务员还是回答“没有”。直到30分钟后，机器修好了，你就可以拿你的冰淇淋了。</p><p id="0757" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果我是服务员，如果每隔几分钟就有人问我，我会非常恼火。那么，什么是最好的方法来确保没有人会打扰我这个服务员，但顾客仍然会感到满意？</p><p id="6f75" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">你需要做的是告诉服务员当机器修好时通知你，但在那之前你应该等待并享受你的食物。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es le"><img src="../Images/8a0b65d94b60b6ae75b28bdedcb1196f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*X_hvHTBG-Rmj4DvZDgsE7Q.jpeg"/></div></div><figcaption class="jp jq et er es jr js bd b be z dx translated">作者形象</figcaption></figure><p id="1f59" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">好的……那么第一个场景就是我们所说的请求驱动。顾客问服务员，服务员回应。但是这种情况并不完全可取，对吗？这就是事件驱动的用武之地。顾客不需要每次都问服务员。如果机器修好了，就告诉服务员给他打电话。从技术上来说，客户是订阅服务员，服务员会发布告诉客户机器修好的事件。</p><p id="11f6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在下一节中，我们将看到事件驱动架构的运行。</p></div><div class="ab cl ju jv gp jw" role="separator"><span class="jx bw bk jy jz ka"/><span class="jx bw bk jy jz ka"/><span class="jx bw bk jy jz"/></div><div class="hb hc hd he hf"><h1 id="afa2" class="kb kc hi bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated">兔子q</h1><h2 id="967e" class="lf kc hi bd kd lg lh li kh lj lk ll kl iq lm ln kp iu lo lp kt iy lq lr kx ls bi translated">基础</h2><p id="fa25" class="pw-post-body-paragraph if ig hi ih b ii kz ik il im la io ip iq lb is it iu lc iw ix iy ld ja jb jc hb bi translated">在上一节中，我们有一个类似事件驱动架构的真实场景。但是注意，顾客和服务员的互动是直接完成的，没有任何中间人。因此，在本节中，我们将有另一个组件作为事件驱动架构的中间人。</p><p id="6b77" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">一般来说，事件驱动架构由三个部分组成。创建事件的生产者、接受事件的消费者和充当中间人的队列。它是一个接受和转发事件的消息缓冲区。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es lt"><img src="../Images/9413bce5874078619205c876515b7f82.png" data-original-src="https://miro.medium.com/v2/resize:fit:784/format:webp/0*KA2wB1oVCqA85pP0.png"/></div><figcaption class="jp jq et er es jr js bd b be z dx translated"><a class="ae jt" href="https://www.rabbitmq.com/tutorials/tutorial-one-javascript.html" rel="noopener ugc nofollow" target="_blank">https://www . rabbit MQ . com/tutorials/tutorials-one-JavaScript . html</a></figcaption></figure><p id="0337" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这就是RabbitMQ的位置。RabbitMQ是一个接受和转发消息的消息代理。</p><p id="8aae" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">你可以把它想象成一个邮局:当你把想要邮寄的邮件放入邮箱时，你可以确定邮递员最终会把邮件送到你的收件人手中。在这个类比中，RabbitMQ是一个邮箱，一个邮局，一个信件载体。</p><p id="4ae0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">RabbitMQ确保当消费者不可用时，有一个存储消息的地方。想象一下，如果生产者和消费者直接交互，当消费者不可用时，会有一些消息消失。</p><h2 id="36e8" class="lf kc hi bd kd lg lh li kh lj lk ll kl iq lm ln kp iu lo lp kt iy lq lr kx ls bi translated">安装</h2><p id="1878" class="pw-post-body-paragraph if ig hi ih b ii kz ik il im la io ip iq lb is it iu lc iw ix iy ld ja jb jc hb bi translated">对于本文，我们将使用cloudamqp托管我们的RabbitMQ服务，并使用它的自由层实例。</p><p id="4139" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在，去https://customer.cloudamqp.com/login<a class="ae jt" href="https://customer.cloudamqp.com/login" rel="noopener ugc nofollow" target="_blank">的</a>登录你的账户。但是如果你还没有创建帐户，你需要先注册。</p><p id="c93b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">之后，你会看到这个页面。然后点击<em class="lu">创建新实例</em>。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es lv"><img src="../Images/20e50e2173a0750b86bea4fae06843e1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yee2e6qUPmA2EwBO-tM7Ew.png"/></div></div><figcaption class="jp jq et er es jr js bd b be z dx translated">作者形象</figcaption></figure><p id="9e1c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">您不需要提供任何信用卡或所需信息，因为我们只使用免费计划。然后填写您的实例名称，并保持计划Litte Lemur(免费)。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es lw"><img src="../Images/b0fa00938dbd3d578ff307e83d0087bc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EOORFDj0HPnthRHC1yYn2g.png"/></div></div></figure><p id="45dd" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在，选择一个离你近的数据中心。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es lx"><img src="../Images/9b3327e0604b58200983d67371588397.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*eTY3QeNrl-DFbgsfYO33yg.png"/></div></div></figure><p id="1479" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">点击<em class="lu">审核</em>，然后<em class="lu">创建实例</em>。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es lv"><img src="../Images/f32aef7b7321fa1f554e14d714c43155.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*H9tjt50thrNHKHS7j4Id3w.png"/></div></div></figure><p id="238e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这就是了。但是要开始编码，我们需要一个连接字符串。</p><p id="e7db" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">要了解连接字符串，请单击实例名称。你会看到这样的东西。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es ly"><img src="../Images/314c869400fbf1480b2e82ef603e8374.png" data-original-src="https://miro.medium.com/v2/resize:fit:1370/format:webp/1*I002u4HEJrswDDwGl7_oJQ.png"/></div></figure><p id="c82d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">因为这个URL是敏感数据，所以你需要保密。我们将在下一节中使用它。</p></div><div class="ab cl ju jv gp jw" role="separator"><span class="jx bw bk jy jz ka"/><span class="jx bw bk jy jz ka"/><span class="jx bw bk jy jz"/></div><div class="hb hc hd he hf"><h1 id="905b" class="kb kc hi bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated">让我们写一些代码</h1><h2 id="b9a4" class="lf kc hi bd kd lg lh li kh lj lk ll kl iq lm ln kp iu lo lp kt iy lq lr kx ls bi translated">设置项目</h2><p id="f40a" class="pw-post-body-paragraph if ig hi ih b ii kz ik il im la io ip iq lb is it iu lc iw ix iy ld ja jb jc hb bi translated">该项目由两个微服务组成，用于注册新帐户的auth和向新用户发送电子邮件的通知。为了简单起见，我选择忽略注册用户和发送电子邮件的实现细节。但是您将看到事件是如何从一个服务传递到另一个服务的。</p><p id="1967" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在直接跳到代码之前，我们需要设置我们的项目。如果您对如何使用TypeScript设置web API感到好奇，这里有一个很好的参考。</p><div class="lz ma ez fb mb mc"><a rel="noopener follow" target="_blank" href="/nerd-for-tech/how-to-set-up-development-server-using-typescript-and-docker-1e63735b5ca2"><div class="md ab dw"><div class="me ab mf cl cj mg"><h2 class="bd hj fi z dy mh ea eb mi ed ef hh bi translated">如何使用Typescript和Docker设置开发服务器</h2><div class="mj l"><h3 class="bd b fi z dy mh ea eb mi ed ef dx translated">通过这些简单的步骤，摆脱设置您的第一个开发服务器的艰巨任务</h3></div><div class="mk l"><p class="bd b fp z dy mh ea eb mi ed ef dx translated">medium.com</p></div></div><div class="ml l"><div class="mm l mn mo mp ml mq jn mc"/></div></div></a></div><p id="8764" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">本质上，我们需要两个web服务器，auth和notification。让我们从设置auth web服务器开始。在当前目录中，创建一个名为auth的文件夹，然后将目录切换到其中。</p><p id="69a3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">您可以通过运行<code class="du mr ms mt mu b">npm init -y</code>来初始化一个新项目。它将创建一个文件<code class="du mr ms mt mu b">package.json</code>。</p><p id="b42c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">通过运行<code class="du mr ms mt mu b">npm i typescript --save-dev</code>安装TypeScript，然后通过运行<code class="du mr ms mt mu b">npx tsc --init</code>将您的项目更改为TypeScript项目。</p><p id="49cb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">运行上面的命令后，您将拥有<code class="du mr ms mt mu b">tsconfig.json</code>。为了使文件更简单，将其内容更新为:</p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="mv mw l"/></div></figure><p id="a7fb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">创建一个<code class="du mr ms mt mu b">nodemon.json</code>用于开发配置。因此，您不必在每次更改代码时都重新构建项目。</p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="mv mw l"/></div></figure><p id="38c4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">然后将<code class="du mr ms mt mu b">package.json</code>的脚本更新为:</p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="mv mw l"/></div></figure><p id="d75b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">有了这些改变，你只需要运行<code class="du mr ms mt mu b">npm run dev</code>，来启动一个开发web服务器。</p><p id="5534" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">auth到此为止。现在，您可以对通知服务进行同样的操作。或者复制第一个并将其重命名为notification。</p><h2 id="1021" class="lf kc hi bd kd lg lh li kh lj lk ll kl iq lm ln kp iu lo lp kt iy lq lr kx ls bi translated">编码</h2><p id="a10f" class="pw-post-body-paragraph if ig hi ih b ii kz ik il im la io ip iq lb is it iu lc iw ix iy ld ja jb jc hb bi translated">我现在假设您在当前目录中有两个文件夹，auth和notification。先说auth服务。</p><p id="cae4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">通过运行以下命令，安装身份验证服务所需的一些依赖项:</p><pre class="je jf jg jh fd mx mu my mz aw na bi"><span id="ffd8" class="lf kc hi mu b fi nb nc l nd ne">// dev dependencies<br/>npm i --save-dev @types/express @types/amqplib nodemon</span><span id="c745" class="lf kc hi mu b fi nf nc l nd ne">// main dependencies<br/>npm i express amqplib body-parser</span></pre><p id="8640" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">一个简单的web服务器的简单依赖列表，对吗？</p><p id="40a2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在，在auth目录下创建一个文件夹<code class="du mr ms mt mu b">src</code>和一个新文件<code class="du mr ms mt mu b">index.ts</code>。然后在那里写一些模板代码。</p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="mv mw l"/></div></figure><p id="a72c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我猜上面的代码非常简单明了。这是一个只有3个端点的web服务器，<code class="du mr ms mt mu b">/register</code>、<code class="du mr ms mt mu b">/login</code>和<code class="du mr ms mt mu b">/</code>。你看，这里有<code class="du mr ms mt mu b">console.log</code>语句，我们稍后会从这里发送消息。</p><p id="ac9b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">通知服务也可以这样做，但是<code class="du mr ms mt mu b">index.ts</code>的内容是这样的:</p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="mv mw l"/></div></figure><p id="947c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">与auth非常相似，但是它只有一个虚拟端点，可以返回“Hello World”。确实很正宗！</p><p id="ddd6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">是时候创建生产者代码了。返回到<code class="du mr ms mt mu b">/auth/src</code>目录，创建一个名为<code class="du mr ms mt mu b"> producer.ts</code>的新文件。</p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="mv mw l"/></div></figure><p id="d8ce" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这里我们有一个名为<code class="du mr ms mt mu b">createMQProducer</code>的函数创建器，它返回一个我们将用来发送事件/消息的函数(参见第22到24行的定义)。第4到21行建立了到RabbitMQ的连接。</p><p id="f8f7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">接下来，返回到<code class="du mr ms mt mu b">/notification</code>目录，在<code class="du mr ms mt mu b">src</code>文件夹中创建一个名为<code class="du mr ms mt mu b">consumer.ts</code>的新文件。</p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="mv mw l"/></div></figure><p id="61aa" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在我们也有了一个叫做<code class="du mr ms mt mu b">createMQConsumer</code>的函数创建器。就像它的名字一样，它返回一个函数来监听RabbitMQ并等待传入的消息。</p><p id="9c9f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">注意第19到31行。这是我们在接受消息时要做的事情，消息本身将是这样的JSON格式。</p><pre class="je jf jg jh fd mx mu my mz aw na bi"><span id="923a" class="lf kc hi mu b fi nb nc l nd ne">{<br/>  "action": "REGISTER",<br/>  "data": {<br/>    ... user's data<br/>  }<br/>}</span></pre><p id="ddd0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">是时候更新两个服务中的<code class="du mr ms mt mu b">index.ts</code>文件了。</p><p id="27f2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">将内部授权服务中的<code class="du mr ms mt mu b">index.ts</code>更新到此。</p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="mv mw l"/></div></figure><p id="f099" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">设置RabbitMQ服务时，将<code class="du mr ms mt mu b">AMQP_URL</code>的值替换为您之前拥有的AMQP URL。</p><p id="6cb2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">注意，在第11行，我们运行函数创建器来获取<code class="du mr ms mt mu b">producer</code>函数。然后我们在第22行和第34行使用它。</p><p id="d032" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">接下来，更新<code class="du mr ms mt mu b">index.ts</code>内部通知服务。</p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="mv mw l"/></div></figure><p id="f45e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">对AMQP网址做和以前一样的事情。</p><p id="bcb3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这里，我们在第11行运行<code class="du mr ms mt mu b">consumer</code>的函数创建器，并在第13行运行返回的函数。函数<code class="du mr ms mt mu b">consumer</code>将监听传入的消息，并与web服务器同时运行。</p><p id="7cc2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我认为这种方法可能不是最好的方法，因为在不同的流程中运行消费者更好。</p><p id="17df" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这就是了。让我们运行这两个服务来测试我们的项目。</p><p id="8d20" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果你去<code class="du mr ms mt mu b">/register</code>并提供电子邮件和密码，然后点击它。看看通知服务。将会有一个打印的控制台，显示事件是从auth服务传输的，并在notification service中接收。</p><p id="ca4f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">有了这个简单的例子，你就可以在收到事件时播放，就像在注册账户时发送邮件，更新上次登录时间等。</p></div><div class="ab cl ju jv gp jw" role="separator"><span class="jx bw bk jy jz ka"/><span class="jx bw bk jy jz ka"/><span class="jx bw bk jy jz"/></div><div class="hb hc hd he hf"><h1 id="5ee9" class="kb kc hi bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated">结论</h1><p id="d865" class="pw-post-body-paragraph if ig hi ih b ii kz ik il im la io ip iq lb is it iu lc iw ix iy ld ja jb jc hb bi translated">我们已经讨论了事件驱动架构和RabbitMQ的概念，然后用TypeScript构建了一个简单的项目。尽管事件驱动架构可以使我们的微服务松散耦合并在当今被大量使用，但它仍然不是一个可以用于所有类型应用的银弹。</p><p id="e604" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">使用事件驱动架构的缺点包括没有集中的地方来控制工作流，回滚很复杂，尤其是在您有分布式事务的情况下。</p><p id="4612" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">请求驱动和事件驱动架构都有各自的优点和缺点。还可以根据应用需求选择使用混合架构。记住这一点，当您想要一个松散耦合且更灵活的分布式系统时，考虑使用事件驱动仍然是一个好主意。</p><p id="abea" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">下面是完整的代码:<a class="ae jt" href="https://github.com/agusrichard/typescript-workbook/tree/master/event-driven-article-material" rel="noopener ugc nofollow" target="_blank">https://github . com/agusrichard/typescript-workbook/tree/master/event-driven-article-material</a></p><p id="1453" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">作为额外的参考，这里有一个稍微复杂一点的例子:<a class="ae jt" href="https://github.com/agusrichard/typescript-workbook/tree/master/event-driven-microservices" rel="noopener ugc nofollow" target="_blank">https://github . com/agusrichard/typescript-workbook/tree/master/event-driven-micro services</a></p></div><div class="ab cl ju jv gp jw" role="separator"><span class="jx bw bk jy jz ka"/><span class="jx bw bk jy jz ka"/><span class="jx bw bk jy jz"/></div><div class="hb hc hd he hf"><h1 id="5ded" class="kb kc hi bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated">资源</h1><div class="lz ma ez fb mb mc"><a href="https://www.techtalksbyanvita.com/post/event-driven-vs-request-driven-rest-architecture" rel="noopener  ugc nofollow" target="_blank"><div class="md ab dw"><div class="me ab mf cl cj mg"><h2 class="bd hj fi z dy mh ea eb mi ed ef hh bi translated">微服务中的事件驱动与请求驱动(RESTful)架构</h2><div class="mj l"><h3 class="bd b fi z dy mh ea eb mi ed ef dx translated">“Taxi-Ride”交互示例让我们仔细看看什么是REST API。这基本上是一种互动…</h3></div><div class="mk l"><p class="bd b fp z dy mh ea eb mi ed ef dx translated">www.techtalksbyanvita.com</p></div></div><div class="ml l"><div class="ng l mn mo mp ml mq jn mc"/></div></div></a></div><div class="lz ma ez fb mb mc"><a href="https://www.rabbitmq.com/" rel="noopener  ugc nofollow" target="_blank"><div class="md ab dw"><div class="me ab mf cl cj mg"><h2 class="bd hj fi z dy mh ea eb mi ed ef hh bi translated">有效的消息传递- RabbitMQ</h2><div class="mj l"><h3 class="bd b fi z dy mh ea eb mi ed ef dx translated">RabbitMQ拥有成千上万的用户，是最受欢迎的开源消息代理之一。从T-Mobile到…</h3></div><div class="mk l"><p class="bd b fp z dy mh ea eb mi ed ef dx translated">www.rabbitmq.com</p></div></div></div></a></div></div></div>    
</body>
</html>