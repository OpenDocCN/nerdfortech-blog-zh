<html>
<head>
<title>Sorting Algorithms</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">排序算法</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/sorting-algorithms-20fae8479594?source=collection_archive---------13-----------------------#2021-07-02">https://medium.com/nerd-for-tech/sorting-algorithms-20fae8479594?source=collection_archive---------13-----------------------#2021-07-02</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/d36e0ac157cbbcc5e533c48712109166.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*T9MhUglvUb5uR8yN34IbGg.png"/></div></div></figure><p id="da87" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">排序意味着以特定的方式排列数据。有两种类型的排序算法。他们是</p><ol class=""><li id="0650" class="jo jp hi is b it iu ix iy jb jq jf jr jj js jn jt ju jv jw bi translated">迭代排序算法</li></ol><ul class=""><li id="ae3e" class="jo jp hi is b it iu ix iy jb jq jf jr jj js jn jx ju jv jw bi translated">选择排序</li><li id="0af1" class="jo jp hi is b it jy ix jz jb ka jf kb jj kc jn jx ju jv jw bi translated">冒泡排序</li><li id="7bde" class="jo jp hi is b it jy ix jz jb ka jf kb jj kc jn jx ju jv jw bi translated">插入排序</li></ul><p id="d275" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">2.递归排序算法</p><ul class=""><li id="d238" class="jo jp hi is b it iu ix iy jb jq jf jr jj js jn jx ju jv jw bi translated">合并排序</li><li id="accd" class="jo jp hi is b it jy ix jz jb ka jf kb jj kc jn jx ju jv jw bi translated">快速排序</li></ul></div><div class="ab cl kd ke gp kf" role="separator"><span class="kg bw bk kh ki kj"/><span class="kg bw bk kh ki kj"/><span class="kg bw bk kh ki"/></div><div class="hb hc hd he hf"><h1 id="6b3c" class="kk kl hi bd km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh bi translated">选择排序</h1><p id="e71d" class="pw-post-body-paragraph iq ir hi is b it li iv iw ix lj iz ja jb lk jd je jf ll jh ji jj lm jl jm jn hb bi translated">该列表分为两个子列表。</p><ol class=""><li id="23aa" class="jo jp hi is b it iu ix iy jb jq jf jr jj js jn jt ju jv jw bi translated">分类的</li><li id="d4d6" class="jo jp hi is b it jy ix jz jb ka jf kb jj kc jn jt ju jv jw bi translated">未分类的</li></ol><p id="8a17" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们从未排序列表中找到最小的元素，并用未排序列表的第一个元素替换它。</p><p id="734e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在每一次交换(称为排序传递)之后，排序列表中的元素数量增加 1，而未排序列表中的元素数量减少 1。</p><p id="b7ff" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">n 个元素的列表需要(n-1)次排序才能对整个数组进行排序。</p><figure class="lo lp lq lr fd ij er es paragraph-image"><div class="er es ln"><img src="../Images/1d6873d2ec2dd7e5ad411c08268c7622.png" data-original-src="https://miro.medium.com/v2/resize:fit:864/format:webp/1*Bdv_19j6x6oqZc8auXpaGg.jpeg"/></div></figure><p id="a794" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">蓝色的列表是未排序的列表，粉色的是已排序的数组。</p><p id="082b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这个数组中有 7 个元素。所以它需要(7–1)= 6 次排序来排序这个数组。</p><pre class="lo lp lq lr fd ls lt lu lv aw lw bi"><span id="6ce2" class="lx kl hi lt b fi ly lz l ma mb">void selectionSort(int arr[]){<br/>        int n = arr.length;<br/>        for (int i = 0; i &lt; n-1; i++)<br/>        {<br/>            int min_idx = i;<br/>            for (int j = i+1; j &lt; n; j++)<br/>                if (arr[j] &lt; arr[min_idx])<br/>                    min_idx = j;<br/>            int temp = arr[min_idx];<br/>            arr[min_idx] = arr[i];<br/>            arr[i] = temp;<br/>        }<br/>}</span></pre></div><div class="ab cl kd ke gp kf" role="separator"><span class="kg bw bk kh ki kj"/><span class="kg bw bk kh ki kj"/><span class="kg bw bk kh ki"/></div><div class="hb hc hd he hf"><h1 id="16a6" class="kk kl hi bd km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh bi translated">冒泡排序</h1><p id="9b13" class="pw-post-body-paragraph iq ir hi is b it li iv iw ix lj iz ja jb lk jd je jf ll jh ji jj lm jl jm jn hb bi translated">这是一种基于比较的算法。我们比较两个相邻的元素，如果它们没有按顺序排列，就交换它们。每次迭代后，排序后的值将设置在未排序数组的末尾。</p><p id="ca91" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如果列表中有 n 个元素，平均和最坏情况下的时间复杂度都是ο(n^2。所以，这不适合大型列表。</p><figure class="lo lp lq lr fd ij er es paragraph-image"><div class="er es mc"><img src="../Images/23ed5a4a1c635199e18bc2d521787742.png" data-original-src="https://miro.medium.com/v2/resize:fit:1112/format:webp/1*XqJdsWrp1HMU3yfumUguHQ.png"/></div></figure><p id="8fa3" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这是冒泡排序的一个实现。该数组在 3 次迭代后被完全排序。</p><pre class="lo lp lq lr fd ls lt lu lv aw lw bi"><span id="e0d2" class="lx kl hi lt b fi ly lz l ma mb">void bubbleSort(int arr[]){<br/>        int n = arr.length;<br/>        for (int i = 0; i &lt; n-1; i++)<br/>        {<br/>            for (int j = 0; j &lt; n-i-1; j++)<br/>                if (arr[j] &gt; arr[j+1])<br/>                {<br/>                    int temp = arr[j];<br/>                    arr[j] = arr[j+1];<br/>                    arr[j+1] = temp;<br/>                }<br/>        }<br/>}</span></pre></div><div class="ab cl kd ke gp kf" role="separator"><span class="kg bw bk kh ki kj"/><span class="kg bw bk kh ki kj"/><span class="kg bw bk kh ki"/></div><div class="hb hc hd he hf"><h1 id="d874" class="kk kl hi bd km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh bi translated">插入排序</h1><p id="9821" class="pw-post-body-paragraph iq ir hi is b it li iv iw ix lj iz ja jb lk jd je jf ll jh ji jj lm jl jm jn hb bi translated">这是一种基于就地比较的算法。位于列表下部的子列表被维护以进行排序。</p><p id="6465" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们按顺序搜索数组，并将未排序的元素插入到排序后的列表中合适的位置。这个过程一直循环，直到所有元素都被添加到排序后的子列表中。</p><figure class="lo lp lq lr fd ij er es paragraph-image"><div class="er es md"><img src="../Images/b046819f1880f94aafdedf49b44b4b09.png" data-original-src="https://miro.medium.com/v2/resize:fit:1124/format:webp/1*EZY_Nyos3QWiHvcAov-Nxw.png"/></div></figure><p id="5b6b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这是一个显示插入排序如何工作的示例图。</p><pre class="lo lp lq lr fd ls lt lu lv aw lw bi"><span id="388e" class="lx kl hi lt b fi ly lz l ma mb">void insertionSort(int arr[]){<br/>        int n = arr.length;<br/>        for (int i = 1; i &lt; n; i++)<br/>        {<br/>            int key = arr[i];            <br/>            int j = i-1;<br/>            while(j&gt;=0 &amp;&amp; arr[j]&gt;key){<br/>                arr[j+1] = arr[j]<br/>                j = j-1;<br/>            }<br/>            arr[j+1] = key;<br/>        }<br/>}</span><span id="5511" class="lx kl hi lt b fi me lz l ma mb">arr[j + 1] = key;<br/>        }<br/>}</span></pre></div><div class="ab cl kd ke gp kf" role="separator"><span class="kg bw bk kh ki kj"/><span class="kg bw bk kh ki kj"/><span class="kg bw bk kh ki"/></div><div class="hb hc hd he hf"><h1 id="ac87" class="kk kl hi bd km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh bi translated">合并排序</h1><p id="5990" class="pw-post-body-paragraph iq ir hi is b it li iv iw ix lj iz ja jb lk jd je jf ll jh ji jj lm jl jm jn hb bi translated">这是一种基于分治的排序算法。</p><h2 id="6a2d" class="lx kl hi bd km mf mg mh kq mi mj mk ku jb ml mm ky jf mn mo lc jj mp mq lg mr bi translated">一般过程</h2><ol class=""><li id="d663" class="jo jp hi is b it li ix lj jb ms jf mt jj mu jn jt ju jv jw bi translated">将阵列分成两半</li><li id="4041" class="jo jp hi is b it jy ix jz jb ka jf kb jj kc jn jt ju jv jw bi translated">递归地对它们进行排序</li><li id="aa4a" class="jo jp hi is b it jy ix jz jb ka jf kb jj kc jn jt ju jv jw bi translated">将它们合并在一起</li></ol><figure class="lo lp lq lr fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mv"><img src="../Images/3641b1479787e681d6776063c662fd9e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2Xl0wf6WZnVfinVPUn81bw.png"/></div></div></figure><pre class="lo lp lq lr fd ls lt lu lv aw lw bi"><span id="9bb7" class="lx kl hi lt b fi ly lz l ma mb">Mergesort (A,lb,ub){<br/>   Mid = (lb+ub)/2;<br/>   Mergesort (A,lb,Mid);<br/>   Mergesort (A,Mid+1,ub);<br/>   Merge (A,lb,Mid,ub);<br/>}</span></pre><p id="a1c3" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在这里，</p><ul class=""><li id="7f40" class="jo jp hi is b it iu ix iy jb jq jf jr jj js jn jx ju jv jw bi translated">A = &gt;一个数组</li><li id="f746" class="jo jp hi is b it jy ix jz jb ka jf kb jj kc jn jx ju jv jw bi translated">lb = &gt;数组的下限</li><li id="9abd" class="jo jp hi is b it jy ix jz jb ka jf kb jj kc jn jx ju jv jw bi translated">ub = &gt;数组的上限</li><li id="138e" class="jo jp hi is b it jy ix jz jb ka jf kb jj kc jn jx ju jv jw bi translated">Mid = &gt;数组的中间值</li></ul></div><div class="ab cl kd ke gp kf" role="separator"><span class="kg bw bk kh ki kj"/><span class="kg bw bk kh ki kj"/><span class="kg bw bk kh ki"/></div><div class="hb hc hd he hf"><h1 id="e5d1" class="kk kl hi bd km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh bi translated">快速排序</h1><p id="554f" class="pw-post-body-paragraph iq ir hi is b it li iv iw ix lj iz ja jb lk jd je jf ll jh ji jj lm jl jm jn hb bi translated">这种排序算法使用分治技术。</p><h2 id="7c41" class="lx kl hi bd km mf mg mh kq mi mj mk ku jb ml mm ky jf mn mo lc jj mp mq lg mr bi translated">一般过程</h2><ol class=""><li id="150f" class="jo jp hi is b it li ix lj jb ms jf mt jj mu jn jt ju jv jw bi translated">从数组中选择一个枢轴</li><li id="d0f1" class="jo jp hi is b it jy ix jz jb ka jf kb jj kc jn jt ju jv jw bi translated">将数组分成 2 个子数组—元素大于轴心，元素小于轴心</li><li id="028d" class="jo jp hi is b it jy ix jz jb ka jf kb jj kc jn jt ju jv jw bi translated">递归地执行步骤 1 和步骤 2，直到数组排序完毕</li></ol><figure class="lo lp lq lr fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/b2edf3bb2baef29baf54ad40e49b08eb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*A7EsaOsa26842RTl3hf3sw.jpeg"/></div></div></figure><pre class="lo lp lq lr fd ls lt lu lv aw lw bi"><span id="2584" class="lx kl hi lt b fi ly lz l ma mb">quickSort(arr[], low, high)<br/>{<br/>    if (low &lt; high)<br/>    {<br/>        pi = partition(arr, low, high);<br/>        quickSort(arr, low, pi - 1);  <br/>        quickSort(arr, pi + 1, high); <br/>    }<br/>}</span></pre><p id="b425" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在这里，</p><ul class=""><li id="3d62" class="jo jp hi is b it iu ix iy jb jq jf jr jj js jn jx ju jv jw bi translated">低= &gt;起始索引</li><li id="ac1d" class="jo jp hi is b it jy ix jz jb ka jf kb jj kc jn jx ju jv jw bi translated">高= &gt;结束指数</li></ul></div></div>    
</body>
</html>