<html>
<head>
<title>Building Custom Callbacks in TensorFlow-Keras</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在TensorFlow-Keras中构建自定义回调</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/building-custom-callbacks-in-tensorflow-keras-232919a16c53?source=collection_archive---------5-----------------------#2021-10-31">https://medium.com/nerd-for-tech/building-custom-callbacks-in-tensorflow-keras-232919a16c53?source=collection_archive---------5-----------------------#2021-10-31</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/cfbc4d4ca3e7c62ad89ad8c0c1eeed15.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vm7FYL5t4vGFf4frQoXsGQ.jpeg"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">帕万·特里库塔姆在<a class="ae iu" href="https://unsplash.com/" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><p id="3203" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">回调是可以在模型训练、评估或预测过程的不同阶段运行的函数。</p><p id="6149" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这里有一个例子来说明回调是如何工作的…</p><p id="801a" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">假设我们已经使用tensorflow.keras建立了一个模型，然后，我们开始训练它。我们已经指定纪元的数量为20。我们持续监控培训师打印的培训和验证损失和准确性。损失在稳步下降。然后，突然在第14个时期，验证损失开始上升。意味着模型过度拟合。现在继续训练没有意义，因为模型已经开始过度拟合，训练者只会在训练结束时保存模型，这将没有任何用处。现在，我们必须在将时期数设置为12或13后重新开始训练，并再次等待它完成。太痛苦了！我们不可能一直重复下去。</p><p id="b238" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">营救的召回...！</p><p id="3acf" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在这种情况下，我们需要使用的回调是ModelCheckpoint回调。ModelCheckpoint回调是tensorflow.keras库中许多现成可用的回调之一。我们可以配置这个回调，在每个时期结束时保存模型的副本(也称为模型检查点)。因此在训练期间，一旦模型在第14个时期开始过度拟合，我们可以简单地终止训练。然后选择并最终确定在第13个时期结束时保存的模型检查点，并删除与其他时期相关的所有检查点。</p><p id="a818" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如前所述，tensorflow.keras库中有许多现成的回调函数。我们不会深入讨论它们，因为本文的目标是展示如何创建定制回调。</p><p id="769f" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">下面是一些常用的预构建回调的例子。</p><figure class="jt ju jv jw fd ij"><div class="bz dy l di"><div class="jx jy l"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">常用回调。</figcaption></figure><p id="2f54" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">现在想象一下，没有一个现成的回调函数满足我们的需求。</p><p id="c258" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我之前多次面临的一个这样的问题是ModelCheckpoint回调不能直接将模型检查点保存到GCS (Google云存储)。当提供本地文件系统中的目录路径时，它工作起来很有魅力，但是在GCS目录路径的情况下却失败了。</p><p id="88dc" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在这种情况下，我们将不得不构建我们自己的自定义回调，它在每个时期结束时运行，并将模型检查点复制到GCS目录。ModelCheckpoint回调会将检查点写入临时本地目录。我们构建的回调将监控这个目录，并使用Google云存储python客户端，在发现检查点时将其复制到GCS目录。</p><p id="06ec" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">自定义回调是通过继承<strong class="ix hj">tensor flow . keras . callbacks . callback</strong>类创建的。该类有多个函数，可以覆盖这些函数以在以下位置添加所需的功能:</p><ol class=""><li id="3980" class="jz ka hi ix b iy iz jc jd jg kb jk kc jo kd js ke kf kg kh bi translated">训练的开始或结束|评估|预测。</li><li id="f34f" class="jz ka hi ix b iy ki jc kj jg kk jk kl jo km js ke kf kg kh bi translated">时代的开始或结束。</li><li id="699c" class="jz ka hi ix b iy ki jc kj jg kk jk kl jo km js ke kf kg kh bi translated">批次的开始或结束。</li></ol><p id="85ff" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在我们的例子中，我们将只使用on_epoch_end函数。</p><figure class="jt ju jv jw fd ij"><div class="bz dy l di"><div class="jx jy l"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">创建自定义回调</figcaption></figure><p id="ab2a" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在上面的例子中，我创建了一个名为GCSCallback的类，它继承了从tensorflow.keras.callbacks导入的Callback类。该类覆盖on_epoch_end函数，并且该函数遍历/tmp/checkpoints目录中找到的每个文件。ModelCheckpoint回调将检查点写入/tmp/checkpoints目录。这个类还有一个名为upload_file_to_gcs的函数，它使用gcs python客户端将文件上传到指定的GCS目录。</p><p id="cdc8" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这里还要注意的一点是，在向回调列表添加回调对象时，需要先添加模型检查点回调，然后是GCS回调。这很重要，因为模型检查点回调必须首先创建检查点，然后GCS回调应该运行并将这些检查点复制到Google云存储中。</p><p id="1fdb" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">就是这样！...就这么简单…我们可以创建回调来做任何我们想做的事情。我们只需要覆盖正确的函数并添加所需的实现。更多有价值的信息可以在他们的官方文档中找到。</p></div></div>    
</body>
</html>