<html>
<head>
<title>Memento Design Pattern</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">纪念品设计模式</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/memento-design-pattern-bdf6e77481fc?source=collection_archive---------20-----------------------#2021-05-25">https://medium.com/nerd-for-tech/memento-design-pattern-bdf6e77481fc?source=collection_archive---------20-----------------------#2021-05-25</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/13ee83d6ff18eb6cb60e42e25a74daee.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*aF_B1fbmLyk0wCF1M5hJ1Q.jpeg"/></div></div></figure><p id="be5f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">Memento模式是一种设计模式，用于将对象的状态恢复到以前的状态，而不会暴露实现细节。这种模式属于行为设计模式的范畴。考虑这样一种情况，我们用状态开发一个应用程序。现在有一个要求说，在一个特定的点，我们需要回到以前的状态。纪念品设计模式可以用来实现这一功能。</p><p id="0cdd" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">Memento设计模式有3个主要组成部分</p><ol class=""><li id="a25d" class="jo jp hi is b it iu ix iy jb jq jf jr jj js jn jt ju jv jw bi translated"><strong class="is hj">发起者:</strong>需要维护其状态的特定对象。它创造了纪念品。</li><li id="e8db" class="jo jp hi is b it jx ix jy jb jz jf ka jj kb jn jt ju jv jw bi translated"><strong class="is hj"> Memento </strong>:负责维护发起者状态的对象。</li><li id="5b2c" class="jo jp hi is b it jx ix jy jb jz jf ka jj kb jn jt ju jv jw bi translated"><strong class="is hj">看守者:</strong>对象跟踪多个纪念品。</li></ol><p id="421b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">实施</strong> —</p><p id="b465" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">发起者与纪念品和看管人的状态相关联。因此，每当我们需要回到以前的状态时，我们与管理员交谈，获得以前的状态并移动。</p><p id="0e7f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">让我们借助一个真实的例子来理解这种模式。</p><h1 id="eda8" class="kc kd hi bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated">用例</h1><blockquote class="la lb lc"><p id="e7d1" class="iq ir ld is b it iu iv iw ix iy iz ja le jc jd je lf jg jh ji lg jk jl jm jn hb bi translated">“中央医院”是一家位于科伦坡的著名私立医院。大约有200名医生为他们的病人提供各种治疗。</p><p id="5c9b" class="iq ir ld is b it iu iv iw ix iy iz ja le jc jd je lf jg jh ji lg jk jl jm jn hb bi translated"><strong class="is hj">需求</strong> —医生需要跟踪发给患者的药物。</p><p id="ede2" class="iq ir ld is b it iu iv iw ix iy iz ja le jc jd je lf jg jh ji lg jk jl jm jn hb bi translated">治疗的继续取决于患者的状态。如果病人情况不佳，医生可能会在现有清单上增加新的药物。否则，如果病人情况良好，医生可能会减少摄入量。(假设这些都是为需要定期服药的长期病情患者做的。)</p></blockquote><h2 id="50dd" class="lh kd hi bd ke li lj lk ki ll lm ln km jb lo lp kq jf lq lr ku jj ls lt ky lu bi translated">分析—</h2><ul class=""><li id="3192" class="jo jp hi is b it lv ix lw jb lx jf ly jj lz jn ma ju jv jw bi translated">我们需要记录之前的药物清单。</li><li id="56e3" class="jo jp hi is b it jx ix jy jb jz jf ka jj kb jn ma ju jv jw bi translated">我们需要将当前药物列表恢复到以前药物列表的功能。</li></ul><p id="ffcb" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">所以很明显，我们可以在这种情况下使用Memento设计模式。让我们实现一个解决方案。</p><h2 id="6347" class="lh kd hi bd ke li lj lk ki ll lm ln km jb lo lp kq jf lq lr ku jj ls lt ky lu bi translated">第一步:</h2><p id="bcda" class="pw-post-body-paragraph iq ir hi is b it lv iv iw ix lw iz ja jb mb jd je jf mc jh ji jj md jl jm jn hb bi translated">让我们实现代表特定药物的Medicine类。</p><figure class="me mf mg mh fd ij"><div class="bz dy l di"><div class="mi mj l"/></div></figure><h2 id="b0fc" class="lh kd hi bd ke li lj lk ki ll lm ln km jb lo lp kq jf lq lr ku jj ls lt ky lu bi translated">第二步:</h2><p id="d4bf" class="pw-post-body-paragraph iq ir hi is b it lv iv iw ix lw iz ja jb mb jd je jf mc jh ji jj md jl jm jn hb bi translated">正如前面提到的，Memento设计模式包含3个主要部分。让我们实现发起者和纪念品类。管理员(PrescriptionHistory类)需要维护这个Memento类的状态。</p><figure class="me mf mg mh fd ij"><div class="bz dy l di"><div class="mi mj l"/></div></figure><p id="a239" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">导入点:</strong></p><ul class=""><li id="fb9e" class="jo jp hi is b it iu ix iy jb jq jf jr jj js jn ma ju jv jw bi translated"><strong class="is hj">。getter </strong>中的clone()方法——如果我们只是将列表复制到另一个列表，那么对第二个列表所做的修改也会影响原始列表。那是因为我们抄袭了参考文献。因此应该使用clone()。</li><li id="5bf8" class="jo jp hi is b it jx ix jy jb jz jf ka jj kb jn ma ju jv jw bi translated"><strong class="is hj"> private getDrugs() </strong> —只有处方类可以访问此方法。</li></ul><p id="018a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们在这门课上实现了两个重要的方法—</p><ul class=""><li id="babb" class="jo jp hi is b it iu ix iy jb jq jf jr jj js jn ma ju jv jw bi translated"><strong class="is hj">。save() </strong> —保留当前状态。通过给予MedicineMemento向护理人员提供状态(处方历史)。如果我们给了处方对象本身，我们<strong class="is hj">不能在不影响先前状态</strong>的情况下改变它。这就是我们传递医药纪念品的原因。基本上，使用当前处方创建一个新的MedicineMemento对象，并传递它。</li><li id="af7e" class="jo jp hi is b it jx ix jy jb jz jf ka jj kb jn ma ju jv jw bi translated"><strong class="is hj"> revert() </strong> —恢复当前状态。获取MedicineMemento本身，并将当前状态设置为MedicineMemento中的状态。</li></ul><h2 id="6b50" class="lh kd hi bd ke li lj lk ki ll lm ln km jb lo lp kq jf lq lr ku jj ls lt ky lu bi translated">步骤03:</h2><p id="f03b" class="pw-post-body-paragraph iq ir hi is b it lv iv iw ix lw iz ja jb mb jd je jf mc jh ji jj md jl jm jn hb bi translated">现在我们需要实现看守类。这个类应该保存前一个对象的状态。</p><p id="2e0a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">行为</strong> —当我们恢复时，最后的处方清单应该是最先出现的。这意味着行为是后进先出的。因此我们可以使用堆栈。</p><figure class="me mf mg mh fd ij"><div class="bz dy l di"><div class="mi mj l"/></div></figure><h2 id="5460" class="lh kd hi bd ke li lj lk ki ll lm ln km jb lo lp kq jf lq lr ku jj ls lt ky lu bi translated">步骤04:</h2><p id="d5d0" class="pw-post-body-paragraph iq ir hi is b it lv iv iw ix lw iz ja jb mb jd je jf mc jh ji jj md jl jm jn hb bi translated">现在我们可以实现主应用程序类了。让我们试着理解一个实际病人的用例。</p><ul class=""><li id="7cf9" class="jo jp hi is b it iu ix iy jb jq jf jr jj js jn ma ju jv jw bi translated"><strong class="is hj">特定的医生分配2种药物给患者服用。</strong></li></ul><p id="a01e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">实施—</p><figure class="me mf mg mh fd ij"><div class="bz dy l di"><div class="mi mj l"/></div></figure><p id="a30b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">输出—</p><figure class="me mf mg mh fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mk"><img src="../Images/724bc5655c6b3c62527388e83ec8588a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4Qt1iRTofHdzp-8eB7BNFQ.jpeg"/></div></div><figcaption class="ml mm et er es mn mo bd b be z dx translated">图1:第一张处方</figcaption></figure><ul class=""><li id="2284" class="jo jp hi is b it iu ix iy jb jq jf jr jj js jn ma ju jv jw bi translated"><strong class="is hj">患者在1周后仍感觉不适</strong>。因此，医生通过在现有列表中引入新的药物来增加治疗。让我们实现这个场景。</li></ul><p id="346b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">实施—</p><figure class="me mf mg mh fd ij"><div class="bz dy l di"><div class="mi mj l"/></div></figure><p id="ffc9" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">输出—</p><figure class="me mf mg mh fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mp"><img src="../Images/764bd19620ba59c1b3876586ee162a39.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2ci-Kz2sU4r0Cen0GkaC0Q.jpeg"/></div></div><figcaption class="ml mm et er es mn mo bd b be z dx translated">图2:更新的处方</figcaption></figure><p id="b6fc" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在我们可以看到，我们已经成功地将新药添加到列表中。</p><ul class=""><li id="586a" class="jo jp hi is b it iu ix iy jb jq jf jr jj js jn ma ju jv jw bi translated"><strong class="is hj">使用新药一周后，患者感觉好多了</strong>。医生决定去掉新加的，开旧单子。</li></ul><p id="b450" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">实施—</p><figure class="me mf mg mh fd ij"><div class="bz dy l di"><div class="mi mj l"/></div></figure><p id="2591" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">输出—</p><figure class="me mf mg mh fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mq"><img src="../Images/2f92dc3804f5d1bcca4a905671701fb0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8bagschzSfDbrFfyWHsh2Q.jpeg"/></div></div><figcaption class="ml mm et er es mn mo bd b be z dx translated">图3:第二次更新后的处方</figcaption></figure><p id="595c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">解释</strong></p><ul class=""><li id="fb35" class="jo jp hi is b it iu ix iy jb jq jf jr jj js jn ma ju jv jw bi translated">即使我们执行了3次恢复方法，应用程序还是恢复了2次。这是为什么呢？</li></ul><p id="6795" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">执行不依赖于处方中的项目。第一个处方包含2种药物，第二个处方包含3种药物。第一次恢复将删除第二次更新的处方。当我们第二次执行revert方法时，应用程序说它不能这样做，因为只有一个处方版本。</p><ul class=""><li id="e39d" class="jo jp hi is b it iu ix iy jb jq jf jr jj js jn ma ju jv jw bi translated">更新的处方打印两次。这是为什么呢？</li></ul><p id="0ce6" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们基本上是把新药添加到处方中，然后把它交给处方历史。现在<strong class="is hj">看管人(处方历史)会开出最后一张处方。等于当前更新的处方。这就是为什么我们恢复一次后得到相同的处方。</strong></p><h2 id="8235" class="lh kd hi bd ke li lj lk ki ll lm ln km jb lo lp kq jf lq lr ku jj ls lt ky lu bi translated">这个怎么解决？</h2><ul class=""><li id="9014" class="jo jp hi is b it lv ix lw jb lx jf ly jj lz jn ma ju jv jw bi translated">避免将新添加的药物传递给处方历史。这可以通过从实现中删除下面一行来实现。</li></ul><p id="81b3" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><code class="du mr ms mt mu b">presHistory.save(prescription);</code></p><p id="e98a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">更新输出—</p><figure class="me mf mg mh fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mv"><img src="../Images/f299e99d5eb1b6c0e52f9373cf5d96eb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*R13FIoTyej0kF8gV3BzWHA.jpeg"/></div></div><figcaption class="ml mm et er es mn mo bd b be z dx translated">图4:没有重复的输出</figcaption></figure><p id="344e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在我们可以看到，没有重复的处方。因此，我们成功地实现了上述解决方案。</p><p id="9305" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">以下URL提供了上述实现的完整源代码。</p><div class="mw mx ez fb my mz"><a href="https://github.com/Damsak/Krish-LP-Training/tree/main/DesignPatterns/MementoDesignPatternPractical/TheCentralHospital" rel="noopener  ugc nofollow" target="_blank"><div class="na ab dw"><div class="nb ab nc cl cj nd"><h2 class="bd hj fi z dy ne ea eb nf ed ef hh bi translated">damsak/Krish-LP-培训</h2><div class="ng l"><h3 class="bd b fi z dy ne ea eb nf ed ef dx translated">通过在GitHub上创建一个帐户，为Damsak/Krish-LP-Training开发做出贡献。</h3></div><div class="nh l"><p class="bd b fp z dy ne ea eb nf ed ef dx translated">github.com</p></div></div><div class="ni l"><div class="nj l nk nl nm ni nn io mz"/></div></div></a></div><p id="554c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我使用了Krishntha Dinesh先生的以下播放列表来收集所需的信息。</p><figure class="me mf mg mh fd ij"><div class="bz dy l di"><div class="np mj l"/></div></figure></div><div class="ab cl nq nr gp ns" role="separator"><span class="nt bw bk nu nv nw"/><span class="nt bw bk nu nv nw"/><span class="nt bw bk nu nv"/></div><div class="hb hc hd he hf"><h1 id="ea75" class="kc kd hi bd ke kf nx kh ki kj ny kl km kn nz kp kq kr oa kt ku kv ob kx ky kz bi translated">参考</h1><div class="mw mx ez fb my mz"><a href="https://www.tutorialspoint.com/design_pattern/memento_pattern.htm" rel="noopener  ugc nofollow" target="_blank"><div class="na ab dw"><div class="nb ab nc cl cj nd"><h2 class="bd hj fi z dy ne ea eb nf ed ef hh bi translated">设计模式——纪念品模式</h2><div class="ng l"><h3 class="bd b fi z dy ne ea eb nf ed ef dx translated">Memento模式用于将对象的状态恢复到先前的状态。记忆模式属于行为…</h3></div><div class="nh l"><p class="bd b fp z dy ne ea eb nf ed ef dx translated">www.tutorialspoint.com</p></div></div><div class="ni l"><div class="oc l nk nl nm ni nn io mz"/></div></div></a></div><div class="mw mx ez fb my mz"><a href="https://refactoring.guru/design-patterns/memento" rel="noopener  ugc nofollow" target="_blank"><div class="na ab dw"><div class="nb ab nc cl cj nd"><h2 class="bd hj fi z dy ne ea eb nf ed ef hh bi translated">纪念品</h2><div class="ng l"><h3 class="bd b fi z dy ne ea eb nf ed ef dx translated">Memento是一种行为设计模式，它允许您保存和恢复对象以前的状态，而不会暴露…</h3></div><div class="nh l"><p class="bd b fp z dy ne ea eb nf ed ef dx translated">重构大师</p></div></div><div class="ni l"><div class="od l nk nl nm ni nn io mz"/></div></div></a></div><div class="mw mx ez fb my mz"><a href="https://www.geeksforgeeks.org/memento-design-pattern/" rel="noopener  ugc nofollow" target="_blank"><div class="na ab dw"><div class="nb ab nc cl cj nd"><h2 class="bd hj fi z dy ne ea eb nf ed ef hh bi translated">纪念品设计模式- GeeksforGeeks</h2><div class="ng l"><h3 class="bd b fi z dy ne ea eb nf ed ef dx translated">Memento模式是一种行为设计模式。Memento模式用于将对象的状态恢复到以前的状态…</h3></div><div class="nh l"><p class="bd b fp z dy ne ea eb nf ed ef dx translated">www.geeksforgeeks.org</p></div></div><div class="ni l"><div class="oe l nk nl nm ni nn io mz"/></div></div></a></div></div></div>    
</body>
</html>