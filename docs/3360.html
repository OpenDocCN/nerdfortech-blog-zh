<html>
<head>
<title>Microservices (Part 3) — Design Patterns for Microservices(Aggregator Pattern)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">微服务(第三部分)——微服务的设计模式(聚合器模式)</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/microservices-part-3-design-patterns-for-microservices-aggregator-pattern-75229280399a?source=collection_archive---------9-----------------------#2021-06-07">https://medium.com/nerd-for-tech/microservices-part-3-design-patterns-for-microservices-aggregator-pattern-75229280399a?source=collection_archive---------9-----------------------#2021-06-07</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/74f26365913f850bb8a94c39084bf4c7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cTX3u99oG5l9WaYAjE2j7Q.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">图1:设计模式(来源:dribbble)</figcaption></figure><p id="d442" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">微服务是一种全新的应用开发方式。设计模式是这个新的实现过程的关键部分。我们来讨论一些常用的设计模式。</p><h1 id="af1a" class="js jt hi bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">聚合器模式</h1><p id="5e44" class="pw-post-body-paragraph iu iv hi iw b ix kq iz ja jb kr jd je jf ks jh ji jj kt jl jm jn ku jp jq jr hb bi translated">微服务应用程序由几个独立的服务组成。这些服务耦合度较低，并通过定义良好的接口相互对话。服务也有自己的数据库。然而，在某些情况下，我们需要编写查询来从不同服务的多个数据库中获取结果。我们可以使用聚合器模式来实现这一点。</p><p id="8c8e" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">在聚合器设计模式中，特定的服务(服务A)将接收请求。那么这个服务将随后向多个服务(服务B，C)发出请求。然后它(服务A)将组合结果并响应初始请求。实现聚合器模式有3种主要方式。</p><ol class=""><li id="e308" class="kv kw hi iw b ix iy jb jc jf kx jj ky jn kz jr la lb lc ld bi translated"><strong class="iw hj">分散-聚集模式</strong></li><li id="845a" class="kv kw hi iw b ix le jb lf jf lg jj lh jn li jr la lb lc ld bi translated"><strong class="iw hj">连锁模式</strong></li><li id="81b6" class="kv kw hi iw b ix le jb lf jf lg jj lh jn li jr la lb lc ld bi translated"><strong class="iw hj">分支模式</strong></li></ol><p id="85be" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">让我们借助一个真实的例子来进一步理解这3个主要实现。</p><h1 id="1f56" class="js jt hi bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">用例</h1><p id="60bd" class="pw-post-body-paragraph iu iv hi iw b ix kq iz ja jb kr jd je jf ks jh ji jj kt jl jm jn ku jp jq jr hb bi translated">假设我们需要为一家酒店实现一个基于微服务的系统。该系统包含以下服务。</p><ol class=""><li id="5f82" class="kv kw hi iw b ix iy jb jc jf kx jj ky jn kz jr la lb lc ld bi translated">服务1:获取客人信息。</li><li id="e267" class="kv kw hi iw b ix le jb lf jf lg jj lh jn li jr la lb lc ld bi translated">服务二:获取房间信息。</li><li id="3672" class="kv kw hi iw b ix le jb lf jf lg jj lh jn li jr la lb lc ld bi translated">服务三:获取美食信息。</li><li id="b489" class="kv kw hi iw b ix le jb lf jf lg jj lh jn li jr la lb lc ld bi translated">服务四:获取餐厅信息。</li></ol><p id="ceda" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">假设这些服务有两个主要消费者。</p><ol class=""><li id="57bb" class="kv kw hi iw b ix iy jb jc jf kx jj ky jn kz jr la lb lc ld bi translated">客人管理系统。</li><li id="32ef" class="kv kw hi iw b ix le jb lf jf lg jj lh jn li jr la lb lc ld bi translated">餐厅管理系统。</li></ol><p id="f6a6" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">通常我们能做的是—</p><p id="58de" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><em class="lj">使用docker创建这4个服务的多个实例并部署它们。</em></p><p id="7a3a" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw hj">问题:</strong>客人管理系统需要客人信息和房间信息。</p><h2 id="2ab2" class="lk jt hi bd ju ll lm ln jy lo lp lq kc jf lr ls kg jj lt lu kk jn lv lw ko lx bi translated"><strong class="ak">解决方案</strong></h2><p id="d4e7" class="pw-post-body-paragraph iu iv hi iw b ix kq iz ja jb kr jd je jf ks jh ji jj kt jl jm jn ku jp jq jr hb bi translated">在微服务架构中，我们总是实现转储管道和智能端点。因此，我们可以创建另一个服务来消费这两个服务(客人信息服务和房间信息服务)，并将响应返回给消费者。有两种主要的方法来实现这一点。</p><p id="a6ce" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw hj">选项01: </strong>向客人信息和客房信息服务发送并行响应。然后将结果汇总并发送回。</p><p id="53dc" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">这种实现称为<strong class="iw hj">分散聚集模式</strong>(也称为并行聚集)。它基本上是一个复合模式，描述了如何将一条消息广播给多个接收者，并将响应重新聚合回一条消息。</p><p id="2be7" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">但是有一个问题。我们不能总是使用这种模式。</p><p id="f271" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw hj">如果客人信息服务依赖客房信息服务怎么办？</strong></p><p id="dfa5" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">现在我们不能发送并行呼叫。</p><p id="e4ac" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw hj">选项02: </strong></p><ol class=""><li id="e272" class="kv kw hi iw b ix iy jb jc jf kx jj ky jn kz jr la lb lc ld bi translated">调用游客信息服务。</li><li id="9a1a" class="kv kw hi iw b ix le jb lf jf lg jj lh jn li jr la lb lc ld bi translated">获得一个唯一的代码(客户代码)以及响应。</li><li id="a55d" class="kv kw hi iw b ix le jb lf jf lg jj lh jn li jr la lb lc ld bi translated">将客人代码交给客房信息服务部。</li><li id="38c7" class="kv kw hi iw b ix le jb lf jf lg jj lh jn li jr la lb lc ld bi translated">然后获取房间信息。</li><li id="13de" class="kv kw hi iw b ix le jb lf jf lg jj lh jn li jr la lb lc ld bi translated">最后，汇总结果并发回。</li></ol><p id="299f" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">这个实现被称为<strong class="iw hj">服务链</strong>。服务链比并行聚合慢。</p><p id="a48d" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw hj">分支</strong></p><p id="3cd4" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">这基本上是聚合器和链设计模式的混合。在这种模式中，一个特定的服务可以在给定的时间与多个服务进行通信。我们可以使用一个名为“分行代码”的字段。那么请求的目的地将由这个分支代码决定(也可能是下一个服务调用地)。</p><figure class="lz ma mb mc fd ij er es paragraph-image"><div class="er es ly"><img src="../Images/3b12e7a8eb826c11dee7dc16f3a424c1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1276/format:webp/1*3IUUGgsg9Z1GItWbxSyIig.jpeg"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">图2:分支</figcaption></figure><p id="0359" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw hj"> <em class="lj">业务需求变化</em> </strong></p><p id="357e" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw hj">新要求:</strong>餐厅管理层在执行其操作之前，需要一些来自客人管理层的信息。</p><p id="b4f2" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">现在，我们可以在不修改任何现有服务的情况下实现这一功能。这是通过创建另一个聚合服务来实现的。这个聚合服务将与必要的服务(在Guest management中)对话并获取信息。</p><p id="c916" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">部署应该在版本控制的帮助下完成。我们可以部署系统的两个版本，并要求客户端升级到新版本。两个版本都应该运行一段特定的时间(直到所有的客户端都升级到新版本)。最后，我们可以删除旧版本的系统。</p><h2 id="697c" class="lk jt hi bd ju ll lm ln jy lo lp lq kc jf lr ls kg jj lt lu kk jn lv lw ko lx bi translated">聚合器模式的优势</h2><ul class=""><li id="f0f6" class="kv kw hi iw b ix kq jb kr jf md jj me jn mf jr mg lb lc ld bi translated">减少客户端和服务之间的通信开销。</li><li id="5039" class="kv kw hi iw b ix le jb lf jf lg jj lh jn li jr mg lb lc ld bi translated">易于理解和实施。</li><li id="6ed7" class="kv kw hi iw b ix le jb lf jf lg jj lh jn li jr mg lb lc ld bi translated">快速发展。</li></ul><p id="2864" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">本文的下一部分阐述了另一种广泛使用的设计模式，称为断路器模式。我使用了Krishntha Dinesh先生的以下播放列表来收集所需的信息。</p><figure class="lz ma mb mc fd ij"><div class="bz dy l di"><div class="mi mj l"/></div></figure></div><div class="ab cl mk ml gp mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="hb hc hd he hf"><h1 id="4435" class="js jt hi bd ju jv mr jx jy jz ms kb kc kd mt kf kg kh mu kj kk kl mv kn ko kp bi translated">参考</h1><div class="mw mx ez fb my mz"><a href="https://dzone.com/articles/microservices-aggregator-design-pattern-using-aws" rel="noopener  ugc nofollow" target="_blank"><div class="na ab dw"><div class="nb ab nc cl cj nd"><h2 class="bd hj fi z dy ne ea eb nf ed ef hh bi translated">使用AWS Lambda - DZone微服务的微服务聚合器设计模式</h2><div class="ng l"><h3 class="bd b fi z dy ne ea eb nf ed ef dx translated">聚合器设计模式可能是微服务实现中最常用的设计模式。这个…</h3></div><div class="nh l"><p class="bd b fp z dy ne ea eb nf ed ef dx translated">dzone.com</p></div></div><div class="ni l"><div class="nj l nk nl nm ni nn io mz"/></div></div></a></div><div class="mw mx ez fb my mz"><a href="https://www.oreilly.com/library/view/java-ee-8/9781788830621/d20a2b30-62e3-4abb-8629-22e054f7f695.xhtml" rel="noopener  ugc nofollow" target="_blank"><div class="na ab dw"><div class="nb ab nc cl cj nd"><h2 class="bd hj fi z dy ne ea eb nf ed ef hh bi translated">Java EE 8设计模式和最佳实践</h2><div class="ng l"><h3 class="bd b fi z dy ne ea eb nf ed ef dx translated">聚合器模式顾名思义，这种模式建立了某种程度上更…</h3></div><div class="nh l"><p class="bd b fp z dy ne ea eb nf ed ef dx translated">www.oreilly.com</p></div></div></div></a></div><div class="mw mx ez fb my mz"><a href="https://java-design-patterns.com/patterns/aggregator-microservices/" rel="noopener  ugc nofollow" target="_blank"><div class="na ab dw"><div class="nb ab nc cl cj nd"><h2 class="bd hj fi z dy ne ea eb nf ed ef hh bi translated">聚合器微服务</h2><div class="ng l"><h3 class="bd b fi z dy ne ea eb nf ed ef dx translated">用户对聚合器服务进行一次调用，然后聚合器调用每个相关的微服务。真实的…</h3></div><div class="nh l"><p class="bd b fp z dy ne ea eb nf ed ef dx translated">java-design-patterns.com</p></div></div></div></a></div></div></div>    
</body>
</html>