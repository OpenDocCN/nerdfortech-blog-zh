<html>
<head>
<title>Building an image classifier with TensorFlow</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用TensorFlow构建图像分类器</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/building-an-image-classifier-with-tensorflow-3e12c1d5d3a2?source=collection_archive---------9-----------------------#2021-05-31">https://medium.com/nerd-for-tech/building-an-image-classifier-with-tensorflow-3e12c1d5d3a2?source=collection_archive---------9-----------------------#2021-05-31</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/3d2409aa0154b1065022799cc2a33478.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YpCjc6jviYcnhgl2Sogt0A.jpeg"/></div></div></figure><p id="ab0c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我想尝试使用<strong class="is hj"> TensorFlow </strong>解决一个简单的图像分类问题。我的意图是从零开始，涵盖建立机器学习模型过程中的所有步骤，包括数据准备、模型创建、训练和最终用于推理。</p><p id="0dc3" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我正在为这个项目寻找两件不同的物品，无意中发现了我儿子的玩具恐龙收藏。红色的<strong class="is hj">暴龙</strong>和银色的<strong class="is hj">腕龙</strong>引起了我的注意，它们是这个项目的好选择。</p><h2 id="3fbe" class="jo jp hi bd jq jr js jt ju jv jw jx jy jb jz ka kb jf kc kd ke jj kf kg kh ki bi translated">数据准备</h2><p id="059b" class="pw-post-body-paragraph iq ir hi is b it kj iv iw ix kk iz ja jb kl jd je jf km jh ji jj kn jl jm jn hb bi translated">与任何其他机器学习项目一样，准备训练数据是第一步。在这种情况下，问题要简单得多，因为我只是要训练模型只对这两种玩具进行分类。因此，我认为每个对象的大约100张图像足以训练模型。</p><p id="23ac" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">为了简单起见，我将相机设置为拍摄长宽比为1:1的照片，或者换句话说，2160 x 2160像素的正方形图像。拍照时，我确保恐龙是从不同的角度拍摄的。此外，我将它们与两种不同的背景放在一起，以消除训练模型中对背景的不必要的偏见。最后，我给每个玩具拍了110张照片，总共220张。</p><figure class="kp kq kr ks fd ij er es paragraph-image"><div class="er es ko"><img src="../Images/a8a99e7eb8e730663f7a0009f7bde20d.png" data-original-src="https://miro.medium.com/v2/resize:fit:706/format:webp/1*XZydL5B0YMSad0wjUN43zg.png"/></div><figcaption class="kt ku et er es kv kw bd b be z dx translated">照片组织成两个独立的目录，以两种恐龙命名</figcaption></figure><p id="ff1c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我把这些照片组织成两个子文件夹，分别以各自的恐龙种类命名。这很重要，因为我计划使用<strong class="is hj"> Keras </strong>到<strong class="is hj"> </strong>中的<strong class="is hj">image _ dataset _ from _ directory</strong>方法从磁盘中的目录结构创建数据集。这种方法会自动用相应的文件夹名称标记每个子文件夹中的图像。</p><p id="ecc4" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">因为这是一个比较容易解决的问题，我认为使用高分辨率图像是一种矫枉过正。因此，我决定将所有照片的大小调整为原始大小的10%，最终得到了一堆216 x 216像素的图像。</p><h2 id="02ff" class="jo jp hi bd jq jr js jt ju jv jw jx jy jb jz ka kb jf kc kd ke jj kf kg kh ki bi translated">发展环境</h2><p id="5b5b" class="pw-post-body-paragraph iq ir hi is b it kj iv iw ix kk iz ja jb kl jd je jf km jh ji jj kn jl jm jn hb bi translated">我已经有了一个用<strong class="is hj"> Python 3.8 </strong>和<strong class="is hj"> TensorFlow 2.4 </strong>配置的虚拟环境。为此，我使用了一个<strong class="is hj"> Jupyter </strong> <strong class="is hj">笔记本</strong>，因为在笔记本上编写这样的项目代码要容易得多。</p><p id="7f82" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我在一个名为“<strong class="is hj">图像”、</strong>的父文件夹中组织了包含训练图像的子文件夹，并为我用于推断的照片创建了一个单独的<strong class="is hj">测试</strong>图像文件夹。此外，我创建了两个笔记本文件——一个用于数据加载、模型创建和训练，而另一个用于推理。</p><figure class="kp kq kr ks fd ij er es paragraph-image"><div class="er es kx"><img src="../Images/47ba15c426274d844246ea11e1c77e6a.png" data-original-src="https://miro.medium.com/v2/resize:fit:736/format:webp/1*KlH7LHPVEQZZvXwreZlX-w.png"/></div><figcaption class="kt ku et er es kv kw bd b be z dx translated">VS代码中的项目文件夹结构</figcaption></figure><h2 id="d95e" class="jo jp hi bd jq jr js jt ju jv jw jx jy jb jz ka kb jf kc kd ke jj kf kg kh ki bi translated">导入依赖项</h2><p id="f434" class="pw-post-body-paragraph iq ir hi is b it kj iv iw ix kk iz ja jb kl jd je jf km jh ji jj kn jl jm jn hb bi translated">然后是时候做一些编码了！</p><p id="1467" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">首先，我导入了脚本所需的所有依赖项。</p><pre class="kp kq kr ks fd ky kz la lb aw lc bi"><span id="d44c" class="jo jp hi kz b fi ld le l lf lg">import <strong class="kz hj">matplotlib.pyplot</strong> as <strong class="kz hj">plt</strong><br/>import <strong class="kz hj">numpy</strong> as <strong class="kz hj">np</strong><br/>import <strong class="kz hj">os</strong><br/>import <strong class="kz hj">PIL</strong><br/>import <strong class="kz hj">pathlib</strong></span><span id="84e2" class="jo jp hi kz b fi lh le l lf lg">import <strong class="kz hj">tensorflow</strong> as <strong class="kz hj">tf</strong><br/>from <strong class="kz hj">tensorflow</strong> import <strong class="kz hj">keras</strong><br/>from <strong class="kz hj">tensorflow.keras</strong> import <strong class="kz hj">layers</strong><br/>from <strong class="kz hj">tensorflow.keras.models</strong> import <strong class="kz hj">Sequential</strong></span></pre><h2 id="0f31" class="jo jp hi bd jq jr js jt ju jv jw jx jy jb jz ka kb jf kc kd ke jj kf kg kh ki bi translated">创建数据集</h2><p id="1197" class="pw-post-body-paragraph iq ir hi is b it kj iv iw ix kk iz ja jb kl jd je jf km jh ji jj kn jl jm jn hb bi translated">我声明了一些在我的代码中有用的全局变量。<strong class="is hj"> pathlib </strong>中的<strong class="is hj"> path </strong>方法帮助我通过<strong class="is hj"> data_dir </strong>变量访问<strong class="is hj"> Images </strong>文件夹中的文件。由于有220个图像，我最初将批处理大小定义为<strong class="is hj"> 55 </strong>，这只是数据集的四分之一。另外，我声明了两个常量来保存<strong class="is hj">图像</strong> <strong class="is hj">高度</strong>和<strong class="is hj">宽度</strong>参数。在这篇文章的后面，你会看到这些参数在起作用。</p><pre class="kp kq kr ks fd ky kz la lb aw lc bi"><span id="fad5" class="jo jp hi kz b fi ld le l lf lg"><strong class="kz hj">data_dir</strong> = pathlib.Path('<strong class="kz hj">Images</strong>')<br/><strong class="kz hj">batch_size</strong> = 55<br/><strong class="kz hj">image_height</strong> = 216<br/><strong class="kz hj">image_width</strong> = 216</span></pre><p id="783f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我在<strong class="is hj"> Keras </strong> <strong class="is hj"> API </strong>中使用了<strong class="is hj">image _ dataset _ from _ directory</strong>方法来创建和加载数据集。首先，我在<strong class="is hj"> validation_split </strong>参数的帮助下，使用图像的<strong class="is hj"> 90% </strong>创建了<strong class="is hj">训练数据集</strong>。由于这个方法在默认情况下会打乱数据集，所以我不必显式地设置<strong class="is hj"> shuffle </strong>参数。</p><figure class="kp kq kr ks fd ij"><div class="bz dy l di"><div class="li lj l"/></div></figure><p id="4deb" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在Jupyter notebook中成功执行后，该方法返回以下输出。</p><figure class="kp kq kr ks fd ij er es paragraph-image"><div class="er es lk"><img src="../Images/e76a2e7f51b22354fb03bdc748f8a202.png" data-original-src="https://miro.medium.com/v2/resize:fit:926/format:webp/1*yxsVRoeaGKWmgQ66AnDV3w.png"/></div><figcaption class="kt ku et er es kv kw bd b be z dx translated">训练数据集创建摘要</figcaption></figure><p id="9fbd" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">类似地，我使用剩余的10%图像创建了验证数据集，如下所示。</p><figure class="kp kq kr ks fd ij"><div class="bz dy l di"><div class="li lj l"/></div></figure><figure class="kp kq kr ks fd ij er es paragraph-image"><div class="er es lk"><img src="../Images/465c7bc78e664e8e2c2a6cf72f2348c4.png" data-original-src="https://miro.medium.com/v2/resize:fit:926/format:webp/1*fm5DpwqyDs5WBkgG2A-ckQ.png"/></div><figcaption class="kt ku et er es kv kw bd b be z dx translated">验证数据集创建摘要</figcaption></figure><h2 id="28ab" class="jo jp hi bd jq jr js jt ju jv jw jx jy jb jz ka kb jf kc kd ke jj kf kg kh ki bi translated">探索数据集</h2><p id="ef05" class="pw-post-body-paragraph iq ir hi is b it kj iv iw ix kk iz ja jb kl jd je jf km jh ji jj kn jl jm jn hb bi translated">我想检查数据集是否准确地从各自的文件夹名称中导出了类名，以及图像是否正确加载。我通过执行下面的代码做到了这一点。</p><figure class="kp kq kr ks fd ij"><div class="bz dy l di"><div class="li lj l"/></div></figure><p id="2f69" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在这里，我阅读了训练数据集，并通过前9个标签和图像循环。输出如下所示。</p><figure class="kp kq kr ks fd ij er es paragraph-image"><div class="er es ll"><img src="../Images/bdd42e81cdf07080783d703ba1d4ae1b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1188/format:webp/1*XSw3O5MEgRk7DA9yn7JqIw.png"/></div><figcaption class="kt ku et er es kv kw bd b be z dx translated">训练数据集中的前9幅图像和各自的标签</figcaption></figure><h2 id="6d6e" class="jo jp hi bd jq jr js jt ju jv jw jx jy jb jz ka kb jf kc kd ke jj kf kg kh ki bi translated">定义模型</h2><p id="30e8" class="pw-post-body-paragraph iq ir hi is b it kj iv iw ix kk iz ja jb kl jd je jf km jh ji jj kn jl jm jn hb bi translated">然后是创建模型的时候了！</p><p id="7926" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我使用Keras API的<strong class="is hj"> Sequential </strong>类对这个模型中的层进行顺序分组。顺序模型更适合于像这样的简单问题，因为我不打算在模型或其层中处理多个输入或输出。</p><p id="3eea" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我定义了一个非常基本的架构模型，只有3个卷积层，每个卷积层后面都有一个最大池层。来自最后卷积和最大池层的输出被平坦化，并被馈送到具有128个神经元的全连接层。这一层之后是最后一层，它只有两个节点，代表要预测的两个对象类。</p><p id="4413" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">该模型的代码如下。</p><figure class="kp kq kr ks fd ij"><div class="bz dy l di"><div class="li lj l"/></div></figure><p id="c4a0" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">你可能会注意到，在进入第一个卷积层之前，我已经使用一个单独的层重新缩放了图像。像素数据通常在0–255的RGB通道值范围内。这种重新调整背后的想法是通过将每个值转换为0-1范围内的相应值来标准化像素数据。</p><p id="8f59" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">可以使用下面的代码查看这些层的摘要。</p><pre class="kp kq kr ks fd ky kz la lb aw lc bi"><span id="0f1d" class="jo jp hi kz b fi ld le l lf lg">model.summary()</span></pre><figure class="kp kq kr ks fd ij er es paragraph-image"><div class="er es ll"><img src="../Images/b05f158decb98e70b2f96172b09a8986.png" data-original-src="https://miro.medium.com/v2/resize:fit:1188/format:webp/1*PI-V1PcqcqO-loht-EOhzg.png"/></div><figcaption class="kt ku et er es kv kw bd b be z dx translated">model.summary()方法输出</figcaption></figure><h2 id="0157" class="jo jp hi bd jq jr js jt ju jv jw jx jy jb jz ka kb jf kc kd ke jj kf kg kh ki bi translated">编译模型</h2><p id="03ac" class="pw-post-body-paragraph iq ir hi is b it kj iv iw ix kk iz ja jb kl jd je jf km jh ji jj kn jl jm jn hb bi translated">在定义了模型之后，是时候编译它了。</p><p id="a5d7" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这里我使用了<strong class="is hj"> Adam </strong>优化方法和<strong class="is hj">稀疏分类交叉熵</strong>损失函数<strong class="is hj"> </strong>用于模型。</p><figure class="kp kq kr ks fd ij"><div class="bz dy l di"><div class="li lj l"/></div></figure><h2 id="3089" class="jo jp hi bd jq jr js jt ju jv jw jx jy jb jz ka kb jf kc kd ke jj kf kg kh ki bi translated">训练模型</h2><p id="01ba" class="pw-post-body-paragraph iq ir hi is b it kj iv iw ix kk iz ja jb kl jd je jf km jh ji jj kn jl jm jn hb bi translated"><strong class="is hj"> fit </strong>方法用于训练模型，我将训练数据集、验证数据集和<strong class="is hj">时期的数量</strong>传递给它。之后又跑了40个纪元的训练。</p><figure class="kp kq kr ks fd ij"><div class="bz dy l di"><div class="li lj l"/></div></figure><p id="1a70" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">该模型在执行不到10个时期后就开始实现100%的训练和验证准确性。这立即表明，我可以不用节省40个纪元来训练这个模型。</p><figure class="kp kq kr ks fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lm"><img src="../Images/75a49336bc92f078a842f8654c38e7fc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sikggVfWE1Ck3y9EObAroA.png"/></div></div></figure><h2 id="d3b3" class="jo jp hi bd jq jr js jt ju jv jw jx jy jb jz ka kb jf kc kd ke jj kf kg kh ki bi translated">可视化培训绩效</h2><p id="796c" class="pw-post-body-paragraph iq ir hi is b it kj iv iw ix kk iz ja jb kl jd je jf km jh ji jj kn jl jm jn hb bi translated">我使用下面的代码绘制了两个图表，并可视化了整体训练表现。第一个示出了训练和验证的准确性，而另一个示出了相对于执行的时期数的训练和验证损失。</p><figure class="kp kq kr ks fd ij"><div class="bz dy l di"><div class="li lj l"/></div></figure><figure class="kp kq kr ks fd ij er es paragraph-image"><div class="er es ln"><img src="../Images/529ad2786e0e15252047e4bc7fe81079.png" data-original-src="https://miro.medium.com/v2/resize:fit:1072/format:webp/1*xJ7J_L9c_Ch6s-d2LjSZtg.png"/></div><figcaption class="kt ku et er es kv kw bd b be z dx translated">训练和验证准确性以及相对于所执行的时期的相应损失</figcaption></figure><h2 id="8e10" class="jo jp hi bd jq jr js jt ju jv jw jx jy jb jz ka kb jf kc kd ke jj kf kg kh ki bi translated">使用模型进行推理</h2><p id="fcea" class="pw-post-body-paragraph iq ir hi is b it kj iv iw ix kk iz ja jb kl jd je jf km jh ji jj kn jl jm jn hb bi translated">然后是使用模型进行推理的有趣部分！</p><p id="936b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">由于本例中的模型仅用于对两个特定玩具的图像进行分类，所以我使用了一些它们的照片，这些照片在之前的训练集或验证集中没有使用过。</p><p id="6950" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我编写了以下代码来打印测试图像以及模型的相应预测。每个预测都显示为恐龙名称和置信度百分比的组合。</p><figure class="kp kq kr ks fd ij"><div class="bz dy l di"><div class="li lj l"/></div></figure><figure class="kp kq kr ks fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lo"><img src="../Images/cef37e7402ac372c6f34f0606820204f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VaTFPXoPZRpC2CHPqPSM2A.png"/></div></div><figcaption class="kt ku et er es kv kw bd b be z dx translated">具有百分比置信度的模型的预测</figcaption></figure><h2 id="0353" class="jo jp hi bd jq jr js jt ju jv jw jx jy jb jz ka kb jf kc kd ke jj kf kg kh ki bi translated">结论</h2><p id="cf73" class="pw-post-body-paragraph iq ir hi is b it kj iv iw ix kk iz ja jb kl jd je jf km jh ji jj kn jl jm jn hb bi translated">你可能会注意到，这个模型在对这两个玩具进行分类时表现得相当好。然而，在一个例子中，它将腕龙归类为暴龙——也许是被同一张照片中的“蝙蝠侠”形象搞混了。此外，它将这三个玩具的图片归类为Trex，置信度为93%。虽然在这样一个简单的分类器中看到这样的问题并不奇怪，但通过进一步增强训练数据集和调整超参数，结果仍然可以得到改善。</p></div></div>    
</body>
</html>