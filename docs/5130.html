<html>
<head>
<title>Jenkins As Code</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">詹金斯是代码</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/jenkins-as-code-bfdbd8f3dff9?source=collection_archive---------2-----------------------#2021-08-31">https://medium.com/nerd-for-tech/jenkins-as-code-bfdbd8f3dff9?source=collection_archive---------2-----------------------#2021-08-31</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/897d8ba074d96c230331a3a0e26e1ee5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*cz6IR5zL8vCHJ93r.jpg"/></div></div></figure><p id="4ad1" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">到目前为止，在我们的工程博客中，我们已经看到了一些不同的技术和功能，如<a class="ae jo" href="https://www.transifex.com/blog/2021/enhancing-security-applications-vault/" rel="noopener ugc nofollow" target="_blank"> Hashicorp的Vault </a>和<a class="ae jo" href="https://www.transifex.com/blog/2021/shoot-for-the-moon-with-spot-instances-in-aws/" rel="noopener ugc nofollow" target="_blank"> Kubernetes的自动缩放</a>。这一次，我们将回归基础，与Jenkins一起建立CI/CD渠道。</p><p id="eb19" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我认为可以肯定的是，大多数DevOps的工程师已经很熟悉Jenkins了，但是，为了以防万一，这是Jenkins在其<a class="ae jo" href="https://www.jenkins.io/" rel="noopener ugc nofollow" target="_blank">主页</a>上对自己的描述:</p><p id="6751" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">领先的开源自动化服务器Jenkins提供了数百个插件来支持任何项目的构建、部署和自动化。</p><p id="8fd3" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">所以，一言以蔽之，它是一个CI/CD工具。现在回到正题。</p><p id="4b99" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们最近的任务是根据<a class="ae jo" href="https://docs.aws.amazon.com/controltower/latest/userguide/aws-multi-account-landing-zone.html" rel="noopener ugc nofollow" target="_blank"> AWS的最佳实践</a>将我们的Jenkins实例迁移到不同的AWS帐户。作为基础设施即代码(IaC)的铁杆支持者，我们希望用正确的方式，即Terragrunt方式来做这件事。</p><h1 id="d20d" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">那么我们要找的是什么样的设置呢？</h1><ol class=""><li id="3fbc" class="kn ko hi is b it kp ix kq jb kr jf ks jj kt jn ku kv kw kx bi translated">Jenkins可能是一堆插件和依赖项。用代码记录它的初始设置可以很容易地看出使用了什么以及为什么使用。</li><li id="8a35" class="kn ko hi is b it ky ix kz jb la jf lb jj lc jn ku kv kw kx bi translated">没有用户界面设置。这并不是说我们讨厌ui，而是点击几下就能改变行为和组件的事情经常没有记录下来。这意味着，工程师们将会绞尽脑汁试图弄清楚这个设置。经常想到的一句话是:<br/>“当我设置这个的时候，只有上帝和我明白它做了什么……现在只有上帝知道了。”</li><li id="429d" class="kn ko hi is b it ky ix kz jb la jf lb jj lc jn ku kv kw kx bi translated">没有什么比用几个命令行命令来配置基础设施更好的了。</li></ol><p id="cfef" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们看到了这种方法的三个主要优势:</p><ul class=""><li id="7e42" class="kn ko hi is b it iu ix iy jb ld jf le jj lf jn lg kv kw kx bi translated">由于我们正在开发AWS，并且我们不希望Jenkins生活在我们的Kubernetes集群中，我们需要一个通过<a class="ae jo" href="https://docs.aws.amazon.com/autoscaling/ec2/userguide/AutoScalingGroup.html" rel="noopener ugc nofollow" target="_blank">自动扩展组</a>部署的Jenkins服务器的<a class="ae jo" href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/AMIs.html" rel="noopener ugc nofollow" target="_blank"> AMI </a>。这将使我们能够以几乎零停机时间推出新版Jenkins服务器。</li><li id="33e0" class="kn ko hi is b it ky ix kz jb la jf lb jj lc jn lg kv kw kx bi translated">我们需要找到一种方法来提供Jenkins配置(存储库、作业、凭证和插件设置),而根本不需要访问Jenkins UI。在启动Jenkins服务器以及更新配置时，应该加载此配置。</li></ul><h1 id="c94e" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">建立AMI</h1><p id="4229" class="pw-post-body-paragraph iq ir hi is b it kp iv iw ix kq iz ja jb lh jd je jf li jh ji jj lj jl jm jn hb bi translated">因为我们知道Jenkins是行业中的常用工具，所以我们搜索了公共的Jenkins AMIs。我们很快就同意使用Bitnami的Jenkins AMI。</p><p id="455e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">当然，仅仅部署特定的映像是不够的。我们希望所有的插件，我们将使用已经安装，以及其他事情。</p><p id="e3ae" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">为了重新包装AMI，我们使用了哈希公司的另一种工具<a class="ae jo" href="https://www.packer.io/" rel="noopener ugc nofollow" target="_blank">打包机</a>。我们还想将这个过程集成到我们的Terragrunt代码中。最后，我们在Terragrunt存储库中提出了以下文件结构:</p><figure class="ll lm ln lo fd ij er es paragraph-image"><div class="er es lk"><img src="../Images/b94147473d08e90e50aaabe2efe9dbdb.png" data-original-src="https://miro.medium.com/v2/resize:fit:478/format:webp/0*ndHBGqGqCT-7A_JM.png"/></div></figure><p id="b6b5" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在jenkins-master文件夹中运行terragrunt apply应该会创建AMI并公开其属性，这样它就可以在其他模块中作为一个依赖项使用，比如在Auto Scaling组中。</p><p id="6b56" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">为了在terragrunt.hcl文件中实现这一点，我们使用了一个简单的模块来实现<a class="ae jo" href="https://registry.terraform.io/providers/hashicorp/aws/latest/docs/data-sources/ami" rel="noopener ugc nofollow" target="_blank"> Terraform的AMI数据源</a>。不过，重要的一步是实现一个“before_hook ”,在模块检索和公开AMI之前构建AMI。</p><p id="bcae" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">文件的内容最终看起来像这样:</p><p id="30fa" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">terragrunt.hcl</p><pre class="ll lm ln lo fd lp lq lr ls aw lt bi"><span id="8cba" class="lu jq hi lq b fi lv lw l lx ly">terraform {<br/> source = "git::git@github.com:transifex/terraform-modules.git//modules/data-ami?ref=v0.1.44"<br/> before_hook "before_hook" {<br/>   commands = ["apply"]<br/>   execute = [<br/>     "packer",<br/>     "build",<br/>     "-var", "assumed_role=${local.iam_role}",<br/>     "-var", "vpc_id=${local.vpc_id}",<br/>     "-var", "subnet_id=${local.public_subnet}",<br/>     "image/main.pkr.hcl",<br/>   ]<br/> }<br/>}<br/> <br/>locals {<br/> # These can / should be loaded as dependencies from other modules<br/> iam_role = "arn:aws:iam::xxxxxxxx:role/my_role"<br/> public_subnet = "vpc-xxxxxxx"<br/> public_subnet = "sub-xxxxxxx"<br/>}<br/> <br/>include {<br/> path = find_in_parent_folders()<br/>}<br/> <br/>inputs = {<br/> filter_names = ["jenkins-master"]<br/>}</span></pre><p id="32bc" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">图像文件夹将保存打包程序配置和我们编写的供应脚本。</p><p id="f4ad" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">setup.sh</p><pre class="ll lm ln lo fd lp lq lr ls aw lt bi"><span id="0ba4" class="lu jq hi lq b fi lv lw l lx ly"><strong class="lq hj">#!/bin/bash</strong><br/>## Install apt packages that are needed or wanted<br/>apt-get install locate &amp;&amp; updatedb<br/> <br/>## Wait for jenkins to start<br/>function wait_for_jenkins()<br/>{<br/> until $(curl --output /dev/null --silent --head --fail http://localhost/jnlpJars/jenkins-cli.jar); do<br/>   printf '.'<br/>   sleep 5<br/> done<br/> echo "Jenkins launched"<br/>}<br/>wait_for_jenkins<br/> <br/>## Change shell of jenkins user<br/>usermod --shell /bin/bash jenkins<br/> <br/>## Download the jenkins-cli.jar<br/>su - jenkins -c "wget localhost/jnlpJars/jenkins-cli.jar -O /opt/bitnami/jenkins/jenkins_home/jenkins-cli.jar"<br/> <br/>## Retrieve the default admin user password<br/>userpass=$(cat /home/bitnami/bitnami_credentials | grep 'The default username and password is' | rev | cut -d' ' -f1 | cut -d'.' -f2 | sed "s/'//g" | rev)<br/> <br/>## Install Jenkins plugins that are needed (and restart Jenkins)<br/>/opt/bitnami/java/bin/java -jar /opt/bitnami/jenkins/jenkins_home/jenkins-cli.jar -s http://localhost:8080/ -auth user:$userpass install-plugin configuration-as-code blueocean ec2 slack github-autostatus metrics github-pullrequest role-strategy google-login job-dsl basic-branch-build-strategies parameterized-scheduler</span></pre><p id="9fe2" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">main.pkr.hcl</p><pre class="ll lm ln lo fd lp lq lr ls aw lt bi"><span id="565b" class="lu jq hi lq b fi lv lw l lx ly">variable "vpc_id" {<br/> type = string<br/>}<br/> <br/>variable "subnet_id" {<br/> type = string<br/>}<br/> <br/>variable "assumed_role" {<br/> type = string<br/>}<br/> <br/>source "amazon-ebs" "jenkins-master" {<br/> assume_role {<br/>   role_arn = "${var.assumed_role}"<br/> }<br/> <br/> ami_name                = "jenkins-master"<br/> instance_type           = "t2.medium"<br/> region                  = "eu-west-1"<br/> source_ami              = "ami-0562a5f132869dd5a"<br/> ssh_username            = "bitnami"<br/> ami_description         = "Jenkins Master AMI"<br/> shutdown_behavior       = "terminate"<br/> spot_price              = "auto"<br/> spot_price_auto_product = "Linux/UNIX"<br/> <br/> ssh_pty               = true<br/> force_delete_snapshot = true<br/> force_deregister      = true<br/> <br/> // Vpc &amp;&amp; subnet to launch the spot instance<br/> vpc_id    = "${var.vpc_id}"<br/> subnet_id = "${var.subnet_id}"<br/> <br/> // Associate public ip so packer can ssh to provision<br/> associate_public_ip_address = true<br/> // Use the public IP to connect<br/> ssh_interface = "public_ip"<br/>}<br/> <br/> <br/>build {<br/> sources = ["source.amazon-ebs.jenkins-master"]<br/> provisioner "shell" {<br/>   execute_command = "echo '' | sudo -S su - root -c '{{ .Vars }} {{ .Path }}'"<br/>   script          = "image/setup.sh"<br/> }<br/>}</span></pre><p id="b105" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">瞧啊！</p><p id="ec08" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">通过一个简单的“terragrunt apply”命令，我们可以构建我们的映像，并且能够在未来的模块中加载它的属性。</p><h1 id="2c96" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">詹金斯配置代码</h1><p id="e5e7" class="pw-post-body-paragraph iq ir hi is b it kp iv iw ix kq iz ja jb lh jd je jf li jh ji jj lj jl jm jn hb bi translated">在我们寻找自动化Jenkins配置的方法时(在groovy脚本中挣扎了几个小时之后)，我们遇到了下面的插件:<a class="ae jo" href="https://www.jenkins.io/projects/jcasc/" rel="noopener ugc nofollow" target="_blank"> JCaC ( Jenkins配置代码)</a>。是的，顾名思义。Jenkins社区采用的一个插件，其唯一目的是提供在YAML文件中定义Jenkins和插件配置的能力。</p><p id="9e68" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这个文件可以放在Jenkins服务器中，也可以从url加载。最重要的是，您可以让Jenkins实例通过<a class="ae jo" href="https://github.com/jenkinsci/configuration-as-code-plugin/blob/master/docs/features/configurationReload.md" rel="noopener ugc nofollow" target="_blank">点击特定的端点</a>来重新加载配置文件。</p><p id="7b01" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们很快接受了这项任务，并开始使用YAML格式配置我们的Jenkins和插件。end文件太大，太具体，不适合我们在这里分享，但是你可以在JCaC 提供的<a class="ae jo" href="https://github.com/jenkinsci/configuration-as-code-plugin/tree/master/demos" rel="noopener ugc nofollow" target="_blank">演示中找到许多关于如何设置它的例子。</a></p><p id="b7d6" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">或者，如果你正在运行Jenkins，你可以安装插件并<a class="ae jo" href="https://github.com/jenkinsci/configuration-as-code-plugin/blob/master/docs/features/configExport.md" rel="noopener ugc nofollow" target="_blank">导出你当前的配置</a>。一旦我们完成了配置文件的创建，为了让Jenkins可以使用它，我们决定将它添加到一个只有Jenkins可以访问的私有S3存储桶中。像往常一样，我们用Terragrunt来做这个。现在还剩两个项目:</p><ol class=""><li id="cca7" class="kn ko hi is b it iu ix iy jb ld jf le jj lf jn ku kv kw kx bi translated">当发生更改时，让Jenkins重新加载文件</li><li id="d7de" class="kn ko hi is b it ky ix kz jb la jf lb jj lc jn ku kv kw kx bi translated">在Jenkins的初始化中提供文件url，以便可以在启动时发现它。</li></ol><p id="f507" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">对于第一项，简单到在将文件上传到s3的“terragrunt apply”中添加一个“after_hook ”:</p><p id="5bf8" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">terragrunt.hcl</p><pre class="ll lm ln lo fd lp lq lr ls aw lt bi"><span id="6316" class="lu jq hi lq b fi lv lw l lx ly">terraform {<br/> source = "git::git@github.com:terraform-aws-modules/terraform-aws-s3-bucket.git//modules/object?ref=v1.25.0"<br/> <br/> after_hook "after_hook" {<br/>   commands     = ["apply"]<br/>   execute      = ["curl", "-X", "POST", "jenkins.domain/reload-configuration-as-code/?casc-reload-token=xxxxxxxx"<br/> }<br/>}</span><span id="932b" class="lu jq hi lq b fi lz lw l lx ly">...</span></pre><p id="d467" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这意味着每次我们更新配置文件时，都会向Jenkins发送一个重新加载配置的帖子。</p><p id="3cc0" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">为了确保Jenkins也会在初始化时加载该文件，我们返回到上一步中构建的AMI，并更改了配置脚本以提供必要的配置:</p><p id="ac9a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">main.pkr.hcl</p><pre class="ll lm ln lo fd lp lq lr ls aw lt bi"><span id="edf1" class="lu jq hi lq b fi lv lw l lx ly">...<br/>build {<br/> sources = ["source.amazon-ebs.jenkins-master"]<br/> provisioner "shell" {<br/>   environment_vars = [<br/>     "jenkins_casc_token=${var.jenkins_casc_token}",<br/>     "vpc_endpoint=${var.vpc_endpoint}"<br/>   ]<br/>   execute_command = "echo '' | sudo -S su - root -c '{{ .Vars }} {{ .Path }}'"<br/>   script          = "image/setup.sh"<br/> }<br/>}</span></pre><p id="d10b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">setup.sh</p><pre class="ll lm ln lo fd lp lq lr ls aw lt bi"><span id="f466" class="lu jq hi lq b fi lv lw l lx ly">...<br/>## Jenkins configuration as code options<br/>sed "s,\"javaOpts\": \"\",\"javaOpts\": \"-Dcasc.reload.token=$jenkins_casc_token -Dcasc.jenkins.config=$vpc_endpoint\",g" -i /root/.nami/registry.json</span></pre><p id="bb8e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">terragrunt.hcl</p><pre class="ll lm ln lo fd lp lq lr ls aw lt bi"><span id="e740" class="lu jq hi lq b fi lv lw l lx ly">terraform {<br/> source = "git::git@github.com:transifex/terraform-modules.git//modules/data-ami?ref=v0.1.44"<br/> before_hook "before_hook" {<br/>   commands = ["apply"]<br/>   execute = [<br/>     "packer",<br/>     "build",<br/>     "-var", "assumed_role=${local.iam_role}",<br/>     "-var", "vpc_id=${local.vpc_id}",<br/>     "-var", "subnet_id=${local.public_subnet}",<br/>     "-var", "jenkins_casc_token=${local.casc_token"]}",<br/>     "-var", "vpc_endpoint=${local.s3_endpoint}",<br/>     "image/main.pkr.hcl",<br/>   ]<br/> }<br/>}<br/> <br/>locals {<br/> # These can / should be loaded as dependencies from other modules<br/> iam_role = "arn:aws:iam::xxxxxxxx:role/my_role"<br/> public_subnet = "vpc-xxxxxxx"<br/> public_subnet = "sub-xxxxxxx"<br/> casc_token = "xxxxxxxxxxx"<br/> s3_endpoint = "xxxxxxxxxxx"<br/>}<br/> <br/>...</span></pre><p id="de21" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在，有了这些更改，配置文件可以在启动时加载了！</p><h1 id="9d77" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">播种你的工作</h1><p id="ed49" class="pw-post-body-paragraph iq ir hi is b it kp iv iw ix kq iz ja jb lh jd je jf li jh ji jj lj jl jm jn hb bi translated">虽然CasC解决了我们的大部分配置问题，但有一件事它做不到，至少自己做不到，那就是创造我们的詹金斯工作岗位。为了实现这一点，你需要另一个插件，<a class="ae jo" href="https://plugins.jenkins.io/job-dsl/" rel="noopener ugc nofollow" target="_blank"> job-dsl </a>，它可以与CasC协同工作。</p><p id="f9c8" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">job-dsl允许您在前面创建的Jenkins配置文件中定义编程作业。如果我在这里没有提到这不适合心脏虚弱的人，那我就失职了。虽然使用这个插件，您可以创建惊人的自动化，但文档在许多地方是缺乏的，并且需要大量的尝试和错误才能达到良好的效果。</p><p id="0fe7" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在我们的例子中，我们希望提供我们的github组织和一些包含他们自己的Jenkinsfiles的精选存储库。为此，我们使用了一个<a class="ae jo" href="https://jenkinsci.github.io/job-dsl-plugin/#method/javaposse.jobdsl.dsl.DslFactory.organizationFolder" rel="noopener ugc nofollow" target="_blank">组织文件夹</a>。这是我们使用的脚本(与我们配置的其余部分一起位于YAML文件中)。</p><pre class="ll lm ln lo fd lp lq lr ls aw lt bi"><span id="3de1" class="lu jq hi lq b fi lv lw l lx ly">jobs:<br/> - script: &gt;<br/>     organizationFolder('Transifex') {<br/>       description("Transifex organization folder configured with JCasC")<br/>       displayName('Transifex')<br/>       buildStrategies {<br/>         buildChangeRequests {<br/>           ignoreTargetOnlyChanges(true)<br/>           ignoreUntrustedChanges(true)<br/>         }<br/>         skipInitialBuildOnFirstBranchIndexing()<br/>       }<br/>       triggers {}<br/>       // "Projects"<br/>       organizations {<br/>         github {<br/>           repoOwner("transifex")<br/>           credentialsId("xxxxxxx")<br/>           traits {<br/>             // Discovers branches on the repository.<br/>             gitHubBranchDiscovery {<br/>               // Determines which branches are discovered.<br/>               // 1 = Exclude branches that are also filed as PRs<br/>               strategyId(1)<br/>             }<br/>             gitHubPullRequestDiscovery {<br/>               // Determines how pull requests are discovered: Merging the pull request with the current target branch revision Discover each pull request once with the discovered revision corresponding to the result of merging with the current revision of the target branch.<br/>               // 1 = Merging the pull request with the current target branch revision<br/>               strategyId(1)<br/>             }<br/>             gitHubExcludeArchivedRepositories()<br/>             sourceWildcardFilter {<br/>               // Space-separated list of project (repository) name patterns to consider.<br/>               includes("xxxxx yyyyyy zzzzzz")<br/>               excludes("")<br/>             }<br/>           }<br/>         }<br/>       }<br/>     }<br/> <br/>...</span></pre><h1 id="ba35" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">最终注释</h1><p id="e478" class="pw-post-body-paragraph iq ir hi is b it kp iv iw ix kq iz ja jb lh jd je jf li jh ji jj lj jl jm jn hb bi translated">总而言之，我们不得不承认向Jenkins提供IaC原则对我们团队来说是一次令人厌倦的经历。许多项目没有记录或者记录得很差，我们的问题的答案从来都不明显。但是一旦完成，就很容易修改和跟踪。</p><p id="3fc9" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">假设我们未来需要一个新的Jenkins，那么只需写几行代码和编辑几个文件就可以了。所有这些都将永远记录在我们的资料库中。我们希望这篇文章能为未来敢于探索这些道路的勇敢的工程师们提供一盏指路明灯。</p></div></div>    
</body>
</html>