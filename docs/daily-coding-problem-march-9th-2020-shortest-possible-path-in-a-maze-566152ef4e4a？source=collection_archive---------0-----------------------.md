# (每日编码问题:2020 年 3 月 9 日)迷宫中最短的可能路径

> 原文：<https://medium.com/nerd-for-tech/daily-coding-problem-march-9th-2020-shortest-possible-path-in-a-maze-566152ef4e4a?source=collection_archive---------0----------------------->

![](img/37ea23b3ef6f874e9b53dadb131a5c4a.png)

嘿伙计们，欢迎回来！这个博客是我们每天解决一个问题系列的延续，感谢 [**日常编码问题**](https://www.dailycodingproblem.com/) **。**

**问题:-** 给你一个 M 乘 N 的矩阵，由表示棋盘的布尔型组成。每个真布尔值代表一面墙。每个假布尔表示一个你可以在上面行走的瓷砖。

给定此矩阵、起始坐标和结束坐标，返回从起点到达结束坐标所需的最少步数。如果没有可能的路径，则返回 null。你可以上下左右移动。你不能穿越墙壁。你不能绕过木板的边缘。

例如，给定以下板:

```
[[f, f, f, f],
[t, t, f, t],
[f, f, f, f],
[f, f, f, f]]
```

start = `(3, 0)`(左下角)和 end = `(0, 0)`(左上角)，到达终点所需的最少步数是 7，因为我们需要通过`(1, 2)`，因为第二排的其他地方都有墙。

**解法:-** 看完问题，脑海里浮现的初始算法是 **DP** (动态编程)。

下面提到的是我看到这个问题后想到的主意

```
1 + min(dist(i-1,j), dist(i+1,j), dist(i,j-1), dist(i,j+1));
```

在做了一次测试后，我发现这将会是一个无限循环。因此，我开始寻找各种迷宫解决算法，这时候我遇到了 [**李算法**](https://en.wikipedia.org/wiki/Lee_algorithm) **。**

现在，在进入最终解决方案之前，让我们先看一下李的算法。

根据维基百科的文章， **Lee 算法**是基于[广度优先搜索](https://en.wikipedia.org/wiki/Breadth-first_search)的[迷宫路由问题](https://en.wikipedia.org/wiki/Maze_router)的一种可能的解决方案。如果存在的话，它总是给出一个最优解，但是很慢并且需要相当大的内存。

1.  创建一个空队列和一个空 2d 数组来标记访问过的节点。
2.  检查起始坐标上是否有墙(如果矩阵有“t”值)。如果是，则返回-1 或整数。MAX_VALUE 否则，将距离标记为 0 的起点坐标推入队列，并将元素标记为已访问。
3.  重复下面提到的步骤，直到队列不为空-
    a .从队列中弹出一个元素。

    b .检查弹出的元素是否是目的坐标，如果是，**返回弹出元素的距离。**

    c .将所有有效元素向 4 个方向(上、下、左、右)推送，距离为队列中**弹出元素距离+1** 。

    有效元素是符合以下标准的元素:-

```
isValid(boolean value, int M, int N, boolean visit, int i, int j) {
   return !(i < 0 || j < 0 || i >= M || j >= N || !value || visit)
}
```

4.如果队列为空，则返回-1 或整数。MAX_VALUE，因为没有到达目的地坐标的路径。

下面是基于这种方法的问题的 java 代码实现

**时间复杂度:-** O(MN) **空间复杂度:-** O(MN)

**为更好地理解数据结构和算法而阅读的书籍-**

*   [数据结构和算法变得简单:数据结构和算法难题，第二版](https://amzn.to/2NmpRoy)

![](img/0e365336c5214bdb38df31fa32eced56.png)

以上是我的观点，非常感谢你阅读我的博客。我将继续这个系列，继续讨论日常问题。如需进一步讨论，请随时联系我，电话号码是*divyabiyani26@gmail.com。*