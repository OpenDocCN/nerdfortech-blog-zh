<html>
<head>
<title>Mastering MonoRepos with CircleCI’s new Dynamic Config</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用 CircleCI 的新动态配置掌握 MonoRepos</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/mastering-monorepos-with-circlecis-new-dynamic-config-2e187fe7934c?source=collection_archive---------0-----------------------#2021-05-03">https://medium.com/nerd-for-tech/mastering-monorepos-with-circlecis-new-dynamic-config-2e187fe7934c?source=collection_archive---------0-----------------------#2021-05-03</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="3c41" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">您是否曾希望将您的微服务、库和应用整合到一个 monorepo 中，但由于管理构建和部署过于困难而避免这样做？如果是这样，不要再烦恼了…</p><p id="236e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在本文中，我将带您了解<strong class="ih hj">如何设置 CircleCI 来分析 monorepo </strong>中的文件更改，然后触发 CircleCI 管道，由<strong class="ih hj">构建并部署 monorepo </strong>的特定子部分。当应用于您自己的项目时，这可以通过在您的 repo 中的最小模块集上选择性地执行工作流来显著地简化您的 CI/CD 管道并降低成本。</p><p id="2340" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">坚持阅读，实现 monorepo 涅槃…</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es jd"><img src="../Images/99020df6e363a1e35a660adf89ffdca5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UuklLVmwSPPwplOcPF5_Fg.jpeg"/></div></div><figcaption class="jp jq et er es jr js bd b be z dx translated">看守的泽尼亚塔被克劳迪奥·阿莫罗索<a class="ae jt" href="https://www.artstation.com/claudioamoroso" rel="noopener ugc nofollow" target="_blank">超越</a></figcaption></figure><h1 id="1cd3" class="ju jv hi bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">它是如何工作的？</h1><p id="beda" class="pw-post-body-paragraph if ig hi ih b ii ks ik il im kt io ip iq ku is it iu kv iw ix iy kw ja jb jc hb bi translated">这现在是可能的，这要感谢<a class="ae jt" href="https://circleci.com/blog/introducing-dynamic-config-via-setup-workflows/" rel="noopener ugc nofollow" target="_blank"> CircleCI 刚刚宣布的</a>的一个强大功能，叫做<strong class="ih hj">动态配置</strong>。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es kx"><img src="../Images/3a37c2dec6da27f5fe96f75653975822.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8jJvIDEOvdKLan4eSnGlWw.png"/></div></div></figure><p id="bca9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在深入研究这个特性之前，让我们回顾一下我们对 monorepos 和 CircleCI piplines 的了解。</p><h1 id="7268" class="ju jv hi bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">MonoRepos</h1><p id="aee5" class="pw-post-body-paragraph if ig hi ih b ii ks ik il im kt io ip iq ku is it iu kv iw ix iy kw ja jb jc hb bi translated">可以肯定地说<strong class="ih hj"> monorepos 在开发者中可能会非常两极分化</strong>。有些人更喜欢应用程序、库或微服务存在于自己的专用存储库中。还有一些人更喜欢一个超级整体仓库。</p><p id="264c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我喜欢 monorepos，因为它有很多好处，比如<strong class="ih hj">简化的代码重用、跨模块/应用的原子提交、更简单的依赖管理和全面的搜索。</strong></p><p id="0c1f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">一个主要的缺点(到目前为止)是<strong class="ih hj">随着 monorepo 的增长，难以扩展构建和部署过程</strong>。CircleCI 的动态配置完全改变了…</p><h1 id="bf44" class="ju jv hi bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">传统环形管道</h1><p id="3c10" class="pw-post-body-paragraph if ig hi ih b ii ks ik il im kt io ip iq ku is it iu kv iw ix iy kw ja jb jc hb bi translated">在 CircleCI 中，工作流通常在变更被推送到存储库分支时被触发。采用连续部署的项目可能有一个触发构建/测试工作流的<code class="du ky kz la lb b">development</code>分支和一个触发构建/测试/docker-image/deploy 工作流的<code class="du ky kz la lb b">master</code>分支。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es lc"><img src="../Images/f853cfe93b69718fcfffe738ead14074.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XfKTh74mMXxCQBQWNhxsyg.jpeg"/></div></div><figcaption class="jp jq et er es jr js bd b be z dx translated">连续部署管道的一个例子</figcaption></figure><p id="0440" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">开箱即用，<strong class="ih hj"> CircleCI 工作流不容易根据作为传入变更集的结果而改变了</strong>的文件/模块进行更改。这意味着您必须“构建世界”，以确保可能受变更集影响的模块被重新构建以合并它。</p><p id="4f73" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">在拥有许多模块/应用/库的大型 monorepo 中，这是无法扩展的。</strong>像谷歌、脸书、优步和推特这样的大公司(它们都雇佣超级 monorepos)有基础设施来构建复杂的工具来处理这个问题。得益于 CircleCI 的动态配置和两个强大的 orb，这对于较小的公司和团队来说更容易实现。</p><h1 id="0e46" class="ju jv hi bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">了解动态配置</h1><p id="848b" class="pw-post-body-paragraph if ig hi ih b ii ks ik il im kt io ip iq ku is it iu kv iw ix iy kw ja jb jc hb bi translated">为了在 monorepo 中设置选择性构建，我们首先需要理解动态配置是如何工作的。</p><p id="7efe" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在标准的“静态”存储库中，<code class="du ky kz la lb b">.circleci/config.yml</code>文件定义了项目的命令/作业/工作流。</p><p id="568a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">使用动态配置时，该过程分为两个阶段:设置<em class="ld">阶段和继续<em class="ld">阶段。静态配置文件在<em class="ld">设置</em>阶段执行，可以:</em></em></p><ol class=""><li id="5b13" class="le lf hi ih b ii ij im in iq lg iu lh iy li jc lj lk ll lm bi translated">动态生成另一个配置文件，用于<em class="ld">延续</em>阶段</li><li id="afd8" class="le lf hi ih b ii ln im lo iq lp iu lq iy lr jc lj lk ll lm bi translated">通过将当前变更集与基本修订进行比较来分析文件更改</li><li id="cbc7" class="le lf hi ih b ii ln im lo iq lp iu lq iy lr jc lj lk ll lm bi translated">设置将被传递到<em class="ld">延续</em>阶段的构建参数/标志</li><li id="1ea7" class="le lf hi ih b ii ln im lo iq lp iu lq iy lr jc lj lk ll lm bi translated">触发<em class="ld">延续</em>阶段</li></ol><p id="b3cf" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">操作 1 对于非常高级的管道非常有用，但对于在 monorepo 中实现选择性构建是不必要的。因此，在本练习中，我们将只执行操作 2、3 和 4。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es ls"><img src="../Images/ddadb314b5d7c9d0e893e050115a5281.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Z3j1jfbs2sH4-7tW1ZZrGQ.jpeg"/></div></div><figcaption class="jp jq et er es jr js bd b be z dx translated">CircleCI 选择性构建的设置阶段和延续阶段</figcaption></figure><p id="76d5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">支持这一强大功能的两个 orb 是:</p><ol class=""><li id="fbc5" class="le lf hi ih b ii ij im in iq lg iu lh iy li jc lj lk ll lm bi translated"><a class="ae jt" href="https://circleci.com/developer/orbs/orb/circleci/path-filtering" rel="noopener ugc nofollow" target="_blank">circle ci/路径过滤</a></li><li id="0f46" class="le lf hi ih b ii ln im lo iq lp iu lq iy lr jc lj lk ll lm bi translated"><a class="ae jt" href="https://circleci.com/developer/orbs/orb/circleci/continuation" rel="noopener ugc nofollow" target="_blank"> circleci/continuation </a></li></ol><p id="d2f5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><code class="du ky kz la lb b">circleci/path-filtering</code> orb 允许您定义应用于 git commit diff 的正则表达式，然后根据已经更改的文件/文件夹设置特定的构建参数。</p><p id="23d6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在引擎盖下，<code class="du ky kz la lb b">circleci/path-filtering</code> orb 调用<code class="du ky kz la lb b">circleci/continuation</code> orb 来启动<em class="ld">延续</em>阶段配置，并将构建参数传递给它。</p><h1 id="3eb0" class="ju jv hi bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">我的单回购结构</h1><p id="b57f" class="pw-post-body-paragraph if ig hi ih b ii ks ik il im kt io ip iq ku is it iu kv iw ix iy kw ja jb jc hb bi translated">在深入 CircleCI 配置文件的细节之前，我将解释一下我为<a class="ae jt" href="https://www.styleguise.net" rel="noopener ugc nofollow" target="_blank"> StyleGuise </a>使用的 monorepo 以及其中的各种模块/服务。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es lt"><img src="../Images/87d848ce1ec527223abee3f7c4445d94.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*k_TIS7I73CMIttt1YCQxXQ.jpeg"/></div></div><figcaption class="jp jq et er es jr js bd b be z dx translated">monorepo 中主要模块的高级视图</figcaption></figure><p id="26fa" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">通过虚线箭头连接的模块表示必须独立构建/部署的“弱”依赖性。他们所依赖的上游契约应该在不破坏下游模块的情况下发展。</p><p id="c45d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">实线箭头表示“强”编译时依赖关系。当上游模块发生变化时，必须重建“强连接”的下游模块。</p><p id="952e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在文件系统上，monorepo 如下所示:</p><pre class="je jf jg jh fd lu lb lv lw aw lx bi"><span id="ac45" class="ly jv hi lb b fi lz ma l mb mc">monorepo<br/>  |<br/>  |-- service<br/>  |   |-- site-api<br/>  |   |    \-- pom.xml<br/>  |   |-- batch<br/>  |   |    \-- pom.xml<br/>  |   |-- common (service-layer)<br/>  |   |    \--pom.xml<br/>  |   |-- pom.xml<br/>  |<br/>  |-- data (common-config)<br/>  |    \-- pom.xml<br/>  |<br/>  |-- ui (site-ui)<br/>  |   |-- build.sbt<br/>  |   |-- package.json<br/>  |<br/>  |-- admin-ui<br/>  |   |-- package.json<br/>  |<br/>  |-- product-classifier<br/>  |   |-- api<br/>  |   |    \-- pom.xml<br/>  |   |-- trainer<br/>  |   |    \-- pom.xml<br/>  |   |-- common<br/>  |   |    \-- pom.xml<br/>  |   |-- pom.xml<br/>  |<br/>  |-- functions (azure serverless functions)<br/>  |   |-- pom.xml<br/>  |<br/>  |-- pom.xml</span></pre><p id="5a99" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如您所见，有多种构建工具用于构建各种子系统:maven(针对 Java 模块)、node . js+vue-CLI+web pack+dart-sass(针对 VueJS 模块)和 sbt(针对基于 scala 的 web 前端)。</p><p id="d28f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Java 应用程序中还使用了各种各样的库。例如，产品分类器使用<a class="ae jt" href="https://deeplearning4j.org" rel="noopener ugc nofollow" target="_blank"> deeplearning4j </a>，无服务器功能依赖于<a class="ae jt" href="https://github.com/Azure/azure-sdk-for-java" rel="noopener ugc nofollow" target="_blank"> Azure 特定的库</a>。为了避免库/jar 文件之间的交叉污染，这些模块彼此完全独立，拥有自己的<code class="du ky kz la lb b">pom.xml</code>文件，并构建在隔离的 CircleCI docker 作业中。</p><p id="b735" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">顶层<code class="du ky kz la lb b">pom.xml</code>负责定义子模块、插件和库版本。</p><h1 id="d4f4" class="ju jv hi bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">启用动态配置</h1><p id="0045" class="pw-post-body-paragraph if ig hi ih b ii ks ik il im kt io ip iq ku is it iu kv iw ix iy kw ja jb jc hb bi translated">在 CircleCI 项目设置中，在“高级”选项卡下，动态配置处于打开状态。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es md"><img src="../Images/369657f533773b20e2d9c5abd93f5285.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Sd5Y4qmWMFvu5s_-If46iQ.png"/></div></div></figure><p id="ccfd" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果你忘记这样做，你可能会在你的 CircleCI 仪表盘上看到一个错误，比如<br/> <code class="du ky kz la lb b">Continuation config contains setup stanza whilst not in setup anymore.</code></p><h1 id="37ea" class="ju jv hi bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">CircleCI 设置配置. yml</h1><p id="1ca0" class="pw-post-body-paragraph if ig hi ih b ii ks ik il im kt io ip iq ku is it iu kv iw ix iy kw ja jb jc hb bi translated"><em class="ld">设置</em>相位配置非常简单。</p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="me mf l"/></div></figure><p id="f074" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">当 CircleCI 执行这个工作流时，<code class="du ky kz la lb b">path-filtering/filter</code>作业在触发工作流的提交和基础修订之间生成一个 git diff。</p><p id="9827" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在我的例子中，我已经将我的基础修订定义为<code class="du ky kz la lb b">master</code>分支。当与我的<code class="du ky kz la lb b">master</code>分支相比时，任何推送到我的<code class="du ky kz la lb b">development</code>分支的提交将固有地产生差异。</p><p id="eaf7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">一旦我准备好将变更部署到产品中，<code class="du ky kz la lb b">development</code>就被合并到<code class="du ky kz la lb b">master</code>中，并被推送到 GitHub。orb 足够智能，可以检测到与基础修订版相同的分支上的提交。在这个场景中，orb 将新提交与<code class="du ky kz la lb b">master</code>分支(又名<code class="du ky kz la lb b">HEAD~1</code>)上的前一个提交进行比较。</p><p id="0dd0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">然后将在<code class="du ky kz la lb b">mapping</code>块中定义的正则表达式应用于 git diff 文件列表。<code class="du ky kz la lb b">mapping</code>块由空格分隔的三元组组成:</p><pre class="je jf jg jh fd lu lb lv lw aw lx bi"><span id="6d58" class="ly jv hi lb b fi lz ma l mb mc">&lt;regexp applied to file list&gt; &lt;build property&gt; &lt;property value&gt;</span></pre><p id="57e1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果一个<code class="du ky kz la lb b">regular expressions</code>匹配，那么其相应的<code class="du ky kz la lb b">build property</code>被设置为已定义的<code class="du ky kz la lb b">property value</code>。</p><p id="e19d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在我的例子中，属性只是作为标志，通知由<code class="du ky kz la lb b">config-path</code>指定的<em class="ld">延续</em>配置文件中定义的工作流。</p><h1 id="95b8" class="ju jv hi bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">CircleCI 延续工作流. yml</h1><p id="14e7" class="pw-post-body-paragraph if ig hi ih b ii ks ik il im kt io ip iq ku is it iu kv iw ix iy kw ja jb jc hb bi translated">延续文件定义了构建参数(第 7 行)、作业(第 51 行)和工作流(第 260 行)。</p><p id="9aa7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">值得注意的是，每个构建参数默认为<code class="du ky kz la lb b">false</code>。这确保了工作流仅在<em class="ld">设置</em>阶段配置确定 monorepo 的相应子部分已更改时执行。</p><p id="c7a5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">使用<code class="du ky kz la lb b">when</code>块有条件地执行每个工作流(第 262、276、290、300、310、320 行)。使用<code class="du ky kz la lb b">or</code>条件(第 263、277 行)触发具有多重/传递子依赖的模块。</p><p id="e395" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">最后，只有在<code class="du ky kz la lb b">master</code>分支上发生提交时，部署作业才会被触发。</p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="me mf l"/></div></figure><h1 id="d2d1" class="ju jv hi bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">您将在 CircleCI 仪表盘上看到的内容</h1><p id="2049" class="pw-post-body-paragraph if ig hi ih b ii ks ik il im kt io ip iq ku is it iu kv iw ix iy kw ja jb jc hb bi translated">这里您可以看到对<code class="du ky kz la lb b">monorepo/admin-ui</code>模块进行更改的结果。请注意<em class="ld">设置</em>阶段工作流程上的特殊<strong class="ih hj">设置</strong>标签，表明 CircleCI 识别了它。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es mg"><img src="../Images/cd4fe250dd4f3ffc8bec099af021e3f4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SFUm1TXLuA412l6dSJpLJw.jpeg"/></div></div></figure><p id="d30d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这里您可以看到一个影响所有模块的更改的示例。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es mh"><img src="../Images/858a20fa93316bcc3d1b4c0e50784abe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7783WcmOtIBUwd6iyZNzRw.jpeg"/></div></div></figure><h1 id="8df0" class="ju jv hi bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">结论</h1><p id="3567" class="pw-post-body-paragraph if ig hi ih b ii ks ik il im kt io ip iq ku is it iu kv iw ix iy kw ja jb jc hb bi translated">CircleCI 动态配置是一个非常强大的特性，可以在运行时简化和操作构建，具有巨大的成本节约潜力。这个例子只是开始触及可能的表面…但它清楚地表明，monorepos 和基于文件更改的选择性构建管道最终是可以实现的。CircleCI 团队推出这一惊人功能的主要道具！感谢阅读！</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es jd"><img src="../Images/faeb27ddb6d072a51624223be66356bb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yz_F8faEPLiwevC-ETWS9A.jpeg"/></div></div><figcaption class="jp jq et er es jr js bd b be z dx translated">Zenyatta 在和平的阴影下</figcaption></figure></div></div>    
</body>
</html>