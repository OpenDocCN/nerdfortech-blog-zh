<html>
<head>
<title>Postgres — Query Performance Tuning</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Postgres —查询性能调优</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/postgres-performance-tuning-e3016eda77b4?source=collection_archive---------7-----------------------#2021-04-01">https://medium.com/nerd-for-tech/postgres-performance-tuning-e3016eda77b4?source=collection_archive---------7-----------------------#2021-04-01</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/3c985035055598b3b2b3f56513272a87.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*jQ5Jv2ETTn908Mfp.jpg"/></div></div></figure><p id="254e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">场景:</strong></p><p id="7dd1" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们有一个Prod数据库运行在Amazon Aurora PostgreSQL上。在使用CloudWatch Logs Insights进行慢速查询分析期间(这是另一篇文章)，我在大约10秒钟内运行了一个查询。(如果所有数据块都在缓存中，则磁盘读取需要5分钟以上的时间)。</p><p id="2fb9" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">是的，这里的一个选项是使用<strong class="is hj"> pg_prewarm </strong>扩展简单地缓存数据(索引)。</p><p id="ec23" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">查询:</strong></p><pre class="jo jp jq jr fd js jt ju jv aw jw bi"><span id="2236" class="jx jy hi jt b fi jz ka l kb kc">explain (analyze, buffers)<br/>SELECT tabalias.rid,<br/>       tabalias.col1,<br/>       tabalias.col2,<br/>       tabalias.col3,<br/>       tabalias.col4,<br/>       tabalias.dis_id,<br/>       tabalias.col5,<br/>       tabalias.processed_date,<br/>       tabalias.col6,<br/>       tabalias.col7,<br/>       tabalias.col8,<br/>       tabalias.col8,<br/>       tabalias.col9,<br/>       tabalias.col10,<br/>       tabalias.col11,<br/>       tabalias.o_id,<br/>       tabalias.col12<br/>FROM   testtable tabalias<br/>WHERE tabalias.processed_date &gt;= '18-dec-2020'<br/>AND   tabalias.processed_date &lt;= '18-jan-2021'<br/>AND   (tabalias.o_id IN ('US'))<br/>AND   (tabalias.dis_id IN ('VAL1','VAL2','VAL3','VAL4','VAL5'))<br/>ORDER BY tabalias.rid;</span></pre><p id="d6f0" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">注意:</strong>我已经更改了这篇博文的表格和列名。</p><p id="f0af" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">当前查询计划:</strong></p><pre class="jo jp jq jr fd js jt ju jv aw jw bi"><span id="e53b" class="jx jy hi jt b fi jz ka l kb kc">Sort  (cost=508512.99..508600.74 rows=35097 width=124) (actual time=9197.968..9198.468 rows=4707 loops=1)<br/>   Sort Key: rid<br/>   Sort Method: quicksort  Memory: 1443kB<br/>   Buffers: shared hit=470537<br/>   -&gt;  Bitmap Heap Scan on testtable tabalias  (cost=462676.21..505863.34 rows=35097 width=124) (actual time=9187.705..9195.001 rows=4707 loops=1)<br/>         Recheck Cond: (((dis_id)::text = ANY ('{VAL1,VAL2,VAL3,VAL4,VAL5}'::text[])) AND (processed_date &gt;= '2020-12-18 00:00:00'::timestamp without time zone) AND (processed_date &lt;= '2021-01-18 00:00:00'::timestamp without time zone))<br/>         Filter: ((o_id)::text = 'US'::text)<br/>         Rows Removed by Filter: 3<br/>         Heap Blocks: exact=4589<br/>         Buffers: shared hit=470537<br/>         -&gt;  <strong class="jt hj">BitmapAnd</strong>  (cost=462676.21..462676.21 rows=39906 width=0) (actual time=9186.433..9186.433 rows=0 loops=1)<br/>               Buffers: shared hit=465948<br/>               -&gt;  Bitmap Index Scan on dis_id_indx  (cost=0.00..9451.54 rows=733641 width=0) (actual time=60.723..60.723 rows=229752 loops=1)<br/>                     Index Cond: ((dis_id)::text = ANY ('{VAL1,VAL2,VAL3,VAL4,VAL5}'::text[]))<br/>                     <strong class="jt hj">Buffers: shared hit=1256</strong><br/>               -&gt;  Bitmap Index Scan on vr_acct_dist_leid_idx  (cost=0.00..453206.87 rows=22201730 width=0) (actual time=9038.687..9038.687 rows=22853543 loops=1)<br/>                     Index Cond: ((processed_date &gt;= '2020-12-18 00:00:00'::timestamp without time zone) AND (processed_date &lt;= '2021-01-18 00:00:00'::timestamp without time zone))<br/>                     <strong class="jt hj">Buffers: shared hit=464692</strong><br/> Planning time: 0.383 ms<br/> Execution time: 9199.731 ms</span></pre><p id="2984" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">查看查询计划，我们可以看到Planner对两个筛选列使用了两个索引— <strong class="is hj"> dis_id </strong>和<strong class="is hj"> processed_date </strong>，然后对这两个索引执行位图索引连接。</p><blockquote class="kd ke kf"><p id="85ea" class="iq ir kg is b it iu iv iw ix iy iz ja kh jc jd je ki jg jh ji kj jk jl jm jn hb bi translated"><strong class="is hj">位图索引连接:</strong>位图索引连接在谓词列上有单独索引而没有复合索引的情况下很有用。它就像两个索引的内部连接。在连接索引后，如果得到的行数较少，那么表堆访问的开销会更小，因为只需要对少数元组进行堆扫描。</p></blockquote><p id="8840" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在来看一下<strong class="is hj">缓冲区:共享命中</strong>，这里成本较高的部分是processed_date上的第二次索引扫描，因为这是由于查询中的1年过滤条件而扫描大量数据。让我们获得两个过滤器列的计数/基数细节。</p><pre class="jo jp jq jr fd js jt ju jv aw jw bi"><span id="dd5e" class="jx jy hi jt b fi jz ka l kb kc">select count(*), count(distinct dis_id), count(distinct processed_date) from testtable;</span><span id="0e5f" class="jx jy hi jt b fi kk ka l kb kc">count   | count  |  count<br/>-----------+--------+---------<br/> 408243990 | 492622 | 9517490</span></pre><p id="543a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在<strong class="is hj"> pg_stats </strong>表格中查找统计数据。</p><pre class="jo jp jq jr fd js jt ju jv aw jw bi"><span id="9f6e" class="jx jy hi jt b fi jz ka l kb kc">select tablename,attname,n_distinct from pg_stats where tablename='testtable' and attname in ('dis_id','processed_date');</span><span id="cad0" class="jx jy hi jt b fi kk ka l kb kc">       tablename        |    attname     | n_distinct<br/>------------------------+----------------+------------<br/> testtable | dis_id |       <strong class="jt hj">4516</strong><br/> testtable | processed_date |      <strong class="jt hj">16433</strong></span></pre><p id="60af" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们可以看到dis_id列有大约. 5M个不同的值，还不错。我们可以猜测，如果计划程序可以只在<strong class="is hj"> dis_id </strong>列上使用索引，然后在堆扫描之后过滤processed_date上的值，这可能是一个更好的计划。与其他许可的RDBMS不同，Postgres没有提供太多的选项来修改执行计划(是的，我们必须付出巨大的代价来获得这些特性)。让我们试着改变计划。</p><p id="546f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">工作1: </strong>由于default_statistics_target默认为100块，我把这个增加到300以增加样本量，并对表进行了分析。我们可以看到，<strong class="is hj"> n_distinct </strong>两列的值都增加了，而计划两列保持不变。</p><pre class="jo jp jq jr fd js jt ju jv aw jw bi"><span id="9a54" class="jx jy hi jt b fi jz ka l kb kc">set default_statistics_target=300;<br/>SET<br/>analyze vr_distributor_returns;<br/>ANALYZE</span><span id="a3b4" class="jx jy hi jt b fi kk ka l kb kc">select tablename,attname,n_distinct from pg_stats where tablename='testtable' and attname in ('dis_id','processed_date');<br/>       tablename        |    attname     | n_distinct<br/>------------------------+----------------+------------<br/> testtable | dis_id |      <strong class="jt hj">11130</strong><br/> testtable | processed_date |      <strong class="jt hj">44499</strong></span></pre><p id="710e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">工作2: </strong>我只为列<strong class="is hj"> dis_id </strong>设置了统计参数，但是在这种情况下，这两个列的n_distinct也增加了，而plan保持不变。</p><pre class="jo jp jq jr fd js jt ju jv aw jw bi"><span id="1838" class="jx jy hi jt b fi jz ka l kb kc">alter table testtable alter column dis_id set STATISTICS 300;<br/>ALTER TABLE<br/>analyze testtable;<br/>ANALYZE</span><span id="21e1" class="jx jy hi jt b fi kk ka l kb kc">select tablename,attname,n_distinct from pg_stats where tablename='testtable' and attname in ('dis_id','processed_date');<br/>       tablename        |    attname     | n_distinct<br/>------------------------+----------------+------------<br/> testtable | dis_id |      <strong class="jt hj">11130</strong><br/> testtable | processed_date |      <strong class="jt hj">44499</strong></span></pre><p id="7209" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">工作3: </strong>使用n_distinct参数对dis_id列的n_distinct值进行硬编码。它起作用了，我们可以看到只有dis_id列的n_distinct值增加了，现在计划只在这个列上选择索引。新的计划查询在不到一秒钟的时间内运行。</p><pre class="jo jp jq jr fd js jt ju jv aw jw bi"><span id="8b7d" class="jx jy hi jt b fi jz ka l kb kc">alter table testtable alter column dis_id set (n_distinct = 500000);<br/>ALTER TABLE<br/>analyze testtable;<br/>ANALYZE</span><span id="b3d1" class="jx jy hi jt b fi kk ka l kb kc">select tablename,attname,n_distinct from pg_stats where tablename='testtable' and attname in ('dis_id','processed_date');<br/>       tablename        |    attname     | n_distinct<br/>------------------------+----------------+------------<br/> testtable | dis_id |     <strong class="jt hj">500000</strong><br/> testtable | processed_date |      <strong class="jt hj">44499</strong></span></pre><p id="3671" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">新查询计划:</strong></p><pre class="jo jp jq jr fd js jt ju jv aw jw bi"><span id="738f" class="jx jy hi jt b fi jz ka l kb kc">Sort  (cost=5369.54..5370.29 rows=303 width=124) (actual time=222.474..223.554 rows=4707 loops=1)<br/>   Sort Key: rid<br/>   Sort Method: quicksort  Memory: 1443kB<br/>   Buffers: shared hit=1295<br/>   -&gt;  Index Scan using dis_id_indx on testtable dbdistribu0_  (cost=0.57..5357.05 rows=303 width=124) (actual time=2.665..219.316 rows=4707 loops=1)<br/>         Index Cond: ((dis_id)::text = ANY ('{VAL1,VAL2,VAL3,VAL4,VAL5}'::text[]))<br/>         Filter: ((processed_date &gt;= '2020-12-18 00:00:00'::timestamp without time zone) AND (processed_date &lt;= '2021-01-18 00:00:00'::timestamp without time zone) AND ((o_id)::text = 'US'::text))<br/>         Rows Removed by Filter: 224579<br/>         <strong class="jt hj">Buffers: shared hit=1295</strong><br/> Planning time: 0.574 ms<br/> Execution time: 223.996 ms</span></pre><p id="61a2" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">工作4: </strong>如果n_distinct也不起作用，我们仍然可以使用查询重写选项来实施新的计划。基本上，首先用子句在<strong class="is hj">的dis_id列过滤表，然后在主查询中过滤processed_date的数据。</strong></p><pre class="jo jp jq jr fd js jt ju jv aw jw bi"><span id="0317" class="jx jy hi jt b fi jz ka l kb kc">WITH TEMPTABLE AS <br/>(SELECT tabalias.rid,<br/>       tabalias.col1,<br/>       tabalias.col2,<br/>       tabalias.col3,<br/>       tabalias.col4,<br/>       tabalias.dis_id,<br/>       tabalias.col5,<br/>       tabalias.processed_date,<br/>       tabalias.col6,<br/>       tabalias.col7,<br/>       tabalias.col8,<br/>       tabalias.col8,<br/>       tabalias.col9,<br/>       tabalias.col10,<br/>       tabalias.col11,<br/>       tabalias.o_id,<br/>       tabalias.col12<br/>FROM   testtable tabalias<br/>where    (tabalias.o_id IN ('US'))<br/>AND   (tabalias.dis_id IN ('VAL1','VAL2','VAL3','VAL4','VAL5')<br/>)<br/>SELECT * FROM temptable <br/>WHERE tabalias.processed_date &gt;= '18-dec-2020'<br/>AND   tabalias.processed_date &lt;= '18-jan-2021'<br/>ORDER BY tabalias.rid;</span></pre><p id="8f94" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">闭幕词:</strong></p><p id="3ef6" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们还可以在(<strong class="is hj"> dis_id，processed_date </strong>)上创建一个新的复合索引，以获得该查询的最小延迟。尽管表的大小超过了500GB，这也是我们希望避免在生产数据库中使用新索引的原因。</p><p id="d5bc" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">提示:</strong> Postgres的另一个特性是使用“CREATE STATISTICS”命令创建相关的统计数据。这可用于向规划者提供更多关于列相关性的信息。</p></div></div>    
</body>
</html>