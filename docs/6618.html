<html>
<head>
<title>Pickling in python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">蟒蛇皮腌制</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/pickling-in-python-b5abbe4fbead?source=collection_archive---------0-----------------------#2022-04-03">https://medium.com/nerd-for-tech/pickling-in-python-b5abbe4fbead?source=collection_archive---------0-----------------------#2022-04-03</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="7b4e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">根据<a class="ae jd" href="https://docs.python.org/3/library/pickle.html#:~:text=%E2%80%9CPickling%E2%80%9D%20is%20the%20process%20whereby,back%20into%20an%20object%20hierarchy." rel="noopener ugc nofollow" target="_blank"> Python文档</a>，pickle是将Python对象层次转换成字节流的过程，而Un-pickle是相反的操作，字节流(来自<a class="ae jd" href="https://docs.python.org/3/glossary.html#term-binary-file" rel="noopener ugc nofollow" target="_blank">二进制文件</a>或<a class="ae jd" href="https://docs.python.org/3/glossary.html#term-bytes-like-object" rel="noopener ugc nofollow" target="_blank">类字节对象</a>)被转换回对象层次。</p><blockquote class="je jf jg"><p id="34cc" class="if ig jh ih b ii ij ik il im in io ip ji ir is it jj iv iw ix jk iz ja jb jc hb bi translated">酸洗和去酸洗也称为“序列化”、“编组”或“展平”。此外，请注意</p><p id="45f0" class="if ig jh ih b ii ij ik il im in io ip ji ir is it jj iv iw ix jk iz ja jb jc hb bi translated"><strong class="ih hj">警告:</strong><code class="du jl jm jn jo b">pickle</code>模块<strong class="ih hj">不安全</strong>。只对您信任的数据进行解密。</p><p id="719a" class="if ig jh ih b ii ij ik il im in io ip ji ir is it jj iv iw ix jk iz ja jb jc hb bi translated">有可能构建恶意pickle数据，该数据将在取消pickle期间<strong class="ih hj">执行任意代码。不要对可能来自不可信来源或可能被篡改的数据进行解压缩。</strong></p></blockquote><p id="8caf" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在这篇文章中，让我们深入探究腌制的概念</p><figure class="jq jr js jt fd ju er es paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="er es jp"><img src="../Images/0952cd85b5cd917c1f3d005456e2a5de.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*IF_uzq4or5t3XSc6"/></div></div><figcaption class="kb kc et er es kd ke bd b be z dx translated">照片由<a class="ae jd" href="https://unsplash.com/@mbaumi?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">米卡·鲍梅斯特</a>在<a class="ae jd" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><h2 id="537c" class="kf kg hi bd kh ki kj kk kl km kn ko kp iq kq kr ks iu kt ku kv iy kw kx ky kz bi translated">电子监管简介</h2><p id="2300" class="pw-post-body-paragraph if ig hi ih b ii la ik il im lb io ip iq lc is it iu ld iw ix iy le ja jb jc hb bi translated"><strong class="ih hj">序列化</strong>一个对象把它变成一个线性字节流。这样做可以将一个对象保存到一个文件中，或者将它传输到另一个进程中。字节流可以被<strong class="ih hj">解串行化</strong> ( <strong class="ih hj">解编组</strong>)以重构原始对象。</p><p id="f008" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">最常见的序列化Python对象的方法叫做<strong class="ih hj">pickle</strong>。Python也可以使用JSON和XML进行序列化。</p><figure class="jq jr js jt fd ju er es paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="er es lf"><img src="../Images/3dc8fd6adca3949034f794d380b22f08.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MuvWiBwVgO1cV32a4rrkzg.png"/></div></div><figcaption class="kb kc et er es kd ke bd b be z dx translated">一般过程</figcaption></figure><p id="e10e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Python <strong class="ih hj">值</strong>和大多数<strong class="ih hj">内置对象</strong>都可以被酸洗，包括模块顶层的用户自定义类。<strong class="ih hj">递归</strong>和<strong class="ih hj">互联对象</strong>也可以被酸洗。然而，<strong class="ih hj">生成器</strong>，<strong class="ih hj"> lambda函数</strong>，<strong class="ih hj">数据库连接</strong>，以及<strong class="ih hj">线程</strong>，这些都是<strong class="ih hj">无法</strong>腌制的东西。</p><h2 id="1623" class="kf kg hi bd kh ki kj kk kl km kn ko kp iq kq kr ks iu kt ku kv iy kw kx ky kz bi translated">酸洗和非酸洗方法</h2><p id="a652" class="pw-post-body-paragraph if ig hi ih b ii la ik il im lb io ip iq lc is it iu ld iw ix iy le ja jb jc hb bi translated">要pickle或un pickle对象，首先必须导入它的模块。这可以通过<code class="du jl jm jn jo b">import pickle</code>命令来完成。现在，您可以使用以下方法:</p><ul class=""><li id="523b" class="lg lh hi ih b ii ij im in iq li iu lj iy lk jc ll lm ln lo bi translated"><code class="du jl jm jn jo b">pickle.dump(object, file)</code>将<code class="du jl jm jn jo b">object</code>保存到<code class="du jl jm jn jo b">file</code>，必须在<code class="du jl jm jn jo b">wb</code>(写二进制)模式下打开。</li><li id="d0f9" class="lg lh hi ih b ii lp im lq iq lr iu ls iy lt jc ll lm ln lo bi translated"><code class="du jl jm jn jo b">variable = pickle.load(file)</code>重建先前写入<code class="du jl jm jn jo b">file</code>的对象，该对象必须在<code class="du jl jm jn jo b">rb</code>(读取二进制)模式下打开。</li><li id="634e" class="lg lh hi ih b ii lp im lq iq lr iu ls iy lt jc ll lm ln lo bi translated"><code class="du jl jm jn jo b">str = pickle.dumps(object</code>)将<code class="du jl jm jn jo b">object</code>作为字符串保存到<code class="du jl jm jn jo b">str</code>变量中。</li><li id="0bce" class="lg lh hi ih b ii lp im lq iq lr iu ls iy lt jc ll lm ln lo bi translated"><code class="du jl jm jn jo b">object = pickle.loads(str)</code>重建先前写入字符串<code class="du jl jm jn jo b">str</code>的对象。</li></ul><p id="0bc9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">下图将帮助您更好地理解这些方法的功能。</p><figure class="jq jr js jt fd ju er es paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="er es lu"><img src="../Images/e945261064e594c8e666366a30178def.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Pvs_O3WI8DLurX5UN8OWbA.png"/></div></div></figure><pre class="jq jr js jt fd lv jo lw lx aw ly bi"><span id="dc08" class="kf kg hi jo b fi lz ma l mb mc">import os<br/>import pickle</span><span id="f940" class="kf kg hi jo b fi md ma l mb mc">x = {'a': 1, 'b': 2} <br/>y = [x, 3, x] <br/>x['c'] = y <br/>print('x {} \nBefore pickling: {}'.format(x, y))</span><span id="73d7" class="kf kg hi jo b fi md ma l mb mc">fi = open('ptest', 'wb') <br/>pickle.dump(y, fi) <br/>fi.close()</span><span id="eb4a" class="kf kg hi jo b fi md ma l mb mc">fi = open('ptest', 'rb') <br/>z = pickle.load(fi) <br/>print('After pickling:', z)</span></pre><p id="a31b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">使用Pickle模块的优势:</strong></p><ol class=""><li id="aa24" class="lg lh hi ih b ii ij im in iq li iu lj iy lk jc me lm ln lo bi translated"><strong class="ih hj">递归对象(包含对自身的引用的对象):</strong> Pickle跟踪它已经序列化的对象，因此以后对同一对象的引用不会被再次序列化。</li><li id="90e4" class="lg lh hi ih b ii lp im lq iq lr iu ls iy lt jc me lm ln lo bi translated"><strong class="ih hj">对象共享(不同地方对同一对象的引用):</strong>这类似于自引用对象；pickle将对象存储一次，并确保所有其他引用都指向主副本。共享对象保持共享，这对可变对象非常重要。</li><li id="2ced" class="lg lh hi ih b ii lp im lq iq lr iu ls iy lt jc me lm ln lo bi translated"><strong class="ih hj">自定义类及其实例:</strong> Marshal根本不支持这些，但是pickle可以透明的保存和恢复类实例。类定义必须是可导入的，并且与对象存储在同一个模块中。</li></ol></div><div class="ab cl mf mg gp mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="hb hc hd he hf"><p id="6822" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我前面说过，腌制是<strong class="ih hj">不安全的</strong>。它可能包含攻击您系统的代码对象和数据。请确保您解压缩的任何内容都来自可靠的来源，并且在传输过程中没有被篡改。下次再见！</p></div></div>    
</body>
</html>