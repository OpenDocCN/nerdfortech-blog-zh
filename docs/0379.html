<html>
<head>
<title>How to do authentication in NodeJS?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">NodeJS 怎么做认证？</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/how-to-do-authentication-in-nodejs-48c16748749b?source=collection_archive---------1-----------------------#2020-11-11">https://medium.com/nerd-for-tech/how-to-do-authentication-in-nodejs-48c16748749b?source=collection_archive---------1-----------------------#2020-11-11</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="1423" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">身份验证是大多数重要的 web 应用程序需要解决的问题，对于应该如何做有很多(相互冲突的)观点。让我们看看解决这个问题的一些方法，以及进一步细节的链接。</p><p id="3b6a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">当我刚开始编程时，我在一家小型初创公司工作。<br/>我们的 CTO 领导软件架构，并将许多代码编写职责委托给我们这些级别较低的员工。<br/>在构建我们的产品时，我们需要验证我们的用户(就像现在大多数应用程序所做的那样)。</p><p id="4f89" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">认证是证明用户的身份。授权就是弄清楚被授权的用户被允许做什么。</p><p id="f7ff" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">那么，我如何认证一个用户呢？</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es jd"><img src="../Images/14271b5eb0836b3bbb96a56c59ac33a0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*brpqdzwFeH0CIocs"/></div></div><figcaption class="jp jq et er es jr js bd b be z dx translated">由<a class="ae jt" href="https://unsplash.com/@markusspiske?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">马库斯·斯皮斯克</a>在<a class="ae jt" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄的照片</figcaption></figure></div><div class="ab cl ju jv gp jw" role="separator"><span class="jx bw bk jy jz ka"/><span class="jx bw bk jy jz ka"/><span class="jx bw bk jy jz"/></div><div class="hb hc hd he hf"><h1 id="139f" class="kb kc hi bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated">选项 1:第三方服务</h1><p id="db28" class="pw-post-body-paragraph if ig hi ih b ii kz ik il im la io ip iq lb is it iu lc iw ix iy ld ja jb jc hb bi translated">当我们开始时，我们的 CTO 做出了一个明智的决定，为此使用第三方服务。<a class="ae jt" href="https://firebase.google.com/products/auth" rel="noopener ugc nofollow" target="_blank">谷歌的 Firebase </a>有一个简洁的认证子系统，负责在云上安全地存储凭证，并且开箱即用，有许多附加功能，比如可以使用谷歌、推特或脸书账户进行认证。</p><p id="6d1a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">还有各种其他的选择(比如<a class="ae jt" href="https://www.okta.com/" rel="noopener ugc nofollow" target="_blank"> Okta </a>)，但是我想把重点放在我自己的个人经历上。</p><p id="5c6e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">委托的好处是实现起来相对较快，并且安全风险由一个不是你自己的实体来承担。<br/>不利方面可能是成本和供应商锁定。</p></div><div class="ab cl ju jv gp jw" role="separator"><span class="jx bw bk jy jz ka"/><span class="jx bw bk jy jz ka"/><span class="jx bw bk jy jz"/></div><div class="hb hc hd he hf"><h1 id="a101" class="kb kc hi bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated">选项 2:使用图书馆</h1><p id="ea83" class="pw-post-body-paragraph if ig hi ih b ii kz ik il im la io ip iq lb is it iu lc iw ix iy ld ja jb jc hb bi translated">大多数开发人员都不是安全专家，而且密码学很难搞清楚。普遍的看法是，最好使用一个成熟的、经过良好测试的实现(比如<a class="ae jt" href="https://www.openssl.org/" rel="noopener ugc nofollow" target="_blank"> OpenSSL </a>)，而不是实现自己的实现。<br/>那么，为什么认证应该是不同的呢？</p><p id="65c6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在一个流行的选择是<a class="ae jt" href="http://www.passportjs.org/" rel="noopener ugc nofollow" target="_blank">passport . js</a>(NPM 上每周 946k 的下载量)，这是一个<a class="ae jt" href="https://expressjs.com/" rel="noopener ugc nofollow" target="_blank"> Express.js </a>专门为认证而构建的中间件。它也支持许多认证策略(google、twitter、facebook 等等)。与第三方云服务不同，这完全是内部部署，没有许可成本(Passport 是开源的，有 MIT 许可)。<br/>但是如果你没有使用 Express.js 呢？例如，如果你使用<a class="ae jt" href="https://sailsjs.com/" rel="noopener ugc nofollow" target="_blank">帆</a>会怎么样？<a class="ae jt" href="https://hapi.dev/" rel="noopener ugc nofollow" target="_blank">哈比神</a>？</p><p id="7135" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">当谷歌搜索认证时，你可能会发现另一种流行的技术叫做<a class="ae jt" href="https://jwt.io/" rel="noopener ugc nofollow" target="_blank"> JWT </a>。它不是一种认证技术，而是用于授权。一个流行的用例是使用 Passport.js 之类的东西来验证用户，然后向他们发送一个 JWT。</p></div><div class="ab cl ju jv gp jw" role="separator"><span class="jx bw bk jy jz ka"/><span class="jx bw bk jy jz ka"/><span class="jx bw bk jy jz"/></div><div class="hb hc hd he hf"><h1 id="73c7" class="kb kc hi bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated">选项 3:自己卷</h1><p id="aebe" class="pw-post-body-paragraph if ig hi ih b ii kz ik il im la io ip iq lb is it iu lc iw ix iy ld ja jb jc hb bi translated">在我的第一份工作中工作了一年多一点后，它的技术领导发生了变化，一个新产品的开发开始了。新任首席技术官决定由我们自己来实施身份认证。</p><p id="55cd" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我很欣赏 CTO 不仅根据工程的合理性，还根据其他因素(如上市时间和成本)做出决策。<br/>实现自己的安全性有很多缺点，而且通常是不明智的。</p></div><div class="ab cl ju jv gp jw" role="separator"><span class="jx bw bk jy jz ka"/><span class="jx bw bk jy jz ka"/><span class="jx bw bk jy jz"/></div><div class="hb hc hd he hf"><p id="1df7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">简单认证</p><p id="a923" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这或多或少是我们 CTO 设计的:<br/> 1。用户向服务器发送了他们的用户名和密码，假设通过 HTTPS <br/> 2 建立了加密连接。服务器从数据库中获取用户的记录(基于用户名)<br/> 3。存储在用户记录中的唯一的 salt 与提供的密码连接，结果被散列<br/> 4。将这个散列与记录中存储的散列进行比较(确保使用<a class="ae jt" href="https://nodejs.org/api/crypto.html#crypto_crypto_timingsafeequal_a_b" rel="noopener ugc nofollow" target="_blank">timingsafequal()</a>而不是相等运算符！).如果它们相同，则意味着用户提供了正确的密码，身份验证成功</p><p id="fa4e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">听起来很棒，不是吗？超级简单，非常优雅。<br/> *凭证不是以纯文本形式发送的(因为使用了 HTTPS，所以通道是加密的)<br/> *密码不是以纯文本形式存储在数据库中。每个人都说盐和散列你的密码，我们在这里做。</p><p id="c6fc" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">然而，它并不是没有缺陷。对于技术演示或概念验证来说，这可能很好，但这可能会受到多种攻击。例如:<br/> *这容易受到重放攻击。<br/> *最薄弱的环节是通信信道(希望加密得很好)</p></div><div class="ab cl ju jv gp jw" role="separator"><span class="jx bw bk jy jz ka"/><span class="jx bw bk jy jz ka"/><span class="jx bw bk jy jz"/></div><div class="hb hc hd he hf"><p id="2250" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们怎样才能做得更好？让我们从<a class="ae jt" href="https://en.wikipedia.org/wiki/Challenge%E2%80%93response_authentication" rel="noopener ugc nofollow" target="_blank">挑战-响应认证</a>中得到启发。有大量的行业标准协议(如<a class="ae jt" href="https://en.wikipedia.org/wiki/Kerberos_(protocol)" rel="noopener ugc nofollow" target="_blank"> Kerberos </a>、<a class="ae jt" href="https://en.wikipedia.org/wiki/Salted_Challenge_Response_Authentication_Mechanism" rel="noopener ugc nofollow" target="_blank">急停</a>等)，但让我们假设我们遭受的<a class="ae jt" href="https://en.wikipedia.org/wiki/Not_invented_here" rel="noopener ugc nofollow" target="_blank">不是这里发明的</a>。</p><p id="cc69" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们在这里试图做的是双重的。不要在通信信道中发送密码<br/> 2。使身份验证唯一，这样它就不能被重放</p><p id="3e78" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这是我想到的:</p><ol class=""><li id="424b" class="le lf hi ih b ii ij im in iq lg iu lh iy li jc lj lk ll lm bi translated">用户向服务器发送他的用户名</li><li id="eab3" class="le lf hi ih b ii ln im lo iq lp iu lq iy lr jc lj lk ll lm bi translated">服务器从数据库中获取用户的记录</li><li id="d101" class="le lf hi ih b ii ln im lo iq lp iu lq iy lr jc lj lk ll lm bi translated">服务器用用户的 salt 和迭代计数，加上一些随机字节(让我们称之为“nonce”)来响应</li><li id="cc3f" class="le lf hi ih b ii ln im lo iq lp iu lq iy lr jc lj lk ll lm bi translated">用户将 salt 应用到他的密码上并对其进行散列，将 nonce 附加到结果上并再次进行散列</li><li id="12b4" class="le lf hi ih b ii ln im lo iq lp iu lq iy lr jc lj lk ll lm bi translated">用户向服务器发送这个散列</li><li id="4461" class="le lf hi ih b ii ln im lo iq lp iu lq iy lr jc lj lk ll lm bi translated">服务器将接收到的散列与用户记录中使用 nonce 散列的散列进行比较(确保使用<a class="ae jt" href="https://nodejs.org/api/crypto.html#crypto_crypto_timingsafeequal_a_b" rel="noopener ugc nofollow" target="_blank">timingsafequal()</a>而不是等式运算符！).如果它们相同，则认证成功。</li></ol><p id="2e60" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">示例实现:<br/>服务器端:<a class="ae jt" href="https://github.com/soryy708/nodejs-cr-auth/blob/master/src/api/routes/auth.js#L31" rel="noopener ugc nofollow" target="_blank">https://github . com/soryy 708/nodejs-Cr-auth/blob/master/src/API/routes/auth . js # L31</a><br/>客户端:<a class="ae jt" href="https://github.com/soryy708/nodejs-cr-auth/blob/master/src/web/index.js#L16" rel="noopener ugc nofollow" target="_blank">https://github . com/soryy 708/nodejs-Cr-auth/blob/master/src/web/index . js # L16</a></p><p id="32bd" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">那么我们这里有什么？首先让我们看一下好处:<br/> *密码根本不通过通信通道发送<br/> *身份验证是唯一的，因为它是用 nonce 散列的；因此无法重播<br/> *服务器不以明文形式存储密码</p><p id="cfb2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">但是缺点是什么呢？<br/> *服务器和客户端之间的对话有更多的步骤，增加了实现难度<br/>* nonce 需要在两个 API 调用之间保持，这违反了无状态性<br/> *我们正在使用 hash 中的 hash，这可能会无意中增加冲突概率</p><p id="9a38" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我不是安全专家，这个想法是我在一张餐巾纸上想出来的(打个比方)。我很想听听你对它的评论，最好是把它彻底遗忘！</p></div></div>    
</body>
</html>