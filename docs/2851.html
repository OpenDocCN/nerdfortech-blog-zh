<html>
<head>
<title>Find Pattern and Replace — Daily Challenge May</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">寻找模式并替换—日常挑战可能</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/find-pattern-and-replace-daily-challenge-may-5ea19d245565?source=collection_archive---------33-----------------------#2021-05-21">https://medium.com/nerd-for-tech/find-pattern-and-replace-daily-challenge-may-5ea19d245565?source=collection_archive---------33-----------------------#2021-05-21</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><figure class="hh hi ez fb hj hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es hg"><img src="../Images/925b1e2ad5123b9aa034897f358874a5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NGkjaIHa0Kl7vFby52f5kA.jpeg"/></div></div><figcaption class="hr hs et er es ht hu bd b be z dx translated">克拉克·范·德·贝肯在<a class="ae hv" href="https://unsplash.com/s/photos/patterns?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><div class=""/><p id="1a93" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">今天的问题来自每日 Leetcode 编码挑战赛——五月版。这是一个中等标签的问题。让我们看看问题陈述。</p><h2 id="5e3f" class="jt ju hy bd jv jw jx jy jz ka kb kc kd jg ke kf kg jk kh ki kj jo kk kl km kn bi translated"><a class="ae hv" href="https://leetcode.com/problems/find-and-replace-pattern/" rel="noopener ugc nofollow" target="_blank"> 890。</a>查找并替换模式</h2><p id="07a6" class="pw-post-body-paragraph iv iw hy ix b iy ko ja jb jc kp je jf jg kq ji jj jk kr jm jn jo ks jq jr js hb bi translated">给定一个字符串列表<code class="du kt ku kv kw b">words</code>和一个字符串<code class="du kt ku kv kw b">pattern</code>，返回<em class="kx">一个与</em> <code class="du kt ku kv kw b">pattern</code>匹配的 <code class="du kt ku kv kw b">words[i]</code> <em class="kx">列表。你可以按<strong class="ix hz">任何顺序</strong>返回答案。</em></p><p id="f5ba" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如果存在字母排列<code class="du kt ku kv kw b">p</code>，则一个单词匹配该模式，因此在用<code class="du kt ku kv kw b">p(x)</code>替换模式中的每个字母<code class="du kt ku kv kw b">x</code>后，我们得到想要的单词。</p><p id="1b3f" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">回想一下，字母排列是从字母到字母的双射:每个字母映射到另一个字母，没有两个字母映射到同一个字母。</p><h2 id="3f40" class="jt ju hy bd jv jw jx jy jz ka kb kc kd jg ke kf kg jk kh ki kj jo kk kl km kn bi translated">示例:</h2><pre class="ky kz la lb fd lc kw ld le aw lf bi"><span id="3fa6" class="jt ju hy kw b fi lg lh l li lj"><strong class="kw hz">Input:</strong> words = ["abc","deq","mee","aqq","dkd","ccc"], pattern = "abb"<br/><strong class="kw hz">Output:</strong> ["mee","aqq"]</span></pre><h2 id="e869" class="jt ju hy bd jv jw jx jy jz ka kb kc kd jg ke kf kg jk kh ki kj jo kk kl km kn bi translated">理解问题:</h2><p id="4593" class="pw-post-body-paragraph iv iw hy ix b iy ko ja jb jc kp je jf jg kq ji jj jk kr jm jn jo ks jq jr js hb bi translated">问题是找到具有相同的映射单词出现计数序列的所有单词。换句话说，应该具有相同数量的唯一元素，并且它们应该以与模式元素相似的顺序出现。所以如果我们指定元素的第一次出现作为它的表示。我们将得到一个字符不可知的序列，我们只需要检查模式表示是否相同。</p><figure class="ky kz la lb fd hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es lk"><img src="../Images/26aafd5d11f623091ba0a72e999de6f5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4k7ieCE8eZANtjnHh0fmUQ.png"/></div></div></figure><h2 id="6615" class="jt ju hy bd jv jw jx jy jz ka kb kc kd jg ke kf kg jk kh ki kj jo kk kl km kn bi translated">代码实现:</h2><pre class="ky kz la lb fd lc kw ld le aw lf bi"><span id="0b73" class="jt ju hy kw b fi lg lh l li lj">def helper(s):<br/>    m = {}<br/>    n = len(s)<br/>    res = []<br/>    for i in range(n):<br/>        if s[i] not in m:<br/>            m[s[i]]= len(m) <br/>        res.append(m[s[i]])<br/>    return res</span><span id="4aea" class="jt ju hy kw b fi ll lh l li lj">def findAndReplacePattern(words, pattern):<br/>    pattern = helper(pattern)<br/>    res = []<br/>    for w in words:<br/>        if helper(w)==pattern: <br/>            res.append(w)   <br/>    return res</span></pre><h2 id="3abd" class="jt ju hy bd jv jw jx jy jz ka kb kc kd jg ke kf kg jk kh ki kj jo kk kl km kn bi translated">优化:</h2><p id="742a" class="pw-post-body-paragraph iv iw hy ix b iy ko ja jb jc kp je jf jg kq ji jj jk kr jm jn jo ks jq jr js hb bi translated">在上面的解决方案中，我们计算模式时不考虑是否已经存在不匹配。我们可以在发现不匹配的时候退出模式发现过程。这是我们使用两个字典实现的。每个字典都映射到它在模式中的表示&amp;反之亦然。如果我们看到任何字符的重复，我们检查第二个字典中是否有相同的值。</p><pre class="ky kz la lb fd lc kw ld le aw lf bi"><span id="aaaf" class="jt ju hy kw b fi lg lh l li lj">def findAndReplacePattern(words, pattern):<br/>    res = []<br/>    for word in words:<br/>        m1 = {}<br/>        m2 = {}<br/>        matched = True<br/>        for i in range(len(pattern)):<br/>            if pattern[i] in m1 or word[i] in m2:<br/>                if word[i] != m1.get(pattern[i]) \<br/>                or m2.get(word[i]) != pattern[i]:<br/>                    matched = False<br/>                    break<br/>            else:<br/>                m1[pattern[i]] = word[i]<br/>                m2[word[i]] = pattern[i]<br/>        if matched:<br/>            res.append(word)<br/>    <br/>    return res</span></pre><p id="9d13" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hz">复杂性分析</strong></p><ul class=""><li id="ee28" class="lm ln hy ix b iy iz jc jd jg lo jk lp jo lq js lr ls lt lu bi translated">时间复杂度:O(N * W)，其中 N 为字数，W 为每个单词的长度。</li><li id="3f43" class="lm ln hy ix b iy lv jc lw jg lx jk ly jo lz js lr ls lt lu bi translated">空间复杂度:O(N * 2W)，答案使用的空间。</li></ul></div></div>    
</body>
</html>