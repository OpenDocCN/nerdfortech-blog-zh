<html>
<head>
<title>Onion Architecture In .Net 5</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">洋葱建筑在。网络5</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/onion-architecture-in-net-5-deb04efe9df0?source=collection_archive---------0-----------------------#2021-06-07">https://medium.com/nerd-for-tech/onion-architecture-in-net-5-deb04efe9df0?source=collection_archive---------0-----------------------#2021-06-07</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/649677a6f91f6470cb09f545a3606bb2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DGIK6R15OJC-b-lhgIoPMA.jpeg"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">洋葱建筑图</figcaption></figure><p id="2036" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi js translated">在本文中，我们将介绍ASP.Net 5.0中的洋葱架构。众所周知，这是一个新推出的框架，于11月正式发布。在这里我分享了为<a class="ae kb" href="https://dotnet.microsoft.com/download/dotnet/5.0" rel="noopener ugc nofollow" target="_blank">安装SDK的链接。网5 </a></p><p id="e4b6" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><em class="kc">支持我</em></p><figure class="ke kf kg kh fd ij er es paragraph-image"><a href="https://www.buymeacoffee.com/jaykrishnareddy"><div class="er es kd"><img src="../Images/7a5c035cd21f7fa41bd8ae7cbadf7d61.png" data-original-src="https://miro.medium.com/v2/resize:fit:340/format:webp/1*1LFaaJOnWU9L0G6_c_wRWQ.png"/></div></a></figure><p id="c1ab" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw hj">我们将要讨论的内容。NET 5洋葱架构？</strong></p><ul class=""><li id="b513" class="ki kj hi iw b ix iy jb jc jf kk jj kl jn km jr kn ko kp kq bi translated">什么是洋葱建筑</li><li id="bc54" class="ki kj hi iw b ix kr jb ks jf kt jj ku jn kv jr kn ko kp kq bi translated">洋葱状建筑的层次</li><li id="0a84" class="ki kj hi iw b ix kr jb ks jf kt jj ku jn kv jr kn ko kp kq bi translated">洋葱架构的实现</li><li id="d2ac" class="ki kj hi iw b ix kr jb ks jf kt jj ku jn kv jr kn ko kp kq bi translated">利弊</li></ul><h1 id="68f4" class="kw kx hi bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">洋葱建筑是什么？</h1><p id="1844" class="pw-post-body-paragraph iu iv hi iw b ix lu iz ja jb lv jd je jf lw jh ji jj lx jl jm jn ly jp jq jr hb bi translated">习惯设计的很大一部分提出了紧密耦合和关注点划分的基本问题。Jeffrey Palermo认为洋葱架构提供了一种在更好的可测试性、实用性和稳定性的背景下构建应用程序的优越方法。洋葱体系结构倾向于3层和n层体系结构所面临的困难，并给出了普通问题的答案。洋葱设计层通过使用接口相互关联。</p><h1 id="c19b" class="kw kx hi bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">洋葱状建筑的层次</h1><p id="ae4e" class="pw-post-body-paragraph iu iv hi iw b ix lu iz ja jb lv jd je jf lw jh ji jj lx jl jm jn ly jp jq jr hb bi translated">基本上，它使用了层的概念，但它们不同于3层和N层。让我们深入了解每一层。</p><p id="e5ee" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw hj">域层</strong></p><p id="606e" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">它存在于洋葱架构的中心部分，由所有应用程序域实体组成，这些实体只不过是由代码优先方法创建的数据库模型。在这个项目中，我使用了Fluent API来创建使用实体框架的表模式</p><p id="162a" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw hj">储存库层</strong></p><p id="496b" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">存储库层充当服务和模型对象之间的中间层，在这一层中，我们将维护所有数据库迁移和应用程序数据上下文对象，在这一层中，我们通常添加接口，这些接口将由涉及数据库的读写操作的数据访问模式组成。</p><p id="fb49" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw hj">服务层</strong></p><p id="ea2b" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">该层用于存储库层和主项目之间的通信，其中包含可公开的API。服务层也可以保存实体的业务逻辑。在这一层，服务接口与它们的实现保持分离，以实现松散耦合和关注点的分离。</p><p id="2c42" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw hj"> UI层</strong></p><p id="fbef" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">UI只是一个前端应用程序，它将与这个API进行通信。</p><h1 id="e153" class="kw kx hi bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">洋葱架构的实现</h1><p id="5c01" class="pw-post-body-paragraph iu iv hi iw b ix lu iz ja jb lv jd je jf lw jh ji jj lx jl jm jn ly jp jq jr hb bi translated">创建新项目</p><figure class="ke kf kg kh fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lz"><img src="../Images/73824b0f34855bf8737a641a2393e252.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tvJ7bdM21XfiijncQRTcrg.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">图一</figcaption></figure><p id="d2b3" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">单击“下一步”按钮后，添加项目名称和解决方案名称，然后单击“创建”按钮</p><figure class="ke kf kg kh fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ma"><img src="../Images/909252d72d0c7788e6dab0e41262b172.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1HseEG-XTFKNHVnRWOyeuw.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">图二</figcaption></figure><p id="f7d1" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">在下拉列表中选择ASP.Net核心5.0模板，并确保检查<strong class="iw hj">启用开放API </strong>对项目中默认Swagger实现的支持</p><figure class="ke kf kg kh fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mb"><img src="../Images/54375efeff01be2e2010dbc05dddcd29.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Nkp3xXNhLEU3DEov8kXJWw.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">图三</figcaption></figure><p id="a611" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">默认项目将被创建，现在我们需要3个空的<strong class="iw hj">类库(。Net Core) </strong>项目在这个应用程序内部作为</p><ul class=""><li id="a66c" class="ki kj hi iw b ix iy jb jc jf kk jj kl jn km jr kn ko kp kq bi translated">域名持有者</li><li id="a27b" class="ki kj hi iw b ix kr jb ks jf kt jj ku jn kv jr kn ko kp kq bi translated">仓库层</li><li id="66da" class="ki kj hi iw b ix kr jb ks jf kt jj ku jn kv jr kn ko kp kq bi translated">服务杀手</li></ul><figure class="ke kf kg kh fd ij er es paragraph-image"><div class="er es mc"><img src="../Images/bfb6d26a6e5554f53fa7892ac5afba55.png" data-original-src="https://miro.medium.com/v2/resize:fit:876/format:webp/1*j95kxPSC8oi5EshyZuzh1Q.png"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">图4</figcaption></figure><p id="f3bc" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">我们将首先从领域层开始</p><p id="b101" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw hj">域层</strong></p><p id="94f2" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw hj">该层使用的包</strong></p><ul class=""><li id="f1ce" class="ki kj hi iw b ix iy jb jc jf kk jj kl jn km jr kn ko kp kq bi translated">微软。实体框架工作核心(5.0.3)</li><li id="919d" class="ki kj hi iw b ix kr jb ks jf kt jj ku jn kv jr kn ko kp kq bi translated">微软。EntityFrameworkCore . Relational(5 . 0 . 3)</li></ul><p id="bb5c" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">创建一个名为<strong class="iw hj"> Models </strong>的文件夹，并在其中创建customer类和BaseEntity类，Customer类调用这个基本实体</p><p id="324f" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw hj"> <em class="kc"> BaseEntity.cs </em> </strong></p><figure class="ke kf kg kh fd ij"><div class="bz dy l di"><div class="md me l"/></div></figure><p id="1d15" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw hj">T13】customer . csT15】</strong></p><figure class="ke kf kg kh fd ij"><div class="bz dy l di"><div class="md me l"/></div></figure><p id="3920" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">因此，现在我们将使用这个customer &amp; base实体类创建实际的表。为此，创建一个单独的文件夹EntityMapper，我们将在该文件夹中维护所有的表模式</p><p id="8dc1" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw hj"><em class="kc">customer map . cs</em></strong></p><figure class="ke kf kg kh fd ij"><div class="bz dy l di"><div class="md me l"/></div></figure><p id="e564" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw hj">域层结构</strong></p><figure class="ke kf kg kh fd ij er es paragraph-image"><div class="er es mf"><img src="../Images/6c3a82863d22ba9ebc3dad0d7c18ed7a.png" data-original-src="https://miro.medium.com/v2/resize:fit:874/format:webp/1*cSGi1LOkMjFDIURSshjNsQ.png"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">图五</figcaption></figure><p id="ed49" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw hj"> <em class="kc">储存层</em> </strong></p><p id="c32b" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw hj">该层使用的包</strong></p><ul class=""><li id="1377" class="ki kj hi iw b ix iy jb jc jf kk jj kl jn km jr kn ko kp kq bi translated">微软。实体框架工作核心(5.0.3)</li><li id="6179" class="ki kj hi iw b ix kr jb ks jf kt jj ku jn kv jr kn ko kp kq bi translated">微软。实体框架工作核心设计(5.0.3)</li><li id="7433" class="ki kj hi iw b ix kr jb ks jf kt jj ku jn kv jr kn ko kp kq bi translated">微软。EntityFrameworkCore . SQL server(5 . 0 . 3)</li><li id="9fbb" class="ki kj hi iw b ix kr jb ks jf kt jj ku jn kv jr kn ko kp kq bi translated">微软。实体框架工作核心工具(5.0.3)</li></ul><p id="f5c4" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">到目前为止，我们在域层中设计了我们的表，现在将使用SQL DB中的迁移命令创建相同的表。让我们在主项目中创建连接字符串。</p><p id="85bf" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw hj"><em class="kc">appsettings . JSON</em></strong></p><figure class="ke kf kg kh fd ij"><div class="bz dy l di"><div class="md me l"/></div></figure><p id="2b97" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">在ConfigureMethod下的startup.cs文件中设置连接</p><p id="9762" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw hj">T33】startup . csT35】</strong></p><figure class="ke kf kg kh fd ij"><div class="bz dy l di"><div class="md me l"/></div></figure><p id="5462" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">现在切换回存储库层，创建一个DataContext文件，它表示与数据库的一个会话，可以用来查询和保存实体的实例</p><p id="c3ca" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw hj"><em class="kc">applicationdbcontext . cs</em></strong></p><figure class="ke kf kg kh fd ij"><div class="bz dy l di"><div class="md me l"/></div></figure><p id="8665" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">让我们使用迁移命令在SQL中创建表。打开软件包管理器控制台，将默认项目切换到Repositorylayer，并依次执行以下命令。</p><figure class="ke kf kg kh fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mg"><img src="../Images/3f8f75b457b59aafb05a06779979b5d2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*L5nwa4crqHEH2C-Mv9X15Q.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">图6</figcaption></figure><p id="750a" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">要执行的命令</p><ul class=""><li id="662a" class="ki kj hi iw b ix iy jb jc jf kk jj kl jn km jr kn ko kp kq bi translated">添加迁移' CreateCustomerTable '</li><li id="6efd" class="ki kj hi iw b ix kr jb ks jf kt jj ku jn kv jr kn ko kp kq bi translated">更新-数据库</li></ul><p id="120d" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">ASP。Net Core的设计就是为了支持依赖注入。现在我们为实体操作创建一个通用的存储库接口，这样我们就可以看到松散耦合的应用程序。下面是代码片段</p><p id="a5fb" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw hj"><em class="kc">I repository . cs</em>T43】</strong></p><figure class="ke kf kg kh fd ij"><div class="bz dy l di"><div class="md me l"/></div></figure><p id="8c80" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">创建repository类来执行继承IRepository接口的数据库操作。</p><p id="2ecb" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw hj"><em class="kc">repository . cs</em></strong></p><figure class="ke kf kg kh fd ij"><div class="bz dy l di"><div class="md me l"/></div></figure><p id="b6f4" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw hj"> <em class="kc">知识库层结构</em> </strong></p><figure class="ke kf kg kh fd ij er es paragraph-image"><div class="er es mh"><img src="../Images/60563bcf95542b28464051ba3d5887a1.png" data-original-src="https://miro.medium.com/v2/resize:fit:900/format:webp/1*LtVKSypunbcslnd1nMRh8Q.png"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">图7</figcaption></figure><h1 id="c973" class="kw kx hi bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">服务层</h1><p id="872e" class="pw-post-body-paragraph iu iv hi iw b ix lu iz ja jb lv jd je jf lw jh ji jj lx jl jm jn ly jp jq jr hb bi translated">这包含了作为我们项目一部分的核心业务逻辑，它充当了存储库层和控制器之间的一个层。</p><p id="d0c1" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw hj">T53】icustomerservice . csT55】</strong></p><figure class="ke kf kg kh fd ij"><div class="bz dy l di"><div class="md me l"/></div></figure><p id="cc7e" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw hj"><em class="kc">customerservice . cs</em>T3】</strong></p><figure class="ke kf kg kh fd ij"><div class="bz dy l di"><div class="md me l"/></div></figure><p id="7db6" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">在startup.cs文件中配置这些服务</p><p id="5496" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw hj">T5】startup . csT7】</strong></p><figure class="ke kf kg kh fd ij"><div class="bz dy l di"><div class="md me l"/></div></figure><p id="15fe" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">在客户控制器中创建可向UI(前端应用程序)公开的API方法</p><p id="8af3" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw hj"><em class="kc">customer controller . cs</em></strong></p><figure class="ke kf kg kh fd ij"><div class="bz dy l di"><div class="md me l"/></div></figure><p id="1d95" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw hj">洋葱架构项目结构</strong></p><figure class="ke kf kg kh fd ij er es paragraph-image"><div class="er es mi"><img src="../Images/510bd60102a7bd0d4e1b0e4df58a8a56.png" data-original-src="https://miro.medium.com/v2/resize:fit:814/format:webp/1*WNfKYVGgyGrVR0JmXM06LQ.png"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">图8</figcaption></figure><p id="5a08" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">让我们运行并测试这个应用程序，检查swagger或postman中的输出。</p><figure class="ke kf kg kh fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mj"><img src="../Images/cd028084167bf23b86b49d8ed9f7e285.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RiG4qcEV4-ST9RWtL0KsUQ.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">图9</figcaption></figure><p id="0808" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">因为我已经使用InserCustomer API在数据库中插入了一条记录，所以我们将通过执行Get ALL Customers API来查看数据。</p><figure class="ke kf kg kh fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mk"><img src="../Images/ebe425bf20424fd4c4b9a5a6d0ba4357.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*f90Jgg8XskNBPau7uhoVYw.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">图10</figcaption></figure><h1 id="3d11" class="kw kx hi bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">洋葱架构的利与弊</h1><p id="e786" class="pw-post-body-paragraph iu iv hi iw b ix lu iz ja jb lv jd je jf lw jh ji jj lx jl jm jn ly jp jq jr hb bi translated">以下是实现洋葱架构的优势:</p><ul class=""><li id="7192" class="ki kj hi iw b ix iy jb jc jf kk jj kl jn km jr kn ko kp kq bi translated">洋葱架构层通过接口联系在一起。在运行期间进行植入。</li><li id="3612" class="ki kj hi iw b ix kr jb ks jf kt jj ku jn kv jr kn ko kp kq bi translated">应用工程是基于区域模型之上的。</li><li id="3b5d" class="ki kj hi iw b ix kr jb ks jf kt jj ku jn kv jr kn ko kp kq bi translated">所有外部依赖，类似于数据集准入和管理调用，都在外部层处理。</li><li id="90dd" class="ki kj hi iw b ix kr jb ks jf kt jj ku jn kv jr kn ko kp kq bi translated">内层没有外层的条件。</li><li id="1a39" class="ki kj hi iw b ix kr jb ks jf kt jj ku jn kv jr kn ko kp kq bi translated">联轴器朝向中间。</li><li id="677a" class="ki kj hi iw b ix kr jb ks jf kt jj ku jn kv jr kn ko kp kq bi translated">适应性强、可行、方便的设计。</li><li id="31dc" class="ki kj hi iw b ix kr jb ks jf kt jj ku jn kv jr kn ko kp kq bi translated">没有令人信服的理由让正常和共享的活动。</li><li id="4be4" class="ki kj hi iw b ix kr jb ks jf kt jj ku jn kv jr kn ko kp kq bi translated">可以立即尝试，因为应用程序中心不依赖任何东西。</li></ul><p id="7748" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">洋葱架构的几个缺点如下:</p><ul class=""><li id="db94" class="ki kj hi iw b ix iy jb jc jf kk jj kl jn km jr kn ko kp kq bi translated">业余爱好者很难理解，包括期望吸收信息。建模者通常会混淆层与层之间的分离义务。</li><li id="6d17" class="ki kj hi iw b ix kr jb ks jf kt jj ku jn kv jr kn ko kp kq bi translated">大量使用的界面</li></ul><div class="ml mm ez fb mn mo"><a href="https://github.com/JayKrishnareddy/OnionArchitecture" rel="noopener  ugc nofollow" target="_blank"><div class="mp ab dw"><div class="mq ab mr cl cj ms"><h2 class="bd hj fi z dy mt ea eb mu ed ef hh bi translated">JayKrishnareddy/onion architecture</h2><div class="mv l"><h3 class="bd b fi z dy mt ea eb mu ed ef dx translated">ASP.NET核心5.0中的洋葱架构包括流畅的API、Swagger、依赖注入、工作单元什么是洋葱…</h3></div><div class="mw l"><p class="bd b fp z dy mt ea eb mu ed ef dx translated">github.com</p></div></div><div class="mx l"><div class="my l mz na nb mx nc io mo"/></div></div></a></div><p id="f06c" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">希望这篇文章能帮助你清楚地了解洋葱架构。</p><p id="44a9" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">….继续学习！！！</p></div></div>    
</body>
</html>