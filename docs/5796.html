<html>
<head>
<title>On the selection of data structures</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">论数据结构的选择</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/on-the-selection-of-data-structures-3cee0f430ea9?source=collection_archive---------7-----------------------#2021-11-16">https://medium.com/nerd-for-tech/on-the-selection-of-data-structures-3cee0f430ea9?source=collection_archive---------7-----------------------#2021-11-16</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="2814" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">GPXmagic中的优化</h2></div><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ix"><img src="../Images/0753368021982cb79040ec0228b6cbb5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*J7K_9VewJVcLWR1kU9qcfA.png"/></div></div></figure><p id="4699" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">GPXmagic的“自然”数据结构是一个跟踪点列表。毕竟，这就是道路。大多数情况下这是非常好的，但是随机访问一个单独的跟踪点的代价是令人担忧的。</p><p id="e787" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">特别是，我需要找到一个离用户点击3D图像最近的跟踪点。因为我将旋转和缩放留给了WebGL组件，所以我没有直接的方法来解释点击位置。我能做的最好的事情就是创建一条“射线”,从这条射线我可以测量任意点的距离。给定一条射线和一系列点，我的第一步解决方案就是找到距离最小的点，很容易写:</p><pre class="iy iz ja jb fd kf kg kh ki aw kj bi"><span id="e502" class="kk kl hi kg b fi km kn l ko kp">trackPointNearestRay : List TrackPoint -&gt; Axis3d Meters LocalCoords -&gt; Maybe TrackPoint<br/>trackPointNearestRay track ray =<br/>    track<br/>        |&gt; List.Extra.minimumBy<br/>            (Length.inMeters &lt;&lt; distanceFromAxis ray &lt;&lt; .xyz)</span></pre><p id="b00c" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">它必须扫描整个列表。对于数百甚至数千个点来说，这是可以接受的，但随着列表的增长，这显然不够优雅或高效。尽管如此，对于大多数曲目来说，它对用户输入的响应速度已经足够快，所以不需要急着修改。(霍尔的原话是“我们应该忘记小的效率，比如说97%的时候:过早的优化是万恶之源。”)</p><p id="68cc" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">随着时间的推移，我已经找到了一种检测交叉轨道段的简洁方法。一个简单的基于列表的方法需要的时间与点数的平方成正比。可能对一百点有用的东西，对十万点可能要花一百万倍的时间。是时候研究数据结构了。</p><p id="44dc" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">长话短说，四叉树有几种变体可能有效，但实现起来都异常复杂。我决定尝试一个非常非常简单的方法。假设您负责一个矩形区域，并且必须跟踪您所在区域的所有路段。进一步假设你把你的区域分成四个象限(比如:西北、东北、东南、西南)。您可以实施以下规则:</p><blockquote class="kq kr ks"><p id="c8de" class="jj jk kt jl b jm jn ij jo jp jq im jr ku jt ju jv kv jx jy jz kw kb kc kd ke hb bi translated">如果路段的边界框完全在一个象限内，将责任委托给该象限。如果它跨越两个或更多，将其添加到我这一级的列表中。</p></blockquote><p id="7830" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">添加了对细分施加限制的规则，使得小于(比方说)10米的区域不被细分，这是一种定义明确且易于实现的树形结构。当然，对于某些路线来说，它可能会严重失衡，但对于大多数现实生活中的路线来说，它表现得相当不错。</p><p id="1f88" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">搜索很简单:给定一个边界框，我寻找与我所在级别的条目重叠的部分，并要求我的代理也这样做。</p><p id="0896" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">比所有这些巧妙的结构简单得多；比全面搜索好得多，但在信封背面解释起来足够简单。</p><p id="b04e" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">然后我想我可以用这个来帮助找到最近的射线。事实证明这相当简单。如果我将光线投射到XY平面，我可以通过询问“你的哪个边界框与这条线相交？”来查询数据结构</p><p id="fe5a" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">不过，我们可以做得更好。与其检索所有相互作用的盒子并找到最近的，为什么不“下推”查询，以便递归遍历跟踪“最近的”盒子并只返回一个结果？</p><p id="1cbc" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">下面是“数据结构遍历”,它使用了一个我们试图最小化的<code class="du kx ky kz kg b">valuation</code>函数:</p><pre class="iy iz ja jb fd kf kg kh ki aw kj bi"><span id="68ea" class="kk kl hi kg b fi km kn l ko kp">queryNearestToAxisUsing :<br/>    SpatialNode contentType units coords<br/>    -&gt; Axis2d.Axis2d units coords<br/>    -&gt; (contentType -&gt; Float)<br/>    -&gt; Maybe (SpatialContent contentType units coords)<br/>queryNearestToAxisUsing current axis valuation =<br/>    case current of<br/>        Blank -&gt;<br/>            Nothing</span><span id="1984" class="kk kl hi kg b fi la kn l ko kp">        SpatialNode node -&gt;<br/>            let<br/>                boxSides =<br/>                    node.box<br/>                        |&gt; Rectangle2d.fromBoundingBox<br/>                        |&gt; Rectangle2d.toPolygon<br/>                        |&gt; Polygon2d.edges</span><span id="c827" class="kk kl hi kg b fi la kn l ko kp">                intersected =<br/>                    List.any<br/>                        (\edge -&gt; LineSegment2d.intersectionWithAxis axis edge /= Nothing)<br/>                        boxSides<br/>            in<br/>            if intersected then<br/>                [ List.Extra.minimumBy (.content &gt;&gt; valuation) node.contents ]<br/>                    ++ [ queryNearestToAxisUsing node.nw axis valuation<br/>                       , queryNearestToAxisUsing node.ne axis valuation<br/>                       , queryNearestToAxisUsing node.se axis valuation<br/>                       , queryNearestToAxisUsing node.sw axis valuation<br/>                       ]<br/>                    |&gt; List.filterMap identity<br/>                    |&gt; List.Extra.minimumBy (.content &gt;&gt; valuation)</span><span id="3661" class="kk kl hi kg b fi la kn l ko kp">            else<br/>                Nothing</span></pre><p id="23e9" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">“应用程序端”调用非常简洁:</p><pre class="iy iz ja jb fd kf kg kh ki aw kj bi"><span id="2596" class="kk kl hi kg b fi km kn l ko kp">trackPointNearestFromIndexFor3d :<br/>    SpatialIndex.SpatialNode TrackPoint Length.Meters LocalCoords<br/>    -&gt; Axis3d Meters LocalCoords<br/>    -&gt; Maybe TrackPoint<br/>trackPointNearestFromIndexFor3d index ray =<br/>    let<br/>        rayShadow =<br/>            ray<br/>                |&gt; Axis3d.projectInto SketchPlane3d.xy<br/>                |&gt; Maybe.withDefault Axis2d.x</span><span id="e664" class="kk kl hi kg b fi la kn l ko kp">        distanceFunction =<br/>            .xyz<br/>                &gt;&gt; Point3d.distanceFromAxis ray<br/>                &gt;&gt; Length.inMeters<br/>    in<br/>    SpatialIndex.queryNearestToAxisUsing index rayShadow distanceFunction<br/>        |&gt; Maybe.map .content</span></pre><p id="4401" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">真正令人兴奋的是，拥有这种结构已经开启了大量的应用可能性，如果没有有效的索引，这些应用是不可能实现的。但是，我很高兴我等到有一个明确定义的需求，这不是在“过早优化”的范畴。</p></div></div>    
</body>
</html>