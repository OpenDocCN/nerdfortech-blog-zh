<html>
<head>
<title>Python programming handbook part-1</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python 编程手册第 1 部分</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/python-programming-handbook-part-1-2f5adffcdd25?source=collection_archive---------3-----------------------#2021-10-02">https://medium.com/nerd-for-tech/python-programming-handbook-part-1-2f5adffcdd25?source=collection_archive---------3-----------------------#2021-10-02</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="144b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Python 是许多 web 开发人员、机器学习实践者使用的最广泛、最强大的编程语言之一……列表还在继续，但是当我们使用 python 编程语言时，我们是否使用了它提供的所有功能！！。这是研究 python 中一些强大但广泛使用的编程实践的系列文章的第一篇。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es jd"><img src="../Images/37e3b7dcc5e4f8f8d981f00d10796647.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*taf9WHc3BPmhbxyKEu2jIg.png"/></div></div></figure><p id="d519" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在本文中，我们将重点关注以下 python <strong class="ih hj">数据结构</strong>。我们不会深入这些数据结构的基础知识，所以那些不熟悉<strong class="ih hj"> python 2 </strong>或<strong class="ih hj"> python 3 </strong>的人可能会发现理解本文中解释的一些概念有困难。</p><ul class=""><li id="b53d" class="jp jq hi ih b ii ij im in iq jr iu js iy jt jc ju jv jw jx bi translated"><strong class="ih hj">列表</strong></li><li id="e979" class="jp jq hi ih b ii jy im jz iq ka iu kb iy kc jc ju jv jw jx bi translated"><strong class="ih hj">元组</strong></li><li id="0da2" class="jp jq hi ih b ii jy im jz iq ka iu kb iy kc jc ju jv jw jx bi translated"><strong class="ih hj">字典</strong></li><li id="1675" class="jp jq hi ih b ii jy im jz iq ka iu kb iy kc jc ju jv jw jx bi translated"><strong class="ih hj">设置</strong></li></ul><p id="a1db" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">元素数组</strong></p><p id="880e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">最基本和最广泛使用的可变和混合类型数据结构是列表。考虑到你们大多数人都习惯于处理列表数据类型，让我们直接进入列表理解。</p><blockquote class="kd ke kf"><p id="0e77" class="if ig kg ih b ii ij ik il im in io ip kh ir is it ki iv iw ix kj iz ja jb jc hb bi translated">列表理解和生成器表达式是在 python 中构建元素序列的两种快速方法。在编程社区中，列表理解一般称为<strong class="ih hj"> <em class="hi">列表组合</em> </strong>，而生成器表达式称为<strong class="ih hj"><em class="hi">gen-exps</em></strong><em class="hi">。</em></p></blockquote><p id="05a9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">使用列表理解构建列表</strong></p><pre class="je jf jg jh fd kk kl km kn aw ko bi"><span id="ed43" class="kp kq hi kl b fi kr ks l kt ku">symbols = "abcdefg"<br/>lis1 = [ord(sym) for sym in symbols]<br/>print(lis1)</span><span id="0a40" class="kp kq hi kl b fi kv ks l kt ku">&gt;&gt;&gt; [97, 98, 99, 100, 101, 102, 103]</span></pre><p id="7f04" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我的目标是构建一个包含上述符号“<strong class="ih hj"> abcdefg </strong>”的 Unicode 替换的列表。上面的例子显示了使用列表理解来构造这样的列表。</p><blockquote class="kd ke kf"><p id="d02f" class="if ig kg ih b ii ij ik il im in io ip kh ir is it ki iv iw ix kj iz ja jb jc hb bi translated"><em class="hi">在 python 代码中，像</em> <strong class="ih hj"> <em class="hi"> { }，( )，[ ] </em> </strong> <em class="hi">这样的符号成对出现时会忽略换行符。因此，您可以构建多个行列表 comps，而无需使用</em> <strong class="ih hj"> <em class="hi"> \ </em> </strong> <em class="hi">换行符。</em></p></blockquote><p id="867d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">列表理解的其他一些例子</strong></p><p id="1b04" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">例 1 </strong>:过滤掉大于 100 的<strong class="ih hj"> Unicode 值</strong>。</p><pre class="je jf jg jh fd kk kl km kn aw ko bi"><span id="87cc" class="kp kq hi kl b fi kr ks l kt ku">lis2 = [ord(sym) for sym in symbols if ord(sym) &gt; 100]<br/>print(lis2)</span><span id="1182" class="kp kq hi kl b fi kv ks l kt ku">&gt;&gt;&gt;[101, 102, 103]</span></pre><p id="6b96" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">例 2 </strong>:笛卡尔积</p><pre class="je jf jg jh fd kk kl km kn aw ko bi"><span id="f8a5" class="kp kq hi kl b fi kr ks l kt ku">lis3 = [(student, subject) for student in students for subject in subjects]<br/>print(lis3)</span><span id="983d" class="kp kq hi kl b fi kv ks l kt ku">&gt;&gt;&gt;[('jon', 'science'), ('jon', 'maths'), ('jon', 'history'),   ('doe', 'science'), ('doe', 'maths'), ('doe', 'history'), ('jack', 'science'), ('jack', 'maths'), ('jack', 'history')]</span></pre><p id="cca0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">元组和生成器表达式</strong></p><p id="875e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">生成器表达式类似于列表理解，但是生成器表达式通过一个接一个地产生条目来节省内存，而不是构建一个完整的列表来提供给构造函数。</p><pre class="je jf jg jh fd kk kl km kn aw ko bi"><span id="3850" class="kp kq hi kl b fi kr ks l kt ku">tup1 = tuple(ord(sym) for sym in symbols)<br/>print(tup1)</span><span id="379d" class="kp kq hi kl b fi kv ks l kt ku">&gt;&gt;&gt;(97, 98, 99, 100, 101, 102, 103)</span></pre><p id="ed2e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">一些 python 入门教材将列表称为可变数据类型，将元组称为不可变数据类型。但是元组远不止这些，现在让我们来看看元组可以被使用的领域。</p><p id="2d8d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">用作记录的元组</strong></p><p id="621d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">元组广泛用于将值存储为记录，下面给出了一个将元组用作记录的示例。</p><pre class="je jf jg jh fd kk kl km kn aw ko bi"><span id="4659" class="kp kq hi kl b fi kr ks l kt ku">City = ("Tokyo", "Delhi", "New York")<br/>Student = ("doe", "john", "jack")<br/>student_list = [('john', 1), ("doe", 2), ('jack', 3)]<br/><br/>for student in student_list:<br/>    print('%s-%s' % student)</span><span id="bd35" class="kp kq hi kl b fi kv ks l kt ku">&gt;&gt;&gt;john-1<br/>doe-2<br/>jack-3</span></pre><p id="78c5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">元组解包</strong></p><p id="d20e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">提取存储在一个元组中的值被称为<strong class="ih hj">元组解包</strong>，解包元组值的方式有很多，但并行执行是元组解包最有效、最简单的方式之一。</p><pre class="je jf jg jh fd kk kl km kn aw ko bi"><span id="8dd5" class="kp kq hi kl b fi kr ks l kt ku">co_ordinates = (1.0, 2.0, 3.0)<br/>x, y, z = co_ordinates<br/>print(x, y, z)</span><span id="f3b2" class="kp kq hi kl b fi kv ks l kt ku">&gt;&gt;&gt;1.0 2.0 3.0</span></pre><p id="84b3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">元组示例的另一种方式是解包，即在函数中使用<strong class="ih hj"> *args </strong>。</p><pre class="je jf jg jh fd kk kl km kn aw ko bi"><span id="9458" class="kp kq hi kl b fi kr ks l kt ku">def div(a, b):<br/>    return a / b<br/><br/><br/>t = (10, 2)<br/>print(div(*t))</span><span id="09f3" class="kp kq hi kl b fi kv ks l kt ku">&gt;&gt;&gt;5.0</span></pre><p id="3fa3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">命名元组</strong></p><p id="dc27" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">命名元组可以用作存储关于对象的信息的存储器。</p><p id="630e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在下面的例子中，创建了一个命名的 tuple student 来存储学生信息。在第二行中，创建了一个名为 doe 的学生实例。</p><pre class="je jf jg jh fd kk kl km kn aw ko bi"><span id="ebcb" class="kp kq hi kl b fi kr ks l kt ku">from collections import namedtuple<br/><br/>Student = namedtuple('Student', 'name marks')<br/>doe = Student('Doe', (22, 34, 45, 64))<br/>print(doe.marks)</span><span id="cf91" class="kp kq hi kl b fi kv ks l kt ku">&gt;&gt;&gt;(22, 34, 45, 64)</span></pre><p id="7973" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">用二等分和内排序管理序列</strong></p><p id="b087" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">collections . bi section</strong>有两个方法用于按顺序管理序列。</p><pre class="je jf jg jh fd kk kl km kn aw ko bi"><span id="3295" class="kp kq hi kl b fi kr ks l kt ku">lis1 = [1, 4, 5, 6, 8, 12, 15, 20, 21, 23, 23, 26, 29, 30]<br/>print(bisect.bisect(lis1, 6))<br/>bisect.insort(lis1, 31)<br/>print(lis1)</span><span id="0884" class="kp kq hi kl b fi kv ks l kt ku">&gt;&gt;&gt;4<br/>[1, 4, 5, 6, 8, 12, 15, 20, 21, 23, 23, 26, 29, 30, 31]</span></pre><p id="9776" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在上面的例子中，二分法将返回元素 6 在列表中的位置，即 4。</p><p id="9860" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">insort 方法会将元素添加到列表中的正确位置，即元素 31 将被添加到列表的末尾。</p><p id="31c6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">字典</strong></p><blockquote class="kd ke kf"><p id="42a5" class="if ig kg ih b ii ij ik il im in io ip kh ir is it ki iv iw ix kj iz ja jb jc hb bi translated">字典不仅在我们的编程实现中很重要，在整个 python 编程结构中也很重要。字典在类、名称空间、模块构造等中无处不在。由于散列表的重要作用，它们被用在字典的后端，这使得它们非常有效。</p></blockquote><p id="4e4a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">类似于用于创建列表的列表理解。字典理解用于创建字典。</p><pre class="je jf jg jh fd kk kl km kn aw ko bi"><span id="3b58" class="kp kq hi kl b fi kr ks l kt ku">DIAL_CODES = [<br/>    (86, 'China'),<br/>    (91, 'India'),<br/>    (1, 'United States'),<br/>    (62, 'Indonesia'),<br/>    (55, 'Brazil'),<br/>    (92, 'Pakistan'),<br/>    (880, 'Bangladesh'),<br/>    (234, 'Nigeria'),<br/>    (7, 'Russia'),<br/>    (81, 'Japan'),<br/>]<br/>dict1 = {country: code for code, country in DIAL_CODES}<br/>print(dict1)</span><span id="c783" class="kp kq hi kl b fi kv ks l kt ku">&gt;&gt;&gt;{'China': 86, 'India': 91, 'United States': 1, 'Indonesia': 62, 'Brazil': 55, 'Pakistan': 92, 'Bangladesh': 880, 'Nigeria': 234, 'Russia': 7, 'Japan': 81}</span></pre><p id="9862" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">使用默认字典处理字典中缺失的键值</strong></p><p id="bb90" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">使用字典时，很有可能会引用字典中没有的值，<strong class="ih hj">默认字典</strong>是一种用来防止这种问题的字典。</p><pre class="je jf jg jh fd kk kl km kn aw ko bi"><span id="fe89" class="kp kq hi kl b fi kr ks l kt ku">dict2 = collections.defaultdict(list)<br/>print(dict2[3])</span><span id="7a19" class="kp kq hi kl b fi kv ks l kt ku">&gt;&gt;&gt;[]</span></pre><p id="0152" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">默认字典采用一个称为默认工厂的参数，这个值可以是列表、字典、集合等。基于这个值，如果关键字不在字典中，将返回上面的值。所以在上面的例子中，将返回一个空列表。</p><p id="5190" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">字典的变化</strong></p><p id="a19c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">命令字典</strong></p><p id="eccd" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">保持键的插入顺序。在调用 popitem 方法时，默认情况下将弹出第一个项目。这可以通过用 popitem()给参数 reverse=True 来改变。</p><p id="cd4e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> Collections.counter </strong></p><p id="3a34" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">计数器用于保存每个键的整数计数。更新时，键计数器的值也将被更新。</p><pre class="je jf jg jh fd kk kl km kn aw ko bi"><span id="1b0e" class="kp kq hi kl b fi kr ks l kt ku">counter = collections.Counter('aaaabctdedede')<br/>print(counter)</span><span id="0950" class="kp kq hi kl b fi kv ks l kt ku">&gt;&gt;&gt;Counter({'a': 4, 'd': 3, 'e': 3, 'b': 1, 'c': 1, 't': 1})</span><span id="2e3f" class="kp kq hi kl b fi kv ks l kt ku">counter.update('aaaaaa')<br/>print(counter)</span><span id="a5e2" class="kp kq hi kl b fi kv ks l kt ku">&gt;&gt;&gt;Counter({'a': 10, 'd': 3, 'e': 3, 'b': 1, 'c': 1, 't': 1})</span></pre><p id="4c40" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">从上面的例子中我们可以看到，通过更新计数器的值，a 的计数在字典中得到更新。</p><p id="e007" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">映射代理</strong></p><p id="b83b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在某些情况下，我们不想改变字典的映射，因为 python 提供了一个 mappingproxy 类型，它的映射是不能改变的。</p><pre class="je jf jg jh fd kk kl km kn aw ko bi"><span id="3bf0" class="kp kq hi kl b fi kr ks l kt ku">from types import MappingProxyType<br/><br/>d = {1: 'A'}<br/>d_proxy = MappingProxyType(d)<br/>print(d_proxy)</span></pre><p id="425b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在上面的例子中，d_proxy 就像一个不可变的字典，它的赋值是不能改变的。</p><pre class="je jf jg jh fd kk kl km kn aw ko bi"><span id="4607" class="kp kq hi kl b fi kr ks l kt ku">d_proxy[1] = 'B'</span></pre><p id="15b2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这种重新分配是不可能的。</p><p id="ac2c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">集合理论</strong></p><p id="be30" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在让我们来看本文的最后一部分，即集合论，集合是定义明确的对象集合，基本用途是避免重复。</p><p id="7402" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">基本设定操作</strong></p><pre class="je jf jg jh fd kk kl km kn aw ko bi"><span id="154d" class="kp kq hi kl b fi kr ks l kt ku">a = ['apple', 'orange', 'apple']<br/>b = ['apple', 'apple']<br/>a = set(a)<br/>b = set(b)<br/>print(a &amp; b)  # intersection of a &amp; b<br/>print(a | b)  # Union of a and b<br/>print(a - b)  # Difference between a &amp; b</span><span id="d6b1" class="kp kq hi kl b fi kv ks l kt ku">&gt;&gt;&gt;{'apple'}<br/>&gt;&gt;&gt;{'apple', 'orange'}<br/>&gt;&gt;&gt;{'orange'}</span></pre><blockquote class="kd ke kf"><p id="1d26" class="if ig kg ih b ii ij ik il im in io ip kh ir is it ki iv iw ix kj iz ja jb jc hb bi translated">重要的一点是，空集没有字面上的定义，定义的空集将被当作一个字典。</p></blockquote><pre class="je jf jg jh fd kk kl km kn aw ko bi"><span id="c1fd" class="kp kq hi kl b fi kr ks l kt ku">d1 = {'one'}<br/>print(type(d1))<br/>d2 = {}<br/>print(type(d2))</span><span id="93a2" class="kp kq hi kl b fi kv ks l kt ku">&gt;&gt;&gt;&lt;class 'set'&gt;<br/>&gt;&gt;&gt;&lt;class 'dict'&gt;</span><span id="72f2" class="kp kq hi kl b fi kv ks l kt ku">c = set()  # empty set</span></pre><p id="1c35" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">集合理解</strong></p><p id="531a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">类似于字典和列表，集合理解可以用来构造集合。</p><pre class="je jf jg jh fd kk kl km kn aw ko bi"><span id="bf2d" class="kp kq hi kl b fi kr ks l kt ku">set1 = {chr(i) for i in range(1, 256)}<br/>print(set1)</span></pre><p id="d624" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">数字 1 到 256 的所有 Unicode 表示。</p></div></div>    
</body>
</html>