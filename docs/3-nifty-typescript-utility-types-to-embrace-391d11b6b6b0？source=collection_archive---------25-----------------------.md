# 包含 3 种漂亮的类型脚本实用程序类型

> 原文：<https://medium.com/nerd-for-tech/3-nifty-typescript-utility-types-to-embrace-391d11b6b6b0?source=collection_archive---------25----------------------->

由于复杂的类型，我经常发现自己在与 Typescript 代码样式和可读性作斗争。在本文中，我们将看一下 TypeScript 提供的一些实用工具类型，它们可能会帮助您清理类型系统，以获得更精简的代码库。

# 1.使用`Partial`实用程序类型

TypeScript 有许多实用工具类型，可以帮助您清理代码并使您的形状缩放得更好。我们将讨论其中的几个实用程序类型，我们将从`Partial`开始。

`Partial`描述了一个类型的一部分，或者换句话说，创建一个类型，将原始类型的所有属性都设置为可选。当您试图帮助动态访问值时，这非常有用。

上面的例子描述了一个用例，我们在前端实现了一个过滤系统。假设我们有一个人员列表，上面有姓名、年龄和职业，我们想用一个漂亮的形状来描述我们的有源滤波器。如您所见，我们在助手函数中使用了`Partial`来创建一个新的过滤器，以更新过滤器，使其包含名称“Akos”有了这个简单的工具，我们可以描述一个非常灵活和抗错误的方式来改变我们的数据。

`Partial`对于我们需要灵活性的情况非常有用。然而，在某些情况下，我们希望确保某些属性对于应用程序的某些部分是不可访问的。让我们看看另一种实用程序类型来解决这个问题。

# 2.使用`Omit`实用程序类型

我们已经看到了一个漂亮而方便的实用程序类型的使用，让我们来看看另一个以`Omit`形式出现的实用程序。就在上面我们谈到了`Partial`。这是一个很棒的工具，可以让一个类型的所有属性都是可选的，然而，在某些情况下，我们只需要更严格地限制什么形状可以进入我们系统的什么部分。让我们看看下面的例子:

在上面的代码中，我们可以看到在一个函数中使用了一个`User`类型，该函数可能会对这些敏感数据进行一些修改，可能会将其存储在与 GDPR 尚不完全兼容的系统中。我们希望确保在这种情况下我们保护了用户的数据(甚至是我们自己的数据),并且我们可以使用`Omit`实用程序类型在将 GDPR 敏感字段放入该函数之前删除它。

使用上面的代码，我们确保只有`oid`字段是从原始的`User`类型传递过来的，它对 GDPR 不敏感，所以我们可以在函数的这一点上对输入数据做任何我们想做的事情。

限制对成员的访问有时足以避免灾难。然而，在某些情况下，对于应用程序中易变的敏感部分，有另一种实用程序类型可以确保代码库中的错误更少

# 3.使用`Readonly`实用程序类型

随着函数式编程和不可变编程模式的兴起，越来越多的人要求我们的代码不要修改变量的值。随着 ES6 的兴起，JavaScript 提供的`const`关键字修复了我们的许多问题，然而，它并没有给出我们可能期望的不变性。考虑下面的片段:

在上面的代码中，我们定义了一个`Animal`类型和它的一个名为`dog`的实例。我们可能认为代码不会工作，因为`dog`是用 const 关键字实例化的，然而，在 JS 中`const`关键字意味着变量本身不能被赋予新的内容，然而，如果值是一个对象，[对象的值仍然可以被改变](https://akoshochrein.com/posts/3-nifty-typescript-utility-types-to-embrace/%5BECMAScript%206:%20New%20Features:%20Overview%20and%20Comparison%5D(http://es6-features.org/#Constants))。产生以下输出:

```
[LOG]: "woof" 
[LOG]: "vau"
```

在我们陷入无法解决的戏剧之前，幸运的是我们有一个由 TypeScript 提供的工具来确保我们的类型的实例不能被更改，这被称为`Readonly`实用程序类型。让我们来看看它的实际应用:

在上面的示例中，程序因编译错误而失败:

```
Cannot assign to 'sound' because it is a read-only property.
```

这意味着，使用这种实用程序类型，您可以确保系统中敏感变量的不变性，从而减少长期错误。谢谢打字稿！

# 摘要

我们今天已经看了很多工具。这里有一个简短的总结:

`Partial`是一个实用程序类型，创建一个新类型，将输入类型的所有属性设置为可选。在为您的类型构建灵活的数据更新工具时会很有用。

`Omit`也是一个实用类型，它创建一个新类型，并从原始类型中删除所有指定的属性。当您想要为系统的一部分从已经存在的类型中创建更严格的类型时，这很有用。

`Readonly`是另一种实用程序类型，它使你能够使你的类型的所有实例禁止值重新分配给它们的所有属性。

感谢大家到目前为止的阅读，期待我们的下一次会议！

*原载于 2021 年 5 月 2 日 https://akoshochrein.com**[*。*](https://akoshochrein.com/posts/3-nifty-typescript-utility-types-to-embrace/)*