<html>
<head>
<title>LeetCode — Generate Parentheses</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">LeetCode —生成括号</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/leetcode-generate-parentheses-5b9a16ecb6b6?source=collection_archive---------8-----------------------#2021-08-15">https://medium.com/nerd-for-tech/leetcode-generate-parentheses-5b9a16ecb6b6?source=collection_archive---------8-----------------------#2021-08-15</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><h1 id="83de" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">问题陈述</h1><p id="b624" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">给定<strong class="jf hj"> n </strong>对括号，写一个函数给<em class="kb">生成所有格式良好的括号组合</em>。</p><p id="9e06" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated">问题陈述摘自:【https://leetcode.com/problems/generate-parentheses T4】</p><p id="9584" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated"><strong class="jf hj">例1: </strong></p><pre class="ki kj kk kl fd km kn ko kp aw kq bi"><span id="0831" class="kr ig hi kn b fi ks kt l ku kv">Input: n = 3<br/>Output: ["((()))", "(()())", "(())()", "()(())", "()()()"]</span></pre><p id="5b50" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated"><strong class="jf hj">例2: </strong></p><pre class="ki kj kk kl fd km kn ko kp aw kq bi"><span id="74a9" class="kr ig hi kn b fi ks kt l ku kv">Input: n = 1<br/>Output: ["()"]</span></pre><p id="61ba" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated"><strong class="jf hj">约束:</strong></p><pre class="ki kj kk kl fd km kn ko kp aw kq bi"><span id="c554" class="kr ig hi kn b fi ks kt l ku kv">- 1 &lt;= n &lt;= 8</span></pre><h1 id="4eda" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">说明</h1><h2 id="86a9" class="kr ig hi bd ih kw kx ky il kz la lb ip jo lc ld it js le lf ix jw lg lh jb li bi translated">强力</h2><p id="db7e" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">解决这个问题的一个强力方法是使用<strong class="jf hj"> ( </strong>和<strong class="jf hj"> ) </strong>生成括号的所有组合。然后验证哪些是有效的，并将有效的添加到结果中。</p><p id="454f" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated">上述逻辑的一小段C++代码如下所示:</p><pre class="ki kj kk kl fd km kn ko kp aw kq bi"><span id="269d" class="kr ig hi kn b fi ks kt l ku kv">vector&lt;string&gt; generateParenthesis(int n) {<br/>    vector&lt;string&gt; combinations;<br/>    generateAll("", 0, combinations);<br/>    return combinations;<br/>}<br/><br/>void generateAll(string current, int pos, vector&lt;string&gt; result) {<br/>    if (pos == current.length) {<br/>        if (valid(current))<br/>            result.add(string(current));<br/>    } else {<br/>        current += '(';<br/>        generateAll(current, pos+1, result);<br/>        current += ')';<br/>        generateAll(current, pos+1, result);<br/>    }<br/>}<br/><br/>bool valid(string current) {<br/>    int balance = 0;<br/>    for (int i = 0; i &lt; current.length; i++) {<br/>        if (current[i] == '(') balance++;<br/>        else balance--;<br/>        if (balance &lt; 0) return false;<br/>    }<br/>    return balance == 0;<br/>}</span></pre><p id="d6dc" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated">上述程序的时间复杂度为<strong class="jf hj"> O((2 n)*n) </strong>。</p><h2 id="384f" class="kr ig hi bd ih kw kx ky il kz la lb ip jo lc ld it js le lf ix jw lg lh jb li bi translated">追踪</h2><p id="f829" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">使用回溯法可以避免产生所有可能的括号排列。</p><p id="1e40" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated">与上述方法中每次添加<strong class="jf hj"> ( </strong>或<strong class="jf hj"> ) </strong>不同，我们只在知道它仍然是有效序列时才添加它们。为此，我们可以跟踪到目前为止我们添加的开始和结束括号的数量。</p><h2 id="62f5" class="kr ig hi bd ih kw kx ky il kz la lb ip jo lc ld it js le lf ix jw lg lh jb li bi translated">算法</h2><pre class="ki kj kk kl fd km kn ko kp aw kq bi"><span id="01b0" class="kr ig hi kn b fi ks kt l ku kv">- initialize result array.<br/><br/>- call _generateParenthesis("", n, 0, 0, result)<br/>  - This is a recursive function that will generate the valid parenthesis.<br/><br/>- return result<br/><br/>// _generateParenthesis(current, n, left, right, result)<br/><br/>- if right == n<br/>  - result.push_back(current) and return<br/>- else<br/>  - if left &lt; n<br/>    - call _generateParenthesis(current + '(', n, left + 1, right, result)<br/><br/>  - if left &gt; right<br/>    - call _generateParenthesis(current + ')', n, left, right + 1, result)</span></pre><p id="9842" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated"><strong class="jf hj"> C++解决方案</strong></p><pre class="ki kj kk kl fd km kn ko kp aw kq bi"><span id="dfc3" class="kr ig hi kn b fi ks kt l ku kv">class Solution {<br/>public:<br/>    void _generateParenthesis(string current, int n, int left, int right, vector&lt;string&gt;&amp; result) {<br/>        if(right == n){<br/>            result.push_back(current);<br/>            return;<br/>        } else {<br/>            if(left &lt; n){<br/>                _generateParenthesis(current + '(', n, left + 1, right, result);<br/>            }<br/><br/>            if(left &gt; right){<br/>                _generateParenthesis(current + ')', n, left, right + 1, result);<br/>            }<br/>        }<br/>    }<br/><br/>    vector&lt;string&gt; generateParenthesis(int n) {<br/>        vector&lt;string&gt; result;<br/>        _generateParenthesis("", n, 0, 0, result);<br/><br/>        return result;<br/>    }<br/>};</span></pre><p id="4d3c" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated"><strong class="jf hj">戈朗解</strong></p><pre class="ki kj kk kl fd km kn ko kp aw kq bi"><span id="6e3f" class="kr ig hi kn b fi ks kt l ku kv">func generateParenthesis(n int) []string {<br/>    result := make([]string, 0)<br/><br/>    _generateParenthesis("", n, 0, 0, &amp;result)<br/>    return result<br/>}<br/><br/>func _generateParenthesis(current string, n, left, right int, result *[]string) {<br/>    if right == n {<br/>        *result = append(*result, current)<br/>        return<br/>    } else {<br/>        if left &lt; n {<br/>            _generateParenthesis(current + "(", n, left + 1, right, result)<br/>        }<br/><br/>        if left &gt; right {<br/>            _generateParenthesis(current + ")", n, left, right + 1, result)<br/>        }<br/>    }<br/>}</span></pre><p id="d019" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated"><strong class="jf hj"> Javascript解决方案</strong></p><pre class="ki kj kk kl fd km kn ko kp aw kq bi"><span id="44f2" class="kr ig hi kn b fi ks kt l ku kv">var generateParenthesis = function(n) {<br/>    let result = [];<br/><br/>    _generateParenthesis("", n, 0, 0, result);<br/><br/>    return result;<br/>};<br/><br/>var _generateParenthesis = function(current, n, left, right, result){<br/>    if( right === n ) {<br/>        result.push(current);<br/>        return;<br/>    } else {<br/>        if( left &lt; n ) {<br/>           _generateParenthesis(current + '(', n, left + 1, right, result);<br/>        }<br/><br/>        if( left &gt; right) {<br/>            _generateParenthesis(current + ')', n, left, right + 1, result);<br/>        }<br/>    }<br/>}</span></pre><p id="ca9a" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated">让我们试运行一下我们的算法，看看解决方案是如何工作的。</p><pre class="ki kj kk kl fd km kn ko kp aw kq bi"><span id="a740" class="kr ig hi kn b fi ks kt l ku kv">Input: n = 2<br/><br/>Step 1: vector&lt;string&gt; result;<br/><br/>Step 2: _generateParenthesis("", n, 0, 0, result)<br/><br/>// in _generateParenthesis(current, n, left, right, result)<br/><br/>Step 3: right == n<br/>        0 == 2<br/>        false<br/><br/>        left &lt; n<br/>        0 &lt; 2<br/>        true<br/><br/>        _generateParenthesis(current + '(', n, left + 1, right, result)<br/>        _generateParenthesis('' + '(', 2, 0 + 1, 0, [])<br/>        _generateParenthesis('(', 2, 1, 0, [])<br/><br/>Step 4: right == n<br/>        0 == 2<br/>        false<br/><br/>        left &lt; n<br/>        1 &lt; 2<br/>        true<br/><br/>        _generateParenthesis(current + '(', n, left + 1, right, result)<br/>        _generateParenthesis('(' + '(', 2, 1 + 1, 0, [])<br/>        _generateParenthesis('((', 2, 2, 0, [])<br/><br/>Step 5: right == n<br/>        0 == 2<br/>        false<br/><br/>        left &lt; n<br/>        2 &lt; 2<br/>        false<br/><br/>        left &gt; right<br/><br/>        2 &gt; 0<br/>        true<br/><br/>        _generateParenthesis(current + ')', n, left, right + 1, result)<br/>        _generateParenthesis('((' + ')', 2, 2, 0 + 1, [])<br/>        _generateParenthesis('(()', 2, 2, 1, [])<br/><br/>Step 6: right == n<br/>        1 == 2<br/>        false<br/><br/>        left &lt; n<br/>        2 &lt; 2<br/>        false<br/><br/>        left &gt; right<br/><br/>        2 &gt; 1<br/>        true<br/><br/>        _generateParenthesis(current + ')', n, left, right + 1, result)<br/>        _generateParenthesis('(()' + ')', 2, 2, 1 + 1, [])<br/>        _generateParenthesis('(())', 2, 2, 2, [])<br/><br/>Step 7: right == n<br/>        2 == 2<br/>        true<br/><br/>        result.push_back(current)<br/>        [].push_back("(())")<br/>        ["(())"]<br/><br/>Step 8: This step goes to the next line of Step 4, where the left is set to 1 and the right is 0.<br/><br/>        left = 1<br/>        right = 0<br/>        current = '('<br/><br/>        _generateParenthesis(current + ')', n, left, right + 1, result)<br/>        _generateParenthesis('(' + ')', 2, 1, 0 + 1, ["(())"])<br/>        _generateParenthesis('()', 2, 1, 1, ["(())"])<br/><br/>Step 9: right == n<br/>        1 == 2<br/>        false<br/><br/>        left &lt; n<br/>        1 &lt; 2<br/>        true<br/><br/>        _generateParenthesis(current + '(', n, left + 1, right, result)<br/>        _generateParenthesis('()' + '(', 2, 1 + 1, 1, ["(())"])<br/>        _generateParenthesis('()(', 2, 2, 1, ["(())"])<br/><br/>Step 10: right == n<br/>         1 == 2<br/>         false<br/><br/>         left &lt; n<br/>         2 &lt; 2<br/>         false<br/><br/>         left &gt; right<br/>         2 &gt; 1<br/><br/>         _generateParenthesis(current + ')', n, left, right + 1, result)<br/>         _generateParenthesis('()(' + ')', 2, 2, 1 + 1, ["(())"])<br/>         _generateParenthesis('()()', 2, 2, 2, ["(())"])<br/><br/>Step 11: right == n<br/>         2 == 2<br/>         true<br/><br/>         result.push_back(current)<br/>         ["(())"].push_back("()()")<br/><br/>Control flows back to Step 3 and then fallbacks to Step 2.<br/><br/>We return result as ["(())", "()()"].</span></pre></div><div class="ab cl lj lk gp ll" role="separator"><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo"/></div><div class="hb hc hd he hf"><p id="ee99" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated"><em class="kb">原载于</em><a class="ae kh" href="https://alkeshghorpade.me/post/leetcode-generate-parenthesis" rel="noopener ugc nofollow" target="_blank"><em class="kb">https://alkeshghorpade . me</em></a><em class="kb">。</em></p></div></div>    
</body>
</html>