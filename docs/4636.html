<html>
<head>
<title>Writing bulletproof code with Property-Based testing</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用基于属性的测试编写防弹代码</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/multiplying-the-quality-of-your-unit-tests-with-property-based-tests-d3c2cb2d5601?source=collection_archive---------13-----------------------#2021-07-30">https://medium.com/nerd-for-tech/multiplying-the-quality-of-your-unit-tests-with-property-based-tests-d3c2cb2d5601?source=collection_archive---------13-----------------------#2021-07-30</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><figure class="hh hi ez fb hj hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es hg"><img src="../Images/0affa472747c6c815096ae1cb9790c91.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OZKFMzqtI0FyOrvatlRYRQ.jpeg"/></div></div></figure><div class=""/><p id="0b4c" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在前一篇文章中，我们看到了如何编写更集中、简洁和可伸缩的测试。然而，<em class="jo">参数化测试</em>属于所谓的<em class="jo">基于实例的测试</em>:测试只使用我们选择作为实例传递的输入和期望值<strong class="is hu">运行。这就产生了一个问题:如果我们没有选择任何其他有效的例子，那么测试就不能通过呢？</strong></p><h1 id="11bb" class="jp jq ht bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">回到密码验证器的例子</h1><p id="2f10" class="pw-post-body-paragraph iq ir ht is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hb bi translated">编写测试的原因之一是它们保护我们免受回归错误的影响。它们是一种工具，用于检测导致正常工作的功能停止工作的代码更改。如果发生这种情况，相应的测试会变红，并指出哪里出了问题。</p><p id="bf88" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">回到我上一篇文章的PasswordValidator，最终的<em class="jo">参数化测试</em>如下所示:</p><figure class="ks kt ku kv fd hk"><div class="bz dy l di"><div class="kw kx l"/></div></figure><p id="dfa2" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在让我们想象一下，您需要在验证器中做一些调整。你完成它，推你的代码。但是，事实证明，另一个队友也接触了验证器，你们正在发生一些冲突。您解决了冲突并再次推送代码。最后，您的测试在您的CI中运行正常，因此您有足够的信心合并您的代码。</p><p id="e58a" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">但是，在此之前，您的团队成员审查了代码，并要求您做一些代码更改。他发现<code class="du ky kz la lb b">ContainsUpperCaseLetterValidator</code>的实现是不正确的。</p><p id="bebc" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">所以你看一看…</p><figure class="ks kt ku kv fd hk"><div class="bz dy l di"><div class="kw kx l"/></div></figure><p id="1987" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">是的，原来它现在验证小写(即<code class="du ky kz la lb b">"[a-z]"</code>)而不是大写字符(即<code class="du ky kz la lb b">"[A-Z]"</code>)。另一方面，你感到困惑。CI上的所有测试都正常。会有什么问题呢？所以您在本地再次运行测试。</p><figure class="ks kt ku kv fd hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es lc"><img src="../Images/154a7381004cb8b98dde52d4e493c74e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*rRnk4FSPj-HzjbJc"/></div></div></figure><p id="1de6" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">还是绿色的。我们知道它应该是红色的，因为我们已经发现了实现本身的错误。但是仔细看看<code class="du ky kz la lb b">ContainsUpperCaseLetterValidator</code>第一个<em class="jo">基于实例的测试</em>。</p><p id="5e57" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们在那里输入密码“123456”，所以<code class="du ky kz la lb b">passwordValidator.validate("123456")</code>应该会返回一个错误消息，不仅针对<code class="du ky kz la lb b">ContainsUpperCaseValidator</code>，也针对<code class="du ky kz la lb b">ContainsLowerCaseValidator</code>，因为它既不包含大写字符也不包含小写字符，只有数字。</p><p id="5758" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在这种情况下，我们可以通过为<code class="du ky kz la lb b">ContainsUpperCaseValidator</code>添加一个在密码输入中包含小写字符的额外示例来“修复”测试(但不是实现)，例如“a23456”。这样做时，测试运行为红色，正如预期的那样。</p><figure class="ks kt ku kv fd hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es ld"><img src="../Images/1da85dc59ed408a33d3cc319f11cfb04.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*y4xU6T279U195g82"/></div></div></figure><blockquote class="le lf lg"><p id="e4da" class="iq ir jo is b it iu iv iw ix iy iz ja lh jc jd je li jg jh ji lj jk jl jm jn hb bi translated"><em class="ht">检查</em> <a class="ae lk" href="https://github.com/sergio-sastre/Multiplying_the_quality_of_unit_tests/blob/master/app/src/test/java/sergio/sastre/multiplying/quality/of/unittests/parameterizedbroken/PasswordUnitTests.kt" rel="noopener ugc nofollow" target="_blank"> <em class="ht">这个链接</em> </a> <em class="ht">查看失败样本的代码或者</em> <a class="ae lk" href="https://github.com/sergio-sastre/Multiplying_the_quality_of_unit_tests/blob/master/app/src/test/java/sergio/sastre/multiplying/quality/of/unittests/parameterized/PasswordUnitTests.kt" rel="noopener ugc nofollow" target="_blank"> <em class="ht">这个其他链接</em> </a> <em class="ht">查看所有</em>参数化测试的全套</p></blockquote><h1 id="45a5" class="jp jq ht bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">拯救基于属性的测试</h1><p id="fafe" class="pw-post-body-paragraph iq ir ht is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hb bi translated">根据前面的例子，我们可以得出结论<strong class="is hu">任何没有至少一个大写字符的密码，必须显示错误消息“不包含大写字符”</strong>。这种每次都必须有效的前提条件和质量的组合被称为<em class="jo">属性</em>。</p><p id="297c" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如果不是仅仅通过<em class="jo">参数化测试</em>提供具体有效的例子，我们还会<strong class="is hu">为前提条件(无大写字符)生成随机有效值</strong>，该前提条件必须总是满足质量(在错误消息中显示“不包含大写字符”),会怎么样？这被称为<em class="jo">基于属性的测试(PBT) </em>。</p><p id="15f8" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在我看来，目前最强大的JVM语言PBT引擎是Jqwik。我发现在编写自定义值生成器时，它比<em class="jo"> Kotest </em>或<em class="jo"> QuickUnit </em>灵活得多。此外，它还提供了一些独特的功能，例如<em class="jo">为生成的输入收集统计数据</em>，这对于确保生成的随机值在预期值之内非常有用。所以本文所有的例子都会用<em class="jo"> Jqwik </em>来写。</p><h1 id="d4d6" class="jp jq ht bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">配置</h1><p id="e0d5" class="pw-post-body-paragraph iq ir ht is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hb bi translated">Jqwik 非常容易配置，<strong class="is hu">可以与Junit4和Junit5 </strong>一起运行。在一个Android项目中，你只需要将以下内容添加到你的项目gradle文件中。</p><figure class="ks kt ku kv fd hk"><div class="bz dy l di"><div class="kw kx l"/></div></figure><p id="5b43" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">对于其他java/jvm项目，你可以查看Jqwik文档。</p><h1 id="2b0b" class="jp jq ht bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">我们的第一个基于属性的测试</h1><p id="c63d" class="pw-post-body-paragraph iq ir ht is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hb bi translated">基于属性的测试需要提供一个生成器，该生成器通过编程或通过注释来创建约束值。在<em class="jo"> Jqwik </em>中，你可以用<code class="du ky kz la lb b">@Provide</code>创建一个生成器，它必须为我们的任意密码返回一个<em class="jo">Jqwik</em>T1。我们的生成器必须生成没有大写字符的随机字符串<strong class="is hu">，如下所示</strong></p><figure class="ks kt ku kv fd hk"><div class="bz dy l di"><div class="kw kx l"/></div></figure><p id="c057" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">然而，这并不能确保生成的输入是我们期望的值。正如我之前提到的，<em class="jo"> Jqwik </em>的一个特殊特性是<em class="jo">为生成的输入收集统计数据</em>。这样做，我们可以确保生成的输入的正确性。我强烈建议总是将它们添加到您的<em class="jo">基于属性的测试</em>中。</p><p id="98a4" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">根据我们的“强密码”规则，在测试中观察数字以及小写和大写字符是有意义的。在Jqwik 中，相应的方法可能是这样的。</p><figure class="ks kt ku kv fd hk"><div class="bz dy l di"><div class="kw kx l"/></div></figure><blockquote class="le lf lg"><p id="a295" class="iq ir jo is b it iu iv iw ix iy iz ja lh jc jd je li jg jh ji lj jk jl jm jn hb bi translated"><em class="ht">在这里</em> 查看所有统计收集器 <a class="ae lk" href="https://github.com/sergio-sastre/Multiplying_the_quality_of_unit_tests/blob/master/app/src/test/java/sergio/sastre/multiplying/quality/of/unittests/pbt/StatCollectors.kt" rel="noopener ugc nofollow" target="_blank"> <em class="ht">的完整实现</em></a></p></blockquote><p id="7cf3" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">通过在生成的输入上添加统计数据，您会对测试正确的东西更有信心。这些报告将包含这些统计数据，稍后您将会看到。</p><p id="2acb" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">一旦我们有了生成器和统计数据，我们的测试就会像这样</p><figure class="ks kt ku kv fd hk"><div class="bz dy l di"><div class="kw kx l"/></div></figure><blockquote class="le lf lg"><p id="f02b" class="iq ir jo is b it iu iv iw ix iy iz ja lh jc jd je li jg jh ji lj jk jl jm jn hb bi translated"><em class="ht">您可以在这里</em> 找到完整的测试套件，包括所有验证器的PBT示例以及随机值生成器 <a class="ae lk" href="https://github.com/sergio-sastre/Multiplying_the_quality_of_unit_tests/blob/master/app/src/test/java/sergio/sastre/multiplying/quality/of/unittests/pbt/PasswordUnitTests.kt" rel="noopener ugc nofollow" target="_blank"> <em class="ht"/></a></p></blockquote><p id="7056" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如果我们运行它，我们会得到类似下面的报告</p><figure class="ks kt ku kv fd hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es ll"><img src="../Images/8e5ba6dcb9fe976d4f30cb08c787f78d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*V-Zi3lik_394K0jO"/></div></div></figure><figure class="ks kt ku kv fd hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es lm"><img src="../Images/7a47e47d3eebac22ec911a6c484a482d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*XWs0YR2TZ0joXtLq"/></div></div></figure><p id="899a" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">太好了！测试不出所料地失败了，生成的值100%都没有大写字母。如你所见，<em class="jo"> Jqwik </em>生成器默认也会考虑边缘情况(更多关于<a class="ae lk" href="https://jqwik.net/docs/current/user-guide.html#generation-of-edge-cases" rel="noopener ugc nofollow" target="_blank">边缘情况，请点击</a>)。</p><h1 id="ac68" class="jp jq ht bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">为什么古怪的测试在PBT中不是一个问题</h1><p id="30c5" class="pw-post-body-paragraph iq ir ht is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hb bi translated">您可能会想…测试失败了，但是每次运行时都会随机生成值…因此，如果我再次运行测试，就会生成新的值，并且可能会发生这样的情况:对于这些新的随机值，测试不会失败。不可重复的测试会降低测试套件的可靠性，需要避免。</p><p id="10c5" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">但是不要担心。首先，<em class="jo"> Jqwik </em> <strong class="is hu">重用同一个种子生成随机值，直到默认一个绿灯运行</strong>。其次，如果您需要在任何时候使用相同的值<strong class="is hu">重复测试</strong>，只需将之前报告中显示的种子添加到测试的最底部即可</p><figure class="ks kt ku kv fd hk"><div class="bz dy l di"><div class="kw kx l"/></div></figure><p id="ba4c" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在，您可以使用导致测试失败的相同值连续运行测试。</p><p id="39d9" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">一旦固定，不要忘记移除种子。这样，生成器将在每次运行时继续生成新的随机值。这样做，您可能会发现实现不正确的其他值。</p><p id="7f4a" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">恭喜你，你的测试已经变得对回归错误更加健壮了。你已经准备好去抓他们了！</p><h1 id="0300" class="jp jq ht bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">结论</h1><p id="b20a" class="pw-post-body-paragraph iq ir ht is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hb bi translated">让我们来看看<em class="jo">基于财产的测试</em>的利弊。</p><h1 id="bad1" class="jp jq ht bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">赞成的意见</h1><ol class=""><li id="b8a1" class="ln lo ht is b it kn ix ko jb lp jf lq jj lr jn ls lt lu lv bi translated">测试变得更加健壮，让你对你的代码更有信心。</li><li id="a3db" class="ln lo ht is b it lw ix lx jb ly jf lz jj ma jn ls lt lu lv bi translated">测试是决定性的。可以重用导致它们失败的种子，这样错误就可以重现。</li><li id="48f1" class="ln lo ht is b it lw ix lx jb ly jf lz jj ma jn ls lt lu lv bi translated">默认情况下探索边缘案例，否则我们可能会忘记。</li></ol><h1 id="161c" class="jp jq ht bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">骗局</h1><ol class=""><li id="c9f1" class="ln lo ht is b it kn ix ko jb lp jf lq jj lr jn ls lt lu lv bi translated">有些属性很难找到，尤其是在PBT中启动时。你可以看看Scott Wlaschin关于<a class="ae lk" href="https://fsharpforfunandprofit.com/posts/property-based-testing-2/" rel="noopener ugc nofollow" target="_blank">如何找到房产</a>的有趣帖子。</li><li id="7c8b" class="ln lo ht is b it lw ix lx jb ly jf lz jj ma jn ls lt lu lv bi translated"><em class="jo">基于属性的测试</em>运行得更慢，因为它们默认执行1000次。但是，如果需要，大多数引擎允许您更改该值。</li><li id="82a1" class="ln lo ht is b it lw ix lx jb ly jf lz jj ma jn ls lt lu lv bi translated">属性并不总是足以测试正确性。看看下面<code class="du ky kz la lb b">String?.reversed()</code>的错误实现及其测试</li></ol><figure class="ks kt ku kv fd hk"><div class="bz dy l di"><div class="kw kx l"/></div></figure><p id="8bc4" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">测试会通过，给我们一个错误的印象，即方法功能是正确的。另一方面，这是那种<em class="jo">基于实例的测试</em>可以快速发现的错误。</p><p id="9485" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">因此，在大多数情况下，将基于<em class="jo">的示例</em>和基于<em class="jo">的属性的测试</em>结合在一起，可以获得最好的结果。</p><p id="f8cc" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">本文中使用的所有代码示例，以及本系列第一篇文章中的代码示例(使用参数化测试的<a class="ae lk" href="https://sergiosastre.hashnode.dev/better-unit-tests-with-parameterized-testing" rel="noopener ugc nofollow" target="_blank">更好的单元测试</a>)都可以在<a class="ae lk" href="https://github.com/sergio-sastre/Multiplying_the_quality_of_unit_tests" rel="noopener ugc nofollow" target="_blank">本报告</a>中找到。</p><p id="22b9" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">你喜欢这个帖子吗？你可能也想看看我写的其他文章</p><ol class=""><li id="7ac2" class="ln lo ht is b it iu ix iy jb mb jf mc jj md jn ls lt lu lv bi translated"><a class="ae lk" href="https://sergiosastre.hashnode.dev/better-unit-tests-with-parameterized-testing" rel="noopener ugc nofollow" target="_blank">通过参数化测试实现更好的单元测试</a></li><li id="35c9" class="ln lo ht is b it lw ix lx jb ly jf lz jj ma jn ls lt lu lv bi translated"><a class="ae lk" href="https://sergio-sastre.medium.com/an-introduction-to-snapshot-testing-on-android-in-2021-c9826e22deb1" rel="noopener">2021年安卓快照测试介绍</a></li><li id="466b" class="ln lo ht is b it lw ix lx jb ly jf lz jj ma jn ls lt lu lv bi translated"><a class="ae lk" rel="noopener" href="/nerd-for-tech/styling-dynamic-strings-directly-in-xml-7b93cfe380ab">直接在Android xml中设计动态字符串</a></li></ol></div><div class="ab cl me mf gp mg" role="separator"><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj"/></div><div class="hb hc hd he hf"><p id="2afb" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><em class="jo">原载于</em><a class="ae lk" href="https://sergiosastre.hashnode.dev/writing-bulletproof-code-with-property-based-testing-pbt" rel="noopener ugc nofollow" target="_blank"><em class="jo">https://sergiosastre . hash node . dev</em></a><em class="jo">。</em></p></div></div>    
</body>
</html>