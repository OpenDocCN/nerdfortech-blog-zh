<html>
<head>
<title>Introduction to Swift Collections</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Swift托收简介</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/introduction-to-swift-collections-81a8a8b526d0?source=collection_archive---------8-----------------------#2021-04-20">https://medium.com/nerd-for-tech/introduction-to-swift-collections-81a8a8b526d0?source=collection_archive---------8-----------------------#2021-04-20</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/aa85d372084eac05f1833fee59a357a2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cU3A_YJZCISd5VE_RjTweQ.jpeg"/></div></div></figure><p id="d99c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">集合类型是对相关项目进行分组的一种方式。Swift目前为存储价值集合提供三种基本但重要的数据结构:</p><p id="7f1c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">数组</strong>——有序的值集合。<br/> <strong class="is hj">设置</strong> -唯一值的无序集合。<br/> <strong class="is hj">字典</strong> -键值关联的无序集合。</p><p id="7f9d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">它们满足了我们的大部分用例，但是您是否遇到过我们可能需要更多功能的需求。当我们想要混合和匹配这些数据结构时，就像我们想要一个有序的集合一样，我们总是很难。<br/>我们所有人都必须创建自定义函数来满足我们的需求。</p><figure class="jp jq jr js fd ij er es paragraph-image"><div class="er es jo"><img src="../Images/fe8996f1c31de695c721b8d50c464c67.png" data-original-src="https://miro.medium.com/v2/resize:fit:858/format:webp/1*axLwzHlATOgCshhCkGpSuQ.jpeg"/></div></figure><p id="1483" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">不再有自定义实现。我们现在可以用更少的努力写出更快的代码。</p><p id="f14e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">一个新的开源包专注于扩展可用的数据结构集，从而帮助我们在Swift标准库提供的功能之外开发更多功能。<br/>在收集包的初始版本中，提供了三种最常被请求的数据结构。</p><h2 id="fe74" class="jt ju hi bd jv jw jx jy jz ka kb kc kd jb ke kf kg jf kh ki kj jj kk kl km kn bi translated">双端队列</h2><p id="e6ee" class="pw-post-body-paragraph iq ir hi is b it ko iv iw ix kp iz ja jb kq jd je jf kr jh ji jj ks jl jm jn hb bi translated">Deque(读作“deck”)或双端队列在某种意义上像数组一样工作，它是<em class="kt">有序的、可变的，并且可以被随机访问</em>。关键区别在于<em class="kt"> Deque </em>支持两端插入和删除。</p><p id="ab8f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><em class="kt">队列</em>的一些关键特征是:</p><ul class=""><li id="1869" class="ku kv hi is b it iu ix iy jb kw jf kx jj ky jn kz la lb lc bi translated">有<code class="du ld le lf lg b">popFirst</code>和<code class="du ld le lf lg b">prepend</code>等操作可以插入和移除前面的元件。<code class="du ld le lf lg b">popFirst</code>返回移除的元素，如果是空数组则返回nil。</li><li id="0d47" class="ku kv hi is b it lh ix li jb lj jf lk jj ll jn kz la lb lc bi translated">前置一个元素对于<em class="kt">队列</em>是一个常数时间操作，但是对于<em class="kt">数组</em>是一个线性时间操作。</li><li id="c469" class="ku kv hi is b it lh ix li jb lj jf lk jj ll jn kz la lb lc bi translated">就像数组一样，非空<em class="kt">dequee</em>的第一个元素的索引始终为零。</li><li id="14d6" class="ku kv hi is b it lh ix li jb lj jf lk jj ll jn kz la lb lc bi translated">写入时拷贝优化也适用于<em class="kt">队列</em>，即每个拷贝共享相同的底层存储，除非其中一个拷贝被修改。</li><li id="b8d1" class="ku kv hi is b it lh ix li jb lj jf lk jj ll jn kz la lb lc bi translated">在<em class="kt">数组</em>的前面插入新数据相对较慢，因为需要移动现有元素来腾出空间。相比之下，<em class="kt"> Deque </em>使用一个循环缓冲区来存储它的元素，这允许在集合的两端进行有效的插入和移除。</li><li id="8880" class="ku kv hi is b it lh ix li jb lj jf lk jj ll jn kz la lb lc bi translated">我们还可以使用一些<em class="kt"> MutableCollection </em>和<em class="kt">RangeReplaceableCollection</em>方法来访问和变更集合的元素。</li></ul><p id="b807" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">为了更好地理解，让我们看一个例子:</p><figure class="jp jq jr js fd ij"><div class="bz dy l di"><div class="lm ln l"/></div></figure><p id="1c62" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">就像数组一样，访问任意偏移量的元素对于Deque来说是一个常量时间操作。</p><p id="59cd" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">尽管一个<em class="kt">队列</em>的接口与一个<em class="kt">数组</em>的接口非常相似，但是操作具有不同的性能特征。在<em class="kt"> Deques </em>中，靠近前端的突变预计会明显更快，但是<em class="kt">数组</em>对于一般的随机访问查找来说可能会稍微快一些。所以建议不要盲目的用<em class="kt"> Deques </em>替换所有数组，除非需要。</p><h2 id="f67e" class="jt ju hi bd jv jw jx jy jz ka kb kc kd jb ke kf kg jf kh ki kj jj kk kl km kn bi translated">有序集合</h2><p id="0847" class="pw-post-body-paragraph iq ir hi is b it ko iv iw ix kp iz ja jb kq jd je jf kr jh ji jj ks jl jm jn hb bi translated">数组和集合的强大混合体。唯一的要求是元素类型应该符合<em class="kt">散列</em>协议。</p><blockquote class="lo lp lq"><p id="83de" class="iq ir kt is b it iu iv iw ix iy iz ja lr jc jd je ls jg jh ji lt jk jl jm jn hb bi translated">追加元素(包括确保它的惟一性)是OrderedSet的一个常量时间操作。</p></blockquote><p id="ba56" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><em class="kt">订购套件</em>的一些主要特点是:</p><ul class=""><li id="dc73" class="ku kv hi is b it iu ix iy jb kw jf kx jj ky jn kz la lb lc bi translated">它确保有序列表中的每个元素只出现一次。</li><li id="c5d9" class="ku kv hi is b it lh ix li jb lj jf lk jj ll jn kz la lb lc bi translated">OrderedSet以用户指定的顺序维护其元素，并支持高效的成员随机访问遍历。</li><li id="7717" class="ku kv hi is b it lh ix li jb lj jf lk jj ll jn kz la lb lc bi translated">使用<code class="du ld le lf lg b">elements</code>属性可以将<em class="kt">有序集合</em>的成员提取为<em class="kt">数组</em>。这是以最小的开销完成的，因为它使用标准数组值来存储元素。</li><li id="49fe" class="ku kv hi is b it lh ix li jb lj jf lk jj ll jn kz la lb lc bi translated"><em class="kt">有序集合</em>提供了一个有效的<em class="kt">无序视图</em>，它的元素符合<code class="du ld le lf lg b">SetAlgebra</code>。</li><li id="95f3" class="ku kv hi is b it lh ix li jb lj jf lk jj ll jn kz la lb lc bi translated"><em class="kt"> OrderedSet </em>通过维护一个成员数组和该数组中的一个索引哈希表来实现。与普通的旧集合相比，有序集合通常会使用更少的内存，因为存储在哈希表中的索引通常可以比标准Int编码更少的位。</li><li id="31bc" class="ku kv hi is b it lh ix li jb lj jf lk jj ll jn kz la lb lc bi translated">如果两个有序集以相同的顺序包含相同的元素，则认为它们相等。</li></ul><figure class="jp jq jr js fd ij"><div class="bz dy l di"><div class="lm ln l"/></div></figure><ul class=""><li id="4568" class="ku kv hi is b it iu ix iy jb kw jf kx jj ky jn kz la lb lc bi translated"><em class="kt">有序集</em>实现了大部分<code class="du ld le lf lg b">SetAlgebra</code>需求，但不是全部。具体来说，它支持成员测试<code class="du ld le lf lg b">contains(_:)</code>以及所有高级集合操作，如<code class="du ld le lf lg b">union(_:)</code>、<code class="du ld le lf lg b">intersection(_:)</code>或<code class="du ld le lf lg b">isSubset(of:)</code>。返回有序集的操作通常会保留元素在其输入中的顺序。</li><li id="46dd" class="ku kv hi is b it lh ix li jb lj jf lk jj ll jn kz la lb lc bi translated">像<code class="du ld le lf lg b">isSubset(of:)</code>这样的谓词倾向于忽略元素排序。</li></ul><figure class="jp jq jr js fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lu"><img src="../Images/de4cc6ad7b33c261e1b5b1c8cc9a51e0.png" data-original-src="https://miro.medium.com/v2/resize:fit:442/format:webp/1*vhWzU1ao3VBDUNpR27lG_g.jpeg"/></div></div></figure><p id="511f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">让我们看看下面的例子，以便更好地理解:</p><figure class="jp jq jr js fd ij"><div class="bz dy l di"><div class="lm ln l"/></div></figure><h2 id="1fd8" class="jt ju hi bd jv jw jx jy jz ka kb kc kd jb ke kf kg jf kh ki kj jj kk kl km kn bi translated"><strong class="ak">有序字典</strong></h2><p id="dd43" class="pw-post-body-paragraph iq ir hi is b it ko iv iw ix kp iz ja jb kq jd je jf kr jh ji jj ks jl jm jn hb bi translated">它是键值对的有序集合。</p><p id="86cc" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><em class="kt">有序字典</em>的一些关键特性是:</p><ul class=""><li id="9209" class="ku kv hi is b it iu ix iy jb kw jf kx jj ky jn kz la lb lc bi translated">它使用哈希表来维护唯一性，并高效地查找这些特定键的对应值。</li><li id="7f95" class="ku kv hi is b it lh ix li jb lj jf lk jj ll jn kz la lb lc bi translated">像<em class="kt">数组</em>一样，OrderedDictionary维护用户指定的元素顺序，并支持对其条目的高效随机访问遍历。</li><li id="44d9" class="ku kv hi is b it lh ix li jb lj jf lk jj ll jn kz la lb lc bi translated"><em class="kt"> OrderedDictionary </em>的几乎所有操作都与普通的<em class="kt">字典</em>相同，比如我们可以使用基于键的下标高效地查找和添加值。</li><li id="cee9" class="ku kv hi is b it lh ix li jb lj jf lk jj ll jn kz la lb lc bi translated">它使用整数作为索引。就像数组一样，第一个元素的索引始终为零。</li><li id="ad94" class="ku kv hi is b it lh ix li jb lj jf lk jj ll jn kz la lb lc bi translated">任何使用下标setter的新条目都会将该元素附加到字典的末尾。所以默认情况下，元素的顺序就是它们被插入的顺序。</li><li id="a6ea" class="ku kv hi is b it lh ix li jb lj jf lk jj ll jn kz la lb lc bi translated">就像数组相等一样，如果两个OrderedDictionaries以相同的顺序包含相同的元素，则它们被视为相等。<em class="kt"> OrderedDictionary </em>只有当其值可等价时才符合可等价。</li></ul><figure class="jp jq jr js fd ij"><div class="bz dy l di"><div class="lm ln l"/></div></figure><ul class=""><li id="1cd6" class="ku kv hi is b it iu ix iy jb kw jf kx jj ky jn kz la lb lc bi translated">当元素的顺序很重要时，或者当您需要访问集合中不同位置的元素时，OrderedDictionary 是对<em class="kt">字典</em>的有用替代。</li></ul><figure class="jp jq jr js fd ij"><div class="bz dy l di"><div class="lm ln l"/></div></figure><p id="a360" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如上例所示，为了避免基于键的下标和基于索引的下标之间的歧义，<em class="kt"> OrderedDictionary </em>不直接符合集合。相反，它提供了对键值对的随机访问视图。就像标准字典一样，这个字典也提供轻量级的键和值视图。</p></div><div class="ab cl lv lw gp lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="hb hc hd he hf"><p id="1368" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">随着这些新数据结构的发布，包含新数据结构的门槛甚至更高了。然而，我们仍然希望在未来向该集合包添加更多条目，从而显著提高真实世界Swift代码的性能和正确性。</p><figure class="jp jq jr js fd ij er es paragraph-image"><div class="er es mc"><img src="../Images/b1ad7f71836a7db1ea89eb30343552a3.png" data-original-src="https://miro.medium.com/v2/resize:fit:410/format:webp/1*YcNsaMxLOll_-hJ58tEtUg.jpeg"/></div></figure><h1 id="07e6" class="md ju hi bd jv me mf mg jz mh mi mj kd mk ml mm kg mn mo mp kj mq mr ms km mt bi translated">参考</h1><div class="mu mv ez fb mw mx"><a href="https://swift.org/blog/swift-collections/" rel="noopener  ugc nofollow" target="_blank"><div class="my ab dw"><div class="mz ab na cl cj nb"><h2 class="bd hj fi z dy nc ea eb nd ed ef hh bi translated">推出Swift系列</h2><div class="ne l"><h3 class="bd b fi z dy nc ea eb nd ed ef dx translated">我很高兴地宣布Swift Collections，这是一个新的开源包，致力于扩展可用的Swift…</h3></div><div class="nf l"><p class="bd b fp z dy nc ea eb nd ed ef dx translated">swift.org</p></div></div></div></a></div><div class="mu mv ez fb mw mx"><a href="https://github.com/apple/swift-collections" rel="noopener  ugc nofollow" target="_blank"><div class="my ab dw"><div class="mz ab na cl cj nb"><h2 class="bd hj fi z dy nc ea eb nd ed ef hh bi translated">苹果/swift-系列</h2><div class="ne l"><h3 class="bd b fi z dy nc ea eb nd ed ef dx translated">Swift Collections是一个针对Swift编程语言的数据结构实现的开源包。阅读…</h3></div><div class="nf l"><p class="bd b fp z dy nc ea eb nd ed ef dx translated">github.com</p></div></div></div></a></div></div></div>    
</body>
</html>