<html>
<head>
<title>An opinionated Kotlin backend service - API Routing &amp; Documentation</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">固执己见的Kotlin后端服务——API路由和文档</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/an-opinionated-kotlin-backend-service-part-3-1e4b02aa6245?source=collection_archive---------3-----------------------#2021-04-30">https://medium.com/nerd-for-tech/an-opinionated-kotlin-backend-service-part-3-1e4b02aa6245?source=collection_archive---------3-----------------------#2021-04-30</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/8e460e0fe1ca0074587f9740494d397d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*YBST1qCD2cmdNuR_.jpg"/></div></div></figure><p id="e88e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这是我的基于Kotlin的后端服务系列的第三部分。<br/>如果你错过了前两部分:</p><ul class=""><li id="b308" class="jo jp hi is b it iu ix iy jb jq jf jr jj js jn jt ju jv jw bi translated"><a class="ae jx" rel="noopener" href="/p/87f814e3dffd">固执己见的科特林后端服务框架</a></li><li id="17c7" class="jo jp hi is b it jy ix jz jb ka jf kb jj kc jn jt ju jv jw bi translated"><a class="ae jx" rel="noopener" href="/p/480ab5e6cdb2">固执己见的Kotlin后端服务——构建&amp;部署</a></li></ul><h1 id="780c" class="kd ke hi bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">API路由和文档</h1><h2 id="895b" class="lb ke hi bd kf lc ld le kj lf lg lh kn jb li lj kr jf lk ll kv jj lm ln kz lo bi translated">Ktor路由</h2><p id="6173" class="pw-post-body-paragraph iq ir hi is b it lp iv iw ix lq iz ja jb lr jd je jf ls jh ji jj lt jl jm jn hb bi translated">由于有了<a class="ae jx" href="https://en.wikipedia.org/wiki/Domain-specific_language" rel="noopener ugc nofollow" target="_blank"> DSL </a>，在Ktor 中定义<a class="ae jx" href="https://ktor.io/docs/routing-in-ktor.html" rel="noopener ugc nofollow" target="_blank">路线变得简单且非常简洁。要定义路线，调用<code class="du lu lv lw lx b">routing</code>功能并添加您需要的路线:</a></p><pre class="ly lz ma mb fd mc lx md me aw mf bi"><span id="ce3d" class="lb ke hi lx b fi mg mh l mi mj">routing {<br/>    // here go your routes<br/>}</span></pre><p id="8259" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">使用不同的http方法:</p><pre class="ly lz ma mb fd mc lx md me aw mf bi"><span id="6c48" class="lb ke hi lx b fi mg mh l mi mj">routing {     <br/>    get("/customer/{id}") { /* handler */ }     <br/>    post("/customer") { /* handler */ }     <br/>    put("/customer/{id}") { /* handler */ } <br/>}</span></pre><p id="2d01" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">按路径分组:</p><pre class="ly lz ma mb fd mc lx md me aw mf bi"><span id="7803" class="lb ke hi lx b fi mg mh l mi mj">routing {<br/>    route("/customer") {<br/>        get("/{id}") { /* handler */ }<br/>        post("/") { /* handler */ }<br/>    }<br/>    route("/account") {<br/>        get("/{id}") { /* handler */ }<br/>    }<br/>}</span></pre><p id="8857" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">分层:</p><pre class="ly lz ma mb fd mc lx md me aw mf bi"><span id="a6c1" class="lb ke hi lx b fi mg mh l mi mj">routing <strong class="lx hj">{<br/>    </strong>route("/customer") <strong class="lx hj">{<br/>        </strong>route("/order") <strong class="lx hj">{<br/>            </strong>get("/{id}") <strong class="lx hj">{ </strong>/* handler */ <strong class="lx hj">}<br/>            </strong>delete("/{id}") <strong class="lx hj">{ </strong>/* handler */ <strong class="lx hj">}<br/>        }<br/>    }<br/>}</strong></span></pre><p id="e3c6" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">模块化(使用扩展功能):</p><pre class="ly lz ma mb fd mc lx md me aw mf bi"><span id="a9fc" class="lb ke hi lx b fi mg mh l mi mj">routing <strong class="lx hj">{<br/>    </strong><em class="mk">customerByIdRoute</em>()<br/>    <em class="mk">createCustomerRoute</em>()<br/>    <em class="mk">orderByIdRoute</em>()<br/><strong class="lx hj">}</strong></span><span id="c9de" class="lb ke hi lx b fi ml mh l mi mj">fun Route.customerByIdRoute() {<br/>    get("/customer/{id}") <strong class="lx hj">{ </strong>/* handler */ <strong class="lx hj">}<br/></strong>}<br/><br/>fun Route.createCustomerRoute() {<br/>    post("/customer") <strong class="lx hj">{  </strong>/* handler */ <strong class="lx hj">}<br/></strong>}<br/><br/>fun Route.orderByIdRoute() {<br/>    get("/order/{id}") <strong class="lx hj">{ </strong>/* handler */ <strong class="lx hj">}<br/></strong>}</span></pre><p id="2b21" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我不想更深入地阐述标准Ktor路由，因为我实际上并没有使用它。如果您有兴趣了解更多关于常规Ktor路线的信息，请阅读众多文章中的一篇，例如<a class="ae jx" rel="noopener" href="/playkids-tech-blog/building-simple-webservices-in-kotlin-using-ktor-59501f004070">此处</a>、<a class="ae jx" rel="noopener" href="/dev-genius/create-simple-post-request-with-ktor-591deab01861">此处</a>或<a class="ae jx" rel="noopener" href="/@billwixted/building-a-rest-api-with-ktor-4c322d31eb31">此处</a>。</p><h2 id="a481" class="lb ke hi bd kf lc ld le kj lf lg lh kn jb li lj kr jf lk ll kv jj lm ln kz lo bi translated">OpenAPI生成</h2><p id="3380" class="pw-post-body-paragraph iq ir hi is b it lp iv iw ix lq iz ja jb lr jd je jf ls jh ji jj lt jl jm jn hb bi translated">我不使用普通Ktor路由函数的原因在本文中有所解释:<a class="ae jx" rel="noopener" href="/p/d57879ec5ab0">用Ktor生成OpenAPI】。</a></p><p id="7bd2" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">要点是，我想要一个OpenAPI文档，我决定编写代码并使用生成器来自动创建文档(而不是编写文档并自动生成代码)。我写的代码是这样的:</p><figure class="ly lz ma mb fd ij"><div class="bz dy l di"><div class="mm mn l"/></div></figure><p id="99e0" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">类似上面的定义用于:</p><ol class=""><li id="88eb" class="jo jp hi is b it iu ix iy jb jq jf jr jj js jn mo ju jv jw bi translated">定义应用程序路线</li><li id="9c86" class="jo jp hi is b it jy ix jz jb ka jf kb jj kc jn mo ju jv jw bi translated">并生成OpenAPI文档:</li></ol><figure class="ly lz ma mb fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mp"><img src="../Images/d6cc7d7b4d7110976be94d41fd5c9d9f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*e1tiHsbRkxHX9310vxxjTQ.png"/></div></div></figure><figure class="ly lz ma mb fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mq"><img src="../Images/5e8ef433beb9b50099254653701c9408.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*t3UtuGrRLcarMBRRaaE5dw.png"/></div></div></figure><h2 id="fd00" class="lb ke hi bd kf lc ld le kj lf lg lh kn jb li lj kr jf lk ll kv jj lm ln kz lo bi translated">路线定义</h2><p id="cc4a" class="pw-post-body-paragraph iq ir hi is b it lp iv iw ix lq iz ja jb lr jd je jf ls jh ji jj lt jl jm jn hb bi translated">让我们一步一步来看定义。</p><pre class="ly lz ma mb fd mc lx md me aw mf bi"><span id="9b78" class="lb ke hi lx b fi mg mh l mi mj">tag(Tags.<em class="mk">Account</em>) <strong class="lx hj">{<br/>    </strong>route("/api/v1/admin/accounts") <strong class="lx hj">{</strong></span></pre><ul class=""><li id="4aaf" class="jo jp hi is b it iu ix iy jb jq jf jr jj js jn jt ju jv jw bi translated"><strong class="is hj">标签功能</strong>用于将路线分组在一起(在这种情况下，分组为<em class="mk">杂项</em>、<em class="mk">客户</em>和<em class="mk">账户</em>)。</li><li id="0c9d" class="jo jp hi is b it jy ix jz jb ka jf kb jj kc jn jt ju jv jw bi translated"><strong class="is hj">路线功能</strong>用于定义与特定路径匹配的路线。</li></ul><p id="0836" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">您还可以创建路线的层次结构:</p><pre class="ly lz ma mb fd mc lx md me aw mf bi"><span id="a02d" class="lb ke hi lx b fi mg mh l mi mj">route("/api/v1") <strong class="lx hj">{<br/>    </strong>route("/misc") <strong class="lx hj">{ }<br/>    </strong>route("/accounts") <strong class="lx hj">{ }<br/>    </strong>route("/customers") <strong class="lx hj">{ }<br/>}</strong></span></pre><p id="8cf2" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">实际路线在路线功能中定义:</p><pre class="ly lz ma mb fd mc lx md me aw mf bi"><span id="2d76" class="lb ke hi lx b fi mg mh l mi mj"><em class="mk">/**<br/> * Create a new account.<br/> */<br/></em>post&lt;Unit, ResponseAccount, RequestAccount&gt;(<br/>    <em class="mk">info</em>(<br/>        summary = "Create an account.",<br/>        description = "Create a new account"<br/>    ),<br/>    <em class="mk">status</em>(HttpStatusCode.OK),<br/>    exceptions = <em class="mk">listOf</em>(<em class="mk">badRequest</em>),<br/>    exampleRequest = <em class="mk">accountExampleRequest</em>,<br/>    exampleResponse = <em class="mk">accountExampleResponse<br/></em>) <strong class="lx hj">{ </strong>_, account <strong class="lx hj">-&gt;<br/>    </strong>val newAccount = controller.createAccount(account)<br/>    respond(newAccount)<br/><strong class="lx hj">}</strong></span></pre><p id="e1ab" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">两个或三个通用类型(两个用于get: <code class="du lu lv lw lx b">get&lt;AccountUUIDParam, ResponseAccount&gt;</code>三个用于post: <code class="du lu lv lw lx b">post&lt;Unit, ResponseAccount, RequestAccount&gt;</code>)定义了</p><ol class=""><li id="bb43" class="jo jp hi is b it iu ix iy jb jq jf jr jj js jn mo ju jv jw bi translated">路径参数(如path/<strong class="is hj"><em class="mk">【account uuid】</em></strong>)</li><li id="2990" class="jo jp hi is b it jy ix jz jb ka jf kb jj kc jn mo ju jv jw bi translated">反应</li><li id="0cf8" class="jo jp hi is b it jy ix jz jb ka jf kb jj kc jn mo ju jv jw bi translated">请求正文(发布、上传)</li></ol><p id="fceb" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这些类型的定义如下所示(路径参数):</p><pre class="ly lz ma mb fd mc lx md me aw mf bi"><span id="91e2" class="lb ke hi lx b fi mg mh l mi mj">@Path("{accountUUID}")<br/>data class AccountUUIDParam(<br/>    @PathParam("UUID of the account.")<br/>    val accountUUID: String<br/>)</span></pre><p id="00d1" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">或者(回应):</p><pre class="ly lz ma mb fd mc lx md me aw mf bi"><span id="5a98" class="lb ke hi lx b fi mg mh l mi mj">@Response("Account Response.")<br/>data class Account(<br/>    val accountUUID: String,<br/>    val createdAt: Instant,<br/>    val modifiedAt: Instant,<br/>    val status: AccountStatus<br/>)</span></pre><p id="8444" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这些数据类别用于:</p><ul class=""><li id="6e15" class="jo jp hi is b it iu ix iy jb jq jf jr jj js jn jt ju jv jw bi translated">创建OpenAPI文档:</li></ul><figure class="ly lz ma mb fd ij er es paragraph-image"><div class="er es mr"><img src="../Images/9df94ab15a09c5e9626fd2172b74986c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1120/format:webp/1*b5fuCnZ7Z7qpHQXnDBd8TQ.png"/></div></figure><ul class=""><li id="5fe1" class="jo jp hi is b it iu ix iy jb jq jf jr jj js jn jt ju jv jw bi translated">定义请求/响应的序列化/反序列化的结果(与Json / data类的往来)</li><li id="57d1" class="jo jp hi is b it jy ix jz jb ka jf kb jj kc jn jt ju jv jw bi translated">定义对象验证规则。接下来，我将更详细地阐述对象验证。</li></ul><h2 id="08b2" class="lb ke hi bd kf lc ld le kj lf lg lh kn jb li lj kr jf lk ll kv jj lm ln kz lo bi translated">方法参数</h2><p id="a784" class="pw-post-body-paragraph iq ir hi is b it lp iv iw ix lq iz ja jb lr jd je jf ls jh ji jj lt jl jm jn hb bi translated"><code class="du lu lv lw lx b">get</code>、<code class="du lu lv lw lx b">post</code>、<code class="du lu lv lw lx b">put</code>、<code class="du lu lv lw lx b">patch</code>、<code class="du lu lv lw lx b">delete</code>和<code class="du lu lv lw lx b">head</code>函数的方法参数<em class="mk">几乎</em>专用<em class="mk">、</em>用于定义OpenAPI文档(异常参数也绑定到对象验证)。</p><pre class="ly lz ma mb fd mc lx md me aw mf bi"><span id="60bf" class="lb ke hi lx b fi mg mh l mi mj"><em class="mk">info</em>(<br/>    summary = "Create an account.",<br/>    description = "Create a new account"<br/>),<br/><em class="mk">status</em>(HttpStatusCode.OK),<br/>exceptions = <em class="mk">listOf</em>(<em class="mk">badRequest</em>),<br/>exampleRequest = <em class="mk">accountExampleRequest</em>,<br/>exampleResponse = <em class="mk">accountExampleResponse</em></span></pre><ul class=""><li id="4b14" class="jo jp hi is b it iu ix iy jb jq jf jr jj js jn jt ju jv jw bi translated"><code class="du lu lv lw lx b"><strong class="is hj">info</strong></code>和<code class="du lu lv lw lx b"><strong class="is hj">status</strong></code>参数的目的很明显(描述路线和响应状态代码)。都是<code class="du lu lv lw lx b">RouteOpenAPIModule </code> vararg参数，其中还有两个:<br/> 1) <code class="du lu lv lw lx b">resonseAnnotationStatusCode</code>:响应HTTP状态码来源于响应定义，例如:<br/> <code class="du lu lv lw lx b">@Response("Account Response.", <strong class="is hj">202</strong>)</code> - &gt;覆盖<code class="du lu lv lw lx b">status(HttpStatusCode.OK)</code>语句<br/> 2) <code class="du lu lv lw lx b">tags</code> <em class="mk"> : </em>设置该路由的标签，如果设置了多个标签，该路由将出现在所有类别/组中。</li><li id="248c" class="jo jp hi is b it jy ix jz jb ka jf kb jj kc jn jt ju jv jw bi translated"><code class="du lu lv lw lx b"><strong class="is hj">exceptions</strong></code>参数定义了可能的错误情况。</li></ul><p id="f5a0" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">例如<code class="du lu lv lw lx b">badRequest</code>定义:</p><figure class="ly lz ma mb fd ij"><div class="bz dy l di"><div class="mm mn l"/></div></figure><p id="a8cd" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">翻译过来就是:</p><figure class="ly lz ma mb fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ms"><img src="../Images/c6117706fe8a4bee49dbd3a3745bb233.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9vctaLUVcvCkeq8u7FIlxg.png"/></div></div></figure><p id="5f1b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">注意，用<code class="du lu lv lw lx b">contentFn</code>定义的运行时错误取决于从作为验证过程一部分抛出的<code class="du lu lv lw lx b">ConstraintViolation</code>中获取的异常消息(见下文“对象验证”一章)。</p><ul class=""><li id="335d" class="jo jp hi is b it iu ix iy jb jq jf jr jj js jn jt ju jv jw bi translated">最后但并非最不重要的是<code class="du lu lv lw lx b">exampleRequest</code>和<code class="du lu lv lw lx b">exampleResponse</code>参数，它们应该是自我解释的。</li></ul><h1 id="6cf6" class="kd ke hi bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">对象验证</h1><p id="5fcb" class="pw-post-body-paragraph iq ir hi is b it lp iv iw ix lq iz ja jb lr jd je jf ls jh ji jj lt jl jm jn hb bi translated">我写过一篇关于对象验证的专门文章:<a class="ae jx" rel="noopener" href="/p/c7e02b5dabc">Ktor/kot Lin</a>中的对象验证。在这篇文章中，我研究了几个验证库，比如<a class="ae jx" href="https://github.com/rcapraro/kalidation" rel="noopener ugc nofollow" target="_blank"> Kalidation </a>、<a class="ae jx" href="https://github.com/valiktor/valiktor" rel="noopener ugc nofollow" target="_blank"> Valiktor </a>或<a class="ae jx" href="https://github.com/konform-kt/konform" rel="noopener ugc nofollow" target="_blank"> Konform </a>。虽然我声明Konform是我的最爱，但实际上我并不使用它，因为<a class="ae jx" href="https://github.com/1gravity/Ktor-OpenAPI-Generator" rel="noopener ugc nofollow" target="_blank"> Ktor-OpenAPI-Generator </a>有一个内置的验证机制。虽然我并不特别喜欢基于注释的验证(我喜欢对包括配置和构建在内的所有事情使用单一语言，这里的单一语言是Kotlin)，但这种情况下的优势在于它有两个用途:</p><ol class=""><li id="9b60" class="jo jp hi is b it iu ix iy jb jq jf jr jj js jn mo ju jv jw bi translated">确认</li><li id="c0cd" class="jo jp hi is b it jy ix jz jb ka jf kb jj kc jn mo ju jv jw bi translated">证明文件</li></ol><p id="45e6" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">例如，这里的注释被<a class="ae jx" href="https://github.com/1gravity/Ktor-OpenAPI-Generator" rel="noopener ugc nofollow" target="_blank"> Ktor-OpenAPI-Generator </a>用来验证输入参数并创建文档:</p><figure class="ly lz ma mb fd ij"><div class="bz dy l di"><div class="mm mn l"/></div></figure><figure class="ly lz ma mb fd ij er es paragraph-image"><div class="er es mt"><img src="../Images/f4c9b1dcb7ad08b7a0a5eac45ff58f5f.png" data-original-src="https://miro.medium.com/v2/resize:fit:876/format:webp/1*rofHdTHd7yg4KXLvVcBvSw.png"/></div></figure><h2 id="2eb8" class="lb ke hi bd kf lc ld le kj lf lg lh kn jb li lj kr jf lk ll kv jj lm ln kz lo bi translated">错误处理</h2><p id="f95b" class="pw-post-body-paragraph iq ir hi is b it lp iv iw ix lq iz ja jb lr jd je jf ls jh ji jj lt jl jm jn hb bi translated">如果输入参数或请求主体验证失败，会发生什么？</p><p id="9f7b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><a class="ae jx" href="https://github.com/1gravity/Ktor-OpenAPI-Generator" rel="noopener ugc nofollow" target="_blank"> Ktor-OpenAPI-Generator </a>抛出一个<code class="du lu lv lw lx b">ConstraintViolation</code>，由上面发布的<code class="du lu lv lw lx b">badRequest</code>定义处理:</p><pre class="ly lz ma mb fd mc lx md me aw mf bi"><span id="9598" class="lb ke hi lx b fi mg mh l mi mj">val <em class="mk">badRequest </em>= apiException&lt;<strong class="lx hj">ConstraintViolation</strong>, ErrorMessage&gt; {<strong class="lx hj"><br/></strong>    // more code here<br/>}</span></pre><p id="4cc9" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这又在路线定义中使用(也张贴在上面),我们来了一个完整的循环:</p><pre class="ly lz ma mb fd mc lx md me aw mf bi"><span id="311d" class="lb ke hi lx b fi mg mh l mi mj">post&lt;Unit, ResponseAccount, RequestAccount&gt;(<br/>    ...<br/>    exceptions = <em class="mk">listOf</em>(<strong class="lx hj"><em class="mk">badRequest</em></strong>),   <br/>    ...<br/>) {<br/>    ...<br/>}</span></pre><p id="0ff3" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这就是本系列的第3部分。如果你喜欢这一点，那就继续跟进<a class="ae jx" rel="noopener" href="/p/52527ce3228">一个固执己见的Kotlin后端服务——数据库/迁移/ ORM </a>。</p><p id="64c9" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">像往常一样，请随时提供反馈。编码快乐！</p></div></div>    
</body>
</html>