<html>
<head>
<title>Event Driven Architecture</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">事件驱动架构</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/event-driven-architecture-b1b3700eff7c?source=collection_archive---------4-----------------------#2022-09-18">https://medium.com/nerd-for-tech/event-driven-architecture-b1b3700eff7c?source=collection_archive---------4-----------------------#2022-09-18</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="2b75" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">顺序代码流与事件驱动代码流</p><h1 id="99a1" class="jd je hi bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">顺序模式</h1><p id="671a" class="pw-post-body-paragraph if ig hi ih b ii kb ik il im kc io ip iq kd is it iu ke iw ix iy kf ja jb jc hb bi translated">在编写代码的顺序模式中，代码从一个点流向另一个点。不同的系统进程相继同步执行。</p><p id="1f9c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在下面的代码流示例中，显示了一个同步序列。一名员工加入了一家新公司，他的数据必须添加到不同的系统中。所有需要员工数据的系统都在一个接一个地更新数据，直到整个更新完成。</p><figure class="kh ki kj kk fd kl er es paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="er es kg"><img src="../Images/8dca437bb76adb0d00e893bdb59092b0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*r18RkjAmnt76ZhTNhLameA.png"/></div></div></figure><h2 id="4be9" class="ks je hi bd jf kt ku kv jj kw kx ky jn iq kz la jr iu lb lc jv iy ld le jz lf bi translated">赞成的意见</h2><ol class=""><li id="739e" class="lg lh hi ih b ii kb im kc iq li iu lj iy lk jc ll lm ln lo bi translated">当代码按顺序流动时，我们知道什么系统已经完成，什么系统还没有开始</li><li id="ad83" class="lg lh hi ih b ii lp im lq iq lr iu ls iy lt jc ll lm ln lo bi translated">易于控制</li></ol><h2 id="5991" class="ks je hi bd jf kt ku kv jj kw kx ky jn iq kz la jr iu lb lc jv iy ld le jz lf bi translated">骗局</h2><ol class=""><li id="2e6f" class="lg lh hi ih b ii kb im kc iq li iu lj iy lk jc ll lm ln lo bi translated">代码是耦合的，如果其中一个系统出现故障，代码流就会中断</li><li id="7945" class="lg lh hi ih b ii lp im lq iq lr iu ls iy lt jc ll lm ln lo bi translated">高耦合。</li></ol><h1 id="295e" class="jd je hi bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">事件驱动架构——主体和观察者模式</h1><p id="8615" class="pw-post-body-paragraph if ig hi ih b ii kb ik il im kc io ip iq kd is it iu ke iw ix iy kf ja jb jc hb bi translated">与序列模式相反，代码流被分成独立的块，这些块可以独立执行，不依赖于其他东西。当一个重要的事件发生时，一个事件被发出。它被通知给正在监听的其他系统。因为代码块是独立的，所以所有子系统并行地反应和完成这些步骤。</p><p id="355b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">主题和观察者模式是实现事件驱动架构的一种方式。Subject 发出一个带有事件名称和数据的事件。观察者倾听事件并做出相应的反应。</p><p id="25bf" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在下面的示例中，主题正在发出事件。一旦员工被添加到系统中，就会有多个观察者监听事件。他们会回应的。即使其中一个系统出现故障，另一个系统将继续工作。这种架构是有弹性的。</p><figure class="kh ki kj kk fd kl er es paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="er es lu"><img src="../Images/965f78d1edf3594ce57737988f01d09b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1UMO3HFyWCleLVSBqdmjNA.png"/></div></div><figcaption class="lv lw et er es lx ly bd b be z dx translated">发出带有“addEmployee”名称和详细数据的事件</figcaption></figure><figure class="kh ki kj kk fd kl er es paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="er es lu"><img src="../Images/20d22d52a842664b50e1416b3b6eb539.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*E07iQdzKTWWmrAiNtFURrg.png"/></div></div></figure><h2 id="8103" class="ks je hi bd jf kt ku kv jj kw kx ky jn iq kz la jr iu lb lc jv iy ld le jz lf bi translated">赞成的意见</h2><ol class=""><li id="00ce" class="lg lh hi ih b ii kb im kc iq li iu lj iy lk jc ll lm ln lo bi translated">解耦，一个系统不需要了解另一个系统</li><li id="f593" class="lg lh hi ih b ii lp im lq iq lr iu ls iy lt jc ll lm ln lo bi translated">我们可以很容易地用一个系统替换另一个系统，只要它与合同有约束力</li><li id="982a" class="lg lh hi ih b ii lp im lq iq lr iu ls iy lt jc ll lm ln lo bi translated">与语言无关，不同的系统可以用不同的语言实现。</li></ol><h2 id="4406" class="ks je hi bd jf kt ku kv jj kw kx ky jn iq kz la jr iu lb lc jv iy ld le jz lf bi translated">骗局</h2><p id="90cc" class="pw-post-body-paragraph if ig hi ih b ii kb ik il im kc io ip iq kd is it iu ke iw ix iy kf ja jb jc hb bi translated">2.受试者无法控制结果</p><h2 id="cc3b" class="ks je hi bd jf kt ku kv jj kw kx ky jn iq kz la jr iu lb lc jv iy ld le jz lf bi translated">例子</h2><p id="5ef2" class="pw-post-body-paragraph if ig hi ih b ii kb ik il im kc io ip iq kd is it iu ke iw ix iy kf ja jb jc hb bi translated">在下面的例子中，我们使用 nano <a class="ae lz" href="https://github.com/ai/nanoevents" rel="noopener ugc nofollow" target="_blank">事件发射器。</a>事件发射器用于发射添加员工事件。</p><figure class="kh ki kj kk fd kl"><div class="bz dy l di"><div class="ma mb l"/></div></figure><figure class="kh ki kj kk fd kl er es paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="er es mc"><img src="../Images/5e27900e8d5ea3c62c4cb121f7e745e1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kA-BHxkkGZaGMkI9YYLc1A.png"/></div></div><figcaption class="lv lw et er es lx ly bd b be z dx translated">发出添加员工</figcaption></figure><p id="8b7d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">雇员文件监听该事件以添加雇员，并且支付系统也被更新。</p><figure class="kh ki kj kk fd kl er es paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="er es md"><img src="../Images/e2e3904ce02bdf3835997a301ef1a93d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AscM5Zh0Zu4PCVYUQjZaDw.png"/></div></div></figure></div></div>    
</body>
</html>