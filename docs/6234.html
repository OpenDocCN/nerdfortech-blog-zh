<html>
<head>
<title>LeetCode — Find Peak Element</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">LeetCode —查找峰值元素</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/leetcode-find-peak-element-c5c867ae0d9c?source=collection_archive---------3-----------------------#2022-01-20">https://medium.com/nerd-for-tech/leetcode-find-peak-element-c5c867ae0d9c?source=collection_archive---------3-----------------------#2022-01-20</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><h1 id="4ce0" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">问题陈述</h1><p id="f812" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">峰元素是严格大于其相邻元素的元素。</p><p id="7316" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">给定一个整数数组<em class="kg"> nums </em>，找到一个 peak 元素，并返回其索引。如果数组包含多个峰值，将索引返回给<strong class="jf hj">任何峰值</strong>。</p><p id="ce60" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">你可能会想象<em class="kg"> nums[-1] = nums[n] = -∞ </em>。</p><p id="79df" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">你必须写一个在<em class="kg"> O(log n) </em>时间内运行的算法。</p><p id="5a69" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">问题陈述摘自:<a class="ae kh" href="https://leetcode.com/problems/find-peak-element" rel="noopener ugc nofollow" target="_blank">https://leetcode.com/problems/find-peak-element</a></p><p id="bd8b" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated"><strong class="jf hj">例 1: </strong></p><pre class="ki kj kk kl fd km kn ko kp aw kq bi"><span id="c21b" class="kr ig hi kn b fi ks kt l ku kv">Input: nums = [1, 2, 3, 1]<br/>Output: 2<br/>Explanation: 3 is a peak element, and your function should return the index number 2.</span></pre><p id="57c6" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated"><strong class="jf hj">例 2: </strong></p><pre class="ki kj kk kl fd km kn ko kp aw kq bi"><span id="3db0" class="kr ig hi kn b fi ks kt l ku kv">Input: nums = [1, 2, 1, 3, 5, 6, 4]<br/>Output: 5<br/>Explanation: Your function can return either index number 1 where the peak element is 2, or index number 5 where the peak element is 6.</span></pre><p id="3cb0" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated"><strong class="jf hj">约束:</strong></p><pre class="ki kj kk kl fd km kn ko kp aw kq bi"><span id="d113" class="kr ig hi kn b fi ks kt l ku kv">- 1 &lt;= nums.length &lt;= 1000<br/>- -2^31 &lt;= nums[i] &lt;= 2^31 - 1<br/>- nums[i] != nums[i + 1] for all valid i</span></pre><h1 id="e916" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">说明</h1><h2 id="d083" class="kr ig hi bd ih kw kx ky il kz la lb ip jo lc ld it js le lf ix jw lg lh jb li bi translated">强力方法</h2><p id="035c" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">一种简单的方法是扫描数组元素并检查它们的邻居是否严格地更小。对于数组的第一个和最后一个元素，我们分别验证第一个索引和倒数第二个索引。对于其余的元素，我们验证邻居。</p><p id="195d" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">由于我们正在扫描数组的所有元素，代码的时间复杂度将是<strong class="jf hj"> O(N) </strong>。</p><p id="6860" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">上述方法的 C++代码片段如下所示:</p><pre class="ki kj kk kl fd km kn ko kp aw kq bi"><span id="4797" class="kr ig hi kn b fi ks kt l ku kv">int findPeak(int array[]){<br/>    int n = array.size();<br/><br/>    if (n == 1)<br/>      return 0;<br/>    if (arr[0] &gt;= arr[1])<br/>        return 0;<br/>    if (arr[n - 1] &gt;= arr[n - 2])<br/>        return n - 1;<br/><br/>    for (int i = 1; i &lt; n - 1; i++) {<br/>        if (arr[i] &gt;= arr[i - 1] &amp;&amp; arr[i] &gt;= arr[i + 1])<br/>            return i;<br/>    }<br/>}</span></pre><h2 id="154f" class="kr ig hi bd ih kw kx ky il kz la lb ip jo lc ld it js le lf ix jw lg lh jb li bi translated">二分搜索法方法</h2><p id="ff5d" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">我们可以使用二分搜索法将上述程序的时间复杂度降低到<strong class="jf hj"> O(log(N)) </strong>。</p><p id="b7de" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">在二分搜索法的例子中，我们在一个排序的数组上工作，并试图通过在每次迭代中将数组大小减半来找到目标元素。我们可以修改这个问题的二分搜索法方法来寻找所需的元素。如果中间的元素不是峰值，我们检查右侧的元素是否大于中间的元素。如果是，右边总有一个峰元素。类似地，如果左侧元素更大，峰值将在左侧。</p><p id="93c9" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">让我们先检查一下算法，以理解修正的二分搜索法方法。</p><pre class="ki kj kk kl fd km kn ko kp aw kq bi"><span id="227e" class="kr ig hi kn b fi ks kt l ku kv">- set low = 0, high = nums.size() - 1<br/>  initialize mid<br/><br/>- loop while low &lt; high<br/>  - set mid = low + (high - low / 2)<br/><br/>  - if nums[mid] &gt; nums[mid + 1]<br/>    - set high = mid<br/>  - else if nums[mid] &lt;= nums[mid + 1]<br/>    - set low = mid + 1<br/><br/>- return low</span></pre><h2 id="54ad" class="kr ig hi bd ih kw kx ky il kz la lb ip jo lc ld it js le lf ix jw lg lh jb li bi translated">C++解决方案</h2><pre class="ki kj kk kl fd km kn ko kp aw kq bi"><span id="d4b2" class="kr ig hi kn b fi ks kt l ku kv">class Solution {<br/>public:<br/>    int findPeakElement(vector&lt;int&gt;&amp; nums) {<br/>        int low = 0, high = nums.size() - 1;<br/>        int mid;<br/><br/>        while(low &lt; high) {<br/>            mid = low + (high - low)/2;<br/>            if(nums[mid] &gt; nums[mid + 1]){<br/>                high = mid;<br/>            } else if(nums[mid] &lt;= nums[mid + 1]){<br/>                low = mid + 1;<br/>            }<br/>        }<br/><br/>        return low;<br/>    }<br/>};</span></pre><h2 id="325a" class="kr ig hi bd ih kw kx ky il kz la lb ip jo lc ld it js le lf ix jw lg lh jb li bi translated">戈朗溶液</h2><pre class="ki kj kk kl fd km kn ko kp aw kq bi"><span id="8725" class="kr ig hi kn b fi ks kt l ku kv">func findPeakElement(nums []int) int {<br/>    low, high := 0, len(nums) - 1<br/>    var mid int<br/><br/>    for low &lt; high {<br/>        mid = low + (high - low)/2<br/><br/>        if nums[mid] &gt; nums[mid + 1] {<br/>            high = mid<br/>        } else if nums[mid] &lt;= nums[mid + 1] {<br/>            low = mid + 1<br/>        }<br/>    }<br/><br/>    return low<br/>}</span></pre><h2 id="d07e" class="kr ig hi bd ih kw kx ky il kz la lb ip jo lc ld it js le lf ix jw lg lh jb li bi translated">Javascript 解决方案</h2><pre class="ki kj kk kl fd km kn ko kp aw kq bi"><span id="4f8d" class="kr ig hi kn b fi ks kt l ku kv">var findPeakElement = function(nums) {<br/>    let low = 0, high = nums.length - 1;<br/>    let mid;<br/><br/>    while(low &lt; high) {<br/>        mid = low + Math.floor((high - low) / 2);<br/><br/>        if(nums[mid] &gt; nums[mid + 1]){<br/>            high = mid;<br/>        } else if(nums[mid] &lt;= nums[mid + 1]){<br/>            low = mid + 1;<br/>        }<br/>    }<br/><br/>    return low;<br/>};</span></pre><p id="3fe4" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">让我们试运行一下我们的算法，看看解决方案是如何工作的。</p><pre class="ki kj kk kl fd km kn ko kp aw kq bi"><span id="8645" class="kr ig hi kn b fi ks kt l ku kv">Input: nums = [1, 2, 1, 3, 5, 6, 4]<br/><br/>Step 1: set low = 0<br/>            high = nums.size() - 1<br/>                 = 7 - 1<br/>                 = 6<br/>        initialize mid<br/><br/>Step 2: loop while low &lt; high<br/>        0 &lt; 6<br/>        true<br/><br/>        mid = low + (high - low) / 2<br/>            = 0 + (6 - 0) / 2<br/>            = 6 / 2<br/>            = 3<br/><br/>        if nums[mid] &gt; nums[mid + 1]<br/>           nums[3] &gt; nums[4]<br/>           3 &gt; 5<br/>           false<br/><br/>        else if nums[mid] &lt;= nums[mid + 1]<br/>                nums[3] &lt;= nums[4]<br/>                3 &lt;= 5<br/>                true<br/><br/>               low = mid + 1<br/>                   = 3 + 1<br/>                   = 4<br/><br/>Step 3: loop while low &lt; high<br/>        4 &lt; 6<br/>        true<br/><br/>        mid = low + (high - low) / 2<br/>            = 4 + (6 - 4) / 2<br/>            = 4 + 2 / 2<br/>            = 4 + 1<br/>            = 5<br/><br/>        if nums[mid] &gt; nums[mid + 1]<br/>           nums[5] &gt; nums[6]<br/>           6 &gt; 4<br/>           true<br/><br/>           high = mid<br/>                = 5<br/><br/>Step 4: loop while low &lt; high<br/>        4 &lt; 5<br/>        true<br/><br/>        mid = low + (high - low) / 2<br/>            = 4 + (5 - 4) / 2<br/>            = 4 + 1 / 2<br/>            = 4 + 0<br/>            = 4<br/><br/>        if nums[mid] &gt; nums[mid + 1]<br/>           nums[4] &gt; nums[5]<br/>           5 &gt; 6<br/>           false<br/><br/>        else if nums[mid] &lt;= nums[mid + 1]<br/>                nums[4] &lt;= nums[5]<br/>                5 &lt; 6<br/>                true<br/><br/>                low = mid + 1<br/>                    = 4 + 1<br/>                    = 5<br/><br/>Step 5: loop while low &lt; high<br/>        5 &lt; 5<br/>        false<br/><br/>Step 6: return low<br/><br/>So we return the answer as 5.</span></pre></div><div class="ab cl lj lk gp ll" role="separator"><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo"/></div><div class="hb hc hd he hf"><p id="b325" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated"><em class="kg">原载于</em><a class="ae kh" href="https://alkeshghorpade.me/post/leetcode-find-peak-element" rel="noopener ugc nofollow" target="_blank"><em class="kg">https://alkeshghorpade . me</em></a><em class="kg">。</em></p></div></div>    
</body>
</html>