<html>
<head>
<title>Handling errors functionally without exceptions</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">无例外地处理功能性错误</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/handling-errors-functionally-without-exceptions-ab4a567ba6b?source=collection_archive---------10-----------------------#2021-07-11">https://medium.com/nerd-for-tech/handling-errors-functionally-without-exceptions-ab4a567ba6b?source=collection_archive---------10-----------------------#2021-07-11</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="eed1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在函数式编程中抛出错误是一个副作用，如果不能使用异常，用什么来代替呢？最好的办法是将异常和错误作为普通值返回。在这个例子中，我们将重新创建Scala的标准库<strong class="ih hj">选项</strong>和<strong class="ih hj">选项</strong>，以更具功能性的方式处理错误。</p><p id="e40b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">例外的坏方面</strong></p><p id="4858" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为什么抛出异常不是<em class="jd">引用透明的</em>，它们在哪里破坏了函数透明性，让我们看一个例子。</p><pre class="je jf jg jh fd ji jj jk jl aw jm bi"><span id="6ca9" class="jn jo hi jj b fi jp jq l jr js"><strong class="jj hj">def</strong> <strong class="jj hj">FailingFn</strong>(i<strong class="jj hj">:Int</strong>)<strong class="jj hj">:Int</strong>={<br/>  <strong class="jj hj">val</strong> y<strong class="jj hj">:</strong> <strong class="jj hj">Int</strong> = <strong class="jj hj">throw</strong> <strong class="jj hj">new</strong> <strong class="jj hj">Exception</strong>("fail!")<br/>  <strong class="jj hj">try</strong> {<br/>    <strong class="jj hj">val</strong> x <strong class="jj hj">=</strong> <strong class="jj hj">42</strong> + <strong class="jj hj">5</strong><br/>    x+y<br/>  }<br/>  <strong class="jj hj">catch</strong> { <strong class="jj hj">case</strong> e<strong class="jj hj">:</strong> <strong class="jj hj">Exception</strong> =&gt; <strong class="jj hj">43</strong> }<br/>}</span><span id="bf94" class="jn jo hi jj b fi jt jq l jr js"><strong class="jj hj">scala&gt;</strong> FailingFn(12)<br/>java.lang.Exception: fail!<br/>  at .FailingFn(&lt;console&gt;:12)<br/>  ... 32 elided</span></pre><p id="d79a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们定义了一个抛出异常的函数，用异常替换<em class="jd"> y </em>的值。</p><pre class="je jf jg jh fd ji jj jk jl aw jm bi"><span id="b730" class="jn jo hi jj b fi jp jq l jr js"><strong class="jj hj">def</strong> <strong class="jj hj">FailingFun</strong>(i<strong class="jj hj">:Int</strong>)<strong class="jj hj">:Int</strong>={<br/>    <strong class="jj hj">try</strong>{<br/>      <strong class="jj hj">val</strong> x<strong class="jj hj">=3</strong><br/>// A thrown exception can be given any type here we are giving it a type Int<br/>      x+((<strong class="jj hj">throw</strong> <strong class="jj hj">new</strong> <strong class="jj hj">Exception</strong>("fail"))<strong class="jj hj">:Int</strong>)<br/>    }<br/>    <strong class="jj hj">catch</strong> {<strong class="jj hj">case</strong> e<strong class="jj hj">:Exception</strong>=&gt;<strong class="jj hj">43</strong>}<br/>  }</span><span id="5dc3" class="jn jo hi jj b fi jt jq l jr js"><strong class="jj hj">scala&gt;</strong> FailingFun(12)<br/>res1: Int = 43</span></pre><p id="694a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在我们可以看到上面的例子不是<em class="jd">引用透明的</em>，在第二个例子中我们得到了不同的输出，因为异常是在try块中定义的。这意味着抛出异常取决于定义它的上下文。</p><p id="f2cb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">上下文1 </strong>:声明<em class="jd"> y </em>抛出异常<em class="jd">“fail”</em>，在这种情况下y是在try块之外声明的。因此catch块没有捕获异常并抛出输出fail。</p><p id="b027" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">上下文2 </strong>:在第二个上下文中，我们在try块中抛出了一个异常，结果，<strong class="ih hj">案例e </strong>得到了一个匹配，并给出了一个不同的输出。</p><p id="214c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">抛出异常的可能替代方案</strong></p><p id="3bcf" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们已经看到抛出依赖于使用它的上下文，这显然违背了函数式编程，那么抛出异常的其他选择是什么呢？一种可能的解决方案是，如果程序中没有异常，则正常返回结果，如果有某种错误，则返回该异常。</p><p id="eda6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Scala库为此提供了两种数据类型，<strong class="ih hj">选项</strong>和<strong class="ih hj">任一</strong>。让我们定义选项，看看它的工作情况。</p><p id="6e85" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">使用选项</strong>处理异常</p><pre class="je jf jg jh fd ji jj jk jl aw jm bi"><span id="d8b5" class="jn jo hi jj b fi jp jq l jr js"><strong class="jj hj">sealed</strong> <strong class="jj hj">trait</strong> <strong class="jj hj">Option</strong>[<strong class="jj hj">+A</strong>]<br/><strong class="jj hj">/*</strong><br/>* <strong class="jj hj">Two</strong> implementation of the option <strong class="jj hj">type</strong><br/><strong class="jj hj">*</strong> <strong class="jj hj">it</strong> <strong class="jj hj">will</strong> <strong class="jj hj">return</strong> <strong class="jj hj">a</strong> <strong class="jj hj">None</strong><br/>* or it will <strong class="jj hj">return</strong> a <strong class="jj hj">Some</strong>*/</span><span id="1538" class="jn jo hi jj b fi jt jq l jr js"><strong class="jj hj">case</strong> <strong class="jj hj">class</strong> <strong class="jj hj">Some</strong>[<strong class="jj hj">+A</strong>](get<strong class="jj hj">:A</strong>) <strong class="jj hj">extends</strong> <strong class="jj hj">Option</strong>[<strong class="jj hj">A</strong>]<br/><strong class="jj hj">case</strong> <strong class="jj hj">object</strong> <strong class="jj hj">None</strong> <strong class="jj hj">extends</strong> <strong class="jj hj">Option</strong>[<strong class="jj hj">Nothing</strong>]</span></pre><p id="630d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在上面的代码中，我们实现了一个名为<strong class="ih hj">选项的特征。</strong>对于那些我们不知道的人来说，一个trait就像java中的一个接口，可以包含可选的方法实现。</p><blockquote class="ju jv jw"><p id="175c" class="if ig jd ih b ii ij ik il im in io ip jx ir is it jy iv iw ix jz iz ja jb jc hb bi translated">关于Scala特征、协方差以及泛型类型在Scala中的重要性的更多信息，请参考我以前的文章。下面提供了链接。</p></blockquote><div class="ka kb ez fb kc kd"><a rel="noopener follow" target="_blank" href="/codex/functional-data-structures-and-pattern-matching-in-scala-7a379092e1e4"><div class="ke ab dw"><div class="kf ab kg cl cj kh"><h2 class="bd hj fi z dy ki ea eb kj ed ef hh bi translated">Scala中的函数数据结构和模式匹配</h2><div class="kk l"><h3 class="bd b fi z dy ki ea eb kj ed ef dx translated">函数式编程范式是一种没有任何可变状态的代码编写方式。所以这提出了一个…</h3></div><div class="kl l"><p class="bd b fp z dy ki ea eb kj ed ef dx translated">medium.com</p></div></div><div class="km l"><div class="kn l ko kp kq km kr ks kd"/></div></div></a></div><p id="8c4a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在我们可以看到两个类实现了我们的选项特征，</p><ul class=""><li id="d008" class="kt ku hi ih b ii ij im in iq kv iu kw iy kx jc ky kz la lb bi translated"><strong class="ih hj"> Some </strong>它扩展了Option显示我们的函数返回值不是错误的条件，<strong class="ih hj">代码中使用的A </strong>表示泛型<strong class="ih hj"> A </strong>可以是整数、双精度或某种函数。</li><li id="d245" class="kt ku hi ih b ii lc im ld iq le iu lf iy lg jc ky kz la lb bi translated">类型表示一个异常，我们的函数返回一个不是有效输出的东西。</li></ul><p id="076d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在让我们实现一个使用<strong class="ih hj">选项</strong>数据类型来处理异常的函数。下面的函数将一个列表作为输入，并返回列表的平均值。如果列表为空，它将返回一个<strong class="ih hj"> None </strong>表示我们无法找到空列表的含义。</p><pre class="je jf jg jh fd ji jj jk jl aw jm bi"><span id="6a3a" class="jn jo hi jj b fi jp jq l jr js">/*<br/>  * It can take any of the two values<br/>  * either a None value in case of an exception<br/>  * or a Some in cases with no exception*/</span><span id="8714" class="jn jo hi jj b fi jt jq l jr js">  <strong class="jj hj">def</strong> mean(lis1<strong class="jj hj">:Seq</strong>[<strong class="jj hj">Double</strong>])<strong class="jj hj">:Option</strong>[<strong class="jj hj">Double</strong>]={<br/>    <strong class="jj hj">if</strong> (lis1.isEmpty) <strong class="jj hj">None</strong><br/>    <strong class="jj hj">else</strong> <strong class="jj hj">Some</strong>(lis1.sum/lis1.length)<br/>  }</span></pre><p id="364d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">返回的是<strong class="ih hj">选项【Double】</strong>可以是None类型或者<strong class="ih hj"> Some </strong>。下图显示了两个函数return，一个返回double，另一个返回Option。</p><figure class="je jf jg jh fd li er es paragraph-image"><div role="button" tabindex="0" class="lj lk di ll bf lm"><div class="er es lh"><img src="../Images/404c63978a52823a3a7468eca7041e26.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*C_lAW7QYGpLFaxESA24Xmw.png"/></div></div><figcaption class="lo lp et er es lq lr bd b be z dx translated">使用选项和标记类型的输入和输出</figcaption></figure><p id="e871" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">使用</strong>处理异常</p><pre class="je jf jg jh fd ji jj jk jl aw jm bi"><span id="55d1" class="jn jo hi jj b fi jp jq l jr js"><strong class="jj hj">sealed</strong> <strong class="jj hj">trait</strong> <strong class="jj hj">Either</strong>[<strong class="jj hj">+E</strong>,<strong class="jj hj">+A</strong>]<br/><br/><strong class="jj hj">case</strong> <strong class="jj hj">class</strong> <strong class="jj hj">Exception</strong>[<strong class="jj hj">+E</strong>](value<strong class="jj hj">:E</strong>) <strong class="jj hj">extends</strong> <strong class="jj hj">Either</strong>[<strong class="jj hj">E</strong>,<strong class="jj hj">Nothing</strong>]<br/><strong class="jj hj">case</strong> <strong class="jj hj">class</strong> <strong class="jj hj">Success</strong>[<strong class="jj hj">+A</strong>](value<strong class="jj hj">:A</strong>) <strong class="jj hj">extends</strong> <strong class="jj hj">Either</strong>[<strong class="jj hj">Nothing</strong>,<strong class="jj hj">A</strong>]</span></pre><p id="9e7b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">数据类型<strong class="ih hj">或者</strong>有两个通用参数，<strong class="ih hj"> E </strong>代表异常，<strong class="ih hj"> A </strong>代表有效值。</p><p id="0a00" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这个特征要么是由两个类实现的<em class="jd">异常和成功。</em></p><ul class=""><li id="9018" class="kt ku hi ih b ii ij im in iq kv iu kw iy kx jc ky kz la lb bi translated"><strong class="ih hj">异常</strong>表示一个错误，其有效值为Nothing，并且有某种异常。</li><li id="b0e6" class="kt ku hi ih b ii lc im ld iq le iu lf iy lg jc ky kz la lb bi translated"><strong class="ih hj">成功</strong>没有异常，有某种有效输出。</li></ul><pre class="je jf jg jh fd ji jj jk jl aw jm bi"><span id="dbd5" class="jn jo hi jj b fi jp jq l jr js"><strong class="jj hj">def</strong> mean(lis1<strong class="jj hj">:List</strong>[<strong class="jj hj">Int</strong>])<strong class="jj hj">:Either</strong>[<strong class="jj hj">String</strong>,<strong class="jj hj">Double</strong>]={<br/>    <strong class="jj hj">if</strong> (lis1.isEmpty) <strong class="jj hj">Exception</strong>("Mean of an empty array")<br/>    <strong class="jj hj">else</strong> <strong class="jj hj">Success</strong>(lis1.sum/lis1.length)<br/>  }</span></pre><ul class=""><li id="0133" class="kt ku hi ih b ii ij im in iq kv iu kw iy kx jc ky kz la lb bi translated">在上面的例子中，如果list为null，我们将返回一个类型异常，它将一个字符串作为参数。</li><li id="c445" class="kt ku hi ih b ii lc im ld iq le iu lf iy lg jc ky kz la lb bi translated">如果列表不为空，将返回一个以double为参数的成功类型。</li></ul><p id="2ada" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">外部链接</strong></p><p id="278e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">下面是我以前关于函数式编程的博客的一些参考资料。</p><div class="ka kb ez fb kc kd"><a href="https://krishnaprasad-k.medium.com/a-practical-introduction-to-functional-programming-b99f74ac96fe" rel="noopener follow" target="_blank"><div class="ke ab dw"><div class="kf ab kg cl cj kh"><h2 class="bd hj fi z dy ki ea eb kj ed ef hh bi translated">函数式编程的实用介绍</h2><div class="kk l"><h3 class="bd b fi z dy ki ea eb kj ed ef dx translated">函数式编程(FP)是一个具有深远意义的简单前提。我们构建我们的程序只使用…</h3></div><div class="kl l"><p class="bd b fp z dy ki ea eb kj ed ef dx translated">krishnaprasad-k.medium.com</p></div></div><div class="km l"><div class="ls l ko kp kq km kr ks kd"/></div></div></a></div><div class="ka kb ez fb kc kd"><a href="https://krishnaprasad-k.medium.com/purely-algebraic-structures-in-scala-monoids-8c4c2ac79970" rel="noopener follow" target="_blank"><div class="ke ab dw"><div class="kf ab kg cl cj kh"><h2 class="bd hj fi z dy ki ea eb kj ed ef hh bi translated">scala中的纯代数结构:幺半群</h2><div class="kk l"><h3 class="bd b fi z dy ki ea eb kj ed ef dx translated">什么是幺半群</h3></div><div class="kl l"><p class="bd b fp z dy ki ea eb kj ed ef dx translated">krishnaprasad-k.medium.com</p></div></div><div class="km l"><div class="lt l ko kp kq km kr ks kd"/></div></div></a></div></div></div>    
</body>
</html>