<html>
<head>
<title>Candlestick Patterns, They Really Work? Conducting a Massive Event Study</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">烛台图案，真的有用吗？进行大规模的事件研究</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/candlestick-patterns-they-really-work-conducting-a-massive-event-study-13f538e4c891?source=collection_archive---------0-----------------------#2021-01-11">https://medium.com/nerd-for-tech/candlestick-patterns-they-really-work-conducting-a-massive-event-study-13f538e4c891?source=collection_archive---------0-----------------------#2021-01-11</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="e0ce" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">烛台模式是18世纪在日本发展起来的一种古老的技术分析形式。这项发明归功于日本大米交易商Munehisa Homma，但直到90年代初，这项技术才由Steve Nilson在他的书《日本烛台制图技术》中推广开来。本文旨在对所有标准普尔&amp; P500成份股进行事件研究，以确定烛台作为预测工具的实际有效性。</p><p id="d17c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在第一部分，我们解释了烛台的基本知识。然后，在第二部分，我们详细介绍了进行事件研究的程序。在第三部分中，我们回顾了用于进行研究的Python代码。在第四部分，我们展示了实验的结果，最后，在第五部分，我们得出结论。</p><h1 id="92be" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">烛台基础</h1><p id="adfd" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">这篇文章的目的不是要详细探究所有烛台模式是如何工作的，而是要简要解释一根蜡烛是如何被阅读的。</p><figure class="ki kj kk kl fd km er es paragraph-image"><div class="er es kh"><img src="../Images/d1fdfd8f703223b4e6eccb674895802a.png" data-original-src="https://miro.medium.com/v2/resize:fit:960/format:webp/1*-MCjIZGrHj-s9JV8IDVW3Q.png"/></div></figure><p id="094e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">蜡烛图和条形图没有太大的不同，两者显示了相同的信息。主要的区别在于术语和词汇。蜡烛线的中心被称为“真实体”，它代表开盘价和收盘价之间的价格范围。如果真正的身体是黑色的，这意味着关闭低于开放，而白色的身体表明相反。那么，实体的上下就是所谓的“影子”，上下，显示的是那个交易日的价格高低。关于烛台的事情是，他们有时形成几种模式，作为预测。模式分为看涨和看跌，无论它们预测的是资产价格的上涨还是下跌。</p><p id="3a70" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">使用烛台最困难的部分是识别图案。幸运的是，Python提供了一个名为TA-Lib的库来简化这项任务。该软件包还有几个用于进行技术分析的特性，我们邀请您查看参考资料部分。</p><h1 id="71fe" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">事件研究</h1><p id="8958" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">在本节中，我们将解释为进行分析而实施的方法。首先，一个必要的定义:什么是事件研究？</p><p id="ba5e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">事件研究是一种统计技术，用来衡量特定事件对公司或资产价值的影响。该方法依赖于法玛的市场效率假说(EMH)和资本资产定价模型(CAPM)。下面，我们详细介绍事件研究的过程:</p><p id="b94b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> 1)定义事件:</strong>第一步是选择将进行研究的事件(以及公司或资产)。通常，对股票分割、并购公告、收益公告、宏观经济公告等进行事件研究。在这条线上，事件被定义为在明确定义的时间点上的非预期冲击。</p><p id="0882" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> 2)将数据拆分成窗口:</strong>仔细选择事件后，我们要确定一个估计窗口、一个事件窗口和一个控制窗口。我们可以观察下图中每个窗口的长度。在估计窗口中，我们将使用事件窗口之前可用的数据拟合模型，以计算一系列参数。在这一行中，窗口必须足够长(这与事件的行为有关)以使估计的参数稳健。然后，在控制窗口(事后窗口)中，我们将应用估计的参数来计算异常收益。事件窗口可以分为两个阶段:事件前的时刻(T1到0)、事件当天(t=0)和3-事件后的时刻(0到T2)。在我们的例子中，T2=0。</p><figure class="ki kj kk kl fd km er es paragraph-image"><div class="er es kp"><img src="../Images/0fa80fd20681191cf33f2f2b3b2df319.png" data-original-src="https://miro.medium.com/v2/resize:fit:1254/format:webp/1*_C84MikmMpXsSOtw8JGjhw.png"/></div></figure><p id="f304" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> 3)选择模型:</strong>下一步是选择一个模型来计算估计窗口的参数，我们将重点关注两个:均值收益模型和市场模型。</p><p id="6f5a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">均值-回报:是一个单因素模型，假设回报行为可以用其期望值(mu)加上白噪声(epsilon)来解释。</p><figure class="ki kj kk kl fd km er es paragraph-image"><div class="er es kq"><img src="../Images/c57b1d0f78244a936344d26637ba9e9c.png" data-original-src="https://miro.medium.com/v2/resize:fit:548/format:webp/1*-opA7qS4QE6myet5NJuodQ.png"/></div><figcaption class="kr ks et er es kt ku bd b be z dx translated">Ri，t表示公司(或资产)I在交易日<em class="kv"> t </em>的收益。</figcaption></figure><p id="117b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">市场模型或CAPM:假设两个风险因素解释了回报的行为。CAPM认为，一项资产的回报可以部分地用市场回报(Rm)来解释，另一方面，也可以用公司的特质风险(epsilon)来解释。就本文的范围而言，我们将特别关注这个模型。</p><figure class="ki kj kk kl fd km er es paragraph-image"><div class="er es kw"><img src="../Images/262f90b6dae84c0bf138596758f909fa.png" data-original-src="https://miro.medium.com/v2/resize:fit:972/format:webp/1*t24amIYxJiDCGMqatEsBQA.png"/></div><figcaption class="kr ks et er es kt ku bd b be z dx translated">阿尔法和贝塔从OLS回归中获得。</figcaption></figure><p id="31fd" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> 4)计算异常收益:</strong>选择模型后，我们就可以计算控制窗口内的异常收益(ARs)了。ARs被定义为资产的当前价格与模型(在这种情况下是市场模型)估计的预测或“公平”价格之间的差异。</p><figure class="ki kj kk kl fd km er es paragraph-image"><div class="er es kx"><img src="../Images/08dbab930cbdfb970851c16c2c6e3ccf.png" data-original-src="https://miro.medium.com/v2/resize:fit:876/format:webp/1*hsQjxZzvUbf7cwShIjtLJw.png"/></div></figure><p id="3b8e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">程序很简单:1-我们用估计窗口中的可用数据估计阿尔法和贝塔，2-我们计算控制窗口中的回报期望值，3-我们计算ARs。</p><p id="863e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">执行T检验:最后一步是计算统计量，并执行T-student检验。对于这一步，我们需要计算控制窗口内的累积异常收益(CAR)。</p><figure class="ki kj kk kl fd km er es paragraph-image"><div role="button" tabindex="0" class="kz la di lb bf lc"><div class="er es ky"><img src="../Images/f9b8cf78caa81fb6c99667bb393b8814.png" data-original-src="https://miro.medium.com/v2/resize:fit:904/format:webp/1*03Od49TYsaDXutUxOx7IJg.png"/></div></div></figure><p id="778f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在这一行中，统计分布为具有L1的T-student-2自由度。对于我们的例子，我们根据蜡烛图的趋势(看涨或看跌)进行单尾t检验。在这条线上，对看涨和看跌模式的测试表明:</p><figure class="ki kj kk kl fd km er es paragraph-image"><div class="er es ld"><img src="../Images/11771b64ea7a9ff0635b746d9bc55113.png" data-original-src="https://miro.medium.com/v2/resize:fit:660/format:webp/1*0iA-9hX-hWimwUVq2JtBQA.png"/></div></figure><h1 id="cb85" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">代码</h1><p id="dbbb" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">在这一节中，我们将检查为进行实验而实现的代码。我们定义了一个名为Events的类，它包含了整个代码:</p><pre class="ki kj kk kl fd le lf lg lh aw li bi"><span id="eb11" class="lj jf hi lf b fi lk ll l lm ln"># Necessary Imports<br/>import talib as tb<br/>import yfinance as yf<br/>import pandas as pd<br/>from dateutil.relativedelta import relativedelta<br/>import numpy as np<br/>from sklearn.linear_model import LinearRegression</span><span id="c93b" class="lj jf hi lf b fi lo ll l lm ln">class Events:<br/>    def __init__(self,df,l1,l2,l3,model,patterns):<br/>        """<br/>        df: DataFrame with price data: Open, Close, High &amp; Low. <br/>        l1: length of estimation window. <br/>        l2: length of event window<br/>        l3: length of control window<br/>        model: market or mean return model. <br/>        patterns: candlestick patterns to conduct the event study. <br/>        """<br/>        self.df=df<br/>        self.l1=l1<br/>        self.l2=l2<br/>        self.l3=l3<br/>        self.model=model<br/>        self.patterns=patterns<strong class="lf hj"><em class="jd">Getting Events</em></strong></span></pre><p id="4478" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">正如我们之前提到的，TA-Lib库提供了一个非常容易识别烛台模式的属性。目前TA-Lib的识别算法支持61种模式。该函数的语法非常简单:PATTERN_NAME (Open，High，Low，Close)。在这一行中，我们可以使用Python的内置<em class="jd"> getattr </em>，传递库名(或缩写)、模式名和四个输入。模式识别函数在发现看涨模式时输出100，看跌模式输出-100，没有识别出任何模式时输出0。有关TA-Lib属性的更多信息，可以在参考资料部分找到该库的文档。</p><pre class="ki kj kk kl fd le lf lg lh aw li bi"><span id="7f73" class="lj jf hi lf b fi lk ll l lm ln">def candle_events(self,stock,pattern):   <br/><br/>        #Define the events<br/>        ind=self.df['Adj Close'][stock].dropna().index.tolist()<br/>        df=pd.DataFrame(index=ind)<br/>        hi=self.df['High'][stock].dropna().values<br/>        lo=self.df['Low'][stock].dropna().values<br/>        op=self.df['Open'][stock].dropna().values<br/>        cl=self.df['Close'][stock].dropna().values<br/>        df[pattern] = getattr(tb, pattern)(op, hi, lo, cl)<br/>        events=df[df[pattern]!=0][pattern]</span></pre><p id="77a2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> <em class="jd">建筑窗户</em> </strong></p><p id="097b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">代码中的以下步骤是为事件数据框中的每个事件定义估计和控制窗口。这部分代码的关键是事件不能重叠。如果我们选择一个事件与另一个事件的估计窗口重叠，我们将获得有偏差的结果。</p><pre class="ki kj kk kl fd le lf lg lh aw li bi"><span id="876b" class="lj jf hi lf b fi lk ll l lm ln">#Dates list<br/>        dates=events.index.tolist()<br/>        dates.insert(0,df.index[1])<br/>        dates.append(df.index[-1])</span><span id="10cf" class="lj jf hi lf b fi lo ll l lm ln">#Compute Windows<br/>        estimation_window=[]<br/>        control_window=[]<br/>        event_day=[]<br/>        bullish_bearish=[]<br/>        for i in range(1,len(dates)-1):<br/>            if ind.index(dates[i])-ind.index(dates[i-1])&gt;=self.l1+self.l2 and ind.index(dates[i+1])-ind.index(dates[i])&gt;=self.l3+1:<br/>                estimation_window.append((ind[ind.index(dates[i])-(self.l1+self.l2)],ind[ind.index(dates[i])-self.l2]))<br/>                control_window.append((ind[ind.index(dates[i])+1],ind[ind.index(dates[i])+self.l3]))<br/>                event_day.append(str(dates[i])[:-9])<br/>                bullish_bearish.append(events.loc[dates[i]])</span><span id="ea81" class="lj jf hi lf b fi lo ll l lm ln">return estimation_window,control_window,event_day,bullish_bearish</span></pre><p id="88cd" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> <em class="jd">选择型号</em> </strong></p><p id="0d18" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">正如我们在上一节中所描述的，第三步是定义一个模型来估计预期回报。我们的代码是为前面提到的两个模型准备的:均值收益和市场模型。对于OLS回归，我们使用Scikit Learn的回归工具。</p><pre class="ki kj kk kl fd le lf lg lh aw li bi"><span id="9199" class="lj jf hi lf b fi lk ll l lm ln">def get_CAR(self,stock,pattern):<br/>      <br/>        reference_index=self.df['Adj Close'].columns[-1]<br/>        estimation_window, control_window, event_day, bullish_bearish=self.candle_events(stock,pattern)<br/>        log_returns=np.log(abs(self.df['Adj Close'][[stock,reference_index]])/abs(self.df['Adj Close'][[stock,reference_index]].shift(1))).dropna()</span><span id="10aa" class="lj jf hi lf b fi lo ll l lm ln">CAR, V_CAR, SCAR={},{},{}<br/>        <br/>        if event_day==[]:<br/>            return {}, {}, {}, {}<br/>        <br/>        else:<br/>            for t in range(len(estimation_window)):<br/>                #Linear Regression<br/>                Rm_estimation=log_returns[reference_index].loc[estimation_window[t][0]:estimation_window[t][1]].values.reshape(-1,1)<br/>                Ri_estimation=log_returns[stock].loc[estimation_window[t][0]:estimation_window[t][1]].values.reshape(-1,1)<br/>                Rm_event=log_returns[reference_index].loc[control_window[t][0]:control_window[t][1]].values.reshape(-1,1)<br/>                Ri_event=log_returns[stock].loc[control_window[t][0]:control_window[t][1]].values<br/>                <br/>                #Calculate expected returns (Market or Mean Return model)<br/>                if self.model=='market':<br/>                    lm=LinearRegression()<br/>                    lm.fit(Rm_estimation,Ri_estimation)<br/>                    event_preds=lm.predict(Rm_event).reshape(Rm_event.shape[0])<br/>                    est_fitted=lm.predict(Rm_estimation).reshape(Rm_estimation.shape[0])</span><span id="01f9" class="lj jf hi lf b fi lo ll l lm ln">elif self.model=='mean return':<br/>                    event_preds=est_fitted=Ri_estimation.reshape(Ri_estimation.shape[0]).mean()</span></pre><p id="fc6f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> <em class="jd">计算ARs并构建T-stat </em> </strong></p><p id="3e61" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">下一步是计算异常收益并构建T统计量。</p><pre class="ki kj kk kl fd le lf lg lh aw li bi"><span id="e8d6" class="lj jf hi lf b fi lk ll l lm ln">#AR estimation window<br/>                AR_est=Ri_estimation.reshape(Ri_estimation.shape[0])-est_fitted</span><span id="e892" class="lj jf hi lf b fi lo ll l lm ln">#AR for the control window<br/>                AR_event=Ri_event.reshape(Ri_event.shape[0])-event_preds</span><span id="0bd1" class="lj jf hi lf b fi lo ll l lm ln">#Variance of AR<br/>                Vi=sum(AR_est**2)/(self.l1-2)</span><span id="6a7a" class="lj jf hi lf b fi lo ll l lm ln">#CAR &amp; CAR variance<br/>                if Vi!=0:<br/>                    CAR[str(event_day[t])]=sum(AR_event)<br/>                    V_CAR[str(event_day[t])]=self.l3*Vi<br/>                    SCAR[str(event_day[t])]=CAR[str(event_day[t])]/V_CAR[str(event_day[t])]**0.5<br/>                else:<br/>                    pass<br/>            <br/>            return CAR, V_CAR, SCAR, bullish_bearish</span></pre><p id="b2f2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> <em class="jd">计算重大事件在模式中的比例</em> </strong></p><p id="f85c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为了进行大规模的研究，我们必须构建一个函数，对一组股票重复执行研究过程。在这一行中，下面的函数对<em class="jd"> self.df </em>数据框中的每只股票运行get_CAR()，并根据与所选模式(看涨或看跌)相关的趋势计算t检验的p值。然后，它将具有统计显著性的事件数量(在5%的水平上)添加到一个字典中，并将分析的样本总数(事件)添加到另一个字典中。</p><pre class="ki kj kk kl fd le lf lg lh aw li bi"><span id="f8a2" class="lj jf hi lf b fi lk ll l lm ln">def pattern_significance(self,pattern):<br/>        <br/>        #Number of stocks in the sample<br/>        stocks=self.df['Adj Close'].columns[:-1]<br/>        <br/>        one_tail_sign,N={},{}<br/>        <br/>        for s in tq(stocks):<br/>            SCAR,bullish_bearish=self.get_CAR(s,pattern)[2:4]<br/>            <br/>            if SCAR!={}:<br/>                #Two tail t-test<br/>                #tt_pvalue=[2*(1-t.cdf(abs(x),self.l1-2)) for x in SCAR.values()]<br/>                #two_tail_sign[s]=sum([1 for x in tt_pvalue if x&lt;0.01])/len(tt_pvalue)<br/>                <br/>                #One tail t-test depending on the pattern trend (Bullish or Bearish)<br/>                for i in bullish_bearish:<br/>                    if i==100:<br/>                        ot_pvalue=[t.pdf(x,self.l1-2) for x in SCAR.values()]<br/>                        one_tail_sign[s]=sum([1 for x in ot_pvalue if x&lt;0.05])<br/>                    elif i==-100:<br/>                        ot_pvalue=[t.cdf(x,self.l1-2) for x in SCAR.values()]<br/>                        one_tail_sign[s]=sum([1 for x in ot_pvalue if x&lt;0.05])<br/>                    else:<br/>                        one_tail_sign[s]=np.nan<br/>           <br/>            elif SCAR=={}:<br/>                #two_tail_sign[s]=np.nan<br/>                one_tail_sign[s]=np.nan<br/>            <br/>            #Number of observations for each stock<br/>            N[s]=len(SCAR)<br/>            <br/>        return one_tail_sign,sum(N.values())</span></pre><p id="1d0b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">对所有可用模式进行研究</strong></p><p id="034f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在代码的最后一部分，我们简单地将pattern_significance函数扩展到TA-Lib中可用的61个模式。该函数输出一个数据框，其中股票代码作为行，模式名称作为列，包含统计意义上的事件数量和一个字典，其中包含为每个模式分析的样本数量。</p><pre class="ki kj kk kl fd le lf lg lh aw li bi"><span id="e73b" class="lj jf hi lf b fi lk ll l lm ln">def S_overall(self):<br/>        one_tail_soverall={}<br/>        N_events={}<br/>        for p in tq(self.patterns):<br/>            ot_sign, N = self.pattern_significance(p)<br/>            N_events[p]=N<br/>            one_tail_soverall[p]=ot_sign</span><span id="62b1" class="lj jf hi lf b fi lo ll l lm ln">return pd.DataFrame(one_tail_soverall,index=self.df['Adj Close'].columns[:-1]),N_events</span></pre><p id="40eb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">要可视化整个代码，可以参考参考资料一节中的Github repo。</p><h1 id="a225" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">实验结果</h1><p id="90c7" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">实验使用市场模型，以指数作为市场基准，对S&amp;P500的502只成份股进行。我们选择L1=200，L2=2，L3=4个交易日。该算法总共处理了136，555个事件。在下表中，我们可以看到前三个和后三个模式，按统计显著事件的比例排列。另一方面，我们分离到另一个表中，该模式具有更多的外观，反之亦然。</p><figure class="ki kj kk kl fd km er es paragraph-image"><div class="er es lp"><img src="../Images/eccd8dfe235e41aca5dfccdd31dbc241.png" data-original-src="https://miro.medium.com/v2/resize:fit:1388/format:webp/1*a_3lesiKnj83PE8ohudZJg.png"/></div></figure><figure class="ki kj kk kl fd km er es paragraph-image"><div class="er es lq"><img src="../Images/5e0ea0d73c5a7e508a9408e2087b1057.png" data-original-src="https://miro.medium.com/v2/resize:fit:1312/format:webp/1*hLtntC78oT5G4szuTNtYBw.png"/></div></figure><p id="6d2a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">另一方面，我们可以分析模式的分布:</p><figure class="ki kj kk kl fd km er es paragraph-image"><div class="er es lr"><img src="../Images/f271d3877471a4d30b5ae0dab6626791.png" data-original-src="https://miro.medium.com/v2/resize:fit:544/format:webp/1*eczId3aA-7fWDBgs0S3rfw.png"/></div></figure><p id="8ff8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们可以观察到显著性很低。从实验中分析的136，555个事件中，只有7247个被证明是具有统计意义的。换句话说，烛台模式有5.3%的时间准确预测了价格趋势。</p><h1 id="3eb0" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">结论</h1><p id="7475" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">那么，烛台图案真的有效吗？从统计学上说，我们可以得出结论，只有5.3%的时间，烛台模式准确预测未来价格的运动。在这方面，尽管围绕这些数字的所有神秘主义，他们被证明是非常低效的预测。此外，它们甚至比随机猜测模型表现更差。总之，技术分析的另一个神话被打破了。</p><p id="76e7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们希望这篇文章的结果鼓励读者继续从不同的角度研究烛台和其他技术分析工具。在未来看到类似的技术指标和模式的实验会很有趣。</p><h1 id="d25c" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">参考</h1><p id="0a8f" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">TA-Lib的资料来源:</p><div class="ls lt ez fb lu lv"><a href="https://mrjbq7.github.io/ta-lib/" rel="noopener  ugc nofollow" target="_blank"><div class="lw ab dw"><div class="lx ab ly cl cj lz"><h2 class="bd hj fi z dy ma ea eb mb ed ef hh bi translated">TA-Lib</h2><div class="mc l"><h3 class="bd b fi z dy ma ea eb mb ed ef dx translated">这是一个基于Cython而不是SWIG的TA-LIB的Python包装器。来自主页:TA-Lib被…广泛使用</h3></div><div class="md l"><p class="bd b fp z dy ma ea eb mb ed ef dx translated">mrjbq7.github.io</p></div></div></div></a></div><p id="8133" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">关于烛台图案的更多信息:</p><div class="ls lt ez fb lu lv"><a href="https://www.investopedia.com/trading/candlestick-charting-what-is-it/" rel="noopener  ugc nofollow" target="_blank"><div class="lw ab dw"><div class="lx ab ly cl cj lz"><h2 class="bd hj fi z dy ma ea eb mb ed ef hh bi translated">理解蜡烛图</h2><div class="mc l"><h3 class="bd b fi z dy ma ea eb mb ed ef dx translated">烛台图表起源于日本，比西方发展条形图和点图图表早100多年。在…</h3></div><div class="md l"><p class="bd b fp z dy ma ea eb mb ed ef dx translated">www.investopedia.com</p></div></div><div class="me l"><div class="mf l mg mh mi me mj kn lv"/></div></div></a></div><div class="ls lt ez fb lu lv"><a href="https://www.investopedia.com/articles/active-trading/092315/5-most-powerful-candlestick-patterns.asp" rel="noopener  ugc nofollow" target="_blank"><div class="lw ab dw"><div class="lx ab ly cl cj lz"><h2 class="bd hj fi z dy ma ea eb mb ed ef hh bi translated">5种最强大的烛台模式</h2><div class="mc l"><h3 class="bd b fi z dy ma ea eb mb ed ef dx translated">蜡烛图是一种技术工具，它将多个时间框架的数据打包到单个价格条中。这使得</h3></div><div class="md l"><p class="bd b fp z dy ma ea eb mb ed ef dx translated">www.investopedia.com</p></div></div><div class="me l"><div class="mk l mg mh mi me mj kn lv"/></div></div></a></div><p id="aa74" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">关于事件研究的更多信息:</p><div class="ls lt ez fb lu lv"><a href="https://www.jstor.org/stable/2729691?seq=1" rel="noopener  ugc nofollow" target="_blank"><div class="lw ab dw"><div class="lx ab ly cl cj lz"><h2 class="bd hj fi z dy ma ea eb mb ed ef hh bi translated">JSTOR上的经济和金融事件研究</h2><div class="mc l"><h3 class="bd b fi z dy ma ea eb mb ed ef dx translated">经济和金融中的事件研究经济文献杂志经济文献杂志(JEL)，第一…</h3></div><div class="md l"><p class="bd b fp z dy ma ea eb mb ed ef dx translated">www.jstor.org</p></div></div><div class="me l"><div class="ml l mg mh mi me mj kn lv"/></div></div></a></div><div class="ls lt ez fb lu lv"><a href="https://en.wikipedia.org/wiki/Event_study" rel="noopener  ugc nofollow" target="_blank"><div class="lw ab dw"><div class="lx ab ly cl cj lz"><h2 class="bd hj fi z dy ma ea eb mb ed ef hh bi translated">事件研究</h2><div class="mc l"><h3 class="bd b fi z dy ma ea eb mb ed ef dx translated">事件研究是一种统计方法，用于评估事件对公司价值的影响。例如……</h3></div><div class="md l"><p class="bd b fp z dy ma ea eb mb ed ef dx translated">en.wikipedia.org</p></div></div></div></a></div><p id="4275" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">本文的Github资源库:</p><div class="ls lt ez fb lu lv"><a href="https://github.com/fedeglan/candlesticks-event-study" rel="noopener  ugc nofollow" target="_blank"><div class="lw ab dw"><div class="lx ab ly cl cj lz"><h2 class="bd hj fi z dy ma ea eb mb ed ef hh bi translated">费德兰/烛台-活动-研究</h2><div class="mc l"><h3 class="bd b fi z dy ma ea eb mb ed ef dx translated">在GitHub上创建一个帐户，为fede glan/candlesticks-event-study的发展做出贡献。</h3></div><div class="md l"><p class="bd b fp z dy ma ea eb mb ed ef dx translated">github.com</p></div></div><div class="me l"><div class="mm l mg mh mi me mj kn lv"/></div></div></a></div></div></div>    
</body>
</html>