<html>
<head>
<title>By A Junior, For A Beginner: The Call Stack &amp; Async Javascript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">初级作者，初学者:调用栈和异步Javascript</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/by-a-junior-for-a-beginner-the-call-stack-async-javascript-21a8f469974f?source=collection_archive---------4-----------------------#2021-04-03">https://medium.com/nerd-for-tech/by-a-junior-for-a-beginner-the-call-stack-async-javascript-21a8f469974f?source=collection_archive---------4-----------------------#2021-04-03</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="a3b1" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">了解如何逐句通过异步代码</h2></div><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ix"><img src="../Images/9bfd066e5f14cdfbfce94dc6812cff80.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xYvb-V79JK796llH4hORHQ.jpeg"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">费伦茨·阿尔马西在<a class="ae jn" href="https://unsplash.com/s/photos/javascript?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><p id="7396" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi kk translated">开始学习Javascript的旅程可能会令人望而生畏。有这么多东西要学，从哪里开始呢？有很多教程和指南会告诉你所有的基本语法。如何编写变量，不同种类的数据结构，如何定义和调用函数，等等。很早的时候，你就开始理解如何“单步执行”几行代码。不管你是否在你的旅程中遇到过它，毫无疑问你已经下意识地开始理解<em class="kt">同步</em> Javascript。</p><p id="0a17" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">同步代码——最简单的形式——从上到下按顺序执行。当然，其中也有细微差别，比如<em class="kt">提升</em>，但那是另一篇文章了。由同步代码引起的副作用——有时被用作一个特性——被称为<em class="kt">阻塞</em>。每条语句必须等到前一条语句执行完毕后才能开始执行。这是因为Javascript是一种单线程语言。</p><p id="1403" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">单线程可能听起来像一个可怕的技术术语，但我们将揭开它的含义。作为其中的一部分，我们还将看看调用堆栈，以及Javascript如何在同步和异步代码的执行中使用堆栈数据结构。我知道你现在在想什么:“哇，我还以为这是一篇关于初学者理解异步JS的文章呢？”准确地说！坚持和我在一起；我们将把它们结合成一个巨大的蝴蝶结来帮助你开始理解异步Javascript。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ku"><img src="../Images/df7fbd5acb5f4e1b94ddd49254c2563e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gouurUWxpiNj_2OqFhCwoQ.jpeg"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">照片由<a class="ae jn" href="https://unsplash.com/@cberdion?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">水晶球</a>在<a class="ae jn" href="https://unsplash.com/s/photos/deck-of-cards?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><h1 id="afd0" class="kv kw hi bd kx ky kz la lb lc ld le lf io lg ip lh ir li is lj iu lk iv ll lm bi translated">一摞？…纸牌？</h1><p id="dc82" class="pw-post-body-paragraph jo jp hi jq b jr ln ij jt ju lo im jw jx lp jz ka kb lq kd ke kf lr kh ki kj hb bi translated">现在你可能很好奇<em class="kt">单线程</em>和<em class="kt">调用栈</em>是什么意思。事实证明，它们关系非常密切，就像PB &amp; J一样。让我们开始吧！</p><p id="9ca3" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">堆栈抽象数据结构在1946年首次出现在计算机科学领域，这要归功于二战中著名的轴心国“英格玛机器”的破译者艾伦·图灵。在Javascript中，同步执行的代码队列被称为c <em class="kt"> all堆栈。</em>确切地说，它最好被想象成桌子上的一叠卡片。堆栈中的第一张牌很快被埋在底部，调用堆栈一张一张地增长。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es ls"><img src="../Images/4f7f854bfbeedc1c32f8c2e0a4b4fc3d.png" data-original-src="https://miro.medium.com/v2/resize:fit:900/format:webp/1*mEGREiyUoNBhDRKU3ws2YQ.png"/></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">调用堆栈可视化</figcaption></figure><p id="16e2" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">但是，当我们需要拿到卡在底部或底部附近的卡片时，会发生什么呢？我们需要先移除顶部的所有东西才能拿到它！这种方法通常被描述为<strong class="jq hj"> <em class="kt">先进后出</em> </strong>。每条语句都按顺序被推到堆栈的顶部。相反，每条语句在完成后都从上至下弹出堆栈。那么单线程呢？本质上，单线程是Javascript只有一个调用栈的一种奇特说法。没什么好怕的！</p><h1 id="32cb" class="kv kw hi bd kx ky kz la lb lc ld le lf io lg ip lh ir li is lj iu lk iv ll lm bi translated">异步语言还是同步语言？</h1><p id="d107" class="pw-post-body-paragraph jo jp hi jq b jr ln ij jt ju lo im jw jx lp jz ka kb lq kd ke kf lr kh ki kj hb bi translated"><strong class="jq hj"> <em class="kt">“什么？我以为Javascript是异步的？”</em></strong>……算是吧。你看，年轻的学徒，Javascript有它自己的绝地思维技巧。不要忘记我们已经了解到它是一种单线程语言，Javascript确实也能够异步执行代码。</p><p id="287d" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">除了调用栈，还要对<strong class="jq hj"> <em class="kt">事件循环</em> </strong>有个大概的了解。分解Javascript如何处理异步代码的最基本方法是查看四个部分:</p><ul class=""><li id="f0a8" class="lt lu hi jq b jr js ju jv jx lv kb lw kf lx kj ly lz ma mb bi translated">调用栈</li><li id="f3d7" class="lt lu hi jq b jr mc ju md jx me kb mf kf mg kj ly lz ma mb bi translated">Web APIs</li><li id="e10f" class="lt lu hi jq b jr mc ju md jx me kb mf kf mg kj ly lz ma mb bi translated">任务排队</li><li id="3ffb" class="lt lu hi jq b jr mc ju md jx me kb mf kf mg kj ly lz ma mb bi translated">事件循环。</li></ul><p id="af25" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">之前，我们讨论了如何使用同步代码将每个代码语句推入调用堆栈或从调用堆栈弹出。记住这一点，当遇到像<code class="du mh mi mj mk b">setTimeout</code> ( <a class="ae jn" href="https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/setTimeout" rel="noopener ugc nofollow" target="_blank"> MDN doc </a>)这样的异步函数时会发生什么？您知道Javascript是单线程的，所以您可能倾向于认为因为函数已经被调用，所以它会在主线程中立即开始计算超时。我不会责怪你这种想法，这正是我们教你如何一步一步完成代码的！但是，如果是这种情况，剩余的代码将被阻止执行，直到超时完成。</p><h1 id="3a52" class="kv kw hi bd kx ky kz la lb lc ld le lf io lg ip lh ir li is lj iu lk iv ll lm bi translated">欢迎来到事件循环</h1><p id="2cbb" class="pw-post-body-paragraph jo jp hi jq b jr ln ij jt ju lo im jw jx lp jz ka kb lq kd ke kf lr kh ki kj hb bi translated">事件循环是Javascript能够执行异步代码的核心。许多人提到事件循环，好像它是运行代码本身的东西，但这实际上有点误解。更具体地说，它监视调用堆栈和任务队列。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es ml"><img src="../Images/9619e23aa442e833ae8b6bddc7363a28.png" data-original-src="https://miro.medium.com/v2/resize:fit:986/format:webp/1*lOrGk6xlTBOJl5SJfaPDDw.png"/></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">调用堆栈、web APIs、任务队列和事件循环流程</figcaption></figure><p id="974e" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">让我们暂时回到我们的<code class="du mh mi mj mk b">setTimeout</code>例子。我们讨论了如果它在单线程中运行，它将如何阻塞后续代码，直到定时器到期。实际上，Javascript读取对<code class="du mh mi mj mk b">setTimeout</code>的调用，并且——因为它是一个异步函数——将它交给web API。Web APIs内置在浏览器中，可以做很多事情，其中之一就是在自己的调用栈中处理Javascript的异步函数！</p><p id="4cd2" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">一旦web API接收到我们的<code class="du mh mi mj mk b">setTimeout</code>，计时器就开始运行。在一个异步函数完成之后——在这个场景中，我们的定时器到期了——在web API中，它被移动到任务队列中。这是事件循环工作的地方。它不断地检查调用栈是否为空，如果是，我们的<code class="du mh mi mj mk b">setTimeout</code>回调函数现在被推到执行它的栈中。</p><h1 id="67a2" class="kv kw hi bd kx ky kz la lb lc ld le lf io lg ip lh ir li is lj iu lk iv ll lm bi translated">重述和吸收</h1><p id="7381" class="pw-post-body-paragraph jo jp hi jq b jr ln ij jt ju lo im jw jx lp jz ka kb lq kd ke kf lr kh ki kj hb bi translated">咻，那是一阵旋风！现在你已经学会了一堆技术术语，希望你能意识到这没什么可怕的。异步Javascript最终归结为什么？一个圆圈。让我们应用我们的循环并完成一个代码示例:</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="mm mn l"/></div></figure><p id="2c0f" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">在示例代码中，我们总共有5个字符串被记录到控制台。从<strong class="jq hj">线开始5</strong>(<code class="du mh mi mj mk b">setTimeout → timer1</code>)<strong class="jq hj">线11</strong>(<code class="du mh mi mj mk b">setTimeout → timer2</code>)<strong class="jq hj">线17</strong>(<code class="du mh mi mj mk b">1st log</code>)<strong class="jq hj">线19</strong>(<code class="du mh mi mj mk b">2nd log</code>)<strong class="jq hj">线21 </strong> ( <code class="du mh mi mj mk b">3rd log</code>)。如果您不熟悉<code class="du mh mi mj mk b">Date.now()</code>呼叫，请不要担心，只要知道我们正在使用它们来获取当前时间。计时器还将打印自脚本启动以来的总时间(以秒为单位)。您认为所有代码运行完毕后，控制台会是什么样子？</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es mo"><img src="../Images/f666b084d022ef10a65c1dc46ee5cff3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*023HJDIFlej-W6Dd"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">照片由<a class="ae jn" href="https://unsplash.com/@zlucerophoto?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">扎克·卢塞罗</a>在<a class="ae jn" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="8813" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">准备好你的答案了吗？太棒了。让我们逐句通过代码来理解结果:</p><pre class="iy iz ja jb fd mp mk mq mr aw ms bi"><span id="f437" class="mt kw hi mk b fi mu mv l mw mx">&gt; 1st log              // line 17<br/>&gt; 2nd log              // line 19<br/>&gt; 3rd log              // line 21<br/>&gt; timer2 : 2 sec       // line 11<br/>&gt; timer1 : 3 sec       // line 5</span></pre><p id="e9db" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">我们遇到的第一个语句在第<strong class="jq hj"> 5 </strong>行。这是我们的<code class="du mh mi mj mk b">setTimeout</code>，它会将<code class="du mh mi mj mk b">‘timer1’</code>记录到控制台。然而，我们知道这是一个异步函数，因此它被放在web API中，开始3秒倒计时。</p><p id="db8e" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">与此同时，我们的代码继续运行其单线程，并在第<strong class="jq hj"> 11 </strong>行遇到另一个setTimeout。这个会打印<code class="du mh mi mj mk b">‘timer2’</code>。当它倒计时2秒时，它再次被放入web API中。</p><p id="ea1f" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">接下来的三个语句都是简单的同步控制台日志，位于第<strong class="jq hj"> 17 </strong>、<strong class="jq hj"> 19 </strong>和<strong class="jq hj"> 21 </strong>行。第17行被添加到堆栈中并立即执行，将<code class="du mh mi mj mk b">‘1st log’</code>打印到控制台。随后，19号线和21号线跟进；将<code class="du mh mi mj mk b">‘2nd log’</code>和<code class="du mh mi mj mk b">‘3rd log’</code>按顺序打印到控制台。</p><p id="d073" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">现在是变得棘手的部分！我们如何处理在web API中倒数的那两个<code class="du mh mi mj mk b">setTimeout</code>?我们知道在定时器超时后，它们被推到任务队列中，但是按什么顺序呢？</p><p id="7eff" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">答案比你想象的要简单:<code class="du mh mi mj mk b">timer2</code>的延迟比<code class="du mh mi mj mk b">timer1</code>短，所以它先被添加到任务队列中！大约又过了一秒钟，<code class="du mh mi mj mk b">timer1</code>也被添加到任务队列中。自始至终，事件循环都在监视Javascript调用堆栈，等待其同步代码完成和堆栈清空。接下来，<code class="du mh mi mj mk b">timer2</code>从任务队列传递到调用堆栈并执行。它将<code class="du mh mi mj mk b">‘timer2 : 2 sec’</code>记录到控制台，一秒钟后将<code class="du mh mi mj mk b">‘timer1: 3 sec’</code>记录到控制台。就是这样！很简单，对吧？</p><h1 id="ad1b" class="kv kw hi bd kx ky kz la lb lc ld le lf io lg ip lh ir li is lj iu lk iv ll lm bi translated">旅程的结束</h1><p id="ffa0" class="pw-post-body-paragraph jo jp hi jq b jr ln ij jt ju lo im jw jx lp jz ka kb lq kd ke kf lr kh ki kj hb bi translated">下面是一些关于单步执行异步代码的要点:</p><ol class=""><li id="05b1" class="lt lu hi jq b jr js ju jv jx lv kb lw kf lx kj my lz ma mb bi translated">所有同步代码都在事件循环将任何语句从任务队列推送到调用堆栈之前执行。</li><li id="5338" class="lt lu hi jq b jr mc ju md jx me kb mf kf mg kj my lz ma mb bi translated">在web API中，两个计时器同时运行它们的倒计时。</li><li id="b3c3" class="lt lu hi jq b jr mc ju md jx me kb mf kf mg kj my lz ma mb bi translated">如果我们的代码长得多，那么<code class="du mh mi mj mk b">setTimeout</code>延迟可能会超过我们设置的2或3秒。这完全依赖于我们的主线程完成代码的时间。为此，最好将<code class="du mh mi mj mk b">setTimeout</code>延迟视为<em class="kt">至少2000ms </em>或<em class="kt">至少3000ms </em>(使用我们的示例代码作为参考)，而不是延迟等于总时间。这是因为<code class="du mh mi mj mk b">setTimeout</code>回调只有在满足两个条件后才被执行:首先，web API中的定时器已经到期。第二，调用栈是空的。如果主线程花了10秒来执行它的代码，我们的<code class="du mh mi mj mk b">setTimeout</code>回调将会等待比我们设置的延迟更长的时间。这意味着它们将在10秒的主线程代码完成后立即执行。</li></ol><p id="05ac" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">这个话题还有很多我们没有涉及到的内容，这确实是一个令人着迷的讨论。最终，我希望你远离这种进入调用堆栈、事件循环和异步代码的感觉，甚至少一点焦虑和不知所措。归根结底，它仍然只是Javascript。</p></div><div class="ab cl mz na gp nb" role="separator"><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne"/></div><div class="hb hc hd he hf"><h1 id="7578" class="kv kw hi bd kx ky ng la lb lc nh le lf io ni ip lh ir nj is lj iu nk iv ll lm bi translated">参考</h1><ul class=""><li id="b8bc" class="lt lu hi jq b jr ln ju lo jx nl kb nm kf nn kj ly lz ma mb bi translated"><a class="ae jn" href="https://www.youtube.com/watch?v=8zKuNo4ay8E" rel="noopener ugc nofollow" target="_blank">异步Javascript &amp;事件循环从头开始</a>，<em class="kt">阿克谢塞尼</em></li><li id="df28" class="lt lu hi jq b jr mc ju md jx me kb mf kf mg kj ly lz ma mb bi translated"><a class="ae jn" href="https://www.educative.io/edpresso/what-is-an-event-loop-in-javascript" rel="noopener ugc nofollow" target="_blank">JavaScript中什么是事件循环？</a>，<em class="kt"> Edpresso团队</em></li><li id="0b6b" class="lt lu hi jq b jr mc ju md jx me kb mf kf mg kj ly lz ma mb bi translated"><a class="ae jn" href="https://www.javascripttutorial.net/javascript-call-stack/" rel="noopener ugc nofollow" target="_blank">JavaScript调用栈介绍</a>，<em class="kt">JavaScript教程</em></li><li id="c959" class="lt lu hi jq b jr mc ju md jx me kb mf kf mg kj ly lz ma mb bi translated"><a class="ae jn" href="https://en.wikipedia.org/wiki/Stack_(abstract_data_type)#History" rel="noopener ugc nofollow" target="_blank">堆栈(抽象数据类型)</a>，<em class="kt">维基百科</em></li></ul></div></div>    
</body>
</html>