<html>
<head>
<title>Reverse a singly linked list</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">反转单向链表</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/reverse-a-singly-linked-list-c01ffdd3bf03?source=collection_archive---------18-----------------------#2021-07-27">https://medium.com/nerd-for-tech/reverse-a-singly-linked-list-c01ffdd3bf03?source=collection_archive---------18-----------------------#2021-07-27</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="463d" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">给定一个对单向链表头的引用，反转它并返回一个对反转链表头的引用。</h2></div><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ix"><img src="../Images/40515c04deef6cf17c9fcf578f9dd5a0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*w9MXYgZ3c_Swmmcr.jpg"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">"图片由<a class="ae jn" href="https://unsplash.com/@edge2edgemedia?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Edge2Edge 媒体</a>在<a class="ae jn" href="https://unsplash.com/s/photos/chain?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄"</figcaption></figure><p id="af1b" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">🔔这篇文章最初发布在我的网站上，<a class="ae jn" href="https://mihaibojin.com/coding-puzzles/linked-list/reverse-singly-linked-list?utm_source=Medium&amp;utm_medium=organic&amp;utm_campaign=top-promo" rel="noopener ugc nofollow" target="_blank">MihaiBojin.com</a>。🔔</p></div><div class="ab cl kk kl gp km" role="separator"><span class="kn bw bk ko kp kq"/><span class="kn bw bk ko kp kq"/><span class="kn bw bk ko kp"/></div><div class="hb hc hd he hf"><blockquote class="kr ks kt"><p id="3fc4" class="jo jp ku jq b jr js ij jt ju jv im jw kv jy jz ka kw kc kd ke kx kg kh ki kj hb bi translated">给定一个对单向链表头的引用，反转它并返回一个对反转链表头的引用。</p></blockquote><p id="d014" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">这是一个简单的问题，可以用几种方法解决。在本文中，我将用我所知道的最优雅的方式来解决它——在线性时间内就地解决。</p><p id="3bf2" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">注意:如果你不熟悉这个数据结构，<a class="ae jn" href="https://en.wikipedia.org/wiki/Linked_list#Singly_linked_list" rel="noopener ugc nofollow" target="_blank">参见维基百科关于链表的文章</a>。</p><h2 id="3730" class="ky kz hi bd la lb lc ld le lf lg lh li jx lj lk ll kb lm ln lo kf lp lq lr ls bi translated">一个简单的 LinkedList 实现</h2><p id="57e1" class="pw-post-body-paragraph jo jp hi jq b jr lt ij jt ju lu im jw jx lv jz ka kb lw kd ke kf lx kh ki kj hb bi translated">但是首先，让我们从一个简单的单链表实现开始。</p><pre class="iy iz ja jb fd ly lz ma mb aw mc bi"><span id="d117" class="ky kz hi lz b fi md me l mf mg">import java.util.*;<br/><br/>public class LinkedList&lt;T&gt; implements Iterable&lt;T&gt; {<br/>  private Node head;<br/>  private Node tail;<br/><br/>  public void add(T value) {<br/>    if (this.head != null) {<br/>      // the majority use-case: the head element exists<br/>      this.tail.next = new Node(value);<br/>      this.tail = this.tail.next;<br/>      return;<br/>    }<br/><br/>    initFirstElement(value);<br/>  }<br/><br/>  private void initFirstElement(T value) {<br/>    this.head = new Node(value);<br/>    this.tail = head;<br/>  }<br/><br/>  public void addAll(List&lt;T&gt; values) {<br/>    values.forEach(this::add);<br/>  }<br/><br/>  /**<br/>   * A singly linked list node<br/>   */<br/>  private class Node {<br/>    private T value;<br/>    private Node prev = null;<br/>    private Node next = null;<br/><br/>    private Node(T value) {<br/>      this.value = value;<br/>    }<br/>  }<br/>}</span></pre><p id="1486" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">上面的代码代表了一个非常简单的链表实现，它构成了我们问题的基础。</p><p id="4f24" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">在我们继续之前，我们可以让它变得更好一点。首先，我们需要按顺序检索列表的所有元素。</p><p id="7352" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">Java 惯用的方法是实现一个<code class="du mh mi mj lz b">Iterator</code>。</p><pre class="iy iz ja jb fd ly lz ma mb aw mc bi"><span id="4b60" class="ky kz hi lz b fi md me l mf mg">public class LinkedList&lt;T&gt; implements Iterable&lt;T&gt; {<br/>  // ...<br/><br/>  @Override<br/>  public Iterator&lt;T&gt; iterator() {<br/>    return new LinkedListIterator();<br/>  }<br/><br/>  /**<br/>   * Iterate over elements until none are left<br/>   */<br/>  private class LinkedListIterator implements Iterator&lt;T&gt; {<br/>    private Node cursor = LinkedList.this.head;<br/><br/>    @Override<br/>    public boolean hasNext() {<br/>      return cursor != null;<br/>    }<br/><br/>    @Override<br/>    public T next() {<br/>      try {<br/>        return cursor.value;<br/>      } finally {<br/>        cursor = cursor.next;<br/>      }<br/>    }<br/>  }<br/>}</span></pre><p id="b6f5" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">另一个好处是覆盖了<code class="du mh mi mj lz b">toString</code>方法，这样我们就可以打印出列表的元素:</p><pre class="iy iz ja jb fd ly lz ma mb aw mc bi"><span id="6fbb" class="ky kz hi lz b fi md me l mf mg">public class LinkedList&lt;T&gt; implements Iterable&lt;T&gt; {<br/>  // ...<br/><br/>  @Override<br/>  public String toString() {<br/>    List&lt;T&gt; results = new ArrayList&lt;&gt;();<br/>    Iterator&lt;T&gt; it = this.iterator();<br/>    while (it.hasNext()) {<br/>      results.add(it.next());<br/>    }<br/><br/>    return results.toString();<br/>  }<br/>}</span></pre><p id="c8d6" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">当然，在我们继续之前，让我们确保我们的自定义链表实现按预期工作。</p><p id="c5f7" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">对于下面的例子，我使用了<a class="ae jn" href="https://junit.org/junit5/docs/current/user-guide/" rel="noopener ugc nofollow" target="_blank"> JUnit 5 </a>和<a class="ae jn" href="http://hamcrest.org/JavaHamcrest/" rel="noopener ugc nofollow" target="_blank"> Hamcrest </a>，但是你可以随意替换它们。</p><pre class="iy iz ja jb fd ly lz ma mb aw mc bi"><span id="f7e5" class="ky kz hi lz b fi md me l mf mg">import java.util.List;<br/><br/>import static org.hamcrest.MatcherAssert.assertThat;<br/>import static org.hamcrest.Matchers.equalTo;<br/><br/>class LinkedListTest {<br/><br/>  @Test<br/>  void testLinkedListImplementation() {<br/>    // ARRANGE<br/>    List&lt;Integer&gt; input = List.of(1, 2, 3);<br/>    LinkedList&lt;Integer&gt; tested = new LinkedList&lt;&gt;();<br/><br/>    // ACT<br/>    tested.addAll(input);<br/>    String output = tested.toString();<br/><br/>    // ASSERT<br/>    assertThat("Expecting the same elements", output.toString(), equalTo(input.toString()));<br/>  }<br/><br/>  @Test<br/>  void testEmptyLinkedList() {<br/>    // ARRANGE<br/>    LinkedList&lt;Integer&gt; tested = new LinkedList&lt;&gt;();<br/><br/>    // ACT<br/>    String output = tested.toString();<br/><br/>    // ASSERT<br/>    assertThat("Expecting an empty list", output.toString(), equalTo(List.of().toString()));<br/>  }<br/>}</span></pre><h2 id="0632" class="ky kz hi bd la lb lc ld le lf lg lh li jx lj lk ll kb lm ln lo kf lp lq lr ls bi translated">解开谜题</h2><p id="eb70" class="pw-post-body-paragraph jo jp hi jq b jr lt ij jt ju lu im jw jx lv jz ka kb lw kd ke kf lx kh ki kj hb bi translated">解决这个问题的一个简单方法是遍历列表的所有元素，将它们添加到堆栈中，然后弹出它们。这种方法可行，但是它需要<code class="du mh mi mj lz b">O(N)</code>额外的空间。</p><p id="d282" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">如果您试图反转一个包含数百万元素的列表，您可能会耗尽堆空间。</p><p id="ae86" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">我们可以做得更好！</p><p id="328f" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">与大多数链表算法一样，您可以依赖两个游标:</p><ul class=""><li id="95ab" class="mk ml hi jq b jr js ju jv jx mm kb mn kf mo kj mp mq mr ms bi translated">第一个保持对反向列表中最后一个元素的引用</li><li id="9736" class="mk ml hi jq b jr mt ju mu jx mv kb mw kf mx kj mp mq mr ms bi translated">第二个保存了对原始列表的新头部的引用</li></ul><p id="b00f" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">一步一步地，我们将迭代原始列表，在我们前进的过程中构造它。最后，我们将只剩下对反向列表头部的引用。</p><p id="4eb0" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">让我们看看这是怎么回事！</p><pre class="iy iz ja jb fd ly lz ma mb aw mc bi"><span id="6f5d" class="ky kz hi lz b fi md me l mf mg">public class LinkedList&lt;T&gt; implements Iterable&lt;T&gt; {<br/>  // ...<br/><br/>  public LinkedList&lt;T&gt; reverse() {<br/>    // initialize references<br/>    Node newHead = null;<br/>    Node oldHead = this.head;<br/>    Node newTail = null;<br/><br/>    // while there are elements we haven't seen in the original list<br/>    while (oldHead != null) {<br/>      // keep a reference to the next element in the original list<br/>      Node next = oldHead.next;<br/><br/>      // change the direction of the elements<br/>      oldHead.next = newHead;<br/><br/>      // oldHead becomes newHead (the reversed list's head)<br/>      newHead = oldHead;<br/><br/>      // at this point, keep a reference to the reversed list's new tail<br/>      // we will need it later<br/>      if (newTail == null) {<br/>        newTail = newHead;<br/>      }<br/><br/>      // advance the read element, in the original list<br/>      oldHead = next;<br/>    }<br/><br/>    // construct the resulting linked list object<br/>    LinkedList&lt;T&gt; result = new LinkedList&lt;&gt;();<br/>    result.head = newHead;<br/>    result.tail = newTail;<br/>    return result;<br/>  }<br/>}</span></pre><p id="f40a" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">当然，我们还需要一个测试来确认解决方案是否有效:</p><pre class="iy iz ja jb fd ly lz ma mb aw mc bi"><span id="6192" class="ky kz hi lz b fi md me l mf mg">class LinkedListTest {<br/>  // ...<br/><br/>  @Test<br/>  void testReverseLinkedList() {<br/>    // ARRANGE<br/>    List&lt;Integer&gt; input = List.of(1, 2, 3);<br/>    LinkedList&lt;Integer&gt; tested = new LinkedList&lt;&gt;();<br/>    tested.addAll(input);<br/><br/>    List&lt;Integer&gt; expected = List.of(3, 2, 1);<br/><br/>    // ACT<br/>    String output = tested.reverse().toString();<br/><br/>    // ASSERT<br/>    assertThat("Expecting the same elements, in reverse order", output.toString(), equalTo(expected.toString()));<br/>  }<br/>}</span></pre><p id="225a" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">现在你有了:就地(没有额外的空间)、线性(只迭代一次输入)、单链表反转。</p><p id="dcc4" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">我希望你喜欢这个练习；与更简单的替代方案(使用堆栈)相比，这是一个更好的解决方案。</p><p id="9910" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">理解双指针概念是有效解决链表编码难题的关键。因此，我建议花点时间学习它，因为它肯定会派上用场！</p><p id="a5a7" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">如果您有任何问题或寻求任何建议，请(<a class="ae jn" href="https://twitter.com/mihaibojin" rel="noopener ugc nofollow" target="_blank">在 Twitter 上 DM 我</a>)！</p><p id="7cf4" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">直到下一次…</p></div><div class="ab cl kk kl gp km" role="separator"><span class="kn bw bk ko kp kq"/><span class="kn bw bk ko kp kq"/><span class="kn bw bk ko kp"/></div><div class="hb hc hd he hf"><p id="31cc" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">如果你喜欢这篇文章并想阅读更多类似的文章，<a class="ae jn" href="https://motivated-founder-807.ck.page/db1cf284bf" rel="noopener ugc nofollow" target="_blank">请订阅我的简讯</a>；我每隔几周就发一封！</p></div></div>    
</body>
</html>