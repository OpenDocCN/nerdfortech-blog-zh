# SQL 注入实践概述(1/2)

> 原文：<https://medium.com/nerd-for-tech/sql-injection-practical-overview-1-2-1da0407078ea?source=collection_archive---------12----------------------->

数据库一直以来就存在，大约 50 年前，许多项目被放在一起，并转化为今天所知的 SQL 或结构化查询语言。很多东西的出现只是为了得到我们今天所知道的数据库。

在实用之前，我们需要把 SQL 作为一门语言来谈。

您可能知道，SQL 不是一种产品，而是一种用于管理和从数据库获取数据的标准编程语言。SQL 是当今的 ISO 规范，许多产品都基于该规范。

SQL 套件作为:

1.  一种用于访问数据库的编程语言
2.  用于处理数据完整性和视图的数据定义语言
3.  一种动态的集成交易控制机制
4.  探索关系系统的灵活性和能力的机制
5.  一种控制数据寄存器集合而不是单个寄存器的方法

SQL 很多。我无法想象没有数据库的软件解决方案或产品，以及任何可用产品中没有 SQL 的情况。

今天，我们有更多的数据存储选择，但在 15 年前，这是不可想象的。SQL 是数据库中使用最多的语言，并且仍然被大量采用。

# SQLi

SQL 注入通常是通过 web 应用程序客户端的数据输入进行的 SQL 代码插入。这种插入可以在完全或部分模式下发现，并将导致访问数据库、获得权限以及获取数据或删除记录

基于您的后端代码实现和任何特权设置，您不仅可以访问数据库，还可以访问其他数据库。你可以执行基于操作系统的命令并控制你的系统。

这种攻击在 find 中非常常见，因为易于检测和利用，所以被列入 OWASP 前 10 名。如果数据库设置配置错误，影响将是巨大的

数据库是存储所有信息的地方，如果这一部分被破坏，你将有一个大问题。作为一个公司，你会赔钱和信誉是事实。黑客的动机是金钱，任何形式的数据窃取对他们来说都是后来的收入。

SQLi 可用于 DDoS，用于数据探索和操作，也可危及基础设施，其中:

1.  DDoS 可以通过注入一个`DROP TABLE` SQL 命令来实现，使整个系统因数据库不一致而不可用。
2.  通过进行数据探索，你可以了解数据库是如何构建的，检查任何内容，插入新用户，或任何想到的事情。
3.  损害基础设施可以通过多种方式完成，您可以加载一个 Webshell 工具，如`C99Shell`(如果您使用 PHP)，或者可能生成反向会话、执行远程连接等等。

## SQLi 类型

有两种类型的 **SQLi** 注射可供选择。**经典** **SQLi** 和**盲 SQLi，**的结果相同，但显示返回的数据不同。

**经典 SQLi** 基于字符输入或布尔表达式生成一个错误，该错误会生成一个通用或非通用的错误消息。通用消息不显示任何与操作系统或路由相关的 ID，也不显示错误细节，它只提示错误本身的名称。

另一方面，**盲 SQLi** 用于由于可能的注射而没有错误消息，并且网站代码执行(内部 SQL 查询)没有返回数据的情况。在这里，攻击者将尝试插入抛出布尔值 True 作为结果的查询，并尝试推断查询执行的信息类型。

当执行顺利时，它将显示预期的内容，而不是错误消息。

## 发送信息

如果你熟悉 web 开发(应该可以)，你应该已经知道有两种使用 **HTTP** 协议动词向服务器发送数据的方法，它们是`GET`和`POST`方法。

`POST`方法在内部发送信息，从 URL 看不到，可以以纯文本或任何编码方式发送。它可以由后端以简单的方式打印出来。这也可以被诸如 Burpsuite 之类的嗅探器捕获。

`GET`方法将信息作为查询字符串直接发送到 URL，也可以以纯文本或任何特定的编码技术发送。这里有一个例子

`process.php?name=David&lastname=Lares`

`name`和`lastname`都是标识符或易受攻击的参数(接下来解释)

## 评估脆弱参数

在 SQLi 中取得成功的关键是，作为攻击者，您必须找到(或识别出)一段代码，这段代码不能执行正确的输入参数验证，而这些输入参数是以某种方式用于组成数据库查询的。

通过引用输入参数，我们可以假设在客户端-服务器架构中，我们指的是环境的客户端。这意味着我们通过 HTML 表单或直接操作 URL，将来自客户端的任何输入集发送到后端。

当使用 **GET** 方法时，所有数据都是从 URL 发送的，您需要使用`“` (ASCII `%27`)来生成错误。

而且，当使用 **POST** 方法时，参数是不可见的，所以你需要使用类似`tamperdata`的工具，或者类似 **Burpsuite** 、 **Acunetix、**或 **Fitler** 的代理工具来识别易受攻击的参数。

我们来练习一下！

现在让我们测试一个已知的经典 SQLi。如果我们回忆一下，需要一个布尔表达式

这里有一个例子:

`SELECT * FROM users WHERE uname='$username' AND pwd='$password';`

`$username`和`$password`都是 PHP 变量，没有以任何方式进行净化或过滤，SQL 语句正在替换`uname`和`pwd`条件中的原始变量内容。

在这一点上看起来很正常，但是利用这种不确定的行为将需要一个布尔`True`语句。我们将修改我们的查询为:

```
$username = 1' or '1' = '1;
SELECT * FROM users WHERE uname='$username';
```

这可以看作是:

```
SELECT * FROM users WHERE uname= 1' or '1' = '1;
```

在 URL 中，`%20`被表示为`''`，这不是基于编码，而是一种发送字符串的方式。因此，此时`' or '1' = '1`将总是解析一个`True`语句，其中:

1.  第一个和第二个`'`标记了一个`OR` SQL 语句
2.  第三个和第四个`'`标志为`=`标志
3.  在真值表中`T or 1`将解析一个**真**语句。因此，1 或(`1 = 1`即**真**)将导致**真语句**

对于此 **GET** 示例，注入成功

对于**后**的场景，事情好像有点变化。对于像这样的手动场景，我们需要拦截请求，而 Burpsuite 代理是完美的工具。

1.  让我们将代理服务器与浏览器设置同步
2.  设定`Intercept IS ON`机构
3.  执行一个请求，看看 HTTP 主体和头发生了什么。
4.  编写您的查询修改并单击`FORWARD`继续提交请求执行。

这是最简单的 SQLi 示例。

这里还有一个:

```
$username = `; DROP TABLE users; --`
$password = `OR ``=`
```

致使

```
SELECT user_id FROM users where user_id = `;DROP TABLE user ; -- ` and password = ``OR`` = ``
```

我在这里的目标是向你解释事情是如何完成的，但是你可以随时参考`OTG-INPVAL-005`文件来获得提示和工作示例。

在下一部分，让我们认真对待工具

在那里见。