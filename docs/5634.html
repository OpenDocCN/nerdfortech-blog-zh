<html>
<head>
<title>Python vs C++ Series: Variable Scope</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python vs C++系列:可变范围</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/python-vs-c-series-variable-scope-cf6c1090923d?source=collection_archive---------7-----------------------#2021-10-25">https://medium.com/nerd-for-tech/python-vs-c-series-variable-scope-cf6c1090923d?source=collection_archive---------7-----------------------#2021-10-25</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="be4e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">每种编程语言都有自己定义作用域的方式，大部分都是类似的工作方式，都有类似的作用域级别，比如块作用域和函数作用域。本文是<a class="ae jd" rel="noopener" href="/nerd-for-tech/python-vs-c-series-getter-setter-and-property-e92d7801c21a"> Python与C++系列</a>的一部分，将重点关注对于C++背景的人来说不直观的特定Python范围规则。</p><p id="fce8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">(注意，本系列中的Python代码假设使用Python 3.7或更高版本)</p><h1 id="1419" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">C++中的变量范围</h1><p id="c8d0" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">C++中的作用域有几个级别，但一般有局部、全局和块作用域。</p><pre class="kh ki kj kk fd kl km kn ko aw kp bi"><span id="6c63" class="kq jf hi km b fi kr ks l kt ku">#include &lt;iostream&gt;<br/><br/>int global_variable = 0; // global variable<br/><br/>int myFunction(int parameter=0)<br/>{<br/>    // local variable can only be accessed within block.<br/>    int local_variable = 0;<br/><br/>    if (parameter &gt; 0)<br/>    {<br/>        local_variable += parameter;<br/>    }<br/>    else<br/>    {<br/>        // global variable can be accessed everywhere<br/>        local_variable += global_variable; <br/>    }<br/><br/>    // update the global variable within a function<br/>    global_variable = local_variable; <br/><br/>    return local_variable;<br/>}<br/><br/>double myFunction2()<br/>{<br/>    // local variable but has the same name as the global_variable.<br/>    // In this case, the local one takes higher priority.<br/>    double global_variable = 1.23;<br/>    return global_variable;<br/>}<br/><br/>void main()<br/>{<br/>    std::cout &lt;&lt; global_variable &lt;&lt; std::endl;<br/>    // 0     The global global_variable<br/>    std::cout &lt;&lt; myFunction(10) &lt;&lt; std::endl;<br/>    // 10    The local_variable<br/>    std::cout &lt;&lt; global_variable &lt;&lt; std::endl;<br/>    // 10    The global global_variable updated by myFunction()<br/>    std::cout &lt;&lt; myFunction2() &lt;&lt; std::endl;<br/>    // 1.23  The local global_variable inside myFunction2()<br/>    std::cout &lt;&lt; global_variable &lt;&lt; std::endl;<br/>    // 10    The global global_variable was not affected by myFunction2()<br/>}</span></pre><h1 id="dcb9" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">Python中的变量范围</h1><p id="76c6" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">Python也有几个作用域级别，其中大部分的工作方式类似于C++和许多其他语言。然而，正如前一篇文章中所讨论的那样(<a class="ae jd" rel="noopener" href="/nerd-for-tech/python-vs-c-series-mutable-immutable-and-copy-assignment-d95c0ea73879">可变、不可变和复制赋值</a>)，复制赋值并不创建新对象；相反，它绑定到一个对象。因此，在Python中使用赋值操作符又引出了另一个问题:赋值是创建一个新的对象来绑定，还是只是更新绑定到另一个对象，又是哪个呢？</p><p id="7879" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">根据官方文档— <a class="ae jd" href="https://docs.python.org/3/tutorial/classes.html#python-scopes-and-namespaces" rel="noopener ugc nofollow" target="_blank"> Python作用域和名称空间</a>，命名变量的搜索顺序如下(引用自<a class="ae jd" href="https://docs.python.org/3/tutorial/classes.html#python-scopes-and-namespaces" rel="noopener ugc nofollow" target="_blank">文档</a>)</p><ul class=""><li id="9abf" class="kv kw hi ih b ii ij im in iq kx iu ky iy kz jc la lb lc ld bi translated">首先搜索的最内层范围包含本地名称</li><li id="3be0" class="kv kw hi ih b ii le im lf iq lg iu lh iy li jc la lb lc ld bi translated">任何封闭函数的作用域(从最近的封闭作用域开始搜索)都包含非局部名称，但也包含非全局名称</li><li id="f8f5" class="kv kw hi ih b ii le im lf iq lg iu lh iy li jc la lb lc ld bi translated">倒数第二个范围包含当前模块的全局名称</li><li id="a4b3" class="kv kw hi ih b ii le im lf iq lg iu lh iy li jc la lb lc ld bi translated">最外层的范围(最后搜索的)是包含内置名称的名称空间</li></ul><p id="7ec9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">由于这个规则，一些非直觉的情况发生了，我们将在下面的小节中讨论这些情况。</p><h1 id="0c52" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">控制语句</h1><p id="6a1f" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">上面提到的搜索顺序不包括<em class="lj"> if语句</em>等控制语句。因此，下面的代码是有效的和可行的。</p><pre class="kh ki kj kk fd kl km kn ko aw kp bi"><span id="ce62" class="kq jf hi km b fi kr ks l kt ku"># if-statement does not define a scope<br/>condition = True<br/>if condition:<br/>    result = 1<br/>else:<br/>    result = 2<br/><br/>print(result)<br/># 1<!-- --> </span></pre><p id="0a30" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">同样，<em class="lj"> for-loop </em>(和<em class="lj"> while-loop </em>)，<em class="lj"> with-statement，</em>和<em class="lj"> try-except </em>也没有定义作用域。</p><pre class="kh ki kj kk fd kl km kn ko aw kp bi"><span id="fbf0" class="kq jf hi km b fi kr ks l kt ku"># for-loop does not define a scope<br/>for i in range(10):<br/>    x = 1 + i<br/><br/>print(x)<br/># 10<br/><br/># with-statement does not define a scope<br/>with open("example.txt") as file:<br/>    data = file.read()<br/><br/>print(data)<br/># Output from the example.txt<br/><br/><br/># try-except does not define a scope<br/>try:<br/>    raise ValueError("Test exception")<br/><br/>except ValueError:<br/>    message = "Catch an exception"<br/><br/>print(message)<br/># Catch an exception</span></pre><h1 id="4e84" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">全局变量</h1><p id="77b1" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">第二种情况发生在使用全局变量时。正如我们所料，我们可以从任何地方访问一个全局变量。</p><pre class="kh ki kj kk fd kl km kn ko aw kp bi"><span id="cf34" class="kq jf hi km b fi kr ks l kt ku">global_variable = [1, 2, 3]   # global variable<br/><br/>def function1():<br/>    print(global_variable)<br/>    # [1, 2, 3]<br/><br/>function1()</span></pre><p id="eddf" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">然而，如果我们试图从函数或内部作用域更新全局变量，行为就会改变。举个例子，</p><pre class="kh ki kj kk fd kl km kn ko aw kp bi"><span id="2419" class="kq jf hi km b fi kr ks l kt ku">global_variable = [1, 2, 3]   # global variable<br/><br/>def function2():<br/>    global_variable = [2, 3, 4]   # local variable<br/>    print(global_variable)<br/>    # [2, 3, 4]<br/>    print(hex(id(global_variable)))<br/>    # 0x7f32763a4780<br/><br/>function2()<br/>print(global_variable)<br/># [1, 2, 3]<br/>print(hex(id(global_variable)))<br/># 0x7f32763f7880</span></pre><p id="8a9a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在这个例子中，当我们将<em class="lj"> function2 </em>中的<em class="lj"> global_variable </em>的值设置为<em class="lj">【2，3，4】</em>时，实际上是在<em class="lj"> function2 </em>的范围内创建了一个新的局部对象进行绑定，并不影响全局<em class="lj"> global_variable </em>的任何内容。我们还可以使用内置函数<a class="ae jd" href="https://docs.python.org/3/library/functions.html#id" rel="noopener ugc nofollow" target="_blank"> id </a>来验证两个<em class="lj"> global_variable </em>变量是不同的对象(参见示例输出)。</p><p id="9693" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">全局关键字</strong></p><p id="c72d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果在Python的函数中为变量赋值，默认情况下，它是一个局部变量。如果我们想在内部作用域(如function)中访问一个全局变量，我们必须使用<a class="ae jd" href="https://docs.python.org/3/reference/lexical_analysis.html#keywords" rel="noopener ugc nofollow" target="_blank"> global </a>关键字，并用它显式声明该变量。请参见下面的示例。</p><pre class="kh ki kj kk fd kl km kn ko aw kp bi"><span id="3977" class="kq jf hi km b fi kr ks l kt ku">global_variable = [1, 2, 3]   # global variable<br/><br/>def function3():<br/>    global global_variable<br/>    global_variable = [3, 4, 5]<br/>    print(global_variable)<br/>    # [3, 4, 5]<br/>    print(hex(id(global_variable)))<br/>    # 0x7f32763a4780<br/><br/>function3()<br/>print(global_variable)<br/># [3, 4, 5]<br/>print(hex(id(global_variable)))<br/># 0x7f32763a4780</span></pre><p id="0d23" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这次，<em class="lj"> global </em>关键字告诉我们<em class="lj"> function3 </em>中的<em class="lj"> global_variable </em>与global <em class="lj"> global_variable </em>绑定在一起，它们的地址显示它们是同一个对象。</p><p id="6cea" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">此外，我们还可以使用<em class="lj"> global </em>关键字从函数或内部作用域定义一个全局变量。</p><pre class="kh ki kj kk fd kl km kn ko aw kp bi"><span id="3316" class="kq jf hi km b fi kr ks l kt ku">def function4():<br/>    global new_global_variable<br/>    new_global_variable = "A new global variable"<br/>    print(new_global_variable)<br/>    # A new global variable<br/>    print(hex(id(new_global_variable)))<br/>    # 0x7f32763a25d0<br/><br/>function4()<br/>print(new_global_variable)<br/># A new global variable<br/>print(hex(id(new_global_variable)))<br/># 0x7f32763a25d0</span></pre><p id="5832" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在<em class="lj"> function4 </em>中，我们用<em class="lj"> global </em>关键字定义了<em class="lj"> new_global_variable </em>，然后我们就可以从<em class="lj"> function4 </em>外部访问它了。</p><h1 id="627a" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">嵌套函数和非局部关键字</h1><p id="bcac" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">Python提供了另一个关键字<a class="ae jd" href="https://docs.python.org/3/reference/lexical_analysis.html#keywords" rel="noopener ugc nofollow" target="_blank">非局部</a>，我们可以在嵌套函数中使用它。正如<a class="ae jd" href="https://docs.python.org/3/tutorial/classes.html#python-scopes-and-namespaces" rel="noopener ugc nofollow" target="_blank">命名变量</a>的搜索顺序规则所述，将首先搜索最里面的范围。因此，在嵌套函数的情况下，内部函数不能更新外部变量。</p><pre class="kh ki kj kk fd kl km kn ko aw kp bi"><span id="dbbb" class="kq jf hi km b fi kr ks l kt ku">def outer_function1():<br/>    variable = 1<br/><br/>    def inner_function1():<br/>        variable = 2<br/>        print(f"inner_function: {variable}")<br/><br/>    inner_function1()<br/>    print(f"outer_function: {variable}")<br/><br/>outer_function1()<br/># The output of the variable:<br/># inner_function: 2<br/># outer_function: 1</span></pre><p id="fe43" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">正如我们所料，<em class="lj"> inner_function1 </em>中的<em class="lj">变量</em>与<em class="lj"> outer_function1 </em>中的<em class="lj">变量</em>是不同的对象。</p><p id="cc57" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在，让我们使用<em class="lj">非本地</em>关键字。关键字使变量引用最近范围内以前绑定的变量，并防止变量进行本地绑定。</p><pre class="kh ki kj kk fd kl km kn ko aw kp bi"><span id="31d0" class="kq jf hi km b fi kr ks l kt ku">def outer_function2():<br/>    variable = 1<br/><br/>    def inner_function2():<br/>        nonlocal variable<br/>        variable = 2<br/>        print(f"inner_function: {variable}")<br/><br/>    inner_function2()<br/>    print(f"outer_function: {variable}")<br/><br/>outer_function2()<br/># The output of the variable:<br/># inner_function: 2<br/># outer_function: 2</span></pre><p id="84b3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="lj"> inner_function2 </em>中的<em class="lj">变量</em>与<em class="lj"> outer_function2 </em>中的<em class="lj">变量</em>绑定。</p><p id="8dfa" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">全局与非局部</strong></p><p id="ef1b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="lj">全局</em>和<em class="lj">非本地</em>的主要区别在于，<em class="lj">非本地</em>关键字只允许访问本地范围之外的下一个最近的范围，而<em class="lj">全局</em>关键字允许访问全局范围。</p><p id="35b5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">下面的例子有三层嵌套函数，我们在最内层使用了<em class="lj">非局部</em>关键字。最内层<em class="lj">函数</em>中变量<em class="lj"> x </em>的变化只影响下一个最接近的作用域<em class="lj">内层</em>函数中的变量x。</p><pre class="kh ki kj kk fd kl km kn ko aw kp bi"><span id="40f5" class="kq jf hi km b fi kr ks l kt ku">x = "hello world"<br/><br/>def outer_nonlocal():<br/><br/>    x = 0<br/><br/>    def inner():<br/><br/>        x = 1<br/><br/>        def innermost():<br/>            nonlocal x<br/>            x = 2<br/>            print(f"innermost: {x}")<br/><br/>        innermost()<br/>        print(f"inner: {x}")<br/><br/>    inner()<br/>    print(f"outer_nonlocal: {x}")<br/><br/>outer_nonlocal()<br/>print(f"global: {x}")<br/># The output of x:<br/># innermost: 2<br/># inner: 2<br/># outer_nonlocal: 0<br/># global: hello world</span></pre><p id="0fd3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">关于<em class="lj">全局</em>关键字，在<em class="lj">最里面的</em>函数中使用<em class="lj">全局</em>关键字的例子允许访问全局变量<em class="lj">y</em>；中间的变量<em class="lj"> y </em>(即<em class="lj"> outer_global </em>函数和<em class="lj"> inner </em>函数)不受影响。</p><pre class="kh ki kj kk fd kl km kn ko aw kp bi"><span id="7c30" class="kq jf hi km b fi kr ks l kt ku">y = "hello world"<br/><br/>def outer_global():<br/><br/>    y = 0<br/><br/>    def inner():<br/><br/>        y = 1<br/><br/>        def innermost():<br/>            global y<br/>            y = 2<br/>            print(f"innermost: {y}")<br/><br/>        innermost()<br/>        print(f"inner: {y}")<br/><br/>    inner()<br/>    print(f"outer_global: {y}")<br/><br/>outer_global()<br/>print(f"global: {y}")<br/># The output of y:<br/># innermost: 2<br/># inner: 1<br/># outer_global: 0<br/># global: 2</span></pre><h1 id="f845" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">结论</h1><p id="d3a3" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">范围是编程语言的一个基本概念，大多数编程语言的工作方式都类似。然而，由于Python中赋值操作符的工作方式以及命名变量规则的搜索顺序，在某些情况下Python作用域的工作方式与C++非常不同。了解这个缺陷对于避免编写错误代码至关重要。</p><p id="83c5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">(所有示例代码也可在<a class="ae jd" href="https://github.com/shunsvineyard/shunsvineyard/tree/main/python_vs_cpp_series/variable_scope" rel="noopener ugc nofollow" target="_blank">变量范围</a>获得)</p></div><div class="ab cl lk ll gp lm" role="separator"><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp"/></div><div class="hb hc hd he hf"><p id="ee16" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="lj">原载于2021年10月25日</em><a class="ae jd" href="https://shunsvineyard.info/2021/10/24/python-vs-c-series-variable-scope/" rel="noopener ugc nofollow" target="_blank"><em class="lj">https://shunsvineyard . info</em></a><em class="lj">。</em></p></div></div>    
</body>
</html>