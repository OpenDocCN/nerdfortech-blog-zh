<html>
<head>
<title>LeetCode — Trapping rain water</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">leet code——收集雨水</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/leetcode-trapping-rain-water-446bcdf58d8f?source=collection_archive---------3-----------------------#2021-12-19">https://medium.com/nerd-for-tech/leetcode-trapping-rain-water-446bcdf58d8f?source=collection_archive---------3-----------------------#2021-12-19</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><h1 id="b992" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">问题陈述</h1><p id="4269" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">给定代表高程图的<em class="kb"> n </em>个非负整数，其中每个条形的宽度为<em class="kb"> 1 </em>，计算雨后它可以收集多少水。</p><p id="aa58" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated">问题陈述摘自:【https://leetcode.com/problems/trapping-rain-water<a class="ae kh" href="https://leetcode.com/problems/trapping-rain-water" rel="noopener ugc nofollow" target="_blank">。</a></p><p id="6320" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated"><strong class="jf hj">例 1: </strong></p><figure class="kj kk kl km fd kn er es paragraph-image"><div class="er es ki"><img src="../Images/1d83a16e54e9a6358d3b92182d7a4919.png" data-original-src="https://miro.medium.com/v2/resize:fit:824/format:webp/0*2U-pLHM7IDYpKkkg.png"/></div></figure><pre class="kj kk kl km fd kq kr ks kt aw ku bi"><span id="ee6c" class="kv ig hi kr b fi kw kx l ky kz">Input: height = [0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1]<br/>Output: 6<br/>Explanation: The above elevation map (black section) is represented by array [0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1]. In this case, 6 units of rain water (blue section) are being trapped.</span></pre><p id="aaad" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated"><strong class="jf hj">例 2: </strong></p><pre class="kj kk kl km fd kq kr ks kt aw ku bi"><span id="7ffc" class="kv ig hi kr b fi kw kx l ky kz">Input: height = [4, 2, 0, 3, 2, 5] <br/>Output: 9</span></pre><p id="acad" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated"><strong class="jf hj">约束:</strong></p><pre class="kj kk kl km fd kq kr ks kt aw ku bi"><span id="0d80" class="kv ig hi kr b fi kw kx l ky kz">- n == height.length <br/>- 1 &lt;= n &lt;= 2 * 10^4 <br/>- 0 &lt;= height[i] &lt;= 10^5</span></pre><h1 id="130b" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">说明</h1><h2 id="8622" class="kv ig hi bd ih la lb lc il ld le lf ip jo lg lh it js li lj ix jw lk ll jb lm bi translated">强力方法</h2><p id="bedf" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">最简单的解决方案是计算阵列的每个元素可以存储的最大水位。它等于两边条形的最小-最大高度减去它的高度。</p><p id="0e0a" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated">上述方法的 C++代码片段如下所示:</p><pre class="kj kk kl km fd kq kr ks kt aw ku bi"><span id="97f2" class="kv ig hi kr b fi kw kx l ky kz">int maxWater(int arr[], int n) {<br/>    int res = 0;<br/><br/>    for (int i = 1; i &lt; n - 1; i++) {<br/><br/>        int left = arr[i];<br/>        for (int j = 0; j &lt; i; j++)<br/>           left = max(left, arr[j]);<br/><br/>        int right = arr[i];<br/>        for (int j = i + 1; j&lt;n; j++)<br/>           right = max(right, arr[j]);<br/><br/>        res = res + (min(left, right) - arr[i]);<br/>    }<br/>    return res;<br/>}</span></pre><p id="9061" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated">上述方法的时间复杂度是<strong class="jf hj"> O(N ) </strong>，因为我们使用了两个嵌套的 for 循环。空间复杂度为<strong class="jf hj"> O(1) </strong>。</p><h2 id="a073" class="kv ig hi bd ih la lb lc il ld le lf ip jo lg lh it js li lj ix jw lk ll jb lm bi translated">动态规划方法</h2><p id="c25f" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">在蛮力方法中，我们反复迭代数组的左右部分来计算蓄水量。但是我们可以存储这个最大值。</p><p id="ba47" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated">我们创建了两个名为 left 和 right 的数组。我们在迭代数组时不断更新最大左侧和最大右侧。</p><p id="a5f5" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated">为了计算最终结果，我们使用下面的公式:</p><pre class="kj kk kl km fd kq kr ks kt aw ku bi"><span id="9da4" class="kv ig hi kr b fi kw kx l ky kz">ans += min(left_max[i], right_max[i]) - height[i]</span></pre><p id="76e2" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated">上述方法的一个 C++片段如下所示:</p><pre class="kj kk kl km fd kq kr ks kt aw ku bi"><span id="3916" class="kv ig hi kr b fi kw kx l ky kz">int ans = 0;<br/>int size = height.size();<br/><br/>vector&lt;int&gt; left_max(size), right_max(size);<br/>left_max[0] = height[0];<br/><br/>for (int i = 1; i &lt; size; i++) {<br/>    left_max[i] = max(height[i], left_max[i - 1]);<br/>}<br/><br/>right_max[size - 1] = height[size - 1];<br/><br/>for (int i = size - 2; i &gt;= 0; i--) {<br/>    right_max[i] = max(height[i], right_max[i + 1]);<br/>}<br/><br/>for (int i = 1; i &lt; size - 1; i++) {<br/>    ans += min(left_max[i], right_max[i]) - height[i];<br/>}<br/>return ans;</span></pre><p id="e08c" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated">该方法的时间复杂度为 O(N) 。我们使用了左右两个数组，所以这种方法的空间复杂度是<strong class="jf hj"> O(N) </strong>。</p><h2 id="23b1" class="kv ig hi bd ih la lb lc il ld le lf ip jo lg lh it js li lj ix jw lk ll jb lm bi translated">空间优化动态规划方法。</h2><p id="e410" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">我们可以通过使用两个简单的变量而不是两个数组来优化上面的解决方案。可以使用以下公式计算在任何元件处截留的水:</p><pre class="kj kk kl km fd kq kr ks kt aw ku bi"><span id="b0eb" class="kv ig hi kr b fi kw kx l ky kz">ans += min(max_left, max_right) - arr[i]</span></pre><p id="90f7" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated">我们可以相应地移动左指针和右指针。</p><p id="c2b9" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated">让我们检查算法:</p><pre class="kj kk kl km fd kq kr ks kt aw ku bi"><span id="ff69" class="kv ig hi kr b fi kw kx l ky kz">- set low = 0, high = height.size() - 1, res = 0<br/>  set low_max = 0, high_max = 0<br/><br/>- loop while low &lt;= high<br/>  - if height[low] &lt; height[high]<br/>    - if height[low] &gt; low_max<br/>      - set low_max = height[low]<br/>    - else<br/>      - update res += low_max - height[low]<br/>    - update low++<br/>  - else<br/>    - if height[high] &gt; high_max<br/>      - set high_max = height[high]<br/>    - else<br/>      - update res += high_max - height[high]<br/>    - update high--<br/><br/>- return res</span></pre><h2 id="977a" class="kv ig hi bd ih la lb lc il ld le lf ip jo lg lh it js li lj ix jw lk ll jb lm bi translated">C++解决方案</h2><pre class="kj kk kl km fd kq kr ks kt aw ku bi"><span id="21e1" class="kv ig hi kr b fi kw kx l ky kz">class Solution {<br/>public:<br/>    int trap(vector&lt;int&gt;&amp; height) {<br/>        int low = 0, high = height.size() - 1, res = 0;<br/>        int low_max = 0, high_max = 0;<br/><br/>        while(low &lt;= high){<br/>            if(height[low] &lt; height[high]){<br/>                if (height[low] &gt; low_max){<br/>                    low_max = height[low];<br/>                } else {<br/>                    res += low_max - height[low];<br/>                }<br/>                low++;<br/>            } else {<br/>                if (height[high] &gt; high_max){<br/>                    high_max = height[high];<br/>                } else {<br/>                    res += high_max - height[high];<br/>                }<br/>                high--;<br/>            }<br/>        }<br/><br/>        return res;<br/>    }<br/>};</span></pre><h2 id="aca6" class="kv ig hi bd ih la lb lc il ld le lf ip jo lg lh it js li lj ix jw lk ll jb lm bi translated">戈朗溶液</h2><pre class="kj kk kl km fd kq kr ks kt aw ku bi"><span id="132d" class="kv ig hi kr b fi kw kx l ky kz">func trap(height []int) int {<br/>    low, high, res := 0, len(height) - 1, 0<br/>    low_max, high_max := 0, 0<br/><br/>    for low &lt;= high {<br/>        if height[low] &lt; height[high] {<br/>            if height[low] &gt; low_max {<br/>                low_max = height[low]<br/>            } else {<br/>                res += low_max - height[low]<br/>            }<br/>            low++<br/>        } else {<br/>            if height[high] &gt; high_max {<br/>                high_max = height[high]<br/>            } else {<br/>                res += high_max - height[high]<br/>            }<br/>            high--<br/>        }<br/>    }<br/><br/>    return res<br/>}</span></pre><h2 id="e312" class="kv ig hi bd ih la lb lc il ld le lf ip jo lg lh it js li lj ix jw lk ll jb lm bi translated">Javascript 解决方案</h2><pre class="kj kk kl km fd kq kr ks kt aw ku bi"><span id="b607" class="kv ig hi kr b fi kw kx l ky kz">var trap = function(height) {<br/>    let low = 0, high = height.length - 1, res = 0;<br/>    let low_max = 0, high_max = 0;<br/><br/>    while( low &lt;= high ) {<br/>        if( height[low] &lt; height[high] ) {<br/>           if( height[low] &gt; low_max ) {<br/>               low_max = height[low];<br/>           } else {<br/>               res += low_max - height[low];<br/>           }<br/><br/>           low++;<br/>        } else {<br/>            if( height[high] &gt; high_max ) {<br/>                high_max = height[high];<br/>            } else {<br/>                res += high_max - height[high];<br/>            }<br/><br/>            high--;<br/>        }<br/>    }<br/><br/>    return res;<br/>};</span></pre><p id="b269" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated">让我们试运行一下我们的算法，看看解决方案是如何工作的。</p><pre class="kj kk kl km fd kq kr ks kt aw ku bi"><span id="be11" class="kv ig hi kr b fi kw kx l ky kz">Input: height = [4, 2, 0, 3, 2, 5]<br/><br/>Step 1: int low = 0, high = height.size() - 1, res = 0<br/>        low = 0, high = 5, res = 0<br/>        int low_max = 0, high_max = 0<br/><br/>Step 2: loop while low &lt;= high<br/>        0 &lt;= 5<br/>        true<br/><br/>        if height[low] &lt; height[high]<br/>           height[0] &lt; height[5]<br/>           4 &lt; 5<br/>           true<br/><br/>           if height[low] &gt; low_max<br/>              height[0] &gt; 0<br/>              4 &gt; 0<br/>              true<br/><br/>              set low_max = height[low]<br/>                          = height[0]<br/>                          = 4<br/><br/>        low++<br/>        low = 1<br/><br/>Step 3: loop while low &lt;= high<br/>        1 &lt;= 5<br/>        true<br/><br/>        if height[low] &lt; height[high]<br/>           height[1] &lt; height[5]<br/>           2 &lt; 5<br/>           true<br/><br/>           if height[low] &gt; low_max<br/>              height[1] &gt; 4<br/>              2 &gt; 4<br/>              false<br/><br/>              res = res + low_max - height[low]<br/>                  = 0 + 4 - 2<br/>                  = 2<br/><br/>        low++<br/>        low = 2<br/><br/>Step 4: loop while low &lt;= high<br/>        2 &lt;= 5<br/>        true<br/><br/>        if height[low] &lt; height[high]<br/>           height[2] &lt; height[5]<br/>           0 &lt; 5<br/>           true<br/><br/>            if height[low] &gt; low_max<br/>               height[2] &gt; 4<br/>               0 &gt; 4<br/>               false<br/><br/>               res = res + low_max - height[low]<br/>                   = 2 + 4 - 0<br/>                   = 6<br/><br/>        low++<br/>        low = 3<br/><br/>Step 5: loop while low &lt;= high<br/>        3 &lt;= 5<br/>        true<br/><br/>        if height[low] &lt; height[high]<br/>           height[3] &lt; height[5]<br/>           3 &lt; 5<br/>           true<br/><br/>           if height[low] &gt; low_max<br/>              height[3] &gt; 4<br/>              3 &gt; 4<br/>              false<br/><br/>              res = res + low_max - height[low]<br/>                   = 6 + 4 - 3<br/>                   = 7<br/><br/>        low++<br/>        low = 4<br/><br/>Step 6: loop while low &lt;= high<br/>        4 &lt;= 5<br/>        true<br/><br/>        if height[low] &lt; height[high]<br/>           height[4] &lt; height[5]<br/>           2 &lt; 5<br/>           true<br/><br/>           if height[low] &gt; low_max<br/>              height[4] &gt; 4<br/>              2 &gt; 4<br/>              false<br/><br/>              res = res + low_max - height[low]<br/>                   = 7 + 4 - 2<br/>                   = 9<br/><br/>        low++<br/>        low = 5<br/><br/>Step 7: loop while low &lt;= high<br/>        5 &lt;= 5<br/>        true<br/><br/>        if height[low] &lt; height[high]<br/>           height[5] &lt; height[5]<br/>           5 &lt; 5<br/>           false<br/><br/>           if height[high] &gt; high_max<br/>              height[5] &gt; 0<br/>              5 &gt; 0<br/>              true<br/><br/>              high_max = height[high]<br/>                       = height[5]<br/>                       = 5<br/><br/>        high--<br/>        high = 4<br/><br/>Step 8: loop while low &lt;= high<br/>        5 &lt;= 4<br/>        false<br/><br/>Step 9: return res<br/><br/>So the answer we return is 9.</span></pre></div><div class="ab cl ln lo gp lp" role="separator"><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls"/></div><div class="hb hc hd he hf"><p id="f370" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated"><em class="kb">原载于</em><a class="ae kh" href="https://alkeshghorpade.me/post/leetcode-trapping-rain-water" rel="noopener ugc nofollow" target="_blank"><em class="kb">https://alkeshghorpade . me</em></a><em class="kb">。</em></p></div></div>    
</body>
</html>