<html>
<head>
<title>From Hex to Color and Back in SwiftUI</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">SwiftUI 中从 Hex 到 Color 的转换</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/from-hex-to-color-and-back-in-swiftui-b2398da68a29?source=collection_archive---------4-----------------------#2022-04-23">https://medium.com/nerd-for-tech/from-hex-to-color-and-back-in-swiftui-b2398da68a29?source=collection_archive---------4-----------------------#2022-04-23</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="68d7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Bart Jacobs 写了一篇从 Hex 到 UIColor 再回到 Swift 的精彩文章，我的文章基于他的工作。我想知道如何在 SwiftUI 中用它的<code class="du je jf jg jh b">Color</code>结构实现同样的功能。</p><h1 id="d9e1" class="ji jj hi bd jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf bi translated">SwiftUI 中从十六进制到彩色</h1><p id="c1bf" class="pw-post-body-paragraph if ig hi ih b ii kg ik il im kh io ip iq ki is it iu kj iw ix iy kk ja jb jc hb bi translated">你不需要 UIKit 来做这个。创建一个扩展，使用一个<code class="du je jf jg jh b">Foundation</code>字符串解析器从十六进制表示中扫描一个<em class="kl"> long long 值</em>，最后在底层<code class="du je jf jg jh b">CGColor</code>的帮助下初始化<code class="du je jf jg jh b">Color</code>。</p><figure class="kn ko kp kq fd kr er es paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="er es km"><img src="../Images/2885f1e35a4599659305aeb74317b1eb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*X1B3rO1ixAiI1KR1MqRtZQ.png"/></div></div><figcaption class="ky kz et er es la lb bd b be z dx translated">扩展“在 SwiftUI 中从十六进制到彩色”</figcaption></figure><p id="5c8d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">与 Barts 的文章有两点不同:</p><ul class=""><li id="07ba" class="lc ld hi ih b ii ij im in iq le iu lf iy lg jc lh li lj lk bi translated">这里我用了<code class="du je jf jg jh b">UInt64</code>和<code class="du je jf jg jh b">scanHexInt32</code>，因为<code class="du je jf jg jh b">scanHexInt32</code>在 iOS 13 中已经被弃用了</li><li id="2e3c" class="lc ld hi ih b ii ll im lm iq ln iu lo iy lp jc lh li lj lk bi translated">这里我使用了<code class="du je jf jg jh b">Color</code>初始化器，并将 alpha 作为不透明度传递(在<code class="du je jf jg jh b">Color</code>的初始化器中没有<code class="du je jf jg jh b">alpha</code>参数)。我可以避免使用 UIKit:)</li></ul><p id="5de8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">备注:也可以用核心图形表示初始化<code class="du je jf jg jh b">Color</code>。请注意，您必须使用<code class="du je jf jg jh b">init(srgbRed:green:blue:alpha:)</code>而不是<code class="du je jf jg jh b">init(red:green:blue:alpha:)</code>，因为<strong class="ih hj"> iOS 使用 sRGB 色彩空间</strong>。</p><h1 id="113e" class="ji jj hi bd jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf bi translated">SwiftUI 中从颜色到十六进制</h1><p id="fccd" class="pw-post-body-paragraph if ig hi ih b ii kg ik il im kh io ip iq ki is it iu kj iw ix iy kk ja jb jc hb bi translated">根据苹果的文档，我希望通过可选的实例属性<code class="du je jf jg jh b">cgColor</code>直接利用<code class="du je jf jg jh b">Color</code>中颜色<em class="kl">的核心图形表示。</em></p><blockquote class="lq lr ls"><p id="8813" class="if ig kl ih b ii ij ik il im in io ip lt ir is it lu iv iw ix lv iz ja jb jc hb bi translated"><em class="hi">你可以从一个常量 SwiftUI color 得到一个 CGColor 实例。这包括从核心图形颜色、从 RGB 或 HSB 组件或从常量 UIKit 和 AppKit 颜色创建的颜色。对于动态颜色，例如使用 init(_:bundle:)从资产目录中加载的颜色，或者从动态 UIKit 或 AppKit 颜色中创建的颜色，此属性为零。</em></p></blockquote><p id="d12f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">然而，在我的测试中，属性总是<code class="du je jf jg jh b">nil</code>。即使是像<code class="du je jf jg jh b">Color.blue</code>这样的恒定 SwiftUI 颜色。</p><p id="b138" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">需要 ui kit</strong>来确保获得底层核心图形表示。一旦我们从<code class="du je jf jg jh b">Color</code>创建了<code class="du je jf jg jh b">UIColor</code>，那么访问核心图形表示和颜色组件就很容易了。如果您想了解更多关于这里使用的字符串格式化程序的信息，请阅读 Bart 的文章。</p><figure class="kn ko kp kq fd kr er es paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="er es km"><img src="../Images/1e0681d14fd8cb743f8beba07140075c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iDgjKlzAWJqtOjroTBzJ1w.png"/></div></div><figcaption class="ky kz et er es la lb bd b be z dx translated">SwiftUI 中“从颜色到十六进制”的扩展</figcaption></figure><p id="508c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">没有 UIKit，也可以从十六进制字符串创建一个<code class="du je jf jg jh b">Color</code>实例。但是你需要用<code class="du je jf jg jh b">UIKit</code>作为桥接机制来从<code class="du je jf jg jh b">Color</code>实例创建一个十六进制字符串。</p><p id="5c80" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这两个扩展很好地工作，并产生相同的视觉颜色，如下所示。</p><figure class="kn ko kp kq fd kr er es paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="er es lw"><img src="../Images/17a14a65670fd8919b7984ebe2f00123.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Viu8taaOGk-izQxH"/></div></div></figure></div><div class="ab cl lx ly gp lz" role="separator"><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc"/></div><div class="hb hc hd he hf"><p id="52da" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="kl">原发布于</em><a class="ae jd" href="https://blog.eidinger.info/from-hex-to-color-and-back-in-swiftui" rel="noopener ugc nofollow" target="_blank"><em class="kl">https://blog . eidinger . info</em></a><em class="kl">。</em></p></div></div>    
</body>
</html>