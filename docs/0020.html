<html>
<head>
<title>React Hooks with closures: useState v/s useReducer</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用闭包反作用钩子:useState v/s useReducer</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/react-hooks-with-closures-usestate-v-s-usereducer-9e0c20e81051?source=collection_archive---------0-----------------------#2019-03-03">https://medium.com/nerd-for-tech/react-hooks-with-closures-usestate-v-s-usereducer-9e0c20e81051?source=collection_archive---------0-----------------------#2019-03-03</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><figure class="hh hi ez fb hj hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es hg"><img src="../Images/e9fb5174a7fc92838b04387cc6c04035.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SIsm8PDlUBFQVPWZUbuqTQ.png"/></div></div></figure><div class=""/><p id="dae4" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">您是钩子的新手吗，正在努力理解影响功能组件从而影响钩子的闭包吗？如果答案是肯定的，那么你来对地方了。</p><p id="74c9" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">所以，让我们从基础开始:</p><h1 id="27ba" class="jo jp ht bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">使用状态</h1><figure class="kn ko kp kq fd hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es km"><img src="../Images/c99ef81ba75bf9a96d736ff523cc8de1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*myGr-IM-4yXo5Yh_ow8QtQ.jpeg"/></div></div></figure><p id="17d9" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">useState是所有内置钩子中最常用的。它类似于<code class="du kr ks kt ku b">this.setState</code>，我们用它来设置功能组件的状态。</p><p id="2110" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在下面附上一个简单的代码片段:</p><figure class="kn ko kp kq fd hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es kv"><img src="../Images/659208c3753a455b307c97bfddab2757.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TTcH-7JKf9xQu4Y1MXBv5w.png"/></div></div></figure><p id="6acd" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">有关使用状态的更多详细信息，请点击<a class="ae kw" href="https://reactjs.org/docs/hooks-reference.html#usestate" rel="noopener ugc nofollow" target="_blank">此处</a>。</p><h1 id="819b" class="jo jp ht bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">用户教育</h1><figure class="kn ko kp kq fd hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es km"><img src="../Images/9db843ab8ac5ded08506e53c434da95b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1UZi87VkzujVFngx4iLhAA.jpeg"/></div></div></figure><p id="455e" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">当您有涉及多个子值的复杂状态逻辑或者下一个状态依赖于前一个状态时，useReducer通常比useState更可取。</p><p id="202d" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在下面附上一个简单的代码片段:</p><figure class="kn ko kp kq fd hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es kx"><img src="../Images/d6bbd16a00038bafc812029f3883f68f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*j7b7KuIgZ638-pkBlFgthQ.png"/></div></div></figure><p id="b6a2" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">有关useReducer的更多详细信息，请点击<a class="ae kw" href="https://reactjs.org/docs/hooks-reference.html#usereducer" rel="noopener ugc nofollow" target="_blank">此处</a>。</p><h1 id="8e6a" class="jo jp ht bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">关闭</h1><figure class="kn ko kp kq fd hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es ky"><img src="../Images/31cced9b6a99af5824738df06c039fb5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gy0El9Ue9CXTSbrYF9HNVw.jpeg"/></div></div></figure><p id="cead" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">闭包是捆绑在一起(封闭)的函数与对其周围状态(词法环境)的引用的组合。换句话说，闭包允许您从内部函数访问外部函数的范围。在JavaScript中，闭包是在每次创建函数时创建的。</p><p id="04d2" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">有关关闭的更多详细信息，请点击<a class="ae kw" rel="noopener" href="/javascript-scene/master-the-javascript-interview-what-is-a-closure-b2f0d2152b36">此处</a>。</p><h1 id="2a23" class="jo jp ht bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">useState v/s useReducer (w.r.t闭包)</h1><p id="3136" class="pw-post-body-paragraph iq ir ht is b it kz iv iw ix la iz ja jb lb jd je jf lc jh ji jj ld jl jm jn hb bi translated">为了理解闭包如何影响带有钩子的功能组件，以及何时使用哪个，我将讨论一个名为<strong class="is hu"> useHistory的钩子。</strong>这是一个自定义挂钩，用于存储历史记录并供您使用。</p><p id="d72d" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hu">使用历史:</strong></p><p id="390a" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们今天要做的例子让我们输入一个用户名句柄，使用github api搜索它，并获取用户的信息。</p><p id="12d3" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">它存储搜索的用户名的历史，并为您提供上一个、下一个和您想要搜索的特定用户名的功能。</p><p id="168f" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">让我先给你看一个useHistory钩子的演示:</p><div class="hh hi ez fb hj le"><a href="https://drive.google.com/open?id=1ZiS8M1s7G8a-627Ag8upezmys7_XJn0L" rel="noopener  ugc nofollow" target="_blank"><div class="lf ab dw"><div class="lg ab lh cl cj li"><h2 class="bd hu fi z dy lj ea eb lk ed ef hs bi translated">演示</h2><div class="ll l"><h3 class="bd b fi z dy lj ea eb lk ed ef dx translated">使用历史</h3></div></div></div></a></div><p id="b7c4" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hu">使用无回调的useState和useEffect挂钩的useHistory的代码段:</strong></p><figure class="kn ko kp kq fd hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es lm"><img src="../Images/ca95b2f3155ae08d805d9354266d7a20.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*x9fgm10vdaRdZUiya8rM9A.png"/></div></div></figure><figure class="kn ko kp kq fd hk er es paragraph-image"><div class="er es ln"><img src="../Images/e07c14a8fd3db5ab945e11bc84ffa0e6.png" data-original-src="https://miro.medium.com/v2/resize:fit:824/format:webp/1*qwjobfmDZnsV98ygMjzvMw.png"/></div></figure><p id="7293" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在让我们来看看我们在使用这段代码时遇到的问题，因为这个问题，我们想到了使用useReducer钩子。</p><div class="hh hi ez fb hj le"><a href="https://drive.google.com/open?id=14Dpqr8gQecXo-FpgzqY_UH7SsCBbmFl_" rel="noopener  ugc nofollow" target="_blank"><div class="lf ab dw"><div class="lg ab lh cl cj li"><h2 class="bd hu fi z dy lj ea eb lk ed ef hs bi translated">关闭问题</h2><div class="ll l"><h3 class="bd b fi z dy lj ea eb lk ed ef dx translated">使用useState挂钩的useHistory</h3></div></div></div></a></div><p id="66bd" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在，如你所见，如果我们在短时间内多次点击“上一页”或“下一页”，我们的代码将进入无限循环。在很短的时间内，这将导致内存泄漏和浏览器崩溃。</p><p id="514f" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如你所见，在useEffect钩子函数的代码中，我们没有改变任何状态变量(如果成功:<strong class="is hu">加载，当前详细信息</strong>，如果错误:<strong class="is hu">加载，错误</strong>，导致重新渲染(<strong class="is hu">当前详细信息</strong>)。但不知何故，这些变量(<strong class="is hu"> currentItemNo </strong>)正在发生变化。这就是闭包出现的问题，在我们的例子中，它产生了一个问题。</p><p id="45e2" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">当调用被调用时，其中的函数进入作用域链，状态对象被保存为当前的状态，此后，当函数组件再次被调用时，状态对象获得不同的内存引用，因此不会被更新。</p><p id="e7d9" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">让我们用流程图来看看这个问题:</p><figure class="kn ko kp kq fd hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es lo"><img src="../Images/9920d41701fbae3be2cfbc862b322c35.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*anO3pTl3jKXRRJ1gQeQqFA.png"/></div></div></figure><p id="a5e2" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">正如您所看到的，因为currentItem在每次成功/错误回调时都会发生变化，所以useEffect钩子会被一次又一次地触发，这将导致一个无限循环(或多个不必要的调用)。</p><p id="2cb9" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在，问题是因为变量state在函数组件内部被初始化，因此每当它被再次调用时，变量state就会得到另一个引用，因此，因为闭包保存了旧状态，所以我们用旧状态更新setState。</p><pre class="kn ko kp kq fd lp ku lq lr aw ls bi"><span id="136f" class="lt jp ht ku b fi lu lv l lw lx">const [state, setState] = useState({</span><span id="3d17" class="lt jp ht ku b fi ly lv l lw lx">...initialState,</span><span id="7f17" class="lt jp ht ku b fi ly lv l lw lx">...data</span><span id="6aab" class="lt jp ht ku b fi ly lv l lw lx">});</span></pre><p id="449b" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在，解决这个问题的解决方案很少:</p><ol class=""><li id="354a" class="lz ma ht is b it iu ix iy jb mb jf mc jj md jn me mf mg mh bi translated"><strong class="is hu">在功能组件外声明变量</strong>:</li></ol><figure class="kn ko kp kq fd hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es mi"><img src="../Images/9bfec5e9b6e6d2fd8ec27c59b7b2bb84.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EBQtvwq7Sd3Mo9t3xT4-og.png"/></div></div></figure><p id="a137" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在，由于变量已经在函数组件范围之外声明，即使再次调用函数，状态变量的内存引用也不会改变，因此我们的函数(如setSuccess、setError)将获得最新的状态。</p><p id="f595" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">2.<strong class="is hu">通过回调使用useState的setState:</strong></p><figure class="kn ko kp kq fd hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es mj"><img src="../Images/8ad522fb2ca13dbfb907fcb7de2be12b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6Q78Ps_PfRKXKoR2X3GQ6Q.png"/></div></div></figure><p id="80a3" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在，当我们在像setSuccess这样的相应函数中调用setState时，setState会给我们最新的状态，因此当我们更新它时，我们将更新关于最新状态的更改。</p><p id="2a68" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">3.<strong class="is hu">使用useReducer: </strong></p><figure class="kn ko kp kq fd hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es mk"><img src="../Images/67232ced13ec75c1bb9aafdfba2d1727.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*n5lpFb-d3pSw4iQedRKrMw.png"/></div></div></figure><p id="6916" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在，如你所知，当下一个状态依赖于前一个状态时，使用useReducer，因此，它将总是具有前一个状态，因此，我们不需要担心状态函数被重新初始化或保存旧值。</p><p id="e2f9" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这都是我的观点。感谢你耐心阅读我的第一篇关于react hooks的博客。:)</p></div></div>    
</body>
</html>