<html>
<head>
<title>Distributed Tracing in Micro Services with Jaeger</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用 Jaeger 实现微服务的分布式跟踪</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/distributed-tracing-in-micro-services-with-jaeger-1e595eb9f906?source=collection_archive---------9-----------------------#2021-08-04">https://medium.com/nerd-for-tech/distributed-tracing-in-micro-services-with-jaeger-1e595eb9f906?source=collection_archive---------9-----------------------#2021-08-04</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/fffbd0c8cc870cc0595f4be0edaefec7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Qcmcxoz1J4uA1qqR_IiKbQ.jpeg"/></div></div></figure><p id="5ed4" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">Jaeger 是由 uber 创建的开源工具，用于微服务之间的分布式跟踪。</p><h1 id="9a5a" class="jo jp hi bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">为什么我们在微服务中需要分布式跟踪？</h1><p id="50f4" class="pw-post-body-paragraph iq ir hi is b it km iv iw ix kn iz ja jb ko jd je jf kp jh ji jj kq jl jm jn hb bi translated">说到微服务架构，最具挑战性任务是内部延续。现在，当处理微服务时，我们必须考虑每个服务的执行时间。这就是为什么需要跨微服务使用分布式跟踪机制的原因。</p><figure class="ks kt ku kv fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es kr"><img src="../Images/56457812afdbbf83977543955fb502fb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*h_QzrF6yWUh5fvdPWWNYGA.png"/></div></div></figure><p id="b7e8" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">假设当客户向 BFF 服务发送请求时，我们需要跟踪请求。这里我们使用 spring boot 来编写微服务。</p><h1 id="2ea9" class="jo jp hi bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">步骤 1:添加依赖关系和配置</h1><p id="8b34" class="pw-post-body-paragraph iq ir hi is b it km iv iw ix kn iz ja jb ko jd je jf kp jh ji jj kq jl jm jn hb bi translated">在本教程中，我将使用 spring boot 来编写微服务，因此这些是您必须添加到 maven 项目中的依赖项。</p><figure class="ks kt ku kv fd ij"><div class="bz dy l di"><div class="kw kx l"/></div></figure><p id="b99c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">并将这些配置添加到 yml 文件中。</p><figure class="ks kt ku kv fd ij"><div class="bz dy l di"><div class="kw kx l"/></div></figure><p id="76fd" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这是连接到 jaeger 服务器实例的配置。最后创建单独的配置文件&amp;添加以下 beans 来识别 jaeger 服务器中的模块细节。</p><figure class="ks kt ku kv fd ij"><div class="bz dy l di"><div class="kw kx l"/></div></figure><p id="c7a5" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">像这样所有的微服务都需要更新。</p><h1 id="e95f" class="jo jp hi bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">步骤 2:启动 JAEGER 服务器和用户界面进行测试</h1><p id="ac68" class="pw-post-body-paragraph iq ir hi is b it km iv iw ix kn iz ja jb ko jd je jf kp jh ji jj kq jl jm jn hb bi translated">我们可以用 docker 来启动 jaeger sever &amp; UI。</p><figure class="ks kt ku kv fd ij"><div class="bz dy l di"><div class="kw kx l"/></div></figure><p id="a2bd" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">一旦 jaeger 用户界面启动，你就可以进入<a class="ae ky" href="http://localhost:16686/search" rel="noopener ugc nofollow" target="_blank">这里</a>。</p><p id="267e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">然后我们可以在 UI 中跟踪 API 请求。</p><figure class="ks kt ku kv fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es kz"><img src="../Images/a0e3c23cb0dabeb95a6effa93d709742.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0x0srhQT5AskRNLRrlmYSA.png"/></div></div><figcaption class="la lb et er es lc ld bd b be z dx translated">jaeger ui</figcaption></figure><p id="f6df" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">例如，这是 jaeger UI 中显示的一个请求。API 执行时间为 2.11 秒。有两个模块在请求中有记录。</p><figure class="ks kt ku kv fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es le"><img src="../Images/bdb88c2472f7a2578c71352da3f7bc4e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8Rd46j-6Rje-w9kFtwoSiw.png"/></div></div></figure><p id="c4d3" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">当我们单击请求时，它会显示每个模块 API 的执行时间。在我的例子中，支付网关花费了更多的执行时间。这是 1.85 秒，但实际上第三方连接花了 1.74 秒。这样才能找出微服务的瓶颈。</p><figure class="ks kt ku kv fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lf"><img src="../Images/7166c65455ac6e530592c40a53e78688.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SvaUNYndNdax5-WFvY7XkA.png"/></div></div></figure></div></div>    
</body>
</html>