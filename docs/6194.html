<html>
<head>
<title>Basics of Optimization in Unity</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Unity 中的优化基础</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/basics-of-optimization-in-unity-dc10fab79f43?source=collection_archive---------8-----------------------#2022-01-13">https://medium.com/nerd-for-tech/basics-of-optimization-in-unity-dc10fab79f43?source=collection_archive---------8-----------------------#2022-01-13</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="35ec" class="pw-post-body-paragraph ig ih hi ii b ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd hb bi translated">现在，我们已经花了一些时间为各种不同的项目创建代码，并对如何构建代码有了一个好的想法，让我们回过头来看看如何在代码创建中变得更加优化。有无数种方法可以优化我们的方法。我将只是概述一些，但肯定还有更多可以找到。</p><ol class=""><li id="4801" class="je jf hi ii b ij ik in io ir jg iv jh iz ji jd jj jk jl jm bi translated">尽可能避免 GetComponent</li></ol><p id="9eb8" class="pw-post-body-paragraph ig ih hi ii b ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd hb bi translated">使用 GetComponent 可能会耗尽一些 GC 分配。为同一目的或像相机这样的关键元素多次使用它，会导致 GC 的累积。为了防止这些问题，通常最好将组件缓存到它自己的对象中，然后当我们以后需要调用它时，我们可以使用缓存的值。</p><p id="a646" class="pw-post-body-paragraph ig ih hi ii b ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd hb bi translated">一个很好的基本规则是，如果对象碰巧是一个类，我们希望它被缓存，如果它是一个结构，我们可以使用 GetComponent 而不需要缓存它。</p><figure class="jo jp jq jr fd js er es paragraph-image"><div class="er es jn"><img src="../Images/f59a55dee6b087514cacd99fd1fd2139.png" data-original-src="https://miro.medium.com/v2/resize:fit:1230/format:webp/1*KnP4RHtOgjhnlQUxiXvlYA.png"/></div></figure><p id="c0ec" class="pw-post-body-paragraph ig ih hi ii b ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd hb bi translated">浏览我工作的第一个项目中的一些代码，我注意到我用这些代码来改变我的船盾的颜色。这一小段代码可以通过缓存 material 类来优化:</p><figure class="jo jp jq jr fd js er es paragraph-image"><div class="er es jv"><img src="../Images/34f98a2d539cede3cdfa2c10d8047831.png" data-original-src="https://miro.medium.com/v2/resize:fit:1098/format:webp/1*LgukVsKVslmhx4UykhZMXg.png"/></div></figure><p id="c5dc" class="pw-post-body-paragraph ig ih hi ii b ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd hb bi translated">因此，由于材质是一个类，我们可以创建一个 _shieldColour 的新私有材质，并在我们的 void start 中分配它:</p><figure class="jo jp jq jr fd js er es paragraph-image"><div class="er es jw"><img src="../Images/f2167076f468c3cb71ec730ca6174ed0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1046/format:webp/1*-V86AZ7jX4oay6ikZe28DQ.png"/></div></figure><p id="f842" class="pw-post-body-paragraph ig ih hi ii b ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd hb bi translated">在这里赋值后，我们可以返回到原始代码并替换 GetComponents:</p><figure class="jo jp jq jr fd js er es paragraph-image"><div class="er es jx"><img src="../Images/b7d467d6bf9721f095e8c9ddd3020988.png" data-original-src="https://miro.medium.com/v2/resize:fit:1028/format:webp/1*5wSKknRKf5uybPkK4wAIog.png"/></div></figure><p id="d8af" class="pw-post-body-paragraph ig ih hi ii b ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd hb bi translated">这可能看起来有点琐碎，但是通过我们编写的代码进行这样的更改可以帮助节省 GC 分配。我们只能说，在我们改变它之前，它已经用完了 200b 的 GC 分配。如果我们像这样使用 GetComponent 有 5 个不同的方法，我们已经有 1kb 的 GC 了。较小的值会很快增加，并在项目中产生 fps 问题，因为 it 必须处理所有未优化代码的多余 GC。</p><p id="61b8" class="pw-post-body-paragraph ig ih hi ii b ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd hb bi translated">2.优化协程</p><p id="fa6a" class="pw-post-body-paragraph ig ih hi ii b ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd hb bi translated">在协同例程中，我们可以为 WaitForSeconds 创建一个缓存值:</p><figure class="jo jp jq jr fd js er es paragraph-image"><div role="button" tabindex="0" class="jz ka di kb bf kc"><div class="er es jy"><img src="../Images/469f6907346c9c2447fe28462638d833.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8A1SSsfw6j8fYFabIAn2mw.png"/></div></div></figure><p id="7b7c" class="pw-post-body-paragraph ig ih hi ii b ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd hb bi translated">这里我们有两个独立的协程，它们执行完全相同的过程。但是，1 缓存了它的 WaitForSeconds，而另一个没有。为了了解这两者之间的区别，我们可以创建一个样本组，并为其指定一个标题，以便在查看我们的层次结构时能够理解:</p><figure class="jo jp jq jr fd js er es paragraph-image"><div role="button" tabindex="0" class="jz ka di kb bf kc"><div class="er es jy"><img src="../Images/0be2e2f4ba29473517177745bd638563.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kfoYjmYjKcI-bwe_zbOaHQ.png"/></div></div></figure><p id="f29e" class="pw-post-body-paragraph ig ih hi ii b ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd hb bi translated">现在，在运行一段时间后，查看我们的分析器，我们可以看到偶尔会构建 20B 个 GC alloc。通过进一步的调查，我们可以发现它来自于我们缓慢的日常生活。这是因为我们在实际的协程中使用了新的 WaitForSeconds，而不是为它创建一个缓存并在那里分配它。</p><p id="30bf" class="pw-post-body-paragraph ig ih hi ii b ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd hb bi translated">3.尽可能使用非字母版本</p><figure class="jo jp jq jr fd js er es paragraph-image"><div role="button" tabindex="0" class="jz ka di kb bf kc"><div class="er es jy"><img src="../Images/9cde4b65f0384be4b2421a11cceacb3c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rSyEUimkwKEVgE45VJVX_w.png"/></div></div></figure><p id="aa3c" class="pw-post-body-paragraph ig ih hi ii b ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd hb bi translated">当我们在项目中使用 raycast 时，可以选择 RaycastNonAlloc，它将执行相同的过程，但是它不会产生任何垃圾。</p><p id="b243" class="pw-post-body-paragraph ig ih hi ii b ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd hb bi translated">4.尽可能使用列表而不是数组</p><p id="c992" class="pw-post-body-paragraph ig ih hi ii b ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd hb bi translated">与数组相比，列表更容易使用，可以更容易地在代码中清除，并且占用的内存更少。</p><p id="f664" class="pw-post-body-paragraph ig ih hi ii b ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd hb bi translated">5.使用活动和静态画布</p><p id="7834" class="pw-post-body-paragraph ig ih hi ii b ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd hb bi translated">当构建一个项目时，要养成的一个好习惯是创建一个活动的和一个静态的画布。将所有的 UI 元素放在一个画布中会弄脏整个画布。这是因为当你有一些东西改变了它的值，整个画布将被刷新。这包括所有其他的视觉效果，但不要改变。相反，UI 元素将改变为 1 个画布，静态元素将改变为自己的画布。</p><p id="3294" class="pw-post-body-paragraph ig ih hi ii b ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd hb bi translated">6.隐藏画布组件，而不是对象</p><figure class="jo jp jq jr fd js er es paragraph-image"><div role="button" tabindex="0" class="jz ka di kb bf kc"><div class="er es jy"><img src="../Images/b39fb2f097dff43bc59fc21ae9fa0aa5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*8CgQ5kj8lbLyVP9WwoNfZg.gif"/></div></div></figure><p id="9da3" class="pw-post-body-paragraph ig ih hi ii b ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd hb bi translated">这些只是我们在 Unity 中优化应用的众多方法中的一部分。外面还有很多，所以花点时间看看你能在网上找到什么。</p></div></div>    
</body>
</html>