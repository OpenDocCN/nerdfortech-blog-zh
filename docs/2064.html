<html>
<head>
<title>Swift Leetcode Series :Combination Sum IV</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Swift Leetcode 系列:组合 Sum IV</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/swift-leetcode-series-combination-sum-iv-748a8380b8ad?source=collection_archive---------12-----------------------#2021-04-19">https://medium.com/nerd-for-tech/swift-leetcode-series-combination-sum-iv-748a8380b8ad?source=collection_archive---------12-----------------------#2021-04-19</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="af14" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">回溯+ DP =漂亮的大脑锻炼</h2></div><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ix"><img src="../Images/9f6a59ad9842210e818290eb96f06016.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rBw3RP1o9D5nLpQ7Pgbq9A.png"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx translated"><a class="ae jn" href="https://leetcode.com/problems/combination-sum-iv/" rel="noopener ugc nofollow" target="_blank"> Leetcode 377(中号)</a></figcaption></figure><div class="jo jp ez fb jq jr"><a href="https://theswiftnerd.com/combination-sum-iv-leetcode/" rel="noopener  ugc nofollow" target="_blank"><div class="js ab dw"><div class="jt ab ju cl cj jv"><h2 class="bd hj fi z dy jw ea eb jx ed ef hh bi translated">组合和 IV (Leetcode 377)</h2><div class="jy l"><h3 class="bd b fi z dy jw ea eb jx ed ef dx translated">难度:链接:April Leetcoding 挑战 2021:第 19 天给定一个非重复整数数组 num 和一个目标整数…</h3></div><div class="jz l"><p class="bd b fp z dy jw ea eb jx ed ef dx translated">theswiftnerd.com</p></div></div><div class="ka l"><div class="kb l kc kd ke ka kf jh jr"/></div></div></a></div><p id="11eb" class="pw-post-body-paragraph kg kh hi ki b kj kk ij kl km kn im ko kp kq kr ks kt ku kv kw kx ky kz la lb hb bi translated">你也可以通过上面的链接在 Swift Nerd 博客上阅读完整的故事。</p><p id="7c04" class="pw-post-body-paragraph kg kh hi ki b kj kk ij kl km kn im ko kp kq kr ks kt ku kv kw kx ky kz la lb hb bi translated">这是经典 coint change 问题的一个变种，如果你想改进你的递归和动态编程，自己解决它是非常重要的。</p><h1 id="c370" class="lc ld hi bd le lf lg lh li lj lk ll lm io ln ip lo ir lp is lq iu lr iv ls lt bi translated">问题描述</h1><p id="b0cc" class="pw-post-body-paragraph kg kh hi ki b kj lu ij kl km lv im ko kp lw kr ks kt lx kv kw kx ly kz la lb hb bi translated">给定一个由<strong class="ki hj">个不同的</strong>个整数<code class="du lz ma mb mc b">nums</code>和一个目标整数<code class="du lz ma mb mc b">target</code>组成的数组，返回<em class="md">加起来等于</em> <code class="du lz ma mb mc b">target</code>的可能组合数。</p><p id="433d" class="pw-post-body-paragraph kg kh hi ki b kj kk ij kl km kn im ko kp kq kr ks kt ku kv kw kx ky kz la lb hb bi translated">答案是<strong class="ki hj">保证</strong>适合一个<strong class="ki hj"> 32 位</strong>整数。</p><p id="aeda" class="pw-post-body-paragraph kg kh hi ki b kj kk ij kl km kn im ko kp kq kr ks kt ku kv kw kx ky kz la lb hb bi translated"><strong class="ki hj">例 1: </strong></p><pre class="iy iz ja jb fd me mc mf mg aw mh bi"><span id="b84e" class="mi ld hi mc b fi mj mk l ml mm"><strong class="mc hj">Input:</strong> nums = [1,2,3], target = 4<br/><strong class="mc hj">Output:</strong> 7<br/><strong class="mc hj">Explanation:</strong><br/>The possible combination ways are:<br/>(1, 1, 1, 1)<br/>(1, 1, 2)<br/>(1, 2, 1)<br/>(1, 3)<br/>(2, 1, 1)<br/>(2, 2)<br/>(3, 1)<br/>Note that different sequences are counted as different combinations.</span></pre><p id="9f0d" class="pw-post-body-paragraph kg kh hi ki b kj kk ij kl km kn im ko kp kq kr ks kt ku kv kw kx ky kz la lb hb bi translated"><strong class="ki hj">例 2: </strong></p><pre class="iy iz ja jb fd me mc mf mg aw mh bi"><span id="241b" class="mi ld hi mc b fi mj mk l ml mm"><strong class="mc hj">Input:</strong> nums = [9], target = 3<br/><strong class="mc hj">Output:</strong> 0</span></pre><h1 id="aae6" class="lc ld hi bd le lf lg lh li lj lk ll lm io ln ip lo ir lp is lq iu lr iv ls lt bi translated">限制</h1><ul class=""><li id="b538" class="mn mo hi ki b kj lu km lv kp mp kt mq kx mr lb ms mt mu mv bi translated"><code class="du lz ma mb mc b">1 &lt;= nums.length &lt;= 200</code></li><li id="d963" class="mn mo hi ki b kj mw km mx kp my kt mz kx na lb ms mt mu mv bi translated"><code class="du lz ma mb mc b">1 &lt;= nums[i] &lt;= 1000</code></li><li id="6fb3" class="mn mo hi ki b kj mw km mx kp my kt mz kx na lb ms mt mu mv bi translated"><code class="du lz ma mb mc b">nums</code>的所有元素都是<strong class="ki hj">独有的</strong>。</li><li id="eb1d" class="mn mo hi ki b kj mw km mx kp my kt mz kx na lb ms mt mu mv bi translated"><code class="du lz ma mb mc b">1 &lt;= target &lt;= 1000</code></li></ul><h1 id="2af4" class="lc ld hi bd le lf lg lh li lj lk ll lm io ln ip lo ir lp is lq iu lr iv ls lt bi translated">解决办法</h1><p id="d751" class="pw-post-body-paragraph kg kh hi ki b kj lu ij kl km lv im ko kp lw kr ks kt lx kv kw kx ly kz la lb hb bi translated">该问题类似于硬币找零问题的经典问题。我们可以考虑递归地将问题分解成子问题，然后构建我们的解决方案。</p><h1 id="8925" class="lc ld hi bd le lf lg lh li lj lk ll lm io ln ip lo ir lp is lq iu lr iv ls lt bi translated">追踪</h1><p id="00fe" class="pw-post-body-paragraph kg kh hi ki b kj lu ij kl km lv im ko kp lw kr ks kt lx kv kw kx ly kz la lb hb bi translated">每当你听到“组合”或“排列”这个词，理想情况下，回溯这个词应该出现在你的脑海中。我们可以使用回溯来置换所有可能的数字组合，并选择适合我们条件的分支。看看硬币兑换问题的例子。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es nb"><img src="../Images/142314fd107e4112fd3d5096ab4f3365.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*OhLa5onxMQwsLCSF.png"/></div></div></figure><p id="efc6" class="pw-post-body-paragraph kg kh hi ki b kj kk ij kl km kn im ko kp kq kr ks kt ku kv kw kx ky kz la lb hb bi translated">我们可以从目标开始，递归地尝试 nums 数组中每个数字的组合。如果我们有一个目标<strong class="ki hj"> T </strong>并且从数组中取一个数 A[i]，其中 0 &lt; = i &lt; n，那么子问题将变成为<strong class="ki hj"> T — A[i] </strong>寻找总的组合，这将依次递归地置换所有可能的路径。一旦 T-A[I]= = 0，这意味着当前分支是一个解，我们可以把它加到结果中。如果<strong class="ki hj"> T — A[i] &lt; 0 </strong>，这意味着数字的当前排列不能给我们目标和，因此我们可以丢弃该分支。</p><h1 id="64fa" class="lc ld hi bd le lf lg lh li lj lk ll lm io ln ip lo ir lp is lq iu lr iv ls lt bi translated">重要事项:</h1><p id="2071" class="pw-post-body-paragraph kg kh hi ki b kj lu ij kl km lv im ko kp lw kr ks kt lx kv kw kx ly kz la lb hb bi translated">当你试图运行这个问题时，它会运行样本测试用例，但是你会在提交时得到<strong class="ki hj"> TLE </strong> ( <strong class="ki hj">时间限制超过</strong>)。为什么？因为递归的深度。对于回溯方法，复杂度将是指数级的<strong class="ki hj"> O(NM) </strong>。其中 N 是数组的大小，M 是最终总和。在约束中，数组的最大大小为 200，而目标可以是 1000。所以我们在讨论顺序为<strong class="ki hj"> 200 1000 </strong>的操作，这是一个大规模的操作(不要忘记空间的递归堆栈)。但是因为我们重复了很多操作，我们可以缓存它们，这就是动态编程的用武之地。</p><p id="d10f" class="pw-post-body-paragraph kg kh hi ki b kj kk ij kl km kn im ko kp kq kr ks kt ku kv kw kx ky kz la lb hb bi translated">因为没有 DP 我们不能提交问题，那么它是唯一可能的解决方案(DP ),但是回溯方法对于发展直觉和理解子问题是重要的。有了更少的约束，我们的回溯解也能得到接受。</p><h1 id="5c2c" class="lc ld hi bd le lf lg lh li lj lk ll lm io ln ip lo ir lp is lq iu lr iv ls lt bi translated">动态规划</h1><p id="4b6b" class="pw-post-body-paragraph kg kh hi ki b kj lu ij kl km lv im ko kp lw kr ks kt lx kv kw kx ly kz la lb hb bi translated">这是一个经典的动态规划问题，因为该问题可以分解为子问题，优化局部结果将有助于优化全局结果。(<strong class="ki hj">重叠子问题</strong>和<strong class="ki hj">优化结构</strong>)。代码或多或少是相同的，但是我们将缓存解决每个子问题的结果。DP[i]将表示实现总和 I 的可能组合的总数。我们将使用自上而下的动态规划，因为我们将从我们的主要问题开始，并朝着较小的子问题努力。还有一种自下而上的方法，我们从 1 开始解决子问题，并朝着主问题和过程努力，我们将解决所有可能的递归步骤，这是我们解决最终问题所需要的。</p><p id="df51" class="pw-post-body-paragraph kg kh hi ki b kj kk ij kl km kn im ko kp kq kr ks kt ku kv kw kx ky kz la lb hb bi translated"><strong class="ki hj">自上而下的方法</strong></p><p id="56ec" class="pw-post-body-paragraph kg kh hi ki b kj kk ij kl km kn im ko kp kq kr ks kt ku kv kw kx ky kz la lb hb bi translated">我们的 DP 数组(<strong class="ki hj"> dp </strong>)将包含单元格(<strong class="ki hj"> dp[i] </strong>)，其中<strong class="ki hj"> i </strong>将表示在<strong class="ki hj"> T </strong>之前剩余的空间，而<strong class="ki hj"> dp[i] </strong>将表示从<strong class="ki hj"> i </strong>到达解(<strong class="ki hj">DP[T】</strong>)的方式的数量。</p><p id="8d07" class="pw-post-body-paragraph kg kh hi ki b kj kk ij kl km kn im ko kp kq kr ks kt ku kv kw kx ky kz la lb hb bi translated">在我们构建<strong class="ki hj"> dp </strong>时，在<strong class="ki hj"> i </strong>的每个值处，我们将遍历我们的数字数组(<strong class="ki hj"> N </strong>)中不同的<strong class="ki hj"> num </strong> s，并考虑每个<strong class="ki hj">num</strong>(<strong class="ki hj">DP【I-num】</strong>)可以到达的单元格。因此，<strong class="ki hj"> dp[i] </strong>的值将是这些可能移动的结果的总和。</p><h1 id="6cf7" class="lc ld hi bd le lf lg lh li lj lk ll lm io ln ip lo ir lp is lq iu lr iv ls lt bi translated">密码</h1><h1 id="8e17" class="lc ld hi bd le lf lg lh li lj lk ll lm io ln ip lo ir lp is lq iu lr iv ls lt bi translated">回溯(递归)</h1><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="nc nd l"/></div></figure><h1 id="a190" class="lc ld hi bd le lf lg lh li lj lk ll lm io ln ip lo ir lp is lq iu lr iv ls lt bi translated">代码:自上而下方法(DP)</h1><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="nc nd l"/></div></figure><h1 id="3289" class="lc ld hi bd le lf lg lh li lj lk ll lm io ln ip lo ir lp is lq iu lr iv ls lt bi translated">复杂性分析</h1><h1 id="4035" class="lc ld hi bd le lf lg lh li lj lk ll lm io ln ip lo ir lp is lq iu lr iv ls lt bi translated">追踪</h1><p id="8947" class="pw-post-body-paragraph kg kh hi ki b kj lu ij kl km lv im ko kp lw kr ks kt lx kv kw kx ly kz la lb hb bi translated"><strong class="ki hj"> Time = O(NM) </strong>其中 N 是数组的大小，M 是总量。</p><p id="0923" class="pw-post-body-paragraph kg kh hi ki b kj kk ij kl km kn im ko kp kq kr ks kt ku kv kw kx ky kz la lb hb bi translated"><strong class="ki hj">空间= O(1) </strong></p><p id="dc47" class="pw-post-body-paragraph kg kh hi ki b kj kk ij kl km kn im ko kp kq kr ks kt ku kv kw kx ky kz la lb hb bi translated">把递归想象成一棵树，每条路径代表一种凑数的方式，树的高度是拥有最多硬币的组合。由于数量是固定的，包含最多硬币的组合将使用最小的硬币。在最坏的情况下，树的根节点可以有 n 个子节点。因此，运行时间成指数增长。</p><h1 id="c27f" class="lc ld hi bd le lf lg lh li lj lk ll lm io ln ip lo ir lp is lq iu lr iv ls lt bi translated">动态规划</h1><p id="4564" class="pw-post-body-paragraph kg kh hi ki b kj lu ij kl km lv im ko kp lw kr ks kt lx kv kw kx ly kz la lb hb bi translated">Time = <strong class="ki hj"> O(N * M) </strong>其中 N 是数组的大小，M 是总量。</p><p id="c431" class="pw-post-body-paragraph kg kh hi ki b kj kk ij kl km kn im ko kp kq kr ks kt ku kv kw kx ky kz la lb hb bi translated">Space = <strong class="ki hj"> O(M) </strong>(用于存储从 0 到 M 的结果)</p></div><div class="ab cl ne nf gp ng" role="separator"><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj"/></div><div class="hb hc hd he hf"><p id="0c02" class="pw-post-body-paragraph kg kh hi ki b kj kk ij kl km kn im ko kp kq kr ks kt ku kv kw kx ky kz la lb hb bi translated">感谢您的阅读。如果你喜欢这篇文章，并发现它很有用，请分享并像野火一样传播它！</p><p id="0e6c" class="pw-post-body-paragraph kg kh hi ki b kj kk ij kl km kn im ko kp kq kr ks kt ku kv kw kx ky kz la lb hb bi translated">你可以在<a class="ae jn" href="https://theswiftnerd.com/" rel="noopener ugc nofollow" target="_blank">the swift nerd</a>|<a class="ae jn" href="https://www.linkedin.com/in/varunrathi28/" rel="noopener ugc nofollow" target="_blank">LinkedIn</a>|<a class="ae jn" href="https://github.com/varunrathi28" rel="noopener ugc nofollow" target="_blank">Github</a>上找到我</p></div></div>    
</body>
</html>