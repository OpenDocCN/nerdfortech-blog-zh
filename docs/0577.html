<html>
<head>
<title>How to Improve MYSQL Database Performance</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何提高 MYSQL 数据库的性能</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/how-to-improve-mysql-mariadb-database-performance-181f270d7fbe?source=collection_archive---------1-----------------------#2021-01-20">https://medium.com/nerd-for-tech/how-to-improve-mysql-mariadb-database-performance-181f270d7fbe?source=collection_archive---------1-----------------------#2021-01-20</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/d1d1ec26bd121e45efa506dc49bd2397.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YknRHdvLsxcTM9EUTFezYQ.jpeg"/></div></div></figure><p id="8d75" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在我的另一篇文章的后续:<a class="ae jo" href="https://pirex360.medium.com/how-to-improve-microsoft-sql-server-mssql-database-c2b159ced54d" rel="noopener">如何提高微软 SQL Server (MSSQL)数据库性能</a>，现在我将对<strong class="is hj"> MYSQL / MariaDB </strong>数据库做同样的事情。</p><p id="2481" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">当我们开发一个定制的 web 应用程序时，我们必须测试所有类型的场景。通常情况下，数据库的缩放是高质量软件的关键点。最近，我继承了几个在性能上受到影响的遗留应用程序，因为以前的开发人员在数据库级别工作得不好。在网络生态系统中，数据库操作中获得的每一个<strong class="is hj">毫秒</strong>都是为我们开发的软件提供更好的用户体验的重要一步。</p><h1 id="862b" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">让我们开始我们的旅程吧！</h1><p id="0987" class="pw-post-body-paragraph iq ir hi is b it ko iv iw ix kp iz ja jb kq jd je jf kr jh ji jj ks jl jm jn hb bi translated">最初的起点是了解在<strong class="is hj"> MyISAM </strong>和<strong class="is hj"> InnoDB </strong>之间选择最佳存储引擎的重要性，这是至关重要的一步，在本文中，我不想关注这两种引擎类型之间的差异，但我在这里留下了一个<a class="ae jo" href="https://en.wikipedia.org/wiki/Comparison_of_MySQL_database_engines" rel="noopener ugc nofollow" target="_blank">链接</a>来了解关于这个主题的更多信息。</p><p id="94ea" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi kt translated"><span class="l ku kv kw bm kx ky kz la lb di">在</span>关于存储引擎的总结中，我倾向于使用<strong class="is hj"> InnoDB </strong>来完成我的所有项目，我只在不经常写表的情况下使用<strong class="is hj"> MyISAM </strong>。您可以拥有一个混合了 InnoDB 和 MyISAM 表的数据库(我不经常使用这种方法，但这是一种可能性)。</p></div><div class="ab cl lc ld gp le" role="separator"><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh"/></div><div class="hb hc hd he hf"><p id="f3e0" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在选择了存储引擎之后，现在是讨论表的字段的索引的时候了。当然，当你创建一个主键时，一个自动索引就被创建了…我看到很多项目只使用这些索引。问题是当数据库增长到更大数量的行/数据时，由于缺乏数据库索引规划，执行过滤数据的 SQL 查询的时间<strong class="is hj"> <em class="lj">受到</em> </strong>的严重影响。</p><p id="b3d9" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">让我们使用我为<strong class="is hj">概念验证</strong>创建的测试数据库，其中有两个充满虚拟数据的表(作者和帖子)，只有字段(id)中有一个主键，每个表都有 auto_increment 和 InnoDB 存储引擎，下面是表的结构:</p><figure class="ll lm ln lo fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lk"><img src="../Images/a618242d1ef477afbb9c4cc73e53d774.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*mFZOXUxKFG4CmlZ_"/></div></div><figcaption class="lp lq et er es lr ls bd b be z dx translated">表<strong class="bd jr">作者</strong>拥有近<strong class="bd jr">430000</strong>430000<strong class="bd jr">行</strong>大小为<strong class="bd jr"> 34.6 MB </strong></figcaption></figure><figure class="ll lm ln lo fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lt"><img src="../Images/1a2e22de5ef38d48ef2ba153d2bf9f21.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*fF3hzIL7Mil0VLNk"/></div></div><figcaption class="lp lq et er es lr ls bd b be z dx translated">表<strong class="bd jr">贴</strong>近<strong class="bd jr"> 276000 </strong>行<strong class="bd jr">大小<strong class="bd jr"> 113.6 MB </strong></strong></figcaption></figure><p id="455b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在让我们创建一个简单的可能的真实世界<code class="du lu lv lw lx b">SELECT</code>，连接两个表并按照以下标准进行过滤:</p><ul class=""><li id="0c26" class="ly lz hi is b it iu ix iy jb ma jf mb jj mc jn md me mf mg bi translated">通过<code class="du lu lv lw lx b">id</code>将表格<code class="du lu lv lw lx b">posts</code>与<code class="du lu lv lw lx b">authors</code>连接起来</li><li id="0c81" class="ly lz hi is b it mh ix mi jb mj jf mk jj ml jn md me mf mg bi translated">根据 1979 年到 2021 年间的文章<code class="du lu lv lw lx b">date</code>进行过滤</li><li id="f298" class="ly lz hi is b it mh ix mi jb mj jf mk jj ml jn md me mf mg bi translated">按作者筛选<code class="du lu lv lw lx b">last_name</code>以“St”开头</li><li id="5285" class="ly lz hi is b it mh ix mi jb mj jf mk jj ml jn md me mf mg bi translated">由作者筛选<code class="du lu lv lw lx b">age</code>18 至 40 岁之间</li></ul><h1 id="59df" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">SQL 测试查询和输出</h1><pre class="ll lm ln lo fd mm lx mn mo aw mp bi"><span id="af4d" class="mq jq hi lx b fi mr ms l mt mu"><strong class="lx hj">SELECT</strong> p.id, a.first_name, a.last_name, a.email,a.birthdate, p.title, p.description, p.content, p.date</span><span id="36ac" class="mq jq hi lx b fi mv ms l mt mu"><strong class="lx hj">FROM</strong> posts p<br/>    <strong class="lx hj">INNER JOIN</strong> authors a<br/>    <strong class="lx hj">ON</strong> p.author_id = a.id</span><span id="562d" class="mq jq hi lx b fi mv ms l mt mu"><strong class="lx hj">WHERE</strong> year(p.date) <strong class="lx hj">BETWEEN</strong> 1979 <strong class="lx hj">AND</strong> 2021<br/><strong class="lx hj">AND</strong> a.last_name <strong class="lx hj">LIKE</strong> 'St%'<br/><strong class="lx hj">AND</strong> (<strong class="lx hj">YEAR</strong>(<strong class="lx hj">CURDATE</strong>()) - <strong class="lx hj">YEAR</strong>(birthdate)) <strong class="lx hj">BETWEEN</strong> 18 <strong class="lx hj">AND</strong> 40</span></pre><figure class="ll lm ln lo fd ij er es paragraph-image"><div class="er es mw"><img src="../Images/5706bebfe0028249c46972898dc3d6eb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1058/0*ecwAyHfe4ETj9kVO"/></div><figcaption class="lp lq et er es lr ls bd b be z dx translated">这些结果是仅使用两个表中主键的索引获得的。</figcaption></figure><h2 id="cc2c" class="mq jq hi bd jr mx my mz jv na nb nc jz jb nd ne kd jf nf ng kh jj nh ni kl nj bi translated">输出<strong class="ak"/><strong class="ak">行数据</strong>用了<strong class="ak"> 126 ms </strong>。</h2><p id="cab4" class="pw-post-body-paragraph iq ir hi is b it ko iv iw ix kp iz ja jb kq jd je jf kr jh ji jj ks jl jm jn hb bi translated">现在我们有一个点来比较优化，将在文章的其余部分应用。</p></div><div class="ab cl lc ld gp le" role="separator"><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh"/></div><div class="hb hc hd he hf"><p id="ad5a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如果您分析所使用的查询，让我们关注一下<code class="du lu lv lw lx b">WHERE</code>子句:有<strong class="is hj"> 3 个</strong>字段被过滤(<code class="du lu lv lw lx b">p.date</code>、<code class="du lu lv lw lx b">a.last_name</code>和<code class="du lu lv lw lx b">a.birthdate</code>)。</p><blockquote class="nk nl nm"><p id="4faa" class="iq ir lj is b it iu iv iw ix iy iz ja nn jc jd je no jg jh ji np jk jl jm jn hb bi translated"><strong class="is hj">注意:</strong>在我参与的一些外部项目中，我仍然看到没有索引的外键。这是数据库关系中的一个坏习惯，会导致表之间的<code class="du lu lv lw lx b">JOIN</code>连接性能下降。</p></blockquote><p id="46a0" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我的经验是分析这些字段，并选择最佳候选项，对它们应用一个索引。不要滥用索引字段(尤其是<code class="du lu lv lw lx b">string</code>类型),因为添加大量索引会降低性能，除了主键和外键之外，我尽量在每个表中最多使用 1 到 3 个索引，并且只在需要时使用。</p><p id="0a88" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">最好的候选字段是可能有重复数据的字段，例如，posts <code class="du lu lv lw lx b">date</code>字段和 authors <code class="du lu lv lw lx b">birthdate</code>字段可能有具有相同内容日期年份的<strong class="is hj"> n </strong>行，例如:'<code class="du lu lv lw lx b">1999-MM-DD</code>'，而 authors <code class="du lu lv lw lx b">last_name</code>字段由于内容的性质也可能有重复值，但是字段类型是<code class="du lu lv lw lx b">string</code>，我避免向<code class="du lu lv lw lx b">string</code>字段添加索引，这只是最后的手段。</p><p id="84bc" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">因此，让我们为帖子<code class="du lu lv lw lx b">date</code>和作者<code class="du lu lv lw lx b">birthdate</code>字段添加索引。</p><pre class="ll lm ln lo fd mm lx mn mo aw mp bi"><span id="6c66" class="mq jq hi lx b fi mr ms l mt mu"><strong class="lx hj">CREATE</strong> <strong class="lx hj">INDEX</strong> index_posts_date <strong class="lx hj">ON</strong> posts (date);<br/><strong class="lx hj">CREATE</strong> <strong class="lx hj">INDEX</strong> index_authors_birthdate <strong class="lx hj">ON</strong> authors (birthdate);</span></pre><p id="9666" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">创建索引后，运行一个简单的 SQL 命令来优化表:<code class="du lu lv lw lx b">OPTIMIZE TABLE table_name</code>，也可以在一行中使用多个表，表名之间用逗号隔开。</p><pre class="ll lm ln lo fd mm lx mn mo aw mp bi"><span id="57dc" class="mq jq hi lx b fi mr ms l mt mu"><strong class="lx hj">OPTIMIZE</strong> <strong class="lx hj">TABLE</strong> authors, posts;</span></pre><p id="4118" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如果您想在所有数据库表上运行这个命令，而不需要手动键入所有表的名称，使用下一个 SQL 命令自动应用到所需数据库的所有表，只需替换所需数据库名称的<code class="du lu lv lw lx b">'your_database'</code>。</p><pre class="ll lm ln lo fd mm lx mn mo aw mp bi"><span id="2245" class="mq jq hi lx b fi mr ms l mt mu"><strong class="lx hj">SELECT</strong> <strong class="lx hj">CONCAT</strong>('OPTIMIZE TABLE ',TABLE_NAME, ';') <br/><strong class="lx hj">FROM</strong> INFORMATION_SCHEMA.TABLES<br/><strong class="lx hj">WHERE</strong> table_schema='your_database';</span></pre></div><div class="ab cl lc ld gp le" role="separator"><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh"/></div><div class="hb hc hd he hf"><h1 id="5724" class="jp jq hi bd jr js nq ju jv jw nr jy jz ka ns kc kd ke nt kg kh ki nu kk kl km bi translated">运行优化命令后，现在让我们重新运行初始查询并测量结果:</h1><figure class="ll lm ln lo fd ij er es paragraph-image"><div class="er es nv"><img src="../Images/4cf4447eb14f74a41a670ab90cd2bd06.png" data-original-src="https://miro.medium.com/v2/resize:fit:1064/format:webp/1*cC3JMGhhUrJHBRCbfgalLQ.png"/></div><figcaption class="lp lq et er es lr ls bd b be z dx translated">性能大幅提升。</figcaption></figure><h2 id="c464" class="mq jq hi bd jr mx my mz jv na nb nc jz jb nd ne kd jf nf ng kh jj nh ni kl nj bi translated">通过这一修改，我们的查询只花了 12.8 毫秒，而不是最初的 126 毫秒！</h2><p id="c642" class="pw-post-body-paragraph iq ir hi is b it ko iv iw ix kp iz ja jb kq jd je jf kr jh ji jj ks jl jm jn hb bi translated">与第一个查询相比，速度提高了<strong class="is hj"> 90% </strong>，只是增加了在<code class="du lu lv lw lx b">WHERE</code>子句上使用的索引。</p></div><div class="ab cl lc ld gp le" role="separator"><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh"/></div><div class="hb hc hd he hf"><h1 id="2b3c" class="jp jq hi bd jr js nq ju jv jw nr jy jz ka ns kc kd ke nt kg kh ki nu kk kl km bi translated">这种方法的缺点是增加了表格的大小！</h1><p id="ad61" class="pw-post-body-paragraph iq ir hi is b it ko iv iw ix kp iz ja jb kq jd je jf kr jh ji jj ks jl jm jn hb bi translated">让我们比较一下添加索引前的表<code class="du lu lv lw lx b">posts</code>大小:<strong class="is hj"> 113.6MB </strong>，添加索引后:<strong class="is hj"> 132.6 MB </strong>。<br/>磁盘空间增加了<strong class="is hj"> 17.35% </strong>，所以你要知道索引是有代价的，表中增加的大小(大小因记录/索引数量和字段类型/内容而异)。</p><blockquote class="nw"><p id="41ca" class="nx ny hi bd nz oa ob oc od oe of jn dx translated">根据我的经验，我更希望提高性能，并接受我需要更多的数据库磁盘空间…</p></blockquote></div><div class="ab cl lc ld gp le" role="separator"><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh"/></div><div class="hb hc hd he hf"><blockquote class="nk nl nm"><p id="f804" class="iq ir lj is b it iu iv iw ix iy iz ja nn jc jd je no jg jh ji np jk jl jm jn hb bi translated"><strong class="is hj">注意:</strong>这里显示的所有 SQL 命令对您的数据来说都是绝对安全的，如果您想回滚到以前的状态很容易:只需删除添加的索引并重新运行优化表命令，您的所有表大小都将恢复正常，没有数据丢失……只有速度。</p></blockquote><p id="44dc" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">嗯，我希望这是一个好的阅读，如果这有助于人们实现他们的目标，我会很高兴。</p></div></div>    
</body>
</html>