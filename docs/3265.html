<html>
<head>
<title>The Endpoint Responsibility Checklist</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">端点责任清单</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/the-endpoint-responsibility-checklist-d7763449f44a?source=collection_archive---------1-----------------------#2021-06-04">https://medium.com/nerd-for-tech/the-endpoint-responsibility-checklist-d7763449f44a?source=collection_archive---------1-----------------------#2021-06-04</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="91a8" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">API框架都应该做什么</h2></div><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ix"><img src="../Images/80315a7763e1048c380a565a7d3e53a7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Kgw98LYziYG5v34y3k5WgQ.png"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">🎅还列出了淘气和可爱的APIs图片由<a class="ae jn" href="https://unsplash.com/s/photos/checklist?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的<a class="ae jn" href="https://unsplash.com/@glenncarstenspeters?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Glenn Carstens-Peters </a>拍摄</figcaption></figure><h1 id="a9bb" class="jo jp hi bd jq jr js jt ju jv jw jx jy io jz ip ka ir kb is kc iu kd iv ke kf bi translated">API端点是做什么的？</h1><p id="8a13" class="pw-post-body-paragraph kg kh hi ki b kj kk ij kl km kn im ko kp kq kr ks kt ku kv kw kx ky kz la lb hb bi translated">在我们关于<a class="ae jn" rel="noopener" href="/p/2b57074084d5/"> Clean API架构</a>的系列文章中，我们已经解释了如何在响应HTTP请求时涉及多个层次。概括地说，有两种类型的请求——一种是通过写入数据库改变状态的请求(POST/DELETE/PUT ),另一种是仅仅从数据库返回状态的请求(GET)。</p><p id="df3f" class="pw-post-body-paragraph kg kh hi ki b kj lc ij kl km ld im ko kp le kr ks kt lf kv kw kx lg kz la lb hb bi translated"><em class="lh">(为了简洁起见，当我们从现在开始说POST时，我们隐含的意思是POST/DELETE/PUT)。</em></p><p id="e8e0" class="pw-post-body-paragraph kg kh hi ki b kj lc ij kl km ld im ko kp le kr ks kt lf kv kw kx lg kz la lb hb bi translated">对于获取和发布端点，您必须履行以下职责:</p><h1 id="ea9a" class="jo jp hi bd jq jr js jt ju jv jw jx jy io jz ip ka ir kb is kc iu kd iv ke kf bi translated">端点责任清单</h1><ul class=""><li id="97dd" class="li lj hi ki b kj kk km kn kp lk kt ll kx lm lb ln lo lp lq bi translated">🔲<strong class="ki hj"> RESTful路由</strong>(基于动词和URL模式，我们应该执行哪个端点？)</li><li id="8a35" class="li lj hi ki b kj lr km ls kp lt kt lu kx lv lb ln lo lp lq bi translated">🔲<strong class="ki hj">控制流程</strong>(命令我们执行，也处理错误)</li><li id="77fe" class="li lj hi ki b kj lr km ls kp lt kt lu kx lv lb ln lo lp lq bi translated">🔲<strong class="ki hj">记录</strong>(写出调试和分析的请求信息)</li><li id="4f66" class="li lj hi ki b kj lr km ls kp lt kt lu kx lv lb ln lo lp lq bi translated">🔲<strong class="ki hj">参数提取和强制</strong>(读取输入并存储在变量中)</li><li id="3284" class="li lj hi ki b kj lr km ls kp lt kt lu kx lv lb ln lo lp lq bi translated">🔲<strong class="ki hj">语法验证</strong>(输入的格式是否正确？)</li><li id="c9c2" class="li lj hi ki b kj lr km ls kp lt kt lu kx lv lb ln lo lp lq bi translated">🔲<strong class="ki hj">语义验证</strong>(输入是否符合我们的业务规则？)</li><li id="3ea6" class="li lj hi ki b kj lr km ls kp lt kt lu kx lv lb ln lo lp lq bi translated">🔲<strong class="ki hj">认证</strong>(哪个配置文件提出这个请求？)</li><li id="7c00" class="li lj hi ki b kj lr km ls kp lt kt lu kx lv lb ln lo lp lq bi translated">🔲<strong class="ki hj">授权</strong>(这个配置文件可以访问请求的数据吗？)</li><li id="5b61" class="li lj hi ki b kj lr km ls kp lt kt lu kx lv lb ln lo lp lq bi translated">🔲<strong class="ki hj">演示</strong>(如果正在返回数据，则将数据格式化为适合客户的正确格式)</li></ul><h1 id="0354" class="jo jp hi bd jq jr js jt ju jv jw jx jy io jz ip ka ir kb is kc iu kd iv ke kf bi translated">编写端点责任清单</h1><p id="9fa6" class="pw-post-body-paragraph kg kh hi ki b kj kk ij kl km kn im ko kp kq kr ks kt ku kv kw kx ky kz la lb hb bi translated">我们前面列出的写操作都需要更新像Mysql这样的RDBMS中的列。任何大规模管理过RDBMS系统的人都会告诉你，它们可能是不可靠的——糟糕的查询会导致其他请求变慢，模式更改会<a class="ae jn" href="https://dba.stackexchange.com/questions/21075/way-to-prevent-queries-from-waiting-for-table-level-lock" rel="noopener ugc nofollow" target="_blank">锁定表</a>或长或短的时间，磁盘变慢会导致查询变慢，从而导致线程池耗尽。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es lw"><img src="../Images/0a805a6f740ae5faac6430c5cf7838cb.png" data-original-src="https://miro.medium.com/v2/resize:fit:768/1*xhzQh7-mDie-0bN3D12YNw.gif"/></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">当你有太多的请求时。</figcaption></figure><p id="fed3" class="pw-post-body-paragraph kg kh hi ki b kj lc ij kl km ld im ko kp le kr ks kt lf kv kw kx lg kz la lb hb bi translated">为了防止潜在的数据丢失并减少这些场景对用户的影响，在我们的架构中，所有的写操作都被排队，并由运行在单独的机器(或单独的集群)上的任务执行。我们称这些机器为<strong class="ki hj"> DBWriter </strong>机器<strong class="ki hj">。</strong></p><p id="2efc" class="pw-post-body-paragraph kg kh hi ki b kj lc ij kl km ld im ko kp le kr ks kt lf kv kw kx lg kz la lb hb bi translated">除了读取端点的工作之外，写入端点的其他职责包括:</p><ul class=""><li id="e391" class="li lj hi ki b kj lc km ld kp lx kt ly kx lz lb ln lo lp lq bi translated">🔲<strong class="ki hj">作业配置</strong>(用必要的数据创建一个散列以在后台执行工作)</li><li id="8059" class="li lj hi ki b kj lr km ls kp lt kt lu kx lv lb ln lo lp lq bi translated">🔲<strong class="ki hj">作业排队</strong>(向队列中写入消息，如<a class="ae jn" href="https://aws.amazon.com/sqs/" rel="noopener ugc nofollow" target="_blank"> AWS SQS </a>)</li><li id="5cec" class="li lj hi ki b kj lr km ls kp lt kt lu kx lv lb ln lo lp lq bi translated">🔲<strong class="ki hj">队列处理</strong>(从队列中提取作业配置并处理作业的DBWriter进程)</li><li id="8ff3" class="li lj hi ki b kj lr km ls kp lt kt lu kx lv lb ln lo lp lq bi translated">🔲<strong class="ki hj">状态突变</strong>(写入一个或多个数据源)</li><li id="c270" class="li lj hi ki b kj lr km ls kp lt kt lu kx lv lb ln lo lp lq bi translated">🔲<strong class="ki hj">异步中继</strong>(通过WebSockets或聊天集群向客户端返回写确认)</li></ul><blockquote class="ma"><p id="18dc" class="mb mc hi bd md me mf mg mh mi mj lb dx translated">我们已经确定了端点的至少14项独立职责。</p></blockquote><figure class="ml mm mn mo mp jc er es paragraph-image"><div class="er es mk"><img src="../Images/f52568bfcf71b61df438c6ea99dbf120.png" data-original-src="https://miro.medium.com/v2/resize:fit:542/1*o-D9rLO5V7aA0pqq80qU5g.gif"/></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">是的，这将是测试</figcaption></figure><h1 id="7369" class="jo jp hi bd jq jr js jt ju jv jw jx jy io jz ip ka ir kb is kc iu kd iv ke kf bi translated">连接回清洁</h1><p id="9ac3" class="pw-post-body-paragraph kg kh hi ki b kj kk ij kl km kn im ko kp kq kr ks kt ku kv kw kx ky kz la lb hb bi translated">在我们之前的文章中，我们讨论了干净的API架构。我们现在将解释在我们的Clean API架构中，我们如何以及何时处理上面清单中的每一项职责。</p><h2 id="d81d" class="mq jp hi bd jq mr ms mt ju mu mv mw jy kp mx my ka kt mz na kc kx nb nc ke nd bi translated">GET请求的干净API</h2><p id="a596" class="pw-post-body-paragraph kg kh hi ki b kj kk ij kl km kn im ko kp kq kr ks kt ku kv kw kx ky kz la lb hb bi translated">让我们从在我们的Clean API架构中可视化地识别GET请求的执行路径开始。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ne"><img src="../Images/cab8b1d1431b98f017d16025a13a9d0e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1jr1JjuOBVpJPwQZ1Zqgtw.png"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">用黄色突出显示的路径用于GET请求</figcaption></figure><p id="d40c" class="pw-post-body-paragraph kg kh hi ki b kj lc ij kl km ld im ko kp le kr ks kt lf kv kw kx lg kz la lb hb bi translated">该执行路径中的步骤可以总结为:</p><p id="a539" class="pw-post-body-paragraph kg kh hi ki b kj lc ij kl km ld im ko kp le kr ks kt lf kv kw kx lg kz la lb hb bi translated"><strong class="ki hj">🔵接收</strong> →🟢 <strong class="ki hj">验证(语法)</strong> →🔴<strong class="ki hj">验证(语义)</strong> →🟢 <strong class="ki hj">入队</strong> →🟢 <strong class="ki hj">响应</strong></p><p id="466e" class="pw-post-body-paragraph kg kh hi ki b kj lc ij kl km ld im ko kp le kr ks kt lf kv kw kx lg kz la lb hb bi translated">请求在API服务器上处理。注意验证的两个阶段——一个语法阶段，一个语义阶段。验证后，该作业将排队并向客户端返回一个成功代码。如果失败，则没有作业排队，并向客户端返回一个错误代码。</p><h2 id="b9b1" class="mq jp hi bd jq mr ms mt ju mu mv mw jy kp mx my ka kt mz na kc kx nb nc ke nd bi translated">发布请求的清理API</h2><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ne"><img src="../Images/d93e898ce838a041d8c675dff0b8cc4f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*O5E4kEg5eMJKKCOz2jdnIw.png"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">用黄色突出显示的路径用于POST请求</figcaption></figure><p id="c423" class="pw-post-body-paragraph kg kh hi ki b kj lc ij kl km ld im ko kp le kr ks kt lf kv kw kx lg kz la lb hb bi translated">当API服务器接收到POST请求时，它会将该请求发送到一个队列，在我们的例子中是AWS SQS。稍后，在DBWriter服务器上，执行路径总结如下:</p><p id="a73c" class="pw-post-body-paragraph kg kh hi ki b kj lc ij kl km ld im ko kp le kr ks kt lf kv kw kx lg kz la lb hb bi translated">🟢Dequeue  →🔴<strong class="ki hj">变异</strong> →🟢 <strong class="ki hj">通知</strong></p><h1 id="b226" class="jo jp hi bd jq jr js jt ju jv jw jx jy io jz ip ka ir kb is kc iu kd iv ke kf bi translated">清单x执行路径</h1><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es nf"><img src="../Images/feb1ec68f9ddf67ff03dca8ee648d9e7.png" data-original-src="https://miro.medium.com/v2/resize:fit:630/1*XzI5gJ0i6KzM5DiU0HVuRw.gif"/></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">编写端点应该是</figcaption></figure><p id="b188" class="pw-post-body-paragraph kg kh hi ki b kj lc ij kl km ld im ko kp le kr ks kt lf kv kw kx lg kz la lb hb bi translated">现在让我们将清单与POST请求的两个执行路径联系起来。</p><blockquote class="ma"><p id="1ea8" class="mb mc hi bd md me ng nh ni nj nk lb dx translated">环绕🟢🔴🔵来自我们的执行路径；在每一项下，我们确定了它们针对✅清单的哪些部分。</p></blockquote><h2 id="abba" class="mq jp hi bd jq mr nl mt ju mu nm mw jy kp nn my ka kt no na kc kx np nc ke nd bi translated"><strong class="ak">路径1:请求回执</strong></h2><p id="ad1e" class="pw-post-body-paragraph kg kh hi ki b kj kk ij kl km kn im ko kp kq kr ks kt ku kv kw kx ky kz la lb hb bi translated">在API服务器上</p><ol class=""><li id="a6bf" class="li lj hi ki b kj lc km ld kp lx kt ly kx lz lb nq lo lp lq bi translated">🔵<strong class="ki hj">接收:</strong>将请求路由到正确的<strong class="ki hj">控制器</strong></li></ol><ul class=""><li id="1c84" class="li lj hi ki b kj lc km ld kp lx kt ly kx lz lb ln lo lp lq bi translated">宁静的✅路线</li><li id="46d5" class="li lj hi ki b kj lr km ls kp lt kt lu kx lv lb ln lo lp lq bi translated">控制流量✅</li></ul><p id="6a65" class="pw-post-body-paragraph kg kh hi ki b kj lc ij kl km ld im ko kp le kr ks kt lf kv kw kx lg kz la lb hb bi translated">2.🟢 <strong class="ki hj">验证:</strong>提取输入参数，验证它们的语法，并使用<strong class="ki hj">参数</strong>和<strong class="ki hj">验证器来验证<strong class="ki hj">请求中的概要文件</strong>。</strong>返回在服务层执行操作所需的输入。</p><ul class=""><li id="af77" class="li lj hi ki b kj lc km ld kp lx kt ly kx lz lb ln lo lp lq bi translated">参数提取和强制✅</li><li id="6e77" class="li lj hi ki b kj lr km ls kp lt kt lu kx lv lb ln lo lp lq bi translated">认证✅</li><li id="1080" class="li lj hi ki b kj lr km ls kp lt kt lu kx lv lb ln lo lp lq bi translated">语法验证✅</li></ul><p id="9419" class="pw-post-body-paragraph kg kh hi ki b kj lc ij kl km ld im ko kp le kr ks kt lf kv kw kx lg kz la lb hb bi translated">3.🔴<strong class="ki hj">验证:</strong>使用<strong class="ki hj">服务</strong>根据业务规则验证输入</p><ul class=""><li id="a396" class="li lj hi ki b kj lc km ld kp lx kt ly kx lz lb ln lo lp lq bi translated">语义验证✅</li><li id="38ce" class="li lj hi ki b kj lr km ls kp lt kt lu kx lv lb ln lo lp lq bi translated">授权✅</li></ul><p id="c8ab" class="pw-post-body-paragraph kg kh hi ki b kj lc ij kl km ld im ko kp le kr ks kt lf kv kw kx lg kz la lb hb bi translated">4.🟢 <strong class="ki hj">入队:</strong>配置<strong class="ki hj">作业配置</strong>并将作业入队。</p><ul class=""><li id="3380" class="li lj hi ki b kj lc km ld kp lx kt ly kx lz lb ln lo lp lq bi translated">职务配置✅</li><li id="0229" class="li lj hi ki b kj lr km ls kp lt kt lu kx lv lb ln lo lp lq bi translated">✅的工作入队</li></ul><p id="226d" class="pw-post-body-paragraph kg kh hi ki b kj lc ij kl km ld im ko kp le kr ks kt lf kv kw kx lg kz la lb hb bi translated">5.🟢 <strong class="ki hj">响应:</strong>回传接收确认，在<strong class="ki hj">响应</strong>中带有200 OK状态码，表明写操作已经成功入队，可选JSON数据。</p><ul class=""><li id="9022" class="li lj hi ki b kj lc km ld kp lx kt ly kx lz lb ln lo lp lq bi translated">介绍✅</li></ul><h2 id="c2d5" class="mq jp hi bd jq mr ms mt ju mu mv mw jy kp mx my ka kt mz na kc kx nb nc ke nd bi translated"><strong class="ak">途径2:请求处理</strong></h2><p id="f0cb" class="pw-post-body-paragraph kg kh hi ki b kj kk ij kl km kn im ko kp kq kr ks kt ku kv kw kx ky kz la lb hb bi translated">在DBWriter服务器上</p><ol class=""><li id="a99c" class="li lj hi ki b kj lc km ld kp lx kt ly kx lz lb nq lo lp lq bi translated">🟢 <strong class="ki hj">出列:</strong>接收带有<strong class="ki hj">作业</strong>或<strong class="ki hj">服务</strong>的入队作业</li></ol><ul class=""><li id="e7a2" class="li lj hi ki b kj lc km ld kp lx kt ly kx lz lb ln lo lp lq bi translated">队列处理✅</li></ul><p id="0529" class="pw-post-body-paragraph kg kh hi ki b kj lc ij kl km ld im ko kp le kr ks kt lf kv kw kx lg kz la lb hb bi translated">2.🔴<strong class="ki hj"> Mutate </strong>:通过服务中定义的操作改变数据库</p><ul class=""><li id="85a8" class="li lj hi ki b kj lc km ld kp lx kt ly kx lz lb ln lo lp lq bi translated">状态突变✅</li><li id="1f36" class="li lj hi ki b kj lr km ls kp lt kt lu kx lv lb ln lo lp lq bi translated">✅伐木公司</li></ul><p id="0f2d" class="pw-post-body-paragraph kg kh hi ki b kj lc ij kl km ld im ko kp le kr ks kt lf kv kw kx lg kz la lb hb bi translated">3.🟢 <strong class="ki hj">通知:</strong>向客户端发回异步套接字消息，告知操作成功或失败。</p><ul class=""><li id="55c2" class="li lj hi ki b kj lc km ld kp lx kt ly kx lz lb ln lo lp lq bi translated">异步继电器✅</li></ul><h1 id="1e26" class="jo jp hi bd jq jr js jt ju jv jw jx jy io jz ip ka ir kb is kc iu kd iv ke kf bi translated">接下来</h1><p id="1658" class="pw-post-body-paragraph kg kh hi ki b kj kk ij kl km kn im ko kp kq kr ks kt ku kv kw kx ky kz la lb hb bi translated">在上一节中，我们定义了所有端点都必须完成的操作清单。然后，我们将该清单与我们的Clean API架构所建议的执行路径联系起来。现在我们要去<a class="ae jn" rel="noopener" href="/perry-street-software-engineering/clean-api-example-save-a-favorite-d45ca6aeba4c">看看这在实践中是什么样子</a>。</p><h1 id="4679" class="jo jp hi bd jq jr js jt ju jv jw jx jy io jz ip ka ir kb is kc iu kd iv ke kf bi translated">本系列的更多内容</h1><ul class=""><li id="3060" class="li lj hi ki b kj kk km kn kp lk kt ll kx lm lb ln lo lp lq bi translated"><a class="ae jn" rel="noopener" href="/p/c36044df2ac7/">web API设计的视觉历史</a></li><li id="df7d" class="li lj hi ki b kj lr km ls kp lt kt lu kx lv lb ln lo lp lq bi translated"><a class="ae jn" rel="noopener" href="/p/9d65232e8a24/">web API执行流程的模式</a></li><li id="8a52" class="li lj hi ki b kj lr km ls kp lt kt lu kx lv lb ln lo lp lq bi translated"><a class="ae jn" rel="noopener" href="/p/ad4288a273ce/">面向铁路的编程</a></li><li id="edd3" class="li lj hi ki b kj lr km ls kp lt kt lu kx lv lb ln lo lp lq bi translated"><a class="ae jn" rel="noopener" href="/p/2b57074084d5/">干净的API架构</a></li><li id="e16d" class="li lj hi ki b kj lr km ls kp lt kt lu kx lv lb ln lo lp lq bi translated">端点责任清单←你在这里</li><li id="47d2" class="li lj hi ki b kj lr km ls kp lt kt lu kx lv lb ln lo lp lq bi translated"><a class="ae jn" rel="noopener" href="/perry-street-software-engineering/clean-api-example-save-a-favorite-d45ca6aeba4c">代码示例:保存收藏夹</a></li></ul><h1 id="5c47" class="jo jp hi bd jq jr js jt ju jv jw jx jy io jz ip ka ir kb is kc iu kd iv ke kf bi translated">你可能喜欢的其他系列</h1><p id="f972" class="pw-post-body-paragraph kg kh hi ki b kj kk ij kl km kn im ko kp kq kr ks kt ku kv kw kx ky kz la lb hb bi translated"><a class="ae jn" href="https://proandroiddev.com/android-activity-lifecycle-considered-harmful-98a5b00d287" rel="noopener ugc nofollow" target="_blank"> <strong class="ki hj"> Android活动生命周期被认为是有害的</strong></a><strong class="ki hj">【2021】<br/></strong>Android进程死亡，不可解释的NullPointerExceptions，以及你现在需要的MVVM生命周期</p><p id="90e1" class="pw-post-body-paragraph kg kh hi ki b kj lc ij kl km ld im ko kp le kr ks kt lf kv kw kx lg kz la lb hb bi translated"><a class="ae jn" rel="noopener" href="/swlh/kotlin-in-xcode-swift-in-android-studio-26a4ace6fc72"><strong class="ki hj">Xcode里的Kotlin？安卓工作室</strong>里的swift</a>？<strong class="ki hj"> (2020) </strong> <br/>关于在iOS &amp; Android上使用Clean + MVVM实现一致架构的系列</p><h1 id="8943" class="jo jp hi bd jq jr js jt ju jv jw jx jy io jz ip ka ir kb is kc iu kd iv ke kf bi translated">关于作者</h1><p id="51c8" class="pw-post-body-paragraph kg kh hi ki b kj kk ij kl km kn im ko kp kq kr ks kt ku kv kw kx ky kz la lb hb bi translated">埃里克·西尔弗伯格(Eric Silverberg)是佩里街软件公司(Perry Street Software)的首席执行官，发行LGBTQ+约会应用程序(LGBTQ+ dating apps)和SCRUFF，在全球拥有2000多万会员。</p></div></div>    
</body>
</html>