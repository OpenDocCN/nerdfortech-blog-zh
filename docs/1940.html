<html>
<head>
<title>Swift Leetcode Series: Deepest Leaves Sum</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Swift Leetcode 系列:最深的叶子和</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/swift-leetcode-series-deepest-leaves-sum-b681746565b1?source=collection_archive---------16-----------------------#2021-04-13">https://medium.com/nerd-for-tech/swift-leetcode-series-deepest-leaves-sum-b681746565b1?source=collection_archive---------16-----------------------#2021-04-13</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="dbf7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><a class="ae jd" href="https://leetcode.com/explore/challenge/card/april-leetcoding-challenge-2021/594/week-2-april-8th-april-14th/3704/" rel="noopener ugc nofollow" target="_blank">Swift 中的 Leetcode 1302(中)</a></p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es je"><img src="../Images/978e55490d6dbaed65e077b5ff393491.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KZYq4dO4wcyt9i28jMyL0g.png"/></div></div></figure><div class="jq jr ez fb js jt"><a href="https://theswiftnerd.com/deepest-leaves-sum-leetcode-1302/" rel="noopener  ugc nofollow" target="_blank"><div class="ju ab dw"><div class="jv ab jw cl cj jx"><h2 class="bd hj fi z dy jy ea eb jz ed ef hh bi translated">最深的叶子总和(Leetcode 1302)</h2><div class="ka l"><h3 class="bd b fi z dy jy ea eb jz ed ef dx translated">难度:标签:April Leetcoding 挑战 2021:第 11 天给定一棵二叉树的根，返回…的值之和</h3></div><div class="kb l"><p class="bd b fp z dy jy ea eb jz ed ef dx translated">theswiftnerd.com</p></div></div><div class="kc l"><div class="kd l ke kf kg kc kh jo jt"/></div></div></a></div><p id="8005" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">你也可以在 Swift Nerd 博客上阅读完整的故事，并通过链接找到更多有趣的帖子。</p><h1 id="38f8" class="ki kj hi bd kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf bi translated">问题描述</h1><p id="3111" class="pw-post-body-paragraph if ig hi ih b ii lg ik il im lh io ip iq li is it iu lj iw ix iy lk ja jb jc hb bi translated">给定二叉树的<code class="du ll lm ln lo b"><strong class="ih hj">root</strong></code>，返回<em class="lp">其最深叶</em>的值之和。</p><h1 id="5291" class="ki kj hi bd kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf bi translated">例子</h1><p id="657c" class="pw-post-body-paragraph if ig hi ih b ii lg ik il im lh io ip iq li is it iu lj iw ix iy lk ja jb jc hb bi translated"><strong class="ih hj">例 1 </strong></p><figure class="jf jg jh ji fd jj er es paragraph-image"><div class="er es lq"><img src="../Images/a8947c344d6a25799fffb320637e2cee.png" data-original-src="https://miro.medium.com/v2/resize:fit:546/format:webp/0*-6YRVRLtFaNHRZJV.png"/></div></figure><pre class="jf jg jh ji fd lr lo ls lt aw lu bi"><span id="eb19" class="lv kj hi lo b fi lw lx l ly lz"><strong class="lo hj">Input:</strong> root = [1,2,3,4,5,null,6,7,null,null,null,null,8]<br/><strong class="lo hj">Output:</strong> 15</span></pre><p id="45a9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">例 2 </strong></p><pre class="jf jg jh ji fd lr lo ls lt aw lu bi"><span id="3a63" class="lv kj hi lo b fi lw lx l ly lz"><strong class="lo hj">Input:</strong> root = [6,7,8,2,7,1,3,9,null,1,4,null,null,null,5]<br/><strong class="lo hj">Output:</strong> 19</span></pre><h1 id="9233" class="ki kj hi bd kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf bi translated">限制</h1><ul class=""><li id="2082" class="ma mb hi ih b ii lg im lh iq mc iu md iy me jc mf mg mh mi bi translated"><strong class="ih hj">树中的节点数在</strong> <code class="du ll lm ln lo b"><strong class="ih hj">[1, 104]</strong></code> <strong class="ih hj">范围内。</strong></li><li id="e383" class="ma mb hi ih b ii mj im mk iq ml iu mm iy mn jc mf mg mh mi bi translated"><code class="du ll lm ln lo b"><strong class="ih hj">1 &lt;= Node.val &lt;= 100</strong></code></li></ul><h1 id="58c6" class="ki kj hi bd kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf bi translated">解决办法</h1><p id="7361" class="pw-post-body-paragraph if ig hi ih b ii lg ik il im lh io ip iq li is it iu lj iw ix iy lk ja jb jc hb bi translated">这是经典的树搜索技术的扩展。如果我们仔细观察，因为所有最深的节点也形成最后一级。我们可以使用<strong class="ih hj">广度优先搜索(BFS) </strong>并将该级别中所有节点的总和存储在一个变量中。当我们完成最后一层时，sum 变量将剩下所有最深节点的总和。</p><p id="a63e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">或者，我们也可以使用<strong class="ih hj">深度优先搜索(DFS) </strong>并使用递归遍历到最深的节点。我们可以找到树的高度，然后将树的高度作为参数传递，以检查我们是否在最深的节点，并简单地返回这些节点的值。我们将详细讨论这两种方法。</p><h1 id="2e34" class="ki kj hi bd kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf bi translated">横向优先搜索</h1><p id="8e9c" class="pw-post-body-paragraph if ig hi ih b ii lg ik il im lh io ip iq li is it iu lj iw ix iy lk ja jb jc hb bi translated">BFS 方法包括使用一种叫做<strong class="ih hj"> Queue(q) </strong>的数据结构，这样我们就可以按照正确的顺序处理树的节点。队列按照先进先出(FIFO)的顺序运行，所以插入会在末尾，从前面移除。我们可以使用该属性，并通过在每次迭代后查找队列中的元素计数来计算下一级要处理的项目数。这是一个棘手的步骤，也是问题的主要症结。为了找到级别的总和，我们可以在迭代队列时将值相加，并在每次遍历后将总和重置为 0。处理完所有级别后，<strong class="ih hj"><em class="lp">sum 变量将剩下最后一个级别</em> </strong>的总和，因为我们<strong class="ih hj"> <em class="lp">只在下一次正向迭代</em> </strong>中重置总和。</p><figure class="jf jg jh ji fd jj"><div class="bz dy l di"><div class="mo mp l"/></div></figure><p id="9ace" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在，在队列为空之后，levelSum 将拥有所有最深层的节点值，我们只需要返回它；).</p><h1 id="da51" class="ki kj hi bd kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf bi translated">深度优先搜索</h1><p id="0d9e" class="pw-post-body-paragraph if ig hi ih b ii lg ik il im lh io ip iq li is it iu lj iw ix iy lk ja jb jc hb bi translated">另一个解决问题的方法是先找到树的最大深度。在下一步中，我们可以从根和每个递归调用开始我们的递归，增加当前级别并传递最大深度(在步骤 1 中计算)。当级别等于最大深度时，我们可以从递归步骤返回节点值并将它们相加。为了计算树的高度，我们可以使用简单的递归函数。</p><figure class="jf jg jh ji fd jj"><div class="bz dy l di"><div class="mo mp l"/></div></figure><h1 id="7b45" class="ki kj hi bd kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf bi translated">密码</h1><h2 id="7978" class="lv kj hi bd kk mq mr ms ko mt mu mv ks iq mw mx kw iu my mz la iy na nb le nc bi translated">使用 BFS 方法</h2><figure class="jf jg jh ji fd jj"><div class="bz dy l di"><div class="mo mp l"/></div></figure><h2 id="81a1" class="lv kj hi bd kk mq mr ms ko mt mu mv ks iq mw mx kw iu my mz la iy na nb le nc bi translated">使用 DFS</h2><figure class="jf jg jh ji fd jj"><div class="bz dy l di"><div class="mo mp l"/></div></figure><h1 id="0da4" class="ki kj hi bd kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf bi translated">复杂性分析</h1><p id="3dd5" class="pw-post-body-paragraph if ig hi ih b ii lg ik il im lh io ip iq li is it iu lj iw ix iy lk ja jb jc hb bi translated">时间复杂度= <strong class="ih hj"> O(V) </strong>其中 V 是顶点(图)或节点(树)的总数</p><p id="3e8a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">空间占用= <strong class="ih hj"> O(V) </strong>，因为在最坏的情况下，我们可以让所有级别的节点同时进入队列。</p></div><div class="ab cl nd ne gp nf" role="separator"><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni"/></div><div class="hb hc hd he hf"><p id="4a32" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">感谢您的阅读。如果你喜欢这篇文章，并发现它很有用，请分享并像野火一样传播它！</p><p id="0ef3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">你可以在<a class="ae jd" href="https://theswiftnerd.com/" rel="noopener ugc nofollow" target="_blank">网站</a>|<a class="ae jd" href="https://www.linkedin.com/in/varunrathi28/" rel="noopener ugc nofollow" target="_blank">LinkedIn</a>|<a class="ae jd" href="https://github.com/varunrathi28" rel="noopener ugc nofollow" target="_blank">Github</a>上找到我</p></div></div>    
</body>
</html>