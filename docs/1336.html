<html>
<head>
<title>Elegant Patterns to execute work concurrently using Completion Service [Java]</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用完成服务并发执行工作的优雅模式[Java]</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/elegant-patterns-to-execute-work-concurrently-using-completion-service-java-1bee26f186b9?source=collection_archive---------11-----------------------#2021-03-14">https://medium.com/nerd-for-tech/elegant-patterns-to-execute-work-concurrently-using-completion-service-java-1bee26f186b9?source=collection_archive---------11-----------------------#2021-03-14</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/3a151cba23eeea5899a69e1e91050373.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*d0D3kMPG-TOHr2g-.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">礼貌:<a class="ae iu" href="https://www.baeldung.com/" rel="noopener ugc nofollow" target="_blank">https://www.baeldung.com/</a></figcaption></figure><h1 id="cbeb" class="iv iw hi bd ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js bi translated">用例分析</h1><p id="9c43" class="pw-post-body-paragraph jt ju hi jv b jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq hb bi translated">假设您有一个用例，其中有一个来自用户的<code class="du kr ks kt ku b">input of N numbers</code>，您需要获取一个<em class="kv">昂贵的数学函数</em> <code class="du kr ks kt ku b"><em class="kv"> f(x) </em></code>对这些数字进行计算的结果，并返回任何首先完成的<code class="du kr ks kt ku b">first K</code>。</p><p id="1100" class="pw-post-body-paragraph jt ju hi jv b jw kw jy jz ka kx kc kd ke ky kg kh ki kz kk kl km la ko kp kq hb bi translated">此外，计算昂贵函数结果的逻辑是通过与远程服务的 HTTP 交互获得的，比如说<code class="du kr ks kt ku b">Math Service</code></p><p id="bcdd" class="pw-post-body-paragraph jt ju hi jv b jw kw jy jz ka kx kc kd ke ky kg kh ki kz kk kl km la ko kp kq hb bi translated"><strong class="jv hj">的目标</strong>就是用<code class="du kr ks kt ku b"> minimal latency overhead</code>来解决这个问题。</p><figure class="lc ld le lf fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lb"><img src="../Images/c32abaf4ce753d8d20d184eac38dcf99.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*r-8TmOjmih3cYBPR__yYOg.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">高级用例</figcaption></figure><p id="8656" class="pw-post-body-paragraph jt ju hi jv b jw kw jy jz ka kx kc kd ke ky kg kh ki kz kk kl km la ko kp kq hb bi translated">我们如何着手解决这个问题？先从提问开始。</p></div><div class="ab cl lg lh gp li" role="separator"><span class="lj bw bk lk ll lm"/><span class="lj bw bk lk ll lm"/><span class="lj bw bk lk ll"/></div><div class="hb hc hd he hf"><h2 id="40db" class="ln iw hi bd ix lo lp lq jb lr ls lt jf ke lu lv jj ki lw lx jn km ly lz jr ma bi translated">描述我们的工作量</h2><p id="b3aa" class="pw-post-body-paragraph jt ju hi jv b jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq hb bi translated">在我们提出任何解决方案之前，分析我们正在处理的工作量是很重要的。</p><ul class=""><li id="3589" class="mb mc hi jv b jw kw ka kx ke md ki me km mf kq mg mh mi mj bi translated">工作受 I/O 限制，不受计算限制。</li><li id="3608" class="mb mc hi jv b jw mk ka ml ke mm ki mn km mo kq mg mh mi mj bi translated">输入将是一个数字列表，可以建模为<code class="du kr ks kt ku b">Iterable&lt;Work&gt;</code></li><li id="6378" class="mb mc hi jv b jw mk ka ml ke mm ki mn km mo kq mg mh mi mj bi translated">我们最有可能使用 HTTP 进行远程服务通信。</li><li id="d19d" class="mb mc hi jv b jw mk ka ml ke mm ki mn km mo kq mg mh mi mj bi translated">结果的无序执行/完成是完全可以接受的。</li><li id="d812" class="mb mc hi jv b jw mk ka ml ke mm ki mn km mo kq mg mh mi mj bi translated">需要一组有限的结果<code class="du kr ks kt ku b">K ≤ N</code>。</li></ul></div><div class="ab cl lg lh gp li" role="separator"><span class="lj bw bk lk ll lm"/><span class="lj bw bk lk ll lm"/><span class="lj bw bk lk ll"/></div><div class="hb hc hd he hf"><h2 id="4104" class="ln iw hi bd ix lo lp lq jb lr ls lt jf ke lu lv jj ki lw lx jn km ly lz jr ma bi translated">利用域服务。</h2><p id="d2ae" class="pw-post-body-paragraph jt ju hi jv b jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq hb bi translated">现在是了解该领域更多信息的好时机。我们需要与<code class="du kr ks kt ku b">Math Service</code>的维护者和利益相关者进行一次引人入胜的讨论。</p><ul class=""><li id="8620" class="mb mc hi jv b jw kw ka kx ke md ki me km mf kq mg mh mi mj bi translated">有什么类型的输入可以用来计算吗？</li><li id="8595" class="mb mc hi jv b jw mk ka ml ke mm ki mn km mo kq mg mh mi mj bi translated">我们能否<code class="du kr ks kt ku b">pre filter</code>较慢的输入，以便输入大小<code class="du kr ks kt ku b">N = K</code></li><li id="e940" class="mb mc hi jv b jw mk ka ml ke mm ki mn km mo kq mg mh mi mj bi translated"><code class="du kr ks kt ku b">Math Service</code>可靠吗？如果<em class="kv">是</em>，那又如何？如果<em class="kv">没有</em>，有何不可。</li><li id="63eb" class="mb mc hi jv b jw mk ka ml ke mm ki mn km mo kq mg mh mi mj bi translated">在某个输入之后，<code class="du kr ks kt ku b"> Math Service</code>是否降级/速率限制请求？</li><li id="0e8b" class="mb mc hi jv b jw mk ka ml ke mm ki mn km mo kq mg mh mi mj bi translated">我们是否知道用户将给出什么样的输入，以便<code class="du kr ks kt ku b">Math Service</code>或我们的服务能够<code class="du kr ks kt ku b">precompute / cache</code>得到结果？</li></ul><p id="5404" class="pw-post-body-paragraph jt ju hi jv b jw kw jy jz ka kx kc kd ke ky kg kh ki kz kk kl km la ko kp kq hb bi translated">让我们假设以上所有问题的答案都是<code class="du kr ks kt ku b">No</code>。上面的任何<code class="du kr ks kt ku b">Yes</code>都会使问题变得更简单，并增加更多优化的空间。</p></div><div class="ab cl lg lh gp li" role="separator"><span class="lj bw bk lk ll lm"/><span class="lj bw bk lk ll lm"/><span class="lj bw bk lk ll"/></div><div class="hb hc hd he hf"><h2 id="7bce" class="ln iw hi bd ix lo lp lq jb lr ls lt jf ke lu lv jj ki lw lx jn km ly lz jr ma bi translated">积木</h2><ul class=""><li id="6028" class="mb mc hi jv b jw jx ka kb ke mp ki mq km mr kq mg mh mi mj bi translated">我们知道工作负载可以并行化。因此，多线程。</li><li id="2dfb" class="mb mc hi jv b jw mk ka ml ke mm ki mn km mo kq mg mh mi mj bi translated">我们知道我们需要一个<strong class="jv hj">线程池执行器</strong>的实现来有效地管理线程。让我们从固定线程池开始。</li></ul><figure class="lc ld le lf fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ms"><img src="../Images/853ec30f523204e97425ef552224af6e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*504Nk8R2qOCiJSyiO-zjGA.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">伪代码。在固定的执行者中提交工作。不是最有效的方法。</figcaption></figure><p id="7d71" class="pw-post-body-paragraph jt ju hi jv b jw kw jy jz ka kx kc kd ke ky kg kh ki kz kk kl km la ko kp kq hb bi translated">这个管用。但是，有一些明显的<strong class="jv hj">问题</strong>:</p><ul class=""><li id="bfa9" class="mb mc hi jv b jw kw ka kx ke md ki me km mf kq mg mh mi mj bi translated">我们需要<code class="du kr ks kt ku b">block</code>获取订单中每个调用的结果。这意味着如果用户想要一批<code class="du kr ks kt ku b">20</code>的任何<code class="du kr ks kt ku b">10</code>结果，并且如果第一个请求是最慢的，那么计算整批的时间就会受到影响。</li><li id="52fd" class="mb mc hi jv b jw mk ka ml ke mm ki mn km mo kq mg mh mi mj bi translated">我们没有利用我们不需要按顺序获得结果这一事实。任何订单都可以。</li></ul><p id="a710" class="pw-post-body-paragraph jt ju hi jv b jw kw jy jz ka kx kc kd ke ky kg kh ki kz kk kl km la ko kp kq hb bi translated">是否有一个<code class="du kr ks kt ku b">Executor</code>的实现，当任务被提供给它时，结果按照它们完成的顺序<strong class="jv hj">放置在队列中</strong>和<strong class="jv hj">而不是按照它们被提交的顺序<strong class="jv hj">放置在队列中</strong>？</strong></p><p id="8a8b" class="pw-post-body-paragraph jt ju hi jv b jw kw jy jz ka kx kc kd ke ky kg kh ki kz kk kl km la ko kp kq hb bi translated">有没有一个实现可以在任务完成时将结果放到一个队列中，这样我们就可以获取<code class="du kr ks kt ku b">first K</code>并完成任务了？</p><figure class="lc ld le lf fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mt"><img src="../Images/aad903dc58cb2e6fffb778f9a61f5a4c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BjqWLnd6L24N5YSL-6XsFQ.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">理想的执行者服务按照“完成”顺序而不是“提交”顺序排队“完成”任务</figcaption></figure><h2 id="d101" class="ln iw hi bd ix lo lp lq jb lr ls lt jf ke lu lv jj ki lw lx jn km ly lz jr ma bi translated">遗嘱执行人完成服务</h2><p id="2abc" class="pw-post-body-paragraph jt ju hi jv b jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq hb bi translated"><a class="ae iu" href="https://docs.oracle.com/javase/7/docs/api/java/util/concurrent/ExecutorCompletionService.html" rel="noopener ugc nofollow" target="_blank">执行人完成服务</a>正是如此。</p><p id="8f72" class="pw-post-body-paragraph jt ju hi jv b jw kw jy jz ka kx kc kd ke ky kg kh ki kz kk kl km la ko kp kq hb bi translated">它没有试图找出哪个任务已经完成(以获得结果)，而是要求<code class="du kr ks kt ku b">CompletionService</code>实例在结果可用时返回结果。</p><p id="ac33" class="pw-post-body-paragraph jt ju hi jv b jw kw jy jz ka kx kc kd ke ky kg kh ki kz kk kl km la ko kp kq hb bi translated">这就是我们想要的。让我们把积木编码出来。</p></div><div class="ab cl lg lh gp li" role="separator"><span class="lj bw bk lk ll lm"/><span class="lj bw bk lk ll lm"/><span class="lj bw bk lk ll"/></div><div class="hb hc hd he hf"><h2 id="a705" class="ln iw hi bd ix lo lp lq jb lr ls lt jf ke lu lv jj ki lw lx jn km ly lz jr ma bi translated">数学服务:</h2><p id="62df" class="pw-post-body-paragraph jt ju hi jv b jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq hb bi translated">我们不必太担心这里的底层细节。为了模拟远程交互上的调用，让我们在输入上添加一个随机延迟。</p><figure class="lc ld le lf fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mu"><img src="../Images/6db94a5d48055de09ff5896cd8506ca5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BXa3kWoCb4fFxviC1vag3w.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">我们的数学服务接口。简单。太美了。</figcaption></figure><figure class="lc ld le lf fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mv"><img src="../Images/7627fd0faa81c5ddaf1b0ac6d635a8ba.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*w7MMyCCrtknDK6oKKM0Nxg.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">我们只是在随机延迟后返回相同的数字。模拟真实呼叫中的网络延迟。</figcaption></figure><h2 id="5552" class="ln iw hi bd ix lo lp lq jb lr ls lt jf ke lu lv jj ki lw lx jn km ly lz jr ma bi translated">工作执行者</h2><p id="6c93" class="pw-post-body-paragraph jt ju hi jv b jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq hb bi translated">这是完成实际工作的地方。这里，我们有一个对<code class="du kr ks kt ku b">Math Service</code>的依赖注入，并向该方法公开一个<code class="du kr ks kt ku b">API</code>。</p><figure class="lc ld le lf fd ij"><div class="bz dy l di"><div class="mw mx l"/></div></figure><h2 id="e855" class="ln iw hi bd ix lo lp lq jb lr ls lt jf ke lu lv jj ki lw lx jn km ly lz jr ma bi translated">驱动程序</h2><ul class=""><li id="4d2a" class="mb mc hi jv b jw jx ka kb ke mp ki mq km mr kq mg mh mi mj bi translated">初始化驱动程序中的依赖项和被依赖项。</li><li id="8f78" class="mb mc hi jv b jw mk ka ml ke mm ki mn km mo kq mg mh mi mj bi translated">输出给定输入的结果。</li></ul><figure class="lc ld le lf fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es my"><img src="../Images/fa10182728bdead36e5abe1e985f1fad.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*aNucyMtjg_-5rj9zCBdcnQ.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">我们的司机。我们想要给定列表中的前 3 个。</figcaption></figure><p id="de76" class="pw-post-body-paragraph jt ju hi jv b jw kw jy jz ka kx kc kd ke ky kg kh ki kz kk kl km la ko kp kq hb bi translated">让我们看看<strong class="jv hj">输出</strong>。注意按顺序提交给<strong class="jv hj">的第一个任务是<strong class="jv hj">而不是</strong>第一个完成的。这是因为每个都有随机延迟，我们处理<code class="du kr ks kt ku b">first available results.</code></strong></p><figure class="lc ld le lf fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mz"><img src="../Images/2056a24633f3ea729faf45295bf77597.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5_-vr9jTVt8B3FhuVuGTYg.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">我们想要达到的目标。返回最先完成的 top K。</figcaption></figure><p id="1e47" class="pw-post-body-paragraph jt ju hi jv b jw kw jy jz ka kx kc kd ke ky kg kh ki kz kk kl km la ko kp kq hb bi translated">如果我们再次运行，我们可能会注意到不同的结果。</p><figure class="lc ld le lf fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es na"><img src="../Images/410a69c417b0bcfc6346092fceead6e5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pFPlTlJu2nW9tjlSaN7pSA.png"/></div></div></figure></div><div class="ab cl lg lh gp li" role="separator"><span class="lj bw bk lk ll lm"/><span class="lj bw bk lk ll lm"/><span class="lj bw bk lk ll"/></div><div class="hb hc hd he hf"><h2 id="00a3" class="ln iw hi bd ix lo lp lq jb lr ls lt jf ke lu lv jj ki lw lx jn km ly lz jr ma bi translated">一般化</h2><p id="7cfc" class="pw-post-body-paragraph jt ju hi jv b jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq hb bi translated">这很好。如果现在有一个类似的需求，但是是针对<code class="du kr ks kt ku b">User Service</code>而不是<code class="du kr ks kt ku b">Math Service</code>呢？比方说，我们想要用户的<code class="du kr ks kt ku b">first K payment methods</code>，并在 UI <em class="kv"> </em>  <em class="kv">(结账页面)</em>上显示结果</p><p id="156b" class="pw-post-body-paragraph jt ju hi jv b jw kw jy jz ka kx kc kd ke ky kg kh ki kz kk kl km la ko kp kq hb bi translated">你注意到这里有一个<strong class="jv hj">图案吗？我们将工作分成块并提交给执行程序，然后循环查找第一个<strong class="jv hj"> K </strong>。我们不应该担心 executor 服务的低水平的<code class="du kr ks kt ku b">take</code>/<code class="du kr ks kt ku b">submit</code>API。</strong></p><blockquote class="nb nc nd"><p id="8efe" class="jt ju kv jv b jw kw jy jz ka kx kc kd ne ky kg kh nf kz kk kl ng la ko kp kq hb bi translated">确实有。</p></blockquote><ul class=""><li id="0d5f" class="mb mc hi jv b jw kw ka kx ke md ki me km mf kq mg mh mi mj bi translated"><code class="du kr ks kt ku b">Define an iterable / stream of input</code>在其上工作将被分割并提交给执行者。</li><li id="ee6d" class="mb mc hi jv b jw mk ka ml ke mm ki mn km mo kq mg mh mi mj bi translated">为 iterable 中的每个元素创建一个任务。这指定了实际工作。</li><li id="1220" class="mb mc hi jv b jw mk ka ml ke mm ki mn km mo kq mg mh mi mj bi translated"><code class="du kr ks kt ku b">Specifying the count of results</code>那是意料之中的。并非所有方法都要求完成所有子事件。这将是参数<strong class="jv hj"> K </strong></li><li id="cdf6" class="mb mc hi jv b jw mk ka ml ke mm ki mn km mo kq mg mh mi mj bi translated"><code class="du kr ks kt ku b">Implement a collector</code>用于收集中间结果并返回最终响应。它可能是一个<em class="kv">列表，一个</em>集合或者其他什么。</li></ul><p id="06f9" class="pw-post-body-paragraph jt ju hi jv b jw kw jy jz ka kx kc kd ke ky kg kh ki kz kk kl km la ko kp kq hb bi translated">让我们定义一个整个代码库都能受益的<strong class="jv hj">接口</strong>。</p><figure class="lc ld le lf fd ij"><div class="bz dy l di"><div class="mw mx l"/></div></figure><p id="61db" class="pw-post-body-paragraph jt ju hi jv b jw kw jy jz ka kx kc kd ke ky kg kh ki kz kk kl km la ko kp kq hb bi translated">有了上面的接口，我们可以像下面这样优雅地为我们以前的数学服务解决方案建模。</p><figure class="lc ld le lf fd ij"><div class="bz dy l di"><div class="mw mx l"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">使用界面解决我们的问题。</figcaption></figure><p id="1c8a" class="pw-post-body-paragraph jt ju hi jv b jw kw jy jz ka kx kc kd ke ky kg kh ki kz kk kl km la ko kp kq hb bi translated">仅此而已。使用由<code class="du kr ks kt ku b">Concurrent Work Executor</code>支持的<code class="du kr ks kt ku b">splitJoin</code>抽象，我们的应用程序可以从不知道底层细节中获益。这又是输出。</p><figure class="lc ld le lf fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es nh"><img src="../Images/706132cfa22598cab0a7cb8d2782e690.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LG4tPqyC3Awfu5V_Qv5vsg.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">我们得到类似的输出。但是现在我们有了一个很好的抽象。</figcaption></figure><p id="13f4" class="pw-post-body-paragraph jt ju hi jv b jw kw jy jz ka kx kc kd ke ky kg kh ki kz kk kl km la ko kp kq hb bi translated">获取<code class="du kr ks kt ku b">top K Payment methods</code>现在变得容易了。</p><figure class="lc ld le lf fd ij"><div class="bz dy l di"><div class="mw mx l"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">我们如何获取前 K 个付款方式的详细信息</figcaption></figure></div><div class="ab cl lg lh gp li" role="separator"><span class="lj bw bk lk ll lm"/><span class="lj bw bk lk ll lm"/><span class="lj bw bk lk ll"/></div><div class="hb hc hd he hf"><h2 id="ec9b" class="ln iw hi bd ix lo lp lq jb lr ls lt jf ke lu lv jj ki lw lx jn km ly lz jr ma bi translated">接口实现:无序并发工作执行器</h2><p id="752c" class="pw-post-body-paragraph jt ju hi jv b jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq hb bi translated">难题的最后一部分是实现并发工作执行器接口。我们可以有多种实现。一个可以无序处理结果<em class="kv">一个可以有序处理结果</em>等等。</p><ul class=""><li id="65ad" class="mb mc hi jv b jw kw ka kx ke md ki me km mf kq mg mh mi mj bi translated">该执行器将其任务提交到一个<code class="du kr ks kt ku b">newCachedThreadPool</code>中，这可以进一步参数化。有些可能需要固定的线程池。</li><li id="b847" class="mb mc hi jv b jw mk ka ml ke mm ki mn km mo kq mg mh mi mj bi translated"><code class="du kr ks kt ku b">Shuts down the pool</code>立即避免更多的工作。</li><li id="d163" class="mb mc hi jv b jw mk ka ml ke mm ki mn km mo kq mg mh mi mj bi translated">使用完成服务(阻塞完成队列)处理到达的<code class="du kr ks kt ku b">non null events of completion results </code></li><li id="f9ba" class="mb mc hi jv b jw mk ka ml ke mm ki mn km mo kq mg mh mi mj bi translated">它等待尽可能多的需要完成的任务。</li><li id="8881" class="mb mc hi jv b jw mk ka ml ke mm ki mn km mo kq mg mh mi mj bi translated">当任何一个<code class="du kr ks kt ku b">future#get</code>失效时</li></ul><blockquote class="nb nc nd"><p id="e8d7" class="jt ju kv jv b jw kw jy jz ka kx kc kd ne ky kg kh nf kz kk kl ng la ko kp kq hb bi translated">如果你不要第一个 K 而是要整个结果呢？<br/>你只需将 K 设为整个输入的大小。</p></blockquote><p id="0cbe" class="pw-post-body-paragraph jt ju hi jv b jw kw jy jz ka kx kc kd ke ky kg kh ki kz kk kl km la ko kp kq hb bi translated">这应该很容易实现。我在必要的地方添加了相关的评论。请随意跳过这一步或自行实现。</p><figure class="lc ld le lf fd ij"><div class="bz dy l di"><div class="mw mx l"/></div></figure></div><div class="ab cl lg lh gp li" role="separator"><span class="lj bw bk lk ll lm"/><span class="lj bw bk lk ll lm"/><span class="lj bw bk lk ll"/></div><div class="hb hc hd he hf"><h1 id="e921" class="iv iw hi bd ix iy ni ja jb jc nj je jf jg nk ji jj jk nl jm jn jo nm jq jr js bi translated">结论</h1><ul class=""><li id="3415" class="mb mc hi jv b jw jx ka kb ke mp ki mq km mr kq mg mh mi mj bi translated">确定工作量</li><li id="20a0" class="mb mc hi jv b jw mk ka ml ke mm ki mn km mo kq mg mh mi mj bi translated">尽可能地利用这个领域。</li><li id="4217" class="mb mc hi jv b jw mk ka ml ke mm ki mn km mo kq mg mh mi mj bi translated">选择正确的执行者服务实现和正确的执行者。</li><li id="d294" class="mb mc hi jv b jw mk ka ml ke mm ki mn km mo kq mg mh mi mj bi translated">围绕它建立一个有意义的抽象。</li><li id="eca0" class="mb mc hi jv b jw mk ka ml ke mm ki mn km mo kq mg mh mi mj bi translated">记录接口以及它们如何提供价值。</li></ul><blockquote class="nb nc nd"><p id="b587" class="jt ju kv jv b jw kw jy jz ka kx kc kd ne ky kg kh nf kz kk kl ng la ko kp kq hb bi translated">完整的要点和单元测试可以在这里看到<a class="ae iu" href="https://gist.github.com/isopropylcyanide/b345af36179ee522d4b2152a502e174c" rel="noopener ugc nofollow" target="_blank">。<br/>就这么定了。希望这一块增值。欢迎建设性的反馈:)</a></p></blockquote></div></div>    
</body>
</html>