<html>
<head>
<title>Protobuf — What &amp; Why?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Protobuf —什么&amp;为什么？</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/protobuf-what-why-fcb324a64564?source=collection_archive---------0-----------------------#2021-07-08">https://medium.com/nerd-for-tech/protobuf-what-why-fcb324a64564?source=collection_archive---------0-----------------------#2021-07-08</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="8a1c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Protobuf 是 Google 精心制作的二进制消息格式，与 JSON &amp; XML 等其他消息格式相比，它是高效的。</p><p id="6ece" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">但是为什么 Protobuf 效率高呢？从 JSON/XML 消息格式转移到 Protobuf 是不是更好的选择？要回答这些问题，让我们深入了解 Protobuf 并理解它的工作原理。</p><p id="5c15" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们都知道 JSON，这是在 web 应用程序中传输消息的最流行的消息格式。JSON 是人类可读的，与 XML 相比是高效的，并且易于使用。JSON 也在 NodeJS 这样的后端框架和 Chrome 这样的客户端应用程序上得到原生支持。这使得 JSON 序列化和反序列化在 Javascript 环境中变得越来越快。</p><p id="969f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">既然 JSON 已经做得很好了，我们为什么还要学习一种新的消息格式呢？看看以下几点是否能说服你。</p><ol class=""><li id="17b1" class="jd je hi ih b ii ij im in iq jf iu jg iy jh jc ji jj jk jl bi translated">Protobuf 因为它已经是二进制的，所以序列化和反序列化非常快，而且消息的大小也比 JSON &amp; XML 小(我们将在本文的最后一节了解更多)。此外，打开服务器压缩后，Protobuf 的有效负载会变得更小。所以有了 Protobuf，我们的 web 应用程序可以更快地请求和响应！</li><li id="eb1f" class="jd je hi ih b ii jm im jn iq jo iu jp iy jq jc ji jj jk jl bi translated">JSON 不允许对消息进行严格的模式定义。这可能不是一个大问题，因为消息验证可以在客户机或服务器上进行。但是，比方说，多个微服务通过一个像 Kafka 这样的使用 JSON 消息的消息代理相互交互。当生产者想要更新一个特定的 JSON 属性时会发生什么？这可能会迫使我们改变大型应用程序中成千上万消费者的验证逻辑，对吗？我们可以在 Kafka 中使用 Protobuf 和模式注册表来解决这个问题。</li><li id="7f10" class="jd je hi ih b ii jm im jn iq jo iu jp iy jq jc ji jj jk jl bi translated">使用 Protobuf，开发工作量要小得多，因为协议缓冲编译器自动为许多流行语言的序列化和反序列化消息生成代码。</li></ol><p id="61da" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果以上几点不能让你信服，也许你可以考虑学习 Protobuf 作为额外的工具。我在哪里看过，学习新的东西可以让你的大脑肌肉保持活跃！:)</p><h1 id="b812" class="jr js hi bd jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko bi translated">为什么是 Protobuf？</h1><p id="3486" class="pw-post-body-paragraph if ig hi ih b ii kp ik il im kq io ip iq kr is it iu ks iw ix iy kt ja jb jc hb bi translated">如下图所示，假设客户下订单后，订单服务通过消息队列将订单细节发送给库存服务。这个订单详细信息消息将存储在消息队列中，库存服务异步轮询订单详细信息并对其进行处理。</p><figure class="kv kw kx ky fd kz er es paragraph-image"><div role="button" tabindex="0" class="la lb di lc bf ld"><div class="er es ku"><img src="../Images/3389e2a73ae1b21301caee1a9de315bd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*88fqiwVGx0vv0wcoyLdNzQ.png"/></div></div><figcaption class="lg lh et er es li lj bd b be z dx translated">订单和库存系统之间的通信</figcaption></figure><p id="9931" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">对于像亚马逊这样一天处理超过 100 万个订单的网站，服务之间的数据传输需要更快，并且应该消耗更少的带宽。这里的目标是通过减少网络上传输的数据量来提高吞吐量和减少延迟。在我们的示例中，我们应该能够以更少的网络带宽和消息队列中每条消息的最小存储利用率，尽可能快地将消息从订单服务发送到库存服务。</p><p id="3e82" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们试着找到解决这个问题的方法。</p><p id="0eb4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">尝试#1 <br/> </strong>当我们使用 XML 作为通信的消息类型时，通过网络传输消息所需的带宽将会很大，因为其冗余结构会占用大量带宽，如下所示。我们可能还需要大量空间来将这些 XML 数据存储在消息队列中。</p><pre class="kv kw kx ky fd lk ll lm ln aw lo bi"><span id="5d01" class="lp js hi ll b fi lq lr l ls lt">&lt;root&gt;<br/>  &lt;orderId&gt;1&lt;/orderId&gt;<br/>  &lt;customerId&gt;123&lt;/customerId&gt;<br/>  &lt;items&gt;987&lt;/items&gt;<br/>  &lt;items&gt;988&lt;/items&gt;<br/>  &lt;couponCode&gt;ALLFREE&lt;/couponCode&gt;<br/>  &lt;paymentMode&gt;CASH&lt;/paymentMode&gt;<br/>  &lt;shippingAddress&gt;<br/>    &lt;name&gt;Alice&lt;/name&gt;<br/>    &lt;address&gt;xyz street&lt;/address&gt;<br/>    &lt;pincode&gt;111111&lt;/pincode&gt;<br/>  &lt;/shippingAddress&gt;<br/>&lt;/root&gt;</span></pre><p id="2a07" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">对于一条消息来说，这是很大的数据量。对于每天接收数百万订单的 Amazon 来说，XML 作为消息类型可能无法很好地扩展。</p><p id="2db3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">尝试#2 <br/> </strong>我们为什么不试试 JSON？JSON 是一种非常流行的消息格式，被广泛使用。尽管与 XML 相比，JSON 占用的空间和网络带宽更少，但作为一种基于文本的消息格式，它也占用了更多的空间和带宽。我们可以做得更好。</p><pre class="kv kw kx ky fd lk ll lm ln aw lo bi"><span id="2aa2" class="lp js hi ll b fi lq lr l ls lt">{<br/>    "orderId": 1,<br/>    "customerId": 123,<br/>    "items": [987, 988],<br/>    "couponCode": "ALLFREE",<br/>    "paymentMode": "CASH",<br/>    "shippingAddress": {<br/>        "name": "Alice",<br/>        "address": "xyz street",<br/>        "pincode": "111111"<br/>    } <br/>}</span></pre><p id="1c85" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">尝试#3 <br/> </strong>协议缓冲区以二进制格式在网络上发送消息。因为消息是二进制的，所以它需要较少的空间和带宽来传输。下面显示的是通过网络传输的订单详细信息。</p><pre class="kv kw kx ky fd lk ll lm ln aw lo bi"><span id="3298" class="lp js hi ll b fi lq lr l ls lt">8,1,16,123,26,4,219,7,220,7,34,7,65,76,76,70,82,69,69,40,1,50,27,10,5,65,108,105,99,101,18,10,120,121,122,32,115,116,114,101,101,116,26,6,49,49,49,49,49,49</span></pre><p id="b6c6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">与 JSON 和 XML 相比，协议缓冲区由于其较小的尺寸，可以很好地扩展以通过网络传输数百万条消息。</p><p id="35b4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在我们知道了问题的解决方案是使用协议缓冲区，我们可能会有以下问题。</p><ol class=""><li id="5475" class="jd je hi ih b ii ij im in iq jf iu jg iy jh jc ji jj jk jl bi translated">我们如何将我们的域对象(即订单消息)转换成二进制格式？</li><li id="1601" class="jd je hi ih b ii jm im jn iq jo iu jp iy jq jc ji jj jk jl bi translated">如何从二进制格式重建另一端(库存服务)的订单对象？</li></ol><p id="93fb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们在下一节讨论这些问题的答案。</p><h1 id="e1fd" class="jr js hi bd jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko bi translated">Protobuf 语义</h1><p id="3ec2" class="pw-post-body-paragraph if ig hi ih b ii kp ik il im kq io ip iq kr is it iu ks iw ix iy kt ja jb jc hb bi translated">这一切都是从定义一个包含消息结构的<code class="du lu lv lw ll b">.proto</code>文件开始的，即我们示例中的顺序。</p><pre class="kv kw kx ky fd lk ll lm ln aw lo bi"><span id="f9a1" class="lp js hi ll b fi lq lr l ls lt">syntax = "proto3";</span><span id="7f99" class="lp js hi ll b fi lx lr l ls lt">message Order {<br/>    enum PaymentMode {<br/>        CASH = 0;<br/>        CARD = 1;<br/>    }<br/>    int32 orderId = 1;<br/>    int32 customerId = 2;<br/>    repeated int32 items = 3;<br/>    string couponCode = 4;<br/>    PaymentMode paymentMode = 5;<br/>    Address shippingAddress = 6;<br/>}</span><span id="25fb" class="lp js hi ll b fi lx lr l ls lt">message Address {<br/>    string name = 1;<br/>    string address = 2;<br/>    string pincode = 3;<br/>}</span></pre><p id="3399" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">上述<code class="du lu lv lw ll b">order.proto</code>文件包含订单消息的模式，内容如下:</p><p id="448d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><code class="du lu lv lw ll b">syntax = "proto3"</code>说这个文件是用<code class="du lu lv lw ll b">proto3</code>编译器格式编写的(下面有更多关于 proto 编译器的信息)</p><p id="0cca" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">一种包含以下字段定义的<code class="du lu lv lw ll b">Order</code>消息类型。</p><ul class=""><li id="b36d" class="jd je hi ih b ii ij im in iq jf iu jg iy jh jc ly jj jk jl bi translated"><code class="du lu lv lw ll b">PaymentMode</code>枚举定义</li><li id="9135" class="jd je hi ih b ii jm im jn iq jo iu jp iy jq jc ly jj jk jl bi translated"><code class="du lu lv lw ll b">orderId</code>类型为<code class="du lu lv lw ll b">integer</code>的字段</li><li id="f304" class="jd je hi ih b ii jm im jn iq jo iu jp iy jq jc ly jj jk jl bi translated"><code class="du lu lv lw ll b">customerId</code>类型为<code class="du lu lv lw ll b">integer</code>的字段</li><li id="d873" class="jd je hi ih b ii jm im jn iq jo iu jp iy jq jc ly jj jk jl bi translated"><code class="du lu lv lw ll b">items</code>类型为<code class="du lu lv lw ll b">collection of integers</code>的字段</li><li id="718c" class="jd je hi ih b ii jm im jn iq jo iu jp iy jq jc ly jj jk jl bi translated"><code class="du lu lv lw ll b">couponCode</code>字符串类型的字段</li><li id="032a" class="jd je hi ih b ii jm im jn iq jo iu jp iy jq jc ly jj jk jl bi translated"><code class="du lu lv lw ll b">paymentMode</code>类型为<code class="du lu lv lw ll b">PaymentMode</code>的字段，它是一个枚举</li><li id="e9b4" class="jd je hi ih b ii jm im jn iq jo iu jp iy jq jc ly jj jk jl bi translated"><code class="du lu lv lw ll b">shippingAddress</code>类型为<code class="du lu lv lw ll b">Address</code>的字段，也是一种消息类型</li></ul><p id="0b67" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">包含以下字段定义的<code class="du lu lv lw ll b">Address</code>消息类型。</p><ul class=""><li id="0d52" class="jd je hi ih b ii ij im in iq jf iu jg iy jh jc ly jj jk jl bi translated"><code class="du lu lv lw ll b">name</code>类型为<code class="du lu lv lw ll b">string</code>的字段</li><li id="4305" class="jd je hi ih b ii jm im jn iq jo iu jp iy jq jc ly jj jk jl bi translated"><code class="du lu lv lw ll b">address</code>类型为<code class="du lu lv lw ll b">string</code>的字段</li><li id="c9a5" class="jd je hi ih b ii jm im jn iq jo iu jp iy jq jc ly jj jk jl bi translated"><code class="du lu lv lw ll b">pincode</code>类型为<code class="du lu lv lw ll b">string</code>的字段</li></ul><p id="f87c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">您可能想知道分配给每个字段的数字是多少。这个编号被称为<strong class="ih hj">字段编号</strong>，并且需要是唯一的。字段编号用于在序列化&amp;反序列化过程中识别字段。我们稍后将回到序列化、反序列化&amp;字段编号。</p><p id="0667" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">一旦定义了原型文件，我们需要一些代码将订单消息转换成二进制格式，反之亦然。这是最具挑战性的部分，但幸运的是，我们有一个由 Google 创建的<strong class="ih hj">原型编译器</strong>，它可以通过必要的算法自动为我们生成代码，完成上述工作。编译器能够生成不同编程语言的代码。以下示例显示了如何使用编译器生成 Javascript 代码。</p><pre class="kv kw kx ky fd lk ll lm ln aw lo bi"><span id="8d29" class="lp js hi ll b fi lq lr l ls lt">protoc --proto_path=. --js_out=import_style=commonjs,binary:. order.proto</span></pre><ul class=""><li id="501c" class="jd je hi ih b ii ij im in iq jf iu jg iy jh jc ly jj jk jl bi translated"><code class="du lu lv lw ll b">protoc</code>是 protobuf 编译器</li><li id="248a" class="jd je hi ih b ii jm im jn iq jo iu jp iy jq jc ly jj jk jl bi translated"><code class="du lu lv lw ll b">proto_path</code>是包含原型文件的目录的路径。<code class="du lu lv lw ll b">.</code>表示当前目录</li><li id="4369" class="jd je hi ih b ii jm im jn iq jo iu jp iy jq jc ly jj jk jl bi translated"><code class="du lu lv lw ll b">js_out=import_style=commonjs,binary:.</code>输出 commonjs 风格的 Javascript 代码，并将 js 文件放在当前目录中。</li><li id="e0b8" class="jd je hi ih b ii jm im jn iq jo iu jp iy jq jc ly jj jk jl bi translated"><code class="du lu lv lw ll b">order.proto</code>原型文件的名称</li></ul><p id="0cf0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">运行<code class="du lu lv lw ll b">protoc</code>命令将在我们当前的目录中生成一个<code class="du lu lv lw ll b">order_pb.js</code>文件。这个文件包含的方法有</p><ul class=""><li id="e474" class="jd je hi ih b ii ij im in iq jf iu jg iy jh jc ly jj jk jl bi translated"><code class="du lu lv lw ll b">serializeBinary</code> -将订单 JS 对象序列化为二进制格式</li><li id="629a" class="jd je hi ih b ii jm im jn iq jo iu jp iy jq jc ly jj jk jl bi translated"><code class="du lu lv lw ll b">deserializeBinary</code> -将二进制文件反序列化为订单 JS 对象</li><li id="ad4c" class="jd je hi ih b ii jm im jn iq jo iu jp iy jq jc ly jj jk jl bi translated"><code class="du lu lv lw ll b">setOrderid</code> -像<code class="du lu lv lw ll b">order.setOrderid()</code>一样设置订单 id</li><li id="cb9e" class="jd je hi ih b ii jm im jn iq jo iu jp iy jq jc ly jj jk jl bi translated"><code class="du lu lv lw ll b">setCustomerid</code> -像<code class="du lu lv lw ll b">order.setCustomerid()</code>一样设置客户 id</li><li id="9b07" class="jd je hi ih b ii jm im jn iq jo iu jp iy jq jc ly jj jk jl bi translated"><code class="du lu lv lw ll b">setItemsList</code> -设置项目集合</li><li id="3966" class="jd je hi ih b ii jm im jn iq jo iu jp iy jq jc ly jj jk jl bi translated"><code class="du lu lv lw ll b">setShippingaddress</code> -设置送货地址。请注意，送货地址也是一个<code class="du lu lv lw ll b">Address</code>对象，它包含类似于<code class="du lu lv lw ll b">serializeBinary</code>、<code class="du lu lv lw ll b">deserializeBinary</code>、<code class="du lu lv lw ll b">setName</code>、<code class="du lu lv lw ll b">setAddress</code>等方法</li></ul><p id="f4ee" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">诸如此类。</p><p id="31d9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">下面是一个示例 JS 代码，它创建一个 order <code class="du lu lv lw ll b">order1</code>，序列化为二进制格式，然后再反序列化为 order 对象。将这一思想推广到我们的订单示例中，我们可以将序列化的订单消息(也称为二进制数据)通过网络从订单服务发送到消息队列和库存服务。请注意，只有这种二进制形式通过网络传输并存储在消息队列中。库存服务可以再次将二进制数据反序列化回适当的 JS Order 对象，并开始使用它。</p><pre class="kv kw kx ky fd lk ll lm ln aw lo bi"><span id="58c2" class="lp js hi ll b fi lq lr l ls lt"><em class="lz">// import</em><br/>const OrderSchema = require("./order_pb");</span><span id="c41b" class="lp js hi ll b fi lx lr l ls lt"><em class="lz">// create order1</em><br/>const order1 = new OrderSchema.Order();<br/>order1.setOrderid(1);<br/>order1.setCustomerid(123);<br/>order1.setItemsList([987, 988]);<br/>order1.setCouponcode("ALLFREE");<br/>order1.setPaymentmode(1);</span><span id="50dc" class="lp js hi ll b fi lx lr l ls lt"><em class="lz">// create address for order1</em><br/>const address = new OrderSchema.Address();<br/>address.setName("Alice");<br/>address.setAddress("xyz street");<br/>address.setPincode("111111");</span><span id="769e" class="lp js hi ll b fi lx lr l ls lt">order1.setShippingaddress(address);</span><span id="a904" class="lp js hi ll b fi lx lr l ls lt"><em class="lz">// serialize order1 to binary</em><br/>const bytes = order1.serializeBinary();<br/>console.log("Binary : " + bytes);</span><span id="c36b" class="lp js hi ll b fi lx lr l ls lt"><em class="lz">// deserialize order1 from binary to JS object</em><br/>const object = OrderSchema.Order.deserializeBinary(bytes).toString();<br/>console.log("Deserialize : " + object);</span></pre><p id="a251" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">您可能会有一个问题，订单和库存服务是如何知道 proto 文件的？</p><p id="9f03" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">好问题。</p><p id="c729" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在生产就绪的消息队列/消息代理(如 Apache Kafka)中，这个原型文件由一个模式注册表管理，该注册表是一个存储原型定义的高可用性服务。生产者使用模式注册中心对消息进行编码。这些编码的消息通过网络传输并存储在消息代理中。消费者提取编码的消息，然后在模式注册中心的帮助下解码它们。下图很好地说明了这一工作流程。</p><figure class="kv kw kx ky fd kz er es paragraph-image"><div role="button" tabindex="0" class="la lb di lc bf ld"><div class="er es ma"><img src="../Images/5d2f8c4d5afcf80e7024cd41681a3c03.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1xHjo3Us_h7JyjfOGHlXaQ.png"/></div></div><figcaption class="lg lh et er es li lj bd b be z dx translated">使用模式注册表的消息通信</figcaption></figure><p id="8329" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这就是 Protobuf 的工作方式。它速度快，重量轻，占用空间和网络带宽少。</p><h1 id="66cc" class="jr js hi bd jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko bi translated">Protobuf 内部</h1><p id="64a3" class="pw-post-body-paragraph if ig hi ih b ii kp ik il im kq io ip iq kr is it iu ks iw ix iy kt ja jb jc hb bi translated">如果你很想了解对象→二进制→对象转换是如何发生的，想知道编码背后的逻辑，那么请继续读下去。</p><p id="4d6a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在前面的例子中，订单消息被转换成二进制消息格式，如下所示。</p><p id="c532" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">订单报文二进制格式:</strong></p><pre class="kv kw kx ky fd lk ll lm ln aw lo bi"><span id="4cd4" class="lp js hi ll b fi lq lr l ls lt">8,1,16,123,26,4,219,7,220,7,34,7,65,76,76,70,82,69,69,40,1,50,27,10,5,65,108,105,99,101,18,10,120,121,122,32,115,116,114,101,101,116,26,6,49,49,49,49,49,49</span></pre><p id="6517" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">订单消息原型(供参考):</strong></p><pre class="kv kw kx ky fd lk ll lm ln aw lo bi"><span id="e90b" class="lp js hi ll b fi lq lr l ls lt">message Order {<br/>    enum PaymentMode {<br/>        CASH = 0;<br/>        CARD = 1;<br/>    }<br/>    int32 orderId = 1;<br/>    int32 customerId = 2;<br/>    repeated int32 items = 3;<br/>    string couponCode = 4;<br/>    PaymentMode paymentMode = 5;<br/>    Address shippingAddress = 6;<br/>}</span><span id="a9a0" class="lp js hi ll b fi lx lr l ls lt">message Address {<br/>    string name = 1;<br/>    string address = 2;<br/>    string pincode = 3;<br/>}</span></pre><p id="610f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">以文本形式订购消息(供参考):</strong></p><pre class="kv kw kx ky fd lk ll lm ln aw lo bi"><span id="0e24" class="lp js hi ll b fi lq lr l ls lt">orderId: 1<br/>customerId: 123<br/>items: [987, 988]<br/>couponCode: "ALLFREE"<br/>paymentMode: "CASH"<br/>shippingAddress:<br/>        - name: "Alice"<br/>        - address: "xyz street"<br/>        - pincode: "111111"</span></pre><p id="2f5c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为了理解编码，让我们从二进制消息格式的第一个数字开始:- <code class="du lu lv lw ll b">8</code>。</p><p id="4ff5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">解码 8: <br/> </strong>既然<code class="du lu lv lw ll b">8</code>是第一个数，那就是一个<code class="du lu lv lw ll b">key</code>。解码一个密钥会给我们原始文件中的字段。为了理解如何解码一个密钥，我们可以使用下面的逻辑。</p><pre class="kv kw kx ky fd lk ll lm ln aw lo bi"><span id="1453" class="lp js hi ll b fi lq lr l ls lt">Decoding logic for key 8:</span><span id="725c" class="lp js hi ll b fi lx lr l ls lt">1. Convert 8 to binary = 0000 1000<br/>2. Take last 3 digits and convert to decimal to get wire type (more about wire type shortly) = 000 i.e 0<br/>3. Right shift by 3 and convert to decimal to get field value i.e 0000 1000 &gt;&gt; 3 = 1</span></pre><p id="978d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">另一个例子，</p><pre class="kv kw kx ky fd lk ll lm ln aw lo bi"><span id="48e7" class="lp js hi ll b fi lq lr l ls lt">Decoding key logic for 16:</span><span id="4545" class="lp js hi ll b fi lx lr l ls lt">1. Convert 16 to binary = 0001 0000<br/>2. Take last 3 digits and convert to decimal to get wire type (more about wire type shortly) = 000 i.e 0<br/>3. Right shift by 3 and convert to decimal to get field value i.e 0000 1000 &gt;&gt; 3 = 2 (10 in binary)</span></pre><p id="a588" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">回到我们的二进制消息，从<code class="du lu lv lw ll b">8</code>我们已经确定了两件事:</p><ol class=""><li id="3640" class="jd je hi ih b ii ij im in iq jf iu jg iy jh jc ji jj jk jl bi translated">电线类型为<code class="du lu lv lw ll b">0</code></li><li id="b3d1" class="jd je hi ih b ii jm im jn iq jo iu jp iy jq jc ji jj jk jl bi translated">字段编号为<code class="du lu lv lw ll b">1</code></li></ol><p id="0e23" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这样，我们可以说<code class="du lu lv lw ll b">8</code>对应于字段<code class="du lu lv lw ll b">orderId</code>(来自 proto 文件的字段编号 1)。</p><p id="5670" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">解码 1: <br/> </strong>由于<code class="du lu lv lw ll b">8</code>的导线类型是<code class="du lu lv lw ll b">0</code>我们可以说即将出现的数字应该是一个 Varint 导线类型。</p><p id="899e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">线类型告诉我们如何处理即将到来的数字。下表显示了导线类型及其含义之间的映射。</p><figure class="kv kw kx ky fd kz er es paragraph-image"><div role="button" tabindex="0" class="la lb di lc bf ld"><div class="er es mb"><img src="../Images/8f1c825ec633487ffa7648cc765ca7a5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*X72vJZ5H2xG_yz5dOCZWkw.png"/></div></div></figure><p id="00a2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">什么是 Varint？ Varint 是一种使用一个或多个字节序列化整数的方法。让我们以整数<code class="du lu lv lw ll b">1</code>为例，它的变量表示为<code class="du lu lv lw ll b">0000 0001</code>。再比如<code class="du lu lv lw ll b">987</code>，它的变量是<code class="du lu lv lw ll b">11011011 00000111</code>。我们怎么算出这是<code class="du lu lv lw ll b">987</code>？下面的块解释了逻辑。</p><pre class="kv kw kx ky fd lk ll lm ln aw lo bi"><span id="5f42" class="lp js hi ll b fi lq lr l ls lt">Decode Logic for Varint 11011011 00000111:</span><span id="92a1" class="lp js hi ll b fi lx lr l ls lt">1. The MSB tells us whether there are further bytes to come. If the MSB is 1, we have upcoming bytes. If MSB is 0 then that is the last byte. In this case the msb of 1st byte is 1 so that means we have to consider the next byte as well. But the MSB of the 2nd byte is 0 so that means no other bytes.</span><span id="c559" class="lp js hi ll b fi lx lr l ls lt">2. Strip out the msb's of the bytes<br/>1011011 0000111</span><span id="a728" class="lp js hi ll b fi lx lr l ls lt">3. Reverse the bytes<br/>0000111 1011011</span><span id="b8a0" class="lp js hi ll b fi lx lr l ls lt">4. Concat the bytes and convert to decimal<br/>0000111 + 1011011 -&gt; 1111011011 -&gt; 987</span></pre><p id="7159" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">再举一个例子，<code class="du lu lv lw ll b">98765</code>和它的变体是<code class="du lu lv lw ll b">11001101 10000011 00000110</code></p><pre class="kv kw kx ky fd lk ll lm ln aw lo bi"><span id="5255" class="lp js hi ll b fi lq lr l ls lt">Decode Logic for Varint 11001101 10000011 00000110:</span><span id="c988" class="lp js hi ll b fi lx lr l ls lt">1. MSB of 1st byte is 1 so there is 2nd byte, MSB of 2nd byte is 1 so there is 3rd byte, MSB of 3rd byte is 0 so no further bytes.</span><span id="52dd" class="lp js hi ll b fi lx lr l ls lt">2. Strip out the msb's of the bytes<br/>1001101 0000011 0000110</span><span id="d50e" class="lp js hi ll b fi lx lr l ls lt">3. Reverse the bytes<br/>0000110 0000011 1001101</span><span id="a978" class="lp js hi ll b fi lx lr l ls lt">4. Concat the bytes and convert to decimal<br/>0000110 + 0000011 + 1001101 -&gt; 11000000111001101 -&gt; 98765</span></pre><p id="cc7e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">回到我们的二进制消息，<code class="du lu lv lw ll b">1</code>是一个变量，它的值是 1。</p><p id="2f30" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">此时，我们已经从解码<code class="du lu lv lw ll b">8 &amp; 1</code>中提取了以下信息:</p><ol class=""><li id="0ce8" class="jd je hi ih b ii ij im in iq jf iu jg iy jh jc ji jj jk jl bi translated"><code class="du lu lv lw ll b">orderId</code>的值为<code class="du lu lv lw ll b">1</code>。</li></ol><p id="39cf" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">解码 16: <br/> </strong>既然之前的数字是线型，<code class="du lu lv lw ll b">16</code>应该是一个键。到现在为止，你可能已经知道如何破译一把钥匙了。</p><p id="3b30" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们有 16 个，</p><ol class=""><li id="1720" class="jd je hi ih b ii ij im in iq jf iu jg iy jh jc ji jj jk jl bi translated">电线类型为<code class="du lu lv lw ll b">0</code></li><li id="f3d4" class="jd je hi ih b ii jm im jn iq jo iu jp iy jq jc ji jj jk jl bi translated">字段编号为<code class="du lu lv lw ll b">2</code></li></ol><p id="21ee" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这意味着<code class="du lu lv lw ll b">16</code>对应于字段 customerId(字段编号 2)。</p><p id="e3a8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">此时，我们已经从解码中提取了以下信息<code class="du lu lv lw ll b">8, 1, 16</code></p><ol class=""><li id="b5d8" class="jd je hi ih b ii ij im in iq jf iu jg iy jh jc ji jj jk jl bi translated"><code class="du lu lv lw ll b">orderId</code>的值是<code class="du lu lv lw ll b">1</code></li><li id="37f3" class="jd je hi ih b ii jm im jn iq jo iu jp iy jq jc ji jj jk jl bi translated">字段是<code class="du lu lv lw ll b">customerId</code></li></ol><p id="daef" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">解码 123: <br/> </strong>由于<code class="du lu lv lw ll b">16</code>的线类型是<code class="du lu lv lw ll b">0</code>我们可以说接下来的数字应该是一个变量。这里的<code class="du lu lv lw ll b">123</code>即<code class="du lu lv lw ll b">01111011</code>是一个变量，解析它会给出<code class="du lu lv lw ll b">123</code>值。</p><pre class="kv kw kx ky fd lk ll lm ln aw lo bi"><span id="860e" class="lp js hi ll b fi lq lr l ls lt">Decode Logic for Varint 01111011:</span><span id="497d" class="lp js hi ll b fi lx lr l ls lt">1. MSB of 1st byte is 0 so there is no 2nd byte.</span><span id="f07f" class="lp js hi ll b fi lx lr l ls lt">2. Strip out the msb's of the bytes<br/>1111011</span><span id="5391" class="lp js hi ll b fi lx lr l ls lt">3. Reverse the bytes<br/>1111011</span><span id="be4d" class="lp js hi ll b fi lx lr l ls lt">4. Concat the bytes and convert to decimal<br/>1111011 -&gt; 123</span></pre><p id="8a34" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">此时，我们已经从解码<code class="du lu lv lw ll b">8, 1, 16 &amp; 123</code>中提取了以下信息:</p><ol class=""><li id="65f7" class="jd je hi ih b ii ij im in iq jf iu jg iy jh jc ji jj jk jl bi translated"><code class="du lu lv lw ll b">orderId</code>的值为<code class="du lu lv lw ll b">1</code>。</li><li id="b22a" class="jd je hi ih b ii jm im jn iq jo iu jp iy jq jc ji jj jk jl bi translated"><code class="du lu lv lw ll b">customerId</code>的值为<code class="du lu lv lw ll b">123</code></li></ol><p id="32d9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">解码 26: <br/> </strong>既然之前的数字是线型，<code class="du lu lv lw ll b">26</code>应该是一个键。</p><pre class="kv kw kx ky fd lk ll lm ln aw lo bi"><span id="3187" class="lp js hi ll b fi lq lr l ls lt">Decoding logic for key 26:</span><span id="fba3" class="lp js hi ll b fi lx lr l ls lt">1. Convert 26 to binary = 0001 1010<br/>2. Take last 3 digits and convert to decimal to get wire type i.e 010 i.e 2<br/>3. Right shift by 3 and convert to decimal to get field value i.e 0001 1010 &gt;&gt; 3 = 3 (11 in binary)</span></pre><p id="d8a7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">对于<code class="du lu lv lw ll b">26</code>我们有，</p><ol class=""><li id="496e" class="jd je hi ih b ii ij im in iq jf iu jg iy jh jc ji jj jk jl bi translated">电线类型为<code class="du lu lv lw ll b">2</code></li><li id="8656" class="jd je hi ih b ii jm im jn iq jo iu jp iy jq jc ji jj jk jl bi translated">字段编号为<code class="du lu lv lw ll b">3</code></li></ol><p id="ce92" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这意味着<code class="du lu lv lw ll b">26</code>对应于字段<code class="du lu lv lw ll b">items</code>(字段编号 3)。</p><p id="c903" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">此时，我们已经从解码<code class="du lu lv lw ll b">8, 1, 16, 123 &amp; 26</code>中提取了以下信息:</p><ol class=""><li id="cbef" class="jd je hi ih b ii ij im in iq jf iu jg iy jh jc ji jj jk jl bi translated"><code class="du lu lv lw ll b">orderId</code>的值为<code class="du lu lv lw ll b">1</code></li><li id="ce16" class="jd je hi ih b ii jm im jn iq jo iu jp iy jq jc ji jj jk jl bi translated"><code class="du lu lv lw ll b">customerId</code>的值是<code class="du lu lv lw ll b">123</code></li><li id="cc95" class="jd je hi ih b ii jm im jn iq jo iu jp iy jq jc ji jj jk jl bi translated">该字段是<code class="du lu lv lw ll b">items</code></li></ol><p id="38c5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">解码 4，219，7，220，7: <br/> </strong>由于<code class="du lu lv lw ll b">26</code>的线类型是<code class="du lu lv lw ll b">2</code>，我们可以说接下来的数字应该是长度分隔的线类型(参考上表)。那么我们如何解析长度分隔的导线类型呢？让我们来看看。</p><pre class="kv kw kx ky fd lk ll lm ln aw lo bi"><span id="0a77" class="lp js hi ll b fi lq lr l ls lt">Decode Logic for Length Delimited:</span><span id="da70" class="lp js hi ll b fi lx lr l ls lt">1. First number is always the length given in Varint i.e value of Varint 4 is 4, so length is 4.</span><span id="d9d5" class="lp js hi ll b fi lx lr l ls lt">2. Since the length is 4, consider the next 4 numbers i.e 219, 7, 220, 7</span><span id="201e" class="lp js hi ll b fi lx lr l ls lt">3. The field number calculated previously for 26 is 3 which corresponds to collection (repeated) of ints, we can say that 219 (11011011), 7 (00000111), 220 (11011100), 7 (00000111) are Varints that would resolve to integers.</span><span id="b557" class="lp js hi ll b fi lx lr l ls lt">4. 11011011 00000111 11011100 00000111 contains 2 ints based on the MSBs</span><span id="b9cf" class="lp js hi ll b fi lx lr l ls lt">5. 11011011 00000111 Varint resolves to 987</span><span id="8ff3" class="lp js hi ll b fi lx lr l ls lt">6. 11011100 00000111 Varint resolves to 988</span></pre><p id="7fdd" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">此时，我们已经从解码<code class="du lu lv lw ll b">8, 1, 16, 123, 26, 4, 219, 7, 220, 7</code>中提取了以下信息:</p><ol class=""><li id="7ba8" class="jd je hi ih b ii ij im in iq jf iu jg iy jh jc ji jj jk jl bi translated"><code class="du lu lv lw ll b">orderId</code>的值为<code class="du lu lv lw ll b">1</code></li><li id="6224" class="jd je hi ih b ii jm im jn iq jo iu jp iy jq jc ji jj jk jl bi translated"><code class="du lu lv lw ll b">customerId</code>的值为<code class="du lu lv lw ll b">123</code></li><li id="90d9" class="jd je hi ih b ii jm im jn iq jo iu jp iy jq jc ji jj jk jl bi translated"><code class="du lu lv lw ll b">items</code>的值是有<code class="du lu lv lw ll b">987</code> &amp; <code class="du lu lv lw ll b">988</code>的集合</li></ol><p id="f99e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">解码 34: <br/> </strong>既然之前的数字是线型，<code class="du lu lv lw ll b">34</code>应该是一个键。</p><p id="4207" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">因为我们有，</p><ol class=""><li id="4ad5" class="jd je hi ih b ii ij im in iq jf iu jg iy jh jc ji jj jk jl bi translated">电线类型为<code class="du lu lv lw ll b">2</code></li><li id="50d1" class="jd je hi ih b ii jm im jn iq jo iu jp iy jq jc ji jj jk jl bi translated">字段编号为<code class="du lu lv lw ll b">4</code></li></ol><p id="db68" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这意味着<code class="du lu lv lw ll b">34</code>对应于字段<code class="du lu lv lw ll b">couponCode</code>(字段编号 4)。</p><p id="fab3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">此时，我们已经从解码<code class="du lu lv lw ll b">8, 1, 16, 123, 26, 4, 219, 7, 220, 7 &amp; 34</code>中提取了以下信息:</p><ol class=""><li id="2fa6" class="jd je hi ih b ii ij im in iq jf iu jg iy jh jc ji jj jk jl bi translated"><code class="du lu lv lw ll b">orderId</code>的值为<code class="du lu lv lw ll b">1</code></li><li id="ec79" class="jd je hi ih b ii jm im jn iq jo iu jp iy jq jc ji jj jk jl bi translated"><code class="du lu lv lw ll b">customerId</code>的值为<code class="du lu lv lw ll b">123</code></li><li id="d33a" class="jd je hi ih b ii jm im jn iq jo iu jp iy jq jc ji jj jk jl bi translated"><code class="du lu lv lw ll b">items</code>的值是有<code class="du lu lv lw ll b">987</code> &amp; <code class="du lu lv lw ll b">988</code>的集合</li><li id="2190" class="jd je hi ih b ii jm im jn iq jo iu jp iy jq jc ji jj jk jl bi translated">字段是<code class="du lu lv lw ll b">couponCode</code></li></ol><p id="049f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">解码 7，65，76，76，70，82，69，69: <br/> </strong>由于<code class="du lu lv lw ll b">34</code>的线类型是<code class="du lu lv lw ll b">2</code>，我们可以说接下来的数字应该是长度分隔的线类型。那么我们如何解析长度分隔的导线类型呢？让我们来看看。</p><pre class="kv kw kx ky fd lk ll lm ln aw lo bi"><span id="ad22" class="lp js hi ll b fi lq lr l ls lt">Decode Logic for Length Delimited:</span><span id="3056" class="lp js hi ll b fi lx lr l ls lt">1. First number is always the length given in Varint i.e value of Varint 7 is 7, so length is 7.</span><span id="32a2" class="lp js hi ll b fi lx lr l ls lt">2. Since the length is 7, consider the next 7 numbers i.e 65,76,76,70,82,69,69</span><span id="8d1a" class="lp js hi ll b fi lx lr l ls lt">3. The field number calculated previously for 34 is 4 which corresponds to string, we can say that 65 (1000001), 76 (1001100), 76 (1001100), 70 (1000110), 82 (1010010), 69(1000101), 69 (1000101) would resolve to UTF-8 string.</span><span id="3626" class="lp js hi ll b fi lx lr l ls lt">4. 1000001 1001100 1001100 1000110 1010010 1000101 1000101 -&gt; ALLFREE (UTF-8)</span></pre><p id="9463" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">此时我们已经从解码<code class="du lu lv lw ll b">8, 1, 16, 123, 26, 4, 219, 7, 220, 7</code>中提取了以下信息:</p><ol class=""><li id="623c" class="jd je hi ih b ii ij im in iq jf iu jg iy jh jc ji jj jk jl bi translated"><code class="du lu lv lw ll b">orderId</code>的值是<code class="du lu lv lw ll b">1</code></li><li id="d1cd" class="jd je hi ih b ii jm im jn iq jo iu jp iy jq jc ji jj jk jl bi translated"><code class="du lu lv lw ll b">customerId</code>的值为<code class="du lu lv lw ll b">123</code></li><li id="951f" class="jd je hi ih b ii jm im jn iq jo iu jp iy jq jc ji jj jk jl bi translated"><code class="du lu lv lw ll b">items</code>的值是有<code class="du lu lv lw ll b">987</code> &amp; <code class="du lu lv lw ll b">988</code>的集合</li><li id="c58a" class="jd je hi ih b ii jm im jn iq jo iu jp iy jq jc ji jj jk jl bi translated"><code class="du lu lv lw ll b">couponCode</code>的值为<code class="du lu lv lw ll b">ALLFREE</code></li></ol><p id="c8c7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">同样，我们可以对数字<code class="du lu lv lw ll b">40 &amp; 41</code>做同样的事情。</p><p id="9953" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">解码 50: <br/> </strong>既然之前的号码是线型，<code class="du lu lv lw ll b">50</code>应该是一个键。</p><p id="babd" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们有 50 美元，</p><ol class=""><li id="8bce" class="jd je hi ih b ii ij im in iq jf iu jg iy jh jc ji jj jk jl bi translated">电线类型为<code class="du lu lv lw ll b">2</code></li><li id="0522" class="jd je hi ih b ii jm im jn iq jo iu jp iy jq jc ji jj jk jl bi translated">字段编号为<code class="du lu lv lw ll b">6</code></li></ol><p id="ad3c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这意味着<code class="du lu lv lw ll b">50</code>对应于字段<code class="du lu lv lw ll b">shippingAddress</code>(字段编号 6)。</p><p id="43d5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">此时，我们已经从解码<code class="du lu lv lw ll b">8, 1, 16, 123, 26, 4, 219, 7, 220, 7 &amp; 50</code>中提取了以下信息:</p><ol class=""><li id="b7c5" class="jd je hi ih b ii ij im in iq jf iu jg iy jh jc ji jj jk jl bi translated"><code class="du lu lv lw ll b">orderId</code>的值为<code class="du lu lv lw ll b">1</code></li><li id="54ca" class="jd je hi ih b ii jm im jn iq jo iu jp iy jq jc ji jj jk jl bi translated"><code class="du lu lv lw ll b">customerId</code>的值是<code class="du lu lv lw ll b">123</code></li><li id="69d8" class="jd je hi ih b ii jm im jn iq jo iu jp iy jq jc ji jj jk jl bi translated"><code class="du lu lv lw ll b">items</code>的值是有<code class="du lu lv lw ll b">987</code> &amp; <code class="du lu lv lw ll b">988</code>的集合</li><li id="f868" class="jd je hi ih b ii jm im jn iq jo iu jp iy jq jc ji jj jk jl bi translated"><code class="du lu lv lw ll b">couponCode</code>的值为<code class="du lu lv lw ll b">ALLFREE</code></li><li id="d535" class="jd je hi ih b ii jm im jn iq jo iu jp iy jq jc ji jj jk jl bi translated">字段是<code class="du lu lv lw ll b">shippingAddress</code></li></ol><p id="2c6d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">解码 27，10，5，65，108，105，99，101，18，10，120，121，122，32，115，116，114，101，116，26，6，49，49，49，49，49: <br/> </strong>既然<code class="du lu lv lw ll b">50</code>的导线类型是<code class="du lu lv lw ll b">2</code>我们可以说下一个那么我们如何解析长度分隔的导线类型呢？让我们来看看。</p><pre class="kv kw kx ky fd lk ll lm ln aw lo bi"><span id="9c15" class="lp js hi ll b fi lq lr l ls lt">Decode Logic for Length Delimited:</span><span id="8d49" class="lp js hi ll b fi lx lr l ls lt">1. First number is always the length given in Varint i.e value of Varint 27 is 27 so length is 27.</span><span id="176c" class="lp js hi ll b fi lx lr l ls lt">2. Since the length is 27, consider the next 27 numbers i.e 10,5,65,108,105,99,101,18,10,120,121,122,32,115,116,114,101,101,116,26,6,49,49,49,49,49,49</span><span id="4428" class="lp js hi ll b fi lx lr l ls lt">3. Since the field number calculated previously for 50 is 6 which corresponds to a message type Address, upcoming numbers starting from 10 to 49 belong to the Address message type and can be parsed similar to the Order message type. You can take that up as an exercise.</span></pre><p id="0a26" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">使用上面提到的二进制格式编码逻辑，我们能够从二进制中构造消息。</p><p id="3b9c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">本帖到此为止，感谢阅读。我们下次再见，在那之前保重，继续学习:)</p></div></div>    
</body>
</html>