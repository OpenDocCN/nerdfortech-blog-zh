<html>
<head>
<title>Things you should know about JAVA Threads, Before going to an Interview</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">去面试之前，你应该知道的关于 JAVA 线程的事情</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/things-you-should-know-about-java-threads-before-going-to-an-interview-57e95e2c5278?source=collection_archive---------4-----------------------#2021-05-12">https://medium.com/nerd-for-tech/things-you-should-know-about-java-threads-before-going-to-an-interview-57e95e2c5278?source=collection_archive---------4-----------------------#2021-05-12</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/4cda19881b73f47170711077333e02a3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*lDVGbwsXdcboJIF4"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">马丁·威尔纳在<a class="ae iu" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><p id="8441" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">让我们从基础开始。什么是 Java 线程？<strong class="ix hj">线程是一个独立的执行流</strong>。一个线程能够独立执行我们分配给它的任务。一个 Java 程序可以有多个线程来执行多任务处理。线程是独立的，这意味着当 Java 程序使用多线程时，如果一个线程发生错误，它不会影响其他线程。每个线程将同时执行分配给它的任务。</p><p id="57a9" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们可以把多任务分成两类</p><figure class="ju jv jw jx fd ij er es paragraph-image"><div class="er es jt"><img src="../Images/9477c56548974675a7feca07364e465c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1266/format:webp/1*K5wBOVN3sfM3VK_OsxBqHg.jpeg"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">多任务类型</figcaption></figure><figure class="ju jv jw jx fd ij er es paragraph-image"><div class="er es jy"><img src="../Images/34907e0c59ab7a3c7ed06bd223f9a738.png" data-original-src="https://miro.medium.com/v2/resize:fit:1076/format:webp/1*7Db2o92v6eeC51m31Gcqmg.png"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">进程与线程——photo by-<a class="ae iu" href="https://www.javatpoint.com/multithreading-in-java" rel="noopener ugc nofollow" target="_blank">Java 教程要点</a></figcaption></figure><p id="0d11" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在本文中，我们集中讨论多线程(基于线程的多任务处理)</p><h1 id="ff83" class="jz ka hi bd kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw bi translated">使用线程的目的</h1><p id="8193" class="pw-post-body-paragraph iv iw hi ix b iy kx ja jb jc ky je jf jg kz ji jj jk la jm jn jo lb jq jr js hb bi translated">考虑下面的场景，一个应用程序必须执行 10 个任务。如果使用 1 个线程完成执行需要 10 秒，那么使用 10 个线程可以将执行时间减少到 1 秒吗？</p><p id="dc20" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">具体要看执行情况。如果这些任务是相互独立的，这意味着没有任务要等到另一个任务完成，那么我们可以为每个线程分配一个任务。因此，这 10 个任务可以同时并行执行，我们可以节省一些时间。</p><p id="2e3d" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">但是如果这些任务依赖于其他任务，这意味着如果一个任务应该等待其他任务完成它的执行，那么我们不能并行执行那些依赖的任务。因此，我们不能通过简单地增加线程数量来减少时间。</p><p id="a44e" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">此外，我们不能通过将相同的任务分配给 2 个线程来减少时间。因为两个线程执行任务的时间是一样的。</p><p id="8b19" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">因此，作为结论，我们可以说我们可以使用多线程来执行独立的任务，而增加线程来执行依赖任务是没有意义的。</p></div><div class="ab cl lc ld gp le" role="separator"><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh"/></div><div class="hb hc hd he hf"><h1 id="34cf" class="jz ka hi bd kb kc lj ke kf kg lk ki kj kk ll km kn ko lm kq kr ks ln ku kv kw bi translated">线程生命周期</h1><p id="1be9" class="pw-post-body-paragraph iv iw hi ix b iy kx ja jb jc ky je jf jg kz ji jj jk la jm jn jo lb jq jr js hb bi translated">理解<strong class="ix hj">线程生命周期</strong>对于理解线程的行为至关重要。让我们看看线程生命周期的每个状态。</p><figure class="ju jv jw jx fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lo"><img src="../Images/662144077edb851e698c106d3a379c04.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bq_OBx1NUefAFfE_RsMJDA.jpeg"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">线程生命周期</figcaption></figure><h2 id="ee7e" class="lp ka hi bd kb lq lr ls kf lt lu lv kj jg lw lx kn jk ly lz kr jo ma mb kv mc bi translated">新状态</h2><p id="3c97" class="pw-post-body-paragraph iv iw hi ix b iy kx ja jb jc ky je jf jg kz ji jj jk la jm jn jo lb jq jr js hb bi translated">在新创建的线程实例上调用 start()方法之前，线程处于“新状态”。</p><h2 id="66ba" class="lp ka hi bd kb lq lr ls kf lt lu lv kj jg lw lx kn jk ly lz kr jo ma mb kv mc bi translated">可运行状态</h2><p id="068a" class="pw-post-body-paragraph iv iw hi ix b iy kx ja jb jc ky je jf jg kz ji jj jk la jm jn jo lb jq jr js hb bi translated">该线程在调用 start()方法后处于“可运行状态”，但尚未被线程调度器选为运行线程。</p><h2 id="334b" class="lp ka hi bd kb lq lr ls kf lt lu lv kj jg lw lx kn jk ly lz kr jo ma mb kv mc bi translated">运行状态</h2><p id="e26a" class="pw-post-body-paragraph iv iw hi ix b iy kx ja jb jc ky je jf jg kz ji jj jk la jm jn jo lb jq jr js hb bi translated">如果线程调度器选择它作为运行线程，它就处于“运行状态”。一个线程只有在处于“运行状态”时才会执行它的任务。</p><h2 id="e1ee" class="lp ka hi bd kb lq lr ls kf lt lu lv kj jg lw lx kn jk ly lz kr jo ma mb kv mc bi translated">等待状态</h2><p id="3b81" class="pw-post-body-paragraph iv iw hi ix b iy kx ja jb jc ky je jf jg kz ji jj jk la jm jn jo lb jq jr js hb bi translated">当一个线程仍然存在，但没有资格运行时，该线程就处于“等待状态”。线程可以通过某些条件从“运行状态”转移到“等待状态”，例如:sleep()、wait()。同样，线程可以通过某些条件从“等待状态”转移到“可运行状态”，例如:notify()、interrupt()。</p><h2 id="0afd" class="lp ka hi bd kb lq lr ls kf lt lu lv kj jg lw lx kn jk ly lz kr jo ma mb kv mc bi translated">死亡状态</h2><p id="3cf5" class="pw-post-body-paragraph iv iw hi ix b iy kx ja jb jc ky je jf jg kz ji jj jk la jm jn jo lb jq jr js hb bi translated">当一个线程完成了分配给它的所有任务，或者当它的 run()方法退出时，它将成为一个死线程。</p></div><div class="ab cl lc ld gp le" role="separator"><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh"/></div><div class="hb hc hd he hf"><h1 id="c23c" class="jz ka hi bd kb kc lj ke kf kg lk ki kj kk ll km kn ko lm kq kr ks ln ku kv kw bi translated">创建线程</h1><p id="4c54" class="pw-post-body-paragraph iv iw hi ix b iy kx ja jb jc ky je jf jg kz ji jj jk la jm jn jo lb jq jr js hb bi translated">我们可以用两种不同的方式创建线程，它们是</p><ol class=""><li id="f059" class="md me hi ix b iy iz jc jd jg mf jk mg jo mh js mi mj mk ml bi translated">扩展线程类</li><li id="9258" class="md me hi ix b iy mm jc mn jg mo jk mp jo mq js mi mj mk ml bi translated">实现可运行接口</li></ol><p id="412a" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">但是线程对象的行为在两种方式下是相同的。</p><h1 id="5128" class="jz ka hi bd kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw bi translated">方法 1:扩展线程类</h1><figure class="ju jv jw jx fd ij"><div class="bz dy l di"><div class="mr ms l"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">线程创建方法 1</figcaption></figure><p id="15ec" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们可以简单地通过在新创建的线程对象上调用 start()方法来创建线程。请参见下面的代码片段。</p><figure class="ju jv jw jx fd ij"><div class="bz dy l di"><div class="mr ms l"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">线程创建方法 1</figcaption></figure><h2 id="60da" class="lp ka hi bd kb lq lr ls kf lt lu lv kj jg lw lx kn jk ly lz kr jo ma mb kv mc bi translated"><strong class="ak">这种线程创建方式的缺点</strong></h2><p id="fcfe" class="pw-post-body-paragraph iv iw hi ix b iy kx ja jb jc ky je jf jg kz ji jj jk la jm jn jo lb jq jr js hb bi translated">我们知道 Java 不支持多重继承。这样，由于用户创建的类(Mythread)从“线程类”继承了特征，所以用户创建的类(Mythread)不能继承另一个类。</p><blockquote class="mt mu mv"><p id="4609" class="iv iw mw ix b iy iz ja jb jc jd je jf mx jh ji jj my jl jm jn mz jp jq jr js hb bi translated">考虑下面的场景:“Employee”是父类，而“Manager”是子类。换句话说，“经理”类继承了“雇员”类的特征。现在，如果我们通过从“线程”类扩展来使“经理”类成为一个线程，“经理”类应该失去它与“雇员”类的关系，这意味着“经理”不再是“雇员”</p></blockquote><h2 id="63b6" class="lp ka hi bd kb lq lr ls kf lt lu lv kj jg lw lx kn jk ly lz kr jo ma mb kv mc bi translated">关于扩展线程类创建的线程的一些事实</h2><ol class=""><li id="b351" class="md me hi ix b iy kx jc ky jg na jk nb jo nc js mi mj mk ml bi translated"><strong class="ix hj">什么是 start()方法和 run()方法？</strong></li></ol><p id="014c" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">答:我们覆盖 run()方法，并指定我们希望分配给新创建的线程的任务。然后，我们在创建的线程实例上调用 start()方法。请记住，start()方法属于“Thread”类，它将在内部调用 run()方法。</p><p id="d3bc" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj"> 2。如果我们没有覆盖 run()方法会发生什么？</strong></p><figure class="ju jv jw jx fd ij"><div class="bz dy l di"><div class="mr ms l"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">No run()方法</figcaption></figure><pre class="ju jv jw jx fd nd ne nf ng aw nh bi"><span id="dd96" class="lp ka hi ne b fi ni nj l nk nl">Output: &lt;nothing&gt;</span></pre><p id="84c9" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">答:将创建一个线程，但它什么也不做，然后它将进入死亡状态。</p><blockquote class="mt mu mv"><p id="6719" class="iv iw mw ix b iy iz ja jb jc jd je jf mx jh ji jj my jl jm jn mz jp jq jr js hb bi translated">解释:当我们调用 start()方法时，将会创建一个线程。start()方法将在内部调用 run()方法。然后 JVM 检查子类是否包含 run()方法。如果是，那么将执行子类的 run 方法。如果没有，JVM 将执行父(线程)类的 run()方法。在 Java“Thread”类的 run()方法中不包含任何任务。因此，如果我们没有覆盖 run()方法，线程类的 run()方法将被调用，它什么也不做。</p></blockquote><p id="8c3b" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj"> 3。我们可以重载 run()方法吗？</strong></p><figure class="ju jv jw jx fd ij"><div class="bz dy l di"><div class="mr ms l"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">重载的 run()方法</figcaption></figure><pre class="ju jv jw jx fd nd ne nf ng aw nh bi"><span id="bc20" class="lp ka hi ne b fi ni nj l nk nl">Output: Hi!! This is from child thread's default run method</span></pre><p id="4763" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">答:是的，我们可以重载 run()方法。但是 start()方法只会调用没有参数的 run()方法。因此，重载的 run()方法不会被 start()方法调用。</p><p id="d1da" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj"> 4。我们可以调用 run()方法而不是 start()方法吗？</strong></p><figure class="ju jv jw jx fd ij"><div class="bz dy l di"><div class="mr ms l"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">直接调用 run()方法</figcaption></figure><pre class="ju jv jw jx fd nd ne nf ng aw nh bi"><span id="6125" class="lp ka hi ne b fi ni nj l nk nl">Output: This method is executed by: main</span></pre><p id="0ae2" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">答:我们可以直接调用 run()方法。但是它不会创建新的子线程。相反，父线程将执行子线程对象的 run()方法。这将是一个典型的 OOP 方法调用。</p><blockquote class="mt mu mv"><p id="35aa" class="iv iw mw ix b iy iz ja jb jc jd je jf mx jh ji jj my jl jm jn mz jp jq jr js hb bi translated">解释:当我们调用 start()方法时，它执行许多任务。</p><p id="066d" class="iv iw mw ix b iy iz ja jb jc jd je jf mx jh ji jj my jl jm jn mz jp jq jr js hb bi translated">它确定线程是否已经存在。如果是，将会抛出一个错误。如果不是，则启动一个新线程，并且状态从 new 变为 runnable。当线程调度器有机会运行时，新线程将调用自己的 run()方法。</p><p id="e673" class="iv iw mw ix b iy iz ja jb jc jd je jf mx jh ji jj my jl jm jn mz jp jq jr js hb bi translated">所以如果我们调用 run()方法而不是 start()方法，start()方法的上述职责就无法执行了。因此，不会创建新线程。因此，父线程将像普通的方法调用一样调用子线程的 run()方法。</p></blockquote><p id="a993" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj"> 5。我们可以覆盖 start()方法吗？</strong></p><figure class="ju jv jw jx fd ij"><div class="bz dy l di"><div class="mr ms l"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">覆盖开始方法</figcaption></figure><pre class="ju jv jw jx fd nd ne nf ng aw nh bi"><span id="2e8f" class="lp ka hi ne b fi ni nj l nk nl">Output: This is start method</span></pre><p id="eab2" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">答:是的，我们可以覆盖 start()方法。但是这里将执行子线程的 start()方法的主体。因此，不会创建新线程，也不会执行 run 方法。</p><blockquote class="mt mu mv"><p id="d834" class="iv iw mw ix b iy iz ja jb jc jd je jf mx jh ji jj my jl jm jn mz jp jq jr js hb bi translated">解释:只有“Thread”类的 start()方法有启动线程的指令。当我们调用 start()方法时，它检查子类是否有 start 方法。如果没有，它执行父线程的 start()方法。在这里，由于我们覆盖了 start()方法，现在子类有了自己的 start()方法。因此，当我们在这里调用 start()方法时，它将只执行子节点的 start()方法。</p></blockquote><h1 id="bdc3" class="jz ka hi bd kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw bi translated">方法 2:实现 Runnable 接口</h1><p id="fe88" class="pw-post-body-paragraph iv iw hi ix b iy kx ja jb jc ky je jf jg kz ji jj jk la jm jn jo lb jq jr js hb bi translated">要通过 runnable 接口创建线程，我们必须创建一个实现 runnable 接口的类。</p><figure class="ju jv jw jx fd ij"><div class="bz dy l di"><div class="mr ms l"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">通过可运行接口创建线程</figcaption></figure><p id="8577" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在实现了 runnable 接口之后，我们可以简单地通过创建一个线程对象来创建线程。</p><figure class="ju jv jw jx fd ij"><div class="bz dy l di"><div class="mr ms l"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">通过可运行接口创建线程</figcaption></figure><pre class="ju jv jw jx fd nd ne nf ng aw nh bi"><span id="dddf" class="lp ka hi ne b fi ni nj l nk nl">Output: Hi!! This is from a child thread which is created by runnable interface</span></pre><h2 id="eeef" class="lp ka hi bd kb lq lr ls kf lt lu lv kj jg lw lx kn jk ly lz kr jo ma mb kv mc bi translated">使用实现可运行接口方法创建线程的优势</h2><p id="673f" class="pw-post-body-paragraph iv iw hi ix b iy kx ja jb jc ky je jf jg kz ji jj jk la jm jn jo lb jq jr js hb bi translated">正如我们前面看到的，要创建一个线程，我们不能将“thread”类扩展到一个已经继承了另一个类的类。但是通过实现 runnable 接口，我们可以创建一个线程而不丢失它的继承关系。</p><blockquote class="mt mu mv"><p id="8557" class="iv iw mw ix b iy iz ja jb jc jd je jf mx jh ji jj my jl jm jn mz jp jq jr js hb bi translated">还记得前面的“经理”和“员工”的例子吗？通过使用这种方法,“雇员”可以同时是“职员”和线程。</p></blockquote><figure class="ju jv jw jx fd ij"><div class="bz dy l di"><div class="mr ms l"/></div></figure></div><div class="ab cl lc ld gp le" role="separator"><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh"/></div><div class="hb hc hd he hf"><h1 id="2b2c" class="jz ka hi bd kb kc lj ke kf kg lk ki kj kk ll km kn ko lm kq kr ks ln ku kv kw bi translated">线程调度程序</h1><figure class="ju jv jw jx fd ij"><div class="bz dy l di"><div class="mr ms l"/></div></figure><p id="822c" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">只需多次执行上述代码。每次执行都会得到不同的输出，对吗？它的发生是因为执行的顺序。在多线程“<strong class="ix hj">中，线程调度器“</strong>决定哪个线程应该先执行，哪个是下一个。线程调度器根据其 JRE 中指定的机制来决定执行顺序。不同的 JRE 可以有不同的机制来决定执行的顺序。</p><h2 id="e4e1" class="lp ka hi bd kb lq lr ls kf lt lu lv kj jg lw lx kn jk ly lz kr jo ma mb kv mc bi translated">线程优先级</h2><p id="ba0b" class="pw-post-body-paragraph iv iw hi ix b iy kx ja jb jc ky je jf jg kz ji jj jk la jm jn jo lb jq jr js hb bi translated">在多线程<strong class="ix hj">中，“线程调度器”</strong>根据<strong class="ix hj">线程的优先级</strong>将线程分配给处理器。具有最高优先级的线程将有机会在其他线程之前执行。</p><p id="5fb5" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">当我们在 Java 中创建一个线程时，它总是被赋予一个优先级。优先级可以在线程创建时由 JVM 定义，也可以由程序员直接定义。线程可接受的优先级范围是 1 到 10，10 为最高，1 为最低。</p><p id="a3d8" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如果线程优先级设置为 1-10 以外的值，应用程序将抛出“非法参数异常”</p><p id="43df" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如果两个线程具有相同的优先级，我们无法预测哪个线程将首先运行。它由线程调度器的算法决定(循环、先来先服务等)</p><p id="409f" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">主线程的优先级默认设置为 5</strong>。当我们创建新线程时，它们将<strong class="ix hj">继承其父线程</strong>的优先级。</p><p id="5e24" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">给线程分配<strong class="ix hj">优先级</strong>的步骤如下所述。</p><figure class="ju jv jw jx fd ij"><div class="bz dy l di"><div class="mr ms l"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">设置优先级的代码段</figcaption></figure></div><div class="ab cl lc ld gp le" role="separator"><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh"/></div><div class="hb hc hd he hf"><h1 id="809f" class="jz ka hi bd kb kc lj ke kf kg lk ki kj kk ll km kn ko lm kq kr ks ln ku kv kw bi translated">螺纹类型</h1><p id="bc9b" class="pw-post-body-paragraph iv iw hi ix b iy kx ja jb jc ky je jf jg kz ji jj jk la jm jn jo lb jq jr js hb bi translated">java 中有两种类型的线程。</p><figure class="ju jv jw jx fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es nm"><img src="../Images/906cef482e74e3dc63eb60f94e5259cc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1370/format:webp/1*BX30e2wb4nczJZG76v22OQ.jpeg"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">守护进程与非守护进程线程</figcaption></figure><p id="536a" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们可以创建一个非守护线程。setDaemon(true)。</p><figure class="ju jv jw jx fd ij"><div class="bz dy l di"><div class="mr ms l"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">创建守护线程的代码片段</figcaption></figure></div><div class="ab cl lc ld gp le" role="separator"><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh"/></div><div class="hb hc hd he hf"><h1 id="f6f8" class="jz ka hi bd kb kc lj ke kf kg lk ki kj kk ll km kn ko lm kq kr ks ln ku kv kw bi translated">线程中的一些重要方法</h1><h2 id="a31a" class="lp ka hi bd kb lq lr ls kf lt lu lv kj jg lw lx kn jk ly lz kr jo ma mb kv mc bi translated">螺纹连接</h2><p id="1e73" class="pw-post-body-paragraph iv iw hi ix b iy kx ja jb jc ky je jf jg kz ji jj jk la jm jn jo lb jq jr js hb bi translated">。join() —当前线程等待指定线程死亡。</p><p id="d90f" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">。加入或。join(long millis，int nanos) —当前线程等待指定时间，以等待指定线程死亡。</p><figure class="ju jv jw jx fd ij"><div class="bz dy l di"><div class="mr ms l"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">join()方法的代码片段</figcaption></figure><blockquote class="mt mu mv"><p id="03ae" class="iv iw mw ix b iy iz ja jb jc jd je jf mx jh ji jj my jl jm jn mz jp jq jr js hb bi translated">在上面的例子中，主线程将一直等到子线程(mythread)完成它的执行。</p></blockquote><h2 id="729b" class="lp ka hi bd kb lq lr ls kf lt lu lv kj jg lw lx kn jk ly lz kr jo ma mb kv mc bi translated">产量法</h2><p id="076d" class="pw-post-body-paragraph iv iw hi ix b iy kx ja jb jc ky je jf jg kz ji jj jk la jm jn jo lb jq jr js hb bi translated">yield 方法向调度程序暗示当前线程愿意给其他线程机会。Yield 是一种本机方法，程序员通常使用这种方法进行调试。</p><figure class="ju jv jw jx fd ij"><div class="bz dy l di"><div class="mr ms l"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">yield()方法的代码片段</figcaption></figure><blockquote class="mt mu mv"><p id="f7a8" class="iv iw mw ix b iy iz ja jb jc jd je jf mx jh ji jj my jl jm jn mz jp jq jr js hb bi translated">这里，当 yield 方法被调用时，主线程将把机会给任何其他线程(mythread1 或 mythread2 ),它将进入等待状态。线程调度器决定下一个运行的线程。</p></blockquote><h2 id="fc5e" class="lp ka hi bd kb lq lr ls kf lt lu lv kj jg lw lx kn jk ly lz kr jo ma mb kv mc bi translated">睡眠方法</h2><p id="7de3" class="pw-post-body-paragraph iv iw hi ix b iy kx ja jb jc ky je jf jg kz ji jj jk la jm jn jo lb jq jr js hb bi translated">当前正在运行的线程将在指定的时间内进入睡眠(等待状态)。</p><pre class="ju jv jw jx fd nd ne nf ng aw nh bi"><span id="ab82" class="lp ka hi ne b fi ni nj l nk nl">Ex: Thread.sleep(5000); //current thread will for 5 sec</span></pre><h2 id="01e8" class="lp ka hi bd kb lq lr ls kf lt lu lv kj jg lw lx kn jk ly lz kr jo ma mb kv mc bi translated"><strong class="ak">中断方法</strong></h2><p id="43e9" class="pw-post-body-paragraph iv iw hi ix b iy kx ja jb jc ky je jf jg kz ji jj jk la jm jn jo lb jq jr js hb bi translated">该方法可以中断处于等待状态的线程(sleep()、wait()、join())。因此，被中断的线程可以唤醒并执行其任务。</p><pre class="ju jv jw jx fd nd ne nf ng aw nh bi"><span id="e6fb" class="lp ka hi ne b fi ni nj l nk nl">Ex: t1.interrupt();</span></pre><blockquote class="mt mu mv"><p id="be87" class="iv iw mw ix b iy iz ja jb jc jd je jf mx jh ji jj my jl jm jn mz jp jq jr js hb bi translated">上面的代码会中断 t1 线程。</p></blockquote><p id="53f7" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">当我们调用 interrupt()方法时，如果指定的线程没有休眠(没有处于等待状态)，那么中断将一直等待，直到该线程进入休眠状态(等待状态)。如果线程进入睡眠状态，那么 interrupt()方法将中断线程。</p><h2 id="62e1" class="lp ka hi bd kb lq lr ls kf lt lu lv kj jg lw lx kn jk ly lz kr jo ma mb kv mc bi translated">该同步方法</h2><p id="97e9" class="pw-post-body-paragraph iv iw hi ix b iy kx ja jb jc ky je jf jg kz ji jj jk la jm jn jo lb jq jr js hb bi translated">如果我们使用 synchronize 方法，一次只有一个线程可以访问同一个对象中的方法。当线程调用一个同步方法时，该方法的对象被自动锁定，并在线程完成其任务时被释放。</p><pre class="ju jv jw jx fd nd ne nf ng aw nh bi"><span id="9dbb" class="lp ka hi ne b fi ni nj l nk nl">public synchronized void myfunction(){<br/>    //your code<br/>}</span></pre><h2 id="e891" class="lp ka hi bd kb lq lr ls kf lt lu lv kj jg lw lx kn jk ly lz kr jo ma mb kv mc bi translated">等待方法</h2><p id="8fd9" class="pw-post-body-paragraph iv iw hi ix b iy kx ja jb jc ky je jf jg kz ji jj jk la jm jn jo lb jq jr js hb bi translated">如果我们调用 wait()方法，当前线程将释放锁并进入<strong class="ix hj">等待状态</strong>。当另一个线程调用该对象的 notify()方法或 notifyAll()方法时，它将返回到<strong class="ix hj">可运行状态</strong>。</p><pre class="ju jv jw jx fd nd ne nf ng aw nh bi"><span id="b3ea" class="lp ka hi ne b fi ni nj l nk nl">synchronized (obj){<br/>   obj.wait();<br/>}</span></pre><h2 id="f39c" class="lp ka hi bd kb lq lr ls kf lt lu lv kj jg lw lx kn jk ly lz kr jo ma mb kv mc bi translated">通知方法</h2><p id="f762" class="pw-post-body-paragraph iv iw hi ix b iy kx ja jb jc ky je jf jg kz ji jj jk la jm jn jo lb jq jr js hb bi translated">当我们调用 notify()方法时，等待特定对象的线程之一将回到<strong class="ix hj">的可运行状态。</strong></p><pre class="ju jv jw jx fd nd ne nf ng aw nh bi"><span id="cc60" class="lp ka hi ne b fi ni nj l nk nl">synchronized (obj){<br/>   obj.notify();<br/>}</span></pre><h2 id="e173" class="lp ka hi bd kb lq lr ls kf lt lu lv kj jg lw lx kn jk ly lz kr jo ma mb kv mc bi translated">通知所有方法</h2><p id="d240" class="pw-post-body-paragraph iv iw hi ix b iy kx ja jb jc ky je jf jg kz ji jj jk la jm jn jo lb jq jr js hb bi translated">当我们调用 notifyAll()方法时，等待特定对象的每一个线程都会回到<strong class="ix hj"> Runnable 状态。</strong></p><pre class="ju jv jw jx fd nd ne nf ng aw nh bi"><span id="eaef" class="lp ka hi ne b fi ni nj l nk nl">synchronized (obj){<br/>   obj.notifyAll();<br/>}</span></pre><h2 id="01b6" class="lp ka hi bd kb lq lr ls kf lt lu lv kj jg lw lx kn jk ly lz kr jo ma mb kv mc bi translated">继续学习❤️</h2></div><div class="ab cl lc ld gp le" role="separator"><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh"/></div><div class="hb hc hd he hf"><h1 id="6601" class="jz ka hi bd kb kc lj ke kf kg lk ki kj kk ll km kn ko lm kq kr ks ln ku kv kw bi translated">参考</h1><p id="63ce" class="pw-post-body-paragraph iv iw hi ix b iy kx ja jb jc ky je jf jg kz ji jj jk la jm jn jo lb jq jr js hb bi translated">2018.<em class="mw">Java 01 中的线程</em>。[视频]可在:&lt;<a class="ae iu" href="https://www.youtube.com/watch?v=Y9JDbm8edOk" rel="noopener ugc nofollow" target="_blank">https://www.youtube.com/watch?v=Y9JDbm8edOk</a>&gt;【2021 年 5 月 12 日访问】。</p><p id="ffde" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><a class="ae iu" href="http://www.javatpoint.com." rel="noopener ugc nofollow" target="_blank">www.javatpoint.com。</a> 2021。<em class="mw">教程—Java point</em>。[在线]可在:&lt;<a class="ae iu" href="https://www.javatpoint.com/" rel="noopener ugc nofollow" target="_blank">https://www.javatpoint.com/</a>&gt;【2021 年 5 月 12 日访问】。</p><p id="0eb6" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">Docs.oracle.com 2021 年。<em class="mw">线程(Java 平台 SE 7 ) </em>。[在线]见:&lt;<a class="ae iu" href="https://docs.oracle.com/javase/7/docs/api/java/lang/Thread.html" rel="noopener ugc nofollow" target="_blank">https://docs . Oracle . com/javase/7/docs/API/Java/lang/thread . html</a>&gt;【2021 年 5 月 12 日访问】。</p></div></div>    
</body>
</html>