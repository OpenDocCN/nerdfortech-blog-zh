<html>
<head>
<title>Typescript Generics: Strong Yet Flexible Types</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Typescript泛型:强大而灵活的类型</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/typescript-generics-strong-yet-flexible-types-27b33fdbe7eb?source=collection_archive---------3-----------------------#2021-08-30">https://medium.com/nerd-for-tech/typescript-generics-strong-yet-flexible-types-27b33fdbe7eb?source=collection_archive---------3-----------------------#2021-08-30</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/d6de57a6f248ef97a16469e14565cb2d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*cDyReGu8uCDz9ich"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">由<a class="ae iu" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">上的</a><a class="ae iu" href="https://unsplash.com/@universaleye?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">万用眼</a>拍照</figcaption></figure><p id="7892" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">Typescript是Javascript的一个强大扩展，它允许我们利用强类型变量，并附带了一些有用的工具来创建灵活的、可重用的代码，这些代码仍然可以进行错误类型检查，即使类型可能因用途而异。</p><p id="a756" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我将在Typescript中深入研究<strong class="ix hj">泛型</strong>。这些让我们把变量绑在一起，不管它们的初始类型。我假设您已经了解了Typescript的基础知识。如果没有，看看我之前的博文。</p><div class="jt ju ez fb jv jw"><a rel="noopener follow" target="_blank" href="/nerd-for-tech/why-you-should-learn-typescript-4808211c6cac"><div class="jx ab dw"><div class="jy ab jz cl cj ka"><h2 class="bd hj fi z dy kb ea eb kc ed ef hh bi translated">为什么你应该学习打字稿</h2><div class="kd l"><h3 class="bd b fi z dy kb ea eb kc ed ef dx translated">我已经在编码生态系统中漫游了一段时间，我有一个我听说过的技术列表…</h3></div><div class="ke l"><p class="bd b fp z dy kb ea eb kc ed ef dx translated">medium.com</p></div></div><div class="kf l"><div class="kg l kh ki kj kf kk io jw"/></div></div></a></div><h2 id="66ce" class="kl km hi bd kn ko kp kq kr ks kt ku kv jg kw kx ky jk kz la lb jo lc ld le lf bi translated">基本用法</h2><p id="3db0" class="pw-post-body-paragraph iv iw hi ix b iy lg ja jb jc lh je jf jg li ji jj jk lj jm jn jo lk jq jr js hb bi translated">让我们考虑一个非常基本的函数的几个版本。它接受一个未知类型的参数，并返回赋给该参数变量的值。在JS中，我们可以简单地声明函数:</p><figure class="ll lm ln lo fd ij"><div class="bz dy l di"><div class="lp lq l"/></div></figure><p id="edf7" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">Typescript实际上对此并不满意，我们根本没有声明任何变量类型，所以我们得到一个错误:</p><figure class="ll lm ln lo fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lr"><img src="../Images/c2e91fc50aef9af7642a783c261eab01.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Sqn-tM9gPYecg67lITNVGw.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">正常功能误差</figcaption></figure><p id="6c6c" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">编译器想知道什么样的参数会被传入这个函数，因为我们不知道，我们可能倾向于添加<code class="du ls lt lu lv b">any</code>类型声明来简单地允许我们想要传入的任何东西。</p><figure class="ll lm ln lo fd ij"><div class="bz dy l di"><div class="lp lq l"/></div></figure><p id="d62d" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">好了，现在编译器高兴了，但是我们真的没有完成多少。我们没有利用Typescript带给我们的类型检查，只是创建了一个变通办法。如果我们的目标是确保如果传入一个<code class="du ls lt lu lv b">string</code>类型，那么将返回一个字符串，如果传入一个<code class="du ls lt lu lv b">number</code>类型，那么将返回一个数字，我们可能需要编写两个不同的类型安全函数:</p><figure class="ll lm ln lo fd ij"><div class="bz dy l di"><div class="lp lq l"/></div></figure><p id="c995" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">现在，我们可以使用各自的功能来获得我们想要的结果，但是，如果你问我，这看起来不是很枯燥。函数的逻辑是重复的，我们需要重复我们的代码来适应我们可能的参数类型。这就是<strong class="ix hj">仿制药</strong>拯救世界的地方。泛型使用<strong class="ix hj">类型参数</strong>来声明“泛型”类型，这些类型可以跨函数使用，但要确保在代码的不同部分使用相同的类型。这是我们的函数，类型声明为泛型<code class="du ls lt lu lv b">T</code>或<code class="du ls lt lu lv b">&lt;T&gt;</code>。</p><figure class="ll lm ln lo fd ij"><div class="bz dy l di"><div class="lp lq l"/></div></figure><p id="4db0" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这段代码在传入的参数和函数返回的变量类型之间创建了一个链接。传入的内容必须与返回的内容类型相同。</p><figure class="ll lm ln lo fd ij"><div class="bz dy l di"><div class="lp lq l"/></div></figure><p id="1727" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">现在我们可以重用这个函数，它将正确地使用一个<code class="du ls lt lu lv b">number</code>或一个<code class="du ls lt lu lv b">string</code>作为参数。如果我们试图让我们的逻辑无论如何都返回一个字符串会怎么样？</p><figure class="ll lm ln lo fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lw"><img src="../Images/6a54922d178644e542411154b0c0efce.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iUpaWGt_pnMLJgNB-Ecp5A.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">铸造误差</figcaption></figure><p id="67de" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这个错误是有道理的。如果我们将参数转换成函数逻辑中的字符串，那么我们就不能保持<code class="du ls lt lu lv b">T</code>泛型类型的确定性。如果我们传入一个数字，这个函数也不可能返回一个数字，因为它会被转换成一个字符串。Typescript提前考虑，让我们知道这将是一个问题，然后才成为一个问题。</p><h2 id="0a80" class="kl km hi bd kn ko kp kq kr ks kt ku kv jg kw kx ky jk kz la lb jo lc ld le lf bi translated">对多种类型使用泛型</h2><p id="da19" class="pw-post-body-paragraph iv iw hi ix b iy lg ja jb jc lh je jf jg li ji jj jk lj jm jn jo lk jq jr js hb bi translated">我们可以使用相同的类型参数语法来声明要通过函数引用的多个类型。</p><figure class="ll lm ln lo fd ij"><div class="bz dy l di"><div class="lp lq l"/></div></figure><p id="f93d" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这将返回<code class="du ls lt lu lv b">false</code>，一个用<code class="du ls lt lu lv b">V</code>泛型类型设置的布尔类型。</p><h2 id="9a91" class="kl km hi bd kn ko kp kq kr ks kt ku kv jg kw kx ky jk kz la lb jo lc ld le lf bi translated">创建具有泛型类型的类</h2><p id="15a5" class="pw-post-body-paragraph iv iw hi ix b iy lg ja jb jc lh je jf jg li ji jj jk lj jm jn jo lk jq jr js hb bi translated">我们还可以创建利用这些灵活的泛型类型的类。让我们创建一个自定义的数组类，它可以用来创建一个我们稍后决定的任何类型的数组。</p><figure class="ll lm ln lo fd ij"><div class="bz dy l di"><div class="lp lq l"/></div></figure><p id="1b4f" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们可以在后续的类函数中使用<code class="du ls lt lu lv b">T</code>类型声明来确保类型保持一致。</p><h2 id="00f9" class="kl km hi bd kn ko kp kq kr ks kt ku kv jg kw kx ky jk kz la lb jo lc ld le lf bi translated">使用泛型扩展现有的类型定义</h2><p id="962d" class="pw-post-body-paragraph iv iw hi ix b iy lg ja jb jc lh je jf jg li ji jj jk lj jm jn jo lk jq jr js hb bi translated">我们可能会遇到这样的情况，我们有一个现有的接口或类型定义，我们想使用它，但除此之外还要添加新的泛型定义。我们可以使用extends关键字来实现这一点。</p><figure class="ll lm ln lo fd ij"><div class="bz dy l di"><div class="lp lq l"/></div></figure><p id="3d44" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们可以尝试从<code class="du ls lt lu lv b">funcArgs</code>接口传入一个期望的类型，但是我们会得到一个错误。</p><figure class="ll lm ln lo fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lx"><img src="../Images/0757d96f10479501a8343719dc43ebfd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wYB4qtf2ZUX-2atQdJjttg.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">funcArgs错误</figcaption></figure><p id="5383" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这很有意义，我们没有传入正确的参数类型。</p><figure class="ll lm ln lo fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ly"><img src="../Images/e7a3731e608d4fd13834bd183115432a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ivihD9DTdV6DIml08CWiGg.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">funcArgs错误2</figcaption></figure><p id="e838" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">即使我们正确地传入了单个<code class="du ls lt lu lv b">num</code>参数，我们仍然没有满足funcArgs接口设置的要求，它需要一个<code class="du ls lt lu lv b">num</code>和一个<code class="du ls lt lu lv b">str</code>变量。</p><figure class="ll lm ln lo fd ij"><div class="bz dy l di"><div class="lp lq l"/></div></figure><p id="84a9" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们走吧。我们已经满足了接口的约束，但是添加一个admin <code class="du ls lt lu lv b">argument</code>作为布尔值，会将<code class="du ls lt lu lv b">T</code>泛型类型设置为<code class="du ls lt lu lv b">funcArgs</code>类型加上一个布尔值，这可以在函数逻辑中一起引用。这通常会抛出一个错误，但是因为我们使用了<code class="du ls lt lu lv b">T extends</code>关键字，编译器很高兴。</p><h1 id="ce21" class="lz km hi bd kn ma mb mc kr md me mf kv mg mh mi ky mj mk ml lb mm mn mo le mp bi translated">结论</h1><p id="e9d6" class="pw-post-body-paragraph iv iw hi ix b iy lg ja jb jc lh je jf jg li ji jj jk lj jm jn jo lk jq jr js hb bi translated">泛型在其他强类型语言中很常见，对其用法的充分理解为开发人员创建仍受益于强类型检查的可重用代码提供了许多可能性。感谢您的阅读和快乐编码！</p></div></div>    
</body>
</html>