<html>
<head>
<title>Point &amp; click to move | Unity</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">点击移动| Unity</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/point-click-to-move-unity-6e2a0ab858fc?source=collection_archive---------6-----------------------#2021-07-16">https://medium.com/nerd-for-tech/point-click-to-move-unity-6e2a0ab858fc?source=collection_archive---------6-----------------------#2021-07-16</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><h2 id="9e4b" class="hg hh hi bd b fp hj hk hl hm hn ho dx hp translated" aria-label="kicker paragraph">统一指南</h2><div class=""/><div class=""><h2 id="e124" class="pw-subtitle-paragraph io hr hi bd b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf dx translated">关于如何在Unity中使用NavMesh代理移动播放器的快速指南</h2></div><figure class="jh ji jj jk fd jl er es paragraph-image"><div role="button" tabindex="0" class="jm jn di jo bf jp"><div class="er es jg"><img src="../Images/45a9b6f40428abad0f6dcfe2d6f2da31.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*NItKlvidsyFepDEJ5eaOGA.gif"/></div></div></figure><p id="d067" class="pw-post-body-paragraph js jt hi ju b jv jw is jx jy jz iv ka kb kc kd ke kf kg kh ki kj kk kl km kn hb bi translated"><strong class="ju hs">目标</strong>:将玩家移向地面上由鼠标点击定义的一个点。</p><p id="bdfc" class="pw-post-body-paragraph js jt hi ju b jv jw is jx jy jz iv ka kb kc kd ke kf kg kh ki kj kk kl km kn hb bi translated">在上一篇文章中，我介绍了<a class="ae ko" rel="noopener" href="/nerd-for-tech/synchronizing-audio-visuals-for-cutscenes-unity-2839947296f9">如何同步音频和视频来构建过场动画</a>。现在，是时候实现播放器功能了，我们将使用NavMesh代理开始移动，它将通过简单的单击向定义的位置移动。</p><h1 id="d184" class="kp kq hi bd kr ks kt ku kv kw kx ky kz ix la iy lb ja lc jb ld jd le je lf lg bi translated">当前场景</h1><p id="8a7a" class="pw-post-body-paragraph js jt hi ju b jv lh is jx jy li iv ka kb lj kd ke kf lk kh ki kj ll kl km kn hb bi translated">首先，让我们看看当前的场景。有几个陈列柜，周围有警卫。每个游戏对象都在地板之上，其中包含一个网格碰撞器:</p><figure class="jh ji jj jk fd jl er es paragraph-image"><div role="button" tabindex="0" class="jm jn di jo bf jp"><div class="er es jg"><img src="../Images/e87b36be5ca434394b2e6fcd3b69fe08.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QJzoZf48PJxvJTpSkhLXRg.png"/></div></div></figure><div class="jh ji jj jk fd ab cb"><figure class="lm jl ln lo lp lq lr paragraph-image"><div role="button" tabindex="0" class="jm jn di jo bf jp"><img src="../Images/b4a9490742298faa955af0ea1b22b3dd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1506/format:webp/1*Peo5i4fN8nWeSLkKm55-fw.png"/></div></figure><figure class="lm jl ls lo lp lq lr paragraph-image"><div role="button" tabindex="0" class="jm jn di jo bf jp"><img src="../Images/d255ec3748e5669007f81d28946a0e86.png" data-original-src="https://miro.medium.com/v2/resize:fit:496/format:webp/1*7ZbgTKIOhUwikeoe9c80-w.png"/></div></figure></div><h1 id="35bf" class="kp kq hi bd kr ks kt ku kv kw kx ky kz ix la iy lb ja lc jb ld jd le je lf lg bi translated">烘焙导航网</h1><p id="0d62" class="pw-post-body-paragraph js jt hi ju b jv lh is jx jy li iv ka kb lj kd ke kf lk kh ki kj ll kl km kn hb bi translated">NavMesh允许我们通过分析场景中静态的不同网格和地形来创建导航网格。所以，为了创建一个导航网格，我们应该通过<em class="lt">烘焙</em>来选择和处理影响导航的游戏对象。</p><p id="68e4" class="pw-post-body-paragraph js jt hi ju b jv jw is jx jy jz iv ka kb kc kd ke kf kg kh ki kj kk kl km kn hb bi translated">为此，让我们通过点击<em class="lt">窗口&gt; AI &gt;导航</em>来打开导航窗口。窗口打开后，我们点击“烘焙”选项卡，根据需要修改属性，最后我们点击<em class="lt">烘焙</em>按钮:</p><div class="jh ji jj jk fd ab cb"><figure class="lm jl lu lo lp lq lr paragraph-image"><div role="button" tabindex="0" class="jm jn di jo bf jp"><img src="../Images/2b328cf9da9f64f79449c6274de49015.png" data-original-src="https://miro.medium.com/v2/resize:fit:980/1*69dxL4bg7EdvlNKoIe5CEQ.gif"/></div></figure><figure class="lm jl lv lo lp lq lr paragraph-image"><div role="button" tabindex="0" class="jm jn di jo bf jp"><img src="../Images/6f04a6c1a6dbda405c166df67c24122d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1022/1*4MetXHKBQcHsfvcpM7y7gQ.gif"/></div></figure></div><p id="286d" class="pw-post-body-paragraph js jt hi ju b jv jw is jx jy jz iv ka kb kc kd ke kf kg kh ki kj kk kl km kn hb bi translated">一旦地板完成烘焙，我们将能够通过场景窗口看到蓝色的导航网格。这是地板上可行走表面的近似值:</p><figure class="jh ji jj jk fd jl er es paragraph-image"><div role="button" tabindex="0" class="jm jn di jo bf jp"><div class="er es jg"><img src="../Images/f74ea99bc1c7573564e2d05317b25414.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hJIQWXfEoF9tMsok28gg2w.png"/></div></div></figure><p id="76f7" class="pw-post-body-paragraph js jt hi ju b jv jw is jx jy jz iv ka kb kc kd ke kf kg kh ki kj kk kl km kn hb bi translated">如果您想了解更多关于<strong class="ju hs"> <em class="lt"> NavMesh </em> </strong>的信息，您可以访问Unity文档:</p><div class="lw lx ez fb ly lz"><a href="https://docs.unity3d.com/Manual/nav-BuildingNavMesh.html" rel="noopener  ugc nofollow" target="_blank"><div class="ma ab dw"><div class="mb ab mc cl cj md"><h2 class="bd hs fi z dy me ea eb mf ed ef hr bi translated">构建导航网格</h2><div class="mg l"><h3 class="bd b fi z dy me ea eb mf ed ef dx translated">从层级几何体创建NavMesh的过程称为NavMesh烘焙。该进程收集渲染…</h3></div><div class="mh l"><p class="bd b fp z dy me ea eb mf ed ef dx translated">docs.unity3d.com</p></div></div><div class="mi l"><div class="mj l mk ml mm mi mn jq lz"/></div></div></a></div><h1 id="6a63" class="kp kq hi bd kr ks kt ku kv kw kx ky kz ix la iy lb ja lc jb ld jd le je lf lg bi translated">测试导航网格</h1><p id="dc2a" class="pw-post-body-paragraph js jt hi ju b jv lh is jx jy li iv ka kb lj kd ke kf lk kh ki kj ll kl km kn hb bi translated">现在，为了测试烘焙的NavMesh，我们将使用一个简单的胶囊来代表我们游戏中的玩家:</p><div class="jh ji jj jk fd ab cb"><figure class="lm jl mo lo lp lq lr paragraph-image"><div role="button" tabindex="0" class="jm jn di jo bf jp"><img src="../Images/de3678bca4b37b8d3e9b9fc68763668f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1516/format:webp/1*SrrreW_RkOg2IjuV-SmLLg.png"/></div></figure><figure class="lm jl mp lo lp lq lr paragraph-image"><div role="button" tabindex="0" class="jm jn di jo bf jp"><img src="../Images/f0a44a2872ab92e6c7cb8f480131e192.png" data-original-src="https://miro.medium.com/v2/resize:fit:486/format:webp/1*ij4ff0WkIAwpmbTyQFOx5A.png"/></div></figure></div><p id="db3d" class="pw-post-body-paragraph js jt hi ju b jv jw is jx jy jz iv ka kb kc kd ke kf kg kh ki kj kk kl km kn hb bi translated">要使用导航网格来导航场景，我们需要将一个<em class="lt"> </em> <strong class="ju hs"> <em class="lt">导航网格代理</em> </strong>组件附加到胶囊:</p><figure class="jh ji jj jk fd jl er es paragraph-image"><div class="er es mq"><img src="../Images/039b0a0eb000e20ae1a9f318439b4936.png" data-original-src="https://miro.medium.com/v2/resize:fit:1240/1*w8PA0Ffi27PSTG9CXiHOSA.gif"/></div></figure><p id="092d" class="pw-post-body-paragraph js jt hi ju b jv jw is jx jy jz iv ka kb kc kd ke kf kg kh ki kj kk kl km kn hb bi translated">如果您想了解更多关于<strong class="ju hs"> <em class="lt">导航网代理</em> </strong>的信息，您可以访问Unity docs:</p><div class="lw lx ez fb ly lz"><a href="https://docs.unity3d.com/Manual/nav-CreateNavMeshAgent.html" rel="noopener  ugc nofollow" target="_blank"><div class="ma ab dw"><div class="mb ab mc cl cj md"><h2 class="bd hs fi z dy me ea eb mf ed ef hr bi translated">创建NavMesh代理</h2><div class="mg l"><h3 class="bd b fi z dy me ea eb mf ed ef dx translated">一旦你有了Unity生成的一个网格来近似你环境中的可行走区域和障碍物…</h3></div><div class="mh l"><p class="bd b fp z dy me ea eb mf ed ef dx translated">docs.unity3d.com</p></div></div><div class="mi l"><div class="mr l mk ml mm mi mn jq lz"/></div></div></a></div><p id="abb2" class="pw-post-body-paragraph js jt hi ju b jv jw is jx jy jz iv ka kb kc kd ke kf kg kh ki kj kk kl km kn hb bi translated">现在，为了移动胶囊，让我们创建一个新的<strong class="ju hs">玩家</strong>脚本并附加它:</p><div class="jh ji jj jk fd ab cb"><figure class="lm jl ms lo lp lq lr paragraph-image"><img src="../Images/713627b618560f961517f60e0da3709c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1020/format:webp/1*RELPHaNISYLwOO9-iz4EsA.png"/></figure><figure class="lm jl mt lo lp lq lr paragraph-image"><div role="button" tabindex="0" class="jm jn di jo bf jp"><img src="../Images/06c9a9dd10d719a311de620e348a5354.png" data-original-src="https://miro.medium.com/v2/resize:fit:720/format:webp/1*cUtj6DM1zFeyXi345zwd6Q.png"/></div></figure></div><p id="eece" class="pw-post-body-paragraph js jt hi ju b jv jw is jx jy jz iv ka kb kc kd ke kf kg kh ki kj kk kl km kn hb bi translated">然后，为了能够处理<strong class="ju hs"> <em class="lt">导航网格代理</em> </strong>，让我们打开脚本并将AI库包含到脚本中:</p><figure class="jh ji jj jk fd jl er es paragraph-image"><div class="er es mu"><img src="../Images/865c6c1d5d0da953df3aa43ab3d5ad00.png" data-original-src="https://miro.medium.com/v2/resize:fit:1006/format:webp/1*OMDiTqduErredHendb6HlA.png"/></div></figure><p id="728d" class="pw-post-body-paragraph js jt hi ju b jv jw is jx jy jz iv ka kb kc kd ke kf kg kh ki kj kk kl km kn hb bi translated">现在，让我们创建一个新的私有<strong class="ju hs"> NavMeshAgent </strong>来存储播放器中组件的引用:</p><figure class="jh ji jj jk fd jl er es paragraph-image"><div class="er es mv"><img src="../Images/26d55d982b76c31141eeca4f3419c1d7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1048/format:webp/1*j4z0Yc5-0X80_u90mECW-Q.png"/></div></figure><p id="8d65" class="pw-post-body-paragraph js jt hi ju b jv jw is jx jy jz iv ka kb kc kd ke kf kg kh ki kj kk kl km kn hb bi translated">然后，在<strong class="ju hs"> Start </strong>方法中，让我们通过使用<strong class="ju hs"> GetComponent </strong>方法<strong class="ju hs">T5】来初始化变量，并对其进行空检查以遵循最佳实践:</strong></p><figure class="jh ji jj jk fd jl er es paragraph-image"><div class="er es mw"><img src="../Images/95fd0cfd8b6f719a1d32ff1a0ecdb69d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1332/format:webp/1*RvuWE6hhjnIfbRhUaJxn5Q.png"/></div></figure><p id="cf3b" class="pw-post-body-paragraph js jt hi ju b jv jw is jx jy jz iv ka kb kc kd ke kf kg kh ki kj kk kl km kn hb bi translated">现在，为了移动播放器，让我们通过使用<strong class="ju hs"> GetMouseButtonDown </strong>方法来检查<strong class="ju hs"> Update </strong>方法中的左键单击输入:</p><figure class="jh ji jj jk fd jl er es paragraph-image"><div class="er es mx"><img src="../Images/acbb4e653baec284cff3f603d8692faf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1108/format:webp/1*dEiocYy4NkVx0yXxQ21yUQ.png"/></div></figure><p id="334b" class="pw-post-body-paragraph js jt hi ju b jv jw is jx jy jz iv ka kb kc kd ke kf kg kh ki kj kk kl km kn hb bi translated">当游戏收到左击输入时，我们需要从主摄像机使用<strong class="ju hs"> ScreenPointToRay </strong>方法创建一个新的光线。这种方法将允许我们从摄像机向屏幕点发送光线，该点将由鼠标光标的位置定义:</p><figure class="jh ji jj jk fd jl er es paragraph-image"><div role="button" tabindex="0" class="jm jn di jo bf jp"><div class="er es my"><img src="../Images/06240991a4a5cbc36f6714db92711e49.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DJibXSr6VwS19uvf5DzWjA.png"/></div></div></figure><p id="4dec" class="pw-post-body-paragraph js jt hi ju b jv jw is jx jy jz iv ka kb kc kd ke kf kg kh ki kj kk kl km kn hb bi translated">如果您想了解更多关于<strong class="ju hs"> ScreenPointToRay </strong>方法的信息，您可以访问Unity文档:</p><div class="lw lx ez fb ly lz"><a href="https://docs.unity3d.com/ScriptReference/Camera.ScreenPointToRay.html" rel="noopener  ugc nofollow" target="_blank"><div class="ma ab dw"><div class="mb ab mc cl cj md"><h2 class="bd hs fi z dy me ea eb mf ed ef hr bi translated">相机。屏幕点存储</h2><div class="mg l"><h3 class="bd b fi z dy me ea eb mf ed ef dx translated">建议更改感谢您帮助我们提高Unity文档的质量。虽然我们不能接受所有的…</h3></div><div class="mh l"><p class="bd b fp z dy me ea eb mf ed ef dx translated">docs.unity3d.com</p></div></div><div class="mi l"><div class="mz l mk ml mm mi mn jq lz"/></div></div></a></div><p id="4479" class="pw-post-body-paragraph js jt hi ju b jv jw is jx jy jz iv ka kb kc kd ke kf kg kh ki kj kk kl km kn hb bi translated">一旦光线被创建，让我们通过使用<strong class="ju hs">物理来检查它是否击中了什么东西(100单位距离内的一个对撞机)。光线投射</strong>法。如果射线碰到碰撞器，我们将在一个<strong class="ju hs"> RaycastHit </strong>变量中得到结果。这个变量将包含关于hit的信息，我们将使用它来设置<strong class="ju hs"> <em class="lt">导航网格代理</em> </strong>的目的地，方法是使用它的<strong class="ju hs"> SetDestination </strong>:</p><figure class="jh ji jj jk fd jl er es paragraph-image"><div role="button" tabindex="0" class="jm jn di jo bf jp"><div class="er es na"><img src="../Images/0044609f250d6f6cdc895de8b8e20582.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JFZeRyUGxuQnBhBWVyoAXg.png"/></div></div></figure><p id="bb02" class="pw-post-body-paragraph js jt hi ju b jv jw is jx jy jz iv ka kb kc kd ke kf kg kh ki kj kk kl km kn hb bi translated">如果你想了解更多关于<strong class="ju hs">物理学的知识。Raycast </strong>方法您可以访问Unity文档:</p><div class="lw lx ez fb ly lz"><a href="https://docs.unity3d.com/ScriptReference/Physics.Raycast.html" rel="noopener  ugc nofollow" target="_blank"><div class="ma ab dw"><div class="mb ab mc cl cj md"><h2 class="bd hs fi z dy me ea eb mf ed ef hr bi translated">物理。光线投射</h2><div class="mg l"><h3 class="bd b fi z dy me ea eb mf ed ef dx translated">建议更改感谢您帮助我们提高Unity文档的质量。虽然我们不能接受所有的…</h3></div><div class="mh l"><p class="bd b fp z dy me ea eb mf ed ef dx translated">docs.unity3d.com</p></div></div><div class="mi l"><div class="nb l mk ml mm mi mn jq lz"/></div></div></a></div><p id="0110" class="pw-post-body-paragraph js jt hi ju b jv jw is jx jy jz iv ka kb kc kd ke kf kg kh ki kj kk kl km kn hb bi translated">这样，每次我们输入左击，我们就能够将胶囊移动到光标位置:</p><figure class="jh ji jj jk fd jl er es paragraph-image"><div role="button" tabindex="0" class="jm jn di jo bf jp"><div class="er es jg"><img src="../Images/62f636c4a230d1d85e5d47bdfa9f462b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*P4fw4aNOoVrNz5heGztKjg.gif"/></div></div></figure><p id="00d0" class="pw-post-body-paragraph js jt hi ju b jv jw is jx jy jz iv ka kb kc kd ke kf kg kh ki kj kk kl km kn hb bi translated">你会注意到胶囊可以穿过场景中的游戏物体。因此，如果要确保NavMesh包含场景中的障碍物，请选择所有障碍物:</p><div class="jh ji jj jk fd ab cb"><figure class="lm jl nc lo lp lq lr paragraph-image"><div role="button" tabindex="0" class="jm jn di jo bf jp"><img src="../Images/a9b28ccd164c73e45610d55856794c83.png" data-original-src="https://miro.medium.com/v2/resize:fit:1470/1*PqT5shRqjdv94rJxRQl_5A.gif"/></div></figure><figure class="lm jl nd lo lp lq lr paragraph-image"><div role="button" tabindex="0" class="jm jn di jo bf jp"><img src="../Images/27feabaf9aacee529045a269a3f9de6c.png" data-original-src="https://miro.medium.com/v2/resize:fit:532/1*fV-GaJJdqoM2IVLGnsytgw.gif"/></div></figure></div><p id="334a" class="pw-post-body-paragraph js jt hi ju b jv jw is jx jy jz iv ka kb kc kd ke kf kg kh ki kj kk kl km kn hb bi translated">选中后，点击检查器右上角的<strong class="ju hs">静态</strong>复选框。这将使游戏对象及其子对象保持静态:</p><div class="jh ji jj jk fd ab cb"><figure class="lm jl ne lo lp lq lr paragraph-image"><div role="button" tabindex="0" class="jm jn di jo bf jp"><img src="../Images/4cf2f2fe6cbc1f34726df5af8908d251.png" data-original-src="https://miro.medium.com/v2/resize:fit:670/1*I5nY3g9xprz8II_-g2czfw.gif"/></div></figure><figure class="lm jl nf lo lp lq lr paragraph-image"><img src="../Images/eee8b6d77a4447a25318a908b47fc7e9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1184/1*HGw-axD441YdmHL4afB5Pw.gif"/></figure></div><p id="21d7" class="pw-post-body-paragraph js jt hi ju b jv jw is jx jy jz iv ka kb kc kd ke kf kg kh ki kj kk kl km kn hb bi translated">最后，要更新NavMesh，再次打开<em class="lt">导航</em>窗口，点击左侧的<em class="lt">清除</em>按钮。然后，再次点击<em class="lt">烘焙</em>按钮，你会在你的场景视图中注意到新的NavMesh:</p><div class="jh ji jj jk fd ab cb"><figure class="lm jl ng lo lp lq lr paragraph-image"><div role="button" tabindex="0" class="jm jn di jo bf jp"><img src="../Images/55a8ec3391bfa8d47ea0f40d08134248.png" data-original-src="https://miro.medium.com/v2/resize:fit:516/1*zGcVakbTQmPkMUIFBUiGbA.gif"/></div></figure><figure class="lm jl nh lo lp lq lr paragraph-image"><div role="button" tabindex="0" class="jm jn di jo bf jp"><img src="../Images/feae17672dcaabe1493356875032dd06.png" data-original-src="https://miro.medium.com/v2/resize:fit:1486/format:webp/1*AnQAZ9sbjIqwOwEdPRg2Fg.png"/></div></figure></div><p id="92ef" class="pw-post-body-paragraph js jt hi ju b jv jw is jx jy jz iv ka kb kc kd ke kf kg kh ki kj kk kl km kn hb bi translated">如果我们用Unity运行游戏，我们会注意到胶囊找到了一条不与静态游戏对象冲突的路径来到达它的目的地:</p><figure class="jh ji jj jk fd jl er es paragraph-image"><div role="button" tabindex="0" class="jm jn di jo bf jp"><div class="er es jg"><img src="../Images/bd6aeaace282b952be885cc97245d732.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*GauWdJwmVpIPVs-uDKiOVA.gif"/></div></div></figure><p id="13e5" class="pw-post-body-paragraph js jt hi ju b jv jw is jx jy jz iv ka kb kc kd ke kf kg kh ki kj kk kl km kn hb bi translated">就是这样，我们可以用Unity点击移动玩家！:d .我将在下一篇文章中看到你，在那里我将展示如何使用Unity的动画系统来移动玩家及其相应的3D模型。</p></div><div class="ab cl ni nj gp nk" role="separator"><span class="nl bw bk nm nn no"/><span class="nl bw bk nm nn no"/><span class="nl bw bk nm nn"/></div><div class="hb hc hd he hf"><blockquote class="np nq nr"><p id="696c" class="js jt lt ju b jv jw is jx jy jz iv ka ns kc kd ke nt kg kh ki nu kk kl km kn hb bi translated"><em class="hi">如果你想更多地了解我，欢迎登陆</em><a class="ae ko" href="https://www.linkedin.com/in/fas444/" rel="noopener ugc nofollow" target="_blank"><strong class="ju hs"><em class="hi">LinkedIn</em></strong></a><strong class="ju hs"><em class="hi"/></strong><em class="hi">或访问我的</em> <a class="ae ko" href="http://fernandoalcasan.com/" rel="noopener ugc nofollow" target="_blank"> <strong class="ju hs"> <em class="hi">网站</em> </strong> </a> <em class="hi"> :D </em></p></blockquote></div></div>    
</body>
</html>