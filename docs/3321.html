<html>
<head>
<title>Implicit conversion and parameters in Scala</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Scala中的隐式转换和参数</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/implicit-conversion-and-parameters-in-scala-ab1c4b3b6615?source=collection_archive---------7-----------------------#2021-06-06">https://medium.com/nerd-for-tech/implicit-conversion-and-parameters-in-scala-ab1c4b3b6615?source=collection_archive---------7-----------------------#2021-06-06</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="83d1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">隐式定义是指如果有任何类型错误，编译器可以插入到程序中的定义。换句话说，这是避免代码中某种错误并继续程序执行的最终方法。考虑例子<em class="jd"> a+b </em>如果<em class="jd"> a </em>和<em class="jd"> b </em>不兼容会发生什么，当然编译器会抛出错误。但是，如果编译器尝试是否有任何方法可以将<em class="jd"> a </em>转换为类型，从而不会出现任何类型不匹配，例如<em class="jd">将a+b转换为convert(a) + b </em>，这将非常好。</p><p id="241b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这正是隐式所做的，它检查是否有任何方法来转换类型，以便可以避免可能的错误。编译器遵循一组应用隐式转换的规则。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div class="er es je"><img src="../Images/af29c1ded95445ea376fc2d7923cd6dc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/format:webp/1*RNEkQAovxdrxL31PCPXJtQ.png"/></div></figure><p id="f044" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">隐式转换规则</strong></p><ul class=""><li id="2f96" class="jm jn hi ih b ii ij im in iq jo iu jp iy jq jc jr js jt ju bi translated"><strong class="ih hj">只有标记为隐式的定义才可用</strong></li></ul><p id="1a1e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在上面的例子中，为了应用convert(a)方法，必须有这样一个用关键字implicit定义的方法。</p><pre class="jf jg jh ji fd jv jw jx jy aw jz bi"><span id="13ba" class="ka kb hi jw b fi kc kd l ke kf"><strong class="jw hj">implicit</strong> <strong class="jw hj">def</strong> intToString(x<strong class="jw hj">:</strong> <strong class="jw hj">Int</strong>) <strong class="jw hj">=</strong> x.toString</span></pre><p id="5d99" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果在代码的给定上下文中有被标记为隐式的方法，编译器会自动地选择它，然后执行转换。</p><ul class=""><li id="79c8" class="jm jn hi ih b ii ij im in iq jo iu jp iy jq jc jr js jt ju bi translated"><strong class="ih hj">给定的隐式必须在给定的范围内</strong></li></ul><p id="47b2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Scala编译器只会考虑给定范围内的隐式转换，在上面的例子中要应用convert方法你必须把它带入程序范围。为了使用库中的隐式方法，我们必须首先显式导入它。例如</p><pre class="jf jg jh ji fd jv jw jx jy aw jz bi"><span id="519c" class="ka kb hi jw b fi kc kd l ke kf"><strong class="jw hj">import</strong> <strong class="jw hj">scala.preamble._</strong></span></pre><p id="7cf7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">导入包<em class="jd"> scala.preamble </em>后，我们可以使用包内定义的所有隐式。在某种程度上，我们将定义的隐含性引入到当前的执行环境中。</p><ul class=""><li id="a8e5" class="jm jn hi ih b ii ij im in iq jo iu jp iy jq jc jr js jt ju bi translated"><strong class="ih hj">一次一个</strong></li></ul><p id="4e31" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果编译器试图解决一个隐式问题，就不可能将另一个隐式问题带入执行环境。</p><p id="dd89" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="jd">convert 1(convert 2(x))+y</em></p><p id="0d51" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这样的隐式转换是不可能的，因为<em class="jd"> conver2(x) </em>正在进行中。</p><ul class=""><li id="955c" class="jm jn hi ih b ii ij im in iq jo iu jp iy jq jc jr js jt ju bi translated"><strong class="ih hj">每当代码在编写时进行类型检查，都不会尝试隐含</strong></li></ul><p id="9439" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果代码已经运行良好，编译器将不会试图改变它，这条规则也可以采用，因为我们总是可以用显式代码隐藏隐式代码。</p><p id="48d6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在程序中有三种使用隐式的方法，它们是<em class="jd">到预期类型的转换，选择和隐式参数接收者的转换</em>现在让我们逐一检查每一种方法。</p><p id="de4b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> 1-转换为预期类型</strong></p><p id="3a10" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果编译器发现类型X，但需要将其转换为类型Y，那么编译器将检查任何隐式函数，如果没有这样的函数，它将抛出一个错误。</p><pre class="jf jg jh ji fd jv jw jx jy aw jz bi"><span id="2077" class="ka kb hi jw b fi kc kd l ke kf">scala&gt; <strong class="jw hj">val</strong> k<strong class="jw hj">:Int</strong> = <strong class="jw hj">3.6</strong><br/>&lt;console&gt;:11: error: type mismatch;<br/> found   : Double(3.6)<br/> required: Int<br/>       val k:Int = 3.6</span></pre><p id="2f61" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">解法</strong>:定义一个隐函数将double转换为Int。</p><pre class="jf jg jh ji fd jv jw jx jy aw jz bi"><span id="ef50" class="ka kb hi jw b fi kc kd l ke kf">scala&gt; <strong class="jw hj">implicit</strong> <strong class="jw hj">def</strong> doubleToInt(x<strong class="jw hj">:</strong> <strong class="jw hj">Double</strong>) <strong class="jw hj">=</strong> x.toInt<br/>warning: there was one feature warning; re-run with -feature for details<br/>doubleToInt: (x: Double)Int</span><span id="eed6" class="ka kb hi jw b fi kg kd l ke kf">scala&gt; <strong class="jw hj">val</strong> k<strong class="jw hj">:Int</strong> = <strong class="jw hj">3.6</strong><br/>k: Int = 3</span></pre><p id="71aa" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在上面的例子中，我们可以看到double类型自动转换成整数。这是因为在相同的上下文中有一个隐式函数<em class="jd"> doubleToInt </em>。所以当我们把一个double类型赋给一个整数时</p><p id="bc88" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="jd">应用doubleToInt(3.6)，得到值3。</em></p><p id="610b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> 2-转换接收器</strong></p><p id="e6e3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">隐式类型转换可以应用于方法调用的接收者。</p><p id="a9a5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">模拟新语法</strong></p><pre class="jf jg jh ji fd jv jw jx jy aw jz bi"><span id="5d0f" class="ka kb hi jw b fi kc kd l ke kf"><strong class="jw hj">Map</strong>(<strong class="jw hj">1</strong> -&gt; "one", <strong class="jw hj">2</strong> -&gt; "two", <strong class="jw hj">3</strong> -&gt; "three")</span></pre><p id="79f9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在上面给出的例子中，你是否想过如何支持操作符<em class="jd"> - &gt; </em>！！！- &gt;不是运算符，而是在ArrowAssoc类中定义的函数。</p><pre class="jf jg jh ji fd jv jw jx jy aw jz bi"><span id="1d99" class="ka kb hi jw b fi kc kd l ke kf"><strong class="jw hj">package</strong> <strong class="jw hj">scala</strong><br/><strong class="jw hj">object</strong> <strong class="jw hj">Predef</strong> {<br/><strong class="jw hj">class</strong> <strong class="jw hj">ArrowAssoc</strong>[<strong class="jw hj">A</strong>](x<strong class="jw hj">:</strong> <strong class="jw hj">A</strong>) {<br/><strong class="jw hj">def</strong> -&gt; [<strong class="jw hj">B</strong>](y<strong class="jw hj">:</strong> <strong class="jw hj">B</strong>)<strong class="jw hj">:</strong> <strong class="jw hj">Tuple2</strong>[<strong class="jw hj">A</strong>, <strong class="jw hj">B</strong>] <strong class="jw hj">=</strong> <strong class="jw hj">Tuple2</strong>(x, y)<br/>}<br/><strong class="jw hj">implicit</strong> <strong class="jw hj">def</strong> any2ArrowAssoc[<strong class="jw hj">A</strong>](x<strong class="jw hj">:</strong> <strong class="jw hj">A</strong>)<strong class="jw hj">:</strong> <strong class="jw hj">ArrowAssoc</strong>[<strong class="jw hj">A</strong>] <strong class="jw hj">=</strong><br/><strong class="jw hj">new</strong> <strong class="jw hj">ArrowAssoc</strong>(x)<br/>...<br/>}</span></pre><p id="2225" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">当你写1 -&gt; "One "编译器会自动把1转换成ArrowAssoc，这样就可以找到-&gt;方法并使用它。</p><p id="9114" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">隐式类</strong></p><p id="1755" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">隐式类就是用implicit关键字声明的类。</p><pre class="jf jg jh ji fd jv jw jx jy aw jz bi"><span id="2731" class="ka kb hi jw b fi kc kd l ke kf">scala&gt; <strong class="jw hj">case</strong> <strong class="jw hj">class</strong> <strong class="jw hj">Rectangle</strong>(width<strong class="jw hj">:</strong> <strong class="jw hj">Int</strong>, height<strong class="jw hj">:</strong> <strong class="jw hj">Int</strong>)<br/>defined class Rectangle</span><span id="9ad1" class="ka kb hi jw b fi kg kd l ke kf">scala&gt; <strong class="jw hj">implicit</strong> <strong class="jw hj">class</strong> <strong class="jw hj">RectangleMaker</strong>(width<strong class="jw hj">:</strong> <strong class="jw hj">Int</strong>) {<br/>     | <strong class="jw hj">def</strong> x(height<strong class="jw hj">:</strong> <strong class="jw hj">Int</strong>) <strong class="jw hj">=</strong> <strong class="jw hj">Rectangle</strong>(width, height)<br/>     |}<br/>defined class RectangleMaker</span><span id="8cb1" class="ka kb hi jw b fi kg kd l ke kf">scala&gt; <strong class="jw hj">val</strong> myRectangle <strong class="jw hj">=</strong> <strong class="jw hj">3</strong> x <strong class="jw hj">4</strong><br/>myRectangle: Rectangle = Rectangle(3,4)</span></pre><p id="b508" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">不存在像x for int这样的操作符，但是编译器会寻找到int的隐式转换，然后它会找到隐式类<em class="jd"> RectangleMaker </em>和<em class="jd"> RectangleMaker </em>中的方法x。</p><p id="73d5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> 3-隐式参数</strong></p><p id="4570" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们定义了一个PreferredPrompt类，以及一个内部带有greet方法的对象Greeter。</p><pre class="jf jg jh ji fd jv jw jx jy aw jz bi"><span id="5fac" class="ka kb hi jw b fi kc kd l ke kf">scala&gt; <strong class="jw hj">class</strong> <strong class="jw hj">PreferredPrompt</strong>(<strong class="jw hj">val</strong> preference<strong class="jw hj">:</strong> <strong class="jw hj">String</strong>)<br/>defined class PreferredPrompt</span><span id="74ce" class="ka kb hi jw b fi kg kd l ke kf">scala&gt; <strong class="jw hj">object</strong> <strong class="jw hj">Greeter</strong> {<br/>     | <strong class="jw hj">def</strong> greet(name<strong class="jw hj">:</strong> <strong class="jw hj">String</strong>)(<strong class="jw hj">implicit</strong> prompt<strong class="jw hj">:</strong> <strong class="jw hj">PreferredPrompt</strong>) <strong class="jw hj">=</strong> {<br/>     | println("Welcome, " + name + ". The system is ready.")<br/>     | println(prompt.preference)<br/>     | }<br/>     | }<br/>defined object Greeter</span></pre><p id="45c5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在我们可以显式地提供提示值，如下所示</p><pre class="jf jg jh ji fd jv jw jx jy aw jz bi"><span id="ed87" class="ka kb hi jw b fi kc kd l ke kf">scala&gt; <strong class="jw hj">val</strong> bobsPrompt <strong class="jw hj">=</strong> <strong class="jw hj">new</strong> <strong class="jw hj">PreferredPrompt</strong>("relax&gt; ")<br/>bobsPrompt: PreferredPrompt = PreferredPrompt@1218e12</span><span id="331a" class="ka kb hi jw b fi kg kd l ke kf">scala&gt; <strong class="jw hj">Greeter</strong>.greet("Bob")(bobsPrompt)<br/>Welcome, Bob. The system is ready.<br/>relax&gt;</span></pre><p id="ec40" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果我们需要编译器隐式地为<em class="jd"> PreferredPrompt </em>提供值，我们必须定义一个PreferredPrompt类型的预期类型变量，如下所示。</p><pre class="jf jg jh ji fd jv jw jx jy aw jz bi"><span id="f087" class="ka kb hi jw b fi kc kd l ke kf"><strong class="jw hj">object</strong> <strong class="jw hj">JoesPrefs</strong> {<br/><strong class="jw hj">implicit</strong> <strong class="jw hj">val</strong> prompt <strong class="jw hj">=</strong> <strong class="jw hj">new</strong> <strong class="jw hj">PreferredPrompt</strong>("Yes, master&gt; ")<br/>}</span></pre><p id="ecfc" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">然后导入到<em class="jd"> JoesPrefs </em>把它带进执行的上下文中。编译器将在当前执行的上下文中寻找一个隐式值，如果找到，编译器将使用它，否则将抛出一个错误。</p><pre class="jf jg jh ji fd jv jw jx jy aw jz bi"><span id="1423" class="ka kb hi jw b fi kc kd l ke kf">scala&gt; <strong class="jw hj">import</strong> <strong class="jw hj">JoesPrefs._</strong><br/>import JoesPrefs._</span><span id="7ab7" class="ka kb hi jw b fi kg kd l ke kf">scala&gt; <strong class="jw hj">Greeter</strong>.greet("Joe")<br/>Welcome, Joe. The system is ready.<br/>Yes, master&gt;</span></pre><p id="4567" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">调试暗示</strong></p><p id="93a4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">隐式是scala中非常强大的特性，但有时很难做到正确。现在让我们看一些关于调试隐含错误的技巧。</p><pre class="jf jg jh ji fd jv jw jx jy aw jz bi"><span id="a3fd" class="ka kb hi jw b fi kc kd l ke kf">scala&gt; <strong class="jw hj">val</strong> chars<strong class="jw hj">:</strong> <strong class="jw hj">List</strong>[<strong class="jw hj">Char</strong>] <strong class="jw hj">=</strong> "xyz"<br/>&lt;console&gt;:17: error: type mismatch;<br/> found   : String("xyz")<br/> required: List[Char]<br/>       val chars: List[Char] = "xyz"</span></pre><p id="65c2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在，为了调试错误，让我们显式地提供wrapString。</p><pre class="jf jg jh ji fd jv jw jx jy aw jz bi"><span id="cef7" class="ka kb hi jw b fi kc kd l ke kf">scala&gt; <strong class="jw hj">val</strong> chars<strong class="jw hj">:List</strong>[<strong class="jw hj">Char</strong>] <strong class="jw hj">= </strong>wrapString("xyz")<br/>&lt;console&gt;:17: error: type mismatch;<br/> found   : scala.collection.immutable.WrappedString<br/> required: List[Char]<br/>       val chars:List[Char] =wrapString("xyz")</span></pre><p id="b7e5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在我们得到了一个错误，wrapString 的返回类型与chars 的类型不匹配。如果我们在隐式应用函数后没有得到任何错误，那么我们可以推断发生了违反作用域规则的情况(作用域内不存在隐式方法)。</p></div></div>    
</body>
</html>