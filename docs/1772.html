<html>
<head>
<title>Javascript Memory Management - Why should we care about memory?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Javascript 内存管理——我们为什么要关心内存？</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/javascript-memory-management-why-should-we-care-about-memory-795e29054ed4?source=collection_archive---------15-----------------------#2021-04-05">https://medium.com/nerd-for-tech/javascript-memory-management-why-should-we-care-about-memory-795e29054ed4?source=collection_archive---------15-----------------------#2021-04-05</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/3713e1263ebe7f981f54073e6a44f108.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*XyRTt9m1w7vxOt2S"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">照片由<a class="ae iu" href="https://unsplash.com/@jordanharrison?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">乔丹·哈里森</a>在<a class="ae iu" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="7f79" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">作为一名 Javascript 开发人员，我们通常专注于编写越来越多的代码，并尽快完成。但是在更快地写代码的过程中，有时我们会让程序比我们预期的要慢。其中一个原因是我们在写代码的时候并不关心内存。我们中的许多人在高端设备上运行程序，这些设备拥有最新的 GPU、CPU 和像超级计算机一样的计算能力。所以我们实际上并没有发现我们的程序变慢了。但最终用户的情况并非如此。我们的用户可能在一台 10 年前的设备上运行这个程序，它不具备开发人员的计算机所拥有的所有超级能力，所以他们在运行我们的网站并定期抱怨客户支持后会感到沮丧。并且在最坏的情况下，用户可能会完全停止使用该产品。</p><blockquote class="jt ju jv"><p id="f4dc" class="iv iw jw ix b iy iz ja jb jc jd je jf jx jh ji jj jy jl jm jn jz jp jq jr js hb bi translated">“不是所有的用户都有顶级设备来运行我们编写的网站或应用程序。因此，我们应该同样关注让他们的应用程序更快，并为所有用户提供几乎相同的体验。”</p></blockquote><h1 id="1af3" class="ka kb hi bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated">概观</h1><p id="2dd5" class="pw-post-body-paragraph iv iw hi ix b iy ky ja jb jc kz je jf jg la ji jj jk lb jm jn jo lc jq jr js hb bi translated">现在你可能会想，好吧，这里有很多 Jagran。现在告诉我我们怎样才能提高性能。你们中的一些人可能会想<em class="jw">“为什么我们需要考虑内存，我们在 Javascript 中有</em> <strong class="ix hj"> <em class="jw">垃圾收集器</em></strong><em class="jw"/><strong class="ix hj"><em class="jw">(GC)</em></strong><em class="jw">。”但是这正是我们犯下大错的地方。</em></p><p id="9cc8" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">即使 Javascript 有一个垃圾收集器来处理不再需要的内存。不过，我们应该知道内存管理和垃圾收集器是如何工作的，这样我们就可以避免编写内存泄漏的程序，并且可以清理不再需要的变量。</p><h1 id="d585" class="ka kb hi bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated">内存生命周期</h1><p id="f050" class="pw-post-body-paragraph iv iw hi ix b iy ky ja jb jc kz je jf jg la ji jj jk lb jm jn jo lc jq jr js hb bi translated">在所有的编程语言中都有一个内存生命周期，从内存被分配到被释放。</p><ul class=""><li id="b6b7" class="ld le hi ix b iy iz jc jd jg lf jk lg jo lh js li lj lk ll bi translated">内存分配</li><li id="c6cc" class="ld le hi ix b iy lm jc ln jg lo jk lp jo lq js li lj lk ll bi translated">内存的使用</li><li id="58e7" class="ld le hi ix b iy lm jc ln jg lo jk lp jo lq js li lj lk ll bi translated">内存释放</li></ul><h2 id="ff5c" class="lr kb hi bd kc ls lt lu kg lv lw lx kk jg ly lz ko jk ma mb ks jo mc md kw me bi translated">内存分配:</h2><p id="bdb0" class="pw-post-body-paragraph iv iw hi ix b iy ky ja jb jc kz je jf jg la ji jj jk lb jm jn jo lc jq jr js hb bi translated">需要时，操作系统会为程序分配内存。在像<strong class="ix hj"> C </strong>这样的低级语言中，程序员必须明确地告诉操作系统使用<code class="du mf mg mh mi b">malloc</code>或<code class="du mf mg mh mi b">calloc</code>来分配内存。但是在 Javascript 这样的高级语言中，分配是由语言本身负责的。</p><h2 id="e016" class="lr kb hi bd kc ls lt lu kg lv lw lx kk jg ly lz ko jk ma mb ks jo mc md kw me bi translated">* Javascript 中的内存分配</h2><pre class="mj mk ml mm fd mn mi mo mp aw mq bi"><span id="befe" class="lr kb hi mi b fi mr ms l mt mu">var n = 123; // allocates memory for a number<br/>var s = 'azerty'; // allocates memory for a string<br/><br/>var o = {<br/>  a: 1,<br/>  b: null<br/>}; // allocates memory for an object and contained values<br/><br/>// (like object) allocates memory for the array and<br/>// contained values<br/>var a = [1, null, 'abra'];<br/><br/>function f(a) {<br/>  return a + 2;<br/>} // allocates a function (which is a callable object)<br/><br/>// function expressions also allocate an object<br/>someElement.addEventListener('click', function() {<br/>  someElement.style.backgroundColor = 'blue';<br/>}, false);</span></pre><p id="f005" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在 javascript 中，函数调用也可以像</p><p id="a769" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><code class="du mf mg mh mi b">var d = new Date(); // allocates a Date object<br/>var e = document.createElement('button'); // allocates a DOM element</code></p><p id="a63e" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">一些方法也可以分配新的值或对象，比如</p><pre class="mj mk ml mm fd mn mi mo mp aw mq bi"><span id="e60f" class="lr kb hi mi b fi mr ms l mt mu">var s = 'azerty';<br/>var s2 = s.substr(0, 3); // s2 is a new string<br/>// Since strings are immutable values,<br/>// JavaScript may decide to not allocate memory,<br/>// but just store the [0, 3] range.</span><span id="37be" class="lr kb hi mi b fi mv ms l mt mu">var a = ['ouais ouais', 'nan nan'];<br/>var a2 = ['generation', 'nan nan'];<br/>var a3 = a.concat(a2);<br/>// new array with 4 elements being<br/>// the concatenation of a and a2 elements.</span></pre><h1 id="ca6d" class="ka kb hi bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated">内存的使用:</h1><p id="79fa" class="pw-post-body-paragraph iv iw hi ix b iy ky ja jb jc kz je jf jg la ji jj jk lb jm jn jo lc jq jr js hb bi translated">基本上，当我们读取或写入内存中分配的值时，就会用到内存。</p><h1 id="1b16" class="ka kb hi bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated">内存释放:</h1><p id="025c" class="pw-post-body-paragraph iv iw hi ix b iy ky ja jb jc kz je jf jg la ji jj jk lb jm jn jo lc jq jr js hb bi translated">大多数与内存管理相关的工作都发生在这个阶段。因为在这个阶段，我们需要决定是否需要清理一些内存。用低级语言来说，释放空间是开发人员的职责。但是在 JS 和 Java 这样的高级语言中，这是由垃圾收集器来完成的。垃圾收集器的主要任务是始终监控内存，并决定是否可以清理一些内存。</p><p id="70d1" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">垃圾收集器保留每个变量的引用，并检查该变量是否可达。如果这个变量可以从根节点到达，那么它会留在内存中，否则 GC 会释放内存。</p><h2 id="1206" class="lr kb hi bd kc ls lt lu kg lv lw lx kk jg ly lz ko jk ma mb ks jo mc md kw me bi translated">引用计数垃圾收集</h2><p id="6ad6" class="pw-post-body-paragraph iv iw hi ix b iy ky ja jb jc kz je jf jg la ji jj jk lb jm jn jo lc jq jr js hb bi translated">这是最简单的垃圾收集算法。在这个算法中，检查如果一个对象被任何其他对象引用，那么它将留在内存中。如果一个对象没有被任何其他对象引用，那么它就被认为是“垃圾”并从内存中删除。这种方法的问题是，如果有一个循环引用，那么如果对象不能从根访问，但仍然从子对象引用，那么它就不会被垃圾收集器收集。<em class="jw">循环引用是内存泄漏的常见原因。</em></p><pre class="mj mk ml mm fd mn mi mo mp aw mq bi"><span id="7d3c" class="lr kb hi mi b fi mr ms l mt mu">var x = {<br/>  a: {<br/>    b: 2<br/>  }<br/>};<br/>// 2 objects are created. One is referenced by the other as one of its properties.<br/>// The other is referenced by virtue of being assigned to the 'x' variable.<br/>// Obviously, none can be garbage-collected.<br/><br/>var y = x;      // The 'y' variable is the second thing that has a reference to the object.<br/><br/>x = 1;          // Now, the object that was originally in 'x' has a unique reference<br/>                //   embodied by the 'y' variable.<br/><br/>var z = y.a;    // Reference to 'a' property of the object.<br/>                //   This object now has 2 references: one as a property,<br/>                //   the other as the 'z' variable.<br/><br/>y = 'mozilla';  // The object that was originally in 'x' has now zero<br/>                //   references to it. It can be garbage-collected.<br/>                //   However its 'a' property is still referenced by<br/>                //   the 'z' variable, so it cannot be freed.<br/><br/>z = null;       // The 'a' property of the object originally in x<br/>                //   has zero references to it. It can be garbage collected.</span></pre><h2 id="0716" class="lr kb hi bd kc ls lt lu kg lv lw lx kk jg ly lz ko jk ma mb ks jo mc md kw me bi translated">标记和扫描算法</h2><p id="438d" class="pw-post-body-paragraph iv iw hi ix b iy ky ja jb jc kz je jf jg la ji jj jk lb jm jn jo lc jq jr js hb bi translated">因为上述算法存在局限性。大多数现代浏览器不使用它。垃圾收集最常用的算法是“标记和清除算法”。</p><p id="e9d5" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">标记和清扫算法假设从根可到达的所有对象都是有效对象，而其他对象可以被销毁。在 javascript 中，全局对象被认为是根对象。因此，所有可以从全局对象访问的对象都留在内存中，而其他对象则被释放。</p><p id="3d30" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">标记</strong>:该算法的第一步是标记从根<em class="jw">可达的所有子节点，即</em>全局对象。</p><p id="fc3d" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">清除:</strong>下一步是从内存中清除所有没有标记<em class="jw">的对象。</em></p><p id="95a8" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><em class="jw">* * JavaScript 内存管理最常见的限制是，开发人员不能手动触发垃圾收集器，如果他们想要的话</em>。<em class="jw"> ** </em></p><h1 id="d2e9" class="ka kb hi bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated">常见的内存泄漏</h1><p id="bfaa" class="pw-post-body-paragraph iv iw hi ix b iy ky ja jb jc kz je jf jg la ji jj jk lb jm jn jo lc jq jr js hb bi translated">由于编码选择不当，会出现常见的内存泄漏，其中一些如下:</p><p id="8096" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">未声明的全局变量:</strong>如果您是 javascript 新手，并且了解到即使您不声明变量，JS 也会为您完成工作，那么这种情况通常会发生。你陷入了一个陷阱，假设你在一个函数中使用了一些临时变量，但是你没有在函数内部声明它，以为 JS 会为你声明这个变量。当你调用函数时，当函数超出作用域时，与函数相关的所有东西都会被垃圾收集器收集，除了你没有在里面声明的变量。这个问题的原因是，当我们没有声明一个变量时，Javascript 会在全局范围内创建这个变量，并且这个变量总是可以被全局对象访问的。</p><blockquote class="jt ju jv"><p id="f654" class="iv iw jw ix b iy iz ja jb jc jd je jf jx jh ji jj jy jl jm jn jz jp jq jr js hb bi translated"><em class="hi">所以请总是在你想使用的范围内声明变量。尝试使用较少数量的全局变量，并在不再需要时手动将其赋值为 null】。</em></p></blockquote><p id="7838" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">闭包:</strong>如果在外层函数中声明了一个变量，这个变量会自动为嵌套的内层函数所用，并继续驻留在内存中，即使这个变量没有在嵌套函数中被使用/引用，那么在闭包中就会发生内存泄漏。</p><p id="81f5" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">Detached DOM/Out of DOM reference:</strong>假设你在一个对象中引用了一个 DOM 元素。在从浏览器中销毁 dom 元素之后。因为您已经访问并存储了 dom 元素，所以即使从浏览器中删除了 dom，它也会保留在内存中。</p><p id="f32c" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">缓存:</strong>重复使用的大型表格、数组、列表中的对象都存储在缓存中。规模无限增长的缓存会导致高内存消耗，因为它们不能被垃圾收集。为了避免这种情况，请确保为其大小指定一个上限。</p><h1 id="79c2" class="ka kb hi bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated"><strong class="ak">结论</strong></h1><ul class=""><li id="d40e" class="ld le hi ix b iy ky jc kz jg mw jk mx jo my js li lj lk ll bi translated">变量有三个生命周期。分配、使用、释放</li><li id="c376" class="ld le hi ix b iy lm jc ln jg lo jk lp jo lq js li lj lk ll bi translated">垃圾收集是自动执行的。我们不能强迫或阻止它。</li><li id="30f2" class="ld le hi ix b iy lm jc ln jg lo jk lp jo lq js li lj lk ll bi translated">对象在可访问时保留在内存中。</li><li id="13d4" class="ld le hi ix b iy lm jc ln jg lo jk lp jo lq js li lj lk ll bi translated">如果我们适当注意内存管理，我们可以避免大部分的内存泄漏。T15】</li></ul><p id="278d" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">希望你会发现一些新的信息，并喜欢这篇文章。如果你喜欢，请鼓掌支持。</p><p id="cc32" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">参考文献:</strong></p><ul class=""><li id="9e6b" class="ld le hi ix b iy iz jc jd jg lf jk lg jo lh js li lj lk ll bi translated"><a class="ae iu" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Memory_Management" rel="noopener ugc nofollow" target="_blank">https://developer . Mozilla . org/en-US/docs/Web/JavaScript/Memory _ Management</a></li></ul></div></div>    
</body>
</html>