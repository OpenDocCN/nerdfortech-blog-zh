<html>
<head>
<title>Splitting Symfony project into chunks</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">将Symfony项目分割成块</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/splitting-symfony-project-into-chunks-c297b5a55dab?source=collection_archive---------1-----------------------#2021-12-19">https://medium.com/nerd-for-tech/splitting-symfony-project-into-chunks-c297b5a55dab?source=collection_archive---------1-----------------------#2021-12-19</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div class="er es if"><img src="../Images/7e09e4b21567d5294e599388de3fc9b3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*ejDJd2rZvDjZ1bNy"/></div></figure><h1 id="9170" class="im in hi bd io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj bi translated">你为什么要离开？</h1><p id="d72e" class="pw-post-body-paragraph jk jl hi jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh hb bi translated">我一直(现在仍然)经常在两个国家之间旅行。我的主要台式电脑(更强大的钻机)留在一个国家，而我总是带着我的笔记本电脑时，访问第二个国家。</p><p id="d414" class="pw-post-body-paragraph jk jl hi jm b jn ki jp jq jr kj jt ju jv kk jx jy jz kl kb kc kd km kf kg kh hb bi translated">现在问题出现了:</p><ul class=""><li id="f3d2" class="kn ko hi jm b jn ki jr kj jv kp jz kq kd kr kh ks kt ku kv bi translated">我的笔记本电脑已经用了7年，已经过时了，</li><li id="f383" class="kn ko hi jm b jn kw jr kx jv ky jz kz kd la kh ks kt ku kv bi translated">我的台式机也有点旧，但功能更强大，</li></ul><p id="3894" class="pw-post-body-paragraph jk jl hi jm b jn ki jp jq jr kj jt ju jv kk jx jy jz kl kb kc kd km kf kg kh hb bi translated">虽然我可以运行<strong class="jm hj"> Symfony </strong>服务器、<strong class="jm hj"> Websocket </strong>服务器、<strong class="jm hj">调试工具</strong>和<strong class="jm hj"> Vue.js </strong> dev工具(持续运行编译和代码分析)，但它只是在笔记本电脑上窒息，简直是在呼救。</p></div><div class="ab cl lb lc gp ld" role="separator"><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg"/></div><div class="hb hc hd he hf"><h1 id="5f5b" class="im in hi bd io ip li ir is it lj iv iw ix lk iz ja jb ll jd je jf lm jh ji jj bi translated">(过度)分块</h1><p id="65dc" class="pw-post-body-paragraph jk jl hi jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh hb bi translated">Chunking bigger <strong class="jm hj"> Symfony </strong>项目其实很容易。每当你需要给项目添加一些额外的逻辑时，请这样想:</p></div><div class="ab cl lb lc gp ld" role="separator"><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg"/></div><div class="hb hc hd he hf"><blockquote class="ln"><p id="1f4f" class="lo lp hi bd lq lr ls lt lu lv lw kh dx translated"><em class="lx">“这个逻辑可以是独立代码吗？我最终能重用它吗？拆分可能太小，还是它是当前工作空间不可分割的一部分？</em></p></blockquote></div><div class="ab cl lb lc gp ld" role="separator"><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg"/></div><div class="hb hc hd he hf"><p id="1d19" class="pw-post-body-paragraph jk jl hi jm b jn ki jp jq jr kj jt ju jv kk jx jy jz kl kb kc kd km kf kg kh hb bi translated">你不希望你的代码被分割得太多。起初这可能很诱人，但是创建一个小的包来提供包装其他composer包逻辑的服务是没有意义的。遵循这种方式甚至可能导致这样的问题，最终您可能会在自己的存储库中找到大量的包(因为您肯定希望将它们存储在某个地方)。</p><p id="075f" class="pw-post-body-paragraph jk jl hi jm b jn ki jp jq jr kj jt ju jv kk jx jy jz kl kb kc kd km kf kg kh hb bi translated">考虑一个购物平台的例子:</p><ul class=""><li id="92fc" class="kn ko hi jm b jn ki jr kj jv kp jz kq kd kr kh ks kt ku kv bi translated">具有用户登录/帐户/购物逻辑的核心本身应该仍然是项目的核心，</li><li id="a980" class="kn ko hi jm b jn kw jr kx jv ky jz kz kd la kh ks kt ku kv bi translated">产品提供逻辑(让它与外部服务集成)可以是<em class="ly">“产品-提供者-捆绑包】、</em></li><li id="d29f" class="kn ko hi jm b jn kw jr kx jv ky jz kz kd la kh ks kt ku kv bi translated"><em class="ly">“意见-收集器-捆绑包”</em>可以是负责从某些页面获取数据的其他包，</li></ul><p id="df9c" class="pw-post-body-paragraph jk jl hi jm b jn ki jp jq jr kj jt ju jv kk jx jy jz kl kb kc kd km kf kg kh hb bi translated">你可以把它想成<strong class="jm hj">桥/连接器</strong>逻辑，虽然听起来一样，但这里的实现有一点点不同。</p><p id="9012" class="pw-post-body-paragraph jk jl hi jm b jn ki jp jq jr kj jt ju jv kk jx jy jz kl kb kc kd km kf kg kh hb bi translated">没有我们需要<strong class="jm hj">连接</strong>或<strong class="jm hj">桥接</strong>的项目。</p></div><div class="ab cl lb lc gp ld" role="separator"><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg"/></div><div class="hb hc hd he hf"><h1 id="7d7b" class="im in hi bd io ip li ir is it lj iv iw ix lk iz ja jb ll jd je jf lm jh ji jj bi translated">如何</h1><p id="2cdc" class="pw-post-body-paragraph jk jl hi jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh hb bi lz translated"><span class="l ma mb mc bm md me mf mg mh di"> W </span> <strong class="jm hj"> <em class="ly">大块是什么帽子？</em> </strong> <em class="ly"> </em>在这种情况下<strong class="jm hj">块</strong>只是另一个<strong class="jm hj"> <em class="ly">【独立Symfony项目】</em> </strong>，带有一些额外的配置，允许将<strong class="jm hj">插件</strong>捆绑到主项目。</p><p id="7c70" class="pw-post-body-paragraph jk jl hi jm b jn ki jp jq jr kj jt ju jv kk jx jy jz kl kb kc kd km kf kg kh hb bi translated">要使chunk完全工作，需要将其配置为一个<strong class="jm hj">包</strong>，为此，您只需要将两个文件放在正确的目录中，如下图所示:</p><figure class="mj mk ml mm fd ij er es paragraph-image"><div role="button" tabindex="0" class="mn mo di mp bf mq"><div class="er es mi"><img src="../Images/c3b4ae1793b048a078bdeb37612ac0e2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qcs4xprXRzk1kXDYAUCh5Q.png"/></div></div><figcaption class="mr ms et er es mt mu bd b be z dx translated">捆绑文件(<strong class="bd io"> LinguaBundle </strong> ) &amp;扩展文件(<strong class="bd io"><em class="lx">lingua Extension</em></strong>)</figcaption></figure><figure class="mj mk ml mm fd ij"><div class="bz dy l di"><div class="mv mw l"/></div><figcaption class="mr ms et er es mt mu bd b be z dx translated"><strong class="ak">语言捆绑</strong></figcaption></figure><figure class="mj mk ml mm fd ij"><div class="bz dy l di"><div class="mv mw l"/></div><figcaption class="mr ms et er es mt mu bd b be z dx translated"><strong class="ak"><em class="lx">lingua extension</em></strong><em class="lx">(我在我所有的其他包中都使用这个代码片段)</em></figcaption></figure><p id="a2b1" class="pw-post-body-paragraph jk jl hi jm b jn ki jp jq jr kj jt ju jv kk jx jy jz kl kb kc kd km kf kg kh hb bi translated">可能还有更多的东西，但是这个最小的配置就是让这些包工作的全部。</p><ul class=""><li id="5a0c" class="kn ko hi jm b jn ki jr kj jv kp jz kq kd kr kh ks kt ku kv bi translated">完整的细节可以在这里找到:<a class="ae mx" href="https://symfony.com/doc/current/bundles/extension.html" rel="noopener ugc nofollow" target="_blank">https://symfony.com/doc/current/bundles/extension.html</a></li></ul></div><div class="ab cl lb lc gp ld" role="separator"><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg"/></div><div class="hb hc hd he hf"><p id="49cd" class="pw-post-body-paragraph jk jl hi jm b jn ki jp jq jr kj jt ju jv kk jx jy jz kl kb kc kd km kf kg kh hb bi lz translated"><span class="l ma mb mc bm md me mf mg mh di"> I </span> <strong class="jm hj"> <em class="ly">用编写器安装组块(bundle)。</em> </strong> <em class="ly"> </em>你可以像平常一样通过composer安装你的包(比如把它添加到你的私有Gitlab实例中)，或者你可以在本地安装这个包。</p><p id="c7e8" class="pw-post-body-paragraph jk jl hi jm b jn ki jp jq jr kj jt ju jv kk jx jy jz kl kb kc kd km kf kg kh hb bi translated">对于本地安装，<strong class="jm hj"> Composer </strong>实际上创建了link，因此您仍然可以使用您的bundle项目，它将在您安装软件包的项目的<code class="du my mz na nb b">vendor</code>文件夹中自动更新。</p><blockquote class="ln"><p id="e368" class="lo lp hi bd lq lr ls lt lu lv lw kh dx translated">如何在本地安装软件包？</p></blockquote><ul class=""><li id="c191" class="kn ko hi jm b jn nc jr nd jv ne jz nf kd ng kh ks kt ku kv bi translated">通过在提到的文件的根目录中提供这个部分来更新将要安装包的项目的<code class="du my mz na nb b">composer.json</code>文件:</li></ul><figure class="mj mk ml mm fd ij"><div class="bz dy l di"><div class="mv mw l"/></div></figure><ul class=""><li id="e146" class="kn ko hi jm b jn ki jr kj jv kp jz kq kd kr kh ks kt ku kv bi translated">在<strong class="jm hj">包</strong>的<code class="du my mz na nb b">composer.json</code>中设置<code class="du my mz na nb b">name</code>(这个名字将用于安装包)，例如:<code class="du my mz na nb b">"bundle": "volmarg/lingua-bundle"</code>，</li><li id="ce06" class="kn ko hi jm b jn kw jr kx jv ky jz kz kd la kh ks kt ku kv bi translated">像平常一样安装软件包，只需调用:<code class="du my mz na nb b">composer require volmarg/lingua-bundle @dev</code></li></ul></div><div class="ab cl lb lc gp ld" role="separator"><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg"/></div><div class="hb hc hd he hf"><p id="c5c5" class="pw-post-body-paragraph jk jl hi jm b jn ki jp jq jr kj jt ju jv kk jx jy jz kl kb kc kd km kf kg kh hb bi lz translated"><span class="l ma mb mc bm md me mf mg mh di">一个</span> <strong class="jm hj"> <em class="ly">激活束</em>。那实际上只是<code class="du my mz na nb b">bundles.php</code>文件中的一个附加行。按照上面的<strong class="jm hj">语言绑定</strong>示例，激活(添加)它的逻辑等于:</strong></p><figure class="mj mk ml mm fd ij er es paragraph-image"><div role="button" tabindex="0" class="mn mo di mp bf mq"><div class="er es nh"><img src="../Images/9edac6ceabc9e9182f44ec39fa3ca609.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9bxdokIddA5ZDa2Ni1V8sw.png"/></div></div><figcaption class="mr ms et er es mt mu bd b be z dx translated">bundles.php</figcaption></figure><p id="c0d7" class="pw-post-body-paragraph jk jl hi jm b jn ki jp jq jr kj jt ju jv kk jx jy jz kl kb kc kd km kf kg kh hb bi translated">现在可以在项目中调用<strong class="jm hj">控制器&amp;服务</strong>，否则<strong class="jm hj"> Symfony </strong>将抛出异常，如<em class="ly">“没有找到名为</em> <code class="du my mz na nb b"><em class="ly">&lt;ServiceName&gt;</em></code> <em class="ly">的服务”</em>。提供的示例包配置允许<strong class="jm hj"> Symfony </strong>加载额外的<code class="du my mz na nb b">services.yaml</code>文件。</p><p id="efdf" class="pw-post-body-paragraph jk jl hi jm b jn ki jp jq jr kj jt ju jv kk jx jy jz kl kb kc kd km kf kg kh hb bi lz translated"><span class="l ma mb mc bm md me mf mg mh di">I</span>T51】问题</p><p id="a7ea" class="pw-post-body-paragraph jk jl hi jm b jn ki jp jq jr kj jt ju jv kk jx jy jz kl kb kc kd km kf kg kh hb bi translated">到目前为止，我发现的唯一问题是迁移并没有像它们应该的那样工作——这意味着如果一个捆绑包包含了迁移，那么这些迁移在安装了该捆绑包的项目中就不会工作。</p><ul class=""><li id="e9e1" class="kn ko hi jm b jn ki jr kj jv kp jz kq kd kr kh ks kt ku kv bi translated">然而，这可以通过以下指南来解决:<a class="ae mx" href="https://www.goetas.com/blog/multi-namespace-migrations-with-doctrinemigrations-30/#symfony-integration" rel="noopener ugc nofollow" target="_blank">https://www . goetas . com/blog/multi-namespace-migrations-with-doctrinmigrations-30/# symfony-integration</a></li></ul><p id="3eb8" class="pw-post-body-paragraph jk jl hi jm b jn ki jp jq jr kj jt ju jv kk jx jy jz kl kb kc kd km kf kg kh hb bi translated"><strong class="jm hj">简单解释</strong></p><figure class="mj mk ml mm fd ij er es paragraph-image"><div role="button" tabindex="0" class="mn mo di mp bf mq"><div class="er es ni"><img src="../Images/76cb123dc4f0312bb50cf57412798fc1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qPCUpCk43JAe05kcRTNuxA.png"/></div></div><figcaption class="mr ms et er es mt mu bd b be z dx translated">教义_移民. yaml</figcaption></figure><p id="637e" class="pw-post-body-paragraph jk jl hi jm b jn ki jp jq jr kj jt ju jv kk jx jy jz kl kb kc kd km kf kg kh hb bi translated">还要记住，<strong class="jm hj">键</strong>必须等于bundle中迁移文件的名称空间。所以它应该变成<code class="du my mz na nb b">LinguaBundleDoctrineMigrations</code>，而不是使用默认的名称空间<code class="du my mz na nb b">DoctrineMigrations</code>。</p></div><div class="ab cl lb lc gp ld" role="separator"><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg"/></div><div class="hb hc hd he hf"><h1 id="87d8" class="im in hi bd io ip li ir is it lj iv iw ix lk iz ja jb ll jd je jf lm jh ji jj bi translated">摘要</h1><p id="89cb" class="pw-post-body-paragraph jk jl hi jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh hb bi translated">对我个人来说，最大的好处是我可以在使用旧笔记本电脑的同时处理项目中较小的部分。</p><p id="3eba" class="pw-post-body-paragraph jk jl hi jm b jn ki jp jq jr kj jt ju jv kk jx jy jz kl kb kc kd km kf kg kh hb bi translated">我还发现好的一点是，我现在实际上在另一个bundle中重用了一些bundle——我经常达到这样一个点，当我想“我想从bundle<strong class="jm hj"><em class="ly">A</em></strong><em class="ly"/>中得到那个逻辑，结果是我已经得到了那个逻辑准备好被重用。</p></div></div>    
</body>
</html>