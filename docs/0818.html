<html>
<head>
<title>Is Graph Bipartite? — Day 76(Python)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">图是二分的吗？—第76天(Python)</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/is-graph-bipartite-day-76-python-c0c3cdc9585e?source=collection_archive---------5-----------------------#2021-02-16">https://medium.com/nerd-for-tech/is-graph-bipartite-day-76-python-c0c3cdc9585e?source=collection_archive---------5-----------------------#2021-02-16</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/4b8c2f559e112461d10a0ba681502fdb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*SMf9sGjyaYMyrpeK"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">照片由<a class="ae iu" href="https://unsplash.com/@ifbdesign?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">本杰明·史密斯</a>在<a class="ae iu" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="8ab3" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">今天的问题来自leetcode的每日编码挑战。这个问题在脸书的采访中经常被问到。让我们看看问题陈述。</p></div><div class="ab cl jt ju gp jv" role="separator"><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy"/></div><div class="hb hc hd he hf"><p id="9e88" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><a class="ae iu" href="https://leetcode.com/problems/is-graph-bipartite/" rel="noopener ugc nofollow" target="_blank"><strong class="ix hj"/></a><strong class="ix hj">。图是二分的吗？</strong></p><p id="6bdc" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">有一个<strong class="ix hj">无向图</strong>有<code class="du ka kb kc kd b">n</code>个节点，每个节点在<code class="du ka kb kc kd b">0</code>和<code class="du ka kb kc kd b">n - 1</code>之间编号。给你一个2D数组<code class="du ka kb kc kd b">graph</code>，其中<code class="du ka kb kc kd b">graph[u]</code>是与节点<code class="du ka kb kc kd b">u</code>相邻的节点数组。更正式地说，对于<code class="du ka kb kc kd b">graph[u]</code>中的每个<code class="du ka kb kc kd b">v</code>，在节点<code class="du ka kb kc kd b">u</code>和节点<code class="du ka kb kc kd b">v</code>之间有一条无向边。该图形具有以下属性:</p><ul class=""><li id="d7e8" class="ke kf hi ix b iy iz jc jd jg kg jk kh jo ki js kj kk kl km bi translated">没有自边缘(<code class="du ka kb kc kd b">graph[u]</code>不包含<code class="du ka kb kc kd b">u</code>)。</li><li id="d388" class="ke kf hi ix b iy kn jc ko jg kp jk kq jo kr js kj kk kl km bi translated">没有平行边(<code class="du ka kb kc kd b">graph[u]</code>不包含重复值)。</li><li id="76c7" class="ke kf hi ix b iy kn jc ko jg kp jk kq jo kr js kj kk kl km bi translated">如果<code class="du ka kb kc kd b">v</code>在<code class="du ka kb kc kd b">graph[u]</code>中，那么<code class="du ka kb kc kd b">u</code>在<code class="du ka kb kc kd b">graph[v]</code>中(图是无向的)。</li><li id="79fa" class="ke kf hi ix b iy kn jc ko jg kp jk kq jo kr js kj kk kl km bi translated">该图可能没有连接，这意味着可能有两个节点<code class="du ka kb kc kd b">u</code>和<code class="du ka kb kc kd b">v</code>，使得它们之间没有路径。</li></ul><p id="d1f0" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如果节点可以被分成两个独立的集合<code class="du ka kb kc kd b">A</code>和<code class="du ka kb kc kd b">B</code>，使得图中的每条边<strong class="ix hj">连接集合<code class="du ka kb kc kd b">A</code>中的一个节点和集合<code class="du ka kb kc kd b">B</code>中的一个节点，则图是<strong class="ix hj">二部图</strong>。</strong></p><p id="d288" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">返回<code class="du ka kb kc kd b">true</code> <em class="ks">当且仅当它是</em> <strong class="ix hj"> <em class="ks">二部</em> </strong>。</p><p id="3ecb" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">例1: </strong></p><figure class="ku kv kw kx fd ij er es paragraph-image"><div class="er es kt"><img src="../Images/233215f4fe92f91b2701feea0eb81c9a.png" data-original-src="https://miro.medium.com/v2/resize:fit:444/format:webp/0*C3yjkmwT9k-7gon7.jpg"/></div></figure><pre class="ku kv kw kx fd ky kd kz la aw lb bi"><span id="c5af" class="lc ld hi kd b fi le lf l lg lh"><strong class="kd hj">Input:</strong> graph = [[1,2,3],[0,2],[0,1,3],[0,2]]<br/><strong class="kd hj">Output:</strong> false<br/><strong class="kd hj">Explanation:</strong> There is no way to partition the nodes into two independent sets such that every edge connects a node in one and a node in the other.</span></pre><p id="d66d" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">例2: </strong></p><figure class="ku kv kw kx fd ij er es paragraph-image"><div class="er es kt"><img src="../Images/7d62efe963cdb8862a802080e880c3db.png" data-original-src="https://miro.medium.com/v2/resize:fit:444/format:webp/0*5Jp_sEWLGNPSSMat.jpg"/></div></figure><pre class="ku kv kw kx fd ky kd kz la aw lb bi"><span id="7dcc" class="lc ld hi kd b fi le lf l lg lh"><strong class="kd hj">Input:</strong> graph = [[1,3],[0,2],[1,3],[0,2]]<br/><strong class="kd hj">Output:</strong> true<br/><strong class="kd hj">Explanation:</strong> We can partition the nodes into two sets: {0, 2} and {1, 3}.</span></pre><p id="c60e" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">约束:</strong></p><ul class=""><li id="8c53" class="ke kf hi ix b iy iz jc jd jg kg jk kh jo ki js kj kk kl km bi translated"><code class="du ka kb kc kd b">graph.length == n</code></li><li id="158b" class="ke kf hi ix b iy kn jc ko jg kp jk kq jo kr js kj kk kl km bi translated"><code class="du ka kb kc kd b">1 &lt;= n &lt;= 100</code></li><li id="82b8" class="ke kf hi ix b iy kn jc ko jg kp jk kq jo kr js kj kk kl km bi translated"><code class="du ka kb kc kd b">0 &lt;= graph[u].length &lt; n</code></li><li id="aafd" class="ke kf hi ix b iy kn jc ko jg kp jk kq jo kr js kj kk kl km bi translated"><code class="du ka kb kc kd b">0 &lt;= graph[u][i] &lt;= n - 1</code></li><li id="fb2f" class="ke kf hi ix b iy kn jc ko jg kp jk kq jo kr js kj kk kl km bi translated"><code class="du ka kb kc kd b">graph[u]</code>不包含<code class="du ka kb kc kd b">u</code>。</li><li id="a22e" class="ke kf hi ix b iy kn jc ko jg kp jk kq jo kr js kj kk kl km bi translated"><code class="du ka kb kc kd b">graph[u]</code>的所有值都是<strong class="ix hj">唯一的</strong>。</li><li id="1259" class="ke kf hi ix b iy kn jc ko jg kp jk kq jo kr js kj kk kl km bi translated">如果<code class="du ka kb kc kd b">graph[u]</code>包含<code class="du ka kb kc kd b">v</code>，那么<code class="du ka kb kc kd b">graph[v]</code>包含<code class="du ka kb kc kd b">u</code>。</li></ul></div><div class="ab cl jt ju gp jv" role="separator"><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy"/></div><div class="hb hc hd he hf"><p id="b93f" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在我们开始讨论算法之前，让我们了解一下什么是二分的。</p><blockquote class="li lj lk"><p id="4069" class="iv iw ks ix b iy iz ja jb jc jd je jf ll jh ji jj lm jl jm jn ln jp jq jr js hb bi translated">根据维基百科，</p><p id="c8f5" class="iv iw ks ix b iy iz ja jb jc jd je jf ll jh ji jj lm jl jm jn ln jp jq jr js hb bi translated">在<a class="ae iu" href="https://en.wikipedia.org/wiki/Graph_theory" rel="noopener ugc nofollow" target="_blank">图论</a>的<a class="ae iu" href="https://en.wikipedia.org/wiki/Mathematics" rel="noopener ugc nofollow" target="_blank">数学</a>领域中，一个<strong class="ix hj">二部图</strong>(或<strong class="ix hj">二部图</strong>)是一个<a class="ae iu" href="https://en.wikipedia.org/wiki/Graph_(discrete_mathematics)" rel="noopener ugc nofollow" target="_blank">图</a>，它的<a class="ae iu" href="https://en.wikipedia.org/wiki/Vertex_(graph_theory)" rel="noopener ugc nofollow" target="_blank">顶点</a>可以分成两个<a class="ae iu" href="https://en.wikipedia.org/wiki/Disjoint_sets" rel="noopener ugc nofollow" target="_blank">不相交的</a>和<a class="ae iu" href="https://en.wikipedia.org/wiki/Independent_set_(graph_theory)" rel="noopener ugc nofollow" target="_blank">独立集合</a> U和V，使得每个<a class="ae iu" href="https://en.wikipedia.org/wiki/Edge_(graph_theory)" rel="noopener ugc nofollow" target="_blank">边</a>将U中的一个顶点连接到V中的一个顶点。顶点集合U和V是等价地，二部图是不包含任何奇数长度<a class="ae iu" href="https://en.wikipedia.org/wiki/Cycle_(graph_theory)" rel="noopener ugc nofollow" target="_blank">圈</a>的图。</p></blockquote><figure class="ku kv kw kx fd ij er es paragraph-image"><div class="er es lo"><img src="../Images/3cbe0e752b8f4b1ef4f518c5bcb01fc3.png" data-original-src="https://miro.medium.com/v2/resize:fit:440/format:webp/1*3-Sn7gZXCxc-X4iHQvyxrg.png"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">偶图</figcaption></figure><p id="d8e2" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">让我们举一个例子，看看我们是否能把它转换成一个二分图。</p><p id="dcbd" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">例1。</p><figure class="ku kv kw kx fd ij er es paragraph-image"><div class="er es kt"><img src="../Images/233215f4fe92f91b2701feea0eb81c9a.png" data-original-src="https://miro.medium.com/v2/resize:fit:444/format:webp/0*C3yjkmwT9k-7gon7.jpg"/></div></figure><p id="6fa8" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">因为上面的图是一个完整的图，所以不可能把它做成二部图。</p><p id="fd43" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">例2。</p><figure class="ku kv kw kx fd ij er es paragraph-image"><div class="er es kt"><img src="../Images/7d62efe963cdb8862a802080e880c3db.png" data-original-src="https://miro.medium.com/v2/resize:fit:444/format:webp/0*5Jp_sEWLGNPSSMat.jpg"/></div></figure><figure class="ku kv kw kx fd ij er es paragraph-image"><div class="er es lp"><img src="../Images/1168e09dc26800dd4f9ba4afcff8d229.png" data-original-src="https://miro.medium.com/v2/resize:fit:984/format:webp/1*Bs8VikmuVA3Mc-65QKf-yA.png"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">偶图</figcaption></figure></div><div class="ab cl jt ju gp jv" role="separator"><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy"/></div><div class="hb hc hd he hf"><p id="85fd" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">为了解决这个问题，我们需要给每个节点分配颜色。例如，假设我们使用两种颜色，黑色和白色。我们开始的节点将被涂成白色。这些节点的邻居将被涂成黑色，然后当前节点的邻居将被涂成白色。我们将在一个循环中继续这样做，直到我们给所有的节点着色。</p><p id="d7e5" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">怎么知道能不能有二部图？</p><p id="bec7" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">当我们继续给图着色时，如果在任何一点到达一个先前着色的节点，我们需要检查该节点的当前颜色是否等于该节点的预期颜色。如果是，我们可以继续着色，否则图不是二分的。</p><p id="f6bc" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">让我们举一个例子，</p><p id="8d2a" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">示例1:</p><figure class="ku kv kw kx fd ij er es paragraph-image"><div class="er es kt"><img src="../Images/233215f4fe92f91b2701feea0eb81c9a.png" data-original-src="https://miro.medium.com/v2/resize:fit:444/format:webp/0*C3yjkmwT9k-7gon7.jpg"/></div></figure><p id="953b" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">让我们从节点0开始。我们将把它涂成黑色。</p><figure class="ku kv kw kx fd ij er es paragraph-image"><div class="er es lq"><img src="../Images/c97fecc5024742366f2caad33c0649df.png" data-original-src="https://miro.medium.com/v2/resize:fit:708/format:webp/1*t_FF1wCGXXj7S5zFiFzLmQ.png"/></div></figure><p id="adb6" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">现在，0的所有相邻节点都是白色的。在这种情况下，1、2和3是白色的。</p><figure class="ku kv kw kx fd ij er es paragraph-image"><div class="er es lr"><img src="../Images/759b38b442da7d2d1ccd649b1d1e9252.png" data-original-src="https://miro.medium.com/v2/resize:fit:712/format:webp/1*7sXS1REdmNKn8Wfis26ZxQ.png"/></div></figure><p id="f81a" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">接下来，1的邻居被涂成黑色。1的邻居是0和2。但是我们已经用白色给2着色了，这意味着有冲突。因此我们需要返回False。</p></div><div class="ab cl jt ju gp jv" role="separator"><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy"/></div><div class="hb hc hd he hf"><p id="283b" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">例2。</p><figure class="ku kv kw kx fd ij er es paragraph-image"><div class="er es kt"><img src="../Images/7d62efe963cdb8862a802080e880c3db.png" data-original-src="https://miro.medium.com/v2/resize:fit:444/format:webp/0*5Jp_sEWLGNPSSMat.jpg"/></div></figure><p id="09d3" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">让我们从节点0开始。我们将把它涂成黑色。</p><figure class="ku kv kw kx fd ij er es paragraph-image"><div class="er es ls"><img src="../Images/929638188b362e837ce448befa49220e.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*I8GdVS9xwT1ru3UH0Lrv_g.png"/></div></figure><p id="599c" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">接下来，我们将把节点0的邻居涂成白色。节点0的邻居将包括1和3。</p><figure class="ku kv kw kx fd ij er es paragraph-image"><div class="er es ls"><img src="../Images/929638188b362e837ce448befa49220e.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*I8GdVS9xwT1ru3UH0Lrv_g.png"/></div></figure><p id="fdd0" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">接下来，我们将1的邻居涂成黑色。节点1的邻居将被涂成黑色。1的邻居将包括节点2和0。</p><figure class="ku kv kw kx fd ij er es paragraph-image"><div class="er es lt"><img src="../Images/4e166eb4d393f4e00cb4267e6a7510f3.png" data-original-src="https://miro.medium.com/v2/resize:fit:744/format:webp/1*fc8MUuxB_yw7wO5NByrV4w.png"/></div></figure><p id="f945" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">接下来，我们将2的邻居涂成白色。2的邻居将包括3和1。既然我们已经给它上色了，就不需要再上色了。类似地，我们需要给节点3的邻居上色。因为它们已经被着色并且没有冲突，我们不需要再次着色它们。</p><p id="4308" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们可以使用BFS或DFS来解决这个问题。我们将使用BFS和DFS来解决这个问题。</p></div><div class="ab cl jt ju gp jv" role="separator"><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy"/></div><div class="hb hc hd he hf"><p id="3573" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">使用BFS的解决方案。</p><p id="3cf2" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">因为我们以前解决过BFS问题，所以我不会深入解释BFS算法。</p><p id="6d00" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们需要一个能够跟踪每个节点颜色的字典。需要记住的一点是，在问题陈述中提到了图形不一定是相连的。因此我们将不得不使用一个循环来遍历所有的节点。需要记住的另一点是，如果当前节点已经被访问过，那么我们需要确保这个节点的颜色是我们想要绘制的颜色，否则我们将返回False。</p><p id="90fc" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">让我们来看看代码片段。</p><pre class="ku kv kw kx fd ky kd kz la aw lb bi"><span id="00e6" class="lc ld hi kd b fi le lf l lg lh">class BipartiteChecker:<br/>    def isBipartite(self, graph: List[List[int]]) -&gt; bool:<br/>        #Dictionary<br/>        color = {}<br/>        for each_node in range(len(graph)):<br/>           #if not visited already<br/>            if each_node not in color:<br/>                neighbors = [each_node]<br/>                next_neighbors = []<br/>                curr_color = True<br/>                while neighbors:<br/>                    out = neighbors.pop(0)<br/>                    if out in color:<br/>                        #Check if current color is intended color<br/>                        if color[out] != curr_color:<br/>                            return False<br/>                    else:<br/>                        color[out] = curr_color<br/>                        for i in graph[out]:<br/>                            next_neighbors.append(i)<br/>                    if neighbors == []:<br/>                        curr_color = not curr_color<br/>                        neighbors, next_neighbors = next_neighbors,neighbors<br/>        return True</span></pre><p id="8c9c" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">复杂性分析。</strong></p><p id="5390" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">时间复杂度</strong></p><p id="a71e" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">因为每次我们访问通过边连接的节点，时间复杂度是O(N+E ),其中N是节点的数量，E是边的数量。</p><p id="043d" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">空间复杂性。</strong></p><p id="5eaf" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">因为我们使用字典来存储彩色节点，所以空间复杂度是O(N ),其中N是节点的数量。</p></div><div class="ab cl jt ju gp jv" role="separator"><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy"/></div><div class="hb hc hd he hf"><p id="7579" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">让我们看看使用DFS的代码片段。</p><pre class="ku kv kw kx fd ky kd kz la aw lb bi"><span id="1db6" class="lc ld hi kd b fi le lf l lg lh">class BipartiteChecker:<br/>    def isBipartite(self, graph: List[List[int]]) -&gt; bool:<br/>        color = {}<br/>        def dfs(curr_node, curr_color):<br/>            <br/>            if curr_node in color:<br/>                if color[curr_node] != curr_color:<br/>                    return False<br/>                else:<br/>                    return True<br/>            else:<br/>                color[curr_node] = curr_color<br/>            for each_node in graph[curr_node]:<br/>                if not dfs(each_node, not curr_color):<br/>                    return False<br/>            return True<br/>        <br/>        for all_node in range(len(graph)):<br/>            if all_node not in color:<br/>                if not dfs(all_node, True):<br/>                    return False<br/>        return True</span></pre><p id="876f" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">复杂性分析。</strong></p><p id="7e01" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">时间复杂度</strong></p><p id="af9f" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">因为每次我们访问通过边连接的节点，时间复杂度是O(N+E ),其中N是节点的数量，E是边的数量。</p><p id="f14e" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">空间复杂度。</strong></p><p id="e584" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">因为我们使用字典来存储彩色节点，所以空间复杂度是O(N ),其中N是节点的数量。</p></div></div>    
</body>
</html>