<html>
<head>
<title>Parallel and asynchronous programming with Java</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用 Java 进行并行和异步编程</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/parallel-and-asynchronous-programming-with-java-54278db2d839?source=collection_archive---------0-----------------------#2020-08-03">https://medium.com/nerd-for-tech/parallel-and-asynchronous-programming-with-java-54278db2d839?source=collection_archive---------0-----------------------#2020-08-03</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="3433" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Java 是一种很好的语言，它通过以编程方式创建轻量级进程(称为<a class="ae jd" href="https://docs.oracle.com/javase/8/docs/api/java/lang/Thread.html" rel="noopener ugc nofollow" target="_blank">线程</a>)来提供顺序、并行和异步编程。它帮助我们编写一个高效的程序来实现某些目标。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es je"><img src="../Images/d147910859fc2ec79bd1589f4fc3debd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gvzyQYxSPp4VvdUFZhu5sg.png"/></div></div></figure><p id="7597" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们先了解一下程序的这 3 种方式是什么？</p><ol class=""><li id="ff54" class="jq jr hi ih b ii ij im in iq js iu jt iy ju jc jv jw jx jy bi translated"><strong class="ih hj">顺序程序:</strong>给出了一个<strong class="ih hj"> N </strong>任务的列表，程序依次挑选出这些任务中的每一个，并执行一些动作。假设每个任务需要 1 秒钟完成，那么我们的顺序程序将需要 N 秒钟完成。</li><li id="d9dd" class="jq jr hi ih b ii jz im ka iq kb iu kc iy kd jc jv jw jx jy bi translated">并行程序:我们对顺序程序不满意，我们想提高它的性能，这里并行程序使用线程来划分任务列表，线程开始并行处理这些任务，以便在更短的时间内完成。<strong class="ih hj"> <em class="ke">这里并行程序等待每个线程完成它们的任务。</em>T11】</strong></li><li id="7383" class="jq jr hi ih b ii jz im ka iq kb iu kc iy kd jc jv jw jx jy bi translated"><strong class="ih hj">异步程序:</strong>它也像并行程序一样，利用线程在较短的时间内完成任务。但是，有一个区别，因为它不等待任务列表完成，任务是异步完成的，程序忙于做其他事情。</li></ol><p id="bd80" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Java 1 有线程来进行并行编程。这个线程类有一个方法<code class="du kf kg kh ki b">void run()</code>，它不接受任何东西，也不返回任何东西。这带来了代码的可变性。开发人员需要创建线程来划分他的任务，以获得更好的性能。几年后，<strong class="ih hj"> Java 5 </strong>提出了<a class="ae jd" href="https://docs.oracle.com/javase/7/docs/api/java/util/concurrent/ExecutorService.html" rel="noopener ugc nofollow" target="_blank"><strong class="ih hj">ExecutorService</strong></a>，它在内部管理线程池，并提供了一种编写并行程序的抽象方法。它返回<a class="ae jd" href="https://docs.oracle.com/javase/7/docs/api/java/util/concurrent/Future.html" rel="noopener ugc nofollow" target="_blank"> <strong class="ih hj">未来</strong> </a>对象。但是有一个问题，一旦我们对 future 对象应用 get 操作，future 对象就不再是 future 了，它就在那里阻塞执行。所以，我们需要一些别的东西来在 Java 中拥有一个纯粹的异步程序。我们开始吧。<strong class="ih hj"> Java 8 </strong>引入<a class="ae jd" href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/CompletableFuture.html" rel="noopener ugc nofollow" target="_blank"><strong class="ih hj">CompletableFuture</strong></a>来实现同样的事情。使用 parallelStream()和 CompletableFuture 可以实现并行和异步编程。</p><p id="83f8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这些概念基于函数式编程。如果你不知道什么是函数式编程？我会推荐参考这篇<a class="ae jd" rel="noopener" href="/@shivanshugoyal0111/the-new-aspect-of-java-with-functional-programming-d2ca6517d15e"> <strong class="ih hj">文章</strong> </a>先了解函数式编程。</p><p id="59a3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在后台，它们使用相同的线程池，数量等于<code class="du kf kg kh ki b">Runtime.getRuntime().availableProcessors()</code>。让我们了解一下 parallelStream 和 CompletableFuture 的区别:</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es kj"><img src="../Images/4488bcab9b5a08ed2941c8a84a441d1b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PO2oJGTRh72x4ys04TBG8g.png"/></div></div></figure><blockquote class="kk kl km"><p id="dd30" class="if ig ke ih b ii ij ik il im in io ip kn ir is it ko iv iw ix kp iz ja jb jc hb bi translated">确定为获得最佳性能而创建的线程数量的最佳方法。</p><p id="6cf6" class="if ig ke ih b ii ij ik il im in io ip kn ir is it ko iv iw ix kp iz ja jb jc hb bi translated">如果任务是 CPU 密集型的，那么<code class="du kf kg kh ki b"># of threads should be equal to and less than # of cores</code>。</p><p id="4c60" class="if ig ke ih b ii ij ik il im in io ip kn ir is it ko iv iw ix kp iz ja jb jc hb bi translated">如果任务是 I/O 密集型的，那么<code class="du kf kg kh ki b"># of threads should be equal to and less than (# of cores / 1 — blockingfactor) where 0 ≤ blockingfactor &lt; 1</code></p><p id="1130" class="if ig ke ih b ii ij ik il im in io ip kn ir is it ko iv iw ix kp iz ja jb jc hb bi translated">一台机器的核心数量:<code class="du kf kg kh ki b">Runtime.getRuntime().availableProcessors()</code></p><p id="1c5b" class="if ig ke ih b ii ij ik il im in io ip kn ir is it ko iv iw ix kp iz ja jb jc hb bi translated"><code class="du kf kg kh ki b">ForkJoinPool.commonPool() returns parallelism value which is # of cores -1 as one is main thread itself</code></p></blockquote><h2 id="fa01" class="kq kr hi bd ks kt ku kv kw kx ky kz la iq lb lc ld iu le lf lg iy lh li lj lk bi translated">Java 中如何使用 parallelStream？</h2><figure class="jf jg jh ji fd jj"><div class="bz dy l di"><div class="ll lm l"/></div></figure><h2 id="7531" class="kq kr hi bd ks kt ku kv kw kx ky kz la iq lb lc ld iu le lf lg iy lh li lj lk bi translated">Java 中如何使用 CompletableFuture？</h2><p id="ba9f" class="pw-post-body-paragraph if ig hi ih b ii ln ik il im lo io ip iq lp is it iu lq iw ix iy lr ja jb jc hb bi translated">completableFuture 可以有以下阶段之一:</p><ol class=""><li id="51f6" class="jq jr hi ih b ii ij im in iq js iu jt iy ju jc jv jw jx jy bi translated"><strong class="ih hj">已解决</strong>(这是最终阶段，一旦实现，以后就不能修改)</li><li id="1bba" class="jq jr hi ih b ii jz im ka iq kb iu kc iy kd jc jv jw jx jy bi translated"><strong class="ih hj">被拒绝</strong>或出错(这也是最终阶段)</li><li id="5487" class="jq jr hi ih b ii jz im ka iq kb iu kc iy kd jc jv jw jx jy bi translated"><strong class="ih hj">待定</strong>(仍在等待进入前两个阶段之一)</li></ol><p id="113c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在 CompletableFuture 上使用 get()不是一个好主意，因为它阻塞了程序的进一步执行。</p><figure class="jf jg jh ji fd jj"><div class="bz dy l di"><div class="ll lm l"/></div></figure><p id="2fd3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">thenApply()、thenAccept()、thenRun()等是在 CompletableFuture 的解析阶段执行的方法。</p><blockquote class="kk kl km"><p id="037c" class="if ig ke ih b ii ij ik il im in io ip kn ir is it ko iv iw ix kp iz ja jb jc hb bi translated"><strong class="ih hj">CompletableFuture&lt;T&gt;是不朽的。他们永远不会死。</strong></p></blockquote><figure class="jf jg jh ji fd jj"><div class="bz dy l di"><div class="ll lm l"/></div></figure><p id="d81a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在 CompletableFuture 的拒绝阶段，整个流程中的第一个 exceptive()方法被调用。<strong class="ih hj">异常有两种处理方式:</strong></p><ol class=""><li id="8423" class="jq jr hi ih b ii ij im in iq js iu jt iy ju jc jv jw jx jy bi translated">展开异常:它只停留在错误通道中。</li><li id="ca99" class="jq jr hi ih b ii jz im ka iq kb iu kc iy kd jc jv jw jx jy bi translated">记录异常并返回默认值以返回数据通道。</li></ol><figure class="jf jg jh ji fd jj"><div class="bz dy l di"><div class="ll lm l"/></div></figure><p id="6da1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">如果尚未完成，可以使用 complete() </strong>方法将<strong class="ih hj"> get() </strong>和相关方法返回的值设置为给定值。当该调用导致 CompletableFuture 转换到完成状态时，它返回 true，否则返回 false。</p><p id="4aaf" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们用下面的例子来理解 complete()。</p><figure class="jf jg jh ji fd jj"><div class="bz dy l di"><div class="ll lm l"/></div></figure><p id="4397" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">未来 1 和未来 2 有什么区别？</p><p id="99db" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">通过语句<code class="du kf kg kh ki b">future1.complete(20);</code>,我们将 future1 放入已解决阶段，future1.get()值为 20。然后，我们在终端中应用打印 20 的<code class="du kf kg kh ki b">future1.thenAccept(System.out::println);</code>。</p><p id="10e9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">通过语句<code class="du kf kg kh ki b">future2.complete(20);</code>，我们将 future2 放入已解决阶段，future2.get()的值为 20。然后，我们应用<code class="du kf kg kh ki b">future2.thenApply(data -&gt; data * 2)</code>，它将 20 作为输入，并将其映射到 40，它被进一步传递给<code class="du kf kg kh ki b">thenAccept(System.out::println);</code>方法，后者将 40 打印到终端。</p><p id="200d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们还有<code class="du kf kg kh ki b"><strong class="ih hj">completeExceptionally(Throwable throwable)</strong></code>，可以在流水线出现异常的情况下使用。在下面的示例中，future 正在使用语句<code class="du kf kg kh ki b">future.completeExceptionally(new RuntimeException(“We are throwing exception”));</code>完成被拒绝的阶段，它查找第一个异常块并跳过其他已解析的阶段块，如<code class="du kf kg kh ki b">thenApply()</code> <code class="du kf kg kh ki b">Programming::<em class="ke">exceptionHandler</em></code> <em class="ke"> </em>正在处理异常并通过向管道返回 0 来从中恢复。之后，<code class="du kf kg kh ki b">thenAccept(System.<em class="ke">out</em>::println)</code>消费响应，在终端上打印 0。</p><figure class="jf jg jh ji fd jj"><div class="bz dy l di"><div class="ll lm l"/></div></figure><p id="4ae5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们谈到了<strong class="ih hj">解决</strong>和<strong class="ih hj">拒绝</strong>阶段，那么<strong class="ih hj">未决</strong>阶段呢？有一条规则说“<strong class="ih hj"> <em class="ke">没有超时</em> </strong>”我们永远不要在编码中执行某个东西。不幸的是，我们在 java 8 中没有这个超时 API，但 java 总是让我们开心，它在 java 9 中引入了<a class="ae jd" href="https://docs.oracle.com/javase/9/docs/api/java/util/concurrent/CompletableFuture.html#completeOnTimeout-T-long-java.util.concurrent.TimeUnit-" rel="noopener ugc nofollow" target="_blank"><strong class="ih hj">completeOnTimeout()API</strong></a>。让我们看看它是如何工作的？</p><figure class="jf jg jh ji fd jj"><div class="bz dy l di"><div class="ll lm l"/></div></figure><p id="6de5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这条语句<code class="du kf kg kh ki b">future.completeOnTimeout(0, 2, TimeUnit.<em class="ke">SECONDS</em>);</code>等待 2 秒完成未来。如果它没有被语句<code class="du kf kg kh ki b">future.complete(<em class="ke">compute</em>(10));</code>完成，future 将被完成到 resolved 阶段，其中<code class="du kf kg kh ki b">future.get()</code>值为 0。</p><p id="8017" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在，我们有另外两件重要的事情要在未来讨论。</p><ol class=""><li id="8eb7" class="jq jr hi ih b ii ij im in iq js iu jt iy ju jc jv jw jx jy bi translated">撰写(类似于流中的<a class="ae jd" href="https://docs.oracle.com/javase/8/docs/api/java/util/stream/Stream.html#flatMap-java.util.function.Function-" rel="noopener ugc nofollow" target="_blank">平面图</a></li><li id="ab37" class="jq jr hi ih b ii jz im ka iq kb iu kc iy kd jc jv jw jx jy bi translated">组合(流中没有相应的 API)</li></ol><p id="091e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们来试着理解一下为什么这些东西在这里都有？我举一个 javascript 的例子来揭开它的神秘面纱。</p><p id="72f4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><code class="du kf kg kh ki b">then(e -&gt; function(e)); it always returns a promise</code></p><p id="9cdb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在 Javascript 是动态类型语言，而 Java 是静态类型语言。这个<code class="du kf kg kh ki b">function(e)</code>可以返回任何东西。它可能是任何数据或<a class="ae jd" href="https://javascript.info/promise-basics" rel="noopener ugc nofollow" target="_blank">承诺</a>。如果是数据，它被包装到一个承诺中并被返回，否则它被直接返回。但是，这种隐式的东西在 Java 中是无效的，因为返回类型在 Java 中很重要。让我们看看如何用 Java 实现它。</p><blockquote class="kk kl km"><p id="0aaa" class="if ig ke ih b ii ij ik il im in io ip kn ir is it ko iv iw ix kp iz ja jb jc hb bi translated"><strong class="ih hj">在 streams 中</strong> <br/>当函数返回数据时，我们使用 map() <br/>当函数返回 stream 时，我们使用 flatMap()</p><p id="a0e8" class="if ig ke ih b ii ij ik il im in io ip kn ir is it ko iv iw ix kp iz ja jb jc hb bi translated"><strong class="ih hj">在 CompletableFuture <br/> </strong>中，当函数返回数据时，我们使用 thenApply() <br/>当函数返回 CompletableFuture &lt; T &gt;时，我们使用 thenCompose()</p></blockquote><figure class="jf jg jh ji fd jj"><div class="bz dy l di"><div class="ll lm l"/></div></figure><p id="2220" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><code class="du kf kg kh ki b"><strong class="ih hj">thenCompose()</strong></code>等待 completableFuture(本例中为<code class="du kf kg kh ki b">add()</code>)完成，然后将结果传递给<code class="du kf kg kh ki b">thenAccept()</code>方法。</p><figure class="jf jg jh ji fd jj"><div class="bz dy l di"><div class="ll lm l"/></div></figure><p id="3f0f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><code class="du kf kg kh ki b"><strong class="ih hj">thenCombine()</strong></code>用于合并两个 completableFutures 的结果。它有两个参数，第一个是 completableStage，第二个是 BiFunction</p><figure class="jf jg jh ji fd jj"><div class="bz dy l di"><div class="ll lm l"/></div></figure><p id="099b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我希望它有助于理解用 Java 进行并行和异步编程。感谢阅读！</p></div></div>    
</body>
</html>