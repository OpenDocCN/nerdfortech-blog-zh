<html>
<head>
<title>Kill Process — Day 77(Python)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">终止流程—第77天(Python)</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/kill-process-day-77-python-b75bcb6ac65e?source=collection_archive---------4-----------------------#2021-02-17">https://medium.com/nerd-for-tech/kill-process-day-77-python-b75bcb6ac65e?source=collection_archive---------4-----------------------#2021-02-17</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/c36ddff0991c3bc7aa228faff1a3ddcb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*siGeq_7ndxV61Eia"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">塞巴斯蒂安·斯塔姆在<a class="ae iu" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><p id="bbe5" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">今天的问题来自Leetcode的每日编码挑战二月版。是Leetcode上一个中等标签的问题。让我们看看问题陈述。</p></div><div class="ab cl jt ju gp jv" role="separator"><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy"/></div><div class="hb hc hd he hf"><p id="8676" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><a class="ae iu" href="https://leetcode.com/problems/kill-process/" rel="noopener ugc nofollow" target="_blank">T5 582</a><strong class="ix hj">。杀死过程</strong></p><p id="8a27" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">给定<strong class="ix hj"> n个</strong>进程，每个进程有一个唯一的<strong class="ix hj"> PID(进程id) </strong>和它的<strong class="ix hj"> PPID(父进程id) </strong>。</p><p id="c12c" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">每个进程只有一个父进程，但可能有一个或多个子进程。这就像一个树形结构。只有一个进程的PPID为0，这意味着该进程没有父进程。所有PID都将是不同的正整数。</p><p id="4715" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们使用两个整数列表来表示一个进程列表，其中第一个列表包含每个进程的PID，第二个列表包含相应的PPID。</p><p id="0d19" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">现在给定这两个列表，以及一个表示您想要终止的进程的PID，返回最终将被终止的进程的PID列表。您应该假设当一个进程被终止时，它的所有子进程都会被终止。最终答案不需要排序。</p><p id="61af" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">例1: </strong></p><pre class="ka kb kc kd fd ke kf kg kh aw ki bi"><span id="0552" class="kj kk hi kf b fi kl km l kn ko"><strong class="kf hj">Input:</strong> <br/>pid =  [1, 3, 10, 5]<br/>ppid = [3, 0, 5, 3]<br/>kill = 5<br/><strong class="kf hj">Output:</strong> [5,10]<br/><strong class="kf hj">Explanation:</strong> <br/>           3<br/>         /   \<br/>        1     5<br/>             /<br/>            10<br/>Kill 5 will also kill 10.</span></pre><p id="eab3" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">注:</strong></p><ol class=""><li id="006d" class="kp kq hi ix b iy iz jc jd jg kr jk ks jo kt js ku kv kw kx bi translated">给定的kill id肯定是给定的PID之一。</li><li id="b703" class="kp kq hi ix b iy ky jc kz jg la jk lb jo lc js ku kv kw kx bi translated">n &gt;= 1。</li></ol></div><div class="ab cl jt ju gp jv" role="separator"><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy"/></div><div class="hb hc hd he hf"><p id="d7d4" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">开始解决这个问题的一种方法是使用一种数据结构来跟踪所有节点的子节点。我们可以使用字典来存储父子关系。</p><p id="e225" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">让我们看看如何存储这种关系。</p><pre class="ka kb kc kd fd ke kf kg kh aw ki bi"><span id="7b62" class="kj kk hi kf b fi kl km l kn ko">parent_dictionary = collections.defaultdict(list)<br/>for p in range(len(ppid)):<br/>    parent_dictionary[ppid[p]].append(pid[p])</span></pre><p id="5826" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">接下来，我们需要确定所有必须被杀死的节点。我们从输入节点开始。我们看看谁是这个节点的子节点。然后我们寻找这些孩子的孩子。继续寻找孩子，直到我们到达叶节点。看来我们需要使用BFS或DFS来解决这个问题。</p><p id="ba6e" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们将使用BFS来解决这个问题。</p><p id="9874" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们需要一个队列来跟踪哪个进程需要被终止。我们将从队列中取出第一个节点，在字典中查找它的子节点，并在队列中添加子节点。不断重复这些步骤，直到队列为空。每次我们从队列中删除节点时，都会将它添加到输出列表中。</p><pre class="ka kb kc kd fd ke kf kg kh aw ki bi"><span id="c934" class="kj kk hi kf b fi kl km l kn ko">import collections<br/>class ProcessKiller:<br/>    def killProcess(self, pid: List[int], ppid: List[int], kill: int) -&gt; List[int]:<br/>        parent_dictionary = collections.defaultdict(list)<br/>        output = []<br/>        next_process_to_kill = [kill]<br/>        for p in range(len(ppid)):<br/>            parent_dictionary[ppid[p]].append(pid[p])<br/>        while(next_process_to_kill):<br/>            kill_proc = next_process_to_kill.pop(0)<br/>            output.append(kill_proc)<br/>            for process in parent_dictionary[kill_proc]:<br/>                next_process_to_kill.append(process)<br/>        return output</span></pre><p id="e0ab" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">复杂性分析。</strong></p><p id="425a" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">时间复杂度</strong></p><p id="135f" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们正在访问ppid和pid中的每个节点来创建字典。如果我们必须杀死根节点，杀死过程的时间将为O(N)。因此时间复杂度是O(N)。</p><p id="d6cf" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">空间复杂性。</strong></p><p id="163f" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">因为我们使用字典来存储节点，所以空间复杂度是O(N)，其中N是节点的数量。</p></div><div class="ab cl jt ju gp jv" role="separator"><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy"/></div><div class="hb hc hd he hf"><p id="4c57" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们也可以使用DFS来解决这个问题。由于我们已经使用DFS解决了相当多的问题，我们可以直接查看代码片段。</p><pre class="ka kb kc kd fd ke kf kg kh aw ki bi"><span id="7fd1" class="kj kk hi kf b fi kl km l kn ko">import collections<br/>class ProcessKiller:<br/>    def killProcess(self, pid: List[int], ppid: List[int], kill: int) -&gt; List[int]:<br/>        parent_dictionary = collections.defaultdict(list)<br/>        output = []<br/>        next_process_to_kill = [kill]<br/>        for p in range(len(ppid)):<br/>            parent_dictionary[ppid[p]].append(pid[p])<br/>        def dfs(node):<br/>            output.append(node)<br/>            for child in parent_dictionary[node]:<br/>                dfs(child)<br/>        dfs(kill)<br/>        return output</span></pre><p id="759f" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">复杂性分析。</strong></p><p id="8550" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">时间复杂度</strong></p><p id="ab77" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们正在访问ppid和pid中的每个节点来创建字典。如果我们必须杀死根节点，杀死过程的时间将为O(N)。因此时间复杂度是O(N)。</p><p id="b07f" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">空间复杂性。</strong></p><p id="5ee6" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">因为我们使用字典来存储节点，所以空间复杂度是O(N)，其中N是节点的数量。</p></div></div>    
</body>
</html>