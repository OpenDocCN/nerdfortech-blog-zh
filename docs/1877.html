<html>
<head>
<title>Counting Sort &amp; Radix Sort</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">计数排序和基数排序</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/counting-sort-radix-sort-ccd9f77a00a2?source=collection_archive---------5-----------------------#2021-04-11">https://medium.com/nerd-for-tech/counting-sort-radix-sort-ccd9f77a00a2?source=collection_archive---------5-----------------------#2021-04-11</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><figure class="hh hi ez fb hj hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es hg"><img src="../Images/11b9601625eeae1c00181eca4f3ce787.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6Amy1taQGD8UfZ8uNhEGIA.jpeg"/></div></div><figcaption class="hr hs et er es ht hu bd b be z dx translated">由<a class="ae hv" href="https://unsplash.com/collections/5844710/sorting?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的<a class="ae hv" href="https://unsplash.com/@chuttersnap?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> CHUTTERSNAP </a>拍照</figcaption></figure><div class=""/><p id="ebdc" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在这篇博客中，我们将介绍两种最常见的非基于比较的排序算法。但在此之前，我们为什么需要非比较排序呢？</p><p id="b282" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">基于比较的排序算法有一个<strong class="ix hz"> <em class="jt">下界的</em> </strong> <code class="du ju jv jw jx b"><strong class="ix hz"><em class="jt">O(nlogn)</em></strong></code> <strong class="ix hz"> <em class="jt">操作</em> </strong>来对<code class="du ju jv jw jx b">n</code>元素进行排序。这是因为排序数组是 n！我们可以排列<code class="du ju jv jw jx b">n</code>数字的排列。每次我们做比较的时候，我们实际上将排列<code class="du ju jv jw jx b">n</code>数字的排列数量减少了一半。为了找到实际的安排，我们至少需要做<code class="du ju jv jw jx b">log2N!</code>。为了提高这个下限，我们使用非比较排序算法，如计数&amp;基数排序。这两种排序算法<strong class="ix hz"> <em class="jt">(计数&amp;基数)对</em> </strong> <code class="du ju jv jw jx b"><strong class="ix hz"><em class="jt">O(n)</em></strong></code> <strong class="ix hz"> <em class="jt">运算</em> </strong>中的数据进行排序。他们通过对数据做出某些假设来做到这一点。这些假设使他们能够在不对元素本身进行比较的情况下进行排序。</p><h1 id="1b1e" class="jy jz hy bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">计数排序</h1><p id="311c" class="pw-post-body-paragraph iv iw hy ix b iy kw ja jb jc kx je jf jg ky ji jj jk kz jm jn jo la jq jr js hb bi translated">计数排序是一种线性时间排序算法，当元素在等于 lower_bound -upper_bound 的固定范围 k 内时，它在 O(n+k)时间内对数据进行排序。例如，对于如下生成的数组:</p><pre class="lb lc ld le fd lf jx lg lh aw li bi"><span id="c552" class="lj jz hy jx b fi lk ll l lm ln">import random<br/>randomlist = [random.randint(5,12) for i in range(20)]<br/>print(randomlist)</span><span id="8d4a" class="lj jz hy jx b fi lo ll l lm ln">[11,11,7,9,9,12,11,10,11,9,12,7,11,9,7,8,11,11,6,10]</span></pre><p id="1575" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们将有一个大小为(12–5+1)的数组。其中，第 0 个索引代表值为 5 的项目，第 1 个索引代表值为 6 的项目，第 2 个索引代表值为 7 的项目，依此类推，第 7 个索引代表值为 12 的项目。</p><figure class="lb lc ld le fd hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es lp"><img src="../Images/29423d6305e0e8b285e3673e6c8533a2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rQ-WwldFD76udm2bq97a2w.png"/></div></div></figure><pre class="lb lc ld le fd lf jx lg lh aw li bi"><span id="05fd" class="lj jz hy jx b fi lk ll l lm ln">def countSort(array):<br/>    lower_bound , upper_bound = min(array), max(array)<br/>    counter_array = [0]*(upper_bound-lower_bound+1)<br/>    for item in array:<br/>        counter_array[item-lower_bound] += 1<br/>    pos = 0<br/>    for idx, item in enumerate(counter_array):<br/>        num = idx + lower_bound<br/>        for i in range(item):<br/>            array[pos] = num<br/>            pos += 1<br/>    return array</span></pre><p id="0f7f" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们看到的一件事是，因为我们用索引映射值，所以我们不能用这种方法对一个有负值的数组进行排序。所以我们稍微修改一下这个方法。我们将最小元素(负)的绝对值加到所有元素上。这样，第 0 个索引将指向值为 0 的元素。一旦我们对数组进行了排序，我们只需从每个元素中减去相同的值，就可以得到包含负值和正值的排序后的数组。修改以处理负数:</p><pre class="lb lc ld le fd lf jx lg lh aw li bi"><span id="4688" class="lj jz hy jx b fi lk ll l lm ln">def countSort(array):<br/>    i_lower_bound , upper_bound = min(array), max(array)<br/>    lower_bound = i_lower_bound<br/>    if i_lower_bound &lt; 0:<br/>        lb = abs(i_lower_bound)<br/>        array = [item + lb for item in array]<br/>        lower_bound , upper_bound = min(array), max(array)<br/>        <br/>    counter_array = [0]*(upper_bound-lower_bound+1)<br/>    for item in array:<br/>        counter_array[item-lower_bound] += 1<br/>    pos = 0<br/>    for idx, item in enumerate(counter_array):<br/>        num = idx + lower_bound<br/>        for i in range(item):<br/>            array[pos] = num<br/>            pos += 1<br/>    if i_lower_bound &lt; 0:<br/>        lb = abs(i_lower_bound)<br/>        array = [item - lb for item in array]<br/>    return array</span></pre><h2 id="0814" class="lj jz hy bd ka lq lr ls ke lt lu lv ki jg lw lx km jk ly lz kq jo ma mb ku mc bi translated">计数排序的限制</h2><p id="6d42" class="pw-post-body-paragraph iv iw hy ix b iy kw ja jb jc kx je jf jg ky ji jj jk kz jm jn jo la jq jr js hb bi translated">我们不能在 k 在范围(n)内的地方使用计数排序，因为计数排序将花费<code class="du ju jv jw jx b">O(n^2)</code>比基于比较的排序算法更差。为了解决这个问题，我们使用基数排序。</p><h1 id="c045" class="jy jz hy bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">基数排序</h1><p id="25d5" class="pw-post-body-paragraph iv iw hy ix b iy kw ja jb jc kx je jf jg ky ji jj jk kz jm jn jo la jq jr js hb bi translated">基数排序的思想是从最低有效位到最高有效位逐位排序。基数排序使用桶排序作为子例程进行排序。这个算法利用了十进制系统中的任何数字都可以用从 0 到 9 的数字来表示的事实。因此，在这个算法中，我们每次创建 10 个桶。例如，对于给定的数组<code class="du ju jv jw jx b">[121, 432, 564, 23, 1, 45, 788]</code>,将有三次通过。在每一遍中，数组按相应的遍位排序(LSB → MSB)。</p><figure class="lb lc ld le fd hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es md"><img src="../Images/2400d70fc6c9a0e05a0b56b83dec9233.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8J3k2uTwR1XcJMVMXmvr6A.png"/></div></div></figure><p id="2a37" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">使用计数排序作为子程序的基数排序:</p><pre class="lb lc ld le fd lf jx lg lh aw li bi"><span id="0d00" class="lj jz hy jx b fi lk ll l lm ln">def radixSort(array):<br/>    n_digits = len(str(max(array)))<br/>    size = len(array)<br/>    for dgt in range(n_digits):<br/>        count_array = [0]*10<br/>        sorted_array = [0] * size<br/>        for num in array:<br/>            idx = (num//(10**dgt))%10<br/>            count_array[idx] += 1<br/>        <br/>        for i in range(1, 10):<br/>            count_array[i] += count_array[i - 1] <br/>        <br/>        i = size - 1<br/>        while i &gt;= 0:<br/>            idx = (array[i] // (10**dgt))%10<br/>            sorted_array[count_array[idx] - 1] = array[i]<br/>            count_array[idx] -= 1<br/>            i -= 1<br/>            <br/>        array = sorted_array</span><span id="63bb" class="lj jz hy jx b fi lo ll l lm ln">return array</span></pre><p id="c507" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">使用计数排序来实现基数排序会使代码稍微复杂一些。为了降低复杂性，我们可以使用桶排序作为子程序。这使得代码更具可读性。</p><pre class="lb lc ld le fd lf jx lg lh aw li bi"><span id="0a4b" class="lj jz hy jx b fi lk ll l lm ln">import itertools<br/>def radixSort(array):<br/>    n_digits = len(str(max(array)))<br/>    for dgt in range(n_digits):<br/>        buckets = [[] for i in range(10)]<br/>        for num in array:<br/>            idx = (num // (10**dgt)) % 10<br/>            buckets[idx].append(num)<br/>        array = list(itertools.chain(*buckets))<br/>    return array</span></pre><p id="7d6d" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">修改为负数排序:</p><pre class="lb lc ld le fd lf jx lg lh aw li bi"><span id="a519" class="lj jz hy jx b fi lk ll l lm ln">def radixSort(array):<br/>    min_num = min(array)<br/>    if min_num &lt; 0:<br/>        lb = abs(min_num)<br/>        array = [item + lb for item in array]<br/>    n_digits = len(str(max(array)))<br/>    for dgt in range(n_digits):<br/>        buckets = [[] for i in range(10)]<br/>        for num in array:<br/>            idx = (num // (10**dgt)) % 10<br/>            buckets[idx].append(num)<br/>        array = list(itertools.chain(*buckets))<br/>    if min_num &lt; 0:<br/>        lb = abs(min_num)<br/>        array = [item - lb for item in array]<br/>    return array</span></pre><figure class="lb lc ld le fd hk"><div class="bz dy l di"><div class="me mf l"/></div></figure><p id="bd0a" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">希望这对你有帮助。</p></div></div>    
</body>
</html>