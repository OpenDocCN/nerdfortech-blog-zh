<html>
<head>
<title>Using CRI-O as container runtime for Kubernetes</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用CRI-O作为Kubernetes的容器运行时</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/using-cri-o-as-container-runtime-for-kubernetes-b8ddf8326d38?source=collection_archive---------0-----------------------#2021-01-12">https://medium.com/nerd-for-tech/using-cri-o-as-container-runtime-for-kubernetes-b8ddf8326d38?source=collection_archive---------0-----------------------#2021-01-12</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><figure class="hh hi ez fb hj hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es hg"><img src="../Images/b0f15b20dc63629122c196c9e66466d8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-mo-ikXypOakjhUf2ABM9g.jpeg"/></div></div><figcaption class="hr hs et er es ht hu bd b be z dx translated">在<a class="ae hv" href="https://unsplash.com/s/photos/container?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上由<a class="ae hv" href="https://unsplash.com/@hdbernd?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Bernd Dittrich </a>拍摄的照片</figcaption></figure><div class=""/><p id="01be" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><em class="jt">在本帖中，我们将看到如何将cri-o设置为Kubernetes的容器运行时。</em></p><h2 id="65cc" class="ju jv hy bd jw jx jy jz ka kb kc kd ke jg kf kg kh jk ki kj kk jo kl km kn ko bi translated">什么是容器运行时？</h2><p id="edba" class="pw-post-body-paragraph iv iw hy ix b iy kp ja jb jc kq je jf jg kr ji jj jk ks jm jn jo kt jq jr js hb bi translated">容器运行时是一个负责在节点上运行和管理容器的软件。Docker是最广为人知的容器运行时，但市场上很少有像containerd、rkt和<strong class="ix hz"> cri-o </strong>这样的运行时。</p><p id="6921" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在1.20版本之后，Kubernetes将不再使用docker作为其容器运行时。对于docker来说，这没什么大不了的，因为docker不仅仅是一个容器运行时，它还是一套可以用来构建和运行容器的产品。你可以阅读这篇<a class="ae hv" href="https://kubernetes.io/blog/2020/12/02/dont-panic-kubernetes-and-docker/" rel="noopener ugc nofollow" target="_blank">帖子</a>了解更多信息。</p><h2 id="4a74" class="ju jv hy bd jw jx jy jz ka kb kc kd ke jg kf kg kh jk ki kj kk jo kl km kn ko bi translated"><a class="ae hv" href="https://cri-o.io/" rel="noopener ugc nofollow" target="_blank"> CRI-O </a></h2><p id="e0df" class="pw-post-body-paragraph iv iw hy ix b iy kp ja jb jc kq je jf jg kr ji jj jk ks jm jn jo kt jq jr js hb bi translated">cri-o是一个轻量级OCI兼容容器运行时，这意味着我们可以使用任何兼容注册表来存储图像和运行任何OCI兼容容器。你可以在这个网站<a class="ae hv" href="https://opencontainers.org/" rel="noopener ugc nofollow" target="_blank">https://opencontainers.org</a>/上了解更多关于OCI(开放集装箱倡议)的信息。</p><p id="0a4e" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">Docker、Containerd和CRI-O之间的比较如下所示:</p><figure class="kv kw kx ky fd hk er es paragraph-image"><div class="er es ku"><img src="../Images/b71ec0bce19ec644d8410bf1f0937459.png" data-original-src="https://miro.medium.com/v2/resize:fit:906/format:webp/1*0jakxqNIASxbihZy5gwExQ.png"/></div><figcaption class="hr hs et er es ht hu bd b be z dx translated">码头工人vs集装箱工人vs CRI-O</figcaption></figure></div><div class="ab cl kz la gp lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="hb hc hd he hf"><h2 id="c6d1" class="ju jv hy bd jw jx jy jz ka kb kc kd ke jg kf kg kh jk ki kj kk jo kl km kn ko bi translated">装置</h2><p id="f167" class="pw-post-body-paragraph iv iw hy ix b iy kp ja jb jc kq je jf jg kr ji jj jk ks jm jn jo kt jq jr js hb bi translated">在本演示中，我们将使用两个ec2虚拟机，一个作为主节点，另一个作为工作节点。必要的配置已经在网络层完成，这样这些节点就可以互相通信，Kubernetes就可以工作了。</p><p id="4db5" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">整个过程分为3个阶段:</p><h2 id="e137" class="ju jv hy bd jw jx jy jz ka kb kc kd ke jg kf kg kh jk ki kj kk jo kl km kn ko bi translated"><em class="lg">先决条件:</em></h2><p id="4880" class="pw-post-body-paragraph iv iw hy ix b iy kp ja jb jc kq je jf jg kr ji jj jk ks jm jn jo kt jq jr js hb bi translated">我们必须在两个节点上启用两个内核模块，然后在运行时启用它们。在两个节点上执行以下命令:</p><p id="4971" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><em class="jt">注意:复制命令时，请忽略括号中的注释。</em></p><pre class="kv kw kx ky fd lh li lj lk aw ll bi"><span id="cca2" class="ju jv hy li b fi lm ln l lo lp">#modprobe overlay  ( For using overlayFS )<br/>#modprobe br_netfilter  (Turns on VxLan for pod communication)</span><span id="9ed3" class="ju jv hy li b fi lq ln l lo lp">#cat &gt; /etc/sysctl.d/99-kubernetes-cri.conf &lt;&lt;EOF<br/>net.bridge.bridge-nf-call-iptables  = 1<br/>net.ipv4.ip_forward                 = 1<br/>net.bridge.bridge-nf-call-ip6tables = 1<br/>EOF</span><span id="be42" class="ju jv hy li b fi lq ln l lo lp">#sysctl --system<br/>#swapoff -a (kubernetes scheduler requires this setting to be done.)</span></pre><h2 id="58c5" class="ju jv hy bd jw jx jy jz ka kb kc kd ke jg kf kg kh jk ki kj kk jo kl km kn ko bi translated">安装cri-o:</h2><p id="bc9a" class="pw-post-body-paragraph iv iw hy ix b iy kp ja jb jc kq je jf jg kr ji jj jk ks jm jn jo kt jq jr js hb bi translated">在开始下载包之前，我们必须在两个节点上设置两个环境变量，它们是<strong class="ix hz"> OS </strong>和<strong class="ix hz">版本</strong>。<strong class="ix hz"> OS </strong>取决于这些节点的操作系统的风格和版本。使用下面的查找表来设置值。这些信息也可以在cri-o网站上找到。</p><figure class="kv kw kx ky fd hk er es paragraph-image"><div class="er es lr"><img src="../Images/3fbf4f5e6a0c1ef357d0158d02c1bbd3.png" data-original-src="https://miro.medium.com/v2/resize:fit:636/format:webp/1*RdgCtzLTj2J-s3dZ1YLr_A.png"/></div><figcaption class="hr hs et er es ht hu bd b be z dx translated">$OS</figcaption></figure><p id="dbdf" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">要确定Ubuntu的版本，您可以运行以下命令:</p><pre class="kv kw kx ky fd lh li lj lk aw ll bi"><span id="987d" class="ju jv hy li b fi lm ln l lo lp">#lsb_release -a</span></pre><p id="c294" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">因为我运行的是Ubuntu 18。*在两个节点上，我将设置如下值:</p><pre class="kv kw kx ky fd lh li lj lk aw ll bi"><span id="1bad" class="ju jv hy li b fi lm ln l lo lp">#OS=xUbuntu_18.04</span></pre><p id="d559" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">接下来，设置要下载的cri-o版本。这应该与您计划部署的Kubernetes版本相匹配。我将使用Kubernetes 1.20，因此将版本设置为1.20。</p><pre class="kv kw kx ky fd lh li lj lk aw ll bi"><span id="f936" class="ju jv hy li b fi lm ln l lo lp">#VERSION=1.20</span></pre><p id="163e" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">现在我们可以执行下面的命令来下载软件包</p><pre class="kv kw kx ky fd lh li lj lk aw ll bi"><span id="7273" class="ju jv hy li b fi lm ln l lo lp">#echo "deb <a class="ae hv" href="https://download.opensuse.org/repositories/devel:/kubic:/libcontainers:/stable/$OS/" rel="noopener ugc nofollow" target="_blank">https://download.opensuse.org/repositories/devel:/kubic:/libcontainers:/stable/$OS/</a> /" &gt; /etc/apt/sources.list.d/devel:kubic:libcontainers:stable.list</span><span id="e090" class="ju jv hy li b fi lq ln l lo lp">#echo "deb <a class="ae hv" href="http://download.opensuse.org/repositories/devel:/kubic:/libcontainers:/stable:/cri-o:/$VERSION/$OS/" rel="noopener ugc nofollow" target="_blank">http://download.opensuse.org/repositories/devel:/kubic:/libcontainers:/stable:/cri-o:/$VERSION/$OS/</a> /" &gt; /etc/apt/sources.list.d/devel:kubic:libcontainers:stable:cri-o:$VERSION.list</span><span id="06c0" class="ju jv hy li b fi lq ln l lo lp">#curl -L <a class="ae hv" href="https://download.opensuse.org/repositories/devel:kubic:libcontainers:stable:cri-o:$VERSION/$OS/Release.key" rel="noopener ugc nofollow" target="_blank">https://download.opensuse.org/repositories/devel:kubic:libcontainers:stable:cri-o:$VERSION/$OS/Release.key</a> | apt-key add -<br/>curl -L <a class="ae hv" href="https://download.opensuse.org/repositories/devel:/kubic:/libcontainers:/stable/$OS/Release.key" rel="noopener ugc nofollow" target="_blank">https://download.opensuse.org/repositories/devel:/kubic:/libcontainers:/stable/$OS/Release.key</a> | apt-key add -</span></pre><p id="8e77" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">更新apt库，安装<strong class="ix hz"> cri-o </strong>、<strong class="ix hz"> cri-o-runc </strong>和<strong class="ix hz"> cri-tools </strong>。</p><pre class="kv kw kx ky fd lh li lj lk aw ll bi"><span id="1546" class="ju jv hy li b fi lm ln l lo lp">#apt-get update<br/>#apt-get install cri-o cri-o-runc cri-tools</span></pre><p id="7c98" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">一旦安装了包，我们将编辑<strong class="ix hz"> /etc/crio/crio.conf </strong>文件并设置<strong class="ix hz"> conmon=/usr/bin/conmon的值。Conmon是一个监控crio的实用程序。默认情况下，crio.conf中的conman设置为空，我们必须用conman的二进制路径替换它。</strong></p><p id="1a38" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">编辑完crio.conf文件后，启用<strong class="ix hz"> cri-o.service </strong>并启动服务。</p><pre class="kv kw kx ky fd lh li lj lk aw ll bi"><span id="60a5" class="ju jv hy li b fi lm ln l lo lp">#systemctl enable cri-o.service<br/>#systemctl start cri-o.service<br/>#systemctl status cri-o.service</span></pre><p id="a5b0" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">运行<strong class="ix hz"> crictl info </strong>命令，检查cri-o是否安装并正确启动。</p><pre class="kv kw kx ky fd lh li lj lk aw ll bi"><span id="4cb3" class="ju jv hy li b fi lm ln l lo lp">#:/home/ubuntu# crictl info<br/>{<br/>  "status": {<br/>    "conditions": [<br/>      {<br/>        "type": "<strong class="li hz">RuntimeReady</strong>",<br/>        "status": true,<br/>        "reason": "",<br/>        "message": ""<br/>      },<br/>      {<br/>        "type": "NetworkReady",<br/>        "status": true,<br/>        "reason": "",<br/>        "message": ""<br/>      }<br/>    ]<br/>  }<br/>}</span></pre><h2 id="0f94" class="ju jv hy bd jw jx jy jz ka kb kc kd ke jg kf kg kh jk ki kj kk jo kl km kn ko bi translated">安装K8:</h2><p id="8e6f" class="pw-post-body-paragraph iv iw hy ix b iy kp ja jb jc kq je jf jg kr ji jj jk ks jm jn jo kt jq jr js hb bi translated">我们将遵循标准的<strong class="ix hz"> kubeadm </strong>方法来设置一个双节点集群。按照<a class="ae hv" href="https://kubernetes.io/docs/setup/production-environment/tools/kubeadm/install-kubeadm/" rel="noopener ugc nofollow" target="_blank">本</a>安装指南安装<strong class="ix hz"> kubectl </strong>、<strong class="ix hz"> kubeadm </strong>和<strong class="ix hz"> kubelet </strong>(版本1.20)。我们不必遵循容器运行时部分，因为我们已经在上面的步骤中设置了cri-o。</p><p id="910b" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">一旦安装了包，我们必须在两个节点上配置<strong class="ix hz"> kubelet </strong>以开始使用<strong class="ix hz"> systemd </strong>作为cgroup驱动程序。默认情况下，cri-o使用<strong class="ix hz"> systemd </strong>作为cgroup驱动程序，而kubelet被设置为使用<strong class="ix hz"> cgroupfs </strong>。我们必须编辑kubelet服务文件，并包括一个额外的“<strong class="ix hz"> KUBELET_EXTRA_ARGS </strong>”设置，在下面的快照中突出显示。</p><pre class="kv kw kx ky fd lh li lj lk aw ll bi"><span id="9ea3" class="ju jv hy li b fi lm ln l lo lp">#vi /etc/systemd/system/kubelet.service.d/10-kubeadm.conf</span><span id="10f9" class="ju jv hy li b fi lq ln l lo lp"># Note: This dropin only works with kubeadm and kubelet v1.11+<br/>[Service]<br/>Environment="KUBELET_KUBECONFIG_ARGS=--bootstrap-kubeconfig=/etc/kubernetes/bootstrap-kubelet.conf --kubeconfig=/etc/kubernetes/kubelet.conf"<br/>Environment="KUBELET_CONFIG_ARGS=--config=/var/lib/kubelet/config.yaml"<br/><strong class="li hz">Environment="KUBELET_EXTRA_ARGS=--feature-gates='AllAlpha=false,RunAsGroup=true' --container-runtime=remote --cgroup-driver=systemd --container-runtime-endpoint='unix:///var/run/crio/crio.sock' --runtime-request-timeout=5m"</strong><br/># This is a file that "kubeadm init" and "kubeadm join" generates at runtime, populating the KUBELET_KUBEADM_ARGS variable dynamically<br/>EnvironmentFile=-/var/lib/kubelet/kubeadm-flags.env<br/># This is a file that the user can use for overrides of the kubelet args as a last resort. Preferably, the user should use<br/># the .NodeRegistration.KubeletExtraArgs object in the configuration files instead. KUBELET_EXTRA_ARGS should be sourced from this file.<br/>EnvironmentFile=-/etc/default/kubelet<br/>ExecStart=<br/>ExecStart=/usr/bin/kubelet $KUBELET_KUBECONFIG_ARGS $KUBELET_CONFIG_ARGS $KUBELET_KUBEADM_ARGS $KUBELET_EXTRA_ARGS</span></pre><p id="e91b" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">保存文件并执行以下命令来重新加载<strong class="ix hz"> systemd </strong>，然后重启<strong class="ix hz"> kubelet </strong>服务:</p><pre class="kv kw kx ky fd lh li lj lk aw ll bi"><span id="42f5" class="ju jv hy li b fi lm ln l lo lp">#systemctl daemon-reload<br/>#systemctl  restart kubelet</span></pre><p id="dc7d" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><em class="jt">注意:为了演示，我将把法兰绒部署为网络插件，并相应地设置</em><strong class="ix hz"><em class="jt">pod-network-CIDR</em></strong><em class="jt">。</em></p><p id="cd54" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们现在可以执行kubeadm init命令，等待控制平面启动并运行。</p><pre class="kv kw kx ky fd lh li lj lk aw ll bi"><span id="b19c" class="ju jv hy li b fi lm ln l lo lp">#kubeadm init --pod-network-cidr=10.244.0.0/16</span></pre><p id="f50d" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">一旦控制面板启动，我们就可以用下面的命令部署法兰绒插件。在运行<strong class="ix hz"> kubectl </strong>之前，确保按照kubeadm命令的输出复制kubeconfig文件。</p><pre class="kv kw kx ky fd lh li lj lk aw ll bi"><span id="3107" class="ju jv hy li b fi lm ln l lo lp">#kubectl apply -f <a class="ae hv" href="https://raw.githubusercontent.com/coreos/flannel/master/Documentation/kube-flannel.ym" rel="noopener ugc nofollow" target="_blank">https://raw.githubusercontent.com/coreos/flannel/master/Documentation/kube-flannel.ym</a></span></pre><p id="ca67" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">一旦创建了资源，检查是否所有在<strong class="ix hz"> kube-system </strong>名称空间下的pod都在运行，然后执行<strong class="ix hz"> kubeadm join </strong>(从kubeadm输出中复制)将我们的worker节点加入到这个集群中。在主节点上执行以下命令，检查两个节点是否都启动，并显示状态为“就绪”:</p><pre class="kv kw kx ky fd lh li lj lk aw ll bi"><span id="28d8" class="ju jv hy li b fi lm ln l lo lp">#kubectl get pods -n kube-system<br/>#kubectl get nodes -o wide</span></pre><p id="1b76" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在上面的输出中，检查<strong class="ix hz">容器-运行时</strong>列，您会注意到它显示了<strong class="ix hz"> cri-o://1.20.0 </strong></p><p id="eca7" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">现在您可以部署一个示例nginx容器，并检查它是否被正确部署。如果到目前为止没有遇到任何错误，这一步应该可以正常工作。</p><pre class="kv kw kx ky fd lh li lj lk aw ll bi"><span id="6f7b" class="ju jv hy li b fi lm ln l lo lp">#kubectl run nginx --image=nginx<br/>#kubectl get pods</span></pre></div><div class="ab cl kz la gp lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="hb hc hd he hf"><h2 id="0fcc" class="ju jv hy bd jw jx jy jz ka kb kc kd ke jg kf kg kh jk ki kj kk jo kl km kn ko bi translated">那是所有人的</h2><p id="8a00" class="pw-post-body-paragraph iv iw hy ix b iy kp ja jb jc kq je jf jg kr ji jj jk ks jm jn jo kt jq jr js hb bi translated">没那么简单！我们现在有一个使用CRI-O作为容器运行时的Kubernetes集群。</p><p id="cfee" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">那为什么是cri-o呢？我正在设置Kata容器，为此，必须将containerd或cri-o设置为容器运行时。在我的下一篇文章中会有更多的介绍。</p><p id="054e" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">你可以在这个<a class="ae hv" href="https://youtube.com/playlist?list=PLOlDWXFyp3kD2IltmtTAyR_G-shyER1Nv" rel="noopener ugc nofollow" target="_blank"> youtube频道</a>找到以上步骤的视频教程。感谢您花时间阅读本文。</p></div></div>    
</body>
</html>