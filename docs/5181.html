<html>
<head>
<title>“Atomic” Property Wrapper Using Unfair Lock</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用不公平锁的“原子”属性包装</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/atomic-property-wrapper-using-unfair-lock-1f3f3d6f9c26?source=collection_archive---------3-----------------------#2021-09-05">https://medium.com/nerd-for-tech/atomic-property-wrapper-using-unfair-lock-1f3f3d6f9c26?source=collection_archive---------3-----------------------#2021-09-05</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="9be4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在这篇文章中，我将描述属性包装器如何帮助我消除<a class="ae jd" href="https://en.wikipedia.org/wiki/Don%27t_repeat_yourself" rel="noopener ugc nofollow" target="_blank"> DRY </a>模式，以及我如何使用<a class="ae jd" href="https://developer.apple.com/documentation/os/1646466-os_unfair_lock_lock" rel="noopener ugc nofollow" target="_blank">OS _ fair _ lock</a>实现线程安全。</p><h2 id="5ede" class="je jf hi bd jg jh ji jj jk jl jm jn jo iq jp jq jr iu js jt ju iy jv jw jx jy bi translated"><strong class="ak">从 NSLock 转换</strong></h2><p id="5f63" class="pw-post-body-paragraph if ig hi ih b ii jz ik il im ka io ip iq kb is it iu kc iw ix iy kd ja jb jc hb bi translated">之前，对于同步机制，我使用了<code class="du ke kf kg kh b">NSLock</code>或递归锁，即主要使用来自<code class="du ke kf kg kh b">NSLocking</code>协议的方法(锁定、解锁方法)。</p><p id="1bf0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果有任何“本地”swift 替代方案，最好不要使用 Swift 的 Obj-C 功能。</p><p id="8281" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">实现 NSLock 的简单方法是使用<strong class="ih hj">OS _ fair _ lock:</strong></p><figure class="ki kj kk kl fd km"><div class="bz dy l di"><div class="kn ko l"/></div></figure><p id="e642" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在引擎盖下，使用了不安全的相互指针，并用适当的不公平锁结构上的指针进行初始化。</p><p id="7c1c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="kp">未锁定</em>，确认到<em class="kp"> NSLocking </em>协议。(然而，可以创建完全“本地的”、Obj-C 自由的类似协议)。</p><p id="64df" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在最初的要点中，我增加了一个额外的协议<code class="du ke kf kg kh b">RunInLockTypeProtocol</code></p><p id="b6d1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">所以它增加了<strong class="ih hj"> runInLock </strong>方法(本质上是将 block 的调用封装在<strong class="ih hj"> lock() </strong>和 deferred <strong class="ih hj"> unlock() </strong>方法下)</p><h2 id="ab2b" class="je jf hi bd jg jh ji jj jk jl jm jn jo iq jp jq jr iu js jt ju iy jv jw jx jy bi translated"><strong class="ak">返回属性包装</strong></h2><p id="e029" class="pw-post-body-paragraph if ig hi ih b ii jz ik il im ka io ip iq kb is it iu kc iw ix iy kd ja jb jc hb bi translated">让我们利用上面的内容创建一个通用的<code class="du ke kf kg kh b">Amotic</code>(线程安全)PW。</p><figure class="ki kj kk kl fd km"><div class="bz dy l di"><div class="kn ko l"/></div></figure><p id="b52a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">包装器基于锁(<code class="du ke kf kg kh b">NSLocking protocol</code>)的用法</p><pre class="ki kj kk kl fd kq kh kr ks aw kt bi"><span id="da3a" class="je jf hi kh b fi ku kv l kw kx">lock.lock()</span><span id="fc4f" class="je jf hi kh b fi ky kv l kw kx">// extra code goes here</span><span id="d7cc" class="je jf hi kh b fi ky kv l kw kx">defer {<br/>    lock.unlock()<br/> }</span></pre><p id="1878" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">调整</strong>方法突变包含值。</p><p id="d836" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这对于引用类型尤其有意义，因为属性包装器返回类型上的指针，并互斥地返回它，但是内容不能以线程安全的方式更改)。下面是一个<strong class="ih hj">原子</strong>使用<strong class="ih hj"> : </strong>的例子</p><pre class="ki kj kk kl fd kq kh kr ks aw kt bi"><span id="9af8" class="je jf hi kh b fi ku kv l kw kx">//@Atomic var value = false</span><span id="5a4c" class="je jf hi kh b fi ky kv l kw kx">// value = true </span><span id="7bd1" class="je jf hi kh b fi ky kv l kw kx">//_value.toggle() or _value.adjust( { _ in !$0 })</span></pre></div></div>    
</body>
</html>