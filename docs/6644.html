<html>
<head>
<title>String in Java is immutable</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Java 中的字符串是不可变的</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/string-in-java-is-immutable-a90f97067bd?source=collection_archive---------2-----------------------#2022-04-10">https://medium.com/nerd-for-tech/string-in-java-is-immutable-a90f97067bd?source=collection_archive---------2-----------------------#2022-04-10</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div class="er es if"><img src="../Images/a89f1f0a4a2d921dbe363504018e2374.png" data-original-src="https://miro.medium.com/v2/resize:fit:800/format:webp/1*cI8p7L4Ly__355VGxD7RmQ.png"/></div><figcaption class="im in et er es io ip bd b be z dx translated">Java 字符串</figcaption></figure><p id="b696" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">好吧，我知道你们大多数人都知道这一点！！！我也知道！！！但是我们是否正确理解了术语<strong class="is hj"> <em class="jo">【不可变】</em> </strong>以及我们是否知道为什么字符串在 Java 中是不可变的<strong class="is hj"> <em class="jo">？？？</em> </strong></p><p id="58fe" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">好了，我们开始吧！！！</p><h2 id="b1ac" class="jp jq hi bd jr js jt ju jv jw jx jy jz jb ka kb kc jf kd ke kf jj kg kh ki kj bi translated">什么是不变性？？？</h2><p id="9012" class="pw-post-body-paragraph iq ir hi is b it kk iv iw ix kl iz ja jb km jd je jf kn jh ji jj ko jl jm jn hb bi translated"><strong class="is hj"> <em class="jo">简单来说，一个对象一旦被创建，就不能被修改或更改。</em> </strong>值和对象在 Java 中是两个不同的术语。<strong class="is hj"> <em class="jo">值</em> </strong>是<strong class="is hj"> <em class="jo">一个实例变量或引用变量所保存的</em> </strong>。<strong class="is hj"> <em class="jo">实例变量保存实际值</em> </strong>(基于类型)，例如程序员提供的。例如</p><pre class="kp kq kr ks fd kt ku kv kw aw kx bi"><span id="c612" class="jp jq hi ku b fi ky kz l la lb">int a = 123;<br/>float s = 65.7;<br/>String name = "Lakshi";</span></pre><p id="2326" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如你所知，Java 中的<strong class="is hj"> <em class="jo">对象</em> </strong>存储在 JVM 中 内存区的<strong class="is hj"> <em class="jo">堆区。为了更好的理解，请参考我的关于 JVM 架构的文章。因此，一个<strong class="is hj"> <em class="jo">引用变量</em> </strong>保存它所指向的对象的<strong class="is hj"> <em class="jo">内存地址，作为它的值。</em> </strong>下图说明了一个参考变量<strong class="is hj"> <em class="jo">。</em>T45】</strong></em></strong></p><figure class="kp kq kr ks fd ij er es paragraph-image"><div class="er es ld"><img src="../Images/188ca92530c5c6629d153927a111494a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1346/format:webp/1*ZzVPi8is3_Wsj_Kv-xqdTQ.png"/></div><figcaption class="im in et er es io ip bd b be z dx translated">参考变量的图示</figcaption></figure><p id="f212" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">而一个对象是一个类 的<strong class="is hj"> <em class="jo">实例，带有许多<strong class="is hj"> <em class="jo">实例变量</em> </strong>通常称为<strong class="is hj"> <em class="jo">【属性】</em> </strong>。</em></strong></p><p id="d5fe" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj"> <em class="jo"> String 是 Java 中的一个类</em> </strong>。因此，任何用“String”类型声明的变量都变成了一个<strong class="is hj"> <em class="jo">引用变量，指向一个 String 类的实例(即 String 对象)</em> </strong>。如下图所示，一个<strong class="is hj"> <em class="jo">变量【名称】</em> </strong>被<strong class="is hj"> <em class="jo">赋值</em> </strong> <strong class="is hj"> <em class="jo">【约翰】</em> </strong>。后来我们把变量的<strong class="is hj"> <em class="jo">值改为【简】</em> </strong>。所以在这里，只有引用变量“name”的值被更改。当“name”变量被修改为“Jane”时，被赋予值“John”的字符串对象永远不会改变。</p><pre class="kp kq kr ks fd kt ku kv kw aw kx bi"><span id="740c" class="jp jq hi ku b fi ky kz l la lb">String name = "John";<br/>name = "Jane";</span></pre><p id="e5d2" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">迷惑对吗？？？对于上面的代码，让我们深入研究一下在内存的堆栈和堆区域发生了什么！！！</p><p id="7ae4" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如前所述，用 Java 创建的任何对象都存储在堆中。当<strong class="is hj"> <em class="jo"> "name "变量被赋值为" John "，</em> </strong> <strong class="is hj"> <em class="jo"> JVM 在堆中创建一个对象</em> </strong>，<strong class="is hj"> <em class="jo">将其值设置为" John" </em> </strong>(因为，一个字符串值被赋值，String 在 Java 中是一个类，因此一个字符串对象被创建)。<strong class="is hj"><em class="jo">“name”变量指向这个对象。</em> </strong>这是下图。</p><figure class="kp kq kr ks fd ij er es paragraph-image"><div class="er es ld"><img src="../Images/d620c768a195eaf402b429b938a17dae.png" data-original-src="https://miro.medium.com/v2/resize:fit:1346/format:webp/1*ry9bvohDS__xym8S5493zA.png"/></div><figcaption class="im in et er es io ip bd b be z dx translated">对象引用的图示</figcaption></figure><p id="0373" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">后来，<strong class="is hj"> <em class="jo">当“名”赋“简”</em> </strong>。这个<strong class="is hj"> <em class="jo">创建了另一个字符串对象，并将其值设置为“Jane”。</em> </strong>现在，“名字”变量指向哪里？？？是的，<strong class="is hj"> <em class="jo"> "name "变量从" John "对象解引用并指向" Jane "对象</em> </strong>，如下所示。</p><p id="9d00" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><em class="jo">注意，这些是字符串对象，它们的值是“John”和“Jane”。</em></p><figure class="kp kq kr ks fd ij er es paragraph-image"><div class="er es le"><img src="../Images/68d7c3050e1e64757c06c31dc53d7dac.png" data-original-src="https://miro.medium.com/v2/resize:fit:1356/format:webp/1*8youc42RFXoiG5W4ltQn8g.png"/></div><figcaption class="im in et er es io ip bd b be z dx translated">使用对象引用</figcaption></figure><blockquote class="lf lg lh"><p id="6733" class="iq ir jo is b it iu iv iw ix iy iz ja li jc jd je lj jg jh ji lk jk jl jm jn hb bi translated">那么，我们改变或修改了对象吗？？？没有，但是创建了一个新的 String 对象(Jane 对象)，并且“name”变量开始指向新创建的对象，即“name”变量现在指向堆中的不同位置(不同的内存地址)。因此，这意味着无论何时修改“name”变量的值，它都会用该值创建一个新对象，此后“name”将指向该对象！！！<strong class="is hj"><em class="hi">Java 中的 String 就是这样不可变的！！！</em> </strong></p><p id="35ed" class="iq ir jo is b it iu iv iw ix iy iz ja li jc jd je lj jg jh ji lk jk jl jm jn hb bi translated">提醒一下，注意这两个对象在堆中有不同的内存地址。</p></blockquote><p id="0de8" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们来看看 Java String 被设计成不可变的原因！！！</p><h2 id="e44b" class="jp jq hi bd jr js jt ju jv jw jx jy jz jb ka kb kc jf kd ke kf jj kg kh ki kj bi translated">为什么 Java 字符串是不可变的？？？</h2><p id="70e8" class="pw-post-body-paragraph iq ir hi is b it kk iv iw ix kl iz ja jb km jd je jf kn jh ji jj ko jl jm jn hb bi translated">观察下面的代码。这是三个具有相同值“John”的“String”类型的引用变量。我们使用“==”和来比较这三个变量。equals()函数。</p><figure class="kp kq kr ks fd ij"><div class="bz dy l di"><div class="ll lm l"/></div></figure><p id="65dd" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这在堆内存中表示如下。</p><figure class="kp kq kr ks fd ij er es paragraph-image"><div class="er es ln"><img src="../Images/92b718ce9eed9c35b89765fe73a9d575.png" data-original-src="https://miro.medium.com/v2/resize:fit:1086/format:webp/1*pvA92XTDh7nHxV8p48U-nA.png"/></div><figcaption class="im in et er es io ip bd b be z dx translated">上述代码的堆表示</figcaption></figure><blockquote class="lf lg lh"><p id="0965" class="iq ir jo is b it iu iv iw ix iy iz ja li jc jd je lj jg jh ji lk jk jl jm jn hb bi translated"><strong class="is hj"><em class="hi">“= =”比较变量</em> </strong>的引用(指向对象的内存地址)，由于所有变量都指向同一个对象，所以<strong class="is hj">前 3 条打印语句将返回“真”</strong></p><p id="616e" class="iq ir jo is b it iu iv iw ix iy iz ja li jc jd je lj jg jh ji lk jk jl jm jn hb bi translated"><strong class="is hj">谓 T41。equals()函数比较对象的值，这些变量指向 </strong>，因为所有变量都指向同一个具有值“约翰”的对象，<strong class="is hj">最后 3 个打印语句也将返回“真”。</strong></p></blockquote><p id="38ff" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">假设字符串“John”占用了 4 个字节的堆内存。如果有 1000 个变量，赋值为“John”。在堆中将创建 1000 个值为“John”的对象。因此，它将占用 4000 (4 x 1000)字节的内存。这不是浪费堆内存吗，相同值的对象占用这么多空间！！！</p><p id="283a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">是的，这就是为什么 Java 使用一个<strong class="is hj"> <em class="jo">字符串池来存储字符串。</em>T3】</strong></p><h2 id="3113" class="jp jq hi bd jr js jt ju jv jw jx jy jz jb ka kb kc jf kd ke kf jj kg kh ki kj bi translated">Java 的字符串池</h2><p id="0ee7" class="pw-post-body-paragraph iq ir hi is b it kk iv iw ix kl iz ja jb km jd je jf kn jh ji jj ko jl jm jn hb bi translated">字符串池是堆中的一个存储区域。每当使用类型 String(字符串对象的引用变量)声明变量时，就会创建一个字符串对象(变量指向的对象),占用堆中的空间。在堆中多次创建相同的对象会减少内存空间和性能。</p><p id="16e6" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">字符串池由 Java 中的 string 类维护。因此，<strong class="is hj"> <em class="jo"> String 类创建了一个字符串池</em> </strong>，以减少在 JVM 堆中创建的字符串对象的数量。现在，当创建一个字符串文字(一个分配给引用变量的字符串值)时，JVM 首先检查该文字的字符串池。如果字面量已经存在于池中，它返回对池化实例的引用(<strong class="is hj"> <em class="jo">)，即它将返回存储在引用变量中已经指向该字面量的值，这将使新的引用变量开始指向池中的对象，这样相同的对象可以被 1000 个变量引用，从而节省堆空间</em> </strong>)。如果该文本不在池中，JVM 将在字符串池中创建一个新的字符串对象(该文本作为值)。<strong class="is hj"> <em class="jo">同样值得注意的是，字符串池中只存储不同的字符串对象！！！</em>T15】</strong></p><p id="1f62" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">另外，请注意，在 Java 中，有两种方法可以在堆中创建字符串对象。</p><ol class=""><li id="5b4f" class="lo lp hi is b it iu ix iy jb lq jf lr jj ls jn lt lu lv lw bi translated">使用字符串文字，例如</li></ol><pre class="kp kq kr ks fd kt ku kv kw aw kx bi"><span id="4b87" class="jp jq hi ku b fi ky kz l la lb">String str1 = "Python";<br/>String str2 = "Data Science";</span></pre><p id="a335" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">2.使用“新”关键字</p><pre class="kp kq kr ks fd kt ku kv kw aw kx bi"><span id="817b" class="jp jq hi ku b fi ky kz l la lb">String str4 = new String("Java");<br/>String str5 = new String("C++");</span></pre></div><div class="ab cl lx ly gp lz" role="separator"><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc"/></div><div class="hb hc hd he hf"><p id="dcbf" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">让我们考虑下面的代码。</p><figure class="kp kq kr ks fd ij"><div class="bz dy l di"><div class="ll lm l"/></div></figure><p id="e85a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">堆和栈的表示如下。</p><figure class="kp kq kr ks fd ij er es paragraph-image"><div class="er es ln"><img src="../Images/fbca6c166304ea68e44c37d59ec7de86.png" data-original-src="https://miro.medium.com/v2/resize:fit:1086/format:webp/1*XjYI2qpcCm7uymKzyA2dSA.png"/></div><figcaption class="im in et er es io ip bd b be z dx translated">使用“new”关键字时堆和堆栈的表示形式</figcaption></figure><p id="db1c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这里，每当“new”关键字被用来创建字符串对象时，我们就明确地要求 JVM 创建一个字符串对象。因此<strong class="is hj"> <em class="jo"> JVM 将在字符串池</em> </strong>外创建一个值为“John”的字符串对象，此后“employee”将指向该对象，如上所示。</p><p id="1cce" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">所以，当使用“==”比较“person”或“name”变量与“employee”变量时，<strong class="is hj"> <em class="jo">将返回 false，因为“employee”指向了现在堆中的另一个位置(引用)</em> </strong>。</p><p id="f5c9" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">的。equals()函数无论如何都会返回 true，因为这三个变量都指向具有相同值的对象“John”。 </p><figure class="kp kq kr ks fd ij er es paragraph-image"><div class="er es ln"><img src="../Images/b78430138d46b98c2d09089191eac6d8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1086/format:webp/1*1SH_FmEcIdnseyy9_pIXSw.png"/></div><figcaption class="im in et er es io ip bd b be z dx translated">使用“new”关键字时堆和堆栈的表示形式</figcaption></figure><p id="72d6" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">同样，当使用“==”比较<strong class="is hj"> <em class="jo">、【str1】和【str3】时，将返回 true </em>、</strong>，因为两者引用的是同一个对象。但<strong class="is hj"><em class="jo">“str 1”或“str3”与“str5”相比，会返回 false </em> </strong>，因为“str5”指向的是在堆中显式创建的对象(使用“new”)。</p><blockquote class="lf lg lh"><p id="81dc" class="iq ir jo is b it iu iv iw ix iy iz ja li jc jd je lj jg jh ji lk jk jl jm jn hb bi translated"><strong class="is hj">注意，所有用“new”关键字创建的字符串对象都发生在堆中，而不是字符串池中。</strong></p><p id="e8e9" class="iq ir jo is b it iu iv iw ix iy iz ja li jc jd je lj jg jh ji lk jk jl jm jn hb bi translated">如前所述，当“str1”被赋予“Python”时，JVM 检查字符串池，因为它不存在，所以它将在字符串池中创建相应的字符串对象。这同样适用于分配给“数据科学”的“str2”。后来，当“str3”再次被赋予“Python”时，JVM 检查字符串池中的“Python”对象，因为它已经存在，所以它返回池实例的引用，即 str1，而不在字符串池中创建新的字符串对象。</p></blockquote><h2 id="816c" class="jp jq hi bd jr js jt ju jv jw jx jy jz jb ka kb kc jf kd ke kf jj kg kh ki kj bi translated">String 类能够维护一个字符串池，基本上是因为 Java 中的 String 是不可变的。</h2><p id="d58c" class="pw-post-body-paragraph iq ir hi is b it kk iv iw ix kl iz ja jb km jd je jf kn jh ji jj ko jl jm jn hb bi translated">再次强调！！！</p><h2 id="bf16" class="jp jq hi bd jr js jt ju jv jw jx jy jz jb ka kb kc jf kd ke kf jj kg kh ki kj bi translated">不变性并不意味着你不能改变引用变量的值，而是意味着你不能改变创建的对象！！！</h2></div><div class="ab cl lx ly gp lz" role="separator"><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc"/></div><div class="hb hc hd he hf"><h2 id="9519" class="jp jq hi bd jr js jt ju jv jw jx jy jz jb ka kb kc jf kd ke kf jj kg kh ki kj bi translated">Java 字符串是线程安全的</h2><p id="2e1f" class="pw-post-body-paragraph iq ir hi is b it kk iv iw ix kl iz ja jb km jd je jf kn jh ji jj ko jl jm jn hb bi translated">因为<strong class="is hj"> <em class="jo">字符串是不可变的</em> </strong>，所以<strong class="is hj"> <em class="jo">线程也是安全的</em> </strong>。假设有一个方法将“name”变量作为参数，如下所示。“name”变量指向堆中的“John”对象。</p><pre class="kp kq kr ks fd kt ku kv kw aw kx bi"><span id="433e" class="jp jq hi ku b fi ky kz l la lb">public class Application {</span><span id="ec88" class="jp jq hi ku b fi me kz l la lb">   public static void main(String args[]){<br/>       givePromotion("John");<br/>   }</span><span id="bea2" class="jp jq hi ku b fi me kz l la lb">   public void givePromotion(String name){<br/>       //promotion code<br/>   }</span><span id="f836" class="jp jq hi ku b fi me kz l la lb">}</span></pre><p id="8f75" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">一个 Java 程序在运行时可以创建许多线程(非守护进程)。假设两个线程同时访问同一个方法。如果 Java String 不是不可变的，当一个线程执行 givePromotion()方法时，另一个线程可以将 String 对象的值从“John”修改为“Jane”。执行线程将“name”(指向相同的 String 对象，但具有不同的值)作为“Jane ”,不同的雇员可能获得提升。如下图所示。</p><figure class="kp kq kr ks fd ij er es paragraph-image"><div class="er es mf"><img src="../Images/d6be7bb2025026b3184937236e84f3cf.png" data-original-src="https://miro.medium.com/v2/resize:fit:966/format:webp/1*QFm5Wkfz35dJ6WpxYtQkVA.png"/></div><figcaption class="im in et er es io ip bd b be z dx translated">字符串对象不是不可变的情况下的插图</figcaption></figure><blockquote class="lf lg lh"><p id="b1d5" class="iq ir jo is b it iu iv iw ix iy iz ja li jc jd je lj jg jh ji lk jk jl jm jn hb bi translated">因为字符串对象是不可变的，所以当一个线程执行相应的方法时，另一个线程不能修改创建的对象。因此，多个线程可以同时访问同一个字符串对象。</p></blockquote><p id="11b5" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">唷！！！很多要理解对吧！！！慢慢来，你会抓住它的！！！</p><p id="c217" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">快乐学习！！！</p></div><div class="ab cl lx ly gp lz" role="separator"><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc"/></div><div class="hb hc hd he hf"><h2 id="6320" class="jp jq hi bd jr js jt ju jv jw jx jy jz jb ka kb kc jf kd ke kf jj kg kh ki kj bi translated">参考</h2><ol class=""><li id="e957" class="lo lp hi is b it kk ix kl jb mg jf mh jj mi jn lt lu lv lw bi translated"><a class="ae lc" href="https://www.youtube.com/watch?v=jK1Ik8q0lyM&amp;list=PLD-mYtebG3X8tf1M8mRly3CO7tlTfeeLW" rel="noopener ugc nofollow" target="_blank"> (57)为什么不变性很重要？——YouTube</a></li><li id="5a7b" class="lo lp hi is b it mj ix mk jb ml jf mm jj mn jn lt lu lv lw bi translated"><a class="ae lc" href="https://www.javatpoint.com/string-pool-in-java" rel="noopener ugc nofollow" target="_blank">Java 中的字符串池—Java point</a></li><li id="9f59" class="lo lp hi is b it mj ix mk jb ml jf mm jj mn jn lt lu lv lw bi translated"><a class="ae lc" href="https://www.journaldev.com/797/what-is-java-string-pool" rel="noopener ugc nofollow" target="_blank">什么是 Java 字符串池？— JournalDev </a></li></ol></div></div>    
</body>
</html>