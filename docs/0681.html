<html>
<head>
<title>Beyond Jupyter Notebooks</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">超越Jupyter笔记本</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/beyond-jupyter-notebooks-63b169c43c44?source=collection_archive---------6-----------------------#2021-02-03">https://medium.com/nerd-for-tech/beyond-jupyter-notebooks-63b169c43c44?source=collection_archive---------6-----------------------#2021-02-03</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="27e8" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">第2部分:使用Streamlit和Docker的非ML模型部署</h2></div><p id="dff0" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">欢迎学习第2部分。在本文中，您将学习如何使用Streamlit部署一个非常简单的非机器学习模型，并使用Docker在第1部分的基础上构建一个容器。</p><p id="6180" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">更准确地说，我们将:</p><ul class=""><li id="f0a1" class="ju jv hi iz b ja jb jd je jg jw jk jx jo jy js jz ka kb kc bi translated"><strong class="iz hj">创建一个服务于我们模型的web应用</strong></li><li id="a71a" class="ju jv hi iz b ja kd jd ke jg kf jk kg jo kh js jz ka kb kc bi translated"><strong class="iz hj">将我们的网络应用程序容器化</strong></li></ul><p id="e74d" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们不会用我们的非机器学习模型创建生产就绪代码，也不会用<strong class="iz hj">测试我们的模型</strong>，因为这部分已经在<a class="ae jt" href="https://gregjan.medium.com/beyond-jupyter-notebooks-6fd11322d313" rel="noopener">第1部分</a>中讨论过了。</p><figure class="kj kk kl km fd kn er es paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="er es ki"><img src="../Images/1c20674b07def5819deb9a902fcdf759.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*4qSwiadViyfUuN0K"/></div></div></figure><h2 id="3d80" class="ku kv hi bd kw kx ky kz la lb lc ld le jg lf lg lh jk li lj lk jo ll lm ln lo bi translated">简化应用程序</h2><p id="4f9f" class="pw-post-body-paragraph ix iy hi iz b ja lp ij jc jd lq im jf jg lr ji jj jk ls jm jn jo lt jq jr js hb bi translated"><a class="ae jt" href="https://streamlit.io/" rel="noopener ugc nofollow" target="_blank"> Streamlit </a>是一个开源的Python库，可以轻松地为机器学习和数据科学(他们自己的话！).就我个人而言，我发现很容易构建一个好看的交互式应用程序非常方便。缺点是可伸缩性(考虑数据的高容量和高吞吐量)和复杂性(在这个问题上，我会使用<a class="ae jt" href="https://plotly.com/dash/" rel="noopener ugc nofollow" target="_blank">破折号</a>)。</p><p id="e6bc" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">首先让我们将<em class="lu"> streamlit </em>安装到我们的conda环境中:</p><pre class="kj kk kl km fd lv lw lx ly aw lz bi"><span id="679d" class="ku kv hi lw b fi ma mb l mc md">conda install -c conda-forge streamlit</span></pre><p id="c9b2" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">现在我们可以为应用程序本身编写代码了:</p><figure class="kj kk kl km fd kn"><div class="bz dy l di"><div class="me mf l"/></div></figure><p id="4d72" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">正如你所看到的，这比Flask应用程序要简单和整洁得多(见<a class="ae jt" href="https://gregjan.medium.com/beyond-jupyter-notebooks-6fd11322d313" rel="noopener">第1部分</a>)。它分为4个部分:</p><ol class=""><li id="c43d" class="ju jv hi iz b ja jb jd je jg jw jk jx jo jy js mg ka kb kc bi translated">导入<em class="lu"> streamlit </em>并加载我们的<em class="lu">建模器</em>类(详情请参见<a class="ae jt" href="https://gregjan.medium.com/beyond-jupyter-notebooks-6fd11322d313" rel="noopener">第1部分</a></li><li id="78b6" class="ju jv hi iz b ja kd jd ke jg kf jk kg jo kh js mg ka kb kc bi translated">设置应用程序的标题</li><li id="6b19" class="ju jv hi iz b ja kd jd ke jg kf jk kg jo kh js mg ka kb kc bi translated">制作一个滑块来选择一个值<em class="lu"> x </em></li><li id="46b0" class="ju jv hi iz b ja kd jd ke jg kf jk kg jo kh js mg ka kb kc bi translated">打印来自类<em class="lu">建模器</em>的<em class="lu">预测</em>函数的输出，将<em class="lu"> x </em>作为输入。它隐式地使用了一个回调函数，roles将在输入组件的属性改变时自动调用<em class="lu"> predict </em>。</li></ol><p id="a2fc" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">就这样吗？是的，差不多！要启动该应用程序，只需在您的终端中输入:</p><pre class="kj kk kl km fd lv lw lx ly aw lz bi"><span id="6938" class="ku kv hi lw b fi ma mb l mc md">streamlit run app.py</span></pre><p id="3a71" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">现在，您应该会看到类似这样的内容:</p><figure class="kj kk kl km fd kn er es paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="er es mh"><img src="../Images/6b6497abe3de960360ca01e399266ff9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*puzkj-0uc7zpCmPpfoIyDQ.png"/></div></div></figure><p id="83a3" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">跟随第一个网址，它将打开你的应用程序:</p><figure class="kj kk kl km fd kn er es paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="er es mi"><img src="../Images/ce47e0e22425ec0db2b816a0bdd621ad.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FW-kT-tLs6l6ZbBiHcswSw.png"/></div></div></figure><p id="607d" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我相信20 = 400，所以该应用程序正在按预期工作。</p></div><div class="ab cl mj mk gp ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="hb hc hd he hf"><h1 id="e413" class="mq kv hi bd kw mr ms mt la mu mv mw le io mx ip lh ir my is lk iu mz iv ln na bi translated">用码头工人集装箱化</h1><p id="c670" class="pw-post-body-paragraph ix iy hi iz b ja lp ij jc jd lq im jf jg lr ji jj jk ls jm jn jo lt jq jr js hb bi translated">所以我们现在只需要一个Docker文件来配置我们的容器(假设已经安装了<em class="lu"> Docker </em>)。您可以将以下文件放在项目文件夹的根目录下:</p><figure class="kj kk kl km fd kn"><div class="bz dy l di"><div class="me mf l"/></div></figure><p id="a30c" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这里使用的基本映像是<em class="lu"> python 3.7-slim </em>(基于Debian)。所有运行命令都使用最新的软件包更新基础映像。正如你所看到的，第一批是专门用来在集装箱上安装<em class="lu">流线型</em>的。<em class="lu">docker文件</em>中的两个关键行是从<em class="lu"> requirements.txt </em>文件中复制并安装所有的python库。这意味着容器和本地anaconda环境将使用相同的库版本。要创建这个文件，请在终端中运行(您的anaconda环境<strong class="iz hj">必须</strong>被激活):</p><pre class="kj kk kl km fd lv lw lx ly aw lz bi"><span id="af21" class="ku kv hi lw b fi ma mb l mc md">pip freeze &gt; requirements.txt</span></pre><p id="408e" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">然后，<em class="lu"> COPY </em>行将所有文件和文件夹复制到容器中。最后，CMD行将通过在app.py作业上运行<em class="lu"> streamlit </em>来启动web应用程序。</p><p id="755a" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">好了，现在我们都准备好了。让我们制作这个容器:</p><pre class="kj kk kl km fd lv lw lx ly aw lz bi"><span id="b9fa" class="ku kv hi lw b fi ma mb l mc md">docker build --tag &lt;containername&gt; .</span></pre><p id="ab9d" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这可能需要一点时间，取决于您的连接速度。但是一旦完成，您就可以启动容器了:</p><pre class="kj kk kl km fd lv lw lx ly aw lz bi"><span id="f85d" class="ku kv hi lw b fi ma mb l mc md">docker run  -p 8501:8501 &lt;containername&gt;:latest</span></pre><p id="c671" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">并通过在浏览器中键入<em class="lu"> localhost:8501 </em>来检查您的应用程序。</p><figure class="kj kk kl km fd kn er es paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="er es nb"><img src="../Images/399432394ee99968801adcd8bea31d4f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*r32uAFi7F_MvlwFZG2uJbg.png"/></div></div></figure><p id="a4c0" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">50 = 2500似乎也差不多。</p><p id="82ed" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">现在，我们可以将这个容器注册到任何云供应商，如GCP、Azure、AWS或名为<em class="lu"> streamlit sharing </em>的streamlit own部署，并让全世界都可以访问它。这不包括在这里。</p></div><div class="ab cl mj mk gp ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="hb hc hd he hf"><p id="de1d" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">尽管我们的模型非常简单，但我们得到了一个外观漂亮、功能强大的web应用程序。Jupyter笔记本又一次完全没有被使用。相反，我们使用生产代码和配置文件。</p><p id="9321" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">你可以访问我的GitHub回购中的所有代码:<a class="ae jt" href="https://github.com/GregoireJan/xstreamlit" rel="noopener ugc nofollow" target="_blank">https://github.com/GregoireJan/xstreamlit</a></p><p id="d5a8" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在下一篇文章中，我们将制作我们的第一个机器学习模型及其Flask web应用程序！</p></div><div class="ab cl mj mk gp ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="hb hc hd he hf"><p id="ba0f" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">以下是Jupyter笔记本系列<em class="lu">之外的部分:</em></p><ul class=""><li id="e6d2" class="ju jv hi iz b ja jb jd je jg jw jk jx jo jy js jz ka kb kc bi translated"><a class="ae jt" href="https://gregjan.medium.com/beyond-jupyter-notebooks-11af930c6bf7" rel="noopener">第0部分:建立一个ML项目</a></li><li id="0bc1" class="ju jv hi iz b ja kd jd ke jg kf jk kg jo kh js jz ka kb kc bi translated"><a class="ae jt" href="https://gregjan.medium.com/beyond-jupyter-notebooks-6fd11322d313" rel="noopener">第1部分:使用烧瓶和对接器的非ML模型部署</a></li><li id="ec9d" class="ju jv hi iz b ja kd jd ke jg kf jk kg jo kh js jz ka kb kc bi translated"><a class="ae jt" href="https://gregjan.medium.com/beyond-jupyter-notebooks-63b169c43c44" rel="noopener">第2部分:使用Streamlit和Docker的非ML模型部署</a></li><li id="fb54" class="ju jv hi iz b ja kd jd ke jg kf jk kg jo kh js jz ka kb kc bi translated"><a class="ae jt" href="https://gregjan.medium.com/beyond-jupyter-notebooks-8fc0333517f3" rel="noopener">第3部分:带烧瓶和对接器的ML模型部署</a></li><li id="dc65" class="ju jv hi iz b ja kd jd ke jg kf jk kg jo kh js jz ka kb kc bi translated">第4部分:使用Streamlit和Docker的ML模型部署<em class="lu">(未发布)</em></li></ul></div></div>    
</body>
</html>