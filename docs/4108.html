<html>
<head>
<title>Use Git Bisect to Find the Commit That Introduced a Bug</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用 Git 二分查找引入 Bug 的提交</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/use-git-bisect-to-find-the-commit-that-introduced-a-bug-166e845f3aa4?source=collection_archive---------12-----------------------#2021-07-07">https://medium.com/nerd-for-tech/use-git-bisect-to-find-the-commit-that-introduced-a-bug-166e845f3aa4?source=collection_archive---------12-----------------------#2021-07-07</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/9d9901fe187d86fd721faf0a4bee2422.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4FWII3POtF3KB28JZNov-A.jpeg"/></div></div></figure><p id="5f15" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">作为一名开发人员，你知道这种情况:代码运行得非常好，但突然出现了一个 bug，但你不知道它是何时何地被引入的。</p><p id="68d2" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如果你在一个大的团队中工作，那么很多提交同时被添加的可能性会很高。因此，找到引入 bug 的提交会变得非常困难。</p><p id="807a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">幸运的是，<a class="ae jo" href="https://git-scm.com/" rel="noopener ugc nofollow" target="_blank"> Git </a>提供了一个工具来帮助检测引入 bug 的第一个错误提交。叫做“git 平分”。</p><h1 id="d7e2" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">它是如何工作的？</h1><p id="c973" class="pw-post-body-paragraph iq ir hi is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hb bi translated">我们需要提供 Git 平分两个信息以便能够识别</p><ol class=""><li id="80f5" class="ks kt hi is b it iu ix iy jb ku jf kv jj kw jn kx ky kz la bi translated">bug <strong class="is hj">不存在的“好”提交。</strong></li><li id="a281" class="ks kt hi is b it lb ix lc jb ld jf le jj lf jn kx ky kz la bi translated">一个“坏的”提交，其中存在 bug<strong class="is hj"/>。</li></ol><p id="a7b6" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这样 Git“知道”bug 必须在“好的”和“坏的”提交之间转换。启动二等分过程会将提交范围分为“好”和“坏”提交，并检查中间的提交:</p><figure class="lh li lj lk fd ij er es paragraph-image"><div class="er es lg"><img src="../Images/3eb05c19dd6857f932925a398ace2999.png" data-original-src="https://miro.medium.com/v2/resize:fit:1380/format:webp/0*2qf3HutkczDU8RP1.jpg"/></div></figure><p id="209b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们现在的任务是在提交时验证代码。这可以通过编译、运行应用程序或启动针对给定 bug 的测试用例来完成。接下来，我们需要告诉 Git 测试是“好”还是“坏”。Git 将简单地重复这个过程，直到我们挑出包含 bug 的提交。</p><p id="27f0" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">使用的算法叫做<a class="ae jo" href="https://en.wikipedia.org/wiki/Binary_search_algorithm" rel="noopener ugc nofollow" target="_blank">二分搜索法</a>。</p><figure class="lh li lj lk fd ij er es paragraph-image"><div class="er es lg"><img src="../Images/0983ec976e0be626339e313b3a8b03fa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1380/format:webp/0*gNJx4Qwf8w_qrDKA.jpg"/></div></figure><h1 id="18e9" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">实际例子</h1><p id="3ea5" class="pw-post-body-paragraph iq ir hi is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hb bi translated">让我们看看如何从命令行运行 Git 二等分。首先，我们需要开始这个过程:</p><pre class="lh li lj lk fd ll lm ln lo aw lp bi"><span id="2fe7" class="lq jq hi lm b fi lr ls l lt lu">$ git bisect start</span></pre><p id="2a5c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">下一步是为 Git 提供“好”和“坏”提交。“坏的”提交通常是指“头”的当前状态:</p><pre class="lh li lj lk fd ll lm ln lo aw lp bi"><span id="73df" class="lq jq hi lm b fi lr ls l lt lu">$ git bisect bad HEAD</span></pre><p id="2672" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">为了能够找到“好的”提交，你需要检查任何旧的版本，在那里你非常确定错误不存在。在您检查它并确认那里不存在 bug 之后，我们向 Git 提供相应的提交散列:</p><pre class="lh li lj lk fd ll lm ln lo aw lp bi"><span id="7016" class="lq jq hi lm b fi lr ls l lt lu">$ git bisect good acd72832</span></pre><p id="52fa" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在我们准备开始“平分”过程。Git 将检查我们提供的“好的”和“坏的”提交范围中间的一个提交:</p><pre class="lh li lj lk fd ll lm ln lo aw lp bi"><span id="8303" class="lq jq hi lm b fi lr ls l lt lu">Bisecting: 6 revisions left to test after this (roughly 2 step)<br/>[commit_ABC] Added controller</span></pre><p id="ec4f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">此时，我们需要验证 bug 是否仍然存在。如果它仍然存在，我们需要运行</p><pre class="lh li lj lk fd ll lm ln lo aw lp bi"><span id="7242" class="lq jq hi lm b fi lr ls l lt lu">$ git bisect bad</span></pre><p id="f119" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">否则我们就跑</p><pre class="lh li lj lk fd ll lm ln lo aw lp bi"><span id="b337" class="lq jq hi lm b fi lr ls l lt lu">$ git bisect good</span></pre><p id="b6a8" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">将其标记为“好”。</p><p id="ce32" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">根据结果，Git 将再次分割原始提交范围并选择前半部分或后半部分。它将再次检查中间的提交，我们需要验证那里是否存在 bug。</p><p id="b025" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这个过程一直重复，直到我们成功地挑出错误的提交！</p><p id="9a01" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">一旦我们找到了罪魁祸首，我们可以通过运行以下命令来结束平分过程:</p><pre class="lh li lj lk fd ll lm ln lo aw lp bi"><span id="8638" class="lq jq hi lm b fi lr ls l lt lu">$ git bisect reset</span></pre><p id="5410" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">然后 Git 将完成这个二分过程，并把我们带回到之前的 HEAD 版本。</p><h1 id="4b27" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">结论</h1><p id="b076" class="pw-post-body-paragraph iq ir hi is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hb bi translated">Git 二等分是追踪 bug 的有用工具。我只在完全不知道 bug 是从哪里引入的，并且需要搜索大量可能不相关的变更时使用<code class="du lv lw lx lm b">git bisect</code>。</p><p id="0079" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">想了解更多关于 Git 平分的信息，请看一下官方文件。</p><p id="7fcb" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如果你喜欢这篇文章，请在<a class="ae jo" href="https://twitter.com/mokkapps" rel="noopener ugc nofollow" target="_blank"> Twitter </a>上关注我，从我这里获得关于新博客文章和更多内容的通知。</p></div><div class="ab cl ly lz gp ma" role="separator"><span class="mb bw bk mc md me"/><span class="mb bw bk mc md me"/><span class="mb bw bk mc md"/></div><div class="hb hc hd he hf"><p id="eb49" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><em class="mf">原发布于</em><a class="ae jo" href="https://www.mokkapps.de/blog/use-git-bisect-to-find-the-commit-that-introduced-a-bug" rel="noopener ugc nofollow" target="_blank"><em class="mf">https://www . mokkapps . de</em></a><em class="mf">。</em></p></div></div>    
</body>
</html>