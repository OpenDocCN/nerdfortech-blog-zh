<html>
<head>
<title>Sorting Algorithms 101: Merge Sort</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">排序算法101:合并排序</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/sorting-algorithms-101-merge-sort-d28e98a4080?source=collection_archive---------12-----------------------#2021-07-20">https://medium.com/nerd-for-tech/sorting-algorithms-101-merge-sort-d28e98a4080?source=collection_archive---------12-----------------------#2021-07-20</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/6ca6276fa679c4710d274a01fbaa0f4a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Y2kIZsWbPL4-oI3n"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">由<a class="ae iu" href="https://unsplash.com/@jerrykavan?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">雅罗米尔·卡万</a>在<a class="ae iu" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄的照片</figcaption></figure><p id="bf98" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">欢迎回来！今天，我带着我的五部分系列中的第四个排序算法回来了。我们之前介绍过，<a class="ae iu" rel="noopener" href="/codex/sorting-algorithms-101-bubble-sort-cfc7df8fb6aa">冒泡排序</a>，<a class="ae iu" rel="noopener" href="/@freda.hon/sorting-algorithms-101-selection-sort-778c201e330a">选择排序</a>，以及<a class="ae iu" rel="noopener" href="/geekculture/sorting-algorithms-101-insertion-sort-ee585f6a62cf">插入排序</a>。</p><p id="35bb" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">让我们简单回顾一下前三个，然后直接进入归并排序。</p><ol class=""><li id="67b5" class="jt ju hi ix b iy iz jc jd jg jv jk jw jo jx js jy jz ka kb bi translated">冒泡排序在其迭代中找到最大的<em class="kc">未排序数，并将其移动到数组的末尾</em></li><li id="c2bb" class="jt ju hi ix b iy kd jc ke jg kf jk kg jo kh js jy jz ka kb bi translated">选择排序在其迭代中找到最小的<em class="kc">未排序数，并将其移动到数组的开头</em></li><li id="5487" class="jt ju hi ix b iy kd jc ke jg kf jk kg jo kh js jy jz ka kb bi translated">插入排序使用一个键，并将其与该键左侧的数字进行比较。如果键左边的数字小于键上的数字，则发生交换。</li></ol><p id="be43" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">为了继续今天的合并排序，您需要对递归有一个基本的理解。如果你对它不熟悉，我做了一个快速的帖子，在这里<a class="ae iu" rel="noopener" href="/codex/a-quick-guide-to-recursion-b84fdaf6986d"/>，让你快速了解。</p><p id="588c" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">没错。现在我们已经准备好了，让我们进入合并排序！</p><h1 id="85bb" class="ki kj hi bd kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf bi translated">合并排序:工作原理</h1><p id="51ba" class="pw-post-body-paragraph iv iw hi ix b iy lg ja jb jc lh je jf jg li ji jj jk lj jm jn jo lk jq jr js hb bi translated">合并排序通过分而治之来实现。该算法将数组分成两半，调用它自己(使用递归)，并继续这个划分过程，直到每个元素都是它自己的数组。想象一棵树在每次分裂时被制作，每个分支由一个新分裂的列表组成。当单个元素在其自己的列表中时，到达<em class="kc">基本情况</em>。</p><p id="d39a" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在这一点上，该算法然后开始在排序时沿树向上移动，并且<em class="kc">将这些单个元素合并</em>回到一个<em class="kc">新的</em>排序数组中。</p><p id="2c1d" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">让我们使用下面的数组来形象化地展示这一点:</p><pre class="ll lm ln lo fd lp lq lr ls aw lt bi"><span id="d1d5" class="lu kj hi lq b fi lv lw l lx ly">list = [ 4, 7, 1, 6, 10, 8, 3, 9, 7, 5, 2 ]<br/>sorted_array = []</span></pre><p id="937e" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">顾名思义，<code class="du lz ma mb lq b">sorted_array</code>将是一个列表，当我们沿着树向上工作并进行排序时，我们会将数字添加到这个列表中。它将在我们的排序算法中定义和创建。</p><p id="46ef" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">该算法首先将该列表分成两半，然后再分成两半，再分成两半，直到达到基本情况:</p><figure class="ll lm ln lo fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mc"><img src="../Images/5cd53eb9a46a9ffda49e7f4143923829.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ar1hxgE0DNrpQYe8ROBqUA.jpeg"/></div></div></figure><p id="2412" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">一下子涵盖所有内容有点混乱，所以我将只着重解释树的左侧。具体来说，左边列表:<code class="du lz ma mb lq b">[4, 7, 1, 6, 10, 8]</code>。之后，您可以轻松地对正确的列表应用相同的步骤。请记住，该算法将同时在左侧和右侧工作——从上到下工作(基本情况),然后再次返回<em class="kc">到</em>。</p><p id="4e3b" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">现在让我们来看看左边列表的最左边部分:</p><figure class="ll lm ln lo fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mc"><img src="../Images/6a825a6fc2cb0540a71d4cae21b956e1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yc4jTSvbmSMjFjx3gcnXsA.jpeg"/></div></div></figure><p id="f9b5" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">当每个分割列表的左半部分变成单个元素时，就达到了基本情况，并且该单个元素被返回给调用它的人。如果你对前一步如何“调用”它有点困惑，请记住算法中的<em class="kc">递归</em>性质。</p><p id="ad0b" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">让我们回到上面的例子。原始数组一直向下拆分到[4]。由于[4]是单个元素，不能再拆分，因此到达基本情况，并且[4]返回到上一步[4，7]。</p><p id="e113" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们现在正在努力。因此，我们现在处于最低水平。由于[7]不能进一步拆分，所以它是基本情况，也返回到[4，7]。</p><p id="2c94" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在基本案例返回到上一步之后，将左边列表的第一个元素[4]与右边列表的第一个元素[7]进行比较。两者中较小的一个将首先被追加到新的<code class="du lz ma mb lq b">sorted_array</code>中，随后是较大的数字。这将导致<code class="du lz ma mb lq b">sorted_array = [4, 7]</code>，然后将返回到前面的步骤【4，7，1】。</p><p id="13fc" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">到目前为止，我们已经做了很多，让我们来看另一个画面:</p><figure class="ll lm ln lo fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mc"><img src="../Images/3cfa0f1dad723e1f8de31e11217db8ad.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2B81k2U1iC-2BAXf5OaDKg.jpeg"/></div></div></figure><p id="5b9b" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">当我们从下往上工作时，我们有[1]下一步。[1]是基例，所以返回到[4，7，1]。然后将这两个列表相互比较。</p><pre class="ll lm ln lo fd lp lq lr ls aw lt bi"><span id="c873" class="lu kj hi lq b fi lv lw l lx ly">to sort: [4, 7] [1]</span></pre><p id="27b2" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">[4]与第二个列表的第一个元素[1]相比较。因为[1]更小，所以它被追加到一个新的<code class="du lz ma mb lq b">sorted_array</code>中，并且因为[4，7]已经被排序，我们简单地把它追加到[1]后面。现在[1，4，7]已经排序了，它被返回给调用它的人。* *请注意:每次都会创建一个新的<code class="du lz ma mb lq b">sorted_array</code>，因为我们的合并算法被递归调用。</p><figure class="ll lm ln lo fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mc"><img src="../Images/56b9a80f384eddeb2b3560775c5f1b64.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*22E7Ze2sSZsJgyaOHZk-9w.jpeg"/></div></div></figure><p id="a535" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">接下来，[6，10，8]将经历完全相同的过程，返回[6，8，10]的sorted_array:</p><figure class="ll lm ln lo fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es md"><img src="../Images/e58760b9dc5c1b6366705612074be507.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*a6rar7pDsMcEFVkKX9_jAA.jpeg"/></div></div></figure><p id="2320" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">同样，第一个数组的第一个元素将与第二个数组的第一个元素进行比较。由于1小于6，所以1将被追加到新的<code class="du lz ma mb lq b">sorted_array</code>中。然后将第一个数组的下一个元素与第二个元素进行比较。4小于6，也追加到1后面的<code class="du lz ma mb lq b">sorted_array</code>中。然后将7与6进行比较。因为6比7小，所以6被附加在4后面……我相信你已经明白了其中的要点。最终，[1，4，6，7，8，10]的<code class="du lz ma mb lq b">sorted_array</code>将返回到调用它的原始数组，在那里它将与树右侧的排序数组进行比较。</p><figure class="ll lm ln lo fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es md"><img src="../Images/128c4ad824f21f6d94bdc42516475b2b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kvPtZuiz0bVRDG-AcctrEw.jpeg"/></div></div></figure><p id="e8eb" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">应用与上面相同的比较和排序逻辑，当一个完全排序的列表返回:[1，2，3，4，5，6，7，7，8，9，10]时，我们的排序算法将最终停止。</p><h1 id="4aa0" class="ki kj hi bd kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf bi translated">算法</h1><p id="656e" class="pw-post-body-paragraph iv iw hi ix b iy lg ja jb jc lh je jf jg li ji jj jk lj jm jn jo lk jq jr js hb bi translated">像往常一样，我将在下面使用Python，但是请随意使用您选择的语言。</p><p id="8d02" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们将使用两个独立的函数来组成算法:1)设置基本情况并处理数组划分，2)处理排序和合并。</p><p id="f3e8" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">让我们从前者开始，定义我们的基本情况:</p><pre class="ll lm ln lo fd lp lq lr ls aw lt bi"><span id="3094" class="lu kj hi lq b fi lv lw l lx ly">def divide_arr(arr):<br/>    if len(arr) &lt; 2:<br/>        return arr[:]</span></pre><p id="0a45" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><em class="kc"> **注意:</em> <code class="du lz ma mb lq b"><em class="kc">[:]</em></code> <em class="kc">创建数组的浅层副本。</em></p><p id="eb34" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">现在，让我们在此<em class="kc"> if </em>语句中添加第二部分，以指示部门是否未满足基本情况:</p><pre class="ll lm ln lo fd lp lq lr ls aw lt bi"><span id="44b1" class="lu kj hi lq b fi lv lw l lx ly">def divide_arr(arr):<br/>    if len(arr) &lt; 2:<br/>        return arr[:]<br/>    else:<br/>        middle = len(arr)//2<br/>        list1 = divide_arr(arr[:middle])<br/>        list2 = divide_arr(arr[middle:])<br/>        return merge_sort(list1, list2)</span></pre><p id="35bd" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><code class="du lz ma mb lq b">middle</code>，是中间的数字。它得到数组除以2的长度，并将用作索引来帮助将数组一分为二。<code class="du lz ma mb lq b">list1</code>表示中间数字左边的元素，而<code class="du lz ma mb lq b">list2</code>表示右边的元素。</p><p id="1c4c" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">注意，我们调用的是<code class="du lz ma mb lq b">divide_arr</code>本身。这个递归调用将导致每个数组继续分成两半。同时，我们将两个列表作为参数插入到合并函数中。</p><p id="4941" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">对于<code class="du lz ma mb lq b">merge_sort</code>函数，我们将首先创建新的数组，这样所有排序后的数字都可以追加到其中。我们还将定义另外两个变量，代表我们要比较的两个数组的索引。索引将用于帮助我们在比较过程中遍历每个数组。为了简单起见，我将使用<code class="du lz ma mb lq b">i</code>和<code class="du lz ma mb lq b">j</code>。</p><pre class="ll lm ln lo fd lp lq lr ls aw lt bi"><span id="a302" class="lu kj hi lq b fi lv lw l lx ly">def merge_sort(arr1, arr2):<br/>    sorted_arr = []<br/>    i, j = 0, 0</span></pre><p id="00ab" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">为了建立我们的比较，我们将使用一个<em class="kc">if</em>-语句。</p><p id="8327" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们知道，如果数组1中的元素小于数组2中的元素，我们希望将数组1中的元素添加到排序后的数组中。否则，如果数组2的第一个元素小于数组1的第一个元素，则追加数组2的元素。所以让我们把这个包括进来:</p><pre class="ll lm ln lo fd lp lq lr ls aw lt bi"><span id="61e4" class="lu kj hi lq b fi lv lw l lx ly">def merge_sort(arr1, arr2):<br/>    sorted_arr = []<br/>    i, j = 0, 0</span><span id="9acb" class="lu kj hi lq b fi me lw l lx ly">    if arr1[i] &lt; arr2[j]:<br/>        sorted_arr.append(arr1[i])<br/>    else:<br/>        sorted_arr.append(arr2[j])</span></pre><p id="c72f" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">很好，但是因为我们需要遍历每个数组来比较每个元素，所以我们应该添加一行代码，在追加数组中的一个元素后，该代码将索引递增1:</p><pre class="ll lm ln lo fd lp lq lr ls aw lt bi"><span id="8c3c" class="lu kj hi lq b fi lv lw l lx ly">def merge_sort(arr1, arr2):<br/>    sorted_arr = []<br/>    i, j = 0, 0        </span><span id="d614" class="lu kj hi lq b fi me lw l lx ly">    if arr1[i] &lt; arr2[j]:<br/>        sorted_arr.append(arr1[i])<br/>        i += 1<br/>    else:<br/>        sorted_arr.append(arr2[j])<br/>        j += 1</span></pre><p id="d9b7" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在这个阶段，指数只会向上移动1，一次。为了让它遍历数组，我们必须抛出一个<em class="kc"> while </em> -loop:</p><pre class="ll lm ln lo fd lp lq lr ls aw lt bi"><span id="8a9b" class="lu kj hi lq b fi lv lw l lx ly">def merge_sort(arr1, arr2):<br/>    sorted_arr = []<br/>    i, j = 0, 0</span><span id="758a" class="lu kj hi lq b fi me lw l lx ly">    while i &lt; len(arr1) and j &lt; len(arr2):<br/>        if arr1[i] &lt; arr2[j]:<br/>            sorted_arr.append(arr1[i])<br/>            i += 1<br/>        else:<br/>            sorted_arr.append(arr2[j])<br/>            j += 1</span></pre><p id="e301" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">太棒了，好多了——但是我们还没有完成。</p><p id="20a4" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">现在，使用上面的<em class="kc">while</em>-语句，迭代和比较将一直运行，直到到达任一数组的末尾。这意味着，如果一个数组的长度比另一个长，循环将在所有元素完全排序之前提前结束。</p><p id="cd32" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">为了解决这个问题，我们需要合并另外两个<em class="kc">while</em>-语句，以确保迭代在两个数组的长度上继续。</p><pre class="ll lm ln lo fd lp lq lr ls aw lt bi"><span id="7164" class="lu kj hi lq b fi lv lw l lx ly">def merge_sort(arr1, arr2):<br/>    sorted_arr = []<br/>    i, j = 0, 0</span><span id="1f7d" class="lu kj hi lq b fi me lw l lx ly">    while i &lt; len(arr1) and j &lt; len(arr2):<br/>        if arr1[i] &lt; arr2[j]:<br/>            sorted_arr.append(arr1[i])<br/>            i += 1<br/>        else:<br/>            sorted_arr.append(arr2[j])<br/>            j += 1<br/>    <br/>    while i &lt; len(arr1):<br/>        sorted_arr.append(arr1[i])<br/>        i += 1<br/>    <br/>    while j &lt; len(arr2):<br/>        sorted_arr.append(arr2[j])<br/>        j += 1<br/>    <br/>    return sorted_arr</span></pre><p id="1dd1" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">现在让我们把所有的<em class="kc">放在一起:</em></p><pre class="ll lm ln lo fd lp lq lr ls aw lt bi"><span id="fd49" class="lu kj hi lq b fi lv lw l lx ly">def divide_arr(arr):<br/>    if len(arr) &lt; 2:<br/>        return arr[:]<br/>    else:<br/>        middle = len(arr)//2<br/>        list1 = divide_arr(arr[:middle])<br/>        list2 = divide_arr(arr[middle:])<br/>        return merge_sort(list1, list2)</span><span id="13ab" class="lu kj hi lq b fi me lw l lx ly">def merge_sort(arr1, arr2):<br/>    sorted_arr = []<br/>    i, j = 0, 0</span><span id="85d1" class="lu kj hi lq b fi me lw l lx ly">    while i &lt; len(arr1) and j &lt; len(arr2):<br/>        if arr1[i] &lt; arr2[j]:<br/>            sorted_arr.append(arr1[i])<br/>            i += 1<br/>        else:<br/>            sorted_arr.append(arr2[j])<br/>            j += 1<br/>    <br/>    while i &lt; len(arr1):<br/>        sorted_arr.append(arr1[i])<br/>        i += 1<br/>    <br/>    while j &lt; len(arr2):<br/>        sorted_arr.append(arr2[j])<br/>        j += 1<br/>    <br/>    return sorted_arr</span><span id="61b2" class="lu kj hi lq b fi me lw l lx ly">list = [ 4, 7, 1, 6, 10, 8, 3, 9, 7, 5, 2 ]<br/>print (divide_arr(list))</span></pre><h1 id="9154" class="ki kj hi bd kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf bi translated">时间复杂度</h1><p id="b76e" class="pw-post-body-paragraph iv iw hi ix b iy lg ja jb jc lh je jf jg li ji jj jk lj jm jn jo lk jq jr js hb bi translated">树中的每个级别或步骤代表(n)个操作，因此在<em class="kc">每个步骤</em>的时间复杂度为O(n)。</p><p id="76d3" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">因为我们在每一步都将我们的列表分成两部分以产生(n)个列表，所以这等同于log(n) <em class="kc">总步骤</em>。</p><p id="0d9e" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">把<em class="kc">的每一步</em>和<em class="kc">的总步数</em>放在一起，我们得到(n×log(n))，一个时间复杂度为<strong class="ix hj"> O(nlog(n)) </strong>。</p></div><div class="ab cl mf mg gp mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="hb hc hd he hf"><p id="b790" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">哇，我们做到了。如果你跟随我经历了这一切，那么你应该受到热烈的欢呼！</p><p id="559c" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">现在我们已经完成了合并排序，这是我的五部分系列的最后一个排序算法…接下来，快速排序！下次见。</p></div></div>    
</body>
</html>