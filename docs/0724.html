<html>
<head>
<title>Implementing a Rock-Paper-Scissors game using Event Sourcing</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用事件源实现石头剪子布游戏</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/implementing-a-rock-paper-scissors-game-using-event-sourcing-35f772cbcaa?source=collection_archive---------5-----------------------#2021-02-08">https://medium.com/nerd-for-tech/implementing-a-rock-paper-scissors-game-using-event-sourcing-35f772cbcaa?source=collection_archive---------5-----------------------#2021-02-08</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="a5d1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在本教程中，我们将了解如何使用针对事件源和CQRS的<a class="ae jd" href="https://serialized.io" rel="noopener ugc nofollow" target="_blank">序列化的</a>API来设计石头剪子布游戏的游戏流程。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es je"><img src="../Images/c6b92b39bb297f31ed3e0a3fc3f0831a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TFpT1nzx8yl250CtPXHg9w.jpeg"/></div></div></figure><p id="6a11" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们最喜欢的应用程序运行时环境通常是<a class="ae jd" href="https://www.dropwizard.io/" rel="noopener ugc nofollow" target="_blank"> Dropwizard </a>，但是因为很多人更喜欢<a class="ae jd" href="https://spring.io/projects/spring-boot" rel="noopener ugc nofollow" target="_blank"> Spring Boot </a>，所以我决定在本文中使用它。我们的<a class="ae jd" href="https://github.com/serialized-io/client-java" rel="noopener ugc nofollow" target="_blank"> Java客户端</a>可以与您在JVM上使用的任何运行时环境或平台一起工作。</p><h1 id="92e5" class="jq jr hi bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">配置序列化项目</h1><p id="8e7e" class="pw-post-body-paragraph if ig hi ih b ii ko ik il im kp io ip iq kq is it iu kr iw ix iy ks ja jb jc hb bi translated">为了开发我们的游戏，我们将使用连续聚合和投影。聚合将存储每场比赛的事件，投影将提供每场比赛的视图以及最高赢家的高分列表(在运行多个比赛的情况下)。</p><p id="898d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果你还没有注册连载，你需要<a class="ae jd" href="https://app.serialized.io/" rel="noopener ugc nofollow" target="_blank">注册一个免费的开发者账户</a>。一旦您注册并创建了您的第一个项目，您将看到一个聚集的空视图，如下所示:</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es kt"><img src="../Images/a51925ff2944b6f39afcd03513b6cf8e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PQUzBYs5kFM-cd-VfbEo4g.jpeg"/></div></div></figure><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es kt"><img src="../Images/0b18c15580b0aeb352d5d2e77218529e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*j2J8BZs-OIfduGtWFrR6Ug.jpeg"/></div></div></figure><p id="172e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">将访问密钥和秘密访问密钥复制到安全的位置。我们将需要这些来从我们的后端应用程序访问序列化的API。</p><p id="cc64" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">干得好！我们现在有一个空的序列化项目。我们现在准备开始开发我们的游戏！</p><h1 id="d0a2" class="jq jr hi bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">游戏的设置和概要</h1><p id="bb49" class="pw-post-body-paragraph if ig hi ih b ii ko ik il im kp io ip iq kq is it iu kr iw ix iy ks ja jb jc hb bi translated">在这一节中，我们将描述游戏的基本功能以及开发整个游戏流程所需要实现的部分。</p><h1 id="8d3f" class="jq jr hi bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">游戏规则</h1><p id="0b36" class="pw-post-body-paragraph if ig hi ih b ii ko ik il im kp io ip iq kq is it iu kr iw ix iy ks ja jb jc hb bi translated">游戏的核心是游戏规则。如果你对游戏的历史感兴趣，你可以在维基百科上了解更多。</p><p id="ef3a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这是游戏规则的简要总结:</p><ul class=""><li id="25b9" class="ku kv hi ih b ii ij im in iq kw iu kx iy ky jc kz la lb lc bi translated">这个游戏是由两个人玩的。</li><li id="0e90" class="ku kv hi ih b ii ld im le iq lf iu lg iy lh jc kz la lb lc bi translated">一轮游戏包括双方亮出他们的手牌(石头/布/剪刀)。</li><li id="3a8c" class="ku kv hi ih b ii ld im le iq lf iu lg iy lh jc kz la lb lc bi translated">每一轮结束时，双方球员已经表明他们的手，有一个赢家。</li><li id="6376" class="ku kv hi ih b ii ld im le iq lf iu lg iy lh jc kz la lb lc bi translated">如果一轮打成平手(显示的是同一手牌)，该轮将再次进行。</li><li id="ad96" class="ku kv hi ih b ii ld im le iq lf iu lg iy lh jc kz la lb lc bi translated">纸打败了石头。</li><li id="3db3" class="ku kv hi ih b ii ld im le iq lf iu lg iy lh jc kz la lb lc bi translated">石头打败剪刀。</li><li id="efc2" class="ku kv hi ih b ii ld im le iq lf iu lg iy lh jc kz la lb lc bi translated">剪刀胜过布。</li><li id="bb42" class="ku kv hi ih b ii ld im le iq lf iu lg iy lh jc kz la lb lc bi translated">一场游戏最好是3回合——当一个玩家赢了2回合就结束了。</li></ul><h1 id="4f51" class="jq jr hi bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">游戏模型</h1><p id="5190" class="pw-post-body-paragraph if ig hi ih b ii ko ik il im kp io ip iq kq is it iu kr iw ix iy ks ja jb jc hb bi translated">我们将使用<em class="li">命令</em>和<em class="li">事件</em>来设计我们的游戏。命令是游戏支持的动作，事件是作为这些命令的结果发出的<a class="ae jd" href="https://serialized.io/ddd/domain-event" rel="noopener ugc nofollow" target="_blank">域事件</a>。</p><h1 id="211b" class="jq jr hi bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">命令</h1><p id="f181" class="pw-post-body-paragraph if ig hi ih b ii ko ik il im kp io ip iq kq is it iu kr iw ix iy ks ja jb jc hb bi translated">鉴于我们简单的游戏规则，我们只能执行两个操作:</p><ul class=""><li id="8955" class="ku kv hi ih b ii ij im in iq kw iu kx iy ky jc kz la lb lc bi translated">当我们决定开始两人游戏时，将会发送。</li><li id="2119" class="ku kv hi ih b ii ld im le iq lf iu lg iy lh jc kz la lb lc bi translated"><code class="du lj lk ll lm b"><strong class="ih hj">ShowHand</strong></code>每当玩家摊牌时都会发送。</li></ul><p id="9ff8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">注意</strong>:由于当最后一手牌出现时游戏自动结束，并且我们有一个赢家，这不是作为一个命令，而是作为一个事件。</p><p id="3d2f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">用命令和事件设计游戏的一个有趣的结果是，我们可以清楚地看到不同命令和事件的数量之间的差异。</p><h1 id="9ea0" class="jq jr hi bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">事件</h1><p id="1930" class="pw-post-body-paragraph if ig hi ih b ii ko ik il im kp io ip iq kq is it iu kr iw ix iy ks ja jb jc hb bi translated">下面是我们的<code class="du lj lk ll lm b"><strong class="ih hj">Game</strong></code>聚合发出的事件描述，作为成功处理命令的结果:</p><ul class=""><li id="cb0a" class="ku kv hi ih b ii ij im in iq kw iu kx iy ky jc kz la lb lc bi translated"><code class="du lj lk ll lm b"><strong class="ih hj">GameStarted</strong></code>将作为<code class="du lj lk ll lm b"><strong class="ih hj">start-game</strong></code>命令的结果被保存。</li><li id="f5e8" class="ku kv hi ih b ii ld im le iq lf iu lg iy lh jc kz la lb lc bi translated"><code class="du lj lk ll lm b"><strong class="ih hj">RoundStarted</strong></code>将与第一轮的<code class="du lj lk ll lm b"><strong class="ih hj">GameStarted</strong></code>一起保存，并在双方玩家都回答后隐含地保存到下一轮。</li><li id="27b6" class="ku kv hi ih b ii ld im le iq lf iu lg iy lh jc kz la lb lc bi translated">当玩家亮出一手牌时,<code class="du lj lk ll lm b"><strong class="ih hj">PlayerAnswered</strong></code>将被保存。</li><li id="d9ac" class="ku kv hi ih b ii ld im le iq lf iu lg iy lh jc kz la lb lc bi translated"><code class="du lj lk ll lm b"><strong class="ih hj">RoundTied</strong></code>当两个玩家都亮出了手牌，并且他们亮出了相同的标志时，将被保存。</li><li id="70b2" class="ku kv hi ih b ii ld im le iq lf iu lg iy lh jc kz la lb lc bi translated">当两个玩家都亮出手牌时，将被保存</li><li id="de66" class="ku kv hi ih b ii ld im le iq lf iu lg iy lh jc kz la lb lc bi translated"><code class="du lj lk ll lm b"><strong class="ih hj">GameFinished</strong></code>当我们有一个赢家(一个玩家赢了2个或更多回合)时将被保存。</li></ul><h1 id="8045" class="jq jr hi bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">问题</h1><p id="fe97" class="pw-post-body-paragraph if ig hi ih b ii ko ik il im kp io ip iq kq is it iu kr iw ix iy ks ja jb jc hb bi translated">我们还将实现一些查询来显示序列化的<strong class="ih hj">投影</strong>支持。投影帮助我们计算可查询的模型，这些模型是聚集中保存的大量事件的结果。我们将支持的游戏查询如下:</p><ul class=""><li id="0d5e" class="ku kv hi ih b ii ij im in iq kw iu kx iy ky jc kz la lb lc bi translated">游戏状态—游戏的当前状态(包括已经进行的回合)。</li><li id="b30c" class="ku kv hi ih b ii ld im le iq lf iu lg iy lh jc kz la lb lc bi translated">高分(列表中每个玩家的获胜次数)。</li><li id="708c" class="ku kv hi ih b ii ld im le iq lf iu lg iy lh jc kz la lb lc bi translated">游戏总数。</li></ul><h1 id="a223" class="jq jr hi bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">实现游戏</h1><p id="5ec5" class="pw-post-body-paragraph if ig hi ih b ii ko ik il im kp io ip iq kq is it iu kr iw ix iy ks ja jb jc hb bi translated">让我们深入研究一下我们游戏的实现吧！</p><h1 id="dbfc" class="jq jr hi bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">应用程序配置</h1><p id="e2e5" class="pw-post-body-paragraph if ig hi ih b ii ko ik il im kp io ip iq kq is it iu kr iw ix iy ks ja jb jc hb bi translated">如果你不熟悉我们的Java客户端，你可以<a class="ae jd" href="https://serialized.io/java/get-started/" rel="noopener ugc nofollow" target="_blank">在这里</a>阅读更多关于基础知识的内容。</p><p id="b336" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">首先，我们必须配置序列化客户端。在我们的<code class="du lj lk ll lm b"><strong class="ih hj">AppConfig</strong></code>类中，我们为聚合客户端创建了一个可注入bean，我们将使用它将事件存储到序列化。我们使用一个<code class="du lj lk ll lm b"><strong class="ih hj">GameState</strong></code>类来管理任何先前存储的事件的状态的具体化，并在这个类中为我们在建模会话中设计的每个事件类型分别注册处理程序方法。</p><pre class="jf jg jh ji fd ln lm lo lp aw lq bi"><span id="f81c" class="lr jr hi lm b fi ls lt l lu lv"><strong class="lm hj">@Configuration<br/>public class AppConfig {<br/>  <br/>  @Autowired<br/>  public AppConfig(Environment env) {<br/>    this.env = env;<br/>  }<br/><br/>  ...<br/>  <br/>  @Bean<br/>  public AggregateClient&lt;GameState&gt; gameClient() {<br/>    return AggregateClient.aggregateClient(GAME_AGGREGATE_TYPE, GameState.class, getConfig())<br/>      .registerHandler(GameStarted.class, GameState::handleGameStarted)<br/>      .registerHandler(PlayerWonRound.class, GameState::handlePlayerWonRound)<br/>      .registerHandler(GameFinished.class, GameState::handleGameFinished)<br/>      .registerHandler(PlayerAnswered.class, GameState::handlePlayerAnswered)<br/>      .registerHandler(RoundStarted.class, GameState::handleRoundStarted)<br/>      .registerHandler(RoundFinished.class, GameState::handleRoundFinished)<br/>      .registerHandler(RoundTied.class, GameState::handleRoundTied)<br/>      .build();<br/>  }<br/><br/>  private SerializedClientConfig getConfig() {<br/>    return SerializedClientConfig.serializedConfig()<br/>      .accessKey(env.getProperty("SERIALIZED_ACCESS_KEY"))<br/>      .secretAccessKey(env.getProperty("SERIALIZED_SECRET_ACCESS_KEY"))<br/>      .build();<br/>  }<br/>  <br/>}</strong></span></pre><h1 id="0ab1" class="jq jr hi bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">游戏逻辑</h1><p id="887f" class="pw-post-body-paragraph if ig hi ih b ii ko ik il im kp io ip iq kq is it iu kr iw ix iy ks ja jb jc hb bi translated"><code class="du lj lk ll lm b"><strong class="ih hj">GameState</strong></code>类包含我们的<code class="du lj lk ll lm b"><strong class="ih hj">Game</strong></code>集合的状态。当一个新的命令(<code class="du lj lk ll lm b"><strong class="ih hj">ShowHand</strong></code>)被发送到<code class="du lj lk ll lm b"><strong class="ih hj">Game</strong></code>集合时，我们将首先加载一个<code class="du lj lk ll lm b"><strong class="ih hj">GameState</strong></code>的实例，该实例基于之前保存在游戏中的所有<strong class="ih hj">事件</strong>。</p><pre class="jf jg jh ji fd ln lm lo lp aw lq bi"><span id="9ec3" class="lr jr hi lm b fi ls lt l lu lv"><strong class="lm hj">/**<br/> * The transient state of a game, built up from events<br/> */<br/>public class GameState {<br/><br/>  private final Set&lt;Player&gt; registeredPlayers = new LinkedHashSet&lt;&gt;();<br/>  private final Set&lt;PlayerHand&gt; shownHands = new HashSet&lt;&gt;();<br/>  private final Map&lt;Player, Long&gt; wins = new HashMap&lt;&gt;();<br/><br/>  private GameStatus gameStatus = GameStatus.NEW;<br/><br/>  public static GameState newGame() {<br/>    return new GameState();<br/>  }<br/><br/>  public GameState handleGameStarted(Event&lt;GameStarted&gt; event) {<br/>    gameStatus = GameStatus.STARTED;<br/>    registeredPlayers.addAll(event.data().players.stream().map(Player::fromString).collect(toSet()));<br/>    return this;<br/>  }<br/><br/>  public GameState handlePlayerWonRound(Event&lt;PlayerWonRound&gt; event) {<br/>    Player winner = Player.fromString(event.data().winner);<br/>    long numberOfWins = wins.getOrDefault(winner, 0L);<br/>    wins.put(winner, numberOfWins + 1);<br/>    return this;<br/>  }<br/><br/>  public GameState handleRoundStarted(Event&lt;RoundStarted&gt; event) {<br/>    return this;<br/>  }<br/><br/>  public GameState handlePlayerAnswered(Event&lt;PlayerAnswered&gt; event) {<br/>    Player player = Player.fromString(event.data().player);<br/>    shownHands.add(new PlayerHand(player, event.data().answer));<br/>    return this;<br/>  }<br/><br/>  public GameState handleRoundTied(Event&lt;RoundTied&gt; event) {<br/>    shownHands.clear();<br/>    return this;<br/>  }<br/><br/>  public GameState handleRoundFinished(Event&lt;RoundFinished&gt; event) {<br/>    shownHands.clear();<br/>    return this;<br/>  }<br/><br/>  public GameState handleGameFinished(Event&lt;GameFinished&gt; event) {<br/>    this.gameStatus = GameStatus.FINISHED;<br/>    return this;<br/>  }<br/><br/>  ...<br/>  <br/>}</strong></span></pre><p id="b897" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们将使用一个集合<code class="du lj lk ll lm b"><strong class="ih hj">Game</strong></code>来实现游戏规则，并为正确的情况发出正确的事件。游戏是事件采购的一个很好的展示窗口，因为它们需要很强的一致性。我们开箱即用的保存的历史也有助于构建有趣的附加功能，如高分和统计。通过对事件做出反应，我们也可以很容易地为玩家建立通知和提醒。</p><p id="a39e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><code class="du lj lk ll lm b"><strong class="ih hj">Game</strong></code>类是我们的聚合根，包含游戏规则和逻辑的实现。</p><pre class="jf jg jh ji fd ln lm lo lp aw lq bi"><span id="1399" class="lr jr hi lm b fi ls lt l lu lv"><strong class="lm hj">public class Game {<br/><br/>  private final GameState gameState;<br/><br/>  ...<br/>  <br/>  public List&lt;Event&lt;?&gt;&gt; startGame(Player player1, Player player2) {<br/>    if (player1.equals(player2)) {<br/>      throw new IllegalArgumentException("Cannot play against yourself");<br/>    }<br/>    Set&lt;Player&gt; players = Stream.of(player1, player2).collect(toCollection(LinkedHashSet::new));<br/>    return singletonList(gameStarted(players));<br/>  }<br/><br/>  Player calculateWinner(PlayerHand hand1, PlayerHand hand2) {<br/>    if (hand1.answer.equals(ROCK)) {<br/>      return hand2.answer.equals(SCISSORS) ?<br/>          hand1.player : hand2.player;<br/>    } else if (hand1.answer.equals(PAPER)) {<br/>      return hand2.answer.equals(ROCK) ?<br/>          hand1.player : hand2.player;<br/>    } else<br/>      return hand2.answer.equals(PAPER) ?<br/>          hand1.player : hand2.player;<br/>  }<br/><br/>  Player calculateLoser(PlayerHand player1, PlayerHand player2) {<br/>    return calculateWinner(player1, player2).equals(player1.player) ? player2.player : player1.player;<br/>  }<br/><br/>}</strong></span></pre><h1 id="7d2b" class="jq jr hi bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">生成高分排行榜</h1><p id="6fea" class="pw-post-body-paragraph if ig hi ih b ii ko ik il im kp io ip iq kq is it iu kr iw ix iy ks ja jb jc hb bi translated">我们的应用程序中的最高分是一个<strong class="ih hj">投影</strong>，它是从所有包含每场比赛赢家/输家id的<code class="du lj lk ll lm b"><strong class="ih hj">GameFinished</strong></code>事件中构建的。</p><p id="55d5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们可以通过简单地告诉Serialized将我们的事件转换成可查询的<code class="du lj lk ll lm b"><strong class="ih hj">winners</strong></code>投影来构建这个投影，该投影可用于创建一个高分列表。</p><p id="30b1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在我们的<code class="du lj lk ll lm b"><strong class="ih hj">AppConfig</strong></code>中，我们添加了一个投影客户端，用于在应用程序启动时初始化投影定义。</p><pre class="jf jg jh ji fd ln lm lo lp aw lq bi"><span id="22a1" class="lr jr hi lm b fi ls lt l lu lv"><strong class="lm hj">@Configuration<br/>public class AppConfig {<br/><br/>  ...<br/><br/>  @Bean<br/>  public ProjectionClient projectionApiClient() {<br/>    return ProjectionClient.projectionClient(getConfig()).build();<br/>  }<br/>  <br/>  ...<br/>  <br/>}</strong></span></pre><p id="a8c8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们创建了一个<code class="du lj lk ll lm b"><strong class="ih hj">ProjectionInitializer</strong></code>服务，它将初始化我们所有的投影(在这个例子中是高分)</p><p id="dff4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果定义代码在应用程序启动之间改变，它将通过再次重新读取所有<code class="du lj lk ll lm b"><strong class="ih hj">GameFinished</strong></code>事件来重新创建投影。</p><pre class="jf jg jh ji fd ln lm lo lp aw lq bi"><span id="f2bd" class="lr jr hi lm b fi ls lt l lu lv"><strong class="lm hj">@Service<br/>public class ProjectionInitializer {<br/><br/>  private final ProjectionClient projectionClient;<br/><br/>  @Autowired<br/>  public ProjectionInitializer(ProjectionClient projectionClient) {<br/>    this.projectionClient = projectionClient;<br/>  }<br/>  <br/>  public void createGameProjection() {<br/>    projectionClient.createOrUpdate(<br/>      singleProjection("games")<br/>        .feed("game")<br/>        .addHandler(GameStarted.class.getSimpleName(),<br/>          merge().build(),<br/>          set().with(targetSelector("status")).with(rawData("IN_PROGRESS")).build())<br/>        .addHandler(RoundFinished.class.getSimpleName(),<br/>          append()<br/>            .with(targetSelector("rounds"))<br/>            .build())<br/>        .addHandler(GameFinished.class.getSimpleName(),<br/>          merge().build(),<br/>          set().with(targetSelector("status")).with(rawData("FINISHED")).build())<br/>        .build());<br/>  }<br/>  <br/>  public void createWinnersProjection() {<br/>    projectionClient.createOrUpdate(<br/>      singleProjection("winners")<br/>        .feed("game")<br/>        .withIdField("winner")<br/>        .addHandler("GameFinished",<br/>          inc().with(targetSelector("wins")).build(),<br/>          set().with(targetSelector("playerName")).with(eventSelector("winner")).build())<br/>  }<br/><br/>  ...<br/>  <br/>}</strong></span></pre><p id="455e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">对于游戏投影，我们将回合添加到回合数组，并在收到<code class="du lj lk ll lm b"><strong class="ih hj">GameStarted</strong></code>和<code class="du lj lk ll lm b"><strong class="ih hj">GameFinished</strong></code>事件时修改游戏的状态。</p><p id="b3f4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">赢家的预测略有不同。在这种情况下，我们使用序列化的<code class="du lj lk ll lm b"><strong class="ih hj">idField</strong></code>特性来创建投影，这些投影可以使用playerId而不是<code class="du lj lk ll lm b"><strong class="ih hj">aggregateId</strong></code>(在这种情况下是gameId)来识别。这使得playerId可以查询<code class="du lj lk ll lm b"><strong class="ih hj">winners</strong></code>预测。</p><h1 id="0d57" class="jq jr hi bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">应用程序类</h1><p id="7c2b" class="pw-post-body-paragraph if ig hi ih b ii ko ik il im kp io ip iq kq is it iu kr iw ix iy ks ja jb jc hb bi translated">我们的主应用程序类是我们的Spring Boot应用程序的入口点。它将启动web容器，并在引导期间初始化/更新我们的投影定义。它看起来是这样的:</p><pre class="jf jg jh ji fd ln lm lo lp aw lq bi"><span id="108a" class="lr jr hi lm b fi ls lt l lu lv"><strong class="lm hj">@Configuration<br/>@EnableAutoConfiguration<br/>@ComponentScan<br/>public class GameApplication implements CommandLineRunner {</strong></span><span id="bce3" class="lr jr hi lm b fi lw lt l lu lv"><strong class="lm hj">  private final ProjectionInitializer configurer;</strong></span><span id="8ff6" class="lr jr hi lm b fi lw lt l lu lv"><strong class="lm hj">  @Autowired<br/>  public GameApplication(ProjectionInitializer configurer) {<br/>    this.configurer = configurer;<br/>  }</strong></span><span id="b2bc" class="lr jr hi lm b fi lw lt l lu lv"><strong class="lm hj">  @Override<br/>  public void run(String... strings) {<br/>    configurer.createWinnersProjection();<br/>    configurer.createGameProjection();<br/>    configurer.totalStatsProjection();<br/>  }</strong></span><span id="6a9d" class="lr jr hi lm b fi lw lt l lu lv"><strong class="lm hj">  public static void main(String[] args) {<br/>    SpringApplication.run(GameApplication.class, args);<br/>  }<br/>}</strong></span></pre><p id="fce1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在启动应用程序之前，您需要将您的序列化API键作为系统属性/环境变量提供给Java进程，以便我们的<code class="du lj lk ll lm b"><strong class="ih hj">AppConfig</strong></code>类可以获取它们并正确初始化我们的客户端。</p><p id="1f68" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">启动应用程序后，您可以转到序列化控制台中的<strong class="ih hj"> Projections </strong>，您应该能够在那里看到初始化的投影定义。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es lx"><img src="../Images/f3a511532a7e3c7b419b3e471683c989.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*f9wWys7AREgXZCXZUcHqJw.jpeg"/></div></div></figure><h1 id="c8e9" class="jq jr hi bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">将碎片拼在一起</h1><p id="1fef" class="pw-post-body-paragraph if ig hi ih b ii ko ik il im kp io ip iq kq is it iu kr iw ix iy ks ja jb jc hb bi translated">为了向我们的客户端(Web/Mobile/other)公开游戏逻辑，我们将创建一个<code class="du lj lk ll lm b"><strong class="ih hj">@Controller</strong></code>，它从客户端接收HTTP <code class="du lj lk ll lm b"><strong class="ih hj">POST</strong></code>请求(命令)并执行请求中提供的<code class="du lj lk ll lm b"><strong class="ih hj">gameId</strong></code>的域逻辑:</p><pre class="jf jg jh ji fd ln lm lo lp aw lq bi"><span id="944a" class="lr jr hi lm b fi ls lt l lu lv"><strong class="lm hj">@Controller<br/>public class GameCommandController {</strong></span><span id="3c43" class="lr jr hi lm b fi lw lt l lu lv"><strong class="lm hj">  private final Logger logger = LoggerFactory.getLogger(getClass());<br/>  private final AggregateClient&lt;GameState&gt; gameClient;</strong></span><span id="f65e" class="lr jr hi lm b fi lw lt l lu lv"><strong class="lm hj">  @Autowired<br/>  public GameCommandController(AggregateClient&lt;GameState&gt; gameClient) {<br/>    this.gameClient = gameClient;<br/>  }</strong></span><span id="388a" class="lr jr hi lm b fi lw lt l lu lv"><strong class="lm hj">  @RequestMapping(value = "/start-game", method = POST, consumes = "application/json")<br/>  @ResponseStatus(value = HttpStatus.OK)<br/>  public void startGame(@RequestBody StartGameCommand command) {<br/>    Player player1 = Player.fromString(command.player1);<br/>    Player player2 = Player.fromString(command.player2);<br/>    GameState state = GameState.newGame();</strong></span><span id="1099" class="lr jr hi lm b fi lw lt l lu lv"><strong class="lm hj">    Game game = Game.fromState(state);<br/>    gameClient.save(saveRequest().withAggregateId(command.gameId).withEvents(game.startGame(player1, player2)).build());<br/>    logger.info("Game [{}] started with players [{}, {}]", command.gameId, command.player1, command.player2);<br/>  }</strong></span><span id="bf39" class="lr jr hi lm b fi lw lt l lu lv"><strong class="lm hj">  @RequestMapping(value = "/show-hand", method = POST, consumes = "application/json")<br/>  @ResponseStatus(value = HttpStatus.OK)<br/>  public void showHand(@RequestBody ShowHandCommand command) {<br/>    // Load the aggregate state from all events, execute domain logic and store the result<br/>    gameClient.update(command.gameId, gameState -&gt; {<br/>      Game game = Game.fromState(gameState);<br/>      return game.showHand(Player.fromString(command.player), command.answer);<br/>    });<br/>    logger.info("Player [{}] answered [{}] in game [{}]", command.player, command.answer, command.gameId);<br/>  }</strong></span><span id="079b" class="lr jr hi lm b fi lw lt l lu lv"><strong class="lm hj">}</strong></span></pre><p id="da9c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为了公开投影，我们创建了一个<code class="du lj lk ll lm b"><strong class="ih hj">@Controller</strong></code>,它接收来自客户端的HTTP调用，查询我们的投影并返回结果:</p><pre class="jf jg jh ji fd ln lm lo lp aw lq bi"><span id="d601" class="lr jr hi lm b fi ls lt l lu lv"><strong class="lm hj">@Controller<br/>public class GameQueryController {<br/><br/>  private final ProjectionClient projectionClient;<br/><br/>  @Autowired<br/>  public GameQueryController(ProjectionClient projectionClient) {<br/>    this.projectionClient = projectionClient;<br/>  }<br/><br/>  @RequestMapping(value = "/high-score", method = GET, produces = "application/json")<br/>  @ResponseBody<br/>  public WinnersProjection highScore() {<br/>    return WinnersProjection.fromProjections(projectionClient.query(list("winners").build(HighScore.class)));<br/>  }<br/><br/>  @RequestMapping(value = "/stats", method = GET, produces = "application/json")<br/>  @ResponseBody<br/>  public TotalGameStats gameStats() {<br/>    ProjectionResponse&lt;TotalGameStats&gt; projection = projectionClient.query(aggregated("total-game-stats").build(TotalGameStats.class));<br/>    return projection.data();<br/>  }<br/><br/>  @RequestMapping(value = "/games/{gameId}", method = GET, produces = "application/json")<br/>  @ResponseBody<br/>  public GameProjection game(@PathVariable UUID gameId) {<br/>    ProjectionResponse&lt;GameProjection&gt; game = projectionClient.query(single("games")<br/>      .id(gameId)<br/>      .build(GameProjection.class));<br/>    return game.data();<br/>  }<br/><br/>}</strong></span></pre><h1 id="04bc" class="jq jr hi bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">测试应用程序</h1><p id="ea52" class="pw-post-body-paragraph if ig hi ih b ii ko ik il im kp io ip iq kq is it iu kr iw ix iy ks ja jb jc hb bi translated">为了测试应用程序，您可以向端点<code class="du lj lk ll lm b"><strong class="ih hj">/start-game</strong></code>和<code class="du lj lk ll lm b"><strong class="ih hj">/show-hand</strong></code>发送HTTP POST请求。</p><p id="698b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">开始新游戏的请求示例如下:</p><pre class="jf jg jh ji fd ln lm lo lp aw lq bi"><span id="6ba5" class="lr jr hi lm b fi ls lt l lu lv"><strong class="lm hj">curl -i http://localhost:8080/start-game \<br/>  --header "Content-Type: application/json" \<br/>  --data '<br/>{<br/>    "gameId" : "dfd2d7bb-8c67-4d4f-87c1-364d72dfd05d",<br/>    "player1": "Lisa",<br/>    "player2": "Bob"<br/>}<br/>'</strong></span></pre><p id="6ce8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为了玩一轮游戏，我们将发送两个<code class="du lj lk ll lm b"><strong class="ih hj">show-hand</strong></code>请求。一个给丽莎，一个给鲍勃:</p><pre class="jf jg jh ji fd ln lm lo lp aw lq bi"><span id="cb47" class="lr jr hi lm b fi ls lt l lu lv"><strong class="lm hj">curl -i http://localhost:8080/show-hand \<br/>  --header "Content-Type: application/json" \<br/>  --data '<br/>{<br/>    "gameId" : "dfd2d7bb-8c67-4d4f-87c1-364d72dfd05d",<br/>    "player": "Lisa",<br/>    "answer" : "ROCK"<br/>}<br/>'</strong></span><span id="c9ff" class="lr jr hi lm b fi lw lt l lu lv"><strong class="lm hj">curl -i http://localhost:8080/show-hand \<br/>  --header "Content-Type: application/json" \<br/>  --data '<br/>{<br/>    "gameId" : "dfd2d7bb-8c67-4d4f-87c1-364d72dfd05d",<br/>    "player": "Bob",<br/>    "answer" : "PAPER"<br/>}<br/>'</strong></span></pre><h1 id="026d" class="jq jr hi bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">舍入结果</h1><p id="e753" class="pw-post-body-paragraph if ig hi ih b ii ko ik il im kp io ip iq kq is it iu kr iw ix iy ks ja jb jc hb bi translated">由于我们的投影已经设置为显示每一轮的结果，我们现在可以在序列化控制台中导航到<code class="du lj lk ll lm b"><strong class="ih hj">Projections/games/dfd2d7bb-8c67-4d4f-87c1-364d72dfd05d</strong></code>并查看完成的一轮。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es ly"><img src="../Images/aff9b613a900cd6b653e91b027a25c18.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*igbVARrFUxqjy71A6fYQ-g.jpeg"/></div></div></figure><p id="18dd" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为了访问这些数据，我们在应用程序中还有一个查询端点:</p><pre class="jf jg jh ji fd ln lm lo lp aw lq bi"><span id="a7fa" class="lr jr hi lm b fi ls lt l lu lv"><strong class="lm hj">curl -i </strong><a class="ae jd" href="http://localhost:8080/games/dfd2d7bb-8c67-4d4f-87c1-364d72dfd05d" rel="noopener ugc nofollow" target="_blank"><strong class="lm hj">http://localhost:8080/games/dfd2d7bb-8c67-4d4f-87c1-364d72dfd05d</strong></a></span></pre><p id="7106" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">该函数调用给定游戏id的序列化<code class="du lj lk ll lm b"><strong class="ih hj">games</strong></code>投影，并返回(已经)计算的投影数据:</p><pre class="jf jg jh ji fd ln lm lo lp aw lq bi"><span id="67f7" class="lr jr hi lm b fi ls lt l lu lv"><strong class="lm hj">{"players":["Bob","Lisa"],"status":"IN_PROGRESS","rounds":[{"winner":"Bob","loser":"Lisa"}]}</strong></span></pre><h1 id="9aa4" class="jq jr hi bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">展示高分</h1><p id="6317" class="pw-post-body-paragraph if ig hi ih b ii ko ik il im kp io ip iq kq is it iu kr iw ix iy ks ja jb jc hb bi translated">如果我们再玩一轮相同的游戏，Bob赢了这一轮(因此也赢了游戏)，我们可以看到高分投影随着他在游戏中的胜利而更新:</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es lz"><img src="../Images/4375582c9a5a27f4e46a69e715b46ed3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*efo0bFmdIQEFyIHn9cMkwg.jpeg"/></div></div></figure><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es ma"><img src="../Images/0156bb2c7fc49ca5aa9bd058211dff2d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*W9xfNelM6mWd2VLBelOY_w.jpeg"/></div></div></figure><p id="c6e2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为了访问这些数据，我们在应用程序中还有一个查询端点:</p><pre class="jf jg jh ji fd ln lm lo lp aw lq bi"><span id="c6b9" class="lr jr hi lm b fi ls lt l lu lv"><strong class="lm hj">curl -i </strong><a class="ae jd" href="http://localhost:8080/high-score" rel="noopener ugc nofollow" target="_blank"><strong class="lm hj">http://localhost:8080/high-score</strong></a></span><span id="819b" class="lr jr hi lm b fi lw lt l lu lv"><strong class="lm hj">{"highScores":[{"playerName":"Bob","wins":1}]}</strong></span></pre><p id="9776" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">该查询显示了来自<code class="du lj lk ll lm b"><strong class="ih hj">high-score</strong></code>预测的预测数据，并使用预测API的<code class="du lj lk ll lm b"><strong class="ih hj">sort</strong></code>和<code class="du lj lk ll lm b"><strong class="ih hj">limit</strong></code>特性来显示获胜次数最多的10名玩家。在与更多玩家一起运行了几个游戏之后，响应可能是这样的:</p><pre class="jf jg jh ji fd ln lm lo lp aw lq bi"><span id="94b2" class="lr jr hi lm b fi ls lt l lu lv"><strong class="lm hj">{<br/>  "highScores":<br/>  [<br/>    {"playerName":"Bob","wins":11},<br/>    {"playerName":"Lisa","wins":6},<br/>    {"playerName":"John","wins":5},<br/>    {"playerName":"Dan","wins":4},<br/>    {"playerName":"Anna","wins":1}<br/>  ]<br/>}</strong></span></pre><h1 id="39bb" class="jq jr hi bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">摘要</h1><p id="89bf" class="pw-post-body-paragraph if ig hi ih b ii ko ik il im kp io ip iq kq is it iu kr iw ix iy ks ja jb jc hb bi translated">这就结束了本教程的概述，展示了使用序列化进行事件源和CQRS的基本技术。希望本教程对你有用，并且它能启发你使用序列化构建自己的应用程序(或者游戏)。</p><h1 id="b1a2" class="jq jr hi bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">完整的示例代码</h1><p id="84e1" class="pw-post-body-paragraph if ig hi ih b ii ko ik il im kp io ip iq kq is it iu kr iw ix iy ks ja jb jc hb bi translated">在我们的Github库中查看本教程的完整示例代码。你可以随意克隆这个项目，并随意修改它。玩得开心！</p></div></div>    
</body>
</html>