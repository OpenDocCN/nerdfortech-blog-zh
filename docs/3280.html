<html>
<head>
<title>Galaxy Shooter 2D — Object Pooling</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">银河射手2D —对象池</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/galaxy-shooter-2d-object-pooling-23-ef91000076e0?source=collection_archive---------16-----------------------#2021-06-04">https://medium.com/nerd-for-tech/galaxy-shooter-2d-object-pooling-23-ef91000076e0?source=collection_archive---------16-----------------------#2021-06-04</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="ec19" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">回收游戏对象可以大大提高性能！</h2></div><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ix"><img src="../Images/8c9a7fbb77ef8cae686a66dc99beac6f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*igePjE2ZeEAUONwJji85Yw.png"/></div></div></figure><p id="6ebb" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">对象池是视频游戏行业使用的一种常见技术，通过重用实体的相同实例并在不再使用时存储它们来提高性能。</p><p id="9404" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">在我的游戏中，有无限的敌人波，有成吨的激光要被敌人和玩家实例化，不断产生和破坏游戏对象会在<strong class="jl hj">垃圾收集器</strong>中产生开销，从而导致性能峰值。</p><p id="d978" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">在本文中，我将通过使用<strong class="jl hj">对象池</strong>来防止这种情况。</p></div><div class="ab cl kf kg gp kh" role="separator"><span class="ki bw bk kj kk kl"/><span class="ki bw bk kj kk kl"/><span class="ki bw bk kj kk"/></div><div class="hb hc hd he hf"><h1 id="b113" class="km kn hi bd ko kp kq kr ks kt ku kv kw io kx ip ky ir kz is la iu lb iv lc ld bi translated">我是如何实现的</h1><ul class=""><li id="407f" class="le lf hi jl b jm lg jp lh js li jw lj ka lk ke ll lm ln lo bi translated">一个通用的<strong class="jl hj">对象池</strong>有以下变量:<br/> -要实例化和存储的游戏对象预置。<br/> -预置初始化池的拷贝数。<br/> -所有<strong class="jl hj">池化游戏对象</strong>的列表，在这里它将检查是否有可用的对象。</li></ul><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es lp"><img src="../Images/c5447e97453c48138f9a4f50a4595b5f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IpgilsN-GQKoD-1ZSOhIdw.png"/></div></div></figure><ul class=""><li id="0019" class="le lf hi jl b jm jn jp jq js lq jw lr ka ls ke ll lm ln lo bi translated">我对原始公式做了一些修改，以适应我心目中的<strong class="jl hj">对象池</strong>结构。</li></ul><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es lt"><img src="../Images/b97e7298d66ed359669126d257666d31.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1Q1QdK5tCjbQw0IU8n9ipA.png"/></div></div></figure><ul class=""><li id="af7b" class="le lf hi jl b jm jn jp jq js lq jw lr ka ls ke ll lm ln lo bi translated">现在，真正的<strong class="jl hj"> ObjectPool </strong>类在技术上是每个可用池的整个管理器。所以，它必须是一个单例的<strong class="jl hj"/>，并且它应该有一个所有<strong class="jl hj">池</strong>的<strong class="jl hj">列表</strong>，以及一个<strong class="jl hj">字典</strong>来快速简单地获取它们。</li></ul><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es lu"><img src="../Images/6b52d2faeb8eabe2825438d238ef7e33.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xKrFtP3wLSvmrrk1nDYS4Q.png"/></div></div><figcaption class="lv lw et er es lx ly bd b be z dx translated">这个枚举有一些未来的大剧透</figcaption></figure><ul class=""><li id="7f7b" class="le lf hi jl b jm jn jp jq js lq jw lr ka ls ke ll lm ln lo bi translated">在<strong class="jl hj"> Start </strong>上，我调用了一个名为<strong class="jl hj"> PopulatePools </strong>的方法，顾名思义，这个方法用它们各自的游戏对象填充这些池。</li></ul><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es lz"><img src="../Images/a2a4bd6e8d93e3e28e8fa36efa61aaa0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DfImUbX6AZ-Ih8c6C_7pXQ.png"/></div></div></figure><ul class=""><li id="4ba4" class="le lf hi jl b jm jn jp jq js lq jw lr ka ls ke ll lm ln lo bi translated"><strong class="jl hj"> GenerateNewObject </strong>方法将所需的游戏对象实例化到其各自的<strong class="jl hj">池</strong>中，并将其添加到<strong class="jl hj">池列表</strong>中。为了防止<strong class="jl hj">池</strong>耗尽游戏对象，我将该方法设置为游戏对象返回类型。</li></ul><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ma"><img src="../Images/b74cbf283d2bb12914baf1a771686e20.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fYzBMgFk73GfWzY2PuS_9g.png"/></div></div></figure><ul class=""><li id="9e9b" class="le lf hi jl b jm jn jp jq js lq jw lr ka ls ke ll lm ln lo bi translated">现在，我需要一个公共方法来请求一个<strong class="jl hj">池化游戏对象</strong>。这个方法将返回一个去激活的游戏对象，并用一个新的位置和旋转来激活它。如果池中没有可用的游戏对象，生成一个并返回。通常，位置和旋转由请求游戏对象的脚本来处理。然而，对我来说，在<strong class="jl hj">对象池管理器</strong>中设置这些属性似乎更合适，并且避免在每个脚本中重复相同的代码行。</li></ul><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es mb"><img src="../Images/90116de04a16e4749e74cec5f29874f9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7ohY3hDunGuA_juxL5cEEw.png"/></div></div></figure><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es mc"><img src="../Images/362b55ea8c5831a1a91f7cb86f56d65f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8FKMQo7POF8yvVP9CpVM0Q.png"/></div></div></figure><ul class=""><li id="ce36" class="le lf hi jl b jm jn jp jq js lq jw lr ka ls ke ll lm ln lo bi translated">最后，那些想要使用<strong class="jl hj">池化游戏对象</strong>的脚本需要访问<strong class="jl hj">对象池管理器实例</strong>来请求游戏对象。</li></ul><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es md"><img src="../Images/0236d09970e2aece19490966ee206a48.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WQcTc6TrPd_O8fY8UgpZrw.png"/></div></div><figcaption class="lv lw et er es lx ly bd b be z dx translated">最后一行代码是它如何从对象池中获得一个玩家激光。</figcaption></figure></div><div class="ab cl kf kg gp kh" role="separator"><span class="ki bw bk kj kk kl"/><span class="ki bw bk kj kk kl"/><span class="ki bw bk kj kk"/></div><div class="hb hc hd he hf"><h1 id="8ee6" class="km kn hi bd ko kp kq kr ks kt ku kv kw io kx ip ky ir kz is la iu lb iv lc ld bi translated">快速笔记</h1><p id="57f1" class="pw-post-body-paragraph jj jk hi jl b jm lg ij jo jp lh im jr js me ju jv jw mf jy jz ka mg kc kd ke hb bi translated">池中的所有游戏对象都必须有一个脚本，该脚本具有停用它们自己的功能。重用它们的唯一方法就是这样做。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es mh"><img src="../Images/68ce46f9b61a82f45f6aa1878119b76d.png" data-original-src="https://miro.medium.com/v2/resize:fit:652/format:webp/1*PpZMdWQuhmeBwfCyeM2HEQ.png"/></div></figure><p id="18da" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">同样，将你的初始化行为放在<strong class="jl hj"> OnEnable </strong>方法中(每次游戏对象被激活时调用)，而不是<strong class="jl hj"> Start </strong>(只调用一次)<strong class="jl hj">。你也可以使用<strong class="jl hj">禁用</strong>来清除数值或者在游戏对象被禁用之前做一些事情。</strong></p><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es mi"><img src="../Images/18f01c91c59519a9d27cbb8c25313d53.png" data-original-src="https://miro.medium.com/v2/resize:fit:796/format:webp/1*vnhEGpHNXrJgX8dOee6dbQ.png"/></div></figure></div><div class="ab cl kf kg gp kh" role="separator"><span class="ki bw bk kj kk kl"/><span class="ki bw bk kj kk kl"/><span class="ki bw bk kj kk"/></div><div class="hb hc hd he hf"><h1 id="d9df" class="km kn hi bd ko kp kq kr ks kt ku kv kw io kx ip ky ir kz is la iu lb iv lc ld bi translated">结果</h1><h2 id="e427" class="mj kn hi bd ko mk ml mm ks mn mo mp kw js mq mr ky jw ms mt la ka mu mv lc mw bi translated">编辑器中的对象池管理器</h2><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es mx"><img src="../Images/2dd609ac22dbba62395ffa517dae3e9c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*F-X2XbVz_Gt1_qwlBLDfIA.png"/></div></div></figure><h2 id="da9f" class="mj kn hi bd ko mk ml mm ks mn mo mp kw js mq mr ky jw ms mt la ka mu mv lc mw bi translated">运行中的对象池</h2><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es my"><img src="../Images/2e7455467af74a84dae8f8c4f61eee27.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*dR1-Z5E-5pZfgdCOschb7A.gif"/></div></div></figure></div></div>    
</body>
</html>