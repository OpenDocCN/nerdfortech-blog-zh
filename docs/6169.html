<html>
<head>
<title>Build the Forest in Python Series: Make the Forest Thread-Safe</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在 Python 系列中构建森林:使森林线程安全</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/build-the-forest-in-python-series-make-the-forest-thread-safe-b70517beb50f?source=collection_archive---------4-----------------------#2022-01-10">https://medium.com/nerd-for-tech/build-the-forest-in-python-series-make-the-forest-thread-safe-b70517beb50f?source=collection_archive---------4-----------------------#2022-01-10</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="e0db" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">多线程是提高性能的一种常用方法。然而，如果共享的状态或数据是可变的，那么线程之间的共享状态和数据就容易被破坏。我们在<a class="ae jd" rel="noopener" href="/nerd-for-tech/build-the-forest-in-python-series-binary-search-tree-43fdf3ddfd47">构建森林系列</a>中构建的树不是线程安全的。当多个线程同时执行写操作(例如，插入或删除)时，树可能被破坏或不正确地构建。当多个线程同时执行写入和读取操作时，即使是读取操作也可能返回不正确的结果。本文的主题是让树变得线程安全，并讨论线程安全的影响。</p><h1 id="b4ef" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">Python 中的多线程和 GIL</h1><p id="eef7" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated"><a class="ae jd" href="https://docs.python.org/3/glossary.html#term-global-interpreter-lock" rel="noopener ugc nofollow" target="_blank">全局解释器锁(GIL) </a>是<a class="ae jd" href="https://github.com/python/cpython" rel="noopener ugc nofollow" target="_blank"> CPython </a>解释器(我们从<a class="ae jd" href="https://www.python.org/downloads/" rel="noopener ugc nofollow" target="_blank"> Python 官网</a>下载的就是 CPython)使用的机制，保证一次只有一个线程可以执行 Python <a class="ae jd" href="https://docs.python.org/3/glossary.html#term-bytecode" rel="noopener ugc nofollow" target="_blank">字节码</a>。尽管 GIL 保证一次只有一个线程执行 Python 字节码，但这并不意味着我们编写的 Python 程序自动是线程安全的。这是因为保护只发生在字节码级别。例如，下面的代码片段是 AVL 树的插入函数的部分反汇编字节码。(注意，我们可以使用<a class="ae jd" href="https://docs.python.org/3/library/dis.html" rel="noopener ugc nofollow" target="_blank"> dis </a>模块反汇编 Python 字节码)</p><pre class="kh ki kj kk fd kl km kn ko aw kp bi"><span id="a2dd" class="kq jf hi km b fi kr ks l kt ku">Disassembly of &lt;code object insert at 0x7f136b391920, file "forest/binary_trees/avl_tree.py", line 112&gt;:<br/>128           0 LOAD_GLOBAL              0 (Node)<br/>              2 LOAD_FAST                1 (key)<br/>              4 LOAD_FAST                2 (data)<br/>              6 LOAD_CONST               1 (('key', 'data'))<br/>              8 CALL_FUNCTION_KW         2<br/>             10 STORE_FAST               3 (new_node)<br/><br/>129          12 LOAD_CONST               2 (None)<br/>             14 STORE_FAST               4 (parent)<br/><br/>130          16 LOAD_FAST                0 (self)<br/>             18 LOAD_ATTR                1 (root)<br/>             20 STORE_FAST               5 (current)<br/><br/>…                                                                                                <br/><br/>147     &gt;&gt;  128 LOAD_FAST                3 (new_node)<br/>            130 LOAD_FAST                4 (parent)<br/>            132 STORE_ATTR               4 (right)<br/><br/>154     &gt;&gt;  134 LOAD_FAST                4 (parent)<br/>            136 LOAD_ATTR                3 (left)<br/>            138 POP_JUMP_IF_FALSE      146<br/>            140 LOAD_FAST                4 (parent)<br/>            142 LOAD_ATTR                4 (right)<br/>            144 POP_JUMP_IF_TRUE       156<br/><br/>155     &gt;&gt;  146 LOAD_FAST                0 (self)<br/>            148 LOAD_METHOD              8 (_insert_fixup)<br/>            150 LOAD_FAST                3 (new_node)<br/>            152 CALL_METHOD              1<br/>            154 POP_TOP<br/>…</span></pre><p id="ed73" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">当多个线程调用 AVL 树的插入函数时，Python 解释器可能会在一个线程执行<em class="kv"> _insert_fixup </em>(即<em class="kv"> 148 LOAD_METHOD </em>)指令之前切换出该线程。同时，另一个线程出现并执行插入函数的一些字节码指令。无论插入是否完成，第二个线程都会中断前面的插入函数。这种情况可能会导致一个不正确的 AVL 树，甚至更糟，程序崩溃。</p><h1 id="3565" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">线程不安全的示例</h1><p id="118a" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">根据上面的讨论，有两种情况多线程可能变得不安全:写争用和读写争用。前者意味着多个写操作同时操作共享的可变资源；后者意味着读操作正在读取写操作同时更新的一些资源。</p><h2 id="e662" class="kq jf hi bd jg kw kx ky jk kz la lb jo iq lc ld js iu le lf jw iy lg lh ka li bi translated">场景 1 —写入争用</h2><p id="00c4" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">为了模拟这个场景，我们需要并发执行一些写操作。在本例中，我们将使用五个线程同时插入 500 个非重复数据。例如，第一个线程插入从 0 到 99 的数据，第二个线程插入从 100 到 199 的数据，依此类推。所有插入完成后，添加的节点总数将是 500。</p><p id="f2d4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">切换间隔</strong></p><p id="fb74" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">从<a class="ae jd" href="https://python.freelycode.com/doc/python_3_5_0/whatsnew/3.2.html#multi-threading" rel="noopener ugc nofollow" target="_blank"> Python 3.2 </a>开始，引入了<a class="ae jd" href="https://docs.python.org/3/library/sys.html#sys.setswitchinterval" rel="noopener ugc nofollow" target="_blank"> setswitchinterval </a>函数，允许我们设置解释器的线程切换间隔。该值确定分配给并发运行线程的时间片的持续时间。为了使多线程问题(例如，竞争条件)快速发生，我们使用<em class="kv"> setswitchinterval </em>函数将切换间隔减少到一个很小的值，这样线程切换将在字节码指令之间更快地发生。</p><p id="f655" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">以下代码是使用我们在<a class="ae jd" rel="noopener" href="/nerd-for-tech/build-the-forest-in-python-series-avl-tree-73f09abc0e1">构建森林系列:AVL 树</a>中构建的 AVL 树来模拟问题的示例。</p><p id="f396" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">线程不安全示例代码</strong></p><pre class="kh ki kj kk fd kl km kn ko aw kp bi"><span id="9e8a" class="kq jf hi km b fi kr ks l kt ku">import threading<br/>import sys<br/><br/>from typing import List<br/><br/>from forest.binary_trees import avl_tree<br/>from forest.binary_trees import traversal<br/><br/># Use a very small thread switch interval to increase the chance that<br/># we can reveal the multithreading issue easily.<br/>sys.setswitchinterval(0.0000001)<br/><br/>def insert_data(tree: avl_tree.AVLTree, data: List) -&gt; None:<br/>    """Insert data into a tree."""<br/>    for key in data:<br/>        tree.insert(key=key, data=str(key))<br/><br/>def multithreading_simulator(tree: avl_tree.AVLTree) -&gt; None:<br/>    """Use five threads to insert data into a tree with non-duplicate data."""<br/>    try:<br/>        thread1 = threading.Thread(<br/>            target=insert_data, args=(tree, [item for item in range(100)])<br/>        )<br/>        thread2 = threading.Thread(<br/>            target=insert_data, args=(tree, [item for item in range(100, 200)])<br/>        )<br/>        thread3 = threading.Thread(<br/>            target=insert_data, args=(tree, [item for item in range(200, 300)])<br/>        )<br/>        thread4 = threading.Thread(<br/>            target=insert_data, args=(tree, [item for item in range(300, 400)])<br/>        )<br/>        thread5 = threading.Thread(<br/>            target=insert_data, args=(tree, [item for item in range(400, 500)])<br/>        )<br/><br/>        thread1.start()<br/>        thread2.start()<br/>        thread3.start()<br/>        thread4.start()<br/>        thread5.start()<br/><br/>        thread1.join()<br/>        thread2.join()<br/>        thread3.join()<br/>        thread4.join()<br/>        thread5.join()<br/><br/>        result = [item for item in traversal.inorder_traverse(tree=tree)]<br/><br/>        incorrect_node_list = list()<br/>        for index in range(len(result)):<br/>            if index &gt; 0:<br/>                if result[index] &lt; result[index - 1]:<br/>                    incorrect_node_list.append(<br/>                        f"{result[index - 1]} -&gt; {result[index]}"<br/>                    )<br/><br/>        if len(result) != 500 or len(incorrect_node_list) &gt; 0:<br/>            print(f"total_nodes: {len(result)}")<br/>            print(f"incorrect_order: {incorrect_node_list}")<br/>    except:<br/>        print("Tree built incorrectly")<br/><br/>if __name__ == "__main__":<br/>    tree = avl_tree.AVLTree()<br/>    multithreading_simulator(tree=tree)</span></pre><p id="e9b6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在线程插入 500 个数据(从 0 到 499)后，此示例执行一些检查:</p><ol class=""><li id="12c8" class="lj lk hi ih b ii ij im in iq ll iu lm iy ln jc lo lp lq lr bi translated">如果总节点数为 500。</li><li id="7e0f" class="lj lk hi ih b ii ls im lt iq lu iu lv iy lw jc lo lp lq lr bi translated">如果有序遍历的输出是有序的。</li><li id="23c4" class="lj lk hi ih b ii ls im lt iq lu iu lv iy lw jc lo lp lq lr bi translated">没有例外。</li></ol><p id="0bd8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果这些检查中的任何一项失败，则树构建不正确。因此，我们证明了之前实现的 AVL 树不是线程安全的。</p><p id="7011" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果我们运行这个例子足够多次(多线程问题是时间问题；它们可能不总是发生)，检查最终会失败，看起来像下面的示例。</p><pre class="kh ki kj kk fd kl km kn ko aw kp bi"><span id="678f" class="kq jf hi km b fi kr ks l kt ku">total_nodes: 454<br/>incorrect_order: ["(459, '459') -&gt; (319, '319')"]</span></pre><p id="3ec0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">同样的情况也适用于我们之前在构建森林系列中构建的所有其他树。完整的线程不安全代码可从<a class="ae jd" href="https://github.com/shunsvineyard/forest-python/blob/main/examples/multithreading_not_safe.py" rel="noopener ugc nofollow" target="_blank">多线程 _ 非 _ 安全. py </a>获得。</p><h2 id="6802" class="kq jf hi bd jg kw kx ky jk kz la lb jo iq lc ld js iu le lf jw iy lg lh ka li bi translated">场景 2 —读写争用</h2><p id="e2fa" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">虽然读操作不会修改任何资源的状态，但是读操作正在读取时，状态可能会受到写操作的影响。例如，线程 A 正在搜索节点 N，而线程 B 正在删除节点 M，在删除过程中，线程 B 也将节点 N 移动到不同的位置。在这种情况下，线程 A 可能无法找到节点 n。</p><pre class="kh ki kj kk fd kl km kn ko aw kp bi"><span id="14ac" class="kq jf hi km b fi kr ks l kt ku">import threading<br/>import sys<br/><br/>from typing import Any, List<br/>from forest.binary_trees import avl_tree<br/><br/># Use a very small thread switch interval to increase the chance that<br/># we can reveal the multithreading issue easily.<br/>sys.setswitchinterval(0.0000001)<br/><br/>flag = False   # Flag to determine if the read thread stops or continues.<br/><br/>def delete_data(tree: avl_tree.AVLTree, data: List) -&gt; None:<br/>    """Delete data from a tree."""<br/>    for key in data:<br/>        tree.delete(key=key)<br/><br/>def find_node(tree: avl_tree.AVLTree, key: Any) -&gt; None:<br/>    """Search a specific node."""<br/>    while flag:<br/>        if not tree.search(key):<br/>            print(f"  Fail to find node: {key}")<br/><br/>def multithreading_simulator(tree: avl_tree.AVLTree, tree_size: int) -&gt; None:<br/>    """Use one thread to delete data and one thread to query at the same time."""<br/>    global flag<br/>    flag = True<br/>    delete_thread = threading.Thread(<br/>        target=delete_data, args=(tree, [item for item in range(20, tree_size)])<br/>    )<br/>    query_node_key = 17<br/>    query_thread = threading.Thread(target=find_node, args=(tree, query_node_key))<br/><br/>    delete_thread.start()<br/>    query_thread.start()<br/><br/>    delete_thread.join()<br/>    flag = False<br/>    query_thread.join()<br/>    print(f"Check if the node {query_node_key} exist?")<br/>    if tree.search(key=query_node_key):<br/>        print(f"{query_node_key} exists")<br/><br/>if __name__ == "__main__":<br/>    print("Build an AVL Tree")<br/>    tree = avl_tree.AVLTree()<br/>    tree_size = 200<br/>    for key in range(tree_size):<br/>        tree.insert(key=key, data=str(key))<br/>    print("Multithreading Read/Write Test")<br/>    multithreading_simulator(tree=tree, tree_size=tree_size)<!-- --> </span></pre><p id="a7c8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在这个例子中，我们首先构建一个有 200 个节点的树，然后使用一个线程继续搜索节点 17，而另一个线程删除从 20 到 200 的节点。因为该示例没有删除节点 17，所以搜索线程应该一直找到节点 17。同样，在删除线程完成之后，我们再次查询节点 17，以确保节点 17 仍然存在于树中。如果在任何时候，搜索线程都找不到节点 17，这意味着我们证明了先前实现的 AVL 树在读写争用的情况下不是线程安全的。当我们运行这个例子足够多次时，这很容易发生。发生这种情况时，将显示以下输出。</p><pre class="kh ki kj kk fd kl km kn ko aw kp bi"><span id="9f10" class="kq jf hi km b fi kr ks l kt ku">Build an AVL Tree<br/>Multithreading Read/Write Test<br/>  Fail to find node: 17<br/>Check if node 17 exist?<br/>17 exists</span></pre><h1 id="c1ae" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">项目设置</h1><p id="7ee4" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">遵循与构建森林系列中的其他文章相同的风格和假设，实现假设为 Python 3.9 或更高版本。本文为我们的项目添加了两个模块:<em class="kv"> atomic_trees.py </em>用于原子树的实现，以及<em class="kv"> test_automic_trees.py </em>用于单元测试。添加这两个文件后，我们的项目布局如下:</p><pre class="kh ki kj kk fd kl km kn ko aw kp bi"><span id="6623" class="kq jf hi km b fi kr ks l kt ku">forest-python<br/>├── forest<br/>│   ├── __init__.py<br/>│   ├── binary_trees<br/>│   │   ├── __init__.py<br/>│   │   ├── atomic_trees.py<br/>│   │   ├── avl_tree.py<br/>│   │   ├── binary_search_tree.py<br/>│   │   ├── double_threaded_binary_tree.py<br/>│   │   ├── red_black_tree.py<br/>│   │   ├── single_threaded_binary_trees.py<br/>│   │   └── traversal.py<br/>│   ├── metrics.py<br/>│   └── tree_exceptions.py<br/>└── tests<br/>    ├── __init__.py<br/>    ├── conftest.py<br/>    ├── test_atomic_trees.py<br/>    ├── test_avl_tree.py<br/>    ├── test_binary_search_tree.py<br/>    ├── test_double_threaded_binary_tree.py<br/>    ├── test_metrics.py<br/>    ├── test_red_black_tree.py<br/>    ├── test_single_threaded_binary_trees.py<br/>    └── test_traversal.py</span></pre><p id="845f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">(完整代码可在<a class="ae jd" href="https://github.com/shunsvineyard/forest-python" rel="noopener ugc nofollow" target="_blank">森林-python </a>获得)</p><h1 id="3fee" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">构建原子树</h1><p id="b6fd" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">为了使森林线程安全，我们需要防止写争用和读写争用。</p><h2 id="559b" class="kq jf hi bd jg kw kx ky jk kz la lb jo iq lc ld js iu le lf jw iy lg lh ka li bi translated">我们想保护什么？</h2><p id="4447" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">我们首先要问的是要保护什么？一般来说，我们需要覆盖任何共享的可变状态和数据。树数据结构是树节点的组合。对节点的任何更改都会更新树的状态，并且树节点是共享的和可变的。因此，为了线程安全，我们需要确保树节点的转换是不可中断的。</p><h2 id="6c68" class="kq jf hi bd jg kw kx ky jk kz la lb jo iq lc ld js iu le lf jw iy lg lh ka li bi translated">什么能改变这个状态？</h2><p id="81bf" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">一般来说，我们不需要担心只读操作，因为读操作不会修改任何东西。只有两个函数会改变我们在本系列中构建的树的状态:插入和删除。以 AVL 树的插入为例。下图突出显示了我们插入节点 35 后接触到的节点。</p><figure class="kh ki kj kk fd ly er es paragraph-image"><div role="button" tabindex="0" class="lz ma di mb bf mc"><div class="er es lx"><img src="../Images/1240a72d417b91b4d595090bcd4a5df7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*ZWIDVZQrFi8kNbjU.png"/></div></div></figure><p id="1d40" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">从这个例子中，我们可以看到在插入操作中更新了多个节点。如果在插入期间有任何其他线程接触这些节点(即，23、33 和 37)或修改其他节点，这些节点也影响节点 22、33 和 37 的属性(例如，高度和平衡因子)，则插入将产生不正确的 AVL 树或更糟的情况——程序崩溃。</p><p id="8d6f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">相同的场景也可以应用于删除。因此，我们需要确保插入和删除都可以不受任何干扰地完成。换句话说，插入和删除函数是不能被多个线程同时执行的关键部分。</p><p id="f4ca" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">修复、移植和旋转功能怎么样？</p><p id="cdd2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这些函数也更新树的状态。然而，它们的目的是支持插入和删除，这就是它们被定义为内部函数的原因(也就是说，客户端代码不应该直接调用它们)。只要我们确保一次执行一个插入或删除操作，这些辅助函数一次只能被一个线程访问——不需要保护它们。</p><p id="93cf" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">如何保护？</strong></p><p id="a4bb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">防止同时访问共享资源的一个常见解决方案是互斥。我们可以使用 Python 内置的<a class="ae jd" href="https://docs.python.org/3/library/threading.html#lock-objects" rel="noopener ugc nofollow" target="_blank">锁对象</a>来保护一个临界区:一个线程需要<a class="ae jd" href="https://docs.python.org/3/library/threading.html#threading.Lock.acquire" rel="noopener ugc nofollow" target="_blank">在进入临界区之前获取</a>一个锁，在离开临界区之后<a class="ae jd" href="https://docs.python.org/3/library/threading.html#threading.Lock.release" rel="noopener ugc nofollow" target="_blank">释放</a>这个锁。以<a class="ae jd" rel="noopener" href="/nerd-for-tech/build-the-forest-in-python-series-avl-tree-73f09abc0e1"> AVL 树的插入</a>为例。通过添加这些步骤，我们可以将插入算法更新为线程安全的。</p><ol class=""><li id="3a95" class="lj lk hi ih b ii ij im in iq ll iu lm iy ln jc lo lp lq lr bi translated">获得一把锁。</li><li id="3886" class="lj lk hi ih b ii ls im lt iq lu iu lv iy lw jc lo lp lq lr bi translated">以与二叉查找树插入相同的方式插入高度为 0 的新节点:通过从根开始遍历树并沿途将新节点的键与每个节点的键进行比较，找到插入新节点的正确位置(即新节点的父节点)。</li><li id="f14c" class="lj lk hi ih b ii ls im lt iq lu iu lv iy lw jc lo lp lq lr bi translated">更新高度，并通过从新节点追溯到根节点来检查违反的 AVL-tree-property 是否发生。在返回到根的过程中，如果需要的话，在途中更新每个节点的高度。如果我们发现一个不平衡的节点，执行一定的旋转来平衡它。旋转后，插入结束。如果没有找到不平衡的节点，则插入在到达根节点并更新其高度后完成。</li><li id="8d7f" class="lj lk hi ih b ii ls im lt iq lu iu lv iy lw jc lo lp lq lr bi translated">打开锁。</li></ol><p id="070c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">第二步和第三步是关键部分，现在受到锁机制的保护。由于原子插入函数不改变其原始功能，我们可以将原子 AVL 树实现为原始 AVL 树的派生类，并扩展插入，如下所示。</p><pre class="kh ki kj kk fd kl km kn ko aw kp bi"><span id="3c5c" class="kq jf hi km b fi kr ks l kt ku">import threading<br/><br/>from typing import Any, Optional<br/>from forest.binary_trees import avl_tree<br/><br/><br/>class AVLTree(avl_tree.AVLTree):<br/>    def __init__(self, registry: Optional[metrics.MetricRegistry] = None) -&gt; None:<br/>        avl_tree.AVLTree.__init__(self, registry=registry)<br/>        self._lock = threading.Lock()  # The lock object<br/><br/>    def insert(self, key: Any, data: Any) -&gt; None:<br/>        self._lock.acquire()<br/>        # The original insertion function is the critical section, and<br/>        # is protected by the lock.<br/>        avl_tree.AVLTree.insert(self, key=key, data=data)<br/>        self._lock.release()</span></pre><p id="58d2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">使用<em class="kv">中的锁与</em>-语句</strong></p><p id="fb80" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Python 编程中的一个良好实践是，如果代码块需要管理资源(例如，打开/关闭文件或获取/释放锁)，我们应该总是使用带语句上下文管理器的<a class="ae jd" href="https://docs.python.org/3/reference/datamodel.html#with-statement-context-managers" rel="noopener ugc nofollow" target="_blank">。用带有语句的<em class="kv">包装的代码块保证释放资源(例如，锁)，即使在带有</em>语句的<em class="kv">中抛出异常(更多细节见<a class="ae jd" href="https://docs.python.org/3/library/threading.html#using-locks-conditions-and-semaphores-in-the-with-statement" rel="noopener ugc nofollow" target="_blank">在带有</a>语句中使用锁)。考虑到最佳实践，我们可以利用<em class="kv">with</em>-语句来管理锁资源，从而更新上面的实现。我们也可以用同样的方法保护删除。此外，语法还简化了实现，如下所示。</em></a></p><pre class="kh ki kj kk fd kl km kn ko aw kp bi"><span id="76d4" class="kq jf hi km b fi kr ks l kt ku">import threading<br/><br/>from typing import Any, Optional<br/>from forest.binary_trees import avl_tree<br/><br/>class AVLTree(avl_tree.AVLTree):<br/>    def __init__(self, registry: Optional[metrics.MetricRegistry] = None) -&gt; None:<br/>        avl_tree.AVLTree.__init__(self, registry=registry)<br/>        self._lock = threading.Lock()<br/><br/>    def insert(self, key: Any, data: Any) -&gt; None:<br/>        with self._lock:<br/>            avl_tree.AVLTree.insert(self, key=key, data=data)<br/><br/>    def delete(self, key: Any) -&gt; None:<br/>        with self._lock:<br/>            avl_tree.AVLTree.delete(self, key=key)</span></pre><h2 id="ca7e" class="kq jf hi bd jg kw kx ky jk kz la lb jo iq lc ld js iu le lf jw iy lg lh ka li bi translated">读写争用怎么样？</h2><p id="e8e0" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">到目前为止，我们在上面所做的更改保护了树免受写争用情况的影响，但是它不能防止读写争用。最简单的解决方案与插入和删除功能相同——使用锁机制。但是，如果我们不小心使用锁机制，可能会出现死锁情况。下图为案例。左侧是带有搜索功能锁的原子 AVL 树，右侧是原子 AVL 树派生的原始 AVL 树。</p><figure class="kh ki kj kk fd ly er es paragraph-image"><div role="button" tabindex="0" class="lz ma di mb bf mc"><div class="er es mf"><img src="../Images/6ecbb58804ab3851401cf0d09ef8a94d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CzuXRqkMHI6oYeyFGzNRMw.png"/></div></div></figure><p id="c60c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">当客户端调用原子 AVL 树的删除函数时，它首先获取锁，然后调用其父代的删除函数(即，来自原始 AVL 树的删除函数)。当我们实现<a class="ae jd" rel="noopener" href="/nerd-for-tech/build-the-forest-in-python-series-avl-tree-73f09abc0e1">原始 AVL 树的删除功能</a>时，我们利用树的搜索功能来识别要删除的节点。然而，由于删除函数是从原子 AVL 树(即，派生类)调用的，所以要调用的搜索函数将是原子 AVL 树的搜索函数。并且原子 AVL 树的搜索试图做的第一件事是获取锁，这将永远不会发生，因为调用者(即原子 AVL 树的删除函数)仍然持有锁。僵局就是这样产生的。</p><p id="5760" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">有许多方法可以处理死锁情况。我们要使用的解决方案是在原来的 AVL 树中分离<em class="kv"> search </em>函数的接口和实现——新的<em class="kv"> _search </em>函数包含 search 实现，接口<em class="kv"> search </em>函数调用<em class="kv"> _search </em>函数，如下面的代码片段所示。</p><pre class="kh ki kj kk fd kl km kn ko aw kp bi"><span id="d245" class="kq jf hi km b fi kr ks l kt ku">def search(self, key: Any) -&gt; Optional[Node]:<br/>    return self._search(key=key)<br/><br/>def _search(self, key: Any) -&gt; Optional[Node]:<br/>    current = self.root<br/>    while current:<br/>        if key &lt; current.key:<br/>            current = current.left<br/>        elif key &gt; current.key:<br/>            current = current.right<br/>        else:  # Key found<br/>            return current<br/>    return None</span></pre><p id="21a8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">任何需要调用搜索函数的方法都会调用实现函数<em class="kv"> _search </em>而不是接口<em class="kv"> search </em>。因此，原始 AVL 树的删除函数变成如下。</p><pre class="kh ki kj kk fd kl km kn ko aw kp bi"><span id="8463" class="kq jf hi km b fi kr ks l kt ku">def delete(self, key: Any) -&gt; None:<br/>    if self.root and (deleting_node := self._search(key=key)):<br/>        # The rest of the code remains the same<br/>        …<!-- --> </span></pre><p id="270f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这样做的几个原因。首先，由于接口保持不变，所以调用原始 AVL 树的客户端代码不会受到影响。第二，我们避免代码重复。第三，我们简化了原子 AVL 树的线程安全搜索功能的实现。下面是原子 AVL 树实现。</p><pre class="kh ki kj kk fd kl km kn ko aw kp bi"><span id="4931" class="kq jf hi km b fi kr ks l kt ku">class AVLTree(avl_tree.AVLTree):<br/>    """Thread-safe AVL Tree."""<br/><br/>    def __init__(self, registry: Optional[metrics.MetricRegistry] = None) -&gt; None:<br/>        avl_tree.AVLTree.__init__(self, registry=registry)<br/>        self._lock = threading.Lock()<br/><br/>    def search(self, key: Any) -&gt; Optional[avl_tree.Node]:<br/>        """Thread-safe search."""<br/>        with self._lock:<br/>            return avl_tree.AVLTree.search(self, key=key)<br/><br/>    def insert(self, key: Any, data: Any) -&gt; None:<br/>        """Thread-safe insert."""<br/>        with self._lock:<br/>            avl_tree.AVLTree.insert(self, key=key, data=data)<br/><br/>    def delete(self, key: Any) -&gt; None:<br/>        """Thread-safe delete."""<br/>        with self._lock:<br/>            avl_tree.AVLTree.delete(self, key=key)</span></pre><p id="76a7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">同样的情况也发生在我们之前实现的其他树中。因此，我们可以应用相同的思想来实现其余的树。完整的原子树可在<a class="ae jd" href="https://github.com/shunsvineyard/forest-python/blob/main/forest/binary_trees/atomic_trees.py" rel="noopener ugc nofollow" target="_blank"> atomic_trees.py </a>获得，它们的父树也通过分离搜索功能的接口和实现进行了修改。参见<a class="ae jd" href="https://github.com/shunsvineyard/forest-python/pull/32/files" rel="noopener ugc nofollow" target="_blank">文件更改列表</a>了解已完成的更新。</p><h1 id="bbfd" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">试验</h1><p id="cc3a" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">我们应该尽可能地对我们的代码进行单元测试。因为我们已经证明了原始 AVL 树(以 AVL 树为例)不是线程安全的，所以我们可以运行相同的测试来确保原子 AVL 树对于写争用和读写争用都是线程安全的。同样，我们可以对其余的原子树运行相同的测试。检查<a class="ae jd" href="https://github.com/shunsvineyard/forest-python/blob/main/tests/test_atomic_trees.py" rel="noopener ugc nofollow" target="_blank"> test_atomic_trees.py </a>以获得完整的单元测试。</p><h1 id="7151" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">分析</h1><p id="5d22" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">尽管原子树是线程安全的，但是使用锁是有代价的。该机制迫使临界区(例如，插入和删除功能)被顺序访问。多线程编程的动机是为了有更好的性能。当代码必须顺序运行时，我们就失去了多线程的好处。此外，在 Python 世界中(具体来说就是 CPython)，GIL 在多线程编程中也起着至关重要的作用。在某些情况下，GIL 会降低多线程方法获得的性能。本节的其余部分将使用 AVL 树(原始 AVL 树(即非线程安全 AVL 树)和原子 AVL 树)来评估锁机制和 GIL 在多线程情况下的性能影响。</p><p id="7a66" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">此外，我们只能比较原始 AVL 树和原子 AVL 树的搜索功能，因为插入和删除在原始 AVL 树中不是线程安全的。为了衡量性能影响，我们将执行以下操作:</p><ol class=""><li id="5535" class="lj lk hi ih b ii ij im in iq ll iu lm iy ln jc lo lp lq lr bi translated">定义一个有 200，000 个节点的原始 AVL 树，用单线程搜索每个节点。并测量所需的时间。</li><li id="728f" class="lj lk hi ih b ii ls im lt iq lu iu lv iy lw jc lo lp lq lr bi translated">使用步骤 2 中的同一个 AVL 树，但是使用两个线程来搜索 200，000 个节点，一个线程搜索节点 0 到 99，999，另一个线程查询 100，000 到 199，999。并测量所需的时间。</li><li id="4566" class="lj lk hi ih b ii ls im lt iq lu iu lv iy lw jc lo lp lq lr bi translated">定义一个具有 200，000 个节点的原子 AVL 树，并使用两个线程来搜索 200，000 个节点。另外，一个线程用于 0 到 99，999，另一个线程用于 100，000 到 199，999。并测量所需的时间。</li></ol><p id="10cf" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">通过比较步骤 1 和步骤 2 的结果，我们可以看到 GIL 的影响。第 2 步和第 3 步结果的比较提供了使用锁机制对性能影响的概念。以下是示例代码。</p><pre class="kh ki kj kk fd kl km kn ko aw kp bi"><span id="9ad6" class="kq jf hi km b fi kr ks l kt ku">import threading<br/>import time<br/><br/>from typing import List<br/>from forest.binary_trees import avl_tree<br/>from forest.binary_trees import atomic_trees<br/><br/>def query_data(tree: avl_tree.AVLTree, data: List) -&gt; None:<br/>    """Query nodes from a tree."""<br/>    for key in data:<br/>        tree.search(key=key)<br/><br/>def multithreading_simulator(tree: avl_tree.AVLTree, total_nodes: int) -&gt; float:<br/>    """Use two threads to query nodes with different ranges."""<br/>    thread1 = threading.Thread(<br/>        target=query_data, args=(tree, [item for item in range(total_nodes // 2)])<br/>    )<br/><br/>    thread2 = threading.Thread(<br/>        target=query_data,<br/>        args=(tree, [item for item in range(total_nodes // 2, total_nodes)]),<br/>    )<br/><br/>    start = time.time()<br/>    thread1.start()<br/>    thread2.start()<br/><br/>    thread1.join()<br/>    thread2.join()<br/>    end = time.time()<br/><br/>    return end - start<br/><br/>if __name__ == "__main__":<br/><br/>    total_nodes = 200000<br/><br/>    original_avl_tree = avl_tree.AVLTree()<br/><br/>    # Single thread case<br/>    for key in range(total_nodes):<br/>        original_avl_tree.insert(key=key, data=str(key))<br/><br/>    data = [item for item in range(total_nodes)]<br/>    start = time.time()<br/>    query_data(tree=original_avl_tree, data=data)<br/>    end = time.time()<br/>    delta = end - start<br/>    print("Single Thread Case")<br/>    print(f"Time in seconds: {delta}")<br/><br/>    # Multithreads case<br/>    delta_with_threads = multithreading_simulator(<br/>        tree=original_avl_tree, total_nodes=total_nodes<br/>    )<br/>    print("Multithread Case")<br/>    print(f"Time in seconds: {delta_with_threads}")<br/><br/>    # Multithread with lock case<br/>    avl_tree_with_lock = atomic_trees.AVLTree()<br/>    for key in range(total_nodes):<br/>        avl_tree_with_lock.insert(key=key, data=str(key))<br/><br/>    delta_with_lock = multithreading_simulator(<br/>        tree=avl_tree_with_lock, total_nodes=total_nodes<br/>    )<br/>    print("Multithread with Lock Case")<br/>    print(f"Time in seconds: {delta_with_lock}")</span></pre><p id="94bb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在我们运行这个例子之后，我们将获得每个案例的运行时间。</p><pre class="kh ki kj kk fd kl km kn ko aw kp bi"><span id="01d6" class="kq jf hi km b fi kr ks l kt ku">Single Thread Case<br/>Time in seconds: 0.3944363594055176<br/>Multithread Case<br/>Time in seconds: 0.4100222587585449<br/>Multithread with Lock Case<br/>Time in seconds: 2.7478058338165283</span></pre><p id="1858" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">(请注意，结果数字因机器而异。然而，在任何设备上，这三种情况之间的比较应该是相似的。)</p><p id="efe2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这里我们可以看到，两个线程的性能提升非常有限，甚至从一个线程到两个线程是负的(第一个和第二个线程的结果)。通过比较第二个和第三个结果，我们也意识到使用锁机制的成本相对较高。</p><h1 id="ac2b" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">例子</h1><p id="c014" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">使用原子树与使用原始树是一样的。例如，如果我们想使用原子 AVL 树，我们需要导入<em class="kv"> atomic_trees </em>并在这个模块中使用原子 AVL 树，如下面的代码片段——这与使用原始 AVL 树是一样的。</p><pre class="kh ki kj kk fd kl km kn ko aw kp bi"><span id="3ccc" class="kq jf hi km b fi kr ks l kt ku">from forest.binary_trees import atomic_trees<br/><br/>if __name__ == "__main__":<br/>    tree = atomic_trees.AVLTree()<br/>    tree.insert(key=17, data="data")<br/>    tree.insert(key=21, data="other_data")<br/>    tree.delete(key=17)</span></pre><h1 id="306d" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">摘要</h1><p id="cf19" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">在本文中，我们实现了二叉树的线程安全版本。我们还意识到，让事情线程安全的成本不是免费的。然而，程序的正确性比它的性能更重要。在某些情况下，我们需要牺牲性能来确保正确性。</p></div><div class="ab cl mg mh gp mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="hb hc hd he hf"><p id="9c44" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="kv">原载于 2022 年 1 月 9 日</em><a class="ae jd" href="https://shunsvineyard.info/2022/01/09/build-the-forest-in-python-series-make-the-forest-thread-safe/" rel="noopener ugc nofollow" target="_blank"><em class="kv">https://shunsvineyard . info</em></a><em class="kv">。</em></p></div></div>    
</body>
</html>