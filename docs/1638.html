<html>
<head>
<title>Symmetric Cryptography: Stream Ciphers in JavaScipt</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">对称加密:JavaScipt 中的流密码</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/symmetric-cryptography-stream-ciphers-in-javascipt-fcda0c21f3a6?source=collection_archive---------21-----------------------#2021-03-29">https://medium.com/nerd-for-tech/symmetric-cryptography-stream-ciphers-in-javascipt-fcda0c21f3a6?source=collection_archive---------21-----------------------#2021-03-29</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/85c817c7df60a68300a694c752e7c83d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uFme60UPDkG0jfLsDQY6tA.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">数字钥匙</figcaption></figure><p id="f1d8" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">对称密码术，特别是加密，要求用相同的密钥对消息进行加密和解密。在这个保护伞下，我们发现流和分组密码。流密码一次处理一位，而块密码处理一组位。关于对称密码以及流密码和分组密码，已经有很多著述。本文是用现代 JavaScript 实现流密码的一个练习。重点是实现一个简单的密码和代码的可读性——不是速度也不是秘密。值得一提的是:如果您需要应用程序内部的安全性，请使用一个众所周知且经过测试的算法。然而，我鼓励你自己去试验和实现这些密码，这是一个很好的练习。</p><p id="56ce" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">该算法的基础是 XOR，这是一种布尔运算符，当被比较的两个位不同时返回真。它的特点是</p><pre class="js jt ju jv fd jw jx jy jz aw ka bi"><span id="32c4" class="kb kc hi jx b fi kd ke l kf kg">(a XOR b) XOR a == b</span></pre><p id="5a2e" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">这是很重要的，因为同一个密钥(a)可以应用一次来加密，然后再应用一次来解密。这是带反转的 XOR(右部)的真值表(左部是真值表)。你可以把<code class="du kh ki kj jx b">p</code>想成普通位，<code class="du kh ki kj jx b">k</code>想成密钥位，<code class="du kh ki kj jx b">c</code>想成密码位。</p><pre class="js jt ju jv fd jw jx jy jz aw ka bi"><span id="69fb" class="kb kc hi jx b fi kd ke l kf kg">p k | c  -&gt;  c k | p<br/>﻿---------------------<br/>1 1 | 0  -&gt;  0 1 | 1<br/>﻿1 0 | 1  -&gt;  1 0 | 1<br/>0 1 | 1  -&gt;  1 1 | 0<br/>0 0 | 0  -&gt;  1 0 | 0</span></pre><p id="c337" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">这种方法的关键(双关语)是密钥的大小(位数)和密钥的随机性(随机性是一个研究得很好的领域)。幸运的是，随机性不会影响密码的实现，但是长度对我们的实现很重要。一次性密码本是理想的，因为密钥大小与纯文本大小相同，提供了最大的安全性。然而，使用 OTP 代表了使其不切实际的挑战(大尺寸难以交换、产生…)。我们想要一种技术，它能够在一系列比特上循环，从末端绕回起点——一个环。永久的“生成器函数”(ES6 中引入的半协同程序)将完美地满足需求。</p><pre class="js jt ju jv fd jw jx jy jz aw ka bi"><span id="8823" class="kb kc hi jx b fi kd ke l kf kg">const ByteKeyRing = function *(byteLength, keyBitArray) {<br/>    <em class="kk">// store the length so we know when to wrap</em><br/>    const keyBitArrayLength = keyBitArray.length<br/><br/>    <em class="kk">// loop in perpetuity incrementing i</em><br/>    let i = 0<br/>    while(true) {<br/><br/>        <em class="kk">// build a byte according to the specified length</em><br/>        const byte = []<br/>        for(let n = 0; n &lt; byteLength; n++)<br/>        {<br/>            <em class="kk">// i mod keyBitArrayLength in {0..keyBitArrayLength-1}</em><br/>            const index = i % keyBitArrayLength<br/><br/>            <em class="kk">// store the bit</em><br/>            const bit = keyBitArray[index]<br/>            byte.push(bit)<br/>            i = i + 1<br/>        }<br/><br/>        <em class="kk">// return out a byte by joining to a string and parsing base 2</em><br/>        yield parseInt(byte.join(''),2)<br/>    }<br/>}</span></pre><p id="e69c" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">生成器函数接受一个字节长度和一个由 0 和 1 组成的数组。它遍历该数组，构建一个字节，并在填充后返回给调用者。重要的细节是下一个请求是从上一个请求停止的地方开始的，数组的迭代不是从头开始。模操作符为我们提供了一个很好的机制，让我们不必自己管理包装。考虑长度为 4 的输入数组:</p><pre class="js jt ju jv fd jw jx jy jz aw ka bi"><span id="5ed3" class="kb kc hi jx b fi kd ke l kf kg">i  <em class="kk">% 4 = x</em><br/>----------<br/>0  <em class="kk">% 4﻿ = 0</em><br/>1  <em class="kk">% 4 = 1  </em><br/>2  <em class="kk">% 4 = 2</em><br/>3  <em class="kk">% 4 = 3</em><br/>4  <em class="kk">% 4 = 0</em><br/>5  <em class="kk">% 4 = 1</em><br/>.<br/>.<br/>.﻿﻿﻿﻿﻿﻿<br/>﻿67 <em class="kk">% 4 = 3</em></span></pre><p id="4b52" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">随着 I 的增加(永久),如果我们以 4 为模，结果将总是在集合{0，1，2，3 }中。仔细观察戒指</p><pre class="js jt ju jv fd jw jx jy jz aw ka bi"><span id="389b" class="kb kc hi jx b fi kd ke l kf kg">const ring = ByteKeyRing(8, [0,0,1])<br/><br/>const thirtySix  = ring.next()<br/><em class="kk">//=&gt; 36 (00100100)</em><br/><br/>const oneFourtySix  = ring.next()<br/><em class="kk">//=&gt; 146 (10010010)</em><br/><br/>const seventyThree  = ring.next()<br/><em class="kk">//=&gt; 73 (01001001)</em><br/><br/>const thirtySixAgain = ring.next()<br/><em class="kk">//=&gt; 36 (00100100)</em></span></pre><p id="59a1" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">我们用数组<code class="du kh ki kj jx b">[0,0,1]</code>给环播种，产生垂直流<code class="du kh ki kj jx b">001001001001001001001001001001001…001</code>。如果我们把</p><ul class=""><li id="d19a" class="kl km hi iw b ix iy jb jc jf kn jj ko jn kp jr kq kr ks kt bi translated">左 8 个最高位(<code class="du kh ki kj jx b">00100100</code>)我们有值<code class="du kh ki kj jx b">36</code>，</li><li id="6f1f" class="kl km hi iw b ix ku jb kv jf kw jj kx jn ky jr kq kr ks kt bi translated">紧跟在该永续流之后的 8 个字节是(<code class="du kh ki kj jx b">10010010</code>)值<code class="du kh ki kj jx b">146</code>，</li><li id="40d7" class="kl km hi iw b ix ku jb kv jf kw jj kx jn ky jr kq kr ks kt bi translated">接下来是 8 个字节(<code class="du kh ki kj jx b">01001001</code>)的值<code class="du kh ki kj jx b">73</code></li><li id="0382" class="kl km hi iw b ix ku jb kv jf kw jj kx jn ky jr kq kr ks kt bi translated">然后整个序列重复。</li></ul><p id="4d2b" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">这种方法允许我们使用一个小密钥(在本例中是三位)来加密任意大小的消息。加密/解密由少量代码执行，该代码将 xor 应用于包含明文的缓冲区，返回密文缓冲区，其中密钥和明文缓冲区是输入(readBuffer、XOR、buffer of 是在<a class="ae kz" href="https://github.com/tb01923/understanding-cryptography/blob/master/ciphers/stream-cipher.js" rel="noopener ugc nofollow" target="_blank">源</a>中定义的帮助器):</p><pre class="js jt ju jv fd jw jx jy jz aw ka bi"><span id="4147" class="kb kc hi jx b fi kd ke l kf kg">const cipherBuffer = (keyByte, byteBuffer) =&gt; {<br/>    const plainByte = readBuffer(byteBuffer)<br/>    const cipherByte = xor(keyByte, plainByte)<br/>    const cipherByteBuffer = bufferOf(cipherByte)<br/>    return cipherByteBuffer<br/>}</span></pre><p id="c5f8" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">考虑到节点中对流的支持，流位是相当容易的。在这种情况下，我们利用转换流:</p><pre class="js jt ju jv fd jw jx jy jz aw ka bi"><span id="a426" class="kb kc hi jx b fi kd ke l kf kg">const { Transform } = require('stream');<br/><br/>const keyIterator = (byteKeyArray) =&gt; {<br/>    const byteSize = 8<br/>    const byteKeyRing = ByteKeyRing(byteSize, byteKeyArray)<br/>    return () =&gt; byteKeyRing.next().value<br/>}<br/><br/>const streamCipher = (byteKeyArray) =&gt;{<br/><br/>    const nextKey = keyIterator(byteKeyArray)<br/><br/>    return new Transform({<br/>        transform(byteBuffer, encoding, callback) {<br/><br/>            const keyByte = nextKey()<br/>            const cipherByteBuffer = cipherBuffer(<br/>                keyByte, byteBuffer)<br/>            this.push(cipherByteBuffer);<br/>            callback();<br/><br/>        }<br/>    });<br/>}</span></pre><p id="0752" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">这里，keyIterator 用于从中提取密钥环，从剩余的密码实现中提取生成器逻辑。这里真正的逻辑是这四行:</p><pre class="js jt ju jv fd jw jx jy jz aw ka bi"><span id="6254" class="kb kc hi jx b fi kd ke l kf kg">const keyByte = nextKey()<br/>const cipherByteBuffer = cipherBuffer(keyByte, byteBuffer)<br/><br/>this.push(cipherByteBuffer);<br/>callback();</span></pre><p id="8a50" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">本质上是三个步骤</p><ol class=""><li id="87d2" class="kl km hi iw b ix iy jb jc jf kn jj ko jn kp jr la kr ks kt bi translated">生成下一个密钥</li><li id="b315" class="kl km hi iw b ix ku jb kv jf kw jj kx jn ky jr la kr ks kt bi translated">获取输入缓冲区并对其执行加密</li><li id="7d58" class="kl km hi iw b ix ku jb kv jf kw jj kx jn ky jr la kr ks kt bi translated">沿着流向下移动它(推送和回调是 TransformStream 的内部工作方式)</li></ol><p id="8e01" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">要使用它，您可以用一个密钥实例化一个 streamCipher，并通过管道传输一些文本:</p><p id="e3dd" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">简单消息被转换成某种密码(同样，这是一种不安全的简单密码)。往返的 encrypt -&gt; decrypt 需要用相同的密钥(相同的密钥非常重要)实例化两个密码，通过一个密码(encrypt)然后通过另一个密码(decrypt)管道文本。</p><p id="aadc" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">真的就这么简单！这里的代码是<a class="ae kz" href="https://github.com/tb01923/understanding-cryptography" rel="noopener ugc nofollow" target="_blank">这里的</a>。</p></div><div class="ab cl lb lc gp ld" role="separator"><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg"/></div><div class="hb hc hd he hf"><p id="eafe" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><em class="kk">原载于</em><a class="ae kz" href="https://www.linkedin.com/pulse/symmetric-cryptography-approximating-stream-ciphers-javascipt-brown/" rel="noopener ugc nofollow" target="_blank"><em class="kk">https://www.linkedin.com</em></a><em class="kk">。</em></p></div></div>    
</body>
</html>