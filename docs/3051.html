<html>
<head>
<title>Prototype Design Pattern</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">原型设计模式</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/prototype-design-pattern-6bf52e3c6e63?source=collection_archive---------7-----------------------#2021-05-28">https://medium.com/nerd-for-tech/prototype-design-pattern-6bf52e3c6e63?source=collection_archive---------7-----------------------#2021-05-28</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div class="er es if"><img src="../Images/2cdff260ed9c6259226bfa53addbf519.png" data-original-src="https://miro.medium.com/v2/resize:fit:1360/format:webp/1*DLfddu1ynBDmlFeijnJNWw.png"/></div></figure><p id="025b" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">如你所知，这篇文章将是另一个设计模式，是原型设计模式，它是在创造类型下。我已经发表了两篇关于设计模式的文章。所以如果你是设计模式的新手，你可以参考这些文章。原型模式表示<strong class="io hj">克隆一个现有的对象，而不是创建一个新的，也可以根据需求</strong>定制。那么这意味着什么呢？我简单解释一下。比方说，我们有一个在线商店，所以当用户搜索一个产品，它会显示成千上万的项目的权利。因此克隆这些项目比创建更容易。我们可以创建第一个实例并注册它。当你需要一个实例时，你可以从原始实例中克隆它。不需要创建新的实例。在我以前的文章中，首先让我们通过一个简单的例子来学习原型设计模式。然后，在我们理解了基础知识之后，我们可以去找一个更高级的真实世界的例子。看看下面的UML图。</p><figure class="jl jm jn jo fd ij er es paragraph-image"><div class="er es jk"><img src="../Images/644c31cdadc73ff779d41192ce02e92c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1120/format:webp/1*yPgfkM5JZV7Dmv2QDtjYpQ.jpeg"/></div></figure><p id="019a" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">如上图所示，我们需要创建形状抽象类和其他具体类(这里的子类是圆形、正方形、矩形)。那么这些类应该从shape类扩展而来。接下来，我们需要创建ShapeCache类。在我们的ShapeCache类中，我们有方法调用get shape，它返回用户请求的形状的实例。用户请求是通过主类完成的。我们的PrototypePatternDemo类有一个main方法，它将使用ShapeCacshe来获取一个Shape对象。它会将信息(圆形/矩形/正方形)传递给ShapeCacshe，以获得它需要的对象类型。正如你所看到的，这是原型设计模式的基本概念。我不打算实现这个场景，因为所有的属性和方法都在UML图中清楚地提到了，所以你可以试试那个。</p><h2 id="0821" class="jp jq hi bd jr js jt ju jv jw jx jy jz ix ka kb kc jb kd ke kf jf kg kh ki kj bi translated">浅层拷贝与深层拷贝</h2><figure class="jl jm jn jo fd ij er es paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="er es kk"><img src="../Images/a46efe0cdb6182bdb8d6df1c90820d6c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cRe3J-4HOZkEbGU4zWlfdA.jpeg"/></div></div></figure><p id="dfcd" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">当您实现原型设计模式时，您需要确定您是需要浅层拷贝还是深层拷贝。浅层复制是通过创建一个新的集合对象并用对原始对象的子对象的引用填充它来完成的。因为复制操作不会递归，所以不会复制子对象。<strong class="io hj">浅拷贝存储原对象的拷贝，并指向原对象的引用。</strong> <strong class="io hj">简单来说就是对一个对象的副本所做的所有修改都反映在原对象中。</strong></p><p id="73f3" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">术语“深度复制”指的是递归复制过程。这意味着首先创建一个新的集合对象，然后用原始子对象的副本递归地填充它。<strong class="io hj">一个对象的副本被复制到深度副本中的另一个对象(位置)</strong>。<strong class="io hj">对对象副本的任何修改都不会反映在原始对象中。</strong></p></div><div class="ab cl kp kq gp kr" role="separator"><span class="ks bw bk kt ku kv"/><span class="ks bw bk kt ku kv"/><span class="ks bw bk kt ku"/></div><div class="hb hc hd he hf"><p id="6fe7" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">现在让我们看一个高级的真实世界的例子。有一家卖手表的商店叫神奇手表。那家商店有不同类型、不同型号、不同价格的手表可供选择。顾客可以到商店购买或通过网站在线购买。种类繁多。主要手表分为模拟手表、数字手表和智能手表。模拟手表只包含手表的基本功能。所以基本上这是传统手表。数字手表有闹钟和秒表。智能手表有一些传统手表没有的功能，如手表的存储、手表操作系统。</p><figure class="jl jm jn jo fd ij er es paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="er es kw"><img src="../Images/2ca85c2b84f1f3796e33c031ee285c9f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yQjufz-MjZoX_O5B4zWZ3w.jpeg"/></div></div></figure><p id="6262" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">让我们实现这个场景。首先，我实现了Watch类，并将其抽象。还实现了getters和setters。因为需要这些对象来从Cloneable接口克隆Watch类实现。</p><figure class="jl jm jn jo fd ij"><div class="bz dy l di"><div class="kx ky l"/></div></figure><p id="8771" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">然后，我创建了模拟、数字和智能手表的其他类，并从手表类扩展而来。我还实现了toString方法。</p><figure class="jl jm jn jo fd ij"><div class="bz dy l di"><div class="kx ky l"/></div></figure><figure class="jl jm jn jo fd ij"><div class="bz dy l di"><div class="kx ky l"/></div></figure><figure class="jl jm jn jo fd ij"><div class="bz dy l di"><div class="kx ky l"/></div></figure><p id="4a23" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">然后你必须实现一个枚举，如下所示。</p><figure class="jl jm jn jo fd ij"><div class="bz dy l di"><div class="kx ky l"/></div></figure><p id="a1c9" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">接下来，在WatchRegistry类中，我实现了名为Watches的HashMap。在WatchRegistry类中，我们有构造函数、getWatch方法和initialize()方法，如下所示。</p><figure class="jl jm jn jo fd ij"><div class="bz dy l di"><div class="kx ky l"/></div></figure><p id="63ad" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">在main类中，首先从WatchRegistry类创建一个实例。然后，您可以从这里的模拟、数字和智能子类中创建一个实例。接下来，您可以使用WatchRegistry实例调用watchRegistry类中的getWatch方法，并记住像下面这样进行转换。最后，您可以根据需要更改任何属性值。</p><figure class="jl jm jn jo fd ij"><div class="bz dy l di"><div class="kx ky l"/></div></figure><p id="df9f" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">程序的输出如下。</p><figure class="jl jm jn jo fd ij er es paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="er es kz"><img src="../Images/a63103c95b7e31c858b0f0d68b6f14a8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-airdoPJGAjBNOWxOfWqUA.png"/></div></div></figure><p id="fdbb" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">现在让我们来看看原型设计模式的优缺点。</p><h2 id="0042" class="jp jq hi bd jr js jt ju jv jw jx jy jz ix ka kb kc jb kd ke kf jf kg kh ki kj bi translated">原型设计模式的优势</h2><ol class=""><li id="b949" class="la lb hi io b ip lc it ld ix le jb lf jf lg jj lh li lj lk bi translated">它减少了分类的需要。</li><li id="2002" class="la lb hi io b ip ll it lm ix ln jb lo jf lp jj lh li lj lk bi translated">它隐藏了创建对象的复杂性。</li><li id="fa85" class="la lb hi io b ip ll it lm ix ln jb lo jf lp jj lh li lj lk bi translated">客户端可以获得新的对象，而不知道它将是哪种类型的对象。</li><li id="c181" class="la lb hi io b ip ll it lm ix ln jb lo jf lp jj lh li lj lk bi translated">它允许您在运行时添加或删除对象。</li></ol><h2 id="d227" class="jp jq hi bd jr js jt ju jv jw jx jy jz ix ka kb kc jb kd ke kf jf kg kh ki kj bi translated"><strong class="ak">原型设计模式的缺点</strong></h2><ol class=""><li id="715d" class="la lb hi io b ip lc it ld ix le jb lf jf lg jj lh li lj lk bi translated">对于使用很少对象和/或没有强调原型链扩展的项目来说，这是过度的。</li><li id="a2ec" class="la lb hi io b ip ll it lm ix ln jb lo jf lp jj lh li lj lk bi translated">它还对客户端隐藏了具体的产品类</li><li id="5291" class="la lb hi io b ip ll it lm ix ln jb lo jf lp jj lh li lj lk bi translated">Prototype的每个子类都必须实现clone()操作，当所考虑的类已经存在时，这可能很困难。此外，当clone()的内部包含不支持复制或具有循环引用的对象时，实现clone()会很困难。</li></ol><h2 id="fe3e" class="jp jq hi bd jr js jt ju jv jw jx jy jz ix ka kb kc jb kd ke kf jf kg kh ki kj bi translated">何时使用原型设计模式</h2><ol class=""><li id="5c0e" class="la lb hi io b ip lc it ld ix le jb lf jf lg jj lh li lj lk bi translated">当类在运行时被实例化时。</li><li id="1cf1" class="la lb hi io b ip ll it lm ix ln jb lo jf lp jj lh li lj lk bi translated">当创建一个对象的成本很高或很复杂时。</li><li id="da95" class="la lb hi io b ip ll it lm ix ln jb lo jf lp jj lh li lj lk bi translated">当您希望保持应用程序中的类数量最少时。</li><li id="fdb6" class="la lb hi io b ip ll it lm ix ln jb lo jf lp jj lh li lj lk bi translated">当客户端应用程序不需要知道对象的创建和表示时。</li></ol><p id="b420" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">您已到达这篇文章的结尾。所以我希望你了解原型设计模式，我将在接下来的博客中上传另一个设计模式。我已经上传了完整的代码到GitHub，我把链接放在了参考文献中，所以如果你想的话，你可以参考一下。那么是时候说再见了，让我们从另一篇文章中见面。</p></div><div class="ab cl kp kq gp kr" role="separator"><span class="ks bw bk kt ku kv"/><span class="ks bw bk kt ku kv"/><span class="ks bw bk kt ku"/></div><div class="hb hc hd he hf"><h1 id="19c5" class="lq jq hi bd jr lr ls lt jv lu lv lw jz lx ly lz kc ma mb mc kf md me mf ki mg bi translated">参考</h1><div class="mh mi ez fb mj mk"><a href="https://github.com/Dilshanushara/Krish_LP_Training/tree/master/Design%20Patterns/Pototype" rel="noopener  ugc nofollow" target="_blank"><div class="ml ab dw"><div class="mm ab mn cl cj mo"><h2 class="bd hj fi z dy mp ea eb mq ed ef hh bi translated">dilshanushara/Krish _ LP _ Training</h2><div class="mr l"><h3 class="bd b fi z dy mp ea eb mq ed ef dx translated">在GitHub上创建一个帐户，为Dilshanushara/Krish _ LP _ Training的发展做出贡献。</h3></div><div class="ms l"><p class="bd b fp z dy mp ea eb mq ed ef dx translated">github.com</p></div></div><div class="mt l"><div class="mu l mv mw mx mt my ik mk"/></div></div></a></div><figure class="jl jm jn jo fd ij"><div class="bz dy l di"><div class="mz ky l"/></div></figure><div class="mh mi ez fb mj mk"><a href="https://www.tutorialspoint.com/design_pattern/prototype_pattern.htm" rel="noopener  ugc nofollow" target="_blank"><div class="ml ab dw"><div class="mm ab mn cl cj mo"><h2 class="bd hj fi z dy mp ea eb mq ed ef hh bi translated">设计模式-原型模式</h2><div class="mr l"><h3 class="bd b fi z dy mp ea eb mq ed ef dx translated">原型模式是指在考虑性能的同时创建重复的对象。这种类型的设计模式…</h3></div><div class="ms l"><p class="bd b fp z dy mp ea eb mq ed ef dx translated">www.tutorialspoint.com</p></div></div><div class="mt l"><div class="na l mv mw mx mt my ik mk"/></div></div></a></div><div class="mh mi ez fb mj mk"><a href="https://www.geeksforgeeks.org/copy-python-deep-copy-shallow-copy/" rel="noopener  ugc nofollow" target="_blank"><div class="ml ab dw"><div class="mm ab mn cl cj mo"><h2 class="bd hj fi z dy mp ea eb mq ed ef hh bi translated">用Python复制(深层复制和浅层复制)- GeeksforGeeks</h2><div class="mr l"><h3 class="bd b fi z dy mp ea eb mq ed ef dx translated">在Python中，赋值语句不复制对象，它们在目标和对象之间创建绑定。当我们使用…</h3></div><div class="ms l"><p class="bd b fp z dy mp ea eb mq ed ef dx translated">www.geeksforgeeks.org</p></div></div><div class="mt l"><div class="nb l mv mw mx mt my ik mk"/></div></div></a></div></div></div>    
</body>
</html>