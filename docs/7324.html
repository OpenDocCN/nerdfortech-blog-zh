<html>
<head>
<title>Declutter Array.reduce()</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Declutter Array.reduce()</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/declutter-array-reduce-bf6087dccfb6?source=collection_archive---------1-----------------------#2022-09-26">https://medium.com/nerd-for-tech/declutter-array-reduce-bf6087dccfb6?source=collection_archive---------1-----------------------#2022-09-26</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="d05b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">许多人说在代码中使用<strong class="ih hj"> Reduce </strong>方法会使代码变得混乱。因此，许多专家建议尽可能避免它。但是把这些建议放在一边。我们现在明白了。记住，它仍然是 Javascript 中数组的内置方法。</p><p id="ba85" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">减少</strong> =多对一。它用于数组。所以在这里，<strong class="ih hj"> <em class="jd">多</em> </strong>指数组中的元素，<strong class="ih hj"> <em class="jd">一</em> </strong>指输出(结果)。该输出由<strong class="ih hj"> Reduce 方法给出。</strong></p><figure class="jf jg jh ji fd jj er es paragraph-image"><div class="er es je"><img src="../Images/3856df40ac8bd6da0791400a1f14ba10.png" data-original-src="https://miro.medium.com/v2/resize:fit:1264/format:webp/0*U-z2BvQjbfL8PYIB.png"/></div></figure><p id="61ce" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Reduce 是一个接受一个<strong class="ih hj">回调</strong>函数和<strong class="ih hj">初始值</strong>的方法。</p><pre class="jf jg jh ji fd jm jn jo jp aw jq bi"><span id="cb2f" class="jr js hi jn b fi jt ju l jv jw">Array.reduce(<strong class="jn hj">() =&gt; {}</strong> , <strong class="jn hj">initialValue</strong>) --&gt; Callback and initial value</span></pre><p id="4f1d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">该初始值决定输出或结果或单个(一个)最终值。</p><p id="4a9e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果，</p><blockquote class="jx jy jz"><p id="3764" class="if ig jd ih b ii ij ik il im in io ip ka ir is it kb iv iw ix kc iz ja jb jc hb bi translated">初始值=数字，那么输出是一个单一的数字。</p><p id="9556" class="if ig jd ih b ii ij ik il im in io ip ka ir is it kb iv iw ix kc iz ja jb jc hb bi translated">初始值= Object {}，那么输出的是单个对象。</p><p id="0c0d" class="if ig jd ih b ii ij ik il im in io ip ka ir is it kb iv iw ix kc iz ja jb jc hb bi translated">初始值= Array []，那么输出是一个单数组。</p></blockquote><p id="9a0b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们在处理数组，我们在数组元素上做运算。每次操作都会给你一个结果。我们需要这样的结果吗？停下来深思！</p><p id="972f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">当然可以！但是为什么呢？因为我们是把很多元素转化成一个元素。所以每个操作都基于前一个元素的操作结果。听起来很困惑，对吧？</p><p id="6bb6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">记住:在第一次迭代时，我们没有先前的迭代结果，因此，我们给出初始值。</p><h2 id="23f6" class="jr js hi bd kd ke kf kg kh ki kj kk kl iq km kn ko iu kp kq kr iy ks kt ku kv bi translated">手术在哪里进行？</h2><p id="862d" class="pw-post-body-paragraph if ig hi ih b ii kw ik il im kx io ip iq ky is it iu kz iw ix iy la ja jb jc hb bi translated">在回调函数内部(函数包含要执行的操作和变量)。该函数必须使用以前的结果值，所以我们需要一个变量来存储结果。根据这个结果，完成后续操作。这个变量是回调函数的第一个参数，通常称为<strong class="ih hj">‘累加器’。</strong></p><p id="862f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">因为我们处理数组，所以第二个和第三个参数将分别是数组和索引中的当前元素——这种描述已经够无聊的了。我们来看一个经典的例子。</p><pre class="jf jg jh ji fd jm jn jo jp aw jq bi"><span id="a137" class="jr js hi jn b fi jt ju l jv jw">const arr = [1,2,3]  </span><span id="a8a4" class="jr js hi jn b fi lb ju l jv jw">// Syntax <br/>// Array.reduce(<strong class="jn hj">() =&gt; {}</strong> , <strong class="jn hj">initialValue</strong>) --&gt; Callback and initial value  </span><span id="de8f" class="jr js hi jn b fi lb ju l jv jw">//Callback parameters --&gt; accumulator(previous result),current element in a array, index.  <br/>// We will add all the elements in an array with an initial value of <strong class="jn hj">0</strong> </span><span id="be9b" class="jr js hi jn b fi lb ju l jv jw">const reduced = arr.reduce((acc,elem,index) =&gt; {     console.log('acc',acc)     <br/>console.log('elem',elem)     <br/>console.log('index',index)     <br/><strong class="jn hj">return acc + elem</strong> <br/>},0)  </span><span id="f95a" class="jr js hi jn b fi lb ju l jv jw">console.log('The final output is',reduced)  </span><span id="920e" class="jr js hi jn b fi lb ju l jv jw">// Output is <br/>acc 0 ---&gt;First iteration value will be initial value <br/>elem 1 <br/>index 0  </span><span id="cbb2" class="jr js hi jn b fi lb ju l jv jw">acc 1 --&gt; 0+1(Form previous result) --&gt; <strong class="jn hj">acc + elem</strong> <br/>elem 2 <br/>index 1 </span><span id="66cd" class="jr js hi jn b fi lb ju l jv jw">acc 3 --&gt;  1+2(From previous result) --&gt; <strong class="jn hj">acc + elem</strong> <br/>elem 3 <br/>index 2 <strong class="jn hj"> </strong></span><span id="4236" class="jr js hi jn b fi lb ju l jv jw"><strong class="jn hj">The final output is 6 --&gt; Result of the output is equal to the final accumulator value(3+3) because no element to process further in the array.</strong></span></pre><p id="359a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们改变初始值，</p><pre class="jf jg jh ji fd jm jn jo jp aw jq bi"><span id="6bbf" class="jr js hi jn b fi jt ju l jv jw">const arr = [1,2,3]; </span><span id="ee25" class="jr js hi jn b fi lb ju l jv jw">const reduced = arr.reduce((acc,elem) =&gt; {     <br/><strong class="jn hj">return acc + elem</strong> <br/>},<strong class="jn hj">100</strong>)  </span><span id="ffd3" class="jr js hi jn b fi lb ju l jv jw">console.log('The final output is',reduced)  </span><span id="e938" class="jr js hi jn b fi lb ju l jv jw"><strong class="jn hj">// Prints value <em class="jd">106 </em></strong> <strong class="jn hj">because when it enters the callback function for the first iteration, it will have <em class="jd">acc </em>value of <em class="jd">100 </em>= <em class="jd">initial value</em></strong></span></pre><p id="a7db" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">注</strong>:</p><ul class=""><li id="90ba" class="lc ld hi ih b ii ij im in iq le iu lf iy lg jc lh li lj lk bi translated">在第一次迭代时，<strong class="ih hj"> acc </strong> = <strong class="ih hj">初始值。所以两者都是必修的。</strong></li><li id="fae3" class="lc ld hi ih b ii ll im lm iq ln iu lo iy lp jc lh li lj lk bi translated">然后回调函数中的第二个参数是它将要处理的数组中的当前<strong class="ih hj">元素</strong>。</li></ul><p id="469c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们复杂一点，比如一个属性名为<strong class="ih hj">‘Price’的对象数组。我们需要总价。</strong></p><pre class="jf jg jh ji fd jm jn jo jp aw jq bi"><span id="fdd4" class="jr js hi jn b fi jt ju l jv jw">const arr = [ { price:100, }, { price:200, }, { price:300, }, ];  </span><span id="c15c" class="jr js hi jn b fi lb ju l jv jw">const reduced = arr.reduce((acc,elem) =&gt; { <br/>return acc + elem.price <br/>},0)  </span><span id="4367" class="jr js hi jn b fi lb ju l jv jw">console.log('The total value is',reduced) <br/>// Outputs --&gt;<strong class="jn hj"> The total value is 600</strong></span></pre><p id="47cc" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">对于嵌套对象，</p><pre class="jf jg jh ji fd jm jn jo jp aw jq bi"><span id="72b1" class="jr js hi jn b fi jt ju l jv jw">const arr = <br/>[ <br/>{ product:<strong class="jn hj">{ name:'Shirt', price:2000 }</strong> }, <br/>{ product:{ name:'Pant', price:1000 } }, <br/>{ product:{ name:'Shoe', price:1500 } }<br/>];  </span><span id="093c" class="jr js hi jn b fi lb ju l jv jw">const <strong class="jn hj">reduced </strong>= arr.reduce((acc,elem) =&gt; {  <br/><strong class="jn hj">let {product} = elem; --&gt; Destructuring first level <br/>return acc + product.price</strong>  <br/>},0)  </span><span id="6252" class="jr js hi jn b fi lb ju l jv jw">console.log('The total value is',reduced) <br/>// Outputs --&gt;<strong class="jn hj"> The total value is 4500</strong></span></pre><p id="3984" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们在一个数组中求最小值和最大值，</p><p id="35bb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们将把初始最大值改为数组中的第一个元素，然后检查数组中的每个元素。</p><p id="b681" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">const arr = [100，30，9，0，200，90，10，25]</p><pre class="jf jg jh ji fd jm jn jo jp aw jq bi"><span id="4410" class="jr js hi jn b fi jt ju l jv jw">const arr = [100,30,9,0,200,90,10,25];  </span><span id="9de2" class="jr js hi jn b fi lb ju l jv jw">const reduced = arr.reduce((acc,elem,index) =&gt; { </span><span id="cae5" class="jr js hi jn b fi lb ju l jv jw">// only enters if the current maximum(acc) is less than current element  <br/>if(acc&lt;elem) {  <br/>acc = elem  return acc  <br/>} </span><span id="5305" class="jr js hi jn b fi lb ju l jv jw">// enters current maximum is greater  <br/>else {   <br/>return acc;  <br/>}  </span><span id="92b8" class="jr js hi jn b fi lb ju l jv jw">},arr[0]) <br/>// First value of array    </span><span id="bec0" class="jr js hi jn b fi lb ju l jv jw">console.log(reduced)   <strong class="jn hj"> //Prints 200</strong></span></pre><p id="98d5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">至少，</p><pre class="jf jg jh ji fd jm jn jo jp aw jq bi"><span id="7460" class="jr js hi jn b fi jt ju l jv jw">const arr = [100,30,9,0,200,90,10,25];  </span><span id="823d" class="jr js hi jn b fi lb ju l jv jw">const reduced = arr.reduce((acc,elem,index) =&gt; { </span><span id="73ea" class="jr js hi jn b fi lb ju l jv jw">// only enters if the current minimum(acc) is greater than current element  <br/>if(acc&gt;elem) {  <br/>acc = elem  return acc  <br/>}  </span><span id="08c0" class="jr js hi jn b fi lb ju l jv jw">// enters current maximum is greater  <br/>else {   <br/>return acc;  <br/>}  <br/>},arr[0]) // First value of array    </span><span id="ea60" class="jr js hi jn b fi lb ju l jv jw">console.log(reduced)   <strong class="jn hj"> // Prints 0</strong></span></pre><p id="4ddb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们将减少一组对象，</p><p id="53f1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">典型的电子商务问题，每个项目的数量被添加到购物车。</p><pre class="jf jg jh ji fd jm jn jo jp aw jq bi"><span id="3946" class="jr js hi jn b fi jt ju l jv jw">const arr = [ <br/>{ product:<strong class="jn hj">{ name:'Shirt', price:2000 }</strong> }, <br/>{ product:{ name:'Pant', price:1000 } }, <br/>{ product:{ name:'Shoe', price:1500 } }, <br/>{ product:{ name:'Shoe', price:1500 } }, <br/>{ product:{ name:'Pant', price:1000 } }, <br/>{ product:{ name:'Pant', price:1000 } }, <br/>{ product:{ name:'Shirt', price:2000, } <br/>}, ];</span></pre><p id="6cab" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们仔细看看结构。</p><p id="f736" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">是数组吗？是的。所以我们可以减少它！</p><p id="63d7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">结构是什么？对象的数组。</p><p id="5dee" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们在第一层有预期的属性吗？不，它是嵌套的。</p><p id="28a5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">完整的结构是什么？</p><pre class="jf jg jh ji fd jm jn jo jp aw jq bi"><span id="f174" class="jr js hi jn b fi jt ju l jv jw">[ { <br/>   product:{     <br/>         name:...,     <br/>         price:...     <br/>      } <br/>  }<br/>]</span></pre><p id="daee" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们需要找到什么？每个产品在此数组中出现的次数。</p><p id="3b33" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="jd">最后的输出应该是在</em> <strong class="ih hj"> <em class="jd">对象</em> </strong> <em class="jd">与</em> <strong class="ih hj"> <em class="jd">键</em> </strong> <em class="jd">为</em> <strong class="ih hj"> <em class="jd">产品名称</em></strong><em class="jd"/><strong class="ih hj"><em class="jd">值</em></strong><em class="jd"/><strong class="ih hj"><em class="jd">中它出现的次数</em> </strong> <em class="jd">。</em></p><p id="95ec" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们使用动态密钥计算和扩展操作符，因为每次迭代都会检查密钥并保留已经计算的属性和值。这将存储在<em class="jd">累加器</em>中，用于下一次迭代，最后一次迭代结果将被输出。</p><p id="ce64" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">检查键=动态键。</p><p id="316b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在 object = Spread 运算符中保留先前输出的结果。</p><pre class="jf jg jh ji fd jm jn jo jp aw jq bi"><span id="de3f" class="jr js hi jn b fi jt ju l jv jw">const reduced = arr.reduce((acc,elem) =&gt; {  </span><span id="7242" class="jr js hi jn b fi lb ju l jv jw">let {product} = elem;  </span><span id="d7ce" class="jr js hi jn b fi lb ju l jv jw">if(!acc[product.name]) { <br/>// using dynamic keys [product.name] and spread operator (...acc) return {...acc,[product.name]:1} <br/>}  </span><span id="d9ec" class="jr js hi jn b fi lb ju l jv jw">else { <br/>return {...acc,[product.name]: acc[product.name] + 1} <br/>}  </span><span id="4e6b" class="jr js hi jn b fi lb ju l jv jw">},<strong class="jn hj">{}</strong>)  <br/>// Final output is reduced to single object and hence initial value is empty object</span></pre><p id="71b6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我解释一下这里的逻辑，</p><p id="ab22" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果密钥在输出对象中不可用→ <strong class="ih hj"> if(！acc[poduct.name])。</strong></p><p id="8d9b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">注意:第一次迭代→将是空对象{} </strong></p><p id="c088" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">请复制已经计算的值(键和值)并用值<strong class="ih hj">‘1’初始化一个新的键。</strong></p><p id="8a82" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">= <strong class="ih hj"> { </strong></p><p id="9852" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> …acc，</strong></p><p id="0e37" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">【产品名称】:1 </strong></p><p id="4a92" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> } </strong></p><p id="80a5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">否则，</p><p id="5f1f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">复制已经计算的值(键和值)并<strong class="ih hj">添加</strong>一个带有<strong class="ih hj">‘1’=</strong>的特定键</p><p id="d7e4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> { </strong></p><p id="2d30" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> …acc，</strong></p><p id="7526" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">【产品名称】:acc【产品名称】+ 1 </strong></p><p id="c580" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> } </strong></p><p id="84e4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">所以输出是，</p><pre class="jf jg jh ji fd jm jn jo jp aw jq bi"><span id="751e" class="jr js hi jn b fi jt ju l jv jw">{Shirt:1, Pant:3, Shoe:2}</span></pre><p id="2227" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们将产品名称添加到一个数组中。</p><pre class="jf jg jh ji fd jm jn jo jp aw jq bi"><span id="5c05" class="jr js hi jn b fi jt ju l jv jw">const reduced = arr.reduce((acc,elem) =&gt; {    <br/>let {product} = elem;     <br/>   <br/>// Since we initialize it as an <strong class="jn hj">array</strong>, we can use the <strong class="jn hj">push </strong>method       acc.push(product.name)        <br/>return acc <br/>},<strong class="jn hj">[]</strong>)</span><span id="efe4" class="jr js hi jn b fi lb ju l jv jw">console.log(reduced) <br/>//[ 'Shirt', 'Pant', 'Shoe', 'Shoe', 'Pant', 'Pant', 'Shirt' ]</span></pre><p id="4ea6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">因为我们可以像上面一样从原始数组创建另一个数组，所以我们可以使用<strong class="ih hj"> reduce </strong>对一个数组进行<strong class="ih hj"> map </strong>操作。让我们对数组中的每个元素求平方。</p><pre class="jf jg jh ji fd jm jn jo jp aw jq bi"><span id="bb05" class="jr js hi jn b fi jt ju l jv jw">const arr = [5,10,15,20,25];  </span><span id="3c33" class="jr js hi jn b fi lb ju l jv jw">const reduced = arr.reduce((acc,elem) =&gt; {     <br/>let squared = elem * elem     <br/>acc.push(squared)     <br/>return acc <br/>},<strong class="jn hj">[]</strong>)  </span><span id="2c0e" class="jr js hi jn b fi lb ju l jv jw">console.log(reduced)</span></pre><p id="58cb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">输出是</p><pre class="jf jg jh ji fd jm jn jo jp aw jq bi"><span id="7709" class="jr js hi jn b fi jt ju l jv jw">[ 25, 100, 225, 400, 625 ]</span></pre><p id="bc4b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">类似地，我们可以使用 reduce 过滤数组，</p><pre class="jf jg jh ji fd jm jn jo jp aw jq bi"><span id="1447" class="jr js hi jn b fi jt ju l jv jw">const arr = [5,10,15,20,25];  </span><span id="eff4" class="jr js hi jn b fi lb ju l jv jw">const reduced = arr.reduce((acc,elem) =&gt; { </span><span id="4e89" class="jr js hi jn b fi lb ju l jv jw">if(elem &gt; 15) { <br/>acc.push(elem) <br/>return acc <br/>} </span><span id="b2ae" class="jr js hi jn b fi lb ju l jv jw">else { <br/>return acc <br/>} <br/>},<strong class="jn hj">[]</strong>)</span></pre><p id="a0ae" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">输出是，</p><pre class="jf jg jh ji fd jm jn jo jp aw jq bi"><span id="6fa4" class="jr js hi jn b fi jt ju l jv jw">[ 20, 25 ] // Values greater than 15</span></pre><p id="ff77" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="jd">原载于 2022 年 9 月 26 日 https://www.pansofarjun.com</em><a class="ae lq" href="https://www.pansofarjun.com/post/declutter-array-reduce" rel="noopener ugc nofollow" target="_blank"><em class="jd"/></a><em class="jd">。</em></p></div></div>    
</body>
</html>