<html>
<head>
<title>Swift Leetcode Series: Flatten Nested List Iterator</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Swift Leetcode系列:扁平嵌套列表迭代器</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/swift-leetcode-series-flatten-nested-list-iterator-cfcfa88d53dd?source=collection_archive---------12-----------------------#2021-04-13">https://medium.com/nerd-for-tech/swift-leetcode-series-flatten-nested-list-iterator-cfcfa88d53dd?source=collection_archive---------12-----------------------#2021-04-13</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="1e8c" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">4月Leetcode挑战赛:Swift第13天解决方案(Leetcode 341)</h2></div><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ix"><img src="../Images/2241290ba7dab61fe8be0508d20038a9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pK09EOc9eCPIxCrlSX9YJg.png"/></div></div></figure><div class="jj jk ez fb jl jm"><a href="https://theswiftnerd.com/flatten-nested-list-iterator/" rel="noopener  ugc nofollow" target="_blank"><div class="jn ab dw"><div class="jo ab jp cl cj jq"><h2 class="bd hj fi z dy jr ea eb js ed ef hh bi translated">展平嵌套列表迭代器(Leetcode 341)</h2><div class="jt l"><h3 class="bd b fi z dy jr ea eb js ed ef dx translated">难度:链接:April Leetcoding第13天给你一个整数嵌套列表nested list。每个元素都是…</h3></div><div class="ju l"><p class="bd b fp z dy jr ea eb js ed ef dx translated">theswiftnerd.com</p></div></div><div class="jv l"><div class="jw l jx jy jz jv ka jh jm"/></div></div></a></div><p id="8cd2" class="pw-post-body-paragraph kb kc hi kd b ke kf ij kg kh ki im kj kk kl km kn ko kp kq kr ks kt ku kv kw hb bi translated">您也可以通过上面的链接阅读Swift Nerd博客上的完整故事，以了解其他语言的更多信息。</p><h1 id="f02c" class="kx ky hi bd kz la lb lc ld le lf lg lh io li ip lj ir lk is ll iu lm iv ln lo bi translated">问题描述</h1><p id="05ea" class="pw-post-body-paragraph kb kc hi kd b ke lp ij kg kh lq im kj kk lr km kn ko ls kq kr ks lt ku kv kw hb bi translated">给你一个嵌套的整数列表<code class="du lu lv lw lx b">nestedList</code>。每个元素要么是整数，要么是列表，列表的元素也可以是整数或其他列表。实现一个迭代器将其扁平化。</p><p id="e26b" class="pw-post-body-paragraph kb kc hi kd b ke kf ij kg kh ki im kj kk kl km kn ko kp kq kr ks kt ku kv kw hb bi translated">实现<code class="du lu lv lw lx b">NestedIterator</code>类:</p><ul class=""><li id="9009" class="ly lz hi kd b ke kf kh ki kk ma ko mb ks mc kw md me mf mg bi translated"><code class="du lu lv lw lx b">NestedIterator(List&lt;NestedInteger&gt; nestedList)</code>用嵌套列表<code class="du lu lv lw lx b">nestedList</code>初始化迭代器。</li><li id="fba4" class="ly lz hi kd b ke mh kh mi kk mj ko mk ks ml kw md me mf mg bi translated"><code class="du lu lv lw lx b">int next()</code>返回嵌套列表中的下一个整数。</li><li id="c074" class="ly lz hi kd b ke mh kh mi kk mj ko mk ks ml kw md me mf mg bi translated">如果嵌套列表中还有一些整数，则<code class="du lu lv lw lx b">boolean hasNext()</code>返回<code class="du lu lv lw lx b">true</code>，否则返回<code class="du lu lv lw lx b">false</code>。</li></ul><h1 id="b1e0" class="kx ky hi bd kz la lb lc ld le lf lg lh io li ip lj ir lk is ll iu lm iv ln lo bi translated">例子</h1><p id="6381" class="pw-post-body-paragraph kb kc hi kd b ke lp ij kg kh lq im kj kk lr km kn ko ls kq kr ks lt ku kv kw hb bi translated"><strong class="kd hj">例1: </strong></p><pre class="iy iz ja jb fd mm lx mn mo aw mp bi"><span id="71a2" class="mq ky hi lx b fi mr ms l mt mu"><strong class="lx hj">Input:</strong> nestedList = [[1,1],2,[1,1]]<br/><strong class="lx hj">Output:</strong> [1,1,2,1,1]<br/><strong class="lx hj">Explanation:</strong> By calling next repeatedly until hasNext returns false, the order of elements returned by next should be: [1,1,2,1,1].</span></pre><p id="52a0" class="pw-post-body-paragraph kb kc hi kd b ke kf ij kg kh ki im kj kk kl km kn ko kp kq kr ks kt ku kv kw hb bi translated"><strong class="kd hj">例2: </strong></p><pre class="iy iz ja jb fd mm lx mn mo aw mp bi"><span id="0a31" class="mq ky hi lx b fi mr ms l mt mu"><strong class="lx hj">Input:</strong> nestedList = [1,[4,[6]]]<br/><strong class="lx hj">Output:</strong> [1,4,6]<br/><strong class="lx hj">Explanation:</strong> By calling next repeatedly until hasNext returns false, the order of elements returned by next should be: [1,4,6].</span></pre><h1 id="6bc2" class="kx ky hi bd kz la lb lc ld le lf lg lh io li ip lj ir lk is ll iu lm iv ln lo bi translated">限制</h1><ul class=""><li id="d4aa" class="ly lz hi kd b ke lp kh lq kk mv ko mw ks mx kw md me mf mg bi translated"><code class="du lu lv lw lx b">1 &lt;= nestedList.length &lt;= 500</code></li><li id="50ff" class="ly lz hi kd b ke mh kh mi kk mj ko mk ks ml kw md me mf mg bi translated">嵌套列表中的整数值在范围<code class="du lu lv lw lx b">[-106, 106]</code>内。</li></ul><h1 id="fa40" class="kx ky hi bd kz la lb lc ld le lf lg lh io li ip lj ir lk is ll iu lm iv ln lo bi translated">解决办法</h1><p id="ddb3" class="pw-post-body-paragraph kb kc hi kd b ke lp ij kg kh lq im kj kk lr km kn ko ls kq kr ks lt ku kv kw hb bi translated">这个问题本质上非常简单，因为如果你仔细观察，就会发现这正是交互协议所做的事情。如果您对数组、集合或任何其他集合或序列使用<code class="du lu lv lw lx b">for</code>–<code class="du lu lv lw lx b">in</code>循环，那么您已经在使用该类型的迭代器了(当然使用了语法糖)。</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="my mz l"/></div></figure><p id="7a1e" class="pw-post-body-paragraph kb kc hi kd b ke kf ij kg kh ki im kj kk kl km kn ko kp kq kr ks kt ku kv kw hb bi translated">在幕后，系统使用makeIterator()创建一个迭代器，并对序列重复调用next()。由于序列协议有一个相关类型的<em class="na"> IteratorProtocol </em>，你永远不必担心下一个元素是如何计算的。</p><p id="f664" class="pw-post-body-paragraph kb kc hi kd b ke kf ij kg kh ki im kj kk kl km kn ko kp kq kr ks kt ku kv kw hb bi translated">第一直觉可能是直接使用<strong class="kd hj"> flatmap() </strong>操作符，但是您应该再考虑一下。所有高阶运算符都在<em class="na">序列</em>协议上定义，该协议本身符合<em class="na">迭代协议</em>。这里的前提是，你必须实现迭代器的功能。所以如果你在面试中被问到这个问题，一定要先和你的面试官核实一下。</p><p id="4746" class="pw-post-body-paragraph kb kc hi kd b ke kf ij kg kh ki im kj kk kl km kn ko kp kq kr ks kt ku kv kw hb bi translated">解决方案很简单，我们可以有一个存储整数列表的属性和一个维护当前索引的属性。初始化时，我们可以以深度优先的方式递归遍历嵌套列表。接下来要做的就是简单地检查一个元素是整数还是嵌套列表。你可能会被诱惑使用条件施法<strong class="kd hj">T3作为？ </strong> <em class="na"> Int </em>，然而这是行不通的。为什么？因为NestedInteger是一个私有类而Int是一个struct。可以发现有实用方法<strong class="kd hj"> isInteger() </strong>和<strong class="kd hj"> getInteger() </strong>解决了我们的问题。我们可以创建一个递归函数来追加所有整数，并在嵌套列表中递归调用它自己。</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="my mz l"/></div></figure><p id="007f" class="pw-post-body-paragraph kb kc hi kd b ke kf ij kg kh ki im kj kk kl km kn ko kp kq kr ks kt ku kv kw hb bi translated">为了获取下一个元素，我们可以简单地使用<strong class="kd hj"> defer </strong>在返回当前元素后增加计数。HasNext()非常简单，因为我们只需要比较currentIndex和list count。</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="my mz l"/></div></figure><h2 id="fed0" class="mq ky hi bd kz nb nc nd ld ne nf ng lh kk nh ni lj ko nj nk ll ks nl nm ln nn bi translated">最终代码</h2><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="my mz l"/></div></figure><h1 id="3e3b" class="kx ky hi bd kz la lb lc ld le lf lg lh io li ip lj ir lk is ll iu lm iv ln lo bi translated">复杂性</h1><p id="4326" class="pw-post-body-paragraph kb kc hi kd b ke lp ij kg kh lq im kj kk lr km kn ko ls kq kr ks lt ku kv kw hb bi translated">Time = <strong class="kd hj"> O(N) </strong>:其中N是元素的总数</p><p id="2074" class="pw-post-body-paragraph kb kc hi kd b ke kf ij kg kh ki im kj kk kl km kn ko kp kq kr ks kt ku kv kw hb bi translated">空间= <strong class="kd hj"> O(N) </strong></p></div><div class="ab cl no np gp nq" role="separator"><span class="nr bw bk ns nt nu"/><span class="nr bw bk ns nt nu"/><span class="nr bw bk ns nt"/></div><div class="hb hc hd he hf"><p id="74c2" class="pw-post-body-paragraph kb kc hi kd b ke kf ij kg kh ki im kj kk kl km kn ko kp kq kr ks kt ku kv kw hb bi translated">感谢您的阅读。如果你喜欢这篇文章，并发现它很有用，请分享并像野火一样传播它！</p><p id="279c" class="pw-post-body-paragraph kb kc hi kd b ke kf ij kg kh ki im kj kk kl km kn ko kp kq kr ks kt ku kv kw hb bi translated">你可以在<a class="ae nv" href="https://theswiftnerd.com/" rel="noopener ugc nofollow" target="_blank">the swift nerd</a>|<a class="ae nv" href="https://www.linkedin.com/in/varunrathi28/" rel="noopener ugc nofollow" target="_blank">LinkedIn</a>|<a class="ae nv" href="https://github.com/varunrathi28" rel="noopener ugc nofollow" target="_blank">Github</a>上找到我</p></div></div>    
</body>
</html>