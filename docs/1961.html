<html>
<head>
<title>Predicting heart disease through machine learning</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">通过机器学习预测心脏病</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/predicting-heart-diseases-through-machine-learning-6f867a674078?source=collection_archive---------12-----------------------#2021-04-14">https://medium.com/nerd-for-tech/predicting-heart-diseases-through-machine-learning-6f867a674078?source=collection_archive---------12-----------------------#2021-04-14</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="d7f5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">分类问题是最常见的领域之一，机器学习算法在其中得到了很好的应用。回归问题和分类问题的最大区别在于，在分类问题中，目标变量是分类变量/二元变量。</p><p id="ff62" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在本文中，我们将查看由UCI机器学习知识库发布的心率疾病数据集，其中目标变量是心脏病。我们将讨论多种算法，还将了解增强如何改善模型结果。</p><p id="3b4b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">该数据集具有多个分类和连续的独立变量，可用于预测患者的心脏病。在完成识别缺失值(如果有)的过程后，我们将继续进行EDA以识别数据中的任何模式。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es jd"><img src="../Images/d4820f0715056034c1b0a86a95d40c62.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NNAL8SeaH5KHIwHePFVBZg.png"/></div></div><figcaption class="jp jq et er es jr js bd b be z dx translated">左:年龄分布右:年龄与目标</figcaption></figure><p id="7de7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">从上图可以看出，年轻人比老年人更容易患心脏病，这很令人惊讶。让我们看看性别是否对心脏病有影响</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es jt"><img src="../Images/e393cfde04836e291206567e9e419ba6.png" data-original-src="https://miro.medium.com/v2/resize:fit:744/format:webp/1*ZBWA7X3aAx2u6hQEwOcMSg.png"/></div><figcaption class="jp jq et er es jr js bd b be z dx translated">男性:0女性:1</figcaption></figure><p id="013c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">从上图可以看出，男性比女性更容易患心脏病。我们还可以看到胆固醇是如何影响心脏病发病率的</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es ju"><img src="../Images/ee5cdab2ff924b3319424a9d1e721b0d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hMtRk2L0U3koTUrgTr2gbA.png"/></div></div><figcaption class="jp jq et er es jr js bd b be z dx translated">胆固醇对心脏病的影响</figcaption></figure><p id="338e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">从上面的图表可以看出，胆固醇本身并不会对心脏病产生巨大的影响。EDA是数据科学的重要组成部分，它的重要性经常被低估。对于本文，我们将继续构建实际的模型。然而，在我们移动之前，我们也可以通过关联矩阵来更好地了解整体数据。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es jv"><img src="../Images/e8bc58ac9f2bd048e2e0d45c55a771b5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*P0HOWBOii0G3lDrKnf4mbw.png"/></div></div><figcaption class="jp jq et er es jr js bd b be z dx translated">相关矩阵</figcaption></figure><h1 id="3d7d" class="jw jx hi bd jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt bi translated">特征工程</h1><p id="34ce" class="pw-post-body-paragraph if ig hi ih b ii ku ik il im kv io ip iq kw is it iu kx iw ix iy ky ja jb jc hb bi translated">在建立模型之前，一定要确保独立变量的设计能够提高模型的性能。对于分类特征，我们需要将它们转换成虚拟变量，代码如下所示。</p><pre class="je jf jg jh fd kz la lb lc aw ld bi"><span id="f1b8" class="le jx hi la b fi lf lg l lh li">df=pd.get_dummies(df,columns=['cp','restecg','slope','ca','thal'],drop_first=<strong class="la hj">True</strong>)<br/>y=df.target<br/>X=df.drop("target",axis=1)</span></pre><p id="5d6c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">此外，对于连续变量，重要的是将它们标准化以提高模型性能。在这种转换中需要注意的一件重要事情是在标准化之前分离训练集和测试集。对于训练集，我们将使用scikit库中的StandardScaler，然后在测试集中对其进行转换，</p><pre class="je jf jg jh fd kz la lb lc aw ld bi"><span id="4277" class="le jx hi la b fi lf lg l lh li"><strong class="la hj">from</strong> <strong class="la hj">sklearn.preprocessing</strong> <strong class="la hj">import</strong> StandardScaler<br/>scaler=StandardScaler()<br/>num_columns=['age','trestbps','chol','thalach','oldpeak']<br/>X_train['age']=scaler.fit_transform(X_train['age'].values.reshape(-1,1))<br/>X_train['trestbps']=scaler.fit_transform(X_train['trestbps'].values.reshape(-1,1))<br/>X_train['chol']=scaler.fit_transform(X_train['chol'].values.reshape(-1,1))  <br/>X_train['thalach']=scaler.fit_transform(X_train['thalach'].values.reshape(-1,1))   <br/>X_train['oldpeak']=scaler.fit_transform(X_train['oldpeak'].values.reshape(-1,1))</span><span id="c9dc" class="le jx hi la b fi lj lg l lh li">X_test['age']=scaler.transform(X_test['age'].values.reshape(-1,1))<br/>X_test['trestbps']=scaler.transform(X_test['trestbps'].values.reshape(-1,1))<br/>X_test['chol']=scaler.transform(X_test['chol'].values.reshape(-1,1))  <br/>X_test['thalach']=scaler.transform(X_test['thalach'].values.reshape(-1,1))   <br/>X_test['oldpeak']=scaler.transform(X_test['oldpeak'].values.reshape(-1,1))</span></pre><p id="edb1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">转换完成后，我们可以进入下一步:使用机器学习算法</p><h1 id="8273" class="jw jx hi bd jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt bi translated">算法</h1><p id="3b57" class="pw-post-body-paragraph if ig hi ih b ii ku ik il im kv io ip iq kw is it iu kx iw ix iy ky ja jb jc hb bi translated">我们将从逻辑回归算法开始，看看它在数据集上的表现。</p><pre class="je jf jg jh fd kz la lb lc aw ld bi"><span id="f7fa" class="le jx hi la b fi lf lg l lh li"><strong class="la hj">from</strong> <strong class="la hj">sklearn.linear_model</strong> <strong class="la hj">import</strong> LogisticRegression<br/><strong class="la hj">from</strong> <strong class="la hj">sklearn.model_selection</strong> <strong class="la hj">import</strong> cross_val_score<br/><strong class="la hj">from</strong> <strong class="la hj">sklearn.metrics</strong> <strong class="la hj">import</strong> accuracy_score,confusion_matrix,classification_report<br/>lr=LogisticRegression(C=1.0,penalty='l2')<br/>lr.fit(X_train,y_train)<br/>print("The cross validation score mean is ",cross_val_score(lr,X_train,y_train,cv=3).mean())<br/>pred=lr.predict(X_test)<br/>print(classification_report(y_test,pred))<br/>sns.heatmap(confusion_matrix(y_test,pred),annot=<strong class="la hj">True</strong>)</span></pre><p id="d65f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Ths给我们的模型准确率为56%，召回率为90%。这是一个不错的结果，但让我们看看决策树如何在数据集上执行。</p><pre class="je jf jg jh fd kz la lb lc aw ld bi"><span id="79e5" class="le jx hi la b fi lf lg l lh li"><strong class="la hj">from</strong> <strong class="la hj">sklearn.tree</strong> <strong class="la hj">import</strong> DecisionTreeClassifier<br/>dc=DecisionTreeClassifier()<br/>dc.fit(X_train,y_train)<br/>print("The cross validation score is ",cross_val_score(dc,X_train,y_train).mean())<br/>pred=dc.predict(X_test)<br/>print(classification_report(y_test,pred))<br/>sns.heatmap(confusion_matrix(y_test,pred),annot=<strong class="la hj">True</strong></span></pre><p id="a51a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">决策树的表现稍好，准确率为57%。决策树只是略微提高了模型的性能，但使用随机森林分类器可能会提高准确性。</p><pre class="je jf jg jh fd kz la lb lc aw ld bi"><span id="bf25" class="le jx hi la b fi lf lg l lh li"><strong class="la hj">from</strong> <strong class="la hj">sklearn.ensemble</strong> <strong class="la hj">import</strong> RandomForestClassifier<br/>rf=RandomForestClassifier()<br/>rf.fit(X_train,y_train)<br/>print("The cross validation score is ",cross_val_score(rf,X_train,y_train).mean())<br/>pred=rf.predict(X_test)<br/>print(classification_report(y_test,pred))<br/>sns.heatmap(confusion_matrix(y_test,pred),annot=<strong class="la hj">True</strong>)</span></pre><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es lk"><img src="../Images/6727063ede00ea231cd7be49ebe0a441.png" data-original-src="https://miro.medium.com/v2/resize:fit:692/format:webp/1*S9Oq33vRwLCeIkHsxdzjjg.png"/></div><figcaption class="jp jq et er es jr js bd b be z dx translated">混淆矩阵</figcaption></figure><p id="bf8a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">随机森林分类器提高了模型性能，现在准确率为71%。热图是数据集的混淆矩阵，显示有19个假阴性和3个假阳性。在心脏病病例中，假阴性的代价非常高。让我们看看boosting算法能否改善这一点。我们将使用一种非常流行的助推算法，称为XG Boost，它实际上已经被用来赢得Kaggle比赛。算法的代码写在下面</p><h1 id="928b" class="jw jx hi bd jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt bi translated">助推</h1><pre class="je jf jg jh fd kz la lb lc aw ld bi"><span id="734b" class="le jx hi la b fi lf lg l lh li"><strong class="la hj">import</strong> <strong class="la hj">xgboost</strong> <strong class="la hj">as</strong> <strong class="la hj">xgb</strong><br/>data_dmatrix = xgb.DMatrix(data=X,label=y)<br/>xg_reg = xgb.XGBClassifier(objective ='reg:logistic', colsample_bytree = 0.3, learning_rate = 0.1,<br/>                max_depth = 5, alpha = 10, n_estimators = 10<br/>xg_reg.fit(X_train,y_train)<br/>pred = xg_reg.predict(X_test)<br/>sns.heatmap(confusion_matrix(y_test,pred),annot=<strong class="la hj">True</strong>)</span></pre><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es lk"><img src="../Images/1c611443cbca0583e3b1a30732ce6ff2.png" data-original-src="https://miro.medium.com/v2/resize:fit:692/format:webp/1*pvTvFmvvULkVBmn8Ixmlog.png"/></div><figcaption class="jp jq et er es jr js bd b be z dx translated">混淆矩阵</figcaption></figure><p id="1662" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">上图显示了混淆矩阵。可以看出，模型的性能有了显著的提高，假阴性减少了。XGBoost模型的准确率超过80%。</p><p id="e1f9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在这个例子中，我们看到了机器学习如何应用于数据集来预测心脏病。我们从探索性数据分析开始，然后转向特征工程，并构建了机器学习算法。最后，我们用XGBoost模型展示了boosting如何提高模型性能。</p></div></div>    
</body>
</html>