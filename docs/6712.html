<html>
<head>
<title>Treap: The Easiest Search Tree (Explained) | Alex Dremov</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Treap:最简单的搜索树(解释)| Alex Dremov</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/treap-the-easiest-search-tree-explained-alex-dremov-c82c9dc3c5e5?source=collection_archive---------0-----------------------#2022-04-25">https://medium.com/nerd-for-tech/treap-the-easiest-search-tree-explained-alex-dremov-c82c9dc3c5e5?source=collection_archive---------0-----------------------#2022-04-25</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="978a" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">二分搜索法树很硬。我将解释一种最简单、最有效、最强大的平衡二叉树——treap或笛卡尔树。</h2></div><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ix"><img src="../Images/038668410ef1d1c16a702ae57b60e9d6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NetE0_4JnQqWymQ_9chymw.png"/></div></div></figure><p id="a8d6" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated"><strong class="jl hj">笛卡尔树或treap </strong>(二叉查找树+二进制堆)是一种快速而简单的数据结构。它同时符合核心搜索二叉树性质和二叉堆性质。尽管很简单，treap会自我平衡，导致所有常见操作的平均复杂性。</p><p id="7362" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">很神奇，对吧？</p><blockquote class="kj kk kl"><p id="aedb" class="jj jk km jl b jm jn ij jo jp jq im jr kn jt ju jv ko jx jy jz kp kb kc kd ke hb bi translated">💥该算法使用随机值。因此，<code class="du kf kg kh ki b">O(logn)</code>复杂度平均为<strong class="jl hj"/>。然而，<code class="du kf kg kh ki b">O(logn)</code>的许多条目几乎总是真实的。因此，在本文的后面，我将只使用<code class="du kf kg kh ki b">O(logn)</code>，而不使用“平均”加法。</p></blockquote><p id="15f5" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">此外，还有一个修改(隐式treap，带隐式键的treap)让你像通常的数组一样使用treap，带有<code class="du kf kg kh ki b">O(logn)</code> <strong class="jl hj">随机插入和</strong> <strong class="jl hj">随机删除</strong>。是不是很酷？在本文中，我将解释如何创建一个并在Swift中提供实现。此外，我将把treap与标准库中的通用<code class="du kf kg kh ki b">set</code>进行比较。开始吧！</p><blockquote class="kj kk kl"><p id="a90e" class="jj jk km jl b jm jn ij jo jp jq im jr kn jt ju jv ko jx jy jz kp kb kc kd ke hb bi translated">💡在二叉查找树中，对于每个节点，左子树中所有项目的值都小于该节点的值，而右子树中所有项目的值都大于该节点的值</p></blockquote><h1 id="fae3" class="kq kr hi bd ks kt ku kv kw kx ky kz la io lb ip lc ir ld is le iu lf iv lg lh bi translated">核心算法</h1><p id="0778" class="pw-post-body-paragraph jj jk hi jl b jm li ij jo jp lj im jr js lk ju jv jw ll jy jz ka lm kc kd ke hb bi translated">正如我前面所说，treap结合了heaps和二分搜索法树。因此，我们至少要存储两个属性:<code class="du kf kg kh ki b">key</code>(或值)和<code class="du kf kg kh ki b">priority</code>。Key是一个值，对于哪个树是搜索树，对于优先级，它是一个二进制堆。</p><blockquote class="kj kk kl"><p id="dc6c" class="jj jk km jl b jm jn ij jo jp jq im jr kn jt ju jv ko jx jy jz kp kb kc kd ke hb bi translated">💡二进制堆是一棵二叉树，其中每个子节点的值都小于该节点的值</p></blockquote><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ix"><img src="../Images/7092a2eeabc21c38657b3b003081c7f5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*oWgMve1U-SC4YiOB.png"/></div></div><figcaption class="ln lo et er es lp lq bd b be z dx translated">Treap示例</figcaption></figure><p id="4e33" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">在上图中，您可能会注意到，对于每个节点，所有子节点的优先级都降低了。另一方面，左侧的所有子节点的键都比节点中的键小，而右侧的所有子节点的键都更大。</p><blockquote class="kj kk kl"><p id="11db" class="jj jk km jl b jm jn ij jo jp jq im jr kn jt ju jv ko jx jy jz kp kb kc kd ke hb bi translated">💡它也被称为<strong class="jl hj">笛卡尔树</strong>，因为它可以显示在一个规则的2D网格上，每个节点都有(键，优先级)坐标。就像上图一样。</p></blockquote><p id="0ef4" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">为了创建一个全功能的搜索树，我们需要实现:</p><ul class=""><li id="1d31" class="lr ls hi jl b jm jn jp jq js lt jw lu ka lv ke lw lx ly lz bi translated">发现</li><li id="cd27" class="lr ls hi jl b jm ma jp mb js mc jw md ka me ke lw lx ly lz bi translated">插入</li><li id="391f" class="lr ls hi jl b jm ma jp mb js mc jw md ka me ke lw lx ly lz bi translated">去除</li></ul><p id="f977" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">像<code class="du kf kg kh ki b">lower bound</code>和<code class="du kf kg kh ki b">upper bound</code>这样更奇特的操作也非常简单，与其他搜索树中的操作没有什么不同。而所有这些操作都可以用<strong class="jl hj">仅仅两个辅助操作</strong>来实现！</p><p id="97c2" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">怎么做呢？</p><blockquote class="kj kk kl"><p id="6d9e" class="jj jk km jl b jm jn ij jo jp jq im jr kn jt ju jv ko jx jy jz kp kb kc kd ke hb bi translated">💥<strong class="jl hj">拆分</strong> <br/> <br/>根据给定的<code class="du kf kg kh ki b">value</code>将树拆分成两棵树。左树中的所有值都比<code class="du kf kg kh ki b">value</code>小<strong class="jl hj">比</strong>大<strong class="jl hj">比</strong>大。并且两个结果树都是正确的树。我们将使用一个特殊的标志来决定是发送等于左树还是右树的值。</p></blockquote><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ix"><img src="../Images/98c42d44427b7734405ad2602b263ad8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*VGv-SV8jYIvYMG7-.png"/></div></div><figcaption class="ln lo et er es lp lq bd b be z dx translated">分裂函数结果示例。向右发送的相等值</figcaption></figure><blockquote class="kj kk kl"><p id="d8b3" class="jj jk km jl b jm jn ij jo jp jq im jr kn jt ju jv ko jx jy jz kp kb kc kd ke hb bi translated">💥<strong class="jl hj">合并</strong> <br/> <br/>将两个treap合并成一个大treap。<br/> <strong class="jl hj">前提:</strong>第一棵树中的所有项目都小于右边树中的项目。</p></blockquote><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ix"><img src="../Images/7791583319c7560837b119248108565c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*vOpEklnD1W7HTdI3.png"/></div></div><figcaption class="ln lo et er es lp lq bd b be z dx translated">合并示例</figcaption></figure><p id="16fe" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">因此，如果我们实现这两个方法，实现所有其他三个操作将是微不足道的。</p><h2 id="f615" class="mf kr hi bd ks mg mh mi kw mj mk ml la js mm mn lc jw mo mp le ka mq mr lg ms bi translated">裂开</h2><p id="d1f6" class="pw-post-body-paragraph jj jk hi jl b jm li ij jo jp lj im jr js lk ju jv jw ll jy jz ka lm kc kd ke hb bi translated">让我们在这个阶段开始考虑代码。我将在<code class="du kf kg kh ki b">C++</code>中解释这一点。在<code class="du kf kg kh ki b">Swift</code>中重写下面的代码实际上非常容易。如果你需要帮助，请在下面留下评论。</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="mt mu l"/></div></figure><p id="dbca" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">对于拆分，我们有一个<code class="du kf kg kh ki b">head</code>节点和一个<code class="du kf kg kh ki b">key</code>节点需要进行拆分。这个方法使用递归非常简单。</p><h2 id="6014" class="mf kr hi bd ks mg mh mi kw mj mk ml la js mm mn lc jw mo mp le ka mq mr lg ms bi translated">算法</h2><p id="eb10" class="pw-post-body-paragraph jj jk hi jl b jm li ij jo jp lj im jr js lk ju jv jw ll jy jz ka lm kc kd ke hb bi translated">设当前头像为<code class="du kf kg kh ki b">p</code>。</p><ul class=""><li id="a90f" class="lr ls hi jl b jm jn jp jq js lt jw lu ka lv ke lw lx ly lz bi translated">如果<code class="du kf kg kh ki b">p-&gt;key</code>比<code class="du kf kg kh ki b">key</code>中的小，那么我们需要将<strong class="jl hj">向右移动</strong>并进一步分割<code class="du kf kg kh ki b">p-&gt;right</code>。<br/> <br/>同样，分割<code class="du kf kg kh ki b">right</code>也会带来两棵树，第一棵树的节点比<code class="du kf kg kh ki b">key</code>的键<strong class="jl hj">少</strong>。然而，它们比<code class="du kf kg kh ki b">p-&gt;key</code>更大(因为它们在第一次分裂的第二棵树中)。<br/>因此，我们将<code class="du kf kg kh ki b">p-&gt;right</code>设置为拆分<code class="du kf kg kh ki b">right</code>结果的第一个<strong class="jl hj">树。<br/> <br/> <strong class="jl hj">结果:</strong> <code class="du kf kg kh ki b">p</code>，分割右边的第二棵树</strong></li><li id="1214" class="lr ls hi jl b jm ma jp mb js mc jw md ka me ke lw lx ly lz bi translated">如果<code class="du kf kg kh ki b">p-&gt;key</code>大于<strong class="jl hj">或等于<code class="du kf kg kh ki b">key</code>的</strong>，那么我们需要将<strong class="jl hj">向左</strong>并进一步分割<code class="du kf kg kh ki b">p-&gt;left</code>。<br/> <br/>与上面的情况类似，我们将<code class="du kf kg kh ki b">p-&gt;left</code>设置为左分裂的第二个<strong class="jl hj">树</strong>。<br/> <br/> <strong class="jl hj">结果:</strong>分割左边的第一棵树，<code class="du kf kg kh ki b">p</code></li></ul><p id="4566" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">上面的算法在第二棵树中留下了一个等于分裂值的节点。对称地，我们将使用<code class="du kf kg kh ki b">equalOnTheLeft</code>标志离开左树中的节点。</p><p id="76eb" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">所以，最后的代码:</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="mt mu l"/></div></figure><blockquote class="kj kk kl"><p id="7d0c" class="jj jk km jl b jm jn ij jo jp jq im jr kn jt ju jv ko jx jy jz kp kb kc kd ke hb bi translated">💡在分割过程中，不使用也不改变优先级。生成的树具有正确的优先级顺序，就像最初的树一样</p></blockquote><h2 id="853b" class="mf kr hi bd ks mg mh mi kw mj mk ml la js mm mn lc jw mo mp le ka mq mr lg ms bi translated">合并</h2><p id="37da" class="pw-post-body-paragraph jj jk hi jl b jm li ij jo jp lj im jr js lk ju jv jw ll jy jz ka lm kc kd ke hb bi translated">合并类似于拆分，但是它使用<strong class="jl hj">优先级</strong>来完成工作。我之前提到过，有一个<strong class="jl hj">前提</strong>:第一个合并树中的所有项目必须少于第二个树中的项目。如果不是这样，就必须使用另一种算法。</p><h2 id="ec6f" class="mf kr hi bd ks mg mh mi kw mj mk ml la js mm mn lc jw mo mp le ka mq mr lg ms bi translated">算法</h2><p id="0eff" class="pw-post-body-paragraph jj jk hi jl b jm li ij jo jp lj im jr js lk ju jv jw ll jy jz ka lm kc kd ke hb bi translated">与<code class="du kf kg kh ki b">split</code>类似，<code class="du kf kg kh ki b">merge</code>也是递归的。让我们合并两棵树:<code class="du kf kg kh ki b">l</code>和<code class="du kf kg kh ki b">r</code>。</p><ul class=""><li id="0d18" class="lr ls hi jl b jm jn jp jq js lt jw lu ka lv ke lw lx ly lz bi translated">我们需要选择哪棵树来代表新的头。这很简单——头部必须具有最高优先级，因此我们基于此选择<code class="du kf kg kh ki b">l</code>或<code class="du kf kg kh ki b">r</code>。</li></ul><blockquote class="kj kk kl"><p id="778e" class="jj jk km jl b jm jn ij jo jp jq im jr kn jt ju jv ko jx jy jz kp kb kc kd ke hb bi translated">💡请注意，<code class="du kf kg kh ki b">l</code>中的头节点在整个<code class="du kf kg kh ki b">l</code>树中具有最高的优先级，因为它是正确树的属性。同样适用于<code class="du kf kg kh ki b">r</code>。</p></blockquote><ul class=""><li id="86df" class="lr ls hi jl b jm jn jp jq js lt jw lu ka lv ke lw lx ly lz bi translated">如果<code class="du kf kg kh ki b">l</code>有更高的优先级，那么<code class="du kf kg kh ki b">l-&gt;left</code>子树肯定会比<code class="du kf kg kh ki b">r</code>保持原样作为左子树，这与它无关。<br/> <br/>然后，<code class="du kf kg kh ki b">l-&gt;right</code>子树必须与<code class="du kf kg kh ki b">r</code>合并，它将成为新的<code class="du kf kg kh ki b">l-&gt;right</code>子树。</li><li id="2b8a" class="lr ls hi jl b jm ma jp mb js mc jw md ka me ke lw lx ly lz bi translated">如果<code class="du kf kg kh ki b">r</code>具有更高的优先级，那么类似于上面的例子，<code class="du kf kg kh ki b">r-&gt;right</code>将保持不变，并且<code class="du kf kg kh ki b">r-&gt;left</code>必须与<code class="du kf kg kh ki b">l</code>合并</li></ul><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="mt mu l"/></div></figure><p id="bfab" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">为什么是正确的？</p><p id="4a62" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">似乎没有什么能阻止我们打破搜索树结构，其中左子树中所有项目的值都小于节点的值，而右子树中所有项目的值都大于节点的值。</p><blockquote class="kj kk kl"><p id="b03f" class="jj jk km jl b jm jn ij jo jp jq im jr kn jt ju jv ko jx jy jz kp kb kc kd ke hb bi translated">💡<strong class="jl hj">先决条件</strong>保存二叉查找树属性，因为项目永远不会被重新排序，并且<code class="du kf kg kh ki b">l &lt; r</code>属性总是保持不变</p></blockquote><h1 id="7c63" class="kq kr hi bd ks kt ku kv kw kx ky kz la io lb ip lc ir ld is le iu lf iv lg lh bi translated">实现搜索树方法</h1><p id="2536" class="pw-post-body-paragraph jj jk hi jl b jm li ij jo jp lj im jr js lk ju jv jw ll jy jz ka lm kc kd ke hb bi translated">你相信我所有的方法都很容易通过<code class="du kf kg kh ki b">split</code>和<code class="du kf kg kh ki b">merge</code>实现。是时候证明这一点了。</p><blockquote class="kj kk kl"><p id="f021" class="jj jk km jl b jm jn ij jo jp jq im jr kn jt ju jv ko jx jy jz kp kb kc kd ke hb bi translated">这个故事最初发表在<a class="ae mv" href="https://alexdemov.me" rel="noopener ugc nofollow" target="_blank"> alexdemov.me </a>上。</p><p id="150d" class="jj jk km jl b jm jn ij jo jp jq im jr kn jt ju jv ko jx jy jz kp kb kc kd ke hb bi translated">查看其他帖子并订阅我的时事通讯，以获得更多的算法解释、编码技巧和许多其他有趣的东西。</p></blockquote><div class="mw mx ez fb my mz"><a href="https://alexdremov.me/treap-algorithm-explained/" rel="noopener  ugc nofollow" target="_blank"><div class="na ab dw"><div class="nb ab nc cl cj nd"><h2 class="bd hj fi z dy ne ea eb nf ed ef hh bi translated">Treap:最简单的搜索树(解释)| Alex Dremov</h2><div class="ng l"><h3 class="bd b fi z dy ne ea eb nf ed ef dx translated">二分搜索法树大多是坚硬的。写红黑树是一场噩梦。在这里，我要去…</h3></div><div class="nh l"><p class="bd b fp z dy ne ea eb nf ed ef dx translated">alexdremov.me</p></div></div><div class="ni l"><div class="nj l nk nl nm ni nn jh mz"/></div></div></a></div><h2 id="f568" class="mf kr hi bd ks mg mh mi kw mj mk ml la js mm mn lc jw mo mp le ka mq mr lg ms bi translated">发现</h2><p id="8d76" class="pw-post-body-paragraph jj jk hi jl b jm li ij jo jp lj im jr js lk ju jv jw ll jy jz ka lm kc kd ke hb bi translated">Find的实现就像一般的搜索树一样。我们利用左子树中的键大于节点中的值这一事实。</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="mt mu l"/></div></figure><h2 id="8e8c" class="mf kr hi bd ks mg mh mi kw mj mk ml la js mm mn lc jw mo mp le ka mq mr lg ms bi translated">插入</h2><p id="898f" class="pw-post-body-paragraph jj jk hi jl b jm li ij jo jp lj im jr js lk ju jv jw ll jy jz ka lm kc kd ke hb bi translated">让我们从拆分和合并的角度来考虑插入。我们有一棵大树，我们需要插入一棵新的<code class="du kf kg kh ki b">key</code>。</p><ul class=""><li id="7b3d" class="lr ls hi jl b jm jn jp jq js lt jw lu ka lv ke lw lx ly lz bi translated">通过<code class="du kf kg kh ki b">key</code>将树分裂成新的树:<code class="du kf kg kh ki b">first</code>和<code class="du kf kg kh ki b">second</code>。然后，我们将有两棵树:第一棵树(其值小于<code class="du kf kg kh ki b">key</code>)和第二棵树(其值大于或等于<code class="du kf kg kh ki b">key</code>)。<br/> <br/>我们可以检查节点已经存在:尝试在正确的树中找到它。</li></ul><blockquote class="kj kk kl"><p id="88f8" class="jj jk km jl b jm jn ij jo jp jq im jr kn jt ju jv ko jx jy jz kp kb kc kd ke hb bi translated">💥实施要求每个项目只满足<strong class="jl hj">一次</strong>。<br/></p></blockquote><ul class=""><li id="818a" class="lr ls hi jl b jm jn jp jq js lt jw lu ka lv ke lw lx ly lz bi translated">创建一个新节点来存储新的<code class="du kf kg kh ki b">key</code> — <code class="du kf kg kh ki b">newNode</code>。这个节点是只有一个节点的正确树。<br/> <br/>对于新节点，需要设置<strong class="jl hj">一个随机优先级</strong></li></ul><blockquote class="kj kk kl"><p id="39c2" class="jj jk km jl b jm jn ij jo jp jq im jr kn jt ju jv ko jx jy jz kp kb kc kd ke hb bi translated">💥随机优先级是复杂性的关键。这使得笛卡尔树自身平衡，使得所有操作变得复杂</p></blockquote><ul class=""><li id="448f" class="lr ls hi jl b jm jn jp jq js lt jw lu ka lv ke lw lx ly lz bi translated">新的负责人将会是<code class="du kf kg kh ki b">merge(first, merge(newNode, second))</code></li></ul><p id="f072" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">看到了吗？就这么简单。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ix"><img src="../Images/52a928d5e12ece5a1eec1d584f3be680.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*F_XQ3v-wDDZ3gxNX.png"/></div></div><figcaption class="ln lo et er es lp lq bd b be z dx translated">插入示例</figcaption></figure><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="mt mu l"/></div></figure><h2 id="c5ab" class="mf kr hi bd ks mg mh mi kw mj mk ml la js mm mn lc jw mo mp le ka mq mr lg ms bi translated">去除</h2><p id="ebef" class="pw-post-body-paragraph jj jk hi jl b jm li ij jo jp lj im jr js lk ju jv jw ll jy jz ka lm kc kd ke hb bi translated">和<code class="du kf kg kh ki b">insert</code>很像。然而，这就是使用<code class="du kf kg kh ki b">equalOnTheLeft</code>标志的地方。</p><blockquote class="kj kk kl"><p id="c2e7" class="jj jk km jl b jm jn ij jo jp jq im jr kn jt ju jv ko jx jy jz kp kb kc kd ke hb bi translated">💡记住由<code class="du kf kg kh ki b">split</code>生成的<code class="du kf kg kh ki b">second</code>树包含大于或等于所选键<strong class="jl hj">的项目</strong></p></blockquote><p id="6d89" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">因此，<code class="du kf kg kh ki b">second</code>树将包含需要删除的值。但是怎么把它从树上去掉呢？</p><p id="d67b" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">再次分裂。</p><p id="5219" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">我们可以通过键分割<code class="du kf kg kh ki b">second</code>树，将<code class="du kf kg kh ki b">equalOnTheLeft</code>标志设置为<code class="du kf kg kh ki b">true</code>。因此，节点将从<code class="du kf kg kh ki b">second</code>树分离到新树。</p><blockquote class="kj kk kl"><p id="bb09" class="jj jk km jl b jm jn ij jo jp jq im jr kn jt ju jv ko jx jy jz kp kb kc kd ke hb bi translated">💡在进行两次分割并分离出删除的节点后，不需要的节点很容易被移除，其他的都被合并。</p></blockquote><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ix"><img src="../Images/ade718d3b38c8537e642610bf6f4116d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*nHQhmHIeV4aDBv7D.png"/></div></div><figcaption class="ln lo et er es lp lq bd b be z dx translated">移除示例</figcaption></figure><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="mt mu l"/></div></figure><h2 id="98cb" class="mf kr hi bd ks mg mh mi kw mj mk ml la js mm mn lc jw mo mp le ka mq mr lg ms bi translated">完整代码</h2><p id="ac66" class="pw-post-body-paragraph jj jk hi jl b jm li ij jo jp lj im jr js lk ju jv jw ll jy jz ka lm kc kd ke hb bi translated">你可以在我的网站上下载稍微优化过的Treap的C++代码</p><div class="mw mx ez fb my mz"><a href="https://alexdremov.me/treap-algorithm-explained/" rel="noopener  ugc nofollow" target="_blank"><div class="na ab dw"><div class="nb ab nc cl cj nd"><h2 class="bd hj fi z dy ne ea eb nf ed ef hh bi translated">Treap:最简单的搜索树(解释)| Alex Dremov</h2><div class="ng l"><h3 class="bd b fi z dy ne ea eb nf ed ef dx translated">二分搜索法树大多是坚硬的。写红黑树是一场噩梦。在这里，我要去…</h3></div><div class="nh l"><p class="bd b fp z dy ne ea eb nf ed ef dx translated">alexdremov.me</p></div></div><div class="ni l"><div class="nj l nk nl nm ni nn jh mz"/></div></div></a></div><h1 id="8220" class="kq kr hi bd ks kt ku kv kw kx ky kz la io lb ip lc ir ld is le iu lf iv lg lh bi translated">与<code class="du kf kg kh ki b">std::set</code>比较</h1><p id="f85a" class="pw-post-body-paragraph jj jk hi jl b jm li ij jo jp lj im jr js lk ju jv jw ll jy jz ka lm kc kd ke hb bi translated">首先，treap的实现版本利用了<code class="du kf kg kh ki b">split</code>和<code class="du kf kg kh ki b">merge</code>方法。请注意，使用旋转会有更高效的实现。然而，treap的真正威力在于其他搜索树无法轻易做到的<code class="du kf kg kh ki b">split</code>和<code class="du kf kg kh ki b">merge</code>方法。</p><h2 id="ba78" class="mf kr hi bd ks mg mh mi kw mj mk ml la js mm mn lc jw mo mp le ka mq mr lg ms bi translated">查找测试</h2><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es no"><img src="../Images/e1e5b874a27f8d97f9565061515908ad.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6q9-RVjZf1H0en2Qlt6J7Q.png"/></div></div></figure><p id="d9d4" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">可见渐近性是相似的。尽管如此，treap总是有更大的开销。尽管如此，还是个不错的结果！我们正在与一个完全优化的标准库数据结构竞争。</p><h2 id="7996" class="mf kr hi bd ks mg mh mi kw mj mk ml la js mm mn lc jw mo mp le ka mq mr lg ms bi translated">插入</h2><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es no"><img src="../Images/ae15ec6f5a0863fc9d3499fa7acb70e7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vCvkExbYOyYCCqOJnaCFVQ.png"/></div></div></figure><p id="0042" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">插入的开销甚至更大。这是意料之中的:递归调用merge和split不会提高性能；).你可以在我的网站上找到测试代码。</p><h2 id="d1bb" class="mf kr hi bd ks mg mh mi kw mj mk ml la js mm mn lc jw mo mp le ka mq mr lg ms bi translated">比较结论</h2><p id="dd75" class="pw-post-body-paragraph jj jk hi jl b jm li ij jo jp lj im jr js lk ju jv jw ll jy jz ka lm kc kd ke hb bi translated">没错，treap的性能比<code class="du kf kg kh ki b">std::set</code>差。然而，结果是可比较的，随着数据量的增加，treap越来越接近于<code class="du kf kg kh ki b">std::set</code>，它实际上是一棵红黑树。</p><p id="1416" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">相信我，</p><p id="0b37" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">你不想写你自己的RB树。简直是噩梦。</p><h1 id="97df" class="kq kr hi bd ks kt ku kv kw kx ky kz la io lb ip lc ir ld is le iu lf iv lg lh bi translated">用例及修改</h1><p id="779f" class="pw-post-body-paragraph jj jk hi jl b jm li ij jo jp lj im jr js lk ju jv jw ll jy jz ka lm kc kd ke hb bi translated">我们开发这种数据结构不仅仅是为了丢失<code class="du kf kg kh ki b">std::set</code>。有几个有用的应用。</p><h2 id="1b1f" class="mf kr hi bd ks mg mh mi kw mj mk ml la js mm mn lc jw mo mp le ka mq mr lg ms bi translated">区间中数字的和</h2><p id="fd2f" class="pw-post-body-paragraph jj jk hi jl b jm li ij jo jp lj im jr js lk ju jv jw ll jy jz ka lm kc kd ke hb bi translated">我们需要修改<code class="du kf kg kh ki b">Node</code>结构，增加<code class="du kf kg kh ki b">sum</code>字段。它将存储所有子节点和自身的总和。</p><pre class="iy iz ja jb fd np ki nq nr aw ns bi"><span id="5bd8" class="mf kr hi ki b fi nt nu l nv nw">template&lt;typename T&gt;<br/>struct Node {<br/>	T key;<br/>	size_t prior;<br/>	long long sum;<br/>	Node* left = nullptr, *right = nullptr;<br/><br/>	Node(T key, size_t prior) :<br/>		key(std::move(key)),<br/>		prior(prior) {<br/>	}<br/>};</span></pre><p id="f65a" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">更新<code class="du kf kg kh ki b">sum</code>极其容易。每次换孩子，<code class="du kf kg kh ki b">sum = left-&gt;sum + right-&gt;sum</code>。因此，您可以实现某种类型的<code class="du kf kg kh ki b">update</code>函数，并在返回值之前在split and merge中调用它。就是这样。</p><p id="5404" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">如何应约回答？</p><p id="b7d4" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">我们收到间隔<code class="du kf kg kh ki b">[l, r]</code>。要计算这个区间上的数字之和，我们可以用<code class="du kf kg kh ki b">l</code>分裂树，然后用<code class="du kf kg kh ki b">r+1</code>分裂结果的第二棵树(或者用<code class="du kf kg kh ki b">r</code>，左边留相等的元素)。最终，我们将得到一个包含区间<code class="du kf kg kh ki b">[l, r]</code>中所有相加数字的树。</p><p id="a07d" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated"><strong class="jl hj">复杂:</strong> <code class="du kf kg kh ki b">O(logn)</code>对<code class="du kf kg kh ki b">O(n)</code>幼稚。</p><h2 id="4014" class="mf kr hi bd ks mg mh mi kw mj mk ml la js mm mn lc jw mo mp le ka mq mr lg ms bi translated">使用值的散列来代替优先级</h2><p id="b72e" class="pw-post-body-paragraph jj jk hi jl b jm li ij jo jp lj im jr js lk ju jv jw ll jy jz ka lm kc kd ke hb bi translated">您可以使用值的散列作为优先级，因为好的散列函数是相当随机的。它带来了什么好处？</p><p id="664b" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">如果键和优先级是固定的，那么无论你如何构造treap或者添加元素，它总是会有相同的结构。</p><blockquote class="kj kk kl"><p id="697c" class="jj jk km jl b jm jn ij jo jp jq im jr kn jt ju jv ko jx jy jz kp kb kc kd ke hb bi translated">💡你可以这样想:键固定x轴，优先级固定y轴</p></blockquote><p id="5b05" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">因此，您可以比较<code class="du kf kg kh ki b">O(n)</code>中的两个集合，因为包含相同值的treaps将具有<strong class="jl hj">完全相同的结构。</strong></p><h2 id="b4f3" class="mf kr hi bd ks mg mh mi kw mj mk ml la js mm mn lc jw mo mp le ka mq mr lg ms bi translated">隐式处理</h2><p id="41ec" class="pw-post-body-paragraph jj jk hi jl b jm li ij jo jp lj im jr js lk ju jv jw ll jy jz ka lm kc kd ke hb bi translated">如果我们用左子树的大小作为一个键会怎么样？然后，我们可以用这个键作为索引。哇哦。这意味着我们可以将一个规则的有序数组表示为一个treap！</p><p id="4b24" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">通过这样做，我们可以:</p><ul class=""><li id="aa24" class="lr ls hi jl b jm jn jp jq js lt jw lu ka lv ke lw lx ly lz bi translated">通过随机索引<br/> <code class="du kf kg kh ki b">O(logn)</code>对<code class="du kf kg kh ki b">O(n)</code>进行插入</li><li id="f928" class="lr ls hi jl b jm ma jp mb js mc jw md ka me ke lw lx ly lz bi translated">通过随机索引<br/> <code class="du kf kg kh ki b">O(logn)</code>对<code class="du kf kg kh ki b">O(n)</code>进行删除</li></ul><p id="672b" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">权力越大，责任越大。</p><blockquote class="kj kk kl"><p id="091d" class="jj jk km jl b jm jn ij jo jp jq im jr kn jt ju jv ko jx jy jz kp kb kc kd ke hb bi translated">😡在标准阵列中，通过随机索引的访问降级为<code class="du kf kg kh ki b">O(logn)</code>而不是<code class="du kf kg kh ki b">O(1)</code>。</p></blockquote><p id="f69d" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">如果您的算法需要大量的数组修改和很少的访问/输出，那么它是正确的选择。此外，您可以将treap转换为数组，并以<code class="du kf kg kh ki b">O(n)</code>的复杂度转换回来。</p><blockquote class="kj kk kl"><p id="9b3d" class="jj jk km jl b jm jn ij jo jp jq im jr kn jt ju jv ko jx jy jz kp kb kc kd ke hb bi translated">💥我在Swift 中实现了隐式treap。它的行为就像通用数组一样，并实现了许多优化。看看吧！</p></blockquote><div class="mw mx ez fb my mz"><a href="https://github.com/AlexRoar/swift-collections/tree/main/Sources/OrderedCollections/TreeArray" rel="noopener  ugc nofollow" target="_blank"><div class="na ab dw"><div class="nb ab nc cl cj nd"><h2 class="bd hj fi z dy ne ea eb nf ed ef hh bi translated">swift-collections/Sources/ordered collections/tree array位于主AlexRoar/swift-collections</h2><div class="ng l"><h3 class="bd b fi z dy ne ea eb nf ed ef dx translated">此时您不能执行该操作。您已使用另一个标签页或窗口登录。您已在另一个选项卡中注销，或者…</h3></div><div class="nh l"><p class="bd b fp z dy ne ea eb nf ed ef dx translated">github.com</p></div></div><div class="ni l"><div class="nx l nk nl nm ni nn jh mz"/></div></div></a></div><h2 id="ec52" class="mf kr hi bd ks mg mh mi kw mj mk ml la js mm mn lc jw mo mp le ka mq mr lg ms bi translated">剪切粘贴问题</h2><p id="b2ac" class="pw-post-body-paragraph jj jk hi jl b jm li ij jo jp lj im jr js lk ju jv jw ll jy jz ka lm kc kd ke hb bi translated">想象一下，你有一根很长的绳子，有人请求你剪下一部分，然后把它插入某个地方。</p><p id="4c0e" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">这个问题可以通过使用带有隐式密钥的treaps来解决。您可以使用分割来剪切所需的部分，并合并来插入它。</p><h2 id="ddac" class="mf kr hi bd ks mg mh mi kw mj mk ml la js mm mn lc jw mo mp le ka mq mr lg ms bi translated">常见问题解答</h2><blockquote class="kj kk kl"><p id="5780" class="jj jk km jl b jm jn ij jo jp jq im jr kn jt ju jv ko jx jy jz kp kb kc kd ke hb bi translated">笛卡尔树最适合什么？</p></blockquote><p id="3458" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">当您需要收集某个区间的某种特征(例如，sum)或对该区间进行一些修改时，Treap非常有用。当您需要用很少的访问来应用大量的随机树插入/删除时，使用隐式键的Treap也很有用。</p><blockquote class="kj kk kl"><p id="83b5" class="jj jk km jl b jm jn ij jo jp jq im jr kn jt ju jv ko jx jy jz kp kb kc kd ke hb bi translated">为什么我们不用数组索引作为隐式treap的键呢？</p></blockquote><p id="981b" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">因为在插入的情况下，我们需要重新计算高于插入索引的所有索引。所以它把复杂度降级为<code class="du kf kg kh ki b">O(n)</code>。</p><blockquote class="kj kk kl"><p id="3234" class="jj jk km jl b jm jn ij jo jp jq im jr kn jt ju jv ko jx jy jz kp kb kc kd ke hb bi translated">treap是随机树吗？</p></blockquote><p id="83a0" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">是的，它是。但是它也可以使用散列值来代替随机值。</p><blockquote class="kj kk kl"><p id="1aa7" class="jj jk km jl b jm jn ij jo jp jq im jr kn jt ju jv ko jx jy jz kp kb kc kd ke hb bi translated">我知道没有分割和合并的实现。它利用左转弯和右转弯。好点了吗？</p></blockquote><p id="50c9" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">比如GeeksforGeeks用的就是这样的实现，我知道。但是我相信treap的真正价值在于无缝的分离和融合。您已经通过例子看到了它是多么有用。当你可以建造可能会更快的AVL时，为什么要实施轮流交换呢？</p><h1 id="0191" class="kq kr hi bd ks kt ku kv kw kx ky kz la io lb ip lc ir ld is le iu lf iv lg lh bi translated">喜欢数据结构吗？</h1><p id="7a32" class="pw-post-body-paragraph jj jk hi jl b jm li ij jo jp lj im jr js lk ju jv jw ll jy jz ka lm kc kd ke hb bi translated">看看我在惊人的跳过列表上的文章吧！虽然很多人从未听说过它，但跳表非常漂亮，可以以最有效的方式解决，例如，寻找第n个最大值的问题或滚动中值问题。</p><div class="mw mx ez fb my mz"><a href="https://alexdremov.me/skip-list-indexation-and-kth-maximum/" rel="noopener  ugc nofollow" target="_blank"><div class="na ab dw"><div class="nb ab nc cl cj nd"><h2 class="bd hj fi z dy ne ea eb nf ed ef hh bi translated">跳过列表索引和第k个最大值| Alex Dremov</h2><div class="ng l"><h3 class="bd b fi z dy ne ea eb nf ed ef dx translated">这是一个很好的结构，可以让你执行插入，搜索，和寻找第n个…</h3></div><div class="nh l"><p class="bd b fp z dy ne ea eb nf ed ef dx translated">alexdremov.me</p></div></div><div class="ni l"><div class="ny l nk nl nm ni nn jh mz"/></div></div></a></div><p id="ff3f" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">另外，你可以查看我博客的整个算法部分</p><div class="mw mx ez fb my mz"><a href="https://alexdremov.me/tag/algorithms/" rel="noopener  ugc nofollow" target="_blank"><div class="na ab dw"><div class="nb ab nc cl cj nd"><h2 class="bd hj fi z dy ne ea eb nf ed ef hh bi translated">亚历克斯·德雷莫夫|算法</h2><div class="ng l"><h3 class="bd b fi z dy ne ea eb nf ed ef dx translated">二分搜索法树大多很硬。写红黑树是一场噩梦。在这里，我将解释其中一个…</h3></div><div class="nh l"><p class="bd b fp z dy ne ea eb nf ed ef dx translated">alexdremov.me</p></div></div><div class="ni l"><div class="nz l nk nl nm ni nn jh mz"/></div></div></a></div><h1 id="bc19" class="kq kr hi bd ks kt ku kv kw kx ky kz la io lb ip lc ir ld is le iu lf iv lg lh bi translated">参考</h1><p id="c463" class="pw-post-body-paragraph jj jk hi jl b jm li ij jo jp lj im jr js lk ju jv jw ll jy jz ka lm kc kd ke hb bi translated"><a class="ae mv" href="https://books.google.de/books?id=NLngYyWFl_YC&amp;pg=PA298&amp;lpg=PA298&amp;dq=treap+algorithm&amp;source=bl&amp;ots=BASmGA8mBd&amp;sig=ACfU3U17YFycVO2ztnR-zjL5yLbhEfv3VQ&amp;hl=en&amp;sa=X&amp;ved=2ahUKEwjxqr_r0qf3AhXD0qQKHcWWDjcQ6AF6BAgyEAM#v=onepage&amp;q=treap%20algorithm&amp;f=false" rel="noopener ugc nofollow" target="_blank">算法介绍</a></p><p id="b267" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated"><a class="ae mv" href="https://algorithmica.org/ru/treap" rel="noopener ugc nofollow" target="_blank">аекартоводрево—алгоитмика</a></p><p id="314f" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated"><a class="ae mv" href="https://www.cs.cmu.edu/~scandal/papers/treaps-spaa98.pdf" rel="noopener ugc nofollow" target="_blank">https://www.cs.cmu.edu/~scandal/papers/treaps-spaa98.pdf</a></p></div></div>    
</body>
</html>