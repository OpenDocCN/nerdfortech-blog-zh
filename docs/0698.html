<html>
<head>
<title>Software Bugs in a Particulate Matter Sensor Library</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">颗粒物传感器库中的软件缺陷</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/software-bugs-in-a-particulate-matter-sensor-library-44c3f030260e?source=collection_archive---------4-----------------------#2021-02-05">https://medium.com/nerd-for-tech/software-bugs-in-a-particulate-matter-sensor-library-44c3f030260e?source=collection_archive---------4-----------------------#2021-02-05</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="fd6b" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">看一看鲁棒解析简单串行协议所需的注意事项。</h2></div><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ix"><img src="../Images/d2a8c14225ae374b01639182abde2043.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nIlgrlKmvyeeoY7H1JtPyA.png"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">PMS5003串行传输的前两个字节。</figcaption></figure><p id="bbc6" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">本文着眼于在Plantower PMS5003颗粒物传感器库中发现的一些缺陷。该设备使用简单的串行接口以低速向另一设备发送数据。这个库的设计和实现听起来微不足道，但是产生一个带有<a class="ae kj" href="https://en.wikipedia.org/wiki/Communication_protocol" rel="noopener ugc nofollow" target="_blank">协议</a>解析缺陷的库却非常容易。</p><p id="fa66" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">Pimoroni Enviro+ FeatherWing板有一个用于PMS5003的连接器。示例代码包括一个绘图程序，该程序可以绘制不同速率下颗粒数据随时间变化的图形。当以最短的一秒间隔执行时，组合绘图仪程序通常在一两分钟后因<code class="du kk kl km kn b">ChecksumMismatchError</code>异常而终止。逻辑分析仪确认PMS5003发送的数据没有<em class="ko">损坏</em>。这个bug和其他一些bug一起被调查，这些bug是通过阅读其他用户遇到的问题而推断出来的。在考虑不同类型的故障和开发<a class="ae kj" href="https://en.wikipedia.org/wiki/Unit_testing" rel="noopener ugc nofollow" target="_blank">单元测试</a>时，发现了更多潜在的错误。</p><p id="0a2a" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">这项工作起源于撰写文章<a class="ae kj" href="https://www.instructables.com/Using-the-Pimoroni-Enviro-FeatherWing-With-the-Ada/" rel="noopener ugc nofollow" target="_blank"> Instructables:将Pimoroni Enviro+ FeatherWing与Adafruit Feather NRF 52840 Express</a>一起使用并修复<a class="ae kj" href="https://github.com/pimoroni/pms5003-python" rel="noopener ugc nofollow" target="_blank"> pimoroni_pms5003 </a>库中的错误。这个库是用CircuitPython编写的，它是MicroPython的一个分支，是Python 3用于微控制器的一个版本。单元测试是用Python 3编写的，可以由CPython执行。</p><p id="85e0" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">本文展示了四个新的单元测试，以及在执行<em class="ko">修订</em>代码期间串行<a class="ae kj" href="https://en.wikipedia.org/wiki/FIFO_(computing_and_electronics)" rel="noopener ugc nofollow" target="_blank"> FIFO </a>缓冲区的动画可视化。这些是用一个小Python程序创建的，用来在单元测试中对串行对象进行测试。它使用<a class="ae kj" href="https://graphviz.org/" rel="noopener ugc nofollow" target="_blank"> Graphviz </a>来帮助创建动画帧。</p><p id="1268" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">Graphviz可能更经常被用于绘制静态数据流，但它也是一个强大的工具，可以帮助快速开发数据流的动态可视化。在这种情况下，状态是从正在执行的单元测试中提取的，但是可以处理其他来源来提取一段时间内的状态，例如，详细的日志文件。</p><p id="a49a" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">披露:我偶尔为Adafruit 写<a class="ae kj" href="https://learn.adafruit.com/users/kevinjwalters" rel="noopener ugc nofollow" target="_blank">的文章。</a></p></div><div class="ab cl kp kq gp kr" role="separator"><span class="ks bw bk kt ku kv"/><span class="ks bw bk kt ku kv"/><span class="ks bw bk kt ku"/></div><div class="hb hc hd he hf"><h1 id="27a5" class="kw kx hi bd ky kz la lb lc ld le lf lg io lh ip li ir lj is lk iu ll iv lm ln bi translated">Plantower PMS5003颗粒物质传感器</h1><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es lo"><img src="../Images/9c142709edf23de42f082d9b63bb1490.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PBwbvDdqiXBaIOuqFBWOFQ.jpeg"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">Plantower PMS5003颗粒物质传感器，带试验板适配器。版权所有Adafruit。</figcaption></figure><p id="ee39" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated"><a class="ae kj" href="http://plantower.com/en/content/?108.html" rel="noopener ugc nofollow" target="_blank"> PMS5003 </a>是一款价格适中的小型传感器，基于<a class="ae kj" href="https://en.wikipedia.org/wiki/Laser_diffraction_analysis" rel="noopener ugc nofollow" target="_blank">衍射分析</a>来测量空气中的<a class="ae kj" href="https://en.wikipedia.org/wiki/Particulates" rel="noopener ugc nofollow" target="_blank">颗粒物</a>。它通常被对环境监测和空气污染感兴趣的爱好者使用。它提供2.5微米(PM2.5)和10微米(PM10)粒子的未校准测量，并且是用于<a class="ae kj" href="https://www.purpleair.com/" rel="noopener ugc nofollow" target="_blank"> PurpleAir物联网设备</a>内部的传感器。</p><p id="6578" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">它有一个9600 <a class="ae kj" href="https://en.wikipedia.org/wiki/Baud" rel="noopener ugc nofollow" target="_blank">波特</a><a class="ae kj" href="https://electronics.stackexchange.com/questions/274287/what-is-the-difference-between-rs-232-and-ttl-uart" rel="noopener ugc nofollow" target="_blank">“TTL”串行接口</a>向另一个设备传输数据。串行接口只有<code class="du kk kl km kn b">TX</code>(发送)和<code class="du kk kl km kn b">RX</code>(接收)引脚，没有用于<a class="ae kj" href="https://en.wikipedia.org/wiki/Flow_control_(data)#Hardware_flow_control" rel="noopener ugc nofollow" target="_blank">硬件流量控制</a>的额外引脚。这种类型的串行接口本质上是异步的。字节以流行的<a class="ae kj" href="https://en.wikipedia.org/wiki/Bit_numbering#Least_significant_bit" rel="noopener ugc nofollow" target="_blank"> lsb </a> -first <a class="ae kj" href="https://en.wikipedia.org/wiki/8-N-1" rel="noopener ugc nofollow" target="_blank"> 8n1 </a>格式编码。</p></div><div class="ab cl kp kq gp kr" role="separator"><span class="ks bw bk kt ku kv"/><span class="ks bw bk kt ku kv"/><span class="ks bw bk kt ku"/></div><div class="hb hc hd he hf"><h1 id="00a0" class="kw kx hi bd ky kz la lb lc ld le lf lg io lh ip li ir lj is lk iu ll iv lm ln bi translated">PMS5003协议</h1><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es lp"><img src="../Images/75f042f9f424b7ffe12d476e87d45a5c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gJZUfQ5_fXxCi8lqmVddeQ.png"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">PMS5003数据手册中的Plantower数据帧定义。中间部分省略。</figcaption></figure><p id="b22e" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">PMS5003通过串行接口发送有关微粒的数据，这些数据编码在数据帧中，如<a class="ae kj" href="https://www.aqmd.gov/docs/default-source/aq-spec/resources-page/plantower-pms5003-manual_v2-3.pdf" rel="noopener ugc nofollow" target="_blank">数据表</a>所述，并在上面显示，为简洁起见，省略了一些字段。这种人类可读的表格形式对于描述数据及其含义非常有用，但是某种类型的<a class="ae kj" href="https://en.wikipedia.org/wiki/Interface_description_language" rel="noopener ugc nofollow" target="_blank">接口定义语言(IDL) </a>是描述数据的<em class="ko">格式</em>的更精确的方式。</p><p id="00d3" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">前两个字符形成一个标题，以识别数据帧的开始。这使得即使读取在数据帧的中途开始或者它与微小的线路噪声混合，也能够找到数据帧。“校验码”是基本的<a class="ae kj" href="https://en.wikipedia.org/wiki/Checksum" rel="noopener ugc nofollow" target="_blank">校验和</a>，用于验证<a class="ae kj" href="https://en.wikipedia.org/wiki/Payload_(computing)" rel="noopener ugc nofollow" target="_blank">有效载荷</a>是否正确。数据帧的这两个部分对于解析和验证传输的完整性非常有用。数据帧大小被引用为32字节，这也是有用的。一个悬而未决的问题是，这种特定的帧大小是否是规范的一个固定部分，即数据帧是否可能在未来的固件修订版或修订产品中扩展。</p></div><div class="ab cl kp kq gp kr" role="separator"><span class="ks bw bk kt ku kv"/><span class="ks bw bk kt ku kv"/><span class="ks bw bk kt ku"/></div><div class="hb hc hd he hf"><h1 id="0c9b" class="kw kx hi bd ky kz la lb lc ld le lf lg io lh ip li ir lj is lk iu ll iv lm ln bi translated">数据率</h1><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es lq"><img src="../Images/191c3e44c63c6b9fac07d57673172eed.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*a64actuSrbEc89z4ujK2cg.png"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">逻辑分析仪显示PMS5003数据帧间隔为908.5毫秒和838.8毫秒。</figcaption></figure><p id="4a16" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">根据随机测试，很容易假设设备每秒发出一次数据帧<em class="ko">。做出这种假设的库和程序很常见。</em></p><p id="9e5e" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">一个逻辑分析仪，如这里与ScanaStudio软件一起使用的Ikalogic SQ25 ,显示情况并非如此。每个数据帧的传输会引起许多低/高转换，从而导致轨迹上出现黄色“块”。通电后不久，PMS5003将每隔908.5毫秒或838.8毫秒发送一次数据帧。这听起来非常接近一秒钟，但以一天中更快的速度，这将导致相对于预期量产生几乎半小时的<em class="ko">额外数据</em>。如果一个程序(或库)假设数据每秒发送一次，这就有问题了。一个典型的简单程序如下所示。</p><pre class="iy iz ja jb fd lr kn ls lt aw lu bi"><span id="1184" class="lv kx hi kn b fi lw lx l ly lz">pms5003 = PMS5003()<br/>while True:<br/>    data = pms5003.read()<br/>    print(data.data.pm_ug_per_m3(2.5))<br/>    time.sleep(1)</span></pre><p id="a479" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">这个代码可能是为了每秒钟读取传感器。<code class="du kk kl km kn b">read() </code>方法和<code class="du kk kl km kn b">print()</code>命令的执行时间将确保它运行的频率稍低。即使只有一个<code class="du kk kl km kn b">time.sleep(1)</code>的<code class="du kk kl km kn b">while</code>循环也不会精确地每秒运行一次，因为循环的开销很小，并且解释器中有后台任务。像C这样简单的编译语言会更接近，但这仍然会受到<a class="ae kj" href="https://en.wikipedia.org/wiki/Interrupt" rel="noopener ugc nofollow" target="_blank">中断</a>的影响。<a class="ae kj" href="https://en.wikipedia.org/wiki/Clock_rate" rel="noopener ugc nofollow" target="_blank">处理器时钟</a>的<a class="ae kj" href="https://en.wikipedia.org/wiki/Clock_drift" rel="noopener ugc nofollow" target="_blank">精度和漂移</a>也会有影响。</p><p id="d222" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">逻辑分析仪向我们展示了将<code class="du kk kl km kn b">read()</code>速率(<a class="ae kj" href="https://en.wikipedia.org/wiki/Queueing_theory" rel="noopener ugc nofollow" target="_blank">数据消费者</a>)与PMS5003发送速率(数据生产者)相匹配的任务具有挑战性。经验分析也不能保证给出PMS5003行为的完整描述。数据手册有助于提供更多细节。</p><blockquote class="ma mb mc"><p id="6c38" class="jn jo ko jp b jq jr ij js jt ju im jv md jx jy jz me kb kc kd mf kf kg kh ki hb bi translated">数字输出有两种选择:无源和有源。上电后默认模式有效。在这种模式下，传感器会自动向主机发送串行数据。</p></blockquote><p id="97a5" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">更详细地描述了“活动模式”。</p><blockquote class="ma mb mc"><p id="714f" class="jn jo ko jp b jq jr ij js jt ju im jv md jx jy jz me kb kc kd mf kf kg kh ki hb bi translated">活动模式分为两个子模式:稳定模式和快速模式。如果浓度变化很小，传感器会以2.3秒的实际间隔运行在稳定模式。如果变化很大，传感器会以200-800毫秒的间隔自动切换到快速模式，浓度越高，间隔越短。</p></blockquote><p id="60a4" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">以主动模式从该传感器读取流数据的程序或库必须以某种方式处理这种自适应/可变速率。如果其消耗数据的速率低于生产率，则数据将被缓冲，并最终在缓冲器填满时<em class="ko">被丢弃</em>。这些类型的缓冲区通常具有固定的最大大小，并且不会随着需求而动态增长<a class="ae kj" href="https://en.wikipedia.org/wiki/Dynamic_array" rel="noopener ugc nofollow" target="_blank">。对于读取数据不太频繁(即每分钟一次)的程序来说，这显然会发生得非常快。</a></p><p id="23c7" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">有问题的串行通信的一个常见策略是“让一切变得更大”。这里一个简单的方法是在Feather board上用CircuitPython做一个快速测试，大大增加接收缓冲区的大小。一个非常大的缓冲区很可能<em class="ko">出现</em>来消除前面提到的，快速测试运行的神秘<code class="du kk kl km kn b">ChecksumMismatchError</code>异常。然而，这将导致一个新的微妙问题—数据将不再是最新的，因为随着从缓冲区中不断增长的陈旧数据帧堆中读取数据，数据将逐渐落后。</p></div><div class="ab cl kp kq gp kr" role="separator"><span class="ks bw bk kt ku kv"/><span class="ks bw bk kt ku kv"/><span class="ks bw bk kt ku"/></div><div class="hb hc hd he hf"><h1 id="b091" class="kw kx hi bd ky kz la lb lc ld le lf lg io lh ip li ir lj is lk iu ll iv lm ln bi translated">阅读标题</h1><p id="38b0" class="pw-post-body-paragraph jn jo hi jp b jq mg ij js jt mh im jv jw mi jy jz ka mj kc kd ke mk kg kh ki hb bi translated">解析头时没有发现错误，但是很容易无意中产生错误。帧头是两个字节，为什么不读取两个字节，然后验证它们呢？</p><p id="818e" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">该测试在数据帧之间注入了5个流氓字节的零，说明了为什么一次读取/解析一个字节是至关重要的。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ml"><img src="../Images/d594f196037397bc912bd647344e133f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*zvhhOrmzyO2QDZPP8UOjvw.gif"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">检查双字节头解析正确性的单元测试。</figcaption></figure><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="mm mn l"/></div></figure><p id="1fd0" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">一个诱人的实现可能是读取两个字节<em class="ko">然后检查它们是否匹配<code class="du kk kl km kn b">424d</code>头。这有时会起作用，但是如果在头之前读取奇数个字节，那么它会失败，因为尽管它出现在数据中，但是<code class="du kk kl km kn b">??42</code>和<code class="du kk kl km kn b">4d??</code>都不匹配<code class="du kk kl km kn b">424d</code>。另一个好的测试是解析<code class="du kk kl km kn b">42</code>，然后解析一个好的数据帧。</em></p><p id="7449" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">这个测试相对简单，很容易理解它的执行和目的。可视化有助于强调接收缓冲区的严格大小。</p><p id="9f3e" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">这个bug确实存在于打算在Raspberry Pi上与Python一起使用的伙伴库中，参见<a class="ae kj" href="https://github.com/pimoroni/pms5003-python/pull/5" rel="noopener ugc nofollow" target="_blank">GitHub:pimoroni/PMS 5003-Python:Read SOF byte-by-byte to allow resync # 5</a>。</p></div><div class="ab cl kp kq gp kr" role="separator"><span class="ks bw bk kt ku kv"/><span class="ks bw bk kt ku kv"/><span class="ks bw bk kt ku"/></div><div class="hb hc hd he hf"><h1 id="e557" class="kw kx hi bd ky kz la lb lc ld le lf lg io lh ip li ir lj is lk iu ll iv lm ln bi translated">读取长度字段</h1><p id="6963" class="pw-post-body-paragraph jn jo hi jp b jq mg ij js jt mh im jv jw mi jy jz ka mj kc kd ke mk kg kh ki hb bi translated">长度字段出现在指示数据帧开始的两个字节之后。该值似乎可以立即用作确定还需要读取多少字节的值。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ml"><img src="../Images/728a09747fa6a2eba081865c6d65eccd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*N8moOJ2QMbO_7PaF5TnWDA.gif"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">单元测试检查一个大的、假的长度字段是否被正确处理。</figcaption></figure><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="mm mn l"/></div></figure><p id="eea2" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">该测试显示了信任长度字段未被<a class="ae kj" href="https://en.wikipedia.org/wiki/Noise_(electronics)" rel="noopener ugc nofollow" target="_blank">线路噪声</a>破坏并且是真实的一个问题。在这种情况下，固定的缓冲区大小有助于导致数据帧的截断，并且后续的数据帧与该片段相结合，从而导致缓冲区中的垃圾数据帧。</p><p id="bd0c" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">这个测试特意选择了34的缓冲长度，以便容易地重现这个错误，但是即使<em class="ko">的缓冲长度是数据帧长度</em>的倍数，也可能发生这种情况。下面的异常来自对原始示例代码的测试，该代码被增强以捕捉任何校验和异常。数字16974很特别，可能很熟悉——它是帧字节(<code class="du kk kl km kn b">424e</code>)的开始，被意外地解析为(big endian)长度字段！</p><pre class="iy iz ja jb fd lr kn ls lt aw lu bi"><span id="222b" class="lv kx hi kn b fi lw lx l ly lz">checksum error<br/>checksum error<br/>Traceback (most recent call last):<br/>  File "code.py", line 254, in &lt;module&gt;<br/>  File "code.py", line 252, in &lt;module&gt;<br/>  File "lib/pimoroni_pms5003/__init__.py", line 155, in read<br/>MemoryError: memory allocation failed, allocating 16974 bytes</span></pre><p id="7e4c" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">这个异常发生在CircuitPython中，它在<a class="ae kj" href="https://circuitpython.readthedocs.io/en/latest/shared-bindings/busio/#busio.UART" rel="noopener ugc nofollow" target="_blank"> UART </a>对象上的默认接收缓冲区大小为64字节，正好是数据帧大小的<em class="ko">两倍</em>。CircuitPython运行的处理器和主板内存有限，而<code class="du kk kl km kn b">MemoryError</code>异常可能是由于大型程序和某种程度的<a class="ae kj" href="https://en.wikipedia.org/wiki/Fragmentation_(computing)" rel="noopener ugc nofollow" target="_blank">内存碎片</a>的混合而发生的。如果库尝试读取16974字节，它可能会尝试读取530个数据帧，以最低的数据帧速率，这将需要20多分钟才能完成。</p><p id="4c2f" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">这里的一个改进是对长度字段进行全面检查，并查找规范之外的值。修订后的代码提出了一个新的例外，<code class="du kk kl km kn b">FrameLengthError</code>，针对长度更长(或更短！)大于预期值。如果数据帧大小在将来发生变化，保持一定灵活性的实现是有用的。一般来说，数据字段随着时间的推移而变化是很常见的，通常会变大。</p><p id="1ac2" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">有人可能会问，如果接收缓冲区大小为64，而数据帧大小为32，这种坏数据帧是如何出现的。看起来缓冲区最多只能容纳2个数据帧，不包括部分截断的数据帧。这将在下一节中探讨。</p></div><div class="ab cl kp kq gp kr" role="separator"><span class="ks bw bk kt ku kv"/><span class="ks bw bk kt ku kv"/><span class="ks bw bk kt ku"/></div><div class="hb hc hd he hf"><h1 id="449b" class="kw kx hi bd ky kz la lb lc ld le lf lg io lh ip li ir lj is lk iu ll iv lm ln bi translated">串行缓冲器</h1><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es mo"><img src="../Images/cde799561a4bb33cb827185c8d63ddcc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*R56uXmx6QlLFVySk1Z4pfA.jpeg"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">16550 afn UART——来自IBM PC/AT的16450的增强版本。照片由hmvh，维基百科。</figcaption></figure><p id="5ddd" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">在异步协议中，数据可以在任何时候发送，接收方需要将其存储在某个地方。主处理器通常从<a class="ae kj" href="https://en.wikipedia.org/wiki/Universal_asynchronous_receiver-transmitter" rel="noopener ugc nofollow" target="_blank">通用异步收发器(UART) </a>获得一些帮助。IBM PC系列最初为此使用8250和16450芯片，它们可以缓冲一个字节。上面显示的16550AFN有一个16字节的缓冲区，减少了主处理器错过表示新数据的中断的机会。如果<a class="ae kj" href="https://en.wikipedia.org/wiki/Interrupt_latency" rel="noopener ugc nofollow" target="_blank">中断没有及时得到服务</a>，那么数据将会丢失，因为后续字节会覆盖UART中的数据。微控制器倾向于集成UARTs，Adafruit Feather nRF52840 Express板上使用的<a class="ae kj" href="https://www.nordicsemi.com/Products/Low-power-short-range-wireless/nRF52840" rel="noopener ugc nofollow" target="_blank">Nordic Semiconductor NRF 52840</a>有一个带6字节缓冲区的<a class="ae kj" href="https://infocenter.nordicsemi.com/index.jsp?topic=%2Fstruct_nrf52%2Fstruct%2Fnrf52840.html&amp;cp=3_0" rel="noopener ugc nofollow" target="_blank">。</a></p><p id="04f6" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">硬件缓冲区由操作系统或CircuitPython解释器中的额外缓冲区补充。如前所述，接收缓冲区默认大小为64字节。由于这是数据帧大小的倍数，这可能会降低<code class="du kk kl km kn b">ChecksumMismatchError</code>异常的频率，但手动测试将显示它们仍然会不可预测地发生。硬件缓冲区的大小也有影响，这取决于CircuitPython解释器如何配置和读取它。</p><p id="0a91" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">在<a class="ae kj" href="https://en.wikipedia.org/wiki/8-N-1" rel="noopener ugc nofollow" target="_blank"> 8n1 </a>发送的32字节数据帧相当于320位。在9600波特的速率下，这需要33.3毫秒，这意味着在传输期间有很大机会从缓冲器<em class="ko">中读取数据。如果程序在PMS5003发送数据后立即读取数据，那么应该没有问题。如果它以较低的<em class="ko">速率</em>读取，那么这肯定会最终导致问题，并且这些问题看起来会随机发生。</em></p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es mp"><img src="../Images/c13742bfbcd2a9be372c3b695a813a3b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wE0bQ_j44V7Lw6fjaqRoZQ.png"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">逻辑分析仪显示程序读取数据帧的速率低于PMS5003发送速率。程序的第二次读取在第二个数据帧传输期间开始。</figcaption></figure><p id="e95d" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">上例显示了由<code class="du kk kl km kn b">Red Toggle</code>(红色)线的下降沿和上升沿指示的两次库读取。为了延长捕获时间，该轨迹以相当低的采样速率(10kHz)捕获。这种低采样率阻止了数据中字节的解码，但是仍然可以清楚地看到每个数据帧传输的总长度。</p><p id="bd33" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">第一次读取(标记1)发生在流式数据帧传输之前。第二次读取(标记2)发生在传输期间的<em class="ko">。这里的产生(传输)速率为1.10Hz，消耗速率为0.752Hz，这显然会导致默认的CircuitPython UART接收缓冲区在几秒钟后就满了。第二次读取可以很容易地释放<em class="ko">一些</em>缓冲空间，但是<em class="ko">并不是整个</em>数据帧的价值。这可以导致第二数据帧的<em class="ko">部分</em>结束部分在缓冲器中结束。</em></p><p id="0ef3" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">这个问题的本质是发送和接收数据的非同步<a class="ae kj" href="https://en.wikipedia.org/wiki/Concurrency_(computer_science)" rel="noopener ugc nofollow" target="_blank">并发</a>。这是这种交流形式的本质，因此程序或库需要处理这种情况。这对于用传统的单元测试来说是一个具有挑战性的领域，因为它们往往具有顺序性。即使真正的并发是可以实现的，在单元测试中使用它也是不明智的，因为行为是不太可能精确预测的。这可能导致测试偶尔神秘地失败。</p><p id="0222" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">从理论上讲，在传输过程中开始的库读取也可能发生在库第一次从传感器读取时。如果重置传感器，这种可能性几乎为零，因为库可以清除接收缓冲区，然后等待传感器初始化并开始发送数据。</p></div><div class="ab cl kp kq gp kr" role="separator"><span class="ks bw bk kt ku kv"/><span class="ks bw bk kt ku kv"/><span class="ks bw bk kt ku"/></div><div class="hb hc hd he hf"><h1 id="bf6e" class="kw kx hi bd ky kz la lb lc ld le lf lg io lh ip li ir lj is lk iu ll iv lm ln bi translated">数据帧的部分读取</h1><p id="7a6d" class="pw-post-body-paragraph jn jo hi jp b jq mg ij js jt mh im jv jw mi jy jz ka mj kc kd ke mk kg kh ki hb bi translated">这个测试显示了三个数据帧，总共96字节，试图挤进一个80字节的缓冲区。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ml"><img src="../Images/d261382ca1f422a7a727d4c9a842466c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*qBE9e2mflPW6pD0fYKOGnA.gif"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">单元测试检查截断的部分数据帧是否得到正确处理。</figcaption></figure><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="mm mn l"/></div></figure><p id="c549" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">这是测试代码是否被截断以及剩余数据是否出现的简单方法。在这种情况下，库应该超时，这就是单元测试以<code class="du kk kl km kn b">SerialTimeoutError</code>异常的形式寻找的。耐心等待永恒的图书馆听起来是破碎的！</p></div><div class="ab cl kp kq gp kr" role="separator"><span class="ks bw bk kt ku kv"/><span class="ks bw bk kt ku kv"/><span class="ks bw bk kt ku"/></div><div class="hb hc hd he hf"><h1 id="a925" class="kw kx hi bd ky kz la lb lc ld le lf lg io lh ip li ir lj is lk iu ll iv lm ln bi translated">重试次数</h1><p id="d0f3" class="pw-post-body-paragraph jn jo hi jp b jq mg ij js jt mh im jv jw mi jy jz ka mj kc kd ke mk kg kh ki hb bi translated">该库可以将错误传递回程序，但也可以提供简单的重试机制来跳过任何错误。该功能已添加到库中，下面的测试显示了它如何跳过损坏的数据帧。</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="mm mn l"/></div></figure><p id="1564" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">执行的动画没有显示太多，已经被省略了。这个测试的关键部分是第二个<code class="du kk kl km kn b">read()</code>成功，没有异常，并返回预期的数据。对<code class="du kk kl km kn b">data_available()</code>的最后一次调用是一个很好的补充，可以验证什么都没有留下。</p><p id="8b16" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">一些单元测试需要检查是否在预期的地方生成了异常——这些异常将<code class="du kk kl km kn b">retries=0</code>传递给构造函数以禁用该特性。</p></div><div class="ab cl kp kq gp kr" role="separator"><span class="ks bw bk kt ku kv"/><span class="ks bw bk kt ku kv"/><span class="ks bw bk kt ku"/></div><div class="hb hc hd he hf"><h1 id="f319" class="kw kx hi bd ky kz la lb lc ld le lf lg io lh ip li ir lj is lk iu ll iv lm ln bi translated">读取数据字段</h1><p id="0747" class="pw-post-body-paragraph jn jo hi jp b jq mg ij js jt mh im jv jw mi jy jz ka mj kc kd ke mk kg kh ki hb bi translated">测试或代码检查没有发现任何错误，但是典型的问题是:</p><ul class=""><li id="216a" class="mq mr hi jp b jq jr jt ju jw ms ka mt ke mu ki mv mw mx my bi translated">精确的消息结构，定义仅在数据表中；</li><li id="5aff" class="mq mr hi jp b jq mz jt na jw nb ka nc ke nd ki mv mw mx my bi translated">关心<a class="ae kj" href="https://en.wikipedia.org/wiki/Endianness" rel="noopener ugc nofollow" target="_blank">字节序</a>，这是一个常见的问题来源；</li><li id="6513" class="mq mr hi jp b jq mz jt na jw nb ka nc ke nd ki mv mw mx my bi translated">为每个字段获取正确的单位。</li></ul></div><div class="ab cl kp kq gp kr" role="separator"><span class="ks bw bk kt ku kv"/><span class="ks bw bk kt ku kv"/><span class="ks bw bk kt ku"/></div><div class="hb hc hd he hf"><h1 id="977f" class="kw kx hi bd ky kz la lb lc ld le lf lg io lh ip li ir lj is lk iu ll iv lm ln bi translated">以被动模式请求数据</h1><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ne"><img src="../Images/92d466dc9e2b2619e656a8e0f0af9a18.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*91vqoRuMBoP_zQaDQ5feXA.png"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">PMS5003数据手册中的Plantower命令定义。</figcaption></figure><p id="4775" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">PMS5003的默认模式是在“活动”模式下连续传输数据流。可以向PMS5003发送命令帧，将其切换到“被动”模式，在这种模式下，必须发送读取命令来请求数据帧。这可以在下面的逻辑分析器跟踪中看到。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es nf"><img src="../Images/4a75b4c8a1fb30cddf9942b8abccfc87.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*guWpExVpyTrvAKemkCc1Kw.png"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">逻辑分析仪显示主动模式下PMS5003的三个读数，然后是被动模式下的三个读数。</figcaption></figure><p id="b227" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">复位(绿色)线在5.4秒(标记1)时短暂地变为低电平，以复位器件。在大约7.3秒时，PMS5003升起<code class="du kk kl km kn b">RX</code>(黄色)线，在8.7秒时，PMS5003以主动模式发送第一个数据帧。程序切换输出值(红线)来显示三个<code class="du kk kl km kn b">read()</code>语句何时出现。<code class="du kk kl km kn b">RX</code>线上的数据帧显然与前三次读取不同步。</p><p id="4682" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">复位线在12.0秒时发出脉冲(标记2)以再次复位设备。在14.4秒时，第一个数据帧被发送，指示健康的PMS5003，库代码在14.6秒时发送一个命令，改变到被动模式，可在<code class="du kk kl km kn b">TX</code>(蓝色)线上观察到。现在，每个<code class="du kk kl km kn b">read()</code>语句都会发送一个读命令，并立即发送回一个数据帧作为响应。这极大地简化了库代码中响应的缓冲和正确解析。</p><p id="5c79" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">当切换到被动模式的命令得到响应时，仍然需要一些注意，但是具有不适当时序的数据帧可能在此之前潜入，混淆简单的实现。即使在发送开关模式命令之前，串行接收缓冲器已被清空，这种情况也会发生。</p><p id="1842" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">Adafruit为PMS5003 提供了自己的CircuitPython库，该库有一个待定的<a class="ae kj" href="https://en.wikipedia.org/wiki/Distributed_version_control#Pull_requests" rel="noopener ugc nofollow" target="_blank"> PR </a>到<a class="ae kj" href="https://github.com/adafruit/Adafruit_CircuitPython_PM25/pull/13" rel="noopener ugc nofollow" target="_blank">添加对被动模式</a>的支持。这是Pimoroni库的增强<a class="ae kj" href="https://github.com/pimoroni/pms5003-circuitpython/issues/5" rel="noopener ugc nofollow" target="_blank">的基础。默认模式是主动的，以避免改变现有程序的行为，但被动模式可能是大多数程序的更好选择。</a></p></div><div class="ab cl kp kq gp kr" role="separator"><span class="ks bw bk kt ku kv"/><span class="ks bw bk kt ku kv"/><span class="ks bw bk kt ku"/></div><div class="hb hc hd he hf"><h1 id="8f03" class="kw kx hi bd ky kz la lb lc ld le lf lg io lh ip li ir lj is lk iu ll iv lm ln bi translated">结论</h1><ul class=""><li id="d838" class="mq mr hi jp b jq mg jt mh jw ng ka nh ke ni ki mv mw mx my bi translated">正确、可靠地解析串行协议可能比看起来更难，尤其是对于可变速率的数据流。</li><li id="1cf1" class="mq mr hi jp b jq mz jt na jw nb ka nc ke nd ki mv mw mx my bi translated">逻辑分析仪是捕捉TTL风格串行通信的有用工具。这不仅允许检查行为和精确定时，而且允许解码数据。</li><li id="d833" class="mq mr hi jp b jq mz jt na jw nb ka nc ke nd ki mv mw mx my bi translated">测试以观察行为是有用的，但也必须参考数据手册等参考信息。任何差异或遗漏都应与制造商讨论。</li><li id="ae29" class="mq mr hi jp b jq mz jt na jw nb ka nc ke nd ki mv mw mx my bi translated">调查存在的问题和对有问题的行为的讨论是有用的研究，有助于寻找bug、开发单元测试和指导手工测试。</li><li id="4040" class="mq mr hi jp b jq mz jt na jw nb ka nc ke nd ki mv mw mx my bi translated">在修复bug或添加特性时，需要认真考虑库接口的变化。这包括添加以前没有出现的异常。</li></ul></div><div class="ab cl kp kq gp kr" role="separator"><span class="ks bw bk kt ku kv"/><span class="ks bw bk kt ku kv"/><span class="ks bw bk kt ku"/></div><div class="hb hc hd he hf"><h1 id="aa17" class="kw kx hi bd ky kz la lb lc ld le lf lg io lh ip li ir lj is lk iu ll iv lm ln bi translated">资源</h1><ul class=""><li id="7ed4" class="mq mr hi jp b jq mg jt mh jw ng ka nh ke ni ki mv mw mx my bi translated"><a class="ae kj" href="https://www.instructables.com/Using-the-Pimoroni-Enviro-FeatherWing-With-the-Ada/" rel="noopener ugc nofollow" target="_blank">说明:将Pimoroni Enviro+ FeatherWing与Adafruit Feather NRF52840 Express一起使用</a></li><li id="5005" class="mq mr hi jp b jq mz jt na jw nb ka nc ke nd ki mv mw mx my bi translated">GitHub PR:<a class="ae kj" href="https://github.com/pimoroni/pms5003-circuitpython/pull/8" rel="noopener ugc nofollow" target="_blank">pimoroni/PMS 5003-circuit python:增加了对串行读取、重试和请求数据的新被动模式的关注#8 </a></li><li id="b222" class="mq mr hi jp b jq mz jt na jw nb ka nc ke nd ki mv mw mx my bi translated">GitHub PR:<a class="ae kj" href="https://github.com/pimoroni/EnviroPlus-FeatherWing/pull/24" rel="noopener ugc nofollow" target="_blank">pimoroni/enviro plus-feather wing:改进了屏幕绘图仪的内存使用，修复了一些错误，并增强了#24 </a></li><li id="c835" class="mq mr hi jp b jq mz jt na jw nb ka nc ke nd ki mv mw mx my bi translated">GitHub PR:<a class="ae kj" href="https://github.com/adafruit/Adafruit_CircuitPython_PM25/pull/13" rel="noopener ugc nofollow" target="_blank">adafruit/ada fruit _ circuit python _ PM25:UART修复和特性#13 </a> — Erik Hess为ada fruit的等效库实现被动模式。</li><li id="32c1" class="mq mr hi jp b jq mz jt na jw nb ka nc ke nd ki mv mw mx my bi translated"><a class="ae kj" href="https://github.com/kevinjwalters/pms5003-circuitpython-test-visualisation" rel="noopener ugc nofollow" target="_blank">单元测试可视化器</a>，运行pms5003-circuitpython单元测试的代码，使用仪器观察串行缓冲区的行为，并使用Graphviz创建一系列帧，用于创建本文中的动画。<a class="ae kj" href="https://imagemagick.org/" rel="noopener ugc nofollow" target="_blank"> ImageMagick </a>可用于将png输出合并成动画gif。</li><li id="eb65" class="mq mr hi jp b jq mz jt na jw nb ka nc ke nd ki mv mw mx my bi translated"><a class="ae kj" href="https://ikalogic.com/sq-logic-analyzer-pattern-generator/" rel="noopener ugc nofollow" target="_blank"> Ikalogic SQ25 </a>，4通道逻辑分析仪，用于本文的调试、测试和截图。</li><li id="b9dc" class="mq mr hi jp b jq mz jt na jw nb ka nc ke nd ki mv mw mx my bi translated"><a class="ae kj" href="https://shop.pimoroni.com/products/enviro-plus-featherwing" rel="noopener ugc nofollow" target="_blank">Pimoroni Enviro+feather wing</a></li><li id="02ec" class="mq mr hi jp b jq mz jt na jw nb ka nc ke nd ki mv mw mx my bi translated"><a class="ae kj" href="https://www.adafruit.com/product/4062" rel="noopener ugc nofollow" target="_blank">Adafruit Feather NRF 52840 Express</a>，Enviro+ FeatherWing推荐使用的羽毛板之一。</li><li id="8616" class="mq mr hi jp b jq mz jt na jw nb ka nc ke nd ki mv mw mx my bi translated"><a class="ae kj" href="http://plantower.com/en/content/?108.html" rel="noopener ugc nofollow" target="_blank"> Plantower PMS5003颗粒物传感器</a></li></ul></div></div>    
</body>
</html>