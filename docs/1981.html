<html>
<head>
<title>UUID over IndexPath</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">索引路径上的 UUID</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/uuid-over-indexpath-3ac126e85304?source=collection_archive---------9-----------------------#2021-04-15">https://medium.com/nerd-for-tech/uuid-over-indexpath-3ac126e85304?source=collection_archive---------9-----------------------#2021-04-15</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><figure class="hh hi ez fb hj hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es hg"><img src="../Images/27e8cafff3802392903b0ff521726c5e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6wpKU33nShtKatAbZG2XgQ.jpeg"/></div></div></figure><div class=""/><p id="2470" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">你好。</p><p id="62fe" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">今天我想建议当<strong class="is hu"> UICollectionView </strong>中的项目或者<strong class="is hu"> UITableView </strong>中的单元格被选中时，开始使用<a class="ae jo" href="https://developer.apple.com/documentation/foundation/uuid" rel="noopener ugc nofollow" target="_blank"><strong class="is hu">【UUID】</strong></a>在列表中查找合适的模型，而不是使用<strong class="is hu"> IndexPath </strong>。</p><p id="86e1" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">出于本文的目的，我假设您熟悉使用<strong class="is hu"> IndexPath </strong>从数组中检索合适的模型。</p></div><div class="ab cl jp jq gp jr" role="separator"><span class="js bw bk jt ju jv"/><span class="js bw bk jt ju jv"/><span class="js bw bk jt ju"/></div><div class="hb hc hd he hf"><p id="80c3" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我将使用我上一篇文章<a class="ae jo" href="https://rafal-prazynski.medium.com/resolve-reusable-cell-problem-47476d17a0ed" rel="noopener"> <strong class="is hu">中的 project 解决可重用单元格问题</strong> </a>并对其进行一点点调整，以恰当地表达本文的意图。</p></div><div class="ab cl jp jq gp jr" role="separator"><span class="js bw bk jt ju jv"/><span class="js bw bk jt ju jv"/><span class="js bw bk jt ju"/></div><div class="hb hc hd he hf"><p id="88f1" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">那么各个班级的情况如何呢？</p><h2 id="ae22" class="jw jx ht bd jy jz ka kb kc kd ke kf kg jb kh ki kj jf kk kl km jj kn ko kp kq bi translated">MOCK.swift</h2><p id="8c7c" class="pw-post-body-paragraph iq ir ht is b it kr iv iw ix ks iz ja jb kt jd je jf ku jh ji jj kv jl jm jn hb bi translated">我在这里声明了包含要显示的图像名称的非排序响应。响应模型(<strong class="is hu">佩佩</strong>)被包裹在<a class="ae jo" href="https://en.wikipedia.org/wiki/Data_transfer_object" rel="noopener ugc nofollow" target="_blank"><strong class="is hu">DTO</strong></a><strong class="is hu"/>(<strong class="is hu">佩佩托</strong>)结构中，该结构包含类型<a class="ae jo" href="https://developer.apple.com/documentation/foundation/uuid" rel="noopener ugc nofollow" target="_blank"> <strong class="is hu"> UUID </strong> </a>的属性<em class="kw"> ID </em>。这个<em class="kw"> ID </em>将用于识别我稍后将展示的列表中的型号。</p><figure class="ky kz la lb fd hk er es paragraph-image"><div class="er es kx"><img src="../Images/cbb5c69aab1f1b4c84e729a97b752248.png" data-original-src="https://miro.medium.com/v2/resize:fit:346/format:webp/1*RKwmkH368fqgH8w8rGxatA.png"/></div><figcaption class="lc ld et er es le lf bd b be z dx translated">Pepe 结构</figcaption></figure></div><div class="ab cl jp jq gp jr" role="separator"><span class="js bw bk jt ju jv"/><span class="js bw bk jt ju jv"/><span class="js bw bk jt ju"/></div><div class="hb hc hd he hf"><h2 id="4fd3" class="jw jx ht bd jy jz ka kb kc kd ke kf kg jb kh ki kj jf kk kl km jj kn ko kp kq bi translated"><strong class="ak"> CollectionView.swift </strong></h2><p id="6002" class="pw-post-body-paragraph iq ir ht is b it kr iv iw ix ks iz ja jb kt jd je jf ku jh ji jj kv jl jm jn hb bi translated">这里我用下面的方法声明了一个协议<strong class="is hu">CollectionViewCellInteractionProtocol</strong>:</p><blockquote class="lg lh li"><p id="4006" class="iq ir kw is b it iu iv iw ix iy iz ja lj jc jd je lk jg jh ji ll jk jl jm jn hb bi translated">func selectedItem(位于索引路径:索引路径)</p></blockquote><p id="a28c" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">该方法将委托动作到<strong class="is hu"> UICollectionView </strong>之外。<br/>不要在对象之间创建紧密的连接是一个好习惯，使用协议进行解耦也是一个好方法。这种方法给了我们更多的灵活性。</p><p id="2432" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">从<strong class="is hu">uicollectionview delegate</strong>方法中的<strong class="is hu">CollectionViewCellInteractionProtocol</strong>调用方法:</p><blockquote class="lg lh li"><p id="7235" class="iq ir kw is b it iu iv iw ix iy iz ja lj jc jd je lk jg jh ji ll jk jl jm jn hb bi translated">func collection view(_ collection view:UICollectionView，didSelectItemAt index path:index path)</p></blockquote></div><div class="ab cl jp jq gp jr" role="separator"><span class="js bw bk jt ju jv"/><span class="js bw bk jt ju jv"/><span class="js bw bk jt ju"/></div><div class="hb hc hd he hf"><h2 id="196d" class="jw jx ht bd jy jz ka kb kc kd ke kf kg jb kh ki kj jf kk kl km jj kn ko kp kq bi translated">collectionviewcell builder . swift</h2><p id="8cec" class="pw-post-body-paragraph iq ir ht is b it kr iv iw ix ks iz ja jb kt jd je jf ku jh ji jj kv jl jm jn hb bi translated">这里我用下面的方法声明了一个协议<strong class="is hu">CollectionViewCellBuilderProtocol</strong>。：</p><blockquote class="lg lh li"><p id="c362" class="iq ir kw is b it iu iv iw ix iy iz ja lj jc jd je lk jg jh ji ll jk jl jm jn hb bi translated">func selected model(id 为:UUID)</p></blockquote><p id="b557" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们需要这个方法来通知<strong class="is hu">CollectionViewCellBuilder</strong>外部哪个 UUID 被选中了。</p><p id="06f4" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">此外，<strong class="is hu"> PepeBuilder </strong>(这里是展示其工作原理的文章:<a class="ae jo" href="https://rafal-prazynski.medium.com/resolve-reusable-cell-problem-47476d17a0ed" rel="noopener"> <strong class="is hu">解决可重用单元问题</strong> </a>)包含闭包声明<strong class="is hu"> <em class="kw"> selectedModel、</em> </strong>用于处理单元上的用户交互，并将在协议<strong class="is hu">CollectionViewCellInteractionProtocol</strong>的方法实现中调用</p></div><div class="ab cl jp jq gp jr" role="separator"><span class="js bw bk jt ju jv"/><span class="js bw bk jt ju jv"/><span class="js bw bk jt ju"/></div><div class="hb hc hd he hf"><h2 id="d058" class="jw jx ht bd jy jz ka kb kc kd ke kf kg jb kh ki kj jf kk kl km jj kn ko kp kq bi translated">这一切是如何运作的:</h2><ol class=""><li id="7eda" class="lm ln ht is b it kr ix ks jb lo jf lp jj lq jn lr ls lt lu bi translated">在<strong class="is hu">视图控制器</strong>中，未排序的模拟模型被创建(<strong class="is hu"> PepesModel </strong>)，保存在全局变量中并传递给<strong class="is hu">collectionviewcell builder</strong>以及<strong class="is hu">视图控制器</strong>正在实现<strong class="is hu">collectionviewcell builder 协议</strong>。</li><li id="0bf0" class="lm ln ht is b it lv ix lw jb lx jf ly jj lz jn lr ls lt lu bi translated">在<strong class="is hu">collectionviewcell builder</strong>中是<strong class="is hu">pep 到</strong>的排序列表，按其属性名<strong class="is hu"><em class="kw"/></strong>，创建<strong class="is hu"> PepeCollectionViewCell 的<strong class="is hu">viewmodel</strong>，</strong>将那些<strong class="is hu">viewmodel</strong>传递给<strong class="is hu"> PepeBuilder </strong>并实现闭包<strong class="is hu"><em class="kw">selected model</em></strong><em class="kw">。</em>实现<strong class="is hu"><em class="kw">selected model</em></strong>是从<strong class="is hu">CollectionViewCellBuilderProtocol</strong>中调用的方法，用于根据选中的单元格传递 UUID。</li><li id="567d" class="lm ln ht is b it lv ix lw jb lx jf ly jj lz jn lr ls lt lu bi translated"><strong class="is hu"> ViewController </strong>从<strong class="is hu">CollectionViewCellBuilder</strong>接收选择的 UUID，并从未排序列表中检索模型。</li><li id="7cb0" class="lm ln ht is b it lv ix lw jb lx jf ly jj lz jn lr ls lt lu bi translated">假设用户点击了索引 4 处的项目，那么我们应该会看到这些日志:</li></ol><figure class="ky kz la lb fd hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es ma"><img src="../Images/b69942aec818606d2b67d191f8f5f8c8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ME6DkXk07EZ9aJRuPQYDAQ.png"/></div></div></figure><h2 id="fded" class="jw jx ht bd jy jz ka kb kc kd ke kf kg jb kh ki kj jf kk kl km jj kn ko kp kq bi translated">它给了我们什么？</h2><p id="dd00" class="pw-post-body-paragraph iq ir ht is b it kr iv iw ix ks iz ja jb kt jd je jf ku jh ji jj kv jl jm jn hb bi translated">在上面的例子中，我们有两个不同的列表:第一个是排序的，第二个不是。多亏了 UUID，我们不需要再去整理第二个了。此外，如果显示的单元格的顺序发生任何变化，我们也不需要担心两个独立列表的索引同步。</p><p id="a107" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">感谢阅读，祝<strong class="is hu">好运！</strong></p><blockquote class="lg lh li"><p id="0162" class="iq ir kw is b it iu iv iw ix iy iz ja lj jc jd je lk jg jh ji ll jk jl jm jn hb bi translated">完整代码:<a class="ae jo" href="https://github.com/Rafal-Prazynski/UUID_over_IndexPath" rel="noopener ugc nofollow" target="_blank">https://github.com/Rafal-Prazynski/UUID_over_IndexPath</a></p></blockquote></div></div>    
</body>
</html>