# 没有上下文和回调/验证条件的 Rails 上下文

> 原文：<https://medium.com/nerd-for-tech/rails-context-without-context-callback-validation-conditions-8015ab28ac0?source=collection_archive---------2----------------------->

当你越来越喜欢 Rails 或任何其他框架时，有时你会认为默认的**并不是你所需要的**。在 Ruby on Rails 的那个案例中，我就遇到过这种情况。

# 让我提出我的理由:

我开发的应用程序有两个生产应用程序在 Heroku 上运行。CI 通过后，这两个应用程序会自动从同一个 Github repo 部署。不幸的是，在其中一个应用程序中，一个模型中必须有一个非常小的差异。然而，他们必须在未来的每一次代码变更中保持同步，当然，除了这一点点差异和数据库。

当这两个应用程序必须在幕后拥有相同的代码时，它们应该如何做一些不同于其他应用程序的事情呢？

很快，我发现我可以使用的区别是网址。如果用户在某个域中，我需要验证一个模型并调用回调函数。

作为最初的想法，我提出了这样的东西:

当然，这太简单了，因为你已经想到当你在服务器上的模型中时，你不能访问域名…

# Rails '验证上下文

继续搜索，我发现 Rails 实际上有对上下文的原生支持！我只需在控制器中保存“我的模型”时给出上下文，我可以这样使用它:

看起来不错，对吧？好吧，这里发生了什么？在控制器中，我通过检查请求来检查用户是否在正确的 URL 上。如果用户是，我通过转发一个上下文来保存模型。然后可以在模型中访问这个上下文，这样只有在给出相应的上下文时才会调用验证。

到目前为止一切顺利！但是该死的，这不能用在回调上，如果你对不同的上下文有不同的验证，你的“if-statement”在保存上下文时会变得很长。

# PORO(普通的老红宝石对象)的方式

我们还在编写 ruby 代码，对吧？最终，**Rails 模型只不过是一个带有一些 Rails 魔力的 PORO** 。让我们利用这一点！

我们可以简单地给模型一个非数据库实例变量，并使用它来检查验证/回调是否应该运行。这样，当然，这个变量不会被写入数据库，但是我们不需要它，因为它只是一些上下文，对吗？

**让我们 PORO 一下:**

我们在这里所做的最终是非常基本的。在从前端的表单中获得允许的参数(最终只是一个散列)后，我们添加另一个键值对`on_my_domain: on_my_domain?`，它解析为`on_my_domain: true`或`on_my_domain: false`。这将使用`attr_writer`将我们的上下文实例变量添加到模型的实例中。我们可以使用`@on_my_domain`来访问它，或者在我们的例子中通过`on_my_domain?`来访问。验证、回调和其他一切现在都可以使用这些信息了！

太棒了，对吧？！

请记住，一旦实例消失了,“上下文”也将消失。

# 让它更滑稽

综上所述，它已经运行得非常好了！不过，在更大的应用程序中，在不同的控制器和不同的模型中使用这样的上下文变量可能会很有趣。幸运的是，我们在这里讨论的是 Rails，所以请放松:)

我们可以将我们的前端检查放入一个助手中，这样它就可以在几个控制器中使用，如下所示:

让我们完成它并写一个关注点，这样每个需要它的模型都可以使用我们的上下文变量:

就是这样！我希望这对你有所帮助。祝您愉快:)