<html>
<head>
<title>Policy As Code — Open Policy Agent In Cloud Native Stack</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">策略即代码—云本机堆栈中的开放策略代理</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/policy-as-code-open-policy-agent-in-cloud-native-stack-5a7b7266db06?source=collection_archive---------8-----------------------#2021-07-03">https://medium.com/nerd-for-tech/policy-as-code-open-policy-agent-in-cloud-native-stack-5a7b7266db06?source=collection_archive---------8-----------------------#2021-07-03</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="9804" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">当我们想到端到端自动化任何流程时，我们想到的是自动化该特定流程的每一个末端。我们脑海中闪现的一个术语是，我们在整个过程或管道中“不需要人工干预”。作为 DevOps 和云爱好者，让我们考虑在任何云提供商(AWS、谷歌云平台或微软 Azure)或任何裸机服务器或机器集群上部署基础设施。目前有许多工具和技术可以以优化的方式灵活地实现基础架构的自动化和资源调配。</p><p id="99f3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">此外，我们将<strong class="ih hj">基础架构的概念作为代码</strong>，这是通过声明性配置文件管理和配置基于云的系统或此类基础架构的明确流程，而不是物理硬件配置或一些其他配置管理工具。我们有几个工具可以在不同的平台上实现自动化和流程编排。我们有不同的工具范围，从开源解决方案到基于企业级 SaaS 的应用程序。在这篇博客中，我们将了解 OPA(开放策略代理)，它是开源<strong class="ih hj">“策略即代码”</strong>测试工具。</p><h1 id="2764" class="jd je hi bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">开放策略代理(OPA)</h1><p id="536a" class="pw-post-body-paragraph if ig hi ih b ii kb ik il im kc io ip iq kd is it iu ke iw ix iy kf ja jb jc hb bi translated">它是一个开源工具，为我们提供了策略即代码的概念，通过在基础设施代码进入生产环境之前对其进行评估，帮助我们快速测试专门为任何基础设施定义的策略和规则。例如，我们可以将其视为一个预部署步骤，首先检查策略和法规，然后发送部署特定基础架构的执行命令。OPA 只是为我们提供了基于策略的控制，用于云原生环境和类似的堆栈。OPA 的使用可以作为一个统一的工具集和框架，用于跨云原生堆栈的策略。</p><p id="3d82" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果您只考虑您的一个服务或整个堆栈中的所有服务，可以使用 OPA 将策略从服务代码中分离出来，这样您就可以发布、分析和审查策略，而不会影响基础架构的可用性或性能。</p><p id="939d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在这篇博客中，我们将探讨用不同的供应和自动化工具实现 OPA。</p><h1 id="af3e" class="jd je hi bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated"><strong class="ak">将 OPA 与 Terraform 供应工作流程合并</strong></h1><p id="914a" class="pw-post-body-paragraph if ig hi ih b ii kb ik il im kc io ip iq kd is it iu ke iw ix iy kf ja jb jc hb bi translated">Terraform 是一个著名的开源工具，它使用<strong class="ih hj">基础设施的概念作为代码</strong>，用于许多云、基础设施或此类服务的自动化和供应。它由 HashiCorp 开发，可为任何应用提供一致的工作流来配置、保护、连接和运行任何基础设施。</p><figure class="kh ki kj kk fd kl er es paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="er es kg"><img src="../Images/9d983dbaf7db9271a04e3d772d5dad76.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PCaB_gH12tlPi9KsBWaybg.png"/></div></div><figcaption class="ks kt et er es ku kv bd b be z dx translated">图 1:来自<a class="ae kw" href="https://d1.awsstatic.com/whitepapers/DevOps/infrastructure-as-code.pdf" rel="noopener ugc nofollow" target="_blank"> AWS 文档</a>的典型基础设施资源生命周期</figcaption></figure><p id="165c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">借助 terraform 配置中的 OPA，我们可以轻松地编写策略，在 Terraform 做出更改之前测试它将要做出的更改。这些特定的测试可以帮助我们检查要应用的更改的健全性，此外，它可以减少同行审查的负担，使流程完全自动化，并有助于在将 Terraform 应用于试运行后发现在将它应用于生产时出现的问题。</p><h1 id="60f5" class="jd je hi bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">使用 OPA 测试您的地形配置</h1><p id="fb81" class="pw-post-body-paragraph if ig hi ih b ii kb ik il im kc io ip iq kd is it iu ke iw ix iy kf ja jb jc hb bi translated">OPA 在实际供应任何基础设施之前充当了一个关口，因此团队可以很容易地在最早的时机发现合规性问题。下面是一个工作流，它使用 OPA 来确定给定的 Terraform (TF)代码在管道中是否有效。</p><figure class="kh ki kj kk fd kl er es paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="er es kx"><img src="../Images/a1a97268733c0416a1f7b678d742e6b7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uqck5xIRotDxyTDlJMtdgA.png"/></div></div><figcaption class="ks kt et er es ku kv bd b be z dx translated">使用开放策略代理执行地形配置的管道。</figcaption></figure><h1 id="6fc8" class="jd je hi bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated"><strong class="ak">测试微软 Azure Terraform 配置的示例</strong></h1><p id="f47d" class="pw-post-body-paragraph if ig hi ih b ii kb ik il im kc io ip iq kd is it iu ke iw ix iy kf ja jb jc hb bi translated">在这里，我们可以获取 terraform 的一个示例配置，它创建了创建虚拟机所需的少量资源，为了全面了解使用 Azure 的 terraform 配置，您可以在这里查看<a class="ae kw" href="https://thesaadahmed.medium.com/power-automation-management-of-infrastructure-using-ansible-and-terraform-3e68a246508" rel="noopener"/>。</p><p id="9321" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">1) <strong class="ih hj">首先创建一个样本 terraform 代码，以便在 Azure 环境中配置虚拟机。</strong></p><pre class="kh ki kj kk fd ky kz la lb aw lc bi"><span id="6040" class="ld je hi kz b fi le lf l lg lh"># Configure the Microsoft Azure Provider</span><span id="71d5" class="ld je hi kz b fi li lf l lg lh">terraform {<br/>  required_providers {<br/>     azurerm = {<br/>  </span><span id="b9ac" class="ld je hi kz b fi li lf l lg lh"># Configure the Microsoft Azure Provider</span><span id="da9b" class="ld je hi kz b fi li lf l lg lh">provider "azurerm" {<br/>   features {}<br/>}</span><span id="9e3f" class="ld je hi kz b fi li lf l lg lh"># Create virtual machine<br/>resource "azurerm_linux_virtual_machine" "myterraformvm" {<br/>    name                  = "myVM"<br/>    location              = "eastus"<br/>    resource_group_name   = "test-resource-group"<br/>    network_interface_ids = "xxxxx"<br/>    size                  = "Standard_A0"<br/>    os_disk {<br/>        name                 = "myOsDisk"<br/>        caching              = "ReadWrite"<br/>        storage_account_type = "Standard_LRS"<br/>        disk_size_gb         = "30"<br/>    }<br/>    source_image_reference {<br/>        publisher = "Canonical"<br/>        offer     = "UbuntuServer"<br/>        sku       = "18.04-LTS"<br/>        version   = "latest"<br/>    }<br/>    computer_name  = "myvm"<br/>        admin_username = "azureuser"<br/>        disable_password_authentication = true<br/>    admin_ssh_key {<br/>        username       = "azureuser"<br/>        public_key     = file("")<br/>    }<br/>    tags = {<br/>        environment = "Demo"<br/>    }<br/>}</span></pre><p id="e4dc" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这里使用这个 terraform 脚本创建了一个 Azure 虚拟机，特别是 Ubuntu 18.04-LTS。</p><p id="1f76" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> 2)设置好配置后，我们将执行地形规划，输出为二进制文件。</strong></p><pre class="kh ki kj kk fd ky kz la lb aw lc bi"><span id="8c54" class="ld je hi kz b fi le lf l lg lh">terraform init<br/>terraform plan --out tfplan.binary</span></pre><p id="b9e3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> 3)向前移动，将 terraform 计划转换为 JSON，有几个选项，这里是</strong> <a class="ae kw" href="https://github.com/palantir/tfjson" rel="noopener ugc nofollow" target="_blank"> <strong class="ih hj">一个</strong> </a> <strong class="ih hj"> : </strong></p><pre class="kh ki kj kk fd ky kz la lb aw lc bi"><span id="8ebf" class="ld je hi kz b fi le lf l lg lh">tfjson tfplan.binary &gt; tfplan.json</span></pre><p id="4f78" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在到了我们必须编写策略检查的部分。</p><p id="6dea" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">例如，我们可以检查资源类型(尤其是 vm_size 参数)。我们已经使用 terraform 代码创建了上面的虚拟机，其中包含我们想要的虚拟机大小，即<code class="du lj lk ll kz b">Standard_A0</code>。为此，我们将编写一个. rego 文件，可以是 instance_check.rego。</p><p id="c592" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">什么是减压阀，</strong>这是用来编写《外地加工措施政策》的语言。这里可以了解更多关于 rego 的信息。OPA 提供了一个在线互动环境，我们可以在这里测试政策。这里你可以看一下。</p><pre class="kh ki kj kk fd ky kz la lb aw lc bi"><span id="2608" class="ld je hi kz b fi le lf l lg lh"># Multi proivder rule to enforce instance type/size</span><span id="7f30" class="ld je hi kz b fi li lf l lg lh">package terraform.analysis</span><span id="5d7d" class="ld je hi kz b fi li lf l lg lh">import input.tfplan as tfplan</span><span id="c725" class="ld je hi kz b fi li lf l lg lh"># Allowed sizes by provider<br/>allowed_types = {<br/>    "azurerm": ["Standard_A0", "Standard_A1"],<br/>}</span><span id="7b3f" class="ld je hi kz b fi li lf l lg lh"># Attribute name for instance type/size by provider<br/>instance_type_key = {<br/>    "azurerm": "vm_size",<br/>}</span><span id="5e81" class="ld je hi kz b fi li lf l lg lh">array_contains(arr, elem) {<br/>  arr[_] = elem<br/>}</span><span id="9f8f" class="ld je hi kz b fi li lf l lg lh">get_basename(path) = basename{<br/>    arr := split(path, "/")<br/>    basename:= arr[count(arr)-1]<br/>}</span><span id="151f" class="ld je hi kz b fi li lf l lg lh"># Extracts the instance type/size<br/>get_instance_type(resource) = instance_type {<br/>    provider_name := get_basename(resource.provider_name)<br/>    instance_type := resource.change.after[instance_type_key[provider_name]]<br/>}</span><span id="c617" class="ld je hi kz b fi li lf l lg lh">deny[reason] {<br/>    resource := tfplan.resource_changes[_]<br/>    instance_type := get_instance_type(resource)<br/>    provider_name := get_basename(resource.provider_name)<br/>    not array_contains(allowed_types[provider_name], instance_type)</span><span id="7cbf" class="ld je hi kz b fi li lf l lg lh">reason := sprintf(<br/>        "instance type %q is not allowed",<br/>        [instance_type]<br/>    )<br/>}</span></pre><p id="12fb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在，您可以在 Mac 或任何其他操作系统上运行以下命令，以评估您编写的策略；</p><pre class="kh ki kj kk fd ky kz la lb aw lc bi"><span id="5187" class="ld je hi kz b fi le lf l lg lh">opa eval — format pretty — data instance_check.rego — input tfplan.json <!-- -->"data.terraform.analysis"</span></pre><p id="7bc5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> 5)输出:</strong></p><p id="6aab" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">输出将是原因，因为我们已经在<code class="du lj lk ll kz b">instance_type.rego</code>文件中为<code class="du lj lk ll kz b">reason</code>设置了打印命令。如果实例类型不匹配，它将像这样打印；</p><pre class="kh ki kj kk fd ky kz la lb aw lc bi"><span id="b7a3" class="ld je hi kz b fi le lf l lg lh">"instance type Standard_B1s is not allowed"</span></pre><h1 id="e88c" class="jd je hi bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">简单地</h1><p id="0754" class="pw-post-body-paragraph if ig hi ih b ii kb ik il im kc io ip iq kd is it iu ke iw ix iy kf ja jb jc hb bi translated">在了解了使用 OPA 和 terraform 的强大功能后，人们可以很容易地想到将其用作部署前检查，或者在应用 terraform 计划之前使用 OPA，并检查特定项目的所有策略，以便对基础架构进行良好的控制。这是一个强大的组合，可用于调配云基础架构和设置云实例。使用 OPA 的优势之一是它是开源工具，可以免费使用。此外，还有许多其他选项可用，如将<a class="ae kw" href="https://www.openpolicyagent.org/docs/latest/" rel="noopener ugc nofollow" target="_blank"> OPA </a>与 Kubernetes、Docker、Prometheus 和其他此类工具和技术一起使用。希望这可以帮助您的研究或您对如何在没有任何手动或人工干预的情况下自动执行策略的兴趣。</p><p id="f76e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这里列出了许多已经制定的 OPA 样本政策<a class="ae kw" href="https://github.com/Scalr/sample-tf-opa-policies" rel="noopener ugc nofollow" target="_blank">。虽然也可以写他的手动策略检查。rego 文件。因此，请保持基础架构创建和配置流程的自动化。</a></p></div></div>    
</body>
</html>