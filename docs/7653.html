<html>
<head>
<title>(RPI) Microservices Communication pattern</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">(RPI)微服务通信模式</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/rpi-microservices-communication-pattern-693399942357?source=collection_archive---------1-----------------------#2022-12-25">https://medium.com/nerd-for-tech/rpi-microservices-communication-pattern-693399942357?source=collection_archive---------1-----------------------#2022-12-25</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/b366cf7977f9bd6bae031438033ec8c8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sTfRe2-B4d58K3ar2_e4Hw.png"/></div></div></figure><blockquote class="iq ir is"><p id="2fb6" class="it iu iv iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">微服务必须与多个微服务通信，以便完成任何复杂的功能。为此，服务使用进程间通信协议。解决方法是利用 RPI 进行任何服务间的交流和协作。客户端使用同步协议向服务发出请求。</p></blockquote></div><div class="ab cl js jt gp ju" role="separator"><span class="jv bw bk jw jx jy"/><span class="jv bw bk jw jx jy"/><span class="jv bw bk jw jx"/></div><div class="hb hc hd he hf"><p id="3bd7" class="pw-post-body-paragraph it iu hi iw b ix iy iz ja jb jc jd je jz jg jh ji ka jk jl jm kb jo jp jq jr hb bi translated">RPI 技术有很多例子</p><ul class=""><li id="2f3c" class="kc kd hi iw b ix iy jb jc jz ke ka kf kb kg jr kh ki kj kk bi translated"><a class="ae kl" href="https://en.wikipedia.org/wiki/Representational_state_transfer" rel="noopener ugc nofollow" target="_blank">休息</a></li><li id="e162" class="kc kd hi iw b ix km jb kn jz ko ka kp kb kq jr kh ki kj kk bi translated"><a class="ae kl" href="http://www.grpc.io/" rel="noopener ugc nofollow" target="_blank"> gRPC </a></li><li id="adb9" class="kc kd hi iw b ix km jb kn jz ko ka kp kb kq jr kh ki kj kk bi translated"><a class="ae kl" href="https://thrift.apache.org/" rel="noopener ugc nofollow" target="_blank">阿帕奇节俭</a></li></ul><p id="2a50" class="pw-post-body-paragraph it iu hi iw b ix iy iz ja jb jc jd je jz jg jh ji ka jk jl jm kb jo jp jq jr hb bi translated">但是我们将更多地讨论 REST 和 gRPC</p><h1 id="1733" class="kr ks hi bd kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo bi translated">什么是休息？</h1><figure class="lq lr ls lt fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lp"><img src="../Images/3aca655a2997ac180497e6f1b71ef1ba.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6cjGAevnut9YuDmprV1Qmw.png"/></div></div></figure><p id="3344" class="pw-post-body-paragraph it iu hi iw b ix iy iz ja jb jc jd je jz jg jh ji ka jk jl jm kb jo jp jq jr hb bi translated"><strong class="iw hj"> REST(表述性状态转移)</strong>是一种服务结构，支持客户端和服务器之间简单快速的通信。它是作为 SOAP 和基于 WSDL 的 Web 服务的替代品而开发的。</p><h1 id="fd26" class="kr ks hi bd kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo bi translated">REST 的指导原则:</h1><ul class=""><li id="dbe0" class="kc kd hi iw b ix lu jb lv jz lw ka lx kb ly jr kh ki kj kk bi translated">无状态:无状态要求从客户端到服务器的每个请求必须包含理解和完成请求所需的所有信息。服务器不能利用任何先前存储在服务器上的上下文信息。</li><li id="d0e8" class="kc kd hi iw b ix km jb kn jz ko ka kp kb kq jr kh ki kj kk bi translated"><strong class="iw hj">统一接口</strong>:通过将通用性原则应用于组件接口，我们可以简化整个系统架构，并提高交互的可见性。</li><li id="ed88" class="kc kd hi iw b ix km jb kn jz ko ka kp kb kq jr kh ki kj kk bi translated"><strong class="iw hj">可缓存</strong>:可缓存约束要求响应应该隐式或显式地将自己标记为可缓存或不可缓存。</li><li id="0345" class="kc kd hi iw b ix km jb kn jz ko ka kp kb kq jr kh ki kj kk bi translated"><strong class="iw hj">客户机-服务器</strong>:客户机-服务器设计模式加强了关注点的分离，这有助于客户机和服务器组件独立发展。</li><li id="1a07" class="kc kd hi iw b ix km jb kn jz ko ka kp kb kq jr kh ki kj kk bi translated"><strong class="iw hj">分层系统:</strong>分层系统风格通过约束组件行为，允许一个架构由分层的层组成。</li><li id="186d" class="kc kd hi iw b ix km jb kn jz ko ka kp kb kq jr kh ki kj kk bi translated"><strong class="iw hj">按需编码</strong> : REST 还允许通过下载和执行 applets 或脚本形式的代码来扩展客户端功能。</li></ul><h1 id="85c6" class="kr ks hi bd kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo bi translated">什么是 RESTful APIs？</h1><p id="5030" class="pw-post-body-paragraph it iu hi iw b ix lu iz ja jb lv jd je jz lz jh ji ka ma jl jm kb mb jp jq jr hb bi translated">现在是我们的定义。REST 是一组指导原则，软件可以使用它们通过互联网进行通信，以使集成变得简单和可伸缩。REST API(也称为“RESTful”API)是遵循这些准则的特定类型的 API。</p><p id="e7d8" class="pw-post-body-paragraph it iu hi iw b ix iy iz ja jb jc jd je jz jg jh ji ka jk jl jm kb jo jp jq jr hb bi translated">为了理解 REST，我们需要首先回顾这些术语:</p><ul class=""><li id="81e8" class="kc kd hi iw b ix iy jb jc jz ke ka kf kb kg jr kh ki kj kk bi translated">客户:使用 API 的个人或程序。客户端向 API 发出请求，以便检索某些信息或更改某些内容。</li><li id="0e27" class="kc kd hi iw b ix km jb kn jz ko ka kp kb kq jr kh ki kj kk bi translated"><strong class="iw hj">资源</strong>:API 可以提供给客户端的任何信息。每个资源都有一个唯一的名称，称为资源标识符。</li><li id="75ec" class="kc kd hi iw b ix km jb kn jz ko ka kp kb kq jr kh ki kj kk bi translated"><strong class="iw hj">服务器</strong>:由接收客户端请求的应用使用，包含客户端想要的资源。</li></ul><h1 id="03ce" class="kr ks hi bd kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo bi translated">gRPC 是什么？</h1><figure class="lq lr ls lt fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mc"><img src="../Images/9fa417a3c90a549b223243748ec49b24.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6ufkIOzURh0WBg_q9jrSgQ.png"/></div></div></figure><p id="cece" class="pw-post-body-paragraph it iu hi iw b ix iy iz ja jb jc jd je jz jg jh ji ka jk jl jm kb jo jp jq jr hb bi translated">gRPC 是一个现代的开源高性能远程过程调用(RPC)框架，可以在任何环境中运行。借助对负载平衡、跟踪、健康检查和身份验证的可插拔支持，它可以高效地连接数据中心内和跨数据中心的服务。它也适用于分布式计算的最后一英里，将设备、移动应用程序和浏览器连接到后端服务(官方定义)。</p><p id="7978" class="pw-post-body-paragraph it iu hi iw b ix iy iz ja jb jc jd je jz jg jh ji ka jk jl jm kb jo jp jq jr hb bi translated">它专注于高性能，并使用<strong class="iw hj"> HTTP/2 </strong>协议来传输二进制消息。它依靠<strong class="iw hj">协议缓冲语言</strong>来定义服务契约。协议缓冲区，也称为<strong class="iw hj"> Protobuf </strong>，允许您定义在服务到服务的通信中使用的接口，而不考虑编程语言。</p><h1 id="8039" class="kr ks hi bd kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo bi translated"><strong class="ak">什么是协议缓冲语言？</strong></h1><figure class="lq lr ls lt fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es md"><img src="../Images/bbb5420c6e6d87135e9549fada033263.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*b7siaQBHwkuz2gDmv8ygHg.png"/></div></div></figure><p id="b0c4" class="pw-post-body-paragraph it iu hi iw b ix iy iz ja jb jc jd je jz jg jh ji ka jk jl jm kb jo jp jq jr hb bi translated">协议缓冲区是 Google 的语言中立、平台中立、可扩展的机制，用于序列化结构化数据——想想 XML，但是更小、更快、更简单。一旦定义了数据的结构化方式，就可以使用专门生成的源代码，使用各种语言轻松地将结构化数据写入各种数据流或从中读取。</p><h1 id="4345" class="kr ks hi bd kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo bi translated">gRPC 是如何工作的？</h1><p id="b959" class="pw-post-body-paragraph it iu hi iw b ix lu iz ja jb lv jd je jz lz jh ji ka ma jl jm kb mb jp jq jr hb bi translated">在<strong class="iw hj"> GRPC </strong>中，客户端应用程序可以直接调用不同机器上的服务器应用程序上的方法，如果它是一个本地对象的话，这让你很容易构建<strong class="iw hj">分布式应用程序</strong>和服务。</p><figure class="lq lr ls lt fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es me"><img src="../Images/d2e2abdf2299c80f87e182cb5c5aacb1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Zg17tkH6R4fGhXNGI0zH6w.png"/></div></div></figure><p id="bbdb" class="pw-post-body-paragraph it iu hi iw b ix iy iz ja jb jc jd je jz jg jh ji ka jk jl jm kb jo jp jq jr hb bi translated">与许多 RPC 系统一样，<strong class="iw hj"> gRPC </strong>基于定义一个服务的思想，该服务指定可以用它们的参数和返回类型远程调用的方法。在服务器端，服务器实现这个接口并运行一个<strong class="iw hj"> gRPC </strong>服务器来处理客户端调用。在客户端，客户端有一个存根，它提供与服务器相同的方法。</p><h2 id="6c23" class="mf ks hi bd kt mg mh mi kx mj mk ml lb jz mm mn lf ka mo mp lj kb mq mr ln ms bi translated">gRPC 方法类型</h2><p id="9d1b" class="pw-post-body-paragraph it iu hi iw b ix lu iz ja jb lv jd je jz lz jh ji ka ma jl jm kb mb jp jq jr hb bi translated">gRPC 允许您定义四种服务方法:</p><figure class="lq lr ls lt fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mt"><img src="../Images/052f2bf2d6d9f59411327bd7e42e4f3a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5wGOBbYcbr7u2qztdhxLvQ.png"/></div></div></figure><p id="95f4" class="pw-post-body-paragraph it iu hi iw b ix iy iz ja jb jc jd je jz jg jh ji ka jk jl jm kb jo jp jq jr hb bi translated"><strong class="iw hj">一元 RPC: </strong>客户端向服务器发送一个请求，然后返回一个响应，就像普通的函数调用一样。</p><p id="a515" class="pw-post-body-paragraph it iu hi iw b ix iy iz ja jb jc jd je jz jg jh ji ka jk jl jm kb jo jp jq jr hb bi translated"><strong class="iw hj">服务器流 RPC: </strong>客户端向服务器发送一个请求，得到一个流来读回一系列消息。客户端从返回的流中读取，直到不再有消息。</p><p id="604d" class="pw-post-body-paragraph it iu hi iw b ix iy iz ja jb jc jd je jz jg jh ji ka jk jl jm kb jo jp jq jr hb bi translated"><strong class="iw hj">客户端流 RPC: </strong>客户端编写一系列消息，并将其发送到服务器，同样使用提供的流。一旦客户端写完消息，它就等待服务器读取消息并返回响应。</p><p id="4b15" class="pw-post-body-paragraph it iu hi iw b ix iy iz ja jb jc jd je jz jg jh ji ka jk jl jm kb jo jp jq jr hb bi translated"><strong class="iw hj">双向流 RPC: </strong>双方使用读写流发送一系列消息。这两个流独立运行，因此客户端和服务器可以按照他们喜欢的任何顺序进行读写。</p><h1 id="749a" class="kr ks hi bd kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo bi translated">gRPC 与 REST</h1><figure class="lq lr ls lt fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mc"><img src="../Images/f04c50daa1e7060740a2735f939cfb29.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*K7kFHlV7SglEUASyB9jf-Q.png"/></div></div><figcaption class="mu mv et er es mw mx bd b be z dx translated">网上对比感谢 https://marutitech.com/rest-vs-grpc/<a class="ae kl" href="https://marutitech.com/rest-vs-grpc/" rel="noopener ugc nofollow" target="_blank"/></figcaption></figure><h1 id="9bea" class="kr ks hi bd kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo bi translated">HTTP 1.1 与 HTTP 2</h1><p id="5f60" class="pw-post-body-paragraph it iu hi iw b ix lu iz ja jb lv jd je jz lz jh ji ka ma jl jm kb mb jp jq jr hb bi translated"><strong class="iw hj">REST API</strong>遵循通信的<strong class="iw hj">请求-响应模型，该模型通常构建在<strong class="iw hj"> HTTP 1.1 </strong>之上。不幸的是，这意味着如果一个微服务接收到来自多个客户端的多个请求，该模型必须一次处理一个请求，从而降低整个系统的速度。</strong></p><p id="42f0" class="pw-post-body-paragraph it iu hi iw b ix iy iz ja jb jc jd je jz jg jh ji ka jk jl jm kb jo jp jq jr hb bi translated">gRPC 没有面临类似的障碍。它建立在 HTTP 2 之上，而是遵循一个<strong class="iw hj">客户端-响应通信模型</strong>。这些条件支持双向通信和流式通信，因为 gRPC 能够从几个客户端接收<strong class="iw hj">多个请求，并通过不断流式传输信息来同时处理这些请求。</strong></p><h1 id="4462" class="kr ks hi bd kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo bi translated">有效载荷数据结构</h1><p id="5212" class="pw-post-body-paragraph it iu hi iw b ix lu iz ja jb lv jd je jz lz jh ji ka ma jl jm kb mb jp jq jr hb bi translated">gRPC 默认使用<strong class="iw hj">协议缓冲区</strong>来序列化有效载荷数据。这种解决方案更轻便，因为它支持高度压缩的格式，并减小了消息的大小。进一步说，<a class="ae kl" href="https://developers.google.com/protocol-buffers" rel="noopener ugc nofollow" target="_blank"> <strong class="iw hj"> Protobuf </strong> </a>是二进制的；因此，它序列化和反序列化结构化数据，以便进行通信和传输。</p><p id="fe88" class="pw-post-body-paragraph it iu hi iw b ix iy iz ja jb jc jd je jz jg jh ji ka jk jl jm kb jo jp jq jr hb bi translated">相比之下，REST 主要依靠 JSON 或 XML 格式来发送和接收数据。事实上，尽管 JSON 没有强制要求任何结构，但它是最流行的格式，因为它具有灵活性和发送动态数据的能力，而不必遵循严格的结构。使用 JSON 的另一个重要好处是它的可读性，这是 Protobuf 还无法与之竞争的。尽管如此，在数据传输方面，JSON 并没有那么轻便和快速。</p><h1 id="6092" class="kr ks hi bd kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo bi translated">代码生成功能</h1><p id="e379" class="pw-post-body-paragraph it iu hi iw b ix lu iz ja jb lv jd je jz lz jh ji ka ma jl jm kb mb jp jq jr hb bi translated">与 gRPC 不同，REST API 不提供内置的代码生成功能，这意味着开发人员必须使用像<a class="ae kl" href="https://www.imaginarycloud.com/blog/flask-python/" rel="noopener ugc nofollow" target="_blank"> Swagger </a>或 Postman 这样的第三方工具来为 API 请求生成代码。</p><p id="12a6" class="pw-post-body-paragraph it iu hi iw b ix iy iz ja jb jc jd je jz jg jh ji ka jk jl jm kb jo jp jq jr hb bi translated">相比之下，<strong class="iw hj"> gRPC 拥有本机代码生成特性</strong>,这是由于它的 protoc 编译器，它与几种编程语言兼容。这对集成了用不同语言和平台开发的各种服务的<strong class="iw hj">微服务系统</strong>尤其有利。总而言之，内置的代码生成器也有利于创建<strong class="iw hj"> SDK </strong>(软件开发工具包)。</p><h1 id="3e57" class="kr ks hi bd kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo bi translated"><strong class="ak">微服务哪个好？</strong></h1><p id="4804" class="pw-post-body-paragraph it iu hi iw b ix lu iz ja jb lv jd je jz lz jh ji ka ma jl jm kb mb jp jq jr hb bi translated">这是我的看法，但是根据下面的定义和比较，当我们谈论微服务架构内服务之间的通信时，我更喜欢使用 gRPC 而不是 REST APIs，因为:</p><ul class=""><li id="7250" class="kc kd hi iw b ix iy jb jc jz ke ka kf kb kg jr kh ki kj kk bi translated">比基于 JSON 的 RESTful API 更快</li><li id="9e84" class="kc kd hi iw b ix km jb kn jz ko ka kp kb kq jr kh ki kj kk bi translated">强类型和定义良好的接口</li><li id="6af9" class="kc kd hi iw b ix km jb kn jz ko ka kp kb kq jr kh ki kj kk bi translated">流支持</li><li id="38f3" class="kc kd hi iw b ix km jb kn jz ko ka kp kb kq jr kh ki kj kk bi translated">支持弹性</li><li id="0d8e" class="kc kd hi iw b ix km jb kn jz ko ka kp kb kq jr kh ki kj kk bi translated">内置认证</li><li id="cae3" class="kc kd hi iw b ix km jb kn jz ko ka kp kb kq jr kh ki kj kk bi translated">加密</li><li id="7af3" class="kc kd hi iw b ix km jb kn jz ko ka kp kb kq jr kh ki kj kk bi translated">压缩</li><li id="70c2" class="kc kd hi iw b ix km jb kn jz ko ka kp kb kq jr kh ki kj kk bi translated">负载平衡</li><li id="83e5" class="kc kd hi iw b ix km jb kn jz ko ka kp kb kq jr kh ki kj kk bi translated">错误处理</li></ul><h1 id="9e40" class="kr ks hi bd kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo bi translated">接下来呢？</h1><p id="4dbd" class="pw-post-body-paragraph it iu hi iw b ix lu iz ja jb lv jd je jz lz jh ji ka ma jl jm kb mb jp jq jr hb bi translated">您可以看看微服务中的异步通信，尽管我们可以在请求者期望立即响应时进行同步请求/响应调用，我们在本文中讨论了基于事件和异步消息传递的集成模式提供了最大的可伸缩性和弹性。为了构建可扩展的架构。</p><h1 id="2f94" class="kr ks hi bd kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo bi translated">参考资料:</h1><ul class=""><li id="c056" class="kc kd hi iw b ix lu jb lv jz lw ka lx kb ly jr kh ki kj kk bi translated"><a class="ae kl" href="https://learn.microsoft.com/en-us/azure/architecture/best-practices/api-design" rel="noopener ugc nofollow" target="_blank"> RESTful web API 设计</a></li><li id="aec0" class="kc kd hi iw b ix km jb kn jz ko ka kp kb kq jr kh ki kj kk bi translated"><a class="ae kl" href="https://microservices.io/index.html" rel="noopener ugc nofollow" target="_blank">微服务架构</a></li><li id="875b" class="kc kd hi iw b ix km jb kn jz ko ka kp kb kq jr kh ki kj kk bi translated"><a class="ae kl" href="https://grpc.io/" rel="noopener ugc nofollow" target="_blank"> grpc.io </a></li></ul></div></div>    
</body>
</html>