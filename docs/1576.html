<html>
<head>
<title>Understanding Javascript Es6 Classes</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">了解 Javascript Es6 类</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/understanding-javascript-es6-classes-dbce09c0b903?source=collection_archive---------13-----------------------#2021-03-26">https://medium.com/nerd-for-tech/understanding-javascript-es6-classes-dbce09c0b903?source=collection_archive---------13-----------------------#2021-03-26</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="021c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="jd">面向对象编程</em>的基本思想是，我们使用对象来模拟我们希望在程序中表示的真实世界的事物，并且/或者提供一种简单的方法来访问我们很难或不可能使用的功能。一般来说，为了使这更容易，我们使用<code class="du je jf jg jh b">class</code>。JavaScript <em class="jd">不像 Java 和其他语言那样</em>有类。</p><blockquote class="ji jj jk"><p id="ba07" class="if ig jd ih b ii ij ik il im in io ip jl ir is it jm iv iw ix jn iz ja jb jc hb bi translated">在 Javascript 中，类只不过是现有的基于原型的继承和构造函数的语法糖。</p></blockquote><p id="9e3e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在这篇文章中，我们将通过与基于原型的继承进行比较来探究类在幕后做什么。</p><p id="e886" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">Es6 类提供什么:</strong></p><ol class=""><li id="ea03" class="jo jp hi ih b ii ij im in iq jq iu jr iy js jc jt ju jv jw bi translated"><strong class="ih hj">构造函数方法:</strong> <br/>构造函数方法是一种特殊的方法，用于创建和初始化用<code class="du je jf jg jh b">class</code>创建的对象。一个类中只能有一个<code class="du je jf jg jh b">constructor</code>方法。</li></ol><pre class="jx jy jz ka fd kb jh kc kd aw ke bi"><span id="252e" class="kf kg hi jh b fi kh ki l kj kk">//create an object with class keyword<br/>class Person {<br/>    constructor(name, age) {<br/>        this.name = name;<br/>        this.age = age;<br/>    }<br/>}<br/>var person = new Person('test', 12);<br/>console.log(person);</span></pre><p id="4767" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">构造函数:</p><pre class="jx jy jz ka fd kb jh kc kd aw ke bi"><span id="6dc1" class="kf kg hi jh b fi kh ki l kj kk">//define a constructor function<br/>function Person(name, age) {<br/>  this.name = name;<br/>  this.age = age;<br/>}<br/>var person = new Person('test', 12);<br/>console.log(person);</span></pre><figure class="jx jy jz ka fd km er es paragraph-image"><div role="button" tabindex="0" class="kn ko di kp bf kq"><div class="er es kl"><img src="../Images/5fcae5e982ab348fff57e6943cd516a3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1188/format:webp/1*RgtTRFOdrKH6QSohPnAeiQ.png"/></div></div></figure><p id="1429" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">无论我们如何通过类或构造函数创建对象。对象指向相同的属性和方法。</p><p id="e2a9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> 2。静态方法:</strong></p><p id="754c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Javascript 静态方法通常用于创建实用函数。Es6 类支持静态方法。要在 Es6 类中声明一个静态方法，我们可以简单地使用<em class="jd"> static </em>关键字和方法签名。<br/>静态方法不在类的实例上调用，而是直接在类上调用。</p><pre class="jx jy jz ka fd kb jh kc kd aw ke bi"><span id="b0c2" class="kf kg hi jh b fi kh ki l kj kk">class Article {  <br/>  constructor(title, date) {  <br/>   this.title = title;   <br/>   this.date = date;  <br/>  }  <br/>  static createTodays() {   <br/>   //remember, this = Article    <br/>   return new this("Today's digest", new Date());  <br/>  }<br/> }  <br/>let article = Article.createTodays(); <br/>console.log( article.title ); // Today's digest<br/>console.log( article.date ); // Thu Mar 25 2021 14:19:38 GMT+0300</span></pre><p id="c2ee" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">不使用 class 关键字的静态方法:</p><pre class="jx jy jz ka fd kb jh kc kd aw ke bi"><span id="4dd1" class="kf kg hi jh b fi kh ki l kj kk">function Article(title, date) {  <br/>   this.title = title;   <br/>   this.date = date;  <br/>}<br/>Article.createTodays = function() {   <br/>   //remember, this = Article    <br/>   return new this("Today's digest", new Date());  <br/>}  <br/>let article = Article.createTodays(); <br/>console.log( article.title ); // Today's digest<br/>console.log( article.date ); // Thu Mar 25 2021 14:19:38 GMT+0300</span></pre><p id="63a4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> 3。getter/setter:</strong></p><p id="e729" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在 Es6 将 Getter 和 setter 添加到类中之前，ECMAScript 5 已经引入了它们。Getters 和 setters 允许我们定义对象访问器。Getters 和 Setters 为我们提供了以下好处:</p><ul class=""><li id="38ce" class="jo jp hi ih b ii ij im in iq jq iu jr iy js jc kt ju jv jw bi translated">它给出了更简单的语法</li><li id="383f" class="jo jp hi ih b ii ku im kv iq kw iu kx iy ky jc kt ju jv jw bi translated">它允许属性和方法使用相同的语法</li><li id="9d72" class="jo jp hi ih b ii ku im kv iq kw iu kx iy ky jc kt ju jv jw bi translated">它可以保证更好的数据质量</li><li id="de4c" class="jo jp hi ih b ii ku im kv iq kw iu kx iy ky jc kt ju jv jw bi translated">这对于在幕后做事很有用</li></ul><ol class=""><li id="cdfa" class="jo jp hi ih b ii ij im in iq jq iu jr iy js jc jt ju jv jw bi translated"><em class="jd">获取/设置类中的方法</em></li></ol><pre class="jx jy jz ka fd kb jh kc kd aw ke bi"><span id="4d04" class="kf kg hi jh b fi kh ki l kj kk">// inside class<br/>class MyClass {<br/>    constructor() {<br/>        this.names_ = [];<br/>    }<br/><br/>    set name(value) {<br/>        this.names_.push(value);<br/>    }<br/><br/>    get name() {<br/>        return this.names_[this.names_.length - 1];<br/>    }<br/>}<br/><br/>const myClassInstance = new MyClass();<br/>myClassInstance.name = 'Joe';</span></pre><p id="bebe" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="jd"> 2。函数中的 get 和 set 方法。</em></p><pre class="jx jy jz ka fd kb jh kc kd aw ke bi"><span id="047e" class="kf kg hi jh b fi kh ki l kj kk">// inside function<br/>function MyFunc() {<br/>  this.names_ = [];<br/>}</span><span id="f60c" class="kf kg hi jh b fi kz ki l kj kk">Object.defineProperty(MyFunc.prototype, "name", {<br/>    get: function() {<br/>           return this.names_[this.names_.length - 1];<br/>    },<br/>    set: function(value) {<br/>          this.names_.push(value);<br/>    }<br/>});<br/>const myFuncInstance = new <!-- -->MyFunc<!-- -->();<br/>myFuncInstance.name = 'Joe';</span></pre><p id="dd4f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> 4。继承是面向对象编程中的重要概念。在传统继承中，基类的方法和属性被复制到派生类中。<br/>在 JavaScript 中，直到 ES6 出来之前都是用 prototype 对象来支持继承的。有人称之为“原型继承”，有人称之为“行为委托”。ES6 类提供了从基类复制方法和属性到派生类的功能。</strong></p><pre class="jx jy jz ka fd kb jh kc kd aw ke bi"><span id="7513" class="kf kg hi jh b fi kh ki l kj kk">class Car {<br/>  constructor(brand) {<br/>    this.car_name = brand;<br/>  }<br/>  present() {<br/>    return ‘I have a ‘ + this.car_name;<br/>  }<br/>}</span><span id="9862" class="kf kg hi jh b fi kz ki l kj kk">class Model extends Car {<br/>  constructor(brand, mod) {<br/>    super(brand);<br/>    this.model = mod;<br/>  }<br/>  show() {<br/>    return this.present() + ‘, it is a ‘ + this.model;<br/>  }<br/>}</span><span id="2f09" class="kf kg hi jh b fi kz ki l kj kk">let myCar = new Model(“Ford”, “Mustang”);<br/>console.log(myCar.show()); // I have a Ford, it is a Mustang</span></pre><p id="5986" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">注意:<code class="du je jf jg jh b">super</code>方法指的是父类。通过调用构造函数方法中的<code class="du je jf jg jh b">super</code>方法，我们调用了父类的构造函数方法，并访问了父类的属性和方法。</p><p id="f968" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们可以用原型做同样的例子。</p><pre class="jx jy jz ka fd kb jh kc kd aw ke bi"><span id="3a08" class="kf kg hi jh b fi kh ki l kj kk">function Car(brand) {<br/>   this.car_name = brand;<br/>}<br/>Car.prototype.present = function() {<br/>   return ‘I have a ‘ + this.car_name;<br/>}<br/>function Model(brand, mod) {<br/>   Car.call(this, brand);<br/>   this.model = mod;<br/>   this.show = function() {<br/>      return this.present() + ‘, it is a ‘ + this.model;<br/>   }<br/>}<br/>Model.prototype = Object.create(Car.prototype)</span><span id="9540" class="kf kg hi jh b fi kz ki l kj kk">let myCar = new Model(“Ford”, “Mustang”);<br/>console.log(myCar.show()); // I have a Ford, it is a Mustang</span></pre><p id="afbb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">工厂功能:</strong></p><p id="f680" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">工厂函数是任何不是返回对象的类或构造函数的函数。在 Javascript 中，任何函数都可以返回一个对象。当它这样做而没有关键字<code class="du je jf jg jh b">new</code>时，它被称为<code class="du je jf jg jh b">factory function</code>。如果需要创建许多对象，可以将对象文字和工厂函数结合起来。</p><ul class=""><li id="3030" class="jo jp hi ih b ii ij im in iq jq iu jr iy js jc kt ju jv jw bi translated">这是使用对象文字创建的对象:</li></ul><pre class="jx jy jz ka fd kb jh kc kd aw ke bi"><span id="dd89" class="kf kg hi jh b fi kh ki l kj kk">const user = {<br/> userName,<br/> avatar, <br/> setUserName (userName) {<br/>    this.userName = userName;<br/>    return this;<br/> }<br/>};</span></pre><ul class=""><li id="04be" class="jo jp hi ih b ii ij im in iq jq iu jr iy js jc kt ju jv jw bi translated">我们可以将它转换成工厂函数来创建多个对象。</li></ul><pre class="jx jy jz ka fd kb jh kc kd aw ke bi"><span id="6d70" class="kf kg hi jh b fi kh ki l kj kk">const createUser = ({ userName, avatar }) =&gt; ({<br/>  userName,<br/>  avatar,<br/>  setUserName (userName) {<br/>    this.userName = userName;<br/>    return this;<br/>  }<br/>});<br/>console.log(createUser({ userName: 'echo', avatar: 'echo.png' }));</span></pre><blockquote class="ji jj jk"><p id="9971" class="if ig jd ih b ii ij ik il im in io ip jl ir is it jm iv iw ix jn iz ja jb jc hb bi translated">如果不想处理<code class="du je jf jg jh b">new</code>关键字、<code class="du je jf jg jh b">class</code>或者<code class="du je jf jg jh b">prototypes</code>，可以用工厂函数实现同样的功能。</p></blockquote><p id="07fa" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在这篇文章中，我们试图看到类的其他替代品。希望它能帮助你更好地理解这个类，并看到幕后发生的事情。它还证明了类只不过是 Javascript 中现有的基于原型的继承和构造函数的语法糖。</p><p id="c419" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> Object.create(): </strong></p><p id="2cca" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><code class="du je jf jg jh b"><strong class="ih hj">Object.create()</strong></code>方法创建一个新对象，使用一个现有对象作为新创建对象的原型。我们也可以利用这种方法通过<code class="du je jf jg jh b">Object.create</code>方法轻松管理继承。</p><p id="f91e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">语法:</strong></p><pre class="jx jy jz ka fd kb jh kc kd aw ke bi"><span id="c9e1" class="kf kg hi jh b fi kh ki l kj kk">Object.create(proto, [propertiesObject])</span></pre><p id="20ca" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><code class="du je jf jg jh b"><strong class="ih hj">proto</strong></code> <strong class="ih hj"> : </strong> <em class="jd">应该是新创建对象的原型的对象。</em></p><p id="70c2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><code class="du je jf jg jh b"><strong class="ih hj">propertiesObject</strong></code> <strong class="ih hj"> : </strong> <em class="jd">可选参数。它指定要添加到新创建的对象中的可枚举属性。</em></p><p id="3a92" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们用 Object.create 方法来说明下面的类示例。</p><pre class="jx jy jz ka fd kb jh kc kd aw ke bi"><span id="dc76" class="kf kg hi jh b fi kh ki l kj kk">// Shape - superclass<br/>function Shape() {<br/>  this.x = 0;<br/>  this.y = 0;<br/>}<br/><br/>// superclass method<br/>Shape.prototype.move = function(x, y) {<br/>  this.x += x;<br/>  this.y += y;<br/>  console.info('Shape moved.');<br/>};<br/><br/>// Rectangle - subclass<br/>function Rectangle() {<br/>  Shape.call(this); // call super constructor.<br/>}<br/><br/>// subclass extends superclass<br/>Rectangle.prototype = Object.create(Shape.prototype);<br/><br/>//If you don't set Rectangle.prototype.constructor to Rectangle,<br/>//it will take the prototype.constructor of Shape (parent).<br/>//To avoid that, we set the prototype.constructor to Rectangle (child).<br/>Rectangle.prototype.constructor = Rectangle;<br/><br/>var rect = new Rectangle();<br/><br/>console.log('Is rect an instance of Rectangle?', rect instanceof Rectangle); // true<br/>console.log('Is rect an instance of Shape?', rect instanceof Shape); // true<br/>rect.move(1, 1); // Outputs, 'Shape moved.'</span></pre><p id="af7d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们可以用<code class="du je jf jg jh b">Object.create()</code>管理相同的继承。</p><pre class="jx jy jz ka fd kb jh kc kd aw ke bi"><span id="9380" class="kf kg hi jh b fi kh ki l kj kk">let myCar = Object.create(null, );</span></pre></div></div>    
</body>
</html>