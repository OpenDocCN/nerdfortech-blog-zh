<html>
<head>
<title>Push_Swap Tutorial</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">推送_交换教程</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/push-swap-tutorial-fa746e6aba1e?source=collection_archive---------0-----------------------#2021-05-24">https://medium.com/nerd-for-tech/push-swap-tutorial-fa746e6aba1e?source=collection_archive---------0-----------------------#2021-05-24</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="52a7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Push_swap是学校42的一个算法项目。我简单介绍一下这个项目，分享一个求解的算法:基数排序。</p><p id="8e7a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">该算法的优点:易于实现，稳定</p><p id="fd20" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这种算法的缺点:过得去但不会得满分(除非你能找到优化的方法)</p><h1 id="fc17" class="jd je hi bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">介绍</h1><p id="8fab" class="pw-post-body-paragraph if ig hi ih b ii kb ik il im kc io ip iq kd is it iu ke iw ix iy kf ja jb jc hb bi translated">首先，我们从称为<strong class="ih hj"> A </strong>和<strong class="ih hj"> B </strong>的两个堆栈开始。</p><p id="15bb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> A </strong>用一些随机整数填充(没有重复)，B<strong class="ih hj">B</strong>为空。我们可以在这些堆栈上执行某些指令，目标是用尽可能少的指令对所有这些整数进行排序。</p><p id="583d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果原始堆栈看起来像这样</p><pre class="kg kh ki kj fd kk kl km kn aw ko bi"><span id="9cc4" class="kp je hi kl b fi kq kr l ks kt">9</span><span id="54ed" class="kp je hi kl b fi ku kr l ks kt">4</span><span id="2ce5" class="kp je hi kl b fi ku kr l ks kt">8</span><span id="043b" class="kp je hi kl b fi ku kr l ks kt">7</span><span id="0e24" class="kp je hi kl b fi ku kr l ks kt">----------     ----------</span><span id="ce4f" class="kp je hi kl b fi ku kr l ks kt">a              b</span></pre><p id="d36b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们的目标是打印一个指令列表，它可以使栈像这样排序</p><pre class="kg kh ki kj fd kk kl km kn aw ko bi"><span id="251c" class="kp je hi kl b fi kq kr l ks kt">4</span><span id="8ecc" class="kp je hi kl b fi ku kr l ks kt">7</span><span id="0bc9" class="kp je hi kl b fi ku kr l ks kt">8</span><span id="d22a" class="kp je hi kl b fi ku kr l ks kt">9</span><span id="f4c7" class="kp je hi kl b fi ku kr l ks kt">----------     ----------</span><span id="ceed" class="kp je hi kl b fi ku kr l ks kt">a              b</span></pre><p id="b719" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这里是我们可以执行的指令列表:</p><p id="9e18" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">sa(交换A):交换<strong class="ih hj"> A </strong>中的前两位数</p><p id="008f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">sb(交换B):交换<strong class="ih hj"> B </strong>中的前两位数</p><p id="566d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">ss : sa + sb</p><p id="baaa" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">ra(旋转A):A<strong class="ih hj">中的顶部数字</strong>到达A<strong class="ih hj">底部</strong></p><p id="24fe" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">rb(旋转B):在<strong class="ih hj"> B </strong>中的顶部数字到<strong class="ih hj"> B </strong>的底部</p><p id="b30a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">rr : ra + rb</p><p id="eecd" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">rra(反向旋转A):从<strong class="ih hj"> A </strong>的底部数字到<strong class="ih hj"> A </strong>的顶部</p><p id="a01f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">rra(反向旋转B):在<strong class="ih hj"> B </strong>中的底部数字到达<strong class="ih hj"> B </strong>的顶部</p><p id="a9e2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">rrr : rra + rrb</p><p id="1af1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">pa(推A):B<strong class="ih hj">中的顶部数字</strong>到达<strong class="ih hj"> A </strong>的顶部</p><p id="85e4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">pb(按B):A中的顶部数字转到B<strong class="ih hj">的顶部</strong></p><p id="3ade" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这是我们运行程序时的样子</p><figure class="kg kh ki kj fd kw er es paragraph-image"><div class="er es kv"><img src="../Images/63d06ce7fa48612e242b692c8b5971d8.png" data-original-src="https://miro.medium.com/v2/resize:fit:744/format:webp/1*HnhUPGIafYrShJav9tkVug.png"/></div></figure><p id="b533" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">一步一步，我们可以看到这些指令真的排序的数字</p><figure class="kg kh ki kj fd kw er es paragraph-image"><div class="er es kz"><img src="../Images/b592a9dce6ed537a2ccc72d99edc7ed0.png" data-original-src="https://miro.medium.com/v2/resize:fit:646/format:webp/1*_KvJFTAY3AzJvF8DlYbMag.png"/></div></figure><p id="11b6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果我们的指令列表是正确的，我们将根据我们使用的指令数量进行评级。</p><p id="705b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">对于3个数字，我们需要用不超过3条指令进行排序。</p><p id="dbb4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">对于5个数字，我们需要用不超过12条指令对其进行排序。</p><p id="a030" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">有了100个数字，我们可以得到</p><p id="0f07" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果说明列表的大小小于700，则为5分</p><p id="fbad" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果说明列表的大小小于900，则为4分</p><p id="2287" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果说明列表的大小小于1100，则为3分</p><p id="adf4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果说明列表的大小小于1300，则为2分</p><p id="1882" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果说明列表的大小小于1500，则扣1分</p><p id="79d6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">有了500个数字，我们可以得到</p><p id="7082" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果说明列表的大小小于5500，则为5分</p><p id="f50d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果说明列表的大小小于7000，则为4分</p><p id="0571" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果说明列表的大小小于8500，则为3分</p><p id="0404" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果说明列表的大小小于10000，则为2分</p><p id="afa6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果说明列表的大小小于11500，则扣1分</p><p id="2bd8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">根据不可靠的消息来源，我们至少需要得到6分才能通过。</p><h1 id="0004" class="jd je hi bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">算法</h1><p id="33f4" class="pw-post-body-paragraph if ig hi ih b ii kb ik il im kc io ip iq kd is it iu ke iw ix iy kf ja jb jc hb bi translated">步骤1:解析，如果没有检测到错误，将数字放入堆栈<strong class="ih hj"> A </strong></p><p id="f5d8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">第二步:检查<strong class="ih hj"> A </strong>中的数字是否全部排序。如果是这样，结束程序，不打印任何东西。最好写一个函数A_is_sorted()</p><p id="db99" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">第三步:如果<strong class="ih hj"> A </strong>的大小≤ 5，调用函数sort_small_stack()。否则，调用函数sort_big_stack()</p><p id="101e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在本文中，我们将关注函数<strong class="ih hj"> sort_big_stack() </strong>的实现</p><p id="7ce0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们可以从这个排序算法开始:基数排序</p><h2 id="3523" class="kp je hi bd jf la lb lc jj ld le lf jn iq lg lh jr iu li lj jv iy lk ll jz lm bi translated">基数排序</h2><p id="83ba" class="pw-post-body-paragraph if ig hi ih b ii kb ik il im kc io ip iq kd is it iu ke iw ix iy kf ja jb jc hb bi translated">你可以看这个短视频，不过我还是要解释一下。</p><figure class="kg kh ki kj fd kw"><div class="bz dy l di"><div class="ln lo l"/></div></figure><p id="b60c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">基数排序是对非负整数进行排序的有效算法，时间复杂度为O(n * d)，其中d = floor(log_b(k) + 1) for base = b(感谢Dmitry的修正)</p><p id="ea17" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">例如，我们可以用这个算法对下面的整数列表进行排序</p><pre class="kg kh ki kj fd kk kl km kn aw ko bi"><span id="7e4b" class="kp je hi kl b fi kq kr l ks kt">87 487 781 100 101 0 1</span></pre><p id="2f27" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">想象有10个标有0，1，2，…，9的盒子</p><p id="f5d2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">从最不重要的数字开始(它是在1的位置上的数字)，我们把每个数字放进它的数字对应的盒子里。</p><p id="1071" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在这个例子中，87在1的位置上有7，因此我们把它放在框7中。487在1的位置上也有7，所以它也应该放在第7个盒子里(就在87后面)…我们重复这个过程，直到每个数字都在其中一个盒子里。</p><pre class="kg kh ki kj fd kk kl km kn aw ko bi"><span id="4514" class="kp je hi kl b fi kq kr l ks kt">box 0    100    0<br/>box 1    781    101    1    <br/>box 2    <br/>box 3<br/>box 4<br/>box 5<br/>box 6<br/>box 7     87    487<br/>box 8<br/>box 9</span></pre><p id="adf0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">之后，我们根据盒子的顺序连接每个数字</p><pre class="kg kh ki kj fd kk kl km kn aw ko bi"><span id="5f77" class="kp je hi kl b fi kq kr l ks kt">100 0 781 101 1 87 487</span></pre><p id="95d1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">正如我们所看到的，这些数字是根据1的位置进行排序的。对于在1的位置上有相同数字的那些，它们根据它们在原始列表中的顺序进行排序。</p><p id="824c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们对10位的数字重复这个过程。</p><p id="12cb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">100在10的位置上有0，所以我们将它放在0框中，0在10的位置上有0，所以我们将它放在100之后的0框中…</p><pre class="kg kh ki kj fd kk kl km kn aw ko bi"><span id="4dfd" class="kp je hi kl b fi kq kr l ks kt">box 0    100    0    101    1<br/>box 1    <br/>box 2    <br/>box 3<br/>box 4<br/>box 5<br/>box 6<br/>box 7    <br/>box 8    781   87    487<br/>box 9</span></pre><p id="3393" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">并连接它</p><pre class="kg kh ki kj fd kk kl km kn aw ko bi"><span id="f971" class="kp je hi kl b fi kq kr l ks kt">100 0 101 1 781 87 487</span></pre><p id="5c52" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">此时，数字先按10位的数字排序，然后按1位的数字排序。</p><p id="993f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">100位的数字也是如此。(这将是最后一次，因为列表中最大的数字是781，只有3个数字。)</p><pre class="kg kh ki kj fd kk kl km kn aw ko bi"><span id="704f" class="kp je hi kl b fi kq kr l ks kt">box 0      0      1       87<br/>box 1    100    101<br/>box 2    <br/>box 3<br/>box 4    487<br/>box 5<br/>box 6<br/>box 7    781<br/>box 8    <br/>box 9</span></pre><p id="91a9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">并连接</p><pre class="kg kh ki kj fd kk kl km kn aw ko bi"><span id="d2c4" class="kp je hi kl b fi kq kr l ks kt">0 1 87 100 101 487 781</span></pre><p id="6b72" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在，数字都排序了。</p><p id="87ef" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">虽然这个算法很快也很优雅，但是我们需要做一些调整才能在我们的push_swap上使用它。首先，我们必须简化数字。</p><h2 id="6393" class="kp je hi bd jf la lb lc jj ld le lf jn iq lg lh jr iu li lj jv iy lk ll jz lm bi translated">简化数字</h2><p id="e91d" class="pw-post-body-paragraph if ig hi ih b ii kb ik il im kc io ip iq kd is it iu ke iw ix iy kf ja jb jc hb bi translated">我们之前提到过，这个算法是针对非负整数的。然而，在这个项目中我们会有负数，所以我们应该在开始之前简化数字。</p><p id="5271" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">例如，如果我们需要对这些数字进行排序</p><pre class="kg kh ki kj fd kk kl km kn aw ko bi"><span id="37aa" class="kp je hi kl b fi kq kr l ks kt">87 -487 781 -100 101 0 1</span></pre><p id="8574" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们的目标是执行一些操作来使它们</p><pre class="kg kh ki kj fd kk kl km kn aw ko bi"><span id="d9b1" class="kp je hi kl b fi kq kr l ks kt">-487 -100 0 1 87 101 781</span></pre><p id="7f78" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果我们用0，1，2…来代替它们，比如</p><pre class="kg kh ki kj fd kk kl km kn aw ko bi"><span id="10dc" class="kp je hi kl b fi kq kr l ks kt">-487 -100 0 1 87 101 781<br/>   0    1 2 3  4   5   6</span></pre><p id="499a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">原始列表</p><pre class="kg kh ki kj fd kk kl km kn aw ko bi"><span id="b230" class="kp je hi kl b fi kq kr l ks kt">87 -487 781 -100 101 0 1</span></pre><p id="d5fa" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">就变成了</p><pre class="kg kh ki kj fd kk kl km kn aw ko bi"><span id="b07f" class="kp je hi kl b fi kq kr l ks kt">4 0 6 1 5 2 3</span></pre><p id="6f39" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">对87 -487 781 -100 101 0 1进行排序的操作也可以对4 0 6 1 5 2 3进行排序，反之亦然。</p><p id="dbe9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">所以，现在我们只需要排序4 0 6 1 5 2 3，而不是排序87 -487 781 -100 101 0 1。</p><p id="b558" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">有了这个思路，我们就可以对任意一个整数列表进行化简，使其取值范围在[0，N](≥0且&lt; N，N为列表的大小)。下面是一个简短的C++实现。</p><p id="0b83" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">(如果不熟悉C++的语法，就把vector <int>想成整数数组，sort想成对数组进行升序排序的函数。)</int></p><pre class="kg kh ki kj fd kk kl km kn aw ko bi"><span id="8c44" class="kp je hi kl b fi kq kr l ks kt">vector&lt;int&gt; input;</span><span id="4db7" class="kp je hi kl b fi ku kr l ks kt">//parse the numbers into input ...<br/>//reminder : there is no duplicate</span><span id="dfdc" class="kp je hi kl b fi ku kr l ks kt">vector&lt;int&gt; copy = input; // copy the numbers from input</span><span id="f3e5" class="kp je hi kl b fi ku kr l ks kt">sort(copy.begin(), copy.end());</span><span id="4d8a" class="kp je hi kl b fi ku kr l ks kt">for(int i = 0 ; i &lt; input.size() ; ++i) <br/>    for(int j = 0 ; j &lt; copy.size() ; ++j)<br/>        if (input[i] == copy[j])<br/>            input[i] = j;</span><span id="f95b" class="kp je hi kl b fi ku kr l ks kt">//put input into stack a ...</span><span id="4e1f" class="kp je hi kl b fi ku kr l ks kt">/*<br/>Remark : This is actually not the most efficient way to implement them. If you want a more efficient program, please learn about binary search or unordered_map (hash)<br/>*/</span></pre><p id="0e22" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在，数组输入中的每个数字都在[0，N]范围内，因此我们可以使用基数排序对它们进行排序。</p><p id="55de" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">但是，对于push_swap来说，使用10个盒子并不是一个好主意，因为我们只有2个盒子。显然，在这种情况下，2个盒子会更合适，这意味着我们应该将数字放在基数2中。</p><p id="5cac" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为了操作基数为2的数字，我们可以将数字保存为由0和1组成的字符串，或者像一些很酷的程序员一样使用<strong class="ih hj">位运算</strong>。</p><h2 id="e04d" class="kp je hi bd jf la lb lc jj ld le lf jn iq lg lh jr iu li lj jv iy lk ll jz lm bi translated">位运算</h2><p id="8fc4" class="pw-post-body-paragraph if ig hi ih b ii kb ik il im kc io ip iq kd is it iu ke iw ix iy kf ja jb jc hb bi translated">同样，你可以阅读这篇文章，但我会解释它。</p><div class="lp lq ez fb lr ls"><a href="https://www.programiz.com/c-programming/bitwise-operators" rel="noopener  ugc nofollow" target="_blank"><div class="lt ab dw"><div class="lu ab lv cl cj lw"><h2 class="bd hj fi z dy lx ea eb ly ed ef hh bi translated">c按位运算符:与、或、异或、求补和移位运算</h2><div class="lz l"><h3 class="bd b fi z dy lx ea eb ly ed ef dx translated">在算术逻辑单元(在CPU内部)中，数学运算如:加、减、乘…</h3></div><div class="ma l"><p class="bd b fp z dy lx ea eb ly ed ef dx translated">www.programiz.com</p></div></div></div></a></div><p id="583c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">今天我们将在C/C++中使用两个按位运算符，它们是</p><pre class="kg kh ki kj fd kk kl km kn aw ko bi"><span id="f228" class="kp je hi kl b fi kq kr l ks kt">&gt;&gt; (Right shift)</span></pre><p id="4cba" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">和</p><pre class="kg kh ki kj fd kk kl km kn aw ko bi"><span id="5245" class="kp je hi kl b fi kq kr l ks kt">&amp; (Bitwise AND)</span></pre><p id="e0bc" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">&gt;&gt;运算符将所有位向右移位。让我们用一个例子来看看它是如何工作的。</p><p id="3079" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">假设我们有一个数字</p><pre class="kg kh ki kj fd kk kl km kn aw ko bi"><span id="bf5b" class="kp je hi kl b fi kq kr l ks kt">int num = 36;</span></pre><p id="bb36" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在基数2中是</p><pre class="kg kh ki kj fd kk kl km kn aw ko bi"><span id="a343" class="kp je hi kl b fi kq kr l ks kt">0000 ... 0010 0100（32 bits in total）</span></pre><p id="3d99" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果我们在C语言中使用&gt;&gt;运算符</p><pre class="kg kh ki kj fd kk kl km kn aw ko bi"><span id="5d93" class="kp je hi kl b fi kq kr l ks kt">printf("%d\n", num&gt;&gt;2); // output is 9</span></pre><p id="f9ff" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">输出将是9。为什么？</p><pre class="kg kh ki kj fd kk kl km kn aw ko bi"><span id="5e5b" class="kp je hi kl b fi kq kr l ks kt">0000 ... 00<strong class="kl hj">10 0100</strong> -&gt; 36</span><span id="f89f" class="kp je hi kl b fi ku kr l ks kt">Right shift 2 bits</span><span id="a229" class="kp je hi kl b fi ku kr l ks kt">0000 ... 0000 <strong class="kl hj">1001</strong> -&gt; 9</span></pre><p id="1607" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">因为10进制的36是2进制的100100，右移2位后变成1001，也就是10进制的9。</p><p id="911b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">一些你可以尝试的练习。先思考，然后用c验证你的答案。</p><pre class="kg kh ki kj fd kk kl km kn aw ko bi"><span id="79ce" class="kp je hi kl b fi kq kr l ks kt">8&gt;&gt;1 == ?</span><span id="5bf0" class="kp je hi kl b fi ku kr l ks kt">5&gt;&gt;2 == ?</span><span id="b506" class="kp je hi kl b fi ku kr l ks kt">2&gt;&gt;4 == ?</span><span id="d2da" class="kp je hi kl b fi ku kr l ks kt">87&gt;&gt;3 == ? (Hint : 87 in base 10 is 1010111)</span></pre><p id="d3ac" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">然后，按位AND运算符(&amp;)。</p><p id="4d3c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">对于每一位，&amp;工作如下</p><pre class="kg kh ki kj fd kk kl km kn aw ko bi"><span id="02fd" class="kp je hi kl b fi kq kr l ks kt">1 &amp; 1 == 1<br/>1 &amp; 0 == 0<br/>0 &amp; 1 == 0<br/>0 &amp; 0 == 0</span></pre><p id="9405" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">对于两个整数，&amp;将在每个位上执行。例如</p><pre class="kg kh ki kj fd kk kl km kn aw ko bi"><span id="fc48" class="kp je hi kl b fi kq kr l ks kt">printf("%d\n", 6&amp;5); //output is 4</span></pre><p id="502f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">将打印4。因为</p><pre class="kg kh ki kj fd kk kl km kn aw ko bi"><span id="7dd5" class="kp je hi kl b fi kq kr l ks kt">6   : 0000 ... 0 <strong class="kl hj">1 1 0</strong><br/>5   : 0000 ... 0 <strong class="kl hj">1 0 1</strong></span><span id="2836" class="kp je hi kl b fi ku kr l ks kt">6&amp;5 : 0000 ... 0 <strong class="kl hj">1 0 0 </strong>-&gt; 4</span></pre><p id="ddba" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">对于1的位置上的位，6和5分别有0和1。0&amp;1 == 0，所以6&amp;5的这个位是0。</p><p id="4ed9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">对于10的位，6和5分别有1和0。1&amp;0 == 0，所以6&amp;5的这个位是0。</p><p id="1d82" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">对于100位的位，6和5分别有1和1。1&amp;1 == 1，所以6&amp;5的这个位是1。</p><p id="591e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">对于6和5，所有其他位都是0，因此6&amp;5 == 000000 … 0100以2为基数，以10为基数就是4。</p><p id="a725" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">更多的例子</p><pre class="kg kh ki kj fd kk kl km kn aw ko bi"><span id="a27d" class="kp je hi kl b fi kq kr l ks kt">2   : 0000 ... 0 <strong class="kl hj">0 1 0</strong><br/>5   : 0000 ... 0 <strong class="kl hj">1 0 1</strong></span><span id="545c" class="kp je hi kl b fi ku kr l ks kt">2&amp;5 : 0000 ... 0 <strong class="kl hj">0 0 0 </strong>-&gt; 0</span><span id="ba2b" class="kp je hi kl b fi ku kr l ks kt">--------------------------------------------------------------------</span><span id="174f" class="kp je hi kl b fi ku kr l ks kt">15  : 0000 ... <strong class="kl hj">1 1 1 1</strong><br/>9   : 0000 ...<strong class="kl hj"> 1 0 0 1</strong></span><span id="cb8d" class="kp je hi kl b fi ku kr l ks kt">2&amp;5 : 0000 ... <strong class="kl hj">1 0 0 1</strong>-&gt; 9</span></pre><p id="c470" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">一些你可以尝试的练习。先思考，然后用c验证你的答案。</p><pre class="kg kh ki kj fd kk kl km kn aw ko bi"><span id="7cc3" class="kp je hi kl b fi kq kr l ks kt">5&amp;10 == ?</span><span id="73f6" class="kp je hi kl b fi ku kr l ks kt">12&amp;23 == ?</span></pre><p id="a6ca" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在，我们终于准备好用基数排序实现push_swap了</p><h2 id="9f43" class="kp je hi bd jf la lb lc jj ld le lf jn iq lg lh jr iu li lj jv iy lk ll jz lm bi translated">push_swap上的基数排序</h2><p id="94b9" class="pw-post-body-paragraph if ig hi ih b ii kb ik il im kc io ip iq kd is it iu ke iw ix iy kf ja jb jc hb bi translated">回到上面的例子，如果我们想要一个指令列表来排序</p><pre class="kg kh ki kj fd kk kl km kn aw ko bi"><span id="9b65" class="kp je hi kl b fi kq kr l ks kt">87 -487 781 -100 101 0 1</span></pre><p id="fc73" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">结果与排序相同</p><pre class="kg kh ki kj fd kk kl km kn aw ko bi"><span id="47d4" class="kp je hi kl b fi kq kr l ks kt">4 0 6 1 5 2 3</span></pre><p id="9d8d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在base 2中，它将是</p><pre class="kg kh ki kj fd kk kl km kn aw ko bi"><span id="57ed" class="kp je hi kl b fi kq kr l ks kt">100 000 110 001 101 010 011</span></pre><p id="12e7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在堆栈中，它看起来像</p><pre class="kg kh ki kj fd kk kl km kn aw ko bi"><span id="614e" class="kp je hi kl b fi kq kr l ks kt">100</span><span id="4422" class="kp je hi kl b fi ku kr l ks kt">000</span><span id="f037" class="kp je hi kl b fi ku kr l ks kt">110</span><span id="204e" class="kp je hi kl b fi ku kr l ks kt">001</span><span id="e17d" class="kp je hi kl b fi ku kr l ks kt">101</span><span id="28fb" class="kp je hi kl b fi ku kr l ks kt">010</span><span id="b05a" class="kp je hi kl b fi ku kr l ks kt">011</span><span id="53aa" class="kp je hi kl b fi ku kr l ks kt">----------     ----------</span><span id="d1a1" class="kp je hi kl b fi ku kr l ks kt">a              b</span></pre><p id="436a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">和基数排序一样，我们需要两个盒子分别存放0和1。这里我们把<strong class="ih hj"> A </strong>作为盒子1，把<strong class="ih hj"> B </strong>作为盒子0。然后，我们从最右边的位开始到最左边的位。</p><p id="374c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在右数第I位，如果<strong class="ih hj"> A </strong>顶部数字的第I位是0，我们执行pb将这个数字放入栈<strong class="ih hj"> B </strong>。否则，我们执行ra以将其留在堆栈<strong class="ih hj"> A </strong>中。在我们对每个数字执行一次操作后，它们中的每一个都在对应于它的数字的盒子中，就像我们在基数排序中将数字放入盒子中一样。</p><p id="9c2b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在我们对第一位(最右边的位)这样做之后，它看起来一定是这样的。</p><pre class="kg kh ki kj fd kk kl km kn aw ko bi"><span id="0b28" class="kp je hi kl b fi kq kr l ks kt">               010</span><span id="caa7" class="kp je hi kl b fi ku kr l ks kt">001            110</span><span id="78f9" class="kp je hi kl b fi ku kr l ks kt">101            000</span><span id="5eaa" class="kp je hi kl b fi ku kr l ks kt">011            100</span><span id="e4e0" class="kp je hi kl b fi ku kr l ks kt">----------     ----------</span><span id="a6af" class="kp je hi kl b fi ku kr l ks kt">a              b</span></pre><p id="79ec" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">之后，我们执行pa，直到堆栈<strong class="ih hj"> B </strong>中没有数字，因为我们以基数排序的方式连接这些数字。</p><pre class="kg kh ki kj fd kk kl km kn aw ko bi"><span id="731e" class="kp je hi kl b fi kq kr l ks kt">100</span><span id="d012" class="kp je hi kl b fi ku kr l ks kt">000</span><span id="7f72" class="kp je hi kl b fi ku kr l ks kt">110</span><span id="8a7f" class="kp je hi kl b fi ku kr l ks kt">010</span><span id="49e0" class="kp je hi kl b fi ku kr l ks kt">001</span><span id="ee2f" class="kp je hi kl b fi ku kr l ks kt">101</span><span id="abf9" class="kp je hi kl b fi ku kr l ks kt">011</span><span id="f2ca" class="kp je hi kl b fi ku kr l ks kt">----------     ----------</span><span id="e5b7" class="kp je hi kl b fi ku kr l ks kt">a              b</span></pre><p id="09c3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们对第二位和第三位重复这一过程。</p><pre class="kg kh ki kj fd kk kl km kn aw ko bi"><span id="ba9c" class="kp je hi kl b fi kq kr l ks kt">-----The-Second-Bit------</span><span id="933d" class="kp je hi kl b fi ku kr l ks kt">               101</span><span id="d586" class="kp je hi kl b fi ku kr l ks kt">110            001</span><span id="e87e" class="kp je hi kl b fi ku kr l ks kt">010            000</span><span id="28c3" class="kp je hi kl b fi ku kr l ks kt">011            100</span><span id="a697" class="kp je hi kl b fi ku kr l ks kt">----------     ----------</span><span id="50fb" class="kp je hi kl b fi ku kr l ks kt">a              b</span><span id="6bc2" class="kp je hi kl b fi ku kr l ks kt">---------Connect---------</span><span id="16d7" class="kp je hi kl b fi ku kr l ks kt">100</span><span id="3231" class="kp je hi kl b fi ku kr l ks kt">000</span><span id="5921" class="kp je hi kl b fi ku kr l ks kt">001</span><span id="ea26" class="kp je hi kl b fi ku kr l ks kt">101</span><span id="07eb" class="kp je hi kl b fi ku kr l ks kt">110</span><span id="55a3" class="kp je hi kl b fi ku kr l ks kt">010</span><span id="5a84" class="kp je hi kl b fi ku kr l ks kt">011</span><span id="9e00" class="kp je hi kl b fi ku kr l ks kt">----------     ----------</span><span id="d536" class="kp je hi kl b fi ku kr l ks kt">a              b</span><span id="4a08" class="kp je hi kl b fi ku kr l ks kt">------The-Third-Bit------</span><span id="f9a2" class="kp je hi kl b fi ku kr l ks kt">               011</span><span id="e759" class="kp je hi kl b fi ku kr l ks kt">100            010</span><span id="0a3d" class="kp je hi kl b fi ku kr l ks kt">101            001</span><span id="911c" class="kp je hi kl b fi ku kr l ks kt">110            000</span><span id="fcb0" class="kp je hi kl b fi ku kr l ks kt">----------     ----------</span><span id="f80d" class="kp je hi kl b fi ku kr l ks kt">a              b</span><span id="ab81" class="kp je hi kl b fi ku kr l ks kt">---------Connect---------</span><span id="3688" class="kp je hi kl b fi ku kr l ks kt">000</span><span id="fb32" class="kp je hi kl b fi ku kr l ks kt">001</span><span id="3794" class="kp je hi kl b fi ku kr l ks kt">010</span><span id="bdbf" class="kp je hi kl b fi ku kr l ks kt">011</span><span id="c9eb" class="kp je hi kl b fi ku kr l ks kt">100</span><span id="ce7c" class="kp je hi kl b fi ku kr l ks kt">101</span><span id="1112" class="kp je hi kl b fi ku kr l ks kt">110</span><span id="95d0" class="kp je hi kl b fi ku kr l ks kt">----------     ----------</span><span id="55b8" class="kp je hi kl b fi ku kr l ks kt">a              b</span></pre><p id="0363" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在我们重复三次之后，数字被排序，因为列表中最大的数字(以10为基数的6，以2为基数的110)只有3位。</p><p id="305a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这就是我们对它们的分类。</p><p id="a626" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">用C++来实现它，就像</p><pre class="kg kh ki kj fd kk kl km kn aw ko bi"><span id="425e" class="kp je hi kl b fi kq kr l ks kt">int size = a.size();</span><span id="a8b0" class="kp je hi kl b fi ku kr l ks kt">int max_num = size - 1; // the biggest number in a is stack_size - 1</span><span id="81a4" class="kp je hi kl b fi ku kr l ks kt">int max_bits = 0; // how many bits for max_num </span><span id="24bc" class="kp je hi kl b fi ku kr l ks kt">while ((max_num &gt;&gt; max_bits) != 0) ++max_bits;</span><span id="b142" class="kp je hi kl b fi ku kr l ks kt">for (int i = 0 ; i &lt; max_bits ; ++i) // repeat for max_bits times<br/>{<br/>    for(int j = 0 ; j &lt; size ; ++j)<br/>    {</span><span id="d9ff" class="kp je hi kl b fi ku kr l ks kt">        int num = a.top(); // top number of A</span><span id="6694" class="kp je hi kl b fi ku kr l ks kt">        if ((num &gt;&gt; i)&amp;1 == 1) ra(); <br/>        // if the (i + 1)-th bit is 1, leave in stack a</span><span id="11b3" class="kp je hi kl b fi ku kr l ks kt">        else pb();<br/>        // otherwise push to stack b</span><span id="2fc7" class="kp je hi kl b fi ku kr l ks kt">    }</span><span id="41a4" class="kp je hi kl b fi ku kr l ks kt">    // put into boxes done</span><span id="6655" class="kp je hi kl b fi ku kr l ks kt">    while (!b.empty()) pa(); // while stack b is not empty, do pa<br/>    <br/>    // connect numbers done</span><span id="d7ad" class="kp je hi kl b fi ku kr l ks kt">}</span></pre><p id="ea9b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">最棘手的部分一定是条件if ((num&gt;&gt;i)&amp;1 == 1)。(num&gt;&gt;i)&amp;1的结果必须是0或1，这是num的第(i + 1)位的值。</p><p id="da22" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">例如，(5&gt;&gt;2)&amp;1 == 1因为</p><pre class="kg kh ki kj fd kk kl km kn aw ko bi"><span id="91e8" class="kp je hi kl b fi kq kr l ks kt"> 5       : <strong class="kl hj">1</strong>01<br/> 5&gt;&gt;2    :   <strong class="kl hj">1</strong><br/>(5&gt;&gt;2)&amp;1 :   <strong class="kl hj">1</strong></span></pre><p id="5c86" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">(8&gt;&gt;2)&amp;1 == 0因为</p><pre class="kg kh ki kj fd kk kl km kn aw ko bi"><span id="6471" class="kp je hi kl b fi kq kr l ks kt"> 8       : 1<strong class="kl hj">0</strong>00<br/> 8&gt;&gt;2    :   1<strong class="kl hj">0</strong><br/>(8&gt;&gt;2)&amp;1 :    <strong class="kl hj">0</strong></span></pre><p id="361f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这就是我们实现sort_big_stack()函数的方法。如果你做完测试(测试者在下面)，你会看到stack_size为100的时候，大概有1084条指令，stack_size为500的时候，大概有6756条指令，足够好通过了。</p><figure class="kg kh ki kj fd kw er es paragraph-image"><div class="er es mb"><img src="../Images/e6d0a56e76ef94e296312126472cf061.png" data-original-src="https://miro.medium.com/v2/resize:fit:1384/format:webp/1*LjwfAbYXsjbxtaS-bCUJ7Q.png"/></div></figure><p id="0d6e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">问:为什么即使输入不同，指令数量也保持不变？(不是tester的问题，不信去查一下test_case。)</p><p id="f817" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">除此之外，我们还可以用其他方式实现它，比如</p><pre class="kg kh ki kj fd kk kl km kn aw ko bi"><span id="609e" class="kp je hi kl b fi kq kr l ks kt">bool is_sorted(stack&lt;int&gt; &amp; a);<br/>// please implement this function by yourself :)</span><span id="2177" class="kp je hi kl b fi ku kr l ks kt">int size = a.size();</span><span id="78dc" class="kp je hi kl b fi ku kr l ks kt">for (int i = 0 ; !is_sorted(a) ; ++i)<br/>{</span><span id="73e2" class="kp je hi kl b fi ku kr l ks kt">    for(int j = 0 ; j &lt; size ; ++j)<br/>    {</span><span id="55bb" class="kp je hi kl b fi ku kr l ks kt">        int num = a.top();</span><span id="d766" class="kp je hi kl b fi ku kr l ks kt">        if ((num &gt;&gt; i)&amp;1) ra();</span><span id="b7d2" class="kp je hi kl b fi ku kr l ks kt">        else pb();</span><span id="272e" class="kp je hi kl b fi ku kr l ks kt">    }</span><span id="0963" class="kp je hi kl b fi ku kr l ks kt">    while (!b.empty()) pa();<br/>}</span></pre><p id="c761" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">您可以尝试分析这些不同实现方式的利弊。</p><p id="7c8d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">此外，还有一些常见错误:</p><pre class="kg kh ki kj fd kk kl km kn aw ko bi"><span id="2a38" class="kp je hi kl b fi kq kr l ks kt">for (int j = 0 ; j &lt; a.size() ; ++j) // ... (x)</span><span id="ae27" class="kp je hi kl b fi ku kr l ks kt">for (int j = 0 ; j &lt; size ; ++j)     // ... (o)</span></pre><p id="4bd7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">仔细想想，这两个循环有什么区别？</p><p id="8e52" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">总之，我们就是这样用基数排序完成push_swap的。如果你遇到任何困难，下面的工具可能会帮助你。或者可以评论提问或者给点建议。祝你好运:)</p><h1 id="ffd1" class="jd je hi bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">工具</h1><p id="09b3" class="pw-post-body-paragraph if ig hi ih b ii kb ik il im kc io ip iq kd is it iu ke iw ix iy kf ja jb jc hb bi translated">对于主题和一些有用的工具(基数排序可视化)</p><div class="lp lq ez fb lr ls"><a href="https://github.com/LeoFu9487/push_swap_tutorial" rel="noopener  ugc nofollow" target="_blank"><div class="lt ab dw"><div class="lu ab lv cl cj lw"><h2 class="bd hj fi z dy lx ea eb ly ed ef hh bi translated">LeoFu9487/push_swap_tutorial</h2><div class="lz l"><h3 class="bd b fi z dy lx ea eb ly ed ef dx translated">首先，阅读以下文章中的算法:中文版…</h3></div><div class="ma l"><p class="bd b fp z dy lx ea eb ly ed ef dx translated">github.com</p></div></div><div class="mc l"><div class="md l me mf mg mc mh kx ls"/></div></div></a></div><p id="449e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">测试员</p><div class="lp lq ez fb lr ls"><a href="https://github.com/LeoFu9487/push_swap_tester" rel="noopener  ugc nofollow" target="_blank"><div class="lt ab dw"><div class="lu ab lv cl cj lw"><h2 class="bd hj fi z dy lx ea eb ly ed ef hh bi translated">leofu 9487/push _ swap _检测仪</h2><div class="lz l"><h3 class="bd b fi z dy lx ea eb ly ed ef dx translated">首先，转到您的库的根目录，在那里我们可以找到您的Makefile并进行git克隆…</h3></div><div class="ma l"><p class="bd b fp z dy lx ea eb ly ed ef dx translated">github.com</p></div></div><div class="mc l"><div class="mi l me mf mg mc mh kx ls"/></div></div></a></div></div></div>    
</body>
</html>