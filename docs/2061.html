<html>
<head>
<title>Parcel Tracking Application With RabbitMQ</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用RabbitMQ的包裹跟踪应用程序</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/parcel-tracking-application-with-rabbitmq-1e022b2ff190?source=collection_archive---------9-----------------------#2021-04-19">https://medium.com/nerd-for-tech/parcel-tracking-application-with-rabbitmq-1e022b2ff190?source=collection_archive---------9-----------------------#2021-04-19</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/fa724cc485a4836b49fd387643e22aab.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*j-T3fET2B1bZ0rr7Kdw2NA.png"/></div></div></figure><p id="b509" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在开发过程中，除了指定将要使用的技术之外，确定项目架构将会如何也是很重要的。如今，最常见的项目架构是微服务架构。微服务架构的一个基本特性是每个服务都可以单独部署。由于这个特性，每个服务都可以在项目中使用不同的协议。这意味着一个项目可以包含HTTP、AMQP和WS连接协议。</p><p id="69b4" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在本文中，我们将构建一个同时使用HTTP、AMQP和WS的服务。在这项服务中，我们将使用这些技术:</p><ul class=""><li id="d1b6" class="jo jp hi is b it iu ix iy jb jq jf jr jj js jn jt ju jv jw bi translated">快递. js</li><li id="6e8b" class="jo jp hi is b it jx ix jy jb jz jf ka jj kb jn jt ju jv jw bi translated">MongoDB</li><li id="9808" class="jo jp hi is b it jx ix jy jb jz jf ka jj kb jn jt ju jv jw bi translated"><a class="ae kc" href="http://socket.io/" rel="noopener ugc nofollow" target="_blank">插座。木卫一</a></li><li id="bd6c" class="jo jp hi is b it jx ix jy jb jz jf ka jj kb jn jt ju jv jw bi translated">兔子q</li><li id="e0c7" class="jo jp hi is b it jx ix jy jb jz jf ka jj kb jn jt ju jv jw bi translated">反应堆</li></ul><p id="8f14" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们将使用Express.js库来处理HTTP请求。当收到HTTP请求时，我们将执行<em class="kd"> publishers </em>，它向RabbitMQ消息代理发布关于事件的消息。我们还将创建消费者来监听发布者发送给RabbitMQ消息代理的消息，并将它们保存到MongoDB数据库中。最后，我们将使用<a class="ae kc" href="http://socket.io/" rel="noopener ugc nofollow" target="_blank">插座。IO </a>为了跟踪MongoDB中的每一个变化，并在使用React构建的前端中呈现这些变化，而无需刷新页面。</p><p id="d076" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">下面是<a class="ae kc" href="https://github.com/ardaorkin/rabbitmq-parcel-tracking.git" rel="noopener ugc nofollow" target="_blank">项目</a>的最终代码</p><h1 id="b65b" class="ke kf hi bd kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb bi translated">要求</h1><ul class=""><li id="8846" class="jo jp hi is b it lc ix ld jb le jf lf jj lg jn jt ju jv jw bi translated">NodeJS 12v+</li></ul><h1 id="7ca8" class="ke kf hi bd kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb bi translated">建筑开发环境</h1><h1 id="6c02" class="ke kf hi bd kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb bi translated">计算机网络服务器</h1><ul class=""><li id="6c84" class="jo jp hi is b it lc ix ld jb le jf lf jj lg jn jt ju jv jw bi translated">首先，让我们创建一个名为包裹追踪系统的文件夹。在该文件夹中，我们再创建一个名为server的文件夹。然后打开一个终端，转到您刚刚创建的服务器文件夹所在的目录，并运行npm init -y。</li></ul><p id="2f2f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">然后再次返回到终端，要安装项目依赖项，请在名为server的文件夹所在的目录中运行以下命令:</p><pre class="lh li lj lk fd ll lm ln lo aw lp bi"><span id="ea74" class="lq kf hi lm b fi lr ls l lt lu">npm i express dotenv tortoise mongoose socket.io nodemon</span></pre><p id="56ef" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">为了确保命令被成功执行并且包被安装，查看终端中返回的消息，打开package.json文件并查看依赖项部分。</p><p id="b813" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">此外，让我们安装开发环境依赖项:</p><p id="addc" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><code class="du lv lw lx lm b">npm i --save-dev @babel/core @babel/preset-env babel-loader</code></p><p id="86bc" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">稍后，创建一个名为。babelrc并在其中编写以下代码:</p><pre class="lh li lj lk fd ll lm ln lo aw lp bi"><span id="59d2" class="lq kf hi lm b fi lr ls l lt lu">{                                        <br/>    "presets": ["@babel/env"]                                        <br/>}</span></pre><p id="1a69" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在，让我们再创建一个名为server.js的文件，并在其中编写以下代码:</p><pre class="lh li lj lk fd ll lm ln lo aw lp bi"><span id="c256" class="lq kf hi lm b fi lr ls l lt lu">//server.js</span><span id="dc7b" class="lq kf hi lm b fi ly ls l lt lu">import express from "express"              </span><span id="fbc3" class="lq kf hi lm b fi ly ls l lt lu">const app = express()              </span><span id="6908" class="lq kf hi lm b fi ly ls l lt lu">app.use("/", (req, res) =&gt; {                </span><span id="aa94" class="lq kf hi lm b fi ly ls l lt lu">res.send("Welcome to parcel tracking system")              </span><span id="2f66" class="lq kf hi lm b fi ly ls l lt lu">})              </span><span id="0200" class="lq kf hi lm b fi ly ls l lt lu">app.listen(8000, () =&gt; console.log(`Server listening on 8000`))</span></pre><p id="f9f5" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">使用以下命令执行server.js:</p><pre class="lh li lj lk fd ll lm ln lo aw lp bi"><span id="e40b" class="lq kf hi lm b fi lr ls l lt lu">nodemon ./server --exec babel -e js</span></pre><p id="e6ff" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">执行后，在浏览器中打开<a class="ae kc" href="http://localhost:3000/" rel="noopener ugc nofollow" target="_blank"> localhost:3000 </a>。如果页面上出现“欢迎使用包裹追踪系统”消息，则意味着Express.js安装已成功结束。</p><h1 id="f6b9" class="ke kf hi bd kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb bi translated">出版商和消费者创作</h1><p id="91c8" class="pw-post-body-paragraph iq ir hi is b it lc iv iw ix ld iz ja jb lz jd je jf ma jh ji jj mb jl jm jn hb bi translated">在这些步骤中，我们将创建我们的第一个发布者和消费者。发布者将发布一条消息，将其发送到RabbitMQ消息代理中的<em class="kd">交换站</em>,<em class="kd">交换站</em>将消息发送到消息队列，<em class="kd">消费者</em>监听队列中他们关心的消息，接收消息并做我们想做的事情。</p><p id="ff3f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在，我们将通过消费者获得的消息记录到控制台。为此，让我们在名为server的文件夹下创建两个名为publisher和consumer的文件夹。在publisher文件夹中，创建一个名为shippingPublihser.js的文件，在consumer文件夹中，创建一个名为shippingConsumer.js的文件。</p><p id="cf1e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">将此代码写入shippingPublihser.js文件:</p><pre class="lh li lj lk fd ll lm ln lo aw lp bi"><span id="dab8" class="lq kf hi lm b fi lr ls l lt lu">//shippingPublisher.js</span><span id="d416" class="lq kf hi lm b fi ly ls l lt lu">import Tortoise from "tortoise"          <br/>import dotenv from "dotenv";          <br/>dotenv.config()          </span><span id="4578" class="lq kf hi lm b fi ly ls l lt lu">const tortoise = new Tortoise(process.env.AMQP_URL)    <br/>        tortoise      <br/>            .exchange("parcel-tracking", "topic", { durable: false })      <br/>            .publish("parcel.shipping", { name: "test", status: "shipping" });</span></pre><p id="8a8c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在，让我们编写消费者，它将接收由发布者发送给消息代理的消息。为此，请将此代码写入shippingConsumer.js文件:</p><pre class="lh li lj lk fd ll lm ln lo aw lp bi"><span id="6f52" class="lq kf hi lm b fi lr ls l lt lu">//shippingConsumer.js</span><span id="1c12" class="lq kf hi lm b fi ly ls l lt lu">import Tortoise from "tortoise"                            <br/>import dotenv from "dotenv";                            <br/>dotenv.config()                            </span><span id="086f" class="lq kf hi lm b fi ly ls l lt lu">const tortoise = new Tortoise(process.env.AMQP_URL)                            </span><span id="18d1" class="lq kf hi lm b fi ly ls l lt lu">tortoise  <br/>    .queue("", { durable: false })  <br/>    .exchange("parcel-tracking", "topic", "*.shipping", { durable: false })  <br/>    .prefetch(1)  <br/>    .json()  <br/>    .subscribe((msg, ack, nack) =&gt; {    <br/>        console.log(msg)    <br/>        ack();  <br/>    });</span></pre><p id="6b2d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们可以选择在本地机器上安装RabbitMQ，但是在这种情况下，不同操作系统的安装步骤会有所不同，我们需要修改一些网络设置。因此，我们用<a class="ae kc" href="http://cloudamqp.com/" rel="noopener ugc nofollow" target="_blank">cloudamqp.com</a>做这一步。为此，让我们创建<a class="ae kc" href="https://cloudamqp.com/" rel="noopener ugc nofollow" target="_blank">cloudamqp.com</a>。稍后，单击按钮Create New Instance并创建一个新的message broker实例。我们可以随意命名实例。要自由计划，选择小狐猴选项。然后分别按下名为选择区域&gt;的按钮审核&gt;创建实例。转到列出了消息代理的<a class="ae kc" href="https://customer.cloudamqp.com/instance" rel="noopener ugc nofollow" target="_blank">页面</a>,单击我们刚刚创建的消息代理实例的名称。在页面中出现的详细信息部分复制AMQP URL的值。在应用这些步骤之后，返回到服务器文件夹，创建一个名为. env的文件。环境文件:</p><pre class="lh li lj lk fd ll lm ln lo aw lp bi"><span id="a155" class="lq kf hi lm b fi lr ls l lt lu">AMQP_URL="&lt;copied_amqp_url&gt;"</span></pre><p id="848e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">通过这个过程，我们创建了一个AQMP服务。现在是运行我们的发布者和消费者的时候了。为此，在两个独立的终端中，分别运行以下命令:</p><pre class="lh li lj lk fd ll lm ln lo aw lp bi"><span id="8920" class="lq kf hi lm b fi lr ls l lt lu">nodemon ./consumers/shippingConsumer --exec babel-node -e js          <br/>nodemon ./publishers/shippingPublisher --exec babel-node -e js</span></pre><p id="451c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">应用这些步骤后，我们应该在运行shippingConsumer.js的终端中看到这条消息:</p><pre class="lh li lj lk fd ll lm ln lo aw lp bi"><span id="f590" class="lq kf hi lm b fi lr ls l lt lu">{ name: 'test', status: 'shipping' }</span></pre><p id="72e2" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">此时我们有一个工作服务！该服务使用AMQP作为通信协议。服务有两个目的；一个是发行商，一个是消费者。在这个流程发布者的工作完成之后，发布者向消息代理发送消息，并且不等待任何回复。消费者只关心消息头包括什么。在这种情况下，消费者关心标题中有<em class="kd"> shipping </em>声明的消息。除了消息头之外，消费者不需要任何东西。</p><p id="2e1f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">下一步，我们将在收到HTTP请求时发布消息。</p><h1 id="3fdd" class="ke kf hi bd kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb bi translated">处理HTTP请求</h1><p id="7516" class="pw-post-body-paragraph iq ir hi is b it lc iv iw ix ld iz ja jb lz jd je jf ma jh ji jj mb jl jm jn hb bi translated">让我们为每个发布者和消费者再创建两个。再次到服务器文件夹。在publishers文件夹中创建这些文件:</p><ul class=""><li id="1aa0" class="jo jp hi is b it iu ix iy jb jq jf jr jj js jn jt ju jv jw bi translated">onroadPublisher.js</li><li id="940a" class="jo jp hi is b it jx ix jy jb jz jf ka jj kb jn jt ju jv jw bi translated">deliveredPublisher.js</li></ul><p id="cf3f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">并在消费者文件夹中创建这些文件:</p><ul class=""><li id="20f6" class="jo jp hi is b it iu ix iy jb jq jf jr jj js jn jt ju jv jw bi translated">onroadConsumer.js</li><li id="f9f3" class="jo jp hi is b it jx ix jy jb jz jf ka jj kb jn jt ju jv jw bi translated">deliveredConsumer.js</li></ul><p id="3980" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在我们将按照<em class="kd">的承诺</em>编写所有publisher文件:</p><pre class="lh li lj lk fd ll lm ln lo aw lp bi"><span id="414b" class="lq kf hi lm b fi lr ls l lt lu">//shippingPublisher.js</span><span id="e3f1" class="lq kf hi lm b fi ly ls l lt lu">import Tortoise from "tortoise";            <br/>import dotenv from "dotenv";            <br/>dotenv.config();            </span><span id="3374" class="lq kf hi lm b fi ly ls l lt lu">const tortoise = new Tortoise(process.env.AMQP_SERVER);            </span><span id="f198" class="lq kf hi lm b fi ly ls l lt lu">const shippingPublisher = (name) =&gt;              <br/>    new Promise((resolve, reject) =&gt; {                <br/>        tortoise                  <br/>            .exchange("parcel-tracking", "topic", { durable: false })                  <br/>            .publish("parcel.shipping", { name, status: "shipping" });                  <br/>        resolve({ name, status: "shipping" });              <br/>});            </span><span id="1233" class="lq kf hi lm b fi ly ls l lt lu">export default shippingPublisher;</span><span id="419a" class="lq kf hi lm b fi ly ls l lt lu">//onroadPublisher.js</span><span id="89fc" class="lq kf hi lm b fi ly ls l lt lu">import Tortoise from "tortoise";            <br/>import dotenv from "dotenv";            <br/>dotenv.config();            </span><span id="98b9" class="lq kf hi lm b fi ly ls l lt lu">const tortoise = new Tortoise(process.env.AMQP_SERVER);            </span><span id="33c9" class="lq kf hi lm b fi ly ls l lt lu">const onroadPublisher = (name) =&gt;              <br/>    new Promise((resolve, reject) =&gt; {                <br/>        tortoise                  <br/>            .exchange("parcel-tracking", "topic", { durable: false })                  <br/>            .publish("parcel.onroad", { name, status: "onroad" });                  <br/>        resolve({ name, status: "onroad" });              <br/>});            </span><span id="7e86" class="lq kf hi lm b fi ly ls l lt lu">export default onroadPublisher;</span><span id="1183" class="lq kf hi lm b fi ly ls l lt lu">//deliveredPublisher.js</span><span id="a8ee" class="lq kf hi lm b fi ly ls l lt lu">import Tortoise from "tortoise";            <br/>import dotenv from "dotenv";            <br/>dotenv.config();            </span><span id="a33c" class="lq kf hi lm b fi ly ls l lt lu">const tortoise = new Tortoise(process.env.AMQP_SERVER);            </span><span id="c7a4" class="lq kf hi lm b fi ly ls l lt lu">const deliveredPublisher = (name) =&gt;              <br/>    new Promise((resolve, reject) =&gt; {                <br/>        tortoise                  <br/>            .exchange("parcel-tracking", "topic", { durable: false })                  <br/>            .publish("parcel.delivered", { name, status: "delivered" });                  <br/>        resolve({ name, status: "delivered" });              <br/>});            </span><span id="fa24" class="lq kf hi lm b fi ly ls l lt lu">export default deliveredPublisher;</span></pre><p id="13a1" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">稍后，让我们对消费者进行编码:</p><pre class="lh li lj lk fd ll lm ln lo aw lp bi"><span id="2aed" class="lq kf hi lm b fi lr ls l lt lu">//shippingConsumer.js</span><span id="e1ae" class="lq kf hi lm b fi ly ls l lt lu">import Tortoise from "tortoise";            <br/>import dotenv from "dotenv";            <br/>dotenv.config();            </span><span id="806d" class="lq kf hi lm b fi ly ls l lt lu">const tortoise = new Tortoise(process.env.AMQP_SERVER);            <br/>tortoise              <br/>    .queue("", { durable: false })              <br/>    .exchange("parcel-tracking", "topic", "*.shipping", { durable: false })              <br/>    .prefetch(1)              <br/>    .json()              <br/>    .subscribe((msg, ack, nack) =&gt; {                <br/>        console.log(msg)                <br/>    ack();              <br/>    });</span><span id="8635" class="lq kf hi lm b fi ly ls l lt lu">//onroadConsumer.js</span><span id="4440" class="lq kf hi lm b fi ly ls l lt lu">import Tortoise from "tortoise";            <br/>import dotenv from "dotenv";            <br/>dotenv.config();            </span><span id="8bfd" class="lq kf hi lm b fi ly ls l lt lu">const tortoise = new Tortoise(process.env.AMQP_SERVER);            <br/>tortoise              <br/>    .queue("", { durable: false })              <br/>    .exchange("parcel-tracking", "topic", "*.onroad", { durable: false })              <br/>    .prefetch(1)              <br/>    .json()              <br/>    .subscribe((msg, ack, nack) =&gt; {                <br/>        console.log(msg)                <br/>    ack();              <br/>    });</span><span id="e52f" class="lq kf hi lm b fi ly ls l lt lu">//deliveredConsumer.js</span><span id="d73a" class="lq kf hi lm b fi ly ls l lt lu">import Tortoise from "tortoise";            <br/>import dotenv from "dotenv";            <br/>dotenv.config();            </span><span id="4862" class="lq kf hi lm b fi ly ls l lt lu">const tortoise = new Tortoise(process.env.AMQP_SERVER);            <br/>tortoise              <br/>    .queue("", { durable: false })              <br/>    .exchange("parcel-tracking", "topic", "*.delivered", { durable: false })              <br/>    .prefetch(1)              <br/>    .json()              <br/>    .subscribe((msg, ack, nack) =&gt; {                <br/>        console.log(msg)                <br/>    ack();              <br/>    });</span></pre><p id="ee4f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在这些配置之后，当服务器接收HTTP请求时，发布者将被执行，当这些发布者向消息代理发送消息时，我们的消费者将会监听这些消息。</p><p id="2798" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在让我们创建HTTP路由。出于最佳实践和干净代码的考虑，在服务器文件夹下创建一个名为routes的文件夹，并在其中创建一个名为index.js的文件。稍后将这几行写到index.js文件中:</p><pre class="lh li lj lk fd ll lm ln lo aw lp bi"><span id="28b8" class="lq kf hi lm b fi lr ls l lt lu">//index.js</span><span id="8a21" class="lq kf hi lm b fi ly ls l lt lu">import { Router } from "express";            <br/>import shippingPublishers from "../publishers/shippingPublisher";            <br/>import onroadPublisher from "../publishers/onroadPublisher";            <br/>import deliveredPublisher from "../publishers/deliveredPublisher";            </span><span id="4e53" class="lq kf hi lm b fi ly ls l lt lu">const router = Router();            </span><span id="1738" class="lq kf hi lm b fi ly ls l lt lu">router.get("/", (req, res) =&gt; {              <br/>    res.send("Welcome to parcel-tracking system");            <br/>});            </span><span id="7310" class="lq kf hi lm b fi ly ls l lt lu">router.get("/shipping/:name", async (req, res, next) =&gt; {              <br/>    const name = req.params.name;              <br/>    await shippingPublishers(name).then((message) =&gt; res.json(message));            <br/>});            </span><span id="b81d" class="lq kf hi lm b fi ly ls l lt lu">router.get("/onroad/:name", async (req, res, next) =&gt; {              <br/>    const name = req.params.name;              <br/>    await onroadPublisher(name).then((message) =&gt; res.json(message));            <br/>});            </span><span id="9c11" class="lq kf hi lm b fi ly ls l lt lu">router.get("/delivered/:name", async (req, res, next) =&gt; {              <br/>    const name = req.params.name;              <br/>    await deliveredPublisher(name).then((message) =&gt; res.json(message));            <br/>});            </span><span id="43d0" class="lq kf hi lm b fi ly ls l lt lu">export default router;</span></pre><p id="731d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">创建HTTP路由后，让我们像这样修改所有server.js文件:</p><pre class="lh li lj lk fd ll lm ln lo aw lp bi"><span id="5e18" class="lq kf hi lm b fi lr ls l lt lu">//server.js</span><span id="57d2" class="lq kf hi lm b fi ly ls l lt lu">import express from "express";<br/>import router from "./routes";            </span><span id="5555" class="lq kf hi lm b fi ly ls l lt lu">const app = express();<br/>const port = process.env.PORT || 8000;</span><span id="14fe" class="lq kf hi lm b fi ly ls l lt lu">app.use(router);</span><span id="85da" class="lq kf hi lm b fi ly ls l lt lu">app.listen(port, () =&gt; console.log(`Server listening on port ${port}`));</span></pre><p id="3fc8" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">稍后，转到服务器文件夹下，运行以下命令:</p><pre class="lh li lj lk fd ll lm ln lo aw lp bi"><span id="f299" class="lq kf hi lm b fi lr ls l lt lu">nodemon ./server --exec babel-node -e js            <br/>nodemon ./consumers/shippingConsumer --exec babel-node -e js            <br/>nodemon ./consumers/onroadConsumer --exec babel-node -e js            <br/>nodemon ./consumers/deliveredConsumer --exec babel-node -e js</span></pre><p id="10a6" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">命令运行后，在浏览器中分别打开这些链接:</p><ul class=""><li id="595b" class="jo jp hi is b it iu ix iy jb jq jf jr jj js jn jt ju jv jw bi translated"><a class="ae kc" href="http://localhost:8000/shipping/test" rel="noopener ugc nofollow" target="_blank">本地主机:8000/出货/测试</a></li><li id="4a78" class="jo jp hi is b it jx ix jy jb jz jf ka jj kb jn jt ju jv jw bi translated"><a class="ae kc" href="http://localhost:8000/onroad/test" rel="noopener ugc nofollow" target="_blank">本地主机:8000/在途/测试</a></li><li id="f77a" class="jo jp hi is b it jx ix jy jb jz jf ka jj kb jn jt ju jv jw bi translated"><a class="ae kc" href="http://localhost:8000/delivered/test" rel="noopener ugc nofollow" target="_blank">本地主机:8000/交付/测试</a></li></ul><p id="88fd" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">当我们打开链接时，我们应该在终端中以JSON格式看到发送到消息代理的消息。</p><p id="cbb2" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在看到消费者运行的终端和在浏览器中返回的JSON数据之后，我们可以确定当服务器接收HTTP请求时，发布者和消费者都在运行。</p><p id="f902" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">下一步，我们将把消息保存到MongoDB。</p><h1 id="0fda" class="ke kf hi bd kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb bi translated">MongoDB配置</h1><p id="9b17" class="pw-post-body-paragraph iq ir hi is b it lc iv iw ix ld iz ja jb lz jd je jf ma jh ji jj mb jl jm jn hb bi translated">要配置MongoDB，让我们在<a class="ae kc" href="https://www.mongodb.com/cloud" rel="noopener ugc nofollow" target="_blank">mongodb.com/cloud</a>中创建一个帐户。稍后，创建一个组织、组织中的一个项目和项目中的一个群。创建集群后，在集群所在的页面中，单击数据库访问。在那里单击添加新数据库用户选项，并创建一个数据库用户。稍后，单击左侧栏上的集群选项。在打开的页面上，单击连接按钮。在“设置连接安全性”步骤中，选择“允许任何地方”选项，然后单击“选择连接方法”。然后，让我们单击“连接您的应用程序”选项，并将“添加您的连接字符串”下的连接信息复制到您的应用程序代码中。让我们回到文本编辑器，在。env文件，并将MongoDB连接信息赋给该变量。使用刚才在数据库访问步骤中创建的密码进行更改，并将myFirstDatabase更改为parceltracking:</p><pre class="lh li lj lk fd ll lm ln lo aw lp bi"><span id="ad69" class="lq kf hi lm b fi lr ls l lt lu">MONGODB_URL="mongodb+srv://username:12345@cluster0.mjh9d.mongodb.net/parceltracking?retryWrites=true&amp;w=majority"</span></pre><p id="1d37" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">完成这些步骤后，转到server.js文件，在导入routes文件夹的行之后写下这些行:</p><pre class="lh li lj lk fd ll lm ln lo aw lp bi"><span id="17a4" class="lq kf hi lm b fi lr ls l lt lu">//server.js</span><span id="7b32" class="lq kf hi lm b fi ly ls l lt lu">import mongoose from "mongoose"<br/>import dotenv from "dotenv"<br/>dotenv.config()              <br/>mongoose.connect(process.env.MONGODB_URL, {              <br/>    useNewUrlParser: true,              <br/>    useUnifiedTopology: true,            <br/>});            </span><span id="2960" class="lq kf hi lm b fi ly ls l lt lu">const db = mongoose.connection;            <br/>db.on("error", console.error.bind(console, "connection error:"));            <br/>db.once("open", () =&gt; console.log("Connected to database"));</span></pre><p id="2175" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">通过这些线路，我们打开了一个MongoDB连接。为了确保一切正常，让我们用以下命令运行server.js:</p><pre class="lh li lj lk fd ll lm ln lo aw lp bi"><span id="5e8c" class="lq kf hi lm b fi lr ls l lt lu">nodemon ./server --exec babel-node -e js</span></pre><p id="03db" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如果我们在终端的控制台中看到连接到数据库的消息，这意味着我们正确地进行了数据库配置。下一步，我们将创建一个MongoDB模式和模型。为此，让我们在服务器文件夹中创建一个名为model的文件夹。在模型文件夹中，创建一个名为Tracking.js的文件，并写下以下代码:</p><pre class="lh li lj lk fd ll lm ln lo aw lp bi"><span id="7f63" class="lq kf hi lm b fi lr ls l lt lu">//Tracking.js</span><span id="6cfe" class="lq kf hi lm b fi ly ls l lt lu">import mongoose from "mongoose";</span><span id="3070" class="lq kf hi lm b fi ly ls l lt lu">const trackingSchema = new mongoose.Schema({              <br/>    name: String,              <br/>    status: String,            <br/>});            </span><span id="5819" class="lq kf hi lm b fi ly ls l lt lu">const Track = mongoose.model("Track", trackingSchema);            </span><span id="e39e" class="lq kf hi lm b fi ly ls l lt lu">export default Track;</span></pre><p id="782a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在创建模型之后，我们将为消费者使用它。但是当我们使用mongoose库中的save()方法时，updateOne()方法将用于其他消费者。首先，让我们像这样修改shippinConsumer.js文件:</p><pre class="lh li lj lk fd ll lm ln lo aw lp bi"><span id="8f69" class="lq kf hi lm b fi lr ls l lt lu">//shippingConsumer.js</span><span id="3097" class="lq kf hi lm b fi ly ls l lt lu">import Tortoise from "tortoise";            <br/>import mongoose from "mongoose"            <br/>import Track from "../model/Tracking";            <br/>import dotenv from "dotenv"            <br/>dotenv.config()                          <br/>mongoose.connect(process.env.MONGODB_URL, {                          <br/>    useNewUrlParser: true,                          <br/>    useUnifiedTopology: true,                        <br/>});                        </span><span id="b7ac" class="lq kf hi lm b fi ly ls l lt lu">const db = mongoose.connection;                        <br/>db.on("error", console.error.bind(console, "connection error:"));                        <br/>db.once("open", () =&gt; console.log("Connected to database"));            </span><span id="1bf0" class="lq kf hi lm b fi ly ls l lt lu">const tortoise = new Tortoise(process.env.AMQP_SERVER);            <br/>tortoise              <br/>    .queue("", { durable: false })              <br/>    .exchange("parcel-tracking", "topic", "*.shipping", { durable: false })              <br/>    .prefetch(1)              <br/>    .json()              <br/>    .subscribe((msg, ack, nack) =&gt; {                <br/>        const newParcel = new Track(msg);                <br/>        newParcel.save((err, parcel) =&gt; {                  <br/>            if (err) throw err;                  <br/>            console.log("shipped parcel:", parcel);                  <br/>            return parcel;                  <br/>        });                <br/>        ack();              <br/>    });</span></pre><p id="09c9" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这样，shippinConsumer.js将在MongoDB中创建新记录。现在，是时候更新这个记录了。为此，让我们像这样修改onroadConsumer和deliveredConsumer:</p><pre class="lh li lj lk fd ll lm ln lo aw lp bi"><span id="3f8f" class="lq kf hi lm b fi lr ls l lt lu">//onroadConsumer.js</span><span id="2eec" class="lq kf hi lm b fi ly ls l lt lu">import Tortoise from "tortoise";              <br/>import mongoose from "mongoose"              <br/>import Track from "../model/Tracking";              <br/>import dotenv from "dotenv"              <br/>dotenv.config()                            <br/>mongoose.connect(process.env.MONGODB_URL, {                            <br/>    useNewUrlParser: true,                            <br/>    useUnifiedTopology: true,                          <br/>});                          </span><span id="a17c" class="lq kf hi lm b fi ly ls l lt lu">const db = mongoose.connection;                          <br/>db.on("error", console.error.bind(console, "connection error:"));                          <br/>db.once("open", () =&gt; console.log("Connected to database"));            </span><span id="d510" class="lq kf hi lm b fi ly ls l lt lu">const tortoise = new Tortoise(process.env.AMQP_SERVER);            <br/>tortoise              <br/>    .queue("", { durable: false })              <br/>    .exchange("parcel-tracking", "topic", "*.onroad", { durable: false })              <br/>    .prefetch(1)              <br/>    .json()              <br/>    .subscribe(async (msg, ack, nack) =&gt; {                <br/>        const onroadParcel = await Track.updateOne(                  <br/>            { name: msg.name },                  <br/>            { status: msg.status },                  <br/>            (err, parcel) =&gt; {                    <br/>                if (err) throw err;                    <br/>                else return parcel;                  <br/>            }                <br/>        );                <br/>        console.log("parcel is on road:", onroadParcel);                <br/>        ack();              <br/>    });</span><span id="c1d4" class="lq kf hi lm b fi ly ls l lt lu">//deliveredConsumer.js</span><span id="ddd6" class="lq kf hi lm b fi ly ls l lt lu">import Tortoise from "tortoise";              <br/>import mongoose from "mongoose"              <br/>import Track from "../model/Tracking";              <br/>import dotenv from "dotenv"              <br/>dotenv.config()                            <br/>mongoose.connect(process.env.MONGODB_URL, {                            <br/>    useNewUrlParser: true,                            <br/>    useUnifiedTopology: true,                          <br/>});                          </span><span id="8842" class="lq kf hi lm b fi ly ls l lt lu">const db = mongoose.connection;                          <br/>db.on("error", console.error.bind(console, "connection error:"));                          <br/>db.once("open", () =&gt; console.log("Connected to database"));              </span><span id="2fb0" class="lq kf hi lm b fi ly ls l lt lu">const tortoise = new Tortoise(process.env.AMQP_SERVER);            <br/>tortoise              <br/>    .queue("", { durable: false })              <br/>    .exchange("parcel-tracking", "topic", "*.delivered", { durable: false })              <br/>    .prefetch(1)              <br/>    .json()              <br/>    .subscribe(async (msg, ack, nack) =&gt; {                <br/>        const deliveredParcel = await Track.updateOne(                  <br/>            { name: msg.name },                  <br/>            { status: msg.status },                  <br/>            (err, parcel) =&gt; {                    <br/>                if (err) throw err;                    <br/>                else return parcel;                  <br/>            }                <br/>        );                <br/>        console.log("parcel was delivered:", deliveredParcel);                <br/>        ack();              <br/>    });</span></pre><p id="d050" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">完成这些配置后，运行以下命令:</p><pre class="lh li lj lk fd ll lm ln lo aw lp bi"><span id="4c4c" class="lq kf hi lm b fi lr ls l lt lu">nodemon ./server --exec babel-node -e js            <br/>nodemon ./consumers/shippingConsumer --exec babel-node -e js            <br/>nodemon ./consumers/onroadConsumer --exec babel-node -e js            <br/>nodemon ./consumers/deliveredConsumer --exec babel-node -e js</span></pre><p id="1d8f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如果您在所有终端中都看到连接到数据库，这意味着您成功地跳过了所有步骤。现在在浏览器中打开下面的链接，以便测试所有的数据库查询，并且每次都检查MongoDB数据库:</p><ul class=""><li id="ce9a" class="jo jp hi is b it iu ix iy jb jq jf jr jj js jn jt ju jv jw bi translated"><a class="ae kc" href="http://localhost:8000/shipping/test" rel="noopener ugc nofollow" target="_blank">本地主机:8000/发货/测试</a></li><li id="18d9" class="jo jp hi is b it jx ix jy jb jz jf ka jj kb jn jt ju jv jw bi translated"><a class="ae kc" href="http://localhost:8000/onroad/test" rel="noopener ugc nofollow" target="_blank">本地主机:8000/在途/测试</a></li><li id="0128" class="jo jp hi is b it jx ix jy jb jz jf ka jj kb jn jt ju jv jw bi translated"><a class="ae kc" href="http://localhost:8000/delivered/test" rel="noopener ugc nofollow" target="_blank">本地主机:8000/交付/测试</a></li></ul><p id="a7d1" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">单击MongoDB云中集群页面中的Collections选项卡。在出现的页面中，单击parceltracking下名为tracks的集合。</p><p id="e202" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如果我们的查询是正确的，每次当shippingConsumer处理消息时，一条新记录将被添加到MongoDB，并且每次其他消费者处理消息时，该记录将被更新。要显示记录中的更改，您需要单击集合页面上的刷新按钮</p><p id="d4f0" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在是时候使用Web Socket来呈现记录中的更改了。</p><h1 id="a50b" class="ke kf hi bd kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb bi translated">用WebSocket渲染实时数据</h1><p id="2c7c" class="pw-post-body-paragraph iq ir hi is b it lc iv iw ix ld iz ja jb lz jd je jf ma jh ji jj mb jl jm jn hb bi translated">为了用WebSocket渲染实时数据，我们将使用<a class="ae kc" href="http://socket.io/" rel="noopener ugc nofollow" target="_blank">套接字。IO </a>库。每次用户在数据库中进行更改时，新的记录将呈现在应用程序的首页，而无需刷新页面。为此，让我们在服务器文件夹中创建名为socket的文件夹，并添加名为trackerSocket的文件。js在里面。稍后在文件中写下这几行:</p><pre class="lh li lj lk fd ll lm ln lo aw lp bi"><span id="555d" class="lq kf hi lm b fi lr ls l lt lu">//trackerSocket.js</span><span id="b55e" class="lq kf hi lm b fi ly ls l lt lu">import socketIo from "socket.io";            <br/>import express from "express";            <br/>import http from "http";            <br/>import mongoose from "mongoose";            <br/>import Track from "../model/Tracking";            <br/>import dotenv from "dotenv";            </span><span id="b354" class="lq kf hi lm b fi ly ls l lt lu">dotenv.config();            </span><span id="07e4" class="lq kf hi lm b fi ly ls l lt lu">const port = process.env.WS_PORT || 8001;            </span><span id="26b2" class="lq kf hi lm b fi ly ls l lt lu">mongoose.connect(process.env.MONGODB_URL, {            <br/>      useNewUrlParser: true,              <br/>    useUnifiedTopology: true,            <br/>});            </span><span id="5309" class="lq kf hi lm b fi ly ls l lt lu">const db = mongoose.connection;            <br/>db.on("error", console.error.bind(console, "connection error:"));            <br/>db.once("open", () =&gt; console.log("Connected to database"));            </span><span id="bbc9" class="lq kf hi lm b fi ly ls l lt lu">const app = express();            </span><span id="913a" class="lq kf hi lm b fi ly ls l lt lu">const server = http.createServer(app);            </span><span id="f4c1" class="lq kf hi lm b fi ly ls l lt lu">const io = socketIo(server, {              <br/>    cors: {                <br/>    origin: "*",                <br/>    methods: ["GET", "POST"],              <br/>    },            <br/>});            </span><span id="021e" class="lq kf hi lm b fi ly ls l lt lu">let interval;            </span><span id="c17e" class="lq kf hi lm b fi ly ls l lt lu">const findParcel = async (socket) =&gt; {              <br/>    const parcel = await Track.find({}, (err, parcel) =&gt; {                <br/>        if (err) throw err;                <br/>            console.log(parcel);                <br/>            return parcel;              <br/>    });              <br/>    socket.emit("parcel", parcel);            <br/>};            </span><span id="6b28" class="lq kf hi lm b fi ly ls l lt lu">io.on("connection", (socket) =&gt; {              <br/>    console.log("New client connected");              <br/>    if (interval) {                <br/>        clearInterval(interval);              <br/>    }              <br/>    interval = setInterval(() =&gt; findParcel(socket), 1000);              <br/>    socket.on("disconnect", () =&gt; {                <br/>        console.log("Client disconnected");                <br/>        clearInterval(interval);                <br/>    });                <br/>});                </span><span id="645a" class="lq kf hi lm b fi ly ls l lt lu">server.listen(port, () =&gt; console.log(`Listening on port ${port}`));</span></pre><p id="0273" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">写完这些行之后，运行以下命令:</p><pre class="lh li lj lk fd ll lm ln lo aw lp bi"><span id="74b3" class="lq kf hi lm b fi lr ls l lt lu">nodemon ./socket/trackerSocket --exec babel-node -e js</span></pre><p id="9e21" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如果您看到消息侦听端口8001并连接到命令的数据库输出，这意味着命令正在成功运行。</p><p id="2316" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在，为了进行前端安装，打开一个终端，转到我们最初创建的名为parcel-tracking-system的文件夹下:</p><pre class="lh li lj lk fd ll lm ln lo aw lp bi"><span id="e972" class="lq kf hi lm b fi lr ls l lt lu">npx create-react-app client</span></pre><p id="61d6" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">稍后，在客户端文件夹下，运行此命令以安装<a class="ae kc" href="http://socket.io/" rel="noopener ugc nofollow" target="_blank">socket . io</a>-客户端库:</p><pre class="lh li lj lk fd ll lm ln lo aw lp bi"><span id="3f60" class="lq kf hi lm b fi lr ls l lt lu">yarn add socket.io-client</span></pre><p id="7be9" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">安装过程结束后，转到客户端文件夹中src文件夹下的。在这里，创建一个名为socket.js的文件，并在其中写下以下几行:</p><pre class="lh li lj lk fd ll lm ln lo aw lp bi"><span id="e07c" class="lq kf hi lm b fi lr ls l lt lu">//socket.js</span><span id="bf41" class="lq kf hi lm b fi ly ls l lt lu">import socketIOClient from "socket.io-client";            <br/>const ENDPOINT = "http://127.0.0.1:8001";            </span><span id="a1fb" class="lq kf hi lm b fi ly ls l lt lu">const socket = socketIOClient(ENDPOINT);            </span><span id="ddcc" class="lq kf hi lm b fi ly ls l lt lu">export default socket;</span></pre><p id="72d3" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">创建sokcet.js后，在同一个目录中打开App.js，并对其进行如下修改:</p><pre class="lh li lj lk fd ll lm ln lo aw lp bi"><span id="1b33" class="lq kf hi lm b fi lr ls l lt lu">//App.js</span><span id="c70a" class="lq kf hi lm b fi ly ls l lt lu">import React from "react";            <br/>import socket from "./socket";            </span><span id="873a" class="lq kf hi lm b fi ly ls l lt lu">function App() {              <br/>    const [parcels, setParcel] = React.useState([{}]);              <br/>    React.useEffect(() =&gt; {                <br/>        socket.on("parcel", (data) =&gt; setParcel(data));                <br/>    });                <br/>    return (                  <br/>        &lt;div&gt;                  <br/>            {parcels.map((parcel) =&gt; (                    <br/>            &lt;&gt;                    <br/>                &lt;div&gt;ID: {parcel._id}&lt;/div&gt;                    <br/>                &lt;div&gt;Name: {parcel.name}&lt;/div&gt;                    <br/>                &lt;div&gt;Status: {parcel.status}&lt;/div&gt;                    <br/>                &lt;br&gt;&lt;/br&gt;                    <br/>            &lt;/&gt;                    <br/>        ))}                    <br/>        &lt;/div&gt;                    <br/>    );                    <br/>}            </span><span id="2780" class="lq kf hi lm b fi ly ls l lt lu">export default App;</span></pre><p id="7a32" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">要运行React应用程序，请在终端的客户端目录下运行以下命令:</p><pre class="lh li lj lk fd ll lm ln lo aw lp bi"><span id="4d3e" class="lq kf hi lm b fi lr ls l lt lu">yarn start</span></pre><p id="57be" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在自动打开的页面中，您应该会看到MongoDB中的记录。要添加新记录并进行更新，请分别打开以下链接:</p><ul class=""><li id="e13a" class="jo jp hi is b it iu ix iy jb jq jf jr jj js jn jt ju jv jw bi translated"><a class="ae kc" href="http://localhost:8000/shipping/mycargo" rel="noopener ugc nofollow" target="_blank">localhost:8000/shipping/my cargo</a></li><li id="ae97" class="jo jp hi is b it jx ix jy jb jz jf ka jj kb jn jt ju jv jw bi translated"><a class="ae kc" href="http://localhost:8000/onroad/mycargo" rel="noopener ugc nofollow" target="_blank">localhost:8000/on road/my cargo</a></li><li id="fa7a" class="jo jp hi is b it jx ix jy jb jz jf ka jj kb jn jt ju jv jw bi translated"><a class="ae kc" href="http://localhost:8000/delivered/mycargo" rel="noopener ugc nofollow" target="_blank">localhost:8000/delivered/my cargo</a></li></ul><p id="3970" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如果你每次点击都能看到MongoDB的变化，那么恭喜你，你有一点服务了！</p><h1 id="721b" class="ke kf hi bd kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb bi translated">结论</h1><p id="6af0" class="pw-post-body-paragraph iq ir hi is b it lc iv iw ix ld iz ja jb lz jd je jf ma jh ji jj mb jl jm jn hb bi translated">微服务结构在新的应用中越来越成为首选结构。软件团队正在努力将现有的整体结构迁移到微服务架构。此外，AMQP作为一种非常受欢迎的通信协议脱颖而出，并为HTTP遇到的一些问题提供了解决方案。在最终用户方面，对实时应用的兴趣和需求也在增加，web sockets为软件开发人员提供了极大的便利。掌握这些工具是一种乐趣，它们用于响应新的需求和新的技术，并且对开发者有很大的帮助。在整篇文章中，我编写了一个小服务，并试图通过总结使用这些结构和技术来提供一个大致的理解。希望对那些阅读、跟随、应用的人有所贡献。</p></div></div>    
</body>
</html>