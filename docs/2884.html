<html>
<head>
<title>Implementing a retro game over behavior in Unity</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在 Unity 中实现对行为的复古游戏</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/implementing-a-retro-game-over-behavior-in-unity-fb126c76c4bf?source=collection_archive---------23-----------------------#2021-05-22">https://medium.com/nerd-for-tech/implementing-a-retro-game-over-behavior-in-unity-fb126c76c4bf?source=collection_archive---------23-----------------------#2021-05-22</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><h2 id="789d" class="hg hh hi bd b fp hj hk hl hm hn ho dx hp translated" aria-label="kicker paragraph">统一指南</h2><div class=""/><div class=""><h2 id="d1a6" class="pw-subtitle-paragraph io hr hi bd b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf dx translated">关于如何在 Unity 中为你的游戏创建一个复古游戏行为的快速指南</h2></div><figure class="jh ji jj jk fd jl er es paragraph-image"><div role="button" tabindex="0" class="jm jn di jo bf jp"><div class="er es jg"><img src="../Images/88b5def3314f09dc0a345b9c91904b65.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*X0fbEEdxtSvqWwFYfFypZg.gif"/></div></div></figure><p id="3753" class="pw-post-body-paragraph js jt hi ju b jv jw is jx jy jz iv ka kb kc kd ke kf kg kh ki kj kk kl km kn hb bi translated"><strong class="ju hs">目标</strong>:在 Unity 的一个太空射击游戏中，创建一个游戏文本 UI 元素，并为其实现一个复古行为。</p><p id="ebc3" class="pw-post-body-paragraph js jt hi ju b jv jw is jx jy jz iv ka kb kc kd ke kf kg kh ki kj kk kl km kn hb bi translated">在上一篇文章中，我向<a class="ae ko" rel="noopener" href="/nerd-for-tech/creating-ui-elements-in-unity-a778929eacfa">展示了如何在 Unity </a>中创建 UI 元素，现在是时候实现一个复古的游戏行为，使用 UI 元素来表示游戏结束了。</p><h1 id="15ba" class="kp kq hi bd kr ks kt ku kv kw kx ky kz ix la iy lb ja lc jb ld jd le je lf lg bi translated">在文本上创建游戏</h1><p id="4845" class="pw-post-body-paragraph js jt hi ju b jv lh is jx jy li iv ka kb lj kd ke kf lk kh ki kj ll kl km kn hb bi translated">为了做到这一点，让我们为游戏 over warning 创建一个新的文本元素，并根据我们的需要修改它以适应场景:</p><div class="jh ji jj jk fd ab cb"><figure class="lm jl ln lo lp lq lr paragraph-image"><div role="button" tabindex="0" class="jm jn di jo bf jp"><img src="../Images/b310214a85823ab085c9c2b9e06809a0.png" data-original-src="https://miro.medium.com/v2/resize:fit:466/1*j_hmsUe7MVlpPrAANyNC6g.gif"/></div></figure><figure class="lm jl ls lo lp lq lr paragraph-image"><div role="button" tabindex="0" class="jm jn di jo bf jp"><img src="../Images/d4618f6729b1e37f835a35b9bc8c2107.png" data-original-src="https://miro.medium.com/v2/resize:fit:680/1*IEX80_s_aUR9hRN92YxbOg.gif"/></div></figure><figure class="lm jl lt lo lp lq lr paragraph-image"><div role="button" tabindex="0" class="jm jn di jo bf jp"><img src="../Images/442c5530cfab515594ef6a3d2c6f8994.png" data-original-src="https://miro.medium.com/v2/resize:fit:858/1*1a2nLOT-4HDG_vbnSVOQAQ.gif"/></div></figure></div><p id="323f" class="pw-post-body-paragraph js jt hi ju b jv jw is jx jy jz iv ka kb kc kd ke kf kg kh ki kj kk kl km kn hb bi translated">一旦游戏结束文本准备就绪，让我们在场景中禁用游戏对象，以确保它只在游戏结束时出现:</p><div class="jh ji jj jk fd ab cb"><figure class="lm jl lu lo lp lq lr paragraph-image"><div role="button" tabindex="0" class="jm jn di jo bf jp"><img src="../Images/ed37b262ebb8cb9bee1e71fe506169c8.png" data-original-src="https://miro.medium.com/v2/resize:fit:940/format:webp/1*CNEeubTqeQbLbPVTm4SBkw.png"/></div></figure><figure class="lm jl lv lo lp lq lr paragraph-image"><div role="button" tabindex="0" class="jm jn di jo bf jp"><img src="../Images/1cbedf4de7110e528acc89adffdb5281.png" data-original-src="https://miro.medium.com/v2/resize:fit:1062/1*07zz4IJ5MHHt9kfpnxi-Ow.gif"/></div></figure></div><h1 id="2422" class="kp kq hi bd kr ks kt ku kv kw kx ky kz ix la iy lb ja lc jb ld jd le je lf lg bi translated">在文本上显示游戏</h1><p id="8b6c" class="pw-post-body-paragraph js jt hi ju b jv lh is jx jy li iv ka kb lj kd ke kf lk kh ki kj ll kl km kn hb bi translated">然后，让我们打开 UI Manager 脚本并创建一个新变量来存储对文本元素上的游戏的引用:</p><figure class="jh ji jj jk fd jl er es paragraph-image"><div class="er es lw"><img src="../Images/cc7039ce34e6a41e80293a7ce283749d.png" data-original-src="https://miro.medium.com/v2/resize:fit:990/1*uYnXO-Ggin0MJd2CYsZBOA.gif"/></div><figcaption class="lx ly et er es lz ma bd b be z dx translated">不要忘记使用<strong class="bd kr">【serialize field】</strong>来从层次结构中拖动文本元素。</figcaption></figure><p id="536e" class="pw-post-body-paragraph js jt hi ju b jv jw is jx jy jz iv ka kb kc kd ke kf kg kh ki kj kk kl km kn hb bi translated">保存脚本，转到检查器，将文本元素拖到画布内部的 UI Manager 脚本组件中:</p><div class="jh ji jj jk fd ab cb"><figure class="lm jl mb lo lp lq lr paragraph-image"><div role="button" tabindex="0" class="jm jn di jo bf jp"><img src="../Images/79660bd1392de28fe64c9b325c5da084.png" data-original-src="https://miro.medium.com/v2/resize:fit:758/1*WZdAg1D2PdCpP0YHAIACkQ.gif"/></div></figure><figure class="lm jl mc lo lp lq lr paragraph-image"><div role="button" tabindex="0" class="jm jn di jo bf jp"><img src="../Images/eba857f5cc1174e3e3c2f026c72822e0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1244/1*GLpJ25cGGhThwNZFYj3Gog.gif"/></div></figure></div><p id="077e" class="pw-post-body-paragraph js jt hi ju b jv jw is jx jy jz iv ka kb kc kd ke kf kg kh ki kj kk kl km kn hb bi translated">然后，返回 UI 管理器脚本，创建一个新的公共函数，在播放器被破坏时调用:</p><figure class="jh ji jj jk fd jl er es paragraph-image"><div role="button" tabindex="0" class="jm jn di jo bf jp"><div class="er es md"><img src="../Images/58a0b5f6e095ae8b945a78a133fd4b1f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*iZdJtegAFdapVML37dEcFA.gif"/></div></div></figure><p id="e64c" class="pw-post-body-paragraph js jt hi ju b jv jw is jx jy jz iv ka kb kc kd ke kf kg kh ki kj kk kl km kn hb bi translated">在这里，我们将使用 gameobject 中的<strong class="ju hs"> SetActive </strong>方法激活文本元素上的游戏:</p><figure class="jh ji jj jk fd jl er es paragraph-image"><div role="button" tabindex="0" class="jm jn di jo bf jp"><div class="er es me"><img src="../Images/577fd1f6be5b333078175a0e12672faf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*IFakgUyCPiX-O_4elRxDTw.gif"/></div></div></figure><p id="ca75" class="pw-post-body-paragraph js jt hi ju b jv jw is jx jy jz iv ka kb kc kd ke kf kg kh ki kj kk kl km kn hb bi translated">现在，为了调用该函数，让我们打开玩家脚本，并确定处理飞船损坏的函数。然后，使用存储我们已经拥有的对 UI 管理器脚本的引用的变量，在玩家失去所有生命时调用<strong class="ju hs"> OnPlayerDeath </strong>函数:</p><figure class="jh ji jj jk fd jl er es paragraph-image"><div class="er es mf"><img src="../Images/12a8d6f73e496f194f4bf07c54613486.png" data-original-src="https://miro.medium.com/v2/resize:fit:1066/format:webp/1*vqx6OtfJuijc6xOiq_gbWg.png"/></div><figcaption class="lx ly et er es lz ma bd b be z dx translated">这个变量存储了对画布内部 UI 管理器脚本的引用。</figcaption></figure><figure class="jh ji jj jk fd jl er es paragraph-image"><div class="er es mg"><img src="../Images/c4e713fbb33ceae562ed41594bb20d10.png" data-original-src="https://miro.medium.com/v2/resize:fit:1360/1*CSdVxBllPini-cqY5LBG7Q.gif"/></div><figcaption class="lx ly et er es lz ma bd b be z dx translated">在从 UI 管理器调用函数之前，检查 UI 管理器引用是否不为空，以防止编译错误。</figcaption></figure><p id="af46" class="pw-post-body-paragraph js jt hi ju b jv jw is jx jy jz iv ka kb kc kd ke kf kg kh ki kj kk kl km kn hb bi translated">如果我们在 Unity 中运行游戏，我们会注意到当玩家击中 3 个敌人时，游戏结束文本元素变得活跃:</p><figure class="jh ji jj jk fd jl er es paragraph-image"><div role="button" tabindex="0" class="jm jn di jo bf jp"><div class="er es jg"><img src="../Images/d4c5046871b46b11af6c64efa2feb3e9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*c-KzBbUyT7bb6JpbM-GPZQ.gif"/></div></div></figure><h1 id="4bd9" class="kp kq hi bd kr ks kt ku kv kw kx ky kz ix la iy lb ja lc jb ld jd le je lf lg bi translated">实施追溯行为</h1><p id="c08b" class="pw-post-body-paragraph js jt hi ju b jv lh is jx jy li iv ka kb lj kd ke kf lk kh ki kj ll kl km kn hb bi translated">正如我在以前的一篇文章中提到的，我们将使用一个<a class="ae ko" href="https://fas444.medium.com/using-coroutines-in-unity-5fa1d51e0055" rel="noopener">协程</a>来实现文本元素上游戏的复古行为。让我们创建一个新的<strong class="ju hs"> IEnumerator </strong>函数来实现它:</p><figure class="jh ji jj jk fd jl er es paragraph-image"><div class="er es mh"><img src="../Images/40cbe7e4a63cbe2ccd4625f5581ee775.png" data-original-src="https://miro.medium.com/v2/resize:fit:1242/1*iCCQwLEYJlwP75t35-hKbA.gif"/></div></figure><p id="55f5" class="pw-post-body-paragraph js jt hi ju b jv jw is jx jy jz iv ka kb kc kd ke kf kg kh ki kj kk kl km kn hb bi translated">现在，在一个无限 while 循环中:</p><ol class=""><li id="d946" class="mi mj hi ju b jv jw jy jz kb mk kf ml kj mm kn mn mo mp mq bi translated">将文本元素的文本设置为“Game Over”(原始)。</li><li id="d55b" class="mi mj hi ju b jv mr jy ms kb mt kf mu kj mv kn mn mo mp mq bi translated">使用<strong class="ju hs"> yield return </strong>语句和<strong class="ju hs"> WaitForSeconds </strong>方法，在执行下一步之前等待。</li><li id="785c" class="mi mj hi ju b jv mr jy ms kb mt kf mu kj mv kn mn mo mp mq bi translated">将文本元素的文本设置为空。</li><li id="10b0" class="mi mj hi ju b jv mr jy ms kb mt kf mu kj mv kn mn mo mp mq bi translated">再次使用<strong class="ju hs"> yield return </strong>语句和<strong class="ju hs"> WaitForSeconds </strong>方法等待再次执行第一步。</li></ol><figure class="jh ji jj jk fd jl er es paragraph-image"><div role="button" tabindex="0" class="jm jn di jo bf jp"><div class="er es mw"><img src="../Images/812194d9579faecb5168f5da5593d1d6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*HDIoVJYxUhgU7DuzYm1aQQ.gif"/></div></div><figcaption class="lx ly et er es lz ma bd b be z dx translated">通过使用<strong class="bd kr"> yield return </strong>语句，我们确保函数在相同的位置重新开始执行。</figcaption></figure><p id="23d6" class="pw-post-body-paragraph js jt hi ju b jv jw is jx jy jz iv ka kb kc kd ke kf kg kh ki kj kk kl km kn hb bi translated">然后，为了执行协程，让我们在<strong class="ju hs"> OnPlayerDeath </strong>函数中激活游戏结束文本元素后，使用<strong class="ju hs"> StartCoroutine </strong>方法调用它:</p><figure class="jh ji jj jk fd jl er es paragraph-image"><div class="er es mx"><img src="../Images/c9a8dce9acc218f37acc5253bd063d5a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1358/1*r5g4rIIxBceIW-wMJ82Aow.gif"/></div></figure><p id="13c2" class="pw-post-body-paragraph js jt hi ju b jv jw is jx jy jz iv ka kb kc kd ke kf kg kh ki kj kk kl km kn hb bi translated">最后，如果我们在 Unity 中运行游戏，我们会看到，一旦玩家被摧毁，游戏结束文本元素会以复古行为显示:</p><figure class="jh ji jj jk fd jl er es paragraph-image"><div role="button" tabindex="0" class="jm jn di jo bf jp"><div class="er es jg"><img src="../Images/77479982e47948ad7711e49cfd3aa97b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*ErE-Q-lg8k2xOD3DPT617w.gif"/></div></div></figure><p id="5f98" class="pw-post-body-paragraph js jt hi ju b jv jw is jx jy jz iv ka kb kc kd ke kf kg kh ki kj kk kl km kn hb bi translated">就这样，你可以在 Unity 中为你的 UI 元素实现一个复古行为！:d .下一篇文章再见，我将展示如何在 Unity 中加载场景。</p></div><div class="ab cl my mz gp na" role="separator"><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd"/></div><div class="hb hc hd he hf"><blockquote class="nf ng nh"><p id="17b4" class="js jt ni ju b jv jw is jx jy jz iv ka nj kc kd ke nk kg kh ki nl kk kl km kn hb bi translated"><em class="hi">如果你想了解我更多，欢迎登陆</em><a class="ae ko" href="https://www.linkedin.com/in/fas444/" rel="noopener ugc nofollow" target="_blank"><strong class="ju hs"><em class="hi">LinkedIn</em></strong></a><strong class="ju hs"><em class="hi"/></strong><em class="hi">或访问我的</em> <a class="ae ko" href="http://fernandoalcasan.com/" rel="noopener ugc nofollow" target="_blank"> <strong class="ju hs"> <em class="hi">网站</em> </strong> </a> <em class="hi"> :D </em></p></blockquote></div></div>    
</body>
</html>