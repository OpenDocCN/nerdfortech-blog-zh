<html>
<head>
<title>Simplified navigation between Composables of Jetpack Compose using Simple-Stack</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用简单堆栈简化 Jetpack 组件之间的导航</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/simplified-navigation-between-composables-of-jetpack-compose-using-simple-stack-9a796a909128?source=collection_archive---------8-----------------------#2021-03-09">https://medium.com/nerd-for-tech/simplified-navigation-between-composables-of-jetpack-compose-using-simple-stack-9a796a909128?source=collection_archive---------8-----------------------#2021-03-09</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/e11a54f65298e3ccb01b8feefc04acab.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xEuOfeLkY1485zLIoXOlQA.png"/></div></div></figure><p id="c992" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">你曾经想要在两个组件之间导航吗？你希望它像你去那里一样容易吗？</p><p id="8d95" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">好消息，因为现在似乎可以用<a class="ae js" href="https://github.com/Zhuinden/simple-stack-compose-integration/" rel="noopener ugc nofollow" target="_blank"> <strong class="is hj"> <em class="jt">简单的——Stack ' s Compose integration</em></strong></a>——我现在认为是<strong class="is hj"> <em class="jt"> BETA </em> </strong>，但尽管如此，这是可能的。</p><h1 id="afce" class="ju jv hi bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">它看起来像什么</h1><h2 id="071d" class="ks jv hi bd jw kt ku kv ka kw kx ky ke jb kz la ki jf lb lc km jj ld le kq lf bi translated">初始设置和依赖关系:</h2><p id="63be" class="pw-post-body-paragraph iq ir hi is b it lg iv iw ix lh iz ja jb li jd je jf lj jh ji jj lk jl jm jn hb bi translated">首先，您将添加依赖项:</p><pre class="ll lm ln lo fd lp jr lq lr aw ls bi"><span id="e77c" class="ks jv hi jr b fi lt lu l lv lw">implementation 'com.github.Zhuinden:simple-stack:2.6.0'<br/>implementation 'com.github.Zhuinden:simple-stack-extensions:2.2.0'<br/><strong class="jr hj">implementation 'com.github.Zhuinden:simple-stack-compose-integration:0.2.0'</strong></span></pre><p id="6bc5" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">当然，您可以添加 Jitpack(不是 JCenter):</p><pre class="ll lm ln lo fd lp jr lq lr aw ls bi"><span id="cdaf" class="ks jv hi jr b fi lt lu l lv lw">// build.gradle<br/>allprojects {<br/>    repositories {<br/>        // ...<br/>        maven { url "https://jitpack.io" }<br/>    }<br/>    // ...<br/>}</span></pre><p id="6c40" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">最重要的是，你可以编写:</p><pre class="ll lm ln lo fd lp jr lq lr aw ls bi"><span id="5229" class="ks jv hi jr b fi lt lu l lv lw">compileOptions {<br/>    sourceCompatibility JavaVersion.VERSION_1_8<br/>    targetCompatibility JavaVersion.VERSION_1_8<br/>}<br/>kotlinOptions {<br/>    jvmTarget = '1.8'<br/>    <strong class="jr hj">useIR = true</strong><br/>}<br/>buildFeatures {<br/>    <strong class="jr hj">compose true</strong><br/>}</span></pre><h2 id="a778" class="ks jv hi bd jw kt ku kv ka kw kx ky ke jb kz la ki jf lb lc km jj ld le kq lf bi translated">设置</h2><p id="3fcc" class="pw-post-body-paragraph iq ir hi is b it lg iv iw ix lh iz ja jb li jd je jf lj jh ji jj lk jl jm jn hb bi translated">为了在活动中使用简单堆栈，我们一如既往地使用导航器。</p><p id="4ae7" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">合成集成仅仅是<code class="du jo jp jq jr b">StateChanger</code>的一个不同实现，以及一个助手，允许将<code class="du jo jp jq jr b">Backstack</code>作为<code class="du jo jp jq jr b">CompositionLocal</code>暴露给可合成树中的子节点。</p><pre class="ll lm ln lo fd lp jr lq lr aw ls bi"><span id="df1e" class="ks jv hi jr b fi lt lu l lv lw">class MainActivity : AppCompatActivity() {<br/>  <strong class="jr hj">private val composeStateChanger = AnimatingComposeStateChanger() </strong><br/><br/>  override fun onCreate(savedInstanceState: Bundle?) {<br/>    super.onCreate(savedInstanceState)<br/><br/>   <strong class="jr hj"> val backstack</strong> = Navigator.configure()<br/>      .setScopedServices(DefaultServiceProvider())<br/>      <strong class="jr hj">.setStateChanger(AsyncStateChanger(composeStateChanger))  </strong><br/>      .install(this, androidContentFrame, History.of(FirstKey()))<br/><br/>    setContent {<br/>      <strong class="jr hj">BackstackProvider(backstack)</strong> {<br/>        MaterialTheme {<br/>          Box(Modifier.fillMaxSize()) {<br/>            <strong class="jr hj">composeStateChanger.RenderScreen()</strong><br/>          }<br/>        }<br/>      }<br/>    }<br/>  }<br/><br/>  override fun onBackPressed() {<br/>    if (!Navigator.onBackPressed(this)) {<br/>      super.onBackPressed()<br/>    }<br/>  }<br/>}</span></pre><p id="3133" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这个<code class="du jo jp jq jr b">StateChanger</code>的实现能够在从<code class="du jo jp jq jr b">DefaultComposeKey</code>延伸的按键之间切换。</p><p id="1880" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在示例中，我通常使用以下关键超类:</p><pre class="ll lm ln lo fd lp jr lq lr aw ls bi"><span id="bb83" class="ks jv hi jr b fi lt lu l lv lw">abstract class ComposeKey : DefaultComposeKey(), Parcelable, DefaultServiceProvider.HasServices {<br/><strong class="jr hj">    override val saveableStateProviderKey: Any = this</strong><br/><br/>    override fun getScopeTag(): String = javaClass.name<br/><br/>    override fun bindServices(serviceBinder: ServiceBinder) {<br/>    }<br/>}</span></pre><p id="df9b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">请注意，使用键本身作为<code class="du jo jp jq jr b">saveableStateProviderKey</code>要求键是可打包的、不可变的，并且必须实现 equals/hashCode。</p><p id="4b63" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">一旦这个“无聊”的设置部分完成(你只需要做一次)，屏幕的定义就像这样:</p><pre class="ll lm ln lo fd lp jr lq lr aw ls bi"><span id="23f9" class="ks jv hi jr b fi lt lu l lv lw"><strong class="jr hj">@Immutable<br/>@Parcelize<br/>data</strong> <strong class="jr hj">class </strong>FirstKey(val title: String) <strong class="jr hj">: ComposeKey()</strong> {<br/>    @Composable<br/>    override fun ScreenComposable(modifier: Modifier) <strong class="jr hj">{<br/>        </strong>FirstScreen(title, modifier)<br/>    <strong class="jr hj">}<br/></strong>}</span></pre><p id="d23e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">其中<code class="du jo jp jq jr b">FirstScreen</code>是一个常规的日常组合:</p><pre class="ll lm ln lo fd lp jr lq lr aw ls bi"><span id="813f" class="ks jv hi jr b fi lt lu l lv lw">@Composable<br/>fun FirstScreen(title: String, modifier: Modifier = Modifier) {<br/>    // ...<br/>}</span></pre><h2 id="0ac2" class="ks jv hi bd jw kt ku kv ka kw kx ky ke jb kz la ki jf lb lc km jj ld le kq lf bi translated">从可组合导航到另一个可组合</h2><p id="0ba8" class="pw-post-body-paragraph iq ir hi is b it lg iv iw ix lh iz ja jb li jd je jf lj jh ji jj lk jl jm jn hb bi translated">为了在组件之间导航，我们只需要访问 backstack，并导航到另一个屏幕。简单。</p><pre class="ll lm ln lo fd lp jr lq lr aw ls bi"><span id="8050" class="ks jv hi jr b fi lt lu l lv lw">@Composable<br/>fun FirstScreen(title: String, modifier: Modifier = Modifier) {<br/><strong class="jr hj">  val backstack = LocalBackstack.current</strong></span><span id="5474" class="ks jv hi jr b fi lx lu l lv lw">  Column(<br/>    modifier = modifier.fillMaxSize(),<br/>    verticalArrangement = Arrangement.Center,<br/>    horizontalAlignment = Alignment.CenterHorizontally<br/>  ) {<br/>    Button(<br/>      onClick = {<br/>        <strong class="jr hj">backstack.goTo(SecondKey())</strong><br/>      }, <br/>      content = {<br/>        Text(title)<br/>      }<br/>    )<br/>  }<br/>}</span></pre><p id="f16a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><em class="jt">(理论上有可能定义一个顶级的</em> <code class="du jo jp jq jr b"><em class="jt">val backstack: Backstack get() = LocalBackstack.current</em></code> <em class="jt">，但是它会对名称空间造成相当大的干扰，所以没有发生。)</em></p><h2 id="7e62" class="ks jv hi bd jw kt ku kv ka kw kx ky ke jb kz la ki jf lb lc km jj ld le kq lf bi translated">跨配置更改存储数据</h2><p id="40ac" class="pw-post-body-paragraph iq ir hi is b it lg iv iw ix lh iz ja jb li jd je jf lj jh ji jj lk jl jm jn hb bi translated">为了跨配置更改存储数据，Simple-Stack 提供的方法是 ScopedServices(与这里概述的方法<a class="ae js" rel="noopener" href="/swlh/simplified-android-development-using-simple-stack-6e44ce808c35"><strong class="is hj"><em class="jt"/></strong></a>)没有特别的不同)。</p><p id="ffb6" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">举个例子，</p><pre class="ll lm ln lo fd lp jr lq lr aw ls bi"><span id="7eac" class="ks jv hi jr b fi lt lu l lv lw">@Immutable<br/>@Parcelize<br/>data class FirstKey(val title: String) : ComposeKey() {<br/>  @Composable<br/>  override fun ScreenComposable(modifier: Modifier) {<br/>    FirstScreen(title, modifier)<br/>  }</span><span id="9b82" class="ks jv hi jr b fi lx lu l lv lw"><em class="jt">  // from DefaultServiceProvider.HasServices</em><br/><strong class="jr hj">  override fun bindServices(serviceBinder: ServiceBinder) {<br/>    with(serviceBinder) {<br/>      add(<em class="jt">FirstModel</em>())<br/>    }<br/>  }</strong><br/>}</span></pre><p id="5d3e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">其中<code class="du jo jp jq jr b">FirstModel</code>只是一个普通类:</p><pre class="ll lm ln lo fd lp jr lq lr aw ls bi"><span id="2add" class="ks jv hi jr b fi lt lu l lv lw">class FirstModel {<br/><em class="jt">    // ...</em><br/>}</span></pre><p id="d107" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">并且为了简化对<code class="du jo jp jq jr b">remember { backstack.lookup&lt;FirstModel&gt;() }</code>的调用，提供了名为<code class="du jo jp jq jr b">rememberService&lt;T&gt;</code>的函数。</p><pre class="ll lm ln lo fd lp jr lq lr aw ls bi"><span id="db87" class="ks jv hi jr b fi lt lu l lv lw">@Composable<br/>fun FirstScreen(title: String, modifier: Modifier = Modifier) {<br/>  val backstack = LocalBackstack.current</span><span id="bc0a" class="ks jv hi jr b fi lx lu l lv lw"><strong class="jr hj">  val firstModel = rememberService&lt;FirstModel&gt;()</strong></span><span id="e938" class="ks jv hi jr b fi lx lu l lv lw">  // ...</span></pre><p id="6f95" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">对于所有的作用域服务，实现<code class="du jo jp jq jr b">ScopedServices.Registered</code>、<code class="du jo jp jq jr b">ScopedServices.Activated</code>、<code class="du jo jp jq jr b">ScopedServices.HandlesBack</code>和<code class="du jo jp jq jr b">Bundleable</code>的能力是拦截重要的导航相关生命周期回调(和状态持久性支持)的可能方式。</p><h1 id="d73f" class="ju jv hi bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">它是如何工作的？</h1><p id="d528" class="pw-post-body-paragraph iq ir hi is b it lg iv iw ix lh iz ja jb li jd je jf lj jh ji jj lk jl jm jn hb bi translated">可以在<a class="ae js" href="https://github.com/Zhuinden/simple-stack-compose-integration/blob/d2a6753c80e557a43a14479339f0f00ec04d74db/core/src/main/java/com/zhuinden/simplestackcomposeintegration/core/ComposeIntegrationCore.kt#L151-L268" rel="noopener ugc nofollow" target="_blank"> <strong class="is hj"> <em class="jt">这里</em> </strong> </a>找到动画状态改变器的代码(它可以根据方向进行基本的连续动画或交叉淡入淡出动画)，但这很棘手，它需要自己的文章，专门用来编写 Jetpack😅所以期待以后的某个时候。</p><figure class="ll lm ln lo fd ij er es paragraph-image"><div class="er es ly"><img src="../Images/a543ee6a2fb019be4a4003af26bdd679.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/1*DKKvJOHeIL7PxbFaJnie3A.gif"/></div></figure><h1 id="f627" class="ju jv hi bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">结论</h1><p id="ff6e" class="pw-post-body-paragraph iq ir hi is b it lg iv iw ix lh iz ja jb li jd je jf lj jh ji jj lk jl jm jn hb bi translated">总的来说，我们已经设法降低了定义可组合组件及其导航的复杂性，定义了一个简单的“key”类，该类也与其自身的可组合组件相关联。</p><pre class="ll lm ln lo fd lp jr lq lr aw ls bi"><span id="a0bb" class="ks jv hi jr b fi lt lu l lv lw">@Immutable<br/>@Parcelize<br/>data class FirstKey(val title: String) : ComposeKey() {<br/>    @Composable<br/>    override fun ScreenComposable(modifier: Modifier) {<br/>        <strong class="jr hj"><em class="jt">// ...</em></strong><br/>    }<br/>}</span></pre><p id="88bb" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">为此，我们获得了在屏幕之间自由导航、跨配置更改存储数据、跨进程死亡保持状态的能力，最重要的是:将<code class="du jo jp jq jr b">Parcelable</code>类作为参数传递，因为所有路径都是简单的不可变(parcelable)数据类。</p><p id="b177" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">然而，它是<strong class="is hj"> 0.2.0 </strong>是有原因的:它是全新的，虽然通过修改器有简单的过渡支持，但与更复杂的动画相比，它可能有点低级，所以事情可能仍然会发生变化。</p><p id="9eaa" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">此外，它目前只支持 Android，还没有桌面支持。</p><p id="81dd" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">尽管如此，我认为这是一个好的开始。源代码可以在<a class="ae js" href="https://github.com/Zhuinden/simple-stack-compose-integration" rel="noopener ugc nofollow" target="_blank"> <em class="jt">这里</em> </a>找到。</p></div></div>    
</body>
</html>