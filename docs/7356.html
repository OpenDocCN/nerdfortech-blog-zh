<html>
<head>
<title>Python Iterators and Iterables</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python 迭代器和可迭代对象</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/python-iterators-and-iterables-904abf5518e7?source=collection_archive---------1-----------------------#2022-10-06">https://medium.com/nerd-for-tech/python-iterators-and-iterables-904abf5518e7?source=collection_archive---------1-----------------------#2022-10-06</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="3e4a" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">对它们是什么、它们如何工作以及我们如何使用它们的分析。</h2></div><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ix"><img src="../Images/e17a4ff28698b23c0f0a4f98e43a4e3b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*La9bv07JxQU8Fr8P9g85Zw.jpeg"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">无限阶梯<a class="ae jn" href="https://www.flickr.com/photos/gadl/288607676/" rel="noopener ugc nofollow" target="_blank">https://www.flickr.com/photos/gadl/288607676/</a></figcaption></figure><h1 id="208e" class="jo jp hi bd jq jr js jt ju jv jw jx jy io jz ip ka ir kb is kc iu kd iv ke kf bi translated">介绍</h1><p id="8899" class="pw-post-body-paragraph kg kh hi ki b kj kk ij kl km kn im ko kp kq kr ks kt ku kv kw kx ky kz la lb hb bi translated">一个 Python <a class="ae jn" href="https://docs.python.org/3.9/glossary.html#term-iterator" rel="noopener ugc nofollow" target="_blank">迭代器</a>被定义为</p><blockquote class="lc ld le"><p id="1052" class="kg kh lf ki b kj lg ij kl km lh im ko li lj kr ks lk ll kv kw lm ln kz la lb hb bi translated"><em class="hi">代表数据流的对象。</em></p></blockquote><p id="3a57" class="pw-post-body-paragraph kg kh hi ki b kj lg ij kl km lh im ko kp lj kr ks kt ll kv kw kx ln kz la lb hb bi translated">简而言之，迭代器是一个可以迭代的对象，这意味着我们可以一个接一个地访问元素，直到一个元素都不剩。</p><p id="9fa6" class="pw-post-body-paragraph kg kh hi ki b kj lg ij kl km lh im ko kp lj kr ks kt ll kv kw kx ln kz la lb hb bi translated">例如，列表是使用循环访问的数据的顺序集合。</p><pre class="iy iz ja jb fd lo lp lq lr aw ls bi"><span id="007b" class="lt jp hi lp b fi lu lv l lw lx">my_list = ['a','b','c']<br/>for letter in my_list:<br/>  print(letter)</span></pre><p id="4458" class="pw-post-body-paragraph kg kh hi ki b kj lg ij kl km lh im ko kp lj kr ks kt ll kv kw kx ln kz la lb hb bi translated">我们可以循环的对象被定义为可迭代的。迭代器和<strong class="ki hj"> Iterables </strong>是两个主要的 Python 概念，有时会产生混淆，因为它们是严格相关的。</p><p id="5bbf" class="pw-post-body-paragraph kg kh hi ki b kj lg ij kl km lh im ko kp lj kr ks kt ll kv kw kx ln kz la lb hb bi translated">这里，我们将分析 Python 迭代器和可迭代对象的定义</p><p id="5f85" class="pw-post-body-paragraph kg kh hi ki b kj lg ij kl km lh im ko kp lj kr ks kt ll kv kw kx ln kz la lb hb bi translated"><strong class="ki hj">定义</strong>:iterable 是一个我们可以迭代的对象。</p><p id="95e3" class="pw-post-body-paragraph kg kh hi ki b kj lg ij kl km lh im ko kp lj kr ks kt ll kv kw kx ln kz la lb hb bi translated"><strong class="ki hj">定义</strong>:迭代器是可以被迭代的对象。换句话说，一个允许我们迭代一个<em class="lf">可迭代</em>对象的对象。</p><p id="2fd8" class="pw-post-body-paragraph kg kh hi ki b kj lg ij kl km lh im ko kp lj kr ks kt ll kv kw kx ln kz la lb hb bi translated">这两个定义听起来可能有点混乱，所以我将解释细节，以便有一个清晰的画面。</p><p id="503b" class="pw-post-body-paragraph kg kh hi ki b kj lg ij kl km lh im ko kp lj kr ks kt ll kv kw kx ln kz la lb hb bi translated">从技术角度来看，Python 将<strong class="ki hj">迭代器</strong>定义为实现<strong class="ki hj">迭代器协议</strong>的对象，该协议由两个方法组成:</p><p id="923b" class="pw-post-body-paragraph kg kh hi ki b kj lg ij kl km lh im ko kp lj kr ks kt ll kv kw kx ln kz la lb hb bi translated"><strong class="ki hj"> __next__ </strong>:返回容器的<strong class="ki hj">下一个</strong>项。</p><p id="3277" class="pw-post-body-paragraph kg kh hi ki b kj lg ij kl km lh im ko kp lj kr ks kt ll kv kw kx ln kz la lb hb bi translated"><strong class="ki hj"> __iter__ </strong>:返回<strong class="ki hj">迭代器</strong>本身。</p><blockquote class="lc ld le"><p id="23ce" class="kg kh lf ki b kj lg ij kl km lh im ko li lj kr ks lk ll kv kw lm ln kz la lb hb bi translated">重复调用迭代器的 __next__()方法(或将其传递给内置函数 next())会返回流中的连续项。</p><p id="f14f" class="kg kh lf ki b kj lg ij kl km lh im ko li lj kr ks lk ll kv kw lm ln kz la lb hb bi translated">当没有更多的数据可用时，将引发 StopIteration 异常。</p><p id="8167" class="kg kh lf ki b kj lg ij kl km lh im ko li lj kr ks lk ll kv kw lm ln kz la lb hb bi translated">此时，迭代器对象被耗尽，对它的 __next__()方法的任何进一步调用只是再次引发 StopIteration。</p></blockquote><p id="1bdc" class="pw-post-body-paragraph kg kh hi ki b kj lg ij kl km lh im ko kp lj kr ks kt ll kv kw kx ln kz la lb hb bi translated"><strong class="ki hj"> __next__() </strong>方法返回数据流中的<strong class="ki hj">个连续项。</strong></p><p id="6e74" class="pw-post-body-paragraph kg kh hi ki b kj lg ij kl km lh im ko kp lj kr ks kt ll kv kw kx ln kz la lb hb bi translated">重复调用<strong class="ki hj"> __next__() </strong>最终会在没有更多可用数据时引发 StopIteration 异常<strong class="ki hj">。</strong></p><p id="0a60" class="pw-post-body-paragraph kg kh hi ki b kj lg ij kl km lh im ko kp lj kr ks kt ll kv kw kx ln kz la lb hb bi translated">此时，数据序列被耗尽，对<strong class="ki hj"> __next__() </strong>的任何进一步调用都会再次引发<strong class="ki hj"> StopIteration </strong>异常。</p><h1 id="1284" class="jo jp hi bd jq jr js jt ju jv jw jx jy io jz ip ka ir kb is kc iu kd iv ke kf bi translated">Python 内置的可迭代表</h1><p id="2913" class="pw-post-body-paragraph kg kh hi ki b kj kk ij kl km kn im ko kp kq kr ks kt ku kv kw kx ky kz la lb hb bi translated">在 Python 中，有<strong class="ki hj">内置的 Iterables </strong>数据结构，例如</p><ul class=""><li id="540a" class="ly lz hi ki b kj lg km lh kp ma kt mb kx mc lb md me mf mg bi translated">列表</li><li id="9dfe" class="ly lz hi ki b kj mh km mi kp mj kt mk kx ml lb md me mf mg bi translated">元组</li><li id="fd2f" class="ly lz hi ki b kj mh km mi kp mj kt mk kx ml lb md me mf mg bi translated">用线串</li><li id="185e" class="ly lz hi ki b kj mh km mi kp mj kt mk kx ml lb md me mf mg bi translated">字典</li></ul><p id="7348" class="pw-post-body-paragraph kg kh hi ki b kj lg ij kl km lh im ko kp lj kr ks kt ll kv kw kx ln kz la lb hb bi translated">根据定义，一个<strong class="ki hj">可迭代的</strong>是一个我们可以迭代的对象。</p><p id="4207" class="pw-post-body-paragraph kg kh hi ki b kj lg ij kl km lh im ko kp lj kr ks kt ll kv kw kx ln kz la lb hb bi translated">我们使用<strong class="ki hj"> <em class="lf"> for — in </em> </strong>键迭代一个 Iterable。</p><p id="0d2b" class="pw-post-body-paragraph kg kh hi ki b kj lg ij kl km lh im ko kp lj kr ks kt ll kv kw kx ln kz la lb hb bi translated">让我们试着去理解它们是如何工作的，如何在元素间循环。</p><pre class="iy iz ja jb fd lo lp lq lr aw ls bi"><span id="f087" class="lt jp hi lp b fi lu lv l lw lx">list_of_numbers = [1,2,3,4]<br/>my_tuple = ('first','second','third')<br/>my_str = 'hello world'<br/><br/>for i in list_of_numbers:<br/>    print(i)<br/>    <br/>#Output<br/>#1<br/>#2<br/>#3<br/>#4<br/><br/>for i in my_tuple:<br/>    print(i)<br/>    <br/>#Output<br/>#first<br/>#second<br/>#third<br/><br/>for i in my_str:<br/>    print(i)<br/>    <br/>#Output<br/>#h<br/>#e<br/>#l<br/>#l<br/>#o<br/> <br/>#w<br/>#o<br/>#r<br/>#l<br/>#d</span></pre><p id="5a26" class="pw-post-body-paragraph kg kh hi ki b kj lg ij kl km lh im ko kp lj kr ks kt ll kv kw kx ln kz la lb hb bi translated">让我们更深入地看看<strong class="ki hj">可迭代列表</strong>，使用<a class="ae jn" href="https://docs.python.org/3/library/functions.html#dir" rel="noopener ugc nofollow" target="_blank"> <strong class="ki hj"> dir </strong>函数</a>来显示我们的<em class="lf"> list_of_numbers </em>中的所有方法和属性</p><pre class="iy iz ja jb fd lo lp lq lr aw ls bi"><span id="4840" class="lt jp hi lp b fi lu lv l lw lx">dir(list_of_numbers)<br/>['__add__', '__class__', '__contains__', '__delattr__', '__delitem__', <br/>'__dir__', '__doc__', '__eq__', '__format__', '__ge__', '__getattribute__', <br/>'__getitem__', '__gt__', '__hash__', '__iadd__', '__imul__', '__init__', <br/>'__init_subclass__', '__iter__', '__le__', '__len__', '__lt__', '__mul__', <br/>'__ne__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__reversed__',<br/> '__rmul__', '__setattr__', '__setitem__', '__sizeof__', '__str__', <br/> '__subclasshook__', 'append', 'clear', 'copy', 'count', 'extend', <br/> 'index', 'insert', 'pop', 'remove', 'reverse', 'sort']</span></pre><p id="93df" class="pw-post-body-paragraph kg kh hi ki b kj lg ij kl km lh im ko kp lj kr ks kt ll kv kw kx ln kz la lb hb bi translated">我们看到，其中有一个<strong class="ki hj"> __iter__() </strong>方法，用于迭代<em class="lf">list _ of _ numbers</em>的元素。我们可以通过做来看看它</p><pre class="iy iz ja jb fd lo lp lq lr aw ls bi"><span id="bf33" class="lt jp hi lp b fi lu lv l lw lx">list_of_numbers.__iter__()<br/>&lt;list_iterator object at 0x7fc9700cc220&gt;</span></pre><p id="0bb1" class="pw-post-body-paragraph kg kh hi ki b kj lg ij kl km lh im ko kp lj kr ks kt ll kv kw kx ln kz la lb hb bi translated">我们可以通过添加实现<strong class="ki hj"> __iter__() </strong>方法的对象是<strong class="ki hj">可迭代的</strong>来丰富我们之前的定义，因为我们可以在 od 上循环。</p><p id="1033" class="pw-post-body-paragraph kg kh hi ki b kj lg ij kl km lh im ko kp lj kr ks kt ll kv kw kx ln kz la lb hb bi translated">这同样适用于<em class="lf">我的元组</em>和<em class="lf">我的字符串</em></p><pre class="iy iz ja jb fd lo lp lq lr aw ls bi"><span id="f657" class="lt jp hi lp b fi lu lv l lw lx">dir(my_tuple)<br/>['__add__', '__class__', '__contains__', '__delattr__', '__dir__', <br/>'__doc__', '__eq__', '__format__', '__ge__', '__getattribute__', <br/>'__getitem__', '__getnewargs__', '__gt__', '__hash__', '__init__', <br/>'__init_subclass__', '__iter__', '__le__', '__len__', '__lt__', '__mul__', <br/>'__ne__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__rmul__', <br/>'__setattr__', '__sizeof__', '__str__', '__subclasshook__', 'count', 'index']</span><span id="8d0f" class="lt jp hi lp b fi mm lv l lw lx">dir(my_str)<br/>['__add__', '__class__', '__contains__', '__delattr__', '__dir__', '__doc__', <br/>'__eq__', '__format__', '__ge__', '__getattribute__', '__getitem__', '__getnewargs__', <br/>'__gt__', '__hash__', '__init__', '__init_subclass__', '__iter__', '__le__', <br/>'__len__', '__lt__', '__mod__', '__mul__', '__ne__', '__new__', '__reduce__', <br/>'__reduce_ex__', '__repr__', '__rmod__', '__rmul__', '__setattr__', '__sizeof__', <br/>'__str__', '__subclasshook__', 'capitalize', 'casefold', 'center', 'count', <br/>'encode', 'endswith', 'expandtabs', 'find', 'format', 'format_map', 'index', <br/>'isalnum', 'isalpha', 'isascii', 'isdecimal', 'isdigit', 'isidentifier', <br/>'islower', 'isnumeric', 'isprintable', 'isspace', 'istitle', 'isupper', <br/>'join', 'ljust', 'lower', 'lstrip', 'maketrans', 'partition', 'replace', <br/>'rfind', 'rindex', 'rjust', 'rpartition', 'rsplit', 'rstrip', 'split', <br/>'splitlines', 'startswith', 'strip', 'swapcase', 'title', 'translate', <br/>'upper', 'zfill']</span></pre><p id="b4ee" class="pw-post-body-paragraph kg kh hi ki b kj lg ij kl km lh im ko kp lj kr ks kt ll kv kw kx ln kz la lb hb bi translated">但是<strong class="ki hj"> __next__() </strong>方法在<em class="lf"> my_str </em>、<em class="lf"> my_tuple </em>和<em class="lf"> list_of_numbers </em>中没有实现。因此，根据我们的定义，我们不处理<strong class="ki hj">迭代器</strong>。</p><pre class="iy iz ja jb fd lo lp lq lr aw ls bi"><span id="277f" class="lt jp hi lp b fi lu lv l lw lx">list_of_numbers.__next__()<br/>Traceback (most recent call last):<br/>  File "&lt;stdin&gt;", line 1, in &lt;module&gt;<br/>AttributeError: 'list' object has no attribute '__next__'<br/>&gt;&gt;&gt; next(list_of_numbers)<br/>Traceback (most recent call last):<br/>  File "&lt;stdin&gt;", line 1, in &lt;module&gt;<br/>TypeError: 'list' object is not an iterator</span></pre><p id="9619" class="pw-post-body-paragraph kg kh hi ki b kj lg ij kl km lh im ko kp lj kr ks kt ll kv kw kx ln kz la lb hb bi translated">正如我们所看到的，list 对象不是迭代器，因为它没有实现<strong class="ki hj">迭代器协议，</strong>，稍后我们将了解原因。</p><p id="f1fd" class="pw-post-body-paragraph kg kh hi ki b kj lg ij kl km lh im ko kp lj kr ks kt ll kv kw kx ln kz la lb hb bi translated">然而，我们可以从我们所知道的开始，在这里施展一些魔法:</p><p id="0321" class="pw-post-body-paragraph kg kh hi ki b kj lg ij kl km lh im ko kp lj kr ks kt ll kv kw kx ln kz la lb hb bi translated">list_of_number 有<strong class="ki hj"> __iter__() </strong>方法，我们可以遍历所有的元素。</p><pre class="iy iz ja jb fd lo lp lq lr aw ls bi"><span id="ea99" class="lt jp hi lp b fi lu lv l lw lx">elem = list_of_numbers.__iter__()</span></pre><p id="4290" class="pw-post-body-paragraph kg kh hi ki b kj lg ij kl km lh im ko kp lj kr ks kt ll kv kw kx ln kz la lb hb bi translated"><strong class="ki hj"> __iter__() </strong>方法返回一个<strong class="ki hj">迭代器</strong>对象，我们知道一个 Python 迭代器实现了<strong class="ki hj"> __next__() </strong>方法</p><pre class="iy iz ja jb fd lo lp lq lr aw ls bi"><span id="59a6" class="lt jp hi lp b fi lu lv l lw lx">elem<br/>&lt;list_iterator object at 0x106a36880&gt;<br/>type(elem)<br/>&lt;class 'list_iterator'&gt;</span></pre><p id="fbd8" class="pw-post-body-paragraph kg kh hi ki b kj lg ij kl km lh im ko kp lj kr ks kt ll kv kw kx ln kz la lb hb bi translated">因此，如果<em class="lf"> elem </em>是一个 Python 迭代器，我们可以使用<strong class="ki hj"> __next()__ </strong>方法，直到<strong class="ki hj"> StopIteration </strong>异常被引发。</p><pre class="iy iz ja jb fd lo lp lq lr aw ls bi"><span id="31e2" class="lt jp hi lp b fi lu lv l lw lx">elem.__next__()<br/>1<br/>elem.__next__()<br/>2<br/>elem.__next__()<br/>3<br/>elem.__next__()<br/>4<br/>elem.__next__()<br/>Traceback (most recent call last):<br/>  File "&lt;input&gt;", line 1, in &lt;module&gt;<br/>StopIteration</span></pre><p id="dc52" class="pw-post-body-paragraph kg kh hi ki b kj lg ij kl km lh im ko kp lj kr ks kt ll kv kw kx ln kz la lb hb bi translated">一分钱一分货！<strong class="ki hj">迭代器协议</strong>得到验证。</p><p id="3765" class="pw-post-body-paragraph kg kh hi ki b kj lg ij kl km lh im ko kp lj kr ks kt ll kv kw kx ln kz la lb hb bi translated">需要记住的重要一点是，由于<strong class="ki hj">没有返回</strong>，<strong class="ki hj">的方法，我们只能用迭代器前进。</strong></p><p id="aa72" class="pw-post-body-paragraph kg kh hi ki b kj lg ij kl km lh im ko kp lj kr ks kt ll kv kw kx ln kz la lb hb bi translated">没有办法访问前面的元素，重置迭代器的唯一方法是创建一个新的迭代器，我稍后会展示。</p><p id="c1c1" class="pw-post-body-paragraph kg kh hi ki b kj lg ij kl km lh im ko kp lj kr ks kt ll kv kw kx ln kz la lb hb bi translated">当然，我们通常不会以这种方式使用迭代器，但是它让我们看到了事物内部是如何工作的。</p><h1 id="4204" class="jo jp hi bd jq jr js jt ju jv jw jx jy io jz ip ka ir kb is kc iu kd iv ke kf bi translated">Iterables 和迭代器有什么区别？</h1><p id="d106" class="pw-post-body-paragraph kg kh hi ki b kj kk ij kl km kn im ko kp kq kr ks kt ku kv kw kx ky kz la lb hb bi translated">让我们快速回顾一下到目前为止我们所学的内容。</p><p id="e150" class="pw-post-body-paragraph kg kh hi ki b kj lg ij kl km lh im ko kp lj kr ks kt ll kv kw kx ln kz la lb hb bi translated">我们已经看到<strong class="ki hj">迭代器</strong>和<strong class="ki hj">迭代器</strong>可以是不同的对象，即使它们并不总是或必须如此。</p><p id="8207" class="pw-post-body-paragraph kg kh hi ki b kj lg ij kl km lh im ko kp lj kr ks kt ll kv kw kx ln kz la lb hb bi translated">我们已经知道，如果一个对象实现了<strong class="ki hj"> __iter__() </strong>和<strong class="ki hj"> __next__() </strong>方法，就可以定义迭代器。</p><p id="765d" class="pw-post-body-paragraph kg kh hi ki b kj lg ij kl km lh im ko kp lj kr ks kt ll kv kw kx ln kz la lb hb bi translated">我们已经验证了列表实现了<strong class="ki hj"> __iter__() </strong>方法，列表可以定义为 Iterables，但是我们已经证明了列表不是迭代器。</p><pre class="iy iz ja jb fd lo lp lq lr aw ls bi"><span id="45b9" class="lt jp hi lp b fi lu lv l lw lx">next(list_of_numbers)<br/>Traceback (most recent call last):<br/>  File "&lt;input&gt;", line 1, in &lt;module&gt;<br/>TypeError: 'list' object is not an iterator<br/><br/>next(my_tuple)<br/>Traceback (most recent call last):<br/>  File "&lt;input&gt;", line 1, in &lt;module&gt;<br/>TypeError: 'tuple' object is not an iterator<br/>next(my_str)<br/>Traceback (most recent call last):<br/>  File "&lt;input&gt;", line 1, in &lt;module&gt;<br/>TypeError: 'str' object is not an iterator</span></pre><p id="dc53" class="pw-post-body-paragraph kg kh hi ki b kj lg ij kl km lh im ko kp lj kr ks kt ll kv kw kx ln kz la lb hb bi translated">所以，<em class="lf">列表</em>，<em class="lf">元组</em>，<em class="lf">字符串</em>是<strong class="ki hj">可迭代</strong>但是<strong class="ki hj">本身不是迭代器</strong>，但是我们已经看到了如何使<em class="lf"> list_of_numbers </em>成为<strong class="ki hj">迭代器</strong>。</p><p id="022f" class="pw-post-body-paragraph kg kh hi ki b kj lg ij kl km lh im ko kp lj kr ks kt ll kv kw kx ln kz la lb hb bi translated"><strong class="ki hj">迭代器</strong>和<strong class="ki hj">迭代器</strong>的概念是分开的，因为<strong class="ki hj">迭代器</strong>跟踪元素的内部位置。毕竟，<strong class="ki hj">迭代器</strong>需要维护下一个<strong class="ki hj">返回哪个元素的信息。</strong></p><p id="c939" class="pw-post-body-paragraph kg kh hi ki b kj lg ij kl km lh im ko kp lj kr ks kt ll kv kw kx ln kz la lb hb bi translated">理解这一点很重要</p><blockquote class="mn"><p id="d512" class="mo mp hi bd mq mr ms mt mu mv mw lb dx translated">如果 Iterables 要维护一个状态，我们一次只能使用一个循环。否则，其他循环会干扰第一个循环产生的状态。</p><p id="4112" class="mo mp hi bd mq mr ms mt mu mv mw lb dx translated">迭代器没有这个限制，我们总是可以返回一个新的迭代器对象。</p></blockquote><p id="fd50" class="pw-post-body-paragraph kg kh hi ki b kj mx ij kl km my im ko kp mz kr ks kt na kv kw kx nb kz la lb hb bi translated">Python <strong class="ki hj">迭代器也是一个可迭代</strong>对象，<strong class="ki hj">但不是每个可迭代对象都是迭代器</strong>。</p><p id="c946" class="pw-post-body-paragraph kg kh hi ki b kj lg ij kl km lh im ko kp lj kr ks kt ll kv kw kx ln kz la lb hb bi translated">我们已经知道列表是一个<strong class="ki hj">可迭代</strong>对象，而不是一个<strong class="ki hj">迭代器</strong>。</p><h1 id="3cee" class="jo jp hi bd jq jr js jt ju jv jw jx jy io jz ip ka ir kb is kc iu kd iv ke kf bi translated">我们如何使用迭代器</h1><p id="bb74" class="pw-post-body-paragraph kg kh hi ki b kj kk ij kl km kn im ko kp kq kr ks kt ku kv kw kx ky kz la lb hb bi translated">以下是使用迭代器的一些最常见的方法</p><h2 id="10f4" class="lt jp hi bd jq nc nd ne ju nf ng nh jy kp ni nj ka kt nk nl kc kx nm nn ke no bi translated">带有字符串和列表的 for 循环中的迭代器</h2><pre class="iy iz ja jb fd lo lp lq lr aw ls bi"><span id="1875" class="lt jp hi lp b fi lu lv l lw lx">my_str = 'I like Python'<br/>for letter in my_str:<br/>  print(letter)<br/>  <br/>  <br/>my_list = list(my_str)<br/>for letter in my_list:<br/>print(letter)<br/><br/>#Outout <br/>I<br/> <br/>l<br/>i<br/>k<br/>e<br/> <br/>P<br/>y<br/>t<br/>h<br/>o</span></pre><h2 id="72cb" class="lt jp hi bd jq nc nd ne ju nf ng nh jy kp ni nj ka kt nk nl kc kx nm nn ke no bi translated">列表理解中的迭代器</h2><pre class="iy iz ja jb fd lo lp lq lr aw ls bi"><span id="7597" class="lt jp hi lp b fi lu lv l lw lx">[letter for letter in my_list]<br/>['I', ' ', 'l', 'i', 'k', 'e', ' ', 'P', 'y', 't', 'h', 'o', 'n']</span></pre><h2 id="3422" class="lt jp hi bd jq nc nd ne ju nf ng nh jy kp ni nj ka kt nk nl kc kx nm nn ke no bi translated">具有字典键和值的迭代器</h2><pre class="iy iz ja jb fd lo lp lq lr aw ls bi"><span id="758a" class="lt jp hi lp b fi lu lv l lw lx">my_dict = {"brand": "motoguzzi","model":"850T5","year":1987}<br/>&gt;&gt;&gt; for key in my_dict:<br/>...     print(key)<br/>... <br/>brand<br/>model<br/>year</span><span id="3963" class="lt jp hi lp b fi mm lv l lw lx">for key in my_dict.keys():<br/>...     print(key)<br/>... <br/>brand<br/>model<br/>year</span><span id="5b9b" class="lt jp hi lp b fi mm lv l lw lx">for val in my_dict.values():<br/>...     print(val)<br/>... <br/>motoguzzi<br/>850T5</span></pre><h2 id="356e" class="lt jp hi bd jq nc nd ne ju nf ng nh jy kp ni nj ka kt nk nl kc kx nm nn ke no bi translated">带上下文管理器的迭代器</h2><p id="4f12" class="pw-post-body-paragraph kg kh hi ki b kj kk ij kl km kn im ko kp kq kr ks kt ku kv kw kx ky kz la lb hb bi translated">我们可以使用上下文管理器轻松地访问和打印文件的内容，因为<a class="ae jn" href="https://docs.python.org/3/library/functions.html#open" rel="noopener ugc nofollow" target="_blank"><em class="lf">open()</em></a><em class="lf"/>函数<em class="lf"> </em>返回一个<strong class="ki hj"> Iterable </strong>对象</p><pre class="iy iz ja jb fd lo lp lq lr aw ls bi"><span id="39a0" class="lt jp hi lp b fi lu lv l lw lx">with open('my_bikes.txt') as bikes:<br/>   for bike in bikes:<br/>      print(bike)</span></pre><h1 id="3482" class="jo jp hi bd jq jr js jt ju jv jw jx jy io jz ip ka ir kb is kc iu kd iv ke kf bi translated">iter 内置函数</h1><p id="0872" class="pw-post-body-paragraph kg kh hi ki b kj kk ij kl km kn im ko kp kq kr ks kt ku kv kw kx ky kz la lb hb bi translated">Python 有一个内置的 iter()函数来获取迭代器，还有一个<a class="ae jn" href="https://docs.python.org/3/library/functions.html#next" rel="noopener ugc nofollow" target="_blank"> <strong class="ki hj"> next() </strong>函数</a>来遍历它的元素。</p><p id="0477" class="pw-post-body-paragraph kg kh hi ki b kj lg ij kl km lh im ko kp lj kr ks kt ll kv kw kx ln kz la lb hb bi translated"><strong class="ki hj">迭代器</strong>可以使用<a class="ae jn" href="https://docs.python.org/3/library/functions.html#iter" rel="noopener ugc nofollow" target="_blank"> <strong class="ki hj"> iter() </strong>内置函数</a>从序列中轻松创建。</p><p id="71df" class="pw-post-body-paragraph kg kh hi ki b kj lg ij kl km lh im ko kp lj kr ks kt ll kv kw kx ln kz la lb hb bi translated">我们已经知道<strong class="ki hj"> Iterable </strong>是一个我们迭代的对象，当传递给<strong class="ki hj">ITER()</strong>函数时，它会生成一个迭代器。</p><p id="279b" class="pw-post-body-paragraph kg kh hi ki b kj lg ij kl km lh im ko kp lj kr ks kt ll kv kw kx ln kz la lb hb bi translated">🔖可以通过使用<a class="ae jn" href="https://docs.python.org/3/library/functions.html#iter" rel="noopener ugc nofollow" target="_blank">函数 iter() </a>从 iterable 创建迭代器。</p><p id="f6b1" class="pw-post-body-paragraph kg kh hi ki b kj lg ij kl km lh im ko kp lj kr ks kt ll kv kw kx ln kz la lb hb bi translated">在这个目录下，对象的类需要一个方法<strong class="ki hj"> __iter__ </strong>，它返回一个迭代器，或者一个<strong class="ki hj"> __getitem__ </strong>方法，其顺序索引从 0 开始。</p><pre class="iy iz ja jb fd lo lp lq lr aw ls bi"><span id="2340" class="lt jp hi lp b fi lu lv l lw lx">my_iterator = iter(list_of_numbers)<br/>type(my_iterator)<br/>&lt;class 'list_iterator'&gt;<br/>while my_iterator:<br/>    print(next(my_iterator))<br/>    <br/>2<br/>3<br/>4<br/>Traceback (most recent call last):<br/>  File "&lt;input&gt;", line 2, in &lt;module&gt;<br/>StopIteration</span></pre><p id="775f" class="pw-post-body-paragraph kg kh hi ki b kj lg ij kl km lh im ko kp lj kr ks kt ll kv kw kx ln kz la lb hb bi translated"><strong class="ki hj"> iter() </strong>与调用<strong class="ki hj"> __iter__() </strong>相同</p><p id="2fd1" class="pw-post-body-paragraph kg kh hi ki b kj lg ij kl km lh im ko kp lj kr ks kt ll kv kw kx ln kz la lb hb bi translated"><strong class="ki hj"> next() </strong>与调用<strong class="ki hj"> __next__() </strong>相同</p><p id="b9ce" class="pw-post-body-paragraph kg kh hi ki b kj lg ij kl km lh im ko kp lj kr ks kt ll kv kw kx ln kz la lb hb bi translated">让我们看另一个例子。语法现在应该很熟悉了，</p><pre class="iy iz ja jb fd lo lp lq lr aw ls bi"><span id="1f03" class="lt jp hi lp b fi lu lv l lw lx">&gt;&gt;&gt; x = iter(["motoguzzi","ferrari","maserati"])<br/>&gt;&gt;&gt; print(next(x))<br/>motoguzzi<br/>&gt;&gt;&gt; print(next(x))<br/>ferrari<br/>&gt;&gt;&gt; print(next(x))<br/>maserati<br/>&gt;&gt;&gt; print(next(x))<br/>Traceback (most recent call last):<br/>  File "&lt;stdin&gt;", line 1, in &lt;module&gt;<br/>StopIteration<br/>&gt;&gt;&gt;</span></pre><p id="7d88" class="pw-post-body-paragraph kg kh hi ki b kj lg ij kl km lh im ko kp lj kr ks kt ll kv kw kx ln kz la lb hb bi translated">当没有更多的项目要处理时，我们看到一个<strong class="ki hj"> StopIteration </strong>异常被引发。</p><p id="f16c" class="pw-post-body-paragraph kg kh hi ki b kj lg ij kl km lh im ko kp lj kr ks kt ll kv kw kx ln kz la lb hb bi translated">我们不得不说还有一些特殊类型的<strong class="ki hj"> Iterables </strong>，叫做生成器，我们稍后会看到。</p><h1 id="7c5f" class="jo jp hi bd jq jr js jt ju jv jw jx jy io jz ip ka ir kb is kc iu kd iv ke kf bi translated">如何构建我们的迭代器</h1><p id="cdba" class="pw-post-body-paragraph kg kh hi ki b kj kk ij kl km kn im ko kp kq kr ks kt ku kv kw kx ky kz la lb hb bi translated">一种简单的方法是把迭代器看成一个包含数据的对象。我们已经看到一个对象必须实现<strong class="ki hj"> __iter__() </strong>和<strong class="ki hj"> __next__() </strong>方法。</p><p id="0185" class="pw-post-body-paragraph kg kh hi ki b kj lg ij kl km lh im ko kp lj kr ks kt ll kv kw kx ln kz la lb hb bi translated"><strong class="ki hj"> __next__() </strong>方法是产生数据的方法。</p><p id="d516" class="pw-post-body-paragraph kg kh hi ki b kj lg ij kl km lh im ko kp lj kr ks kt ll kv kw kx ln kz la lb hb bi translated">重要提示:只要定义了<strong class="ki hj"> __iter__() </strong>，就不必定义<strong class="ki hj"> __next__() </strong>。</p><p id="81f7" class="pw-post-body-paragraph kg kh hi ki b kj lg ij kl km lh im ko kp lj kr ks kt ll kv kw kx ln kz la lb hb bi translated"><strong class="ki hj"> __iter_() </strong>方法返回迭代器对象本身。所以每个<strong class="ki hj">迭代器</strong>也是一个<strong class="ki hj">可迭代的</strong>并且可以在大多数接受其他可迭代的地方使用。</p><p id="874a" class="pw-post-body-paragraph kg kh hi ki b kj lg ij kl km lh im ko kp lj kr ks kt ll kv kw kx ln kz la lb hb bi translated">让我们构建我们的迭代器，一个计算斐波那契数列的自定义类。</p><pre class="iy iz ja jb fd lo lp lq lr aw ls bi"><span id="4ce0" class="lt jp hi lp b fi lu lv l lw lx">class FibonacciIterator:<br/>        def __init__(self, max: int):<br/>        self.max = max<br/>        self.a = 0<br/>        self.b = 1<br/>        self.counter = self.a<br/><br/>    def __iter__(self):<br/>        """<br/>        This method returns the iterator itself<br/><br/>        :return:<br/>        """<br/><br/>        return self<br/><br/>    def __next__(self):<br/>        """<br/>        This method returns the next element.<br/><br/>        :return:<br/>        """<br/><br/>        if self.counter &gt; self.max:<br/>            raise StopIteration<br/>        else:<br/>            self.a, self.b = self.b, self.a + self.b<br/>            self.counter = self.a<br/>            return self.counter<br/><br/><br/>series = FibonacciIterator(20)<br/>for num in series:<br/>  print(num)<br/>else:<br/>  print("stop")</span></pre><p id="e07a" class="pw-post-body-paragraph kg kh hi ki b kj lg ij kl km lh im ko kp lj kr ks kt ll kv kw kx ln kz la lb hb bi translated">当我们运行它时，我们得到</p><pre class="iy iz ja jb fd lo lp lq lr aw ls bi"><span id="da7b" class="lt jp hi lp b fi lu lv l lw lx">1<br/>1<br/>2<br/>3<br/>5<br/>8<br/>13<br/>21<br/>stop</span></pre><p id="ea06" class="pw-post-body-paragraph kg kh hi ki b kj lg ij kl km lh im ko kp lj kr ks kt ll kv kw kx ln kz la lb hb bi translated">这里重要的一点是，当我们打印 stop 时，StopIteration 异常被抛出，所以我们的迭代器被耗尽了。</p><p id="bfb5" class="pw-post-body-paragraph kg kh hi ki b kj lg ij kl km lh im ko kp lj kr ks kt ll kv kw kx ln kz la lb hb bi translated">如果我们运行它两次，我们将看到没有更多的元素可用。</p><pre class="iy iz ja jb fd lo lp lq lr aw ls bi"><span id="b4f9" class="lt jp hi lp b fi lu lv l lw lx">for num in series:<br/>        print(num)<br/>    else:<br/>        print("stop")<br/>    for num in series:<br/>        print(num)<br/>    else:<br/>        print("stop")</span></pre><p id="a590" class="pw-post-body-paragraph kg kh hi ki b kj lg ij kl km lh im ko kp lj kr ks kt ll kv kw kx ln kz la lb hb bi translated">我们看到在第一站被打印后，没有更多的条目需要迭代。</p><pre class="iy iz ja jb fd lo lp lq lr aw ls bi"><span id="863b" class="lt jp hi lp b fi lu lv l lw lx">1<br/>1<br/>2<br/>3<br/>5<br/>8<br/>13<br/>21<br/>stop<br/>stop</span></pre><p id="2d7a" class="pw-post-body-paragraph kg kh hi ki b kj lg ij kl km lh im ko kp lj kr ks kt ll kv kw kx ln kz la lb hb bi translated">这是因为迭代器保持状态。<strong class="ki hj">迭代器需要维护下一个返回哪个元素的信息。</strong></p><p id="2709" class="pw-post-body-paragraph kg kh hi ki b kj lg ij kl km lh im ko kp lj kr ks kt ll kv kw kx ln kz la lb hb bi translated">如果我们想要一个<strong class="ki hj">迭代器，它永远不会耗尽它的条目</strong>，我们可以在需要的时候启动它。</p><pre class="iy iz ja jb fd lo lp lq lr aw ls bi"><span id="4c44" class="lt jp hi lp b fi lu lv l lw lx">for _ in range(10):<br/>        fibonacci_series = [print(num) for num in FibonacciIterator(20)]</span></pre><p id="65e3" class="pw-post-body-paragraph kg kh hi ki b kj lg ij kl km lh im ko kp lj kr ks kt ll kv kw kx ln kz la lb hb bi translated">在这种情况下，我们在每个循环中初始化迭代器。</p><p id="3618" class="pw-post-body-paragraph kg kh hi ki b kj lg ij kl km lh im ko kp lj kr ks kt ll kv kw kx ln kz la lb hb bi translated">另一种实现方式是重构我们的迭代器<strong class="ki hj">，将迭代状态和迭代器对象</strong>分开。让我们看看我们是否能做到，为什么它会有帮助。</p><p id="b400" class="pw-post-body-paragraph kg kh hi ki b kj lg ij kl km lh im ko kp lj kr ks kt ll kv kw kx ln kz la lb hb bi translated">首先，需要提到的是，<strong class="ki hj"> __iter__() </strong>还可以返回实现<strong class="ki hj"> __next__() </strong>方法的另一个类的新实例，这意味着我们可以拥有一个只实现<strong class="ki hj"> __iter__() </strong>方法的类，并在单独的类中定义<strong class="ki hj"> __next__() </strong>方法。</p><blockquote class="lc ld le"><p id="dfc0" class="kg kh lf ki b kj lg ij kl km lh im ko li lj kr ks lk ll kv kw lm ln kz la lb hb bi translated">迭代器必须有一个 __iter__()方法返回迭代器对象本身，所以每个迭代器也是可迭代的，并且可能用在大多数接受其他可迭代的地方。</p></blockquote><p id="52e7" class="pw-post-body-paragraph kg kh hi ki b kj lg ij kl km lh im ko kp lj kr ks kt ll kv kw kx ln kz la lb hb bi translated">单独的类也可以是迭代器。在这种情况下，我们将迭代器传递给实现迭代器的类，然后接受迭代器。</p><p id="d530" class="pw-post-body-paragraph kg kh hi ki b kj lg ij kl km lh im ko kp lj kr ks kt ll kv kw kx ln kz la lb hb bi translated">让我们通过添加<em class="lf"> DotheMath </em>迭代器类来重构我们最初的例子。</p><pre class="iy iz ja jb fd lo lp lq lr aw ls bi"><span id="5c0a" class="lt jp hi lp b fi lu lv l lw lx">class DoTheMath:<br/>    def __init__(self, max: int):<br/>        self.max = max<br/>        self.a = 0<br/>        self.b = 1<br/>        self.counter = self.a<br/><br/>    def __next__(self):<br/>        """<br/>        This method returns the next element.<br/><br/>        :return:<br/>        """<br/><br/>        if self.counter &gt; self.max:<br/>            raise StopIteration<br/>        else:<br/>            self.a, self.b = self.b, self.a + self.b<br/>            self.counter = self.a<br/>            return self.counter<br/><br/>class FibonacciIterator:<br/>    def __init__(self, max: int):<br/>        self.max = max<br/><br/>    def __iter__(self):<br/>        """<br/>        This method returns the iterator itself<br/><br/>        :return:<br/>        """<br/><br/>        return DoTheMath(self.max)</span></pre><p id="ffa1" class="pw-post-body-paragraph kg kh hi ki b kj lg ij kl km lh im ko kp lj kr ks kt ll kv kw kx ln kz la lb hb bi translated">我们可以运行它，看看迭代器永远不会耗尽。</p><pre class="iy iz ja jb fd lo lp lq lr aw ls bi"><span id="5aee" class="lt jp hi lp b fi lu lv l lw lx">series = FibonacciIterator(20)<br/>for num in series:<br/>  print(num)<br/>else:<br/>  print("stop")<br/>for num in series:<br/>  print(num)<br/>else:<br/>  print("stop")<br/><br/>1<br/>1<br/>2<br/>3<br/>5<br/>8<br/>13<br/>21<br/>stop<br/>1<br/>1<br/>2<br/>3<br/>5<br/>8<br/>13<br/>21<br/>stop</span></pre><p id="f2ba" class="pw-post-body-paragraph kg kh hi ki b kj lg ij kl km lh im ko kp lj kr ks kt ll kv kw kx ln kz la lb hb bi translated">或者</p><pre class="iy iz ja jb fd lo lp lq lr aw ls bi"><span id="c2d5" class="lt jp hi lp b fi lu lv l lw lx">series = FibonacciIterator(20)<br/><br/>for _ in range(10):<br/>  fibonacci_series = [print(num) for num in series]</span></pre><p id="147c" class="pw-post-body-paragraph kg kh hi ki b kj lg ij kl km lh im ko kp lj kr ks kt ll kv kw kx ln kz la lb hb bi translated">我们现在有了一个可重用的迭代器，因为<strong class="ki hj">我们已经分离了迭代状态和迭代器对象</strong>。我们将确保我们的迭代器不会耗尽。</p><p id="394b" class="pw-post-body-paragraph kg kh hi ki b kj lg ij kl km lh im ko kp lj kr ks kt ll kv kw kx ln kz la lb hb bi translated">我们可以用最初的 FibonacciIterator 类实现同样的行为。</p><pre class="iy iz ja jb fd lo lp lq lr aw ls bi"><span id="a018" class="lt jp hi lp b fi lu lv l lw lx">run_this = iter([num for num in FibonacciIterator(10)])</span></pre><p id="5d46" class="pw-post-body-paragraph kg kh hi ki b kj lg ij kl km lh im ko kp lj kr ks kt ll kv kw kx ln kz la lb hb bi translated"><strong class="ki hj"> iter() </strong>和调用我们的类 FibonacciIterator 的<strong class="ki hj"> __iter__() </strong>方法是一样的。</p><p id="4e5b" class="pw-post-body-paragraph kg kh hi ki b kj lg ij kl km lh im ko kp lj kr ks kt ll kv kw kx ln kz la lb hb bi translated"><strong class="ki hj"> next() </strong>与调用我们的类 FibonacciIterator 的<strong class="ki hj"> __next__() </strong>方法相同。</p><h1 id="502b" class="jo jp hi bd jq jr js jt ju jv jw jx jy io jz ip ka ir kb is kc iu kd iv ke kf bi translated">结论</h1><p id="aa92" class="pw-post-body-paragraph kg kh hi ki b kj kk ij kl km kn im ko kp kq kr ks kt ku kv kw kx ky kz la lb hb bi translated">迭代器是一个可以被迭代的对象，这意味着我们可以一个接一个地访问元素，直到没有元素留下。当没有更多的元素要访问时，会引发 StopIteration 异常。<br/>我们用来迭代的工具是<em class="lf"> for-in </em>。所以迭代器和循环是兼容的。<br/>每个实现迭代器协议的对象都可以被视为迭代器。另一件值得一提的事情是迭代器在资源方面也很有效，因为一次只处理一个元素。这就是为什么提供无限元素序列的迭代器永远不会耗尽它的内存分配。<br/>可迭代对象是我们可以迭代的对象。我们使用<em class="lf"> for-in </em>来迭代一个 iterable。<br/>一个<strong class="ki hj">迭代器</strong>是一个<strong class="ki hj">可迭代</strong>，但并不是所有的<strong class="ki hj">可迭代</strong>都是<strong class="ki hj">迭代器</strong>。我们已经看到了 list 是如何实现<strong class="ki hj"> __iter__() </strong>方法却没有实现<strong class="ki hj"> __next__() </strong>。要理解的重要一点是迭代器维护状态，这意味着它们知道下一个要返回的元素(如果有的话)的位置。Iterables 不保持状态，这很好，因为如果 Iterables 要保持状态，我们一次只能使用一个循环。否则，其他循环会干扰第一个循环产生的状态。<br/>另一方面，迭代器没有这个限制，但是我们可以返回一个新的迭代器对象，创建永远不迭代的迭代器。</p></div></div>    
</body>
</html>