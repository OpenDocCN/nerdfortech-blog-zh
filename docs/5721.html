<html>
<head>
<title>React Native App Performance- PART 2</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">反应原生应用性能-第 2 部分</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/react-native-app-performance-part-2-8238ecd9645e?source=collection_archive---------0-----------------------#2021-11-07">https://medium.com/nerd-for-tech/react-native-app-performance-part-2-8238ecd9645e?source=collection_archive---------0-----------------------#2021-11-07</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/3e9e1405f4a9150be078fd1dfff4beda.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OBkIA141BUtaCblnLlYTxA.jpeg"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">图片由<a class="ae iu" href="https://pixabay.com/users/alan9187-2347/?utm_source=link-attribution&amp;amp;utm_medium=referral&amp;amp;utm_campaign=image&amp;amp;utm_content=534120" rel="noopener ugc nofollow" target="_blank"> alan9187 </a>来自<a class="ae iu" href="https://pixabay.com/?utm_source=link-attribution&amp;amp;utm_medium=referral&amp;amp;utm_campaign=image&amp;amp;utm_content=534120" rel="noopener ugc nofollow" target="_blank"> Pixabay </a></figcaption></figure><p id="8bea" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">好的性能对每个 app 都很重要。使用 React Native 时，您可能会经常遇到应用程序性能方面的问题。这就是为什么您需要在开发过程中关注 React 本机应用程序的最佳实践和性能改进，以便您可以修复这些问题，并向最终用户提供完美的体验。我将在下面分享一些最佳实践。</p><h1 id="18ac" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">避免使用 ScrollView 来呈现巨大的列表</h1><p id="f21e" class="pw-post-body-paragraph iv iw hi ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated">在 React Native 中，有几种方法可以显示带有可滚动列表的项目。在 React Native 中实现列表的最常见方式是使用<code class="du kw kx ky kz b">ScrollView</code>和<code class="du kw kx ky kz b">FlatList</code>组件。</p><p id="a878" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><code class="du kw kx ky kz b">ScrollView</code>实现起来很简单。它通常用于迭代有限数量的条目列表，如下所示。但是，它会一次渲染所有子对象。当列表中的项目数量很少时，这种方法很好。另一方面，使用数据量大的<code class="du kw kx ky kz b">ScrollView</code>会直接影响 React Native app 的整体性能。</p><pre class="la lb lc ld fd le kz lf lg aw lh bi"><span id="fa2a" class="li ju hi kz b fi lj lk l ll lm">&lt;ScrollView&gt;<br/>  {items.map(item =&gt; {<br/>    return &lt;Item key={item.name.toString()} /&gt;;<br/>  })}<br/>&lt;/ScrollView&gt;</span></pre><p id="7bbd" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">为了处理列表格式的大量数据，React Native 提供了<code class="du kw kx ky kz b">FlatList</code>。<code class="du kw kx ky kz b">FlatList</code>中的项目是惰性加载的。因此，该应用程序确实使用了过多或不一致的内存量。<code class="du kw kx ky kz b">FlatList</code>可以如下图所示使用:</p><pre class="la lb lc ld fd le kz lf lg aw lh bi"><span id="821f" class="li ju hi kz b fi lj lk l ll lm">&lt;FlatList<br/>  data={elements}<br/>  keyExtractor={item =&gt; `${items.name}`}<br/>  renderItem={({ item }) =&gt; &lt;Item key={item.name.toString()} /&gt;}<br/>/&gt;</span></pre><blockquote class="ln lo lp"><p id="d5e1" class="iv iw lq ix b iy iz ja jb jc jd je jf lr jh ji jj ls jl jm jn lt jp jq jr js hb bi translated">你也可以尝试使用<a class="ae iu" href="https://github.com/Flipkart/recyclerlistview" rel="noopener ugc nofollow" target="_blank"> recyclerlistview </a>来提升大型列表的性能</p></blockquote><h1 id="af9c" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">避免将内联函数作为道具传递</h1><p id="1733" class="pw-post-body-paragraph iv iw hi ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated">当将函数作为属性传递给组件时，避免内联传递该函数，如下所示:</p><pre class="la lb lc ld fd le kz lf lg aw lh bi"><span id="bca9" class="li ju hi kz b fi lj lk l ll lm">function Card(props) {<br/>  return(<br/>    &lt;Button title=' Make Beverage' onPress={props.onPress}/&gt;<br/>  <br/>  )<br/>}<br/>export default function Main() {<br/> <br/>  return (<br/>    &lt;View style={styles.container}&gt;<br/>      &lt;Card<br/>        onPress={()=&gt; console.log('clicked on card')}<br/>      /&gt;<br/>    &lt;/View&gt;<br/>  );<br/>}</span></pre><p id="a478" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">不推荐使用上面的方法，因为每当父元素重新呈现一个新的引用时，这个函数就会被重新创建。这意味着即使道具根本没有改变，子组件也会重新渲染。</p><p id="63d3" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">解决方案是将函数声明为类方法或函数组件中的函数，这样引用就消除了任何交叉呈现的可能性。</p><pre class="la lb lc ld fd le kz lf lg aw lh bi"><span id="adaf" class="li ju hi kz b fi lj lk l ll lm">export default function Main() {<br/>  function handleCard(){<br/>    console.log('clicked on card')<br/>  }<br/>  return (<br/>    &lt;View style={styles.container}&gt;<br/>      &lt;Card<br/>        onPress={handleCard}<br/>      /&gt;<br/>    &lt;/View&gt;<br/>  );<br/>}</span></pre><h1 id="fd6f" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">避免更新<code class="du kw kx ky kz b">componentWillUpdate</code>中的<code class="du kw kx ky kz b">state</code>或<code class="du kw kx ky kz b">dispatch</code>动作</h1><p id="62d7" class="pw-post-body-paragraph iv iw hi ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated">您应该利用<code class="du kw kx ky kz b">componentWillUpdate</code>生命周期方法来准备更新，而不是触发另一个更新。如果你的目标是设置一个状态，你应该使用<code class="du kw kx ky kz b">componentWillReceiveProps</code>来代替。为了安全起见，使用<code class="du kw kx ky kz b">componentDidUpdate</code>而不是<code class="du kw kx ky kz b">componentWillReceiveProps</code>来调度任何冗余动作。</p><h1 id="ed04" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">避免不必要的重新渲染</h1><p id="4776" class="pw-post-body-paragraph iv iw hi ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated">React Native 以类似于<code class="du kw kx ky kz b">React.js</code>的方式处理组件的渲染。因此，对 React 有效的优化技术也适用于 React 原生应用。一种优化技术是避免主线程上不必要的渲染。在功能组件中，这可以通过使用<code class="du kw kx ky kz b">React.memo()</code>来完成。</p><p id="f599" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><code class="du kw kx ky kz b">React.memo()</code>用于处理记忆化，这意味着如果任何组件不止一次地接收同一组属性，它将使用先前缓存的属性，并且只渲染一次功能组件返回的 JSX 视图，从而节省渲染开销。</p><p id="c371" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">下面显示了一个很好的例子，其中<code class="du kw kx ky kz b">Card</code>组件有一个名为<code class="du kw kx ky kz b">count</code>的状态变量，每当按钮被按下时，该变量就增加 2。当按钮被按下时，<code class="du kw kx ky kz b">CardCount</code>组件被重新渲染，即使它的文本属性不会随着每次渲染而改变。它没有对其父组件<code class="du kw kx ky kz b">Card</code>做任何特殊的事情，只是显示文本。这可以通过用<code class="du kw kx ky kz b">React.memo()</code>包装<code class="du kw kx ky kz b">CardCount</code>组件的内容来优化。</p><pre class="la lb lc ld fd le kz lf lg aw lh bi"><span id="5fca" class="li ju hi kz b fi lj lk l ll lm">// <!-- -->Card<!-- -->.js<br/>const <!-- -->Card<!-- --> = () =&gt; {<br/>  const [count, setCount] = useState(0);  return (<br/>    &lt;View style={{ flex: 1, justifyContent: 'center', alignItems: 'center' }}&gt;<br/>      &lt;Button title='Press me' onPress={() =&gt; setCount(count + 2)} /&gt;<br/>      &lt;CardCount text='text' /&gt;<br/>    &lt;/View&gt;<br/>  );<br/>};// CardCount.js<br/>const CardCount = React.Memo(({ text }) =&gt; {<br/>  return &lt;Text&gt;{text}&lt;/Text&gt;;<br/>});</span></pre><h1 id="1425" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">将 nativeDriver 与动画库一起使用</h1><p id="befd" class="pw-post-body-paragraph iv iw hi ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated">在 React 本地应用中渲染动画最流行的方法之一是使用<a class="ae iu" href="https://reactnative.dev/docs/animated.html" rel="noopener ugc nofollow" target="_blank">动画</a>库。</p><p id="e97e" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在动画在屏幕上开始之前，它使用<code class="du kw kx ky kz b">nativeDriver</code>通过本机桥发送动画。这有助于动画独立于阻塞的 JavaScript 线程执行，从而带来更流畅、更丰富的体验，而不会出现闪烁或丢帧。要将<code class="du kw kx ky kz b">nativeDriver</code>与<code class="du kw kx ky kz b">Animated</code>一起使用，可以将其值设置为<code class="du kw kx ky kz b">true</code>，如下图所示:</p><pre class="la lb lc ld fd le kz lf lg aw lh bi"><span id="1289" class="li ju hi kz b fi lj lk l ll lm">&lt;ScrollView<br/>  showsVerticalScrollIndicator={ false }<br/>  scrollEventThrottle={ 1 }<br/>  onScroll={Animated.event(<br/>    [{ nativeEvent: { contentOffset: { y: animatedValue } } }],<br/>    { useNativeDriver: false }<br/>  )}<br/>&gt;<br/>&lt;/ScrollView&gt;</span></pre><h1 id="3b2b" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">避免箭头功能</h1><p id="6e61" class="pw-post-body-paragraph iv iw hi ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated">箭头函数是浪费重渲染的常见原因。不要在函数中使用箭头函数作为回调来呈现视图。使用 arrow 函数，每个渲染都会生成该特定函数的一个新实例，因此当协调发生时，React Native 会比较差异，因为函数引用不匹配，所以它无法重用旧引用。</p><pre class="la lb lc ld fd le kz lf lg aw lh bi"><span id="9737" class="li ju hi kz b fi lj lk l ll lm">class ArrowClass extends React.Component {<br/>  // ...<br/>  addTodo() {<br/>    // ...<br/>  }<br/>  render() {<br/>    return (<br/>      &lt;View&gt;<br/>        &lt;TouchableHighlight onPress={() =&gt; this.addTodo()} /&gt;<br/>      &lt;/View&gt;<br/>    );<br/>  }<br/>}class CorrectClass extends React.Component {<br/>  // ...<br/>  addTodo = () =&gt; {<br/>    // ...<br/>  }<br/>  render() {<br/>    return (<br/>      &lt;View&gt;<br/>        &lt;TouchableHighlight onPress={this.addTodo} /&gt;<br/>      &lt;/View&gt;<br/>    );<br/>  }<br/>}</span></pre><h1 id="2509" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">利用 InteractionManager</h1><p id="abc5" class="pw-post-body-paragraph iv iw hi ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated"><a class="ae iu" href="https://reactnative.dev/docs/interactionmanager" rel="noopener ugc nofollow" target="_blank"> InteractionManager </a>允许您在任何交互或动画完成后，在 JavaScript 线程上安排任务的执行。特别是，<code class="du kw kx ky kz b">InteractionManager</code>可以让 JavaScript 动画流畅运行。</p><p id="37e5" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">可以使用以下代码安排任务在交互后运行:</p><pre class="la lb lc ld fd le kz lf lg aw lh bi"><span id="f1f3" class="li ju hi kz b fi lj lk l ll lm">InteractionManager.runAfterInteractions(() =&gt; {<br/>  // ...long-running synchronous task...<br/>});</span></pre><h1 id="618a" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">渲染时避免匿名函数</h1><p id="950a" class="pw-post-body-paragraph iv iw hi ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated">在<code class="du kw kx ky kz b">render()</code>中创建函数是一种不好的做法，会导致一些严重的性能问题。每次组件重新呈现时，都会创建一个不同的回调。对于简单和较小的组件来说，这可能不是问题，但是对于<code class="du kw kx ky kz b">PureComponents</code>和<code class="du kw kx ky kz b">React.memo()</code>或者当函数作为道具传递给子组件时，这是个大问题，这会导致不必要的重新渲染。</p><h1 id="158b" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">利用内存优化</h1><p id="d56e" class="pw-post-body-paragraph iv iw hi ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated">本机应用程序有许多进程在后台运行。你可以在 Xcode 的帮助下找到不必要的来提高性能。在 Android Studio 中，有一个 Android 设备监视器，用于监视应用程序中的漏洞。使用像<code class="du kw kx ky kz b">FlatListSectionList</code>或<code class="du kw kx ky kz b">isVirtualList</code>这样的滚动列表是提高性能的可靠方法。</p><p id="9e17" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">您可以使用以下代码来监控性能并识别内存泄漏:</p><pre class="la lb lc ld fd le kz lf lg aw lh bi"><span id="e207" class="li ju hi kz b fi lj lk l ll lm">Import PerfMonitor from ‘react-native/libraries/Performance/RCTRenderingPerf’;<br/>perfMonitor.toggle();<br/>PerfMonitor.start();<br/>SetTimeout ( () =&gt; {<br/>perfMonitor.stop();<br/>}; 2000);<br/>}; 5000);</span></pre><h1 id="5e68" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">使用 Flipper 调试速度更快</h1><p id="0eee" class="pw-post-body-paragraph iv iw hi ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated">对于每个开发人员来说，调试都是最具挑战性的任务之一。当一切看起来都正常的时候，引入一个新的特性是比较容易的，但是发现哪里出了问题是非常令人沮丧的。</p><p id="63ed" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">时间是调试过程中的一个重要因素，我们通常必须快速解决问题。然而，React Native 中的调试并不十分简单，因为您试图解决的问题可能发生在 JavaScript 或本机代码中。</p><p id="cb00" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><a class="ae iu" href="https://fbflipper.com/" rel="noopener ugc nofollow" target="_blank"> Flipper </a>是一个手机 app 的调试平台。它还广泛支持 React Native。</p><h1 id="4cb0" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">结论</h1><p id="1ca9" class="pw-post-body-paragraph iv iw hi ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated"><a class="ae iu" href="https://reactnative.dev/" rel="noopener ugc nofollow" target="_blank"> React Native </a>是一个用于创建跨平台移动应用的开源框架。JavaScript 是它的核心，它有构建界面和功能的组件。这是一个流行的高性能框架，只要您从一开始就考虑性能，它就能提供无缝的大规模体验。</p><blockquote class="ln lo lp"><p id="952c" class="iv iw lq ix b iy iz ja jb jc jd je jf lr jh ji jj ls jl jm jn lt jp jq jr js hb bi translated"><strong class="ix hj">你可以看看我以前的博客，了解应用程序性能的基本变化——</strong></p><p id="0720" class="iv iw lq ix b iy iz ja jb jc jd je jf lr jh ji jj ls jl jm jn lt jp jq jr js hb bi translated"><a class="ae iu" rel="noopener" href="/nerd-for-tech/react-native-app-performance-part-1-ea218dac23ee">https://medium . com/nerd-for-tech/react-native-app-performance-part-1-ea 218 DAC 23 ee</a></p></blockquote></div></div>    
</body>
</html>