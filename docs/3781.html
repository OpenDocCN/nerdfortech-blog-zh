<html>
<head>
<title>Implementing space shooter game features - Evasive maneuver</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">实现太空射击游戏功能-规避策略</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/implementing-space-shooter-game-features-evasive-maneuver-3dc197eb7947?source=collection_archive---------20-----------------------#2021-06-23">https://medium.com/nerd-for-tech/implementing-space-shooter-game-features-evasive-maneuver-3dc197eb7947?source=collection_archive---------20-----------------------#2021-06-23</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><h2 id="31c8" class="hg hh hi bd b fp hj hk hl hm hn ho dx hp translated" aria-label="kicker paragraph">统一指南</h2><div class=""/><div class=""><h2 id="4c94" class="pw-subtitle-paragraph io hr hi bd b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf dx translated">Unity 空间射击游戏新增功能快速回顾</h2></div><figure class="jh ji jj jk fd jl er es paragraph-image"><div role="button" tabindex="0" class="jm jn di jo bf jp"><div class="er es jg"><img src="../Images/6eb5f1d34af3bdf7dabe1d3cf2a49756.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*yBzEOwOtymgs3mC80wP_rQ.gif"/></div></div></figure><p id="b021" class="pw-post-body-paragraph js jt hi ju b jv jw is jx jy jz iv ka kb kc kd ke kf kg kh ki kj kk kl km kn hb bi translated"><strong class="ju hs">目标</strong>:在 Unity 的太空射击游戏中，为敌人实施躲避行为，以避免射击。</p><p id="eb41" class="pw-post-body-paragraph js jt hi ju b jv jw is jx jy jz iv ka kb kc kd ke kf kg kh ki kj kk kl km kn hb bi translated">在之前的帖子中，我<a class="ae ko" rel="noopener" href="/nerd-for-tech/implementing-space-shooter-game-features-attract-power-ups-83b3666daffe">在我的 Unity 太空射击游戏中为玩家实现了一种吸引能量的方式</a>。现在是时候对一些敌人实施规避行为，以避免玩家的射击。</p><h1 id="0526" class="kp kq hi bd kr ks kt ku kv kw kx ky kz ix la iy lb ja lc jb ld jd le je lf lg bi translated">识别镜头</h1><p id="cac1" class="pw-post-body-paragraph js jt hi ju b jv lh is jx jy li iv ka kb lj kd ke kf lk kh ki kj ll kl km kn hb bi translated">为了识别玩家的射击，让我们使用<strong class="ju hs"> EnemyRange </strong>类，它在<a class="ae ko" rel="noopener" href="/nerd-for-tech/implementing-space-shooter-game-features-aggressive-enemies-bc123d1e1ed1">一个旧帖子</a>中被用来检测玩家，并给敌人一个聪明的行为来尝试撞击它:</p><figure class="jh ji jj jk fd jl er es paragraph-image"><div class="er es lm"><img src="../Images/d72c6e5a89b73b4499a5b2edb7e096c3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1034/1*QlrQibBvuZt0um0xll1tDg.gif"/></div></figure><p id="d70e" class="pw-post-body-paragraph js jt hi ju b jv jw is jx jy jz iv ka kb kc kd ke kf kg kh ki kj kk kl km kn hb bi translated">在本课中，我们使用<strong class="ju hs"> OnTriggerEnter2D </strong>的方法来探测敌人周围一定范围内的对撞机。在这种情况下，我们只是检查属于标记为“<em class="ln">玩家”</em>的游戏对象的碰撞器:</p><figure class="jh ji jj jk fd jl er es paragraph-image"><div role="button" tabindex="0" class="jm jn di jo bf jp"><div class="er es lo"><img src="../Images/dc24f8b9a708372af992a60b55623001.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-cnjPslafeuFJ9D-KXK03g.png"/></div></div></figure><p id="35da" class="pw-post-body-paragraph js jt hi ju b jv jw is jx jy jz iv ka kb kc kd ke kf kg kh ki kj kk kl km kn hb bi translated">因此，为了识别玩家镜头的碰撞体，让我们加入一个新的条件，检查属于标记为“<em class="ln">玩家镜头</em>”的游戏对象的碰撞体:</p><figure class="jh ji jj jk fd jl er es paragraph-image"><div role="button" tabindex="0" class="jm jn di jo bf jp"><div class="er es lp"><img src="../Images/29a6ecdaa9623a30591e590ff0ce4b41.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*WCg58U5moJno86xsFeYLAw.gif"/></div></div></figure><h1 id="7b6c" class="kp kq hi bd kr ks kt ku kv kw kx ky kz ix la iy lb ja lc jb ld jd le je lf lg bi translated">回避行为</h1><p id="83bb" class="pw-post-body-paragraph js jt hi ju b jv lh is jx jy li iv ka kb lj kd ke kf lk kh ki kj ll kl km kn hb bi translated">让我们检查游戏的下一帧，我们有玩家向它前面的敌人射击:</p><figure class="jh ji jj jk fd jl er es paragraph-image"><div role="button" tabindex="0" class="jm jn di jo bf jp"><div class="er es jg"><img src="../Images/f88955d05dd39cd53109976abf97f3f3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HNbuy1PlkKTh3OFMpmXWeg.png"/></div></div></figure><p id="c471" class="pw-post-body-paragraph js jt hi ju b jv jw is jx jy jz iv ka kb kc kd ke kf kg kh ki kj kk kl km kn hb bi translated">如果我们转到场景视图，我们将能够看到射击碰撞器刚刚触发了<strong class="ju hs"> EnemyRange </strong>类的<strong class="ju hs">ontrigerenterra2d</strong>方法。正如你所看到的，我们在场景中有一些颜色线，这些将在我们将要做的事情中起到重要作用，以避免镜头:</p><ul class=""><li id="1e25" class="lq lr hi ju b jv jw jy jz kb ls kf lt kj lu kn lv lw lx ly bi translated">红线</li></ul><p id="c028" class="pw-post-body-paragraph js jt hi ju b jv jw is jx jy jz iv ka kb kc kd ke kf kg kh ki kj kk kl km kn hb bi translated">计算子弹进入<strong class="ju hs">敌人区域</strong>碰撞器的方向。</p><ul class=""><li id="c464" class="lq lr hi ju b jv jw jy jz kb ls kf lt kj lu kn lv lw lx ly bi translated">黄色标线</li></ul><p id="02cc" class="pw-post-body-paragraph js jt hi ju b jv jw is jx jy jz iv ka kb kc kd ke kf kg kh ki kj kk kl km kn hb bi translated">通过在红线向量和 Z 轴向量之间做叉积，我们就能得到这条线，它代表垂直方向。有了这个方向，我们可以告诉敌人在子弹击中它之前向那个方向移动。</p><ul class=""><li id="610c" class="lq lr hi ju b jv jw jy jz kb ls kf lt kj lu kn lv lw lx ly bi translated">绿线</li></ul><p id="a008" class="pw-post-body-paragraph js jt hi ju b jv jw is jx jy jz iv ka kb kc kd ke kf kg kh ki kj kk kl km kn hb bi translated">这条线代表了镜头和 Z 轴之间的另一个垂直方向，我们也可以使用这个方向来移动并尝试避免镜头。</p><div class="jh ji jj jk fd ab cb"><figure class="lz jl ma mb mc md me paragraph-image"><div role="button" tabindex="0" class="jm jn di jo bf jp"><img src="../Images/fc5eec2a3bb1ac2943e8e0f87cf8a62f.png" data-original-src="https://miro.medium.com/v2/resize:fit:706/format:webp/1*W75C4mRC_Dt5CZJmvgmpZw.png"/></div></figure><figure class="lz jl mf mb mc md me paragraph-image"><div role="button" tabindex="0" class="jm jn di jo bf jp"><img src="../Images/aafcbd82656b53cb4953e7ee8dc6d33c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1296/format:webp/1*_TcGD3wDbcMwgtxpyw7dsA.png"/></div></figure></div><p id="51af" class="pw-post-body-paragraph js jt hi ju b jv jw is jx jy jz iv ka kb kc kd ke kf kg kh ki kj kk kl km kn hb bi translated">为了更好地形象化，让我们看下一张图片:</p><figure class="jh ji jj jk fd jl er es paragraph-image"><div role="button" tabindex="0" class="jm jn di jo bf jp"><div class="er es mg"><img src="../Images/4d1192244b828c130b7312591556bc3c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*gcA4dKVP1cuCCrX9.png"/></div></div><figcaption class="mh mi et er es mj mk bd b be z dx translated">图片来自<a class="ae ko" href="https://en.wikipedia.org/wiki/Cross_product#/media/File:Right_hand_rule_cross_product.svg" rel="noopener ugc nofollow" target="_blank">维基百科</a></figcaption></figure><p id="8b30" class="pw-post-body-paragraph js jt hi ju b jv jw is jx jy jz iv ka kb kc kd ke kf kg kh ki kj kk kl km kn hb bi translated">叉积返回一个新向量，该向量垂直于所用的两个向量。在这种情况下，我们可以说向量<em class="ln"> a </em>(蓝色)<em class="ln"> </em>是 Z 轴向量(0，0，1)，向量<em class="ln"> b </em>(红色)是从射击到敌人的方向。因此，通过使用这些向量的叉积，我们获得了移动敌人的垂直方向，并试图避免射击。</p><h2 id="536c" class="ml kq hi bd kr mm mn mo kv mp mq mr kz kb ms mt lb kf mu mv ld kj mw mx lf ho bi translated">敌人靶场等级</h2><p id="e506" class="pw-post-body-paragraph js jt hi ju b jv lh is jx jy li iv ka kb lj kd ke kf lk kh ki kj ll kl km kn hb bi translated">让我们打开<strong class="ju hs"> EnemyRange </strong>类并创建一些新变量:</p><ul class=""><li id="2db5" class="lq lr hi ju b jv jw jy jz kb ls kf lt kj lu kn lv lw lx ly bi translated">回避范围</li></ul><p id="7498" class="pw-post-body-paragraph js jt hi ju b jv jw is jx jy jz iv ka kb kc kd ke kf kg kh ki kj kk kl km kn hb bi translated">该变量将存储沿垂直方向的回避机动的长度。我们可以使用<strong class="ju hs">【serialize field】</strong>通过 inspector 修改它的值。</p><ul class=""><li id="b33b" class="lq lr hi ju b jv jw jy jz kb ls kf lt kj lu kn lv lw lx ly bi translated">避免延误</li></ul><p id="cfd7" class="pw-post-body-paragraph js jt hi ju b jv jw is jx jy jz iv ka kb kc kd ke kf kg kh ki kj kk kl km kn hb bi translated">该变量将存储在进行另一次规避机动之前等待的期望延迟。</p><ul class=""><li id="f1d7" class="lq lr hi ju b jv jw jy jz kb ls kf lt kj lu kn lv lw lx ly bi translated">耽搁</li></ul><p id="e2cc" class="pw-post-body-paragraph js jt hi ju b jv jw is jx jy jz iv ka kb kc kd ke kf kg kh ki kj kk kl km kn hb bi translated">这个变量将作为协程中要返回的值，这样我们就不会因为创建新的<strong class="ju hs"> WaitForSeconds </strong>而浪费更多的内存。</p><ul class=""><li id="667c" class="lq lr hi ju b jv jw jy jz kb ls kf lt kj lu kn lv lw lx ly bi translated">避免</li></ul><p id="09c6" class="pw-post-body-paragraph js jt hi ju b jv jw is jx jy jz iv ka kb kc kd ke kf kg kh ki kj kk kl km kn hb bi translated">这个变量将指示敌人是否正在躲避射击。</p><figure class="jh ji jj jk fd jl er es paragraph-image"><div class="er es my"><img src="../Images/d023557a6408d0acf0636147e8d4d34d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1014/format:webp/1*EM5pG8CNCsluG8y3y7wdJw.png"/></div></figure><p id="c337" class="pw-post-body-paragraph js jt hi ju b jv jw is jx jy jz iv ka kb kc kd ke kf kg kh ki kj kk kl km kn hb bi translated">现在，在<strong class="ju hs"> Start </strong>方法中，让我们初始化变量，以在避免一个快照后返回各自的协程内部:</p><figure class="jh ji jj jk fd jl er es paragraph-image"><div class="er es mz"><img src="../Images/a1b3876f362bd111b6837585a7a98482.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*W0LxzxgcBwxcuo-1kbscVQ.png"/></div></figure><p id="c5c8" class="pw-post-body-paragraph js jt hi ju b jv jw is jx jy jz iv ka kb kc kd ke kf kg kh ki kj kk kl km kn hb bi translated">接下来，让我们再次使用<strong class="ju hs"> OnTriggerEnter2D </strong>方法，在这里我们检查被识别的碰撞器是否用“<em class="ln"> PlayerShot </em>标记:</p><figure class="jh ji jj jk fd jl er es paragraph-image"><div role="button" tabindex="0" class="jm jn di jo bf jp"><div class="er es na"><img src="../Images/276175e1880b68ff690556f78eae6610.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EaJ4gwlg8ykAirPFmjOWPA.png"/></div></div></figure><p id="0494" class="pw-post-body-paragraph js jt hi ju b jv jw is jx jy jz iv ka kb kc kd ke kf kg kh ki kj kk kl km kn hb bi translated">然后，为了获得垂直方向，让我们通过减去各自的位置来获得从射击到敌人的方向。之后，让我们使用<strong class="ju hs">矢量 3。Cross </strong>方法获得方向和<strong class="ju hs">向量 3.forward </strong>(代表 Z 轴(0，0，1))的叉积。最后再补充一下<strong class="ju hs">。最后归一化</strong>以获得矢量的方向:</p><figure class="jh ji jj jk fd jl er es paragraph-image"><div role="button" tabindex="0" class="jm jn di jo bf jp"><div class="er es nb"><img src="../Images/aadfd8cc493c7e4e28153eb962a5b0ac.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1sF6KTF2WDBuKWQfBq5Exw.png"/></div></div></figure><p id="0f99" class="pw-post-body-paragraph js jt hi ju b jv jw is jx jy jz iv ka kb kc kd ke kf kg kh ki kj kk kl km kn hb bi translated">现在，要选择使用垂直方向向左或向右移动，让我们通过比较<strong class="ju hs"> Random.value </strong>和返回向左或向右方向来选择一个:</p><figure class="jh ji jj jk fd jl er es paragraph-image"><div role="button" tabindex="0" class="jm jn di jo bf jp"><div class="er es nc"><img src="../Images/5d737bed7f056627a3019ea1c4b73606.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rbXkrx0MRH5qo5LRNxQDtg.png"/></div></div></figure><p id="73f5" class="pw-post-body-paragraph js jt hi ju b jv jw is jx jy jz iv ka kb kc kd ke kf kg kh ki kj kk kl km kn hb bi translated">接下来，让我们创建一个新的协程，它接收垂直方向并将其添加到敌人的位置。然后，我们返回延迟变量以在执行另一个回避策略之前等待:</p><figure class="jh ji jj jk fd jl er es paragraph-image"><div role="button" tabindex="0" class="jm jn di jo bf jp"><div class="er es nd"><img src="../Images/7ebe4d373a62b86c2ee7538d172ea747.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*elm8R44CRjhBarlRAV4qWA.png"/></div></div></figure><p id="204c" class="pw-post-body-paragraph js jt hi ju b jv jw is jx jy jz iv ka kb kc kd ke kf kg kh ki kj kk kl km kn hb bi translated">最后，在我们获得垂直方向移动后，我们称之为协程。为了避免启动其他协程，让我们检查一下敌人此刻是否没有躲避射击:</p><figure class="jh ji jj jk fd jl er es paragraph-image"><div role="button" tabindex="0" class="jm jn di jo bf jp"><div class="er es nc"><img src="../Images/c4d338ed3f52644ea98dd5238a83c101.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wLIHUITJO8msOJBri46iNg.png"/></div></div></figure><p id="cbc7" class="pw-post-body-paragraph js jt hi ju b jv jw is jx jy jz iv ka kb kc kd ke kf kg kh ki kj kk kl km kn hb bi translated">现在，如果我们在 Unity 中运行游戏，我们将能够看到敌人如预期的那样避开了射击:</p><figure class="jh ji jj jk fd jl er es paragraph-image"><div role="button" tabindex="0" class="jm jn di jo bf jp"><div class="er es jg"><img src="../Images/f979182afeeb092d5f0b800aefd7d4b2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*0OoNWQZXeQ70F-n4DjXcrw.gif"/></div></div></figure><blockquote class="ne nf ng"><p id="de64" class="js jt ln ju b jv jw is jx jy jz iv ka nh kc kd ke ni kg kh ki nj kk kl km kn hb bi translated">注意:我们也可以使用<strong class="ju hs"> Vector3。将敌人顺利转移到新方向的方法。</strong></p></blockquote><h1 id="b94e" class="kp kq hi bd kr ks kt ku kv kw kx ky kz ix la iy lb ja lc jb ld jd le je lf lg bi translated">实现行为</h1><p id="1199" class="pw-post-body-paragraph js jt hi ju b jv lh is jx jy li iv ka kb lj kd ke kf lk kh ki kj ll kl km kn hb bi translated">因为我们使用<strong class="ju hs"> EnemyRange </strong>类来实现新的回避行为，所以让我们创建两个新的 bool 变量来指示脚本是打算跟随玩家还是回避镜头:</p><figure class="jh ji jj jk fd jl er es paragraph-image"><div class="er es nk"><img src="../Images/c295e32521a48959be2e17c82c7f5af8.png" data-original-src="https://miro.medium.com/v2/resize:fit:660/format:webp/1*veVFoul2BI0Uag2C8Unw-Q.png"/></div></figure><p id="d48e" class="pw-post-body-paragraph js jt hi ju b jv jw is jx jy jz iv ka kb kc kd ke kf kg kh ki kj kk kl km kn hb bi translated">这样，我们可以在检查器中修改预设的各个属性:</p><div class="jh ji jj jk fd ab cb"><figure class="lz jl nl mb mc md me paragraph-image"><div role="button" tabindex="0" class="jm jn di jo bf jp"><img src="../Images/5a694c3d64134bb46daf1b36c08665c5.png" data-original-src="https://miro.medium.com/v2/resize:fit:886/1*LkAyL4FZv_6-0-kf9T1Mzw.gif"/></div></figure><figure class="lz jl nm mb mc md me paragraph-image"><div role="button" tabindex="0" class="jm jn di jo bf jp"><img src="../Images/a6c9851f3b89b4c76e054fce9f38e5d3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1116/1*sAiTRDa742cFxpLgkWvbKg.gif"/></div></figure></div><p id="f798" class="pw-post-body-paragraph js jt hi ju b jv jw is jx jy jz iv ka kb kc kd ke kf kg kh ki kj kk kl km kn hb bi translated">让我们制作一个新的变体预设，它有一个避免射击的脚本和一个跟随玩家的脚本:</p><div class="jh ji jj jk fd ab cb"><figure class="lz jl nn mb mc md me paragraph-image"><div role="button" tabindex="0" class="jm jn di jo bf jp"><img src="../Images/4d198e317f8fa1d2c2dc7884f0d22e88.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/1*kxrmuSEDVzlyObstX0onuQ.gif"/></div></figure><figure class="lz jl nn mb mc md me paragraph-image"><div role="button" tabindex="0" class="jm jn di jo bf jp"><img src="../Images/2d68af3fbcc6ae56e47196c29779cac2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/1*sp4f71jMgK0HD_YYzpE3Jg.gif"/></div></figure></div><p id="a31d" class="pw-post-body-paragraph js jt hi ju b jv jw is jx jy jz iv ka kb kc kd ke kf kg kh ki kj kk kl km kn hb bi translated">为了处理这些行为，我们可以在<strong class="ju hs"> OnTriggerEnter2D </strong>方法的条件中添加相应的布尔值:</p><div class="jh ji jj jk fd ab cb"><figure class="lz jl no mb mc md me paragraph-image"><div role="button" tabindex="0" class="jm jn di jo bf jp"><img src="../Images/f0e8654d44ab2d81bf1d8bf376adb9fc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1142/1*trTdlTR7rglJqdZyY-dKfw.gif"/></div></figure><figure class="lz jl np mb mc md me paragraph-image"><div role="button" tabindex="0" class="jm jn di jo bf jp"><img src="../Images/ceb563a771b94a8729946af2a567bbe0.png" data-original-src="https://miro.medium.com/v2/resize:fit:860/1*Y4wAacdeYc92mI51x5t19g.gif"/></div></figure></div><p id="b3f1" class="pw-post-body-paragraph js jt hi ju b jv jw is jx jy jz iv ka kb kc kd ke kf kg kh ki kj kk kl km kn hb bi translated">现在，为了实现 waves 中的行为，让我们打开 spawn manager 脚本并创建一个新变量来存储对新预设的引用，以避免快照:</p><figure class="jh ji jj jk fd jl er es paragraph-image"><div class="er es nq"><img src="../Images/706d9ada4c044e7c9a214b1b12af9015.png" data-original-src="https://miro.medium.com/v2/resize:fit:1074/format:webp/1*TaF2bn7vdy0N1en6-2Tmxw.png"/></div><figcaption class="mh mi et er es mj mk bd b be z dx translated">enemyAggresive 变量存储对以下行为预置的引用。</figcaption></figure><p id="71de" class="pw-post-body-paragraph js jt hi ju b jv jw is jx jy jz iv ka kb kc kd ke kf kg kh ki kj kk kl km kn hb bi translated">然后，为了表示每个敌人具有各自行为的概率，让我们使用浮点数:</p><figure class="jh ji jj jk fd jl er es paragraph-image"><div class="er es nr"><img src="../Images/4d828d3350857d24845e767c77473c22.png" data-original-src="https://miro.medium.com/v2/resize:fit:1102/format:webp/1*4wgkGiF3c9YSSWKyoRJtKA.png"/></div></figure><p id="d518" class="pw-post-body-paragraph js jt hi ju b jv jw is jx jy jz iv ka kb kc kd ke kf kg kh ki kj kk kl km kn hb bi translated">然后，在产生敌人的方法中，让我们将概率值与<strong class="ju hs"> Random.value </strong>进行比较，以决定新的躲避行为是否应该实例化为敌人的子游戏对象:</p><figure class="jh ji jj jk fd jl er es paragraph-image"><div role="button" tabindex="0" class="jm jn di jo bf jp"><div class="er es ns"><img src="../Images/50e257ae64fc9671d5c183ab6355ad62.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RfbcIAORfGIZqc15WpfezA.png"/></div></div></figure><p id="d21b" class="pw-post-body-paragraph js jt hi ju b jv jw is jx jy jz iv ka kb kc kd ke kf kg kh ki kj kk kl km kn hb bi translated">最后，在检查器中，让我们添加各自的预设并修改概率值:</p><figure class="jh ji jj jk fd jl er es paragraph-image"><div class="er es nt"><img src="../Images/9fa428e256c00e338444f2aa0b844dce.png" data-original-src="https://miro.medium.com/v2/resize:fit:1380/1*802In0hk2sjYUIzb0bkjSQ.gif"/></div></figure><p id="6c75" class="pw-post-body-paragraph js jt hi ju b jv jw is jx jy jz iv ka kb kc kd ke kf kg kh ki kj kk kl km kn hb bi translated">现在，如果我们在 Unity 中运行游戏，我们将能够看到躲避射击或试图撞击玩家的敌人:</p><figure class="jh ji jj jk fd jl er es paragraph-image"><div role="button" tabindex="0" class="jm jn di jo bf jp"><div class="er es jg"><img src="../Images/f89c162953527c705f99bdb20c4b76b6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*Pp6KuYYMbwvPhh9YkI2Xuw.gif"/></div></div></figure><p id="883c" class="pw-post-body-paragraph js jt hi ju b jv jw is jx jy jz iv ka kb kc kd ke kf kg kh ki kj kk kl km kn hb bi translated">就是这样，我们实现了一个新的行为，以避免镜头！:d .我会在下一篇文章中看到你，在那里我会展示更多添加到我的 Unity 太空射击游戏中的功能。</p></div><div class="ab cl nu nv gp nw" role="separator"><span class="nx bw bk ny nz oa"/><span class="nx bw bk ny nz oa"/><span class="nx bw bk ny nz"/></div><div class="hb hc hd he hf"><blockquote class="ne nf ng"><p id="17b4" class="js jt ln ju b jv jw is jx jy jz iv ka nh kc kd ke ni kg kh ki nj kk kl km kn hb bi translated"><em class="hi">如果你想了解我更多，欢迎登陆</em><a class="ae ko" href="https://www.linkedin.com/in/fas444/" rel="noopener ugc nofollow" target="_blank"><strong class="ju hs"><em class="hi">LinkedIn</em></strong></a><strong class="ju hs"><em class="hi"/></strong><em class="hi">或访问我的</em> <a class="ae ko" href="http://fernandoalcasan.com/" rel="noopener ugc nofollow" target="_blank"> <strong class="ju hs"> <em class="hi">网站</em> </strong> </a> <em class="hi"> :D </em></p></blockquote></div></div>    
</body>
</html>