<html>
<head>
<title>Swift Memory Management in a Nutshell</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">简而言之，快速内存管理</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/swift-memory-management-in-a-nutshell-8a12d3ef03eb?source=collection_archive---------5-----------------------#2021-06-30">https://medium.com/nerd-for-tech/swift-memory-management-in-a-nutshell-8a12d3ef03eb?source=collection_archive---------5-----------------------#2021-06-30</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div class="er es if"><img src="../Images/151eecbff8325565f33f9e6601809706.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*pNw_724sRT2ngQW74n836Q.jpeg"/></div></figure><p id="8b62" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">对一些人来说，计算机内存管理是一件很难理解的事情。但实际上，这对于程序员来说是非常基本的理解，我相信你们大多数人对此至少有一个基本的概念。在本文中，我们将讨论Swift中的内存管理。</p><h1 id="6b87" class="jk jl hi bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">值类型和引用类型</h1><p id="6824" class="pw-post-body-paragraph im in hi io b ip ki ir is it kj iv iw ix kk iz ja jb kl jd je jf km jh ji jj hb bi translated">每个编程语言里总有这两个，<strong class="io hj">值类型</strong>和<strong class="io hj">引用类型</strong>。两者的区别只是包含它的变量的值。具有<strong class="io hj">值类型</strong>的变量将总是存储实际值，另一方面，具有<strong class="io hj">引用类型</strong>的变量将总是存储实际值的地址或位置。</p><figure class="ko kp kq kr fd ij er es paragraph-image"><div class="er es kn"><img src="../Images/c8d57c7202c8dc2d6400979857d378c3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1044/format:webp/1*HvZ4AXUjrcC7rS-LycooTA.png"/></div></figure><p id="2dce" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">在Swift编程语言中，<strong class="io hj">值类型</strong>由<strong class="io hj"> Int </strong>、<strong class="io hj"> Double </strong>、<strong class="io hj"> Float </strong>、<strong class="io hj"> Bool </strong>、<strong class="io hj"> Tuple </strong>或任意一种<strong class="io hj"> struct </strong>类型组成。<strong class="io hj">参考型</strong>由<strong class="io hj">闭合型</strong>组成，或任一<strong class="io hj">类</strong>型。</p><p id="e7f4" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">由于<strong class="io hj">值类型</strong>将总是存储实际值，每个涉及到<strong class="io hj">值类型</strong>的赋值将总是创建一个新的要传递的实例。对于<strong class="io hj">引用类型</strong>，只有在初始化时才会创建一个新实例。当将<strong class="io hj">引用类型</strong>的变量赋给另一个时，它将只是传递一个实际实例的地址。</p><p id="63cd" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">想象一下<strong class="io hj">参考型号</strong>就像遥控器和电视一样。变量是远程的，实例是电视。地址就是电视所在的地方。因此，创建一个新变量就相当于购买一个新遥控器。创建一个新实例就像买一台新电视一样。</p><figure class="ko kp kq kr fd ij er es paragraph-image"><div class="er es ks"><img src="../Images/b62cd3e54a2aa59809b5f506c05f27fc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/1*mX4ymhBGCihcS0rqrEYsJg.jpeg"/></div></figure><p id="6664" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">让我们在操场上做一个小实验:</p><figure class="ko kp kq kr fd ij"><div class="bz dy l di"><div class="kt ku l"/></div></figure><p id="8e1b" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">如上所述，当“<strong class="io hj"> <em class="kv"> ref.number </em> </strong>”赋值时，它会将值直接赋值给<strong class="io hj"> MyClass </strong> <strong class="io hj">实例</strong>，该实例也被<strong class="io hj"> refType </strong>变量引用。另一方面，当<strong class="io hj"> val </strong>被赋予<strong class="io hj"> valType </strong>时，该值被复制到<strong class="io hj"> val </strong>中，从而创建了<strong class="io hj"> MyStruct </strong>的两个实例，因此<strong class="io hj"> val </strong>和<strong class="io hj"> valType </strong>是两个不同的实例。</p><p id="b0fe" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">使用电视类比，<strong class="io hj"> refType </strong>是指向<strong class="io hj"> MyClass </strong>电视的遥控器。当我们创建<strong class="io hj"> ref </strong>时，我们只是想添加一个指向同一台电视的新遥控器。因此，无论我们对<strong class="io hj"> ref </strong>或<strong class="io hj"> refType </strong>做了什么，只要它指向同一个电视，它就会一直影响同一个电视。</p><h1 id="6335" class="jk jl hi bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">堆栈和堆</h1><p id="bd65" class="pw-post-body-paragraph im in hi io b ip ki ir is it kj iv iw ix kk iz ja jb kl jd je jf km jh ji jj hb bi translated">让我们更深入地回忆一下。一般在Swift或者其他编程语言中，内存中有两个地方存储值，分别是<strong class="io hj"> Stack </strong>和<strong class="io hj"> Heap </strong>。</p><p id="648d" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">顾名思义，<strong class="io hj"> Stack </strong>总是以堆栈的方式将值存储在内存中，所以新的分配总是放在前一个的上面，并且总是从顶部释放，或者通常称为<strong class="io hj"> LIFO </strong> ( <em class="kv">后进先出</em>)。</p><p id="2c93" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">堆做的事情不同，如果空间足够并且已经被应用程序保留，它将把值存储在任何地方。无论谁先谁后，它都会根据需要释放任何价值。</p><p id="ab0f" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">每当我们在代码上声明一个变量，并且该代码在运行时被执行，该变量将总是被存储在<strong class="io hj">堆栈</strong>中，并且只有当执行到达返回或作用域(function，if-else等)的末尾时才会被释放。).另一方面，<strong class="io hj">引用类型</strong>实例及其所有属性将始终存储在<strong class="io hj">堆</strong>中。</p><p id="7f03" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">变量将总是存储在它们被创建的地方。当在函数或任何执行作用域上声明它时，它将一直驻留在那里，并在作用域完成后被释放。如果它被声明为实例的属性，它将一直存在于它的父实例中，直到被释放。</p><p id="131d" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><strong class="io hj">值类型实例</strong>将一直存在于变量所在的位置。但是<strong class="io hj">引用类型实例</strong>会一直活在<strong class="io hj">堆</strong>里。因此，如果<strong class="io hj">引用类型</strong>实例包含<strong class="io hj">值类型属性</strong>，这些属性将存在于其父实例内的<strong class="io hj">堆</strong>中，直到被释放。但是如果<strong class="io hj">值类型实例</strong>在<strong class="io hj">栈</strong>上被创建，它将一直存在直到被释放。</p><p id="d1f7" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">为了更好地理解它，让我们看看下面这段代码:</p><figure class="ko kp kq kr fd ij"><div class="bz dy l di"><div class="kt ku l"/></div></figure><p id="2c10" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">这些代码可以通过下面的动画进行可视化:</p><figure class="ko kp kq kr fd ij er es paragraph-image"><div class="er es kw"><img src="../Images/09666b517c47f2160f33cf6eb9fef6aa.png" data-original-src="https://miro.medium.com/v2/resize:fit:844/1*dP7_HhKAoZ0zbFbi4Nw4lQ.gif"/></div></figure><p id="ae95" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">所以，当<strong class="io hj">函数栈</strong>被执行时，它会将<strong class="io hj"> ref1 </strong>存储在栈中。然后它会创建一个<strong class="io hj"> MyObject </strong>的实例并放入堆中，然后它的地址会被<strong class="io hj"> ref1 </strong>存储在堆栈中。当<strong class="io hj"> if scope </strong>被执行时，它会将<strong class="io hj"> ref2 </strong>放在堆栈中<strong class="io hj"> ref1 </strong>的顶部。然后<strong class="io hj"> ref1 </strong>的值将被复制到<strong class="io hj"> ref2 </strong>，它是<strong class="io hj"> MyObject实例</strong>的地址，所以我们可以说<strong class="io hj"> ref1 </strong>和<strong class="io hj"> ref2 </strong>引用的是同一个实例。当<strong class="io hj">作用域</strong>结束时<strong class="io hj"> ref2 </strong>将从<strong class="io hj">堆栈</strong>中释放，当<strong class="io hj">功能作用域</strong>结束时<strong class="io hj"> ref1 </strong>也将被释放。当没有人引用<strong class="io hj"> MyObject实例</strong>时，它将从<strong class="io hj">堆</strong>中释放。</p><h1 id="b49d" class="jk jl hi bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">自动引用计数</h1><p id="c02a" class="pw-post-body-paragraph im in hi io b ip ki ir is it kj iv iw ix kk iz ja jb kl jd je jf km jh ji jj hb bi translated">在<strong class="io hj">栈</strong>的情况下，何时以及如何释放内存的机制非常清楚，但是在<strong class="io hj">堆</strong>的情况下却不是这样。实际上，何时以及如何释放<strong class="io hj">堆</strong>上的内存在以前是个大问题。如果不释放<strong class="io hj">堆</strong>上的实例，它将消耗太多空间。Swift编程语言使用Objective-C上已经存在的解决方案来解决这个问题，它被称为<strong class="io hj">自动引用计数</strong>，或<strong class="io hj"> ARC </strong>。</p><p id="005b" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><strong class="io hj"> ARC </strong>只是一个计数器，一个花哨的计数器，它计算引用每个实例的变量的数量。当一个新的变量出现并引用一个实例时，<strong class="io hj"> ARC </strong>会将该实例的计数器加1。当变量被释放时，它会将计数器减1。当计数器达到零时，实例将从<strong class="io hj">堆</strong>中释放。非常简单和强大！</p><p id="2d7c" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">让我们检查下面的代码:</p><figure class="ko kp kq kr fd ij"><div class="bz dy l di"><div class="kt ku l"/></div></figure><p id="630a" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">这是无用的代码，但我想给你们展示的是这段代码的可视化表示:</p><figure class="ko kp kq kr fd ij er es paragraph-image"><div class="er es kx"><img src="../Images/9b4bf18de4ee7d8329b072310db95cb9.png" data-original-src="https://miro.medium.com/v2/resize:fit:724/1*sUbx198LIU8TzWO1sUyZGQ.gif"/></div></figure><p id="4168" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">在动画中，可以清楚地看到，每当出现一个新变量来引用同一个实例时，该实例的计数器就会加1。当变量引用其他东西时，计数器将减1。当计数器达到零时，对象将被释放。这就是Swift管理<strong class="io hj">堆</strong>的方式。</p><h1 id="8a32" class="jk jl hi bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">保留周期</h1><p id="7488" class="pw-post-body-paragraph im in hi io b ip ki ir is it kj iv iw ix kk iz ja jb kl jd je jf km jh ji jj hb bi translated"><strong class="io hj">弧</strong>也不是没有问题。使用<strong class="io hj">电弧</strong>时的一个问题叫做<strong class="io hj">保持周期</strong>。这是<strong class="io hj">弧</strong>计数器永远不会达到零的情况。这种情况怎么会发生？这个机制看起来很强大，对吧？</p><p id="fb00" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">让我们看看这段代码:</p><figure class="ko kp kq kr fd ij"><div class="bz dy l di"><div class="kt ku l"/></div></figure><p id="010f" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">看起来不错，对吧？您是否意识到<strong class="io hj">对象1 </strong>和<strong class="io hj">对象2 </strong>是相互引用的？可以这样形象化:</p><figure class="ko kp kq kr fd ij er es paragraph-image"><div class="er es ky"><img src="../Images/77a70aafbc2328d7a964cbdf3f352c3a.png" data-original-src="https://miro.medium.com/v2/resize:fit:964/format:webp/1*nVfiOS-K8Ope6Payzq72IA.png"/></div></figure><p id="d891" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">无论执行过程中发生什么，两个实例计数器都不会达到零，除非手动指定为null。这种情况被称为<strong class="io hj">保持周期</strong>。Swift有针对这些情况的解决方案，通过使用一个<strong class="io hj">弱</strong>或<strong class="io hj">无主</strong>变量。</p><h1 id="c989" class="jk jl hi bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">弱无主变量</h1><p id="484b" class="pw-post-body-paragraph im in hi io b ip ki ir is it kj iv iw ix kk iz ja jb kl jd je jf km jh ji jj hb bi translated"><strong class="io hj">弱变量</strong>是一个不会增加<strong class="io hj">弧</strong>计数器的变量，例如分配给它的计数器。因此，如果有三个变量引用同一个实例，并且其中一个是<strong class="io hj">弱</strong>，那么该实例的计数器将是2。当另外两个变量被释放时，实例也会被释放，从而使<strong class="io hj">弱变量</strong>自动指向空。这就是为什么弱应该是可选类型。</p><p id="6020" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">为了更好地理解弱变量是如何工作的，让我们看看下面这段代码:</p><figure class="ko kp kq kr fd ij"><div class="bz dy l di"><div class="kt ku l"/></div></figure><p id="c0f0" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">如果没有其他<strong class="io hj">强变量</strong>引用它的实例，ref3 变量将自动为空。</p><p id="9656" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><strong class="io hj">无主</strong>怎么办？它和weak是一样的，但是它不是可选的，如果它的值已经为null，它会抛出一个不可捕获的错误，因为它试图强制取消装箱。</p><h1 id="1cd4" class="jk jl hi bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">解决方案</h1><p id="cd37" class="pw-post-body-paragraph im in hi io b ip ki ir is it kj iv iw ix kk iz ja jb kl jd je jf km jh ji jj hb bi translated">让我们回到保留周期的例子。了解了弱变量和无主变量之后，我们能为它创建一个优雅的解决方案吗？解决方案很简单，只需使其中一个引用变量变弱:</p><figure class="ko kp kq kr fd ij"><div class="bz dy l di"><div class="kt ku l"/></div></figure><p id="e4c2" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">这不会造成内存泄漏，因为<strong class="io hj"> object2 </strong>现在很弱，因此<strong class="io hj"> ARC </strong>计数器现在可以达到零。使用这种可视化表示可以更好地解释这一点:</p><figure class="ko kp kq kr fd ij er es paragraph-image"><div class="er es kz"><img src="../Images/ea1a399cbe38db5c7845b81854097b93.png" data-original-src="https://miro.medium.com/v2/resize:fit:1004/1*c5jQZyQPPbCiAv5mLU31yQ.gif"/></div></figure><p id="2b89" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">现在<strong class="io hj"> ARC </strong>计数器，例如<strong class="io hj"> Object2 </strong>的计数器，在栈上的变量被释放时可以达到零。它很快会使<strong class="io hj"> Object1 </strong>实例计数器也归零，并触发<strong class="io hj"> ARC </strong>将其释放。</p><h1 id="79d6" class="jk jl hi bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">其他用途</h1><p id="81e5" class="pw-post-body-paragraph im in hi io b ip ki ir is it kj iv iw ix kk iz ja jb kl jd je jf km jh ji jj hb bi translated">弱变量可以确保实例不会被意外保留。一个最常见的用法是使用<strong class="io hj">中的<strong class="io hj">弱自我</strong>逃避关闭</strong>。它将确保自我不会被封闭所保留，并且在封闭被释放之前不会被释放。所有的<strong class="io hj">委托模式</strong>都为它们的委托属性使用了一个弱变量，因为通常情况下，实现委托的对象将委托消费者作为其属性，所以它可能会引入<strong class="io hj">保留周期</strong>问题。</p><h1 id="013e" class="jk jl hi bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">最终注释</h1><p id="8dc2" class="pw-post-body-paragraph im in hi io b ip ki ir is it kj iv iw ix kk iz ja jb kl jd je jf km jh ji jj hb bi translated">在这篇文章中可以提出一些观点:</p><ul class=""><li id="f5b9" class="la lb hi io b ip iq it iu ix lc jb ld jf le jj lf lg lh li bi translated"><strong class="io hj">值类型</strong>变量存储实际实例</li><li id="8b34" class="la lb hi io b ip lj it lk ix ll jb lm jf ln jj lf lg lh li bi translated"><strong class="io hj">引用类型</strong>变量存储实例的位置</li><li id="bd0c" class="la lb hi io b ip lj it lk ix ll jb lm jf ln jj lf lg lh li bi translated"><strong class="io hj">值类型</strong>实例存储在变量所在的位置</li><li id="e83a" class="la lb hi io b ip lj it lk ix ll jb lm jf ln jj lf lg lh li bi translated"><strong class="io hj">引用类型</strong>实例存储在堆中</li><li id="554a" class="la lb hi io b ip lj it lk ix ll jb lm jf ln jj lf lg lh li bi translated"><strong class="io hj">弧</strong>是计数实例引用变量</li><li id="e5cf" class="la lb hi io b ip lj it lk ix ll jb lm jf ln jj lf lg lh li bi translated"><strong class="io hj"> ARC </strong>将在其计数器达到0后释放一个实例</li><li id="e7b8" class="la lb hi io b ip lj it lk ix ll jb lm jf ln jj lf lg lh li bi translated"><strong class="io hj">保持循环</strong>发生在<strong class="io hj">圆弧</strong>计数器无法归零的情况下</li><li id="427d" class="la lb hi io b ip lj it lk ix ll jb lm jf ln jj lf lg lh li bi translated"><strong class="io hj">弱变量</strong>不会增加<strong class="io hj">圆弧</strong>计数器</li><li id="5c36" class="la lb hi io b ip lj it lk ix ll jb lm jf ln jj lf lg lh li bi translated">一个<strong class="io hj">弱变量</strong>可选</li><li id="5a4d" class="la lb hi io b ip lj it lk ix ll jb lm jf ln jj lf lg lh li bi translated">一个<strong class="io hj">无主变量</strong>与弱变量相同，但不是可选的</li><li id="3d17" class="la lb hi io b ip lj it lk ix ll jb lm jf ln jj lf lg lh li bi translated">一个<strong class="io hj">无主变量</strong>将强制展开可选值</li></ul><p id="69bd" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">就这些！</p><p id="cad8" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">如果你有任何意见、问题或建议，请在下面的评论区发表。</p></div></div>    
</body>
</html>