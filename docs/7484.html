<html>
<head>
<title>Database Indexing In A Nutshell</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">简而言之，数据库索引</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/database-indexing-in-a-nutshell-b525b73eadef?source=collection_archive---------2-----------------------#2022-11-14">https://medium.com/nerd-for-tech/database-indexing-in-a-nutshell-b525b73eadef?source=collection_archive---------2-----------------------#2022-11-14</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="6ad7" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">索引是一种性能调整方法，可以更快地检索记录。索引为索引列中的每个值创建一个入口点。</h2></div><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ix"><img src="../Images/a398f06980ea1d525f41361b989830a7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*gGCPNwYuLxDXV3I5"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">马库斯·温克勒在<a class="ae jn" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><p id="0d68" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><em class="kk">索引</em>是在数据库后台使用的查找表，用于加快查询速度。索引通过提供一种快速查找所请求数据的方法来增强查询。</p><p id="0dea" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">简单地说，索引是指向表中数据的指针。数据库中的索引非常类似于一本书的索引页。</p><h2 id="b9b1" class="kl km hi bd kn ko kp kq kr ks kt ku kv jx kw kx ky kb kz la lb kf lc ld le lf bi translated">Index 通过提供指向关联值的指针，帮助数据库快速找到行。</h2></div><div class="ab cl lg lh gp li" role="separator"><span class="lj bw bk lk ll lm"/><span class="lj bw bk lk ll lm"/><span class="lj bw bk lk ll"/></div><div class="hb hc hd he hf"><h2 id="8e54" class="kl km hi bd kn ko kp kq kr ks kt ku kv jx kw kx ky kb kz la lb kf lc ld le lf bi translated">为什么要索引？</h2><p id="5a38" class="pw-post-body-paragraph jo jp hi jq b jr ln ij jt ju lo im jw jx lp jz ka kb lq kd ke kf lr kh ki kj hb bi translated">当数据库表变得更大时，扫描数百万、数十亿或数万亿行，只返回两三行是一种巨大的浪费。</p><p id="1810" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">想象一下，当你的老师要求你打开第五章，并阅读该章中的某个子主题。你显然没有一页一页地滚动，以达到特定的子主题。你可以进入“索引”页面，从第五章找到特定子主题的页码，然后直接打开该页码。</p><p id="be71" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">同样，当你请求一个特定的行时，数据库使用它们的索引来查找所请求的数据，如果 DBMS 没有索引，当你请求一个特定的行时，它将按顺序进行并检查每一行；"<em class="kk">这是我需要的那一行吗？</em>”，如果是则返回，如果不是，则继续搜索直到结束。</p><p id="5409" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">索引只是一种存储在 DBMS 中的数据结构，最常见的形式是 B 树或哈希表。</p><blockquote class="ls lt lu"><p id="b049" class="jo jp kk jq b jr js ij jt ju jv im jw lv jy jz ka lw kc kd ke lx kg kh ki kj hb bi translated"><em class="hi">默认情况下，大多数 DBMS 自动在主列和唯一列上创建索引。</em></p></blockquote><p id="5e6f" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">在本文中，我们将讨论两种非常流行的索引技术。</p></div><div class="ab cl lg lh gp li" role="separator"><span class="lj bw bk lk ll lm"/><span class="lj bw bk lk ll lm"/><span class="lj bw bk lk ll"/></div><div class="hb hc hd he hf"><h1 id="1cc5" class="ly km hi bd kn lz ma mb kr mc md me kv io mf ip ky ir mg is lb iu mh iv le mi bi translated"><strong class="ak">聚集索引</strong></h1><p id="6bb4" class="pw-post-body-paragraph jo jp hi jq b jr ln ij jt ju lo im jw jx lp jz ka kb lq kd ke kf lr kh ki kj hb bi translated">聚集索引定义了数据在表中的存储顺序，表只能按一种方式排序。因此，每个表只能有一个聚集索引。在 RDBMS 中，主键通常允许您基于特定的列创建聚集索引。任何经过<strong class="jq hj">排序且唯一的</strong>列值都可以用作聚集索引，大多数情况下使用二分搜索法算法来高效地检索数据。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es mj"><img src="../Images/4dd876800273306e54001daee174c73e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1216/format:webp/1*-YN1BsP3-36pzhPBxQIBRA.png"/></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">EmployeeId 的聚集索引</figcaption></figure><h1 id="2a35" class="ly km hi bd kn lz mk mb kr mc ml me kv io mm ip ky ir mn is lb iu mo iv le mi bi translated"><strong class="ak">非聚集索引</strong></h1><p id="969b" class="pw-post-body-paragraph jo jp hi jq b jr ln ij jt ju lo im jw jx lp jz ka kb lq kd ke kf lr kh ki kj hb bi translated">当您需要使用另一列来查询数据时，我们可以创建一个称为非聚集索引的辅助索引。假设我们想为<em class="kk">雇员表</em>、<em class="kk">、</em>中的<em class="kk">第一个</em>、<em class="kk">姓名</em>创建一个辅助索引，而聚集索引是<em class="kk">雇员 id。</em></p><p id="a0a3" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">对于具有大量插入/更新操作的表，应该首选非聚集索引，因为它不需要额外的时间和 CPU 计算来在实际表上的每次插入/更新后对行进行排序。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es mp"><img src="../Images/3f2feb9793daa2c7fe6b374bd26ecd1b.png" data-original-src="https://miro.medium.com/v2/resize:fit:776/format:webp/1*H3-VBVXpbcdNakL4YqbhmA.png"/></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">名字的非聚集索引</figcaption></figure><p id="7b6e" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><strong class="jq hj"> <em class="kk">但是非聚集索引比聚集索引</em> </strong>低，因为我们仍然需要从为二级索引创建的表中读取数据，然后跳转到 employee 表以获得特定的雇员。但是，它比全表扫描快得多。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es mq"><img src="../Images/1ebca416802d3f358a336da2f140970f.png" data-original-src="https://miro.medium.com/v2/resize:fit:962/format:webp/1*ZheKqKov9ZQTB4UIkSWHRg.png"/></div><figcaption class="jj jk et er es jl jm bd b be z dx translated"><strong class="bd kn">运行速度比较</strong></figcaption></figure></div><div class="ab cl lg lh gp li" role="separator"><span class="lj bw bk lk ll lm"/><span class="lj bw bk lk ll lm"/><span class="lj bw bk lk ll"/></div><div class="hb hc hd he hf"><h2 id="2147" class="kl km hi bd kn ko kp kq kr ks kt ku kv jx kw kx ky kb kz la lb kf lc ld le lf bi translated"><strong class="ak">索引是如何工作的？</strong></h2><p id="3c2e" class="pw-post-body-paragraph jo jp hi jq b jr ln ij jt ju lo im jw jx lp jz ka kb lq kd ke kf lr kh ki kj hb bi translated">假设您有一个主键的索引(<em class="kk">雇员 id </em>)。这将在一个单独的表中创建一个主键值的有序列表，每个条目都有一个指向原始表中相对值的指针。</p><p id="84ae" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">每当你想使用主键访问表时，它将使用二分搜索法算法(耗时 O(LogN))来访问索引表中所需的值，然后，转到原始表中的相对值。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es mr"><img src="../Images/1bae2a6f877f57dec1977203a0624309.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0iA205Wx6sph2APmf0BynQ.png"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx translated"><strong class="bd kn">聚集索引</strong></figcaption></figure><p id="dd1f" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><strong class="jq hj">在<em class="kk">员工 id 上创建的聚集索引</em></strong>中， <em class="kk">员工 id 存储在多个数据页/页面文件中。</em>当您要求一个特定的<em class="kk">员工 id </em>时，它将导航到相关的页面文件以选择值。</p><blockquote class="ls lt lu"><p id="a92a" class="jo jp kk jq b jr js ij jt ju jv im jw lv jy jz ka lw kc kd ke lx kg kh ki kj hb bi translated">页面文件是数据库系统保存数据的基本和最小单位。无论数据库有多大，所有的原始数据都存储在页面文件中。</p></blockquote><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ms"><img src="../Images/bc06d5ea674151c7602ff8ce1324e8b8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oLsD4fXFop-Pk40vkcBusg.png"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx translated"><strong class="bd kn">非聚集索引</strong></figcaption></figure><p id="e7f3" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><strong class="jq hj">非聚集索引</strong>在单独的表中创建；它有两列，一列用于姓氏，一列用于相应的<em class="kk">员工 id </em>。创建的表现在按<em class="kk">姓氏</em>排序，这种方式我们实际上不能在 employee 表中使用，因为我们已经按<em class="kk">雇员 id </em>排序。</p><p id="3966" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">当查询非聚集索引时，它使用与员工 Id 关联的行定位器找到相关的行。然后在聚集索引中导航，并在实际的表中找到相关的数据行。</p></div><div class="ab cl lg lh gp li" role="separator"><span class="lj bw bk lk ll lm"/><span class="lj bw bk lk ll lm"/><span class="lj bw bk lk ll"/></div><div class="hb hc hd he hf"><h1 id="1c47" class="ly km hi bd kn lz ma mb kr mc md me kv io mf ip ky ir mg is lb iu mh iv le mi bi translated"><strong class="ak">创建索引</strong></h1><pre class="iy iz ja jb fd mt mu mv mw aw mx bi"><span id="b17d" class="kl km hi mu b fi my mz l na nb">CREATE INDEX employee_idx<br/>  ON employee(employee_id);</span></pre></div><div class="ab cl lg lh gp li" role="separator"><span class="lj bw bk lk ll lm"/><span class="lj bw bk lk ll lm"/><span class="lj bw bk lk ll"/></div><div class="hb hc hd he hf"><h1 id="ed0c" class="ly km hi bd kn lz ma mb kr mc md me kv io mf ip ky ir mg is lb iu mh iv le mi bi translated">最后的想法</h1><p id="c190" class="pw-post-body-paragraph jo jp hi jq b jr ln ij jt ju lo im jw jx lp jz ka kb lq kd ke kf lr kh ki kj hb bi translated">为数据库编制索引需要很好地理解数据、用户功能以及数据库是如何编制索引的。当处理大型数据集时，打开数据库终端并在有索引和没有索引的表上运行查询会发现速度有很大的差异。</p><p id="341b" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">索引可以大大提高搜索速度，但它们也有相关的缺点。每个插入、更新或删除操作都需要更新索引。如果你添加越来越多的数据，它将消耗更多的时间和占用大量的空间。当表包含多个索引时，每个索引都会增加处理表更新的时间。到目前为止，仅对用于搜索目的的列创建索引是一个很好的选择。</p></div><div class="ab cl lg lh gp li" role="separator"><span class="lj bw bk lk ll lm"/><span class="lj bw bk lk ll lm"/><span class="lj bw bk lk ll"/></div><div class="hb hc hd he hf"><h1 id="3cf3" class="ly km hi bd kn lz ma mb kr mc md me kv io mf ip ky ir mg is lb iu mh iv le mi bi translated">包装东西</h1><p id="48a2" class="pw-post-body-paragraph jo jp hi jq b jr ln ij jt ju lo im jw jx lp jz ka kb lq kd ke kf lr kh ki kj hb bi translated">最后，我希望您对数据库索引有一个清晰的概念。</p><p id="be67" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">如果有什么我说得不对的地方，欢迎在下面评论！。<em class="kk">如果你喜欢这篇文章，点击👏下面这样更多的人可以看到它！请务必在</em><a class="ae jn" rel="noopener" href="/@susithrj"><strong class="jq hj"><em class="kk">Medium</em></strong></a><strong class="jq hj"><em class="kk"/></strong><em class="kk">或</em> <a class="ae jn" href="https://susithrj.wordpress.com/" rel="noopener ugc nofollow" target="_blank"> <strong class="jq hj"> <em class="kk">我的博客</em></strong></a><strong class="jq hj"><em class="kk"/></strong><em class="kk">上关注我，以便在有新文章发表时获得更新。</em></p><p id="2246" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><em class="kk">快乐</em>T30】索引 T32】！👌</p></div></div>    
</body>
</html>