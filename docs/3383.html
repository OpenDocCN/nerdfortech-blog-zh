<html>
<head>
<title>What’s New In Modern JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">现代JavaScript的新特性</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/whats-new-in-modern-javascript-fb708c04b8f5?source=collection_archive---------3-----------------------#2021-06-08">https://medium.com/nerd-for-tech/whats-new-in-modern-javascript-fb708c04b8f5?source=collection_archive---------3-----------------------#2021-06-08</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/063864f07248c0fa67c9032639194adb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*28WpQ6m4S_A-ZZ2RwhIPQA.jpeg"/></div></div></figure><p id="b194" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">JavaScript是一种广泛使用的脚本语言，它基于ECMA脚本规范。尽管JavaScript已经多年没有发展了，但MEAN (MongoDB、Express、Angular、Node)栈的进入已经带来了一些有用的升级。因此，ECMAScript 6(也称为ES6和ECMAScript 2015)于2015年6月发布，现在被广泛使用。</p><p id="f9d6" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">JavaScript ES6引入了新的语法和几个新特性，旨在使您的代码更加现代和可读。它使您能够用更少的代码做更多的事情。</p><p id="d641" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在本文中，我将介绍ES6中添加的一些新特性。</p><h1 id="c49e" class="jo jp hi bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">让和const</h1><p id="1397" class="pw-post-body-paragraph iq ir hi is b it km iv iw ix kn iz ja jb ko jd je jf kp jh ji jj kq jl jm jn hb bi translated">在以前的版本中，我们使用<code class="du kr ks kt ku b">var</code>来声明变量。<code class="du kr ks kt ku b">var</code>语句声明了一个<strong class="is hj">函数作用域或全局作用域</strong>的变量。这意味着在函数中使用<code class="du kr ks kt ku b">var</code>关键字会创建一个可以从函数中访问的函数范围变量。同样，如果我们在函数之外使用<code class="du kr ks kt ku b">var</code>关键字，它会产生<strong class="is hj">一个全局作用域变量</strong>。这些<strong class="is hj">全局变量可以从代码文件</strong>中的任何地方访问。重复的<code class="du kr ks kt ku b">var</code>声明<strong class="is hj">不会导致错误</strong>，变量的值将<strong class="is hj">全局改变</strong>。</p><p id="4be0" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">参见下面的代码，</p><figure class="kw kx ky kz fd ij er es paragraph-image"><div class="er es kv"><img src="../Images/2d3f78b7f3a4db79a48adc8e04020e70.png" data-original-src="https://miro.medium.com/v2/resize:fit:866/format:webp/1*LLOxTk2XhIeDQNbbWvFByg.png"/></div><figcaption class="la lb et er es lc ld bd b be z dx translated">代码片段1</figcaption></figure><ul class=""><li id="b178" class="le lf hi is b it iu ix iy jb lg jf lh jj li jn lj lk ll lm bi translated">在第5行和第12行，即使<code class="du kr ks kt ku b">var</code>是在<code class="du kr ks kt ku b">{}</code>块中声明的，它也会全局改变变量的值<strong class="is hj">。</strong></li><li id="18fb" class="le lf hi is b it ln ix lo jb lp jf lq jj lr jn lj lk ll lm bi translated">即使我们在第18行的同一个块(范围)中复制了<code class="du kr ks kt ku b">var</code>，也没有出现<strong class="is hj">错误</strong>。</li></ul><figure class="kw kx ky kz fd ij er es paragraph-image"><div class="er es ls"><img src="../Images/f8e1a79fdeee8eecf5c29b2def76843b.png" data-original-src="https://miro.medium.com/v2/resize:fit:870/format:webp/1*7pgaCWzYoN7x2ZPsXgggSQ.png"/></div><figcaption class="la lb et er es lc ld bd b be z dx translated">产出1</figcaption></figure><h2 id="ff2a" class="lt jp hi bd jq lu lv lw ju lx ly lz jy jb ma mb kc jf mc md kg jj me mf kk mg bi translated">让</h2><p id="b533" class="pw-post-body-paragraph iq ir hi is b it km iv iw ix kn iz ja jb ko jd je jf kp jh ji jj kq jl jm jn hb bi translated">在ES6中，<code class="du kr ks kt ku b">let</code>关键字可以用来声明阻塞的作用域变量。这些块范围变量只能从块内部访问，而不能全局访问(我们不能从块外部访问)。参见下面的代码，</p><figure class="kw kx ky kz fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mh"><img src="../Images/da2ea6c5041b691c268bc0b8f32bdd36.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JuG77mPiLVGDNj2INncjrw.png"/></div></div><figcaption class="la lb et er es lc ld bd b be z dx translated">代码片段2</figcaption></figure><ul class=""><li id="8018" class="le lf hi is b it iu ix iy jb lg jf lh jj li jn lj lk ll lm bi translated">在这里，第5行和第12行中创建的变量只在它们自己的块中可用。</li></ul><figure class="kw kx ky kz fd ij er es paragraph-image"><div class="er es mi"><img src="../Images/608ac71a39df2d214415d21321355165.png" data-original-src="https://miro.medium.com/v2/resize:fit:862/format:webp/1*WNT5b1Axqrn2nuy939epzQ.png"/></div><figcaption class="la lb et er es lc ld bd b be z dx translated">产出2</figcaption></figure><p id="706c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">此外，我们<strong class="is hj">不能在同一个作用域</strong> (Block)内复制let，这样做会导致<strong class="is hj">错误</strong>。参见下面的代码，</p><figure class="kw kx ky kz fd ij er es paragraph-image"><div class="er es mj"><img src="../Images/226f135e4ae3b47980f0ff5cb395c7f8.png" data-original-src="https://miro.medium.com/v2/resize:fit:684/format:webp/1*ORxBFPYD1IeqtjMUT1LN-Q.png"/></div><figcaption class="la lb et er es lc ld bd b be z dx translated">代码片段3</figcaption></figure><figure class="kw kx ky kz fd ij er es paragraph-image"><div class="er es mk"><img src="../Images/ee6911e75345ed080220df7f00c871cb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1260/format:webp/1*K3Mgv3-eur4bkQY88vzDDw.png"/></div><figcaption class="la lb et er es lc ld bd b be z dx translated">产出3</figcaption></figure><blockquote class="ml mm mn"><p id="5795" class="iq ir mo is b it iu iv iw ix iy iz ja mp jc jd je mq jg jh ji mr jk jl jm jn hb bi translated">注意:- <code class="du kr ks kt ku b">let</code>提供了一个可变变量，这意味着我们可以在声明之后随时更改值。对于Ex:</p></blockquote><pre class="kw kx ky kz fd ms ku mt mu aw mv bi"><span id="e4ba" class="lt jp hi ku b fi mw mx l my mz">var x=1;<br/>x=2;<br/>console.log(x);  //result is 2</span></pre><h2 id="05c3" class="lt jp hi bd jq lu lv lw ju lx ly lz jy jb ma mb kc jf mc md kg jj me mf kk mg bi translated">常数</h2><p id="bc00" class="pw-post-body-paragraph iq ir hi is b it km iv iw ix kn iz ja jb ko jd je jf kp jh ji jj kq jl jm jn hb bi translated">在ES6中，有另一个新的声明变量的关键字叫做<strong class="is hj"> const </strong>。但是<strong class="is hj">常量变量一旦被设置</strong>，就不能被重新分配。换句话说，它提供了一个<strong class="is hj">不可变的变量</strong>，除非它与对象或数组一起使用。参见下面的代码，</p><figure class="kw kx ky kz fd ij er es paragraph-image"><div class="er es na"><img src="../Images/47bf360fbeb825b4d5d83c7ba09b3cf9.png" data-original-src="https://miro.medium.com/v2/resize:fit:618/format:webp/1*IgtgUCz5md_sYVV7M1dMGw.png"/></div><figcaption class="la lb et er es lc ld bd b be z dx translated">代码片段4</figcaption></figure><figure class="kw kx ky kz fd ij er es paragraph-image"><div class="er es nb"><img src="../Images/62de85c9af2837d4d413c7bfc038fdf1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1264/format:webp/1*CvzDV1Q4zM97-5-7q_F8nw.png"/></div><figcaption class="la lb et er es lc ld bd b be z dx translated">产出4</figcaption></figure><blockquote class="ml mm mn"><p id="db43" class="iq ir mo is b it iu iv iw ix iy iz ja mp jc jd je mq jg jh ji mr jk jl jm jn hb bi translated">注意:<code class="du kr ks kt ku b">const</code>只保护<strong class="is hj">直接变量</strong>。它不能保护内部组件。例如，它不能保护数组中的元素或对象中的元素。参见下面的代码，</p></blockquote><figure class="kw kx ky kz fd ij er es paragraph-image"><div class="er es nc"><img src="../Images/6c4457c906a56ec155c3297593defd0a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1380/format:webp/1*OkhsMpCtr2R9xaRlHUH2tg.png"/></div><figcaption class="la lb et er es lc ld bd b be z dx translated">代码片段5</figcaption></figure><figure class="kw kx ky kz fd ij er es paragraph-image"><div class="er es nd"><img src="../Images/09bd3ed0a35842f4b98d0726a092c02f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1268/format:webp/1*KItu6ZQ83XHeIo6x6sMMPg.png"/></div><figcaption class="la lb et er es lc ld bd b be z dx translated">产出5</figcaption></figure><h1 id="613c" class="jo jp hi bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">箭头功能</h1><p id="f683" class="pw-post-body-paragraph iq ir hi is b it km iv iw ix kn iz ja jb ko jd je jf kp jh ji jj kq jl jm jn hb bi translated">arrow函数非常棒，因为它使您的代码更具可读性、结构化和现代感。考虑以下代码:</p><figure class="kw kx ky kz fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ne"><img src="../Images/ac98edfd026200f99100c23efe15a27e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*d-82imVLuUWCi6lyvtON_Q.png"/></div></div><figcaption class="la lb et er es lc ld bd b be z dx translated">代码片段6</figcaption></figure><figure class="kw kx ky kz fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es nf"><img src="../Images/67cbf133d9b363302f3e1fc6e2fe8007.png" data-original-src="https://miro.medium.com/v2/resize:fit:858/format:webp/1*3tgQPkcKRF6nDkq5h051QQ.png"/></div></div><figcaption class="la lb et er es lc ld bd b be z dx translated">产出6</figcaption></figure><blockquote class="ml mm mn"><p id="a459" class="iq ir mo is b it iu iv iw ix iy iz ja mp jc jd je mq jg jh ji mr jk jl jm jn hb bi translated"><strong class="is hj">注意:</strong>如果我们在常规函数中使用‘this’关键字，那么‘this’关键字将代表函数的调用者。但是如果我们在一个箭头函数中使用“this”关键字，那么“this”关键字将不会表示函数的调用方。参见下面的例子。</p></blockquote><figure class="kw kx ky kz fd ij er es paragraph-image"><div class="er es ng"><img src="../Images/a3765944ad98dce7321919e6c7c5cfd0.png" data-original-src="https://miro.medium.com/v2/resize:fit:698/format:webp/1*h6YVAJ_hxPGddLRLlMC48w.png"/></div><figcaption class="la lb et er es lc ld bd b be z dx translated">代码片段7</figcaption></figure><figure class="kw kx ky kz fd ij er es paragraph-image"><div class="er es nh"><img src="../Images/a232988acac771cf41bc81b0029e9f3c.png" data-original-src="https://miro.medium.com/v2/resize:fit:856/format:webp/1*x0PWVF9HKBzrFOGAv5cJVw.png"/></div><figcaption class="la lb et er es lc ld bd b be z dx translated">产出7</figcaption></figure><h1 id="059c" class="jo jp hi bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">目标</h1><p id="a3fa" class="pw-post-body-paragraph iq ir hi is b it km iv iw ix kn iz ja jb ko jd je jf kp jh ji jj kq jl jm jn hb bi translated">参见下面的例子，</p><figure class="kw kx ky kz fd ij er es paragraph-image"><div class="er es ni"><img src="../Images/3ef218635b44e020b5f73657ad671b25.png" data-original-src="https://miro.medium.com/v2/resize:fit:1166/format:webp/1*fURt0TZnT-haVIZcmwy6cw.png"/></div><figcaption class="la lb et er es lc ld bd b be z dx translated">代码片段8</figcaption></figure><figure class="kw kx ky kz fd ij er es paragraph-image"><div class="er es nj"><img src="../Images/b5bd97453b5a396056bee82658ffdaa7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1014/format:webp/1*Jpi_t2LL_3wYV_sUhD8onQ.png"/></div><figcaption class="la lb et er es lc ld bd b be z dx translated">产出8</figcaption></figure><p id="097a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">注:</strong></p><ul class=""><li id="4bab" class="le lf hi is b it iu ix iy jb lg jf lh jj li jn lj lk ll lm bi translated">在Es6中，在上面的代码中，第7行和第18行将在键-值对中将变量名存储为“key ”,变量值存储为“value”。<em class="mo">当我们在创建对象时不知道键值对的“值”时，这是一个很好的方法。</em></li><li id="755b" class="le lf hi is b it ln ix lo jb lp jf lq jj lr jn lj lk ll lm bi translated">第8行和第19行将变量的值存储为键-值对中的“key”。这叫做<strong class="is hj">动态属性</strong>。<em class="mo">当我们在创建对象时不知道键-值对的“键”时，这是一个好方法。</em></li></ul><h1 id="7c63" class="jo jp hi bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">冻结</h1><p id="4272" class="pw-post-body-paragraph iq ir hi is b it km iv iw ix kn iz ja jb ko jd je jf kp jh ji jj kq jl jm jn hb bi translated">Object.freeze()是一种用于冻结对象的方法。它用于使对象不可变。因此，我们不能添加、删除或修改冻结对象的组件。</p><blockquote class="ml mm mn"><p id="5ecd" class="iq ir mo is b it iu iv iw ix iy iz ja mp jc jd je mq jg jh ji mr jk jl jm jn hb bi translated"><strong class="is hj">注意:</strong>冻结()方法只会冻结第一级组件。对象组件的内部组件不会被冻结。参见下面的代码，</p></blockquote><figure class="kw kx ky kz fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es nk"><img src="../Images/ba114074b81bcb1d76f4d6b7021b3b05.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7Z9g0y29b1sl3jp7xJAMsQ.png"/></div></div><figcaption class="la lb et er es lc ld bd b be z dx translated">代码片段9</figcaption></figure><figure class="kw kx ky kz fd ij er es paragraph-image"><div class="er es nl"><img src="../Images/aeae0ac1022190a925d0ff13f4a7fa33.png" data-original-src="https://miro.medium.com/v2/resize:fit:974/format:webp/1*DnUxJXxvU7xfPnNedJmi_w.png"/></div><figcaption class="la lb et er es lc ld bd b be z dx translated">产出9</figcaption></figure><blockquote class="ml mm mn"><p id="86c7" class="iq ir mo is b it iu iv iw ix iy iz ja mp jc jd je mq jg jh ji mr jk jl jm jn hb bi translated"><strong class="is hj">注意:</strong>如果你有一个对象将被从一个服务发送到另一个服务，并且你想确保它不被修改，你可以使用<code class="du kr ks kt ku b">freeze()</code>方法。</p></blockquote><h1 id="976d" class="jo jp hi bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">模板</h1><p id="3da5" class="pw-post-body-paragraph iq ir hi is b it km iv iw ix kn iz ja jb ko jd je jf kp jh ji jj kq jl jm jn hb bi translated">ES6的一个很好的特性是模板文字。当连接字符串或在字符串中使用变量时，我们不需要使用加号(+)操作符。</p><figure class="kw kx ky kz fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es nm"><img src="../Images/2355acbc3d4f6134553a031aeeddea76.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xZ1VV9GZareiXLa42JV2sg.png"/></div></div><figcaption class="la lb et er es lc ld bd b be z dx translated">代码片段10</figcaption></figure><figure class="kw kx ky kz fd ij er es paragraph-image"><div class="er es nn"><img src="../Images/ebf3303542a06c7f03f9a09ca890e9db.png" data-original-src="https://miro.medium.com/v2/resize:fit:894/format:webp/1*9zHuLUKEeBhLjR4kynOQlg.png"/></div><figcaption class="la lb et er es lc ld bd b be z dx translated">产出10</figcaption></figure><h1 id="503e" class="jo jp hi bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">班级</h1><p id="a7e1" class="pw-post-body-paragraph iq ir hi is b it km iv iw ix kn iz ja jb ko jd je jf kp jh ji jj kq jl jm jn hb bi translated">类是面向对象编程(OOP)的核心。ES6允许您创建和利用类。参见下面的代码，</p><figure class="kw kx ky kz fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es no"><img src="../Images/d09c6493e2c8d5a7063b56e0ede2a564.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-CB1XNxz_Hx-viw_zoRPBA.png"/></div></div><figcaption class="la lb et er es lc ld bd b be z dx translated">代码片段11</figcaption></figure><figure class="kw kx ky kz fd ij er es paragraph-image"><div class="er es np"><img src="../Images/11f75c77bb2341bbfeaedb07da4ab361.png" data-original-src="https://miro.medium.com/v2/resize:fit:878/format:webp/1*fRJrqSnWXI1N5gzr9HJwdQ.png"/></div><figcaption class="la lb et er es lc ld bd b be z dx translated">产出11</figcaption></figure><p id="2e92" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">注意:</p><blockquote class="ml mm mn"><p id="0736" class="iq ir mo is b it iu iv iw ix iy iz ja mp jc jd je mq jg jh ji mr jk jl jm jn hb bi translated">*在ES6中，我们使用'<strong class="is hj">构造函数</strong>'关键字来声明一个构造函数。</p><p id="b01f" class="iq ir mo is b it iu iv iw ix iy iz ja mp jc jd je mq jg jh ji mr jk jl jm jn hb bi translated">*没有必要为了存储实例变量而声明实例变量。我们需要做的就是<strong class="is hj">在构造函数</strong>中赋值。(参见线3 &amp; 4)</p><p id="e03d" class="iq ir mo is b it iu iv iw ix iy iz ja mp jc jd je mq jg jh ji mr jk jl jm jn hb bi translated">*和java一样，我们使用'<strong class="is hj">扩展</strong>关键字来实现继承。</p><p id="da7b" class="iq ir mo is b it iu iv iw ix iy iz ja mp jc jd je mq jg jh ji mr jk jl jm jn hb bi translated">*我们使用<strong class="is hj"> super() </strong>方法调用父类的构造函数。</p><p id="feb0" class="iq ir mo is b it iu iv iw ix iy iz ja mp jc jd je mq jg jh ji mr jk jl jm jn hb bi translated">*类中最酷的特性是我们可以在调用对象时<strong class="is hj">覆盖一个函数(参考第26行)</strong></p></blockquote><h1 id="f05e" class="jo jp hi bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">破坏</h1><p id="5796" class="pw-post-body-paragraph iq ir hi is b it km iv iw ix kn iz ja jb ko jd je jf kp jh ji jj kq jl jm jn hb bi translated">解构是破坏一个结构的过程。从编程的角度来看，解构数据结构意味着将单个值从数据结构中解包出来。在ES6中，析构可以用在对象或数组上。考虑下面的代码，</p><figure class="kw kx ky kz fd ij"><div class="bz dy l di"><div class="nq nr l"/></div><figcaption class="la lb et er es lc ld bd b be z dx translated">销毁的代码片段</figcaption></figure><p id="27c1" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">注意:</p><ul class=""><li id="8f67" class="le lf hi is b it iu ix iy jb lg jf lh jj li jn lj lk ll lm bi translated">在上面的代码中，第8行解压person对象并给每个变量赋值。如果变量的名称与对象的一个键匹配，则该键的值将存储在该变量中。</li><li id="d5cd" class="le lf hi is b it ln ix lo jb lp jf lq jj lr jn lj lk ll lm bi translated">第19行将根据数组的顺序为变量赋值。</li><li id="3b3b" class="le lf hi is b it ln ix lo jb lp jf lq jj lr jn lj lk ll lm bi translated">第28行根据数组的顺序分配变量值。赋值后，数组中剩余的所有元素将被复制到一个新的数组(c1)中。</li><li id="8418" class="le lf hi is b it ln ix lo jb lp jf lq jj lr jn lj lk ll lm bi translated">第33行将复制该数组。</li><li id="0275" class="le lf hi is b it ln ix lo jb lp jf lq jj lr jn lj lk ll lm bi translated">第41行将合并这两个数组。</li><li id="def0" class="le lf hi is b it ln ix lo jb lp jf lq jj lr jn lj lk ll lm bi translated">在第54行，即使我们将整个对象作为参数发送，该对象将被解压缩，并且该对象的这两个元素将作为参数传递给函数。</li></ul><h1 id="7005" class="jo jp hi bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">回调、承诺、异步/等待</h1><p id="bc2b" class="pw-post-body-paragraph iq ir hi is b it km iv iw ix kn iz ja jb ko jd je jf kp jh ji jj kq jl jm jn hb bi translated">Node.js将异步运行。这里，一条语句不等待前一条语句完成执行。要理解异步代码是如何工作的，请看下面的代码。</p><figure class="kw kx ky kz fd ij er es paragraph-image"><div class="er es ns"><img src="../Images/fb19b4ab3ac83e17d2f751b0221fb1bd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1004/format:webp/1*a_MmZ9JBde9Jv1fxJw85jQ.png"/></div><figcaption class="la lb et er es lc ld bd b be z dx translated">代码片段12</figcaption></figure><figure class="kw kx ky kz fd ij er es paragraph-image"><div class="er es nt"><img src="../Images/85939cef5fc3df690662594b5f0a17d3.png" data-original-src="https://miro.medium.com/v2/resize:fit:900/format:webp/1*lf1HMyEA9EyeMgMWv9wYsw.png"/></div><figcaption class="la lb et er es lc ld bd b be z dx translated">产出12</figcaption></figure><blockquote class="ml mm mn"><p id="181d" class="iq ir mo is b it iu iv iw ix iy iz ja mp jc jd je mq jg jh ji mr jk jl jm jn hb bi translated"><strong class="is hj">注意:</strong>以上，即使先调用function1()，function2()也先完成其执行，如输出所示。这是因为执行是异步的。这里，function2()不等待function1()的完成。此外，因为第19行在function1()和function2()完成之前执行，所以输出是“未定义的”。</p></blockquote><h2 id="3a91" class="lt jp hi bd jq lu lv lw ju lx ly lz jy jb ma mb kc jf mc md kg jj me mf kk mg bi translated">回调函数</h2><p id="9699" class="pw-post-body-paragraph iq ir hi is b it km iv iw ix kn iz ja jb ko jd je jf kp jh ji jj kq jl jm jn hb bi translated">假设我们在一家比萨饼店，我们点了一份比萨饼，并指示店主在比萨饼做好时给我们打电话。然后我们就能继续工作了。披萨好了他们会打电话给我们，这样我们就可以去拿了。回调函数以类似的方式工作。</p><p id="2d90" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">假设当我们调用FunctionA()时，我们将functionB()作为参数传递给functionA()。因此，当functionA()完成时，它调用functionB()。这就是我们如何使用回调函数来管理异步代码。看看下面的代码，</p><figure class="kw kx ky kz fd ij er es paragraph-image"><div class="er es nu"><img src="../Images/55e9ba0241707b55f5911e67b3c2ca69.png" data-original-src="https://miro.medium.com/v2/resize:fit:884/format:webp/1*oV4HGT-RpdU2bHR5wc1XwA.png"/></div><figcaption class="la lb et er es lc ld bd b be z dx translated">代码片段13</figcaption></figure><figure class="kw kx ky kz fd ij er es paragraph-image"><div class="er es nv"><img src="../Images/0af7e9035f6eef2c4fe66f11f1e5556b.png" data-original-src="https://miro.medium.com/v2/resize:fit:954/format:webp/1*MnJRNQYJBmknP3fKH8GDXQ.png"/></div><figcaption class="la lb et er es lc ld bd b be z dx translated">产出13</figcaption></figure><p id="19db" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们可以看到，通过利用回调函数，我们可以让代码以特定的顺序执行。</p><h2 id="166d" class="lt jp hi bd jq lu lv lw ju lx ly lz jy jb ma mb kc jf mc md kg jj me mf kk mg bi translated">承诺</h2><p id="3928" class="pw-post-body-paragraph iq ir hi is b it km iv iw ix kn iz ja jb ko jd je jf kp jh ji jj kq jl jm jn hb bi translated">当回调函数的数量增加时，它看起来会变得更加复杂。取名<strong class="is hj">《回调地狱》</strong>。我们可以用承诺来有效地解决这个问题。</p><p id="a29a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">一个需要时间来完成执行的函数，当我们调用这个函数时，它会返回一个承诺。承诺有两种可能的状态，它们是“决定”和“拒绝”。当函数成功完成后，我们可以使用then()继续执行。如果函数返回任何错误，我们可以使用catch()来处理这些错误。</p><p id="f10b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">为了说明承诺是如何工作的，考虑下面的例子。让我们假设我们正在向系统发送关于我们客户的账户细节的信息。根据账户类型，系统将计算利息金额。如果没有找到记录，系统将抛出一个错误。看看下面的代码，</p><figure class="kw kx ky kz fd ij"><div class="bz dy l di"><div class="nq nr l"/></div><figcaption class="la lb et er es lc ld bd b be z dx translated">承诺的代码片段</figcaption></figure><figure class="kw kx ky kz fd ij er es paragraph-image"><div class="er es np"><img src="../Images/ef5a0bf2443637325bc838e5e1ec117c.png" data-original-src="https://miro.medium.com/v2/resize:fit:878/format:webp/1*d9Ps3ndqXgWRnbRVTrLeow.png"/></div><figcaption class="la lb et er es lc ld bd b be z dx translated">输出到上面的代码</figcaption></figure><h2 id="d822" class="lt jp hi bd jq lu lv lw ju lx ly lz jy jb ma mb kc jf mc md kg jj me mf kk mg bi translated">异步等待</h2><p id="5b3d" class="pw-post-body-paragraph iq ir hi is b it km iv iw ix kn iz ja jb ko jd je jf kp jh ji jj kq jl jm jn hb bi translated"><code class="du kr ks kt ku b">async</code>和<code class="du kr ks kt ku b">await</code>让承诺更容易写。函数前的关键字<code class="du kr ks kt ku b">async</code>使函数返回一个承诺。一个函数前的关键字<code class="du kr ks kt ku b">await</code>让函数等待一个承诺。<code class="du kr ks kt ku b">await</code>关键字只能在<code class="du kr ks kt ku b">async</code>函数中使用。让我们使用Async / Await来转换上面的代码。</p><pre class="kw kx ky kz fd ms ku mt mu aw mv bi"><span id="37b6" class="lt jp hi ku b fi mw mx l my mz">getAccount(client_accounts,"John Doe") .then(account=&gt;getInterestDetails(account)) .then(interestDetails=&gt;getInterest(interestDetails.amount,interestDetails.rate)).then(interest=&gt;console.log("Interest is "+interest)).catch((error)=&gt;console.log(error));</span></pre><p id="0d4c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">而不是用这个👆用这个👇</p><figure class="kw kx ky kz fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es nw"><img src="../Images/fa760df77da2f552744b9527a9b8c82a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mhQW2FaPt_vQ8b96S4BaeA.png"/></div></div><figcaption class="la lb et er es lc ld bd b be z dx translated">代码片段14</figcaption></figure><figure class="kw kx ky kz fd ij er es paragraph-image"><div class="er es np"><img src="../Images/75c63b92cf7e82a014816077c5aadf67.png" data-original-src="https://miro.medium.com/v2/resize:fit:878/format:webp/1*SI5w1CGQTqBsKPKuGtrh1Q.png"/></div><figcaption class="la lb et er es lc ld bd b be z dx translated">产出14</figcaption></figure><h1 id="ea08" class="jo jp hi bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">继续学习❤️</h1></div><div class="ab cl nx ny gp nz" role="separator"><span class="oa bw bk ob oc od"/><span class="oa bw bk ob oc od"/><span class="oa bw bk ob oc"/></div><div class="hb hc hd he hf"><h1 id="356d" class="jo jp hi bd jq jr oe jt ju jv of jx jy jz og kb kc kd oh kf kg kh oi kj kk kl bi translated">参考</h1><figure class="kw kx ky kz fd ij"><div class="bz dy l di"><div class="oj nr l"/></div></figure><figure class="kw kx ky kz fd ij"><div class="bz dy l di"><div class="oj nr l"/></div></figure><div class="ok ol ez fb om on"><a href="https://www.freecodecamp.org/news/write-less-do-more-with-javascript-es6-5fd4a8e50ee2/" rel="noopener  ugc nofollow" target="_blank"><div class="oo ab dw"><div class="op ab oq cl cj or"><h2 class="bd hj fi z dy os ea eb ot ed ef hh bi translated">JavaScript ES6 -写得更少，做得更多</h2><div class="ou l"><h3 class="bd b fi z dy os ea eb ot ed ef dx translated">JavaScript ES6带来了新的语法和令人惊叹的新特性，使您的代码更加现代，可读性更好。它允许…</h3></div><div class="ov l"><p class="bd b fp z dy os ea eb ot ed ef dx translated">www.freecodecamp.org</p></div></div><div class="ow l"><div class="ox l oy oz pa ow pb io on"/></div></div></a></div><figure class="kw kx ky kz fd ij"><div class="bz dy l di"><div class="oj nr l"/></div></figure></div></div>    
</body>
</html>