<html>
<head>
<title>EDA implementation — Integration scenarios</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">EDA实施—集成场景</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/eda-implementation-integration-scenarios-66895923439?source=collection_archive---------4-----------------------#2021-05-06">https://medium.com/nerd-for-tech/eda-implementation-integration-scenarios-66895923439?source=collection_archive---------4-----------------------#2021-05-06</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="a537" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">将业务系统与events backbone集成的用例及方法</h2></div><p id="44b7" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在<a class="ae jt" href="https://chathura-ekanayake.medium.com/applying-event-driven-architecture-in-digital-transformation-projects-acbcb27440af" rel="noopener">之前的一篇文章</a>中，我们讨论了基于事件驱动架构(EDA)系统的通用架构。在本文中，我们将通过关注特定的产品及其交互来探索这种事件驱动系统的实现方法。</p><p id="ca01" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">图1描述了一个基于EDA的系统的通用架构(关于这个的细节在这里<a class="ae jt" href="https://chathura-ekanayake.medium.com/applying-event-driven-architecture-in-digital-transformation-projects-acbcb27440af" rel="noopener">讨论过</a>)。在这里，我们将缩小到该架构的几个有趣的部分(在下图中突出显示),并探索可能的实现方法。</p><figure class="jv jw jx jy fd jz er es paragraph-image"><div role="button" tabindex="0" class="ka kb di kc bf kd"><div class="er es ju"><img src="../Images/24cc32028a5c9bff59247a08e20b81c2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xVSY9PWqnCQnx8bYlpoAaA.png"/></div></div><figcaption class="kg kh et er es ki kj bd b be z dx translated">图1:基于EDA的系统的通用架构，突出了本文关注的部分</figcaption></figure><p id="8a99" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">本文的重点主要是事件主干，特别是它与系统其余部分的交互。events backbone有多种选择，商业和开源都有，包括<a class="ae jt" href="https://www.rabbitmq.com/" rel="noopener ugc nofollow" target="_blank"> RabbitMQ </a>、<a class="ae jt" href="https://kafka.apache.org/" rel="noopener ugc nofollow" target="_blank"> Kafka </a>、<a class="ae jt" href="https://activemq.apache.org/" rel="noopener ugc nofollow" target="_blank"> ActiveMQ </a>、<a class="ae jt" href="https://nats.io/" rel="noopener ugc nofollow" target="_blank"> NATS </a>和<a class="ae jt" href="https://www.ibm.com/products/mq" rel="noopener ugc nofollow" target="_blank"> IBM MQ </a>。</p><blockquote class="kk kl km"><p id="9af6" class="ix iy kn iz b ja jb ij jc jd je im jf ko jh ji jj kp jl jm jn kq jp jq jr js hb bi translated">Events backbone促进了服务之间的松散耦合，并提供了可靠的消息传递。此外，它支持发布/订阅模式，这允许多个服务接收从其他服务发布的事件。</p></blockquote><p id="3eb4" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">从实现的角度来看，我们需要考虑连接事件主干和相关服务的集成方法。许多事件代理支持多种消息协议，如AMQP、MQTT和STOMP。如果业务服务可以通过这些协议进行通信，它就可以直接连接事件代理来发布和使用消息。</p><p id="eeab" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">但是，如果业务服务只通过HTTP等协议进行通信，或者如果需要将文件服务器或数据库集成到事件驱动的系统中，则有必要使用集成层。此外，在许多场景中，在发布到events backbone之前或从events backbone消费之后，有必要处理事件。在这种情况下，集成层成为执行这种中间消息处理操作的重要组件。在本文中，我们将使用Kafka作为事件主干，使用<a class="ae jt" href="https://wso2.com/integration/micro-integrator/" rel="noopener ugc nofollow" target="_blank"> WSO2 Micro Integrator </a>作为集成层来说明其中的一些实现方法。</p><h1 id="441f" class="kr ks hi bd kt ku kv kw kx ky kz la lb io lc ip ld ir le is lf iu lg iv lh li bi translated">将基于HTTP的业务服务与事件主干网集成</h1><p id="7e36" class="pw-post-body-paragraph ix iy hi iz b ja lj ij jc jd lk im jf jg ll ji jj jk lm jm jn jo ln jq jr js hb bi translated">让我们考虑图2中描绘的场景:</p><figure class="jv jw jx jy fd jz er es paragraph-image"><div role="button" tabindex="0" class="ka kb di kc bf kd"><div class="er es lo"><img src="../Images/d70e639acb57b424f55cc5c53568989c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*V7CT0kLZcP6K0Zv9ZHwvxQ.png"/></div></div><figcaption class="kg kh et er es ki kj bd b be z dx translated">图2:通过HTTP将事件主干与业务系统集成</figcaption></figure><ol class=""><li id="f5f4" class="lp lq hi iz b ja jb jd je jg lr jk ls jo lt js lu lv lw lx bi translated">客户在购物门户中下订单</li><li id="8d4d" class="lp lq hi iz b ja ly jd lz jg ma jk mb jo mc js lu lv lw lx bi translated">购物门户通过HTTP将销售订单作为JSON请求发送到集成层</li><li id="ae43" class="lp lq hi iz b ja ly jd lz jg ma jk mb jo mc js lu lv lw lx bi translated">集成层根据给定的策略处理请求，如下:<br/> 3a。如果数量小于100，则将其发送到Kafka <br/>中的“销售-订单”主题3b:如果数量大于100，则通过HTTP调用库存服务以获取订购商品的单价和可用库存<br/> 3c:计算订单总价值，通过组合订单审批的所有相关信息来准备消息，并将其发送到Kafka <br/> 3d中的“订单-审批”主题:构造适当的JSON响应消息并通过HTTP回复购物门户</li></ol><p id="0bb1" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在这个场景中，多个基于HTTP的服务(即购物门户和库存服务)和事件中枢(即Kafka)参与到业务流程中。此外，除了使用Kafka events broker桥接HTTP服务之外，集成层还执行消息处理活动，如条件路由(3a)、服务编排(3b)和消息丰富(3c)。</p><p id="adc9" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">图3显示了在<a class="ae jt" href="https://wso2.com/integration/integration-studio/" rel="noopener ugc nofollow" target="_blank"> WSO2 Integration Studio </a>中建模的集成流(这是一个为<a class="ae jt" href="https://wso2.com/integration/micro-integrator/" rel="noopener ugc nofollow" target="_blank"> WSO2微集成器</a>创建集成流的图形编辑器)。</p><figure class="jv jw jx jy fd jz er es paragraph-image"><div role="button" tabindex="0" class="ka kb di kc bf kd"><div class="er es md"><img src="../Images/c258bd7923ff8c1c8301b194ad98207c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hxuxfQITwFOffJRWsuZ6kQ.png"/></div></div><figcaption class="kg kh et er es ki kj bd b be z dx translated">图3:将HTTP服务与Kafka集成的可视化集成</figcaption></figure><p id="7952" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">相同流程的基于XML的集成代码如图4所示(见下图)。它首先使用<a class="ae jt" href="https://ei.docs.wso2.com/en/latest/micro-integrator/references/mediators/property-Group-Mediator/" rel="noopener ugc nofollow" target="_blank">属性组中介器</a>从传入的消息中提取必要的数据。然后使用<a class="ae jt" href="https://ei.docs.wso2.com/en/latest/micro-integrator/references/mediators/filter-Mediator/" rel="noopener ugc nofollow" target="_blank">过滤中介</a>根据订单数量执行条件路由。如果订单数量大于100，它使用<a class="ae jt" href="https://ei.docs.wso2.com/en/latest/micro-integrator/references/mediators/call-Mediator/" rel="noopener ugc nofollow" target="_blank">调用中介</a>调用库存服务。然后使用<a class="ae jt" href="https://ei.docs.wso2.com/en/latest/micro-integrator/references/mediators/payloadFactory-Mediator/" rel="noopener ugc nofollow" target="_blank">有效负载工厂中介</a>通过组合必要的信息来构建新的JSON有效负载。使用<a class="ae jt" href="https://ei.docs.wso2.com/en/latest/micro-integrator/references/connectors/kafka-connector/kafka-connector-overview/" rel="noopener ugc nofollow" target="_blank"> Kafka连接器</a>将此丰富的消息发布到“订单批准”Kafka主题。</p><p id="d33d" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如果订单数量少于100，则使用Kafka连接器将消息直接发布到“销售订单”主题。在这两种情况下，它都使用有效负载工厂中介来构造适当的响应消息，并将其发送到购物门户。</p><figure class="jv jw jx jy fd jz"><div class="bz dy l di"><div class="me mf l"/></div><figcaption class="kg kh et er es ki kj bd b be z dx translated">图4:将HTTP服务与Kafka集成的集成代码(DSL)</figcaption></figure><h1 id="e29d" class="kr ks hi bd kt ku kv kw kx ky kz la lb io lc ip ld ir le is lf iu lg iv lh li bi translated">将处理过的事件保存在数据库中</h1><p id="54fa" class="pw-post-body-paragraph ix iy hi iz b ja lj ij jc jd lk im jf jg ll ji jj jk lm jm jn jo ln jq jr js hb bi translated">现在让我们考虑一个场景，我们需要在数据库中记录完成的订单。我们在Kafka中创建了一个名为“completed-orders”的主题，以JSON格式接收已完成订单的详细信息。多个部门的订单处理系统可能会将完整的订单信息发布到此主题。现在，我们可以配置集成层来监听这个主题，并根据需要将接收到的事件保存在数据库表中。在这个场景中，我们假设需要从JSON消息中分别提取订单细节和与发货相关的细节，并将它们存储在两个名为“orders”和“shipments”的表中。这个用例如图5所示。</p><figure class="jv jw jx jy fd jz er es paragraph-image"><div role="button" tabindex="0" class="ka kb di kc bf kd"><div class="er es mg"><img src="../Images/06ce85b1bedd4eece6049021316a99ee.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JCbd2j2jOxTXAF1tQ_uujg.png"/></div></div><figcaption class="kg kh et er es ki kj bd b be z dx translated">图5:从Kafka事件中提取细节，并将这些细节保存在多个表中</figcaption></figure><p id="e715" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">当我们需要访问数据库时，我们在这个集成场景中使用了<a class="ae jt" href="https://ei.docs.wso2.com/en/latest/micro-integrator/use-cases/tutorials/sending-a-simple-message-to-a-datasource/" rel="noopener ugc nofollow" target="_blank"> WSO2 MI数据服务</a>。可以通过数据服务将SQL支持的数据库操作公开为REST服务。因此，当调用这种REST数据服务方法时，通过使用REST有效负载作为SQL参数，对数据执行基于SQL的底层操作。图6显示了两个REST方法“/hmartdata/orders”和“/hmartdata/shipments”的数据服务配置，以及它们相关的SQL操作。</p><figure class="jv jw jx jy fd jz"><div class="bz dy l di"><div class="me mf l"/></div><figcaption class="kg kh et er es ki kj bd b be z dx translated">图6:用于插入订单和发货数据的WSO2 MI数据服务配置</figcaption></figure><p id="69c0" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">现在，我们需要一种方法来订阅Kafka中的“已完成订单”主题。为此，我们使用了一个名为<a class="ae jt" href="https://ei.docs.wso2.com/en/latest/micro-integrator/references/synapse-properties/inbound-endpoints/about-inbound-endpoints/" rel="noopener ugc nofollow" target="_blank">的入站端点</a>，它可以监听来自各种来源的消息/事件，包括Kafka、RabbitMQ、MQTT和websockets。下面是Kafka入站端点的配置，它指定了要监听的Kafka主题以及每个入站事件要触发的集成流。</p><figure class="jv jw jx jy fd jz"><div class="bz dy l di"><div class="me mf l"/></div><figcaption class="kg kh et er es ki kj bd b be z dx translated">图7: Kafka入站端点配置</figcaption></figure><p id="f7ee" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">现在我们可以考虑实际的集成流，它将被每个传入的消息触发(图8)。首先，它从传入的Kafka消息中提取与订单相关的信息，并调用“/hmartdata/orders”数据服务方法将其保存在“orders”表中。然后，它提取与发货相关的信息，并调用“/hmartdata/shipments”方法将发货数据存储在“shipments”表中。</p><figure class="jv jw jx jy fd jz"><div class="bz dy l di"><div class="me mf l"/></div><figcaption class="kg kh et er es ki kj bd b be z dx translated">图8:从已完成的订单消息中提取信息并通过数据服务将这些信息保存在数据库表中的集成流程</figcaption></figure><p id="4172" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">上述基于DSL的集成流程的图形化集成流程如图9所示。</p><figure class="jv jw jx jy fd jz er es paragraph-image"><div role="button" tabindex="0" class="ka kb di kc bf kd"><div class="er es mh"><img src="../Images/ff1e1ec6b4205aa5d57961f05f7af703.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*piyqsn-r0FK9DtneHauJmQ.png"/></div></div><figcaption class="kg kh et er es ki kj bd b be z dx translated">图9:在WSO2 Integration studio中为持久化订单设计的图形化集成流程</figcaption></figure><h1 id="092b" class="kr ks hi bd kt ku kv kw kx ky kz la lb io lc ip ld ir le is lf iu lg iv lh li bi translated">将文件系统与事件主干集成</h1><p id="5809" class="pw-post-body-paragraph ix iy hi iz b ja lj ij jc jd lk im jf jg ll ji jj jk lm jm jn jo ln jq jr js hb bi translated">作为第三个用例，让我们假设一个合作伙伴组织想要向一个仓库下批量订单。为此，他们将所有单个订单放在一个XML文件中，并将其发送到仓库托管的文件服务器。现在，仓库系统必须挑选这样的批量订单文件并处理单个订单。另外，让我们假设仓库系统只能处理JSON消息。</p><p id="d3c3" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们可以使用events backbone(即Kafka)来保存这样的单个订单，直到它们被处理。然后每个需要处理订单请求的仓库系统都可以订阅Kafka主题并消费订单。在这种情况下，我们可以通过执行以下任务，使用集成层来弥合文件服务器和Kafka之间的差距:</p><ol class=""><li id="1016" class="lp lq hi iz b ja jb jd je jg lr jk ls jo lt js lu lv lw lx bi translated">从文件服务器获取批量订单文件</li><li id="041d" class="lp lq hi iz b ja ly jd lz jg ma jk mb jo mc js lu lv lw lx bi translated">通过检查所有必要的部分是否可用(使用XML模式)来验证批量订单内容</li><li id="7c03" class="lp lq hi iz b ja ly jd lz jg ma jk mb jo mc js lu lv lw lx bi translated">将批量订单拆分成单个订单，并将它们转换成JSON</li><li id="8f8e" class="lp lq hi iz b ja ly jd lz jg ma jk mb jo mc js lu lv lw lx bi translated">将每个订单发布到名为“销售订单”的Kafka主题</li></ol><p id="7779" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这个场景如图10所示。</p><figure class="jv jw jx jy fd jz er es paragraph-image"><div role="button" tabindex="0" class="ka kb di kc bf kd"><div class="er es mi"><img src="../Images/be3fee0aafe0cca6f0a0dcb890a2f6ca.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Wfz6s5lWzLMBB8pQv_kHDw.png"/></div></div><figcaption class="kg kh et er es ki kj bd b be z dx translated">图10:将文件服务器与Kafka集成</figcaption></figure><p id="0644" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">与前面的场景类似，我们使用入站端点将文件提取到集成层。下面是文件入站端点的配置，该端点包含要从中获取文件的文件夹以及要为每个传入文件触发的集成流(请注意，在本例中，我们从本地文件系统而不是文件服务器获取文件):</p><figure class="jv jw jx jy fd jz"><div class="bz dy l di"><div class="me mf l"/></div><figcaption class="kg kh et er es ki kj bd b be z dx translated">图11:获取文件和触发相关集成流的WSO2 MI入站端点</figcaption></figure><p id="1139" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">现在，我们可以考虑处理从文件系统获取的每个文件的集成流程。它根据给定的XML模式验证传入的文件(使用<a class="ae jt" href="https://ei.docs.wso2.com/en/latest/micro-integrator/references/mediators/validate-Mediator/" rel="noopener ugc nofollow" target="_blank">验证中介</a>),将文件内容分成单独的订单(使用<a class="ae jt" href="https://ei.docs.wso2.com/en/latest/micro-integrator/references/mediators/iterate-Mediator/" rel="noopener ugc nofollow" target="_blank">迭代中介</a>),并将每个订单发布到Kafka主题。这个集成流程的图形视图和集成代码分别如图12和图13所示。</p><figure class="jv jw jx jy fd jz er es paragraph-image"><div role="button" tabindex="0" class="ka kb di kc bf kd"><div class="er es mj"><img src="../Images/87b1059314c7a6e9b127e26656b4f4d1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RHMMYssvgGPYw9e_z-zbnQ.png"/></div></div><figcaption class="kg kh et er es ki kj bd b be z dx translated">图12:文件处理集成流程的图形视图</figcaption></figure><figure class="jv jw jx jy fd jz"><div class="bz dy l di"><div class="me mf l"/></div><figcaption class="kg kh et er es ki kj bd b be z dx translated">图13:文件处理流程的集成代码</figcaption></figure><p id="26cd" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">正如我们在本文中所讨论的，企业系统可以以各种方式与事件主干集成，以满足EDA相关的业务用例。在接下来的文章中，我们将看到如何在EDA中应用<a class="ae jt" href="https://chathura-ekanayake.medium.com/eda-implementation-processing-and-integrating-event-streams-4eeb1a083743" rel="noopener">流处理技术</a>，以及如何将事件作为托管API向外部消费者公开。</p></div></div>    
</body>
</html>