<html>
<head>
<title>Introduction to FLOWER.</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">花卉概论。</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/build-your-own-federated-learning-model-2c882ea8cfde?source=collection_archive---------3-----------------------#2021-05-31">https://medium.com/nerd-for-tech/build-your-own-federated-learning-model-2c882ea8cfde?source=collection_archive---------3-----------------------#2021-05-31</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="d5eb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在我早先的<a class="ae jd" href="https://ankitasinha0811.medium.com/beginners-guide-to-federated-learning-d529557a1b1e" rel="noopener">帖子</a>中，我从广泛的层面上介绍了什么是联合学习。在这里，我将带你了解如何使用一个叫做<a class="ae jd" href="https://github.com/adap/flower" rel="noopener ugc nofollow" target="_blank">花</a>的框架来建立你自己的基于联合学习的模型。</p><p id="7e9c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们将着眼于跨设备和异步设计。这与<a class="ae jd" href="https://ai.googleblog.com/2017/04/federated-learning-collaborative.html" rel="noopener ugc nofollow" target="_blank"> GBoard </a>和<a class="ae jd" href="https://www.technologyreview.com/2019/12/11/131629/apple-ai-personalizes-siri-federated-learning/" rel="noopener ugc nofollow" target="_blank"> Siri </a>非常相似，在这种情况下，本地模型驻留在边缘设备(你的手机/ mac)上。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es je"><img src="../Images/ba4c20953d0d67fb1da03446eb9c541a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yVkKYw-Z8FfKEIz-YBjAHg.png"/></div></div><figcaption class="jq jr et er es js jt bd b be z dx translated">联合学习</figcaption></figure><p id="fde8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们直接进入构建您自己的模型所需的组件。联邦学习系统需要两个部分</p><ol class=""><li id="2e89" class="ju jv hi ih b ii ij im in iq jw iu jx iy jy jc jz ka kb kc bi translated">计算机网络服务器</li><li id="a669" class="ju jv hi ih b ii kd im ke iq kf iu kg iy kh jc jz ka kb kc bi translated">客户。</li></ol><p id="691a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">数据科学家可以完全控制服务器。服务器托管聚合逻辑，并确保所有设备都具有最新和更新的模型参数。</p><p id="a251" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">客户端(设备)有一个在本地数据上运行的本地模型。</p><p id="81b4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在我们的用例中，我们将遵循以下步骤。</p><ol class=""><li id="7de4" class="ju jv hi ih b ii ij im in iq jw iu jx iy jy jc jz ka kb kc bi translated">我们将构建一个简单的基于 pytorch 的神经网络模型来读取图像并对其进行分类。</li><li id="b478" class="ju jv hi ih b ii kd im ke iq kf iu kg iy kh jc jz ka kb kc bi translated">我们将首先在客户端的本地数据上训练模型。让我们从 3 个设备开始，因此我们在 3 个独立的设备中有 3 个本地运行的模型。</li><li id="a103" class="ju jv hi ih b ii kd im ke iq kf iu kg iy kh jc jz ka kb kc bi translated">一旦我们的模型被训练并且我们有了我们的模型参数，我们试着与服务器连接。</li><li id="da38" class="ju jv hi ih b ii kd im ke iq kf iu kg iy kh jc jz ka kb kc bi translated">然后，服务器根据某种策略接受或拒绝连接邀请。这里我们将简单地使用先来先服务的策略。</li><li id="9a8a" class="ju jv hi ih b ii kd im ke iq kf iu kg iy kh jc jz ka kb kc bi translated">如果连接成功，客户端会将模型参数发送给服务器。</li><li id="701a" class="ju jv hi ih b ii kd im ke iq kf iu kg iy kh jc jz ka kb kc bi translated">服务器等待所有 3 个模型参数，然后聚合它们，从而利用所有模型中的所有数据。</li><li id="6195" class="ju jv hi ih b ii kd im ke iq kf iu kg iy kh jc jz ka kb kc bi translated">这可以在我们想要训练数据的任意多个时期发生。</li><li id="b8e5" class="ju jv hi ih b ii kd im ke iq kf iu kg iy kh jc jz ka kb kc bi translated">然后，服务器将更新的权重参数发送回客户端。</li><li id="22a1" class="ju jv hi ih b ii kd im ke iq kf iu kg iy kh jc jz ka kb kc bi translated">客户端现在将使用权重进行图像分类。</li></ol><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es ki"><img src="../Images/d12084458d5fab9276bfd0dafe3e1af8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*eY92qwFPsxKNRg0OPirdSw.png"/></div></div></figure><p id="8d55" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们创建一个文件 caller server.py，并添加以下几行:</p><pre class="jf jg jh ji fd kj kk kl km aw kn bi"><span id="1bd8" class="ko kp hi kk b fi kq kr l ks kt">import flwr as fl<br/><br/># Start Flower server for three rounds of federated learning<br/>if __name__ == "__main__":<br/>    strategy = fl.server.strategy.FedAvg(<br/>        fraction_fit=0.1,<br/>        min_available_clients=3<br/>)</span><span id="ec54" class="ko kp hi kk b fi ku kr l ks kt">fl.server.start_server("[::]:8080", config={"num_rounds": 3}, , strategy=strategy)</span></pre><p id="a202" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这就是我们启动一个绑定到本地主机的服务器所需的全部内容。战略是我们的政策。Num_rounds 指定训练将持续 3 轮。根据先连接的设备，每轮可以有不同的客户端集。fraction_fit 在每轮中对所有可用客户端的 10%进行采样。min_available_client 是训练开始时需要连接的最小客户端数量。在这里，您可以找到定义策略的各种方法<a class="ae jd" href="https://github.com/adap/flower/blob/71f8226f2fb56d0624427f358b6805408945cd95/doc/source/strategies.rst" rel="noopener ugc nofollow" target="_blank">。</a></p><p id="81fc" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">您可以在 EC2 或 Sagemaker 的 AWS 中托管您的 server.py。或者在你自己的工作站上运行。</p><p id="9216" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在让我们写我们的客户。你可以在这里找到 colab 笔记本<a class="ae jd" href="https://colab.research.google.com/drive/1Gpc_ie2b126476DKRDT4OHe50tIAm7N5?usp=sharing" rel="noopener ugc nofollow" target="_blank">，在这里</a>找到 git <a class="ae jd" href="https://github.com/anki08/Build-your-own-Federated-Learning-model" rel="noopener ugc nofollow" target="_blank">上的代码。Flwr 是基于 GRPC，这是没有在免费的 collab 版本。您可以创建一个 docker 实例或在您的工作站上运行它。</a></p><p id="3d62" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">非基于 FL 的 ANN 和 FL 之间的唯一区别在于连接到服务器并获得更新的权重。我们将在这里查看笔记本的联合学习部分。</p><pre class="jf jg jh ji fd kj kk kl km aw kn bi"><span id="8acf" class="ko kp hi kk b fi kq kr l ks kt">class CifarClient(fl.client.NumPyClient):</span><span id="d631" class="ko kp hi kk b fi ku kr l ks kt">def get_parameters(self):<br/>    return [val.cpu().numpy() for _, val in   net.state_dict().items()]</span><span id="2f11" class="ko kp hi kk b fi ku kr l ks kt">def set_parameters(self, parameters):<br/>    params_dict = zip(net.state_dict().keys(), parameters)<br/>    state_dict = OrderedDict({k: torch.Tensor(v) for k, v in params_dict})<br/>    net.load_state_dict(state_dict, strict=True)</span><span id="d607" class="ko kp hi kk b fi ku kr l ks kt">def fit(self, parameters, config):<br/>    self.set_parameters(parameters)<br/>    train(net, trainloader, epochs=1)<br/>    return self.get_parameters(), len(trainloader), {}</span><span id="c95f" class="ko kp hi kk b fi ku kr l ks kt">def evaluate(self, parameters, config):</span><span id="1a9c" class="ko kp hi kk b fi ku kr l ks kt">    self.set_parameters(parameters)</span><span id="ee8e" class="ko kp hi kk b fi ku kr l ks kt">    loss, accuracy = test(net, testloader)</span><span id="4475" class="ko kp hi kk b fi ku kr l ks kt">    return float(loss), len(testloader), {"accuracy": accuracy}</span></pre><p id="65fd" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这是实现 flowr 的最重要的类。这个功能—</p><ol class=""><li id="d6b0" class="ju jv hi ih b ii ij im in iq jw iu jx iy jy jc jz ka kb kc bi translated">get_parameters:将模型参数作为 NumPy ndarrays 列表返回给服务器。</li><li id="d6ce" class="ju jv hi ih b ii kd im ke iq kf iu kg iy kh jc jz ka kb kc bi translated">set_parameters:从 NumPy ndarrays 列表中设置客户端中的模型参数。</li><li id="3845" class="ju jv hi ih b ii kd im ke iq kf iu kg iy kh jc jz ka kb kc bi translated">fit:设置模型参数，在客户端训练模型，并将更新后的模型参数返回给服务器。</li><li id="abc0" class="ju jv hi ih b ii kd im ke iq kf iu kg iy kh jc jz ka kb kc bi translated">评估:设置模型参数，评估客户端本地测试数据集上的模型，并将结果返回给服务器。</li></ol><p id="75af" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在，您可以运行最后一个单元，并检查您的模型的准确性如何受到集中训练的影响。(确保有 3 个 client.py 副本，因为我们提到了 min_available_clients = 3。</p><p id="5da0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">参考资料:</p><div class="kv kw ez fb kx ky"><a href="https://flower.dev/docs/installation.html" rel="noopener  ugc nofollow" target="_blank"><div class="kz ab dw"><div class="la ab lb cl cj lc"><h2 class="bd hj fi z dy ld ea eb le ed ef hh bi translated">安装花卉</h2><div class="lf l"><h3 class="bd b fi z dy ld ea eb le ed ef dx translated">Flower 需要 Python 3.6 或以上版本。PyPI 上提供了稳定版本:最新的(潜在的不稳定)变更…</h3></div><div class="lg l"><p class="bd b fp z dy ld ea eb le ed ef dx translated">花卉. dev</p></div></div><div class="lh l"><div class="li l lj lk ll lh lm jo ky"/></div></div></a></div><p id="31fc" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">【https://github.com/adap/flower T4】</p></div></div>    
</body>
</html>