<html>
<head>
<title>JUnit Testing in Android with Kotlin for Beginners | Hemcrest and Mockito</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在 Android 中使用 Kotlin 对初学者进行 JUnit 测试| Hemcrest 和 Mockito</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/junit-testing-in-android-with-kotlin-for-beginners-hemcrest-and-mockito-b731a74abaea?source=collection_archive---------0-----------------------#2021-08-14">https://medium.com/nerd-for-tech/junit-testing-in-android-with-kotlin-for-beginners-hemcrest-and-mockito-b731a74abaea?source=collection_archive---------0-----------------------#2021-08-14</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="2d63" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">~您编写的未经测试的代码越多，您需要检查错误的路径就越多</h2></div><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ix"><img src="../Images/c0aa4fd23eba3edde0b644a8364d7633.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oOEm-hEpn4wR_J0Fa0dQ0w.png"/></div></div></figure><p id="66a3" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">作为一名 Android 开发人员，当我开始学习 JUnit 测试用例时，我不得不访问许多网站来学习它，每个内容都有自己独特的表示单元测试的风格，但是我还没有找到一个地方可以一步一步地学习 JUnit 测试用例，但是不要担心，这就是我在这里讨论这个主题的原因</p><p id="d4a3" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">在这里，我将只涉及 JUnit 测试，但请继续关注下一个主题，即使用 Expresso 进行 UI 测试</p><p id="6a44" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">好了，不要再讨论了，让我们一步一步来</p><h1 id="0aff" class="kf kg hi bd kh ki kj kk kl km kn ko kp io kq ip kr ir ks is kt iu ku iv kv kw bi translated">什么是单元测试？</h1><ul class=""><li id="bfdb" class="kx ky hi jl b jm kz jp la js lb jw lc ka ld ke le lf lg lh bi translated">尝试和测试特定的单元(特定的边界)</li><li id="4c96" class="kx ky hi jl b jm li jp lj js lk jw ll ka lm ke le lf lg lh bi translated">单元可以是单个方法，或者一组方法，或者一组类</li></ul><h1 id="840c" class="kf kg hi bd kh ki kj kk kl km kn ko kp io kq ip kr ir ks is kt iu ku iv kv kw bi translated"><strong class="ak">单元测试的优势</strong></h1><p id="e09a" class="pw-post-body-paragraph jj jk hi jl b jm kz ij jo jp la im jr js ln ju jv jw lo jy jz ka lp kc kd ke hb bi translated">一旦我编写了单元测试，我将能够在几毫秒内自动运行单元测试，并检查特定方法的所有条件是否通过/或者我们可以说确保一个函数做它应该做的事情</p><h1 id="8951" class="kf kg hi bd kh ki kj kk kl km kn ko kp io kq ip kr ir ks is kt iu ku iv kv kw bi translated">创建第一个 Junit 测试用例</h1><p id="7bc9" class="pw-post-body-paragraph jj jk hi jl b jm kz ij jo jp la im jr js ln ju jv jw lo jy jz ka lp kc kd ke hb bi translated">让我们以一个我们想要为其编写测试用例的类为例，它有一个方法 isPositiveNumber，如果 Number 为正，则返回 true，否则返回 false</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es lq"><img src="../Images/fd73c63036d5db6ca6a5b14fa887fdc6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4UD38wUAuTtIUMFxxuB4Sw.png"/></div></div></figure><ul class=""><li id="0472" class="kx ky hi jl b jm jn jp jq js lr jw ls ka lt ke le lf lg lh bi translated">右键单击您想要编写测试用例的文件，导航到 GoTo-&gt; Test</li></ul><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es lu"><img src="../Images/4ca19952aad7c7f1271d488a6698ad8d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rWfcnRJw_gGZZ922Wnu9HQ.png"/></div></div></figure><h1 id="e5ad" class="kf kg hi bd kh ki kj kk kl km kn ko kp io kq ip kr ir ks is kt iu ku iv kv kw bi translated"><strong class="ak">注解</strong></h1><p id="71a0" class="pw-post-body-paragraph jj jk hi jl b jm kz ij jo jp la im jr js ln ju jv jw lo jy jz ka lp kc kd ke hb bi translated">让我们先了解一下注释</p><h2 id="47af" class="lv kg hi bd kh lw lx ly kl lz ma mb kp js mc md kr jw me mf kt ka mg mh kv mi bi translated">之前:-</h2><ul class=""><li id="13a3" class="kx ky hi jl b jm kz jp la js lb jw lc ka ld ke le lf lg lh bi translated">如果我们想在测试开始前执行一些操作，比如初始化一些变量等等</li><li id="3f1b" class="kx ky hi jl b jm li jp lj js lk jw ll ka lm ke le lf lg lh bi translated">它告诉 Junit 这个方法必须在每个测试用例之前运行</li></ul><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es mj"><img src="../Images/76b0e4a74429f50676b36ef300b2c51b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1088/format:webp/1*S2-fC5DfQstXQDEPjQn2uw.png"/></div></figure><h2 id="5979" class="lv kg hi bd kh lw lx ly kl lz ma mb kp js mc md kr jw me mf kt ka mg mh kv mi bi translated">@测试:-</h2><ul class=""><li id="0f2b" class="kx ky hi jl b jm kz jp la js lb jw lc ka ld ke le lf lg lh bi translated">Junit 中的测试是带有@Test 注释的方法注释</li><li id="ca6f" class="kx ky hi jl b jm li jp lj js lk jw ll ka lm ke le lf lg lh bi translated">在这里，我将编写实际的测试—如何进行？</li><li id="e048" class="kx ky hi jl b jm li jp lj js lk jw ll ka lm ke le lf lg lh bi translated">我需要调用方法 SUT &amp;确保它产生预期的输出</li></ul><blockquote class="mk"><p id="3e79" class="ml mm hi bd mn mo mp mq mr ms mt ke dx translated">注意:- SUT =被测系统，为你正在编写的测试用例命名类的标准方式</p></blockquote><figure class="mv mw mx my mz jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es mu"><img src="../Images/1be679edc7c9f3202ab9a22ab7b607db.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1zZ0DCR2ku0JTGxMVWUsyg.png"/></div></div></figure><ul class=""><li id="530f" class="kx ky hi jl b jm jn jp jq js lr jw ls ka lt ke le lf lg lh bi translated">使用@test 注释调用该类方法(isPositiveNumber())进行测试</li><li id="9c97" class="kx ky hi jl b jm li jp lj js lk jw ll ka lm ke le lf lg lh bi translated">我可以用条件断言/检查该方法，以查看预期的输出是否出现</li><li id="38d8" class="kx ky hi jl b jm li jp lj js lk jw ll ka lm ke le lf lg lh bi translated">在上面的示例中，负数作为参数传递</li><li id="72d1" class="kx ky hi jl b jm li jp lj js lk jw ll ka lm ke le lf lg lh bi translated"><strong class="jl hj"> assertTrue() </strong>检查输出是否为真，这意味着测试通过，否则测试失败</li><li id="09ee" class="kx ky hi jl b jm li jp lj js lk jw ll ka lm ke le lf lg lh bi translated">测试将失败，因为输出将为假</li></ul><h1 id="9115" class="kf kg hi bd kh ki kj kk kl km kn ko kp io kq ip kr ir ks is kt iu ku iv kv kw bi translated">单元测试的命名</h1><p id="2873" class="pw-post-body-paragraph jj jk hi jl b jm kz ij jo jp la im jr js ln ju jv jw lo jy jz ka lp kc kd ke hb bi translated">这就是我们应该如何命名我们的功能/单元测试用例，虽然不是强制性的，但这是命名测试用例的标准方式</p><p id="8a4e" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated"><strong class="jl hj"> &lt;工作单元&gt; _ &lt;状态下测试&gt; _ &lt;预期行为&gt; </strong></p><h1 id="562d" class="kf kg hi bd kh ki kj kk kl km kn ko kp io kq ip kr ir ks is kt iu ku iv kv kw bi translated">哈姆克雷斯特图书馆</h1><ul class=""><li id="a98b" class="kx ky hi jl b jm kz jp la js lb jw lc ka ld ke le lf lg lh bi translated">Hamcrest 是用于单元测试的著名框架</li><li id="3877" class="kx ky hi jl b jm li jp lj js lk jw ll ka lm ke le lf lg lh bi translated">它被捆绑在 JUnit 中，简单地说，它使用现有的谓词——称为匹配器类——来生成断言</li></ul><h2 id="3348" class="lv kg hi bd kh lw lx ly kl lz ma mb kp js mc md kr jw me mf kt ka mg mh kv mi bi translated">示例:-</h2><ul class=""><li id="5167" class="kx ky hi jl b jm kz jp la js lb jw lc ka ld ke le lf lg lh bi translated">使用 reverseString()方法创建了类 StringReverser</li><li id="f549" class="kx ky hi jl b jm li jp lj js lk jw ll ka lm ke le lf lg lh bi translated">创建了一个测试用例，并使用 hamcrest 库来断言响应</li><li id="f3fc" class="kx ky hi jl b jm li jp lj js lk jw ll ka lm ke le lf lg lh bi translated">如你所见，我们使用了带有参数的 assertThat()函数，该函数包含“is ”,它是以下包的一部分:-<br/><strong class="jl hj"><em class="na">“import org . ham crest . corematchers . * "</em></strong></li><li id="6a28" class="kx ky hi jl b jm li jp lj js lk jw ll ka lm ke le lf lg lh bi translated">因此，这个测试测试当空字符串被输入到 reverse 方法中时，空字符串被返回，因为空字符串的反转也是空字符串</li></ul><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es nb"><img src="../Images/6b93d25578309f023435f6e84fffa2b7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UV2cwQy1sZnIH4dpPcnIPQ.png"/></div></div><figcaption class="nc nd et er es ne nf bd b be z dx translated">使用 hamcrest 进行 JUnit 测试</figcaption></figure><p id="2a6a" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">我希望你对我们如何在 android 中编写单元测试用例有所了解🤘</p><p id="a95c" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">我们去莫奇托吧</p><h1 id="acd3" class="kf kg hi bd kh ki kj kk kl km kn ko kp io kq ip kr ir ks is kt iu ku iv kv kw bi translated">使用 Kotlin 的 Android 中的 Mockito</h1><ul class=""><li id="fb9e" class="kx ky hi jl b jm kz jp la js lb jw lc ka ld ke le lf lg lh bi translated">Mockito 是 android 中的一个框架，它帮助你初始化你想要测试的类，也就是创建你的 mocks</li><li id="e1c1" class="kx ky hi jl b jm li jp lj js lk jw ll ka lm ke le lf lg lh bi translated">基本上，在真实的场景中，我们可能有复杂的类，其中可能包含许多依赖关系，所以手动初始化一个类并不总是可能的，这里 Mockito 来拯救</li></ul><h1 id="6204" class="kf kg hi bd kh ki kj kk kl km kn ko kp io kq ip kr ir ks is kt iu ku iv kv kw bi translated">模仿一个类/对象的两种方法</h1><h2 id="49b7" class="lv kg hi bd kh lw lx ly kl lz ma mb kp js mc md kr jw me mf kt ka mg mh kv mi bi translated">一种是使用@Mock 注释</h2><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ng"><img src="../Images/5bc4c84414bc53504bc646b53bdba117.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*p35V2LpbMJKnOMwcZYbsfw.png"/></div></div></figure><h2 id="e253" class="lv kg hi bd kh lw lx ly kl lz ma mb kp js mc md kr jw me mf kt ka mg mh kv mi bi translated">其次是使用模拟功能</h2><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es nh"><img src="../Images/267ae9bafa1a9a0becaf26a1fab8c42b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OJvxVU-eItQTvUNIyh_6Cw.png"/></div></div></figure><p id="2b7c" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">它创建一个类/接口的模拟对象，该对象以 classToMock 作为参数</p><h1 id="6ffc" class="kf kg hi bd kh ki kj kk kl km kn ko kp io kq ip kr ir ks is kt iu ku iv kv kw bi translated">莫奇托测试赛跑运动员</h1><ul class=""><li id="af98" class="kx ky hi jl b jm kz jp la js lb jw lc ka ld ke le lf lg lh bi translated">用 JUnit special @RunWith 注释测试。然后将 MockitoJUnitRunner 定义为其参数</li></ul><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ni"><img src="../Images/ff17447c80b1f47f7e746c2f8d61dd0d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WvCYQGYBhet2prcXOepzcg.png"/></div></div></figure><ul class=""><li id="900c" class="kx ky hi jl b jm jn jp jq js lr jw ls ka lt ke le lf lg lh bi translated">此后，我不必显式初始化对象/模拟——只需用@Mock 对它们进行注释</li><li id="e4a1" class="kx ky hi jl b jm li jp lj js lk jw ll ka lm ke le lf lg lh bi translated">Mockito 是一个特殊的框架，它减少了实现测试加倍所涉及的工作</li></ul><blockquote class="mk"><p id="5e8f" class="ml mm hi bd mn mo mp mq mr ms mt ke dx translated">具有外部依赖性的单元测试类称为测试双精度测试</p></blockquote><p id="cfaa" class="pw-post-body-paragraph jj jk hi jl b jm nj ij jo jp nk im jr js nl ju jv jw nm jy jz ka nn kc kd ke hb bi translated">希望你能抓住一些东西，我已经用了非常简单的步骤让你明白——我唯一需要的是一些耐心，但是相信我，在这之后你将不必去任何其他网站的任何地方开始你的测试用例</p><p id="66a4" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">让我们互相学习 Mockito 最重要的用法</p><h1 id="1b36" class="kf kg hi bd kh ki kj kk kl km kn ko kp io kq ip kr ir ks is kt iu ku iv kv kw bi translated"><strong class="ak">在 mockito 中验证</strong></h1><p id="0816" class="pw-post-body-paragraph jj jk hi jl b jm kz ij jo jp la im jr js ln ju jv jw lo jy jz ka lp kc kd ke hb bi translated">verify 是 Mockito 的断言，它验证在特定的 mock 上调用了某个方法</p><ul class=""><li id="b36b" class="kx ky hi jl b jm jn jp jq js lr jw ls ka lt ke le lf lg lh bi translated">示例-验证(运算符)。添加(a，b)</li><li id="18b7" class="kx ky hi jl b jm li jp lj js lk jw ll ka lm ke le lf lg lh bi translated">这意味着在 operators 对象上验证是否调用了 add 方法</li></ul><p id="ae3f" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">所以有时我们不需要方法的响应，我们只是想知道函数是否被调用取决于我们的条件，这里验证方法进入图片</p><ul class=""><li id="03c6" class="kx ky hi jl b jm jn jp jq js lr jw ls ka lt ke le lf lg lh bi translated">我们也有更多的 mockito 函数，比如 when，然后返回一些方法来测试我们的单元</li></ul><h1 id="eb22" class="kf kg hi bd kh ki kj kk kl km kn ko kp io kq ip kr ir ks is kt iu ku iv kv kw bi translated">示例— Mockito 测试用例网络助手类</h1><p id="7e93" class="pw-post-body-paragraph jj jk hi jl b jm kz ij jo jp la im jr js ln ju jv jw lo jy jz ka lp kc kd ke hb bi translated">我写了一个名为 NetworkHelper 的类，它有一个总是返回 true 的方法 isConnectedToNetwork</p><p id="68ec" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">让我们使用 Mockito 来看看 NetworkHelperTest</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="no np l"/></div></figure><h1 id="22d8" class="kf kg hi bd kh ki kj kk kl km kn ko kp io kq ip kr ir ks is kt iu ku iv kv kw bi translated">参考资料:-</h1><ul class=""><li id="c439" class="kx ky hi jl b jm kz jp la js lb jw lc ka ld ke le lf lg lh bi translated"><a class="ae nq" href="https://github.com/mockito/mockito/wiki" rel="noopener ugc nofollow" target="_blank">https://github.com/mockito/mockito/wiki</a></li><li id="d127" class="kx ky hi jl b jm li jp lj js lk jw ll ka lm ke le lf lg lh bi translated"><a class="ae nq" href="https://www.raywenderlich.com/195-android-unit-testing-with-mockito" rel="noopener ugc nofollow" target="_blank">https://www . raywenderlich . com/195-Android-unit-testing-with-mock ITO</a></li></ul><p id="f405" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">就这样伙计们！我希望并且希望你们都已经很好地了解了如何编写单元测试用例，我知道这有点冗长，但是也值得一读</p><p id="6a4e" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">下节课再见，别忘了继续关注我</p><p id="7832" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated"><a class="ae nq" href="https://puneet-grover.medium.com/" rel="noopener">媒体</a>、<a class="ae nq" href="http://www.linkedin.com/in/puneet-grover-android-soft" rel="noopener ugc nofollow" target="_blank">领英</a>和<a class="ae nq" href="https://twitter.com/puneetgrover_" rel="noopener ugc nofollow" target="_blank">推特</a></p><p id="9290" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">编码快乐！</p></div></div>    
</body>
</html>