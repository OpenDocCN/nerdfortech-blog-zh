<html>
<head>
<title>Polyfill Part 3 🎥: for Call(), Apply() and Bind() ⏳</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">聚合填料第 3 部分🎥:对于 Call()，Apply()和 Bind()⏳</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/polyfill-part-3-for-call-apply-and-bind-169a05d33d02?source=collection_archive---------2-----------------------#2022-09-23">https://medium.com/nerd-for-tech/polyfill-part-3-for-call-apply-and-bind-169a05d33d02?source=collection_archive---------2-----------------------#2022-09-23</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/78bcc359ecfcefc194464159f8d6ad2a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uUZwZ9lgwdQ8ksNVRCnulA.jpeg"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">亚历山德拉·奥尼索在<a class="ae iu" href="https://unsplash.com/?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><p id="e6f5" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">嘿！你可能在面试中被问到过这个问题，也可能没有。不管是什么情况，多了解一些也无妨。所以在这里我将分享如何为<strong class="ix hj">调用</strong>、<strong class="ix hj">应用、</strong>和<strong class="ix hj">绑定</strong>方法创建 polyfill。</p><blockquote class="jt ju jv"><p id="31d1" class="iv iw jw ix b iy iz ja jb jc jd je jf jx jh ji jj jy jl jm jn jz jp jq jr js hb bi translated"><strong class="ix hj"> <em class="hi">咱们码！🤽‍♀ </em> </strong></p></blockquote><h2 id="d5df" class="ka kb hi bd kc kd ke kf kg kh ki kj kk jg kl km kn jk ko kp kq jo kr ks kt ku bi translated">调用的 Pollyfill():</h2><p id="65e1" class="pw-post-body-paragraph iv iw hi ix b iy kv ja jb jc kw je jf jg kx ji jj jk ky jm jn jo kz jq jr js hb bi translated">让我们先从语法上看一下<strong class="ix hj">function . prototype . call()</strong>是如何工作的:</p><pre class="la lb lc ld fd le lf lg lh aw li bi"><span id="f9c9" class="ka kb hi lf b fi lj lk l ll lm">myFunc.call(context, arg1, /* …, */ argN)</span></pre><p id="144c" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">所以，原来的<strong class="ix hj">功能</strong>。<strong class="ix hj">原型</strong>。<strong class="ix hj">调用</strong>函数需要一个上下文和逗号分隔的参数。</p><p id="d72d" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">基于此，让我们构建自己的<strong class="ix hj">调用</strong>函数:</p><pre class="la lb lc ld fd le lf lg lh aw li bi"><span id="3041" class="ka kb hi lf b fi lj lk l ll lm">Function.prototype.<strong class="lf hj">myCall </strong>= function (context, ...args) {</span><span id="12ed" class="ka kb hi lf b fi ln lk l ll lm">  if (typeof this !== "function") {<br/>     throw new Error(this + ".call is not a function");<br/>  }</span><span id="3d1b" class="ka kb hi lf b fi ln lk l ll lm">  context.tempRef = this;</span><span id="8293" class="ka kb hi lf b fi ln lk l ll lm"><strong class="lf hj">  </strong>let <strong class="lf hj">result </strong>= context.tempRef(...args);</span><span id="3a99" class="ka kb hi lf b fi ln lk l ll lm">  <strong class="lf hj">delete </strong>context.tempRef;</span><span id="5fd0" class="ka kb hi lf b fi ln lk l ll lm">  return <strong class="lf hj">result</strong>;</span><span id="63f7" class="ka kb hi lf b fi ln lk l ll lm">};</span></pre><h2 id="20b7" class="ka kb hi bd kc kd ke kf kg kh ki kj kk jg kl km kn jk ko kp kq jo kr ks kt ku bi translated">应用的 Pollyfill():</h2><p id="de00" class="pw-post-body-paragraph iv iw hi ix b iy kv ja jb jc kw je jf jg kx ji jj jk ky jm jn jo kz jq jr js hb bi translated">让我们首先从语法上看一下<strong class="ix hj">function . prototype . apply()</strong>是如何工作的:</p><pre class="la lb lc ld fd le lf lg lh aw li bi"><span id="986e" class="ka kb hi lf b fi lj lk l ll lm">myFunc.apply(thisArg, argsArray)</span></pre><p id="d59d" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">所以，原来的<strong class="ix hj">功能</strong>。<strong class="ix hj">原型</strong>。<strong class="ix hj"> apply </strong>函数接受一个上下文和一个参数数组。</p><p id="c715" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">基于此，让我们构建自己的<strong class="ix hj">应用</strong>函数:</p><pre class="la lb lc ld fd le lf lg lh aw li bi"><span id="4edb" class="ka kb hi lf b fi lj lk l ll lm">Function.prototype.<strong class="lf hj">myApply </strong>= function (context, args) {</span><span id="0c02" class="ka kb hi lf b fi ln lk l ll lm">  if (typeof this !== "function") {<br/>       throw new Error(this + ".apply is not a function");<br/>  }</span><span id="5bf8" class="ka kb hi lf b fi ln lk l ll lm">  context.tempRef = this;</span><span id="0d09" class="ka kb hi lf b fi ln lk l ll lm">  let <strong class="lf hj">result </strong>= context.tempRef(...args);</span><span id="8e81" class="ka kb hi lf b fi ln lk l ll lm"><strong class="lf hj">  delete </strong>context.tempRef;</span><span id="7fa1" class="ka kb hi lf b fi ln lk l ll lm">  return <strong class="lf hj">result</strong>;</span><span id="a156" class="ka kb hi lf b fi ln lk l ll lm">};</span></pre><blockquote class="jt ju jv"><p id="f87c" class="iv iw jw ix b iy iz ja jb jc jd je jf jx jh ji jj jy jl jm jn jz jp jq jr js hb bi translated">它类似于<strong class="ix hj">调用</strong>的 polyfill，除了这里我们得到的是一个参数数组，而不是逗号分隔的参数。</p></blockquote><h2 id="59ea" class="ka kb hi bd kc kd ke kf kg kh ki kj kk jg kl km kn jk ko kp kq jo kr ks kt ku bi translated">Bind()的 Pollyfill:</h2><p id="833d" class="pw-post-body-paragraph iv iw hi ix b iy kv ja jb jc kw je jf jg kx ji jj jk ky jm jn jo kz jq jr js hb bi translated">让我们首先从语法上看一下<strong class="ix hj">function . prototype . bind()</strong>是如何工作的:</p><pre class="la lb lc ld fd le lf lg lh aw li bi"><span id="7b96" class="ka kb hi lf b fi lj lk l ll lm">myFunc.bind(thisArg, arg1, arg2, /* …, */ argN)</span></pre><p id="47e9" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">所以，原来的<strong class="ix hj">功能</strong>。<strong class="ix hj">原型</strong>。<strong class="ix hj"> bind </strong>函数接受一个上下文和逗号分隔的参数。</p><p id="0673" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">基于此，让我们构建我们自己的<strong class="ix hj">绑定</strong>函数:</p><pre class="la lb lc ld fd le lf lg lh aw li bi"><span id="417b" class="ka kb hi lf b fi lj lk l ll lm">Function.prototype.<strong class="lf hj">myBind </strong>= function(<strong class="lf hj">context</strong>, ...<strong class="lf hj">args</strong>){<br/>  if (typeof this !== "<strong class="lf hj">function</strong>") {<br/>    throw new Error(this + ".bind is not a function");<br/>  }<br/>  let <strong class="lf hj">callbackFn </strong>= this;</span><span id="4ca8" class="ka kb hi lf b fi ln lk l ll lm">  return function(){        <br/>    <strong class="lf hj">callbackFn</strong>.call(<strong class="lf hj">context</strong>, ...[...<strong class="lf hj">args</strong>, ...<strong class="lf hj">arguments</strong>]);<br/>  }<br/>}</span></pre></div><div class="ab cl lo lp gp lq" role="separator"><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt"/></div><div class="hb hc hd he hf"><p id="b313" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><em class="jw">如果你喜欢这个帖子，请点击掌声👏</em> <em class="jw">图标下方，关注我这里的</em><a class="ae iu" href="https://tanyas27.medium.com/" rel="noopener"><em class="jw"/></a><em class="jw">了解更多！</em></p><p id="9002" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><em class="jw">下面跟随</em><strong class="ix hj"><em class="jw">poly fill</em></strong><em class="jw">系列:</em></p><div class="lv lw ez fb lx ly"><a rel="noopener follow" target="_blank" href="/nerd-for-tech/polyfill-for-array-map-filter-and-reduce-e3e637e0d73b"><div class="lz ab dw"><div class="ma ab mb cl cj mc"><h2 class="bd hj fi z dy md ea eb me ed ef hh bi translated">用于数组映射()的 Polyfill、filter()和 reduce()💁</h2><div class="mf l"><h3 class="bd b fi z dy md ea eb me ed ef dx translated">嘿！你可能在面试中被问到过这个问题，也可能没有。不管是什么情况，它不会伤害到…</h3></div><div class="mg l"><p class="bd b fp z dy md ea eb me ed ef dx translated">medium.com</p></div></div><div class="mh l"><div class="mi l mj mk ml mh mm io ly"/></div></div></a></div><div class="lv lw ez fb lx ly"><a href="https://tanyas27.medium.com/polyfill-for-array-methods-part-2-foreach-81638691efe4" rel="noopener follow" target="_blank"><div class="lz ab dw"><div class="ma ab mb cl cj mc"><h2 class="bd hj fi z dy md ea eb me ed ef hh bi translated">数组方法的聚合填充第 2 部分🎥:forEach()</h2><div class="mf l"><h3 class="bd b fi z dy md ea eb me ed ef dx translated">嘿！所以在之前的博客中，我分享了如何为 map、fill 和 reduce 数组方法创建 polyfill。以防你…</h3></div><div class="mg l"><p class="bd b fp z dy md ea eb me ed ef dx translated">tanyas27.medium.com</p></div></div><div class="mh l"><div class="mn l mj mk ml mh mm io ly"/></div></div></a></div></div><div class="ab cl lo lp gp lq" role="separator"><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt"/></div><div class="hb hc hd he hf"><div class="la lb lc ld fd ly"><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/call" rel="noopener  ugc nofollow" target="_blank"><div class="lz ab dw"><div class="ma ab mb cl cj mc"><h2 class="bd hj fi z dy md ea eb me ed ef hh bi translated">function . prototype . call()-JavaScript | MDN</h2><div class="mf l"><h3 class="bd b fi z dy md ea eb me ed ef dx translated">注意:除了 call()接受一个参数列表，而 apply()接受一个…</h3></div><div class="mg l"><p class="bd b fp z dy md ea eb me ed ef dx translated">developer.mozilla.org</p></div></div><div class="mh l"><div class="mo l mj mk ml mh mm io ly"/></div></div></a></div><div class="lv lw ez fb lx ly"><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/apply" rel="noopener  ugc nofollow" target="_blank"><div class="lz ab dw"><div class="ma ab mb cl cj mc"><h2 class="bd hj fi z dy md ea eb me ed ef hh bi translated">function . prototype . apply()-JavaScript | MDN</h2><div class="mf l"><h3 class="bd b fi z dy md ea eb me ed ef dx translated">注意:除了 call()接受一个参数列表，而 apply()接受一个…</h3></div><div class="mg l"><p class="bd b fp z dy md ea eb me ed ef dx translated">developer.mozilla.org</p></div></div><div class="mh l"><div class="mp l mj mk ml mh mm io ly"/></div></div></a></div><div class="lv lw ez fb lx ly"><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/bind" rel="noopener  ugc nofollow" target="_blank"><div class="lz ab dw"><div class="ma ab mb cl cj mc"><h2 class="bd hj fi z dy md ea eb me ed ef hh bi translated">function . prototype . bind()-JavaScript | MDN</h2><div class="mf l"><h3 class="bd b fi z dy md ea eb me ed ef dx translated">函数创建了一个新的绑定函数。调用绑定函数通常会导致执行…</h3></div><div class="mg l"><p class="bd b fp z dy md ea eb me ed ef dx translated">developer.mozilla.org</p></div></div><div class="mh l"><div class="mq l mj mk ml mh mm io ly"/></div></div></a></div></div></div>    
</body>
</html>