<html>
<head>
<title>Stacked Package — Better Busy and Error Handling</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">堆叠封装—更好的繁忙和错误处理</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/stacked-package-better-busy-and-error-handling-643b0131f0a6?source=collection_archive---------4-----------------------#2021-07-19">https://medium.com/nerd-for-tech/stacked-package-better-busy-and-error-handling-643b0131f0a6?source=collection_archive---------4-----------------------#2021-07-19</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="e3f6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">你是否曾经因为在你的UI中塞满了太多的setstate()，而感到沮丧？当然我们都经历过，至少我经历过。所以我开始用bloC。但是使用<a class="ae jd" href="https://pub.dev/packages/flutter_bloc" rel="noopener ugc nofollow" target="_blank"> bloC </a>有时候有些矫枉过正。所以我已经开始使用<a class="ae jd" href="https://pub.dev/packages/provider" rel="noopener ugc nofollow" target="_blank"> <em class="je">提供者</em> </a> <em class="je">包</em>，它帮助我写出干净的代码。但是当我想导航到另一个页面，显示一个简单的小吃店时，我仍然想将我的构建上下文传递给方法，这是我不喜欢的。这时我发现了一个名为<code class="du jf jg jh ji b"><strong class="ih hj">stacked</strong></code>的很棒的包，它是内置的<code class="du jf jg jh ji b">ChangeNotifier</code></p><p id="2a11" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">堆叠封装中有<strong class="ih hj">多种可用特性</strong>。在这篇文章中，我将告诉你我们如何使用这个包更有效地处理错误和加载状态。</p><p id="f2eb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们看一个简单的例子，我们可以使用堆栈封装实现一个简单的递增计数器。</p><p id="8721" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">首先，让我们看看我们的视图模型</p><figure class="jj jk jl jm fd jn"><div class="bz dy l di"><div class="jo jp l"/></div><figcaption class="jq jr et er es js jt bd b be z dx translated"><strong class="ak"> BaseViewModel只是changeNotifier的扩展，但它提供了更多的功能</strong></figcaption></figure><p id="1a45" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">BaseViewModel有许多子类型，如FutureViewModel、ReactiveViewModel、StreamViewModel等等。它们扩展了BaseviewModel的功能，并减少了许多样板代码。</p><p id="0e86" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">下面是我们简单的计数器小部件(我们的视图)。</p><figure class="jj jk jl jm fd jn"><div class="bz dy l di"><div class="jo jp l"/></div></figure><p id="3ee3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果你看上面的视图(小部件)，我们用<strong class="ih hj"> ViewModelBuilder </strong>包装它。</p><ol class=""><li id="472c" class="ju jv hi ih b ii ij im in iq jw iu jx iy jy jc jz ka kb kc bi translated"><strong class="ih hj"> ViewModelBuilder &lt; T &gt;。无功()</strong></li></ol><ul class=""><li id="eb59" class="ju jv hi ih b ii ij im in iq jw iu jx iy jy jc kd ka kb kc bi translated">T将是我们想要提供的视图模型的类型。(<code class="du jf jg jh ji b">CounterViewModel </code>在这种情况下)</li><li id="64e5" class="ju jv hi ih b ii ke im kf iq kg iu kh iy ki jc kd ka kb kc bi translated">viewModelBuilder接受一个回调，该回调将创建一个ViewModel实例。</li><li id="dfab" class="ju jv hi ih b ii ke im kf iq kg iu kh iy ki jc kd ka kb kc bi translated">每当从ViewModel调用notifyListeners()时，如果它是一个<strong class="ih hj">viewmodelbuilder . reactive()</strong>，构建器将重新构建</li><li id="eba1" class="ju jv hi ih b ii ke im kf iq kg iu kh iy ki jc kd ka kb kc bi translated">还有另一个版本叫做<strong class="ih hj">viewmodelbuilder . non reactive()，</strong>当你调用notifyListeners()时，它不会被重新构建。</li></ul><p id="c8b8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我希望你能很好地理解上面的代码，因为它看起来完全像一个changeNotifier代码。那么这有什么特别的呢？为什么我这么夸大这个包裹？让我们看看</p><figure class="jj jk jl jm fd jn er es paragraph-image"><div role="button" tabindex="0" class="kk kl di km bf kn"><div class="er es kj"><img src="../Images/2c22689f41cbb9aa445a747bd807520b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tz7GMzuomveJwAjdjq88bQ.jpeg"/></div></div><figcaption class="jq jr et er es js jt bd b be z dx translated">照片由<a class="ae jd" href="https://unsplash.com/@mike_van_den_bos?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">迈克·范·登博斯</a>在<a class="ae jd" href="https://unsplash.com/s/photos/loading?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><h1 id="bd74" class="kq kr hi bd ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln bi translated"><strong class="ak"> 1。减负荷逻辑锅炉板代码</strong></h1><p id="13cb" class="pw-post-body-paragraph if ig hi ih b ii lo ik il im lp io ip iq lq is it iu lr iw ix iy ls ja jb jc hb bi translated">你有没有写过这样的加载逻辑，</p><figure class="jj jk jl jm fd jn"><div class="bz dy l di"><div class="jo jp l"/></div></figure><p id="df34" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">那么你必须做这样的事情，</p><figure class="jj jk jl jm fd jn"><div class="bz dy l di"><div class="jo jp l"/></div></figure><h2 id="4b6a" class="lt kr hi bd ks lu lv lw kw lx ly lz la iq ma mb le iu mc md li iy me mf lm mg bi translated">1.伊斯布什()</h2><p id="ef53" class="pw-post-body-paragraph if ig hi ih b ii lo ik il im lp io ip iq lq is it iu lr iw ix iy ls ja jb jc hb bi translated">但是用stacked你可以做一些事情，</p><figure class="jj jk jl jm fd jn"><div class="bz dy l di"><div class="jo jp l"/></div></figure><p id="93ea" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如你所见，我们没有维护任何用于维护加载状态的布尔变量。包裹会帮你处理的。</p><figure class="jj jk jl jm fd jn"><div class="bz dy l di"><div class="jo jp l"/></div></figure><p id="046c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> 2。</strong>忙碌(对象)</p><p id="147e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">假设您想要维护单独变量的加载状态，而不是整个视图模型的加载状态。您可以使用<code class="du jf jg jh ji b">setBusyForObject()</code>，它将让您根据传入的对象的hashcode来设置忙碌状态。</p><p id="50df" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在viewModel中使用setBusyForObject()并传递您想要设置忙碌状态的对象和一个表示它是否忙碌的布尔值。</p><figure class="jj jk jl jm fd jn"><div class="bz dy l di"><div class="jo jp l"/></div></figure><p id="a141" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在视图中，执行如下操作</p><pre class="jj jk jl jm fd mh ji mi mj aw mk bi"><span id="bd1e" class="lt kr hi ji b fi ml mm l mn mo"><strong class="ji hj">viewModel.busy(viewModel.post)</strong> <br/>             ? LoadingWidget() <br/>             : MyWidget(viewModel.post)</span></pre><p id="5372" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这种方法非常有用，它不是让整个视图模型忙碌起来，而是精确地针对一个属性。</p><blockquote class="mp mq mr"><p id="69fc" class="if ig je ih b ii ij ik il im in io ip ms ir is it mt iv iw ix mu iz ja jb jc hb bi translated">它使用hashcode，如果你想使用原始类型，让它们成为final或者const</p></blockquote><pre class="jj jk jl jm fd mh ji mi mj aw mk bi"><span id="775f" class="lt kr hi ji b fi ml mm l mn mo">class PostViewModel extends BaseViewModel{<br/>   final String initKey = 'initialized';<br/>   void init(){<br/>      setBusyForObject(initKey,true);<br/>      //do initialization<br/>      setBusyForObject(initKey,false); <br/>  }<br/>}</span></pre><p id="f792" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在UI中，您可以使用字符串键来检查繁忙程度，</p><pre class="jj jk jl jm fd mh ji mi mj aw mk bi"><span id="2ac6" class="lt kr hi ji b fi ml mm l mn mo"><strong class="ji hj">viewModel.busy(viewModel.initKey)</strong> ? LoadingWidget() : MyWidget()</span></pre><p id="d66e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">3 .任意对象集合</p><ul class=""><li id="d0f1" class="ju jv hi ih b ii ij im in iq jw iu jx iy jy jc kd ka kb kc bi translated">还有另一种方法来检查<strong class="ih hj"> <em class="je">是否有任何对象忙</em> </strong></li></ul><pre class="jj jk jl jm fd mh ji mi mj aw mk bi"><span id="b6f4" class="lt kr hi ji b fi ml mm l mn mo"><strong class="ji hj">viewModel.anyObjectsBusy</strong> ? LoadingWidget() : MyWidget()</span></pre><p id="698c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">当我们初始化一大堆对象，并且希望在UI中显示某些内容之前初始化所有对象时，上面的方法非常方便。</p><p id="24fc" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">4.runBusyForFuture(未来)</p><p id="ca9d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果我们想要运行一个长时间运行的任务，并且想要根据任务的完成状态自动设置忙碌状态，我们可以使用runBusyForFuture()</p><figure class="jj jk jl jm fd jn"><div class="bz dy l di"><div class="jo jp l"/></div></figure><p id="eac5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">runBusyFuture将会有一个未来，</p><ol class=""><li id="6541" class="ju jv hi ih b ii ij im in iq jw iu jx iy jy jc jz ka kb kc bi translated">对于整个ViewModel或传入的对象，将Busy state设置为true。</li><li id="d970" class="ju jv hi ih b ii ke im kf iq kg iu kh iy ki jc jz ka kb kc bi translated">计算未来。</li><li id="1e35" class="ju jv hi ih b ii ke im kf iq kg iu kh iy ki jc jz ka kb kc bi translated">将忙状态设置为假。</li><li id="422f" class="ju jv hi ih b ii ke im kf iq kg iu kh iy ki jc jz ka kb kc bi translated">返回结果。</li><li id="ddcb" class="ju jv hi ih b ii ke im kf iq kg iu kh iy ki jc jz ka kb kc bi translated">还为您处理错误(稍后将详细介绍)</li></ol><p id="d4bd" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">您也可以传递一个对象来设置该特定对象的忙碌状态</p><pre class="jj jk jl jm fd mh ji mi mj aw mk bi"><span id="dc9e" class="lt kr hi ji b fi ml mm l mn mo">void getAllPost() async{<br/>   allPosts = await  runBusyFuture(myApiService.getAllPosts(),<strong class="ji hj">busyObject:allPosts</strong>);<br/>   notifyListeners();<br/>}</span></pre><p id="2065" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">您还可以将一个字符串传递给<code class="du jf jg jh ji b">busyObject</code>，</p><pre class="jj jk jl jm fd mh ji mi mj aw mk bi"><span id="03f5" class="lt kr hi ji b fi ml mm l mn mo">void updateItem(int id) async{<br/>   <strong class="ji hj">String updateKey = '$id update-key';</strong><br/>  _post = await runBusyFuture(<br/>          myApiService.fetchPost(id),<strong class="ji hj">busyObject: </strong>updateKey);<br/>   notifyListeners();<br/>}</span></pre><p id="bb8c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">然后你可以在用户界面中使用它，</p><pre class="jj jk jl jm fd mh ji mi mj aw mk bi"><span id="d7aa" class="lt kr hi ji b fi ml mm l mn mo">viewModel.busy('$id update-key') ? LoadingWidget() : MyWidget(id)</span></pre></div><div class="ab cl mv mw gp mx" role="separator"><span class="my bw bk mz na nb"/><span class="my bw bk mz na nb"/><span class="my bw bk mz na"/></div><div class="hb hc hd he hf"><figure class="jj jk jl jm fd jn er es paragraph-image"><div role="button" tabindex="0" class="kk kl di km bf kn"><div class="er es nc"><img src="../Images/d372638bba6104c8d2472bfd0eb30468.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EfKPwQM0KpHlr2B9_ZPaAQ.jpeg"/></div></div><figcaption class="jq jr et er es js jt bd b be z dx translated">在<a class="ae jd" href="https://unsplash.com/s/photos/error?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上由<a class="ae jd" href="https://unsplash.com/@visuals?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">视觉</a>拍摄的照片</figcaption></figure><h1 id="e21e" class="kq kr hi bd ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln bi translated">2.错误处理变得简单</h1><p id="d055" class="pw-post-body-paragraph if ig hi ih b ii lo ik il im lp io ip iq lq is it iu lr iw ix iy ls ja jb jc hb bi translated">类似于繁忙处理，我们可以使用<code class="du jf jg jh ji b">stacked </code>包轻松处理错误。它为我们做了一切，我们可以在用户界面中访问它们，并相应地显示小部件。</p><ol class=""><li id="b203" class="ju jv hi ih b ii ij im in iq jw iu jx iy jy jc jz ka kb kc bi translated"><strong class="ih hj">设置错误(错误)</strong></li></ol><p id="4bfb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">使用这种方法，您可以设置整个视图模型的误差。</p><pre class="jj jk jl jm fd mh ji mi mj aw mk bi"><span id="42d7" class="lt kr hi ji b fi ml mm l mn mo">setError(‘something went wrong’)</span></pre><p id="29f1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">并在UI中访问它，</p><pre class="jj jk jl jm fd mh ji mi mj aw mk bi"><span id="c7c7" class="lt kr hi ji b fi ml mm l mn mo"><strong class="ji hj">viewModel.hasError</strong> <br/>        ? Text(<strong class="ji hj">viewModel.error(viewModel)</strong>)//'something went wrong'<br/>        : Text(‘success’)</span></pre><ol class=""><li id="9389" class="ju jv hi ih b ii ij im in iq jw iu jx iy jy jc jz ka kb kc bi translated"><code class="du jf jg jh ji b">ViewModel.hasError</code>告知我们的视图模型中是否有错误。</li><li id="b8ec" class="ju jv hi ih b ii ke im kf iq kg iu kh iy ki jc jz ka kb kc bi translated"><code class="du jf jg jh ji b">viewModel.error(object)</code>，这里我们已经传递了ViewModel本身，所以它将获取我们的viewModel中的错误。</li></ol></div><div class="ab cl mv mw gp mx" role="separator"><span class="my bw bk mz na nb"/><span class="my bw bk mz na nb"/><span class="my bw bk mz na"/></div><div class="hb hc hd he hf"><h2 id="a407" class="lt kr hi bd ks lu lv lw kw lx ly lz la iq ma mb le iu mc md li iy me mf lm mg bi translated">2.setErrorForObject(对象，错误)</h2><p id="12a9" class="pw-post-body-paragraph if ig hi ih b ii lo ik il im lp io ip iq lq is it iu lr iw ix iy ls ja jb jc hb bi translated">使用这个方法，您可以为特定的对象或键设置一个错误，并在您的UI中访问它。</p><figure class="jj jk jl jm fd jn"><div class="bz dy l di"><div class="jo jp l"/></div></figure><p id="c448" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">try块将在3秒后引发一个错误，它将被下面的catch块捕获。在其中，我们为对象<code class="du jf jg jh ji b">_post,</code>设置错误，用异常字符串作为错误的值。</p><p id="945e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们可以检查UI内部的错误，</p><pre class="jj jk jl jm fd mh ji mi mj aw mk bi"><span id="fdea" class="lt kr hi ji b fi ml mm l mn mo">SomeWidget(<br/>child: <strong class="ji hj">viewModel.hasErrorForKey(viewModel.post)</strong><br/>            ? Text(<strong class="ji hj">viewModel.error(viewModel.post)</strong>)<br/>            : Text("success")),<br/>);</span></pre><p id="9876" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这就是我们在UI中访问错误的方式。</p><p id="9c39" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我已经告诉过runBusyFuture() 为我们处理错误，</p><p id="5f0a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">语法:</p><pre class="jj jk jl jm fd mh ji mi mj aw mk bi"><span id="f68b" class="lt kr hi ji b fi ml mm l mn mo">Future&lt;T&gt; runBusyFuture&lt;T&gt;(<br/>        Future&lt;T&gt; busyFuture,<br/>       {Object? busyObject,<br/>        bool throwException = false})</span></pre><blockquote class="mp mq mr"><p id="2675" class="if ig je ih b ii ij ik il im in io ip ms ir is it mt iv iw ix mu iz ja jb jc hb bi translated"><strong class="ih hj">忙碌的未来</strong>:这是我们想要实现的未来</p><p id="db57" class="if ig je ih b ii ij ik il im in io ip ms ir is it mt iv iw ix mu iz ja jb jc hb bi translated"><strong class="ih hj"> busyObject </strong>:这个是可选的。如果我们传递一个对象，它的hashcode被用作设置错误或繁忙状态的键。</p><p id="fe81" class="if ig je ih b ii ij ik il im in io ip ms ir is it mt iv iw ix mu iz ja jb jc hb bi translated"><strong class="ih hj">throw exception</strong>:runBusyFuture默认不抛出错误，如果出现错误，只会设置错误状态。我们可以通过设置<code class="du jf jg jh ji b">throwException=true</code>来覆盖这个行为并抛出一个错误</p></blockquote><p id="6f75" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> runErrorFuture() </strong></p><p id="ff49" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">有时你不想处理任何忙碌(忙碌😂而不是商业)逻辑，并且仍然想要运行一个可能引起错误的未来。在那种情况下，你可以使用<strong class="ih hj"> runErrorFuture()。它的工作方式类似于，<code class="du jf jg jh ji b">runBusyFuture()</code>，但是它不处理任何繁忙逻辑。而且<strong class="ih hj"> runBusyFuture()是使用runErrorFuture()构建的。</strong></strong></p></div><div class="ab cl mv mw gp mx" role="separator"><span class="my bw bk mz na nb"/><span class="my bw bk mz na nb"/><span class="my bw bk mz na"/></div><div class="hb hc hd he hf"><h1 id="72d5" class="kq kr hi bd ks kt nd kv kw kx ne kz la lb nf ld le lf ng lh li lj nh ll lm ln bi translated">3.处理未来—未来视图模型</h1><p id="5b0d" class="pw-post-body-paragraph if ig hi ih b ii lo ik il im lp io ip iq lq is it iu lr iw ix iy ls ja jb jc hb bi translated">有时，我们可能希望初始化来自未来的数据，所以我们使用FutureBuilder，堆叠包也有一些很酷的功能来初始化来自未来的数据，并处理未来的生命周期。FutureViewModel帮助我们利用BaseViewModel的强大功能和我上面提到的<em class="je">特性。</em></p><ul class=""><li id="bb68" class="ju jv hi ih b ii ij im in iq jw iu jx iy jy jc kd ka kb kc bi translated">您只需覆盖方法<strong class="ih hj"> futureToRun()，</strong>，该方法将为您启动来自未来的数据，并将其保存在名为<strong class="ih hj"> data </strong>的属性中。</li></ul><figure class="jj jk jl jm fd jn"><div class="bz dy l di"><div class="jo jp l"/></div></figure><p id="c714" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这个方法的作用是，</p><ul class=""><li id="2cce" class="ju jv hi ih b ii ij im in iq jw iu jx iy jy jc kd ka kb kc bi translated">当您创建FutureViewModel对象时，它将运行futureToRun()。</li><li id="ed05" class="ju jv hi ih b ii ke im kf iq kg iu kh iy ki jc kd ka kb kc bi translated">它会叫<code class="du jf jg jh ji b">setBusy(true)</code></li><li id="67ce" class="ju jv hi ih b ii ke im kf iq kg iu kh iy ki jc kd ka kb kc bi translated">一旦计算完成，您就可以使用<code class="du jf jg jh ji b">viewModel.data</code>来访问数据</li><li id="7d72" class="ju jv hi ih b ii ke im kf iq kg iu kh iy ki jc kd ka kb kc bi translated">如果它导致失败，它将设置ViewModel的错误状态。</li><li id="9928" class="ju jv hi ih b ii ke im kf iq kg iu kh iy ki jc kd ka kb kc bi translated">最后，它会调用<code class="du jf jg jh ji b">setBusy(false)</code></li></ul><p id="a906" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们能用这个做什么？</p><ul class=""><li id="5489" class="ju jv hi ih b ii ij im in iq jw iu jx iy jy jc kd ka kb kc bi translated">我们可以使用<code class="du jf jg jh ji b">viewModel.dataReady</code>检查数据是否准备好</li><li id="2e30" class="ju jv hi ih b ii ke im kf iq kg iu kh iy ki jc kd ka kb kc bi translated">我们可以使用<code class="du jf jg jh ji b">viewModel.data</code>获取数据</li></ul><pre class="jj jk jl jm fd mh ji mi mj aw mk bi"><span id="9854" class="lt kr hi ji b fi ml mm l mn mo">Center(<br/>  child: ViewModelBuilder&lt;PostViewModel&gt;.reactive(<br/>    viewModelBuilder: () =&gt; PostViewModel(),<br/>     builder: (ctx, viewModel, _) =&gt; <br/>        <strong class="ji hj">viewModel.hasError</strong><br/>        ? Text('Something went wrong')<br/>        : <strong class="ji hj">viewModel.dataReady</strong><br/>            ? MyListItem(viewModel.data)<br/>            : CircularProgressIndicator(),<br/>  ),<br/>)</span></pre><h2 id="3374" class="lt kr hi bd ks lu lv lw kw lx ly lz la iq ma mb le iu mc md li iy me mf lm mg bi translated"><strong class="ak"> onData() </strong></h2><p id="4bc2" class="pw-post-body-paragraph if ig hi ih b ii lo ik il im lp io ip iq lq is it iu lr iw ix iy ls ja jb jc hb bi translated">如果你想把获取的数据赋给某个变量，你可以覆盖一个钩子<strong class="ih hj"> onData(data)。</strong></p><pre class="jj jk jl jm fd mh ji mi mj aw mk bi"><span id="a236" class="lt kr hi ji b fi ml mm l mn mo">class PostViewModel extends FutureViewModel {<br/>  <strong class="ji hj">List&lt;Post&gt; allPosts;</strong><br/>  @override<br/>  Future futureToRun() async {<br/>     //your future<br/>  }</span><span id="c953" class="lt kr hi ji b fi ni mm l mn mo">@override<br/><strong class="ji hj">  void onData(data) {   //called once the data is ready<br/>    allPosts = data;<br/>    super.onData(data);<br/>  }</strong><br/> }</span></pre><p id="9bc4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在你可以使用<em class="je"> allPosts变量</em>访问相同的数据，你可以在onData内部做任何类型的操作，比如过滤数据，缓存等等。</p><h2 id="a8d6" class="lt kr hi bd ks lu lv lw kw lx ly lz la iq ma mb le iu mc md li iy me mf lm mg bi translated">一个错误()</h2><p id="0c57" class="pw-post-body-paragraph if ig hi ih b ii lo ik il im lp io ip iq lq is it iu lr iw ix iy ls ja jb jc hb bi translated">如果您希望在futureToRun()中发生错误时分配一些默认值，该怎么办？您可以覆盖onError()挂钩。</p><pre class="jj jk jl jm fd mh ji mi mj aw mk bi"><span id="222a" class="lt kr hi ji b fi ml mm l mn mo">@override<br/>void onError(error) { <br/>  <strong class="ji hj">onData(someDefaultData);<em class="je"><br/></em></strong><em class="je">  </em>super.onError(error);<br/>}</span></pre><p id="650f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在上面的代码中，当错误发生时，我将一些默认值设置为我的“数据”。现在我们可以使用<code class="du jf jg jh ji b">viewModel.data</code>来访问默认数据</p><blockquote class="mp mq mr"><p id="d65d" class="if ig je ih b ii ij ik il im in io ip ms ir is it mt iv iw ix mu iz ja jb jc hb bi translated">不要在onError()内部再次调用<code class="du jf jg jh ji b">futureToRun()</code>，可能会造成死循环。</p></blockquote><p id="052c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">目前，没有重试功能，但我希望他们会很快添加它。</p></div><div class="ab cl mv mw gp mx" role="separator"><span class="my bw bk mz na nb"/><span class="my bw bk mz na nb"/><span class="my bw bk mz na"/></div><div class="hb hc hd he hf"><p id="f99c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">希望你已经了解了<strong class="ih hj"> <em class="je">堆栈</em> </strong> <em class="je">包</em>是如何减少大量样板代码并帮助我们轻松处理错误和加载状态的。</p><p id="25bf" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在我的下一篇<a class="ae jd" rel="noopener" href="/nerd-for-tech/stacked-package-service-location-routing-logging-b8bdc1e6c839">文章</a>中，我将写这个包提供的服务，比如服务定位、路由、日志。感谢您的阅读😻，鼓掌👏如果你喜欢这篇文章。</p></div></div>    
</body>
</html>