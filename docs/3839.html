<html>
<head>
<title>Python Object-Oriented Programming</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python面向对象编程</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/python-object-oriented-programming-5a9950d15e48?source=collection_archive---------8-----------------------#2021-06-26">https://medium.com/nerd-for-tech/python-object-oriented-programming-5a9950d15e48?source=collection_archive---------8-----------------------#2021-06-26</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="8914" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">我的数据科学之旅(第4.1部分)</h2></div><p id="7087" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">面向对象编程是指使用对象而不仅仅是函数和方法定义的编程范式。对象包含数据，称为属性和方法(行为)。</p><figure class="ju jv jw jx fd jy er es paragraph-image"><div role="button" tabindex="0" class="jz ka di kb bf kc"><div class="er es jt"><img src="../Images/d039b82a1f6cdca3b33f3c4871003937.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*lkILQf50AIrokJ_u"/></div></div><figcaption class="kf kg et er es kh ki bd b be z dx translated">照片由<a class="ae kj" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的<a class="ae kj" href="https://unsplash.com/@clemhlrdt?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Clément Hélardot </a>拍摄</figcaption></figure><h1 id="d1eb" class="kk kl hi bd km kn ko kp kq kr ks kt ku io kv ip kw ir kx is ky iu kz iv la lb bi translated">类别和对象</h1><p id="0009" class="pw-post-body-paragraph ix iy hi iz b ja lc ij jc jd ld im jf jg le ji jj jk lf jm jn jo lg jq jr js hb bi translated">类是创建对象的代码模板或蓝图。类为创建的对象提供属性和方法。类是一个逻辑实体，在运行时不消耗内存。</p><p id="d0a6" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">对象是指在执行期间从类创建的运行时实例。对象被认为是真实世界的实体。对象在创建时会消耗内存。</p><p id="d2aa" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">属性:属性是所有实例共享的类的变量</p><p id="7433" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">方法:方法是一个对象执行的函数</p><figure class="ju jv jw jx fd jy er es paragraph-image"><div class="er es lh"><img src="../Images/0f808d190d2b07fbbb28dc480045333a.png" data-original-src="https://miro.medium.com/v2/resize:fit:892/format:webp/1*GksYM0TLI-Z4rFCesdLAeQ.png"/></div></figure><h1 id="5b09" class="kk kl hi bd km kn ko kp kq kr ks kt ku io kv ip kw ir kx is ky iu kz iv la lb bi translated">创建一个类</h1><pre class="ju jv jw jx fd li lj lk ll aw lm bi"><span id="1a43" class="ln kl hi lj b fi lo lp l lq lr">class Student:<br/>  def __init__(self,Name,Age,Gender):<br/>    self.Name=Name<br/>    self.Age=Age<br/>    self.Gender=Gender<br/>   <br/>  def eat(self):<br/>    print("{} is eating".format(self.Name))<br/>  <br/>  def study(self):<br/>    print("{} is studying".format(self.Name))</span><span id="3d3b" class="ln kl hi lj b fi ls lp l lq lr">  def sleep(self):<br/>    print("{} is sleeping".format(self.Name))<br/>--------------------------------------------------------------------Creating an object<br/>obj_1=Student("Jack",20,"Male")</span><span id="b216" class="ln kl hi lj b fi ls lp l lq lr">obj_1.eat()<br/>→Jack is eating</span></pre><p id="f26c" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="iz hj">构造函数</strong>:构造函数是python在对象初始化时调用的一种特殊方法。初始化类时，它将实例变量赋给对象。实例变量是属于特定实例(对象)的变量。更改对象2的实例变量不会影响对象1的实例变量</p><p id="f82f" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">当obj_1被创建时，调用__init__方法，它将变量(Jack，20，Male)赋给对象(obj_1)</p><p id="7e9d" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="iz hj">Self</strong>:Self关键字用来表示类的实例</p><pre class="ju jv jw jx fd li lj lk ll aw lm bi"><span id="ee1b" class="ln kl hi lj b fi lo lp l lq lr">obj_1=Student("Jack",20,"Male")<br/>obj_2=Student("Kate",22,"Female")</span></pre><p id="66b7" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这里两个对象(obj_1，obj_2)有他们的名字、年龄和性别。这是可能的，因为有self关键字。每个对象都有自己的实例变量</p><p id="1285" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如果self被省略，那么所有创建的对象将具有相同的变量</p><p id="6151" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">self关键字作为方法中的参数传递，以便该方法可以访问这些属性</p><p id="5589" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">所以自我对于obj_1 →是obj_1</p><p id="e8a6" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">obj_1.eat()与Student.eat(obj_1)相同</p><p id="6386" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">注意:对于方法eat()有1个已定义的参数，但是调用时没有给定参数(obj_1.eat())，因为这与(Student.eat(obj_1))相同</p><h1 id="8cf3" class="kk kl hi bd km kn ko kp kq kr ks kt ku io kv ip kw ir kx is ky iu kz iv la lb bi translated">变量(属性)</h1><p id="3cb1" class="pw-post-body-paragraph ix iy hi iz b ja lc ij jc jd ld im jf jg le ji jj jk lf jm jn jo lg jq jr js hb bi translated">类中定义了两种类型的变量</p><ol class=""><li id="c2dd" class="lt lu hi iz b ja jb jd je jg lv jk lw jo lx js ly lz ma mb bi translated">实例变量</li><li id="18e4" class="lt lu hi iz b ja mc jd md jg me jk mf jo mg js ly lz ma mb bi translated">静态变量</li></ol><p id="008e" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="iz hj">实例变量:</strong>实例变量归类的每个对象所有。每个对象都有自己的变量，可以单独更改(特定对象的变量)。它是在__init__方法中定义的。对象只能调用这些变量。</p><pre class="ju jv jw jx fd li lj lk ll aw lm bi"><span id="987e" class="ln kl hi lj b fi lo lp l lq lr">print(obj_1.Name)→Jack<br/>print(obj_2.Name)→Kate</span></pre><p id="b2b3" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="iz hj">静态变量或类变量:</strong>类拥有的变量。所有对象通用的变量。它是在__init__方法(构造函数方法)外部定义的。这些变量可以由对象和类调用</p><pre class="ju jv jw jx fd li lj lk ll aw lm bi"><span id="b1dd" class="ln kl hi lj b fi lo lp l lq lr">class Student:<br/>  Stream="CSE"                         #Class Variable<br/>  def __init__(self,Name,Roll):<br/>    self.Name=Name                     #Instance Variable<br/>    self.Roll=Roll                     #Instance Variable</span><span id="3d9e" class="ln kl hi lj b fi ls lp l lq lr">a=Student("A",1)<br/>b=Student("B",2)<br/>print(a.Name)→A<br/>print(b.Name)→B<br/>print(a.Roll)→1<br/>print(b.Roll)→1<br/>print(a.Stream)→CSE<br/>print(b.Stream)→CSE<br/></span><span id="ca17" class="ln kl hi lj b fi ls lp l lq lr">print(Student.Stream)→CSE</span><span id="4e97" class="ln kl hi lj b fi ls lp l lq lr">#Class varible can be updated for each object <br/>a.Stream="Mech"</span><span id="667c" class="ln kl hi lj b fi ls lp l lq lr">print(a.Stream)→"Mech"<br/>print(b.Stream)→"CSE"<br/>print(Student.Stream)→"CSE"</span><span id="1942" class="ln kl hi lj b fi ls lp l lq lr">#Class variable canged for all instance<br/>Student.Stream="Prod"</span><span id="75a6" class="ln kl hi lj b fi ls lp l lq lr">print(a.Stream)→"Prod"<br/>print(b.Stream)→"Prod"<br/>print(Student.Stream)→"Prod"</span></pre><h1 id="6c6e" class="kk kl hi bd km kn ko kp kq kr ks kt ku io kv ip kw ir kx is ky iu kz iv la lb bi translated">方法</h1><p id="8629" class="pw-post-body-paragraph ix iy hi iz b ja lc ij jc jd ld im jf jg le ji jj jk lf jm jn jo lg jq jr js hb bi translated">3种方法</p><ol class=""><li id="c3f0" class="lt lu hi iz b ja jb jd je jg lv jk lw jo lx js ly lz ma mb bi translated">实例方法</li><li id="104f" class="lt lu hi iz b ja mc jd md jg me jk mf jo mg js ly lz ma mb bi translated">分类方法</li><li id="a8b3" class="lt lu hi iz b ja mc jd md jg me jk mf jo mg js ly lz ma mb bi translated">静态方法</li></ol><p id="fd7a" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="iz hj">实例方法:</strong>实例方法是可以访问实例变量的方法。在上面的例子中，eat()、sleep()、study()都是实例方法，因为它们可以访问实例变量。Instance(self)作为Instance方法中的第一个参数传递。</p><p id="211d" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">实例方法可以分为访问器方法和赋值器方法</p><ol class=""><li id="f098" class="lt lu hi iz b ja jb jd je jg lv jk lw jo lx js ly lz ma mb bi translated">访问器方法:获取实例变量的实例方法</li><li id="1909" class="lt lu hi iz b ja mc jd md jg me jk mf jo mg js ly lz ma mb bi translated">Mutator方法:修改特定对象的实例变量的实例方法</li></ol><p id="5052" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="iz hj">类方法:</strong>类方法是绑定到类的方法。它不需要创建对象来访问该方法。类方法用于访问类变量。Class(cls)作为Class方法中的第一个参数传递。类方法可以访问和修改类状态</p><p id="7537" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="iz hj">静态方法:</strong>静态方法不接受任何隐式参数(例如self或类的cls)。静态方法也属于类而不是对象，但是与类方法不同，静态方法不能改变类的状态。静态方法对该类一无所知。</p><pre class="ju jv jw jx fd li lj lk ll aw lm bi"><span id="9869" class="ln kl hi lj b fi lo lp l lq lr">class Student:   <br/>  school="xyz"                                  #Class Variable</span><span id="0a2a" class="ln kl hi lj b fi ls lp l lq lr">  def __init__(self,name,roll):                 #Constructor Metod<br/>    self.name=name                              #Instance Variable<br/>    self.roll=roll                              #Instance Variable</span><span id="35ad" class="ln kl hi lj b fi ls lp l lq lr">  def display(self):                            #Instance Metod<br/>    print("name is {} and roll is{}".format(self.name,self.roll))</span><span id="cb08" class="ln kl hi lj b fi ls lp l lq lr"><br/>  @classmethod<br/>  def info(cls):                                 #Class Method<br/>    return cls.school</span><span id="0946" class="ln kl hi lj b fi ls lp l lq lr">  @staticmethod                                  #Static Method<br/>  def isAdult(age):<br/>    if age&gt;18:<br/>      return "yes"<br/>    else:<br/>      return "no"</span><span id="e3af" class="ln kl hi lj b fi ls lp l lq lr">--------------------------------------------------------------------<br/>o1=Student("Jack",1)</span><span id="6a61" class="ln kl hi lj b fi ls lp l lq lr">o1.display()                                     #Instance Method<br/>name is Jack and roll is 1</span><span id="6f6e" class="ln kl hi lj b fi ls lp l lq lr"><strong class="lj hj">Student.display(o1)  #class name can be used to call instance method<br/>name is Jack and roll is 1</strong></span><span id="868c" class="ln kl hi lj b fi ls lp l lq lr">Student.info()                                   #Class Method<br/>xyz</span><span id="6838" class="ln kl hi lj b fi ls lp l lq lr"><strong class="lj hj">o1.info()  #object can be used to get the class method also<br/>xyz</strong></span><span id="58b2" class="ln kl hi lj b fi ls lp l lq lr">Student.isAdult(20)                              #Static Method<br/>yes</span><span id="b17c" class="ln kl hi lj b fi ls lp l lq lr"><strong class="lj hj">o1.isAdult(20)  #object can be used to get the static method also<br/>yes</strong></span><span id="23a6" class="ln kl hi lj b fi ls lp l lq lr">-------------------------------------------------------------------o1.name                                          #Accessor<br/>Jack</span><span id="6666" class="ln kl hi lj b fi ls lp l lq lr">o1.name="Mike"                                   #Mutator<br/>o1.name<br/>Mike</span></pre><h1 id="76f0" class="kk kl hi bd km kn ko kp kq kr ks kt ku io kv ip kw ir kx is ky iu kz iv la lb bi translated">遗产</h1><p id="14d8" class="pw-post-body-paragraph ix iy hi iz b ja lc ij jc jd ld im jf jg le ji jj jk lf jm jn jo lg jq jr js hb bi translated">继承允许我们定义一个从另一个类继承所有方法和属性的类。父类是被继承的类，也称为基类。子类是从另一个类继承的类，也称为派生类。</p><p id="7be9" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">为了创建子类，父类作为参数被发送给子类。</p><pre class="ju jv jw jx fd li lj lk ll aw lm bi"><span id="7b17" class="ln kl hi lj b fi lo lp l lq lr">class Person:<br/>  def __init__(self,fname,lname):<br/>    self.fname=fname<br/>    self.lname=lname<br/>  <br/>  def display(self):<br/>    print(self.fname,self,lname)</span><span id="3027" class="ln kl hi lj b fi ls lp l lq lr">x=Person("Jack","Doe")<br/>x.display<br/>Jack Doe<br/>--------------------------------------------------------------------<br/>class Student(Person):<br/>  pass</span><span id="fc0c" class="ln kl hi lj b fi ls lp l lq lr">y=Student("Mike","olson")<br/>y.display<br/>Mike olson</span></pre><p id="ca18" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">Class Student继承了Person的所有属性和方法</p><p id="ce75" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如果__init__被添加到student类，则student类将不再从父类继承。学生类的__init__方法覆盖了父类的__init__方法。</p><pre class="ju jv jw jx fd li lj lk ll aw lm bi"><span id="bf2f" class="ln kl hi lj b fi lo lp l lq lr">class Student(Person):<br/>  def __init__(self,roll,marks):<br/>    self.roll=roll<br/>    self.marks=marks<br/># This class can no longer inherit from the parent class Person</span></pre><p id="e3a8" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">为了使子类继承父类，使用了super()函数。</p><pre class="ju jv jw jx fd li lj lk ll aw lm bi"><span id="155b" class="ln kl hi lj b fi lo lp l lq lr">class Student(Person):<br/>  def __init__(self,fname,lname,roll,marks):#Constructor for Student<br/>    super().__init__(fname,lname)           #Constructor for Person<br/>    self.roll=roll<br/>    self.marks=marks</span></pre><p id="b8af" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">子类构造函数应该包含子类和父类的参数。super()仅用于继承父类属性。</p><h1 id="6835" class="kk kl hi bd km kn ko kp kq kr ks kt ku io kv ip kw ir kx is ky iu kz iv la lb bi translated">多重遗传</h1><h2 id="149b" class="ln kl hi bd km mh mi mj kq mk ml mm ku jg mn mo kw jk mp mq ky jo mr ms la mt bi translated">多重遗传</h2><pre class="ju jv jw jx fd li lj lk ll aw lm bi"><span id="d170" class="ln kl hi lj b fi lo lp l lq lr">class Parent1:<br/>    -<br/>class Parent2:<br/>    -</span><span id="6b33" class="ln kl hi lj b fi ls lp l lq lr">class Child(Parent1, Parent2):<br/>    -</span></pre><h2 id="465a" class="ln kl hi bd km mh mi mj kq mk ml mm ku jg mn mo kw jk mp mq ky jo mr ms la mt bi translated">多级遗传</h2><pre class="ju jv jw jx fd li lj lk ll aw lm bi"><span id="f5c6" class="ln kl hi lj b fi lo lp l lq lr">class Parent:<br/>    -</span><span id="f683" class="ln kl hi lj b fi ls lp l lq lr">class Child(Parent):<br/>    -<br/><br/>class Child2(Child):<br/>    -</span></pre><h2 id="81b8" class="ln kl hi bd km mh mi mj kq mk ml mm ku jg mn mo kw jk mp mq ky jo mr ms la mt bi translated">方法解析顺序</h2><p id="e1d7" class="pw-post-body-paragraph ix iy hi iz b ja lc ij jc jd ld im jf jg le ji jj jk lf jm jn jo lg jq jr js hb bi translated">MRO是一个用于继承的概念。它是在类层次结构中搜索方法的顺序。</p><p id="3a35" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在多重继承的情况下，首先在当前类中搜索任何指定的属性。如果没有找到，则搜索继续以自下而上和自左向右的方式进入父类，而不搜索相同的类两次。</p><pre class="ju jv jw jx fd li lj lk ll aw lm bi"><span id="fdc5" class="ln kl hi lj b fi lo lp l lq lr">class A:<br/>  def display(self):<br/>    print("class A method")</span><span id="eb70" class="ln kl hi lj b fi ls lp l lq lr">class B:<br/>  def display(self):<br/>    print("class B method")</span><span id="b331" class="ln kl hi lj b fi ls lp l lq lr">class C(A,B):<br/>  def info(self):<br/>    print("class C method")</span><span id="c576" class="ln kl hi lj b fi ls lp l lq lr">x=C()<br/>x.display()<br/>class A method</span><span id="a267" class="ln kl hi lj b fi ls lp l lq lr">if <br/>class C(B,A):<br/>  def info(self):<br/>    print("class C method")</span><span id="a10b" class="ln kl hi lj b fi ls lp l lq lr">x=c()<br/>x.display()<br/>class B method</span></pre><h1 id="aa14" class="kk kl hi bd km kn ko kp kq kr ks kt ku io kv ip kw ir kx is ky iu kz iv la lb bi translated">装修工</h1><p id="3031" class="pw-post-body-paragraph ix iy hi iz b ja lc ij jc jd ld im jf jg le ji jj jk lf jm jn jo lg jq jr js hb bi translated">python中的设计模式允许用户在不改变结构的情况下向现有对象添加新功能。</p><p id="ba7e" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在python中，函数被认为是一级的</p><h2 id="8a52" class="ln kl hi bd km mh mi mj kq mk ml mm ku jg mn mo kw jk mp mq ky jo mr ms la mt bi translated">一级属性</h2><ul class=""><li id="6e5c" class="lt lu hi iz b ja lc jd ld jg mu jk mv jo mw js mx lz ma mb bi translated">函数是对象:函数可以赋给变量</li></ul><pre class="ju jv jw jx fd li lj lk ll aw lm bi"><span id="eead" class="ln kl hi lj b fi lo lp l lq lr">def display(text):<br/>  return(text)</span><span id="7f1c" class="ln kl hi lj b fi ls lp l lq lr">display(abc)<br/>abc</span><span id="1e8d" class="ln kl hi lj b fi ls lp l lq lr">x=display(abc)               #assignig function to a variable<br/>print(x)<br/>abc</span></pre><ul class=""><li id="bd4a" class="lt lu hi iz b ja jb jd je jg lv jk lw jo lx js mx lz ma mb bi translated">函数可以作为参数传递给其他函数:</li></ul><pre class="ju jv jw jx fd li lj lk ll aw lm bi"><span id="c047" class="ln kl hi lj b fi lo lp l lq lr">def a(text):<br/>  return text</span><span id="2e9f" class="ln kl hi lj b fi ls lp l lq lr">def b(x):<br/>  print(x)</span><span id="b309" class="ln kl hi lj b fi ls lp l lq lr">b(a(2))<br/>2</span></pre><ul class=""><li id="f69a" class="lt lu hi iz b ja jb jd je jg lv jk lw jo lx js mx lz ma mb bi translated">函数可以返回函数</li></ul><pre class="ju jv jw jx fd li lj lk ll aw lm bi"><span id="29bf" class="ln kl hi lj b fi lo lp l lq lr">def a(x):<br/>  def squared(): <br/>    return x*x<br/>  return squared()</span><span id="c359" class="ln kl hi lj b fi ls lp l lq lr">a(2)<br/>4</span></pre><h2 id="1833" class="ln kl hi bd km mh mi mj kq mk ml mm ku jg mn mo kw jk mp mq ky jo mr ms la mt bi translated">关闭</h2><p id="b3b6" class="pw-post-body-paragraph ix iy hi iz b ja lc ij jc jd ld im jf jg le ji jj jk lf jm jn jo lg jq jr js hb bi translated">内部函数可以访问外部函数的参数。在上面的例子中，内部函数(squared)不接受任何参数，但是外部函数接受参数x</p><pre class="ju jv jw jx fd li lj lk ll aw lm bi"><span id="fe12" class="ln kl hi lj b fi lo lp l lq lr">def main_welcome(msg): <br/>  def sub_welcome():<br/>    print("Hello")<br/>    print(msg)<br/>    print("Bye")<br/>  return sub_welcome()</span><span id="a9ab" class="ln kl hi lj b fi ls lp l lq lr">main_welcome("how are you")<br/>Hello <br/>how are you <br/>Bye</span></pre><p id="a30f" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">关闭</p><pre class="ju jv jw jx fd li lj lk ll aw lm bi"><span id="946d" class="ln kl hi lj b fi lo lp l lq lr">def main_welcome(msg): <br/>  def sub_welcome():<br/>    print("Hello")<br/>    print(msg)<br/>    print("Bye")<br/>  return sub_welcome           </span><span id="3b21" class="ln kl hi lj b fi ls lp l lq lr">x=main_welcome("how are you")<br/>print(x())<br/>Hello <br/>how are you <br/>Bye</span><span id="30c1" class="ln kl hi lj b fi ls lp l lq lr">def multiplier(x): <br/>  def multiply(y):<br/>    return x*y<br/>  return multiply</span><span id="bdce" class="ln kl hi lj b fi ls lp l lq lr">x=multiplier(3)<br/>print(x(2))<br/>6<br/></span></pre><p id="8de2" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">Clousers是一个函数对象，它会记住封闭范围(外部函数)中的值，即使它不在内存中</p><pre class="ju jv jw jx fd li lj lk ll aw lm bi"><span id="fca7" class="ln kl hi lj b fi lo lp l lq lr">def main_welcome(text): <br/>  def sub_welcome():<br/>    print("Hello")<br/>    print(text)<br/>    print("Bye")<br/>  return sub_welcome</span><span id="b635" class="ln kl hi lj b fi ls lp l lq lr">x=main_welcome("how are you")<br/>del main_welcome<br/>x()</span><span id="5bda" class="ln kl hi lj b fi ls lp l lq lr">Hello <br/>how are you <br/>Bye</span></pre><p id="8d8b" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在上面的例子中，x存储了内部函数的状态，并且即使在删除了外部函数之后也能够运行</p><p id="c635" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">可以接受其他函数的函数称为高阶函数</p><pre class="ju jv jw jx fd li lj lk ll aw lm bi"><span id="bcb6" class="ln kl hi lj b fi lo lp l lq lr">def main_welcome(func):<br/>  def sub_welcome():<br/>    print("Hello")<br/>    func()<br/>    print("Bye")<br/>  return sub_welcome</span><span id="5a37" class="ln kl hi lj b fi ls lp l lq lr">def display():<br/>  print("How are you")</span><span id="a4bc" class="ln kl hi lj b fi ls lp l lq lr">x=main_welcome(display)<br/>x()</span><span id="9cd4" class="ln kl hi lj b fi ls lp l lq lr">Hello <br/>How are you <br/>Bye<br/>--------------------------------------------------------------------</span><span id="f3f5" class="ln kl hi lj b fi ls lp l lq lr">def main_welcome(func):<br/>  def sub_welcome():<br/>    print("Hello")<br/>    func()<br/>    print("Bye") <br/>  return sub_welcome()      # <strong class="lj hj">parenthesis returns the called          <br/>                              function(return the result), without <br/>                              parenthesis function is returned</strong></span><span id="f937" class="ln kl hi lj b fi ls lp l lq lr">def display():<br/>  print("How are you")</span><span id="fe56" class="ln kl hi lj b fi ls lp l lq lr">x=main_welcome(display)<br/>x                           # <strong class="lj hj">since the return sub_welcome() returns <br/>                              the result, x is called x insted of <br/>                              x()</strong></span></pre><p id="c14e" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">括号返回被调用的函数(返回结果)，不带括号的函数返回</p><h2 id="0850" class="ln kl hi bd km mh mi mj kq mk ml mm ku jg mn mo kw jk mp mq ky jo mr ms la mt bi translated">装修工</h2><pre class="ju jv jw jx fd li lj lk ll aw lm bi"><span id="84de" class="ln kl hi lj b fi lo lp l lq lr">def main(func):<br/>  def sub():<br/>    print("1")<br/>    print("2")<br/>    func()<br/>  return sub</span><span id="bfa6" class="ln kl hi lj b fi ls lp l lq lr">def qq():<br/>  print("3")</span><span id="38b1" class="ln kl hi lj b fi ls lp l lq lr">--------------------------------------------------------------------<br/>main(qq)()<br/>1<br/>2<br/>3</span><span id="714c" class="ln kl hi lj b fi ls lp l lq lr">z=main(qq)<br/>z()<br/>1<br/>2<br/>3</span><span id="66a4" class="ln kl hi lj b fi ls lp l lq lr">@main<br/>def qq():<br/>  print("3")<br/>qq()<br/>1<br/>2<br/>3<br/>--------------------------------------------------------------------<br/>def main(func):<br/>  def sub(a,b):<br/>    print("1")<br/>    print("2")<br/>    func()</span><span id="6049" class="ln kl hi lj b fi ls lp l lq lr">def qq(a,b):<br/>  return a*b</span><span id="dabc" class="ln kl hi lj b fi ls lp l lq lr">main(qq)(2,3)      # passing the qq function in the main, then <br/>1                    passing the parameters for qq in sub<br/>2</span><span id="ca67" class="ln kl hi lj b fi ls lp l lq lr">z=main(qq)<br/>z(2,3)<br/>1<br/>2</span><span id="6482" class="ln kl hi lj b fi ls lp l lq lr">@main<br/>def qq(a,b):<br/>  return a*b<br/>qq(2,3)<br/>1<br/>2</span><span id="f811" class="ln kl hi lj b fi ls lp l lq lr"># The function qq is not being printed</span><span id="3069" class="ln kl hi lj b fi ls lp l lq lr">--------------------------------------------------------------------</span><span id="050d" class="ln kl hi lj b fi ls lp l lq lr"># To print the qq function the function is assgined to a variable then printed </span><span id="bb9a" class="ln kl hi lj b fi ls lp l lq lr">def main(func):<br/>  def sub(a,b):<br/>    print("1")<br/>    print("2")<br/>    val=func(a,b)<br/>    print(val)<br/>  return sub</span><span id="bc3e" class="ln kl hi lj b fi ls lp l lq lr">def qq(a,b):<br/>  return a*b</span><span id="2cfa" class="ln kl hi lj b fi ls lp l lq lr">main(qq)(2,3)<br/>1<br/>2<br/>6</span><span id="4591" class="ln kl hi lj b fi ls lp l lq lr">@main<br/>def qq(a,b):<br/>  return a*b<br/>qq(2,3)<br/>1<br/>2<br/>6</span></pre><h1 id="949f" class="kk kl hi bd km kn ko kp kq kr ks kt ku io kv ip kw ir kx is ky iu kz iv la lb bi translated">公共、私有和受保护的变量</h1><pre class="ju jv jw jx fd li lj lk ll aw lm bi"><span id="56c5" class="ln kl hi lj b fi lo lp l lq lr">self.name=   → public<br/>self._name=  → protected<br/>self.__name= → private</span></pre><p id="29ad" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">Public:变量可以在任何地方访问</p><p id="3ef6" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">Protected:可以在类内访问，也可以通过从父类继承来访问。</p><p id="6b59" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">Private:不能访问或修改。变量是初始设置的。不能在函数外部修改或访问它。</p><p id="38fd" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在python中，Public、Private和Protected只是给开发者的提示。例如，私有变量不阻止访问或修改。它仍然可以被访问或更改。这只是表明这个变量是私有的，所以不要改变或访问它。</p><h1 id="2900" class="kk kl hi bd km kn ko kp kq kr ks kt ku io kv ip kw ir kx is ky iu kz iv la lb bi translated">邓德方法或魔术方法</h1><p id="7b95" class="pw-post-body-paragraph ix iy hi iz b ja lc ij jc jd ld im jf jg le ji jj jk lf jm jn jo lg jq jr js hb bi translated">有两个前缀和后缀的方法加下划线。这些方法在没有被调用的情况下被初始化，例如__init__，__add__，__str__。这些方法并不意味着被直接调用，而是从类内部调用，例如，将两个数相加。</p><pre class="ju jv jw jx fd li lj lk ll aw lm bi"><span id="74a9" class="ln kl hi lj b fi lo lp l lq lr">1+2<br/>3</span><span id="e3b2" class="ln kl hi lj b fi ls lp l lq lr">a=1<br/>b=2<br/>a.__add__(b)<br/>3</span></pre><p id="d871" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">当添加2个数字时，内部调用__add__()方法</p><p id="f3c7" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">dir()函数显示了继承的魔法方法列表。Dunder方法主要用于改变预定义的行为。</p><h1 id="fadb" class="kk kl hi bd km kn ko kp kq kr ks kt ku io kv ip kw ir kx is ky iu kz iv la lb bi translated">多态性</h1><p id="4d64" class="pw-post-body-paragraph ix iy hi iz b ja lc ij jc jd ld im jf jg le ji jj jk lf jm jn jo lg jq jr js hb bi translated">多态性是单个实体(方法、对象或操作符)在不同场景中表示不同类型的能力。</p><p id="8429" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">例如，len()函数在给定字符串输入时返回字母的数量，在给定列表作为输入时返回元素的数量，在给定字典时返回键的数量</p><p id="3515" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">"+"运算符在输入中给定一个数字时将两个数字相加，在给定一个字符串时将字符串连接起来。</p><h2 id="4293" class="ln kl hi bd km mh mi mj kq mk ml mm ku jg mn mo kw jk mp mq ky jo mr ms la mt bi translated">运算符重载</h2><p id="563a" class="pw-post-body-paragraph ix iy hi iz b ja lc ij jc jd ld im jf jg le ji jj jk lf jm jn jo lg jq jr js hb bi translated">运算符重载会更改方法的预定义行为，例如+运算符调用。__add__()方法将两个数字相加或连接两个字符串。+运算符不能添加两个类对象，因此可以重载+运算符来添加该类的两个对象。</p><pre class="ju jv jw jx fd li lj lk ll aw lm bi"><span id="3cb2" class="ln kl hi lj b fi lo lp l lq lr">class S:<br/>def __init__(self,M):<br/>  self.M=M<br/>def __add__(self,other):<br/>  add=self.M+other.M<br/>  return add</span><span id="305d" class="ln kl hi lj b fi ls lp l lq lr">s1=S(9)                         #2 objects<br/>s2=S(5)</span><span id="268d" class="ln kl hi lj b fi ls lp l lq lr">s1+s2<br/>14</span><span id="a59d" class="ln kl hi lj b fi ls lp l lq lr">s1.__add__(s2)<br/>14</span><span id="2018" class="ln kl hi lj b fi ls lp l lq lr">S.__add__(s1,s2)<br/>14</span><span id="2b09" class="ln kl hi lj b fi ls lp l lq lr">in def __add__(self,other)  self is s1 and other is s2 </span></pre><h2 id="5ff2" class="ln kl hi bd km mh mi mj kq mk ml mm ku jg mn mo kw jk mp mq ky jo mr ms la mt bi translated">方法重载</h2><p id="36fd" class="pw-post-body-paragraph ix iy hi iz b ja lc ij jc jd ld im jf jg le ji jj jk lf jm jn jo lg jq jr js hb bi translated">默认情况下，Python不支持方法重载</p><p id="ac78" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">方法重载是指一个类有两个同名但参数不同的方法</p><pre class="ju jv jw jx fd li lj lk ll aw lm bi"><span id="bb06" class="ln kl hi lj b fi lo lp l lq lr">def prod(a,b):<br/>  return a*b</span><span id="4b83" class="ln kl hi lj b fi ls lp l lq lr">def prod(a,b,c):<br/>  return a*b*c</span></pre><p id="9830" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">python只接受最新定义的方法。所以prod(2，1，4)可以工作，但是prod(1，2)不行</p><p id="5e1c" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在python中有两种方法可以实现这个函数</p><ul class=""><li id="a5b1" class="lt lu hi iz b ja jb jd je jg lv jk lw jo lx js mx lz ma mb bi translated">使用*参数</li></ul><pre class="ju jv jw jx fd li lj lk ll aw lm bi"><span id="d6db" class="ln kl hi lj b fi lo lp l lq lr">def prod(*args):<br/>  p=1<br/>  for x in args:<br/>    p=p*x<br/>  return p</span><span id="a8d0" class="ln kl hi lj b fi ls lp l lq lr">prod(1,2)<br/>2</span><span id="5344" class="ln kl hi lj b fi ls lp l lq lr">prod(1,2,3)<br/>6</span><span id="8303" class="ln kl hi lj b fi ls lp l lq lr">prod(1,2,3,4)<br/>24</span></pre><ul class=""><li id="0406" class="lt lu hi iz b ja jb jd je jg lv jk lw jo lx js mx lz ma mb bi translated">多重调度装饰器</li></ul><pre class="ju jv jw jx fd li lj lk ll aw lm bi"><span id="0ac7" class="ln kl hi lj b fi lo lp l lq lr">@dispatch(int,int)<br/>def prod(a,b):<br/>  return a*b</span><span id="bd31" class="ln kl hi lj b fi ls lp l lq lr">@dispatch(int,int,int)<br/>def prod(a,b,c):<br/>  return a*b*c</span><span id="cb0f" class="ln kl hi lj b fi ls lp l lq lr">prod(1,2)<br/>2</span><span id="61a3" class="ln kl hi lj b fi ls lp l lq lr">prod(1,2,3)<br/>6</span></pre><p id="c36e" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">多分派装饰器根据调用的参数在几个函数体中选择运行。</p><h2 id="92b8" class="ln kl hi bd km mh mi mj kq mk ml mm ku jg mn mo kw jk mp mq ky jo mr ms la mt bi translated">方法覆盖</h2><p id="a663" class="pw-post-body-paragraph ix iy hi iz b ja lc ij jc jd ld im jf jg le ji jj jk lf jm jn jo lg jq jr js hb bi translated">当子类中的方法与其超类中的方法具有相同的名称、相同的参数时，那么子类中的方法被认为覆盖了超类中的方法。</p><pre class="ju jv jw jx fd li lj lk ll aw lm bi"><span id="7410" class="ln kl hi lj b fi lo lp l lq lr">class A:<br/>  def display(self):<br/>    return "Method A"<br/>class B(A):<br/>  pass</span><span id="e277" class="ln kl hi lj b fi ls lp l lq lr">x=B()<br/>x.display()<br/>Method A<br/>--------------------------------------------------------------------<br/>class A:<br/>  def display(self):<br/>    return "Method A"<br/>class B(A):<br/>  def display(self):<br/>    return "Method B"</span><span id="2661" class="ln kl hi lj b fi ls lp l lq lr">x=B()<br/>x.display()<br/>Method B</span></pre><h1 id="49f3" class="kk kl hi bd km kn ko kp kq kr ks kt ku io kv ip kw ir kx is ky iu kz iv la lb bi translated">= vs copy() vs deepcopy()</h1><pre class="ju jv jw jx fd li lj lk ll aw lm bi"><span id="e658" class="ln kl hi lj b fi lo lp l lq lr">lst1=[1,2,3,4]<br/>lst2=lst1<br/>lst2<br/>[1,2,3,4]</span><span id="2bdc" class="ln kl hi lj b fi ls lp l lq lr">id(lst1)<br/>140632842905872</span><span id="b055" class="ln kl hi lj b fi ls lp l lq lr">id(lst2)<br/>140632842905872<br/>#memory location</span></pre><p id="7326" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">两个变量lst1和lst2代表相同的内存位置，因此一个变量的变化会影响另一个变量</p><h2 id="d83d" class="ln kl hi bd km mh mi mj kq mk ml mm ku jg mn mo kw jk mp mq ky jo mr ms la mt bi translated">。复制()</h2><p id="979a" class="pw-post-body-paragraph ix iy hi iz b ja lc ij jc jd ld im jf jg le ji jj jk lf jm jn jo lg jq jr js hb bi translated">也叫浅抄。浅层复制不会复制每个元素的值。相反，它们引用lst1中每个值的存储位置。</p><pre class="ju jv jw jx fd li lj lk ll aw lm bi"><span id="892f" class="ln kl hi lj b fi lo lp l lq lr">lst1=[1,2,3,4]<br/>lst2=lst1.copy()</span><span id="9632" class="ln kl hi lj b fi ls lp l lq lr">id(lst1)<br/>140632842905152</span><span id="2bb9" class="ln kl hi lj b fi ls lp l lq lr">id(lst2)<br/>140632842449936</span><span id="ee32" class="ln kl hi lj b fi ls lp l lq lr">print(id(lst1[0]))<br/>print(id(lst2[0]))</span><span id="2504" class="ln kl hi lj b fi ls lp l lq lr">94269450803712 <br/>94269450803712<br/>--------------------------------------------------------------------<br/>Note if values are changed in lst1 lst2 is not affected<br/>lst1[0]=0</span><span id="3e67" class="ln kl hi lj b fi ls lp l lq lr">lst1<br/>[0,2,3,4]</span><span id="f6ed" class="ln kl hi lj b fi ls lp l lq lr">lst2<br/>[1,2,3,4]</span><span id="09aa" class="ln kl hi lj b fi ls lp l lq lr">print(id(lst1))<br/>print(id(lst2))</span><span id="385c" class="ln kl hi lj b fi ls lp l lq lr">140182184495536 <br/>140182184530480</span><span id="4345" class="ln kl hi lj b fi ls lp l lq lr">print(id(lst1[0]))<br/>print(id(lst2[0]))</span><span id="ca85" class="ln kl hi lj b fi ls lp l lq lr">94269450803680 <br/>94269450803712<br/>--------------------------------------------------------------------<br/>lst2 refereces each element to lst1 this can be clearly seen in nested list</span><span id="b36a" class="ln kl hi lj b fi ls lp l lq lr">lst1=[[1,2,3],[4,5,6]]<br/>lst2=lst1.copy()</span><span id="f895" class="ln kl hi lj b fi ls lp l lq lr">lst1[0][0]=0</span><span id="a7e4" class="ln kl hi lj b fi ls lp l lq lr">print(lst1)<br/>print(lst2)</span><span id="7359" class="ln kl hi lj b fi ls lp l lq lr">[[0, 2, 3], [4, 5, 6]] <br/>[[0, 2, 3], [4, 5, 6]]<br/>--------------------------------------------------------------------<br/>lst1=[[1,2,3],[4,5,6]]<br/>lst2=lst1.copy()</span><span id="36ec" class="ln kl hi lj b fi ls lp l lq lr">lst1.append([7,8,9])</span><span id="800d" class="ln kl hi lj b fi ls lp l lq lr">print(lst1)<br/>print(lst2)</span><span id="1d7c" class="ln kl hi lj b fi ls lp l lq lr">[[1, 2, 3], [4, 5, 6], [7, 8, 9]] <br/>[[1, 2, 3], [4, 5, 6]]<br/>only changes inside the nested list is copied </span></pre><h2 id="505c" class="ln kl hi bd km mh mi mj kq mk ml mm ku jg mn mo kw jk mp mq ky jo mr ms la mt bi translated">。deepcopy()</h2><p id="edf9" class="pw-post-body-paragraph ix iy hi iz b ja lc ij jc jd ld im jf jg le ji jj jk lf jm jn jo lg jq jr js hb bi translated">创建要复制的新内存，不引用任何内容。</p><figure class="ju jv jw jx fd jy er es paragraph-image"><div class="er es my"><img src="../Images/f44d9f7890ad4f14595aef7ba064c67f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sYMD2uX4soWTxW3sB-NaLw.png"/></div></figure><h1 id="b80c" class="kk kl hi bd km kn ko kp kq kr ks kt ku io kv ip kw ir kx is ky iu kz iv la lb bi translated">*args和**kwargs</h1><p id="6c6d" class="pw-post-body-paragraph ix iy hi iz b ja lc ij jc jd ld im jf jg le ji jj jk lf jm jn jo lg jq jr js hb bi translated">args是arguments的缩写，即函数或方法期望传递给它的值。如果您不确定要传递给函数多少个参数，可以使用args语法，它可以接受任意数量的参数</p><pre class="ju jv jw jx fd li lj lk ll aw lm bi"><span id="cf18" class="ln kl hi lj b fi lo lp l lq lr">def prod(*args):<br/>  p=1<br/>  for x in args:<br/>    p=p*x<br/>  return p</span><span id="f5b2" class="ln kl hi lj b fi ls lp l lq lr">prod(1,2)<br/>2</span><span id="bce9" class="ln kl hi lj b fi ls lp l lq lr">prod(1,2,3)<br/>6</span><span id="6b3d" class="ln kl hi lj b fi ls lp l lq lr">prod(1,2,3,4)<br/>24</span></pre><p id="414e" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">kwargs是关键字参数的缩写</p><pre class="ju jv jw jx fd li lj lk ll aw lm bi"><span id="7511" class="ln kl hi lj b fi lo lp l lq lr">def func(**kwargs):<br/>  for key, value in kwargs.items()<br/>    print (“%s == %s” %(key, value))</span><span id="4cac" class="ln kl hi lj b fi ls lp l lq lr">func(fname="A",lname="B")</span><span id="3ae6" class="ln kl hi lj b fi ls lp l lq lr">fname == A <br/>lname == B</span></pre><h1 id="585f" class="kk kl hi bd km kn ko kp kq kr ks kt ku io kv ip kw ir kx is ky iu kz iv la lb bi translated">异常处理</h1><p id="b4be" class="pw-post-body-paragraph ix iy hi iz b ja lc ij jc jd ld im jf jg le ji jj jk lf jm jn jo lg jq jr js hb bi translated">运行时无法处理错误。可以在运行时处理异常。</p><pre class="ju jv jw jx fd li lj lk ll aw lm bi"><span id="da4f" class="ln kl hi lj b fi lo lp l lq lr">try:<br/>   Block of code </span><span id="5512" class="ln kl hi lj b fi ls lp l lq lr">except <em class="mz">ExceptionI</em>:   #specific error <br/>   If there is ExceptionI error in the try block, then execute this    <br/>   block.<br/>except Exception :   #can handle all error<br/>   If there is ExceptionII error in the try block, then execute this <br/>   block.<br/>   <br/>else:<br/>   If there is no exception then execute this block.</span><span id="a50f" class="ln kl hi lj b fi ls lp l lq lr">finally:<br/>   this block is run irrespective of whether the code returned an <br/>   error or ran succesfully</span></pre><p id="bc7e" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">例如，</p><pre class="ju jv jw jx fd li lj lk ll aw lm bi"><span id="9100" class="ln kl hi lj b fi lo lp l lq lr">try:<br/>  a=b<br/>except Exception as ex:<br/>  print(ex)<br/>else:<br/>  print(“No Error”)<br/>finally:<br/>  print(“executed”)</span><span id="78ae" class="ln kl hi lj b fi ls lp l lq lr">name 'b' is not defined <br/>executed<br/>--------------------------------------------------------------------<br/>#personalized error</span><span id="763a" class="ln kl hi lj b fi ls lp l lq lr">try:<br/>  a=b<br/>except NameError :<br/>  print("Variable b not defined")<br/>else:<br/>  print(“No Error”)<br/>finally:<br/>  print(“executed”)</span><span id="6a4a" class="ln kl hi lj b fi ls lp l lq lr">Variable b not defined <br/>executed</span></pre><h2 id="9e4e" class="ln kl hi bd km mh mi mj kq mk ml mm ku jg mn mo kw jk mp mq ky jo mr ms la mt bi translated">自定义异常处理</h2><pre class="ju jv jw jx fd li lj lk ll aw lm bi"><span id="a60a" class="ln kl hi lj b fi lo lp l lq lr">class Error(Exception):          #inherit from exception class<br/>  pass<br/>class DOBerror(Error):           #custom error <br/>  pass</span><span id="4557" class="ln kl hi lj b fi ls lp l lq lr">year=int(input())<br/>age=2021-year<br/>try:<br/>  if age&gt;1 and age&lt;=100:<br/>    print("ok")<br/>  else:<br/>    raise DOBerror<br/>except DOBerror:<br/>  print("enter valid age")</span><span id="ee44" class="ln kl hi lj b fi ls lp l lq lr">1999<br/>ok</span><span id="bdab" class="ln kl hi lj b fi ls lp l lq lr">2021 <br/>enter valid age</span></pre></div><div class="ab cl na nb gp nc" role="separator"><span class="nd bw bk ne nf ng"/><span class="nd bw bk ne nf ng"/><span class="nd bw bk ne nf"/></div><div class="hb hc hd he hf"><p id="11df" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">感谢您的阅读</p></div></div>    
</body>
</html>