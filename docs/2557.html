<html>
<head>
<title>Track web browser usage in Android using Accessibility Service</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用辅助功能服务跟踪Android中网络浏览器的使用情况</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/track-web-browser-usage-in-android-using-accessibility-service-800bfa2745d2?source=collection_archive---------6-----------------------#2021-05-11">https://medium.com/nerd-for-tech/track-web-browser-usage-in-android-using-accessibility-service-800bfa2745d2?source=collection_archive---------6-----------------------#2021-05-11</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/ca092f9c6ffc05f204c59e08cf8b324a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uuEHHXpb49owfbBnnBg20Q.jpeg"/></div></div></figure><p id="6648" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">虽然无障碍服务旨在帮助残疾用户，但它是跟踪用户行为的强大工具。它让我们能够跟踪用户手势，监控应用程序的使用，还可以从各种应用程序中读取文本等。</p><p id="0380" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们可以通过以下方式实现可访问性服务监听器来跟踪用户访问的URL。它首先以下面的方式在AndroidManifest.xml文件中定义我们的服务。</p><pre class="jo jp jq jr fd js jt ju jv aw jw bi"><span id="2b86" class="jx jy hi jt b fi jz ka l kb kc">&lt;service android:name=".LogUrlService"<br/>    android:permission="android.permission.BIND_ACCESSIBILITY_SERVICE"&gt;<br/>    &lt;intent-filter&gt;<br/>        &lt;action android:name="android.accessibilityservice.AccessibilityService" /&gt;<br/>    &lt;/intent-filter&gt;<br/>    &lt;meta-data android:name="android.accessibilityservice" android:resource="@xml/accessibilityservice" /&gt;<br/><br/>&lt;/service&gt;</span></pre><p id="a803" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们想要监听的事件类型的详细信息将保存在一个名为accessibilityservice的xml文件中。这是那个文件的内容。我们感兴趣的事件是typeWindowsChanged、typeWindowStateChanged和typeWindowContentChanged。另一个重要的属性是canRetrieveWindowContent，它被设置为true。</p><pre class="jo jp jq jr fd js jt ju jv aw jw bi"><span id="f2b0" class="jx jy hi jt b fi jz ka l kb kc">&lt;?xml version="1.0" encoding="utf-8"?&gt;<br/>&lt;accessibility-service xmlns:android="http://schemas.android.com/apk/res/android"<br/>    android:accessibilityEventTypes = "typeWindowsChanged|typeWindowStateChanged|typeWindowContentChanged"<br/>    android:accessibilityFeedbackType="feedbackVisual"<br/>    android:notificationTimeout="300"<br/>    android:accessibilityFlags="flagDefault|flagIncludeNotImportantViews|flagRequestTouchExplorationMode|flagRequestEnhancedWebAccessibility|flagReportViewIds|flagRetrieveInteractiveWindows"<br/>    android:canRetrieveWindowContent="true"<br/><br/>    &gt;<br/><br/>&lt;/accessibility-service&gt;</span></pre><p id="24b0" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">访问此服务的权限需要由用户明确授予您的应用程序，方法是导航至设置-&gt;应用程序与通知&gt;高级&gt;特殊应用程序用法&gt;辅助功能，或者我们可以通过调用辅助功能设置意图以编程方式完成此操作</p><pre class="jo jp jq jr fd js jt ju jv aw jw bi"><span id="64b7" class="jx jy hi jt b fi jz ka l kb kc">Intent intent = new Intent(Settings.<em class="kd">ACTION_ACCESSIBILITY_SETTINGS</em>);<br/>startActivity(intent);</span></pre><p id="b183" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">一旦许可被授予，每当可访问性事件被触发时，我们的服务就开始接收回调。由于该事件将由所有应用程序触发，我们需要对其进行过滤，以确保我们只处理与web浏览器相关的事件。我们需要预先知道我们要跟踪的浏览器的包名。每次事件被触发时，我们都会看到一个AccessibilityNodeInfo对象，它包括窗口内容以及这个父对象的子AccessibilityNodeInfo的树。我们寻找一个特定的节点，它代表浏览器的地址栏。这对于每个浏览器都是唯一的。这是一个一次性的活动，我们通过遍历节点，找出哪个节点包含数据，并获得相关的节点id名称。</p><pre class="jo jp jq jr fd js jt ju jv aw jw bi"><span id="b73b" class="jx jy hi jt b fi jz ka l kb kc">private void getChild(AccessibilityNodeInfo info)<br/>{<br/>    int i=info.getChildCount();<br/>    for(int p=0;p&lt;i;p++)<br/>    {<br/>        AccessibilityNodeInfo n=info.getChild(p);<br/>        if(n!=null) {<br/>            String strres = n.getViewIdResourceName();<br/>            if (n.getText() != null) {<br/>                String txt = n.getText().toString();<br/>                Log.<em class="kd">d</em>("Track", strres + "  :  " + txt);<br/>            }<br/>            getChild(n);<br/>        }<br/>    }<br/>}</span></pre><p id="6b27" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">一旦完成，我们就可以用包名和惟一的节点id名构建一个列表。以下是android上一些流行浏览器的列表</p><pre class="jo jp jq jr fd js jt ju jv aw jw bi"><span id="2582" class="jx jy hi jt b fi jz ka l kb kc">private static List&lt;SupportedBrowserConfig&gt; getSupportedBrowsers() {<br/>    List&lt;SupportedBrowserConfig&gt; browsers = new ArrayList&lt;&gt;();<br/>   <br/> browsers.add( new SupportedBrowserConfig("com.android.chrome", "com.android.chrome:id/url_bar"));<br/> <br/>   browsers.add( new SupportedBrowserConfig("org.mozilla.firefox", "org.mozilla.firefox:id/mozac_browser_toolbar_url_view"));<br/> <br/>   browsers.add( new SupportedBrowserConfig("com.opera.browser", "com.opera.browser:id/url_field"));<br/> <br/>   browsers.add( new SupportedBrowserConfig("com.opera.mini.native", "com.opera.mini.native:id/url_field"));<br/> <br/>   browsers.add( new SupportedBrowserConfig("com.duckduckgo.mobile.android", "com.duckduckgo.mobile.android:id/omnibarTextInput"));<br/> <br/>   browsers.add( new SupportedBrowserConfig("com.microsoft.emmx", "com.microsoft.emmx:id/url_bar"));<br/><br/><br/>    return browsers;<br/>}</span></pre><p id="07e6" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在剩下的工作就是在浏览器窗口激活或改变时查询特定节点的内容。</p><pre class="jo jp jq jr fd js jt ju jv aw jw bi"><span id="caaa" class="jx jy hi jt b fi jz ka l kb kc">case AccessibilityEvent.<em class="kd">TYPE_WINDOW_STATE_CHANGED</em>:<br/><br/><br/>case AccessibilityEvent.<em class="kd">TYPE_WINDOWS_CHANGED</em>:<br/>case AccessibilityEvent.<em class="kd">TYPE_WINDOW_CONTENT_CHANGED</em>: {<br/>    AccessibilityNodeInfo parentNodeInfo = event.getSource();<br/>    if (parentNodeInfo == null) {<br/>        return;<br/>    }<br/><br/>    String packageName = event.getPackageName().toString();<br/>    SupportedBrowserConfig browserConfig = null;<br/>    for (SupportedBrowserConfig supportedConfig: <em class="kd">getSupportedBrowsers</em>()) {<br/>        if (supportedConfig.packageName.equals(packageName)) {<br/>            browserConfig = supportedConfig;<br/>        }<br/>    }</span><span id="2760" class="jx jy hi jt b fi ke ka l kb kc">    if (browserConfig == null) {<br/>        return;<br/>    }<br/><br/>    String capturedUrl = captureUrl(parentNodeInfo, browserConfig);<br/>    parentNodeInfo.recycle();<br/><br/>    if (capturedUrl == null) {<br/>        return;<br/>    }</span></pre><p id="4735" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在，我们可以在后台持续监控用户访问的所有URL，即使浏览器以匿名模式运行。</p><p id="7450" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">你可以在这里找到这个项目的源文件<a class="ae kf" href="https://github.com/venkymani/LogUrl" rel="noopener ugc nofollow" target="_blank"/></p></div></div>    
</body>
</html>