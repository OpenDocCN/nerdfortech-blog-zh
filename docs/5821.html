<html>
<head>
<title>Intro to Convolutional Coding — Part III</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">卷积编码简介—第三部分</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/intro-to-convolutional-coding-part-iii-5529fdeebdb6?source=collection_archive---------2-----------------------#2021-11-21">https://medium.com/nerd-for-tech/intro-to-convolutional-coding-part-iii-5529fdeebdb6?source=collection_archive---------2-----------------------#2021-11-21</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/94a3073dd9437d36b4565d0ac705c478.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*are3e5XQsuPnFPud"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">由<a class="ae iu" href="https://unsplash.com/@markusspiske?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Markus Spiske </a>在<a class="ae iu" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="dfcf" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这篇文章展示了一个使用 Viterbi 算法解码的非递归卷积码的 Python 实现示例。我之前关于该主题的帖子大致介绍了这些代码，并回顾了<a class="ae iu" href="https://yair-mz.medium.com/into-to-convolutional-coding-part-i-d63decab56a0" rel="noopener">编码</a>和<a class="ae iu" href="https://yair-mz.medium.com/intro-to-convolutional-coding-part-ii-d289c109ff7a" rel="noopener">解码</a>的过程。我的完整实现可以在专门的 GitHub gist 上找到。然而，我写它是为了好玩，它的目的是有教育意义。更好、更优化(尽管不一定容易阅读)的实现是存在的。</p><h1 id="3902" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">卷积码类</h1><h2 id="b463" class="kr ju hi bd jv ks kt ku jz kv kw kx kd jg ky kz kh jk la lb kl jo lc ld kp le bi translated">构造器</h2><p id="0a3f" class="pw-post-body-paragraph iv iw hi ix b iy lf ja jb jc lg je jf jg lh ji jj jk li jm jn jo lj jq jr js hb bi translated"><code class="du lk ll lm ln b">ConvolutionalCode</code>类实现了前面讨论的编码器和解码器。构造函数接收一个整数元组，每个表示一个生成器。</p><figure class="lo lp lq lr fd ij"><div class="bz dy l di"><div class="ls lt l"/></div></figure><p id="c5f9" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">构造函数从生成器的数量来推断代码的速率(为了简单起见，我们只考虑<code class="du lk ll lm ln b">k=1</code>)。约束长度由最大生成器以及 FSM 的状态确定。最后，调用<code class="du lk ll lm ln b">_build_fsm</code>方法。</p><h2 id="483e" class="kr ju hi bd jv ks kt ku jz kv kw kx kd jg ky kz kh jk la lb kl jo lc ld kp le bi translated">有限状态机（Finite State Machine 的缩写）</h2><p id="b2e9" class="pw-post-body-paragraph iv iw hi ix b iy lf ja jb jc lg je jf jg lh ji jj jk li jm jn jo lj jq jr js hb bi translated"><code class="du lk ll lm ln b">_build_fsm</code>方法将 FSM 指定为两个嵌套字典。根据<code class="du lk ll lm ln b">state</code>和<code class="du lk ll lm ln b">input</code>，字典<code class="du lk ll lm ln b">next_states</code>包含 FSM 中的下一个状态:</p><pre class="lo lp lq lr fd lu ln lv lw aw lx bi"><span id="344f" class="kr ju hi ln b fi ly lz l ma mb">self.next_states[current_state][current_input]</span></pre><p id="56fd" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">新状态是通过右移旧状态(丢弃 LSB)并添加左移输入来找到的。</p><pre class="lo lp lq lr fd lu ln lv lw aw lx bi"><span id="58b8" class="kr ju hi ln b fi ly lz l ma mb">new_state = (current_input &lt;&lt; (self.constraint_length - 1)) + (current_state &gt;&gt; self.k)</span></pre><p id="cee0" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">根据<code class="du lk ll lm ln b">state</code>和<code class="du lk ll lm ln b">input</code>，字典<code class="du lk ll lm ln b">out_bits</code>保存由编码器输出的位值(根据发生器数量的位数):</p><pre class="lo lp lq lr fd lu ln lv lw aw lx bi"><span id="43cd" class="kr ju hi ln b fi ly lz l ma mb">self.out_bits[current_state][current_input]</span></pre><p id="2995" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">对于每个生成器，获得一个位反转表示(由于用于指定生成器的约定)。</p><pre class="lo lp lq lr fd lu ln lv lw aw lx bi"><span id="1614" class="kr ju hi ln b fi ly lz l ma mb">bit_reversed_gen = int('{:0{width}b}'.format(gen, width=self.constraint_length+1)[::-1], 2)</span></pre><p id="649f" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">将左移输入添加到状态以表示 LSR。</p><pre class="lo lp lq lr fd lu ln lv lw aw lx bi"><span id="4839" class="kr ju hi ln b fi ly lz l ma mb">lsr = (current_input &lt;&lt; self.constraint_length) + current_state</span></pre><p id="1657" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">以发生器为掩码应用按位<code class="du lk ll lm ln b">&amp;</code></p><pre class="lo lp lq lr fd lu ln lv lw aw lx bi"><span id="574b" class="kr ju hi ln b fi ly lz l ma mb">generator_masked_sum_arg = bit_reversed_gen &amp; (lsr)  # mask input and state with generator</span></pre><p id="cd8c" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">对 mod 2 位求和以获得输出位</p><pre class="lo lp lq lr fd lu ln lv lw aw lx bi"><span id="0718" class="kr ju hi ln b fi ly lz l ma mb">bin(generator_masked_sum_arg).count("1") % 2</span></pre><p id="d6d6" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">完整的方法如下所示</p><figure class="lo lp lq lr fd ij"><div class="bz dy l di"><div class="ls lt l"/></div></figure><h2 id="c1f0" class="kr ju hi bd jv ks kt ku jz kv kw kx kd jg ky kz kh jk la lb kl jo lc ld kp le bi translated">编码器</h2><p id="ae99" class="pw-post-body-paragraph iv iw hi ix b iy lf ja jb jc lg je jf jg lh ji jj jk li jm jn jo lj jq jr js hb bi translated">为简单起见，我们假设编码器的输入表示为<code class="du lk ll lm ln b">bytes</code>。我们将输入转换为二进制形式，将状态机初始化为零状态，然后一次将一位输入 FSM，对序列进行编码。一个额外的步骤是在用“约束长度”比特编码之前用零填充流的结尾。填充确保状态机以确定的状态完成编码过程，帮助解码器选择一条幸存路径。这种填充称为“零尾终止”。</p><figure class="lo lp lq lr fd ij"><div class="bz dy l di"><div class="ls lt l"/></div></figure><h2 id="1f28" class="kr ju hi bd jv ks kt ku jz kv kw kx kd jg ky kz kh jk la lb kl jo lc ld kp le bi translated">解码器</h2><p id="d3d7" class="pw-post-body-paragraph iv iw hi ix b iy lf ja jb jc lg je jf jg lh ji jj jk li jm jn jo lj jq jr js hb bi translated">为了解码，我们需要遍历各种网格路径。于是我写了一个<code class="du lk ll lm ln b">TrellisPath</code>类。该类将路径保存为状态列表。它还保存了与路径、路径中的最后状态、路径长度和路径度量相对应的输入位列表。它还实现了一个<code class="du lk ll lm ln b">add_2_path</code>方法，该方法允许向路径添加一个新的状态、一个位输入和一个分支度量。<code class="du lk ll lm ln b">duplicate_path</code>类方法允许复制路径，因为路径必须被复制。</p><figure class="lo lp lq lr fd ij"><div class="bz dy l di"><div class="ls lt l"/></div></figure><p id="1a58" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">使用<code class="du lk ll lm ln b">TrellisPath</code>我们可以实现解码器。首先，将接收到的序列分解成 n 位的组，并初始化幸存路径列表</p><pre class="lo lp lq lr fd lu ln lv lw aw lx bi"><span id="8ccc" class="kr ju hi ln b fi ly lz l ma mb">received_codewords = [tuple(data[i: i+self.n]) for i in range(0, len(data), self.n)]    <br/>surviving_paths = [TrellisPath()]</span></pre><p id="0db4" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">然后迭代每个码字。对于每个码字，迭代<code class="du lk ll lm ln b">surviving_paths</code>。对于每条路径，找到由<code class="du lk ll lm ln b">possible_input</code>指定的<code class="du lk ll lm ln b">possible_transitions</code>，并以路径和分支度量为特征。这些<code class="du lk ll lm ln b">possible_transitions</code>中的每一个在分支时都会产生<em class="mc"> k </em>条潜在路径。然而，网格中的每个节点有多个<code class="du lk ll lm ln b">entring_paths</code>。在进入节点的那些路径中，具有最小路径度量的路径被选择以形成<code class="du lk ll lm ln b">new_path</code>，在下一个码字的迭代期间被认为是<code class="du lk ll lm ln b">surviving_paths</code>。代码如下所示。</p><figure class="lo lp lq lr fd ij"><div class="bz dy l di"><div class="ls lt l"/></div></figure></div><div class="ab cl md me gp mf" role="separator"><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi"/></div><div class="hb hc hd he hf"><h1 id="4e2d" class="jt ju hi bd jv jw mk jy jz ka ml kc kd ke mm kg kh ki mn kk kl km mo ko kp kq bi translated">完整的代码和例子</h1><p id="54ab" class="pw-post-body-paragraph iv iw hi ix b iy lf ja jb jc lg je jf jg lh ji jj jk li jm jn jo lj jq jr js hb bi translated"><a class="ae iu" href="https://gist.github.com/YairMZ/b88e594047c7b5366053cd7fb375a94f" rel="noopener ugc nofollow" target="_blank">要点</a>还包括作为单个可运行文件的全部代码。在底部，我添加了两个运行它的最小的例子。</p><figure class="lo lp lq lr fd ij"><div class="bz dy l di"><div class="ls lt l"/></div></figure></div></div>    
</body>
</html>