<html>
<head>
<title>TypeScript Generics and Type Composition</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">类型脚本泛型和类型组合</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/typescript-generics-and-dynamic-type-composition-8f055151711f?source=collection_archive---------18-----------------------#2021-06-06">https://medium.com/nerd-for-tech/typescript-generics-and-dynamic-type-composition-8f055151711f?source=collection_archive---------18-----------------------#2021-06-06</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="6663" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">TypeScript 泛型类型非常强大，它们允许我们进行类型组合，这是一种可以在每个 TS 项目中使用的惊人模式。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es jd"><img src="../Images/9ed6f589f071251da2ff6da6810db5a7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jTTpW1Pjmmx930u6U3vPcg.jpeg"/></div></div></figure><p id="5ecd" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如何使用泛型？使用泛型真的很简单，我们只需要告诉 TS 我们的类型接受其他类型是“完整的”。<br/>因此，如果我们有一些类型<strong class="ih hj"> <em class="jp"> A </em> </strong>和一些动态属性“<em class="jp"> dynamicObj </em>”基于使用地点，很难静态地定义所有属性类型，因为我们需要为“<em class="jp"> dynamicObj </em>”指定所有可能的类型。</p><pre class="je jf jg jh fd jq jr js jt aw ju bi"><span id="572c" class="jv jw hi jr b fi jx jy l jz ka">type B = {<br/>  keyA: string;<br/>  keyB: string;<br/>}</span><span id="fa7f" class="jv jw hi jr b fi kb jy l jz ka">type C = {<br/>  keyT: number;<br/>  keyV: boolean;<br/>}</span></pre><p id="0534" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在有一个简单且完全不安全的解决方案:<strong class="ih hj"> <em class="jp">“就说 dynamicObject 是 any 类型的”<br/> </em> </strong> <em class="jp">当然，你永远不应该使用这个，在你的代码中有任何类型都是“代码味”的一个巨大标志。此外，我们可以用未知的，然后做定型。</em></p><pre class="je jf jg jh fd jq jr js jt aw ju bi"><span id="819d" class="jv jw hi jr b fi jx jy l jz ka"><em class="jp">type A </em>= {<br/>  prop: <em class="jp">string</em>;<br/>  dynamicObject: unknown;<br/>};</span><span id="9459" class="jv jw hi jr b fi kb jy l jz ka">const aWithB: A = {<br/>  prop: 'ok',<br/>  dynamicObject: {<br/>    keyA: 'test',<br/>    keyB: 'ok'<br/>  }<br/>}</span><span id="ec03" class="jv jw hi jr b fi kb jy l jz ka">console.log((aWithB.dynamicObject as B).keyA) // NOT SO GOOD 😓 </span></pre><p id="a345" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们可以在 dynamicObject 属性上用<strong class="ih hj"> UnionType </strong>更进一步。</p><pre class="je jf jg jh fd jq jr js jt aw ju bi"><span id="b5fb" class="jv jw hi jr b fi jx jy l jz ka"><em class="jp">type A </em>= {<br/>  prop: <em class="jp">string</em>;<br/>  dynamicObject: B | C;<br/>};</span><span id="25fd" class="jv jw hi jr b fi kb jy l jz ka">const aWithB: A = {<br/>  prop: 'ok',<br/>  dynamicObject: {<br/>    keyA: 'test',<br/>    keyB: 'ok'<br/>  }<br/>}</span><span id="bc83" class="jv jw hi jr b fi kb jy l jz ka">console.log(<br/>  (aWithB.dynamicObject as B).keyA // We still need to cast type 😞 <br/>)</span></pre><p id="29cb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">所以让我们看看如何用泛型解决这个问题</strong></p><p id="fab3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果我们将类型 A 指定为具有某些属性(如 prop 和 dynamicObj)的类型，我们知道 dynamicObj 依赖于使用位置。然后，我们可以将类型 A 定义为接受另一个类型的类型，该类型将是属性 dynamicObject 的类型。听起来比实际更复杂。</p><pre class="je jf jg jh fd jq jr js jt aw ju bi"><span id="067e" class="jv jw hi jr b fi jx jy l jz ka"><em class="jp">type A&lt;DynamicObjectType&gt; </em>= {<br/>  prop: <em class="jp">string</em>;<br/>  dynamicObject: <em class="jp">DynamicObjectType</em>;<br/>};</span><span id="c5ce" class="jv jw hi jr b fi kb jy l jz ka">const aWithB: A&lt;B&gt; = {<br/>  prop: 'ok',<br/>  dynamicObject: {<br/>    keyA: 'test',<br/>    keyB: 'ok'<br/>  }<br/>}</span><span id="5638" class="jv jw hi jr b fi kb jy l jz ka">const aWithC: A&lt;C&gt; = {<br/>  prop: 'ok',<br/>  dynamicObject: {<br/>    keyT: 11,<br/>    keyV: true<br/>  }<br/>}</span><span id="da26" class="jv jw hi jr b fi kb jy l jz ka">console.log(aWithB.dynamicObject.keyA);<br/>console.log(aWithC.dynamicObject.keyV);</span><span id="ae8f" class="jv jw hi jr b fi kb jy l jz ka">// No warnings, no compilation error 🤩 </span></pre><p id="3edc" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">也就是说，现在我们的类型 A 是可伸缩的，可以扩展到任意数量的可以是 dynamicObject 属性的类型。甚至这也是一个有效的类型:</p><pre class="je jf jg jh fd jq jr js jt aw ju bi"><span id="00b8" class="jv jw hi jr b fi jx jy l jz ka">const foo: A&lt;number&gt; = {<br/>  prop: "lol",<br/>  dynamicObject: 11<br/>}</span></pre><p id="c087" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这就是你如何在类型组合中收获泛型的力量，非常简单！</p><p id="e16b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">快乐的编码！</p></div></div>    
</body>
</html>