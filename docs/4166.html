<html>
<head>
<title>An introduction to recursion in Javascript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Javascript 中递归的介绍</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/an-introduction-to-recursion-in-javascript-8a42b200ec0a?source=collection_archive---------13-----------------------#2021-07-09">https://medium.com/nerd-for-tech/an-introduction-to-recursion-in-javascript-8a42b200ec0a?source=collection_archive---------13-----------------------#2021-07-09</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/f9b5a4f0ee577ded290366b20f31427b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*i3wpfHFNCase2Wr8"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated"><a class="ae iu" href="https://unsplash.com/@tine999?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">蒂内·伊万尼奇</a>在<a class="ae iu" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄的照片</figcaption></figure><p id="8169" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如果你正在探索函数式编程，那么学习如何循环是值得的，因为循环是你会发现自己在整个项目中使用的一个关键工具。在这个行业中，没有办法真正避免它，除非你只是编写没有重复元素的非常小的应用程序。</p><p id="0425" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如果你熟悉函数式编程中的 for、while 和 forEach 循环方式，你应该把它们抛在脑后，因为它们是面向对象编程/命令式范式的(没有双关的意思)。但是绝对不要忘记他们。毕竟，函数式编程不是宗教，它只是一种编写代码的方式，这主要取决于您的项目需要什么。</p><p id="8253" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">不过，不要告诉其他人我说过这话，他们可能会认为这是一种亵渎。*咳嗽*。</p><p id="3a20" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">本质上，递归只是一个从内部调用自身的函数(或者高阶函数调用低阶函数 x 次)。</p><p id="ba3e" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">让我们看一个简单的递归函数。</p><pre class="jt ju jv jw fd jx jy jz ka aw kb bi"><span id="ad0f" class="kc kd hi jy b fi ke kf l kg kh">const rebelScum = (times, index = 0) =&gt; {</span><span id="1360" class="kc kd hi jy b fi ki kf l kg kh">   if (index === times) return;</span><span id="2972" class="kc kd hi jy b fi ki kf l kg kh">   console.log('You rebel scum.');<br/>   rebelScum(times, index + 1);<br/>};</span></pre><p id="7326" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这将会，你大概能猜到，输出“你这个叛逆的人渣。”x 到控制台的次数。本质上，这或多或少就是 for 循环的工作方式。以下是构建递归函数的一些简单指南:</p><ol class=""><li id="4742" class="kj kk hi ix b iy iz jc jd jg kl jk km jo kn js ko kp kq kr bi translated">必须有计数器参数。</li><li id="da8b" class="kj kk hi ix b iy ks jc kt jg ku jk kv jo kw js ko kp kq kr bi translated">必须有退出条件。</li></ol><p id="8fdb" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">差不多就是这样。简单吧？没错。递归函数可以:</p><ul class=""><li id="92ce" class="kj kk hi ix b iy iz jc jd jg kl jk km jo kn js kx kp kq kr bi translated">对于 n 维数组/对象有多个计数器。</li><li id="d662" class="kj kk hi ix b iy ks jc kt jg ku jk kv jo kw js kx kp kq kr bi translated">动态改变循环次数。</li><li id="b9f7" class="kj kk hi ix b iy ks jc kt jg ku jk kv jo kw js kx kp kq kr bi translated">做浓缩咖啡(或者不做)。</li></ul><p id="07ff" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">让我们来看一个更实用的递归函数:</p><figure class="jt ju jv jw fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ky"><img src="../Images/90105433ce374a8b746089b461584c3f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*i2zUE5X3ZEOtDIS6KPDGEw.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">递归复合函数</figcaption></figure><p id="6af9" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们得到的输出是:</p><figure class="jt ju jv jw fd ij er es paragraph-image"><div class="er es kz"><img src="../Images/0256fb3e4b98694968dad6cbbd00dd5a.png" data-original-src="https://miro.medium.com/v2/resize:fit:884/format:webp/1*5V0GEwjKzcQzGLLAajS0Eg.png"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">输出</figcaption></figure><p id="2f11" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">事情是这样的:</p><ul class=""><li id="79c6" class="kj kk hi ix b iy iz jc jd jg kl jk km jo kn js kx kp kq kr bi translated">首先，它检查 index 是否等于 period。如果是，则返回(跳到末尾)，然后返回数组。</li><li id="8bb0" class="kj kk hi ix b iy ks jc kt jg ku jk kv jo kw js kx kp kq kr bi translated">else 语句首先触发，因为索引不大于 0，复合起始原则并将其作为数组中的第一个元素添加。</li><li id="3e5f" class="kj kk hi ix b iy ks jc kt jg ku jk kv jo kw js kx kp kq kr bi translated">该函数调用自身，将更新后的内容作为参数传递给自身，并再次遍历所有 if 语句。</li><li id="a1ac" class="kj kk hi ix b iy ks jc kt jg ku jk kv jo kw js kx kp kq kr bi translated">由于 index 现在大于 0，它复合最后一个数组元素并将其推送到数组中。</li><li id="22f3" class="kj kk hi ix b iy ks jc kt jg ku jk kv jo kw js kx kp kq kr bi translated">在最后一次循环中，index 现在等于 T，因此进行了一次限定范围的返回，跳到函数的末尾并返回数组。</li></ul><p id="4555" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如果我们不提供第一个检查，或者把它放在最后，我们就会得到一个无限循环，也就是所谓的堆栈溢出或 JS，<code class="du la lb lc jy b">maximum call stack exceeded</code>。这个循环实际上可能不是无限的(尽管它当然可能是无限的)，但是这个函数被调用的次数太多，以至于它超过了浏览器或系统的可用内存。</p><p id="e9a1" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">下面是另一个创建 rgb 颜色数组的示例:</p><figure class="jt ju jv jw fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ld"><img src="../Images/7569015199060aaedbf3d05b3417585e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NynFf0f7tIovwA9i8BFEtw.png"/></div></div></figure><p id="defa" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">然而这并不是实现递归的唯一方法。您也可以使用递归函数调用常规函数，使用与上面相同的原理。</p><h2 id="9218" class="kc kd hi bd le lf lg lh li lj lk ll lm jg ln lo lp jk lq lr ls jo lt lu lv lw bi translated">让我们回顾一下:</h2><ul class=""><li id="6dd6" class="kj kk hi ix b iy lx jc ly jg lz jk ma jo mb js kx kp kq kr bi translated">递归是当一个函数调用它自己或另一个函数，直到它到达一个条件退出(或崩溃你的 IDE)。</li><li id="95ff" class="kj kk hi ix b iy ks jc kt jg ku jk kv jo kw js kx kp kq kr bi translated">您应该始终实现一种方法来让递归函数退出。</li><li id="6ba0" class="kj kk hi ix b iy ks jc kt jg ku jk kv jo kw js kx kp kq kr bi translated">递归函数最常用于函数式编程。</li><li id="e2e5" class="kj kk hi ix b iy ks jc kt jg ku jk kv jo kw js kx kp kq kr bi translated">在函数式编程中使用 for 和 while 循环对某些人来说是不可饶恕的大罪，因此递归是一项必须掌握的技能。</li><li id="abb4" class="kj kk hi ix b iy ks jc kt jg ku jk kv jo kw js kx kp kq kr bi translated">尽管如此……函数式编程不是一种宗教😏。</li></ul></div></div>    
</body>
</html>