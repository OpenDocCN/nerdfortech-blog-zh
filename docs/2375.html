<html>
<head>
<title>All About JAVA Virtual Machine (JVM)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">关于JAVA虚拟机的一切</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/all-about-java-virtual-machine-jvm-2ef665c770b8?source=collection_archive---------14-----------------------#2021-05-03">https://medium.com/nerd-for-tech/all-about-java-virtual-machine-jvm-2ef665c770b8?source=collection_archive---------14-----------------------#2021-05-03</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/935fa5b2350305314d9f2c4ff46ccd24.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iK1EFamgj6pjOvuhROEFNA.jpeg"/></div></div></figure><p id="5252" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在我们开始学习JVM (Java虚拟机)之前，我们需要了解什么是虚拟机。所以虚拟意味着不在现实中。这台机器是完成我们工作的某种装置。所以虚拟机是不存在的东西。虚拟机主要可以分为两类。</p><ol class=""><li id="f665" class="jo jp hi is b it iu ix iy jb jq jf jr jj js jn jt ju jv jw bi translated"><strong class="is hj">基于系统的</strong></li><li id="5561" class="jo jp hi is b it jx ix jy jb jz jf ka jj kb jn jt ju jv jw bi translated"><strong class="is hj">基于应用/基于流程</strong></li></ol><p id="08ac" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">基于系统的虚拟机可能有一个或多个硬件，它会创建多个彼此完全独立的环境。</p><p id="5bde" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">基于应用程序的虚拟机不涉及任何硬件。但是可能有软件可以帮助你创建一个运行其他程序的平台。</p><p id="c2ee" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">因为这是基于应用的，我们可以把它看作一个程序。所以JVM是一个基于应用的VM。JVM是一个规范，它说明了应该如何去做。当我们安装Java运行时环境(JRE)时，它会部署特定的代码来为特定的平台创建一个JVM。</p><figure class="kd ke kf kg fd ij er es paragraph-image"><div class="er es kc"><img src="../Images/0ac122b74b41a45bc537653b3bf9a2a7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1098/format:webp/1*52-zto0b0rPXoQeRyXYYNA.png"/></div></figure><p id="2194" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">当你启动一个java程序时，它会在你的计算机上创建一个JVM实例。你的程序退出的时候，JVM实例也被破坏了。假设你同时在电脑上运行三个Java程序。那么那时有多少JVM实例呢？</p><p id="af9b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">答案是3。因为那时您计算机上将有3个不同的JVM实例。</strong></p><p id="f97f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们使用<strong class="is hj">javac&lt;Filename&gt;T7】将java文件编译成类文件。</strong></p><p id="a123" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">为了运行我们使用<strong class="is hj"> java &lt;文件名&gt;T9】</strong></p><p id="3d46" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">所以当你给java的时候，意味着你告诉你的操作系统给我一个JVM实例。当JVM创建它时，创建一个非恶魔线程。在我们的类中应该有public static void main方法。所以当JVM创建时，它执行main方法。</p><p id="6e68" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">JVM可以通过两种方式被破坏。</p><ol class=""><li id="193d" class="jo jp hi is b it iu ix iy jb jq jf jr jj js jn jt ju jv jw bi translated">如果所有非恶魔线程都被破坏。</li><li id="bdb1" class="jo jp hi is b it jx ix jy jb jz jf ka jj kb jn jt ju jv jw bi translated">当应用程序调用System.exit()时</li></ol></div><div class="ab cl kh ki gp kj" role="separator"><span class="kk bw bk kl km kn"/><span class="kk bw bk kl km kn"/><span class="kk bw bk kl km"/></div><div class="hb hc hd he hf"><h1 id="a5ef" class="ko kp hi bd kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll bi translated">JAVA虚拟机内部</h1><figure class="kd ke kf kg fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lm"><img src="../Images/4330e51fab08b6e497ff6d69388e3560.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LuKOZMDCX8e1zDyGyMUu_w.png"/></div></div><figcaption class="ln lo et er es lp lq bd b be z dx translated">JVM的高级图</figcaption></figure><p id="070d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在JVM中，我们主要有3个部分。</p><ol class=""><li id="1cc5" class="jo jp hi is b it iu ix iy jb jq jf jr jj js jn jt ju jv jw bi translated">类装入器</li><li id="f387" class="jo jp hi is b it jx ix jy jb jz jf ka jj kb jn jt ju jv jw bi translated">存储区</li><li id="3a13" class="jo jp hi is b it jx ix jy jb jz jf ka jj kb jn jt ju jv jw bi translated">执行引擎</li></ol><figure class="kd ke kf kg fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lr"><img src="../Images/4240a044d960b79016acad6355fc5c9a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ENrQWfusPlBRv3mEwMlA2g.jpeg"/></div></div><figcaption class="ln lo et er es lp lq bd b be z dx translated">JVM内部</figcaption></figure><p id="ecfe" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">先说一下类加载器。</p><h1 id="936a" class="ko kp hi bd kq kr ls kt ku kv lt kx ky kz lu lb lc ld lv lf lg lh lw lj lk ll bi translated">1.类装入器</h1><p id="f467" class="pw-post-body-paragraph iq ir hi is b it lx iv iw ix ly iz ja jb lz jd je jf ma jh ji jj mb jl jm jn hb bi translated">类装入器的主要职责是将类装入内存。除此之外，还有一些其他的责任。这些可以分为三个部分。</p><ol class=""><li id="eaf6" class="jo jp hi is b it iu ix iy jb jq jf jr jj js jn jt ju jv jw bi translated">装货</li><li id="74f9" class="jo jp hi is b it jx ix jy jb jz jf ka jj kb jn jt ju jv jw bi translated">连接</li><li id="8f8c" class="jo jp hi is b it jx ix jy jb jz jf ka jj kb jn jt ju jv jw bi translated">初始化</li></ol><h2 id="c684" class="mc kp hi bd kq md me mf ku mg mh mi ky jb mj mk lc jf ml mm lg jj mn mo lk mp bi translated"><strong class="ak">加载</strong></h2><p id="fb9e" class="pw-post-body-paragraph iq ir hi is b it lx iv iw ix ly iz ja jb lz jd je jf ma jh ji jj mb jl jm jn hb bi translated">当JVM读取文件来加载它时，</p><ol class=""><li id="f4a4" class="jo jp hi is b it iu ix iy jb jq jf jr jj js jn jt ju jv jw bi translated">读取完全限定的类名</li></ol><p id="290c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">2.读取变量信息</p><p id="7a5d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">3.读取直系父代信息</p><p id="25ec" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">4.读取这是类还是接口</p><p id="9310" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">所以读取这些信息并加载到主存区。当每一个类被加载时，JVM从类类型中创建对象。(每个类只有一个对象正在创建)</p><h2 id="e2d7" class="mc kp hi bd kq md me mf ku mg mh mi ky jb mj mk lc jf ml mm lg jj mn mo lk mp bi translated"><strong class="ak">链接</strong></h2><p id="bbd4" class="pw-post-body-paragraph iq ir hi is b it lx iv iw ix ly iz ja jb lz jd je jf ma jh ji jj mb jl jm jn hb bi translated">链接主要分为三个部分。</p><ol class=""><li id="3f48" class="jo jp hi is b it iu ix iy jb jq jf jr jj js jn jt ju jv jw bi translated"><strong class="is hj">验证</strong></li><li id="91b1" class="jo jp hi is b it jx ix jy jb jz jf ka jj kb jn jt ju jv jw bi translated"><strong class="is hj">准备</strong></li><li id="5d80" class="jo jp hi is b it jx ix jy jb jz jf ka jj kb jn jt ju jv jw bi translated"><strong class="is hj">分辨率</strong></li></ol><p id="129c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">验证</strong></p><p id="76da" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在验证中，它有一个叫做字节码验证器的子程序，</p><p id="41a3" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这个类是否来自一个有效的编译器？</p><p id="9d55" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这个类是否有正确的结构？</p><p id="594d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">该调用文件的格式是否正确？</p><p id="e970" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如果以上不满足，JVM将抛出一个异常，称为验证器异常。如果一切顺利，它将进入准备阶段。</p><p id="6881" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">准备</strong></p><p id="b427" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">准备意味着如果你在你的类中使用了任何实例级变量或者静态变量，这个准备部分会给它们分配一个默认值。</p><p id="50c2" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">例如:</p><p id="ad51" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">object -&gt; null，int -&gt; zero，boolean -&gt; false</p><p id="e12a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">决议</strong></p><p id="da7d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在java中，我们可以创建一个类，我们可以给它命名，比如雇员，学生等等。但是当涉及到机器代码时，就没有所谓的雇员或学生了，因为一切都是领域特定的对象。JVM也不理解学生或雇员。所以在类转换为机器级JVM之前，用直接链接替换那些符号链接。</p><h2 id="ab50" class="mc kp hi bd kq md me mf ku mg mh mi ky jb mj mk lc jf ml mm lg jj mn mo lk mp bi translated"><strong class="ak">初始化</strong></h2><p id="4e72" class="pw-post-body-paragraph iq ir hi is b it lx iv iw ix ly iz ja jb lz jd je jf ma jh ji jj mb jl jm jn hb bi translated">在初始化部分，它将分配实数值并执行静态块。每个类在使用之前都必须初始化一个规则。那么什么是主动使用。积极使用意味着它可以是，</p><ol class=""><li id="70c1" class="jo jp hi is b it iu ix iy jb jq jf jr jj js jn jt ju jv jw bi translated">使用新关键字。</li><li id="7a1b" class="jo jp hi is b it jx ix jy jb jz jf ka jj kb jn jt ju jv jw bi translated">调用静态方法。</li><li id="7270" class="jo jp hi is b it jx ix jy jb jz jf ka jj kb jn jt ju jv jw bi translated">为静态字段赋值</li><li id="b6f1" class="jo jp hi is b it jx ix jy jb jz jf ka jj kb jn jt ju jv jw bi translated">初始化类</li><li id="03b7" class="jo jp hi is b it jx ix jy jb jz jf ka jj kb jn jt ju jv jw bi translated">获取实例</li><li id="8ae4" class="jo jp hi is b it jx ix jy jb jz jf ka jj kb jn jt ju jv jw bi translated">实例化子类</li></ol><p id="f9fc" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在任何这些主动使用之前，它必须经过初始化阶段。</p><p id="8064" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">还有一些其他的事情也发生在初始化部分。当编译器编译一个类时，它将创建一个匿名方法，并在该方法中存储实例级变量和静态变量。因此，如果我们没有任何类型的静态变量或实例变量，这个匿名方法将不会被创建。</p><p id="978c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">JVM还会为每个构造函数创建一个名为init的方法。在init方法()中，</p><ol class=""><li id="22f5" class="jo jp hi is b it iu ix iy jb jq jf jr jj js jn jt ju jv jw bi translated">可以有一段代码来调用一些其他的构造函数init方法()。</li><li id="9d75" class="jo jp hi is b it jx ix jy jb jz jf ka jj kb jn jt ju jv jw bi translated">对于特定的实现，可以有字节码。</li><li id="b594" class="jo jp hi is b it jx ix jy jb jz jf ka jj kb jn jt ju jv jw bi translated">可以有初始化实例变量的代码。</li></ol><p id="23f5" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这两种方法都不能被开发者访问。</p><h1 id="45bf" class="ko kp hi bd kq kr ls kt ku kv lt kx ky kz lu lb lc ld lv lf lg lh lw lj lk ll bi translated">2.存储区</h1><p id="0402" class="pw-post-body-paragraph iq ir hi is b it lx iv iw ix ly iz ja jb lz jd je jf ma jh ji jj mb jl jm jn hb bi translated">JVM存储区主要分为5个子部分。</p><ol class=""><li id="4c11" class="jo jp hi is b it iu ix iy jb jq jf jr jj js jn jt ju jv jw bi translated">方法区域—保留类别信息(常量池、方法数据、方法代码、字段数据)</li><li id="06b4" class="jo jp hi is b it jx ix jy jb jz jf ka jj kb jn jt ju jv jw bi translated">堆区域—保存所有对象信息</li><li id="87ce" class="jo jp hi is b it jx ix jy jb jz jf ka jj kb jn jt ju jv jw bi translated">堆栈—保留方法和变量信息</li><li id="a51a" class="jo jp hi is b it jx ix jy jb jz jf ka jj kb jn jt ju jv jw bi translated">PC寄存器—仅当执行方法不是本机方法时，保存关于下一次执行的信息。</li><li id="d5f6" class="jo jp hi is b it jx ix jy jb jz jf ka jj kb jn jt ju jv jw bi translated">本机方法区域—存储有关本机信息的详细信息。</li></ol><h1 id="ef87" class="ko kp hi bd kq kr ls kt ku kv lt kx ky kz lu lb lc ld lv lf lg lh lw lj lk ll bi translated">3.执行引擎</h1><p id="0855" class="pw-post-body-paragraph iq ir hi is b it lx iv iw ix ly iz ja jb lz jd je jf ma jh ji jj mb jl jm jn hb bi translated">执行引擎执行分配给运行时数据区的字节码。执行引擎主要包含三个部分。</p><ol class=""><li id="e101" class="jo jp hi is b it iu ix iy jb jq jf jr jj js jn jt ju jv jw bi translated">解释者</li><li id="1a93" class="jo jp hi is b it jx ix jy jb jz jf ka jj kb jn jt ju jv jw bi translated">JIT编译器(实时编译器)</li><li id="9c0d" class="jo jp hi is b it jx ix jy jb jz jf ka jj kb jn jt ju jv jw bi translated">垃圾收集工</li></ol><p id="060a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">解释者</p><p id="1449" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">解释器解释字节码并逐行执行指令。解释器的问题是它每次都要解释，甚至多次解释同一个方法，这降低了系统的性能。</p><p id="5e8e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">JIT编译器</p><p id="3e26" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">JIT编译器弥补了解释器执行速度慢的缺点，提高了性能。JIT编译器能够在运行时将字节码转换为机器码的同时执行某些简单的优化。</p><p id="17dd" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">垃圾收集工</p><p id="49f3" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">垃圾收集器检查堆中未使用的对象，并移除和回收内存。垃圾收集器是一个自动管理内存的java程序。这是一个后台运行的守护线程。</p></div><div class="ab cl kh ki gp kj" role="separator"><span class="kk bw bk kl km kn"/><span class="kk bw bk kl km kn"/><span class="kk bw bk kl km"/></div><div class="hb hc hd he hf"><h1 id="d5f7" class="ko kp hi bd kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll bi translated">参考</h1><p id="d2da" class="pw-post-body-paragraph iq ir hi is b it lx iv iw ix ly iz ja jb lz jd je jf ma jh ji jj mb jl jm jn hb bi translated">执行引擎(https://www . geeks forgeeks . org/execution-Engine-in-Java/)</p><p id="7d3b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">即时编译器(https://www . geeks forgeeks . org/just-In-Time-Compiler/)</p><p id="6dcf" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">CodeLabs(https://www . YouTube . com/watch？v = butiwbafkc &amp; list = PLD-myte BG 3 x-RF 1 Hu 16 AC 3 RF 9 e-maak XJ)</p></div></div>    
</body>
</html>