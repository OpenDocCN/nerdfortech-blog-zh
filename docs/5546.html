<html>
<head>
<title>LeetCode — Unique Paths</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">LeetCode —唯一路径</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/leetcode-unique-paths-1050e5e6d0e7?source=collection_archive---------10-----------------------#2021-10-14">https://medium.com/nerd-for-tech/leetcode-unique-paths-1050e5e6d0e7?source=collection_archive---------10-----------------------#2021-10-14</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><h1 id="f837" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">问题陈述</h1><p id="8b07" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">一个机器人位于一个<strong class="jf hj"> m x n </strong>网格的左上角(在下图中标为“开始”)。</p><p id="a38d" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">机器人在任何时候只能向下或向右移动。机器人正试图到达网格的右下角(下图中标有“完成”)。</p><p id="d402" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">有多少条可能的唯一路径？</p><p id="f437" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">问题陈述摘自:【https://leetcode.com/problems/unique-paths】T2</p><p id="cb28" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated"><strong class="jf hj">例一:</strong></p><figure class="ki kj kk kl fd km er es paragraph-image"><div class="er es kh"><img src="../Images/accfe89f2baed178b7a95672321c049d.png" data-original-src="https://miro.medium.com/v2/resize:fit:800/format:webp/0*kNAIYjOX0KeJbXLz.png"/></div></figure><pre class="ki kj kk kl fd kp kq kr ks aw kt bi"><span id="7d78" class="ku ig hi kq b fi kv kw l kx ky">Input: m = 3, n = 7<br/>Output: 28</span></pre><p id="f017" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated"><strong class="jf hj">例 2: </strong></p><pre class="ki kj kk kl fd kp kq kr ks aw kt bi"><span id="b8a3" class="ku ig hi kq b fi kv kw l kx ky">Input: m = 3, n = 2<br/>Output: 3<br/>Explanation:<br/>From the top-left corner, there are a total of 3 ways to reach the bottom-right corner:<br/>1. Right -&gt; Down -&gt; Down<br/>2. Down -&gt; Down -&gt; Right<br/>3. Down -&gt; Right -&gt; Down</span></pre><p id="892d" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated"><strong class="jf hj">例 3: </strong></p><pre class="ki kj kk kl fd kp kq kr ks aw kt bi"><span id="813b" class="ku ig hi kq b fi kv kw l kx ky">Input: m = 7, n = 3<br/>Output: 28</span></pre><p id="346e" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated"><strong class="jf hj">例 4: </strong></p><pre class="ki kj kk kl fd kp kq kr ks aw kt bi"><span id="368d" class="ku ig hi kq b fi kv kw l kx ky">Input: m = 3, n = 3<br/>Output: 6</span></pre><p id="7ac8" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated"><strong class="jf hj">约束:</strong></p><pre class="ki kj kk kl fd kp kq kr ks aw kt bi"><span id="78b2" class="ku ig hi kq b fi kv kw l kx ky">- 1 &lt;= m, n &lt;= 100<br/>- It's guaranteed that the answer will be less than or equal to 2 * 10^9</span></pre><h1 id="bb12" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">说明</h1><h2 id="9538" class="ku ig hi bd ih kz la lb il lc ld le ip jo lf lg it js lh li ix jw lj lk jb ll bi translated">强力方法</h2><p id="6a84" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">根据问题陈述，机器人可以向下或向右移动。我们可以用递归来求计数。设<em class="lm"> numberOfPaths(m，n) </em>表示到达网格中第 m 行第 n 列的路径数。<em class="lm">c++中的 numberOfPaths(m，n) </em>可以递归地写成如下。</p><pre class="ki kj kk kl fd kp kq kr ks aw kt bi"><span id="3ad8" class="ku ig hi kq b fi kv kw l kx ky">int numberOfPaths(int m, int n){<br/>    if (m == 1 || n == 1)<br/>        return 1;<br/><br/>    return numberOfPaths(m - 1, n) + numberOfPaths(m, n - 1);<br/>}</span></pre><p id="b410" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">上述解的时间复杂度为<strong class="jf hj">指数级</strong>。存在许多重叠的子问题，因此我们可以使用动态规划方法来避免重新计算重叠的子问题。</p><h2 id="1caa" class="ku ig hi bd ih kz la lb il lc ld le ip jo lf lg it js lh li ix jw lj lk jb ll bi translated">动态规划方法</h2><p id="af83" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">我们可以通过使用上述递归方法以自下而上的方式构建临时 2D 数组 count[][]，来避免重新计算重叠的子问题。</p><pre class="ki kj kk kl fd kp kq kr ks aw kt bi"><span id="8120" class="ku ig hi kq b fi kv kw l kx ky">int numberOfPaths(int m, int n){<br/>    // create a 2D array to store results of sub-problems<br/>    int count[m][n];<br/><br/>    // count of paths to reach any cell in first column is 1<br/>    for (int i = 0; i &lt; m; i++)<br/>        count[i][0] = 1;<br/><br/>    // count of paths to reach any cell in first row is 1<br/>    for (int j = 0; j &lt; n; j++)<br/>        count[0][j] = 1;<br/><br/>    for (int i = 1; i &lt; m; i++) {<br/>        for (int j = 1; j &lt; n; j++)<br/>            count[i][j] = count[i - 1][j] + count[i][j - 1];<br/>    }<br/><br/>    return count[m - 1][n - 1];<br/>}</span></pre><p id="212b" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">上述程序的时间复杂度为<strong class="jf hj"> O(mn) </strong>。空间复杂度为<strong class="jf hj"> O(mn) </strong>。我们可以通过<strong class="jf hj"> O(n) </strong>进一步减少空间，其中 n 是列的大小。</p><h2 id="6565" class="ku ig hi bd ih kz la lb il lc ld le ip jo lf lg it js lh li ix jw lj lk jb ll bi translated">组合学方法</h2><p id="734b" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">我们这里要计算<em class="lm"> m+n-2 C n-1 </em>哪个会是<strong class="jf hj"> (m+n-2)！/ (n-1)！(m-1)！</strong></p><p id="05f2" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">让我们检查一下如何计算上述公式的算法:</p><pre class="ki kj kk kl fd kp kq kr ks aw kt bi"><span id="7411" class="ku ig hi kq b fi kv kw l kx ky">- set paths = 1<br/><br/>- loop for i = n; i &lt; m + n - 1; i++<br/>  - set paths = paths * i<br/>  - update paths = paths / (i - n + 1)<br/><br/>- return paths</span></pre><p id="fe07" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated"><strong class="jf hj"> C++解决方案</strong></p><pre class="ki kj kk kl fd kp kq kr ks aw kt bi"><span id="7fc6" class="ku ig hi kq b fi kv kw l kx ky">class Solution {<br/>public:<br/>    int uniquePaths(int m, int n) {<br/>        long int paths = 1;<br/><br/>        for(int i = n; i &lt; m + n - 1; i++){<br/>            paths *= i;<br/>            paths /= (i - n + 1);<br/>        }<br/><br/>        return int(paths);<br/>    }<br/>};</span></pre><p id="bd0f" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated"><strong class="jf hj"> Golang 解决方案</strong></p><pre class="ki kj kk kl fd kp kq kr ks aw kt bi"><span id="984b" class="ku ig hi kq b fi kv kw l kx ky">func uniquePaths(m int, n int) int {<br/>    paths := 1<br/><br/>    for i := n; i &lt; m + n - 1; i++{<br/>        paths *= i<br/>        paths /= (i - n + 1)<br/>    }<br/><br/>    return paths<br/>}</span></pre><p id="0974" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated"><strong class="jf hj"> Javascript 解决方案</strong></p><pre class="ki kj kk kl fd kp kq kr ks aw kt bi"><span id="1aba" class="ku ig hi kq b fi kv kw l kx ky">var uniquePaths = function(m, n) {<br/>    let paths = 1;<br/><br/>    for(let i = n; i &lt; m + n - 1; i++){<br/>        paths *= i;<br/>        paths /= (i - n + 1);<br/>    }<br/><br/>    return paths;<br/>};</span></pre><p id="5847" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">让我们试运行一下我们的算法，看看解决方案是如何工作的。</p><pre class="ki kj kk kl fd kp kq kr ks aw kt bi"><span id="f851" class="ku ig hi kq b fi kv kw l kx ky">Input: m = 3, n = 7<br/><br/>Step 1: set paths = 1<br/><br/>Step 2: loop for i = n; i &lt; m + n - 1<br/>         i = 7<br/>         7 &lt; 7 + 3 - 1<br/>         7 &lt; 9<br/>         7 &lt; 9<br/>         true<br/><br/>         paths = paths * i<br/>         paths = 1 * 7<br/>               = 7<br/><br/>         paths = paths / (i - n + 1)<br/>               = 7 / (7 - 7 + 1)<br/>               = 7 / 1<br/>               = 7<br/><br/>         i++<br/>         i = 8<br/><br/>Step 3: loop for i &lt; m + n - 1<br/>        8 &lt; 8 + 3 - 1<br/>        8 &lt; 9<br/>        8 &lt; 9<br/>        true<br/><br/>        paths = paths * i<br/>        paths = 7 * 8<br/>              = 56<br/><br/>        paths = paths / (i - n + 1)<br/>              = 56 / (8 - 7 + 1)<br/>              = 56 / 2<br/>              = 28<br/><br/>        i++<br/>        i = 9<br/><br/>Step 4: loop for i &lt; m + n - 1<br/>        9 &lt; 8 + 3 - 1<br/>        9 &lt; 9<br/>        false<br/><br/>Step 5: return paths<br/><br/>So we return answer as 28.</span></pre></div><div class="ab cl ln lo gp lp" role="separator"><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls"/></div><div class="hb hc hd he hf"><p id="2e37" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated"><em class="lm">原载于</em><a class="ae kg" href="https://alkeshghorpade.me/post/leetcode-unique-paths" rel="noopener ugc nofollow" target="_blank"><em class="lm">https://alkeshghorpade . me</em></a><em class="lm">。</em></p></div></div>    
</body>
</html>