<html>
<head>
<title>From Zero to Hero Django Admin: Model Relations (Part5)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">从零到英雄 Django 管理:模型关系(第五部分)</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/from-zero-to-hero-django-admin-model-relations-part5-c4c60c6d57a7?source=collection_archive---------0-----------------------#2021-12-13">https://medium.com/nerd-for-tech/from-zero-to-hero-django-admin-model-relations-part5-c4c60c6d57a7?source=collection_archive---------0-----------------------#2021-12-13</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="efb1" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">列出可编辑的，表格和堆叠的内嵌，折叠部分，水平和垂直过滤器</h2></div><p id="a277" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">多好的一周啊！一堆工作会议，然后完成一些任务，并试图开发一个新的永久工作的基础设施。现在我可以把这几行字写成冥想。我在写作的时候满足了自己。希望你在阅读的同时也会感到满意。我们将在本文中尝试介绍 Django 的模型关系。然后，我们将使用这些关系定制管理应用程序。我们开始吧。</p><figure class="ju jv jw jx fd jy er es paragraph-image"><div role="button" tabindex="0" class="jz ka di kb bf kc"><div class="er es jt"><img src="../Images/621589dae0758c3f0ab73e538a132334.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*o22fbIZ82oppUXc8jHfeDQ.jpeg"/></div></div><figcaption class="kf kg et er es kh ki bd b be z dx translated"><a class="ae kj" href="https://unsplash.com/@faisaldada?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Faisal </a>在<a class="ae kj" href="https://unsplash.com/@faisaldada?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><h1 id="2d31" class="kk kl hi bd km kn ko kp kq kr ks kt ku io kv ip kw ir kx is ky iu kz iv la lb bi translated">介绍</h1><p id="38f1" class="pw-post-body-paragraph ix iy hi iz b ja lc ij jc jd ld im jf jg le ji jj jk lf jm jn jo lg jq jr js hb bi translated">基本上，我们会指出这些主题:</p><ul class=""><li id="64e9" class="lh li hi iz b ja jb jd je jg lj jk lk jo ll js lm ln lo lp bi translated">一对一的关系</li><li id="0c00" class="lh li hi iz b ja lq jd lr jg ls jk lt jo lu js lm ln lo lp bi translated">使用伪造者创建伪数据</li><li id="5509" class="lh li hi iz b ja lq jd lr jg ls jk lt jo lu js lm ln lo lp bi translated">什么是表格和堆叠内联</li><li id="16e7" class="lh li hi iz b ja lq jd lr jg ls jk lt jo lu js lm ln lo lp bi translated">admin 类的 list_editable 属性</li><li id="17c9" class="lh li hi iz b ja lq jd lr jg ls jk lt jo lu js lm ln lo lp bi translated">什么是折叠部分</li><li id="50e7" class="lh li hi iz b ja lq jd lr jg ls jk lt jo lu js lm ln lo lp bi translated">多对多关系</li><li id="77de" class="lh li hi iz b ja lq jd lr jg ls jk lt jo lu js lm ln lo lp bi translated">什么是垂直和水平过滤器</li></ul><h1 id="07d1" class="kk kl hi bd km kn ko kp kq kr ks kt ku io kv ip kw ir kx is ky iu kz iv la lb bi translated">一对一的关系</h1><p id="2a00" class="pw-post-body-paragraph ix iy hi iz b ja lc ij jc jd ld im jf jg le ji jj jk lf jm jn jo lg jq jr js hb bi translated">通过使用一对一关系，我们假设一个对象只有一个对象关系。例如，如果我们在<code class="du lv lw lx ly b">Book</code>和<code class="du lv lw lx ly b">Category</code>对象之间创建一对一的关系，每个 book 实例只有一个 category 实例作为<code class="du lv lw lx ly b">book_category</code>字段。</p><p id="7caf" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我将在<code class="du lv lw lx ly b">blog/models.py</code>文件中创建<code class="du lv lw lx ly b">Comment</code>类。</p><pre class="ju jv jw jx fd lz ly ma mb aw mc bi"><span id="3ab6" class="md kl hi ly b fi me mf l mg mh">class Comment(models.Model):<br/>   blog = models.ForeignKey(<br/>to='blog.Blog', related_name='comments', on_delete=models.CASCADE)<br/>   content = models.TextField()<br/>   is_published = models.BooleanField(default=False)<br/>   added_date = models.DateField(auto_now_add=True)</span><span id="dc34" class="md kl hi ly b fi mi mf l mg mh">   class Meta:<br/>      verbose_name = 'Blog Comment'<br/>      verbose_name_plural = 'Blog Comments'<br/>   <br/>   def __str__(self):<br/>      return f"{self.blog.title} - {self.content}"</span></pre><p id="f3e8" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">然后，进行迁移。</p><pre class="ju jv jw jx fd lz ly ma mb aw mc bi"><span id="8831" class="md kl hi ly b fi me mf l mg mh">python manage.py makemigrations &amp;&amp; python manage.py migrate</span></pre><h2 id="7bc0" class="md kl hi bd km mj mk ml kq mm mn mo ku jg mp mq kw jk mr ms ky jo mt mu la mv bi translated">使用 Faker 创建虚拟数据</h2><p id="8a31" class="pw-post-body-paragraph ix iy hi iz b ja lc ij jc jd ld im jf jg le ji jj jk lf jm jn jo lg jq jr js hb bi translated">现在我们需要创建虚拟数据。我们已经习惯了使用本系列早期的 Faker。我要进<code class="du lv lw lx ly b">shell</code>。</p><pre class="ju jv jw jx fd lz ly ma mb aw mc bi"><span id="4487" class="md kl hi ly b fi me mf l mg mh"># import models and module<br/>from blog.models import Comment, Blog<br/>from faker import Faker</span><span id="074d" class="md kl hi ly b fi mi mf l mg mh"># create Faker instance<br/>faker = Faker()</span><span id="a34e" class="md kl hi ly b fi mi mf l mg mh"># create dummy data<br/>for blog in Blog.objects.iterator():<br/>   comments = [Comment(content=faker.paragraph(), blog=blog) for _ in range(0,3)]<br/>   Comment.objects.bulk_create(comments)</span></pre><p id="c341" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们只需要为模型创建一个管理类。</p><pre class="ju jv jw jx fd lz ly ma mb aw mc bi"><span id="c053" class="md kl hi ly b fi me mf l mg mh">class CommentAdmin(admin.ModelAdmin):<br/>   list_display = ('__str__', 'added_date', 'is_published')<br/>   list_per_page = 15</span><span id="3cd1" class="md kl hi ly b fi mi mf l mg mh"><br/>admin.site.register(Comment, CommentAdmin)</span></pre><p id="fff2" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如果你到现在还在做同样的事情，我们可以期待看到如下列表。</p><figure class="ju jv jw jx fd jy er es paragraph-image"><div role="button" tabindex="0" class="jz ka di kb bf kc"><div class="er es mw"><img src="../Images/c954b4747db9b9f5e22886ed9359235f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WjogZyv4nihKghe3ZtFeXA.png"/></div></div><figcaption class="kf kg et er es kh ki bd b be z dx translated">作者图片</figcaption></figure><h2 id="cd28" class="md kl hi bd km mj mk ml kq mm mn mo ku jg mp mq kw jk mr ms ky jo mt mu la mv bi translated">列表 _ 可编辑字段</h2><p id="9b6f" class="pw-post-body-paragraph ix iy hi iz b ja lc ij jc jd ld im jf jg le ji jj jk lf jm jn jo lg jq jr js hb bi translated">我们可以设置一些字段的值，同时在表格中显示它们。例如，对象是否已发布。为此，我们需要在 admin 类中使用<code class="du lv lw lx ly b">list_editable</code>。</p><pre class="ju jv jw jx fd lz ly ma mb aw mc bi"><span id="7f81" class="md kl hi ly b fi me mf l mg mh">class CommentAdmin(admin.ModelAdmin):<br/>   ...<br/>   list_editable = ('is_published',)</span></pre><figure class="ju jv jw jx fd jy er es paragraph-image"><div role="button" tabindex="0" class="jz ka di kb bf kc"><div class="er es mw"><img src="../Images/0a8dbaa833207c3aafb026e7857a3318.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hbZAEFenw42rlMAmufo-FA.png"/></div></div><figcaption class="kf kg et er es kh ki bd b be z dx translated">作者图片</figcaption></figure><h2 id="f0b5" class="md kl hi bd km mj mk ml kq mm mn mo ku jg mp mq kw jk mr ms ky jo mt mu la mv bi translated">表格和堆叠内嵌</h2><p id="3342" class="pw-post-body-paragraph ix iy hi iz b ja lc ij jc jd ld im jf jg le ji jj jk lf jm jn jo lg jq jr js hb bi translated">假设我们想在<code class="du lv lw lx ly b">Blog</code>对象的详细页面上看到<code class="du lv lw lx ly b">Blog</code>对象的相关<code class="du lv lw lx ly b">Comment</code>对象。此外，我们想修改<code class="du lv lw lx ly b">Blog</code>对象的详细页面上的注释。或者在同一页面上添加新的注释。我们在这样的场景中使用<code class="du lv lw lx ly b">Inlines</code>。我们需要按照以下步骤来使用内联:</p><ul class=""><li id="b2e6" class="lh li hi iz b ja jb jd je jg lj jk lk jo ll js lm ln lo lp bi translated">为相关模型(<code class="du lv lw lx ly b">admin.TabularInline</code>或<code class="du lv lw lx ly b">admin.StackedInline</code>)创建一个内联类</li><li id="a949" class="lh li hi iz b ja lq jd lr jg ls jk lt jo lu js lm ln lo lp bi translated">在您想要使用的主模型中注册内联类(模型管理类的<code class="du lv lw lx ly b">inlines</code>字段)</li></ul><p id="4db1" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我将创建一个内联类。</p><pre class="ju jv jw jx fd lz ly ma mb aw mc bi"><span id="695d" class="md kl hi ly b fi me mf l mg mh">class CommentInline(admin.TabularInline):<br/>   model = Comment<br/>   fields = ('content', 'is_published', 'added_date')<br/>   readonly_fields = ('added_date',)<br/>   extra = 1</span></pre><ul class=""><li id="2922" class="lh li hi iz b ja jb jd je jg lj jk lk jo ll js lm ln lo lp bi translated">我们在将在<code class="du lv lw lx ly b">model</code>字段中创建的内联类中设置模型</li><li id="ddd9" class="lh li hi iz b ja lq jd lr jg ls jk lt jo lu js lm ln lo lp bi translated">我们设置将在内联类中显示的字段</li><li id="c9c1" class="lh li hi iz b ja lq jd lr jg ls jk lt jo lu js lm ln lo lp bi translated">如果我们想显示一个不可编辑的字段，我们需要在<code class="du lv lw lx ly b">readonly_fields</code>字段中反映它</li><li id="90eb" class="lh li hi iz b ja lq jd lr jg ls jk lt jo lu js lm ln lo lp bi translated">我们可以通过设置<code class="du lv lw lx ly b">extra</code>字段来限制额外的添加形式</li></ul><p id="deee" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">现在我们需要在模型管理类中注册这个类。</p><pre class="ju jv jw jx fd lz ly ma mb aw mc bi"><span id="2780" class="md kl hi ly b fi me mf l mg mh">class BlogAdmin(admin.ModelAdmin):<br/>   inlines = (CommentInline,)</span></pre><p id="6e4e" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">当我们转到博客对象的详细信息页面时，我们可以看到相关的对象。此外，我们可以添加、更新和删除它们。</p><figure class="ju jv jw jx fd jy er es paragraph-image"><div role="button" tabindex="0" class="jz ka di kb bf kc"><div class="er es mw"><img src="../Images/722775b350088dc39aeccde547a240f0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TNthJFEtF-jqZbaAlFgM-w.png"/></div></div><figcaption class="kf kg et er es kh ki bd b be z dx translated">按作者分类的图像(内嵌表格)</figcaption></figure><p id="8a87" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">那么，<code class="du lv lw lx ly b">StackedInline</code>是什么？只是内联风格不同而已。我们只需要使用<code class="du lv lw lx ly b">admin.StackedInline</code>而不是<code class="du lv lw lx ly b">admin.TabularInline</code>。</p><pre class="ju jv jw jx fd lz ly ma mb aw mc bi"><span id="cd4a" class="md kl hi ly b fi me mf l mg mh">class CommentInline(admin.StackedInline):<br/>   model = Comment<br/>   fields = ('content', 'is_published', 'added_date')<br/>   readonly_fields = ('added_date',)<br/>   extra = 1</span></pre><figure class="ju jv jw jx fd jy er es paragraph-image"><div role="button" tabindex="0" class="jz ka di kb bf kc"><div class="er es mw"><img src="../Images/7199a835b794d365ce71173e705f4522.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VX5kLHNrRBEce6_Da_luEQ.png"/></div></div><figcaption class="kf kg et er es kh ki bd b be z dx translated">按作者分类的图像(内嵌堆叠)</figcaption></figure><h2 id="e72c" class="md kl hi bd km mj mk ml kq mm mn mo ku jg mp mq kw jk mr ms ky jo mt mu la mv bi translated">崩溃的部分</h2><p id="8206" class="pw-post-body-paragraph ix iy hi iz b ja lc ij jc jd ld im jf jg le ji jj jk lf jm jn jo lg jq jr js hb bi translated">其实这只是一个 CSS 类。我们在上面看到一个长长的表格。我们可以把它改成下拉结构。我在下面的内联类中添加了一个 CSS 类。</p><pre class="ju jv jw jx fd lz ly ma mb aw mc bi"><span id="7cb0" class="md kl hi ly b fi me mf l mg mh">class CommentInline(admin.StackedInline):<br/>   classes = ('collapse',)</span></pre><figure class="ju jv jw jx fd jy er es paragraph-image"><div role="button" tabindex="0" class="jz ka di kb bf kc"><div class="er es mw"><img src="../Images/3562c2af1ef4266966e8b6912c225e2c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*25vHguFJRTUbai5M9w7a9w.png"/></div></div><figcaption class="kf kg et er es kh ki bd b be z dx translated">作者图片</figcaption></figure><p id="9d70" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们在上面看到一个折叠的内嵌。此外，我们可以将相同的 CSS 类添加到字段集中。我将把它添加到<code class="du lv lw lx ly b">BlogAdmin</code>字段集中。</p><pre class="ju jv jw jx fd lz ly ma mb aw mc bi"><span id="836d" class="md kl hi ly b fi me mf l mg mh">class BlogAdmin(admin.ModelAdmin):<br/>   fieldsets = (<br/>      ...<br/>       ('Nice to Have Properties', {'fields': (('slug', 'is_published'),),<br/>      'description': 'If the object hasn\'t these attributes, they will be automatically generated', <br/>     'classes': ('collapse',)} # I added a CSS class<br/>)</span></pre><figure class="ju jv jw jx fd jy er es paragraph-image"><div role="button" tabindex="0" class="jz ka di kb bf kc"><div class="er es mw"><img src="../Images/17a1d13044b0d29745369f5e28a84975.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*V-N2pOo8J2oa7rpkBpx5zw.png"/></div></div><figcaption class="kf kg et er es kh ki bd b be z dx translated">作者图片</figcaption></figure><p id="8e44" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们折叠了<code class="du lv lw lx ly b">BlogAdmin</code>类的最后一个字段集。</p><h1 id="535d" class="kk kl hi bd km kn ko kp kq kr ks kt ku io kv ip kw ir kx is ky iu kz iv la lb bi translated">多对多关系</h1><p id="cc07" class="pw-post-body-paragraph ix iy hi iz b ja lc ij jc jd ld im jf jg le ji jj jk lf jm jn jo lg jq jr js hb bi translated">为了解释这种关系，我们可以假设我们有<code class="du lv lw lx ly b">Blog</code>和<code class="du lv lw lx ly b">Category</code>模型。每个博客可以有多个类别，每个类别可以有多个博客。这种类型的关系是多对多关系。</p><h2 id="f1ed" class="md kl hi bd km mj mk ml kq mm mn mo ku jg mp mq kw jk mr ms ky jo mt mu la mv bi translated">创建多对多关系</h2><p id="22d4" class="pw-post-body-paragraph ix iy hi iz b ja lc ij jc jd ld im jf jg le ji jj jk lf jm jn jo lg jq jr js hb bi translated">我将创建<code class="du lv lw lx ly b">Category</code>模型类。</p><pre class="ju jv jw jx fd lz ly ma mb aw mc bi"><span id="d570" class="md kl hi ly b fi me mf l mg mh">class Category(models.Model):<br/>   name = models.CharField(max_length=255)<br/>   is_published = models.BooleanField(default=True)<br/>   <br/>   class Meta:<br/>      verbose_name = 'Blog Category'<br/>      verbose_name_plural = 'Blog Categories'</span><span id="8197" class="md kl hi ly b fi mi mf l mg mh">   def __str__(self):<br/>      return self.name</span></pre><p id="ee47" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">然后，将一个字段添加到我们已经有的<code class="du lv lw lx ly b">Blog</code>模型类中。</p><pre class="ju jv jw jx fd lz ly ma mb aw mc bi"><span id="94ae" class="md kl hi ly b fi me mf l mg mh">class Blog(models.Model):<br/>   ...<br/>   category = models.ManyToManyField(to='blog.Category', related_name='blogs')</span></pre><p id="2996" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">并对数据库进行迁移和推送更改</p><pre class="ju jv jw jx fd lz ly ma mb aw mc bi"><span id="24f2" class="md kl hi ly b fi me mf l mg mh">python manage.py makemigrations &amp;&amp; python manage.py migrate</span></pre><p id="8bf0" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">现在，我们可以为类别模型创建一个管理类。</p><pre class="ju jv jw jx fd lz ly ma mb aw mc bi"><span id="722b" class="md kl hi ly b fi me mf l mg mh">class CategoryAdmin(admin.ModelAdmin):<br/>   list_display = ('__str__', 'is_published')<br/>   list_per_page = 15<br/>   list_editable = ('is_published',)<br/></span><span id="6d2f" class="md kl hi ly b fi mi mf l mg mh">admin.site.register(Category, CategoryAdmin)</span></pre><p id="aada" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我将手动创建一些虚拟数据。</p><figure class="ju jv jw jx fd jy er es paragraph-image"><div role="button" tabindex="0" class="jz ka di kb bf kc"><div class="er es mw"><img src="../Images/cd9e5858d864e01c1ef2232a3ff72214.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ATy8FQy-HU2iLOaugXiWdg.png"/></div></div><figcaption class="kf kg et er es kh ki bd b be z dx translated">作者图片</figcaption></figure><h2 id="53ae" class="md kl hi bd km mj mk ml kq mm mn mo ku jg mp mq kw jk mr ms ky jo mt mu la mv bi translated">垂直和水平过滤器</h2><p id="b8da" class="pw-post-body-paragraph ix iy hi iz b ja lc ij jc jd ld im jf jg le ji jj jk lf jm jn jo lg jq jr js hb bi translated">现在，如果我们转到博客对象的详细信息页面，我们看不到类别字段。因为我们已经在 admin 类中设置了字段集。我将更新 BlogAdmin 类中的字段集，以显示类别字段。</p><pre class="ju jv jw jx fd lz ly ma mb aw mc bi"><span id="967d" class="md kl hi ly b fi me mf l mg mh">class BlogAdmin(admin.ModelAdmin):<br/>   ...</span><span id="8623" class="md kl hi ly b fi mi mf l mg mh">   fieldsets = (</span><span id="5ec7" class="md kl hi ly b fi mi mf l mg mh">(None, {'fields': (('added_date', 'updated_date'),),</span><span id="af02" class="md kl hi ly b fi mi mf l mg mh">'description': 'Time Information'}),</span><span id="5e9d" class="md kl hi ly b fi mi mf l mg mh">('Must Properties', {'fields': ('title', 'content','category'),</span><span id="11eb" class="md kl hi ly b fi mi mf l mg mh">'description': 'The object has to have these attributes'}),</span><span id="ad14" class="md kl hi ly b fi mi mf l mg mh">('Nice to Have Properties', {'fields': (('slug', 'is_published'),),</span><span id="5593" class="md kl hi ly b fi mi mf l mg mh">'description': 'If the object hasn\'t these attributes, they will be automatically generated',</span><span id="bf5e" class="md kl hi ly b fi mi mf l mg mh">'classes': ('collapse',)})</span><span id="a9db" class="md kl hi ly b fi mi mf l mg mh">)</span></pre><figure class="ju jv jw jx fd jy er es paragraph-image"><div role="button" tabindex="0" class="jz ka di kb bf kc"><div class="er es mw"><img src="../Images/31a82da83f59acaa4cf8b7ee7891de89.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pp040TyiDFFB3OBXy6iBDQ.png"/></div></div><figcaption class="kf kg et er es kh ki bd b be z dx translated">作者图片</figcaption></figure><p id="5f88" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们可以通过使用<code class="du lv lw lx ly b">filter_vertical</code>或<code class="du lv lw lx ly b">filter_horizontal</code>来改变多对多表单域的样式。我们需要给出想要使用过滤器组件过滤的字段名称。在我们的例子中，我们需要过滤类别来设置博客的类别。</p><pre class="ju jv jw jx fd lz ly ma mb aw mc bi"><span id="6102" class="md kl hi ly b fi me mf l mg mh">class BlogAdmin(admin.ModelAdmin):<br/>   ...<br/>   filter_vertical = ('category',)</span></pre><figure class="ju jv jw jx fd jy er es paragraph-image"><div role="button" tabindex="0" class="jz ka di kb bf kc"><div class="er es mw"><img src="../Images/bebd3fd025740661e884b655bca60fd9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kswc0ofnfO_sr1gcIQVTcg.png"/></div></div><figcaption class="kf kg et er es kh ki bd b be z dx translated">按作者分类的图像(垂直过滤)</figcaption></figure><p id="f7ad" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">此外，我们可以改变过滤器的风格如下。</p><pre class="ju jv jw jx fd lz ly ma mb aw mc bi"><span id="c61e" class="md kl hi ly b fi me mf l mg mh">class BlogAdmin(admin.ModelAdmin):<br/>   ...<br/>   filter_horizontal = ('category',)</span></pre><figure class="ju jv jw jx fd jy er es paragraph-image"><div role="button" tabindex="0" class="jz ka di kb bf kc"><div class="er es mw"><img src="../Images/facbed41fe2fcf11de2edec9c6080f9a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3y8ARPrPBZrKF_zOYk3Bjg.png"/></div></div><figcaption class="kf kg et er es kh ki bd b be z dx translated">按作者分类的图像(水平过滤)</figcaption></figure><h1 id="98b9" class="kk kl hi bd km kn ko kp kq kr ks kt ku io kv ip kw ir kx is ky iu kz iv la lb bi translated">最后</h1><p id="ff16" class="pw-post-body-paragraph ix iy hi iz b ja lc ij jc jd ld im jf jg le ji jj jk lf jm jn jo lg jq jr js hb bi translated">希望这是有帮助的。你可以从下面得到所有的代码。另外，你可以从下面得到这个系列的全部内容。</p><div class="mx my ez fb mz na"><a href="https://github.com/mebaysan/DjangoAdminForMedium" rel="noopener  ugc nofollow" target="_blank"><div class="nb ab dw"><div class="nc ab nd cl cj ne"><h2 class="bd hj fi z dy nf ea eb ng ed ef hh bi translated">GitHub-mebaysan/djangodadminformedium:为中型 Django 管理博客系列创建</h2><div class="nh l"><h3 class="bd b fi z dy nf ea eb ng ed ef dx translated">我开始准备这个 repo 来解释我们如何在 Django 中定制管理应用程序。本次回购依赖于一个媒介…</h3></div><div class="ni l"><p class="bd b fp z dy nf ea eb ng ed ef dx translated">github.com</p></div></div><div class="nj l"><div class="nk l nl nm nn nj no kd na"/></div></div></a></div><p id="1e0c" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">事实上，我已经完成了我认为应该解释的关于 Django Admin 的核心主题。我将会写关于 Django 的额外插件，如何在 list_display 字段显示图片，等等。如果我将来写作。</p><p id="050a" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">亲切的问候。</p></div></div>    
</body>
</html>