<html>
<head>
<title>Lane detection with OpenCV — Part 2</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">利用OpenCV进行车道检测—第二部分</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/lane-detection-with-opencv-part-2-efdad71e8819?source=collection_archive---------4-----------------------#2021-02-15">https://medium.com/nerd-for-tech/lane-detection-with-opencv-part-2-efdad71e8819?source=collection_archive---------4-----------------------#2021-02-15</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="58a7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在第一部分的<a class="ae jd" href="https://lucav76.medium.com/lane-detection-with-opencv-part-1-ad9ea5758c07" rel="noopener">中，我们看到了如何使用阈值处理来选择车道的颜色，以及如何使用透视校正来获得道路的鸟瞰图。我们现在来看看如何定位车道。</a></p><p id="e49f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">以下内容主要摘自《自动驾驶汽车的<a class="ae jd" href="http://packt.live/3jimRoS" rel="noopener ugc nofollow" target="_blank">实践愿景和行为》一书，这本书是我在Krishtof Korda的帮助下为Packt Publishing撰写的。</a></p><h1 id="98da" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">边缘检测</h1><p id="7a9c" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated"><em class="kh">代码需要Python 3.7，OpenCV和NumPy。</em></p><p id="1050" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">下一步是检测边缘，我们将使用绿色通道，因为在我们的实验中，它给出了良好的结果。请注意，您需要对从您计划运行该软件的国家拍摄的图像和视频以及许多不同的光线条件进行实验。最有可能的是，根据线条的颜色和图像中的颜色，您可能想要选择不同的通道，可能来自另一个颜色空间；您可以使用<em class="kh"> cvtColor() </em>将图像转换成不同的色彩空间，例如:</p><pre class="ki kj kk kl fd km kn ko kp aw kq bi"><span id="c2f5" class="kr jf hi kn b fi ks kt l ku kv">img_hls = cv2.cvtColor(img_bgr, cv2.COLOR_BGR2HLS).astype(np.<br/>float)</span></pre><p id="cd16" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们将坚持绿色。</p><p id="95ff" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">OpenCV有几种方法来计算边缘检测，我们将使用Scharr，因为它执行得相当好。Scharr计算导数，因此它可以检测图像中的颜色差异。我们对X轴感兴趣，我们希望结果是一个64位浮点数，所以我们的调用如下:</p><pre class="ki kj kk kl fd km kn ko kp aw kq bi"><span id="6aae" class="kr jf hi kn b fi ks kt l ku kv">edge_x = cv2.Scharr(channel, cv2.CV_64F, 1, 0)</span></pre><p id="0867" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在Scharr计算导数时，值可以是正的，也可以是负的。我们对符号不感兴趣，而只对存在边缘的事实感兴趣。所以，我们将取绝对值:</p><pre class="ki kj kk kl fd km kn ko kp aw kq bi"><span id="1b70" class="kr jf hi kn b fi ks kt l ku kv">edge_x = np.absolute(edge_x)</span></pre><p id="6e1b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">另一个问题是，这些值不在我们期望的单通道图像的0–255值范围内，并且这些值是浮点，而我们需要一个8位整数。我们可以用下面的代码行解决这两个问题:</p><pre class="ki kj kk kl fd km kn ko kp aw kq bi"><span id="03ac" class="kr jf hi kn b fi ks kt l ku kv">edge_x = np.uint8(255 * edge_x / np.max(edge_x))</span></pre><p id="30e0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这是结果:</p><figure class="ki kj kk kl fd kx er es paragraph-image"><div role="button" tabindex="0" class="ky kz di la bf lb"><div class="er es kw"><img src="../Images/1b007ed609da38eebe53c8ae59ba9d6d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9vX-Uv0xRaH3NQ0DZlQtEw.png"/></div></div><figcaption class="le lf et er es lg lh bd b be z dx translated">使用Scharr、缩放和绝对值进行边缘检测</figcaption></figure><p id="bdd2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">此时，我们可以应用阈值处理将图像转换为黑白，以更好地隔离车道的像素。我们需要选择像素的强度，在这种情况下，我们可以选择20–120；我们将只选择亮度值至少为20且不超过120的像素:</p><pre class="ki kj kk kl fd km kn ko kp aw kq bi"><span id="e84f" class="kr jf hi kn b fi ks kt l ku kv">binary = np.zeros_like(img_edge)<br/>binary[img_edge &gt;= 20] = 255</span></pre><p id="c523" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="kh"> zeros_like() </em>方法创建一个充满零的数组，与图像的形状相同，第二行将所有像素的亮度设置为20到120到255之间。这是结果:</p><figure class="ki kj kk kl fd kx er es paragraph-image"><div role="button" tabindex="0" class="ky kz di la bf lb"><div class="er es kw"><img src="../Images/12cf333405ea338b0f1a190dabe65556.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8zRcrE_kll93sFrePvLdTw.png"/></div></div><figcaption class="le lf et er es lg lh bd b be z dx translated">应用阈值20后的结果</figcaption></figure><p id="0a28" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">车道现在非常明显，但有一些噪音。我们可以通过提高阈值来减少这种情况:</p><pre class="ki kj kk kl fd km kn ko kp aw kq bi"><span id="079e" class="kr jf hi kn b fi ks kt l ku kv">binary[img_edge &gt;= 50] = 255</span></pre><p id="4288" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">输出如下所示:</p><figure class="ki kj kk kl fd kx er es paragraph-image"><div role="button" tabindex="0" class="ky kz di la bf lb"><div class="er es li"><img src="../Images/8af8ab7b282ad931a6cf26c36a55fc92.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HbrcZhAlPkfFmCIu70RPcg.png"/></div></div><figcaption class="le lf et er es lg lh bd b be z dx translated">应用阈值50后的结果</figcaption></figure><p id="f4dd" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在，噪音减少了，但是我们失去了顶部的线条。我们现在将描述一种技术，它可以帮助我们保留完整的线条，而不会有过多的噪声。</p><h1 id="c2f8" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">插值阈值</h1><p id="fa84" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">在实践中，我们不必在选择具有大量噪声的整条线和降低噪声同时只检测部分线之间进行选择。我们可以在底部应用较高的阈值(这里我们有更高的分辨率、更清晰的图像和更多的噪声)，在顶部应用较低的阈值(这里，我们得到更低的对比度、更弱的检测和更少的噪声，因为像素被透视校正拉伸，自然地使它们模糊)。我们可以在阈值之间进行插值:</p><pre class="ki kj kk kl fd km kn ko kp aw kq bi"><span id="01ca" class="kr jf hi kn b fi ks kt l ku kv">threshold_up = 15<br/>threshold_down = 60<br/>threshold_delta = threshold_down-threshold_up<br/>for y in range(height):<br/>binary_line = binary[y,:]<br/>edge_line = channel_edge[y,:]<br/>threshold_line = threshold_up + threshold_delta * y/height<br/>binary_line[edge_line &gt;= threshold_line] = 255</span></pre><p id="b60f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们看看结果:</p><figure class="ki kj kk kl fd kx er es paragraph-image"><div role="button" tabindex="0" class="ky kz di la bf lb"><div class="er es lj"><img src="../Images/ab5f36f11b8c243c588287e0b17603a3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6uFU7U63YTNshQw6Xo_yPg.png"/></div></div><figcaption class="le lf et er es lg lh bd b be z dx translated">应用插值阈值(从15到60)后的结果</figcaption></figure><p id="0f92" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在，我们可以在底部有更少的噪声，在顶部检测更弱的信号。然而，虽然人类可以在视觉上识别车道，但对于计算机来说，它们仍然只是图像中的像素，所以仍然有工作要做。但是我们非常简化了图像，我们正在取得良好的进展。</p><h1 id="4bdc" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">组合阈值</h1><p id="b7e8" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">如前所述，我们还想在另一个通道上使用阈值，而不进行边缘检测。我们选择了HLS的L通道。<br/>这是阈值高于140的结果:</p><figure class="ki kj kk kl fd kx er es paragraph-image"><div role="button" tabindex="0" class="ky kz di la bf lb"><div class="er es lk"><img src="../Images/105269622e14107982fd3842a5fb9f8d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qqdzJCpysmWkxU3ccEsijw.png"/></div></div><figcaption class="le lf et er es lg lh bd b be z dx translated">阈值高于140的l通道</figcaption></figure><p id="c3e1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">还不错。现在，我们可以将它与边缘结合起来:</p><figure class="ki kj kk kl fd kx er es paragraph-image"><div role="button" tabindex="0" class="ky kz di la bf lb"><div class="er es ll"><img src="../Images/96a704a5f81ea1d9fceb569500078586.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0ifM9rNeWMLTaIzrpryToA.png"/></div></div><figcaption class="le lf et er es lg lh bd b be z dx translated">两个阈值的组合</figcaption></figure><p id="08c7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">结果是噪音更大，但也更健壮。<br/>在继续之前，我们先来介绍一个有转折的画面:</p><figure class="ki kj kk kl fd kx er es paragraph-image"><div role="button" tabindex="0" class="ky kz di la bf lb"><div class="er es lm"><img src="../Images/18591755a2c14747af47149db94f4c0e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ECNJ9JNPZ0XzQ8wDyQNAaQ.png"/></div></div><figcaption class="le lf et er es lg lh bd b be z dx translated">一个转弯的车道，来自速度梦</figcaption></figure><p id="76f4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这是门槛:</p><figure class="ki kj kk kl fd kx er es paragraph-image"><div role="button" tabindex="0" class="ky kz di la bf lb"><div class="er es li"><img src="../Images/a522f15c9890def58dc3c4174301e887.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MTH1F-4VZhBP23kzgdAN6w.png"/></div></div><figcaption class="le lf et er es lg lh bd b be z dx translated">巷子拐了个弯，过了门槛</figcaption></figure><p id="4181" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">它看起来仍然很好，但我们可以看到，因为转弯，我们不再有一条垂直线。事实上，在图像的顶部，线条基本上是水平的</p><h1 id="59f8" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">使用直方图查找车道</h1><p id="9d8f" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">我们怎样才能或多或少地理解车道在哪里？从视觉上看，对于人类来说，答案很简单:车道是一条长线。但是电脑呢？<br/>如果我们谈论垂直线，一种方法是计算某一列上白色的像素。但是如果我们用一个转弯来检查图像，那可能就不行了。然而，如果我们减少对图像底部的关注，线条会更垂直一些:</p><figure class="ki kj kk kl fd kx er es paragraph-image"><div role="button" tabindex="0" class="ky kz di la bf lb"><div class="er es lk"><img src="../Images/0222e642056e2b34f8b6c6af33c4c6e6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Uad2FFC94wcQYxHyUl7XYg.png"/></div></div><figcaption class="le lf et er es lg lh bd b be z dx translated">车道拐了一个弯，过了门槛，到了标准杆底</figcaption></figure><p id="3d6c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们现在可以按列计算像素:</p><pre class="ki kj kk kl fd km kn ko kp aw kq bi"><span id="2af9" class="kr jf hi kn b fi ks kt l ku kv">partial_img = img[img.shape[0] // 2:, :] # Select the bottom<br/>part<br/>hist = np.sum(partial_img, axis=0) # axis 0: columns direction</span></pre><p id="89f5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">要将直方图保存为文件中的图形，我们可以使用Matplotlib:</p><pre class="ki kj kk kl fd km kn ko kp aw kq bi"><span id="2093" class="kr jf hi kn b fi ks kt l ku kv">import matplotlib.pyplot as plt</span><span id="0605" class="kr jf hi kn b fi ln kt l ku kv">plt.plot(hist)<br/>plt.savefig(filename)<br/>plt.clf()</span></pre><p id="c962" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们得到以下结果:</p><figure class="ki kj kk kl fd kx er es paragraph-image"><div role="button" tabindex="0" class="ky kz di la bf lb"><div class="er es lo"><img src="../Images/be975558177aa8bcb509e4f2400630bb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*u6utB2KZq1h9zzjBy6pIgA.png"/></div></div><figcaption class="le lf et er es lg lh bd b be z dx translated">左:直行车道直方图，右:转弯车道直方图</figcaption></figure><p id="1e5a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">直方图上的X坐标代表像素；由于我们的图像分辨率为1024x600，直方图显示了1，024个数据点，峰值位于车道所在像素的中心。<br/>正如我们所看到的，在直线车道的情况下，直方图非常清楚地标识了两条线；转弯时，直方图不太清晰(因为线转弯，因此白色像素分散了一点)，但仍然可用。我们还可以看到，在虚线的情况下，直方图中的峰值不太明显，但仍然存在。<br/>这个看起来很有前景！<br/>现在，我们需要一种方法来探测这两座山峰。我们可以使用NumPy中的argmax()，它返回数组中最大元素的索引，这是我们的峰值之一。<br/>然而，我们需要两个。为此，我们可以将阵列分成两半，并在每一半上选择一个峰:</p><pre class="ki kj kk kl fd km kn ko kp aw kq bi"><span id="b2c0" class="kr jf hi kn b fi ks kt l ku kv">size = len(histogram)<br/>max_index_left = np.argmax(histogram[0:size//2])<br/>max_index_right = np.argmax(histogram[size//2:]) + size//2</span></pre><p id="8877" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在我们有了索引，它代表了峰值的X坐标。该值本身(例如，直方图[索引])可以被认为是识别车道的置信度，因为更多的像素意味着更多的置信度。</p><h1 id="6acd" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">临终遗言</h1><p id="fec5" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">现在你知道了车道的初始位置。本书的剩余章节解释了如何增强这种方法来识别转弯，如何在已识别的车道上画线，以及如何利用来自先前帧的信息来使检测更加鲁棒。</p><p id="bd88" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果你喜欢这两篇文章，如果你对自动驾驶汽车使用的一些技术感到好奇，请考虑一下<a class="ae jd" href="http://packt.live/3jimRoS" rel="noopener ugc nofollow" target="_blank">的《自动驾驶汽车的实践愿景和行为</a>》一书。它还谈到了神经网络，物体检测，语义分割，传感器，激光雷达，地图，控制等等。</p></div></div>    
</body>
</html>