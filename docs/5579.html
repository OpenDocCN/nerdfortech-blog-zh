<html>
<head>
<title>Programming with Functions #9: Try, for-comprehension, and monadic laws</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">函数编程#9:尝试、理解和一元法则</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/programming-with-functions-9-try-for-comprehension-and-monadic-laws-4d04c4b77ed7?source=collection_archive---------3-----------------------#2021-10-19">https://medium.com/nerd-for-tech/programming-with-functions-9-try-for-comprehension-and-monadic-laws-4d04c4b77ed7?source=collection_archive---------3-----------------------#2021-10-19</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex if ig ih ii"><div class="bz dy l di"><div class="ij ik l"/></div></figure><h1 id="c588" class="il im hi bd in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji bi translated">尝试</h1><p id="9e59" class="pw-post-body-paragraph jj jk hi jl b jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg hb bi translated">在上一集里，我们谈到了<code class="du kh ki kj kk b">Option</code>和<code class="du kh ki kj kk b">Either</code>，以及如何使用它们来避免抛出异常。但是更多时候，我们从第三方库接收异常，并尝试用<code class="du kh ki kj kk b">try/catch</code>子句处理它们。有时我们会重新抛出它们——这是我们在这里试图避免的，所以您可能会认为对这些情况使用<code class="du kh ki kj kk b">Either</code>可能有意义。</p><pre class="kl km kn ko fd kp kk kq kr aw ks bi"><span id="00c5" class="kt im hi kk b fi ku kv l kw kx">def foo(data: Data): Either[Throwable, Result] = <br/>  try {<br/>    val res: Result = javaLib.getSomethingOrThrowException(data)<br/>    Right(res)<br/>  } catch {<br/>    case NonFatal(err) =&gt; Left(err)<br/>  }</span></pre><p id="a73b" class="pw-post-body-paragraph jj jk hi jl b jm ky jo jp jq kz js jt ju la jw jx jy lb ka kb kc lc ke kf kg hb bi translated">异常在JVM上是如此普遍，以至于在Scala中我们有一个特殊的构造来帮助我们。它被简称为<code class="du kh ki kj kk b">Try</code>，你可以把它看作是一个<code class="du kh ki kj kk b">try/catch</code>子句的功能版本。如果我们决定使用它，上面的代码将如下所示:</p><pre class="kl km kn ko fd kp kk kq kr aw ks bi"><span id="7edb" class="kt im hi kk b fi ku kv l kw kx">def foo(data: Data): Try[Result] =<br/>  Try(javaLib.getSomethingOrThrowException(data))</span></pre><p id="5a1e" class="pw-post-body-paragraph jj jk hi jl b jm ky jo jp jq kz js jt ju la jw jx jy lb ka kb kc lc ke kf kg hb bi translated"><code class="du kh ki kj kk b">Try[Result]</code>和<code class="du kh ki kj kk b">Either[Throwable, Result]</code>差别不大。我们可以把<code class="du kh ki kj kk b">Try</code>看作是<code class="du kh ki kj kk b">Either</code>的一个更专业的版本，甚至更适合处理错误，但仅限于来自JVM的错误。这就像一个必要之恶:我们不应该需要它，因为根本不应该有异常，但我们并不是生活在一个理想的函数世界里，异常无处不在，正因为如此我们才使用<code class="du kh ki kj kk b">Try</code>。正如<code class="du kh ki kj kk b">Either</code>对于成功的计算有<code class="du kh ki kj kk b">Right</code>子类，对于错误有<code class="du kh ki kj kk b">Left</code>子类一样，<code class="du kh ki kj kk b">Try</code>有<code class="du kh ki kj kk b">Success</code>和<code class="du kh ki kj kk b">Failure</code>。子类<code class="du kh ki kj kk b">Success[T]</code>包含成功计算的结果，而<code class="du kh ki kj kk b">Failure</code>包含被抛出的异常。与<code class="du kh ki kj kk b">Either</code>一样，<code class="du kh ki kj kk b">Try</code>使我们能够使用<code class="du kh ki kj kk b">flatMap</code>来链接对可能抛出异常的函数的调用。我们还可以访问<code class="du kh ki kj kk b">map</code>、<code class="du kh ki kj kk b">foreach</code>、<code class="du kh ki kj kk b">filter</code>等等。所有这些方法都是在原始计算结果成功的条件下工作的——如果计算最终抛出异常，它们将什么也不做。为此，我们有另外两种方法:<code class="du kh ki kj kk b">recover</code>和<code class="du kh ki kj kk b">recoverWith</code>。</p><pre class="kl km kn ko fd kp kk kq kr aw ks bi"><span id="50f4" class="kt im hi kk b fi ku kv l kw kx">case class Result(text: String)</span><span id="c002" class="kt im hi kk b fi ld kv l kw kx">val t: Try[Result] =<br/>  Try(javaLib.getSomethingOrThrowException(data))</span><span id="b399" class="kt im hi kk b fi ld kv l kw kx">t.recover {<br/>  case ex: IOException =&gt; defaultResult<br/>}</span><span id="dcb2" class="kt im hi kk b fi ld kv l kw kx">t.recoverWith {<br/>  case ex: IOException =&gt;<br/>    if (ignoreErrors) Success(defaultResult) <br/>    else Failure(ex)  <br/>}</span></pre><p id="251d" class="pw-post-body-paragraph jj jk hi jl b jm ky jo jp jq kz js jt ju la jw jx jy lb ka kb kc lc ke kf kg hb bi translated">它们都取代了<code class="du kh ki kj kk b">try/catch</code>中的catch子句，但它们的工作方式略有不同。当你确定对于某些异常，你的代码应该返回一个成功的结果时，使用<code class="du kh ki kj kk b">recover</code>。<code class="du kh ki kj kk b">recover</code>将一个部分函数作为它的参数:这个部分函数应该产生一个结果，这个结果的恢复将包含在一个<code class="du kh ki kj kk b">Success</code>中。对于分部函数不支持的所有其他类型的异常，结果仍然是一个<code class="du kh ki kj kk b">Failure</code>。<code class="du kh ki kj kk b">recoverWith</code>允许更多的灵活性:它接受一个局部函数，这个函数可以单独决定它的结果应该是一个<code class="du kh ki kj kk b">Success</code>还是一个<code class="du kh ki kj kk b">Failure</code>。您可以想象<code class="du kh ki kj kk b">recover</code>是异常的<code class="du kh ki kj kk b">map</code>，将它们映射到结果，然后将结果包装在成功的尝试中，而<code class="du kh ki kj kk b">recoverWith</code>是平面映射——它将异常平面映射到成功或失败的尝试。另一方面，如果你根本不关心错误，你只想从一个可以抛出异常的方法中得到有效的结果，你可以把一个<code class="du kh ki kj kk b">Try</code>变成一个<code class="du kh ki kj kk b">Option</code>:</p><pre class="kl km kn ko fd kp kk kq kr aw ks bi"><span id="4901" class="kt im hi kk b fi ku kv l kw kx">Try(javaLib.getSomethingOrThrowException(data)).toOption</span></pre><p id="89c8" class="pw-post-body-paragraph jj jk hi jl b jm ky jo jp jq kz js jt ju la jw jx jy lb ka kb kc lc ke kf kg hb bi translated">简而言之:用<code class="du kh ki kj kk b">Try</code>代替<code class="du kh ki kj kk b">try/catch</code>。</p><h1 id="e9e3" class="il im hi bd in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji bi translated">为了理解</h1><p id="35fc" class="pw-post-body-paragraph jj jk hi jl b jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg hb bi translated">在上述所有三种情况下——<code class="du kh ki kj kk b">Option</code>、<code class="du kh ki kj kk b">Either</code>和<code class="du kh ki kj kk b">Try</code>——以及其他构造(集合、期货、事件流……)中，我们可以使用平面图将几个接受一些参数的函数链接在一起，并产生同类的构造。我在前面的视频中举了一个例子，但只是一个非常简单的例子:三个函数，每个函数都有一个参数，由前面的函数产生，产生一个结果作为后面函数的参数。</p><pre class="kl km kn ko fd kp kk kq kr aw ks bi"><span id="6629" class="kt im hi kk b fi ku kv l kw kx">val result = foo(t).flatMap(bar).flatMap(boo)</span></pre><p id="6226" class="pw-post-body-paragraph jj jk hi jl b jm ky jo jp jq kz js jt ju la jw jx jy lb ka kb kc lc ke kf kg hb bi translated">这看起来非常干净漂亮，但实际上，那些平面图可能会变得复杂得多。平面图中可以嵌套平面图，我们可能需要在它们之间执行一些操作，并且我们可能需要使用多个函数的结果作为参数。这里有一个更真实的例子:</p><pre class="kl km kn ko fd kp kk kq kr aw ks bi"><span id="6516" class="kt im hi kk b fi ku kv l kw kx">val res = client.getTeamMembers(teamId).flatMap { members =&gt;<br/>  storage.getUserData(members.map(_.userId)).flatMap { users =&gt;<br/>    log(s”members: $members, users: $users”)<br/>    system.getPriorityLevels(teamId).flatMap {<br/>      case levels if levels.size &gt; 1 =&gt;<br/>        doSomeStuffOrFail(members, users, levels)<br/>      case _ =&gt;<br/>        doSomeOtherStuffOrFail(members, users)<br/>    }<br/>  }<br/>}</span></pre><p id="b666" class="pw-post-body-paragraph jj jk hi jl b jm ky jo jp jq kz js jt ju la jw jx jy lb ka kb kc lc ke kf kg hb bi translated">有点丑，对吧？每个调用都需要一个新的嵌套级别。总是有办法解除平面图的嵌套，把它们变成一个链，但是这可能会使代码可读性更差。但是我们还能做什么呢？Scala为我们提供了语法糖，在这种情况下很有帮助:<code class="du kh ki kj kk b">for/yield</code>，也称为<strong class="jl hj"> for-comprehensions </strong>。Haskell也实现了类似的东西，即“do”符号。在Scala中是这样的:</p><pre class="kl km kn ko fd kp kk kq kr aw ks bi"><span id="4dc6" class="kt im hi kk b fi ku kv l kw kx">val res = for {<br/>  members &lt;- client.getTeamMembers(teamId)<br/>  users   &lt;- storage.getUserData(members.map(_.userId))<br/>  _       =  log(s”members: $members, users: $users”)<br/>  levels  &lt;- system.getPriorityLevels(teamId)<br/>} yield<br/>  if (levels.size &gt; 1) <br/>    doSomeStuffOrFail(members, users, levels)<br/>  else <br/>    doSomeOtherStuffOrFail(members, users)</span></pre><p id="92f0" class="pw-post-body-paragraph jj jk hi jl b jm ky jo jp jq kz js jt ju la jw jx jy lb ka kb kc lc ke kf kg hb bi translated">现在好多了。</p><p id="316c" class="pw-post-body-paragraph jj jk hi jl b jm ky jo jp jq kz js jt ju la jw jx jy lb ka kb kc lc ke kf kg hb bi translated"><code class="du kh ki kj kk b">for/yield</code>内的每条“左箭头”线代表一个新的<code class="du kh ki kj kk b">flatMap</code>，给出一个成功的结果。如果一个<code class="du kh ki kj kk b">flatMap</code>成功了，我们往下走一行，也就是到下一个<code class="du kh ki kj kk b">flatMap</code>。如果失败，则跳过所有连续的行以及yield后面的行，整个for-comprehension返回失败。</p><figure class="kl km kn ko fd ii er es paragraph-image"><div role="button" tabindex="0" class="lf lg di lh bf li"><div class="er es le"><img src="../Images/45fb0040d7a4127b88af5b8e09030416.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*q5Uh7DilTG1VwQuY"/></div></div></figure><h1 id="80a2" class="il im hi bd in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji bi translated">一元定律</h1><p id="a078" class="pw-post-body-paragraph jj jk hi jl b jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg hb bi translated">这是可能的，因为单子的一个性质，你不必知道，但我还是要告诉你:<strong class="jl hj">结合律</strong>。正如我之前提到的，单子是一个概念。如果一段代码满足一定的标准，我们称之为单子。就是这样。在这些标准中有“单位”法、<code class="du kh ki kj kk b">flatMap</code>法，还有三个所谓的一元定律:</p><ol class=""><li id="9fd5" class="ll lm hi jl b jm ky jq kz ju ln jy lo kc lp kg lq lr ls lt bi translated">左侧标识</li><li id="869f" class="ll lm hi jl b jm lu jq lv ju lw jy lx kc ly kg lq lr ls lt bi translated">正确的身份</li><li id="2f15" class="ll lm hi jl b jm lu jq lv ju lw jy lx kc ly kg lq lr ls lt bi translated">结合性</li></ol><p id="1010" class="pw-post-body-paragraph jj jk hi jl b jm ky jo jp jq kz js jt ju la jw jx jy lb ka kb kc lc ke kf kg hb bi translated">前两个相当琐碎。他们关心的是“单元”方法，也就是我们用来创建单子的构造函数。比方说，我们有一个函数<code class="du kh ki kj kk b">f</code>，它接受一个值并返回另一个值的单子:</p><pre class="kl km kn ko fd kp kk kq kr aw ks bi"><span id="77d6" class="kt im hi kk b fi ku kv l kw kx">def f(value: V): Monad[V]</span></pre><p id="b8be" class="pw-post-body-paragraph jj jk hi jl b jm ky jo jp jq kz js jt ju la jw jx jy lb ka kb kc lc ke kf kg hb bi translated"><strong class="jl hj">左同一律</strong>说如果我们用“unit”方法创建一个带值的单子，然后用<code class="du kh ki kj kk b">f</code>对其进行<code class="du kh ki kj kk b">flatMap</code>，那么结果应该和我们只是用那个值调用<code class="du kh ki kj kk b">f</code>一样:</p><pre class="kl km kn ko fd kp kk kq kr aw ks bi"><span id="6311" class="kt im hi kk b fi ku kv l kw kx">Monad(v).flatMap(f) == f(v)</span></pre><p id="7a6a" class="pw-post-body-paragraph jj jk hi jl b jm ky jo jp jq kz js jt ju la jw jx jy lb ka kb kc lc ke kf kg hb bi translated"><strong class="jl hj">右恒等律</strong>说，如果我们有一个单子<code class="du kh ki kj kk b">flatMap</code>用“单位”法把它做出来，那么结果应该完全就像我们没有做一样。</p><pre class="kl km kn ko fd kp kk kq kr aw ks bi"><span id="7731" class="kt im hi kk b fi ku kv l kw kx">val monad: Monad[V] = …<br/>monad.flatMap(Monad(_)) == monad</span></pre><p id="1059" class="pw-post-body-paragraph jj jk hi jl b jm ky jo jp jq kz js jt ju la jw jx jy lb ka kb kc lc ke kf kg hb bi translated">第三个定律，<strong class="jl hj">结合律</strong>，稍微复杂一点。基本上，它说应该可以取消一个单子的每个嵌套<code class="du kh ki kj kk b">flatMap</code>。为了解释，让我们从上一个示例的更简单版本开始:</p><pre class="kl km kn ko fd kp kk kq kr aw ks bi"><span id="b80b" class="kt im hi kk b fi ku kv l kw kx">mA.flatMap(a =&gt;<br/>  mB.flatMap(b =&gt; // mA and mB are monads<br/>    doStuff(a, b) // doStuff returns a monad<br/>  )<br/>)</span></pre><p id="02dc" class="pw-post-body-paragraph jj jk hi jl b jm ky jo jp jq kz js jt ju la jw jx jy lb ka kb kc lc ke kf kg hb bi translated">在Haskell中，我们可以使用操作符<code class="du kh ki kj kk b">&gt;&gt;=</code>来代替方法<code class="du kh ki kj kk b">flatMap</code>。如果我们这样做了，并且如果我们只对如何将单子与平面图连接在一起感兴趣，而不是对里面的数据实际做了什么，那么上面的代码可以简化成这样:</p><pre class="kl km kn ko fd kp kk kq kr aw ks bi"><span id="e126" class="kt im hi kk b fi ku kv l kw kx">mA &gt;&gt;= (mB &gt;&gt;= doStuff)</span></pre><p id="c98f" class="pw-post-body-paragraph jj jk hi jl b jm ky jo jp jq kz js jt ju la jw jx jy lb ka kb kc lc ke kf kg hb bi translated">正如您在括号中看到的，我们将首先对<code class="du kh ki kj kk b">mB</code>单子中的内容执行<code class="du kh ki kj kk b">doStuff</code>，只有在之后，我们才会将结果传递给<code class="du kh ki kj kk b">mA</code>。我们从里到外。但是这里出现了结合律，它说首先使用两个平面图中的哪一个(或<code class="du kh ki kj kk b">&gt;&gt;=</code>)并不重要。</p><pre class="kl km kn ko fd kp kk kq kr aw ks bi"><span id="6f8d" class="kt im hi kk b fi ku kv l kw kx">mA &gt;&gt;= (mB &gt;&gt;= doStuff)</span></pre><p id="bb1d" class="pw-post-body-paragraph jj jk hi jl b jm ky jo jp jq kz js jt ju la jw jx jy lb ka kb kc lc ke kf kg hb bi translated">应该会给我们相同的结果</p><pre class="kl km kn ko fd kp kk kq kr aw ks bi"><span id="416d" class="kt im hi kk b fi ku kv l kw kx">(mA &gt;&gt;= mB) &gt;&gt;= doStuff</span></pre><p id="a7c4" class="pw-post-body-paragraph jj jk hi jl b jm ky jo jp jq kz js jt ju la jw jx jy lb ka kb kc lc ke kf kg hb bi translated">这意味着我们也可以完全去掉括号，直接</p><pre class="kl km kn ko fd kp kk kq kr aw ks bi"><span id="6f98" class="kt im hi kk b fi ku kv l kw kx">mA &gt;&gt;= mB &gt;&gt;= doStuff</span></pre><p id="ce22" class="pw-post-body-paragraph jj jk hi jl b jm ky jo jp jq kz js jt ju la jw jx jy lb ka kb kc lc ke kf kg hb bi translated">你可以把它想象成我们添加数字时发生的事情的一个更普通的版本:</p><pre class="kl km kn ko fd kp kk kq kr aw ks bi"><span id="13e1" class="kt im hi kk b fi ku kv l kw kx">5 + (3 + 8) == (5 + 3) + 8 == 5 + 3 + 8</span></pre><p id="2937" class="pw-post-body-paragraph jj jk hi jl b jm ky jo jp jq kz js jt ju la jw jx jy lb ka kb kc lc ke kf kg hb bi translated">不是每个操作都遵守这个规则(例如，减法不遵守)，但是如果我们处理单子，它们的平面图操作遵守。在我们的例子中，这意味着嵌套代码:</p><pre class="kl km kn ko fd kp kk kq kr aw ks bi"><span id="c16e" class="kt im hi kk b fi ku kv l kw kx">mA.flatMap(a =&gt; <br/>  mB.flatMap(b =&gt; <br/>    doStuff(a, b)<br/>  )<br/>)</span></pre><p id="6cea" class="pw-post-body-paragraph jj jk hi jl b jm ky jo jp jq kz js jt ju la jw jx jy lb ka kb kc lc ke kf kg hb bi translated">可以重构为:</p><pre class="kl km kn ko fd kp kk kq kr aw ks bi"><span id="d666" class="kt im hi kk b fi ku kv l kw kx">mA.flatMap { a =&gt; <br/>  mB.flatMap(b =&gt; Monad((a, b)))<br/>}.flatMap { case (a, b) =&gt; <br/>  doStuff(a, b)<br/>}</span></pre><p id="e575" class="pw-post-body-paragraph jj jk hi jl b jm ky jo jp jq kz js jt ju la jw jx jy lb ka kb kc lc ke kf kg hb bi translated">然后我们可以在上面撒上语法糖，得到这个:</p><pre class="kl km kn ko fd kp kk kq kr aw ks bi"><span id="a186" class="kt im hi kk b fi ku kv l kw kx">for {<br/>  a   &lt;- mA<br/>  b   &lt;- mB<br/>  res &lt;- doStuff(a, b)<br/>} yield res</span></pre><p id="8240" class="pw-post-body-paragraph jj jk hi jl b jm ky jo jp jq kz js jt ju la jw jx jy lb ka kb kc lc ke kf kg hb bi translated">在“左箭头”行之间，我们可以插入标准的“赋值”行，用于log语句(如上)或更常见的用于简化计算，并将它们存储在中间值中，然后可以用作连续函数调用的参数。尽管有一个或者两个限制:for-comprehension中的第一行必须是“左箭头”行，因为这是Scala编译器决定使用哪种单子的方式。毕竟，<code class="du kh ki kj kk b">Option.flatMap</code>要求我们返回<code class="du kh ki kj kk b">Option</code>、<code class="du kh ki kj kk b">Either.flatMap</code> — <code class="du kh ki kj kk b">Either</code>等等。这是由for-comprehension的第一行决定的……这也意味着你必须小心不要在一个for-comprehension中混合不同种类的单子。这很容易做到，但会导致神秘的编译错误。但至少它们是编译错误。</p><figure class="kl km kn ko fd ii er es paragraph-image"><div role="button" tabindex="0" class="lf lg di lh bf li"><div class="er es le"><img src="../Images/7eab2cf182e94ed60c85ef7e3c88b31c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*94tE1uPRLlcKwTrG"/></div></div></figure><p id="55a8" class="pw-post-body-paragraph jj jk hi jl b jm ky jo jp jq kz js jt ju la jw jx jy lb ka kb kc lc ke kf kg hb bi translated">还可以对左箭头返回的数据进行模式匹配，只有在某些条件为真时才采取进一步的行动。例如，你可能有一个<code class="du kh ki kj kk b">Boolean</code>的<code class="du kh ki kj kk b">Option</code>,并且想要继续理解只有当它包含<code class="du kh ki kj kk b">true</code>的时候:</p><pre class="kl km kn ko fd kp kk kq kr aw ks bi"><span id="6711" class="kt im hi kk b fi ku kv l kw kx">def checkSetting(setting: Setting): Option[Boolean] = ...</span><span id="9924" class="kt im hi kk b fi ld kv l kw kx">for { // this is a for/yield for the type Option<br/>  ...<br/>  true &lt;- checkSetting(Settings.IS_RECORDING_ALLOWED)<br/>  ...<br/>} yield { ... }</span></pre><p id="dc11" class="pw-post-body-paragraph jj jk hi jl b jm ky jo jp jq kz js jt ju la jw jx jy lb ka kb kc lc ke kf kg hb bi translated">只有当<code class="du kh ki kj kk b">checkSetting</code>返回<code class="du kh ki kj kk b">Some(true)</code>时，行<code class="du kh ki kj kk b">true &lt;- checkSetting(Settings.IS_RECORDING_ALLOWED)</code>才会被通过。如果它返回<code class="du kh ki kj kk b">Some(false)</code>或<code class="du kh ki kj kk b">None</code>，剩余的for-comprehension将被跳过。</p><p id="d09b" class="pw-post-body-paragraph jj jk hi jl b jm ky jo jp jq kz js jt ju la jw jx jy lb ka kb kc lc ke kf kg hb bi translated">Uff。单子说够了。</p><p id="bd00" class="pw-post-body-paragraph jj jk hi jl b jm ky jo jp jq kz js jt ju la jw jx jy lb ka kb kc lc ke kf kg hb bi translated">在这个系列中，还有一个我想讨论的话题。这与函数式编程有点无关，但我认为包含它足够有趣:接下来是<a class="ae lz" href="https://makingthematrix.medium.com/programming-with-functions-10-composition-over-inheritance-33bfbcf295c3" rel="noopener"> <strong class="jl hj">复合超过继承</strong>。</a></p><p id="9fa3" class="pw-post-body-paragraph jj jk hi jl b jm ky jo jp jq kz js jt ju la jw jx jy lb ka kb kc lc ke kf kg hb bi translated"><strong class="jl hj">链接:</strong></p><p id="df45" class="pw-post-body-paragraph jj jk hi jl b jm ky jo jp jq kz js jt ju la jw jx jy lb ka kb kc lc ke kf kg hb bi translated"><a class="ae lz" href="https://www.scala-lang.org/api/current/scala/Try.html" rel="noopener ugc nofollow" target="_blank">试试在Scala docs </a> <br/> <a class="ae lz" href="https://www.youtube.com/watch?v=d-dy1x33moA" rel="noopener ugc nofollow" target="_blank">中更多关于单子从“R </a></p></div></div>    
</body>
</html>