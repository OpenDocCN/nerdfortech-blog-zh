<html>
<head>
<title>Git Series — 2. Git Basics</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Git 系列— 2。Git 基础</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/git-series-2-git-basics-e986147c98cb?source=collection_archive---------21-----------------------#2021-04-12">https://medium.com/nerd-for-tech/git-series-2-git-basics-e986147c98cb?source=collection_archive---------21-----------------------#2021-04-12</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/1195ab9eff99c6159560195b82bf9662.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cKaYfzjtBxmJDp6xWnvHTQ.jpeg"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">【https://images8.alphacoders.com/430/thumb-1920-430944.jpg T4】</figcaption></figure><p id="8cc3" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在 Git 系列的上一篇文章“<a class="ae iu" rel="noopener" href="/nerd-for-tech/git-series-1-introduction-getting-started-with-git-5d006b368228">简介&amp;Git 入门</a>中，我们介绍了 Git 的定义、基本特性、基本流程、优点、Git 和 GitHub 的区别，以及如何在不同的操作系统上安装 Git。在本文中，我们将介绍 Git 的基础知识，从创建一个存储库开始，到克隆一个现有的存储库，跟踪和提交变更，撤销变更，推和拉变更，管理远程分支，标记和别名。让我们开始吧..</p><h1 id="ba1a" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">创建新的存储库</h1><p id="d88a" class="pw-post-body-paragraph iv iw hi ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated">创建新的存储库是 git 中最简单的任务。你只需要根据你的操作系统打开一个 CLI 工具(Linux 中的终端或者 Windows 中的命令提示符/Powershell/Git Bash)，cd 到你需要创建仓库的目录下就可以了</p><p id="666d" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">对于 Linux:</p><pre class="kw kx ky kz fd la lb lc ld aw le bi"><span id="b141" class="lf ju hi lb b fi lg lh l li lj">$ cd /home/user/my_project</span></pre><p id="73d4" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">对于 macOS:</p><pre class="kw kx ky kz fd la lb lc ld aw le bi"><span id="4e9c" class="lf ju hi lb b fi lg lh l li lj">$ cd /Users/user/my_project</span></pre><p id="465c" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">对于 Windows:</p><pre class="kw kx ky kz fd la lb lc ld aw le bi"><span id="5008" class="lf ju hi lb b fi lg lh l li lj">$ cd C:/Users/user/my_project</span></pre><p id="f914" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">和类型:</p><pre class="kw kx ky kz fd la lb lc ld aw le bi"><span id="5caa" class="lf ju hi lb b fi lg lh l li lj">$ git init</span></pre><p id="ff21" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这将创建一个名为<code class="du lk ll lm lb b">.git</code>的新的隐藏子目录，其中包含所有必需的存储库文件——Git 存储库框架。</p><h1 id="278c" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">克隆现有存储库</h1><p id="9316" class="pw-post-body-paragraph iv iw hi ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated">如果您想要克隆现有的存储库而不是创建新的存储库，您可以使用</p><p id="d989" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><code class="du lk ll lm lb b">git clone REPO_URL</code></p><p id="3223" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">要从 GitHub 克隆一个存储库，可以从下面的截图中找到 REPO_URL</p><figure class="kw kx ky kz fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ln"><img src="../Images/bf3ba7ab6295407e6aed0470c545fbf2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5fbARBXWeu7eK4EhDGrfTA.png"/></div></div></figure><p id="6f26" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">因此，您可以通过键入以下命令来克隆上述存储库</p><p id="e544" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><code class="du lk ll lm lb b">git clone <a class="ae iu" href="https://github.com/NomanNasirMinhas/Rust-Calculator.git" rel="noopener ugc nofollow" target="_blank">https://github.com/NomanNasirMinhas/Rust-Calculator.git</a></code></p><p id="1bee" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">它将在终端中打开的当前工作目录中克隆这个存储库。</p><p id="656f" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">正如在<a class="ae iu" rel="noopener" href="/nerd-for-tech/git-series-1-introduction-getting-started-with-git-5d006b368228">上一篇文章</a>中提到的，你也可以使用任何服务器托管的存储库来代替 GitHub。因此，要从您的服务器使用存储库，您可以键入</p><p id="38e7" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><code class="du lk ll lm lb b">git clone user@server:path_to_repo/repo.git</code></p><p id="d121" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">此时，我们刚刚创建或克隆了一个存储库，您的项目中还没有任何东西被跟踪。</p><h1 id="de18" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">跟踪和提交更改</h1><p id="5765" class="pw-post-body-paragraph iv iw hi ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated"><strong class="ix hj">忽略文件</strong></p><p id="2476" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在开始跟踪和提交更改之前，我们需要了解关于忽略文件的知识。通常，您会有一类不想让 Git 自动添加甚至显示为未被跟踪的文件。例如 nodeJS 项目中的<code class="du lk ll lm lb b">node modules </code>文件夹或 rust 项目中的<code class="du lk ll lm lb b">target</code>文件夹。在这种情况下，你可以在项目的父文件夹中创建一个文件列出模式来匹配它们，命名为<code class="du lk ll lm lb b">.gitignore</code>。下面是一个示例<code class="du lk ll lm lb b">.gitignore</code>文件:</p><pre class="kw kx ky kz fd la lb lc ld aw le bi"><span id="4439" class="lf ju hi lb b fi lg lh l li lj"># ignore all .a files<br/>*.a<br/><br/># but do track lib.a, even though you're ignoring .a files above<br/>!lib.a<br/><br/># only ignore the TODO file in the current directory, not subdir/TODO<br/>/TODO<br/><br/># ignore all files in any directory named build<br/>build/<br/><br/># ignore doc/notes.txt, but not doc/server/arch.txt<br/>doc/*.txt<br/><br/># ignore all .pdf files in the doc/ directory and any of its subdirectories<br/>doc/**/*.pdf</span></pre><blockquote class="lo lp lq"><p id="4033" class="iv iw lr ix b iy iz ja jb jc jd je jf ls jh ji jj lt jl jm jn lu jp jq jr js hb bi translated">如果你想要一个项目的起点，GitHub 在 https://github.com/github/gitignore 为几十个项目和语言维护了一个相当全面的好的<code class="du lk ll lm lb b">.gitignore</code>文件示例列表。</p></blockquote><p id="bdd8" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">暂存文件</strong></p><p id="40a9" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">当你添加、编辑或删除了项目中的任何文件，并且想要跟踪 git 中的变化时，你可以根据自己的需要使用不同的方法使用“git add”命令。</p><p id="c829" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">要跟踪特定文件中的更改，只需键入</p><p id="6984" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><code class="du lk ll lm lb b">git add file_name.file_extension</code></p><p id="bed1" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">若要跟踪特定扩展名的文件中的更改，请使用</p><p id="85af" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><code class="du lk ll lm lb b">git add *.file_extension</code></p><p id="7cbe" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如果有很多文件，并且您不能单独添加所有文件，那么可以跟踪文件夹中包含的所有文件的更改</p><p id="f78b" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><code class="du lk ll lm lb b">git add .</code></p><p id="a352" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">您可以同时使用多个 add 命令。例如，跟踪特定 exe 文件和所有 txt 扩展名文件的变化</p><p id="0835" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><code class="du lk ll lm lb b">git add file_name.exe</code></p><p id="3ac5" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><code class="du lk ll lm lb b">git add *.txt</code></p><p id="c7d8" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">为了检查所有跟踪文件的当前状态，您可以使用“git status ”,例如</p><pre class="kw kx ky kz fd la lb lc ld aw le bi"><span id="40ab" class="lf ju hi lb b fi lg lh l li lj">$ git add README<br/>$ git status<br/>On branch master<br/>Your branch is up-to-date with 'origin/master'.<br/>Changes to be committed:<br/>  (use "git restore --staged &lt;file&gt;..." to unstage)<br/><br/>    new file:   README</span></pre><p id="9aae" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">删除文件</strong></p><p id="0278" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">要从 Git 中删除一个文件，您必须从您跟踪的文件中删除它(更准确地说，从您的临时区域中删除它),然后提交。<code class="du lk ll lm lb b">git rm</code>命令会这样做，并且还会从您的工作目录中删除该文件，这样您下次就不会看到它是一个未被跟踪的文件</p><pre class="kw kx ky kz fd la lb lc ld aw le bi"><span id="2a3e" class="lf ju hi lb b fi lg lh l li lj">rm PROJECTS.md<!-- --> </span></pre><p id="b68b" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">您可能想要做的另一件有用的事情是将文件保存在工作树中，但是将它从暂存区域中删除。换句话说，您可能希望将文件保存在硬盘上，但不再让 Git 跟踪它。如果您忘记向您的<code class="du lk ll lm lb b">.gitignore</code>文件添加一些东西，并且不小心暂存了它，比如一个大的日志文件或一堆<code class="du lk ll lm lb b">.a</code>编译的文件，这将特别有用。为此，使用<code class="du lk ll lm lb b">--cached</code>选项:</p><pre class="kw kx ky kz fd la lb lc ld aw le bi"><span id="e39d" class="lf ju hi lb b fi lg lh l li lj">git rm --cached README</span></pre><p id="718d" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">提交变更</strong></p><p id="e37f" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">添加完所有文件后，您需要通过以下方式提交这些更改</p><p id="97f5" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><code class="du lk ll lm lb b">git commit -m "Describe Your changes in a sentence or any other message"</code></p><p id="e061" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在<code class="du lk ll lm lb b">git commit</code>命令中添加<code class="du lk ll lm lb b">-a</code>选项会让 Git 在提交之前自动暂存每个已经被跟踪的文件，让您跳过<code class="du lk ll lm lb b">git add</code>部分</p><pre class="kw kx ky kz fd la lb lc ld aw le bi"><span id="4c21" class="lf ju hi lb b fi lg lh l li lj">git commit -a -m 'Add new benchmarks'</span></pre><p id="ce28" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在您创建了几个提交之后，或者如果您已经克隆了一个具有现有提交历史的存储库，您可能想要回顾一下发生了什么。最基本和最强大的工具是<code class="du lk ll lm lb b">git log</code>命令。最干净的方法是</p><pre class="kw kx ky kz fd la lb lc ld aw le bi"><span id="600f" class="lf ju hi lb b fi lg lh l li lj">$ git log --pretty=oneline<br/>ca82a6dff817ec66f44342007202690a93763949 Change version number<br/>085bb3bcb608e1e8451d4b2432f8ecbe6306e7e7 Remove unnecessary test<br/>a11bef06a3f659402fe7563abf99ad00de2209e6 Initial commit</span></pre><p id="cd80" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">撤销提交</strong></p><p id="a927" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">当您过早提交并且可能忘记添加一些文件，或者您弄乱了您的提交消息时，需要一个常见的撤销提交。如果您想重做提交，进行您忘记的额外更改，暂存它们，并使用<code class="du lk ll lm lb b">--amend</code>选项再次提交</p><pre class="kw kx ky kz fd la lb lc ld aw le bi"><span id="ea47" class="lf ju hi lb b fi lg lh l li lj">git commit -m 'Initial commit'<br/>git add forgotten_file<br/>git commit --amend</span></pre><p id="f528" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">卸载文件</strong></p><p id="da8d" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">例如，假设您已经更改了两个文件，并希望将它们作为两个独立的更改提交，但是您不小心键入了<code class="du lk ll lm lb b">git add *</code>并将它们都存放起来。你怎么能把两者中的一个分开呢？<code class="du lk ll lm lb b">git status</code>命令提醒您:</p><pre class="kw kx ky kz fd la lb lc ld aw le bi"><span id="3a1c" class="lf ju hi lb b fi lg lh l li lj">$ git add *<br/>$ git status<br/>On branch master<br/>Changes to be committed:<br/>  (use "git restore --staged &lt;file&gt;..." to unstage)<br/>	modified:   CONTRIBUTING.md<br/>	renamed:    README.md -&gt; README</span></pre><p id="134d" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在“Changes to committed”文本的正下方，写着使用<code class="du lk ll lm lb b">git restore --staged &lt;file&gt;…​</code>取消登台。因此，让我们使用这个建议来卸载<code class="du lk ll lm lb b">CONTRIBUTING.md</code>文件:</p><pre class="kw kx ky kz fd la lb lc ld aw le bi"><span id="12e0" class="lf ju hi lb b fi lg lh l li lj">$ git restore --staged CONTRIBUTING.md<br/>$ git status<br/>On branch master<br/>Changes to be committed:<br/>  (use "git restore --staged &lt;file&gt;..." to unstage)<br/>	renamed:    README.md -&gt; README</span><span id="389f" class="lf ju hi lb b fi lv lh l li lj">Changes not staged for commit:<br/>  (use "git add &lt;file&gt;..." to update what will be committed)<br/>  (use "git restore &lt;file&gt;..." to discard changes in working directory)<br/>	modified:   CONTRIBUTING.md</span></pre><p id="2ae4" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><code class="du lk ll lm lb b">CONTRIBUTING.md</code>文件已修改，但再次未转移。</p><p id="5d72" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">取消修改已修改的文件</strong></p><p id="2d4c" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如果您意识到您不想保留对<code class="du lk ll lm lb b">CONTRIBUTING.md</code>文件的更改，该怎么办？如何轻松地取消修改它——将它恢复到您上次提交时的样子(或者最初克隆，或者您将它放入工作目录时的样子)？幸运的是，<code class="du lk ll lm lb b">git status</code>也告诉你如何去做。在最后一个输出示例中，未登台区域如下所示:</p><pre class="kw kx ky kz fd la lb lc ld aw le bi"><span id="3b16" class="lf ju hi lb b fi lg lh l li lj">Changes not staged for commit:<br/>  (use "git add &lt;file&gt;..." to update what will be committed)<br/>  (use "git checkout -- &lt;file&gt;..." to discard changes in working directory)</span><span id="ec5d" class="lf ju hi lb b fi lv lh l li lj">    modified:   CONTRIBUTING.md</span></pre><p id="9496" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">它非常明确地告诉您如何放弃您所做的更改。让我们照它说的做:</p><pre class="kw kx ky kz fd la lb lc ld aw le bi"><span id="87ff" class="lf ju hi lb b fi lg lh l li lj">$ git checkout -- CONTRIBUTING.md<br/>$ git status<br/>On branch master<br/>Changes to be committed:<br/>  (use "git reset HEAD &lt;file&gt;..." to unstage)</span><span id="0988" class="lf ju hi lb b fi lv lh l li lj">    renamed:    README.md -&gt; README</span></pre><p id="ab43" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">您可以看到更改已被恢复。</p><h1 id="945a" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">推送/发布我们的提交</h1><p id="bee2" class="pw-post-body-paragraph iv iw hi ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated">请记住，到目前为止，我们在本地所做更改还没有发布到云/服务器存储库中。</p><p id="7732" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">为了发布您的更改，我们只需键入</p><p id="1cfb" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><code class="du lk ll lm lb b">git push</code></p><p id="595e" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">或者</p><p id="baa7" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><code class="du lk ll lm lb b">git push &lt;remote&gt; &lt;branch&gt;</code></p><p id="4704" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">更具体地说，如果你有多个遥控器或多个分支。</p><blockquote class="lo lp lq"><p id="b1bc" class="iv iw lr ix b iy iz ja jb jc jd je jf ls jh ji jj lt jl jm jn lu jp jq jr js hb bi translated">我们将在本文的下一节讨论“远程”的细节，在本系列的下一篇文章中讨论“分支”。</p></blockquote><p id="102a" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在这一阶段，如果您在您拥有的克隆存储库中进行了更改，该命令将发布您的更改，但是您已经创建了一个新的 git 存储库，那么此时<code class="du lk ll lm lb b">push</code>命令将抛出一个上游错误。这个错误意味着我们还没有将我们的本地存储库连接到一个远程文件夹，变更将被推送到这个文件夹中。这就引出了我们的下一个话题“遥控器”</p><h1 id="0a24" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">遥控器</h1><p id="c761" class="pw-post-body-paragraph iv iw hi ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated">为了能够在任何 Git 项目上协作，您需要知道如何管理您的远程存储库。远程存储库是您的项目的版本，托管在互联网或网络的某个地方。</p><blockquote class="lo lp lq"><p id="a224" class="iv iw lr ix b iy iz ja jb jc jd je jf ls jh ji jj lt jl jm jn lu jp jq jr js hb bi translated">您完全有可能使用一个“远程”存储库，事实上，它位于您所在的主机上。“远程”一词并不一定意味着储存库在网络或互联网上的某个地方，只是意味着它在其他地方。</p></blockquote><p id="f9a3" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">检查 git 存储库的远程信息</strong></p><p id="2172" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">要查看您已经配置了哪些远程服务器，您可以运行<code class="du lk ll lm lb b">git remote</code>命令。它列出了您指定的每个远程句柄的简称。如果你已经克隆了你的库，你至少应该看到<code class="du lk ll lm lb b">origin</code>——这是 Git 给你克隆的服务器的默认名称。</p><p id="2dac" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">您还可以指定<code class="du lk ll lm lb b">-v</code>，它向您显示 Git 为短名称存储的 URL，以便在读写该遥控器时使用。</p><pre class="kw kx ky kz fd la lb lc ld aw le bi"><span id="b175" class="lf ju hi lb b fi lg lh l li lj">$ git remote -v<br/>origin	https://github.com/schacon/ticgit (fetch)<br/>origin	https://github.com/schacon/ticgit (push)</span></pre><p id="a1c5" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">上述命令的结果显示了两个具有相同名称的遥控器，但是<em class="lr">获取和推送。</em>表示分别从其中拉取变更(根据远程代码同步本地代码)和向其中推送变更的 url。如果我们在新创建的 git 存储库中运行这个命令，那么我们将看不到任何远程。为了添加一个远程您的本地存储库，我们可以使用</p><p id="bbf2" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><code class="du lk ll lm lb b">git remote add &lt;shortname&gt; &lt;url&gt;</code></p><p id="49ee" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">例如</p><pre class="kw kx ky kz fd la lb lc ld aw le bi"><span id="b961" class="lf ju hi lb b fi lg lh l li lj">git remote add origin https://github.com/paulboone/ticgit</span></pre><p id="c066" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">上面的命令显示我们已经在 GitHub 上创建了我们的远程存储库。我们还可以通过以下方式添加任何其他服务器的远程存储库</p><p id="1fbd" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">`<code class="du lk ll lm lb b">git remote add origin ssh://user@host:/path_to_repository</code></p><p id="c96e" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">既然我们已经向本地存储库添加了一个远程，我们可以通过</p><pre class="kw kx ky kz fd la lb lc ld aw le bi"><span id="3cf1" class="lf ju hi lb b fi lg lh l li lj">git push origin master</span></pre><p id="2d97" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">一旦我们添加了一个遥控器，在提交时就不需要再添加了。</p><p id="cd82" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">重命名和移除遥控器</strong></p><p id="3527" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">您可以运行<code class="du lk ll lm lb b">git remote rename</code>来更改遥控器的简称。例如，如果您想将<code class="du lk ll lm lb b">origin</code>重命名为<code class="du lk ll lm lb b">repo1</code>，您可以使用<code class="du lk ll lm lb b">git remote rename</code>来完成:</p><pre class="kw kx ky kz fd la lb lc ld aw le bi"><span id="9119" class="lf ju hi lb b fi lg lh l li lj">$ git remote rename origin repo1</span></pre><h1 id="db38" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">从你的遥控器里拿出来</h1><p id="e31a" class="pw-post-body-paragraph iv iw hi ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated">假设您将更改推送到一个远程设备。您的另一个项目团队克隆了您的存储库。当他检查代码时，他发现了一些错误，于是他对代码做了一些修改来修复它们。然后，他推动了变革。你将如何让你的朋友在你的本地代码中做出改变？您可以运行 pull 命令来获取远程存储库上的最新代码，方法是</p><p id="bbc9" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><code class="du lk ll lm lb b">git pull</code></p><p id="8e8e" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如果两个代码之间没有冲突，这将把您的本地代码与远程存储库上的代码进行交换。所谓冲突，是指在将文件推送到远程后，您对任何文件中的代码进行了任何更改。可能出现的情况是，当您拉取代码时，您的代码中可能有一些未提交的本地代码更改，这可能与从远程拉取的代码冲突。在这种情况下，我们有合并问题，因为 git 不能决定应该保留哪些代码；本地或远程。因此，最好总是先提取代码，然后在本地进行修改。</p><h1 id="230b" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">磨尖</h1><p id="8687" class="pw-post-body-paragraph iv iw hi ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated">Git 能够将存储库历史中的特定点标记为重要点。通常，人们使用这个功能来标记发布点(<code class="du lk ll lm lb b">v1.0</code>、<code class="du lk ll lm lb b">v2.0</code>等等)。Git 支持两种类型的标签:<strong class="ix hj">轻量级</strong>和<strong class="ix hj">带注释的</strong>。轻量级标签非常像一个不变的分支——它只是一个指向特定提交的指针。然而，带注释的标签作为完整的对象存储在 Git 数据库中。</p><p id="ddad" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在 Git 中创建带注释的标签很简单。最简单的方法是在运行<code class="du lk ll lm lb b">tag</code>命令时指定<code class="du lk ll lm lb b">-a</code>:</p><pre class="kw kx ky kz fd la lb lc ld aw le bi"><span id="068b" class="lf ju hi lb b fi lg lh l li lj">git tag -a v1.4 -m "my version 1.4"</span></pre><p id="b217" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">您可以看到标记数据以及使用<code class="du lk ll lm lb b">git show</code>命令标记的提交:</p><pre class="kw kx ky kz fd la lb lc ld aw le bi"><span id="ada0" class="lf ju hi lb b fi lg lh l li lj">$ git show v1.4<br/>tag v1.4<br/>Tagger: Ben Straub &lt;ben@straub.cc&gt;<br/>Date:   Sat May 3 20:19:12 2014 -0700</span><span id="a0c1" class="lf ju hi lb b fi lv lh l li lj">my version 1.4</span><span id="3b0e" class="lf ju hi lb b fi lv lh l li lj">commit ca82a6dff817ec66f44342007202690a93763949<br/>Author: Scott Chacon &lt;schacon@gee-mail.com&gt;<br/>Date:   Mon Mar 17 21:52:11 2008 -0700</span><span id="b990" class="lf ju hi lb b fi lv lh l li lj">    Change version number</span></pre><p id="30ef" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">标记提交的另一种方法是使用轻量级标记。这基本上是存储在文件中的提交校验和，不保留任何其他信息。要创建一个轻量级标记，不要提供任何<code class="du lk ll lm lb b">-a</code>、<code class="du lk ll lm lb b">-s</code>或<code class="du lk ll lm lb b">-m</code>选项，只需提供一个标记名:</p><pre class="kw kx ky kz fd la lb lc ld aw le bi"><span id="e832" class="lf ju hi lb b fi lg lh l li lj">$ git tag v1.4-lw</span></pre><p id="835b" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这一次，如果您在标签上运行<code class="du lk ll lm lb b">git show</code>，您将看不到额外的标签信息。该命令只显示提交:</p><pre class="kw kx ky kz fd la lb lc ld aw le bi"><span id="8204" class="lf ju hi lb b fi lg lh l li lj">$ git show v1.4-lw<br/>commit ca82a6dff817ec66f44342007202690a93763949<br/>Author: Scott Chacon &lt;schacon@gee-mail.com&gt;<br/>Date:   Mon Mar 17 21:52:11 2008 -0700</span><span id="9391" class="lf ju hi lb b fi lv lh l li lj">    Change version number</span></pre><p id="ce83" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">默认情况下，<code class="du lk ll lm lb b">git push</code>命令不会将标签传输到远程服务器。创建标签后，您必须将标签明确推送到共享服务器。这个过程就像共享远程分支一样——您可以运行<code class="du lk ll lm lb b">git push origin &lt;tagname&gt;</code>。</p><pre class="kw kx ky kz fd la lb lc ld aw le bi"><span id="b842" class="lf ju hi lb b fi lg lh l li lj">$ git push origin v1.5</span></pre><p id="a4e9" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如果您有很多想要一次推送的标签，您也可以使用<code class="du lk ll lm lb b">git push</code>命令的<code class="du lk ll lm lb b">--tags</code>选项。这将把你所有的标签转移到远程服务器上。</p><pre class="kw kx ky kz fd la lb lc ld aw le bi"><span id="4ad2" class="lf ju hi lb b fi lg lh l li lj">$ git push origin --tags</span></pre><p id="f64e" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在 Git 中列出现有的标签很简单。只需输入<code class="du lk ll lm lb b">git tag</code>(可选<code class="du lk ll lm lb b">-l</code>或<code class="du lk ll lm lb b">--list</code>):</p><pre class="kw kx ky kz fd la lb lc ld aw le bi"><span id="573e" class="lf ju hi lb b fi lg lh l li lj">$ git tag<br/>v1.0<br/>v2.0</span></pre><p id="5adf" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">要删除本地存储库中的标签，您可以使用<code class="du lk ll lm lb b">git tag -d &lt;tagname&gt;</code>。例如，我们可以删除上面的轻量级标签，如下所示:</p><pre class="kw kx ky kz fd la lb lc ld aw le bi"><span id="7ef2" class="lf ju hi lb b fi lg lh l li lj">$ git tag -d v1.4-lw<br/>Deleted tag 'v1.4-lw' (was e7d5add)</span></pre><p id="c4db" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">请注意，这不会从任何远程服务器上删除标记。删除远程标签最直观的方法是:</p><pre class="kw kx ky kz fd la lb lc ld aw le bi"><span id="10b8" class="lf ju hi lb b fi lg lh l li lj">$ git push origin --delete &lt;tagname&gt;</span></pre><h1 id="97e3" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">Git 别名</h1><p id="3e7f" class="pw-post-body-paragraph iv iw hi ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated">如果您不想输入每个 Git 命令的全部文本，您可以使用<code class="du lk ll lm lb b">git config</code>为每个命令设置一个别名。以下是您可能想要设置的几个示例:</p><pre class="kw kx ky kz fd la lb lc ld aw le bi"><span id="a797" class="lf ju hi lb b fi lg lh l li lj">$ git config --global alias.co checkout<br/>$ git config --global alias.br branch<br/>$ git config --global alias.ci commit<br/>$ git config --global alias.st status</span></pre><p id="f6c2" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这意味着，例如，您只需键入<code class="du lk ll lm lb b">git ci.</code>，而不是键入<code class="du lk ll lm lb b">git commit</code></p><blockquote class="lo lp lq"><p id="5fce" class="iv iw lr ix b iy iz ja jb jc jd je jf ls jh ji jj lt jl jm jn lu jp jq jr js hb bi translated">在下一篇文章中，我们将介绍一个简单的 git 流程，从创建一个空的 git 存储库到推送和拉取代码。</p></blockquote></div></div>    
</body>
</html>