<html>
<head>
<title>Multiprocessing in Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python 中的多重处理</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/multiprocessing-in-python-ef567a35189a?source=collection_archive---------12-----------------------#2021-05-25">https://medium.com/nerd-for-tech/multiprocessing-in-python-ef567a35189a?source=collection_archive---------12-----------------------#2021-05-25</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="18b3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在本文中，我将分享我是如何在 Python 脚本中使用多重处理的。在早期，当我知道多处理的概念，但不知道如何确切地使用它来使 Python 脚本运行得更快时，我挣扎了很久。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es jd"><img src="../Images/68f8ba77945aa44f97c677b3128dbdb5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*FM1gmoXnvaMg3i84qUP-_w.png"/></div></figure><p id="cc4e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">线性运行 python 脚本中的方法没有任何问题，事实上，这要简单得多…编写方法来完成特定的任务，逐个调用它们并从每个方法中收集数据，就大功告成了。但在大多数情况下，这是一种耗时的方法。</p><blockquote class="jl jm jn"><p id="3d07" class="if ig jo ih b ii ij ik il im in io ip jp ir is it jq iv iw ix jr iz ja jb jc hb bi translated">多重处理来了…</p></blockquote><p id="94e3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">当我开始使用多重处理编写脚本时，我不得不处理一些事情。让我们先把它们记下来。<br/> 1。将脚本拆分成可以并行运行的任务。<br/> 2。正确地执行这些方法，并将它们与主流程结合起来。<br/> 3。管理进程间的共享数据(列表、队列、返回值)。<br/> 4。管理不同进程的日志记录。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es js"><img src="../Images/e844493ec5ebd6f376ee3763aa07c258.png" data-original-src="https://miro.medium.com/v2/resize:fit:640/format:webp/1*H7kMnNue2awkWjpsaYWn_g.jpeg"/></div></figure><p id="63cd" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">是的，一开始这让我很困惑。但是在我的导师的帮助下，很明显，是 StackOverflow😛我想到了一个解决办法。所以我们来探索一下。</p><h1 id="2661" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated"><strong class="ak"> 1。将脚本拆分成可以并行运行的任务。</strong></h1><p id="09f5" class="pw-post-body-paragraph if ig hi ih b ii kr ik il im ks io ip iq kt is it iu ku iw ix iy kv ja jb jc hb bi translated">这是最棘手的部分，因为一开始，我甚至找不到一对可以并行运行的方法。让我们举一个简单的例子——</p><p id="b51a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">假设您想要生成一个从 1 到 20 的数字列表，然后向列表中的每个数字添加一个从 10–20 的随机整数，然后将列表转换为一个集合，这样在最终输出中就不会有重复的数字。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="er es kw"><img src="../Images/d6b1d8b4317cf8cfa3e2c795fcacb8db.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ucnKZ1p6i9Jh9pS99QEAHA.png"/></div></div></figure><p id="870e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们将创建 3 个方法来分割这项任务，一个方法将生成一个从 1 到 20 的数字列表，然后另一个方法将向列表中的每个数字添加随机数，然后一个方法将列表转换为集合。现在的问题是，有没有办法并行运行这些方法？？😕 💭</p><blockquote class="jl jm jn"><p id="0354" class="if ig jo ih b ii ij ik il im in io ip jp ir is it jq iv iw ix jr iz ja jb jc hb bi translated">如果我们的第二个方法(<strong class="ih hj"> add_random </strong>)不必等待第一个方法(<strong class="ih hj"> generate_numbers_list </strong>)完成，并且只要生成一个数字，第二个方法就可以开始处理该数字，即生成一个随机数并添加到其中，那会怎么样？</p></blockquote><p id="44cd" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们将再添加两个方法，一个在开始，即 logger 方法，另一个在<strong class="ih hj"> convert_to_set </strong>()方法之前，该方法将收集所有数据流并创建一个最终列表，该列表将准备好转换为 set。因为将列表转换为集合需要所有数据同时进行，所以我们不能并行化该方法。</p><p id="b8bc" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在，流程将会是—</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="er es lb"><img src="../Images/459950169583188c4cf03701967936a0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zG-bWn2NApZ-whTtoZFB-A.png"/></div></div></figure><p id="6b4f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在，这 4 种方法将并行运行。(生成数字列表，随机添加，数字列表，打印日志)</p><pre class="je jf jg jh fd lc ld le lf aw lg bi"><span id="e438" class="lh ju hi ld b fi li lj l lk ll">def generate_numbers_list():<br/>    LOGGER_QUEUE.put("Number generation Started")<br/>    for x in range(1, 21):<br/>        NUMBERS_QUEUE.put(x)<br/>        time.sleep(5)</span></pre></div><div class="ab cl lm ln gp lo" role="separator"><span class="lp bw bk lq lr ls"/><span class="lp bw bk lq lr ls"/><span class="lp bw bk lq lr"/></div><div class="hb hc hd he hf"><pre class="lc ld le lf aw lg bi"><span id="ad1a" class="lh ju hi ld b fi lt lu lv lw lx lj l lk ll">def add_random():<br/>    LOGGER_QUEUE.put("Number addition Started")<br/>    while True:<br/>        num = randint(10, 20)<br/>        if not NUMBERS_QUEUE.empty():<br/>            x = NUMBERS_QUEUE.get()<br/>            LOGGER_QUEUE.put(f"add_random - {x}")<br/>            RANDINT_QUEUE.put(x+num)</span></pre></div><div class="ab cl lm ln gp lo" role="separator"><span class="lp bw bk lq lr ls"/><span class="lp bw bk lq lr ls"/><span class="lp bw bk lq lr"/></div><div class="hb hc hd he hf"><pre class="lc ld le lf aw lg bi"><span id="1fdc" class="lh ju hi ld b fi lt lu lv lw lx lj l lk ll">def numbers_list(final_list):<br/>    LOGGER_QUEUE.put("list conversion Started")<br/>    while True:<br/>        if not RANDINT_QUEUE.empty():<br/>            x = RANDINT_QUEUE.get()<br/>            LOGGER_QUEUE.put(f"appending - {x}")<br/>            final_list.append(x)</span></pre></div><div class="ab cl lm ln gp lo" role="separator"><span class="lp bw bk lq lr ls"/><span class="lp bw bk lq lr ls"/><span class="lp bw bk lq lr"/></div><div class="hb hc hd he hf"><p id="a415" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> generate_numbers_list </strong>()将生成从 1 到 20 的数字列表。为了使它更耗时，我们可以添加 time.sleep(5)在生成每个数字后睡眠 5 秒钟。现在，只要它生成一个数字，它就会将该数字添加到名为——NUMBERS _ Queue 的多处理队列中，该队列正被下一个方法监听，即<strong class="ih hj"> add_random </strong> () <br/>只要队列中有一个数字可用，add_random 就会将一个随机数添加到该队列中，并将其放入 RANDINT_QUEUE。接下来，它被下一个方法<strong class="ih hj"> numbers_list </strong>()监听，并收集数据以创建最终列表。</p><h1 id="2255" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated"><strong class="ak"> 2。正确地执行这些方法，并将它们与主流程结合起来。</strong></h1><p id="61ea" class="pw-post-body-paragraph if ig hi ih b ii kr ik il im ks io ip iq kt is it iu ku iw ix iy kv ja jb jc hb bi translated">您可以为每种方法创建一个流程，然后启动它。</p><pre class="je jf jg jh fd lc ld le lf aw lg bi"><span id="1516" class="lh ju hi ld b fi li lj l lk ll">generate_numbers_process = Process(target=generate_numbers_list)<br/>    add_random_process = Process(target=add_random)<br/>    numbers_list_process = Process(target=numbers_list)<br/>    generate_numbers_process.start()<br/>    add_random_process.start()<br/>    numbers_list_process.start()<br/>    generate_numbers_process.join()<br/>    add_random_process.join()<br/>    numbers_list_process.join()</span></pre><p id="ee88" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">每个进程都需要 Join，以便它们与主方法连接，并且主方法不会在没有其进程的情况下退出。</p><h1 id="8f7c" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated"><strong class="ak"> 3。管理进程间的共享数据(列表、队列、返回值)。</strong></h1><p id="ab39" class="pw-post-body-paragraph if ig hi ih b ii kr ik il im ks io ip iq kt is it iu ku iw ix iy kv ja jb jc hb bi translated">我们将对共享数据使用多处理队列和列表。</p><pre class="je jf jg jh fd lc ld le lf aw lg bi"><span id="5029" class="lh ju hi ld b fi li lj l lk ll">from multiprocessing import Process, Queue, Manager<br/>NUMBERS_QUEUE = Queue()<br/>RANDINT_QUEUE = Queue()<br/>LOGGER_QUEUE = Queue()</span><span id="313c" class="lh ju hi ld b fi ly lj l lk ll">shared_list = Manager().list()</span></pre><h1 id="8d92" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated"><strong class="ak"> 4。管理不同进程的日志记录。</strong></h1><p id="d4e2" class="pw-post-body-paragraph if ig hi ih b ii kr ik il im ks io ip iq kt is it iu ku iw ix iy kv ja jb jc hb bi translated">由于所有的方法都是并行运行的，如果我们直接在每个方法中写入 logging.info()，那么日志将会开始打印，而没有任何正确的顺序。因此，为了按顺序打印日志，我们还需要一个方法(<strong class="ih hj"> print_logs </strong>())，该方法将监听我们示例中的 Queue- LOGGER_QUEUE，只要队列中有任何日志，它就会记录它。</p><pre class="je jf jg jh fd lc ld le lf aw lg bi"><span id="0669" class="lh ju hi ld b fi li lj l lk ll">def print_logs():<br/>    while True:<br/>        if not LOGGER_QUEUE.empty():<br/>            x = LOGGER_QUEUE.get()<br/>            logging.info(x)</span></pre></div><div class="ab cl lm ln gp lo" role="separator"><span class="lp bw bk lq lr ls"/><span class="lp bw bk lq lr ls"/><span class="lp bw bk lq lr"/></div><div class="hb hc hd he hf"><p id="fe03" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在，由于方法正在监听多重处理队列，如果没有来自源方法的数据结束的信号，它们将无限期等待。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="er es lz"><img src="../Images/2ccd0df43ac8c468a151f6537823ec6b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7LZVA3_rE9oumeUIZcMRiw.jpeg"/></div></div></figure><p id="84f4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为了处理这种情况，我们将在每个队列的末尾添加一个标志，一旦遇到该标志，侦听方法将停止从队列中提取数据。在我们的例子中，该标志将是“end”字符串，然后继续检查队列中的“end”字符串，并打破循环。</p><pre class="je jf jg jh fd lc ld le lf aw lg bi"><span id="b422" class="lh ju hi ld b fi li lj l lk ll">NUMBERS_QUEUE.put("end")<br/>RANDINT_QUEUE.put("end")<br/>LOGGER_QUEUE.put("end")</span><span id="5519" class="lh ju hi ld b fi ly lj l lk ll">while True:<br/>    if not RANDINT_QUEUE.empty():<br/>        if QUEUE.get() == "end":<br/>            break</span></pre><p id="e256" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这是我创建的一个简单的例子，用来解释我在 python 中使用多处理的策略。<em class="jo">我的用例是从一个 API 获取数据，将其格式化，然后存储在 s3 中。</em></p><p id="b128" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">随意查看整个脚本—<a class="ae ma" href="https://github.com/kuldeepkr16/python-scripts/blob/main/multip_techniques.py" rel="noopener ugc nofollow" target="_blank">https://github . com/kuldeepkr 16/python-scripts/blob/main/multip _ techniques . py</a><br/>欢迎反馈。😄</p></div></div>    
</body>
</html>