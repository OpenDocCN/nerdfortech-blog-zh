<html>
<head>
<title>JavaScript Promises — Final Part. Async/Await</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript 承诺——最后一部分。异步/等待</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/javascript-promises-final-part-async-await-5500fbf4d336?source=collection_archive---------11-----------------------#2021-09-29">https://medium.com/nerd-for-tech/javascript-promises-final-part-async-await-5500fbf4d336?source=collection_archive---------11-----------------------#2021-09-29</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/be6317f5a8ece6a4f71627dd78e375e4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Nu2ut4AQmGtB-c5yqI_Hxw.png"/></div></div></figure><p id="195c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这是这个系列的最后一部分。</p><p id="9eeb" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">为了理解 async/await，你必须理解承诺的基础和<a class="ae jo" rel="noopener" href="/nerd-for-tech/javascript-promises-part-3-promise-chaining-707ab6f1bbfc">承诺链</a>。一旦你理解了这两个概念，这篇文章就变得非常简单了。</p></div><div class="ab cl jp jq gp jr" role="separator"><span class="js bw bk jt ju jv"/><span class="js bw bk jt ju jv"/><span class="js bw bk jt ju"/></div><div class="hb hc hd he hf"><p id="c011" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">TLDR</p><blockquote class="jw"><p id="11a5" class="jx jy hi bd jz ka kb kc kd ke kf jn dx translated">async/await 是 javascript 承诺的语法糖</p></blockquote><p id="ace5" class="pw-post-body-paragraph iq ir hi is b it kg iv iw ix kh iz ja jb ki jd je jf kj jh ji jj kk jl jm jn hb bi translated">这意味着，使用 async/await，我们将能够避免 JS 承诺的样板语法，并更容易地处理它们。</p></div><div class="ab cl jp jq gp jr" role="separator"><span class="js bw bk jt ju jv"/><span class="js bw bk jt ju jv"/><span class="js bw bk jt ju"/></div><div class="hb hc hd he hf"><p id="a711" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们将从一个简单的例子开始，一旦我们理解了基础知识，我们将看一个更实际的例子。<br/>看看下面的函数。第一个创建了一个承诺，该承诺解析为值 1。第二个函数消耗并记录解析的值。</p><figure class="km kn ko kp fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es kl"><img src="../Images/fcadddd411a6f7e56f7e58c83ce2a6e6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*k_6i_DK7DgkWTOPHbNgZmA.png"/></div></div></figure><p id="0564" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这里的问题是，我们的业务逻辑被包装在 promise 语法中，很难阅读代码。一旦你开始将多个承诺串联起来，事情就会变得更加困难。我们的逻辑被分解成不同的部分。</p><p id="057f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">为了避免这种情况，我们可以使用 async/await。使用 async/await 关键字重写上述函数，它们变成:</p><figure class="km kn ko kp fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es kq"><img src="../Images/7edd85fdb48bc1820e7fe5ba36481ebe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Wh49_zbXkwFiDqp0Vn0v7A.png"/></div></div></figure><p id="23d8" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这样不是更好看更好理解吗？现在让我们了解发生了什么。</p><p id="109e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">当在 function 关键字之前应用<code class="du kr ks kt ku b">async</code>关键字时，该函数被称为异步函数。异步函数有两个区别于普通函数的特征:</p><ol class=""><li id="688a" class="kv kw hi is b it iu ix iy jb kx jf ky jj kz jn la lb lc ld bi translated">异步函数总是返回一个承诺。</li><li id="d947" class="kv kw hi is b it le ix lf jb lg jf lh jj li jn la lb lc ld bi translated">您可以在异步函数中使用<code class="du kr ks kt ku b">await</code>关键字。</li></ol><p id="5958" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><code class="du kr ks kt ku b">await</code>关键字应用于返回承诺的函数之前。并且，<code class="du kr ks kt ku b">await</code>关键字让 JavaScript 一直等到承诺兑现。只有在承诺兑现后，才会恢复正常执行。</p><p id="f4d7" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">因此，在我们的例子中，第 7 行不会执行，直到从函数<code class="du kr ks kt ku b">createPromise</code>(第 6 行)返回的承诺被解析。</p><p id="796b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在，由于异步函数总是返回一个承诺，我们不必显式地将返回值包装在承诺中。我们只需要返回该值，它将自动被包装在一个承诺中。<br/>所以，我们可以进一步简化第一个函数:</p><figure class="km kn ko kp fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es kq"><img src="../Images/d993e5d6088c2076916f067bdf388ef5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fUIlT_lDSqZ6P9uaAUh5Uw.png"/></div></div></figure><p id="7730" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">使用 async/await，我们有类似 synchronous 的语法，可以处理异步代码。</p></div><div class="ab cl jp jq gp jr" role="separator"><span class="js bw bk jt ju jv"/><span class="js bw bk jt ju jv"/><span class="js bw bk jt ju"/></div><div class="hb hc hd he hf"><p id="0fbd" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在，让我们看一个实际的例子。让我们以我们在<a class="ae jo" rel="noopener" href="/nerd-for-tech/javascript-promises-part-3-promise-chaining-707ab6f1bbfc">承诺链</a>中使用的例子为例:</p><figure class="km kn ko kp fd ij"><div class="bz dy l di"><div class="lj lk l"/></div></figure><p id="9570" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们获取所有用户，然后将他们登录到控制台。为此，我们必须使用如上所示的承诺链。如你所见，我们的逻辑被分成不同的块，很难阅读。</p><p id="a75b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">使用 async/await 重写上述函数变成:</p><figure class="km kn ko kp fd ij"><div class="bz dy l di"><div class="lj lk l"/></div></figure><p id="2a16" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">看出区别。代码变得更加易读，我们的业务逻辑也在一个地方。</p><p id="d915" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们的函数是用关键字<code class="du kr ks kt ku b">async</code>定义的。我们<code class="du kr ks kt ku b">await</code>来自 API 的响应，在第 3 行。一旦解决了这个问题，我们<code class="du kr ks kt ku b">await</code>将第 4 行的响应体读作 JSON。<br/>每行在前一行结束后执行。</p><p id="30bc" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">要明白，幕后没有魔法。我们实际上是在和承诺本身一起工作。但是，使用 async-await 关键字要容易得多，因为我们不必担心 JS 承诺的样板语法。</p></div><div class="ab cl jp jq gp jr" role="separator"><span class="js bw bk jt ju jv"/><span class="js bw bk jt ju jv"/><span class="js bw bk jt ju"/></div><div class="hb hc hd he hf"><p id="3070" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">错误处理</strong></p><p id="3c04" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">为了处理<code class="du kr ks kt ku b">promise</code>中的错误，我们使用了<code class="du kr ks kt ku b">catch</code>块。由于 async-await 完全消除了块的使用，我们将如何处理错误呢？</p><p id="434e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">为此，我们可以在 JavaScript 中使用<code class="du kr ks kt ku b">try…catch</code>语法。</p><p id="4c01" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">信不信由你，<code class="du kr ks kt ku b">try…catch</code>语法不是最近在 JS 中引入的，它从 ES3 开始就存在了。</p><p id="c90f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">要使用它，将可能抛出错误的语句放在一个<code class="du kr ks kt ku b">try</code>块中，并添加一个<code class="du kr ks kt ku b">catch</code>块来处理错误。</p><p id="6e3d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">将<code class="du kr ks kt ku b">try-catch</code>添加到我们的示例中，就变成了</p><figure class="km kn ko kp fd ij"><div class="bz dy l di"><div class="lj lk l"/></div></figure></div><div class="ab cl jp jq gp jr" role="separator"><span class="js bw bk jt ju jv"/><span class="js bw bk jt ju jv"/><span class="js bw bk jt ju"/></div><div class="hb hc hd he hf"><blockquote class="ll lm ln"><p id="0949" class="iq ir lo is b it iu iv iw ix iy iz ja lp jc jd je lq jg jh ji lr jk jl jm jn hb bi translated">async/await 是 JS 承诺的语法糖。它们帮助我们编写类似同步的语法来处理异步代码。</p></blockquote></div><div class="ab cl jp jq gp jr" role="separator"><span class="js bw bk jt ju jv"/><span class="js bw bk jt ju jv"/><span class="js bw bk jt ju"/></div><div class="hb hc hd he hf"><p id="d1b8" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如果你觉得这篇文章有帮助，一定要鼓掌分享。你可以在这里找到我所有的文章<a class="ae jo" href="http://abdu-manaz.medium.com/" rel="noopener">，包括这个系列的其他部分。如果你有任何建议/意见，请告诉我。请务必关注我，以免错过任何文章。</a></p></div></div>    
</body>
</html>