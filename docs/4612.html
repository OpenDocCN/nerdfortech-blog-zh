<html>
<head>
<title>Coroutines (Part II) — Job, SupervisorJob, Launch and Async</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">协同程序(第二部分)—作业、管理作业、启动和异步</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/coroutines-part-ii-job-supervisorjob-launch-and-async-578d3486fa0c?source=collection_archive---------5-----------------------#2021-07-29">https://medium.com/nerd-for-tech/coroutines-part-ii-job-supervisorjob-launch-and-async-578d3486fa0c?source=collection_archive---------5-----------------------#2021-07-29</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="c6b1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这是关于协程的3部分系列的第2篇文章。如果你没有读过第一篇文章，我强烈建议你读一读</p><div class="jd je ez fb jf jg"><a href="https://victorbrandalise.com/coroutines-part-i-grasping-the-fundamentals/" rel="noopener  ugc nofollow" target="_blank"><div class="jh ab dw"><div class="ji ab jj cl cj jk"><h2 class="bd hj fi z dy jl ea eb jm ed ef hh bi translated">协程(第一部分)-掌握基本原则</h2><div class="jn l"><h3 class="bd b fi z dy jl ea eb jm ed ef dx translated">你读了20篇文章，看了6个视频，问了你的大学，不知何故你还是不明白…</h3></div><div class="jo l"><p class="bd b fp z dy jl ea eb jm ed ef dx translated">victorbrandalise.com</p></div></div><div class="jp l"><div class="jq l jr js jt jp ju jv jg"/></div></div></a></div><p id="93b5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在学习了基础知识之后，我们终于可以开始在代码中使用协程了。我们将从学习<code class="du jw jx jy jz b">Job</code>和<code class="du jw jx jy jz b">SupervisorJob</code>开始，然后继续用<code class="du jw jx jy jz b">launch</code>和<code class="du jw jx jy jz b">async</code>创建协程。</p><figure class="kb kc kd ke fd kf er es paragraph-image"><div role="button" tabindex="0" class="kg kh di ki bf kj"><div class="er es ka"><img src="../Images/19a6f5c8a4f02ca4e5f4c14be9df9c78.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NHL76lF6VUiDh9rV3EbFuw.jpeg"/></div></div><figcaption class="kl km et er es kn ko bd b be z dx translated"><a class="ae kp" href="https://unsplash.com/@dominik_photography?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">张秀坤·瓦尼</a>在<a class="ae kp" href="https://unsplash.com/s/photos/mine?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的封面照片</figcaption></figure><h1 id="578d" class="kq kr hi bd ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln bi translated">职位</h1><p id="31b3" class="pw-post-body-paragraph if ig hi ih b ii lo ik il im lp io ip iq lq is it iu lr iw ix iy ls ja jb jc hb bi translated">对于创建的每个协程，都会返回一个作业实例来唯一标识该协程，并允许您管理其生命周期。如果有必要，您还可以手动创建作业，例如，您可能希望将它交给一个<code class="du jw jx jy jz b">CoroutineContext</code>来管理上下文的生命周期。</p><figure class="kb kc kd ke fd kf"><div class="bz dy l di"><div class="lt lu l"/></div></figure><blockquote class="lv lw lx"><p id="3ee6" class="if ig ly ih b ii ij ik il im in io ip lz ir is it ma iv iw ix mb iz ja jb jc hb bi translated">从概念上来说，一个任务是一个可以取消的东西，它有一个生命周期，最终会完成。[…]抛出CancellationException的协程被视为正常取消。如果取消原因是不同的异常类型，则作业被视为失败。</p><p id="0ec4" class="if ig ly ih b ii ij ik il im in io ip lz ir is it ma iv iw ix mb iz ja jb jc hb bi translated"><a class="ae kp" href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-job/" rel="noopener ugc nofollow" target="_blank"> <em class="hi">科特林文档</em> </a></p></blockquote><p id="9b19" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">作业具有一组定义状态:新、活动、完成、已完成、取消和已取消。</p><p id="4299" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们不能访问状态本身，但是我们可以访问作业的属性:isActive、isCancelled和isCompleted。</p><figure class="kb kc kd ke fd kf er es paragraph-image"><div role="button" tabindex="0" class="kg kh di ki bf kj"><div class="er es mc"><img src="../Images/01b69dfcef0278fb485df98ee7494dc2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NxJadstDEMvBPHZ1Yy6D5A.png"/></div></div><figcaption class="kl km et er es kn ko bd b be z dx translated"><a class="ae kp" href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-job/" rel="noopener ugc nofollow" target="_blank">https://kot Lin . github . io/kot linx . coroutines/kot linx-coroutines-core/kot linx . coroutines/-job/</a></figcaption></figure><p id="0d15" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果你传入一个特定的<code class="du jw jx jy jz b">Job</code>或<code class="du jw jx jy jz b">SupervisorJob</code>作为上下文，比如在<code class="du jw jx jy jz b">launch(SupervisorJob())</code>中，它不会导致工作在那个<code class="du jw jx jy jz b">Job</code>中运行，这只是意味着它将使用那个<code class="du jw jx jy jz b">Job</code>作为它将构建的<code class="du jw jx jy jz b">Job</code>的父作业。为什么？因为<code class="du jw jx jy jz b">AbstractCoroutine</code>实现了<code class="du jw jx jy jz b">Job</code>并且所有协程都扩展了<code class="du jw jx jy jz b">AbstractCoroutine</code>。</p><figure class="kb kc kd ke fd kf"><div class="bz dy l di"><div class="lt lu l"/></div></figure><figure class="kb kc kd ke fd kf er es paragraph-image"><div class="er es md"><img src="../Images/50cc9178d56b5f8fe9bf355e55702b81.png" data-original-src="https://miro.medium.com/v2/resize:fit:1332/format:webp/0*dqneQwKlPbGPTxmO.png"/></div></figure><h1 id="4501" class="kq kr hi bd ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln bi translated">父子层次结构</h1><ul class=""><li id="f35a" class="me mf hi ih b ii lo im lp iq mg iu mh iy mi jc mj mk ml mm bi translated">当父作业被取消时，子作业也被取消；</li><li id="f2ae" class="me mf hi ih b ii mn im mo iq mp iu mq iy mr jc mj mk ml mm bi translated">如果我们取消孩子的工作，父母的工作继续；</li><li id="7168" class="me mf hi ih b ii mn im mo iq mp iu mq iy mr jc mj mk ml mm bi translated">当父作业抛出异常时，子作业也被取消；</li><li id="7a1d" class="me mf hi ih b ii mn im mo iq mp iu mq iy mr jc mj mk ml mm bi translated">当子作业抛出异常时，父作业可能被取消；</li><li id="229c" class="me mf hi ih b ii mn im mo iq mp iu mq iy mr jc mj mk ml mm bi translated">在所有子进程完成之前，父进程无法完成；</li></ul><figure class="kb kc kd ke fd kf"><div class="bz dy l di"><div class="lt lu l"/></div></figure><h1 id="b158" class="kq kr hi bd ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln bi translated">主管工作</h1><p id="833b" class="pw-post-body-paragraph if ig hi ih b ii lo ik il im lp io ip iq lq is it iu lr iw ix iy ls ja jb jc hb bi translated">它类似于常规作业，唯一的例外是其子作业可以彼此独立地失败。</p><p id="5ba4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">孩子的失败或取消不会导致主管的工作失败或影响其他孩子，因此主管可以创建一个独特的策略来处理其孩子的失败。</p><p id="9ce6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">一个<code class="du jw jx jy jz b">SupervisorJob</code>只有当它是作用域的一部分时才起作用:要么使用<code class="du jw jx jy jz b">supervisorScope</code>创建，要么使用<code class="du jw jx jy jz b">CoroutineScope(SupervisorJob())</code>创建。将一个<code class="du jw jx jy jz b">SupervisorJob</code>作为协程构建器的一个参数传递，并不会达到您想要的取消效果。</p><p id="538a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">下面是他们使用<code class="du jw jx jy jz b">launch</code>并排显示的行为:</p><figure class="kb kc kd ke fd kf"><div class="bz dy l di"><div class="lt lu l"/></div></figure><p id="2fb4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如您所见，通过使用<code class="du jw jx jy jz b">SupervisorJob</code>，一个孩子的失败不会影响到另一个孩子。</p><p id="30e4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">下面是他们使用<code class="du jw jx jy jz b">async</code>的行为:</p><figure class="kb kc kd ke fd kf"><div class="bz dy l di"><div class="lt lu l"/></div></figure><p id="48eb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这可能不是您所期望的，发生的原因是<code class="du jw jx jy jz b">launch</code>传播异常，而<code class="du jw jx jy jz b">await</code>抛出异常。我们会在第三部分深入探讨。</p><h1 id="4f20" class="kq kr hi bd ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln bi translated">协同程序构建器</h1><p id="fdd2" class="pw-post-body-paragraph if ig hi ih b ii lo ik il im lp io ip iq lq is it iu lr iw ix iy ls ja jb jc hb bi translated">协程生成器是简单的函数，它生成新的协程来执行给定的挂起函数。它们不同于典型的非挂起函数，因为它们不挂起自己，因此充当正常世界和挂起世界之间的链接。</p><p id="dc6e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在runBlocking上下文中，调用层次结构中的给定挂起函数及其子级将有效地阻塞当前线程，直到它完成执行。这通常在main()函数中使用，以提供一种顶级协同程序，在这样做和测试时保持JVM活动，因为您希望测试执行阻塞，直到所有工作完成。</p><p id="55bc" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">启动协程有两种主要方式，它们有不同的用途:</p><h1 id="dd31" class="kq kr hi bd ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln bi translated">发动</h1><figure class="kb kc kd ke fd kf"><div class="bz dy l di"><div class="lt lu l"/></div></figure><p id="6b8c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">launch builder将启动一个新的协程，但不会等待它完成，这意味着它不会将结果返回给调用者。充当普通函数和协程之间的链接。</p><p id="87ff" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">协程上下文继承自<code class="du jw jx jy jz b">CoroutineScope</code>，但是您可以通过传递另一个上下文作为<code class="du jw jx jy jz b">context</code>参数来指定更多的元素。记住<code class="du jw jx jy jz b">CoroutineContext</code>永远不会被覆盖，而是与现有的相结合。</p><p id="ee97" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">默认情况下，协程被立即调度执行。您可以通过指定<code class="du jw jx jy jz b">start</code>参数来改变这一点。你可以在这里阅读允许值<a class="ae kp" href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-coroutine-start/index.html" rel="noopener ugc nofollow" target="_blank">。</a></p><p id="6f28" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果你看一下返回类型，你可以看到它是一个<code class="du jw jx jy jz b">Job</code>。这意味着您可以通过与该作业交互来控制协程的生命周期。调用<code class="du jw jx jy jz b">job.cancel()</code>就可以轻松取消。</p><p id="5beb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">正如我们前面看到的，<code class="du jw jx jy jz b">launch</code>在视图模型上被大量使用，以创建从非挂起代码到挂起代码的桥梁。</p><p id="6cdc" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我看到人们一开始做错的一件事是在发射块周围增加一个try catch。即使抛出异常，catch也不会运行。</p><figure class="kb kc kd ke fd kf"><div class="bz dy l di"><div class="lt lu l"/></div></figure><p id="1aa2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">你需要记住，当你从一个非挂起函数中启动一个新的协程时，你基本上是在改变你代码中的世界。启动协程的代码和协程现在分开运行。</p><p id="e25a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">要解决这个问题，您只需将try catch块移动到launch块中，或者在您的作用域上下文中添加一个<code class="du jw jx jy jz b">CoroutineExceptionHandler</code>。</p><figure class="kb kc kd ke fd kf"><div class="bz dy l di"><div class="lt lu l"/></div></figure><h1 id="4455" class="kq kr hi bd ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln bi translated">异步ˌ非同步(asynchronous)</h1><figure class="kb kc kd ke fd kf"><div class="bz dy l di"><div class="lt lu l"/></div></figure><p id="f595" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">async builder将启动一个新的协程，它允许您通过调用<code class="du jw jx jy jz b">await</code>获得返回值。</p><p id="8802" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我说的关于<code class="du jw jx jy jz b">context</code>和<code class="du jw jx jy jz b">start</code>参数的同样的事情在这里也适用。</p><p id="7024" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><code class="du jw jx jy jz b">await</code>在不阻塞线程的情况下等待块完成，并在延迟操作完成时恢复，返回结果或引发相应的异常。你可能认为用一个try catch包装<code class="du jw jx jy jz b">await</code>可以工作，它确实有点工作，但是不像你预期的那样。你认为下面的代码会输出什么？</p><figure class="kb kc kd ke fd kf"><div class="bz dy l di"><div class="lt lu l"/></div></figure><p id="e820" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">输出:</p><pre class="kb kc kd ke fd ms jz mt mu aw mv bi"><span id="4a15" class="mw kr hi jz b fi mx my l mz na">Caught exception Exception in thread "DefaultDispatcher-worker-1"</span></pre><p id="a011" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">第一次看的时候，这看起来很混乱，下面是正在发生的事情:</p><ol class=""><li id="f271" class="me mf hi ih b ii ij im in iq nb iu nc iy nd jc ne mk ml mm bi translated">由<code class="du jw jx jy jz b">async</code>启动的协程抛出异常</li><li id="ab07" class="me mf hi ih b ii mn im mo iq mp iu mq iy mr jc ne mk ml mm bi translated">异常被捕获，并打印“捕获的异常”</li><li id="013b" class="me mf hi ih b ii mn im mo iq mp iu mq iy mr jc ne mk ml mm bi translated">协程将异常处理委托给它的父进程</li><li id="5036" class="me mf hi ih b ii mn im mo iq mp iu mq iy mr jc ne mk ml mm bi translated">父级被取消，因为它没有异常处理程序</li></ol><p id="d38c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">那么，如何正确处理异常呢？您需要用<code class="du jw jx jy jz b">supervisorScope</code>包装<code class="du jw jx jy jz b">await</code>调用，以防止异常向上传播。</p><figure class="kb kc kd ke fd kf"><div class="bz dy l di"><div class="lt lu l"/></div></figure><p id="c4da" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">当我们更深入地研究异常处理时，您将理解为什么需要这样做。现在让我们尝试另一件事，如果我们在根作用域上使用<code class="du jw jx jy jz b">SupervisorJob</code>，会发生什么？</p><figure class="kb kc kd ke fd kf"><div class="bz dy l di"><div class="lt lu l"/></div></figure><p id="04c4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">输出:</p><pre class="kb kc kd ke fd ms jz mt mu aw mv bi"><span id="df72" class="mw kr hi jz b fi mx my l mz na">Caught exception Exception in thread "DefaultDispatcher-worker-1" java.lang.Exception <br/>Caught exception Exception in thread "DefaultDispatcher-worker-2" java.lang.Exception</span></pre><p id="9196" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">除了一个例外，它与普通工作非常相似</p><ol class=""><li id="6ee0" class="me mf hi ih b ii ij im in iq nb iu nc iy nd jc ne mk ml mm bi translated"><code class="du jw jx jy jz b">async</code>启动的协程抛出异常</li><li id="3e12" class="me mf hi ih b ii mn im mo iq mp iu mq iy mr jc ne mk ml mm bi translated">异常被捕获，并打印“捕获的异常”</li><li id="4112" class="me mf hi ih b ii mn im mo iq mp iu mq iy mr jc ne mk ml mm bi translated">协程将异常处理委托给它的父进程</li><li id="c71e" class="me mf hi ih b ii mn im mo iq mp iu mq iy mr jc ne mk ml mm bi translated">父代不会因为是<code class="du jw jx jy jz b">SupervisorJob</code>而被取消，只有子代会被取消</li></ol><h1 id="2bf4" class="kq kr hi bd ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln bi translated">他们是不同的，但没有那么多</h1><p id="73a0" class="pw-post-body-paragraph if ig hi ih b ii lo ik il im lp io ip iq lq is it iu lr iw ix iy ls ja jb jc hb bi translated"><code class="du jw jx jy jz b">launch</code>和嵌套<code class="du jw jx jy jz b">async</code>构建器都不会重新抛出发生在它们内部的异常。相反，它们在协程层次结构中向上传播。正如我们之前看到的，子协程总是将异常处理委托给它的父协程。</p><h1 id="638b" class="kq kr hi bd ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln bi translated">验光仪</h1><p id="d3b7" class="pw-post-body-paragraph if ig hi ih b ii lo ik il im lp io ip iq lq is it iu lr iw ix iy ls ja jb jc hb bi translated"><code class="du jw jx jy jz b">CoroutineScope</code>大写的C和<code class="du jw jx jy jz b"><a class="ae kp" href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/coroutine-scope.html" rel="noopener ugc nofollow" target="_blank">coroutineScope</a></code>小写的C是两回事。这里我们将讨论一个函数调用。</p><figure class="kb kc kd ke fd kf"><div class="bz dy l di"><div class="lt lu l"/></div></figure><p id="e352" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><code class="du jw jx jy jz b">coroutineScope</code>创建一个建立新<code class="du jw jx jy jz b">CoroutineScope</code>的边界。新范围从外部范围继承了它的<code class="du jw jx jy jz b">coroutineContext</code>,但是覆盖了上下文的作业。它还导致当前协同程序挂起，直到所有子协同程序都完成了它们的执行。</p><p id="4707" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">当我们需要在一个挂起函数中以结构化的方式启动新的协同程序，而不需要访问外部作用域时，这非常有用。真正酷的是<code class="du jw jx jy jz b">coroutineScope</code>将创建一个子范围。因此，如果父作用域被取消，它将把取消传递给所有新的协程。</p><p id="3f75" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">例如，下面的代码不起作用，因为<code class="du jw jx jy jz b">async</code>和<code class="du jw jx jy jz b">launch</code>是<code class="du jw jx jy jz b">CoroutineScope</code>的扩展</p><figure class="kb kc kd ke fd kf"><div class="bz dy l di"><div class="lt lu l"/></div></figure><p id="9135" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">你如何解决这个问题？您可以使用<code class="du jw jx jy jz b">coroutineScope</code>在一个挂起函数中创建一个作用域，并且仍然保持结构化并发。</p><figure class="kb kc kd ke fd kf"><div class="bz dy l di"><div class="lt lu l"/></div></figure><blockquote class="lv lw lx"><p id="09ce" class="if ig ly ih b ii ij ik il im in io ip lz ir is it ma iv iw ix mb iz ja jb jc hb bi translated"><em class="hi">该功能是为工作的并行分解而设计的。当这个作用域中的任何子协程失败时，这个作用域也失败，所有其余的子协程都被取消。当您有许多异步块，如果其中任何一个失败，就必须取消这些块时，这是非常有用的。</em></p><p id="0fa2" class="if ig ly ih b ii ij ik il im in io ip lz ir is it ma iv iw ix mb iz ja jb jc hb bi translated"><a class="ae kp" href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/coroutine-scope.html" rel="noopener ugc nofollow" target="_blank"> <em class="hi">科特林文档</em> </a></p></blockquote><p id="3e2c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">记住，如果不使用<code class="du jw jx jy jz b">SupervisorJob</code>，异常也会取消父类的作用域。</p><h1 id="80f9" class="kq kr hi bd ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln bi translated">监督镜</h1><p id="a27b" class="pw-post-body-paragraph if ig hi ih b ii lo ik il im lp io ip iq lq is it iu lr iw ix iy ls ja jb jc hb bi translated"><code class="du jw jx jy jz b">supervisorScope</code>的行为定义为:一个子节点的失败不会导致作用域失败，也不会影响它的其他子节点。</p><figure class="kb kc kd ke fd kf"><div class="bz dy l di"><div class="lt lu l"/></div></figure><p id="b199" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">那是什么意思？</p><figure class="kb kc kd ke fd kf"><div class="bz dy l di"><div class="lt lu l"/></div></figure><p id="8039" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这段代码输出了什么？通过查看定义，您可能认为它不输出任何内容，因为子节点的失败不应该导致其作用域失败。</p><p id="a391" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">以下是输出结果:</p><pre class="kb kc kd ke fd ms jz mt mu aw mv bi"><span id="e0aa" class="mw kr hi jz b fi mx my l mz na">Exception in thread "main" java.lang.Exception <br/>Exception in thread "main" java.lang.Exception</span></pre><p id="a9f3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这很有趣，异常被向上传播，作用域被取消。尽管听起来您可以随心所欲地破坏子协程，但这并不完全正确。异常仍然会向上传播，如果父<code class="du jw jx jy jz b">supervisorScope</code>没有一些错误处理机制，它仍然会被取消。</p><p id="7786" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">那么，我们怎么解决呢？我们可以简单地给<code class="du jw jx jy jz b">CoroutineContext</code>加上一个<code class="du jw jx jy jz b">CoroutineExceptionHandler</code>。</p><figure class="kb kc kd ke fd kf"><div class="bz dy l di"><div class="lt lu l"/></div></figure><p id="b5f4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">关于<code class="du jw jx jy jz b">supervisorScope</code>的另一个巧妙的特性是在它内部创建的协程成为顶级协程，允许我们在其中安装一个<code class="du jw jx jy jz b">CoroutineExceptionHandler</code>。</p><figure class="kb kc kd ke fd kf"><div class="bz dy l di"><div class="lt lu l"/></div></figure><p id="437f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这段代码有预期的输出，但没有输出任何内容。</p></div><div class="ab cl nf ng gp nh" role="separator"><span class="ni bw bk nj nk nl"/><span class="ni bw bk nj nk nl"/><span class="ni bw bk nj nk"/></div><div class="hb hc hd he hf"><p id="a781" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在这篇文章中，我们了解了<code class="du jw jx jy jz b">Job</code>和<code class="du jw jx jy jz b">SupervisorJob</code>，最重要的是它们是如何工作的。我们还看到了<code class="du jw jx jy jz b">launch</code>和<code class="du jw jx jy jz b">async</code>可以用来创建协程，并了解了它们之间的区别。既然我们已经了解了协程的基本知识，我们可以继续学习更高级的概念，请继续关注第三部分。</p><p id="98a4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果您有任何疑问，请随时联系我。下一篇文章再见😉</p><div class="jd je ez fb jf jg"><a href="https://victorbrandalise.com/coroutines-part-iii-structured-concurrency-and-cancellation/" rel="noopener  ugc nofollow" target="_blank"><div class="jh ab dw"><div class="ji ab jj cl cj jk"><h2 class="bd hj fi z dy jl ea eb jm ed ef hh bi translated">协同程序(第三部分)——结构化并发和取消</h2><div class="jn l"><h3 class="bd b fi z dy jl ea eb jm ed ef dx translated">这是关于协程的3篇系列文章的第3篇，也是最后一篇。如果你没有看过前两篇文章，我…</h3></div><div class="jo l"><p class="bd b fp z dy jl ea eb jm ed ef dx translated">victorbrandalise.com</p></div></div><div class="jp l"><div class="nm l jr js jt jp ju jv jg"/></div></div></a></div><h1 id="d646" class="kq kr hi bd ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln bi translated">资源</h1><p id="a69f" class="pw-post-body-paragraph if ig hi ih b ii lo ik il im lp io ip iq lq is it iu lr iw ix iy ls ja jb jc hb bi translated">你正确地处理了Kotlin协程中的异常吗？</p><p id="a45f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><a class="ae kp" href="https://marco-cattaneo.medium.com/kotlin-coroutine-job-lifecycle-c1166039d906" rel="noopener"> Kotlin协程作业生命周期</a></p></div><div class="ab cl nf ng gp nh" role="separator"><span class="ni bw bk nj nk nl"/><span class="ni bw bk nj nk nl"/><span class="ni bw bk nj nk"/></div><div class="hb hc hd he hf"><p id="c473" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="ly">原载于2021年7月29日</em><a class="ae kp" href="https://victorbrandalise.com/coroutines-part-ii-job-supervisorjob-launch-and-async/" rel="noopener ugc nofollow" target="_blank"><em class="ly">【https://victorbrandalise.com】</em></a><em class="ly">。</em></p></div></div>    
</body>
</html>