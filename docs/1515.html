<html>
<head>
<title>Understanding Objects and Prototypes in Javascript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">理解 Javascript 中的对象和原型</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/understanding-objects-and-prototypes-in-javascript-d847baa50f9a?source=collection_archive---------6-----------------------#2021-03-23">https://medium.com/nerd-for-tech/understanding-objects-and-prototypes-in-javascript-d847baa50f9a?source=collection_archive---------6-----------------------#2021-03-23</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="c920" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">JavaScript 是一种基于原型的基于对象的语言，而不是基于类的。对象本质上不是基于类的，但是基于构造函数、原型对象和方法的公共模式来定义类抽象通常是很方便的。<strong class="ih hj">内置对象</strong>本身通过使用<strong class="ih hj">原型</strong>属性遵循这样一种类模式。在这篇文章中，我们将研究内置对象和原型。</p></div><div class="ab cl je jf gp jg" role="separator"><span class="jh bw bk ji jj jk"/><span class="jh bw bk ji jj jk"/><span class="jh bw bk ji jj"/></div><div class="hb hc hd he hf"><p id="c726" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">内置对象:</strong></p><p id="fb03" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">javascript 中有几个内置对象扩展了语言的灵活性。许多内置对象是函数:它们可以通过参数调用。此外，其中一些是构造函数:它们是打算与<code class="du jl jm jn jo b"><strong class="ih hj">new</strong></code>操作符一起使用的函数。</p><ul class=""><li id="f51e" class="jp jq hi ih b ii ij im in iq jr iu js iy jt jc ju jv jw jx bi translated"><code class="du jl jm jn jo b">String</code></li><li id="00fb" class="jp jq hi ih b ii jy im jz iq ka iu kb iy kc jc ju jv jw jx bi translated"><code class="du jl jm jn jo b">Number</code></li><li id="b190" class="jp jq hi ih b ii jy im jz iq ka iu kb iy kc jc ju jv jw jx bi translated"><code class="du jl jm jn jo b">Boolean</code></li><li id="8e06" class="jp jq hi ih b ii jy im jz iq ka iu kb iy kc jc ju jv jw jx bi translated"><code class="du jl jm jn jo b">Object</code></li><li id="880f" class="jp jq hi ih b ii jy im jz iq ka iu kb iy kc jc ju jv jw jx bi translated"><code class="du jl jm jn jo b">Function</code></li><li id="c679" class="jp jq hi ih b ii jy im jz iq ka iu kb iy kc jc ju jv jw jx bi translated"><code class="du jl jm jn jo b">Array</code></li><li id="839a" class="jp jq hi ih b ii jy im jz iq ka iu kb iy kc jc ju jv jw jx bi translated"><code class="du jl jm jn jo b">Date</code></li><li id="1989" class="jp jq hi ih b ii jy im jz iq ka iu kb iy kc jc ju jv jw jx bi translated"><code class="du jl jm jn jo b">RegExp</code></li><li id="85f2" class="jp jq hi ih b ii jy im jz iq ka iu kb iy kc jc ju jv jw jx bi translated"><code class="du jl jm jn jo b">Error</code></li></ul><p id="7c34" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">内置对象是“功能”？</strong></p><ul class=""><li id="c565" class="jp jq hi ih b ii ij im in iq jr iu js iy jt jc ju jv jw jx bi translated">如果内置对象有一个[[Call]]内部属性，那么内置对象就是一个<code class="du jl jm jn jo b"><strong class="ih hj">"Function"</strong></code> <strong class="ih hj">。</strong></li><li id="872f" class="jp jq hi ih b ii jy im jz iq ka iu kb iy kc jc ju jv jw jx bi translated">如果内置对象有一个[[Constructor]]内部属性，那么内置对象就是一个<code class="du jl jm jn jo b"><strong class="ih hj">"Constructor Function"</strong></code> <strong class="ih hj">。</strong></li><li id="2700" class="jp jq hi ih b ii jy im jz iq ka iu kb iy kc jc ju jv jw jx bi translated">如果内置对象没有[[Call]]内部属性，则内置对象是一个<code class="du jl jm jn jo b"><strong class="ih hj">"Object"</strong></code> <strong class="ih hj">。</strong></li></ul><p id="41e4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">上面列出的所有内置对象都是函数和构造函数。它们可以通过参数调用，也可以通过使用<strong class="ih hj"> new </strong>关键字调用。</p><p id="4d45" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">内置对象长什么样？</strong></p><p id="35c5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们考虑字符串对象。</p><ol class=""><li id="14cb" class="jp jq hi ih b ii ij im in iq jr iu js iy jt jc kd jv jw jx bi translated">String(): <br/>它执行类型转换。</li><li id="330e" class="jp jq hi ih b ii jy im jz iq ka iu kb iy kc jc kd jv jw jx bi translated">String.constructor: <br/>当<code class="du jl jm jn jo b"><strong class="ih hj">String</strong></code>作为<code class="du jl jm jn jo b"><strong class="ih hj">new</strong></code>表达式的一部分被调用时，它就是一个构造函数:它初始化新创建的对象。</li><li id="9652" class="jp jq hi ih b ii jy im jz iq ka iu kb iy kc jc kd jv jw jx bi translated">String . prototype:<br/><code class="du jl jm jn jo b"><strong class="ih hj">String.prototype</strong></code>的初始值是标准的内置字符串原型对象。</li><li id="0027" class="jp jq hi ih b ii jy im jz iq ka iu kb iy kc jc kd jv jw jx bi translated">新创建的 String 对象:<br/>新创建的 String 对象本身就是一个值为空字符串的 String 对象。String prototype 对象的[[Prototype]]内部属性的值是标准内置对象 Prototype 对象。</li></ol><p id="bfe5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="jd">字符串对象:</em></p><figure class="kf kg kh ki fd kj er es paragraph-image"><div role="button" tabindex="0" class="kk kl di km bf kn"><div class="er es ke"><img src="../Images/657452f5d7bea965f273f0aa69d9e645.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*aQNAOMSROQgOdqn-yXOWgA.png"/></div></div></figure><p id="58d2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="jd">数组对象:</em></p><figure class="kf kg kh ki fd kj er es paragraph-image"><div role="button" tabindex="0" class="kk kl di km bf kn"><div class="er es kq"><img src="../Images/b810cc33ad9a5cf194328b6d06b71fce.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RzdcQ5HAmercoG8EhBAYCw.png"/></div></div></figure><p id="1ed2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="jd">功能对象:</em></p><figure class="kf kg kh ki fd kj er es paragraph-image"><div role="button" tabindex="0" class="kk kl di km bf kn"><div class="er es kr"><img src="../Images/e31efe34cd3392e684373aeb76405b65.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*P0nCa8ccR2pNtC4VcFVotQ.png"/></div></div></figure><p id="4ee3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如上例，所有内置对象都通过原型对象相互连接。</p></div><div class="ab cl je jf gp jg" role="separator"><span class="jh bw bk ji jj jk"/><span class="jh bw bk ji jj jk"/><span class="jh bw bk ji jj"/></div><div class="hb hc hd he hf"><p id="aa2e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">原型</strong>:</p><p id="e2be" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">每个内置函数(<em class="jd">对象、函数、数组等等</em>)都提供了一个匿名对象，可以通过内置函数的<code class="du jl jm jn jo b">prototype</code>属性引用。<code class="du jl jm jn jo b">Object.prototype</code>对象有很多方法和<a class="ae ks" href="https://www.javascripttutorial.net/javascript-object-properties/" rel="noopener ugc nofollow" target="_blank">属性</a>如<code class="du jl jm jn jo b">toString()</code>和<code class="du jl jm jn jo b">valueOf()</code>。除此之外，它还包含引用了<code class="du jl jm jn jo b">Object built-in function</code>的<code class="du jl jm jn jo b">constructor</code>。<br/> <em class="jd">我们假设圆代表一个函数，正方形代表一个物体。下图说明了</em> <code class="du jl jm jn jo b"><em class="jd">Object()</em></code> <em class="jd">函数和</em> <code class="du jl jm jn jo b"><em class="jd">Object.prototype</em></code> <em class="jd">对象之间的关系:</em></p><figure class="kf kg kh ki fd kj er es paragraph-image"><div class="er es kt"><img src="../Images/12ac77bd424035da84ad94eaa90af04d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1308/format:webp/1*S2ktmXcEMt6BVOXNagiQiw.png"/></div></figure><pre class="kf kg kh ki fd ku jo kv kw aw kx bi"><span id="d26e" class="ky kz hi jo b fi la lb l lc ld">Object.prototype.constructor = Object</span></pre></div><div class="ab cl je jf gp jg" role="separator"><span class="jh bw bk ji jj jk"/><span class="jh bw bk ji jj jk"/><span class="jh bw bk ji jj"/></div><div class="hb hc hd he hf"><p id="e8d6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">定义名为 Foo 的新函数:</strong></p><p id="7703" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们定义一个名为 Foo 的构造函数。它看起来和物体一样。因为<strong class="ih hj">函数</strong>和<strong class="ih hj">对象</strong>都是内置函数，它们都有<strong class="ih hj">原型</strong>对象。</p><pre class="kf kg kh ki fd ku jo kv kw aw kx bi"><span id="7768" class="ky kz hi jo b fi la lb l lc ld">function Foo(name) {<br/>   this.name = name;<br/>}</span></pre><figure class="kf kg kh ki fd kj er es paragraph-image"><div class="er es le"><img src="../Images/42fbd3ce2d1e941943b74e4072bbe03b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1182/format:webp/1*ZB90iO5NYoJVCvRCerdqVg.png"/></div></figure><p id="095b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">此外，JavaScript 通过<code class="du jl jm jn jo b">[[Prototype]]</code>将<code class="du jl jm jn jo b">Foo.prototype</code>对象链接到<code class="du jl jm jn jo b">Object.prototype</code>对象，这被称为<em class="jd">原型链</em>。</p><pre class="kf kg kh ki fd ku jo kv kw aw kx bi"><span id="22ab" class="ky kz hi jo b fi la lb l lc ld">Foo.prototype.__proto__ === Object.prototype // true</span></pre><figure class="kf kg kh ki fd kj er es paragraph-image"><div role="button" tabindex="0" class="kk kl di km bf kn"><div class="er es lf"><img src="../Images/cb4dce6207608f97cb0112cec4b80b62.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tq2ZOlKvfXk1uJAh8I3wUQ.png"/></div></div></figure><p id="5ab0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">在 prototype 对象中定义一个方法，并从 Foo()创建一个新实例:</strong></p><pre class="kf kg kh ki fd ku jo kv kw aw kx bi"><span id="49d6" class="ky kz hi jo b fi la lb l lc ld">Foo.prototype.getName = function() {<br/> return this.name; <br/>}<br/>// create an instance of Foo constructor function<br/>let foo1 = new Foo(‘John’);</span></pre><p id="a27d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">新实例通过<code class="du jl jm jn jo b">__proto__</code>连接到 Foo 构造函数的原型对象，读作<em class="jd"> dunder proto。</em></p><pre class="kf kg kh ki fd ku jo kv kw aw kx bi"><span id="bad3" class="ky kz hi jo b fi la lb l lc ld"><em class="jd">foo1.__proto__ === Foo.prototype // true</em></span></pre><figure class="kf kg kh ki fd kj er es paragraph-image"><div role="button" tabindex="0" class="kk kl di km bf kn"><div class="er es lf"><img src="../Images/8286092f02c553045f3a432d1667d95d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yDrEm-wwTt5D1sPYyvKUaA.png"/></div></div></figure><p id="012c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果我们想通过新创建的对象<strong class="ih hj"> foo1 </strong>访问<strong class="ih hj"> getName </strong>方法。它将遵循以下步骤。<br/> 1。foo1 检查自身的<strong class="ih hj"> getName </strong>方法。<br/> 2。如果它不存在于<strong class="ih hj"> foo1 </strong>对象中，它将要求<strong class="ih hj"> Foo.prototype. <br/> 3。</strong>如果在<strong class="ih hj"> Foo.prototype </strong>对象中不存在，它会要求<strong class="ih hj">foo . prototype . _ _ proto _ _(object . prototype)</strong></p><figure class="kf kg kh ki fd kj er es paragraph-image"><div class="er es lg"><img src="../Images/82603de28b5475a7c0ca031e318b6904.png" data-original-src="https://miro.medium.com/v2/resize:fit:862/format:webp/1*Wy648vtohzdO5VB-SK1rVA.png"/></div></figure><p id="e38d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们创建另一个对象并为这个对象定义一个方法。</p><pre class="kf kg kh ki fd ku jo kv kw aw kx bi"><span id="da54" class="ky kz hi jo b fi la lb l lc ld">var foo2= new Foo('');<br/>foo2.getMessage = function () { <br/>  return “Hello!”; <br/>};</span></pre><figure class="kf kg kh ki fd kj er es paragraph-image"><div role="button" tabindex="0" class="kk kl di km bf kn"><div class="er es lf"><img src="../Images/1249d3f399171ad3fc56b2be287f41af.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*z1iE3yxycxANqCqe0jSvfg.png"/></div></div></figure><pre class="kf kg kh ki fd ku jo kv kw aw kx bi"><span id="fb88" class="ky kz hi jo b fi la lb l lc ld">foo2.getMessage(); // “Hello!”<br/>foo1.getMessage(); // getMessage is not defined</span></pre><p id="586e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> foo1 </strong>和<strong class="ih hj"> foo2 </strong>将遵循上述模式中描述的相同原型链。<code class="du jl jm jn jo b">getMessage</code>方法仅针对<strong class="ih hj"> foo2 </strong>指定。因为<code class="du jl jm jn jo b">foo2.getMessage</code>将返回一个结果。当<code class="du jl jm jn jo b">foo1.getMessage</code>方法运行时，会抛出错误，因为<strong class="ih hj"> foo1 </strong>会遍历所有的原型链，找不到任何<strong class="ih hj"> getMessage </strong>方法。</p><p id="2469" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">说明字符串内置对象:</strong></p><p id="2001" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们已经提到，许多内置对象是函数，如函数、对象、字符串、数组等。我们已经通过创建<strong class="ih hj"> Foo </strong>函数看到了<strong class="ih hj">内置的函数对象</strong>。其余的内置对象以同样的方式工作。为了深入理解，我们可以举一个例子说明字符串内置对象是如何工作的。</p><pre class="kf kg kh ki fd ku jo kv kw aw kx bi"><span id="324f" class="ky kz hi jo b fi la lb l lc ld">String.prototype.getMessage = function() {<br/> return "Hello"; <br/>}<br/>let str = new String();<br/>str.getMessage() // 'Hello';</span></pre><figure class="kf kg kh ki fd kj er es paragraph-image"><div role="button" tabindex="0" class="kk kl di km bf kn"><div class="er es lf"><img src="../Images/da2887cacbd669928dcc810115c5133b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PuWQkmH1BjXgzfllGoYg0w.png"/></div></div></figure><p id="e3d8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们已经讨论了对象、函数和字符串内置对象。我们还没有涉及的其他内置对象(数字、日期、正则表达式、错误、布尔值)也以同样的方式工作。</p><p id="2d80" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">希望这些例子能帮助你理解原型如何与内置对象一起在 js 中工作。每个内置对象本身都遵循这样一种类模式。这种类模式是通过原型对象呈现的。</p></div></div>    
</body>
</html>