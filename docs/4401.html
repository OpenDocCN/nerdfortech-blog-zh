<html>
<head>
<title>Constraints: Intro (Part I)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">约束条件:简介(第一部分)</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/constraints-introduction-part-i-5f6fb459704e?source=collection_archive---------19-----------------------#2021-07-19">https://medium.com/nerd-for-tech/constraints-introduction-part-i-5f6fb459704e?source=collection_archive---------19-----------------------#2021-07-19</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="75b9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在这一系列文章中，我们将考虑定位子视图的约束。考虑它们的一些属性和特性。</p><h1 id="445f" class="jd je hi bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">什么是约束？</h1><p id="896d" class="pw-post-body-paragraph if ig hi ih b ii kb ik il im kc io ip iq kd is it iu ke iw ix iy kf ja jb jc hb bi translated">简而言之，这是一种线性依赖:一种将一个元素的参考点锚定到另一个元素或其自身的方法。约束定位视图，它们定义线性方程组。为了不产生歧义，应该有一个解决方案。</p><p id="e77d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">每个约束可以由以下公式表示:</p><pre class="kg kh ki kj fd kk kl km kn aw ko bi"><span id="84fe" class="kp je hi kl b fi kq kr l ks kt"><strong class="kl hj">y {relation} a * x + b // for example y &gt;= a * x + b</strong></span></pre><p id="2a92" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">其中一个视图的y锚点(中心、前导、高度)，相对于另一个视图的适当锚点和{关系}可以是<strong class="ih hj"> =、&gt; =、或=&lt;= T3。约束的最佳表示可以通过<strong class="ih hj"> NSLayoutConstraint </strong> init(构造函数)方法来演示。让我们创建一些纵横比的依赖关系:</strong></p><figure class="kg kh ki kj fd kv er es paragraph-image"><div class="er es ku"><img src="../Images/716f400d4304e73d8e2e4657358a2fdc.png" data-original-src="https://miro.medium.com/v2/resize:fit:966/format:webp/1*jhAamm9GAix5-_FQ9kHeAA.png"/></div><figcaption class="ky kz et er es la lb bd b be z dx translated">高度=宽度* 0.5 + 0.0</figcaption></figure><p id="30dd" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">要激活约束，只需将其'<strong class="ih hj"> isActive </strong>属性<strong class="ih hj"> </strong>或调用static<strong class="ih hj">nslayoutconstraint . activate</strong>方法。始终可以修改常量值，但修改优先级和乘数约束<strong class="ih hj">不应激活。</strong>否则你会得到运行时异常。</p><figure class="kg kh ki kj fd kv er es paragraph-image"><div class="er es lc"><img src="../Images/54a13532f7fd3a74aebc6a50835fa596.png" data-original-src="https://miro.medium.com/v2/resize:fit:1302/format:webp/1*0bRphg9_sxQFFkV-0SD3Sw.png"/></div><figcaption class="ky kz et er es la lb bd b be z dx translated">更改非活动约束中的优先级</figcaption></figure><p id="0c32" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果视图没有被添加到superview中，也会发生另一个异常&amp;您试图激活约束，即下面的断言将会失败:<strong class="ih hj">assert(</strong>aspectrationconstraint . is active = = camerabutton . superview！=零<strong class="ih hj"> ) </strong></p><p id="377a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">通常使用<strong class="ih hj"> PropertyAnimator </strong>或调用静态方法<strong class="ih hj">ui view . animate(with duration..</strong></p><pre class="kg kh ki kj fd kk kl km kn aw ko bi"><span id="773a" class="kp je hi kl b fi kq kr l ks kt"><strong class="kl hj"> let</strong> newValue: CGFloat = 200.0<br/> //UIViewPropertyAnimator<br/> UIView.animate(withDuration: 0.5, <br/>               delay: 0.1, <br/>               options:    .curveEaseInOut.union(.beginFromCurrentState)) {<br/>      constr?.constant = newValue<br/> } completion: { finished <strong class="kl hj">in </strong>//</span><span id="2066" class="kp je hi kl b fi ld kr l ks kt"> }</span></pre><h1 id="f90d" class="jd je hi bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">UIView内部:</h1><p id="732e" class="pw-post-body-paragraph if ig hi ih b ii kb ik il im kc io ip iq kd is it iu ke iw ix iy kf ja jb jc hb bi translated">每个视图应该有4个约束(记住<strong class="ih hj">帧</strong>)。2个x相关，2个y相关。它可以居中&amp;大小。可以是左上约束&amp;右下约束。</p><p id="5001" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">但是等等，你可能会说，我只是拖放了“Hello World”标签放在中间，然后我只添加了2个约束，而不是4个。额外的2是从<strong class="ih hj">固有内容大小生成的。</strong>(2 NSContentSizeLayoutConstraint约束)<strong class="ih hj">约束保存在视图中。每个视图都有约束数组属性，添加&amp;移除方法。</strong></p><p id="1824" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们假设在一个视图中有2个标签容器，其中有额外的标签:(lbl1包含lbl2 &amp; lbl3包含lbl4)。</p><figure class="kg kh ki kj fd kv er es paragraph-image"><div role="button" tabindex="0" class="lf lg di lh bf li"><div class="er es le"><img src="../Images/8a686c1c4a51fba102533fdb31f529de.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2qkeG6WbRZIoVNw_38xusQ.png"/></div></div><figcaption class="ky kz et er es la lb bd b be z dx translated">两个带有子标签的容器(标签)</figcaption></figure><p id="8646" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">请注意，相对于lbl1{3}定位lbl2{4}中心的约束条件位于lbl1{3}内部。定位lb3{1}的约束存储在它们的超级视图中，即视图控制者的视图中。此外，在故事板中，假尺寸约束(占位符约束)只是为了正确显示内容。这里(在SB中)没有显示所有的约束。尤其是视图控制器的视图约束，因为它将被添加到窗口中，并且将有视图的超级视图。</p><p id="079f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们在代码中创建一些标签:</p><figure class="kg kh ki kj fd kv er es paragraph-image"><div role="button" tabindex="0" class="lf lg di lh bf li"><div class="er es lj"><img src="../Images/fef0f49e14557bf83896a8078e431b9e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xZG136_NiZWWkLe05HyZSw.png"/></div></div></figure><p id="c1cb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">注意:</strong>注意，子视图(lbl)可以有可访问性标识符(可以用于单元测试&amp;调试)，约束也可以有id。检查控制台的输出，我们可以看到vc的视图有4个约束，但我们没有在sb或代码中添加任何约束:</p><figure class="kg kh ki kj fd kv er es paragraph-image"><div role="button" tabindex="0" class="lf lg di lh bf li"><div class="er es lk"><img src="../Images/b200214dcdeef00f3f56346ca99f7896.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*poBj151G0D1x9ZoX4ou6lg.png"/></div></div></figure><p id="0b1e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这是因为视图被添加到了窗口中，该窗口显示在应用程序的屏幕(主屏幕)上。</p><p id="4971" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">就个人而言，为了添加将与父视图匹配的子视图，而不是创建至少两个约束，我使用了<strong class="ih hj">自动调整大小掩码</strong>和<strong class="ih hj">translatesAutoresizingMaskIntoConstraints(默认为true </strong>)。</p><pre class="kg kh ki kj fd kk kl km kn aw ko bi"><span id="86fe" class="kp je hi kl b fi kq kr l ks kt"><strong class="kl hj">//extension</strong> UIView {</span><span id="7bd4" class="kp je hi kl b fi ld kr l ks kt"><strong class="kl hj">func</strong> makeFlexibleSizeUsingAutoresizingMask() {<br/>  translatesAutoresizingMaskIntoConstraints = <strong class="kl hj">true<br/>  </strong>autoresizingMask = [.flexibleWidth, .flexibleHeight]<br/>}</span><span id="56d0" class="kp je hi kl b fi ld kr l ks kt"><strong class="kl hj">// add subview and match it is size with parent<br/>func</strong> addAndMatchSize(subview refView: UIView) {<br/>  addSubview(refView)<br/>  refView.frame = bounds // define initial frame   <br/>  refView.makeFlexibleSizeUsingAutoresizingMask()<br/>}</span></pre><p id="a69f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为了找到一个视图(约束容器),在其中放置约束(包含第一和第二项),我们必须遍历视图的层次结构。</p><figure class="kg kh ki kj fd kv er es paragraph-image"><div role="button" tabindex="0" class="lf lg di lh bf li"><div class="er es ll"><img src="../Images/f1c02506a83c0ebb16449c439609a506.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UpZTP52rk6-qXMwHYWB91A.png"/></div></div><figcaption class="ky kz et er es la lb bd b be z dx translated">找到要放置约束的视图。</figcaption></figure><p id="7055" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这里我们检查视图是否直接相互连接，如果不是，我们创建一组父视图并找到第一个交集。视图应该有一些共同的祖先，并且应该有superview，否则将会引发运行时异常。</p><p id="d5a0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为了从一侧访问约束，我们可以在其上使用引用，或者从另一侧我们可以使用<strong class="ih hj">constraintsAffectingLayout(for</strong>:)方法，指定适当的轴(垂直或水平)。我们可以遍历它们的集合，甚至通过标识符找到约束。让我们看看如何访问高度约束(假设它有“高度”标识符):</p><figure class="kg kh ki kj fd kv er es paragraph-image"><div role="button" tabindex="0" class="lf lg di lh bf li"><div class="er es lm"><img src="../Images/2d8e590dd6a597f853714a2e7cabe269.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5re2J7nuvm0yN8JVY-PKEg.png"/></div></div><figcaption class="ky kz et er es la lb bd b be z dx translated">访问高度约束</figcaption></figure><p id="1cd9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在这种情况下，高度约束的乘数为零，只是一些常量值。</p><h1 id="e473" class="jd je hi bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">违反约束:</h1><p id="4019" class="pw-post-body-paragraph if ig hi ih b ii kb ik il im kc io ip iq kd is it iu ke iw ix iy kf ja jb jc hb bi translated">通常我们通过使用弱引用或弱出口来访问约束。约束是有优先级的，如果有一个优先级较高的约束，它将优先于另一个优先级较低的约束。最新的约束将被“停用”，但它将被保留在原始的约束数组中。然而，在违反约束的情况下，违反的约束不仅会被“停用”，而且会从包含的数组中删除。至少我能回忆起老版本操作系统(早于iOS 13)上的这种行为。那么约束上弱引用可以被无效。在这种情况下，你必须保持对约束的强引用，否则有可能得到<strong class="ih hj"> NullReference </strong>异常。在装有iOS 14.5的模拟器上快速播放高度限制演示了<strong class="ih hj">逻辑已经改变</strong>:限制被保留，并处于活动状态，但是我们会看到违反限制的调试消息…</p><figure class="kg kh ki kj fd kv er es paragraph-image"><div role="button" tabindex="0" class="lf lg di lh bf li"><div class="er es ln"><img src="../Images/f1eafdd3b96943eac07ef851ebf90615.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xAXIzLxMgC1ECKru2APxIA.png"/></div></div><figcaption class="ky kz et er es la lb bd b be z dx translated">违反了最新的约束</figcaption></figure><figure class="kg kh ki kj fd kv er es paragraph-image"><div class="er es lo"><img src="../Images/a322ec5128ee3a36e4f69338ed772bda.png" data-original-src="https://miro.medium.com/v2/resize:fit:992/format:webp/1*cG0XlI5kEFAlyzhT-22r3A.png"/></div></figure><p id="5e3a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">冲突的约束都保存在lbl1的约束数组中。</p><p id="e774" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们回到固有的内容大小。</p><h1 id="eb6f" class="jd je hi bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">内在内容大小</h1><p id="493c" class="pw-post-body-paragraph if ig hi ih b ii kb ik il im kc io ip iq kd is it iu ke iw ix iy kf ja jb jc hb bi translated">根据官方文档:“这是接收视图的自然大小，仅考虑视图本身的属性”。所以<strong class="ih hj"> UILabels，UIButtons </strong>和其他大多数提供的控件都有默认大小。要在自定义视图中添加类似的行为，必须覆盖父方法:</p><figure class="kg kh ki kj fd kv er es paragraph-image"><div class="er es lp"><img src="../Images/009d8a17085f4d23c5379d0e349d1a2d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1258/format:webp/1*XKdOGZn-3IQ49zClN01BRg.png"/></div><figcaption class="ky kz et er es la lb bd b be z dx translated">重写方法以返回隐式大小</figcaption></figure><p id="b76d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">默认情况下，当没有内部内容大小时，返回<strong class="ih hj"> noIntrinsicMetric(-1) </strong>。</p><h1 id="3a80" class="jd je hi bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">内容拥抱，抗压:</h1><p id="c838" class="pw-post-body-paragraph if ig hi ih b ii kb ik il im kc io ip iq kd is it iu ke iw ix iy kf ja jb jc hb bi translated"><strong class="ih hj">内容拥抱</strong>优先级定义视图在多大程度上限制其内容的伸展，即视图拥抱自己的程度。默认优先级是250。(较低)</p><p id="2e5a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">压缩阻力</strong>表示视图抵抗压缩的程度。默认优先级是750。低优先级的约束可能会受到压缩阻力&amp;内容拥抱的影响，因为基本上它们的优先级可能高于或低于上述属性。</p><figure class="kg kh ki kj fd kv er es paragraph-image"><div class="er es lq"><img src="../Images/2babe789bbd9842ae567d10f5a219074.png" data-original-src="https://miro.medium.com/v2/resize:fit:908/format:webp/1*1LzShhPXwdND4WB_8kzSNg.png"/></div><figcaption class="ky kz et er es la lb bd b be z dx translated">带2个标签的水平堆栈视图</figcaption></figure><p id="ba9e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们考虑具有两个标签的水平堆栈视图:第一个标签具有较低的内容拥抱，因此如果堆栈视图完全填充superview，则可以扩展。</p></div><div class="ab cl lr ls gp lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="hb hc hd he hf"><p id="c1b9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在第一篇文章中，我们考虑了约束、它们的属性、描述的内容拥抱和压缩阻力、固有内容大小。在下面的文章中，我们将考虑创建约束和调试约束的不同方法。</p></div></div>    
</body>
</html>