<html>
<head>
<title>Oh No! Big O</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">哦不！大 O</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/oh-no-big-o-a3aeb29526d3?source=collection_archive---------13-----------------------#2021-07-11">https://medium.com/nerd-for-tech/oh-no-big-o-a3aeb29526d3?source=collection_archive---------13-----------------------#2021-07-11</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="2b4a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">大 O 及其分解。这篇文章需要对 big O 进行总结，以及如何在识别算法的实际时间复杂度时将它从理论应用到实践。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es jd"><img src="../Images/531c3e916669a37ec739d4ac8f233207.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*10MbHLB88SLzlaTZ"/></div></div><figcaption class="jp jq et er es jr js bd b be z dx translated">马库斯·温克勒在<a class="ae jt" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><p id="49a9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">一年前，我甚至没有听说过“大 o”这个术语。我有一个根植于通信设计的视觉背景，所以这个术语直到我开始学习编码中的各种算法设计模式时才出现。在关于避免循环中的循环的对话中偶然提到了这一点。我，当时天真的程序员，没有意识到循环中有循环的含义。好吧，举例来说，当你处理一个 25 项长的数组时，这没什么大不了的，但是当处理大型数据集时，这就有很大的影响了。所以在这篇文章中，我将详细介绍我对大 O 的理解，以及如何开始识别/分类实际的算法，而不是理论方程，希望可以帮助其他迷失的人。</p><h1 id="6c91" class="ju jv hi bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">大 O 关乎大局。</h1><p id="55b7" class="pw-post-body-paragraph if ig hi ih b ii ks ik il im kt io ip iq ku is it iu kv iw ix iy kw ja jb jc hb bi translated">我意识到大 O 的关键在于趋势识别。当你执行一个函数 3 次对 1，000，000 次，而不是 3 次对 20 次，会发生什么？它的大致轨迹是怎样的？手术数量是否继续复合？它是平的吗？</p><p id="b1cf" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">记住大局，否则你的趋势识别可能会被误解。例如:</p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="kx ky l"/></div></figure><p id="5a27" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果你举上面的例子。该功能输出到控制台，从<code class="du kz la lb lc b">n</code>计数到<code class="du kz la lb lc b">20</code>。因此，从微观角度来看，它可能看起来像 O(n ),因为随着输入大小的增加，比如从 1 到 5 到 15，发生的操作数量也会增加。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es ld"><img src="../Images/fe303b84466ae179d66c7215673bb754.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OX6tKBobp9ZBdG_-U9ySOA.jpeg"/></div></div></figure><p id="9064" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">但是一旦你大幅增加输入大小，比如说 100，000，轨迹看起来就和以前不一样了。这仅仅是 0(1)时间中的一个短暂现象。</p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="le ky l"/></div><figcaption class="jp jq et er es jr js bd b be z dx translated">重要的是宏观的观点，而不是微观的观点</figcaption></figure><h1 id="34a9" class="ju jv hi bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">这是模糊逻辑</h1><p id="0ae4" class="pw-post-body-paragraph if ig hi ih b ii ks ik il im kt io ip iq ku is it iu kv iw ix iy kw ja jb jc hb bi translated">从我收集的情况来看，没有真正的公式化方法来接近大 O。从概念的角度来看，你会认为你可以计算一个函数中的运算次数，因为这就是大 O 的时间是如何计算的。归结起来就是这些操作的复杂性。</p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="kx ky l"/></div></figure><p id="9707" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果，比如拿上面的代码，算一下运算。你会得到:</p><pre class="je jf jg jh fd lf lc lg lh aw li bi"><span id="a8c8" class="lj jv hi lc b fi lk ll l lm ln">2 assignments // equal sign followed by an integer<br/>1 n assignment // because i++ is short for i+= 1<br/>2 n additions // once in the i++ and on line 6 <br/>1 n comparision // in the for loop line 5<br/>---------------------<br/>A total of 4n + 2 operations </span></pre><p id="78b8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">所以它等于 O(4n + 2)。2 可以去掉，因为它在最大的图片中是名义上的。但是等等，那就是 O(4n)了，对吧？为什么是，但实际上不是。事实是，事情的广泛范围<code class="du kz la lb lc b">4 * n</code>并不重要。时间还是线性的。所以你可以去掉 4。<strong class="ih hj"> n 的输入越多，</strong>运算所需的时间越长。</p><pre class="je jf jg jh fd lf lc lg lh aw li bi"><span id="9413" class="lj jv hi lc b fi lk ll l lm ln">O(4n + 2) = O(n)</span></pre><blockquote class="lo lp lq"><p id="39cf" class="if ig lr ih b ii ij ik il im in io ip ls ir is it lt iv iw ix lu iz ja jb jc hb bi translated">W <strong class="ih hj">重要的是操作的复杂性。</strong></p></blockquote><p id="3db7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这里有一个非常深刻的例子:</p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="kx ky l"/></div></figure><p id="9f7c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><code class="du kz la lb lc b">myCoolFunction()</code>现在稍微复杂一些。仍然简单，因为这是为了说明的目的。所以我们再统计一下操作，只是为了比较。</p><pre class="je jf jg jh fd lf lc lg lh aw li bi"><span id="3323" class="lj jv hi lc b fi lk ll l lm ln">2 assignments // equal sign followed by an integer<br/>3 n assignments // i++ is i+= 1 and line 6 <br/>2 n additions // in the i++ and on j++ <br/>2 n comparisions // in the for loop line 5<br/>---------------------<br/>A total of 7n + 2 operations</span></pre><p id="8e61" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">好的，那么通过纯粹尝试采用上面的公式化方法，你会确定我们有 7 n 个操作和 2 个常量操作。如上所述，这减少到 O(n)。很不幸，在这种情况下，那就错了。这里的不同之处在于，我们的<code class="du kz la lb lc b">for loop</code>包含了一个额外的<code class="du kz la lb lc b">for loop</code>。所以每次循环第一个循环时，它都要循环内部的 for 循环。所以这实际上会分解成。</p><pre class="je jf jg jh fd lf lc lg lh aw li bi"><span id="9fbc" class="lj jv hi lc b fi lk ll l lm ln">OUTER LOOP<br/>1 assignment // equal sign followed by an integer<br/>3 n assignments // i++ is i+= 1 and line 6<br/>1 n comparision // in the for loop line 5<br/>INNER LOOP<br/>1 assignment // equal sign followed by an integer<br/>2 n asignments // j=0 and j++<br/>1 n comparision // in the for loop line 7</span></pre><blockquote class="lo lp lq"><p id="3399" class="if ig lr ih b ii ij ik il im in io ip ls ir is it lt iv iw ix lu iz ja jb jc hb bi translated">我知道这有点让人昏昏欲睡，但我确实有一个观点，所以继续吧。</p></blockquote><p id="fea1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们马上就要讲到了。因为我们有一个内部循环和一个外部循环，这 n 个赋值是相关但独立的。关系是<code class="du kz la lb lc b">outerloop * innerloop</code>,因为我们执行外部循环多少次，内部循环就会执行多少次。</p><pre class="je jf jg jh fd lf lc lg lh aw li bi"><span id="4660" class="lj jv hi lc b fi lk ll l lm ln">O(4n + 1) // outer loop <br/>O(3n + 1) // inner loop<br/>O(4n + 1) * O(3n + 1) // outerloop * innerloop<br/>O(n) * O(n) // applying the same reduction logic above<br/>--- or --- <br/>O(n^2)</span></pre><p id="f18b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">好了，够了。我通过上面的练习展示了如何系统地确定一个函数的运行时。在一天结束的时候，你应该花时间计算操作吗？如果你愿意，但正如你在上面看到的，由于大 o 的宽泛态度，大多数操作都被打折扣/取消了。重要的是复杂性，或者在我们的情况下，是循环中的循环。这取决于你去破译到底发生了什么逻辑。此外，在计算 big O 时，还有其他一些细节我们不会在本文中讨论，比如推入或弹出数组中的项的运行时间、数据类型的访问时间。文章的重点是给你一个对大 o 的粗略估计。</p><h1 id="cabf" class="ju jv hi bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">将大 O 应用于实际算法</h1><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es lv"><img src="../Images/c8e50b7f69321aae1bbc0c91c5895bc1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2H5WHi0SovLRB0qagV_I7w.jpeg"/></div></div><figcaption class="jp jq et er es jr js bd b be z dx translated">我们将讨论的 4 大 O 符号供参考，还有更多</figcaption></figure><p id="b6d0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在是时候跳过理论层面，把它应用到实际算法中去了。虽然有一些其他的大 O 方程，我们将坚持上面的 4。实际上，我们已经在上面的文章中讨论了其中的三个。</p><ul class=""><li id="6e79" class="lw lx hi ih b ii ij im in iq ly iu lz iy ma jc mb mc md me bi translated"><strong class="ih hj"> O(1) —是在常量时间运行的任何东西，输入大小不影响运行时间(记住这个有大图)。</strong></li><li id="df70" class="lw lx hi ih b ii mf im mg iq mh iu mi iy mj jc mb mc md me bi translated">O(log n) —我们很快就会谈到这个问题。我会解释日志是什么意思。</li><li id="da39" class="lw lx hi ih b ii mf im mg iq mh iu mi iy mj jc mb mc md me bi translated">O(n)-这是一种复杂度呈线性的算法。输入越大，运行的时间就越长。</li><li id="c6d2" class="lw lx hi ih b ii mf im mg iq mh iu mi iy mj jc mb mc md me bi translated"><strong class="ih hj"> O(n ) —通常称为二次时间，是一种随着输入大小的增加而运行时间呈指数增长的算法。</strong></li></ul><h2 id="8a8d" class="lj jv hi bd jw mk ml mm ka mn mo mp ke iq mq mr ki iu ms mt km iy mu mv kq mw bi translated">O(1) —常数时间</h2><p id="a90a" class="pw-post-body-paragraph if ig hi ih b ii ks ik il im kt io ip iq ku is it iu kv iw ix iy kw ja jb jc hb bi translated">总的来说，无论输入大小如何，这个运行时都是平坦的。一个示例算法是访问哈希表。虽然从技术上来说它是摊销常数时间，但它仍然是常数。因为无论生成多少个键，运行时间都不会增加，所以可以将其视为访问一个索引数组。一个更简单的例子是。输入一个无限长的字符串，返回第一个字母。</p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="kx ky l"/></div></figure><h2 id="37ba" class="lj jv hi bd jw mk ml mm ka mn mo mp ke iq mq mr ki iu ms mt km iy mu mv kq mw bi translated">O(log n) —对数时间</h2><p id="c020" class="pw-post-body-paragraph if ig hi ih b ii ks ik il im kt io ip iq ku is it iu kv iw ix iy kw ja jb jc hb bi translated">首先快速解释一下<em class="lr"> log </em>对于包括我在内的非数学专业人士来说意味着什么。<em class="lr"> Log </em>就是一个数的对数，粗略的衡量了在得到一个小于等于 1 的值之前，你可以将那个数除以 2 的次数。</p><p id="a598" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果这没有意义，你可以把 O(log n)想象成一个运行时，你有一个馅饼，你把它切成两半，丢弃一半，拿另一半，然后把那一半切成两半，丢弃一半，拿另一半，然后把那一半分成两半。或者，在算法领域，我描述的是一个流行的算法，叫做二分搜索法。它很省时，因为与线性搜索不同，它在每次循环中把 n 分成两半。</p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="kx ky l"/></div></figure><h2 id="19d6" class="lj jv hi bd jw mk ml mm ka mn mo mp ke iq mq mr ki iu ms mt km iy mu mv kq mw bi translated">O(n) —线性时间</h2><p id="6105" class="pw-post-body-paragraph if ig hi ih b ii ks ik il im kt io ip iq ku is it iu kv iw ix iy kw ja jb jc hb bi translated">线性时间是一种在轨迹上是线性的算法。输入的大小与执行所需的时间有关。一个流行的例子是线性搜索。此外，简单的递归算法通常是 O(n)。</p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="kx ky l"/></div></figure><h2 id="58fa" class="lj jv hi bd jw mk ml mm ka mn mo mp ke iq mq mr ki iu ms mt km iy mu mv kq mw bi translated">O(n ) —多项式/二次时间</h2><p id="cb6f" class="pw-post-body-paragraph if ig hi ih b ii ks ik il im kt io ip iq ku is it iu kv iw ix iy kw ja jb jc hb bi translated">二次时间是一种算法，其中执行时间随着输入的大小呈指数增长。例如，如果你有一个带有内部循环的循环，例如，将数组中的字符串与数组中的其他字符串进行比较。或者，就像下面的例子一样，我们循环遍历一个数组，然后循环遍历数组的各个元素并做一些工作。</p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="kx ky l"/></div></figure><p id="8bb6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这就是应用于实际代码的四个大运行时。你如何利用这种学习来识别其他算法的大 O？我发现，将 Big O 的理论转化为实际代码，以学习典型算法方法的设计模式，并了解它们的 Big O 时间复杂度，是最有见地的方法。比如二分搜索法<em class="lr"> O(log n) </em>，线性搜索<em class="lr"> O(n) </em>，冒泡排序<em class="lr"> O(n ) </em>。和大 O 一样，没有放之四海而皆准的答案。通常，您的算法属于许多类别中的一种。</p></div><div class="ab cl mx my gp mz" role="separator"><span class="na bw bk nb nc nd"/><span class="na bw bk nb nc nd"/><span class="na bw bk nb nc"/></div><div class="hb hc hd he hf"><p id="6c67" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">因此，我已经带你们了解了一些关于大 O 的理论思考，并展示了一些大 O 在算法中的实际应用。最后，我想重申文章的要点:</p><ul class=""><li id="e8cd" class="lw lx hi ih b ii ij im in iq ly iu lz iy ma jc mb mc md me bi translated">谈到大 o，要从大处着眼。</li><li id="ed2c" class="lw lx hi ih b ii mf im mg iq mh iu mi iy mj jc mb mc md me bi translated">对于 Big O 来说，没有现成的答案。这是一种模糊逻辑，由您自己去做一些调查工作来决定代码在做什么。</li><li id="9b52" class="lw lx hi ih b ii mf im mg iq mh iu mi iy mj jc mb mc md me bi translated">一旦确定了基本设计模式，就可以对算法进行粗略的估计。了解流行的算法方法，并知道其中的大 O。</li></ul><p id="2392" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">编码快乐！</p></div></div>    
</body>
</html>