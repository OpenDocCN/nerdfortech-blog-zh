<html>
<head>
<title>Feel and Make the Arrays more powerful in iOS Development</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">感受并让数组在 iOS 开发中更加强大</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/feel-and-make-the-arrays-more-powerful-in-ios-development-5de1b8b0ff3f?source=collection_archive---------16-----------------------#2021-05-09">https://medium.com/nerd-for-tech/feel-and-make-the-arrays-more-powerful-in-ios-development-5de1b8b0ff3f?source=collection_archive---------16-----------------------#2021-05-09</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/4785a04a10bcb07bfeefe0ba32f5fb24.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*xD9tMSWjs27qRplv"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">照片由<a class="ae iu" href="https://unsplash.com/@mohamad_mahdi?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">穆罕默德·迈赫迪·阿巴斯</a>在<a class="ae iu" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="e3ea" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在编写自定义函数之前，让我们重新访问一下可用的内置函数，这些函数相对较少使用，但功能强大。</p><h2 id="23e3" class="jt ju hi bd jv jw jx jy jz ka kb kc kd jg ke kf kg jk kh ki kj jo kk kl km kn bi translated">作为索引的范围运算符</h2><p id="c697" class="pw-post-body-paragraph iv iw hi ix b iy ko ja jb jc kp je jf jg kq ji jj jk kr jm jn jo ks jq jr js hb bi translated">我们可以使用开值域或闭值域操作符来访问和修改数组中的元素。如果数组不能适应变化，那么它将抛出错误。</p><pre class="kt ku kv kw fd kx ky kz la aw lb bi"><span id="1361" class="jt ju hi ky b fi lc ld l le lf">var array = [1,2,3]</span><span id="e69b" class="jt ju hi ky b fi lg ld l le lf">array[0…1] = [2,2]<br/>print(array[0..4]) // error: Index Out Of Range</span></pre><h2 id="abea" class="jt ju hi bd jv jw jx jy jz ka kb kc kd jg ke kf kg jk kh ki kj jo kk kl km kn bi translated">枚举</h2><p id="c51b" class="pw-post-body-paragraph iv iw hi ix b iy ko ja jb jc kp je jf jg kq ji jj jk kr jm jn jo ks jq jr js hb bi translated">enumerated()将在每次迭代中返回一个包含索引和元素的对。</p><pre class="kt ku kv kw fd kx ky kz la aw lb bi"><span id="95f5" class="jt ju hi ky b fi lc ld l le lf">array.enumerated().forEach({print(“\($0) -&gt; \($1)”)})</span></pre><h2 id="368f" class="jt ju hi bd jv jw jx jy jz ka kb kc kd jg ke kf kg jk kh ki kj jo kk kl km kn bi translated">元素序列</h2><p id="13d0" class="pw-post-body-paragraph iv iw hi ix b iy ko ja jb jc kp je jf jg kq ji jj jk kr jm jn jo ks jq jr js hb bi translated">基于索引比较两个数组中的每一个元素，只有在各自索引处的所有元素都相等时才返回 true。这与 array == arrayCopy 相同。</p><pre class="kt ku kv kw fd kx ky kz la aw lb bi"><span id="c15e" class="jt ju hi ky b fi lc ld l le lf">array.elementsEqual(arrayCopy)</span></pre><h2 id="b807" class="jt ju hi bd jv jw jx jy jz ka kb kc kd jg ke kf kg jk kh ki kj jo kk kl km kn bi translated">前缀</h2><p id="af18" class="pw-post-body-paragraph iv iw hi ix b iy ko ja jb jc kp je jf jg kq ji jj jk kr jm jn jo ks jq jr js hb bi translated">如果我们想从数组中取出前 n 个元素，并且不确定数组的大小，那么我们可以使用 prefix。这将返回指定数量的元素(如果可用)。但是如果数字超过了数组的长度，那么它将返回完整的数组。</p><pre class="kt ku kv kw fd kx ky kz la aw lb bi"><span id="b0f2" class="jt ju hi ky b fi lc ld l le lf">array.prefix(20)</span><span id="5aee" class="jt ju hi ky b fi lg ld l le lf"><strong class="ky hj">var</strong> test:[Int] = []</span><span id="7310" class="jt ju hi ky b fi lg ld l le lf">print(test.prefix(10)) // []</span></pre><h2 id="c9d7" class="jt ju hi bd jv jw jx jy jz ka kb kc kd jg ke kf kg jk kh ki kj jo kk kl km kn bi translated">FirstIndex/LastIndex</h2><p id="211f" class="pw-post-body-paragraph iv iw hi ix b iy ko ja jb jc kp je jf jg kq ji jj jk kr jm jn jo ks jq jr js hb bi translated">firstIndex(of:)或 lastIndex(of:)通常用于了解元素的索引。但是还有 firstIndex(where:)或者 lastIndex(where:)更强大。我们可以使用自定义谓词来查找索引，如下所示。</p><pre class="kt ku kv kw fd kx ky kz la aw lb bi"><span id="2bec" class="jt ju hi ky b fi lc ld l le lf">//Finding first number which is greater than 2</span><span id="ad15" class="jt ju hi ky b fi lg ld l le lf">array.firstIndex(where: {$0 &gt; 2})</span><span id="1c14" class="jt ju hi ky b fi lg ld l le lf">//Finding first empty string in a list</span><span id="bddd" class="jt ju hi ky b fi lg ld l le lf">arrayNames.firstIndex(where: {$0.isEmpty})</span></pre><h2 id="d5b3" class="jt ju hi bd jv jw jx jy jz ka kb kc kd jg ke kf kg jk kh ki kj jo kk kl km kn bi translated">斯瓦帕特</h2><p id="dfcd" class="pw-post-body-paragraph iv iw hi ix b iy ko ja jb jc kp je jf jg kq ji jj jk kr jm jn jo ks jq jr js hb bi translated">为了交换数组内部的元素，我们可以使用 swapAt(from_index，to_index)。</p><pre class="kt ku kv kw fd kx ky kz la aw lb bi"><span id="e5d7" class="jt ju hi ky b fi lc ld l le lf">array.swapAt(0, 1)</span></pre><h1 id="d943" class="lh ju hi bd jv li lj lk jz ll lm ln kd lo lp lq kg lr ls lt kj lu lv lw km lx bi translated">延长</h1><p id="bab9" class="pw-post-body-paragraph iv iw hi ix b iy ko ja jb jc kp je jf jg kq ji jj jk kr jm jn jo ks jq jr js hb bi translated">现在让我们给数组更多的功能</p><h2 id="0b70" class="jt ju hi bd jv jw jx jy jz ka kb kc kd jg ke kf kg jk kh ki kj jo kk kl km kn bi translated">替换事件</h2><p id="655a" class="pw-post-body-paragraph iv iw hi ix b iy ko ja jb jc kp je jf jg kq ji jj jk kr jm jn jo ks jq jr js hb bi translated">当我们需要用其他元素替换一个元素时，我们可以利用这个扩展</p><pre class="kt ku kv kw fd kx ky kz la aw lb bi"><span id="3541" class="jt ju hi ky b fi lc ld l le lf"><strong class="ky hj">extension</strong> Array {</span><span id="2160" class="jt ju hi ky b fi lg ld l le lf"><strong class="ky hj"> mutating</strong> <strong class="ky hj">func</strong> replaceOccurrences(of value: Element, with val:    <br/>   Element) <strong class="ky hj">where</strong>  Element: Equatable {</span><span id="b7ac" class="jt ju hi ky b fi lg ld l le lf"><strong class="ky hj">    var</strong> ex = <strong class="ky hj">false</strong></span><span id="b04f" class="jt ju hi ky b fi lg ld l le lf"><strong class="ky hj">    while</strong> ex == <strong class="ky hj">false</strong> {</span><span id="113d" class="jt ju hi ky b fi lg ld l le lf"><strong class="ky hj">     if</strong> <strong class="ky hj">let</strong> i = <strong class="ky hj">self</strong>.firstIndex(of: value ) {</span><span id="67da" class="jt ju hi ky b fi lg ld l le lf"><strong class="ky hj">       self</strong>[i] = val</span><span id="c874" class="jt ju hi ky b fi lg ld l le lf">     } <strong class="ky hj">else</strong> {</span><span id="6cc1" class="jt ju hi ky b fi lg ld l le lf">       ex = <strong class="ky hj">true</strong></span><span id="2288" class="jt ju hi ky b fi lg ld l le lf">     }<br/>   }<br/> }</span><span id="0f88" class="jt ju hi ky b fi lg ld l le lf"><strong class="ky hj"> mutating</strong> <strong class="ky hj">func</strong> replaceFirstOccurence(of value: Element, with val:    <br/>   Element) <strong class="ky hj">where</strong>  Element: Equatable {</span><span id="ca88" class="jt ju hi ky b fi lg ld l le lf"><strong class="ky hj">     if</strong> <strong class="ky hj">let</strong> i = <strong class="ky hj">self</strong>.firstIndex(of: value ) {</span><span id="36ef" class="jt ju hi ky b fi lg ld l le lf"><strong class="ky hj">       self</strong>[i] = val</span><span id="a863" class="jt ju hi ky b fi lg ld l le lf">    } <br/> }</span><span id="33fc" class="jt ju hi ky b fi lg ld l le lf"><strong class="ky hj"> mutating</strong> <strong class="ky hj">func</strong> replaceLastOccurence(of value: Element, with val:    <br/>   Element) <strong class="ky hj">where</strong>  Element: Equatable {</span><span id="9ee7" class="jt ju hi ky b fi lg ld l le lf"><strong class="ky hj">    if</strong> <strong class="ky hj">let</strong> i = <strong class="ky hj">self</strong>.lastIndex(of: value ) {</span><span id="de81" class="jt ju hi ky b fi lg ld l le lf"><strong class="ky hj">      self</strong>[i] = val</span><span id="6d5b" class="jt ju hi ky b fi lg ld l le lf">    } <br/> }<br/>}</span></pre><h2 id="e0fd" class="jt ju hi bd jv jw jx jy jz ka kb kc kd jg ke kf kg jk kh ki kj jo kk kl km kn bi translated">独特元素</h2><p id="5614" class="pw-post-body-paragraph iv iw hi ix b iy ko ja jb jc kp je jf jg kq ji jj jk kr jm jn jo ks jq jr js hb bi translated">拥有关于数组中唯一元素的信息总是有用的。在那种情况下，下面的内容会很有用。</p><pre class="kt ku kv kw fd kx ky kz la aw lb bi"><span id="ff23" class="jt ju hi ky b fi lc ld l le lf"><strong class="ky hj">extension</strong> Array {</span><span id="92c8" class="jt ju hi ky b fi lg ld l le lf"><strong class="ky hj">  func</strong> unique() -&gt; [Element] <strong class="ky hj">where</strong> Element: Equatable {</span><span id="5776" class="jt ju hi ky b fi lg ld l le lf"><strong class="ky hj">     var</strong> newArray: [Element] = []</span><span id="8178" class="jt ju hi ky b fi lg ld l le lf"><strong class="ky hj">     self</strong>.forEach { i <strong class="ky hj">in</strong></span><span id="c8e5" class="jt ju hi ky b fi lg ld l le lf"><strong class="ky hj">        if</strong> !newArray.contains(i) {</span><span id="2db8" class="jt ju hi ky b fi lg ld l le lf">            newArray.append(i)</span><span id="15cb" class="jt ju hi ky b fi lg ld l le lf">        }</span><span id="1f3d" class="jt ju hi ky b fi lg ld l le lf">     }</span><span id="2af6" class="jt ju hi ky b fi lg ld l le lf"><strong class="ky hj">     return</strong> newArray</span><span id="7c81" class="jt ju hi ky b fi lg ld l le lf">  }</span><span id="5709" class="jt ju hi ky b fi lg ld l le lf"><strong class="ky hj">  func</strong> uniqueElementsCount() -&gt; [Element : Int] <strong class="ky hj">where</strong> Element: <br/>     Equatable {</span><span id="017e" class="jt ju hi ky b fi lg ld l le lf"><strong class="ky hj">     var</strong> newArray: [Element:Int] = [:]</span><span id="7f67" class="jt ju hi ky b fi lg ld l le lf"><strong class="ky hj">     self</strong>.forEach { i <strong class="ky hj">in</strong></span><span id="8c99" class="jt ju hi ky b fi lg ld l le lf"><strong class="ky hj">       if</strong> !newArray.keys.contains(i) {</span><span id="822d" class="jt ju hi ky b fi lg ld l le lf">         newArray[i] = 0</span><span id="ab7e" class="jt ju hi ky b fi lg ld l le lf">       } <strong class="ky hj">else</strong> {</span><span id="abaa" class="jt ju hi ky b fi lg ld l le lf">         newArray[i] = (newArray[i] ?? 0) + 1</span><span id="9881" class="jt ju hi ky b fi lg ld l le lf">       }</span><span id="f419" class="jt ju hi ky b fi lg ld l le lf">    }</span><span id="c578" class="jt ju hi ky b fi lg ld l le lf"><strong class="ky hj">    return</strong> newArray</span><span id="71a9" class="jt ju hi ky b fi lg ld l le lf">  }</span><span id="916a" class="jt ju hi ky b fi lg ld l le lf">}</span></pre><h2 id="abba" class="jt ju hi bd jv jw jx jy jz ka kb kc kd jg ke kf kg jk kh ki kj jo kk kl km kn bi translated">元素计数</h2><p id="4a03" class="pw-post-body-paragraph iv iw hi ix b iy ko ja jb jc kp je jf jg kq ji jj jk kr jm jn jo ks jq jr js hb bi translated">当您需要知道一个元素在数组中出现了多少次时，可以使用下面的代码片段</p><pre class="kt ku kv kw fd kx ky kz la aw lb bi"><span id="3bad" class="jt ju hi ky b fi lc ld l le lf"><strong class="ky hj">extension</strong> Array {</span><span id="2f39" class="jt ju hi ky b fi lg ld l le lf"><strong class="ky hj">  func</strong> countOf(element: Element) -&gt; Int <strong class="ky hj">where</strong> Element: Equatable {</span><span id="ee06" class="jt ju hi ky b fi lg ld l le lf"><strong class="ky hj">    var</strong> ex = 0</span><span id="c5ed" class="jt ju hi ky b fi lg ld l le lf"><strong class="ky hj">    self</strong>.forEach { i <strong class="ky hj">in</strong></span><span id="507d" class="jt ju hi ky b fi lg ld l le lf"><strong class="ky hj">      if</strong> i == element {</span><span id="ba74" class="jt ju hi ky b fi lg ld l le lf">        ex = ex + 1</span><span id="53c1" class="jt ju hi ky b fi lg ld l le lf">      }</span><span id="a64a" class="jt ju hi ky b fi lg ld l le lf">    }</span><span id="fddd" class="jt ju hi ky b fi lg ld l le lf"><strong class="ky hj">    return</strong> ex</span><span id="999a" class="jt ju hi ky b fi lg ld l le lf">  }</span><span id="9379" class="jt ju hi ky b fi lg ld l le lf">}</span></pre><h2 id="84df" class="jt ju hi bd jv jw jx jy jz ka kb kc kd jg ke kf kg jk kh ki kj jo kk kl km kn bi translated">分组字符串</h2><p id="bf81" class="pw-post-body-paragraph iv iw hi ix b iy ko ja jb jc kp je jf jg kq ji jj jk kr jm jn jo ks jq jr js hb bi translated">当你有一系列的名字，你想把它们按字母顺序排列，使用下面的扩展。</p><pre class="kt ku kv kw fd kx ky kz la aw lb bi"><span id="7eed" class="jt ju hi ky b fi lc ld l le lf"><strong class="ky hj">extension</strong> Array {</span><span id="513c" class="jt ju hi ky b fi lg ld l le lf"><strong class="ky hj">func</strong> grouped() -&gt; [(alphabet: Character, values: [String])] <strong class="ky hj">where</strong> <br/>  Element == String  {</span><span id="b6b1" class="jt ju hi ky b fi lg ld l le lf"><strong class="ky hj">    return </strong>Dictionary(grouping: <strong class="ky hj">self</strong>) { (country) -&gt; Character <strong class="ky hj">in</strong></span><span id="74a7" class="jt ju hi ky b fi lg ld l le lf"><strong class="ky hj">            return</strong> country.first ?? "-"</span><span id="4f1d" class="jt ju hi ky b fi lg ld l le lf">       }</span><span id="605d" class="jt ju hi ky b fi lg ld l le lf">       .map({(alphabet: $0, values: $1)}) </span><span id="7e08" class="jt ju hi ky b fi lg ld l le lf">       .sorted(by: {$0.alphabet &lt; $1.alphabet})</span><span id="3e53" class="jt ju hi ky b fi lg ld l le lf">   }</span><span id="06cf" class="jt ju hi ky b fi lg ld l le lf">}</span></pre><h1 id="ec2f" class="lh ju hi bd jv li lj lk jz ll lm ln kd lo lp lq kg lr ls lt kj lu lv lw km lx bi translated">我们无意中犯的常见错误</h1><p id="63c7" class="pw-post-body-paragraph iv iw hi ix b iy ko ja jb jc kp je jf jg kq ji jj jk kr jm jn jo ks jq jr js hb bi translated">我无意中犯的一个常见错误是试图添加不同数据类型的元素。</p><pre class="kt ku kv kw fd kx ky kz la aw lb bi"><span id="ffa7" class="jt ju hi ky b fi lc ld l le lf">var arr = [1,2,3]<br/>arr.appennd("four") // Not possible</span></pre><p id="a971" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">最好的解决方法是用“Any”使数组匿名</p><pre class="kt ku kv kw fd kx ky kz la aw lb bi"><span id="3f40" class="jt ju hi ky b fi lc ld l le lf">var arr: [Any] = [1,2,3]<br/>arr.append("four")</span></pre><p id="5761" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">好了..</p><p id="9529" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">感谢阅读…</p></div></div>    
</body>
</html>