<html>
<head>
<title>Elasticsearch Highlighting with Kotlin</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用 Kotlin 突出显示弹性搜索</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/elasticsearch-highlighting-with-kotlin-e4b35ee1780e?source=collection_archive---------2-----------------------#2022-10-06">https://medium.com/nerd-for-tech/elasticsearch-highlighting-with-kotlin-e4b35ee1780e?source=collection_archive---------2-----------------------#2022-10-06</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/2d6c8e5c9cdb5fbd59c244f5c770c751.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8i-q8pOl-2W_XOxv9WM-dg.png"/></div></div></figure><p id="d1a4" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">本周，我不得不在我的项目的搜索栏中添加高亮显示功能。目前，每当我在前端点击一个搜索结果，它就会打开相应的文档。这些文档非常长，因此要花很长时间才能找到文档中您要找的部分。为了解决这个问题，我需要在文档中突出显示最佳匹配，这样您就可以一目了然了。</p><h1 id="60db" class="jo jp hi bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">使用 KT-Search 突出显示</h1><p id="4158" class="pw-post-body-paragraph iq ir hi is b it km iv iw ix kn iz ja jb ko jd je jf kp jh ji jj kq jl jm jn hb bi translated">KT-Search 是一个很棒的 Kotlin 客户端，用于弹性搜索。即使没有得到官方支持，它也提供了官方 Java 客户端的大部分特性。<a class="ae kr" href="https://www.elastic.co/guide/en/elasticsearch/reference/current/highlighting.html#highlighting" rel="noopener ugc nofollow" target="_blank">遗憾的是，kt-search 不支持高亮显示</a>。因此，我们需要自己编写功能。</p><p id="38e0" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">本教程的最终结果将是一个包含突出显示的术语信息的 ElasticSearch。</p><p id="e7d6" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这个问题的解决方案由三部分组成:</p><ol class=""><li id="6218" class="ks kt hi is b it iu ix iy jb ku jf kv jj kw jn kx ky kz la bi translated">创建查询</li><li id="22ac" class="ks kt hi is b it lb ix lc jb ld jf le jj lf jn kx ky kz la bi translated">接收响应</li><li id="6a99" class="ks kt hi is b it lb ix lc jb ld jf le jj lf jn kx ky kz la bi translated">反序列化 SearchResponse</li></ol><h2 id="074c" class="lg jp hi bd jq lh li lj ju lk ll lm jy jb ln lo kc jf lp lq kg jj lr ls kk lt bi translated">创建查询</h2><p id="8ef6" class="pw-post-body-paragraph iq ir hi is b it km iv iw ix kn iz ja jb ko jd je jf kp jh ji jj kq jl jm jn hb bi translated">首先，我们需要找到一种方法向 ElasticSearch 发送一个包含带高亮显示的查询的请求。由于没有突出显示自身的功能，我们必须使用 kt-search 的 rawBody 特性。</p><p id="99fc" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">因为这个查询可能会很长，所以我为它创建了一个单独的函数。</p><figure class="lu lv lw lx fd ij"><div class="bz dy l di"><div class="ly lz l"/></div></figure><p id="8cd1" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">请用<code class="du ma mb mc md b">highlight</code>块注意下部:</p><ul class=""><li id="a0ed" class="ks kt hi is b it iu ix iy jb ku jf kv jj kw jn me ky kz la bi translated">前后标签环绕匹配的术语。如果你不定义它们，ElasticSearch 会用<code class="du ma mb mc md b">&lt;em&gt;</code>和<code class="du ma mb mc md b">&lt;/em&gt;</code>来表示它们。</li><li id="3b77" class="ks kt hi is b it lb ix lc jb ld jf le jj lf jn me ky kz la bi translated"><code class="du ma mb mc md b">fields</code>块定义了应该从哪个字段返回最佳匹配。<br/> ElasticDocument 是一个数据类，其值称为<code class="du ma mb mc md b">content</code>。我使用它，因为我可以通过 IntelliJ 重构，而不必在每次更改这个属性的名称时手动更改字符串。</li><li id="7a72" class="ks kt hi is b it lb ix lc jb ld jf le jj lf jn me ky kz la bi translated"><code class="du ma mb mc md b">fragment_size</code>定义了片段的最大长度。片段是匹配的术语与其周围的一些上下文的组合。</li><li id="9f9f" class="ks kt hi is b it lb ix lc jb ld jf le jj lf jn me ky kz la bi translated"><code class="du ma mb mc md b">number_of_fragments</code>定义在一个请求中返回多少这样的片段字符串。</li><li id="6a1b" class="ks kt hi is b it lb ix lc jb ld jf le jj lf jn me ky kz la bi translated">应基于此<a class="ae kr" href="https://www.elastic.co/guide/en/elasticsearch/reference/current/highlighting.html#set-highlighter-type" rel="noopener ugc nofollow" target="_blank">信息</a>选择<code class="du ma mb mc md b">fragmenter</code>和<code class="du ma mb mc md b">type</code>。</li></ul><h2 id="358e" class="lg jp hi bd jq lh li lj ju lk ll lm jy jb ln lo kc jf lp lq kg jj lr ls kk lt bi translated">接收响应</h2><p id="e02d" class="pw-post-body-paragraph iq ir hi is b it km iv iw ix kn iz ja jb ko jd je jf kp jh ji jj kq jl jm jn hb bi translated">既然我们现在有了高亮显示的查询，我们可以使用库的<code class="du ma mb mc md b">search()</code>函数，对吗？号码</p><p id="e29a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">搜索功能的 SearchResponse 不包含高亮显示。这意味着我们必须自己去做。</p><figure class="lu lv lw lx fd ij"><div class="bz dy l di"><div class="ly lz l"/></div></figure><p id="cbbd" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这个函数只返回字符串形式的 JSON。它使用 SearchClient 的 restClient 创建一个新的 post 请求。路径由索引的名称和我们希望在 ElasticSearch 上执行的功能一起设置。在我们这里是<code class="du ma mb mc md b">_search</code>。</p><p id="7190" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><code class="du ma mb mc md b">rawBody</code>使用我们在<code class="du ma mb mc md b">createQuery()</code>函数中定义的 JSON 字符串。</p><h2 id="4d82" class="lg jp hi bd jq lh li lj ju lk ll lm jy jb ln lo kc jf lp lq kg jj lr ls kk lt bi translated">反序列化 SearchResponse</h2><p id="e8ea" class="pw-post-body-paragraph iq ir hi is b it km iv iw ix kn iz ja jb ko jd je jf kp jh ji jj kq jl jm jn hb bi translated">最后，我们需要将带有搜索结果的字符串反序列化为一个命中列表。通常这将由 kt-search 处理，但由于 kt-search 的默认搜索响应不包含高亮信息，我们需要自己编写它。</p><figure class="lu lv lw lx fd ij"><div class="bz dy l di"><div class="ly lz l"/></div></figure><p id="8d19" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这些是反序列化所需的可序列化类。</p><p id="a9c3" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">请注意，Hit 类过滤掉了突出显示的术语，因此您的搜索结果中没有<code class="du ma mb mc md b">&lt;highlighted&gt;</code>包装器。</p><p id="c630" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在我们可以将所有这些步骤合并到我们自己的搜索函数中，这样我们就可以像平常一样调用它。</p><figure class="lu lv lw lx fd ij"><div class="bz dy l di"><div class="ly lz l"/></div></figure><p id="19e6" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">既然我们用<code class="du ma mb mc md b">@Serializable</code>注释了上面的所有类，现在我们可以调用 kt-search 提供的<code class="du ma mb mc md b">DEFAULT_JSON</code>对象的<code class="du ma mb mc md b">decodeFromString</code>方法。</p><p id="a35d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这将返回包含嵌套命中的 SearchResponse。我们可以通过调用<code class="du ma mb mc md b">searchResult.hits</code>来访问它们。</p><p id="def8" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">最后，我们有包含突出显示信息的点击。</p><h1 id="07b4" class="jo jp hi bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">反射</h1><h2 id="eea3" class="lg jp hi bd jq lh li lj ju lk ll lm jy jb ln lo kc jf lp lq kg jj lr ls kk lt bi translated">什么进展顺利</h2><p id="b3c3" class="pw-post-body-paragraph iq ir hi is b it km iv iw ix kn iz ja jb ko jd je jf kp jh ji jj kq jl jm jn hb bi translated">在我看来，检索突出显示信息的自写逻辑的实际实现非常好。我没有那么多问题，因为我可以用单元测试来测试行为。</p><h2 id="7259" class="lg jp hi bd jq lh li lj ju lk ll lm jy jb ln lo kc jf lp lq kg jj lr ls kk lt bi translated">什么需要改进</h2><p id="b16f" class="pw-post-body-paragraph iq ir hi is b it km iv iw ix kn iz ja jb ko jd je jf kp jh ji jj kq jl jm jn hb bi translated">我遇到的最大问题是理解 kt-search 的 SearchResponse 确实不包含任何关于高亮显示的信息。我很困惑，因为我发送了一个带有突出显示请求的查询，但是没有得到任何结果。当我通过 curl 发送一个请求时，我终于明白了，这与 kt-search 的 SearchResponse 有关。下一次，我将首先读取响应对象的 JavaDoc，这样我就可以一眼看出我正在寻找的字段不包含在其中。</p></div></div>    
</body>
</html>