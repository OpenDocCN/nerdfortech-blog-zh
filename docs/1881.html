<html>
<head>
<title>Hooked On React-Redux Hooks</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">挂在 React-Redux 挂钩上</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/hooked-on-react-redux-hooks-ba5c90803938?source=collection_archive---------9-----------------------#2021-04-11">https://medium.com/nerd-for-tech/hooked-on-react-redux-hooks-ba5c90803938?source=collection_archive---------9-----------------------#2021-04-11</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="f631" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在用钩子将最近的 React 应用程序的类组件转换为功能组件时，我开始寻找一种方法，不仅可以使用钩子管理本地状态，还可以允许我的组件从 Redux 存储中访问全局状态。</p><p id="9fd9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我发现 2019 年发布的 React Redux 版本包括两个新的挂钩<code class="du jd je jf jg b">useDispatch</code>和<code class="du jd je jf jg b">useSelector</code>，允许我们放弃更高阶的<code class="du jd je jf jg b">connect</code>组件，而是使用挂钩将我们的组件连接到 Redux 商店。</p><figure class="jh ji jj jk fd jl"><div class="bz dy l di"><div class="jm jn l"/></div></figure><p id="bad9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><code class="du jd je jf jg b">useDispatch</code>钩子从 Redux 存储中返回对我们的<code class="du jd je jf jg b">dispatch</code>函数的引用。我们可以使用它直接访问我们的调度操作，而不必在组件中使用<code class="du jd je jf jg b">mapDispatchToProps</code>。让我们来看一个前后:</p><p id="33fb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在没有挂钩的情况下将组件的派单连接到我们的 Redux store:</p><figure class="jh ji jj jk fd jl er es paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="er es jo"><img src="../Images/1533672003b5aa2ff2e82b72a5a9d4c2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LYsnv4yEn6vi0PW1N3mC-A.png"/></div></div></figure><p id="066f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">该文件从 React 应用程序中的另一个文件导入调度动作<code class="du jd je jf jg b">fetchCategories</code>，并且还从“react-redux”导入<code class="du jd je jf jg b">connect</code>。为了能够将这个<code class="du jd je jf jg b">App</code>组件连接到 Redux store，我们必须在 connect 中包装我们的<code class="du jd je jf jg b">App</code>组件，将调度动作<code class="du jd je jf jg b">fetchCategories</code>作为第二个参数传递给它。我们将第一个参数设置为<code class="du jd je jf jg b">null</code>,因为我们在这个组件中没有使用<code class="du jd je jf jg b">mapStateToProps</code>。如果是的话，这将是我们的连接包装器中的第一个参数。</p><p id="fd59" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">下面是这个组件作为一个带钩子的功能组件的样子:</p><figure class="jh ji jj jk fd jl er es paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="er es jo"><img src="../Images/502cd83db45250d4e8525dd82673ed16.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*C73-SSCxA9ykkvWP70x5Fg.png"/></div></div></figure><p id="f837" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如你所见，它的重量轻了一点，我们去掉了组件底部杂乱的连接包装。我们将在这一个中使用完全挂钩，并用<code class="du jd je jf jg b">useEffect</code>挂钩替换我们的组件生命周期方法。<code class="du jd je jf jg b">useEffect</code>钩子取代了像<code class="du jd je jf jg b">componentDidMount</code>或<code class="du jd je jf jg b">componentDidUpdate</code>这样的组件生命周期方法。这对于开发人员来说非常有用，因为后一种方法已知会给人们带来问题，因为它只有在组件初始呈现后进行更新时才会被触发。</p><p id="5bd6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们没有导入<code class="du jd je jf jg b">connect</code>,而是从‘react-redux’导入<code class="du jd je jf jg b">useDispatch</code>,并将挂钩设置为等于<code class="du jd je jf jg b">const dispatch</code>。这一步是必不可少的，因为<code class="du jd je jf jg b">useDispatch</code>不能在回调中被调用，将它设置为一个变量允许我们在<code class="du jd je jf jg b">useEffect</code>钩子中访问它。导入我们的<code class="du jd je jf jg b">fetchCategories</code>动作仍然是必要的，但是我们不再需要将它导入到组件的 props 中，只要组件被加载到页面上，我们就可以直接调用它。</p><p id="4c8a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果<code class="du jd je jf jg b">useDispatch</code>取代了<code class="du jd je jf jg b">mapDispatchToProps</code>，你可能已经猜到了<code class="du jd je jf jg b">useSelector</code>取代了<code class="du jd je jf jg b">mapStateToProps</code>。让我们仔细看看:</p><figure class="jh ji jj jk fd jl er es paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="er es jv"><img src="../Images/9980092071011a0b6085b610fbd7147e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mw7W7q1J-8yU2LJ4sKIE3Q.png"/></div></div></figure><p id="8d0e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这里我们再次导入<code class="du jd je jf jg b">connect</code>并使用它来包装我们的<code class="du jd je jf jg b">ShopContainer</code>组件，以连接到 Redux 存储并将全局状态映射到组件的道具。我们来看看<code class="du jd je jf jg b">useSelector</code>是什么样子的。</p><figure class="jh ji jj jk fd jl er es paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="er es jw"><img src="../Images/40a2a3639958aca8c8930cd8514240e4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*POgtCqjl8Ng88rPLaqOWiQ.png"/></div></div></figure><p id="ae37" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们没有导入<code class="du jd je jf jg b">connect</code>,而是从‘react-redux’导入<code class="du jd je jf jg b">useSelector</code>,然后实现它，让我们的功能组件直接访问商店。我们可以完全去掉我们的<code class="du jd je jf jg b">mapStateToProps</code>函数，绕过将组件连接到 Redux 存储的需要。如果你问我，我会觉得很酷！</p><p id="7882" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">对于<code class="du jd je jf jg b">useSelector</code>有一个警告:<code class="du jd je jf jg b">useSelector</code>使用严格的对象比较(<code class="du jd je jf jg b">===</code>)来确定组件是否应该重新呈现。这与<code class="du jd je jf jg b">connect()</code>不同，后者对<code class="du jd je jf jg b">mapState</code>调用的结果使用浅层相等检查来确定是否需要重新渲染。对于我们上面的例子，这并不重要，但是假设我们从 Redux 存储中返回两个对象。例如:</p><figure class="jh ji jj jk fd jl er es paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="er es jx"><img src="../Images/02111c31d70a165ae41042f4faeb3bce.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ba4wve5EbV3l3ypw5Fkw4A.png"/></div></div></figure><p id="a1f0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这里我们的<code class="du jd je jf jg b">useSelector</code>钩子每次被调用时都返回一个不同的对象文字。默认情况下，每次返回一个新对象都会强制重新呈现组件。</p><p id="0ebf" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">解决这个问题的方法是对我们想要检索的每个状态值调用一次<code class="du jd je jf jg b">useSelector</code>:</p><figure class="jh ji jj jk fd jl er es paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="er es jy"><img src="../Images/16d901432df66872f628854b54913079.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NyqE2Ge-JKLoMJF-U5cRTQ.png"/></div></div></figure><p id="4d7c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">或者，我们可以告诉<code class="du jd je jf jg b">useSelector</code>使用浅层等式比较:</p><figure class="jh ji jj jk fd jl er es paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="er es jz"><img src="../Images/0a3f96c836aef94b526cda4f8d79d7de.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cjNYFWRj8xFlbmr_EHVAFQ.png"/></div></div></figure><p id="56be" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">钩子很棒。一旦你掌握了它们，它们就很容易使用，React-developer 社区显然正在远离类组件，并使用钩子给功能组件提供管理状态和连接 Redux 存储的能力。</p><p id="3c2a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">React Redux 增加了 Redux 特有的挂钩，这是一种有效的方法，可以简化组件，在概念上更容易理解。</p><p id="c9ba" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">关于 React hooks 的更多信息，请查看我的朋友兼工程师同事 Brock Byrd 的博客，这里是<a class="ae kc" rel="noopener" href="/geekculture/react-hooks-and-why-you-should-use-them-ab92ee033e43">https://medium . com/geek culture/React-hooks-and-why-you-should-use-them-ab 92 ee 033 e 43</a>。</p><p id="cff6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">和往常一样，查看 React-Redux hooks 文档以获得关于这个主题的更多信息:【https://react-redux.js.org/api/hooks<a class="ae kc" href="https://react-redux.js.org/api/hooks" rel="noopener ugc nofollow" target="_blank"/></p></div></div>    
</body>
</html>