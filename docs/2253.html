<html>
<head>
<title>Swift Leetcode Series: Unique Paths II</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Swift Leetcode 系列:独特路径 II</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/swift-leetcode-series-unique-paths-ii-1defdf2def4b?source=collection_archive---------11-----------------------#2021-04-28">https://medium.com/nerd-for-tech/swift-leetcode-series-unique-paths-ii-1defdf2def4b?source=collection_archive---------11-----------------------#2021-04-28</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="db84" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">Swift +动态编程= Leetcode 63 ✅ ✅ ✅</h2></div><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ix"><img src="../Images/0fd260e2f760cebd875d3ca91249fdfa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GyUc7SANKCr7bO5U-TPArQ.png"/></div></div></figure><div class="jj jk ez fb jl jm"><a href="https://theswiftnerd.com/unique-paths-ii-leetcode/" rel="noopener  ugc nofollow" target="_blank"><div class="jn ab dw"><div class="jo ab jp cl cj jq"><h2 class="bd hj fi z dy jr ea eb js ed ef hh bi translated">唯一路径 II (Leetcode 63)</h2><div class="jt l"><h3 class="bd b fi z dy jr ea eb js ed ef dx translated">难度:中等链接:April Leetcoding 挑战 2021:第 28 天一个机器人位于一个 m x n 的左上角…</h3></div><div class="ju l"><p class="bd b fp z dy jr ea eb js ed ef dx translated">theswiftnerd.com</p></div></div><div class="jv l"><div class="jw l jx jy jz jv ka jh jm"/></div></div></a></div><p id="ad39" class="pw-post-body-paragraph kb kc hi kd b ke kf ij kg kh ki im kj kk kl km kn ko kp kq kr ks kt ku kv kw hb bi translated">你也可以点击上面的链接，阅读 Swift Nerd 博客上的完整故事以及其他有趣的故事。</p><h1 id="9c47" class="kx ky hi bd kz la lb lc ld le lf lg lh io li ip lj ir lk is ll iu lm iv ln lo bi translated">问题描述</h1><p id="9e4c" class="pw-post-body-paragraph kb kc hi kd b ke lp ij kg kh lq im kj kk lr km kn ko ls kq kr ks lt ku kv kw hb bi translated">一个机器人位于<code class="du lu lv lw lx b">m x n</code>网格的左上角(在下图中标为“开始”)。</p><p id="bfc2" class="pw-post-body-paragraph kb kc hi kd b ke kf ij kg kh ki im kj kk kl km kn ko kp kq kr ks kt ku kv kw hb bi translated">机器人在任何时候只能向下或向右移动。机器人正试图到达网格的右下角(下图中标有“完成”)。</p><p id="f7de" class="pw-post-body-paragraph kb kc hi kd b ke kf ij kg kh ki im kj kk kl km kn ko kp kq kr ks kt ku kv kw hb bi translated">现在考虑如果一些障碍被添加到网格中。会有多少独特的路径？</p><p id="cf08" class="pw-post-body-paragraph kb kc hi kd b ke kf ij kg kh ki im kj kk kl km kn ko kp kq kr ks kt ku kv kw hb bi translated">网格中的障碍物和空间分别标记为<code class="du lu lv lw lx b">1</code>和<code class="du lu lv lw lx b">0</code>。</p><p id="7804" class="pw-post-body-paragraph kb kc hi kd b ke kf ij kg kh ki im kj kk kl km kn ko kp kq kr ks kt ku kv kw hb bi translated"><strong class="kd hj">例 1: </strong></p><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es ly"><img src="../Images/3e7fa7d5f12dd393fa0fa1c3ac991a48.png" data-original-src="https://miro.medium.com/v2/resize:fit:484/format:webp/0*WE199H72dspGYzaV.jpg"/></div></figure><pre class="iy iz ja jb fd lz lx ma mb aw mc bi"><span id="83c7" class="md ky hi lx b fi me mf l mg mh"><strong class="lx hj">Input:</strong> obstacleGrid = [[0,0,0],[0,1,0],[0,0,0]]<br/><strong class="lx hj">Output:</strong> 2<br/><strong class="lx hj">Explanation:</strong> There is one obstacle in the middle of the 3x3 grid above.<br/>There are two ways to reach the bottom-right corner:<br/>1. Right -&gt; Right -&gt; Down -&gt; Down<br/>2. Down -&gt; Down -&gt; Right -&gt; Right</span></pre><p id="45f4" class="pw-post-body-paragraph kb kc hi kd b ke kf ij kg kh ki im kj kk kl km kn ko kp kq kr ks kt ku kv kw hb bi translated"><strong class="kd hj">例 2: </strong></p><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es mi"><img src="../Images/7d27c642012cc5d30da868db8a967e5e.png" data-original-src="https://miro.medium.com/v2/resize:fit:324/format:webp/0*V2z4SCXHSxLCJ5Xw.jpg"/></div></figure><pre class="iy iz ja jb fd lz lx ma mb aw mc bi"><span id="a5cb" class="md ky hi lx b fi me mf l mg mh"><strong class="lx hj">Input:</strong> obstacleGrid = [[0,1],[0,0]]<br/><strong class="lx hj">Output:</strong> 1</span></pre><h1 id="df78" class="kx ky hi bd kz la lb lc ld le lf lg lh io li ip lj ir lk is ll iu lm iv ln lo bi translated">限制</h1><ul class=""><li id="2773" class="mj mk hi kd b ke lp kh lq kk ml ko mm ks mn kw mo mp mq mr bi translated"><code class="du lu lv lw lx b">m == obstacleGrid.length</code></li><li id="cc7f" class="mj mk hi kd b ke ms kh mt kk mu ko mv ks mw kw mo mp mq mr bi translated"><code class="du lu lv lw lx b">n == obstacleGrid[i].length</code></li><li id="7778" class="mj mk hi kd b ke ms kh mt kk mu ko mv ks mw kw mo mp mq mr bi translated"><code class="du lu lv lw lx b">1 &lt;= m, n &lt;= 100</code></li><li id="7d65" class="mj mk hi kd b ke ms kh mt kk mu ko mv ks mw kw mo mp mq mr bi translated"><code class="du lu lv lw lx b">obstacleGrid[i][j]</code>是<code class="du lu lv lw lx b">0</code>还是<code class="du lu lv lw lx b">1</code>。</li></ul><h1 id="41e3" class="kx ky hi bd kz la lb lc ld le lf lg lh io li ip lj ir lk is ll iu lm iv ln lo bi translated">解决办法</h1><p id="0591" class="pw-post-body-paragraph kb kc hi kd b ke lp ij kg kh lq im kj kk lr km kn ko ls kq kr ks lt ku kv kw hb bi translated">一种简单的方法是尝试用深度优先搜索递归地找到每一条可能的路径。但是由于会重复计算许多子路径，对于一个大矩阵，我们会收到一个<strong class="kd hj"> TLE </strong>(超过时间限制)。既然我们已经走上了正确的道路，我们该如何优化呢？</p><h1 id="d54a" class="kx ky hi bd kz la lb lc ld le lf lg lh io li ip lj ir lk is ll iu lm iv ln lo bi translated">动态编程(记忆化)</h1><p id="9a60" class="pw-post-body-paragraph kb kc hi kd b ke lp ij kg kh lq im kj kk lr km kn ko ls kq kr ks lt ku kv kw hb bi translated">我们可以在一个<strong class="kd hj"> 2D 矩阵</strong>中存储一个矩阵元素可达的路径数。我们只能向右或向下移动，因此我们可以继续添加路径，DP 表中的最后一个单元格将表示可能的唯一路径的总数。单元格<strong class="kd hj"> DP[i][j] </strong>可能从<strong class="kd hj">左侧(DP [i][j — 1]) </strong>或<strong class="kd hj">顶部(DP[i — 1][j]) </strong>到达。如果单元格是障碍，则路径为零(<strong class="kd hj"> obstacleGrid[i][j] = 0 </strong>)。因为我们只能从(0，0)开始，因此如果第一个单元是障碍，那么整个矩阵是不可达的，总路径将是 0。我们还需要用值<strong class="kd hj"> 1 </strong>作为初始起始位置的种子来表示单一的初始路径。一旦我们完成构建<strong class="kd hj"> DP </strong>，右下角<strong class="kd hj">单元格的值应该就是我们的答案。</strong></p><h2 id="471f" class="md ky hi bd kz mx my mz ld na nb nc lh kk nd ne lj ko nf ng ll ks nh ni ln nj bi translated">密码</h2><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="nk nl l"/></div></figure><h1 id="b0dc" class="kx ky hi bd kz la lb lc ld le lf lg lh io li ip lj ir lk is ll iu lm iv ln lo bi translated">复杂性分析</h1><p id="b81b" class="pw-post-body-paragraph kb kc hi kd b ke lp ij kg kh lq im kj kk lr km kn ko ls kq kr ks lt ku kv kw hb bi translated">因为我们遍历每个单元一次，所以总的操作将等于矩阵的大小，即 N * M。我们还存储每个单元的路径，因此空间复杂度也是矩阵大小的量级。</p><p id="5006" class="pw-post-body-paragraph kb kc hi kd b ke kf ij kg kh ki im kj kk kl km kn ko kp kq kr ks kt ku kv kw hb bi translated"><strong class="kd hj"> Time = O(N * M) </strong>，其中 N =行数，M =列数</p><p id="3cc1" class="pw-post-body-paragraph kb kc hi kd b ke kf ij kg kh ki im kj kk kl km kn ko kp kq kr ks kt ku kv kw hb bi translated"><strong class="kd hj">空间= O(N * M) </strong></p></div><div class="ab cl nm nn gp no" role="separator"><span class="np bw bk nq nr ns"/><span class="np bw bk nq nr ns"/><span class="np bw bk nq nr"/></div><div class="hb hc hd he hf"><p id="0800" class="pw-post-body-paragraph kb kc hi kd b ke kf ij kg kh ki im kj kk kl km kn ko kp kq kr ks kt ku kv kw hb bi translated">感谢您的阅读。如果你喜欢这篇文章，并发现它很有用，请分享并像野火一样传播它！</p><p id="2b7b" class="pw-post-body-paragraph kb kc hi kd b ke kf ij kg kh ki im kj kk kl km kn ko kp kq kr ks kt ku kv kw hb bi translated">你可以在<a class="ae nt" href="https://theswiftnerd.com/" rel="noopener ugc nofollow" target="_blank">网站</a>|<a class="ae nt" href="https://www.linkedin.com/in/varunrathi28/" rel="noopener ugc nofollow" target="_blank">LinkedIn</a>|<a class="ae nt" href="https://github.com/varunrathi28" rel="noopener ugc nofollow" target="_blank">Github</a>上找到我</p></div></div>    
</body>
</html>