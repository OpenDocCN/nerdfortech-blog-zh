<html>
<head>
<title>If you can code. you can do statistics.</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如果你会编码。可以做统计。</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/if-you-can-code-you-can-do-statistics-ff7ff36ff40c?source=collection_archive---------11-----------------------#2021-02-13">https://medium.com/nerd-for-tech/if-you-can-code-you-can-do-statistics-ff7ff36ff40c?source=collection_archive---------11-----------------------#2021-02-13</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="f358" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">在一窍不通的情况下做统计。</h2></div><p id="e469" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="iz hj">简介:</strong></p><p id="2f6a" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在这一系列的博客文章中，我将谈论一些我们可以在没有任何统计学知识的情况下用来回答统计问题的技巧。<br/>我们将讨论一些统计学&amp;概率问题，并通过计算(使用代码)来回答它们。并与解析解进行比较。</p><p id="7865" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们还将讨论这种方法的利弊。</p><figure class="ju jv jw jx fd jy er es paragraph-image"><div role="button" tabindex="0" class="jz ka di kb bf kc"><div class="er es jt"><img src="../Images/f03786953af7f1ac2e98292a0a87098c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qufiZPfd8E2K-nqJLlNC6w.png"/></div></div><figcaption class="kf kg et er es kh ki bd b be z dx translated">xkcd.com</figcaption></figure></div><div class="ab cl kj kk gp kl" role="separator"><span class="km bw bk kn ko kp"/><span class="km bw bk kn ko kp"/><span class="km bw bk kn ko"/></div><div class="hb hc hd he hf"><p id="e11c" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">要充分利用这些帖子，你需要知道些什么？<br/>对于循环，函数，真的就是这样。</p><p id="a9e3" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">注意:我将使用python🐍。但是你可以用你喜欢的语言实现同样的逻辑，即使你喜欢的语言是PHP💩。</p></div><div class="ab cl kj kk gp kl" role="separator"><span class="km bw bk kn ko kp"/><span class="km bw bk kn ko kp"/><span class="km bw bk kn ko"/></div><div class="hb hc hd he hf"><p id="887a" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这是概率，那就从一个硬币的例子开始吧。<br/> <br/> <strong class="iz hj"> <em class="kq">例如:</em> </strong></p><blockquote class="kr ks kt"><p id="9f51" class="ix iy kq iz b ja jb ij jc jd je im jf ku jh ji jj kv jl jm jn kw jp jq jr js hb bi translated">我们在一家魔法商店前发现了一枚硬币。我们翻了100次，数了数正面和反面的数量。<br/>我们意识到我们得到了69个头和31个尾。<br/>所以问题是这样的。这是一枚公平的硬币吗？还是这里发生了什么奇怪的事情🤔？</p></blockquote><p id="ddf0" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">重构问题:<br/>为了解决这些问题，我们必须用一种我们程序员直观理解的方式来构建它们。在这种情况下，非常简单。如果硬币是公平的，如果我抛100次，得到69个正面的可能性有多大？<br/>为了回答这个问题，我们可以这样做:</p><p id="424d" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">*使用公平硬币(正面为0.5)模拟N次游戏(一次游戏100次翻转)。</p><p id="51e3" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">*计算我们得到69个或更多人头的次数。</p><p id="afbf" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">*计算有69个或更多人头的N个游戏的百分比。</p><pre class="ju jv jw jx fd kx ky kz la aw lb bi"><span id="aefd" class="lc ld hi ky b fi le lf l lg lh">from random import choice<br/>coin = [1 , 0] # 1 is heads 0 is tails<br/>N = 100000<br/>sum_of_heads = []<br/>for i in range(N):<br/>    flips = [] <br/>    for _ in range(100):<br/>        flips.append(choice(coin)) <br/>    sum_of_heads.append(sum(flips))</span><span id="3632" class="lc ld hi ky b fi li lf l lg lh">&gt;&gt;&gt; len(list(filter(lambda x:x&gt;=69, sum_of_heads)))/N</span><span id="95d8" class="lc ld hi ky b fi li lf l lg lh">0.00087</span></pre><figure class="ju jv jw jx fd jy er es paragraph-image"><div class="er es lj"><img src="../Images/5770faf4b9f18e37f605a668ff318d26.png" data-original-src="https://miro.medium.com/v2/resize:fit:1130/format:webp/1*DeQzwsQikAXpwL3AKfYwpw.png"/></div><figcaption class="kf kg et er es kh ki bd b be z dx translated">绿色虚线是69</figcaption></figure><p id="6ceb" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">正如我们在这里看到的，如果硬币是公平的，我们得到这个数据(69头)的概率是0.00087(这就是所谓的P值)。</p><p id="e594" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="iz hj">另一种解决方案:<br/> </strong>通常对于这些问题，我会尽可能使用numpy来提高执行速度🏃🏽🏃🏽。</p><pre class="ju jv jw jx fd kx ky kz la aw lb bi"><span id="cb59" class="lc ld hi ky b fi le lf l lg lh">import numpy as np</span><span id="148e" class="lc ld hi ky b fi li lf l lg lh">n = 10000<br/>flips_num = 100<br/>sims = np.random.choice([1,0], size=n*flips_num).reshape(flips_num, n).sum(axis=0)</span><span id="d40e" class="lc ld hi ky b fi li lf l lg lh">&gt;&gt;&gt; sum(sims &gt;= 69)/n</span><span id="fdc2" class="lc ld hi ky b fi li lf l lg lh">0.00087</span></pre><p id="643b" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这个解决方案比第一个快几个数量级。<br/>我在这里做的是模拟所有的翻转(N*100)，然后将1D数组改造成形状为(100，N)的2D数组，并对每一行求和。</p><p id="fc45" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><a class="ae lk" href="https://en.wikipedia.org/wiki/Checking_whether_a_coin_is_fair#:~:text=A%20fair%20coin%20is%20an,the%20same%20chance%20of%20winning" rel="noopener ugc nofollow" target="_blank">如果您对分析解决方案感兴趣。</a></p></div><div class="ab cl kj kk gp kl" role="separator"><span class="km bw bk kn ko kp"/><span class="km bw bk kn ko kp"/><span class="km bw bk kn ko"/></div><div class="hb hc hd he hf"><p id="dbc8" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="iz hj">举例:</strong></p><blockquote class="kr ks kt"><p id="65ae" class="ix iy kq iz b ja jb ij jc jd je im jf ku jh ji jj kv jl jm jn kw jp jq jr js hb bi translated">我们有一个装有三枚硬币的盒子。硬币1是标准的，硬币2有两个头像，硬币3是作弊的，所以得到头像的概率是1/3。从盒子里随机选择一枚硬币，扔向空中。<br/> - (a)求获得正面结果的概率。<br/> - (b)已知所选硬币是正面的情况下，硬币是双正面的概率是多少？同样，如果我们重新定义这个问题，如何去模拟它是很直观的。<br/>如果我们将每个硬币模拟成正面概率[0.5，1，1/3]，然后我们从这些概率/硬币列表中随机选择一个概率(p)N次，我们得到正面的概率是多少？<br/>在这些时间里，我们得到1(双头硬币)的概率是多少</p></blockquote></div><div class="ab cl kj kk gp kl" role="separator"><span class="km bw bk kn ko kp"/><span class="km bw bk kn ko kp"/><span class="km bw bk kn ko"/></div><div class="hb hc hd he hf"><blockquote class="kr ks kt"><p id="a175" class="ix iy kq iz b ja jb ij jc jd je im jf ku jh ji jj kv jl jm jn kw jp jq jr js hb bi translated">解释随机<a class="ae lk" href="https://numpy.org/doc/stable/reference/random/generated/numpy.random.choice.html" rel="noopener ugc nofollow" target="_blank"> np.random.choice </a> p参数。<br/> p是与a中每个值相关的概率。<br/>因此，如果我们有a = ['tails '，' heads']和p = [0，1]，这意味着我们将总是选择正面，如果p=[0.1，0.9]，这意味着10次中有9次我们将选择正面。(如果你运行足够多的模拟)<br/> **概率总和必须为1</p></blockquote><p id="0af5" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">同样，如果我们重新定义这个问题，如何去模拟它是很直观的。如果我们将每枚硬币模拟为正面概率[0.5，1，0.33333]，然后我们随机选择N次这些概率/硬币列表中的一个概率(p)，我们得到正面的概率是多少？在这些时间里，我们得到1(双头硬币)的概率是多少</p><p id="e4bd" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">为了回答这个问题，我们可以这样做:</p><ul class=""><li id="e0b2" class="ll lm hi iz b ja jb jd je jg ln jk lo jo lp js lq lr ls lt bi translated">从盒子中随机选择一枚硬币(从正面概率列表中随机选择一个正面概率)大小这里是N；</li><li id="0358" class="ll lm hi iz b ja lu jd lv jg lw jk lx jo ly js lq lr ls lt bi translated">循环概率，用你选择的硬币掷硬币。(注意，反面概率=正面概率)；</li><li id="8652" class="ll lm hi iz b ja lu jd lv jg lw jk lx jo ly js lq lr ls lt bi translated">如果选择了头(1)增加一个头；</li><li id="fb69" class="ll lm hi iz b ja lu jd lv jg lw jk lx jo ly js lq lr ls lt bi translated">如果是双头硬币(正面概率=1)，则增加两个正面加一个:<br/> -正面的概率将是正面/N <br/> -给定正面的概率将是两个正面/正面。</li></ul><pre class="ju jv jw jx fd kx ky kz la aw lb bi"><span id="05cf" class="lc ld hi ky b fi le lf l lg lh">N = 1000000<br/>proba_of_heads = [0.5, 1, 1/3]<br/>heads = 0<br/>two_headed = 0<br/>random_coin_proba = np.random.choice(proba_of_heads, size=N)<br/>for c in random_coin_proba:<br/>    if np.random.choice(a=[0,1], p=(1-c, c)):<br/>        heads += 1<br/>        if c == 1:<br/>            two_headed += 1<br/>            <br/>&gt;&gt;&gt; f"(a) proba of heads is {heads/N}. \n (b)proba of two headed given heads is {two_headed/heads}"</span><span id="4e99" class="lc ld hi ky b fi li lf l lg lh">(a) proba of heads is 0.6106. <br/>(b) proba of two headed given heads is 0.5456</span></pre><h1 id="880c" class="lz ld hi bd ma mb mc md me mf mg mh mi io mj ip mk ir ml is mm iu mn iv mo mp bi translated">群体差异。</h1><p id="8e64" class="pw-post-body-paragraph ix iy hi iz b ja mq ij jc jd mr im jf jg ms ji jj jk mt jm jn jo mu jq jr js hb bi translated"><strong class="iz hj">示例:</strong></p><blockquote class="kr ks kt"><p id="95af" class="ix iy kq iz b ja jb ij jc jd je im jf ku jh ji jj kv jl jm jn kw jp jq jr js hb bi translated">假设你是一名教师，你教A和B两个班。在第一次测试后，你注意到B班的平均分高于A班的平均分。<br/>你想知道，这是否足够重要？这种差异是偶然造成的可能性有多大？</p></blockquote><pre class="ju jv jw jx fd kx ky kz la aw lb bi"><span id="5b59" class="lc ld hi ky b fi le lf l lg lh">a_scores = [5.5,6.8,7,9,3,7,6,1,4,5,2,8,7,9]<br/>b_scores = [4.7,5,6,8,8,9,9,4,6.5,7,6.3,7,8]<br/>&gt;&gt;&gt; np.mean(b_scores), np.mean(a_scores)</span><span id="824d" class="lc ld hi ky b fi li lf l lg lh">(6.8076923076923075, 5.735714285714286)</span></pre><p id="3bc0" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">因此，B类的平均值为:6.8 <br/>，A类的平均值为:5.7</p><p id="155a" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如果你在谷歌上搜索如何使用python来回答这个问题，你可能会得到这样的结果:</p><pre class="ju jv jw jx fd kx ky kz la aw lb bi"><span id="fdb3" class="lc ld hi ky b fi le lf l lg lh">from statsmodels.stats.weightstats import ttest_ind<br/>&gt;&gt;&gt; ttest_ind(b_scores, a_scores, alternative='larger', usevar='unequal')[1]</span><span id="f587" class="lc ld hi ky b fi li lf l lg lh">0.096</span></pre><p id="4bc2" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">但这似乎不是一个有用的抽象层次，让我无法更好地理解这个问题。那么我们如何用代码来解决这个问题呢？</p><h2 id="bfb4" class="lc ld hi bd ma mv mw mx me my mz na mi jg nb nc mk jk nd ne mm jo nf ng mo nh bi translated">洗牌:</h2><p id="f990" class="pw-post-body-paragraph ix iy hi iz b ja mq ij jc jd mr im jf jg ms ji jj jk mt jm jn jo mu jq jr js hb bi translated">在这种情况下，重新思考这个问题将有助于我们设计解决方案。我们试图回答的真正问题是:如果两组之间没有差异，我们得到均值(b)-均值(a)=(6.807–5.735)= 1.072的平均值差异的可能性有多大。</p><p id="dab4" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们能做的很简单:</p><ul class=""><li id="8e2b" class="ll lm hi iz b ja jb jd je jg ln jk lo jo lp js lq lr ls lt bi translated">把所有的分数放在一个列表里；</li><li id="2a44" class="ll lm hi iz b ja lu jd lv jg lw jk lx jo ly js lq lr ls lt bi translated">洗牌，并随机分裂他们；</li><li id="4de5" class="ll lm hi iz b ja lu jd lv jg lw jk lx jo ly js lq lr ls lt bi translated">取手段之间的差异；</li><li id="d17b" class="ll lm hi iz b ja lu jd lv jg lw jk lx jo ly js lq lr ls lt bi translated">重复该过程，并计算平均值之差为1.072或更高时的次数。</li></ul><pre class="ju jv jw jx fd kx ky kz la aw lb bi"><span id="d4f9" class="lc ld hi ky b fi le lf l lg lh">from random import shuffle<br/>a_scores = [5.5,6.8,7,9,3,7,6,1,4,5,2,8,7,9]<br/>b_scores = [4.7,5,6,8,8,9,9,4,6.5,7,6.3,7,8]<br/>mean_diff = np.mean(b_scores) - np.mean(a_scores)<br/>N = 100000<br/>means_diffs = []<br/>for i in range(N):<br/>    mixed = a_scores + b_scores<br/>    shuffle(mixed)<br/>    a , b = mixed[:len(a_scores)], mixed[len(a_scores):]<br/>    means_diffs.append(np.mean(b) - np.mean(a))</span><span id="8a45" class="lc ld hi ky b fi li lf l lg lh">&gt;&gt;&gt; np.sum(np.array(means_diffs) &gt;= 1.072)/N</span><span id="9198" class="lc ld hi ky b fi li lf l lg lh">0.096</span></pre><figure class="ju jv jw jx fd jy er es paragraph-image"><div class="er es ni"><img src="../Images/ac793a33c20d79a76d5f165f4e78c0ee.png" data-original-src="https://miro.medium.com/v2/resize:fit:1124/format:webp/1*Jbs3wi8i6fmM7O7H6BBrRQ.png"/></div></figure><p id="7998" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">正如你在这里看到的，结果与解析解相同，但不同的是，我们实际上知道发生了什么。希望是:D</p><p id="7d1a" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="iz hj">这些方法的好处:</strong></p><p id="44c7" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">1 —灵活性(非常容易添加分支逻辑和处理大量边缘情况)；<br/> 2 —迫使你在解决问题的同时思考问题，而不是担心t分布表或<a class="ae lk" href="https://en.wikipedia.org/wiki/Degrees_of_freedom_(statistics)" rel="noopener ugc nofollow" target="_blank">自由度</a>；3-对程序员来说很直观，因为这是我们的思维方式；4 —你做出假设和设计选择。但是，分析方法通常带有一些假设，你需要了解这些假设，并时刻牢记在心。</p><p id="1a51" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="iz hj">这些方法的败笔。</strong></p><p id="c77b" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">1 —结果不精确，但对大多数应用来说足够了；<br/> 2 —与解析解相比，计算成本较高；<br/> 3 —分支逻辑需要大量迭代，并且难以向量化(使用numpy)；<br/>4——并非所有的统计问题都可以直接模拟，因此有时模拟也很难想象。(我将在接下来的文章中讨论更多的例子)</p><p id="4d43" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这篇文章不是什么？<br/>——我不是说这种方式比用分析法好。<br/>——我不是说你不应该学统计学或者你不需要。</p><p id="233f" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">*我要说的是，许多统计问题可以通过计算来解决，如果你想变得有趣，除了简单的循环或函数之外，不需要任何东西。如果你是程序员，这是一种更自然的思考方式。</p><p id="a72c" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">下一篇文章:A/B测试，简单而正确的方法。</p></div></div>    
</body>
</html>