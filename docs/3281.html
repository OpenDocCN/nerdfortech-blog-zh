<html>
<head>
<title>Day 4: Open the Lock</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">第四天:打开锁</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/day-4-interleaving-string-8c232e934967?source=collection_archive---------17-----------------------#2021-06-04">https://medium.com/nerd-for-tech/day-4-interleaving-string-8c232e934967?source=collection_archive---------17-----------------------#2021-06-04</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="413b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> <em class="jd">问题链接:</em> </strong></p><div class="je jf ez fb jg jh"><a href="https://leetcode.com/explore/challenge/card/june-leetcoding-challenge-2021/603/week-1-june-1st-june-7th/3767/" rel="noopener  ugc nofollow" target="_blank"><div class="ji ab dw"><div class="jj ab jk cl cj jl"><h2 class="bd hj fi z dy jm ea eb jn ed ef hh bi translated">探索- LeetCode</h2><div class="jo l"><h3 class="bd b fi z dy jm ea eb jn ed ef dx translated">这个挑战是初学者友好的，对高级和非高级用户都可用。它由30个每日…</h3></div><div class="jp l"><p class="bd b fp z dy jm ea eb jn ed ef dx translated">leetcode.com</p></div></div><div class="jq l"><div class="jr l js jt ju jq jv jw jh"/></div></div></a></div><p id="ddce" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> <em class="jd">问题陈述:</em> </strong></p><p id="63e0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">你面前有一把锁，有四个圆形的轮子。每个轮子有10个槽:<code class="du jx jy jz ka b">'0', '1', '2', '3', '4', '5', '6', '7', '8', '9'</code>。轮子可以自由旋转和环绕:比如我们可以把<code class="du jx jy jz ka b">'9'</code>变成<code class="du jx jy jz ka b">'0'</code>，或者把<code class="du jx jy jz ka b">'0'</code>变成<code class="du jx jy jz ka b">'9'</code>。每次移动包括在一个槽中转动一个轮子。</p><p id="1d64" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">锁最初从<code class="du jx jy jz ka b">'0000'</code>开始，这是一个代表4个车轮状态的字符串。</p><p id="a50b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">你会得到一个<code class="du jx jy jz ka b">deadends</code>死胡同列表，这意味着如果锁显示这些代码中的任何一个，锁的轮子将停止转动，你将无法打开它。</p><p id="131f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">给定一个代表将解锁锁的轮子的值的<code class="du jx jy jz ka b">target</code>，返回打开锁所需的最小总圈数，如果不可能，则返回-1。</p><p id="45ad" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> <em class="jd">例1: </em> </strong></p><pre class="kb kc kd ke fd kf ka kg kh aw ki bi"><span id="d1dc" class="kj kk hi ka b fi kl km l kn ko"><strong class="ka hj">Input:</strong> deadends = ["0201","0101","0102","1212","2002"], target = "0202"<br/><strong class="ka hj">Output:</strong> 6<br/><strong class="ka hj">Explanation:</strong><br/>A sequence of valid moves would be "0000" -&gt; "1000" -&gt; "1100" -&gt; "1200" -&gt; "1201" -&gt; "1202" -&gt; "0202".<br/>Note that a sequence like "0000" -&gt; "0001" -&gt; "0002" -&gt; "0102" -&gt; "0202" would be invalid,<br/>because the wheels of the lock become stuck after the display becomes the dead end "0102".</span></pre><p id="cc4c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> <em class="jd">例二:</em> </strong></p><pre class="kb kc kd ke fd kf ka kg kh aw ki bi"><span id="c725" class="kj kk hi ka b fi kl km l kn ko"><strong class="ka hj">Input:</strong> deadends = ["8888"], target = "0009"<br/><strong class="ka hj">Output:</strong> 1<br/><strong class="ka hj">Explanation:</strong><br/>We can turn the last wheel in reverse to move from "0000" -&gt; "0009".</span></pre><p id="4922" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> <em class="jd">例题3: </em> </strong></p><pre class="kb kc kd ke fd kf ka kg kh aw ki bi"><span id="9e01" class="kj kk hi ka b fi kl km l kn ko"><strong class="ka hj">Input:</strong> deadends = ["8887","8889","8878","8898","8788","8988","7888","9888"], target = "8888"<br/><strong class="ka hj">Output:</strong> -1<br/>Explanation:<br/>We can't reach the target without getting stuck.</span></pre><p id="6fb3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> <em class="jd">例4: </em> </strong></p><pre class="kb kc kd ke fd kf ka kg kh aw ki bi"><span id="0bd3" class="kj kk hi ka b fi kl km l kn ko"><strong class="ka hj">Input:</strong> deadends = ["0000"], target = "8888"<br/><strong class="ka hj">Output:</strong> -1</span></pre><p id="e79e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> <em class="jd">约束:</em> </strong></p><pre class="kb kc kd ke fd kf ka kg kh aw ki bi"><span id="8fed" class="kj kk hi ka b fi kl km l kn ko">- 1 &lt;= deadends.length &lt;= 500<br/>- deadends[i].length == 4<br/>- target.length == 4<br/>- t<!-- -->arget will not be in the list <!-- -->deadends<br/>- target<!-- --> and <!-- -->deadends[i]<!-- --> consist of digits only.<strong class="ka hj">Output:</strong> -1</span></pre><p id="e79d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> <em class="jd">我的解决方案:</em> </strong></p><pre class="kb kc kd ke fd kf ka kg kh aw ki bi"><span id="5c4a" class="kj kk hi ka b fi kl km l kn ko">from collections import deque</span><span id="f76d" class="kj kk hi ka b fi kp km l kn ko">class Solution:<br/>    def openLock(self, deadends: List[str], target: str) -&gt; int:<br/>        if target in deadends or '0000' in deadends or not target:<br/>            return -1<br/>        <br/>        deadset = set(deadends)<br/>        queue = deque(['0000'])<br/>        distance = {'0000': 0}<br/>        <br/>        while queue:<br/>            cur = queue.popleft()<br/>            if cur == target:<br/>                return distance[target]<br/>            <br/>            for neigh in self.neighbours(cur, deadset):<br/>                if neigh in distance:<br/>                    continue<br/>                queue.append(neigh)<br/>                distance[neigh] = distance[cur] + 1<br/>                <br/>        return -1<br/>    <br/>    def neighbours(self, state, deadset):<br/>        ans = []<br/>        for idx, char in enumerate(state):<br/>            for op in [-1, 1]:<br/>                nextSlot = str((int(char) + op) % 10) <br/>                neighbour = state[:idx] + nextSlot + state[idx + 1:]<br/>                if neighbour not in deadset:<br/>                    ans.append(neighbour)<br/>        return ans</span></pre><p id="57f3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> <em class="jd">解释:</em> </strong></p><p id="480a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">先举个简单的例子。</p><pre class="kb kc kd ke fd kf ka kg kh aw ki bi"><span id="0cf6" class="kj kk hi ka b fi kl km l kn ko">deadends = ["3"], target = "5", initialString = "0"</span></pre><p id="a05d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果是这种情况，那么我们有两个选择，顺时针或逆时针从1到5。请注意，如果我们顺时针方向移动，我们将被困在死胡同3。因此，为了解决这个问题，我们必须想出一个办法，我们可以同时检查顺时针和逆时针方向。对于这样的问题，队列是最好的选择。</p><p id="5610" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们看看怎么做。</p><ol class=""><li id="1b33" class="kq kr hi ih b ii ij im in iq ks iu kt iy ku jc kv kw kx ky bi translated">将0推入队列，并将其标记为0级。与队列一起，保存一个访问过的数组。</li><li id="376d" class="kq kr hi ih b ii kz im la iq lb iu lc iy ld jc kv kw kx ky bi translated">弹出0，将其添加到访问过的数组，将两个邻居，即1(顺时针)和9(逆时针)推入队列。</li><li id="cbaa" class="kq kr hi ih b ii kz im la iq lb iu lc iy ld jc kv kw kx ky bi translated">Pop 1，将其添加到已访问的数组中。现在我们有两个选项，即0和2。我们丢弃0，因为它已经在被访问的数组中。还有，pop 9。我们还有两个选项，即0和8。重复同样的步骤，直到你到达目标。</li><li id="c1e3" class="kq kr hi ih b ii kz im la iq lb iu lc iy ld jc kv kw kx ky bi translated">请注意，在第2级，当我们弹出2时，我们有一个将3推入队列的选项，但是因为它是一个死胡同，所以我们跳过它。</li></ol><figure class="kb kc kd ke fd lf er es paragraph-image"><div class="er es le"><img src="../Images/b76c5d742b62877c0128ec92b20d1cfd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1184/format:webp/1*Z3S6rqiB_Bm6hbDw82RHeA.png"/></div></figure><p id="9e31" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">因此，我们分5步实现目标。</p><p id="08f4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">用同样的方法，对给定的问题算出这个算法。变化是，我们有4个数字，而不是1个数字。所以，对所有的数字应用这个算法，你就会得到答案。</p><p id="aa8e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">就是这样！</p><p id="ddbe" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果你有兴趣解决更多的问题，请跟随我，和我一起踏上这段旅程。</p><p id="a489" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">明天见！</p><p id="22b0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">干杯！</p></div></div>    
</body>
</html>