<html>
<head>
<title>BFS and DFS</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">BFS和外勤部</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/bfs-and-dfs-6abde74daace?source=collection_archive---------3-----------------------#2022-04-15">https://medium.com/nerd-for-tech/bfs-and-dfs-6abde74daace?source=collection_archive---------3-----------------------#2022-04-15</a></blockquote><div><div class="es gl gm gn go gp"/><div class="gq gr gs gt gu"><div class=""/><blockquote class="hu hv hw"><p id="2aa1" class="hx hy hz ia b ib ic id ie if ig ih ii ij ik il im in io ip iq ir is it iu iv gq bi translated">不熟？？？让我们在这里讨论广度优先搜索(BFS)和深度优先搜索(DFS)算法！！！</p></blockquote><h1 id="7f4d" class="iw ix gx bd iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt bi translated">DFS？？？</h1><p id="86d7" class="pw-post-body-paragraph hx hy gx ia b ib ju id ie if jv ih ii jw jx il im jy jz ip iq ka kb it iu iv gq bi translated">在这里，我们不探索下一层周围的顶点，而是深入到图形的深度。我们深入探索连接到源节点的节点，我们开始遍历，直到最后一个节点。</p><p id="abca" class="pw-post-body-paragraph hx hy gx ia b ib ic id ie if ig ih ii jw ik il im jy io ip iq ka is it iu iv gq bi translated">当遍历时，我们经常被DFS图中的节点级别所迷惑。我们假设如果节点位于彼此之上，则它们处于不同的层，并且不在搜索深度内。<strong class="ia gy"> <em class="hz"> DFS不是遍历图形的各个层，而是从一个源节点深入到最后一个节点。</em>T3】</strong></p><blockquote class="hu hv hw"><p id="d520" class="hx hy hz ia b ib ic id ie if ig ih ii ij ik il im in io ip iq ir is it iu iv gq bi translated">因此，不要因为看到图是如何绘制的而感到困惑，而是考虑连接到源节点的节点，并更深入地探索该路径。</p><p id="61b0" class="hx hy hz ia b ib ic id ie if ig ih ii ij ik il im in io ip iq ir is it iu iv gq bi translated">对于一个<strong class="ia gy"> DFS </strong>，我们<strong class="ia gy">不能使用队列</strong>作为数据结构！！！为什么？？？因为DFS意味着我们从源节点/某个特定的节点更深入，遍历回来(返回到同一个节点)。明确的规则是后进先出，最后进入的元素将首先被删除。所以，合适的人选是<strong class="ia gy">栈</strong>！！！</p><p id="26ce" class="hx hy hz ia b ib ic id ie if ig ih ii ij ik il im in io ip iq ir is it iu iv gq bi translated">但是，队列遵循FIFO(先进先出)规则；进入第一个的元素将首先被移除。更适用于BFS。在BFS中，在移动到下一层/级别之前，必须首先探索同一级别中的所有节点。</p></blockquote><h2 id="746a" class="kc ix gx bd iy kd ke kf jc kg kh ki jg jw kj kk jk jy kl km jo ka kn ko js kp bi translated">无向图上DFS的规则</h2><ul class=""><li id="a855" class="kq kr gx ia b ib ju if jv jw ks jy kt ka ku iv kv kw kx ky bi translated">遍历<strong class="ia gy"> <em class="hz">可以从任意顶点</em> </strong>开始(没有具体规则说这应该是初始顶点/源节点)。</li><li id="367b" class="kq kr gx ia b ib kz if la jw lb jy lc ka ld iv kv kw kx ky bi translated">从源节点开始，<strong class="ia gy"> <em class="hz">遍历该路径中的每个相邻顶点，直到最后一个节点</em> </strong>(没有边的节点！！！)—假设遍历是深入一个树枝！！！</li><li id="06fe" class="kq kr gx ia b ib kz if la jw lb jy lc ka ld iv kv kw kx ky bi translated">当有<strong class="ia gy"> <em class="hz">个节点连接到另外两个或更多的节点时，可以选择任何路径</em> </strong>，(没有明确的规则说先右后左！！！)，即<strong class="ia gy"> <em class="hz">可以沿着任意一个节点的路径</em> </strong>走，直到最后一个节点没有相邻的未访问过的顶点。</li><li id="cf53" class="kq kr gx ia b ib kz if la jw lb jy lc ka ld iv kv kw kx ky bi translated">在DFS中遍历特定路径时，我们总是会检查当前节点 的<strong class="ia gy"> <em class="hz">相邻未访问顶点(vertex的复数，vertex的意思是节点)。</em></strong></li></ul></div><div class="ab cl le lf ge lg" role="separator"><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj"/></div><div class="gq gr gs gt gu"><p id="aeb2" class="pw-post-body-paragraph hx hy gx ia b ib ic id ie if ig ih ii jw ik il im jy io ip iq ka is it iu iv gq bi translated">我们来看一个例子！！！</p><figure class="lm ln lo lp ek lq dy dz paragraph-image"><div class="dy dz ll"><img src="../Images/10b43ad3e03ae94c25e082a41a3b6462.png" data-original-src="https://miro.medium.com/v2/resize:fit:606/format:webp/1*SCy4ciTbz_8wJ6clJijpHg.png"/></div><figcaption class="lt lu ea dy dz lv lw bd b be z ft translated">DFS图</figcaption></figure><h2 id="4fef" class="kc ix gx bd iy kd ke kf jc kg kh ki jg jw kj kk jk jy kl km jo ka kn ko js kp bi translated">DFS遍历的步骤</h2><ol class=""><li id="bd84" class="kq kr gx ia b ib ju if jv jw ks jy kt ka ku iv lx kw kx ky bi translated">从任意顶点开始，我们就从顶点0开始。</li><li id="8821" class="kq kr gx ia b ib kz if la jw lb jy lc ka ld iv lx kw kx ky bi translated">初始化堆栈，并将节点0压入堆栈。</li><li id="7899" class="kq kr gx ia b ib kz if la jw lb jy lc ka ld iv lx kw kx ky bi translated">从节点0可以取两条路径，<strong class="ia gy"> <em class="hz">取任意一条路径</em> </strong>，即1或3(因为这些是<strong class="ia gy"> <em class="hz">到节点0的相邻顶点</em> </strong>)。</li><li id="5c89" class="kq kr gx ia b ib kz if la jw lb jy lc ka ld iv lx kw kx ky bi translated">我们将采用节点1的路径。将节点1压入堆栈。</li><li id="78b0" class="kq kr gx ia b ib kz if la jw lb jy lc ka ld iv lx kw kx ky bi translated">节点1将节点0、3、2、6和5作为相邻顶点。但是<strong class="ia gy"> <em class="hz">我们不能进入节点0的路径，因为它已经被访问并被推送到堆栈</em> </strong>。因此，剩下的选项是3、2、6和5。我们将采用节点3的路径，并将节点3推入堆栈。</li><li id="6a77" class="kq kr gx ia b ib kz if la jw lb jy lc ka ld iv lx kw kx ky bi translated">节点3将节点0、1、2和4作为相邻顶点。节点0和1是已经被访问过的<strong class="ia gy"> <em class="hz">并被推入堆栈</em> </strong>。所以剩下的顶点是2和4。我们将采用节点2的路径。将节点2压入堆栈。</li><li id="619d" class="kq kr gx ia b ib kz if la jw lb jy lc ka ld iv lx kw kx ky bi translated">节点2的相邻顶点是节点1、3、4和5，但是节点1和3被访问并被推送到堆栈。我们将获取节点4的路径，并将其推送到堆栈。</li><li id="cf01" class="kq kr gx ia b ib kz if la jw lb jy lc ka ld iv lx kw kx ky bi translated">节点4将节点3、2和6作为相邻节点，但只有节点6未被访问，因此采用节点6的路径并将其推入堆栈。</li><li id="8710" class="kq kr gx ia b ib kz if la jw lb jy lc ka ld iv lx kw kx ky bi translated">节点6将节点1和4作为相邻顶点，但这两个节点都被访问过，并且已经在堆栈中。节点6没有其他未访问的相邻顶点，我们需要向后遍历。</li></ol><figure class="lm ln lo lp ek lq dy dz paragraph-image"><div class="dy dz ly"><img src="../Images/976e2fab2c654e6f259a0e432a2ade1c.png" data-original-src="https://miro.medium.com/v2/resize:fit:128/format:webp/1*wP5EmkCyt-xV6r2hg6uWaQ.png"/></div><figcaption class="lt lu ea dy dz lv lw bd b be z ft translated">向后遍历前捕捉堆栈</figcaption></figure><blockquote class="hu hv hw"><p id="f249" class="hx hy hz ia b ib ic id ie if ig ih ii ij ik il im in io ip iq ir is it iu iv gq bi translated">当向后遍历时，我们将从节点6开始，但是如何继续呢？？？我们将使用堆栈并从中弹出元素，以便在图中进一步遍历！！！这里，在每个节点上，<strong class="ia gy">我们必须检查该节点是否有任何相邻的未访问节点</strong>(查看是否所有节点都被遍历过！！！).</p><p id="d669" class="hx hy hz ia b ib ic id ie if ig ih ii ij ik il im in io ip iq ir is it iu iv gq bi translated">注意:当从堆栈中弹出节点时，在向后遍历过程中(我们使用堆栈来这样做，因为也是为了跟踪遍历)，您看到您弹出的是您推到堆栈中的最后一个节点吗！！！这就是为什么DFS实现遵循<strong class="ia gy"> LIFO原则</strong>，结果是<strong class="ia gy">堆栈作为其数据结构</strong>。</p></blockquote><ol class=""><li id="3ab6" class="kq kr gx ia b ib ic if ig jw lz jy ma ka mb iv lx kw kx ky bi translated">从堆栈中弹出节点6，因为它是堆栈的当前顶层元素<strong class="ia gy"><em class="hz"/></strong>。</li><li id="43c4" class="kq kr gx ia b ib kz if la jw lb jy lc ka ld iv lx kw kx ky bi translated">下一个顶部元素是节点4，我们必须检查它是否有任何未访问的相邻顶点。节点4有节点2、3和6，所有节点都被访问。因此，我们将从堆栈中弹出节点4。</li><li id="f953" class="kq kr gx ia b ib kz if la jw lb jy lc ka ld iv lx kw kx ky bi translated">堆栈中的下一个顶部元素是节点2。节点2有<strong class="ia gy"> <em class="hz">节点5作为没有访问过</em> </strong>的相邻顶点，因此，节点5将被压入堆栈。</li><li id="a6c0" class="kq kr gx ia b ib kz if la jw lb jy lc ka ld iv lx kw kx ky bi translated">当前栈顶元素是节点5，节点5有任何相邻的未访问顶点吗？？？不，那我们需要从这里往回走。</li><li id="4564" class="kq kr gx ia b ib kz if la jw lb jy lc ka ld iv lx kw kx ky bi translated">从堆栈中弹出节点5。</li><li id="744f" class="kq kr gx ia b ib kz if la jw lb jy lc ka ld iv lx kw kx ky bi translated">现在堆栈中的顶部元素是节点2。节点2有没有没有被访问过的相邻顶点？？？没有。因此，从堆栈中弹出节点2。</li><li id="5751" class="kq kr gx ia b ib kz if la jw lb jy lc ka ld iv lx kw kx ky bi translated">顶层元素是节点3，与其相邻的节点0、1、2和4都被访问。因此，从堆栈中弹出节点3。</li><li id="73d8" class="kq kr gx ia b ib kz if la jw lb jy lc ka ld iv lx kw kx ky bi translated">现在，顶部元素是节点1，所有与其相邻的顶点都被访问，我们将把它从堆栈中弹出。</li><li id="3902" class="kq kr gx ia b ib kz if la jw lb jy lc ka ld iv lx kw kx ky bi translated">最后，节点0是堆栈中的唯一元素和顶部元素，是否有任何相邻的0顶点仍未被访问？？？不，所以从堆栈中弹出节点0。</li></ol><blockquote class="hu hv hw"><p id="b03b" class="hx hy hz ia b ib ic id ie if ig ih ii ij ik il im in io ip iq ir is it iu iv gq bi translated">当<strong class="ia gy">堆栈变空</strong>时，<strong class="ia gy">指示</strong>我们需要<strong class="ia gy">停止DFS遍历。</strong></p></blockquote><figure class="lm ln lo lp ek lq dy dz paragraph-image"><div class="dy dz mc"><img src="../Images/7ff3d2c1607fd7a85f542683368d6def.png" data-original-src="https://miro.medium.com/v2/resize:fit:1168/format:webp/1*7bUZZzx7fs-2OGurOUfHkg.png"/></div><figcaption class="lt lu ea dy dz lv lw bd b be z ft translated">堆栈转换的快照</figcaption></figure><p id="cbaf" class="pw-post-body-paragraph hx hy gx ia b ib ic id ie if ig ih ii jw ik il im jy io ip iq ka is it iu iv gq bi translated">因此，上图中一个有效的深度优先搜索是:</p><figure class="lm ln lo lp ek lq dy dz paragraph-image"><div class="dy dz ll"><img src="../Images/271eaaade71f51ceb8844d4f7ea19c8a.png" data-original-src="https://miro.medium.com/v2/resize:fit:606/format:webp/1*amXLlvk2RUes975jymfApw.png"/></div><figcaption class="lt lu ea dy dz lv lw bd b be z ft translated">一次有效遍历</figcaption></figure><blockquote class="hu hv hw"><p id="a58a" class="hx hy hz ia b ib ic id ie if ig ih ii ij ik il im in io ip iq ir is it iu iv gq bi translated">基于您选择采用的路径，上面的图<strong class="ia gy">可以有替代的有效遍历。例如，最初，在节点0，如果您选择跟随节点3的路径而不是节点1(如上例所示)，那么遍历将是<strong class="ia gy"> 0 3 …… </strong>并继续！！！</strong></p></blockquote><p id="61d3" class="pw-post-body-paragraph hx hy gx ia b ib ic id ie if ig ih ii jw ik il im jy io ip iq ka is it iu iv gq bi translated">万岁！！！希望你明白深度优先搜索！！！现在让我们看看BFS！！！</p></div><div class="ab cl le lf ge lg" role="separator"><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj"/></div><div class="gq gr gs gt gu"><h1 id="8f9a" class="iw ix gx bd iy iz md jb jc jd me jf jg jh mf jj jk jl mg jn jo jp mh jr js jt bi translated">BFS？？？</h1><p id="1930" class="pw-post-body-paragraph hx hy gx ia b ib ju id ie if jv ih ii jw jx il im jy jz ip iq ka kb it iu iv gq bi translated">这是广度优先，其中一层一层地遍历<strong class="ia gy"> <em class="hz">图</em> </strong>。<strong class="ia gy"> <em class="hz">在移动到下一层</em> </strong>之前，浏览每一层中的所有节点。</p><p id="735f" class="pw-post-body-paragraph hx hy gx ia b ib ic id ie if ig ih ii jw ik il im jy io ip iq ka is it iu iv gq bi translated">实现BFS时，<strong class="ia gy"> <em class="hz">队列用作数据结构</em> </strong>。<strong class="ia gy"> <em class="hz">队列遵循FIFO(先进先出)规则</em> </strong>。为什么是FIFO？？？让我们先讨论一下BFS的规则吧！！！</p><h2 id="e3f3" class="kc ix gx bd iy kd ke kf jc kg kh ki jg jw kj kk jk jy kl km jo ka kn ko js kp bi translated">无向图上的BFS规则</h2><ol class=""><li id="8a13" class="kq kr gx ia b ib ju if jv jw ks jy kt ka ku iv lx kw kx ky bi translated">遍历可以从任意顶点开始(没有具体的规则说这应该是初始顶点/源节点)。</li><li id="6a6c" class="kq kr gx ia b ib kz if la jw lb jy lc ka ld iv lx kw kx ky bi translated">从源节点/根节点，<strong class="ia gy"> <em class="hz">我们需要探索连接到它的所有节点</em> </strong>(所有相邻顶点都要探索)。</li><li id="b691" class="kq kr gx ia b ib kz if la jw lb jy lc ka ld iv lx kw kx ky bi translated">连接到初始节点的节点可以以任何顺序被访问。 </li><li id="5a41" class="kq kr gx ia b ib kz if la jw lb jy lc ka ld iv lx kw kx ky bi translated">当探索连接到特定节点的节点时，必须检查该节点是否未被访问，以插入到队列中。</li></ol><blockquote class="hu hv hw"><p id="aab6" class="hx hy hz ia b ib ic id ie if ig ih ii ij ik il im in io ip iq ir is it iu iv gq bi translated">注意:找出任意节点的<strong class="ia gy">相邻顶点称为对该节点</strong>的<strong class="ia gy">探索！！！</strong></p><p id="3467" class="hx hy hz ia b ib ic id ie if ig ih ii ij ik il im in io ip iq ir is it iu iv gq bi translated">有两种类型的图，<strong class="ia gy">有向图和无向图。</strong></p><p id="78bc" class="hx hy hz ia b ib ic id ie if ig ih ii ij ik il im in io ip iq ir is it iu iv gq bi translated"><strong class="ia gy">有向图</strong>遵循特定的方向，根据该方向遍历该图。每个顶点基于一个方向通向下一个顶点。图上标明了方向！！！</p><p id="bc64" class="hx hy hz ia b ib ic id ie if ig ih ii ij ik il im in io ip iq ir is it iu iv gq bi translated"><strong class="ia gy">无向图<em class="gx"> </em> </strong>没有指定方向，可以向任何方向遍历。</p></blockquote></div><div class="ab cl le lf ge lg" role="separator"><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj"/></div><div class="gq gr gs gt gu"><p id="7d3e" class="pw-post-body-paragraph hx hy gx ia b ib ic id ie if ig ih ii jw ik il im jy io ip iq ka is it iu iv gq bi translated">我们来看一个例子！！！</p><figure class="lm ln lo lp ek lq dy dz paragraph-image"><div class="dy dz ll"><img src="../Images/10b43ad3e03ae94c25e082a41a3b6462.png" data-original-src="https://miro.medium.com/v2/resize:fit:606/format:webp/1*SCy4ciTbz_8wJ6clJijpHg.png"/></div><figcaption class="lt lu ea dy dz lv lw bd b be z ft translated">BFS图</figcaption></figure><h2 id="a3f5" class="kc ix gx bd iy kd ke kf jc kg kh ki jg jw kj kk jk jy kl km jo ka kn ko js kp bi translated">BFS遍历的步骤</h2><ol class=""><li id="bb2f" class="kq kr gx ia b ib ju if jv jw ks jy kt ka ku iv lx kw kx ky bi translated">从任意顶点开始，我们就从顶点0开始。</li><li id="0dbd" class="kq kr gx ia b ib kz if la jw lb jy lc ka ld iv lx kw kx ky bi translated">初始化队列，并将节点0插入队列。</li><li id="7769" class="kq kr gx ia b ib kz if la jw lb jy lc ka ld iv lx kw kx ky bi translated"><strong class="ia gy"> <em class="hz">现在，我们从队列中删除节点0，将其标记为“已访问”。</em>T49】</strong></li><li id="90e4" class="kq kr gx ia b ib kz if la jw lb jy lc ka ld iv lx kw kx ky bi translated">然后，我们将研究与节点0相连或相邻的节点。在这种情况下，节点1和3连接到节点0，因此插入到队列中。这些节点可以以任何顺序插入队列。</li><li id="79ce" class="kq kr gx ia b ib kz if la jw lb jy lc ka ld iv lx kw kx ky bi translated">此时，我们的队列中有节点1和3，因此，根据FIFO规则(删除先插入的节点)，<strong class="ia gy"> <em class="hz">节点1将从队列中删除，并标记为“已访问”。</em>T3】</strong></li><li id="dce4" class="kq kr gx ia b ib kz if la jw lb jy lc ka ld iv lx kw kx ky bi translated">现在，我们需要检查节点1的<strong class="ia gy"> <em class="hz">相邻未访问顶点</em> </strong>。节点1连接到节点0、3、2、6和5。但是<strong class="ia gy"> <em class="hz">节点0已经被访问过</em> </strong>并且<strong class="ia gy"> <em class="hz">节点3已经在队列</em> </strong>中。因此，只有节点2、6和5将被插入队列。</li><li id="ad54" class="kq kr gx ia b ib kz if la jw lb jy lc ka ld iv lx kw kx ky bi translated"><strong class="ia gy"> <em class="hz">节点3被插入到节点1之后的队列中，根据FIFO规则，它有资格从队列中移除并被标记为“已访问”。</em>T19】</strong></li><li id="20fa" class="kq kr gx ia b ib kz if la jw lb jy lc ka ld iv lx kw kx ky bi translated">节点0、1、2和4是节点3的相邻顶点。<strong class="ia gy"> <em class="hz">但是节点0和1被访问，节点2已经在队列中</em> </strong>。因此，只有节点4被插入队列。</li><li id="26f3" class="kq kr gx ia b ib kz if la jw lb jy lc ka ld iv lx kw kx ky bi translated">接下来，<strong class="ia gy"> <em class="hz">节点2将从队列中移除并标记为“已访问”</em> </strong>。</li><li id="4164" class="kq kr gx ia b ib kz if la jw lb jy lc ka ld iv lx kw kx ky bi translated">节点1、3、4和5是节点2的相邻顶点。<strong class="ia gy"> <em class="hz">由于已经访问了节点1和3，并且节点4和5已经在队列</em> </strong>中，所以不必在队列中插入任何内容。因此，<strong class="ia gy"> <em class="hz">要从队列中移除的下一个元素是节点6，并且将被标记为“已访问”。</em> </strong></li><li id="2e91" class="kq kr gx ia b ib kz if la jw lb jy lc ka ld iv lx kw kx ky bi translated">节点6的相邻顶点是节点1和4。<strong class="ia gy"> <em class="hz">节点1已经被访问，节点4已经在队列中</em> </strong>。不需要在队列中插入任何东西，所以我们移动到下一个可以从队列中删除的节点。</li><li id="851e" class="kq kr gx ia b ib kz if la jw lb jy lc ka ld iv lx kw kx ky bi translated">从队列中移除的下一个节点<strong class="ia gy"> <em class="hz">将是节点5，并且将被标记为“已访问”。</em> </strong></li><li id="4168" class="kq kr gx ia b ib kz if la jw lb jy lc ka ld iv lx kw kx ky bi translated">节点5的相邻顶点是节点1和2。<strong class="ia gy"> <em class="hz">由于两个节点都被访问过</em> </strong>，所以队列中没有要插入的内容。</li><li id="da15" class="kq kr gx ia b ib kz if la jw lb jy lc ka ld iv lx kw kx ky bi translated">最后，留在队列中的唯一节点是<strong class="ia gy"> <em class="hz">节点4，它将从队列中移除并标记为“已访问”</em> </strong>。</li></ol><blockquote class="hu hv hw"><p id="9fe6" class="hx hy hz ia b ib ic id ie if ig ih ii ij ik il im in io ip iq ir is it iu iv gq bi translated">现在，队列<strong class="ia gy">为空</strong>和<strong class="ia gy">表明我们需要停止BFS遍历。</strong></p><p id="75be" class="hx hy hz ia b ib ic id ie if ig ih ii ij ik il im in io ip iq ir is it iu iv gq bi translated">我们<strong class="ia gy">跟踪“访问过的”节点</strong>，以便<strong class="ia gy">它们不会被再次访问！！！为此，我们从队列中删除节点，并将它们标记为“已访问”！！！</strong></p><p id="5f2e" class="hx hy hz ia b ib ic id ie if ig ih ii ij ik il im in io ip iq ir is it iu iv gq bi translated">一旦移除，<strong class="ia gy">该节点的相邻的未访问顶点被插入到队列</strong>中。请注意，该节点的任何未被访问但<strong class="ia gy">已经在队列</strong>中的相邻顶点不得再次插入队列！！！</p></blockquote><p id="a1f2" class="pw-post-body-paragraph hx hy gx ia b ib ic id ie if ig ih ii jw ik il im jy io ip iq ka is it iu iv gq bi translated">下图说明了队列在BFS遍历中的状态！！！</p><figure class="lm ln lo lp ek lq dy dz paragraph-image"><div class="dy dz mi"><img src="../Images/9bdef393f701e316054681531cd987dd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1294/format:webp/1*migYsMQH5Ct2MxC9GaMbIg.png"/></div><figcaption class="lt lu ea dy dz lv lw bd b be z ft translated">队列状态</figcaption></figure><p id="9f50" class="pw-post-body-paragraph hx hy gx ia b ib ic id ie if ig ih ii jw ik il im jy io ip iq ka is it iu iv gq bi translated">因此，上图的一个有效的广度优先搜索是:</p><figure class="lm ln lo lp ek lq dy dz paragraph-image"><div class="dy dz mj"><img src="../Images/9d2bb6321af7dd77cb8d466b2647f636.png" data-original-src="https://miro.medium.com/v2/resize:fit:568/format:webp/1*-FVW0S65Mx0d4Y2sDh3mCg.png"/></div><figcaption class="lt lu ea dy dz lv lw bd b be z ft translated">一次有效遍历</figcaption></figure><blockquote class="hu hv hw"><p id="d4dc" class="hx hy hz ia b ib ic id ie if ig ih ii ij ik il im in io ip iq ir is it iu iv gq bi translated">根据你将一个节点的相邻顶点插入队列的顺序，上面的图<strong class="ia gy">可以有替代的有效遍历，例如，最初，在节点0，如果你选择将节点3和1插入队列，按照顺序3和1，那么遍历将是0 3 1…等等！！！</strong></p></blockquote><p id="0ddc" class="pw-post-body-paragraph hx hy gx ia b ib ic id ie if ig ih ii jw ik il im jy io ip iq ka is it iu iv gq bi translated">希望你明白广度优先搜索！！！</p><p id="bc19" class="pw-post-body-paragraph hx hy gx ia b ib ic id ie if ig ih ii jw ik il im jy io ip iq ka is it iu iv gq bi translated">如果你有兴趣，请查看我的<a class="ae mk" href="https://github.com/Lakshikuga/Krish-training/tree/main/BFSDFS" rel="noopener ugc nofollow" target="_blank"> GitHub </a>关于BFS和DFS的实现！！！</p><p id="945e" class="pw-post-body-paragraph hx hy gx ia b ib ic id ie if ig ih ii jw ik il im jy io ip iq ka is it iu iv gq bi translated">快乐学习！！！</p></div><div class="ab cl le lf ge lg" role="separator"><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj"/></div><div class="gq gr gs gt gu"><h1 id="d7c7" class="iw ix gx bd iy iz md jb jc jd me jf jg jh mf jj jk jl mg jn jo jp mh jr js jt bi translated">参考</h1><ol class=""><li id="9c29" class="kq kr gx ia b ib ju if jv jw ks jy kt ka ku iv lx kw kx ky bi translated"><a class="ae mk" href="https://www.youtube.com/watch?v=aMCI4AqVUug" rel="noopener ugc nofollow" target="_blank">https://www.youtube.com/watch?v=aMCI4AqVUug</a></li><li id="884f" class="kq kr gx ia b ib kz if la jw lb jy lc ka ld iv lx kw kx ky bi translated"><a class="ae mk" href="https://www.youtube.com/watch?v=vf-cxgUXcMk" rel="noopener ugc nofollow" target="_blank">https://www.youtube.com/watch?v=vf-cxgUXcMk</a></li></ol></div></div>    
</body>
</html>