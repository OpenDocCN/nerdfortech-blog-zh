<html>
<head>
<title>Managing Data in Containers</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">管理容器中的数据</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/managing-data-in-containers-bc49cefadab2?source=collection_archive---------0-----------------------#2022-05-05">https://medium.com/nerd-for-tech/managing-data-in-containers-bc49cefadab2?source=collection_archive---------0-----------------------#2022-05-05</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="294d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们在本地机器上有代码和它的环境(例如节点依赖)。我们创建一个docker文件，并指示他们创建一个图像。映像是只读的，它在代码创建的特定时间拍摄代码的快照。因此我们需要容器来运行它们。永远记住这样一个事实，即<em class="jd">容器在它们上面添加了一个额外的层，而不是从它被创建的映像</em>中复制代码。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es je"><img src="../Images/b02f12699f99a8958daacdf610adb530.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*PHxlNIbbtpPIdU37.png"/></div></div></figure><ol class=""><li id="ac1b" class="jq jr hi ih b ii ij im in iq js iu jt iy ju jc jv jw jx jy bi translated">一旦我们创建了<strong class="ih hj">图像</strong>和<strong class="ih hj">容器</strong>，它们将从本地机器中隔离出来</li><li id="288d" class="jq jr hi ih b ii jz im ka iq kb iu kc iy kd jc jv jw jx jy bi translated">图像是只读的——我们不能重写图像中的代码</li><li id="ed6d" class="jq jr hi ih b ii jz im ka iq kb iu kc iy kd jc jv jw jx jy bi translated">容器是图像之上的一个读写层</li></ol><h1 id="b17c" class="ke kf hi bd kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb bi translated">但是等等！容器中的书写层来自哪里？</h1><p id="cf8f" class="pw-post-body-paragraph if ig hi ih b ii lc ik il im ld io ip iq le is it iu lf iw ix iy lg ja jb jc hb bi translated">答案来自代码本身。说一个类似登录表单和注册表单的代码。当我们通过提供详细信息注册到网站时，它将进入数据库并被保存。然后，它将创建一个像脸书注册定制的个人资料网址。</p><p id="1801" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这里的问题是从永久数据演变而来的，因为到目前为止，我们已经看到了存储临时数据的方法，这些临时数据在创建容器时会派上用场并且是默认的。但是对于永久数据，我们需要另一种工具来填补丢失数据的空白。</p><p id="6b82" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这个工具必须找到连接到本地机器/主机的方法，因为这是永久性的。docker领域中的这些工具被称为<strong class="ih hj">卷和绑定挂载。</strong></p><blockquote class="lh li lj"><p id="d0d2" class="if ig jd ih b ii ij ik il im in io ip lk ir is it ll iv iw ix lm iz ja jb jc hb bi translated"><strong class="ih hj"> <em class="hi">卷是主机硬盘上的文件夹，映射到docker容器内的文件夹。</em>T15】</strong></p><p id="dc5c" class="if ig jd ih b ii ij ik il im in io ip lk ir is it ll iv iw ix lm iz ja jb jc hb bi translated"><strong class="ih hj">因为是主机中的文件夹，所以是永久的<em class="hi">。与容器的连接使它们之间能够通信</em> </strong></p></blockquote><p id="3c4f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们遇到的问题叫做<strong class="ih hj">数据持久化。</strong>有些数据需要在容器被移除后仍然可用。这是通过与本地计算机文件夹建立连接来完成的。</p><p id="d85c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">当你创建一个图像时，给指令<strong class="ih hj"> <em class="jd">卷[“任意docker文件夹”] </em> </strong>。该指令将连接到只有Docker知道的本地机器文件夹。<em class="jd">因此，卷完全由docker管理，并与所有本地机器进程隔离</em>。</p><p id="b01e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">当你运行一个基于镜像的容器(有volume指令)时，就会创建一个VOLUME，这个名字是docker自己随机给定的——这叫做<strong class="ih hj">匿名Volume </strong>。</p><p id="3232" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">因为匿名卷是由docker自动创建的，所以它被绑定到一个特定的容器，一旦该容器被删除，它就会自动删除(<strong class="ih hj"> — rm命令</strong>)</p><p id="f32c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">因为我们对跨所有容器的数据持久性感兴趣，所以我们需要找到一种方法，即使容器被删除，也不要删除卷。这是在<strong class="ih hj">命名卷</strong>的帮助下完成的。因此，在创建容器时，添加一个命令。即使在移除容器后，该卷仍会存在</p><p id="cfea" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="jd">注意:命名卷和匿名卷都有用例</em></p><p id="3504" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">由于卷完全由docker本身控制，我们的本地更改不会反映在docker文件系统中——无论如何，这都是我们想要的隔离。</p><p id="2f00" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">但是在开发过程中，我们不能每次修改源代码都创建新的映像。这是在<strong class="ih hj">绑定坐骑的帮助下完成的。</strong>在此给出指令中的绝对路径，而不是卷名-</p><pre class="jf jg jh ji fd ln lo lp lq aw lr bi"><span id="09e6" class="ls kf hi lo b fi lt lu l lv lw">'-v [local machine folder]:['container folder that needs to be connected to local machine']</span></pre><p id="741f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">绑定挂载并不完全由docker本身控制，因为我们有意将本地机器文件夹附加到容器上。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div class="er es lx"><img src="../Images/e70bd0d4bf1339ec5fe42d12ae695a38.png" data-original-src="https://miro.medium.com/v2/resize:fit:1004/format:webp/0*Z7JmDvXnTl8H8sp6.png"/></div><figcaption class="ly lz et er es ma mb bd b be z dx translated">来源:Docker网站</figcaption></figure><p id="39d0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">重述</strong>:</p><p id="9ca8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="jd">容器是读写的——它们在图像</em>上添加一个薄的 <strong class="ih hj"> <em class="jd">读写层</em> </strong> <em class="jd"/></p><p id="cfa7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="jd">容器移除后容器数据无法持久化— </em> <strong class="ih hj"> <em class="jd">卷</em> </strong> <em class="jd">为解决方案</em></p><p id="d704" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="jd">容器无法与主机文件系统交互— </em> <strong class="ih hj"> <em class="jd">绑定挂载</em> </strong> <em class="jd">是解决方案</em></p></div><div class="ab cl mc md gp me" role="separator"><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh"/></div><div class="hb hc hd he hf"><p id="be16" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="jd">原载于2022年5月5日https://www.pansofarjun.com</em><a class="ae mj" href="https://www.pansofarjun.com/post/managing-data-in-containers" rel="noopener ugc nofollow" target="_blank"><em class="jd"/></a><em class="jd">。</em></p></div></div>    
</body>
</html>