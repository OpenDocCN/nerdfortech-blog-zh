<html>
<head>
<title>Asynchronous PHP With Revoltphp &amp; Vonage Voice API</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">带有Revoltphp &amp; Vonage语音API的异步PHP</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/asynchronous-php-with-revoltphp-vonage-voice-api-a505c672aa2b?source=collection_archive---------0-----------------------#2022-01-28">https://medium.com/nerd-for-tech/asynchronous-php-with-revoltphp-vonage-voice-api-a505c672aa2b?source=collection_archive---------0-----------------------#2022-01-28</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/a0083a373993dfbd8726f913579ef214.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hvH_tGGnwQ_gpfWSJvJE8g.png"/></div></div></figure><p id="7374" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">一些读者可能会感到惊讶，异步PHP并不是什么新鲜事。PHP5.5早在2014年就引入了生成器，让我们走上了这条道路，从那时起，我们已经看到了<a class="ae jo" href="https://amphp.org/" rel="noopener ugc nofollow" target="_blank"> amphp </a>、<a class="ae jo" href="https://reactphp.org/" rel="noopener ugc nofollow" target="_blank"> ReactPhp </a>和<a class="ae jo" href="https://www.swoole.co.uk/" rel="noopener ugc nofollow" target="_blank">opens wole</a>的创建。</p><h1 id="3601" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">你好，纤维！</h1><p id="7171" class="pw-post-body-paragraph iq ir hi is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hb bi translated">PHP开发人员倾向于不考虑异步编程，因为我们习惯于处理请求/响应生命周期的本质(封装状态)。发生的一些事情可能会改变这一点:<a class="ae jo" href="https://wiki.php.net/rfc/fibers" rel="noopener ugc nofollow" target="_blank">将原生纤维引入PHP8.1 </a>。虽然纤程可能不是“真正的”异步执行，而像<a class="ae jo" href="https://nodejs.org/en/" rel="noopener ugc nofollow" target="_blank"> node.js </a>和<a class="ae jo" href="https://golang.org/" rel="noopener ugc nofollow" target="_blank"> Go </a>这样的运行时是，但如果在没有任何阻塞I/O的情况下执行，它肯定会给你带来巨大的性能提升。</p><h1 id="7971" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">你好，RevoltPhp！</h1><p id="49d7" class="pw-post-body-paragraph iq ir hi is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hb bi translated">一个新的项目已经在PHP8.1发布后创建，<a class="ae jo" href="https://revolt.run/" rel="noopener ugc nofollow" target="_blank">revert PHP</a>，这是amphp &amp; ReactPhp的创建者的合作，旨在将他们在协同例程中的经验用于利用新的纤程特性。虽然最好把它看作是一个“底层库”,供框架在其上使用(读/写流回调之类的概念可能很难导航)，但我将向您展示如何学习这个概念的一个小尝试。</p><h1 id="cb59" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">紧急情况！资产失控！</h1><figure class="kt ku kv kw fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ks"><img src="../Images/766c646a61406870ee52c989570a433c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jDhpm159BcmJAplFmlzASA.jpeg"/></div></div></figure><p id="ddac" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">好的，我的意思是我将介绍我们的用例，但我喜欢有时有点戏剧性。假设我们有现实世界的恐龙公园。当一只暴怒的食人蜥蜴逃出围栏时，需要通知员工。事实是，通信系统是用编写的，因此从技术上来说，它是一种阻塞式I/O语言。您需要使用Vonage同时呼叫2000名公园工作人员，并发出文本到语音的警告，对吗？让我们开始创建一个异步代码线程。</p><h1 id="9549" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">设置:PHP 8.1，Composer，Slim，ngrok，Vonage，RevoltPhp</h1><h2 id="787e" class="kx jq hi bd jr ky kz la jv lb lc ld jz jb le lf kd jf lg lh kh jj li lj kl lk bi translated">PHP 8.1</h2><p id="9b09" class="pw-post-body-paragraph iq ir hi is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hb bi translated">为此你需要PHP 8.1，这还没有正式发布。Mac用户可以在<a class="ae jo" href="https://github.com/shivammathur/homebrew-php" rel="noopener ugc nofollow" target="_blank"> shivammathur的家酿库</a>下找到，Linux用户可以在<a class="ae jo" href="https://launchpad.net/~ondrej/+archive/ubuntu/php/" rel="noopener ugc nofollow" target="_blank"> ondrej的apt PPA </a>上找到，Windows用户可以在<a class="ae jo" href="https://windows.php.net/qa/" rel="noopener ugc nofollow" target="_blank"> PHP for Windows </a>的QA版块上找到。</p><h2 id="7cd6" class="kx jq hi bd jr ky kz la jv lb lc ld jz jb le lf kd jf lg lh kh jj li lj kl lk bi translated">设计者</h2><p id="dcc8" class="pw-post-body-paragraph iq ir hi is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hb bi translated">我们需要composer，PHP事实上的依赖管理器，所以<a class="ae jo" href="https://getcomposer.org/doc/00-intro.md#installation-linux-unix-macos" rel="noopener ugc nofollow" target="_blank">如果你还没有得到它，请按照这里的安装说明</a>来做。</p><h2 id="6b6c" class="kx jq hi bd jr ky kz la jv lb lc ld jz jb le lf kd jf lg lh kh jj li lj kl lk bi translated">项目空间</h2><p id="b4f5" class="pw-post-body-paragraph iq ir hi is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hb bi translated">以下需求将需要您的项目空间，因此创建一个新的目录来存放代码，并使用composer创建一个<code class="du ll lm ln lo b">composer.json</code>配置。为此，请在空白目录中运行以下命令:</p><p id="a032" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><code class="du ll lm ln lo b">composer init</code></p><h2 id="a873" class="kx jq hi bd jr ky kz la jv lb lc ld jz jb le lf kd jf lg lh kh jj li lj kl lk bi translated">纤细的骨架</h2><p id="4618" class="pw-post-body-paragraph iq ir hi is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hb bi translated">为了让真正的非阻塞事件循环<em class="lp">和</em>拥有HTTP请求处理，您可能希望使用类似于<a class="ae jo" href="https://reactphp.org/http/" rel="noopener ugc nofollow" target="_blank"> ReactPhp的HTTP客户端</a>的东西。不过对于这个例子，我们需要为语音API处理打开一些路径，而<a class="ae jo" href="https://www.slimframework.com/" rel="noopener ugc nofollow" target="_blank"> Slim </a>是一种快速的方法。为了得到它，我们使用composer:</p><p id="4ea4" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><code class="du ll lm ln lo b">composer require slim/slim</code></p><p id="0924" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们还需要一个PSR-7兼容的库来处理请求/响应(我已经用了Guzzle的，但是有几个选项可用):</p><p id="1d28" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><code class="du ll lm ln lo b">composer require guzzlehttp/psr7</code></p><h2 id="7642" class="kx jq hi bd jr ky kz la jv lb lc ld jz jb le lf kd jf lg lh kh jj li lj kl lk bi translated">ngrok</h2><p id="42dc" class="pw-post-body-paragraph iq ir hi is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hb bi translated">如果你以前没有遇到过ngrok ，它是一个超级有用的工具，可以创建安全的URL隧道进入你的本地主机。我们需要这个来让Vonage的网钩工作。查看这里的<a class="ae jo" href="https://ngrok.com/download" rel="noopener ugc nofollow" target="_blank">安装说明</a>并为自己创建一个帐户。</p><h2 id="0fe5" class="kx jq hi bd jr ky kz la jv lb lc ld jz jb le lf kd jf lg lh kh jj li lj kl lk bi translated">Vonage语音API</h2><p id="94e3" class="pw-post-body-paragraph iq ir hi is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hb bi translated">Vonage为发送和接收调用提供了一个全功能的API，所以我们将使用核心的<a class="ae jo" href="https://github.com/Vonage/vonage-php-sdk-core" rel="noopener ugc nofollow" target="_blank"> PHP SDK </a>来发送出站调用。用composer安装它:</p><p id="93ca" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><code class="du ll lm ln lo b">composer require vonage/client-core</code></p><h1 id="8d9c" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">RevoltPhp</h1><p id="0e91" class="pw-post-body-paragraph iq ir hi is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hb bi translated">最后，我们需要从RevoltPhp获取事件循环。它目前仍然是预发布的，所以您需要指定dev分支:</p><p id="dbae" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><code class="du ll lm ln lo b">composer require revolt/event-loop:dev-main</code></p><h1 id="c23d" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">设置Vonage应用程序和号码</h1><p id="7d5e" class="pw-post-body-paragraph iq ir hi is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hb bi translated">要创建呼出电话来警告幸福无知的公园工作人员海湾的危险，你需要相应地设置你的Vonage帐户。</p><h1 id="0cc9" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">Vonage API帐户</h1><p id="4498" class="pw-post-body-paragraph iq ir hi is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hb bi translated">要完成本教程，您将需要一个<a class="ae jo" href="http://developer.nexmo.com/ed?c=blog_text&amp;ct=2021-11-12-asyncronous-php-with-revoltphp-vonage-voice-api" rel="noopener ugc nofollow" target="_blank"> Vonage API帐户</a>。如果您还没有，您可以今天就<a class="ae jo" href="http://developer.nexmo.com/ed?c=blog_text&amp;ct=2021-11-12-asyncronous-php-with-revoltphp-vonage-voice-api" rel="noopener ugc nofollow" target="_blank">注册</a>并开始使用免费信用点数进行构建。一旦你有了一个帐户，你可以在<a class="ae jo" href="http://developer.nexmo.com/ed?c=blog_text&amp;ct=2021-11-12-asyncronous-php-with-revoltphp-vonage-voice-api" rel="noopener ugc nofollow" target="_blank"> Vonage API仪表板</a>的顶部找到你的API密匙和API秘密。</p><p id="f4b3" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">本教程还使用了一个虚拟电话号码。要购买号码，请前往<em class="lp">号码</em> &gt; <em class="lp">购买号码</em>并搜索符合您需求的号码。</p><figure class="kt ku kv kw fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/941d1ebad7252085aa9c1e88f9dc18f8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9RUNrmWVrhuK9uZKQ1igZA.png"/></div></div></figure><p id="ae83" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">创建一个启用语音功能的新应用程序，并下载应用程序密钥。</p><h1 id="49b1" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">打那个电话！</h1><p id="7adc" class="pw-post-body-paragraph iq ir hi is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hb bi translated">好了，让我们开始Slim应用程序。在项目路径中创建一个名为<code class="du ll lm ln lo b">/public</code>的目录，并在其中创建一个名为<code class="du ll lm ln lo b">index.php</code>的新php文件。我们的文件将如下所示:</p><figure class="kt ku kv kw fd ij"><div class="bz dy l di"><div class="lq lr l"/></div></figure><p id="d597" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这里有很多东西需要消化，所以我们来分解一下。</p><p id="863a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">首先，我们使用我们之前创建的应用程序凭证来设置我们的Vonage客户端，使用一个<code class="du ll lm ln lo b">Keypair</code>对象并读入您下载的SSH密钥作为第一个参数，应用程序ID作为第二个参数:</p><figure class="kt ku kv kw fd ij"><div class="bz dy l di"><div class="lq lr l"/></div></figure><p id="2b86" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">接下来，我们通过使用<a class="ae jo" href="https://github.com/FakerPHP/Faker/" rel="noopener ugc nofollow" target="_blank"> faker </a>库模拟要调用的电话号码的有效载荷，该库被设置为一个名为<code class="du ll lm ln lo b">$phoneNumbers</code>的变量。</p><figure class="kt ku kv kw fd ij"><div class="bz dy l di"><div class="lq lr l"/></div></figure><p id="0b40" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">Faker允许您设置区域设置，所以在这种情况下，我选择了英国数字，将其设置为' en_GB '。如果你想设置一个不同的地区，<a class="ae jo" href="https://fakerphp.github.io/" rel="noopener ugc nofollow" target="_blank">在这里</a>看一下faker文档。</p><p id="ace5" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们使用一个经典的<code class="du ll lm ln lo b">for</code>循环将电话号码创建到一个数组中，所以我们现在有2000个电话号码准备接收恐龙警告。我们怎么做呢？终点有一个<code class="du ll lm ln lo b">foreach</code>回路:</p><figure class="kt ku kv kw fd ij"><div class="bz dy l di"><div class="lq lr l"/></div></figure><blockquote class="ls lt lu"><p id="9811" class="iq ir lp is b it iu iv iw ix iy iz ja lv jc jd je lw jg jh ji lx jk jl jm jn hb bi translated">本教程是模拟一个例子，所以不要运行这个现场！原因是将会产生2000个假电话号码，Vonage将会尝试给所有的号码打电话！</p></blockquote><p id="c245" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">因此，我们的应用程序有了一个终点。它将循环通过所有要呼叫的电话号码，但是需要两件事情来完成我们的<strong class="is hj">同步</strong>警告。你看到上面代码中的<code class="du ll lm ln lo b">setAnswerWebhook()</code>方法了吗？好吧，一旦我们打出那个电话，沃纳治需要知道怎么处理它。这就是ngrok和我们的webhooks的用武之地。</p><h1 id="ee06" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">接通电话</h1><p id="39da" class="pw-post-body-paragraph iq ir hi is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hb bi translated">Ngrok会打开一个隧道，当你启动它的时候会给你一个本地主机的URL。PHP有一个内置的web服务器，所以我们将把它用于localhost，然后启动ngrok来打开隧道。在我们创建的<code class="du ll lm ln lo b">public</code>目录中，启动内置的PHP web服务器:</p><figure class="kt ku kv kw fd ij"><div class="bz dy l di"><div class="lq lr l"/></div></figure><p id="3882" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们机器上的端口8000现已开放，所以输入以下命令让ngrok隧道它:</p><figure class="kt ku kv kw fd ij"><div class="bz dy l di"><div class="lq lr l"/></div></figure><p id="0ed5" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如果一切顺利，您将得到如下回应:</p><figure class="kt ku kv kw fd ij er es paragraph-image"><div class="er es ly"><img src="../Images/78980e90937ebfe7b9f86b53fbd0772a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1264/format:webp/1*IfiybdI1QMkymrT77RdSDQ.png"/></div></figure><p id="b0de" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">它提供的URL需要添加到您的Vonage应用程序中。在仪表板上导航到您的Vonage应用程序，然后点击编辑。在编辑应用程序面板中，您可以为来电设置语音网络挂钩；获取ngrok URL，并添加我们在PHP代码中设置webhooks时放置占位符的路径。例如，如果ngrok创建了URL <code class="du ll lm ln lo b">https://aef9-82-30-208-179.ngrok.io</code>，我们将把我们的webhook URLs改为</p><ul class=""><li id="718c" class="lz ma hi is b it iu ix iy jb mb jf mc jj md jn me mf mg mh bi translated"><a class="ae jo" href="https://aef9-82-30-208-179.ngrok.io/webhooks/answer" rel="noopener ugc nofollow" target="_blank">https://aef9-82-30-208-179.ngrok.io/webhooks/answer</a></li><li id="3c47" class="lz ma hi is b it mi ix mj jb mk jf ml jj mm jn me mf mg mh bi translated"><a class="ae jo" href="https://aef9-82-30-208-179.ngrok.io/webhooks/event" rel="noopener ugc nofollow" target="_blank">https://aef9-82-30-208-179.ngrok.io/webhooks/event</a></li></ul><p id="d235" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">以下是您在Vonage仪表板中编辑它们的位置:</p><figure class="kt ku kv kw fd ij er es paragraph-image"><div class="er es ly"><img src="../Images/78980e90937ebfe7b9f86b53fbd0772a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1264/format:webp/1*IfiybdI1QMkymrT77RdSDQ.png"/></div></figure><p id="edb6" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">然后，我们更改我们的PHP代码，当设置webhooks时，我们的路由现在看起来像这样:</p><figure class="kt ku kv kw fd ij"><div class="bz dy l di"><div class="lq lr l"/></div></figure><h1 id="088e" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">设置警告</h1><p id="996d" class="pw-post-body-paragraph iq ir hi is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hb bi translated">我们将发布一条新路线的恐龙警告，答案webhook指向这条路线。为了使用Vonage文本到语音转换，我们使用了一个叫做<code class="du ll lm ln lo b">NCCO object</code>的东西，这是一个JSON对象的专有名词，它控制如何处理调用。将以下路线添加到您的<code class="du ll lm ln lo b">index.php</code>:</p><figure class="kt ku kv kw fd ij"><div class="bz dy l di"><div class="lq lr l"/></div></figure><p id="2c53" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">NCCO对象是作为对webhook的JSON响应给出的，所以Vonage知道如何处理它——在这种情况下，您选择的<code class="du ll lm ln lo b">language</code>和<code class="du ll lm ln lo b">style</code>将读出您选择的<code class="du ll lm ln lo b">text</code>。</p><h1 id="32d3" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">回到异步与同步</h1><p id="ba77" class="pw-post-body-paragraph iq ir hi is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hb bi translated">我们有一个呼出电话的端点，当人们接听紧急电话时，我们有一个回复。但是，本文的重点是关于异步代码，对吗？我们的紧急端点，当在运行时被击中时，将同步循环通过每个号码并拨打它；那就是PHP。所以，现在是纤维的时候了。</p><h1 id="29be" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">介绍RevoltPhp</h1><p id="67d0" class="pw-post-body-paragraph iq ir hi is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hb bi translated">RevoltPhp的事件循环将继续执行任何工作，直到没有更多的工作要做，并将控制权交还给父线程(这通常是应用程序的终止，因为对于非阻塞I/O PHP应用程序，我们希望<code class="du ll lm ln lo b">EventLoop</code>到<em class="lp">永远不会耗尽工作)。</em></p><p id="c539" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在我们的例子中，我们的出站调用目前是同步的，并且阻塞在<code class="du ll lm ln lo b">foreach</code>循环中。我们想在不可避免的混乱发生之前立刻通知所有2000名公园员工。</p><p id="3c58" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">RevoltPhp的事件循环定义了<code class="du ll lm ln lo b">EventLoop</code>类将执行的六个核心回调:</p><ul class=""><li id="4078" class="lz ma hi is b it iu ix iy jb mb jf mc jj md jn me mf mg mh bi translated"><strong class="is hj">延期</strong></li></ul><blockquote class="ls lt lu"><p id="9dfd" class="iq ir lp is b it iu iv iw ix iy iz ja lv jc jd je lw jg jh ji lx jk jl jm jn hb bi translated">回调在事件循环的下一次迭代中执行。如果安排了延迟，事件循环不会在迭代之间等待。</p></blockquote><ul class=""><li id="bfb8" class="lz ma hi is b it iu ix iy jb mb jf mc jj md jn me mf mg mh bi translated"><strong class="is hj">延迟</strong></li></ul><blockquote class="ls lt lu"><p id="670f" class="iq ir lp is b it iu iv iw ix iy iz ja lv jc jd je lw jg jh ji lx jk jl jm jn hb bi translated">回调在指定的秒数后执行。几分之一秒可以用浮点数表示。</p></blockquote><ul class=""><li id="c1b7" class="lz ma hi is b it iu ix iy jb mb jf mc jj md jn me mf mg mh bi translated"><strong class="is hj">重复</strong></li></ul><blockquote class="ls lt lu"><p id="ea83" class="iq ir lp is b it iu iv iw ix iy iz ja lv jc jd je lw jg jh ji lx jk jl jm jn hb bi translated">回调在指定的秒数后重复执行。几分之一秒可以用浮点数表示。</p></blockquote><ul class=""><li id="7c8f" class="lz ma hi is b it iu ix iy jb mb jf mc jj md jn me mf mg mh bi translated"><strong class="is hj">流可读</strong></li></ul><blockquote class="ls lt lu"><p id="9fe9" class="iq ir lp is b it iu iv iw ix iy iz ja lv jc jd je lw jg jh ji lx jk jl jm jn hb bi translated">当流中有数据要读取，或者连接关闭时，就会执行回调。</p></blockquote><ul class=""><li id="3f33" class="lz ma hi is b it iu ix iy jb mb jf mc jj md jn me mf mg mh bi translated"><strong class="is hj">流可写</strong></li></ul><blockquote class="ls lt lu"><p id="b706" class="iq ir lp is b it iu iv iw ix iy iz ja lv jc jd je lw jg jh ji lx jk jl jm jn hb bi translated">当写缓冲区中有足够的空间来接受要写入的新数据时，就会执行回调。</p></blockquote><ul class=""><li id="edbb" class="lz ma hi is b it iu ix iy jb mb jf mc jj md jn me mf mg mh bi translated"><strong class="is hj">信号</strong></li></ul><blockquote class="ls lt lu"><p id="67d1" class="iq ir lp is b it iu iv iw ix iy iz ja lv jc jd je lw jg jh ji lx jk jl jm jn hb bi translated">当进程收到来自操作系统的特定信号时，回调被执行。"</p></blockquote><p id="0776" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">好的，我们需要在我们的路径中创建回调。根据我们的需求，我们将需要<code class="du ll lm ln lo b">repeat</code>回调。它看起来是这样的:</p><figure class="kt ku kv kw fd ij"><div class="bz dy l di"><div class="lq lr l"/></div></figure><p id="8100" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">Woah！那么这是什么？</p><h1 id="8539" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">事件循环</h1><p id="d16c" class="pw-post-body-paragraph iq ir hi is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hb bi translated"><code class="du ll lm ln lo b">EventLoop::run();</code>只要还有工作就会继续工作<em class="lp">。因此，我们正在用静态回调创建<code class="du ll lm ln lo b">EventLoop::repeat()</code>来创建一个工作负载。以下是它的主要部分:</em></p><ul class=""><li id="5ba7" class="lz ma hi is b it iu ix iy jb mb jf mc jj md jn me mf mg mh bi translated">回调的第一个参数是0，因为这是我们想要的迭代间隔的浮点数。请不要拖延，我们有恐龙在外面！</li><li id="7320" class="lz ma hi is b it mi ix mj jb mk jf ml jj mm jn me mf mg mh bi translated">第二个是我们的回调一代——我们得到了用于纤程管理的<code class="du ll lm ln lo b">callbackID</code>。</li><li id="01c3" class="lz ma hi is b it mi ix mj jb mk jf ml jj mm jn me mf mg mh bi translated">变量<code class="du ll lm ln lo b">$static</code>记录有多少回调被创建。它被用作<code class="du ll lm ln lo b">$phoneNumbers</code>的索引，所以一旦我们没有更多的数据，<code class="du ll lm ln lo b">isset($phoneNumbers[$i])</code>为假，所以我们用回调ID取消事件循环作为参考。</li></ul><p id="ba67" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这是代码部分，但在引擎盖下发生了什么？最后，我们得到:</p><h1 id="207f" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">异步PHP</h1><p id="d3c4" class="pw-post-body-paragraph iq ir hi is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hb bi translated">与传统的PHP同步操作不同，从事件循环运行的那一刻起，封装的<code class="du ll lm ln lo b">repeat</code>回调就遍布PHP的运行时纤程。这是用纤程触发的2000个调用，而不是同步执行。从PHP开发人员的角度来看，有趣的是，这是在没有一些常见的工程方法来分散负载的情况下完成的，例如使用<a class="ae jo" href="https://laravel.com/docs/8.x/queues" rel="noopener ugc nofollow" target="_blank"> Laravel </a>作业/队列工作器或无服务器架构，其中<a class="ae jo" href="https://bref.sh/" rel="noopener ugc nofollow" target="_blank"> Bref </a>绑定到<a class="ae jo" href="https://cloud.google.com/compute" rel="noopener ugc nofollow" target="_blank">谷歌云计算</a>或<a class="ae jo" href="https://aws.amazon.com/lambda/" rel="noopener ugc nofollow" target="_blank"> AWS Lambda </a>。这些都是非常好的方法，但是这里的要点是我们的方法<strong class="is hj">是普通的PHP </strong>。</p><p id="cfca" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">多亏了Vonage和RevoltPhp，我们可以更快地称之为“安全”,多亏了我们公园工作人员的不懈努力，我们才可以尽快将这些资产纳入控制范围。</p></div><div class="ab cl mn mo gp mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="hb hc hd he hf"><p id="00fe" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><em class="lp">最初发布于</em><a class="ae jo" href="https://learn.vonage.com/blog/2021/11/12/asyncronous-php-with-revoltphp-vonage-voice-api/" rel="noopener ugc nofollow" target="_blank"><em class="lp">https://learn . vonage . com/blog/2021/11/12/async ronous-PHP-with-revolt PHP-vonage-voice-API/</em></a></p></div></div>    
</body>
</html>