<html>
<head>
<title>Airflow Catchup &amp; Backfill — Demystified</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">气流收集和回填——揭秘</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/airflow-catchup-backfill-demystified-355def1b6f92?source=collection_archive---------0-----------------------#2021-01-26">https://medium.com/nerd-for-tech/airflow-catchup-backfill-demystified-355def1b6f92?source=collection_archive---------0-----------------------#2021-01-26</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="9593" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在我之前的<a class="ae jd" rel="noopener" href="/nerd-for-tech/airflow-mwaa-automating-etl-for-a-data-warehouse-f5e50d14713c">博客</a>中，我们讨论了气流的基本原理。这个博客将涵盖一些先进的话题。</p><p id="0529" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">气流允许再次调度错过的 DAG 运行，以便管道赶上由于某种原因错过的调度。它还允许手动重新运行回溯日期的 Dag，并回填这些运行。回填和追赶乍一看令人困惑。在这个博客中，我们将理解这些概念。但是在我们开始这些之前，我们需要刷新“开始日期”和“执行日期”。</p><h2 id="dc06" class="je jf hi bd jg jh ji jj jk jl jm jn jo iq jp jq jr iu js jt ju iy jv jw jx jy bi translated">开始日期和执行日期</h2><blockquote class="jz ka kb"><p id="8ae5" class="if ig kc ih b ii ij ik il im in io ip kd ir is it ke iv iw ix kf iz ja jb jc hb bi translated"><strong class="ih hj">开始日期</strong> — <em class="hi">开始计划 DAG 的日期</em></p><p id="8b80" class="if ig kc ih b ii ij ik il im in io ip kd ir is it ke iv iw ix kf iz ja jb jc hb bi translated"><strong class="ih hj"> schedule_interval </strong> — <em class="hi">距离我们希望 DAG 被触发的最小 start_date 的时间间隔。</em></p></blockquote><figure class="kh ki kj kk fd kl er es paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="er es kg"><img src="../Images/d754ad57c58a9baf62511f51fa5024e5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TsnJxK33JUNKTw-PNYTnqQ.png"/></div></div></figure><p id="3197" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">对于来自 2021 年 1 月 1 日至 26 日 05:00:00 的数据，开始日期为 2021 年 1 月 1 日至 26 日 06:00:00 UTC 且计划间隔为 1 小时的 DAG 实际执行时间为 2021 年 1 月 1 日至 26 日 05:00:00。</p><pre class="kh ki kj kk fd ks kt ku kv aw kw bi"><span id="ad73" class="je jf hi kt b fi kx ky l kz la">Trigger Point → start_date + { schedule_interval } → till the end.</span></pre><figure class="kh ki kj kk fd kl er es paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="er es lb"><img src="../Images/bfdd965f26d1811fbf75572f58153678.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2Ve1S0JTTgE9cxzhuQ-tbQ.png"/></div></div></figure><p id="cc44" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">执行日期是需要处理数据的期间的开始。</p><h2 id="35e5" class="je jf hi bd jg jh ji jj jk jl jm jn jo iq jp jq jr iu js jt ju iy jv jw jx jy bi translated">调味酱</h2><p id="a742" class="pw-post-body-paragraph if ig hi ih b ii lc ik il im ld io ip iq le is it iu lf iw ix iy lg ja jb jc hb bi translated">默认情况下，Airflow 将运行任何过去计划但尚未运行的时间间隔。为了避免追赶，我们需要在 DAG 定义中显式传递参数<code class="du lh li lj kt b">catchup=False</code>。</p><figure class="kh ki kj kk fd kl er es paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="er es lk"><img src="../Images/0b23f83399a7759cea1121ff0fefce91.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8foi9cV4CLUixQO7M7hrrw.png"/></div></div></figure><p id="63ea" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们用一个 catchup=true 的例子来理解这一点。</p><figure class="kh ki kj kk fd kl er es paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="er es ll"><img src="../Images/a7d677fdf2c552b43f346485b619d187.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yfVkKapeMcRv7IwR5LSkZQ.png"/></div></div></figure><p id="df98" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在上图中，我们有一个初始配置，其中一切正常，我们的 DAG 运行发生在 6。然后我们暂停了 DAG。</p><figure class="kh ki kj kk fd kl er es paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="er es lm"><img src="../Images/2457cb6142457ba86b5c151ba4944674.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XdUH5rWHrvbDnTsXLoAUDQ.png"/></div></div></figure><p id="2022" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这里我们看到，由于在下一个计划 DAG 运行暂停，因此计划的 start_date 不可用。</p><figure class="kh ki kj kk fd kl er es paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="er es ln"><img src="../Images/691a9fd5dbbde6990daa5b0b8d85aaeb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Sqye1qCL2fNh8xZ9QXC_OA.png"/></div></div></figure><p id="cc3a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在下一个计划中，发生了同样的情况(未触发 DAG 运行)。现在，我们从控制台启用或计划 DAG 运行。</p><figure class="kh ki kj kk fd kl er es paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="er es lo"><img src="../Images/0003e7b0bc69408e7db1361dc084cb1b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*90WcUYmxZhhZTPZxAaHZyQ.png"/></div></div></figure><p id="79c1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在上图中，我们看到在下一个计划中，触发了以前错过的 DAG 运行。请注意，start_date 是下一个计划(9)。如果您注意到，虽然执行日期是实际日期，但 start_date 在最后三次 DAG 运行中是相同的。这表示回填。因此，执行日期为 6 的第一次 DAG 运行发生在 7，然后是 8。</p><h2 id="2c90" class="je jf hi bd jg jh ji jj jk jl jm jn jo iq jp jq jr iu js jt ju iy jv jw jx jy bi translated">回填</h2><p id="72be" class="pw-post-body-paragraph if ig hi ih b ii lc ik il im ld io ip iq le is it iu lf iw ix iy lg ja jb jc hb bi translated">如果出于某种原因，我们希望按照特定计划手动重新运行 Dag，我们可以使用以下 CLI 命令来执行此操作。</p><pre class="kh ki kj kk fd ks kt ku kv aw kw bi"><span id="91d1" class="je jf hi kt b fi kx ky l kz la">airflow backfill -s &lt;START_DATE&gt; -e &lt;END_DATE&gt; --rerun_failed_tasks -B &lt;DAG_NAME&gt;</span></pre><p id="d06d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这将执行在 START_DATE &amp; END_DATE <strong class="ih hj">之间安排的所有 DAG 运行，而不管 airflow.cfg 中的 catchup 参数</strong>的值。</p><p id="779f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">注意这里-B 表示我们希望 DAG 运行是向后进行的。首先是最近的日期，然后是较早的日期。</p><pre class="kh ki kj kk fd ks kt ku kv aw kw bi"><span id="d377" class="je jf hi kt b fi kx ky l kz la">airflow backfill -m -s &lt;START_DATE&gt; -e &lt;END_DATE&gt; &lt;DAG_NAME&gt;</span></pre><p id="f489" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">上述命令将在给定的时间间隔内将所有任务标记为“成功”。</p><p id="0e8e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="kc">注意:使用以上 CLI 命令进行回填 DAG 运行时，其 ID 中将带有</em> <code class="du lh li lj kt b"><em class="kc">backfill_</em></code> <em class="kc">前缀。</em></p><p id="24e2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">希望这是有帮助的！！</p></div></div>    
</body>
</html>