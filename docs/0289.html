<html>
<head>
<title>Apache Camel: CRUD with JPA</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Apache Camel:带有JPA的CRUD</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/apache-camel-crud-with-jpa-fa9603430ff5?source=collection_archive---------0-----------------------#2020-09-11">https://medium.com/nerd-for-tech/apache-camel-crud-with-jpa-fa9603430ff5?source=collection_archive---------0-----------------------#2020-09-11</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/6fcfe9095629c2568872ffa439fccf37.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PANIc8nOoG3rm1ifN2JU6w.jpeg"/></div></div></figure><p id="3f20" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们已经看到了关于阿帕奇骆驼的其他帖子，你可以在我的个人资料中看到。今天我们将看到如何用JPA进行数据库操作。</p><p id="99cb" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">一如既往，我们将从配置开始。谈到依赖性，我们需要补充以下几点:</p><ul class=""><li id="b006" class="jo jp hi is b it iu ix iy jb jq jf jr jj js jn jt ju jv jw bi translated">Apache Camel<em class="jx">Camel-jpa-starter</em>组件将允许我们使用JPA组件。</li><li id="6e3b" class="jo jp hi is b it jy ix jz jb ka jf kb jj kc jn jt ju jv jw bi translated"><em class="jx"> hibernate-entitymanager </em>库将允许我们使用hibernate注释。</li></ul><p id="4607" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们必须记住一些关于JPA的基本知识。一个是将关系数据作为Java对象处理的质量。允许我们在Java类中管理数据库中的信息。这些类将被称为<em class="jx">实体</em>。另一个是JPQL的存在，一种允许我们对这些实体进行查询的语言。</p><p id="1479" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">多亏了Spring boot和camel starter库，我们不必做太多的配置工作，但是在Java类的层次上，我们必须添加一些注释:</p><figure class="kd ke kf kg fd ij"><div class="bz dy l di"><div class="kh ki l"/></div></figure><p id="e4e9" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><a class="ae kj" href="http://twitter.com/Entity" rel="noopener ugc nofollow" target="_blank"> <em class="jx"> @Entity </em> </a>将允许我们指明它是一个要通过JPA管理的类。用<a class="ae kj" href="http://twitter.com/Id" rel="noopener ugc nofollow" target="_blank"> <em class="jx"> @Id </em> </a>我们将指出哪个是它的主键，用<a class="ae kj" href="http://twitter.com/GeneratedValue" rel="noopener ugc nofollow" target="_blank"><em class="jx">@ generated value</em></a>我们将管理它的生成。在<em class="jx"> MySQL的情况下，</em>它将是自动的。</p><p id="9de6" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在第一个例子中，我们将看到<em class="jx"> JPA </em>组件与<em class="jx"> SQL </em>组件非常相似。只是我们将使用<em class="jx"> JPQL </em>并且我们必须指出哪个是我们将要执行查询的实体。</p><figure class="kd ke kf kg fd ij"><div class="bz dy l di"><div class="kh ki l"/></div></figure><p id="c41a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们要做的第一件事是指出哪一个是我们要生成的实体。然后，如果我们要进行JPQL查询，我们必须添加'<em class="jx"> query </em>'参数。</p><p id="ade9" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">此外，在这个特定的例子中，我们希望通过表达式语言，基于作为请求参数的标识符获得一本书。为了实现这一点，我们将使用<em class="jx">到</em>的方法，而不是<em class="jx">到</em>。它将允许我们动态地路由流并解释表达式语言。</p><p id="8e01" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><em class="jx"> JPA </em>的另一个特性是<em class="jx"> namedQuery </em>，它允许我们在类级别定义<em class="jx"> JPQL </em>查询。在下面的例子中，我们将看到如何通过<em class="jx"> JPA </em>组件使用<em class="jx"> namedQueries </em>。要使用的查询是<em class="jx"> findAll </em>(我们以前见过这个声明)。</p><figure class="kd ke kf kg fd ij"><div class="bz dy l di"><div class="kh ki l"/></div></figure><p id="acfc" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在第二个例子中，我们可以看到使用<em class="jx"> outType </em>方法在输出端指示对象类型的区别。或者，如果我们愿意，我们可以通过<em class="jx"> JPA </em>组件本身的查询参数<em class="jx"> resultClass </em>来表示相同的内容。</p><p id="80e7" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们还可以做一些操作，允许我们在数据库中持久保存这样的对象。正如我们在前面的例子中看到的，在保存值的情况下，操作非常简单。我们只需指示要持久保存的对象，并使用查询参数<em class="jx"> usePersist </em>来指示它应该持久保存该对象。当然，流必须包括要存储的对象的数据。</p><figure class="kd ke kf kg fd ij"><div class="bz dy l di"><div class="kh ki l"/></div></figure><p id="f621" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">对于数据的更新和删除，我们需要使用查询参数<em class="jx"> useExecuteUpdate </em>。在这个例子中，我们将使用process方法来创建要从消息头和消息体数据中更新的对象。</p><figure class="kd ke kf kg fd ij"><div class="bz dy l di"><div class="kh ki l"/></div></figure><p id="5fce" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">最后，我们将看到与数据删除相关的示例。顺便说一下，我们将看到如何进行本地查询。那就是使用通用的<em class="jx"> SQL </em>语言，而不是<em class="jx"> JPQL </em>。</p><figure class="kd ke kf kg fd ij"><div class="bz dy l di"><div class="kh ki l"/></div></figure><p id="ca68" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如您所见，有些查询可能比使用简单的SQL稍微困难一点，但其他查询也非常简单。我们总是和物体打交道。这在用面向对象语言编程时是非常令人感激的。</p></div></div>    
</body>
</html>