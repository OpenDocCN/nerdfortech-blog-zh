<html>
<head>
<title>R Tutorial — Apply Function Family in R</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">R教程—在R中应用函数族</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/r-tutorial-apply-function-family-in-r-cbbd4b6781cd?source=collection_archive---------16-----------------------#2021-05-29">https://medium.com/nerd-for-tech/r-tutorial-apply-function-family-in-r-cbbd4b6781cd?source=collection_archive---------16-----------------------#2021-05-29</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="fdb0" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">了解如何在R中使用apply()函数族</h2></div><p id="0a35" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在本文中，我们将讨论R中的<em class="jt"> apply() </em>函数族、它的类型以及应用于不同数据结构的几种类型。apply()家族是R内置的包，所以我们不用单独安装。apply()函数的主要优点是我们可以使用这些函数作为循环操作的替代方法。</p><p id="7cc9" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在这篇文章中，我们将学习如何使用R <em class="jt"> apply() </em>函数，以及应用于不同数据结构的不同类型的函数，如<em class="jt"> lapply() </em>、<em class="jt"> sapply() </em>、<em class="jt"> tapply() </em>、<em class="jt"> mapply() </em>和<em class="jt"> replicate() </em>。所以让我们开始吧！</p><figure class="jv jw jx jy fd jz er es paragraph-image"><div role="button" tabindex="0" class="ka kb di kc bf kd"><div class="er es ju"><img src="../Images/1fbb1d753d382201cf9854d90e2ae100.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FaviYDQ9z5bqfzw5xnu-BA.jpeg"/></div></div><figcaption class="kg kh et er es ki kj bd b be z dx translated">照片由<a class="ae kk" href="https://unsplash.com/@afgprogrammer?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">穆罕默德·拉赫马尼</a>在<a class="ae kk" href="https://unsplash.com/s/photos/programmer?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><h1 id="4355" class="kl km hi bd kn ko kp kq kr ks kt ku kv io kw ip kx ir ky is kz iu la iv lb lc bi translated">apply()系列—</h1><p id="342d" class="pw-post-body-paragraph ix iy hi iz b ja ld ij jc jd le im jf jg lf ji jj jk lg jm jn jo lh jq jr js hb bi translated"><em class="jt"> apply() </em>系列预装在R base包中，由各种函数组成，以重复的方式操作数组、列表、矩阵和数据帧中的数据。apply()函数族帮助我们用很少的几行代码来执行操作。这些功能可以是—</p><ol class=""><li id="4404" class="li lj hi iz b ja jb jd je jg lk jk ll jo lm js ln lo lp lq bi translated">向量化结构，如列表、数组、矩阵等。</li><li id="eecd" class="li lj hi iz b ja lr jd ls jg lt jk lu jo lv js ln lo lp lq bi translated">平均值、总和、平均值等聚合函数。</li></ol><h2 id="2378" class="lw km hi bd kn lx ly lz kr ma mb mc kv jg md me kx jk mf mg kz jo mh mi lb mj bi translated">我们应该如何以及何时使用这些工具？</h2><p id="e7a0" class="pw-post-body-paragraph ix iy hi iz b ja ld ij jc jd le im jf jg lf ji jj jk lg jm jn jo lh jq jr js hb bi translated">这些函数的使用取决于我们想要操作的数据结构和我们需要的输出格式。让我们看看如何一个接一个地执行这些功能—</p><h1 id="ae4d" class="kl km hi bd kn ko kp kq kr ks kt ku kv io kw ip kx ir ky is kz iu la iv lb lc bi translated"><strong class="ak">apply()函数</strong></h1><p id="c535" class="pw-post-body-paragraph ix iy hi iz b ja ld ij jc jd le im jf jg lf ji jj jk lg jm jn jo lh jq jr js hb bi translated">先说家族的第一个函数，<em class="jt"> apply() </em>函数。这在数组上操作。为了简化，我们在本教程中将只使用2D数组。首先，让我们看看基本的apply函数是如何工作的。我们可以使用RStudio的帮助部分来了解该功能的说明。</p><pre class="jv jw jx jy fd mk ml mm mn aw mo bi"><span id="453c" class="lw km hi ml b fi mp mq l mr ms">?apply()</span></pre><p id="0991" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">R文档显示该函数的语法如下—</p><pre class="jv jw jx jy fd mk ml mm mn aw mo bi"><span id="a7cd" class="lw km hi ml b fi mp mq l mr ms">apply(X, MARGIN, FUN, ...)</span></pre><p id="810b" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">其中:-</p><ol class=""><li id="1ae8" class="li lj hi iz b ja jb jd je jg lk jk ll jo lm js ln lo lp lq bi translated">x是一个2D阵列。</li><li id="85fa" class="li lj hi iz b ja lr jd ls jg lt jk lu jo lv js ln lo lp lq bi translated">MARGIN是一个变量，它定义了我们如何应用函数。当Margin =1时，它应用于行，当Margin = 2时，它应用于列，当Margin = c(1，2)时，它应用于行和列。</li><li id="9235" class="li lj hi iz b ja lr jd ls jg lt jk lu jo lv js ln lo lp lq bi translated">乐趣是我们应用于数据的函数。它可以是任何R函数，包括用户定义的函数(UDF)。</li><li id="cdef" class="li lj hi iz b ja lr jd ls jg lt jk lu jo lv js ln lo lp lq bi translated">…..这用于传递给函数的任何其他参数。</li></ol><p id="859b" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">让我们构建一个4 x 4的矩阵，并计算每列值的总和—</p><pre class="jv jw jx jy fd mk ml mm mn aw mo bi"><span id="9aed" class="lw km hi ml b fi mp mq l mr ms">matrix_1 &lt;- matrix(1:16, nrow = 4)</span><span id="814e" class="lw km hi ml b fi mt mq l mr ms">matrix_1</span></pre><p id="fe5c" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们将得到如下输出—</p><pre class="jv jw jx jy fd mk ml mm mn aw mo bi"><span id="8ee5" class="lw km hi ml b fi mp mq l mr ms">[,1] [,2] [,3] [,4]<br/>[1,]    1    5    9   13<br/>[2,]    2    6   10   14<br/>[3,]    3    7   11   15<br/>[4,]    4    8   12   16</span></pre><p id="c2f6" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">让我们计算每行值的总和—</p><pre class="jv jw jx jy fd mk ml mm mn aw mo bi"><span id="2549" class="lw km hi ml b fi mp mq l mr ms">apply(matrix_1, 1, sum)</span></pre><p id="b294" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们将得到如下输出—</p><pre class="jv jw jx jy fd mk ml mm mn aw mo bi"><span id="ddf3" class="lw km hi ml b fi mp mq l mr ms">[1] 28 32 36 40</span></pre><p id="330e" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">让我们计算每列值的总和—</p><pre class="jv jw jx jy fd mk ml mm mn aw mo bi"><span id="bb82" class="lw km hi ml b fi mp mq l mr ms">apply(matrix_1, 2, sum)</span></pre><p id="940c" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们将得到如下输出—</p><pre class="jv jw jx jy fd mk ml mm mn aw mo bi"><span id="8973" class="lw km hi ml b fi mp mq l mr ms">[1] 10 26 42 58</span></pre><p id="9113" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">让我们在矩阵中引入NA值，看看我们如何执行函数—</p><pre class="jv jw jx jy fd mk ml mm mn aw mo bi"><span id="caf1" class="lw km hi ml b fi mp mq l mr ms">matrix_1[2,3] &lt;- NA</span><span id="1bcd" class="lw km hi ml b fi mt mq l mr ms">matrix_1</span></pre><p id="e993" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们将得到如下输出—</p><pre class="jv jw jx jy fd mk ml mm mn aw mo bi"><span id="7260" class="lw km hi ml b fi mp mq l mr ms">[,1] [,2] [,3] [,4]<br/>[1,]    1    5    9   13<br/>[2,]    2    6   NA   14<br/>[3,]    3    7   11   15<br/>[4,]    4    8   12   16</span></pre><p id="9b3c" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">让我们使用应用功能—</p><pre class="jv jw jx jy fd mk ml mm mn aw mo bi"><span id="8f53" class="lw km hi ml b fi mp mq l mr ms">apply(matrix_1, 1, sum)</span></pre><p id="9c0c" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们将得到如下输出—</p><pre class="jv jw jx jy fd mk ml mm mn aw mo bi"><span id="a69e" class="lw km hi ml b fi mp mq l mr ms">[1] 28 NA 36 40</span></pre><p id="c2dd" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">将<em class="jt"> na.rm </em>参数传递给上面的代码—</p><pre class="jv jw jx jy fd mk ml mm mn aw mo bi"><span id="4c63" class="lw km hi ml b fi mp mq l mr ms">apply(matrix_1, 1, sum, na.rm = TRUE)</span></pre><p id="8e95" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们将得到如下输出—</p><pre class="jv jw jx jy fd mk ml mm mn aw mo bi"><span id="bcef" class="lw km hi ml b fi mp mq l mr ms">[1] 28 22 36 40</span></pre><p id="3811" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">现在，让我们去掉这个NA —</p><pre class="jv jw jx jy fd mk ml mm mn aw mo bi"><span id="9ce7" class="lw km hi ml b fi mp mq l mr ms">matrix_1[2,3] &lt;- 10</span><span id="1a3a" class="lw km hi ml b fi mt mq l mr ms">matrix_1</span></pre><p id="0224" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们将得到如下输出—</p><pre class="jv jw jx jy fd mk ml mm mn aw mo bi"><span id="b348" class="lw km hi ml b fi mp mq l mr ms">[,1] [,2] [,3] [,4]<br/>[1,]    1    5    9   13<br/>[2,]    2    6   10   14<br/>[3,]    3    7   11   15<br/>[4,]    4    8   12   16</span></pre><p id="5337" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在上面的例子中，我们使用apply()函数来计算一行或一列的总和。在下面的例子中，我们将使用apply()函数来转换每行和每列中的值。请注意边距参数。我们将定义一个函数，将矩阵的每个元素乘以5，并将MARGIN参数设置为<em class="jt"> 1:2 </em>，以便该函数可以对矩阵的每一行和每一列进行操作。</p><pre class="jv jw jx jy fd mk ml mm mn aw mo bi"><span id="89cd" class="lw km hi ml b fi mp mq l mr ms">matrix_2 &lt;- apply(matrix_1,1:2, function(x) x*5)</span><span id="3551" class="lw km hi ml b fi mt mq l mr ms">matrix_2</span></pre><p id="e6ec" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们将得到如下输出—</p><pre class="jv jw jx jy fd mk ml mm mn aw mo bi"><span id="c047" class="lw km hi ml b fi mp mq l mr ms">[,1] [,2] [,3] [,4]<br/>[1,]    5   25   45   65<br/>[2,]   10   30   50   70<br/>[3,]   15   35   55   75<br/>[4,]   20   40   60   80</span></pre><p id="46ea" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在前面的例子中，我们在矩阵上使用了apply()函数。但是让我们看看当我们循环遍历一个向量时会发生什么？</p><p id="57e1" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">让我们先创建一个向量—</p><pre class="jv jw jx jy fd mk ml mm mn aw mo bi"><span id="3e5a" class="lw km hi ml b fi mp mq l mr ms">vector_1 &lt;- c(1:15)</span><span id="7f7d" class="lw km hi ml b fi mt mq l mr ms">vector_1</span></pre><p id="ac48" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们将得到如下输出—</p><pre class="jv jw jx jy fd mk ml mm mn aw mo bi"><span id="d0f4" class="lw km hi ml b fi mp mq l mr ms">[1]  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15</span></pre><p id="dc84" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">让我们使用apply()函数—</p><pre class="jv jw jx jy fd mk ml mm mn aw mo bi"><span id="75fd" class="lw km hi ml b fi mp mq l mr ms">apply(vector_1, 1, sum)</span></pre><p id="50aa" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如果你运行这个函数，你会得到下面的错误—</p><pre class="jv jw jx jy fd mk ml mm mn aw mo bi"><span id="f432" class="lw km hi ml b fi mp mq l mr ms">Error in apply(vector_1, 1, sum) : dim(X) must have a positive length</span></pre><p id="f648" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如您所见，它不起作用，因为apply()函数只有在数据至少有两个维度时才能发挥最佳作用。如果使用的数据是矢量格式，那么我们需要使用其他函数，比如lapply()、sapply()或vapply()。</p><figure class="jv jw jx jy fd jz er es paragraph-image"><div role="button" tabindex="0" class="ka kb di kc bf kd"><div class="er es mu"><img src="../Images/985a42bb529bcf855df58e21063a7388.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rKPE-B40gjndoEhkRelrOQ.jpeg"/></div></div><figcaption class="kg kh et er es ki kj bd b be z dx translated">照片由<a class="ae kk" href="https://unsplash.com/@magnetme?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Magnet.me </a>在<a class="ae kk" href="https://unsplash.com/s/photos/apply?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><h1 id="889e" class="kl km hi bd kn ko kp kq kr ks kt ku kv io kw ip kx ir ky is kz iu la iv lb lc bi translated">lapply()函数</h1><p id="83e3" class="pw-post-body-paragraph ix iy hi iz b ja ld ij jc jd le im jf jg lf ji jj jk lg jm jn jo lh jq jr js hb bi translated">当我们想要应用一个给定的函数来循环遍历一个列表或一个向量中的每个数据元素时，我们使用这个函数。我们可以使用RStudio的帮助部分来了解该功能的说明。</p><pre class="jv jw jx jy fd mk ml mm mn aw mo bi"><span id="95ff" class="lw km hi ml b fi mp mq l mr ms">?lapply</span></pre><p id="6c48" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">R文档显示了函数的语法，如下所示。请注意，这个函数中没有MARGIN参数。</p><pre class="jv jw jx jy fd mk ml mm mn aw mo bi"><span id="9ada" class="lw km hi ml b fi mp mq l mr ms">lapply(X, FUN, ....)</span></pre><p id="b15c" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们可以将这个函数用于其他对象，如数据帧、列表或向量，我们得到的输出是列表形式的(因此名称以“l”开头)，它具有与传递给它的对象相同数量的元素。我们将创建三个名为A、B和C的矩阵，并从一列中提取值，看看这是如何工作的。</p><pre class="jv jw jx jy fd mk ml mm mn aw mo bi"><span id="7afd" class="lw km hi ml b fi mp mq l mr ms">A = matrix(1:16, nrow = 4)<br/>B = 1:10<br/>C = 15:20<br/>my_list &lt;- list(A,B,C)<br/>my_list</span></pre><p id="5cee" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们将得到如下输出—</p><pre class="jv jw jx jy fd mk ml mm mn aw mo bi"><span id="6400" class="lw km hi ml b fi mp mq l mr ms">[[1]]<br/>     [,1] [,2] [,3] [,4]<br/>[1,]    1    5    9   13<br/>[2,]    2    6   10   14<br/>[3,]    3    7   11   15<br/>[4,]    4    8   12   16<br/><br/>[[2]]<br/>[1]  1  2  3  4  5  6  7  8  9 10<br/><br/>[[3]]<br/>[1] 15 16 17 18 19 20</span></pre><p id="64a3" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">让我们计算每个列表的总和—</p><pre class="jv jw jx jy fd mk ml mm mn aw mo bi"><span id="65ad" class="lw km hi ml b fi mp mq l mr ms">lapply(my_list, sum)</span></pre><p id="5052" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们将得到如下输出—</p><pre class="jv jw jx jy fd mk ml mm mn aw mo bi"><span id="452f" class="lw km hi ml b fi mp mq l mr ms">[[1]]<br/>[1] 136<br/><br/>[[2]]<br/>[1] 55<br/><br/>[[3]]<br/>[1] 105</span></pre><p id="404c" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们可以看到结果是如何保存为列表的。如果我们想要一个向量形式的结果，那么我们必须将<em class="jt"> unlist </em>参数传递给lapply()函数</p><pre class="jv jw jx jy fd mk ml mm mn aw mo bi"><span id="dfdd" class="lw km hi ml b fi mp mq l mr ms">unlist(lapply(my_list, sum))</span></pre><p id="9772" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们将得到如下输出—</p><pre class="jv jw jx jy fd mk ml mm mn aw mo bi"><span id="4f3e" class="lw km hi ml b fi mp mq l mr ms">[1] 136  55 105</span></pre><p id="c8ca" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们还可以创建自己的函数，并将其传递给lapply()。例如，如果我们想给每个元素加10，我们将使用如下所示的代码—</p><pre class="jv jw jx jy fd mk ml mm mn aw mo bi"><span id="f7a0" class="lw km hi ml b fi mp mq l mr ms">lapply(my_list, function(x) x + 10)</span></pre><p id="5b26" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们将得到如下输出—</p><pre class="jv jw jx jy fd mk ml mm mn aw mo bi"><span id="0e36" class="lw km hi ml b fi mp mq l mr ms">[[1]]<br/>     [,1] [,2] [,3] [,4]<br/>[1,]   11   15   19   23<br/>[2,]   12   16   20   24<br/>[3,]   13   17   21   25<br/>[4,]   14   18   22   26<br/><br/>[[2]]<br/>[1] 11 12 13 14 15 16 17 18 19 20<br/><br/>[[3]]<br/>[1] 25 26 27 28 29 30</span></pre><h1 id="8c50" class="kl km hi bd kn ko kp kq kr ks kt ku kv io kw ip kx ir ky is kz iu la iv lb lc bi translated"><strong class="ak">sapply()函数</strong></h1><p id="9f3c" class="pw-post-body-paragraph ix iy hi iz b ja ld ij jc jd le im jf jg lf ji jj jk lg jm jn jo lh jq jr js hb bi translated"><em class="jt"> sapply() </em>函数的工作方式就像lapply()函数一样，但是它会尽可能地简化输出。事实上，sapply()函数是lapply()的一个“<em class="jt">包装器</em>”函数。我们可以使用RStudio的帮助部分来了解该功能的说明。</p><pre class="jv jw jx jy fd mk ml mm mn aw mo bi"><span id="ea46" class="lw km hi ml b fi mp mq l mr ms">?sapply</span></pre><p id="e42f" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">R文档显示了函数的语法，如下所示。请注意，这个函数中也没有MARGIN参数。</p><pre class="jv jw jx jy fd mk ml mm mn aw mo bi"><span id="4bd8" class="lw km hi ml b fi mp mq l mr ms">sapply(X, FUN, ..., simplify = TRUE, USE.NAMES = TRUE)</span></pre><p id="5dcc" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这意味着，如果数据是可简化的，它将返回一个向量，而不是像lapply()那样返回一个列表。让我们同样使用<em class="jt"> my_list </em>的例子。</p><pre class="jv jw jx jy fd mk ml mm mn aw mo bi"><span id="7fd6" class="lw km hi ml b fi mp mq l mr ms">sapply(my_list, sum)</span></pre><p id="15ef" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们将得到如下输出—</p><pre class="jv jw jx jy fd mk ml mm mn aw mo bi"><span id="6e79" class="lw km hi ml b fi mp mq l mr ms">[1] 136  55 105</span></pre><p id="f3e0" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">现在让我们将<em class="jt"> simplify = FALSE </em>参数传递给上面的代码，看看会发生什么—</p><pre class="jv jw jx jy fd mk ml mm mn aw mo bi"><span id="86d8" class="lw km hi ml b fi mp mq l mr ms">sapply(my_list, sum, simplify = FALSE)</span></pre><p id="0fbe" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们将得到如下输出—</p><pre class="jv jw jx jy fd mk ml mm mn aw mo bi"><span id="4077" class="lw km hi ml b fi mp mq l mr ms">[[1]]<br/>[1] 136<br/><br/>[[2]]<br/>[1] 55<br/><br/>[[3]]<br/>[1] 105</span></pre><p id="a227" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在这里，我们可以看到输出是以列表而不是向量的形式返回的。像apply()函数一样，我们也可以使用函数来转换数据。这是我们如何做到的—</p><pre class="jv jw jx jy fd mk ml mm mn aw mo bi"><span id="e629" class="lw km hi ml b fi mp mq l mr ms">print(sapply(my_list, function(x) x + 5))</span></pre><p id="2fce" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们将得到如下输出—</p><pre class="jv jw jx jy fd mk ml mm mn aw mo bi"><span id="bf69" class="lw km hi ml b fi mp mq l mr ms">[[1]]<br/>       [,1] [,2] [,3] [,4]<br/>[1,]    6   10   14   18<br/>[2,]    7   11   15   19<br/>[3,]    8   12   16   20<br/>[4,]    9   13   17   21<br/><br/>[[2]]<br/>[1]  6  7  8  9 10 11 12 13 14 15<br/><br/>[[3]]<br/>[1] 20 21 22 23 24 25</span></pre><h1 id="e909" class="kl km hi bd kn ko kp kq kr ks kt ku kv io kw ip kx ir ky is kz iu la iv lb lc bi translated"><strong class="ak">VAP ply()函数</strong></h1><p id="06bc" class="pw-post-body-paragraph ix iy hi iz b ja ld ij jc jd le im jf jg lf ji jj jk lg jm jn jo lh jq jr js hb bi translated"><em class="jt"> vapply() </em>函数类似于sapply()函数，但是它要求用户指定他们传递给vapply()函数的参数的数据类型。我们可以使用RStudio的帮助部分来了解该功能的说明。</p><pre class="jv jw jx jy fd mk ml mm mn aw mo bi"><span id="1729" class="lw km hi ml b fi mp mq l mr ms">?vapply</span></pre><p id="4232" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">R文档显示了函数的语法，如下所示。请注意，这个函数中也没有MARGIN参数。</p><pre class="jv jw jx jy fd mk ml mm mn aw mo bi"><span id="73cb" class="lw km hi ml b fi mp mq l mr ms">vapply(X, FUN, FUN.VALUE, …, USE.NAMES = TRUE)</span></pre><p id="1d63" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">好玩。值是我们需要指定要传递的数据类型的地方。如果你希望列表中的每一项都返回一个数值，那么我们用这个参数来取乐。值=整数(1)。这里要记住的另一件事是，这种简化总是在vapply()函数的情况下完成的。该函数检查所有的乐趣值是否与乐趣兼容。值，为此它们必须具有相同的长度和类型。</p><pre class="jv jw jx jy fd mk ml mm mn aw mo bi"><span id="72fe" class="lw km hi ml b fi mp mq l mr ms">vapply(my_list, sum, FUN.VALUE = integer(1))</span></pre><p id="c2f3" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们将得到如下输出—</p><pre class="jv jw jx jy fd mk ml mm mn aw mo bi"><span id="be3a" class="lw km hi ml b fi mp mq l mr ms">[1] 136  55 105</span></pre><h1 id="e0b3" class="kl km hi bd kn ko kp kq kr ks kt ku kv io kw ip kx ir ky is kz iu la iv lb lc bi translated"><strong class="ak">replicate()函数</strong></h1><p id="3b95" class="pw-post-body-paragraph ix iy hi iz b ja ld ij jc jd le im jf jg lf ji jj jk lg jm jn jo lh jq jr js hb bi translated">该函数通常与apply()函数族一起使用。当我们将<em class="jt"> replicate() </em>函数传递给一个向量时，它会将其值复制指定的次数。我们可以使用RStudio的帮助部分来了解该功能的说明。</p><pre class="jv jw jx jy fd mk ml mm mn aw mo bi"><span id="2b2f" class="lw km hi ml b fi mp mq l mr ms">?replicate</span></pre><p id="d69d" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">R文档显示了函数的语法，如下所示。请注意，这个函数中也没有MARGIN参数。</p><pre class="jv jw jx jy fd mk ml mm mn aw mo bi"><span id="343f" class="lw km hi ml b fi mp mq l mr ms">replicate(n, expr, simplify = "array")</span></pre><p id="8f69" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">哪里—</p><ol class=""><li id="eb7b" class="li lj hi iz b ja jb jd je jg lk jk ll jo lm js ln lo lp lq bi translated"><em class="jt"> n </em>是表示重复次数的整数。</li><li id="683a" class="li lj hi iz b ja lr jd ls jg lt jk lu jo lv js ln lo lp lq bi translated"><em class="jt"> expr </em>是反复评估的表达式。</li></ol><p id="1f6c" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">让我们看一个例子——</p><pre class="jv jw jx jy fd mk ml mm mn aw mo bi"><span id="a5fa" class="lw km hi ml b fi mp mq l mr ms">hist(replicate(100, mean(rexp(10))))</span></pre><p id="a974" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们将得到如下输出—</p><figure class="jv jw jx jy fd jz er es paragraph-image"><div role="button" tabindex="0" class="ka kb di kc bf kd"><div class="er es mv"><img src="../Images/4ca9ed007d9ee9ea44c6709878b8b08a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZRZEiPSB5Ecwidd08ng0tg.png"/></div></div><figcaption class="kg kh et er es ki kj bd b be z dx translated">作者图片</figcaption></figure><h1 id="0f3f" class="kl km hi bd kn ko kp kq kr ks kt ku kv io kw ip kx ir ky is kz iu la iv lb lc bi translated"><strong class="ak">mapply()函数</strong></h1><p id="ba74" class="pw-post-body-paragraph ix iy hi iz b ja ld ij jc jd le im jf jg lf ji jj jk lg jm jn jo lh jq jr js hb bi translated">mapply()函数中的“m”代表“多元”应用。这是模仿sapply()函数的。我们使用这个函数向量化一个通常不接受向量作为参数的函数的参数。我们可以将这个函数应用于多个列表或多个向量参数。我们可以使用RStudio的帮助部分来了解该功能的说明。</p><pre class="jv jw jx jy fd mk ml mm mn aw mo bi"><span id="82de" class="lw km hi ml b fi mp mq l mr ms">?mapply</span></pre><p id="01f6" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">R文档显示了函数的语法，如下所示。请注意，这个函数中也没有MARGIN参数。</p><pre class="jv jw jx jy fd mk ml mm mn aw mo bi"><span id="cc66" class="lw km hi ml b fi mp mq l mr ms">mapply(FUN, ..., MoreArgs = NULL, SIMPLIFY = TRUE, USE.NAMES = TRUE)</span></pre><p id="d5b8" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">哪里—</p><ol class=""><li id="f6e2" class="li lj hi iz b ja jb jd je jg lk jk ll jo lm js ln lo lp lq bi translated">乐趣是要应用的功能</li><li id="0ed3" class="li lj hi iz b ja lr jd ls jg lt jk lu jo lv js ln lo lp lq bi translated">….要向量化的参数</li><li id="4aa1" class="li lj hi iz b ja lr jd ls jg lt jk lu jo lv js ln lo lp lq bi translated">MoreArgs列出了其他有趣的论点。</li><li id="4510" class="li lj hi iz b ja lr jd ls jg lt jk lu jo lv js ln lo lp lq bi translated">SIMPLIFY是逻辑或字符串。这会尝试将结果简化为向量、矩阵或更高维的数组。</li><li id="ade8" class="li lj hi iz b ja lr jd ls jg lt jk lu jo lv js ln lo lp lq bi translated">使用。如果它是一个字符向量，我们用这个字符向量作为名字。</li></ol><p id="7829" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">让我们考虑下面的例子。假设我们想要在4次复制1，在3次复制2，在2次复制3，在1次复制4。</p><pre class="jv jw jx jy fd mk ml mm mn aw mo bi"><span id="0909" class="lw km hi ml b fi mp mq l mr ms">mapply(rep, times = 1:4, x = 4:1)</span></pre><p id="b4aa" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们将得到如下输出—</p><pre class="jv jw jx jy fd mk ml mm mn aw mo bi"><span id="4be9" class="lw km hi ml b fi mp mq l mr ms">[[1]]<br/>[1] 4<br/><br/>[[2]]<br/>[1] 3 3<br/><br/>[[3]]<br/>[1] 2 2 2<br/><br/>[[4]]<br/>[1] 1 1 1 1</span></pre><p id="2a96" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">还有另一种方法可以做到这一点—</p><pre class="jv jw jx jy fd mk ml mm mn aw mo bi"><span id="0c47" class="lw km hi ml b fi mp mq l mr ms">mapply(rep, times = 1:4, MoreArgs = list(x = 25))</span></pre><p id="f3ea" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们将得到如下输出—</p><pre class="jv jw jx jy fd mk ml mm mn aw mo bi"><span id="e326" class="lw km hi ml b fi mp mq l mr ms">[[1]]<br/>[1] 25<br/><br/>[[2]]<br/>[1] 25 25<br/><br/>[[3]]<br/>[1] 25 25 25<br/><br/>[[4]]<br/>[1] 25 25 25 25</span></pre><p id="b263" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们将得到列表形式的输出。要获得向量形式的输出，请使用以下代码—</p><pre class="jv jw jx jy fd mk ml mm mn aw mo bi"><span id="199d" class="lw km hi ml b fi mp mq l mr ms">unlist(mapply(rep, times = 1:4, x = 4:1))</span></pre><p id="298f" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们将得到如下输出—</p><pre class="jv jw jx jy fd mk ml mm mn aw mo bi"><span id="c945" class="lw km hi ml b fi mp mq l mr ms">[1] 4 3 3 2 2 2 1 1 1 1</span></pre><p id="f450" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">现在，让我们创建一个函数并将mapply()函数传递给它。假设我们有两个向量，想把它们相加后乘以2。因此，让我们先创建函数，然后将参数传递给它。</p><pre class="jv jw jx jy fd mk ml mm mn aw mo bi"><span id="41e5" class="lw km hi ml b fi mp mq l mr ms">x &lt;- c(A = 10, B = 20, C = 30)<br/>y &lt;- c(J = 40, K = 50, L = 60)<br/>addition &lt;- function(u,v){<br/>  (u+v)*2<br/>}<br/>mapply(addition, x, y)</span></pre><p id="2783" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们将得到如下输出—</p><pre class="jv jw jx jy fd mk ml mm mn aw mo bi"><span id="470b" class="lw km hi ml b fi mp mq l mr ms">A   B   C <br/>100 140 180</span></pre><h1 id="b306" class="kl km hi bd kn ko kp kq kr ks kt ku kv io kw ip kx ir ky is kz iu la iv lb lc bi translated"><strong class="ak">tap ply()函数— </strong></h1><p id="c139" class="pw-post-body-paragraph ix iy hi iz b ja ld ij jc jd le im jf jg lf ji jj jk lg jm jn jo lh jq jr js hb bi translated">此函数将函数应用于不规则数组的每个单元格，即由特定因子级别的唯一组合给出的每个(非空)值组。我们可以使用RStudio的帮助部分来了解该功能的说明。</p><pre class="jv jw jx jy fd mk ml mm mn aw mo bi"><span id="2215" class="lw km hi ml b fi mp mq l mr ms">?tapply</span></pre><p id="602d" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">R文档显示了函数的语法，如下所示。请注意，这个函数中也没有MARGIN参数。</p><pre class="jv jw jx jy fd mk ml mm mn aw mo bi"><span id="2418" class="lw km hi ml b fi mp mq l mr ms">tapply(X, INDEX, FUN = NULL, ..., default = NA, simplify = TRUE)</span></pre><p id="68b8" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">让我们在R中加载<em class="jt">虹膜</em>数据集，并在这个虹膜数据集上使用tapply()函数。让我们加载数据集—</p><pre class="jv jw jx jy fd mk ml mm mn aw mo bi"><span id="e02c" class="lw km hi ml b fi mp mq l mr ms">datasets::iris</span><span id="7139" class="lw km hi ml b fi mt mq l mr ms">head(iris)</span></pre><p id="0004" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们将得到如下输出—</p><pre class="jv jw jx jy fd mk ml mm mn aw mo bi"><span id="b1d7" class="lw km hi ml b fi mp mq l mr ms">Sepal.Length Sepal.Width Petal.Length Petal.Width Species<br/>1          5.1         3.5          1.4         0.2  setosa<br/>2          4.9         3.0          1.4         0.2  setosa<br/>3          4.7         3.2          1.3         0.2  setosa<br/>4          4.6         3.1          1.5         0.2  setosa<br/>5          5.0         3.6          1.4         0.2  setosa<br/>6          5.4         3.9          1.7         0.4  setosa</span></pre><p id="2c45" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">假设如果我们想计算所有物种的萼片长度的平均值</p><pre class="jv jw jx jy fd mk ml mm mn aw mo bi"><span id="3121" class="lw km hi ml b fi mp mq l mr ms">tapply(iris$Sepal.Length, iris$Species, mean)</span></pre><p id="f818" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们将得到如下输出—</p><pre class="jv jw jx jy fd mk ml mm mn aw mo bi"><span id="513c" class="lw km hi ml b fi mp mq l mr ms">setosa versicolor  virginica <br/>5.006      5.936      6.588</span></pre><p id="ba8e" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">类似地，我们可以用这个代码计算这三种物种的萼片长度中值</p><pre class="jv jw jx jy fd mk ml mm mn aw mo bi"><span id="6cb1" class="lw km hi ml b fi mp mq l mr ms">tapply(iris$Sepal.Length, iris$Species, median)</span></pre><p id="865e" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们将得到如下输出—</p><pre class="jv jw jx jy fd mk ml mm mn aw mo bi"><span id="d985" class="lw km hi ml b fi mp mq l mr ms">setosa versicolor  virginica <br/>5.0        5.9        6.5</span></pre></div><div class="ab cl mw mx gp my" role="separator"><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb"/></div><div class="hb hc hd he hf"><h1 id="2044" class="kl km hi bd kn ko nd kq kr ks ne ku kv io nf ip kx ir ng is kz iu nh iv lb lc bi translated">结论—</h1><p id="52b9" class="pw-post-body-paragraph ix iy hi iz b ja ld ij jc jd le im jf jg lf ji jj jk lg jm jn jo lh jq jr js hb bi translated">在这篇文章中，我们学习了r中的apply()函数族。如果你喜欢这篇文章或者对我有什么建议，请在下面评论让我知道。</p><p id="53f5" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><em class="jt">谢谢你！</em></p></div></div>    
</body>
</html>