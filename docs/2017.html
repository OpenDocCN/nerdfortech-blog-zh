<html>
<head>
<title>Higher-Order Functions in C</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">C语言中的高阶函数</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/higher-order-functions-in-c-74f6c4b550ee?source=collection_archive---------1-----------------------#2021-04-17">https://medium.com/nerd-for-tech/higher-order-functions-in-c-74f6c4b550ee?source=collection_archive---------1-----------------------#2021-04-17</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/8a4c735f1cf1134d5242d4651beb0afc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*J8kJv2cwUhX1G2AfwJverg.jpeg"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">照片由<a class="ae iu" href="https://unsplash.com/@dylanferreira?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">迪伦·费雷拉</a>在<a class="ae iu" href="https://unsplash.com/s/photos/high?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="b8b6" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">高阶函数的概念是函数式编程中的关键，但像递归函数一样，它们也用于实现某些算法、编程模式，甚至编写内核驱动程序。尽管C语言不支持许多现成的FP概念，但是高阶函数可以使用函数指针和编译器支持来实现。在本文中，我试图用简单的例子来说明这一点。</p><h1 id="a7c9" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">什么动物是高阶函数？</h1><p id="9304" class="pw-post-body-paragraph iv iw hi ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated">高阶函数是接受其他函数作为参数或返回函数本身的函数。由于C严重依赖于指针的使用，它也允许指针引用像函数一样的可运行代码块。事实上，函数本身就是指向它们所包含的代码的指针，所以我们将会看到，将一个函数赋给一个函数指针是完全有效的。然后，这样的指针可以作为参数传递给函数，或者像其他变量一样由函数返回。这就是高阶函数在c中的实现方式。</p><h1 id="75c2" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">指向功能</h1><p id="cc10" class="pw-post-body-paragraph iv iw hi ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated">根据以下内容声明一个函数:</p><pre class="kw kx ky kz fd la lb lc ld aw le bi"><span id="fedc" class="lf ju hi lb b fi lg lh l li lj"><strong class="lb hj">void fun_name(void);</strong><br/>^    ^        ^<br/>|    |        `----- parameter type<br/>|    `-------------- function name<br/>`------------------- return type</span></pre><p id="1a9d" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这一行声明了一个名为<em class="lk"> fun_name </em>的函数，它不接受任何参数，也不返回任何内容。如果它接受了<code class="du ll lm ln lb b">int</code>并返回了<code class="du ll lm ln lb b">double</code>，那么它将被这样声明:<code class="du ll lm ln lb b">double fun_name(int param);</code>其中<em class="lk"> param </em>是整数参数的名称(声明中不强制提供)。很简单。</p><p id="5747" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">现在我们想要一个指向这样一个函数的指针，因为我们想把它作为参数传递给其他函数，或者从高阶函数返回。这里有一个指向我们最新功能的指针:</p><pre class="kw kx ky kz fd la lb lc ld aw le bi"><span id="441b" class="lf ju hi lb b fi lg lh l li lj"><strong class="lb hj">double (*fun_ptr)(int param);</strong><br/>^       ^^        ^   ^<br/>|       ||        |   `------ parameter name<br/>|       ||        `---------- parameter type<br/>|       |`------------------- pointer name<br/>|       `-------------------- pointer marker<br/>`---------------------------- return type</span></pre><p id="fb64" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这意味着函数指针的声明和它所指向的函数几乎是一样的。唯一的区别是指针名现在被加上了括号，以避免与返回类型(可能是指针本身)混淆。这也意味着我们需要准确地知道被指向函数的类型。这提供了一些类型安全。</p><h1 id="2cc9" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">函数杂耍出</h1><p id="f64b" class="pw-post-body-paragraph iv iw hi ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated">上一节展示了函数指针的类型，现在让我们看看如何将它添加到函数签名中。</p><pre class="kw kx ky kz fd la lb lc ld aw le bi"><span id="21f1" class="lf ju hi lb b fi lg lh l li lj"><strong class="lb hj">void use_fptr(double (*fun_ptr)(int param));</strong><br/>^    ^        ^        ^        ^   ^<br/>|    |        |        |        |   `------- pointed fn param<br/>|    |        |        |        `----------- pointed fn param type<br/>|    |        |        `-------------------- pointer parameter name<br/>|    |        `----------------------------- pointed fn return type<br/>|    `-------------------------------------- function name<br/>`------------------------------------------- function return type</span></pre><p id="9729" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">假设我们的参数列表包含两个函数指针，那么它们可能如下所示:</p><p id="7b7a" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><code class="du ll lm ln lb b">void use_fptr(void (*fptr1)(void), void (*fptr2)(void));</code></p><p id="2b61" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">现在棘手的部分是:返回一个函数指针。为了让事情更清楚，我假设我们的函数不接受任何参数，而是返回一个指向接受int的函数的指针，并返回一个double。可以这样声明:</p><pre class="kw kx ky kz fd la lb lc ld aw le bi"><span id="593a" class="lf ju hi lb b fi lg lh l li lj"><strong class="lb hj">double (* fn_returns_fptr(void))(int param);</strong><br/>^       ^ ^               ^      ^   ^<br/>|       | |               |      |   `------ returned fptr param<br/>|       | |               |      `---------- ret. fptr param type<br/>|       | |               `----------------- function param type<br/>|       | `--------------------------------- function name<br/>|       `----------------------------------- ret. pointer marker<br/>`------------------------------------------- ret. fptr return type</span></pre><p id="6415" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在上面的例子中，所有的括号都是强制性的，否则就无法知道星号指的是什么。所以我们不是简单地把返回类型放在函数名的左边，而是因为返回类型是一个指向函数的指针，我们把指向函数的返回类型放在左边，参数列表放在右边，把我们的函数嵌入到它的返回类型中，就像一个洋葱。这已经足以让任何一个刚刚学习函数指针的人感到困惑，但这可能会更复杂。想象一个函数，取一个以上的函数指针作为参数，返回一个函数指针，取两个函数指针作为参数，返回一个函数指针……无限。一个更短的例子可能就足够了:</p><pre class="kw kx ky kz fd la lb lc ld aw le bi"><span id="459a" class="lf ju hi lb b fi lg lh l li lj">double (* fun(double (*p1)(int), double (*p2)(int)))(int);</span></pre><p id="9fee" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">一个名为<code class="du ll lm ln lb b">fun</code>的函数，它接受两个函数指针，每个指针接受一个int并返回一个double，而它自己返回其中一个函数指针。实际上没那么有趣。假设它返回了一个函数指针，这个函数指针带有一个函数指针。这就是詹姆斯·海特菲尔德所说的“绝对恐怖”。</p><p id="90f7" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">幸运的是，C提供了简化这一点的方法。键入别名来拯救世界。</p><h1 id="683f" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">蒸馏函数传递</h1><p id="a328" class="pw-post-body-paragraph iv iw hi ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated">因为函数和指针只是类型，所以我们也可以为它们定义别名，然后使用这个名称来引用它们，而不是笨重的类型。事实上，函数指针语法非常容易变得难以忍受的复杂，以至于我在展示它们的时候已经犯了错误也不会感到惊讶。所以要避免这种风险，尽可能使用类型别名。我们可以为我们的<code class="du ll lm ln lb b">int</code>取<code class="du ll lm ln lb b">double</code>返回函数指针创建一个类型别名，如下所示:</p><pre class="kw kx ky kz fd la lb lc ld aw le bi"><span id="a9f7" class="lf ju hi lb b fi lg lh l li lj"><strong class="lb hj">typedef double (*int_to_double)(int);</strong><br/>^       ^       ^^              ^<br/>|       |       ||              `---- pointed function param type<br/>|       |       |`------------------- type alias<br/>|       |       `-------------------- pointer marker<br/>|       `---------------------------- pointed function return type<br/>`------------------------------------ type aliasing keyword</span></pre><p id="3aff" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这不是一个新类型，它是一个现有类型的别名<code class="du ll lm ln lb b">int_to_double</code>，是一个函数指针。然后我们可以在参数列表中和作为返回类型使用它，这样詹姆斯·海特菲尔德就不需要睁着一只眼睡觉了。同样可怕的函数声明可以简化如下:</p><pre class="kw kx ky kz fd la lb lc ld aw le bi"><span id="15ac" class="lf ju hi lb b fi lg lh l li lj"><strong class="lb hj">int_to_double</strong> fun(<strong class="lb hj">int_to_double</strong> p1, <strong class="lb hj">int_to_double</strong> p2);</span></pre><p id="ae91" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">好多了。然后，我们可以创建更有意义的<em class="lk"> typedef </em> s like(有意将样式改为其他现代语言中熟悉的样式，但这并没有什么不同):</p><pre class="kw kx ky kz fd la lb lc ld aw le bi"><span id="9534" class="lf ju hi lb b fi lg lh l li lj">typedef int (*<strong class="lb hj">IntBiFunction</strong>)(int, int);<br/>typedef void (*<strong class="lb hj">IntConsumer</strong>)(int);<br/>typedef void (*<strong class="lb hj">Callback</strong>)(void);<br/>typedef bool (*<strong class="lb hj">IntPredicate</strong>)(int);<br/>typedef int (*<strong class="lb hj">IntSupplier</strong>)(void);</span></pre><p id="9087" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">传递它们轻而易举:</p><pre class="kw kx ky kz fd la lb lc ld aw le bi"><span id="32a2" class="lf ju hi lb b fi lg lh l li lj">int <strong class="lb hj">op</strong>(int a, int b, <strong class="lb hj">IntBiFunction</strong> fun) {<br/>    <strong class="lb hj">return</strong> fun(a, b);<br/>}</span><span id="0517" class="lf ju hi lb b fi lo lh l li lj">void <strong class="lb hj">iter</strong>(<strong class="lb hj">IntConsumer </strong>fun, int x) {<br/>    <strong class="lb hj">for</strong> (unsigned int i = 0; i &lt; x; ++i) {<br/>        fun(i);<br/>    }<br/>}</span><span id="a17d" class="lf ju hi lb b fi lo lh l li lj"><strong class="lb hj">callback </strong>writeln(char *str) {<br/>    <strong class="lb hj">return </strong>lambda(void, (void), { printf("%s\n", str); });<br/>}</span></pre><p id="f123" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">等等！λ？耶普。</p><h1 id="8438" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">我们能做什么</h1><p id="59f4" class="pw-post-body-paragraph iv iw hi ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated">我们已经可以用函数和函数指针做很多事情了。</p><p id="962a" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">将它们作为参数传递:</p><pre class="kw kx ky kz fd la lb lc ld aw le bi"><span id="de3d" class="lf ju hi lb b fi lg lh l li lj">int add(int a, int b);<br/>int sub(int a, int b);</span><span id="180b" class="lf ju hi lb b fi lo lh l li lj">int result = op(2, 1, add); // =&gt; 3<br/>result = op(2, 1, sub);     // =&gt; 1</span></pre><p id="8bd9" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">将它们赋给(指针)变量:</p><pre class="kw kx ky kz fd la lb lc ld aw le bi"><span id="8b98" class="lf ju hi lb b fi lg lh l li lj">IntBiFunction addptr = add;<br/>IntBiFunction subptr = sub;</span><span id="f5f1" class="lf ju hi lb b fi lo lh l li lj">int result = op(2, 1, addptr);  // =&gt; 3<br/>result = op(2, 1, subptr);      // =&gt; 1</span></pre><p id="2488" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">从函数中返回它们:</p><pre class="kw kx ky kz fd la lb lc ld aw le bi"><span id="2a53" class="lf ju hi lb b fi lg lh l li lj">IntBiFunction op(char c) {<br/>    if (c == '+') {<br/>        return add;<br/>    } else {<br/>        return sub;<br/>    }<br/>}</span></pre><p id="6d51" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">将它们放入数组:</p><pre class="kw kx ky kz fd la lb lc ld aw le bi"><span id="8650" class="lf ju hi lb b fi lg lh l li lj">typedef void (*Action)(void);</span><span id="90d4" class="lf ju hi lb b fi lo lh l li lj">void pull(void);<br/>void push(void);<br/>void idle(void);</span><span id="7035" class="lf ju hi lb b fi lo lh l li lj">Action actions[] = { pull, push, idle };</span></pre><p id="ea1f" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">比较它们:</p><pre class="kw kx ky kz fd la lb lc ld aw le bi"><span id="5059" class="lf ju hi lb b fi lg lh l li lj">if (fptr == push) {</span></pre><p id="2472" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">等等。</p><p id="091f" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">但是有一件事我们不能做，匿名定义它们。</p><h1 id="853e" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">我们还能做什么</h1><p id="fb95" class="pw-post-body-paragraph iv iw hi ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated">因此，尽管我们仍然不能匿名定义函数，编译器已经向前迈进了一步，并能够做一些神奇的事情，使我们更接近匿名和lambda函数。顺便说一下，是时候说几句术语了:</p><pre class="kw kx ky kz fd la lb lc ld aw le bi"><span id="5d58" class="lf ju hi lb b fi lg lh l li lj">Anonymous functions are functions that are defined without a name, often inline, and therefore sometimes called ‘inline functions’ too, however that’s not exactly the point, and may cause confusion with C’s native concept of <a class="ae iu" href="https://www.drdobbs.com/the-new-c-inline-functions/184401540" rel="noopener ugc nofollow" target="_blank">inline functions</a>, which is a different kind of animal. The other name for anonymous functions is <em class="lk">lambda functions</em>, which comes from the math theory of <em class="lk">lambda calculus</em>, where functions have no name.</span><span id="8401" class="lf ju hi lb b fi lo lh l li lj">Another term, frequently occurs together with the previous ones, is <em class="lk">closure</em>. These are anonymous functions that also bind the scope, so that they capture the variables from their environment in the function body to be used even when it’s called from outside of this scope.</span><span id="21c7" class="lf ju hi lb b fi lo lh l li lj">The support for assigning functions to variables, passing them as arguments, returning them from functions, and putting them in data structures, especially using lambdas and closures, is called having <em class="lk">first-class functions</em>.</span></pre><p id="1ac3" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们为什么关心？因为这样的函数更容易创建(事实上，它们可以在运行中定义)，并且作为参数传递给更高阶的函数，这使得能够编写一些算法和模式，同时也促进了并行计算。手头有了这些概念，也有助于我们以声明式风格编写代码，说明我们试图实现什么，而不是给出如何实现的指令。如果没有高阶函数，实现一些逻辑会比必要的更复杂。</p><p id="2d4e" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">那么如何才能做到呢？</p><h1 id="cb31" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated"><strong class="ak">海合会的做法</strong></h1><p id="e82b" class="pw-post-body-paragraph iv iw hi ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated">使用GNU C编译器，当我们要调用函数时，我们可以动态地定义它们。但是在我向您展示如何操作之前，让我告诉您它需要的特性。这些是GCC提供的非标准特性:</p><ol class=""><li id="df20" class="lp lq hi ix b iy iz jc jd jg lr jk ls jo lt js lu lv lw lx bi translated">语句表达式</li></ol><p id="eca7" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">最简单的语句表达式是这样的:</p><pre class="kw kx ky kz fd la lb lc ld aw le bi"><span id="ad94" class="lf ju hi lb b fi lg lh l li lj"><strong class="lb hj">({</strong> char *s = "Hello"; <strong class="lb hj">s;</strong> <strong class="lb hj">})</strong></span></pre><p id="0a8e" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">其中括号是表达式的容器，最后一个表达式(在我们的例子中只有变量<code class="du ll lm ln lb b">s</code>)提供了语句表达式计算的值。重点是，在语句表达式中，我们可以做的不仅仅是初始化变量。请考虑以下情况:</p><pre class="kw kx ky kz fd la lb lc ld aw le bi"><span id="1e00" class="lf ju hi lb b fi lg lh l li lj"><strong class="lb hj">({</strong> char *s; s = calloc(20, sizeof(char)); <strong class="lb hj">if</strong> (argc &gt; 1) <strong class="lb hj">{</strong> strcpy(s, "We take no arguments"); <strong class="lb hj">} else {</strong> strcpy(s, "Welcome to GCC"); <strong class="lb hj">}</strong> <strong class="lb hj">s;</strong> <strong class="lb hj">})</strong></span></pre><p id="ec3a" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这是同一个表达式，但是它计算的值是动态变化的。和任何表达式一样，它可以赋给变量，或者作为函数参数传递。</p><p id="7a59" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">2.嵌套函数</p><p id="80c7" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">"嵌套函数是定义在另一个函数内部的函数."——在<a class="ae iu" href="https://gcc.gnu.org/onlinedocs/gcc/Nested-Functions.html#Nested-Functions" rel="noopener ugc nofollow" target="_blank"> GNU编译器文档</a>中说明。我们不需要知道更多。</p><p id="9015" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">当我们结合这两个特征时，真正的好处就来了:</p><pre class="kw kx ky kz fd la lb lc ld aw le bi"><span id="e2d5" class="lf ju hi lb b fi lg lh l li lj"><strong class="lb hj">({</strong> void <strong class="lb hj">prn</strong>(int x) { printf("x = %d\n", x); } <strong class="lb hj">&amp;prn;</strong> <strong class="lb hj">})<br/>   ^                                        ^ ^<br/>   |                                        | `------- return value<br/>   `----------------------------------------`--------- nested func.</strong></span></pre><p id="9c65" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">现在，我们的语句表达式的值是一个指针，指向我们刚刚嵌套创建的函数。</p><p id="f319" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">c能提供的比看起来更多。幸运的是，C支持宏，这是预处理程序的小替换规则，可以将我们更喜欢的语法转换成编译器可以理解的语法。这允许我们编写自己的匿名函数实现。</p><p id="4759" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">不难看出上面表达式中的模式，我们可以信赖一个宏，创建一个语句表达式，返回一个指向没有名字的函数的指针。或者它爱怎么叫就怎么叫，我们不在乎。这是我们获得匿名函数的方法。原作者在编写该宏并在本文中介绍其用法方面做得非常好，但他收到的愤怒评论足以写满一整章关于lambdas的内容，因此我觉得有必要在这里澄清一些事情，但我仍然欠你一句话，在这里引用该宏及其用法:</p><pre class="kw kx ky kz fd la lb lc ld aw le bi"><span id="0d5f" class="lf ju hi lb b fi lg lh l li lj">#define lambda(lambda$_ret, lambda$_args, lambda$_body)\<br/>  ({\<br/>    lambda$_ret lambda$__anon$ lambda$_args\<br/>      lambda$_body\<br/>    &amp;lambda$__anon$;<br/>  \})</span></pre><p id="eb43" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">宏有三个参数，返回类型、参数列表(args)和函数体，然后这些参数被放入一个语句表达式中，其中指向新创建的函数的指针将是表达式的值。我们可以如下使用该宏:</p><pre class="kw kx ky kz fd la lb lc ld aw le bi"><span id="5658" class="lf ju hi lb b fi lg lh l li lj">iter(<strong class="lb hj">lambda(</strong>void, (int x), { printf("%d\n", x); }<strong class="lb hj">)</strong>, 5);</span></pre><p id="1cd5" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这意味着我们的lambda函数只有一个int类型的参数<code class="du ll lm ln lb b">x</code>，并且不返回任何值。当然，我们的匿名函数的类型需要与我们传递的参数的类型相匹配。这提供了一些类型安全。</p><p id="20cc" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">现在最难的部分:<em class="lk">捍卫概念</em>。在原文下面的评论页边上有一些旁注:</p><ul class=""><li id="5270" class="lp lq hi ix b iy iz jc jd jg lr jk ls jo lt js ly lv lw lx bi translated">如果你不喜欢lambdas，没关系——有些人也不喜欢宏。</li><li id="2856" class="lp lq hi ix b iy lz jc ma jg mb jk mc jo md js ly lv lw lx bi translated">不喜欢某样东西并不代表它无效。</li><li id="ddb9" class="lp lq hi ix b iy lz jc ma jg mb jk mc jo md js ly lv lw lx bi translated">如果你到目前为止还没有用过lambdas，现在开始也不迟，但是…</li><li id="b219" class="lp lq hi ix b iy lz jc ma jg mb jk mc jo md js ly lv lw lx bi translated">没有人强迫你使用它们。</li><li id="9ff3" class="lp lq hi ix b iy lz jc ma jg mb jk mc jo md js ly lv lw lx bi translated">有没有可能用错？绝对的。</li><li id="e571" class="lp lq hi ix b iy lz jc ma jg mb jk mc jo md js ly lv lw lx bi translated">我们是否应该隐瞒这种技术，因为它可能会被错误地使用？肯定不是。即使是恶意代码，也最好暴露出来。</li><li id="8c76" class="lp lq hi ix b iy lz jc ma jg mb jk mc jo md js ly lv lw lx bi translated">在GCC中实现<em class="lk">语句表达式</em>和<em class="lk">嵌套函数</em>是有原因的——如果你觉得它们有用，就使用它们。</li><li id="af44" class="lp lq hi ix b iy lz jc ma jg mb jk mc jo md js ly lv lw lx bi translated">没有人会因为<em class="lk">不</em>知道一些事情而成为更好的开发人员。</li></ul><p id="a65f" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">记住这一点，我们可以进入下一部分…</p><h1 id="220d" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated"><strong class="ak">铿锵的接近</strong></h1><p id="cb6b" class="pw-post-body-paragraph iv iw hi ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated">GNU不会因为实现了可以像lambda函数一样使用的编译器特性而被愤怒的开发人员孤立。事实上，Clang走得更远，它提供了匿名函数，这些函数也能够捕获主体中实际使用的上下文，所以它们可以被认为是闭包！</p><p id="58e6" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">让我们看看实际情况。</p><pre class="kw kx ky kz fd la lb lc ld aw le bi"><span id="831a" class="lf ju hi lb b fi lg lh l li lj">typedef void (^Callback)(void);</span><span id="c5b2" class="lf ju hi lb b fi lo lh l li lj">Callback writeln(char *str);<br/>void call(Callback callback);</span><span id="05bf" class="lf ju hi lb b fi lo lh l li lj">// ...<br/>Callback my_callback = <strong class="lb hj">^ {</strong> printf("I was called!"); <strong class="lb hj">}</strong>;</span><span id="12df" class="lf ju hi lb b fi lo lh l li lj">int y = 5;<br/>iter(<strong class="lb hj">^ (int x) {</strong> printf("%d + %d = %d\n", y, x, y + x); <strong class="lb hj">}</strong>, 5);</span></pre><p id="01ad" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">正如我们所看到的，语法比GCC要干净得多。关键是<code class="du ll lm ln lb b">^</code> (=λ，lambda)，它告诉我们正在处理一个匿名函数。返回类型如果是void可以省略，省略的时候参数列表如果是空的也可以省略— <code class="du ll lm ln lb b">(void)</code>。所以语法本质上和函数指针是一样的，星号被一个脱字符号代替，但是我们不再受限于首先声明我们的函数，它可以被动态定义。在最后一行中，我们可以看到局部变量<code class="du ll lm ln lb b">y</code>是如何在函数体中被捕获的，并且在从<code class="du ll lm ln lb b">iter</code>函数中调用我们的闭包时变得可用，即使它不在它的作用域中，这是相当不错的。</p><p id="6d0c" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这个功能在Clang里叫<a class="ae iu" href="https://clang.llvm.org/docs/BlockLanguageSpec.html" rel="noopener ugc nofollow" target="_blank">封杀</a>，苹果<a class="ae iu" href="https://web.archive.org/web/20090920043909/http://images.apple.com/macosx/technology/docs/GrandCentral_TB_brief_20090903.pdf" rel="noopener ugc nofollow" target="_blank">提倡的</a>。<em class="lk"> Y tho？</em>他们称之为“实现多核的更好方式”。这意味着他们看到了将函数式编程的高度要求的特性结合起来的潜力，这些特性促进了并行计算，并具有c语言的速度和硬件接近性。</p><p id="5d1c" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">然而，在macOS之外使用块并不简单。<code class="du ll lm ln lb b">BlocksRuntime</code>通常不是Clang (LLVM)发行版的一部分，需要调整才能启用。即使这样，它可能会有臃肿的功能。因此，存在库的<a class="ae iu" href="http://mackyle.github.io/blocksruntime/" rel="noopener ugc nofollow" target="_blank">解块克隆，可以单独下载和构建。</a></p><h1 id="ff6f" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">挑战极限</h1><p id="1072" class="pw-post-body-paragraph iv iw hi ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated">这些都是前沿的特性，推动了C编程语言的极限。同时，这也意味着它们的可用性受到编译器支持程度的限制。这破坏了可移植性，不应该在可移植性很重要的情况下使用。使用GCC的方法需要打开2级优化，并启用C99标准的扩展。编译方式如下:</p><pre class="kw kx ky kz fd la lb lc ld aw le bi"><span id="9f90" class="lf ju hi lb b fi lg lh l li lj">gcc <strong class="lb hj">-O2</strong> -o fun.exe <strong class="lb hj">--std=gnu99</strong> fun.c</span></pre><p id="5569" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">Clang还需要一个语言扩展，这并不容易获得。我们很可能需要自己编译它，然后我们可以这样编译我们的程序:</p><pre class="kw kx ky kz fd la lb lc ld aw le bi"><span id="5213" class="lf ju hi lb b fi lg lh l li lj">clang <strong class="lb hj">-fblocks</strong> -o fun-clang.exe fun-clang.c <strong class="lb hj">-lBlocksRuntime</strong></span></pre><p id="1c9d" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如果我们设法让我们的程序编译，如果我们试图在GCC中使用局部变量，或者如果我们不小心将函数指针指向<code class="du ll lm ln lb b">void*</code>并返回，它仍然会崩溃，这很容易使开发变得痛苦。</p><p id="a276" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">然而，即使这些技术的可用性有限，也绝对值得关注它们，因为它们正被用于某些目的，并且预计会被更多地使用。</p><p id="b382" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">另一方面，高阶函数并不是什么新东西，在标准库中(<code class="du ll lm ln lb b">bsearch</code>，<code class="du ll lm ln lb b">qsort</code>)，在Linux内核中，驱动程序接口是使用一个一级函数表定义的，在像GTK这样的流行库中，都可以找到高阶函数来支持回调。它们在不复杂的情况下解决了某些控制复杂性的问题，有助于应对并行计算的挑战，并且无论我们实际上使用哪种编程语言，它们都绝对值得学习。</p><p id="f3dc" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">尽管C并不以支持这些概念而闻名，尽管有更多适用的语言，它们为一级和更高阶的函数提供了更好的支持，但我们仍然可以在C中使用它们，如果我们发现它是合理的，并学习了这样做所需的工具。</p><h1 id="4d3d" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">结论</h1><p id="c26a" class="pw-post-body-paragraph iv iw hi ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated">C语言是一种非常强大的语言，毫不夸张地说，C语言主宰着世界。它无处不在，但编程范式也是如此。几乎没有任何严肃的编程语言能够成功地将自己局限于一种范式。我们可以学习更多的范例，了解他们擅长的东西。如果我们为来自其他范例的概念找到了有效的用例，不管这种语言最常用的方式是什么，我们都可以从使用它们中受益。幸运的是，C提供了对关于高阶函数和一级函数的最重要特性的支持，这些特性甚至可以在优秀编译器的帮助下进行扩展。</p><p id="56a3" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">然而，我们应该记住在C中应用这些概念的利弊，并且还有其他的选择。c互操作性是许多编程语言的关键，这进一步扩大了我们的选择范围。</p><p id="a31c" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">作为比较，我们可以在C++、C#和Java等语言中找到对这些概念(以及更多)的现成支持。对于C中的核心函数式编程，我们可以<a class="ae iu" href="https://common-lisp.net/project/ecl/" rel="noopener ugc nofollow" target="_blank">将Lisp </a>嵌入到C中。如果我们愿意离开C，有一些围绕这些概念从头设计的语言，如OCaml和Haskell。</p><p id="dde3" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">无论我们把重点放在哪里，我们仍然可以从外国概念中受益，并把它们用在最合适的地方。了解更多只会让我们成为更好的开发者。</p></div></div>    
</body>
</html>