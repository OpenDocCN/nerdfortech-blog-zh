<html>
<head>
<title>How to Eager load when there’s Lazy loading involved</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">当存在延迟加载时，如何快速加载</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/how-to-eager-load-when-theres-lazy-loading-involved-57753644834e?source=collection_archive---------1-----------------------#2021-07-11">https://medium.com/nerd-for-tech/how-to-eager-load-when-theres-lazy-loading-involved-57753644834e?source=collection_archive---------1-----------------------#2021-07-11</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/235971b7a5da99a7092c57f09b57fdc3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*FfpwrHivUvjrYDVY"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">迈克·范·登博斯在<a class="ae iu" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><p id="f76b" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们经常会遇到这样的情况，虽然我们的实体有另一个实体的映射，但是我们需要使用那个实体，并通过快速加载获得所有相关的映射。这些情况大多发生在我们有大量数据库调用，并且我们需要减少调用次数，从而减少总时间的时候。不要烦恼！<strong class="ix hj"> <em class="jt">加入接取</em> </strong>救援！</p><p id="bc11" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">所以，让我们先看看数据。</p><p id="867f" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">对于这个例子，我创建了两个表<strong class="ix hj"> <em class="jt"> department </em> </strong>和<strong class="ix hj"> <em class="jt"> employee </em> </strong>，其中一个部门可以有许多雇员，但是一个雇员只能属于一个部门。</p><p id="e574" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">让我们看一看这些数据。</p><figure class="jv jw jx jy fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ju"><img src="../Images/a1e61ac09ef075c900df18e0a83ff701.png" data-original-src="https://miro.medium.com/v2/resize:fit:588/format:webp/1*PqXCwbjUrflGqHU8PMG8kg.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">部门表</figcaption></figure><figure class="jv jw jx jy fd ij er es paragraph-image"><div class="er es jz"><img src="../Images/ab2d36fd213a2ee9f7eb859bb3894ae7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1068/format:webp/1*fNO_hWx9zpSX9UgcQtOx3A.png"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">员工表</figcaption></figure><p id="0457" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">现在让我们来看看<strong class="ix hj"> <em class="jt">部门</em> </strong>和<strong class="ix hj"> <em class="jt">员工</em> </strong>的 java 类。</p><figure class="jv jw jx jy fd ij"><div class="bz dy l di"><div class="ka kb l"/></div></figure><figure class="jv jw jx jy fd ij"><div class="bz dy l di"><div class="ka kb l"/></div></figure><p id="daaa" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我希望您关注的主要内容是映射和获取类型。正如我们在<strong class="ix hj"> <em class="jt"> Department </em> </strong>类中看到的，在一对多的双向映射中，使用一个列表来映射雇员。这是使用 employeeList 列表上的<strong class="ix hj"> <em class="jt"> @OneToMany </em> </strong>注释完成的，注意获取类型是惰性的也很重要。同样，在<strong class="ix hj"> <em class="jt"> Employee </em> </strong>类中，我们在 department 变量上添加了一个<strong class="ix hj"> <em class="jt"> @ManyToOne </em> </strong>注释，将一个雇员与他们的部门关联起来。</p><p id="126a" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">所以，在我深入到<strong class="ix hj"> <em class="jt"> JOIN FETCH </em> </strong>之前，我只想接触一个 JOIN 的例子，从控制台输出中，我们可以找出正在进行的调用的数量。</p><p id="6720" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">当我们使用 JPA 提供的<strong class="ix hj"> <em class="jt"> JOIN </em> </strong>或<a class="ae iu" href="https://docs.spring.io/spring-data/jpa/docs/current/api/org/springframework/data/jpa/repository/JpaRepository.html#findAll--" rel="noopener ugc nofollow" target="_blank"><strong class="ix hj"><em class="jt">find all()</em></strong></a>方法来获取所有部门及其相关用户时，我们使用以下方式:</p><figure class="jv jw jx jy fd ij"><div class="bz dy l di"><div class="ka kb l"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">使用 JPA 提供的 findAll()方法</figcaption></figure><figure class="jv jw jx jy fd ij"><div class="bz dy l di"><div class="ka kb l"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">通过使用 join</figcaption></figure><p id="95ee" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">对于所使用的两种风格，都会生成下面提到的 Hibernate 查询。</p><figure class="jv jw jx jy fd ij"><div class="bz dy l di"><div class="ka kb l"/></div></figure><p id="5fc2" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们可以看到，首先运行一个 SQL 查询来获取所有部门，然后对每个部门运行一个 SQL 查询来获取该部门中相应的雇员。</p><p id="b5f6" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">最后，如果使用控制器显示，结果应该如下所示:</p><figure class="jv jw jx jy fd ij"><div class="bz dy l di"><div class="ka kb l"/></div></figure><p id="6113" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">那么，如何对此进行优化呢？</p><p id="3687" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">嗯通过使用<strong class="ix hj"> <em class="jt">加入取</em> </strong>！</p><p id="cbee" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">因此，<strong class="ix hj"> <em class="jt"> JOIN FETCH </em> </strong>基本上删除了所有额外的调用来获取特定部门的所有雇员，但这是在一个 DB 调用中完成的！</p><figure class="jv jw jx jy fd ij"><div class="bz dy l di"><div class="ka kb l"/></div></figure><h1 id="8eca" class="kc kd hi bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated">结论</h1><p id="a653" class="pw-post-body-paragraph iv iw hi ix b iy la ja jb jc lb je jf jg lc ji jj jk ld jm jn jo le jq jr js hb bi translated">因此，很明显<strong class="ix hj"> <em class="jt"> JOIN FETCH </em> </strong>加速了您的 DB 调用，在关联类型为<strong class="ix hj"> <em class="jt"> LAZY </em> </strong>但我们需要以<strong class="ix hj"><em class="jt"/></strong>方式获取数据的情况下，我们可以利用<strong class="ix hj"> <em class="jt"> JOIN FETCH </em> </strong>的这一属性。</p><p id="7bf5" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">整个例子写的是用弹簧开机检查<a class="ae iu" href="https://github.com/Attyuttam/join-fetch-example" rel="noopener ugc nofollow" target="_blank"> <strong class="ix hj"> <em class="jt">这个</em> </strong> </a>出来的！</p></div></div>    
</body>
</html>