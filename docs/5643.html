<html>
<head>
<title>The Liskov Substitution Principle</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">利斯科夫替代原理</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/the-liskov-substitution-principle-e35ce940571?source=collection_archive---------8-----------------------#2021-10-26">https://medium.com/nerd-for-tech/the-liskov-substitution-principle-e35ce940571?source=collection_archive---------8-----------------------#2021-10-26</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="30db" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这使事情变得有点复杂，因为这个原则规定对象应该可以用它们的子类型替换，而不影响程序的正确性。</p><p id="3d48" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果你对 OOP 编程有所了解，继承是实现这一原则时的思考方式。</p><p id="186a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这里打个比方更好理解。假设鸵鸟是一种鸟，但实际上不会飞。通过用一个<code class="du jd je jf jg b">fly</code>方法拥有<code class="du jd je jf jg b">Bird</code>类，所有实例化的鸟都应该会飞，对吗？此时，有了一个扩展了<code class="du jd je jf jg b">Bird</code>的<code class="du jd je jf jg b">Ostrich</code>类，你可以覆盖<code class="du jd je jf jg b">Bird</code>类中的<code class="du jd je jf jg b">fly</code>方法，让它不被实现，这当然是一个设计缺陷，因为你不应该在所有使用<code class="du jd je jf jg b">Bird</code>对象的地方都使用<code class="du jd je jf jg b">Ostrich</code>对象。</p><p id="dabd" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">利斯科夫通过认可“是-A”思维方式的改变，建立了一种严格的思维模式。</p><p id="f470" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">查看另一个例子，以及如何实现。</p><p id="d85a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们有一个带有<code class="du jd je jf jg b">getCabinWidth</code>方法的通用<code class="du jd je jf jg b">Car</code>类，但也有一个从<code class="du jd je jf jg b">Car</code>本身继承的<code class="du jd je jf jg b">RacingCar</code>类，这个<code class="du jd je jf jg b">RacingCar</code>没有实现<code class="du jd je jf jg b">getCabinWidth</code>方法，而是使用了<code class="du jd je jf jg b">getCockpitWidth</code>方法。</p><p id="b583" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在一个循环交互之后，在多个<code class="du jd je jf jg b">Cars</code>和<code class="du jd je jf jg b">RacingCar</code>的几个实例化之后，您将不得不处理由于不存在而未实现的方法。因此，最好的解决方案是实现一个泛型类，它可以从<code class="du jd je jf jg b">Cars</code>和<code class="du jd je jf jg b">RacingCars</code>中实现，这个新的泛型类，姑且称之为<code class="du jd je jf jg b">Vehicle</code>将有一个名为<code class="du jd je jf jg b">getInteriorWidth</code>的方法。</p><p id="a252" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">然后，每个继承的方法将调用它们各自的 cabin 的方法，实例结构将以良好的形式正确地调用每个方法。</p><p id="25f7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果替代测试失败，这整个原则想要打破等级制度。</p><p id="82b4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这里是另一个方法，这次用代码解释。</p><p id="7776" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">因此，我们有一个从另一个名为<code class="du jd je jf jg b">InHouseProduct</code>的类继承而来的<code class="du jd je jf jg b">Product</code>类，它在<code class="du jd je jf jg b">Product</code>类中设置的初始折扣之后提供 1.5 倍的折扣。</p><pre class="jh ji jj jk fd jl jg jm jn aw jo bi"><span id="2ed7" class="jp jq hi jg b fi jr js l jt ju">public class Product {<br/>  protected double discount = 20;<br/>  public double getDiscount() {<br/>    return discount<br/>  }<br/>}</span></pre><p id="55af" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">和</p><pre class="jh ji jj jk fd jl jg jm jn aw jo bi"><span id="9b39" class="jp jq hi jg b fi jr js l jt ju">public class InHouseProduct extends Product { <br/>  public void applyExtraDiscount() {<br/>    discount = discount * 1.5<br/>  }<br/>}</span></pre><p id="66d4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这些都是在 ArrayList 中实例化和实现的，当循环时，您需要评估实例是否与<code class="du jd je jf jg b">InHouseProduct</code>匹配，然后调用<code class="du jd je jf jg b">applyExtraDiscount</code></p><p id="dae5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">下面是完整的实现，它叫做<code class="du jd je jf jg b">PricingUtils</code></p><pre class="jh ji jj jk fd jl jg jm jn aw jo bi"><span id="c582" class="jp jq hi jg b fi jr js l jt ju">import java.util.ArrayList;</span><span id="4450" class="jp jq hi jg b fi jv js l jt ju">public class PricingUtils {</span><span id="fce7" class="jp jq hi jg b fi jv js l jt ju"> public static void main(String[] args) {<br/>   Product p1 = new Product();<br/>   Product p2 = new Product();<br/>   Product p3 = new InHouseProduct();<br/> }</span><span id="fbf9" class="jp jq hi jg b fi jv js l jt ju"> List&lt;Product&gt; productList = new ArrayList&lt;&gt;();<br/> productList.add(p1);<br/> productList.add(p2);<br/> productList.add(p3);</span><span id="9e1f" class="jp jq hi jg b fi jv js l jt ju"> for(Product product: productList) {<br/>  if(product instanceof InHouseProduct) {<br/>   ((InHouseProduct) product).applyExtraDiscount();<br/>  }<br/>    System.out.println(product.getDiscount());<br/>  }<br/>}</span></pre><p id="11e4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这都是违反 LSP 的。要解决这个问题，你需要做一些小事。</p><p id="9567" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">首先，让我们覆盖<code class="du jd je jf jg b">InHouseProduct</code>上的<code class="du jd je jf jg b">getDiscount</code>方法，并在其中应用额外的折扣。<code class="du jd je jf jg b">Product</code>类保持不变。</p><pre class="jh ji jj jk fd jl jg jm jn aw jo bi"><span id="8ad4" class="jp jq hi jg b fi jr js l jt ju">public class Product {<br/>  protected double discount = 20;<br/>  public double getDiscount() {<br/>    return discount<br/>  }<br/>}</span><span id="6cb4" class="jp jq hi jg b fi jv js l jt ju">public class InHouseProduct extends Product {</span><span id="7421" class="jp jq hi jg b fi jv js l jt ju"><a class="ae jw" href="http://twitter.com/Override" rel="noopener ugc nofollow" target="_blank">  @Override</a><br/>  public double getDiscount() {<br/>      this.applyExtraDiscount();<br/>      return discount;<br/>  }</span><span id="d4bc" class="jp jq hi jg b fi jv js l jt ju">  public void applyExtraDiscount() {<br/>    discount = discount * 1.5<br/>  }<br/>}</span></pre><p id="4509" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">然后，在实现中，您可以直接调用<code class="du jd je jf jg b">PricingUtils</code>类中的<code class="du jd je jf jg b">getDiscount</code>方法，而不是请求实例</p><pre class="jh ji jj jk fd jl jg jm jn aw jo bi"><span id="d4c3" class="jp jq hi jg b fi jr js l jt ju">import java.util.ArrayList;</span><span id="42c0" class="jp jq hi jg b fi jv js l jt ju">public class PricingUtils {</span><span id="9e41" class="jp jq hi jg b fi jv js l jt ju">  public static void main(String[] args) {<br/>   Product p1 = new Product();<br/>   Product p2 = new Product();<br/>   Product p3 = new InHouseProduct();<br/>  }</span><span id="02f8" class="jp jq hi jg b fi jv js l jt ju">  List&lt;Product&gt; productList = new ArrayList&lt;&gt;();<br/>  productList.add(p1);<br/>  productList.add(p2);<br/>  productList.add(p3);</span><span id="999b" class="jp jq hi jg b fi jv js l jt ju">  for(Product product: productList) {<br/>    System.out.println(product.getDiscount());<br/>  }<br/>}</span></pre><p id="af03" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在我看来，这是最难理解的原理。都是侧重于讲而不是问。我很高兴有很多不同的方式来解释这一点。</p><p id="35b8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我建议你花时间阅读更多的补充材料来阐明这个原则。</p><p id="9add" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">接下来让我们转到接口分离原则。</p></div></div>    
</body>
</html>