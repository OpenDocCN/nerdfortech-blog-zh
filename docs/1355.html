<html>
<head>
<title>Android JetpackCompose — with a global state</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Android JetpackCompose —具有全局状态</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/android-jetpackcompose-with-global-state-3a0b3c0f0b30?source=collection_archive---------6-----------------------#2021-03-15">https://medium.com/nerd-for-tech/android-jetpackcompose-with-global-state-3a0b3c0f0b30?source=collection_archive---------6-----------------------#2021-03-15</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><h2 id="4046" class="hg hh hi bd b fp hj hk hl hm hn ho dx hp translated" aria-label="kicker paragraph">移动应用中的反应式编程——一次旅行</h2><div class=""/><div class=""><h2 id="7029" class="pw-subtitle-paragraph io hr hi bd b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf dx translated">Android的JetpackCompose(或iOS的SwiftUI)是一种很棒的功能性、声明性、基于组件的UI开发技术。让我们用全局状态管理使它变得更好</h2></div><p id="51b2" class="pw-post-body-paragraph jg jh hi ji b jj jk is jl jm jn iv jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi kc translated">我们都很熟悉<a class="ae kl" href="https://reactjs.org/" rel="noopener ugc nofollow" target="_blank"> <em class="km"> React.js </em> </a>和它伟大的<a class="ae kl" href="https://reactjs.org/docs/introducing-jsx.html" rel="noopener ugc nofollow" target="_blank"> <em class="km"> JSX </em>扩展</a>用于轻松构建UI组件。它让开发人员直接从一些<em class="km">数据</em>或<em class="km">状态</em>中编写动态UI，而不是将静态UI代码(例如<em class="km"> xml </em>或<em class="km"> html </em>)和动态状态绑定代码(例如<a class="ae kl" href="https://developer.android.com/topic/libraries/view-binding" rel="noopener ugc nofollow" target="_blank"><em class="km">view binding</em></a><em class="km"/>或<a class="ae kl" href="https://jquery.com/" rel="noopener ugc nofollow" target="_blank"> <em class="km"> JQuery </em> </a>)分开。</p><p id="1bb7" class="pw-post-body-paragraph jg jh hi ji b jj jk is jl jm jn iv jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated"><em class="km"> Android </em>和<em class="km"> iOS </em>团队紧随其后，开发了他们的原生等价物<em class="km">React+JSX</em>——<a class="ae kl" href="https://developer.android.com/jetpack/compose" rel="noopener ugc nofollow" target="_blank">——<em class="km">JetpackCompose</em></a>和<a class="ae kl" href="https://developer.apple.com/xcode/swiftui/" rel="noopener ugc nofollow" target="_blank"> <em class="km"> SwiftUI </em> </a>。<br/>像<em class="km"> React </em>一样，它们提供内部状态管理，也就是说，每个‘组件’要么可以控制自己的状态，要么被自己的‘父组件’控制，父组件处理自己的状态……<br/>像<em class="km"> React </em>一样，它们缺少<a class="ae kl" href="https://spin.atomicobject.com/2017/06/07/react-state-vs-redux-state/" rel="noopener ugc nofollow" target="_blank"> <strong class="ji hs">全局</strong>状态管理</a> — <a class="ae kl" href="https://redux.js.org/" rel="noopener ugc nofollow" target="_blank"> <em class="km"> Redux </em> </a>，例如。这正是我们来这里的目的。</p><figure class="ko kp kq kr fd ks er es paragraph-image"><div role="button" tabindex="0" class="kt ku di kv bf kw"><div class="er es kn"><img src="../Images/8f3392a00558f732d326665df14ab614.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FJcegVpeEcufUGLjbeEHBA.png"/></div></div><figcaption class="kz la et er es lb lc bd b be z dx translated">一个简单的带有对话框的JetpackCompose屏幕——使用Reactdroid的存储作为状态</figcaption></figure></div><div class="ab cl ld le gp lf" role="separator"><span class="lg bw bk lh li lj"/><span class="lg bw bk lh li lj"/><span class="lg bw bk lh li"/></div><div class="hb hc hd he hf"><h2 id="09aa" class="lk ll hi bd lm ln lo lp lq lr ls lt lu jp lv lw lx jt ly lz ma jx mb mc md ho bi translated">JetpackCompose长什么样</h2><p id="b117" class="pw-post-body-paragraph jg jh hi ji b jj me is jl jm mf iv jo jp mg jr js jt mh jv jw jx mi jz ka kb hb bi translated">这是<em class="km"> JetpackCompose </em>中一个简单屏幕的样子:</p><figure class="ko kp kq kr fd ks"><div class="bz dy l di"><div class="mj mk l"/></div><figcaption class="kz la et er es lb lc bd b be z dx translated">JetpackCompose中带有标题的简单屏幕</figcaption></figure><p id="b8ff" class="pw-post-body-paragraph jg jh hi ji b jj jk is jl jm jn iv jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated">这是一个类似的例子，但是用<em class="km">动态</em>状态<em class="km">来控制标题，使用一个<em class="km">按钮</em>:</em></p><figure class="ko kp kq kr fd ks"><div class="bz dy l di"><div class="mj mk l"/></div><figcaption class="kz la et er es lb lc bd b be z dx translated">JetpackCompose中带有动态标题的简单屏幕</figcaption></figure><p id="8da6" class="pw-post-body-paragraph jg jh hi ji b jj jk is jl jm jn iv jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated">如果你在这里，你可能已经明白——一旦这个组件树在中型应用程序中变得越来越深，管理所有这些内部的<em class="km">状态</em>就变得越来越困难。此外，你必须通过层次树深处的许多<em class="km">状态</em>，例如，仅仅为了控制一个<em class="km">文本</em>，或者<em class="km">按钮</em>。<br/>更重要的是——如果你有多个具有相似UI的屏幕，或者只有一个与相似的<em class="km">状态</em>相关，你必须再次编写和管理它，并以某种方式在这些<em class="km">状态</em>之间进行连接(例如<em class="km"> SharedPrefs </em>、<em class="km"> DB </em>或<em class="km"> Intents </em>)。嗯，至少我们已经让<code class="du ml mm mn mo b"><a class="ae kl" href="https://stackoverflow.com/questions/66424642/android-jetpack-compose-by-remembersaveable-state-does-not-survive-back-button" rel="noopener ugc nofollow" target="_blank">rememberSaveable</a></code>在屏幕旋转期间保持那些<em class="km">状态</em>😅。</p></div><div class="ab cl ld le gp lf" role="separator"><span class="lg bw bk lh li lj"/><span class="lg bw bk lh li lj"/><span class="lg bw bk lh li"/></div><div class="hb hc hd he hf"><h2 id="2923" class="lk ll hi bd lm ln lo lp lq lr ls lt lu jp lv lw lx jt ly lz ma jx mb mc md ho bi translated">拥有全局状态管理看起来像什么</h2><p id="4eac" class="pw-post-body-paragraph jg jh hi ji b jj me is jl jm mf iv jo jp mg jr js jt mh jv jw jx mi jz ka kb hb bi translated">无论如何，我在这里不是要说服你为什么<strong class="ji hs">全局</strong>状态很棒，我在这里是要向你展示如何在<em class="km"> JetpackCompose </em> :) <br/>跟随<a class="ae kl" rel="noopener" href="/nerd-for-tech/reactdroid-reactive-mvi-architecture-for-android-with-a-pure-kotlin-core-multiplatform-587726a5045f">我的系列</a>上的<a class="ae kl" href="https://github.com/GuyMichael/Reactdroid" rel="noopener ugc nofollow" target="_blank"> <em class="km"> Reactdroid </em> </a>库，这里是你如何可以<em class="km">连接</em>你的<em class="km"> JetpackCompose </em>代码到<em class="km">存储库<em class="km"/></em></p><figure class="ko kp kq kr fd ks"><div class="bz dy l di"><div class="mj mk l"/></div><figcaption class="kz la et er es lb lc bd b be z dx translated">JetpackCompose中带有全局状态标题的简单屏幕，使用Reactdroid的存储</figcaption></figure><p id="a51d" class="pw-post-body-paragraph jg jh hi ji b jj jk is jl jm jn iv jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated">就是这样！现在<em class="km">标题</em>在全局范围内，可以被你整个应用程序中的许多组件跨页面使用(例如<em class="km">活动</em>)。<br/>此外，您可以在应用程序的任何地方从<strong class="ji hs">更改<em class="km">标题</em>(使用<em class="km">分派</em>)，而不管使用它的组件在哪里。</strong></p><p id="d8b1" class="pw-post-body-paragraph jg jh hi ji b jj jk is jl jm jn iv jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated">当然，作为<a class="ae kl" href="https://github.com/GuyMichael/Reactdroid" rel="noopener ugc nofollow" target="_blank"> <em class="km"> Reactdroid </em> </a>库的一部分，您可以将<em class="km"> props </em>模型用于复杂状态，而不是单个值。这次我们将导出一个<em class="km">连接的“</em>主屏幕”，而不是让它“知道”它的<em class="km">状态</em>是如何被控制的。<em class="km">jetpackcomposite</em>团队称之为<a class="ae kl" href="https://developer.android.com/codelabs/jetpack-compose-state#5" rel="noopener ugc nofollow" target="_blank"> <em class="km">吊装</em> </a>:</p><figure class="ko kp kq kr fd ks"><div class="bz dy l di"><div class="mj mk l"/></div><figcaption class="kz la et er es lb lc bd b be z dx translated">JetpackCompose中的连接屏幕，使用Reactdroid的存储和提升</figcaption></figure><p id="7b53" class="pw-post-body-paragraph jg jh hi ji b jj jk is jl jm jn iv jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated">简而言之，<em class="km">连接</em>方法<em class="km">将通常接收一些<em class="km">属性</em>的</em>组件(<em class="km">组件</em>)连接到<em class="km">存储</em>(全局状态)，并帮助您将UI代码与状态管理代码分离——与前面示例中的<code class="du ml mm mn mo b">observeAsValue</code>(以及类似方法)和<code class="du ml mm mn mo b">mutableStateOf</code>相反。就像<em class="km"> Redux </em> …</p><blockquote class="mp mq mr"><p id="d028" class="jg jh km ji b jj jk is jl jm jn iv jo ms jq jr js mt ju jv jw mu jy jz ka kb hb bi translated">依我拙见，这应该是唯一的方法/风格。<br/>现在关注点的分离被最大化了——你甚至可以让不同的开发人员在每个部分工作:<br/>纯UI代码在<em class="hi">主屏幕</em>中，连接到数据/状态代码在<em class="hi">connectedmainseen</em>中，而<em class="hi"> MainActivity </em>就像它应该的那样——完全不知道UI代码。</p></blockquote></div><div class="ab cl ld le gp lf" role="separator"><span class="lg bw bk lh li lj"/><span class="lg bw bk lh li lj"/><span class="lg bw bk lh li"/></div><div class="hb hc hd he hf"><h1 id="cbb4" class="mv ll hi bd lm mw mx my lq mz na nb lu ix nc iy lx ja nd jb ma jd ne je md nf bi translated">摘要</h1><p id="6e88" class="pw-post-body-paragraph jg jh hi ji b jj me is jl jm mf iv jo jp mg jr js jt mh jv jw jx mi jz ka kb hb bi translated">这是一个快速的概述，展示了如何将全局状态和<em class="km"> JetpackCompose </em>一起使用。它让我们在前往<a class="ae kl" href="https://kotlinlang.org/docs/multiplatform.html" rel="noopener ugc nofollow" target="_blank"> <em class="km">科特林多平台</em> </a>的旅程中又前进了一步。我希望你喜欢它，如果你想了解它是如何工作的，请继续关注。</p><blockquote class="mp mq mr"><p id="0b8c" class="jg jh km ji b jj jk is jl jm jn iv jo ms jq jr js mt ju jv jw mu jy jz ka kb hb bi translated">如果你很难理解这些例子，你可能会错过<em class="hi">上的<a class="ae kl" rel="noopener" href="/nerd-for-tech/reactdroid-reactive-mvi-architecture-for-android-with-a-pure-kotlin-core-multiplatform-587726a5045f">我的系列</a>React</em>+<em class="hi">Redux</em>中的<em class="hi"> Kotlin </em>但它基本上只是<a class="ae kl" href="https://redux.js.org/" rel="noopener ugc nofollow" target="_blank"> <em class="hi"> Redux </em> </a>样式，并绑定到JetpackCompose。这里的要点是——使用<em class="hi"> JetpackCompose </em>和<em class="hi"> SwiftUI </em> <em class="hi"> :) </em>，我们离全面的<a class="ae kl" href="https://kotlinlang.org/docs/multiplatform.html" rel="noopener ugc nofollow" target="_blank"> <em class="hi"> Kotlin多平台</em> </a> <em class="hi"> </em>库又近了一步</p></blockquote></div></div>    
</body>
</html>