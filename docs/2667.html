<html>
<head>
<title>Target Array With Multiple Sums — Daily Challenge May</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">具有多个和的目标阵列—每日挑战可能</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/target-array-with-multiple-sums-daily-challenge-may-93d18fcaff2d?source=collection_archive---------17-----------------------#2021-05-15">https://medium.com/nerd-for-tech/target-array-with-multiple-sums-daily-challenge-may-93d18fcaff2d?source=collection_archive---------17-----------------------#2021-05-15</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><figure class="hh hi ez fb hj hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es hg"><img src="../Images/bc141dfaa2505e4b40a9f55a7598cee7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nkGL_8TSse1-G2lRUU5kdg.jpeg"/></div></div><figcaption class="hr hs et er es ht hu bd b be z dx translated">照片由<a class="ae hv" href="https://unsplash.com/@deneskozma?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Denes Kozma </a>在<a class="ae hv" href="https://unsplash.com/s/photos/multiple-sum?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><div class=""/><p id="88b1" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">今天的问题来自每日Leetcode编码挑战赛——五月版。这是一个难以回答的问题。让我们看看问题陈述。</p><h2 id="2c46" class="jt ju hy bd jv jw jx jy jz ka kb kc kd jg ke kf kg jk kh ki kj jo kk kl km kn bi translated"><a class="ae hv" href="https://leetcode.com/problems/construct-target-array-with-multiple-sums/" rel="noopener ugc nofollow" target="_blank"> 1354年。</a>用多个和构造目标数组</h2><p id="91d7" class="pw-post-body-paragraph iv iw hy ix b iy ko ja jb jc kp je jf jg kq ji jj jk kr jm jn jo ks jq jr js hb bi translated">给你一个n个整数的数组<code class="du kt ku kv kw b">target</code>。从由<code class="du kt ku kv kw b">n</code> 1组成的起始数组<code class="du kt ku kv kw b">arr</code>中，您可以执行以下程序:</p><blockquote class="kx ky kz"><p id="8bd3" class="iv iw la ix b iy iz ja jb jc jd je jf lb jh ji jj lc jl jm jn ld jp jq jr js hb bi translated">1.设<code class="du kt ku kv kw b">x</code>是当前数组中所有元素的总和。<br/> 2。选择索引<code class="du kt ku kv kw b">i</code>，使得<code class="du kt ku kv kw b">0 &lt;= i &lt; n</code>，并将索引<code class="du kt ku kv kw b">i</code>处的<code class="du kt ku kv kw b">arr</code>的值设置为<code class="du kt ku kv kw b">x</code>。<br/> 3。您可以根据需要多次重复此过程。</p></blockquote><p id="5936" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">返回<code class="du kt ku kv kw b">true</code> <em class="la">如果可以从</em> <code class="du kt ku kv kw b">arr</code> <em class="la">构造</em> <code class="du kt ku kv kw b">target</code> <em class="la">数组，否则返回</em> <code class="du kt ku kv kw b">false</code>。</p><h2 id="3a42" class="jt ju hy bd jv jw jx jy jz ka kb kc kd jg ke kf kg jk kh ki kj jo kk kl km kn bi translated">示例:</h2><pre class="le lf lg lh fd li kw lj lk aw ll bi"><span id="6d17" class="jt ju hy kw b fi lm ln l lo lp"><strong class="kw hz">Input:</strong> target = [9,3,5]<br/><strong class="kw hz">Output:</strong> true</span></pre><h2 id="5d39" class="jt ju hy bd jv jw jx jy jz ka kb kc kd jg ke kf kg jk kh ki kj jo kk kl km kn bi translated">理解问题:</h2><p id="e13f" class="pw-post-body-paragraph iv iw hy ix b iy ko ja jb jc kp je jf jg kq ji jj jk kr jm jn jo ks jq jr js hb bi translated">让我们以[9，3，5]为例。如果我们从[1，1，1]开始，我们可以通过用3(当前数组的和)替换中间的1来移动到[1，3，1]。类似地，我们移到[1，3，5](用更新后的数组(1，3，1)的和5替换最右边的1) &amp; [9，3，5](用更新后的数组(1，3，5)的和9替换最左边的1)。</p><p id="0f16" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们可以回溯到[1，1，1]。为此，我们移除max元素并用1替换它。[9, 3, 5] → [1, 3, 5] → [1, 3, 1] → [1, 1, 1].为此，我们使用最大堆。</p><figure class="le lf lg lh fd hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es lq"><img src="../Images/b0a717b0c3696de3396f0a1065656d5b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*m4e8xzj7U0DzyPM-DZxu6w.png"/></div></div></figure><p id="f3b4" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">关键是，<code class="du kt ku kv kw b">target</code>数组中最大的数字一定是最近更改的数字。因此，如果我们有当前的最大值<code class="du kt ku kv kw b">curr</code>，我们将它与其余的<code class="du kt ku kv kw b">sum_rest</code>之和进行比较，该数值的先前值必须是<code class="du kt ku kv kw b">curr-sum_rest</code>，只要<code class="du kt ku kv kw b">curr-sum_rest</code>仍然大于<code class="du kt ku kv kw b">sum_rest</code>，先前值将是<code class="du kt ku kv kw b">curr-sum_rest-sum_rest</code>，以此类推，直到<code class="du kt ku kv kw b">prev = curr-k*sum_rest</code>小于<code class="du kt ku kv kw b">sum_rest</code>。如此有效<code class="du kt ku kv kw b">prev = curr % sum_rest</code>。</p><h2 id="4a08" class="jt ju hy bd jv jw jx jy jz ka kb kc kd jg ke kf kg jk kh ki kj jo kk kl km kn bi translated">代码实现:</h2><pre class="le lf lg lh fd li kw lj lk aw ll bi"><span id="db13" class="jt ju hy kw b fi lm ln l lo lp">def isPossible(target):<br/>    heap = [-el for el in target]<br/>    heapq.heapify(heap)<br/>    <br/>    sum_heap = sum(target)<br/>    <br/>    if len(target)==1: <br/>        return target[0] == 1<br/>    <br/>    while sum_heap &gt; len(target): <br/>        curr = -1 * heapq.heappop(heap)<br/>        sum_rest = sum_heap - curr<br/>        if sum_rest &gt; curr : <br/>            return False<br/>        if sum_rest==1: <br/>            return True<br/>        prev = curr % sum_rest <br/>        if prev &lt; 1: <br/>            return False<br/>        sum_heap = sum_rest + prev<br/>        heapq.heappush(heap, -prev)<br/>        <br/>    return True</span></pre><h2 id="0666" class="jt ju hy bd jv jw jx jy jz ka kb kc kd jg ke kf kg jk kh ki kj jo kk kl km kn bi translated"><strong class="ak">复杂性分析</strong></h2><ul class=""><li id="a06e" class="lr ls hy ix b iy ko jc kp jg lt jk lu jo lv js lw lx ly lz bi translated">时间复杂度:创建heapq的O(n)。log(max(array))* heapq操作的log n。</li><li id="5bae" class="lr ls hy ix b iy ma jc mb jg mc jk md jo me js lw lx ly lz bi translated">优先队列的空间复杂度为O(n)。</li></ul><p id="b758" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">编码快乐！！</p></div></div>    
</body>
</html>