<html>
<head>
<title>Todo App With GraphQL, Express.js And React — Episode 1</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用 GraphQL、Express.js 和 React 的 Todo 应用程序—第 1 集</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/todo-app-with-graphql-express-js-redux-episode-1-ccbe54b40c89?source=collection_archive---------4-----------------------#2021-05-03">https://medium.com/nerd-for-tech/todo-app-with-graphql-express-js-redux-episode-1-ccbe54b40c89?source=collection_archive---------4-----------------------#2021-05-03</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/aee247e71af8002c5249e1af3082ea89.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nkG4MeJ05GClnO2Xx0UQ0Q.png"/></div></div></figure><h1 id="6535" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">构建基本 API</h1><p id="538e" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi km translated">欢迎光临。进行 API 调用并在 web 页面上呈现响应非常有趣。但是，创建一个 API 并查询它是很棒的！此外，创建 API 可以让我们更深入地了解 API 是如何工作的，它们背后的逻辑是什么，以及当收到 API 调用时后端会发生什么。因此，如果您觉得到目前为止您已经在项目中做了足够多的 API 调用，并且您决定深入了解任何应用程序的整个过程，我可以说这篇文章可能会对您有所帮助。</p><p id="58f1" class="pw-post-body-paragraph jo jp hi jq b jr kv jt ju jv kw jx jy jz kx kb kc kd ky kf kg kh kz kj kk kl hb bi translated">我们将在这个项目中构建一个 todo 应用程序。我们将使用这些技术:</p><ul class=""><li id="eba3" class="la lb hi jq b jr kv jv kw jz lc kd ld kh le kl lf lg lh li bi translated">快递. js</li><li id="bc4b" class="la lb hi jq b jr lj jv lk jz ll kd lm kh ln kl lf lg lh li bi translated">GraphQL</li><li id="69b6" class="la lb hi jq b jr lj jv lk jz ll kd lm kh ln kl lf lg lh li bi translated">阿波罗</li><li id="dce4" class="la lb hi jq b jr lj jv lk jz ll kd lm kh ln kl lf lg lh li bi translated">蒙戈</li><li id="97b9" class="la lb hi jq b jr lj jv lk jz ll kd lm kh ln kl lf lg lh li bi translated">反应</li></ul><p id="4d34" class="pw-post-body-paragraph jo jp hi jq b jr kv jt ju jv kw jx jy jz kx kb kc kd ky kf kg kh kz kj kk kl hb bi translated">我们的项目结构如下图所示:</p><figure class="lp lq lr ls fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lo"><img src="../Images/953f0c69f967f2fd7702e97a8aa080f3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xHjiqP0ijRUT2hRUJccyZg.png"/></div></div></figure><p id="6a70" class="pw-post-body-paragraph jo jp hi jq b jr kv jt ju jv kw jx jy jz kx kb kc kd ky kf kg kh kz kj kk kl hb bi translated">这一系列文章计划由 3 集组成。这些剧集将包含以下标题:</p><ul class=""><li id="acc2" class="la lb hi jq b jr kv jv kw jz lc kd ld kh le kl lf lg lh li bi translated">构建基本 API</li><li id="9f1a" class="la lb hi jq b jr lj jv lk jz ll kd lm kh ln kl lf lg lh li bi translated">构建用户身份验证</li><li id="cb73" class="la lb hi jq b jr lj jv lk jz ll kd lm kh ln kl lf lg lh li bi translated">在前端呈现和操作数据</li></ul><p id="7384" class="pw-post-body-paragraph jo jp hi jq b jr kv jt ju jv kw jx jy jz kx kb kc kd ky kf kg kh kz kj kk kl hb bi translated">在这一集里，我们将构建一个基本的 API。它将包含一个获取 Todo 项的查询和三个创建、修改和删除项的突变。</p><p id="7989" class="pw-post-body-paragraph jo jp hi jq b jr kv jt ju jv kw jx jy jz kx kb kc kd ky kf kg kh kz kj kk kl hb bi translated">这里是<a class="ae lt" href="https://github.com/ardaorkin/todo-app-server" rel="noopener ugc nofollow" target="_blank">这一集</a>的最终代码。</p><p id="730d" class="pw-post-body-paragraph jo jp hi jq b jr kv jt ju jv kw jx jy jz kx kb kc kd ky kf kg kh kz kj kk kl hb bi translated">准备好了吗？那我们走吧！</p></div><div class="ab cl lu lv gp lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="hb hc hd he hf"><h2 id="ab58" class="mb ir hi bd is mc md me iw mf mg mh ja jz mi mj je kd mk ml ji kh mm mn jm mo bi translated">要求</h2><ul class=""><li id="2b82" class="la lb hi jq b jr js jv jw jz mp kd mq kh mr kl lf lg lh li bi translated">NodeJS 14v+</li><li id="5299" class="la lb hi jq b jr lj jv lk jz ll kd lm kh ln kl lf lg lh li bi translated">NPM 还是纱线</li><li id="c49a" class="la lb hi jq b jr lj jv lk jz ll kd lm kh ln kl lf lg lh li bi translated">NPX</li><li id="19f9" class="la lb hi jq b jr lj jv lk jz ll kd lm kh ln kl lf lg lh li bi translated">React 开发人员工具</li><li id="96da" class="la lb hi jq b jr lj jv lk jz ll kd lm kh ln kl lf lg lh li bi translated">Apollo 客户端开发工具</li></ul></div><div class="ab cl lu lv gp lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="hb hc hd he hf"><h2 id="e7ee" class="mb ir hi bd is mc md me iw mf mg mh ja jz mi mj je kd mk ml ji kh mm mn jm mo bi translated">建筑开发环境</h2><p id="369f" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi km translated"><span class="l kn ko kp bm kq kr ks kt ku di"> C </span>创建一个名为<strong class="jq hj"> todo-app </strong>的文件夹，并在<strong class="jq hj"> todo-app </strong>文件夹中再创建两个文件夹，分别名为<strong class="jq hj"> server </strong>和<strong class="jq hj"> client </strong>。</p><p id="9beb" class="pw-post-body-paragraph jo jp hi jq b jr kv jt ju jv kw jx jy jz kx kb kc kd ky kf kg kh kz kj kk kl hb bi translated">在代码编辑器中打开<strong class="jq hj"> todo-app/server </strong>文件夹，运行此命令构建 NodeJS 项目并安装依赖项:</p><pre class="lp lq lr ls fd ms mt mu mv aw mw bi"><span id="33aa" class="mb ir hi mt b fi mx my l mz na">npm init -y &amp;&amp; npm i express apollo-server-express graphql mongoose dotenv cors &amp;&amp; npm i --save-dev nodemon @babel/core @babel/node @babel/preset-env babel-loader</span></pre><p id="0402" class="pw-post-body-paragraph jo jp hi jq b jr kv jt ju jv kw jx jy jz kx kb kc kd ky kf kg kh kz kj kk kl hb bi translated">现在创建您的后端项目结构，如下所示:</p><figure class="lp lq lr ls fd ij er es paragraph-image"><div class="er es nb"><img src="../Images/5a0ae0a2d2a7cf8171bb73cc7ba64d1d.png" data-original-src="https://miro.medium.com/v2/resize:fit:468/format:webp/1*kaWZsTRe8IYqD_jhNLFVyA.png"/></div><figcaption class="nc nd et er es ne nf bd b be z dx translated">安装项目依赖项时，将自动创建 package.json、package-lock.json 文件和 node_modules 目录。因此您不需要手动创建它们。</figcaption></figure><p id="d69f" class="pw-post-body-paragraph jo jp hi jq b jr kv jt ju jv kw jx jy jz kx kb kc kd ky kf kg kh kz kj kk kl hb bi translated">创建所有文件和目录后，打开。babelrc 文件，并将这几行写入其中:</p><pre class="lp lq lr ls fd ms mt mu mv aw mw bi"><span id="7031" class="mb ir hi mt b fi mx my l mz na">{</span><span id="0272" class="mb ir hi mt b fi ng my l mz na">"presets": ["@babel/env"]</span><span id="1d57" class="mb ir hi mt b fi ng my l mz na">}</span></pre><p id="44ad" class="pw-post-body-paragraph jo jp hi jq b jr kv jt ju jv kw jx jy jz kx kb kc kd ky kf kg kh kz kj kk kl hb bi translated">我们在中进行的配置。babelrc 文件将提供我们在模块导入时使用 ES6。</p><p id="7353" class="pw-post-body-paragraph jo jp hi jq b jr kv jt ju jv kw jx jy jz kx kb kc kd ky kf kg kh kz kj kk kl hb bi translated">在进一步讨论服务器配置之前，让我们创建一个 MongoDB 云帐户。</p></div><div class="ab cl lu lv gp lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="hb hc hd he hf"><h2 id="96a3" class="mb ir hi bd is mc md me iw mf mg mh ja jz mi mj je kd mk ml ji kh mm mn jm mo bi translated">MongoDB 配置</h2><p id="ea12" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi km translated"><span class="l kn ko kp bm kq kr ks kt ku di">为了</span>配置 MongoDB，让我们在 mongodb.com/cloud 的<a class="ae lt" href="https://www.mongodb.com/cloud" rel="noopener ugc nofollow" target="_blank">创建一个账户。稍后，创建一个组织、组织中的一个项目和项目中的一个群。创建集群后，在集群所在的页面中，单击数据库访问。在那里单击添加新数据库用户选项，并创建一个数据库用户。稍后，单击左侧栏上的集群选项。在打开的页面上，单击连接按钮。在“设置连接安全性”步骤中，选择“允许任何地方”选项，然后单击“选择连接方法”。然后，让我们单击连接您的应用程序选项，并复制<strong class="jq hj">下的连接信息，将您的连接字符串添加到您的应用程序代码</strong>。<strong class="jq hj"> </strong>让我们回到文本编辑器，在。env 文件，并将 MongoDB 连接信息赋给该变量。使用刚刚在数据库访问步骤中创建的密码进行更改，并将<strong class="jq hj"> myFirstDatabase </strong>更改为<strong class="jq hj"> todolist </strong>:</a></p><pre class="lp lq lr ls fd ms mt mu mv aw mw bi"><span id="cfad" class="mb ir hi mt b fi mx my l mz na">MONGODB_URL="mongodb+srv://username:12345@cluster0.mjh9d.mongodb.net/todolist?retryWrites=true&amp;w=majority"</span></pre><p id="aecb" class="pw-post-body-paragraph jo jp hi jq b jr kv jt ju jv kw jx jy jz kx kb kc kd ky kf kg kh kz kj kk kl hb bi translated">现在，打开<strong class="jq hj"> db/connection/index.js </strong>文件，写下这几行:</p><pre class="lp lq lr ls fd ms mt mu mv aw mw bi"><span id="53cd" class="mb ir hi mt b fi mx my l mz na">import dotenv from "dotenv";</span><span id="d081" class="mb ir hi mt b fi ng my l mz na">import mongoose from "mongoose";</span><span id="3195" class="mb ir hi mt b fi ng my l mz na">dotenv.config();</span><span id="4e68" class="mb ir hi mt b fi ng my l mz na">const dbConnection = () =&gt;</span><span id="a803" class="mb ir hi mt b fi ng my l mz na">  new Promise((resolve, reject) =&gt; {</span><span id="eeb4" class="mb ir hi mt b fi ng my l mz na">    mongoose.connect(process.env.MONGODB_URL, {</span><span id="55cb" class="mb ir hi mt b fi ng my l mz na">      useNewUrlParser: true,</span><span id="cc81" class="mb ir hi mt b fi ng my l mz na">      useUnifiedTopology: true,</span><span id="605a" class="mb ir hi mt b fi ng my l mz na">      useFindAndModify: false,</span><span id="77eb" class="mb ir hi mt b fi ng my l mz na">    });</span><span id="d67d" class="mb ir hi mt b fi ng my l mz na">  const db = mongoose.connection;</span><span id="ab08" class="mb ir hi mt b fi ng my l mz na">  db.on("error", () =&gt; {</span><span id="415a" class="mb ir hi mt b fi ng my l mz na">    console.error.bind(console, "connection error:");</span><span id="4444" class="mb ir hi mt b fi ng my l mz na">      reject(</span><span id="7690" class="mb ir hi mt b fi ng my l mz na">        new Error(</span><span id="686a" class="mb ir hi mt b fi ng my l mz na">          "Connection error has occurred when trying to connect to the database!"</span><span id="d28f" class="mb ir hi mt b fi ng my l mz na">      )</span><span id="1d83" class="mb ir hi mt b fi ng my l mz na">    );</span><span id="6c20" class="mb ir hi mt b fi ng my l mz na">  });</span><span id="59a6" class="mb ir hi mt b fi ng my l mz na">  db.once("open", () =&gt; resolve("🚀 Successful database connection."));</span><span id="fdd0" class="mb ir hi mt b fi ng my l mz na">});</span><span id="5c0d" class="mb ir hi mt b fi ng my l mz na">export default dbConnection;</span></pre><p id="c10f" class="pw-post-body-paragraph jo jp hi jq b jr kv jt ju jv kw jx jy jz kx kb kc kd ky kf kg kh kz kj kk kl hb bi translated">通过这个配置，我们定义了 MongoDB 的连接信息，并提供了一个 promise 函数，可以在项目的任何地方使用。在用 JavaScript 编写后端项目时，尽可能多地创建 Promise 函数并添加错误处理行是一个好主意。</p><p id="6c49" class="pw-post-body-paragraph jo jp hi jq b jr kv jt ju jv kw jx jy jz kx kb kc kd ky kf kg kh kz kj kk kl hb bi translated">稍后，打开<strong class="jq hj"> db/models/TodoModel.js </strong>文件，用以下几行填充它:</p><pre class="lp lq lr ls fd ms mt mu mv aw mw bi"><span id="ff3d" class="mb ir hi mt b fi mx my l mz na">import mongoose from "mongoose";<br/></span><span id="f4ca" class="mb ir hi mt b fi ng my l mz na">const todoSchema = new mongoose.Schema({</span><span id="4816" class="mb ir hi mt b fi ng my l mz na">  user: String,</span><span id="eb6d" class="mb ir hi mt b fi ng my l mz na">  title: String,</span><span id="514d" class="mb ir hi mt b fi ng my l mz na">  mission: String,</span><span id="b35e" class="mb ir hi mt b fi ng my l mz na">  isDone: Boolean,</span><span id="fafe" class="mb ir hi mt b fi ng my l mz na">},</span><span id="1e1a" class="mb ir hi mt b fi ng my l mz na">{ timestamps: true });</span><span id="2df5" class="mb ir hi mt b fi ng my l mz na">const Todo = mongoose.model("Todo", todoSchema);</span><span id="1bf9" class="mb ir hi mt b fi ng my l mz na">export default Todo;</span></pre><p id="95ee" class="pw-post-body-paragraph jo jp hi jq b jr kv jt ju jv kw jx jy jz kx kb kc kd ky kf kg kh kz kj kk kl hb bi translated">现在，我们已经创建了集合的模式，该模式将放在数据库中，并从该模式中复制一个模型。让我们继续服务器配置，并运行服务器以连接到数据库。</p></div><div class="ab cl lu lv gp lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="hb hc hd he hf"><h2 id="9cfc" class="mb ir hi bd is mc md me iw mf mg mh ja jz mi mj je kd mk ml ji kh mm mn jm mo bi translated">服务器配置</h2><p id="c274" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi km translated">下面我们已经创建了 MongoDB 配置。现在，让我们使用它！</p><p id="fe96" class="pw-post-body-paragraph jo jp hi jq b jr kv jt ju jv kw jx jy jz kx kb kc kd ky kf kg kh kz kj kk kl hb bi translated">打开<strong class="jq hj"> server.js </strong>文件，将这些行写入其中:</p><pre class="lp lq lr ls fd ms mt mu mv aw mw bi"><span id="aa90" class="mb ir hi mt b fi mx my l mz na">import express from "express";</span><span id="8a91" class="mb ir hi mt b fi ng my l mz na">import dbConnection from "./db/connection";</span><span id="76ea" class="mb ir hi mt b fi ng my l mz na">const startServer = async () =&gt; {</span><span id="a824" class="mb ir hi mt b fi ng my l mz na">  await dbConnection()</span><span id="9c89" class="mb ir hi mt b fi ng my l mz na">    .then((result) =&gt; console.log(result))</span><span id="602d" class="mb ir hi mt b fi ng my l mz na">    .catch((err) =&gt; console.log(err));</span><span id="8ce8" class="mb ir hi mt b fi ng my l mz na">  const app = express();</span><span id="d203" class="mb ir hi mt b fi ng my l mz na"><br/>  app.use("/", (req, res) =&gt; res.send("Welcome to Todo App"));</span><span id="7630" class="mb ir hi mt b fi ng my l mz na">app.listen(4000, () =&gt; console.log(`🚀 Server listening on port 4000`));</span><span id="a9e3" class="mb ir hi mt b fi ng my l mz na">};</span><span id="5943" class="mb ir hi mt b fi ng my l mz na">startServer();</span></pre><p id="7cff" class="pw-post-body-paragraph jo jp hi jq b jr kv jt ju jv kw jx jy jz kx kb kc kd ky kf kg kh kz kj kk kl hb bi translated">现在打开<strong class="jq hj"> package.json </strong>文件，将这一行写入脚本部分:</p><pre class="lp lq lr ls fd ms mt mu mv aw mw bi"><span id="c260" class="mb ir hi mt b fi mx my l mz na">"start": "nodemon ./server --exec babel-node -e js",</span></pre><p id="0d2a" class="pw-post-body-paragraph jo jp hi jq b jr kv jt ju jv kw jx jy jz kx kb kc kd ky kf kg kh kz kj kk kl hb bi translated">编写完启动脚本后，您的<strong class="jq hj"> package.json </strong>的脚本部分应该如下所示:</p><pre class="lp lq lr ls fd ms mt mu mv aw mw bi"><span id="25cb" class="mb ir hi mt b fi mx my l mz na">"scripts": {</span><span id="da06" class="mb ir hi mt b fi ng my l mz na">  "start": "nodemon ./server --exec babel-node -e js",</span><span id="520b" class="mb ir hi mt b fi ng my l mz na">  "test": "echo \"Error: no test specified\" &amp;&amp; exit 1"</span><span id="b5f4" class="mb ir hi mt b fi ng my l mz na">},</span></pre><p id="846e" class="pw-post-body-paragraph jo jp hi jq b jr kv jt ju jv kw jx jy jz kx kb kc kd ky kf kg kh kz kj kk kl hb bi translated">打开控制台，使用以下命令运行服务器:</p><pre class="lp lq lr ls fd ms mt mu mv aw mw bi"><span id="f97f" class="mb ir hi mt b fi mx my l mz na">npm start</span></pre><p id="6a3a" class="pw-post-body-paragraph jo jp hi jq b jr kv jt ju jv kw jx jy jz kx kb kc kd ky kf kg kh kz kj kk kl hb bi translated">如果您在终端的输出上看到这两条消息，这意味着您成功地进行了配置:</p><pre class="lp lq lr ls fd ms mt mu mv aw mw bi"><span id="aa4b" class="mb ir hi mt b fi mx my l mz na">🚀 Successful database connection.<br/>🚀 Server listening on port 4000</span></pre><p id="850c" class="pw-post-body-paragraph jo jp hi jq b jr kv jt ju jv kw jx jy jz kx kb kc kd ky kf kg kh kz kj kk kl hb bi translated">是时候构建 GraphQL 模式并运行 Apollo 服务器了！</p></div><div class="ab cl lu lv gp lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="hb hc hd he hf"><h2 id="cb96" class="mb ir hi bd is mc md me iw mf mg mh ja jz mi mj je kd mk ml ji kh mm mn jm mo bi translated">构建 GrapQL 模式和 Apollo 服务器</h2><p id="038d" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi km translated">要构建一个 GraphQL 结构，从创建类型定义开始是一个好主意。为此，打开<strong class="jq hj">schema/typeDefs/index . js</strong>文件，并编写以下几行:</p><pre class="lp lq lr ls fd ms mt mu mv aw mw bi"><span id="e85c" class="mb ir hi mt b fi mx my l mz na">import { gql } from "apollo-server-express";</span><span id="96b4" class="mb ir hi mt b fi ng my l mz na">const typeDefs = gql`</span><span id="363b" class="mb ir hi mt b fi ng my l mz na">  type Todo {</span><span id="53ba" class="mb ir hi mt b fi ng my l mz na">    user: String</span><span id="f625" class="mb ir hi mt b fi ng my l mz na">    title: String</span><span id="1e68" class="mb ir hi mt b fi ng my l mz na">    mission: String</span><span id="7281" class="mb ir hi mt b fi ng my l mz na">    createdAt: String</span><span id="36ea" class="mb ir hi mt b fi ng my l mz na">    updatedAt: String</span><span id="cfc5" class="mb ir hi mt b fi ng my l mz na">    isDone: Boolean</span><span id="a01b" class="mb ir hi mt b fi ng my l mz na"> }</span><span id="d3de" class="mb ir hi mt b fi ng my l mz na">  input TodoInput {</span><span id="9743" class="mb ir hi mt b fi ng my l mz na">    user: String</span><span id="3a0e" class="mb ir hi mt b fi ng my l mz na">    title: String</span><span id="d75e" class="mb ir hi mt b fi ng my l mz na">    mission: String</span><span id="c4f3" class="mb ir hi mt b fi ng my l mz na">    isDone: Boolean</span><span id="94dd" class="mb ir hi mt b fi ng my l mz na">  }</span><span id="1fd7" class="mb ir hi mt b fi ng my l mz na">  type Query {</span><span id="3a1b" class="mb ir hi mt b fi ng my l mz na">    getTodoList: [Todo]</span><span id="58e3" class="mb ir hi mt b fi ng my l mz na">  }</span><span id="01c8" class="mb ir hi mt b fi ng my l mz na">  type Mutation {</span><span id="d925" class="mb ir hi mt b fi ng my l mz na">    addTodo(todo: TodoInput): Todo</span><span id="73e3" class="mb ir hi mt b fi ng my l mz na">  }`;<br/></span><span id="f2ac" class="mb ir hi mt b fi ng my l mz na">export default typeDefs;</span></pre><p id="f9f0" class="pw-post-body-paragraph jo jp hi jq b jr kv jt ju jv kw jx jy jz kx kb kc kd ky kf kg kh kz kj kk kl hb bi translated">这样，我们定义了一个与数据库集合模式并行的 Todo 类型，一个与 Todo 类型和 Todo 模式并行的输入类型。我们还定义了内置的 GraphQL 类型:查询和变异。我们将定义一个<strong class="jq hj">解析器</strong>对象，我们将为其中的查询和变异类型使用相同的属性名；此外，我们将把 MongoDB 查询函数分配给<strong class="jq hj">解析器</strong>对象中的属性。我们将把查询函数写入模型。稍后，我们将合并 Apollo 服务器配置中的类型定义、解析器和模型，这样，我们将建立<strong class="jq hj">类型定义、</strong><strong class="jq hj">解析器、</strong>和<strong class="jq hj">模型</strong>之间的关系。</p><p id="68f6" class="pw-post-body-paragraph jo jp hi jq b jr kv jt ju jv kw jx jy jz kx kb kc kd ky kf kg kh kz kj kk kl hb bi translated">现在，让我们创建模型。为此，打开<strong class="jq hj"> schema/models/index.js </strong>文件，将以下几行写入其中:</p><pre class="lp lq lr ls fd ms mt mu mv aw mw bi"><span id="3b5a" class="mb ir hi mt b fi mx my l mz na">import Todo from "../../db/models/TodoModel";</span><span id="a936" class="mb ir hi mt b fi ng my l mz na">const generateTodoModel = () =&gt; ({</span><span id="4aac" class="mb ir hi mt b fi ng my l mz na">queries: {</span><span id="1590" class="mb ir hi mt b fi ng my l mz na">  getAll: () =&gt;</span><span id="1e7e" class="mb ir hi mt b fi ng my l mz na">    new Promise(</span><span id="b991" class="mb ir hi mt b fi ng my l mz na">      async (resolve, reject) =&gt;</span><span id="5a2f" class="mb ir hi mt b fi ng my l mz na">        await Todo.find({}, (err, todo) =&gt;</span><span id="ff97" class="mb ir hi mt b fi ng my l mz na">          err ? reject(err) : resolve(todo)</span><span id="a1db" class="mb ir hi mt b fi ng my l mz na">      )<br/>    ),</span><span id="dd92" class="mb ir hi mt b fi ng my l mz na">  },</span><span id="00c2" class="mb ir hi mt b fi ng my l mz na">  mutations: {</span><span id="2f65" class="mb ir hi mt b fi ng my l mz na">    addTodo: (todo) =&gt;</span><span id="bc9f" class="mb ir hi mt b fi ng my l mz na">      new Promise((resolve, reject) =&gt;</span><span id="e35d" class="mb ir hi mt b fi ng my l mz na">        new Todo(todo).save((err, todo) =&gt; (err ? reject(err) : resolve(todo)))</span><span id="5aca" class="mb ir hi mt b fi ng my l mz na">      ),</span><span id="b342" class="mb ir hi mt b fi ng my l mz na">  },</span><span id="863a" class="mb ir hi mt b fi ng my l mz na">});</span><span id="cb7a" class="mb ir hi mt b fi ng my l mz na">export default generateTodoModel;</span></pre><p id="b0ca" class="pw-post-body-paragraph jo jp hi jq b jr kv jt ju jv kw jx jy jz kx kb kc kd ky kf kg kh kz kj kk kl hb bi translated">这样，我们就创建了将在导入的 Todo 模型上执行的查询函数，并将这些函数分配给我们创建的 GraphQL 模式中的模型。稍后，在解析器对象中，我们将通过在 Apollo 服务器中定义的上下文对象调用这些函数，并将它们作为值分配给属性。现在，让我们创建 resolver 对象并将 console.log()函数分配给属性。为此，打开<strong class="jq hj">schema/resolvers/index . js</strong>并将这些行写入其中:</p><pre class="lp lq lr ls fd ms mt mu mv aw mw bi"><span id="6c8c" class="mb ir hi mt b fi mx my l mz na">const resolvers = {</span><span id="7171" class="mb ir hi mt b fi ng my l mz na">  Query: {</span><span id="2d71" class="mb ir hi mt b fi ng my l mz na">    getTodoList: async (parent, args, context) =&gt;</span><span id="5182" class="mb ir hi mt b fi ng my l mz na">      console.log(JSON.parse(JSON.stringify(args.todo)), context)</span><span id="8614" class="mb ir hi mt b fi ng my l mz na">  },</span><span id="6954" class="mb ir hi mt b fi ng my l mz na">  Mutation: {</span><span id="7314" class="mb ir hi mt b fi ng my l mz na">    addTodo: async (parent, args, context) =&gt;</span><span id="55f9" class="mb ir hi mt b fi ng my l mz na">      console.log(JSON.parse(JSON.stringify(args.todo)), context)</span><span id="0a2c" class="mb ir hi mt b fi ng my l mz na">  },</span><span id="d595" class="mb ir hi mt b fi ng my l mz na">};</span><span id="e93a" class="mb ir hi mt b fi ng my l mz na">export default resolvers;</span></pre><p id="21b1" class="pw-post-body-paragraph jo jp hi jq b jr kv jt ju jv kw jx jy jz kx kb kc kd ky kf kg kh kz kj kk kl hb bi translated">现在，我们已经创建了<strong class="jq hj">类型定义</strong>、<strong class="jq hj">、</strong>、<strong class="jq hj">解析器</strong>、<strong class="jq hj">T22、<strong class="jq hj">模型</strong>。是时候创建 Apollo 服务器配置并与那些 GraphQL 元素建立关系了。要做到这一点，打开<strong class="jq hj"> server.js 文件</strong>并像这样修改它:</strong></p><pre class="lp lq lr ls fd ms mt mu mv aw mw bi"><span id="2c25" class="mb ir hi mt b fi mx my l mz na">import express from "express";</span><span id="92d0" class="mb ir hi mt b fi ng my l mz na">import { ApolloServer } from "apollo-server-express";</span><span id="29f4" class="mb ir hi mt b fi ng my l mz na">import typeDefs from "./schema/typeDefs";</span><span id="8bf2" class="mb ir hi mt b fi ng my l mz na">import resolvers from "./schema/resolvers";</span><span id="e5b8" class="mb ir hi mt b fi ng my l mz na">import generateTodoModel from "./schema/models";</span><span id="e1a3" class="mb ir hi mt b fi ng my l mz na">import dbConnection from "./db/connection";</span><span id="1804" class="mb ir hi mt b fi ng my l mz na">import cors from "cors"<br/></span><span id="ff01" class="mb ir hi mt b fi ng my l mz na">const startApolloServer = async () =&gt; {</span><span id="e90b" class="mb ir hi mt b fi ng my l mz na">  await dbConnection()</span><span id="5d35" class="mb ir hi mt b fi ng my l mz na">    .then((result) =&gt; console.log(result))</span><span id="3df3" class="mb ir hi mt b fi ng my l mz na">    .catch((err) =&gt; console.log(err));</span><span id="a07e" class="mb ir hi mt b fi ng my l mz na">  const app = express();<br/>  app.use(cors())</span><span id="331a" class="mb ir hi mt b fi ng my l mz na">  const server = new ApolloServer({</span><span id="2f89" class="mb ir hi mt b fi ng my l mz na">    typeDefs,</span><span id="0353" class="mb ir hi mt b fi ng my l mz na">    resolvers,</span><span id="edbf" class="mb ir hi mt b fi ng my l mz na">    subscriptions: { path: "/subscriptions" },</span><span id="dd1f" class="mb ir hi mt b fi ng my l mz na">    context: ({ req }) =&gt; {</span><span id="1d8c" class="mb ir hi mt b fi ng my l mz na">      return {</span><span id="3d22" class="mb ir hi mt b fi ng my l mz na">        models: {</span><span id="2f08" class="mb ir hi mt b fi ng my l mz na">          Todo: generateTodoModel(),</span><span id="a899" class="mb ir hi mt b fi ng my l mz na">        },</span><span id="3bf1" class="mb ir hi mt b fi ng my l mz na">      };</span><span id="b885" class="mb ir hi mt b fi ng my l mz na">    },</span><span id="8685" class="mb ir hi mt b fi ng my l mz na">  });</span><span id="1f83" class="mb ir hi mt b fi ng my l mz na">  await server.start();</span><span id="08dc" class="mb ir hi mt b fi ng my l mz na">  server.applyMiddleware({ app });</span><span id="d7e1" class="mb ir hi mt b fi ng my l mz na">  app.use((req, res) =&gt; {</span><span id="a763" class="mb ir hi mt b fi ng my l mz na">    res.status(200);</span><span id="c2da" class="mb ir hi mt b fi ng my l mz na">    res.send("Welcome Todo App");</span><span id="68fc" class="mb ir hi mt b fi ng my l mz na">    res.end();</span><span id="d6f9" class="mb ir hi mt b fi ng my l mz na">  });<br/></span><span id="0ba0" class="mb ir hi mt b fi ng my l mz na">  await new Promise((resolve) =&gt; app.listen({ port: 4000 }, resolve));</span><span id="f04d" class="mb ir hi mt b fi ng my l mz na">  console.log(`🚀 Server ready at http://localhost:4000${server.graphqlPath}`);</span><span id="5ea3" class="mb ir hi mt b fi ng my l mz na">  console.log(</span><span id="ed63" class="mb ir hi mt b fi ng my l mz na">`🚀 Subscriptions ready at ws://localhost:4000${server.subscriptionsPath}`</span><span id="2bcb" class="mb ir hi mt b fi ng my l mz na">  );</span><span id="9ab8" class="mb ir hi mt b fi ng my l mz na">  return { server, app };</span><span id="cc0a" class="mb ir hi mt b fi ng my l mz na">};</span><span id="2bd0" class="mb ir hi mt b fi ng my l mz na">startApolloServer();</span></pre><p id="0121" class="pw-post-body-paragraph jo jp hi jq b jr kv jt ju jv kw jx jy jz kx kb kc kd ky kf kg kh kz kj kk kl hb bi translated">如您所见，我们构建了 Apollo 服务器，并在其中创建了<strong class="jq hj">类型定义</strong>、<strong class="jq hj">解析器</strong>和<strong class="jq hj">模型</strong>之间的关系。现在，检查您之前运行<code class="du nh ni nj mt b">npm start</code>命令的终端。如果您在终端的输出上看到这些消息…</p><pre class="lp lq lr ls fd ms mt mu mv aw mw bi"><span id="7b7b" class="mb ir hi mt b fi mx my l mz na">🚀 Successful database connection.<br/>🚀 Server ready at <a class="ae lt" href="http://localhost:4000/graphql" rel="noopener ugc nofollow" target="_blank">http://localhost:4000/graphql</a><br/>🚀 Subscriptions ready at <a class="ae lt" href="http://localhost:4000/subscriptions" rel="noopener ugc nofollow" target="_blank">ws://localhost:4000/subscriptions</a></span></pre><p id="d1a7" class="pw-post-body-paragraph jo jp hi jq b jr kv jt ju jv kw jx jy jz kx kb kc kd ky kf kg kh kz kj kk kl hb bi translated">…祝贺您，您已经成功运行了一台 Apollo 服务器！</p><p id="dffc" class="pw-post-body-paragraph jo jp hi jq b jr kv jt ju jv kw jx jy jz kx kb kc kd ky kf kg kh kz kj kk kl hb bi translated">你在 Apollo 服务器配置中看到了<strong class="jq hj">上下文</strong>功能吗？它将来自<strong class="jq hj"> express 服务器</strong>的<strong class="jq hj"> req </strong>对象作为参数。然而，它现在不用它了。无论如何，更重要的是看看<strong class="jq hj">上下文</strong>函数返回什么——它返回我们在 GraphQL 模式中定义的模型！</p><p id="51e3" class="pw-post-body-paragraph jo jp hi jq b jr kv jt ju jv kw jx jy jz kx kb kc kd ky kf kg kh kz kj kk kl hb bi translated">现在，在解析器中，让我们调用模型中定义的函数。记住，到目前为止，我们只是将查询元素记录到控制台。让我们通过解析器运行一个真正的数据库查询，而不是仅仅将事情记录到控制台。为此，打开<strong class="jq hj">schema/resolvers/index . js</strong>并进行如下更改:</p><pre class="lp lq lr ls fd ms mt mu mv aw mw bi"><span id="2515" class="mb ir hi mt b fi mx my l mz na">const resolvers = {</span><span id="984d" class="mb ir hi mt b fi ng my l mz na">  Query: {</span><span id="6fec" class="mb ir hi mt b fi ng my l mz na">    getTodoList: async (parent, args, context) =&gt;</span><span id="87ef" class="mb ir hi mt b fi ng my l mz na">      await context.models.Todo.queries.getAll(),</span><span id="1e28" class="mb ir hi mt b fi ng my l mz na">  },</span><span id="0efd" class="mb ir hi mt b fi ng my l mz na">  Mutation: {</span><span id="b30a" class="mb ir hi mt b fi ng my l mz na">    addTodo: async (parent, args, context) =&gt;</span><span id="bf27" class="mb ir hi mt b fi ng my l mz na">      await context.models.Todo.mutations.addTodo(</span><span id="aa52" class="mb ir hi mt b fi ng my l mz na">        JSON.parse(JSON.stringify(args.todo))</span><span id="6890" class="mb ir hi mt b fi ng my l mz na">      ),</span><span id="46f8" class="mb ir hi mt b fi ng my l mz na">  },</span><span id="1a64" class="mb ir hi mt b fi ng my l mz na">};</span><span id="0ae8" class="mb ir hi mt b fi ng my l mz na">export default resolvers;</span></pre><p id="cf64" class="pw-post-body-paragraph jo jp hi jq b jr kv jt ju jv kw jx jy jz kx kb kc kd ky kf kg kh kz kj kk kl hb bi translated">有了这个配置，我们就能够使用 GraphQL 查询语言运行 MongoDB 查询。要运行一个真正的查询，在浏览器中打开<a class="ae lt" href="http://localhost:4000/graphql" rel="noopener ugc nofollow" target="_blank">http://localhost:4000/graph QL</a>地址，然后运行一个将创建一个新 todo 的变异，如下所示:</p><figure class="lp lq lr ls fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es nk"><img src="../Images/ce0200501117f7c0adc7f362ade6962f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bffSJLcj_36meD8kCrhkaQ.png"/></div></div></figure><p id="8709" class="pw-post-body-paragraph jo jp hi jq b jr kv jt ju jv kw jx jy jz kx kb kc kd ky kf kg kh kz kj kk kl hb bi translated">如果您看到了<strong class="jq hj">数据</strong>对象，这意味着您已经完成了正确的配置，并且已经向 MongoDB 添加了一个 todo 对象。为了确保安全，请查看 MongoDB 集合。单击 MongoDB 云中集群页面中的 Collections 选项卡。在出现的页面上，单击名为<strong class="jq hj"> todolist </strong>的数据库下名为<strong class="jq hj"> todo </strong>的集合。</p><figure class="lp lq lr ls fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es nl"><img src="../Images/462abb43c754961511b69ac54d9df7b4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MzgqO5awgUlXAELQBFH8vA.png"/></div></div></figure><p id="ca4d" class="pw-post-body-paragraph jo jp hi jq b jr kv jt ju jv kw jx jy jz kx kb kc kd ky kf kg kh kz kj kk kl hb bi translated">到目前为止，我们已经添加了一个查询解析器和一个变异解析器。让我们再添加两个变异解析器来修改和删除 todo 项。为此，打开<strong class="jq hj"> schema/models/index.js </strong>文件，并将这些函数写入<strong class="jq hj">突变</strong>对象:</p><pre class="lp lq lr ls fd ms mt mu mv aw mw bi"><span id="e843" class="mb ir hi mt b fi mx my l mz na">modifyItem: (body) =&gt;</span><span id="a4ee" class="mb ir hi mt b fi ng my l mz na">  new Promise(</span><span id="1b4e" class="mb ir hi mt b fi ng my l mz na">    async (resolve, reject) =&gt;</span><span id="1b69" class="mb ir hi mt b fi ng my l mz na">      await Todo.findByIdAndUpdate(body.id, body.query, (err, todo) =&gt;</span><span id="b75d" class="mb ir hi mt b fi ng my l mz na">        err ? reject(err) : resolve(todo)</span><span id="3bdf" class="mb ir hi mt b fi ng my l mz na">        )</span><span id="097d" class="mb ir hi mt b fi ng my l mz na">  ),</span><span id="0b7b" class="mb ir hi mt b fi ng my l mz na">  deleteItem: (id) =&gt;</span><span id="6d5d" class="mb ir hi mt b fi ng my l mz na">    new Promise(</span><span id="0e6d" class="mb ir hi mt b fi ng my l mz na">      async (resolve, reject) =&gt;</span><span id="ed24" class="mb ir hi mt b fi ng my l mz na">        await Todo.findByIdAndDelete(id, (err, todo) =&gt;</span><span id="b301" class="mb ir hi mt b fi ng my l mz na">          err ? reject(err) : resolve(todo)</span><span id="bea5" class="mb ir hi mt b fi ng my l mz na">        )</span><span id="dd4c" class="mb ir hi mt b fi ng my l mz na">   ),</span></pre><p id="0513" class="pw-post-body-paragraph jo jp hi jq b jr kv jt ju jv kw jx jy jz kx kb kc kd ky kf kg kh kz kj kk kl hb bi translated">然后转到<strong class="jq hj">schema/resolvers/index . js</strong>文件，将这些行写入<strong class="jq hj">突变</strong>:</p><pre class="lp lq lr ls fd ms mt mu mv aw mw bi"><span id="8e9d" class="mb ir hi mt b fi mx my l mz na">modifyItem: async (parent, args, context) =&gt;</span><span id="2b7f" class="mb ir hi mt b fi ng my l mz na">  await context.models.Todo.mutations.modifyItem(</span><span id="8541" class="mb ir hi mt b fi ng my l mz na">    JSON.parse(JSON.stringify(args))</span><span id="d3ff" class="mb ir hi mt b fi ng my l mz na">  ),</span><span id="eee7" class="mb ir hi mt b fi ng my l mz na">deleteItem: async (parent, args, context) =&gt;</span><span id="5134" class="mb ir hi mt b fi ng my l mz na">  await context.models.Todo.mutations.deleteItem(</span><span id="65c8" class="mb ir hi mt b fi ng my l mz na">    JSON.parse(JSON.stringify(args.id))</span><span id="4b07" class="mb ir hi mt b fi ng my l mz na">  ),</span></pre><p id="3bde" class="pw-post-body-paragraph jo jp hi jq b jr kv jt ju jv kw jx jy jz kx kb kc kd ky kf kg kh kz kj kk kl hb bi translated">最后，转到<strong class="jq hj">schema/typeDefs/index . js</strong>文件，将这些行写入<strong class="jq hj">突变</strong>类型:</p><pre class="lp lq lr ls fd ms mt mu mv aw mw bi"><span id="9fcc" class="mb ir hi mt b fi mx my l mz na">modifyItem(id: ID!, query: TodoInput): Todo</span><span id="01a7" class="mb ir hi mt b fi ng my l mz na">deleteItem(id: ID!): Todo</span></pre><p id="688e" class="pw-post-body-paragraph jo jp hi jq b jr kv jt ju jv kw jx jy jz kx kb kc kd ky kf kg kh kz kj kk kl hb bi translated">现在，在浏览器中打开<a class="ae lt" href="http://localhost:4000/graphql" rel="noopener ugc nofollow" target="_blank">http://localhost:4000/graph QL</a>。并运行<strong class="jq hj"> GetTodos </strong>查询:</p><figure class="lp lq lr ls fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es nk"><img src="../Images/f9e36648fc96608796574af1f45dca33.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IeMc3zSJ-DZoMWxjZI1RkA.png"/></div></div></figure><p id="899f" class="pw-post-body-paragraph jo jp hi jq b jr kv jt ju jv kw jx jy jz kx kb kc kd ky kf kg kh kz kj kk kl hb bi translated">从返回值中复制<strong class="jq hj"> _id </strong>属性，在 Apollo playground 上打开一个新标签，然后运行一个<strong class="jq hj"> ModifyItem </strong>变异，如下所示:</p><figure class="lp lq lr ls fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es nm"><img src="../Images/56d38b19006a725506a204b696a7b108.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4BG3xSblv3QwBIjAhThcjQ.png"/></div></div></figure><p id="0a9e" class="pw-post-body-paragraph jo jp hi jq b jr kv jt ju jv kw jx jy jz kx kb kc kd ky kf kg kh kz kj kk kl hb bi translated">请参见<strong class="jq hj"> updatedAt </strong>和<strong class="jq hj"> isDone </strong>属性已更改。在 MongoDB 连接配置中，我们提供了 updateAt 属性以在每个更新操作中进行更改，并且我们已经通过在 Apollo 服务器上运行的查询更改了<strong class="jq hj"> isDone </strong>。让我们运行一个删除查询。在 playground 中打开一个新的选项卡，然后像这样运行一个删除查询:</p><figure class="lp lq lr ls fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es nm"><img src="../Images/96bbc46051c45990b521cf303bc51c64.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*r-Bzdsdc_-8Sj7uefN4oQw.png"/></div></div></figure><p id="9caa" class="pw-post-body-paragraph jo jp hi jq b jr kv jt ju jv kw jx jy jz kx kb kc kd ky kf kg kh kz kj kk kl hb bi translated">就是这样！我们有一个可以运行 GraphQL 查询的 API，我们有一个 NoSQL 数据库，我们有一个与 express.js 集成的 Apollo 服务器。干得好！</p><p id="7ba9" class="pw-post-body-paragraph jo jp hi jq b jr kv jt ju jv kw jx jy jz kx kb kc kd ky kf kg kh kz kj kk kl hb bi translated">下次我们将基于 API 调用复制 JSON Web Token，并在 Apollo 服务器上进行用户认证和授权配置！</p></div></div>    
</body>
</html>