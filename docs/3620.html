<html>
<head>
<title>Stock Prediction Using Prophet</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Prophet进行股票预测</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/stock-prediction-using-prophet-31c6e09de0d3?source=collection_archive---------17-----------------------#2021-06-16">https://medium.com/nerd-for-tech/stock-prediction-using-prophet-31c6e09de0d3?source=collection_archive---------17-----------------------#2021-06-16</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><h1 id="8dc5" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">设置阶段</h1><p id="fd5d" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">在这篇文章中，我将讨论预测股票价格的股票使用脸书先知，这是一个开源库。Prophet使用时间序列数据框架进行未来预测。我将使用google colab来演示这一点。为了搭建平台，我们需要安装yahoofinace(yfinance ),它将是提取历史股票时间序列数据的来源，Prophet(prophet)库将用于预测，pandas将修改数据框架以适应Prophet的要求。金融、先知和熊猫这三个库是因为使用导入函数而被调用的。</p><blockquote class="kb kc kd"><p id="943f" class="jd je ke jf b jg kf ji jj jk kg jm jn kh ki jq jr kj kk ju jv kl km jy jz ka hb bi translated"><strong class="jf hj">T1】！pip安装yfinanceT3】</strong></p><p id="f00d" class="jd je ke jf b jg kf ji jj jk kg jm jn kh ki jq jr kj kk ju jv kl km jy jz ka hb bi translated"><strong class="jf hj">T5！pip安装先知T7】</strong></p><p id="477d" class="jd je ke jf b jg kf ji jj jk kg jm jn kh ki jq jr kj kk ju jv kl km jy jz ka hb bi translated"><strong class="jf hj"> <em class="hi">导入熊猫为pd </em> </strong></p><p id="c6ff" class="jd je ke jf b jg kf ji jj jk kg jm jn kh ki jq jr kj kk ju jv kl km jy jz ka hb bi translated"><strong class="jf hj"> <em class="hi">导入yfinance为yf </em> </strong></p><p id="4fda" class="jd je ke jf b jg kf ji jj jk kg jm jn kh ki jq jr kj kk ju jv kl km jy jz ka hb bi translated"><strong class="jf hj"> <em class="hi">从先知导入先知</em> </strong></p></blockquote><h1 id="da52" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">正在准备数据集</h1><p id="81d3" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">现在使用雅虎财经(yfinance)下载股票的历史数据。股票的股票代码可以从雅虎财经网站获得。在目前的情况下，我已经创建了RIL数据框架，其中包含从yf下载的印度信实有限公司的历史市场数据。当前情况下的股票代码是RELIANCE.NS。需要使用head/tail函数检查数据框。在本例中，我们可以看到RIL数据框架有“日期”、“开盘价”、“最高价”、“最低价”、“收盘价”、“调整收盘价”和“成交量”栏。</p><blockquote class="kb kc kd"><p id="ba95" class="jd je ke jf b jg kf ji jj jk kg jm jn kh ki jq jr kj kk ju jv kl km jy jz ka hb bi translated"><strong class="jf hj"><em class="hi">RIL = YF . download(‘信诚。</em>NS’)</strong></p><p id="cb4a" class="jd je ke jf b jg kf ji jj jk kg jm jn kh ki jq jr kj kk ju jv kl km jy jz ka hb bi translated"><strong class="jf hj"> <em class="hi"> RIL=RIL.sort_values('日期')。</em>reset _ index()</strong></p><p id="1bdf" class="jd je ke jf b jg kf ji jj jk kg jm jn kh ki jq jr kj kk ju jv kl km jy jz ka hb bi translated"><strong class="jf hj"> <em class="hi"> RIL.tail(3) </em> </strong></p></blockquote><h1 id="e707" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">数据集分析和工程</h1><p id="6f33" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">在一个理想的世界里，所有的方面都应该被考虑到股票的市场价格中。鉴于这一点和先知图书馆的要求，我们将从RIL数据框架中删除除“日期”和“调整关闭”之外的所有列。Prophet接受熊猫期望的ds(日期戳)格式，即YYYY-MM-DD表示日期，YYYY-MM-DD表示时间戳。为了将数据帧RIL与Prophet一起使用，我们需要将列名更改为“ds”和“y”</p><blockquote class="kb kc kd"><p id="95c7" class="jd je ke jf b jg kf ji jj jk kg jm jn kh ki jq jr kj kk ju jv kl km jy jz ka hb bi translated"><strong class="jf hj"> <em class="hi"> RIL = RIL[['日期'，'形容词关闭']] </em> </strong></p><p id="35ea" class="jd je ke jf b jg kf ji jj jk kg jm jn kh ki jq jr kj kk ju jv kl km jy jz ka hb bi translated"><strong class="jf hj"><em class="hi">【RIL = RIL . rename(columns = { ' Date ':' ds '，' Adj Close': 'y'}) </em> </strong></p><p id="251f" class="jd je ke jf b jg kf ji jj jk kg jm jn kh ki jq jr kj kk ju jv kl km jy jz ka hb bi translated"><strong class="jf hj"><em class="hi">RIL . head②</em></strong></p></blockquote><h1 id="bbbd" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">将Prophet模型应用于数据集</h1><p id="31cd" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">我们现在都准备好了。调用先知函数并命名。我把它命名为模型(可能是任何东西)。现在把这个模型放到RIL的数据框架中。还有其他一些我们在本文中不会考虑的参数，因此，一旦执行了单元代码，请忽略#INFO。</p><blockquote class="kb kc kd"><p id="b5e9" class="jd je ke jf b jg kf ji jj jk kg jm jn kh ki jq jr kj kk ju jv kl km jy jz ka hb bi translated"><strong class="jf hj"> <em class="hi">型号=先知()</em> </strong></p><p id="8845" class="jd je ke jf b jg kf ji jj jk kg jm jn kh ki jq jr kj kk ju jv kl km jy jz ka hb bi translated"><strong class="jf hj"><em class="hi">【RIL】</em></strong></p></blockquote><h1 id="7036" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">创建测试/预测数据集</h1><p id="8b5a" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">为了进行预测，我们需要一个带有ds列的数据帧，其中包含要进行预测的日期。这可以使用帮助器方法Prophet.make_future_dataframe适当地创建，指定需要进行预测的天数。默认情况下，该数据框架还将包括历史记录中的日期，以便我们可以检查模型是否合适。</p><blockquote class="kb kc kd"><p id="cfe6" class="jd je ke jf b jg kf ji jj jk kg jm jn kh ki jq jr kj kk ju jv kl km jy jz ka hb bi translated"><strong class="jf hj"><em class="hi">future = model . make _ future _ data frame(periods = 30)</em></strong></p><p id="208c" class="jd je ke jf b jg kf ji jj jk kg jm jn kh ki jq jr kj kk ju jv kl km jy jz ka hb bi translated"><strong class="jf hj"><em class="hi"/></strong></p></blockquote><h1 id="e316" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">获得预测结果</h1><p id="562d" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">当我们执行model.predict(future)时，根据历史数据(上面的RIL数据帧)训练的模型现在用于将预测值(yhat)传递给未来数据集(类似于测试数据集)的每一行。结果保存在新的数据集预测中，除了时间序列标记(ds)、预测值(ys)值之外，还包括误差的上限(yhat_upper)和下限(yhat_lower)。</p><blockquote class="kb kc kd"><p id="eeeb" class="jd je ke jf b jg kf ji jj jk kg jm jn kh ki jq jr kj kk ju jv kl km jy jz ka hb bi translated"><strong class="jf hj"><em class="hi">fore</em>cast =<em class="hi"/></strong></p><p id="5b82" class="jd je ke jf b jg kf ji jj jk kg jm jn kh ki jq jr kj kk ju jv kl km jy jz ka hb bi translated"><strong class="jf hj"> <em class="hi">预测[['ds '，' yhat '，' yhat_lower '，' yhat_upper']]。</em>尾巴()</strong></p></blockquote><h1 id="0cb6" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">交互式可视化</h1><p id="ade1" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">为了便于可视化，可以调用plot_plotly、plot_components_plotly，并使用“模型”和“预测”执行函数plot_plotly。</p><blockquote class="kb kc kd"><p id="d566" class="jd je ke jf b jg kf ji jj jk kg jm jn kh ki jq jr kj kk ju jv kl km jy jz ka hb bi translated"><em class="hi">从prophet.plot导入plot_plotly，plot_components_plotly </em></p><p id="0d80" class="jd je ke jf b jg kf ji jj jk kg jm jn kh ki jq jr kj kk ju jv kl km jy jz ka hb bi translated"><em class="hi"> plot_plotly(模型，预测)</em></p></blockquote><h1 id="b75f" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">参考</h1><div class="kn ko ez fb kp kq"><a href="https://facebook.github.io/prophet/docs/quick_start.html" rel="noopener  ugc nofollow" target="_blank"><div class="kr ab dw"><div class="ks ab kt cl cj ku"><h2 class="bd hj fi z dy kv ea eb kw ed ef hh bi translated">快速启动</h2><div class="kx l"><h3 class="bd b fi z dy kv ea eb kw ed ef dx translated">Prophet遵循sklearn模型API。我们创建一个Prophet类的实例，然后调用它的fit和predict…</h3></div><div class="ky l"><p class="bd b fp z dy kv ea eb kw ed ef dx translated">facebook.github.io</p></div></div><div class="kz l"><div class="la l lb lc ld kz le lf kq"/></div></div></a></div></div></div>    
</body>
</html>