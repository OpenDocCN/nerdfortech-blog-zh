<html>
<head>
<title>JavaScript Memoization Patterns</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript记忆模式</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/javascript-memoization-patterns-f0438f96a696?source=collection_archive---------7-----------------------#2021-02-27">https://medium.com/nerd-for-tech/javascript-memoization-patterns-f0438f96a696?source=collection_archive---------7-----------------------#2021-02-27</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div class="er es if"><img src="../Images/8b7a7c782d556aaad8fb141995306b8b.png" data-original-src="https://miro.medium.com/v2/resize:fit:960/format:webp/1*0wuagP2HJdq7gI39h29z0A.jpeg"/></div></figure><h2 id="c8f1" class="im in hi bd io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj bi translated">什么是记忆化？</h2><p id="d282" class="pw-post-body-paragraph jk jl hi jm b jn jo jp jq jr js jt ju ix jv jw jx jb jy jz ka jf kb kc kd ke hb bi translated">记忆化是一种优化技术，它基于记忆用相同参数调用的函数返回的结果。</p><p id="85c6" class="pw-post-body-paragraph jk jl hi jm b jn kf jp jq jr kg jt ju ix kh jw jx jb ki jz ka jf kj kc kd ke hb bi translated">如果我们有一个消耗大量计算的纯函数，那么我们可以使用记忆化。</p><p id="43b5" class="pw-post-body-paragraph jk jl hi jm b jn kf jp jq jr kg jt ju ix kh jw jx jb ki jz ka jf kj kc kd ke hb bi translated">记忆将帮助我们存储已经获得的输出值，然后下一次使用相同的输入值调用该函数时，它可以简单地返回存储的值，而无需进行所有的计算。</p><h2 id="e27b" class="im in hi bd io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj bi translated">记住斐波那契</h2><p id="b662" class="pw-post-body-paragraph jk jl hi jm b jn jo jp jq jr js jt ju ix jv jw jx jb jy jz ka jf kb kc kd ke hb bi translated">没有<strong class="jm hj">记忆</strong>计算量过大，以下函数耗时4727 ms:</p><figure class="kl km kn ko fd ij er es paragraph-image"><div class="er es kk"><img src="../Images/1cac54f1b93e208bbbceff0df8b4d37c.png" data-original-src="https://miro.medium.com/v2/resize:fit:920/format:webp/1*xlgRg7n_gqs9Oq1I5zQRuw.png"/></div></figure><p id="2d9a" class="pw-post-body-paragraph jk jl hi jm b jn kf jp jq jr kg jt ju ix kh jw jx jb ki jz ka jf kj kc kd ke hb bi translated">多亏了<strong class="jm hj">记忆</strong>，我们在性能上获得了很大的提升，消耗的时间减少到了1毫秒；</p><figure class="kl km kn ko fd ij er es paragraph-image"><div class="er es kp"><img src="../Images/f016c0d43b2b972055372914aec1b9c5.png" data-original-src="https://miro.medium.com/v2/resize:fit:938/format:webp/1*z1LKCFtKTkgH4UWrKggXGQ.png"/></div></figure><h2 id="4e0d" class="im in hi bd io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj bi translated">记忆模式</h2><p id="449c" class="pw-post-body-paragraph jk jl hi jm b jn jo jp jq jr js jt ju ix jv jw jx jb jy jz ka jf kb kc kd ke hb bi translated">实现<strong class="jm hj">记忆</strong>有两种模式:</p><ul class=""><li id="25c2" class="kq kr hi jm b jn kf jr kg ix ks jb kt jf ku ke kv kw kx ky bi translated">作为一个对象运行</li><li id="4e1f" class="kq kr hi jm b jn kz jr la ix lb jb lc jf ld ke kv kw kx ky bi translated">高阶函数</li><li id="9d9d" class="kq kr hi jm b jn kz jr la ix lb jb lc jf ld ke kv kw kx ky bi translated"><a class="ae le" href="https://thelbouffi.medium.com/easy-way-to-grasp-javascript-closures-7dc45fe998d9" rel="noopener">关闭</a></li></ul><h2 id="0047" class="im in hi bd io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj bi translated">作为一个对象运行</h2><p id="efc7" class="pw-post-body-paragraph jk jl hi jm b jn jo jp jq jr js jt ju ix jv jw jx jb jy jz ka jf kb kc kd ke hb bi translated">函数作为一个对象(实际上就是这样)，我们在其中存储缓存的值(而不是使用全局变量)是我们第一种<strong class="jm hj">内存化</strong>的方式，如下例所示:</p><figure class="kl km kn ko fd ij er es paragraph-image"><div class="er es lf"><img src="../Images/173df3ab37f6c315b2d66573837e1ae8.png" data-original-src="https://miro.medium.com/v2/resize:fit:974/format:webp/1*ni4kxpH2HpgqK03kkcABnQ.png"/></div></figure><p id="3895" class="pw-post-body-paragraph jk jl hi jm b jn kf jp jq jr kg jt ju ix kh jw jx jb ki jz ka jf kj kc kd ke hb bi translated">我们看到，只要进程还活着，结果就会缓存在函数中。</p><p id="d82b" class="pw-post-body-paragraph jk jl hi jm b jn kf jp jq jr kg jt ju ix kh jw jx jb ki jz ka jf kj kc kd ke hb bi translated">斐波那契函数也是如此</p><figure class="kl km kn ko fd ij er es paragraph-image"><div class="er es lg"><img src="../Images/2879dbb18b91430624b964442ef10469.png" data-original-src="https://miro.medium.com/v2/resize:fit:1128/format:webp/1*aUl5Hvsz_b8ga1D_7Hx9Nw.png"/></div></figure><p id="ad16" class="pw-post-body-paragraph jk jl hi jm b jn kf jp jq jr kg jt ju ix kh jw jx jb ki jz ka jf kj kc kd ke hb bi translated">同样的行为，当我们有多个论点时</p><figure class="kl km kn ko fd ij er es paragraph-image"><div class="er es lh"><img src="../Images/ec07fd349c2a38c14e5c26f1347eae77.png" data-original-src="https://miro.medium.com/v2/resize:fit:740/format:webp/1*vvqB-bi6tYHpZ7zTJLTjaw.png"/></div></figure><h2 id="31ef" class="im in hi bd io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj bi translated">高阶函数记忆</h2><p id="bfcf" class="pw-post-body-paragraph jk jl hi jm b jn jo jp jq jr js jt ju ix jv jw jx jb jy jz ka jf kb kc kd ke hb bi translated"><strong class="jm hj">高阶函数</strong>是<strong class="jm hj">记忆</strong>的第二种方式，正如我们在这个例子中看到的，我们将函数<strong class="jm hj">记忆</strong>放在一个<strong class="jm hj">高阶函数</strong>中:</p><figure class="kl km kn ko fd ij er es paragraph-image"><div class="er es li"><img src="../Images/e65db9db845884ea3eb8919b0b90a02b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1054/format:webp/1*ISucbduKOS1yBVfwIXbhvw.png"/></div></figure><h2 id="3dfa" class="im in hi bd io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj bi translated">封闭记忆化</h2><p id="014b" class="pw-post-body-paragraph jk jl hi jm b jn jo jp jq jr js jt ju ix jv jw jx jb jy jz ka jf kb kc kd ke hb bi translated">我们可以使用的第三种记忆方法也是最快的方法是使用<a class="ae le" href="https://thelbouffi.medium.com/easy-way-to-grasp-javascript-closures-7dc45fe998d9" rel="noopener"> <strong class="jm hj">闭包</strong> </a>。例如，我们可以从第一次调用开始<strong class="jm hj">记忆</strong>一个递归函数，将它设置为一个内部函数，这个内部函数将有一个<a class="ae le" href="https://thelbouffi.medium.com/easy-way-to-grasp-javascript-closures-7dc45fe998d9" rel="noopener"> <strong class="jm hj">闭包</strong> </a>。</p><figure class="kl km kn ko fd ij er es paragraph-image"><div class="er es lj"><img src="../Images/5bf148a753960ee89f8654cc94bef874.png" data-original-src="https://miro.medium.com/v2/resize:fit:1212/format:webp/1*tw4f3IBtq1iorm0uaS6UUg.png"/></div></figure></div><div class="ab cl lk ll gp lm" role="separator"><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp"/></div><div class="hb hc hd he hf"><p id="6af2" class="pw-post-body-paragraph jk jl hi jm b jn kf jp jq jr kg jt ju ix kh jw jx jb ki jz ka jf kj kc kd ke hb bi translated">我们可以在这里找到上面例子<a class="ae le" href="https://gist.github.com/thelbouffi/e2dfc4639cbdfc5a8ef5779651c21f8b" rel="noopener ugc nofollow" target="_blank">中使用的代码。</a></p></div></div>    
</body>
</html>