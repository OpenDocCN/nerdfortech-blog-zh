<html>
<head>
<title>Validate Income And Outgoing Parameters In NestJS</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">验证 NestJS 中的传入和传出参数</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/validate-income-and-outgoing-parameters-in-nestjs-50f5d1e9555c?source=collection_archive---------0-----------------------#2022-11-03">https://medium.com/nerd-for-tech/validate-income-and-outgoing-parameters-in-nestjs-50f5d1e9555c?source=collection_archive---------0-----------------------#2022-11-03</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><figure class="hh hi ez fb hj hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es hg"><img src="../Images/7b32fd839dc508e0ffd4416706eabc1f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8TZjlMNJE1YZx8vPqoNaYg.png"/></div></div></figure><div class=""/><h1 id="b99b" class="iq ir ht bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">简介:</h1><p id="60be" class="pw-post-body-paragraph jo jp ht jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">我们应该总是<strong class="jq hu">关心</strong>什么样的<strong class="jq hu">数据将</strong>传入我们的<strong class="jq hu"> REST API。</strong>有时我们需要<strong class="jq hu">移除额外的参数</strong>，有时我们需要<strong class="jq hu">检查类型</strong>。一些变量应该作为一个<strong class="jq hu">数字</strong>发送，其中一些是<strong class="jq hu">字符串</strong>或者可能是<strong class="jq hu">时间</strong>或<strong class="jq hu"> URL。</strong></p><p id="f351" class="pw-post-body-paragraph jo jp ht jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">问题是，即使我们对传入的数据进行了验证，大多数时候我们也会忘记验证我们的响应。但是:<br/> <strong class="jq hu">为什么要验证外向参数？由于一些消费者正在消费我们的响应，我们应该小心我们将要在一些现有代码中改变什么。很可能由于我们的改变，反应也会改变。有时，我们删除或添加一个新的参数，这可能会打破我们的消费者。</strong></p></div><div class="ab cl kr ks gp kt" role="separator"><span class="ku bw bk kv kw kx"/><span class="ku bw bk kv kw kx"/><span class="ku bw bk kv kw"/></div><div class="hb hc hd he hf"><h1 id="ab11" class="iq ir ht bd is it ky iv iw ix kz iz ja jb la jd je jf lb jh ji jj lc jl jm jn bi translated">准备 NestJS:</h1><p id="0430" class="pw-post-body-paragraph jo jp ht jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">在开始编写验证之前，我们应该在我们的项目中添加一个管道来捕获来自验证的错误。</p><p id="2dc8" class="pw-post-body-paragraph jo jp ht jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">为此，我们只需要对<code class="du ld le lf lg b">main.ts</code>的下面一行</p><pre class="lh li lj lk fd ll lg lm ln aw lo bi"><span id="fcb0" class="lp ir ht lg b fi lq lr l ls lt">const app = await NestFactory.create(AppModule);</span><span id="dd93" class="lp ir ht lg b fi lu lr l ls lt">app.useGlobalPipes(new ValidationPipe()); &lt;------ Add this line</span><span id="c2d1" class="lp ir ht lg b fi lu lr l ls lt">await app.listen(3000);</span></pre><h1 id="0436" class="iq ir ht bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">传入参数:</h1><p id="dda7" class="pw-post-body-paragraph jo jp ht jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">首先，让我们假设我们有一个表单，它负责从用户那里获取数据，并将他/她注册到我们的数据库中。<br/>我们需要的字段类似于下面的代码(您可以在本节末尾找到完整的代码) :</p><pre class="lh li lj lk fd ll lg lm ln aw lo bi"><span id="2c6f" class="lp ir ht lg b fi lq lr l ls lt">string name;<br/>string birthday;<br/>string imagePath;<br/>number age; // age can be optional</span></pre><p id="7384" class="pw-post-body-paragraph jo jp ht jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">对于传入的数据，我们必须为每个端点创建一个<strong class="jq hu"> DTO </strong>文件，例如，这里我们有一个<code class="du ld le lf lg b">register.dto.ts</code>文件。</p><figure class="lh li lj lk fd hk"><div class="bz dy l di"><div class="lv lw l"/></div></figure><p id="bc78" class="pw-post-body-paragraph jo jp ht jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">下一步是安装相关的包来验证 DTO</p><pre class="lh li lj lk fd ll lg lm ln aw lo bi"><span id="62ff" class="lp ir ht lg b fi lq lr l ls lt">npm install class-validator class-transformer</span></pre><p id="7387" class="pw-post-body-paragraph jo jp ht jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">Typescript 本身正在处理<strong class="jq hu">装饰器</strong>。因此，像下面的代码一样，我们很容易为每个参数添加验证:</p><figure class="lh li lj lk fd hk"><div class="bz dy l di"><div class="lv lw l"/></div></figure><p id="07cb" class="pw-post-body-paragraph jo jp ht jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated"><code class="du ld le lf lg b">class-validator</code>支持许多装饰者，对于他们中的每一个，它都有许多选项。所以，我推荐你看看他们的文档<a class="ae lx" href="https://github.com/typestack/class-validator" rel="noopener ugc nofollow" target="_blank">https://github.com/typestack/class-validator</a>。</p><h1 id="65eb" class="iq ir ht bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">传出参数:</h1><p id="ee14" class="pw-post-body-paragraph jo jp ht jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">传出的问题是，在作为响应发送之前，我们必须手动<strong class="jq hu">调用</strong>的<strong class="jq hu">验证函数</strong> <strong class="jq hu">。</strong></p><p id="71a1" class="pw-post-body-paragraph jo jp ht jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">因此，流程的第一步是<strong class="jq hu">通过<code class="du ld le lf lg b">class-transformer</code>包将<strong class="jq hu">对象</strong>转换为<strong class="jq hu">类</strong>。下面的代码可以将您的对象转换为类，并在有错误时抛出。</strong></p><figure class="lh li lj lk fd hk"><div class="bz dy l di"><div class="lv lw l"/></div></figure><p id="62ce" class="pw-post-body-paragraph jo jp ht jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">下一步是通过我们的验证类扩展我们当前的 dto，然后在将它作为响应传递之前轻松地调用验证函数。</p><figure class="lh li lj lk fd hk"><div class="bz dy l di"><div class="lv lw l"/></div></figure><p id="cfd8" class="pw-post-body-paragraph jo jp ht jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">在这里，这就是我们将如何使用我们在一个样本控制器</p><figure class="lh li lj lk fd hk"><div class="bz dy l di"><div class="lv lw l"/></div></figure><p id="f0be" class="pw-post-body-paragraph jo jp ht jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">我希望你会发现这篇文章很有用，<strong class="jq hu">如果你有任何问题就问</strong>我，如果你想成为一名职业✌️，就<strong class="jq hu">跟随</strong></p></div><div class="ab cl kr ks gp kt" role="separator"><span class="ku bw bk kv kw kx"/><span class="ku bw bk kv kw kx"/><span class="ku bw bk kv kw"/></div><div class="hb hc hd he hf"><h1 id="15c6" class="iq ir ht bd is it ky iv iw ix kz iz ja jb la jd je jf lb jh ji jj lc jl jm jn bi translated">培养</h1><p id="d52e" class="pw-post-body-paragraph jo jp ht jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">这里，我提供了一个视频来为 Nest 中的传入和传出参数创建一个验证函数。JS，我们也将在那里测试更多的类验证器的装饰器</p><figure class="lh li lj lk fd hk"><div class="bz dy l di"><div class="ly lw l"/></div></figure></div></div>    
</body>
</html>