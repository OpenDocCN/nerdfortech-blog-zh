<html>
<head>
<title>Let’s talk about debouncing and throttling and how they can enhance your react app’s performance.</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">让我们来谈谈去抖动和节流，以及它们如何增强 react 应用程序的性能。</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/lets-talk-about-debouncing-and-throttling-and-how-they-can-enhance-your-react-app-s-performance-10fba026d126?source=collection_archive---------7-----------------------#2021-06-20">https://medium.com/nerd-for-tech/lets-talk-about-debouncing-and-throttling-and-how-they-can-enhance-your-react-app-s-performance-10fba026d126?source=collection_archive---------7-----------------------#2021-06-20</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><blockquote class="if"><p id="d833" class="ig ih hi bd ii ij ik il im in io ip dx translated">去抖动和节流是用于性能优化的 JS 模式，用于控制用户在特定时间段内执行动作的速率。</p></blockquote><h1 id="46df" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">嗯...什么？？</h1><h2 id="c626" class="jo ir hi bd is jp jq jr iw js jt ju ja jv jw jx je jy jz ka ji kb kc kd jm ke bi translated">场景 1</h2><p id="81ff" class="pw-post-body-paragraph kf kg hi kh b ki kj kk kl km kn ko kp jv kq kr ks jy kt ku kv kb kw kx ky ip hb bi translated">想象一下，你正在一个网站上搜索某样东西。每次击键时，应用程序都会向服务器发出请求并获取结果。但是我们关心每次击键得到的结果吗？也许不是..我们只关心完成输入后的结果，或者可能在输入一些内容后暂停以获取相关结果。这就是去抖动和节流技术派上用场的时候。</p><figure class="kz la lb lc fd ld"><div class="bz dy l di"><div class="le lf l"/></div></figure><h2 id="a73b" class="jo ir hi bd is jp jq jr iw js jt ju ja jv jw jx je jy jz ka ji kb kc kd jm ke bi translated">场景 2</h2><p id="b7ff" class="pw-post-body-paragraph kf kg hi kh b ki kj kk kl km kn ko kp jv kq kr ks jy kt ku kv kb kw kx ky ip hb bi translated">想象一下另一个场景，你在玩一个多人射击游戏，你用鼠标控制射击。一旦你点击鼠标按钮，玩家射击，在幕后一个 API 被调用来发送更新的统计数据(例如，你剩下的子弹总数或你的健康百分比)到服务器。一旦你完成射击，发送更新的数据是有意义的，而不是每次点击鼠标都发送。最后，重要的是(对你这个玩家来说)你开枪后剩下的子弹数量。</p><h1 id="1c25" class="iq ir hi bd is it iu iv iw ix iy iz ja jb lg jd je jf lh jh ji jj li jl jm jn bi translated">好吧，现在怎么办？</h1><p id="ecfc" class="pw-post-body-paragraph kf kg hi kh b ki kj kk kl km kn ko kp jv kq kr ks jy kt ku kv kb kw kx ky ip hb bi translated">像这样的动作和一些更像例如滚动、调整大小等的动作是由用户决定执行的。有时，用户可能比实际需要更频繁地触发它。如果所有这些操作都涉及繁重的计算操作，它可能会降低应用程序的性能。这时去抖动和节流技术就派上了用场。</p><h1 id="20f3" class="iq ir hi bd is it iu iv iw ix iy iz ja jb lg jd je jf lh jh ji jj li jl jm jn bi translated">听起来很棒..但是，我们如何使用它呢？</h1><p id="aff8" class="pw-post-body-paragraph kf kg hi kh b ki kj kk kl km kn ko kp jv kq kr ks jy kt ku kv kb kw kx ky ip hb bi translated">在开始实现之前，让我们先了解一下什么是去抖动，什么是节流，以及它们各自的用法。</p><h2 id="7fd5" class="jo ir hi bd is jp jq jr iw js jt ju ja jv jw jx je jy jz ka ji kb kc kd jm ke bi translated">去抖:</h2><p id="3812" class="pw-post-body-paragraph kf kg hi kh b ki kj kk kl km kn ko kp jv kq kr ks jy kt ku kv kb kw kx ky ip hb bi translated">在去抖中，我们只在用户完成触发后的特定时间触发一次用户动作。换句话说，忽略所有之前的用户操作，只考虑用户完成触发后的最后一个操作。</p><p id="1bb5" class="pw-post-body-paragraph kf kg hi kh b ki lj kk kl km lk ko kp jv ll kr ks jy lm ku kv kb ln kx ky ip hb bi translated"><strong class="kh hj">示例 1: </strong>如果你连续点击一个按钮，比如说 10 次，你的按钮动作将只被调用一次，在你第 10 次点击按钮后过了一段时间，而不是被调用 10 次。</p><p id="de2d" class="pw-post-body-paragraph kf kg hi kh b ki lj kk kl km lk ko kp jv ll kr ks jy lm ku kv kb ln kx ky ip hb bi translated"><strong class="kh hj">例子 2: </strong>当你去一家餐馆时，服务员不是冲到厨房告诉厨师你点的菜，而是等着记下你点的菜，直到你点完，让他把菜加进去。服务员去厨房把你点的菜递给厨师。</p><h2 id="fe52" class="jo ir hi bd is jp jq jr iw js jt ju ja jv jw jx je jy jz ka ji kb kc kd jm ke bi translated">节流:</h2><p id="d815" class="pw-post-body-paragraph kf kg hi kh b ki kj kk kl km kn ko kp jv kq kr ks jy kt ku kv kb kw kx ky ip hb bi translated">在节流中，我们在特定的时间间隔过后定期触发用户事件。</p><p id="d575" class="pw-post-body-paragraph kf kg hi kh b ki lj kk kl km lk ko kp jv ll kr ks jy lm ku kv kb ln kx ky ip hb bi translated">例如:我们在 100 毫秒的间隔内连续点击一个按钮 10 次。如果我们每 200 毫秒限制一次这个动作，按钮动作将被调用 5 次而不是 10 次。</p><h1 id="9454" class="iq ir hi bd is it iu iv iw ix iy iz ja jb lg jd je jf lh jh ji jj li jl jm jn bi translated">凉爽的..但是现在我们如何实现它们呢？</h1><p id="5938" class="pw-post-body-paragraph kf kg hi kh b ki kj kk kl km kn ko kp jv kq kr ks jy kt ku kv kb kw kx ky ip hb bi translated">我们将通过 follg 实现去抖动和节流。方式:</p><ul class=""><li id="c4c9" class="lo lp hi kh b ki lj km lk jv lq jy lr kb ls ip lt lu lv lw bi translated">构建我们的<code class="du lx ly lz ma b">custom implementation</code>去抖和节流功能。</li><li id="9c82" class="lo lp hi kh b ki mb km mc jv md jy me kb mf ip lt lu lv lw bi translated">使用定制钩子<code class="du lx ly lz ma b">useDebounce()</code>和<code class="du lx ly lz ma b">useThrottle().</code>转换上述定制实现</li></ul><h1 id="c1b7" class="iq ir hi bd is it iu iv iw ix iy iz ja jb lg jd je jf lh jh ji jj li jl jm jn bi translated">那么我们在建造什么？</h1><figure class="kz la lb lc fd ld er es paragraph-image"><div class="er es mg"><img src="../Images/08e74dc47ef27d7d3cfec03dc818170a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1068/1*b8P-PyViG08b5xOo-Z7Wqw.gif"/></div><figcaption class="mj mk et er es ml mm bd b be z dx translated">口袋妖怪名称自动完成文本框</figcaption></figure><p id="e409" class="pw-post-body-paragraph kf kg hi kh b ki lj kk kl km lk ko kp jv ll kr ks jy lm ku kv kb ln kx ky ip hb bi translated">这个应用程序非常简单。我们希望创建一个自动完成框，当我们在框中键入神奇宝贝的名称时，它会建议/自动完成它们的名称。</p><h1 id="fd94" class="iq ir hi bd is it iu iv iw ix iy iz ja jb lg jd je jf lh jh ji jj li jl jm jn bi translated">kickstarter 代码</h1><figure class="kz la lb lc fd ld"><div class="bz dy l di"><div class="mn lf l"/></div></figure><p id="7a2b" class="pw-post-body-paragraph kf kg hi kh b ki lj kk kl km lk ko kp jv ll kr ks jy lm ku kv kb ln kx ky ip hb bi translated">你可以从<a class="ae mo" href="https://gist.github.com/mistryakshar54/dc1d2d615fd4738cf46f01e1b2d171e4" rel="noopener ugc nofollow" target="_blank">这个链接</a>获得<code class="du lx ly lz ma b">./mockData.json</code>的模拟数据，从<a class="ae mo" href="https://gist.github.com/mistryakshar54/d849194747d88062683f594127cc525a" rel="noopener ugc nofollow" target="_blank">这个链接</a>获得所需的 css。</p><p id="aeff" class="pw-post-body-paragraph kf kg hi kh b ki lj kk kl km lk ko kp jv ll kr ks jy lm ku kv kb ln kx ky ip hb bi translated">现在我们可以走了..该应用程序应该如下所示:</p><figure class="kz la lb lc fd ld er es paragraph-image"><div class="er es mg"><img src="../Images/640b5ee2ffc889fef6466ccae0f61020.png" data-original-src="https://miro.medium.com/v2/resize:fit:1068/1*IcIrDrJCl2KO0WBeGROTkw.gif"/></div></figure><figure class="kz la lb lc fd ld"><div class="bz dy l di"><div class="mp lf l"/></div></figure><p id="e461" class="pw-post-body-paragraph kf kg hi kh b ki lj kk kl km lk ko kp jv ll kr ks jy lm ku kv kb ln kx ky ip hb bi translated">注意控制台中的<code class="du lx ly lz ma b"><strong class="kh hj">filter pokemon</strong></code>。<code class="du lx ly lz ma b">filterPokemon()</code>通过从搜索框的文本中过滤口袋妖怪的名字来激活我们的自动完成框。我们每击一次键，就会调用<code class="du lx ly lz ma b">filterPokemons()</code>。想象一下，如果这个方法做了大量的计算，它将降低我们的应用程序的性能！！！</p><p id="bf7f" class="pw-post-body-paragraph kf kg hi kh b ki lj kk kl km lk ko kp jv ll kr ks jy lm ku kv kb ln kx ky ip hb bi translated">这正是去抖动和节流等技术大放异彩的时候！！</p><h2 id="d977" class="jo ir hi bd is jp jq jr iw js jt ju ja jv jw jx je jy jz ka ji kb kc kd jm ke bi translated">实现去抖:</h2><pre class="kz la lb lc fd mq ma mr ms aw mt bi"><span id="b574" class="jo ir hi ma b fi mu mv l mw mx">const customDebounce = (fn, timer = 1000) =&gt; {</span><span id="5e8f" class="jo ir hi ma b fi my mv l mw mx">  let timeOutValue = null;</span><span id="fcb0" class="jo ir hi ma b fi my mv l mw mx">  return (...args) =&gt; {</span><span id="2558" class="jo ir hi ma b fi my mv l mw mx">    if (timeOutValue) {<br/>      clearTimeout(timeOutValue);<br/>    }</span><span id="9601" class="jo ir hi ma b fi my mv l mw mx">    timeOutValue = setTimeout(() =&gt; {<br/>      fn(...args);<br/>      clearTimeout(timeOutValue);<br/>    }, timer);</span><span id="01bb" class="jo ir hi ma b fi my mv l mw mx">  };</span><span id="fe12" class="jo ir hi ma b fi my mv l mw mx">};</span></pre><p id="ecb1" class="pw-post-body-paragraph kf kg hi kh b ki lj kk kl km lk ko kp jv ll kr ks jy lm ku kv kb ln kx ky ip hb bi translated">这里发生的是，我们的<code class="du lx ly lz ma b">customDebounce()</code>接受两个参数，要调用的回调函数(在我们的例子中是<code class="du lx ly lz ma b">filterPokemon()</code>)和一个定时器值(用户停止执行动作后要等待的毫秒数)。</p><p id="18da" class="pw-post-body-paragraph kf kg hi kh b ki lj kk kl km lk ko kp jv ll kr ks jy lm ku kv kb ln kx ky ip hb bi translated"><code class="du lx ly lz ma b">customDebounce()</code>返回一个匿名函数。匿名函数负责在<code class="du lx ly lz ma b">setTimeout</code>的帮助下跟踪用户是否还在打字。怎么会？</p><p id="5c1f" class="pw-post-body-paragraph kf kg hi kh b ki lj kk kl km lk ko kp jv ll kr ks jy lm ku kv kb ln kx ky ip hb bi translated">如果用户输入了什么，我们用一个新的 setTimeout 调用来重置计时器。一旦用户停止输入并且<code class="du lx ly lz ma b">setTimeout</code>调用被触发，我们的回调函数就会被执行。</p><p id="06de" class="pw-post-body-paragraph kf kg hi kh b ki lj kk kl km lk ko kp jv ll kr ks jy lm ku kv kb ln kx ky ip hb bi translated">因此，在这个<code class="du lx ly lz ma b">customDebounce()</code>的帮助下，我们的函数(<code class="du lx ly lz ma b">filterPokemon()</code>)将只在用户停止输入时被调用，而不是在每次击键时被调用。</p><h1 id="b7d3" class="iq ir hi bd is it iu iv iw ix iy iz ja jb lg jd je jf lh jh ji jj li jl jm jn bi translated">在我们的应用中安装我们的<code class="du lx ly lz ma b">customDebounce()</code>:</h1><pre class="kz la lb lc fd mq ma mr ms aw mt bi"><span id="3775" class="jo ir hi ma b fi mu mv l mw mx">//imports here...</span><span id="91d5" class="jo ir hi ma b fi my mv l mw mx"><strong class="ma hj">const customDebounce = (fn, timer = 1000) =&gt; {<br/>  let timeOutValue = null;<br/>  return (...args) =&gt; {<br/>    if (timeOutValue) {<br/>      clearTimeout(timeOutValue);<br/>    }<br/>    timeOutValue = setTimeout(() =&gt; {<br/>      fn(...args);<br/>      clearTimeout(timeOutValue);<br/>    }, timer);<br/>  };<br/>};</strong></span><span id="de54" class="jo ir hi ma b fi my mv l mw mx">export default function App() {<br/>  // useStates here</span><span id="7eb2" class="jo ir hi ma b fi my mv l mw mx">  // filterPokemon() logic here...</span><span id="076e" class="jo ir hi ma b fi my mv l mw mx"><strong class="ma hj">const memoizedDebounce = useCallback(customDebounce(filterPokemons), []);</strong></span><span id="d8e8" class="jo ir hi ma b fi my mv l mw mx">const handleChange = (e) =&gt; {<br/>    // handleChange logic<br/><strong class="ma hj">    memoizedDebounce(newVal);</strong><br/>  };</span><span id="1a07" class="jo ir hi ma b fi my mv l mw mx">return (<br/>    //component logic here...<br/>  );<br/>}</span></pre><p id="fe7c" class="pw-post-body-paragraph kf kg hi kh b ki lj kk kl km lk ko kp jv ll kr ks jy lm ku kv kb ln kx ky ip hb bi translated">我们在声明组件之前添加了<code class="du lx ly lz ma b"><strong class="kh hj">customDebounce()</strong></code> <strong class="kh hj"> </strong>。我们使用<code class="du lx ly lz ma b">useCallback</code>钩子来记忆我们的<code class="du lx ly lz ma b"><strong class="kh hj">customDebounce()</strong></code> <strong class="kh hj"> </strong>，并向它传递我们的回调函数(<code class="du lx ly lz ma b">filterPokemons()</code>)。</p><h2 id="da40" class="jo ir hi bd is jp jq jr iw js jt ju ja jv jw jx je jy jz ka ji kb kc kd jm ke bi translated">但是为什么我们需要用<strong class="ak"> useCallback </strong>来记忆它呢？</h2><p id="eb08" class="pw-post-body-paragraph kf kg hi kh b ki kj kk kl km kn ko kp jv kq kr ks jy kt ku kv kb kw kx ky ip hb bi translated">答案很简单。</p><pre class="kz la lb lc fd mq ma mr ms aw mt bi"><span id="711b" class="jo ir hi ma b fi mu mv l mw mx">&lt;input value={autocompleteInput} onChange={handleChange} /&gt;</span></pre><p id="4359" class="pw-post-body-paragraph kf kg hi kh b ki lj kk kl km lk ko kp jv ll kr ks jy lm ku kv kb ln kx ky ip hb bi translated">每当输入框的值改变时，<code class="du lx ly lz ma b">onChange() </code>重新创建<code class="du lx ly lz ma b">handleChange()</code>的新副本。因此，去抖方法总是被重新创建，因此我们无法判断<code class="du lx ly lz ma b">setTimeout</code>是否被设置。</p><p id="fb94" class="pw-post-body-paragraph kf kg hi kh b ki lj kk kl km lk ko kp jv ll kr ks jy lm ku kv kb ln kx ky ip hb bi translated">整个代码看起来应该像这样:</p><figure class="kz la lb lc fd ld"><div class="bz dy l di"><div class="mn lf l"/></div></figure><figure class="kz la lb lc fd ld er es paragraph-image"><div class="er es mg"><img src="../Images/7017488da8d7d7a983d4a4509861459e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1068/1*yXQ2j3suStKP0El25Tjc7w.gif"/></div><figcaption class="mj mk et er es ml mm bd b be z dx translated">带去抖功能的应用</figcaption></figure><p id="29b1" class="pw-post-body-paragraph kf kg hi kh b ki lj kk kl km lk ko kp jv ll kr ks jy lm ku kv kb ln kx ky ip hb bi translated"><strong class="kh hj">请注意，这一次 filterPokemon 控制台仅在我们停止/暂停输入后才被调用。这真的很棒，因为我们现在可以更少地调用</strong> <code class="du lx ly lz ma b"><strong class="kh hj">filterPokemon()</strong></code> <strong class="kh hj">并节省计算时间！！</strong></p><p id="7381" class="pw-post-body-paragraph kf kg hi kh b ki lj kk kl km lk ko kp jv ll kr ks jy lm ku kv kb ln kx ky ip hb bi translated">让我们更进一步..让我们创建一个钩子吧！！</p><h1 id="6a5f" class="iq ir hi bd is it iu iv iw ix iy iz ja jb lg jd je jf lh jh ji jj li jl jm jn bi translated">useDebounce 钩子[完全可选]！！</h1><p id="7daa" class="pw-post-body-paragraph kf kg hi kh b ki kj kk kl km kn ko kp jv kq kr ks jy kt ku kv kb kw kx ky ip hb bi translated">我们将创建一个名为<code class="du lx ly lz ma b">useDebounce.js</code>的独立钩子文件</p><figure class="kz la lb lc fd ld"><div class="bz dy l di"><div class="mn lf l"/></div></figure><p id="9bd1" class="pw-post-body-paragraph kf kg hi kh b ki lj kk kl km lk ko kp jv ll kr ks jy lm ku kv kb ln kx ky ip hb bi translated">实现相当简单。我们把<code class="du lx ly lz ma b">customDebounce()</code>变成一个钩子。我们的<code class="du lx ly lz ma b">timeout</code>变量将使用<code class="du lx ly lz ma b">useState()</code>转换成状态变量，其余一切都是一样的。</p><p id="ed9d" class="pw-post-body-paragraph kf kg hi kh b ki lj kk kl km lk ko kp jv ll kr ks jy lm ku kv kb ln kx ky ip hb bi translated">我们现在如何使用它？</p><pre class="kz la lb lc fd mq ma mr ms aw mt bi"><span id="d74b" class="jo ir hi ma b fi mu mv l mw mx">We replace :<br/><strong class="ma hj">const memoizedDebounce = useCallback(customDebounce(filterPokemons), []);</strong></span><span id="23ad" class="jo ir hi ma b fi my mv l mw mx">with <br/><strong class="ma hj">const debouncedFn = useDebounce(filterPokemons);<br/>const memoizedDebounce = useCallback(debouncedFn, [debouncedFn]);</strong></span></pre><p id="8abf" class="pw-post-body-paragraph kf kg hi kh b ki lj kk kl km lk ko kp jv ll kr ks jy lm ku kv kb ln kx ky ip hb bi translated">我们现在可以去🥳 🥳了</p><h2 id="3dd2" class="jo ir hi bd is jp jq jr iw js jt ju ja jv jw jx je jy jz ka ji kb kc kd jm ke bi translated">实施节流:</h2><p id="e624" class="pw-post-body-paragraph kf kg hi kh b ki kj kk kl km kn ko kp jv kq kr ks jy kt ku kv kb kw kx ky ip hb bi translated">节流的实现就像用 catch 去抖一样..我们不等待暂停..相反，我们等到超时结束，调用回调函数，我们再次设置超时。这让用户可以在一定的时间间隔内调用回调，并看到一些结果，而不是在最后(在用户完成输入之后)得到输出</p><pre class="kz la lb lc fd mq ma mr ms aw mt bi"><span id="7926" class="jo ir hi ma b fi mu mv l mw mx">const customThrottle = (fn, timer = 1000) =&gt; {<br/>let timeOutValue = null;<br/>return (...args) =&gt; {<br/>if (timeOutValue) { return; }<br/> timeOutValue = setTimeout(() =&gt; {<br/>      fn(...args);<br/>      clearTimeout(timeOutValue);<br/>    }, timer);<br/> };<br/>};</span></pre><p id="b795" class="pw-post-body-paragraph kf kg hi kh b ki lj kk kl km lk ko kp jv ll kr ks jy lm ku kv kb ln kx ky ip hb bi translated">这里发生了什么事？</p><p id="b3eb" class="pw-post-body-paragraph kf kg hi kh b ki lj kk kl km lk ko kp jv ll kr ks jy lm ku kv kb ln kx ky ip hb bi translated">当用户输入时，<code class="du lx ly lz ma b">customThrottle</code>被触发调用，设置<br/> <code class="du lx ly lz ma b">timeOutValue</code>。<code class="du lx ly lz ma b">setTimeout</code>将为<code class="du lx ly lz ma b">timeOutValue</code>设置一个 id。</p><p id="3b2b" class="pw-post-body-paragraph kf kg hi kh b ki lj kk kl km lk ko kp jv ll kr ks jy lm ku kv kb ln kx ky ip hb bi translated">第二次触发<code class="du lx ly lz ma b">customThrottle</code>时，<code class="du lx ly lz ma b">timeOutValue</code>将不为空，因此将退出函数执行(返回语句)。</p><p id="b849" class="pw-post-body-paragraph kf kg hi kh b ki lj kk kl km lk ko kp jv ll kr ks jy lm ku kv kb ln kx ky ip hb bi translated">一旦<code class="du lx ly lz ma b">setTimeout</code>被调用(在特定的毫秒之后)，回调函数(<code class="du lx ly lz ma b">filterPokemon</code>)将被执行，并且<code class="du lx ly lz ma b">timeOutValue</code>被设置为空。</p><p id="20ce" class="pw-post-body-paragraph kf kg hi kh b ki lj kk kl km lk ko kp jv ll kr ks jy lm ku kv kb ln kx ky ip hb bi translated">因此，当<code class="du lx ly lz ma b">customThrottle</code>被触发时，<code class="du lx ly lz ma b">timeOutValue</code>将为空，因此<code class="du lx ly lz ma b">setTimeout</code>将被执行。</p><p id="e0c4" class="pw-post-body-paragraph kf kg hi kh b ki lj kk kl km lk ko kp jv ll kr ks jy lm ku kv kb ln kx ky ip hb bi translated">这就是<code class="du lx ly lz ma b">debounce</code>和<code class="du lx ly lz ma b">throttle</code>的关键区别</p><p id="c242" class="pw-post-body-paragraph kf kg hi kh b ki lj kk kl km lk ko kp jv ll kr ks jy lm ku kv kb ln kx ky ip hb bi translated">让我们直接把它实现为一个钩子:</p><figure class="kz la lb lc fd ld"><div class="bz dy l di"><div class="mn lf l"/></div></figure><p id="2060" class="pw-post-body-paragraph kf kg hi kh b ki lj kk kl km lk ko kp jv ll kr ks jy lm ku kv kb ln kx ky ip hb bi translated">我们现在如何使用它？</p><pre class="kz la lb lc fd mq ma mr ms aw mt bi"><span id="920d" class="jo ir hi ma b fi mu mv l mw mx">We replace :<br/><strong class="ma hj">const debouncedFn = useDebounce(filterPokemons);<br/></strong>with <br/><strong class="ma hj">const debouncedFn = useThrottle(filterPokemons);<br/></strong></span></pre><figure class="kz la lb lc fd ld er es paragraph-image"><div class="er es mg"><img src="../Images/9e5c34be9aa14e34413a08615ada62e0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1068/1*gvWyWimFem-kNGjzatRRgw.gif"/></div></figure><p id="59ed" class="pw-post-body-paragraph kf kg hi kh b ki lj kk kl km lk ko kp jv ll kr ks jy lm ku kv kb ln kx ky ip hb bi translated">请注意，节流不会等待用户停止绑定，也不会在每次击键时触发。相反，它以特定的时间间隔调用<code class="du lx ly lz ma b">filterPokemon</code>(我们将默认值设置为 1000 毫秒)。</p></div><div class="ab cl mz na gp nb" role="separator"><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne"/></div><div class="hb hc hd he hf"><h1 id="67a7" class="iq ir hi bd is it ng iv iw ix nh iz ja jb ni jd je jf nj jh ji jj nk jl jm jn bi translated">如果我想两个都用呢？我能同时使用两个吗？</h1><p id="6324" class="pw-post-body-paragraph kf kg hi kh b ki kj kk kl km kn ko kp jv kq kr ks jy kt ku kv kb kw kx ky ip hb bi translated">是的，去抖动和节流的结合是可能的。</p><p id="b8c6" class="pw-post-body-paragraph kf kg hi kh b ki lj kk kl km lk ko kp jv ll kr ks jy lm ku kv kb ln kx ky ip hb bi translated"><strong class="kh hj">为什么？:</strong>只有在用户键入后，去抖动才会起作用，而节流只会在特定的时间间隔起作用。可能有这样一种情况，用户需要在键入一些键击以获得相关数据时看到建议，并且可能希望在键入后获得确切的结果。然而这种情况不太可能发生。</p><p id="2cc6" class="pw-post-body-paragraph kf kg hi kh b ki lj kk kl km lk ko kp jv ll kr ks jy lm ku kv kb ln kx ky ip hb bi translated"><strong class="kh hj">如何？:</strong>我们可以将节流和去抖结合起来，在特定条件下工作。例如，执行节流，直到用户键入 5-6 个字符，然后依靠去抖动获得准确的结果。</p><figure class="kz la lb lc fd ld"><div class="bz dy l di"><div class="mn lf l"/></div></figure><p id="d6cd" class="pw-post-body-paragraph kf kg hi kh b ki lj kk kl km lk ko kp jv ll kr ks jy lm ku kv kb ln kx ky ip hb bi translated">注意:</p><pre class="kz la lb lc fd mq ma mr ms aw mt bi"><span id="217b" class="jo ir hi ma b fi mu mv l mw mx"><strong class="ma hj">newVal.length &gt; 3 ? memoizedDebounce(newVal) : memoizedThrottle(newVal);</strong></span></pre><p id="6104" class="pw-post-body-paragraph kf kg hi kh b ki lj kk kl km lk ko kp jv ll kr ks jy lm ku kv kb ln kx ky ip hb bi translated">我们一直节流到输入长度为 3，一旦输入长度大于 3，我们就切换到去抖。</p><h2 id="06f9" class="jo ir hi bd is jp jq jr iw js jt ju ja jv jw jx je jy jz ka ji kb kc kd jm ke bi translated"><a class="ae mo" href="https://codesandbox.io/s/peaceful-burnell-rw0g7?file=/src/App.js" rel="noopener ugc nofollow" target="_blank">链接到 codesandbox </a></h2></div><div class="ab cl mz na gp nb" role="separator"><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne"/></div><div class="hb hc hd he hf"><h1 id="702b" class="iq ir hi bd is it ng iv iw ix nh iz ja jb ni jd je jf nj jh ji jj nk jl jm jn bi translated">结论:</h1><p id="23a1" class="pw-post-body-paragraph kf kg hi kh b ki kj kk kl km kn ko kp jv kq kr ks jy kt ku kv kb kw kx ky ip hb bi translated">去抖动和节流是提高应用程序性能的好方法。在对钩子、闭包和超时了解不多的情况下，我们可以见证如何节省大量计算时间并改善用户体验。</p></div></div>    
</body>
</html>