<html>
<head>
<title>Technical Failure #1: React hooks dependencies</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">技术失败#1: React 挂钩依赖性</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/technical-failure-1-react-hooks-dependencies-f7d8e24effcf?source=collection_archive---------31-----------------------#2021-05-29">https://medium.com/nerd-for-tech/technical-failure-1-react-hooks-dependencies-f7d8e24effcf?source=collection_archive---------31-----------------------#2021-05-29</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="7ef5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><a class="ae jd" href="https://reactjs.org/blog/2019/02/06/react-v16.8.0.html" rel="noopener ugc nofollow" target="_blank"> React 在 16.8 </a>引入了钩子，一切都变了。钩子提供了一个机会来制造具有状态和生命周期的功能组件。新方法需要重新定义如何在 React 中编写代码的心智模型。没有完全转换到新的方法会导致问题。</p></div><div class="ab cl je jf gp jg" role="separator"><span class="jh bw bk ji jj jk"/><span class="jh bw bk ji jj jk"/><span class="jh bw bk ji jj"/></div><div class="hb hc hd he hf"><p id="e114" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">技术领导者的工作充满了决策。你需要在一开始就做出决定，即使在项目的最后阶段，它们也会对项目产生影响。这一系列文章是写给那些想从我的错误中吸取教训的人的:</p><ol class=""><li id="e5c0" class="jl jm hi ih b ii ij im in iq jn iu jo iy jp jc jq jr js jt bi translated">React 挂钩依赖关系</li></ol></div><div class="ab cl je jf gp jg" role="separator"><span class="jh bw bk ji jj jk"/><span class="jh bw bk ji jj jk"/><span class="jh bw bk ji jj"/></div><div class="hb hc hd he hf"><h1 id="8f54" class="ju jv hi bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">情况</h1><p id="6a57" class="pw-post-body-paragraph if ig hi ih b ii ks ik il im kt io ip iq ku is it iu kv iw ix iy kw ja jb jc hb bi translated">假设我们有一个状态经常变化的根组件和一个连接到后端的组件。</p><figure class="kx ky kz la fd lb"><div class="bz dy l di"><div class="lc ld l"/></div></figure><p id="24ab" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这段代码每 3 秒更新一次组件状态。每次计数器增加时，组件被重新渲染。这导致每次计数器改变时调用<code class="du le lf lg lh b">getArticles</code>方法。</p><h1 id="b85e" class="ju jv hi bd jw jx li jz ka kb lj kd ke kf lk kh ki kj ll kl km kn lm kp kq kr bi translated">为什么会这样？</h1><p id="1564" class="pw-post-body-paragraph if ig hi ih b ii ks ik il im kt io ip iq ku is it iu kv iw ix iy kw ja jb jc hb bi translated">React 在比较依赖关系时使用引用相等来决定是否应该运行<code class="du le lf lg lh b">useEffect</code>回调。在这种情况下，以下赋值:</p><pre class="kx ky kz la fd ln lh lo lp aw lq bi"><span id="f264" class="lr jv hi lh b fi ls lt l lu lv">const db = DBConnection();</span></pre><p id="5546" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">每次渲染<code class="du le lf lg lh b">db</code>都会改变它的引用，即使这个变量的值和之前一样。</p><p id="db53" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这就是为什么每次组件被渲染时<code class="du le lf lg lh b">useEffect</code>回调都会运行:</p><pre class="kx ky kz la fd ln lh lo lp aw lq bi"><span id="9eef" class="lr jv hi lh b fi ls lt l lu lv">useEffect(() =&gt; {<br/>  console.count("get articles");<br/>  db.getArticles().then(setArticles);<br/>}, [db]);</span></pre><h1 id="007d" class="ju jv hi bd jw jx li jz ka kb lj kd ke kf lk kh ki kj ll kl km kn lm kp kq kr bi translated">糟糕的决定</h1><p id="1308" class="pw-post-body-paragraph if ig hi ih b ii ks ik il im kt io ip iq ku is it iu kv iw ix iy kw ja jb jc hb bi translated">我的决定似乎是最容易也是最简单的。当我将<code class="du le lf lg lh b">db</code>与<code class="du le lf lg lh b">useEffect</code>或任何挂钩一起使用时，我只是省略了这种依赖性。代码看起来是这样的，开始时一切都很好:</p><pre class="kx ky kz la fd ln lh lo lp aw lq bi"><span id="9610" class="lr jv hi lh b fi ls lt l lu lv">const db = DBConnection();</span><span id="83ed" class="lr jv hi lh b fi lw lt l lu lv">useEffect(() =&gt; {<br/>  console.count("get articles");<br/>  db.getArticles().then(setArticles);<br/>}, []);</span></pre><h1 id="f5cb" class="ju jv hi bd jw jx li jz ka kb lj kd ke kf lk kh ki kj ll kl km kn lm kp kq kr bi translated">最糟糕的决定</h1><p id="c56d" class="pw-post-body-paragraph if ig hi ih b ii ks ik il im kt io ip iq ku is it iu kv iw ix iy kw ja jb jc hb bi translated">有一件事仍然困扰着我。我从 eslint 得到一个警告，即<code class="du le lf lg lh b">db</code>依赖项应该包含在依赖数组中。</p><figure class="kx ky kz la fd lb er es paragraph-image"><div role="button" tabindex="0" class="ly lz di ma bf mb"><div class="er es lx"><img src="../Images/cd1433d36e486dbc490f5fa8a5be6c25.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JHzmWoNs_tXQXEyNdXS88A.png"/></div></div><figcaption class="me mf et er es mg mh bd b be z dx translated">Eslint 规则警告</figcaption></figure><p id="200f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在糟糕的决定之后，还有一个更糟糕的决定。我用<code class="du le lf lg lh b">eslint-disable-next-line</code>抑制了所有这些。这导致我在每个文件中多次使用它，代码失去了很多可读性。</p><h1 id="0d59" class="ju jv hi bd jw jx li jz ka kb lj kd ke kf lk kh ki kj ll kl km kn lm kp kq kr bi translated">正确的方式</h1><p id="7a77" class="pw-post-body-paragraph if ig hi ih b ii ks ik il im kt io ip iq ku is it iu kv iw ix iy kw ja jb jc hb bi translated">我们需要做的一切就是记忆<code class="du le lf lg lh b">db</code>并将其添加到依赖数组中。</p><p id="471c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为什么这是最好的方法？</p><ul class=""><li id="1556" class="jl jm hi ih b ii ij im in iq jn iu jo iy jp jc mi jr js jt bi translated"><code class="du le lf lg lh b">DBConnection</code>可以进行多个数据库实例的连接。我们希望保持尽可能少的联系。这就是我们创建数据库连接的一个实例的原因。</li><li id="c31e" class="jl jm hi ih b ii mj im mk iq ml iu mm iy mn jc mi jr js jt bi translated">传递<code class="du le lf lg lh b">db</code>实例确保当实例改变时，我们再次获取文章。</li></ul><pre class="kx ky kz la fd ln lh lo lp aw lq bi"><span id="9beb" class="lr jv hi lh b fi ls lt l lu lv">const db = useMemo(() =&gt; DBConnection(), []);</span><span id="27f3" class="lr jv hi lh b fi lw lt l lu lv">useEffect(() =&gt; {<br/>  console.count("get articles");<br/>  db.getArticles().then(setArticles);<br/>}, [db]);</span></pre><h1 id="8c82" class="ju jv hi bd jw jx li jz ka kb lj kd ke kf lk kh ki kj ll kl km kn lm kp kq kr bi translated">结论</h1><p id="7c42" class="pw-post-body-paragraph if ig hi ih b ii ks ik il im kt io ip iq ku is it iu kv iw ix iy kw ja jb jc hb bi translated">你可以在<a class="ae jd" href="https://codesandbox.io/s/blue-shadow-72mhw?file=/src/App.js:556-690" rel="noopener ugc nofollow" target="_blank"> codesandbox </a>上查看正确的代码。犯错是我们学习的方式。发展是根据结果做出决策并得出结论。</p><p id="a512" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果你有任何问题，请在下面的评论中告诉我。<a class="ae jd" href="https://twitter.com/Perfect7M" rel="noopener ugc nofollow" target="_blank">你可以在推特上找到我。</a></p></div></div>    
</body>
</html>