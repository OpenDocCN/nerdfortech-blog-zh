<html>
<head>
<title>Let's Implement a Binary Search Tree</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">让我们实现一个二叉查找树</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/lets-implement-binary-search-tree-6a8f7f34f67f?source=collection_archive---------2-----------------------#2020-09-05">https://medium.com/nerd-for-tech/lets-implement-binary-search-tree-6a8f7f34f67f?source=collection_archive---------2-----------------------#2020-09-05</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="5202" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">简介:</h2></div><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ix"><img src="../Images/6174a3ba88e1f7387b7e4c5bbdee6735.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qu5vbQ_v6htt9Bj2SUC2Yg.png"/></div></div></figure><p id="9736" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">二叉查找树是二叉树，其中左子树的每个节点的值小于或等于父节点，而右子树的每个节点的值大于或等于父节点。同时，每个子树也是一个二叉查找树。</p><p id="7e4f" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">那么，我们为什么需要二叉查找树呢？？</p><p id="78af" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">因为从二叉树中搜索、插入或删除任何元素在任何情况下都需要 O(n)时间，即使该树是平衡的。然而，在最佳情况下的二叉查找树的情况下，它需要 O(深度),这是 O(log N)时间复杂度。这是因为我们可以将键值与根节点的值进行比较，如果它小于根节点，它将在左子树中搜索，否则在右子树中搜索。</p><h2 id="411c" class="kf kg hi bd kh ki kj kk kl km kn ko kp js kq kr ks jw kt ku kv ka kw kx ky kz bi translated"><strong class="ak">实施二叉查找树:</strong></h2><p id="25b4" class="pw-post-body-paragraph jj jk hi jl b jm la ij jo jp lb im jr js lc ju jv jw ld jy jz ka le kc kd ke hb bi translated">1) <strong class="jl hj">用给定的元素建造一个二叉查找树</strong>:</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es lf"><img src="../Images/527f4461f40d1a5062c675fb3562f116.png" data-original-src="https://miro.medium.com/v2/resize:fit:1298/format:webp/1*w83gQ8UE8z9BCJMOAXrRrA.jpeg"/></div><figcaption class="lg lh et er es li lj bd b be z dx translated">构建 bst 的代码</figcaption></figure><p id="43cf" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">2) <strong class="jl hj">在二叉查找树中查找键值</strong>:</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es lk"><img src="../Images/89e08f40a46c8aae71029d40e056bbc1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1284/format:webp/1*BsFrJQ2T3x-OkBq_DxM8vA.jpeg"/></div><figcaption class="lg lh et er es li lj bd b be z dx translated">在 bst 中搜索元素的代码</figcaption></figure><p id="fcc4" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">3) <strong class="jl hj">在二叉查找树</strong>中删除一个元素:首先使用上面的代码搜索要删除的元素，然后根据节点的类型将其删除。</p><p id="c483" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated"><strong class="jl hj">情况 1 </strong>:如果包含键值的节点是一个<strong class="jl hj">叶节点</strong>，我们可以简单地删除它并向父节点返回 null</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es ll"><img src="../Images/11a80218625988c3bad115b06943ab32.png" data-original-src="https://miro.medium.com/v2/resize:fit:1342/format:webp/1*eoWY8bdjF-mN7QpFCjr-rg.jpeg"/></div><figcaption class="lg lh et er es li lj bd b be z dx translated">叶节点删除</figcaption></figure><p id="cbfc" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated"><strong class="jl hj">情况 2 </strong>:如果包含键值的节点有<strong class="jl hj">一个子节点</strong>，则为该子节点分配一个指针，并将其返回给父节点</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es lm"><img src="../Images/2599e809da631916c74486135dfd30fd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MYj67IjqpimWR486YnSP9g.jpeg"/></div></div><figcaption class="lg lh et er es li lj bd b be z dx translated">删除带有 1 个子节点的节点</figcaption></figure><p id="e180" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated"><strong class="jl hj">情况 3 </strong>:如果一个包含 key-value 的节点有<strong class="jl hj">两个子节点</strong>找到该节点的下级后继节点并替换数据，然后删除替换了根节点数据的后继节点。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ln"><img src="../Images/b397e39e41fa3fe1273bde3daa9a492e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*W_hCWzuz12j6SoZhjiZiJA.jpeg"/></div></div><figcaption class="lg lh et er es li lj bd b be z dx translated">删除带有 2 个子节点的节点</figcaption></figure><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es lo"><img src="../Images/83d87e74e00af15655bdd770ddd1c70e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1158/format:webp/1*BImkwcoBzAovm7IjF0qHMg.jpeg"/></div><figcaption class="lg lh et er es li lj bd b be z dx translated">构建搜索和删除所有类型节点的输出</figcaption></figure><h2 id="ddcc" class="kf kg hi bd kh ki kj kk kl km kn ko kp js kq kr ks jw kt ku kv ka kw kx ky kz bi translated">检查给定的树是否是二叉查找树:</h2><p id="a2d6" class="pw-post-body-paragraph jj jk hi jl b jm la ij jo jp lb im jr js lc ju jv jw ld jy jz ka le kc kd ke hb bi translated">我们可以采用自上而下的方法，为每个节点分配一个最大值和最小值，并检查该节点的值是否在该范围内。对于该树中的每个节点，它都是二叉查找树</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es lp"><img src="../Images/a7cadf94f402522a903697911a304420.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*t0ET9tF64Mp0HOjKJwVcaA.jpeg"/></div></div><figcaption class="lg lh et er es li lj bd b be z dx translated">检查树是否为 bst 的代码</figcaption></figure><p id="eafd" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">如果二叉查找树是平衡的，我们可以在 O(log N)时间复杂度内执行插入、搜索和删除，其中 N 是节点的数量，在偏斜 BST 的情况下，它是 O(n)。</p><p id="4759" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">文章结尾。</p><p id="a5c3" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">谢谢你</p><p id="4ed0" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">快乐编码:)</p></div></div>    
</body>
</html>