<html>
<head>
<title>Partial Application with React</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">带 React 的部分应用</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/functional-component-object-state-724691aa7bfb?source=collection_archive---------11-----------------------#2021-03-04">https://medium.com/nerd-for-tech/functional-component-object-state-724691aa7bfb?source=collection_archive---------11-----------------------#2021-03-04</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/b626ec33270f0da76dcfb9d172e0f1a1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Jak_zv5f5wvgpOGJ8P2yIw.jpeg"/></div></div></figure><p id="087c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如何在 React 功能组件中实现声明性表单状态管理策略？</p><p id="09d9" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">思考这个问题一两分钟后，我意识到除了改变表单的底层对象状态之外，如果该功能还能在用户开始输入时清除任何验证错误，那就太好了。</p><p id="cb69" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">所以我开始考虑这个结果。</p><pre class="jo jp jq jr fd js jt ju jv aw jw bi"><span id="f003" class="jx jy hi jt b fi jz ka l kb kc">&lt;input type="text" onChange={<strong class="jt hj">setsProperty('firstName')</strong>} /&gt;</span></pre><p id="6f96" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在确保可重用性的同时，我可以使用什么技术来完成这项工作？功能组成呢，具体来说，<a class="ae kd" href="https://en.wikipedia.org/wiki/Partial_application" rel="noopener ugc nofollow" target="_blank">局部应用</a>？考虑到这一点，我像这样逐步完成了这个过程。</p><p id="b22a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">当 onChange 事件触发时，我需要一个属性名来设置修改状态对象。</p><pre class="jo jp jq jr fd js jt ju jv aw jw bi"><span id="1745" class="jx jy hi jt b fi jz ka l kb kc">const formObjectMutator = <strong class="jt hj">prop =&gt; event</strong> =&gt;{}</span></pre><p id="c758" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">除此之外，我还需要访问当前状态，这样我就可以将它与更改后的属性结合起来。</p><pre class="jo jp jq jr fd js jt ju jv aw jw bi"><span id="5789" class="jx jy hi jt b fi jz ka l kb kc">const formObjectMutator = <strong class="jt hj">currentState</strong> =&gt; prop =&gt; event =&gt;{}</span></pre><p id="6b86" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我将如何更新状态？为此，我也需要一个 useState setter 函数。</p><pre class="jo jp jq jr fd js jt ju jv aw jw bi"><span id="1649" class="jx jy hi jt b fi jz ka l kb kc">const formObjectMutator = currentState =&gt; <strong class="jt hj">updateStateFn</strong> =&gt; prop =&gt; event =&gt;{<br/>      <strong class="jt hj">updateStateFn</strong>({...currentState,[prop]: event.target.value});<br/>}</span></pre><p id="3360" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">好了，这变得很混乱，currentState 和 updateStateFn 显然属于一起，可以移到同一个函数中。</p><pre class="jo jp jq jr fd js jt ju jv aw jw bi"><span id="de61" class="jx jy hi jt b fi jz ka l kb kc">const formObjectMutator = (<strong class="jt hj">currentState, updateStateFn</strong>) =&gt; prop =&gt; event =&gt;{<br/>        updateStateFn({...currentState,[prop]: event.target.value});<br/>}</span></pre><p id="0b04" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">哦，对了，我差点忘了，那些验证错误怎么办？让我们使这一个成为可选的。我们也可以将这个参数传递给初始函数。</p><pre class="jo jp jq jr fd js jt ju jv aw jw bi"><span id="cd36" class="jx jy hi jt b fi jz ka l kb kc">const formObjectMutator = (currentState, updateStateFn, <strong class="jt hj">clearMessagesFn</strong>) =&gt; prop =&gt; event =&gt;{</span><span id="0f45" class="jx jy hi jt b fi ke ka l kb kc">    updateStateFn({...currentState,[prop]: event.target.value});<br/>   <br/>     //clear validation errors<br/>    if(<strong class="jt hj">clearMessagesFn</strong>)<strong class="jt hj"><br/>       clearMessagesFn();</strong><br/>}</span></pre><p id="452d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">最后，我们如何在 React 功能组件中使用这个几乎不可读的函数？</p><pre class="jo jp jq jr fd js jt ju jv aw jw bi"><span id="cad0" class="jx jy hi jt b fi jz ka l kb kc">// 1. Create your state and mutator function<br/>const [profile, setProfile] = useState(null);</span><span id="3a36" class="jx jy hi jt b fi ke ka l kb kc">// 2.Configure a new function that takes the property name<br/>const <strong class="jt hj">setsProperty</strong> = <strong class="jt hj">formObjectMutator</strong>(profile, setProfile, () =&gt; validationErrors &amp;&amp; setValidationErrors(null));</span><span id="1346" class="jx jy hi jt b fi ke ka l kb kc">// 3. Configure new functions that handle onChange events<br/>&lt;input type=”text” onChange={setsProperty('firstName')} /&gt;<br/>&lt;input type=”text” onChange={setsProperty('lastName')} /&gt;<br/>&lt;input type=”text” onChange={setsProperty('age')} /&gt;</span></pre><p id="7ec8" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">完事了吗？几乎是，但在此过程中，我意识到“currentState”参数似乎产生正确结果的唯一原因是，formObjectMutator <strong class="is hj"> </strong>函数在每个更新周期后都用最近的状态重新初始化。</p><p id="160a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">用 useState 钩子<a class="ae kd" href="https://reactjs.org/docs/hooks-reference.html#functional-updates" rel="noopener ugc nofollow" target="_blank">创建的 Mutator 函数也将接受一个函数来代替值</a>。因此，如果我们传入一个回调，先前的状态值将作为参数传递给它，我们可以使用该值，结合我们的更改，来重建我们的状态对象。</p><p id="472a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">重构之后，这就是我最终得到的结果。</p><pre class="jo jp jq jr fd js jt ju jv aw jw bi"><span id="d951" class="jx jy hi jt b fi jz ka l kb kc">export const formObjectMutator = (updateStateFn, clearMessagesFn) =&gt; property =&gt; event =&gt; {</span><span id="8ce9" class="jx jy hi jt b fi ke ka l kb kc">    // do not reference the event object within <br/>    // the inner function passed to the state <br/>    // function or you will have problems<br/>    <strong class="jt hj">const newValue = event.target.value;</strong></span><span id="299f" class="jx jy hi jt b fi ke ka l kb kc">    updateStateFn(<strong class="jt hj">prevState =&gt; { <br/>        return { …prevState, [property]: newValue} <br/>    }</strong>);</span><span id="e765" class="jx jy hi jt b fi ke ka l kb kc">    if(clearValidationMessagesFn)<br/>       clearValidationMessagesFn();<br/>}</span><span id="9600" class="jx jy hi jt b fi ke ka l kb kc">// Now it only requires the setter function<br/>const setsProperty = formObjectMutator(setProfile, () =&gt; validationErrors &amp;&amp; setValidationErrors(null));</span><span id="d63b" class="jx jy hi jt b fi ke ka l kb kc">.......</span><span id="7f0f" class="jx jy hi jt b fi ke ka l kb kc">&lt;input type=”text” onChange={setsProperty('pronouns')} /&gt;</span></pre><figure class="jo jp jq jr fd ij"><div class="bz dy l di"><div class="kf kg l"/></div></figure></div></div>    
</body>
</html>