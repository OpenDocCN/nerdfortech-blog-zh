<html>
<head>
<title>How to start using Java streams</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何开始使用Java流</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/how-to-start-using-java-streams-6e7f7f061a61?source=collection_archive---------6-----------------------#2021-07-15">https://medium.com/nerd-for-tech/how-to-start-using-java-streams-6e7f7f061a61?source=collection_archive---------6-----------------------#2021-07-15</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><h2 id="9f1f" class="hg hh hi bd b fp hj hk hl hm hn ho dx hp translated" aria-label="kicker paragraph">Java指南</h2><div class=""/><div class=""><h2 id="cc98" class="pw-subtitle-paragraph io hr hi bd b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf dx translated">开始使用Java流，让您的生活更轻松</h2></div><figure class="jh ji jj jk fd jl er es paragraph-image"><div role="button" tabindex="0" class="jm jn di jo bf jp"><div class="er es jg"><img src="../Images/e23996c2ff1b310b5f2135f062940b6b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*t4PSiCKQgn4FW4rp"/></div></div></figure><p id="1e16" class="pw-post-body-paragraph js jt hi ju b jv jw is jx jy jz iv ka kb kc kd ke kf kg kh ki kj kk kl km kn hb bi ko translated">Java 8中引入了流，它们本质上是支持聚合操作的元素序列，类似于循环。</p><p id="6b4f" class="pw-post-body-paragraph js jt hi ju b jv jw is jx jy jz iv ka kb kc kd ke kf kg kh ki kj kk kl km kn hb bi translated">假设我们想计算单词“key”在数组中出现的次数:</p><figure class="jh ji jj jk fd jl"><div class="bz dy l di"><div class="kx ky l"/></div></figure><p id="ba5c" class="pw-post-body-paragraph js jt hi ju b jv jw is jx jy jz iv ka kb kc kd ke kf kg kh ki kj kk kl km kn hb bi translated">使用for循环，我们会得到如下结果:</p><figure class="jh ji jj jk fd jl"><div class="bz dy l di"><div class="kx ky l"/></div></figure><p id="4dd5" class="pw-post-body-paragraph js jt hi ju b jv jw is jx jy jz iv ka kb kc kd ke kf kg kh ki kj kk kl km kn hb bi translated">使用streams，我们会得到这样的结果:</p><figure class="jh ji jj jk fd jl"><div class="bz dy l di"><div class="kx ky l"/></div></figure><p id="0640" class="pw-post-body-paragraph js jt hi ju b jv jw is jx jy jz iv ka kb kc kd ke kf kg kh ki kj kk kl km kn hb bi translated">正如您所看到的，流中的方法名立刻告诉您代码打算做什么。首先，我们使用Arrays stream()方法将数组转换为顺序流，然后使用filter方法返回满足lambda表达式(a -&gt; a.equals("key "))中指示的条件的流，流中的元素数量由count()方法返回。</p><p id="88a1" class="pw-post-body-paragraph js jt hi ju b jv jw is jx jy jz iv ka kb kc kd ke kf kg kh ki kj kk kl km kn hb bi translated"><strong class="ju hs">Java流的特点是</strong>:</p><ul class=""><li id="1821" class="kz la hi ju b jv jw jy jz kb lb kf lc kj ld kn le lf lg lh bi translated">流不存储它们的元素。这些存储在集合中或按需生成。</li><li id="835b" class="kz la hi ju b jv li jy lj kb lk kf ll kj lm kn le lf lg lh bi translated">由于流不是数据结构，您需要从I/O通道、数组或集合中获取输入。</li><li id="db1e" class="kz la hi ju b jv li jy lj kb lk kf ll kj lm kn le lf lg lh bi translated">流不会修改原始数据结构。</li><li id="e348" class="kz la hi ju b jv li jy lj kb lk kf ll kj lm kn le lf lg lh bi translated">溪流不会改变它们的源头。上一个示例中的filter方法不是删除元素或修改流，而是生成一个新的流。</li><li id="132a" class="kz la hi ju b jv li jy lj kb lk kf ll kj lm kn le lf lg lh bi translated">流操作直到需要它们的结果时才被执行，换句话说，它们是<strong class="ju hs">懒惰的</strong>。</li></ul><h1 id="0013" class="ln lo hi bd lp lq lr ls lt lu lv lw lx ix ly iy lz ja ma jb mb jd mc je md me bi translated">中间和终端操作流</h1><p id="0175" class="pw-post-body-paragraph js jt hi ju b jv mf is jx jy mg iv ka kb mh kd ke kf mi kh ki kj mj kl km kn hb bi translated">在创建一个流之后，你通常会使用中间和终端操作。</p><figure class="jh ji jj jk fd jl er es paragraph-image"><div role="button" tabindex="0" class="jm jn di jo bf jp"><div class="er es mk"><img src="../Images/752bda0e00470cef667f8b9508f8f3ca.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*inrzccNQxjB_fZ70ny_5Qg.gif"/></div></div></figure><ul class=""><li id="bc8c" class="kz la hi ju b jv jw jy jz kb lb kf lc kj ld kn le lf lg lh bi translated"><strong class="ju hs">中间操作</strong>用于转换原始流。上例中使用的filter()方法是一个中间操作，它产生一个包含满足条件的元素的流。</li><li id="3231" class="kz la hi ju b jv li jy lj kb lk kf ll kj lm kn le lf lg lh bi translated"><strong class="ju hs">终端操作</strong>强制执行之前的惰性操作。这些操作返回一个空的或非流的结果，而不是另一个流。上例中的count()方法是一个终端操作。使用终端操作后，该流就不能再使用了。</li></ul><p id="0570" class="pw-post-body-paragraph js jt hi ju b jv jw is jx jy jz iv ka kb kc kd ke kf kg kh ki kj kk kl km kn hb bi translated">让我们看看下面的例子:</p><figure class="jh ji jj jk fd jl"><div class="bz dy l di"><div class="kx ky l"/></div></figure><p id="d14f" class="pw-post-body-paragraph js jt hi ju b jv jw is jx jy jz iv ka kb kc kd ke kf kg kh ki kj kk kl km kn hb bi translated">这段代码将数组中的每个数字乘以3，然后打印出来。这里map()方法用于在将(a -&gt; a * 3)函数应用于原始流之后返回一个流，这是一个中间操作。for Each()方法为流中的每个元素执行一个操作，并且是一个终结操作。</p><p id="3b89" class="pw-post-body-paragraph js jt hi ju b jv jw is jx jy jz iv ka kb kc kd ke kf kg kh ki kj kk kl km kn hb bi translated">流是一个非常有用的工具，可以节省您的时间，并使您的代码更具可读性。开始在代码中实现这个API，简单地完成工作。</p></div><div class="ab cl ml mm gp mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="hb hc hd he hf"><p id="aa0f" class="pw-post-body-paragraph js jt hi ju b jv jw is jx jy jz iv ka kb kc kd ke kf kg kh ki kj kk kl km kn hb bi translated"><em class="ms">感谢阅读本文！如果您有任何</em>建议<em class="ms">，请在下面留下评论。一定要拍拍这个帖子，关注我。</em></p></div></div>    
</body>
</html>