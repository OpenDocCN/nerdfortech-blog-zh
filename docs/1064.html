<html>
<head>
<title>Create a chat app with java sockets</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用 java 套接字创建聊天应用程序</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/create-a-chat-app-with-java-sockets-8449fdaa933?source=collection_archive---------0-----------------------#2021-03-03">https://medium.com/nerd-for-tech/create-a-chat-app-with-java-sockets-8449fdaa933?source=collection_archive---------0-----------------------#2021-03-03</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div class="er es if"><img src="../Images/c49962c5bbb068d089015485b6f5fadc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*md-ixthfFfB4WoT402y8cw.jpeg"/></div></figure><p id="066f" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">在本文中，我们将使用 Java 套接字实现一个客户端/服务器聊天应用程序。本教程是关于使用线程的聊天应用的后端实现。我们将一步一步地解释概念和实现。</p></div><div class="ab cl jk jl gp jm" role="separator"><span class="jn bw bk jo jp jq"/><span class="jn bw bk jo jp jq"/><span class="jn bw bk jo jp"/></div><div class="hb hc hd he hf"><h1 id="e990" class="jr js hi bd jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko bi translated">基本概念</h1><p id="ad59" class="pw-post-body-paragraph im in hi io b ip kp ir is it kq iv iw ix kr iz ja jb ks jd je jf kt jh ji jj hb bi translated">服务器:</p><p id="6406" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">为了与客户端通信，服务器使用两种类型的套接字</p><p id="777c" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><strong class="io hj"> ServerSocket </strong>:这个类被服务器用来声明一个 ServerSocket 对象，服务器需要这个对象来监听来自客户端的连接请求</p><p id="d90c" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><strong class="io hj"> Socket </strong>:这个类被服务器用来声明一个 Socket 对象，服务器用它来发送和接收来自客户端的数据</p><p id="20f3" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">客户:</p><p id="fccb" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">为了与服务器通信，客户端使用一个套接字(来自<strong class="io hj">套接字</strong>类的对象)来发送和接收来自服务器的数据</p><p id="3620" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">= &gt;服务器和客户端中的<strong class="io hj"> Socket </strong>类的<strong class="io hj">实例化</strong>是不同的，尽管它是相同的类，但是它在客户端和服务器之间是不同的</p><h1 id="f396" class="jr js hi bd jt ju ku jw jx jy kv ka kb kc kw ke kf kg kx ki kj kk ky km kn ko bi translated">履行</h1><p id="4d22" class="pw-post-body-paragraph im in hi io b ip kp ir is it kq iv iw ix kr iz ja jb ks jd je jf kt jh ji jj hb bi translated">使用 IntelliJ IDEA，我创建了一个名为“chat”的项目，然后在 src 文件夹下创建了两个 Java 类:Server.java 和 Client.java</p><figure class="la lb lc ld fd ij er es paragraph-image"><div class="er es kz"><img src="../Images/6e7230c54ed552e3c8a5b3a303b23b67.png" data-original-src="https://miro.medium.com/v2/resize:fit:988/format:webp/1*z3lPVoTUGRH9zuvDx2GCiA.png"/></div><figcaption class="le lf et er es lg lh bd b be z dx translated">项目创建</figcaption></figure><figure class="la lb lc ld fd ij er es paragraph-image"><div class="er es li"><img src="../Images/205ba8f7e61e4f95f628b7e70a6c8dff.png" data-original-src="https://miro.medium.com/v2/resize:fit:1086/format:webp/1*wftdrB3K-k5ztvHlMb8OnQ.png"/></div><figcaption class="le lf et er es lg lh bd b be z dx translated">Server.java</figcaption></figure><figure class="la lb lc ld fd ij er es paragraph-image"><div class="er es lj"><img src="../Images/135e6ffb37547fb02982062dcb178eae.png" data-original-src="https://miro.medium.com/v2/resize:fit:1254/format:webp/1*pj2Iu8T7NU9MgFSx5GrChw.png"/></div><figcaption class="le lf et er es lg lh bd b be z dx translated">Client.java</figcaption></figure><p id="34e2" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">现在让我们实现 Server.java 类:</p><p id="9a19" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><strong class="io hj">1-Server.java</strong></p><p id="954a" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">首先，我们声明 5 个对象:</p><ul class=""><li id="5071" class="lk ll hi io b ip iq it iu ix lm jb ln jf lo jj lp lq lr ls bi translated">final<strong class="io hj">ServerSocket</strong>serversocket:这一行意味着我们声明了一个名为“server socket”的对象，它是 server socket 类的一个对象。它被声明为“最终”，这意味着它是一个常数</li><li id="2d77" class="lk ll hi io b ip lt it lu ix lv jb lw jf lx jj lp lq lr ls bi translated">final<strong class="io hj">Socket</strong>clientSocket:这一行意味着我们声明了一个名为“client Socket”的对象，它是 Socket 类的一个对象。它被声明为“最终”，这意味着它是一个常数</li><li id="edc5" class="lk ll hi io b ip lt it lu ix lv jb lw jf lx jj lp lq lr ls bi translated">final BufferedReader in:这一行意味着我们声明了一个名为“in”的对象，它是 BufferedReader 类的一个对象。<strong class="io hj">用于从 clientSocket 对象中读取数据</strong></li><li id="ebb3" class="lk ll hi io b ip lt it lu ix lv jb lw jf lx jj lp lq lr ls bi translated">final PrintWriter out:这一行意味着我们声明了一个名为“out”的对象，它是 PrintWriter 类的一个对象。<strong class="io hj">用于将数据写入 clientsocket 对象</strong></li></ul><p id="cad0" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">= &gt;在上面所有的代码中，我们只是声明了对象，我们仍然没有实例化它们。</p><ul class=""><li id="26b0" class="lk ll hi io b ip iq it iu ix lm jb ln jf lo jj lp lq lr ls bi translated">final Scanner sc = new Scanner(system . in):这一行代码意味着我们从名为“sc”的类 Scanner 中创建了一个对象，以便能够从用户的键盘上读取数据</li></ul><figure class="la lb lc ld fd ij er es paragraph-image"><div class="er es ly"><img src="../Images/81fd6371732f51d1eaf11d63cd56d928.png" data-original-src="https://miro.medium.com/v2/resize:fit:1316/format:webp/1*XVbi8UJpFx4SNg732Cu3bA.png"/></div></figure><p id="2010" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">现在让我们实例化 serversocket 对象:</p><figure class="la lb lc ld fd ij er es paragraph-image"><div class="er es lz"><img src="../Images/70fb69a4bd677e9654dfdf704f14d754.png" data-original-src="https://miro.medium.com/v2/resize:fit:1212/format:webp/1*aO6GE3LENAfbEXi5mzgovQ.png"/></div></figure><p id="59a6" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">如您所见，ServerSocket 类的构造函数必须接受一个端口号，服务器将使用该端口号来监听客户端的请求，而且实例化应该在 try/catch 中进行</p><figure class="la lb lc ld fd ij er es paragraph-image"><div class="er es ma"><img src="../Images/95d01002958f4304aa25c429b090db6b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1214/format:webp/1*NYF1qP3qa25aYh_LvHL2Vg.png"/></div></figure><p id="8437" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">如前所述，服务器使用 serversocket 来监听来自客户端的连接请求，它使用方法<strong class="io hj"> accept() </strong>来等待来自客户端的请求，一旦接收到请求，它就接受它并创建一个<strong class="io hj"> Socket </strong>类的实例，在我们的例子中它将是“clientsocket”对象。</p><figure class="la lb lc ld fd ij er es paragraph-image"><div role="button" tabindex="0" class="mc md di me bf mf"><div class="er es mb"><img src="../Images/c1cbbdfd62d949952b9eec43df8eed44.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Z4bHDdkrOWTjd-bDax1eBA.png"/></div></div></figure><p id="f028" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">为了实例化“out”，我们使用了<strong class="io hj"> PrintWriter </strong>类的构造函数，这个构造函数接受一个参数，这是套接字的输出流，注意这里使用的套接字是<strong class="io hj"> clientSocket </strong>，因为它负责向客户端发送数据。</p><p id="340a" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">现在“out”准备将数据写入“clientsocket”！</p><figure class="la lb lc ld fd ij er es paragraph-image"><div role="button" tabindex="0" class="mc md di me bf mf"><div class="er es mg"><img src="../Images/fb0a6c58206efd9df1f78a67ad729f95.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*E-l-NbMxpTb8fXErt7GaHw.png"/></div></div></figure><p id="22d7" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">在这一部分中，我们实例化“In”对象，我们将使用它从 clientSocket 中读取数据。这里的构造函数将调用另一个构造函数作为参数</p><p id="8b1c" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><strong class="io hj">new InputStreamReader(client socket . getinputstream())</strong>:为套接字创建一个流读取器。然而，这个流读取器只读取字节形式的数据，因此必须将其传递给 BufferedReader 以转换为字符。</p><p id="0b78" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">既然我们将使用的所有对象都已创建，我们将开始实现两个线程:</p><p id="b23a" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><em class="mh">发送线程</em>:它包含服务器将用来向客户端发送消息的代码</p><p id="4f6f" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><em class="mh">接收线程</em>:它包含了服务器用来从客户端接收消息的代码</p><p id="8aa9" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><strong class="io hj">发送线程</strong></p><p id="e882" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">在这一部分中，我们将从用户处读取数据，并将这些数据发送给客户端。</p><figure class="la lb lc ld fd ij er es paragraph-image"><div role="button" tabindex="0" class="mc md di me bf mf"><div class="er es mi"><img src="../Images/7f992070c56b44792ee76d91686e7ef0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*q9RtMHWrnFvJyfKNkH7q8g.png"/></div></div></figure><p id="bb3a" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">Java 中的类 Thread 有自己默认的 run()方法，该方法应该包含线程将要执行的代码。然而它不能被执行，除非你在那个线程上调用方法<strong class="io hj"> start() </strong>。此外，由于在每个不同的线程中我们有不同的代码要实现，我们使用了<strong class="io hj"> @Override </strong>注释。</p><p id="3b18" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><strong class="io hj">接收线程</strong></p><p id="7fcb" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">在这一部分，我们实现了接收线程。</p><p id="fd47" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">我们使用方法<strong class="io hj"> readLine() </strong>使用与 clientSocket 关联的“in”对象读取从客户端发送的数据。</p><p id="f9eb" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">该方法逐行读取客户端发送的消息，如果该方法返回空值，则意味着客户端不再连接。这并不意味着客户端没有发送任何东西，因为客户端可以连接到服务器，仍然没有发送任何东西。</p><figure class="la lb lc ld fd ij er es paragraph-image"><div role="button" tabindex="0" class="mc md di me bf mf"><div class="er es mj"><img src="../Images/0f94ca80afdbcb9084bf24be0b67c4b8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*u7KcZyXCLW-hdGLEKRBCew.png"/></div></div></figure><p id="f7e4" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">当客户端不再连接到服务器时，我们应该使用方法<strong class="io hj"> close() </strong>关闭我们使用的所有套接字和流。此外，我们将所有代码放在 try/catch 中，这样我们可以打印任何与读取数据或关闭套接字和流相关的错误。</p><p id="c35f" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">服务器现在可以通信了！</p><p id="32d6" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">这是完整的代码</p><figure class="la lb lc ld fd ij er es paragraph-image"><div role="button" tabindex="0" class="mc md di me bf mf"><div class="er es mk"><img src="../Images/e40f40a1e7ffa160cf5e96a98e0733cb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0oKZA_8Af-yZgfQqyAsw7Q.png"/></div></div></figure><figure class="la lb lc ld fd ij er es paragraph-image"><div role="button" tabindex="0" class="mc md di me bf mf"><div class="er es ml"><img src="../Images/f44bcd73ebca6a7959a81586da39221a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6BWpRy3T3764OWw9IorKqQ.png"/></div></div></figure><p id="7356" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">现在让我们实现 Client.java 类:</p><p id="8d54" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><strong class="io hj">2-Client.java</strong></p><figure class="la lb lc ld fd ij er es paragraph-image"><div role="button" tabindex="0" class="mc md di me bf mf"><div class="er es mm"><img src="../Images/833e353e364ff0adfb8cd7ac9041d9c3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4lIBkn68GtcBCUceffhvFQ.png"/></div></div></figure><p id="5d41" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">正如你所看到的，客户端的大部分代码与服务器端的是一样的，所以我将只解释在客户端不同的代码行。</p><p id="2895" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">当我们声明客户机将用来与服务器通信的套接字时，套接字类的构造函数接受两个参数:</p><p id="654c" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><strong class="io hj"> host </strong>:这是服务器的 IP 地址，在我们的例子中，服务器和客户端都是在同一台机器上实现的，所以我们使用地址 localhost:127 . 0 . 0 . 1</p><p id="4eef" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><strong class="io hj">端口</strong>:端口号，是 Server.java 服务器定义的端口号</p><p id="91fb" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">现在，客户端也有两个线程，一个用于发送数据，另一个用于接收数据，它们的实现方式与服务器的线程相同</p><figure class="la lb lc ld fd ij er es paragraph-image"><div role="button" tabindex="0" class="mc md di me bf mf"><div class="er es mn"><img src="../Images/27b2b786d7cda8b87143d26242093f13.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DsQc3zH9G5SvI3JatNYjyA.png"/></div></div></figure><figure class="la lb lc ld fd ij er es paragraph-image"><div role="button" tabindex="0" class="mc md di me bf mf"><div class="er es mo"><img src="../Images/de892884bad21003bc3f722f33c3cbd8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VytjDeeQPTN42fXmia_yrQ.png"/></div></div></figure><p id="7cc9" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">现在，客户端已经准备好进行通信了</p><p id="7f74" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">以下是完整的代码:</p><figure class="la lb lc ld fd ij er es paragraph-image"><div role="button" tabindex="0" class="mc md di me bf mf"><div class="er es mp"><img src="../Images/7e5380d3d954e1dc486d78180882a143.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*n_31spp1fVt4jKapglmiEg.png"/></div></div></figure><figure class="la lb lc ld fd ij er es paragraph-image"><div role="button" tabindex="0" class="mc md di me bf mf"><div class="er es mq"><img src="../Images/b1747b79cffef3d2eebd49d7b5ef5e44.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Hqe5F3i5fw_7a2Fh4Rh9oA.png"/></div></div></figure><p id="5d22" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><strong class="io hj"> 3-执行</strong></p><p id="d363" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">让我们看看这是如何工作的</p><p id="4760" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">先办 Server.java 班，再办 Client.java 班</p><figure class="la lb lc ld fd ij er es paragraph-image"><div role="button" tabindex="0" class="mc md di me bf mf"><div class="er es mr"><img src="../Images/d896d6c60489943a538f61c1c81330ad.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*h9vtkpe5oZLylo7uSuIfwg.png"/></div></div></figure><figure class="la lb lc ld fd ij er es paragraph-image"><div role="button" tabindex="0" class="mc md di me bf mf"><div class="er es ms"><img src="../Images/1151ed38330ccb72409cb0287980474c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iJNab9G8JFcfIZNuk_xECQ.png"/></div></div></figure><p id="8a6d" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">您可以使用以下链接从我的 github 资源库下载项目:</p><div class="mt mu ez fb mv mw"><a href="https://github.com/JiheneBarhoumi/ChatApp" rel="noopener  ugc nofollow" target="_blank"><div class="mx ab dw"><div class="my ab mz cl cj na"><h2 class="bd hj fi z dy nb ea eb nc ed ef hh bi translated">JiheneBarhoumi/ChatApp</h2><div class="nd l"><h3 class="bd b fi z dy nb ea eb nc ed ef dx translated">在 GitHub 上创建一个帐户，为 JiheneBarhoumi/ChatApp 的开发做出贡献。</h3></div><div class="ne l"><p class="bd b fp z dy nb ea eb nc ed ef dx translated">github.com</p></div></div><div class="nf l"><div class="ng l nh ni nj nf nk ik mw"/></div></div></a></div></div></div>    
</body>
</html>