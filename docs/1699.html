<html>
<head>
<title>Functional Programming in PHP (Part 2) — Currying</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">PHP 函数式编程(第二部分)——Currying</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/functional-programming-in-php-part-2-currying-2353b71dbe7a?source=collection_archive---------5-----------------------#2021-04-02">https://medium.com/nerd-for-tech/functional-programming-in-php-part-2-currying-2353b71dbe7a?source=collection_archive---------5-----------------------#2021-04-02</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/0b49fbd7a53b905e00ed554f4ded6619.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XWer59VMXChN6Z6hjU4OwQ.jpeg"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">由<a class="ae iu" href="https://unsplash.com/@sharonmccutcheon?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">莎伦·麦卡琴</a>在<a class="ae iu" href="https://unsplash.com/s/photos/bubbles?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄的照片</figcaption></figure><p id="8fd5" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在<a class="ae iu" href="https://auxiliaire.medium.com/functional-programming-in-php-an-introduction-80e3f2a46e74" rel="noopener">上一篇文章</a>中，我们介绍了 PHP 中函数式编程(FP)的基础。到目前为止，这不是一个全面的介绍，而是提到了 FP 的最重要的概念以及 PHP 的特性，这是尽快开始在 PHP 中应用 FP 所必需的。在这一部分中，我假设你已经熟悉了介绍中提到的那些基础知识，随着我们继续进行<em class="jt">和</em>的讨论，我会加入更多的概念。</p><h1 id="ff84" class="ju jv hi bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">给你的代码增添趣味</h1><p id="6db6" class="pw-post-body-paragraph iv iw hi ix b iy ks ja jb jc kt je jf jg ku ji jj jk kv jm jn jo kw jq jr js hb bi translated">虽然听起来很花哨，但 currying 实际上与你最喜欢的姜黄混合粉没有任何关系，而是从美国数学家哈斯克尔·库里(Haskell Curry)那里衍生出它的名字(你肯定会记得这个名字)。尽管如此，我们将会看到，阿谀奉承无异于给我们的代码增添趣味。</p><p id="dcaf" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在纯函数式语言中，比如 Haskell(惊喜！)，您可以为函数提供比它们期望的更少的参数(←不准确，它们总是期望最多一个参数，但是为了简单起见，我们将从这个角度进行讨论)，并且它们弹性地回复一个新函数，该函数期望剩余的参数，同时捕获您已经提供的参数。</p><p id="2ddb" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这是 currying。(事实上这是自动的，因为您不需要像我们将要做的那样显式地调用函数上的<code class="du kx ky kz la b">curry</code>。)</p><p id="d552" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们可以用如下一些象征来说明这一点。</p><p id="1f0f" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如果我们将函数视为将输入映射到输出的映射器，我们可以将它们符号化如下:</p><pre class="lb lc ld le fd lf la lg lh aw li bi"><span id="f24c" class="lj jv hi la b fi lk ll l lm ln">&lt;input_type&gt; → &lt;output_type&gt;</span></pre><p id="eb31" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">像这样带多个参数的函数:</p><pre class="lb lc ld le fd lf la lg lh aw li bi"><span id="151d" class="lj jv hi la b fi lk ll l lm ln">&lt;input_type_1&gt;, &lt;input_type_2&gt;, &lt;input_type_3&gt; → &lt;output_type&gt;</span></pre><p id="40a3" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">那么我们可以这样表示 curried 函数(3 个参数的例子):</p><pre class="lb lc ld le fd lf la lg lh aw li bi"><span id="76cf" class="lj jv hi la b fi lk ll l lm ln">&lt;input_type&gt; → (&lt;input_type_2&gt; → (&lt;input_type_3&gt; → &lt;output_type&gt;))</span></pre><p id="1e17" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">也就是说，我们的函数不是等待所有三个参数，而是返回另一个接受下一个参数的函数，并返回另一个接受最后一个参数的函数，然后返回输出。</p><p id="3324" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">有多少输入参数并不重要。</p><pre class="lb lc ld le fd lf la lg lh aw li bi"><span id="b7c5" class="lj jv hi la b fi lk ll l lm ln">&lt;input_type_1&gt;, ...&lt;input_type_n&gt; → &lt;output_type&gt;</span></pre><p id="9679" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">会被奉承到:</p><pre class="lb lc ld le fd lf la lg lh aw li bi"><span id="d0cf" class="lj jv hi la b fi lk ll l lm ln">&lt;input_type_1&gt; → (... → (&lt;input_type_n&gt; → &lt;output_type&gt;))</span></pre><p id="b339" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们也可以跳过括号，因为我们的函数总是返回一个输出，所以很明显箭头右侧的所有内容都是输出:</p><pre class="lb lc ld le fd lf la lg lh aw li bi"><span id="e637" class="lj jv hi la b fi lk ll l lm ln">&lt;input_type_1&gt; → ... → &lt;input_type_n&gt; → &lt;output_type&gt;</span></pre><p id="bc7e" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这里重要的一点是，我们可以推迟收集所有需要的数据，并将已经可用的数据存储在一个新函数中。</p><p id="d427" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">实际上，这意味着，如果你期望 5 个参数，而你一个都没给，你得到一个函数，继续期望 5 个参数<em class="jt">或更少</em>。如果这个函数只有一个参数，那么它将返回一个新函数，期望剩下的 4 个参数，同时获取已经提供的参数。如果你给这个函数提供两个参数，那么返回的函数将期待剩下的三个参数，依此类推。好的一面是，返回的函数也会帮我们这个忙，我们可以一个接一个地给函数输入参数。或者一个接一个。或者按你喜欢的任何方式分组。</p><p id="a735" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如果您提供了所有必需的参数会怎么样？然后你的函数最终被执行，正如我们在上面看到的，并返回结果。</p><p id="a70d" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这是一个非常强大的概念，让我们摆脱了大量的局部变量。</p><p id="5f35" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">此时，您可以尝试实现自己版本的<code class="du kx ky kz la b">curry</code>函数，它接受一个函数，并不断返回接受下一个参数的嵌入式函数，直到原始函数的所有参数都满足，在这种情况下，它只返回使用提供的参数调用的原始函数的结果。</p><p id="1c19" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在此期间，我将谈谈<em class="jt">变长参数列表</em>。一会儿见。</p><h1 id="142d" class="ju jv hi bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">"一条大蟒蛇正在消化一头大象"</h1><p id="434a" class="pw-post-body-paragraph iv iw hi ix b iy ks ja jb jc kt je jf jg ku ji jj jk kv jm jn jo kw jq jr js hb bi translated">就像名画中的蛇一样，如果我们允许，我们的功能也能够吞咽和消化几乎任何东西。这意味着它们可以接受不同数量的参数，我们不需要指定它们的数量。它可以是零、一或更多。</p><p id="73cd" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这是通过用“<code class="du kx ky kz la b">...</code>标记”来标记我们的函数来实现的 PHP 这样称呼它们。在其他语言中，它被称为“省略号”(C/C++，Java)，或“扩展操作符”(JavaScript/TypeScript)，但奇怪的是，PHP 避免将其称为这些名称中的任何一个，而是在文档的所有相关部分<a class="ae iu" href="https://www.php.net/manual/en/functions.arguments.php#functions.variable-arg-list" rel="noopener ugc nofollow" target="_blank">中使用“<code class="du kx ky kz la b">...</code>令牌”或“<code class="du kx ky kz la b">...</code>操作符”短语(</a><a class="ae iu" href="https://www.php.net/manual/en/migration56.new-features.php" rel="noopener ugc nofollow" target="_blank">发布公告</a>)。即使我们不直呼其名(出于一些迷信的原因)，它们也非常有用，我们会相当频繁地使用它们。</p><p id="b613" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">语法如下所示:</p><pre class="lb lc ld le fd lf la lg lh aw li bi"><span id="b3c3" class="lj jv hi la b fi lk ll l lm ln">function variadic(...$arguments) {}</span></pre><p id="a9f0" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">其中<code class="du kx ky kz la b">$arguments</code>参数将是一个<code class="du kx ky kz la b">array</code>。这可以帮助我们在 PHP 中一次为函数提供任意数量的参数，并简化一些代码。</p><p id="afb5" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">回到我们的汤…</p><h1 id="bf3e" class="ju jv hi bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">用咖喱烹饪</h1><p id="4fcd" class="pw-post-body-paragraph iv iw hi ix b iy ks ja jb jc kt je jf jg ku ji jj jk kv jm jn jo kw jq jr js hb bi translated">我们第一次尝试使用我们的 curry 函数(您可能已经实现了它，或者将使用我稍后提供的实现)可能看起来像下面这样:</p><figure class="lb lc ld le fd ij"><div class="bz dy l di"><div class="lo lp l"/></div></figure><p id="58f5" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如果我们运行这段代码，它应该会输出:</p><pre class="lb lc ld le fd lf la lg lh aw li bi"><span id="f8d2" class="lj jv hi la b fi lk ll l lm ln">myc(a, b, c)     =&gt;     a b c<br/>myc(a)(b)(c)     =&gt;     a b c<br/>myc(a, b)(c)     =&gt;     a b c<br/>myc(a)(b, c)     =&gt;     a b c<br/>myca(b, c)       =&gt;     a b c<br/>myca(b)(c)       =&gt;     a b c<br/>mycab(c)         =&gt;     a b c<br/>mycabc           =&gt;     a b c</span></pre><p id="f1d3" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如果我们采用测试驱动的开发方法，这可能是我们的(草率的)测试。我们创建了一个简单函数<code class="du kx ky kz la b">$myfunc</code>(第 5 行)的简化版本，另外三个函数一个接一个地向它们提供参数(第 7–9 行)，然后开始疯狂地调用这些函数。</p><p id="882f" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们假设的<code class="du kx ky kz la b">curry</code>函数显然只接受一个参数，即要 curried 化的函数。</p><p id="3d09" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><code class="du kx ky kz la b">$myfunc</code>将是我们的原始函数，它有固定数量的参数，只是从它们创建另一个字符串。这里没有魔法。</p><p id="6fc2" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">创建函数的部分代表了这样一种思想，即 curried 函数一直保持 curry 状态，直到所有需要的参数都被传递给原始函数。注意，我们不需要重复已经给出的参数，因为它们在返回的函数中被捕获，并且只等待其余的。我们可以像刚才那样，把这些函数赋给一个新变量，它们继承已经提供的参数。</p><p id="9303" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">打印到屏幕上的代码行显示了调用这种定制函数的各种方式。正如您所看到的，无论我们如何调用它们，或者我们如何对参数进行分组，只要提供了所有参数，它们总是返回相同的字符串:<code class="du kx ky kz la b">a b c</code>。</p><p id="12a5" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们的测试做得不是特别好，因为一些重要的案例被遗漏了。例如，如果我们的原始函数不期望任何参数，该怎么办？然后，按照指定，返回函数调用的结果。如果我们立即提供所有需要的参数呢？为此，我们可以尝试以下方法:</p><pre class="lb lc ld le fd lf la lg lh aw li bi"><span id="ffe1" class="lj jv hi la b fi lk ll l lm ln">curry($myfunc)('a', 'b', 'c')</span></pre><p id="afae" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">根据定义，它将返回相同的输出:<code class="du kx ky kz la b">a b c</code>。那么为什么不使用我们的带三个点的朋友，并接受一个可变长度的参数列表呢？嗯，那要看情况。假设我们有它，我们可以这样调用:</p><pre class="lb lc ld le fd lf la lg lh aw li bi"><span id="19d1" class="lj jv hi la b fi lk ll l lm ln">curry($myfunc, 'a', 'b', 'c'); // 1.<br/>curry($myfunc, 'a')('b', 'c'); // 2.</span></pre><p id="9ef8" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这样好些了吗？我认为第一个没有意义，因为我们可以直接调用原始函数。如果<code class="du kx ky kz la b">curry</code>返回的是原函数的结果。但是如果它一直返回一个函数(可调用的)，那么我们需要另一个调用来触发原始函数，就像这样:</p><pre class="lb lc ld le fd lf la lg lh aw li bi"><span id="b5cf" class="lj jv hi la b fi lk ll l lm ln">curry($myfunc, 'a', 'b', 'c')();</span></pre><p id="e2a0" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">那对我来说也没多大意义。我能想到的这样做的唯一原因是确保我们的<code class="du kx ky kz la b">curry</code>函数总是返回一个可调用的。</p><p id="9d7f" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">第二个例子是把一些参数放在<code class="du kx ky kz la b">curry</code>中，而把一些留在后面，这样做丝毫没有改善语法。事实上，它只是提出了一些混乱，有时看到完全不同类型的参数在库里以下的第一个，我们原来的功能。我更喜欢保持 API 干净，并且尽可能使用最少的必要参数。对于这一点，下面这样的签名在我看来是最优的:</p><pre class="lb lc ld le fd lf la lg lh aw li bi"><span id="8250" class="lj jv hi la b fi lk ll l lm ln">curry(callable $fn)</span></pre><p id="2a85" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">没有噪音，没有杂物，只有赤裸裸的必需品。好了，继续前进。</p><h1 id="7962" class="ju jv hi bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">上菜</h1><p id="7f5f" class="pw-post-body-paragraph iv iw hi ix b iy ks ja jb jc kt je jf jg ku ji jj jk kv jm jn jo kw jq jr js hb bi translated">如果还想刺激食欲，就不能简单地对食物拍照。事实证明，服务在其中起着至关重要的作用。食物如何被放在盘子上，如何被点燃，使用什么样的相机，等等。</p><p id="75ec" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在上面的示例用法中，我们可以找到 23 个<code class="du kx ky kz la b">$</code>字符的实例。总共 18 行代码。这超过了总人数的 3%。相当多的杂物。如前所述，我们甚至不需要它们。我们更乐意拥有常量，但我们这样做的选择也不是很明智。</p><p id="d6e0" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">暂时，让我们玩弄一下不可变值的思想，假装我们上一部分的实现没有任何问题。所以定义一个不可变的值，如下所示:</p><pre class="lb lc ld le fd lf la lg lh aw li bi"><span id="1dcf" class="lj jv hi la b fi lk ll l lm ln">function immutable(): string { return 'totally immutable'; }</span></pre><p id="4d78" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">以前我们定义变量来存储函数。因此，让我们也将它们定义为不可变的:</p><pre class="lb lc ld le fd lf la lg lh aw li bi"><span id="0b3a" class="lj jv hi la b fi lk ll l lm ln">function immutableFn(): callable { return fn() =&gt; 'yeah'; }</span></pre><p id="bbb1" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">让我们看看如何利用这些巴结。</p><figure class="lb lc ld le fd ij"><div class="bz dy l di"><div class="lo lp l"/></div></figure><p id="42da" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">产出:</p><pre class="lb lc ld le fd lf la lg lh aw li bi"><span id="5687" class="lj jv hi la b fi lk ll l lm ln">Immutable greeting: Good day, Tülin!<br/>Good day, Tülin!<br/>Hello, Tülin!</span></pre><p id="780f" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">所以我们大大减少了变量的使用。所有不应该改变的东西都变成了不可变的(通过函数实现)，我们还通过更高阶的函数和 currying 来改进代码重用。恕我直言，我们还提高了可读性。</p><p id="58fe" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们的主函数有一个不可改变的值<code class="du kx ky kz la b">greet</code>。它只返回一个接受两个参数(一个窗体和一个名称)的函数。</p><p id="63f9" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">对于两种支持的形式<code class="du kx ky kz la b">formal</code>和<code class="du kx ky kz la b">informal</code>，我们有两个不可变的值，分别是值“Good day”和“Hello”。</p><p id="3449" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">然后我们使用一些 FP 魔法定义了两个新的不可改变的值，用来自<code class="du kx ky kz la b">formal</code>和<code class="du kx ky kz la b">informal</code>的预定义值填充我们原始的<code class="du kx ky kz la b">greet</code>函数，并给它们命名为<code class="du kx ky kz la b">greetFormally</code>和<code class="du kx ky kz la b">greetInformally</code>。</p><p id="8805" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这里重要的一点是，当数据可用时，我们可以将数据传递给我们的函数，并且我们可以以类似于<a class="ae iu" href="https://www.freecodecamp.org/news/a-quick-intro-to-dependency-injection-what-it-is-and-when-to-use-it-7578c84fa88f/" rel="noopener ugc nofollow" target="_blank">依赖注入</a>或<a class="ae iu" href="https://refactoring.guru/design-patterns/strategy" rel="noopener ugc nofollow" target="_blank">策略设计模式</a>的方式将函数注入其他函数。这帮助我们<a class="ae iu" href="https://en.wikipedia.org/wiki/Separation_of_concerns" rel="noopener ugc nofollow" target="_blank">分离关注点</a>，不重复自己<a class="ae iu" href="https://en.wikipedia.org/wiki/Don%27t_repeat_yourself" rel="noopener ugc nofollow" target="_blank">干</a>，保持<a class="ae iu" href="https://en.wikipedia.org/wiki/Single-responsibility_principle" rel="noopener ugc nofollow" target="_blank">单一责任</a>。是啊，所有的 OOP 的东西，只是更容易。</p><p id="27f9" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><em class="jt">注意，我提到这些只是为了帮助你理解一些概念，前提是你已经熟悉这些概念，但它们不是一对一的类比，如果你没有完全理解它们，你也不必担心。要继续，理解我们的代码示例是如何工作的就足够了。</em></p><p id="5086" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">最后，我们用名为<code class="du kx ky kz la b">tulin</code>的值‘tüLin’定义了另一个不可变的，用已经存储在<code class="du kx ky kz la b">tulin</code>中的值定义了另一个名为<code class="du kx ky kz la b">girl</code>的。</p><p id="898e" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们所有的组件都是可重复使用的。我们在现有功能的基础上构建了新的功能，比如玩乐高。我们在创建新的、专门化的功能的代码中相对较早地添加了配置，并在可能的最新时刻为它们提供了最切实的价值。随着我们为我们的工具箱收集越来越多的 FP 工具，这个组织原则将会被进一步强调。</p><p id="193a" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">请记住，我们用来存储不可变值的命名组件不应该是 PHP 意义上的函数。它们之所以成为函数，只是因为我们实现了不变量 uses 函数。这解释了即将出现的大量括号:</p><pre class="lb lc ld le fd lf la lg lh aw li bi"><span id="f42c" class="lj jv hi la b fi lk ll l lm ln">greet()(formal(), tulin())</span></pre><p id="f2ac" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">和</p><pre class="lb lc ld le fd lf la lg lh aw li bi"><span id="814d" class="lj jv hi la b fi lk ll l lm ln">greetFormally()(tulin())</span></pre><p id="3136" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这些乍一看可能很奇怪，但是在理想世界中，它们应该是这样的:</p><pre class="lb lc ld le fd lf la lg lh aw li bi"><span id="f337" class="lj jv hi la b fi lk ll l lm ln">greet(formal, tulin)</span></pre><p id="3242" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">和</p><pre class="lb lc ld le fd lf la lg lh aw li bi"><span id="dc1d" class="lj jv hi la b fi lk ll l lm ln">greetFormally(tulin)</span></pre><p id="7291" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这个理想世界类似于 Scala 语法的工作方式。那么，在一种假想的 PHP 语言中，整个代码片段会是什么样子呢？</p><p id="895b" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">假设有一个用于定义不可变值的构造，它被称为<code class="du kx ky kz la b">let</code>，那么它可能如下所示:</p><pre class="lb lc ld le fd lf la lg lh aw li bi"><span id="90e6" class="lj jv hi la b fi lk ll l lm ln">let callable greet = fn(callable $form, string $name): string =&gt; $form() . ', ' . $name . '!';</span><span id="3360" class="lj jv hi la b fi lq ll l lm ln">let callable formal = fn(): string =&gt; "Good day";<br/>let callable informal = fn(): string =&gt; "Hello";</span><span id="7ff6" class="lj jv hi la b fi lq ll l lm ln">let callable greetFormally = curry(greet)(formal);<br/>let callable greetInformally = curry(greet)(informal);</span><span id="5980" class="lj jv hi la b fi lq ll l lm ln">let string tulin = "Tülin";</span><span id="e2b8" class="lj jv hi la b fi lq ll l lm ln">let string girl = tulin;</span><span id="9638" class="lj jv hi la b fi lq ll l lm ln">// reassignment does not work:<br/>// let string girl = "Somebody else";</span><span id="e2a6" class="lj jv hi la b fi lq ll l lm ln">greet(formal, tulin);<br/>greetFormally(tulin);<br/>greetInformally(girl);</span></pre><p id="19f6" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">好多了。现在别做梦了，回去工作吧。我们有一个功能要实现。</p><figure class="lb lc ld le fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lr"><img src="../Images/81639540a6a0273b5d7fb91b610ccad3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2N6ACvH-Z-yMkBG8uS8pMg.jpeg"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">这里有一幅美丽的巴伐利亚风景图，可以帮助你做好心理准备——由作者提供</figcaption></figure><h1 id="be27" class="ju jv hi bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">在 PHP 中实现 curry</h1><p id="02b1" class="pw-post-body-paragraph iv iw hi ix b iy ks ja jb jc kt je jf jg ku ji jj jk kv jm jn jo kw jq jr js hb bi translated">在语言中实现 currying 有几种方法，在 PHP 中也有几种方法。现在，您可能有了自己的版本，并对照使用示例进行了检查。如果效果很好，恭喜你，你做对了！</p><p id="6229" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">作为参考，我提供了我自己的实现，它专注于定义一个清晰的接口，并尽可能对用户隐藏实现细节。</p><p id="81cc" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">所有的例子都是使用这个实现进行测试的，它也是我们将在这一系列文章中实现的所有其他功能的基础。</p><figure class="lb lc ld le fd ij"><div class="bz dy l di"><div class="lo lp l"/></div></figure><p id="9f8b" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">首先，不要和这里的<code class="du kx ky kz la b">class</code>关键词混淆。这不是严格意义上的 OOP 类(我们也不允许实例化它——通过第 19 行),它只是帮助我们隐藏信息。我不想暴露我的函数的内部，它不是供公众使用的。封装正在被拯救。</p><p id="8055" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们使用了<em class="jt">反射</em> (第 4 行)的很酷的 PHP <a class="ae iu" href="https://www.php.net/manual/en/book.reflection.php" rel="noopener ugc nofollow" target="_blank">特性，它提供了一些关于正在使用的东西的元信息，例如我们的函数有多少个参数。这也使得用一些参数调用我们的函数成为可能(第 16 行)。</a></p><p id="ad5f" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们基本的 curry 函数在这里是作为私有方法实现的。public 方法只是提供了一个清晰的接口，做了一些准备。<code class="du kx ky kz la b">_curry</code>可能是一个递归函数，这意味着它会调用自己，但我们不为此而烦恼。我们只是让用户在需要时调用它(第 14 行)。在我们的例子中，直到所有的参数都被提供。如果没有丢失任何东西，那么就用收集到的参数调用原始函数，并返回结果(第 16 行)。</p><p id="390c" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">剩下的只是 PHP mambo jambo:我们如何通过参数列表传递数据，以及如何用箭头函数捕获上下文(第 14 行)。同样在这一行中，我们声明我们不知道下一次将有多少参数被传递给我们的函数，但是无论提供了什么，只要用数组解包<code class="du kx ky kz la b">...</code>操作符将它转发给我们的私有 curry weightlifter 就行，我们不点名地调用它。</p><p id="6c24" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们的函数在那里停止执行，只继续收集原始函数的参数，如果它们被提供的话。因为它是使用我们的全感知私有函数来实现的，所以它可以重新检查所有参数是否都可用，然后最终调用该函数。</p><p id="676e" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">然而这并不是函数在 FP 中实现的方式，而是我们在 PHP 中实现一个基本 FP 函数的方式。无论我们用什么狡猾的方法来实现这些功能，它们都是相当短的、可测试的，并且它们的内部结构永远不会再出现。希望我们永远不需要接触这个部件，但是我们可以在 FP 的日常业务中愉快地使用它，知道它只做一件事，而且做得对。</p><p id="b9c5" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">您可以改进这个功能，或者根据您的需要进行定制。一如既往，最重要的不是一个东西是如何实现的，而是它定义了什么接口，给出了什么保证，或者遵守了什么法律。</p><p id="ec82" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这就够了。确保你有一个可用的<code class="du kx ky kz la b">curry</code>版本，根据提供的用例进行测试，因为从现在开始我们会大量使用它。</p><p id="f285" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><em class="jt">在</em> <a class="ae iu" href="https://auxiliaire.medium.com/function-composition-functional-programming-in-php-part-3-56ff7152c20a" rel="noopener"> <em class="jt">的下一篇文章</em> </a> <em class="jt">中，我将谈论函数组合，我们如何以一种干净的方式将几个函数组合成一个函数，以及模块，我们可以使用模块来更好地组织我们的代码，同时仍然具有封装的好处，所以敬请关注！</em></p></div></div>    
</body>
</html>