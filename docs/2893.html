<html>
<head>
<title>Understanding Factory Method Design Pattern</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">理解工厂方法设计模式</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/understanding-factory-method-design-pattern-4d7ba8f0dfc4?source=collection_archive---------3-----------------------#2021-05-23">https://medium.com/nerd-for-tech/understanding-factory-method-design-pattern-4d7ba8f0dfc4?source=collection_archive---------3-----------------------#2021-05-23</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/6de5632634228fc08e0cf171a9a643ca.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*1Q0zPMeKIO_YXxoC"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">伯明翰博物馆信托基金会在<a class="ae iu" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="9131" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">工厂方法模式也称为虚拟构造器，属于创造性设计模式。这种模式的主要目的是为创建对象创建一个抽象类(也称为工厂)。因此，对象实例化是由其子类完成的。此外，您可以使用接口作为工厂，而不是抽象类。因此，如果您使用 interface 作为工厂，它的子类必须为对象实例化实现它们自己的工厂方法。</p><p id="4d91" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在我的<a class="ae iu" href="https://nisal-pubudu.medium.com/introduction-to-design-patterns-understanding-singleton-design-pattern-5a4d49960444" rel="noopener"> <em class="jt">上一篇文章</em> </a>中，我已经用一些实际例子解释了关于单例设计模式。如果您仔细阅读了那篇文章，您可能会记得我强调了这两种模式之间的区别。那就是，<em class="jt">“如果你想在创建实例时接受任何参数，你应该使用工厂设计模式，而不是 Singleton。”</em></p><p id="1424" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">所以，当你使用工厂方法模式时，你必须总是使用参数来决定你想要得到哪个实例。但是，如果有必要，您仍然可以使用无参数构造函数。</p><p id="6c05" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">另一个区别是，Singleton 模式确保您总是得到您正在检索的任何类型的相同实例，但是工厂方法模式通常为您提供每种类型的不同实例。</p><h1 id="7756" class="ju jv hi bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">工厂方法模式的用例</h1><p id="f559" class="pw-post-body-paragraph iv iw hi ix b iy ks ja jb jc kt je jf jg ku ji jj jk kv jm jn jo kw jq jr js hb bi translated">在这一章中，我将通过一个使用 Java 的实际例子来解释如何应用工厂方法模式。</p><p id="fc84" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">假设有一家卖快餐的餐馆。在这家餐馆里，他们有几种快餐，如正餐、饮料、沙拉和甜点。然而，如果顾客想要，他们可以购买组合食品(不同食品的集合)。组合有三个不同的类别，名为，建兴组合，家庭组合和大型组合。根据套餐的预算，每个套餐包含不同类型的食物。</p><figure class="ky kz la lb fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es kx"><img src="../Images/6d5d037a9ff5c1babce5e79a9a718e9c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hySGjVXusVZDZb6seLwevQ.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">图像:组合类型</figcaption></figure><p id="6338" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">下面的图示将为您提供该实现的总体概述</p><figure class="ky kz la lb fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lc"><img src="../Images/59c3c6175f4de382ae0d493b397a76c1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*werYVrswLk4SHo_wiMK0ew.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">图:实施概述</figcaption></figure><p id="bb66" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">让我们看看如何一步一步地实现这个用例。</p><h2 id="27eb" class="ld jv hi bd jw le lf lg ka lh li lj ke jg lk ll ki jk lm ln km jo lo lp kq lq bi translated">步骤 01</h2><figure class="ky kz la lb fd ij"><div class="bz dy l di"><div class="lr ls l"/></div></figure><p id="15d6" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在第一步中，我创建了一个名为<strong class="ix hj">“regular orders”</strong>的抽象类。这个类包含一个名为<strong class="ix hj">“打印顺序”</strong>的抽象方法。正如我上面提到的，餐厅有几种食物。因此，这些食物项目中的每一个都应该有一个单独的类，并必须实现作为扩展<strong class="ix hj">" regular order "</strong>类的结果的<strong class="ix hj"> "printOrder" </strong>方法。之所以将<strong class="ix hj">【regular order】</strong>类扩展为这 4 个类，是因为它们都是可以单独订购的常规食品。</p><figure class="ky kz la lb fd ij"><div class="bz dy l di"><div class="lr ls l"/></div></figure><figure class="ky kz la lb fd ij"><div class="bz dy l di"><div class="lr ls l"/></div></figure><blockquote class="lt lu lv"><p id="09d7" class="iv iw jt ix b iy iz ja jb jc jd je jf lw jh ji jj lx jl jm jn ly jp jq jr js hb bi translated">沙拉和甜点也有自己的类别，如上两类。</p></blockquote><h2 id="2265" class="ld jv hi bd jw le lf lg ka lh li lj ke jg lk ll ki jk lm ln km jo lo lp kq lq bi translated">步骤 02</h2><figure class="ky kz la lb fd ij"><div class="bz dy l di"><div class="lr ls l"/></div></figure><p id="50fb" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在这一步中，我创建了名为<strong class="ix hj">“Combos”</strong>的抽象类，它必须由其他 3 个名为、Lite-Combo、Family-Combo 和 Mega-Combo 的子类继承。如你所见，这个抽象类还包含一个名为<strong class="ix hj">“combo details”的抽象方法因此，这 3 个类都应该在它们的类中实现那个方法。</strong></p><figure class="ky kz la lb fd ij"><div class="bz dy l di"><div class="lr ls l"/></div></figure><figure class="ky kz la lb fd ij"><div class="bz dy l di"><div class="lr ls l"/></div></figure><figure class="ky kz la lb fd ij"><div class="bz dy l di"><div class="lr ls l"/></div></figure><p id="f6ee" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">正如您所看到的，所有 3 个类都在它们内部实现了<strong class="ix hj">“combo details”</strong>方法。该方法负责通过创建它们的对象来添加属于每个组合的所有食品。因此，如果餐馆想要在他们的菜单中添加一个新的组合，我们唯一要做的就是为这个特定的组合创建一个类，并扩展<strong class="ix hj"> "Combos" </strong>类。</p><h2 id="cb83" class="ld jv hi bd jw le lf lg ka lh li lj ke jg lk ll ki jk lm ln km jo lo lp kq lq bi translated">步骤 03</h2><figure class="ky kz la lb fd ij"><div class="bz dy l di"><div class="lr ls l"/></div></figure><p id="5736" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在这一步中，我已经实现了<strong class="ix hj">“combo creator”</strong>类。这个类负责根据<strong class="ix hj">“combo code”返回相关的包</strong>为了保存代码，我为此实现了一个枚举。</p><figure class="ky kz la lb fd ij"><div class="bz dy l di"><div class="lr ls l"/></div></figure><h2 id="af1d" class="ld jv hi bd jw le lf lg ka lh li lj ke jg lk ll ki jk lm ln km jo lo lp kq lq bi translated">步骤 04</h2><figure class="ky kz la lb fd ij"><div class="bz dy l di"><div class="lr ls l"/></div></figure><p id="1ee0" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">作为最后一步，我已经实现了<strong class="ix hj">“hot meal application”</strong>类。所以，在这里你可以将与你想要的组合相关的组合代码传递给<strong class="ix hj"> "Combos" </strong>类的实例。在<strong class="ix hj">“print order”</strong>方法的帮助下，它会给出你所购买的组合的详细信息。</p><figure class="ky kz la lb fd ij er es paragraph-image"><div class="er es lz"><img src="../Images/ee8e123f062625450cdff3aac6c5fe88.png" data-original-src="https://miro.medium.com/v2/resize:fit:1054/format:webp/1*p9j-efAItFrf1JMLOzzTrg.png"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">图:工厂方法模式实现的结果</figcaption></figure><p id="29d6" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如果你有兴趣，你可以使用下面的 GitHub 链接来看看我的工厂方法模式的完整实现。</p><div class="ma mb ez fb mc md"><a href="https://github.com/nisal-kumara/krish-lp-training/tree/master/Design%20Patterns/FactoryMethod" rel="noopener  ugc nofollow" target="_blank"><div class="me ab dw"><div class="mf ab mg cl cj mh"><h2 class="bd hj fi z dy mi ea eb mj ed ef hh bi translated">尼萨尔-库马拉/克里希-LP-培训</h2><div class="mk l"><h3 class="bd b fi z dy mi ea eb mj ed ef dx translated">在 GitHub 上创建一个帐户，为 nisal-kumara/krish-lp-training 的发展做出贡献。</h3></div><div class="ml l"><p class="bd b fp z dy mi ea eb mj ed ef dx translated">github.com</p></div></div><div class="mm l"><div class="mn l mo mp mq mm mr io md"/></div></div></a></div><p id="cfd9" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">所以，这是我的文章的结尾，我希望你喜欢它。快乐编码👨‍💻。</p></div><div class="ab cl ms mt gp mu" role="separator"><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx"/></div><div class="hb hc hd he hf"><h2 id="d07b" class="ld jv hi bd jw le lf lg ka lh li lj ke jg lk ll ki jk lm ln km jo lo lp kq lq bi translated">参考</h2><figure class="ky kz la lb fd ij"><div class="bz dy l di"><div class="mz ls l"/></div></figure><div class="ma mb ez fb mc md"><a href="https://stackabuse.com/factory-method-design-pattern-in-java/" rel="noopener  ugc nofollow" target="_blank"><div class="me ab dw"><div class="mf ab mg cl cj mh"><h2 class="bd hj fi z dy mi ea eb mj ed ef hh bi translated">Java 中的工厂方法设计模式</h2><div class="mk l"><h3 class="bd b fi z dy mi ea eb mj ed ef dx translated">简介设计模式是日常编程中使用的编程方法的集合。他们…</h3></div><div class="ml l"><p class="bd b fp z dy mi ea eb mj ed ef dx translated">stackabuse.com</p></div></div></div></a></div></div></div>    
</body>
</html>