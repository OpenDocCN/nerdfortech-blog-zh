<html>
<head>
<title>Sorting extension in Swift</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Swift中的排序扩展</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/sorting-extension-in-swift-438ed6f23ce1?source=collection_archive---------5-----------------------#2021-04-01">https://medium.com/nerd-for-tech/sorting-extension-in-swift-438ed6f23ce1?source=collection_archive---------5-----------------------#2021-04-01</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/a95c0099d4597fdf21d1bdfba23d06a8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Ty4KjGGmrQnrH-MoGvyWrA.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">格伦·卡斯滕斯-彼得斯在Unsplash上的照片</figcaption></figure></div><div class="ab cl iv iw gp ix" role="separator"><span class="iy bw bk iz ja jb"/><span class="iy bw bk iz ja jb"/><span class="iy bw bk iz ja"/></div><div class="hb hc hd he hf"><p id="48ea" class="pw-post-body-paragraph jc jd hi je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hb bi translated">在iOS开发中，我们多次遇到对数组进行排序的任务，然后我们在应用程序中任何需要的地方编写如下代码。<em class="ka">注意到</em> <strong class="je hj"> <em class="ka">动物</em> </strong> <em class="ka">的数组还没有定义，动物的结构也没有定义，但是不要担心，它们将在本文的后面被指定。</em></p><pre class="kb kc kd ke fd kf kg kh ki aw kj bi"><span id="bf26" class="kk kl hi kg b fi km kn l ko kp">animals.sorted { (left, right) -&gt; Bool in {<br/>    return left.id &gt; right.id<br/>}</span></pre></div><div class="ab cl iv iw gp ix" role="separator"><span class="iy bw bk iz ja jb"/><span class="iy bw bk iz ja jb"/><span class="iy bw bk iz ja"/></div><div class="hb hc hd he hf"><h2 id="7931" class="kk kl hi bd kq kr ks kt ku kv kw kx ky jn kz la lb jr lc ld le jv lf lg lh li bi translated">1.问题是</h2><p id="f6de" class="pw-post-body-paragraph jc jd hi je b jf lj jh ji jj lk jl jm jn ll jp jq jr lm jt ju jv ln jx jy jz hb bi translated">如果不是按<strong class="je hj"> <em class="ka"> id </em> </strong>对动物数组进行排序，而是现在需要按<strong class="je hj"> <em class="ka">名称</em> </strong>或动物拥有的任何其他属性进行排序呢？好吧，我们可能会重复相同的代码，但是通过所需的属性来改变id。</p><pre class="kb kc kd ke fd kf kg kh ki aw kj bi"><span id="16c8" class="kk kl hi kg b fi km kn l ko kp">animals.sorted { (left, right) -&gt; Bool in {<br/>    return left.name &gt; right.name<br/>}</span><span id="aa74" class="kk kl hi kg b fi lo kn l ko kp">animals.sorted { (left, right) -&gt; Bool in {<br/>    return left.age &gt; right.age<br/>}</span></pre><p id="6a36" class="pw-post-body-paragraph jc jd hi je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hb bi translated">随着我们向项目中添加更多具有多个属性的结构，这个简单的任务开始变得乏味，并且在出现错误的情况下更难调试。一个更干净的方法是，创建一个数组的扩展，允许我们根据任何属性对任何数组进行排序。</p></div><div class="ab cl iv iw gp ix" role="separator"><span class="iy bw bk iz ja jb"/><span class="iy bw bk iz ja jb"/><span class="iy bw bk iz ja"/></div><div class="hb hc hd he hf"><h2 id="9cd3" class="kk kl hi bd kq kr ks kt ku kv kw kx ky jn kz la lb jr lc ld le jv lf lg lh li bi translated">2.我们想要达到的目标</h2><p id="797a" class="pw-post-body-paragraph jc jd hi je b jf lj jh ji jj lk jl jm jn ll jp jq jr lm jt ju jv ln jx jy jz hb bi translated">那么，我们如何做到这一点呢？让我们首先定义我们将在本文中使用的结构动物，它的属性<em class="ka"> id </em>为整数，属性<em class="ka"> name </em>为字符串。</p><pre class="kb kc kd ke fd kf kg kh ki aw kj bi"><span id="89e8" class="kk kl hi kg b fi km kn l ko kp">struct Animal: CustomStringConvertible {<br/>    let id: Int<br/>    let name: String<br/>    <br/>    var description: String {<br/>        return "Animal(id: \(id), name: \(name))"<br/>    }<br/>}</span></pre><p id="0cae" class="pw-post-body-paragraph jc jd hi je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hb bi translated">现在，让我们找到一种更好的方法来编写我们看到的第一段代码，不是实现，而是当我们需要对任何类型的数组进行排序时，我们希望代码看起来是什么样子。</p><pre class="kb kc kd ke fd kf kg kh ki aw kj bi"><span id="9f47" class="kk kl hi kg b fi km kn l ko kp">// 1. Define the array of animals<br/>let animals = [<br/>    Animal(id: 1, name: "platypus"),<br/>    Animal(id: 2, name: "chicken"),<br/>    Animal(id: 3, name: "dog")<br/>]</span><span id="f5d9" class="kk kl hi kg b fi lo kn l ko kp">// 2. This is the way we's like to sort them, by id<br/>animals.sorted(by: { $0.id })</span><span id="7832" class="kk kl hi kg b fi lo kn l ko kp">// 3. or rather by name<br/>animals.sorted(by: { $0.name })</span></pre><p id="4768" class="pw-post-body-paragraph jc jd hi je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hb bi translated">请记住，我们不想将这种行为特别附加到动物或任何其他已定义的结构/类，相反，这种解决方案应该是通用的，并且在本示例之外的任何其他上下文中也可以重用。</p></div><div class="ab cl iv iw gp ix" role="separator"><span class="iy bw bk iz ja jb"/><span class="iy bw bk iz ja jb"/><span class="iy bw bk iz ja"/></div><div class="hb hc hd he hf"><h2 id="0d5b" class="kk kl hi bd kq kr ks kt ku kv kw kx ky jn kz la lb jr lc ld le jv lf lg lh li bi translated">3.解决方案</h2><p id="2810" class="pw-post-body-paragraph jc jd hi je b jf lj jh ji jj lk jl jm jn ll jp jq jr lm jt ju jv ln jx jy jz hb bi translated">因为该方法是任何类型的数组扩展，所以让我们创建一个通用函数，它可以处理任何"<em class="ka"> sortable </em>"对象，我所说的sortable是指任何符合协议<em class="ka"> Comparable、</em>的东西，这样我们就知道哪些元素比其他元素大，即使它们不是具体的类型(T)。此外，这个函数应该返回一个新的排序数组，这样我们就可以重用Swift的“sorted()”内置函数。</p><pre class="kb kc kd ke fd kf kg kh ki aw kj bi"><span id="7cb4" class="kk kl hi kg b fi km kn l ko kp">extension Array {<br/>    func sorted&lt;T: Comparable&gt;() -&gt; Array {<br/>        // Here, our nice code<br/>    }<br/>}</span></pre><p id="2ea6" class="pw-post-body-paragraph jc jd hi je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hb bi translated">这个函数需要接收什么参数？这当然是一个闭包，但是这个闭包需要接受一个类型为<em class="ka">元素</em>的对象，并返回另一个类型为<em class="ka"> T </em>的对象。请注意，我将闭包命名为<strong class="je hj"> <em class="ka"> compare </em> </strong>，因为它是一个在比较每一对值时将对数组中的每个元素执行的块。</p><pre class="kb kc kd ke fd kf kg kh ki aw kj bi"><span id="7e54" class="kk kl hi kg b fi km kn l ko kp">func sorted&lt;T: Comparable&gt;(by compare: (Element) -&gt; T) -&gt; Array {<br/>    // Here, our nice code<br/>}</span></pre><p id="7425" class="pw-post-body-paragraph jc jd hi je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hb bi translated">我们可以使用带有一对元素的<em class="ka">比较</em>块，根据同一个块<em class="ka">比较的结果来检查哪一个大于另一个。</em>例如:</p><pre class="kb kc kd ke fd kf kg kh ki aw kj bi"><span id="0710" class="kk kl hi kg b fi km kn l ko kp">// We can now compare using &gt; or &lt; on the results of compare()</span><span id="0d58" class="kk kl hi kg b fi lo kn l ko kp">compare(array.first!) &gt; compare(array.last)</span><span id="9035" class="kk kl hi kg b fi lo kn l ko kp">// NOTE: We don't really know what the result of this operation is, because it's a generic array of T, but what we do know, is that <em class="ka">first</em> and <em class="ka">last</em> elements can be compared, because T is a comformance of the <em class="ka">Comparable </em>protocol</span><span id="5de2" class="kk kl hi kg b fi lo kn l ko kp">compare(array[0]) will give &lt;T: Comparable&gt; value in return<br/>compare(array[1]) will give another &lt;T: Comparable&gt; value in return</span></pre><p id="c9a6" class="pw-post-body-paragraph jc jd hi je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hb bi translated">填充函数后，到目前为止，我们已经有了这段代码，看起来很整洁，并且(不完全)按照我们的期望…按照任何给定的属性对任何类型的元素数组进行排序。</p><pre class="kb kc kd ke fd kf kg kh ki aw kj bi"><span id="b65b" class="kk kl hi kg b fi km kn l ko kp">func sorted&lt;T: Comparable&gt;(by compare: (Element) -&gt; T) -&gt; Array {<br/>   return self.sorted {<br/>        // BUG 1. We are forcing the comparison to be &gt;<br/>        compare($0) &gt; compare($1)<br/>    }<br/>}</span></pre><p id="ceee" class="pw-post-body-paragraph jc jd hi je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hb bi translated">然而，正如评论<em class="ka"> BUG 1 </em>。说，我们对所有的排序调用强制进行大于或小于的比较，但这不是应该的工作方式，有时我们需要一个动物数组升序排序，但也需要一个用户数组降序排序。这就是为什么我们需要添加一个新的布尔参数叫做<em class="ka"> ascendant(例子中标注为</em><strong class="je hj"><em class="ka">ASC</em></strong><em class="ka">)</em>其<em class="ka"> </em>默认值为true <em class="ka">。</em></p><p id="7d2a" class="pw-post-body-paragraph jc jd hi je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hb bi translated">这是整个扩展最终的样子:</p><figure class="kb kc kd ke fd ij"><div class="bz dy l di"><div class="lp lq l"/></div></figure><h2 id="1791" class="kk kl hi bd kq kr ks kt ku kv kw kx ky jn kz la lb jr lc ld le jv lf lg lh li bi translated">奖金</h2><p id="0b3c" class="pw-post-body-paragraph jc jd hi je b jf lj jh ji jj lk jl jm jn ll jp jq jr lm jt ju jv ln jx jy jz hb bi translated">在Swift的新版本中，我们可以使用这个完全相同的扩展，但是我们可以发送一个属性KeyPath，而不是发送一个闭包，好的一点是，价格相同，我们不需要额外的代码。因此，我们可以这样排序数组:</p><pre class="kb kc kd ke fd kf kg kh ki aw kj bi"><span id="b491" class="kk kl hi kg b fi km kn l ko kp">// KeyPath for Animal.name<br/>animals.sorted(by: \.name)</span><span id="1cd1" class="kk kl hi kg b fi lo kn l ko kp">// KeyPath for Animal.id<br/>animals.sorted(by: \.id, asc = false)</span></pre><p id="ae9b" class="pw-post-body-paragraph jc jd hi je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hb bi translated">这个排序包装器扩展的另一个很棒的用例是当结构有嵌套对象时。假设您有动物和人，其中动物属于一个人，并且您希望按照动物所属的人的属性对动物进行排序。例如:</p><pre class="kb kc kd ke fd kf kg kh ki aw kj bi"><span id="f35b" class="kk kl hi kg b fi km kn l ko kp">// CREATE THE STRUCTURES</span><span id="41dc" class="kk kl hi kg b fi lo kn l ko kp">struct Person {<br/>    let id: Int<br/>    let name: String<br/>}</span><span id="77eb" class="kk kl hi kg b fi lo kn l ko kp">struct Animal {<br/>    let id: Int<br/>    let name: String<br/>    let owner: Person<br/>}</span><span id="c401" class="kk kl hi kg b fi lo kn l ko kp">let person1 = Person(id: 3, name: "bob")<br/>let person2 = Person(id: 2, name: "alice")<br/>let person3 = Person(id: 1, name: "charlie")</span><span id="d0c1" class="kk kl hi kg b fi lo kn l ko kp">let animals = [<br/>    Animal(id: 1, name: "dog", owner: person1),<br/>    Animal(id: 2, name: "cat", owner: person2),<br/>    Animal(id: 3, name: "turtle", owner: person3)<br/>]</span><span id="0895" class="kk kl hi kg b fi lo kn l ko kp">// SORT THE ARRAYS</span><span id="54a0" class="kk kl hi kg b fi lo kn l ko kp">// sort animals by the owner's id<br/>animals.sorted(by: { $0.owner.id })</span><span id="5336" class="kk kl hi kg b fi lo kn l ko kp">// =&gt; animal: 3-turtle, person: 1-charlie<br/>// =&gt; animal: 2-cat, person: 2-alice<br/>// =&gt; animal: 1-dog, person: 3-bob</span><span id="895b" class="kk kl hi kg b fi lo kn l ko kp">// sort animals by the owner's name<br/>animals.sorted(by: { $0.owner.name })</span><span id="4993" class="kk kl hi kg b fi lo kn l ko kp">// =&gt; animal: 2-cat, person: 2-alice<br/>// =&gt; animal: 1-dog, person: 3-bob<br/>// =&gt; animal: 3-turtle, person: 1-charlie</span></pre></div><div class="ab cl iv iw gp ix" role="separator"><span class="iy bw bk iz ja jb"/><span class="iy bw bk iz ja jb"/><span class="iy bw bk iz ja"/></div><div class="hb hc hd he hf"><p id="d956" class="pw-post-body-paragraph jc jd hi je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hb bi translated"><em class="ka">感谢阅读。我希望你喜欢这个小教程，如果它对你有用，不要害羞👏关于这篇文章。下次见。</em></p></div></div>    
</body>
</html>