<html>
<head>
<title>How to inject variables in Kubernetes manifest with Azure Pipelines?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何用Azure管道在Kubernetes manifest中注入变量？</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/how-to-inject-variables-in-kubernetes-manifest-with-azure-pipelines-e598755be9b?source=collection_archive---------0-----------------------#2020-03-12">https://medium.com/nerd-for-tech/how-to-inject-variables-in-kubernetes-manifest-with-azure-pipelines-e598755be9b?source=collection_archive---------0-----------------------#2020-03-12</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="a58e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">最近，我接下了为Juntoz.com平台第3版创建基础的任务，包括使用nodejs、docker容器和kubernetes实现完全的云原生。</p><p id="0681" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">而且，作为我最初开发的一部分，我发现自己遇到了K8S清单的一个常见问题:将同一个清单应用于两个环境(暂存和生产)，但使用不同的设置(例如，在暂存中，我只需要一个副本，而在生产中，我需要两个副本)。</p><p id="a4a3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">最常用的解决方案之一是使用<code class="du jd je jf jg b">Helm</code>，我还不想去那里，因为我刚刚进入这个容器和编排器的全新世界。</p><p id="67c0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在阅读了关于<code class="du jd je jf jg b">Kustomize</code>的文章后，我决定使用一个对我非常有效的老方法:替换文本变量。它易于理解，易于实施，并且非常有效。</p><p id="c164" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这是可能的，因为我们的构建和部署都在Azure管道中运行，所以我们有一个先前的层，在将清单应用到集群之前，我们可以在那里进行这些替换。</p><h1 id="89d4" class="jh ji hi bd jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke bi translated">步伐</h1><p id="616a" class="pw-post-body-paragraph if ig hi ih b ii kf ik il im kg io ip iq kh is it iu ki iw ix iy kj ja jb jc hb bi translated">每个管道都有一个文件<code class="du jd je jf jg b">azure-pipelines.yml</code>，它定义了管道将要执行的步骤。下面是我们将使用的示例。</p><pre class="kk kl km kn fd ko jg kp kq aw kr bi"><span id="3bf4" class="ks ji hi jg b fi kt ku l kv kw"><br/>variables:<br/>- group: Docker Vars<br/>- name: image-name<br/>  value: my-image<br/>- name: image-tag<br/>  value: $(Build.BuildNumber)</span><span id="cbd4" class="ks ji hi jg b fi kx ku l kv kw">stages:<br/>- stage: Build<br/>  jobs:<br/>  - job: Build<br/>    pool:<br/>      vmImage: Ubuntu-16.04<br/>    steps:<br/>    - task: Docker@2<br/>      inputs:<br/>        command: login<br/>        containerRegistry: $(docker-container-registry)<br/>    - task: Docker@2<br/>      inputs:<br/>        command: buildAndPush<br/>        repository: $(image-name)<br/>        tags: $(image-tag)<br/>    - task: CopyFiles@2<br/>      inputs:<br/>        contents: $(build.sourcesDirectory)/k8s*.*<br/>        targetFolder: $(build.artifactStagingDirectory)<br/>    - task: PublishBuildArtifacts@1<br/>      inputs:<br/>        pathtoPublish: $(build.artifactStagingDirectory)<br/>        artifactName: drop<br/>- stage: Staging<br/>  jobs:<br/>  - deployment: Staging<br/>    variables:<br/>    - name: kub-pod-instancecount<br/>      value: 1<br/>    - name: env-name<br/>      value: Staging<br/>    - name: log-level<br/>      value: info<br/>    pool:<br/>      vmImage: Ubuntu-16.04<br/>    environment: STG<br/>    strategy:<br/>      runOnce:<br/>        deploy:<br/>          steps:<br/>          - task: qetza.replacetokens.replacetokens-task.replacetokens@3<br/>            displayName: Replace tokens in **/*<br/>            inputs:<br/>              rootDirectory: $(Pipeline.Workspace)/drop<br/>              targetFiles: '**/*.yml'<br/>              keepToken: true<br/>              tokenPrefix: __<br/>              tokenSuffix: __<br/>          - task: Kubernetes@1<br/>            displayName: kubectl apply<br/>            inputs:<br/>              connectionType: Azure Resource Manager<br/>              azureSubscriptionEndpoint: my-azure<br/>              azureResourceGroup: my-resource-group<br/>              kubernetesCluster: my-cluster<br/>              command: apply<br/>              arguments: -f $(Pipeline.Workspace)/drop<br/>- stage: Production<br/>  jobs:<br/>  - deployment: Production<br/>    variables:<br/>    - name: kub-pod-instancecount<br/>      value: 2<br/>    - name: env-name<br/>      value: Production<br/>    - name: log-level<br/>      value: info<br/>    pool:<br/>      vmImage: Ubuntu-16.04<br/>    environment: PROD<br/>    strategy:<br/>      runOnce:<br/>        deploy:<br/>          steps:<br/>          - task: qetza.replacetokens.replacetokens-task.replacetokens@3<br/>            displayName: Replace tokens in **/*<br/>            inputs:<br/>              rootDirectory: $(Pipeline.Workspace)/drop<br/>              targetFiles: '**/*.yml'<br/>              keepToken: true<br/>              tokenPrefix: __<br/>              tokenSuffix: __<br/>          - task: Kubernetes@1<br/>            displayName: kubectl apply<br/>            inputs:<br/>              connectionType: Azure Resource Manager<br/>              azureSubscriptionEndpoint: my-azure<br/>              azureResourceGroup: my-resource-group<br/>              kubernetesCluster: my-cluster<br/>              command: apply<br/>              arguments: -f $(Pipeline.Workspace)/drop</span></pre><p id="6219" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如您所见，管道在所有三个阶段都非常简单:构建、试运行和生产。</p><p id="6434" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><code class="du jd je jf jg b">Build</code>阶段创建Docker映像并将其推送到注册中心，它还将发布<code class="du jd je jf jg b">k8s-apply.yml</code>文件作为管道工件，因此它在部署阶段是可见的。</p><p id="2508" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><code class="du jd je jf jg b">Staging</code>阶段执行部署到暂存环境中，而<code class="du jd je jf jg b">Production</code>阶段在其对应的环境中执行相同的操作。</p><p id="cc42" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这是我们想要应用的kubernetes清单(<code class="du jd je jf jg b">k8s-apply.yml</code>)。</p><pre class="kk kl km kn fd ko jg kp kq aw kr bi"><span id="a68c" class="ks ji hi jg b fi kt ku l kv kw">apiVersion: apps/v1<br/>kind: Deployment<br/>metadata:<br/>  name: my-deploy<br/>spec:<br/>  replicas: __kub-pod-instancecount__<br/>  selector:<br/>    matchLabels:<br/>      app: my-app<br/>  template:<br/>    metadata:<br/>      labels:<br/>        app: my-app<br/>    spec:<br/>      containers:<br/>      - name: my-container<br/>        image: __docker-container-url__/__image-name__:__image-tag__<br/>        ports:<br/>        - containerPort: 3000<br/>        env:<br/>        - name: API_PORT<br/>          value: "3000"<br/>        - name: LOG_LEVEL<br/>          value: __log-level__<br/>        - name: RUN_ENV<br/>          value: __env-name__<br/>---<br/>apiVersion: v1<br/>kind: Service<br/>metadata:<br/>  name: my-svc<br/>spec:<br/>  selector:<br/>    app: my-app<br/>  ports:<br/>    - port: 3000<br/>      targetPort: 3000</span></pre><p id="88ad" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">清单是一个常规清单，其特殊性在于它包含几个用“__”括起来的变量名。</p><p id="c482" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">神奇的事情发生在任务<code class="du jd je jf jg b">qetza.replacetokens.replacetokens-task.replacetokens@3</code>的每个环境的部署阶段。该任务将扫描所有的<code class="du jd je jf jg b">targetFiles</code>，并验证__(如__log-level__)包含的任何文本是否解析为变量名。如果它作为变量名匹配，那么它将把它的值写入文件，然后文件被覆盖。</p><p id="9607" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">因此，在临时部署时，清单应该以如下形式结束:</p><pre class="kk kl km kn fd ko jg kp kq aw kr bi"><span id="a250" class="ks ji hi jg b fi kt ku l kv kw">apiVersion: apps/v1<br/>kind: Deployment<br/>metadata:<br/>  name: my-deploy<br/>spec:<br/>  replicas: 1<br/>  selector:<br/>    matchLabels:<br/>      app: my-app<br/>  template:<br/>    metadata:<br/>      labels:<br/>        app: my-app<br/>    spec:<br/>      containers:<br/>      - name: my-container<br/>        image: my-registry/my-image:my-tag<br/>        ports:<br/>        - containerPort: 3000<br/>        env:<br/>        - name: API_PORT<br/>          value: "3000"<br/>        - name: LOG_LEVEL<br/>          value: info<br/>        - name: RUN_ENV<br/>          value: Staging</span></pre><p id="0f05" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在生产中，像这样:</p><pre class="kk kl km kn fd ko jg kp kq aw kr bi"><span id="1866" class="ks ji hi jg b fi kt ku l kv kw">apiVersion: apps/v1<br/>kind: Deployment<br/>metadata:<br/>  name: my-deploy<br/>spec:<br/>  replicas: 2<br/>  selector:<br/>    matchLabels:<br/>      app: my-app<br/>  template:<br/>    metadata:<br/>      labels:<br/>        app: my-app<br/>    spec:<br/>      containers:<br/>      - name: my-container<br/>        image: my-registry/my-image:my-tag<br/>        ports:<br/>        - containerPort: 3000<br/>        env:<br/>        - name: API_PORT<br/>          value: "3000"<br/>        - name: LOG_LEVEL<br/>          value: info<br/>        - name: RUN_ENV<br/>          value: Production</span></pre><h2 id="207b" class="ks ji hi bd jj ky kz la jn lb lc ld jr iq le lf jv iu lg lh jz iy li lj kd lk bi translated">变量在哪里？</h2><p id="4309" class="pw-post-body-paragraph if ig hi ih b ii kf ik il im kg io ip iq kh is it iu ki iw ix iy kj ja jb jc hb bi translated">大概你在问自己，<code class="du jd je jf jg b">__docker-container-url__</code>怎么变成了<code class="du jd je jf jg b">my-registry</code>？因为<code class="du jd je jf jg b">docker-container-url</code>是一个注册在变量组<code class="du jd je jf jg b">Docker Vars</code>中的变量，所以这个问题得到了解决。</p><p id="c302" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">变量可以在几个范围级别上定义，其中更直接的级别将覆盖最远的级别。更多信息，请查看<a class="ae ll" href="https://docs.microsoft.com/en-us/azure/devops/pipelines/process/variables?view=azure-devops&amp;tabs=yaml%2Cbatch" rel="noopener ugc nofollow" target="_blank">这个</a>。</p><p id="51d6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">额外收获:变量的一个很酷的地方是它们也可以内联扩展。如果我定义了一个变量<code class="du jd je jf jg b">my-image-prefix = jz</code>，然后定义了第二个变量<code class="du jd je jf jg b">my-image = $(my-image-prefix)-user</code>，那么任务将生成文本<code class="du jd je jf jg b">my-image = jz-user</code>。</p></div></div>    
</body>
</html>