<html>
<head>
<title>SOLID Principles in Java</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Java中的坚实原理</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/solid-principles-in-java-5cf926e44247?source=collection_archive---------2-----------------------#2021-07-10">https://medium.com/nerd-for-tech/solid-principles-in-java-5cf926e44247?source=collection_archive---------2-----------------------#2021-07-10</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div class="er es if"><img src="../Images/e211d8a5467d3cb811210d6ffe720d8f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1160/format:webp/1*c6P_q3U1Tjo4FbA7hu7TQA.png"/></div></figure><p id="34ad" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">坚实的原则基本上构成了构建面向对象、松散耦合、健壮、可维护和易于理解的应用程序的基本准则。面试中最常被问到的问题之一，让我们来看看每个问题:</p><p id="7046" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><strong class="io hj"> <em class="jk">单一责任</em> </strong>:一个类应该有且只有一个责任。我们应该只为一个目的编写、更改或维护一个类，这给了我们更干净、健壮的代码和更少的测试用例的优势，因为我们知道哪个功能包含在哪个类中，以及在发生更改时哪个类将被修改。对于ex: <br/> <code class="du jl jm jn jo b">public class Vehicle{<br/> public void printDetails() {}<br/> public double calculate() {}<br/> public void addtoDB() {}<br/>}</code></p><p id="b66b" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">上面的类有三个独立的职责:打印、计算和添加到数据库。通过应用SRP，我们可以将上面的类分成三个具有独立职责的类。</p><p id="24a2" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><strong class="io hj"><em class="jk"/></strong>:一个类应该对扩展开放，但对修改关闭，这基本上意味着我们不希望我们现有的代码被修改，导致潜在的问题或错误。其他开发人员在一些功能变化的情况下应该能够扩展我们的类和覆盖一些方法。对于ex: <br/>更好的方法是让子类根据它们的类型重写Value方法。</p><p id="b45e" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><strong class="io hj"> <em class="jk">利斯科夫替换</em> </strong>:派生类必须可替换基类。简单地说，如果类A扩展了类B，我们应该能够用A替换B，而不会破坏我们程序的行为。根据OOPS概念，继承是一个好的实践，但是Liskov原则要求在使用继承时要仔细考虑。只有当我们的超类在所有情况下都可以用子类替换时，我们才应该使用继承。<br/> For ex:经典的方矩形问题。<br/> <code class="du jl jm jn jo b">public class Rectangle {<br/> private double height;<br/> private double width;<br/> public void setHeight(double h) { height = h; }<br/> public void setWidht(double w) { width = w; }<br/> //getters and calculateArea method<br/>}<br/>public class Square extends Rectangle {<br/> public void setHeight(double h) {<br/> super.setHeight(h);<br/> super.setWidth(w);<br/> }<br/> public void setWidth(double h) {<br/> super.setHeight(h);<br/> super.setWidth(w);<br/> }<br/>}<br/></code>由于其明确的基类Rectangle显然不能被square子类替换，因为Square具有高度和宽度相等的约束，所以用Square类替换Rectangle类会中断LSP。</p><p id="a807" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><strong class="io hj"><em class="jk"/></strong>:不应该要求任何人在他们的类中实现他们不会使用的方法。较大的接口应该分成较小的接口。这确保了实现类只需要关心对它们有用的方法。这给了我们只使用所需功能的灵活性。对于ex: <br/> <code class="du jl jm jn jo b">public interface Vehicle {<br/> public void drive();<br/> public void stop();<br/> public void openDoors();<br/>}<br/>public class Bike implements Vehicle {<br/> // Can be implemented<br/> public void drive() {...}<br/> public void stop() {...}<br/> // Can not be implemented<br/> public void openDoors() {...}<br/>}<br/></code>对于一个自行车类来说，实现openDoors方法没有意义。这应该通过将车辆接口分解成多个具有可能功能的更小的接口来解决，这样就不会有类被迫实现不需要的方法。</p><p id="6069" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><strong class="io hj"> <em class="jk">依赖倒置</em> </strong>:一个类应该依赖抽象(接口和抽象类)而不是具体化(类)。上面的代码适用于一种引擎，但是如果有两种引擎，比如柴油和汽油，那就意味着要修改我们的类，这不是个好主意。<br/>这可以通过增加一个抽象层来解决，所以car现在不是直接依赖于Engine而是依赖于EngineInterface。PetrolEngine或DieselEngine类实现了这个接口，我们可以将它们中的任何一个连接到Car类:</p><p id="7aec" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">希望这篇文章给出了坚实的原则好主意。快乐学习:)<br/>。<br/>。<br/>引用:<a class="ae jp" href="https://www.educative.io/edpresso/what-are-the-solid-principles-in-java?aid=5082902844932096&amp;utm_source=google&amp;utm_medium=cpc&amp;utm_campaign=edpresso-dynamic&amp;utm_term=&amp;utm_campaign=Dynamic+-+Edpresso&amp;utm_source=adwords&amp;utm_medium=ppc&amp;hsa_acc=5451446008&amp;hsa_cam=8092184362&amp;hsa_grp=86276435689&amp;hsa_ad=397226000870&amp;hsa_src=g&amp;hsa_tgt=aud-470210443636:dsa-837376625453&amp;hsa_kw=&amp;hsa_mt=b&amp;hsa_net=adwords&amp;hsa_ver=3&amp;gclid=Cj0KCQjwxJqHBhC4ARIsAChq4asdhLfFjckL-xdC-l0Lfitrm9aJ9gezJtP6D1YRPFT4jrqUtb9gQm0aAjWQEALw_wcB" rel="noopener ugc nofollow" target="_blank"> educative.io </a>，<a class="ae jp" href="https://howtodoinjava.com/best-practices/solid-principles/" rel="noopener ugc nofollow" target="_blank"> howToDoInJava </a></p></div></div>    
</body>
</html>