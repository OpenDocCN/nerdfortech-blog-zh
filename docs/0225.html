<html>
<head>
<title>Cassandra internals</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Cassandra内部</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/cassandra-internals-38e279c72c3e?source=collection_archive---------0-----------------------#2020-07-26">https://medium.com/nerd-for-tech/cassandra-internals-38e279c72c3e?source=collection_archive---------0-----------------------#2020-07-26</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="fc7f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在我之前的帖子中，我试图解释<a class="ae jd" rel="noopener" href="/@shivanshugoyal0111/pagination-in-cassandra-b7e45ec2656a"> <strong class="ih hj"> <em class="je">如何在Cassandra中实现分页？</em> </strong> </a>在这里，我们将看看如何在Cassandra中写入、读取、更新和删除数据。Cassandra是一个水平可伸缩的NoSQL数据库。</p><figure class="jg jh ji jj fd jk er es paragraph-image"><div class="er es jf"><img src="../Images/1babcfa90fbf9b3a0fcf8e99edf99f27.png" data-original-src="https://miro.medium.com/v2/resize:fit:1118/format:webp/1*6TKD2mbu5s0Tq_HlcMWRHQ.png"/></div></figure><p id="ff31" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在讨论Cassandra如何维护数据之前，我们首先需要了解一些基本术语:</p><ol class=""><li id="e783" class="jn jo hi ih b ii ij im in iq jp iu jq iy jr jc js jt ju jv bi translated"><strong class="ih hj"> CommitLog: </strong>这是Cassandra节点本地所有更改的仅附加日志。任何写入Cassandra的数据在写入memtable之前都将首先写入commitlog。它有助于在任何节点出现故障时恢复数据。CommitLog提供了数据更新操作的优化。Cassandra不需要将每次更新都刷新到磁盘，而不用考虑万一失败时的数据丢失。你可能想知道<strong class="ih hj"> <em class="je">如果Cassandra必须只将更新写到磁盘，那么为什么不直接写到表呢？</em></strong>commit log针对写入进行了优化。与按排序顺序存储行的SSTables不同，CommitLog按Cassandra处理更新的顺序存储更新。CommitLog还将所有列族的<strong class="ih hj">更改存储在一个文件</strong>中，因此当磁盘同时接收多个列族的更新时，它不需要进行大量的搜索。</li><li id="91e0" class="jn jo hi ih b ii jw im jx iq jy iu jz iy ka jc js jt ju jv bi translated"><strong class="ih hj">内存表:</strong>内存表由CQL表维护。它有一个已配置的内存大小，达到该大小后，memtable将被刷新到磁盘上一个新的STable。Memtable是一个<strong class="ih hj">内存缓存</strong>，内容存储为键/列。Memtable数据按键排序。它也有助于Cassandra的读取操作。每个CQL表只有一个<strong class="ih hj">活动的</strong>内存表，其他的也可能存在，等待被刷新。</li><li id="a129" class="jn jo hi ih b ii jw im jx iq jy iu jz iy ka jc js jt ju jv bi translated"><strong class="ih hj"> SSTable: </strong>它是一个不可变的数据文件，用来在磁盘上永久存储存储数据。每个CQL表有一个<strong class="ih hj">活动</strong>表。当一个memtable数据被刷新时，一个新的STable被创建。一个分区的数据可以跨多个表，一个表可以有多个分区的数据。排序字符串表是一个由键/值字符串对组成的文件，按键排序。一个表可以完全映射到内存中，这允许我们在不接触磁盘的情况下执行查找和扫描。</li><li id="d3fd" class="jn jo hi ih b ii jw im jx iq jy iu jz iy ka jc js jt ju jv bi translated"><strong class="ih hj">压缩:</strong>一个CQL表数据是它的memtable +它在磁盘上的所有SSTables的组合。为了有效地从CQL表中读取数据，需要将给定CQL表的所有表编译成一个表，这是通过一个称为<strong class="ih hj">压缩</strong>的过程完成的。这种压缩何时发生？有3种压缩方式:<strong class="ih hj"> a)大小分层:</strong>这是Cassandra中默认的压缩方式。当您有大量插入、少量读取的工作负载时，最好使用这种策略。<strong class="ih hj"> b) Level tiered: </strong>它最适合频繁更新现有行的读负载。<strong class="ih hj"> c)时间窗口压缩:</strong>它最适合时间序列数据和TTL。</li></ol><figure class="jg jh ji jj fd jk er es paragraph-image"><div role="button" tabindex="0" class="kc kd di ke bf kf"><div class="er es kb"><img src="../Images/ab6b0340d7e18c8bc15249d3627a4d1d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZTKaUNTNZpUKGJQEiOxGYA.png"/></div></div><figcaption class="kg kh et er es ki kj bd b be z dx translated">在时间T5，压缩发生，删除表1，2，3，并创建一个新的表(4)。它还通过减少查找表的数量来帮助Cassandra的读取路径。</figcaption></figure><p id="38c5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">5.<strong class="ih hj"> NTP: </strong>在这里讨论变得很重要。这是一个<a class="ae jd" href="https://en.wikipedia.org/wiki/Network_Time_Protocol" rel="noopener ugc nofollow" target="_blank">网络协议</a>用于机器之间的时钟同步。如果未启用，Cassandra将无法识别行的最新数据。因此，压缩也不能正常工作。</p></div><div class="ab cl kk kl gp km" role="separator"><span class="kn bw bk ko kp kq"/><span class="kn bw bk ko kp kq"/><span class="kn bw bk ko kp"/></div><div class="hb hc hd he hf"><h2 id="eedb" class="kr ks hi bd kt ku kv kw kx ky kz la lb iq lc ld le iu lf lg lh iy li lj lk ll bi translated">详细表格</h2><p id="5c3d" class="pw-post-body-paragraph if ig hi ih b ii lm ik il im ln io ip iq lo is it iu lp iw ix iy lq ja jb jc hb bi translated">下面是SSTable的快照:</p><figure class="jg jh ji jj fd jk er es paragraph-image"><div role="button" tabindex="0" class="kc kd di ke bf kf"><div class="er es lr"><img src="../Images/b916a044ee5b5b62a5642990310edd72.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OKFyjXIf-01yY3CTABd1rw.png"/></div></div><figcaption class="kg kh et er es ki kj bd b be z dx translated">这是CQL表目录的快照。它位于LOC _ TO _ CASS _ DATA/DATA/key space _ name/table _ name/。这些文件都不是可读的，除了TOC.txt，它包含了SSTable的组件列表。</figcaption></figure><p id="b78d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">a)filter . db:</strong>filter文件存储了行键bloom filter。它存储在磁盘上，以便<a class="ae jd" href="https://en.wikipedia.org/wiki/Bloom_filter" rel="noopener ugc nofollow" target="_blank">布隆过滤器</a>在节点重启后激活。</p><p id="9e8e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> b) Index.db: </strong>索引文件包含SSTable索引，它将行键映射到数据文件中它们各自的偏移量。行键根据它们的标记按排序顺序存储。每个行键都与一个索引项相关联，该索引项包括其数据在数据文件中的存储位置。</p><p id="5e89" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> c) Summary.db: </strong>摘要文件包含SSTable索引的索引摘要和索引边界。指数摘要是根据表指数计算的。它根据索引文件中各自的位置，对相距<strong class="ih hj"> index_interval </strong>(默认index_interval为128) <strong class="ih hj"> </strong>的行索引进行采样。索引边界包括表索引中的开始和结束行键。</p><p id="46bf" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">d) Data.db: 这个文件包含实际的数据，所有的行内容都将保存在这里。</p><p id="9444" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">e) CompressionInfo.db: 该文件包含压缩元数据信息，包括块大小、压缩数据长度等。</p><p id="1372" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> f) Statistics.db: </strong>该文件包含有关用于生成分区键的分区的信息、有关估计行键和估计列数的直方图、压缩数据与未压缩数据的比率、创建该表的所有表生成编号的列表等。</p></div><div class="ab cl kk kl gp km" role="separator"><span class="kn bw bk ko kp kq"/><span class="kn bw bk ko kp kq"/><span class="kn bw bk ko kp"/></div><div class="hb hc hd he hf"><h2 id="3c56" class="kr ks hi bd kt ku kv kw kx ky kz la lb iq lc ld le iu lf lg lh iy li lj lk ll bi translated">Cassandra写入路径</h2><p id="ea57" class="pw-post-body-paragraph if ig hi ih b ii lm ik il im ln io ip iq lo is it iu lp iw ix iy lq ja jb jc hb bi translated">Cassandra的写操作比传统的RDBMS数据库快得多。更快写入的原因是其存储引擎。Cassandra使用<strong class="ih hj">日志结构化合并(LSM)树</strong>，而关系数据库使用<strong class="ih hj"> B+树</strong>数据结构来存储数据。Cassandra不关心被修改的列的现有值，它完全跳过读取部分，在内存中创建一个记录，包括列和更新的值。然后，它在内存中对插入和更新进行分组，并在附加模式下每隔一段时间将数据顺序写入磁盘。每次刷新时，数据都被写入不可变文件(SSTable ),并且永远不会被覆盖。因此，由于它跳过了对长数据文件的扫描，并再次将数据添加到相同的长数据文件中，因此在Cassandra中写入所需的时间明显减少。</p><p id="720a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">客户端与Cassandra集群中的一个节点(成为<a class="ae jd" href="https://docs.datastax.com/en/glossary/doc/glossary/gloss_coordinator_node.html" rel="noopener ugc nofollow" target="_blank">协调器节点</a>)连接。协调器节点为数据识别正确的节点集(取决于CL)。在被定向到特定节点后，数据被写入commitLog(在磁盘上)，然后相同的数据按照分区键的排序顺序被添加到memtable(在内存中)。在某个时刻(例如，memtable已满)，Cassandra将数据刷新到磁盘上一个新的SSTable，memtable和commitLog将被清除，以释放空间供重用。</p><figure class="jg jh ji jj fd jk er es paragraph-image"><div role="button" tabindex="0" class="kc kd di ke bf kf"><div class="er es ls"><img src="../Images/c1906536c3b237da04de5655a65aad8d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*r5JJZhsZRgQC_lh1KoqkXA.png"/></div></div><figcaption class="kg kh et er es ki kj bd b be z dx translated">节点内的Cassandra写入路径。Memtables和STables仅属于目标CQL表。</figcaption></figure><p id="4f32" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">Cassandra中的行更新是如何工作的？</strong></p><p id="43f3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Cassandra将每个新行视为一个<a class="ae jd" href="https://docs.datastax.com/en/glossary/doc/glossary/gloss_upsert.html" rel="noopener ugc nofollow" target="_blank"> upsert </a>:如果新行与现有行具有相同的主键，Cassandra会将其作为对现有行的更新来处理。数据库中可能存在同一行的多个版本。这就是Cassandra在读取过程中执行另一轮比较的原因。当客户机请求具有特定主键的数据时，Cassandra从一个或多个副本中检索该行的多个版本。具有最新时间戳的版本是返回给客户端的唯一版本(“<strong class="ih hj">最后写入成功</strong>”)。</p><p id="6d9c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">在Cassandra中，行删除是如何工作的？</strong></p><p id="f3cd" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Cassandra仅将每个删除的行视为upsert。删除的行将被标记为逻辑删除。Tombstone是行中的一个标记，表示一列被删除，当压缩发生时，它将从行中删除该列，如第二个图中所述。</p></div><div class="ab cl kk kl gp km" role="separator"><span class="kn bw bk ko kp kq"/><span class="kn bw bk ko kp kq"/><span class="kn bw bk ko kp"/></div><div class="hb hc hd he hf"><h2 id="e3a2" class="kr ks hi bd kt ku kv kw kx ky kz la lb iq lc ld le iu lf lg lh iy li lj lk ll bi translated">卡珊德拉阅读路径</h2><p id="aec0" class="pw-post-body-paragraph if ig hi ih b ii lm ik il im ln io ip iq lo is it iu lp iw ix iy lq ja jb jc hb bi translated">Cassandra读取路径非常复杂，因为路径中包含更多的组件。Cassandra read是活动memtable及其在磁盘上的所有表的结果。在我们进入读取路径之前，我们需要先了解它的所有组件。</p><ol class=""><li id="4d06" class="jn jo hi ih b ii ij im in iq jp iu jq iy jr jc js jt ju jv bi translated"><strong class="ih hj"> Memtable: </strong>上面已经描述过了。</li><li id="1a0d" class="jn jo hi ih b ii jw im jx iq jy iu jz iy ka jc js jt ju jv bi translated"><strong class="ih hj">行缓存:</strong>将频繁访问的行存储在缓存中，提高读取性能。行缓存大小是可配置的，要存储的行数也是可配置的。当缓存已满时，它使用<a class="ae jd" href="https://en.wikipedia.org/wiki/Cache_replacement_policies#Least_recently_used_(LRU)" rel="noopener ugc nofollow" target="_blank"> LRU </a>回收策略从缓存中回收行。行缓存不是直写式的。如果对该行进行写入，则该行的缓存将失效，并且不会再次缓存，直到该行被读取。</li><li id="5bca" class="jn jo hi ih b ii jw im jx iq jy iu jz iy ka jc js jt ju jv bi translated"><strong class="ih hj"> Bloom Filter: </strong>用于识别表中是否有行。它存储在<strong class="ih hj">完全脱离堆的内存</strong>中，使用一个新的实现来减轻JVM中的垃圾收集压力。它肯定会告诉我们该行是否不存在于任何表中，但是它也会给出误报。</li><li id="acfe" class="jn jo hi ih b ii jw im jx iq jy iu jz iy ka jc js jt ju jv bi translated"><strong class="ih hj">分区键缓存:</strong>用于存储分区键。如果在缓存中找到分区键，它可以直接转到压缩偏移映射，在磁盘上找到包含数据的压缩块。分区键缓存的大小是可配置的，存储在键缓存中的分区键的数量也是可配置的。</li><li id="9c25" class="jn jo hi ih b ii jw im jx iq jy iu jz iy ka jc js jt ju jv bi translated"><strong class="ih hj">分区摘要:</strong>用于存储分区索引文件的索引(是实际数据索引的索引)。它驻留在内存中，以识别分区索引的块，从而进行高效读取。</li><li id="59d2" class="jn jo hi ih b ii jw im jx iq jy iu jz iy ka jc js jt ju jv bi translated"><strong class="ih hj">分区索引:</strong>用于存储所有分区键的索引。它驻留在<strong class="ih hj">磁盘</strong>上。一旦Cassandra从分区摘要中获得该块，它就在该块的分区索引中查找，以识别分区键的特定索引。</li><li id="ff73" class="jn jo hi ih b ii jw im jx iq jy iu jz iy ka jc js jt ju jv bi translated"><strong class="ih hj">压缩偏移图:</strong>用来存储数据在磁盘上的确切位置。它由<strong class="ih hj"> <em class="je">分区键缓存</em> </strong>或<strong class="ih hj"> <em class="je">分区索引使用。</em>T13】</strong></li></ol><blockquote class="lt lu lv"><p id="e403" class="if ig je ih b ii ij ik il im in io ip lw ir is it lx iv iw ix ly iz ja jb jc hb bi translated"><strong class="ih hj"> </strong></p></blockquote><p id="c4ce" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">现在，让我们看看读取路径:</strong></p><ol class=""><li id="007b" class="jn jo hi ih b ii ij im in iq jp iu jq iy jr jc js jt ju jv bi translated">读取memtable，如果数据可用，则读取它并将其与表中的数据合并。</li><li id="ec92" class="jn jo hi ih b ii jw im jx iq jy iu jz iy ka jc js jt ju jv bi translated">读取行缓存(如果启用)，如果数据在那里，返回它，否则转到下一步。</li><li id="8219" class="jn jo hi ih b ii jw im jx iq jy iu jz iy ka jc js jt ju jv bi translated">检查bloom-filter，如果它说数据不存在，只返回memtable数据(如果找到的话)。如果它说，SSTable中存在数据，则进入下一步。</li><li id="139a" class="jn jo hi ih b ii jw im jx iq jy iu jz iy ka jc js jt ju jv bi translated">读取分区键缓存(如果启用)，如果在缓存中找到分区键，则读取缓存中找到的值的压缩偏移映射，以获得数据在磁盘上的确切位置。假设在缓存中找不到分区键，请转到下一步。</li><li id="e656" class="jn jo hi ih b ii jw im jx iq jy iu jz iy ka jc js jt ju jv bi translated">读取分区摘要缓存，它告诉分区索引数据的索引。</li><li id="22a0" class="jn jo hi ih b ii jw im jx iq jy iu jz iy ka jc js jt ju jv bi translated">从分区摘要中读取偏移量，以找到磁盘上包含数据的压缩块。</li><li id="e17d" class="jn jo hi ih b ii jw im jx iq jy iu jz iy ka jc js jt ju jv bi translated">使用压缩偏移映射定位磁盘上的数据。</li><li id="1e29" class="jn jo hi ih b ii jw im jx iq jy iu jz iy ka jc js jt ju jv bi translated">从磁盘上的表中获取数据。</li></ol><figure class="jg jh ji jj fd jk er es paragraph-image"><div role="button" tabindex="0" class="kc kd di ke bf kf"><div class="er es lz"><img src="../Images/08b0e19a33ef5de5f053d308448d4552.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*23rYPfnCpXwmslRE_GAXjA.png"/></div></div><figcaption class="kg kh et er es ki kj bd b be z dx translated">单个Cassandra节点中的Cassandra读取路径</figcaption></figure></div><div class="ab cl kk kl gp km" role="separator"><span class="kn bw bk ko kp kq"/><span class="kn bw bk ko kp kq"/><span class="kn bw bk ko kp"/></div><div class="hb hc hd he hf"><p id="a12d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">与Cassandra合作时，需要记住以下几点:</p><ol class=""><li id="7c80" class="jn jo hi ih b ii ij im in iq jp iu jq iy jr jc js jt ju jv bi translated">复制因子必须大于1。<strong class="ih hj"> 3 </strong>是生产集群的推荐射频。</li><li id="0401" class="jn jo hi ih b ii jw im jx iq jy iu jz iy ka jc js jt ju jv bi translated">检查压缩、压缩、布隆过滤器和缓存设置，并根据您的要求进行配置。</li><li id="068c" class="jn jo hi ih b ii jw im jx iq jy iu jz iy ka jc js jt ju jv bi translated">为群集设置一致性级别，可以根据使用情形在客户端为每次写入和读取设置一致性级别。</li><li id="be4e" class="jn jo hi ih b ii jw im jx iq jy iu jz iy ka jc js jt ju jv bi translated">确保容量应该是总可用容量的最大利用率的一半。</li></ol><p id="c7ad" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">感谢阅读！</p></div></div>    
</body>
</html>