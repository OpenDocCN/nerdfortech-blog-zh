<html>
<head>
<title>Top View of a Binary Tree</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">二叉树的俯视图</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/top-view-of-a-binary-tree-6de9576a8673?source=collection_archive---------5-----------------------#2021-08-09">https://medium.com/nerd-for-tech/top-view-of-a-binary-tree-6de9576a8673?source=collection_archive---------5-----------------------#2021-08-09</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="05ce" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">下面给出的是一棵二叉树。任务是打印二叉树的顶视图。二叉树的顶视图是当从顶部查看该树时可见的节点集。对于下面给定的树。</p><pre class="jd je jf jg fd jh ji jj jk aw jl bi"><span id="6920" class="jm jn hi ji b fi jo jp l jq jr"><strong class="ji hj">Note: </strong>Return nodes from <strong class="ji hj">leftmost </strong>node to <strong class="ji hj">rightmost </strong>node.</span></pre><p id="0f39" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">例 1: </strong></p><pre class="jd je jf jg fd jh ji jj jk aw jl bi"><span id="8abf" class="jm jn hi ji b fi jo jp l jq jr"><strong class="ji hj">Input:<br/></strong>      1<br/>   /    \<br/>  2      3<br/><strong class="ji hj">Output: </strong>2 1 3</span></pre><p id="ad37" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">例二:</strong></p><pre class="jd je jf jg fd jh ji jj jk aw jl bi"><span id="936e" class="jm jn hi ji b fi jo jp l jq jr"><strong class="ji hj">Input:<br/></strong>       10<br/>    /      \<br/>  20        30<br/> /   \    /    \<br/>40   60  90    100<br/><strong class="ji hj">Output: </strong>40 20 10 30 100</span></pre><p id="acf7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">任务:</strong> <br/>完成函数<strong class="ih hj"> topView() </strong>，该函数以<strong class="ih hj">根节点</strong>为参数，从左到右返回俯视图中可见的节点列表。打印顶视图结束后打印 endline。</p><p id="bcd7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">期望时间复杂度:</strong> O(N) <br/> <strong class="ih hj">期望辅助空间:</strong> O(N)。</p><p id="a6cb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">约束:</strong> <br/> 1 ≤ N ≤ 10^5 <br/> 1 ≤节点数据≤ 10^5</p><p id="cd00" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我将使用地图、配对和队列来寻找解决方案。让我们先了解这些。</p><ol class=""><li id="ffa7" class="js jt hi ih b ii ij im in iq ju iu jv iy jw jc jx jy jz ka bi translated"><a class="ae kb" href="https://www.geeksforgeeks.org/map-associative-containers-the-c-standard-template-library-stl/" rel="noopener ugc nofollow" target="_blank"> <strong class="ih hj"> <em class="kc">地图</em> </strong> </a></li></ol><figure class="jd je jf jg fd ke er es paragraph-image"><div class="er es kd"><img src="../Images/3b4b8eddde6871a20ac189fd8665cabb.png" data-original-src="https://miro.medium.com/v2/resize:fit:988/format:webp/0*M1e553wg0R9cdZ6E.png"/></div></figure><p id="c04e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">它是一个以键值对形式存储数据的容器，如上图所示。没有两个映射值具有相同的键值。一些基本函数有:begin()、end()、clear()等。</p><p id="4e7a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> 2 <em class="kc">。</em> </strong> <a class="ae kb" href="http://geeksforgeeks.org/pair-in-cpp-stl/" rel="noopener ugc nofollow" target="_blank"> <strong class="ih hj"> <em class="kc">对</em> </strong> </a></p><p id="335c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">它是由两个数据元素或容器组成的容器。</p><p id="6362" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">语法为:</strong> pair(数据类型 1，数据类型 2) Pair_name</p><blockquote class="kh ki kj"><p id="31ae" class="if ig kc ih b ii ij ik il im in io ip kk ir is it kl iv iw ix km iz ja jb jc hb bi translated"><strong class="ih hj">代码:</strong></p></blockquote><pre class="jd je jf jg fd jh ji jj jk aw jl bi"><span id="a7c5" class="jm jn hi ji b fi jo jp l jq jr">vector&lt;int&gt; topView(Node *root)<br/> {<br/> <strong class="ji hj"><em class="kc">//map where key and value pair are of int type </em></strong><br/> map&lt;int,int&gt; m; <br/> <br/><strong class="ji hj"><em class="kc"> // queue of pair </em></strong><br/> queue&lt;pair&lt;struct Node*,int&gt;&gt; q;</span><span id="a569" class="jm jn hi ji b fi kn jp l jq jr"><strong class="ji hj">//constructs a pair object with its first element set to x i.e. root</strong></span><span id="9c55" class="jm jn hi ji b fi kn jp l jq jr"><strong class="ji hj">//and its second element set to y i.e. 0</strong><br/> q.push(make_pair(root,0));<br/> <br/><strong class="ji hj"><em class="kc">// while the queue has elements</em></strong><br/> while(!q.empty())<br/> {<br/> <strong class="ji hj"><em class="kc">// pair points to the front of the queue </em></strong><br/> pair&lt;struct Node*,int&gt; current = q.front();</span><span id="aba3" class="jm jn hi ji b fi kn jp l jq jr"><strong class="ji hj"><em class="kc">// pop the front element from the queue </em></strong><br/> q.pop();</span><span id="058e" class="jm jn hi ji b fi kn jp l jq jr"><strong class="ji hj"><em class="kc">// if second element in the current pair is equal to the end element in map </em></strong><br/> if(m.find(current.second)==m.end())</span><span id="81e3" class="jm jn hi ji b fi kn jp l jq jr"><strong class="ji hj"><em class="kc">//then the value at that index in the map will store the <br/>//data which is held by first element of the current pair </em></strong><br/> m[current.second]=current.first-&gt;data;</span><span id="c30a" class="jm jn hi ji b fi kn jp l jq jr"><strong class="ji hj"><em class="kc">//if element at left is not NULL </em></strong><br/> if(current.first-&gt;left)<br/><strong class="ji hj"><em class="kc">// recursive call </em></strong><br/> q.push(make_pair(current.first-&gt;left,current.second-1));</span><span id="a8c6" class="jm jn hi ji b fi kn jp l jq jr"><strong class="ji hj"><em class="kc">//if element at right is not NULL</em></strong><em class="kc"> </em><br/> if(current.first-&gt;right)<br/><strong class="ji hj"><em class="kc">// recursive call <br/></em></strong> q.push(make_pair(current.first-&gt;right,current.second+1));<br/> <br/> }</span><span id="3d70" class="jm jn hi ji b fi kn jp l jq jr"><strong class="ji hj"><em class="kc">//vector to store the answer </em></strong><br/> vector&lt;int&gt;ans</span><span id="0bb7" class="jm jn hi ji b fi kn jp l jq jr"><strong class="ji hj"><em class="kc">// pushing the top view elements from the map in the vector </em></strong><br/> auto p=m.begin();<br/> while(p!=m.end())<br/> {<br/> ans.push_back(p-&gt;second);<br/> p++;<br/> }<br/> return ans;<br/> }</span></pre><blockquote class="kh ki kj"><p id="61d7" class="if ig kc ih b ii ij ik il im in io ip kk ir is it kl iv iw ix km iz ja jb jc hb bi translated"><strong class="ih hj">代码片段</strong></p></blockquote><figure class="jd je jf jg fd ke er es paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="er es ko"><img src="../Images/a723035937814eb53c3e8cccc3549392.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kmmPU2B_x76w-TrCyBMNrw.png"/></div></div></figure><p id="1be8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">便于理解的参考&amp;可视化:</strong></p><ol class=""><li id="4e5d" class="js jt hi ih b ii ij im in iq ju iu jv iy jw jc jx jy jz ka bi translated">下图显示了配对队列的可视化效果。</li></ol><pre class="jd je jf jg fd jh ji jj jk aw jl bi"><span id="6a1d" class="jm jn hi ji b fi jo jp l jq jr">       Queue of Pairs: (10, 20) (15, 5) (1, 5) (5, 10) (7, 9)</span></pre><figure class="jd je jf jg fd ke er es paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="er es kt"><img src="../Images/c3693bd12a8ede1d297a96464ab62de0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*FxrqyUeVeDAokbhs.jpg"/></div></div></figure><p id="161b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">希望有帮助！！😀既然你喜欢看我的博客，为什么不请我喝杯咖啡，支持我的工作呢！！<a class="ae kb" href="https://www.buymeacoffee.com/sukanyabharati" rel="noopener ugc nofollow" target="_blank">https://www.buymeacoffee.com/sukanyabharati</a>☕</p></div></div>    
</body>
</html>