<html>
<head>
<title>Juice up Our Functions with Python Decorator (Part 2)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用 Python Decorator 充实我们的函数(第 2 部分)</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/juice-up-our-functions-with-python-decorator-part-2-837f45715d52?source=collection_archive---------3-----------------------#2021-02-01">https://medium.com/nerd-for-tech/juice-up-our-functions-with-python-decorator-part-2-837f45715d52?source=collection_archive---------3-----------------------#2021-02-01</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/c5973e68f31505a97283e7152d86880f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*sp7oMjn0m-CU8fR3"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">照片由<a class="ae iu" href="https://unsplash.com/@emmasvalstad?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">艾玛·斯瓦斯塔德</a>在<a class="ae iu" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="d6fb" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在本文中，我们将继续我们关于 Python Decorator 的旅程，并讨论一些更复杂的概念。在前一篇文章中，我们问装饰者可以接受参数吗？我们将在这里学习它。</p></div><div class="ab cl jt ju gp jv" role="separator"><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy"/></div><div class="hb hc hd he hf"><h1 id="2368" class="ka kb hi bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated">装饰方法</h1><p id="ceef" class="pw-post-body-paragraph iv iw hi ix b iy ky ja jb jc kz je jf jg la ji jj jk lb jm jn jo lc jq jr js hb bi translated">在上一篇文章中，我们学习了如何修饰一个函数，但是我们也可以修饰一个方法吗？基本上，<a class="ae iu" href="https://stackoverflow.com/questions/155609/whats-the-difference-between-a-method-and-a-function" rel="noopener ugc nofollow" target="_blank">一个类的方法就是一个函数</a>，不同的是一个方法被一个与对象相关联的名字所调用。</p><p id="1850" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">先说一些内置的装饰器。</p><figure class="ld le lf lg fd ij"><div class="bz dy l di"><div class="lh li l"/></div></figure><p id="b6b2" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在上面的代码中，我们定义了一个名为<code class="du lj lk ll lm b">Vector.</code>的类。这个类表示一个二维向量，包含 x 和 y 两个分量。注意，在第 5、6 和 7 行中，我们使用了<code class="du lj lk ll lm b">__x</code>、<code class="du lj lk ll lm b">__y</code>作为 x 和 y 的引用。这样做的目的是为了区分我们可以“自由”访问的变量和应该“私有”的变量。<a class="ae iu" href="https://stackoverflow.com/questions/1641219/does-python-have-private-variables-in-classes#:~:text=Python%20does%20not%20have%20any,expose%20your%20classes%20member%20variables.&amp;text=The%20double%20underscore%20%22__%22%20does,mean%20a%20%22private%20variable%22." rel="noopener ugc nofollow" target="_blank">尽管如此，我们不能像在 Java </a>中那样在 Python 中创建私有变量 <a class="ae iu" href="https://stackoverflow.com/questions/1641219/does-python-have-private-variables-in-classes#:~:text=Python%20does%20not%20have%20any,expose%20your%20classes%20member%20variables.&amp;text=The%20double%20underscore%20%22__%22%20does,mean%20a%20%22private%20variable%22." rel="noopener ugc nofollow" target="_blank">。</a></p><p id="3ba3" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">类<code class="du lj lk ll lm b">Vector</code>中有几个方法。首先，我们定义了一个<a class="ae iu" href="https://www.geeksforgeeks.org/dunder-magic-methods-python/" rel="noopener ugc nofollow" target="_blank"> dunder </a>，这样实例的字符串表示就很容易阅读了。然后，它有三种使用<code class="du lj lk ll lm b">@property</code> (x，y 和距离)进行修饰的方法。<code class="du lj lk ll lm b">@property</code>将一个方法变成一个实例变量。所以为了访问 x(或 __x ),我们必须写，而不是像我们总是做的那样访问一个实例变量。</p><p id="de70" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">接下来是<code class="du lj lk ll lm b">setter,</code>如果我们想要重置或改变一个实例变量，我们使用这个装饰器。我们可以在第 24 行和第 28 行看到定义，以及它在第 49 行和第 50 行的用法。这里，我们将实例变量 x 和 y 从之前的 1，1 改为 3，3。</p><p id="bba1" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">装饰器<code class="du lj lk ll lm b">@classmethod</code>通常在我们想要创建一个特殊的实例时使用。在这个方法中，我们提供的参数是<code class="du lj lk ll lm b">cls,</code>，它指的是类的构造函数。看看我们在第 32、33 和 34 行中的定义，这个方法将通过调用<code class="du lj lk ll lm b">cls(1, 1)</code>来创建一个带有向量值(1，1)的实例，其中<code class="du lj lk ll lm b">cls(1, 1)</code>调用这个类的构造函数(<code class="du lj lk ll lm b">__init__</code>)并为其参数提供值<code class="du lj lk ll lm b">x=1</code>和<code class="du lj lk ll lm b">y=1</code>。</p><p id="15a9" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">最后一个装饰器是第 53 行的<code class="du lj lk ll lm b">@staticmethod.</code>，我们直接从类中调用该方法。但是怎么做呢？难道我们不能从实例中调用方法吗？让我们这样做吧。现在，当我们移除第 36 行时会发生什么？</p><figure class="ld le lf lg fd ij er es paragraph-image"><div class="er es ln"><img src="../Images/d9930832fea2ccacf6f4b0c6b97d81b1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1258/format:webp/1*ObBDON4ypiyb4PDHSBLE2g.png"/></div></figure><p id="51f8" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">错误发生在哪里，是什么原因造成的？它发生在第 53 行，因为当我们使用一个方法时，这个函数的签名变成了<code class="du lj lk ll lm b">calculate_distance(self, tup1, tup2)</code>，但是我们只定义了它只接受两个参数。为了缓解这个问题，我们必须将<code class="du lj lk ll lm b">@staticmethod</code>或<code class="du lj lk ll lm b">self</code>添加到函数定义中。</p></div><div class="ab cl jt ju gp jv" role="separator"><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy"/></div><div class="hb hc hd he hf"><h1 id="28db" class="ka kb hi bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated">嵌套装饰器</h1><p id="3155" class="pw-post-body-paragraph iv iw hi ix b iy ky ja jb jc kz je jf jg la ji jj jk lb jm jn jo lc jq jr js hb bi translated">以前，我们只使用单个装饰器，但实际上，我们可以使用多个装饰器来装饰一个函数。让我们来回顾一下上一篇文章。</p><figure class="ld le lf lg fd ij"><div class="bz dy l di"><div class="lh li l"/></div></figure><p id="5648" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">从上一篇文章中我们知道了<code class="du lj lk ll lm b">@do_ten_times</code>和<code class="du lj lk ll lm b">@timer</code>是做什么的；<code class="du lj lk ll lm b">@do_ten_times</code>重复一个函数调用十次，而<code class="du lj lk ll lm b">@timer</code>是测量一个函数完全执行需要多长时间。现在，我们试着结合这两个装饰器来装饰<code class="du lj lk ll lm b">wasting_operations.</code>注意，我们把<code class="du lj lk ll lm b">@do_ten_times</code>放在<code class="du lj lk ll lm b">@timer,</code>上面，所以上面的代码本质上是</p><figure class="ld le lf lg fd ij"><div class="bz dy l di"><div class="lh li l"/></div></figure><p id="5e96" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">它从下往上开始。结果是</p><figure class="ld le lf lg fd ij er es paragraph-image"><div class="er es lo"><img src="../Images/9e6e30682fdabe75e9cbcd9f7ccc84e5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1368/format:webp/1*0t_Pvqlg0H3rzXtpR0vozA.png"/></div></figure><p id="b6fb" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">注意在<code class="du lj lk ll lm b">wasting_operations</code>的每次重复中，<code class="du lj lk ll lm b">@timer</code>测量函数调用的时间。当我们改变顺序，把<code class="du lj lk ll lm b">@timer</code>写在<code class="du lj lk ll lm b">@do_ten_times</code>上面，会发生什么？</p><figure class="ld le lf lg fd ij er es paragraph-image"><div class="er es lo"><img src="../Images/edded1c5f1c2d5ca2cbedc7a4f8694f0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1368/format:webp/1*8faYLc3ieqsnj80vsuULSA.png"/></div></figure><p id="0e8a" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这次函数运行了十次，然后测量时间。</p></div><div class="ab cl jt ju gp jv" role="separator"><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy"/></div><div class="hb hc hd he hf"><h1 id="7736" class="ka kb hi bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated">带参数的装饰器</h1><p id="36b5" class="pw-post-body-paragraph iv iw hi ix b iy ky ja jb jc kz je jf jg la ji jj jk lb jm jn jo lc jq jr js hb bi translated">现在，我们将回答我们长期以来的问题，装饰者可以接受论点吗？让我们把<code class="du lj lk ll lm b">@do_ten_times</code>改成<code class="du lj lk ll lm b">@repeats,</code>,这样它就可以根据我们给它的参数重复函数调用。</p><figure class="ld le lf lg fd ij"><div class="bz dy l di"><div class="lh li l"/></div></figure><p id="2c61" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们有一个名为<code class="du lj lk ll lm b">repeats</code>的装饰器，带有一个参数<code class="du lj lk ll lm b">num_reps</code>，它定义了将执行多少个函数调用。然后我们看到函数<em class="lp"> say_hi </em>被一个参数<code class="du lj lk ll lm b">num_reps = 5.</code>修饰</p><p id="c15f" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们来剖析一下这个装修工。首先，我们定义了一个函数<code class="du lj lk ll lm b">repeats</code>来获取关键字<code class="du lj lk ll lm b">num_reps,</code>这是我们必须提供<code class="du lj lk ll lm b">num_reps.</code>的部分，然后我们有一个内部函数叫做<code class="du lj lk ll lm b">decorator,</code>，它的任务和我们知道的一样，就是修饰一个函数。所以，普通的装饰器和带参数的装饰器之间的区别在于，我们只是在带参数的装饰器之上添加了另一层。</p></div><div class="ab cl jt ju gp jv" role="separator"><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy"/></div><div class="hb hc hd he hf"><h1 id="d9e5" class="ka kb hi bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated">有状态装饰器</h1><p id="e6dc" class="pw-post-body-paragraph iv iw hi ix b iy ky ja jb jc kz je jf jg la ji jj jk lb jm jn jo lc jq jr js hb bi translated">除了修饰函数，decorator 还可以存储变量。如果我们想知道一个函数在某个特定时间和地点的状态，例如，一个函数被调用了多少次，这就变得很有用。</p><figure class="ld le lf lg fd ij"><div class="bz dy l di"><div class="lh li l"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">来自<a class="ae iu" href="https://realpython.com/primer-on-python-decorators/#fancy-decorators" rel="noopener ugc nofollow" target="_blank">https://real python . com/primer-on-python-decorators/# fancy-decorators</a>的示例</figcaption></figure><p id="9bf1" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">装饰器<code class="du lj lk ll lm b">@count_calls</code>用于计算函数<code class="du lj lk ll lm b">say_hi</code>被调用的次数，在上面的例子中是两次。请注意，在<code class="du lj lk ll lm b">count_calls</code>定义中，函数<code class="du lj lk ll lm b">wrapper</code>在第 10 行有一个内部状态变量<code class="du lj lk ll lm b">num_calls.</code>，我们在第 7 行初始化了<code class="du lj lk ll lm b">num_calls</code>，每次调用该函数，计数器都会增加 1</p></div><div class="ab cl jt ju gp jv" role="separator"><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy"/></div><div class="hb hc hd he hf"><h1 id="fd4b" class="ka kb hi bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated">作为装饰者的类</h1><p id="b044" class="pw-post-body-paragraph iv iw hi ix b iy ky ja jb jc kz je jf jg la ji jj jk lb jm jn jo lc jq jr js hb bi translated">我们已经从一个函数制作了一个装饰器，现在我们将学习一些不同的东西。我们将从一个类中创建一个装饰器。让我们把 decorator <code class="du lj lk ll lm b">count_calls</code>改成一个类。</p><figure class="ld le lf lg fd ij"><div class="bz dy l di"><div class="lh li l"/></div></figure><p id="f82b" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">函数作为装饰者<code class="du lj lk ll lm b">num_calls</code>现在变成了类作为装饰者<code class="du lj lk ll lm b">CountCalls.</code>我们该怎么做呢？在第 28 行，我们使用<code class="du lj lk ll lm b">CountCalls</code>作为一个普通的高阶函数(没有语法糖)。当我们写<code class="du lj lk ll lm b">CountCalls(say_ho)</code>时，结果将成为<code class="du lj lk ll lm b">CountCalls.</code>的一个实例，所以下次我们执行<code class="du lj lk ll lm b">say_ho()</code>时，我们也将调用 dunder <code class="du lj lk ll lm b">__call__.</code>，注意我们使用<code class="du lj lk ll lm b">functools.update_wrapper</code>而不是<code class="du lj lk ll lm b">functools.wraps.</code></p></div><div class="ab cl jt ju gp jv" role="separator"><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy"/></div><div class="hb hc hd he hf"><h1 id="02bb" class="ka kb hi bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated">用方法作为装饰器的类</h1><p id="b478" class="pw-post-body-paragraph iv iw hi ix b iy ky ja jb jc kz je jf jg la ji jj jk lb jm jn jo lc jq jr js hb bi translated">现在，让我们把我们编写的几个 decorators 放在一个类中。</p><figure class="ld le lf lg fd ij"><div class="bz dy l di"><div class="lh li l"/></div></figure><p id="5bd0" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在上面的代码中，我们定义了一个名为<code class="du lj lk ll lm b">MyClass</code>的类，它有两个方法作为装饰器。我们可以像使用普通函数一样使用这些方法。不同之处在于我们必须添加参数<code class="du lj lk ll lm b">self</code>(第 9 行和第 24 行)，并且我们使用类的实例来访问它的方法(第 39 行和第 43 行)。</p></div><div class="ab cl jt ju gp jv" role="separator"><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy"/></div><div class="hb hc hd he hf"><h1 id="9243" class="ka kb hi bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated">装饰者的真实例子</h1><h2 id="24e8" class="lq kb hi bd kc lr ls lt kg lu lv lw kk jg lx ly ko jk lz ma ks jo mb mc kw md bi translated">1.创建单件</h2><p id="c49a" class="pw-post-body-paragraph iv iw hi ix b iy ky ja jb jc kz je jf jg la ji jj jk lb jm jn jo lc jq jr js hb bi translated">Singleton 是一个只有一个实例的类。让我们看看它的实际效果。</p><figure class="ld le lf lg fd ij"><div class="bz dy l di"><div class="lh li l"/></div></figure><p id="0d52" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">请注意，第 6 行和第 7 行是神奇的地方。我们第一次创建类<code class="du lj lk ll lm b">Single, wrapper.instance</code>的实例是 None。所以当我们运行<code class="du lj lk ll lm b">not wrapper.instance</code>时，这个值为真，然后执行第 7 行并返回。我们确定这在第 20 行。</p><h2 id="1fdd" class="lq kb hi bd kc lr ls lt kg lu lv lw kk jg lx ly ko jk lz ma ks jo mb mc kw md bi translated">2.贮藏</h2><p id="e452" class="pw-post-body-paragraph iv iw hi ix b iy ky ja jb jc kz je jf jg la ji jj jk lb jm jn jo lc jq jr js hb bi translated">缓存将帮助我们减少操作的数量，这样以后就不会执行相同的操作，例如当我们执行递归操作时。让我们创建一个递归函数来获取斐波那契数列的值。</p><figure class="ld le lf lg fd ij"><div class="bz dy l di"><div class="lh li l"/></div></figure><p id="ddef" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在上面的代码中，我们使用装饰器<code class="du lj lk ll lm b">@count_calls</code>来计算函数<code class="du lj lk ll lm b">fibonacci</code>被调用的次数。对于<code class="du lj lk ll lm b">fibonacci(19),</code>,它需要的操作数是 13529。我们可以通过使用 decorator 来减少这种情况。</p><figure class="ld le lf lg fd ij"><div class="bz dy l di"><div class="lh li l"/></div></figure><p id="78d0" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">Decorator <code class="du lj lk ll lm b">cache</code>可以通过使用我们所学的一种行为来做到这一点，这种行为是通过存储变量来跟踪函数调用。在第 19 行，我们编写了<code class="du lj lk ll lm b">cache_key</code>，它将成为特定函数调用的签名。因此，如果下一次用相同的参数调用这个函数，这个函数将只需要查看它的字典，但是如果用新的参数调用这个函数，它将向它的字典添加一个新的键-值对。即使你可以自己做，最好还是用<code class="du lj lk ll lm b"><a class="ae iu" href="https://docs.python.org/3/library/functools.html#functools.lru_cache" rel="noopener ugc nofollow" target="_blank">@functools.lru_cache</a>.</code></p></div><div class="ab cl jt ju gp jv" role="separator"><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy"/></div><div class="hb hc hd he hf"><h1 id="5f61" class="ka kb hi bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated">结论</h1><p id="e9a6" class="pw-post-body-paragraph iv iw hi ix b iy ky ja jb jc kz je jf jg la ji jj jk lb jm jn jo lc jq jr js hb bi translated">我们已经学习了很多关于装饰器的知识，从函数作为装饰器，类作为装饰器，方法作为装饰器，等等。需要记住和理解的是，decorator 基本上只是一个接受另一个函数并返回该函数的函数。记住这个简单的概念，我们会更容易变得有创造力，用 decorator 解决某些问题。</p><p id="c523" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">感谢您的阅读。</p><p id="e16e" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">以上所有代码都可以在:<a class="ae iu" href="https://github.com/agusrichard/python-workbook/tree/master/decorator" rel="noopener ugc nofollow" target="_blank">https://github . com/agusrichard/python-workbook/tree/master/decorator</a>中访问</p><h2 id="d0e7" class="lq kb hi bd kc lr ls lt kg lu lv lw kk jg lx ly ko jk lz ma ks jo mb mc kw md bi translated">资源:</h2><div class="me mf ez fb mg mh"><a href="https://realpython.com/primer-on-python-decorators/" rel="noopener  ugc nofollow" target="_blank"><div class="mi ab dw"><div class="mj ab mk cl cj ml"><h2 class="bd hj fi z dy mm ea eb mn ed ef hh bi translated">Python 装饰者入门——真正的 Python</h2><div class="mo l"><h3 class="bd b fi z dy mm ea eb mn ed ef dx translated">更新:在你能理解 decorators 之前，你必须首先理解函数是如何工作的。为了我们的目的，一个…</h3></div><div class="mp l"><p class="bd b fp z dy mm ea eb mn ed ef dx translated">realpython.com</p></div></div><div class="mq l"><div class="mr l ms mt mu mq mv io mh"/></div></div></a></div><div class="me mf ez fb mg mh"><a href="https://www.programiz.com/python-programming/decorator" rel="noopener  ugc nofollow" target="_blank"><div class="mi ab dw"><div class="mj ab mk cl cj ml"><h2 class="bd hj fi z dy mm ea eb mn ed ef hh bi translated">Python 装饰者</h2><div class="mo l"><h3 class="bd b fi z dy mm ea eb mn ed ef dx translated">Python 有一个有趣的特性，叫做 decorators，用于向现有代码添加功能。这也叫…</h3></div><div class="mp l"><p class="bd b fp z dy mm ea eb mn ed ef dx translated">www.programiz.com</p></div></div></div></a></div><div class="me mf ez fb mg mh"><a href="https://www.geeksforgeeks.org/decorators-in-python/" rel="noopener  ugc nofollow" target="_blank"><div class="mi ab dw"><div class="mj ab mk cl cj ml"><h2 class="bd hj fi z dy mm ea eb mn ed ef hh bi translated">Python 中的装饰者- GeeksforGeeks</h2><div class="mo l"><h3 class="bd b fi z dy mm ea eb mn ed ef dx translated">在 Python 中，函数是第一类对象，也就是说-函数是对象；他们可以参考…</h3></div><div class="mp l"><p class="bd b fp z dy mm ea eb mn ed ef dx translated">www.geeksforgeeks.org</p></div></div><div class="mq l"><div class="mw l ms mt mu mq mv io mh"/></div></div></a></div><figure class="ld le lf lg fd ij"><div class="bz dy l di"><div class="mx li l"/></div></figure></div></div>    
</body>
</html>