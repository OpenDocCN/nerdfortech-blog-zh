<html>
<head>
<title>Programming with Functions #8: Monads</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">函数编程#8:单子</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/programming-with-functions-8-monads-c2a30153f5ff?source=collection_archive---------6-----------------------#2021-07-13">https://medium.com/nerd-for-tech/programming-with-functions-8-monads-c2a30153f5ff?source=collection_archive---------6-----------------------#2021-07-13</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex if ig ih ii"><div class="bz dy l di"><div class="ij ik l"/></div></figure><p id="59f1" class="pw-post-body-paragraph il im hi in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji hb bi translated">在Scala中，不像Haskell，monad只是一个概念——没有一个叫做Monad的超类，所有的Monad都继承自它。monad基本上是任何具有静态方法unit的包装类(注意:这是该方法的流行名称；它不是单元类型)，它接受一个元素或元素的集合，并创建一个包含它们的单子，它实现了flatMap，使我们能够对单子进行链式操作:我们可以从原始元素创建一个单子，然后将这个元素平面映射到另一种类型的单子，将元素平面映射到那个单子中，等等。但是语言并没有区分单子类和非单子类。开发人员在编写他们的类时，应该牢记一元规则。</p><p id="4b11" class="pw-post-body-paragraph il im hi in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji hb bi translated">很有可能你可以有一个漫长而快乐的程序员生涯，并且永远不用单子。但是如果我能说服你考虑至少使用一些简单的方法呢？或者也许你已经在不知不觉中使用了它们？有三种:<code class="du jj jk jl jm b">Option</code>、<code class="du jj jk jl jm b">Either</code>、<code class="du jj jk jl jm b">Try</code>。它们将帮助你避免一件我们都应该避免的事情:例外。</p><h2 id="5300" class="jn jo hi bd jp jq jr js jt ju jv jw jx iw jy jz ka ja kb kc kd je ke kf kg kh bi translated">不要抛出异常。永远不会。</h2><p id="eb32" class="pw-post-body-paragraph il im hi in b io ki iq ir is kj iu iv iw kk iy iz ja kl jc jd je km jg jh ji hb bi translated">在前面的一章中，我举例说明了一种划分两个双精度数的方法<code class="du jj jk jl jm b">div</code>，以及如何使用<code class="du jj jk jl jm b">Double</code>类中的一个特殊常量来解决这个问题。Scala中的<code class="du jj jk jl jm b">Double</code>用的就是那两个常量:<code class="du jj jk jl jm b">Infinity</code>、<code class="du jj jk jl jm b">-Infinity</code>和神奇的<code class="du jj jk jl jm b">NaN</code>，只是运气不好。在许多其他情况下，我们就没有这么幸运了，使用某些参数或参数组合会导致抛出异常。</p><p id="5e79" class="pw-post-body-paragraph il im hi in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji hb bi translated">抛出异常就相当于把双手抛向空中，大喊<em class="kn">“OMG，我不知道怎么办！”</em>逃跑。这并不能解决你的问题。它只是把它交给别人，好像它是一个烫手山芋。千万不要这样做，如果不是因为其他原因，至少是为了那个必须代替你处理异常的人。那个人可能就是你，明天。</p><p id="33d7" class="pw-post-body-paragraph il im hi in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji hb bi translated">从表面上看，抛出异常类似于早期返回、循环中断和goto语句。在过去的某个时候，它们都被认为是处理特殊情况的有效方法。该函数将对其参数或中间结果执行一些断言，如果断言失败，它将提前返回一些特殊值。或者它会运行一个循环，从一个集合的元素中计算复杂的结果，但是如果一个元素不是预期的，它会提前中断这个循环。随着时间的推移，出现了许多关于这些结构如何导致不可读的代码、困难的重构和难以预测的结果的批评，并且逐渐地它们不再被使用。我非常相信抛出异常也属于这一类，也应该停止使用。总有比抛出异常或者返回某个特殊值更好的处理问题的方法(<em class="kn"> *cough* null *cough* </em>)。幸运的是，函数式编程中有一些工具可供我们使用。</p><h2 id="b8a9" class="jn jo hi bd jp jq jr js jt ju jv jw jx iw jy jz ka ja kb kc kd je ke kf kg kh bi translated">[计]选项</h2><p id="58fc" class="pw-post-body-paragraph il im hi in b io ki iq ir is kj iu iv iw kk iy iz ja kl jc jd je km jg jh ji hb bi translated"><code class="du jj jk jl jm b">Option</code>是最简单有趣的单子(你总是可以在<code class="du jj jk jl jm b">Unit</code>类型上定义<code class="du jj jk jl jm b">flatMap</code>——它什么都不会做，但是耶，它是单子)。</p><p id="22fa" class="pw-post-body-paragraph il im hi in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji hb bi translated">您可以将<code class="du jj jk jl jm b">Option</code>视为一个集合，它可以只有零个或一个元素。它的单元方法仅仅是它的构造函数，它将一个给定类型A的元素作为参数，并返回一个包含该元素的<code class="du jj jk jl jm b">Option[A]</code>实例。如果你想有一个零元素的选项，你调用方法<code class="du jj jk jl jm b">Option.empty[A]</code>。您仍然会收到一个<code class="du jj jk jl jm b">Option[A]</code>的实例，即使其中没有<code class="du jj jk jl jm b">A</code>类型的元素。在下面，子类<code class="du jj jk jl jm b">Some[A]</code>表示带有元素的选项，子类<code class="du jj jk jl jm b">None</code>表示空选项。如果您正在编写的函数通常会产生类型为<code class="du jj jk jl jm b">A</code>的结果，但是对于某些参数来说，它无法做到这一点，那么您可以自由地将结果类型声明中的<code class="du jj jk jl jm b">A</code>替换为<code class="du jj jk jl jm b">Option[A]</code>并使用该功能。</p><figure class="kp kq kr ks fd ii er es paragraph-image"><div role="button" tabindex="0" class="kt ku di kv bf kw"><div class="er es ko"><img src="../Images/5c4e92b80172c2c636afb2fbad8f6de0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*r_APDBAGisSXvg8o"/></div></div></figure><pre class="kp kq kr ks fd kz jm la lb aw lc bi"><span id="9c1d" class="jn jo hi jm b fi ld le l lf lg">sealed trait TrollNumber<br/>case object One extends TrollNumber<br/>case object Two extends TrollNumber<br/>case object Many extends TrollNumber<br/>case object Lots extends TrollNumber</span></pre><p id="635c" class="pw-post-body-paragraph il im hi in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji hb bi translated">在特里·普拉切特的Discworld系列中，巨魔是一种基于石英的生命形式。他们的智力受到温度的影响:当温度下降到接近绝对零度时，他们可能会非常聪明，但通常他们的智力低于平均水平，而且他们对大数(即大于2的数)有一点麻烦。</p><p id="3447" class="pw-post-body-paragraph il im hi in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji hb bi translated">【巨魔的头颅，作者马特·史密斯，来自Lwiki，<a class="ae lh" href="https://wiki.lspace.org/User:Knmatt" rel="noopener ugc nofollow" target="_blank">https://wiki.lspace.org/User:Knmatt</a>，<a class="ae lh" href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="noopener ugc nofollow" target="_blank">https://creativecommons.org/licenses/by-nc-sa/4.0/</a>】</p><pre class="kp kq kr ks fd kz jm la lb aw lc bi"><span id="d11c" class="jn jo hi jm b fi ld le l lf lg">def partialTrollNumber(n: Int): TrollNumber = n match {<br/>  case 1 =&gt; One<br/>  case 2 =&gt; Two<br/>  case 3 =&gt; Many<br/>  case 4 =&gt; Lots<br/>  case _ =&gt; throw new IllegalArgumentException(“oh no!”)<br/>}</span><span id="f923" class="jn jo hi jm b fi li le l lf lg">def totalTrollNumber(n: Int): Option[TrollNumber] = n match {<br/>  case 1 =&gt; Some(One)<br/>  case 2 =&gt; Some(Two)<br/>  case 3 =&gt; Some(Many)<br/>  case 4 =&gt; Some(Lots)<br/>  case _ =&gt; None<br/>}</span></pre><p id="b7f4" class="pw-post-body-paragraph il im hi in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji hb bi translated">然后是类<code class="du jj jk jl jm b">Option[A]</code>的<code class="du jj jk jl jm b">flatMap</code>方法:</p><pre class="kp kq kr ks fd kz jm la lb aw lc bi"><span id="116a" class="jn jo hi jm b fi ld le l lf lg">def flatMap[B](f: (A) =&gt; Option[B]): Option[B]</span></pre><p id="3de9" class="pw-post-body-paragraph il im hi in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji hb bi translated">您为它提供一个函数<code class="du jj jk jl jm b">f</code>，它将获取选项的元素并基于该元素创建一个新的选项，类型为<code class="du jj jk jl jm b">B</code>。但是这只有在选项实际上有一个元素时才有效——如果<code class="du jj jk jl jm b">Option[A]</code>为空，<code class="du jj jk jl jm b">Option[B]</code>也将为空。</p><p id="f8a0" class="pw-post-body-paragraph il im hi in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji hb bi translated">我们也可以将这些平面图链接在一起。如果结果是<code class="du jj jk jl jm b">Some</code>，第一个被调用函数的结果将作为参数传递给第二个函数，如果结果是<code class="du jj jk jl jm b">Some</code>，那么第二个函数的结果将传递给第三个函数，以此类推。最终，只有当所有连续的函数调用都产生中间结果时，我们才会得到<code class="du jj jk jl jm b">Some(finalResult)</code>。如果他们中的任何一个以<code class="du jj jk jl jm b">None</code>结束，最终的结果也将是<code class="du jj jk jl jm b">None</code>。</p><pre class="kp kq kr ks fd kz jm la lb aw lc bi"><span id="8473" class="jn jo hi jm b fi ld le l lf lg">def foo(t: T): Option[X]<br/>def bar(x: X): Option[Y]<br/>def boo(y: Y): Option[Z]<br/>val t: T = ...<br/>val result: Option[Z] = foo(t).flatMap(bar).flatMap(boo)</span></pre><p id="1b12" class="pw-post-body-paragraph il im hi in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji hb bi translated">由于一个选项可以被视为任何其他集合——毕竟，它只是一个最多包含一个元素的列表——除了<code class="du jj jk jl jm b">flatMap</code> : <code class="du jj jk jl jm b">map</code>，<code class="du jj jk jl jm b">foreach</code>，<code class="du jj jk jl jm b">fold</code>，<code class="du jj jk jl jm b">filter</code>等等之外，还有大量的方法可以像它们的对应方法一样用于更常规的集合，即使有时在一个您知道可能最多包含一个元素的集合上使用它们会感觉有点奇怪。</p><p id="00ac" class="pw-post-body-paragraph il im hi in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji hb bi translated">最后，在Scala中有一种特殊的情况:如果你用null作为元素来提供<code class="du jj jk jl jm b">Option</code>构造函数，你将得到<code class="du jj jk jl jm b">None</code>，一个空的选项。您不应该显式地这样做，但是有时您可能会因为调用用Java编写的第三方库而收到一个<code class="du jj jk jl jm b">null</code>。如果您担心这种情况会发生，那么将调用的结果包装在一个<code class="du jj jk jl jm b">Option</code>中，并将您自己的逻辑放在<code class="du jj jk jl jm b">Option.foreach</code>中。</p><pre class="kp kq kr ks fd kz jm la lb aw lc bi"><span id="f978" class="jn jo hi jm b fi ld le l lf lg">val result = javaLib.getSomethingOrNull(bar)<br/>Option(result).foreach { res =&gt;<br/>  // will be executed only if result is NOT null<br/>}</span></pre><p id="6cb6" class="pw-post-body-paragraph il im hi in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji hb bi translated">简而言之，<code class="du jj jk jl jm b">None</code>，一个空选项，可以用来表示出了问题或者发生了意想不到的事情，无法计算出有效的结果。</p><h2 id="4a25" class="jn jo hi bd jp jq jr js jt ju jv jw jx iw jy jz ka ja kb kc kd je ke kf kg kh bi translated">也</h2><p id="82cd" class="pw-post-body-paragraph il im hi in b io ki iq ir is kj iu iv iw kk iy iz ja kl jc jd je km jg jh ji hb bi translated">然而，有时我们想知道更多关于发生的事情。这就是为什么有这么多类型的异常的原因——它们不仅用于在发生错误时引起恐慌，还用于大声呼喊阻止您继续计算的悲剧是什么。</p><p id="f835" class="pw-post-body-paragraph il im hi in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji hb bi translated"><code class="du jj jk jl jm b">Option</code>当然太简单了，但这就是为什么有<code class="du jj jk jl jm b">Either</code>。就其一般形式而言，<code class="du jj jk jl jm b">Either</code>就像是两种价值观的结合，只不过是兴奋剂。一个<code class="du jj jk jl jm b">Either[A, B]</code>实例只能包含一个元素，但是这个元素可以是<code class="du jj jk jl jm b">A</code>或者<code class="du jj jk jl jm b">B</code>类型。类似于<code class="du jj jk jl jm b">Option[A]</code>有两个子类:<code class="du jj jk jl jm b">Some[A]</code>和<code class="du jj jk jl jm b">None</code>，<code class="du jj jk jl jm b">Either[A, B]</code>也有两个:<code class="du jj jk jl jm b">Left[A]</code>和<code class="du jj jk jl jm b">Right[B]</code>。所以每次我们有一个函数</p><pre class="kp kq kr ks fd kz jm la lb aw lc bi"><span id="f9aa" class="jn jo hi jm b fi ld le l lf lg">def partialFoo(...): B</span></pre><p id="76a4" class="pw-post-body-paragraph il im hi in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji hb bi translated">可以抛出一个异常，我们可以把它转换成</p><pre class="kp kq kr ks fd kz jm la lb aw lc bi"><span id="2a9a" class="jn jo hi jm b fi ld le l lf lg">def totalFoo(...): Either[A, B]</span></pre><p id="0c4f" class="pw-post-body-paragraph il im hi in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji hb bi translated">其中<code class="du jj jk jl jm b">B</code>是有效结果的类型，而<code class="du jj jk jl jm b">A</code>是描述错误的数据结构。</p><figure class="kp kq kr ks fd ii er es paragraph-image"><div role="button" tabindex="0" class="kt ku di kv bf kw"><div class="er es ko"><img src="../Images/f186a7044ed05be68ee1c4e912461dce.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*N820jJtjFNocsIxt"/></div></div></figure><p id="06b8" class="pw-post-body-paragraph il im hi in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji hb bi translated">但是等等，还有更多。我选择<code class="du jj jk jl jm b">B</code>作为有效结果的类型是有原因的。为了使<code class="du jj jk jl jm b">Either</code>成为单子，必须有一个偏好:<code class="du jj jk jl jm b">unit</code>方法必须只有一个参数，即元素本身，并且它必须自己选择使用哪个子类。此外，<code class="du jj jk jl jm b">flatMap</code>方法需要选择它采用什么“路径”——我们是向左还是向右平面映射？Scala做了一个有利于<code class="du jj jk jl jm b">Right[B]</code>的武断决定，从而永远压迫左撇子，比如我(😢 ).得益于此，我们现在可以链接“eithers”:如果我们从一个函数返回一个结果作为一个<code class="du jj jk jl jm b">Either</code>，那么我们可以将它平面映射到另一个函数。然后，该函数将接收第一个函数的结果，但前提是该结果属于子类<code class="du jj jk jl jm b">Right[B]</code>。然后第二个函数可以产生另一个<code class="du jj jk jl jm b">Either[C, D]</code>类型的结果，这个结果可以链接到另一个函数，等等。</p><figure class="kp kq kr ks fd ii er es paragraph-image"><div role="button" tabindex="0" class="kt ku di kv bf kw"><div class="er es ko"><img src="../Images/82443fcd7efef8a4276b944ac4c628a9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*DZKdNOkrbABn3Ctk"/></div></div></figure><p id="08eb" class="pw-post-body-paragraph il im hi in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji hb bi translated">但是，如果这些链接的函数中的任何一个产生了错误，处理就在链中的该链接处停止，绕过所有连续的函数调用，并从整个链中返回错误。这就是使用一元进行错误处理的美妙之处:它的优点是只在一个地方处理异常，而没有异常造成的混乱。</p><pre class="kp kq kr ks fd kz jm la lb aw lc bi"><span id="c39e" class="jn jo hi jm b fi ld le l lf lg">case class Error(msg: String)<br/>def makeX(t: T): Either[Error, X]<br/>def makeY(x: X): Either[Error, Y]<br/>def makeZ(y: Y): Either[Error, Z]<br/>val t = T()<br/>val result: Either[Error, Z] = <br/>  makeX(t).flatMap(makeY).flatMap(makeZ)<br/>// the result is either the valid outcome of <br/>// the whole flat-map chain, or the first of the encountered errors</span></pre><p id="cc2e" class="pw-post-body-paragraph il im hi in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji hb bi translated">理论上来说，<code class="du jj jk jl jm b">Either</code>的左边部分可以用来做任何事情。只有一元规则的实现方式使它特别适合处理错误。我们使用数据本身——例如，如上所述，错误可以由描述错误的文本消息组成——但我们也可以利用类型系统并创建我们的错误层次结构。<code class="du jj jk jl jm b">Error</code>可以是一个特征，然后我们可以有IO错误、网络错误、无效状态错误等类别。这就是默认的Java异常层次结构的工作方式，如果我们觉得懒惰，我们可以使用那个层次结构，而不是创建我们自己的层次结构。例如:</p><pre class="kp kq kr ks fd kz jm la lb aw lc bi"><span id="4374" class="jn jo hi jm b fi ld le l lf lg">def petBlackCat(cat: Cat): Either[Throwable, Purr] = <br/>  if (cat.colour != Black) <br/>    Left(new IllegalArgumentException(“this is not a black cat”))<br/>  else <br/>    Right(pet(cat)) // the method `pet` produces a purr</span></pre><p id="6718" class="pw-post-body-paragraph il im hi in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji hb bi translated">在下一个视频中，我们将继续这个话题，讨论<code class="du jj jk jl jm b">Try</code>单子、<code class="du jj jk jl jm b">for/yield</code>语法，以及单子到底是什么的一些理论。到时候见。</p><p id="ebb4" class="pw-post-body-paragraph il im hi in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji hb bi translated">前情提要:<a class="ae lh" rel="noopener" href="/nerd-for-tech/programming-with-functions-7-expressions-over-statements-20fbb7a9114d">语句上的表情</a></p><h2 id="5c31" class="jn jo hi bd jp jq jr js jt ju jv jw jx iw jy jz ka ja kb kc kd je ke kf kg kh bi translated">链接</h2><ul class=""><li id="4e68" class="lj lk hi in b io ki is kj iw ll ja lm je ln ji lo lp lq lr bi translated">Scala文档中的<a class="ae lh" href="https://www.scala-lang.org/api/current/scala/Option.html" rel="noopener ugc nofollow" target="_blank">选项</a></li><li id="4b07" class="lj lk hi in b io ls is lt iw lu ja lv je lw ji lo lp lq lr bi translated"><a class="ae lh" href="https://www.scala-lang.org/api/current/scala/util/Either.html" rel="noopener ugc nofollow" target="_blank">在Scala文档中</a></li><li id="27f2" class="lj lk hi in b io ls is lt iw lu ja lv je lw ji lo lp lq lr bi translated"><a class="ae lh" href="https://alvinalexander.com/scala/handling-nested-options-with-flatmap-for/" rel="noopener ugc nofollow" target="_blank"> Alvin Alexander关于Option + flatMap的文章</a>(在那里你可以找到他关于这个主题的其他文章的链接)</li></ul></div></div>    
</body>
</html>