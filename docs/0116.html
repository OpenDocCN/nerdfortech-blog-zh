<html>
<head>
<title>Python and Kafka: message passing and more</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python和卡夫卡:消息传递及更多</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/python-and-kafka-message-passing-and-more-44ccb4f1576c?source=collection_archive---------1-----------------------#2020-03-24">https://medium.com/nerd-for-tech/python-and-kafka-message-passing-and-more-44ccb4f1576c?source=collection_archive---------1-----------------------#2020-03-24</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="b196" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在开发人员职业生涯的许多阶段，他/她必须构建能够与他人通信的系统。例如，可能有两个<strong class="ih hj"> <em class="jd"> python </em> </strong>程序，第二个程序的操作可能依赖于第一个程序的输出。线性序列中可以有多个程序，每个连续的程序都依赖于前一个程序的输出。线性序列甚至可以根据前一个程序的输出分支到两个子程序。下面是一个<strong class="ih hj"> <em class="jd">依赖图</em> </strong>的例子。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div class="er es je"><img src="../Images/cec0a809dced1256f7abbe2c2e811369.png" data-original-src="https://miro.medium.com/v2/resize:fit:1202/format:webp/1*w7Bht4t-dwqjDDtYlBdFqQ.jpeg"/></div><figcaption class="jm jn et er es jo jp bd b be z dx translated">图python程序的依赖图</figcaption></figure><p id="422d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如图1所示，程序2依赖于程序1的输出。类似地，程序3依赖于程序2的输出。程序3又分支成两个子程序，接受来自程序3的输出。如果开发人员的目标是让程序4和程序5并行运行，那么他/她必须以多线程的方式对这些程序进行异步调用。由于python本身并不是线程安全的，所以创建可伸缩的多线程系统变得有点困难。这就是<strong class="ih hj"> <em class="jd">阿帕奇卡夫卡</em> </strong>可以用的地方。</p><p id="2566" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在讨论Apache Kafka  的实现和与Python的集成之前，让我先简单介绍一下它。</p><p id="4b14" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">由<strong class="ih hj"> LinkedIn开发的软件平台Kafka </strong>是一个开源的流处理管道，后来被捐赠给了<strong class="ih hj"> Apache软件基金会。</strong></p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jr js di jt bf ju"><div class="er es jq"><img src="../Images/1de63faf322d4ce79040355ae62d3b8e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8GbrXbHdH5uPGMb5epWhrg.png"/></div></div><figcaption class="jm jn et er es jo jp bd b be z dx translated"><a class="ae jv" href="https://kafka.apache.org/images/logo.png" rel="noopener ugc nofollow" target="_blank">https://kafka.apache.org/</a><a class="ae jv" href="https://kafka.apache.org/" rel="noopener ugc nofollow" target="_blank">的阿帕奇标志</a></figcaption></figure><p id="a5e5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">正如官方<strong class="ih hj"> Apache </strong>网站上提到的，<strong class="ih hj"> Kafka </strong>可用于创建<strong class="ih hj">数据管道</strong>，这些管道可横向扩展、速度极快且具有容错能力。</p><p id="bce8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">上面给出的涉及python程序的用例并不是一个精确的流管道，但是Kafka  可以用来解决向程序发送消息以供执行的问题，也可以用来在程序之间水平缩放信息。</p><p id="ae60" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们向前看，看看如何做到这一点。</p><h1 id="75c8" class="jw jx hi bd jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt bi translated"><strong class="ak"> 1。在Ubuntu和Confluent上安装Kafka-Kafka for python:</strong></h1><p id="e5de" class="pw-post-body-paragraph if ig hi ih b ii ku ik il im kv io ip iq kw is it iu kx iw ix iy ky ja jb jc hb bi translated">为了安装Kafka，只需按照<a class="ae jv" href="https://www.digitalocean.com/community/tutorials/how-to-install-apache-kafka-on-ubuntu-18-04" rel="noopener ugc nofollow" target="_blank"> <strong class="ih hj">这个</strong> </a>在<a class="ae jv" href="https://www.digitalocean.com/" rel="noopener ugc nofollow" target="_blank"> <strong class="ih hj"> DigitalOcean </strong> </a>上给出的Ubuntu 18安装教程。</p><p id="f86e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><a class="ae jv" href="https://www.confluent.io/" rel="noopener ugc nofollow" target="_blank"><strong class="ih hj"><em class="jd">confuent-Kafka</em></strong></a>是Kafka服务的全托管企业平台。</p><p id="8fa2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Confluent还为Kafka出货了一个<strong class="ih hj"> <em class="jd"> Python客户端</em> </strong>，可以用来直接集成Kafka和Python。这个客户端可以用来创建主题、删除主题以及发送和接收消息。</p><h1 id="59d0" class="jw jx hi bd jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt bi translated">2.通过python使用Kafka:</h1><p id="6384" class="pw-post-body-paragraph if ig hi ih b ii ku ik il im kv io ip iq kw is it iu kx iw ix iy ky ja jb jc hb bi translated">让我们开始制作项目文件夹。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div class="er es kz"><img src="../Images/678df03cea1b7fedafa1114f6c4d2a56.png" data-original-src="https://miro.medium.com/v2/resize:fit:706/format:webp/1*4nvSxxZ2jc6yPlYFwxg4wQ.jpeg"/></div><figcaption class="jm jn et er es jo jp bd b be z dx translated">图2:项目文件夹</figcaption></figure><p id="2d40" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们将使用Docker进行实验，因为它是一项很棒的技术，让开发人员的生活变得极其简单。</p><p id="2697" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">一个好的做法是有两个项目文件夹，但对于这个实验，将只使用一个。为了执行python程序，我们将进入容器内部，手动运行它们。</p><blockquote class="la lb lc"><p id="59ba" class="if ig jd ih b ii ij ik il im in io ip ld ir is it le iv iw ix lf iz ja jb jc hb bi translated">如果你想要一个关于使用Docker和python的教程，看看这些博客-&gt; <a class="ae jv" rel="noopener" href="/@abose550/installing-tensorflow-2-0-on-ubuntu-18-04-using-docker-run-all-experiments-from-a-container-4be9c2a8004d"> <strong class="ih hj"> Docker和Tensorflow </strong> </a> <strong class="ih hj">还有</strong> <a class="ae jv" rel="noopener" href="/@abose550/deep-learning-for-production-deploying-yolo-using-docker-2c32bb50e8d6"> <strong class="ih hj"> Docker和YOLO </strong> </a></p></blockquote><p id="8b31" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们现在开始检查这些文件。</p><p id="3b47" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Config.yml : 包含主题列表以及两个程序将要读取的内容。还包含代理信息。一个kafka主题为一定数量的主题保留了一定的信息。卡夫卡的主题也可以被分解成分区。然后，用户可以在这些分区中发送特定的消息。要了解更多关于卡夫卡主题和分区的内容，请查看此链接- &gt; <a class="ae jv" href="http://cloudurable.com/blog/kafka-architecture-topics/index.html" rel="noopener ugc nofollow" target="_blank"> <strong class="ih hj"> <em class="jd">卡夫卡主题和分区</em> </strong> </a> <strong class="ih hj"> <em class="jd">。</em></strong>Kafka消费者阅读来自特定主题的消息，Kafka向主题产生/发送消息。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div class="er es lg"><img src="../Images/3b89a889f1d8b5874c3a595bbf962854.png" data-original-src="https://miro.medium.com/v2/resize:fit:1018/format:webp/1*IFfYGEzlKdLQtfqEEBVShQ.jpeg"/></div><figcaption class="jm jn et er es jo jp bd b be z dx translated">图3:主题的配置文件</figcaption></figure><p id="25e2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> KafaConsumer.py和KafkaProducer.py : </strong>这两个文件包含了<strong class="ih hj"> <em class="jd"> Kafka消费者</em> </strong>和<strong class="ih hj"> <em class="jd"> Kafka生产者的类。</em> </strong>完整信息请参考<a class="ae jv" href="https://github.com/AbhishekBose/kafka_python" rel="noopener ugc nofollow" target="_blank"><strong class="ih hj"><em class="jd">github repo</em></strong></a>。下面给出的链接。这两个文件包含使用来自<strong class="ih hj"><em class="jd">confluent _ Kafka</em></strong>library . main(operation，x，y)的<strong class="ih hj">消费者</strong>和<strong class="ih hj">生产者</strong>类创建的类</p><p id="1edd" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> Dockerfile: </strong>包含我们将要生成的docker容器的配置。这将使用一个<strong class="ih hj"> python:3.8镜像</strong>并使用<strong class="ih hj"> requirements.txt </strong>文件安装所有需要的库。使用<strong class="ih hj"> ADD </strong>命令将项目文件夹添加到容器中，如下图4所示。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jr js di jt bf ju"><div class="er es lh"><img src="../Images/9050c2968f8fd0ce5b721b63daa7e9d1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Fk5rGui4NbxAvvnBLYbmJg.jpeg"/></div></div><figcaption class="jm jn et er es jo jp bd b be z dx translated">图4:docker文件</figcaption></figure><p id="9004" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> Requirements.txt </strong>:包含这个项目所有python库的列表</p><p id="5a9f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> python_1.py : </strong>这个文件的任务是向主题发送一条消息，这条消息将被第二个python代码读取。使用<strong class="ih hj"> PyYaml库读取<strong class="ih hj">配置文件</strong>。</strong>定义为<strong class="ih hj"> main(operation，x，y) </strong>的函数初始化名为prod的生产者对象，并向其发送消息。该消息是json格式的，可以在第二个程序中读取。在这个例子中，第二个函数将执行两个操作，即加法和减法。操作和运算符作为命令行参数。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jr js di jt bf ju"><div class="er es li"><img src="../Images/8bb7c8097c2c0d5d46a523bfc32298d8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CO_s7768bEv5xALKw5y-rw.jpeg"/></div></div><figcaption class="jm jn et er es jo jp bd b be z dx translated">图5:显示了为特定主题生成消息的程序</figcaption></figure><p id="c8e1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> python_2.py: </strong>这段代码本质上将包含消费者。消费者将阅读主题，其中<strong class="ih hj"> python_1.py </strong>将产生消息。这两个函数分别定义为<strong class="ih hj"><em class="jd">【x，y】add</em></strong>和<strong class="ih hj"> <em class="jd"> subtract(x，y)。</em> </strong>这些功能将被接收的两个操作符执行操作，如图6.1所示。图6.2中定义的主要函数是while循环，它不断地从消费者主题中读取信息。该函数通过读取json格式的消息来检查前面代码发送的<strong class="ih hj">操作</strong>，并调用相应的函数。如果消息中的运算符是<strong class="ih hj"> <em class="jd">和</em> </strong>，则调用<strong class="ih hj">加</strong>函数，否则调用<strong class="ih hj">减</strong>函数。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div class="er es lj"><img src="../Images/518a94b8366b5b6c697eec314aedabd2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1118/format:webp/1*cDn_HI9hxoFFFMRA273Z8A.jpeg"/></div><figcaption class="jm jn et er es jo jp bd b be z dx translated">图6.1:显示了将要调用的两个函数。</figcaption></figure><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jr js di jt bf ju"><div class="er es lk"><img src="../Images/47d5dfd5b7c2281cc00484f5536ee229.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*aMkG3vQqVpUT02uK9d8sqQ.jpeg"/></div></div><figcaption class="jm jn et er es jo jp bd b be z dx translated">图6.2:显示了从消费者主题中读取的主函数。</figcaption></figure><h1 id="5eba" class="jw jx hi bd jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt bi translated"><strong class="ak"> 3。构建映像并运行容器:</strong></h1><p id="ac75" class="pw-post-body-paragraph if ig hi ih b ii ku ik il im kv io ip iq kw is it iu kx iw ix iy ky ja jb jc hb bi translated">为了构建映像，请键入以下命令:</p><pre class="jf jg jh ji fd ll lm ln lo aw lp bi"><span id="a072" class="lq jx hi lm b fi lr ls l lt lu">docker build -t 'image_name' .</span></pre><p id="ebf2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">构建映像后，通过键入以下命令生成一个容器:</p><pre class="jf jg jh ji fd ll lm ln lo aw lp bi"><span id="45ad" class="lq jx hi lm b fi lr ls l lt lu">docker run -it -d --name=container_name --network=host image_name</span></pre><h1 id="41d3" class="jw jx hi bd jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt bi translated"><strong class="ak"> 4。执行程序:</strong></h1><p id="5073" class="pw-post-body-paragraph if ig hi ih b ii ku ik il im kv io ip iq kw is it iu kx iw ix iy ky ja jb jc hb bi translated">通过键入以下命令进入容器内部:</p><pre class="jf jg jh ji fd ll lm ln lo aw lp bi"><span id="1082" class="lq jx hi lm b fi lr ls l lt lu">docker exec -it container_name  bash</span></pre><p id="9f71" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这能让你进去。上面的容器打开了容器内部的bash shell。</p><p id="fc7a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在两个单独的shells中运行以下命令来观察输出</p><p id="0bfa" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">首先运行消费者</p><pre class="jf jg jh ji fd ll lm ln lo aw lp bi"><span id="d223" class="lq jx hi lm b fi lr ls l lt lu">cd src<br/>python python2.py 0</span></pre><p id="5c40" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这里的0是<strong class="ih hj">客户端id </strong>，它为您的消费者提供了一个名称。您可以让<strong class="ih hj"> <em class="jd">多个消费者</em> </strong>阅读消费者主题。这确保了并行处理，如图7.1 中的<strong class="ih hj">所示。只需给每个<strong class="ih hj">消费者</strong>分配一个不同的<strong class="ih hj">客户id </strong>。</strong></p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jr js di jt bf ju"><div class="er es lv"><img src="../Images/37eafff9201f9a5ffbbea13d9dc77d8c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*aY-01qEPBZYG3a_erAywPw.jpeg"/></div></div><figcaption class="jm jn et er es jo jp bd b be z dx translated">图7.1:启动消费者</figcaption></figure><p id="f2ca" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在，通过以下方式执行生成器:</p><pre class="jf jg jh ji fd ll lm ln lo aw lp bi"><span id="d28c" class="lq jx hi lm b fi lr ls l lt lu">python python1.py 5 2 sum</span></pre><p id="c0f8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这里的运算是求和，<strong class="ih hj">运算符是5和2 </strong>(图7.2)</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jr js di jt bf ju"><div class="er es lw"><img src="../Images/bf7f8bb508c335c04c3a89fc9281732f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AnnjUCi-85d0Z68hQtyqsA.jpeg"/></div></div><figcaption class="jm jn et er es jo jp bd b be z dx translated">图7.2:用sum操作符执行的python1程序</figcaption></figure><p id="3c72" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在图7.3中，可以立即看到对之前的shell进行加法操作的结果</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jr js di jt bf ju"><div class="er es lx"><img src="../Images/a7e02c7cb00a0b62b1861e4cf8a6318d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*b-5s2RcJoInCfZm0Y_cqCg.jpeg"/></div></div><figcaption class="jm jn et er es jo jp bd b be z dx translated">图7.3:可以看到输出消息和结果7</figcaption></figure><h1 id="d1c7" class="jw jx hi bd jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt bi translated"><strong class="ak"> 5。结论:</strong></h1><p id="03cc" class="pw-post-body-paragraph if ig hi ih b ii ku ik il im kv io ip iq kw is it iu kx iw ix iy ky ja jb jc hb bi translated">这个项目是卡夫卡如何被广泛用于创建大规模并行数据管道的一个基本例子。在<a class="ae jv" href="https://nayan.co" rel="noopener ugc nofollow" target="_blank"> <strong class="ih hj">阎娜科技</strong> </a>我们广泛使用<strong class="ih hj">卡夫卡</strong>用于我们的深度学习推理和训练数据管道。</p><p id="db78" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> Github回购</strong>:<a class="ae jv" href="https://github.com/AbhishekBose/kafka_python" rel="noopener ugc nofollow" target="_blank"><strong class="ih hj"><em class="jd">https://github.com/AbhishekBose/kafka_python</em></strong></a></p></div></div>    
</body>
</html>