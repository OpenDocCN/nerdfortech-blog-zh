<html>
<head>
<title>How to implement Material UI Data Grid in your Project — Part-II</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在您的项目中实现材质UI数据网格—第二部分</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/how-to-implement-material-ui-data-grid-in-your-project-part-ii-e94d91bfea36?source=collection_archive---------2-----------------------#2021-09-06">https://medium.com/nerd-for-tech/how-to-implement-material-ui-data-grid-in-your-project-part-ii-e94d91bfea36?source=collection_archive---------2-----------------------#2021-09-06</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><h1 id="0c4c" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">列定义</h1><p id="64d1" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">在Datagrid中，<strong class="jf hj">列</strong>道具是静态的，这意味着它不能在渲染之间改变。一旦安装了组件，就不能更改。</p><p id="15a3" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">关于<strong class="jf hj">头</strong> —它有类似<strong class="jf hj">头名</strong>和<strong class="jf hj">描述</strong> <a class="ae kg" href="https://arjunvaidy.medium.com/how-to-implement-material-ui-data-grid-in-your-project-part-i-7a40be743a6e" rel="noopener"> <strong class="jf hj">(前文中解释的</strong>)</a>的属性</p><h1 id="5122" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">大小</h1><p id="62f7" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">关于列的<strong class="jf hj">大小，其默认宽度为<strong class="jf hj">100像素。</strong>这是固定的，这意味着无论整个网格大小(表格大小)是多少，它都会保持<strong class="jf hj">100像素。</strong>我们可以通过使用属性<strong class="jf hj">‘宽度’</strong>来改变这个值</strong></p><p id="ace5" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated"><code class="du kh ki kj kk b">Const columns = [{field:'name',width:150}]</code></p><p id="8bba" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">如果网格尺寸小于列宽，它将显示一个水平滚动条</p><figure class="km kn ko kp fd kq er es paragraph-image"><div class="er es kl"><img src="../Images/ee62a3cf065e407c4111180e968f557c.png" data-original-src="https://miro.medium.com/v2/resize:fit:940/format:webp/1*5osbQe3mHgib3LBDEa44VA.png"/></div><figcaption class="kt ku et er es kv kw bd b be z dx translated">底部的水平滚动条</figcaption></figure><p id="6831" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">我们还可以将<strong class="jf hj"> minWidth </strong>属性设置为某个值。这将是列的最小宽度。这在像flex这样的响应式设计中非常有用。</p><p id="0eac" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated"><strong class="jf hj"> flex </strong>属性改变了流体宽度的绝对值。整列表现为flex——与CSS中的flex相同</p><p id="dec5" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">例如，假设网格的总宽度为500像素，每列的伸缩度为1。所以每列将占用<strong class="jf hj"> 250px </strong>每列<strong class="jf hj"> (1:1) </strong>。如果第一列的弯曲度为<strong class="jf hj"> 1.5 </strong>，第二列的弯曲度为<strong class="jf hj"> 1 </strong>。第一个会占用<strong class="jf hj">300像素</strong>，第二个会占用<strong class="jf hj">200像素(1.5:1) </strong>。这都归结为简单的比率计算。</p><p id="e926" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">注意<strong class="jf hj">:宽度</strong>和<strong class="jf hj">伸缩</strong>不会一起工作。在这种情况下，<strong class="jf hj"> flex覆盖宽度</strong>，但是<strong class="jf hj"> flex </strong>可以有<strong class="jf hj"> minWidth </strong>值，低于该值它不能移动</p><h1 id="f9d1" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">价值获取者</h1><p id="7c7e" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">简单地说，<strong class="jf hj"> valueGetter </strong>使您能够使用不同列的值。我们可以从不同的列中获取值，并进行类似连接的操作。这个结果值可以显示在单独的列中。</p><p id="d73c" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated"><strong class="jf hj"> valueGetter </strong>需要一个接受单元格参数的函数。有关电池参数<a class="ae kg" href="https://material-ui.com/api/data-grid/grid-cell-params/" rel="noopener ugc nofollow" target="_blank">的详细信息，请参见此处</a>。它有许多内置且易于访问的方法和属性。好了，让我们看一个例子</p><pre class="km kn ko kp fd kx kk ky kz aw la bi"><span id="cd3b" class="lb ig hi kk b fi lc ld l le lf">import * as React from 'react';<br/>import { DataGrid } from '@mui/x-data-grid';</span><span id="358a" class="lb ig hi kk b fi lg ld l le lf">// params has method called <strong class="kk hj">getValue</strong>(<strong class="kk hj">what id,which field</strong>) and returns the <strong class="kk hj">value</strong> of the particulat cell</span><span id="b0c6" class="lb ig hi kk b fi lg ld l le lf">const <strong class="kk hj">getTotal</strong> = (params) =&gt; params.<strong class="kk hj">getValue(params.id, 'maths')</strong>  + params.<strong class="kk hj">getValue(params.id, 'science')</strong></span><span id="a868" class="lb ig hi kk b fi lg ld l le lf">const columns = [<br/>{ field: 'maths', headerName: 'Maths', width: 130 },<br/>{ field: 'science', headerName: 'Science', width: 130 },<br/><strong class="kk hj">{<br/>field: 'Total',<br/>headerName: 'Total marks',<br/>width: 160,<br/>valueGetter: getTotal,<br/>},</strong><br/>];<br/>const rows = [<br/>{ id: 1, maths: 75, science: 60 },<br/>{ id: 2, maths: 80, science: 70 },<br/>{ id: 3, maths: 50, science: 80 },<br/>{ id: 4, maths: 80, science: 60 },<br/>{ id: 5, maths: 100, science: 90 },<br/>];</span><span id="f5f6" class="lb ig hi kk b fi lg ld l le lf">export default function ValueGetterGrid() {</span><span id="9ba0" class="lb ig hi kk b fi lg ld l le lf">return (</span><span id="2020" class="lb ig hi kk b fi lg ld l le lf">&lt;div style={{ height: 400, width: '100%' }}&gt;<br/>&lt;DataGrid rows={rows} columns={columns} /&gt;<br/>&lt;/div&gt;</span><span id="09cc" class="lb ig hi kk b fi lg ld l le lf">);<br/>}</span></pre><figure class="km kn ko kp fd kq"><div class="bz dy l di"><div class="lh li l"/></div><figcaption class="kt ku et er es kv kw bd b be z dx translated">显示valueGetter属性演示的数据网格示例</figcaption></figure><p id="0571" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">我们有三个栏目数学、科学和总分。</p><p id="50b4" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">这里，前两个字段是独立的，第三个字段依赖于前两个字段。</p><p id="785e" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">因此，我在第三列上使用了<strong class="jf hj"> valueGetter </strong>属性来使用前两列，并定义了<strong class="jf hj"> getTotal </strong>函数来显示结果。</p><h1 id="8788" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">值格式化程序</h1><p id="5aa2" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">当rows数组中有嵌套对象时，这个属性特别有用(我个人的用例)。它格式化单个列中的值。</p><pre class="km kn ko kp fd kx kk ky kz aw la bi"><span id="e864" class="lb ig hi kk b fi lc ld l le lf">import * as React from 'react';<br/>import { DataGrid } from '@mui/x-data-grid';</span><span id="1bb3" class="lb ig hi kk b fi lg ld l le lf">const rows = [<br/>{<br/>id:1,</span><span id="17f9" class="lb ig hi kk b fi lg ld l le lf"><strong class="kk hj">// nested objects</strong><br/><strong class="kk hj">place:{<br/>pincode:613007,<br/>name:'Thanjavur'<br/>}</strong><br/>},<br/>{<br/>id: 2,</span><span id="045e" class="lb ig hi kk b fi lg ld l le lf"><strong class="kk hj">// nested objects<br/>place:{<br/>pincode:600028,<br/>name:'Chennai'<br/>}</strong><br/>},<br/>{<br/>id: 3,</span><span id="21d6" class="lb ig hi kk b fi lg ld l le lf"><strong class="kk hj">// nested objects<br/>place:{<br/>pincode:641001,<br/>name:'Coimbatore'<br/>}</strong><br/>},<br/>];</span><span id="1c74" class="lb ig hi kk b fi lg ld l le lf">export default function ValueFormatterGrid() {<br/>return (<br/>&lt;div style={{ height: 300, width: '100%' }}&gt;</span><span id="635d" class="lb ig hi kk b fi lg ld l le lf">&lt;DataGrid<br/>rows={rows}<br/>columns={[<br/>{<br/>field: 'place',<br/>headerName: 'Place',<br/>width: 150,</span><span id="d27c" class="lb ig hi kk b fi lg ld l le lf">// Takes the value from nested object<br/><strong class="kk hj">valueFormatter: (params) =&gt; params.value.name</strong></span><span id="d4a2" class="lb ig hi kk b fi lg ld l le lf">},<br/>]}</span><span id="1f18" class="lb ig hi kk b fi lg ld l le lf">/&gt;<br/>&lt;/div&gt;</span><span id="b01d" class="lb ig hi kk b fi lg ld l le lf">);</span><span id="c402" class="lb ig hi kk b fi lg ld l le lf">}</span></pre><figure class="km kn ko kp fd kq"><div class="bz dy l di"><div class="lh li l"/></div></figure><p id="a49d" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">这里<strong class="jf hj"> valueFormatter </strong>从rows数组中的<strong class="jf hj"> place </strong>属性中提取<strong class="jf hj"> name </strong>值。</p><h1 id="33e1" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">值分析器</h1><p id="0fca" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">它与valueFormatter相反。用户输入的任何值都将被解析为某种格式。</p><pre class="km kn ko kp fd kx kk ky kz aw la bi"><span id="6398" class="lb ig hi kk b fi lc ld l le lf">import * as React from 'react';<br/>import { DataGrid } from '@mui/x-data-grid';</span><span id="2a8a" class="lb ig hi kk b fi lg ld l le lf">const rows = [<br/>{<br/>id: 1,<br/>taxRate: 0.1,<br/>},<br/>{<br/>id: 2,<br/>taxRate: 0.2,<br/>},<br/>{<br/>id: 3,<br/>taxRate: 0.3,<br/>},<br/>];</span><span id="e07e" class="lb ig hi kk b fi lg ld l le lf">export default function ValueParserGrid() {</span><span id="6141" class="lb ig hi kk b fi lg ld l le lf">return (<br/>&lt;div style={{ height: 300, width: '100%' }}&gt;<br/>&lt;DataGrid<br/>rows={rows}<br/>columns={[<br/>{<br/>type: 'number',<br/>field: 'taxRate',<br/>editable:true,<br/>headerName: 'Tax Rate',<br/>width: 150,<br/>valueFormatter: (params) =&gt; {<br/>const valueFormatted = Number(params.value * 100).toLocaleString();<br/>return `${valueFormatted} %`;<br/>},<br/>// Whatever value you enter will be divided by 100 simultaneously<br/><strong class="kk hj">valueParser: (value) =&gt; Number(value) / 100,</strong><br/>},<br/>]}<br/>/&gt;<br/>&lt;/div&gt;<br/>);<br/>}</span></pre><figure class="km kn ko kp fd kq"><div class="bz dy l di"><div class="lh li l"/></div><figcaption class="kt ku et er es kv kw bd b be z dx translated">打开沙盒并键入</figcaption></figure><p id="e924" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">本质上，valueFormater在显示之前格式化值，而valueParser实时格式化值(随着用户键入)</p><h1 id="0044" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">渲染单元</h1><p id="187c" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">默认情况下，单元格中显示的值将是一个字符串。值包含在DOM中的<div>中。这些<div>有许多属性</div></div></p><figure class="km kn ko kp fd kq er es paragraph-image"><div role="button" tabindex="0" class="lk ll di lm bf ln"><div class="er es lj"><img src="../Images/dcf0ba235333409e34f02998414a5956.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HBVidJzArthVQPRBRTMZuQ.png"/></div></div><figcaption class="kt ku et er es kv kw bd b be z dx translated"><div>数据网格单元的属性</div></figcaption></figure><p id="e4d0" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">对于renderCell属性，它可以使用单元格参数方法和属性完成valueFormatter和valueGetter的所有工作。但是它有额外的访问和操作DOM节点的能力。例如，在单元格内添加按钮或图标，将单元格更改为不同的组件。</p><p id="2e1b" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">renderCell属性需要一个接受GridCellParams并返回预期结果的函数</p><pre class="km kn ko kp fd kx kk ky kz aw la bi"><span id="459a" class="lb ig hi kk b fi lc ld l le lf">import * as React from "react";<br/>import { DataGrid } from "@material-ui/data-grid";<br/>import { TextField } from "@material-ui/core";</span><span id="fc83" class="lb ig hi kk b fi lg ld l le lf">const rows = [<br/>{<br/>id: 1,<br/>taxRate: 0.1<br/>},<br/>{<br/>id: 2,<br/>taxRate: 0.2<br/>},<br/>{<br/>id: 3,<br/>taxRate: 0.3<br/>}<br/>];</span><span id="9980" class="lb ig hi kk b fi lg ld l le lf">export default function RenderCell() {</span><span id="a139" class="lb ig hi kk b fi lg ld l le lf">return (</span><span id="7001" class="lb ig hi kk b fi lg ld l le lf">&lt;div style={{ height: 300, width: "100%" }}&gt;</span><span id="e8e3" class="lb ig hi kk b fi lg ld l le lf">&lt;DataGrid<br/>rows={rows}<br/>columns={[<br/>{<br/>field: "taxRate",<br/>headerName: "Tax Rate",</span><span id="ef5c" class="lb ig hi kk b fi lg ld l le lf"><strong class="kk hj">// renders default cell into TextField component</strong></span><span id="7c5c" class="lb ig hi kk b fi lg ld l le lf"><strong class="kk hj">renderCell: (params) =&gt; (<br/>&lt;&gt;<br/>&lt;TextField value={params.value} /&gt;<br/>&lt;/&gt;<br/>),</strong><br/>Width: 150,<br/>editable: true<br/>}<br/>]}<br/>/&gt;<br/>&lt;/div&gt;<br/>);<br/>}</span></pre><figure class="km kn ko kp fd kq"><div class="bz dy l di"><div class="lh li l"/></div></figure><p id="0b10" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">上述示例将普通单元格呈现到TextField组件中</p></div></div>    
</body>
</html>