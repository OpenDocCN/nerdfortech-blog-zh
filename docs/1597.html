<html>
<head>
<title>A Good Industry Practice to Preprocess data for ML model Training/Inferencing — tf.Transform</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">为 ML 模型训练/推理预处理数据的良好行业实践— tf。改变</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/a-good-industry-practice-to-preprocess-data-for-ml-model-training-inferencing-tf-transform-55ff36af952b?source=collection_archive---------9-----------------------#2021-03-27">https://medium.com/nerd-for-tech/a-good-industry-practice-to-preprocess-data-for-ml-model-training-inferencing-tf-transform-55ff36af952b?source=collection_archive---------9-----------------------#2021-03-27</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/6502294a1567a8fa96cb809171fa6df0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LLk-CVth1IsCoA3MvnxHuQ.jpeg"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">ML 模型推理流程</figcaption></figure><p id="b1c9" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">在大多数场景中，生产中的 ML/DL(机器学习/深度学习)解决方案使用 Tensorflow 来构建他们的产品。因为与 PyTorch 相比，Tensorflow(TF)拥有广泛的生产社区支持。(然而，PyTorch 由于其灵活性而成为 ML/DL 研究人员的首选)</p><p id="a88e" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">让我来解释一下数据预处理应该如何进行:</p><ol class=""><li id="500f" class="js jt hi iw b ix iy jb jc jf ju jj jv jn jw jr jx jy jz ka bi translated">始终将数据预处理组件与模型训练/推理组件分离。</li><li id="d9c7" class="js jt hi iw b ix kb jb kc jf kd jj ke jn kf jr jx jy jz ka bi translated">使用<strong class="iw hj"> tf。转换</strong>进行预处理</li></ol><p id="5318" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">我会回到为什么<strong class="iw hj"> tf。转型？</strong></p></div><div class="ab cl kg kh gp ki" role="separator"><span class="kj bw bk kk kl km"/><span class="kj bw bk kk kl km"/><span class="kj bw bk kk kl"/></div><div class="hb hc hd he hf"><h1 id="60c8" class="kn ko hi bd kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk bi translated">1.为什么我们需要将数据预处理组件与 ML 管道中的其他组件分离。？</h1><p id="db3d" class="pw-post-body-paragraph iu iv hi iw b ix ll iz ja jb lm jd je jf ln jh ji jj lo jl jm jn lp jp jq jr hb bi translated">什么是 ML 环境下的预处理？</p><blockquote class="lq lr ls"><p id="e3fa" class="iu iv lt iw b ix iy iz ja jb jc jd je lu jg jh ji lv jk jl jm lw jo jp jq jr hb bi translated">“将原始输入转换为特征以训练机器学习模型的过程”</p></blockquote><p id="384b" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">当您打算扩展您的模型以满足 10K 请求/秒时。当架构与预处理紧密耦合时，进行预处理的成本会很高。最好有一个单独的组件来执行预处理任务，并将特征存储在合适的存储区域，如 Feast(特征存储),这些特征可以由训练/服务组件读取。</p><p id="6cec" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">我们的模型架构应该以这样一种方式设计，即在初始训练期间执行的转换/预处理必须易于在下一次重新训练期间或者在服务/推理模型时重现。我们可以通过确保在模型图中保存转换或者通过创建转换特征的存储库来做到这一点。</p><p id="dd67" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw hj"> tf.transform </strong>提供了一种有效的方法，通过预处理传递数据来执行变换，并保存生成的特征和变换工件，以便在预测时间期间 TensorFlow 服务可以应用这些变换。"</p></div><div class="ab cl kg kh gp ki" role="separator"><span class="kj bw bk kk kl km"/><span class="kj bw bk kk kl km"/><span class="kj bw bk kk kl"/></div><div class="hb hc hd he hf"><h1 id="8f37" class="kn ko hi bd kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk bi translated">2.tf。转换实现</h1><p id="2d04" class="pw-post-body-paragraph iu iv hi iw b ix ll iz ja jb lm jd je jf ln jh ji jj lo jl jm jn lp jp jq jr hb bi translated">以下是我们通常作为良好实践遵循的高级步骤:</p><ol class=""><li id="2144" class="js jt hi iw b ix iy jb jc jf ju jj jv jn jw jr jx jy jz ka bi translated">创建一个 tf。转换预处理函数并通过它传递原始数据。</li><li id="b81f" class="js jt hi iw b ix kb jb kc jf kd jj ke jn kf jr jx jy jz ka bi translated">保存张量流变换层</li><li id="b410" class="js jt hi iw b ix kb jb kc jf kd jj ke jn kf jr jx jy jz ka bi translated">在模型服务时加载转换层</li><li id="ed19" class="js jt hi iw b ix kb jb kc jf kd jj ke jn kf jr jx jy jz ka bi translated">通过它传递推理数据以从原始输入中获取已处理的要素。</li></ol><p id="04d6" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">所有的 tf。转换保存为 TF 图，下面是模型服务期间的流程:</p><p id="48cf" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">在<a class="ae lx" href="https://www.tensorflow.org/tfx/transform/api_docs/python/tft" rel="noopener ugc nofollow" target="_blank"> tf 中。转换文档</a>您可以找到您的项目可能需要的几乎所有转换。</p><p id="cb1a" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">首先，我们需要创建一个函数，它将接受原始输入，然后使用<a class="ae lx" href="https://www.tensorflow.org/tfx/transform/api_docs/python/tft" rel="noopener ugc nofollow" target="_blank"> tf 将它们转换为我们需要的内容。转换 API</a>。</p><figure class="ly lz ma mb fd ij"><div class="bz dy l di"><div class="mc md l"/></div></figure><p id="a8cc" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">这里有一个例子，我们正在使用<strong class="iw hj"> scale_to_0_1 </strong>，它将在 0 到 1 之间缩放我们的图像像素张量值。</p><p id="f5ed" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">在我们开始训练之前，我们将所有的原始数据传递给上面的<code class="du me mf mg mh b">preprocessing_fn</code>，然后我们得到<strong class="iw hj">转换后的数据</strong>和<strong class="iw hj">转换层</strong></p><p id="2a28" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">可选地，我们可以将<strong class="iw hj"><em class="lt">transformed _ data</em></strong>保存为 TFRecords，它可以被训练组件有效地读取</p><figure class="ly lz ma mb fd ij"><div class="bz dy l di"><div class="mc md l"/></div></figure><p id="1554" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">在模型服务的时候，我们将加载 tf。变换图层。</p><p id="27ba" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">这是模型服务流的外观:</p><figure class="ly lz ma mb fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mi"><img src="../Images/5d715287d914432ab4380a57ae54bb47.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4v2fEaGXoX07TInE391eQA.jpeg"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">模型服务流程</figcaption></figure><p id="c55d" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">我们将原始输入传递给变换层，然后获取给定输入的特征，然后将这些特征传递给模型进行预测。</p><figure class="ly lz ma mb fd ij"><div class="bz dy l di"><div class="mc md l"/></div></figure><p id="7fd4" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">如果你想了解更多这方面的内容，可以联系我。</p></div></div>    
</body>
</html>