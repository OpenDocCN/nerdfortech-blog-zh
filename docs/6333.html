<html>
<head>
<title>LeetCode — Contiguous Array</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">LeetCode —连续数组</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/leetcode-contiguous-array-ca44062bf4d6?source=collection_archive---------1-----------------------#2022-02-05">https://medium.com/nerd-for-tech/leetcode-contiguous-array-ca44062bf4d6?source=collection_archive---------1-----------------------#2022-02-05</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><h1 id="6a83" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">问题陈述</h1><p id="e1dd" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">给定一个二进制数组 nums，返回 0 和 1 个数相等的连续子数组的最大长度。</p><p id="b7df" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">问题陈述摘自:<a class="ae kg" href="https://leetcode.com/problems/contiguous-array" rel="noopener ugc nofollow" target="_blank">https://leetcode.com/problems/contiguous-array</a>。</p><p id="2e38" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated"><strong class="jf hj">例一:</strong></p><pre class="kh ki kj kk fd kl km kn ko aw kp bi"><span id="f1a9" class="kq ig hi km b fi kr ks l kt ku">Input: nums = [0, 1] <br/>Output: 2 <br/>Explanation: [0, 1] is the longest contiguous subarray with an equal number of 0 and 1.</span></pre><p id="5601" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated"><strong class="jf hj">例二:</strong></p><pre class="kh ki kj kk fd kl km kn ko aw kp bi"><span id="9a40" class="kq ig hi km b fi kr ks l kt ku">Input: nums = [0, 1, 0] <br/>Output: 2 <br/>Explanation: [0, 1] (or [1, 0]) is a longest contiguous subarray with equal number of 0 and 1.</span></pre><p id="ba9e" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated"><strong class="jf hj">约束:</strong></p><pre class="kh ki kj kk fd kl km kn ko aw kp bi"><span id="d7d7" class="kq ig hi km b fi kr ks l kt ku">- 1 &lt;= nums.length &lt;= 10^5 <br/>- nums[i] is either 0 or 1</span></pre><h1 id="5414" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">说明</h1><h2 id="b4a9" class="kq ig hi bd ih kv kw kx il ky kz la ip jo lb lc it js ld le ix jw lf lg jb lh bi translated">强力方法</h2><p id="7f06" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">简单的方法是考虑数组的每个子集，并验证它是否有相等数量的 0 和 1。然后，我们找出具有相等数量的 0 和 1 的最大子数组。</p><p id="00f2" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">这种方法的一个 C++片段如下所示:</p><pre class="kh ki kj kk fd kl km kn ko aw kp bi"><span id="d9e6" class="kq ig hi km b fi kr ks l kt ku">int maxLength = 0;<br/><br/>for (int i = 0; i &lt; nums.size(); i++) {<br/>    int zeroes = 0, ones = 0;<br/>    for (int j = i; j &lt; nums.length; j++) {<br/>        if (nums[j] == 0) {<br/>            zeroes++;<br/>        } else {<br/>            ones++;<br/>        }<br/>        if (zeroes == ones) {<br/>            maxLength = Math.max(maxLength, j - i + 1);<br/>        }<br/>    }<br/>}<br/><br/>return maxLength;</span></pre><p id="e3d2" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">上述方法的时间复杂度为<strong class="jf hj"> O(N ) </strong>，对于大数组将超时。</p><h2 id="5925" class="kq ig hi bd ih kv kw kx il ky kz la ip jo lb lc it js ld le ix jw lf lg jb lh bi translated">使用附加阵列</h2><p id="cf78" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">在这种方法中，我们使用一个额外的大小为 2n + 1 的数组。我们使用一个额外的<strong class="jf hj"> sum </strong>变量，它将在遍历时跟踪数组元素的总和。当特定索引处的元素为 1 时，我们将使总和增加 1，如果该元素为 0，则将总和减少-1。</p><p id="e1f6" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">所以我们能达到的最大和最小和是 n 和-n，其中 n 是数组的大小。因此，我们创建一个大小为 2n + 1 的数组来跟踪目前为止遇到的各种总和。每当我们在遍历数组时遇到相同的和值，我们通过从当前索引中减去该索引处的值来计算子数组的长度。我们将上面的值与我们以前可能遇到的最大子阵列进行比较。</p><p id="7781" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">这种优化方法的 C++代码片段如下所示:</p><pre class="kh ki kj kk fd kl km kn ko aw kp bi"><span id="d111" class="kq ig hi km b fi kr ks l kt ku">int n = nums.size();<br/>int array[2 * n + 1];<br/>array[n] = -1;<br/>int maxLength = 0, count = 0;<br/><br/>for (int i = 0; i &lt; n; i++) {<br/>    count = count + (nums[i] == 0 ? -1 : 1);<br/><br/>    if (array[count + n] &gt;= -1) {<br/>        maxLength = max(maxLength, i - array[count + n]);<br/>    } else {<br/>        array[count + n] = i;<br/>    }<br/>}<br/><br/>return maxLength;</span></pre><p id="59e4" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">对于大小为 2n + 1 的数组，上述方法的时间复杂度为<strong class="jf hj"> O(N) </strong>，空间复杂度为<strong class="jf hj"> O(N) </strong>。</p><h2 id="aae5" class="kq ig hi bd ih kv kw kx il ky kz la ip jo lb lc it js ld le ix jw lf lg jb lh bi translated">使用哈希映射</h2><p id="2fa3" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">我们可以通过使用哈希映射而不是数组来将空间优化为 n。哈希映射将以 index-sum 的形式存储键值对。</p><p id="685b" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">每当我们第一次遇到一个和时，我们就在哈希表中为这个和创建一个条目，并将它的索引存储为值。如果我们再次遇到 sum，我们从当前索引中减去现有的索引(hash map 的值)。</p><p id="361a" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">我们来检查一下算法。</p><pre class="kh ki kj kk fd kl km kn ko aw kp bi"><span id="c0e9" class="kq ig hi km b fi kr ks l kt ku">- set unordered_map[int, int] = {0 , -1}<br/>  set maxLength = 0, sum = 0<br/><br/>- loop for i = 0; i &lt; nums.size(); i++<br/>  - sum = sum + (nums[i] == 1 ? 1 : -1)<br/><br/>  // the sum exists in the hash map update the maxLength<br/>  // else set the current index for that sum<br/>  - if m.count(sum)<br/>    - maxLength = max(maxLength, i - m[sum])<br/>  - else<br/>    - m[sum] = i<br/><br/>- return maxLength</span></pre><p id="c0fa" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">让我们看看我们在<strong class="jf hj"> C++ </strong>、<strong class="jf hj"> Golang </strong>和<strong class="jf hj"> Javascript </strong>中的解决方案。</p><h2 id="f0f3" class="kq ig hi bd ih kv kw kx il ky kz la ip jo lb lc it js ld le ix jw lf lg jb lh bi translated">C++解决方案</h2><pre class="kh ki kj kk fd kl km kn ko aw kp bi"><span id="c62b" class="kq ig hi km b fi kr ks l kt ku">class Solution {<br/>public:<br/>    int findMaxLength(vector&lt;int&gt;&amp; nums) {<br/>        unordered_map&lt;int, int&gt; m{{0, -1}};<br/>        int maxLength = 0, sum = 0;<br/><br/>        for(int i = 0; i &lt; nums.size(); i++) {<br/>            sum = sum + (nums[i] == 1 ? 1 : -1);<br/><br/>            if(m.count(sum)) {<br/>                maxLength = max(maxLength, i - m[sum]);<br/>            } else {<br/>                m[sum] = i;<br/>            }<br/>        }<br/><br/>        return maxLength;<br/>    }<br/>};</span></pre><h2 id="4319" class="kq ig hi bd ih kv kw kx il ky kz la ip jo lb lc it js ld le ix jw lf lg jb lh bi translated">戈朗溶液</h2><pre class="kh ki kj kk fd kl km kn ko aw kp bi"><span id="7577" class="kq ig hi km b fi kr ks l kt ku">func max(a, b int) int {<br/>    if a &gt; b {<br/>        return a<br/>    }<br/><br/>    return b<br/>}<br/><br/>func findMaxLength(nums []int) int {<br/>    m := make(map[int]int)<br/>    maxLength, sum := 0, 0<br/>    m[0] = -1<br/><br/>    for i := 0; i &lt; len(nums); i++ {<br/>        if nums[i] == 1 {<br/>            sum = sum + 1<br/>        } else {<br/>            sum = sum - 1<br/>        }<br/><br/>        if index, ok := m[sum]; ok  {<br/>            maxLength = max(maxLength, i - index)<br/>        } else {<br/>            m[sum] = i<br/>        }<br/>    }<br/><br/>    return maxLength<br/>}</span></pre><h2 id="632c" class="kq ig hi bd ih kv kw kx il ky kz la ip jo lb lc it js ld le ix jw lf lg jb lh bi translated">Javascript 解决方案</h2><pre class="kh ki kj kk fd kl km kn ko aw kp bi"><span id="bee5" class="kq ig hi km b fi kr ks l kt ku">var findMaxLength = function(nums) {<br/>    let m = {0: -1};<br/>    let maxLength = 0, sum = 0;<br/><br/>    for(let i = 0; i &lt; nums.length; i++) {<br/>        sum = sum + (nums[i] == 1 ? 1 : -1);<br/><br/>        if(m[sum] === undefined) {<br/>            m[sum] = i;<br/>        } else {<br/>            maxLength = Math.max(maxLength, i - m[sum]);<br/>        }<br/>    }<br/><br/>    return maxLength;<br/>};</span></pre><p id="e32e" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">让我们试运行一下我们的算法，看看解决方案是如何工作的。</p><pre class="kh ki kj kk fd kl km kn ko aw kp bi"><span id="f258" class="kq ig hi km b fi kr ks l kt ku">Input: [0, 1, 1, 0, 1, 1, 1, 0]<br/><br/>Step 1: unordered_map&lt;int, int&gt; m{{0, -1}}<br/>        maxLength = 0, sum = 0<br/><br/>Step 2: loop for i = 0; i &lt; nums.size()<br/>        0 &lt; 8<br/>        true<br/><br/>        sum = sum + (nums[i] == 1 ? 1 : -1)<br/>            = 0 + (nums[0] == 1 ? 1 : -1)<br/>            = 0 + (0 == 1 ? 1 : -1)<br/>            = 0 + -1<br/>            = -1<br/><br/>        if m.count(sum)<br/>           m.count(-1) // no key with -1<br/>           false<br/>        else<br/>           m[sum] = i<br/>           m[-1] = 0<br/><br/>        i++<br/>        i = 1<br/><br/>Step 3: i &lt; nums.size()<br/>        1 &lt; 8<br/>        true<br/><br/>        sum = sum + (nums[i] == 1 ? 1 : -1)<br/>            = -1 + (num[1] == 1 ? 1 : -1)<br/>            = -1 + (1 == 1 ? 1 : -1)<br/>            = -1 + 1<br/>            = 0<br/><br/>        if m.count(sum)<br/>           m.count(0) // has key with 0<br/>           true<br/><br/>           maxLength = max(maxLength, i - m[sum])<br/>                     = max(0, 1 - (-1))<br/>                     = max(0, 2)<br/>                     = 2<br/><br/>        i++<br/>        i = 2<br/><br/>Step 4: i &lt; nums.size()<br/>        2 &lt; 8<br/>        true<br/><br/>        sum = sum + (nums[i] == 1 ? 1 : -1)<br/>            = 0 + (num[2] == 1 ? 1 : -1)<br/>            = 0 + (1 == 1 ? 1 : -1)<br/>            = 0 + 1<br/>            = 1<br/><br/>        if m.count(sum)<br/>           m.count(1) // no key with -1<br/>           false<br/>        else<br/>           m[sum] = i<br/>           m[1] = 2<br/><br/>        i++<br/>        i = 3<br/><br/>Step 5: i &lt; nums.size()<br/>        3 &lt; 8<br/>        true<br/><br/>        sum = sum + (nums[i] == 1 ? 1 : -1)<br/>            = 1 + (num[3] == 1 ? 1 : -1)<br/>            = 1 + (0 == 1 ? 1 : -1)<br/>            = 1 + -1<br/>            = 0<br/><br/>        if m.count(sum)<br/>           m.count(0) // has key with 0<br/>           true<br/><br/>           maxLength = max(maxLength, i - m[sum])<br/>                     = max(2, 3 - (-1))<br/>                     = max(2, 4)<br/>                     = 4<br/><br/>        i++<br/>        i = 4<br/><br/>Step 6: i &lt; nums.size()<br/>        4 &lt; 8<br/>        true<br/><br/>        sum = sum + (nums[i] == 1 ? 1 : -1)<br/>            = 0 + (num[4] == 1 ? 1 : -1)<br/>            = 0 + (1 == 1 ? 1 : -1)<br/>            = 0 + 1<br/>            = 1<br/><br/>        if m.count(sum)<br/>           m.count(1) // has key with 1<br/>           true<br/><br/>           maxLength = max(maxLength, i - m[sum])<br/>                     = max(4, 4 - 2)<br/>                     = max(4, 2)<br/>                     = 2<br/><br/>        i++<br/>        i = 5<br/><br/>Step 7: i &lt; nums.size()<br/>        5 &lt; 8<br/>        true<br/><br/>        sum = sum + (nums[i] == 1 ? 1 : -1)<br/>            = 1 + (num[5] == 1 ? 1 : -1)<br/>            = 1 + (1 == 1 ? 1 : -1)<br/>            = 1 + 1<br/>            = 2<br/><br/>        if m.count(sum)<br/>           m.count(2) // no key with 2<br/>           false<br/>        else<br/>           m[sum] = i<br/>           m[2] = 5<br/><br/>        i++<br/>        i = 6<br/><br/>Step 8: i &lt; nums.size()<br/>        6 &lt; 8<br/>        true<br/><br/>        sum = sum + (nums[i] == 1 ? 1 : -1)<br/>            = 2 + (num[6] == 1 ? 1 : -1)<br/>            = 2 + (1 == 1 ? 1 : -1)<br/>            = 2 + 1<br/>            = 3<br/><br/>        if m.count(sum)<br/>           m.count(3) // no key with 3<br/>           false<br/>        else<br/>           m[sum] = i<br/>           m[3] = 6<br/><br/>        i++<br/>        i = 7<br/><br/>Step 9: i &lt; nums.size()<br/>        7 &lt; 8<br/>        true<br/><br/>        sum = sum + (nums[i] == 1 ? 1 : -1)<br/>            = 3 + (num[7] == 1 ? 1 : -1)<br/>            = 3 + (0 == 1 ? 1 : -1)<br/>            = 3 + -1<br/>            = 2<br/><br/>        if m.count(sum)<br/>           m.count(2) // has key with 0<br/>           true<br/><br/>           maxLength = max(maxLength, i - m[sum])<br/>                     = max(4, 7 - 5)<br/>                     = max(4, 2)<br/>                     = 4<br/><br/>        i++<br/>        i = 8<br/><br/>Step 10: i &lt; nums.size()<br/>         8 &lt; 8<br/>         false<br/><br/>Step 11: return maxLength<br/><br/>So we return the answer as 4.</span></pre></div><div class="ab cl li lj gp lk" role="separator"><span class="ll bw bk lm ln lo"/><span class="ll bw bk lm ln lo"/><span class="ll bw bk lm ln"/></div><div class="hb hc hd he hf"><p id="38bf" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated"><em class="lp">原载于</em><a class="ae kg" href="https://alkeshghorpade.me/post/leetcode-contiguous-array" rel="noopener ugc nofollow" target="_blank"><em class="lp">https://alkeshghorpade . me</em></a><em class="lp">。</em></p></div></div>    
</body>
</html>