<html>
<head>
<title>Modern Javascript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">现代Javascript</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/modern-javascript-a5c7dd9c2b07?source=collection_archive---------9-----------------------#2021-06-24">https://medium.com/nerd-for-tech/modern-javascript-a5c7dd9c2b07?source=collection_archive---------9-----------------------#2021-06-24</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/a1677d622eb0d8d4fb14b0af76d15746.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Vqqwc9b4xq1XK8NzgMw8qQ.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">(来源:<a class="ae iu" href="https://pureinfotech.com/set-print-screen-key-screenshot-screen-sketch-windows-10/" rel="noopener ugc nofollow" target="_blank">https://pure infotech . com/set-print-screen-key-screen-screen-sketch-windows-10/</a>)</figcaption></figure><p id="6775" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">你可能在这里或那里学过javascript，有些人可能在他们学校的IT课程中学过。但是当像MEAN和MERN这样的堆栈出现时，大多数开发人员开始学习JS。因为从那时起，JS在许多方面都发生了变化。<strong class="ix hj"> Ecma </strong>是JS的基础。每个开发人员都必须了解JS的基本原理。所以让我们来谈谈JS的一些现代概念。</p><h1 id="8ede" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">范围</h1><p id="4fd1" class="pw-post-body-paragraph iv iw hi ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated">在JS中有3种声明变量的方法，一种是使用<code class="du kw kx ky kz b">var</code>关键字，另一种是<code class="du kw kx ky kz b">let</code>，还有一种是<code class="du kw kx ky kz b">const</code>，但是有什么区别吗？</p><figure class="lb lc ld le fd ij er es paragraph-image"><div class="er es la"><img src="../Images/f8a2c4919d7b919f56f17bae551abe90.png" data-original-src="https://miro.medium.com/v2/resize:fit:770/format:webp/1*O6BVBuy517PoNz7R7DE4-A.png"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">1-scope.js</figcaption></figure><p id="58bb" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">考虑到上面的代码，当您运行这段代码时，它会给出如下输出:</p><pre class="lb lc ld le fd lf kz lg lh aw li bi"><span id="42a6" class="lj ju hi kz b fi lk ll l lm ln">i =0<br/>i =1<br/>i =2<br/>i =3<br/>i =4<br/>i =5<br/>i =6<br/>i =7<br/>i =8<br/>i =9<br/>k =9</span></pre><p id="3883" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">但是当你在第2行(<code class="du kw kx ky kz b">let k =i</code>)声明变量“<strong class="ix hj"> k </strong>”的时候用<code class="du kw kx ky kz b">let</code>代替<code class="du kw kx ky kz b">var</code>，那么会发生什么呢？你会得到这样的东西👉<code class="du kw kx ky kz b">ReferenceError: k is not defined</code></p><p id="abb0" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">因为用<code class="du kw kx ky kz b">let</code>关键字定义的变量在范围之外是不可见的。所以作为一个最佳实践，最好使用<code class="du kw kx ky kz b">let</code>关键字在一个冗长的脚本或项目的多个函数中声明变量。这使得调试更加容易。</p><h1 id="fdfb" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">常数</h1><p id="d8cc" class="pw-post-body-paragraph iv iw hi ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated">如果您在上述场景中使用了<code class="du kw kx ky kz b">const</code>，您将得到与<code class="du kw kx ky kz b">let</code>相同的响应，但原因不同。让我们看看为什么，</p><figure class="lb lc ld le fd ij er es paragraph-image"><div class="er es lo"><img src="../Images/1d353469df891f7aadb322da85d03e40.png" data-original-src="https://miro.medium.com/v2/resize:fit:554/format:webp/1*ClTgFsmq6c-6wPJAl1oWfQ.png"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">2-const.js</figcaption></figure><p id="8f95" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如果你运行这段代码，你会得到一个<code class="du kw kx ky kz b">TypeError</code>，因为我们试图改变常量变量。</p><figure class="lb lc ld le fd ij er es paragraph-image"><div class="er es lp"><img src="../Images/f75853f3c4df2ead0e15f4b67be591c2.png" data-original-src="https://miro.medium.com/v2/resize:fit:506/format:webp/1*sVREh6zU86SS9wZZm1NY6g.png"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">2-const.js</figcaption></figure><p id="c49e" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如果您运行这段代码，那么您将得到<code class="du kw kx ky kz b">[ 10, 20, 30 ]</code>作为输出。因为<code class="du kw kx ky kz b">const</code>只保护一个不是对象或数组的变量。所以你可以像上面的代码一样改变数组。</p></div><div class="ab cl lq lr gp ls" role="separator"><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv"/></div><div class="hb hc hd he hf"><h1 id="a1be" class="jt ju hi bd jv jw lx jy jz ka ly kc kd ke lz kg kh ki ma kk kl km mb ko kp kq bi translated">箭头功能</h1><p id="2465" class="pw-post-body-paragraph iv iw hi ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated">我们通常用JS写一个函数，</p><pre class="lb lc ld le fd lf kz lg lh aw li bi"><span id="eec5" class="lj ju hi kz b fi lk ll l lm ln">function functionName (parameter) {<br/>     //to-do<br/>}</span></pre><p id="8f7a" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">但是我们可以用新的方法用JS写一个函数，</p><pre class="lb lc ld le fd lf kz lg lh aw li bi"><span id="e171" class="lj ju hi kz b fi lk ll l lm ln">const functionName =(parameter) =&gt; {<br/>    //to-do<br/>}</span></pre><p id="18f4" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">或者如果函数体中只有一行，我们可以这样写:</p><pre class="lb lc ld le fd lf kz lg lh aw li bi"><span id="4bbc" class="lj ju hi kz b fi lk ll l lm ln">const functionName = (parameter) =&gt; //to-do;</span></pre><p id="e953" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这就是所谓的<strong class="ix hj">箭头功能。</strong>让我们看一个例子，</p><figure class="lb lc ld le fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mc"><img src="../Images/4f92c7bd39e8d1e8b414feffe40544c5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xN6SJdB1lKFR3rPlk3gM_A.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">3-箭头F1.js</figcaption></figure><p id="555f" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如果您运行上面的代码，您将得到如下输出:</p><pre class="lb lc ld le fd lf kz lg lh aw li bi"><span id="ac75" class="lj ju hi kz b fi lk ll l lm ln">10<br/>10<br/>10<br/>4</span></pre><p id="f876" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这就是箭头函数的妙处。</p><h1 id="4cd3" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">箭头函数的行为</h1><p id="f1e6" class="pw-post-body-paragraph iv iw hi ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated">尽管arrow function是用现代JS编写函数的另一种方式，但这两者的行为方式还是有一些不同。让我们看一个简单的例子，</p><figure class="lb lc ld le fd ij er es paragraph-image"><div class="er es md"><img src="../Images/810062dec10e11bcfebb991ce11f811f.png" data-original-src="https://miro.medium.com/v2/resize:fit:982/format:webp/1*n_MsVH-1neskk6bgbel2gg.png"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">4-arrowF2.js</figcaption></figure><p id="6586" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">所以如果你仔细观察上面的代码段，<strong class="ix hj"> print </strong>是一个对象变量，它有两个函数<strong class="ix hj"> function1 </strong>(普通函数)和<strong class="ix hj"> function2 </strong>(箭头函数)。当我们运行上面的代码时，输出会是什么？你会得到，</p><pre class="lb lc ld le fd lf kz lg lh aw li bi"><span id="5748" class="lj ju hi kz b fi lk ll l lm ln">1st function : { function1: [Function: function1], function2: [Function: function2] }<br/>2nd function : {}</span></pre><p id="e42a" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">因为在普通函数中，<code class="du kw kx ky kz b"><strong class="ix hj">this</strong></code> <strong class="ix hj"> </strong>关键字代表调用该函数的对象，同时在箭头函数中，<code class="du kw kx ky kz b"><strong class="ix hj">this</strong></code> <strong class="ix hj"> </strong>关键字代表定义箭头函数的对象。<a class="ae iu" href="https://www.w3schools.com/js/js_arrow_function.asp" rel="noopener ugc nofollow" target="_blank">点击此处</a>了解更多关于<code class="du kw kx ky kz b"><strong class="ix hj">this</strong></code> <strong class="ix hj"> </strong>关键词。所以不要混淆。</p></div><div class="ab cl lq lr gp ls" role="separator"><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv"/></div><div class="hb hc hd he hf"><h1 id="dd4f" class="jt ju hi bd jv jw lx jy jz ka ly kc kd ke lz kg kh ki ma kk kl km mb ko kp kq bi translated">目标</h1><p id="d5f9" class="pw-post-body-paragraph iv iw hi ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated">现在让我们看看我们可以在JS对象中做些什么。</p><figure class="lb lc ld le fd ij er es paragraph-image"><div class="er es me"><img src="../Images/b63cb649c463fcbcf905337b6b525509.png" data-original-src="https://miro.medium.com/v2/resize:fit:726/format:webp/1*iaAmzdSiYjwd-cni3JkB7A.png"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">5-object.js</figcaption></figure><p id="87da" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在上面的代码中，<code class="du kw kx ky kz b">demoObject</code>是一个应该有一个键:值对的对象。但是我用的是没有对子的<code class="du kw kx ky kz b">num</code>。如果我运行这个你会得到，</p><pre class="lb lc ld le fd lf kz lg lh aw li bi"><span id="0e21" class="lj ju hi kz b fi lk ll l lm ln">1.4142135623730951</span></pre><p id="e2a1" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">因为我已经声明并使用了该变量的其他模块(Math ),所以在这种情况下我们不需要将它指定为一个<strong class="ix hj"> key : value </strong>对。这实际上与<code class="du kw kx ky kz b">num:num;</code>类似，但没有必要放在这里。</p><p id="f5b2" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">让我们看另一个例子，</p><figure class="lb lc ld le fd ij er es paragraph-image"><div class="er es mf"><img src="../Images/2c77a8c340461b570bfba6147631dee7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1002/format:webp/1*tpY6dIPkOcByAfqHqmsGRg.png"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">5-object.js</figcaption></figure><p id="80c0" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在上面的代码中，<code class="du kw kx ky kz b">[status]</code>是第5行的键。那就是所谓的<strong class="ix hj">动态属性</strong>。这意味着如果键值是动态的，我们可以在对象中设置一个占位符作为键。假设您想通过服务向用户发送一个对象，您被告知键值不是静态的。在这种情况下，您可以将占位符设置为一个键，然后从用户那里获取值。所以如果运行代码你会得到，</p><pre class="lb lc ld le fd lf kz lg lh aw li bi"><span id="1275" class="lj ju hi kz b fi lk ll l lm ln">{ key: 'value', service: 'approved' }</span></pre><p id="3df2" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">为了演示，我将第1行中的占位符值设置为<code class="du kw kx ky kz b">service</code>。</p></div><div class="ab cl lq lr gp ls" role="separator"><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv"/></div><div class="hb hc hd he hf"><h1 id="0e69" class="jt ju hi bd jv jw lx jy jz ka ly kc kd ke lz kg kh ki ma kk kl km mb ko kp kq bi translated">冷冻法</h1><p id="deb6" class="pw-post-body-paragraph iv iw hi ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated">让我们看看另一个很酷的特性，</p><figure class="lb lc ld le fd ij er es paragraph-image"><div class="er es mg"><img src="../Images/3419061102ec1987625c80b35ef167c2.png" data-original-src="https://miro.medium.com/v2/resize:fit:732/format:webp/1*rEIkt74UrHqBEVpdskkOnQ.png"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">6-freeze.js</figcaption></figure><p id="2773" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在上面的代码中，我定义了一个带有一个空值键的对象，我正在设置值并打印它(暂时忘记注释)。然后我再次改变这个值，再次打印这个对象。所以如果你运行这个你会得到，</p><pre class="lb lc ld le fd lf kz lg lh aw li bi"><span id="8345" class="lj ju hi kz b fi lk ll l lm ln">{ x: 'alpha' }<br/>{ x: 'beta' }</span></pre><p id="1447" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">作为输出。那么，如果我取消第4行的注释并再次运行它，会发生什么呢？输出会是什么呢？</p><pre class="lb lc ld le fd lf kz lg lh aw li bi"><span id="9340" class="lj ju hi kz b fi lk ll l lm ln">{ x: 'alpha' }                                 <br/>{ x: 'alpha' }</span></pre><p id="89a7" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">您将得到这个输出。因为如果使用<strong class="ix hj">冻结，</strong>无论如何都不允许改变数值。因此，在工作时，假设你想在应用程序的所有服务中保持一个对象值不变，那么你可以冻结这个值并在服务中传递它。那么做下面的事情，</p><figure class="lb lc ld le fd ij er es paragraph-image"><div class="er es mh"><img src="../Images/db2ab371d02c7fbd8e2b8dbaa61a361c.png" data-original-src="https://miro.medium.com/v2/resize:fit:652/format:webp/1*CxZLz1mBb1GDmAGC2MvW2w.png"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">6-freeze.js</figcaption></figure><p id="cd4e" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">所以你认为一旦我打印出来，这个对象的值会是什么样子，</p><pre class="lb lc ld le fd lf kz lg lh aw li bi"><span id="9825" class="lj ju hi kz b fi lk ll l lm ln">{ x: ‘alpha’, y: 5 }<br/>{ x: ‘alpha’, y: 5 }</span></pre><p id="219c" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">但是不，如果我运行代码，输出将是，</p><pre class="lb lc ld le fd lf kz lg lh aw li bi"><span id="16af" class="lj ju hi kz b fi lk ll l lm ln">{ x: 'alpha', y: { z: 5 } }<br/>{ x: 'alpha', y: { z: '444' } }</span></pre><p id="2a7f" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">因为你需要记住<strong class="ix hj"> Object.freeze() </strong>方法只冻结第一级的值(不是第一级的第一个值)而不会冻结内部级的对象值。</p></div><div class="ab cl lq lr gp ls" role="separator"><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv"/></div><div class="hb hc hd he hf"><h1 id="c48e" class="jt ju hi bd jv jw lx jy jz ka ly kc kd ke lz kg kh ki ma kk kl km mb ko kp kq bi translated">模板</h1><p id="1f72" class="pw-post-body-paragraph iv iw hi ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated">让我们看看模板，</p><figure class="lb lc ld le fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mi"><img src="../Images/35d24e5b6610db311bef4c6583a08431.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xI-6KL1UKKF2FhYaq2V8vg.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">7-模板. js</figcaption></figure><p id="6b69" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如果你运行这个你会得到</p><pre class="lb lc ld le fd lf kz lg lh aw li bi"><span id="889d" class="lj ju hi kz b fi lk ll l lm ln">Edward Kenway born in England</span></pre><p id="5e36" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">所以模板不是一个大话题，但它是用来代替执行时间中的值。这些都是用美元符号和花括号写的。而且整个句子要在反斜杠(``)之间。</p></div><div class="ab cl lq lr gp ls" role="separator"><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv"/></div><div class="hb hc hd he hf"><h1 id="384d" class="jt ju hi bd jv jw lx jy jz ka ly kc kd ke lz kg kh ki ma kk kl km mb ko kp kq bi translated">JS中的类</h1><p id="ea00" class="pw-post-body-paragraph iv iw hi ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated">大多数人都是从Java或。Net作为他们的第一个面向对象编程语言。我们在这些语言中使用了类。众所周知，类是创建对象的模板，这里指的是JS对象。现在让我们看看JS中的类是如何工作的，</p><figure class="lb lc ld le fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mj"><img src="../Images/efc6a1e802529c9554aaf4ef72221431.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*q2s3GK9JN76ema4QqE0ybw.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">8类. js</figcaption></figure><p id="430a" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">通常在Java中，我们使用与类名同名的构造函数，但是在这里我们使用关键字<code class="du kw kx ky kz b">constructor</code>。即使我们在构造函数中使用了<code class="du kw kx ky kz b">name</code>(上面的代码),我们也不需要像在JAVA中那样声明。最重要的是，我们可以在通过对象调用时覆盖一个函数。所以如果你执行上面的代码，你会得到如下结果，</p><pre class="lb lc ld le fd lf kz lg lh aw li bi"><span id="a536" class="lj ju hi kz b fi lk ll l lm ln">Connor is an employee<br/>Edward is an Employee and Principal of VNC<br/>This function is overridden</span></pre><p id="2342" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">前两行输出是预期的，因为我已经从每个类中调用了这些函数。但是在覆盖之后，您可以看到输出为“这个函数被覆盖”。所以尽管这看起来完全像Java类，但实际上它模仿了。</p></div><div class="ab cl lq lr gp ls" role="separator"><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv"/></div><div class="hb hc hd he hf"><h1 id="f4c7" class="jt ju hi bd jv jw lx jy jz ka ly kc kd ke lz kg kh ki ma kk kl km mb ko kp kq bi translated">JS中的解构</h1><p id="e19d" class="pw-post-body-paragraph iv iw hi ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated">这是一个JS表达式，用于从JS对象的数组或属性中获取值。如果我们进行数组析构，我们可以在一行中分别声明两个变量并赋值，如下面的代码所示，</p><figure class="lb lc ld le fd ij er es paragraph-image"><div class="er es lo"><img src="../Images/358d55901b622764b68a8996c85f16b3.png" data-original-src="https://miro.medium.com/v2/resize:fit:554/format:webp/1*oOSCiA7x7eOx09dAU3_UUQ.png"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">9-destruct . js</figcaption></figure><p id="e123" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">所以你会得到，</p><pre class="lb lc ld le fd lf kz lg lh aw li bi"><span id="de71" class="lj ju hi kz b fi lk ll l lm ln">5<br/>10 </span></pre><p id="b9ce" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">作为输出。让我们再举一个例子，在下面的代码中有一个函数，我创建了一个带有一些键值的对象，然后创建了一个名为"<strong class="ix hj"> area" </strong>的函数，并将其中一个值<strong class="ix hj"> "Obj " </strong>作为参数传递。</p><figure class="lb lc ld le fd ij er es paragraph-image"><div class="er es mk"><img src="../Images/14ace43ed24ad6a4e3214d9c275fedd5.png" data-original-src="https://miro.medium.com/v2/resize:fit:766/format:webp/1*N3C-iJtosxmI_TapobkqCw.png"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">9-destruct . js</figcaption></figure><p id="5bf7" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">让我们看看如果我运行代码会发生什么，</p><pre class="lb lc ld le fd lf kz lg lh aw li bi"><span id="4cb9" class="lj ju hi kz b fi lk ll l lm ln">5.9049000000000005</span></pre><p id="8e1c" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我得到5.9049000000000005作为输出，因为我已经用<code class="du kw kx ky kz b">Obj</code>作为参数记录了函数，所以我不需要特别提到<code class="du kw kx ky kz b">Obj</code>的值(像<code class="du kw kx ky kz b">Obj.value</code>)。它自动从Obj中获取值。</p><p id="dcb4" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">假设我们用相同的代码打印了如下内容，</p><figure class="lb lc ld le fd ij er es paragraph-image"><div class="er es ml"><img src="../Images/bcd7d7771697059064e9874e31f702f8.png" data-original-src="https://miro.medium.com/v2/resize:fit:980/format:webp/1*Wtlvi3IAe0cz7HmgcMktIQ.png"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">9-destruct . js</figcaption></figure><p id="11ba" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">所以在上面的代码中，我添加了一个名为<code class="du kw kx ky kz b">area1</code>的函数，带有一个有趣的参数，我解释了它，正如我在前面的方法调用(<code class="du kw kx ky kz b">area</code>)中提到的，我将对象作为参数传递，但是在这里，我传递了对象以及带有条件的键值(<code class="du kw kx ky kz b">{value}, {round =3} ={}</code>)。基本上，如果给这一轮赋予任何值，它将取3。因此，输出将带有根据舍入值的小数位。所以如果我运行代码，</p><pre class="lb lc ld le fd lf kz lg lh aw li bi"><span id="ac7e" class="lj ju hi kz b fi lk ll l lm ln">5.905<br/>5.90490</span></pre><p id="f58d" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">正如我上面提到的，在第一个控制台中，我没有传递任何值给<code class="du kw kx ky kz b">round</code>，所以它只输出3个小数点，在第二个控制台日志中，我传递了5作为<code class="du kw kx ky kz b">round</code>变量的参数，所以它输出5个小数点。</p><p id="621f" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">让我们再举一个在文件处理中使用和不使用析构的例子，</p><figure class="lb lc ld le fd ij er es paragraph-image"><div class="er es mm"><img src="../Images/12c0158bc2fd5895add999e314e1ed92.png" data-original-src="https://miro.medium.com/v2/resize:fit:1310/format:webp/1*KnRlI9TCkleW9ykwbkgsgQ.png"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">9-destruct . js</figcaption></figure><p id="38a1" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如你所见，我们通常需要fs模块，并使用了一个变量，并使用该变量中的函数作为上面的代码。但是使用析构，我们可以这样写，</p><figure class="lb lc ld le fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mn"><img src="../Images/ccd5caeb6da689fa73dc4e1b5914e9c3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7FQmYaZ6qDB-3EMtUitIxg.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">9-destruct . js</figcaption></figure><p id="12dd" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">从上面的代码可以看出，我们不需要任何<code class="du kw kx ky kz b">const</code>来调用函数，我们可以直接调用我们想要的任何方法。所以这里我用了<code class="du kw kx ky kz b">writeFile</code>。让我们再举一个例子，</p><figure class="lb lc ld le fd ij er es paragraph-image"><div class="er es mo"><img src="../Images/4667d33e19dc60c95cfcb865ca68d87b.png" data-original-src="https://miro.medium.com/v2/resize:fit:804/format:webp/1*pE1b--rkdh6j4BShHxJW3w.png"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">9-destruct . js</figcaption></figure><p id="76ee" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">所以在上面的代码中，只有4个属性(其中一个为空)有5个值。如果你运行这个，</p><pre class="lb lc ld le fd lf kz lg lh aw li bi"><span id="5c50" class="lj ju hi kz b fi lk ll l lm ln">10<br/>50</span></pre><p id="9ff6" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在这里，它跳过空属性的值，并将该值赋给<code class="du kw kx ky kz b">d</code> <strong class="ix hj"> </strong>。<strong class="ix hj"> </strong>这就是为什么d的值打印为50。让我们看看如果我们稍微改变一下代码会发生什么，</p><figure class="lb lc ld le fd ij er es paragraph-image"><div class="er es mp"><img src="../Images/eccf1abdfefb1446fc02064d9f20ffeb.png" data-original-src="https://miro.medium.com/v2/resize:fit:946/format:webp/1*lpObi8pgptZwyWx5LuZ7Dg.png"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">9-destruct . js</figcaption></figure><p id="7daf" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这里有两个属性<code class="du kw kx ky kz b">a</code>和<code class="du kw kx ky kz b">otherValues</code>，如果我们运行代码，</p><pre class="lb lc ld le fd lf kz lg lh aw li bi"><span id="4bd7" class="lj ju hi kz b fi lk ll l lm ln">10<br/>[ 20, 30, 40, 50 ] </span></pre><p id="7238" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们知道<code class="du kw kx ky kz b">a</code>是10，但是<strong class="ix hj">扩展操作符</strong> (…)用来获得分配给<code class="du kw kx ky kz b">otherValues</code>属性的其余值。我们可以使用这个spread操作符将一个数组复制到另一个数组。让我们看看它是怎么做的，</p><figure class="lb lc ld le fd ij er es paragraph-image"><div class="er es mq"><img src="../Images/421c7ad8490cc5b955df861f703cb9e6.png" data-original-src="https://miro.medium.com/v2/resize:fit:830/format:webp/1*K1O7MQU31OJjZ1-SCgCJ-g.png"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">9-destruct . js</figcaption></figure><p id="19b9" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">没什么，只是我在代码中添加了这几行，如果我们打印出来，</p><pre class="lb lc ld le fd lf kz lg lh aw li bi"><span id="b3f1" class="lj ju hi kz b fi lk ll l lm ln">10<br/>[ 20, 30, 40, 50 ]<br/>new  array:20,30,40,50</span></pre><p id="467e" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如您所见，新对象(<code class="du kw kx ky kz b">newArr</code>)获得了复制的值。你也可以用它来合并两个数组。这也适用于对象，让我们看看如何，</p><figure class="lb lc ld le fd ij er es paragraph-image"><div class="er es mr"><img src="../Images/2492e238c75f77031c74e11a46b6f1e0.png" data-original-src="https://miro.medium.com/v2/resize:fit:924/format:webp/1*IeImRDC8wdxifgRb51wzrw.png"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">9-destruct . js</figcaption></figure><p id="d330" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在这段代码中，我用一些值创建了一个games对象。如你所见，我已经用spread操作符将games对象传递给了string和object，</p><pre class="lb lc ld le fd lf kz lg lh aw li bi"><span id="7ea2" class="lj ju hi kz b fi lk ll l lm ln">stealth<br/>{ name: 'Splinter Cell', character: 'sam fisher', sequel: 6 }</span></pre><p id="f5ba" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">所以打印出了类型，其他的都分配给了<code class="du kw kx ky kz b">gameDetails </code>对象。我们也可以使用析构来复制对象，就像数组一样。</p></div><div class="ab cl lq lr gp ls" role="separator"><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv"/></div><div class="hb hc hd he hf"><h1 id="657d" class="jt ju hi bd jv jw lx jy jz ka ly kc kd ke lz kg kh ki ma kk kl km mb ko kp kq bi translated">承诺</h1><p id="eefe" class="pw-post-body-paragraph iv iw hi ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated">当我们在JS中处理异步操作(比如HTTP请求和响应)时，我们使用了回调函数。但是Promise比回调函数要好。通常，我们可以将函数作为参数传递给另一个函数。(回调也是一个函数)。所以回调的问题是它会创建“<strong class="ix hj">回调地狱</strong>”，这意味着当函数中调用了如此多的嵌套函数时，代码会变得混乱。诺言能够处理这种问题。基本上在承诺中，当没有出错或拒绝时，它解决。换句话说，我们用它从异步流程中获得同步输出。</p><p id="19f9" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">承诺有3种状态，如待定、已解决和已拒绝。让我们看看代码，</p><figure class="lb lc ld le fd ij er es paragraph-image"><div class="er es ms"><img src="../Images/abb445033f44223a53d0e34bca5ad846.png" data-original-src="https://miro.medium.com/v2/resize:fit:1316/format:webp/1*CKIF67R8bew99Tyn8piUBg.png"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">10-promise.js</figcaption></figure><p id="21a4" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">为了创建一个承诺，我们使用一个构造函数。我设置了超时来模拟HTTP响应(需要一些时间来填充)。这段代码解释了promise如何工作的基本思想。</p><p id="f8d4" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">要使用承诺，我们必须用<code class="du kw kx ky kz b">then()</code>来解决，用<code class="du kw kx ky kz b">catch()</code>来拒绝。</p><figure class="lb lc ld le fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mc"><img src="../Images/69f8293d402769d568a3fbae6888598e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*eP7DiEAn1bzg2P3un_ic_Q.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">10-promise.js</figcaption></figure><p id="00cd" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如果您运行此命令，3000毫秒后您将得到以下输出，</p><pre class="lb lc ld le fd lf kz lg lh aw li bi"><span id="d846" class="lj ju hi kz b fi lk ll l lm ln">Promise is resolved!</span></pre><p id="3f24" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们还可以创建一个函数来使用前面的承诺，如下所示:</p><figure class="lb lc ld le fd ij er es paragraph-image"><div class="er es mt"><img src="../Images/c66f19d77b3ff6e5241c7271e9452af9.png" data-original-src="https://miro.medium.com/v2/resize:fit:954/format:webp/1*zwZkWvrjRNHLUdc-2mAUcg.png"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">10-promise.js</figcaption></figure><p id="1b79" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">有一种叫做<strong class="ix hj">链接</strong>的东西，假设有多个异步请求，我们可以创建一个单独的承诺并将它与其他承诺链接在一起。比如创建一个函数，在then()方法中添加新的promise，就像下面的代码一样(只有then部分)，</p><pre class="lb lc ld le fd lf kz lg lh aw li bi"><span id="4ea4" class="lj ju hi kz b fi lk ll l lm ln">...<br/>.then(1stPromiseObject)<br/>.then(2ndPromiseResolve)<br/>...</span></pre></div><div class="ab cl lq lr gp ls" role="separator"><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv"/></div><div class="hb hc hd he hf"><h1 id="61a9" class="jt ju hi bd jv jw lx jy jz ka ly kc kd ke lz kg kh ki ma kk kl km mb ko kp kq bi translated">异步/等待</h1><p id="768b" class="pw-post-body-paragraph iv iw hi ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated">这和承诺一起工作，让承诺更容易写。如果有一个函数以<strong class="ix hj"> async </strong>关键字开始，这个函数将返回一个promise。<strong class="ix hj"> await </strong>只在<strong class="ix hj">异步函数内部工作。</strong>这个关键词让JS知道了嘿！等到承诺返回任何结果。如果你使用await而不使用async，你会得到syntaxError，说“await只在async函数中有效”。最重要的是，这是比<strong class="ix hj"> promise.then()更简单的语法。</strong>让我们看看这个例子(考虑前面的<strong class="ix hj"> demoPromise </strong>代码)，</p><figure class="lb lc ld le fd ij er es paragraph-image"><div class="er es mo"><img src="../Images/2297d9ee2aa068596c1fc4e011dbd0e3.png" data-original-src="https://miro.medium.com/v2/resize:fit:804/format:webp/1*ZZ7cyEcxovzzVyWlYGiXiw.png"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">10-promise.js</figcaption></figure><p id="a06b" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这就是异步和等待函数willl的样子。与其他类型相比，这很容易理解。</p><p id="dbb0" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我希望你通过这篇文章学到了很多新的JS特性，我已经把这些代码上传到了我的GitHub中。<a class="ae iu" href="https://github.com/Ramsunthar/JS-snippets" rel="noopener ugc nofollow" target="_blank">点击此处</a>查看代码。不断学习。</p><h1 id="0ce6" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">参考</h1><p id="9a43" class="pw-post-body-paragraph iv iw hi ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated">我参考了下面的YouTube视频来写这篇文章，它是由<a class="mu mv ge" href="https://medium.com/u/26403c4bd160?source=post_page-----a5c7dd9c2b07--------------------------------" rel="noopener" target="_blank"> Krishantha Dinesh </a>制作的</p><figure class="lb lc ld le fd ij"><div class="bz dy l di"><div class="mw mx l"/></div></figure><figure class="lb lc ld le fd ij"><div class="bz dy l di"><div class="mw mx l"/></div></figure><div class="my mz ez fb na nb"><a href="https://www.w3schools.com/js/js_arrow_function.asp" rel="noopener  ugc nofollow" target="_blank"><div class="nc ab dw"><div class="nd ab ne cl cj nf"><h2 class="bd hj fi z dy ng ea eb nh ed ef hh bi translated">JavaScript箭头函数</h2><div class="ni l"><h3 class="bd b fi z dy ng ea eb nh ed ef dx translated">组织良好，易于理解的网站建设教程，有很多如何使用HTML，CSS，JavaScript的例子…</h3></div><div class="nj l"><p class="bd b fp z dy ng ea eb nh ed ef dx translated">www.w3schools.com</p></div></div><div class="nk l"><div class="nl l nm nn no nk np io nb"/></div></div></a></div><div class="my mz ez fb na nb"><a href="https://www.geeksforgeeks.org/destructuring-assignment-in-javascript/" rel="noopener  ugc nofollow" target="_blank"><div class="nc ab dw"><div class="nd ab ne cl cj nf"><h2 class="bd hj fi z dy ng ea eb nh ed ef hh bi translated">JavaScript中的析构赋值</h2><div class="ni l"><h3 class="bd b fi z dy ng ea eb nh ed ef dx translated">析构赋值是一个JavaScript表达式，允许从数组中解包值，或者从…</h3></div><div class="nj l"><p class="bd b fp z dy ng ea eb nh ed ef dx translated">www.geeksforgeeks.org</p></div></div><div class="nk l"><div class="nq l nm nn no nk np io nb"/></div></div></a></div><div class="my mz ez fb na nb"><a href="https://www.loginradius.com/blog/async/callback-vs-promises-vs-async-await/" rel="noopener  ugc nofollow" target="_blank"><div class="nc ab dw"><div class="nd ab ne cl cj nf"><h2 class="bd hj fi z dy ng ea eb nh ed ef hh bi translated">回调vs承诺vs异步等待</h2><div class="ni l"><h3 class="bd b fi z dy ng ea eb nh ed ef dx translated">这篇博客解释了JavaScript处理异步操作所依赖的基本概念。这些概念…</h3></div><div class="nj l"><p class="bd b fp z dy ng ea eb nh ed ef dx translated">www.loginradius.com</p></div></div><div class="nk l"><div class="nr l nm nn no nk np io nb"/></div></div></a></div></div></div>    
</body>
</html>