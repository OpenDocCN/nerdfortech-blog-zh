<html>
<head>
<title>Debounce your Search | React Input Optimization</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">去抖您的搜索|反应输入优化</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/debounce-your-search-react-input-optimization-fd270a8042b?source=collection_archive---------0-----------------------#2021-08-26">https://medium.com/nerd-for-tech/debounce-your-search-react-input-optimization-fd270a8042b?source=collection_archive---------0-----------------------#2021-08-26</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/8933e4fa3854e49902a096a7f2866351.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*y6C4nSvy2Woe0m7bWEn4BA.png"/></div></div></figure><p id="74d1" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">去抖是一种限制任务发生次数的优化技术。如果您曾经在React中实现过一个搜索特性，在用户输入每个字符时自动过滤列表或发送一个获取请求，这是一项可以大大提高应用程序效率的技术。</p><h1 id="29db" class="jo jp hi bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">设置/安装</h1><p id="8a4f" class="pw-post-body-paragraph iq ir hi is b it km iv iw ix kn iz ja jb ko jd je jf kp jh ji jj kq jl jm jn hb bi translated">对于这个例子，我们将从lodash实用程序库中导入去抖功能，而不是创建我们自己的版本。为此，我们将把这一行代码添加到处理过滤操作的组件的顶部。</p><pre class="kr ks kt ku fd kv kw kx ky aw kz bi"><span id="4ce5" class="la jp hi kw b fi lb lc l ld le">import debounce from 'lodash.debounce';</span></pre><p id="3e57" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">接下来，我们必须安装依赖npm或yarn，这取决于您使用哪一个。</p><p id="7619" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><code class="du lf lg lh kw b">npm install lodash.debounce</code></p><p id="5b49" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">或者</p><p id="e15b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><code class="du lf lg lh kw b">yarn add lodash.debounce</code></p><h1 id="4761" class="jo jp hi bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">分解示例</h1><figure class="kr ks kt ku fd ij"><div class="bz dy l di"><div class="li lj l"/></div></figure><p id="10e8" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在上面的CodeSandbox示例中，我已经创建了一个简单的应用程序，它显示了一个水果列表和一个搜索栏，当你输入时，搜索栏会过滤列表。</p><p id="765a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">搜索栏是一个<a class="ae lk" href="https://reactjs.org/docs/forms.html" rel="noopener ugc nofollow" target="_blank">控件形式</a>。它显示的值取自状态，输入通过其<code class="du lf lg lh kw b">onChange</code>合成事件与状态链接。</p><pre class="kr ks kt ku fd kv kw kx ky aw kz bi"><span id="0fb4" class="la jp hi kw b fi lb lc l ld le">const [searchTerm, setSearchTerm] = useState("");</span><span id="debf" class="la jp hi kw b fi ll lc l ld le"><br/>const handleChange = (e) =&gt; {</span><span id="6d91" class="la jp hi kw b fi ll lc l ld le">  setSearchTerm(e.target.value);</span><span id="3951" class="la jp hi kw b fi ll lc l ld le">};</span></pre></div><div class="ab cl lm ln gp lo" role="separator"><span class="lp bw bk lq lr ls"/><span class="lp bw bk lq lr ls"/><span class="lp bw bk lq lr"/></div><div class="hb hc hd he hf"><pre class="kv kw kx ky aw kz bi"><span id="33dd" class="la jp hi kw b fi lt lu lv lw lx lc l ld le">&lt;input type="text" value={searchTerm} onChange={handleChange} /&gt;</span></pre><p id="4691" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">每次输入一个字符或从输入中删除一个字符时，水果列表被过滤，最终用户看到的列表被更新。</p><pre class="kr ks kt ku fd kv kw kx ky aw kz bi"><span id="f177" class="la jp hi kw b fi lb lc l ld le">let listToDisplay = fruits;<br/></span><span id="7817" class="la jp hi kw b fi ll lc l ld le">if (searchTerm !== "")</span><span id="5178" class="la jp hi kw b fi ll lc l ld le">  listToDisplay = fruits.filter((fruit) =&gt; {</span><span id="10be" class="la jp hi kw b fi ll lc l ld le">    return fruit.includes(searchTerm);</span><span id="2925" class="la jp hi kw b fi ll lc l ld le">  });</span><span id="efa1" class="la jp hi kw b fi ll lc l ld le">}</span></pre><h1 id="d8d5" class="jo jp hi bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">问题是</h1><p id="952d" class="pw-post-body-paragraph iq ir hi is b it km iv iw ix kn iz ja jb ko jd je jf kp jh ji jj kq jl jm jn hb bi translated">虽然这个例子运行良好，但是您可以想象随着列表的增长，每次搜索花费的时间会越来越长。另一个场景可能是我们为每个被搜索的字符发送api请求。无论哪种方式，这种实现都可能开始降低应用程序的速度，并且您会不知道如何解决这个问题。进来了<code class="du lf lg lh kw b">debounce</code>。</p><h1 id="d967" class="jo jp hi bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">去抖</h1><pre class="kr ks kt ku fd kv kw kx ky aw kz bi"><span id="5026" class="la jp hi kw b fi lb lc l ld le">_.debounce(func, [wait=0], [options={}])</span></pre><p id="54a1" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">虽然<code class="du lf lg lh kw b">debounce</code>有3个参数，我们将使用前两个，我们想要调用的函数和我们设置的等待时间。</p><p id="f400" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们还将使用内置在<code class="du lf lg lh kw b">debounce</code>中的<code class="du lf lg lh kw b">.cancel </code>函数来帮助清理(稍后将详细介绍)。</p><p id="f8f4" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">有关<code class="du lf lg lh kw b">debounce</code>功能的更多信息，请参考<a class="ae lk" href="https://lodash.com/docs/4.17.15#debounce" rel="noopener ugc nofollow" target="_blank">官方文档</a>。</p><h1 id="b268" class="jo jp hi bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">履行</h1><p id="1d58" class="pw-post-body-paragraph iq ir hi is b it km iv iw ix kn iz ja jb ko jd je jf kp jh ji jj kq jl jm jn hb bi translated">第一步是与<code class="du lf lg lh kw b">useMemo</code>一起工作，从我们的<code class="du lf lg lh kw b">debounce</code>函数中记忆一个返回值。该返回值将在两次重新呈现之间保持不变。这一步是必不可少的，因为如果我们不在两次重新渲染之间保存这些数据，其他的<code class="du lf lg lh kw b">debounce</code>实现将会在每次重新渲染时出现，而我们将基本上拥有我们最初的例子；我们将在最后一次字符输入后的一段时间后过滤每个字符的列表。</p><pre class="kr ks kt ku fd kv kw kx ky aw kz bi"><span id="076b" class="la jp hi kw b fi lb lc l ld le">const debouncedResults = useMemo(() =&gt; {</span><span id="8baa" class="la jp hi kw b fi ll lc l ld le">  return debouce(handleChange, 300);</span><span id="c56f" class="la jp hi kw b fi ll lc l ld le">}, []);</span></pre><p id="e4cb" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">接下来，我们将与<code class="du lf lg lh kw b">useEffect</code>合作，清理当我们的组件被卸载时来自<code class="du lf lg lh kw b">debounce</code>的任何副作用；当我们不在那个页面或视图上时，就没有理由进行搜索了。这就是我们将在内存返回值上调用<code class="du lf lg lh kw b">.cancel</code>函数的地方。</p><pre class="kr ks kt ku fd kv kw kx ky aw kz bi"><span id="8947" class="la jp hi kw b fi lb lc l ld le">useEffect(() =&gt; {</span><span id="c3e6" class="la jp hi kw b fi ll lc l ld le">  return () =&gt; {</span><span id="abfe" class="la jp hi kw b fi ll lc l ld le">    debouncedResults.cancel();</span><span id="b624" class="la jp hi kw b fi ll lc l ld le">  };</span><span id="2e75" class="la jp hi kw b fi ll lc l ld le">});</span></pre><p id="fab4" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">最后，我们将撤销一些以前的工作。我们将通过删除表单的value属性并将<code class="du lf lg lh kw b">onChange</code>设置为调用<code class="du lf lg lh kw b">debouncedResults</code>来使表单不受控制。这将使表单在每次输入改变时被调用<code class="du lf lg lh kw b">debounce</code>。</p><pre class="kr ks kt ku fd kv kw kx ky aw kz bi"><span id="2552" class="la jp hi kw b fi lb lc l ld le">&lt;input type="text" onChange={debouncedResults} /</span></pre><p id="415f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">就这样，一个完整的去抖输入！</p><h1 id="f7ea" class="jo jp hi bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">工作示例</h1><figure class="kr ks kt ku fd ij"><div class="bz dy l di"><div class="li lj l"/></div></figure></div></div>    
</body>
</html>