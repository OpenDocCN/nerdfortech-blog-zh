<html>
<head>
<title>Rails Custom Type — as a single value or as an array of custom type values</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Rails自定义类型—作为单个值或自定义类型值的数组</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/rails-custom-type-as-a-single-value-or-as-an-array-of-custom-type-values-ec14e840ce2c?source=collection_archive---------4-----------------------#2021-04-26">https://medium.com/nerd-for-tech/rails-custom-type-as-a-single-value-or-as-an-array-of-custom-type-values-ec14e840ce2c?source=collection_archive---------4-----------------------#2021-04-26</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="2959" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">您是否曾经需要在特定类型的数据库中存储一些信息？当然，我想。我们都使用字符串、整数、小数等，尤其是在使用PostgreSQL的情况下也使用数组(pg数组)。但是如果我们需要一个尚不存在的类型呢？对我们正在构建的应用程序来说更独特的东西。Rails让我们了解了这一点:</p><p id="2112" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">自定义类型</strong></p><p id="86bc" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">那么，让我们来看看自定义类型是如何工作的！</p><h1 id="ee86" class="jd je hi bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">预期结果</h1><p id="ed24" class="pw-post-body-paragraph if ig hi ih b ii kb ik il im kc io ip iq kd is it iu ke iw ix iy kf ja jb jc hb bi translated">首先，让我们快速定义我们想要实现的目标。我们的Rails示例应用程序将有一个支付模型，它有三个属性:</p><ul class=""><li id="bd37" class="kg kh hi ih b ii ij im in iq ki iu kj iy kk jc kl km kn ko bi translated">数量</li><li id="df1c" class="kg kh hi ih b ii kp im kq iq kr iu ks iy kt jc kl km kn ko bi translated">货币</li><li id="3135" class="kg kh hi ih b ii kp im kq iq kr iu ks iy kt jc kl km kn ko bi translated">可能的货币</li></ul><p id="1bb6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">因此，我们在这里进行了深入的研究，不仅将“普通”属性定义为自定义类型，还使用PostgreSQL为possible _ currencies定义了这些自定义类型的数组(使用pg数组)。现在不要想太多，我们一会儿将逐个介绍。首先，我们需要运行迁移并创建模型。我们还需要调整一些配置。</p><ol class=""><li id="b025" class="kg kh hi ih b ii ij im in iq ki iu kj iy kk jc ku km kn ko bi translated">告诉模型哪些属性是自定义类型的</li><li id="c67d" class="kg kh hi ih b ii kp im kq iq kr iu ks iy kt jc ku km kn ko bi translated">注册类型，以便它可以在应用程序启动时加载</li></ol><figure class="kv kw kx ky fd kz"><div class="bz dy l di"><div class="la lb l"/></div></figure><p id="9583" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">首先，我们开始将自定义类型添加到非数组属性中，然后我们将修改它，使其只支持一个单独的自定义类型的元素数组。最后我们把两者都带到了一起，那就继续吧！</p></div><div class="ab cl lc ld gp le" role="separator"><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh"/></div><div class="hb hc hd he hf"><h1 id="6137" class="jd je hi bd jf jg lj ji jj jk lk jm jn jo ll jq jr js lm ju jv jw ln jy jz ka bi translated">Currency:自定义类型的单值属性</h1><h2 id="f08c" class="lo je hi bd jf lp lq lr jj ls lt lu jn iq lv lw jr iu lx ly jv iy lz ma jz mb bi translated">描述类型的值</h2><p id="f4aa" class="pw-post-body-paragraph if ig hi ih b ii kb ik il im kc io ip iq kd is it iu ke iw ix iy kf ja jb jc hb bi translated">为了简单起见，让我们定义一种货币类型，在这种货币类型中，我们不出所料地存储一种单一货币(我知道有货币宝石，这只是为了说明)。但是我们为什么需要它呢？在这种情况下，我们希望在一种货币中实现某些行为。我们希望货币能够以字符串格式、ISO 4217码、符号(例如€)显示自己，我们还希望能够将货币字符串解析回其货币类，并查看所有可能的货币。为此，我们描述了一个“货币”模块，并将单一货币作为类添加到其中，在这里我们描述了所提到的方法:</p><figure class="kv kw kx ky fd kz"><div class="bz dy l di"><div class="la lb l"/></div></figure><p id="75c3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">单个类，例如' Currency::EUR '是我们希望保存到数据库并希望从数据库中获取的值。因此，有了一个具有此类属性的模型，即“支付”模型，我们可以</p><p id="cb06" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">payment . last . currency . iso<br/>=&gt;'欧元'</p><p id="5585" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这意味着我们从货币属性中得到的值必须像</p><p id="cd27" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Payment.last.currency <br/> = &gt;货币::欧元</p><p id="caec" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">因此，当我们从数据库中检索值时，它需要自动保持不变。让我们看看我们如何能做到这一点。</p><h2 id="2da0" class="lo je hi bd jf lp lq lr jj ls lt lu jn iq lv lw jr iu lx ly jv iy lz ma jz mb bi translated">创建货币类型</h2><p id="2270" class="pw-post-body-paragraph if ig hi ih b ii kb ik il im kc io ip iq kd is it iu ke iw ix iy kf ja jb jc hb bi translated">为此，Rails给了我们一个类‘active record::Type::Value’来继承，它给了我们创建自定义类型所需的4个方法。</p><ul class=""><li id="7365" class="kg kh hi ih b ii ij im in iq ki iu kj iy kk jc kl km kn ko bi translated"><strong class="ih hj">类型</strong>:定义我们如何在数据库中实际保存它。</li><li id="8c7a" class="kg kh hi ih b ii kp im kq iq kr iu ks iy kt jc kl km kn ko bi translated"><strong class="ih hj"> cast </strong>:将用户输入转化为对象。一旦我们将货币值(' Currency::EUR ')赋给对象的货币属性，就会调用这个方法。</li><li id="f24a" class="kg kh hi ih b ii kp im kq iq kr iu ks iy kt jc kl km kn ko bi translated"><strong class="ih hj">序列化</strong>:将值翻译成数据库可以理解的东西(在本例中是字符串)。一旦我们将对象保存到数据库中，就会调用这个方法。</li><li id="d2cb" class="kg kh hi ih b ii kp im kq iq kr iu ks iy kt jc kl km kn ko bi translated"><strong class="ih hj">反序列化</strong>:当我们从数据库记录中实例化一笔付款时，将数据库可理解的字符串翻译成货币值。</li></ul><p id="ecf9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这些方法中的每一个都需要一个参数“值”。因为我们从来没有真正显式地调用过这些方法(Rails为我们做了这些)，所以我们只需要知道这些参数是什么。这随方法的不同而不同。这个参数或者是我们分配给对象属性的值(强制转换)，或者是对象属性的实际值(序列化)，或者是来自数据库的字符串(反序列化)。</p><p id="7cc6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在数据库中，我们希望将货币保存为字符串(如“eur”)，但如果我们读取支付对象的值，我们希望它是一个货币类，如“Currency::EUR”。所以，我们可以这样做:</p><figure class="kv kw kx ky fd kz"><div class="bz dy l di"><div class="la lb l"/></div></figure><p id="034f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">首先，我们说我们希望它是数据库中的一个字符串，方法是在type方法中说“string”。如果您还记得迁移，那实际上就是数据库列的类型！</p><p id="ac64" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在给一个支付对象赋值时，我们给货币属性一个字符串(就像它来自一个表单一样),它需要被转换成一个货币类。只有当我们保存对象时，serialize方法才会将类转换为字符串(我们在类中定义的)并保存它。为了检查这一点，您可以使用类似Postico的东西来读取您的数据库。如果我们现在想从数据库中读取付款，将使用' deserialize '方法反序列化该字符串，这样我们就可以再次访问货币类。在irb中尝试:</p><figure class="kv kw kx ky fd kz"><div class="bz dy l di"><div class="la lb l"/></div></figure><p id="f8c0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为了检查这是否真的按照我们想要的方式工作，我们还可以添加一些规格:</p><figure class="kv kw kx ky fd kz"><div class="bz dy l di"><div class="la lb l"/></div></figure><p id="6887" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在我们已经拥有了单值自定义类型所需的一切，让我们看看如何对数组进行自定义。</p></div><div class="ab cl lc ld gp le" role="separator"><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh"/></div><div class="hb hc hd he hf"><h1 id="f573" class="jd je hi bd jf jg lj ji jj jk lk jm jn jo ll jq jr js lm ju jv jw ln jy jz ka bi translated">货币:自定义类型元素的数组</h1><p id="42e4" class="pw-post-body-paragraph if ig hi ih b ii kb ik il im kc io ip iq kd is it iu ke iw ix iy kf ja jb jc hb bi translated">现在，我们希望为我们的支付提供一组货币类。所以这是可行的:</p><p id="26ec" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">payment . last . possible _ currences<br/>=&gt;[货币::欧元，货币::美元]</p><p id="5983" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这里唯一需要更改的是currency_type.rb，以便它能够正确地序列化和反序列化值。</p><ul class=""><li id="f88d" class="kg kh hi ih b ii ij im in iq ki iu kj iy kk jc kl km kn ko bi translated"><strong class="ih hj"> cast </strong>:我们为属性提供了一个货币字符串数组`['eur '，' usd']，该属性将被转换为货币类。</li><li id="d855" class="kg kh hi ih b ii kp im kq iq kr iu ks iy kt jc kl km kn ko bi translated"><strong class="ih hj"> serialize </strong>:在保存到数据库时，我们需要将这个Ruby数组转换成一个pg字符串数组。为此，对数组的每个元素调用“to_s ”,以便它表示货币类的字符串值。</li><li id="7bee" class="kg kh hi ih b ii kp im kq iq kr iu ks iy kt jc kl km kn ko bi translated"><strong class="ih hj">反序列化</strong>:当我们从数据库中检索付款时，我们需要将pg数组转换回Ruby数组。这将为我们提供一个类似`['eur '，' usd']`的字符串数组，然后我们将它转换为一个货币类`[Currency::EUR，Currency::USD]`数组</li></ul><p id="50ed" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">也许在这里展示规格更有意义:</p><figure class="kv kw kx ky fd kz"><div class="bz dy l di"><div class="la lb l"/></div></figure><p id="1780" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">下面是类型文件:</p><figure class="kv kw kx ky fd kz"><div class="bz dy l di"><div class="la lb l"/></div></figure><p id="99d4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在irb中查看:</p><figure class="kv kw kx ky fd kz"><div class="bz dy l di"><div class="la lb l"/></div></figure></div><div class="ab cl lc ld gp le" role="separator"><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh"/></div><div class="hb hc hd he hf"><h1 id="ed08" class="jd je hi bd jf jg lj ji jj jk lk jm jn jo ll jq jr js lm ju jv jw ln jy jz ka bi translated">把它放在一起</h1><p id="cbd3" class="pw-post-body-paragraph if ig hi ih b ii kb ik il im kc io ip iq kd is it iu ke iw ix iy kf ja jb jc hb bi translated">现在，我们已经分别了解了非阵列和阵列实施，让我们从规格开始将它们放在一起:</p><figure class="kv kw kx ky fd kz"><div class="bz dy l di"><div class="la lb l"/></div></figure><p id="70cf" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">所以基本上，它应该两者都做，取决于你给它什么，对吗？让我们快速定义这些方法:</p><ul class=""><li id="fa74" class="kg kh hi ih b ii ij im in iq ki iu kj iy kk jc kl km kn ko bi translated"><strong class="ih hj"> cast </strong>:我们以字符串的形式提供类，就像它们来自一个表单一样。因此，<strong class="ih hj"> cast </strong>需要决定是将单个货币字符串转换成货币类，还是将货币字符串数组转换成货币类数组。</li><li id="ffdf" class="kg kh hi ih b ii kp im kq iq kr iu ks iy kt jc kl km kn ko bi translated"><strong class="ih hj">序列化</strong>:如果是数组，需要将Ruby数组转换成pg数组。然而，如果它是一个单一的货币类，它只需要将它转换成一个字符串。</li><li id="5069" class="kg kh hi ih b ii kp im kq iq kr iu ks iy kt jc kl km kn ko bi translated"><strong class="ih hj">反序列化</strong>:这有点复杂，因为我们需要检查数据库中的值是否是pg数组。我们只需通过检查PostgreSQL文档中的分隔符来实现这一点。如果是一个，我们把它解码成一个Ruby数组，并对字符串进行常量化。如果不是，那就是我们保持不变的单一货币。</li></ul><figure class="kv kw kx ky fd kz"><div class="bz dy l di"><div class="la lb l"/></div></figure></div><div class="ab cl lc ld gp le" role="separator"><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh"/></div><div class="hb hc hd he hf"><p id="aa9f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">所以，就这样了。当然，这不能只用于货币。只要想想飞船的类型，让你的想象力自由流动。希望这篇小文章对你有帮助。随意评论，伸手！</p><p id="57dd" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">祝一切顺利，</p><p id="3e84" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">凯文</p></div></div>    
</body>
</html>