# Java 中的记录

> 原文：<https://medium.com/nerd-for-tech/records-in-java-3e6e47fdb6fb?source=collection_archive---------2----------------------->

![](img/ce5c1c4acbe2902c90988eb5015cce84.png)

由 [Unsplash](https://unsplash.com?utm_source=medium&utm_medium=referral) 上的 [AltumCode](https://unsplash.com/@altumcode?utm_source=medium&utm_medium=referral) 拍摄的照片

在 Java 14 和 Java 15 中作为预览特性之后，Java 记录现在是从 Java 16 开始的 Java 语言的一部分。

在本文中，我们将深入研究 Java 记录，看看这个特性提供了什么，以及如何使用它。

# 记录

根据 [JEP 395](https://openjdk.java.net/jeps/395) ，记录描述为`classes that act as transparent carriers for immutable data`。

在 Java 中有记录之前，当我们想要表示一些数据时，我们最终得到如下所示的类:

这里我们有一个具有四个属性的类。要使用它，我们需要更多的代码来处理它。例如，我们需要一个构造函数，getters 来获取属性值。我们还需要`toString()`、`hashCode()`和`equals()`方法来完整实现这个类。

这种样板代码可以使用 IDE 生成，也可以使用一些像 Lombok 这样的库生成，但是这样做也有缺点。

我们需要的是 Java 语言中的一种机制，它可以处理纯数据类，而不需要处理样板代码或外部工具，这些工具会在我们的程序中引起问题。

为了解决这个问题，记录开始发挥作用。记录类声明由名称、标题和主体组成。标题列出了被称为*组件*的记录字段。

前面的类实现可以使用记录以这种方式编写:

在上面的示例中，记录描述如下:

*   唱片的名字是`User`，
*   头部包含组件`String firstName,String lastName`，
*   身体暂时是空的。

通过使用记录，我们得到一个类，它有一个接受记录所有属性的隐式构造函数，这个构造函数称为规范构造函数。我们还根据类的属性得到了`toString()`、`hashCode()`和`equals()`方法的实现。此外，我们为每个属性获取一个访问器方法。

我们应该注意到，记录没有为其属性实现 setter 方法，这意味着记录是*不可变的*:一旦用某些值实例化，记录的状态就不能改变。

# 对记录的限制

与普通类相比，有些限制适用于记录:

*   **不能扩展另一个类**:记录类声明没有`extends`子句。与可以隐式扩展其超类对象的普通类不同，记录不能从另一个类继承，即使是它的超类`java.lang.Record`。
*   **最终类**:记录是最终的，不能是抽象的。这意味着一个记录的状态不能被另一个使用继承的类增强。
*   **不可变**:记录是用来携带数据而不被修改的最佳方式，因为所有的属性都是最终的。
*   **无实例字段**:记录类中不允许有实例字段。记录的状态仅由记录头中声明的属性定义。

在我们的例子中，如果我们想添加一个名为`password`的实例字段，我们会得到一个编译错误:

# 记录的用例

记录可以在许多方面作为普通类的替代品。在下文中，我们将看到这些用例的一些例子。

*   **数据的临时容器**:可以创建一条记录，例如在一个方法中存储临时数据。如果我们只需要在方法中保存一些数据，就没有必要为记录创建专用的类文件。我们可以称之为*地方志类*。

在这个例子中，我们创建了一个记录，用它作为每个客户购买的数据存储。该记录对于该方法是本地的，不会在该方法之外使用。

*   **数据传输对象(dto)**:记录可用于表示 d to，它是一个没有行为的对象:它仅用于传输数据。
*   **映射中的键**:如果我们想在`Map`中使用一个由许多值组成的键，那么一个记录会很有用。默认情况下，`hashCode()`和`equals()`方法在记录中实现。

# 记录与 Java Beans

当许多开发人员想要实现 Java Bean 时，他们会倾向于使用记录。但是，记录不能真正扮演 Java Bean 的角色，原因有几个:

*   表示实体的 Java Beans 通常是可变对象，但是记录是不可变的。
*   字段访问器的名称不符合 Java bean 约定:它不是以`get`开头。在前面的例子中，如果我们想从记录中获得`firstName`的值，语句将是`user.firstName()`而不是`user.getFirstName()`