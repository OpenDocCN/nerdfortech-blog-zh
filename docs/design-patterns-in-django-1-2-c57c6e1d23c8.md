# Django 1.2 中的设计模式

> 原文：<https://medium.com/nerd-for-tech/design-patterns-in-django-1-2-c57c6e1d23c8?source=collection_archive---------2----------------------->

![](img/7565c0db8169af9873dcdcaf9254886b.png)

[兰斯·安德森](https://unsplash.com/@lanceanderson?utm_source=medium&utm_medium=referral)在 [Unsplash](https://unsplash.com?utm_source=medium&utm_medium=referral) 上拍照

在上一篇文章([第 1.1 部分](/@sawanrai777/design-patterns-in-django-1-1-b74fc38a877b))中，我已经给你介绍了 Django 设计模式(DDPs)。我们还讨论了一些设计模式。在这里，我们将继续我们的 DDPs 之旅。我们已经完成了**模型**部分下的**结构设计模式**。现在是讨论更多 DDP 的时候了。

![](img/0e7ce695e4aeb763e86d7ec6f8e28fd4.png)

**1.2 检索模式:**在结构化设计模式下，我们开始了解 models.py 中可能发生的各种类型的类间和类内结构。在创建模型之后，我们需要访问/检索我们的模型的属性和方法。检索模式下有两个 DDP，如下所示:

**1.2.1 属性字段:**如果你学过 DBMS 课程，你会知道我们不在表中存储派生属性。我们使用基本属性在运行时计算派生属性。**例子**:我们存储用户的“出生日期”，可以计算任意时间点的“年龄”。Django 模特也是如此。我们可以在 User 类内部创建实例级 **get_age()** 方法，提取用户的 DOB，计算后返回年龄。写 **user.get_age()** 正确但不 pythonic 化。我想访问**年龄**作为一个属性。我能做的就是把 **"@Property"** decorator 放在 **get_age()** 方法之前。现在，我可以写 **user.age.**

**1.2.2 自定义模型管理器 CMM:** 查询的两个基本问题:I)提取数据的复杂和嵌套查询，ii)某些查询在整个代码中被重复调用，这也违反了 **DRY** 原则。我们可以为每个条件创建多个方法来提取数据，并按照所需的顺序调用这些方法来过滤有用的数据。**举例** : **用户。Objects.all()。过滤器(user_type='prime ')。过滤器(状态= '活动')**。这里，我们使用 Django 的内置功能来过滤数据。首先，我们提取所有的用户对象。接下来，我们过滤 prime 用户，然后过滤活跃用户。我们不再编写单一的条件语句，而是逐个调用 filter 方法。通过定义多个数据访问方法，并在每个方法中使用单个条件，可以为我们的自定义模型类实现相同的设置。

**2。表单:**需要表单来从用户那里收集数据。在 Django 中，我们将所有表单存储在 **forms.py** 文件中。我们可以有基于函数或基于类的表单(更多细节参见 Django 文档)。我们在表单级别有以下 DDP。

**2.1 动态表单生成:**在创建表单时，我们希望在表单中添加/删除一些字段。我们可以有一个表单初始化方法，它接受要添加到表单中的有效表单字段的列表。**举例:**网购中的支付选项。我们要求用户货到付款(COD)和在线支付。如果用户选择货到付款，我们将不会在下一页提供在线支付详情字段。这是一个很基本的例子。可以分享更多与此模式相关的有意义的复杂例子。

**2.2 基于用户的表单:**所有基于 Web 的应用程序都以不同的方式处理多种类型的用户。每个用户都有不同级别的访问权限和附加设施。根据用户类型，我们可以在将表单发送给用户之前添加/删除表单字段。**举例:**某航空公司向其 prime 客户提供“添加特别午餐”选项，而普通客户没有此选项。

**2.3 每个视图多个表单动作:**如何在单个视图中处理多个表单动作？当多个表单动作被映射到一个 URL 时，我们如何以不同的方式对待每个动作？**阶级基础观点**就是答案。通过扩展通用的 **TemplateView** 创建一个视图类，它将提供默认的 **get** 和 **post** 方法。我们可以将表单动作标识符作为参数传递给**请求**。在视图端，我们可以检查用户执行了哪个操作，并进一步采取相应的步骤来生成响应。

**2.4 CRUD 视图:**在 web 应用中，我们总是执行 CRUD 操作。 **C** :创建信息， **R** :读取信息， **U** :更新信息， **D** :删除信息。作为一名 web 开发者，你需要为用户提供 **CRUD** 工具。我们也可以在这里使用基于类的视图概念，而不是为每个操作创建单独的 URL。对于每组相关信息(在单个页面上创建或者与一个模型相关)，通过扩展 generic **TemplateView** 创建一个视图类。借助表单动作标识符(来自请求对象中的用户方)对视图类的 **post/get** 方法中的数据执行 **C/R/U/D** 操作。

这就是这篇文章的内容。我们已经完成**型号**和**表格** DDPs。我们现在只剩下**视图**和**模板** DDPs。我知道看文字和只看文字很无聊。这就是为什么我只提供每个 DDP 很少的细节。更多详细信息，请参考 A. Ravindran 的[实际书籍](https://doc.lagout.org/programmation/Django/Django%20Design%20Patterns%20and%20Best%20Practices%20%5BRavindran%202015-03-26%5D.pdf)，其中也包含示例。感谢你阅读这篇文章。我希望在这个系列的下一篇文章中见到你。[https://medium . com/@ sawan rai 777/design-patterns-in-django-1-3-4 b0b 8324 e5f](/@sawanrai777/design-patterns-in-django-1-3-4b0b8324e5f)

访问下面的工作实例链接:【https://github.com/DjangoPatternsBook/superbook[。](https://github.com/DjangoPatternsBook/superbook)

【代码作者:阿伦·拉文德兰(GitHub id: arocks)】