<html>
<head>
<title>Exponential backoff algorithm in NodeJS</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">NodeJS中的指数退避算法</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/exponential-backoff-algorithm-in-nodejs-40e3d765b183?source=collection_archive---------0-----------------------#2022-05-08">https://medium.com/nerd-for-tech/exponential-backoff-algorithm-in-nodejs-40e3d765b183?source=collection_archive---------0-----------------------#2022-05-08</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/b89f7f09fddebc3ffda80c484fa95a6f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*9JCYER7aBvd2IlMS"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">吉姆·威尔逊在<a class="ae iu" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="9a00" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在使用第三方库和API时，由于API的速率限制策略，我们有时可能会出错。如果发出的请求数量超过了每个时间限制的配额，就会发生这种情况。例如，每分钟100个对POST /example/user的请求。</p><p id="11fd" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我在使用Google Sheets API时也遇到过类似的错误。谷歌文档建议在等待一段时间后继续尝试指数补偿算法<a class="ae iu" href="https://cloud.google.com/iot/docs/how-tos/exponential-backoff" rel="noopener ugc nofollow" target="_blank">https://cloud . Google . com/IOT/docs/how-tos/指数补偿</a></p><p id="3495" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">让我们动手看看代码。</p><pre class="jt ju jv jw fd jx jy jz ka aw kb bi"><span id="1fc6" class="kc kd hi jy b fi ke kf l kg kh">const backoff = (fun, successFun, failureFun, exponent) =&gt; {</span><span id="a052" class="kc kd hi jy b fi ki kf l kg kh">  console.log('Retrying after' + Math.pow(2, exponent))</span><span id="fffe" class="kc kd hi jy b fi ki kf l kg kh">  setTimeout(async () =&gt; {</span><span id="b6c6" class="kc kd hi jy b fi ki kf l kg kh">    const res = await fun()</span><span id="6e7e" class="kc kd hi jy b fi ki kf l kg kh">    if (res.data) {</span><span id="7ff9" class="kc kd hi jy b fi ki kf l kg kh">        console.log('success')</span><span id="9431" class="kc kd hi jy b fi ki kf l kg kh">        successFun()</span><span id="864a" class="kc kd hi jy b fi ki kf l kg kh">    } else if (exponent &lt;= 10) {</span><span id="fb95" class="kc kd hi jy b fi ki kf l kg kh">        backoff(fun, successFun, failureFun, exponent + 1)</span><span id="3722" class="kc kd hi jy b fi ki kf l kg kh">    } else {</span><span id="5c2a" class="kc kd hi jy b fi ki kf l kg kh">        console.log('failure')</span><span id="7e0e" class="kc kd hi jy b fi ki kf l kg kh">        failureFun()</span><span id="e541" class="kc kd hi jy b fi ki kf l kg kh">        }</span><span id="92e9" class="kc kd hi jy b fi ki kf l kg kh">    }, Math.pow(2, exponent) + Math.random() * 1000)</span><span id="3135" class="kc kd hi jy b fi ki kf l kg kh">}</span></pre><h2 id="9e3f" class="kc kd hi bd kj kk kl km kn ko kp kq kr jg ks kt ku jk kv kw kx jo ky kz la lb bi translated">论点是:</h2><ol class=""><li id="bd9a" class="lc ld hi ix b iy le jc lf jg lg jk lh jo li js lj lk ll lm bi translated">fun:这是一个进行第三方API调用的函数，在我的例子中是google sheet API。这并不局限于一段特定的代码。<code class="du ln lo lp jy b">fun</code>函数可以有任何可能导致成功或失败的代码。</li><li id="be84" class="lc ld hi ix b iy lq jc lr jg ls jk lt jo lu js lj lk ll lm bi translated">successFun:这是一个帮助器函数，在成功运行<code class="du ln lo lp jy b">fun</code>后执行一段代码。这可以像控制台日志或在数据库中输入数据一样简单。</li><li id="8ac5" class="lc ld hi ix b iy lq jc lr jg ls jk lt jo lu js lj lk ll lm bi translated">failureFun:类似于successFun，但是当重试次数超过。在上面的代码中，我们在结束一天的工作之前要重试10次。</li><li id="d4c2" class="lc ld hi ix b iy lq jc lr jg ls jk lt jo lu js lj lk ll lm bi translated">指数:指数是2的当前幂。这指定了重试前等待的时间。每次尝试后，我们都会增加这个值。</li></ol><h2 id="65aa" class="kc kd hi bd kj kk kl km kn ko kp kq kr jg ks kt ku jk kv kw kx jo ky kz la lb bi translated">逻辑是:</h2><p id="c84d" class="pw-post-body-paragraph iv iw hi ix b iy le ja jb jc lf je jf jg lv ji jj jk lw jm jn jo lx jq jr js hb bi translated">退避函数的代码被包装在一个等待<code class="du ln lo lp jy b">Math.pow(2, exponent) + Math.random() * 1000</code>秒时间的setTimeout中。我们使用随机，以便2次或更多次重试同时呼叫的概率更小。<br/>setTimeout里面的事情很简单。我们只需使用<code class="du ln lo lp jy b">fun</code>进行API调用，如果成功，就会执行<code class="du ln lo lp jy b">successFun</code>块，并停止进一步的执行。<br/>如果API调用失败，递增指数后再次调用<code class="du ln lo lp jy b">backoff</code>函数。这告诉代码在等待一段时间后重试。<br/>如果API调用失败，并且达到了重试限制(上面代码中的10 ),我们将在那里停止重试和执行，并执行<code class="du ln lo lp jy b">failureFun</code></p><p id="2fc7" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">那都是乡亲们！</p></div></div>    
</body>
</html>