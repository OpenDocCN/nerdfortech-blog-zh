<html>
<head>
<title>How to use Asynchronous functions in JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在 JavaScript 中使用异步函数</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/how-to-use-asynchronous-functions-in-javascript-b1b449a6b5be?source=collection_archive---------13-----------------------#2021-04-13">https://medium.com/nerd-for-tech/how-to-use-asynchronous-functions-in-javascript-b1b449a6b5be?source=collection_archive---------13-----------------------#2021-04-13</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/></div><div class="ab cl if ig gp ih" role="separator"><span class="ii bw bk ij ik il"/><span class="ii bw bk ij ik il"/><span class="ii bw bk ij ik"/></div><div class="hb hc hd he hf"><figure class="in io ip iq fd ir er es paragraph-image"><div role="button" tabindex="0" class="is it di iu bf iv"><div class="er es im"><img src="../Images/cc4544f604bbe350b96715cdb9d3412c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hvI-csUmKhrGxS_4-6PrBw.jpeg"/></div></div></figure><p id="2736" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated">大家好，我是迪露莎·费尔南多，这是我关于如何在 JavaScript 中使用异步函数的第二篇博文。我希望您能更好地理解我在这里所说的内容，并理解异步函数背后的概念。所以先简单介绍一下。</p><h1 id="a83a" class="jw jx hi bd jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt bi translated"><strong class="ak"> 1。JavaScript 简介</strong>👀</h1><p id="38c8" class="pw-post-body-paragraph iy iz hi ja b jb ku jd je jf kv jh ji jj kw jl jm jn kx jp jq jr ky jt ju jv hb bi translated">JavaScript 是一种高级且强大的语言，为开发人员提供了一系列功能，例如</p><ol class=""><li id="8c82" class="kz la hi ja b jb jc jf jg jj lb jn lc jr ld jv le lf lg lh bi translated"><strong class="ja hj">动态打字</strong></li><li id="59a7" class="kz la hi ja b jb li jf lj jj lk jn ll jr lm jv le lf lg lh bi translated"><strong class="ja hj">基于原型的</strong></li><li id="002c" class="kz la hi ja b jb li jf lj jj lk jn ll jr lm jv le lf lg lh bi translated"><strong class="ja hj">面向对象</strong></li><li id="a0fb" class="kz la hi ja b jb li jf lj jj lk jn ll jr lm jv le lf lg lh bi translated"><strong class="ja hj">多参数</strong></li></ol><h1 id="7d8c" class="jw jx hi bd jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt bi translated"><strong class="ak"> 2。JavaScript 是单线程的吗？🤔</strong></h1><p id="c420" class="pw-post-body-paragraph iy iz hi ja b jb ku jd je jf kv jh ji jj kw jl jm jn kx jp jq jr ky jt ju jv hb bi translated">所以，除了这个<strong class="ja hj">之外，JavaScript 是一个单线程执行语言</strong>，它有一个调用栈和一个内存堆。简单地说，它在执行阶段充当一个进程队列😉。</p><figure class="in io ip iq fd ir er es paragraph-image"><div role="button" tabindex="0" class="is it di iu bf iv"><div class="er es ln"><img src="../Images/0df7b8889b960a8ac7d4e8803bc089f1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wlZ0phJwvdAMfU5kLLjF1w.png"/></div></div><figcaption class="lo lp et er es lq lr bd b be z dx translated">显示了执行过程是如何逐行进行的</figcaption></figure><p id="b2c6" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated">同样，它自己按顺序一行一行地执行。所以问题是，当重载的进程或函数出现在代码中间，并且花费太多时间来完成它的工作时会发生什么！🤔下面的例子展示了它是如何发生的！</p><figure class="in io ip iq fd ir er es paragraph-image"><div role="button" tabindex="0" class="is it di iu bf iv"><div class="er es ls"><img src="../Images/c24cd048ca2a8b4235689175b20c1b42.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WkSmCoazwERqjGdGjdJD_w.png"/></div></div><figcaption class="lo lp et er es lq lr bd b be z dx translated">在代码中间提取请求</figcaption></figure><p id="5585" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated">你可以看到有一个<strong class="ja hj">获取请求</strong>，它在源代码的中间！所以相对而言，遍历网络并找到资源要花费很多时间。如果源代码有多个这样的函数，那么代码的其余部分应该会在执行期间面临延迟和阻塞。为了防止这种情况，我们必须使用线程同步方法作为 JavaScript 中的异步函数。这将导致等待或阻止其余代码的执行，直到 fetch 函数执行为止😑。这些是导致进程阻塞的一些进程。</p><ul class=""><li id="9d90" class="kz la hi ja b jb jc jf jg jj lb jn lc jr ld jv lt lf lg lh bi translated"><strong class="ja hj">数据库连接请求</strong></li><li id="9706" class="kz la hi ja b jb li jf lj jj lk jn ll jr lm jv lt lf lg lh bi translated"><strong class="ja hj"> API 调用</strong></li><li id="a41c" class="kz la hi ja b jb li jf lj jj lk jn ll jr lm jv lt lf lg lh bi translated"><strong class="ja hj"> HTTP 请求等。</strong></li></ul><figure class="in io ip iq fd ir er es paragraph-image"><div role="button" tabindex="0" class="is it di iu bf iv"><div class="er es lu"><img src="../Images/acf4a3ded50f403cb52c6fcc5e27f3a0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5ShkHj1u7Li2k-pR_0loCA.png"/></div></div><figcaption class="lo lp et er es lq lr bd b be z dx translated">代码中间的数据库连接请求</figcaption></figure><p id="d686" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated">为了防止这些中断，JavaScript 的开发者引入了异步函数理论。在这里，我演示了它是如何工作的，以及工作流程是如何进行的。😎</p><h1 id="4e8a" class="jw jx hi bd jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt bi translated"><strong class="ak"> 3。异步ˌ非同步(asynchronous)..前往救援</strong>🤠</h1><p id="a5ee" class="pw-post-body-paragraph iy iz hi ja b jb ku jd je jf kv jh ji jj kw jl jm jn kx jp jq jr ky jt ju jv hb bi translated">以下是我在几种情况下经历和使用的一些功能性方法来防止这些干扰。</p><ol class=""><li id="864e" class="kz la hi ja b jb jc jf jg jj lb jn lc jr ld jv le lf lg lh bi translated"><strong class="ja hj">超时功能方法</strong></li><li id="e008" class="kz la hi ja b jb li jf lj jj lk jn ll jr lm jv le lf lg lh bi translated"><strong class="ja hj">异步/等待方法</strong></li><li id="de42" class="kz la hi ja b jb li jf lj jj lk jn ll jr lm jv le lf lg lh bi translated"><strong class="ja hj">回调函数方法</strong></li><li id="5085" class="kz la hi ja b jb li jf lj jj lk jn ll jr lm jv le lf lg lh bi translated"><strong class="ja hj">承诺功能</strong></li></ol><p id="02df" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated"><em class="lv">让我们一个一个来了解它的工作原理吧！…..</em></p><h1 id="85d0" class="jw jx hi bd jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt bi translated"><strong class="ak"> 3.1 超时功能方法</strong>⏰</h1><p id="a7a7" class="pw-post-body-paragraph iy iz hi ja b jb ku jd je jf kv jh ji jj kw jl jm jn kx jp jq jr ky jt ju jv hb bi translated">在这个方法中，我们可以给函数设置一个超时，给时间来结束进程，并通过使用回调函数调用它，并在最后执行。</p><figure class="in io ip iq fd ir er es paragraph-image"><div role="button" tabindex="0" class="is it di iu bf iv"><div class="er es lw"><img src="../Images/b721d3b7e10169cc0ca2be77643c18bb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*shlh8pa1uSCW_YBEZ-kfhQ.png"/></div></div><figcaption class="lo lp et er es lq lr bd b be z dx translated">超时方法的基本语法</figcaption></figure><p id="1edb" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated">在这里，我们必须以毫秒为单位给出超时时间，如下所示。所以 1 秒等于 1000 毫秒(1s = 1000ms 毫秒)</p><p id="86f3" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated">通过使用这种方法，我们可以将复杂的过程函数包含到这个程序块中，并执行程序的其余部分，而不会像🥳那样遇到任何麻烦</p><figure class="in io ip iq fd ir er es paragraph-image"><div role="button" tabindex="0" class="is it di iu bf iv"><div class="er es lx"><img src="../Images/26e30677543cea51589f296cfe7c3917.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XMxTnjyePVVU6PzHpEANSQ.png"/></div></div><figcaption class="lo lp et er es lq lr bd b be z dx translated">获取请求函数在超时函数内</figcaption></figure><p id="4bc8" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated">我们可以看到，fetch 请求函数位于超时函数块内部，它执行得很好，没有妨碍其余代码的处理。</p><figure class="in io ip iq fd ir er es paragraph-image"><div role="button" tabindex="0" class="is it di iu bf iv"><div class="er es ly"><img src="../Images/5883bf7ff5aaed4a04e2fb4565afad00.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WXlOmH6hxBpAQQcTMpZhDQ.png"/></div></div><figcaption class="lo lp et er es lq lr bd b be z dx translated">超时回调如何工作的概念性视图</figcaption></figure><h1 id="5996" class="jw jx hi bd jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt bi translated">3.2 异步/等待函数方法😏</h1><p id="2311" class="pw-post-body-paragraph iy iz hi ja b jb ku jd je jf kv jh ji jj kw jl jm jn kx jp jq jr ky jt ju jv hb bi translated">Async / await 函数是在源代码中使用“Async”关键字和“await”关键字声明的函数。这些功能还支持异步的、基于承诺的行为，从而使书写风格更加整洁。</p><p id="e0ac" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated">所以这个函数可以声明如下:</p><ol class=""><li id="9fe3" class="kz la hi ja b jb jc jf jg jj lb jn lc jr ld jv le lf lg lh bi translated"><strong class="ja hj"> <em class="lv">无超时方法:</em> </strong></li></ol><figure class="in io ip iq fd ir er es paragraph-image"><div role="button" tabindex="0" class="is it di iu bf iv"><div class="er es lz"><img src="../Images/83724b793cbc0daa0df127071545e1d5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kj4G76xuor7XShRY9-Af8g.png"/></div></div><figcaption class="lo lp et er es lq lr bd b be z dx translated">无超时的异步 await 函数</figcaption></figure><blockquote class="ma mb mc"><p id="60bd" class="iy iz lv ja b jb jc jd je jf jg jh ji md jk jl jm me jo jp jq mf js jt ju jv hb bi translated">注意:上面的基本语法显示了如何将函数名和变量作为关键字。</p></blockquote><p id="8929" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated">在这个函数中，我们不会使用超时期限。这种类型的函数可以用在不需要关注时间和进程持续时间的程序中。在下一个方法中，我将向您展示如何在代码中使用超时函数，该函数可用于时间集中的流程。</p><p id="276a" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated"><strong class="ja hj"> 2。<em class="lv">超时功能方法:</em> </strong></p><figure class="in io ip iq fd ir er es paragraph-image"><div role="button" tabindex="0" class="is it di iu bf iv"><div class="er es mg"><img src="../Images/a3233bbf572529048daf5ee454e52501.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2MxbupIX5-83p-gqoUTpTA.png"/></div></div><figcaption class="lo lp et er es lq lr bd b be z dx translated">带有超时的异步 await 函数</figcaption></figure><blockquote class="ma mb mc"><p id="5560" class="iy iz lv ja b jb jc jd je jf jg jh ji md jk jl jm me jo jp jq mf js jt ju jv hb bi translated">注意:在超时值中，我们应该给上面例子中的语法以毫秒为单位</p></blockquote><p id="0f65" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated">因此，这里我们可以使用一个超时周期，给程序中的时间部分一些时间来处理。我们还必须给出 myResolve 和 myReject 作为回调方法。它们的定义如下…🙃</p><ol class=""><li id="0390" class="kz la hi ja b jb jc jf jg jj lb jn lc jr ld jv le lf lg lh bi translated"><strong class="ja hj"> myResolve -:如果作业/进程成功完成，并有一个结果值。</strong></li><li id="b53a" class="kz la hi ja b jb li jf lj jj lk jn ll jr lm jv le lf lg lh bi translated"><strong class="ja hj"> myReject -:如果发生错误，该错误被称为错误对象。</strong></li></ol><h1 id="5f4b" class="jw jx hi bd jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt bi translated">3.3 回调函数方法🧑‍🎤</h1><p id="3279" class="pw-post-body-paragraph iy iz hi ja b jb ku jd je jf kv jh ji jj kw jl jm jn kx jp jq jr ky jt ju jv hb bi translated">这个函数的主要和最简单的思想是</p><blockquote class="ma mb mc"><p id="7df6" class="iy iz lv ja b jb jc jd je jf jg jh ji md jk jl jm me jo jp jq mf js jt ju jv hb bi translated"><strong class="ja hj"> <em class="hi">“我稍后再打！”</em> </strong> <em class="hi">🤭</em></p></blockquote><p id="1093" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated"><strong class="ja hj">那么这是什么意思？？</strong> <br/> *在最简单的意义上，回调是作为参数传递给另一个独立函数的函数！这种技术允许几个函数调用另一个常用函数。它可以在另一个函数完成其进程后运行。</p><ol class=""><li id="5632" class="kz la hi ja b jb jc jf jg jj lb jn lc jr ld jv le lf lg lh bi translated"><strong class="ja hj">基本函数调用方法</strong></li></ol><figure class="in io ip iq fd ir er es paragraph-image"><div role="button" tabindex="0" class="is it di iu bf iv"><div class="er es mh"><img src="../Images/96e5bf628ce119afa22de85804923ced.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_yDOdqThoc54Q9rCe7xGWA.png"/></div></div><figcaption class="lo lp et er es lq lr bd b be z dx translated">基本常用语法</figcaption></figure><p id="f2c3" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated">这是我们在没有任何同步或超时方法的情况下使用的基本标准语法。因此，我们可以将它们与同步和超时方法一起使用，如下所述。</p><p id="0051" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated">2 <strong class="ja hj">。使用回调函数的基本语法</strong></p><figure class="in io ip iq fd ir er es paragraph-image"><div role="button" tabindex="0" class="is it di iu bf iv"><div class="er es mi"><img src="../Images/567f0eaba4fc17b50d51fb08e170c3b9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ROZl9zyZ_7IMSSrn6P9CLw.png"/></div></div><figcaption class="lo lp et er es lq lr bd b be z dx translated">回调函数基本语法</figcaption></figure><p id="1c4a" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated">我们必须将回调函数声明为一个变量，并像上面一样在几个地方调用它。在这种情况下，我们可以通过在通常的时间回调它来使用它。</p><h1 id="940a" class="jw jx hi bd jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt bi translated">3.4 承诺功能🤝</h1><p id="88d5" class="pw-post-body-paragraph iy iz hi ja b jb ku jd je jf kv jh ji jj kw jl jm jn kx jp jq jr ky jt ju jv hb bi translated">Promises 函数基于函数内部的<strong class="ja hj"> resolve 方法</strong>和<strong class="ja hj"> reject 方法</strong>。这个函数主要用于<strong class="ja hj"> API 获取请求</strong>和它的操作或者从服务器在线获取东西🙂。</p><figure class="in io ip iq fd ir er es paragraph-image"><div role="button" tabindex="0" class="is it di iu bf iv"><div class="er es mj"><img src="../Images/f0029a33d15d1b22945f4a3b3c4f9d17.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*a1J_L6efjMVgANaiqd9FLw.png"/></div></div><figcaption class="lo lp et er es lq lr bd b be z dx translated">使用承诺功能</figcaption></figure><blockquote class="ma mb mc"><p id="b20d" class="iy iz lv ja b jb jc jd je jf jg jh ji md jk jl jm me jo jp jq mf js jt ju jv hb bi translated">同样，我们可以在必要的地方将 promises 函数应用到程序中，比如 fetch <strong class="ja hj"> API 请求</strong>等。</p></blockquote></div><div class="ab cl if ig gp ih" role="separator"><span class="ii bw bk ij ik il"/><span class="ii bw bk ij ik il"/><span class="ii bw bk ij ik"/></div><div class="hb hc hd he hf"><p id="16d0" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated">所以这些方法是可以在 Async JS 中使用的主要功能，如上所述。这篇关于 Async JS 的博文到此结束。当你阅读这个博客时，如果你发现任何错误或任何更好的想法！请在下面留下评论。我会尽快回复你，以后会有新的博客😎。谢谢你，❤</p></div></div>    
</body>
</html>