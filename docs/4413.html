<html>
<head>
<title>Creating a modular waypoint system | Unity</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">创建模块化航路点系统| Unity</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/creating-a-modular-waypoint-system-unity-49cf6dc6e430?source=collection_archive---------3-----------------------#2021-07-20">https://medium.com/nerd-for-tech/creating-a-modular-waypoint-system-unity-49cf6dc6e430?source=collection_archive---------3-----------------------#2021-07-20</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><h2 id="79db" class="hg hh hi bd b fp hj hk hl hm hn ho dx hp translated" aria-label="kicker paragraph">统一指南</h2><div class=""/><div class=""><h2 id="e124" class="pw-subtitle-paragraph io hr hi bd b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf dx translated">关于如何在 Unity 中创建模块化航路点系统的快速指南</h2></div><figure class="jh ji jj jk fd jl er es paragraph-image"><div role="button" tabindex="0" class="jm jn di jo bf jp"><div class="er es jg"><img src="../Images/a83276e200bf120d8f2484af20d1806c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*Nv5F8rqQp7gbFF49be1jCw.gif"/></div></div></figure><p id="9f89" class="pw-post-body-paragraph js jt hi ju b jv jw is jx jy jz iv ka kb kc kd ke kf kg kh ki kj kk kl km kn hb bi translated">目标:创建一个模块化的路点系统来统一移动 NPC。</p><p id="0ad0" class="pw-post-body-paragraph js jt hi ju b jv jw is jx jy jz iv ka kb kc kd ke kf kg kh ki kj kk kl km kn hb bi translated">在上一篇文章中，我介绍了<a class="ae ko" rel="noopener" href="/nerd-for-tech/using-the-animation-system-unity-d80c8be71f87">如何在 Unity 中使用动画系统来制作玩家</a>的动画。现在，是时候创建一个模块化的路点系统，让 NPC(不可玩的角色)跟随一条统一的路径。</p><h1 id="3c7a" class="kp kq hi bd kr ks kt ku kv kw kx ky kz ix la iy lb ja lc jb ld jd le je lf lg bi translated">NPC</h1><p id="96c0" class="pw-post-body-paragraph js jt hi ju b jv lh is jx jy li iv ka kb lj kd ke kf lk kh ki kj ll kl km kn hb bi translated">在当前场景中，我们有一些 NPC，如果他们看到它，他们会识别玩家。这些 NPC 是 3 个守卫，周围有一些陈列柜:</p><figure class="jh ji jj jk fd jl er es paragraph-image"><div role="button" tabindex="0" class="jm jn di jo bf jp"><div class="er es jg"><img src="../Images/6d1c09b5bc8e62656028f6dcfe05d5e6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-Q623okdaqMrE1e77eoL5Q.png"/></div></div></figure><p id="50b5" class="pw-post-body-paragraph js jt hi ju b jv jw is jx jy jz iv ka kb kc kd ke kf kg kh ki kj kk kl km kn hb bi translated">如果你关注了我的上一篇帖子，你会记得我们已经使用了一个<strong class="ju hs"> <em class="lm">导航网</em> </strong> <em class="lm"> </em> <strong class="ju hs"> <em class="lm">代理</em> </strong>来移动玩家。这是我们已经在场景中烘焙过的<strong class="ju hs"> NavMesh </strong>:</p><figure class="jh ji jj jk fd jl er es paragraph-image"><div role="button" tabindex="0" class="jm jn di jo bf jp"><div class="er es jg"><img src="../Images/85bb9775e413b4fdc44534a737b55c49.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MO_X8d_lCLjMHMYWH2lkFA.png"/></div></div></figure><p id="0b86" class="pw-post-body-paragraph js jt hi ju b jv jw is jx jy jz iv ka kb kc kd ke kf kg kh ki kj kk kl km kn hb bi translated">因此，为了通过地板路径移动 NPC，让我们为它们添加一个<strong class="ju hs"> <em class="lm">导航网格代理</em> </strong>组件:</p><div class="jh ji jj jk fd ab cb"><figure class="ln jl lo lp lq lr ls paragraph-image"><div role="button" tabindex="0" class="jm jn di jo bf jp"><img src="../Images/48a6dae72b9a1ebf02bf48a67dd31abf.png" data-original-src="https://miro.medium.com/v2/resize:fit:990/1*0fPeEBaC2o83ox9P9MTvlw.gif"/></div></figure><figure class="ln jl lt lp lq lr ls paragraph-image"><div role="button" tabindex="0" class="jm jn di jo bf jp"><img src="../Images/29792c73270afee9bd9c89866c6c6711.png" data-original-src="https://miro.medium.com/v2/resize:fit:1012/1*80JrvefT8dBg0vQgkggu9Q.gif"/></div></figure></div><figure class="jh ji jj jk fd jl er es paragraph-image"><div role="button" tabindex="0" class="jm jn di jo bf jp"><div class="er es jg"><img src="../Images/918787295b9df199d103727cf08cb755.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*W2f8iQfSId_9ePLSB9BofA.png"/></div></div></figure><p id="a117" class="pw-post-body-paragraph js jt hi ju b jv jw is jx jy jz iv ka kb kc kd ke kf kg kh ki kj kk kl km kn hb bi translated">然后，让我们给它们添加下一个组件:</p><ul class=""><li id="bd26" class="lu lv hi ju b jv jw jy jz kb lw kf lx kj ly kn lz ma mb mc bi translated">新脚本</li></ul><p id="36d8" class="pw-post-body-paragraph js jt hi ju b jv jw is jx jy jz iv ka kb kc kd ke kf kg kh ki kj kk kl km kn hb bi translated">使用模块化系统处理航路点的移动。</p><ul class=""><li id="497e" class="lu lv hi ju b jv jw jy jz kb lw kf lx kj ly kn lz ma mb mc bi translated">碰撞机</li></ul><p id="9cd2" class="pw-post-body-paragraph js jt hi ju b jv jw is jx jy jz iv ka kb kc kd ke kf kg kh ki kj kk kl km kn hb bi translated">为了触发碰撞，我们需要检测路径点。别忘了启用<strong class="ju hs"> <em class="lm">是触发</em> </strong>属性。</p><div class="jh ji jj jk fd ab cb"><figure class="ln jl md lp lq lr ls paragraph-image"><div role="button" tabindex="0" class="jm jn di jo bf jp"><img src="../Images/5b41b65fa9ab7f7cbccba5251b983760.png" data-original-src="https://miro.medium.com/v2/resize:fit:1018/1*JP-e3YVQXEhfOJjL-T0Mlw.gif"/></div></figure><figure class="ln jl me lp lq lr ls paragraph-image"><div role="button" tabindex="0" class="jm jn di jo bf jp"><img src="../Images/8d316096e2b16c47417aa55e329bd1c0.png" data-original-src="https://miro.medium.com/v2/resize:fit:984/1*ncYhD87vy-mQovZvmcKCbQ.gif"/></div></figure></div><h1 id="44a5" class="kp kq hi bd kr ks kt ku kv kw kx ky kz ix la iy lb ja lc jb ld jd le je lf lg bi translated">路标</h1><p id="1d31" class="pw-post-body-paragraph js jt hi ju b jv lh is jx jy li iv ka kb lj kd ke kf lk kh ki kj ll kl km kn hb bi translated">现在，为了避免在创建将定义路径的路点时出现混乱，让我们创建一个新的空游戏对象来存储它们:</p><figure class="jh ji jj jk fd jl er es paragraph-image"><div class="er es mf"><img src="../Images/26b193d6f4f5ed66e4665e5180e3042a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1010/1*KrUfVWQ2Nk5pafbhVlgSVA.gif"/></div></figure><p id="78ca" class="pw-post-body-paragraph js jt hi ju b jv jw is jx jy jz iv ka kb kc kd ke kf kg kh ki kj kk kl km kn hb bi translated">然后，让我们创建一个新的空对象来代表我们的第一个航点。创建完成后，让我们将游戏对象移动到各自守卫将要移动到的第一个位置:</p><div class="jh ji jj jk fd ab cb"><figure class="ln jl mg lp lq lr ls paragraph-image"><div role="button" tabindex="0" class="jm jn di jo bf jp"><img src="../Images/2a1a443168f5620611a32bb9144342c4.png" data-original-src="https://miro.medium.com/v2/resize:fit:524/1*HRESAoV6TMv3aPXG6NUn_Q.gif"/></div></figure><figure class="ln jl mh lp lq lr ls paragraph-image"><div role="button" tabindex="0" class="jm jn di jo bf jp"><img src="../Images/31d78f84c04ee2a7790c76e8941af8fc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1478/1*IcgpcdRsJtONwf3qZl70Ug.gif"/></div></figure></div><p id="73c9" class="pw-post-body-paragraph js jt hi ju b jv jw is jx jy jz iv ka kb kc kd ke kf kg kh ki kj kk kl km kn hb bi translated">现在，让我们将各自的组件添加到航路点:</p><ul class=""><li id="88b5" class="lu lv hi ju b jv jw jy jz kb lw kf lx kj ly kn lz ma mb mc bi translated">碰撞机</li></ul><p id="5f06" class="pw-post-body-paragraph js jt hi ju b jv jw is jx jy jz iv ka kb kc kd ke kf kg kh ki kj kk kl km kn hb bi translated">该组件将允许在与 NPC 的碰撞中检测到航路点。不要忘记启用<strong class="ju hs"> <em class="lm">是触发</em> </strong>属性。</p><ul class=""><li id="08e9" class="lu lv hi ju b jv jw jy jz kb lw kf lx kj ly kn lz ma mb mc bi translated">刚体</li></ul><p id="7def" class="pw-post-body-paragraph js jt hi ju b jv jw is jx jy jz iv ka kb kc kd ke kf kg kh ki kj kk kl km kn hb bi translated">这个组件将允许检测与其他有碰撞器的游戏对象(如 NPC)的碰撞。不要忘记禁用<strong class="ju hs"> <em class="lm">使用重力</em> </strong>属性，以免重力影响航路点。</p><blockquote class="mi mj mk"><p id="cbbe" class="js jt lm ju b jv jw is jx jy jz iv ka ml kc kd ke mm kg kh ki mn kk kl km kn hb bi translated">注意:我们也可以把刚体放在 NPC 中来检测碰撞，而不是把它添加到航路点中。</p></blockquote><div class="jh ji jj jk fd ab cb"><figure class="ln jl mo lp lq lr ls paragraph-image"><div role="button" tabindex="0" class="jm jn di jo bf jp"><img src="../Images/c2b625a8447b12dc5bd1f7c13049c177.png" data-original-src="https://miro.medium.com/v2/resize:fit:1002/1*OV0i-xRa-92uyGbK3mROsg.gif"/></div></figure><figure class="ln jl mp lp lq lr ls paragraph-image"><div role="button" tabindex="0" class="jm jn di jo bf jp"><img src="../Images/523dd1c1163cfa415bd8ba73a6a7f7a7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/1*OjeJL9uT7LRKx90yWA4fkg.gif"/></div></figure></div><p id="9da6" class="pw-post-body-paragraph js jt hi ju b jv jw is jx jy jz iv ka kb kc kd ke kf kg kh ki kj kk kl km kn hb bi translated">然后，让我们在场景中添加更多的路点来定义 NPC 应该遵循的路径:</p><div class="jh ji jj jk fd ab cb"><figure class="ln jl mg lp lq lr ls paragraph-image"><div role="button" tabindex="0" class="jm jn di jo bf jp"><img src="../Images/2503a8d7074e07dbb3e615bf8059d89e.png" data-original-src="https://miro.medium.com/v2/resize:fit:524/1*2l9r-To9Okxp39b4B7TAxw.gif"/></div></figure><figure class="ln jl mh lp lq lr ls paragraph-image"><div role="button" tabindex="0" class="jm jn di jo bf jp"><img src="../Images/b31638a1e7694edefab3afaf11af814f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1478/format:webp/1*mMYvc7KZw91Fsi7H0_yaPQ.png"/></div></figure></div><p id="4eb5" class="pw-post-body-paragraph js jt hi ju b jv jw is jx jy jz iv ka kb kc kd ke kf kg kh ki kj kk kl km kn hb bi translated">最后，让我们为航路点游戏对象创建并选择一个新标签:</p><div class="jh ji jj jk fd ab cb"><figure class="ln jl mq lp lq lr ls paragraph-image"><div role="button" tabindex="0" class="jm jn di jo bf jp"><img src="../Images/8ae8543a1221220a42dadff1e745523a.png" data-original-src="https://miro.medium.com/v2/resize:fit:986/1*2F70Bj9hyE0s8wmZo8GRew.gif"/></div></figure><figure class="ln jl mr lp lq lr ls paragraph-image"><div role="button" tabindex="0" class="jm jn di jo bf jp"><img src="../Images/81c6aae2f455c7c80babe8894feea9f3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1016/1*a_Vr7_VtCoa19Sg5RGnVBQ.gif"/></div></figure></div><h1 id="d8a2" class="kp kq hi bd kr ks kt ku kv kw kx ky kz ix la iy lb ja lc jb ld jd le je lf lg bi translated">模块化系统</h1><p id="b866" class="pw-post-body-paragraph js jt hi ju b jv lh is jx jy li iv ka kb lj kd ke kf lk kh ki kj ll kl km kn hb bi translated">现在，为了创建模块化的航点系统，让我们打开之前附加到 NPC 上的新<strong class="ju hs"> AIGuard </strong>脚本。当我们使用<strong class="ju hs"> <em class="lm">导航网格代理</em> </strong>来移动 NPC 时，我们需要将 AI 名称空间添加到我们的脚本中:</p><figure class="jh ji jj jk fd jl er es paragraph-image"><div class="er es ms"><img src="../Images/e2d3145e845024fb33f8ef9c918d43f4.png" data-original-src="https://miro.medium.com/v2/resize:fit:980/format:webp/1*cFwcoO-uUGweni8nSAJG_g.png"/></div></figure><p id="50cd" class="pw-post-body-paragraph js jt hi ju b jv jw is jx jy jz iv ka kb kc kd ke kf kg kh ki kj kk kl km kn hb bi translated">然后，让我们创建:</p><ul class=""><li id="ff16" class="lu lv hi ju b jv jw jy jz kb lw kf lx kj ly kn lz ma mb mc bi translated">导航代理</li></ul><p id="8273" class="pw-post-body-paragraph js jt hi ju b jv jw is jx jy jz iv ka kb kc kd ke kf kg kh ki kj kk kl km kn hb bi translated">此变量将存储对附加到 NPC 的<strong class="ju hs"> <em class="lm">导航网格代理</em> </strong>组件的引用。</p><ul class=""><li id="670c" class="lu lv hi ju b jv jw jy jz kb lw kf lx kj ly kn lz ma mb mc bi translated">航点</li></ul><p id="a3c5" class="pw-post-body-paragraph js jt hi ju b jv jw is jx jy jz iv ka kb kc kd ke kf kg kh ki kj kk kl km kn hb bi translated">该列表将存储定义 NPC 将遵循的路径的路点的不同变换组件。转换组件应该从路径的第一个到最后一个路点排序。不要忘记使用<strong class="ju hs">【串行字段】</strong>来通过检查器定义路径点。</p><ul class=""><li id="fd81" class="lu lv hi ju b jv jw jy jz kb lw kf lx kj ly kn lz ma mb mc bi translated">目标</li></ul><p id="d582" class="pw-post-body-paragraph js jt hi ju b jv jw is jx jy jz iv ka kb kc kd ke kf kg kh ki kj kk kl km kn hb bi translated">该整数变量将存储<strong class="ju hs"> <em class="lm">导航网格代理</em> </strong>要到达的当前目标(在航路点列表内)的索引。</p><figure class="jh ji jj jk fd jl er es paragraph-image"><div class="er es mt"><img src="../Images/86116c4ceb053ea984f1c6a003bdb779.png" data-original-src="https://miro.medium.com/v2/resize:fit:1164/format:webp/1*-TuULpl66qR3rYoFbKR9ww.png"/></div></figure><p id="e370" class="pw-post-body-paragraph js jt hi ju b jv jw is jx jy jz iv ka kb kc kd ke kf kg kh ki kj kk kl km kn hb bi translated">现在，让我们将各自的路点按顺序拖到第一个 NPC:</p><div class="jh ji jj jk fd ab cb"><figure class="ln jl mu lp lq lr ls paragraph-image"><img src="../Images/2cc30743c62b3fb1668bf433651bbc03.png" data-original-src="https://miro.medium.com/v2/resize:fit:1010/1*zpKvxoC9DVcN25WeZKiV1A.gif"/></figure><figure class="ln jl mv lp lq lr ls paragraph-image"><div role="button" tabindex="0" class="jm jn di jo bf jp"><img src="../Images/6af9ec104514de3cc77585daf0f53874.png" data-original-src="https://miro.medium.com/v2/resize:fit:990/1*aKug0yXm9I-G6Kn24BddHA.gif"/></div></figure></div><p id="4f33" class="pw-post-body-paragraph js jt hi ju b jv jw is jx jy jz iv ka kb kc kd ke kf kg kh ki kj kk kl km kn hb bi translated">接下来，在<strong class="ju hs"> Start </strong>方法中，让我们通过使用<strong class="ju hs"> GetComponent </strong>方法用<strong class="ju hs"> <em class="lm"> Nav Mesh Agent </em> </strong>初始化变量。然后，让我们验证航路点列表是否包含至少两个元素，并且第一个元素不为空。如果是这样的话，让我们将<strong class="ju hs"> <em class="lm">导航网格代理</em> </strong>的目的地设置为第一个变换位置:</p><figure class="jh ji jj jk fd jl er es paragraph-image"><div role="button" tabindex="0" class="jm jn di jo bf jp"><div class="er es mw"><img src="../Images/93fd5008afadfe972649911e29aabef9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*viosqU0GGa98U1cZx0CeJg.png"/></div></div><figcaption class="mx my et er es mz na bd b be z dx translated">这样，NPC 将前往第一个航路点。</figcaption></figure><p id="e9a2" class="pw-post-body-paragraph js jt hi ju b jv jw is jx jy jz iv ka kb kc kd ke kf kg kh ki kj kk kl km kn hb bi translated">现在，为了检测与航路点的触发碰撞，让我们使用<strong class="ju hs"> OnTriggerEnter </strong>方法，并使用各自的标签检查另一个碰撞器是否属于某个航路点:</p><figure class="jh ji jj jk fd jl er es paragraph-image"><div role="button" tabindex="0" class="jm jn di jo bf jp"><div class="er es nb"><img src="../Images/6d224d3b96f5c3039f8c83796a4bce13.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*P9KLDCbHTjTk7ksCqbCOYg.png"/></div></div></figure><p id="1d0a" class="pw-post-body-paragraph js jt hi ju b jv jw is jx jy jz iv ka kb kc kd ke kf kg kh ki kj kk kl km kn hb bi translated">如果检测到一个航路点，让我们给目标变量添加一个单位，指向列表中的下一个航路点。</p><p id="7ac8" class="pw-post-body-paragraph js jt hi ju b jv jw is jx jy jz iv ka kb kc kd ke kf kg kh ki kj kk kl km kn hb bi translated">然后，让我们检查目标是否指向列表中不存在的航路点，如果是，让我们使用<strong class="ju hs">反转</strong>方法来反转列表中航路点的顺序，并定义新目标(倒数第二个航路点)。</p><p id="4cf8" class="pw-post-body-paragraph js jt hi ju b jv jw is jx jy jz iv ka kb kc kd ke kf kg kh ki kj kk kl km kn hb bi translated">这样，NPC 将从最后一个航路点到第一个航路点(并向后)一遍又一遍地遵循相同的路径:</p><figure class="jh ji jj jk fd jl er es paragraph-image"><div class="er es nc"><img src="../Images/dba378d3c312225e71d295ff18777991.png" data-original-src="https://miro.medium.com/v2/resize:fit:1310/format:webp/1*V1OQbkLsVeBaXTnBEN1mdg.png"/></div></figure><p id="d7c6" class="pw-post-body-paragraph js jt hi ju b jv jw is jx jy jz iv ka kb kc kd ke kf kg kh ki kj kk kl km kn hb bi translated">最后，让我们检查用目标变量定义的航路点在列表中是否不为空，并将其设置为<strong class="ju hs"> <em class="lm">导航网格代理</em> </strong>的新目的地:</p><figure class="jh ji jj jk fd jl er es paragraph-image"><div role="button" tabindex="0" class="jm jn di jo bf jp"><div class="er es nd"><img src="../Images/644655b28b9215f52f313e1ca9352dd0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rTdCwfssqtKqMP2symTQ8w.png"/></div></div></figure><p id="8dc2" class="pw-post-body-paragraph js jt hi ju b jv jw is jx jy jz iv ka kb kc kd ke kf kg kh ki kj kk kl km kn hb bi translated">现在，如果我们在 Unity 中运行游戏，我们会看到 NPC 一遍又一遍地沿着由路点定义的路径前进:</p><figure class="jh ji jj jk fd jl er es paragraph-image"><div role="button" tabindex="0" class="jm jn di jo bf jp"><div class="er es jg"><img src="../Images/69ccb6fe9567eead6e7fbcfaa96c4d12.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*zwUePv-3zphql6tcJj5Tsg.gif"/></div></div></figure><figure class="jh ji jj jk fd jl er es paragraph-image"><div role="button" tabindex="0" class="jm jn di jo bf jp"><div class="er es jg"><img src="../Images/ea895915ec22f7124b29f00d33315e66.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*hpWu8Cz8Dxt8CNfySQNBdg.gif"/></div></div></figure><p id="d383" class="pw-post-body-paragraph js jt hi ju b jv jw is jx jy jz iv ka kb kc kd ke kf kg kh ki kj kk kl km kn hb bi translated">这样，我们就可以在游戏中与其他 NPC 使用相同的脚本和更多的路点。</p><p id="9dc1" class="pw-post-body-paragraph js jt hi ju b jv jw is jx jy jz iv ka kb kc kd ke kf kg kh ki kj kk kl km kn hb bi translated">就这样，我们在 Unity 中创建了一个模块化的航点系统！:d .我会在下一个帖子中看到你，在那里我会展示如何让 NPC 看到玩家的团结。</p></div><div class="ab cl ne nf gp ng" role="separator"><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj"/></div><div class="hb hc hd he hf"><blockquote class="mi mj mk"><p id="696c" class="js jt lm ju b jv jw is jx jy jz iv ka ml kc kd ke mm kg kh ki mn kk kl km kn hb bi translated"><em class="hi">如果你想更多地了解我，欢迎登陆</em><a class="ae ko" href="https://www.linkedin.com/in/fas444/" rel="noopener ugc nofollow" target="_blank"><strong class="ju hs"><em class="hi">LinkedIn</em></strong></a><strong class="ju hs"><em class="hi"/></strong><em class="hi">或访问我的</em> <a class="ae ko" href="http://fernandoalcasan.com/" rel="noopener ugc nofollow" target="_blank"> <strong class="ju hs"> <em class="hi">网站</em> </strong> </a> <em class="hi"> :D </em></p></blockquote></div></div>    
</body>
</html>