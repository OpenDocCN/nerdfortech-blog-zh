<html>
<head>
<title>Generalized Matthew Package</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">广义 Matthew 包</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/generalized-matth-493fc1fbf3fa?source=collection_archive---------2-----------------------#2022-09-04">https://medium.com/nerd-for-tech/generalized-matth-493fc1fbf3fa?source=collection_archive---------2-----------------------#2022-09-04</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="200a" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">这个包能做什么？</h2></div><h2 id="76b7" class="ix iy hi bd iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju bi translated">用<a class="ae jv" rel="noopener" href="/@uriitai"> Uri Itai </a>编写</h2><figure class="jx jy jz ka fd kb er es paragraph-image"><div class="er es jw"><img src="../Images/cb5e9828702688610b783e93af0ef72b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1260/format:webp/1*WJ4a9ipaBbO3COn5NCc0Fw.png"/></div><figcaption class="ke kf et er es kg kh bd b be z dx translated">图片来自 https://arxiv.org/pdf/2208.05651.pdf<a class="ae jv" href="https://arxiv.org/pdf/2208.05651.pdf" rel="noopener ugc nofollow" target="_blank"/></figcaption></figure><h1 id="60ed" class="ki iy hi bd iz kj kk kl jd km kn ko jh io kp ip jl ir kq is jp iu kr iv jt ks bi translated">马太相关系数是多少？</h1><p id="4741" class="pw-post-body-paragraph kt ku hi kv b kw kx ij ky kz la im lb ji lc ld le jm lf lg lh jq li lj lk ll hb bi translated">马修相关系数(MCC)是一种拟合优度，旨在提供比常见 KPI(如<strong class="kv hj"> F1 </strong>或<strong class="kv hj"> AUC)更好的结果。</strong>特别是，MCC 更好地处理了不平衡数据的情况(它对流行率更具竞争性)。从数学上讲，如果我们考虑一个二元分类问题，它是两个随机变量之间的一个正则皮尔逊系数:目标(<strong class="kv hj"> Y </strong>)和预测(<strong class="kv hj">Y’)</strong>。在二进制的情况下，皮尔逊相关崩溃为一个简单的公式。这里可以找到<a class="ae jv" href="https://bmcgenomics.biomedcentral.com/articles/10.1186/s12864-019-6413-7" rel="noopener ugc nofollow" target="_blank">这里</a>可以找到<a class="ae jv" href="https://www.voxco.com/blog/matthewss-correlation-coefficient-definition-formula-and-advantages/#:~:text=Matthew%27s%20correlation%20coefficient%2C%20also%20abbreviated,2%20x%202%20contingency%20table." rel="noopener ugc nofollow" target="_blank">。</a></p><h1 id="15dd" class="ki iy hi bd iz kj kk kl jd km kn ko jh io kp ip jl ir kq is jp iu kr iv jt ks bi translated">MCC 对多类问题的推广</h1><h2 id="5d08" class="ix iy hi bd iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju bi translated">不是很直白吗？</h2><p id="1cad" class="pw-post-body-paragraph kt ku hi kv b kw kx ij ky kz la im lb ji lc ld le jm lf lg lh jq li lj lk ll hb bi translated">皮尔逊相关在非二元分类世界中不存在。因为拓扑是离散的并且值的集合是不可排序的。因此，将 MCC 推广到多类问题需要对我们的定义进行一些修改。在我们发表的一篇论文中。我们通过使用不同类型的<strong class="kv hj">方法来解决这个问题。</strong></p><p id="6572" class="pw-post-body-paragraph kt ku hi kv b kw lm ij ky kz ln im lb ji lo ld le jm lp lg lh jq lq lj lk ll hb bi translated">我们在这里展示的 python 包是这些思想的实现。</p><p id="99b0" class="pw-post-body-paragraph kt ku hi kv b kw lm ij ky kz ln im lb ji lo ld le jm lp lg lh jq lq lj lk ll hb bi translated">我们将简要介绍显著类型的方法，这里我们只讨论正数。</p><h2 id="7084" class="ix iy hi bd iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju bi translated">等差中项</h2><p id="911a" class="pw-post-body-paragraph kt ku hi kv b kw kx ij ky kz la im lb ji lc ld le jm lf lg lh jq li lj lk ll hb bi translated">两个数的权重相等时最常用的型均值</p><h2 id="2bd5" class="ix iy hi bd iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju bi translated">加权平均数</h2><p id="99ff" class="pw-post-body-paragraph kt ku hi kv b kw kx ij ky kz la im lb ji lc ld le jm lf lg lh jq li lj lk ll hb bi translated">类似于算术平均值，但权重不同</p><h2 id="ec20" class="ix iy hi bd iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju bi translated">几何平均值</h2><p id="bc0b" class="pw-post-body-paragraph kt ku hi kv b kw kx ij ky kz la im lb ji lc ld le jm lf lg lh jq li lj lk ll hb bi translated">这里我们计算两个正数乘积的<a class="ae jv" href="https://en.wikipedia.org/wiki/Geometric_mean" rel="noopener ugc nofollow" target="_blank">平方</a>根。了解对数分数的读者可能会觉得很熟悉。</p><h2 id="8205" class="ix iy hi bd iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju bi translated">调和平均值</h2><p id="23a9" class="pw-post-body-paragraph kt ku hi kv b kw kx ij ky kz la im lb ji lc ld le jm lf lg lh jq li lj lk ll hb bi translated">两个<a class="ae jv" href="https://en.wikipedia.org/wiki/Harmonic_mean" rel="noopener ugc nofollow" target="_blank">倒数之和的倒数</a></p><p id="26e2" class="pw-post-body-paragraph kt ku hi kv b kw lm ij ky kz ln im lb ji lo ld le jm lp lg lh jq lq lj lk ll hb bi translated">调和平均值的一个 ML 例子是<a class="ae jv" href="https://en.wikipedia.org/wiki/F-score" rel="noopener ugc nofollow" target="_blank"> F1-score </a>，它是<strong class="kv hj">精度</strong>和<strong class="kv hj">召回</strong>之间的调和平均值。</p><h2 id="10be" class="ix iy hi bd iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju bi translated">HM-GM-AM 不等式</h2><p id="34eb" class="pw-post-body-paragraph kt ku hi kv b kw kx ij ky kz la im lb ji lc ld le jm lf lg lh jq li lj lk ll hb bi translated">一个常见的不等式表述为:对于两个正数<strong class="kv hj"> X </strong>、<strong class="kv hj">和 Y </strong>，它们的调和均值小于它们的几何均值，几何均值小于它们的算术均值。</p><p id="70d5" class="pw-post-body-paragraph kt ku hi kv b kw lm ij ky kz ln im lb ji lo ld le jm lp lg lh jq lq lj lk ll hb bi translated">在<a class="ae jv" href="https://arxiv.org/pdf/2208.05651.pdf" rel="noopener ugc nofollow" target="_blank">论文</a>中，我们利用这些手段将 F1 和 Matthew 推广到多类问题。</p><h1 id="f92c" class="ki iy hi bd iz kj kk kl jd km kn ko jh io kp ip jl ir kq is jp iu kr iv jt ks bi translated">python 包</h1><p id="cc16" class="pw-post-body-paragraph kt ku hi kv b kw kx ij ky kz la im lb ji lc ld le jm lf lg lh jq li lj lk ll hb bi translated">数学是美好的，证明关于手段的引理是可怕的。然而，正如每个数据科学家都知道的那样，只有当你可以用法律语言(如 Python、Python 或在极端情况下用 Python)谈论数据科学项目时，它才存在。因此，我们在一个新的 Python 包中组织了我们的结果:<a class="ae jv" href="https://pypi.org/project/generalized-matth/" rel="noopener ugc nofollow" target="_blank"><strong class="kv hj">generalized _ matth</strong></a><strong class="kv hj">。</strong></p><p id="9323" class="pw-post-body-paragraph kt ku hi kv b kw lm ij ky kz ln im lb ji lo ld le jm lp lg lh jq lq lj lk ll hb bi translated">因为我们专注于两个目标:</p><ul class=""><li id="cad3" class="lr ls hi kv b kw lm kz ln ji lt jm lu jq lv ll lw lx ly lz bi translated">将马修推广到多类问题</li><li id="8df5" class="lr ls hi kv b kw ma kz mb ji mc jm md jq me ll lw lx ly lz bi translated">创建一个工具来与我们的广义 F1 进行比较</li></ul><p id="02fa" class="pw-post-body-paragraph kt ku hi kv b kw lm ij ky kz ln im lb ji lo ld le jm lp lg lh jq lq lj lk ll hb bi translated">我们需要一组函数，既能计算综合得分，又能比较拟合质量的优劣:</p><h2 id="3f9c" class="ix iy hi bd iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju bi translated">调用基对象</h2><p id="9c37" class="pw-post-body-paragraph kt ku hi kv b kw kx ij ky kz la im lb ji lc ld le jm lf lg lh jq li lj lk ll hb bi translated">我们从调用执行函数计算的主对象开始:</p><pre class="jx jy jz ka fd mf mg mh mi aw mj bi"><span id="14f2" class="ix iy hi mg b fi mk ml l mm mn"><strong class="mg hj">import </strong>generalized_matth<br/><strong class="mg hj">from </strong>generalized_matth.matt_funct <strong class="mg hj">import </strong>matthew_multiclass</span></pre><p id="fc61" class="pw-post-body-paragraph kt ku hi kv b kw lm ij ky kz ln im lb ji lo ld le jm lp lg lh jq lq lj lk ll hb bi translated">matthew _ mlticlass 是我们用来运行函数的类。我们描述一个新的枚举:</p><pre class="jx jy jz ka fd mf mg mh mi aw mj bi"><span id="69d3" class="ix iy hi mg b fi mk ml l mm mn"><strong class="mg hj">class </strong>AVERAG_TYPE(Enum):<br/>    MATTHEW_GEN = 2<br/>    F1_GEN = 3</span></pre><p id="13e6" class="pw-post-body-paragraph kt ku hi kv b kw lm ij ky kz ln im lb ji lo ld le jm lp lg lh jq lq lj lk ll hb bi translated">此枚举包含要使用的方法的类型。当前版本只有广义 F1 和广义 Matthew (F1_GEN 和 MATTHEW_GEN)。在一些更高级的代码版本中，我们将其扩展为附加手段。</p><h2 id="f14e" class="ix iy hi bd iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju bi translated">matthew _ 多类呼叫</h2><p id="e416" class="pw-post-body-paragraph kt ku hi kv b kw kx ij ky kz la im lb ji lc ld le jm lf lg lh jq li lj lk ll hb bi translated">我们提供了枚举和类名，现在我们可以展示如何调用它。</p><p id="6923" class="pw-post-body-paragraph kt ku hi kv b kw lm ij ky kz ln im lb ji lo ld le jm lp lg lh jq lq lj lk ll hb bi translated">它接收两个变量:</p><ul class=""><li id="f1f0" class="lr ls hi kv b kw lm kz ln ji lt jm lu jq lv ll lw lx ly lz bi translated"><strong class="kv hj"> y_true </strong> —目标值列表</li><li id="d543" class="lr ls hi kv b kw ma kz mb ji mc jm md jq me ll lw lx ly lz bi translated"><strong class="kv hj"> y_pred </strong> —预测值列表</li></ul><p id="e678" class="pw-post-body-paragraph kt ku hi kv b kw lm ij ky kz ln im lb ji lo ld le jm lp lg lh jq lq lj lk ll hb bi translated">这些数组具有相同的长度。</p><pre class="jx jy jz ka fd mf mg mh mi aw mj bi"><span id="8e79" class="ix iy hi mg b fi mk ml l mm mn">y_true = np.asarray([1,0,0,1,1])<br/>y_pred = np.asarray([1,1,1,0,1])<br/>test_class =matthew_multiclass(y_true,y_pred )</span></pre><p id="7bd2" class="pw-post-body-paragraph kt ku hi kv b kw lm ij ky kz ln im lb ji lo ld le jm lp lg lh jq lq lj lk ll hb bi translated">对于这样的调用，test_class 将计算广义 Matthew 分数。它相当于添加了这一行:</p><pre class="jx jy jz ka fd mf mg mh mi aw mj bi"><span id="0d3c" class="ix iy hi mg b fi mk ml l mm mn"><strong class="mg hj">from </strong>generalized_matth.matt_funct <strong class="mg hj">import </strong>AVERAG_TYPE<br/></span></pre><p id="2d7a" class="pw-post-body-paragraph kt ku hi kv b kw lm ij ky kz ln im lb ji lo ld le jm lp lg lh jq lq lj lk ll hb bi translated">打电话</p><pre class="jx jy jz ka fd mf mg mh mi aw mj bi"><span id="2723" class="ix iy hi mg b fi mk ml l mm mn">y_true = np.asarray([1,0,0,1,1])<br/>y_pred = np.asarray([1,1,1,0,1])<br/>test_class =matthew_multiclass(y_true, y_pred, avg_type=AVERAG_TYPE.MATTHEW_GEN.value )</span></pre><p id="65f5" class="pw-post-body-paragraph kt ku hi kv b kw lm ij ky kz ln im lb ji lo ld le jm lp lg lh jq lq lj lk ll hb bi translated">分数大概是-0.4082。</p><p id="80f3" class="pw-post-body-paragraph kt ku hi kv b kw lm ij ky kz ln im lb ji lo ld le jm lp lg lh jq lq lj lk ll hb bi translated">如果我们希望使用广义 F1，我们执行以下操作:</p><pre class="jx jy jz ka fd mf mg mh mi aw mj bi"><span id="b581" class="ix iy hi mg b fi mk ml l mm mn"><br/>y_true = np.asarray([1,1,1,0,0])<br/>y_pred = np.asarray([1,1,1,0,1])<br/>test_class =matthew_multiclass(y_true, y_pred, avg_type=AVERAG_TYPE.F1_GEN.value )</span></pre><p id="8d88" class="pw-post-body-paragraph kt ku hi kv b kw lm ij ky kz ln im lb ji lo ld le jm lp lg lh jq lq lj lk ll hb bi translated">要获得的分数是 0.75</p><h2 id="9c72" class="ix iy hi bd iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju bi translated">main_matthew_mult_class</h2><p id="acc5" class="pw-post-body-paragraph kt ku hi kv b kw kx ij ky kz la im lb ji lc ld le jm lf lg lh jq li lj lk ll hb bi translated">这是在包中运行的主进程。来源如下:</p><pre class="jx jy jz ka fd mf mg mh mi aw mj bi"><span id="8edd" class="ix iy hi mg b fi mk ml l mm mn"><strong class="mg hj">def </strong>main_matthew_mult_class(self):<br/>    G_mat = self.norm_confusion_mat()<br/>    <strong class="mg hj">return </strong>self.scalar_op(G_mat)</span></pre><p id="e07b" class="pw-post-body-paragraph kt ku hi kv b kw lm ij ky kz ln im lb ji lo ld le jm lp lg lh jq lq lj lk ll hb bi translated">使用了两个通用函数。后者由我们希望使用的平均类型决定:</p><h2 id="f349" class="ix iy hi bd iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju bi translated">广义 F1</h2><pre class="jx jy jz ka fd mf mg mh mi aw mj bi"><span id="a8c9" class="ix iy hi mg b fi mk ml l mm mn"><strong class="mg hj">def </strong>gen_f1_scalar_op(self, h_conf_mat):<br/>        l_mat = len(h_conf_mat)<br/>        <strong class="mg hj">return </strong>st.mstats.hmean([h_conf_mat[i][i] <strong class="mg hj">for </strong>i <strong class="mg hj">in </strong>range(l_mat)])</span></pre><h2 id="1639" class="ix iy hi bd iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju bi translated">广义马修</h2><pre class="jx jy jz ka fd mf mg mh mi aw mj bi"><span id="b2a0" class="ix iy hi mg b fi mk ml l mm mn">self.scalar_op = np.linalg.det</span></pre><h1 id="dd60" class="ki iy hi bd iz kj kk kl jd km kn ko jh io kp ip jl ir kq is jp iu kr iv jt ks bi translated">一些测试</h1><p id="6d29" class="pw-post-body-paragraph kt ku hi kv b kw kx ij ky kz la im lb ji lc ld le jm lf lg lh jq li lj lk ll hb bi translated">在本节中，我们将介绍一些测试，让读者验证他们的代码:</p><pre class="jx jy jz ka fd mf mg mh mi aw mj bi"><span id="61b5" class="ix iy hi mg b fi mk ml l mm mn">y_true = [0] * 13 + [1] * 21 + [2] * 20<br/>y_pred = [0] * 5 + [1] * 6 + [2] * 2 + [0] * 2 + [1] * 8 + [2] * 11 + [0] * 8 + [1] * 2 + [2] * 10</span><span id="6486" class="ix iy hi mg b fi mo ml l mm mn">test0 =matthew_multiclass(y_true, y_pred, avg_type=AVERAG_TYPE.F1_GEN.value)<br/>print (test0.main_matthew_mult_class())</span></pre><p id="1f00" class="pw-post-body-paragraph kt ku hi kv b kw lm ij ky kz ln im lb ji lo ld le jm lp lg lh jq lq lj lk ll hb bi translated">分数是 0.4130</p><p id="d280" class="pw-post-body-paragraph kt ku hi kv b kw lm ij ky kz ln im lb ji lo ld le jm lp lg lh jq lq lj lk ll hb bi translated">如果我们做到以下几点:</p><pre class="jx jy jz ka fd mf mg mh mi aw mj bi"><span id="d0ff" class="ix iy hi mg b fi mk ml l mm mn">test0 =matthew_multiclass(y_true, y_pred, avg_type=AVERAG_TYPE.MATTHEW_GEN.value)<br/>print (test0.main_matthew_mult_class())</span></pre><p id="01a3" class="pw-post-body-paragraph kt ku hi kv b kw lm ij ky kz ln im lb ji lo ld le jm lp lg lh jq lq lj lk ll hb bi translated">分数约为 0.031</p><p id="e319" class="pw-post-body-paragraph kt ku hi kv b kw lm ij ky kz ln im lb ji lo ld le jm lp lg lh jq lq lj lk ll hb bi translated">很明显，如果我们跑:</p><pre class="jx jy jz ka fd mf mg mh mi aw mj bi"><span id="d7bc" class="ix iy hi mg b fi mk ml l mm mn">test0 =matthew_multiclass(y_true, y_true, avg_type=AVERAG_TYPE.MATTHEW_GEN.value)<br/>print (test0.main_matthew_mult_class())<br/></span></pre><p id="85c5" class="pw-post-body-paragraph kt ku hi kv b kw lm ij ky kz ln im lb ji lo ld le jm lp lg lh jq lq lj lk ll hb bi translated">这两项功能的得分都是 1.0。</p><h2 id="e4a9" class="ix iy hi bd iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju bi translated">感谢</h2><p id="5b7f" class="pw-post-body-paragraph kt ku hi kv b kw kx ij ky kz la im lb ji lc ld le jm lf lg lh jq li lj lk ll hb bi translated">我们要感谢亚历山大·莫拉克在整个工作过程中所做的富有成效的讨论和有益的想法。</p></div></div>    
</body>
</html>