<html>
<head>
<title>Timely optimization, part 3</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">及时优化，第3部分</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/timely-optimization-part-3-e856ccea2f88?source=collection_archive---------7-----------------------#2021-11-30">https://medium.com/nerd-for-tech/timely-optimization-part-3-e856ccea2f88?source=collection_archive---------7-----------------------#2021-11-30</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="e0e9" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">避免昂贵的列表操作</h2></div><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ix"><img src="../Images/befbf7bbbaefd079917514f2469563cf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*G5Ya5zLCYyhVnKwb1VeDog.png"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">GPXmagic中的渲染选项</figcaption></figure><p id="66f4" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">以前，我写过从简单的列表搜索切换到使用二维索引(一种四叉树)的效果，以及将代码从应用程序整体移动到数据结构的影响，减少了创建结果集的开销，这些结果集只是为了以某种方式过滤或减少它们，但实际上是被丢弃的。</p><p id="c057" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">然而，列表的广泛使用是GPXmagic的一部分。它是GPS坐标列表的编辑器和可视化工具；这就是GPX文件<em class="kj">的含义</em>被过早优化咬了很多次，我通常会相当小心地避免任何过早优化。例如，正如你在上面的截图中看到的，有几个选项可以显示一个音轨。</p><p id="9b28" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">到目前为止，我还没有尝试优化这一点。我的大部分功能测试都是在中小赛道上进行的，大概有几千个GPS点。这是我用来渲染的一段代码。</p><pre class="iy iz ja jb fd kk kl km kn aw ko bi"><span id="d8a6" class="kp kq hi kl b fi kr ks l kt ku">...     <br/>        scene =<br/>            List.concat<br/>                [ graphNodes<br/>                , if options.centreLine then<br/>                    mapOverPairs (centreLineBetween gradientColourPastel)</span><span id="576e" class="kp kq hi kl b fi kv ks l kt ku">                  else<br/>                    []<br/>                , if options.roadTrack then<br/>                    mapOverPairs paintSurfaceBetween</span><span id="146a" class="kp kq hi kl b fi kv ks l kt ku">                  else<br/>                    []<br/>                , if options.curtainStyle /= NoCurtain &amp;&amp; not options.terrainOn then<br/>                    mapOverPairs (curtainBetween floorPlane gradientFunction)</span><span id="bfa8" class="kp kq hi kl b fi kv ks l kt ku">                  else<br/>                    []<br/>                , if options.roadPillars &amp;&amp; not options.terrainOn then<br/>                    mapOverPoints (roadSupportPillar floorPlane)</span><span id="422f" class="kp kq hi kl b fi kv ks l kt ku">                  else<br/>                    []<br/>                , if options.roadCones &amp;&amp; not options.terrainOn then<br/>                    mapOverPoints trackPointCone</span><span id="626b" class="kp kq hi kl b fi kv ks l kt ku">                  else<br/>                    []<br/>                ]<br/>    in<br/>    scene</span></pre><p id="b2e1" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">它遍历列表中五个可能元素中的每一个，每个元素生成一个WebGL可视元素的列表，这些元素在末尾连接在一起。相当清楚。它跑得相当快。有什么问题吗？</p><p id="077d" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">想象一下，这超过了我的一个更大的例子。它有23000点。最坏的情况下，我们要遍历五次。每次遍历都会构造一个更长的可视元素列表。然后，我们可能有五个(比如说)各有50，000个元素的列表。这些元素然后被连接成250，000个元素的最终结果。然后，部分列表被丢弃，供垃圾收集器回收。我们的峰值内存使用远远高于它所需要的。</p><p id="38db" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">这实际上更糟，因为<code class="du kw kx ky kl b">mapOverPairs</code>不经意地增加了开销:</p><pre class="iy iz ja jb fd kk kl km kn aw ko bi"><span id="fbbd" class="kp kq hi kl b fi kr ks l kt ku">mapOverPairs f =<br/>            List.concat &lt;| List.map2 f track (List.drop 1 track)</span></pre><p id="6792" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">言归正传，我正在努力减少一般的内存使用，从浏览器开发人员控制台可以明显看出，添加图形元素会消耗数十兆字节，因此这似乎是值得一试的事情。</p><p id="23f3" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">我们所需要做的就是重组控制流程，这样我们就可以在赛道上运行一次，并为每个点应用所有的活动选项，同时消除<code class="du kw kx ky kl b">mapOverPairs</code>。然而，我不想仅仅移动遍历中的<code class="du kw kx ky kl b">if ...</code>结构；这看起来很傻，因为他们不可能在手术过程中改变。</p><p id="23d7" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">我以这个结尾:</p><pre class="iy iz ja jb fd kk kl km kn aw ko bi"><span id="ae4f" class="kp kq hi kl b fi kr ks l kt ku">scenePainterFunctions : List (TrackPoint -&gt; Scene)<br/>        scenePainterFunctions =<br/>            [ if options.centreLine then<br/>                Just (centreLineBetween gradientColourPastel)</span><span id="b32d" class="kp kq hi kl b fi kv ks l kt ku">              else<br/>                Nothing<br/>            , if options.roadTrack then<br/>                Just paintSurfaceBetween</span><span id="6ca7" class="kp kq hi kl b fi kv ks l kt ku">              else<br/>                Nothing<br/>            , if options.curtainStyle /= NoCurtain &amp;&amp; not options.terrainOn then<br/>                Just (curtainBetween floorPlane gradientFunction)</span><span id="20dc" class="kp kq hi kl b fi kv ks l kt ku">              else<br/>                Nothing<br/>            , if options.roadPillars &amp;&amp; not options.terrainOn then<br/>                Just (roadSupportPillar floorPlane)</span><span id="ddd6" class="kp kq hi kl b fi kv ks l kt ku">              else<br/>                Nothing<br/>            , if options.roadCones &amp;&amp; not options.terrainOn then<br/>                Just trackPointCone</span><span id="1ada" class="kp kq hi kl b fi kv ks l kt ku">              else<br/>                Nothing<br/>            ]<br/>                |&gt; List.filterMap identity</span><span id="1ced" class="kp kq hi kl b fi kv ks l kt ku">        paintScenePart : TrackPoint -&gt; Scene -&gt; Scene<br/>        paintScenePart pt accum =<br/>            -- This is intended to allow us to touch each TP once, create all the<br/>            -- active scene elements, and build a scene list with minimal overhead.<br/>            scenePainterFunctions<br/>                |&gt; List.map (\fn -&gt; fn pt)<br/>                |&gt; combineLists<br/>                |&gt; reversingCons accum</span><span id="1f85" class="kp kq hi kl b fi kv ks l kt ku">        scene : Scene<br/>        scene =<br/>            List.foldl paintScenePart [] track.trackPoints</span></pre><p id="29c1" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">三个街区来解释。</p><p id="5fee" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">首先，<code class="du kw kx ky kl b">scenePainterFunctions</code>是原始的<code class="du kw kx ky kl b">if ...</code>语句，根据选项集修改为返回<code class="du kw kx ky kl b">Just &lt;function&gt;</code>或<code class="du kw kx ky kl b">Nothing</code>，然后对其进行过滤，留下一个将描绘所选特征的函数列表。</p><p id="878d" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">其次，<code class="du kw kx ky kl b">paintScenePart</code>是我们用来对这些点进行单次遍历的函数。<em class="kj">对于每个点</em>，它应用每个选择的渲染函数，每个函数返回一个小的可视元素列表。对于每个点，这些被组合成一个单个列表，并被推到我们的累积列表的开始。</p><p id="9134" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">第三，<code class="du kw kx ky kl b">scene</code>仅仅对每个点应用<code class="du kw kx ky kl b">paintScenePart</code>操作。</p><p id="066b" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">助手函数<code class="du kw kx ky kl b">combineLists</code>和<code class="du kw kx ky kl b">reversingCons</code>只是有效地将列表放在一起，而元素的顺序并不重要。</p><pre class="iy iz ja jb fd kk kl km kn aw ko bi"><span id="4ef0" class="kp kq hi kl b fi kr ks l kt ku">reversingCons : List a -&gt; List a -&gt; List a<br/>reversingCons xs ys =<br/>    -- Use this for speed when order can be ignored.<br/>    case ( xs, ys ) of<br/>        ( [], _ ) -&gt;<br/>            ys</span><span id="7eee" class="kp kq hi kl b fi kv ks l kt ku">        ( _, [] ) -&gt;<br/>            xs</span><span id="4b9c" class="kp kq hi kl b fi kv ks l kt ku">        ( x :: moreX, _ ) -&gt;<br/>            reversingCons moreX (x :: ys)<br/></span><span id="9a07" class="kp kq hi kl b fi kv ks l kt ku">combineLists : List (List a) -&gt; List a<br/>combineLists lists =<br/>    List.foldl reversingCons [] lists</span></pre><p id="fb3d" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">大问题:有区别吗？老实说，我很难搞清楚这个问题。浏览器开发工具不会不合理地假设您是JavaScript开发人员。我没有。我是一名Elm开发人员，Elm编译成密集、晦涩的JavaScript。因此，查看内存分配的相当智能的工具很难解释。结果是“我想是的”，尽管其中有“我非常希望它是这样的”的成分。尽管如此，我喜欢代码的形状，我会睡得更香。</p></div></div>    
</body>
</html>