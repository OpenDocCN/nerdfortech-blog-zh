<html>
<head>
<title>Builder design pattern (Fluent Interface in C++ and C#)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">构建器设计模式(C++和C#中的流畅界面)</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/builder-design-pattern-fluent-interface-c-70cae9490a91?source=collection_archive---------3-----------------------#2021-02-28">https://medium.com/nerd-for-tech/builder-design-pattern-fluent-interface-c-70cae9490a91?source=collection_archive---------3-----------------------#2021-02-28</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/989f3106898fe2b33695c377411e6aaf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ioDLgO4DKCvZihc22Ydplw.jpeg"/></div></div></figure><p id="7845" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">构建器设计模式是一种简单但功能强大的创建模式，它通过封装复杂的对象构造逻辑，将对象构造与实现分离，并将构造责任委托给不同的类。该模式适用于从同一对象构建多个表示。</p><blockquote class="jo jp jq"><p id="2115" class="iq ir jr is b it iu iv iw ix iy iz ja js jc jd je jt jg jh ji ju jk jl jm jn hb bi translated">构建器模式使用简单的对象和一步一步的方法构建复杂的对象。这种类型的设计模式属于创建模式，因为这种模式提供了创建对象的最佳方式之一。[ <a class="ae jv" href="https://www.tutorialspoint.com/design_pattern/builder_pattern.htm" rel="noopener ugc nofollow" target="_blank">由导师点</a></p></blockquote></div><div class="ab cl jw jx gp jy" role="separator"><span class="jz bw bk ka kb kc"/><span class="jz bw bk ka kb kc"/><span class="jz bw bk ka kb"/></div><div class="hb hc hd he hf"><p id="6ec0" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">基于<a class="ae jv" href="https://en.wikipedia.org/wiki/Code_smell#:~:text=In%20computer%20programming%2C%20a%20code,%2C%20developer%2C%20and%20development%20methodology.&amp;text=It%20is%20also%20a%20term%20used%20by%20agile%20programmers." rel="noopener ugc nofollow" target="_blank">代码气味</a>应用构建器设计模式:</p><ul class=""><li id="d02f" class="kd ke hi is b it iu ix iy jb kf jf kg jj kh jn ki kj kk kl bi translated">您的类有一个带有几个可选参数的构造函数</li><li id="214d" class="kd ke hi is b it km ix kn jb ko jf kp jj kq jn ki kj kk kl bi translated">构造函数中复杂的逻辑和多重条件检查</li><li id="0bfe" class="kd ke hi is b it km ix kn jb ko jf kp jj kq jn ki kj kk kl bi translated">一些参数组合是不允许的(例如:洲和国家)</li></ul></div><div class="ab cl jw jx gp jy" role="separator"><span class="jz bw bk ka kb kc"/><span class="jz bw bk ka kb kc"/><span class="jz bw bk ka kb"/></div><div class="hb hc hd he hf"><p id="1e35" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">示例:</p><p id="5d2d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这个例子演示了如何利用构建器模式，使用多个构建器类和一个流畅的接口来构建电子邮件对象。在这里，电子邮件对象是用header和body builder类分多个阶段构建的。每个构建器都有一系列的方法，如<code class="du kr ks kt ku b"> <strong class="is hj"><em class="jr">from()</em></strong></code>、<code class="du kr ks kt ku b"> <strong class="is hj"><em class="jr">to()</em></strong></code>、<code class="du kr ks kt ku b"><strong class="is hj"><em class="jr">subject()</em></strong></code>。这个例子可能看起来有点夸张，因为使用的电子邮件并不复杂。</p><p id="1f1a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj"> <em class="jr"> email.h </em> </strong></p><p id="cff5" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><em class="jr">这是email类，有私有变量，如</em><code class="du kr ks kt ku b"><em class="jr">from</em></code><em class="jr"/><code class="du kr ks kt ku b"><em class="jr">to</em></code><em class="jr"/><code class="du kr ks kt ku b"><em class="jr">subject</em></code><em class="jr"/><code class="du kr ks kt ku b"><em class="jr">body </em></code><em class="jr">和</em> <code class="du kr ks kt ku b"><em class="jr">attachment</em></code> <em class="jr">。Email类有一组friend类，以便访问上面的私有变量。该构造函数是私有的，以防止直接从其他类创建电子邮件对象。</em></p><pre class="kv kw kx ky fd kz ku la lb aw lc bi"><span id="f23b" class="ld le hi ku b fi lf lg l lh li">#pragma once<br/>#include &lt;string&gt;<br/>#include &lt;sstream&gt;<br/>class EmailBuilder;</span><span id="dac7" class="ld le hi ku b fi lj lg l lh li">class Email<br/>{<br/>public:<br/>    friend class EmailBuilder;<br/>    friend class EmailHeaderBuilder;<br/>    friend class EmailBodyBuilder;<br/>    friend std::ostream &amp;operator&lt;&lt;(std::ostream &amp;os, const Email &amp;obj);<br/>    static EmailBuilder create();</span><span id="fd56" class="ld le hi ku b fi lj lg l lh li">private:<br/>    Email() = default;</span><span id="249a" class="ld le hi ku b fi lj lg l lh li">    std::string m_from;<br/>    std::string m_to;<br/>    std::string m_subject;<br/>    std::string m_body;<br/>    std::string m_attachment;<br/>};</span></pre><p id="ad01" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj"> <em class="jr"> email.cpp </em> </strong></p><p id="0716" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">运算符(&lt;</p><pre class="kv kw kx ky fd kz ku la lb aw lc bi"><span id="476f" class="ld le hi ku b fi lf lg l lh li">#include "email.h"<br/>#include "emailbuilder.h"<br/>EmailBuilder Email::create()<br/>{<br/>    return EmailBuilder{};<br/>}<br/>std::ostream &amp;operator&lt;&lt;(std::ostream &amp;os, const Email &amp;obj)<br/>{<br/>    return os<br/>           &lt;&lt; "from: " &lt;&lt; obj.m_from &lt;&lt; std::endl<br/>           &lt;&lt; "to: " &lt;&lt; obj.m_to &lt;&lt; std::endl<br/>           &lt;&lt; "subject: " &lt;&lt; obj.m_subject &lt;&lt; std::endl<br/>           &lt;&lt; "body: " &lt;&lt; obj.m_body &lt;&lt; std::endl<br/>           &lt;&lt; "attachment: " &lt;&lt; obj.m_attachment &lt;&lt; std::endl;<br/>}</span></pre><p id="f860" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj"><em class="jr">abstract email builder . h</em></strong></p><p id="0b6a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">基本构建器类有构建器创建方法，如<code class="du kr ks kt ku b">header()</code>和<code class="du kr ks kt ku b">body()</code>来获得所需的构建器实现。它有一个<code class="du kr ks kt ku b">EmailBodyBuilder </code>和<code class="du kr ks kt ku b">EmailHeaderBuilder</code>的转发类声明。电子邮件的Cast运算符也被重载，以将最终构造的电子邮件对象所有权返回给调用者。</p><pre class="kv kw kx ky fd kz ku la lb aw lc bi"><span id="5534" class="ld le hi ku b fi lf lg l lh li">#pragma once<br/>#include "email.h"<br/>class EmailHeaderBuilder;<br/>class EmailBodyBuilder;<br/>class AbstractEmailBuilder<br/>{<br/>protected:<br/>    Email &amp;m_email;<br/>    explicit AbstractEmailBuilder(Email &amp;email) : m_email(email) {}<br/>public:<br/>    operator Email() const<br/>    {<br/>        return std::move(m_email);<br/>    };<br/>    EmailHeaderBuilder header() const;<br/>    EmailBodyBuilder body() const;<br/>};</span></pre><p id="2bd5" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj"><em class="jr">abstract email builder . CPP</em></strong></p><pre class="kv kw kx ky fd kz ku la lb aw lc bi"><span id="ce28" class="ld le hi ku b fi lf lg l lh li">#include "abstractEmailBuilder.h"<br/>#include "emailbuilder.h"<br/>#include "emailBodyBuilder.h"<br/>#include "emailHeaderBuilder.h"<br/>EmailHeaderBuilder AbstractEmailBuilder::header() const<br/>{<br/>    return EmailHeaderBuilder{m_email};<br/>};<br/>EmailBodyBuilder AbstractEmailBuilder::body() const<br/>{<br/>    return EmailBodyBuilder{m_email};<br/>};</span></pre><p id="9859" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj"><em class="jr">email builder . h</em></strong></p><p id="ddcf" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">一个具体的类实现，初始化email对象并将其传递给抽象类。这将允许生成器类访问该对象。</p><pre class="kv kw kx ky fd kz ku la lb aw lc bi"><span id="9d22" class="ld le hi ku b fi lf lg l lh li">#pragma once<br/>#include "email.h"<br/>#include "abstractEmailBuilder.h"<br/>class EmailBuilder : public AbstractEmailBuilder<br/>{<br/>    Email m_email;<br/>public:<br/>    EmailBuilder() : AbstractEmailBuilder{m_email}<br/>    {<br/>    }<br/>};</span></pre><p id="5d94" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj"><em class="jr">email body builder . h</em></strong></p><p id="0e0b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">使用<code class="du kr ks kt ku b">EmailBodyBuilder </code>具体类演示邮件正文的创建。</p><pre class="kv kw kx ky fd kz ku la lb aw lc bi"><span id="ba3c" class="ld le hi ku b fi lf lg l lh li">#pragma once<br/>#include &lt;string&gt;<br/>#include "emailbuilder.h"<br/>class EmailBodyBuilder : public AbstractEmailBuilder<br/>{<br/>public:<br/>    explicit EmailBodyBuilder(Email &amp;email)<br/>        : AbstractEmailBuilder{email}<br/>    {<br/>    }<br/>    EmailBodyBuilder &amp;body(const std::string &amp;body)<br/>    {<br/>        m_email.m_body = body;<br/>        return *this;<br/>    }<br/>    EmailBodyBuilder &amp;attachment(const std::string &amp;attachment)<br/>    {<br/>        m_email.m_attachment = attachment;<br/>        return *this;<br/>    }<br/>};</span></pre><p id="a82c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj"><em class="jr">emailheaderbuilder . h</em></strong></p><p id="4b7a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">使用<code class="du kr ks kt ku b">EmailHeaderBuilder </code>具体类演示电子邮件标题的创建。</p><pre class="kv kw kx ky fd kz ku la lb aw lc bi"><span id="d379" class="ld le hi ku b fi lf lg l lh li">#pragma once<br/>#include &lt;string&gt;<br/>#include "emailbuilder.h"<br/>class EmailHeaderBuilder : public AbstractEmailBuilder<br/>{<br/>public:<br/>    explicit EmailHeaderBuilder(Email &amp;email)<br/>        : AbstractEmailBuilder{email}<br/>    {<br/>    }<br/>    EmailHeaderBuilder &amp;from(const std::string &amp;from)<br/>    {<br/>        m_email.m_from = from;<br/>        return *this;<br/>    }<br/>    EmailHeaderBuilder &amp;to(const std::string &amp;to)<br/>    {<br/>        m_email.m_to = to;<br/>        return *this;<br/>    }<br/>    EmailHeaderBuilder &amp;subject(const std::string &amp;subject)<br/>    {<br/>        m_email.m_subject = subject;<br/>        return *this;<br/>    }<br/>};</span></pre><p id="42f4" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj"> <em class="jr"> main.cpp </em> </strong></p><pre class="kv kw kx ky fd kz ku la lb aw lc bi"><span id="3ffc" class="ld le hi ku b fi lf lg l lh li">#include &lt;iostream&gt;<br/>#include &lt;sstream&gt;<br/>#include &lt;string&gt;<br/>#include "email.h"<br/>#include "emailbuilder.h"<br/>#include "emailHeaderBuilder.h"<br/>#include "emailBodyBuilder.h"<br/>using namespace std;<br/>int main()<br/>{<br/>    Email mail = Email::create()<br/>                     .header()<br/>                         .from("test1<a class="ae jv" href="mailto:sukithaj@gmail.com" rel="noopener ugc nofollow" target="_blank">@example.com</a>")<br/>                         .to("<a class="ae jv" href="mailto:test@gmail.com" rel="noopener ugc nofollow" target="_blank">test2@</a><a class="ae jv" href="mailto:sukithaj@gmail.com" rel="noopener ugc nofollow" target="_blank">example</a><a class="ae jv" href="mailto:test@gmail.com" rel="noopener ugc nofollow" target="_blank">.com</a>")<br/>                         .subject("This is a test mail")<br/>                     .body()<br/>                         .body("This is a test body")<br/>                         .attachment("This is a test attachment");<br/>    std::cout &lt;&lt; mail &lt;&lt; std::endl;<br/>}</span></pre></div><div class="ab cl jw jx gp jy" role="separator"><span class="jz bw bk ka kb kc"/><span class="jz bw bk ka kb kc"/><span class="jz bw bk ka kb"/></div><div class="hb hc hd he hf"><p id="b036" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">结论</strong></p><p id="2843" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">生成器设计模式的变化很少，这个例子是c++的流畅接口实现。常见的实现是使用基于目录的类结构。如果你想了解更多，网上有很多资源。</p><p id="e855" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">应用设计模式的理想时机是重构阶段。代码气味是发现什么需要改变以及哪些类和代码段需要改变的最好方法。以后我会写更多与代码气味相关的故事。</p></div><div class="ab cl jw jx gp jy" role="separator"><span class="jz bw bk ka kb kc"/><span class="jz bw bk ka kb kc"/><span class="jz bw bk ka kb"/></div><div class="hb hc hd he hf"><p id="f45e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">感谢<a class="lk ll ge" href="https://medium.com/u/36cefa51daac?source=post_page-----70cae9490a91--------------------------------" rel="noopener" target="_blank"> Desmond Harris Fernando </a>对<a class="ae jv" href="https://github.com/sukitha/BuilderPattern" rel="noopener ugc nofollow" target="_blank"> C#代码</a>的审核。</p></div></div>    
</body>
</html>