<html>
<head>
<title>Data Structures: Stacks and Queues</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">数据结构:堆栈和队列</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/data-structures-stacks-and-queues-a708303e3665?source=collection_archive---------7-----------------------#2021-02-21">https://medium.com/nerd-for-tech/data-structures-stacks-and-queues-a708303e3665?source=collection_archive---------7-----------------------#2021-02-21</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="0920" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">数据结构和最著名的相关算法指南</h2></div><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ix"><img src="../Images/344dcf48615cebc563ffec56657141e0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4ipXYyCMdD1YwYTxy68Puw.png"/></div></div></figure><p id="4e0c" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">在本文中，我将解释两种重要的数据结构，并且我将在以后的文章中写一些更流行的数据结构。我们第一次讨论需要使用我们已经讨论过的更简单的数据结构来实现的数据结构。如果你需要更多的信息，你可以参考以前的文章。</p><div class="kf kg ez fb kh ki"><a href="https://jhonny-chamoun.medium.com/data-structures-linked-list-994f798cd64e" rel="noopener follow" target="_blank"><div class="kj ab dw"><div class="kk ab kl cl cj km"><h2 class="bd hj fi z dy kn ea eb ko ed ef hh bi translated">数据结构:链表</h2><div class="kp l"><h3 class="bd b fi z dy kn ea eb ko ed ef dx translated">数据结构和最著名的相关算法指南</h3></div><div class="kq l"><p class="bd b fp z dy kn ea eb ko ed ef dx translated">jhonny-chamoun.medium.com</p></div></div><div class="kr l"><div class="ks l kt ku kv kr kw jh ki"/></div></div></a></div><div class="kf kg ez fb kh ki"><a href="https://jhonny-chamoun.medium.com/data-structures-arrays-13e8bf06b055" rel="noopener follow" target="_blank"><div class="kj ab dw"><div class="kk ab kl cl cj km"><h2 class="bd hj fi z dy kn ea eb ko ed ef hh bi translated">数据结构:数组</h2><div class="kp l"><h3 class="bd b fi z dy kn ea eb ko ed ef dx translated">数据结构和最著名的相关算法指南</h3></div><div class="kq l"><p class="bd b fp z dy kn ea eb ko ed ef dx translated">jhonny-chamoun.medium.com</p></div></div><div class="kr l"><div class="ks l kt ku kv kr kw jh ki"/></div></div></a></div><p id="d7f6" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">请记住，这些文章假设我们的读者熟悉数据结构的概念以及为什么在软件开发中使用它们，并且它将深入我们正在研究的每个数据结构的定义、不同类型、实现和复杂性。</p><h1 id="b211" class="kx ky hi bd kz la lb lc ld le lf lg lh io li ip lj ir lk is ll iu lm iv ln lo bi translated">定义</h1><p id="7665" class="pw-post-body-paragraph jj jk hi jl b jm lp ij jo jp lq im jr js lr ju jv jw ls jy jz ka lt kc kd ke hb bi translated">栈和队列都是模拟真实场景的线性数据结构。堆栈模拟后进先出情况，队列模拟先进先出情况。</p><p id="dacc" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">两种数据结构都用于组织对数据的访问，不同之处在于每种结构组织访问的方式…</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es lu"><img src="../Images/88a621154da053b8c3d2c9384a7c7388.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fToqoMv27Ru1NFHd8-dt4A.jpeg"/></div></div></figure><p id="b677" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated"><strong class="jl hj"> Push </strong>是向堆栈添加元素的方法，而<strong class="jl hj"> Pop </strong>是访问和删除堆栈顶部元素的方法。</p><p id="d398" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated"><strong class="jl hj"> Enqueue </strong>是向队列中添加元素的方法，<strong class="jl hj"> Dequeue </strong>是移除之前已入队的元素。</p><h1 id="7489" class="kx ky hi bd kz la lb lc ld le lf lg lh io li ip lj ir lk is ll iu lm iv ln lo bi translated">使用</h1><h2 id="0e29" class="lv ky hi bd kz lw lx ly ld lz ma mb lh js mc md lj jw me mf ll ka mg mh ln mi bi translated">堆</h2><p id="d737" class="pw-post-body-paragraph jj jk hi jl b jm lp ij jo jp lq im jr js lr ju jv jw ls jy jz ka lt kc kd ke hb bi translated">1-文本编辑器中的撤销功能。<br/> 2-编译器语法-检查括号和大括号耦合。<br/> 3-造型桩。<br/> 4-支持递归，并跟踪之前的函数调用。<br/> 5-用于在图形或树上进行深度优先搜索。</p><h2 id="11b8" class="lv ky hi bd kz lw lx ly ld lz ma mb lh js mc md lj jw me mf ll ka mg mh ln mi bi translated">长队</h2><p id="f458" class="pw-post-body-paragraph jj jk hi jl b jm lp ij jo jp lq im jr js lr ju jv jw ls jy jz ka lt kc kd ke hb bi translated">1-模拟等候线。<br/> 2-任何先来先服务的情况，例如在web服务器请求管理中。<br/>三口气先搜索图或树遍历。</p><h1 id="5096" class="kx ky hi bd kz la lb lc ld le lf lg lh io li ip lj ir lk is ll iu lm iv ln lo bi translated">复杂性</h1><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es mj"><img src="../Images/7d95a1ce961e9502614436466994d1cf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Ds1Eq5CBQna9GZ64LPAonA.png"/></div></div></figure><h2 id="d49a" class="lv ky hi bd kz lw lx ly ld lz ma mb lh js mc md lj jw me mf ll ka mg mh ln mi bi translated">堆</h2><p id="d0bd" class="pw-post-body-paragraph jj jk hi jl b jm lp ij jo jp lq im jr js lr ju jv jw ls jy jz ka lt kc kd ke hb bi translated">除了在我们寻找的项目不存在的情况下线性搜索之外，大多数操作都具有恒定的时间复杂度。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es mk"><img src="../Images/0f921ee87220cb5df5115c94d1706d10.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pvip8Pi_dT2OiMhh4x7T3g.png"/></div></div></figure><h1 id="5e3c" class="kx ky hi bd kz la lb lc ld le lf lg lh io li ip lj ir lk is ll iu lm iv ln lo bi translated">长队</h1><p id="dde0" class="pw-post-body-paragraph jj jk hi jl b jm lp ij jo jp lq im jr js lr ju jv jw ls jy jz ka lt kc kd ke hb bi translated">类似地，队列中只有包含和移除操作是线性的。所有其他操作都具有恒定的复杂性。</p><h1 id="d6b0" class="kx ky hi bd kz la lb lc ld le lf lg lh io li ip lj ir lk is ll iu lm iv ln lo bi translated">不同语言方法</h1><h2 id="5667" class="lv ky hi bd kz lw lx ly ld lz ma mb lh js mc md lj jw me mf ll ka mg mh ln mi bi translated">C#</h2><p id="97fe" class="pw-post-body-paragraph jj jk hi jl b jm lp ij jo jp lq im jr js lr ju jv jw ls jy jz ka lt kc kd ke hb bi translated">英寸NET中，队列和堆栈都是作为类来实现、打包和提供的，以便于调用和使用。</p><pre class="iy iz ja jb fd ml mm mn mo aw mp bi"><span id="46b6" class="lv ky hi mm b fi mq mr l ms mt">// Using a stack in c# is as easy as the below example.<br/>Stack st = new Stack();</span><span id="975a" class="lv ky hi mm b fi mu mr l ms mt">st.Push('A');<br/>st.Push('B');<br/>st.Push('C');</span><span id="7a45" class="lv ky hi mm b fi mu mr l ms mt">char ch = st.Pop(); //will return C;<br/>char ch2 = st.Pop(); // returns B;</span><span id="7f06" class="lv ky hi mm b fi mu mr l ms mt">// Using a queue can also be done as the below example.<br/>Queue q = new Queue();</span><span id="5a47" class="lv ky hi mm b fi mu mr l ms mt">q.Enqueue(“Two”);<br/>q.Enqueue(“One”);<br/><br/>// Remove elements and print them to the console.<br/>while (q.Count &gt; 0)<br/>    Console.WriteLine(q.Dequeue());</span></pre><h2 id="c5eb" class="lv ky hi bd kz lw lx ly ld lz ma mb lh js mc md lj jw me mf ll ka mg mh ln mi bi translated">Java语言（一种计算机语言，尤用于创建网站）</h2><p id="2144" class="pw-post-body-paragraph jj jk hi jl b jm lp ij jo jp lq im jr js lr ju jv jw ls jy jz ka lt kc kd ke hb bi translated">Java提供的堆栈和队列的实现略有不同。</p><p id="5940" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">除了用于堆栈操作的方法之外，堆栈作为继承vector数据类型及其所有方法的类提供。它的用法非常类似于C#。</p><p id="892e" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">另一方面，队列是作为一个接口提供的，它需要使用不同的数据类型作为队列。下面是一个例子。</p><pre class="iy iz ja jb fd ml mm mn mo aw mp bi"><span id="198e" class="lv ky hi mm b fi mq mr l ms mt">// examples of declaring a queue in JAVA.<br/>Queue queueA = new LinkedList();<br/>Queue queueB = new PriorityQueue();</span><span id="5d83" class="lv ky hi mm b fi mu mr l ms mt">queueA.add("element 1");<br/>queueA.add("element 2");</span><span id="c57b" class="lv ky hi mm b fi mu mr l ms mt">// both poll and remove do the same with one difference, if the    // queue is empty poll return a null while remove throws an        // exception.</span><span id="fad4" class="lv ky hi mm b fi mu mr l ms mt">String element1 = queueA.poll();<br/><br/>String element2 = queueA.remove();</span></pre><h2 id="add3" class="lv ky hi bd kz lw lx ly ld lz ma mb lh js mc md lj jw me mf ll ka mg mh ln mi bi translated">Java Script语言</h2><p id="b3e1" class="pw-post-body-paragraph jj jk hi jl b jm lp ij jo jp lq im jr js lr ju jv jw ls jy jz ka lt kc kd ke hb bi translated">JavaScript既不提供堆栈也不提供队列的预打包实现，这意味着像你我这样的开发人员或工程师需要实现它。</p><p id="2366" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">最简单的方法是用它们的原型方法构建构造函数，就像我们在JAVA和C#中看到的那样。唯一的区别是使用对象{}进行存储。</p><p id="2c30" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">下面的链接是一个很棒的博客，解释了JavaScript中堆栈和队列的实现。</p><div class="kf kg ez fb kh ki"><a href="https://code.tutsplus.com/articles/data-structures-with-javascript-stack-and-queue--cms-23348" rel="noopener  ugc nofollow" target="_blank"><div class="kj ab dw"><div class="kk ab kl cl cj km"><h2 class="bd hj fi z dy kn ea eb ko ed ef hh bi translated">JavaScript的数据结构:堆栈和队列</h2><div class="kp l"><h3 class="bd b fi z dy kn ea eb ko ed ef dx translated">web开发中最常用的两种数据结构是堆栈和队列。许多互联网用户…</h3></div><div class="kq l"><p class="bd b fp z dy kn ea eb ko ed ef dx translated">code.tutsplus.com</p></div></div><div class="kr l"><div class="mv l kt ku kv kr kw jh ki"/></div></div></a></div><h2 id="da6b" class="lv ky hi bd kz lw lx ly ld lz ma mb lh js mc md lj jw me mf ll ka mg mh ln mi bi translated">Ruby和Python</h2><p id="fe24" class="pw-post-body-paragraph jj jk hi jl b jm lp ij jo jp lq im jr js lr ju jv jw ls jy jz ka lt kc kd ke hb bi translated">Ruby和Python都没有专门针对队列和堆栈的数据结构，相反，它们提供了各自的方法和基本数据结构，因此我们可以模仿堆栈和队列的功能。</p><p id="1329" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">例如，Ruby提供了用于数组的push和pop方法，提供了LIFO行为(堆栈)和push/shift或unshift/pop，提供了FIFO行为(队列)。</p><p id="448d" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">Python提供了与List捆绑在一起的append、pop和pop(0 ),它还提供了带有append、pop和popleft方法的dequeue。</p><h1 id="95e2" class="kx ky hi bd kz la lb lc ld le lf lg lh io li ip lj ir lk is ll iu lm iv ln lo bi translated">用队列和堆栈解决的常见问题</h1><p id="9157" class="pw-post-body-paragraph jj jk hi jl b jm lp ij jo jp lq im jr js lr ju jv jw ls jy jz ka lt kc kd ke hb bi translated">BFS和DFS，主要是在树和图中，是最常见的设计模式，其中队列和堆栈起着重要的作用。</p><h2 id="c225" class="lv ky hi bd kz lw lx ly ld lz ma mb lh js mc md lj jw me mf ll ka mg mh ln mi bi translated">广度优先搜索(BFS)</h2><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es mw"><img src="../Images/2060bfda89eb808afc17f5d80087b610.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*PvXMyl7PHuW8GAszMlYKZQ.gif"/></div></div></figure><p id="9150" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">逐层访问树中的所有顶点或节点。为了做到这一点，每次我们访问一个节点时，我们都将它的子节点放入一个队列中，所以在我们处理完那个节点后，我们将可以按顺序访问下一级节点。</p><h2 id="78bd" class="lv ky hi bd kz lw lx ly ld lz ma mb lh js mc md lj jw me mf ll ka mg mh ln mi bi translated">深度优先搜索</h2><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es mx"><img src="../Images/df1c5b809b498fbe73522756415bb4a8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1248/1*aApu4NMQukGtjySD1lvbsw.gif"/></div></figure><p id="e335" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">从根节点开始访问树中的所有顶点或节点，并一直访问所有子节点，直到到达最深处。</p><p id="449d" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">DFS使用堆栈来存储它所访问的每个顶点的子节点，以便在处理完更深的节点后再访问它们。</p><h1 id="1772" class="kx ky hi bd kz la lb lc ld le lf lg lh io li ip lj ir lk is ll iu lm iv ln lo bi translated">结论</h1><p id="48d7" class="pw-post-body-paragraph jj jk hi jl b jm lp ij jo jp lq im jr js lr ju jv jw ls jy jz ka lt kc kd ke hb bi translated">当我们解释了队列和堆栈的定义以及它在不同语言中的实现和它最常见的编码模式时，请记住还有更多的数据结构来建模和修复不同的问题。我们将在以后的文章中讨论它们，以及它们的实现和帮助解决它们特定问题的最常见的编码模式。</p><p id="cc47" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">敬请关注…</p></div></div>    
</body>
</html>