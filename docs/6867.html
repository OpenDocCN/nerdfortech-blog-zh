<html>
<head>
<title>Delegate Call in Smart Contract</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">智能合同中的委托呼叫</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/delegate-call-in-smart-contract-431ba5caf576?source=collection_archive---------1-----------------------#2022-06-01">https://medium.com/nerd-for-tech/delegate-call-in-smart-contract-431ba5caf576?source=collection_archive---------1-----------------------#2022-06-01</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/d34725c75a0acc23a4d101c300a86079.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jaYsSFfDVIuyAnQImxqjkw.png"/></div></div></figure><p id="940d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">一些开发人员对“委托调用”这个术语持谨慎态度，因为它被描述为“危险的”恐惧和危险来自于对事物如何工作以及如何安全使用的知识的缺乏。例如，我们大多数人并不害怕开车，因为我们知道它是如何工作的，以及如何安全地驾驶。当一个契约使用委托调用来调用一个函数时，它从另一个契约加载并执行该函数代码，就好像它是自己的一样。</p><p id="253c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">当通过委托调用执行函数时，这些值不会改变:</p><ul class=""><li id="6bd5" class="jo jp hi is b it iu ix iy jb jq jf jr jj js jn jt ju jv jw bi translated">地址(这个)</li><li id="77ee" class="jo jp hi is b it jx ix jy jb jz jf ka jj kb jn jt ju jv jw bi translated">msg.sender</li><li id="3339" class="jo jp hi is b it jx ix jy jb jz jf ka jj kb jn jt ju jv jw bi translated">消息值</li></ul><p id="7e29" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">使用委托调用加载和执行函数的协定执行对状态变量的读取和写入。持有检索到的函数的契约永远不会被读取或写入。</p><p id="86a7" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如果ContractA利用委托调用来调用ContractB中的函数，则以下两种说法是正确的:</p><ul class=""><li id="25b1" class="jo jp hi is b it iu ix iy jb jq jf jr jj js jn jt ju jv jw bi translated">ContractA的状态变量可以读写。</li><li id="4fa2" class="jo jp hi is b it jx ix jy jb jz jf ka jj kb jn jt ju jv jw bi translated">ContractB的状态变量从不被读取或写入。</li></ul><p id="c4fd" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">ContractB的函数可以读写ContractA和ContractB声明的状态变量的值。只有ContractA的状态变量被读取或写入。</p><blockquote class="kc kd ke"><p id="844a" class="iq ir kf is b it iu iv iw ix iy iz ja kg jc jd je kh jg jh ji ki jk jl jm jn hb bi translated"><em class="hi"> delegatecall影响使用delegatecall调用函数的契约的状态变量。持有被借用的函数的契约的状态变量不被读取或写入。</em></p></blockquote><figure class="kj kk kl km fd ij"><div class="bz dy l di"><div class="kn ko l"/></div></figure><h1 id="c22a" class="kp kq hi bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm bi translated">例子</h1><p id="4802" class="pw-post-body-paragraph iq ir hi is b it ln iv iw ix lo iz ja jb lp jd je jf lq jh ji jj lr jl jm jn hb bi translated">让我们看一个基本的例子。<br/>合同方有以下内容:</p><ul class=""><li id="71bc" class="jo jp hi is b it iu ix iy jb jq jf jr jj js jn jt ju jv jw bi translated">address(this)= = 0x 2791 BCA 1 F2 de 4661 ed 88 a 30 c 99 a7a 9449 aa 84174</li><li id="95ed" class="jo jp hi is b it jx ix jy jb jz jf ka jj kb jn jt ju jv jw bi translated">名为“字符串令牌名”的状态变量的值是“FunToken”</li><li id="bcde" class="jo jp hi is b it jx ix jy jb jz jf ka jj kb jn jt ju jv jw bi translated">名为“initialise()”的外部方法，该方法使用delegatecall来调用ContractB的“settokenname(string calldata _ newName)”函数。</li></ul><p id="5d79" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">合同b包含以下条款:</p><ul class=""><li id="1ccc" class="jo jp hi is b it iu ix iy jb jq jf jr jj js jn jt ju jv jw bi translated">地址(this)= = 0x6b 175474 e 89094 c 44 da 98 b 954 eedeac 495271d 0f</li><li id="8327" class="jo jp hi is b it jx ix jy jb jz jf ka jj kb jn jt ju jv jw bi translated">状态变量字符串“tokenName”的值是“BoringToken”</li><li id="d9db" class="jo jp hi is b it jx ix jy jb jz jf ka jj kb jn jt ju jv jw bi translated">“setTokenName(string calldata _newName)”是一个外部函数，它将“TokenName”状态变量更新为“_ newName”值。</li></ul><p id="eaf0" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这是用2 ETH调用ContractA中的“初始化()”函数时发生的情况:</p><ol class=""><li id="a65a" class="jo jp hi is b it iu ix iy jb jq jf jr jj js jn ls ju jv jw bi translated">这些值是这样设置的:</li></ol><ul class=""><li id="03d7" class="jo jp hi is b it iu ix iy jb jq jf jr jj js jn jt ju jv jw bi translated">address(this)= = 0x 2791 BCA 1 F2 de 4661 ed 88 a 30 c 99 a7a 9449 aa 84174</li><li id="e073" class="jo jp hi is b it jx ix jy jb jz jf ka jj kb jn jt ju jv jw bi translated">msg . sender = = 0x ab 5801 a7 d 398351 b 8 be 11 c 439 e 05 C5 b 3259 AEC 9b</li><li id="ea29" class="jo jp hi is b it jx ix jy jb jz jf ka jj kb jn jt ju jv jw bi translated">消息值== 2 ETH</li></ul><p id="0d9b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">2.使用委托调用,“initialise()”方法调用ContractB中的“setTokenName”函数。运行“setTokenName”时，将返回以下值。他们一点都没变。</p><ul class=""><li id="5014" class="jo jp hi is b it iu ix iy jb jq jf jr jj js jn jt ju jv jw bi translated">address(this)= = 0x 2791 BCA 1 F2 de 4661 ed 88 a 30 c 99 a7a 9449 aa 84174</li><li id="658f" class="jo jp hi is b it jx ix jy jb jz jf ka jj kb jn jt ju jv jw bi translated">msg . sender = = 0x ab 5801 a7 d 398351 b 8 be 11 c 439 e 05 C5 b 3259 AEC 9b</li><li id="2fe6" class="jo jp hi is b it jx ix jy jb jz jf ka jj kb jn jt ju jv jw bi translated">消息值== 2 ETH</li></ul><p id="bcd5" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">3.在ContractA中，字符串“tokenName”状态变量的值被更改。即使代码源自ContractB，也不会在ContractB中更改。</p><figure class="kj kk kl km fd ij"><div class="bz dy l di"><div class="lt ko l"/></div></figure><p id="f1af" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">Solidity addresses有一个“委托调用”方法，允许您进行委托调用。此方法返回一个布尔状态变量，该变量指示函数调用是否被反转。委托调用函数返回第二个值，这是函数调用的返回值。请参见上面的示例代码。</p><figure class="kj kk kl km fd ij"><div class="bz dy l di"><div class="lt ko l"/></div></figure><h1 id="8d15" class="kp kq hi bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm bi translated">如何安全地使用委托调用</h1><p id="62a4" class="pw-post-body-paragraph iq ir hi is b it ln iv iw ix lo iz ja jb lp jd je jf lq jh ji jj lr jl jm jn hb bi translated">既然您已经理解了委托调用是如何工作的，那么让我们来看看如何安全地使用它。</p><h2 id="ac56" class="lu kq hi bd kr lv lw lx kv ly lz ma kz jb mb mc ld jf md me lh jj mf mg ll mh bi translated">1.控制委托调用执行的内容</h2><p id="1f47" class="pw-post-body-paragraph iq ir hi is b it ln iv iw ix lo iz ja jb lp jd je jf lq jh ji jj lr jl jm jn hb bi translated">不受信任的代码不应该与委托调用一起运行，因为它可能会更改状态变量或调用“自毁”来破坏调用协定。可以使用权限、身份验证或其他类型的控制来指定或更改委托调用函数和契约。</p><h2 id="1aae" class="lu kq hi bd kr lv lw lx kv ly lz ma kz jb mb mc ld jf md me lh jj mf mg ll mh bi translated">2.仅呼叫有代码的地址上的委托呼叫</h2><p id="8c6a" class="pw-post-body-paragraph iq ir hi is b it ln iv iw ix lo iz ja jb lp jd je jf lq jh ji jj lr jl jm jn hb bi translated">如果在不是约定的地址上调用Delegatecall，因此没有代码，它将为状态值返回“True”。如果代码期望委托调用函数在不能运行时返回“False ”,这可能会导致错误。</p><p id="ffdf" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如果您不确定当对某个地址变量进行委托调用时，该变量是否总是保留带有代码的地址，请在调用该变量之前检查该变量中的任何地址是否带有代码，如果没有，则进行恢复。以下是检查地址中代码的代码示例:</p><figure class="kj kk kl km fd ij"><div class="bz dy l di"><div class="lt ko l"/></div></figure></div><div class="ab cl mi mj gp mk" role="separator"><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn"/></div><div class="hb hc hd he hf"><h1 id="4fad" class="kp kq hi bd kr ks mp ku kv kw mq ky kz la mr lc ld le ms lg lh li mt lk ll lm bi translated">结论</h1><p id="85ac" class="pw-post-body-paragraph iq ir hi is b it ln iv iw ix lo iz ja jb lp jd je jf lq jh ji jj lr jl jm jn hb bi translated">因此，我们学习了智能契约中的委托调用，如何小心使用它，以及当我们使用用例时它如何为我们带来好处。</p><blockquote class="kc kd ke"><p id="e872" class="iq ir kf is b it iu iv iw ix iy iz ja kg jc jd je kh jg jh ji ki jk jl jm jn hb bi translated"><em class="hi">你可以在这里</em>   <em class="hi">买一杯咖啡支持我和我的内容☕ </em> <a class="ae mu" href="https://www.buymeacoffee.com/amanagarwal" rel="noopener ugc nofollow" target="_blank"> <strong class="is hj"> <em class="hi">。</em></strong></a></p><p id="4646" class="iq ir kf is b it iu iv iw ix iy iz ja kg jc jd je kh jg jh ji ki jk jl jm jn hb bi translated"><em class="hi">关注我上</em><a class="ae mu" href="https://twitter.com/02amanag" rel="noopener ugc nofollow" target="_blank"><strong class="is hj"><em class="hi">Twitter</em></strong></a><em class="hi">和</em><a class="ae mu" href="https://www.linkedin.com/in/02amanag/" rel="noopener ugc nofollow" target="_blank"><strong class="is hj"><em class="hi">LinkedIn</em></strong></a><em class="hi">。</em></p></blockquote><h1 id="4c18" class="kp kq hi bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm bi translated">了解更多信息</h1><div class="mv mw ez fb mx my"><a href="https://learn.block6.tech/oracle-blockchain-47b5ad917aa6" rel="noopener  ugc nofollow" target="_blank"><div class="mz ab dw"><div class="na ab nb cl cj nc"><h2 class="bd hj fi z dy nd ea eb ne ed ef hh bi translated">Oracle区块链</h2><div class="nf l"><h3 class="bd b fi z dy nd ea eb ne ed ef dx translated">Oracle区块链是什么？</h3></div><div class="ng l"><p class="bd b fp z dy nd ea eb ne ed ef dx translated">学习. block6.tech</p></div></div><div class="nh l"><div class="ni l nj nk nl nh nm io my"/></div></div></a></div><div class="mv mw ez fb mx my"><a href="https://enlear.academy/off-chain-transaction-of-blockchain-7b9fa3f9b94a" rel="noopener  ugc nofollow" target="_blank"><div class="mz ab dw"><div class="na ab nb cl cj nc"><h2 class="bd hj fi z dy nd ea eb ne ed ef hh bi translated">区块链的链外交易</h2><div class="nf l"><h3 class="bd b fi z dy nd ea eb ne ed ef dx translated">什么是外链交易？</h3></div><div class="ng l"><p class="bd b fp z dy nd ea eb ne ed ef dx translated">enlear .学院</p></div></div><div class="nh l"><div class="nn l nj nk nl nh nm io my"/></div></div></a></div><div class="mv mw ez fb mx my"><a rel="noopener follow" target="_blank" href="/geekculture/ethereum-v-s-hyperledger-f1b0c5e05b40"><div class="mz ab dw"><div class="na ab nb cl cj nc"><h2 class="bd hj fi z dy nd ea eb ne ed ef hh bi translated">以太坊虚拟分类帐</h2><div class="nf l"><h3 class="bd b fi z dy nd ea eb ne ed ef dx translated">Hyperledger和以太坊是世界上使用最广泛的两个区块链平台。两者都是免费使用的。他们…</h3></div><div class="ng l"><p class="bd b fp z dy nd ea eb ne ed ef dx translated">medium.com</p></div></div><div class="nh l"><div class="no l nj nk nl nh nm io my"/></div></div></a></div><blockquote class="np"><p id="74e7" class="nq nr hi bd ns nt nu nv nw nx ny jn dx translated"><a class="ae mu" href="https://learn.block6.tech" rel="noopener ugc nofollow" target="_blank"> Learn发布的内容。Block6.tech </a></p><p id="0fdd" class="nq nr hi bd ns nt nz oa ob oc od jn dx translated">👉<a class="ae mu" href="https://t.me/block6_tech" rel="noopener ugc nofollow" target="_blank">电报</a> —新鲜想法</p><p id="2032" class="nq nr hi bd ns nt nz oa ob oc od jn dx translated">👉<a class="ae mu" href="https://twitter.com/block6_tech" rel="noopener ugc nofollow" target="_blank">推特</a> —最新文章</p><p id="86d7" class="nq nr hi bd ns nt nz oa ob oc od jn dx translated">👉<a class="ae mu" href="https://linktr.ee/block6" rel="noopener ugc nofollow" target="_blank"> LinkTr.ee </a></p></blockquote></div></div>    
</body>
</html>