<html>
<head>
<title>6 Tips to Boost Node.Js Performance</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">提升节点的 6 个技巧。Js 性能</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/6-tips-to-boost-node-js-performance-32fd05ab9809?source=collection_archive---------1-----------------------#2021-11-06">https://medium.com/nerd-for-tech/6-tips-to-boost-node-js-performance-32fd05ab9809?source=collection_archive---------1-----------------------#2021-11-06</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/26f3a7264f60906d4f9ed487a0280ae8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*VqnDzMszhEBUOLla"/></div></div></figure><p id="259f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">近年来，JavaScript 已经从一种卫星语言变成了许多技术项目的核心。越来越多的开发者不仅在前端也在后端采用了这种技术，根据<a class="ae jo" href="https://insights.stackoverflow.com/survey/2019#technology-_-programming-scripting-and-markup-languages" rel="noopener ugc nofollow" target="_blank"> StackOverflow </a>或者根据<a class="ae jo" href="https://www.tiobe.com/tiobe-index/" rel="noopener ugc nofollow" target="_blank"> Tiobe </a>的说法#7，这使它成为世界上最受欢迎的语言(显然 JS 的人使用了很多 StackOverflow，呵呵)。</p><p id="846f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">JavaScript 是学习基础的简单语言(斯坦福是这么说的！)和 Node.js 一起让你构建各种应用。</p><p id="4209" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">然而，掌握 JavaScript 和 Node.js 并不是那么简单，在今天的文章中，我想为您带来 6 个性能技巧/提示/秘密，供您应用到您的 Node.js 项目中。</p><p id="0ace" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们要学习的技巧是:</p><ol class=""><li id="9f02" class="jp jq hi is b it iu ix iy jb jr jf js jj jt jn ju jv jw jx bi translated"><strong class="is hj">缓存</strong></li><li id="ea55" class="jp jq hi is b it jy ix jz jb ka jf kb jj kc jn ju jv jw jx bi translated"><strong class="is hj">指标</strong></li><li id="de8a" class="jp jq hi is b it jy ix jz jb ka jf kb jj kc jn ju jv jw jx bi translated"><strong class="is hj">异步架构</strong></li><li id="568c" class="jp jq hi is b it jy ix jz jb ka jf kb jj kc jn ju jv jw jx bi translated"><strong class="is hj">使用现代协议</strong></li><li id="cd7b" class="jp jq hi is b it jy ix jz jb ka jf kb jj kc jn ju jv jw jx bi translated"><strong class="is hj">使用集群</strong></li><li id="042f" class="jp jq hi is b it jy ix jz jb ka jf kb jj kc jn ju jv jw jx bi translated"><strong class="is hj">监控应用</strong></li></ol><h1 id="c2af" class="kd ke hi bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">#1 —缓存</h1><figure class="lb lc ld le fd ij"><div class="bz dy l di"><div class="lf lg l"/></div></figure><p id="3508" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在应用程序中使用缓存层有助于提高访问用户请求和/或应用程序需要的循环数据的速度，Node.js 中最常用的缓存机制形式之一是 Redis。</p><p id="f221" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><a class="ae jo" href="https://redis.io/" rel="noopener ugc nofollow" target="_blank"> Redis </a>是一种内存存储机制，可以用作数据库、缓存和消息代理。它支持字符串、哈希、列表、集合、有序集、位图、日志、地理空间索引和数据流等数据结构。还有一个场合，我想给大家带来一个 Redis 教程。</p><p id="c720" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在，在不使用 Redis 的情况下比较下面的代码。这是一个使用 Google Books API 的客户端，总是会获得书籍:</p><pre class="lb lc ld le fd lh li lj lk aw ll bi"><span id="da01" class="lm ke hi li b fi ln lo l lp lq"><em class="lr">'use strict';</em></span><span id="d461" class="lm ke hi li b fi ls lo l lp lq"><em class="lr">//dependencies</em></span><span id="8444" class="lm ke hi li b fi ls lo l lp lq"><strong class="li hj"><em class="lr">const</em></strong><em class="lr"> express = require('express');</em></span><span id="103c" class="lm ke hi li b fi ls lo l lp lq"><strong class="li hj"><em class="lr">const</em></strong><em class="lr"> responseTime = require('response-time')</em></span><span id="f595" class="lm ke hi li b fi ls lo l lp lq"><strong class="li hj"><em class="lr">const</em></strong><em class="lr"> axios = require('axios');</em></span><span id="2844" class="lm ke hi li b fi ls lo l lp lq"><strong class="li hj"><em class="lr">var</em></strong><em class="lr"> app = express();</em></span><span id="9be5" class="lm ke hi li b fi ls lo l lp lq"><em class="lr">//creates a middleware to capture the response time</em></span><span id="309c" class="lm ke hi li b fi ls lo l lp lq"><em class="lr">app.</em><strong class="li hj"><em class="lr">use</em></strong><em class="lr">(responseTime());</em></span><span id="ec10" class="lm ke hi li b fi ls lo l lp lq"><strong class="li hj"><em class="lr">const</em></strong><em class="lr"> getBook = (req, res) =&gt; {</em></span><span id="a43d" class="lm ke hi li b fi ls lo l lp lq"><em class="lr">let isbn = req.query.isbn;</em></span><span id="71d8" class="lm ke hi li b fi ls lo l lp lq"><em class="lr">let url = `https://www.googleapis.com/books/v1/volumes?q=isbn:${isbn}`;</em></span><span id="c79c" class="lm ke hi li b fi ls lo l lp lq"><em class="lr">axios.get(url)</em></span><span id="969e" class="lm ke hi li b fi ls lo l lp lq"><em class="lr">.</em><strong class="li hj"><em class="lr">then</em></strong><em class="lr">(response =&gt; {</em></span><span id="804b" class="lm ke hi li b fi ls lo l lp lq"><em class="lr">let book = response.data.items</em></span><span id="1beb" class="lm ke hi li b fi ls lo l lp lq"><em class="lr">res.send(book);</em></span><span id="469e" class="lm ke hi li b fi ls lo l lp lq"><em class="lr">})</em></span><span id="d697" class="lm ke hi li b fi ls lo l lp lq"><em class="lr">.</em><strong class="li hj"><em class="lr">catch</em></strong><em class="lr">(err =&gt; {</em></span><span id="4beb" class="lm ke hi li b fi ls lo l lp lq"><em class="lr">res.send('Book not found');</em></span><span id="106c" class="lm ke hi li b fi ls lo l lp lq"><em class="lr">});</em></span><span id="df89" class="lm ke hi li b fi ls lo l lp lq"><em class="lr">};</em></span><span id="76d9" class="lm ke hi li b fi ls lo l lp lq"><em class="lr">app.get('/book', getBook);</em></span><span id="1e2f" class="lm ke hi li b fi ls lo l lp lq"><em class="lr">app.listen(3000, </em><strong class="li hj"><em class="lr">function</em></strong><em class="lr">() {</em></span><span id="05bd" class="lm ke hi li b fi ls lo l lp lq"><em class="lr">console.log('Server on port 3000!')</em></span><span id="726a" class="lm ke hi li b fi ls lo l lp lq"><em class="lr">});</em></span></pre><p id="50d0" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这段代码的性能还不错，去 Google 一下得到这个信息用了不到 1s 的时间:</p><figure class="lb lc ld le fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lt"><img src="../Images/032341c9309b50e8db8defc1aa4f2e73.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*tqzWtkhNORJOWeaT.png"/></div></div></figure><p id="b171" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在，相同的代码，但是使用 Redis，创建一个中间缓存层:</p><pre class="lb lc ld le fd lh li lj lk aw ll bi"><span id="3b6c" class="lm ke hi li b fi ln lo l lp lq"><em class="lr">‘use strict’;</em></span><span id="b923" class="lm ke hi li b fi ls lo l lp lq"><strong class="li hj"><em class="lr">const</em></strong><em class="lr"> express = require(‘express’);</em></span><span id="4f23" class="lm ke hi li b fi ls lo l lp lq"><strong class="li hj"><em class="lr">const</em></strong><em class="lr"> responseTime = require(‘response-time’)</em></span><span id="2471" class="lm ke hi li b fi ls lo l lp lq"><strong class="li hj"><em class="lr">const</em></strong><em class="lr"> axios = require(‘axios’);</em></span><span id="6849" class="lm ke hi li b fi ls lo l lp lq"><strong class="li hj"><em class="lr">const</em></strong><em class="lr"> redis = require(‘redis’);</em></span><span id="eaf8" class="lm ke hi li b fi ls lo l lp lq"><strong class="li hj"><em class="lr">const</em></strong><em class="lr"> client = redis.createClient();</em></span><span id="0f83" class="lm ke hi li b fi ls lo l lp lq"><strong class="li hj"><em class="lr">var</em></strong><em class="lr"> app = express();</em></span><span id="f613" class="lm ke hi li b fi ls lo l lp lq"><em class="lr">app.</em><strong class="li hj"><em class="lr">use</em></strong><em class="lr">(responseTime());</em></span><span id="5a6f" class="lm ke hi li b fi ls lo l lp lq"><strong class="li hj"><em class="lr">const</em></strong><em class="lr"> getBook = (req, res) =&gt; {</em></span><span id="be38" class="lm ke hi li b fi ls lo l lp lq"><em class="lr">let isbn = req.query.isbn;</em></span><span id="3105" class="lm ke hi li b fi ls lo l lp lq"><em class="lr">let url = `https://www.googleapis.com/books/v1/volumes?q=isbn:${isbn}`;</em></span><span id="1327" class="lm ke hi li b fi ls lo l lp lq"><strong class="li hj"><em class="lr">return</em></strong><em class="lr"> axios.get(url)</em></span><span id="210b" class="lm ke hi li b fi ls lo l lp lq"><strong class="li hj"><em class="lr">.then</em></strong><em class="lr">(response =&gt; {</em></span><span id="7e35" class="lm ke hi li b fi ls lo l lp lq"><em class="lr">let book = response.data.items;</em></span><span id="7e96" class="lm ke hi li b fi ls lo l lp lq"><em class="lr">// Set the isbn string as our cache key. Content is the title.</em></span><span id="bb5f" class="lm ke hi li b fi ls lo l lp lq"><em class="lr">// Cache expiration for 1h (60min x 60s)</em></span><span id="cc53" class="lm ke hi li b fi ls lo l lp lq"><em class="lr">client.setex(isbn, 3600, JSON.stringify(book));</em></span><span id="c694" class="lm ke hi li b fi ls lo l lp lq"><em class="lr">res.send(book);</em></span><span id="9eca" class="lm ke hi li b fi ls lo l lp lq"><em class="lr">})</em></span><span id="2dc0" class="lm ke hi li b fi ls lo l lp lq"><strong class="li hj"><em class="lr">.catch</em></strong><em class="lr">(err =&gt; {</em></span><span id="9da8" class="lm ke hi li b fi ls lo l lp lq"><em class="lr">res.send(‘Book not found !!!’);</em></span><span id="a8be" class="lm ke hi li b fi ls lo l lp lq"><em class="lr">});</em></span><span id="4cc5" class="lm ke hi li b fi ls lo l lp lq"><em class="lr">};</em></span><span id="7d59" class="lm ke hi li b fi ls lo l lp lq"><strong class="li hj"><em class="lr">const</em></strong><em class="lr"> getCache = (req, res) =&gt; {</em></span><span id="c80c" class="lm ke hi li b fi ls lo l lp lq"><em class="lr">let isbn = req.query.isbn;</em></span><span id="92da" class="lm ke hi li b fi ls lo l lp lq"><em class="lr">//Check cache data first</em></span><span id="5cfd" class="lm ke hi li b fi ls lo l lp lq"><em class="lr">client.get(isbn, (err, result) =&gt; {</em></span><span id="62b2" class="lm ke hi li b fi ls lo l lp lq"><strong class="li hj"><em class="lr">if</em></strong><em class="lr"> (result) {</em></span><span id="0e49" class="lm ke hi li b fi ls lo l lp lq"><em class="lr">res.send(result);</em></span><span id="d39f" class="lm ke hi li b fi ls lo l lp lq"><em class="lr">} </em><strong class="li hj"><em class="lr">else</em></strong><em class="lr"> {</em></span><span id="0601" class="lm ke hi li b fi ls lo l lp lq"><em class="lr">getBook(req, res);</em></span><span id="64b2" class="lm ke hi li b fi ls lo l lp lq"><em class="lr">}</em></span><span id="8784" class="lm ke hi li b fi ls lo l lp lq"><em class="lr">});</em></span><span id="bc53" class="lm ke hi li b fi ls lo l lp lq"><em class="lr">}</em></span><span id="4b02" class="lm ke hi li b fi ls lo l lp lq"><em class="lr">app.get(‘/book’, getCache);</em></span><span id="7e7d" class="lm ke hi li b fi ls lo l lp lq"><em class="lr">app.listen(3000, </em><strong class="li hj"><em class="lr">function</em></strong><em class="lr">() {</em></span><span id="125f" class="lm ke hi li b fi ls lo l lp lq"><em class="lr">console.log(‘Server on 3000!’)</em></span><span id="3716" class="lm ke hi li b fi ls lo l lp lq"><em class="lr">});</em></span></pre><p id="1a9a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">它们之间的区别在于，在第二段代码中，我总是根据 ISBN 检查缓存中是否已经有了书名。如果我有它，我返回缓存中的内容，否则，我将 Google 它，除了返回之外，我还将它保存在缓存中，以便以后更快地查询。</p><p id="51cb" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">结果，当数据已经被缓存时，速度快得惊人，不到 1 毫秒。是的，不到一毫秒！！！</p><figure class="lb lc ld le fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lu"><img src="../Images/decc2804e5557d11b80bf22bb982d91d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*y7DMqYIamr6WR-hs.png"/></div></div></figure><h1 id="c419" class="kd ke hi bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">#2 —索引</h1><p id="7bbb" class="pw-post-body-paragraph iq ir hi is b it lv iv iw ix lw iz ja jb lx jd je jf ly jh ji jj lz jl jm jn hb bi translated">任何曾经使用过数据库的人都一定听说过索引。即使它是所有主索引/主键中最基本的。但是，在实际应用中，这往往是不够的。</p><p id="241e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们以 MongoDB 为例，这是一个经常与 Node.js 结合使用的 NoSQL 数据库。在与他谈论索引之前，我们先了解一下如何了解他的集合是否需要新的索引。为了分析 MongoDB 中查询的性能，我们使用解释函数，如下所示:</p><pre class="lb lc ld le fd lh li lj lk aw ll bi"><span id="6500" class="lm ke hi li b fi ln lo l lp lq"><em class="lr">db.users.find({email: 'user@email.com'}).explain("executionStats")</em></span></pre><p id="bee9" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">查询将被执行，作为回报，我们将获得其计划和执行的数据。</p><pre class="lb lc ld le fd lh li lj lk aw ll bi"><span id="b933" class="lm ke hi li b fi ln lo l lp lq"><em class="lr">db.users.find({email: 'user@email.com'}).explain("executionStats")</em></span><span id="f1f8" class="lm ke hi li b fi ls lo l lp lq"><em class="lr">{</em></span><span id="a588" class="lm ke hi li b fi ls lo l lp lq"><em class="lr">"queryPlanner" : ...</em></span><span id="4f58" class="lm ke hi li b fi ls lo l lp lq"><em class="lr">},</em></span><span id="e09d" class="lm ke hi li b fi ls lo l lp lq"><em class="lr">"winningPlan" : {</em></span><span id="f818" class="lm ke hi li b fi ls lo l lp lq"><em class="lr">"stage" : "COLLSCAN",</em></span><span id="544b" class="lm ke hi li b fi ls lo l lp lq"><em class="lr">"filter" : {</em></span><span id="2729" class="lm ke hi li b fi ls lo l lp lq"><em class="lr">"email" : {</em></span><span id="0f48" class="lm ke hi li b fi ls lo l lp lq"><em class="lr">"$eq" : "user@email.com"</em></span><span id="40ac" class="lm ke hi li b fi ls lo l lp lq"><em class="lr">}</em></span><span id="a851" class="lm ke hi li b fi ls lo l lp lq"><em class="lr">},</em></span><span id="1067" class="lm ke hi li b fi ls lo l lp lq"><em class="lr">"direction" : "forward"</em></span><span id="6860" class="lm ke hi li b fi ls lo l lp lq"><em class="lr">},</em></span><span id="11f5" class="lm ke hi li b fi ls lo l lp lq"><em class="lr">"rejectedPlans" : [ ]</em></span><span id="0849" class="lm ke hi li b fi ls lo l lp lq"><em class="lr">},</em></span><span id="17d2" class="lm ke hi li b fi ls lo l lp lq"><em class="lr">"executionStats" : {</em></span><span id="34f2" class="lm ke hi li b fi ls lo l lp lq"><em class="lr">"executionSuccess" : </em><strong class="li hj"><em class="lr">true</em></strong><em class="lr">,</em></span><span id="7c08" class="lm ke hi li b fi ls lo l lp lq"><em class="lr">"nReturned" : 1,</em></span><span id="880d" class="lm ke hi li b fi ls lo l lp lq"><em class="lr">"executionTimeMillis" : 0,</em></span><span id="15c8" class="lm ke hi li b fi ls lo l lp lq"><em class="lr">"totalKeysExamined" : 0,</em></span><span id="f3b2" class="lm ke hi li b fi ls lo l lp lq"><em class="lr">"totalDocsExamined" : 1039,</em></span><span id="89bb" class="lm ke hi li b fi ls lo l lp lq"><em class="lr">"executionStages" : {</em></span><span id="9b03" class="lm ke hi li b fi ls lo l lp lq"><em class="lr">...</em></span><span id="2048" class="lm ke hi li b fi ls lo l lp lq"><em class="lr">},</em></span><span id="24ed" class="lm ke hi li b fi ls lo l lp lq"><em class="lr">...</em></span><span id="d48c" class="lm ke hi li b fi ls lo l lp lq"><em class="lr">}</em></span><span id="8578" class="lm ke hi li b fi ls lo l lp lq"><em class="lr">},</em></span><span id="383d" class="lm ke hi li b fi ls lo l lp lq"><em class="lr">"serverInfo" : {</em></span><span id="07cc" class="lm ke hi li b fi ls lo l lp lq"><em class="lr">...</em></span><span id="2ed2" class="lm ke hi li b fi ls lo l lp lq"><em class="lr">},</em></span><span id="0a9b" class="lm ke hi li b fi ls lo l lp lq">"ok" : 1</span><span id="7ad5" class="lm ke hi li b fi ls lo l lp lq">}</span></pre><p id="150b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">从上面的摘录中，有两个要点需要分析:</p><ul class=""><li id="80ec" class="jp jq hi is b it iu ix iy jb jr jf js jj jt jn ma jv jw jx bi translated"><strong class="is hj"> nReturned </strong>:返回的文档数，本例中只有 1 个；</li><li id="aa78" class="jp jq hi is b it jy ix jz jb ka jf kb jj kc jn ma jv jw jx bi translated"><strong class="is hj"> totalDocsExamined </strong>:为找到我们想要的东西而扫描的文档总数，在本例中是 1039；</li></ul><p id="5699" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">你理解这出戏吗？MongoDB 必须一个接一个地查看 1039 个文档，才能找到我们想要的东西！</p><p id="ec9a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">下面是用户集合的电子邮件字段中的快速索引创建代码:</p><pre class="lb lc ld le fd lh li lj lk aw ll bi"><span id="496e" class="lm ke hi li b fi ln lo l lp lq"><em class="lr">db.getCollection("users").createIndex({ "email": 1 }, { "name": "email_1", "unique": </em><strong class="li hj"><em class="lr">true</em></strong><em class="lr"> })</em></span><span id="3342" class="lm ke hi li b fi ls lo l lp lq"><em class="lr">{</em></span><span id="3a94" class="lm ke hi li b fi ls lo l lp lq"><em class="lr">"createdCollectionAutomatically" : </em><strong class="li hj"><em class="lr">false</em></strong><em class="lr">,</em></span><span id="ef62" class="lm ke hi li b fi ls lo l lp lq"><em class="lr">"numIndexesBefore" : 1,</em></span><span id="dfff" class="lm ke hi li b fi ls lo l lp lq"><em class="lr">"numIndexesAfter" : 2,</em></span><span id="2d0a" class="lm ke hi li b fi ls lo l lp lq"><em class="lr">"ok" : 1</em></span><span id="dfb0" class="lm ke hi li b fi ls lo l lp lq"><em class="lr">}</em></span></pre><p id="5e45" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">相同查询的结果，1 个文档被查询，1 个被返回:</p><pre class="lb lc ld le fd lh li lj lk aw ll bi"><span id="9b87" class="lm ke hi li b fi ln lo l lp lq"><em class="lr">db.users.find({email: 'user@email.com'}).explain("executionStats")</em></span><span id="a9bd" class="lm ke hi li b fi ls lo l lp lq"><em class="lr">{</em></span><span id="69cf" class="lm ke hi li b fi ls lo l lp lq"><em class="lr">"queryPlanner" : ...,</em></span><span id="8932" class="lm ke hi li b fi ls lo l lp lq"><em class="lr">"winningPlan" : {</em></span><span id="9b1b" class="lm ke hi li b fi ls lo l lp lq"><em class="lr">"stage" : "FETCH",</em></span><span id="07b1" class="lm ke hi li b fi ls lo l lp lq"><em class="lr">"inputStage" : {</em></span><span id="54f5" class="lm ke hi li b fi ls lo l lp lq"><em class="lr">"stage" : "IXSCAN",</em></span><span id="f69c" class="lm ke hi li b fi ls lo l lp lq"><em class="lr">"keyPattern" : {</em></span><span id="0314" class="lm ke hi li b fi ls lo l lp lq"><em class="lr">"email" : 1</em></span><span id="5621" class="lm ke hi li b fi ls lo l lp lq"><em class="lr">},</em></span><span id="a45c" class="lm ke hi li b fi ls lo l lp lq"><em class="lr">"indexName" : "email_1",</em></span><span id="a1ce" class="lm ke hi li b fi ls lo l lp lq"><em class="lr">"isMultiKey" : </em><strong class="li hj"><em class="lr">false</em></strong><em class="lr">,</em></span><span id="776a" class="lm ke hi li b fi ls lo l lp lq"><em class="lr">"isUnique" : </em><strong class="li hj"><em class="lr">true</em></strong><em class="lr">,</em></span><span id="f964" class="lm ke hi li b fi ls lo l lp lq"><em class="lr">...</em></span><span id="a377" class="lm ke hi li b fi ls lo l lp lq"><em class="lr">}</em></span><span id="e461" class="lm ke hi li b fi ls lo l lp lq"><em class="lr">},</em></span><span id="8ba7" class="lm ke hi li b fi ls lo l lp lq"><em class="lr">"rejectedPlans" : [ ]</em></span><span id="5171" class="lm ke hi li b fi ls lo l lp lq"><em class="lr">},</em></span><span id="3a03" class="lm ke hi li b fi ls lo l lp lq"><em class="lr">"executionStats" : {</em></span><span id="b5a0" class="lm ke hi li b fi ls lo l lp lq"><em class="lr">"executionSuccess" : </em><strong class="li hj"><em class="lr">true</em></strong><em class="lr">,</em></span><span id="5669" class="lm ke hi li b fi ls lo l lp lq"><em class="lr">"nReturned" : 1,</em></span><span id="e946" class="lm ke hi li b fi ls lo l lp lq"><em class="lr">"executionTimeMillis" : 0,</em></span><span id="8e9e" class="lm ke hi li b fi ls lo l lp lq"><em class="lr">"totalKeysExamined" : 1,</em></span><span id="9623" class="lm ke hi li b fi ls lo l lp lq"><em class="lr">"totalDocsExamined" : 1,</em></span><span id="3d65" class="lm ke hi li b fi ls lo l lp lq"><em class="lr">...</em></span><span id="efc1" class="lm ke hi li b fi ls lo l lp lq"><em class="lr">}</em></span><span id="a820" class="lm ke hi li b fi ls lo l lp lq"><em class="lr">}</em></span><span id="cf8c" class="lm ke hi li b fi ls lo l lp lq"><em class="lr">},</em></span><span id="ecb9" class="lm ke hi li b fi ls lo l lp lq"><em class="lr">"serverInfo" : {</em></span><span id="a532" class="lm ke hi li b fi ls lo l lp lq"><em class="lr">...</em></span><span id="f26b" class="lm ke hi li b fi ls lo l lp lq"><em class="lr">}</em></span></pre><p id="239e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">关于执行时间，两者都是瞬时的(executionTimeMillis: 0)，但是因为基本上没有什么数据。在巨量(大数据)中，时差也会很明显。</p><h1 id="b83e" class="kd ke hi bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">#3 —异步架构</h1><p id="f00a" class="pw-post-body-paragraph iq ir hi is b it lv iv iw ix lw iz ja jb lx jd je jf ly jh ji jj lz jl jm jn hb bi translated">异步编程是为了理解每件事都有它的时间，但这并不意味着我们应该让我们的用户等待一个答案。Node.js 为 JavaScript 世界带来了默认的异步编程模型，包括回调、承诺和异步/等待。然而，仅仅使用这些特性，而不考虑你的体系结构，使其异步工作，会留下很多“性能在桌面上”。</p><p id="f0e9" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">首先，我们来谈谈异步处理。</p><p id="d4d0" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如果您的后端对请求有很高的需求，并且每个请求都需要一定量的处理才能返回，那么您不应该同步响应。每个尝试过同步处理大量并发请求的人都会遇到同样的问题:请求丢弃、超时溢出和用户不满意。你应该使用专业的排队解决方案，如 Kafka、RabbitMQ 或 AWS SQS(点击名称查看教程)。或者，将这个解决方案带到分布式系统的另一个层次，使用无服务器在后台处理请求的结果。</p><p id="97b2" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">使用这些解决方案，您接收请求，将其排队等待处理(这将由使用队列的工作人员来完成)，并对稍后将返回请求的用户做出响应。当工作人员完成他们的工作时，是时候给用户一个更好的响应了。</p><p id="f97f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">但是如何向用户返回异步响应呢？</p><p id="17b4" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这就是我想提出的第二点:异步数据。</p><p id="c514" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">当你想向用户发送消息/数据/任何东西，而不需要他不时主动向你发送请求(著名的轮询)时，最有效的方法是与他建立一个开放的通信通道，这通常是通过 WebHooks、WebSockets 或 Socket.io 等技术实现的。</p><p id="677e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">例如，一旦建立了带有 WebSockets 的客户机-服务器通道，服务器就可以将请求与数据流相关联，并且每当有新闻时，就在需要的确切时刻轻松地将其发送给一个或多个客户机，从而产生实时更新的愉快感觉。</p><p id="75c9" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">请注意，这种架构的实现和实施并不简单。此外，对于小项目来说，这没有意义，因为对于请求来说，要经历更多的负载和层次，这比仅仅接收请求和返回响应要花费更多的时间。然而，由于我上面提到的问题，对于大型应用程序来说，这些最初的损失得到了很多回报，此外还保持了很高的信心，即收到的所有内容迟早都会得到处理。</p><h1 id="a2a6" class="kd ke hi bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated"># 4 —使用现代协议</h1><figure class="lb lc ld le fd ij"><div class="bz dy l di"><div class="mb lg l"/></div></figure><p id="28c9" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">HTTP/2 通常称为 SPDY，是 IETF HTTP 工作组开发的最新 web 标准协议。HTTP/2 使网络浏览更快、更容易，并且使用更少的带宽。它关注性能，尤其是解决在最常用的 HTTP，1 版本中仍然存在的问题。x.</p><p id="dfa6" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">目前，像谷歌、脸书和 Youtube 这样的大公司已经在他们的页面上实现了这个协议，并鼓励越来越多的开发者使用它。它比通常的要复杂一些，例如，它需要一个加密连接(SSL)。</p><p id="74ac" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">下面是 Node.js 中的一个 HTTP/2 服务器的例子，来自<a class="ae jo" href="https://nodejs.org/api/http2.html" rel="noopener ugc nofollow" target="_blank">官网</a>:</p><pre class="lb lc ld le fd lh li lj lk aw ll bi"><span id="ef07" class="lm ke hi li b fi ln lo l lp lq"><strong class="li hj"><em class="lr">const</em></strong><em class="lr"> http2 = require('http2');</em></span><span id="db71" class="lm ke hi li b fi ls lo l lp lq"><strong class="li hj"><em class="lr">const</em></strong><em class="lr"> fs = require('fs');</em></span><span id="68c2" class="lm ke hi li b fi ls lo l lp lq"><strong class="li hj"><em class="lr">const</em></strong><em class="lr"> server = http2.createSecureServer({</em></span><span id="e5b5" class="lm ke hi li b fi ls lo l lp lq"><em class="lr">key: fs.readFileSync('localhost-privkey.pem'),</em></span><span id="eee7" class="lm ke hi li b fi ls lo l lp lq"><em class="lr">cert: fs.readFileSync('localhost-cert.pem')</em></span><span id="3cf1" class="lm ke hi li b fi ls lo l lp lq"><em class="lr">});</em></span><span id="bf03" class="lm ke hi li b fi ls lo l lp lq"><em class="lr">server.on('error', (err) =&gt; console.error(err));</em></span><span id="0414" class="lm ke hi li b fi ls lo l lp lq"><em class="lr">server.on('stream', (stream, headers) =&gt; {</em></span><span id="a9a1" class="lm ke hi li b fi ls lo l lp lq"><em class="lr">// stream is a Duplex</em></span><span id="9185" class="lm ke hi li b fi ls lo l lp lq"><em class="lr">stream.respond({</em></span><span id="d737" class="lm ke hi li b fi ls lo l lp lq"><em class="lr">'content-type': 'text/html',</em></span><span id="541c" class="lm ke hi li b fi ls lo l lp lq"><em class="lr">':status': 200</em></span><span id="a1e9" class="lm ke hi li b fi ls lo l lp lq"><em class="lr">});</em></span><span id="4f65" class="lm ke hi li b fi ls lo l lp lq"><em class="lr">stream.</em><strong class="li hj"><em class="lr">end</em></strong><em class="lr">('&lt;h1&gt;Hello World&lt;/h1&gt;');</em></span><span id="bc80" class="lm ke hi li b fi ls lo l lp lq"><em class="lr">});</em></span><span id="9eb4" class="lm ke hi li b fi ls lo l lp lq"><em class="lr">server.listen(8443);</em></span></pre><p id="970d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">要在代码中生成所需的证书(PEM 文件),可以通过命令行使用 OpenSSL:</p><pre class="lb lc ld le fd lh li lj lk aw ll bi"><span id="1106" class="lm ke hi li b fi ln lo l lp lq"><strong class="li hj"><em class="lr">openssl</em></strong><em class="lr"> req -x509 -newkey rsa:2048 -nodes -sha256 -subj '/CN=localhost'</em></span><span id="9187" class="lm ke hi li b fi ls lo l lp lq"><em class="lr">-keyout localhost-privkey.pem -out localhost-cert.pem</em></span></pre><p id="0c1b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">另一个技巧是查看 CPRM，这是一个基于 HTTP / 2 的实现，越来越受微服务的欢迎。</p><h1 id="a856" class="kd ke hi bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">#5 —使用集群</h1><p id="d105" class="pw-post-body-paragraph iq ir hi is b it lv iv iw ix lw iz ja jb lx jd je jf ly jh ji jj lz jl jm jn hb bi translated">默认情况下，Node.js 运行在一个线程上，因此运行在一个处理器内核上，如果它运行在一个有多个内核的机器上，效率会很低。</p><p id="c3e3" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">但这已经很久没有通过在 Node.js 中实现线程集群来解决了，它允许您创建共享服务器端口的子进程，允许 Node 在具有多种颜色的服务器上处理大量请求。</p><p id="d0d8" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">当我们使用 PM2 时，我们可以上传一组相同的进程，而无需对您的代码进行任何更改，只需在使用该实用程序启动您的进程时传递一个参数:</p><pre class="lb lc ld le fd lh li lj lk aw ll bi"><span id="40d6" class="lm ke hi li b fi ln lo l lp lq"><strong class="li hj"><em class="lr">pm2</em></strong><em class="lr"> </em><strong class="li hj"><em class="lr">start</em></strong><em class="lr">  app.js -i 0</em></span></pre><p id="0d14" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">因此，PM2 会自动将你的应用程序缩放到运行它的机器的所有颜色。</p><figure class="lb lc ld le fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mc"><img src="../Images/892af37cdcc8485acd48a7794f7a1ed4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*vZZg6DScx9Djh-EW.png"/></div></div></figure><p id="af43" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">值得注意的是，在集群中上传应用程序需要一些小心，因为，例如，它们不能共享内存中的数据，只能使用公共服务，如数据库、Redis、队列等。对于任何想要开发集群的人来说，一个技巧是遵循 12 因素应用程序方法。</p><h1 id="214e" class="kd ke hi bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">#6 —监控应用</h1><p id="5e41" class="pw-post-body-paragraph iq ir hi is b it lv iv iw ix lw iz ja jb lx jd je jf ly jh ji jj lz jl jm jn hb bi translated">对生产应用程序影响最大的事情之一就是程序错误。不仅仅是因为它们破坏了用户体验，还因为它们降低了应用程序本身的性能，因为错误会导致线程中断，产生副作用，并且通常是不可见的。</p><p id="fbbb" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">记住这一点，最后一个技巧是最重要的:监控你的应用程序！</p><p id="55a2" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">当我谈到监控时，它不仅仅是查看服务器上的内存和 CPU 使用情况，而是使用一些专业的监控解决方案，如 New Relic、Dynatrace、Stackify、Ruxit、LogicMonitor 和 Monitis。</p><p id="59dc" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">至少从系统的角度来看，只有使用实时监控工具，您才能确保您的应用程序运行良好，并且您的用户得到良好的服务。</p><p id="0f9b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如果你不能租用这样的工具，我们至少需要用日志暴露错误。我说的不是 console.log，而是使用更专业的日志包，比如 Winston，我在博客上做了一个教程(点击名称)。</p><p id="8c59" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">下面是使用 Winston 的一个基本示例:</p><pre class="lb lc ld le fd lh li lj lk aw ll bi"><span id="ca58" class="lm ke hi li b fi ln lo l lp lq"><strong class="li hj"><em class="lr">const</em></strong><em class="lr"> winston = require(‘winston’);</em></span><span id="a2f0" class="lm ke hi li b fi ls lo l lp lq"><em class="lr">let logger = </em><strong class="li hj"><em class="lr">new</em></strong><em class="lr"> winston.Logger({</em></span><span id="2d6c" class="lm ke hi li b fi ls lo l lp lq"><em class="lr">transports: [</em></span><span id="cb3a" class="lm ke hi li b fi ls lo l lp lq"><strong class="li hj"><em class="lr">new</em></strong><em class="lr"> winston.transports.File({</em></span><span id="aa41" class="lm ke hi li b fi ls lo l lp lq"><em class="lr">level: ‘verbose’,</em></span><span id="dc5b" class="lm ke hi li b fi ls lo l lp lq"><em class="lr">timestamp: </em><strong class="li hj"><em class="lr">new</em></strong><em class="lr"> </em><strong class="li hj"><em class="lr">Date</em></strong><em class="lr">(),</em></span><span id="fdf5" class="lm ke hi li b fi ls lo l lp lq"><em class="lr">filename: ‘filelog-verbose.log’,</em></span><span id="6f29" class="lm ke hi li b fi ls lo l lp lq"><em class="lr">json: </em><strong class="li hj"><em class="lr">false</em></strong><em class="lr">,</em></span><span id="22f7" class="lm ke hi li b fi ls lo l lp lq"><em class="lr">}),</em></span><span id="1437" class="lm ke hi li b fi ls lo l lp lq"><strong class="li hj"><em class="lr">new</em></strong><em class="lr"> winston.transports.File({</em></span><span id="56b5" class="lm ke hi li b fi ls lo l lp lq"><em class="lr">level: ‘error’,</em></span><span id="7916" class="lm ke hi li b fi ls lo l lp lq"><em class="lr">timestamp: </em><strong class="li hj"><em class="lr">new</em></strong><em class="lr"> </em><strong class="li hj"><em class="lr">Date</em></strong><em class="lr">(),</em></span><span id="b439" class="lm ke hi li b fi ls lo l lp lq"><em class="lr">filename: ‘filelog-error.log’,</em></span><span id="b21e" class="lm ke hi li b fi ls lo l lp lq"><em class="lr">json: </em><strong class="li hj"><em class="lr">false</em></strong><em class="lr">,</em></span><span id="6a3f" class="lm ke hi li b fi ls lo l lp lq"><em class="lr">})</em></span><span id="ece7" class="lm ke hi li b fi ls lo l lp lq"><em class="lr">]</em></span><span id="b34f" class="lm ke hi li b fi ls lo l lp lq"><em class="lr">});</em></span><span id="74a3" class="lm ke hi li b fi ls lo l lp lq"><em class="lr">logger.stream = {</em></span><span id="8bd4" class="lm ke hi li b fi ls lo l lp lq"><em class="lr">write: </em><strong class="li hj"><em class="lr">function</em></strong><em class="lr">(message, encoding) {</em></span><span id="2c9f" class="lm ke hi li b fi ls lo l lp lq"><em class="lr">logger.info(message);</em></span><span id="2b70" class="lm ke hi li b fi ls lo l lp lq"><em class="lr">}</em></span><span id="09ee" class="lm ke hi li b fi ls lo l lp lq"><em class="lr">};</em></span></pre><p id="44a3" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如果可能的话，我特别发现将日志存储在云中比将日志文件存储在服务器上更实际。为此，我推荐 AWS CloudWatch 日志，Winston 也支持它。</p><p id="6aa8" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">监控范围内的另一个好的技巧是定期对您的应用程序进行压力测试。</p></div></div>    
</body>
</html>