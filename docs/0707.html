<html>
<head>
<title>The ‘Promise’ Model, in Kotlin</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">科特林的“承诺”模型</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/the-promise-model-in-kotlin-1c121f22d35a?source=collection_archive---------2-----------------------#2021-02-07">https://medium.com/nerd-for-tech/the-promise-model-in-kotlin-1c121f22d35a?source=collection_archive---------2-----------------------#2021-02-07</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><h2 id="9008" class="hg hh hi bd b fp hj hk hl hm hn ho dx hp translated" aria-label="kicker paragraph">移动应用中的反应式编程——一次旅行</h2><div class=""/><div class=""><h2 id="69dc" class="pw-subtitle-paragraph io hr hi bd b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf dx translated">对于纯粹的Kotlin使用，特别是对于Android，您需要的唯一异步任务链模型构建在RxKotlin之上——第1部分</h2></div><h2 id="9616" class="jg jh hi bd ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc ho bi translated">介绍</h2><p id="2363" class="pw-post-body-paragraph kd ke hi kf b kg kh is ki kj kk iv kl jr km kn ko jv kp kq kr jz ks kt ku kv hb bi translated">这是我即将撰写的一长串文章的第一部分，这些文章将全面涵盖移动(特别是Android)开发，并将提供一个全面的架构来构建伟大的现代应用程序。上述架构是一个反应式的、基于组件的MVI，它已经在两个生产应用程序中完美地工作，现在是它见光的时候了。它让我的职业生活变得更好，应该分享。</p><figure class="kx ky kz la fd lb er es paragraph-image"><div role="button" tabindex="0" class="lc ld di le bf lf"><div class="er es kw"><img src="../Images/6108f13da1a365ad0dffc9b79e88fe0d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ljExpiaBADJwMMc6GAaZ3A.jpeg"/></div></div><figcaption class="li lj et er es lk ll bd b be z dx translated">哥伦比亚Cabo圣胡安德尔阿桂</figcaption></figure></div><div class="ab cl lm ln gp lo" role="separator"><span class="lp bw bk lq lr ls"/><span class="lp bw bk lq lr ls"/><span class="lp bw bk lq lr"/></div><div class="hb hc hd he hf"><p id="5817" class="pw-post-body-paragraph kd ke hi kf b kg lt is ki kj lu iv kl jr lv kn ko jv lw kq kr jz lx kt ku kv hb bi ly translated">现代编程最重要的工具之一，尤其是当我们谈到<em class="mh">移动开发</em>的时候，是一个<em class="mh">异步任务链接工具</em>。<br/>这也是这几天非常热门的话题，从各种<em class="mh"> rx </em>用法到<em class="mh"> Kotlin </em>自己的实现(例如<a class="ae mi" href="https://kotlinlang.org/docs/reference/coroutines/basics.html" rel="noopener ugc nofollow" target="_blank"> <em class="mh">协程</em> </a>)。甚至还有适用于Android  的<a class="ae mi" href="https://developer.android.com/topic/libraries/architecture/coroutines#lifecycle-aware" rel="noopener ugc nofollow" target="_blank"> <em class="mh">支持Livecycle的协程作用域。</em></a></p><p id="5da1" class="pw-post-body-paragraph kd ke hi kf b kg lt is ki kj lu iv kl jr lv kn ko jv lw kq kr jz lx kt ku kv hb bi translated">为了启动你的引擎，下面是<em class="mh"> JavaScript </em>的任务链接工具——<em class="mh">Promise</em>——的样子，使用起来很简单(对于一个实际的应用程序来说):</p><figure class="kx ky kz la fd lb"><div class="bz dy l di"><div class="mj mk l"/></div><figcaption class="li lj et er es lk ll bd b be z dx translated">JavaScript的承诺。那真是太好了。如果你还不熟悉它，<a class="ae mi" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise" rel="noopener ugc nofollow" target="_blank">请到这里阅读</a>，它将帮助你理解本文的其余部分。</figcaption></figure><p id="ac37" class="pw-post-body-paragraph kd ke hi kf b kg lt is ki kj lu iv kl jr lv kn ko jv lw kq kr jz lx kt ku kv hb bi translated">这里我们从数字“5”开始，但通常这是一个API请求。然后我们处理第一个结果(在我们的例子中是' 5 ')并返回另一个结果(B)。<br/> <em class="mh">然后</em>我们用并行任务处理‘B’，每个任务都有自己的结果(“C1”、“C2”)。<br/> <em class="mh">然后</em>我们处理两个‘C’结果。</p><p id="27da" class="pw-post-body-paragraph kd ke hi kf b kg lt is ki kj lu iv kl jr lv kn ko jv lw kq kr jz lx kt ku kv hb bi translated">现在再读一遍代码。现在再读一遍这个描述。我的意思是，这段代码有多清楚，对吗？描述就是这么写的。</p><p id="238b" class="pw-post-body-paragraph kd ke hi kf b kg lt is ki kj lu iv kl jr lv kn ko jv lw kq kr jz lx kt ku kv hb bi translated">为了提高热度，这里是(几乎)相同的链，在<em class="mh"> Kotlin协程中。<br/> </em>注意:<em class="mh">协程</em>提供了许多方法来完成类似的任务。不过，一般的方法是<a class="ae mi" href="https://zach-gollwitzer.medium.com/imperative-vs-declarative-programming-procedural-functional-and-oop-b03a53ba745c" rel="noopener"> <em class="mh">命令式(过程式)编程</em> </a>:</p><figure class="kx ky kz la fd lb"><div class="bz dy l di"><div class="mj mk l"/></div><figcaption class="li lj et er es lk ll bd b be z dx translated">协程方法</figcaption></figure><p id="f4f1" class="pw-post-body-paragraph kd ke hi kf b kg lt is ki kj lu iv kl jr lv kn ko jv lw kq kr jz lx kt ku kv hb bi translated">关于<em class="mh">协程</em>的实际工作方式还有很多(因此这段代码的运行方式与上面的<em class="mh">承诺</em>略有不同),它们可以做的不仅仅是任务链接。我想这甚至不公平。我想这就是我的观点。</p><p id="0b1e" class="pw-post-body-paragraph kd ke hi kf b kg lt is ki kj lu iv kl jr lv kn ko jv lw kq kr jz lx kt ku kv hb bi translated"><em class="mh">注意:我是Kotlin的超级粉丝，如果能在语言中内置一个可靠的任务链接工具，我会非常高兴。不过在我看来，协程现在还不够成熟，不像rx那样成熟。随着时间的推移，rx库会在协程的基础上重新发布。没有理由不在以后用它们来重建这个承诺。</em></p><p id="ecfa" class="pw-post-body-paragraph kd ke hi kf b kg lt is ki kj lu iv kl jr lv kn ko jv lw kq kr jz lx kt ku kv hb bi translated">那么，如果你问我，一个好的任务链接工具应该是什么样的呢？嗯，像<a class="ae mi" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise" rel="noopener ugc nofollow" target="_blank"> JavaScript的承诺</a>，坦白说。这简直太棒了。</p></div><div class="ab cl lm ln gp lo" role="separator"><span class="lp bw bk lq lr ls"/><span class="lp bw bk lq lr ls"/><span class="lp bw bk lq lr"/></div><div class="hb hc hd he hf"><h1 id="6eb9" class="ml jh hi bd ji mm mn mo jm mp mq mr jq ix ms iy ju ja mt jb jy jd mu je kc mv bi translated">我们将在本文中做什么</h1><p id="014f" class="pw-post-body-paragraph kd ke hi kf b kg kh is ki kj kk iv kl jr km kn ko jv kp kq kr jz ks kt ku kv hb bi translated">这篇文章讲述了一个名为<em class="mh"> Promise </em>的<em class="mh">异步任务链接工具</em>的全能实现，它建立在<em class="mh"> RxKotlin </em>的<code class="du mw mx my mz b">Single</code>模型(<a class="ae mi" href="https://github.com/GuyMichael/APromise" rel="noopener ugc nofollow" target="_blank">的基础上，现在可以在GitHub上获得，看看吧！</a>)。<br/>这篇文章是写给任何用<em class="mh"> Kotlin </em>编程的人的，无论是<em class="mh">手机</em>还是<em class="mh">服务器</em>开发，无论是<em class="mh"> Android </em>还是<em class="mh"> iOS。你将学到的是如何做适当的<em class="mh">任务链</em>，反应式的。</em></p><blockquote class="na"><p id="fc7b" class="nb nc hi bd nd ne nf ng nh ni nj kv dx translated">您将学习如何编写上面的JavaScript的Promise示例，但是更加强大，并且使用Kotlin编写</p></blockquote></div><div class="ab cl lm ln gp lo" role="separator"><span class="lp bw bk lq lr ls"/><span class="lp bw bk lq lr ls"/><span class="lp bw bk lq lr"/></div><div class="hb hc hd he hf"><p id="1db0" class="pw-post-body-paragraph kd ke hi kf b kg lt is ki kj lu iv kl jr lv kn ko jv lw kq kr jz lx kt ku kv hb bi translated">那为什么不直接用<em class="mh"> rx </em>呢？因为没那么容易。它有一个很长的学习曲线，它涵盖的范围远不止任务链接——就像<em class="mh">协程</em>(和<a class="ae mi" href="https://kotlinlang.org/docs/reference/coroutines/flow.html" rel="noopener ugc nofollow" target="_blank"> <em class="mh">流</em> </a> <em class="mh"> ) </em>所做的那样。</p><p id="eeda" class="pw-post-body-paragraph kd ke hi kf b kg lt is ki kj lu iv kl jr lv kn ko jv lw kq kr jz lx kt ku kv hb bi translated">当我们知道我们的工具应该是什么样子，但不想被绑定到任何特定的实现(<em class="mh">rx/Coroutine/rx-on-top-of-Coroutine)</em>时，我们该怎么办？我们创建所需的API，并抽象出底层实现:)</p><blockquote class="na"><p id="d991" class="nb nc hi bd nd ne nf ng nh ni nj kv dx translated">创建工具的第一步是定义它应该是什么样子，也就是它的API</p></blockquote><p id="1a1b" class="pw-post-body-paragraph kd ke hi kf b kg nk is ki kj nl iv kl jr nm kn ko jv nn kq kr jz no kt ku kv hb bi translated">好吧，我们开始吃吧，好吗？</p></div><div class="ab cl lm ln gp lo" role="separator"><span class="lp bw bk lq lr ls"/><span class="lp bw bk lq lr ls"/><span class="lp bw bk lq lr"/></div><div class="hb hc hd he hf"><h1 id="35f1" class="ml jh hi bd ji mm mn mo jm mp mq mr jq ix ms iy ju ja mt jb jy jd mu je kc mv bi translated">“承诺”模式</h1><p id="4b74" class="pw-post-body-paragraph kd ke hi kf b kg kh is ki kj kk iv kl jr km kn ko jv kp kq kr jz ks kt ku kv hb bi translated"><em class="mh">创建工具的第一步</em>是定义它应该是什么样子，意思是，它的API，以及它应该服务于哪个平台/环境。<br/>所以我们决定我们想要类似于<em class="mh"> JavaScript </em>的<em class="mh"> Promise </em>的东西，但是纯粹的<em class="mh"> Kotlin </em>，以虚拟方式服务于所有平台。嗯，因为我们喜欢科特林。</p><p id="ecbc" class="pw-post-body-paragraph kd ke hi kf b kg lt is ki kj lu iv kl jr lv kn ko jv lw kq kr jz lx kt ku kv hb bi translated">我们希望我们的工具是健壮的。我是说，防弹的。请注意，这不是一个简单的任务。所以我们会用<a class="ae mi" href="https://github.com/ReactiveX/RxKotlin" rel="noopener ugc nofollow" target="_blank"> <em class="mh"> RxKotlin </em> </a>。在网上快速搜索一下，就会看到来自<em class="mh"> rx </em>专家的一些好建议，包括但不限于:“就用<em class="mh">单个</em>！”。</p><h2 id="5026" class="jg jh hi bd ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc ho bi translated"><em class="np"> Rx </em>单为救援</h2><p id="609d" class="pw-post-body-paragraph kd ke hi kf b kg kh is ki kj kk iv kl jr km kn ko jv kp kq kr jz ks kt ku kv hb bi translated"><a class="ae mi" href="http://reactivex.io/documentation/single.html" rel="noopener ugc nofollow" target="_blank">反应信号</a>是一种特殊类型的<code class="du mw mx my mz b">Observable</code>，它只发出一个值，或一个错误通知。它非常适合我们的任务。我们只需要让它看起来整洁、简单和易于使用，然后我们就可以得到rx所能提供的一切，那是一吨重！我们需要用<em class="mh">承诺</em>来包装它。我们走吧。</p><h2 id="8b50" class="jg jh hi bd ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc ho bi translated">用一个人来建立一个承诺</h2><p id="37c4" class="pw-post-body-paragraph kd ke hi kf b kg kh is ki kj kk iv kl jr km kn ko jv kp kq kr jz ks kt ku kv hb bi translated">我不会面面俱到，你可以访问<a class="ae mi" href="https://github.com/GuyMichael/APromise" rel="noopener ugc nofollow" target="_blank">项目的GitHub页面</a>或者具体来说，<a class="ae mi" href="https://github.com/GuyMichael/APromise/blob/master/apromise/src/main/java/com/guymichael/promise/Promise.kt" rel="noopener ugc nofollow" target="_blank">实际承诺实现</a>。我将讲述基础知识，然后讲述我是如何实现错误处理的:</p><p id="8cbd" class="pw-post-body-paragraph kd ke hi kf b kg lt is ki kj lu iv kl jr lv kn ko jv lw kq kr jz lx kt ku kv hb bi translated">我们首先定义新的Promise类:</p><figure class="kx ky kz la fd lb"><div class="bz dy l di"><div class="mj mk l"/></div><figcaption class="li lj et er es lk ll bd b be z dx translated">新Promise类声明的简化版本</figcaption></figure><p id="e7f9" class="pw-post-body-paragraph kd ke hi kf b kg lt is ki kj lu iv kl jr lv kn ko jv lw kq kr jz lx kt ku kv hb bi translated">如上所述，构造函数接收到一个<em class="mh">rx</em>T1】实例，该实例被保存为成员。此外，我们还有另一位同学，<code class="du mw mx my mz b">promiseSubscriber</code>——我们很快就会谈到它。实际上在最终的实现中有更多的成员，但是它们现在不那么重要了。我们将在下一篇文章中讨论它们— <em class="mh"> Promise错误处理</em>。<br/>接下来要定义的是，链接<em class="mh">动作/子句/任务</em>看起来是什么样子。</p><h2 id="4df8" class="jg jh hi bd ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc ho bi translated">给定单个，为链接操作创建新的承诺实例</h2><p id="bf36" class="pw-post-body-paragraph kd ke hi kf b kg kh is ki kj kk iv kl jr km kn ko jv kp kq kr jz ks kt ku kv hb bi translated">我们将为大多数连锁动作创建一个新的<code class="du mw mx my mz b">Promise</code>(就像<code class="du mw mx my mz b">Single</code>动作一样):</p><figure class="kx ky kz la fd lb"><div class="bz dy l di"><div class="mj mk l"/></div><figcaption class="li lj et er es lk ll bd b be z dx translated">新的承诺创建者功能，供内部使用，已简化</figcaption></figure><p id="1e50" class="pw-post-body-paragraph kd ke hi kf b kg lt is ki kj lu iv kl jr lv kn ko jv lw kq kr jz lx kt ku kv hb bi translated"><em class="mh">注意:我使用了一个专用的私有方法来创建新的实例，而不是仅仅调用默认的公共构造函数，因为这样更容易控制所有的内部类调用。很快，将会有更多的特性支持和添加到这个方法中，所以最好将它与公共构造函数区分开来。在实际代码中，这个方法甚至调用另一个方法</em> <code class="du mw mx my mz b"><em class="mh">createInstanceImpl</em></code> <em class="mh">来创建新的</em><code class="du mw mx my mz b"><em class="mh">Promise</em></code><em class="mh">——这样做是为了允许扩展这个Promise模型，例如</em><code class="du mw mx my mz b"><em class="mh">APromise </em></code><em class="mh">——一个Android Promise (wink wink)。</em></p><p id="e20c" class="pw-post-body-paragraph kd ke hi kf b kg lt is ki kj lu iv kl jr lv kn ko jv lw kq kr jz lx kt ku kv hb bi translated">好了，我们有了一个新的<em class="mh">承诺</em>模型，它包装了<em class="mh"> rx </em>的<code class="du mw mx my mz b">Single</code>，我们有了一个实用方法来创建新的承诺，用于链接操作。在我们着手将<code class="du mw mx my mz b">Single</code>的行动包装成我们自己的行动(例如，令人惊叹的‘然后’行动)这一几乎是例行公事的任务之前，唯一缺少的是<em class="mh">执行</em>我们的<em class="mh">承诺</em>的方法。</p><h2 id="85c7" class="jg jh hi bd ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc ho bi translated">履行承诺，通过订阅单</h2><p id="41a3" class="pw-post-body-paragraph kd ke hi kf b kg kh is ki kj kk iv kl jr km kn ko jv kp kq kr jz ks kt ku kv hb bi translated">记住，我们的承诺动作链是异步的。这也(最好)意味着它不会计算(late-init ),直到我们希望它这样做。就像<em class="mh"> Java Streams、Kotlin协程、</em>和<em class="mh"> rx Observables </em>一样。这实际上意味着我们可以将<em class="mh">承诺</em>作为方法参数(<a class="ae mi" href="https://en.wikipedia.org/wiki/First-class_citizen" rel="noopener ugc nofollow" target="_blank"> <em class="mh">一等公民</em> </a>)进行修改，在其他<em class="mh">承诺</em>链中使用，并在以后执行。<br/>对于<em class="mh"> JavaScript Promise </em>爱好者来说，这可能会感觉不可思议，需要手动<em class="mh">执行</em> a <code class="du mw mx my mz b">Promise</code>，而不是它神奇地启动(<a class="ae mi" href="https://stackoverflow.com/questions/42118900/when-is-the-body-of-a-promise-executed" rel="noopener ugc nofollow" target="_blank">提示:它立即启动，一点也不神奇</a>)，但从各方面来看，这是一个惊人的特性。<br/>那么让我们来看看我们的<code class="du mw mx my mz b">execute </code>方法(从原始代码简化而来):</p><figure class="kx ky kz la fd lb"><div class="bz dy l di"><div class="mj mk l"/></div><figcaption class="li lj et er es lk ll bd b be z dx translated">Promise的execute方法的简化版本</figcaption></figure><p id="ea48" class="pw-post-body-paragraph kd ke hi kf b kg lt is ki kj lu iv kl jr lv kn ko jv lw kq kr jz lx kt ku kv hb bi translated">所以基本上，<code class="du mw mx my mz b">execute</code>方法订阅了底层的<code class="du mw mx my mz b">Single</code>，它是执行链的<em class="mh"> rx </em>方式，并返回一个<code class="du mw mx my mz b">Disposable</code>。<br/>我们保存/缓存这个<em class="mh">一次性</em>作为我们来自类声明的<code class="du mw mx my mz b">promiseSubscriber</code>(还记得吗？往上一点)。这很重要。它确保底层<code class="du mw mx my mz b">Single</code> <em class="mh"> rx </em>链不会<em class="mh">处置</em>并取消(例如由于<em class="mh">垃圾收集</em>)。<br/>作为奖励，我们返回这个非常<code class="du mw mx my mz b">Disposable</code>，它可以用来取消(<em class="mh"> dispose </em>)我们的<em class="mh"> Promise </em>链(实际上我们用另一个<code class="du mw mx my mz b">Disposable </code>实例将它包装在真实代码中，但想法是一样的)。<br/>多么神奇，一个<em class="mh">可取消的承诺</em>。</p><p id="70e5" class="pw-post-body-paragraph kd ke hi kf b kg lt is ki kj lu iv kl jr lv kn ko jv lw kq kr jz lx kt ku kv hb bi translated"><em class="mh">注意:如您所见，</em> <code class="du mw mx my mz b"><em class="mh">promiseSubscriber</em></code> <em class="mh">仅由链中的最后一个承诺持有，因为它仅由我们称为</em> <code class="du mw mx my mz b"><em class="mh">execute()</em></code> <em class="mh"> on的实例保存(就像在rx中一样，您订阅整个链，而不是其中的每个操作/行)。这是有意义的，因为当一个</em> <code class="du mw mx my mz b"><em class="mh">promise</em></code> <em class="mh">的</em> <strong class="kf hs"> <em class="mh">整个</em> </strong> <em class="mh">链已经成功完成时，它就被认为是解决了。正是如此。</em></p><p id="d4a1" class="pw-post-body-paragraph kd ke hi kf b kg lt is ki kj lu iv kl jr lv kn ko jv lw kq kr jz lx kt ku kv hb bi translated">如今，现在..到了<strong class="kf hs">好玩的</strong>部分！</p></div><div class="ab cl lm ln gp lo" role="separator"><span class="lp bw bk lq lr ls"/><span class="lp bw bk lq lr ls"/><span class="lp bw bk lq lr"/></div><div class="hb hc hd he hf"><h1 id="90c3" class="ml jh hi bd ji mm mn mo jm mp mq mr jq ix ms iy ju ja mt jb jy jd mu je kc mv bi translated">链接操作</h1><p id="356e" class="pw-post-body-paragraph kd ke hi kf b kg kh is ki kj kk iv kl jr km kn ko jv kp kq kr jz ks kt ku kv hb bi translated">让我们从最简单的动作开始，一个‘然后’。不用说，它应该返回一个(新的)<code class="du mw mx my mz b">Promise</code>，因为这就是<em class="mh">反应式</em>链接的全部内容:)</p><h2 id="5c24" class="jg jh hi bd ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc ho bi translated">消费者的“然后”</h2><figure class="kx ky kz la fd lb"><div class="bz dy l di"><div class="mj mk l"/></div><figcaption class="li lj et er es lk ll bd b be z dx translated">最基本的“然后”操作，原样(未简化)</figcaption></figure><p id="d25d" class="pw-post-body-paragraph kd ke hi kf b kg lt is ki kj lu iv kl jr lv kn ko jv lw kq kr jz lx kt ku kv hb bi translated">就是这样！多有趣啊。我们现在可以连锁(简单- <em class="mh">消费者</em> ) <em class="mh">行动/任务/条款</em>！但是等等，我们还没完，还有很多事情要做。更多相同的，但更多。让我们从那个让你再次平静的电话开始。</p><p id="cae6" class="pw-post-body-paragraph kd ke hi kf b kg lt is ki kj lu iv kl jr lv kn ko jv lw kq kr jz lx kt ku kv hb bi translated"><code class="du mw mx my mz b">singleOfConsumer</code>只是一个实用方法，用于根据给定的<em class="mh">消费者</em>参数创建新的<code class="du mw mx my mz b">Single</code>实例(消费者<em class="mh">消费者</em>只是一个接收参数并返回<em class="mh"> void </em>的函数)。</p><p id="c60d" class="pw-post-body-paragraph kd ke hi kf b kg lt is ki kj lu iv kl jr lv kn ko jv lw kq kr jz lx kt ku kv hb bi translated"><em class="mh">注意:因为我们想要创建许多类型的‘then’方法(例如，使用异步参数)，我们将有一些实用方法，它们很简单，但也是核心逻辑，这就是我们的rx知识派上用场的地方。</em></p><p id="e7c1" class="pw-post-body-paragraph kd ke hi kf b kg lt is ki kj lu iv kl jr lv kn ko jv lw kq kr jz lx kt ku kv hb bi translated">那么让我们来看看非常简单的<code class="du mw mx my mz b">singleOfConsumer</code>方法:</p><figure class="kx ky kz la fd lb"><div class="bz dy l di"><div class="mj mk l"/></div><figcaption class="li lj et er es lk ll bd b be z dx translated">从一个消费者创建一个新单的实用程序方法。原样</figcaption></figure><p id="be53" class="pw-post-body-paragraph kd ke hi kf b kg lt is ki kj lu iv kl jr lv kn ko jv lw kq kr jz lx kt ku kv hb bi translated">没什么特别的——只是调用了<code class="du mw mx my mz b">Single.map()</code>(通常用于将一些<code class="du mw mx my mz b">Single&lt;T&gt;</code>映射到另一些类型<code class="du mw mx my mz b">Single&lt;R&gt;</code>)，但是我们返回给<em class="mh">消费者</em>(<code class="du mw mx my mz b">T</code>类型的<code class="du mw mx my mz b">it</code>)的相同参数。<br/>这实际上是一个‘then’回调，它只消耗<em class="mh"> Promise </em>链中的当前参数，而不对链的其余部分做任何更改。这与在<em class="mh"> JavaScript </em>中的用法完全相同，在这里您将使用‘then’参数，并且<em class="mh">在‘then’块的末尾返回</em>它，将它向前传递给链的其余部分。</p><p id="7a79" class="pw-post-body-paragraph kd ke hi kf b kg lt is ki kj lu iv kl jr lv kn ko jv lw kq kr jz lx kt ku kv hb bi translated"><em class="mh">注意:Single的</em> <code class="du mw mx my mz b"><em class="mh">map</em></code> <em class="mh">方法创建(并返回)一个新的</em> <code class="du mw mx my mz b"><em class="mh">Single</em></code> <em class="mh">，就像我们的‘then’方法创建一个新的</em> <code class="du mw mx my mz b">Promise</code> <em class="mh">。所以实际上，每当我们使用‘then’时，我们既创建了一个新的</em> <code class="du mw mx my mz b"><em class="mh">Single </em></code> <em class="mh">，又创建了一个新的</em> <code class="du mw mx my mz b"><em class="mh">Promise</em></code> <em class="mh">。你可能不喜欢，但这就是反应式编程的全部——映射值，不可变的值。这意味着一遍又一遍地重新创建实例。</em></p><p id="4dfa" class="pw-post-body-paragraph kd ke hi kf b kg lt is ki kj lu iv kl jr lv kn ko jv lw kq kr jz lx kt ku kv hb bi translated">以完全相同的方式，我们可以定义一个“thenMap”动作，其中<em class="mh">将</em>映射到我们的类型，例如从<code class="du mw mx my mz b">Promise&lt;T&gt;</code>到<code class="du mw mx my mz b">Promise&lt;R&gt;</code>。这现在非常容易:</p><figure class="kx ky kz la fd lb"><div class="bz dy l di"><div class="mj mk l"/></div><figcaption class="li lj et er es lk ll bd b be z dx translated">一个简单的“then”动作，它将承诺链从类型“T”映射到类型“R”</figcaption></figure><p id="e33b" class="pw-post-body-paragraph kd ke hi kf b kg lt is ki kj lu iv kl jr lv kn ko jv lw kq kr jz lx kt ku kv hb bi translated">其中<code class="du mw mx my mz b">singleOfMap()</code>与<code class="du mw mx my mz b">singleOfConsumer()</code>完全相同，但没有最后一行，返回<em class="mh">函数</em>响应，而不是输入参数<code class="du mw mx my mz b">it</code>。<br/>不过这一次，参数是一个<em class="mh">映射器</em>而不是一个<em class="mh">消费者(</em>一个<em class="mh">映射器</em>，或者仅仅是一个<em class="mh">函数</em>，实际上，是一个接收参数并返回参数的函数。在反应式编程中，<em class="mh">函数</em>被大量用作<em class="mh">映射器，</em>在某种意义上，它在<em class="mh">反应式</em>链内将一个值映射到另一个值，或将一种类型映射到另一种类型。</p><figure class="kx ky kz la fd lb"><div class="bz dy l di"><div class="mj mk l"/></div><figcaption class="li lj et er es lk ll bd b be z dx translated">一个实用的方法，创建一个新的单一的映射函数</figcaption></figure><p id="52f1" class="pw-post-body-paragraph kd ke hi kf b kg lt is ki kj lu iv kl jr lv kn ko jv lw kq kr jz lx kt ku kv hb bi translated"><em class="mh">注意:在这一点上，有必要指出这样一个事实，我并没有仅仅使用“then”来命名所有的</em>  <em class="mh">动作。相反，我通过名字和签名使它们显式化(</em> <a class="ae mi" href="https://stackoverflow.com/questions/1517582/what-is-the-difference-between-statically-typed-and-dynamically-typed-languages" rel="noopener ugc nofollow" target="_blank"> <em class="mh">因为Kotlin是一种静态类型语言</em> </a> <em class="mh">)。<br/>对于那些习惯了JavaScript承诺的人，我只能说:“欢迎来到显式代码的神奇世界，我相信你会爱上它的！”。</em></p><p id="5a25" class="pw-post-body-paragraph kd ke hi kf b kg lt is ki kj lu iv kl jr lv kn ko jv lw kq kr jz lx kt ku kv hb bi translated">你已经冷静下来了吗？太好了，让我们把它变得更有趣。</p><h2 id="d54b" class="jg jh hi bd ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc ho bi translated">然后等待连锁承诺</h2><p id="5374" class="pw-post-body-paragraph kd ke hi kf b kg kh is ki kj kk iv kl jr km kn ko jv kp kq kr jz ks kt ku kv hb bi translated">在<em class="mh"> JavaScript Promise </em>中，这是‘then’的(令人敬畏的)用法，在这里你返回一个新的<code class="du mw mx my mz b">promise</code>。它的行为是等待这个新的<code class="du mw mx my mz b">promise </code>，并将其结果传递给链中将要使用的下一个‘then’。这就是去掉错误处理代码后的结果——我们将在下一篇文章中讨论:</p><figure class="kx ky kz la fd lb"><div class="bz dy l di"><div class="mj mk l"/></div><figcaption class="li lj et er es lk ll bd b be z dx translated">最常用的“然后”动作，在完成/恢复链之前等待另一个承诺。简化了的</figcaption></figure><p id="c966" class="pw-post-body-paragraph kd ke hi kf b kg lt is ki kj lu iv kl jr lv kn ko jv lw kq kr jz lx kt ku kv hb bi translated">现在你肯定明白了，这个方法的核心逻辑在于<em class="mh"> rx </em>，在实用方法<code class="du mw mx my mz b">singleOfAsync</code>内。<br/>这个方法的作用是接收一个<em class="mh">函数</em>，该函数将接收<em class="mh">承诺</em>链中的“当前”参数(<code class="du mw mx my mz b">T</code>)和<em class="mh">返回</em> ( <em class="mh">将</em>映射到)一个新的<code class="du mw mx my mz b">Promise</code>，具有新的类型<code class="du mw mx my mz b">R</code>(当然，很可能是同一类型<code class="du mw mx my mz b">T</code>)。<br/>这种将<em class="mh">承诺</em>如此轻松地链接起来的能力就是<em class="mh">承诺</em>的全部意义所在。与<em class="mh"> JavaScript </em>相反，我们知道编译时的类型！现在我们感到(几乎)满意了。让我们让<em class="mh">排版</em>爱好者冷静一分钟，因为他们对<em class="mh">排版</em>的泛型非常满意，我敢肯定；)</p><p id="d9f1" class="pw-post-body-paragraph kd ke hi kf b kg lt is ki kj lu iv kl jr lv kn ko jv lw kq kr jz lx kt ku kv hb bi translated">现在我们来看看<code class="du mw mx my mz b">singleOfAsync</code>的简化版:</p><figure class="kx ky kz la fd lb"><div class="bz dy l di"><div class="mj mk l"/></div><figcaption class="li lj et er es lk ll bd b be z dx translated">从映射器创建新单的实用方法——从某个参数T到新的承诺<r/></figcaption></figure><p id="1574" class="pw-post-body-paragraph kd ke hi kf b kg lt is ki kj lu iv kl jr lv kn ko jv lw kq kr jz lx kt ku kv hb bi translated">所以基本上，链接异步动作的<code class="du mw mx my mz b">Single</code>方式是一个<code class="du mw mx my mz b">flatMap</code>，它接受一个<em class="mh">映射器/函数</em>，这个映射器/函数<em class="mh">将链中的【当前】值<code class="du mw mx my mz b">T</code>映射到一个新的<code class="du mw mx my mz b">Single </code>(某种类型的<code class="du mw mx my mz b">R</code>)。<br/>函数<em class="mh">的参数</em>也差不多，但是它返回一个新的<code class="du mw mx my mz b">Promise&lt;R&gt; </code>而不是一个新的<code class="du mw mx my mz b">Single&lt;R&gt;</code>，对吗？所以我们将只手动执行给定的<em class="mh">功能</em>并取(<em class="mh">返回</em>到<code class="du mw mx my mz b">flatMap</code>)新的<em class="mh">承诺</em>的<code class="du mw mx my mz b">Single</code>，忽略新的<code class="du mw mx my mz b">Promise</code>。真是偷窃。</em></p><p id="34fb" class="pw-post-body-paragraph kd ke hi kf b kg lt is ki kj lu iv kl jr lv kn ko jv lw kq kr jz lx kt ku kv hb bi translated"><em class="mh">注:我们的</em> <code class="du mw mx my mz b"><em class="mh">Promise</em></code> <em class="mh">只是一个包装器，这里真正重要的是</em> <code class="du mw mx my mz b"><em class="mh">Single</em></code> <em class="mh">。所以基本上，一个</em> <code class="du mw mx my mz b"><em class="mh">Promise</em></code> <em class="mh">是由它的</em> <code class="du mw mx my mz b"><em class="mh">Single</em></code> <em class="mh">定义的，从另一个</em> <code class="du mw mx my mz b"><em class="mh">Single</em></code> <em class="mh">创建一个新的</em> <code class="du mw mx my mz b"><em class="mh">Promise</em></code> <em class="mh">，基本上与复制那个</em> <code class="du mw mx my mz b"><em class="mh">Promise</em></code> <em class="mh">是一样的。</em> <br/> <em class="mh">或者是？！？！:)<br/>我们将在下一篇文章中讨论错误处理，这是我刚才所说的一个例外。但是这个想法仍然存在——单身是我们承诺的定义。</em></p></div><div class="ab cl lm ln gp lo" role="separator"><span class="lp bw bk lq lr ls"/><span class="lp bw bk lq lr ls"/><span class="lp bw bk lq lr"/></div><div class="hb hc hd he hf"><p id="13a1" class="pw-post-body-paragraph kd ke hi kf b kg lt is ki kj lu iv kl jr lv kn ko jv lw kq kr jz lx kt ku kv hb bi translated">遵循上述原则，我们可以(非常容易地，<a class="ae mi" href="https://github.com/GuyMichael/APromise/blob/master/apromise/src/main/java/com/guymichael/promise/Promise.kt" rel="noopener ugc nofollow" target="_blank">参见源代码</a>)创建更多的‘then’动作并改进这些动作，以允许线程管理和更具体的用法。以下是一些让你兴奋的事情:</p><h2 id="534e" class="jg jh hi bd ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc ho bi translated">“然后”用穿线</h2><figure class="kx ky kz la fd lb"><div class="bz dy l di"><div class="mj mk l"/></div><figcaption class="li lj et er es lk ll bd b be z dx translated">简单的线程管理和<em class="np">承诺</em></figcaption></figure><h2 id="e9eb" class="jg jh hi bd ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc ho bi translated">实用程序操作</h2><p id="e7b0" class="pw-post-body-paragraph kd ke hi kf b kg kh is ki kj kk iv kl jr km kn ko jv kp kq kr jz ks kt ku kv hb bi translated">如果你对我们的“那么”感到满意，让我们来看看一些非那么实用的行动:</p><figure class="kx ky kz la fd lb"><div class="bz dy l di"><div class="mj mk l"/></div></figure><p id="cd7a" class="pw-post-body-paragraph kd ke hi kf b kg lt is ki kj lu iv kl jr lv kn ko jv lw kq kr jz lx kt ku kv hb bi translated">所有<em class="mh"> rx </em>的力量，在一个<em class="mh">承诺</em>般的语法中。</p></div><div class="ab cl lm ln gp lo" role="separator"><span class="lp bw bk lq lr ls"/><span class="lp bw bk lq lr ls"/><span class="lp bw bk lq lr"/></div><div class="hb hc hd he hf"><h2 id="37a7" class="jg jh hi bd ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc ho bi translated">回到起点</h2><p id="4082" class="pw-post-body-paragraph kd ke hi kf b kg kh is ki kj kk iv kl jr km kn ko jv kp kq kr jz ks kt ku kv hb bi translated">在我们总结之前，让我们用一个例子来结束这篇文章开始的<a class="ae mi" href="#5da1" rel="noopener ugc nofollow"> <em class="mh"> JavaScript </em>链是如何使用这个<em class="mh"> Kotlin Promise </em>编写的:</a></p><figure class="kx ky kz la fd lb"><div class="bz dy l di"><div class="mj mk l"/></div><figcaption class="li lj et er es lk ll bd b be z dx translated">同样的JavaScript链，在一个<em class="np">科特林承诺</em></figcaption></figure></div><div class="ab cl lm ln gp lo" role="separator"><span class="lp bw bk lq lr ls"/><span class="lp bw bk lq lr ls"/><span class="lp bw bk lq lr"/></div><div class="hb hc hd he hf"><h1 id="9c25" class="ml jh hi bd ji mm mn mo jm mp mq mr jq ix ms iy ju ja mt jb jy jd mu je kc mv bi translated">摘要</h1><p id="48e7" class="pw-post-body-paragraph kd ke hi kf b kg kh is ki kj kk iv kl jr km kn ko jv kp kq kr jz ks kt ku kv hb bi translated">所以这些是如何从<em class="mh"> rx Single、</em>创建<em class="mh"> Promise </em>的基础，从而产生一个无所不能的<em class="mh"> Promise </em>模型，它可以做<code class="du mw mx my mz b">Single</code>可以做的任何事情，但以一种直观、专注的方式，专门为<em class="mh">任务链</em>制作。<br/>希望你喜欢它，也希望你学到了一些新东西:)<br/>还有更多，尤其是我们如何处理错误(<em class="mh">拒绝</em>)，这将在下一篇文章中介绍。</p><p id="0050" class="pw-post-body-paragraph kd ke hi kf b kg lt is ki kj lu iv kl jr lv kn ko jv lw kq kr jz lx kt ku kv hb bi translated">我想感谢您的阅读，并鼓励您等待本<em class="mh">旅程</em>到<em class="mh">移动应用中的反应式编程</em>中的其余文章。它们将涵盖一切，从Android特有的T21承诺到构建现代应用的MVI架构。<br/> <em class="mh">提示:我瞄准</em> <a class="ae mi" href="https://kotlinlang.org/docs/reference/multiplatform.html" rel="noopener ugc nofollow" target="_blank"> <em class="mh">科特林多平台</em> </a> <em class="mh">。</em></p><p id="0886" class="pw-post-body-paragraph kd ke hi kf b kg lt is ki kj lu iv kl jr lv kn ko jv lw kq kr jz lx kt ku kv hb bi translated">这个项目，包括Android的<em class="mh"> APromise </em>，在GitHub上，<a class="ae mi" href="https://github.com/GuyMichael/APromise" rel="noopener ugc nofollow" target="_blank">去看看吧。</a></p><p id="969b" class="pw-post-body-paragraph kd ke hi kf b kg lt is ki kj lu iv kl jr lv kn ko jv lw kq kr jz lx kt ku kv hb bi translated">请随时留下您的意见和/或直接联系我。<br/>直到下一章——<em class="mh">承诺错误处理</em>——过得愉快。</p><p id="69f0" class="pw-post-body-paragraph kd ke hi kf b kg lt is ki kj lu iv kl jr lv kn ko jv lw kq kr jz lx kt ku kv hb bi translated">编辑:<a class="ae mi" rel="noopener" href="/@gguymi/ebb5b66bb745">下一章准备好了</a>！</p></div></div>    
</body>
</html>