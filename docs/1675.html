<html>
<head>
<title>Graph Traversal in Python: BFS,DFS,Dijkstra,A-star parallel comparision</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python中的图遍历:BFS，DFS，Dijkstra，A-star并行比较</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/graph-traversal-in-python-bfs-dfs-dijkstra-a-star-parallel-comparision-dd4132ec323a?source=collection_archive---------3-----------------------#2021-04-01">https://medium.com/nerd-for-tech/graph-traversal-in-python-bfs-dfs-dijkstra-a-star-parallel-comparision-dd4132ec323a?source=collection_archive---------3-----------------------#2021-04-01</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="a79f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们已经讨论过关于<a class="ae jd" rel="noopener" href="/nerd-for-tech/graph-traversal-in-python-breadth-first-search-bfs-b6cff138d516">广度优先搜索(BFS) </a>、<a class="ae jd" rel="noopener" href="/nerd-for-tech/graph-traversal-in-python-depth-first-search-dfs-ce791f48af5b">深度优先搜索(DFS) </a>、<a class="ae jd" rel="noopener" href="/nerd-for-tech/graph-traversal-in-python-dijkstras-search-895c1d5aa1b1">Dijkstra’Search</a>、<a class="ae jd" rel="noopener" href="/nerd-for-tech/graph-traversal-in-python-a-algorithm-27c30d67e0d0"> A-star(或A*)算法</a>。让我们快速回顾和比较过去4篇介绍图遍历算法的文章。这将是关于图遍历的最后一篇文章。</p><p id="d4bb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">简而言之，BFS和DFS只是根据自己的偏好遍历所有节点。一个走得更宽，另一个挖得更深。而Diskstra看起来更聪明，能够根据自己的喜好选择较小的步长。从用户那里得到答案而被欺骗。</p><p id="bb30" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">单个情况下，哪个效率更高全凭运气。自从A*得到了小抄，它通常比其他人更快。</p><p id="090f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> BFS和DFS: </strong></p><p id="8c8f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">对于BFS和DFS，节点扫描的顺序是固定的。在BFS中，节点被推到类似队列的FIFO存储中，并保持先来先服务的扫描顺序。那些较浅的节点在那些较深的节点之前加入队列，因此它们可以首先被扫描。而对于DFS，浅节点进入堆栈式的LIFO存储，并“卡”在底部！那些更深的节点堆叠在入口处，首先出来，如下图所示。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div class="er es je"><img src="../Images/602830e1ebffd48a2eb8e53a32a6c3f8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1346/format:webp/1*lmtkK7gxhEdeSNzP4fa90w.png"/></div></figure><p id="68d2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">上面的示例是通过以下代码实现的:</p><pre class="jf jg jh ji fd jm jn jo jp aw jq bi"><span id="a531" class="jr js hi jn b fi jt ju l jv jw">#BFS<br/>queue.append(new_node)<br/>queue.pop(0)</span><span id="f542" class="jr js hi jn b fi jx ju l jv jw">#DFS<br/>queue.append(ned_node)<br/>queue.pop()#default pop out the -1, i.e., the last one</span></pre><p id="1154" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">他们确实需要另一个容器来记录被访问的节点。但是它们的边缘没有重物。距离的累积是不必要的。</p><p id="e76b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在如果你看到他们的代码，他们几乎是一样的，除了节点弹出的方式为下一轮扫描。另一个区别是，对于DFS，扫描顺序与推入顺序不同。这将导致“已访问”列表中的错误顺序。我们不返回'已访问'列表，相反，我们需要创建另一个容器来存储' s '或者直接打印' s '作为输出。为了使BFS和DFS相似，我们选择直接打印“s”。</p><pre class="jf jg jh ji fd jm jn jo jp aw jq bi"><span id="c269" class="jr js hi jn b fi jt ju l jv jw">#BFS<br/>def bfs(graph,node):<br/>    visited=[]<br/>    queue=[]    <br/>    visited.append(node)<br/>    queue.append(node)<br/>    <br/>    while queue:<br/>        s=queue.pop(0)<br/>        <br/>        for x in graph[s]:<br/>            if x not in visited:<br/>                visited.append(x)<br/>                queue.append(x)<br/>    return visited</span><span id="20f5" class="jr js hi jn b fi jx ju l jv jw">#DFS<br/>def dfs(graph,node):<br/>    visited=[]<br/>    queue=[]<br/>    <br/>    queue.append(node)<br/>    visited.append(node)<br/>    <br/>    while queue:<br/>        s=queue.pop()<br/>        print(s)</span><span id="667e" class="jr js hi jn b fi jx ju l jv jw">        for x in graph[s][::-1]:<br/>            if x not in visited:<br/>                visited.append(x)<br/>                queue.append(x)</span></pre></div><div class="ab cl jy jz gp ka" role="separator"><span class="kb bw bk kc kd ke"/><span class="kb bw bk kc kd ke"/><span class="kb bw bk kc kd"/></div><div class="hb hc hd he hf"><p id="7573" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">迪杰斯特拉和一个* </strong></p><p id="c0fb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在我们有了边缘的重量。这仅仅意味着每条路都有它的长度。BFS和DFS无法处理这种情况，因为它们没有“累加器”来计算距离。我们可以简单地添加<strong class="ih hj">“累加器”</strong>让它们更智能。其实我们可以做一个BFS和DFS版的Dijkstra或者A*！</p><p id="2289" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们先看看Dijkstra和A*，然后回到“广度/深度-Dijkstra”和“广度/深度A*”。请允许我把之前的代码都粘贴到这里，开始看看这些算法有什么特别的地方。</p><pre class="jf jg jh ji fd jm jn jo jp aw jq bi"><span id="0960" class="jr js hi jn b fi jt ju l jv jw">#Dijkstra<br/>import heapq</span><span id="a237" class="jr js hi jn b fi jx ju l jv jw">def dijkstra(graph,node):    <br/>    distances={node:float('inf') for node in graph}<br/>    distances[node]=0<br/>    came_from={node:None for node in graph}    <br/>    queue=[(0,node)]<br/>    <br/>    while queue:<br/>        current_distance,current_node=heapq.heappop(queue)<br/>        # relaxation<br/>        for next_node,weight in graph[current_node].items():<br/>            distance_temp=current_distance+weight<br/>            if distance_temp&lt;distances[next_node]:<br/>                distances[next_node]=distance_temp<br/>                came_from[next_node]=current_node<br/>                heapq.heappush(queue,(distance_temp,next_node))<br/>    return distances,came_from</span><span id="be9e" class="jr js hi jn b fi jx ju l jv jw">#A*<br/>def astar(graph,start_node,end_node):<br/>   <br/>    f_distance={node:float('inf') for node in graph}<br/>    f_distance[start_node]=0<br/>    <br/>    g_distance={node:float('inf') for node in graph}<br/>    g_distance[start_node]=0<br/>    <br/>    came_from={node:None for node in graph}<br/>    came_from[start_node]=start_node<br/>    <br/>    queue=[(0,start_node)]    <br/>    while queue:<br/>        current_f_distance,current_node=heapq.heappop(queue)<br/><br/>        if current_node == end_node:<br/>            return f_distance, came_from<br/>        for next_node,weights in graph[current_node].items():               <br/>            temp_g_distance=g_distance[current_node]+weights[0]            <br/>            if temp_g_distance&lt;g_distance[next_node]:                <br/>                g_distance[next_node]=temp_g_distance<br/>                heuristic=weights[1]                <br/>                f_distance[next_node]=temp_g_distance+heuristic<br/>                came_from[next_node]=current_node<br/>                <br/>                heapq.heappush(queue,(f_distance[next_node],next_node))</span><span id="9fd0" class="jr js hi jn b fi jx ju l jv jw">    return f_distance, came_from</span></pre><p id="52c6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">显然它们看起来更复杂，但事实上它们只有几个临时容器来存储信息。</p><p id="2e4d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">从BFS/DFS到Dijkstra，我们多了一个容器<strong class="ih hj">来存储所有的距离</strong>。我们用另一个容器<strong class="ih hj">存储遍历路径</strong>。(我们在BFS/DFS中需要这个路径记录器吗？我想我们可能需要它！)</p><p id="22aa" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">从Dijkstra到A*我们有另一个备忘单容器，叫做<strong class="ih hj">“启发式”</strong>。<strong class="ih hj">普通距离</strong>容器仍然在这里，但将其名称改为“g_distance”或“g_score”，启发式和g_distance的附加使得<strong class="ih hj">“f _ distance”</strong>或“f_score”。</p><p id="068f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">最后，我们需要一个过滤器来选择最小的项目<strong class="ih hj">。heapq.heappop() </strong>方法执行这样的功能。</p><p id="6474" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果我们概括所有这些图算法的模式，它们具有以下结构:图算法确实需要容器来<strong class="ih hj">存储即将到来的信息</strong>，并且<strong class="ih hj">处理信息</strong>，并且<strong class="ih hj">返回</strong>处理过的信息。仅此而已。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div class="er es kf"><img src="../Images/eb2f496113a5c94bc059852cf8f266e0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1292/format:webp/1*lX_J2sW8UvNzqSvXmqhvuA.png"/></div></figure><p id="28da" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这个模式<strong class="ih hj">可能不一定</strong>代表了<strong class="ih hj">这个世界上所有的算法！我们将在未来探索其他算法的更多模式来验证这一假设。感谢阅读！</strong></p></div><div class="ab cl jy jz gp ka" role="separator"><span class="kb bw bk kc kd ke"/><span class="kb bw bk kc kd ke"/><span class="kb bw bk kc kd"/></div><div class="hb hc hd he hf"><p id="7b65" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">BFS/DFS版的Dijkstra和A* </strong></p><p id="b864" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们可以通过将heapq.heappop()方法与queue.pop(0)放在一起以获得BFS-迪杰斯特拉/A*，或者将queue.pop()放在一起以获得DFS-迪杰斯特拉/A*来制作这些算法。没有选择最小值，队列现在简单地以FIFO和LIFO的方式弹出节点。现在你有了更慢的Dijkstra/A*！</p><p id="6159" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">但同样，速度全凭运气，<strong class="ih hj">除非你“作弊”</strong>，这意味着A*仍然比其他人快。</p></div></div>    
</body>
</html>