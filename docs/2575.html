<html>
<head>
<title>Resilient Network Calls From The Front-End</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">来自前端的弹性网络呼叫</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/resilient-network-calls-from-the-front-end-d45d846e28b0?source=collection_archive---------24-----------------------#2021-05-11">https://medium.com/nerd-for-tech/resilient-network-calls-from-the-front-end-d45d846e28b0?source=collection_archive---------24-----------------------#2021-05-11</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="b470" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">从您的前端重试所有网络呼叫，以使应用程序更具弹性和可靠性</h2></div><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ix"><img src="../Images/0ea63978e55ff179922f7c814c6204e1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*p5BeOr0P8ZUsvPva"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">丹尼·米勒在<a class="ae jn" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><p id="f338" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">我们构建的前端应用程序大多依赖于活跃的互联网连接，以便访问服务器并获取或发布数据。一旦检索到数据，我们就可以在本地做一些事情，比如动画、过渡、验证等等。我们如此习惯于可靠的互联网连接，以至于我们经常忽略这样一个事实，即我们从前端到服务器端的网络调用可能是应用程序中最不可靠的部分。我们需要这样对待它，因为它随时都可能失败(很少，但它可能会失败)。<br/>可能会发生这样的情况，用户从一部手机访问你的应用程序，这部手机正在从 Wi-Fi 切换到移动数据，或者在一个低覆盖区域。<br/>在这些情况下，您的应用程序试图进行的网络调用可能会失败，用户会看到一个很好的错误消息，要求他再试一次。用户刷新屏幕或再次点击按钮，应用程序就像什么也没发生一样工作。你说工作完成了，然后继续下一个功能。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es kk"><img src="../Images/5816e61f7007c7bf2c5956f71963d770.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*mAUbF2A8TMLnhrst"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">只是一点擦伤</figcaption></figure><p id="9ab9" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">但是在这里你可以做得更好。您的应用程序可以代替用户重试，从而提高 UX。</p><h2 id="defa" class="kl km hi bd kn ko kp kq kr ks kt ku kv jx kw kx ky kb kz la lb kf lc ld le lf bi translated">自动重试失败的请求</h2><p id="1ab5" class="pw-post-body-paragraph jo jp hi jq b jr lg ij jt ju lh im jw jx li jz ka kb lj kd ke kf lk kh ki kj hb bi translated">我们可以做一个简单的拦截器来拦截所有的 HTTP 请求。如果遇到错误，它可以在抛出错误之前重试。</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="ll lm l"/></div></figure><p id="7260" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">用户可能会等待更长时间，但这可能比显示错误要好。此外，用户可能知道他的设备正在切换到 Wi-Fi，或者他在信号较弱的区域。</p><p id="28ba" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">上面的拦截器是非常基本的，将重试一切。但是我们可以进一步改进它。如果错误是 4xx，通常意味着是客户端出了问题，重试 1000 次也不能解决问题。因此，如果是这种情况，我们可以跳过重试。<br/>此外，在上面的简单示例中，我们只是在 1 秒钟后重试，这时间太长了。相反，我们可以非常快地重试一次或两次，然后后退并以更大的延迟重试一次或两次。这样，如果它是一个临时错误，它将通过快速重试立即得到解决，或者作为后退延迟后的最后希望。但是我们应该小心，不要让用户等待太久，否则他们可能会认为应用程序没有响应。<br/>作为 UX 的最后一项改进，当我们重试时，我们可以在进度加载器旁边添加一个小文本，内容大致为“检测到连接缓慢，请耐心等待”或“服务器正忙，请稍候”。通过这种方式，我们将向用户反馈应用程序没有停滞或没有响应，但它确实在尽最大努力完成工作。</p><h2 id="7514" class="kl km hi bd kn ko kp kq kr ks kt ku kv jx kw kx ky kb kz la lb kf lc ld le lf bi translated">结论</h2><p id="9a8d" class="pw-post-body-paragraph jo jp hi jq b jr lg ij jt ju lh im jw jx li jz ka kb lj kd ke kf lk kh ki kj hb bi translated">大多数应用程序没有这样的功能也能工作。他们可以成功，因为他们完成了工作。但是像这样的小事情可以促使你的思维总是涵盖边缘案例，甚至在它们出现之前。<br/>另一个要点是，这是在全球范围内完成的，因此所有新的网络调用将更具弹性，甚至开发人员都不知道。</p></div></div>    
</body>
</html>