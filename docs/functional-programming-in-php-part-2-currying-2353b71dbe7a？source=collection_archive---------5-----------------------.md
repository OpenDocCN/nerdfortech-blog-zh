# PHP 函数式编程(第二部分)——Currying

> 原文：<https://medium.com/nerd-for-tech/functional-programming-in-php-part-2-currying-2353b71dbe7a?source=collection_archive---------5----------------------->

![](img/0b49fbd7a53b905e00ed554f4ded6619.png)

由[莎伦·麦卡琴](https://unsplash.com/@sharonmccutcheon?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText)在 [Unsplash](https://unsplash.com/s/photos/bubbles?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText) 拍摄的照片

在[上一篇文章](https://auxiliaire.medium.com/functional-programming-in-php-an-introduction-80e3f2a46e74)中，我们介绍了 PHP 中函数式编程(FP)的基础。到目前为止，这不是一个全面的介绍，而是提到了 FP 的最重要的概念以及 PHP 的特性，这是尽快开始在 PHP 中应用 FP 所必需的。在这一部分中，我假设你已经熟悉了介绍中提到的那些基础知识，随着我们继续进行*和*的讨论，我会加入更多的概念。

# 给你的代码增添趣味

虽然听起来很花哨，但 currying 实际上与你最喜欢的姜黄混合粉没有任何关系，而是从美国数学家哈斯克尔·库里(Haskell Curry)那里衍生出它的名字(你肯定会记得这个名字)。尽管如此，我们将会看到，阿谀奉承无异于给我们的代码增添趣味。

在纯函数式语言中，比如 Haskell(惊喜！)，您可以为函数提供比它们期望的更少的参数(←不准确，它们总是期望最多一个参数，但是为了简单起见，我们将从这个角度进行讨论)，并且它们弹性地回复一个新函数，该函数期望剩余的参数，同时捕获您已经提供的参数。

这是 currying。(事实上这是自动的，因为您不需要像我们将要做的那样显式地调用函数上的`curry`。)

我们可以用如下一些象征来说明这一点。

如果我们将函数视为将输入映射到输出的映射器，我们可以将它们符号化如下:

```
<input_type> → <output_type>
```

像这样带多个参数的函数:

```
<input_type_1>, <input_type_2>, <input_type_3> → <output_type>
```

那么我们可以这样表示 curried 函数(3 个参数的例子):

```
<input_type> → (<input_type_2> → (<input_type_3> → <output_type>))
```

也就是说，我们的函数不是等待所有三个参数，而是返回另一个接受下一个参数的函数，并返回另一个接受最后一个参数的函数，然后返回输出。

有多少输入参数并不重要。

```
<input_type_1>, ...<input_type_n> → <output_type>
```

会被奉承到:

```
<input_type_1> → (... → (<input_type_n> → <output_type>))
```

我们也可以跳过括号，因为我们的函数总是返回一个输出，所以很明显箭头右侧的所有内容都是输出:

```
<input_type_1> → ... → <input_type_n> → <output_type>
```

这里重要的一点是，我们可以推迟收集所有需要的数据，并将已经可用的数据存储在一个新函数中。

实际上，这意味着，如果你期望 5 个参数，而你一个都没给，你得到一个函数，继续期望 5 个参数*或更少*。如果这个函数只有一个参数，那么它将返回一个新函数，期望剩下的 4 个参数，同时获取已经提供的参数。如果你给这个函数提供两个参数，那么返回的函数将期待剩下的三个参数，依此类推。好的一面是，返回的函数也会帮我们这个忙，我们可以一个接一个地给函数输入参数。或者一个接一个。或者按你喜欢的任何方式分组。

如果您提供了所有必需的参数会怎么样？然后你的函数最终被执行，正如我们在上面看到的，并返回结果。

这是一个非常强大的概念，让我们摆脱了大量的局部变量。

此时，您可以尝试实现自己版本的`curry`函数，它接受一个函数，并不断返回接受下一个参数的嵌入式函数，直到原始函数的所有参数都满足，在这种情况下，它只返回使用提供的参数调用的原始函数的结果。

在此期间，我将谈谈*变长参数列表*。一会儿见。

# "一条大蟒蛇正在消化一头大象"

就像名画中的蛇一样，如果我们允许，我们的功能也能够吞咽和消化几乎任何东西。这意味着它们可以接受不同数量的参数，我们不需要指定它们的数量。它可以是零、一或更多。

这是通过用“`...`标记”来标记我们的函数来实现的 PHP 这样称呼它们。在其他语言中，它被称为“省略号”(C/C++，Java)，或“扩展操作符”(JavaScript/TypeScript)，但奇怪的是，PHP 避免将其称为这些名称中的任何一个，而是在文档的所有相关部分[中使用“`...`令牌”或“`...`操作符”短语(](https://www.php.net/manual/en/functions.arguments.php#functions.variable-arg-list)[发布公告](https://www.php.net/manual/en/migration56.new-features.php))。即使我们不直呼其名(出于一些迷信的原因)，它们也非常有用，我们会相当频繁地使用它们。

语法如下所示:

```
function variadic(...$arguments) {}
```

其中`$arguments`参数将是一个`array`。这可以帮助我们在 PHP 中一次为函数提供任意数量的参数，并简化一些代码。

回到我们的汤…

# 用咖喱烹饪

我们第一次尝试使用我们的 curry 函数(您可能已经实现了它，或者将使用我稍后提供的实现)可能看起来像下面这样:

如果我们运行这段代码，它应该会输出:

```
myc(a, b, c)     =>     a b c
myc(a)(b)(c)     =>     a b c
myc(a, b)(c)     =>     a b c
myc(a)(b, c)     =>     a b c
myca(b, c)       =>     a b c
myca(b)(c)       =>     a b c
mycab(c)         =>     a b c
mycabc           =>     a b c
```

如果我们采用测试驱动的开发方法，这可能是我们的(草率的)测试。我们创建了一个简单函数`$myfunc`(第 5 行)的简化版本，另外三个函数一个接一个地向它们提供参数(第 7–9 行)，然后开始疯狂地调用这些函数。

我们假设的`curry`函数显然只接受一个参数，即要 curried 化的函数。

`$myfunc`将是我们的原始函数，它有固定数量的参数，只是从它们创建另一个字符串。这里没有魔法。

创建函数的部分代表了这样一种思想，即 curried 函数一直保持 curry 状态，直到所有需要的参数都被传递给原始函数。注意，我们不需要重复已经给出的参数，因为它们在返回的函数中被捕获，并且只等待其余的。我们可以像刚才那样，把这些函数赋给一个新变量，它们继承已经提供的参数。

打印到屏幕上的代码行显示了调用这种定制函数的各种方式。正如您所看到的，无论我们如何调用它们，或者我们如何对参数进行分组，只要提供了所有参数，它们总是返回相同的字符串:`a b c`。

我们的测试做得不是特别好，因为一些重要的案例被遗漏了。例如，如果我们的原始函数不期望任何参数，该怎么办？然后，按照指定，返回函数调用的结果。如果我们立即提供所有需要的参数呢？为此，我们可以尝试以下方法:

```
curry($myfunc)('a', 'b', 'c')
```

根据定义，它将返回相同的输出:`a b c`。那么为什么不使用我们的带三个点的朋友，并接受一个可变长度的参数列表呢？嗯，那要看情况。假设我们有它，我们可以这样调用:

```
curry($myfunc, 'a', 'b', 'c'); // 1.
curry($myfunc, 'a')('b', 'c'); // 2.
```

这样好些了吗？我认为第一个没有意义，因为我们可以直接调用原始函数。如果`curry`返回的是原函数的结果。但是如果它一直返回一个函数(可调用的)，那么我们需要另一个调用来触发原始函数，就像这样:

```
curry($myfunc, 'a', 'b', 'c')();
```

那对我来说也没多大意义。我能想到的这样做的唯一原因是确保我们的`curry`函数总是返回一个可调用的。

第二个例子是把一些参数放在`curry`中，而把一些留在后面，这样做丝毫没有改善语法。事实上，它只是提出了一些混乱，有时看到完全不同类型的参数在库里以下的第一个，我们原来的功能。我更喜欢保持 API 干净，并且尽可能使用最少的必要参数。对于这一点，下面这样的签名在我看来是最优的:

```
curry(callable $fn)
```

没有噪音，没有杂物，只有赤裸裸的必需品。好了，继续前进。

# 上菜

如果还想刺激食欲，就不能简单地对食物拍照。事实证明，服务在其中起着至关重要的作用。食物如何被放在盘子上，如何被点燃，使用什么样的相机，等等。

在上面的示例用法中，我们可以找到 23 个`$`字符的实例。总共 18 行代码。这超过了总人数的 3%。相当多的杂物。如前所述，我们甚至不需要它们。我们更乐意拥有常量，但我们这样做的选择也不是很明智。

暂时，让我们玩弄一下不可变值的思想，假装我们上一部分的实现没有任何问题。所以定义一个不可变的值，如下所示:

```
function immutable(): string { return 'totally immutable'; }
```

以前我们定义变量来存储函数。因此，让我们也将它们定义为不可变的:

```
function immutableFn(): callable { return fn() => 'yeah'; }
```

让我们看看如何利用这些巴结。

产出:

```
Immutable greeting: Good day, Tülin!
Good day, Tülin!
Hello, Tülin!
```

所以我们大大减少了变量的使用。所有不应该改变的东西都变成了不可变的(通过函数实现)，我们还通过更高阶的函数和 currying 来改进代码重用。恕我直言，我们还提高了可读性。

我们的主函数有一个不可改变的值`greet`。它只返回一个接受两个参数(一个窗体和一个名称)的函数。

对于两种支持的形式`formal`和`informal`，我们有两个不可变的值，分别是值“Good day”和“Hello”。

然后我们使用一些 FP 魔法定义了两个新的不可改变的值，用来自`formal`和`informal`的预定义值填充我们原始的`greet`函数，并给它们命名为`greetFormally`和`greetInformally`。

这里重要的一点是，当数据可用时，我们可以将数据传递给我们的函数，并且我们可以以类似于[依赖注入](https://www.freecodecamp.org/news/a-quick-intro-to-dependency-injection-what-it-is-and-when-to-use-it-7578c84fa88f/)或[策略设计模式](https://refactoring.guru/design-patterns/strategy)的方式将函数注入其他函数。这帮助我们[分离关注点](https://en.wikipedia.org/wiki/Separation_of_concerns)，不重复自己[干](https://en.wikipedia.org/wiki/Don%27t_repeat_yourself)，保持[单一责任](https://en.wikipedia.org/wiki/Single-responsibility_principle)。是啊，所有的 OOP 的东西，只是更容易。

*注意，我提到这些只是为了帮助你理解一些概念，前提是你已经熟悉这些概念，但它们不是一对一的类比，如果你没有完全理解它们，你也不必担心。要继续，理解我们的代码示例是如何工作的就足够了。*

最后，我们用名为`tulin`的值‘tüLin’定义了另一个不可变的，用已经存储在`tulin`中的值定义了另一个名为`girl`的。

我们所有的组件都是可重复使用的。我们在现有功能的基础上构建了新的功能，比如玩乐高。我们在创建新的、专门化的功能的代码中相对较早地添加了配置，并在可能的最新时刻为它们提供了最切实的价值。随着我们为我们的工具箱收集越来越多的 FP 工具，这个组织原则将会被进一步强调。

请记住，我们用来存储不可变值的命名组件不应该是 PHP 意义上的函数。它们之所以成为函数，只是因为我们实现了不变量 uses 函数。这解释了即将出现的大量括号:

```
greet()(formal(), tulin())
```

和

```
greetFormally()(tulin())
```

这些乍一看可能很奇怪，但是在理想世界中，它们应该是这样的:

```
greet(formal, tulin)
```

和

```
greetFormally(tulin)
```

这个理想世界类似于 Scala 语法的工作方式。那么，在一种假想的 PHP 语言中，整个代码片段会是什么样子呢？

假设有一个用于定义不可变值的构造，它被称为`let`，那么它可能如下所示:

```
let callable greet = fn(callable $form, string $name): string => $form() . ', ' . $name . '!';let callable formal = fn(): string => "Good day";
let callable informal = fn(): string => "Hello";let callable greetFormally = curry(greet)(formal);
let callable greetInformally = curry(greet)(informal);let string tulin = "Tülin";let string girl = tulin;// reassignment does not work:
// let string girl = "Somebody else";greet(formal, tulin);
greetFormally(tulin);
greetInformally(girl);
```

好多了。现在别做梦了，回去工作吧。我们有一个功能要实现。

![](img/81639540a6a0273b5d7fb91b610ccad3.png)

这里有一幅美丽的巴伐利亚风景图，可以帮助你做好心理准备——由作者提供

# 在 PHP 中实现 curry

在语言中实现 currying 有几种方法，在 PHP 中也有几种方法。现在，您可能有了自己的版本，并对照使用示例进行了检查。如果效果很好，恭喜你，你做对了！

作为参考，我提供了我自己的实现，它专注于定义一个清晰的接口，并尽可能对用户隐藏实现细节。

所有的例子都是使用这个实现进行测试的，它也是我们将在这一系列文章中实现的所有其他功能的基础。

首先，不要和这里的`class`关键词混淆。这不是严格意义上的 OOP 类(我们也不允许实例化它——通过第 19 行),它只是帮助我们隐藏信息。我不想暴露我的函数的内部，它不是供公众使用的。封装正在被拯救。

我们使用了*反射* (第 4 行)的很酷的 PHP [特性，它提供了一些关于正在使用的东西的元信息，例如我们的函数有多少个参数。这也使得用一些参数调用我们的函数成为可能(第 16 行)。](https://www.php.net/manual/en/book.reflection.php)

我们基本的 curry 函数在这里是作为私有方法实现的。public 方法只是提供了一个清晰的接口，做了一些准备。`_curry`可能是一个递归函数，这意味着它会调用自己，但我们不为此而烦恼。我们只是让用户在需要时调用它(第 14 行)。在我们的例子中，直到所有的参数都被提供。如果没有丢失任何东西，那么就用收集到的参数调用原始函数，并返回结果(第 16 行)。

剩下的只是 PHP mambo jambo:我们如何通过参数列表传递数据，以及如何用箭头函数捕获上下文(第 14 行)。同样在这一行中，我们声明我们不知道下一次将有多少参数被传递给我们的函数，但是无论提供了什么，只要用数组解包`...`操作符将它转发给我们的私有 curry weightlifter 就行，我们不点名地调用它。

我们的函数在那里停止执行，只继续收集原始函数的参数，如果它们被提供的话。因为它是使用我们的全感知私有函数来实现的，所以它可以重新检查所有参数是否都可用，然后最终调用该函数。

然而这并不是函数在 FP 中实现的方式，而是我们在 PHP 中实现一个基本 FP 函数的方式。无论我们用什么狡猾的方法来实现这些功能，它们都是相当短的、可测试的，并且它们的内部结构永远不会再出现。希望我们永远不需要接触这个部件，但是我们可以在 FP 的日常业务中愉快地使用它，知道它只做一件事，而且做得对。

您可以改进这个功能，或者根据您的需要进行定制。一如既往，最重要的不是一个东西是如何实现的，而是它定义了什么接口，给出了什么保证，或者遵守了什么法律。

这就够了。确保你有一个可用的`curry`版本，根据提供的用例进行测试，因为从现在开始我们会大量使用它。

*在* [*的下一篇文章*](https://auxiliaire.medium.com/function-composition-functional-programming-in-php-part-3-56ff7152c20a) *中，我将谈论函数组合，我们如何以一种干净的方式将几个函数组合成一个函数，以及模块，我们可以使用模块来更好地组织我们的代码，同时仍然具有封装的好处，所以敬请关注！*