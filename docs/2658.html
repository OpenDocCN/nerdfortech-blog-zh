<html>
<head>
<title>May 14: Random CSS animations using styled-components in React</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">5月14日:在React中使用样式化组件的随机CSS动画</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/may-14-random-css-animations-using-styled-components-in-react-dda83d9afb62?source=collection_archive---------8-----------------------#2021-05-15">https://medium.com/nerd-for-tech/may-14-random-css-animations-using-styled-components-in-react-dda83d9afb62?source=collection_archive---------8-----------------------#2021-05-15</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/45176f11deba5634c30349d24f5dc7e8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*cKQVe1K9iJUUzPFHFnpX3w.gif"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">纸动物实验镜，埃德沃德·迈布里奇，1893年</figcaption></figure><p id="42b8" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">没有动画，网络就没那么有趣了。这是吸引用户的最简单的方法，因为<a class="ae js" href="https://www.nngroup.com/articles/response-times-3-important-limits/" rel="noopener ugc nofollow" target="_blank">动画模仿了真实世界</a>的自然节奏，使网站更具关联性。如果做得好，它会给一个应用程序带来完美的、专业的光芒，这是其他地方无法轻易弥补的。</p><p id="323f" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><a class="ae js" href="https://joshgoestoflatiron.medium.com/april-2-intervals-and-event-listeners-when-working-with-react-hooks-14bc069affe0" rel="noopener">我以前在这个博客上写过关于</a> <strong class="iw hj"> React </strong>的文章，这是一个用于构建用户界面的开源JavaScript库，因为尽管它很受欢迎，功能强大，但它的许多怪癖甚至会让最有经验的开发人员感到困惑。其中一个特质是React应用程序与CSS的关系，既然CSS是web动画事实上的标准，现在Adobe终于理所应当地在Flash的核心部分占有一席之地，理解这种关系对于使用它创建引人注目的动画至关重要。让我们在今天的帖子中关注这种关系！</p><h1 id="b78c" class="ju jv hi bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">背景</h1><p id="7359" class="pw-post-body-paragraph iu iv hi iw b ix ks iz ja jb kt jd je jf ku jh ji jj kv jl jm jn kw jp jq jr hb bi translated"><a class="ae js" href="https://daveceddia.com/what-react-does/" rel="noopener ugc nofollow" target="_blank"> David Ceddia </a>提出了我想在开始之前强调的一个重要观点:<strong class="iw hj"> React做的事情并没有你想象的那么多。它在网页上绘制HTML就是这样。因此，当你创建和调整自己的动画React应用程序时，请记住，许多“React问题”实际上只是JavaScript问题或CSS问题。</strong></p><p id="d8a2" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">在这篇博文中，我将使用一个简单的掷骰子作为例子，灵感来自纽约的生活，每年这个时候街头掷骰子游戏很常见。按下“滚动”按钮后，三个骰子旋转到顶部，从“墙壁”上“反弹”，并“降落”在屏幕上随机的某个地方:</p><figure class="ky kz la lb fd ij er es paragraph-image"><div class="er es kx"><img src="../Images/89c87f21e809a14bc2aaee74e4abd910.png" data-original-src="https://miro.medium.com/v2/resize:fit:640/1*71k3oa4j40y6REDtTW_dmQ.gif"/></div></figure><p id="0638" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">要考虑的一个关键术语:关键帧<strong class="iw hj">是一个平滑过渡的起点或终点的快照——一个在时间上冻结的时刻。它被称为<em class="jt">帧</em>是因为很久很久以前，在一个很远很远的星系里，动画是在被称为“胶片”的纸质材料的实际物理条上完成的，被分成称为帧的方块。</strong></p><h1 id="5187" class="ju jv hi bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">通往王国的钥匙</h1><p id="86c6" class="pw-post-body-paragraph iu iv hi iw b ix ks iz ja jb kt jd je jf ku jh ji jj kv jl jm jn kw jp jq jr hb bi translated">在纯CSS中，我们将使用<code class="du lc ld le lf b">@keyframes</code> CSS规则来制作骰子动画，这允许我们定义动画的起点、终点和中间点，具有很大的灵活性和简单明了的细节:</p><pre class="ky kz la lb fd lg lf lh li aw lj bi"><span id="889b" class="lk jv hi lf b fi ll lm l ln lo">@keyframes dieAnimation {<br/>   from {<br/>      top: 110%;<br/>      left: 50%;<br/>   }<br/>   to {<br/>      top: 0%;<br/>      left: 50%;<br/>      transform: rotate( 360deg );<br/>   }<br/>}</span></pre><p id="43da" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">这个动画将使我们的骰子从视窗的底部缩放到顶部，旋转360 °,并始终保持在视窗的中间。这个动画非常简单，因为它只有两个关键帧:开始<code class="du lc ld le lf b">from:</code>和结束<code class="du lc ld le lf b">to:</code>。我们可以通过指定其他关键帧来进一步了解细节:</p><pre class="ky kz la lb fd lg lf lh li aw lj bi"><span id="5ab0" class="lk jv hi lf b fi ll lm l ln lo">@keyframes dieAnimation {<br/>   0% {<br/>      top: 110%;<br/>      left: 50%;<br/>   }<br/>   50% {<br/>      top: 0%;<br/>      left: 50%;<br/>      transform: rotate( 360deg );<br/>   }<br/>   100% {<br/>      top: 50%;<br/>      left: 50%;<br/>      transform: rotate( 360deg );<br/>   }<br/>}</span></pre><p id="2239" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">现在，我们的旋转骰子将在动画进行到一半时停在视口的顶部，然后停在屏幕的中央。</p><p id="d717" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">这很可爱，但它并没有真正公平地对待掷骰子的体验。骰子总是沿着相同的路径，落在相同的地方…但是在现实生活中，当然，骰子是随机的，落在随机的地方。那么，<em class="jt">我们如何给我们的骰子动画添加随机性呢？</em>有些CSS预处理程序中有随机数发生器，比如<a class="ae js" href="https://sass-lang.com/" rel="noopener ugc nofollow" target="_blank"> SASS </a>:</p><pre class="ky kz la lb fd lg lf lh li aw lj bi"><span id="d121" class="lk jv hi lf b fi ll lm l ln lo">$randomDuration: random( 5 );</span><span id="d83c" class="lk jv hi lf b fi lp lm l ln lo">.dice { animation-duration: $randomDuration; }</span></pre><p id="22fa" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">但是这里有一个巨大的问题:SASS只在运行时随机化，这意味着只要SASS处理你的CSS，这个数字就不会改变(直到SASS再次运行)。每当代码像<code class="du lc ld le lf b">Math.random()</code>一样运行时，这个“随机”数字就不会产生。借用<a class="ae js" href="https://twitter.com/jake_albaugh/status/814510609219911680" rel="noopener ugc nofollow" target="_blank">杰克·阿尔博</a>的一个比喻，在SASS中用<code class="du lc ld le lf b">random</code>挑选一个随机数就像用一个随机总统的名字挑选一个随机的名字。</p><h1 id="39f5" class="ju jv hi bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">风格警察</h1><p id="978f" class="pw-post-body-paragraph iu iv hi iw b ix ks iz ja jb kt jd je jf ku jh ji jj kv jl jm jn kw jp jq jr hb bi translated">很明显，我们需要将JavaScript引入到图片中来随机化我们的CSS骰子动画。但是因为我们使用的是React而不是纯JavaScript，所以我们将通过引入<code class="du lc ld le lf b">styled-components</code>来做到这一点，这是一个<a class="ae js" href="https://github.com/styled-components/styled-components" rel="noopener ugc nofollow" target="_blank">包</a>，它允许我们一起使用CSS和JavaScript，并和谐地使用两者——这是一个被称为<a class="ae js" rel="noopener" href="/dailyjs/what-is-actually-css-in-js-f2f529a2757"><strong class="iw hj">“CSS-in-JS”的概念</strong> </a></p><p id="1dad" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">在之前的博客文章中，我已经探讨了React的<em class="jt">声明性</em>本质以及这给习惯于编写<em class="jt">过程化</em>代码(比如纯JavaScript和CSS)的程序员带来的挫败感。JavaScript和CSS通常从头到尾都以一种(相对)简单的方式运行，但是React……并不像那样运行(这是重点)。因此，像<code class="du lc ld le lf b">styled-components</code>这样的各种工具已经被开发出来，通过允许开发人员定义和使用CSS片段作为模板或模块来弥合这一差距，就像React对JavaScript和HTML所做的那样。CSS-in-JS不是一个单独的库或包，而是这种模块化方法以及为实现它而创建的思想和代码包的统称。</p><p id="0a40" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">首先，我将在我们的<code class="du lc ld le lf b">Die</code>组件的顶部运行<code class="du lc ld le lf b">yarn add styled-components</code>(或<code class="du lc ld le lf b">npm install --save styled-components</code>)和<code class="du lc ld le lf b">import</code>，这基本上只是一个骰子正面的SVG:</p><pre class="ky kz la lb fd lg lf lh li aw lj bi"><span id="ce6f" class="lk jv hi lf b fi ll lm l ln lo">import styled from "styled-components";</span><span id="28c3" class="lk jv hi lf b fi lp lm l ln lo">export default function Die( { number } ) {<br/>   return &lt;svg className="die"&gt;<br/>      ...<br/>   &lt;/svg&gt;;<br/>}</span></pre><p id="555e" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">接下来，我将用我刚刚导入的<code class="du lc ld le lf b">styled</code>模板替换我们的<code class="du lc ld le lf b">svg</code>标签，并将其应用于<code class="du lc ld le lf b">svg</code>，使用我希望应用于反勾号的样式:</p><pre class="ky kz la lb fd lg lf lh li aw lj bi"><span id="2367" class="lk jv hi lf b fi ll lm l ln lo">import styled from "styled-components";</span><span id="ec07" class="lk jv hi lf b fi lp lm l ln lo"><strong class="lf hj">const DieSvg = styled.svg`<br/>   position: absolute;<br/>   top: ${ props =&gt; props.randomX }%;<br/>   left: ${ props =&gt; props.randomY }%;<br/>   animation: ${ dieAnimation( props =&gt; props.randomY ) } 0.5s linear;<br/>`;</strong></span><span id="3bd6" class="lk jv hi lf b fi lp lm l ln lo">export default function Die( { number } ) {<br/>   return &lt;<strong class="lf hj">DieSvg</strong> className="die"&gt;<br/>      ...<br/>   &lt;/<strong class="lf hj">DieSvg</strong>&gt;;<br/>}</span></pre><p id="fc14" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">请特别注意两件事:</p><ol class=""><li id="f09a" class="lq lr hi iw b ix iy jb jc jf ls jj lt jn lu jr lv lw lx ly bi translated"><strong class="iw hj">我在定义</strong> <code class="du lc ld le lf b"><strong class="iw hj">DieSvg</strong></code> <strong class="iw hj"> <em class="jt">外</em>我们的</strong> <code class="du lc ld le lf b"><strong class="iw hj">Die</strong></code> <strong class="iw hj">分量！如果我不这样做，React将会在每次我们的<code class="du lc ld le lf b">Die</code>重新渲染时创建一个新的<code class="du lc ld le lf b">DieSvg</code>。这不会破坏你的代码，但是这是低效和多余的，并且<code class="du lc ld le lf b">styled-components</code>会在你的控制台中相应地抱怨。</strong></li><li id="4f2d" class="lq lr hi iw b ix lz jb ma jf mb jj mc jn md jr lv lw lx ly bi translated"><strong class="iw hj">我在用回调函数调用</strong> <code class="du lc ld le lf b"><strong class="iw hj">props</strong></code> <strong class="iw hj">！</strong>试图用<code class="du lc ld le lf b">randomX</code>甚至<code class="du lc ld le lf b">props.randomX</code>直接调用它们<em class="jt">不会</em>起作用。</li></ol><p id="4b01" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">最后，我将把<code class="du lc ld le lf b">randomX</code>和<code class="du lc ld le lf b">randomY</code>作为<code class="du lc ld le lf b">props</code>添加到<code class="du lc ld le lf b">Die</code>和<code class="du lc ld le lf b">DieSvg</code>中:</p><pre class="ky kz la lb fd lg lf lh li aw lj bi"><span id="fd43" class="lk jv hi lf b fi ll lm l ln lo">...<br/>export default function Die( { number, <strong class="lf hj">randomX, randomY</strong> } ) {<br/>   return &lt;DieSvg className="die" <strong class="lf hj">randomX={ randomX } randomY={ randomY }</strong>&gt;<br/>      ...<br/>   &lt;/DieSvg&gt;;<br/>}</span></pre><h1 id="30dc" class="ju jv hi bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">每个人都得到rannn-dom</h1><p id="629b" class="pw-post-body-paragraph iu iv hi iw b ix ks iz ja jb kt jd je jf ku jh ji jj kv jl jm jn kw jp jq jr hb bi translated">我们的<code class="du lc ld le lf b">Die</code>组件现在准备好接受一个<code class="du lc ld le lf b">randomX</code>和<code class="du lc ld le lf b">randomY</code>，所以它将出现在屏幕上的一个随机位置。现在到了困难的部分:动画他们如何真正到达那里！幸运的是，<code class="du lc ld le lf b">styled-components</code>在纯CSS中有一个与<code class="du lc ld le lf b">@keyframes</code>规则相对应的规则，我们将对其使用do:</p><pre class="ky kz la lb fd lg lf lh li aw lj bi"><span id="5910" class="lk jv hi lf b fi ll lm l ln lo">import styled<strong class="lf hj">, { keyframes }</strong> from "styled-components";</span><span id="636b" class="lk jv hi lf b fi lp lm l ln lo"><strong class="lf hj">const dieAnimation = randomY =&gt; keyframes`<br/>   0% {<br/>      top: 110%;<br/>      left: 50%;<br/>   }<br/>   50% {<br/>      top: 0%;<br/>      left: ${ randomY / 2 }%;<br/>      transform: rotate( 360deg );<br/>   }<br/>   100% { transform: rotate( 0deg ); }<br/>`;</strong></span><span id="980b" class="lk jv hi lf b fi lp lm l ln lo">const DieSvg = styled.svg`<br/>   ...<br/>`;</span></pre><p id="2d09" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">请再次注意，<strong class="iw hj">整个</strong> <code class="du lc ld le lf b"><strong class="iw hj">dieAnimation</strong></code> <strong class="iw hj">被包裹在一个回调中，以获取它需要的</strong> <code class="du lc ld le lf b"><strong class="iw hj">props</strong></code> <strong class="iw hj">！</strong>再来一遍:<em class="jt">不要试图直接叫</em><code class="du lc ld le lf b"><em class="jt">props</em></code><em class="jt"/>不然你会很难受。</p><p id="5f2b" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">现在我们已经在<code class="du lc ld le lf b">dieAnimation</code>中定义了<code class="du lc ld le lf b">keyframes</code>，让我们的<code class="du lc ld le lf b">DieSvg</code>实际使用它:</p><pre class="ky kz la lb fd lg lf lh li aw lj bi"><span id="3258" class="lk jv hi lf b fi ll lm l ln lo">const DieSvg = styled.svg`<br/>   position: absolute;<br/>   top: ${ props =&gt; props.randomX }%;<br/>   left: ${ props =&gt; props.randomY }%;<br/>   <strong class="lf hj">animation: ${ dieAnimation( props =&gt; props.randomY ) } 0.5s linear;</strong><br/>`;</span></pre><p id="c889" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">我们现在将<em class="jt">作为函数调用</em> <code class="du lc ld le lf b">dieAnimation()</code>，将<code class="du lc ld le lf b">props =&gt; props.randomY</code>作为回调传入，并且还指定它是一个运行时为<code class="du lc ld le lf b">0.5s</code>的<code class="du lc ld le lf b">linear</code>动画，就像我们在纯CSS中一样。</p><p id="18b7" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">现在是时候把这一切结合在一起了！我将编写一个新的React组件，<code class="du lc ld le lf b">Dice</code>，在屏幕上一次显示三个骰子，并显示我们移山倒海编写的新动画:</p><pre class="ky kz la lb fd lg lf lh li aw lj bi"><span id="1d94" class="lk jv hi lf b fi ll lm l ln lo">import Die from "./Die";</span><span id="6de9" class="lk jv hi lf b fi lp lm l ln lo">export default function Dice( { roll } ) {</span><span id="b556" class="lk jv hi lf b fi lp lm l ln lo">const randomX = [ Math.floor( ( Math.random() * 25 ) + 5 ), Math.floor( ( Math.random() * 25 ) + 5 ), Math.floor( ( Math.random() * 25 ) + 5 ) ];</span><span id="289c" class="lk jv hi lf b fi lp lm l ln lo">const randomY = [ Math.floor( ( Math.random() * 25 ) + 5 ), Math.floor( ( Math.random() * 25 ) + 5 ), Math.floor( ( Math.random() * 25 ) + 5 ) ];</span><span id="3017" class="lk jv hi lf b fi lp lm l ln lo">   return &lt;div&gt;<br/>      &lt;Die number={ roll[ 0 ] } randomX={ randomX[ 0 ] } randomY={ randomY[ 0 ] } /&gt;<br/>      &lt;Die number={ roll[ 1 ] } randomX={ randomX[ 1 ] } randomY={ randomY[ 1 ] } /&gt;<br/>      &lt;Die number={ roll[ 2 ] } randomX={ randomX[ 2 ] } randomY={ randomY[ 2 ] } /&gt;<br/>   &lt;/div&gt;;</span><span id="06d6" class="lk jv hi lf b fi lp lm l ln lo">}</span></pre><p id="2fdf" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">这个组件接受一个<code class="du lc ld le lf b">roll</code>，一个由1到6之间的三个随机数组成的数组，作为它的<code class="du lc ld le lf b">props</code>的一部分。然后它定义了两个数组，每个数组都有实际的实数<code class="du lc ld le lf b">Math.random()</code>随机数，而<em class="jt">不是</em>随机的总统，并返回一个<code class="du lc ld le lf b">&lt;div&gt;</code>，里面有我们动画<code class="du lc ld le lf b">Die</code>的三个副本——每个副本都在屏幕上不同的随机位置结束！</p><p id="ae9f" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><a class="ae js" href="https://github.com/josh-frank/cee-lo" rel="noopener ugc nofollow" target="_blank">派生并克隆链接的库</a>，在终端运行<code class="du lc ld le lf b">yarn start</code>或<code class="du lc ld le lf b">npm start</code>，你会看到结果。</p><h1 id="8acc" class="ju jv hi bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">结论</h1><p id="6346" class="pw-post-body-paragraph iu iv hi iw b ix ks iz ja jb kt jd je jf ku jh ji jj kv jl jm jn kw jp jq jr hb bi translated">在我的演示中，您可能会注意到骰子偶尔会重叠，这显然不是真正的骰子的行为方式。这暗示了模拟真实世界随机性的困难之一——物理比计算机代码复杂和微妙得多。与运动学角力，让你的应用逼真是一个巨大的挑战，只有你可以征服——但我希望这个简短的教程给你信心，抓住机会，掷骰子！</p></div></div>    
</body>
</html>