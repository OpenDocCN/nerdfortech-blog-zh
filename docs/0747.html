<html>
<head>
<title>Leave transaction control to the client</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">将事务控制留给客户端</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/leave-transaction-control-to-the-client-ea6009348f37?source=collection_archive---------6-----------------------#2021-02-10">https://medium.com/nerd-for-tech/leave-transaction-control-to-the-client-ea6009348f37?source=collection_archive---------6-----------------------#2021-02-10</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="628d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">每个领域最终都会遇到这种情况。业务操作需要维护给定模型上两个或更多实体之间的不变量。如何在不弄乱模型的情况下完成它？哪个组件应该负责确保这一点？</p><p id="42cd" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">例如，假设您的域有成员和他们写的故事，每个配置文件应该显示成员发布的故事数量。团队决定向成员实体添加一个“storiesWrittenCount ”,以避免对故事集合的额外查询。</p><p id="ffd0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">满足这种情况的第一个天真尝试是:</p><pre class="jd je jf jg fd jh ji jj jk aw jl bi"><span id="a09e" class="jm jn hi ji b fi jo jp l jq jr">WriteStoryUseCase(story, member) {<br/>  storyRepo.create(story)<br/>  member.storiesWrittenCount++<br/>  memberRepo.update(member)<br/>}</span></pre><p id="10bf" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">使用这种方法，在成功创建故事后，存在成员更新失败的风险，破坏了故事计数不变量。</p><p id="ca5c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在过去，我用三种不同的方式解决了在两个或更多实体之间提供事务支持的挑战</p></div><div class="ab cl js jt gp ju" role="separator"><span class="jv bw bk jw jx jy"/><span class="jv bw bk jw jx jy"/><span class="jv bw bk jw jx"/></div><div class="hb hc hd he hf"><h2 id="c55c" class="jm jn hi bd jz ka kb kc kd ke kf kg kh iq ki kj kk iu kl km kn iy ko kp kq kr bi translated">选项1:忽略它</h2><p id="aa8e" class="pw-post-body-paragraph if ig hi ih b ii ks ik il im kt io ip iq ku is it iu kv iw ix iy kw ja jb jc hb bi translated">风险低，冲刺晚了。你不会想在复古版里再讨论一次关于故事指向的问题。</p><h2 id="4f42" class="jm jn hi bd jz ka kb kc kd ke kf kg kh iq ki kj kk iu kl km kn iy ko kp kq kr bi translated">选项2:将事务实现泄露给域</h2><pre class="jd je jf jg fd jh ji jj jk aw jl bi"><span id="4452" class="jm jn hi ji b fi jo jp l jq jr">WriteStoryUseCase(story, member) {<br/>  MongoClient client = ...<br/>  ClientSession clientSession = client.startSession()</span><span id="2c4c" class="jm jn hi ji b fi kx jp l jq jr"><em class="ky">  ...create story and update member...</em></span><span id="16f4" class="jm jn hi ji b fi kx jp l jq jr">  clientSession.withTransaction(...)<br/>}</span></pre><p id="ce5c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">此时，您的域依赖于您的基础层(本例中为<em class="ky"> Mongo </em>)，不再是“干净的”</p><h2 id="879f" class="jm jn hi bd jz ka kb kc kd ke kf kg kh iq ki kj kk iu kl km kn iy ko kp kq kr bi translated">选项3:创建一个“StoryMemberRepo”</h2><pre class="jd je jf jg fd jh ji jj jk aw jl bi"><span id="619d" class="jm jn hi ji b fi jo jp l jq jr">WriteStoryUseCase(story, member) {<br/>  storyMemberRepo.writeStoryAndUpdateMember(story, member)<br/>}</span></pre><p id="9e35" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这里我们避免了数据库依赖，但是，这些存储库混合了概念，您的代码库可能会以一个<em class="ky"> MemberRepo </em>、一个<em class="ky"> StoryRepo </em>、一个<em class="ky"> StoryMemberRepo </em>、一个<em class="ky">StoryMemberNotificationRepo</em>等结束。现在已经不清楚在哪里可以找到功能，这导致了开发人员的困惑和可能的代码重复。</p></div><div class="ab cl js jt gp ju" role="separator"><span class="jv bw bk jw jx jy"/><span class="jv bw bk jw jx jy"/><span class="jv bw bk jw jx"/></div><div class="hb hc hd he hf"><h1 id="2fe0" class="kz jn hi bd jz la lb lc kd ld le lf kh lg lh li kk lj lk ll kn lm ln lo kq lp bi translated">另一种选择</h1><p id="4d13" class="pw-post-body-paragraph if ig hi ih b ii ks ik il im kt io ip iq ku is it iu kv iw ix iy kw ja jb jc hb bi translated">当我在阅读<a class="ae lq" href="https://www.oreilly.com/library/view/domain-driven-design-tackling/0321125215/" rel="noopener ugc nofollow" target="_blank">领域驱动设计</a>的时候，一个特别的句子引起了我的注意并让我思考:<strong class="ih hj"> <em class="ky">“把事务控制留给客户。”</em>T15】</strong></p><p id="8a24" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> <em class="ky">把域中的事务概念抽象出来，让客户端发起并提交工作单元怎么样？</em>T19】</strong></p><h2 id="a922" class="jm jn hi bd jz ka kb kc kd ke kf kg kh iq ki kj kk iu kl km kn iy ko kp kq kr bi translated">敬代码！</h2><p id="551e" class="pw-post-body-paragraph if ig hi ih b ii ks ik il im kt io ip iq ku is it iu kv iw ix iy kw ja jb jc hb bi translated">Kotlin和Mongo是首选技术，你可以在<a class="ae lq" href="https://github.com/SenhorCastor/leave-transaction-control-to-the-client" rel="noopener ugc nofollow" target="_blank"> Github </a>查看完整的例子。</p><p id="855a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我定义了<em class="ky">事务:</em></p><pre class="jd je jf jg fd jh ji jj jk aw jl bi"><span id="df54" class="jm jn hi ji b fi jo jp l jq jr">interface Transaction {<br/>  fun start()<br/>  fun commit()<br/>}</span></pre><p id="dfbf" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">而它的<em class="ky"> Mongo </em>表示:</p><pre class="jd je jf jg fd jh ji jj jk aw jl bi"><span id="f2be" class="jm jn hi ji b fi jo jp l jq jr">class TransactionMongo private constructor(...) : Transaction {<br/><strong class="ji hj">  </strong>private lateinit var session: ClientSession<br/><br/>  override fun start() {<br/>    session = client.startSession()<br/>    session.startTransaction()<br/>  }<br/><br/>  override fun commit() {<br/>    try {<br/>      session.commitTransaction()<br/>    } catch (e: Exception) {<br/>      session.abortTransaction()<br/>      throw TransactionAbortedException(e);<br/>    } finally {<br/>      session.close()<br/>    }<br/>  }<br/>}</span></pre><p id="5012" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在<em class="ky">回购</em>中保存<em class="ky">实体</em>的每个功能接收一个可选的<em class="ky">事务</em>作为输入，并返回一个<em class="ky">事务</em>:</p><pre class="jd je jf jg fd jh ji jj jk aw jl bi"><span id="3166" class="jm jn hi ji b fi jo jp l jq jr">interface MemberRepo {<br/>  fun save(member: Member, tr: Transaction? = null): Transaction<br/>}</span></pre><p id="89fd" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">随着其实施:</p><pre class="jd je jf jg fd jh ji jj jk aw jl bi"><span id="589c" class="jm jn hi ji b fi jo jp l jq jr">class UserRepoMongo(private val mongoClient: MongoClient) : UserRepo {<br/>  override fun save(user: User, tr: Transaction?): Transaction {</span><span id="fe13" class="jm jn hi ji b fi kx jp l jq jr">    val transactionUsed = mongoClient.getTransaction(tr)<br/>    collection.save(transactionUsed.session(), user)</span><span id="0e3d" class="jm jn hi ji b fi kx jp l jq jr">    return transactionUsed<br/>  }<br/>}</span></pre><p id="f491" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为了简单起见，我给<em class="ky"> MongoClient </em>添加了一个扩展函数:</p><pre class="jd je jf jg fd jh ji jj jk aw jl bi"><span id="9221" class="jm jn hi ji b fi jo jp l jq jr">fun MongoClient.getTransaction(tr: Transaction?): TransactionMongo {<br/>  return if (transaction == null) {<br/>    val newTransaction = TransactionMongo.create(this)<br/>    newTransaction.start()<br/>    return newTransaction<br/>  } else {<br/>    transaction as TransactionMongo<br/>  }<br/>}</span></pre><p id="4fea" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">最后，我的用例是这样的:</p><pre class="jd je jf jg fd jh ji jj jk aw jl bi"><span id="073e" class="jm jn hi ji b fi jo jp l jq jr">WriteStoryUseCase(story: Story, member: Member) {<br/>  val tr = storyRepo.save(story);<br/>  val memberUpdated = member.incrementStoriesWrittenCount()<br/>  val trAfterSave =  memberRepo.save(memberUpdated, tr)<br/>  trAfterSave.commit()<br/>}</span></pre><p id="3904" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">使用这种方法，域中的数据库没有依赖性。此外，这两个实体没有混淆概念。</p><p id="4ff9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">增加的复杂性是，现在模型需要处理一个新的概念<em class="ky">事务。</em>这将提交工作单元的责任转移给了模型，这在设计上是一个合理的想法。</p><p id="3b11" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">最后，如果领域需要从许多用例中创建故事，那么您可以使用一个服务来完成这项工作，并且可以在您的模型中共享。</p></div><div class="ab cl js jt gp ju" role="separator"><span class="jv bw bk jw jx jy"/><span class="jv bw bk jw jx jy"/><span class="jv bw bk jw jx"/></div><div class="hb hc hd he hf"><h1 id="0ab9" class="kz jn hi bd jz la lb lc kd ld le lf kh lg lh li kk lj lk ll kn lm ln lo kq lp bi translated">模型</h1><p id="056e" class="pw-post-body-paragraph if ig hi ih b ii ks ik il im kt io ip iq ku is it iu kv iw ix iy kw ja jb jc hb bi translated">让我们来看看用来解决这个例子的模型(<a class="ae lq" href="https://github.com/SenhorCastor/leave-transaction-control-to-the-client" rel="noopener ugc nofollow" target="_blank"> Github </a>)。</p><figure class="jd je jf jg fd ls er es paragraph-image"><div role="button" tabindex="0" class="lt lu di lv bf lw"><div class="er es lr"><img src="../Images/8055ad5e6e4fb05c08f2653fa78dc31d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LGH78bK7_UOOYeF90wqrSQ.jpeg"/></div></div></figure><p id="f7da" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">应用程序层拥有全局访问权来控制流程和执行依赖注入。</p><p id="40f5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Repos和事务层包含实现内层中定义的不同实体和存储库所需的细节。在这种特殊情况下，<em class="ky">蒙戈</em>。</p><p id="c10c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">用例是实际业务逻辑所在的地方，即<em class="ky">“领域层”</em></p><p id="be19" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">下面是该示例的主要组件的UML图:</p><p id="0cf8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">您可以看到用例如何只能访问实体和接口回购；细节注入App层。</p><figure class="jd je jf jg fd ls er es paragraph-image"><div role="button" tabindex="0" class="lt lu di lv bf lw"><div class="er es lz"><img src="../Images/d9c74d6dc33666e557cdd99baedfc0d9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*njv-Ng5PVlmgLEctQh2N7g.jpeg"/></div></div></figure></div><div class="ab cl js jt gp ju" role="separator"><span class="jv bw bk jw jx jy"/><span class="jv bw bk jw jx jy"/><span class="jv bw bk jw jx"/></div><div class="hb hc hd he hf"><p id="b5d4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">目前就这些了。感谢您的阅读！这是我的第一个媒体故事——希望你喜欢。</p><p id="3a1f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">您可以在<a class="ae lq" rel="noopener" href="/@fernandoamartin"> Medium </a>、<a class="ae lq" href="https://twitter.com/Fer_A_Martin" rel="noopener ugc nofollow" target="_blank"> Twitter </a>和<a class="ae lq" href="https://www.linkedin.com/in/fernandoamartin/" rel="noopener ugc nofollow" target="_blank"> Linkedin </a>上关注我，在那里我将分享我在软件开发、工程管理等方面的想法和经验。</p></div></div>    
</body>
</html>