<html>
<head>
<title>Implement your own Promises in JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用JavaScript实现你自己的承诺</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/implement-your-own-promises-in-javascript-68ddaa6a5409?source=collection_archive---------2-----------------------#2021-04-11">https://medium.com/nerd-for-tech/implement-your-own-promises-in-javascript-68ddaa6a5409?source=collection_archive---------2-----------------------#2021-04-11</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><figure class="hh hi ez fb hj hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es hg"><img src="../Images/f647edf9748495392f469292b391519a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*lPGYhjrc0D7Plw_H"/></div></div><figcaption class="hr hs et er es ht hu bd b be z dx translated">照片由<a class="ae hv" href="https://unsplash.com/@kar111?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">郭佳欣·阿维蒂斯扬</a>在<a class="ae hv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><div class=""/><p id="6370" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">Promises是JavaScript中最基本的概念之一，我们都在应用程序中多次使用过，但是我们能实现自己的Promise API吗？别担心，它没有看起来那么复杂。在这篇文章中，我们将自己实现一个基本的Promise API。</p><h2 id="dc84" class="ju jv hy bd jw jx jy jz ka kb kc kd ke jg kf kg kh jk ki kj kk jo kl km kn ko bi translated">什么是承诺？</h2><blockquote class="kp kq kr"><p id="eba8" class="iv iw jt ix b iy iz ja jb jc jd je jf ks jh ji jj kt jl jm jn ku jp jq jr js hb bi translated"><a class="ae hv" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise" rel="noopener ugc nofollow" target="_blank"> <strong class="ix hz"> Promise </strong> </a>对象表示异步操作的最终完成(或失败)及其结果值。</p></blockquote><p id="cfbc" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">它可以处于以下三种状态之一:</p><ul class=""><li id="8d37" class="kv kw hy ix b iy iz jc jd jg kx jk ky jo kz js la lb lc ld bi translated">挂起，操作正在进行时的初始状态</li><li id="21d4" class="kv kw hy ix b iy le jc lf jg lg jk lh jo li js la lb lc ld bi translated">履行，定义操作成功</li><li id="660f" class="kv kw hy ix b iy le jc lf jg lg jk lh jo li js la lb lc ld bi translated">拒绝，表示操作失败</li></ul><blockquote class="kp kq kr"><p id="70d1" class="iv iw jt ix b iy iz ja jb jc jd je jf ks jh ji jj kt jl jm jn ku jp jq jr js hb bi translated"><strong class="ix hz">注</strong>:当一个承诺被履行或拒绝时，就说这个承诺被<strong class="ix hz">解决了</strong>。(我们将在本文中大量使用这个术语)</p></blockquote><h2 id="dd59" class="ju jv hy bd jw jx jy jz ka kb kc kd ke jg kf kg kh jk ki kj kk jo kl km kn ko bi translated">你如何使用承诺？</h2><p id="414a" class="pw-post-body-paragraph iv iw hy ix b iy lj ja jb jc lk je jf jg ll ji jj jk lm jm jn jo ln jq jr js hb bi translated">对于实现承诺，让我们首先看看它的框架，本质上是它接受的输入，以及它公开的方法。</p><p id="e0cf" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">它有一个接受回调的构造函数，以及像then、catch和finally这样的方法。</p><figure class="lo lp lq lr fd hk"><div class="bz dy l di"><div class="ls lt l"/></div><figcaption class="hr hs et er es ht hu bd b be z dx translated">使用JavaScript Promise</figcaption></figure></div><div class="ab cl lu lv gp lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="hb hc hd he hf"><h1 id="ed11" class="mb jv hy bd jw mc md me ka mf mg mh ke mi mj mk kh ml mm mn kk mo mp mq kn mr bi translated">1.定义骨架</h1><p id="ccda" class="pw-post-body-paragraph iv iw hy ix b iy lj ja jb jc lk je jf jg ll ji jj jk lm jm jn jo ln jq jr js hb bi translated">我们首先定义我们的承诺类<strong class="ix hz"> MyPromise </strong>。</p><h2 id="2a49" class="ju jv hy bd jw jx jy jz ka kb kc kd ke jg kf kg kh jk ki kj kk jo kl km kn ko bi translated">以下属性在构造函数中定义:</h2><ol class=""><li id="472b" class="kv kw hy ix b iy lj jc lk jg ms jk mt jo mu js mv lb lc ld bi translated"><code class="du mw mx my mz b">state </code>:可以是<code class="du mw mx my mz b">PENDING</code>、<code class="du mw mx my mz b">FULFILLED</code>或<code class="du mw mx my mz b">REJECTED</code></li><li id="dd6d" class="kv kw hy ix b iy le jc lf jg lg jk lh jo li js mv lb lc ld bi translated"><code class="du mw mx my mz b">handlers</code>:存储then、catch、finally方法的回调。<em class="jt">(处理程序只有在承诺完成时才会执行。)</em></li><li id="5edb" class="kv kw hy ix b iy le jc lf jg lg jk lh jo li js mv lb lc ld bi translated"><code class="du mw mx my mz b">value</code>:解析或拒绝值。</li></ol><p id="bdcd" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hz"/></p><figure class="lo lp lq lr fd hk"><div class="bz dy l di"><div class="ls lt l"/></div><figcaption class="hr hs et er es ht hu bd b be z dx translated">我的承诺骨架</figcaption></figure></div><div class="ab cl lu lv gp lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="hb hc hd he hf"><h1 id="2d52" class="mb jv hy bd jw mc md me ka mf mg mh ke mi mj mk kh ml mm mn kk mo mp mq kn mr bi translated">2._resolve()和_reject()方法实现</h1><p id="cd4b" class="pw-post-body-paragraph iv iw hy ix b iy lj ja jb jc lk je jf jg ll ji jj jk lm jm jn jo ln jq jr js hb bi translated"><code class="du mw mx my mz b">_resolve()</code>或<code class="du mw mx my mz b">_reject()</code>分别将承诺的<code class="du mw mx my mz b">state</code>设置为<code class="du mw mx my mz b">FULFILLED </code>或<code class="du mw mx my mz b">REJECTED </code>，更新<code class="du mw mx my mz b">value</code>属性并执行附带的处理程序。</p><blockquote class="kp kq kr"><p id="8716" class="iv iw jt ix b iy iz ja jb jc jd je jf ks jh ji jj kt jl jm jn ku jp jq jr js hb bi translated"><strong class="ix hz">注意</strong>:如果我们试图就一个已经达成的承诺给<code class="du mw mx my mz b">_resolve()</code>或<code class="du mw mx my mz b">_reject()</code>打电话，什么也不会发生。</p></blockquote><figure class="lo lp lq lr fd hk"><div class="bz dy l di"><div class="ls lt l"/></div></figure><p id="fba7" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">想知道上面代码中的<code class="du mw mx my mz b">isThenable(value)</code>是什么？</p><p id="a1ff" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">对于一个承诺被另一个承诺解决/拒绝的情况，我们必须等待它完成，然后处理我们当前的承诺。</p><h2 id="6086" class="ju jv hy bd jw jx jy jz ka kb kc kd ke jg kf kg kh jk ki kj kk jo kl km kn ko bi translated">isThenable()函数实现</h2><p id="c81e" class="pw-post-body-paragraph iv iw hy ix b iy lj ja jb jc lk je jf jg ll ji jj jk lm jm jn jo ln jq jr js hb bi translated">一个<code class="du mw mx my mz b">isThenable </code>函数检查value是一个<code class="du mw mx my mz b">MyPromise</code>的实例还是一个包含<code class="du mw mx my mz b">then</code>函数的对象。</p><figure class="lo lp lq lr fd hk"><div class="bz dy l di"><div class="ls lt l"/></div></figure></div><div class="ab cl lu lv gp lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="hb hc hd he hf"><h1 id="d334" class="mb jv hy bd jw mc md me ka mf mg mh ke mi mj mk kh ml mm mn kk mo mp mq kn mr bi translated">3.然后()方法<strong class="ak">实现</strong></h1><p id="94b8" class="pw-post-body-paragraph iv iw hy ix b iy lj ja jb jc lk je jf jg ll ji jj jk lm jm jn jo ln jq jr js hb bi translated"><code class="du mw mx my mz b">then()</code> <strong class="ix hz"> </strong>方法以两个参数作为回调<code class="du mw mx my mz b">onSuccess</code>和<code class="du mw mx my mz b">onFail</code>。<code class="du mw mx my mz b">onSuccess</code> <strong class="ix hz"> </strong>在承诺兑现时调用，而<code class="du mw mx my mz b">onFail</code> <strong class="ix hz"> </strong>在承诺被拒绝时调用。</p><blockquote class="kp kq kr"><p id="4b87" class="iv iw jt ix b iy iz ja jb jc jd je jf ks jh ji jj kt jl jm jn ku jp jq jr js hb bi translated"><strong class="ix hz">“记住承诺是可以被锁链锁住的”。</strong></p><p id="5c31" class="iv iw jt ix b iy iz ja jb jc jd je jf ks jh ji jj kt jl jm jn ku jp jq jr js hb bi translated"><strong class="ix hz">承诺链接</strong>的本质是<code class="du mw mx my mz b">then()</code>方法返回一个<strong class="ix hz">新的承诺</strong>对象<strong class="ix hz">。承诺就是这样被锁住的。这在我们需要连续执行两个或更多异步操作的场景中特别有用，其中每个后续操作在前一个操作成功时开始，并带有前一个步骤的结果。</strong></p></blockquote><p id="4bf8" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">传递给<code class="du mw mx my mz b">then()</code>的回调使用<code class="du mw mx my mz b">addHandlers</code>函数存储在<code class="du mw mx my mz b">handlers</code>数组中。处理程序是一个对象<code class="du mw mx my mz b">{onSuccess, onFail}</code>,当一个承诺完成时，它将被执行。</p><p id="e7dd" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们对<code class="du mw mx my mz b">then()</code>的实现如下所示:</p><figure class="lo lp lq lr fd hk"><div class="bz dy l di"><div class="ls lt l"/></div><figcaption class="hr hs et er es ht hu bd b be z dx translated">然后是功能实现</figcaption></figure></div><div class="ab cl lu lv gp lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="hb hc hd he hf"><h1 id="4f28" class="mb jv hy bd jw mc md me ka mf mg mh ke mi mj mk kh ml mm mn kk mo mp mq kn mr bi translated">4.catch()方法实现</h1><p id="e7cb" class="pw-post-body-paragraph iv iw hy ix b iy lj ja jb jc lk je jf jg ll ji jj jk lm jm jn jo ln jq jr js hb bi translated"><code class="du mw mx my mz b"><strong class="ix hz"><em class="jt">catch()</em></strong></code> <strong class="ix hz"> <em class="jt">是利用</em> </strong> <code class="du mw mx my mz b"><strong class="ix hz"><em class="jt">then()</em></strong></code> <em class="jt">实现的。</em>我们调用<code class="du mw mx my mz b">then()</code>方法，将<code class="du mw mx my mz b">onSuccess</code>回调作为<code class="du mw mx my mz b">null</code>，并将<code class="du mw mx my mz b">onFail</code>回调作为第二个参数传递。</p><figure class="lo lp lq lr fd hk"><div class="bz dy l di"><div class="ls lt l"/></div></figure></div><div class="ab cl lu lv gp lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="hb hc hd he hf"><h1 id="6ef0" class="mb jv hy bd jw mc md me ka mf mg mh ke mi mj mk kh ml mm mn kk mo mp mq kn mr bi translated"><strong class="ak"> 5。finally()方法实现</strong></h1><p id="0df1" class="pw-post-body-paragraph iv iw hy ix b iy lj ja jb jc lk je jf jg ll ji jj jk lm jm jn jo ln jq jr js hb bi translated">在我们开始实施<code class="du mw mx my mz b">finally()</code>方法之前，让我们先了解它的行为<em class="jt">(我自己也花了一些时间来理解)</em>。</p><p id="21d6" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">来自MDN文档:</p><blockquote class="kp kq kr"><p id="d8ad" class="iv iw jt ix b iy iz ja jb jc jd je jf ks jh ji jj kt jl jm jn ku jp jq jr js hb bi translated"><code class="du mw mx my mz b">finally()</code>方法返回一个<code class="du mw mx my mz b"><a class="ae hv" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise" rel="noopener ugc nofollow" target="_blank">Promise</a></code>。当承诺完成时，即履行或拒绝时，执行指定的回调函数。这为代码提供了一种运行方式，无论承诺是成功实现还是在处理完<code class="du mw mx my mz b">Promise</code>后被拒绝。</p><p id="d482" class="iv iw jt ix b iy iz ja jb jc jd je jf ks jh ji jj kt jl jm jn ku jp jq jr js hb bi translated"><code class="du mw mx my mz b">finally()</code>方法与调用<code class="du mw mx my mz b">.then(onFinally, onFinally)</code>非常相似，但是有一些不同之处:</p><p id="788a" class="iv iw jt ix b iy iz ja jb jc jd je jf ks jh ji jj kt jl jm jn ku jp jq jr js hb bi translated">当内联创建一个函数时，您可以传递它一次，而不是被迫声明它两次，或者为它创建一个变量</p><p id="561d" class="iv iw jt ix b iy iz ja jb jc jd je jf ks jh ji jj kt jl jm jn ku jp jq jr js hb bi translated">与<code class="du mw mx my mz b">Promise.resolve(2).then(() =&gt; {}, () =&gt; {})</code>(将用<code class="du mw mx my mz b">undefined</code>解析)不同，<code class="du mw mx my mz b">Promise.resolve(2).finally(() =&gt; {})</code>将用<code class="du mw mx my mz b">2</code>解析。</p><p id="6a04" class="iv iw jt ix b iy iz ja jb jc jd je jf ks jh ji jj kt jl jm jn ku jp jq jr js hb bi translated">同样，与<code class="du mw mx my mz b">Promise.reject(3).then(() =&gt; {}, () =&gt; {})</code>(将用<code class="du mw mx my mz b">undefined</code>)不同，<code class="du mw mx my mz b">Promise.reject(3).finally(() =&gt; {})</code>将用<code class="du mw mx my mz b">3</code>拒绝。</p></blockquote><p id="f1cd" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><code class="du mw mx my mz b">finally()</code>方法返回一个承诺，该承诺将用以前的<code class="du mw mx my mz b">fulfilled</code>或<code class="du mw mx my mz b">rejected</code>值进行结算。</p><figure class="lo lp lq lr fd hk"><div class="bz dy l di"><div class="ls lt l"/></div></figure><h2 id="4eda" class="ju jv hy bd jw jx jy jz ka kb kc kd ke jg kf kg kh jk ki kj kk jo kl km kn ko bi translated">摘要</h2><p id="62f4" class="pw-post-body-paragraph iv iw hy ix b iy lj ja jb jc lk je jf jg ll ji jj jk lm jm jn jo ln jq jr js hb bi translated">我们模仿承诺的基本实现。除了作为实例方法的<code class="du mw mx my mz b">then()</code>、<code class="du mw mx my mz b">catch()</code>、<code class="du mw mx my mz b">finally()</code>方法之外，还有很多其他的方法。还有一些静态方法，我会在以后的文章中介绍。</p><p id="5899" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我希望你喜欢这篇文章。</p><p id="ea7d" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">点击查看<a class="ae hv" href="https://codepen.io/mayank_shubham/pen/abpEVJK?editors=0012" rel="noopener ugc nofollow" target="_blank"> Codepen上的完整代码。</a></p></div></div>    
</body>
</html>