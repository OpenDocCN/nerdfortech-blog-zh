<html>
<head>
<title>Decoupling Binding</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">解耦绑定</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/decoupling-binding-57566dc7b17d?source=collection_archive---------6-----------------------#2021-03-06">https://medium.com/nerd-for-tech/decoupling-binding-57566dc7b17d?source=collection_archive---------6-----------------------#2021-03-06</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="1dc4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这是系列文章的一部分。目标、基础、项目结构、文章摘要见 <a class="ae je" href="https://sites.google.com/view/migueltt/home_en" rel="noopener ugc nofollow" target="_blank"> <em class="jd"> Android::简体</em> </a></p><p id="e6f5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><a class="ae je" href="https://developer.android.com/jetpack/compose" rel="noopener ugc nofollow" target="_blank"> Jetpack Compose </a>正在测试中！(截至 2021 年 3 月)</p><p id="b502" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">知识库:<a class="ae je" href="https://gitlab.com/migueltt/simpleandroid" rel="noopener ugc nofollow" target="_blank">https://gitlab.com/migueltt/simpleandroid</a></p></div><div class="ab cl jf jg gp jh" role="separator"><span class="ji bw bk jj jk jl"/><span class="ji bw bk jj jk jl"/><span class="ji bw bk jj jk"/></div><div class="hb hc hd he hf"><p id="8455" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如今，现代的 Android 应用程序很容易构建——也就是说，如果你遵循 Android 架构组件指南的话。如果你遵循这些原则，事情会变得更简单:</p><ul class=""><li id="2324" class="jm jn hi ih b ii ij im in iq jo iu jp iy jq jc jr js jt ju bi translated">一个<code class="du jv jw jx jy b">Activity</code>或<code class="du jv jw jx jy b">Fragment</code>只是 Android 系统、视图(布局)和视图模型的粘合剂</li><li id="e34d" class="jm jn hi ih b ii jz im ka iq kb iu kc iy kd jc jr js jt ju bi translated">将所有与 UI 相关的代码重构为扩展函数</li><li id="5e81" class="jm jn hi ih b ii jz im ka iq kb iu kc iy kd jc jr js jt ju bi translated">不要在您的<code class="du jv jw jx jy b">Fragment</code>中创建协程——视图模型应该是唯一启动协程的模型——主要原因是协程应该遵循视图模型生命周期</li><li id="1eda" class="jm jn hi ih b ii jz im ka iq kb iu kc iy kd jc jr js jt ju bi translated">您可以在<code class="du jv jw jx jy b">Activity</code>、<code class="du jv jw jx jy b">navigation-graph</code>和<code class="du jv jw jx jy b">Fragment</code>级别定义视图模型——这使得数据共享和协程行为变得更加容易</li></ul><p id="28e3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">主要目标是拥有这样的架构:</p><figure class="kf kg kh ki fd kj er es paragraph-image"><div role="button" tabindex="0" class="kk kl di km bf kn"><div class="er es ke"><img src="../Images/d24dab60637d8a2836a55588aad95071.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RCMtazUIEOYNO7xJjM3xeA.png"/></div></div></figure><p id="97f8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">首先，</strong> XML 布局包含了所有的 UI 设计(直到 Jetpack Compose 最终投入生产)——遵循通用的命名约定:<code class="du jv jw jx jy b"><a class="ae je" href="https://gitlab.com/migueltt/simpleandroid/-/blob/develop/app/src/debug/res/layout/fragment_test_main.xml" rel="noopener ugc nofollow" target="_blank">fragment_test_main.xml</a></code></p><ul class=""><li id="f15a" class="jm jn hi ih b ii ij im in iq jo iu jp iy jq jc jr js jt ju bi translated">在 XML 布局中，仅当您需要引用变量时，才使用<em class="jd">数据绑定</em><strong class="ih hj">——否则，<strong class="ih hj">不使用</strong>标签，而使用<em class="jd">视图绑定— </em>确保您的应用程序<code class="du jv jw jx jy b"><a class="ae je" href="https://gitlab.com/migueltt/simpleandroid/-/blob/develop/app/build.gradle" rel="noopener ugc nofollow" target="_blank">build.gradle</a></code>文件指定:</strong></li></ul><pre class="kf kg kh ki fd kq jy kr ks aw kt bi"><span id="a118" class="ku kv hi jy b fi kw kx l ky kz">buildFeatures <strong class="jy hj">{<br/>    </strong>viewBinding true<br/>    dataBinding true<br/><strong class="jy hj">}</strong></span></pre><ul class=""><li id="4fef" class="jm jn hi ih b ii ij im in iq jo iu jp iy jq jc jr js jt ju bi translated">请记住，无论何时使用<code class="du jv jw jx jy b">&lt;layout&gt;..&lt;/layout&gt;</code>，您都在添加大量代码来同步数据如何绑定到您的布局中——如果您真的不需要它，只需使用<strong class="ih hj"> <em class="jd">视图绑定</em> </strong> <em class="jd"> —顺便说一句:</em> <strong class="ih hj"> <em class="jd">不要使用</em> </strong> <em class="jd"> </em> <code class="du jv jw jx jy b"><em class="jd">findViewById(..)</em></code> <em class="jd">或 kotlin 合成 id。</em></li></ul><p id="3058" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">其次，</strong>用同样的惯例给相关的<code class="du jv jw jx jy b">Fragment</code>命名:<code class="du jv jw jx jy b"><a class="ae je" href="https://gitlab.com/migueltt/simpleandroid/-/blob/develop/app/src/debug/java/com/simpleandroid/modules/testui/FragmentTestMain.kt" rel="noopener ugc nofollow" target="_blank">FragmentTestMain</a></code>——是的，有点打破常规…</p><p id="0deb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">第三个</strong>，创建一个<code class="du jv jw jx jy b"><a class="ae je" href="https://gitlab.com/migueltt/simpleandroid/-/blob/develop/app/src/debug/java/com/simpleandroid/modules/testui/FragmentTestMainBindingExt.kt" rel="noopener ugc nofollow" target="_blank">FragmentTestMainBindingExt</a></code>文件——这将包括扩展函数，将所有 UI 相关代码从<code class="du jv jw jx jy b">Fragment</code>中解耦出来:</p><ul class=""><li id="c8c4" class="jm jn hi ih b ii ij im in iq jo iu jp iy jq jc jr js jt ju bi translated">当使用<em class="jd">数据绑定</em>或<em class="jd">视图绑定</em>时，会为您的 XML 布局生成一个类——它恰好遵循<code class="du jv jw jx jy b">&lt;xml-filename&gt;Binding</code>约定，这就是我们将<code class="du jv jw jx jy b">FragmentTestMain</code>命名为<code class="du jv jw jx jy b">Fragment</code>的原因——这样您的所有文件都很容易识别</li><li id="9c42" class="jm jn hi ih b ii jz im ka iq kb iu kc iy kd jc jr js jt ju bi translated">在这个<code class="du jv jw jx jy b"><a class="ae je" href="https://gitlab.com/migueltt/simpleandroid/-/blob/develop/app/src/debug/java/com/simpleandroid/modules/testui/FragmentTestMainBindingExt.kt" rel="noopener ugc nofollow" target="_blank">FragmentTestMainBindingExt</a></code>文件中，开始添加与绑定类相关的扩展函数</li></ul><p id="1bca" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">第四个</strong>，在你的<code class="du jv jw jx jy b">FragmentTestMain</code>中总是使用生成的<em class="jd">绑定类</em>的扩展函数:</p><pre class="kf kg kh ki fd kq jy kr ks aw kt bi"><span id="3095" class="ku kv hi jy b fi kw kx l ky kz">// Your traditional FragmentTestMain.kt file<br/>package com.simpleandroid.modules.testui<br/><br/>import android.os.Bundle<br/>import android.view.LayoutInflater<br/>import android.view.View<br/>import android.view.ViewGroup<br/>import androidx.fragment.app.Fragment<br/>import androidx.fragment.app.viewModels<br/>import com.simpleandroid.databinding.FragmentTestMainBinding<br/><br/>class FragmentTestMain : Fragment() {<br/><br/>    private lateinit var binder: FragmentTestMainBinding<br/>    private val viewModel: TestViewModel by viewModels()</span><span id="e5d8" class="ku kv hi jy b fi la kx l ky kz">    override fun onCreateView(<br/>        inflater: LayoutInflater,<br/>        container: ViewGroup?,<br/>        savedInstanceState: Bundle?<br/>    ): View =<br/>        FragmentTestMainBinding.inflate(<br/>            inflater, container, false<br/>        ).<em class="jd">apply </em><strong class="jy hj">{<br/>            </strong>binder = this<br/>        <strong class="jy hj">}</strong>.<em class="jd">root<br/><br/>    </em>override fun onViewCreated(<br/>        view: View, savedInstanceState: Bundle?<br/>    ) {<br/>        super.onViewCreated(view, savedInstanceState)<br/>        binder.<em class="jd">setup</em>(this)<br/>        viewModel.sample.observe(<em class="jd">viewLifecycleOwner</em>)<strong class="jy hj"> {<br/>            </strong>// do something<br/>        <strong class="jy hj">}<br/></strong>    }<br/>}</span><span id="a246" class="ku kv hi jy b fi la kx l ky kz">class TestViewModel : ViewModel() {<br/>    val _sample = MutableLiveData("test")<br/>    val sample: LiveData&lt;String&gt; = _sample<br/>}</span></pre><p id="03b1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在另一文件中:</p><pre class="kf kg kh ki fd kq jy kr ks aw kt bi"><span id="118c" class="ku kv hi jy b fi kw kx l ky kz">// Decouple binding here: FragmentTestMainBindingExt.kt<br/>package com.simpleandroid.modules.testui<br/><br/>import androidx.activity.addCallback<br/>import androidx.core.view.GravityCompat<br/>import androidx.fragment.app.Fragment<br/>import androidx.navigation.fragment.NavHostFragment<br/>import androidx.navigation.fragment.findNavController<br/>import com.simpleandroid.R<br/>import com.simpleandroid.databinding.FragmentTestMainBinding<br/>import com.simpleandroid.ui.setupWithNavControllerExt<br/><br/>fun FragmentTestMainBinding.setup(<br/>    fragment: Fragment<br/>) {<br/>   //reference all UI components through the binding<br/>   :<br/>}</span></pre><p id="ea7f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这将所有与 UI 相关的代码从<code class="du jv jw jx jy b">Fragment</code>本身解耦，并且<em class="jd">从视图模型中观察</em> <code class="du jv jw jx jy b">LiveData</code>。就这样，没有什么需要添加到<code class="du jv jw jx jy b">Fragment</code>中的了——它支持开箱即用的配置更改。</p><p id="163b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">对于某些边缘情况可能有例外:</p><ul class=""><li id="4ba6" class="jm jn hi ih b ii ij im in iq jo iu jp iy jq jc jr js jt ju bi translated">在背压上处理自定义<em class="jd">——始终使用<code class="du jv jw jx jy b">onBackPressedDispatcher</code></em></li><li id="844b" class="jm jn hi ih b ii jz im ka iq kb iu kc iy kd jc jr js jt ju bi translated">处理<code class="du jv jw jx jy b">Toolbar (top, bottom)</code>、<code class="du jv jw jx jy b">Drawer</code>、<code class="du jv jw jx jy b">FloatingActionButton</code>时的具体代码——要解决这个问题，查看<a class="ae je" href="https://miguelt.medium.com/ux-policies-bbbb432dc5fc" rel="noopener"> UX 政策系列</a></li></ul><p id="cdaa" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">通过遵循这些原则，在 Jetpack Compose 上进行迁移将变得更加容易，因为您的所有 UI 都已经与<code class="du jv jw jx jy b">Fragment</code>解耦了。</p></div></div>    
</body>
</html>