<html>
<head>
<title>Visualizing the player health</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">可视化玩家健康</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/visualizing-the-player-health-f70252304d45?source=collection_archive---------17-----------------------#2021-04-24">https://medium.com/nerd-for-tech/visualizing-the-player-health-f70252304d45?source=collection_archive---------17-----------------------#2021-04-24</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="a290" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">在它结束之前我能承受多少打击？</h2></div><p id="34f0" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们现在有了完全正常工作的评分系统。UI 的第一部分完成了！太好了！现在让我们来看看 UI 的第二部分，玩家生活！</p></div><div class="ab cl ju jv gp jw" role="separator"><span class="jx bw bk jy jz ka"/><span class="jx bw bk jy jz ka"/><span class="jx bw bk jy jz"/></div><div class="hb hc hd he hf"><p id="6ae9" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="iz hj">创建 UI 元素</strong> <br/>我们从分数文本框开始同样的过程，我们创建 UI 元素！</p><ul class=""><li id="6f05" class="kb kc hi iz b ja jb jd je jg kd jk ke jo kf js kg kh ki kj bi translated"><em class="kk">右键单击层级中的画布&gt; UI &gt;图像</em></li></ul><p id="1f69" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这样做就会呈现给你这个白色方块:<br/> <em class="kk">别着急！这是正常的，因为我们还没有向 Unity 提供任何关于图像的信息。正方形只是一个占位符。</em></p><figure class="km kn ko kp fd kq er es paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="er es kl"><img src="../Images/e677152be223b171c74b32ae60959d4c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iYxk0imLSdvDflSoX7fyXQ.png"/></div></div><figcaption class="kx ky et er es kz la bd b be z dx translated">刚刚创建的图像组件！</figcaption></figure><p id="60c5" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">把它移到你认为合适的地方！我会把它放在左上角。</p></div><div class="ab cl ju jv gp jw" role="separator"><span class="jx bw bk jy jz ka"/><span class="jx bw bk jy jz ka"/><span class="jx bw bk jy jz"/></div><div class="hb hc hd he hf"><p id="aa9f" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="iz hj">分配目标图像<br/> </strong>为了显示实际的精灵而不是白盒，我们只需要为 Unity 提供一个源图像来显示。只需将文件从项目视图拖到检查器的“源图像”区域。你选择哪一幅图像并不重要。</p><figure class="km kn ko kp fd kq er es paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="er es lb"><img src="../Images/b4ce577dba1082ede25399456a1207c1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*fOuGo7DBtg5gfHRV4qqxeg.gif"/></div></div><figcaption class="kx ky et er es kz la bd b be z dx translated">指定源图像文件</figcaption></figure></div><div class="ab cl ju jv gp jw" role="separator"><span class="jx bw bk jy jz ka"/><span class="jx bw bk jy jz ka"/><span class="jx bw bk jy jz"/></div><div class="hb hc hd he hf"><p id="7075" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="iz hj">修复图像的怪异外观<br/> </strong>你可能已经注意到，图像看起来确实很怪异，而且是压在一起的。这是因为图像填满了图像游戏对象的整个空间。要解决这个问题，只需在检查器中单击图像组件内的复选框“<em class="kk">保留特征”</em>。</p><ul class=""><li id="3306" class="kb kc hi iz b ja jb jd je jg kd jk ke jo kf js kg kh ki kj bi translated">点击 lives_img &gt;在检查器中查找图像组件&gt;检查<em class="kk">保留特征</em></li></ul><figure class="km kn ko kp fd kq er es paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="er es lc"><img src="../Images/7d9c76a66753570d4058b20618dfd10b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*9lexkhoaF-4ORBwc6edHFw.gif"/></div></div><figcaption class="kx ky et er es kz la bd b be z dx translated">固定目标图像的纵横比！</figcaption></figure><p id="9730" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">不要忘记将枢轴点更改为左上方的<em class="kk"/>,以避免其他屏幕上的生活显示位置错误，这可能与您的屏幕不同！</p></div><div class="ab cl ju jv gp jw" role="separator"><span class="jx bw bk jy jz ka"/><span class="jx bw bk jy jz ka"/><span class="jx bw bk jy jz"/></div><div class="hb hc hd he hf"><p id="b027" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">用代码让它工作！做完所有这些，我们现在有了游戏中的指示器。然而，这个图像只是静态的，并不代表玩家仍然拥有的真实生活。要解决这个问题，我们需要通过代码实现逻辑。让我们从声明变量开始吧！</p><ul class=""><li id="0c7d" class="kb kc hi iz b ja jb jd je jg kd jk ke jo kf js kg kh ki kj bi translated">我们需要一个对图像组件的引用，以便交换精灵来表示当前的生活。因此，我们需要一个<em class="kk">类型的变量 Image </em>。</li><li id="2c6d" class="kb kc hi iz b ja ld jd le jg lf jk lg jo lh js kg kh ki kj bi translated">我们可以有四种生活状态。三，二，一，零。因此，我们需要的不仅仅是一个雪碧。我们可以用一个类型为<em class="kk"> Sprite </em>的数组轻松解决这个问题。</li><li id="f217" class="kb kc hi iz b ja ld jd le jg lf jk lg jo lh js kg kh ki kj bi translated">为了让检查器中的脚本更加整洁，让我们添加一个<em class="kk">头。</em></li></ul><p id="b36f" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这是你刚刚读到的代码:</p><figure class="km kn ko kp fd kq er es paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="er es li"><img src="../Images/2440cd289399acde8f3d3ea0d60d45d0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*k3Lza6ET0KvCVL34Q4NpSQ.png"/></div></div></figure><p id="0ba0" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们需要一个函数来切换出代表当前生活的精灵。</p><ul class=""><li id="4267" class="kb kc hi iz b ja jb jd je jg kd jk ke jo kf js kg kh ki kj bi translated">创建一个新的<em class="kk">公共</em>函数，该函数需要传回一个返回当前生命数量的变量</li><li id="22fe" class="kb kc hi iz b ja ld jd le jg lf jk lg jo lh js kg kh ki kj bi translated">我们希望根据玩家当前的生活更新图像的精灵。相应的精灵存储在我们刚刚创建的数组中。让我们访问它的索引来显示正确的精灵！</li><li id="6ccf" class="kb kc hi iz b ja ld jd le jg lf jk lg jo lh js kg kh ki kj bi translated">为了微妙地通知玩家只剩下一条命，我们可以改变图像的颜色。</li></ul><figure class="km kn ko kp fd kq er es paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="er es lj"><img src="../Images/2a455c6c2d8f93f7befb4db3d7378508.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sIOXLCqzFfIkitBkx8vMCw.png"/></div></div></figure><p id="8bd3" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">当前生命存储在<em class="kk"> Player.cs </em>脚本中。由于 UIManager 需要这些信息，我们必须在播放器脚本中创建 UIManager 的句柄。</p><ul class=""><li id="6b4a" class="kb kc hi iz b ja jb jd je jg kd jk ke jo kf js kg kh ki kj bi translated">创建 UIManager 类型的变量</li><li id="3389" class="kb kc hi iz b ja ld jd le jg lf jk lg jo lh js kg kh ki kj bi translated">找到组件并访问 UIManager 脚本</li><li id="e9bc" class="kb kc hi iz b ja ld jd le jg lf jk lg jo lh js kg kh ki kj bi translated">不要忘记空检查！</li></ul><figure class="km kn ko kp fd kq er es paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="er es lk"><img src="../Images/6087b3c7b4e005c3e0d27680118af077.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GYdV8Pon-p8qDqZNG4KdSQ.png"/></div></div></figure><p id="e09a" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">还记得我们在 UIManager 脚本中创建了一个公共函数吗？我们有这个函数，但是它不知道何时更新代表生命的精灵。</p><ul class=""><li id="53b5" class="kb kc hi iz b ja jb jd je jg kd jk ke jo kf js kg kh ki kj bi translated">调用<em class="kk"> _uiManager。更新玩家伤害函数中的 Lives() </em>方法，并放弃<em class="kk"> _lives </em>变量</li><li id="1274" class="kb kc hi iz b ja ld jd le jg lf jk lg jo lh js kg kh ki kj bi translated">根据你之前在分配目标图像时选择的精灵，我们也应该在<em class="kk"> void Start() </em>中调用这个函数。这将确保精灵将在游戏开始时更新为三个生命，不管选择的精灵是什么。<br/> <em class="kk">如果你没有这样做，并且你选择了“一个”或“两个”精灵作为源图像，这将在你开始游戏时发生:</em></li></ul><figure class="km kn ko kp fd kq er es paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="er es kl"><img src="../Images/1fbcb494724b202df405330130ed7a76.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*gLr8rRTy6m65vzsBr7SqBw.gif"/></div></div></figure><p id="3286" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如果这一切都完成了，<em class="kk"> Player.cs </em>的<em class="kk"> Damage() </em>方法看起来会是这样的:</p><figure class="km kn ko kp fd kq er es paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="er es ll"><img src="../Images/089897078957c681f399e0f14e4a269a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mtwT9-UpsfocVbjI3LDbHQ.png"/></div></div></figure></div><div class="ab cl ju jv gp jw" role="separator"><span class="jx bw bk jy jz ka"/><span class="jx bw bk jy jz ka"/><span class="jx bw bk jy jz"/></div><div class="hb hc hd he hf"><p id="ebe3" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">就是这样！现在，实时可视化正在按预期工作，玩家知道在“游戏结束”之前，这艘船还能承受多少打击时间！</p><p id="b0c1" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">接下来是游戏结束通知。敬请期待！</p></div></div>    
</body>
</html>