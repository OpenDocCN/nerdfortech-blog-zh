<html>
<head>
<title>May 20: Removing duplicates from a JavaScript array of non-primitives (without lodash!)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">5 月 20 日:从非原语的 JavaScript 数组中删除重复项(没有 lodash！)</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/may-20-removing-duplicates-from-a-javascript-array-of-non-primitives-without-lodash-c71e57251ee9?source=collection_archive---------23-----------------------#2021-05-20">https://medium.com/nerd-for-tech/may-20-removing-duplicates-from-a-javascript-array-of-non-primitives-without-lodash-c71e57251ee9?source=collection_archive---------23-----------------------#2021-05-20</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/9ae00fd34c577c2ddc471e950f8779bf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*TI3KJzjX7azSr0pfOv-P6w.gif"/></div></div></figure><p id="509a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">啊，不起眼的<strong class="is hj">阵！这是 JavaScript 数据结构的瑞士军刀:没什么特别的，但是它确实做到了它在罐子上说的。数组是将变量和值组合在一起的一种便捷方式，理解数组对于使用 web APIs 至关重要。</strong></p><p id="af1c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">但不幸的是，像 JavaScript 中的其他东西一样，数组有很多限制、怪癖和警告——有效地使用它们需要聪明的思维和 MacGyver 式的变通方法。特别是，<strong class="is hj">过滤非原始重复项</strong>是<strong class="is hj"> </strong>一个常见的数组问题，几乎是无处不在的采访主题。例如，如果我将客户的邮件列表作为一个数组来处理，我可能不希望在我的地址数组中出现重复的收件人。也许我的客户是阿尔·帕西诺在《T21》中扮演的角色，他坚持让我在没有像<a class="ae jp" href="https://lodash.com/" rel="noopener ugc nofollow" target="_blank"> lodash </a>这样的外部库的情况下工作。</p><p id="a777" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">因为我在职业生涯和个人项目中遇到过这个问题，所以让我们探索一些方法吧！</p><h1 id="3f78" class="jq jr hi bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">背景:原始爱情</h1><p id="1caa" class="pw-post-body-paragraph iq ir hi is b it ko iv iw ix kp iz ja jb kq jd je jf kr jh ji jj ks jl jm jn hb bi translated">在 JavaScript 中，<strong class="is hj">原语</strong>是<strong class="is hj">四个 Ts 之一，</strong>代表<em class="jo">文本</em>，一个<em class="jo">总计，</em>一个<em class="jo">真值</em>或<em class="jo">无类型:</em></p><ul class=""><li id="72d7" class="kt ku hi is b it iu ix iy jb kv jf kw jj kx jn ky kz la lb bi translated"><strong class="is hj">文字:</strong>一个字符，<code class="du lc ld le lf b">'c'</code>，或者一个<code class="du lc ld le lf b">'string'</code>；</li><li id="03a3" class="kt ku hi is b it lg ix lh jb li jf lj jj lk jn ky kz la lb bi translated"><strong class="is hj">总计:</strong>一个<code class="du lc ld le lf b">Number()</code>像<code class="du lc ld le lf b">3</code>或者<code class="du lc ld le lf b">3.14</code>或者<code class="du lc ld le lf b">0b11</code>；</li><li id="fc7f" class="kt ku hi is b it lg ix lh jb li jf lj jj lk jn ky kz la lb bi translated"><strong class="is hj">真相:</strong> a <code class="du lc ld le lf b">Boolean()</code> ( <code class="du lc ld le lf b">true</code>或<code class="du lc ld le lf b">false</code>)</li><li id="a168" class="kt ku hi is b it lg ix lh jb li jf lj jj lk jn ky kz la lb bi translated"><strong class="is hj">无类型:</strong> <code class="du lc ld le lf b">undefined</code>、<code class="du lc ld le lf b">null</code>或<code class="du lc ld le lf b">NaN</code></li></ul><p id="3a87" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">四个 t 的相关定义和区别特征是<strong class="is hj">严格</strong> <strong class="is hj">可比性:</strong>两个图元如果具有严格相同的值，则它们相等；</p><pre class="ll lm ln lo fd lp lf lq lr aw ls bi"><span id="9643" class="lt jr hi lf b fi lu lv l lw lx">1 === 1;<br/>   &gt; true<br/>'primitive' === 'primitive';<br/>   &gt; true<br/>false === false;<br/>   &gt; true</span></pre><p id="6bc9" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">因为像<code class="du lc ld le lf b">includes()</code>和<code class="du lc ld le lf b">indexOf()</code>这样的<code class="du lc ld le lf b">Array</code>方法依赖于严格的可比性，所以原语的这种属性使得从数组中过滤它们的副本变得相对容易:</p><pre class="ll lm ln lo fd lp lf lq lr aw ls bi"><span id="e375" class="lt jr hi lf b fi lu lv l lw lx">function filterPrimitiveDuplicates( array ) {<br/>   return array.filter( ( element, index ) =&gt; {<br/>      return !array.slice( 0, index ).includes( element );<br/>   } );<br/>}</span><span id="cf17" class="lt jr hi lf b fi ly lv l lw lx">filterPrimitiveDuplicates( [ 5, 4, 5, 2, 5 ] )<br/>   &gt; [ 5, 4, 2 ]<br/>filterPrimitiveDuplicates( "there is no there there".split( " " ) )<br/>   &gt; [ 'there', 'is', 'no' ]</span></pre><p id="4d4b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">JavaScript 工具包中还有另一个相对较新的依赖于严格相等的特性:<a class="ae jp" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Set" rel="noopener ugc nofollow" target="_blank"> <strong class="is hj">集合</strong> </a> <strong class="is hj">。一个 JavaScript 是一个严格唯一值的非索引集合，就像一个 T21 数学集合一样。大多数浏览器都支持快速的<code class="du lc ld le lf b">Set()</code> s，我们可以在函数中利用它们的唯一性约束来<code class="du lc ld le lf b">filterPrimitiveDuplicates()</code>，就像上面的函数一样:</strong></p><pre class="ll lm ln lo fd lp lf lq lr aw ls bi"><span id="ea8e" class="lt jr hi lf b fi lu lv l lw lx">function filterPrimitiveDuplicates( array ) {<br/>   return [ ...new Set( array ) ];<br/>}</span></pre><p id="b1a6" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">要去除原始副本，我们所要做的就是将我们的<code class="du lc ld le lf b">array</code>变成一个<code class="du lc ld le lf b">Set()</code>，然后将其展开回到一个数组中！这可能很难相信，但是在一个数组和一个<code class="du lc ld le lf b">Set()</code>之间来回转换比遍历一个<code class="du lc ld le lf b">array</code>的<code class="du lc ld le lf b">element</code>并将它们与<code class="du lc ld le lf b">includes()</code>进行比较要稍微快一点(<a class="ae jp" href="https://jsben.ch/5c9EW" rel="noopener ugc nofollow" target="_blank">大约 25% </a>)。</p><h1 id="bbe1" class="jq jr hi bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">回归原始</h1><p id="5463" class="pw-post-body-paragraph iq ir hi is b it ko iv iw ix kp iz ja jb kq jd je jf kr jh ji jj ks jl jm jn hb bi translated">不幸的是，对于我们的 Advil 预算来说，<strong class="is hj">非原语</strong>如数组和对象<strong class="is hj">是不可比的。</strong>如果两个数组在内存中有不同的地址，那么即使它们的值完全相同，顺序也完全相同，它们也不完全相等。</p><pre class="ll lm ln lo fd lp lf lq lr aw ls bi"><span id="10b1" class="lt jr hi lf b fi lu lv l lw lx">[ 5 ] === [ 5 ];<br/>   &gt; false           // ugh<br/>[ 1, 2 ] == [ 1, 2 ];<br/>   &gt; false           // yuck</span></pre><p id="f2ac" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这适用于<code class="du lc ld le lf b">Set()</code>、<code class="du lc ld le lf b">includes()</code>和<code class="du lc ld le lf b">indexOf()</code>，就像它适用于十二等分和三等分一样:</p><pre class="ll lm ln lo fd lp lf lq lr aw ls bi"><span id="c2c9" class="lt jr hi lf b fi lu lv l lw lx">const arrayOfNonPrimitives = [ [ 1, 2 ], [ 3, 4 ], [ 5, 6 ], [ 1, 2 ] ];</span><span id="8949" class="lt jr hi lf b fi ly lv l lw lx">new Set( arrayOfNonPrimitives ) ;<br/>   &gt; Set(4) { [ 1, 2 ], [ 3, 4 ], [ 5, 6 ], [ 1, 2 ] } // fail<br/>arrayOfNonPrimitives.includes( [ 1, 2 ] );<br/>   &gt; false                                             // awful<br/>arrayOfNonPrimitives.indexOf( [ 1, 2 ] );<br/>   &gt; -1                                                // my eyes</span></pre><p id="5a5d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">那么，如果元素不是严格可比的，我们如何从非基元数组中过滤出重复的元素呢？我们把它们转换成一个基本的数据类型怎么样?<em class="jo">和</em>是严格可比的——就像字符串一样？我已经知道这会变得很混乱…</p><h2 id="f21f" class="lt jr hi bd js lz ma mb jw mc md me ka jb mf mg ke jf mh mi ki jj mj mk km ml bi translated">将数组转换为字符串</h2><p id="9b13" class="pw-post-body-paragraph iq ir hi is b it ko iv iw ix kp iz ja jb kq jd je jf kr jh ji jj ks jl jm jn hb bi translated">JavaScript 的<code class="du lc ld le lf b">toString()</code>或<code class="du lc ld le lf b">join()</code>方法将很好地完成这项任务；当在数组上没有参数的情况下调用时，要么产生一个由逗号分隔的每个元素组成的字符串——而<em class="jo">这些</em>字符串，<em class="jo">与</em>具有可比性:</p><pre class="ll lm ln lo fd lp lf lq lr aw ls bi"><span id="132a" class="lt jr hi lf b fi lu lv l lw lx">[ 1, 2, 3 ].join();<br/>   &gt; '1,2,3'<br/>[ 1, 2, 3 ].toString();<br/>   &gt; '1,2,3'<br/>[ 1, 2, 3 ].toString() === [ 1, 2, 3 ].join();<br/>   &gt; true</span></pre><p id="f193" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">让我们像以前一样过滤，但添加一些铸造:</p><pre class="ll lm ln lo fd lp lf lq lr aw ls bi"><span id="8665" class="lt jr hi lf b fi lu lv l lw lx">function filterArrayDuplicates( array ) {<br/>   return array.filter( ( element, index ) =&gt; {<br/>      return !array.slice( 0, index ).join().includes( element.join() );<br/>   } );<br/>}</span><span id="48f5" class="lt jr hi lf b fi ly lv l lw lx">filterArrayDuplicates( [ [ 1, 2 ], [ 3, 4 ], [ 1, 2 ] ] );<br/>   &gt; [ [ 1, 2 ], [ 3, 4 ] ]           // hallelujah</span></pre><p id="5d9f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">同样的想法也适用于我们的方法，其中包含图形内容，可能不适合年轻读者:</p><pre class="ll lm ln lo fd lp lf lq lr aw ls bi"><span id="43ef" class="lt jr hi lf b fi lu lv l lw lx">function filterArrayDuplicates( array ) {<br/>   return [ ...new Set( array.map( element =&gt; element.join() ) ) ].map( element =&gt; element.split( "," ).map( element =&gt; parseInt( element ) ) );<br/>}</span></pre><p id="ebfe" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在<em class="jo">我</em>尖叫着跑进树林成为原始人之前，让我们把这个梳理成多行:</p><pre class="ll lm ln lo fd lp lf lq lr aw ls bi"><span id="ed35" class="lt jr hi lf b fi lu lv l lw lx">const castToString = element =&gt; element.join();</span><span id="0a1d" class="lt jr hi lf b fi ly lv l lw lx">const castToInteger = element =&gt; parseInt( element );</span><span id="6bf2" class="lt jr hi lf b fi ly lv l lw lx">const splitByCommasThenCastToInteger = element =&gt; element.split( "," ).map( castToInteger );</span><span id="24f6" class="lt jr hi lf b fi ly lv l lw lx">function filterArrayDuplicates( array ) {<br/>   const castEachElementToString = array.map( castToString );<br/>   const castToSetAndBackAgain = [ ...new Set( castEachElementToString ) ];<br/>   return castToSetAndBackAgain.map( splitByCommasThenCastToInteger );<br/>}</span></pre><p id="a88c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">当我预定义了所有那些讨厌的(但是重要的！)回调。首先，我用一个<code class="du lc ld le lf b">map()</code>函数<code class="du lc ld le lf b">castEachElementToString</code>；然后，我<code class="du lc ld le lf b">castToSetAndBackAgain</code>；最后，我使用另一个<code class="du lc ld le lf b">map()</code>函数来<code class="du lc ld le lf b">splitByCommasThenCastToInteger</code>。咻！</p><h2 id="26be" class="lt jr hi bd js lz ma mb jw mc md me ka jb mf mg ke jf mh mi ki jj mj mk km ml bi translated">将对象转换为字符串</h2><p id="022d" class="pw-post-body-paragraph iq ir hi is b it ko iv iw ix kp iz ja jb kq jd je jf kr jh ji jj ks jl jm jn hb bi translated">当我意识到<code class="du lc ld le lf b">toString()</code>和<code class="du lc ld le lf b">join()</code>将<em class="jo">而不是</em>作用于对象时，我活下去的意愿慢慢变得越来越弱——因为没有<code class="du lc ld le lf b">Object.join()</code>方法，并且<code class="du lc ld le lf b">Object</code> <code class="du lc ld le lf b">toString()</code>的默认转换是荒谬且无益的:</p><pre class="ll lm ln lo fd lp lf lq lr aw ls bi"><span id="421c" class="lt jr hi lf b fi lu lv l lw lx">{ one: 1, two: 2, three: 3 }.toString();<br/>   &gt; '[object Object]'           // what is this sorcery<br/>{ one: 1, two: 2, three: 3 }.join();<br/>   &gt; Uncaught: TypeError         // how could a merciful God do this</span></pre><figure class="ll lm ln lo fd ij er es paragraph-image"><div class="er es mm"><img src="../Images/ba03190aea56a942b0e521485ae2b49b.png" data-original-src="https://miro.medium.com/v2/resize:fit:472/format:webp/1*1nwzPJhCMDE_tGUN1qqRzw.png"/></div><figcaption class="mn mo et er es mp mq bd b be z dx translated">在[对象对象]打电话之前，一切都是娱乐和游戏</figcaption></figure><p id="2a04" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们需要发挥创造力，找到另一种方式来比较<code class="du lc ld le lf b">Object</code>的值，以正确确定它们是否包含相同的值。一种方法是<code class="du lc ld le lf b">JSON.stringify()</code>，它几乎肯定<em class="jo">不是</em>打算用于这样的用途，但仍然产生了一个<code class="du lc ld le lf b">Object</code>的可接受的原始版本:</p><pre class="ll lm ln lo fd lp lf lq lr aw ls bi"><span id="84c0" class="lt jr hi lf b fi lu lv l lw lx">JSON.stringify( { one: 1, two: 2, three: 3 } );<br/>   &gt; '{"one":1,"two":2,"three":3}'     // I guess that's better (?!)</span></pre><p id="f5fe" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><code class="du lc ld le lf b">JSON.stringify()</code>的唯一问题是，如果键/值对以不同的顺序插入，它将产生不同的结果，即使那些键/值对完全相同:</p><pre class="ll lm ln lo fd lp lf lq lr aw ls bi"><span id="c15b" class="lt jr hi lf b fi lu lv l lw lx">thisObject = { one: 1, two: 2, three: 3 };<br/>thatObject = { three: 3, two: 2, one: 1 };</span><span id="efdd" class="lt jr hi lf b fi ly lv l lw lx">JSON.stringify( thisObject );<br/>   &gt; '{"one":1,"two":2,"three":3}'<br/>JSON.stringify( thatObject );<br/>   &gt; '{"three":3,"two":2,"one":1}'<br/>JSON.stringify( thisObject ) === JSON.stringify( thatObject );<br/>   &gt; false                       // this is the life I've chosen</span></pre><p id="c19f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">为了解决这个歇斯底里和可笑的问题，我将使用两个<code class="du lc ld le lf b">Object</code>原型方法:<code class="du lc ld le lf b">Object.keys()</code>和<code class="du lc ld le lf b">Object.values()</code>。我们将把对象分割成它们的<code class="du lc ld le lf b">keys()</code>和<code class="du lc ld le lf b">values()</code>数组，然后<code class="du lc ld le lf b">sort()</code>并对每个<code class="du lc ld le lf b">toString()</code>进行造型。当这样做时，具有相同键/值对的两个对象将总是产生相同的结果，即使这些对是无序的:</p><pre class="ll lm ln lo fd lp lf lq lr aw ls bi"><span id="cfc4" class="lt jr hi lf b fi lu lv l lw lx">function compareObjects( thisObject, thatObject ) {<br/>   return Object.keys( thisObject ).sort().toString() === Object.keys( thatObject ).sort().toString() &amp;&amp; Object.values( thisObject ).sort().toString() === Object.values( thatObject ).sort().toString();<br/>}</span><span id="6a71" class="lt jr hi lf b fi ly lv l lw lx">compareObjects( thisObject, thatObject )<br/>   &gt; true                       // it's over, Mr. Frodo</span></pre><p id="2f5e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">记得我在上面解释过,<code class="du lc ld le lf b">Set()</code>依赖于其元素的可比性来加强其独特性。因为没有直接的方法可以有效地将对象转换为原语，同时保证其可比性，所以我们不能像上面那样使用<code class="du lc ld le lf b">Set()</code>。但是，我们<em class="jo">可以通过将我们的<code class="du lc ld le lf b">compareObjects()</code>方法与<code class="du lc ld le lf b">findIndex()</code>方法结合起来使用<code class="du lc ld le lf b">filter()</code>，后者返回数组中满足测试回调的第一个元素的索引:</em></p><pre class="ll lm ln lo fd lp lf lq lr aw ls bi"><span id="f943" class="lt jr hi lf b fi lu lv l lw lx">function compareObjects( thisObject, thatObject ) {<br/>   ...<br/>}</span><span id="9c4e" class="lt jr hi lf b fi ly lv l lw lx">function filterObjectDuplicates( array ) {<br/>   return array.filter( ( element, index ) =&gt; {<br/>      return index === array.findIndex( elementToCompare =&gt; compareObjects( element, elementToCompare ) );<br/>   } );<br/>}</span><span id="2542" class="lt jr hi lf b fi ly lv l lw lx">filterObjectDuplicates( [ { one: 1 }, { two: 2 }, { three: 3 }, { one: 1 } ] )<br/>   &gt; [ { one: 1 }, { two: 2 }, { three: 3 } ] // sweet victory</span></pre><h1 id="20e3" class="jq jr hi bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">结论:原始的感觉，原始的方式</h1><p id="995e" class="pw-post-body-paragraph iq ir hi is b it ko iv iw ix kp iz ja jb kq jd je jf kr jh ji jj ks jl jm jn hb bi translated">重要的是要注意，在我在上面的恐怖马戏团中使用的所有例子中，非原语数组元素<em class="jo">本身只包含原语。</em>在非原语中没有非原语的<strong class="is hj">嵌套</strong>，比如…</p><pre class="ll lm ln lo fd lp lf lq lr aw ls bi"><span id="28b8" class="lt jr hi lf b fi lu lv l lw lx">[<br/>  {<br/>    name: 'Josh',<br/>    languages: [ 'English', 'Spanish' ],<br/>    diet: { vegetarian: false, glutenFree: false }<br/>  },<br/>  {<br/>    name: 'Worf',<br/>    languages: [ 'English', 'Klingon' ],<br/>    diet: { vegetarian: false, glutenFree: true }<br/>  },<br/>]</span></pre><p id="f827" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">也没有任何<strong class="is hj">不规则的</strong>数组具有一种以上的数据类型:</p><pre class="ll lm ln lo fd lp lf lq lr aw ls bi"><span id="a612" class="lt jr hi lf b fi lu lv l lw lx">[ 56, null, true, { name: "Josh"}, 9.5, "Spanish" ]</span></pre><p id="2cc2" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">你的数组越不规则，嵌套越多，就越需要调整和绞尽脑汁来消除重复。只有你能决定如何最好地调整和处理边缘情况和不规则情况。请记住核心思想:<strong class="is hj">将元素转换为原语</strong>和<strong class="is hj">确保这些原语是严格的、唯一的可比较的！</strong></p></div></div>    
</body>
</html>