<html>
<head>
<title>C# Continue with Entity Framework Code Project — 2</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">C#继续实体框架代码项目— 2</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/c-continue-with-entity-framework-code-project-2-9ed21aaf34e6?source=collection_archive---------3-----------------------#2022-12-01">https://medium.com/nerd-for-tech/c-continue-with-entity-framework-code-project-2-9ed21aaf34e6?source=collection_archive---------3-----------------------#2022-12-01</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/06c807b77211c7c29f214d4292058f91.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xg0sfsvor0Tjs7WzSrH65A.png"/></div></div></figure><p id="3245" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这篇文章是第一篇文章的后续，所以如果你还没有阅读第一篇文章的话，请阅读第一篇。</p><p id="d841" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在其他文章中，我在歌曲表的控制器中有以下代码(不检查空值或错误，保持简短):</p><pre class="jp jq jr js fd jt ju jv bn jw jx bi"><span id="06ac" class="jy jz hi ju b be ka kb l kc kd">[Route("api/[controller]")]//this will determine the url to call the action<br/>[ApiController]<br/>public class SongsController : ControllerBase<br/>{<br/>  private APIDbContext _dbContext;<br/>  public SongsController(APIDbContext dbContext)<br/>  {<br/>   _dbContext = dbContext;<br/>  }  <br/><br/>  [HttpGet] //could just name it Get<br/>  public IEnumerable&lt;Song&gt; GetSongs()<br/>  {<br/>   return _dbContext.Songs;<br/>  }<br/><br/>  [HttpGet("{id}")] <br/>  public Song GetSong(int id)<br/>  {<br/>   return _dbContext.Songs.Find(id);<br/>  }<br/><br/>  //add FromBody to let it know that the data we need to add is coming <br/>  //from the body of the request.<br/>  [HttpPost]<br/>  public void PostSong([FromBody] Song song)<br/>  {<br/>   _dbContext.Songs.Add(song);<br/>   _dbContext.SaveChanges();<br/>  }<br/><br/>  [HttpPut("{Id}")]<br/>  public void PutSong(int id, [FromBody] Song song)<br/>  {<br/>   Song s = _dbContext.Songs.Find(id);<br/>   s.Title = song.Title;<br/>   s.Language= song.Language;<br/>   _dbContext.SaveChanges();<br/>  }<br/><br/>  [HttpDelete("{id}")]<br/>  public void Delete(int id)<br/>  {<br/>   Song s =_dbContext.Songs.Find(id);<br/>   _dbContext.Songs.Remove(s);<br/>   _dbContext.SaveChanges();<br/>  }<br/> }</span></pre><p id="ae3c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">请注意，在上面的代码中，方法不是异步的，这是可行的，但是，您也可以使用更高效的异步代码。</p><p id="5132" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如果我们想拥有异步方法，我们需要使用<code class="du ke kf kg ju b">async </code>和<code class="du ke kf kg ju b">await </code>关键字并返回<code class="du ke kf kg ju b">Task</code>或<code class="du ke kf kg ju b">Task&lt;T&gt;</code>。让我们一次看一个方法。还需要<code class="du ke kf kg ju b">using System.Threading.Tasks;</code></p><p id="00c9" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这个:</p><pre class="jp jq jr js fd jt ju jv bn jw jx bi"><span id="161b" class="jy jz hi ju b be ka kb l kc kd">[HttpGet] //could just name it Get<br/>public IEnumerable&lt;Song&gt; GetSongs()<br/>{<br/>   return _dbContext.Songs;<br/>}</span></pre><p id="bb1f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">变成这样(也将结果更改为 IActionResult，与异步更改无关):</p><pre class="jp jq jr js fd jt ju jv bn jw jx bi"><span id="91ce" class="jy jz hi ju b be ka kb l kc kd">public async Task&lt;IActionResult&gt; GetSongs()<br/>{<br/>   return StatusCode(StatusCodes.Status200OK, await _dbContext.Songs.ToListAsync());<br/>}</span></pre><p id="8d64" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">类似地，代码的其余部分将像这样更改(注意，返回类型将取决于您想要返回的内容，这只是一个指南):</p><pre class="jp jq jr js fd jt ju jv bn jw jx bi"><span id="a3ff" class="jy jz hi ju b be ka kb l kc kd">[HttpGet("{id}")] //could just name it Get<br/>public async Task&lt;Song&gt; GetSong(int id)<br/>{<br/>   return await _dbContext.Songs.FindAsync(id);<br/>}<br/><br/>//add FromBody to let it know that the data we need to add is coming from the body of the request.<br/>[HttpPost]<br/>public async Task&lt;IActionResult&gt; PostSong([FromBody] Song song)<br/>{<br/>  await _dbContext.Songs.AddAsync(song);<br/>  await _dbContext.SaveChangesAsync();<br/>  return StatusCode(StatusCodes.Status201Created);<br/>}<br/><br/>[HttpPut("{Id}")]<br/>public async Task&lt;IActionResult&gt; PutSong(int id, [FromBody] Song song)<br/>{<br/>   Song s = await _dbContext.Songs.FindAsync(id);<br/>   s.Title = song.Title;<br/>   s.Language= song.Language;<br/>   _dbContext.SaveChanges();<br/>   return StatusCode(StatusCodes.Status202Accepted);<br/>}<br/><br/>[HttpDelete("{id}")]<br/>public async Task&lt;IActionResult&gt; Delete(int id)<br/>{<br/>   Song s = await _dbContext.Songs.FindAsync(id);<br/>   _dbContext.Songs.Remove(s);<br/>   await  _dbContext.SaveChangesAsync();<br/>   return StatusCode(StatusCodes.Status200OK);<br/>}</span></pre><p id="b9b5" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">注意这里没有 RemoveAsync。</p><h1 id="e89b" class="kh jz hi bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld bi translated">当代码不那么简单时</h1><p id="a5c9" class="pw-post-body-paragraph iq ir hi is b it le iv iw ix lf iz ja jb lg jd je jf lh jh ji jj li jl jm jn hb bi translated">我们的代码非常短，部分原因是我们什么都不检查，而且也不涉及业务逻辑。通常不会是那样的。最好有一些额外的文件来处理这个问题。这些文件将是存储库和它们的接口。在这种情况下你会。</p><figure class="jp jq jr js fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lj"><img src="../Images/aca9c6cee3c94e4afaa7a0d32e9d12a5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Um2_wuf6jfazK9FUcpYC3g.png"/></div></div></figure><p id="2d1a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">该接口及其相关类将基于每个表。每个表仍然有它的控制器。</p><p id="6534" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">其中一个类的示例可能是(我考虑过删除处理 _customerMap 的部分，但是，留下它，您可以忽略它，它不是特定于概念的):</p><pre class="jp jq jr js fd jt ju jv bn jw jx bi"><span id="6e69" class="jy jz hi ju b be ka kb l kc kd">public class CustomerRepository : ICustomerRepository<br/>{<br/>   //use to cache customers<br/>   private static ConcurrentDictionary&lt;string, Customer&gt; _customerMap = new ConcurrentDictionary&lt;string, Customer&gt;();<br/>   //not static, should not cache<br/>   private APIDbContext _context;<br/><br/>   public CustomerRepository(APIDbContext injectedContext)<br/>   {<br/>      this._context = injectedContext;<br/>      if (_customerMap is null)<br/>      {<br/>         _customerMap = new ConcurrentDictionary&lt;string, Customer&gt;(this._context.Customers.ToDictionary(c =&gt; c.CustomerID));<br/>      }<br/>   }<br/><br/>   public async Task&lt;Customer&gt; CreateAsync(Customer c)<br/>   {<br/>      c.CustomerID = c.CustomerID.ToUpper();<br/>      EntityEntry&lt;Customer&gt; added = await this._context.AddAsync(c);<br/>      int affected = await this._context.SaveChangesAsync();<br/>      if (affected == 1)<br/>      {<br/>         if (_customerMap == null)<br/>         {<br/>            return c;<br/>         }<br/>         else<br/>         {<br/>            return _customerMap.AddOrUpdate(c.CustomerID, c, UpdateCache);<br/>         }<br/>       }<br/>       else<br/>       {<br/>          return null;<br/>       }<br/>   }<br/><br/>   public Task&lt;IEnumerable&lt;Customer&gt;&gt; RetrieveAllAsync()<br/>   {<br/>      return Task.FromResult(_customerMap is null ? Enumerable.Empty&lt;Customer&gt;() : _customerMap.Values);<br/>   }<br/>              <br/>   public Task&lt;Customer?&gt; RetrieveAsync(string id)<br/>   {<br/>      id = id.ToUpper();<br/>      if (_customerMap is null) return null!;<br/>      _customerMap.TryGetValue(id, out Customer? c);<br/>      return Task.FromResult(c);<br/>   }<br/><br/>   private Customer UpdateCache(string id, Customer c)<br/>   {<br/>      Customer? old;<br/>      if (_customerMap is not null)<br/>      {<br/>         if (_customerMap.TryGetValue(id, out old))<br/>         {<br/>            if (_customerMap.TryUpdate(id, c, old))<br/>            {<br/>               return c;<br/>            }<br/>         }<br/>      }<br/>      return null;<br/>   }<br/><br/>   public async Task&lt;Customer?&gt; UpdateAsync(string id, Customer c)<br/>   {<br/>      id = id.ToUpper();<br/>      c.CustomerID = c.CustomerID.ToUpper();<br/>      this._context.Update(c);//we did not use Update in the previous ex.<br/>      int affected = await this._context.SaveChangesAsync();<br/>      if (affected == 1)<br/>      {<br/>         return UpdateCache(id, c);<br/>      }<br/>      return null;<br/>   }<br/><br/>   public async Task&lt;bool?&gt; DeleteAsync(string id)<br/>   {<br/>      id = id.ToUpper();<br/>      Customer? c = this._context.Customers.Find(id);<br/>      if (c is null) return null;<br/>      this._context.Remove(c);<br/>      int affected = await this._context.SaveChangesAsync();<br/>      if (affected == 1)<br/>      {<br/>         if (_customerMap is null) return null;<br/>         return _customerMap.TryRemove(id, out c);<br/>      }else<br/>      {<br/>         return null;<br/>      }   <br/>    }<br/> }</span></pre><p id="3b55" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">一旦你有了它，在你可以在控制器中使用它之前，你需要进入你的 program.cs，就像我们对 APIDbContext 所做的那样:</p><pre class="jp jq jr js fd jt ju jv bn jw jx bi"><span id="1902" class="jy jz hi ju b be ka kb l kc kd">builder.Services.AddScoped&lt;ICustomerRepository, CustomerRepository&gt;();</span></pre><p id="9ce1" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">然后在歌曲控制器、客户控制器等上:</p><pre class="jp jq jr js fd jt ju jv bn jw jx bi"><span id="0fab" class="jy jz hi ju b be ka kb l kc kd">...<br/>public class CustomerController :ControllerBase<br/>{<br/>   private readonly ICustomerRepository repo;<br/>   public CustomerController(ICustomerRepository repo)<br/>   {<br/>      this.repo = repo;<br/>   }<br/><br/>    [HttpGet]<br/>    [ProducesResponseType(200, Type = typeof(IEnumerable&lt;Customer&gt;))]<br/>    public async Task&lt;IEnumerable&lt;Customer&gt;&gt; GetCustomers(string country)<br/>    {<br/>       if (string.IsNullOrEmpty(country) || string.IsNullOrWhiteSpace(country))<br/>       {<br/>          return await repo.RetrieveAllAsync();<br/>       }            <br/>       else <br/>       {<br/>          return (await repo.RetrieveAllAsync()).Where( c =&gt; c.Country == country);<br/>       }<br/>     }<br/>...</span></pre><h1 id="8e6d" class="kh jz hi bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld bi translated">当您需要多个 Get(或任何其他动作)时</h1><p id="87af" class="pw-post-body-paragraph iq ir hi is b it le iv iw ix lf iz ja jb lg jd je jf lh jh ji jj li jl jm jn hb bi translated">如果你有两个 HttpGet 方法，你会得到一个错误，因为代码不知道使用哪一个。您需要创建第二个方法，以便它有一个不同的路径。</p><p id="14ce" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">你会有这个:</p><pre class="jp jq jr js fd jt ju jv bn jw jx bi"><span id="a727" class="jy jz hi ju b be ka kb l kc kd">[HttpGet("{id}")] //could just name it Get<br/>public async Task&lt;Song&gt; GetSong(int id)<br/>{<br/>   return await _dbContext.Songs.FindAsync(id);<br/>}</span></pre><p id="6277" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">您现在可以添加类似这样的内容:</p><pre class="jp jq jr js fd jt ju jv bn jw jx bi"><span id="4c8e" class="jy jz hi ju b be ka kb l kc kd">[HttpGet("[action]/{id}")]<br/>public async Task&lt;Song&gt; GetSomeOtherName(int id)<br/>{<br/>   return await _dbContext.Songs.FindAsync(id);<br/>}</span></pre><p id="49f7" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">它的 url 应该是:<code class="du ke kf kg ju b">localhostOrWhateverServer/api/songs/GetSomeOtherName/1</code></p><p id="280c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">/api，因为这是控制器已经设置好的(<code class="du ke kf kg ju b">[Route(“api/[controller]”)</code>)。</p><h1 id="26df" class="kh jz hi bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld bi translated">带 EF 的 Linq</h1><p id="24f6" class="pw-post-body-paragraph iq ir hi is b it le iv iw ix lf iz ja jb lg jd je jf lh jh ji jj li jl jm jn hb bi translated">用 EF 获取数据的时候可以用 linq。我只举几个例子。</p><pre class="jp jq jr js fd jt ju jv bn jw jx bi"><span id="aa1a" class="jy jz hi ju b be ka kb l kc kd">//get only the songs that have id&gt;4 and don't get all cols, just id and lang<br/>public async Task&lt;IActionResult&gt; GetSongs()<br/>  {<br/>   var myList = await (from s in _dbContext.Songs<br/>       where s.Id &gt; 4<br/>       select new<br/>       {<br/>        id = s.Id,<br/>        lang = s.Language<br/>       }).ToListAsync();                      <br/>       <br/>   return StatusCode(StatusCodes.Status200OK, myList);<br/>  }</span></pre><p id="580f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">结果是:</p><pre class="jp jq jr js fd jt ju jv bn jw jx bi"><span id="a4e7" class="jy jz hi ju b be ka kb l kc kd">[<br/>    {<br/>        "id": 5,<br/>        "lang": "Russian"<br/>    },<br/>    {<br/>        "id": 6,<br/>        "lang": "Portuguese"<br/>    },<br/>    {<br/>        "id": 7,<br/>        "lang": "Valencian"<br/>    },<br/>    {<br/>        "id": 8,<br/>        "lang": "Arabic"<br/>    }<br/>]</span></pre><p id="791b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如果您有歌曲，并且您还有一个将每首歌曲链接到歌曲所在国家列表的表，那么您可以在获得歌曲时获得这些国家，代码类似于下面的代码。</p><p id="38c9" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">请记住，为了能够拥有他们国家的歌曲，您需要这样的代码:</p><p id="70ac" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在 DbContext 类中，除了 Songs DbSet 之外，还需要 countries。它应该与表名相匹配:public <code class="du ke kf kg ju b">DbSet&lt;SongAndCountry&gt; SongAndCountries { get; set; }</code></p><p id="1de8" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在 Song.cs 本身，<code class="du ke kf kg ju b">public ICollection&lt;SongAndCountry&gt; SongAndCountries { get; set; }</code></p><p id="efb0" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">然后在 SongController.cs 中，您可以获得带有特定 id 的歌曲以及它们各自的国家，如下所示:</p><p id="fe70" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><code class="du ke kf kg ju b">var myList = await (_dbContext.Songs.<strong class="is hj">Where(s =&gt; s.Id == 3</strong>).<strong class="is hj">Include</strong>(c =&gt; c.SongAndCountries).ToListAsync());</code></p><p id="11d8" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">与上面类似，但是多了一个过滤器，您可以:</p><pre class="jp jq jr js fd jt ju jv bn jw jx bi"><span id="b45d" class="jy jz hi ju b be ka kb l kc kd">IQueryable&lt;Category&gt;? categories = db.Categories?.Include(c =&gt; c.Products.Where(p =&gt; p.cost &lt; 50));<br/><br/>IQueryable&lt;Product&gt;? products = db.Products?.Where(p =&gt; EF.Functions.Like(p.ProductName, "Ch%"));</span></pre><h1 id="cb52" class="kh jz hi bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld bi translated">页式算法</h1><p id="8990" class="pw-post-body-paragraph iq ir hi is b it le iv iw ix lf iz ja jb lg jd je jf lh jh ji jj li jl jm jn hb bi translated">假设我们希望用户能够告诉我们他/她想要什么页面，以及每页有多少条记录(这是在我们不想同时发送所有记录时使用的)。</p><p id="e094" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们可以获取一个 pgNum 和一个 pgSize(比如每页 10 条记录)，然后我们会用</p><p id="59a1" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><code class="du ke kf kg ju b">Songs.<strong class="is hj">Skip</strong>( (pgNum -1) * pgSize).<strong class="is hj">Take</strong>(pgSize)</code></p><p id="97fc" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">到目前为止就是这样。</p></div></div>    
</body>
</html>