<html>
<head>
<title>Event Loop in detail</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">详细的事件循环</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/event-loop-in-detail-f1c3c9653046?source=collection_archive---------8-----------------------#2021-03-15">https://medium.com/nerd-for-tech/event-loop-in-detail-f1c3c9653046?source=collection_archive---------8-----------------------#2021-03-15</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/5150e2a451e438c75ca11d3a3f099c6c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*GRf4J_TUXXK-OsDh"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">扎卡里亚·奥西在<a class="ae iu" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><p id="0218" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">Javascript已经真正征服了开发世界，大多数尖端技术都在其中实现。像nodeJs、React和Angular这样的项目正在被大量采用，不只是停留在那里，而是讨论哪个更好。</p><p id="39c2" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">所有此类框架共有的一个关键方面是javascript。不管这些框架有多复杂，它们都是一个javascript库，这篇博客试图揭示javascript和事件循环的细节。</p><blockquote class="jt ju jv"><p id="b8e0" class="iv iw jw ix b iy iz ja jb jc jd je jf jx jh ji jj jy jl jm jn jz jp jq jr js hb bi translated">t<strong class="ix hj">L；DR </strong>事件循环是一个半无限循环，在OS上轮询和阻塞，直到一组文件描述符中的一些准备好。</p></blockquote><p id="601b" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">什么是</strong> <strong class="ix hj">文件描述符</strong>:文件描述符是标识内核上资源的整数。假设你打开一个文件或者创建一个套接字连接，文件描述符标识了内存中的文件内容。所有进程都被称为内存中的文件，因此得名。</p><p id="cd0f" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">让我们看看一个普通的Java服务器如何处理一个请求</strong>:当接收到一个请求时，一个新的线程被创建来处理它。这种方法的问题是，每个新请求都由CPU分配一些资源，服务器很快就会因资源短缺而阻塞。通常不会有问题，因为你的服务器功能强大得多，流量也不疯狂。</p><p id="f94d" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj"> nodeJs多线程解决方案</strong>:在启动时，我们请求一个创建套接字连接的TCP服务器，这会产生一个文件描述符。这个文件描述符用来告诉内核我们对某些事情感兴趣，例如，传入的请求。所以当TCP客户端请求连接时，内核会唤醒它。因此，假设您一次收到一百万个请求，所有请求都在不使用线程的情况下同步处理(假设您的服务器只有一个内核)。node不是立刻承担负载，而是在空闲时承担负载。线程方法将很容易阻塞系统，因为内存中加载了大量等待数据的线程，而在node中，无论传入请求的数量有多少，它都会一个接一个地响应所有请求，而不会阻塞。<br/>但另一方面，如果您的任何请求需要很长时间来执行，所有后续请求都会受到影响(可能没有机会执行)。简而言之，在大量请求得到答复之前，其他请求将不得不等待或过期。换句话说，nodeJs不是运行CPU密集型工作的最佳位置。你最好把它交给另一个服务或者依靠工人线程，<a class="ae iu" href="https://udayreddy.medium.com/scaling-nodejs-server-19c5ecddfbfc" rel="noopener">点击这里</a>了解更多。</p><p id="53c5" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">那么，事件循环是如何工作的呢？正如我说过的，这是一个半无限循环，当我们请求的资源准备好时就会运行。假设我们运行了一个<code class="du ka kb kc kd b">setTimeout</code>,它会执行以下操作。<br/> 1。JS将该行放到调用栈<br/> 2中。我们要求内核设置一个计时器。<br/> 3。内核设置它并给我们一个文件描述符来识别操作。<br/> 3。我们将函数放入内存，并忘记调用了setTimeout。最重要的是，我们释放了最初分配的资源。<br/> …..片刻之后(超时之后)… <br/> 4。一旦定时器关闭，内核将调用nodeJs进程。<br/> 5。事件循环识别计时器已到期，并将其添加到队列中。<br/> 6。如果调用堆栈上没有任何东西，事件循环将再次迭代，以检查队列上是否有新的项目。<br/> 7。事件循环发现队列有setTimeout的回调，因此运行它。</strong></p><blockquote class="jt ju jv"><p id="5d3c" class="iv iw jw ix b iy iz ja jb jc jd je jf jx jh ji jj jy jl jm jn jz jp jq jr js hb bi translated"><strong class="ix hj"> EventLoop </strong>每当调用堆栈为空时，运行队列中的项目。</p></blockquote><p id="80d5" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我只提到了“队列”，这可能意味着只有一个队列。没有。有多个队列，一共有六个:<br/> 1。定时器队列:存储<code class="du ka kb kc kd b">setTimeout</code>和<code class="du ka kb kc kd b">setInterval</code> <br/> 2的回调。文件操作队列:存储TCP、fs等I/O相关的回调。<br/> 3。setImmediate queue:存储<code class="du ka kb kc kd b">setImmediate</code>4的所有回调。轮询队列:当前正在节点上运行代码。<br/> 5。承诺队列:存储<code class="du ka kb kc kd b">Promise</code> <br/> 6的回调。NextTick队列:存储<code class="du ka kb kc kd b">nextTick</code>的回调</p><p id="2e8c" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">事件循环以不同的方式管理每个队列的优先级，因此它分阶段工作。</p><p id="7bda" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">以下是不同的阶段:<br/> 1。<strong class="ix hj">定时器</strong>:该阶段执行<code class="du ka kb kc kd b">setTimeout()</code>和<code class="du ka kb kc kd b">setInterval()</code>安排的回调。<br/> 2。<strong class="ix hj">待定回调</strong>:执行推迟到下一次循环迭代的I/O回调。<br/> 3。<strong class="ix hj">闲置，准备</strong>:仅供内部使用。<br/> 4。<strong class="ix hj">轮询</strong>:检索新的I/O事件；执行与I/O相关的回调(除了关闭回调、计时器调度的回调和<code class="du ka kb kc kd b">setImmediate()</code>)之外的几乎所有回调；节点将在适当的时候阻塞这里。<br/> 5。<strong class="ix hj">检查</strong>:这里调用<code class="du ka kb kc kd b">setImmediate()</code>回调。<br/> 6。<strong class="ix hj">关闭回调</strong>:一些关闭回调，例如<code class="du ka kb kc kd b">socket.on('close', ...)</code>。</p><p id="184c" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">当我说事件循环分阶段运行时，它每次运行时都基于上述优先级执行回调。</p><p id="68d0" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">定时器</strong>:事件循环的第一阶段，检查<code class="du ka kb kc kd b">timer-queue</code>是否有任何回调排队等待执行。如果是这样，我们就开始运行它们，一旦完成，我们就进入下一步。</p><p id="c341" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">未决回调</strong>:检查<code class="du ka kb kc kd b">file operations</code>队列是否有任何准备好执行的任务。如果是这样，我们就开始运行它们，一旦完成，我们就进入下一步。</p><p id="5bec" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">轮询阶段</strong>:在这个阶段，实际的javascript代码在这里执行。所以，当你运行<code class="du ka kb kc kd b">node index.js</code>时，代码就是在这个阶段执行的。根据代码的不同，它可能会立即执行，也可能会将某些内容添加到队列中，以便在事件循环的下一个节拍执行。<br/>该阶段可以阻塞节点流程，因为它是同步执行的。<br/>除了close-callback(close有一个单独的阶段)之外，这个进程以及执行代码还会轮询I/O。我们正在讨论计时器、文件操作、setImmediate。<br/>如果轮询队列(您的常规同步源代码)为空，它可能会执行以下操作:<br/> 1 .如果任何<code class="du ka kb kc kd b">setImmediate</code>被调度，它立即退出轮询阶段并进入检查阶段。<br/> 2。如果没有安排<code class="du ka kb kc kd b">setImmediate</code>，它将等待是否有回调被添加到轮询队列中，并立即执行它们。<br/> 3。如果轮询队列为空，并且计时器回调到期，它会快速返回到第一阶段，即计时器阶段。</p><p id="6c96" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">检查阶段</strong>:执行当前节拍内安排的所有<code class="du ka kb kc kd b">setImmediate</code>回调。</p><p id="0c61" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">关闭回调</strong>:所有<code class="du ka kb kc kd b">close</code>事件，例如socket发出一个关闭事件，将在本阶段执行。</p><p id="1881" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">什么是蜱？</strong> <br/>滴答是当前正在执行的事件循环，一个滴答相当于说:所有阶段运行一次。</p><h2 id="3d13" class="ke kf hi bd kg kh ki kj kk kl km kn ko jg kp kq kr jk ks kt ku jo kv kw kx ky bi translated"><code class="du ka kb kc kd b"><strong class="ak">process.nextTick()</strong></code></h2><p id="de56" class="pw-post-body-paragraph iv iw hi ix b iy kz ja jb jc la je jf jg lb ji jj jk lc jm jn jo ld jq jr js hb bi translated">这不是事件循环的一部分，从某种意义上说，它有一个单独的队列，只要event loop切换阶段就运行。如果回调被安排在<code class="du ka kb kc kd b">nextTick-queue</code>，一旦事件循环从一个阶段切换到另一个阶段，它将同步运行项目。这会阻塞事件循环，所以在使用时要小心，因为它可能会使I/O饥饿。<br/>你想运行它的唯一原因是当你需要在你正在做的事情之后，事件循环做其他事情之前运行某个东西。</p><p id="66d4" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj"> Promise.resolve() <br/> </strong>这和event-loop完全没有关系。当当前堆栈为空时，它运行回调。比方说，您有一个正在运行的函数，它调度了一个<code class="du ka kb kc kd b">Promise.resolve</code>，这个解析的回调在函数当前被执行后立即运行。</p><p id="99ff" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><code class="du ka kb kc kd b">process.nextTick</code>和<code class="du ka kb kc kd b">Promise.resolve</code>被称为微任务，以最高优先级运行，但它们之间<code class="du ka kb kc kd b">process.nextTick</code>胜出。所有其他的调度程序都被称为宏任务或者只是一般意义上的任务。</p><p id="88a6" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">任务的优先级:<br/><code class="du ka kb kc kd b">process.nextTick</code>&gt;<code class="du ka kb kc kd b">Promise.resolve</code>&gt;<code class="du ka kb kc kd b">setImmediate</code>&gt;<code class="du ka kb kc kd b">setTimeout/setInterval</code><br/>注意:虽然<code class="du ka kb kc kd b">setImmediate</code>并不总是保证在<code class="du ka kb kc kd b">setTimeout</code>之前运行，上面的优先级是一个大概的比较。</p><p id="14fb" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">快速回顾一下:1。只要调用堆栈为空，事件循环就会运行。<br/> 2。事件循环分阶段运行(定时器- &gt; IO - &gt;池- &gt;检查- &gt;退出)<br/> 3。每当调用栈为空时，就执行承诺，即在事件循环之前。<br/> 4。process.nextTick在事件循环的阶段之间运行。</p><p id="8505" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">简而言之，你的事件循环应该看起来像下面的乒乓球，它应该快速运行你的指令。I/O密集型不是问题，但CPU密集型是问题。<br/>要了解更多关于nodeJs性能以及如何优化的信息，<a class="ae iu" href="https://udayreddy.medium.com/scaling-nodejs-server-19c5ecddfbfc" rel="noopener">点击这里</a></p><figure class="lf lg lh li fd ij er es paragraph-image"><div class="er es le"><img src="../Images/20436e3059aa3a2fa940f28f904c00dc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1276/1*tHtFIPxI8a2g1Yf2BmMcMA.gif"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">活动的事件循环</figcaption></figure><p id="73c5" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">高度鼓励看下面:<br/><a class="ae iu" href="https://www.youtube.com/watch?v=PNa9OMajw9w&amp;t=12s" rel="noopener ugc nofollow" target="_blank">https://www.youtube.com/watch?v=PNa9OMajw9w&amp;t = 12s</a><br/><a class="ae iu" href="https://www.youtube.com/watch?v=P9csgxBgaZ8" rel="noopener ugc nofollow" target="_blank">https://www.youtube.com/watch?v=P9csgxBgaZ8</a></p><p id="83d4" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">参考资料:<br/><a class="ae iu" href="https://stackoverflow.com/questions/49811043/relationship-between-event-loop-libuv-and-v8-engine" rel="noopener ugc nofollow" target="_blank">https://stack overflow . com/questions/49811043/relationship-between-event-loop-libuv-and-V8-engine</a><br/><a class="ae iu" href="https://dev.to/khaosdoctor/node-js-under-the-hood-3-deep-dive-into-the-event-loop-135d" rel="noopener ugc nofollow" target="_blank">https://dev . to/khaosdoctor/node-js-under-the-hood-3-deep-dive-into-the-event-loop-135d</a><br/><a class="ae iu" href="https://stackoverflow.com/questions/50115031/does-v8-have-an-event-loop" rel="noopener ugc nofollow" target="_blank">https://stack overflow . com/questions/5011500</a></p><p id="98fd" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">读起来不错:<br/><a class="ae iu" href="https://dev.to/lunaticmonk/understanding-the-node-js-event-loop-phases-and-how-it-executes-the-javascript-code-1j9" rel="noopener ugc nofollow" target="_blank">https://dev . to/lunatic monk/understanding-the-node-js-event-loop-phases-and-how-it-executes-the-JavaScript-code-1j 9</a></p></div></div>    
</body>
</html>