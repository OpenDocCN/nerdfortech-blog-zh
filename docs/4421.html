<html>
<head>
<title>Algorithms II: Fundamental Data Structures</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">算法II:基本数据结构</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/algorithms-ii-fundamental-data-structures-9e2382babc2a?source=collection_archive---------11-----------------------#2021-07-20">https://medium.com/nerd-for-tech/algorithms-ii-fundamental-data-structures-9e2382babc2a?source=collection_archive---------11-----------------------#2021-07-20</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/6a05fc2198525f42e26632a8c6ab8354.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CU2c1RlwV5Ddb_6RGNu1eQ.jpeg"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">src:今日美国:亚马逊仓库</figcaption></figure><p id="e113" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">在我程序员生涯的早期，我是用C编程语言写的。这是我编程的第一门语言，我并不讨厌这种体验。我着手构建的一个项目是一个销售点系统，类似于你当地超市的收银台，作为学习这门语言的关键部分和测试我的掌握程度的一种方式。</p><p id="16d3" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">与C 合作建立这样一个系统的唯一问题是如何存储和管理数据。例如，像任何其他收银台一样，我需要存储商品及其匹配价格的主列表，我必须存储元数据，例如，商品是否有折扣以及折扣是多少。当时，我知道如何在C编程语言中使用的唯一数据结构是<strong class="iw hj">原始数组。</strong>这让事情变得非常困难，最终我放弃了开发游戏的项目。</p><p id="f7e2" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">设计没有适当数据结构的算法真的很有挑战性。这就是为什么大多数有经验的程序员在决定将一种编程语言用于一个项目之前会考虑它所支持的数据结构，至少，这是我在体验了<strong class="iw hj"> C </strong>之后一直做的事情。考虑到用例及问题类型的变化，使用支持多种数据结构的语言是很重要的。确保语言以最佳性能实现默认算法也很重要，例如，我们应该优先考虑为数据结构(如list)上的搜索、获取、插入、删除和排序操作提供最佳整体性能的语言，这是因为在实际生产环境中，软件系统很可能每秒至少执行这些操作几百万次或几十亿次。</p><p id="5fb6" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">考虑以下语言性能基准。我不想在这里挑起争端，但是根据这些基准，如果性能在你的清单上是最重要的，你可能会远离<strong class="iw hj"> python3 </strong>。</p><p id="d478" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">我不是第一个注意到这一点的人。在这里了解更多关于python性能和效率的不足:<a class="ae js" href="http://jakevdp.github.io/blog/2014/05/09/why-python-is-slow/" rel="noopener ugc nofollow" target="_blank">http://jakevdp . github . io/blog/2014/05/09/why-python-is-slow/</a></p><figure class="ju jv jw jx fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es jt"><img src="../Images/8a533b88364f9f3e723d8eba1d3ed9a9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lA4EECfQBEEuFKDx2a4x2w.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">Java Vs Python tryed and true Vs " modern and new "<a class="ae js" href="https://belitsoft.com/java-development-services/java-vs-python-tried-and-true-vs-modern-and-new" rel="noopener ugc nofollow" target="_blank">https://belit soft . com/Java-development-services/Java-Vs-Python-tryed and true-Vs-modern and new</a></figcaption></figure><figure class="ju jv jw jx fd ij er es paragraph-image"><div class="er es jy"><img src="../Images/b8f711f298c3b4c30d6ee949ce4ffaf2.png" data-original-src="https://miro.medium.com/v2/resize:fit:800/format:webp/1*qdULK9z_bzO3qBV722EsUw.jpeg"/></div></figure><figure class="ju jv jw jx fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es jz"><img src="../Images/e1d84884787df8e4a817a18bce9a37e0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MDrqrO4_3tY9Uyy44tSPtQ.jpeg"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">编程语言与工具:Medium<a class="ae js" rel="noopener" href="/travelling-developers/top-5-programming-languages-to-learn-in-2019-70247ec3e729">https://Medium . com/traveling-developers/top-5-programming-languages-to-learn-in-2019-70247 ec3e 729</a></figcaption></figure><p id="7619" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">后来，在我的职业生涯中，我选定Java作为对这些数据结构提供最佳支持的语言，事实证明，这些数据结构对于设计哪怕是最简单的算法都是至关重要的。有了Java集合，我觉得(现在仍然如此)面对任何抛给我的特定领域的问题都是不可战胜的。我只需要从集合API中选择一个数据结构(Map、HashMap、List、ArrayList、Set e.t.c ),就可以了。值得注意的是，大多数(我认为是所有)现代编程语言都广泛支持数据结构，区别因素是不同语言对这些数据结构的操作的速度和效率如何不同。</p></div><div class="ab cl ka kb gp kc" role="separator"><span class="kd bw bk ke kf kg"/><span class="kd bw bk ke kf kg"/><span class="kd bw bk ke kf"/></div><div class="hb hc hd he hf"><p id="56be" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">一个<strong class="iw hj">数据结构</strong>可以定义为一个组织其他数据项的<strong class="iw hj">方案</strong>。在这篇文章中，我们将看到一些关键的数据结构，它们定义了程序员的日常生活，而不管他们使用哪种语言来设计和实现算法。</p><p id="e963" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">这些是线性数据结构、图形、树、集合和字典。</p><h1 id="1da2" class="kh ki hi bd kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le bi translated"><strong class="ak">线性数据结构</strong></h1><h1 id="7a24" class="kh ki hi bd kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le bi translated"><strong class="ak">数组</strong></h1><p id="3921" class="pw-post-body-paragraph iu iv hi iw b ix lf iz ja jb lg jd je jf lh jh ji jj li jl jm jn lj jp jq jr hb bi translated"><strong class="iw hj">数组</strong>和<strong class="iw hj">链表</strong>可以说是最重要的数据结构。该阵列可以是一维或多维的，通常是二维的。一维数组是连续存储的相同数据类型的项目<strong class="iw hj"> n </strong>的序列，其值可以通过指示数组的<strong class="iw hj">索引</strong>的数字来访问。</p><p id="3831" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">可以假设数组的元素使用相同数量的计算机内存，并且数组的每个元素都可以在可预测的恒定时间内被访问，而不管它们在数组中的位置或索引。这些属性将数组与链表和其他数据结构区分开来。该数组用于定义其他类型的数据结构，如<strong class="iw hj">字符串</strong>。</p><figure class="ju jv jw jx fd ij er es paragraph-image"><div class="er es lk"><img src="../Images/70767a0b8ab6c83b7f05c6e93b09d45d.png" data-original-src="https://miro.medium.com/v2/resize:fit:904/format:webp/1*1-OOgCNMqvCpT7C0Q3ZAzw.jpeg"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">array:Medium:<a class="ae js" rel="noopener" href="/@vandersonramos/moving-the-first-item-to-the-last-position-in-the-array-javascript-c8ba435efee3">https://Medium . com/@ vandersonramos/move-the-first-item-to-last-position-in-the-array-JavaScript-c8ba 435 efee 3</a></figcaption></figure><h1 id="08f0" class="kh ki hi bd kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le bi translated"><strong class="ak">链表</strong></h1><figure class="ju jv jw jx fd ij er es paragraph-image"><div class="er es ll"><img src="../Images/63de8fee83696cfd9d78852643ce1f57.png" data-original-src="https://miro.medium.com/v2/resize:fit:682/format:webp/1*fksLBeMIJyqkTdXyIcdGMA.png"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">单链表:来源<a class="ae js" href="https://www.educative.io/edpresso/what-is-a-singly-linked-list" rel="noopener ugc nofollow" target="_blank">https://www . educative . io/edpresso/什么是单链表</a></figcaption></figure><p id="a7b3" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw hj">链表</strong>是一个零个或多个元素的序列，称为<strong class="iw hj">节点</strong>，每个节点包含两种信息；一些数据和一个或多个到其他节点的链接(称为<strong class="iw hj">指针</strong> ) <strong class="iw hj"> </strong>到链表中的其他节点。一个名为“<strong class="iw hj"> null </strong>”的特殊指针用于指示该节点后继节点的缺失(链表的末尾)。</p><p id="6b1a" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">要访问链表中的一个元素，首先必须从链表的第一个节点开始，遍历链表，直到到达目标节点。因此，访问链表中的元素所需的时间取决于该元素的节点在链表中的位置。</p><p id="c62e" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">链表的优点是它们不需要预先保留计算机内存，因为与数组相反，节点可以动态地添加或删除。</p><figure class="ju jv jw jx fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lm"><img src="../Images/620e4eb4bc72a14517cd05345cb9a99a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*opAfZxPG7rG1ZfhsyOIi6A.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">访问单个链表</figcaption></figure><p id="f7dd" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">链表有时包含一个<strong class="iw hj">头</strong>，它可以提供关于链表的信息，例如，链表的大小，指向包含链表的第一个和最后一个元素的节点的指针。</p><p id="b2de" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">链表可以增强为<strong class="iw hj">双向链表，</strong>其中每个节点都包含一个指向下一个和上一个节点的指针。</p><figure class="ju jv jw jx fd ij er es paragraph-image"><div class="er es ln"><img src="../Images/6badfe9ec5406d0f0bb3c92ad07dd6de.png" data-original-src="https://miro.medium.com/v2/resize:fit:1226/1*l-dCbvT-Up1tQudntjej1w.gif"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">双向链表</figcaption></figure><p id="e194" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw hj">简单或线性列表</strong></p><p id="a418" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">链表和数组用于表示一种更抽象的数据结构，称为线性列表或简单列表。列表支持基本操作，如在列表中插入、删除和搜索元素。</p><p id="57d3" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">该列表允许我们导出更重要的数据结构，如<strong class="iw hj">队列</strong>和<strong class="iw hj">堆栈</strong>。</p><figure class="ju jv jw jx fd ij er es paragraph-image"><div class="er es lo"><img src="../Images/049713adc524ac84e55335f04d882f22.png" data-original-src="https://miro.medium.com/v2/resize:fit:946/format:webp/1*R7I0FbirkdqBb5Bvx-_pHw.jpeg"/></div></figure><p id="a64a" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">堆栈是一种数据结构，它只允许在数据结构的一端，即顶部进行操作。数据结构采用<strong class="iw hj"> LI-FO </strong>格式，即<strong class="iw hj"> <em class="lp">后进先出。</em> </strong>添加(也称为推送操作)和删除(也称为弹出操作)发生在顶部元素。</p><figure class="ju jv jw jx fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lq"><img src="../Images/240e6e980658ea04a89bd21cf69d955f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CXqAvOySy-Ah7e9N0kP4hw.png"/></div></div></figure><p id="3721" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">队列是一种支持在线性数据结构两端操作的数据结构。元素的添加在数据结构的<strong class="iw hj">后</strong>端完成，该操作称为<strong class="iw hj"> en队列</strong>，而元素的删除从数据结构的<strong class="iw hj">前</strong>端完成，也称为<strong class="iw hj"> de队列。</strong>因此，队列以<strong class="iw hj"> FIFO </strong>格式运行，(<em class="lp">先进先出</em>)。</p><h1 id="c17f" class="kh ki hi bd kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le bi translated"><strong class="ak">图表</strong></h1><p id="f6df" class="pw-post-body-paragraph iu iv hi iw b ix lf iz ja jb lg jd je jf lh jh ji jj li jl jm jn lj jp jq jr hb bi translated">图可以(非正式地)定义为由线段(<strong class="iw hj">边或弧</strong>)连接的点(<strong class="iw hj">节点或顶点</strong>)的集合。</p><p id="698a" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">一个图也可以(正式地)定义为一个<strong class="iw hj">G</strong>=【V，E】。<strong class="iw hj"> G </strong>是由一对两个集合表示的图，<strong class="iw hj"> V </strong>是顶点的集合，<strong class="iw hj"> E </strong>是边的集合。</p><p id="3d7a" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">如果顶点对(<em class="lp"> u，v </em>)等于顶点对(v，u)，则该图被认为是<strong class="iw hj">有向图，</strong>否则，该图被认为是<strong class="iw hj">无向图。</strong>有向图也叫<strong class="iw hj">有向图。</strong></p><p id="9b5d" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw hj">图形表示</strong></p><p id="ce68" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">计算机算法可以用两种格式表示图形；<strong class="iw hj">邻接矩阵</strong>或<strong class="iw hj">邻接链表。</strong>图的邻接矩阵是一个<strong class="iw hj"> n乘n </strong>布尔矩阵(用1和0表示)，每个顶点占一行一列。如果从第<strong class="iw hj"> <em class="lp">行</em>到第<strong class="iw hj"> <em class="lp">第j</em>列</strong>有连接边，则值为<strong class="iw hj"> 1 </strong>如果连接边不存在，则值为<strong class="iw hj"> 0 </strong>。</strong></p><figure class="ju jv jw jx fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lr"><img src="../Images/df3e32e1fd83809ff97c84c16d3c203d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gDKYF9cqS9vNX-sCJVW8jw.jpeg"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">使用邻接矩阵的图示。来源。研究门:<a class="ae js" href="https://www.researchgate.net/figure/Different-types-of-graphs-and-their-corresponding-adjacency-matrix-representations-The_fig1_347300725" rel="noopener ugc nofollow" target="_blank">https://www . research gate . net/figure/Different-types-of-graphs-and-its-communication-adjacency-matrix-representations-The _ fig 1 _ 347300725</a></figcaption></figure><p id="0e24" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">另一方面，<strong class="iw hj">邻接链表</strong>是每个顶点的一个链表集合，它包含与链表顶点相邻的所有顶点，即通过一条边连接到所述顶点。图形表示利用链表头，在该链表头上添加导出链表的顶点的名称。</p><figure class="ju jv jw jx fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lr"><img src="../Images/90286705264fe173e31a5dd22ff13ecd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wLVVLJfgj65YXUkEMn8a5g.jpeg"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">邻接链表图解。来源，研究门:<a class="ae js" href="https://www.researchgate.net/figure/Different-ways-to-represent-a-static-graph-Beyond-the-adjacency-matrix-representation-as_fig2_347300725" rel="noopener ugc nofollow" target="_blank">https://www . Research gate . net/figure/Different-ways-to-representation-a-static-graph-Beyond-the-adjacency-matrix-representation-as _ fig 2 _ 347300725</a></figcaption></figure><p id="23d7" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw hj">图形:加权图形</strong></p><p id="0ebb" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">加权图(或称加权有向图)是一个图或有向图，它的边被赋予了数字。分配给其边缘的数字称为<strong class="iw hj">重量</strong>和<strong class="iw hj">成本</strong>。要在邻接矩阵中表示加权图，如果一条边不存在(因此没有分配给它的权重)，可以使用特殊符号，如<strong class="iw hj"> ∞ </strong>。</p><figure class="ju jv jw jx fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ls"><img src="../Images/29aee0a42727f5315591676c83b93929.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*s-1qiUUQgZI2fozRRI5uNg.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">加权图。源代码Java point<a class="ae js" href="https://www.javatpoint.com/graph-representation" rel="noopener ugc nofollow" target="_blank">https://www.javatpoint.com/graph-representation</a></figcaption></figure><p id="7a66" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">加权图在现实世界中有许多应用，例如在交通或通信网络中寻找两点之间的最短路径，或者旅行推销员问题。</p><p id="c94c" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw hj">图:路径和循环</strong></p><p id="d244" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">从顶点<strong class="iw hj"> <em class="lp"> u </em> </strong> <em class="lp"> </em>到图<strong class="iw hj"> G </strong>的顶点<strong class="iw hj"> <em class="lp"> v </em> </strong> <em class="lp"> </em>的路径可以定义为以<strong class="iw hj"><em class="lp"/></strong><em class="lp"/>开始，以<strong class="iw hj"> <em class="lp"> v </em> </strong> <em class="lp">结束的相邻顶点序列。</em>路径的长度是定义路径的顶点序列中的顶点总数减1，这与所选路径中的边总数相同。</p><figure class="ju jv jw jx fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lt"><img src="../Images/bf3ee2035d80d2126d7767e6fd2c4a8e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hvRgvtEvFzhMs4YFa4A1-A.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated"><a class="ae js" href="https://mathematica.stackexchange.com/questions/4084/finding-a-not-shortest-path-between-two-vertices" rel="noopener ugc nofollow" target="_blank">寻找两个顶点之间的“非最短”路径</a>:<a class="ae js" href="https://mathematica.stackexchange.com/questions/4084/finding-a-not-shortest-path-between-two-vertices" rel="noopener ugc nofollow" target="_blank">https://Mathematica . stack exchange . com/questions/4084/Finding-a-not-shortest-path-between-two-vertices</a></figcaption></figure><figure class="ju jv jw jx fd ij er es paragraph-image"><div class="er es lu"><img src="../Images/507adef118c38c8f586895ec1a1126b8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1370/format:webp/1*N-kwHjr4sA2E_81QE_AAAA.png"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">时间相关图:<a class="ae js" href="https://link.springer.com/article/10.1007/s41019-019-00105-0" rel="noopener ugc nofollow" target="_blank">https://link . springer . com/article/10.1007/s 41019-019-00105-0</a></figcaption></figure><p id="b9a9" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">如果每对顶点(u，v)都有一条连接边，那么这个图就是连通的。</p><figure class="ju jv jw jx fd ij er es paragraph-image"><div class="er es lv"><img src="../Images/85ebbdf5628fa9c569d795da22c56d00.png" data-original-src="https://miro.medium.com/v2/resize:fit:964/format:webp/1*GL0bMxCJjYQ5io6wSH_sqw.png"/></div><figcaption class="iq ir et er es is it bd b be z dx translated"><a class="ae js" href="https://www.gatevidyalay.com/tag/cyclic-graph-definition/" rel="noopener ugc nofollow" target="_blank">https://www.gatevidyalay.com/tag/cyclic-graph-definition/</a></figcaption></figure><p id="5330" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw hj">图中的一个圈</strong>是在图中的同一个顶点开始和结束的一条路径。没有圈的图称为<strong class="iw hj">无圈图。</strong></p><figure class="ju jv jw jx fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lw"><img src="../Images/30f1ebcc89bb017a8bfc1bbeef18fcfd.png" data-original-src="https://miro.medium.com/v2/resize:fit:724/format:webp/1*sr70Yhr-xa1ZAErEEfMsZA.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">【https://www.gatevidyalay.com/tag/cyclic-graph-definition/ T42】</figcaption></figure><p id="ff5f" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw hj">树木</strong></p><p id="0838" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">树是一个连通的非循环图。</p><figure class="ju jv jw jx fd ij er es paragraph-image"><div class="er es lx"><img src="../Images/378fe98b97e9097de36f62cd202ad866.png" data-original-src="https://miro.medium.com/v2/resize:fit:1354/format:webp/1*4h8C4eVl8TOWIFR5Mnhnlw.png"/></div></figure><p id="0216" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">没有圈但不连通的图称为<strong class="iw hj">森林，</strong>因为它的每个连通部分都是一棵树。</p><p id="303f" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">对于树中的每两个顶点，总是存在一条从这些顶点中的一个到另一个的简单路径。这使得可以选择树中的一个顶点，并使其成为树的<strong class="iw hj">根</strong>，从而将树转换为<strong class="iw hj">根树。</strong></p><figure class="ju jv jw jx fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ly"><img src="../Images/8d911d237b6a68c14bbd6956c543672b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lxYZamLT87UmsC9JYA83ag.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">根树:<a class="ae js" href="https://media.geeksforgeeks.org/wp-content/uploads/minHeightTree.png" rel="noopener ugc nofollow" target="_blank">https://media . geeks forgeeks . org/WP-content/uploads/minheighttree . png</a></figcaption></figure><p id="b7b7" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">树在计算机科学中的一个常见应用是描述企业的文件目录和组织结构图中的层次结构。</p><p id="52a4" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw hj">点了棵树</strong></p><p id="5e01" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">有序树是一个有根的树，其中每个顶点的所有子节点都是有序的。</p><p id="6852" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">一棵<strong class="iw hj">二叉树</strong>是一棵有序树，其中每个顶点有不超过两个孩子，并且每个孩子要么被指定为其父顶点的<strong class="iw hj">左孩子</strong>要么被指定为其父顶点的<strong class="iw hj">右孩子</strong>。</p><figure class="ju jv jw jx fd ij er es paragraph-image"><div class="er es lz"><img src="../Images/24f7a0f1c71b23a0359d95605ce96497.png" data-original-src="https://miro.medium.com/v2/resize:fit:840/format:webp/1*lwaDg8aL0XtdEndSDBtyvQ.png"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">二叉树:<a class="ae js" href="https://www.geeksforgeeks.org/binary-tree-data-structure/" rel="noopener ugc nofollow" target="_blank">https://www.geeksforgeeks.org/binary-tree-data-structure/</a></figcaption></figure><h1 id="c443" class="kh ki hi bd kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le bi translated"><strong class="ak">集合和字典</strong></h1><figure class="ju jv jw jx fd ij er es paragraph-image"><div class="er es ma"><img src="../Images/37a64171cfee9ba5a52d07935a5b78e4.png" data-original-src="https://miro.medium.com/v2/resize:fit:604/format:webp/1*rh0guNB2cCc7-YSW5c-6bA.png"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">设置</figcaption></figure><p id="0362" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">集合直接来源于数学。集合可以描述为不同项目的无序集合。集合的符号不同，一个涉及元素的显式列表，像这样；</p><p id="3b19" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw hj"> s = {1，2，3，4，5} </strong></p><p id="5ff2" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">或者通过声明集合中所有元素共有的属性；</p><p id="04b2" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw hj"> s = {n:n是质数，n &lt; 10} </strong></p><p id="9f09" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">最重要的集合操作是检查成员资格和寻找多个集合之间的联合。一些编程语言会提供现成的集合数据结构，但是如果必须显式定义一个集合，有几种方法可以做到。一个涉及位串，也称为<strong class="iw hj">位向量，即</strong></p><p id="0635" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">s = {2，3，5，7}变成了011010100 </p><p id="52f4" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">表示集合的另一种方式是使用<strong class="iw hj">列表</strong>数据结构。</p><p id="1025" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw hj">字典</strong></p><p id="10a9" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">实现集合操作(搜索、插入、删除等)的数据结构称为字典。</p></div><div class="ab cl ka kb gp kc" role="separator"><span class="kd bw bk ke kf kg"/><span class="kd bw bk ke kf kg"/><span class="kd bw bk ke kf"/></div><div class="hb hc hd he hf"><p id="3ebc" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw hj">结论</strong></p><p id="2206" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">在计算机科学中，数据和操作之间存在着非常密切的关系。因此，算法的设计、实现和应用在很大程度上依赖于用于这些操作的数据结构。</p><p id="b32e" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">数据结构会影响算法的速度和效率。因此，在定义一个策略来开发一个领域问题的算法解决方案之前，考虑可用的数据结构是非常重要的。</p><p id="adcf" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">因此，不要只看受欢迎程度以及脸书和谷歌是否声称高度利用了一种新的、时髦的编程语言，重要的是你要询问这种语言支持哪些数据结构(准确地说是ADT ),这些ADT的速度和效率如何，以及在定义新问题的新解决方案时它们对我们来说有多容易。</p><p id="657b" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">这是关于算法主题的四部分系列的第二部分。如果你还没有，请查看本文的前传:<a class="ae js" href="https://medium.datadriveninvestor.com/algorithm-problem-types-afdfc811d8af" rel="noopener ugc nofollow" target="_blank">https://medium . datadriveninvestor . com/algorithm-problem-types-AFD fc 811 D8 af</a></p><p id="336d" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">支持我，看看我的小应用:<a class="ae js" href="https://thelifeplanner.co" rel="noopener ugc nofollow" target="_blank">人生规划师</a></p><p id="abed" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">感谢您的阅读…</p></div></div>    
</body>
</html>