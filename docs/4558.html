<html>
<head>
<title>Cue the Queue</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">排队等候</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/cue-the-queue-915d01bae98?source=collection_archive---------11-----------------------#2021-07-26">https://medium.com/nerd-for-tech/cue-the-queue-915d01bae98?source=collection_archive---------11-----------------------#2021-07-26</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="4f00" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">探索二进制堆的数据结构，它对二进制优先级队列的适应性，以及它的实际应用。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es jd"><img src="../Images/aff77fbd9bbf9dcd087654454fe3ae58.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*8GMnlcY0f01xxVif"/></div></div><figcaption class="jp jq et er es jr js bd b be z dx translated">利瓦伊·琼斯在<a class="ae jt" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><h1 id="6e1b" class="ju jv hi bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">什么是堆？</h1><p id="4392" class="pw-post-body-paragraph if ig hi ih b ii ks ik il im kt io ip iq ku is it iu kv iw ix iy kw ja jb jc hb bi translated">根据<a class="ae jt" href="https://en.wikipedia.org/wiki/Heap_(data_structure)" rel="noopener ugc nofollow" target="_blank">维基百科</a>，在<a class="ae jt" href="https://en.wikipedia.org/wiki/Computer_science" rel="noopener ugc nofollow" target="_blank">计算机科学</a>中，<strong class="ih hj">堆</strong>是一种专门的基于<a class="ae jt" href="https://en.wikipedia.org/wiki/Tree_(data_structure)" rel="noopener ugc nofollow" target="_blank">树</a>的<a class="ae jt" href="https://en.wikipedia.org/wiki/Data_structure" rel="noopener ugc nofollow" target="_blank">数据结构</a>本质上是一种几乎完整的<a class="ae jt" href="https://en.wikipedia.org/wiki/Heap_(data_structure)#cite_note-1" rel="noopener ugc nofollow" target="_blank">【1】</a>树，满足<strong class="ih hj">堆属性</strong>:在一个<em class="kx">最大堆</em>中，对于任意给定的<a class="ae jt" href="https://en.wikipedia.org/wiki/Node_(computer_science)" rel="noopener ugc nofollow" target="_blank">节点</a> C，如果P是C的父节点 那么P的<em class="kx">键</em>(值<em class="kx"/>)大于或等于c的键，在一个<em class="kx">最小堆</em>中，P的键小于或等于c的键<a class="ae jt" href="https://en.wikipedia.org/wiki/Heap_(data_structure)#cite_note-2" rel="noopener ugc nofollow" target="_blank">【2】</a>堆“顶”上的节点(没有父节点)称为<em class="kx">根</em>节点。</p><p id="2d8a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">下面是一个二进制堆的图像，如果这没有任何意义的话:</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es ky"><img src="../Images/f73207ca1b72929fa6d557ca6d5e3823.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2mm8hJtAJwTVum2X_TzmIw.jpeg"/></div></div><figcaption class="jp jq et er es jr js bd b be z dx translated">来源:<a class="ae jt" href="https://upload.wikimedia.org/wikipedia/commons/c/c4/Max-Heap-new.svg" rel="noopener ugc nofollow" target="_blank">https://upload . wikimedia . org/Wikipedia/commons/c/C4/Max-Heap-new . SVG</a></figcaption></figure><p id="5e69" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">换句话说，堆是一个树形结构。我们要特别讨论的是二进制堆。与二叉查找树不同，这些值不会在同级之间排序。在二进制最大堆(根节点上的最大值)中，当您遍历树时，降序的子元素需要具有较小的值。不同之处在于，堆没有与二叉查找树相同的规则。兄弟姐妹之间的值没有小于或大于的顺序。在二进制堆中最重要的是，如果它是一个<em class="kx">最大二进制堆，</em>父节点的值比子节点的值大，而在一个<em class="kx">最小二进制堆中，</em>父节点总是比子节点小。只关心树的血统的好处是它可以更紧凑。兄弟节点的值是不相关的。重要的是，在MaxBinaryHeap中，父节点的价值更大，而它们的子节点的价值较小。此外，每个父母最多只能有两个孩子，因此二进制这个词。</p><h2 id="2d4d" class="kz jv hi bd jw la lb lc ka ld le lf ke iq lg lh ki iu li lj km iy lk ll kq lm bi translated">那么我们如何创建二进制堆呢？</h2><p id="0cba" class="pw-post-body-paragraph if ig hi ih b ii ks ik il im kt io ip iq ku is it iu kv iw ix iy kw ja jb jc hb bi translated">二进制堆只是一个数组，但是应用了一些额外的规则。让我们再来看看上图的底部。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es ln"><img src="../Images/9dd05ae525f1dc4d8cc68c5fefb2c1de.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XuBkHMJBQBFtIMa59L3Hlg.jpeg"/></div></div></figure><p id="6f9e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这是一个二进制堆的数组表示，更像实际代码的样子。箭头表示父子关系。从你的普通数组转换到一个<strong class="ih hj">最大二进制堆</strong>的规则如下。</p><ul class=""><li id="d991" class="lo lp hi ih b ii ij im in iq lq iu lr iy ls jc lt lu lv lw bi translated">子节点必须≤父节点。</li><li id="5143" class="lo lp hi ih b ii lx im ly iq lz iu ma iy mb jc lt lu lv lw bi translated">对于数组中的任何索引(x)。左孩子存储在2x + 1。右边的孩子以2x + 2存储</li><li id="286f" class="lo lp hi ih b ii lx im ly iq lz iu ma iy mb jc lt lu lv lw bi translated">可以通过Math.floor((x -1) / 2)找到子节点(x)的父节点</li></ul><h1 id="d6e8" class="ju jv hi bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">二进制堆和优先级队列有什么区别？</h1><p id="1f38" class="pw-post-body-paragraph if ig hi ih b ii ks ik il im kt io ip iq ku is it iu kv iw ix iy kw ja jb jc hb bi translated">二进制堆实际上只是实现优先级队列的一种常见方式。我认为一个区别是，首先，它们是按优先级排列的，而不仅仅是纯数值。这导致了另一个不同:创建一个具有优先级值和附加键和值的对象。例如，假设你在急诊室排队。每个元素可能包含一个名称、去急诊室的原因和优先级。</p><h1 id="374b" class="ju jv hi bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">真正的编码和现实生活中的应用。</h1><p id="a15e" class="pw-post-body-paragraph if ig hi ih b ii ks ik il im kt io ip iq ku is it iu kv iw ix iy kw ja jb jc hb bi translated">如前所述，优先级队列是一个二进制堆，它是一个应用了一些附加规则的数组。我们将利用面向对象的设计模式来创建一个优先级队列类。此外，我们将利用一个<strong class="ih hj">最小二进制堆</strong>，而不是<strong class="ih hj">最大二进制堆</strong>。这是一回事。只是优先级从最小到最大。</p><h2 id="6816" class="kz jv hi bd jw la lb lc ka ld le lf ke iq lg lh ki iu li lj km iy lk ll kq lm bi translated">引入快速交付</h2><p id="e44a" class="pw-post-body-paragraph if ig hi ih b ii ks ik il im kt io ip iq ku is it iu kv iw ix iy kw ja jb jc hb bi translated">我们现实生活中的应用程序将为<strong class="ih hj">快速递送</strong>创建一个优先级队列，以安排包裹在递送司机的路线上递送。我们将忽略关于尺寸和重量差异的其他细节，并优化我们的队列，以确定包裹处理人员应该如何将包裹放入卡车。</p><p id="d073" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">所以我们的任务就是做一个优先级队列，按照沿线距离排列优先级。换句话说，当司机在路线上行进时，从路线的起点到每次交付的距离是多远？这是这一天司机的路线，绿点代表送货。<em class="kx">注意路线从左上角开始。</em></p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es mc"><img src="../Images/9d66d6e496736a1cfaf78109b7e71df2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6i23bXB0hVu1SN3dGpjaMA.jpeg"/></div></div></figure><p id="09de" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">因此，如果我们要画出包在优先级队列树中的样子，它看起来会像这样。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es md"><img src="../Images/c1a3b6abf700d5f028eb312a510ddf6b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JKqiDsvLoCg-g0uhq4VkjQ.jpeg"/></div></div><figcaption class="jp jq et er es jr js bd b be z dx translated">按英里排序的最小二进制堆来传递盒子</figcaption></figure><p id="09fe" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们从创建基类开始。盒类和优先级队列。</p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="me mf l"/></div></figure><p id="cdf1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">对于盒子类，这就是我们所需要的。距离的键-值对将设置优先级。值得一提的是，PriorityQueue类需要初始化的只是一个空数组来保存我们的对象。</p><h2 id="afd7" class="kz jv hi bd jw la lb lc ka ld le lf ke iq lg lh ki iu li lj km iy lk ll kq lm bi translated">排队()</h2><p id="7892" class="pw-post-body-paragraph if ig hi ih b ii ks ik il im kt io ip iq ku is it iu kv iw ix iy kw ja jb jc hb bi translated">现在我们需要一个方法来向PriorityQueue类添加新的Box对象。通常这将被命名为<em class="kx"> enqueue </em>，这样我们也将这样做。</p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="me mf l"/></div></figure><h2 id="4a2f" class="kz jv hi bd jw la lb lc ka ld le lf ke iq lg lh ki iu li lj km iy lk ll kq lm bi translated">气泡泵()</h2><p id="f9a2" class="pw-post-body-paragraph if ig hi ih b ii ks ik il im kt io ip iq ku is it iu kv iw ix iy kw ja jb jc hb bi translated">也许你注意到了上面第14行的函数调用<code class="du mg mh mi mj b">this.bubbleUp()</code>,这是我们优先级队列成功的一个基本函数。但是因为它只有几行代码，所以它被抽象成了自己的函数。它所做的是将我们新添加的对象与其父对象进行比较。如果它的优先级低于父元素，它将与父元素交换，并重复这个过程，直到父元素的优先级低于它自己的优先级值。</p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="me mf l"/></div></figure><h2 id="1f68" class="kz jv hi bd jw la lb lc ka ld le lf ke iq lg lh ki iu li lj km iy lk ll kq lm bi translated">出列()</h2><p id="ac38" class="pw-post-body-paragraph if ig hi ih b ii ks ik il im kt io ip iq ku is it iu kv iw ix iy kw ja jb jc hb bi translated">这样，我们就完成了向PriorityQueue类添加box对象的方法。现在我们需要一个方法来删除最高优先级的项目<code class="du mg mh mi mj b">dequeue()</code>。这可以被认为是我们的包交付后运行的函数。</p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="me mf l"/></div></figure><p id="9f8e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">和enqueue()一样，我们有一个对帮助器方法<code class="du mg mh mi mj b">bubbleDown()</code>的调用，我们一会儿会用到它，但是我想让你注意我们从数组中移除值的独特方式。我们将最高优先级的对象设置为一个变量，然后用数组的最后一个元素交换第一个元素的值。这是为什么呢？是的，有一个名为<code class="du mg mh mi mj b">Array.shift()</code>的内置方法可以毫不费力地给我们提供对象。好吧，缺点是shift()不是很有效，我们试图尽可能快地保持我们的运行时。shift()的问题是数组的所有元素都将被重新索引。而使用。pop()和交换值保持了类的精简和快速运行。</p><h2 id="8e26" class="kz jv hi bd jw la lb lc ka ld le lf ke iq lg lh ki iu li lj km iy lk ll kq lm bi translated">泡泡街()</h2><p id="1758" class="pw-post-body-paragraph if ig hi ih b ii ks ik il im kt io ip iq ku is it iu kv iw ix iy kw ja jb jc hb bi translated">现在关于bubbleDown()。代码相当多，所以请务必阅读GitHub Gist中的注释。实际上，代码中发生的事情是，交换的值需要与它的子值进行比较，看它是否应该被交换，如果它比子值大，那么它就在树中的正确位置。</p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="me mf l"/></div></figure><h1 id="e318" class="ju jv hi bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">回到快速交货</h1><p id="9da1" class="pw-post-body-paragraph if ig hi ih b ii ks ik il im kt io ip iq ku is it iu kv iw ix iy kw ja jb jc hb bi translated">咻，好吧，这是相当多的代码，但好消息是，这就是我们拥有一个功能完整的优先级队列所需的全部代码。</p><blockquote class="mk ml mm"><p id="a168" class="if ig kx ih b ii ij ik il im in io ip mn ir is it mo iv iw ix mp iz ja jb jc hb bi translated">附带说明:确保上述所有方法都包含在PriorityQueue类中。我确实把它们从里面去掉了，只是为了熟悉这些方法。</p></blockquote><h2 id="dcdd" class="kz jv hi bd jw la lb lc ka ld le lf ke iq lg lh ki iu li lj km iy lk ll kq lm bi translated">现在我们可以专注于它的应用。</h2><p id="c8c5" class="pw-post-body-paragraph if ig hi ih b ii ks ik il im kt io ip iq ku is it iu kv iw ix iy kw ja jb jc hb bi translated">这是一个清爽的清晨，包裹已经被分好，放在送货卡车外面，准备放进卡车里。其中一个打包员按下电脑上的按钮<strong class="ih hj">打印打包订单，</strong>正在后台运行上面的代码。另外，关于距离，我们可以说它们是米，因为很容易转换成千米。</p><pre class="je jf jg jh fd mq mj mr ms aw mt bi"><span id="15a3" class="kz jv hi mj b fi mu mv l mw mx">let newPriorityQueue = new PriorityQueue()</span><span id="2ab3" class="kz jv hi mj b fi my mv l mw mx">newPriorityQueue.enqueue('211 15th street', 4300);<br/>newPriorityQueue.enqueue('223 16th street', 4900);<br/>newPriorityQueue.enqueue('252 15th street', 3100);<br/>newPriorityQueue.enqueue('202 16th street', 4700);<br/>newPriorityQueue.enqueue('234 16th street', 5300);<br/>newPriorityQueue.enqueue('202 14th street', 200);<br/>newPriorityQueue.enqueue('298 14th street', 2000);<br/>newPriorityQueue.enqueue('297 17th street', 6800);<br/>newPriorityQueue.enqueue('261 18th street', 9200);<br/>newPriorityQueue.enqueue('267 16th street', 5800);<br/>newPriorityQueue.enqueue('280 16th street', 6300);<br/>newPriorityQueue.enqueue('258 17th street', 7500);<br/>newPriorityQueue.enqueue('273 16th street', 6000);<br/>newPriorityQueue.enqueue('270 17th street', 7100);<br/>newPriorityQueue.enqueue('241 17th street', 7700);<br/>newPriorityQueue.enqueue('220 14th street', 800);<br/>newPriorityQueue.enqueue('201 18th street', 8600);<br/>newPriorityQueue.enqueue('227 17th street', 7900);<br/>newPriorityQueue.enqueue('210 17th street', 8100);</span></pre><p id="f4cc" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">上面输入的输出是什么。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es mz"><img src="../Images/9ed13d2b34abf9b09bffbb103d2e33f2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NogP5exKJd2hQs0YWrE1ww.jpeg"/></div></div></figure><p id="6b09" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">由于知道箱子的优先级，现在包装员知道如何包装卡车。项目0是最高优先级(在顶部), 18是最低优先级。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es na"><img src="../Images/2c62c6b8ab432bc0ad663e9cf0736055.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Rpy2Qbl99Wg8-RNj-OY3Tw.jpeg"/></div></div></figure><blockquote class="mk ml mm"><p id="77b8" class="if ig kx ih b ii ij ik il im in io ip mn ir is it mo iv iw ix mp iz ja jb jc hb bi translated">从理论上讲，使用树来显示数据是有道理的，但是对于包装一辆卡车来说，使用数组格式更节省空间。</p></blockquote><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es nb"><img src="../Images/e91a23c6bd50cd00aa0d544d5fa2513d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Ih92GWGdojxs9kcAYPqCow.jpeg"/></div></div></figure><p id="c13a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">啊，好多了:D </strong>包裹现在被分类成优先队列，最高优先级是距离路线起点最短的距离。优先级最低的是数组中的最后一项。使得包裹的递送比将它们随机分布在卡车的后部更容易和更有效。</p><h2 id="b68c" class="kz jv hi bd jw la lb lc ka ld le lf ke iq lg lh ki iu li lj km iy lk ll kq lm bi translated">与现实世界的轻微偏离。</h2><p id="d54c" class="pw-post-body-paragraph if ig hi ih b ii ks ik il im kt io ip iq ku is it iu kv iw ix iy kw ja jb jc hb bi translated">我已经展示了二进制优先级队列的实际应用。分拣包裹以便投递。如果你参考上面的图片，你可以想象一个司机会从货架上拿起箱子去送货。很棒吧？如果您还记得上面的这一段，我们需要脱离实际，讨论数组数据类型。</p><blockquote class="mk ml mm"><p id="ee43" class="if ig kx ih b ii ij ik il im in io ip mn ir is it mo iv iw ix mp iz ja jb jc hb bi translated">我们将最高优先级的对象设置为一个变量，然后用数组的最后一个元素交换第一个元素的值。这是为什么呢？是的，有一个名为<code class="du mg mh mi mj b">Array.shift()</code>的内置方法，它会毫不费力地为我们提供对象。缺点是shift()不是很有效，我们试图尽可能快地保持我们的运行时间。shift()的问题是数组的所有元素都将被重新索引。而使用。pop()和交换值保持了类的精简和快速运行。</p></blockquote><p id="79c0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">一个数组被索引，我们的优先级队列在一个数组中，所有的位置都有一个索引。这里有一个视觉参考。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es nb"><img src="../Images/363c525769381a0dd74f2eaa506739c8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HU_Xi3OnS-IKasjvDmKmEw.jpeg"/></div></div></figure><p id="25db" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如上所述，使用shift()效率很低，运行时间为O(n ),因为所有内容都需要重新索引。所以我们需要做的是移除第一个项目，但不要打乱盒子的索引。这是用我们的函数完成的。<code class="du mg mh mi mj b">dequeue() and bubbleDown()</code></p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="me mf l"/></div></figure><h2 id="c67a" class="kz jv hi bd jw la lb lc ka ld le lf ke iq lg lh ki iu li lj km iy lk ll kq lm bi translated"><strong class="ak">出列的直观例子()</strong></h2><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es nb"><img src="../Images/a4fd2ca72b150cb7a59454da443338c9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*kai_g-XNdMbT4-RmXYswrA.gif"/></div></div></figure><p id="3872" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">你可以在上面看到，我们从来没有重新索引数组。我们交换最后一个值的pop()以外的值，但这是在常数时间O(1)完成的。enqueue()函数基本上是相同的，但是它将一个对象推到末尾，然后<em class="kx">使其冒泡</em>，直到它在数组中找到正确的位置。</p></div><div class="ab cl nc nd gp ne" role="separator"><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh"/></div><div class="hb hc hd he hf"><p id="c091" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">概括地说，我们讨论什么是堆，什么是二进制优先级队列。我向您展示了创建这些类的实际代码。然后我们考虑了现实世界应用的想法。至此，我们关于二进制优先级队列的讨论结束了。</p></div></div>    
</body>
</html>