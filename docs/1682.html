<html>
<head>
<title>Tutorial: Intro to React Hooks</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">教程:React挂钩简介</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/tutorial-intro-to-react-hooks-417e4ea3ff33?source=collection_archive---------10-----------------------#2021-04-01">https://medium.com/nerd-for-tech/tutorial-intro-to-react-hooks-417e4ea3ff33?source=collection_archive---------10-----------------------#2021-04-01</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="12fb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">本教程假设您了解React状态和生命周期的概念。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es jd"><img src="../Images/9902c90cc4d4b55f0b9de2d2d703740d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*3nKQ8Pz1fV8fuEze"/></div></div><figcaption class="jp jq et er es jr js bd b be z dx translated">照片由<a class="ae jt" href="https://unsplash.com/@sigmund?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">西格蒙德</a>在<a class="ae jt" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><h1 id="63d4" class="ju jv hi bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">在我们开始教程之前</h1><p id="3b0f" class="pw-post-body-paragraph if ig hi ih b ii ks ik il im kt io ip iq ku is it iu kv iw ix iy kw ja jb jc hb bi translated">在本教程中，我们将构建一个小游戏。这是一种习惯于使用钩子构建react功能组件的实用方法。我们将带着代码片段浏览本教程的每一部分，这样你就可以在构建游戏的时候跟着做了。</p><p id="b472" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">本教程分为以下几个部分:</p><ul class=""><li id="3d38" class="kx ky hi ih b ii ij im in iq kz iu la iy lb jc lc ld le lf bi translated"><strong class="ih hj">教程</strong>的设置将为你提供启动代码</li><li id="c3bc" class="kx ky hi ih b ii lg im lh iq li iu lj iy lk jc lc ld le lf bi translated"><strong class="ih hj">概述</strong>将探究钩子的一些历史基础</li><li id="edfa" class="kx ky hi ih b ii lg im lh iq li iu lj iy lk jc lc ld le lf bi translated">构建游戏将使用React开发中最常见的钩子</li><li id="4c30" class="kx ky hi ih b ii lg im lh iq li iu lj iy lk jc lc ld le lf bi translated"><strong class="ih hj">添加时间限制</strong>将延长游戏添加时间限制</li><li id="f504" class="kx ky hi ih b ii lg im lh iq li iu lj iy lk jc lc ld le lf bi translated"><strong class="ih hj">总结</strong>将讨论扩展并得出结论</li></ul><p id="1106" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">你可以继续下去，直到你建立了一个游戏的基本版本，通过一些实践来了解钩子。</p><h2 id="a66d" class="ll jv hi bd jw lm ln lo ka lp lq lr ke iq ls lt ki iu lu lv km iy lw lx kq ly bi translated">我们在建造什么？</h2><p id="93b1" class="pw-post-body-paragraph if ig hi ih b ii ks ik il im kt io ip iq ku is it iu kv iw ix iy kw ja jb jc hb bi translated">在本教程中，我们将使用React hooks构建一个交互式hangman游戏。</p><p id="eadd" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Hangman是一个经典游戏，玩家必须一次猜一个单词的一个字母。你可以<a class="ae jt" href="https://www.hangmanwords.com/play" rel="noopener ugc nofollow" target="_blank">玩</a>来适应这个游戏。</p><p id="b6d6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">有几个规则可以应用到游戏中来增加更多的复杂性，但我们将专注于完成游戏的第一次迭代。我们鼓励您针对扩展部分中建议的更复杂的用例来试验和扩展这个解决方案。</p><h2 id="4587" class="ll jv hi bd jw lm ln lo ka lp lq lr ke iq ls lt ki iu lu lv km iy lw lx kq ly bi translated">先决条件</h2><p id="3728" class="pw-post-body-paragraph if ig hi ih b ii ks ik il im kt io ip iq ku is it iu kv iw ix iy kw ja jb jc hb bi translated">我们将假设您以前使用过React，并且熟悉创建组件、状态管理和生命周期方法。<br/>我们也在使用ES6的特性——箭头函数、常量、let语句。你可以查一下<a class="ae jt" href="https://babeljs.io/repl/#?presets=react&amp;code_lz=MYewdgzgLgBApgGzgWzmWBeGAeAFgRgD4AJRBEAGhgHcQAnBAEwEJsB6AwgbgChRJY_KAEMAlmDh0YWRiGABXVOgB0AczhQAokiVQAQgE8AkowAUAcjogQUcwEpeAJTjDgUACIB5ALLK6aRklTRBQ0KCohMQk6Bx4gA" rel="noopener ugc nofollow" target="_blank">巴别塔REPL </a>了解ES6编译成什么。<br/>注意，我们在本教程中使用钩子，因为钩子已经在React版本16.8中引入，所以你需要将16.8作为最小值。本教程的React版本。</p><h1 id="f0b9" class="ju jv hi bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">教程的设置</h1><p id="0868" class="pw-post-body-paragraph if ig hi ih b ii ks ik il im kt io ip iq ku is it iu kv iw ix iy kw ja jb jc hb bi translated">让我们开始吧。<br/>我们想首先创建一个react应用程序。我们可以从头开始创建它，或者使用create-react-app来减少样板代码。在本教程中，我们将使用<a class="ae jt" href="https://reactjs.org/docs/create-a-new-react-app.html" rel="noopener ugc nofollow" target="_blank">创建-反应-应用</a>。</p><pre class="je jf jg jh fd lz ma mb mc aw md bi"><span id="c11e" class="ll jv hi ma b fi me mf l mg mh">npx create-react-app react-hangman<br/>cd react-hangman<br/>npm start</span></pre><p id="d5f1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">上面的代码片段将创建一个带有简单应用程序组件的React应用程序。对于本教程，我们不会关注组件的样式和测试，所以让我们继续删除<code class="du mi mj mk ma b">App.css</code>和<code class="du mi mj mk ma b">App.test.js</code>文件。现在我们可以简单地编辑<code class="du mi mj mk ma b">App.js</code>来包含<code class="du mi mj mk ma b">Hangman</code>组件。<code class="du mi mj mk ma b">Hangman.jsx</code>是我们在本教程中要重点构建的东西。</p><pre class="je jf jg jh fd lz ma mb mc aw md bi"><span id="7b9b" class="ll jv hi ma b fi me mf l mg mh">//App.js<br/>import React from 'react';<br/>import Hangman from './Hangman';<br/><br/>const App = () =&gt; &lt;Hangman /&gt;<br/><br/>export default App;</span></pre><p id="a535" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><a class="ae jt" href="https://github.com/meenakshi-dhanani/react-hangman/commit/3df118d7a3cbf0bf63466d9ad17a2abb39ac9a23" rel="noopener ugc nofollow" target="_blank">查看此时的完整代码</a></p><h1 id="b7f2" class="ju jv hi bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">概观</h1><p id="7679" class="pw-post-body-paragraph if ig hi ih b ii ks ik il im kt io ip iq ku is it iu kv iw ix iy kw ja jb jc hb bi translated">现在你已经准备好了，让我们先来了解一下React钩子。</p><h2 id="564f" class="ll jv hi bd jw lm ln lo ka lp lq lr ke iq ls lt ki iu lu lv km iy lw lx kq ly bi translated">什么是React钩子？</h2><p id="3552" class="pw-post-body-paragraph if ig hi ih b ii ks ik il im kt io ip iq ku is it iu kv iw ix iy kw ja jb jc hb bi translated">在16.8之前，React中的类组件用于管理状态，并且具有跨生命周期方法分布的逻辑。功能组件被用来提取一些常见的用户界面。使用React挂钩，您现在可以挂钩到您的功能组件状态和逻辑，这些状态和逻辑以前会跨生命周期方法传播。相关的逻辑现在可以在一个地方，而不是被分割。通过构建定制的钩子，逻辑也可以跨组件共享。</p><h1 id="aad5" class="ju jv hi bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">构建游戏</h1><p id="2b4b" class="pw-post-body-paragraph if ig hi ih b ii ks ik il im kt io ip iq ku is it iu kv iw ix iy kw ja jb jc hb bi translated">作为第一次迭代的一部分，我们希望显示一个秘密单词，假设我们用__屏蔽了所有字母，我们需要列出所有字母A-Z，以便玩家可以选择一个字母，如果该字母是秘密单词的一部分，它就会显示出来。</p><p id="a661" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">假设暗号是“刽子手”。那么下面的表达式应该将秘密单词屏蔽为:</p><p id="ac27" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi">_ _ _ _ _ _ _</p><pre class="je jf jg jh fd lz ma mb mc aw md bi"><span id="c4ef" class="ll jv hi ma b fi me mf l mg mh">"HANGMAN".split("").fill("_").join(" ")</span></pre><p id="181b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们从一个基本布局开始:</p><pre class="je jf jg jh fd lz ma mb mc aw md bi"><span id="42d0" class="ll jv hi ma b fi me mf l mg mh">//Hangman.jsx<br/>import React from 'react';<br/><br/>export default function Hangman() {<br/>    const word = "HANGMAN";<br/>    const alphabets = ["A", "B", "C", "D", "E", "F", "G",<br/>        "H", "I", "J", "K", "L", "M", "N", "O", "P", "Q", "R",<br/>        "S", "T", "U", "V", "W", "X", "Y", "Z"];<br/><br/>    return  &lt;div&gt;<br/>            &lt;p&gt;{word.split("").fill("_").join(" ")}&lt;/p&gt;<br/>            {alphabets<br/>            .map((alphabet, index) =&gt; <br/>            &lt;button key={index}&gt;{alphabet}&lt;/button&gt;)}<br/>            &lt;/div&gt;<br/>}</span></pre><p id="a453" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在这种状态下，如果你点击按钮，没有任何行动发生。我们的下一步将是点击一个字母表，并猜测该字母是否是单词的一部分。如果字母确实是单词的一部分，它就会显示出来，如果不是，它就不会显示出来。为此，我们需要保存所有正确猜测的字母，以便它们作为秘密单词的一部分显示出来。现在我们有了一个跨组件持久化数据的用例。这就需要国家。让我们看看如何在React中使用状态钩子注入状态。</p><h2 id="2a61" class="ll jv hi bd jw lm ln lo ka lp lq lr ke iq ls lt ki iu lu lv km iy lw lx kq ly bi translated">州钩</h2><p id="56bf" class="pw-post-body-paragraph if ig hi ih b ii ks ik il im kt io ip iq ku is it iu kv iw ix iy kw ja jb jc hb bi translated">我们可以使用状态挂钩将状态注入React中的功能组件。该状态将在组件的重新呈现过程中保留。<code class="du mi mj mk ma b">useState</code>是一个我们可以使用的钩子。<code class="du mi mj mk ma b">useState</code>返回一对状态的当前值和一个允许您设置状态的函数。在类组件中，我们曾经用<code class="du mi mj mk ma b">this.setState</code>做过类似的事情。对于需要保留的不同值，可以在一个组件中使用多个<code class="du mi mj mk ma b">useState</code>。</p><p id="6928" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们需要为Hangman组件保持正确的猜测。让我们使用useState钩子。我们修改了这个单词，对所有尚未猜到的字母显示__。</p><pre class="je jf jg jh fd lz ma mb mc aw md bi"><span id="c253" class="ll jv hi ma b fi me mf l mg mh">import React, {useState} from 'react';<br/><br/>export default function Hangman() {<br/>    const word = "HANGMAN";<br/>    const alphabets = ["A", "B", "C", "D", "E", "F", "G",<br/>        "H", "I", "J", "K", "L", "M", "N", "O", "P", "Q", "R",<br/>        "S", "T", "U", "V", "W", "X", "Y", "Z"];<br/>    const [correctGuesses, setCorrectGuesses] = useState([])    <br/><br/>    const maskedWord = word.split('').map(letter =&gt; <br/>    correctGuesses.includes(letter) ? letter : "_").join(" ");<br/><br/>    return  &lt;div&gt;<br/>            &lt;p&gt;{maskedWord}&lt;/p&gt;<br/>            {alphabets<br/>            .map((alphabet, index) =&gt; <br/>            &lt;button key={index} onClick={() =&gt; {<br/>                if (word.includes(alphabet)) {<br/>                    setCorrectGuesses([...correctGuesses, alphabet])<br/>                }<br/>            }}&gt;{alphabet}&lt;/button&gt;)}<br/>            {!maskedWord.includes("_") &amp;&amp; &lt;p&gt;You won!&lt;/p&gt;}<br/>            &lt;/div&gt;<br/>}</span></pre><h1 id="c963" class="ju jv hi bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">添加时间限制</h1><p id="6463" class="pw-post-body-paragraph if ig hi ih b ii ks ik il im kt io ip iq ku is it iu kv iw ix iy kw ja jb jc hb bi translated">现在我们有了一个公平可行的解决方案，让我们给这个游戏添加一些规则。我们最多有2分钟的时间来猜这个单词，如果在2分钟内没有猜中，我们将显示“游戏结束”。</p><p id="b255" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在这种情况下，我们需要注入一个超时。超时会影响这场比赛的结果。让我们看看效果挂钩，以了解如何在组件中添加超时逻辑。</p><h2 id="702a" class="ll jv hi bd jw lm ln lo ka lp lq lr ke iq ls lt ki iu lu lv km iy lw lx kq ly bi translated">效果挂钩</h2><p id="45e7" class="pw-post-body-paragraph if ig hi ih b ii ks ik il im kt io ip iq ku is it iu kv iw ix iy kw ja jb jc hb bi translated">效果挂钩是React中另一个最常用的挂钩。它接受一个函数(效果),当它的任何一个因变量改变时，这个函数就会运行。effect(副作用的缩写)钩子，用于管理组件上的任何副作用——操作DOM元素、获取数据、订阅等。在我们的例子中，我们将使用<code class="du mi mj mk ma b">useEffect</code>来设置超时。默认情况下，<code class="du mi mj mk ma b">useEffect</code>为每个组件渲染运行，除非我们提到<code class="du mi mj mk ma b">[]</code>作为它的参数，在这种情况下，它只在组件的第一次渲染期间运行。</p><pre class="je jf jg jh fd lz ma mb mc aw md bi"><span id="00a9" class="ll jv hi ma b fi me mf l mg mh">import React, { useEffect, useState } from 'react';<br/><br/>export default function Hangman({duration = 120000}) {<br/>    const word = "Hangman".toUpperCase();<br/>    const alphabets = ["A", "B", "C", "D", "E", "F", "G",<br/>        "H", "I", "J", "K", "L", "M", "N", "O", "P", "Q", "R",<br/>        "S", "T", "U", "V", "W", "X", "Y", "Z"];<br/>    const [correctGuesses, setCorrectGuesses] = useState([])<br/>    const [timeUp, setTimeUp] = useState(false);<br/><br/>    useEffect(() =&gt; {<br/>        const timeout = setTimeout(() =&gt; {<br/>            setTimeUp(true);<br/>        }, duration);<br/><br/>        return () =&gt; clearTimeout(timeout);<br/>    }, [])<br/><br/><br/>    const maskedWord = word.split('').map(letter =&gt; correctGuesses.includes(letter) ? letter : "_").join(" ");<br/>    return (<br/>        &lt;div&gt;<br/>            &lt;p&gt;{maskedWord}&lt;/p&gt;<br/>            {alphabets.map((alphabet, index) =&gt; &lt;button key={index} onClick={() =&gt; {<br/>                if (word.includes(alphabet)) {<br/>                    setCorrectGuesses([...correctGuesses, alphabet])<br/>                }<br/>            }}&gt;{alphabet}&lt;/button&gt;)}<br/>            {timeUp ? <br/>            &lt;p&gt;You lost!&lt;/p&gt; : <br/>            !maskedWord.includes("_") &amp;&amp;  &lt;p&gt;You won!&lt;/p&gt;}<br/>        &lt;/div&gt;<br/>    );<br/>}</span></pre><p id="c742" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">注意我们是如何使用<code class="du mi mj mk ma b">useState</code>来保存timeUp的状态的。在<code class="du mi mj mk ma b">useEffect</code>的第二个参数中我们提到了<code class="du mi mj mk ma b">[]</code>，所以超时只在Hangman第一次渲染的时候设置。最后，当组件在游戏结束后卸载时，我们在<code class="du mi mj mk ma b">return () =&gt; clearTimeout(timeout)</code>中清除效果。这可以用来退订，清理所用资源的效果。</p><h1 id="b7ad" class="ju jv hi bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">包扎</h1><p id="6674" class="pw-post-body-paragraph if ig hi ih b ii ks ik il im kt io ip iq ku is it iu kv iw ix iy kw ja jb jc hb bi translated">恭喜你！你有一个刽子手游戏:</p><ul class=""><li id="e817" class="kx ky hi ih b ii ij im in iq kz iu la iy lb jc lc ld le lf bi translated">我们来玩刽子手吧</li><li id="d5c4" class="kx ky hi ih b ii lg im lh iq li iu lj iy lk jc lc ld le lf bi translated">有一个时间上限让你猜</li></ul><p id="bd1e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们希望你已经掌握了基本的钩子。</p><p id="8983" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">本教程试图让你开始使用react钩子。我们将进一步鼓励你探索更多的钩子，例如，使用上下文，使用历史，创建你自己的定制钩子。等等。点击查看挂钩<a class="ae jt" href="https://reactjs.org/docs/hooks-overview.html" rel="noopener ugc nofollow" target="_blank">的详细说明。</a></p><p id="c121" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">有很多规则可以应用，游戏可以进一步扩展。对你来说，用钩子试试这些功能部件是一个很好的练习。</p><ul class=""><li id="505a" class="kx ky hi ih b ii ij im in iq kz iu la iy lb jc lc ld le lf bi translated">最多允许猜测6次</li><li id="909d" class="kx ky hi ih b ii lg im lh iq li iu lj iy lk jc lc ld le lf bi translated">显示计时器的剩余时间</li><li id="cbd3" class="kx ky hi ih b ii lg im lh iq li iu lj iy lk jc lc ld le lf bi translated">限制对元音的猜测</li><li id="3e7b" class="kx ky hi ih b ii lg im lh iq li iu lj iy lk jc lc ld le lf bi translated">获取基于主题的单词列表</li></ul><p id="51c7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">你可以在<a class="ae jt" href="https://github.com/meenakshi-dhanani/react-hangman" rel="noopener ugc nofollow" target="_blank">这个</a>资源库中找到游戏的完整源代码。</p></div></div>    
</body>
</html>