<html>
<head>
<title>What are XPath Injections and How to Avoid Them</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">什么是 XPath 注入以及如何避免它们</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/what-are-xpath-injections-and-how-to-avoid-them-2d656b850293?source=collection_archive---------3-----------------------#2022-01-26">https://medium.com/nerd-for-tech/what-are-xpath-injections-and-how-to-avoid-them-2d656b850293?source=collection_archive---------3-----------------------#2022-01-26</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/9a281a0d5ffff41ce56227c845af19fa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*CELTJlNznH7ORfr0"/></div></div></figure><p id="311c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">XML 是网络服务的语言。当我们调用一个服务或从它那里得到响应时，我们发送/接收的所有信息都是 XML 格式的。服务的数据结构及其接口都是用 XML 定义的。</p><p id="19e7" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">XPath 或 XML Path 是 Java 中包含的一个库，用于计算 XML 文档中的表达式。同时，它是定义这些表达式的语言，并且依赖于<a class="ae jo" href="https://www.w3.org/" rel="noopener ugc nofollow" target="_blank"> W3C 联盟</a>(因此与网络本身相关联，而不是任何特定的编程语言)。</p><h1 id="c26e" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">XPath:构建表达式</h1><p id="0d22" class="pw-post-body-paragraph iq ir hi is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hb bi translated">在 XPath 中，XML 文档被当作树型结构来计算。每个 XML 元素称为一个节点(当存在嵌套时，我们称之为子节点，但它们本身仍然是节点)，我们必须遵循的到达特定节点的路径称为路径。XPath 定义了选择器的范围(/，..、@等。)和运算符(and、or、&gt;、≥、</p><pre class="ks kt ku kv fd kw kx ky kz aw la bi"><span id="ea87" class="lb jq hi kx b fi lc ld l le lf">/root/node</span></pre><p id="ab6e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">Extrapolating it to our XML document of parking spaces:</p><pre class="ks kt ku kv fd kw kx ky kz aw la bi"><span id="31f1" class="lb jq hi kx b fi lc ld l le lf">/parking/plaza</span></pre><p id="4d5f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">The previous expression will reach all the <plaza>元素。现在，让我们想象一下，我们想要更有选择性，只接触车牌:</plaza></p><pre class="ks kt ku kv fd kw kx ky kz aw la bi"><span id="c244" class="lb jq hi kx b fi lc ld l le lf">/parking/plaza/registration</span></pre><p id="03f0" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">但是 XPath 更加强大。使用下面的表达式，我们可以过滤所有到期日在特定日期的方块:</p><pre class="ks kt ku kv fd kw kx ky kz aw la bi"><span id="98b8" class="lb jq hi kx b fi lc ld l le lf">/parking/plaza [expiration = ’04 -12–2021 ‘]</span></pre><p id="19b0" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如果我们想进一步过滤所获得的信息，我们可以指出，一旦按截止日期过滤完成，它只返回所有者的姓名:</p><pre class="ks kt ku kv fd kw kx ky kz aw la bi"><span id="4e66" class="lb jq hi kx b fi lc ld l le lf">/parking/space [expiration = ’04 -12–2021 ‘] /owner</span></pre><p id="2f67" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们还可以通过索引选择一个节点:在 XML 树中的位置(记住，这些是基于 1 的索引，不像数组和索引是基于 0 的):</p><p id="cc9a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><code class="du lg lh li kx b">/ parking / square [1]</code></p><h1 id="f159" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">XPath 注入</h1><p id="6fe4" class="pw-post-body-paragraph iq ir hi is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hb bi translated">让我们使用<a class="ae jo" href="https://www.w3schools.com/js/js_htmldom.asp" rel="noopener ugc nofollow" target="_blank"> DOM </a>来重新创建 XML 树和 XPath 来计算表达式。最终结果将是一个节点列表，我们已经迭代过这些节点，以在控制台上显示每个节点的内容。</p><pre class="ks kt ku kv fd kw kx ky kz aw la bi"><span id="950b" class="lb jq hi kx b fi lc ld l le lf">import java.io.IOException;</span><span id="9b8d" class="lb jq hi kx b fi lj ld l le lf">import javax.xml.parsers.DocumentBuilder;</span><span id="86ca" class="lb jq hi kx b fi lj ld l le lf">import javax.xml.parsers.DocumentBuilderFactory;</span><span id="ac85" class="lb jq hi kx b fi lj ld l le lf">import javax.xml.parsers.ParserConfigurationException;</span><span id="1b98" class="lb jq hi kx b fi lj ld l le lf">import javax.xml.xpath.XPath;</span><span id="2055" class="lb jq hi kx b fi lj ld l le lf">import javax.xml.xpath.XPathConstants;</span><span id="6c93" class="lb jq hi kx b fi lj ld l le lf">import javax.xml.xpath.XPathExpressionException;</span><span id="cace" class="lb jq hi kx b fi lj ld l le lf">import javax.xml.xpath.XPathFactory;</span><span id="2106" class="lb jq hi kx b fi lj ld l le lf">import org.w3c.dom.Document;</span><span id="6b0f" class="lb jq hi kx b fi lj ld l le lf">import org.w3c.dom.NodeList;</span><span id="7d03" class="lb jq hi kx b fi lj ld l le lf">import org.xml.sax.SAXException;</span><span id="30b0" class="lb jq hi kx b fi lj ld l le lf">public class Evaluator {</span><span id="4c9e" class="lb jq hi kx b fi lj ld l le lf">public NodeList filterNodes (String expression, String XMLDocumentpath) {</span><span id="83ce" class="lb jq hi kx b fi lj ld l le lf">NodeList nodesResult = null;</span><span id="7f1a" class="lb jq hi kx b fi lj ld l le lf">try {</span><span id="c57e" class="lb jq hi kx b fi lj ld l le lf">DocumentBuilderFactory dBuilderFactory = DocumentBuilderFactory.newInstance ();</span><span id="cfab" class="lb jq hi kx b fi lj ld l le lf">DocumentBuilder dBuilder = dBuilderFactory.newDocumentBuilder ();</span><span id="4baa" class="lb jq hi kx b fi lj ld l le lf">DocumentXML document = dBuilder.parse (pathXMLDocument);</span><span id="bfa1" class="lb jq hi kx b fi lj ld l le lf">XPath xpath = XPathFactory.newInstance (). NewXPath ();</span><span id="16d6" class="lb jq hi kx b fi lj ld l le lf">nodesResult = (NodeList) xpath.evaluate (expression, XML document, XPathConstants.NODESET);</span><span id="c020" class="lb jq hi kx b fi lj ld l le lf">} catch (ParserConfigurationException ex) {</span><span id="aa8d" class="lb jq hi kx b fi lj ld l le lf">ex.printStackTrace ();</span><span id="8c66" class="lb jq hi kx b fi lj ld l le lf">} catch (SAXException ex) {</span><span id="4a15" class="lb jq hi kx b fi lj ld l le lf">ex.printStackTrace ();</span><span id="6eb5" class="lb jq hi kx b fi lj ld l le lf">} catch (IOException ex) {</span><span id="de14" class="lb jq hi kx b fi lj ld l le lf">ex.printStackTrace ();</span><span id="d2d2" class="lb jq hi kx b fi lj ld l le lf">} catch (XPathExpressionException ex) {</span><span id="8148" class="lb jq hi kx b fi lj ld l le lf">ex.printStackTrace ();</span><span id="7447" class="lb jq hi kx b fi lj ld l le lf">}</span><span id="4de8" class="lb jq hi kx b fi lj ld l le lf">return nodesResult;</span><span id="d00c" class="lb jq hi kx b fi lj ld l le lf">}</span><span id="a18d" class="lb jq hi kx b fi lj ld l le lf">public static void main (String [] args) {</span><span id="9e39" class="lb jq hi kx b fi lj ld l le lf">Evaluator evaluator = new Evaluator ();</span><span id="5309" class="lb jq hi kx b fi lj ld l le lf">NodeList nodes = evaluator.filterNodes (“/ parking / plaza”, “parking.xml”);</span><span id="0506" class="lb jq hi kx b fi lj ld l le lf">for (int i = 0; i &lt;nodes.getLength (); i ++) {</span><span id="ad85" class="lb jq hi kx b fi lj ld l le lf">System.out.println (nodes.item (i) .getTextContent ());</span><span id="c1a0" class="lb jq hi kx b fi lj ld l le lf">}</span><span id="f3d3" class="lb jq hi kx b fi lj ld l le lf">}</span><span id="9762" class="lb jq hi kx b fi lj ld l le lf">}</span></pre><p id="2a1b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在，设想下面的方法，通过车牌号获取一个座位的数据。</p><pre class="ks kt ku kv fd kw kx ky kz aw la bi"><span id="f18c" class="lb jq hi kx b fi lc ld l le lf">public NodeList getPlazaPlatenumber (String platenumber) {</span><span id="561e" class="lb jq hi kx b fi lj ld l le lf">// …</span><span id="df3a" class="lb jq hi kx b fi lj ld l le lf">String expression = “/ parking / plaza [registration = ‘“ + registration + “‘“, “parking.xml”;</span><span id="f913" class="lb jq hi kx b fi lj ld l le lf">return (NodeList) xpath.evaluate (expression, XML document, XPathConstants.NODESET);</span><span id="31ef" class="lb jq hi kx b fi lj ld l le lf">}</span></pre><p id="363b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如果我们将一个现有的车牌作为参数传递，它将返回所需的信息。如果车牌不存在，它将返回一个空列表。但是如果参数板号包含恶意值呢？</p><pre class="ks kt ku kv fd kw kx ky kz aw la bi"><span id="cfa6" class="lb jq hi kx b fi lc ld l le lf">‘or 1 = 1 or’</span></pre><p id="ff3b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">将前面的字符串作为参数值板号传递返回的结果将是所有方格的信息，这显然是信息泄露。</p><pre class="ks kt ku kv fd kw kx ky kz aw la bi"><span id="bdb3" class="lb jq hi kx b fi lc ld l le lf">AAA-1111</span><span id="30a1" class="lb jq hi kx b fi lj ld l le lf">John</span><span id="dc05" class="lb jq hi kx b fi lj ld l le lf">111–88–88</span><span id="d75c" class="lb jq hi kx b fi lj ld l le lf">04–12–2021</span><span id="16f7" class="lb jq hi kx b fi lj ld l le lf">BBB-2222</span><span id="2a09" class="lb jq hi kx b fi lj ld l le lf">Draz</span><span id="8ec0" class="lb jq hi kx b fi lj ld l le lf">111–64–64</span><span id="63e2" class="lb jq hi kx b fi lj ld l le lf">03–21–2021</span><span id="17a9" class="lb jq hi kx b fi lj ld l le lf">CCC-3333</span><span id="5b8b" class="lb jq hi kx b fi lj ld l le lf">James</span><span id="b678" class="lb jq hi kx b fi lj ld l le lf">111–22–22</span><span id="0576" class="lb jq hi kx b fi lj ld l le lf">01–10–2021</span></pre><p id="33c4" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">发生了什么事？</p><p id="f0af" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">非常简单:通过不验证表达式，我们并不新的方法使我们能够构建复杂的表达式。在我们的例子中，我们构造了一个条件表达式，其中有三个条件，由两个操作符“or”、“包含适当的引号以便表达式有效”和“编译器不抛出语法异常”:</p><pre class="ks kt ku kv fd kw kx ky kz aw la bi"><span id="d561" class="lb jq hi kx b fi lc ld l le lf">/parking/plaza [platenumber = ‘’ or 1 = 1 or ‘’]</span></pre><figure class="ks kt ku kv fd ij er es paragraph-image"><div class="er es lk"><img src="../Images/7c1ac01253a1655a93ee3ea6216eb644.png" data-original-src="https://miro.medium.com/v2/resize:fit:1398/0*lXF3cPFmYn5hnt1z"/></div><figcaption class="ll lm et er es ln lo bd b be z dx translated"><a class="ae jo" href="https://www.ws-attacks.org/Xpath_Injection" rel="noopener ugc nofollow" target="_blank"> Ws 攻击</a></figcaption></figure><p id="c246" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">第一个和第三个条件返回 false，但第二个条件返回 true。因此，表达式的全局结果对于所有元素<em class="lp"> &lt; platenumber &gt; </em>的值也是正确的。因此，机密信息被返回，这可能使开发人员损失数百万美元，并危及消费者隐私。</p><p id="9e73" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">一种解决方案是根据适当的正则表达式验证牌照，并使程序仅在肯定验证的情况下执行调用。在数字参数的情况下，解决方案要简单得多，因为对<em class="lp"> Integer.parseInt()或 Float.parseFloat() </em>的调用如果没有接收到这些类型之一，就会抛出异常。</p><p id="5dd9" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">使用 SQL 时，必须验证 XPath 表达式，以避免 XPath 注入攻击。使用<a class="ae jo" href="https://www.whitesourcesoftware.com/whitesource-cure/#:~:text=WhiteSource%20Cure%20is%20the%20first,and%20speed%20when%20releasing%20software." rel="noopener ugc nofollow" target="_blank"> WS Cure </a>，一个可以集成到您的开发环境中的免费自动修复应用程序，您可以解决这个问题和许多其他安全问题。这可以极大地提高你的团队的生产力，因为你只需要专注于发布软件。</p><h1 id="50f5" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">使用 WhiteSource 固化</h1><p id="b76c" class="pw-post-body-paragraph iq ir hi is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hb bi translated">使用 WhiteSource Cure 查找 Xpath 漏洞非常简单。它包括两个步骤。</p><ol class=""><li id="ec1a" class="lq lr hi is b it iu ix iy jb ls jf lt jj lu jn lv lw lx ly bi translated">将链接复制到您的 GitHub repo。在这个例子中，我将使用<a class="ae jo" href="https://github.com/WebGoat/WebGoat-Legacy" rel="noopener ugc nofollow" target="_blank"> WebGoat Legacy </a>，这是一个故意不安全的 JavaEE 应用程序，用于测试目的。</li></ol><figure class="ks kt ku kv fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lz"><img src="../Images/4010ceaf61e1473fe76993450990f1c9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*6c_YPN8SBePSmYAW"/></div></div></figure><p id="f4ab" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">2.在白源固化<a class="ae jo" href="https://cure.whitesource.io/" rel="noopener ugc nofollow" target="_blank">网页</a>上粘贴你要测试的回购的链接。</p><figure class="ks kt ku kv fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ma"><img src="../Images/babfbf3963a22428fbe819ffae7eab15.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*0vUYWklDb0o_kfhk"/></div></div></figure><p id="4939" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">3.接下来，WhiteSource Cure 向您展示了回购中所有漏洞的列表。如果您想要检查任何特定的漏洞，只需点击它即可。在我们的例子中，我们对 Xpath 注入感兴趣。因此，我们将点击它。您可以通过单击“补救”选项卡查看 WhiteSource Cure 建议的修复:</p><figure class="ks kt ku kv fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mb"><img src="../Images/c6afe6dae29aea603bb27aee31c490ac.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*uJ1W01-6Su6dnFVc"/></div></div></figure><h1 id="4ee2" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">结论</h1><p id="b7ca" class="pw-post-body-paragraph iq ir hi is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hb bi translated">像所有的注入攻击一样，Xpath 注入会引起问题，修复起来非常困难和耗时。然而，了解您可以使用的所有工具可以使任务变得简单得多。确保尝试我今天提到的解决方案，并且不要忘记让我知道你的经历。</p><p id="8305" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我希望这对你有所帮助！</p></div></div>    
</body>
</html>