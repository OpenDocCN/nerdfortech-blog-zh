<html>
<head>
<title>How to Use State in React Without Classes: The State Hook</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在没有类的情况下使用 React 中的状态:状态挂钩</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/how-to-use-state-in-react-without-classes-the-state-hook-73882d0dc188?source=collection_archive---------11-----------------------#2021-04-05">https://medium.com/nerd-for-tech/how-to-use-state-in-react-without-classes-the-state-hook-73882d0dc188?source=collection_archive---------11-----------------------#2021-04-05</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="a436" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">无类组件(又名函数组件)和状态:语法和示例快速概述</h2></div><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ix"><img src="../Images/f285504ebe3c17efbd0d6017af02456f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JbjnUYcQBLFD2VtlLizS3A.png"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">州钩例子来自:https://reactjs.org/docs/hooks-overview.html</figcaption></figure><h2 id="16e7" class="jn jo hi bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">什么是钩子？</h2><p id="4b16" class="pw-post-body-paragraph kl km hi kn b ko kp ij kq kr ks im kt jy ku kv kw kc kx ky kz kg la lb lc ld hb bi translated">在 2019 年 2 月发布的 React 16.8 之前，如果你想在 React 组件中使用<strong class="kn hj">状态</strong>，你必须将现有代码从函数组件重构为类组件。然而，在这次 React 更新中，您可以选择使用<strong class="kn hj">挂钩</strong> <em class="le">、</em>或“f <a class="ae lf" href="https://reactjs.org/docs/hooks-overview.html#but-what-is-a-hook" rel="noopener ugc nofollow" target="_blank">功能，让您“挂钩”React 状态</a>和功能组件的生命周期特性本文主要关注挂钩到状态，但是也有其他可用的挂钩，例如，如果您想访问函数组件中的生命周期方法，您可以选择<a class="ae lf" href="https://reactjs.org/docs/hooks-overview.html#effect-hook" rel="noopener ugc nofollow" target="_blank">效果挂钩</a>。您可能习惯于在您的类组件中使用生命周期方法，如<code class="du lg lh li lj b">componentDidMount</code>和<code class="du lg lh li lj b">componentDidUpdate</code>。状态挂钩允许您在不使用类组件的情况下挂钩到状态功能，而效果挂钩允许您以同样的方式挂钩到生命周期功能。</p><h2 id="2bd9" class="jn jo hi bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">为什么要改变？</h2><p id="91c0" class="pw-post-body-paragraph kl km hi kn b ko kp ij kq kr ks im kt jy ku kv kw kc kx ky kz kg la lb lc ld hb bi translated"><a class="ae lf" href="https://reactjs.org/docs/hooks-intro.html#motivation" rel="noopener ugc nofollow" target="_blank">根据 React 团队的说法</a>将钩子引入框架有很多原因。这超出了本文的范围，我鼓励您阅读 React 文档，以便更好地理解钩子可以提供什么。要注意的最重要的一点是，使用钩子是完全向后兼容的，这意味着如果您选择在代码中添加或更改一个或几个组件来使用和测试它们，它不会破坏您现有的代码。此外，在撰写本文时，React 团队还没有从 React 中移除类的计划。钩子不一定要取代类组件，但是它们的目的是解决程序员在设计具有大量组件和复杂组件层次结构的项目时遇到的一些问题。</p><h2 id="519b" class="jn jo hi bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">代码示例:旧方法和新方法</h2><p id="61df" class="pw-post-body-paragraph kl km hi kn b ko kp ij kq kr ks im kt jy ku kv kw kc kx ky kz kg la lb lc ld hb bi translated">让我们回忆一下，在 React 中，我们的组件是受控制的，这意味着它们从不直接从 DOM 读取，而是使用 state 来管理用户一个字符一个字符地输入到表单中的内容。在下面的例子中，我为一个简单的联系人表单使用了一个带有 state 的类组件，用户在这个表单中输入他们的姓名、电子邮件以及他们想发送给网站管理员的消息:</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="lk ll l"/></div></figure><p id="8d6f" class="pw-post-body-paragraph kl km hi kn b ko lm ij kq kr ln im kt jy lo kv kw kc lp ky kz kg lq lb lc ld hb bi translated">在本例中，这段代码不会通过电子邮件或任何其他动作提交表单，而是只提醒用户他们输入的信息已经提交。同样，我们使用一个受控制的组件，其中表单的内容随着用户使用 state 和<code class="du lg lh li lj b">changeHandler</code>函数输入而更新，并使用<code class="du lg lh li lj b">submitHandler </code>函数提交，该函数防止表单发出新的网络请求和重新呈现整个页面的默认行为，提醒用户表单已经提交，并将表单字段重置为空字符串。让我们看一下被重构为使用带有状态挂钩的函数组件的完全相同的组件:</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="lk ll l"/></div></figure><p id="555c" class="pw-post-body-paragraph kl km hi kn b ko lm ij kq kr ln im kt jy lo kv kw kc lp ky kz kg lq lb lc ld hb bi translated">让我们回顾一下这两个组件之间的一些基本区别:</p><ol class=""><li id="3665" class="lr ls hi kn b ko lm kr ln jy lt kc lu kg lv ld lw lx ly lz bi translated">看看我们的 import 语句，除了<code class="du lg lh li lj b">React</code>(第 1 行)之外，我们还导入了<code class="du lg lh li lj b">useState</code>。</li><li id="3417" class="lr ls hi kn b ko ma kr mb jy mc kc md kg me ld lw lx ly lz bi translated">使用 JavaScript 的<strong class="kn hj">数组析构</strong>，我们用<code class="du lg lh li lj b">useState</code>创建一个新的状态变量，例如<code class="du lg lh li lj b">name</code>，其中第一项是当前值，第二项是一个让我们更新该状态变量的函数。我们对<code class="du lg lh li lj b">email</code>和<code class="du lg lh li lj b">message</code>状态变量做了同样的处理(第 5–7 行)。</li><li id="0c32" class="lr ls hi kn b ko ma kr mb jy mc kc md kg me ld lw lx ly lz bi translated">注意表单输入元素中的<strong class="kn hj">值</strong>属性不再引用<code class="du lg lh li lj b">{this.state.name}</code>、<code class="du lg lh li lj b">{this.state.email}</code>和<code class="du lg lh li lj b">{this.state.message}</code>，而是直接引用带有<code class="du lg lh li lj b">{name}</code>、<code class="du lg lh li lj b">{email}</code>和<code class="du lg lh li lj b">{message}</code>的状态变量(第 24、26、28 行)。</li><li id="cd15" class="lr ls hi kn b ko ma kr mb jy mc kc md kg me ld lw lx ly lz bi translated">最后，虽然我们仍然使用一个<code class="du lg lh li lj b">submitHandler</code>，但是我们的代码中不再有<code class="du lg lh li lj b">changeHandler</code>，我们可以在表单输入元素的<code class="du lg lh li lj b">onChange</code>属性中直接调用状态变量的更新函数作为回调函数(第 24、26、28 行)。</li></ol><h2 id="3394" class="jn jo hi bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">进一步的考虑</h2><p id="c398" class="pw-post-body-paragraph kl km hi kn b ko kp ij kq kr ks im kt jy ku kv kw kc kx ky kz kg la lb lc ld hb bi translated">一段时间以来，React 没有提供一种方法来有效地在组件之间共享状态，而不需要通过每个单独的子组件手动传递属性，并且将这些属性传递给不直接相关的组件既麻烦又难以跟踪。你可能熟悉试图解决这个问题的状态管理库，比如<a class="ae lf" href="https://redux.js.org/" rel="noopener ugc nofollow" target="_blank"> Redux </a>。使用 React 钩子和使用本地<a class="ae lf" href="https://reactjs.org/docs/context.html" rel="noopener ugc nofollow" target="_blank"> React 上下文 API </a>，外部库不是必需的，我将在下一篇文章中介绍上下文，敬请关注！</p><h2 id="ca26" class="jn jo hi bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated"><strong class="ak">参考资料和附加资源</strong></h2><ul class=""><li id="462d" class="lr ls hi kn b ko kp kr ks jy mf kc mg kg mh ld mi lx ly lz bi translated"><a class="ae lf" href="https://reactjs.org/docs/hooks-overview.html" rel="noopener ugc nofollow" target="_blank">挂钩概述</a></li><li id="b521" class="lr ls hi kn b ko ma kr mb jy mc kc md kg me ld mi lx ly lz bi translated"><a class="ae lf" href="https://reactjs.org/docs/hooks-state.html" rel="noopener ugc nofollow" target="_blank">使用状态挂钩</a></li><li id="f0e2" class="lr ls hi kn b ko ma kr mb jy mc kc md kg me ld mi lx ly lz bi translated"><a class="ae lf" href="https://reactjs.org/docs/hooks-overview.html#effect-hook" rel="noopener ugc nofollow" target="_blank">效果挂钩</a></li><li id="ccfd" class="lr ls hi kn b ko ma kr mb jy mc kc md kg me ld mi lx ly lz bi translated"><a class="ae lf" href="https://reactjs.org/docs/hooks-intro.html#motivation" rel="noopener ugc nofollow" target="_blank">为什么要挂钩？</a></li><li id="6cc6" class="lr ls hi kn b ko ma kr mb jy mc kc md kg me ld mi lx ly lz bi translated"><a class="ae lf" href="https://redux.js.org/" rel="noopener ugc nofollow" target="_blank"> Redux </a></li><li id="3513" class="lr ls hi kn b ko ma kr mb jy mc kc md kg me ld mi lx ly lz bi translated"><a class="ae lf" href="https://reactjs.org/docs/context.html" rel="noopener ugc nofollow" target="_blank">上下文 API </a></li></ul></div></div>    
</body>
</html>