<html>
<head>
<title>IDamageable interface | Unity</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">I可成像界面| Unity</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/idamageable-interface-unity-45bf961d141?source=collection_archive---------1-----------------------#2021-10-14">https://medium.com/nerd-for-tech/idamageable-interface-unity-45bf961d141?source=collection_archive---------1-----------------------#2021-10-14</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><h2 id="4508" class="hg hh hi bd b fp hj hk hl hm hn ho dx hp translated" aria-label="kicker paragraph">统一指南</h2><div class=""/><div class=""><h2 id="e124" class="pw-subtitle-paragraph io hr hi bd b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf dx translated">关于如何在Unity中实现IDamageable接口的快速指南</h2></div><figure class="jh ji jj jk fd jl er es paragraph-image"><div role="button" tabindex="0" class="jm jn di jo bf jp"><div class="er es jg"><img src="../Images/7044bc4e24c91e7e651757f505cb1f2d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*ZkmOs-wtHOp9gbakV6uZOg.gif"/></div></div></figure><p id="b064" class="pw-post-body-paragraph js jt hi ju b jv jw is jx jy jz iv ka kb kc kd ke kf kg kh ki kj kk kl km kn hb bi translated"><strong class="ju hs">目标</strong>:在2D游戏的敌人中实现一个IDamageable接口，以指示他们有生命值并且是可伤害的。</p><p id="a59b" class="pw-post-body-paragraph js jt hi ju b jv jw is jx jy jz iv ka kb kc kd ke kf kg kh ki kj kk kl km kn hb bi translated">在上一篇文章中，我介绍了<a class="ae ko" rel="noopener" href="/nerd-for-tech/using-abstract-classes-to-design-enemies-unity-60c39c793a66">如何在Unity中使用抽象类来设计敌人。现在，为了让玩家知道敌人是易受伤害的，是时候使用界面了。</a></p><h1 id="f258" class="kp kq hi bd kr ks kt ku kv kw kx ky kz ix la iy lb ja lc jb ld jd le je lf lg bi translated">当前的敌人</h1><p id="4f6f" class="pw-post-body-paragraph js jt hi ju b jv lh is jx jy li iv ka kb lj kd ke kf lk kh ki kj ll kl km kn hb bi translated">首先，让我们看看2D游戏中的敌人。目前，我们有一个苔藓巨人，一个蜘蛛和一个骷髅在关卡的特定区域巡逻:</p><figure class="jh ji jj jk fd jl er es paragraph-image"><div role="button" tabindex="0" class="jm jn di jo bf jp"><div class="er es jg"><img src="../Images/dd28eac05eff454b69f61c6248803f12.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*4YgXabWtYpxKMscGACR29A.gif"/></div></div></figure><div class="jh ji jj jk fd ab cb"><figure class="lm jl ln lo lp lq lr paragraph-image"><div role="button" tabindex="0" class="jm jn di jo bf jp"><img src="../Images/6854874bed0d26fc698f7f8b9a6eb3bf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/1*KVMUixUr2S0J-tOFGz9veQ.gif"/></div></figure><figure class="lm jl ln lo lp lq lr paragraph-image"><div role="button" tabindex="0" class="jm jn di jo bf jp"><img src="../Images/69eb5a79267d1664f7b7d977459fe1a9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/1*OLQMRtmxjGZla2prhnNv-Q.gif"/></div></figure></div><h1 id="5a8a" class="kp kq hi bd kr ks kt ku kv kw kx ky kz ix la iy lb ja lc jb ld jd le je lf lg bi translated">可成像接口</h1><p id="6e2a" class="pw-post-body-paragraph js jt hi ju b jv lh is jx jy li iv ka kb lj kd ke kf lk kh ki kj ll kl km kn hb bi translated">现在，为了表明某些游戏对象是可破坏的(比如我们的敌人)，让我们创建一个名为IDamageable的新C#脚本:</p><figure class="jh ji jj jk fd jl er es paragraph-image"><div class="er es ls"><img src="../Images/6b656d2dd5b2c9ceeb45ee8995540261.png" data-original-src="https://miro.medium.com/v2/resize:fit:1028/1*y2AS9lYHakRsxsLdwxM60g.gif"/></div></figure><p id="2bbe" class="pw-post-body-paragraph js jt hi ju b jv jw is jx jy jz iv ka kb kc kd ke kf kg kh ki kj kk kl km kn hb bi translated">创建完成后，让我们打开脚本，将IDamageable类修改为interface类型:</p><blockquote class="lt lu lv"><p id="85f5" class="js jt lw ju b jv jw is jx jy jz iv ka lx kc kd ke ly kg kh ki lz kk kl km kn hb bi translated">注意:一个<strong class="ju hs">id imageable</strong><strong class="ju hs">接口</strong>将允许我们<strong class="ju hs">强制</strong>某些类实现处理损坏所需的<strong class="ju hs">属性</strong>和/或<strong class="ju hs">方法</strong>。</p></blockquote><figure class="jh ji jj jk fd jl er es paragraph-image"><div class="er es ma"><img src="../Images/7696217da7f8a684429e07be7c9aa6b9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1366/1*Ue2aX1pGiM5Fi2VV0lb5iw.gif"/></div></figure><p id="29d4" class="pw-post-body-paragraph js jt hi ju b jv jw is jx jy jz iv ka kb kc kd ke kf kg kh ki kj kk kl km kn hb bi translated">然后，让我们声明一个新的属性和一个方法来处理某些职业的伤害，比如敌人:</p><ul class=""><li id="7e04" class="mb mc hi ju b jv jw jy jz kb md kf me kj mf kn mg mh mi mj bi translated">健康</li></ul><p id="af1c" class="pw-post-body-paragraph js jt hi ju b jv jw is jx jy jz iv ka kb kc kd ke kf kg kh ki kj kk kl km kn hb bi translated">这个属性将决定每个职业的健康程度。</p><ul class=""><li id="9844" class="mb mc hi ju b jv jw jy jz kb md kf me kj mf kn mg mh mi mj bi translated">损害</li></ul><p id="c27e" class="pw-post-body-paragraph js jt hi ju b jv jw is jx jy jz iv ka kb kc kd ke kf kg kh ki kj kk kl km kn hb bi translated">这种方法会照顾到类内健康的损害应用。</p><figure class="jh ji jj jk fd jl er es paragraph-image"><div class="er es mk"><img src="../Images/32c77b87b91825a479e37b2ca98f7c20.png" data-original-src="https://miro.medium.com/v2/resize:fit:1022/format:webp/1*hWYQGWy8h9IfScGHnByXdg.png"/></div></figure><p id="9c84" class="pw-post-body-paragraph js jt hi ju b jv jw is jx jy jz iv ka kb kc kd ke kf kg kh ki kj kk kl km kn hb bi translated">一旦我们保存了接口，让我们打开一个敌人的类，并确保通过实现<strong class="ju hs">idamagable</strong>接口来声明它是可破坏的:</p><figure class="jh ji jj jk fd jl er es paragraph-image"><div role="button" tabindex="0" class="jm jn di jo bf jp"><div class="er es ml"><img src="../Images/eee4f584904e8f532ebcd1cafb51b345.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*wnxCNte4zpKR1Xzw5ultuw.gif"/></div></div></figure><p id="68df" class="pw-post-body-paragraph js jt hi ju b jv jw is jx jy jz iv ka kb kc kd ke kf kg kh ki kj kk kl km kn hb bi translated">您会注意到，只要我们声明该类实现了接口，该类就会显示一个错误:</p><figure class="jh ji jj jk fd jl er es paragraph-image"><div class="er es mm"><img src="../Images/ce33369363c1d1ca898729f3683e8f0d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1220/format:webp/1*PmIqQT29bsVOmTy1xHOJyA.png"/></div></figure><p id="e6fb" class="pw-post-body-paragraph js jt hi ju b jv jw is jx jy jz iv ka kb kc kd ke kf kg kh ki kj kk kl km kn hb bi translated">这是因为需要实现<strong class="ju hs">I imageable</strong>接口。要修复它，我们需要在类中声明各自的健康属性和损坏方法:</p><figure class="jh ji jj jk fd jl er es paragraph-image"><div class="er es mn"><img src="../Images/9f1dd617e39bc03f2deba58b0f14569d.png" data-original-src="https://miro.medium.com/v2/resize:fit:966/format:webp/1*U3jgKvHra2aNhv0KNEQ3pw.png"/></div></figure><figure class="jh ji jj jk fd jl er es paragraph-image"><div class="er es mo"><img src="../Images/4cebdec883c89942c14040c43127525b.png" data-original-src="https://miro.medium.com/v2/resize:fit:964/format:webp/1*vVSuIoXiIMTG4drOcz5TOA.png"/></div></figure><p id="d0f2" class="pw-post-body-paragraph js jt hi ju b jv jw is jx jy jz iv ka kb kc kd ke kf kg kh ki kj kk kl km kn hb bi translated">声明之后，我们会看到错误从脚本中消失了。然后，让我们对其他敌人职业做同样的事情:</p><div class="jh ji jj jk fd ab cb"><figure class="lm jl mp lo lp lq lr paragraph-image"><div role="button" tabindex="0" class="jm jn di jo bf jp"><img src="../Images/d3b3c56f763af190c045126978bdf482.png" data-original-src="https://miro.medium.com/v2/resize:fit:902/format:webp/1*sjTh2EcVf6ytShpbEl39mA.png"/></div></figure><figure class="lm jl mq lo lp lq lr paragraph-image"><div role="button" tabindex="0" class="jm jn di jo bf jp"><img src="../Images/e75913c770d436baf58270d950b71d2f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1100/format:webp/1*kuu3Yx7tFnYJLx9rf89-cA.png"/></div></figure></div><p id="f2a7" class="pw-post-body-paragraph js jt hi ju b jv jw is jx jy jz iv ka kb kc kd ke kf kg kh ki kj kk kl km kn hb bi translated">现在，我们能够宣布对我们的每一个敌人做什么。例如，我们可以在<strong class="ju hs">伤害</strong>方法中从<strong class="ju hs">生命</strong>属性中减去一个单位:</p><figure class="jh ji jj jk fd jl er es paragraph-image"><div class="er es mr"><img src="../Images/8a5b32169d5dcab826d69643e27ea478.png" data-original-src="https://miro.medium.com/v2/resize:fit:1090/format:webp/1*wdVWqIp5A-kdpO9xkfmtng.png"/></div></figure><p id="22b8" class="pw-post-body-paragraph js jt hi ju b jv jw is jx jy jz iv ka kb kc kd ke kf kg kh ki kj kk kl km kn hb bi translated">这个接口实现允许我们调用<strong class="ju hs">损害</strong>方法，而不限制我们想要在攻击中损害什么。我们可以在一个木头盒子、一个敌人甚至是一个玩家中实现这个界面。例如，要使用它，我们可以在碰撞中从碰撞器获取<strong class="ju hs">I可损坏的</strong>组件，并调用<strong class="ju hs">损坏</strong>方法:</p><figure class="jh ji jj jk fd jl er es paragraph-image"><div class="er es ms"><img src="../Images/c48444cb40c26e1df07efe09055b20db.png" data-original-src="https://miro.medium.com/v2/resize:fit:1156/format:webp/1*dpiyd9ZOibL7xZSHPqgmBw.png"/></div></figure><figure class="jh ji jj jk fd jl er es paragraph-image"><div role="button" tabindex="0" class="jm jn di jo bf jp"><div class="er es jg"><img src="../Images/f151644c8e09ece66256bc359e47bc8b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*qq1MsP6DrmFaKop3wTieaw.gif"/></div></div></figure><p id="c7b8" class="pw-post-body-paragraph js jt hi ju b jv jw is jx jy jz iv ka kb kc kd ke kf kg kh ki kj kk kl km kn hb bi translated">就是这样，现在我们可以用一个界面来表明我们的敌人在Unity中是易受攻击的！:d .我会在下一篇文章中看到你，在那里我会展示一种在Unity的近战中实现生命盒检测的方法。</p></div><div class="ab cl mt mu gp mv" role="separator"><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my"/></div><div class="hb hc hd he hf"><blockquote class="lt lu lv"><p id="4311" class="js jt lw ju b jv jw is jx jy jz iv ka lx kc kd ke ly kg kh ki lz kk kl km kn hb bi translated"><em class="hi">如果你想更多地了解我，欢迎登陆</em><a class="ae ko" href="https://www.linkedin.com/in/fas444/" rel="noopener ugc nofollow" target="_blank"><strong class="ju hs"><em class="hi">LinkedIn</em></strong></a><strong class="ju hs"><em class="hi"/></strong><em class="hi">或访问我的</em> <a class="ae ko" href="http://fernandoalcasan.com/" rel="noopener ugc nofollow" target="_blank"> <strong class="ju hs"> <em class="hi">网站</em> </strong> </a> <em class="hi"> :D </em></p></blockquote></div></div>    
</body>
</html>