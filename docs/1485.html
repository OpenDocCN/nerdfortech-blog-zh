<html>
<head>
<title>Social application with Vue.js and GO</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">带有Vue.js和GO的社交应用</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/social-application-with-vue-js-and-go-d9e563466b66?source=collection_archive---------1-----------------------#2021-03-22">https://medium.com/nerd-for-tech/social-application-with-vue-js-and-go-d9e563466b66?source=collection_archive---------1-----------------------#2021-03-22</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><figure class="hh hi ez fb hj hk er es paragraph-image"><div class="er es hg"><img src="../Images/4cdfb643ef90df60dcd8aaa1429ba169.png" data-original-src="https://miro.medium.com/v2/resize:fit:1088/format:webp/1*9RcvJALOdCOUBieIJCCMEg.jpeg"/></div><figcaption class="hn ho et er es hp hq bd b be z dx translated">标志归功于vuejs.org和golang.org</figcaption></figure><div class=""/><div class=""><h2 id="ec61" class="pw-subtitle-paragraph iq hs ht bd b ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh dx translated">用vue.js和golang创建和服务一个类似twitter的应用程序第7部分:与GOLANG服务器的连接</h2></div><p id="8fb9" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">这是本系列的第七部分。在这里检查所有零件:</p><ul class=""><li id="bced" class="ke kf ht jk b jl jm jo jp jr kg jv kh jz ki kd kj kk kl km bi translated"><a class="ae kn" href="https://ivano-dalmasso.medium.com/social-application-with-vue-js-and-go-4e4db0cdde64" rel="noopener">第一部分:设置</a></li><li id="e9bc" class="ke kf ht jk b jl ko jo kp jr kq jv kr jz ks kd kj kk kl km bi translated"><a class="ae kn" href="https://ivano-dalmasso.medium.com/social-application-with-vue-js-and-go-64b3adee8dac" rel="noopener">第二部分:VUE入门</a></li><li id="8e37" class="ke kf ht jk b jl ko jo kp jr kq jv kr jz ks kd kj kk kl km bi translated"><a class="ae kn" href="https://ivano-dalmasso.medium.com/social-application-with-vue-js-and-go-24a1d1e7137d" rel="noopener">第三部分:组件&amp;插槽</a></li><li id="c040" class="ke kf ht jk b jl ko jo kp jr kq jv kr jz ks kd kj kk kl km bi translated"><a class="ae kn" rel="noopener" href="/nerd-for-tech/social-application-with-vue-js-and-go-3a11d506fc38">第4部分:Vuex首次设置</a></li><li id="5b86" class="ke kf ht jk b jl ko jo kp jr kq jv kr jz ks kd kj kk kl km bi translated"><a class="ae kn" rel="noopener" href="/nerd-for-tech/social-application-with-vue-js-and-go-ef364b572422">第5部分:Vuex终结</a></li><li id="6dcf" class="ke kf ht jk b jl ko jo kp jr kq jv kr jz ks kd kj kk kl km bi translated"><a class="ae kn" href="https://ivano-dalmasso.medium.com/social-application-with-vue-js-and-go-a22a1afb76eb" rel="noopener">第六部分:Vuex中的表格和数据</a></li><li id="572f" class="ke kf ht jk b jl ko jo kp jr kq jv kr jz ks kd kj kk kl km bi translated">第七部分:连接golang服务器(this)</li><li id="23ef" class="ke kf ht jk b jl ko jo kp jr kq jv kr jz ks kd kj kk kl km bi translated"><a class="ae kn" href="https://ivano-dalmasso.medium.com/social-application-with-vue-js-and-go-64978f7c381f" rel="noopener">第8部分:基于令牌的认证</a></li><li id="7993" class="ke kf ht jk b jl ko jo kp jr kq jv kr jz ks kd kj kk kl km bi translated"><a class="ae kn" href="https://ivano-dalmasso.medium.com/social-application-with-vue-js-and-go-4d0caa37ddac" rel="noopener">第9部分:存储索引为DB的认证令牌</a></li></ul><p id="3faf" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">在这一课中，我们的简单应用程序开始最终与golang后端服务器进行对话，我们将开始在通信的前端和数据存储的后端编写逻辑。</p><p id="0d0e" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">我们将在本次会议中更新前端和后端，您可以在这里找到代码:</p><ul class=""><li id="b26c" class="ke kf ht jk b jl jm jo jp jr kg jv kh jz ki kd kj kk kl km bi translated"><a class="ae kn" href="https://github.com/idalmasso/go-vue-tutorial-backend/releases/tag/v0.7" rel="noopener ugc nofollow" target="_blank">后端</a></li><li id="689c" class="ke kf ht jk b jl ko jo kp jr kq jv kr jz ks kd kj kk kl km bi translated"><a class="ae kn" href="https://github.com/idalmasso/go-vue-tutorial-frontend/releases/tag/v0.7" rel="noopener ugc nofollow" target="_blank">前端</a></li></ul></div><div class="ab cl kt ku gp kv" role="separator"><span class="kw bw bk kx ky kz"/><span class="kw bw bk kx ky kz"/><span class="kw bw bk kx ky"/></div><div class="hb hc hd he hf"><h2 id="9eb0" class="la lb ht bd lc ld le lf lg lh li lj lk jr ll lm ln jv lo lp lq jz lr ls lt lu bi translated">在后端创建帖子逻辑</h2><p id="6dc3" class="pw-post-body-paragraph ji jj ht jk b jl lv iu jn jo lw ix jq jr lx jt ju jv ly jx jy jz lz kb kc kd hb bi translated">让我们开始在后端创建一些逻辑，使我们能够操纵帖子。创建一个文件夹“<em class="ma">&lt;back end _ source _ folder&gt;/endpoints</em>”(这实际上会翻译成创建一个同名的包)，并在其中创建两个文件:<em class="ma"> utils.go </em>和<em class="ma"> posts.go </em>。</p><p id="73ab" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">在utils.go文件中插入以下代码:</p><pre class="mb mc md me fd mf mg mh mi aw mj bi"><span id="4e62" class="la lb ht mg b fi mk ml l mm mn">package endpoints;</span><span id="e1ba" class="la lb ht mg b fi mo ml l mm mn">import (<br/> "encoding/json"<br/> "log"<br/> "net/http"<br/> "github.com/gorilla/mux"<br/>)</span><span id="789e" class="la lb ht mg b fi mo ml l mm mn">//AddRouterEndpoints add the actual endpoints for api<br/>func AddRouterEndpoints(r *mux.Router) *mux.Router {<br/>  r.HandleFunc("/api/posts", getPosts).Methods("GET")<br/>  r.HandleFunc("/api/posts", addPost).Methods("POST")<br/>  r.HandleFunc("/api/posts/{POST_ID}",deletePost)<br/>      .Methods("DELETE")<br/>  r.HandleFunc("/api/posts/{POST_ID}/comments",addComment)<br/>      .Methods("POST")<br/>  return r<br/>}<br/><br/>func sendJSONResponse(w http.ResponseWriter, data interface{}) {<br/>  body, err := json.Marshal(data)<br/>  if err != nil {<br/>    log.Printf("Failed to encode a JSON response: %v", err)<br/>    w.WriteHeader(http.StatusInternalServerError)<br/>    return<br/>  }<br/>  w.Header().Set("Content-Type", "application/json; charset=UTF-8")<br/>  w.WriteHeader(http.StatusOK)<br/>  _, err = w.Write(body)<br/>  if err != nil {<br/>    log.Printf("Failed to write the response body: %v", err)<br/>    return<br/>  }<br/>}</span></pre><p id="ec7e" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">这些函数非常容易理解:第一个是更新一个路由器，作为参数添加路由解析方法，用于添加、获取和删除帖子。此外，我们还添加了一个向其中插入注释的方法。我们使用gorilla mux，它实际上是一个多路复用器，使管理路线的代码更加容易和有组织。</p><p id="7045" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">第一个函数的代码实际上只是说，如果我们的服务器的/api/posts端点是用http GET方法调用的，那么它应该是带有getPost函数(我们还没有编写)的服务器，并且跟在其他函数后面。</p><p id="8b1b" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">第二个函数是一个助手函数，我们将在routes函数中使用。这将接受一个http作为输入。ResponseWriter和一个空接口(和往常一样，它可以是go中的任何东西),然后用响应编写器编写对象，用http OK代码序列化为json。注意，如果对象不是json可序列化的，它将返回一个错误。</p><p id="5be7" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">有了这个设置，我们将在第二个文件中插入处理路由的实际函数。在文件的顶部，我们插入</p><pre class="mb mc md me fd mf mg mh mi aw mj bi"><span id="f294" class="la lb ht mg b fi mk ml l mm mn">package endpoints<br/><br/>import (<br/>	"encoding/json"<br/>	"log"<br/>	"net/http"<br/>	"strconv"<br/>	"time"<br/><br/>	"github.com/gorilla/mux"<br/>)<br/>type comment struct {<br/>	ID       int      `json:"id"`<br/>	Username string   `json:"username"`<br/>	Post string   	  `json:"post"`<br/>	Date time.Time 	  `json:"date"`	<br/>}<br/>//post Struct is used as post structure...<br/>type post struct {<br/>	ID   		 int       `json:"id"`<br/>	Username string    `json:"username"`<br/>	Post string    		 `json:"post"`<br/>	Date time.Time 		 `json:"date"`<br/>	Comments []comment `json:"comments"`<br/>}<br/></span></pre><p id="3b50" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">这是两个结构的定义，一个带有name comment，另一个带有name post，包含了API数据传输所需的字段。注意，字段名都是大写的，这是json序列化所需要的。我们现在不打算使用数据库，我们将在以后的课程中添加它，现在我们将创建一个帖子数组并在内存中使用它们:</p><pre class="mb mc md me fd mf mg mh mi aw mj bi"><span id="fc41" class="la lb ht mg b fi mk ml l mm mn">var posts []post=make([]post, 0)<br/>//need an index for the array... When I'll delete the posts the index will have to go on...<br/>var index int=1<br/></span></pre><p id="5c5d" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">在此之后，我们可以开始创建实际的处理函数:</p><pre class="mb mc md me fd mf mg mh mi aw mj bi"><span id="d52a" class="la lb ht mg b fi mk ml l mm mn">//addPost will get in Body a post with ONLY username and post-&gt; need to add the others and save it<br/>func addPost(w http.ResponseWriter, r *http.Request) {<br/>  log.Println("addPost called")<br/>  var actualPost post<br/>  err:=json.NewDecoder(r.Body).Decode(&amp;actualPost)<br/>  if err!=nil{<br/>    http.Error(w, err.Error(), http.StatusBadRequest)<br/>    return<br/>  }<br/>  actualPost.ID = index<br/>  index++<br/>  actualPost.Date=time.Now()<br/>  if actualPost.Comments== nil{<br/>    actualPost.Comments=make([]comment, 0)<br/>  }<br/>  posts=append(posts, actualPost)<br/>  sendJSONResponse(w,actualPost)<br/>}</span><span id="ce06" class="la lb ht mg b fi mo ml l mm mn">//deletePost removes the post that is being passed. Get the id from //the query<br/>func deletePost(w http.ResponseWriter, r *http.Request) {<br/>  log.Println("deletePost called")<br/>  vars := mux.Vars(r)<br/>  idString, ok := vars["POST_ID"]<br/>  if !ok {<br/>    http.Error(w, "Cannot find ID", http.StatusBadRequest)<br/>    return<br/>  }<br/>  id, err := strconv.Atoi(idString)<br/>  if err!=nil{<br/>    http.Error(w, "Cannot convert the id value to string",http.StatusBadRequest)<br/>    return<br/>  }<br/>  for i:=0;i&lt;len(posts);i++{<br/>    if posts[i].ID==id {<br/>      posts[i]=posts[len(posts)-1]<br/>      posts=posts[:len(posts)-1]<br/>      w.WriteHeader(http.StatusOK)<br/>      return<br/>    }<br/>  }<br/>  http.Error(w, "Cannot find the requested id", http.StatusNotFound)<br/>}<br/>//addComment will get the comment in the body, and the id in the query<br/>func addComment(w http.ResponseWriter, r *http.Request) {<br/>  log.Println("addComment called")<br/>  vars := mux.Vars(r)<br/>  idString, ok := vars["POST_ID"]<br/>  if !ok {<br/>    http.Error(w, "Cannot find ID", http.StatusBadRequest)<br/>    return<br/>  }<br/>  id, err := strconv.Atoi(idString)<br/>  if err!=nil{<br/>    http.Error(w, "Cannot convert the id value to string", http.StatusBadRequest)<br/>    return<br/>  }<br/>  var actualComment comment<br/>  err = json.NewDecoder(r.Body).Decode(&amp;actualComment)<br/>  if err!=nil{<br/>    http.Error(w, err.Error(), http.StatusBadRequest)<br/>    return<br/>  }<br/>  for i:=0;i&lt;len(posts);i++{<br/>    if posts[i].ID==id {<br/>      //Now I have the post<br/>      var commMax int=0<br/>      for comm:=0;comm&lt;len(posts[i].Comments);comm++{<br/>        if commMax&lt;posts[i].Comments[comm].ID{<br/>          commMax=posts[i].Comments[comm].ID<br/>        }<br/>      }<br/>      actualComment.ID=commMax+1<br/>      actualComment.Date=time.Now()<br/>      posts[i].Comments = append(posts[i].Comments, actualComment)<br/>      sendJSONResponse(w, posts[i])<br/>      return<br/>    }<br/>  }<br/>  //If I'm here, there is no post with the id searched... <br/>  http.Error(w, "Cannot find a post with the selected id", http.StatusNotFound)<br/>}<br/>//getPosts will return all the posts actually in the array<br/>func getPosts(w http.ResponseWriter, r *http.Request) {<br/>  log.Println("Get post called")<br/>  sendJSONResponse(w, posts)<br/>}</span></pre><p id="0e96" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">让我们解释一下这段代码:</p><ul class=""><li id="07f6" class="ke kf ht jk b jl jm jo jp jr kg jv kh jz ki kd kj kk kl km bi translated">addPost函数实际上只是尝试将请求体解码为Post对象。如果可以做到这一点，它会将这个对象(带有填充的id和日期)添加到我们的帖子“storage”中，然后返回它，更新后带有ok响应</li><li id="f7a6" class="ke kf ht jk b jl ko jo kp jr kq jv kr jz ks kd kj kk kl km bi translated">deletePost函数获取POST_ID查询参数，如果“存储”中有一篇具有该ID的文章，它将被删除。否则，它向客户端返回一个NotFound状态代码。</li><li id="6f87" class="ke kf ht jk b jl ko jo kp jr kq jv kr jz ks kd kj kk kl km bi translated">addComment将一个Comment对象添加到由POST_ID查询参数指示的帖子中。事实上，查找ID的代码一点也不好，但是一旦我们开始使用数据库，我们就会替换它。</li><li id="ff2c" class="ke kf ht jk b jl ko jo kp jr kq jv kr jz ks kd kj kk kl km bi translated">getPosts只是将作为回答的帖子列表序列化为json。</li></ul><p id="bc33" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">现在所有的对象都可以被调用了，最后要做的就是在服务器的主函数中调用之前在utils文件中编写的<em class="ma"> addRouterEndpoint </em>方法。然后，为了管理CORS策略，我们只需编写一个简单的装饰器，在将它传递给http之前应用于路由器。手柄功能。简单来说就是这样做的:</p><pre class="mb mc md me fd mf mg mh mi aw mj bi"><span id="5f95" class="la lb ht mg b fi mk ml l mm mn">func main(){<br/>  r := mux.NewRouter()<br/>  r=endpoints.AddRouterEndpoints(r)<br/>  fs := http.FileServer(http.Dir("./dist"))<br/>  r.PathPrefix("/").Handler(fs)<br/>	<br/>  http.Handle("/",&amp;corsRouterDecorator{r})<br/>  fmt.Println("Listening")	<br/>  log.Panic(<br/>    http.ListenAndServe(":3000", nil),<br/>  )<br/>}<br/><br/><br/>type corsRouterDecorator struct {<br/>  R *mux.Router<br/>}<br/><br/>func (c *corsRouterDecorator) ServeHTTP(rw http.ResponseWriter, req *http.Request) {<br/>  if origin := req.Header.Get("Origin"); origin != "" {<br/>    rw.Header().Set("Access-Control-Allow-Origin", origin)<br/>    rw.Header().Set("Access-Control-Allow-Methods", <br/>      "POST, GET, PUT, DELETE, PATCH")<br/>    rw.Header().Add("Access-Control-Allow-Headers", <br/>      "Content-Type, Access-Control-Allow-Headers, Authorization, X-Requested-With")<br/>  }<br/>  // Stop here if its Preflighted OPTIONS request<br/>  if req.Method == "OPTIONS" {<br/>    return<br/>  }<br/>  c.R.ServeHTTP(rw, req)<br/>}</span></pre><p id="66bd" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">就是这样！这样，我们就有了这个服务器创建和服务的4个想要的路由，然后它将操作帖子和评论对象。注意，在这一章中，我们不打算管理认证，所以任何将帖子发送到/api/posts发布路径的用户都可以向我们的服务器添加新帖子。我们将在另一章中讨论这个问题。</p></div><div class="ab cl kt ku gp kv" role="separator"><span class="kw bw bk kx ky kz"/><span class="kw bw bk kx ky kz"/><span class="kw bw bk kx ky"/></div><div class="hb hc hd he hf"><h2 id="da18" class="la lb ht bd lc ld le lf lg lh li lj lk jr ll lm ln jv lo lp lq jz lr ls lt lu bi translated">更新前端</h2><p id="d83e" class="pw-post-body-paragraph ji jj ht jk b jl lv iu jn jo lw ix jq jr lx jt ju jv ly jx jy jz lz kb kc kd hb bi translated">在前端，大部分工作将在存储操作中完成。请注意，我们在后端将“post.user”更改为“post.username ”,因此对于semplicity，我们可以在任何地方进行更改。</p><p id="55d5" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">然后，在Post store的index.js中，我们来做一些修改。首先，我们将不再有“ADD_COMMENT”变异，但是，因为路由返回给我们完整的post对象，我们可以有一个“SET_POST_COMMENTS”变异，如下所示:</p><pre class="mb mc md me fd mf mg mh mi aw mj bi"><span id="624f" class="la lb ht mg b fi mk ml l mm mn">SET_POST_COMMENTS(state, { postId, post }) {<br/>  const oldPost = state.posts.find(post =&gt; post.id == postId);<br/>  oldPost.comments = post.comments;<br/>}</span></pre><p id="f9a9" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">然后，ADD_POST突变不再需要找id，可以变得更简单。同样，让我们为初始化添加一个SET_ALL_POSTS变异:</p><pre class="mb mc md me fd mf mg mh mi aw mj bi"><span id="380a" class="la lb ht mg b fi mk ml l mm mn">ADD_POST(state, post) {<br/>  state.posts.push(post);<br/>},<br/>SET_ALL_POSTS(state, posts) {<br/>  state.posts = posts;<br/>},</span></pre><p id="c652" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">有了这个，我们改变并简化了我们的突变。我们现在可以更新动作来调用api，并添加新的动作“getAllPosts”来完成我们需要的功能。这是通过以下代码完成的:</p><pre class="mb mc md me fd mf mg mh mi aw mj bi"><span id="0c3a" class="la lb ht mg b fi mk ml l mm mn">async addPost(context, post) {<br/>      fetch("http://localhost:3000/api/posts", {<br/>        method: "POST",<br/>        headers: { "Content-Type": "application/json" },<br/>        body: JSON.stringify(post)<br/>      })<br/>        .then(response =&gt; {<br/>          if (!response.ok) {<br/>            throw Error(response.body);<br/>          }<br/>          return response.json();<br/>        })<br/>        .then(data =&gt; {<br/>          context.commit("ADD_POST", data);<br/>        })<br/>        .catch(error =&gt; {<br/>          console.log(error);<br/>        });<br/>    },<br/>    async deletePost(context, { post }) {<br/>      fetch("http://localhost:3000/api/posts/" + post.id, {<br/>        method: "DELETE"<br/>      })<br/>        .then(response =&gt; {<br/>          if (response.ok) {<br/>            console.log(response);<br/>            context.commit("DELETE_POST", post.id);<br/>            return;<br/>          }<br/>          throw Error(response);<br/>        })<br/>        .catch(error =&gt; {<br/>          console.log(error);<br/>        });<br/>    },<br/>    async addComment(context, { postId, comment }) {<br/>      fetch("http://localhost:3000/api/posts/" + postId + "/comments", {<br/>        method: "POST",<br/>        headers: {<br/>          "Content-Type": "application/json"<br/>        },<br/>        body: JSON.stringify(comment)<br/>      })<br/>        .then(response =&gt; {<br/>          if (response.ok) {<br/>            return response.json();<br/>          } else throw Error(response.body);<br/>        })<br/>        .then(data =&gt; {<br/>          context.commit("SET_POST_COMMENTS", { postId: postId, post: data });<br/>        })<br/>        .catch(error =&gt; {<br/>          console.log(error);<br/>        });<br/>    },<br/>    async getAllPosts(context) {<br/>      fetch("http://localhost:3000/api/posts")<br/>        .then(response =&gt; {<br/>          if (response.ok) {<br/>            return response.json();<br/>          } else {<br/>            throw Error(response.body);<br/>          }<br/>        })<br/>        .then(data =&gt; {<br/>          console.log(data);<br/>          context.commit("SET_ALL_POSTS", data);<br/>        })<br/>        .catch(error =&gt; {<br/>          console.log(error);<br/>        });<br/>    }</span></pre><p id="68c1" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">因此，所有这些操作实际上都是通过fetch调用我们在服务器上创建的新的相对api。在对返回的承诺的解析中，如果响应是ok的，我们调用变异的提交，否则我们只记录错误。显然，当promise resolution有一个我们以后必须使用的对象参数时，我们必须对它进行反序列化，使用response.json()方法的promise resolution很容易做到这一点。有了它，我们就可以将数据发送给我们必须进行的突变。</p><p id="e0c3" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">注意，我们从来没有为帖子添加删除按钮，所以现在让我们来做一下:在SinglePost组件中，在卡片的槽标题中添加一个普通的按钮，如</p><pre class="mb mc md me fd mf mg mh mi aw mj bi"><span id="778b" class="la lb ht mg b fi mk ml l mm mn">&lt;button class="delete-button" @click.prevent="deletePost"&gt;        Delete<br/>&lt;/button&gt;</span></pre><p id="d611" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">其背后的逻辑非常简单，我们必须用Post值调度detetePost操作:</p><pre class="mb mc md me fd mf mg mh mi aw mj bi"><span id="07d6" class="la lb ht mg b fi mk ml l mm mn">deletePost() {<br/>  this.$store.dispatch("posts/deletePost", { post: this.post });    }</span></pre><p id="515e" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">现在我们只需要初始化文章存储。</p><p id="bae1" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">我们可以在Posts.vue组件中这样做，使用mounted()配置方法，如下所示:</p><pre class="mb mc md me fd mf mg mh mi aw mj bi"><span id="c367" class="la lb ht mg b fi mk ml l mm mn">mounted() {    <br/>  this.$store.dispatch("posts/getAllPosts");<br/>  }</span></pre><p id="f4cc" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">就像这样，当post组件被挂载时，它调用存储库的getAllPosts操作，用来自服务器的所有帖子填充存储库。然后，vue用户界面中的每个动作都调用商店的相关动作，商店的更新自动反映在组件中。</p><p id="7ba9" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">事实上，动作是异步的，允许在它们解决时做一些动作(例如，我们可以在用户点击delete post时设置一个等待的gif或动画，并在动作解决时删除动画)。</p><p id="c272" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">有了这个设置，我们就可以启动服务器，然后是vue客户端，然后一切都应该正常工作，帖子实际上被添加到后端存储。</p><p id="98e8" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">我们实际上还有两个大问题要解决:</p><ol class=""><li id="c5d0" class="ke kf ht jk b jl jm jo jp jr kg jv kh jz ki kd mp kk kl km bi translated">帖子实际上保存在内存中，这将在下一课中解决，现在如果我们停止服务器，帖子实际上将永远丢失，但至少客户端现在是持久的，重新打开页面将再次显示数据。</li><li id="2795" class="ke kf ht jk b jl ko jo kp jr kq jv kr jz ks kd mp kk kl km bi translated">身份验证，现在任何用户都可以通过向服务器传递post对象来存储新的帖子。</li></ol><p id="ff5a" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">在下一章中，我们将解决最后一个问题，因此只有经过认证的用户才能登录并使用实际的应用程序。</p></div></div>    
</body>
</html>