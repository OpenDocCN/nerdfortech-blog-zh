<html>
<head>
<title>Going into PHP CQRS</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">走进PHP CQRS</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/going-into-php-cqrs-85cf8e21fa57?source=collection_archive---------2-----------------------#2021-07-28">https://medium.com/nerd-for-tech/going-into-php-cqrs-85cf8e21fa57?source=collection_archive---------2-----------------------#2021-07-28</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/2d883acd2bc15247cbf92ae1c34edbeb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*M5pDgciNpwW1AMAALoNGpg.jpeg"/></div></div></figure><p id="72dd" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">约翰独自坐在办公室的电脑后面。唯一的光亮是他桌上的灯和笔记本电脑。他感到筋疲力尽，但是他知道他必须找到问题的原因。</p><p id="09b2" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">又经过一个小时的调试，约翰随机重现了bug，他终于搞定了。在他的代码中，他重用了产品服务来从数据库中检索产品。然而，他不知道的是，无论何时有人调用它，这个代码都在改变和保存产品的大量视图。约翰运气不好，因为他的队友在代码中引入了一个错误，存储了不正确的值。</p><p id="7493" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">有多少次你不得不深入调试代码，而函数看起来很明显，实际上却在做一些意想不到的事情？</p><p id="2050" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在这种情况下，<em class="jo"> CQRS </em>会帮助我们。因此，随着代码变得更加清晰和简单，我们可以对代码进行更多的推理。</p><h1 id="c741" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">输入命令查询责任分离(CQRS)</h1><p id="4acc" class="pw-post-body-paragraph iq ir hi is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hb bi translated">在他的原则中，<em class="jo"> CQRS </em>定义了<em class="jo">查询</em>和<em class="jo">命令</em>的区别。</p><p id="7828" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">查询</strong>是获取数据的方式，<strong class="is hj">命令</strong>修改数据。<br/>这个简单的区别允许开发者之间达成一致，即他们可以安全地使用查询任意多次<strong class="is hj">而不会产生副作用</strong>。</p><p id="550e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">查询和命令<strong class="is hj">是可识别的</strong>，这意味着我们知道特定的查询或命令应该做什么。这比CRUD有巨大的优势，因为它允许捕捉用户的意图。<br/> <br/>如果用户想改变他的电子邮件地址。然后，我们可能只要求电子邮件，因此，发送给他特定的通知，以确认他的新电子邮件地址。<br/>从查询端，我们可以提供针对特定视图的查询。这允许我们知道它在哪里被使用以及它在什么决定之前。对于更改电子邮件，只检索当前电子邮件而不是完整的用户详细信息可能就足够了。</p><h1 id="4082" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">实践中的CQRS</h1><figure class="ks kt ku kv fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/7e0285fcae949096e913354c4dc6a4fa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gXR0PkGl09B-mZGUft1WuQ.jpeg"/></div></div></figure><h1 id="1048" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">西蒙·CQRS</h1><p id="ec2a" class="pw-post-body-paragraph iq ir hi is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hb bi translated">为了给<em class="jo"> Symfony </em>安装<em class="jo">生态区</em>支架，执行以下操作:</p><blockquote class="kw kx ky"><p id="46f6" class="iq ir jo is b it iu iv iw ix iy iz ja kz jc jd je la jg jh ji lb jk jl jm jn hb bi translated">作曲家要求<a class="ae lc" href="https://packagist.org/packages/ecotone/" rel="noopener ugc nofollow" target="_blank">生态交错带/ </a> symfony-bundle</p></blockquote><h1 id="408f" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">拉勒维尔·CQRS</h1><p id="23ac" class="pw-post-body-paragraph iq ir hi is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hb bi translated">为了安装<em class="jo">生态交错带</em>支架用于<em class="jo">拉韦勒</em>，执行以下操作:</p><blockquote class="kw kx ky"><p id="04b9" class="iq ir jo is b it iu iv iw ix iy iz ja kz jc jd je la jg jh ji lb jk jl jm jn hb bi translated">作曲家要求<a class="ae lc" href="https://packagist.org/packages/ecotone/" rel="noopener ugc nofollow" target="_blank">生态交错带/ </a>拉勒韦尔</p></blockquote><h1 id="d41a" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">注册命令</h1><p id="f754" class="pw-post-body-paragraph iq ir hi is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hb bi translated">让我们定义第一个<strong class="is hj">命令</strong>，它将改变电子邮件地址。</p><figure class="ks kt ku kv fd ij"><div class="bz dy l di"><div class="ld le l"/></div></figure><p id="c5c3" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">命令处理程序</strong>是我们实际处理已定义命令的地方。</p><figure class="ks kt ku kv fd ij"><div class="bz dy l di"><div class="ld le l"/></div></figure><p id="0045" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这就是我们如何将<strong class="is hj">命令</strong>与<strong class="is hj">处理程序关联起来。</strong> <em class="jo">交错区</em>正在查看方法声明中的<strong class="is hj">第一个类型提示，以了解该处理程序应该使用哪个命令。为了发送这个命令，我们将使用<strong class="is hj"> CommandBus，</strong>，我们将把它注入到我们的<em class="jo"> HTTP </em> <em class="jo">控制器</em>中。</strong></p><figure class="ks kt ku kv fd ij"><div class="bz dy l di"><div class="ld le l"/></div></figure><p id="ee8c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">命令总线自动注册在您的依赖容器</strong>中。他知道路由到特定的处理程序，所以您需要做的就是发送命令。</p><blockquote class="kw kx ky"><p id="3664" class="iq ir jo is b it iu iv iw ix iy iz ja kz jc jd je la jg jh ji lb jk jl jm jn hb bi translated"><em class="hi">上面的控制器当然是伪代码，但是调整到</em> Symfony <em class="hi">或</em> Laravel <em class="hi">应该很简单。</em></p></blockquote><h1 id="fac2" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">注册查询</h1><p id="610b" class="pw-post-body-paragraph iq ir hi is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hb bi translated">让我们注册<strong class="is hj">查询</strong>，它将返回用户的送货地址。</p><figure class="ks kt ku kv fd ij"><div class="bz dy l di"><div class="ld le l"/></div></figure><p id="4ac6" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在<strong class="is hj">查询处理器</strong>将处理我们的<em class="jo">GetUserShippingAddressQuery</em>。</p><figure class="ks kt ku kv fd ij"><div class="bz dy l di"><div class="ld le l"/></div></figure><blockquote class="kw kx ky"><p id="16ed" class="iq ir jo is b it iu iv iw ix iy iz ja kz jc jd je la jg jh ji lb jk jl jm jn hb bi translated">如果需要，你可以在同一个类中定义多个查询/命令处理程序。这有助于保持您的逻辑，并避免代码样板。</p></blockquote><p id="f61d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">由于我们已经使用<em class="jo">#【Query Handler】</em>注释注册了查询处理程序，现在我们可以发送查询了。</p><figure class="ks kt ku kv fd ij"><div class="bz dy l di"><div class="ld le l"/></div></figure><p id="6902" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在我们调用QueryBus并返回帐单地址。</p><h1 id="75d7" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">强大的功能，但使用简单</h1><figure class="ks kt ku kv fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/f39872689d4e8bdffcb95330219f8eda.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*S6P8HF6CRBkGhRI9XQkUKg.jpeg"/></div></div></figure><p id="cf48" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">当你开始使用<em class="jo">生态区</em>时，你会发现自己做的<strong class="is hj">配置</strong>要少得多，结果代码会变得更容易阅读和理解。</p><p id="798a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">econtero遵循编程的新趋势</strong>，旨在保持框架的业务逻辑清晰。在大多数情况下，你将只使用PHP 8的属性，而<em class="jo">生态区</em>将一起处理点火和连接。</p><p id="44d3" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">你可以在官方的<a class="ae lc" href="https://docs.ecotone.tech/modelling/command-handling" rel="noopener ugc nofollow" target="_blank">生态区文档</a>中读到更多关于命令处理程序和查询处理程序的信息。</p></div></div>    
</body>
</html>