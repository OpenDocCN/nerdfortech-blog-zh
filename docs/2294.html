<html>
<head>
<title>Coroutines With Unity!</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">统一的协程！</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/coroutines-with-unity-7dd9eefdeb2e?source=collection_archive---------2-----------------------#2021-04-30">https://medium.com/nerd-for-tech/coroutines-with-unity-7dd9eefdeb2e?source=collection_archive---------2-----------------------#2021-04-30</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="ec7b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">创建一个重复的产卵系统，并保持我们的项目整洁。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es jd"><img src="../Images/5ff44555085ca168cd856a544af873cf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*znb9BviaK6_wYN9jmWM-nQ.gif"/></div></div></figure><p id="b6fc" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在 Unity 中，允许我们运行一个可以暂停执行的函数。简单来说，我们可以停止、开始和等待。</p><p id="7659" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Unity 中的一个<strong class="ih hj">协程</strong>方法需要一个<strong class="ih hj"> IEnumerator </strong>，它需要包含一个<strong class="ih hj"> yield 返回类型</strong>。最常见的<strong class="ih hj">收益返回类型</strong>是<strong class="ih hj">等待秒。</strong>这允许我们在继续函数之前以秒为单位设置时间量，这与每帧运行我们函数的更新方法相反。一个简单的<strong class="ih hj">协程</strong>可以很好地运行顺序事件，实例化或改变时间线上的某些游戏对象。</p><p id="d1a2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">协程</strong>的另一个常见用途是创建一个函数的重复实例。为此，我们需要使用一个<strong class="ih hj"> while 循环。我们可以设置一个函数，当某事为真或假时，在循环中重复它自己。这些循环可能是危险的，因为如果在错误的上下文中使用，它们将无限重复。在一个<strong class="ih hj">协程</strong>中使用它们会安全得多，因为它允许我们在重复之前<strong class="ih hj">放弃一次返回</strong>。</strong></p><p id="339b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们可以分别用<strong class="ih hj"> StopCoroutine </strong>和<strong class="ih hj"> StartCoroutine </strong>来停止和启动我们的协同程序，后面跟着我们的协同程序的名称和()来调用括号中的函数。</p><p id="c9aa" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们还可以通过创建一个可以在代码的其他地方在真或假之间切换的 bool 来操作我们的 while 循环。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es jp"><img src="../Images/89c7d859b993a55dd2f041c434293304.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IJ4A_87AqOEirXU7upSgXA.png"/></div></div></figure><p id="cd92" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">上图乍一看可能有点吓人。它运行一个简单的种子管理器。让我们浏览一遍。</p><p id="a545" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">首先我存储一个<strong class="ih hj">游戏对象类型变量</strong>来存储我们的<strong class="ih hj">敌人预置</strong>。</p><p id="88bf" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">接下来我有另一个<strong class="ih hj">变量</strong>存储一个<strong class="ih hj">空游戏对象</strong>来存放我们所有的衍生对象。(稍后将详细介绍)</p><p id="03b8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">随后是一个<strong class="ih hj"> bool 变量 _stopSpawn，</strong>当我们用完 live 的时候，我们将在我们的玩家脚本调用的方法中改变它，游戏结束了！</p><p id="d42c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在我们的<strong class="ih hj"> start </strong>方法中，我们简单地调用我们的<strong class="ih hj">协程来启动</strong>。</p><p id="6a3a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们的<strong class="ih hj">生成例程协程</strong>由一个<strong class="ih hj"> while 循环</strong>组成，它检查我们创建的 bool。这允许循环在 bool 为 false 时继续运行。在这里，我有类似于我的敌人在上一篇文章中包装的两行代码。我用它来设置一个沿 x 轴的随机产卵位置。</p><p id="64b2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">接下来，我将<strong class="ih hj">实例化我的预设，</strong>在我上面设置的位置，并跟随脚本附加到的我的空白产卵管理器游戏对象的旋转。我也将每个实例化的敌人分配给<strong class="ih hj">变量 _ 敌人。</strong></p><p id="83f1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">使用我们刚刚存储的<strong class="ih hj">变量</strong>，下一行将每个敌人的<strong class="ih hj">父游戏对象</strong>指定为我们在脚本开始时指定的<strong class="ih hj">空白敌人容器变量</strong>。</p><p id="cc05" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">最后，我们<strong class="ih hj">产生了一个新的 5 秒返回时间，</strong>允许一个敌人每 5 秒重生一次，每次都在一个随机的位置，并被保存在一个容器中，以避免我们的等级混乱。</p><p id="ec77" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们的最后一个方法是<strong class="ih hj"> public </strong>，当我们的生命为 0 并且游戏结束时，我们从我们的玩家脚本中调用它。这只是将我们的 bool 转换为 true，并在游戏结束后阻止敌人重复产卵。</p></div><div class="ab cl jq jr gp js" role="separator"><span class="jt bw bk ju jv jw"/><span class="jt bw bk ju jv jw"/><span class="jt bw bk ju jv"/></div><div class="hb hc hd he hf"><p id="2f2d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">除了把我们的敌人放在一个容器里。我们也可以用我们的激光器做同样的事情。在 Unity 中生成没有混乱的对象对于在运行时和我们的层次结构中更容易地排除故障是必不可少的。</p><p id="3986" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在我们的<strong class="ih hj">玩家类</strong>中，我们可以添加一个<strong class="ih hj">游戏对象变量</strong>来再次存储这个容器。我们的容器仅仅是我们的<strong class="ih hj">玩家游戏对象</strong>中的<strong class="ih hj">空白游戏对象。现在，在我们的<strong class="ih hj"> FireLaser 方法</strong>中，我们简单地将我们的实例化行存储到一个游戏对象变量中，然后访问它的<strong class="ih hj">父对象</strong>，并让它<strong class="ih hj">等于我们的容器的游戏对象</strong>。</strong></p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es jx"><img src="../Images/57905c176599fe94553ada25b0dc3d75.png" data-original-src="https://miro.medium.com/v2/resize:fit:872/format:webp/1*2cb77PlKQ16AXs91dRPFgg.png"/></div></figure></div></div>    
</body>
</html>