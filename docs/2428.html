<html>
<head>
<title>Serialize JSON HttpResponse to Kotlin Objects with Ktor.</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用Ktor将JSON HttpResponse序列化为Kotlin对象。</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/serialize-json-httpresponse-to-kotlin-objects-with-ktor-a9ac6e4db270?source=collection_archive---------2-----------------------#2021-05-06">https://medium.com/nerd-for-tech/serialize-json-httpresponse-to-kotlin-objects-with-ktor-a9ac6e4db270?source=collection_archive---------2-----------------------#2021-05-06</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/21e2ee61dc24ae2aae4eca18dc17423c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*0bA-CFnZJ26yHdfW"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">由<a class="ae iu" href="https://unsplash.com/@tomcrewceramics?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">汤姆·克鲁</a>在<a class="ae iu" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄的照片</figcaption></figure><p id="eab1" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">最近我遇到了一个问题，我应该从哪里获得一个<a class="ae iu" href="https://www.jenkins.io/" rel="noopener ugc nofollow" target="_blank"> Jenkins </a>作业的最后一次成功构建散列。为此，我通过http使用了一个简单的json api调用，并得到了一个HttpResponse。现在的问题是，我需要从这个HttpResponse中提取散列值。我想到的第一件事就是使用子字符串，但是我意识到，如果有人改变json输出模式的某些东西，这种方法并不可靠。对此，我需要一个更好的、更程序化的解决方案。</p><p id="3141" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">首先，让我们用<a class="ae iu" href="https://ktor.io" rel="noopener ugc nofollow" target="_blank"> Ktor </a>创建http请求，从Jenkins那里获取HttpResponse。</p><h1 id="a596" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">Jenkins API 调用Ktor</h1><h2 id="30a7" class="kr ju hi bd jv ks kt ku jz kv kw kx kd jg ky kz kh jk la lb kl jo lc ld kp le bi translated">必需的依赖关系</h2><figure class="lf lg lh li fd ij"><div class="bz dy l di"><div class="lj lk l"/></div></figure><p id="1994" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如果你的Jenkins不需要认证，你甚至不需要ktor-client- <a class="ae iu" href="https://ktor.io/docs/authentication.html#basic-usage" rel="noopener ugc nofollow" target="_blank"> auth </a>依赖。</p><h2 id="6f7a" class="kr ju hi bd jv ks kt ku jz kv kw kx kd jg ky kz kh jk la lb kl jo lc ld kp le bi translated">定义HttpClient</h2><figure class="lf lg lh li fd ij"><div class="bz dy l di"><div class="lj lk l"/></div></figure><p id="de98" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">该客户端使用Jenkins的密码和用户名进行基本身份验证。不要忘记有<strong class="ix hj">sendwithrequest</strong>的部分！如果该值未设置为true，每次验证都会失败。</p><p id="4b27" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">下一部分是带有序列化程序的JsonFeature。它对Json使用普通的<a class="ae iu" href="https://kotlinlang.org/docs/serialization.html" rel="noopener ugc nofollow" target="_blank"> kotlinxSerializer </a>。建议将ignoreUnknownKeys的值设为true，因为如果不是json字符串的每个值都可以放入数据类中，它将会失败。</p><p id="06ac" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">最后一步是配置ResponseValidator。在我的例子中，如果状态代码高于300，它将抛出一个带有响应文本的自定义Jenkins异常。</p><h2 id="c577" class="kr ju hi bd jv ks kt ku jz kv kw kx kd jg ky kz kh jk la lb kl jo lc ld kp le bi translated">将对象序列化为字符串并反转</h2><p id="f9b6" class="pw-post-body-paragraph iv iw hi ix b iy ll ja jb jc lm je jf jg ln ji jj jk lo jm jn jo lp jq jr js hb bi translated">让我们先从一个非常简单的例子开始，然后再看更难的。</p><ol class=""><li id="8d42" class="lq lr hi ix b iy iz jc jd jg ls jk lt jo lu js lv lw lx ly bi translated">创建可序列化的数据类</li></ol><pre class="lf lg lh li fd lz ma mb mc aw md bi"><span id="8696" class="kr ju hi ma b fi me mf l mg mh"><strong class="ma hj">@Serializable</strong> <br/><strong class="ma hj">data</strong> <strong class="ma hj">class</strong> Data(<strong class="ma hj">val</strong> a: Int, <strong class="ma hj">val</strong> b: String)</span></pre><p id="5a4d" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">2.通过调用以下命令将此类的实例序列化为字符串:</p><pre class="lf lg lh li fd lz ma mb mc aw md bi"><span id="7a27" class="kr ju hi ma b fi me mf l mg mh">Json.encodeToString(Data(42, <strong class="ma hj">"str"</strong>))</span></pre><p id="f30e" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">结果，您得到一个包含JSON格式的对象状态的字符串:<code class="du mi mj mk ma b">{"a": 42, "b": "str"}</code></p><p id="7878" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">3.通过调用以下命令将字符串序列化为类的实例:</p><pre class="lf lg lh li fd lz ma mb mc aw md bi"><span id="ab6b" class="kr ju hi ma b fi me mf l mg mh"><strong class="ma hj">val</strong> obj = Json.decodeFromString&lt;Data&gt;(<strong class="ma hj">"""{"a":42, "b": "str"}"""</strong>)</span></pre><p id="cbf8" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这将创建与步骤1中定义的完全相同的对象。</p><h2 id="4eec" class="kr ju hi bd jv ks kt ku jz kv kw kx kd jg ky kz kh jk la lb kl jo lc ld kp le bi translated">创建可序列化的数据类</h2><p id="62ce" class="pw-post-body-paragraph iv iw hi ix b iy ll ja jb jc lm je jf jg ln ji jj jk lo jm jn jo lp jq jr js hb bi translated">因为我们的Jenkins Json响应看起来像这样，所以我们需要为我们想要序列化的所有东西创建类。</p><figure class="lf lg lh li fd ij"><div class="bz dy l di"><div class="lj lk l"/></div></figure><ol class=""><li id="69a2" class="lq lr hi ix b iy iz jc jd jg ls jk lt jo lu js lv lw lx ly bi translated">首先，我们需要创建一个包含所有其他内容的根类。在这种情况下，我称之为JenkinsJsonData。</li><li id="2ec5" class="lq lr hi ix b iy ml jc mm jg mn jk mo jo mp js lv lw lx ly bi translated">下一步我们需要的是行动。它包含一个元素数组。</li><li id="607c" class="lq lr hi ix b iy ml jc mm jg mn jk mo jo mp js lv lw lx ly bi translated">我们最不想要的是包含SHA1散列的<em class="mq"> lastBuiltRevision，</em>。</li></ol><p id="eedb" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">因为我还需要buildNumber用于该项目后面的另一个任务，所以我会立即将其添加到基类的构造函数的参数中。</p><figure class="lf lg lh li fd ij"><div class="bz dy l di"><div class="lj lk l"/></div></figure><p id="a018" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如您所见，lastBuiltRevision是可空的。如果不是所有在<em class="mq">动作</em> <strong class="ix hj"> </strong>下的对象都包含一个lastBuiltRevision，这可能会是一个问题。为了弥补这种不安全性，我们在JenkinsJsonData类中编写了一个自定义getter。</p><p id="b14e" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">它只搜索这些操作的最后一项，其中lastBuiltRevision不为空，然后返回它的散列。</p><h2 id="caf8" class="kr ju hi bd jv ks kt ku jz kv kw kx kd jg ky kz kh jk la lb kl jo lc ld kp le bi translated">调用Jenkins Api并序列化输出</h2><figure class="lf lg lh li fd ij"><div class="bz dy l di"><div class="lj lk l"/></div></figure><ol class=""><li id="8a44" class="lq lr hi ix b iy iz jc jd jg ls jk lt jo lu js lv lw lx ly bi translated">对Jenkins Api调用的branchName进行双重编码。</li><li id="7da1" class="lq lr hi ix b iy ml jc mm jg mn jk mo jo mp js lv lw lx ly bi translated">用生成的URL调用client.get函数。</li><li id="c68c" class="lq lr hi ix b iy ml jc mm jg mn jk mo jo mp js lv lw lx ly bi translated">这个函数需要在runBlocking块中，因为它是一个挂起函数。</li><li id="3619" class="lq lr hi ix b iy ml jc mm jg mn jk mo jo mp js lv lw lx ly bi translated">这将返回一个JenkinsJsonData对象，其中包含散列的自定义getter。</li><li id="5694" class="lq lr hi ix b iy ml jc mm jg mn jk mo jo mp js lv lw lx ly bi translated">如果状态代码超过300，get请求将抛出一个异常，并抛出一个新的自定义异常。</li></ol><h1 id="fd3e" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">反射</h1><h2 id="07eb" class="kr ju hi bd jv ks kt ku jz kv kw kx kd jg ky kz kh jk la lb kl jo lc ld kp le bi translated">什么进展顺利？</h2><p id="e34d" class="pw-post-body-paragraph iv iw hi ix b iy ll ja jb jc lm je jf jg ln ji jj jk lo jm jn jo lp jq jr js hb bi translated">序列化本身工作得很好，官方文档中的例子也很容易理解和扩展。此外，Ktor的get请求非常有效。</p><h2 id="84eb" class="kr ju hi bd jv ks kt ku jz kv kw kx kd jg ky kz kh jk la lb kl jo lc ld kp le bi translated">有哪些需要改进的地方？</h2><p id="5fa8" class="pw-post-body-paragraph iv iw hi ix b iy ll ja jb jc lm je jf jg ln ji jj jk lo jm jn jo lp jq jr js hb bi translated">HttpResponse的读取造成了一些麻烦，因为我必须使用runBlocking块来运行它，因为它是一个挂起函数。我不知道这样的功能是什么，也不知道它有什么特别之处。</p><p id="1285" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">另一件事是，我对actions类的可空的lastSuccessfulBuild参数有一些问题。这个问题的解决方案非常简单合理。问题是我没有足够仔细地阅读stacktrace，这肯定需要改进。</p><p id="8ca9" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我希望这篇文章对你有用😃</p></div></div>    
</body>
</html>