<html>
<head>
<title>LeetCode — Remove Duplicates from Sorted Array II</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">LeetCode —从排序数组II中删除重复项</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/leetcode-remove-duplicates-from-sorted-array-ii-c6ffff9e844d?source=collection_archive---------1-----------------------#2022-01-29">https://medium.com/nerd-for-tech/leetcode-remove-duplicates-from-sorted-array-ii-c6ffff9e844d?source=collection_archive---------1-----------------------#2022-01-29</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><h1 id="9c3a" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">问题陈述</h1><p id="d4e5" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">给定一个按<strong class="jf hj">非降序</strong>排序的整数数组<em class="kb"> nums </em>，就地移除一些重复元素，使得每个唯一元素最多出现<strong class="jf hj">两次</strong>。元素的<strong class="jf hj">相对顺序</strong>应保持与<strong class="jf hj">相同</strong>。</p><p id="edf2" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated">因为在某些语言中不可能改变数组的长度，所以必须将结果放在数组<em class="kb"> nums </em>的<strong class="jf hj">第一部分</strong>中。更正式的说法是，如果删除重复项后还有<em class="kb"> k </em>个元素，那么<em class="kb"> nums </em>的第一个<em class="kb"> k </em>个元素应该保存最终结果。除了前k个元素之外，剩下什么并不重要。</p><p id="95ba" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated">将最终结果放入nums 的前k个槽后，返回<em class="kb"> k。</em></p><p id="e1d3" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated">不要为另一个阵列分配额外空间。你必须通过用O(1)个额外的内存修改输入数组来做到这一点。</p><p id="2c95" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated"><strong class="jf hj">自定义判断:</strong></p><p id="96f1" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated">法官将使用以下代码测试您的解决方案:</p><pre class="kh ki kj kk fd kl km kn ko aw kp bi"><span id="9928" class="kq ig hi km b fi kr ks l kt ku">int[] nums = [...]; // Input array<br/>int[] expectedNums = [...]; // The expected answer with correct length<br/><br/>int k = removeDuplicates(nums); // Calls your implementation<br/><br/>assert k == expectedNums.length;<br/>for (int i = 0; i &lt; k; i++) {<br/>    assert nums[i] == expectedNums[i];<br/>}</span></pre><p id="44af" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated">如果所有的断言都通过了，那么你的解决方案就会被接受。</p><p id="0b77" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated">问题陈述摘自:<a class="ae kv" href="https://leetcode.com/problems/remove-duplicates-from-sorted-array-ii" rel="noopener ugc nofollow" target="_blank">https://leet code . com/problems/remove-duplicates-from-sorted-array-ii</a></p><p id="d8ed" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated"><strong class="jf hj">例1: </strong></p><pre class="kh ki kj kk fd kl km kn ko aw kp bi"><span id="8245" class="kq ig hi km b fi kr ks l kt ku">Input: nums = [1, 1, 1, 2, 2, 3]<br/>Output: 5, nums = [1, 1, 2, 2, 3, _]<br/>Explanation: Your function should return k = 5, with the first five elements of nums being 1, 1, 2, 2, and 3 respectively.<br/>It does not matter what you leave beyond the returned k (hence they are underscores).</span></pre><p id="9f1d" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated"><strong class="jf hj">例2: </strong></p><pre class="kh ki kj kk fd kl km kn ko aw kp bi"><span id="8689" class="kq ig hi km b fi kr ks l kt ku">Input: nums = [0, 0, 1, 1, 1, 1, 2, 3, 3]<br/>Output: 7, nums = [0, 0, 1, 1, 2, 3, 3, _, _]<br/>Explanation: Your function should return k = 7, with the first seven elements of nums being 0, 0, 1, 1, 2, 3, and 3 respectively.<br/>It does not matter what you leave beyond the returned k (hence they are underscores).</span></pre><p id="9496" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated"><strong class="jf hj">约束:</strong></p><pre class="kh ki kj kk fd kl km kn ko aw kp bi"><span id="3c20" class="kq ig hi km b fi kr ks l kt ku">- 1 &lt;= nums.length &lt;= 3 * 10^4 <br/>- -10^4 &lt;= nums[i] &lt;= 10^4 <br/>- nums is sorted in non-decreasing order.</span></pre><h1 id="e661" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">说明</h1><p id="794c" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">在我们之前的博客文章<a class="ae kv" href="https://alkeshghorpade.me/post/leetcode-remove-duplicates-from-sorted-array" rel="noopener ugc nofollow" target="_blank">中，我们已经看到了一个类似的问题。这个问题的唯一区别是，我们应该保持唯一元素最多出现两次。</a></p><p id="93c9" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated">如果我们观察前面的blog post算法，我们正在比较当前的第I个index元素和第I-1个index元素。</p><pre class="kh ki kj kk fd kl km kn ko aw kp bi"><span id="587c" class="kq ig hi km b fi kr ks l kt ku">int i = 0;<br/><br/>for(int j = 1; j &lt; nums.size(); j++){<br/>    if(nums[j] != nums[i]){<br/>        i++;<br/>        nums[i] = nums[j];<br/>    }<br/>}</span></pre><p id="c287" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated">条件<strong class="jf hj"> if(nums[j]！= nums[i]) </strong>比较两个相邻元素，如果(nums[i — 1]！= nums[i]) 。由于我们最多可以保留两个相似的元素，所以条件将类似于<strong class="jf hj"> if(nums[i — 1]！= nums[I]| | nums[I-2]！= nums[i]) </strong>。</p><p id="cfaf" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated">让我们检查算法，以获得一个清晰的图片。</p><pre class="kh ki kj kk fd kl km kn ko aw kp bi"><span id="d9b0" class="kq ig hi km b fi kr ks l kt ku">- set k = 2, n = nums.size()<br/><br/>- if n &lt;= 2<br/>  - return n<br/><br/>- loop for i = 2; i &lt; n; i++<br/>  - if nums[i] != nums[k - 2] || nums[i] != nums[k - 1]<br/>    - nums[k] = nums[i]<br/>    - k++<br/><br/>- return k</span></pre><p id="ddbd" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated">我们保留一个整数<strong class="jf hj"> k </strong>，仅当当前元素与前两个索引都不匹配时，它才更新数组的第<strong class="jf hj">个</strong>索引。如果第k个索引匹配第k-1和第k-2个元素，我们继续在数组中向前移动。让我们来看看我们在<strong class="jf hj"> C++ </strong>、<strong class="jf hj"> Golang </strong>和<strong class="jf hj"> Javascript </strong>中的解决方案。</p><h2 id="2e2a" class="kq ig hi bd ih kw kx ky il kz la lb ip jo lc ld it js le lf ix jw lg lh jb li bi translated">C++解决方案</h2><pre class="kh ki kj kk fd kl km kn ko aw kp bi"><span id="49d3" class="kq ig hi km b fi kr ks l kt ku">class Solution {<br/>public:<br/>    int removeDuplicates(vector&lt;int&gt;&amp; nums) {<br/>        int k = 2;<br/>        int n = nums.size();<br/><br/>        if(n &lt;= 2) {<br/>            return n;<br/>        }<br/><br/>        for(int i = 2; i &lt; n; i++){<br/>            if(nums[i] != nums[k - 2] || nums[i] != nums[k - 1]){<br/>                nums[k] = nums[i];<br/>                k++;<br/>            }<br/>        }<br/><br/>        return k;<br/>    }<br/>};</span></pre><h2 id="587d" class="kq ig hi bd ih kw kx ky il kz la lb ip jo lc ld it js le lf ix jw lg lh jb li bi translated">戈朗溶液</h2><pre class="kh ki kj kk fd kl km kn ko aw kp bi"><span id="f4c1" class="kq ig hi km b fi kr ks l kt ku">func removeDuplicates(nums []int) int {<br/>    k := 2<br/>    n := len(nums)<br/><br/>    if n &lt;= 2 {<br/>        return n<br/>    }<br/><br/>    for i := 2; i &lt; n; i++ {<br/>        if nums[i] != nums[k - 2] || nums[i] != nums[k - 1] {<br/>            nums[k] = nums[i]<br/>            k++<br/>        }<br/>    }<br/><br/>    return k<br/>}</span></pre><h2 id="54f8" class="kq ig hi bd ih kw kx ky il kz la lb ip jo lc ld it js le lf ix jw lg lh jb li bi translated">Javascript解决方案</h2><pre class="kh ki kj kk fd kl km kn ko aw kp bi"><span id="cd1a" class="kq ig hi km b fi kr ks l kt ku">var removeDuplicates = function(nums) {<br/>    let k = 2;<br/>    let n = nums.length;<br/><br/>    if(n &lt;= 2) {<br/>        return n;<br/>    }<br/><br/>    for(let i = 2; i &lt; n; i++) {<br/>        if(nums[i] != nums[k - 2] || nums[i] != nums[k - 1]) {<br/>            nums[k] = nums[i];<br/>            k++;<br/>        }<br/>    }<br/><br/>    return k;<br/>};</span></pre><p id="139a" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated">对于这个输入<strong class="jf hj"> nums = [1，1，1，2，2，3] </strong>，我们的<strong class="jf hj"> C++ </strong>方法的模拟运行如下:</p><pre class="kh ki kj kk fd kl km kn ko aw kp bi"><span id="148b" class="kq ig hi km b fi kr ks l kt ku">Input: nums = [1, 1, 1, 2, 2, 3]<br/><br/>Step 1: k = 2<br/>        n = nums.size()<br/>          = 6<br/><br/>Step 2: if n &lt;= 2<br/>           6 &lt;= 2<br/>           false<br/><br/>Step 3: loop for i = 2; i &lt; n;<br/>          2 &lt; 6<br/>          true<br/><br/>          if nums[i] != nums[k - 2] || nums[i] != nums[k - 1]<br/>             nums[2] != nums[0] || nums[2] != nums[1]<br/>             1 != 1 || 1 != 1<br/>             false<br/><br/>          i++<br/>          i = 3<br/><br/>Step 4: loop i &lt; n<br/>          3 &lt; 6<br/>          true<br/><br/>          if nums[i] != nums[k - 2] || nums[i] != nums[k - 1]<br/>             nums[3] != nums[0] || nums[3] != nums[1]<br/>             2 != 1 || 2 != 1<br/>             true<br/><br/>             nums[k] = nums[i]<br/>             nums[2] = nums[3]<br/>             nums[2] = 2<br/><br/>             k++<br/>             k = 3<br/><br/>             nums = [1, 1, 2, 2, 2, 3]<br/><br/>          i++<br/>          i = 4<br/><br/>Step 5: loop i &lt; n<br/>          4 &lt; 6<br/>          true<br/><br/>          if nums[i] != nums[k - 2] || nums[i] != nums[k - 1]<br/>             nums[4] != nums[1] || nums[4] != nums[2]<br/>             2 != 1 || 2 != 2<br/>             true<br/><br/>             nums[k] = nums[i]<br/>             nums[3] = nums[4]<br/>             nums[3] = 2<br/><br/>             k++<br/>             k = 4<br/><br/>             nums = [1, 1, 2, 2, 2, 3]<br/><br/>          i++<br/>          i = 5<br/><br/>Step 6: loop i &lt; n<br/>          5 &lt; 6<br/>          true<br/><br/>          if nums[i] != nums[k - 2] || nums[i] != nums[k - 1]<br/>             nums[5] != nums[2] || nums[5] != nums[3]<br/>             3 != 2 || 3 != 2<br/>             true<br/><br/>             nums[k] = nums[i]<br/>             nums[4] = nums[5]<br/>             nums[4] = 3<br/><br/>             k++<br/>             k = 5<br/><br/>             nums = [1, 1, 2, 2, 3, 3]<br/><br/>          i++<br/>          i = 6<br/><br/>Step 7: loop i &lt; n<br/>          6 &lt; 6<br/>          false<br/><br/>Step 8: return k<br/><br/>So we return the answer as 5, and the array till the 5th index is [1, 1, 2, 2, 3].</span></pre></div><div class="ab cl lj lk gp ll" role="separator"><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo"/></div><div class="hb hc hd he hf"><p id="8bc7" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated"><em class="kb">原发布于</em><a class="ae kv" href="https://alkeshghorpade.me/post/leetcode-remove-duplicates-from-sorted-array-ii" rel="noopener ugc nofollow" target="_blank"><em class="kb">https://alkeshghorpade . me</em></a><em class="kb">。</em></p></div></div>    
</body>
</html>