<html>
<head>
<title>AI Search Algorithms With Examples</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">人工智能搜索算法及实例</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/ai-search-algorithms-with-examples-54772c6d973a?source=collection_archive---------0-----------------------#2022-02-08">https://medium.com/nerd-for-tech/ai-search-algorithms-with-examples-54772c6d973a?source=collection_archive---------0-----------------------#2022-02-08</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="cc72" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">人工智能搜索算法在解决现实问题中的应用</h2></div><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ix"><img src="../Images/5e23378530c936ef47d2f1cafbc29d0d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SiYQQFPHNWZ6s8-Wu2ZCVA.jpeg"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">图1(<a class="ae jn" rel="noopener" href="/@pawara73">作者</a>的作品)</figcaption></figure><p id="357a" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">寻找已知的东西叫做“搜索”,与我们所说的寻找未知的东西的“研究”相反。顾名思义，人工智能搜索算法的职责也是搜索。解决问题是搜索的一个直接应用。在人工智能搜索算法的帮助下，可以为现实世界的问题制定有效和高效的解决方案。</p><p id="b04e" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">在深入研究算法之前，首先，我们应该了解一个问题的本质和一些相关的术语。一般来说，一个问题由4个主要部分组成，如状态、动作/操作、目标、路径。简而言之，问题解决可以被定义为一个过程，该过程包括沿着一条或多条路径通过动作或操作将一组状态转换为一个目标。</p><h2 id="ba39" class="kk kl hi bd km kn ko kp kq kr ks kt ku jx kv kw kx kb ky kz la kf lb lc ld le bi translated"><strong class="ak">状态空间</strong></h2><p id="9be8" class="pw-post-body-paragraph jo jp hi jq b jr lf ij jt ju lg im jw jx lh jz ka kb li kd ke kf lj kh ki kj hb bi translated">状态空间由所有可能的状态以及解决特定问题的动作组成。在状态空间的图形表示中(例如树)，状态由节点表示，而动作由弧线表示。任何状态空间都有一个初始“开始”节点和一个结束“目标”节点或多个目标状态。从初始开始节点到最终目标节点的路径被称为特定问题的“解决方案”。</p><blockquote class="lk ll lm"><p id="1205" class="jo jp ln jq b jr js ij jt ju jv im jw lo jy jz ka lp kc kd ke lq kg kh ki kj hb bi translated"><strong class="jq hj">注意:</strong>一个问题可能有多个目标和路径。</p></blockquote><h2 id="de74" class="kk kl hi bd km kn ko kp kq kr ks kt ku jx kv kw kx kb ky kz la kf lb lc ld le bi translated"><em class="lr">问题01: </em></h2><p id="f6f5" class="pw-post-body-paragraph jo jp hi jq b jr lf ij jt ju lg im jw jx lh jz ka kb li kd ke kf lj kh ki kj hb bi translated">为了清楚地理解状态空间，考虑下面的问题[图2]。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ls"><img src="../Images/c3fe0789326c79f845e986f90bd09ed7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jXXkXNsNsklEXR6Xr8_vwA.png"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">图2:例题(图片由<a class="ae jn" rel="noopener" href="/@pawara73">作者</a>设计)</figcaption></figure><p id="61ac" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">想象有一个机器人在房间‘A’(初始状态)，它需要去房间‘Z’(目标状态)。如果我们考虑机器人在每个房间(节点)的所有可能运动，我们可以用树的形式画出一个状态空间。例如，当机器人处于初始状态A时，他可以去B或d。当机器人移动到下一个状态B时，他可以移动到C、E或回到A[图3]。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es lt"><img src="../Images/c2e05f101fdbf99f298c6dc9bdb640ba.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JO09uJT8MXcz73mqdTEEMA.png"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">图3:机器人在状态B的可能路径(图片由<a class="ae jn" rel="noopener" href="/@pawara73">作者</a>设计)</figcaption></figure><p id="bd7f" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">基于机器人在每个状态下的所有可能运动，我们可以为上述场景绘制状态空间，如下所示:</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es lu"><img src="../Images/4afb7919b8ac9eb8776e247549daaaa5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rBFnkm0JWbjkf-o3iwSQjA.png"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">图4:状态空间图(图片由<a class="ae jn" rel="noopener" href="/@pawara73">作者</a>设计)</figcaption></figure><p id="5f05" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">除了直接路径A、B、C、z之外，我们还可以识别许多路径。</p><pre class="iy iz ja jb fd lv lw lx ly aw lz bi"><span id="bc18" class="kk kl hi lw b fi ma mb l mc md">Ex: A B C Z<br/>    A B A B C Z<br/>    A D E B C Z<br/>    A D E B A B C Z<br/>    ....</span></pre><p id="1a99" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">可以观察到，一些路径较短，而另一些路径较长。真正的问题出现在这里。在上面的例子中，状态空间很小，我们可以算出最佳/最短路径。但是想象一个有几十万个节点的状态空间。我们如何探索这样一个状态空间？</p><p id="1bac" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">解决办法无非是搜索算法。下一章，我们将讨论人工智能中的08大搜索算法。</p><h1 id="f6f0" class="me kl hi bd km mf mg mh kq mi mj mk ku io ml ip kx ir mm is la iu mn iv ld mo bi translated">搜索算法</h1><p id="6d3c" class="pw-post-body-paragraph jo jp hi jq b jr lf ij jt ju lg im jw jx lh jz ka kb li kd ke kf lj kh ki kj hb bi translated">由于状态空间通常非常大，我们采用搜索算法来有效且高效地在状态空间中导航。搜索算法定义了如何找到从初始状态到目标状态的路径(解)。不同的算法定义了从当前状态(节点)移动到下一个状态(节点)的不同方法。一些算法只提供探索状态空间的系统方法，而其他算法告诉如何有效和高效地探索。</p><p id="b469" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">搜索算法有两种类型，即无信息搜索算法和有信息搜索算法[图5]。知情搜索算法仅提供了探索状态空间的系统方法，并且没有提供额外的信息来支持搜索过程。广度优先搜索、均匀搜索、深度优先搜索、深度受限搜索、迭代深化搜索和双向搜索是06种主要的无信息搜索算法。</p><p id="2437" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">另一方面，诸如贪婪搜索和A*搜索算法的信息搜索算法是基于附加信息的，这使得搜索过程既系统又有效。</p><blockquote class="lk ll lm"><p id="a04f" class="jo jp ln jq b jr js ij jt ju jv im jw lo jy jz ka lp kc kd ke lq kg kh ki kj hb bi translated"><strong class="jq hj">注意:</strong>有一些人工智能搜索算法不属于上述任何一个主要类别。因为，有些问题不需要特定的路径来解决，而是关注搜索过程是否能达到目标状态。在应用搜索解决这类问题时，我们只需在附近找到最佳可用节点(局部搜索)，或者在竞争环境中搜索(对抗性搜索)。</p><p id="e2ff" class="jo jp ln jq b jr js ij jt ju jv im jw lo jy jz ka lp kc kd ke lq kg kh ki kj hb bi translated">一些游戏，像国际象棋，爬山，某些设计和时间安排的问题。</p></blockquote><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es mp"><img src="../Images/836a325844ce74ae8fcabf000e618569.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Dhe1UZ_KtqiMfS3rBOTihw.png"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">图5:人工智能搜索算法分类(图片由<a class="ae jn" rel="noopener" href="/@pawara73">作者</a>设计)</figcaption></figure><h2 id="6cc0" class="kk kl hi bd km kn ko kp kq kr ks kt ku jx kv kw kx kb ky kz la kf lb lc ld le bi translated"><strong class="ak">搜索算法评估标准:</strong></h2><p id="e864" class="pw-post-body-paragraph jo jp hi jq b jr lf ij jt ju lg im jw jx lh jz ka kb li kd ke kf lj kh ki kj hb bi translated">我们采用了4个标准来评估上面提到的每种搜索算法的性能。它们是:</p><ol class=""><li id="2bd3" class="mq mr hi jq b jr js ju jv jx ms kb mt kf mu kj mv mw mx my bi translated"><strong class="jq hj">完备性:</strong>在有解的情况下找到解的能力(算法在到达状态空间的任何目标节点/末端之前，不应遗漏任何节点)。</li><li id="2adc" class="mq mr hi jq b jr mz ju na jx nb kb nc kf nd kj mv mw mx my bi translated"><strong class="jq hj">最优性:</strong>找到最高质量解的能力(算法应该先找到较浅层次的目标节点)。</li><li id="9973" class="mq mr hi jq b jr mz ju na jx nb kb nc kf nd kj mv mw mx my bi translated"><strong class="jq hj">时间复杂度:</strong>算法处理节点需要多长时间。(算法的执行时间/ CPU时间)</li><li id="b380" class="mq mr hi jq b jr mz ju na jx nb kb nc kf nd kj mv mw mx my bi translated"><strong class="jq hj">空间复杂度:</strong>算法使用多少内存来存储节点。</li></ol><p id="a30d" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">为了理解上述算法的应用，首先考虑下面的场景。接下来，我们将应用每种搜索算法来找到解决方案，并根据提到的评估标准比较性能。</p><h2 id="87d2" class="kk kl hi bd km kn ko kp kq kr ks kt ku jx kv kw kx kb ky kz la kf lb lc ld le bi translated">问题02:</h2><p id="0062" class="pw-post-body-paragraph jo jp hi jq b jr lf ij jt ju lg im jw jx lh jz ka kb li kd ke kf lj kh ki kj hb bi translated">如何在健身房选择合适的一套运动器材，节省时间，燃烧最大的热量？</p><p id="b91e" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">“健身房里充满了不同的运动器材，它们的卡路里燃烧率各不相同。锻炼时，重要的是覆盖全身，而不是身体的一部分。选择恢复时间最短的锻炼方法可以减少锻炼的总时间以及对身体的损害。因此，选择正确的运动器材来燃烧目标卡路里，并让整个身体都参与到运动过程中来，并且最不容易造成伤害是很重要的。该场景基于表1中给出的信息和状态空间(图6)。”</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ne"><img src="../Images/4eeb3827a30f202e5e8f34cc7e9a2e6a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3OIFobQfl2XPB3WP5_MB7g.jpeg"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">表1:不同的运动器材与卡路里消耗的对比(由<a class="ae jn" rel="noopener" href="/@pawara73">作者</a>设计)</figcaption></figure><pre class="iy iz ja jb fd lv lw lx ly aw lz bi"><span id="590d" class="kk kl hi lw b fi ma mb l mc md"><strong class="lw hj">Path Cost:</strong> Time taken to burn 300 Cal (minutes)<br/><strong class="lw hj">Heuristic Value:</strong> Recovery time required after burning 300 Cal (minutes)</span></pre><blockquote class="lk ll lm"><p id="11f7" class="jo jp ln jq b jr js ij jt ju jv im jw lo jy jz ka lp kc kd ke lq kg kh ki kj hb bi translated"><strong class="jq hj">注意:</strong>路径成本和启发值的单位相同。</p></blockquote><p id="6aff" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">基于上述信息，绘制了以下状态空间图[图6]。这是一个有多个路径但只有一个目标节点的问题。下图包括路径成本和启发式值。但是请注意，只有某些算法需要额外的信息。沿着每条路径，全身部分(上半身、下半身和下半身)都包括在内。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es nf"><img src="../Images/ce21c9860324001944221707efe4edc2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*alTkXIRVFhY1WldKhGBUVg.png"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">图6:问题02的状态空间(图片由<a class="ae jn" rel="noopener" href="/@pawara73">作者</a>设计)</figcaption></figure><p id="6036" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">现在我们将讨论无信息和有信息搜索算法的特征，同时将它们应用于上述状态空间。</p><blockquote class="lk ll lm"><p id="968f" class="jo jp ln jq b jr js ij jt ju jv im jw lo jy jz ka lp kc kd ke lq kg kh ki kj hb bi translated"><strong class="jq hj">注意:</strong>为了实现搜索，通常我们使用两个列表来存储开放节点(要访问的节点/边缘节点)和关闭节点(已经访问的节点)。</p></blockquote><p id="45e4" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">为了演示每个算法，我使用了一个在线模拟工具:<a class="ae jn" href="https://ali-elganzory.github.io/AI-Search/" rel="noopener ugc nofollow" target="_blank">AI Search(Ali-elganzory . github . io)</a></p><h1 id="ad8d" class="me kl hi bd km mf mg mh kq mi mj mk ku io ml ip kx ir mm is la iu mn iv ld mo bi translated">1.不知情的搜索算法</h1><p id="06fd" class="pw-post-body-paragraph jo jp hi jq b jr lf ij jt ju lg im jw jx lh jz ka kb li kd ke kf lj kh ki kj hb bi translated">不知情搜索算法遵循系统的方式在状态空间中进行探索，并且不使用额外的信息(启发式)</p><h2 id="c824" class="kk kl hi bd km kn ko kp kq kr ks kt ku jx kv kw kx kb ky kz la kf lb lc ld le bi translated">1.1广度优先搜索(BFS)</h2><p id="c03d" class="pw-post-body-paragraph jo jp hi jq b jr lf ij jt ju lg im jw jx lh jz ka kb li kd ke kf lj kh ki kj hb bi translated">顾名思义，BFS算法逐层探索状态空间[图7]。当我们探索一个节点时，子节点总是被添加到开放列表的末尾。当从OPEN中删除要添加到CLOSED中的节点时，检查它是否是目标节点，如果是，则停止。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ng"><img src="../Images/80a14924b9fe89e2e137309e7709764c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*fDZp9pyZZgDT6Mq9h3oodg.gif"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">图7:广度优先搜索中的状态空间(左)和状态空间遍历(右)(图片由<a class="ae jn" rel="noopener" href="/@pawara73">作者</a>设计)</figcaption></figure><pre class="iy iz ja jb fd lv lw lx ly aw lz bi"><span id="5314" class="kk kl hi lw b fi ma mb l mc md"><strong class="lw hj">Path:</strong> 0, 1, 5, 10, 13</span></pre><p id="206f" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">遍历在封闭列表中。但是开放列表和封闭列表一起增加了空间复杂度，因为存储在存储器中的节点总数是开放列表和封闭列表的总和。</p><p id="0b60" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">由于开放列表中目标节点以外的节点不被处理，BFS的时间复杂度只与封闭列表中的节点数有关。由于状态空间是逐层探索的，如果有解，那就<strong class="jq hj">肯定</strong>找到了。因此BFS是完整的。BFS是最优的，因为较浅层次的目标节点首先被找到。</p><p id="027d" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">在BFS中，具有分支因子‘b’并且找到的目标节点的级别为‘d’的状态空间的空间复杂度为<strong class="jq hj"> O( <em class="ln"> bᵈ⁺ </em> ) </strong>。时间复杂度是<strong class="jq hj"> O( <em class="ln"> bᵈ </em> ) </strong>因为虽然内存包含来自‘d+1’的节点，但是‘d’以外的节点不在BFS中处理。</p><h2 id="8388" class="kk kl hi bd km kn ko kp kq kr ks kt ku jx kv kw kx kb ky kz la kf lb lc ld le bi translated">1.2深度优先搜索(DFS)</h2><p id="ef66" class="pw-post-body-paragraph jo jp hi jq b jr lf ij jt ju lg im jw jx lh jz ka kb li kd ke kf lj kh ki kj hb bi translated">在DFS中，状态空间是沿着分支深度方向探索的。它沿着每个分支检查目标节点。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ng"><img src="../Images/36c8b527845a8a873f48197028addfc6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*biLRqP6-1w22TtvxjMpTwA.gif"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">图8:深度优先搜索中的状态空间(左)和状态空间遍历(右)(图片由<a class="ae jn" rel="noopener" href="/@pawara73">作者</a>设计)</figcaption></figure><pre class="iy iz ja jb fd lv lw lx ly aw lz bi"><span id="e806" class="kk kl hi lw b fi ma mb l mc md"><strong class="lw hj">Path:</strong> 0, 4, 9, 12, 13</span></pre><p id="778d" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">因为DFS在较浅层次的目标之前识别较深层次的目标，所以它不是最佳的。DFS也不完整。因为，如果在状态空间中的一个分支中有一个循环，即使我们可以沿着另一个分支找到目标节点，由于这个循环，我们仍然不能到达那个分支。</p><p id="d86b" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">令人惊讶的是，DFS的内存使用率非常低。它只存储沿着分支的节点，因此在每一层中存储最小数量的节点，而不像在BFS中，所有的节点都存储在每一层中。在最坏的情况下，如果具有分支因子“b”的搜索树的最大深度是“m”，那么DFS的空间和时间复杂度分别是<strong class="jq hj"> O( <em class="ln"> bm </em> ) </strong>和<strong class="jq hj"> O( <em class="ln"> bᵐ </em> ) </strong>。</p><h2 id="0fd8" class="kk kl hi bd km kn ko kp kq kr ks kt ku jx kv kw kx kb ky kz la kf lb lc ld le bi translated">1.3深度限制搜索(DLS)</h2><p id="dc88" class="pw-post-body-paragraph jo jp hi jq b jr lf ij jt ju lg im jw jx lh jz ka kb li kd ke kf lj kh ki kj hb bi translated">在DFS中，您会注意到它不是最佳的，即:如果目标出现在较浅的级别，则不会首先被发现。如果我们给搜索的深度设定一个极限会怎么样？在DFS中，我们可以设置深度限制，这样就不会搜索超出该树的内容。所以，如果目标是在一个较浅的层次，那么就很快找到了。但是如果目标超出了我们设定的水平呢？这也是我们的示例场景中发生的事情[图9]。在这里，深度被设置为3级，但是目标节点在4级，所以搜索将永远无法找到目标节点。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ng"><img src="../Images/cb1be7ce1a762c451e55d80cd0b4afa6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*ymrfHQ0w0CLTE4GbjqAjEQ.gif"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">图9:状态空间遍历深度受限搜索(图片由<a class="ae jn" rel="noopener" href="/@pawara73">作者</a>设计)</figcaption></figure><pre class="iy iz ja jb fd lv lw lx ly aw lz bi"><span id="a2f0" class="kk kl hi lw b fi ma mb l mc md"><strong class="lw hj">Path:</strong> Not found</span></pre><p id="c788" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">在DLS中，它既不完整也不是最优的，因为不是图中的所有节点都被检查，并且不能有效地找到目标节点。如果我们为具有分支因子‘b’的状态空间设置深度极限‘l’，那么DLS的空间和时间复杂度将分别为<strong class="jq hj"> O( <em class="ln"> bl </em> ) </strong>和<strong class="jq hj"> O( <em class="ln"> bˡ </em> ) </strong>。</p><h2 id="8829" class="kk kl hi bd km kn ko kp kq kr ks kt ku jx kv kw kx kb ky kz la kf lb lc ld le bi translated">1.4迭代深化搜索(IDS)</h2><p id="d237" class="pw-post-body-paragraph jo jp hi jq b jr lf ij jt ju lg im jw jx lh jz ka kb li kd ke kf lj kh ki kj hb bi translated">在IDS中，我们迭代地增加深度限制并执行DFS，直到找到目标节点。使用DFS有助于减少存储节点的内存使用。并且由于如果目标节点处于较浅的级别(最优)，则状态空间被迭代地探索(逐层)，所以在深入之前首先找到它，并且完全检查一层中的所有节点(完整性)。</p><p id="e2b6" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">因此，IDS兼有DFS(占用较少的存储空间)和BFS(完全和最优)的优点，并且消除了DLS所面临的问题。下面的动画展示了在IDS下遍历状态空间的过程[图10]。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ng"><img src="../Images/5e0386571d39e0894ab50f9a84951ed3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*h3aYO43bClu-gkWlrURTMA.gif"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">图10:迭代深化搜索中的状态空间(左)和状态空间遍历(右)(图片由<a class="ae jn" rel="noopener" href="/@pawara73">作者</a>设计)</figcaption></figure><pre class="iy iz ja jb fd lv lw lx ly aw lz bi"><span id="2a09" class="kk kl hi lw b fi ma mb l mc md"><strong class="lw hj">Path:</strong> 0, 4, 9, 12, 13</span></pre><h2 id="238b" class="kk kl hi bd km kn ko kp kq kr ks kt ku jx kv kw kx kb ky kz la kf lb lc ld le bi translated">1.5双向搜索(BDS)</h2><p id="b88a" class="pw-post-body-paragraph jo jp hi jq b jr lf ij jt ju lg im jw jx lh jz ka kb li kd ke kf lj kh ki kj hb bi translated">如果我们同时运行两个BFS搜索算法，则应用BDS:一个是从“开始节点”向前到“目标节点”,另一个是从“目标”向后到“开始”,等待两个搜索在中间相遇。正因为如此，时间和空间复杂度都变成了那个BFS的一半的两倍(比BFS的O( <em class="ln"> bᵈ </em>)小得多)。对于具有分支因子‘b’和深度‘d’的图，BDS的空间和时间复杂度用<strong class="jq hj"> O( <em class="ln"> bᵈ/ </em> ) </strong>表示。</p><blockquote class="lk ll lm"><p id="8d3e" class="jo jp ln jq b jr js ij jt ju jv im jw lo jy jz ka lp kc kd ke lq kg kh ki kj hb bi translated"><strong class="jq hj">注:</strong>既然，2×o(<em class="hi">bᵈ/</em>)≈o(<em class="hi">bᵈ/</em>)，我们就用O( <em class="hi"> bᵈ/ </em>)代替2O( <em class="hi"> bᵈ/ </em>)</p></blockquote><p id="bf9b" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">但是BDS不适用于像我们的例子这样的情况，一些子节点有多个父节点(例如:node-9有node-3和node-4作为父节点)。因为向后搜索算法不能确定从多个父节点中跟随哪个节点。</p><h2 id="56f8" class="kk kl hi bd km kn ko kp kq kr ks kt ku jx kv kw kx kb ky kz la kf lb lc ld le bi translated">1.6统一成本搜索(UCS)</h2><p id="8385" class="pw-post-body-paragraph jo jp hi jq b jr lf ij jt ju lg im jw jx lh jz ka kb li kd ke kf lj kh ki kj hb bi translated">在UCS中，从一个节点到另一个节点的每个动作(边)都被赋予一个值。并且每个节点与从“开始节点”到特定节点计算的总路径成本相关联。在UCS中，考虑的是总路径开销，而不是深度。</p><p id="c6cd" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">类似于BFS，我们扩展开放列表中最低成本的节点而不是最浅的节点。虽然在BFS，图中的交叉连接被忽略，但在这里它们被考虑，因为每条路径都与一个值相关联。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ng"><img src="../Images/4ab7b71edeb4535571cbbd4b99a26f04.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*xJMKYrlbtPDMdRrFVmVm1w.gif"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">图11:统一成本搜索中的状态空间(左)和状态空间遍历(右)(图片由<a class="ae jn" rel="noopener" href="/@pawara73">作者</a>设计)</figcaption></figure><pre class="iy iz ja jb fd lv lw lx ly aw lz bi"><span id="21db" class="kk kl hi lw b fi ma mb l mc md"><strong class="lw hj">f(n) = g(n)<br/> </strong>    = Summation(total path cost to each node from start node)<br/> <strong class="lw hj">    </strong>= (Node0-Node1)+(Node1-Node6)+(Node6-Node10)+(Node10-Node13)<br/>     = 10 + 15 + 10 + 11<br/>     = 46 (path cost)<br/><strong class="lw hj">Path:</strong> 0, 1, 6, 10, 13 (Path with the least path cost)</span></pre><p id="b502" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">根据我们的场景，上面只计算了最低成本路径。在动画[图11]中，您可以观察到遍历与BFS非常相似，但考虑到了成本。因此，UCS是完全最优的，其时间和空间复杂度与BFS相似，分别为<strong class="jq hj"> O( <em class="ln"> bᵈ </em> ) </strong>和<strong class="jq hj"> O( <em class="ln"> bᵈ⁺ </em> ) </strong>。</p><h1 id="c142" class="me kl hi bd km mf mg mh kq mi mj mk ku io ml ip kx ir mm is la iu mn iv ld mo bi translated">2.知情搜索算法</h1><p id="2168" class="pw-post-body-paragraph jo jp hi jq b jr lf ij jt ju lg im jw jx lh jz ka kb li kd ke kf lj kh ki kj hb bi translated">在知情搜索算法中，使用附加信息来使搜索更加高效和有效。这些额外的信息被称为<strong class="jq hj">启发法</strong>。启发式不是理论，而是一些常识性的经验，比如信息。</p><p id="86f8" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><strong class="jq hj">例如:</strong> <em class="ln">如果你开车在两个城市之间旅行，启发式的将是交通水平。(直接路径成本将是两个城市之间的距离。城市间的位移和交通等附加信息被视为启发式信息)</em></p><p id="fa29" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">在知情搜索算法中，为了找到接下来要访问的最佳节点，我们使用一个<em class="ln">评估函数</em> <strong class="jq hj"> f(n) </strong>来帮助子节点决定接下来要访问哪个节点。然后，我们遍历到具有最小f(n) 值的下一个节点。根据f(n ),我们有两种搜索算法，贪婪搜索和A*搜索算法。</p><h2 id="4972" class="kk kl hi bd km kn ko kp kq kr ks kt ku jx kv kw kx kb ky kz la kf lb lc ld le bi translated">2.1贪婪搜索算法</h2><p id="52cf" class="pw-post-body-paragraph jo jp hi jq b jr lf ij jt ju lg im jw jx lh jz ka kb li kd ke kf lj kh ki kj hb bi translated">在贪婪搜索中，考虑子节点的启发值。通过计算具有最低启发值的节点的路径来确定路径。另一个需要注意的事实是，通常初始节点的启发值最高，目标节点的启发值最低。但是也有例外，比如为初始节点获取一个中间值。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ng"><img src="../Images/d2833fd2ed771a2730c9fe4f496ad127.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*Wjh2o2xhrFDvlNhV0ckheg.gif"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">图12:贪婪搜索中的状态空间(左)和状态空间遍历(右)(图片由<a class="ae jn" rel="noopener" href="/@pawara73">作者</a>设计)</figcaption></figure><pre class="iy iz ja jb fd lv lw lx ly aw lz bi"><span id="ebb9" class="kk kl hi lw b fi ma mb l mc md"><strong class="lw hj">f(n) = h(n)<br/>     </strong>= Summation(Heuristic values of nodes)<strong class="lw hj"><br/>     </strong>= Node0 + Node2 + Node7 + Node11 + Node13<br/>     = 5 + 10 + 8 + 5 + 0<br/>     = 28<br/><strong class="lw hj">Path:</strong> 0, 2, 7, 11, 13</span></pre><p id="ddbc" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">在贪婪搜索中，您可以看到我们没有访问特定节点的所有子节点。我们找到每个子节点的试探法，只有具有最低值的子节点被插入到要处理的开放列表中。因此贪婪搜索是不完整的。同样，这也不是最佳路径(不是最短路径——我们在统一成本搜索中找到了这条路径)。因此，贪婪搜索也不是最优的。作为解决方案，我们不仅要考虑启发值，还要考虑路径成本。A*算法来了。</p><h2 id="20c6" class="kk kl hi bd km kn ko kp kq kr ks kt ku jx kv kw kx kb ky kz la kf lb lc ld le bi translated">2.2 A*搜索算法</h2><p id="28e1" class="pw-post-body-paragraph jo jp hi jq b jr lf ij jt ju lg im jw jx lh jz ka kb li kd ke kf lj kh ki kj hb bi translated">在A*算法中，我们同时考虑了路径成本和启发式算法。在A*中，f(n)函数包括两个部分:路径成本[g(n)]和启发式值([h(n)]。节点“a”的f(n)值可计算如下:</p><pre class="iy iz ja jb fd lv lw lx ly aw lz bi"><span id="2ab4" class="kk kl hi lw b fi ma mb l mc md">f(n)ₐ = g(n)ₐ + h(n)ₐ</span><span id="6510" class="kk kl hi lw b fi nh mb l mc md">f(n)ₐ = Evaluation value at the particular node (node 'a')<br/>g(n)ₐ = Total path cost from start node to particular node(node 'a')<br/>h(n)ₐ = The heuristic value of the particular node(node 'a')</span></pre><p id="a754" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">现在，我们将根据上一个问题的A*搜索算法找到最佳路径。我们必须找到每个节点的f(n)值，并选择具有最小f(n)值的子节点，然后遍历直到遇到目标节点。在这个例子中，只提到了路径中目标的f(n)值。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ng"><img src="../Images/88f4eddcded113e15747453cc8d47fb4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*vnVBopX6x4VeydyVCExqhQ.gif"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">图13:a*搜索中的状态空间(左)和状态空间遍历(右)(图片由<a class="ae jn" rel="noopener" href="/@pawara73">作者</a>设计)</figcaption></figure><pre class="iy iz ja jb fd lv lw lx ly aw lz bi"><span id="dc6b" class="kk kl hi lw b fi ma mb l mc md">At Node-0 :<br/>    f(n)₀ =  0 +  5 = 5<br/>At Node-3:<br/>    f(n)₃ = 10 + 12 = 22<br/>At Node-8:<br/>    f(n)₈ = 30 + 10 = 40<br/>At Node-11:<br/>    f(n)₁₁ = 36 + 5 = 41<br/>At Node-13:<br/>    f(n)₁₃ = 46 + 0 = 46<br/><br/>f(n)ₜₒₜₐₗ = f(n)₀ + f(n)₃ + f(n)₈ + f(n)₁₁ + f(n)₁₃ = 154</span><span id="68f5" class="kk kl hi lw b fi nh mb l mc md"><strong class="lw hj">Path:</strong> 0, 3, 8, 11, 13</span></pre><p id="e874" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">A*算法是完整的，因为它在到达目标节点/状态空间的末端之前检查所有节点。这也是最优的，因为考虑到路径成本和启发式值，因此可以用A*找到具有最低启发式的最低路径。A*的一个缺点是，它将处理的所有节点都存储在内存中。因此，对于分支因子‘b’和深度‘d’的状态空间，A*的空间和时间复杂度由<strong class="jq hj"> O( <em class="ln"> bᵈ </em> ) </strong>表示。A*的时间复杂度取决于启发值。</p><h1 id="ffb8" class="me kl hi bd km mf mg mh kq mi mj mk ku io ml ip kx ir mm is la iu mn iv ld mo bi translated">搜索算法比较综述</h1><p id="05dc" class="pw-post-body-paragraph jo jp hi jq b jr lf ij jt ju lg im jw jx lh jz ka kb li kd ke kf lj kh ki kj hb bi translated">每种有根据的搜索算法的概要可以总结如下。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ni"><img src="../Images/cb1aa85391f9eb4bb32bb3224f1f3ab0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1IEi2n9dlckjyyJmODIwkA.png"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">表2:04主要评价标准下的搜索算法比较(由<a class="ae jn" href="https://pawara73.medium.com/" rel="noopener">作者</a>设计)</figcaption></figure><blockquote class="lk ll lm"><p id="d044" class="jo jp ln jq b jr js ij jt ju jv im jw lo jy jz ka lp kc kd ke lq kg kh ki kj hb bi translated"><strong class="jq hj">注:</strong>如果状态空间图的分支因子是有限的，则所有的BFS、IDS、BDS(如果算法可以双向应用)、UCS都是完备的。如果算法可以应用于两个方向，并且步骤成本相同，则BDS是完整的。</p></blockquote><h1 id="982a" class="me kl hi bd km mf mg mh kq mi mj mk ku io ml ip kx ir mm is la iu mn iv ld mo bi translated"><strong class="ak">结论</strong></h1><p id="103c" class="pw-post-body-paragraph jo jp hi jq b jr lf ij jt ju lg im jw jx lh jz ka kb li kd ke kf lj kh ki kj hb bi translated">在知情搜索算法中，基于启发式值来执行状态空间上的探索，但是在知情搜索中，特别是以特定于算法的系统方式来执行探索。</p><p id="7b5c" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">当考虑无信息搜索算法时，如果状态空间中的每个子节点只有一个父节点，则在完整性、最优性、时间复杂度和空间复杂度方面最佳的搜索算法是双向搜索算法。但是如果子节点多于父节点，则在状态空间中双向搜索是不适用的，它是IDS算法，因为它是最优的、完全的，空间复杂度是(bm)的量级，时间复杂度是(bᵈ)的量级，这与其他算法类似。</p><p id="4fdc" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">最佳搜索算法是A*，因为它是最优的、完整的并且采用了额外的信息(启发法),所以解决方案优于其他算法。</p><h1 id="6507" class="me kl hi bd km mf mg mh kq mi mj mk ku io ml ip kx ir mm is la iu mn iv ld mo bi translated">参考资料:</h1><p id="446c" class="pw-post-body-paragraph jo jp hi jq b jr lf ij jt ju lg im jw jx lh jz ka kb li kd ke kf lj kh ki kj hb bi translated"><a class="ae jn" href="https://www.cin.ufpe.br/~tfl2/artificial-intelligence-modern-approach.9780131038059.25368.pdf" rel="noopener ugc nofollow" target="_blank">https://www . CIN . ufpe . br/~ TF L2/artificial-intelligence-modern-approach . 9780131038059.25368 . pdf</a></p><p id="9788" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><a class="ae jn" href="http://www.ccpo.odu.edu/~klinck/Reprints/PDF/wikipediaNav2018.pdf" rel="noopener ugc nofollow" target="_blank">http://www . ccpo . odu . edu/~ klink/reprings/PDF/Wikipedia nav 2018 . PDF</a></p></div></div>    
</body>
</html>