<html>
<head>
<title>Using Contour External Auth Server</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用轮廓外部认证服务器</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/using-contour-external-auth-server-d8312a131c9c?source=collection_archive---------8-----------------------#2021-05-27">https://medium.com/nerd-for-tech/using-contour-external-auth-server-d8312a131c9c?source=collection_archive---------8-----------------------#2021-05-27</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="f91a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">总结</strong></p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es jd"><img src="../Images/2477918588ed60ac350f7ff49637ed43.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*_88XvLGzZRpMi-EO.png"/></div></div></figure><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es jp"><img src="../Images/1b0db0e46c5b10d5b86cc6eedc6abf38.png" data-original-src="https://miro.medium.com/v2/resize:fit:560/0*ZlPVcP5R91J9bzGg"/></div></figure><p id="df85" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Contour 是 K8s 环境的入口控制器:【https://projectcontour.io/】T2。它在幕后使用特使代理:【https://www.envoyproxy.io/】T4</p><p id="a1e0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Contour 的一个有趣特性是它支持外部客户端授权(<a class="ae jq" href="https://projectcontour.io/guides/external-authorization/" rel="noopener ugc nofollow" target="_blank">https://projectcontour.io/guides/external-authorization/</a>)。因为 envoy 支持外部授权(<a class="ae jq" href="https://www.envoyproxy.io/docs/envoy/latest/api-v3/extensions/filters/http/ext_authz/v3/ext_authz.proto.html" rel="noopener ugc nofollow" target="_blank">https://www . envoy proxy . io/docs/envoy/latest/API-v3/extensions/filters/http/ext _ authz/v3/ext _ authz . proto . html</a>)，所以 Contour 能够集成到其中，提供一个使用 K8s 服务的优雅解决方案。在本文中，让我们看看如何在 K8s 中创建一个外部授权服务，以支持如下用例。基于客户端上下文支持 RBAC<br/>2。基于客户端上下文的 API 防火墙等等。</p><p id="d613" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在本文中，我们将尝试做这些用例的初步实现。我正在使用 docker desktop 在我的 Mac 上创建一个 Kubernetes 集群。</p><p id="ac5f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">设置</strong></p><p id="2ca2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">安装等高线图:</p><pre class="je jf jg jh fd jr js jt ju aw jv bi"><span id="4999" class="jw jx hi js b fi jy jz l ka kb"># helm repo add bitnami https://charts.bitnami.com/bitnami<br/># helm install contour-example bitnami/contour</span></pre><p id="755c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这将创建以下窗格:</p><pre class="je jf jg jh fd jr js jt ju aw jv bi"><span id="dc02" class="jw jx hi js b fi jy jz l ka kb"># kubectl get pods | grep contour<br/>contour-example-contour-68bdf8788b-98kqm 1/1 Running 0 3m21s<br/>contour-example-contour-68bdf8788b-r8jhx 1/1 Running 0 3m43s<br/>contour-example-envoy-76hxc              2/2 Running 0 62s</span></pre><p id="057b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">部署一个示例 web 应用程序(<a class="ae jq" href="https://projectcontour.io/getting-started/" rel="noopener ugc nofollow" target="_blank">https://projectcontour.io/getting-started/</a>):</p><pre class="je jf jg jh fd jr js jt ju aw jv bi"><span id="d99f" class="jw jx hi js b fi jy jz l ka kb"># cat kuard.yaml</span><span id="1376" class="jw jx hi js b fi kc jz l ka kb">apiVersion: apps/v1<br/>kind: Deployment<br/>metadata:<br/> labels:<br/> app: kuard<br/> name: kuard<br/>spec:<br/> replicas: 1<br/> selector:<br/> matchLabels:<br/> app: kuard<br/> template:<br/> metadata:<br/> labels:<br/> app: kuard<br/> spec:<br/> containers:<br/> — image: gcr.io/kuar-demo/kuard-amd64:1<br/> name: kuard<br/> — -<br/>apiVersion: v1<br/>kind: Service<br/>metadata:<br/> labels:<br/> app: kuard<br/> name: kuard<br/>spec:<br/> ports:<br/> — port: 8080<br/> protocol: TCP<br/> targetPort: 8080<br/> selector:<br/> app: kuard<br/> sessionAffinity: None<br/> type: ClusterIP</span><span id="d82e" class="jw jx hi js b fi kc jz l ka kb"># kubectl apply -f kuard.yaml</span></pre><p id="2f64" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">确认您可以连接到应用程序:</p><pre class="je jf jg jh fd jr js jt ju aw jv bi"><span id="f463" class="jw jx hi js b fi jy jz l ka kb"># kubectl port-forward kuard-&lt;pod id&gt; 8080:8080<br/>Forwarding from 127.0.0.1:8080 -&gt; 8080<br/>Forwarding from [::1]:8080 -&gt; 8080<br/>Handling connection for 8080<br/>Handling connection for 8080</span><span id="d253" class="jw jx hi js b fi kc jz l ka kb"># curl localhost:8080<br/>&lt;!doctype html&gt;</span><span id="8644" class="jw jx hi js b fi kc jz l ka kb">&lt;html lang="en"&gt;<br/>&lt;head&gt;<br/>  &lt;meta charset="utf-8"&gt;</span><span id="e8d0" class="jw jx hi js b fi kc jz l ka kb">&lt;title&gt;KUAR Demo&lt;/title&gt;<br/>...</span></pre><p id="fb4d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们首先创建一个支持 TLS 的外部认证服务。该服务本质上是一个 gRPC 服务器，可以用任何语言实现。此 gRPC 服务器使用此协议:<a class="ae jq" href="https://github.com/envoyproxy/envoy/blob/main/api/envoy/service/auth/v2/external_auth.proto" rel="noopener ugc nofollow" target="_blank">https://github . com/envoy proxy/envoy/proxy/blob/main/API/envoy/service/auth/v2/external _ auth . proto</a></p><p id="47f8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我选择了 Java 来实现外部认证服务器。要进行部署，请执行以下步骤:</p><ol class=""><li id="ebaa" class="kd ke hi ih b ii ij im in iq kf iu kg iy kh jc ki kj kk kl bi translated">克隆 repo:<a class="ae jq" href="https://github.com/sudhindra-hub/external-auth-demo/tree/master" rel="noopener ugc nofollow" target="_blank">https://github . com/sudhindra-hub/external-auth-demo/tree/master</a></li></ol><pre class="je jf jg jh fd jr js jt ju aw jv bi"><span id="8333" class="jw jx hi js b fi jy jz l ka kb"># make all </span></pre><p id="0f6f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">3.我们现在将在 Kubernetes 部署它。但是在此之前，我们应该在 Kubernetes 内部公开我们在 HTTPS 上的服务。为此，我们将创建一个自签名证书和私钥:</p><pre class="je jf jg jh fd jr js jt ju aw jv bi"><span id="8d7e" class="jw jx hi js b fi jy jz l ka kb"># openssl req -newkey rsa:2048 -nodes -keyout external_auth_server.key -days 365 -out external_auth_server.crt</span></pre><p id="5268" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们将使用引用上述证书和私钥的密钥创建一个 Kubernetes 秘密:</p><pre class="je jf jg jh fd jr js jt ju aw jv bi"><span id="73a8" class="jw jx hi js b fi jy jz l ka kb"># kubectl create secret tls my-tls-secret \<br/>--cert=external_auth_server.crt \<br/>--key=external_auth_server.key</span><span id="4cc3" class="jw jx hi js b fi kc jz l ka kb"># kubectl describe secret my-tls-secret<br/>Name:         my-tls-secret<br/>Namespace:    default<br/>Labels:       &lt;none&gt;<br/>Annotations:  &lt;none&gt;</span><span id="6fe0" class="jw jx hi js b fi kc jz l ka kb">Type:  kubernetes.io/tls</span><span id="781f" class="jw jx hi js b fi kc jz l ka kb">Data<br/>====<br/>tls.crt:  1029 bytes<br/>tls.key:  1704 bytes</span></pre><p id="7485" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们将在下面引用我们在 YAML 中应用的这个秘密:</p><pre class="je jf jg jh fd jr js jt ju aw jv bi"><span id="9d5a" class="jw jx hi js b fi jy jz l ka kb"># kubectl apply -f <a class="ae jq" href="https://raw.githubusercontent.com/sudhindra-hub/external-auth-demo/master/k8s/external-auth.yaml" rel="noopener ugc nofollow" target="_blank">https://raw.githubusercontent.com/sudhindra-hub/external-auth-demo/master/k8s/external-auth.yaml</a></span><span id="93aa" class="jw jx hi js b fi kc jz l ka kb"># kubectl get pods -l app=my-external-auth<br/>NAME                                READY   STATUS    RESTARTS   AGE<br/>my-external-auth-&lt;pod id&gt;   1/1     Running   1          4h28m</span></pre><p id="edbf" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们将创建一个引用上述外部服务的“extension service”CRD:</p><pre class="je jf jg jh fd jr js jt ju aw jv bi"><span id="fe43" class="jw jx hi js b fi jy jz l ka kb"># kubectl apply -f <a class="ae jq" href="https://raw.githubusercontent.com/sudhindra-hub/external-auth-demo/master/k8s/extension-service.yaml" rel="noopener ugc nofollow" target="_blank">https://raw.githubusercontent.com/sudhindra-hub/external-auth-demo/master/k8s/extension-service.yaml</a></span><span id="84c9" class="jw jx hi js b fi kc jz l ka kb"># kubectl get ExtensionService<br/>NAME AGE<br/>my-external-auth 4h</span></pre><p id="c679" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">CRD 只是一个指向我们外部认证服务的指针。理想情况下，ExtensionService 需要配置有<a class="ae jq" href="https://projectcontour.io/docs/main/config/api/#projectcontour.io/v1.UpstreamValidation" rel="noopener ugc nofollow" target="_blank">https://project contour . io/docs/main/config/API/# project contour . io/v1。UpstreamValidation </a>授权外部 auth 服务。但我没有在这个设置中这样做。不过，强烈建议在生产中启用此功能。</p><p id="ed1d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们现在将为之前在 Contour 中部署的应用程序“kuard”创建一条路线。Contour ingress 只支持虚拟主机配置的 FQDN，因此我们将在我们的 Mac 上创建一个名为“foo.com”的虚拟 FQDN，只需更新<em class="km"> /etc/hosts </em>:</p><pre class="je jf jg jh fd jr js jt ju aw jv bi"><span id="f4bd" class="jw jx hi js b fi jy jz l ka kb"># grep “foo.com” /etc/hosts<br/>127.0.0.1 foo.com</span></pre><p id="9bf1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">接下来，我们将通过创建自签名 CA 证书/私钥来公开 HTTPS (TLS 终止)上的“kuard”应用程序:</p><pre class="je jf jg jh fd jr js jt ju aw jv bi"><span id="207f" class="jw jx hi js b fi jy jz l ka kb">openssl req \ <br/> -newkey rsa:2048 \<br/> -x509 \<br/> -nodes \<br/> -keyout server.key \<br/> -new \<br/> -out server.crt \<br/> -subj /CN=foo.com \<br/> -reqexts SAN \<br/> -extensions SAN \<br/> -config &lt;(cat /System/Library/OpenSSL/openssl.cnf \<br/> &lt;(printf ‘[SAN]\nsubjectAltName=DNS:foo.com’)) \<br/> -sha256 \<br/> -days 3650</span></pre><p id="0a5d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这将创建“server.crt”和“server.key”。我们将参照这些文件创建一个 Kubernetes 秘密:</p><pre class="je jf jg jh fd jr js jt ju aw jv bi"><span id="8c59" class="jw jx hi js b fi jy jz l ka kb"># kubectl create secret tls kuard<br/>--cert=./server.crt \<br/>--key=./server.key</span><span id="807a" class="jw jx hi js b fi kc jz l ka kb">#  kubectl describe secret kuard<br/>Name:         kuard<br/>Namespace:    default<br/>Labels:       &lt;none&gt;<br/>Annotations:  &lt;none&gt;</span><span id="a74c" class="jw jx hi js b fi kc jz l ka kb">Type:  kubernetes.io/tls</span><span id="a99a" class="jw jx hi js b fi kc jz l ka kb">Data<br/>====<br/>tls.crt:  1025 bytes<br/>tls.key:  1704 bytes</span></pre><p id="4df3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们希望启用客户端身份验证(这是我们在外部身份验证服务上了解客户端身份的方式)。创建一个自签名证书和私钥，就像我们之前创建的一样，并创建一个名为“client-kuard”的秘密，它将该证书作为 CA:</p><pre class="je jf jg jh fd jr js jt ju aw jv bi"><span id="19aa" class="jw jx hi js b fi jy jz l ka kb"># cat client_secret.yaml<br/>apiVersion: v1<br/>data:<br/> ca.crt: &lt;base64 encoded PEM contents&gt;<br/>kind: Secret<br/>metadata:<br/> name: client-kuard<br/> namespace: default<br/>type: Opaque</span><span id="285b" class="jw jx hi js b fi kc jz l ka kb"># kubectl apply -f client_secret.yaml</span><span id="5121" class="jw jx hi js b fi kc jz l ka kb"># kubectl describe secret client-kuard<br/>Name: client-kuard<br/>Namespace: default<br/>Labels: &lt;none&gt;<br/>Annotations: &lt;none&gt;</span><span id="a657" class="jw jx hi js b fi kc jz l ka kb">Type: Opaque</span><span id="0d98" class="jw jx hi js b fi kc jz l ka kb">Data<br/>====<br/>ca.crt: 1025 bytes</span></pre><p id="4a4a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们现在准备为来自 FQDN“foo . com”的应用程序“kuard”创建一个路由，同时还指示外部授权:</p><pre class="je jf jg jh fd jr js jt ju aw jv bi"><span id="8709" class="jw jx hi js b fi jy jz l ka kb"># kubectl apply -f <a class="ae jq" href="https://raw.githubusercontent.com/sudhindra-hub/external-auth-demo/master/k8s/httpproxy.yaml" rel="noopener ugc nofollow" target="_blank">https://raw.githubusercontent.com/sudhindra-hub/external-auth-demo/master/k8s/httpproxy.yaml</a></span></pre><p id="15a8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">测试代理是否有效:</p><pre class="je jf jg jh fd jr js jt ju aw jv bi"><span id="2c19" class="jw jx hi js b fi jy jz l ka kb"># kubectl get proxy<br/>NAME    FQDN    TLS SECRET STATUS STATUS DESCRIPTION<br/>my-auth foo.com kuard      valid  Valid  HTTPProxy</span></pre><p id="c4f4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在，我们准备测试我们的外部认证服务器是否工作。如果考察外部 auth server 的逻辑:<a class="ae jq" href="https://github.com/sudhindra-hub/external-auth-demo/blob/master/java/src/main/java/com/example/auth/AuthorizationServiceImpl.java" rel="noopener ugc nofollow" target="_blank">https://github . com/sudhindra-hub/external-auth-demo/blob/master/Java/src/main/Java/com/example/auth/authorizationserviceimpl . Java</a>，很简单的逻辑。它检查客户端证书中是否有包含关键字“client1”的“Subject ”;如果是，它批准(HTTP 状态 200)该请求。否则，对于未授权的访问，它返回 401。</p><p id="6c4c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">请记住，在前面，我们创建了一个自签名证书/私钥，并且我们创建了一个称为“client-kuard”的秘密来引用这个证书。使用这个自签名证书/私钥，让我们创建一个 CSR(证书签名请求),如下所示:</p><pre class="je jf jg jh fd jr js jt ju aw jv bi"><span id="0af9" class="jw jx hi js b fi jy jz l ka kb"># openssl genrsa -out MyClient1.key 2048</span><span id="c480" class="jw jx hi js b fi kc jz l ka kb"># openssl req -new -key MyClient1.key -out MyClient1.csr</span><span id="0680" class="jw jx hi js b fi kc jz l ka kb"># openssl x509 -req -in MyClient1.csr -CA client.crt -CAkey client.key -CAcreateserial -out MyClient1.pem -days 1024 -sha256</span></pre><p id="2178" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">对于上面的 CSR，我将 subject 设置为包含“client1”:</p><pre class="je jf jg jh fd jr js jt ju aw jv bi"><span id="0efb" class="jw jx hi js b fi jy jz l ka kb"># openssl req -text -noout -verify -in MyClient1.csr | grep Subject<br/>verify OK<br/> Subject: C = US, ST = CA, L = San Jose, O = MyOrg, OU = MyUnit, CN = client1<br/> Subject Public Key Info:</span></pre><p id="b563" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们将创建另一个客户端证书，该证书由与上述相同的 CA 颁发，但其主题中不包含“client1”。</p><pre class="je jf jg jh fd jr js jt ju aw jv bi"><span id="ea80" class="jw jx hi js b fi jy jz l ka kb"># openssl req -text -noout -verify -in MyClient2.csr | grep Subject<br/>verify OK<br/> Subject: C = US, ST = CA, L = San Jose, O = MyOrg, OU = MyUnit, CN = client2<br/> Subject Public Key Info:</span></pre><p id="dd11" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们现在将获取服务器 CA 证书:</p><pre class="je jf jg jh fd jr js jt ju aw jv bi"><span id="7cd7" class="jw jx hi js b fi jy jz l ka kb"># echo quit | openssl s_client -showcerts -servername foo.com -connect foo.com:443 &gt; cacert.pem</span></pre><p id="9cbd" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在为客户机 1 发出 CURL 命令:</p><pre class="je jf jg jh fd jr js jt ju aw jv bi"><span id="fe71" class="jw jx hi js b fi jy jz l ka kb"># curl --cacert cacert.pem --cert MyClient1.pem --key MyClient1.key <a class="ae jq" href="https://foo.com" rel="noopener ugc nofollow" target="_blank">https://foo.com</a><br/>&lt;!doctype html&gt;</span><span id="11c0" class="jw jx hi js b fi kc jz l ka kb">&lt;html lang=”en”&gt;<br/>&lt;head&gt;<br/> &lt;meta charset=”utf-8"&gt;</span><span id="eea7" class="jw jx hi js b fi kc jz l ka kb">&lt;title&gt;KUAR Demo&lt;/title&gt;</span><span id="5e66" class="jw jx hi js b fi kc jz l ka kb">...</span></pre><p id="0921" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这成功了！如果您检查上面的头，我们的外部 auth 服务器除了批准请求之外，还附加了一个额外的头“Foo: bar”发送给应用程序。应用程序可以使用这些类型的头来实施 RBAC。</p><p id="0e96" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在让我们用客户端 2 进行测试:</p><pre class="je jf jg jh fd jr js jt ju aw jv bi"><span id="9be8" class="jw jx hi js b fi jy jz l ka kb"># curl -v --cacert cacert.pem --cert MyClient2.pem --key MyClient2.key <a class="ae jq" href="https://foo.com" rel="noopener ugc nofollow" target="_blank">https://foo.com</a></span><span id="698a" class="jw jx hi js b fi kc jz l ka kb">...<br/>* Using Stream ID: 1 (easy handle 0x7f9fd600f600)<br/>&gt; GET / HTTP/2<br/>&gt; Host: foo.com<br/>&gt; User-Agent: curl/7.64.1<br/>&gt; Accept: */*<br/>&gt;<br/>* Connection state changed (MAX_CONCURRENT_STREAMS == 2147483647)!<br/>&lt; HTTP/2 401<br/>&lt; date: Thu, 27 May 2021 21:49:09 GMT<br/>&lt; server: envoy<br/>&lt;<br/>* Connection #0 to host foo.com left intact<br/>* Closing connection 0</span></pre><p id="eaaa" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这也是意料之中的。您还可以检查外部身份验证服务器窗格的日志来检查请求。</p><p id="3b6c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果您想使用浏览器发出请求，而不是上面的 curl，您需要将客户端证书/密钥作为“pfx”文件导入:</p><pre class="je jf jg jh fd jr js jt ju aw jv bi"><span id="dfac" class="jw jx hi js b fi jy jz l ka kb"># openssl pkcs12 -inkey MyClient1.key -in MyClient1.pem -export -out cert_pfx.pfx</span></pre><p id="f79a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">按照这些步骤导入:<a class="ae jq" href="https://www.digicert.com/kb/ssl-support/p12-import-export-mac-server.htm" rel="noopener ugc nofollow" target="_blank">https://www . digicert . com/kb/SSL-support/p12-import-export-MAC-server . htm</a>。我们可以忽略服务器证书进行测试:</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es kn"><img src="../Images/4f2725a0f999c4aba4d3284c32e34d0f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*31dUHZRUobdZjUi1PUipsg.png"/></div></div></figure></div></div>    
</body>
</html>