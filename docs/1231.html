<html>
<head>
<title>Builder and Composite design patterns C#</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">构建器和复合设计模式C#</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/builder-and-composite-design-patterns-c-1cd1425a5f89?source=collection_archive---------5-----------------------#2021-03-10">https://medium.com/nerd-for-tech/builder-and-composite-design-patterns-c-1cd1425a5f89?source=collection_archive---------5-----------------------#2021-03-10</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/7f2fae616fb72ebec5b1a6d47471edcd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2C2Sl-GlJV7ki9eTv59Sgw.jpeg"/></div></div></figure><p id="416b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">复合设计模式是一种常见的结构设计模式，它将对象组成一个树形结构，并提供一个接口来处理它们，就像它们是单独的对象一样。这种模式创建了一个树形结构，其中的对象继承自同一个基础，并在结构上提供了一个很好的抽象。</p></div><div class="ab cl jo jp gp jq" role="separator"><span class="jr bw bk js jt ju"/><span class="jr bw bk js jt ju"/><span class="jr bw bk js jt"/></div><div class="hb hc hd he hf"><p id="6a2f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">在下列情况下应用此设计模式:</strong></p><ul class=""><li id="604c" class="jv jw hi is b it iu ix iy jb jx jf jy jj jz jn ka kb kc kd bi translated">在层次结构的顶部需要通用函数</li><li id="f4d6" class="jv jw hi is b it ke ix kf jb kg jf kh jj ki jn ka kb kc kd bi translated">要求统一处理复杂和个别的对象</li></ul><p id="5b6f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">用途:</strong></p><ul class=""><li id="189b" class="jv jw hi is b it iu ix iy jb jx jf jy jj jz jn ka kb kc kd bi translated">在不破坏代码的情况下向结构中添加新元素保留了开闭原则</li></ul></div><div class="ab cl jo jp gp jq" role="separator"><span class="jr bw bk js jt ju"/><span class="jr bw bk js jt ju"/><span class="jr bw bk js jt"/></div><div class="hb hc hd he hf"><p id="e49d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">真实单词示例:</strong></p><p id="5db3" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这种模式的常见用例是目录/文件夹结构、HTML标签。JSON结构、YAML结构和XML。的。net XElement类是使用复合模式实现的。</p><figure class="kk kl km kn fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es kj"><img src="../Images/c29bb923502927933e23f7a998c5d0a7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YgbNhLplEPRiP3EAJxzf9w.png"/></div></div><figcaption class="ko kp et er es kq kr bd b be z dx translated">来自微软官方网站的XContainer文档</figcaption></figure><p id="e3a5" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">XContainer抽象类可以看作是基础，XDocument和XElements都是从它继承的。XDocument和XElement都可以被认为是复合的。你可以从<a class="ae ks" href="https://docs.microsoft.com/en-us/dotnet/api/system.xml.linq.xnode?view=net-5.0" rel="noopener ugc nofollow" target="_blank">官方网站</a>了解更多信息</p></div><div class="ab cl jo jp gp jq" role="separator"><span class="jr bw bk js jt ju"/><span class="jr bw bk js jt ju"/><span class="jr bw bk js jt"/></div><div class="hb hc hd he hf"><p id="d89e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">示例:</strong></p><p id="6d91" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在本例中，出于演示目的，实现了XElement的一个简化版本。</p><p id="0258" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">类图:</strong></p><figure class="kk kl km kn fd ij er es paragraph-image"><div class="er es kt"><img src="../Images/4f49ec6810301dd34c7e1e9794b9c446.png" data-original-src="https://miro.medium.com/v2/resize:fit:1298/format:webp/1*MUCe-u8QeUjTTbpI5qYyyA.png"/></div><figcaption class="ko kp et er es kq kr bd b be z dx translated">复合设计</figcaption></figure><p id="a2ba" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj"><em class="ku">pixel element . cs</em></strong></p><p id="5923" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这是一个复合接口，它描述了XML文档和XML元素的常见方法，如<code class="du kv kw kx ky b">Add()</code>和<code class="du kv kw kx ky b">Remove() </code>。</p><pre class="kk kl km kn fd kz ky la lb aw lc bi"><span id="6aad" class="ld le hi ky b fi lf lg l lh li">using System;<br/>using System.Collections.Generic;<br/>using System.Text;</span><span id="7317" class="ld le hi ky b fi lj lg l lh li">namespace Composite<br/>{<br/>    public interface IXElement<br/>    {<br/>        string XName { get; }<br/>        void Add(IXElement element);<br/>        void Remove(IXElement element);<br/>        List&lt;IXElement&gt; Elements();</span><span id="ae70" class="ld le hi ky b fi lj lg l lh li">    }<br/>}</span></pre><p id="25cb" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj"> <em class="ku"> XDocument.cs </em> </strong></p><p id="6269" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">XML文档的实现，这有一个额外的属性来保存注释。这个类有两个构造函数，一个带有注释，另一个带有注释和参数列表，支持在创建时传递XML元素列表。</p><pre class="kk kl km kn fd kz ky la lb aw lc bi"><span id="90b9" class="ld le hi ky b fi lf lg l lh li">using System;<br/>using System.Collections.Generic;<br/>using System.Text;</span><span id="d0cf" class="ld le hi ky b fi lj lg l lh li">namespace Composite<br/>{<br/>    public class XDocument : IXElement<br/>    {<br/>        private readonly List&lt;IXElement&gt; children;</span><span id="44ea" class="ld le hi ky b fi lj lg l lh li">        public string XName { get; }<br/>        public string Comment { get;  }<br/>        public XDocument(string _comment, params IXElement[] items)<br/>        {   </span><span id="a06b" class="ld le hi ky b fi lj lg l lh li">            children = new List&lt;IXElement&gt;();<br/>            Comment = _comment;<br/>            foreach (var _item in items) {<br/>                children.Add(_item);<br/>            }<br/>        }<br/>        public XDocument(string _comment)<br/>        {<br/>            children = new List&lt;IXElement&gt;();<br/>            Comment = _comment;<br/>        }<br/>        public void Add(IXElement element)<br/>        {<br/>            children.Add(element);<br/>        }<br/>        public void Remove(IXElement element)<br/>        {<br/>            children.Remove(element);<br/>        }<br/>        public override string ToString()<br/>        {<br/>            var document = new StringBuilder().Append($"&lt; !--{Comment}--&gt;");<br/>            document.Append("&lt;Root&gt;");<br/>            foreach (var item in children) {<br/>                document.Append(item.ToString());<br/>            }<br/>            document.Append(@"&lt;\Root&gt;");<br/>            return document.ToString();<br/>        }<br/>        public List&lt;IXElement&gt; Elements()<br/>        {<br/>            return children;<br/>        }<br/>    }<br/>}</span></pre><p id="c240" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj"> <em class="ku"> XElement.cs </em> </strong></p><p id="cf98" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这是XML元素的实现。这个类有三个构造函数，它们是名称、值和元素参数列表的组合。这为调用者提供了创建带有或不带有内部元素的XML元素的灵活性。</p><pre class="kk kl km kn fd kz ky la lb aw lc bi"><span id="ecb5" class="ld le hi ky b fi lf lg l lh li">using System;<br/>using System.Collections.Generic;<br/>using System.Text;</span><span id="d565" class="ld le hi ky b fi lj lg l lh li">namespace Composite<br/>{<br/>    public class XElement : IXElement<br/>    {<br/>        public string XValue { get; }</span><span id="6a3e" class="ld le hi ky b fi lj lg l lh li">        private readonly List&lt;IXElement&gt; children;</span><span id="c1d0" class="ld le hi ky b fi lj lg l lh li">        public string XName { get; }</span><span id="992d" class="ld le hi ky b fi lj lg l lh li">        public XElement(string name)<br/>        {<br/>            XName = name;<br/>            children = new List&lt;IXElement&gt;();</span><span id="d57f" class="ld le hi ky b fi lj lg l lh li">        }<br/>        public XElement(string name, string value)<br/>        {<br/>            XName = name;<br/>            XValue = value;<br/>            children = new List&lt;IXElement&gt;();</span><span id="60fc" class="ld le hi ky b fi lj lg l lh li">        }<br/>        public XElement(string name, params IXElement[] items)<br/>        {<br/>            children = new List&lt;IXElement&gt;();<br/>            XName = name;<br/>            foreach (var _item in items)<br/>            {<br/>                children.Add(_item);<br/>            }<br/>        }<br/>        public void Add(IXElement element)<br/>        {<br/>            children.Add(element);<br/>        }<br/>        public void Remove(IXElement element)<br/>        {<br/>            children.Remove(element);<br/>        }<br/>        public override string ToString()<br/>        {<br/>            var document = new StringBuilder();<br/>            document.Append($"&lt;{XName}&gt;");<br/>            if (children.Count &gt; 0)<br/>            {<br/>                foreach (var item in children)<br/>                {<br/>                    document.Append(item.ToString());<br/>                }<br/>            }<br/>            else {<br/>                if(XValue != null)<br/>                document.Append(XValue.ToString());<br/>            }<br/>            document.Append(@"&lt;\"+XName+"&gt;");<br/>            return document.ToString();<br/>        }<br/>        public List&lt;IXElement&gt; Elements()<br/>        {<br/>            return children;<br/>        }<br/>    }<br/>}</span></pre><p id="534f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj"> <em class="ku"> main.cs </em> </strong></p><p id="f2b1" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在main方法中，通过将XML元素的注释和列表传递给构造函数来创建XML文档。观察在构造函数中传递元素层次结构的能力。</p><pre class="kk kl km kn fd kz ky la lb aw lc bi"><span id="6550" class="ld le hi ky b fi lf lg l lh li">using Composite;<br/>using System;</span><span id="c8b8" class="ld le hi ky b fi lj lg l lh li">namespace Main<br/>{<br/>    class Program<br/>    {<br/>        static void Main(string[] args)<br/>        {<br/>            XDocument document = new XDocument("This is the root element", <br/>                new XElement("child1", <br/>                    new XElement("child1.1", <br/>                        new XElement("child1.1.1", "1.1.1"))),<br/>                new XElement("child2", "2"),<br/>                new XElement("child3", "3"),<br/>                new XElement("child4", "4"));<br/>            var element5 = new XElement("child4", "5");<br/>            document.Add(element5);<br/>            Console.WriteLine(document);<br/>            document.Remove(element5);<br/>            Console.WriteLine(document);<br/>        }<br/>    }<br/>}</span></pre><p id="b834" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">与其他模式的关系:</strong></p><p id="e005" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在现实世界中，模式不是单独存在的，而是编织在一起为复杂的设计问题提供解决方案。</p><ul class=""><li id="5a6f" class="jv jw hi is b it iu ix iy jb jx jf jy jj jz jn ka kb kc kd bi translated"><strong class="is hj"> <em class="ku">生成器</em> </strong>:可以在创建复杂的树形结构时使用</li><li id="5c4b" class="jv jw hi is b it ke ix kf jb kg jf kh jj ki jn ka kb kc kd bi translated"><strong class="is hj"> <em class="ku">迭代器</em> </strong>:遍历复杂结构</li><li id="7fbc" class="jv jw hi is b it ke ix kf jb kg jf kh jj ki jn ka kb kc kd bi translated"><strong class="is hj"> <em class="ku"> Flyweight </em> </strong>:创建对象时节省内存资源</li></ul><p id="d4ca" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">上面的例子扩展了一个构建器来演示模式是如何协同工作的。上面的XML构造看起来有点混乱，所以添加了一个流畅的构建器来简化XML创建过程。</p><p id="45eb" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">之前关于<a class="ae ks" href="https://sukithaj.medium.com/builder-design-pattern-fluent-interface-c-70cae9490a91" rel="noopener">构建器模式</a>的文章。</p><p id="f2cd" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">带生成器的类图</strong></p><figure class="kk kl km kn fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lk"><img src="../Images/916c1f68e1967560b3549b7c6c439ae0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BYtRxxnaQq3XrklAzQK85w.png"/></div></div><figcaption class="ko kp et er es kq kr bd b be z dx translated">带有生成器的类图</figcaption></figure><p id="7a18" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj"><em class="ku">ixmlbuilder . cs</em></strong></p><p id="3c74" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">该接口提供了添加元素和重置结构的方法。</p><pre class="kk kl km kn fd kz ky la lb aw lc bi"><span id="af9c" class="ld le hi ky b fi lf lg l lh li">namespace Builder<br/>{<br/>    public interface IXMLBuilder<br/>    {<br/>        public XDocument Root { get; }<br/>        IXMLBuilder AddElement(string name, string value);<br/>        IXMLBuilder AddElement(string name);<br/>        IXMLBuilder MoveTo(string name);<br/>        IXMLBuilder Reset();</span><span id="6837" class="ld le hi ky b fi lj lg l lh li">    }<br/>}</span></pre><p id="f152" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj"><em class="ku">XML builder . cs</em></strong></p><p id="39e5" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">实现的建设者接口，其中有根文件和简单的逻辑添加元素。</p><pre class="kk kl km kn fd kz ky la lb aw lc bi"><span id="d273" class="ld le hi ky b fi lf lg l lh li">using Composite;<br/>using System;<br/>using System.Collections.Generic;<br/>using System.Linq;<br/>using System.Text;</span><span id="a3ed" class="ld le hi ky b fi lj lg l lh li">namespace Builder<br/>{<br/>    public class XMLBuilder : IXMLBuilder<br/>    {<br/>        public XDocument Root { get; }<br/>        internal IXElement Current { get; set; }<br/>        public XMLBuilder(string comment) {<br/>            Root = new XDocument(comment);<br/>            Current = Root;<br/>        }<br/>        public IXMLBuilder AddElement( string name, string value)<br/>        {<br/>            Current.Add(new XElement(name, value));<br/>            return this;<br/>        }<br/>        public IXMLBuilder MoveTo(string name)<br/>        {<br/>            List&lt;IXElement&gt; filtered = Current.Elements().Where(x =&gt; x.XName == name).ToList();<br/>            Current = filtered.Count &gt; 0 ? filtered[0] : Root;<br/>            return this;<br/>        }<br/>        public IXMLBuilder Reset()<br/>        {<br/>            Current = Root;<br/>            return this;<br/>        }<br/>        public IXMLBuilder AddElement(string name)<br/>        {<br/>            var temp = new XElement(name);<br/>            Current.Add(temp);<br/>            Current = temp;<br/>            return this;<br/>        }<br/>    }<br/>}</span></pre><p id="82c4" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj"> <em class="ku"> main.cs </em> </strong></p><p id="1616" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">使用构建器界面构建XML树的一种更简单的方法。</p><pre class="kk kl km kn fd kz ky la lb aw lc bi"><span id="0e58" class="ld le hi ky b fi lf lg l lh li">using Builder;<br/>using Composite;<br/>using System;</span><span id="9068" class="ld le hi ky b fi lj lg l lh li">namespace Main<br/>{<br/>    class Program<br/>    {<br/>        static void Main(string[] args)<br/>        {</span><span id="8509" class="ld le hi ky b fi lj lg l lh li">                XDocument xdocument = new XMLBuilder("This is the root element")<br/>                .AddElement("child1")<br/>                .AddElement("child1.1")<br/>                .AddElement("child1.1.1", "1.1.1")<br/>                .Reset()<br/>                .AddElement("child2", "2")<br/>                .AddElement("child2", "3")<br/>                .AddElement("child2", "4")<br/>                .AddElement("child2", "5")<br/>                .Root;</span><span id="c510" class="ld le hi ky b fi lj lg l lh li">                 Console.WriteLine(xdocument);<br/>        }<br/>    }<br/>}</span></pre><p id="57d4" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">讨论:</p><p id="6df3" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">一些人认为，原始模式违反了<a class="ae ks" href="https://en.wikipedia.org/wiki/Liskov_substitution_principle" rel="noopener ugc nofollow" target="_blank"> <strong class="is hj"> <em class="ku"> Liskov替代原则</em> </strong> </a>和<a class="ae ks" href="https://en.wikipedia.org/wiki/Interface_segregation_principle" rel="noopener ugc nofollow" target="_blank"> <strong class="is hj"> <em class="ku">接口分离原则</em> </strong> </a>通过强制叶节点实现无意义的方法如<code class="du kv kw kx ky b">Add()</code>或<code class="du kv kw kx ky b">Remove()</code>。然而，本文提供的示例符合ISP和LSP，因为<code class="du kv kw kx ky b">XElement</code>和<code class="du kv kw kx ky b">XDocument</code>已经实现了所有的抽象方法。</p></div><div class="ab cl jo jp gp jq" role="separator"><span class="jr bw bk js jt ju"/><span class="jr bw bk js jt ju"/><span class="jr bw bk js jt"/></div><div class="hb hc hd he hf"><p id="9b64" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">谢谢你，<a class="ll lm ge" href="https://medium.com/u/36cefa51daac?source=post_page-----1cd1425a5f89--------------------------------" rel="noopener" target="_blank">德斯蒙德·哈里斯·费尔南多</a>和<a class="ll lm ge" href="https://medium.com/u/702c7758a2a3?source=post_page-----1cd1425a5f89--------------------------------" rel="noopener" target="_blank">迪努莎·坎南加拉</a>审阅代码。</p><p id="793b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">源代码可在<a class="ae ks" href="https://github.com/sukitha/CompositePattern.git" rel="noopener ugc nofollow" target="_blank"> git </a>中获得，</p></div></div>    
</body>
</html>