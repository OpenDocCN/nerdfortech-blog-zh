<html>
<head>
<title>Working with OneDev Cache</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用OneDev缓存</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/working-with-onedev-cache-5d84cefc9a3?source=collection_archive---------2-----------------------#2022-01-21">https://medium.com/nerd-for-tech/working-with-onedev-cache-5d84cefc9a3?source=collection_archive---------2-----------------------#2022-01-21</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/565dba7d17c332c6d34d6e576b5b5563.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2vVbUTSdPQr6kt5oR6O3vA.jpeg"/></div></div></figure><p id="8272" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在容器中运行的CI/CD作业总是从干净的环境开始，并且可能会很慢，因为它不能重用在作业的上一次运行中下载/生成的文件。为了解决这个问题，OneDev提供了缓存指定容器目录的能力，使它们能够在不同的作业运行中存活。</p><h1 id="0023" class="jo jp hi bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">定义作业缓存</h1><p id="88d0" class="pw-post-body-paragraph iq ir hi is b it km iv iw ix kn iz ja jb ko jd je jf kp jh ji jj kq jl jm jn hb bi translated">可以在作业的<em class="kr">更多设置</em>中定义缓存，如下图:</p><figure class="kt ku kv kw fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ks"><img src="../Images/c2ce31274ebccffcb0bd8d69ddfc540f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UnmCcOaYHWeKnihTxYBNCA.png"/></div></div></figure><p id="ea7b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这里缓存键标识一个缓存。具有相同键的缓存可以跨不同的项目或作业重用，即使路径不同，而具有不同键的缓存即使路径相同也不会被重用。</p><h1 id="8454" class="jo jp hi bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">它是如何工作的</h1><p id="bcc0" class="pw-post-body-paragraph iq ir hi is b it km iv iw ix kn iz ja jb ko jd je jf kp jh ji jj kq jl jm jn hb bi translated">缓存位于运行作业的节点的本地。如果一个作业在节点1上运行以填充缓存，如果后续运行发生在节点2上，它将不会受益于该缓存，除非节点2上的缓存也被填充。在幕后，OneDev分配一个由缓存键标识的主机目录，并将其作为缓存路径挂载到容器中，这样在作业容器被销毁后，它就不会被销毁。</p><p id="0605" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">此外，如果有多个作业在同一节点上并发运行，声明相同的缓存键，OneDev将在该键下分配多个主机目录，以确保单个缓存目录在同一时间仅由单个作业使用，从而避免争用情况。由于这会消耗大量磁盘空间，作业执行器中定义的缓存TTL会告诉OneDev何时清理未使用的缓存目录:</p><figure class="kt ku kv kw fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ks"><img src="../Images/2866e2ff6919bde6c904f0d3e0cc8084.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*eTSVnY9HVRbOPx_Fwrx1Qw.png"/></div></div></figure><p id="31d8" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">默认情况下，OneDev会自动发现作业执行器，默认缓存TTL是一周。创建适当的作业执行器，并在必要时覆盖缓存TTL。</p><h1 id="f66b" class="jo jp hi bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">示例设置</h1><p id="88af" class="pw-post-body-paragraph iq ir hi is b it km iv iw ix kn iz ja jb ko jd je jf kp jh ji jj kq jl jm jn hb bi translated">让我们在本节中检查一些示例设置。</p><p id="5412" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">1.缓存Java项目的maven本地存储库</p><p id="29b5" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">一个典型的Java maven项目可能会下载很多依赖项，这可能会花费很多时间。缓存保存下载依赖项的maven本地存储库至关重要。在容器中运行时，maven本地存储库通常放在<em class="kr"> /root/.m2/repository </em>中，因此我们可以添加一个缓存条目，如下所示:</p><figure class="kt ku kv kw fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ks"><img src="../Images/eac9e411f2a9632dc8c89684fba6424a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Zjf0x0Ug7HyyYZ0gKfThlQ.png"/></div></div></figure><p id="5fdb" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">所有Maven项目的缓存键应该是相同的，因为我们希望尽可能多地重用缓存</p><p id="a564" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">2.缓存JavaScript项目的npm包</p><p id="c8dc" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">一个典型的JavaScript项目也会下载许多npm包，通常保存在项目根目录下的目录<em class="kr"> node_modules </em>中。我们可以缓存这个目录来加速<em class="kr"> npm安装</em>，如下所示:</p><figure class="kt ku kv kw fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ks"><img src="../Images/086770655874ee89bc25ecd619f738ae.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*h5OIiIQ2-DsCFFedKsmz4Q.png"/></div></div></figure><p id="c8e3" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在这个例子中，我们将项目路径嵌入到缓存键中，使它只能在同一个项目中重用。这是因为不同的项目可能有非常不同的依赖关系。虽然<em class="kr"> npm安装</em>将重新同步已挂载的<em class="kr"> node_modules </em>以确保它们与当前的<em class="kr"> package-lock.json </em>一致，但是如果缓存先前被不同的项目使用，缓存中的太多文件可能需要更改，这可能会使<em class="kr"> npm安装</em>运行缓慢。</p><p id="6e2b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">请注意，如果作业在Kubernetes集群中运行，缓存<em class="kr"> node_modules </em>将导致构建失败，因为相对路径缓存是通过符号链接设置的，许多npm包对此处理得不好。在这种情况下，建议缓存<em class="kr"> /root/。取而代之的是npm </em>，缓存键不应该包含项目路径，因为全局npm缓存是以累积的方式工作的。</p></div></div>    
</body>
</html>