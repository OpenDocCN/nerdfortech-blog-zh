<html>
<head>
<title>Introduction to Message Brokers</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">消息代理简介</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/introduction-to-message-brokers-bb5cacf9c70b?source=collection_archive---------6-----------------------#2021-05-15">https://medium.com/nerd-for-tech/introduction-to-message-brokers-bb5cacf9c70b?source=collection_archive---------6-----------------------#2021-05-15</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/3d55b55121642793b2486e9795639558.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*1skJSHCCBVmekG3B"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">克里斯蒂娜·特里普科维奇在<a class="ae iu" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><p id="5335" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">消息代理是使服务能够相互通信和交换信息的程序。如果你已经了解了 API，你可能会认为消息代理和 API 是一样的。但事实并非如此，消息代理通常通过实现不同服务可以读写的队列来做到这一点。因此，这将允许这些服务彼此异步通信，即使它们是用不同的语言编写的或在不同的平台上实现的。</p><p id="bd62" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">因此，这些消息代理充当应用程序之间的桥梁，允许发送方发布消息，而不知道接收方在哪里或有多少接收方。</p><h1 id="a8b3" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">消息代理的用例</h1><p id="e33c" class="pw-post-body-paragraph iv iw hi ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated">正如您已经猜到的，消息代理在软件开发中被广泛使用。每当需要可靠的多服务通信、安全消息传递或异步特性时，它们都很有用。现在，我将向您展示消息代理的几个用例。</p><ul class=""><li id="df13" class="kw kx hi ix b iy iz jc jd jg ky jk kz jo la js lb lc ld le bi translated">如果你必须开发一个支付处理系统，支付只发送一次是很重要的。使用消息代理处理这些交易可以确保支付信息不会丢失或重复，并提供收据证明。</li><li id="a5d2" class="kw kx hi ix b iy lf jc lg jg lh jk li jo lj js lb lc ld le bi translated">假设有一个任务，它向几个应用程序发送数据，必须避免直接使用它们 API。在这种情况下，消息经纪人可以拯救你的一天。</li><li id="3837" class="kw kx hi ix b iy lf jc lg jg lh jk li jo lj js lb lc ld le bi translated">此外，当您想要控制数据馈送时，消息代理也很方便。例如，任何系统中的注册数量。</li></ul><h1 id="07e3" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">消息代理的基本组件</h1><p id="8f56" class="pw-post-body-paragraph iv iw hi ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated">您需要了解消息代理中的 4 个组件。</p><ul class=""><li id="e271" class="kw kx hi ix b iy iz jc jd jg ky jk kz jo la js lb lc ld le bi translated"><strong class="ix hj">生产者</strong> —这是发送任何类型数据的端点，这些数据存储在消息代理中以供分发。</li><li id="93be" class="kw kx hi ix b iy lf jc lg jg lh jk li jo lj js lb lc ld le bi translated"><strong class="ix hj">消费者</strong> —这是向消息代理请求消息并消费消息的端点。</li><li id="cbe6" class="kw kx hi ix b iy lf jc lg jg lh jk li jo lj js lb lc ld le bi translated"><strong class="ix hj">队列</strong> —这是消息代理用来存储内部消息的数据类型，逻辑为 FIFO(先进先出)。队列存储消息，直到消费服务处理它们。这些队列还允许异步类型的编程，因为队列是负责传递消息的队列，发送方可以继续执行不同的任务。</li><li id="1999" class="kw kx hi ix b iy lf jc lg jg lh jk li jo lj js lb lc ld le bi translated"><strong class="ix hj">交换器</strong> —这是一种逻辑配置，甚至是队列顶部的实体，它告诉消息代理创建某种类型的组，消费者可以监听接收的消息，生产者可以编写发送的消息。</li></ul><h1 id="211f" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">消息代理的类型</h1><p id="0827" class="pw-post-body-paragraph iv iw hi ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated">与消息代理的通信有两种基本形式:</p><ul class=""><li id="cd39" class="kw kx hi ix b iy iz jc jd jg ky jk kz jo la js lb lc ld le bi translated">点对点(队列)</li><li id="e920" class="kw kx hi ix b iy lf jc lg jg lh jk li jo lj js lb lc ld le bi translated">发布和订阅(主题)</li></ul><h2 id="73be" class="lk ju hi bd jv ll lm ln jz lo lp lq kd jg lr ls kh jk lt lu kl jo lv lw kp lx bi translated">点对点(队列)</h2><p id="1928" class="pw-post-body-paragraph iv iw hi ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated">在这种模式中，通信只发生在一个生产者和一个消费者之间。所以基本上，这是消息的生产者和消费者之间的一对一关系。每条消息只发送和使用一次。这种类型的消息传递通常使用一个队列来存储由生产者发送的消息，直到消费者收到它们。例如，当某个动作只需要执行一次时，我们可以使用这种模式。</p><figure class="lz ma mb mc fd ij er es paragraph-image"><div class="er es ly"><img src="../Images/c89aa1e0dd42019db9928da7d4882331.png" data-original-src="https://miro.medium.com/v2/resize:fit:1362/format:webp/1*9oTJiSc1hzNjyZpWfeVfrA.png"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">图片:点对点模式(<a class="ae iu" href="https://codenotfound.com/" rel="noopener ugc nofollow" target="_blank">https://codenotfound.com/</a>)</figcaption></figure><h2 id="ac01" class="lk ju hi bd jv ll lm ln jz lo lp lq kd jg lr ls kh jk lt lu kl jo lv lw kp lx bi translated">发布和订阅(主题)</h2><p id="1f00" class="pw-post-body-paragraph iv iw hi ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated">发布和订阅模式与前面的略有不同。在这种模式中，生产者被称为发布者，消费者被称为订阅者。消息的发布者不知道任何关于订阅者的信息，消息将被发送到主题。因此，一个或多个发布者可以发布相同的主题，并且来自一个或多个发布者的消息可以被多个订阅者接收。我们可以使用这种模式来实现通知机制或分配独立的任务。</p><figure class="lz ma mb mc fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es md"><img src="../Images/f665b3a7f98e8d00ce1f11d35b1fc947.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0Cve20PgnhmcXfavpa3nKA.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">图片:发布订阅模式(【https://codenotfound.com/】T2)</figcaption></figure></div><div class="ab cl me mf gp mg" role="separator"><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj"/></div><div class="hb hc hd he hf"><h1 id="a0e4" class="jt ju hi bd jv jw ml jy jz ka mm kc kd ke mn kg kh ki mo kk kl km mp ko kp kq bi translated">消息代理的例子</h1><p id="e2fa" class="pw-post-body-paragraph iv iw hi ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated">今天有许多消息经纪人，但最受欢迎的是<strong class="ix hj"> RabbitMQ、Apache Kafka 和 Redis </strong>。因此，让我们简单地浏览一下这些消息代理。</p><h2 id="e148" class="lk ju hi bd jv ll lm ln jz lo lp lq kd jg lr ls kh jk lt lu kl jo lv lw kp lx bi translated">阿帕奇卡夫卡</h2><p id="7aba" class="pw-post-body-paragraph iv iw hi ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated">这个消息代理最初是由 LinkedIn 开发的，用于处理高吞吐量和低延迟的处理。这些需要长时间的大量数据，而这正是卡夫卡擅长的。因为它与 Apache Storm 和 Spark 集成，所以在实时流数据分析应用程序中被大量使用。如果你把卡夫卡和其他消息代理人的表现进行比较，卡夫卡通常是第一位的。</p><p id="9427" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">Kafka 支持所有主要语言，包括 Python、Java、C/C++、。NET，PHP，Ruby，JavaScript，Go，Swift 等等。此外，它是大数据使用情形的完美选择，因为它可以用有限的资源实现高吞吐量。</p><blockquote class="mq mr ms"><p id="a6b8" class="iv iw mt ix b iy iz ja jb jc jd je jf mu jh ji jj mv jl jm jn mw jp jq jr js hb bi translated">如果你想知道 Kafka 有多受欢迎，包括网飞、易贝、优步、PayPal 和 Pinterest 在内的所有科技巨头都在使用 Kafka 作为他们的消息代理。</p></blockquote><h2 id="ca2e" class="lk ju hi bd jv ll lm ln jz lo lp lq kd jg lr ls kh jk lt lu kl jo lv lw kp lx bi translated">兔子 q</h2><p id="e58f" class="pw-post-body-paragraph iv iw hi ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated">RabbitMQ 是部署最广泛、最流行的开源消息代理。它最初发布于 2007 年，是最早创建的通用消息代理之一。RabbitMQ 通过实现<strong class="ix hj">高级消息队列协议(AMQP) </strong>通过点对点和发布-订阅方法传递消息。它旨在支持复杂的路由逻辑。</p><p id="4250" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这个消息代理附带了一个名为<strong class="ix hj">“管理插件”</strong>的插件，它帮助用户通过图形用户界面使用它来操作 RabbitMQ，以及查看与消息传递相关的不同统计数据等功能。此外，它还可以对队列中发生的所有操作和数据进行概述。</p><p id="49fb" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">RabbitMQ 还支持所有主流语言，包括 Python、Java、.NET、PHP、Ruby、JavaScript、Go、Swift 等等。</p><h2 id="f939" class="lk ju hi bd jv ll lm ln jz lo lp lq kd jg lr ls kh jk lt lu kl jo lv lw kp lx bi translated">雷迪斯</h2><p id="973e" class="pw-post-body-paragraph iv iw hi ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated">与其他消息代理相比，Redis 有点不同，因为它是内存中的数据结构存储。因此，它既可以用作高性能的键值存储，也可以用作消息代理。但问题是，不能保证消息在那里是持久的。</p><p id="bc42" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">Radis 还有另一个不同之处，它没有持久性，而是将内存放入磁盘或数据库中。但是，对于实时数据处理来说，这是一件好事。本来 Redis 就不是一对一，一对多。但是自从 Redis 5.0 引入以来，它支持一对多选项。</p><p id="026d" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">所以，这是文章的结尾，我希望你喜欢它。快乐编码👨‍💻。</p></div><div class="ab cl me mf gp mg" role="separator"><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj"/></div><div class="hb hc hd he hf"><h2 id="9ff6" class="lk ju hi bd jv ll lm ln jz lo lp lq kd jg lr ls kh jk lt lu kl jo lv lw kp lx bi translated">参考</h2><p id="82dd" class="pw-post-body-paragraph iv iw hi ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated">v .萨莫法尔，2019。<em class="mt">消息代理简介。第一部分:阿帕奇卡夫卡 vs rabbit MQ—DZone 大数据</em>。[在线]dzone.com。可从以下网址获取:&lt;https://dzone . com/articles/introduction-to-message-brokers-part-1-Apache-kafk&gt;【2021 年 5 月 14 日获取】。</p><p id="f4bd" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">于扎克，学士，2021 年。<em class="mt"> Message broker —完整的专业知识、使用案例和分步指南| TSH.io </em>。[在线]软件公司。可在:&lt;https://tsh.io/blog/message-broker/&gt;【2021 年 5 月 15 日获取】。</p></div></div>    
</body>
</html>