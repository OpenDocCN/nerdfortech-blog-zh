<html>
<head>
<title>Adventures in Encryption: Securing Your Laptop Kubernetes Cluster</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">加密冒险:保护您的笔记本电脑 Kubernetes 集群</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/adventures-in-encryption-securing-your-laptop-kubernetes-cluster-9e032bf77f3e?source=collection_archive---------11-----------------------#2021-05-18">https://medium.com/nerd-for-tech/adventures-in-encryption-securing-your-laptop-kubernetes-cluster-9e032bf77f3e?source=collection_archive---------11-----------------------#2021-05-18</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/7f9c9a83f1aba171e993d81b1a7b73bd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Uwa2KEEzS4o9edZXqCjGaQ.jpeg"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">“是秘密吗？安全吗？”</figcaption></figure><p id="64d0" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><em class="js">使用</em> <a class="ae jt" href="https://cert-manager.io/" rel="noopener ugc nofollow" target="_blank"> <em class="js">证书管理器</em> </a>更好的安全性和更好的 web 开发</p><p id="2811" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">前端和后端开发人员越来越多地生活在 API 服务器、云托管和服务的世界中，所有这些都受到 TLS 证书和其他类型加密的保护。然而，许多开发人员工具使用的是普通的老式本地主机，传统上根本没有加密。</p><p id="68f2" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">当您在这些开发环境中使用的 API 和服务受到 SSL 和 TLS 的保护时，这是有局限性的。饼干就不一样了。一些操作失败。您会在本地系统上遇到各种与安全相关的错误，这些错误是在笔记本电脑上工作所特有的。不修复与您的本地设置相关的错误，而不是您试图设计的东西，开发就已经够难了。</p><p id="8c2f" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">因此，趋势是在我们的开发环境中也使用适当的加密。如果您直接在运行于 localhost 上的开发服务器上进行开发，有一些很好的教程可以帮助您进行设置。Daksh Shah 的一篇文章值得一读，因为我们将在本文中使用这种方法:创建和信任我们的自签名证书颁发机构，并为我们的测试服务器创建服务器证书。</p><p id="2e02" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">对于我们这些在 Docker 和 Kubernetes 中开发容器化应用的人来说，我们需要走得更远。这就是这篇文章的内容。</p><h1 id="1015" class="ju jv hi bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">假设和前提条件</h1><p id="23a4" class="pw-post-body-paragraph iu iv hi iw b ix ks iz ja jb kt jd je jf ku jh ji jj kv jl jm jn kw jp jq jr hb bi translated">这应该不是你第一次学习使用证书设置服务器、使用 openssl 之类的工具或者配置 Kubernetes。我假设你至少玩过所有这些东西。</p><p id="e0c6" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">所以:</p><ul class=""><li id="229f" class="kx ky hi iw b ix iy jb jc jf kz jj la jn lb jr lc ld le lf bi translated">你至少知道一点如何使用 Kubernetes 和 docker，并且不会被在你的个人笔记本电脑上安装这些东西所吓倒。</li><li id="417c" class="kx ky hi iw b ix lg jb lh jf li jj lj jn lk jr lc ld le lf bi translated">我将很快地介绍<a class="ae jt" href="https://en.wikipedia.org/wiki/Public_key_infrastructure" rel="noopener ugc nofollow" target="_blank"> PKI </a>和<a class="ae jt" href="https://en.wikipedia.org/wiki/X.509" rel="noopener ugc nofollow" target="_blank"> X.509 </a>，但是希望您能对什么是密钥和什么是证书有所了解。</li><li id="c546" class="kx ky hi iw b ix lg jb lh jf li jj lj jn lk jr lc ld le lf bi translated">你也知道 X.509 不是从未来来拯救你尚未出生的孩子，也不是不会爬楼梯的邪恶机器人。</li></ul><figure class="lm ln lo lp fd ij er es paragraph-image"><div class="er es ll"><img src="../Images/b155d5ced956e4b0d23297e2c211b88d.png" data-original-src="https://miro.medium.com/v2/resize:fit:526/format:webp/1*bjjWAGddTLxw29YUuYWbnQ.jpeg"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">ED-209 不会创建您的证书。你同意吗？</figcaption></figure><ul class=""><li id="b833" class="kx ky hi iw b ix iy jb jc jf kz jj la jn lb jr lc ld le lf bi translated">对于我们的第一部分，我们将创建我们自己的“超级证书”，或如它所称的那样，一个“认证机构”，或“CA”。为什么我们需要自己的个人 CA？因为您使用一个 CA 证书来制作其他证书。正如我们将要看到的。</li></ul><h1 id="b169" class="ju jv hi bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">我的设置和教程所需的软件</h1><p id="52cb" class="pw-post-body-paragraph iu iv hi iw b ix ks iz ja jb kt jd je jf ku jh ji jj kv jl jm jn kw jp jq jr hb bi translated">我在本教程中描述的可以在 Linux、Windows 或我在这里做的 MacOS 上完成。作为参考，我的设置如下:</p><ol class=""><li id="286e" class="kx ky hi iw b ix iy jb jc jf kz jj la jn lb jr lq ld le lf bi translated">MacBook Pro 上的 MacOS Mojave (10.14)</li><li id="9527" class="kx ky hi iw b ix lg jb lh jf li jj lj jn lk jr lq ld le lf bi translated">Mac 版 Docker 桌面，已激活 Kubernetes。你也可以用 minikube 来做这件事，尽管最近我发现 DDFM 的环境更稳定了，也不太可能让我变得不稳定。</li><li id="c2de" class="kx ky hi iw b ix lg jb lh jf li jj lj jn lk jr lq ld le lf bi translated">我已经安装了 Nginx 控制器，它可以让我的容器和 pod 在它们运行的任何端口上运行，但是我的 web 应用程序可以在端口 80 和 443 上使用，就像上帝打算的那样。在本教程中，您需要安装该软件。<a class="ae jt" href="https://kubernetes.github.io/ingress-nginx/deploy/" rel="noopener ugc nofollow" target="_blank">这里是请示</a>的好地方。</li><li id="3888" class="kx ky hi iw b ix lg jb lh jf li jj lj jn lk jr lq ld le lf bi translated">这种设置的真正神奇之处在于使用了名为 c <a class="ae jt" href="https://cert-manager.io/" rel="noopener ugc nofollow" target="_blank"> ert-manager </a>的软件，一旦我们设置好了，它就会自动为我们创建服务器证书。你还应该安装那个。</li><li id="d0be" class="kx ky hi iw b ix lg jb lh jf li jj lj jn lk jr lq ld le lf bi translated">为了有一些我们可以看的内容，你会想要下载我的样本文件。您将在本教程的后面找到安装说明。</li></ol><h1 id="95ff" class="ju jv hi bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">制作 CA</h1><p id="3bd9" class="pw-post-body-paragraph iu iv hi iw b ix ks iz ja jb kt jd je jf ku jh ji jj kv jl jm jn kw jp jq jr hb bi translated">这一节在很大程度上归功于<a class="ae jt" href="https://cert-manager-munnerz.readthedocs.io/en/latest/tasks/issuers/setup-ca.html" rel="noopener ugc nofollow" target="_blank">cert-manager 的赞助公司 JetStack </a>的本教程，在一个关于在其产品中使用自签名证书的章节中。一旦你完成了这个教程，给它一个阅读。</p><p id="0e5f" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">要创建您自己的证书颁发机构，您需要在您的系统上安装 openssl。为了让你开始，我在 GitHub 上有<a class="ae jt" href="https://github.com/torenware/lets-encrypt-files" rel="noopener ugc nofollow" target="_blank">示例文件可以用作模板。</a></p><p id="af34" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">为了使这个过程更容易无误地重复，我们创建了一个配置文件来创建 CA。此配置仅用于创建我们的 CA；我们不会直接签署服务器证书。这将是证书管理器的工作。</p><p id="42f2" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">我们将调用配置文件<code class="du lr ls lt lu b">cert-defaults.csr.cnf</code>，它将填充一些我们想要嵌入到证书中的基本信息。这里有一个例子:当然，您需要更改设置以适合您自己或您的公司:</p><pre class="lm ln lo lp fd lv lu lw lx aw ly bi"><span id="8d38" class="lz jv hi lu b fi ma mb l mc md"><strong class="lu hj">[req]</strong><br/>days                   = 180<br/>serial                 = 1<br/>distinguished_name     = req_distinguished_name<br/>x509_extensions        = v3_ca</span><span id="5390" class="lz jv hi lu b fi me mb l mc md"><strong class="lu hj">[req_distinguished_name]</strong><br/>countryName_default            = US<br/>stateOrProvinceName_default    = CA<br/>localityName_default           = Our Fair City<br/>organizationName_default       = SomeCompany<br/>commonName                     = Common Name<br/>commonName_default             = SomeCompanyCACert<br/>0.emailAddress_default         = moe@somecompany.com<br/>1.emailAddress_default         = curly@somecompany.com<br/>2.emailAddress_default         = larry@somecompany.com</span><span id="56fc" class="lz jv hi lu b fi me mb l mc md"><strong class="lu hj">[ v3_ca ]</strong><br/># The extentions to add to a self-signed cert<br/># @see also https://www.freecodecamp.org/news/how-to-get-https-working-on-your-local-development-environment-in-5-minutes-7af615770eec/<br/>subjectKeyIdentifier   = hash<br/>authorityKeyIdentifier = keyid:always,issuer:always<br/>basicConstraints       = critical,CA:TRUE<br/>keyUsage               = digitalSignature, nonRepudiation, keyEncipherment, dataEncipherment, keyAgreement, keyCertSign<br/>subjectAltName         = @alt_names<br/>issuerAltName          = issuer:copy</span><span id="d277" class="lz jv hi lu b fi me mb l mc md"><strong class="lu hj">[alt_names]</strong><br/>DNS.1 = localhost</span></pre><p id="22f8" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">现在我们有了配置文件，让我们创建我们的 CA 证书:</p><pre class="lm ln lo lp fd lv lu lw lx aw ly bi"><span id="c97d" class="lz jv hi lu b fi ma mb l mc md">openssl req -x509 -days 1024 -newkey rsa:4096 \<br/>    -extensions v3_ca \<br/>    -config ca-self-signed.cnf \<br/>    -keyout our-ca.key \<br/>    -out our-ca.crt</span></pre><p id="efe5" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">这将生成我们的密钥并创建自签名证书文件，该文件现在存储在我们的-ca.crt 中。因为这是一个 ca，所以保证密钥的安全是非常重要的。该命令要求我们输入一个密码，该密码应该很长并且很难猜到。我将我的存储在 1Password 中；你应该用你最喜欢的密码工具做类似的事情。当我们将密钥导入到 Kubernetes 时，您将需要它。</p><pre class="lm ln lo lp fd lv lu lw lx aw ly bi"><span id="08b6" class="lz jv hi lu b fi ma mb l mc md">Generating a 4096 bit RSA private key<br/>.......................................++<br/>...........................++<br/>writing new private key to 'our-ca.key'<br/>Enter PEM pass phrase:</span></pre><p id="fcad" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">接下来，您需要告诉您的计算机信任您刚刚创建的 CA 证书。对于 Mac 和 Windows，以及您想要使用的浏览器，该过程是不同的。以下是一些适用于 Mac 和 Windows 以及 Chrome 和 Firefox 的参考资料。</p><ul class=""><li id="3d54" class="kx ky hi iw b ix iy jb jc jf kz jj la jn lb jr lc ld le lf bi translated"><a class="ae jt" href="https://javorszky.co.uk/2019/11/06/get-firefox-to-trust-your-self-signed-certificates/" rel="noopener ugc nofollow" target="_blank">将证书导入 Firefox </a></li><li id="b67a" class="kx ky hi iw b ix lg jb lh jf li jj lj jn lk jr lc ld le lf bi translated"><a class="ae jt" href="https://www.pico.net/kb/how-do-you-get-chrome-to-accept-a-self-signed-certificate" rel="noopener ugc nofollow" target="_blank">将证书导入 Windows 上的 Chrome</a></li><li id="1f96" class="kx ky hi iw b ix lg jb lh jf li jj lj jn lk jr lc ld le lf bi translated"><a class="ae jt" href="https://www.techrepublic.com/article/how-to-add-a-trusted-certificate-authority-certificate-to-chrome-and-firefox/" rel="noopener ugc nofollow" target="_blank">将证书导入 Windows 和 MacOS 上的 Firefox 和 Chrome 技术版本</a></li></ul><h1 id="6e79" class="ju jv hi bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">配置 Kubernetes 和 Nginx</h1><p id="fc45" class="pw-post-body-paragraph iu iv hi iw b ix ks iz ja jb kt jd je jf ku jh ji jj kv jl jm jn kw jp jq jr hb bi translated">现在，您已经在笔记本电脑上设置了自签名 CA。创建自己的证书并不困难，如果你只是建立一个网络服务器，这就是你需要做的。Daksh Shah 的文章是你的答案。但是为了保护 minikube 或 Docker 桌面上的 Kubernetes 集群，您需要配置 Kubernetes 来使用您的 CA。</p><p id="2e30" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">要检查我们的进度，请设置您的系统，以便它可以与应用程序/目录中的<a class="ae jt" href="https://github.com/torenware/lets-encrypt-files/tree/master/app" rel="noopener ugc nofollow" target="_blank"> my Github 模板文件一起工作。这些文件将为名为“dev.somecompany.com”的域创建一个非常简单的部署以及入口定义。因此入口定义将起作用，在/etc/hosts 文件中创建一行，如下所示:</a></p><pre class="lm ln lo lp fd lv lu lw lx aw ly bi"><span id="1018" class="lz jv hi lu b fi ma mb l mc md">127.0.0.1 dev.somecompany.com</span></pre><p id="d2a0" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">(注意:如果你使用的是 minikube 而不是 Docker Desktop，你应该用<code class="du lr ls lt lu b">minikube ip </code>获得你的 kube 的 IP 地址，并使用该 IP 地址而不是 127.0.01)</p><p id="ede9" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">设置/etc/hosts 后，按照指示应用文件:</p><pre class="lm ln lo lp fd lv lu lw lx aw ly bi"><span id="5d42" class="lz jv hi lu b fi ma mb l mc md">cd app<br/>kubectl apply -f .</span></pre><p id="9763" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">我们现在准备开始构建 Kubernetes 对象，这将使事情进展顺利。在这里，顺序很重要:</p><ol class=""><li id="7faf" class="kx ky hi iw b ix iy jb jc jf kz jj la jn lb jr lq ld le lf bi translated">将 ca 证书数据作为 tls 机密加载到 k8s 中。注意，我正在解密 CA 的秘密密钥，将它加载到 k8s，并在完成后立即删除解密的密钥:</li></ol><pre class="lm ln lo lp fd lv lu lw lx aw ly bi"><span id="08b5" class="lz jv hi lu b fi ma mb l mc md">openssl rsa -in ../cacert/our-ca.key -out temp-decrypted.key<br/><br/>kubectl create secret tls loaded-ca-key-pair \<br/>   --cert=../cacert/our-ca.crt \<br/>   --key=temp-decrypted.key \<br/>   --namespace=default<br/><br/>rm temp-decrypted.key</span></pre><p id="7a56" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">2.现在创建 cert-manager 所谓的“发行者”。这是我们希望 cert-manager 如何为我们创建证书的定义，提供 CM 需要的信息。注意，在这种情况下，发行者只是指向我们刚刚在<code class="du lr ls lt lu b">loaded-ca-key-pair</code>中上传的 CA 数据。我们将把它命名为<code class="du lr ls lt lu b">issuer.yaml</code></p><pre class="lm ln lo lp fd lv lu lw lx aw ly bi"><span id="8cb5" class="lz jv hi lu b fi ma mb l mc md">apiVersion: cert-manager.io/v1<br/>kind: Issuer<br/>metadata:<br/>  name: ca-cert-issuer<br/>spec:<br/>  ca:<br/>    secretName: loaded-ca-key-pair</span></pre><p id="247e" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">我们将<code class="du lr ls lt lu b">issuer.yaml</code>导入到 Kubernetes 中</p><pre class="lm ln lo lp fd lv lu lw lx aw ly bi"><span id="c150" class="lz jv hi lu b fi ma mb l mc md">kubectl apply -f issuer.yaml</span></pre><p id="4d1d" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">此颁发者将只在当前命名空间中工作；如果您需要一个涵盖所有名称空间的发布者，那么您应该创建一个 ClusterIssuer。语法是相同的，只有“种类”不同。</p><p id="2661" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">3.最后，我们需要对入口资源进行一些修改。我们需要添加<code class="du lr ls lt lu b">cert-manager.io/issuer</code>注释来指向我们的发行者:</p><pre class="lm ln lo lp fd lv lu lw lx aw ly bi"><span id="2738" class="lz jv hi lu b fi ma mb l mc md">apiVersion: extensions/v1beta1<br/>kind: Ingress<br/>metadata:<br/>  name: ingress-somecompany-service<br/>  annotations:<br/>    kubernetes.io/ingress.class: nginx<br/>    nginx.ingress.kubernetes.io/use-regex: 'true'<br/>    <strong class="lu hj">cert-manager.io/issuer: ca-cert-issuer</strong></span></pre><p id="c5af" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">我们还需要在入口资源的规范中添加一个位，以告诉 cert-manager 将我们的秘密放在哪里。当应用入口资源时，将自动创建此秘密:</p><pre class="lm ln lo lp fd lv lu lw lx aw ly bi"><span id="e9cc" class="lz jv hi lu b fi ma mb l mc md">spec:<br/>  <strong class="lu hj">tls:<br/>  - hosts:<br/>      - dev.somecompany.com<br/>     secretName: dev-sc-secret</strong><br/>  rules:<br/>  - host: dev.somecompany.com<br/>## and so on!</span></pre><p id="ef94" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">该证书以现在创建的秘密<code class="du lr ls lt lu b">dev-sc-secret</code>命名，该秘密是 cert-manager 实际上隐藏我们新创建的证书和密钥的地方，我们的入口资源现在将使用它。恭喜你！您应该能够浏览到 https://dev.somecompany.com 的<a class="ae jt" href="https://dev.somecompany.com" rel="noopener ugc nofollow" target="_blank">并从应用程序/目录中看到部署发布的网页。如果你检查页面使用的证书，你会发现你的浏览器要么非常满意(Chrome)，要么基本满意(Firefox)。您已经获得了对本地群集的安全访问。</a></p><p id="b47e" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi">— —</p><p id="f2ab" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">现在，您已经大致了解了如何在 Kubernetes 集群上配置 cert-manager，以及如何使用 X.509 证书保护您的本地开发集群。下一步是了解如何使用这些知识来加密公共 Kubernetes 集群中的免费证书。我们将把它留到第二部分。</p><p id="ce35" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><em class="js"> Rob Thorne 是一名全栈开发人员，最近他做了越来越多的开发工作。他可以被雇佣。你可以在 Twitter 上找到 Rob 的@torenware。</em></p></div></div>    
</body>
</html>