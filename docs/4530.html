<html>
<head>
<title>Normalizing absolute SVG paths with cubic bézier conversions</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用三次贝塞尔转换规范化绝对SVG路径</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/normalizing-absolute-svg-paths-with-cubic-b%C3%A9zier-conversions-ed3920d65423?source=collection_archive---------3-----------------------#2021-07-25">https://medium.com/nerd-for-tech/normalizing-absolute-svg-paths-with-cubic-b%C3%A9zier-conversions-ed3920d65423?source=collection_archive---------3-----------------------#2021-07-25</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div class="er es if"><img src="../Images/26164f14264157e11d8838954cb0bd93.png" data-original-src="https://miro.medium.com/v2/resize:fit:472/format:webp/1*Cl2wmRFRbfR5jNfbxqTBlA.jpeg"/></div><figcaption class="im in et er es io ip bd b be z dx translated">图片来源:20世纪福克斯</figcaption></figure><p id="b230" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这篇博客文章是<a class="ae jo" rel="noopener" href="/geekculture/june-17-calculating-svg-bézier-curve-intersections-without-snap-adff3fc6aae7">中的第3部分，它很快成为关于我最喜欢的主题之一的系列</a>:<strong class="is hj">矢量图形——一种可耻的未被充分利用的方式，用相对较少的努力将你的应用从“meh”变成“wow”。</strong>矢量轻便、快速且用途广泛，由于本系列文章的主题<code class="du jp jq jr js b"><strong class="is hj">&lt;path&gt;</strong></code> <strong class="is hj"> s(直线和曲线的序列),对它们进行操作/制作动画很容易。</strong></p><p id="10a6" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在今天的节目中，我将重温一个月前<a class="ae jo" href="https://javascript.plainenglish.io/june-3-parsing-and-validating-svg-paths-with-regex-7bd0e245115" rel="noopener ugc nofollow" target="_blank">的一段代码</a>，我称之为<code class="du jp jq jr js b">PathParser</code>。在那篇文章中，我解释了路径是用标准语法中的字符串定义的；我编写了一个类，将这些语法字符串解析成坐标数组，大家都玩得很开心。我们今天将添加代码，所以如果你想回顾它或者跟随你自己进入一个新的分支，那么<a class="ae jo" href="https://github.com/josh-frank/path-normalizer" rel="noopener ugc nofollow" target="_blank">派生并克隆库</a>。</p><blockquote class="jt ju jv"><p id="e917" class="iq ir jw is b it iu iv iw ix iy iz ja jx jc jd je jy jg jh ji jz jk jl jm jn hb bi translated">如果今天的博客帖子比平时更不连贯或更有错别字，我归咎于一种可怕的鼻窦感染，目前正在用工业级苯海拉明、异丙嗪和<a class="ae jo" href="https://drizly.com/liquor/soju/chum-churum-original-soju/p22242" rel="noopener ugc nofollow" target="_blank"> Chum-churum </a>治疗。不过谢天谢地，至少不是COVID！谢谢，莫德娜！</p></blockquote><h1 id="4f7b" class="ka kb hi bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated">背景:新常态</h1><p id="d47f" class="pw-post-body-paragraph iq ir hi is b it ky iv iw ix kz iz ja jb la jd je jf lb jh ji jj lc jl jm jn hb bi translated">在我之前关于SVG路径的讨论中，我解释过<code class="du jp jq jr js b">&lt;path&gt;</code>标签可以替换所有其他的形状标签，并且在<code class="du jp jq jr js b">&lt;path&gt;</code>标签中，贝塞尔<code class="du jp jq jr js b">C</code>和<code class="du jp jq jr js b">c</code>命令可以替换所有其他的命令，除了最初的<code class="du jp jq jr js b">M</code> / <code class="du jp jq jr js b">m</code>。以下两个形状具有相同的点，并且看起来相同:</p><pre class="ld le lf lg fd lh js li lj aw lk bi"><span id="05bb" class="ll kb hi js b fi lm ln l lo lp">const sameShape = [<br/>  "M 25 25 L 75 25 L 75 75 L 25 75 Z",<br/>  "M 25 25 C 25 25 75 25 75 25 C 75 25 75 75 75 75 C 75 75 25 75 25 75 Z"<br/>];</span><span id="2375" class="ll kb hi js b fi lq ln l lo lp">PathParser.parse( sameShape[ 0 ] )<br/>  -&gt; [ [ 25, 25 ], [ 75, 25 ], [ 75, 75 ], [ 25, 75 ], [] ]<br/>PathParser.parse( sameShape[ 1 ] )<br/>  -&gt; [ [ 25, 25 ], [ 75, 25 ], [ 75, 75 ], [ 25, 75 ], [] ]</span></pre><p id="f102" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">在一个</strong> <strong class="is hj">规格化的SVG路径中，所有命令，除了第一个</strong> <code class="du jp jq jr js b"><strong class="is hj">m</strong></code> <strong class="is hj"> / </strong> <code class="du jp jq jr js b"><strong class="is hj">M</strong></code> <strong class="is hj">命令外，都被转换成等价的</strong><code class="du jp jq jr js b"><strong class="is hj">C</strong></code>/<strong class="is hj">/</strong><code class="du jp jq jr js b"><strong class="is hj">c</strong></code><strong class="is hj">命令。路径规范化是常见的和常规的，因为它使各种路径操作变得容易得多。这是因为，当路径被规范化时，每个命令的凹度(曲线延伸超出其点多远)可以被计算，而无需针对不同的命令类型进行分支。</strong></p><h1 id="61d7" class="ka kb hi bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated">减少，重复使用…</h1><p id="faf4" class="pw-post-body-paragraph iq ir hi is b it ky iv iw ix kz iz ja jb la jd je jf lb jh ji jj lc jl jm jn hb bi translated">让我们调用我们的<code class="du jp jq jr js b">class NormalizedPath()</code>，并用一个<code class="du jp jq jr js b">constructor</code>和一个在初始化时被调用的方法<code class="du jp jq jr js b">parse()</code>填充它:</p><pre class="ld le lf lg fd lh js li lj aw lk bi"><span id="2053" class="ll kb hi js b fi lm ln l lo lp">class NormalizedPath {</span><span id="f885" class="ll kb hi js b fi lq ln l lo lp">  constructor( descriptor ) {<br/>    this.parse( descriptor );<br/>  }</span><span id="6445" class="ll kb hi js b fi lq ln l lo lp">  parse( descriptor ) {<br/>    ...<br/>  }</span><span id="e120" class="ll kb hi js b fi lq ln l lo lp">}</span></pre><p id="f926" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">不同的命令被不同地规范化，就像不同的命令在<code class="du jp jq jr js b">PathParser</code>中被不同地解析一样。我们在<code class="du jp jq jr js b">PathParser</code>中使用了<strong class="is hj">语法</strong>来执行正确的操作以解析路径；这一次，我们将使用<code class="du jp jq jr js b">reduce()</code>和一个大的<code class="du jp jq jr js b">switch() { case: }</code>来处理所有的事情，而不是使用<code class="du jp jq jr js b">normalizerGrammar</code>来做正确的数学运算来正常化一个命令。(后面多讲一点为什么。)</p><p id="fece" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如果你仔细观察上面的<code class="du jp jq jr js b">sameShape</code>，你会清楚地看到<strong class="is hj">路径的规范化版本中的每个点都依赖于它前面的点。对于我们需要使用的方法，这应该是一个巨大的线索！每次我们分析一个命令时，我们都需要跟踪它，这样我们就知道它的<code class="du jp jq jr js b">previous</code>命令用于下一个<code class="du jp jq jr js b">command</code>命令:</strong></p><pre class="ld le lf lg fd lh js li lj aw lk bi"><span id="efb6" class="ll kb hi js b fi lm ln l lo lp">parse( descriptor ) {<br/>  let previous = [ 0, 0 ];<br/>  this.parsedCommands = PathParser.parseRaw( descriptor ).reduce( ( result, command, index ) =&gt; {<br/>    switch( command[ 0 ].toLowerCase() ) {<br/>      ...<br/>    }<br/>  }, [] );<br/>}</span></pre><p id="da0f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><code class="du jp jq jr js b"><strong class="is hj">reduce()</strong></code> <strong class="is hj">是我最喜欢的JavaScript王牌</strong>之一——这就是为什么它是如此的罪恶，以至于在编程教程或编码训练营中很少被强调。当在数组上调用时，它需要两个参数，一个回调和一个对象/数组，就像这样:<code class="du jp jq jr js b">reduce( ( result, element ) =&gt; {}, [] )</code>。它执行回调中指定的逻辑，回调将参数a <code class="du jp jq jr js b">result</code>和被迭代的特定元素(在本例中，是单个的<code class="du jp jq jr js b">command</code>)作为参数。然后，它收集该逻辑的结果，将其粘贴到在<code class="du jp jq jr js b">reduce</code>的第二个参数中指定的结果对象/数组中，并返回它。</p><p id="e2d4" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">看看下面的代码，自己看看那个大ol' <code class="du jp jq jr js b">switch() { case: }</code>。请注意，为了我现在的理智，由于我的鼻窦爆炸，<strong class="is hj">这个类现在只解析绝对路径:</strong></p><pre class="ld le lf lg fd lh js li lj aw lk bi"><span id="213c" class="ll kb hi js b fi lm ln l lo lp">parse( descriptor ) {<br/>  let quadX, quadY, bezierX, bezierY, previousCommand = "", previousPoint = [ 0, 0 ];<br/>  const isRelative = command =&gt; command[ 0 ] === command[ 0 ].toLowerCase();</span><span id="e14d" class="ll kb hi js b fi lq ln l lo lp">  const updatePrevious = command =&gt; {<br/>    previousCommand = command[ 0 ];<br/>    if ( command[ 0 ].toLowerCase () === "h" ) previousPoint[ 0 ] = isRelative( command ) ? previousPoint[ 0 ] + command[ 1 ] : command[ 1 ];<br/>    else if ( command[ 0 ].toLowerCase () === "v" ) previousPoint[ 1 ] = isRelative( command ) ? previousPoint[ 1 ] + command[ 1 ] : command[ 1 ];<br/>    else {<br/>      previousPoint = isRelative( command ) ? [ previousPoint[ 0 ] + command[ command.length - 2 ], previousPoint[ 1 ] + command[ command.length - 1 ] ] : command.slice( command.length - 2 );<br/>    }<br/>  };</span><span id="ae8d" class="ll kb hi js b fi lq ln l lo lp">  this.parsedCommands = PathParser.parseRaw( descriptor ).reduce( ( result, command, index ) =&gt; {<br/>    let normalizedCommand;<br/>    switch ( command[ 0 ] ) {<br/>      case "M":<br/>        if ( !index ) normalizedCommand = command;<br/>        else normalizedCommand = [ "C", ...previousPoint, ...command.slice( 1 ), ...command.slice( 1 ) ];<br/>        break;<br/>      case "H":<br/>        normalizedCommand = [ "C", ...previousPoint, command[ 1 ], previousPoint[ 1 ], command[ 1 ], previousPoint[ 1 ] ];<br/>        break;<br/>      case "V":<br/>        normalizedCommand = [ "C", ...previousPoint, 0, command[ 1 ], 0, command[ 1 ] ];<br/>        break;<br/>      case "L":<br/>        normalizedCommand = [ "C", ...previousPoint, ...command.slice( 1 ), ...command.slice( 1 ) ];<br/>        break;<br/>      case "S":<br/>        let [ cx, cy ] = previousPoint;<br/>        if ( [ "c", "s" ].includes( previousCommand.toLowerCase() ) ) {<br/>          cx += cx - bezierX;<br/>          cy += cy - bezierY;<br/>        }<br/>        normalizedCommand = [ "C", cx, cy, command[ 1 ], command[ 2 ], command[ 3 ], command[ 4 ] ];<br/>        break;<br/>      case "Q":<br/>        quadX = command[ 1 ];<br/>        quadY = command[ 2 ];<br/>        normalizedCommand = [ "C",<br/>          previousPoint[ 0 ] / 3 + ( 2 / 3 ) * command[ 1 ],<br/>          previousPoint[ 1 ] / 3 + ( 2 / 3 ) * command[ 2 ],<br/>          command[ 3 ] / 3 + ( 2 / 3 ) * command[ 1 ],<br/>          command[ 4 ] / 3 + ( 2 / 3 ) * command[ 2 ],<br/>          command[ 3 ],<br/>          command[ 4 ]<br/>        ];<br/>        break;<br/>      case "T":<br/>        if ( [ "q", "t" ].includes( command[ 0 ].toLowerCase() ) ) {<br/>          quadX = previousPoint[ 0 ] * 2 - quadX;<br/>          quadY = previousPoint[ 1 ] * 2 - quadY;<br/>        } else {<br/>          quadX = previousPoint[ 0 ];<br/>          quadY = previousPoint[ 1 ];<br/>        }<br/>        normalizedCommand = [ "C",<br/>          previousPoint[ 0 ] / 3 + ( 2 / 3 ) * quadX,<br/>          previousPoint[ 1 ] / 3 + ( 2 / 3 ) * quadY,<br/>          command[ 1 ] / 3 + ( 2 / 3 ) * quadX,<br/>          command[ 2 ] / 3 + ( 2 / 3 ) * quadY,<br/>          command[ 1 ],<br/>          command[ 2 ]<br/>        ];<br/>        break;<br/>      case "A":<br/>        normalizedCommand = [ "C", ...arcToCubicBeziers( previousPoint, command.slice( 1 ) ) ];<br/>        break;<br/>      case "C":<br/>        normalizedCommand = command;<br/>        break;<br/>      case "Z":<br/>        normalizedCommand = [ "Z" ];<br/>        break;<br/>      default: break;<br/>    }</span><span id="2673" class="ll kb hi js b fi lq ln l lo lp">    [ bezierX, bezierY ] = command.length &gt; 4 ? [ command[ command.length - 4 ], command[ command.length - 3 ] ] : [ previousPoint[ 0 ], previousPoint[ 1 ] ];<br/>    updatePrevious( command );<br/>    return [ ...result, normalizedCommand ];<br/>  }, [] );</span><span id="0206" class="ll kb hi js b fi lq ln l lo lp">}</span></pre><p id="74e8" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">分解这个怪物的几个要点，不分先后:</p><ul class=""><li id="3bd3" class="lr ls hi is b it iu ix iy jb lt jf lu jj lv jn lw lx ly lz bi translated">你可以马上看到我们开始定义一大堆计数器:<code class="du jp jq jr js b">quadX</code>、<code class="du jp jq jr js b">quadY</code>、<code class="du jp jq jr js b">bezierX</code>、<code class="du jp jq jr js b">bezierY</code>、<code class="du jp jq jr js b">previousCommand</code>字母和<code class="du jp jq jr js b">previousPoint</code>。这是为了跟踪我们在哪个点上，以及它的曲线控制点(如果/如果适用的话)。</li><li id="7b45" class="lr ls hi is b it ma ix mb jb mc jf md jj me jn lw lx ly lz bi translated"><code class="du jp jq jr js b">parse()</code>在其闭包中包含两个实用函数——主要是为了避免重复代码。在顶部附近，我们定义了一个快速函数<code class="du jp jq jr js b">isRelative</code>，它告诉我们一个命令是相对的还是绝对的——这对正确更新<code class="du jp jq jr js b">previousPoint</code>很重要。在<code class="du jp jq jr js b">reduce</code>内部，在定义一个盒子来存放我们的<code class="du jp jq jr js b">previousPoint</code>之后，我们还定义了一个与<code class="du jp jq jr js b">parse()</code>到<code class="du jp jq jr js b">updatePrevious()</code>作用域相同的函数，这取决于命令是绝对的还是相对的。</li><li id="eb97" class="lr ls hi is b it ma ix mb jb mc jf md jj me jn lw lx ly lz bi translated">在我们的<code class="du jp jq jr js b">reduce</code>中的<code class="du jp jq jr js b">switch()</code>内，我们编写了将移动或直线命令解析成曲线的逻辑，这取决于<code class="du jp jq jr js b">previousPoint</code>是什么。记得我在上面提到过，在规范化路径中，除了第一个移动命令之外的所有命令<em class="jw">都已经被解析了——这就是为什么我们不处理<code class="du jp jq jr js b">M</code>命令<code class="du jp jq jr js b">if ( !index )</code>——也就是说，如果我们在第一个命令上。</em></li><li id="2021" class="lr ls hi is b it ma ix mb jb mc jf md jj me jn lw lx ly lz bi translated">像<code class="du jp jq jr js b">Q</code>、<code class="du jp jq jr js b">T</code>、<code class="du jp jq jr js b">S</code>和<code class="du jp jq jr js b">A</code>这样的曲线是特例——我们需要更多的信息来解析这些曲线，而不仅仅是<code class="du jp jq jr js b">previousPoint</code>坐标。这就是为什么有这些<code class="du jp jq jr js b">quadX</code> / <code class="du jp jq jr js b">quadY</code>和<code class="du jp jq jr js b">bezierX</code> / <code class="du jp jq jr js b">bezierY</code>计数器，这也是为什么我决定使用反语法——语法的全部目的是简化事情，但是为每个命令将这些参数传递给我们的语法有点麻烦。</li><li id="2d1f" class="lr ls hi is b it ma ix mb jb mc jf md jj me jn lw lx ly lz bi translated">最后，我们用迄今为止的<code class="du jp jq jr js b">...result</code>和新近的<code class="du jp jq jr js b">normalizedCommand</code>来<code class="du jp jq jr js b">updatePrevious</code>和<code class="du jp jq jr js b">return</code>一个数组。</li></ul><h1 id="ebb0" class="ka kb hi bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated">盟约之弧</h1><p id="04f3" class="pw-post-body-paragraph iq ir hi is b it ky iv iw ix kz iz ja jb la jd je jf lb jh ji jj lc jl jm jn hb bi translated">如果你仔细看了上面的代码，你需要精神病学的帮助(或者在NSA的工作)…你可能注意到<code class="du jp jq jr js b">A</code>命令的<code class="du jp jq jr js b">case</code>短得可疑:</p><pre class="ld le lf lg fd lh js li lj aw lk bi"><span id="603c" class="ll kb hi js b fi lm ln l lo lp">case "A":<br/>  normalizedCommand = [ "C", <strong class="js hj">...arcToCubicBeziers( previousPoint, command.slice( 1 ) )</strong> ];<br/>        break;</span></pre><p id="b470" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">事实是，<a class="ae jo" href="https://stackoverflow.com/a/30279817/14834132" rel="noopener ugc nofollow" target="_blank"> <strong class="is hj">没有简单的方法将圆弧转换成三次贝塞尔曲线</strong> </a> <strong class="is hj">。从数学上讲，不可能创建一个看起来与弧线完全相同的贝塞尔曲线，解释原因超出了本文的范围或我的能力范围(即使没有苯那君)。</strong></p><p id="b3d4" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">然而，<em class="jw">有可能用多条贝塞尔曲线复制一个圆弧。这正是像<a class="ae jo" href="http://snapsvg.io/" rel="noopener ugc nofollow" target="_blank"> Snap </a>和<a class="ae jo" href="http://paperjs.org/" rel="noopener ugc nofollow" target="_blank"> Paper </a>这样的库所做的……但是像那样导入一个完整的库仅仅是为了改变曲线，用<em class="jw"> Monty Python、</em> <a class="ae jo" href="https://www.youtube.com/watch?v=B7jLmZhhWRQ" rel="noopener ugc nofollow" target="_blank">的话说就是愚蠢，非常愚蠢</a>。所以，我使用的代码是我从科林·梅克的工作中改编/精简的；我之前在这个博客上讨论的另一个项目 <a class="ae jo" href="https://javascript.plainenglish.io/july-7-triggering-file-uploads-downloads-without-a-back-end-in-react-6438cb77859?source=your_stories_page-------------------------------------" rel="noopener ugc nofollow" target="_blank">中使用过它。这种方法计算一个弧的中心，然后用一些非常不愉快的数学方法将它分割成向量。</a><a class="ae jo" href="https://github.com/josh-frank/path-normalizer/blob/master/arcToCubicBeziers.js" rel="noopener ugc nofollow" target="_blank">在仓库里自己检查</a>；留下评论，当我不那么难受的时候，我可能会更深入地研究弧到立方的转换。</em></p><h1 id="16f0" class="ka kb hi bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated">结论</h1><p id="93ce" class="pw-post-body-paragraph iq ir hi is b it ky iv iw ix kz iz ja jb la jd je jf lb jh ji jj lc jl jm jn hb bi translated">你可能会发现自己想知道所有这些工作的意义是什么:</p><ul class=""><li id="e93f" class="lr ls hi is b it iu ix iy jb lt jf lu jj lv jn lw lx ly lz bi translated">在矢量动画中，规格化使得计算关键帧之间的过渡(或“补间”)更加容易和平滑</li><li id="2763" class="lr ls hi is b it ma ix mb jb mc jf md jj me jn lw lx ly lz bi translated">在视频游戏中，归一化使得计算<strong class="is hj">交点</strong>变得更加容易</li><li id="8fb7" class="lr ls hi is b it ma ix mb jb mc jf md jj me jn lw lx ly lz bi translated">在计算机图形学和机器学习应用中，归一化使得计算形状的<strong class="is hj">边界框</strong> — <em class="jw">完全包围形状的最小可能右垂直矩形</em>变得更容易，如下所示:</li></ul><figure class="ld le lf lg fd ij er es paragraph-image"><div class="er es mf"><img src="../Images/49a3d3ed0530086368156a8fb5a19e52.png" data-original-src="https://miro.medium.com/v2/resize:fit:1206/format:webp/1*tWS9feJSM42TSwPUm3cLvQ.png"/></div><figcaption class="im in et er es io ip bd b be z dx translated">边界框很吸引人——留下评论，我可能会在未来的博客文章中涉及它们。(图片鸣谢:StackOverflow上的Solo)</figcaption></figure><p id="f595" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">最后，稍微不同的一点是，我不得不提到我是多么感激接种了新型冠状病毒疫苗，这种病毒导致了新冠肺炎！如果我没有免疫力，我现在会病得更重！这个世界上有如此多的人迫切需要疫苗，如果你像我一样幸运地生活在发达国家，疫苗很可能是免费的。再也没有借口了！如果你还没有，请:如果可以的话，拍下来，拯救一条生命——也许是你自己！</p></div></div>    
</body>
</html>