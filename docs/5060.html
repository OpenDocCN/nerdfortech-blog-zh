<html>
<head>
<title>Using C# Generic Types With Scriptable Objects in Unity</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在Unity中使用C#泛型类型和可脚本化的对象</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/using-c-generic-types-with-scriptable-objects-in-unity-340cfc32811f?source=collection_archive---------1-----------------------#2021-08-25">https://medium.com/nerd-for-tech/using-c-generic-types-with-scriptable-objects-in-unity-340cfc32811f?source=collection_archive---------1-----------------------#2021-08-25</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="8a24" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">利用类继承来蒙蔽Unity</h2></div><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es ix"><img src="../Images/d2f7fbbd8250d559d6360ca8c8c1379b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1228/format:webp/1*wKIhQJCirUxonoTnYjLbmg.png"/></div><figcaption class="jf jg et er es jh ji bd b be z dx translated">技术上不真实。</figcaption></figure><p id="b4cc" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">我最近看了Ryan Hipple关于游戏架构的精彩演示，他展示了一个他称之为运行时集的有用模式。这是跟踪场景中给定类型的所有活动对象的有用方法。如果你曾经需要跟踪一波中有多少敌人，或者玩家的战俘营中有哪些建筑，这是一个很好的方法来跟踪这些信息，并且任何需要这些信息的类或方法都可以使用，而不需要硬依赖或额外的代码。</p><p id="d37a" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">棘手的是，他没有完全解释运行时集的实现。他只是展示了核心对象的简化版本。代码如下:</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="kh ki di kj bf kk"><div class="er es kg"><img src="../Images/fc118776caba292e28a97161f0d3c29b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pxcg2k_NL21o4XzhOC14SQ.png"/></div></div><figcaption class="jf jg et er es jh ji bd b be z dx translated">瑞安·希普尔，团结奥斯汀2017</figcaption></figure><p id="fe28" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">这很棒，对吧？如果我想跟踪我的战术救援游戏中的所有参与者，我只需要创建一个新的。此类属的特定类型的资产。像这样:</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="kh ki di kj bf kk"><div class="er es kg"><img src="../Images/027f45a967044498981a7375c74deae6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ci_N_hUGE7n5DXnjPcPkLQ.png"/></div></div></figure><p id="128e" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">但是如果你看到顶部的剧透…不。Unity不喜欢那样。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es ix"><img src="../Images/d2f7fbbd8250d559d6360ca8c8c1379b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1228/format:webp/1*wKIhQJCirUxonoTnYjLbmg.png"/></div></figure><p id="6c8a" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">不支持一般的MonoBehaviours？！这根本不是一种单一行为！瑞安·希普勒用了什么魔法来完成这个作品？</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="kh ki di kj bf kk"><div class="er es kl"><img src="../Images/4c250a7ec9c1f45a641be039ca10ba3a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*EKu4oqJRYesAQi-iezbUew.gif"/></div></div><figcaption class="jf jg et er es jh ji bd b be z dx translated">WTH，团结？！</figcaption></figure><p id="5f0a" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">好吧，显然我们需要一个不同的方法。Unity不想创建一个泛型类的实例，所以我们必须给泛型类披上羊皮。</p><p id="ae8a" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">让我们制作一套服装。这并不复杂——只要有足够的外表来欺骗Unity给我们想要的就行了。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="kh ki di kj bf kk"><div class="er es kg"><img src="../Images/9070d7c88b75de610c2f29e6d5c7a7c3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Ls5mJZhelOcvNe0Di7_1ag.png"/></div></div><figcaption class="jf jg et er es jh ji bd b be z dx translated">呜哇——呃，我是说……咩！</figcaption></figure><p id="51a4" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">哇哦。是啊，就这么简单。<em class="km"> ActorRuntimeSet </em>继承了其父类的所有方法和字段——在本例中，不再通用的<em class="km"> RuntimeSet &lt; Actor &gt;。</em>所以，不需要身体。我们已经定义过了。</p><p id="e8f0" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">现在，我们可以创建我们的。代码已修改的资产:</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="kh ki di kj bf kk"><div class="er es kg"><img src="../Images/ee7cd441663fd3be79eb3afe809b700d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LHfBtmH2Di6hdXM-PQcpbg.png"/></div></div></figure><p id="015b" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">这是结果:</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="kh ki di kj bf kk"><div class="er es kn"><img src="../Images/cc9d12131d9cd43a93acbfc55b5f8fd5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*E1m9CJMJTUNYdErh_-vNBg.png"/></div></div></figure><p id="4352" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">我可以把这个资产放到我的演员预置的一个序列化字段中，然后指示他们在启用或禁用的时候在列表中添加或删除他们自己:</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="kh ki di kj bf kk"><div class="er es kg"><img src="../Images/8192e6801d68a183ff5c453e147a3f51.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5LubXOW5uUItJ6DJMUZ4lg.png"/></div></div></figure><p id="d507" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">这就是要点:通过将一个泛型类继承到一个标准类，你可以在Unity的注意下隐藏泛型类型。一旦你建立了一个资产，你可以让任何对象引用它来获得一个更新的项目列表。</p><p id="b6bd" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">你能想出其他方法来使用这一招吗？在下面留言告诉我吧！</p></div></div>    
</body>
</html>