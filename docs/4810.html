<html>
<head>
<title>LeetCode — Letter Combinations of a Phone Number</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">LeetCode —电话号码的字母组合</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/leetcode-letter-combinations-of-a-phone-number-f711ab47dfb1?source=collection_archive---------4-----------------------#2021-08-08">https://medium.com/nerd-for-tech/leetcode-letter-combinations-of-a-phone-number-f711ab47dfb1?source=collection_archive---------4-----------------------#2021-08-08</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div class="er es if"><img src="../Images/2f6b9a00bb6081e9b0a8110ba778202c.png" data-original-src="https://miro.medium.com/v2/resize:fit:534/format:webp/1*AVNS1q5aVTM615wMfdr4RA.png"/></div></figure><h1 id="368a" class="im in hi bd io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj bi translated">问题陈述</h1><p id="5927" class="pw-post-body-paragraph jk jl hi jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh hb bi translated">给定一个包含从<strong class="jm hj"> 2到9 </strong>的数字的字符串，返回该数字可能代表的所有可能的字母组合。在<strong class="jm hj">任意顺序</strong>返回答案。</p><p id="25db" class="pw-post-body-paragraph jk jl hi jm b jn ki jp jq jr kj jt ju jv kk jx jy jz kl kb kc kd km kf kg kh hb bi translated">下面给出了数字到字母的映射(就像电话按钮一样)。请注意，1不映射到任何字母。</p><p id="bfd2" class="pw-post-body-paragraph jk jl hi jm b jn ki jp jq jr kj jt ju jv kk jx jy jz kl kb kc kd km kf kg kh hb bi translated">问题陈述摘自:<a class="ae kn" href="https://leetcode.com/problems/letter-combinations-of-a-phone-number" rel="noopener ugc nofollow" target="_blank">https://leet code . com/problems/letter-combinations-of-a-phone-number</a></p><p id="cdb2" class="pw-post-body-paragraph jk jl hi jm b jn ki jp jq jr kj jt ju jv kk jx jy jz kl kb kc kd km kf kg kh hb bi translated"><strong class="jm hj">例1: </strong></p><pre class="ko kp kq kr fd ks kt ku kv aw kw bi"><span id="f0ab" class="kx in hi kt b fi ky kz l la lb">Input: digits = "23"<br/>Output: ["ad", "ae", "af", "bd", "be", "bf", "cd", "ce", "cf"]</span></pre><p id="cf8e" class="pw-post-body-paragraph jk jl hi jm b jn ki jp jq jr kj jt ju jv kk jx jy jz kl kb kc kd km kf kg kh hb bi translated"><strong class="jm hj">例2: </strong></p><pre class="ko kp kq kr fd ks kt ku kv aw kw bi"><span id="e14e" class="kx in hi kt b fi ky kz l la lb">Input: digits = ""<br/>Output: []</span></pre><p id="513a" class="pw-post-body-paragraph jk jl hi jm b jn ki jp jq jr kj jt ju jv kk jx jy jz kl kb kc kd km kf kg kh hb bi translated"><strong class="jm hj">例3: </strong></p><pre class="ko kp kq kr fd ks kt ku kv aw kw bi"><span id="7d54" class="kx in hi kt b fi ky kz l la lb">Input: digits = "2"<br/>Output: ["a", "b", "c"]</span></pre><p id="2a9d" class="pw-post-body-paragraph jk jl hi jm b jn ki jp jq jr kj jt ju jv kk jx jy jz kl kb kc kd km kf kg kh hb bi translated"><strong class="jm hj">约束:</strong></p><pre class="ko kp kq kr fd ks kt ku kv aw kw bi"><span id="8bc7" class="kx in hi kt b fi ky kz l la lb">- 0 &lt;= digits.length &lt;= 4<br/>- digits[i] is a digit in the range ['2', '9']</span></pre><h1 id="524c" class="im in hi bd io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj bi translated">说明</h1><p id="78ce" class="pw-post-body-paragraph jk jl hi jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh hb bi translated">这个问题可以用迭代和递归的方法来解决。我们将在博客中讨论递归解决方案。</p><h2 id="7ef0" class="kx in hi bd io lc ld le is lf lg lh iw jv li lj ja jz lk ll je kd lm ln ji lo bi translated">递归</h2><p id="4ba9" class="pw-post-body-paragraph jk jl hi jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh hb bi translated">每个数字(除了0和1)可以代表3到4个不同的字母。为了存储这些数据，我们可以使用一个哈希映射，其中键是数字，值是相应的字符串。</p><p id="33e7" class="pw-post-body-paragraph jk jl hi jm b jn ki jp jq jr kj jt ju jv kk jx jy jz kl kb kc kd km kf kg kh hb bi translated">递归函数将尝试按字母顺序映射到当前数字的所有字母，并为下一个数字再次调用递归函数，并将传递当前输出字符串。</p><p id="52b3" class="pw-post-body-paragraph jk jl hi jm b jn ki jp jq jr kj jt ju jv kk jx jy jz kl kb kc kd km kf kg kh hb bi translated">例如，如果数字是34，数字3映射到“def”。将为每个字符d、e和f调用三个递归函数。对于映射到“ghi”的数字4，我们将字符g、h和I附加到所有的d、e和f。这将生成dg、dh、d i、eg、eh、ei和fg、fh、fi。</p><h2 id="7a30" class="kx in hi bd io lc ld le is lf lg lh iw jv li lj ja jz lk ll je kd lm ln ji lo bi translated">算法</h2><pre class="ko kp kq kr fd ks kt ku kv aw kw bi"><span id="9e27" class="kx in hi kt b fi ky kz l la lb">- initialize hashmap with key as digit and value with the corresponding string.<br/><br/>- initialize the result as an empty array.<br/><br/>- if digits.size() != 0<br/>  - call recursive function generateCombination("", digits, 0)<br/><br/>- return result.<br/><br/>// generateCombination(current, digits, index)<br/>- if index == digits.size<br/>  - append current in result.<br/><br/>- else<br/>  - currentDigit = digits[index]<br/>  - string mapping = hashmap[currentDigit];<br/>  - Loop<br/>    - for(int i = 0; i &lt; mapping.size(); i++) {<br/>        generateCombination(current + mapping[i], digits, index + 1);<br/>      }</span></pre><p id="6eba" class="pw-post-body-paragraph jk jl hi jm b jn ki jp jq jr kj jt ju jv kk jx jy jz kl kb kc kd km kf kg kh hb bi translated"><strong class="jm hj"> C++解决方案</strong></p><pre class="ko kp kq kr fd ks kt ku kv aw kw bi"><span id="180f" class="kx in hi kt b fi ky kz l la lb">class Solution {<br/>private:<br/>    map&lt;char, string&gt; m = {<br/>        {'2', "abc"}, {'3', "def"}, {'4', "ghi"},<br/>        {'5', "jkl"}, {'6', "mno"}, {'7', "pqrs"},<br/>        {'8', "tuv"}, {'9', "wxyz"}<br/>    };<br/><br/>    vector&lt;string&gt; result;<br/><br/>public:<br/>    vector&lt;string&gt; letterCombinations(string digits) {<br/>        if(digits.size() != 0){<br/>            generateCombination("", digits, 0);<br/>        }<br/><br/>        return result;<br/>    }<br/><br/>    void generateCombination(string current, string digits, int index) {<br/>        if(index == digits.size()){<br/>            result.push_back(current);<br/>        } else {<br/>            char currentDigit = digits[index];<br/>            string mapping = m[currentDigit];<br/>            for(int i = 0; i &lt; mapping.size(); i++){<br/>                generateCombination(current + mapping[i], digits, index+1);<br/>            }<br/>        }<br/>    }<br/>};</span></pre><p id="b9d6" class="pw-post-body-paragraph jk jl hi jm b jn ki jp jq jr kj jt ju jv kk jx jy jz kl kb kc kd km kf kg kh hb bi translated"><strong class="jm hj">戈朗解决方案</strong></p><pre class="ko kp kq kr fd ks kt ku kv aw kw bi"><span id="b2b0" class="kx in hi kt b fi ky kz l la lb">var letters = [...]string{"", "", "abc", "def", "ghi", "jkl",<br/>	"mno", "pqrs", "tuv", "wxyz"}<br/><br/>func letterCombinations(digits string) []string {<br/>    if len(digits) == 0 {<br/>		return nil<br/>	}<br/><br/>	var result []string<br/><br/>    generateCombination("", digits, &amp;result)<br/><br/>	return result<br/>}<br/><br/>func generateCombination(current string, digits string, ans *[]string) {<br/>	if len(digits) == 0 {<br/>		*ans = append(*ans, current)<br/>		return<br/>	}<br/><br/>	currentDigit, _ := strconv.Atoi(string(digits[0]))<br/><br/>	for i := 0; i &lt; len(letters[currentDigit]); i++ {<br/>		generateCombination(current + string(letters[currentDigit][i]), digits[1:], ans)<br/>	}<br/>}</span></pre><p id="610a" class="pw-post-body-paragraph jk jl hi jm b jn ki jp jq jr kj jt ju jv kk jx jy jz kl kb kc kd km kf kg kh hb bi translated"><strong class="jm hj"> Javascript解决方案</strong></p><pre class="ko kp kq kr fd ks kt ku kv aw kw bi"><span id="e2d8" class="kx in hi kt b fi ky kz l la lb">const map = {<br/>        2: 'abc',<br/>        3: 'def',<br/>        4: 'ghi',<br/>        5: 'jkl',<br/>        6: 'mno',<br/>        7: 'pqrs',<br/>        8: 'tuv',<br/>        9: 'wxyz',<br/>    };<br/><br/>let result = [];<br/><br/>var letterCombinations = function(digits) {<br/>    if (!digits) return [];<br/><br/>    let current = [];<br/><br/>    generateCombination(current, digits, 0);<br/><br/>    return result;<br/>};<br/><br/>function generateCombination(current, digits, index) {<br/>    if (index === digits.length) {<br/>        result.push(current.join(''));<br/>        return;<br/>    }<br/><br/>    for (const char of map[digits[index]]) {<br/>        current.push(char);<br/>        generateCombination(current, digits, index + 1);<br/>        current.pop();<br/>    }<br/>}</span></pre><p id="e759" class="pw-post-body-paragraph jk jl hi jm b jn ki jp jq jr kj jt ju jv kk jx jy jz kl kb kc kd km kf kg kh hb bi translated">让我们试运行一下我们的算法，看看解决方案是如何工作的。</p><pre class="ko kp kq kr fd ks kt ku kv aw kw bi"><span id="b853" class="kx in hi kt b fi ky kz l la lb">Input: digits = "23"<br/><br/>Step 1: map&lt;char, string&gt; m = {<br/>            {'2', "abc"}, {'3', "def"}, {'4', "ghi"},<br/>            {'5', "jkl"}, {'6', "mno"}, {'7', "pqrs"},<br/>            {'8', "tuv"}, {'9', "wxyz"}<br/>        };<br/><br/>        vector&lt;string&gt; result;<br/><br/>Step 2: digits.size() == 0<br/>        2 == 0<br/>        false<br/><br/>Step 3: generateCombination("", digits, 0)<br/><br/>Step 4: index == digits.size()<br/>        0 == 2<br/>        false<br/><br/>        char currentDigit = digits[index];<br/>        currentDigit = digits[0];<br/>        currentDigit = "2"<br/><br/>        string mapping = m[currentDigit];<br/>        mapping = m["2"]<br/>        mapping = "abc"<br/><br/>        loop 1.0:<br/>        for(int i = 0; i &lt; mapping.size(); i++)<br/>        0 &lt; 2<br/><br/>        generateCombination(current + mapping[i], digits, index + 1)<br/>        generateCombination("" + mapping[0], "23", 0 + 1)<br/>        generateCombination("" + "a", "23", 0 + 1)<br/>        generateCombination("a", "23", 1)<br/><br/>Step 5: generateCombination("a", "23", 1)<br/>        index == digits.size()<br/>        1 == 2<br/>        false<br/><br/>        char currentDigit = digits[1];<br/>        currentDigit = digits[1];<br/>        currentDigit = "3"<br/><br/>        string mapping = m[currentDigit];<br/>        mapping = m["3"]<br/>        mapping = "def"<br/><br/>        loop 1.1:<br/>        for(int i = 0; i &lt; mapping.size(); i++)<br/>        0 &lt; 3<br/><br/>        generateCombination(current + mapping[i], digits, index + 1)<br/>        generateCombination("a" + mapping[0], "23", 1 + 1)<br/>        generateCombination("a" + "d", "23", 1 + 1)<br/>        generateCombination("ad", "23", 2)<br/><br/>Step 6: generateCombination("ad", "23", 2)<br/>        index == digits.size()<br/>        2 == 2<br/>        true<br/><br/>        result.push_back(current)<br/>        result.push_back("ad")<br/>        result = ["ad"]<br/><br/>Step 7: Algo flow returns to loop 1.1<br/><br/>        loop 1.2:<br/>        for(int i = 0; i &lt; mapping.size(); i++)<br/>        // since i was 0 it is incremented i++ to 1<br/><br/>        i &lt; mapping.size()<br/>        1 &lt; 3<br/>        true<br/><br/>        generateCombination(current + mapping[i], digits, index + 1)<br/>        generateCombination("a" + mapping[1], "23", 1 + 1)<br/>        generateCombination("a" + "e", "23", 1 + 1)<br/>        generateCombination("ae", "23", 2)<br/><br/>Step 8: generateCombination("ae", "23", 2)<br/>        index == digits.size()<br/>        2 == 2<br/>        true<br/><br/>        result.push_back(current)<br/>        result.push_back("ae")<br/>        result = ["ad", "ae"]<br/><br/>Step 9: Algo flow returns to loop 1.2<br/><br/>        loop 1.3:<br/>        for(int i = 0; i &lt; mapping.size(); i++)<br/>        // since i was 1 it is incremented i++ to 2<br/><br/>        i &lt; mapping.size()<br/>        2 &lt; 3<br/>        true<br/><br/>        generateCombination(current + mapping[i], digits, index + 1)<br/>        generateCombination("a" + mapping[2], "23", 1 + 1)<br/>        generateCombination("a" + "f", "23", 1 + 1)<br/>        generateCombination("af", "23", 2)<br/><br/>Step 10: generateCombination("af", "23", 2)<br/>        index == digits.size()<br/>        2 == 2<br/>        true<br/><br/>        result.push_back(current)<br/>        result.push_back("af")<br/>        result = ["ad", "ae", "af"]<br/><br/>Step 11: Algo flow returns to loop 1.3<br/><br/>        loop 1.4:<br/>        for(int i = 0; i &lt; mapping.size(); i++)<br/>        // since i was 2 it is incremented i++ to 3<br/><br/>        i &lt; mapping.size()<br/>        3 &lt; 3<br/>        false<br/><br/>Step 12: Algo flow returns to loop 1.0<br/><br/>        loop 1.5:<br/>        for(int i = 0; i &lt; mapping.size(); i++)<br/>        // since i was 0 it is incremented i++ to 1<br/><br/>        i &lt; mapping.size()<br/>        1 &lt; 3<br/>        true<br/><br/>        generateCombination(current + mapping[i], digits, index + 1)<br/>        generateCombination("" + mapping[1], "23", 0 + 1)<br/>        generateCombination("" + "b", "23", 0 + 1)<br/>        generateCombination("b", "23", 1)<br/><br/>Step 13: generateCombination("b", "23", 1)<br/><br/>        index == digits.size()<br/>        1 == 2<br/>        false<br/><br/>        char currentDigit = digits[1];<br/>        currentDigit = digits[1];<br/>        currentDigit = "3"<br/><br/>        string mapping = m[currentDigit];<br/>        mapping = m["3"]<br/>        mapping = "def"<br/><br/>        loop 2.1:<br/>        for(int i = 0; i &lt; mapping.size(); i++)<br/>        0 &lt; 3<br/><br/>        generateCombination(current + mapping[i], digits, index + 1)<br/>        generateCombination("b" + mapping[0], "23", 1 + 1)<br/>        generateCombination("b" + "d", "23", 1 + 1)<br/>        generateCombination("bd", "23", 2)<br/><br/>Step 14: generateCombination("bd", "23", 2)<br/>        index == digits.size()<br/>        2 == 2<br/>        true<br/><br/>        result.push_back(current)<br/>        result.push_back("bd")<br/>        result = ["ad", "ae", "af", "bd"]<br/><br/>Step 15: Algo flow returns to loop 2.1<br/><br/>        loop 2.2:<br/>        for(int i = 0; i &lt; mapping.size(); i++)<br/>        // since i was 0 it is incremented i++ to 1<br/><br/>        i &lt; mapping.size()<br/>        1 &lt; 3<br/>        true<br/><br/>        generateCombination(current + mapping[i], digits, index + 1)<br/>        generateCombination("b" + mapping[1], "23", 1 + 1)<br/>        generateCombination("b" + "e", "23", 1 + 1)<br/>        generateCombination("be", "23", 2)<br/><br/>Step 16: generateCombination("be", "23", 2)<br/>        index == digits.size()<br/>        2 == 2<br/>        true<br/><br/>        result.push_back(current)<br/>        result.push_back("be")<br/>        result = ["ad", "ae", "af", "bd", "be"]<br/><br/>Step 17: Algo flow returns to loop 2.2<br/><br/>        loop 2.3:<br/>        for(int i = 0; i &lt; mapping.size(); i++)<br/>        // since i was 1 it is incremented i++ to 2<br/><br/>        i &lt; mapping.size()<br/>        2 &lt; 3<br/>        true<br/><br/>        generateCombination(current + mapping[i], digits, index + 1)<br/>        generateCombination("b" + mapping[1], "23", 1 + 1)<br/>        generateCombination("b" + "f", "23", 1 + 1)<br/>        generateCombination("bf", "23", 2)<br/><br/>Step 18: generateCombination("bf", "23", 2)<br/>        index == digits.size()<br/>        2 == 2<br/>        true<br/><br/>        result.push_back(current)<br/>        result.push_back("bf")<br/>        result = ["ad", "ae", "af", "bd", "be", "bf"]<br/><br/>// similar steps are triggered for c with d, e, and f.<br/><br/>The output is<br/>["ad", "ae", "af", "bd", "be", "bf", "cd", "ce", "cf"]</span></pre></div><div class="ab cl lp lq gp lr" role="separator"><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu"/></div><div class="hb hc hd he hf"><p id="9926" class="pw-post-body-paragraph jk jl hi jm b jn ki jp jq jr kj jt ju jv kk jx jy jz kl kb kc kd km kf kg kh hb bi translated"><em class="lw">原载于</em><a class="ae kn" href="https://alkeshghorpade.me/post/leetcode-letter-combinations-of-phone-numbers" rel="noopener ugc nofollow" target="_blank"><em class="lw">https://alkeshghorpade . me</em></a><em class="lw">。</em></p></div></div>    
</body>
</html>