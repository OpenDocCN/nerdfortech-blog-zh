<html>
<head>
<title>Checking API Key without shooting yourself in the foot (JavaScript, NodeJS)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">检查 API 密钥，而不是搬起石头砸自己的脚(JavaScript，NodeJS)</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/checking-api-key-without-shooting-yourself-in-the-foot-javascript-nodejs-f271e47bb428?source=collection_archive---------3-----------------------#2021-07-09">https://medium.com/nerd-for-tech/checking-api-key-without-shooting-yourself-in-the-foot-javascript-nodejs-f271e47bb428?source=collection_archive---------3-----------------------#2021-07-09</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/f460787798f5aae107e742d45bcbdbda.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*LZsoTHIEc_-mYTvG"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">照片由<a class="ae iu" href="https://unsplash.com/@picsaf?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">阿扎马特 E </a>在<a class="ae iu" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="8e2a" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">非常容易搬起石头砸自己的脚，不仅一不小心让黑客<em class="jt">轻松黑掉认证机制</em>，还让<em class="jt">更容易让他们找出 API 密钥</em>！</p><p id="7c06" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如果 API 密匙控制对一些潜在的昂贵资源的访问，这可能会特别有问题，因此通过获取 API 密匙，黑客可以让你积累相当多的账单。</p><p id="1c96" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">当后端开发人员编写 API 时，有时他们需要验证请求者。服务器需要找出是谁发出的请求，这样它就可以授权或拒绝访问。有许多方法可以实现这一点，其中之一是通过 API 键。</p></div><div class="ab cl ju jv gp jw" role="separator"><span class="jx bw bk jy jz ka"/><span class="jx bw bk jy jz ka"/><span class="jx bw bk jy jz"/></div><div class="hb hc hd he hf"><h1 id="5a62" class="kb kc hi bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated">API 基于密钥的身份验证的工作原理</h1><p id="57e4" class="pw-post-body-paragraph iv iw hi ix b iy kz ja jb jc la je jf jg lb ji jj jk lc jm jn jo ld jq jr js hb bi translated">在其核心，API 基于密钥的认证机制是这样工作的:<br/>API 消费者发送一个请求，并在其中嵌入一个密钥。如果密钥与服务器预期的密钥匹配，那么用户就通过了身份验证(因为他们有一个共享的秘密)。<br/>天真地说，代码中可能是这样的:</p><pre class="le lf lg lh fd li lj lk ll aw lm bi"><span id="2e72" class="ln kc hi lj b fi lo lp l lq lr">if (req.body.apiKey == expectedApiKey) {<br/>  // Authorize access<br/>} else {<br/>  response.status(401).send('unauthorized');<br/>}</span></pre><p id="0b24" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">因此，如果消费者发送的密钥(<code class="du ls lt lu lj b">req.body.apiKey</code>)与我们期望的 API 密钥(<code class="du ls lt lu lj b">expectedApiKey</code>)相同，那么我们授权访问，否则我们发送一个错误。<br/>不幸的是，这段代码容易受到定时攻击。</p></div><div class="ab cl ju jv gp jw" role="separator"><span class="jx bw bk jy jz ka"/><span class="jx bw bk jy jz ka"/><span class="jx bw bk jy jz"/></div><div class="hb hc hd he hf"><h1 id="8737" class="kb kc hi bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated">什么是定时攻击？</h1><p id="e046" class="pw-post-body-paragraph iv iw hi ix b iy kz ja jb jc la je jf jg lb ji jj jk lc jm jn jo ld jq jr js hb bi translated">黑客可以用来危害系统的一种技术叫做“定时攻击”。其工作方式是通过测量从系统获得响应需要多长时间，并通过从时间中获得洞察力来利用它。<br/>举个例子，假设一个黑客试图从服务器上猜出一个密码。如果黑客猜测的正确密码越接近，服务器的响应时间就越长，那么他可以使用计时信息来缩小可能的密码猜测范围。这有点像“寻找顶针”,服务器告诉黑客他是变得更近(更热)还是更远(更冷)。</p></div><div class="ab cl ju jv gp jw" role="separator"><span class="jx bw bk jy jz ka"/><span class="jx bw bk jy jz ka"/><span class="jx bw bk jy jz"/></div><div class="hb hc hd he hf"><h1 id="8492" class="kb kc hi bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated">为什么天真的方法容易受到攻击？</h1><p id="460c" class="pw-post-body-paragraph iv iw hi ix b iy kz ja jb jc la je jf jg lb ji jj jk lc jm jn jo ld jq jr js hb bi translated">在 JavaScript 字符串比较中，使用<code class="du ls lt lu lj b">==</code>和<code class="du ls lt lu lj b">===</code>操作符是不安全的。在后台，它遍历操作数，如果一个字符不同，它会提前终止。它看起来会像这样:</p><pre class="le lf lg lh fd li lj lk ll aw lm bi"><span id="af26" class="ln kc hi lj b fi lo lp l lq lr">bool operator==(string op1, string op2) {<br/>  if(op1.length != op2.length) return false;<br/>  for(let i = 0; i &lt; op1.length; ++i) {<br/>    if op1[i] != op2[i] return false;<br/>  }<br/>  return true;<br/>}</span></pre><p id="d280" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这里有 2 个问题:<br/> 1。如果输入的长度不相同，过程会提前返回。<br/> 2。<code class="du ls lt lu lj b">for</code>循环经历的迭代次数取决于相等子串的长度。<br/>发生的情况是，它向攻击者泄露了有用的信息:长度是否正确？如果是的话，到目前为止我猜对了多少子串呢？</p><p id="1ac6" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">作为一个攻击者，我可以猜测 API 密钥，并测量我需要多长时间才能得到拒绝消息。如果我注意到对于一些猜测的 API 键，比其他的要花更长的时间被拒绝，我可以推断我可能已经正确地猜测了一部分(一个子串)。然后，我可以根据这个猜测尝试各种变化，以缩小正确的子串或找出更长的正确子串。</p></div><div class="ab cl ju jv gp jw" role="separator"><span class="jx bw bk jy jz ka"/><span class="jx bw bk jy jz ka"/><span class="jx bw bk jy jz"/></div><div class="hb hc hd he hf"><h1 id="dee1" class="kb kc hi bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated">如何修复漏洞？</h1><p id="e935" class="pw-post-body-paragraph iv iw hi ix b iy kz ja jb jc la je jf jg lb ji jj jk lc jm jn jo ld jq jr js hb bi translated">NodeJS 有一个内置的加密模块，它实现了<a class="ae iu" href="https://nodejs.org/api/crypto.html#crypto_crypto_timingsafeequal_a_b" rel="noopener ugc nofollow" target="_blank">timingsafequal</a>。它与简单的相等性检查的不同之处在于它基于一个常数时间算法。在同样长的时间后，不管字符串是否相等，也不管是否有相等的子串，都会得到一个响应。</p><p id="4cd8" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">它的代码可能是这样的:</p><pre class="le lf lg lh fd li lj lk ll aw lm bi"><span id="d1a9" class="ln kc hi lj b fi lo lp l lq lr">bool timingSafeEqual(string op1, string op2) {<br/>  bool eq = true;<br/>  for(let i = 0; i &lt; Math.min(op1.length, op2.length); ++i) {<br/>    if op1[i] != op2[i] eq = false;<br/>  }<br/>  if op1.length != op2.length eq = false;<br/>  return eq;<br/>}</span></pre><p id="b075" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">通过将<code class="du ls lt lu lj b">req.body.apiKey</code>和<code class="du ls lt lu lj b">expectedApiKey</code>作为参数传递给<code class="du ls lt lu lj b">timingSafeEqual</code>，您可以在不泄露计时信息的情况下发现它们是否相等。</p><p id="e690" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">然而，事情没那么简单！<code class="du ls lt lu lj b">timingSafeEqual</code>的文档说参数必须都是<code class="du ls lt lu lj b">Buffer</code> s、<code class="du ls lt lu lj b">TypedArray</code> s 或<code class="du ls lt lu lj b">DataView</code> s。这不是问题。问题是<strong class="ix hj">它们必须有相同的字节长度</strong>。</p><p id="4c56" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">所以我们处于进退两难的境地。为了修复这个漏洞，我们需要使用<code class="du ls lt lu lj b">timingSafeEqual</code>，但是使用<code class="du ls lt lu lj b">timingSafeEqual</code>，如果长度不同，我们需要做一些特殊的事情。我们如何做到这一点而不泄露时间信息呢？</p><h1 id="47f0" class="kb kc hi bd kd ke lv kg kh ki lw kk kl km lx ko kp kq ly ks kt ku lz kw kx ky bi translated">让我们看看我们的选择</h1><p id="1168" class="pw-post-body-paragraph iv iw hi ix b iy kz ja jb jc la je jf jg lb ji jj jk lc jm jn jo ld jq jr js hb bi translated"><em class="jt">如果我们这样做:</em></p><pre class="le lf lg lh fd li lj lk ll aw lm bi"><span id="73b1" class="ln kc hi lj b fi lo lp l lq lr">if (crypto.timingSafeEqual(Buffer.from(req.body.apiKey), Buffer.from(expectedApiKey)) {<br/>  // Authorize access<br/>} else {<br/>  response.status(401).send('unauthorized');<br/>}</span></pre><p id="0750" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如果长度不同，将会引发异常。即使我们处理了这个异常，它仍然有一个计时足迹，所以我们会泄漏计时信息。</p><p id="6ba2" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><em class="jt">如果我们这样做:</em></p><pre class="le lf lg lh fd li lj lk ll aw lm bi"><span id="706d" class="ln kc hi lj b fi lo lp l lq lr">if (req.body.apiKey.length === expectedApiKey.length &amp;&amp; crypto.timingSafeEqual(Buffer.from(req.body.apiKey), Buffer.from(expectedApiKey)) {<br/>  // Authorize access<br/>} else {<br/>  response.status(401).send('unauthorized');<br/>}</span></pre><p id="3696" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如果长度不同，我们就不会到达<code class="du ls lt lu lj b">if</code>语句的<code class="du ls lt lu lj b">timingSafeEqual</code>部分(因为 JavaScript 的<a class="ae iu" href="https://en.wikipedia.org/wiki/Lazy_evaluation" rel="noopener ugc nofollow" target="_blank">延迟求值</a>)，所以我们又一次泄露了计时信息。</p><p id="7899" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><em class="jt">我们可以这样做:</em></p><pre class="le lf lg lh fd li lj lk ll aw lm bi"><span id="7509" class="ln kc hi lj b fi lo lp l lq lr">if (crypto.timingSafeEqual(Buffer.from(req.body.apiKey.padEnd(expectedApiKey.length).slice(0, expectedApiKey.length)), Buffer.from(expectedApiKey)) {<br/>  // Authorize access<br/>} else {<br/>  response.status(401).send('unauthorized');<br/>}</span></pre><p id="f036" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">它通过填充强制左操作数与右操作数长度相同。这可能是一个可行的解决方案，但是:</p><ol class=""><li id="13f8" class="ma mb hi ix b iy iz jc jd jg mc jk md jo me js mf mg mh mi bi translated">它看起来不干净。它可能会在代码审查中引起一些人的注意，并且可能保证一个“WTF”。</li><li id="80fe" class="ma mb hi ix b iy mj jc mk jg ml jk mm jo mn js mf mg mh mi bi translated">我关注的是<code class="du ls lt lu lj b">String.slice</code>的实现。是常数时间算法吗？还是取决于输入大小？<br/>我还没有查看 NodeJS 内部来验证。</li></ol></div><div class="ab cl ju jv gp jw" role="separator"><span class="jx bw bk jy jz ka"/><span class="jx bw bk jy jz ka"/><span class="jx bw bk jy jz"/></div><div class="hb hc hd he hf"><h1 id="d772" class="kb kc hi bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated">我提议的解决方案</h1><p id="c6b6" class="pw-post-body-paragraph iv iw hi ix b iy kz ja jb jc la je jf jg lb ji jj jk lc jm jn jo ld jq jr js hb bi translated">哈希两者和<code class="du ls lt lu lj b">timingSafeEqual</code>的密码。</p><pre class="le lf lg lh fd li lj lk ll aw lm bi"><span id="db10" class="ln kc hi lj b fi lo lp l lq lr">const hash = crypto.createHash('sha512');<br/>if (crypto.timingSafeEqual(<br/>  hash.copy().update(req.body.apiKey).digest(),<br/>  hash.copy().update(expectedApiKey).digest()<br/>)) {<br/>  // Authorize access<br/>} else {<br/>  response.status(401).send('unauthorized');<br/>}</span></pre><p id="3e06" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们使用的好的散列函数有一些属性:</p><ul class=""><li id="cc0c" class="ma mb hi ix b iy iz jc jd jg mc jk md jo me js mo mg mh mi bi translated">对于每一对函数调用，如果明文相同，那么密文也相同。这样我们可以比较密码，并且知道明文是相同的当且仅当密码是相同的。</li><li id="378e" class="ma mb hi ix b iy mj jc mk jg ml jk mm jo mn js mo mg mh mi bi translated">该函数的输出总是相同的大小(以位为单位)。<br/>这样，<code class="du ls lt lu lj b">timingSafeEqual</code>的两个输入大小相同。</li><li id="340f" class="ma mb hi ix b iy mj jc mk jg ml jk mm jo mn js mo mg mh mi bi translated">不管输入是什么，函数都做同样多的工作。<br/>这意味着它不会泄露计时信息。</li></ul><p id="be8b" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这里有一个额外的好处:不用在源代码或环境变量中以纯文本的形式存储 API 键，而是可以存储它的散列。即使有人可以访问您的源代码或环境变量，他们也很难弄清楚 API 密钥。这是因为好的散列函数的另一个特性:</p><ul class=""><li id="abcc" class="ma mb hi ix b iy iz jc jd jg mc jk md jo me js mo mg mh mi bi translated">给定明文，计算它的匹配密文在计算上是便宜的。<br/>给定密文，计算它的匹配明文的计算代价非常高。</li></ul></div></div>    
</body>
</html>