<html>
<head>
<title>Implement custom validators using JSR based validations [Java 8/Spring]</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用基于 JSR 的验证实现定制验证器[Java 8/Spring]</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/implement-custom-validators-using-jsr-based-validations-java-8-spring-f06920877916?source=collection_archive---------0-----------------------#2018-06-08">https://medium.com/nerd-for-tech/implement-custom-validators-using-jsr-based-validations-java-8-spring-f06920877916?source=collection_archive---------0-----------------------#2018-06-08</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/331a8dfd31ee9c9f18e550a11306d3c9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NpiGr57KeKevnYGUvRiwwQ.jpeg"/></div></div></figure><p id="e17a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">最近，在我们的项目中，我们要求<strong class="is hj"> <em class="jo">处理客户端作为 JSON 响应从 UI 发送的 Java 模型</em> </strong>中的字段验证。</p><p id="e98f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">出于演示的目的，让我们将 sampleDto 作为我们的模型对象。它看起来有点像这样</p><pre class="jp jq jr js fd jt ju jv jw aw jx bi"><span id="b1c2" class="jy jz hi ju b fi ka kb l kc kd">@Getter<br/>@Setter<br/>public class SampleDto {</span><span id="a5b5" class="jy jz hi ju b fi ke kb l kc kd">    public Integer sampleInteger;<br/>    public String sampleString;<br/>    public List&lt;Integer&gt; sampleList;</span><span id="3023" class="jy jz hi ju b fi ke kb l kc kd">}</span></pre><p id="f22a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">相当简单。注意,<a class="ae kf" rel="noopener" href="/@ricardoespsanto/lombok-31997912dd88"> Lombok </a>用于@Getter @Setter 注释，这是为了强调简洁。考虑一个典型的 MVC 类型架构。这个<strong class="is hj"> <em class="jo"> dto/model </em> </strong>将作为 JSON 响应从用户传入。使用<a class="kg kh ge" href="https://medium.com/u/94144f041644?source=post_page-----f06920877916--------------------------------" rel="noopener" target="_blank"> Postman </a>，让我们构造请求体。</p><pre class="jp jq jr js fd jt ju jv jw aw jx bi"><span id="b02f" class="jy jz hi ju b fi ka kb l kc kd">{<br/> "sampleInteger": 171,<br/> "sampleString": "VALID",<br/> "sampleList": [1,2, 3]<br/> }</span></pre><p id="a183" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">为了映射传入的 post 请求，让我们构建一个非常简单的控制器，其端点名为<strong class="is hj"> test/me </strong>。只是最基本的。</p><pre class="jp jq jr js fd jt ju jv jw aw jx bi"><span id="5feb" class="jy jz hi ju b fi ka kb l kc kd"><a class="ae kf" href="http://twitter.com/RestController" rel="noopener ugc nofollow" target="_blank">@RestController</a><br/><a class="ae kf" href="http://twitter.com/RequestMapping" rel="noopener ugc nofollow" target="_blank">@RequestMapping</a>("test")<br/>public class SampleController {</span><span id="9abc" class="jy jz hi ju b fi ke kb l kc kd"><a class="ae kf" href="http://twitter.com/PostMapping" rel="noopener ugc nofollow" target="_blank">@PostMapping</a>("me")<br/> public void testMe(@RequestBody SampleDto sampleDto) {</span><span id="a678" class="jy jz hi ju b fi ke kb l kc kd">      //...our validation logic goes here<br/> }</span></pre></div><div class="ab cl ki kj gp kk" role="separator"><span class="kl bw bk km kn ko"/><span class="kl bw bk km kn ko"/><span class="kl bw bk km kn"/></div><div class="hb hc hd he hf"><p id="a2f8" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在进入业务需求。比方说，我们要验证<strong class="is hj">要求 A) <em class="jo">每个被传递的字符串是否都必须是大写字母<br/> </em> </strong>如果条件不满足，我们抛出一个异常并停止执行。</p><p id="ebcd" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们如何实现这一目标？有很多方法可以做到这一点。想想天真的方法</p><pre class="jp jq jr js fd jt ju jv jw aw jx bi"><span id="de42" class="jy jz hi ju b fi ka kb l kc kd">public void testMe(@RequestBody SampleDto sampleDto) {<br/>    if (null != sampleDto.getSampleString()) {<br/>         //handle null<br/>    }</span><span id="d2d4" class="jy jz hi ju b fi ke kb l kc kd">    if (sampleDto.getSampleString().chars().mapToObj(i -&gt; (char) <br/>           i).noneMatch(Character::isLowerCase)) {<br/>        //handle all upper case<br/>    }<br/>}</span></pre><p id="cc64" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这里没有什么特别的，只是检查字符串是否不为空，并且没有出现任何小写字符。</p><h1 id="66a4" class="kp jz hi bd kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll bi translated">瞧啊。它工作了。</h1><p id="577d" class="pw-post-body-paragraph iq ir hi is b it lm iv iw ix ln iz ja jb lo jd je jf lp jh ji jj lq jl jm jn hb bi translated">现在我们已经处理了需求，甚至没有意识到我们已经用业务级验证搞乱了控制器逻辑，我们应该感到自豪。正当我们高兴的时候，客户又提出了一个要求。</p><p id="a99a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">要求 B)样本整数的大小必须在 7–71 之间</strong></p><p id="36ea" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们花了一些时间，很快意识到这是大约 3-4 行代码的额外工作。</p><blockquote class="lr ls lt"><p id="3031" class="iq ir jo is b it iu iv iw ix iy iz ja lu jc jd je lv jg jh ji lw jk jl jm jn hb bi translated">我们甚至将我们的验证逻辑隔离到不同的函数中，以加强关注点的分离。</p></blockquote><pre class="jp jq jr js fd jt ju jv jw aw jx bi"><span id="4df5" class="jy jz hi ju b fi ka kb l kc kd">public void testMe(@RequestBody @Valid SampleDto sampleDto) {<br/>    if (isValid(sampleDto)) {<br/>       //continue<br/>    }</span><span id="7bcd" class="jy jz hi ju b fi ke kb l kc kd">    else {<br/>        //handle errors<br/>    }<br/>}</span><span id="d243" class="jy jz hi ju b fi ke kb l kc kd">private boolean isValid(SampleDto sampleDto) {<br/>     if (null != sampleDto.getSampleString()) {<br/>           return false;<br/>     }</span><span id="b05a" class="jy jz hi ju b fi ke kb l kc kd">     if (sampleDto.getSampleString().chars().mapToObj(i -&gt; (char)   <br/>         i).noneMatch(Character::isLowerCase)) {<br/>          return false;<br/>     }</span><span id="2881" class="jy jz hi ju b fi ke kb l kc kd">     if (null != sampleDto.getSampleInteger()) {<br/>          return false;<br/>     }</span><span id="f838" class="jy jz hi ju b fi ke kb l kc kd">     if (sampleDto.getSampleInteger() &gt;= 7 &amp;&amp; <br/>        sampleDto.getSampleInteger() &lt;= 71) {<br/>          return false;<br/>     }<br/>     return true;<br/>}</span></pre><p id="7a49" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">令人惊讶的是，现在我们可以在验证到来时处理单独的验证。此外，我们的控制器逻辑委托验证逻辑。</p><p id="23e4" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">客户看到你陶醉在自己的荣耀中，突然拿出一个。</p><p id="1df7" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj"> <em class="jo"> C)用户输入的样本整数必须是质数</em> </strong></p><blockquote class="lx"><p id="58fa" class="ly lz hi bd ma mb mc md me mf mg jn dx translated">现在，我们开始注意到目前为止我们的方法存在的问题。</p></blockquote><ul class=""><li id="f3f6" class="mh mi hi is b it mj ix mk jb ml jf mm jj mn jn mo mp mq mr bi translated">我们正在处理许多 iff 和 else。</li><li id="8c58" class="mh mi hi is b it ms ix mt jb mu jf mv jj mw jn mo mp mq mr bi translated">我们到底应该把验证函数放在哪里？我们说的是独立包装吗？这个功能的范围是什么？谁能说呢？</li><li id="02a3" class="mh mi hi is b it ms ix mt jb mu jf mv jj mw jn mo mp mq mr bi translated">我们应该为其他 dto 设置单独的验证功能吗？我们说的是多少人？</li><li id="4e05" class="mh mi hi is b it ms ix mt jb mu jf mv jj mw jn mo mp mq mr bi translated"><em class="jo">如果一个模型字段有五个验证，</em>这是否意味着我们需要在一个函数中放入五个不同的逻辑块？如果有五个不同的成员呢？</li><li id="5d58" class="mh mi hi is b it ms ix mt jb mu jf mv jj mw jn mo mp mq mr bi translated">如果<em class="jo">我想对一些 dto 进行验证，而不是对其他 dto 进行验证</em>，那该如何操作呢？</li></ul><p id="6b25" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">显然，我们陷入了一个难题。随着项目规模的增长，我们的挫折感也随之而来。</p><h1 id="676f" class="kp jz hi bd kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll bi translated">输入 JAVA Bean 验证/JSR</h1><p id="4427" class="pw-post-body-paragraph iq ir hi is b it lm iv iw ix ln iz ja jb lo jd je jf lp jh ji jj lq jl jm jn hb bi translated">当然，在大多数应用程序中，验证用户输入是一个非常常见的需求，Java Bean 验证框架已经成为处理这种逻辑的事实上的标准。</p><p id="5d52" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj"> JSR 380 </strong>是用于 bean 验证的 Java API 的规范，是 JavaEE 和 JavaSE 的一部分，它确保 bean 的属性满足特定的标准，</p><p id="0f8b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">设置基于 JSR 的注释非常简单。包括对 hibernate-validation(带版本)的依赖，您就可以开始了。</p><pre class="jp jq jr js fd jt ju jv jw aw jx bi"><span id="5e56" class="jy jz hi ju b fi ka kb l kc kd">&lt;dependency&gt;<br/>     &lt;groupId&gt;org.hibernate&lt;/groupId&gt;<br/>     &lt;artifactId&gt;hibernate-validator&lt;/artifactId&gt;    <br/>     &lt;version&gt;${hibernate-validator.version}&lt;/version&gt;<br/>&lt;/dependency&gt;</span></pre><p id="51a1" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">你说，我们如何使用它？</p><p id="4377" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">只需<br/> <strong class="is hj"> <em class="jo"> A:用所需验证类型<br/> <strong class="is hj"> <em class="jo">的注释来注释成员字段</em></strong>B:</em></strong><em class="jo">让 spring 知道必须使用</em><strong class="is hj"><em class="jo">@ Valid annotation</em></strong>来完成验证</p><p id="090c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">答:我们的 sampleDto 的整数字段现在得到了改造</strong></p><pre class="jp jq jr js fd jt ju jv jw aw jx bi"><span id="2edc" class="jy jz hi ju b fi ka kb l kc kd">@NotNull<br/>@Range(min = 7, max = 71, message = "Size has to be between 7-71")<br/>public Integer sampleInteger;</span></pre><p id="37e6" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">@Range 和@NotNull 是内置的验证器。让我们利用它，而不是重新发明轮子。请注意，如果验证失败，我们也可以传入自定义消息。</p><p id="2b4b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在，考虑“尺寸≤ 71 &amp;尺寸≥7”是我们测试的唯一约束。我们的控制器逻辑如何被修改？</p><p id="212b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">由于 Spring 支持验证器，我们简单地让我们的方法知道必须使用@Valid 注释来执行验证</p><p id="6883" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj"> B: @Valid 批注<br/> </strong>根据 Docs，<em class="jo"> @Valid 标记一个属性、方法参数或方法返回类型，用于验证级联。当验证属性、方法参数或方法返回类型时，验证对象及其属性上定义的约束。这种行为是递归应用的。</em></p><p id="1ff6" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这对我们很重要。现在我们可以随时随地进行验证。</p><pre class="jp jq jr js fd jt ju jv jw aw jx bi"><span id="8ba1" class="jy jz hi ju b fi ka kb l kc kd"><a class="ae kf" href="http://twitter.com/PostMapping" rel="noopener ugc nofollow" target="_blank">@PostMapping</a>(“me”)<br/> public void testMe(@RequestBody<strong class="ju hj"> @Valid</strong> SampleDto sampleDto) {<br/>     //...our business logic goes here<br/> }</span></pre><p id="4401" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">请注意<strong class="is hj">@有效的</strong>注释。现在我们要接受验证了。但是默认情况下，如果验证失败，Spring 不会做任何事情。没有人捕捉到异常。<strong class="is hj">无声无息地失败了。这绝对不是我们想要的。</strong></p><p id="65a3" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">为了显式地捕捉它，我们需要传递一个类型为<strong class="is hj"><em class="jo">binding result</em></strong><em class="jo">的接口:一个表示绑定结果的<br/>通用接口。扩展了错误注册功能的接口，允许应用验证器，并添加了特定于绑定的分析和模型构建。</em></p><p id="90a6" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们分别处理纠错。此外，该方法已被修改为返回一个字符串，以便我们可以获得它作为一个响应。</p><figure class="jp jq jr js fd ij er es paragraph-image"><div class="er es mx"><img src="../Images/2f3be7bdd9801f8a139f883fca087200.png" data-original-src="https://miro.medium.com/v2/resize:fit:1188/format:webp/1*b8f8Ejj0nKJeFryoBFJ-mw.png"/></div><figcaption class="my mz et er es na nb bd b be z dx translated">我们改良的控制器</figcaption></figure><p id="f193" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">让我们启动一个来自 POSTMAN 的 post 请求，并看看它是如何工作的。</p><figure class="jp jq jr js fd ij er es paragraph-image"><div class="er es nc"><img src="../Images/27dbf2f8b29b93c150f6edaa6746301f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1126/format:webp/1*FBCjozxHizuMNwVew2bRWA.png"/></div><figcaption class="my mz et er es na nb bd b be z dx translated">我们收到我们的信息作为回应</figcaption></figure><p id="d593" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">当我们的 sampleInteger 完全符合约束条件时会发生什么？即在 7–71 之间。我们去看看。</p><figure class="jp jq jr js fd ij er es paragraph-image"><div class="er es nd"><img src="../Images/2f4e6e77826e2136c83481a2ced06eb9.png" data-original-src="https://miro.medium.com/v2/resize:fit:630/format:webp/1*O2TcK9MLO66IN-zYGeK2Qg.png"/></div></figure><h1 id="c362" class="kp jz hi bd kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll bi translated">平稳。</h1><p id="6877" class="pw-post-body-paragraph iq ir hi is b it lm iv iw ix ln iz ja jb lo jd je jf lp jh ji jj lq jl jm jn hb bi translated">我们的验证运行良好。一切都在正确的位置。没有整洁的控制器，除了我们可以使用控制器建议处理的绑定结果部分。没问题。</p><p id="ccfc" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">让我们解决房间里的大象，好吗？<br/> <strong class="is hj">自定义验证呢？</strong></p><p id="7495" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如果默认情况下没有实现，我如何处理字符串大写检查。</p></div><div class="ab cl ki kj gp kk" role="separator"><span class="kl bw bk km kn ko"/><span class="kl bw bk km kn ko"/><span class="kl bw bk km kn"/></div><div class="hb hc hd he hf"><p id="0932" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">欢迎来到文章的最后部分。如果你能走到这一步，真了不起。我们正在实现基于自定义 JSR 的注释，同时意识到我们为什么需要这样做，以及我们的替代方案是什么。</p><p id="9e43" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">让我们来处理“<strong class="is hj">字符串大写检查</strong>”。让我们遵循一些步骤。</p><ul class=""><li id="3b46" class="mh mi hi is b it iu ix iy jb ne jf nf jj ng jn mo mp mq mr bi translated">用自定义注释修饰所需的字段。我们将很快创建它。</li></ul><pre class="jp jq jr js fd jt ju jv jw aw jx bi"><span id="82dc" class="jy jz hi ju b fi ka kb l kc kd">@NotNull()<br/>@StringUpperCase()<br/>public String sampleString;</span></pre><p id="ab90" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们将自定义注释命名为:<strong class="is hj"> StringUpperCase。</strong>让我们创建它</p><ul class=""><li id="b5fa" class="mh mi hi is b it iu ix iy jb ne jf nf jj ng jn mo mp mq mr bi translated">我们使用@interface 符号创建一个注释。为方便起见，让我们放入一个单独的包，比如说 com . medium . log in . validation . constraints</li></ul><pre class="jp jq jr js fd jt ju jv jw aw jx bi"><span id="6c05" class="jy jz hi ju b fi ka kb l kc kd">@Constraint(validatedBy = "StringUpperCaseValidator.class"<br/>public @interface  StringUpperCase{<br/>}</span></pre><figure class="jp jq jr js fd ij er es paragraph-image"><div class="er es nh"><img src="../Images/50de83059cd1de6c5975c96e55a912c9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1224/format:webp/1*61RQY6jMYEhQpGf1nwVj8g.png"/></div><figcaption class="my mz et er es na nb bd b be z dx translated">约束有效注释</figcaption></figure><p id="133f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这是一个非常简单的注释，有一个运行时范围。我们的目标要么是一个字段，要么是一个参数，这是我们适当指定的。我们注意到以下情况:</p><p id="b01f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj"> @constraint </strong>:包含该约束<br/> <strong class="is hj">的验证逻辑的类，当违反约束<br/> <strong class="is hj">时会生成</strong>消息，验证 api 使用</strong>组。我们不要碰它。<br/><strong class="is hj">payload:</strong>Spring 用来处理代理。我们也不要碰它</p><p id="c507" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">很好，一旦我们声明了注释，我们需要为它创建一个验证器。当然，这是有道理的。这个注释如何知道它的验证逻辑是什么？</p><ul class=""><li id="0cb3" class="mh mi hi is b it iu ix iy jb ne jf nf jj ng jn mo mp mq mr bi translated">最后一步，让我们在一个单独的包中创建验证逻辑。比方说<br/><em class="jo">com . medium . log in . validation . validator .</em>建议创建一个单独的包。这是加强模块化的原因。更改验证逻辑不应涉及控制器的更改。</li></ul><pre class="jp jq jr js fd jt ju jv jw aw jx bi"><span id="233c" class="jy jz hi ju b fi ka kb l kc kd">public class StringUpperCaseValidator implements  <br/>             ConstraintValidator&lt;StringUpperCase, String&gt;{<br/>   <br/>   @Overrride<br/>   public boolean isValid(String val, ConstraintValidatorContext c){<br/>   }<br/>}</span></pre><figure class="jp jq jr js fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ni"><img src="../Images/a22eaeb18c9b8f5add5aff29baa0e5ee.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pdhV7ZmdWWPSaL9XIzoj8A.png"/></div></div><figcaption class="my mz et er es na nb bd b be z dx translated">约束验证器逻辑</figcaption></figure><p id="9da4" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们实现了验证库提供给我们的 constraintValidator 接口。请注意，我们引用了之前创建的注释<strong class="is hj"> "StringUpperCase" </strong>，并指定我们正在验证一个字符串。它可以是任何对象。</p><p id="51be" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这里只有一种方法是最重要的。<br/>你猜对了，是<strong class="is hj"> isValid()。</strong>你会意识到<strong class="is hj">是有效的</strong>方法的逻辑类似于我们在简单实现时的逻辑。</p><h1 id="9f0a" class="kp jz hi bd kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll bi translated">就是这样。我们完了。我们做到了。</h1><p id="aa5e" class="pw-post-body-paragraph iq ir hi is b it lm iv iw ix ln iz ja jb lo jd je jf lp jh ji jj lq jl jm jn hb bi translated">最后，让我们验证它是否有效。</p><figure class="jp jq jr js fd ij er es paragraph-image"><div class="er es nj"><img src="../Images/8699e804ad16df6968f8e5156ec6d0a4.png" data-original-src="https://miro.medium.com/v2/resize:fit:858/format:webp/1*JdvvBVlOo7ZEroY6xj3t3A.png"/></div><figcaption class="my mz et er es na nb bd b be z dx translated">当以大写字母键入时，所有约束都得到满足。</figcaption></figure><p id="865d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">既然这样，让我们加入一个单元测试。</p><pre class="jp jq jr js fd jt ju jv jw aw jx bi"><span id="9ac3" class="jy jz hi ju b fi ka kb l kc kd">@Test<br/>public void sampleStringNotUpperCaseTest() {<br/>      SampleDto sampleDto = new SampleDto();<br/>      sampleDto.setSampleList(new ArrayList(Arrays.asList(1,2,3)));<br/>      sampleDto.setSampleString("FAIL");<br/>      sampleDto.setSampleInteger(23);</span><span id="13fa" class="jy jz hi ju b fi ke kb l kc kd">      // test string as invalid: not in uppercase<br/>      Set&lt;ConstraintViolation&lt;SampleDto&gt;&gt; violations = <br/>             this.validator.validate(sampleDto);</span><span id="26c5" class="jy jz hi ju b fi ke kb l kc kd">      assertEquals(1, violations.size());<br/>}</span></pre><h2 id="d9ad" class="jy jz hi bd kq nk nl nm ku nn no np ky jb nq nr lc jf ns nt lg jj nu nv lk nw bi translated">这就把我们带到了文章的结尾。所有的验证逻辑都在单独的包中，我们可以随时强制执行，不会干扰 MVC 逻辑。</h2><p id="dfd9" class="pw-post-body-paragraph iq ir hi is b it lm iv iw ix ln iz ja jb lo jd je jf lp jh ji jj lq jl jm jn hb bi translated">为了对控制器隐藏 bindingResults 参数，我们可以设置一个控制器通知。我很快会写这方面的内容。</p><p id="3940" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如果你喜欢这篇文章，请鼓掌并分享给其他人。<br/>祝您愉快。</p></div></div>    
</body>
</html>