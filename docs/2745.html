<html>
<head>
<title>Effective &amp; Readable Unit Testing With Junit5</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用Junit5进行有效且可读的单元测试</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/effective-readable-unit-testing-with-junit5-c8e5d9579af5?source=collection_archive---------14-----------------------#2021-05-18">https://medium.com/nerd-for-tech/effective-readable-unit-testing-with-junit5-c8e5d9579af5?source=collection_archive---------14-----------------------#2021-05-18</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/bd9f195d8f9cd1cf4b92641a901147c7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LOQ1AB4Ln6AJwbUWFSuwyQ.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">如何用junit5编写可读的单元测试</figcaption></figure><p id="bd49" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">上周我不得不在Arimac做技术演讲，我想用书面媒体分享内容。</p><p id="2d84" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">这些就是我要在这里讨论的新特性。</p><ul class=""><li id="cefd" class="jt ju hi iw b ix iy jb jc jf jv jj jw jn jx jr jy jz ka kb bi translated">显示名称</li><li id="b83f" class="jt ju hi iw b ix kc jb kd jf ke jj kf jn kg jr jy jz ka kb bi translated">组断言</li><li id="b415" class="jt ju hi iw b ix kc jb kd jf ke jj kf jn kg jr jy jz ka kb bi translated">条件测试</li><li id="81f2" class="jt ju hi iw b ix kc jb kd jf ke jj kf jn kg jr jy jz ka kb bi translated">参数化测试(更新)</li><li id="3d4b" class="jt ju hi iw b ix kc jb kd jf ke jj kf jn kg jr jy jz ka kb bi translated">动态测试</li><li id="933a" class="jt ju hi iw b ix kc jb kd jf ke jj kf jn kg jr jy jz ka kb bi translated">嵌套测试</li></ul><p id="2c14" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">在这里，我们将讨论一些如何在Junit中编写有效测试的特性&amp;我们将讨论的另一个方面是可读性。</p><h2 id="162b" class="kh ki hi bd kj kk kl km kn ko kp kq kr jf ks kt ku jj kv kw kx jn ky kz la lb bi translated">设置</h2><p id="7ccd" class="pw-post-body-paragraph iu iv hi iw b ix lc iz ja jb ld jd je jf le jh ji jj lf jl jm jn lg jp jq jr hb bi translated">要在java项目中设置Junit5，您需要<a class="ae js" href="https://www.oracle.com/java/technologies/javase/javase-jdk8-downloads.html" rel="noopener ugc nofollow" target="_blank"> <strong class="iw hj"> java 1.8 </strong> </a> &amp;以上版本</p><p id="aa77" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">对于我的设置，我已经创建了<a class="ae js" href="https://github.com/sajith4u/junit5-demo" rel="noopener ugc nofollow" target="_blank">示例项目</a>。首先，我们必须添加junit-jupiter-engine作为依赖项。</p><pre class="lh li lj lk fd ll lm ln lo aw lp bi"><span id="28b6" class="kh ki hi lm b fi lq lr l ls lt">&lt;<strong class="lm hj">dependency</strong>&gt;<br/>    &lt;<strong class="lm hj">groupId</strong>&gt;org.junit.jupiter&lt;/<strong class="lm hj">groupId</strong>&gt;<br/>    &lt;<strong class="lm hj">artifactId</strong>&gt;junit-jupiter-engine&lt;/<strong class="lm hj">artifactId</strong>&gt;<br/>    &lt;<strong class="lm hj">version</strong>&gt;5.7.1&lt;/<strong class="lm hj">version</strong>&gt;<br/>    &lt;<strong class="lm hj">scope</strong>&gt;test&lt;/<strong class="lm hj">scope</strong>&gt;<br/>&lt;/<strong class="lm hj">dependency</strong>&gt;</span></pre><h2 id="1096" class="kh ki hi bd kj kk kl km kn ko kp kq kr jf ks kt ku jj kv kw kx jn ky kz la lb bi translated">显示名称</h2><p id="f63e" class="pw-post-body-paragraph iu iv hi iw b ix lc iz ja jb ld jd je jf le jh ji jj lf jl jm jn lg jp jq jr hb bi translated">在运行时，显示名称有助于提高测试用例的可读性。</p><p id="ab38" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">使用的注释</p><pre class="lh li lj lk fd ll lm ln lo aw lp bi"><span id="93b5" class="kh ki hi lm b fi lq lr l ls lt">@DisplayName</span></pre><p id="253f" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">示例:</p><pre class="lh li lj lk fd ll lm ln lo aw lp bi"><span id="034b" class="kh ki hi lm b fi lq lr l ls lt">@Test<br/>@DisplayName(<strong class="lm hj">"Check Assertion Display Name"</strong>)<br/><strong class="lm hj">void </strong>testSimpleAssertion() {<br/>    <em class="lu">assertEquals</em>(1, 1);<br/>}</span></pre><p id="c2c1" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">视角</p><figure class="lh li lj lk fd ij er es paragraph-image"><div class="er es lv"><img src="../Images/33d94e904832104ecaad5d28770b9cc6.png" data-original-src="https://miro.medium.com/v2/resize:fit:818/format:webp/1*PPt4HIP-QPGFF8WL9P6cKg.png"/></div></figure><h2 id="9660" class="kh ki hi bd kj kk kl km kn ko kp kq kr jf ks kt ku jj kv kw kx jn ky kz la lb bi translated">组断言</h2><p id="c7da" class="pw-post-body-paragraph iu iv hi iw b ix lc iz ja jb ld jd je jf le jh ji jj lf jl jm jn lg jp jq jr hb bi translated">组断言的主要优点是它有助于一次运行多个检查，如果出现一个错误，它不会阻塞。</p><p id="12e4" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">让我们先看看我们在六月的表现。</p><pre class="lh li lj lk fd ll lm ln lo aw lp bi"><span id="4498" class="kh ki hi lm b fi lq lr l ls lt">@Test<br/>@DisplayName(<strong class="lm hj">"Junit 4 Way To Run Multiple Tests"</strong>)<br/><strong class="lm hj">void </strong>testOldList() {<br/><br/>    <strong class="lm hj">final </strong>BMICalculatorService bmiCalculatorService = <strong class="lm hj">new </strong>BMICalculatorService();<br/><br/>    <strong class="lm hj">float </strong>bmi1 = bmiCalculatorService.calculateBMI(55, 161);<br/>    <strong class="lm hj">float </strong>bmi2 = bmiCalculatorService.calculateBMI(75, 161);<br/>    <strong class="lm hj">float </strong>bmi3 = bmiCalculatorService.calculateBMI(65, 135);<br/><br/>    <em class="lu">assertEquals</em>(UserCategory.<strong class="lm hj"><em class="lu">NORMAL</em></strong>, bmiCalculatorService.getUserCategory(bmi1));<br/>    <em class="lu">assertEquals</em>(UserCategory.<strong class="lm hj"><em class="lu">OVER_WEIGHT</em></strong>, bmiCalculatorService.getUserCategory(bmi2));<br/>    <em class="lu">assertEquals</em>(UserCategory.<strong class="lm hj"><em class="lu">OBESE</em></strong>, bmiCalculatorService.getUserCategory(bmi3));<br/>}</span></pre><p id="8857" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">这里的问题是，如果第二个断言失败，它将不会继续检查第三种情况。</p><figure class="lh li lj lk fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lw"><img src="../Images/fadfd83562ba95dc64374a536edd98c7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zabj6UHLq9lW0fT6-DOuAw.png"/></div></div></figure><p id="4401" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">然后我们在6月5日做同样的事情</p><pre class="lh li lj lk fd ll lm ln lo aw lp bi"><span id="1a40" class="kh ki hi lm b fi lq lr l ls lt">@Test<br/>@DisplayName(<strong class="lm hj">"BMI Calculator"</strong>)<br/><strong class="lm hj">void </strong>testMBICalculator() {<br/><br/>    <strong class="lm hj">final </strong>BMICalculatorService bmiCalculatorService = <strong class="lm hj">new </strong>BMICalculatorService();<br/>    <strong class="lm hj">final float </strong>bmi1 = bmiCalculatorService.calculateBMI(55, 161);<br/>    <strong class="lm hj">float </strong>bmi2 = bmiCalculatorService.calculateBMI(75, 161);<br/><br/>    Assertions.<em class="lu">assertAll</em>(() -&gt; <em class="lu">assertEquals</em>(UserCategory.<strong class="lm hj"><em class="lu">NORMAL</em></strong>, bmiCalculatorService.getUserCategory(bmi1)),<br/>            () -&gt; <em class="lu">assertEquals</em>(UserCategory.<strong class="lm hj"><em class="lu">NORMAL</em></strong>, bmiCalculatorService.getUserCategory(bmi2)), <br/>            () -&gt; <em class="lu">assertEquals</em>(UserCategory.<strong class="lm hj"><em class="lu">OVER_WEIGHT</em></strong>, bmiCalculatorService.getUserCategory(bmi2)));<br/>}</span></pre><p id="4a90" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">这是第二次断言失败时的结果。如果断言中途失败，它将执行第三次。</p><figure class="lh li lj lk fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lx"><img src="../Images/57174460dbdc3411c0375be5069a6ac1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ci-r5WsphwSp1EtdtNfzOA.png"/></div></div></figure><h2 id="8152" class="kh ki hi bd kj kk kl km kn ko kp kq kr jf ks kt ku jj kv kw kx jn ky kz la lb bi translated">条件测试</h2><p id="b1aa" class="pw-post-body-paragraph iu iv hi iw b ix lc iz ja jb ld jd je jf le jh ji jj lf jl jm jn lg jp jq jr hb bi translated">当我们编写单元测试时，我们必须根据条件运行一些逻辑。因此，我们可以由junit自己来做，而不是在程序级别检查条件。</p><figure class="lh li lj lk fd ij er es paragraph-image"><div class="er es ly"><img src="../Images/14e38ed51889fc4ee773a5ea05350a06.png" data-original-src="https://miro.medium.com/v2/resize:fit:1354/format:webp/1*UXaahkKM0rRX8SGhpYePxA.png"/></div></figure><p id="7479" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">如果条件失败，它将不会执行测试用例。</p><figure class="lh li lj lk fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lz"><img src="../Images/0e031be1b6ab47af222ff8e2d7a30f2d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*avmQMT0mQB2WV7WDb_NiGw.png"/></div></div></figure><h2 id="ad3a" class="kh ki hi bd kj kk kl km kn ko kp kq kr jf ks kt ku jj kv kw kx jn ky kz la lb bi translated">参数化测试</h2><p id="8d29" class="pw-post-body-paragraph iu iv hi iw b ix lc iz ja jb ld jd je jf le jh ji jj lf jl jm jn lg jp jq jr hb bi translated">junit 4中出现了参数化测试，但是在junit 5中，在编写测试用例时有很多改进。<strong class="iw hj"><em class="lu">@ parameterized Test</em></strong>是<strong class="iw hj"> @ <em class="lu"> Test </em> </strong>注释的子测试，因此不需要同时放置两个注释。</p><figure class="lh li lj lk fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ma"><img src="../Images/fe775077e49b5bf58103a026823e486e.png" data-original-src="https://miro.medium.com/v2/resize:fit:966/format:webp/1*15o1UwgsnOcJgEKXz53qGw.png"/></div></div></figure><figure class="lh li lj lk fd ij er es paragraph-image"><div class="er es mb"><img src="../Images/c8d416c5defc35b11485369a5e074c6f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1214/format:webp/1*aCrvCoan2xK1KlbYQOcPEA.png"/></div></figure><p id="ab75" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">以上两个测试案例解释了我们如何使用多个参数来检查断言。最大的好处是那些参数值给对象类型。读取支持的参数转换<a class="ae js" href="https://junit.org/junit5/docs/current/user-guide/#writing-tests-parameterized-tests-argument-conversion" rel="noopener ugc nofollow" target="_blank">类型</a></p><h2 id="b9c9" class="kh ki hi bd kj kk kl km kn ko kp kq kr jf ks kt ku jj kv kw kx jn ky kz la lb bi translated">动态测试</h2><p id="0c8b" class="pw-post-body-paragraph iu iv hi iw b ix lc iz ja jb ld jd je jf le jh ji jj lf jl jm jn lg jp jq jr hb bi translated">这是我认为junit5将提供的最好的特性。原因是我们可以动态地创建测试用例，这有助于在流中进行测试。</p><figure class="lh li lj lk fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mc"><img src="../Images/b3005b92348f547062c19d62702b0304.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*f06-1JbLArGHCx-cVU6FUQ.png"/></div></div></figure><p id="8dff" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">在这里，当员工的流列表，它将创建动态测试，并给出结果。我们必须确保测试结果需要返回DynamicTest的Stream、Collection、Iterable、Iterator。</p><figure class="lh li lj lk fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es md"><img src="../Images/f2851f175408d9ce3f211fd998f6229d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NgwBTNupFWtZH2exuQK68A.png"/></div></div></figure><h2 id="b76e" class="kh ki hi bd kj kk kl km kn ko kp kq kr jf ks kt ku jj kv kw kx jn ky kz la lb bi translated">嵌套测试</h2><p id="d139" class="pw-post-body-paragraph iu iv hi iw b ix lc iz ja jb ld jd je jf le jh ji jj lf jl jm jn lg jp jq jr hb bi translated">Netsted测试有助于以更可读的方式编写单元测试。如果我们的类包含大量的测试用例，那么我们可以使用嵌套测试来组织测试。</p><p id="ced3" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">例如:</p><pre class="lh li lj lk fd ll lm ln lo aw lp bi"><span id="1fd7" class="kh ki hi lm b fi lq lr l ls lt">@DisplayName(<strong class="lm hj">"Nested Test Example"</strong>)<br/><strong class="lm hj">class </strong>NetstedExampleTest {<br/><br/>    @Test<br/>    @DisplayName(<strong class="lm hj">"Test1"</strong>)<br/>    <strong class="lm hj">void </strong>testDemo() {<br/>        <em class="lu">assertEquals</em>(1, 1);<br/>    }<br/><br/><br/>    @Test<br/>    @DisplayName(<strong class="lm hj">"Test2"</strong>)<br/>    <strong class="lm hj">void </strong>testLogic2() {<br/>        <em class="lu">assertEquals</em>(1, 1);<br/>    }<br/><br/><br/>    @Nested<br/>    @DisplayName(<strong class="lm hj">"Inner Class"</strong>)<br/>    <strong class="lm hj">class </strong>InnerLogicTest {<br/><br/>        @Test<br/>        @DisplayName(<strong class="lm hj">"Layer1"</strong>)<br/>        <strong class="lm hj">void </strong>testLogic2() {<br/>            <em class="lu">assertEquals</em>(1, 1);<br/>        }<br/><br/><br/>        @Nested<br/>        @DisplayName(<strong class="lm hj">"Layer One Class"</strong>)<br/>        <strong class="lm hj">class </strong>LayerOneTest {<br/><br/>            @Test<br/>            @DisplayName(<strong class="lm hj">"Layer2"</strong>)<br/>            <strong class="lm hj">void </strong>testLogic2() {<br/>                <em class="lu">assertEquals</em>(1, 1);<br/>            }<br/>        }<br/>    }<br/><br/>}</span></pre><p id="6d4d" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">像这种方式很容易阅读。</p><figure class="lh li lj lk fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es me"><img src="../Images/3366033c0ad7c6b321d22ca72c46be3d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GM4okngnOlnhoPKZghbdeQ.png"/></div></div></figure><p id="e175" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">仅此而已。这些代码示例可在<a class="ae js" href="https://github.com/sajith4u/junit5-demo" rel="noopener ugc nofollow" target="_blank">这里</a>获得</p></div></div>    
</body>
</html>