<html>
<head>
<title>How default parameters could cause Havoc— Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">默认参数如何造成混乱 Python</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/how-default-parameters-could-cause-havoc-python-e6cb3d8fefb8?source=collection_archive---------18-----------------------#2021-07-19">https://medium.com/nerd-for-tech/how-default-parameters-could-cause-havoc-python-e6cb3d8fefb8?source=collection_archive---------18-----------------------#2021-07-19</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="7bd4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这篇文章是我根据自己的亲身经历写的。很多时候，由于 python 中默认参数的奇怪行为，我被困了几个小时。这就是我这篇文章要分享的内容。</p><h2 id="361b" class="jd je hi bd jf jg jh ji jj jk jl jm jn iq jo jp jq iu jr js jt iy ju jv jw jx bi translated">什么是默认参数？</h2><p id="2906" class="pw-post-body-paragraph if ig hi ih b ii jy ik il im jz io ip iq ka is it iu kb iw ix iy kc ja jb jc hb bi translated">默认参数是具有默认值的参数，在调用函数时可以选择传递这些参数。如果在没有参数的情况下调用函数，参数将被赋予默认值。</p><pre class="kd ke kf kg fd kh ki kj kk aw kl bi"><span id="0a32" class="jd je hi ki b fi km kn l ko kp">def callPerson(name='guest'):<br/> print(f'hello {name}')</span></pre><p id="6a37" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果您调用该函数，</p><pre class="kd ke kf kg fd kh ki kj kk aw kl bi"><span id="a76e" class="jd je hi ki b fi km kn l ko kp">&gt;&gt; callPerson('saravana') #  hello saravana</span><span id="bb55" class="jd je hi ki b fi kq kn l ko kp">&gt;&gt; <strong class="ki hj">callPerson() #  hello guest</strong></span></pre><p id="a453" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这是默认参数的工作方式，</p><ul class=""><li id="1c80" class="kr ks hi ih b ii ij im in iq kt iu ku iy kv jc kw kx ky kz bi translated">你给它传递一个值，它全心全意地接受并使用它。</li><li id="8adf" class="kr ks hi ih b ii la im lb iq lc iu ld iy le jc kw kx ky kz bi translated">如果你没有传递任何值，它不会抱怨，它会使用它所拥有的值。</li></ul></div><div class="ab cl lf lg gp lh" role="separator"><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk"/></div><div class="hb hc hd he hf"><figure class="kd ke kf kg fd ln er es paragraph-image"><div role="button" tabindex="0" class="lo lp di lq bf lr"><div class="er es lm"><img src="../Images/6c6c8a4a8805057dc43d2cc3fe2b94c3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KpfR6fnFnClOYPEiu1IojQ.jpeg"/></div></div><figcaption class="lu lv et er es lw lx bd b be z dx translated">照片由<a class="ae ly" href="https://unsplash.com/@messrro?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">迈赫迪</a>在<a class="ae ly" href="https://unsplash.com/s/photos/bomb?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄</figcaption></figure><p id="e94f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">那么默认参数有什么问题呢？</strong></p><p id="ab49" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">默认参数本身没有任何问题。当它被赋予一个<strong class="ih hj">可变对象时，比如</strong>、<strong class="ih hj">列表、字典、集合、</strong>或任何<strong class="ih hj">用户定义的类。</strong></p><blockquote class="lz"><p id="3af8" class="ma mb hi bd mc md me mf mg mh mi jc dx translated">使用可变对象作为默认参数值可能会导致混乱</p></blockquote><p id="104d" class="pw-post-body-paragraph if ig hi ih b ii mj ik il im mk io ip iq ml is it iu mm iw ix iy mn ja jb jc hb bi translated">如你所知，可变对象可以改变，变异。</p><pre class="kd ke kf kg fd kh ki kj kk aw kl bi"><span id="f7a1" class="jd je hi ki b fi km kn l ko kp">myList = [1,2,3]  # list - mutable<br/>myList[0] = 10    # Fine✌</span><span id="16d8" class="jd je hi ki b fi kq kn l ko kp">myTuple = (1,2,3) # tuple- immutable<br/><strong class="ki hj">myTuple[0] = 10   # ERROR🚫</strong></span></pre><p id="13ab" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在让我们看看为什么不应该在默认参数中使用可变对象。</p><p id="c877" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">先说个例子。</p><pre class="kd ke kf kg fd kh ki kj kk aw kl bi"><span id="bc7e" class="jd je hi ki b fi km kn l ko kp">&gt;&gt;&gt; def buyStuff(item,<strong class="ki hj">alreadyBought=[]</strong>):<br/>          alreadyBought.append(item)<br/>          print('You bought ',alreadyBought)</span><span id="bc4f" class="jd je hi ki b fi kq kn l ko kp">&gt;&gt;&gt; buyStuff('apple',['mango','jackfruit'])<br/>You bought  ['mango', 'jackfruit', 'apple']   #fine</span><span id="69b8" class="jd je hi ki b fi kq kn l ko kp">&gt;&gt;&gt; buyStuff('apple')<br/>You bought  ['apple']                         #this is also fine</span><span id="d7bb" class="jd je hi ki b fi kq kn l ko kp">&gt;<strong class="ki hj">&gt;&gt; buyStuff('apple')<br/>You bought  ['apple', 'apple']</strong>           #Wait, free apple?</span></pre><p id="8419" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们只想要一个苹果，但是有人给了我们两个苹果，而且也没有人出价🤔</p><p id="5d25" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">去理解为什么会发生这种情况？我们必须首先了解默认参数是如何工作的。</p><blockquote class="lz"><p id="e8b3" class="ma mb hi bd mc md me mf mg mh mi jc dx translated">Python 的默认参数在函数被定义时被评估一次，而不是每次函数被调用时</p></blockquote><ul class=""><li id="2993" class="kr ks hi ih b ii mj im mk iq ms iu mt iy mu jc kw kx ky kz bi translated">第一次用<code class="du mo mp mq ki b"><strong class="ih hj">alreadyBought=[] </strong></code>定义函数时，<code class="du mo mp mq ki b">alreadyBought </code>变量开始指向一个空列表。</li></ul><figure class="kd ke kf kg fd ln er es paragraph-image"><div role="button" tabindex="0" class="lo lp di lq bf lr"><div class="er es mv"><img src="../Images/c7670da2cd8a7d9e53fe7fa51f09d052.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CkH7FRqVNlcMXoUuUuSxFQ.png"/></div></div><figcaption class="lu lv et er es lw lx bd b be z dx translated">指向空列表的已备份变量</figcaption></figure><ul class=""><li id="2868" class="kr ks hi ih b ii ij im in iq kt iu ku iy kv jc kw kx ky kz bi translated">当你向它添加数据时。它会变成，</li></ul><figure class="kd ke kf kg fd ln er es paragraph-image"><div role="button" tabindex="0" class="lo lp di lq bf lr"><div class="er es mw"><img src="../Images/ef43931fc7358905c5a12d67aa827231.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OyHBo1Z6OQqajVxMOph5aA.png"/></div></div><figcaption class="lu lv et er es lw lx bd b be z dx translated">将元素追加到列表后。</figcaption></figure><ul class=""><li id="3cd8" class="kr ks hi ih b ii ij im in iq kt iu ku iy kv jc kw kx ky kz bi translated">由于<strong class="ih hj"> <em class="mx">已经购买的变量总是指向那个列表</em> </strong>，相同的列表每次都被重用，这就是为什么我们会得到那个奇怪的行为。</li></ul><h2 id="9a7b" class="jd je hi bd jf jg jh ji jj jk jl jm jn iq jo jp jq iu jr js jt iy ju jv jw jx bi translated">如何避免这种情况？</h2><ol class=""><li id="aa54" class="kr ks hi ih b ii jy im jz iq my iu mz iy na jc nb kx ky kz bi translated">尝试用相应的不可变对象替换可变对象。</li></ol><pre class="kd ke kf kg fd kh ki kj kk aw kl bi"><span id="bccb" class="jd je hi ki b fi km kn l ko kp">list() -&gt; <strong class="ki hj">tuple()</strong><br/>set()  -&gt; <strong class="ki hj">frozenset()<br/></strong>dict() -&gt; <a class="ae ly" href="https://pypi.org/project/frozendict/" rel="noopener ugc nofollow" target="_blank"><strong class="ki hj">frozendict(</strong></a><strong class="ki hj">)</strong></span></pre><p id="df81" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">2.但是上述方法并不总是优选的。如果我们真的想要一个可变的呢？</p><p id="8fab" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们能做的最安全的事情是在函数定义中将<code class="du mo mp mq ki b"><strong class="ih hj">None </strong></code>赋给默认参数，并在函数中为其赋可变值。</p><pre class="kd ke kf kg fd kh ki kj kk aw kl bi"><span id="0499" class="jd je hi ki b fi km kn l ko kp">&gt;&gt; def buyStuff(item,alreadyBought=None):<br/>      <strong class="ki hj">if not alreadyBought:<br/>           alreadyBought = []</strong><br/>      alreadyBought.append(item)<br/>      print(‘You bought ‘,alreadyBought)</span><span id="637f" class="jd je hi ki b fi kq kn l ko kp">&gt;&gt;&gt; buyStuff(‘apple’)<br/><strong class="ki hj">You bought [‘apple’]<br/></strong>&gt;&gt;&gt; buyStuff(‘apple’)<br/><strong class="ki hj">You bought [‘apple’]</strong></span></pre><p id="3eee" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在，每次我们调用不带<code class="du mo mp mq ki b">alreadyBought </code>参数的函数时，我们将在函数中显式地给它分配一个空列表。但可悲的是我们只收到了一个苹果🍎 ☹.</p><h2 id="239e" class="jd je hi bd jf jg jh ji jj jk jl jm jn iq jo jp jq iu jr js jt iy ju jv jw jx bi translated">世界上的每一个人都是有福的！！</h2><p id="5893" class="pw-post-body-paragraph if ig hi ih b ii jy ik il im jz io ip iq ka is it iu kb iw ix iy kc ja jb jc hb bi translated">默认参数中的可变对象也不例外。在某些情况下，我们可以利用奇怪的行为(不再奇怪)。</p><blockquote class="nc nd ne"><p id="a484" class="if ig mx ih b ii ij ik il im in io ip nf ir is it ng iv iw ix nh iz ja jb jc hb bi translated">有时，您可以专门“利用”(阅读:按预期使用)这种行为来维护函数调用之间的状态。这通常是在编写缓存函数时完成的。— <a class="ae ly" href="https://docs.python-guide.org/writing/gotchas/" rel="noopener ugc nofollow" target="_blank">文档</a></p></blockquote><pre class="kd ke kf kg fd kh ki kj kk aw kl bi"><span id="01ca" class="jd je hi ki b fi km kn l ko kp"># ith fibbonaci number using dynamic programming</span><span id="bbde" class="jd je hi ki b fi kq kn l ko kp">def fibbonaci(i,<strong class="ki hj">memo={0:0,1:1}</strong>):<br/> if memo.get(i)!=None:<br/>       return memo[i]<br/> memo[i] = fibbonaci(i-1)+fibbonaci(i-2)<br/> return memo[i]</span></pre><p id="a625" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如你所见，我们不想在每个调用中都传递<code class="du mo mp mq ki b">memo</code>字典，它是在默认参数中为我们维护的。</p></div><div class="ab cl lf lg gp lh" role="separator"><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk"/></div><div class="hb hc hd he hf"><p id="9ef5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我希望下次你知道，当你得到那个<code class="du mo mp mq ki b"><em class="mx">extra apple🍏</em></code>时该做什么。感谢您的阅读。拍手声👏如果你学到了新东西。如果你想了解更多，请阅读这篇文章。</p></div></div>    
</body>
</html>