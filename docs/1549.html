<html>
<head>
<title>Graph Traversal in Python: Depth First Search (DFS)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python中的图遍历:深度优先搜索(DFS)</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/graph-traversal-in-python-depth-first-search-dfs-ce791f48af5b?source=collection_archive---------6-----------------------#2021-03-25">https://medium.com/nerd-for-tech/graph-traversal-in-python-depth-first-search-dfs-ce791f48af5b?source=collection_archive---------6-----------------------#2021-03-25</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="65ad" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">深度优先搜索(DFS)或深度优先遍历(DFT)是另一种基本的图算法，类似于前面讨论的<a class="ae jd" href="https://mb-miaobin.medium.com/graph-traversal-in-python-breadth-first-search-bfs-b6cff138d516" rel="noopener"> BFS或</a>BFT。唯一的、微小的区别是深度优先算法尽可能地进入更深层次的节点。</p><p id="2bb7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">例如，在与BFS从节点“A”开始的情况相同的情况下，DFS转到“B”，然后是“D”和“E”、“F”。然后是C。但是为什么它扫描“D”之后是“E”，arn”和“D”不是一个级别的？这是因为“D”没有更多的子节点连接。该算法返回到“B”并寻找“B”的子节点，也就是“E”。注意“E”有一个子节点“F”，它也是“C”的子节点。它可能会被扫描两次，我们需要稍后处理它。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es je"><img src="../Images/5992ec571721bb27b0844c557ba51301.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XrcHohQ0kjyBhYIMk8NNlg.png"/></div></div></figure><p id="ee24" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">要在代码中实现它，我们需要找到一种方法来确保“深度优先”的顺序。具有“后进先出”原则的堆栈可能有助于实现这一点。如下图所示:我们将第一个节点放入并弹出，用“B”和“C”交换“A ”,但为了保持从左到右的扫描，我们将其反转为“C”和“B ”,将它们推入堆栈。下一轮我们弹出“B”并交换“B”的子节点，依此类推。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div class="er es jq"><img src="../Images/a783ae33942ed5bf6045fce6aecf29c6.png" data-original-src="https://miro.medium.com/v2/resize:fit:730/format:webp/1*4wse0l6sfx7Jx5-_ftYuhA.png"/></div></figure><p id="e027" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">python中的图形以字典的形式表示，因此您可以使用键来检索值。在我们的示例中，我们插入“A”来检索“B”和“C”。</p><pre class="jf jg jh ji fd jr js jt ju aw jv bi"><span id="72cb" class="jw jx hi js b fi jy jz l ka kb">graph={<br/> ‘A’:[‘B’,’C’],<br/> ‘B’:[‘D’,’E’],<br/> ‘C’:[‘F’],<br/> ‘D’:[],<br/> ‘E’:[‘F’],<br/> ‘F’:[]<br/>}<br/>graph[‘A’]<br/># this should gives you ['B','C']</span></pre><p id="a125" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">上面的图形式的代码是这样的如下(注意有方向):</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div class="er es kc"><img src="../Images/c09bff380c29ea4d90624794f4f67ded.png" data-original-src="https://miro.medium.com/v2/resize:fit:694/format:webp/1*Alxy0bGB9TTI1qTzdzr0uA.png"/></div></figure><p id="6913" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为了与我们之前的<a class="ae jd" href="https://mb-miaobin.medium.com/graph-traversal-in-python-breadth-first-search-bfs-b6cff138d516" rel="noopener"> BFS </a>实现进行比较，我们以BFS风格对DFS进行编码。除了“队列”结构和“堆栈”结构略有不同之外，所有变量的名称和位置都是相同的。正如我们在<a class="ae jd" href="https://mb-miaobin.medium.com/graph-traversal-in-python-breadth-first-search-bfs-b6cff138d516" rel="noopener">上一篇文章</a>中解释的，“队列”是为了确保“先进先出”原则，以便广度搜索在下一级节点搜索之前完全完成。另一方面,“堆栈”更喜欢使用新插入的元素，以便实现深度优先搜索。</p><pre class="jf jg jh ji fd jr js jt ju aw jv bi"><span id="a1dc" class="jw jx hi js b fi jy jz l ka kb">def dfs(graph,node):<br/>    <br/>    # node is the starting position<br/>    # graph is the graph in dictionary format<br/>    visited=[]<br/>    queue=[]<br/>    <br/>    queue.append(node)<br/>    visited.append(node)<br/>    <br/>    while queue:<br/>        s=queue.pop()<br/>        print(s)<br/>        for x in graph[s][::-1]:<br/>            if x not in visited:<br/>                visited.append(x)<br/>                queue.append(x)</span></pre><p id="75bc" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们测试一些例子:</p><pre class="jf jg jh ji fd jr js jt ju aw jv bi"><span id="879e" class="jw jx hi js b fi jy jz l ka kb">graph={<br/>    'A':['B','C'],<br/>    'B':['D','E'],<br/>    'C':['F'],<br/>    'D':[],<br/>    'E':['F'],<br/>    'F':[]<br/>}<br/>dfs(graph,'A')<br/># this will return the sequence of A,B,D,E,F,C</span></pre><p id="ba0b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">另一个例子是:</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div class="er es kd"><img src="../Images/f4a6e722b9a31571b4709de9af7f3cf7.png" data-original-src="https://miro.medium.com/v2/resize:fit:656/format:webp/1*PjID3mTEoZ5HuyzKnHde1Q.png"/></div></figure><pre class="jf jg jh ji fd jr js jt ju aw jv bi"><span id="8fdd" class="jw jx hi js b fi jy jz l ka kb">graph={<br/>    'A':['C','E'],<br/>    'B':[],<br/>    'C':['B','G'],<br/>    'D':[],<br/>    'E':['H'],<br/>    'H':['D'],<br/>    'G':[]<br/>}<br/>dfs(graph,'A')<br/># this will return the sequence of A,C,B,G,E,H,D</span></pre><p id="3c9e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这个链接使用递归方法来搜索深度，这在编码上更简单，但是理解起来有点棘手，特别是当你不熟悉递归编程的时候。我们将在以后的文章中解释对递归方法的理解。</p><div class="ke kf ez fb kg kh"><a href="https://www.educative.io/edpresso/how-to-implement-depth-first-search-in-python" rel="noopener  ugc nofollow" target="_blank"><div class="ki ab dw"><div class="kj ab kk cl cj kl"><h2 class="bd hj fi z dy km ea eb kn ed ef hh bi translated">如何在Python中实现深度优先搜索</h2><div class="ko l"><h3 class="bd b fi z dy km ea eb kn ed ef dx translated">如何在Python中实现深度优先搜索</h3></div><div class="kp l"><p class="bd b fp z dy km ea eb kn ed ef dx translated">如何在Pythonwww.educative.io中实现深度优先搜索</p></div></div><div class="kq l"><div class="kr l ks kt ku kq kv jo kh"/></div></div></a></div></div></div>    
</body>
</html>