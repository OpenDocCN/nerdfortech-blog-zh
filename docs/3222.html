<html>
<head>
<title>React Lifecycle Methods Cheat Sheet</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">React生命周期方法备忘单</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/react-lifecycle-methods-cheat-sheet-77c20a3199c9?source=collection_archive---------6-----------------------#2021-06-02">https://medium.com/nerd-for-tech/react-lifecycle-methods-cheat-sheet-77c20a3199c9?source=collection_archive---------6-----------------------#2021-06-02</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/fcffe12f447296276c956fb574233fa0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*udmccBKtJxyWNmcOnumuVw.gif"/></div></div></figure><p id="e312" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">React.js是少数几个，但这就是为什么cheat sheets受到赞赏。</p><figure class="jp jq jr js fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es jo"><img src="../Images/ca840886520954db442def4644dcfd06.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-amlrLaPx2GcIPBwHH9pWg.png"/></div></div><figcaption class="jt ju et er es jv jw bd b be z dx translated">不包括静态方法</figcaption></figure><p id="5da5" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在我的采访中，我几次被问到React生命周期，所以看起来生命周期方法很受欢迎。</p><p id="00bf" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我只包括了那些更常见的。</p><h1 id="b136" class="jx jy hi bd jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku bi translated">什么是生命周期？</h1><p id="7d22" class="pw-post-body-paragraph iq ir hi is b it kv iv iw ix kw iz ja jb kx jd je jf ky jh ji jj kz jl jm jn hb bi translated">对象在其存在过程中经历不同的事件:创建、更新和删除。React的生命周期方法允许开发人员在对象生命周期的特定时间操作该对象。要使用生命周期方法，您必须使用React类组件。然后，只需在类中定义方法。</p><pre class="jp jq jr js fd la lb lc ld aw le bi"><span id="feec" class="lf jy hi lb b fi lg lh l li lj">import React, { Component } from ‘react’<br/>import fetchAnimes from '../actions/fetchAnimes'</span><span id="4f7f" class="lf jy hi lb b fi lk lh l li lj">class AnimeContainer extends Component {</span><span id="c887" class="lf jy hi lb b fi lk lh l li lj">   componentDidMount() {<br/>      <strong class="lb hj">this</strong>.props.fetchAnimes()<br/>   }</span><span id="c404" class="lf jy hi lb b fi lk lh l li lj">   render() {<br/>      return (<br/>         &lt;div&gt;<br/>            This method must exist.<br/>         &lt;/div&gt;<br/>      )<br/>    }</span><span id="0a2c" class="lf jy hi lb b fi lk lh l li lj">}</span><span id="1468" class="lf jy hi lb b fi lk lh l li lj">export default connect(null, {fetchAnimes})(AnimeContainer)</span></pre><h1 id="bd21" class="jx jy hi bd jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku bi translated">构造函数()</h1><p id="f344" class="pw-post-body-paragraph iq ir hi is b it kv iv iw ix kw iz ja jb kx jd je jf ky jh ji jj kz jl jm jn hb bi translated">这是React组件将经历的第一个方法。这只会发生一次。只有当您打算改变原始的构造函数方法或者打算设置<code class="du ll lm ln lb b">state</code>时，才需要这个方法。</p><h1 id="65f6" class="jx jy hi bd jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku bi translated">渲染()</h1><p id="1435" class="pw-post-body-paragraph iq ir hi is b it kv iv iw ix kw iz ja jb kx jd je jf ky jh ji jj kz jl jm jn hb bi translated">这是组件首次安装的方式。组件挂载后，每当React的虚拟DOM检测到变化时，就会调用这个方法。</p><p id="f1e3" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这是React类组件中必须存在的一个方法。其他方法都是可选的。该方法必须返回一个JSX元素。</p><h1 id="285d" class="jx jy hi bd jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku bi translated">componentDidMount()</h1><p id="b6da" class="pw-post-body-paragraph iq ir hi is b it kv iv iw ix kw iz ja jb kx jd je jf ky jh ji jj kz jl jm jn hb bi translated">因为一个组件只能挂载一次，所以这个方法只被调用一次，也就是组件被成功挂载的时候。通常，<code class="du ll lm ln lb b">fetch</code>请求是用这种方法发出的。</p><h1 id="4ace" class="jx jy hi bd jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku bi translated"><strong class="ak">shouldcomponentdupdate()</strong></h1><p id="7fc1" class="pw-post-body-paragraph iq ir hi is b it kv iv iw ix kw iz ja jb kx jd je jf ky jh ji jj kz jl jm jn hb bi translated">也许你不想让React在每一个小变化后都重新渲染。您可以使用此方法手动控制组件更新的时间。应该返回一个布尔值。</p><h1 id="2faa" class="jx jy hi bd jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku bi translated">componentDidUpdate()</h1><p id="b465" class="pw-post-body-paragraph iq ir hi is b it kv iv iw ix kw iz ja jb kx jd je jf ky jh ji jj kz jl jm jn hb bi translated">当您希望将更新发送到另一个库或者希望更新触发另一个事件时，可以使用此方法。</p><h1 id="0afb" class="jx jy hi bd jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku bi translated">componentWillUnmount()</h1><p id="11e4" class="pw-post-body-paragraph iq ir hi is b it kv iv iw ix kw iz ja jb kx jd je jf ky jh ji jj kz jl jm jn hb bi translated">这个方法在组件被卸载之前被调用。如果您有每隔几秒钟就发生的后台获取请求，这是您可以停止它们的方法。</p></div><div class="ab cl lo lp gp lq" role="separator"><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt"/></div><div class="hb hc hd he hf"><p id="2588" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">还有一些其他的方法，比如<code class="du ll lm ln lb b">getSnapshotBeforeUpdate</code>和<code class="du ll lm ln lb b">static getDerivedStateFromProps()</code>，但是当我第一次开始学习React时，它们只是增加了我的困惑。</p></div></div>    
</body>
</html>