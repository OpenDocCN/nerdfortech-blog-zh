<html>
<head>
<title>Getting better production code by reducing noise in tests</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">通过减少测试中的噪音获得更好的产品代码</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/getting-better-production-code-by-reducing-noise-in-tests-88e65f82ad4f?source=collection_archive---------11-----------------------#2021-03-20">https://medium.com/nerd-for-tech/getting-better-production-code-by-reducing-noise-in-tests-88e65f82ad4f?source=collection_archive---------11-----------------------#2021-03-20</a></blockquote><div><div class="dt gx gy gz ha hb"/><div class="hc hd he hf hg"><div class=""/><figure class="ew ey ih ii ij ik es et paragraph-image"><div role="button" tabindex="0" class="il im di in bf io"><div class="es et ig"><img src="../Images/75426c2592bd643c4c54bfc551236cd0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zE4kH3Ph-wXre0Vp3rkkRg.jpeg"/></div></div><figcaption class="ir is eu es et it iu bd b be z dy translated">有时很难看到测试树后面的产品代码。照片来自个人收藏</figcaption></figure><p id="04d9" class="pw-post-body-paragraph iv iw hj ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hc bi translated">您是否注意到，有时您需要编写大量的测试代码，只是为了验证生产逻辑的某些非常具体的部分？</p><p id="790c" class="pw-post-body-paragraph iv iw hj ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hc bi translated">当我自己遇到这种情况时，我的第一反应是隐藏所有这些无趣的细节。例如，通过在测试代码中引入工厂方法或构建器。通常这确实已经足够好了。然而，在以这种方式清理测试之前，最好考虑一下是否不是产品代码需要清理。</p><blockquote class="jt ju jv"><p id="0089" class="iv iw jw ix b iy iz ja jb jc jd je jf jx jh ji jj jy jl jm jn jz jp jq jr js hc bi translated">关注因子低的测试是设计糟糕的产品代码的标志。</p></blockquote><p id="cd51" class="pw-post-body-paragraph iv iw hj ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hc bi translated">这里的焦点因素是对测试行为真正重要的代码和所有测试代码之间的比率。</p><h1 id="08c0" class="ka kb hj bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated">示例—初始迭代</h1><p id="d5d2" class="pw-post-body-paragraph iv iw hj ix b iy ky ja jb jc kz je jf jg la ji jj jk lb jm jn jo lc jq jr js hc bi translated">不久前，我们的团队需要优化从关系数据库中删除过期报价的流程。为了解决索引碎片问题，我们决定按月对数据进行分区，并用过期数据截断整个分区(而不是逐个删除记录)。</p><p id="a994" class="pw-post-body-paragraph iv iw hj ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hc bi translated">我们最初的测试(用Groovy和<a class="ae ld" href="http://spockframework.org/" rel="noopener ugc nofollow" target="_blank">斯波克</a>编写)看起来像这样:</p><pre class="le lf lg lh fe li lj lk ll aw lm bi"><span id="7e55" class="ln kb hj lj b fj lo lp l lq lr">class DeleteExpiredQuotesSpec extends Specification {</span><span id="8739" class="ln kb hj lj b fj ls lp l lq lr">  QuotesRepository quotes = new QuotesJdbcRepository(...)</span><span id="ec38" class="ln kb hj lj b fj ls lp l lq lr">  def "deletes quotes that were created 1 month before the previous month"() {<br/>    given:<br/>    def quote1 = aQuote().id(id1).createdAt("2008-01-01T11:11:11Z"). build()<br/>    def quote2 = aQuote().id(id2).createdAt("2008-02-31T11:11:11Z"). build()<br/>    def quote3 = aQuote().id(id3).createdAt("2008-03-02T11:11:11Z"). build()</span><span id="1403" class="ln kb hj lj b fj ls lp l lq lr">    quotes.add(quote1)<br/>    quotes.add(quote2)<br/>    quotes.add(quote3)</span><span id="1624" class="ln kb hj lj b fj ls lp l lq lr">    when:    <br/>    def now = Instant.parse("2008-03-28T13:11:11Z")<br/>    quotes.deleteExpired(now)</span><span id="770a" class="ln kb hj lj b fj ls lp l lq lr">    then:<br/>    !quotes.contains(quote1.id)<br/>    quotes.contains(quote2.id)<br/>    quotes.contains(quote3.id)<br/>  }</span><span id="ed99" class="ln kb hj lj b fj ls lp l lq lr">}</span></pre><p id="c847" class="pw-post-body-paragraph iv iw hj ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hc bi translated">该测试验证两件事:</p><ul class=""><li id="4796" class="lt lu hj ix b iy iz jc jd jg lv jk lw jo lx js ly lz ma mb bi translated">我们能删除数据吗？</li><li id="c6b9" class="lt lu hj ix b iy mc jc md jg me jk mf jo mg js ly lz ma mb bi translated">我们删除了正确的数据吗？</li></ul><p id="1f3d" class="pw-post-body-paragraph iv iw hj ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hc bi translated">当当前月份是二月，我们需要删除前一年12月创建的报价时，我们的逻辑还能工作吗？没问题——我们可以添加另一个测试。</p><p id="a24a" class="pw-post-body-paragraph iv iw hj ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hc bi translated">可以进行测试来验证我们的存储库是否删除了报价。然而，现在我们有两个测试贯穿整个过程，这样我们就可以验证一个特定的细节——找到要删除的正确分区。</p><p id="14a2" class="pw-post-body-paragraph iv iw hj ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hc bi translated">如果我们只想验证是否找到了正确的分区，那么这些测试中有很多东西并不是很有趣。下面是同样的测试，其中重要代码用粗体标记:</p><pre class="le lf lg lh fe li lj lk ll aw lm bi"><span id="2e58" class="ln kb hj lj b fj lo lp l lq lr">given:<br/>def quote1 = <strong class="lj hk">aQuote</strong>().id(id1).<strong class="lj hk">createdAt</strong>("2008-<strong class="lj hk">01</strong>-01T11:11:11Z"). build()<br/>def quote2 = <strong class="lj hk">aQuote</strong>().id(id2).<strong class="lj hk">createdAt</strong>("2008-<strong class="lj hk">02</strong>-31T11:11:11Z"). build()<br/>def quote3 = <strong class="lj hk">aQuote</strong>().id(id3).<strong class="lj hk">createdAt</strong>("2008-<strong class="lj hk">03</strong>-02T11:11:11Z"). build()</span><span id="4968" class="ln kb hj lj b fj ls lp l lq lr"><strong class="lj hk">quotes</strong>.<strong class="lj hk">add</strong>(<strong class="lj hk">quote1</strong>)<br/><strong class="lj hk">quotes</strong>.<strong class="lj hk">add</strong>(<strong class="lj hk">quote2</strong>)<br/><strong class="lj hk">quotes</strong>.<strong class="lj hk">add</strong>(<strong class="lj hk">quote3</strong>)</span><span id="8051" class="ln kb hj lj b fj ls lp l lq lr">when:    <br/>def <strong class="lj hk">now</strong> = Instant.parse("2008-<strong class="lj hk">03</strong>-28T13:11:11Z")<br/><strong class="lj hk">quotes</strong>.<strong class="lj hk">deleteExpired</strong>(<strong class="lj hk">now</strong>)</span><span id="2f53" class="ln kb hj lj b fj ls lp l lq lr">then:<br/><strong class="lj hk">!quotes.contains(quote1</strong>.id<strong class="lj hk">)<br/>quotes.contains(quote2</strong>.id<strong class="lj hk">)<br/>quotes.contains(quote3</strong>.id<strong class="lj hk">)</strong></span></pre><h1 id="5dbd" class="ka kb hj bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated">降低测试中的噪音</h1><p id="873c" class="pw-post-body-paragraph iv iw hj ix b iy ky ja jb jc kz je jf jg la ji jj jk lb jm jn jo lc jq jr js hc bi translated">让我们通过隐藏不重要的东西来简化这个测试:</p><pre class="le lf lg lh fe li lj lk ll aw lm bi"><span id="6dd4" class="ln kb hj lj b fj lo lp l lq lr">given:<br/>def quoteInJan = <strong class="lj hk">addQuoteCreatedIn</strong>(<strong class="lj hk">JANUARY</strong>)<br/>def quoteInFeb = <strong class="lj hk">addQuoteCreatedIn</strong>(<strong class="lj hk">FEBRUARY</strong>)<br/>def quoteInMarch = <strong class="lj hk">addQuoteCreatedIn</strong>(<strong class="lj hk">MARCH</strong>)</span><span id="838e" class="ln kb hj lj b fj ls lp l lq lr"><strong class="lj hk">quotes</strong>.<strong class="lj hk">deleteExpired</strong>(someTimeIn(<strong class="lj hk">MARCH</strong>))</span><span id="5f88" class="ln kb hj lj b fj ls lp l lq lr">expect:<br/><strong class="lj hk">!quotes.contains(quoteInJan)<br/>quotes.contains(quoteInFeb)<br/>quotes.contains(quoteInMarch)</strong></span></pre><p id="0740" class="pw-post-body-paragraph iv iw hj ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hc bi translated">现在更容易看到创建时间的月份部分。然而，如果我们停在这里，我们只是应用了一些化妆品。即使测试现在变得更好了，我们仍然忽略了它试图告诉我们的东西:“产品代码中缺少一些东西”！</p><h1 id="c943" class="ka kb hj bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated">改进生产代码</h1><p id="4f4a" class="pw-post-body-paragraph iv iw hj ix b iy ky ja jb jc kz je jf jg la ji jj jk lb jm jn jo lc jq jr js hc bi translated">测试仍然验证我们在开始时确定的两件事。这是因为在生产代码中没有专门的概念来负责选择正确的分区。</p><p id="38d2" class="pw-post-body-paragraph iv iw hj ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hc bi translated">再来补充一下<code class="dv mh mi mj lj b">ExpiredQuotesCleanupMonth</code>。现在，我们可以编写更加集中的测试，只验证月份/分区的发现:</p><pre class="le lf lg lh fe li lj lk ll aw lm bi"><span id="f14b" class="ln kb hj lj b fj lo lp l lq lr">def "expired quotes cleanup month is 1 month before the previous month"() { <br/>  expect:<br/><strong class="lj hk">  </strong>new <strong class="lj hk">ExpiredQuotesCleanupMonth</strong>(someTimeIn(<strong class="lj hk">MARCH</strong>))<br/>    .value() == <strong class="lj hk">JANUARY<br/></strong>}</span></pre><p id="429f" class="pw-post-body-paragraph iv iw hj ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hc bi translated">这样好多了。现在我们可以重构我们的存储库，使用<code class="dv mh mi mj lj b">ExpiredQuotesCleanupMonth</code>作为参数，而不是<code class="dv mh mi mj lj b">Instant</code>。我们可以将策略(需要截断什么分区)和实现(如何截断分区)分开。</p><p id="9f08" class="pw-post-body-paragraph iv iw hj ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hc bi translated">然而，测试中仍然有一种方法可以隐藏东西— <code class="dv mh mi mj lj b">someTimeIn</code>。让我们利用这个机会让我们的产品代码更有表现力。</p><p id="d3f2" class="pw-post-body-paragraph iv iw hj ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hc bi translated">我们可以引入<code class="dv mh mi mj lj b">CurrentMonth</code>类。它封装了从当前时间中获取月份的一点点逻辑，并不复杂。但是，它增加了一个值，现在只需查看<code class="dv mh mi mj lj b">ExpiredQuotesCleanupMonth</code>构造函数就可以清楚地知道预期的参数是什么——它不仅仅是一个时间瞬间(其中只有月份部分重要)或任何月份，而是当前月份:</p><pre class="le lf lg lh fe li lj lk ll aw lm bi"><span id="6f50" class="ln kb hj lj b fj lo lp l lq lr">new <!-- -->ExpiredQuotesCleanupMonth<!-- -->(new CurrentMonth(MARCH))</span></pre><h1 id="09a7" class="ka kb hj bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated">结果</h1><p id="18a7" class="pw-post-body-paragraph iv iw hj ix b iy ky ja jb jc kz je jf jg la ji jj jk lb jm jn jo lc jq jr js hc bi translated">我们已经使用了测试来移除通用目的类型的使用，取而代之的是引入我们自己的特定领域包装器(<code class="dv mh mi mj lj b">CurrentMonth</code>)。我们还将数据库更新机制(存储库实现)从指定删除标准的策略(<code class="dv mh mi mj lj b">ExpiredQuotesCleanupMonth</code>)中分离出来。</p><p id="ff53" class="pw-post-body-paragraph iv iw hj ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hc bi translated">下面是最终的存储库测试:</p><pre class="le lf lg lh fe li lj lk ll aw lm bi"><span id="9bb6" class="ln kb hj lj b fj lo lp l lq lr">given:<br/>def quoteInJan = <strong class="lj hk">addQuoteCreatedIn</strong>(<strong class="lj hk">JANUARY</strong>)<br/>def quoteInFeb = <strong class="lj hk">addQuoteCreatedIn</strong>(<strong class="lj hk">FEBRUARY</strong>)<br/>def quoteInMarch = <strong class="lj hk">addQuoteCreatedIn</strong>(<strong class="lj hk">MARCH</strong>)</span><span id="b36a" class="ln kb hj lj b fj ls lp l lq lr"><strong class="lj hk">quotes</strong>.<strong class="lj hk">deleteBy</strong>(<br/>  new <strong class="lj hk">ExpiredQuotesCleanupMonth</strong>(new <strong class="lj hk">CurrentMonth</strong>(<strong class="lj hk">MARCH</strong>)))</span><span id="6635" class="ln kb hj lj b fj ls lp l lq lr">expect:<br/><strong class="lj hk">!quotes.contains(quoteInJan)<br/>quotes.contains(quoteInFeb)<br/>quotes.contains(quoteInMarch)</strong></span></pre></div></div>    
</body>
</html>