<html>
<head>
<title>pandas: Find column with min/max value for each row in dataframe</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">熊猫:查找数据帧中每行的最小/最大值列</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/pandas-find-column-with-min-max-value-for-each-row-in-dataframe-a2f2d2b2ea7a?source=collection_archive---------4-----------------------#2021-05-07">https://medium.com/nerd-for-tech/pandas-find-column-with-min-max-value-for-each-row-in-dataframe-a2f2d2b2ea7a?source=collection_archive---------4-----------------------#2021-05-07</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="4f9b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">有时您有多列度量用于一个目的，但是您只想保留根据您的需要执行的那一列。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es jd"><img src="../Images/febbe5e64e5f475b529c1a44919ae9ef.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*Fzizo-31s7PXQKVb.jpg"/></div></div><figcaption class="jp jq et er es jr js bd b be z dx translated"><a class="ae jt" href="https://pixabay.com/photos/entrepreneur-idea-competence-vision-1340649/" rel="noopener ugc nofollow" target="_blank">(来源)</a></figcaption></figure><p id="b16c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在本演示中，我们将分析一个合成聚类模型输出数据集。诀窍在于，我们有到每个聚类中心的距离的列，但没有带有聚类分配本身的列。换句话说，进一步分析模型预测变得很困难。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es ju"><img src="../Images/26f57c42af8c5421b8b3c8b4d76e9179.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Q_33xvJ-6hcJaRVFbq1vlw.png"/></div></div><figcaption class="jp jq et er es jr js bd b be z dx translated">数据帧预览</figcaption></figure><p id="7b8a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">因此，我们有了一个股票数据聚类模型的数据框架。符号、公司、部门、日期和价格列是用于预测的特征。</p><p id="36f4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">模型输出剩余的十列“DistancesToClusterCenter no .”列。这些表示数据点离每个聚类质心有多远。</p><p id="47aa" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">但问题来了。该数据帧不包括具有单个聚类分配的列，仅包括质心距离。我们如何创建一个这样的列？</p><p id="9f3f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">答案是<code class="du jv jw jx jy b">idxmin</code>函数。根据文档中的<a class="ae jt" href="https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.idxmin.html?highlight=idxmin#pandas.DataFrame.idxmin" rel="noopener ugc nofollow" target="_blank">，该函数根据指定的轴返回具有最小值的单元格的索引或列名。我们对具有最小值的列感兴趣，因此我们可以调用:</a></p><pre class="je jf jg jh fd jz jy ka kb aw kc bi"><span id="4d33" class="kd ke hi jy b fi kf kg l kh ki">df["ClusterAssignment"] = df.idxmin(axis="columns")</span></pre><p id="9f31" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这将为每行在新的ClusterAssignment列中保存具有最小值的列。然而，这需要一个调整:只在质心距离列上调用<code class="du jv jw jx jy b">idxmin</code>,而不是所有可用的列。</p><pre class="je jf jg jh fd jz jy ka kb aw kc bi"><span id="7fd6" class="kd ke hi jy b fi kf kg l kh ki">names = [f"DistancesToClusterCenter no.{i}" for i in range(0, 10)]</span><span id="047d" class="kd ke hi jy b fi kj kg l kh ki">df["ClusterAssignment"] = df[names].idxmin(axis="columns")</span></pre><p id="7800" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><code class="du jv jw jx jy b">names</code>是质心距离列的列表。第二个<code class="du jv jw jx jy b">idxmin</code>只在那个子集上被调用，而不是所有的列。这是结果。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es kk"><img src="../Images/cf78823d045a4dba852d6c593a49d77b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FFLvWKP_ip_X9Vlj7mO8eg.png"/></div></div><figcaption class="jp jq et er es jr js bd b be z dx translated">idxmin输出</figcaption></figure><p id="51f4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们可以更进一步，在ClusterAssignment中只保留集群号，而不是完整的列名。</p><pre class="je jf jg jh fd jz jy ka kb aw kc bi"><span id="e27c" class="kd ke hi jy b fi kf kg l kh ki">df["ClusterAssignment"] = df["ClusterAssignment"].map(lambda value: value.split(".")[-1])</span></pre><p id="47b8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">对于每个名称，将字符串拆分为点(。)并保留最后一个子串，即簇号。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es kl"><img src="../Images/d25f68db9b580a2cb08329cccc8a15c9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*z-JRw8iEN68iiXg8H0FxpQ.png"/></div></div><figcaption class="jp jq et er es jr js bd b be z dx translated">已清理的集群分配</figcaption></figure><p id="2ff6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们已经得到了我们想要的，所以我们可以删除质心距离列。谢天谢地，我们已经把它们保存在<code class="du jv jw jx jy b">names</code>列表中，以便于<code class="du jv jw jx jy b">drop</code>呼叫。</p><pre class="je jf jg jh fd jz jy ka kb aw kc bi"><span id="f43b" class="kd ke hi jy b fi kf kg l kh ki">df= df.drop(names, axis="columns")</span></pre><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es km"><img src="../Images/1135f85cbc3c684ac053c9f758ac7316.png" data-original-src="https://miro.medium.com/v2/resize:fit:1376/format:webp/1*WRKSnXjJcQIAKdooMA4dyQ.png"/></div><figcaption class="jp jq et er es jr js bd b be z dx translated">最终数据帧</figcaption></figure><p id="ea0f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们已经达到了所需的数据框架:模型预测的输入要素和聚类。</p><p id="8fcb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">作为一个额外的提示，您可以使用<code class="du jv jw jx jy b">idxmax</code>对具有最大值的列重复这个过程，例如，离数据点最远的质心。</p><pre class="je jf jg jh fd jz jy ka kb aw kc bi"><span id="e830" class="kd ke hi jy b fi kf kg l kh ki">df["MostDistantCluster"] = df[names].idxmax(axis="columns")df["MostDistantCluster"] = df["MostDistantCluster"].map(lambda value: value.split(".")[-1])</span><span id="df35" class="kd ke hi jy b fi kj kg l kh ki">df["MostDistantCluster"] = df["MostDistantCluster"].map(lambda value: value.split(".")[-1])</span></pre><p id="03d3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这将导致这个数据帧。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es kn"><img src="../Images/3481d0178140d937964f5a1ccd91637f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1360/format:webp/1*Yu_DHYUnVx0cPoPbaLUoVA.png"/></div><figcaption class="jp jq et er es jr js bd b be z dx translated">idxmax的结果数据帧</figcaption></figure><p id="58f8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这是这个演示的完整脚本。</p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="ko kp l"/></div><figcaption class="jp jq et er es jr js bd b be z dx translated">为数据帧中的每一行查找具有最大/最小值的列</figcaption></figure></div></div>    
</body>
</html>