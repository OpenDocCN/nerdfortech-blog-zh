<html>
<head>
<title>Python Tortoise ORM Integration with FastAPI</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python乌龟ORM与FastAPI的集成</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/python-tortoise-orm-integration-with-fastapi-c3751d248ce1?source=collection_archive---------0-----------------------#2021-11-19">https://medium.com/nerd-for-tech/python-tortoise-orm-integration-with-fastapi-c3751d248ce1?source=collection_archive---------0-----------------------#2021-11-19</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/17455fd801ae7aea8555cfff51500e00.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DcbZNtVYSq4tt8Fj6b3eug.png"/></div></div></figure><p id="532f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我最喜欢Django的一点是它的ORM这个框架如此受欢迎的原因之一。另一方面，FastAPI没有ORM，只专注于服务端点，与数据库无关。</p><p id="25dc" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">python <em class="jo">有不少ORM选项:Django-alchemy </em>、<em class="jo"> peewee </em>、<em class="jo"> ponyORM、乌龟</em>。后者除了异步之外，还受到了Django ORM的启发，因此其语法非常相似，甚至许多乌龟函数都与它们的Django对应物共享名称，因此使用Django ORM go的用户节省了大量学习乌龟函数的时间。</p><p id="c7db" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在本教程中，我将同时使用fastAPI和tortoise-orm，因此请确保您至少了解fastAPI框架和数据库的基础知识。</p><h1 id="c623" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">乌龟相容性</h1><p id="39e5" class="pw-post-body-paragraph iq ir hi is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hb bi translated">Tortoise支持以下数据库。</p><ul class=""><li id="269e" class="ks kt hi is b it iu ix iy jb ku jf kv jj kw jn kx ky kz la bi translated">PostgreSQL&gt; = 9.4(使用asyncpg)</li><li id="7d9f" class="ks kt hi is b it lb ix lc jb ld jf le jj lf jn kx ky kz la bi translated">SQLite(使用aiosqlite)</li><li id="779b" class="ks kt hi is b it lb ix lc jb ld jf le jj lf jn kx ky kz la bi translated">MySQL / MariaDB(使用aiomysql或asyncmy)</li></ul><p id="c3d1" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">但是对于这个例子，我将使用SQLite，因为它不需要任何配置。</p><figure class="lg lh li lj fd ij"><div class="bz dy l di"><div class="lk ll l"/></div></figure><h1 id="289c" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">Python乌龟ORM安装</h1><p id="9f90" class="pw-post-body-paragraph iq ir hi is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hb bi translated">要安装tortoise-orm，只需使用您选择的虚拟环境管理器，我将使用pipenv。</p><pre class="lg lh li lj fd lm ln lo lp aw lq bi"><span id="5b6d" class="lr jq hi ln b fi ls lt l lu lv"><em class="jo">pipenv install tortoise-orm</em></span></pre><p id="4433" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我还将安装fastAPI和我们将需要的其他实用程序</p><pre class="lg lh li lj fd lm ln lo lp aw lq bi"><span id="b834" class="lr jq hi ln b fi ls lt l lu lv"><em class="jo">pipenv install python-multipart fastapi uvicorn pydantic</em></span></pre><h1 id="ff50" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">用乌龟创建模型</h1><p id="00e8" class="pw-post-body-paragraph iq ir hi is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hb bi translated">我们将创建一个名为app的目录和一个名为<em class="jo"> models.py </em>的模型文件</p><pre class="lg lh li lj fd lm ln lo lp aw lq bi"><span id="ee6a" class="lr jq hi ln b fi ls lt l lu lv"><em class="jo"># app/models.py<br/>from tortoise.models import Model<br/>from tortoise import fields<br/></em></span><span id="09e0" class="lr jq hi ln b fi lw lt l lu lv"><em class="jo">class Job(Model):<br/>    # P</em>rimary key field is created automatically<em class="jo"><br/>    # id = fields.IntField(pk=True) <br/>    name = fields.CharField(max_length=255)<br/>    description = fields.TextField()</em></span><span id="d35f" class="lr jq hi ln b fi lw lt l lu lv"><em class="jo">    def __str__(self):<br/>        return self.name</em></span></pre><p id="d1bb" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如果您注意到语法与Django字段非常相似，甚至一些参数也是相同的。</p><p id="16c1" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">要开始使用乌龟ORM，我们需要:</p><ol class=""><li id="dd8b" class="ks kt hi is b it iu ix iy jb ku jf kv jj kw jn lx ky kz la bi translated">连接到数据库</li><li id="0d5f" class="ks kt hi is b it lb ix lc jb ld jf le jj lf jn lx ky kz la bi translated">创建所需的表</li></ol><h1 id="2a24" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">用Tortoise连接数据库</h1><p id="ca3f" class="pw-post-body-paragraph iq ir hi is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hb bi translated">我们将在名为database的目录中创建一个连接到数据库的函数:</p><pre class="lg lh li lj fd lm ln lo lp aw lq bi"><span id="12fa" class="lr jq hi ln b fi ls lt l lu lv"><em class="jo"># database/connectToDatabase.py<br/>from tortoise import Tortoise</em></span><span id="8d5a" class="lr jq hi ln b fi lw lt l lu lv"><em class="jo">async def connectToDatabase():<br/>    await Tortoise.init(<br/>        db_url='sqlite://db.sqlite3',<br/>        modules={'models': ['app.models']}<br/>    )</em></span></pre><h1 id="be9e" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">使用Tortoise生成示意图</h1><p id="204b" class="pw-post-body-paragraph iq ir hi is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hb bi translated">现在，让我们创建一个函数，在应用程序的根目录下生成模型。</p><pre class="lg lh li lj fd lm ln lo lp aw lq bi"><span id="d28f" class="lr jq hi ln b fi ls lt l lu lv"><em class="jo"># createSchema.py<br/>from tortoise import Tortoise, run_async<br/>from database.connectToDatabase import connectToDatabase</em></span><span id="4165" class="lr jq hi ln b fi lw lt l lu lv"><em class="jo">async def main():<br/>    await connectToDatabase()<br/>    await Tortoise.generate_schemas()</em></span><span id="9556" class="lr jq hi ln b fi lw lt l lu lv"><em class="jo">if __name__ == '__main__':<br/>    run_async(main())</em></span></pre><p id="95b5" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">观察我们如何将刚刚创建的函数导入到connect中，然后调用<em class="jo"> generate_schemas () </em>方法，该方法将负责读取我们的模型并对数据库进行更改。</p><p id="e824" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">另一个你应该理解的方面是，我们在<em class="jo"> run_async () </em>函数中运行main函数，这个函数是由tortoise提供的。这是我们的await函数运行所必需的，否则，只会创建一个<em class="jo"> corroutine </em>对象。</p><p id="9a76" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">为什么我们把这个方法放在一个外部文件中？因为<strong class="is hj"><em class="jo">generate _ schemas()</em>只需要使用一次</strong>；当表被创建时。我们不能将它包含在执行fastAPI时将运行的文件中。</p><p id="8a41" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">知道了这一点，让我们运行它来创建我们的表。</p><pre class="lg lh li lj fd lm ln lo lp aw lq bi"><span id="5ce0" class="lr jq hi ln b fi ls lt l lu lv"><em class="jo">python3 createSchema.py</em></span></pre><p id="7434" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如果一切顺利，我们将在SQLite数据库中创建表。</p><h1 id="386a" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">Tortoise与FastAPI集成</h1><p id="e59d" class="pw-post-body-paragraph iq ir hi is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hb bi translated">我们将从一个简单的fastAPI应用程序开始。</p><p id="5d4b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">要把fastAPI和tortoise联系起来，后者给了我们一个函数叫做<em class="jo"> register_tortosise () </em>。What接收我们用fastAPI创建的实例、数据库的地址以及模型的位置。</p><pre class="lg lh li lj fd lm ln lo lp aw lq bi"><span id="0223" class="lr jq hi ln b fi ls lt l lu lv"><em class="jo"># main.py<br/>from fastapi import FastAPI<br/>from database.connectToDatabase import connectToDatabase</em></span><span id="3fb5" class="lr jq hi ln b fi lw lt l lu lv"><em class="jo">app = FastAPI()<br/>await connectToDatabase()</em></span><span id="bfc7" class="lr jq hi ln b fi lw lt l lu lv"><em class="jo">@app.get("/")<br/>async def read_root():<br/>    return {"Hello": "World"}</em></span><span id="2c79" class="lr jq hi ln b fi lw lt l lu lv"><em class="jo">register_tortoise(<br/>    app,<br/>    db_url="sqlite://db.sqlite3",<br/>    modules={"models": ["app.models"]},<br/>    generate_schemas=True,<br/>    add_exception_handlers=True,<br/>)</em></span></pre><figure class="lg lh li lj fd ij"><div class="bz dy l di"><div class="ly ll l"/></div></figure><h1 id="d245" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">用乌龟创造一个物体</h1><p id="0a79" class="pw-post-body-paragraph iq ir hi is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hb bi translated">要创建一个对象，我们可以选择在一个用我们的实例的<em class="jo"> post () </em>方法修饰的函数内<strong class="is hj">调用模型的<em class="jo"> create () </em>方法，或者我们也可以创建一个实例，然后调用它的<em class="jo"> save () </em>方法。</strong></p><pre class="lg lh li lj fd lm ln lo lp aw lq bi"><span id="b230" class="lr jq hi ln b fi ls lt l lu lv"><em class="jo"># main.py<br/>from fastapi import FastAPI<br/>from tortoise.contrib.fastapi import HTTPNotFoundError, register_tortoise</em></span><span id="5ccd" class="lr jq hi ln b fi lw lt l lu lv"><em class="jo">app = FastAPI()</em></span><span id="f0eb" class="lr jq hi ln b fi lw lt l lu lv"><em class="jo">@app.get("/")<br/>async def read_root():<br/>    return {"Hello": "World"}</em></span><span id="756e" class="lr jq hi ln b fi lw lt l lu lv"><em class="jo">@app.post("/job/create/", status_code=201)<br/>async def create_job(name=Form(...), description=Form(...)):<br/>    job = await Job.create(name=name, description=description)<br/>    return {"status":"ok"}<br/># ...</em></span></pre><p id="7605" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如果我们现在使用fastAPI创建的文档接口发出web请求，在<em class="jo"> / docs / </em>中，我们将看到我们将能够使用名称和描述创建一个作业对象。</p><figure class="lg lh li lj fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lz"><img src="../Images/e6972d8ca83a9e91e7ace239209248a1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*0N98LwbbQdui_YHN.png"/></div></div></figure><h1 id="58e3" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">用Pydantic和Tortoise序列化对象</h1><p id="3009" class="pw-post-body-paragraph iq ir hi is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hb bi translated">我们已经创建了对象，但是如果我们想在创建后返回对象呢？因为它是一个模型的实例，我们不能就这样返回它。对于HTTP响应，我们需要一个合适的数据类型。</p><p id="02bc" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj"> Pydantic允许我们序列化来自数据库的对象，以便能够将它们作为JSON响应</strong>或我们想要的任何内容返回。</p><p id="e089" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">您必须导入<em class="jo"> pydantic_model_creator </em>函数，并将其作为参数传递给我们的模型。</p><pre class="lg lh li lj fd lm ln lo lp aw lq bi"><span id="753c" class="lr jq hi ln b fi ls lt l lu lv"><em class="jo"># main.py<br/>from fastapi import FastAPI<br/>from app.models import Job<br/>from tortoise.contrib.fastapi import HTTPNotFoundError, register_tortoise<br/>from tortoise.contrib.pydantic import pydantic_model_creator</em></span><span id="391e" class="lr jq hi ln b fi lw lt l lu lv"><em class="jo">app = FastAPI()</em></span><span id="65b0" class="lr jq hi ln b fi lw lt l lu lv"><em class="jo">job_pydantic = pydantic_model_creator(Job)</em></span><span id="8368" class="lr jq hi ln b fi lw lt l lu lv"><em class="jo">@app.get("/")<br/>async def read_root():<br/>    return {"Hello": "World"}</em></span><span id="5530" class="lr jq hi ln b fi lw lt l lu lv"><em class="jo">@app.post("/job/create/", status_code=201)<br/>async def create_job(name=Form(...), description=Form(...)):<br/>    job = await Job.create(name=name, description=description)<br/>    return await job_pydantic.from_tortoise_orm(job)</em></span><span id="fc47" class="lr jq hi ln b fi lw lt l lu lv"><em class="jo">register_tortoise(<br/>    app,<br/>    db_url="sqlite://db.sqlite3",<br/>    modules={"models": ["app.models"]},<br/>    add_exception_handlers=True,<br/>)</em></span></pre><p id="cde1" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">为了在JSON中获取我们的对象，我们调用我们刚刚创建的对象的方法<em class="jo"> from_tortoise_orm () </em>。</p><p id="3de1" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">记得在<em class="jo">前加上</em>字<em class="jo">等待</em>，否则你将返回一个<em class="jo">协程</em>。</p><h1 id="3d86" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">从查询集中获取对象列表</h1><p id="e2ad" class="pw-post-body-paragraph iq ir hi is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hb bi translated">我们将使用fastAPI实例的<strong class="is hj"> get () </strong>方法。</p><p id="7cad" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">为了获得对象列表，我们使用了<em class="jo"> all () </em>方法，并用<em class="jo"> from_queryset () </em>序列化结果。</p><pre class="lg lh li lj fd lm ln lo lp aw lq bi"><span id="04f2" class="lr jq hi ln b fi ls lt l lu lv"><em class="jo"># main.py</em></span><span id="b62a" class="lr jq hi ln b fi lw lt l lu lv"><em class="jo"># ...</em></span><span id="48bc" class="lr jq hi ln b fi lw lt l lu lv"><em class="jo">@app.get("/jobs/")<br/>async def get_jobs():<br/>    return await job_pydantic.from_queryset(Job.all())</em></span></pre><figure class="lg lh li lj fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lz"><img src="../Images/38d2a18274bd9833f970c69c8d054058.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*u7vGZq7dgIEkIFVY.png"/></div></div></figure><h1 id="e923" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">用乌龟更新对象</h1><p id="0b37" class="pw-post-body-paragraph iq ir hi is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hb bi translated">现在<strong class="is hj">我们创建一个接收id的端点，并用<em class="jo"> put () </em>方法</strong>进行修饰。我们将job_pydantic对象作为response_model，<a class="ae ma" href="https://fastapi.tiangolo.com/tutorial/response-model/" rel="noopener ugc nofollow" target="_blank">传递，以便它验证数据条目，将其包含在文档中，并将响应限制在可修改的字段</a>。</p><p id="0f48" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们还将创建第二个job_pydantic对象，也就是说，另一个序列化程序，它排除了只读字段(我们的主键),返回没有id的字段。</p><p id="e9ea" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">为了更新一个对象，我们使用fastAPI的put方法并接收要编辑的对象的id。接下来，我们用<em class="jo"> Job.filter () </em>过滤那些匹配id的对象，然后我们调用它的<em class="jo"> update () </em>方法。因为id是唯一的，因为它是主键，所以只有id与我们发送的数据相对应的对象才会被编辑。</p><pre class="lg lh li lj fd lm ln lo lp aw lq bi"><span id="a8c1" class="lr jq hi ln b fi ls lt l lu lv"><em class="jo"># main.py</em></span><span id="0232" class="lr jq hi ln b fi lw lt l lu lv"><em class="jo">job_pydantic = pydantic_model_creator(Job)<br/>job_pydantic_no_ids = pydantic_model_creator(Job, exclude_readonly=True)<br/># ...</em></span><span id="a98a" class="lr jq hi ln b fi lw lt l lu lv"><em class="jo">@app.put("/job/{job_id}", response_model=job_pydantic, responses={404: {"model": HTTPNotFoundError}})<br/>async def update_job(job_id: int, job: job_pydantic):<br/>    await Job.filter(id=job_id).update(**job.dict())<br/>    return await job_pydantic_no_ids.from_queryset_single(Job.get(id=job_id))</em></span></pre><figure class="lg lh li lj fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lz"><img src="../Images/fb72efb48f3e012f9a8743e6e7e55c51.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*qaAWg9bmOWiMqPH5.png"/></div></div></figure><h1 id="e7dd" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">用乌龟得到一个物体</h1><p id="e523" class="pw-post-body-paragraph iq ir hi is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hb bi translated">现在我们可以应用上一节中的相同方法。这一次我们将<strong class="is hj">需要一个id和fastAPI <em class="jo"> get () </em>方法</strong>。我们将<em class="jo"> response_model </em>传递给它，以便它负责验证，并且我们定义我们将使用的唯一参数是id，通过它我们将对ORM查询的结果使用<em class="jo"> from_queryset_single </em>()方法:Job.get <em class="jo"> (id = job_id) </em>。</p><pre class="lg lh li lj fd lm ln lo lp aw lq bi"><span id="a6d5" class="lr jq hi ln b fi ls lt l lu lv"><em class="jo"># main.py</em></span><span id="6a80" class="lr jq hi ln b fi lw lt l lu lv"><em class="jo"># ...</em></span><span id="7924" class="lr jq hi ln b fi lw lt l lu lv"><em class="jo">@app.get("/job/{job_id}", response_model=job_pydantic, responses={404: {"model": HTTPNotFoundError}})<br/>async def get_job(job_id: int):<br/>    return await job_pydantic_no_ids.from_queryset_single(Job.get(id=job_id))</em></span></pre><figure class="lg lh li lj fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lz"><img src="../Images/6f7ba5b19ef175c830fd3455d95cf7d0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*Y2aZRb_DiZLL4Zku.png"/></div></div></figure><h1 id="a5c3" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">删除带有乌龟的对象</h1><p id="c9bd" class="pw-post-body-paragraph iq ir hi is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hb bi translated">要删除一个对象<strong class="is hj">，我们</strong>也<strong class="is hj">需要一个id并调用fastAPI的<em class="jo"> delete () </em>方法</strong>，因此函数如下:</p><pre class="lg lh li lj fd lm ln lo lp aw lq bi"><span id="af03" class="lr jq hi ln b fi ls lt l lu lv"><em class="jo"># main.py<br/>class Status(BaseModel):<br/>    message: str<br/># ...</em></span><span id="eca4" class="lr jq hi ln b fi lw lt l lu lv"><em class="jo">@app.delete("/job/{job_id}", response_model=Status, responses={404: {"model": HTTPNotFoundError}})<br/>async def delete_job(job_id: int):<br/>    deleted_job = await Job.filter(id=job_id).delete()<br/>    if not deleted_job:<br/>        raise HTTPException(status_code=404, detail=f"Job {job_id} not found")<br/>    return Status(message=f"Deleted job {job_id}")</em></span></pre><p id="6cee" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们通过在URL中获得的id进行过滤，如果找到对象，我们就删除它，如果对象的id不存在，我们将通过异常返回404错误。如果是，我们将不再返回对象，但是返回一条消息通知id已被删除就足够了。</p><figure class="lg lh li lj fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lz"><img src="../Images/b19ac345d9ec112de107c84164d52631.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*cbQmg6hIgBk7qO4A.png"/></div></div></figure><p id="c281" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这样，我们就可以使用tortoise作为orm在fastAPI中执行基本的CRUD操作。在这篇文章中，我没有涉及外键、外键字段、多对多或模型之间的其他类型的关系。我将来可能会写一个关于这个的条目，同时，你可以阅读官方的乌龟文档。</p></div></div>    
</body>
</html>