# 关于阵列的快速笔记/小测验

> 原文：<https://medium.com/nerd-for-tech/quick-and-dirty-notes-mini-quiz-on-arrays-431f72db3162?source=collection_archive---------21----------------------->

![](img/0cca1ac7873eb10790354a8619121037.png)

关于阵列的快速备忘单/小测验，用于复习基础知识。

这篇博客文章将被格式化为一个问题，然后是相应的答案。我发现提出问题有助于巩固我回忆信息的能力，并迫使我对主题有更好的理解。看看它是否对你有同样的作用。

当你浏览博客时，试着用自己的话回答问题，然后再看提供的答案。

## 尽可能多的描述一个数组。

*   相同数据类型(通常)的项目集合。
*   可以是多个维度。
*   可以是静态的或动态的。
*   按顺序组织项目并在内存中连续(按顺序)存储数据。因此是所有数据结构中占用空间最小的。
*   有一个标识每个数据位置的索引。

## 阵列的常见操作有哪些？

*   检查
*   推
*   插入
*   删除

## 上述数组操作的 bigO 是什么？除了上面的，你还能列举一些吗？

*   查找→O(1) →常数时间
*   push → O(1) →恒定时间→除非增加阵列大小→然后 O(n)由于数据的拷贝/位置调整
*   插入→ O(n) →线性时间
*   删除→ O(n) →线性时间
*   搜索→ O(n) →线性时间
*   * pop→O(1)——->常数时间——->*能解释一下为什么吗？*

## 为什么数组的插入和删除是线性时间？

因为每当插入或删除一个元素时，数组都需要为它后面的每个值重新分配索引。因此，数组需要找到用于插入或删除的索引，然后为以下值重新分配索引，这需要接触数组的剩余部分→数组的剩余部分 1/x→O(n * 1/x)→其计算结果为 O(n)。

例如

设 arr = [1，2，3，4，5，6]

假设我们在索引 3 处插入 10，使→ arr = [1，2，3，10，4，5，6]

当我们在索引 3 处插入时，将该索引的值设置为 10。因此，以下所有值都需要重新分配给它们的索引+1。所以在这种情况下，我们仍然需要接触数组中的 3 个元素→ 3 =原始数组长度的 1/2→这意味着我们的 bigO 是 O(n*1/2)，其计算结果为 O(n)。

## Array.pop()的 bigO 是什么？

*pop → O(1) — ->常数时间— ->因为它直接转到最后一个索引，不需要重新分配它之前或之后的元素的索引(因为它是最后一个索引)。

## 数组中的数据存储在哪里？

随机存取存储器(RAM) →连续存储器。

## 阵列的优势/劣势是什么？

*   快速查找。很快。推()。很快。pop()。→ O(1) →恒定时间
*   较慢的插入(。splice())。较慢的删除(也叫拼接)。较慢的未换档()。更慢的搜索。→ O(n) →线性时间

## 静态数组和动态数组有什么区别？

*   静态数组的大小是预先决定的。
*   动态数组会相应地增长/收缩。

## 如何调整动态数组的大小？

如果需要更大的空间，动态数组允许您**在新位置**复制并重建数组。它们将进行复制，然后移动到内存中的一个空间，其****通常是初始空间**的两倍。**

***这种复制需要一个循环，这意味着大小的增加将创建一个实例。push()将是 O(n)而不是 O(1)**

***在 Javascript 和 Python 中，数组被视为动态数组。高级语言对此进行推断。而更关心内存的低级语言允许您设置大小(静态数组)。**

## **你如何构建一个数组？**

**根据你最熟悉的语言，答案可能会有所不同。但是花一些时间来完成一个解决方案。考虑数组固有的操作，并尝试用伪代码(或实际代码)写出数组的类定义，看看您对它的理解程度如何。**

**这就是这个小测验/小抄的全部内容。希望它能让你开心，让你开心！**