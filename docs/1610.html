<html>
<head>
<title>Understand Scope And Scope Chain In JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">理解 JavaScript 中的范围和范围链</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/understand-scopes-and-scope-chain-in-javascript-12ee91161abb?source=collection_archive---------8-----------------------#2021-03-28">https://medium.com/nerd-for-tech/understand-scopes-and-scope-chain-in-javascript-12ee91161abb?source=collection_archive---------8-----------------------#2021-03-28</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="438e" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">范围</h2></div><p id="f258" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">JavaScript 中的<strong class="iz hj"> <em class="jt">作用域</em> </strong>是指代码的当前上下文，决定了变量对 JavaScript 的可访问性。简单来说，我们可以说我们的程序如何组织和访问变量“我们可以访问的地方”。</p><p id="50f3" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">JavaScript 中的<strong class="iz hj">词法范围</strong>意味着在函数外定义的变量可以在变量声明后定义的另一个函数内访问。但反之则不然；函数内部定义的变量在函数外部是不可访问的。</p><p id="eb07" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">作用域有两种——<strong class="iz hj"><em class="jt">全局作用域</em> </strong>和<strong class="iz hj"> <em class="jt">局部作用域</em> </strong>。</p><p id="c326" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="iz hj">全局范围</strong></p><p id="6f16" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在函数外定义的变量<strong class="iz hj">在全局范围内。此外，在整个 JavaScript 文档中只有一个全局范围。一旦你声明了一个全局变量，你就可以在代码中的任何地方使用它，甚至是在函数中</strong></p><p id="ba64" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="iz hj">局部范围</strong></p><p id="8236" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">函数中定义的变量<strong class="iz hj">在局部范围内。并且它们对该函数的每次调用都有不同的作用域。此外，每个函数在被调用时都会创建一个新的作用域。所以也有一个函数作用域。</strong></p><p id="2f4a" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">重点介绍<strong class="iz hj">外</strong>和<strong class="iz hj">内</strong>和<em class="jt">的功能。每个</em>函数都有它的局部作用域。</p><figure class="jv jw jx jy fd jz er es paragraph-image"><div role="button" tabindex="0" class="ka kb di kc bf kd"><div class="er es ju"><img src="../Images/541a9db3659b1e21655d09732830ada6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3zcwke0wPy1t7n85o59HiQ.png"/></div></div></figure><p id="99d3" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">名称变量在任何地方都是可访问的，因为这是一个全局变量。</p><p id="02d7" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在内部函数中，所有变量都是可访问的。为什么？</p><p id="798e" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><em class="jt">由于</em>我们已经讨论过的词法范围。那么会输出什么呢？</p><p id="0980" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">那为什么 var_age 未定义？</p><p id="6257" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这是因为<strong class="iz hj">的</strong>的<strong class="iz hj">吊装。</strong> <em class="jt">什么</em>如果我们访问 let 和 const。然后我们得到 ReferenceError，因为<strong class="iz hj">临时死区</strong>。</p><p id="2326" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们来讨论一下<em class="jt"> let，const，和 var </em>的作用域。</p><figure class="jv jw jx jy fd jz er es paragraph-image"><div role="button" tabindex="0" class="ka kb di kc bf kd"><div class="er es kg"><img src="../Images/5330fbf0799eca5665ad85fd3697b176.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*e9SH8kmzzYZjv8Ouyv2BVQ.png"/></div></div></figure><p id="965f" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">提升和临时死区将在后续文章中讨论。</p><p id="a720" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="iz hj">功能范围</strong> <em class="jt">让我们通过例子</em>来理解</p><figure class="jv jw jx jy fd jz er es paragraph-image"><div role="button" tabindex="0" class="ka kb di kc bf kd"><div class="er es kh"><img src="../Images/ff6ec08a324f50ee35543d9e31907802.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*StvKVcyU4gbgD7drEOgF6A.png"/></div></div></figure><p id="50fc" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这里变量 foo 是可访问的，因为 var 是函数作用域。</p><p id="8e39" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">JavaScript 中的所有作用域都是仅用<strong class="iz hj"> <em class="jt">函数作用域</em> </strong>创建的，它们不是由<strong class="iz hj"> <em class="jt"> for 创建的，而</em> </strong>循环或表达式语句如<strong class="iz hj"> <em class="jt"> if 和开关</em> </strong>。block 语句中定义的变量将保留在它们原来所在的范围内。</p><p id="4228" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这些都在范围内。希望你喜欢。</p><h2 id="c1ed" class="ki kj hi bd kk kl km kn ko kp kq kr ks jg kt ku kv jk kw kx ky jo kz la lb lc bi translated">范围链</h2><p id="0ba0" class="pw-post-body-paragraph ix iy hi iz b ja ld ij jc jd le im jf jg lf ji jj jk lg jm jn jo lh jq jr js hb bi translated">现在你可能会问什么是<strong class="iz hj">作用域链</strong>以及它如何影响代码？</p><p id="6e4f" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="iz hj">作用域链</strong>建立给定函数的作用域。每个定义的函数都有其嵌套的作用域，在另一个函数中定义的任何函数都有一个链接到外部函数的局部作用域，这种链接称为链。</p><p id="65fd" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><em class="jt">调用函数不会影响作用域链。怎么会？</em>让我们看看</p><figure class="jv jw jx jy fd jz er es paragraph-image"><div role="button" tabindex="0" class="ka kb di kc bf kd"><div class="er es kh"><img src="../Images/b49d4263c1e67e78882e499386508e93.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0zX4la4hzjEpliX7Wwowew.png"/></div></div></figure><p id="a5b1" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">只能访问全局变量和临时变量。<em class="jt">为什么？</em></p><p id="d1e4" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">要访问“foo”和“bar ”,我们必须将第三个函数限定在第二个函数中。</p><p id="5572" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我希望你在这里学到了新东西。</p><p id="818f" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">谢谢你的 time☺️</p></div></div>    
</body>
</html>