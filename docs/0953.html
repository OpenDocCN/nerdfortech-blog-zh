<html>
<head>
<title>Dead Letter Exchanges at RabbitMQ + .NET Core</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">RabbitMQ +上的死信交流。网络核心</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/dead-letter-exchanges-at-rabbitmq-net-core-b6348122460d?source=collection_archive---------0-----------------------#2021-02-25">https://medium.com/nerd-for-tech/dead-letter-exchanges-at-rabbitmq-net-core-b6348122460d?source=collection_archive---------0-----------------------#2021-02-25</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div class="er es if"><img src="../Images/6b162305812441219b2fa8af0ab32f68.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*aQantURBYE4_3gWyfA4UAQ@2x.jpeg"/></div></figure><p id="2193" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">当我们配置 RabbitMQ 实例时，我们不能忘记考虑的一件事是，在实践中，队列的消费者可能无法处理某些通知，甚至队列本身也可能由于某些事件而拒绝消息。在这种情况下，我们必须实现死信交换，这样才有可能保留那些消息并在其他时间重新处理它们。</p><p id="7c67" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">在本文中，我打算解释何时使用死信交换(dlx)，如何在 RabbitMQ 中配置它，以及如何构建一个. NET 核心应用程序来测试流。</p><h2 id="9008" class="jk jl hi bd jm jn jo jp jq jr js jt ju ix jv jw jx jb jy jz ka jf kb kc kd ke bi translated">何时使用死信交换(dlx)</h2><p id="9f00" class="pw-post-body-paragraph im in hi io b ip kf ir is it kg iv iw ix kh iz ja jb ki jd je jf kj jh ji jj hb bi translated">有几种无法传递或处理消息的情况，在 RabbitMQ 中，它们是:</p><ol class=""><li id="db8d" class="kk kl hi io b ip iq it iu ix km jb kn jf ko jj kp kq kr ks bi translated"><strong class="io hj">由于 TTL(生存时间)，消息已经过期:</strong>在 RabbitMQ 中，可以将参数 x-message-ttl 添加到队列中，以设置消息可以生存多长时间。当消息的 TTL 过期时，该消息将被丢弃。</li><li id="3a3d" class="kk kl hi io b ip kt it ku ix kv jb kw jf kx jj kp kq kr ks bi translated"><strong class="io hj">消息被消费者拒绝:</strong>由于某种原因，消息无法被处理，因此消费者以 requeue 标志设置为 false 的方式否定确认(Nack)消息时，会发生这种情况。</li><li id="0f3f" class="kk kl hi io b ip kt it ku ix kv jb kw jf kx jj kp kq kr ks bi translated"><strong class="io hj">队列已经达到了它的长度容量:</strong>在 RabbitMQ 中，可以将参数<em class="ky"> x-max-length </em>添加到队列中，以设置它可以包含多少个就绪消息。当达到容量时，下一条消息将被丢弃。</li></ol><p id="3c38" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">在任何一种情况下，如果您不想丢失这些消息，就必须配置 dlx。</p><h2 id="8995" class="jk jl hi bd jm jn jo jp jq jr js jt ju ix jv jw jx jb jy jz ka jf kb kc kd ke bi translated">如何在 RabbitMQ 配置 DLXs</h2><p id="741d" class="pw-post-body-paragraph im in hi io b ip kf ir is it kg iv iw ix kh iz ja jb ki jd je jf kj jh ji jj hb bi translated">下图显示了具有 DLX 的 RabbitMQ 实例的体系结构:</p><figure class="la lb lc ld fd ij er es paragraph-image"><div role="button" tabindex="0" class="le lf di lg bf lh"><div class="er es kz"><img src="../Images/745ebbcfe56f101db7c19175ce30019e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Ud2dXM2iJr6yu4EgnkwD7w.png"/></div></div><figcaption class="li lj et er es lk ll bd b be z dx translated"><strong class="bd jm">DLX 使用的建筑</strong></figcaption></figure><p id="36dd" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">因此，基本上，该解决方案包括:</p><ul class=""><li id="1cbc" class="kk kl hi io b ip iq it iu ix km jb kn jf ko jj lm kq kr ks bi translated"><strong class="io hj">生产者:</strong>向交易所发送消息的应用程序</li><li id="832c" class="kk kl hi io b ip kt it ku ix kv jb kw jf kx jj lm kq kr ks bi translated"><strong class="io hj">交换:</strong>将消息重定向到普通队列的普通交换</li><li id="38d9" class="kk kl hi io b ip kt it ku ix kv jb kw jf kx jj lm kq kr ks bi translated"><strong class="io hj">队列:</strong>普通队列，存储交换机发送的消息</li><li id="5596" class="kk kl hi io b ip kt it ku ix kv jb kw jf kx jj lm kq kr ks bi translated"><strong class="io hj">消费者:</strong>从队列中接收消息的应用程序</li><li id="98b2" class="kk kl hi io b ip kt it ku ix kv jb kw jf kx jj lm kq kr ks bi translated"><strong class="io hj">死信交换:</strong>专用于重定向被拒绝消息的交换</li><li id="aef8" class="kk kl hi io b ip kt it ku ix kv jb kw jf kx jj lm kq kr ks bi translated"><strong class="io hj">死信队列:</strong>专门存储被拒绝消息的队列</li></ul><p id="5f66" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">现在，让我们使用 RabbitMQ 管理接口创建交换、队列和绑定。(这里我不会展示如何使用 Docker 创建 RabbitMQ 的实例，也不会展示如何创建用户和虚拟主机。为此，我建议你阅读我的另一篇关于在启动时配置 RabbitMQ 的文章。</p><p id="c997" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">首先，让我们处理交流。</p></div><div class="ab cl lo lp gp lq" role="separator"><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt"/></div><div class="hb hc hd he hf"><p id="2e71" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">为了简化解释，我不会创建一个交换来将消息重定向到普通队列，因为我将使用<em class="ky"> amq.direct </em>交换，这是在创建 RabbitMQ 的实例时默认出现的。</p><figure class="la lb lc ld fd ij er es paragraph-image"><div role="button" tabindex="0" class="le lf di lg bf lh"><div class="er es lv"><img src="../Images/9581ac6b25c463111aa0f6bbf0b28d43.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4nBJBlFG57-xAj5lSJLdiQ.png"/></div></div><figcaption class="li lj et er es lk ll bd b be z dx translated"><strong class="bd jm"> amq.direct 交换，用于将发布的消息重定向到队列</strong></figcaption></figure><p id="be8d" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">为了创建死信交换，我们将使用以下配置:</p><ul class=""><li id="fe26" class="kk kl hi io b ip iq it iu ix km jb kn jf ko jj lm kq kr ks bi translated"><strong class="io hj">名字:</strong>我会把它命名为<em class="ky"> demo-dead-letter-exchange，</em>但是你可以选择你想要的名字。</li><li id="37fd" class="kk kl hi io b ip kt it ku ix kv jb kw jf kx jj lm kq kr ks bi translated"><strong class="io hj"> Type: </strong>为了简化，我准备使用<strong class="io hj"> <em class="ky"> fanout </em> </strong>，这样绑定到交换的每个队列都会收到被拒绝的消息。</li><li id="3c9e" class="kk kl hi io b ip kt it ku ix kv jb kw jf kx jj lm kq kr ks bi translated"><strong class="io hj">耐久性:</strong>我将把它设置为<strong class="io hj">耐久性</strong>，这样交换可以持续到服务器重启</li><li id="e6e0" class="kk kl hi io b ip kt it ku ix kv jb kw jf kx jj lm kq kr ks bi translated"><strong class="io hj">自动删除:</strong>它将被设置为<strong class="io hj">否</strong>，因此当没有队列绑定到交换机时，它不会被删除。</li><li id="7ff7" class="kk kl hi io b ip kt it ku ix kv jb kw jf kx jj lm kq kr ks bi translated"><strong class="io hj">内部:</strong>由于我不打算让这个交换可以被出版商使用，它将被设置为<strong class="io hj"> Yes。</strong></li></ul><p id="b8db" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">死信交换的配置应该如下所示:</p><figure class="la lb lc ld fd ij er es paragraph-image"><div role="button" tabindex="0" class="le lf di lg bf lh"><div class="er es lw"><img src="../Images/19f4dd430f2389bb8aa2d8004e4ccfc5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-SAazrRaUild4--bPKejeQ.png"/></div></div><figcaption class="li lj et er es lk ll bd b be z dx translated"><strong class="bd jm">DLX 的配置</strong></figcaption></figure><p id="64ff" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">配置好所有的交换之后，让我们创建队列。</p></div><div class="ab cl lo lp gp lq" role="separator"><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt"/></div><div class="hb hc hd he hf"><p id="0888" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">为了开始创建队列，我们将创建存储已发布消息的队列，它将具有以下配置:</p><ul class=""><li id="f832" class="kk kl hi io b ip iq it iu ix km jb kn jf ko jj lm kq kr ks bi translated"><strong class="io hj">名称:</strong>我将它命名为<em class="ky"> demo-queue，</em>但是你可以选择你想要的名称。</li><li id="a49f" class="kk kl hi io b ip kt it ku ix kv jb kw jf kx jj lm kq kr ks bi translated"><strong class="io hj">耐久性:</strong>我将把它设置为<strong class="io hj">耐久性</strong>，这样队列可以存活到服务器重启。</li><li id="c293" class="kk kl hi io b ip kt it ku ix kv jb kw jf kx jj lm kq kr ks bi translated"><strong class="io hj">自动删除:</strong>它将被设置为<strong class="io hj">否</strong>，因此当所有用户断开连接时，它不会被删除。</li></ul><p id="26e7" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">以及以下论点:</p><ul class=""><li id="9b31" class="kk kl hi io b ip iq it iu ix km jb kn jf ko jj lm kq kr ks bi translated"><strong class="io hj"> x-queue-mode: </strong>它将被设置为<strong class="io hj"> lazy，</strong>因为我不需要快速访问消息。</li><li id="5df0" class="kk kl hi io b ip kt it ku ix kv jb kw jf kx jj lm kq kr ks bi translated"><strong class="io hj">x-dead-letter-exchange:</strong>它将被设置为<strong class="io hj">demo-dead-letter-exchange</strong>，这是之前创建的 DLX 的名称。如前所述，正是这个参数将使被拒绝的消息被重定向到 DLX。</li></ul><p id="ff1e" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">您的队列应该是这样的:</p><figure class="la lb lc ld fd ij er es paragraph-image"><div role="button" tabindex="0" class="le lf di lg bf lh"><div class="er es lv"><img src="../Images/ddc10cd0dca8db2f0da28c77dd0dd033.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*81MGzd8XQSfmJcImsGicTw.png"/></div></div><figcaption class="li lj et er es lk ll bd b be z dx translated"><strong class="bd jm"> <em class="lx">配置<em class="lx">队列</em>中的</em>，该队列将存储已发布的消息</strong></figcaption></figure><p id="e0eb" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">现在，为了完成队列的创建，我们将创建死信队列，它将被称为<em class="ky">演示死信队列</em>和<em class="ky"> </em>将具有与<em class="ky">演示队列</em>几乎相同的配置，因为我们将只排除<em class="ky"> x 死信交换</em>参数。<em class="ky">演示死信队列</em>应该是这样的:</p><figure class="la lb lc ld fd ij er es paragraph-image"><div role="button" tabindex="0" class="le lf di lg bf lh"><div class="er es ly"><img src="../Images/543eea3840e60a03d704eaee58ebf040.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*K-O2Xjm6eQbJ2v4FZVFgpA.png"/></div></div><figcaption class="li lj et er es lk ll bd b be z dx translated"><strong class="bd jm"> <em class="lx">配置</em>的死信<em class="lx">队列</em> </strong></figcaption></figure><p id="71c8" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">最后，我们将把交换绑定到各自的队列，以完成 RabbitMQ 的配置。</p><p id="220f" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><em class="ky">演示队列</em>必须绑定到<em class="ky"> amq.direct </em>交换:</p><figure class="la lb lc ld fd ij er es paragraph-image"><div role="button" tabindex="0" class="le lf di lg bf lh"><div class="er es ly"><img src="../Images/12a267793544d0c69f485fb52201307e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6I0KW8qm9meecXaTpRRbOA.png"/></div></div><figcaption class="li lj et er es lk ll bd b be z dx translated"><strong class="bd jm"> <em class="lx">绑定</em>的演示<em class="lx">-队列</em> <em class="lx">与</em>的 amq.direct 交换</strong></figcaption></figure><p id="66b9" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">demo-dead-letter-queue 必须像这样绑定到<em class="ky"> amq.direct </em>交换:</p><figure class="la lb lc ld fd ij er es paragraph-image"><div role="button" tabindex="0" class="le lf di lg bf lh"><div class="er es lz"><img src="../Images/e5007e6188c031add4aa3c5cbf9a7aba.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uH9axXeogOruQ-jt8TYONQ.png"/></div></div><figcaption class="li lj et er es lk ll bd b be z dx translated"><strong class="bd jm"> <em class="lx">绑定</em>的演示<em class="lx"> - </em>死<em class="lx"> - </em>信<em class="lx">-排队</em>-<em class="lx">带</em>的演示<em class="lx"> - </em>死<em class="lx"> - </em>信<em class="lx"> - </em>交换</strong></figcaption></figure><p id="6a04" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">一旦我们完成了 RabbitMQ 的配置，就该使用。NET，所以所做的一切都可以被测试。</p><h2 id="e68f" class="jk jl hi bd jm jn jo jp jq jr js jt ju ix jv jw jx jb jy jz ka jf kb kc kd ke bi translated">测试死信交换的功能。网络核心</h2><p id="3486" class="pw-post-body-paragraph im in hi io b ip kf ir is it kg iv iw ix kh iz ja jb ki jd je jf kj jh ji jj hb bi translated">测试 DLX 的代码非常简单，由四个类组成:</p><ol class=""><li id="25e1" class="kk kl hi io b ip iq it iu ix km jb kn jf ko jj kp kq kr ks bi translated"><strong class="io hj"><em class="ky">RabbitMQ connection . cs</em>:</strong>负责与 rabbit MQ 连接的类。从代码中可以看出，虚拟主机必须命名为<em class="ky"> demo-vhost，</em>用户<em class="ky"> john123，</em>密码<em class="ky"> 123456 </em>，主机为 localhost:5672，这是默认设置(但是可以随意配置)。</li></ol><pre class="la lb lc ld fd ma mb mc md aw me bi"><span id="84a7" class="jk jl hi mb b fi mf mg l mh mi">using RabbitMQ.Client;</span><span id="8bb6" class="jk jl hi mb b fi mj mg l mh mi">using System;</span><span id="975c" class="jk jl hi mb b fi mj mg l mh mi">namespace ConfiguringDeadLetterExchange</span><span id="6960" class="jk jl hi mb b fi mj mg l mh mi">{<br/>    public class RabbitMQConnection</span><span id="e4b1" class="jk jl hi mb b fi mj mg l mh mi">    {</span><span id="d893" class="jk jl hi mb b fi mj mg l mh mi">        private readonly IConnectionFactory _connectionFactory;</span><span id="0dd1" class="jk jl hi mb b fi mj mg l mh mi">        private IConnection _connection;</span><span id="55cf" class="jk jl hi mb b fi mj mg l mh mi">        public RabbitMQConnection()</span><span id="b47c" class="jk jl hi mb b fi mj mg l mh mi">        {</span><span id="9ec1" class="jk jl hi mb b fi mj mg l mh mi">            _connectionFactory = new ConnectionFactory()</span><span id="06d7" class="jk jl hi mb b fi mj mg l mh mi">            {</span><span id="0a0b" class="jk jl hi mb b fi mj mg l mh mi">                Uri = new Uri(GetConnectionString())</span><span id="2413" class="jk jl hi mb b fi mj mg l mh mi">            };</span><span id="9fe4" class="jk jl hi mb b fi mj mg l mh mi">            _connection = _connectionFactory.CreateConnection();</span><span id="b84c" class="jk jl hi mb b fi mj mg l mh mi">        }<br/></span><span id="4fcf" class="jk jl hi mb b fi mj mg l mh mi">        public IModel CreateModel()</span><span id="2e0d" class="jk jl hi mb b fi mj mg l mh mi">        {</span><span id="915a" class="jk jl hi mb b fi mj mg l mh mi">            return _connection.CreateModel();</span><span id="eed0" class="jk jl hi mb b fi mj mg l mh mi">        }<br/></span><span id="3aeb" class="jk jl hi mb b fi mj mg l mh mi">        private string GetConnectionString()</span><span id="86d2" class="jk jl hi mb b fi mj mg l mh mi">        { </span><span id="13a5" class="jk jl hi mb b fi mj mg l mh mi">            string user = "john123";</span><span id="bb9b" class="jk jl hi mb b fi mj mg l mh mi">            string password = "123456";</span><span id="7fd1" class="jk jl hi mb b fi mj mg l mh mi">            string host = "localhost:5672";</span><span id="1700" class="jk jl hi mb b fi mj mg l mh mi">            string virtualHost = "demo-vhost";</span><span id="c5a6" class="jk jl hi mb b fi mj mg l mh mi">            string connectionString = "amqp://{0}:{1}@{2}/{3}";</span><span id="e0cd" class="jk jl hi mb b fi mj mg l mh mi">            return string.Format(connectionString, user, password,<br/>                host, virtualHost);</span><span id="e9ff" class="jk jl hi mb b fi mj mg l mh mi">        }</span><span id="493c" class="jk jl hi mb b fi mj mg l mh mi">    }</span><span id="7cdb" class="jk jl hi mb b fi mj mg l mh mi">}</span></pre><p id="e746" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><em class="ky"> 2。</em><strong class="io hj"><em class="ky">consumer . cs:</em></strong>类，负责消费来自<em class="ky">演示队列</em>的消息，并使用<em class="ky"> BasicNack </em>方法拒绝它。此外，它有一个方法<em class="ky"> SetConsumer </em>来启用队列的监听器。</p><pre class="la lb lc ld fd ma mb mc md aw me bi"><span id="80af" class="jk jl hi mb b fi mf mg l mh mi">using Newtonsoft.Json;</span><span id="bbee" class="jk jl hi mb b fi mj mg l mh mi">using RabbitMQ.Client;</span><span id="0387" class="jk jl hi mb b fi mj mg l mh mi">using RabbitMQ.Client.Events;</span><span id="09c6" class="jk jl hi mb b fi mj mg l mh mi">using System.Text;</span><span id="6091" class="jk jl hi mb b fi mj mg l mh mi">namespace ConfiguringDeadLetterExchange</span><span id="5bde" class="jk jl hi mb b fi mj mg l mh mi">{</span><span id="c4a3" class="jk jl hi mb b fi mj mg l mh mi">    public class Consumer</span><span id="52f5" class="jk jl hi mb b fi mj mg l mh mi">    {</span><span id="4219" class="jk jl hi mb b fi mj mg l mh mi">        public Consumer(IModel channel)</span><span id="00d2" class="jk jl hi mb b fi mj mg l mh mi">        {</span><span id="fe9e" class="jk jl hi mb b fi mj mg l mh mi">            _channel = channel;</span><span id="b974" class="jk jl hi mb b fi mj mg l mh mi">        }</span><span id="f799" class="jk jl hi mb b fi mj mg l mh mi">        private IModel _channel;</span><span id="7f82" class="jk jl hi mb b fi mj mg l mh mi">       <br/>        public void SetConsumer()</span><span id="1e57" class="jk jl hi mb b fi mj mg l mh mi">        {</span><span id="75b1" class="jk jl hi mb b fi mj mg l mh mi">            var consumer = new EventingBasicConsumer(_channel);</span><span id="237b" class="jk jl hi mb b fi mj mg l mh mi">            consumer.Received += ReceivedEvent;</span><span id="60de" class="jk jl hi mb b fi mj mg l mh mi">            _channel.BasicConsume(queue: "demo-queue", autoAck:<br/>                false, consumer: consumer);</span><span id="597a" class="jk jl hi mb b fi mj mg l mh mi">        }</span><span id="4d45" class="jk jl hi mb b fi mj mg l mh mi"><br/>        public async void ReceivedEvent(object sender,<br/>            BasicDeliverEventArgs e)</span><span id="23fb" class="jk jl hi mb b fi mj mg l mh mi">        {</span><span id="d02a" class="jk jl hi mb b fi mj mg l mh mi">            var message = Encoding.UTF8.GetString(e.Body.Span);</span><span id="f14d" class="jk jl hi mb b fi mj mg l mh mi">            if (e.RoutingKey == "demo-queue")</span><span id="481d" class="jk jl hi mb b fi mj mg l mh mi">            {</span><span id="e967" class="jk jl hi mb b fi mj mg l mh mi">                var deserializedMessage =<br/>                    JsonConvert.DeserializeObject&lt;object&gt;(message);</span><span id="7a70" class="jk jl hi mb b fi mj mg l mh mi">                _channel.BasicNack(e.DeliveryTag, false, false);</span><span id="204d" class="jk jl hi mb b fi mj mg l mh mi">            }</span><span id="d4d2" class="jk jl hi mb b fi mj mg l mh mi">        }</span><span id="06b6" class="jk jl hi mb b fi mj mg l mh mi">    }</span><span id="93ee" class="jk jl hi mb b fi mj mg l mh mi">}</span></pre><p id="bf90" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><em class="ky"> 3。</em><strong class="io hj"><em class="ky">producer . cs</em>:</strong>类，负责使用<em class="ky"> amq.direct </em>交换向<em class="ky">演示队列</em>发布消息。</p><pre class="la lb lc ld fd ma mb mc md aw me bi"><span id="b5ae" class="jk jl hi mb b fi mf mg l mh mi">using Newtonsoft.Json;</span><span id="4af7" class="jk jl hi mb b fi mj mg l mh mi">using RabbitMQ.Client;</span><span id="9c41" class="jk jl hi mb b fi mj mg l mh mi">using System.Text;</span><span id="7290" class="jk jl hi mb b fi mj mg l mh mi">namespace ConfiguringDeadLetterExchange</span><span id="5840" class="jk jl hi mb b fi mj mg l mh mi">{</span><span id="7af9" class="jk jl hi mb b fi mj mg l mh mi">    public class Producer</span><span id="c8c7" class="jk jl hi mb b fi mj mg l mh mi">    {</span><span id="e341" class="jk jl hi mb b fi mj mg l mh mi">        private IModel _channel;<br/></span><span id="83e7" class="jk jl hi mb b fi mj mg l mh mi">        public Producer(IModel channel)</span><span id="8065" class="jk jl hi mb b fi mj mg l mh mi">        {</span><span id="e7f9" class="jk jl hi mb b fi mj mg l mh mi">            _channel = channel;</span><span id="1241" class="jk jl hi mb b fi mj mg l mh mi">        }</span><span id="d56c" class="jk jl hi mb b fi mj mg l mh mi"><br/>        public void Publish(object publishModel)</span><span id="0d20" class="jk jl hi mb b fi mj mg l mh mi">        {</span><span id="7481" class="jk jl hi mb b fi mj mg l mh mi">            var message = JsonConvert.SerializeObject(publishModel);</span><span id="b9e0" class="jk jl hi mb b fi mj mg l mh mi">            var body = Encoding.UTF8.GetBytes(message);</span><span id="c3a7" class="jk jl hi mb b fi mj mg l mh mi">            IBasicProperties properties <br/>                = _channel.CreateBasicProperties();</span><span id="3731" class="jk jl hi mb b fi mj mg l mh mi">            properties.Persistent = true;</span><span id="0a4e" class="jk jl hi mb b fi mj mg l mh mi">            properties.DeliveryMode = 2;</span><span id="0183" class="jk jl hi mb b fi mj mg l mh mi">            _channel.ConfirmSelect();</span><span id="43c9" class="jk jl hi mb b fi mj mg l mh mi">            _channel.BasicPublish(exchange: "amq.direct",<br/>                routingKey: "demo-queue", mandatory: true,<br/>                basicProperties: properties, body: body);</span><span id="1395" class="jk jl hi mb b fi mj mg l mh mi">            _channel.WaitForConfirmsOrDie();</span><span id="1707" class="jk jl hi mb b fi mj mg l mh mi">            _channel.ConfirmSelect();</span><span id="71fa" class="jk jl hi mb b fi mj mg l mh mi">        }</span><span id="ea41" class="jk jl hi mb b fi mj mg l mh mi">    }</span><span id="c221" class="jk jl hi mb b fi mj mg l mh mi">}</span></pre><p id="857a" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><em class="ky"> 4。</em> <strong class="io hj"> <em class="ky"> Program.cs </em> : </strong>类，该类使用<em class="ky"> CreateModel </em>方法创建通道，使用<em class="ky"> SetConsumer </em>方法启用监听器，并将消息<strong class="io hj"> test </strong>发布到<em class="ky"> demo-queue，</em>稍后将被消费和拒绝(线程。代码处的睡眠只是为了防止程序在消息被消费之前终止，因为它是控制台应用程序的代码)。</p><pre class="la lb lc ld fd ma mb mc md aw me bi"><span id="4981" class="jk jl hi mb b fi mf mg l mh mi">using RabbitMQ.Client;</span><span id="de6e" class="jk jl hi mb b fi mj mg l mh mi">using System.Threading;</span><span id="9c0e" class="jk jl hi mb b fi mj mg l mh mi">namespace ConfiguringDeadLetterExchange</span><span id="fd9a" class="jk jl hi mb b fi mj mg l mh mi">{</span><span id="a2d2" class="jk jl hi mb b fi mj mg l mh mi">    class Program</span><span id="3276" class="jk jl hi mb b fi mj mg l mh mi">    {</span><span id="8a7e" class="jk jl hi mb b fi mj mg l mh mi">        static void Main(string[] args)</span><span id="60da" class="jk jl hi mb b fi mj mg l mh mi">        {</span><span id="5b7e" class="jk jl hi mb b fi mj mg l mh mi">            RabbitMQConnection rabbitMQConnection = new<br/>                RabbitMQConnection();</span><span id="d98c" class="jk jl hi mb b fi mj mg l mh mi">            IModel channel = rabbitMQConnection.CreateModel();</span><span id="a2ba" class="jk jl hi mb b fi mj mg l mh mi">            Consumer consumer = new Consumer(channel);</span><span id="e481" class="jk jl hi mb b fi mj mg l mh mi">            consumer.SetConsumer();</span><span id="5a53" class="jk jl hi mb b fi mj mg l mh mi">            Producer producer = new Producer(channel);</span><span id="6480" class="jk jl hi mb b fi mj mg l mh mi">            producer.Publish("teste");</span><span id="0d9e" class="jk jl hi mb b fi mj mg l mh mi">            Thread.Sleep(10000);</span><span id="2e85" class="jk jl hi mb b fi mj mg l mh mi">        }</span><span id="d7e6" class="jk jl hi mb b fi mj mg l mh mi">    }</span><span id="01fa" class="jk jl hi mb b fi mj mg l mh mi">}</span></pre><p id="f18c" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">执行应用程序后，消息<strong class="io hj"> test </strong>将被拒绝，并应出现在演示死信队列中:</p><figure class="la lb lc ld fd ij er es paragraph-image"><div role="button" tabindex="0" class="le lf di lg bf lh"><div class="er es mk"><img src="../Images/4e4e60919765778ca8e27a25c90a51b1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*owTZNimPvXuVLfI-mDvT4A.png"/></div></div><figcaption class="li lj et er es lk ll bd b be z dx translated"><strong class="bd jm"> <em class="lx">带有被拒绝消息</em></strong>的演示死信队列</figcaption></figure><p id="caea" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">如果您使用 RabbitMQ 的 managemente 接口从队列中获取消息，您可以看到一些有趣的事情，例如<strong class="io hj">计数</strong>，它表示消息被拒绝的次数，以及<strong class="io hj">原因</strong>，它表示消息被拒绝的原因。在这种情况下，原因是<strong class="io hj">被拒绝</strong>，因为我们使用<em class="ky"> BasicAck </em>方法、<em class="ky"> </em>显式地拒绝了它，但是原因可以根据消息被拒绝的情况而变化。</p><figure class="la lb lc ld fd ij er es paragraph-image"><div role="button" tabindex="0" class="le lf di lg bf lh"><div class="er es lz"><img src="../Images/e6bf5f359ce8f44a42ceba746e07f400.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MyPvHUrthmxkLccNXS4tvQ.png"/></div></div><figcaption class="li lj et er es lk ll bd b be z dx translated"><strong class="bd jm">在</strong><strong class="bd jm"><em class="lx">demo-dead-letter-queue</em></strong>的被拒绝报文的属性</figcaption></figure></div><div class="ab cl lo lp gp lq" role="separator"><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt"/></div><div class="hb hc hd he hf"><p id="f421" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">在配置了 DLX 并将被拒绝的消息存储在队列中之后，您可以创建自己的流程来重新处理它们，这可以是安排重试以将这些消息返回到<em class="ky">演示队列</em>或者甚至手动处理它们。</p><p id="2d6f" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">有了 RabbitMQ 的这种死信交换配置，我希望您不会丢失更多的消息，并在您的流中获得更多的弹性。</p></div></div>    
</body>
</html>