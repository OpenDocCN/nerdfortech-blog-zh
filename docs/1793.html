<html>
<head>
<title>Object validation in Ktor/Kotlin</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Ktor/Kotlin 中的对象验证</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/object-validation-in-kotlin-c7e02b5dabc?source=collection_archive---------0-----------------------#2021-04-07">https://medium.com/nerd-for-tech/object-validation-in-kotlin-c7e02b5dabc?source=collection_archive---------0-----------------------#2021-04-07</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/4f77f5bf4bc45d873e514ebff0fe0c28.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*eXU-1EnKBzJ_KOUf.jpeg"/></div></div></figure><h1 id="4bb4" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">介绍</h1><p id="b71a" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">作为我的系列<a class="ae km" rel="noopener" href="/p/87f814e3dffd">一个固执己见的 Kotlin 后端服务</a>的一部分，我检查了几个库来验证客户端请求。</p><p id="37fa" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">我的要求是使用一个 Kotlin 库，有一个简洁流畅的 API，没有典型的 Java 冗长(因此这些都没有出现在我的列表中:【http://java-source.net/open-source/validation<a class="ae km" href="http://java-source.net/open-source/validation" rel="noopener ugc nofollow" target="_blank"/>)。</p><p id="0efe" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">我不想要的(【https://sebthom.github.io/oval】T4):</p><pre class="ks kt ku kv fd kw kx ky kz aw la bi"><span id="e3e7" class="lb ir hi kx b fi lc ld l le lf">public class BusinessObject {</span><span id="4221" class="lb ir hi kx b fi lg ld l le lf"> <!-- -->  @NotNull<br/>   @NotEmpty<br/>   @Length(max=32)<br/>   private String name;</span><span id="03e4" class="lb ir hi kx b fi lg ld l le lf">   @NotNull<br/>   private String <!-- -->deliveryAddress<!-- -->;</span><span id="33a5" class="lb ir hi kx b fi lg ld l le lf">   @NotNull<br/>   private String <!-- -->invoiceAddress<!-- -->;</span><span id="5970" class="lb ir hi kx b fi lg ld l le lf">   @Assert(expr = "_value ==_this.deliveryAddress || _value == _            <br/>           this.invoiceAddress", lang = "groovy")<br/>   public String mailingAddress;</span><span id="7cd0" class="lb ir hi kx b fi lg ld l le lf">}</span></pre><p id="1337" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">更合我意(<a class="ae km" href="https://joi.dev/" rel="noopener ugc nofollow" target="_blank"> https://joi.dev </a>)，虽然它不是 DSL，但“只是”一个流畅的 API:</p><pre class="ks kt ku kv fd kw kx ky kz aw la bi"><span id="14e6" class="lb ir hi kx b fi lc ld l le lf">username: Joi.string()<br/>             .alphanum()<br/>             .min(3)<br/>             .max(30)<br/>             .required(),<br/>email:    Joi.string()<br/>             .email({ minDomainSegments: 2, tlds: { allow: ['com', 'net'] </span></pre><p id="a90c" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">我想用一种语言来构建我的应用程序。正如<em class="lh"> mailingAddress </em>示例所示，注释往往会模糊配置和代码之间的界限。配置文件(yaml、json、xml 等)也是如此。).真实配置文件(例如部署配置)是可以的，但是用于对象验证的配置文件呢？绝对不行。</p><p id="b249" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">无论如何，我检查了以下 5 个图书馆:</p><ol class=""><li id="eaf2" class="li lj hi jq b jr kn jv ko jz lk kd ll kh lm kl ln lo lp lq bi translated"><a class="ae km" href="https://github.com/wajahatkarim3/EasyValidation" rel="noopener ugc nofollow" target="_blank">简易验证</a></li><li id="e44c" class="li lj hi jq b jr lr jv ls jz lt kd lu kh lv kl ln lo lp lq bi translated"><a class="ae km" href="https://github.com/kamedon/Validation" rel="noopener ugc nofollow" target="_blank">卡梅东</a></li><li id="161d" class="li lj hi jq b jr lr jv ls jz lt kd lu kh lv kl ln lo lp lq bi translated"><a class="ae km" href="https://github.com/rcapraro/kalidation" rel="noopener ugc nofollow" target="_blank">加碱</a></li><li id="09cb" class="li lj hi jq b jr lr jv ls jz lt kd lu kh lv kl ln lo lp lq bi translated"><a class="ae km" href="https://github.com/valiktor/valiktor" rel="noopener ugc nofollow" target="_blank"> Valiktor </a></li><li id="70d4" class="li lj hi jq b jr lr jv ls jz lt kd lu kh lv kl ln lo lp lq bi translated"><a class="ae km" href="https://github.com/konform-kt/konform" rel="noopener ugc nofollow" target="_blank"> Konform </a></li></ol><h1 id="c377" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">坏事</h1><p id="829b" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">前三个图书馆没有进入我的候选名单。</p><h2 id="bed4" class="lb ir hi bd is lw lx ly iw lz ma mb ja jz mc md je kd me mf ji kh mg mh jm mi bi translated">简易验证</h2><ul class=""><li id="c085" class="li lj hi jq b jr js jv jw jz mj kd mk kh ml kl mm lo lp lq bi translated">329 个 Github 星，7 个守望者，63 个分叉</li><li id="9c6a" class="li lj hi jq b jr lr jv ls jz lt kd lu kh lv kl mm lo lp lq bi translated">最后提交时间:2020 年 10 月 23 日</li></ul><p id="532c" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">API 是流畅的，但是它没有 DSL:</p><figure class="ks kt ku kv fd ij"><div class="bz dy l di"><div class="mn mo l"/></div></figure><p id="b4c7" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">总的来说，API 看起来过时了，而且它还依赖于一些 Android 特定的库。</p><h2 id="519f" class="lb ir hi bd is lw lx ly iw lz ma mb ja jz mc md je kd me mf ji kh mg mh jm mi bi translated">卡梅东</h2><ul class=""><li id="90ee" class="li lj hi jq b jr js jv jw jz mj kd mk kh ml kl mm lo lp lq bi translated">19 个 Github 明星，2 个守望者，6 个分叉</li><li id="863b" class="li lj hi jq b jr lr jv ls jz lt kd lu kh lv kl mm lo lp lq bi translated">上次提交时间:2018 年 10 月 8 日</li></ul><p id="41a1" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">不活跃，没有社区，死项目。</p><h2 id="db31" class="lb ir hi bd is lw lx ly iw lz ma mb ja jz mc md je kd me mf ji kh mg mh jm mi bi translated">验证</h2><ul class=""><li id="5adb" class="li lj hi jq b jr js jv jw jz mj kd mk kh ml kl mm lo lp lq bi translated">43 颗 Github 星，7 个守望者，5 个叉子</li><li id="e79b" class="li lj hi jq b jr lr jv ls jz lt kd lu kh lv kl mm lo lp lq bi translated">最后提交时间:2020 年 9 月 11 日</li></ul><p id="48e1" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">验证 DSL 似乎非常灵活，也许太灵活了:</p><figure class="ks kt ku kv fd ij"><div class="bz dy l di"><div class="mn mo l"/></div></figure><p id="8cfa" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">与 Valiktor 和 Konform 相比，似乎有更多的样板代码。再加上对这个库的兴趣相对较低，我决定先给另外两个库一个机会，只有在另外两个库中发现一些令人失望的东西时，我才会回到 Kvalidation。</p><h1 id="9585" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">好人</h1><p id="d6d9" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">我的一个需求是能够以一种描述性的方式向客户端显示验证错误，这样就可以清楚哪个参数验证失败了。</p><p id="309a" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">创建错误消息的逻辑必须封装在验证代码中，以确保验证库的细节不会泄漏到应用程序的其他组件中(例如路由或错误处理模块)。为此，我希望验证库抛出一个带有错误消息的<em class="lh"> IllegalArgumentException </em>。然后我会捕获这些异常，并把它们转换成 HTTP 400 响应(使用 Ktor 特性):</p><pre class="ks kt ku kv fd kw kx ky kz aw la bi"><span id="1d84" class="lb ir hi kx b fi lc ld l le lf">exception&lt;IllegalArgumentException&gt; <strong class="kx hj">{ </strong>e <strong class="kx hj">-&gt;<br/>    </strong>logger.error("Exception occurred: ${e.message}")<br/>    val response = TextContent(e.message ?: "Bad Request",<br/>        ContentType.Text.Plain.<em class="lh">withCharset</em>(Charsets.UTF_8),<br/>        HttpStatusCode.BadRequest<br/>    )<br/>    <em class="lh">call</em>.respond(response)<br/><strong class="kx hj">}</strong></span></pre><h2 id="766c" class="lb ir hi bd is lw lx ly iw lz ma mb ja jz mc md je kd me mf ji kh mg mh jm mi bi translated">Valiktor</h2><ul class=""><li id="9b43" class="li lj hi jq b jr js jv jw jz mj kd mk kh ml kl mm lo lp lq bi translated">279 个 Github 星，10 个守望者，27 个分叉</li><li id="5caf" class="li lj hi jq b jr lr jv ls jz lt kd lu kh lv kl mm lo lp lq bi translated">上次提交时间:2020 年 10 月 11 日</li></ul><p id="4e96" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">图书馆马上升起了两个(次要的)红旗。<br/>第一个事实是，尽管声称自己是 DSL，但示例是 DSL 和 Builder type / fluent api 的混合:</p><pre class="ks kt ku kv fd kw kx ky kz aw la bi"><span id="3b22" class="lb ir hi kx b fi lc ld l le lf">data class Employee(val id: Int, val name: String, val email: String) {<br/>    init {<br/>        validate(this) {<br/>            validate(Employee::id).isPositive()<br/>            validate(Employee::name).hasSize(min = 3, max = 80)<br/>            validate(Employee::email).isNotBlank().isEmail()<br/>        }<br/>    }<br/>}</span></pre><p id="0718" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">第二个问题是验证不返回结果，而是抛出一个<em class="lh">ConstraintViolationException</em>，这对扁平的调用结构没有帮助。</p><p id="a464" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">在任何情况下，我仍然将一个简单的例子放在一起，作为真实应用程序的一部分来测试验证。使用一些扩展函数和<a class="ae km" href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/run-catching.html" rel="noopener ugc nofollow" target="_blank"> runCatching </a>，我去掉了大部分样板代码:</p><figure class="ks kt ku kv fd ij"><div class="bz dy l di"><div class="mn mo l"/></div></figure><p id="d4c2" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">实际的验证逻辑非常紧凑，包含可接受的样板代码:</p><pre class="ks kt ku kv fd kw kx ky kz aw la bi"><span id="f926" class="lb ir hi kx b fi lc ld l le lf">init {<br/>    <em class="lh">runCatching </em><strong class="kx hj">{<br/>        </strong><em class="lh">validate</em>(this) <strong class="kx hj">{<br/>            </strong>validate(Account::accountUUID).<em class="lh">matches</em>(<em class="lh">uuidRegex</em>)<br/>            validate(Account::createdAt).<em class="lh">isNotNull</em>()<br/>            validate(Account::modifiedAt).<em class="lh">isNotNull</em>()<br/>            validate(Account::status).<em class="lh">isNotNull</em>()<br/>        <strong class="kx hj">}<br/>    }</strong>.<em class="lh">throwOnFailure</em>()<br/>}</span></pre><p id="d884" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">向客户端显示的错误是自我解释的，尽管对我来说有点冗长:</p><blockquote class="mp mq mr"><p id="d94a" class="jo jp lh jq b jr kn jt ju jv ko jx jy ms kp kb kc mt kq kf kg mu kr kj kk kl hb bi translated">account uuid:defaultconstraintviolationmessage(property = account uuid，value = 20836570-d4ef-420 e-b500–7b7f 6，constraint=matches(pattern=^[0–9a-fa-f]{8}-[0–9a-fa-f]{4}-[0–9a-fa-f]{4}-[0–9a-fa-f]{4}-[0–9a-fa-f]{12}$)，message =必须与^[0–9a-fa-f]{8}-[0–9a-fa-f]{4}-[0–9a-fa-f]{4}-[0–9a-fa-f]{4}-[0–9a-fa-f]{12}$匹配)</p></blockquote><h2 id="a4dd" class="lb ir hi bd is lw lx ly iw lz ma mb ja jz mc md je kd me mf ji kh mg mh jm mi bi translated">Konform</h2><ul class=""><li id="f7a2" class="li lj hi jq b jr js jv jw jz mj kd mk kh ml kl mm lo lp lq bi translated">300 个 Github 星，10 个守望者，16 个叉子</li><li id="147d" class="li lj hi jq b jr lr jv ls jz lt kd lu kh lv kl mm lo lp lq bi translated">最后提交日期:2021 年 3 月 21 日</li></ul><p id="6e0d" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">这里我们有一个“真正的”DSL:</p><pre class="ks kt ku kv fd kw kx ky kz aw la bi"><span id="d886" class="lb ir hi kx b fi lc ld l le lf">val validateUser = Validation&lt;UserProfile&gt; {<br/>    UserProfile::fullName {<br/>        minLength(2)<br/>        maxLength(100)<br/>    }<br/><br/>    UserProfile::age ifPresent {<br/>        minimum(0)<br/>        maximum(150)<br/>    }<br/>}</span></pre><p id="c83d" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">与 Valiktor 的更长的<em class="lh">validate(Account::Account uuid)</em>相比，我喜欢非常短的<em class="lh"> Account::accountUUID </em>。</p><p id="cbd6" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">使用扩展函数进行调用和错误处理，我们为 Account 对象获得以下代码:</p><figure class="ks kt ku kv fd ij"><div class="bz dy l di"><div class="mn mo l"/></div></figure><p id="f4dd" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">实际的验证逻辑非常紧凑，样板代码甚至比 Valiktor 还要少:</p><pre class="ks kt ku kv fd kw kx ky kz aw la bi"><span id="1cca" class="lb ir hi kx b fi lc ld l le lf">init {<br/>    Validation&lt;Account&gt; <strong class="kx hj">{<br/>        </strong>Account::accountUUID <strong class="kx hj">{<br/>            </strong><em class="lh">pattern</em>(<em class="lh">uuidRegex</em>)<br/>        <strong class="kx hj">}<br/>        </strong>Account::createdAt <em class="lh">required </em><strong class="kx hj">{ }<br/>        </strong>Account::modifiedAt <em class="lh">required </em><strong class="kx hj">{ }<br/>        </strong>Account::status <em class="lh">required </em><strong class="kx hj">{ }<br/>    }</strong>.<em class="lh">validateAndThrowOnFailure</em>(this)<br/>}</span></pre><p id="609f" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">出现在客户面前的错误是自我解释的，并且非常简短:</p><blockquote class="mp mq mr"><p id="62f6" class="jo jp lh jq b jr kn jt ju jv ko jx jy ms kp kb kc mt kq kf kg mu kr kj kk kl hb bi translated">[验证错误(数据路径=。accountUUID，message =必须与预期模式匹配]]</p></blockquote><h1 id="f86e" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">裁决</h1><ol class=""><li id="0851" class="li lj hi jq b jr js jv jw jz mj kd mk kh ml kl ln lo lp lq bi translated">Konform(获胜者)</li><li id="5889" class="li lj hi jq b jr lr jv ls jz lt kd lu kh lv kl ln lo lp lq bi translated">Valiktor(亚军)</li><li id="e0b2" class="li lj hi jq b jr lr jv ls jz lt kd lu kh lv kl ln lo lp lq bi translated">验证(承诺)</li></ol><p id="8665" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">我仅仅触及了这些库的表面，一旦我添加了更复杂的验证，肯定会有更多的内容要讲，但目前我将并行使用 Konform 和 Valiktor。</p><p id="155a" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">请随意评论并提供反馈。编码快乐！</p><h1 id="3a4e" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">附录 1</h1><p id="e44f" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">添加此库<a class="ae km" href="https://github.com/michaelbull/kotlin-result" rel="noopener ugc nofollow" target="_blank">https://github.com/michaelbull/kotlin-result</a>Valiktor 的错误处理部分可更改为:</p><pre class="ks kt ku kv fd kw kx ky kz aw la bi"><span id="c83f" class="lb ir hi kx b fi lc ld l le lf">import com.github.michaelbull.result.Result<br/>import com.github.michaelbull.result.onFailure</span><span id="62df" class="lb ir hi kx b fi lg ld l le lf">fun &lt;V&gt; Result&lt;V, Throwable&gt;.throwOnFailure() {<br/>    <em class="lh">onFailure </em><strong class="kx hj">{<br/>        </strong>val error = (component2() as ConstraintViolationException)<br/>        throw IllegalArgumentException(error.<em class="lh">getMessage</em>())<br/>    <strong class="kx hj">}<br/></strong>}</span></pre><p id="f38b" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">runCatching 部分保持不变，只是多了一个导入:</p><pre class="ks kt ku kv fd kw kx ky kz aw la bi"><span id="7c0a" class="lb ir hi kx b fi lc ld l le lf">import com.github.michaelbull.result.*</span><span id="f9fe" class="lb ir hi kx b fi lg ld l le lf"><em class="lh">runCatching </em><strong class="kx hj">{<br/>    </strong><em class="lh">validate</em>(this) <strong class="kx hj">{<br/>        </strong>validate(Account::accountUUID).<em class="lh">matches</em>(<em class="lh">uuidRegex</em>)<br/>        validate(Account::status).<em class="lh">isNotNull</em>()<br/>    <strong class="kx hj">}<br/>}</strong>.<em class="lh">throwOnFailure</em>()</span></pre><h1 id="c9ec" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">增编 2</h1><p id="dee1" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">在试验不同的 JSON 序列化器/反序列化器库时(参见<a class="ae km" rel="noopener" href="/p/feae3d06eadb">https://medium.com/p/feae3d06eadb</a>)，我意识到在<em class="lh"> init { } </em>中触发验证不起作用，因为例如 GSON 在不使用主构造函数的情况下构造对象(参见例如<a class="ae km" href="https://stackoverflow.com/questions/52837665/why-kotlin-data-classes-can-have-nulls-in-non-nullable-fields-with-gson" rel="noopener ugc nofollow" target="_blank">why-kotlin-data-classes-can-have-nulls-in-non-nullable-fields-with-GSON</a>或<a class="ae km" href="https://stackoverflow.com/questions/54767493/data-class-init-function-is-not-called-when-object-generated-from-gson-in-kotlin" rel="noopener ugc nofollow" target="_blank">data-class-init-function-is-not-called-when-object-generated-from-GSON-in)因此，我必须通过将<em class="lh"> init {} </em>转换成常规的<em class="lh"> validate() </em>函数来改变验证的触发方式。大概是这样的:</a></p><pre class="ks kt ku kv fd kw kx ky kz aw la bi"><span id="5dce" class="lb ir hi kx b fi lc ld l le lf">data class Account(<br/>    var accountUUID: String,<br/>    var createdAt: Instant,<br/>    var modified: Instant,<br/>    var status: AccountStatus<br/>) {<br/>    fun validate(): Account {<br/>       // do validation</span></pre><p id="1dcd" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">在路由器中，我现在需要显式地调用 validate()函数，所以不用做:</p><pre class="ks kt ku kv fd kw kx ky kz aw la bi"><span id="552c" class="lb ir hi kx b fi lc ld l le lf">val account = <em class="lh">call</em>.receive&lt;Account&gt;()</span></pre><p id="a8be" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">我愿意:</p><pre class="ks kt ku kv fd kw kx ky kz aw la bi"><span id="2257" class="lb ir hi kx b fi lc ld l le lf">val account = <em class="lh">call</em>.receive&lt;Account&gt;().validate()</span></pre></div></div>    
</body>
</html>