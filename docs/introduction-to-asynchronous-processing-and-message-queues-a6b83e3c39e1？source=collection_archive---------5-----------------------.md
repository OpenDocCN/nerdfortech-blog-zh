# 异步处理和消息队列简介

> 原文：<https://medium.com/nerd-for-tech/introduction-to-asynchronous-processing-and-message-queues-a6b83e3c39e1?source=collection_archive---------5----------------------->

![](img/be7cd4d9c2930f36a19453a92b069f20.png)

# 介绍

在客户机-服务器体系结构中，客户机可以通过在彼此之间发送消息来请求服务器完成某项工作。

当您开始管理消息发送的速率、服务器可以处理的请求数量或客户端要求的响应时间时，处理这种通信会增加复杂性。

在这篇博客中，我们将看到一种处理这种复杂性的方法。

# 什么是同步处理？

在同步处理中，客户端向服务器发送请求，等待服务器完成其工作并发回响应，然后客户端才能继续执行任何其他工作。

这个过程通常被称为*阻塞*请求，因为在收到响应之前，客户端无法执行任何其他工作。

# 什么是异步处理？

异步处理与同步处理正好相反。这里，客户机在向服务器发送请求后不等待响应，而是继续做任何其他工作。

这个过程被称为*非阻塞*请求，因为客户端的执行线程没有被阻塞。这使得系统可以在给定的时间内完成更多的工作。

# 同步与异步处理

*   同步请求阻塞客户机的执行线程，迫使它们在执行另一个动作之前等待响应。另一方面，异步请求不会阻塞，允许在给定的时间内完成更多的工作。
*   因为我们不知道请求需要多少时间，所以很难构建具有同步处理的响应性应用程序。阻塞操作越多，系统就变得越慢。使用异步处理，响应时间很快，因为客户端不必等待请求。
*   异步处理的容错能力高于同步处理，因为当请求失败时，很容易建立重试机制。

![](img/dc9a8ee6b97364b6929dfd78b5d74cea.png)

# 什么是消息队列？

消息队列是缓冲来自一个服务的请求并异步广播到另一个服务的组件。

在这里，客户机是消息的生产者，它们向队列而不是任何服务器发送请求消息。当消息被添加到队列中时，它们会得到一个确认，这使它们能够继续执行其他作业，而不必等待服务器。

服务器被称为消息消费者，根据它们在任何给定时间可以服务的请求数量，从队列中获得这些消息。这种情况一直持续到队列中的所有消息都得到服务。

两个最常见的消息队列是— [RabbitMQ](https://www.rabbitmq.com/) 和 [Kafka](https://kafka.apache.org/) 。

# 消息队列的结构

消息队列主要是消息生产者和消息消费者之间的消息代理。

消息队列设置中的每个不同的实体(生产者、消费者和队列)都有各自的职责，并且它们尽可能地相互分离。

所有实体之间的唯一契约是消息，消息队列将消息从生产者转移到消费者。

在下面的小节中，我们将讨论每个组件的职责，并研究消息队列向消费者传递消息的各种模式。

# 消息生产者

消息生产者发起异步处理请求。生产者有责任生成有效的消息并将其发布到消息队列。提交到队列的消息随后排队并交付给消费者进行异步处理。

生成器使用高级消息队列协议(AMQP)与消息队列进行通信。

# 消息代理

消息代理只是一个队列。您甚至可以以编程方式实现一个简单的代理，该代理缓冲消息并在需要时将其发送给消费者。

消息代理是设置中实际的解耦元素，位于生产者和消费者之间，并管理生产者和消费者之间的通信过程。

由于其简单性，代理针对高并发性和吞吐量进行了优化。

值得注意的是，添加消息代理会给基础设施带来额外的复杂性，并且需要您对其进行扩展。谈到可伸缩性，代理也有特定的要求和限制。

# 消息消费者

消费者的主要职责是接收和处理队列中的消息。

大多数消费者是执行实际异步处理的 API 服务。

消费者可以用不同的应用程序语言或技术实现，并独立于其他组件进行维护。

为了实现脱钩，消费者应该对生产者一无所知。两者之间应该存在的唯一契约是来自队列的有效消息。

正确分离后，使用者可以作为独立的服务层，消息队列设置和基础设施中的其他组件都可以使用它们。

# 消费者沟通策略

消息队列需要将消息向下传输给消费者，这取决于应用程序开发人员如何实现消费者，消息队列有三种不同的方式将消息传递给消费者:

*   **拉动模式**

在这个模型中，消费者定期检查队列的状态。这是在用户方编程的预定间隔内完成的。

如果在队列中发现了消息，则消费者将拾取它们，直到不再有消息需要处理，或者当“N”条消息被使用完。这个“N”可以在消息代理上配置。

*   **推送模式**

一旦添加了消息，消费者就会得到通知，然后消息就会被推送到消费者那里。消息以消费者可以轻松调节的速度被推送到消费者手中。

*   **订阅模式**

在这个模型中，消费者可以订阅一个主题。此发布者将消息发布到主题，而不是队列。连接到代理的每个消费者维护其私有队列，以接收来自主题的消息。

在消费者订阅主题之后，当消息发布到该主题时，将为每个订阅者克隆消息，并将其添加到消费者的私有队列中。

# 比较不同的消息代理

正如我们在上面看到的，对于异步通信，我们通常需要一个消息代理。

下面是在选择代理来管理异步操作时必须考虑的几个问题:

*   **规模**:系统中每秒发送的消息数量
*   **数据持久性**:恢复消息的能力
*   **消费者能力**:管理一对一/一对多消费者的能力

# 兔子 q

*   规模:基于配置和资源。
*   持久性:支持持久性和瞬时性消息。
*   一对一与一对多消费者:两者皆有。

RabbitMQ 支持所有主流语言，包括 Python、Java、.NET、PHP、Ruby、JavaScript、Go、Swift 等等。

# 卡夫卡

*   规模:每秒可以发送多达一百万条消息。
*   坚持:是的。
*   一对一与一对多消费者:只有一对多

卡夫卡在 Azure 和 AWS 上都管理过 SaaS。Kafka 还支持所有主流语言，包括 Python、Java、C/C++、Clojure、。NET、PHP、Ruby、JavaScript、Go、Swift 等等。

# 雷迪斯

*   规模:每秒可以发送多达一百万条消息。
*   持久性:不支持(它是一个内存数据库)。
*   一对一与一对多消费者:两者皆有。

Redis 与其他消息代理略有不同。Redis 是内存中的数据存储。最初，Redis 只支持与消费者一对一的交流。然而，由于 Redis 5.0 引入了发布订阅，您可以选择一对多作为另一种选择。

# 结论

在这篇博客中，我们介绍了异步处理如何优于它的同类处理，以及消息队列如何帮助我们实现异步处理，同时保持其设置中的不同实体相互解耦。

我们还讨论了最常用的消息代理的一些基本特征:Redis、Kafka 和 RabbitMQ。

下面是根据不同用例选择正确的消息代理的更多说明:

**短期消息:Redis**

*   Redis 适用于不需要持久性的短期消息。

**大量数据:卡夫卡**

*   Kafka 适合长期存储大量数据。Kafka 对于需要持久性的一对多用例也是理想的。

**复杂路由:RabbitMQ**

*   RabbitMQ 适用于复杂的路由通信。

编码快乐！💻

(如果您发现任何疑问、更新或更正来改进本文，请在评论中分享)😊

# 从 Web 开发开始？

查看 [**HTML 反应过来:终极指南**](https://gumroad.com/a/316675187)

这本电子书是一个全面的学习指南，通过大量易于理解的例子和经过验证的路线图，它将教你**成为一个自信的网络开发者所需要知道的一切**

有了这个链接，就可以拿**六折。**

[![](img/198b6c32d194de7f3738a144ee9e8650.png)](https://gumroad.com/a/316675187)

HTML 反应:完整的网络开发电子书

*(原载于*[*【https://dev.to/apoorvtyagi.*](https://dev.to/apoorvtyagi/introduction-to-asynchronous-processing-and-message-queues-27od)*)*