<html>
<head>
<title>Word Embedding : Text Analysis : NLP : Part-3 : GloVe</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">单词嵌入:文本分析:自然语言处理:第3部分:手套</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/word-embedding-text-analysis-nlp-part-3-glove-and-fasttext-da21d074237a?source=collection_archive---------9-----------------------#2021-05-09">https://medium.com/nerd-for-tech/word-embedding-text-analysis-nlp-part-3-glove-and-fasttext-da21d074237a?source=collection_archive---------9-----------------------#2021-05-09</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="e64f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="jd">手套背后的直觉</em></p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es je"><img src="../Images/045c2fd37fabe1f2e28218dd2702a765.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dE3x06aqf5UF9aLvQu044Q.png"/></div></div></figure><p id="38dc" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">正如我们在Word2Vec的前一篇文章中看到的，它可以获取单词的局部统计信息，而“全局向量”(GloVe)可以满足单词的全局上下文信息，这意味着它也可以处理未见过的单词。手套模型于2014年由Jeffrey Pennington、Richard Socher和Christopher D. Manning推出。然而，Word2Vec有一些缺点，但结合LDA可以生成手套模型。因此，我们也将使用Word2Vec来构建手套模型。</p><h1 id="535f" class="jq jr hi bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">手套</h1><p id="76ee" class="pw-post-body-paragraph if ig hi ih b ii ko ik il im kp io ip iq kq is it iu kr iw ix iy ks ja jb jc hb bi translated">我们可以借助共现矩阵来推导单词之间的语义关系。给定一个语料库有U个单词，那么共现矩阵X将是<strong class="ih hj"> UxX </strong>。在这个矩阵中<strong class="ih hj"> <em class="jd"> ith </em> </strong> raw和<strong class="ih hj"> <em class="jd"> jth </em> </strong>列将代表<strong class="ih hj"> <em class="jd"> Xij </em> </strong>即2个字在<strong class="ih hj"> <em class="jd"> ith </em> </strong> raw和<strong class="ih hj"> <em class="jd"> jth </em> </strong>列位置出现的值。我们可以看到共生矩阵的图示。</p><p id="83c7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">例如，我们有下面两个句子</p><p id="403c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">数据是下一个石油。</p><p id="8276" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">数据是未来。</p><p id="bdf1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">基于这两个句子，我们可以建立下面的共现矩阵。最后，设<strong class="ih hj"><em class="jd">P(j | I)= Xij/Xi</em></strong>为单词j在I的上下文中出现的概率，这里，在下表中如果我们要计算P(Data|is) = 2/4，</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es kt"><img src="../Images/70bc81e52f137f05b986bdd5c244593a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*k5cnHXLNFVuweeZz0YKKLg.png"/></div></div></figure><p id="2fef" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们以一篇研究论文中的同一个例子来说明共现矩阵的威力，以及我们如何使用该矩阵来计算单词之间的语义相似度。让我们举一个上面提到的研究论文中的例子。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es ku"><img src="../Images/b4c9ed18c9d259cde517a021290d9008.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*K-dFXYqFrO4Zb-ienoIOXw.png"/></div></div><figcaption class="kv kw et er es kx ky bd b be z dx translated">来源:-<a class="ae kz" href="https://nlp.stanford.edu/pubs/glove.pdf" rel="noopener ugc nofollow" target="_blank">https://nlp.stanford.edu/pubs/glove.pdf</a></figcaption></figure><p id="3f08" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">T31】P _ ik/P _ JKT33】其中<strong class="ih hj">T35】P _ ik = X _ ik/X _ I .T37】</strong></strong></p><p id="4909" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">所以根据上面的公式和表格，我们可以看到固体冰的概率比气体冰的概率高。这样我们可以看到，每当单词相关时，概率很高，单词不相关时，概率很低。但是当一个词与更多的词相关时，例如水与蒸汽和冰相关，那么在这些情况下我们会得到高概率。为了解决这个问题<strong class="ih hj"> <em class="jd"> P_ik/P_jk </em> </strong>被采用。</p><p id="2172" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">因此，当我们试图直接使用这个共生矩阵时，它会有一个维数问题，它是以百万计的。因此，GloVe引入了使用Word2Vec的共生矩阵来解决这个问题。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div class="er es la"><img src="../Images/6959e6287a1bff7e3a372e0af4238e07.png" data-original-src="https://miro.medium.com/v2/resize:fit:526/format:webp/1*z8KItM8kdTYPuGOo1K-3eA.png"/></div><figcaption class="kv kw et er es kx ky bd b be z dx translated">来源:【https://nlp.stanford.edu/pubs/glove.pdf】T42</figcaption></figure><p id="b1d0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们可以在上面的公式中看到，我们使用了单词向量<strong class="ih hj"> <em class="jd"> i，j，k </em> </strong>，其中k是上下文向量。所以当我们传递函数F的这三个向量时，我们会得到概率比。</p><p id="6ece" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">让我们来研究方程式</strong></p><p id="5eed" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">根据上述等式，我们必须处理几个问题。首先，我们有一个标量的概率比，左边是向量，所以我们必须把向量转换成标量。第二，选择一个函数F应用于向量。第三，我们有3个变量<strong class="ih hj"> <em class="jd"> i，j，k </em> </strong>，很难用3个变量准备成本函数。让我们一步步解决这些问题。</p><ol class=""><li id="0d8d" class="lb lc hi ih b ii ij im in iq ld iu le iy lf jc lg lh li lj bi translated">为了将向量转换成标量，我们将使用两个向量的点积，但问题是我们这里有三个向量。所以，我们对I和j向量做向量减法。这是从Word2Vec模型中提取的，因为我们可以在单词之间进行类比，并对其进行转置以匹配维度。我们可以在下面的公式中看到这一点。</li></ol><figure class="jf jg jh ji fd jj er es paragraph-image"><div class="er es lk"><img src="../Images/c2211f104bce45604dde2ffb47079d42.png" data-original-src="https://miro.medium.com/v2/resize:fit:642/format:webp/1*DQVtFJ0hVpA1oUGrEKCrxQ.png"/></div></figure><p id="151f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">2.那么F是什么呢，它是基于减群和除群之间的同态得到的，就像这样。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div class="er es ll"><img src="../Images/8977bb19174f744b194f6c135400a8bd.png" data-original-src="https://miro.medium.com/v2/resize:fit:854/format:webp/1*cwW3Gp2sFeiYn71e0ISPKA.png"/></div></figure><p id="69b1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">同样，这种特殊的同态保证了<strong class="ih hj"> <em class="jd"> F(X-Y) </em> </strong>的减法可以作为除法<strong class="ih hj"> <em class="jd"> F(X)/F(Y) </em> </strong>给出并得到相同的结果。</p><p id="7592" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在上述公式的解是</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div class="er es lm"><img src="../Images/c1e66a401162b4dcaca6e9fcb11da400.png" data-original-src="https://miro.medium.com/v2/resize:fit:650/format:webp/1*jCw40wvfApdVQwC2jNbhfg.png"/></div></figure><p id="d6f7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">根据给定的计算，我们可以得出结论，我们可以把解决方案作为一个指数函数。所以公式应该是这样的。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es ln"><img src="../Images/5afda9bf5813c455bc52c7a6732131ef.png" data-original-src="https://miro.medium.com/v2/resize:fit:970/format:webp/1*XGQ5-DlJsN-HI8ASEZKdrA.png"/></div></div></figure><p id="e8dc" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为了方程的对称性，我们来介绍一下上面方程中的一些偏置<strong class="ih hj"> <em class="jd"> bi </em> </strong>和<strong class="ih hj"> <em class="jd"> bk </em> </strong>。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div class="er es lo"><img src="../Images/82605557f23d363dea1c24cebc2838a2.png" data-original-src="https://miro.medium.com/v2/resize:fit:698/format:webp/1*2Wb4P6DEjtLkBAA12ydbrA.png"/></div></figure><p id="16a1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">3.现在是研究成本函数的时候了。上式中的问题是当<strong class="ih hj"> <em class="jd"> Xik </em> </strong>为0时。一种解决方案是在对数中包括加法移位，<strong class="ih hj"><em class="jd">【log(Xik)→log(1+Xik)</em></strong>，这被称为拉普拉斯变换，其保持了X的稀疏性，同时避免了发散。这是LSA的财产，通过这种方式，我们将LSA和Word2Vec结合起来，生成GloVe。</p><p id="4862" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">添加这部分后，问题是，即使在很少出现协方差矩阵后，它们的权重也是相等的。因此，为了解决这些问题，添加了加权回归模型，并将加权函数<strong class="ih hj"><em class="jd">【f(Xij)</em></strong>加入到成本函数中。所以，成本函数公式应该是这样的。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div class="er es lp"><img src="../Images/2f337d84f01d3631e0bd1a32e1f1526e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1114/format:webp/1*ktRl2X02lx9WG2wEyHGIOA.png"/></div></figure><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es lq"><img src="../Images/f445ca131c317fd5256f29344931ac6b.png" data-original-src="https://miro.medium.com/v2/resize:fit:842/format:webp/1*gCNwWIx43ppn8vpwEl8F2Q.png"/></div></div></figure><p id="31b2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这里，我们在定义F时已经去掉了前一个公式中的第三个向量k。因此，<strong class="ih hj"> <em class="jd"> j </em> </strong>在这个公式中将像上下文向量一样工作。</p><h1 id="1420" class="jq jr hi bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated"><strong class="ak">手套模型的实现</strong></h1><figure class="jf jg jh ji fd jj"><div class="bz dy l di"><div class="lr ls l"/></div></figure><p id="0522" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">接下来，我们将看看用于嵌入的FastText。衷心欢迎提出建议。</p><h1 id="eb43" class="jq jr hi bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">参考</h1><ol class=""><li id="494c" class="lb lc hi ih b ii ko im kp iq lt iu lu iy lv jc lg lh li lj bi translated"><a class="ae kz" rel="noopener" href="/analytics-vidhya/glove-theory-and-python-implementation-b706aea28ac1">https://medium . com/analytics-vid hya/glove-theory-and-python-implementation-b 706 AEA 28 AC 1</a></li><li id="1c02" class="lb lc hi ih b ii lw im lx iq ly iu lz iy ma jc lg lh li lj bi translated">https://nlp.stanford.edu/projects/glove/<a class="ae kz" href="https://nlp.stanford.edu/projects/glove/" rel="noopener ugc nofollow" target="_blank"/></li></ol></div></div>    
</body>
</html>