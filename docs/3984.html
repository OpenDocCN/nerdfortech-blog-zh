<html>
<head>
<title>JS Decorators for mongoose model from scratch</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">从零开始为猫鼬模型的 JS 装饰</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/js-decorators-for-mongoose-model-from-scratch-cc329a36d412?source=collection_archive---------5-----------------------#2021-07-02">https://medium.com/nerd-for-tech/js-decorators-for-mongoose-model-from-scratch-cc329a36d412?source=collection_archive---------5-----------------------#2021-07-02</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/dae39c7be37adb2c7c5b073fe865b8ca.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nIO9zHIGk94uWLQ-XwRd9g.png"/></div></div></figure><p id="6a1c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">任何优秀的开发人员都很好奇这些东西是如何工作的。我们将尝试使用 decorator 来消除一个缺点，这个缺点你可能已经在一些关于 mongoose API 和 TypeORM 的讨论中听说过了(我在这里发现了惊人的对比<a class="ae jo" href="https://eliezer.medium.com/typeorm-mongodb-review-8855903228b1" rel="noopener"/>)。这是一种快速揭开事物神秘面纱的神奇方式——弄脏我们的手。让我们看看 decorators 如何在您使用 mongoose API 的情况下发挥作用。</p><p id="cd81" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这里有一个缺点:<em class="jp">如果您希望您的模型支持 TS 类型，您需要定义 Mongo 模式和 TypeScript 类型</em>。在代码中，它可能是这样的:</p><figure class="jq jr js jt fd ij"><div class="bz dy l di"><div class="ju jv l"/></div></figure><p id="88f0" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">对于这个小模型来说，这没什么大不了的，但是我们可能会忘记在类型中添加新的属性也需要更新模式定义。有很多库已经用不同的方式解决了这个问题，但是在这里我看到这是一个很好的机会来探索 decorator 的用法并简要概述可能使用的技术。</p><p id="52ee" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们的目标是定义模型类型，并提出一种方法来创建模型，减少 props 和 schema 不匹配的可能性。</p><p id="ecb2" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">首先，我们需要知道，所有的 TS 类型和接口在转换阶段都被删除了，为了装饰器的使用，因此要定义新的模型类型，我们应该使用<em class="jp">类</em>关键字，TS 将<em class="jp">类</em>视为一个类型，在转换后不会被删除。让我们从模型的定义开始:</p><figure class="jq jr js jt fd ij"><div class="bz dy l di"><div class="ju jv l"/></div></figure><p id="d8de" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">让我们定义工厂函数，在这里我们将传递我们的模型类，它将创建 mongoose 模型:</p><figure class="jq jr js jt fd ij"><div class="bz dy l di"><div class="ju jv l"/></div></figure><p id="df2e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">ModelFactory 的实现如下所示:</p><figure class="jq jr js jt fd ij"><div class="bz dy l di"><div class="ju jv l"/></div></figure><p id="1461" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们稍后会回来提取<em class="jp">模型名称</em>和<em class="jp">模式元数据</em>。</p><p id="93f6" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">嗯，<em class="jp"> modelName </em>它只是一个带有我们数据库集合名称的字符串。为了提取这个名字，我们可以声明第一个装饰器<em class="jp">模式</em>，我们将它放在类声明下，它帮助我们提取这个名字:</p><figure class="jq jr js jt fd ij"><div class="bz dy l di"><div class="ju jv l"/></div></figure><p id="bd1c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">Decorator 非常简单，它只是获取<em class="jp">目标</em>什么是类构造函数，并调用<em class="jp">typemetadastorage . addschemametadata</em>方法，该方法将元数据存储在内存中。让我们回顾一下<em class="jp">类型元数据存储</em>的实现:</p><figure class="jq jr js jt fd ij"><div class="bz dy l di"><div class="ju jv l"/></div></figure><p id="1647" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这里没什么特别的，只是存储在内存映射中，这里的键是我们的构造函数和它们相关的选项。让我们使用这个装饰器:</p><figure class="jq jr js jt fd ij"><div class="bz dy l di"><div class="ju jv l"/></div></figure><p id="8843" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">对于<em class="jp">类型元数据存储</em>，我们需要定义方法，该方法将通过目标类解析集合数据库名称(<em class="jp"> getSchemaMetadata </em>方法):</p><figure class="jq jr js jt fd ij"><div class="bz dy l di"><div class="ju jv l"/></div></figure><p id="9139" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在我们可以在我们的工厂方法中使用它，该方法通过我们前面留下的类声明来构建模型，现在我们可以从元数据中定义我们的 DB 集合名称:</p><figure class="jq jr js jt fd ij"><div class="bz dy l di"><div class="ju jv l"/></div></figure><p id="c5d2" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">第一步完成了。现在让我们实现<em class="jp"> Prop </em> decorator，它可以跟踪我们属性的 Mongoose 定义。这将是一个简单的实现，我们可以调用没有道具的<em class="jp">道具</em>装饰器，并允许它从属性声明中推断类型，或者只是用 Mongoose SchemaDefinition 放置标准对象，有两种方法可以使用它:</p><figure class="jq jr js jt fd ij"><div class="bz dy l di"><div class="ju jv l"/></div></figure><p id="53b4" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">以下是 Prop decorator 的实现:</p><figure class="jq jr js jt fd ij"><div class="bz dy l di"><div class="ju jv l"/></div></figure><p id="f7e1" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这里也没什么特别的，我们只是将所有元数据存储在内存中。只有一件事需要提及，当 decorator 在没有选项的情况下调用时，我们试图使用外部库<a class="ae jo" href="https://www.npmjs.com/package/reflect-metadata" rel="noopener ugc nofollow" target="_blank"> reflect-metadata </a>隐式定义类型。并且不要忘记为您的<em class="jp"> tsconfig.json </em>打开以下属性:</p><figure class="jq jr js jt fd ij"><div class="bz dy l di"><div class="ju jv l"/></div></figure><p id="031c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们还需要实现 type metadata . addpropertymetdata 方法:</p><figure class="jq jr js jt fd ij"><div class="bz dy l di"><div class="ju jv l"/></div></figure><p id="8a76" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">addPropertyMetdata 是非常简单的方法，我们只需将所有参数保存在内存中。我们还定义了<em class="jp">getPropertiesDefinitions</em>，它构造了所有与目标类对象相关联的 mongose<em class="jp">ShemaDefinitions</em>。让我们完成我们的工厂方法:</p><figure class="jq jr js jt fd ij"><div class="bz dy l di"><div class="ju jv l"/></div></figure><p id="8749" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">就这样，我们只需要测试实现了什么。这是我们的模型:</p><figure class="jq jr js jt fd ij"><div class="bz dy l di"><div class="ju jv l"/></div></figure><p id="7f99" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这里是我们使用它的索引文件:</p><figure class="jq jr js jt fd ij"><div class="bz dy l di"><div class="ju jv l"/></div></figure><p id="80b7" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">运行该文件后，我们按预期保存了实体:</p><figure class="jq jr js jt fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es jw"><img src="../Images/649b501801a37104318cd42b7c56776b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CEYjZIpXhpp9g6-a0cwMjg.png"/></div></div></figure><p id="4e11" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我希望本教程给出了一个使用 decorators 的要点，它受到了<a class="ae jo" href="https://www.npmjs.com/package/@nestjs/mongoose" rel="noopener ugc nofollow" target="_blank">@ nestjs/mongose</a>模块的启发，你可以深入到它们的实现中，并且本教程肯定会加速它。一些使用<a class="ae jo" href="https://www.npmjs.com/package/@nestjs/mongoose" rel="noopener ugc nofollow" target="_blank">@ nestjs/mongose</a>的文档可以在这里找到<a class="ae jo" href="https://docs.nestjs.com/techniques/mongodb" rel="noopener ugc nofollow" target="_blank"><em class="jp"/></a>。</p><p id="7bd9" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如果你需要深入教程代码，你可以在这里找到<a class="ae jo" href="https://github.com/vladimirtopolev/decorators-mongoose" rel="noopener ugc nofollow" target="_blank"><em class="jp"/></a>。</p></div></div>    
</body>
</html>