<html>
<head>
<title>Introduction to SOLID Design Principles</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">固体设计原理介绍</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/introduction-to-solid-design-principles-94a9394eb84e?source=collection_archive---------1-----------------------#2020-02-19">https://medium.com/nerd-for-tech/introduction-to-solid-design-principles-94a9394eb84e?source=collection_archive---------1-----------------------#2020-02-19</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><h1 id="e011" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">介绍</h1><ol class=""><li id="0f35" class="jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju bi translated">坚实的原则是这样的设计原则，它使用户能够管理大部分的软件设计问题，无论是大规模的还是小规模的。</li><li id="b58a" class="jd je hi jf b jg jv ji jw jk jx jm jy jo jz jq jr js jt ju bi translated">术语 SOLID 是五个设计原则的首字母缩写，旨在使软件设计更易于理解、灵活和维护。</li></ol><h1 id="2ecf" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated"><strong class="ak">坚实的标准是为了什么？</strong></h1><figure class="kb kc kd ke fd kf er es paragraph-image"><div role="button" tabindex="0" class="kg kh di ki bf kj"><div class="er es ka"><img src="../Images/ced00123d7aa8d803d4d914a4cc9ac69.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*wtcxkFhtNwnOWLTG.png"/></div></div></figure><h1 id="c171" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated"><strong class="ak">单一责任原则</strong></h1><p id="f9f6" class="pw-post-body-paragraph km kn hi jf b jg jh ko kp ji jj kq kr jk ks kt ku jm kv kw kx jo ky kz la jq hb bi translated">每个模块或类应该只负责软件提供的功能的一个部分。一个类可以有许多属性和方法，所有这些属性和方法都指向一个责任。</p><p id="4fab" class="pw-post-body-paragraph km kn hi jf b jg lb ko kp ji lc kq kr jk ld kt ku jm le kw kx jo lf kz la jq hb bi translated">这个原则被 Robert C. Martin 表述为<strong class="jf hj">“类应该有且只有一个改变的理由”</strong>。这意味着一个类应该只有一个作业。</p><p id="2077" class="pw-post-body-paragraph km kn hi jf b jg lb ko kp ji lc kq kr jk ld kt ku jm le kw kx jo lf kz la jq hb bi translated">这个原则的好处是更小的类更容易阅读、维护和单元测试，更低的耦合和微服务组织。</p><figure class="kb kc kd ke fd kf er es paragraph-image"><div role="button" tabindex="0" class="kg kh di ki bf kj"><div class="er es lg"><img src="../Images/2188d34dbac99b1f7369521d956db35f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UdtQxTZa6zQ3_eWHxAzV3A.png"/></div></div></figure><h1 id="b693" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated"><strong class="ak">打开/关闭原理</strong></h1><p id="b8ff" class="pw-post-body-paragraph km kn hi jf b jg jh ko kp ji jj kq kr jk ks kt ku jm kv kw kx jo ky kz la jq hb bi translated">原则规定<strong class="jf hj">“软件实体<em class="lh">(类、模块、功能等。)</em>应该对扩展开放，但对修改关闭"</strong>。</p><p id="9acc" class="pw-post-body-paragraph km kn hi jf b jg lb ko kp ji lc kq kr jk ld kt ku jm le kw kx jo lf kz la jq hb bi translated">这意味着代码的设计和编写应该以这样一种方式完成，即编码新功能(对扩展开放)应该能够在不改变现有代码(对修改关闭)的情况下集成。</p><p id="21c4" class="pw-post-body-paragraph km kn hi jf b jg lb ko kp ji lc kq kr jk ld kt ku jm le kw kx jo lf kz la jq hb bi translated">将类实现为抽象类，将方法实现为抽象方法，它促进了接口的使用，使您能够在不更改现有代码的情况下调整应用程序的功能。这使得松散耦合成为可能。</p><figure class="kb kc kd ke fd kf er es paragraph-image"><div role="button" tabindex="0" class="kg kh di ki bf kj"><div class="er es li"><img src="../Images/b82f1b409a7d36120f9341a592ed15bd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*AifHz5AUOpaTnc6k.png"/></div></div></figure><h1 id="f845" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated"><strong class="ak">利斯科夫替代原理</strong></h1><p id="2551" class="pw-post-body-paragraph km kn hi jf b jg jh ko kp ji jj kq kr jk ks kt ku jm kv kw kx jo ky kz la jq hb bi translated">这个原则是 OCP 的扩展，是 Barbara Liskov 于 1987 年在她关于数据抽象和层次的会议演讲中提出的。她说超类的对象应该可以被它的子类替换，这意味着派生类型必须完全可以替换它们的基本类型。</p><blockquote class="lj lk ll"><p id="7dc4" class="km kn lh jf b jg lb ko kp ji lc kq kr lm ld kt ku ln le kw kx lo lf kz la jq hb bi translated">例如:如果 S 是 T 的子类型，那么 T 类型的对象可以用 S 类型的对象替换。</p></blockquote><p id="0a5c" class="pw-post-body-paragraph km kn hi jf b jg lb ko kp ji lc kq kr jk ld kt ku jm le kw kx jo lf kz la jq hb bi translated">由于面向对象编程中的继承概念，它要求子类(子类)的对象与其超类(父类)的对象行为相同。</p><figure class="kb kc kd ke fd kf er es paragraph-image"><div class="er es lp"><img src="../Images/ccee1498bf530254e9a3313cd2e9a958.png" data-original-src="https://miro.medium.com/v2/resize:fit:1238/format:webp/1*4Z02zfWt2tiNXRfpuUg9PQ.png"/></div></figure><h1 id="bca7" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated"><strong class="ak">界面分离原理</strong></h1><p id="0f28" class="pw-post-body-paragraph km kn hi jf b jg jh ko kp ji jj kq kr jk ks kt ku jm kv kw kx jo ky kz la jq hb bi translated">“许多特定于客户端的接口比一个通用接口要好”。我们不应该强迫客户在他们不使用的接口上实现。</p><p id="41c3" class="pw-post-body-paragraph km kn hi jf b jg lb ko kp ji lc kq kr jk ld kt ku jm le kw kx jo lf kz la jq hb bi translated">更容易违背这个概念，尤其是当软件最终增长时，当新的需求出现并且必须添加越来越多的特性时。我们可以把它分解成更小的接口，而不是创建一个更大的接口，以确保实现类只需要关心方法，每个方法为一个子模块服务。</p><figure class="kb kc kd ke fd kf er es paragraph-image"><div role="button" tabindex="0" class="kg kh di ki bf kj"><div class="er es lq"><img src="../Images/8b6b423cdb8ef2aeb60f64bfe394965c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*uw6QnUGx7BFRMlmZ.png"/></div></div></figure><h1 id="ab38" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated"><strong class="ak">依存倒置原则</strong></h1><p id="825e" class="pw-post-body-paragraph km kn hi jf b jg jh ko kp ji jj kq kr jk ks kt ku jm kv kw kx jo ky kz la jq hb bi translated">这个原则表示“高级模块不应该依赖于低级模块。两者都应该依赖于抽象”。该原则还指出，抽象不应该依赖于细节。细节应该依赖于抽象。</p><p id="d93b" class="pw-post-body-paragraph km kn hi jf b jg lb ko kp ji lc kq kr jk ld kt ku jm le kw kx jo lf kz la jq hb bi translated">该原理的主要目的是减少耦合，这可以通过遵循开闭原理和利斯科夫替代原理来实现。</p><figure class="kb kc kd ke fd kf er es paragraph-image"><div class="er es lr"><img src="../Images/5970dfca75a1661b5fd07401b18eec14.png" data-original-src="https://miro.medium.com/v2/resize:fit:1296/format:webp/0*v4mxtHtFNNjSIMVb.png"/></div></figure><h1 id="c05c" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">优势坚实的原则帮助我们</h1><ol class=""><li id="0bb9" class="jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju bi translated">实现代码复杂度的降低。</li><li id="39e5" class="jd je hi jf b jg jv ji jw jk jx jm jy jo jz jq jr js jt ju bi translated">增加可读性、可扩展性和可维护性。</li><li id="bfbf" class="jd je hi jf b jg jv ji jw jk jx jm jy jo jz jq jr js jt ju bi translated">减少错误并实现可重用性。</li><li id="a803" class="jd je hi jf b jg jv ji jw jk jx jm jy jo jz jq jr js jt ju bi translated">实现更好的可测试性</li><li id="6485" class="jd je hi jf b jg jv ji jw jk jx jm jy jo jz jq jr js jt ju bi translated">减少紧耦合。</li></ol></div></div>    
</body>
</html>