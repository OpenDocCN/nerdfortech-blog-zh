<html>
<head>
<title>Talk about Go: A simple implement of Circuit Breaker</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">谈谈 Go:断路器的一种简单实现</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/talk-about-go-a-simple-implement-of-circuit-breaker-486c7bb58cda?source=collection_archive---------1-----------------------#2022-06-09">https://medium.com/nerd-for-tech/talk-about-go-a-simple-implement-of-circuit-breaker-486c7bb58cda?source=collection_archive---------1-----------------------#2022-06-09</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/3d71e8233c55822ac1cac10c3407d9cd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*W0rfpz-8N3DF2qaGOKTfSA.jpeg"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">断路器</figcaption></figure><p id="4676" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">一个简单的断路器实现，当你的 API(或接口)在一段时间内达到<strong class="iw hj">高错误率时，触发快速失效并快速返回。</strong></p><h1 id="4fe9" class="js jt hi bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">序</h1><p id="1a0b" class="pw-post-body-paragraph iu iv hi iw b ix kq iz ja jb kr jd je jf ks jh ji jj kt jl jm jn ku jp jq jr hb bi translated">断路器可以说是微服务通话中出现的高频词。它最早来源于老宅电路的保险丝(电源过载-跳闸)，后来被股市行业用来形容出现异常情况，暂时暂停交易，开始保护市场现场。</p><p id="15ef" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">在微服务环节中，断路器在短时间内引用 API 上的<strong class="iw hj">多次异常/超时</strong>(<strong class="iw hj">过度错误率</strong>)</p></div><div class="ab cl kv kw gp kx" role="separator"><span class="ky bw bk kz la lb"/><span class="ky bw bk kz la lb"/><span class="ky bw bk kz la"/></div><div class="hb hc hd he hf"><p id="0c92" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw hj">动态调整</strong> <br/>保险丝的核心功能是“动态调整”，也就是说，在一定的时间窗口内，当 API 上的错误数，或者比值达到一个危险值时，保险丝必须<strong class="iw hj">持有</strong>请求，快速返回(失败)，并通知上游 API <strong class="iw hj"> n <em class="lc"> eed 冷静下来。</em> </strong></p><p id="6607" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">关于<strong class="iw hj">动态调整，</strong>主要有以下参数:</p><ul class=""><li id="9300" class="ld le hi iw b ix iy jb jc jf lf jj lg jn lh jr li lj lk ll bi translated"><strong class="iw hj">阈值</strong>:包括两个指标:统计的最小次数和出错的比例。最小数量的统计用于捕获高频请求，即请求量必须至少大于，断路器才开始关心差错率。否则，其他低频 API 上的少量故障会触发断路器。</li><li id="b88c" class="ld le hi iw b ix lm jb ln jf lo jj lp jn lq jr li lj lk ll bi translated"><strong class="iw hj">回合间隔:</strong>熔断调度的时间窗口，可以类比为限流算法中的单位时间，即熔断周期内 API 的总次数和错误计数复位的时间。</li></ul><p id="590d" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw hj">恢复间隔</strong></p><p id="8cdd" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">断路器触发后，多长时间的空闲期给予 API 的重试权限，并尝试纠正它，恢复到正常状态。</p><p id="bc89" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw hj"> round interval </strong>和<strong class="iw hj"> recover interval </strong>的主要区别在于，熔丝复位计数后，API 必须再次达到错误率才能触发熔丝，而 recover interval 只是允许当前熔断的 API 请求，错误率还是很高的。如果在请求仍未恢复的情况下再次尝试，请保持熔断状态，并等待下一个恢复周期或复位周期。所以<strong class="iw hj">恢复期</strong> &lt; <strong class="iw hj">回合间隔</strong>。</p><p id="d89c" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">关于状态转换，这个示例图更清楚:</p><figure class="ls lt lu lv fd ij er es paragraph-image"><div class="er es lr"><img src="../Images/de6235f90122c0211a74466d621cd5ec.png" data-original-src="https://miro.medium.com/v2/resize:fit:1192/format:webp/0*cNcdAcB3E6QqVYGZ.png"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">CBK 地位</figcaption></figure><p id="531c" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw hj"> AOP 模式</strong> <br/>熟悉了 fuse 的基本用途，我们来分析一下它的组件在项目中的位置。相信你会明白切片导向的概念。许多常见的组件，如流量限制和断路器保护，都是面向切片的模块，通常用于收集和报告流量状况，并根据特定的规则保护下游。最常见的是将它们放在网关层。</p><p id="deba" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw hj">如下图所示:</strong></p><figure class="ls lt lu lv fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lw"><img src="../Images/33276c53a1ba4262789f15d72ab46a86.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*7ROMTmvI3ao9H5BX.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">服务中控件的位置</figcaption></figure><h1 id="b745" class="js jt hi bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">代码工具</h1><p id="c0d0" class="pw-post-body-paragraph iu iv hi iw b ix kq iz ja jb kr jd je jf ks jh ji jj kt jl jm jn ku jp jq jr hb bi translated">让我们看看代码实现部分。</p><h1 id="5fb7" class="js jt hi bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">接口定义</h1><p id="3f20" class="pw-post-body-paragraph iu iv hi iw b ix kq iz ja jb kr jd je jf ks jh ji jj kt jl jm jn ku jp jq jr hb bi translated">基于断路器的特性，先定义断路器接口<code class="du lx ly lz ma b">CircuitBraker</code>，这里的 key 是指断路器采集的 API，可以是链路上的请求标识符，用来区分不同的请求。</p><pre class="ls lt lu lv fd mb ma mc md aw me bi"><span id="c9d4" class="mf jt hi ma b fi mg mh l mi mj">type CircuitBreaker interface {<br/>    // check if your api(key) allow to access<br/>    CanAccess(key string) bool<br/>    // mark failed api result<br/>    Failed(key string)<br/>    // mark succeed api result<br/>    Succeed(key string)<br/>}</span></pre><h1 id="e7c0" class="js jt hi bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">接口工具</h1><p id="f39c" class="pw-post-body-paragraph iu iv hi iw b ix kq iz ja jb kr jd je jf ks jh ji jj kt jl jm jn ku jp jq jr hb bi translated">基于以上商定的几个功能特征，创建<code class="du lx ly lz ma b">CircuitBreakerImp</code>作为实现主体</p><pre class="ls lt lu lv fd mb ma mc md aw me bi"><span id="7137" class="mf jt hi ma b fi mg mh l mi mj">type CircuitBreakerImp struct {<br/>    lock            sync.RWMutex<br/>    apiMap          map[string]*apiSnapShop <br/>    minCheck        int64                   <br/>    cbkErrRate      float64                 <br/>    recoverInterval time.Duration           <br/>    roundInterval   time.Duration           <br/>}</span></pre><p id="71b6" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">断路器实现体的<code class="du lx ly lz ma b">apiMap</code>主要存储采集 API 的列表，用来表示当前阶段采集的每个 API 的整体快照。</p><pre class="ls lt lu lv fd mb ma mc md aw me bi"><span id="4d34" class="mf jt hi ma b fi mg mh l mi mj">type apiSnapShop struct {<br/>    isPaused   bool <br/>    errCount   int64<br/>    totalCount int64</span><span id="07d6" class="mf jt hi ma b fi mk mh l mi mj">    accessLast int64 // The last access time of the api<br/>    roundLast  int64 // fuse cycle time<br/>}</span></pre><p id="1625" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw hj">断路器状态</strong>，基于每个失败的请求，请求快照会保存在当前<code class="du lx ly lz ma b">CircuitBreakerImp</code>实例的 apiMap 中，所以<code class="du lx ly lz ma b">IsBreak()</code>接口的实现相对简单，直接返回其状态即可:</p><pre class="ls lt lu lv fd mb ma mc md aw me bi"><span id="3a24" class="mf jt hi ma b fi mg mh l mi mj">func (c *CircuitBreakerImp) IsBreak(key string) bool {<br/>    c.lock.RLock()<br/>    defer c.lock.RUnlock()</span><span id="697f" class="mf jt hi ma b fi mk mh l mi mj">    // Find out whether the current key (API) has reached a fuse<br/>    if api, ok := c.apiMap[key]; ok {<br/>        return api.isPaused<br/>    }<br/>    return false<br/>}</span></pre><p id="0ad2" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw hj">访问记录，</strong>网关每收到一次请求，都会向请求发起地和请求返回地的断路器上报接口访问次数和返回是否成功的信息，如上图 AOP 图所示，每次请求 API 时都用<code class="du lx ly lz ma b">accessed()</code>函数上报。<br/>此外，如前所述，断路器有一个<strong class="iw hj">复位周期</strong>，即该接口再接入多长时间后，其快照计数将被复位。因此，在每个<code class="du lx ly lz ma b">access</code>处，需要额外的判断。用于重置 API 计数。</p><pre class="ls lt lu lv fd mb ma mc md aw me bi"><span id="4cc8" class="mf jt hi ma b fi mg mh l mi mj">// accessed record<br/>func (c *CircuitBreakerImp) accessed(api *apiSnapShop) {<br/>    /*<br/>        whether now it is older than the cycle time?<br/>        - yes: reset counter<br/>        - no: update counter<br/>    */<br/>    now := time.Now().UnixNano()<br/>    if util.Abs64(now-api.roundLast) &gt; int64(c.roundInterval) {<br/>        if api.roundLast != 0 {            <br/>            log.Warnf("# Trigger circuit breaker windows，reset API counter!")<br/>        }<br/>        api.errCount = 0<br/>        api.totalCount = 0<br/>        api.roundLast = now<br/>    }<br/>    api.totalCount++<br/>    api.accessLast = now<br/>}</span></pre></div><div class="ab cl kv kw gp kx" role="separator"><span class="ky bw bk kz la lb"/><span class="ky bw bk kz la lb"/><span class="ky bw bk kz la"/></div><div class="hb hc hd he hf"><p id="d4f8" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw hj">报告成功，</strong>网关收到成功响应码后，记录成功。还有一个细节就是为什么上面的<code class="du lx ly lz ma b">accessed()</code>函数不需要添加互斥体，实际上是需要的，但是在<code class="du lx ly lz ma b">accessed()</code>函数中是在调用的上层，也就是在后续的<code class="du lx ly lz ma b">Successd()</code>和<code class="du lx ly lz ma b">Failed()</code>函数体中添加的。我们先来看<code class="du lx ly lz ma b">Successd()</code>的实现，<strong class="iw hj">如果断路器中记录了当前 api(已经失败)，那么成功后关闭断路器并给出请求</strong>，即使 api 再次失败，也会基于请求错误率重新分配断路器。</p><pre class="ls lt lu lv fd mb ma mc md aw me bi"><span id="fe56" class="mf jt hi ma b fi mg mh l mi mj">/*<br/>    Succeed record<br/>    Only collect which api in global map,<br/>    check whether is's paused:<br/>    - yes, cancel the paused breaker state.<br/>*/<br/>func (c *CircuitBreakerImp) Succeed(key string) {<br/>    c.lock.Lock()<br/>    c.lock.Unlock()</span><span id="5b3d" class="mf jt hi ma b fi mk mh l mi mj">    if api, ok := c.apiMap[key]; ok {<br/>        c.accessed(api)<br/>        if api.isPaused {<br/>            log.Warnf("# Trigger API: %v access succeed.", key)<br/>            api.isPaused = false<br/>        }<br/>    }<br/>}</span></pre></div><div class="ab cl kv kw gp kx" role="separator"><span class="ky bw bk kz la lb"/><span class="ky bw bk kz la lb"/><span class="ky bw bk kz la"/></div><div class="hb hc hd he hf"><p id="7797" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw hj">上报访问失败</strong>，统计失败的逻辑比较简单。对于首次失败的接口，将其添加到运行状况检查图中。对于已经记录的接口，要判断错误率，及时更新。<br/>另外，触发断路器的前提是请求量必须达到一定的阈值。</p><pre class="ls lt lu lv fd mb ma mc md aw me bi"><span id="3779" class="mf jt hi ma b fi mg mh l mi mj">/*<br/>    Failed record<br/>    whether exists in api map,<br/>        - yes:<br/>            - record access and error count<br/>            - the percentage of failures reaches the threshold? yes, mark as paused<br/>        - no:<br/>            update in global map for access and error count<br/>*/<br/>func (c *CircuitBreakerImp) Failed(key string) {<br/>    c.lock.Lock()<br/>    defer c.lock.Unlock()</span><span id="6997" class="mf jt hi ma b fi mk mh l mi mj">    if api, ok := c.apiMap[key]; ok {<br/>        c.accessed(api)<br/>        api.errCount++</span><span id="b62b" class="mf jt hi ma b fi mk mh l mi mj">        errRate := float64(api.errCount) / float64(api.totalCount)<br/>        // access count reaches the threshold &amp;&amp; failures rate above the fuse limit<br/>        if api.totalCount &gt; c.minCheck &amp;&amp; errRate &gt; c.cbkErrRate {<br/>            log.Warnf("# Trigger CBK！: %v, total: %v, "+<br/>                "errRate: %.3f.", key, api.totalCount, errRate)<br/>            api.isPaused = true<br/>        }<br/>    } else {<br/>        api := &amp;apiSnapShop{}<br/>        c.accessed(api)<br/>        api.errCount++<br/>        c.apiMap[key] = api<br/>    }<br/>}</span></pre></div><div class="ab cl kv kw gp kx" role="separator"><span class="ky bw bk kz la lb"/><span class="ky bw bk kz la lb"/><span class="ky bw bk kz la"/></div><div class="hb hc hd he hf"><p id="7fe8" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw hj">访问权限查询</strong>，基于上面实现的功能断路器的核心功能，需要向网关层提供一个断路器状态来获取当前接口。<br/>以下是为呼叫者提供的<strong class="iw hj">访问查询</strong>。</p><p id="d26d" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">这里有一个问题，上面不是已经实现了<code class="du lx ly lz ma b">IsBreak()</code>函数吗，我们为什么还需要<code class="du lx ly lz ma b">CanAccess()</code>函数？<br/>嗯，因为<code class="du lx ly lz ma b">IsBreak()</code>返回的只是接口的熔断状态，但是不要忘了在熔断阶段有一个“半关状态”，即熔断时间过了恢复期(冷却期)，那么就可以释放访问权限，所以这部分逻辑在<code class="du lx ly lz ma b">CanAccess()</code>中处理，我们来看看代码。<br/>其中，输入键表示网关层要访问的接口的标识，如<code class="du lx ly lz ma b">/get-hello</code>，函数返回值表示接口的可访问状态。</p><blockquote class="ml mm mn"><p id="de89" class="iu iv lc iw b ix iy iz ja jb jc jd je mo jg jh ji mp jk jl jm mq jo jp jq jr hb bi translated">在熔断周期内，如果已经过了恢复期(冷却期)，可以释放访问，或者调用<code class="du lx ly lz ma b">Successd()</code>熔断状态暂时恢复，否则熔断状态会保持，接口会被限制，fast 失效的核心代码在这里。</p></blockquote><pre class="ls lt lu lv fd mb ma mc md aw me bi"><span id="1223" class="mf jt hi ma b fi mg mh l mi mj">func (c *CircuitBreakerImp) CanAccess(key string) bool {<br/>    /*<br/>        return the api's status of isPaused<br/>        - not paused, return true<br/>        - paused, return whether current time oldder then recovery period<br/>    */<br/>    c.lock.RLock()<br/>    defer c.lock.RUnlock()<br/>    log.Debugf("# Cbk check accessable for api id-%v key", reqType)</span><span id="009b" class="mf jt hi ma b fi mk mh l mi mj">    if api, ok := c.apiMap[key]; ok {<br/>        log.Debugf("# Cbk detail for api id-%v key, total: %v, "+<br/>            "errCount: %v, paused: %v", reqType, api.totalCount,<br/>            api.errCount, api.isPaused)<br/>            <br/>        if api.isPaused {            <br/>            latency := util.Abs64(time.Now().UnixNano() - api.accessLast)<br/>            if latency &lt; int64(c.recoverInterval) {<br/>                return false<br/>            }<br/>            log.Warnf("# Trigger: The CBK has passed the recovery period: %v, key: %v!", c.recoverInterval, key)<br/>        }<br/>    }    <br/>    return true<br/>}</span></pre><h1 id="8658" class="js jt hi bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">单元测试</h1><p id="4dae" class="pw-post-body-paragraph iu iv hi iw b ix kq iz ja jb kr jd je jf ks jh ji jj kt jl jm jn ku jp jq jr hb bi translated">基于上面的实现，接下来编写测试代码来覆盖案例，演示并保持这两个过程在循环滚动:</p><ul class=""><li id="1105" class="ld le hi iw b ix iy jb jc jf lf jj lg jn lh jr li lj lk ll bi translated"><strong class="iw hj">失败- &gt;保持失败- &gt;保险丝打开- &gt;冷却时间过去</strong></li><li id="afba" class="ld le hi iw b ix lm jb ln jf lo jj lp jn lq jr li lj lk ll bi translated"><strong class="iw hj">进入恢复期- &gt;继续访问</strong></li></ul><h1 id="e1ed" class="js jt hi bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">模拟 API 访问</h1><pre class="ls lt lu lv fd mb ma mc md aw me bi"><span id="dbc8" class="mf jt hi ma b fi mg mh l mi mj">const API_PREFIX = "/fake-api"<br/>var (<br/>    HasCbk = false<br/>)</span><span id="ac80" class="mf jt hi ma b fi mk mh l mi mj">func StartJob(cbk *CircuitBreakerImp) {<br/>    for {<br/>        // 1 failure per second, parameter 0 means failed, 1 means success<br/>        ReqForTest(cbk, 0)<br/>        time.Sleep(time.Second * 1)<br/>    }<br/>}</span><span id="ffd8" class="mf jt hi ma b fi mk mh l mi mj">// Build request scheduling, fuse to restore it and let it succeed 1 time<br/>func ReqForTest(cbk *CircuitBreakerImp, req int) {<br/>    // mock failed case<br/>    mockAPI := API_PREFIX //+ strconv.Itoa(req)<br/>    //log.Infof("Ready to reqForTest: %s, req-id-%v", HOST_PREFIX+mockAPI, req)</span><span id="51dd" class="mf jt hi ma b fi mk mh l mi mj">    if !cbk.CanAccess(mockAPI, req) {<br/>        log.Warnf("Api: %v is break, req-id-%v, wait for next round or success for one...", mockAPI, req)<br/>        HasCbk = true<br/>        return<br/>    } else {<br/>        log.Infof("Request can access: %s, req-id-%v", HOST_PREFIX+mockAPI, req)<br/>        // After the recovery period, after the circuit breaker is recovered, skip the error and let it succeed<br/>        if HasCbk &amp;&amp; req == 0 {<br/>            HasCbk = false<br/>            req = 1<br/>            log.Warnf("Transfer fail to success: %s, req-id-%v", HOST_PREFIX+mockAPI, req)<br/>        }<br/>    }</span><span id="3c45" class="mf jt hi ma b fi mk mh l mi mj">    if req == 0 {<br/>        log.Errorf("# Meet failed ReqForTest: %s", HOST_PREFIX+mockAPI)<br/>        cbk.Failed(mockAPI)<br/>    } else {<br/>        log.Infof("# Meet success ReqForTest: %s", HOST_PREFIX+mockAPI)<br/>        cbk.Succeed(mockAPI)<br/>    }<br/>}</span></pre><h1 id="ff71" class="js jt hi bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">初始化保险丝</h1><p id="0d60" class="pw-post-body-paragraph iu iv hi iw b ix kq iz ja jb kr jd je jf ks jh ji jj kt jl jm jn ku jp jq jr hb bi translated">初始化断路器并分配相关参数</p><pre class="ls lt lu lv fd mb ma mc md aw me bi"><span id="1d7b" class="mf jt hi ma b fi mg mh l mi mj">cbk := &amp;CircuitBreakerImp{}<br/>cbk.apiMap = make(map[string]*apiSnapShop)<br/>// 15s per round to reset the err rate<br/>cbk.roundInterval = util.ToDuration(15 * time.Second)<br/>// when breaker is triggered, recover for next try<br/>cbk.recoverInterval = util.ToDuration(5 * time.Second)<br/>// consider the api at least request for 5 time durning the round interval<br/>cbk.minCheck = 5<br/>// when error rate comes to 50%, circuit breaker triggered<br/>cbk.cbkErrRate = 0.5</span></pre><h1 id="ed9f" class="js jt hi bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">输出说明</h1><figure class="ls lt lu lv fd ij er es paragraph-image"><div class="er es mr"><img src="../Images/4f8509ee317ae89ec1c807ccf636e9c8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1366/format:webp/0*Sd_Dc-tPZW8jmSSi.png"/></div></figure><p id="34eb" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">正如我们所料，尽管界面上前 5 个请求的失败率为 100%，但请求量并未增加，因此断路器不会被触发，直到满足持续熔断条件，断路器才会被触发。</p><p id="29ce" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw hj"> <em class="lc">触发的断路器持续 5 秒</em> </strong>后，进入空闲期，API 变为可访问，界面再次被访问。如果错误率仍然满足，熔丝状态将继续恢复。</p><p id="6d13" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw hj"> <em class="lc">复位周期后，</em></strong>API 计数复位，回到程序开始的状态，接口恢复<strong class="iw hj">连续可访问</strong>，直到达到错误率，保险丝打开。</p><h1 id="4f44" class="js jt hi bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">摘要</h1><p id="4596" class="pw-post-body-paragraph iu iv hi iw b ix kq iz ja jb kr jd je jf ks jh ji jj kt jl jm jn ku jp jq jr hb bi translated">至此，一个简单的断路器实现已经完成。刚开始的时候，很多概念都很容易绕过。后来结合场景模拟和代码调试，以及开头的状态转换画面，就很好理解了。尽管许多现成的组件都是现成的，但是只要你用心去想，它们的内部实现并不是那么深不可测。</p><h1 id="e2da" class="js jt hi bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">项目链接</h1><p id="1962" class="pw-post-body-paragraph iu iv hi iw b ix kq iz ja jb kr jd je jf ks jh ji jj kt jl jm jn ku jp jq jr hb bi translated"><a class="ae ms" href="https://github.com/pixeldin/cbk-s1mpl3" rel="noopener ugc nofollow" target="_blank">https://github.com/pixeldin/cbk-s1mpl3</a></p><h1 id="4a89" class="js jt hi bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">参考</h1><p id="8201" class="pw-post-body-paragraph iu iv hi iw b ix kq iz ja jb kr jd je jf ks jh ji jj kt jl jm jn ku jp jq jr hb bi"><strong class="iw hj">Circuit Breaker Pattern</strong><br/><a class="ae ms" href="https://docs.microsoft.com/en-us/previous-versions/msp-n-p/dn589784(v=pandp.10)" rel="noopener ugc nofollow" target="_blank">https://docs.microsoft.com/en-us/previous-versions/msp-n-p/dn589784(v=pandp.10)</a><br/><strong class="iw hj">Sony’s implement of gobreaker</strong><br/><a class="ae ms" href="https://github.com/sony/gobreaker" rel="noopener ugc nofollow" target="_blank">https://github.com/sony/gobreaker</a><br/><strong class="iw hj">微服务架构中的熔断器设计与实现</strong><br/><a class="ae ms" href="https://mp.weixin.qq.com/s/DGRnUhyv6SS_E36ZQKGpPA" rel="noopener ugc nofollow" target="_blank">https://mp.weixin.qq.com/s/DGRnUhyv6SS_E36ZQKGpPA</a></p></div></div>    
</body>
</html>