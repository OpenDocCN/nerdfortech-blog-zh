<html>
<head>
<title>Running services with Knative &amp; Kong</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">与 Knative &amp; Kong 一起经营服务</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/running-services-with-knative-kong-3135c0d94dfa?source=collection_archive---------1-----------------------#2021-09-23">https://medium.com/nerd-for-tech/running-services-with-knative-kong-3135c0d94dfa?source=collection_archive---------1-----------------------#2021-09-23</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/4950ca9192b180ef3f8392cfb94a084f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7XKmC4vMmTRvRGjnPN2bjw.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">孔庆东和孔庆东是天造地设的一对…我们是天生的一对！</figcaption></figure><blockquote class="iu"><p id="7af1" class="iv iw hi bd ix iy iz ja jb jc jd je dx translated">在这里的<a class="ae jf" href="https://github.com/vorteil/direktiv" rel="noopener ugc nofollow" target="_blank"> direktiv.io </a>我们广泛使用<a class="ae jf" href="https://knative.dev/" rel="noopener ugc nofollow" target="_blank">Knative</a>…因为这确实是一个令人惊叹的项目！</p></blockquote><p id="016f" class="pw-post-body-paragraph jg jh hi ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc je hb bi translated">大多数开发人员和系统管理员将 Knative 视为一个无服务器的框架，但是它还有更多的功能<strong class="ji hj">(无服务器组件只是其中的一小部分)</strong>。</p><p id="c42c" class="pw-post-body-paragraph jg jh hi ji b jj kd jl jm jn ke jp jq jr kf jt ju jv kg jx jy jz kh kb kc je hb bi translated">它通过为每个服务仅定义一个 yaml 来抽象服务部署和管理，同时提供额外的功能，如基于报头的路由和流量分流…所有这些都允许我们在 Direktiv 中运行同一服务的不同版本。这是我们实时迁移功能的关键部分！</p><p id="5716" class="pw-post-body-paragraph jg jh hi ji b jj kd jl jm jn ke jp jq jr kf jt ju jv kg jx jy jz kh kb kc je hb bi translated">在这篇文章中，我将展示如何使用带 Knative 的<a class="ae jf" href="https://konghq.com/" rel="noopener ugc nofollow" target="_blank">孔</a>入口控制器来获得更多的好处！</p><h1 id="39eb" class="ki kj hi bd kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf bi translated">设置它</h1><p id="ff0a" class="pw-post-body-paragraph jg jh hi ji b jj lg jl jm jn lh jp jq jr li jt ju jv lj jx jy jz lk kb kc je hb bi translated">首先，您需要一个 Kubernetes 环境(显然)。从你最喜欢的云提供商那里选择一个服务或者安装<a class="ae jf" href="https://k3s.io/" rel="noopener ugc nofollow" target="_blank"> k3s </a>(我更喜欢这个)。</p><p id="4ebf" class="pw-post-body-paragraph jg jh hi ji b jj kd jl jm jn ke jp jq jr kf jt ju jv kg jx jy jz kh kb kc je hb bi translated">如果您从未使用过 Knative，我们将开始安装。Knative 可以通过提供的<a class="ae jf" href="https://knative.dev/docs/admin/install/serving/install-serving-with-yaml/" rel="noopener ugc nofollow" target="_blank"> YAML </a>文件轻松安装:</p><pre class="ll lm ln lo fd lp lq lr ls aw lt bi"><span id="175a" class="lu kj hi lq b fi lv lw l lx ly"># kubectl apply -f https://github.com/knative/serving/releases/download/v0.25.1/serving-crds.yaml</span><span id="8b48" class="lu kj hi lq b fi lz lw l lx ly"># kubectl apply -f https://github.com/knative/serving/releases/download/v0.25.1/serving-core.yaml</span></pre><p id="09a0" class="pw-post-body-paragraph jg jh hi ji b jj kd jl jm jn ke jp jq jr kf jt ju jv kg jx jy jz kh kb kc je hb bi translated">这将安装 Knative 的服务部分，但它也需要一个网络组件来处理路由。安装说明书建议<a class="ae jf" href="https://github.com/knative-sandbox/net-kourier" rel="noopener ugc nofollow" target="_blank"> Kourier </a>、<a class="ae jf" href="https://getambassador.io/" rel="noopener ugc nofollow" target="_blank">大使</a>、<a class="ae jf" href="https://projectcontour.io/" rel="noopener ugc nofollow" target="_blank">轮廓</a>和<a class="ae jf" href="https://istio.io/" rel="noopener ugc nofollow" target="_blank"> Istio </a>。所有这些组件当然都是有效的选项，并且工作得非常好，但是还有一个选项在这里没有提到:<a class="ae jf" href="https://konghq.com/solutions/kubernetes-ingress/" rel="noopener ugc nofollow" target="_blank"> Kong 代表 Kubernetes </a></p><p id="21d6" class="pw-post-body-paragraph jg jh hi ji b jj kd jl jm jn ke jp jq jr kf jt ju jv kg jx jy jz kh kb kc je hb bi translated">Kong 提供了一个支持开箱即用的 Knative 的入口控制器。所有服务都可以通过 Kong 自动路由并得到适当的管理。</p><p id="9bef" class="pw-post-body-paragraph jg jh hi ji b jj kd jl jm jn ke jp jq jr kf jt ju jv kg jx jy jz kh kb kc je hb bi translated">(对我们来说)好处是显而易见的。使用 Kong 的<strong class="ji hj">完整特性集使得 Knative services 更容易专注于<strong class="ji hj">业务功能</strong>，而 Kong 则处理支持功能，如<strong class="ji hj">认证、响应转换和请求限制</strong>。</strong></p><p id="99a9" class="pw-post-body-paragraph jg jh hi ji b jj kd jl jm jn ke jp jq jr kf jt ju jv kg jx jy jz kh kb kc je hb bi translated">请看下图(它显示了从集群外部和内部访问的服务):</p><figure class="ll lm ln lo fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ma"><img src="../Images/483a72c0949538ea531711cd2457a216.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7TyN_lheoiJ53wIClvsDqw.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">从集群外部到内部的服务可访问性</figcaption></figure><p id="c657" class="pw-post-body-paragraph jg jh hi ji b jj kd jl jm jn ke jp jq jr kf jt ju jv kg jx jy jz kh kb kc je hb bi translated">Knative 区分可从群集外部访问的外部服务和仅供群集内部使用的私有服务。为了支持这两者，我们将在 Kubernetes 集群中安装两个 Kong 实例。</p><p id="076d" class="pw-post-body-paragraph jg jh hi ji b jj kd jl jm jn ke jp jq jr kf jt ju jv kg jx jy jz kh kb kc je hb bi translated">孔配备了舵图，所以我们将使用这些安装。所有配置选项请查看<a class="ae jf" href="https://github.com/Kong/charts" rel="noopener ugc nofollow" target="_blank">孔掌舵图 github </a>页面。对于这个例子，我们将使用一个基本的方法。</p><p id="151c" class="pw-post-body-paragraph jg jh hi ji b jj kd jl jm jn ke jp jq jr kf jt ju jv kg jx jy jz kh kb kc je hb bi translated">为了确保这两个实例是独立的，我们为每个实例配置了自己的名称空间:<em class="mb"> kong-internal </em>和<em class="mb"> kong-external </em>。除了 Kubernetes 服务的类型之外，安装几乎完全相同。用于外部服务的 Kong 使用一个<code class="du mc md me lq b">LoadBalancer</code>，而内部服务使用一个<code class="du mc md me lq b">ClusterIP</code>(因此不能从集群外部访问)。</p><p id="48c1" class="pw-post-body-paragraph jg jh hi ji b jj kd jl jm jn ke jp jq jr kf jt ju jv kg jx jy jz kh kb kc je hb bi translated">为了区分这两者，我们还分配了不同的入口类别。</p><h2 id="8333" class="lu kj hi bd kk mf mg mh ko mi mj mk ks jr ml mm kw jv mn mo la jz mp mq le mr bi translated">对外服务孔</h2><p id="62be" class="pw-post-body-paragraph jg jh hi ji b jj lg jl jm jn lh jp jq jr li jt ju jv lj jx jy jz lk kb kc je hb bi translated">让我们为外部服务安装孔:</p><pre class="ll lm ln lo fd lp lq lr ls aw lt bi"><span id="cf6e" class="lu kj hi lq b fi lv lw l lx ly"># helm repo add kong https://charts.konghq.com<br/># helm repo update<br/><br/># kubectl create namespace kong-external<br/># helm install -n kong-external kong-external kong/kong</span></pre><h2 id="2bdb" class="lu kj hi bd kk mf mg mh ko mi mj mk ks jr ml mm kw jv mn mo la jz mp mq le mr bi translated">孔为内部服务</h2><p id="2bbf" class="pw-post-body-paragraph jg jh hi ji b jj lg jl jm jn lh jp jq jr li jt ju jv lj jx jy jz lk kb kc je hb bi translated">让我们安装孔为内部服务:</p><pre class="ll lm ln lo fd lp lq lr ls aw lt bi"><span id="f49b" class="lu kj hi lq b fi lv lw l lx ly"># kubectl create namespace kong-internal<br/># helm install -n kong-internal --set proxy.type=ClusterIP --set ingressController.ingressClass=kong-internal kong-internal kong/kong</span></pre><h2 id="2dc6" class="lu kj hi bd kk mf mg mh ko mi mj mk ks jr ml mm kw jv mn mo la jz mp mq le mr bi translated">确认</h2><p id="a10b" class="pw-post-body-paragraph jg jh hi ji b jj lg jl jm jn lh jp jq jr li jt ju jv lj jx jy jz lk kb kc je hb bi translated">服务将在几秒钟内可用，两个名称空间中的所有 pod 都应该处于运行状态。</p><pre class="ll lm ln lo fd lp lq lr ls aw lt bi"><span id="2857" class="lu kj hi lq b fi lv lw l lx ly"># kubectl get pods -n kong-internal<br/>NAME                                 READY   STATUS    RESTARTS   AGE<br/>kong-internal-kong-77dc9c4cf-tb2b5   2/2     Running   0          24s<br/><br/># kubectl get pods -n kong-external<br/>NAME                                   READY   STATUS    RESTARTS   AGE<br/>svclb-kong-external-kong-proxy-9cbcl   2/2     Running   0          30s<br/>kong-external-kong-79668fdf45-rk7s2    2/2     Running   0          30s</span></pre><p id="a204" class="pw-post-body-paragraph jg jh hi ji b jj kd jl jm jn ke jp jq jr kf jt ju jv kg jx jy jz kh kb kc je hb bi translated">要在生产环境中使用外部服务，需要进行 DNS 更改，如 Knative 文档中所述。在这种情况下将使用<a class="ae jf" href="https://sslip.io/" rel="noopener ugc nofollow" target="_blank"> sslip.io </a>进行测试。Knative 提供了一个名为 default-domain 的 Kubernetes 作业，该作业将 Knative 服务配置为使用 sslip.io 作为默认 DNS 后缀:</p><pre class="ll lm ln lo fd lp lq lr ls aw lt bi"><span id="2468" class="lu kj hi lq b fi lv lw l lx ly"># kubectl apply -f https://github.com/knative/serving/releases/download/v0.25.0/serving-default-domain.yaml</span></pre><p id="f48b" class="pw-post-body-paragraph jg jh hi ji b jj kd jl jm jn ke jp jq jr kf jt ju jv kg jx jy jz kh kb kc je hb bi translated">在我们设置好所有组件并使它们运行之后，我们现在需要将它们“粘合”在一起。</p><blockquote class="ms mt mu"><p id="03fc" class="jg jh mb ji b jj kd jl jm jn ke jp jq mv kf jt ju mw kg jx jy mx kh kb kc je hb bi translated">听起来很难，但实际上非常容易...我们只需要告诉 Knative 使用 Kong 作为入口控制器…</p></blockquote><p id="17e0" class="pw-post-body-paragraph jg jh hi ji b jj kd jl jm jn ke jp jq jr kf jt ju jv kg jx jy jz kh kb kc je hb bi translated">这是一个简单的命令，用于修改 Knative 的一个配置图。这定义了默认的入口类别，并且可以根据服务进行覆盖。在我们的例子中，如果没有另外指定的话，所有的请求都通过外部 Kong 进行路由。</p><pre class="ll lm ln lo fd lp lq lr ls aw lt bi"><span id="67aa" class="lu kj hi lq b fi lv lw l lx ly">kubectl patch configmap/config-network \<br/>  --namespace knative-serving \<br/>    --type merge \<br/>      --patch '{"data":{"ingress.class":"kong"}}'</span></pre><h1 id="90b4" class="ki kj hi bd kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf bi translated">配置和测试服务</h1><p id="2815" class="pw-post-body-paragraph jg jh hi ji b jj lg jl jm jn lh jp jq jr li jt ju jv lj jx jy jz lk kb kc je hb bi translated">是时候将这个设置付诸实施并看看它是如何工作的了。第一步是安装服务。我们希望安装一个内部服务和外部服务来与孔一起工作。</p><h2 id="d6de" class="lu kj hi bd kk mf mg mh ko mi mj mk ks jr ml mm kw jv mn mo la jz mp mq le mr bi translated">配置服务</h2><p id="03fa" class="pw-post-body-paragraph jg jh hi ji b jj lg jl jm jn lh jp jq jr li jt ju jv lj jx jy jz lk kb kc je hb bi translated">为此，我建议使用以下两个服务示例:</p><figure class="ll lm ln lo fd ij"><div class="bz dy l di"><div class="my mz l"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">孔内部服务</figcaption></figure><figure class="ll lm ln lo fd ij"><div class="bz dy l di"><div class="my mz l"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">孔对外服务</figcaption></figure><figure class="ll lm ln lo fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es na"><img src="../Images/718ca0c680165834f608c8744f442153.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SALc5Q55gp-IynphLARRVA.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">为孔应用服务配置</figcaption></figure><p id="8677" class="pw-post-body-paragraph jg jh hi ji b jj kd jl jm jn ke jp jq jr kf jt ju jv kg jx jy jz kh kb kc je hb bi translated">如您所见，除了内部服务有额外的注释和标签之外，它们几乎是相同的。但是他们做什么呢？</p><ul class=""><li id="edd1" class="nb nc hi ji b jj kd jn ke jr nd jv ne jz nf je ng nh ni nj bi translated"><em class="mb">networking.knative.dev/visibility:集群-本地</em>:该标签将其标记为集群可访问的服务。</li><li id="a407" class="nb nc hi ji b jj nk jn nl jr nm jv nn jz no je ng nh ni nj bi translated">【autoscaling.knative.dev/minScale: " 1 "<em class="mb">:如果一个服务从零开始扩展，需要几秒钟才能得到第一个响应。使用此设置，总是有一个服务实例在运行。</em></li><li id="4622" class="nb nc hi ji b jj nk jn nl jr nm jv nn jz no je ng nh ni nj bi translated"><em class="mb">networking.knative.dev/ingress.class:孔-内部</em>:安装时内部孔实例指定入口类<em class="mb">孔-内部</em>。该设置确保请求通过内部 Kong 实例而不是外部实例进行路由。</li></ul><p id="f3f0" class="pw-post-body-paragraph jg jh hi ji b jj kd jl jm jn ke jp jq jr kf jt ju jv kg jx jy jz kh kb kc je hb bi translated">服务本身的<a class="ae jf" href="https://knative.dev/docs/reference/api/serving-api/#serving.knative.dev/v1.RevisionTemplateSpec" rel="noopener ugc nofollow" target="_blank">配置</a>(容器名、环境变量、秘密等。)类似于默认的 Kubernetes 部署，基本上是 Kubernetes 的 PodSpec 的子集。</p><p id="3e62" class="pw-post-body-paragraph jg jh hi ji b jj kd jl jm jn ke jp jq jr kf jt ju jv kg jx jy jz kh kb kc je hb bi translated">Knative 在安装期间创建并部署服务，如果该过程成功完成，则将其标记为就绪。第一次部署服务可能需要更长时间，特别是如果服务中的图像还没有下载到 Kubernetes 节点。如果此过程成功，服务就可以使用了:</p><pre class="ll lm ln lo fd lp lq lr ls aw lt bi"><span id="b2d2" class="lu kj hi lq b fi lv lw l lx ly"># kubectl get ksvc<br/>NAME                  URL                                                        LATESTCREATED               LATESTREADY                 READY   REASON<br/>helloworld-internal   http://helloworld-internal.default.svc.cluster.local       helloworld-internal-00001   helloworld-internal-00001   True    <br/>helloworld-external   http://helloworld-external.default.192.168.1.1.sslip.io   helloworld-external-00001   helloworld-external-00001   True</span></pre><h2 id="a459" class="lu kj hi bd kk mf mg mh ko mi mj mk ks jr ml mm kw jv mn mo la jz mp mq le mr bi translated">测试服务</h2><p id="6118" class="pw-post-body-paragraph jg jh hi ji b jj lg jl jm jn lh jp jq jr li jt ju jv lj jx jy jz lk kb kc je hb bi translated">好极了……</p><figure class="ll lm ln lo fd ij er es paragraph-image"><div class="er es np"><img src="../Images/e9edc40f03cea4d0cdac0677bb5a9bfd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1104/format:webp/0*OQqbrXEcNoAfXzz8.jpg"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">如果没有 curl，软件故障排除会是什么样子？</figcaption></figure><p id="68a3" class="pw-post-body-paragraph jg jh hi ji b jj kd jl jm jn ke jp jq jr kf jt ju jv kg jx jy jz kh kb kc je hb bi translated">可以用一个简单的<code class="du mc md me lq b">curl</code>命令调用外部服务。因为安装了模拟 DNS 的<code class="du mc md me lq b">sslip.io</code>,所以调用看起来像:</p><pre class="ll lm ln lo fd lp lq lr ls aw lt bi"><span id="e156" class="lu kj hi lq b fi lv lw l lx ly"># curl http://helloworld-external.default.192.168.1.1.sslip.io<br/>Hello Go Sample v1!</span></pre><p id="35d9" class="pw-post-body-paragraph jg jh hi ji b jj kd jl jm jn ke jp jq jr kf jt ju jv kg jx jy jz kh kb kc je hb bi translated">第二个服务是一个内部服务，具有 Kubernetes 内部 URL<a class="ae jf" href="http://helloworld-internal.default.svc.cluster.local/" rel="noopener ugc nofollow" target="_blank"><em class="mb">http://hello world-internal . default . SVC . cluster . local</em></a>。要调用内部服务，我们需要运行一个带有<code class="du mc md me lq b">curl</code>的交互式 pod，并从那里调用服务:</p><pre class="ll lm ln lo fd lp lq lr ls aw lt bi"><span id="d21e" class="lu kj hi lq b fi lv lw l lx ly"># kubectl run test-service --rm -i --tty --image curlimages/curl -- sh<br/># curl http://helloworld-internal.default.svc.cluster.local</span></pre><h1 id="8102" class="ki kj hi bd kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf bi translated">使用插件</h1><h2 id="c42d" class="lu kj hi bd kk mf mg mh ko mi mj mk ks jr ml mm kw jv mn mo la jz mp mq le mr bi translated">请求限制器插件示例</h2><p id="2681" class="pw-post-body-paragraph jg jh hi ji b jj lg jl jm jn lh jp jq jr li jt ju jv lj jx jy jz lk kb kc je hb bi translated">在开始的时候我们提到了孔的插件以及它们在<a class="ae jf" href="http://www.direktiv.io" rel="noopener ugc nofollow" target="_blank"> Direktiv </a>中的作用。在这个例子中，我们将把一个插件(<a class="ae jf" href="https://docs.konghq.com/hub/kong-inc/rate-limiting/" rel="noopener ugc nofollow" target="_blank">请求限制插件</a>)连接到 Knative 服务。</p><p id="7024" class="pw-post-body-paragraph jg jh hi ji b jj kd jl jm jn ke jp jq jr kf jt ju jv kg jx jy jz kh kb kc je hb bi translated">将插件安装或应用到服务需要两个步骤:</p><p id="7b9c" class="pw-post-body-paragraph jg jh hi ji b jj kd jl jm jn ke jp jq jr kf jt ju jv kg jx jy jz kh kb kc je hb bi translated">步骤 1:创建插件:这个例子将使用<a class="ae jf" href="https://docs.konghq.com/hub/kong-inc/rate-limiting/" rel="noopener ugc nofollow" target="_blank">请求限制插件</a>，所以我们需要先创建它。这将把请求限制为每分钟最多 5 个。</p><figure class="ll lm ln lo fd ij"><div class="bz dy l di"><div class="my mz l"/></div></figure><figure class="ll lm ln lo fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es nq"><img src="../Images/de0ca548e4058c6cd9c5135451315d8c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QDv2LkKdROQYpDwCo3GxcQ.png"/></div></div></figure><p id="a7a2" class="pw-post-body-paragraph jg jh hi ji b jj kd jl jm jn ke jp jq jr kf jt ju jv kg jx jy jz kh kb kc je hb bi translated"><strong class="ji hj">步骤 2:使用创建的插件的名称来注释服务:</strong>。这可以在服务创建期间或之后完成。我们将用请求限制器注释外部服务。如果超出限制，重复调用该服务将会返回错误。</p><pre class="ll lm ln lo fd lp lq lr ls aw lt bi"><span id="3a17" class="lu kj hi lq b fi lv lw l lx ly"># kubectl annotate ksvc helloworld-external konghq.com/plugins=my-ratelimit</span></pre><p id="8aca" class="pw-post-body-paragraph jg jh hi ji b jj kd jl jm jn ke jp jq jr kf jt ju jv kg jx jy jz kh kb kc je hb bi translated">全部完成—速率限制插件已部署！</p><h2 id="7c5c" class="lu kj hi bd kk mf mg mh ko mi mj mk ks jr ml mm kw jv mn mo la jz mp mq le mr bi translated">基于路径的路由示例</h2><p id="e252" class="pw-post-body-paragraph jg jh hi ji b jj lg jl jm jn lh jp jq jr li jt ju jv lj jx jy jz lk kb kc je hb bi translated">第二个配置展示了如何根据 URL 中请求的路径将外部请求路由到内部 knative 服务。我们使用“主机”报头来利用<a class="ae jf" href="https://knative.dev/docs/serving/samples/knative-routing-go/" rel="noopener ugc nofollow" target="_blank"> Knative 的路由</a>。如果一个请求到达网关(在本例中是 Kong ), kna tive 使用消息头路由到请求的“Host”消息头中指定的后端服务。为了启用基于路径的路由，Kong 可以通过一个<a class="ae jf" href="https://docs.konghq.com/hub/kong-inc/request-transformer/" rel="noopener ugc nofollow" target="_blank">请求转换器插件</a>自动添加这个报头。</p><figure class="ll lm ln lo fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es nr"><img src="../Images/46db988a135cc165401710775a672589.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*f52fqlYYbo7mzJVayzeqpA.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">基于路径的路由示例</figcaption></figure><p id="9796" class="pw-post-body-paragraph jg jh hi ji b jj kd jl jm jn ke jp jq jr kf jt ju jv kg jx jy jz kh kb kc je hb bi translated">要路由到的服务需要部署到具有相同入口类<em class="mb">的入口控制器(即，在外部 Kong 入口控制器中需要有内部服务)</em>。如前所述，一个简单的标签会将一个 Knative 服务部署为“集群本地”:</p><figure class="ll lm ln lo fd ij"><div class="bz dy l di"><div class="my mz l"/></div></figure><figure class="ll lm ln lo fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ns"><img src="../Images/87416275a870e31572e4d151a5a44597.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1uGEdBVnfpLIHiZza8dEJA.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">Kong 集群-本地安装</figcaption></figure><p id="4c06" class="pw-post-body-paragraph jg jh hi ji b jj kd jl jm jn ke jp jq jr kf jt ju jv kg jx jy jz kh kb kc je hb bi translated">下一步是配置插件来添加标题。请求转换器插件需要安装在入口控制器的名称空间<em class="mb"> kong-external: </em></p><figure class="ll lm ln lo fd ij"><div class="bz dy l di"><div class="my mz l"/></div></figure><figure class="ll lm ln lo fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ns"><img src="../Images/2fc35b3b5da90e9bc3911150a5f6bcea.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FfM_KGa6EPWORcd-lOu_ow.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">Kong 外部集群安装</figcaption></figure><p id="9284" class="pw-post-body-paragraph jg jh hi ji b jj kd jl jm jn ke jp jq jr kf jt ju jv kg jx jy jz kh kb kc je hb bi translated">成功创建插件后，需要使用插件创建相应的入口。</p><p id="4875" class="pw-post-body-paragraph jg jh hi ji b jj kd jl jm jn ke jp jq jr kf jt ju jv kg jx jy jz kh kb kc je hb bi translated">下面 YAML 加一条路线<em class="mb">/你好</em>。该路由使用前面的插件将主机头添加到请求中，并将请求再次路由到 Kong 代理，后者返回 Knative 服务的结果。这可以用一个简单的<code class="du mc md me lq b">curl</code><em class="mb"/><a class="ae jf" href="http://helloworld-external.default.192.168.1.1.sslip.io/hello" rel="noopener ugc nofollow" target="_blank">http://hello world-external . default . 192 . 168 . 1 . 1 . sslip . io/hello</a>请求来测试:</p><figure class="ll lm ln lo fd ij"><div class="bz dy l di"><div class="my mz l"/></div></figure><figure class="ll lm ln lo fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es nt"><img src="../Images/503cd570c91ae880df0e9880fddf2dcc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PmTQB7skUYYmyN40Gfov_Q.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">为请求添加了“你好”路线</figcaption></figure><h1 id="501a" class="ki kj hi bd kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf bi translated">最后的想法</h1><p id="8ee5" class="pw-post-body-paragraph jg jh hi ji b jj lg jl jm jn lh jp jq jr li jt ju jv lj jx jy jz lk kb kc je hb bi translated">Knative 支持简单的、版本控制的部署，Kong 围绕 API 和路由添加了一组丰富的特性。不幸的是，Knative 没有得到应有的重视，因为它不仅仅是一个无服务器解决方案(<strong class="ji hj">这些只是我的想法</strong>)。但是这两种工具结合使用可以显著简化 Kubernetes 环境中的微服务部署和管理。</p><p id="452d" class="pw-post-body-paragraph jg jh hi ji b jj kd jl jm jn ke jp jq jr kf jt ju jv kg jx jy jz kh kb kc je hb bi translated">一如既往…乐意回答任何问题！</p></div></div>    
</body>
</html>