<html>
<head>
<title>Todo App With GraphQL, Express.js And React — Episode 2</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用GraphQL、Express.js和React的Todo应用程序—第2集</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/todo-app-with-graphql-express-js-react-episode-2-b56167d8c19e?source=collection_archive---------13-----------------------#2021-05-10">https://medium.com/nerd-for-tech/todo-app-with-graphql-express-js-react-episode-2-b56167d8c19e?source=collection_archive---------13-----------------------#2021-05-10</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/9e0109df621d442dea7f7e35bf4984b6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*sWGnui8mov15ZZxd.png"/></div></div></figure><p id="ae54" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">欢迎光临。在这一集里，我们将为我们的应用添加用户认证和授权功能。这两个概念经常被混淆或互换使用。事实上，认证意味着“识别用户是谁”，而授权意味着“确定用户可以做什么和不可以做什么。”</p><p id="2c2f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">目前，我们的待办事项列表对每个人都是可用的。为了安全起见，我们希望限制访问，所以任何人都不能向我们的列表添加新任务，也不能更改或删除现有的任务。为了实现这一点，我们将进行一些后端配置，幸运的是，Apollo-server有一些内置的助手来帮助我们进行用户验证和授权。</p><p id="f04b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">好吧，我们摇滚吧！</p></div><div class="ab cl jo jp gp jq" role="separator"><span class="jr bw bk js jt ju"/><span class="jr bw bk js jt ju"/><span class="jr bw bk js jt"/></div><div class="hb hc hd he hf"><p id="2df0" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">用户的模式配置</strong></p><p id="c395" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们需要在GraphQL模式中进行一些配置，以处理用户操作。为此，我们将创建一个类型、一个输入、一个查询和一个变异定义，以及一个查询函数和一个变异解析器函数。因此，打开<strong class="is hj"> schmea/typeDefs/index.js </strong>文件，将这一行写在<strong class="is hj">查询</strong>类型定义的上方</p><pre class="jv jw jx jy fd jz ka kb kc aw kd bi"><span id="1a85" class="ke kf hi ka b fi kg kh l ki kj">type User {</span><span id="cc8e" class="ke kf hi ka b fi kk kh l ki kj">_id: ID</span><span id="5d8f" class="ke kf hi ka b fi kk kh l ki kj">username: String</span><span id="a053" class="ke kf hi ka b fi kk kh l ki kj">password: String</span><span id="1b38" class="ke kf hi ka b fi kk kh l ki kj">}</span><span id="4433" class="ke kf hi ka b fi kk kh l ki kj">input UserInput {</span><span id="33c6" class="ke kf hi ka b fi kk kh l ki kj">username: String</span><span id="e5a9" class="ke kf hi ka b fi kk kh l ki kj">password: String</span><span id="32fe" class="ke kf hi ka b fi kk kh l ki kj">}</span></pre><p id="a9de" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这种类型的定义将用于用户操作。现在，让我们添加一个查询定义。让我们将下面一行写入<strong class="is hj">查询</strong>类型:</p><pre class="jv jw jx jy fd jz ka kb kc aw kd bi"><span id="69ff" class="ke kf hi ka b fi kg kh l ki kj">getUsers: [User]</span></pre><p id="ed65" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">并将下面几行添加到<strong class="is hj">突变:</strong></p><pre class="jv jw jx jy fd jz ka kb kc aw kd bi"><span id="ab06" class="ke kf hi ka b fi kg kh l ki kj">addUser(user: UserInput): User</span></pre><p id="6fc0" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">让我们打开<strong class="is hj"> resolvers/index.js </strong>文件，并将这一行写入<strong class="is hj">查询</strong>对象:</p><pre class="jv jw jx jy fd jz ka kb kc aw kd bi"><span id="e50e" class="ke kf hi ka b fi kg kh l ki kj">getUsers: async (parent, args, context) =&gt;</span><span id="1cbf" class="ke kf hi ka b fi kk kh l ki kj">  await context.models.Todo.queries.getUsers(),</span></pre><p id="e449" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">然后将这一行添加到<strong class="is hj">突变</strong>对象:</p><pre class="jv jw jx jy fd jz ka kb kc aw kd bi"><span id="6be3" class="ke kf hi ka b fi kg kh l ki kj">addUser: async (parent, args, context) =&gt;</span><span id="e8f1" class="ke kf hi ka b fi kk kh l ki kj">  await context.models.Todo.mutations.addUser(</span><span id="8989" class="ke kf hi ka b fi kk kh l ki kj">   JSON.parse(JSON.stringify(args.user))</span><span id="e8f4" class="ke kf hi ka b fi kk kh l ki kj">  ),</span></pre><p id="6919" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在，打开<strong class="is hj"> models/index.js </strong>文件。首先导入我们将在下一部分创建的<strong class="is hj">用户</strong>模型:</p><pre class="jv jw jx jy fd jz ka kb kc aw kd bi"><span id="7bf9" class="ke kf hi ka b fi kg kh l ki kj">import User from "../../db/models/UserModel";</span></pre><p id="6b13" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">并在<strong class="is hj">中写出这几行查询</strong>对象:</p><pre class="jv jw jx jy fd jz ka kb kc aw kd bi"><span id="30d8" class="ke kf hi ka b fi kg kh l ki kj">getUsers: () =&gt;</span><span id="762b" class="ke kf hi ka b fi kk kh l ki kj">  new Promise(</span><span id="c83d" class="ke kf hi ka b fi kk kh l ki kj">    async (resolve, reject) =&gt;</span><span id="7a2a" class="ke kf hi ka b fi kk kh l ki kj">      await User.find({}, (err, users) =&gt;</span><span id="3c18" class="ke kf hi ka b fi kk kh l ki kj">        err</span><span id="1602" class="ke kf hi ka b fi kk kh l ki kj">          ? reject(err)</span><span id="c53e" class="ke kf hi ka b fi kk kh l ki kj">          : resolve(users)</span><span id="224d" class="ke kf hi ka b fi kk kh l ki kj">      )</span><span id="cabf" class="ke kf hi ka b fi kk kh l ki kj">  ),</span></pre><p id="840b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">并将这些行写入<strong class="is hj">突变</strong>对象:</p><pre class="jv jw jx jy fd jz ka kb kc aw kd bi"><span id="ad40" class="ke kf hi ka b fi kg kh l ki kj">addUser: (user) =&gt;</span><span id="8726" class="ke kf hi ka b fi kk kh l ki kj">  new Promise((resolve, reject) =&gt;</span><span id="f8c1" class="ke kf hi ka b fi kk kh l ki kj">    new User(user).save((err, user) =&gt; (err ? reject(err) : resolve(user)))</span><span id="5051" class="ke kf hi ka b fi kk kh l ki kj">  ),</span></pre><p id="7324" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">嗯，就是这样。我们的模式已经准备好处理基本的用户操作。现在，让我们在数据库中创建一个用户模型。</p></div><div class="ab cl jo jp gp jq" role="separator"><span class="jr bw bk js jt ju"/><span class="jr bw bk js jt ju"/><span class="jr bw bk js jt"/></div><div class="hb hc hd he hf"><p id="e9e0" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">用户的数据库配置</strong></p><p id="28f8" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">为了理解我们的GraphQL配置，我们必须创建一个解析器和类型定义指向的模型。为了实现这些，在<strong class="is hj"> db/models </strong>目录下创建一个名为<strong class="is hj"> UserModel.js </strong>的文件，并在其中写入以下内容:</p><pre class="jv jw jx jy fd jz ka kb kc aw kd bi"><span id="e896" class="ke kf hi ka b fi kg kh l ki kj">import mongoose from "mongoose";</span><span id="8b4b" class="ke kf hi ka b fi kk kh l ki kj">const userSchema = new mongoose.Schema({</span><span id="ef97" class="ke kf hi ka b fi kk kh l ki kj">  username: { type: String, unique: true },</span><span id="85d4" class="ke kf hi ka b fi kk kh l ki kj">  password: String,</span><span id="f8e4" class="ke kf hi ka b fi kk kh l ki kj">},</span><span id="da4a" class="ke kf hi ka b fi kk kh l ki kj">{ timestamps: true }</span><span id="ff07" class="ke kf hi ka b fi kk kh l ki kj">);</span><span id="6b8d" class="ke kf hi ka b fi kk kh l ki kj">const User = mongoose.model("User", userSchema);</span><span id="25a5" class="ke kf hi ka b fi kk kh l ki kj">export default User;</span></pre><p id="5175" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在，是检验的时候了。打开<a class="ae kl" href="http://HTTP://localhost:4000/graphql" rel="noopener ugc nofollow" target="_blank">HTTP://localhost:4000/graph QL</a>，这样添加一个用户:</p><figure class="jv jw jx jy fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es km"><img src="../Images/e1d5e309ce8cedd2c01b7701e710829d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*p4rqhZ4fym-bb4AfB1QFGg.png"/></div></div></figure><p id="811e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">让我们查询我们的第一个用户。就像这样:</p><figure class="jv jw jx jy fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es kn"><img src="../Images/ef7b639c82ee984df4befdf7347f4ad5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6zHOZScVAW9JUDkfigtEXA.png"/></div></div></figure><p id="96e0" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在我们确保一切正常后，我们可以用创建者用户的id签署todo项。</p><p id="6783" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">签署待办事项</strong></p><p id="a9b0" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">要将用户id添加到待办事项中，打开<strong class="is hj">模式/类型定义</strong>并添加<strong class="is hj">待办事项</strong>的变更类型和输入定义，如下所示:</p><pre class="jv jw jx jy fd jz ka kb kc aw kd bi"><span id="87d2" class="ke kf hi ka b fi kg kh l ki kj">type Todo {</span><span id="c119" class="ke kf hi ka b fi kk kh l ki kj">_id: ID</span><span id="7a18" class="ke kf hi ka b fi kk kh l ki kj">title: String</span><span id="d74a" class="ke kf hi ka b fi kk kh l ki kj">mission: String</span><span id="1eeb" class="ke kf hi ka b fi kk kh l ki kj">createdAt: String</span><span id="159f" class="ke kf hi ka b fi kk kh l ki kj">updatedAt: String</span><span id="a32f" class="ke kf hi ka b fi kk kh l ki kj">isDone: Boolean</span><span id="98ac" class="ke kf hi ka b fi kk kh l ki kj">owner_id: ID</span><span id="93cc" class="ke kf hi ka b fi kk kh l ki kj">}</span><span id="38ec" class="ke kf hi ka b fi kk kh l ki kj">input TodoInput {</span><span id="aab7" class="ke kf hi ka b fi kk kh l ki kj">title: String</span><span id="b85a" class="ke kf hi ka b fi kk kh l ki kj">mission: String</span><span id="f4e5" class="ke kf hi ka b fi kk kh l ki kj">isDone: Boolean</span><span id="2cdd" class="ke kf hi ka b fi kk kh l ki kj">owner_id: ID!</span><span id="ffac" class="ke kf hi ka b fi kk kh l ki kj">}</span></pre><p id="50e5" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">然后打开<strong class="is hj"> db/models/TodoModel.js </strong>，像这样更改模式:</p><pre class="jv jw jx jy fd jz ka kb kc aw kd bi"><span id="6bee" class="ke kf hi ka b fi kg kh l ki kj">const todoSchema = new mongoose.Schema(</span><span id="499d" class="ke kf hi ka b fi kk kh l ki kj">{</span><span id="70d0" class="ke kf hi ka b fi kk kh l ki kj">title: String,</span><span id="1534" class="ke kf hi ka b fi kk kh l ki kj">mission: String,</span><span id="77df" class="ke kf hi ka b fi kk kh l ki kj">isDone: Boolean,</span><span id="7570" class="ke kf hi ka b fi kk kh l ki kj">owner_id: { type: mongoose.SchemaTypes.ObjectId, required: true },</span><span id="331a" class="ke kf hi ka b fi kk kh l ki kj">},</span><span id="cfe0" class="ke kf hi ka b fi kk kh l ki kj">{ timestamps: true }</span><span id="d053" class="ke kf hi ka b fi kk kh l ki kj">);</span></pre><p id="dfdf" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">就是这样！当添加待办事项时，我们会添加所需的配置以对其进行签名。我们来测试一下。复制我们的第一个用户的id并运行这个突变:</p><figure class="jv jw jx jy fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es kn"><img src="../Images/b03ad1835a97e280aaaf1a85b033f987.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1Q3qghMRzLd3uvAKiDaUZw.png"/></div></div><figcaption class="ko kp et er es kq kr bd b be z dx translated">在您的情况下，您很可能需要更改owner_id。</figcaption></figure><p id="c2f8" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">就是这样。我们刚刚添加了一个新的待办事项，并用我们的用户id进行了签名。让我们改变我们的突变，所以根据给定的用户名和密码返回待办事项。为了实现这一点，让我们打开<strong class="is hj"> schema/models/index.js </strong>并将该函数添加到<strong class="is hj">查询</strong>对象，如下所示:</p><pre class="jv jw jx jy fd jz ka kb kc aw kd bi"><span id="3c7e" class="ke kf hi ka b fi kg kh l ki kj">getUserNotes: (id) =&gt;</span><span id="f3eb" class="ke kf hi ka b fi kk kh l ki kj">  new Promise(</span><span id="44c2" class="ke kf hi ka b fi kk kh l ki kj">    async (resolve, reject) =&gt;</span><span id="78c5" class="ke kf hi ka b fi kk kh l ki kj">      await Todo.find({ owner_id: id }, (err, notes) =&gt;</span><span id="32fd" class="ke kf hi ka b fi kk kh l ki kj">        err ? reject(err) : resolve(notes)</span><span id="dc18" class="ke kf hi ka b fi kk kh l ki kj">    )</span><span id="7252" class="ke kf hi ka b fi kk kh l ki kj">  ),</span></pre><p id="9c68" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">并将这些行添加到<strong class="is hj">schema/resolvers/index . js</strong>文件中的<strong class="is hj">查询</strong>对象中:</p><pre class="jv jw jx jy fd jz ka kb kc aw kd bi"><span id="1259" class="ke kf hi ka b fi kg kh l ki kj">getUserNotes: async (parent, args, context) =&gt;</span><span id="1efc" class="ke kf hi ka b fi kk kh l ki kj">  await context.models.Todo.queries.getUserNotes(</span><span id="2d28" class="ke kf hi ka b fi kk kh l ki kj">    JSON.parse(JSON.stringify(args.owner_id))</span><span id="6366" class="ke kf hi ka b fi kk kh l ki kj">  ),</span></pre><p id="2632" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">并将这些行添加到<strong class="is hj">schema/typeDefs/index . js</strong>中的<strong class="is hj">查询</strong>类型定义中:</p><pre class="jv jw jx jy fd jz ka kb kc aw kd bi"><span id="317d" class="ke kf hi ka b fi kg kh l ki kj">getUserNotes(owner_id: ID!): [Todo]</span></pre><p id="876b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">并运行测试查询:</p><figure class="jv jw jx jy fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es km"><img src="../Images/4689673c584f1ffdb4343cbdd7a444f9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WqiZhbNaGcV8457-StIL5w.png"/></div></div></figure><p id="900a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如果一切正常，让我们进入下一章:要求登录认证。</p><h2 id="9289" class="ke kf hi bd ks kt ku kv kw kx ky kz la jb lb lc ld jf le lf lg jj lh li lj lk bi translated">在Apollo服务器中要求登录验证</h2><p id="eafc" class="pw-post-body-paragraph iq ir hi is b it ll iv iw ix lm iz ja jb ln jd je jf lo jh ji jj lp jl jm jn hb bi translated">要进行登录验证，打开<strong class="is hj"> server.js </strong>并更改<strong class="is hj">上下文</strong>对象，如下所示:</p><pre class="jv jw jx jy fd jz ka kb kc aw kd bi"><span id="e28a" class="ke kf hi ka b fi kg kh l ki kj">context: ({ req }) =&gt; {</span><span id="d4a6" class="ke kf hi ka b fi kk kh l ki kj">  const username = req?.headers?.username;</span><span id="d5cf" class="ke kf hi ka b fi kk kh l ki kj">  const password = req?.headers?.password;</span><span id="e1de" class="ke kf hi ka b fi kk kh l ki kj">  const user = await validateUser({ username, password })</span><span id="ed33" class="ke kf hi ka b fi kk kh l ki kj">    .then((result) =&gt; result)</span><span id="371e" class="ke kf hi ka b fi kk kh l ki kj">    .catch((err) =&gt; console.log(err));</span><span id="d5cb" class="ke kf hi ka b fi kk kh l ki kj">  return {</span><span id="d9e0" class="ke kf hi ka b fi kk kh l ki kj">    user,</span><span id="ea76" class="ke kf hi ka b fi kk kh l ki kj">    models: {<br/>      user,</span><span id="e60b" class="ke kf hi ka b fi kk kh l ki kj">      Todo: generateTodoModel(user),</span><span id="8188" class="ke kf hi ka b fi kk kh l ki kj">    },</span><span id="78d8" class="ke kf hi ka b fi kk kh l ki kj">  };</span><span id="2004" class="ke kf hi ka b fi kk kh l ki kj">},</span></pre><p id="2d1d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">创建一个名为<strong class="is hj"> controllers </strong>的目录，并在其中创建一个名为<strong class="is hj"> validateUser.js </strong>的文件。打开<strong class="is hj"> validateUser.js </strong>并将这些行写入其中:</p><pre class="jv jw jx jy fd jz ka kb kc aw kd bi"><span id="1fec" class="ke kf hi ka b fi kg kh l ki kj">import User from "../db/models/UserModel";</span><span id="3081" class="ke kf hi ka b fi kk kh l ki kj">const validateUser = (user) =&gt;</span><span id="15ea" class="ke kf hi ka b fi kk kh l ki kj">  new Promise(</span><span id="021c" class="ke kf hi ka b fi kk kh l ki kj">    async (resolve, reject) =&gt;</span><span id="6d12" class="ke kf hi ka b fi kk kh l ki kj">      await User.findOne({ ...user }, (err, user) =&gt;</span><span id="1d8d" class="ke kf hi ka b fi kk kh l ki kj">        err</span><span id="1448" class="ke kf hi ka b fi kk kh l ki kj">        ? reject(err)</span><span id="8f9d" class="ke kf hi ka b fi kk kh l ki kj">        : user === null</span><span id="be7c" class="ke kf hi ka b fi kk kh l ki kj">        ? reject(new Error("User not found"))</span><span id="4fd0" class="ke kf hi ka b fi kk kh l ki kj">        : resolve(user)</span><span id="51eb" class="ke kf hi ka b fi kk kh l ki kj">    )</span><span id="9be3" class="ke kf hi ka b fi kk kh l ki kj">  );</span><span id="cc84" class="ke kf hi ka b fi kk kh l ki kj">export default validateUser;</span></pre><p id="e92c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在，打开<strong class="is hj">schema/resolvers/index . js</strong>并将<strong class="is hj"> getUserNotes </strong>函数更改如下:</p><pre class="jv jw jx jy fd jz ka kb kc aw kd bi"><span id="9ed5" class="ke kf hi ka b fi kg kh l ki kj">getUserNotes: async (parent, args, context) =&gt;</span><span id="68c3" class="ke kf hi ka b fi kk kh l ki kj">  await context.models.Todo.queries.getUserNotes()</span></pre><p id="59f2" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">然后打开<strong class="is hj"> schema/models/index.js </strong>文件，给<strong class="is hj"> generateTodoModel </strong>函数添加一个<strong class="is hj">用户</strong>参数:</p><pre class="jv jw jx jy fd jz ka kb kc aw kd bi"><span id="bca0" class="ke kf hi ka b fi kg kh l ki kj">const generateTodoModel = ({user}) =&gt; ({<br/>...</span></pre><p id="2df4" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">并更改<strong class="is hj">查询</strong>对象中的<strong class="is hj"> getUserNotes </strong>，就像这样:</p><pre class="jv jw jx jy fd jz ka kb kc aw kd bi"><span id="93a5" class="ke kf hi ka b fi kg kh l ki kj">getUserNotes: () =&gt;</span><span id="26ca" class="ke kf hi ka b fi kk kh l ki kj">  !user</span><span id="2fd8" class="ke kf hi ka b fi kk kh l ki kj">    ? null</span><span id="2625" class="ke kf hi ka b fi kk kh l ki kj">      : new Promise(</span><span id="c4ab" class="ke kf hi ka b fi kk kh l ki kj">        async (resolve, reject) =&gt;</span><span id="9a73" class="ke kf hi ka b fi kk kh l ki kj">          await Todo.find({ owner_id: user._id }, (err, notes) =&gt;</span><span id="513f" class="ke kf hi ka b fi kk kh l ki kj">            err ? reject(err) : resolve(notes)</span><span id="de71" class="ke kf hi ka b fi kk kh l ki kj">          )</span><span id="e885" class="ke kf hi ka b fi kk kh l ki kj">        ),</span></pre><p id="2eee" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">打开<strong class="is hj">schema/typeDefs/index . js</strong>并更改<strong class="is hj"> getUserNotes </strong>查询定义，如下所示:</p><pre class="jv jw jx jy fd jz ka kb kc aw kd bi"><span id="2e80" class="ke kf hi ka b fi kg kh l ki kj">getUserNotes: [Todo]</span></pre><p id="d272" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们打开<a class="ae kl" href="http://localhost:4000/graphql" rel="noopener ugc nofollow" target="_blank">http://localhost:4000/graph QL</a>。单击<strong class="is hj"> GetUserNotes </strong>查询所在的选项卡，然后单击页面下方的<strong class="is hj"> HTTP HEADERS </strong>选项卡，并编写以下几行:</p><figure class="jv jw jx jy fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lq"><img src="../Images/fc304384c862b0b2b12f2b6a7a9c7c3e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gKZRwckF4kUOP-FHPinBlA.png"/></div></div></figure><p id="d1d8" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">然后运行查询！如果您的屏幕是这样的，那么恭喜您，您已经添加了用户验证和授权:</p><figure class="jv jw jx jy fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lr"><img src="../Images/027aef05bcfcd93228715011d3fa2f33.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KDBhdWdGZnqOLw_9lfXKaw.png"/></div></div></figure><p id="216e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">要使用当前登录用户的id自动签署新添加的待办事项，请更改<strong class="is hj"> addUser </strong>变体，如下所示。在<strong class="is hj"> schema/models/index.js </strong>中这样修改它:</p><pre class="jv jw jx jy fd jz ka kb kc aw kd bi"><span id="f8d2" class="ke kf hi ka b fi kg kh l ki kj">addTodo: (todo) =&gt;</span><span id="9679" class="ke kf hi ka b fi kk kh l ki kj">  !user</span><span id="642a" class="ke kf hi ka b fi kk kh l ki kj">    ? null</span><span id="0ad5" class="ke kf hi ka b fi kk kh l ki kj">      : new Promise((resolve, reject) =&gt;</span><span id="db8d" class="ke kf hi ka b fi kk kh l ki kj">        new Todo(</span><span id="d92c" class="ke kf hi ka b fi kk kh l ki kj">          Object.assign({}, { ...todo }, { owner_id: user._id })</span><span id="2230" class="ke kf hi ka b fi kk kh l ki kj">        ).save((err, todo) =&gt; (err ? reject(err) : resolve(todo)))</span><span id="f26a" class="ke kf hi ka b fi kk kh l ki kj">      ),</span></pre><p id="8702" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">…并在<strong class="is hj">schema/resolvers/index . js</strong>中进行如下更改:</p><pre class="jv jw jx jy fd jz ka kb kc aw kd bi"><span id="497f" class="ke kf hi ka b fi kg kh l ki kj">addUser: async (parent, args, context) =&gt;</span><span id="f9de" class="ke kf hi ka b fi kk kh l ki kj">  await context.models.Todo.mutations.addUser(</span><span id="a4f7" class="ke kf hi ka b fi kk kh l ki kj">    JSON.parse(JSON.stringify(args.user))</span><span id="55a6" class="ke kf hi ka b fi kk kh l ki kj">  ),</span></pre><p id="0caf" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">最后，在<strong class="is hj">模式/typeDefs/index.js </strong>中修改输入定义，如下所示:</p><pre class="jv jw jx jy fd jz ka kb kc aw kd bi"><span id="8a89" class="ke kf hi ka b fi kg kh l ki kj">input TodoInput {</span><span id="e939" class="ke kf hi ka b fi kk kh l ki kj">  title: String</span><span id="9fec" class="ke kf hi ka b fi kk kh l ki kj">  mission: String</span><span id="21fa" class="ke kf hi ka b fi kk kh l ki kj">  isDone: Boolean</span><span id="ef39" class="ke kf hi ka b fi kk kh l ki kj">}</span></pre><h1 id="f4c0" class="ls kf hi bd ks lt lu lv kw lw lx ly la lz ma mb ld mc md me lg mf mg mh lj mi bi translated"><strong class="ak">结论</strong></h1><p id="8565" class="pw-post-body-paragraph iq ir hi is b it ll iv iw ix lm iz ja jb ln jd je jf lo jh ji jj lp jl jm jn hb bi translated">用户认证和授权几乎是每个应用程序的核心概念。我试图解释这些概念是如何隐含在阿波罗服务器中的。为了检查其他进一步的配置，您可以克隆<a class="ae kl" href="https://github.com/ardaorkin/todo-app-server" rel="noopener ugc nofollow" target="_blank"> <strong class="is hj"> repo </strong> </a> <strong class="is hj">。</strong></p><p id="0027" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们将在下一集创建一个带有React的Apollo客户端。</p><p id="ce12" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">感谢您的关注。</p></div></div>    
</body>
</html>