<html>
<head>
<title>Create your own Snake Game in Python using Turtle</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Turtle在Python中创建自己的贪吃蛇游戏</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/create-your-own-snake-game-in-python-using-turtle-bd3bf95bb4c1?source=collection_archive---------1-----------------------#2021-09-26">https://medium.com/nerd-for-tech/create-your-own-snake-game-in-python-using-turtle-bd3bf95bb4c1?source=collection_archive---------1-----------------------#2021-09-26</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><h1 id="9193" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">关于蛇的游戏</h1><p id="2e8e" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">我们都可以证明，贪吃蛇游戏可能是我们小时候在手机上玩的第一个游戏，也是我们最喜欢的游戏。相互竞争以获得最高分。</p><p id="b980" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">随着android的出现，我们有了很多更复杂的游戏。尽管如此，贪吃蛇游戏的魅力并没有消失，我们甚至可以在android上看到它的模仿。它的创作仍然引人入胜。</p><p id="7056" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">作为一名python开发人员，我深入研究了如何尽可能简单地创建游戏。我们可以在创建游戏时学习OOP概念，如继承、__init__功能、探索python中的海龟、随机和时间模块。</p><p id="3ad5" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">事不宜迟。让我们直接开始吧。</p><h1 id="0074" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">游戏的目标</h1><p id="da6d" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">玩家必须移动蛇，当蛇碰到食物时，蛇的长度增加，分数也增加。如果蛇头碰到自己的尾巴或屏幕边缘。蛇死了，控制台应该输出游戏结束。</p><h1 id="f6bb" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated"><strong class="ak">构建贪吃蛇游戏的步骤</strong></h1><ol class=""><li id="f93d" class="kg kh hi jf b jg jh jk jl jo ki js kj jw kk ka kl km kn ko bi translated"><strong class="jf hj">安装海龟模块和随机</strong>(请看一下<a class="ae kp" rel="noopener" href="/nerd-for-tech/simulating-a-random-walk-in-python-617d1e6de7d7">我之前的项目</a>模拟随机漫步，以更好地了解海龟模块。)</li><li id="8727" class="kg kh hi jf b jg kq jk kr jo ks js kt jw ku ka kl km kn ko bi translated"><strong class="jf hj">创建游戏屏幕</strong></li><li id="7c9a" class="kg kh hi jf b jg kq jk kr jo ks js kt jw ku ka kl km kn ko bi translated"><strong class="jf hj">创造蛇的身体</strong></li><li id="f366" class="kg kh hi jf b jg kq jk kr jo ks js kt jw ku ka kl km kn ko bi translated"><strong class="jf hj">创建移动蛇的键盘绑定</strong></li><li id="384b" class="kg kh hi jf b jg kq jk kr jo ks js kt jw ku ka kl km kn ko bi translated"><strong class="jf hj">为蛇创造食物(类继承)</strong></li><li id="219e" class="kg kh hi jf b jg kq jk kr jo ks js kt jw ku ka kl km kn ko bi translated"><strong class="jf hj">维护记分板(类继承)</strong></li><li id="3542" class="kg kh hi jf b jg kq jk kr jo ks js kt jw ku ka kl km kn ko bi translated"><strong class="jf hj">检测蛇与食物的碰撞</strong></li><li id="d55b" class="kg kh hi jf b jg kq jk kr jo ks js kt jw ku ka kl km kn ko bi translated"><strong class="jf hj">检测蛇与墙壁的碰撞</strong></li><li id="937a" class="kg kh hi jf b jg kq jk kr jo ks js kt jw ku ka kl km kn ko bi translated"><strong class="jf hj">探测蛇与尾巴的碰撞</strong></li></ol></div><div class="ab cl kv kw gp kx" role="separator"><span class="ky bw bk kz la lb"/><span class="ky bw bk kz la lb"/><span class="ky bw bk kz la"/></div><div class="hb hc hd he hf"><h2 id="6407" class="lc ig hi bd ih ld le lf il lg lh li ip jo lj lk it js ll lm ix jw ln lo jb lp bi translated">第一步:<strong class="ak">安装模块龟和随机</strong></h2><p id="70f0" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">要安装turtle包，你可以在py控制台发出下面的命令。</p><pre class="lq lr ls lt fd lu lv lw lx aw ly bi"><span id="d280" class="lc ig hi lv b fi lz ma l mb mc">pip install turtle</span></pre><h2 id="b1b4" class="lc ig hi bd ih ld le lf il lg lh li ip jo lj lk it js ll lm ix jw ln lo jb lp bi translated"><strong class="ak">步骤2:创建游戏屏幕</strong></h2><pre class="lq lr ls lt fd lu lv lw lx aw ly bi"><span id="1e1e" class="lc ig hi lv b fi lz ma l mb mc">from turtle import Screen, Turtle<br/>import time<br/>screen = Screen()<br/>screen.setup(width=600, height=600)<br/>#giving keyword arguments here for better understanding<br/>screen.bgcolor("black")<br/>screen.title("Snake Game")<br/>screen.tracer(0) #Screen wont refresh<br/># First step is to create a snake</span></pre><p id="ecfd" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">从turtle包中导入屏幕和Turtle类后。我们创建了一个屏幕类的对象。我们使用了以下方法来创建turtle包的可用屏幕，可以在这里找到<a class="ae kp" href="https://docs.python.org/3/library/turtle.html" rel="noopener ugc nofollow" target="_blank"/>(Turtle文档)。</p><p id="3915" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated"><strong class="jf hj">解释-: </strong></p><ul class=""><li id="eb7f" class="kg kh hi jf b jg kb jk kc jo md js me jw mf ka mg km kn ko bi translated"><strong class="jf hj"> screen.title("贪吃蛇游戏")</strong>将设置所需的屏幕标题</li><li id="8859" class="kg kh hi jf b jg kq jk kr jo ks js kt jw ku ka mg km kn ko bi translated"><strong class="jf hj"> screen.setup(width=600，height=600) </strong>用于设置屏幕的高度和宽度</li><li id="80cf" class="kg kh hi jf b jg kq jk kr jo ks js kt jw ku ka mg km kn ko bi translated"><strong class="jf hj"> screen.tracer(0) </strong>将关闭屏幕更新直到刷新</li><li id="5085" class="kg kh hi jf b jg kq jk kr jo ks js kt jw ku ka mg km kn ko bi translated"><strong class="jf hj">screen . bgcolor(" black ")</strong>将设置屏幕的背景色为黑色</li></ul></div><div class="ab cl kv kw gp kx" role="separator"><span class="ky bw bk kz la lb"/><span class="ky bw bk kz la lb"/><span class="ky bw bk kz la"/></div><div class="hb hc hd he hf"><h2 id="f544" class="lc ig hi bd ih ld le lf il lg lh li ip jo lj lk it js ll lm ix jw ln lo jb lp bi translated"><strong class="ak">第三步:创建蛇的身体</strong></h2><pre class="lq lr ls lt fd lu lv lw lx aw ly bi"><span id="a578" class="lc ig hi lv b fi lz ma l mb mc">from turtle import Turtle<br/>xy_starting = [(-20, 0), (-40, 0)]<br/>class Snake:<br/>    def __init__(self):<br/>        # What should happen when we initialize a new snake object<br/>        my_turtle_1 = Turtle("triangle")<br/>        my_turtle_1.color("green")<br/>        self.turtles = [my_turtle_1]<br/>        self.head = self.turtles[0]<br/>        self.create_snake()<br/><br/>    def create_snake(self):<br/>        for coordinates in xy_starting:<br/>            my_turtle = Turtle("square")<br/>            my_turtle.color("green")<br/>            my_turtle.penup()  # to<br/>            my_turtle.goto(coordinates)<br/>            self.turtles.append(my_turtle)<br/>            #Simply appends other turtles passed to the turtles list<br/>            # Changing the positioning of the second and third box <br/>            # they end up on top of each other</span></pre><p id="f2f6" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">我们创建另一个名为snake.py的py文件，在这里我们将创建我们的蛇。</p><pre class="lq lr ls lt fd lu lv lw lx aw ly bi"><span id="c3a1" class="lc ig hi lv b fi lz ma l mb mc">xy_starting = [(-20, 0), (-40, 0)]<br/># Defines the coordinates for our three turtles </span></pre><p id="d7d6" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">我们继续创建蛇的方法是创建三只乌龟，它们显示在屏幕上，如下所示。</p><figure class="lq lr ls lt fd mi er es paragraph-image"><div class="er es mh"><img src="../Images/30a5c846439b2b7a46a23914f0bbffda.png" data-original-src="https://miro.medium.com/v2/resize:fit:470/format:webp/1*m3dQyecgpJ95UQxi9YOHTw.jpeg"/></div><figcaption class="ml mm et er es mn mo bd b be z dx translated">图片来源:我的桌面</figcaption></figure><p id="13c3" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">为了了解海龟坐标系的概念:</p><figure class="lq lr ls lt fd mi er es paragraph-image"><div role="button" tabindex="0" class="mq mr di ms bf mt"><div class="er es mp"><img src="../Images/1390b9446b0860ecb9f51c69c4bf247c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*g5NPmfKj4qpZKBPI8iDjiw.png"/></div></div></figure><p id="1adf" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">从坐标系中我们知道，默认情况下，我们的第一只海龟会出现在坐标(0，0)处。因此，我们应该在(-20，0)和(-40，0)创建第二只海龟。我们将x和y坐标定义为一个列表中的元组。</p><p id="c2d8" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">我们定义了一个名为“create_snake”的新函数。这基本上创造了一只形状为正方形、颜色为绿色的海龟。</p><pre class="lq lr ls lt fd lu lv lw lx aw ly bi"><span id="9448" class="lc ig hi lv b fi lz ma l mb mc">def create_snake(self):<br/>        for coordinates in xy_starting:<br/>            my_turtle = Turtle("square")<br/>            my_turtle.color("green")<br/>            my_turtle.penup()  # to stop the turtle from drawing<br/>            my_turtle.goto(coordinates)<br/>            self.turtles.append(my_turtle)</span></pre><p id="0d59" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated"><strong class="jf hj">解说-: </strong></p><ul class=""><li id="3bc0" class="kg kh hi jf b jg kb jk kc jo md js me jw mf ka mg km kn ko bi translated"><strong class="jf hj">my_turtle = turtle(" square ")</strong>将创建一个名为“my _ Turtle”的方形Turtle类对象。</li><li id="fdcc" class="kg kh hi jf b jg kq jk kr jo ks js kt jw ku ka mg km kn ko bi translated"><strong class="jf hj"> my_turtle.color("green") </strong>将乌龟的颜色设置为绿色。作为青蛇是有道理的。</li><li id="9488" class="kg kh hi jf b jg kq jk kr jo ks js kt jw ku ka mg km kn ko bi translated">my_turtle.penup() 在移动时，也就是在创建3只乌龟时，将停止乌龟的绘制。</li><li id="644a" class="kg kh hi jf b jg kq jk kr jo ks js kt jw ku ka mg km kn ko bi translated"><strong class="jf hj">my _ turtle . goto(coordinates)</strong>当for循环遍历xy坐标列表时，将使turtle转到这些x-y坐标。</li><li id="4f12" class="kg kh hi jf b jg kq jk kr jo ks js kt jw ku ka mg km kn ko bi translated"><strong class="jf hj">self . turtles . append(my _ turtle)</strong>会将新的海龟添加到类开始时初始化的“海龟”列表中。</li></ul><h2 id="d8cb" class="lc ig hi bd ih ld le lf il lg lh li ip jo lj lk it js ll lm ix jw ln lo jb lp bi translated">__init__函数</h2><pre class="lq lr ls lt fd lu lv lw lx aw ly bi"><span id="af34" class="lc ig hi lv b fi lz ma l mb mc">class Snake:<br/>    def __init__(self):<br/>        # What should happen when we initialize a new snake object<br/>        my_turtle_1 = Turtle("triangle")<br/>        my_turtle_1.color("green")<br/>        self.turtles = [my_turtle_1]<br/>        self.head = self.turtles[0]<br/>        self.create_snake()</span></pre><p id="0da3" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">记住，每当你从任何类中初始化一个新的对象时，就会调用<strong class="jf hj">“init”</strong>。我们将创建一个三角形的蛇头，并将其添加到一个名为“海龟”的列表中。</p><p id="a89e" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">另一种理解方式是，在我们的<strong class="jf hj"> __init__ </strong>函数中成功的<strong class="jf hj">“self”</strong>可以被整个类使用和调用。它们成为整个类的全局变量。</p><p id="8f96" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">类似地，Snake类的许多对象可以通过传递不同的乌龟作为参数来创建。</p><p id="8c16" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated"><strong class="jf hj">解释-: </strong></p><ul class=""><li id="0f7a" class="kg kh hi jf b jg kb jk kc jo md js me jw mf ka mg km kn ko bi translated"><strong class="jf hj">my _ turtle _ 1 = Turtle(" triangle ")</strong>将创建一个形状为三角形的Turtle类的对象。</li><li id="4961" class="kg kh hi jf b jg kq jk kr jo ks js kt jw ku ka mg km kn ko bi translated">我的乌龟会把我们的第一只乌龟变成绿色</li><li id="1df9" class="kg kh hi jf b jg kq jk kr jo ks js kt jw ku ka mg km kn ko bi translated"><strong class="jf hj">self . turtles =[my_turtle_1]</strong>会创建一个乌龟对象列表，以my _ turtle _ 1作为第一个乌龟对象或者头。</li><li id="7144" class="kg kh hi jf b jg kq jk kr jo ks js kt jw ku ka mg km kn ko bi translated"><strong class="jf hj">self . head = self . turtles[0]</strong>将提取蛇的头部(或龟的列表)</li><li id="7166" class="kg kh hi jf b jg kq jk kr jo ks js kt jw ku ka mg km kn ko bi translated">最后，我们调用create_snake()函数来创建我们的蛇。</li></ul><blockquote class="mu mv mw"><p id="4ab0" class="jd je mx jf b jg kb ji jj jk kc jm jn my kd jq jr mz ke ju jv na kf jy jz ka hb bi translated"><strong class="jf hj">因此，每当“类蛇”的任何对象被创建时，上面的代码行就像在__init__函数中一样被执行。</strong></p></blockquote></div><div class="ab cl kv kw gp kx" role="separator"><span class="ky bw bk kz la lb"/><span class="ky bw bk kz la lb"/><span class="ky bw bk kz la"/></div><div class="hb hc hd he hf"><h2 id="13f5" class="lc ig hi bd ih ld le lf il lg lh li ip jo lj lk it js ll lm ix jw ln lo jb lp bi translated"><strong class="ak">步骤4:创建键盘绑定来移动蛇</strong></h2><p id="92a7" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated"><strong class="jf hj"> 4.1:移动蛇</strong></p><p id="35a4" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">我们定义了另一个函数“move”来实现移动蛇的功能。</p><pre class="lq lr ls lt fd lu lv lw lx aw ly bi"><span id="3149" class="lc ig hi lv b fi lz ma l mb mc">def move(self):<br/>    for turtle in range(len(self.turtles) - 1, 0, -1):<br/>        # Simply start = 2, stop = 0, step = -1<br/>        # to goto a particular x and y position<br/>        x_coord = self.turtles[turtle - 1].xcor()<br/>        y_coord = self.turtles[turtle - 1].ycor()<br/>        # turtles[turtle].penup()<br/>        self.turtles[turtle].goto(x_coord, y_coord)<br/>    self.turtles[0].penup()# To not make drawing a line when moving<br/>    self.turtles[0].forward(move_by_forward)</span></pre><p id="edbd" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">我们希望我们所有的海龟一起移动来实现这一点，我们遍历每个海龟对象，并使用“goto”方法将海龟移动到成功的海龟的先前位置。</p><p id="00bf" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated"><strong class="jf hj">解说:</strong></p><ul class=""><li id="e113" class="kg kh hi jf b jg kb jk kc jo md js me jw mf ka mg km kn ko bi translated"><strong class="jf hj">for turtle in range(len(self . turtles)-1，0，-1) </strong>将从乌龟的头部到尾部遍历乌龟对象“turtles”列表。(最后一只乌龟)。其中<strong class="jf hj">" len(self . turtles)-1 "</strong>返回值2，0为<strong class="jf hj">-1 "</strong>步长的停止值</li><li id="263b" class="kg kh hi jf b jg kq jk kr jo ks js kt jw ku ka mg km kn ko bi translated"><strong class="jf hj">x _ coord = self . turtles[turtle—1]。xcor() </strong>获取当前被迭代的海龟的x坐标。</li><li id="bf88" class="kg kh hi jf b jg kq jk kr jo ks js kt jw ku ka mg km kn ko bi translated"><strong class="jf hj">y _ coord = self . turtles[turtle—1]。ycor() </strong>获取当前被迭代的乌龟后面的乌龟的y坐标。</li><li id="3527" class="kg kh hi jf b jg kq jk kr jo ks js kt jw ku ka mg km kn ko bi translated"><strong class="jf hj"> self.turtles【乌龟】。goto(x_coord，y_coord) </strong>将海龟移动到下一个海龟的坐标x_coord，y_coord。</li><li id="7455" class="kg kh hi jf b jg kq jk kr jo ks js kt jw ku ka mg km kn ko bi translated"><strong class="jf hj"> self.turtles[0]。penup() </strong>会移动乌龟的头而不画图。</li><li id="cd05" class="kg kh hi jf b jg kq jk kr jo ks js kt jw ku ka mg km kn ko bi translated"><strong class="jf hj"> self.turtles[0]。前进(move_by_forward) </strong>将乌龟移动20步。</li></ul><h2 id="0694" class="lc ig hi bd ih ld le lf il lg lh li ip jo lj lk it js ll lm ix jw ln lo jb lp bi translated"><strong class="ak"> 4.2:创建键盘绑定</strong></h2><pre class="lq lr ls lt fd lu lv lw lx aw ly bi"><span id="f594" class="lc ig hi lv b fi lz ma l mb mc">def up(self):<br/>    # If the turtle goes up it shouldn't be going down by pressing   down arrow<br/>    if self.head.heading() != DOWN:<br/>        self.head.setheading(UP)<br/><br/>def down(self):<br/>    # If the turtle goes down it shouldn't be going up by pressing up arrow<br/>    if self.head.heading() != UP:<br/>        self.head.setheading(DOWN)<br/><br/>def right(self):<br/>    # If the turtle goes right it shouldn't be going left by pressing left arrow<br/>    if self.head.heading() != LEFT:<br/>        self.head.setheading(RIGHT)<br/><br/>def left(self):<br/>    # If the turtle goes left it shouldn't be going right by pressing right arrow<br/>    if self.head.heading() != RIGHT:<br/>        self.head.setheading(LEFT)</span></pre><p id="1719" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">我们定义了4个函数上、下、右和左。解释海龟向不同方向的运动。</p><p id="fa98" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">我们还应该考虑蛇游戏的逻辑，如果:</p><blockquote class="mu mv mw"><p id="7204" class="jd je mx jf b jg kb ji jj jk kc jm jn my kd jq jr mz ke ju jv na kf jy jz ka hb bi translated">self . head . heading()-指向蛇的当前头部</p></blockquote><ul class=""><li id="06b9" class="kg kh hi jf b jg kb jk kc jo md js me jw mf ka mg km kn ko bi translated">如果海龟上升，按下条件<strong class="jf hj">给出的向下箭头，它就不会下降！= DOWN </strong>只比我们可以设置的头指向“UP”<strong class="jf hj">self . head . set heading(UP)</strong>。</li><li id="48e1" class="kg kh hi jf b jg kq jk kr jo ks js kt jw ku ka mg km kn ko bi translated">如果海龟掉下去了，按下条件if <strong class="jf hj"> self.head.heading()！= UP </strong>。</li><li id="c7a1" class="kg kh hi jf b jg kq jk kr jo ks js kt jw ku ka mg km kn ko bi translated">如果乌龟往右走，按条件if <strong class="jf hj"> self.head.heading()！=左</strong>。</li><li id="cc74" class="kg kh hi jf b jg kq jk kr jo ks js kt jw ku ka mg km kn ko bi translated">如果乌龟向左走，按下条件if <strong class="jf hj"> self.head.heading()给出的右箭头，它就不应该向右走！=右</strong>。</li></ul><pre class="lq lr ls lt fd lu lv lw lx aw ly bi"><span id="ea1a" class="lc ig hi lv b fi lz ma l mb mc"># Hardcoding Headings for easy readability<br/>UP = 90<br/>DOWN = 270<br/>RIGHT = 0<br/>LEFT = 180</span></pre><p id="4af7" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">我把标题硬编码了，标题基本上是表示方向的度数。</p><pre class="lq lr ls lt fd lu lv lw lx aw ly bi"><span id="506a" class="lc ig hi lv b fi lz ma l mb mc"># Incorporating Event Listeners<br/>snake = Snake()<br/>screen.listen()<br/>screen.onkey(snake.up, "Up")<br/>screen.onkey(snake.down, "Down")<br/>screen.onkey(snake.left, "Left")<br/>screen.onkey(snake.right, "Right")</span></pre><p id="6c40" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">为了创建keayboard绑定，我们转到main.py。</p><p id="31ea" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated"><strong class="jf hj">解释-: </strong></p><ul class=""><li id="802e" class="kg kh hi jf b jg kb jk kc jo md js me jw mf ka mg km kn ko bi translated">将创建一个类snake的对象。</li><li id="93b0" class="kg kh hi jf b jg kq jk kr jo ks js kt jw ku ka mg km kn ko bi translated"><strong class="jf hj"> screen.listen() </strong>在TurtleScreen上设置焦点(以便收集按键事件)</li><li id="8a41" class="kg kh hi jf b jg kq jk kr jo ks js kt jw ku ka mg km kn ko bi translated"><strong class="jf hj"> screen.onkey(snake.up，" up") </strong>将snake类的" Up "函数绑定到键盘上的向上箭头。</li><li id="24c9" class="kg kh hi jf b jg kq jk kr jo ks js kt jw ku ka mg km kn ko bi translated"><strong class="jf hj"> screen.onkey(snake.down，" down") </strong>将snake类的" Down "函数绑定到键盘上的向上箭头。</li><li id="5bc9" class="kg kh hi jf b jg kq jk kr jo ks js kt jw ku ka mg km kn ko bi translated"><strong class="jf hj"> screen.onkey(snake.left，" left") </strong>将snake类的" Left "函数绑定到键盘上的向上箭头。</li><li id="f10e" class="kg kh hi jf b jg kq jk kr jo ks js kt jw ku ka mg km kn ko bi translated"><strong class="jf hj"> screen.onkey(snake.right，“右”)</strong>将snake类的“右”函数绑定到键盘上的向上箭头。</li></ul></div><div class="ab cl kv kw gp kx" role="separator"><span class="ky bw bk kz la lb"/><span class="ky bw bk kz la lb"/><span class="ky bw bk kz la"/></div><div class="hb hc hd he hf"><h2 id="42d2" class="lc ig hi bd ih ld le lf il lg lh li ip jo lj lk it js ll lm ix jw ln lo jb lp bi translated">第五步:为蛇创造食物</h2><p id="bc71" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">我们创建了一个名为food.py的新文件，并在其中定义了一个名为“food”的类来为我们的蛇创建食物。</p><pre class="lq lr ls lt fd lu lv lw lx aw ly bi"><span id="6331" class="lc ig hi lv b fi lz ma l mb mc">from turtle import Turtle<br/>import random<br/><br/>class Food(Turtle):<br/><br/>    def __init__(self):<br/>        super().__init__()<br/>        self.shape("circle")<br/>        self.penup()<br/>        self.shapesize(stretch_len=1, stretch_wid=1)<br/>        self.color("blue")<br/>        self.speed("fastest")<br/>        random_x = random.randint(-280, 280)<br/>        random_y = random.randint(-280, 280)<br/>        self.goto(random_x, random_y)<br/><br/>    # Defining a function for changing the position of food<br/>    # with every iteration<br/>    def refresh(self):<br/>        random_x = random.randint(-280, 280)<br/>        random_y = random.randint(-280, 280)<br/>        self.goto(random_x, random_y)</span></pre><h2 id="9749" class="lc ig hi bd ih ld le lf il lg lh li ip jo lj lk it js ll lm ix jw ln lo jb lp bi translated">类继承</h2><p id="cb1b" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">我们不用从turtle包中再次创建Turtle类的对象，而是使用类继承来继承这个类的所有属性和方法。</p><p id="9ad0" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">方法是简单地在类定义中将“Turtle”作为参数传递。</p><pre class="lq lr ls lt fd lu lv lw lx aw ly bi"><span id="9800" class="lc ig hi lv b fi lz ma l mb mc">class Food(Turtle):</span></pre><p id="4809" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">为了实现子类Food中超类(Turtle)的__init__函数的功能，我们使用了“super”关键字。</p><pre class="lq lr ls lt fd lu lv lw lx aw ly bi"><span id="c133" class="lc ig hi lv b fi lz ma l mb mc">def __init__(self):<br/>        super().__init__()</span></pre><p id="126f" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">定义食物的大小</p><pre class="lq lr ls lt fd lu lv lw lx aw ly bi"><span id="939a" class="lc ig hi lv b fi lz ma l mb mc">self.shapesize(stretch_len=1, stretch_wid=1)</span></pre><p id="90e0" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">定义当食物被蛇吃掉时，食物应该跳到哪里的随机坐标。</p><pre class="lq lr ls lt fd lu lv lw lx aw ly bi"><span id="d718" class="lc ig hi lv b fi lz ma l mb mc">random_x = random.randint(-280, 280)<br/>        random_y = random.randint(-280, 280)<br/>        self.goto(random_x, random_y)</span></pre><p id="f9a7" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">我们定义了另一个函数“refresh ”,它将使食物进入随机坐标。</p><pre class="lq lr ls lt fd lu lv lw lx aw ly bi"><span id="2879" class="lc ig hi lv b fi lz ma l mb mc">def refresh(self):<br/>        random_x = random.randint(-280, 280)<br/>        random_y = random.randint(-280, 280)<br/>        self.goto(random_x, random_y)</span></pre></div><div class="ab cl kv kw gp kx" role="separator"><span class="ky bw bk kz la lb"/><span class="ky bw bk kz la lb"/><span class="ky bw bk kz la"/></div><div class="hb hc hd he hf"><h2 id="4978" class="lc ig hi bd ih ld le lf il lg lh li ip jo lj lk it js ll lm ix jw ln lo jb lp bi translated">步骤6 : <strong class="ak">维护记分牌</strong></h2><p id="f8d3" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">我们创建了一个名为scoreboard的新pyfile，其中有一个类记分牌，用于在蛇吃食物时维护用户的分数。</p><pre class="lq lr ls lt fd lu lv lw lx aw ly bi"><span id="f32e" class="lc ig hi lv b fi lz ma l mb mc">from turtle import Turtle<br/><br/>class Scoreboard(Turtle):<br/><br/>    def __init__(self):<br/>        super().__init__()<br/>        self.score = 0<br/>        # need to give white color otherwise it wont be visible as<br/>        # it will be in black<br/>        self.color("white")<br/>        self.penup()<br/>        self.goto(0, 270)<br/>        # Deciding upon the coordinates of where the scoreboard is to be placed<br/>        self.write(f"Score: {self.score}", align="center", font=("Arial", 24, "normal"))<br/>        self.hideturtle()<br/>        # Deciding upon the coordinates of where the scoreboard is to be placed<br/><br/>    def update_scoreboard(self):<br/>        self.write(f"Score: {self.score}", align="center", font=("Arial", 24, "normal"))<br/><br/>    def increase_score(self):<br/>        self.score += 1<br/>        self.clear()<br/>        self.update_scoreboard()<br/>        self.write(f"Score: {self.score}", align="center", font=("Arial", 24, "normal"))<br/><br/>    def game_over(self):<br/>        self.goto(0, 0)<br/>        self.write("GAME OVER", align="center", font=("Arial", 24, "normal"))</span></pre><p id="cade" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">为了简洁起见，我在代码中添加了注释。我已经创建了4个函数__init__用白色创建了分数图形。</p><pre class="lq lr ls lt fd lu lv lw lx aw ly bi"><span id="8b1f" class="lc ig hi lv b fi lz ma l mb mc">self.goto(0, 270)</span></pre><p id="0e20" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">定义记分板放置在屏幕中间顶部的位置。x轴= 0，y轴= 270</p><pre class="lq lr ls lt fd lu lv lw lx aw ly bi"><span id="d7b5" class="lc ig hi lv b fi lz ma l mb mc">update_scoreboard(self)</span></pre><p id="1c6b" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">每次调用都会更新记分板。</p><pre class="lq lr ls lt fd lu lv lw lx aw ly bi"><span id="6d00" class="lc ig hi lv b fi lz ma l mb mc">increase_score(self)</span></pre><p id="97d0" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">会增加分数，也会清除以前的分数。</p><pre class="lq lr ls lt fd lu lv lw lx aw ly bi"><span id="3733" class="lc ig hi lv b fi lz ma l mb mc">game_over(self)</span></pre><p id="ed55" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">在这种情况下，记分板将返回零值。</p><h2 id="5d02" class="lc ig hi bd ih ld le lf il lg lh li ip jo lj lk it js ll lm ix jw ln lo jb lp bi translated"><strong class="ak">步骤7:检测蛇与食物的碰撞</strong></h2><pre class="lq lr ls lt fd lu lv lw lx aw ly bi"><span id="fe15" class="lc ig hi lv b fi lz ma l mb mc">## DETECTING COLLISION WITH FOOD<br/>## Detecting collision by using distance method<br/>## Checking the distance of the snake from the food<br/>## We know that food is 10 by 10 in dimensions<br/>## After testing 15 was the best one<br/>if snake.head.distance(food) &lt; 15:<br/>    food.refresh()<br/>    snake.extend()<br/>    scoreboard.increase_score()</span></pre><p id="f1b4" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">碰撞可以通过蛇和食物之间的距离来解释，该距离应该小于15(测试时)。碰撞后需要执行三个动作。</p><ol class=""><li id="63e2" class="kg kh hi jf b jg kb jk kc jo md js me jw mf ka kl km kn ko bi translated">食物应该在一个新的位置生成——food . refresh()</li><li id="463d" class="kg kh hi jf b jg kq jk kr jo ks js kt jw ku ka kl km kn ko bi translated">蛇应该伸出尾巴— snake.extend()</li><li id="c33e" class="kg kh hi jf b jg kq jk kr jo ks js kt jw ku ka kl km kn ko bi translated">记分板的分数增加— scoreboard.increase_score()</li></ol><p id="57b1" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">1和3已经讨论过了，让我们看看如何实现2。那是延长尾巴。</p><pre class="lq lr ls lt fd lu lv lw lx aw ly bi"><span id="5e7b" class="lc ig hi lv b fi lz ma l mb mc">def add_turtle(self, coordinates):<br/>    my_turtle = Turtle("square")<br/>    my_turtle.color("green")<br/>    my_turtle.penup()  # to<br/>    my_turtle.goto(coordinates)<br/>    self.turtles.append(my_turtle)<br/><br/>def extend(self):<br/>    #catches the tail of the snake and inserts a turtle there<br/>    self.add_turtle(self.turtles[-1].position())</span></pre><p id="fbbb" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">我们在snake.py文件中定义了两个新函数“add_turtle”和“extend”</p><p id="757a" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">add_turtle从extend函数中获取一个对象和尾巴的坐标，并简单地将一个新创建的turtle添加到turtles列表中，从而增加turtle列表中turtle对象的数量以及蛇的长度。</p></div><div class="ab cl kv kw gp kx" role="separator"><span class="ky bw bk kz la lb"/><span class="ky bw bk kz la lb"/><span class="ky bw bk kz la"/></div><div class="hb hc hd he hf"><h2 id="1bdb" class="lc ig hi bd ih ld le lf il lg lh li ip jo lj lk it js ll lm ix jw ln lo jb lp bi translated">步骤8 : <strong class="ak">检测蛇与屏幕边界的碰撞</strong></h2><pre class="lq lr ls lt fd lu lv lw lx aw ly bi"><span id="5987" class="lc ig hi lv b fi lz ma l mb mc">## DETECTING COLLISION WITH WALL<br/><br/>if snake.head.xcor() &gt; 290 or snake.head.xcor() &lt; -290 or snake.head.ycor() &gt; 290 or snake.head.ycor() &lt; -290:<br/>    snake_moves = False<br/>    scoreboard.game_over()<br/>    ## Game ends</span></pre><p id="59fe" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">为了检测蛇的碰撞，我们只对当它碰到屏幕边界时的头部感兴趣。我们可以用一个简单的if条件来检查这一点，它检查乌龟头部的x和y坐标。</p><p id="4cb9" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">通过测试发现，x和y坐标中的290°和-290°将是我们定义屏幕边界和冲突的最佳选择。</p></div><div class="ab cl kv kw gp kx" role="separator"><span class="ky bw bk kz la lb"/><span class="ky bw bk kz la lb"/><span class="ky bw bk kz la"/></div><div class="hb hc hd he hf"><h2 id="192c" class="lc ig hi bd ih ld le lf il lg lh li ip jo lj lk it js ll lm ix jw ln lo jb lp bi translated">步骤9:检测蛇与自己尾巴的碰撞</h2><pre class="lq lr ls lt fd lu lv lw lx aw ly bi"><span id="6266" class="lc ig hi lv b fi lz ma l mb mc">## DETECT COLLISION WITH TAIL<br/>for turtle in snake.turtles:<br/>    if turtle == snake.head:<br/>        pass<br/>    elif snake.head.distance(turtle) &lt; 10:<br/>        snake_moves = False<br/>        scoreboard.game_over()</span></pre><p id="33ab" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">elif snake.head.distance(乌龟)&lt; 10 accounts for the distance of the head of the turtle with the previous turtles in snake if it is found to be less than 10 the while loop breaks snake_moves = False and the game over message is poped up by calling the game over function in the scoreborard class.</p><p id="780c" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">The complete code can be found <a class="ae kp" href="https://github.com/Ayu-dxt777/100daysofpython/tree/main/Snake%20Game" rel="noopener ugc nofollow" target="_blank">此处</a>。</p><p id="11eb" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">最后的结果是:</p><figure class="lq lr ls lt fd mi er es paragraph-image"><div role="button" tabindex="0" class="mq mr di ms bf mt"><div class="er es nb"><img src="../Images/32199c8cd4c6333c75200c33b9751a04.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*D80wXlO3jFAseGcI68e6zQ.gif"/></div></div></figure><p id="c982" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated"><strong class="jf hj">总结</strong></p><p id="53e7" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">我们成功开发了贪吃蛇游戏，在这个过程中，我们学习了海龟模块、类继承、OOP概念，比如__init__功能。</p></div><div class="ab cl kv kw gp kx" role="separator"><span class="ky bw bk kz la lb"/><span class="ky bw bk kz la lb"/><span class="ky bw bk kz la"/></div><div class="hb hc hd he hf"><p id="7fa8" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">你喜欢我的努力吗？如果是的话，请跟我来获取我的最新帖子和更新，或者更好的是，请我喝杯咖啡！☕</p><figure class="lq lr ls lt fd mi er es paragraph-image"><a href="https://www.buymeacoffee.com/ayushdixit"><div class="er es nc"><img src="../Images/3bbcc67f2c463738de4869129603300d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Nh1owl6a3HdaRB_Y0y04pw.png"/></div></a></figure><div class="nd ne ez fb nf ng"><a href="https://www.buymeacoffee.com/ayushdixit" rel="noopener  ugc nofollow" target="_blank"><div class="nh ab dw"><div class="ni ab nj cl cj nk"><h2 class="bd hj fi z dy nl ea eb nm ed ef hh bi translated">ayushdixit正在编码、部署项目和写博客</h2><div class="nn l"><h3 class="bd b fi z dy nl ea eb nm ed ef dx translated">嘿👋我刚刚在这里创建了一个页面。你现在可以给我买杯咖啡了！</h3></div><div class="no l"><p class="bd b fp z dy nl ea eb nm ed ef dx translated">www.buymeacoffee.com</p></div></div><div class="np l"><div class="nq l nr ns nt np nu mj ng"/></div></div></a></div></div></div>    
</body>
</html>