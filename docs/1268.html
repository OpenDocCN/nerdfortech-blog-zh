<html>
<head>
<title>Sorting Algorithms: Insertion Sort</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">排序算法:插入排序</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/sorting-algorithms-insertion-sort-e018917d2b1b?source=collection_archive---------23-----------------------#2021-03-11">https://medium.com/nerd-for-tech/sorting-algorithms-insertion-sort-e018917d2b1b?source=collection_archive---------23-----------------------#2021-03-11</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="fd6f" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">(Javascript 实现)</h2></div><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es ix"><img src="../Images/70658e96ef007ebe65d3d21de1a4dc75.png" data-original-src="https://miro.medium.com/v2/resize:fit:1328/format:webp/1*ieFC8E1qLfM9ltGx59Pwng.png"/></div><figcaption class="jf jg et er es jh ji bd b be z dx translated">插入排序算法</figcaption></figure><h2 id="c8ab" class="jj jk hi bd jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg bi translated">时间复杂度:</h2><p id="8ebd" class="pw-post-body-paragraph kh ki hi kj b kk kl ij km kn ko im kp ju kq kr ks jy kt ku kv kc kw kx ky kz hb bi translated">最坏情况:<strong class="kj hj"> O(n ) </strong></p><h2 id="3d03" class="jj jk hi bd jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg bi translated">工作原理:</h2><p id="6c07" class="pw-post-body-paragraph kh ki hi kj b kk kl ij km kn ko im kp ju kq kr ks jy kt ku kv kc kw kx ky kz hb bi translated">插入排序的工作原理与选择排序和冒泡排序稍有不同。</p><p id="0a22" class="pw-post-body-paragraph kh ki hi kj b kk la ij km kn lb im kp ju lc kr ks jy ld ku kv kc le kx ky kz hb bi translated">为了对数组进行排序，插入排序所做的是创建一个总是被排序的左边部分的假想切片。</p><p id="9ae3" class="pw-post-body-paragraph kh ki hi kj b kk la ij km kn lb im kp ju lc kr ks jy ld ku kv kc le kx ky kz hb bi translated">这听起来有点复杂，但非常简单。假设我们认为第一个元素已排序，那么这将是到目前为止已排序的切片。<br/>一旦我们将它与第二个元素进行比较，我们就会知道第二个元素与第一个元素相比是否排序。</p><p id="6fce" class="pw-post-body-paragraph kh ki hi kj b kk la ij km kn lb im kp ju lc kr ks jy ld ku kv kc le kx ky kz hb bi translated">如果第二个元素大于第一个元素，我们保持不变，否则，我们在第一个元素之前插入第二个元素。</p><p id="8d86" class="pw-post-body-paragraph kh ki hi kj b kk la ij km kn lb im kp ju lc kr ks jy ld ku kv kc le kx ky kz hb bi translated">通过这种方式，排序后的切片现在变得更大且已排序，而未排序的部分变得更小。我们只需要继续前进穿过未排序的部分，并找出在哪里插入未排序的元素。</p><p id="92da" class="pw-post-body-paragraph kh ki hi kj b kk la ij km kn lb im kp ju lc kr ks jy ld ku kv kc le kx ky kz hb bi translated">最好的方法是创建一个外部循环，它负责从数组的第二个元素向前移动，直到最后一个元素。和一个嵌套循环，它将比较向后移动的元素。</p><p id="4be8" class="pw-post-body-paragraph kh ki hi kj b kk la ij km kn lb im kp ju lc kr ks jy ld ku kv kc le kx ky kz hb bi translated">让我们通过看这些图片来理解它是如何工作的。红色箭头表示外部循环向前移动，绿色大点表示嵌套循环向后移动。以便将当前值与排序后的元素进行比较。(切片部分的表示只是为了更好地理解正在发生的事情，我们并不创建实际的切片)。</p><p id="de32" class="pw-post-body-paragraph kh ki hi kj b kk la ij km kn lb im kp ju lc kr ks jy ld ku kv kc le kx ky kz hb bi">[1][2,4,5,3]</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="lg lh di li bf lj"><div class="er es lf"><img src="../Images/11501802bb1ab4ff74a8b2046c0515d8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZHYf8wf8nJFQbwtww4u9_Q.png"/></div></div><figcaption class="jf jg et er es jh ji bd b be z dx translated">因为我们认为数组的第一部分已经排序，所以让我们从第二个元素开始，并与第一个元素进行比较。在这种情况下，2 &gt; 1 是真的，所以我们保持它们那样。</figcaption></figure><p id="c429" class="pw-post-body-paragraph kh ki hi kj b kk la ij km kn lb im kp ju lc kr ks jy ld ku kv kc le kx ky kz hb bi">[1,2][4,5,3]</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="lg lh di li bf lj"><div class="er es lf"><img src="../Images/ac096f5993d7567bbdef0e42f0b36c57.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6OsTFgefAkO6gVye6hPLGw.png"/></div></div><figcaption class="jf jg et er es jh ji bd b be z dx translated">我们可以说数组的第一个切片([1，2][4，5，3])是排序的，所以我们向前移动一个索引，并与前一个进行比较。4 大于 2，所以我们认为它仍然排序。</figcaption></figure><p id="2dad" class="pw-post-body-paragraph kh ki hi kj b kk la ij km kn lb im kp ju lc kr ks jy ld ku kv kc le kx ky kz hb bi">[1,2,4][5,3]</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="lg lh di li bf lj"><div class="er es lk"><img src="../Images/15924b1c98fb6739d7eda999b6c445d0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*E6kZRVJicBck-DIsAHPTLw.png"/></div></div><figcaption class="jf jg et er es jh ji bd b be z dx translated">到目前为止，第一个切片排序为[1，2，4]，我们需要继续比较其余的元素。5 大于 4，所以我们继续前进..</figcaption></figure><p id="6d80" class="pw-post-body-paragraph kh ki hi kj b kk la ij km kn lb im kp ju lc kr ks jy ld ku kv kc le kx ky kz hb bi">[1,2,4,5][3]</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="lg lh di li bf lj"><div class="er es ll"><img src="../Images/1966f2d50491b355923938de54c657b2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Fwjy5DAHgzTUR9FV__SdDQ.png"/></div></div><figcaption class="jf jg et er es jh ji bd b be z dx translated">到目前为止，我们的订单片段看起来像这样[1，2，4，5]，现在我们将比较 las 元素。3 大于 5 吗？不，所以我们要把 3 和排序后的部分或者数组进行反向比较。</figcaption></figure><p id="40b3" class="pw-post-body-paragraph kh ki hi kj b kk la ij km kn lb im kp ju lc kr ks jy ld ku kv kc le kx ky kz hb bi">[1,2,4,5][3]</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="lg lh di li bf lj"><div class="er es ll"><img src="../Images/a18a4668fcebb4659c05fff7ef993504.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QzJSDlv2vU5Y5SL5VOdy_g.png"/></div></div><figcaption class="jf jg et er es jh ji bd b be z dx translated">3 比 4 小，所以让我们继续后退。</figcaption></figure><p id="abe0" class="pw-post-body-paragraph kh ki hi kj b kk la ij km kn lb im kp ju lc kr ks jy ld ku kv kc le kx ky kz hb bi">[1,2,4,5][3]</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="lg lh di li bf lj"><div class="er es ll"><img src="../Images/59290fdc05065cfeb4b7cf7f5199a100.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Fp3aOWA6W22eCkNlQa21OQ.png"/></div></div><figcaption class="jf jg et er es jh ji bd b be z dx translated">3 大于 2 吗？是的，它是。所以我们停止迭代，因为我们找到了插入未排序元素的正确位置。</figcaption></figure><p id="6b4e" class="pw-post-body-paragraph kh ki hi kj b kk la ij km kn lb im kp ju lc kr ks jy ld ku kv kc le kx ky kz hb bi">[1,2,3,4,5]</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="lg lh di li bf lj"><div class="er es lk"><img src="../Images/62a82752a7f24073c846c55be8b49a81.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*unKp5Em9G1yVUOyCIE6fFQ.png"/></div></div><figcaption class="jf jg et er es jh ji bd b be z dx translated">我们在正确的索引中插入 3。</figcaption></figure><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="lg lh di li bf lj"><div class="er es ll"><img src="../Images/58e0136f562c6409e7b46ad617370856.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tHROBXlPhru83cX-WFYN8Q.png"/></div></div><figcaption class="jf jg et er es jh ji bd b be z dx translated">该数组已排序。</figcaption></figure><h2 id="bc53" class="jj jk hi bd jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg bi translated">伪代码:</h2><pre class="iy iz ja jb fd lm ln lo lp aw lq bi"><span id="a683" class="jj jk hi ln b fi lr ls l lt lu"><em class="lv">// Start from the second index of the array and compare it with the <br/>   previous one</em></span><span id="c703" class="jj jk hi ln b fi lw ls l lt lu"><em class="lv">// Swap if the second element is greater than the previous one. <br/>   Otherwise just move forward</em></span><span id="f5d0" class="jj jk hi ln b fi lw ls l lt lu"><em class="lv">// Continue to the next element and if is not in the correct order <br/>   iterate backwards through the sorted part and insert it in the <br/>   correct spot</em></span><span id="ba30" class="jj jk hi ln b fi lw ls l lt lu"><em class="lv">// Repeat until everything is sorted</em></span></pre><h2 id="2262" class="jj jk hi bd jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg bi translated">代码:</h2><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="lx ly l"/></div><figcaption class="jf jg et er es jh ji bd b be z dx translated">插入排序实现</figcaption></figure><p id="7e00" class="pw-post-body-paragraph kh ki hi kj b kk la ij km kn lb im kp ju lc kr ks jy ld ku kv kc le kx ky kz hb bi translated">请在此查看对其他基本排序算法的解释:</p><ul class=""><li id="097e" class="lz ma hi kj b kk la kn lb ju mb jy mc kc md kz me mf mg mh bi translated"><a class="ae mi" href="https://eduru.medium.com/sorting-algorithms-bubble-sort-a49ab9de1d7f" rel="noopener"> <em class="lv">气泡排序</em> </a></li><li id="d9ac" class="lz ma hi kj b kk mj kn mk ju ml jy mm kc mn kz me mf mg mh bi translated"><a class="ae mi" href="https://eduru.medium.com/sorting-algorithms-selection-sort-e14651a1a262" rel="noopener"> <em class="lv">选择排序</em> </a></li></ul></div></div>    
</body>
</html>