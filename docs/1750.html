<html>
<head>
<title>Learning Tree Traversal</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">学习树遍历</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/learning-tree-traversal-29e11a6c421d?source=collection_archive---------13-----------------------#2021-04-04">https://medium.com/nerd-for-tech/learning-tree-traversal-29e11a6c421d?source=collection_archive---------13-----------------------#2021-04-04</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="bc33" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">学习数据结构和算法的另一周，我正在学习树遍历。上周，我写了一篇关于我对二分搜索法树的介绍的博客，可以在这里找到。那篇文章概述了什么是树，以及如何用JavaScript类构造树。本文将扩展同一个类，可以在这里找到<a class="ae jd" href="https://replit.com/@liamH47/Trees#index.js" rel="noopener ugc nofollow" target="_blank"/>，以包括一些更常见的树遍历算法。</p></div><div class="ab cl je jf gp jg" role="separator"><span class="jh bw bk ji jj jk"/><span class="jh bw bk ji jj jk"/><span class="jh bw bk ji jj"/></div><div class="hb hc hd he hf"><p id="1e8e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">树遍历是一个经典的计算机科学问题。想法是访问树中的每个节点一次，不管树的形状或具体类型。做这件事有许多方法，每一种方法在不同的情况下都有好处。这与链表、堆栈或队列有很大的不同，在链表、堆栈或队列中，访问每个节点的方式实际上只有一种，那就是以线性方式从开始到结束。</p><p id="618e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">有两种主要的方法来遍历一棵树。第一种叫做广度优先搜索(BFS)，第二种叫做深度优先搜索(DFS)。BFS“跨越”树工作，在移动到它们的孩子之前访问每个节点的兄弟节点，而DFS在它的兄弟节点之前访问一个节点的孩子节点。它们都有相同的时间复杂度，但有时一个会比另一个更好，这取决于具体的场景。</p><figure class="jm jn jo jp fd jq er es paragraph-image"><div class="er es jl"><img src="../Images/da6aace3ed4ad1aa3efb8b5216b700a4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1202/format:webp/1*BXcsdlL2Mr-TNVC16TRk3g.png"/></div></figure><h1 id="bae8" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">广度优先搜索</h1><p id="873f" class="pw-post-body-paragraph if ig hi ih b ii kr ik il im ks io ip iq kt is it iu ku iw ix iy kv ja jb jc hb bi translated">BFS从访问根节点开始，然后从左到右进入下一层。一旦它访问了一个级别右边最远的兄弟节点，它就进入下一个级别，并重复这个过程，直到所有节点都被访问过。为了知道哪个节点需要在树中向下移动，BFS算法必须将节点存储在队列或数组中。这意味着在特别宽的树上，BFS不是一个很好的选择，因为太多的节点必须存储在内存中。在下面的例子中，为了简单起见，我写了一个使用数组而不是队列的BFS算法，尽管队列会更高效。</p><figure class="jm jn jo jp fd jq er es paragraph-image"><div class="er es kw"><img src="../Images/02e75959bdb28413857b835ea0f3f4d6.png" data-original-src="https://miro.medium.com/v2/resize:fit:734/format:webp/1*-tSBaQRpDZZCgqBIE90jTg.png"/></div></figure><p id="3498" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">有些情况下，BFS表现得很好。例如，如果我们正在遍历一个每个节点只有一个子节点的树，那么一次只需要在队列中存储一个节点，因此不需要太多的内存。</p></div><div class="ab cl je jf gp jg" role="separator"><span class="jh bw bk ji jj jk"/><span class="jh bw bk ji jj jk"/><span class="jh bw bk ji jj"/></div><div class="hb hc hd he hf"><h1 id="4ef5" class="jt ju hi bd jv jw kx jy jz ka ky kc kd ke kz kg kh ki la kk kl km lb ko kp kq bi translated">深度优先搜索</h1><p id="3718" class="pw-post-body-paragraph if ig hi ih b ii kr ik il im ks io ip iq kt is it iu ku iw ix iy kv ja jb jc hb bi translated">DFS有几个变种，但有一点是相同的，它们都是先访问一个节点的子节点，再访问它的兄弟节点。主要的变体称为前序、前序和后序。</p><figure class="jm jn jo jp fd jq er es paragraph-image"><div class="er es lc"><img src="../Images/854a0d2cccc3c278a67c0eec5200f57c.png" data-original-src="https://miro.medium.com/v2/resize:fit:640/1*wKmvQ2mh-txpZQ26qwVCuw.gif"/></div><figcaption class="ld le et er es lf lg bd b be z dx translated">在https://visualgo.net/en/bst<a class="ae jd" href="https://visualgo.net/en/bst" rel="noopener ugc nofollow" target="_blank"/>找到更多像这样令人惊叹的可视化工具</figcaption></figure><h2 id="a77e" class="lh ju hi bd jv li lj lk jz ll lm ln kd iq lo lp kh iu lq lr kl iy ls lt kp lu bi translated">中根次序</h2><p id="1ca2" class="pw-post-body-paragraph if ig hi ih b ii kr ik il im ks io ip iq kt is it iu ku iw ix iy kv ja jb jc hb bi translated">Inorder按照值的升序访问节点，如果您需要以这种方式排序返回的数据，这将非常有用。</p><figure class="jm jn jo jp fd jq er es paragraph-image"><div class="er es lv"><img src="../Images/e299f401b85d2b0f97dd96ede89ed418.png" data-original-src="https://miro.medium.com/v2/resize:fit:710/format:webp/1*Zl-skkoc7bMeW2OEZ_hxRQ.png"/></div></figure><h2 id="77b6" class="lh ju hi bd jv li lj lk jz ll lm ln kd iq lo lp kh iu lq lr kl iy ls lt kp lu bi translated">预购</h2><p id="a439" class="pw-post-body-paragraph if ig hi ih b ii kr ik il im ks io ip iq kt is it iu ku iw ix iy kv ja jb jc hb bi translated">Preorder访问根，然后沿着树的左侧向下，然后移动到右侧。</p><figure class="jm jn jo jp fd jq er es paragraph-image"><div class="er es lw"><img src="../Images/501be8d46fc946c0951034dc0a56995c.png" data-original-src="https://miro.medium.com/v2/resize:fit:690/format:webp/1*htLjJRvD-P-WMaQdhlZSdg.png"/></div></figure><h2 id="adb6" class="lh ju hi bd jv li lj lk jz ll lm ln kd iq lo lp kh iu lq lr kl iy ls lt kp lu bi translated">后期订单</h2><p id="12d7" class="pw-post-body-paragraph if ig hi ih b ii kr ik il im ks io ip iq kt is it iu ku iw ix iy kv ja jb jc hb bi translated">Postorder访问树左下角的节点，它是兄弟节点，然后向上移动到父节点。一旦访问了树的左侧，它将访问底部的右侧，并重复与左侧相同的过程。最后，它返回并最后访问根节点。</p><figure class="jm jn jo jp fd jq er es paragraph-image"><div role="button" tabindex="0" class="ly lz di ma bf mb"><div class="er es lx"><img src="../Images/c9a32a88cbac5387ca0aad9281bfe95d.png" data-original-src="https://miro.medium.com/v2/resize:fit:676/format:webp/1*c_gw3pJtlQzdanauxLjHGA.png"/></div></div></figure></div></div>    
</body>
</html>