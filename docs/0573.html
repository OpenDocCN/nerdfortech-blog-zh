<html>
<head>
<title>Visual Studio 2019 Debugging Productivity Tips</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Visual Studio 2019调试生产力提示</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/visual-studio-2019-debugging-productivity-tips-420d6c5aac61?source=collection_archive---------2-----------------------#2021-01-19">https://medium.com/nerd-for-tech/visual-studio-2019-debugging-productivity-tips-420d6c5aac61?source=collection_archive---------2-----------------------#2021-01-19</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/927361a84920b58e80b6f9c76e080a2e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FeJFUHRMfLy_viA2HREmAw.png"/></div></div></figure><h1 id="b169" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">介绍</h1><p id="2612" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">我们假设读者了解Visual Studio中调试的基础知识，但我们将深入探讨调试中的一些主要概念。</p><p id="7428" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">许多开发人员用这个足够强大的知识包来处理他们的调试会话。然而，Visual Studio调试工具提供了更多的功能。以下是Visual Studio调试生产率提示的列表。注意，那些提示和快捷方式已经用<strong class="jq hj"><em class="kr">Visual studio 2019 16.6</em></strong>验证过，没有安装扩展。</p><h1 id="35cd" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">运行到光标处</h1><p id="d265" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">使用快捷键Ctrl+F10，可以让调试器运行到光标指向的那一行。</p><figure class="kt ku kv kw fd ij er es paragraph-image"><div class="er es ks"><img src="../Images/3e3b35ce6b97b92b5e57991b66a063c9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1028/0*YeWoD5CxrSqN4QCc.gif"/></div></figure><h1 id="87ea" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">通过简单的鼠标点击运行执行</h1><p id="12c8" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">在调试一个<em class="kr">运行执行通过这里</em>时，悬停在源代码上，会出现一个绿色图标。这个字形可以点击。</p><figure class="kt ku kv kw fd ij er es paragraph-image"><div class="er es kx"><img src="../Images/7bab5d2f40342491aceffd427b2fde1e.png" data-original-src="https://miro.medium.com/v2/resize:fit:932/0*lM46KgH-JON7pN3p.gif"/></div></figure><h1 id="3eef" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">将下一条语句设置在此处</h1><p id="ed1c" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">通过按住Ctrl键，可以将通过here绿色字形的Run执行转换为set next statement to here。它不同于Run execution through，因为中间的语句没有被执行。因此，在下面的小动画中，我们可以在监视窗口中看到引用obj仍然为空:中间的MyClass构造函数尚未执行。</p><figure class="kt ku kv kw fd ij er es paragraph-image"><div class="er es ky"><img src="../Images/530b2d4ce41469c42d5803218caaba13.png" data-original-src="https://miro.medium.com/v2/resize:fit:1030/0*f8VbA_ECS7x4zy0a.gif"/></div></figure><h1 id="6d7f" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">数据断点命中:当值改变时</h1><p id="0395" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">如果将断点设置为非静态属性设置器，则在更改所有对象的属性值时将会遇到该断点。由于本地(或监视)窗口右键单击:当值改变菜单时中断，可以为单个对象获得相同的行为。</p><p id="2590" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">上面的动画演示了这一功能。只有当obj2。Prop改变，obj不变。道具变了。</p><p id="0469" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">请注意，在调试会话期间，数据断点被绑定到一个活动对象。因此，一旦被调试的进程停止，它就会丢失，不能在将来的调试会话中重用。</p><p id="8966" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">请注意，当值改变时菜单中断，当右键单击本地窗口中的字段时也可用，但不幸的是调试器没有中断现场更改，我不确定这是一个错误还是一个尚未实现的功能？</p><figure class="kt ku kv kw fd ij er es paragraph-image"><div class="er es kz"><img src="../Images/80070177dbad31bff6e27dbe37b73bae.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*xW3SteALT9ppMjhz.gif"/></div></figure><h1 id="a4c3" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">条件断点</h1><p id="e041" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">一个条件可以附加到一个断点上，以便只在特定的情况下中断。在下面的动画中，我们用循环中的条件I <em class="kr"> &gt; 6 </em>来定义断点。然后我们单击Continue，可以看到一旦断点停止，Ivalue实际上是7。</p><figure class="kt ku kv kw fd ij er es paragraph-image"><div class="er es kz"><img src="../Images/38c51fa79d66cbd3703fb53762105885.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*rP4FEhOo8wQjjT0b.gif"/></div></figure><h1 id="e953" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">跟踪断点</h1><p id="a894" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">暂停程序执行是遇到断点时最常见的操作。然而，您可以选择在<em class="kr">输出</em>窗口中不暂停(或暂停)地打印一些轨迹。下面的动画展示了这种可能性，我们在<em class="kr">输出</em>窗口中从0到9追踪I的值。请注意，跟踪断点在代码编辑器的装订线中具有菱形形状。</p><p id="d97a" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">请注意，条件和跟踪操作都可以在断点上指定。</p><figure class="kt ku kv kw fd ij er es paragraph-image"><div class="er es kz"><img src="../Images/dec219b5807f65af08bb9cd377fadf9d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*_JiM9C5VDb--0bY2.gif"/></div></figure><h1 id="1c00" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">跟踪引用超出范围的对象</h1><p id="0867" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">在<em class="kr">观察器中，</em>窗口对象通过它们在当前执行的作用域中的引用名来跟踪。然而，当这种被跟踪的引用超出范围时，它在<em class="kr">观察</em>窗口的上下文中变得没有意义，并且被禁用，即使被引用的对象仍然是活动的。</p><p id="9260" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">在许多情况下，我们希望继续跟踪超出范围的对象的状态。为此，在<em class="kr">观察</em>窗口中右键单击该引用，单击菜单制作对象ID并在要观察的项目中添加$1(或$2或$3…取决于您已经创建了多少个对象ID)。</p><p id="7033" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">下面的动画显示了如何跟踪范围外对象的属性getter的状态，该属性getter以字符串形式返回实际日期时间。它很好地显示了当引用<em class="kr"> obj </em>在<em class="kr"> Fct() </em>的上下文中超出范围时，要监视的<em class="kr"> obj </em>项被禁用，<em class="kr"> $1。道具</em>仍然会更新。</p><figure class="kt ku kv kw fd ij er es paragraph-image"><div class="er es la"><img src="../Images/206349c7965634bb6fe1132d4321147d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1032/0*3_vwccPHsg9E23RO.gif"/></div></figure><h1 id="1239" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">查看函数返回的值</h1><p id="1593" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">源代码有时会忽略函数返回的值。或者有时这个值在调试时显然不可访问。</p><p id="e168" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">这种返回值可以在调试&gt;窗口&gt;自动窗口中显示。<a class="ae lb" href="https://docs.microsoft.com/en-us/visualstudio/debugger/pseudovariables?view=vs-2019" rel="noopener ugc nofollow" target="_blank">伪变量</a> $ReturnValue也可以在<em class="kr">立即</em>和<em class="kr">观察</em>窗口中查看最后一次函数调用返回的值。</p><p id="cc36" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">请注意，只有当Visual Studio调试器附加到进程并且程序被调试器暂停时，菜单“调试”&gt;“窗口”&gt;“自动”才可用。</p><figure class="kt ku kv kw fd ij er es paragraph-image"><div class="er es lc"><img src="../Images/ce9a1826297bd54dbdf20d2e6b8508cc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1314/0*En6DEEXscUrOFbXY.gif"/></div></figure><h1 id="227b" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">重新附加到进程</h1><p id="4be8" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">自从Visual Studio 2017提出了<em class="kr">重附着到进程</em> Shift+Alt+P设施，它非常方便。一旦您将调试器附加到一个进程，Visual Studio就会记住它，并建议将调试器重新附加到同一个进程。<em class="kr"> Same </em>是斜体，因为这里有一个关于进程身份的启发:</p><ul class=""><li id="464c" class="ld le hi jq b jr km jv kn jz lf kd lg kh lh kl li lj lk ll bi translated">如果你附加的进程还活着<em class="kr">重新附加到进程</em>重新附加到它。</li><li id="3f9e" class="ld le hi jq b jr lm jv ln jz lo kd lp kh lq kl li lj lk ll bi translated">否则，Visual Studio会尝试查找具有相同先前进程名称的单个进程，并将调试器重新附加到该进程。</li><li id="48c9" class="ld le hi jq b jr lm jv ln jz lo kd lp kh lq kl li lj lk ll bi translated">如果发现多个进程具有该名称，则<em class="kr">附加到进程</em>对话框打开，仅显示具有相同名称的进程</li><li id="3d21" class="ld le hi jq b jr lm jv ln jz lo kd lp kh lq kl li lj lk ll bi translated">如果找不到该名称的进程，显示<em class="kr">附加到进程</em>对话框</li></ul><figure class="kt ku kv kw fd ij er es paragraph-image"><div class="er es kz"><img src="../Images/e76809a0c35bc5263079125260f09d85.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*ZDSLEmLsSQCeRFBd.gif"/></div></figure><p id="5bd3" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">重新附加到进程也适用于涉及多个进程的调试会话。在这种情况下，Visual Studio会尝试使用与上述相同的试探法来查找它已经附加到的所有进程。</p><h1 id="cb68" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">过程无副作用表达式评估</h1><p id="fc38" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">有时，当在<em class="kr">立即</em>或<em class="kr">监视</em>窗口中对表达式求值时，某些状态会发生变化。这种行为通常是不可取的，你不希望仅仅因为你需要计算一个表达式的值，就破坏你被调试程序的状态。</p><p id="0734" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">为了避免改变任何状态，你可以在你的表达式后面加上nse(无副作用)。下面的动画演示了这种可能性(在<em class="kr">观察</em>窗口中观察<em class="kr">_状态</em>值是否改变)。</p><figure class="kt ku kv kw fd ij er es paragraph-image"><div class="er es lr"><img src="../Images/dca177c673eb1ff8414c6c77e6c6742a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1186/0*r46RZj5UiSutlDP0.gif"/></div></figure><p id="397b" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">这里nse用于<em class="kr">手表</em>窗口。由于<em class="kr">sideffectfct()</em>被监视项目中的<em class="kr">刷新</em>评估按钮，此示例与上一个相比有所不同。</p><figure class="kt ku kv kw fd ij er es paragraph-image"><div class="er es ls"><img src="../Images/9caf4fcc3d981b4fcbbd6577e3b25298.png" data-original-src="https://miro.medium.com/v2/resize:fit:1096/0*XU-3mls3Jl4nUy6p.gif"/></div></figure><p id="5626" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">“监视”窗口中没有副作用表达式求值</p><h1 id="fe28" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">在源代码中显示线程</h1><p id="d7e2" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">众所周知，调试多线程应用程序非常复杂。希望<em class="kr">显示源代码中的线程</em>按钮能有所帮助。它在编辑器栏中引入了标记图标，以跟踪其他线程暂停的位置。这个标记可以用来显示线程id，并最终切换到另一个线程。请注意，如果至少有两个线程暂停在同一位置，则会显示不同的标记符号。</p><figure class="kt ku kv kw fd ij er es paragraph-image"><div class="er es kz"><img src="../Images/dd5a9f24cbecc20db322d7a18e56588b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Qfo-mdYEgcpxgqkl.gif"/></div></figure><p id="1657" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">调试多线程应用程序的更多技巧可在本Microsoft文档中找到:<a class="ae lb" href="https://docs.microsoft.com/en-us/visualstudio/debugger/get-started-debugging-multithreaded-apps?view=vs-2019" rel="noopener ugc nofollow" target="_blank">调试多线程应用程序入门(C#、Visual Basic、C++) </a></p><p id="ec69" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">这是这个小演示的源代码，如果你想玩的话，</p><figure class="kt ku kv kw fd ij"><div class="bz dy l di"><div class="lt lu l"/></div></figure><h1 id="8e2c" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">将IL代码反编译成可以调试的源代码</h1><p id="c3b3" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">我们经常依赖一些黑盒组件:没有源代码的程序集。</p><p id="d93b" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">然而，当调试一个复杂的行为时，观察甚至调试嵌套在引用的黑盒中的逻辑是很方便的。这也是为什么从16.5版本开始Visual Studio 2019可以从编译后的程序集生成一些源代码。这样的源代码然后是可调试的。该功能基于OSS项目<a class="ae lb" href="https://github.com/icsharpcode/ILSpy" rel="noopener ugc nofollow" target="_blank"> ILSpy </a>。</p><p id="6227" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">反编译菜单可以在<em class="kr">模块</em>窗口的汇编右键菜单中提出(如下图动画所示)，也可以在<em class="kr">源文件未找到</em>或<em class="kr">无符号加载</em>对话框中提出。</p><p id="a43b" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">将IL代码反编译成源代码不可能是完美的，因为在编译时会丢失一些源信息。因此，这个特性有一些限制，在这个官方文档的最后解释如下:<a class="ae lb" href="https://docs.microsoft.com/en-us/visualstudio/debugger/decompilation?view=vs-2019" rel="noopener ugc nofollow" target="_blank">从。在调试</a>时使用. NET程序集。</p><figure class="kt ku kv kw fd ij er es paragraph-image"><div class="er es lc"><img src="../Images/4e9c1a8bd18040280738713fb3bc4b58.png" data-original-src="https://miro.medium.com/v2/resize:fit:1314/0*i_RU8Pw1ZWB8nfD-.gif"/></div></figure><h1 id="68b1" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">结论</h1><p id="c44b" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">Visual Studio大放异彩，但在调试方面尤其出色。在这里，我试着选择一些既隐蔽又有用的提示，我希望它们能帮助你提高工作效率。</p><p id="6bf6" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">…..继续学习！！！！</p></div></div>    
</body>
</html>