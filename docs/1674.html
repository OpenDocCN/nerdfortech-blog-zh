<html>
<head>
<title>Stop accessing React context directly</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">停止直接访问React上下文</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/stop-accessing-react-context-directly-ec37ae108b7c?source=collection_archive---------2-----------------------#2021-04-01">https://medium.com/nerd-for-tech/stop-accessing-react-context-directly-ec37ae108b7c?source=collection_archive---------2-----------------------#2021-04-01</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/d83064935042661cfdb0f3e0fb3eb5fc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YePVzjkjsadOqzQ03wl5kA.png"/></div></div></figure><p id="f7a2" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我正在为我的一个同事做代码审查，偶然发现了一些代码，这些代码立即在我的脑海中发出了一个危险信号。</p><pre class="jo jp jq jr fd js jt ju jv aw jw bi"><span id="d753" class="jx jy hi jt b fi jz ka l kb kc">&lt;Checkbox label={translationContext.getTranslation(checkboxLabel)}/&gt;</span></pre><p id="f41e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这类似于我写了很多次的代码，但是在这次特别的回顾中，这一行代码引起了我的注意。我开始思考，<em class="kd">我们要在这个组件中公开整个翻译上下文吗？如果我们需要改变它呢？一定有更好的方法！所以我开始查看我们剩下的代码，发现这不是这个开发者的错。这是一种到处都是的模式(或者我应该说是反模式)!在其他部分，我找到了一些这样的例子:</em></p><pre class="jo jp jq jr fd js jt ju jv aw jw bi"><span id="1a5d" class="jx jy hi jt b fi jz ka l kb kc">... inside functional component<br/>const getNextSection = () =&gt; {<br/>  valid = context.actions.validateCurrentSection()<br/>  <br/>  if(!valid){<br/>    return context.actions.showErrors()<br/>  } else {<br/>    return context.actions.getNextSection()<br/>  }<br/>}</span></pre><p id="217e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们已经创建了这个完整的模式，其中我们的上下文对象拥有这个<code class="du ke kf kg jt b">actions </code>成员，它存储了处理上下文中状态变化的所有函数。幸运的是，我们使用了typescript，所以所有存在于<code class="du ke kf kg jt b">actions</code>中的函数都被记录下来，并且可以自动完成。但是这意味着每个组件都需要访问整个上下文，不管它实际需要的信息有多少。更糟糕的是，这意味着每次上下文改变时，整个组件都要重新渲染！即使发生变化的数据实际上并未被相关组件使用。</p><p id="f014" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这也引入了一些其他问题。如果我们将来需要将这些功能转移到不同的环境中，会怎么样呢？我们需要跟踪每次通过<code class="du ke kf kg jt b">context.actions.functionIWantToMove</code>访问该函数，并改变调用该函数的上下文，这意味着我必须给该组件完全访问第二个上下文的权限。所以它可以访问一个数据或者调用一个函数。</p><p id="f9b5" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我做了一个快速的责备，看看谁可能实现了这样一个不负责任的模式，当然，是我。显然这是一种可怕的做事方式。我们需要一个更好的解决方案。</p><h1 id="1375" class="kh jy hi bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld bi translated">反应钩子救援！</h1><figure class="jo jp jq jr fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es le"><img src="../Images/092eb7b1ab2dd775c48eab00dc5a4c7d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*htAZPYyhEjkTJ1pmag13IQ.png"/></div></div></figure><p id="c9d2" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">React真正擅长的事情之一是分离关注点。没有什么比钩子更能体现这一点了。我回到了最初导致红旗的那一行，我扩展了代码以提供更多的上下文:</p><pre class="jo jp jq jr fd js jt ju jv aw jw bi"><span id="754d" class="jx jy hi jt b fi jz ka l kb kc">import React, {useContext} from "react"<br/>import {TranslationContext} from "../contexts/translation-context.tsx"</span><span id="341c" class="jx jy hi jt b fi lf ka l kb kc">const CheckboxGroup = ({options}) =&gt; (<br/>  translationContext = useContext(TranslationContext)<br/>  &lt;div&gt;<br/>    {options.map(option =&gt; (<br/>      &lt;Checkbox label={translationContext.getTranslation(option.text) /&gt;<br/>      ))<br/>    }<br/>  &lt;/div&gt;<br/>)</span></pre><p id="7da0" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们很快就能制造出一个钩子，以一种更干净的方式完成这个任务。我们<strong class="is hj">的确</strong>最终不得不将<code class="du ke kf kg jt b">Checkbox</code>组件包装在一个包装器组件中，但我认为这是值得的。</p><pre class="jo jp jq jr fd js jt ju jv aw jw bi"><span id="ff3c" class="jx jy hi jt b fi jz ka l kb kc">import React from "react"<br/>import {useTranslate} from "../translate"</span><span id="9c23" class="jx jy hi jt b fi lf ka l kb kc">const TranslatedCheckbox = ({label}) =&gt; {<br/>  const translatedValue = useTranslate(label)<br/>  <br/>  return &lt;Checkbox label={translatedValue} /&gt;<br/>}</span></pre><p id="7a77" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">然后我的外部<code class="du ke kf kg jt b">CheckboxGroup</code>组件看起来像这样:</p><pre class="jo jp jq jr fd js jt ju jv aw jw bi"><span id="d4f1" class="jx jy hi jt b fi jz ka l kb kc">const CheckboxGroup = ({options}) =&gt; (<br/>  &lt;div&gt;<br/>    {options.map(<br/>      option =&gt; &lt;TranslatedCheckbox label={option.label}/&gt;<br/>     )<br/>    }<br/>  &lt;/div&gt;<br/>)</span></pre><p id="0aa7" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这最终会好得多。它不仅更干净，而且通过隐藏翻译的实现细节，修复了我们的抽象漏洞。现在，真正进行翻译的组件需要了解<code class="du ke kf kg jt b">TranslationContext</code>。</p><p id="12bd" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我只想指出，这里的代码片段是为了说明一个观点而设计的例子，经过编辑后只显示了相关的部分。我知道他们不会照原样运行。希望这一点仍能被理解。</p></div></div>    
</body>
</html>