<html>
<head>
<title>GitLab CI/CD from git to K8s</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">从git到K8s的GitLab CI/CD</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/gitlab-ci-cd-from-git-to-k8s-a57c3bf3df3a?source=collection_archive---------2-----------------------#2021-01-23">https://medium.com/nerd-for-tech/gitlab-ci-cd-from-git-to-k8s-a57c3bf3df3a?source=collection_archive---------2-----------------------#2021-01-23</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><blockquote class="if ig ih"><p id="8118" class="ii ij ik il b im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg hb bi translated">在本文中，我将解释如何使用GitLab CI/CD来构建、测试和部署nodejs应用程序到K8s(通过rancher API)</p></blockquote><figure class="ji jj jk jl fd jm er es paragraph-image"><div class="er es jh"><img src="../Images/379cf70314b48a3ef17a02be59b2e412.png" data-original-src="https://miro.medium.com/v2/resize:fit:996/format:webp/1*1fVNnwGF0z9D9goOtgY9kQ.jpeg"/></div></figure><p id="6523" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jp iv iw ix jq iz ja jb jr jd je jf jg hb bi translated">GitLab是什么？</p><p id="0355" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jp iv iw ix jq iz ja jb jr jd je jf jg hb bi translated">GitLab是一个完整的DevOps平台。一个具有无限可能性的应用程序。组织依靠GitLab的源代码管理、CI/CD、安全性等来快速交付软件。</p><p id="a436" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jp iv iw ix jq iz ja jb jr jd je jf jg hb bi translated">什么是GitLab CI/CD？</p><p id="8227" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jp iv iw ix jq iz ja jb jr jd je jf jg hb bi translated">是GitLab的一部分，每当开发人员向应用程序推送代码时，它就构建并测试<br/>软件。<br/> GitLab CD(持续部署)是一种软件服务<br/>，它将每个代码的变更放在生产<br/>中，从而导致生产的日常部署。<br/>这是一个更快的系统，可用于代码<br/>部署和开发。<br/>您可以通过设置自己的<br/> runner(它是一个处理构建的应用程序)来更快地执行作业，并预先安装了<br/>所有的依赖项。<br/>git lab CI解决方案既经济又安全，在成本上<br/>非常灵活，与用于运行它的机器一样。<br/>它允许项目团队成员每天集成他们的<br/>工作，这样集成错误可以通过自动化构建容易地识别<br/>。</p><blockquote class="if ig ih"><p id="3b65" class="ii ij ik il b im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg hb bi translated">GitLab正在使用DIND (docker中的docker)服务来构建和推送docker，这意味着在docker容器中运行docker守护进程。</p></blockquote><p id="9813" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jp iv iw ix jq iz ja jb jr jd je jf jg hb bi translated">使用DIND有什么问题？</p><p id="7fc8" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jp iv iw ix jq iz ja jb jr jd je jf jg hb bi translated">如果你的GitLab实例在Kubernest之外运行，你可以在你的runner机器上使用docker，但在K8s中，DIND服务需要很多权限才能打开，使用DIND也有一些问题，比如</p><p id="88b1" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jp iv iw ix jq iz ja jb jr jd je jf jg hb bi translated">1- (Linux安全模块)像SELinux:当启动一个容器时，“内部Docker”可能会尝试应用与“外部Docker”冲突或混淆的安全配置文件当试图合并-privileged标志的原始实现时，这实际上是最难解决的问题。</p><p id="f4ee" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jp iv iw ix jq iz ja jb jr jd je jf jg hb bi translated">2-当你在Docker中运行Docker时，外部Docker运行在普通文件系统(EXT4、BTRFS等等)之上，而内部Docker运行在一个写时复制系统(AUFS、BTRFS等等)之上..取决于外部对接器被设置成使用什么)。有很多组合是行不通的。例如，你不能在AUFS之上运行AUFS。如果您在BTRFS之上运行BTRFS，它应该首先工作，但是一旦您有了嵌套的子卷，删除父子卷将会失败。</p><p id="7917" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jp iv iw ix jq iz ja jb jr jd je jf jg hb bi translated">因此，我将使用Kaniko executor来构建和推动CI/CD管道中的docker映像，您可以使用DIND来考虑这些问题。</p><p id="c058" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jp iv iw ix jq iz ja jb jr jd je jf jg hb bi translated">kaniko是一个在容器或Kubernetes集群中从Docker文件构建容器映像的工具，它支持在不能轻松或安全地运行Docker守护进程的环境中构建容器映像，比如标准的Kubernetes集群。</p><p id="e809" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jp iv iw ix jq iz ja jb jr jd je jf jg hb bi translated">为什么我选择了Kaniko？</p><p id="a647" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jp iv iw ix jq iz ja jb jr jd je jf jg hb bi translated">1-它不需要docker守护进程</p><p id="9890" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jp iv iw ix jq iz ja jb jr jd je jf jg hb bi translated">2-它不需要任何特殊的特权或许可</p><p id="9b79" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jp iv iw ix jq iz ja jb jr jd je jf jg hb bi translated">3-你可以在一个标准的Kubernetes集群、Google Kubernetes引擎或任何不能访问特权或Docker守护进程的环境中运行“kaniko”。</p><p id="0ca8" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jp iv iw ix jq iz ja jb jr jd je jf jg hb bi translated">Kaniko是如何工作的？</p><figure class="ji jj jk jl fd jm er es paragraph-image"><div class="er es js"><img src="../Images/3c1449f1b3104093877d86f76522e2a1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IUYVlGIBaJC--LQI63Cd4Q.png"/></div></figure><p id="bc84" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jp iv iw ix jq iz ja jb jr jd je jf jg hb bi translated"><strong class="il hj">在我解释了工具和技术之后，让我们开始编写管道</strong></p><p id="6819" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jp iv iw ix jq iz ja jb jr jd je jf jg hb bi translated">我们需要做到以下几点:</p><p id="abd0" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jp iv iw ix jq iz ja jb jr jd je jf jg hb bi translated">1-安装节点模块并构建nodejs应用程序</p><p id="29f4" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jp iv iw ix jq iz ja jb jr jd je jf jg hb bi translated">2-使用JUnit和测试报告测试应用程序</p><p id="a91f" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jp iv iw ix jq iz ja jb jr jd je jf jg hb bi translated">3-使用Kankio executor构建并推送docker映像</p><p id="e53f" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jp iv iw ix jq iz ja jb jr jd je jf jg hb bi translated">4-从git库克隆舵图，并使用一种脚本语言编辑它，我将使用python和YAML管道</p><p id="f7d8" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jp iv iw ix jq iz ja jb jr jd je jf jg hb bi translated">5-使用Rancher CLI和API更新目录和升级应用程序</p><blockquote class="if ig ih"><p id="1f54" class="ii ij ik il b im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg hb bi translated"><em class="hi"> Rancher是一个开源软件，它结合了组织在生产中采用和运行容器所需的一切。Rancher构建于Kubernetes之上，使DevOps团队能够轻松测试、部署和管理他们的应用程序。</em></p></blockquote><p id="06b9" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jp iv iw ix jq iz ja jb jr jd je jf jg hb bi translated"><strong class="il hj"> GitLab用YAML风格写流水线</strong></p><ul class=""><li id="38ab" class="jt ju hi il b im in iq ir jp jv jq jw jr jx jg jy jz ka kb bi translated"><strong class="il hj">首先，我们需要定义流水线阶段</strong></li></ul><pre class="ji jj jk jl fd kc kd ke kf aw kg bi"><span id="b249" class="kh ki hi kd b fi kj kk l kl km">stages:<br/>- build<br/>- test<br/>- docker-build<br/>- bump-helm-chart-version<br/>- deployment</span></pre><ul class=""><li id="f35e" class="jt ju hi il b im in iq ir jp jv jq jw jr jx jg jy jz ka kb bi translated"><strong class="il hj">对于构建，我将使用节点映像来构建nodejs应用程序，您可以使用与您的应用程序相关的任何映像，例如。net core，java，Ruby等。</strong></li></ul><pre class="ji jj jk jl fd kc kd ke kf aw kg bi"><span id="ce1d" class="kh ki hi kd b fi kj kk l kl km">build:<br/>stage: build<br/>image: node<br/>script:<br/>- echo “Start building App”<br/>- npm install<br/>- npm build<br/>- echo “Build successfully!”<br/>artifacts:<br/>expire_in: 1 hour<br/>paths:<br/>- build/dist<br/>- node_modules/</span></pre><p id="4b2a" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jp iv iw ix jq iz ja jb jr jd je jf jg hb bi translated">在构建阶段的工件中，我们将期望构建路径和节点模块</p><ul class=""><li id="881b" class="jt ju hi il b im in iq ir jp jv jq jw jr jx jg jy jz ka kb bi translated"><strong class="il hj">在测试阶段，我也将使用节点映像</strong></li></ul><pre class="ji jj jk jl fd kc kd ke kf aw kg bi"><span id="c895" class="kh ki hi kd b fi kj kk l kl km">stage: test<br/>image: node<br/>script:<br/>- echo “Testing App”<br/>- npm run test<br/>- echo “Test successfully!”<br/>artifacts:<br/>expire_in: 1 hour<br/>paths:<br/>- test-reports/jest-junit.xml<br/>reports:<br/>junit:<br/>- test-reports/jest-junit.xml</span></pre><p id="0bce" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jp iv iw ix jq iz ja jb jr jd je jf jg hb bi translated">作为测试阶段的产物，我将Junit验证放在测试报告文件中。</p><ul class=""><li id="3f5a" class="jt ju hi il b im in iq ir jp jv jq jw jr jx jg jy jz ka kb bi translated"><strong class="il hj">对于构建和推送docker映像，我将使用Kankio映像</strong></li></ul><pre class="ji jj jk jl fd kc kd ke kf aw kg bi"><span id="91a9" class="kh ki hi kd b fi kj kk l kl km">docker-build:<br/>image: gcr.io/kaniko-project/executor:debug<br/>stage: docker-build<br/>script:<br/>- export VERSION=$(cat package.json | grep version | head -1 | awk -F= “{ print $2 }” | sed ‘s/[version:,\”,]//g’ | tr -d ‘[[:space:]]’)<br/>- echo “app version $VERSION”<br/>- mkdir -p /kaniko/.docker<br/>- echo “{\”auths\”:{\”$CI_REGISTRY\”:{\”username\”:\”$CI_REGISTRY_USER\”,\”password\”:\”$CI_REGISTRY_PASSWORD\”}}}” &gt; /kaniko/.docker/config.json<br/>- /kaniko/executor — context ./ — dockerfile build/dockerfile — insecure — skip-tls-verify — destination $CI_REGISTRY/amlt/test-node-js-app:$VERSION<br/>- echo “Image build and pushed successfully”</span></pre><p id="3c36" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jp iv iw ix jq iz ja jb jr jd je jf jg hb bi translated">首先，我使用Linux grep命令从package.json导出应用程序的版本(您可以使用自己的方式来版本化您的应用程序)。</p><p id="64cc" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jp iv iw ix jq iz ja jb jr jd je jf jg hb bi translated">然后我为Kankio创建了config.json，其中包含docker注册表凭证，我使用了GitLab预定义的ENV。您可以在GitLab中设置某种ENV，以便在管道中使用。从您的git存储库中转到settings并选择CI/CD。</p><p id="e79d" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jp iv iw ix jq iz ja jb jr jd je jf jg hb bi translated">最后，我运行了kaniko构建/推送命令</p><p id="748c" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jp iv iw ix jq iz ja jb jr jd je jf jg hb bi translated"><strong class="il hj">克隆和编辑K8s舵图</strong></p><p id="fdfe" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jp iv iw ix jq iz ja jb jr jd je jf jg hb bi translated">在这个阶段，我将使用一个纯ubuntu映像，并准备以下工具在这个阶段使用</p><p id="e9cd" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jp iv iw ix jq iz ja jb jr jd je jf jg hb bi translated">1- SSH代理连接到helm charts git存储库进行克隆、提交和推送。</p><p id="20ac" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jp iv iw ix jq iz ja jb jr jd je jf jg hb bi translated">2- Python和Python管道编辑舵图</p><p id="0907" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jp iv iw ix jq iz ja jb jr jd je jf jg hb bi translated">3吉特</p><pre class="ji jj jk jl fd kc kd ke kf aw kg bi"><span id="49b0" class="kh ki hi kd b fi kj kk l kl km">bump-helm-chart-version:<br/>stage: bump-helm-chart-version<br/>image: ubuntu:18.04<br/>before_script:<br/>- export VERSION=$(cat package.json | grep version | head -1 | awk -F= “{ print $2 }” | sed ‘s/[version:,\”,]//g’ | tr -d ‘[[:space:]]’)<br/>- apt-get update -y &amp;&amp; apt-get install openssh-client -y<br/>- apt install git -y<br/>- apt-get install -y python<br/>- apt-get install python-pip -y<br/>- python -m pip install pyyaml<br/>- eval $(ssh-agent -s)<br/>- echo “$GIT_SSH_PRIVATE_KEY” | tr -d ‘\r’ | ssh-add -<br/>- mkdir -p ~/.ssh<br/>- chmod 700 ~/.ssh<br/>- ssh-keyscan $GIT_HOST &gt;&gt; ~/.ssh/known_hosts<br/>- chmod 644 ~/.ssh/known_hosts<br/>- git config — global user.name “${GIT_USER_NAME}”<br/>- git config — global user.email “${GIT_USER_EMAIL}”</span><span id="b63b" class="kh ki hi kd b fi kn kk l kl km">script:<br/>- ssh “git@$GIT_HOST”<br/>- git clone $CI_CHART_REPOSITORY<br/>- cd $HELM_CHART_ROOT_FOLDER<br/>- |<br/>if [ -d “$HELM_CHART_FOLDER_NAME-$VERSION” ]; then<br/>echo “Skip version exists”<br/>else<br/>cp -a -r $HELM_CHART_FOLDER_NAME “$HELM_CHART_FOLDER_NAME-$VERSION”<br/>cd “$HELM_CHART_FOLDER_NAME-$VERSION”<br/>python ../../update-yaml.py<br/>cd ../<br/>git add . &amp;&amp; git commit -m “CI-CD bump version $VERSION” &amp;&amp; git push<br/>fi<br/>only:<br/>- branches</span></pre><p id="a6f2" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jp iv iw ix jq iz ja jb jr jd je jf jg hb bi translated">在预脚本工作中，我准备了我们的映像并设置了所需的工具，并让git知道用户名和电子邮件，以避免在克隆或推送期间询问。</p><p id="a8cc" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jp iv iw ix jq iz ja jb jr jd je jf jg hb bi translated">在脚本中，我首先使用ssh-agent连接到git主机，然后克隆了helm charts。</p><p id="236f" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jp iv iw ix jq iz ja jb jr jd je jf jg hb bi translated">为了降级和升级的目的，我从原始版本中复制了一份进行编辑，以保持Rancher中的版本控制。</p><p id="ee1c" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jp iv iw ix jq iz ja jb jr jd je jf jg hb bi translated">我编写了一个简单的python脚本来编辑YAML文件的值，如docker图像标签、图表版本和应用程序版本</p><pre class="ji jj jk jl fd kc kd ke kf aw kg bi"><span id="798e" class="kh ki hi kd b fi kj kk l kl km"><em class="ik">import</em> yaml<br/><em class="ik">import</em> os<br/>f=open(“values.yaml”)<br/>y=yaml.safe_load(f)<br/>y[“image”][“tag”] = os.environ[“VERSION”]<br/><em class="ik">with</em> open(“values.yaml”, “w”) <em class="ik">as</em> f:<br/>yaml.dump(y, f)<br/>f=open(“Chart.yaml”)<br/>y=yaml.safe_load(f)<br/>y[“version”]= os.environ[“VERSION”]<br/>y[“appVersion”]= os.environ[“VERSION”]<br/><em class="ik">with</em> open(“Chart.yaml”, “w”) <em class="ik">as</em> f:<br/>yaml.dump(y, f)</span></pre><p id="22d3" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jp iv iw ix jq iz ja jb jr jd je jf jg hb bi translated">最后，我将修改提交并推送到git存储库。</p><p id="2ed7" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jp iv iw ix jq iz ja jb jr jd je jf jg hb bi translated"><strong class="il hj">最后一个阶段，我们需要使用Rancher API升级K8s中的app</strong></p><p id="5833" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jp iv iw ix jq iz ja jb jr jd je jf jg hb bi translated">在这个阶段，我使用了带有Rancher CLI的Linux映像</p><blockquote class="if ig ih"><p id="4146" class="ii ij ik il b im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg hb bi translated">您也可以使用直接HTTP调用Rancher API</p></blockquote><pre class="ji jj jk jl fd kc kd ke kf aw kg bi"><span id="2bc9" class="kh ki hi kd b fi kj kk l kl km">deployment:<br/>image: ubuntu:18.04<br/>stage: deployment<br/>before_script:<br/>- echo “Configure machine”<br/>- export VERSION=$(cat package.json | grep version | head -1 | awk -F= “{ print $2 }” | sed ‘s/[version:,\”,]//g’ | tr -d ‘[[:space:]]’)<br/>- apt-get update<br/>- apt install curl -y<br/>- curl -k $RANCHER_CLI_URL | tar xz<br/>script:<br/>- echo “Start deployment”<br/>- cd $RANCHER_CLI_FOLDER_NAME<br/>- ls -t<br/>- ./rancher login $RANCHER_URL/v3 — token $RANCHER_API_TOKEN — skip-verify — context $RANCHER_CONTEXT<br/>- |<br/>curl -k — location — request POST “$REFRESH_CATELOG_URL” — header “Authorization: Bearer $RANCHER_API_TOKEN” &amp;&amp; sleep 20<br/>- ./rancher app upgrade $RANCHER_APP_NAME $VERSION<br/>- echo “The App successfully upgraded”</span></pre><p id="7296" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jp iv iw ix jq iz ja jb jr jd je jf jg hb bi translated">首先，我通过从GitLab ENV中存储的URL下载rancher CLI来准备图像，以便于更改。</p><ul class=""><li id="d7bc" class="jt ju hi il b im in iq ir jp jv jq jw jr jx jg jy jz ka kb bi translated">我使用存储在env中的牧场主访问令牌向牧场主api进行了身份验证</li><li id="5297" class="jt ju hi il b im ko iq kp jp kq jq kr jr ks jg jy jz ka kb bi translated">在更新目录步骤中，我使用直接HTTP调用作为解决方法，因为CLI不读取/刷新项目范围目录</li><li id="f5da" class="jt ju hi il b im ko iq kp jp kq jq kr jr ks jg jy jz ka kb bi translated">最后，我使用package.json中的应用程序版本，使用rancher升级K8s中的应用程序(请记住，您可以使用您的版本控制，如git标记等)</li></ul><p id="2faf" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jp iv iw ix jq iz ja jb jr jd je jf jg hb bi translated">现在，您的应用程序已经升级，工作负载也用新的docker映像进行了更新，您节省了时间。</p><p id="ebdb" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jp iv iw ix jq iz ja jb jr jd je jf jg hb bi translated">最后，我希望我为您提供了解决部署问题的思路</p><p id="e078" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jp iv iw ix jq iz ja jb jr jd je jf jg hb bi translated">如果你用的是Jenkins而不是GitLab，我建议你看看我的文章</p><div class="kt ku ez fb kv kw"><a href="https://regoo707.medium.com/build-and-deploy-your-app-in-rancher-using-jenkins-pipeline-cc1bb02cfcc6" rel="noopener follow" target="_blank"><div class="kx ab dw"><div class="ky ab kz cl cj la"><h2 class="bd hj fi z dy lb ea eb lc ed ef hh bi translated">使用Jenkins pipeline在Rancher中构建和部署您的应用</h2><div class="ld l"><h3 class="bd b fi z dy lb ea eb lc ed ef dx translated">在这篇文章中，我将解释如何编写Jenkins pipeline来自动化构建代码的过程。</h3></div><div class="le l"><p class="bd b fp z dy lb ea eb lc ed ef dx translated">regoo707.medium.com</p></div></div><div class="lf l"><div class="lg l lh li lj lf lk jn kw"/></div></div></a></div></div></div>    
</body>
</html>