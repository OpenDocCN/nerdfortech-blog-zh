<html>
<head>
<title>Your First Golang REST API Client</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">您的第一个Golang REST API客户端</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/your-first-golang-rest-api-client-287c8dc0961?source=collection_archive---------0-----------------------#2021-10-13">https://medium.com/nerd-for-tech/your-first-golang-rest-api-client-287c8dc0961?source=collection_archive---------0-----------------------#2021-10-13</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/40b8eb37d4203918abdfce82dd767c8b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zkYmeFbWLxtLO6mHjj3kYg.png"/></div></div></figure><p id="aa53" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在本教程中，我们将帮助您设置您的环境，编写一个程序从REST API请求数据，解析数据，并将其输出到控制台。如果你已经安装了Golang，那么你可以跳过本教程的第一部分，直接跳到编码部分。</p><p id="20d4" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">本教程涵盖了获取RESTful API的实时外汇数据，但也可以适用于任何提供JSON数据的API。</p><p id="8c58" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">关于WebSocket实现，请阅读<a class="ae jo" rel="noopener" href="/nerd-for-tech/your-first-golang-websocket-fx-data-fc1eb7db35f0">你的第一个Golang Websocket: FX数据</a></p><p id="e559" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">首先，下载并安装Golang</p><p id="0536" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">首先，从https://golang.org/doc/install<a class="ae jo" href="https://golang.org/doc/install" rel="noopener ugc nofollow" target="_blank">下载并安装Golang，一旦你运行了GoLang，你可以打开一个命令窗口，输入下面的命令，你会得到版本输出。</a></p><pre class="jp jq jr js fd jt ju jv jw aw jx bi"><span id="9285" class="jy jz hi ju b fi ka kb l kc kd">go -version</span><span id="221d" class="jy jz hi ju b fi ke kb l kc kd">go version go1.17.1 windows/amd64</span></pre><p id="e3d4" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">获取您的API密钥</p><p id="3f7e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这个程序你需要的最后一样东西是你的TraderMade API密匙，如果你没有，你可以<a class="ae jo" href="https://marketdata.tradermade.com/signup" rel="noopener ugc nofollow" target="_blank">免费注册</a>，然后你可以从你的<a class="ae jo" href="https://marketdata.tradermade.com/myAccount" rel="noopener ugc nofollow" target="_blank">仪表盘</a>上复制它。</p><p id="7324" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">好了，我们写点代码吧。</p><p id="78e8" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">首先，我们需要添加一些包名，我将使用“main ”,然后我们将导入一些我们将要使用的包，encoding/json将帮助解析json，fmt将帮助打印语句，io/ioutil将允许程序基本的读写命令，log这用于将消息记录到控制台，以便我们可以看到程序正在做什么，net/http这将允许我们对REST服务进行get调用。</p><pre class="jp jq jr js fd jt ju jv jw aw jx bi"><span id="54ff" class="jy jz hi ju b fi ka kb l kc kd">package main</span><span id="d456" class="jy jz hi ju b fi ke kb l kc kd">  import (</span><span id="2402" class="jy jz hi ju b fi ke kb l kc kd">    "encoding/json"<br/>    "fmt"<br/>    "io/ioutil"<br/>    "log"<br/>    "net/http"</span><span id="d7f6" class="jy jz hi ju b fi ke kb l kc kd">  )</span></pre><p id="be78" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">然后我们添加主函数。这将是程序的入口点，在这个主函数中，我们将首先定义货币参数、api_key参数和URL。下面的api_key有一个字符串“your_api_key ”,您应该在其中插入您的api_key。</p><pre class="jp jq jr js fd jt ju jv jw aw jx bi"><span id="8684" class="jy jz hi ju b fi ka kb l kc kd">func main(){</span><span id="95d9" class="jy jz hi ju b fi ke kb l kc kd">    currencies := "EURUSD,GBPUSD"</span><span id="3469" class="jy jz hi ju b fi ke kb l kc kd">    api_key := "your_api_key"</span><span id="9e83" class="jy jz hi ju b fi ke kb l kc kd">    url := "https://marketdata.tradermade.com/api/v1/live?currency=" + currencies + "&amp;api_key=" + api_key</span><span id="1f72" class="jy jz hi ju b fi ke kb l kc kd">  }</span></pre><p id="a336" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在我们要添加一个http。使用我们在上一步中定义的url获取请求。我们还将添加一些错误捕捉代码，这些代码将检查在我们进行Get调用时设置的getErr变量，如果该变量为空，我们将继续，否则我们将记录一个错误。</p><pre class="jp jq jr js fd jt ju jv jw aw jx bi"><span id="d3d4" class="jy jz hi ju b fi ka kb l kc kd">resp, getErr := http.Get(url)<br/>  if getErr != nil {<br/>        log.Fatal(getErr)<br/>  }</span></pre><p id="8076" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">接下来，我们检查了从Get调用中收到的一些数据，我们将使用ioutil检索请求体。ReadAll函数。我们再次检查res.Body中的错误。</p><pre class="jp jq jr js fd jt ju jv jw aw jx bi"><span id="6534" class="jy jz hi ju b fi ka kb l kc kd">body, readErr := ioutil.ReadAll(res.Body)<br/>  if readErr != nil {<br/>      log.Fatal(readErr)<br/>    }</span></pre><p id="6c60" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在，我们需要解析JSON主体，但在此之前，我们需要理解它是由什么组成的。为此，只需打印我们在main函数中收到的主体字符串。</p><pre class="jp jq jr js fd jt ju jv jw aw jx bi"><span id="cb3f" class="jy jz hi ju b fi ka kb l kc kd">func main(){<br/>    currencies := "EURUSD,GBPUSD"<br/>    api_key := "your_api_key"<br/>    url := "https://marketdata.tradermade.com/api/v1/live?currency=" + currencies + "&amp;api_key=" + api_key</span><span id="d94e" class="jy jz hi ju b fi ke kb l kc kd">    resp, getErr := http.Get(url)<br/>    if getErr != nil {<br/>      log.Fatal(getErr)<br/>    }</span><span id="3c0c" class="jy jz hi ju b fi ke kb l kc kd">    body, readErr := ioutil.ReadAll(res.Body)<br/>    if readErr != nil {<br/>      log.Fatal(readErr)<br/>    }</span><span id="ca77" class="jy jz hi ju b fi ke kb l kc kd">    fmt.Println(string(body)) </span><span id="6095" class="jy jz hi ju b fi ke kb l kc kd">   }</span></pre><p id="5b43" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">并在命令终端中使用命令go run“main.go”运行该文件(我们已经将文件保存为main . go)。</p><pre class="jp jq jr js fd jt ju jv jw aw jx bi"><span id="f592" class="jy jz hi ju b fi ka kb l kc kd">{<br/>   "endpoint": "live",<br/>   "quotes": [<br/>    {<br/>     "ask": 1.15537,<br/>     "base_currency": "EUR",<br/>     "bid": 1.15536,<br/>     "mid": 1.15536,<br/>     "quote_currency": "USD"<br/>    },<br/>    {<br/>     "ask": 1.3621,<br/>     "base_currency": "GBP",<br/>     "bid": 1.36208,<br/>     "mid": 1.36209,<br/>     "quote_currency": "USD"<br/>    }<br/>   ],<br/>   "requested_time": "Tue, 12 Oct 2021 11:34:26 GMT",<br/>   "timestamp": 1634038467<br/>}</span></pre><p id="3477" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">你现在可以在上面看到我们收到的JSON正文。然而，这只是一个字符串，如果您正在处理对象，它并不十分有用。由于Golang是一种强类型语言，我们需要做一些工作才能解析收到的数据。我们首先必须定义我们想要写入响应体的数据结构。正如你所看到的，下面的数据结构与我们上面打印的数据相匹配</p><pre class="jp jq jr js fd jt ju jv jw aw jx bi"><span id="c6f5" class="jy jz hi ju b fi ka kb l kc kd">type data struct {<br/>      Endpoint       string                   `json:'endpoint'`<br/>      Quotes         []map[string]interface{} `json:'quotes'`<br/>      Requested_time string                   `json:'requested_time'`<br/>      Timestamp      int32                    `json:'timestamp'`<br/>  }</span></pre><p id="3fbf" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">尽管大部分都很简单，但理解数据结构中的引号是如何定义的还是很有帮助的。</p><p id="e528" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们将引号定义为[]map[string]interface{}，用简单的语言来说，这意味着一个映射数组，其中键是字符串类型，值是未知类型。map只是一个带有键和值的JSON对象(类似于Python中的字典)，但是在Golang中我们必须定义它。接口是一个略有不同的概念，但通常在值类型未知时用于解析JSON。</p><p id="d492" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在我们已经定义了数据结构，这是很重要的一点，我们只需要将它解组到内存中的一个对象中。为此，我们将为数据结构分配一个名为data_obj的变量，然后对接收到的数据进行解组。</p><pre class="jp jq jr js fd jt ju jv jw aw jx bi"><span id="4b2f" class="jy jz hi ju b fi ka kb l kc kd">data_obj := data{}</span><span id="9394" class="jy jz hi ju b fi ke kb l kc kd">  jsonErr := json.Unmarshal(body, &amp;data_obj)<br/>  if jsonErr != nil {<br/>     log.Fatal(jsonErr)<br/>  }</span></pre><p id="eb80" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在我们将打印解析后的值，并在需要时使用它们。我们将简单地打印所有的值，并迭代前面定义的引号。</p><pre class="jp jq jr js fd jt ju jv jw aw jx bi"><span id="803c" class="jy jz hi ju b fi ka kb l kc kd">fmt.Println("endpoint", data_obj.Endpoint, "requested time", data_obj.Requested_time, "timestamp", data_obj.Timestamp)</span><span id="aad8" class="jy jz hi ju b fi ke kb l kc kd">  for key, value := range data_obj.Quotes {</span><span id="3667" class="jy jz hi ju b fi ke kb l kc kd">     fmt.Println(key)</span><span id="1d00" class="jy jz hi ju b fi ke kb l kc kd">     fmt.Println("symbol", value["base_currency"]+value["quote_currency"], "bid", value["bid"], "ask", value["ask"],<br/>"mid", value["mid"])</span><span id="e15f" class="jy jz hi ju b fi ke kb l kc kd">  }</span></pre><p id="c449" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们现在可以看到，我们已经打印了在数据结构中定义的所有值。现在使用这些键和值应该相当简单。</p><pre class="jp jq jr js fd jt ju jv jw aw jx bi"><span id="11a3" class="jy jz hi ju b fi ka kb l kc kd">endpoint live requested time Tue, 12 Oct 2021 17:40:05 GMT timestamp 1634060405<br/>0<br/>symbol EUR USD bid 1.15256 ask 1.15256 mid 1.15256<br/>1<br/>  symbol GBP USD bid 1.35834 ask 1.35836 mid 1.35835</span></pre><p id="7fdc" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">下面是Golang的完整代码，可以复制粘贴以开始获取实时外汇和CFD数据。请记住从您的<a class="ae jo" href="https://marketdata.tradermade.com/myAccount" rel="noopener ugc nofollow" target="_blank">仪表板</a>添加您的API密钥。希望这篇文章有助于在Golang中解析JSON REST API。如果你喜欢我们的工作或对未来的文章有建议，请留下评论并鼓掌，我们希望听到你的声音。</p><pre class="jp jq jr js fd jt ju jv jw aw jx bi"><span id="fced" class="jy jz hi ju b fi ka kb l kc kd">package main</span><span id="00bf" class="jy jz hi ju b fi ke kb l kc kd">import (</span><span id="7dcc" class="jy jz hi ju b fi ke kb l kc kd">    "encoding/json"<br/>    "fmt"<br/>    "io/ioutil"<br/>    "log"<br/>    "net/http"</span><span id="1ef9" class="jy jz hi ju b fi ke kb l kc kd">)</span><span id="776e" class="jy jz hi ju b fi ke kb l kc kd">type data struct {<br/>      Endpoint       string                   `json:'endpoint'`<br/>      Quotes         []map[string]interface{} `json:'quotes'`<br/>      Requested_time string               `json:'requested_time'`<br/>      Timestamp      int32                    `json:'timestamp'`<br/>  }</span><span id="3188" class="jy jz hi ju b fi ke kb l kc kd">func main(){<br/>      currencies := "EURUSD,GBPUSD"<br/>      api_key := "your_api_key"<br/>      url := "https://marketdata.tradermade.com/api/v1/live?currency=" + currencies + "&amp;api_key=" + api_key</span><span id="3c6f" class="jy jz hi ju b fi ke kb l kc kd">      resp, getErr := http.Get(url)<br/>      if getErr != nil {<br/>        log.Fatal(getErr)<br/>      }</span><span id="d6ce" class="jy jz hi ju b fi ke kb l kc kd">      body, readErr := ioutil.ReadAll(res.Body)<br/>      if readErr != nil {<br/>        log.Fatal(readErr)<br/>      }</span><span id="933e" class="jy jz hi ju b fi ke kb l kc kd">      fmt.Println(string(body)) <br/></span><span id="adfa" class="jy jz hi ju b fi ke kb l kc kd">      data_obj := data{}</span><span id="1d39" class="jy jz hi ju b fi ke kb l kc kd">      jsonErr := json.Unmarshal(body, &amp;data_obj)<br/>      if jsonErr != nil {<br/>         log.Fatal(jsonErr)<br/>      }</span><span id="fe8d" class="jy jz hi ju b fi ke kb l kc kd">      fmt.Println("endpoint", data_obj.Endpoint, "requested time", data_obj.Requested_time, "timestamp", data_obj.Timestamp)</span><span id="caff" class="jy jz hi ju b fi ke kb l kc kd">      for key, value := range data_obj.Quotes {</span><span id="ea1e" class="jy jz hi ju b fi ke kb l kc kd">           fmt.Println(key)</span><span id="fabf" class="jy jz hi ju b fi ke kb l kc kd">           fmt.Println("symbol", value["base_currency"]+value["quote_currency"], "bid", value["bid"], "ask", value["ask"],<br/>      "mid", value["mid"])</span><span id="01f6" class="jy jz hi ju b fi ke kb l kc kd">      }</span><span id="5076" class="jy jz hi ju b fi ke kb l kc kd"> }</span></pre></div></div>    
</body>
</html>