<html>
<head>
<title>Using URL Sessions with Swift 5.5 Async/await &amp; Codable</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">通过Swift 5.5异步/等待和可编码使用URL会话</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/using-url-sessions-with-swift-5-5-aysnc-await-codable-8935fe55fbfc?source=collection_archive---------0-----------------------#2021-06-24">https://medium.com/nerd-for-tech/using-url-sessions-with-swift-5-5-aysnc-await-codable-8935fe55fbfc?source=collection_archive---------0-----------------------#2021-06-24</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="ffca" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">创建支持异步/等待的具有URL会话的API管理器。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es jd"><img src="../Images/9ae18414593870751577e44e0b193d55.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zoN0YxCnWdvMs35FaP5tNA.jpeg"/></div></div><figcaption class="jp jq et er es jr js bd b be z dx translated"><a class="ae jt" href="https://unsplash.com/@zanilic?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Zan </a>在<a class="ae jt" href="https://unsplash.com/s/photos/macbook-xcode?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure></div><div class="ab cl ju jv gp jw" role="separator"><span class="jx bw bk jy jz ka"/><span class="jx bw bk jy jz ka"/><span class="jx bw bk jy jz"/></div><div class="hb hc hd he hf"><p id="cfbe" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">众所周知，在WWDC-21中，苹果在Swift中引入了异步(async)功能，允许我们运行复杂的异步代码，就像同步代码一样。也就是说，我们现在不必为我们的结果编写复杂的回调完成处理程序或管理委托，因为async/await会处理它。<br/>到目前为止，它只针对iOS 15及以上版本推出，但我确信苹果肯定也在考虑对较低版本的iOS提供支持。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es kb"><img src="../Images/0fdb481f2a3df744fd18065ff57a4686.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UeGILHZZAslBdZJq0mjy3w.png"/></div></div></figure><p id="e341" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这是来自https://developer.apple.com/videos/play/wwdc2021/10132/ WWDC会议<a class="ae jt" href="https://developer.apple.com/videos/play/wwdc2021/10132/" rel="noopener ugc nofollow" target="_blank">的代码的可视化表示，其中他们使用fetch thumbnail作为例子来区分完成处理程序和aysnc/await之间的语法和复杂性差异。</a></p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es kc"><img src="../Images/f086d3942fab86d7cba36d54023767bc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2MC4AbtuOGNifjmD3mGH4Q.png"/></div></div><figcaption class="jp jq et er es jr js bd b be z dx translated">使用async/await清除代码。</figcaption></figure><p id="509f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在让我们进入主题。</p><p id="7533" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们已经知道有大量的网络库可用，如Alamofire、AFNetworking和Moya，但在这里，我们创建了非常简单的方法，没有任何依赖性来支持我们的URL会话网络调用。</p><p id="7483" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们首先创建我们在创建API管理器时需要的所有必需品。</p><p id="f03e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">创建一个枚举来声明我们将发起的请求的类型。</p><pre class="je jf jg jh fd kd ke kf kg aw kh bi"><span id="b9bb" class="ki kj hi ke b fi kk kl l km kn">enum RequestType: String {</span><span id="cb3e" class="ki kj hi ke b fi ko kl l km kn">case postRequest = "POST"</span><span id="ab40" class="ki kj hi ke b fi ko kl l km kn">case getRequest = "GET"</span><span id="57db" class="ki kj hi ke b fi ko kl l km kn">}</span></pre><p id="c8d4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">创建一个包含所有端点的字符串类型的枚举。</p><pre class="je jf jg jh fd kd ke kf kg aw kh bi"><span id="d82b" class="ki kj hi ke b fi kk kl l km kn">enum Endpoint: String {</span><span id="3bcb" class="ki kj hi ke b fi ko kl l km kn">case getProducts = "get/products"</span><span id="24aa" class="ki kj hi ke b fi ko kl l km kn">}</span></pre><p id="b285" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为我们的Api管理器创建一个具有有用属性的类。</p><pre class="je jf jg jh fd kd ke kf kg aw kh bi"><span id="3265" class="ki kj hi ke b fi kk kl l km kn">class ApiManager {</span><span id="6574" class="ki kj hi ke b fi ko kl l km kn">var baseURL = "https://api.spoonacular.com/"</span><span id="566f" class="ki kj hi ke b fi ko kl l km kn">static var shared = ApiManager()</span><span id="51a0" class="ki kj hi ke b fi ko kl l km kn">private var request: URLRequest?</span><span id="fad1" class="ki kj hi ke b fi ko kl l km kn">private init () {} </span><span id="5573" class="ki kj hi ke b fi ko kl l km kn">}</span></pre><p id="f9a5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在让我们创建所有的助手方法，它们将支持我们的get/post调用，并且可以根据每个人的需要进行定制。</p><p id="7b78" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">对于GET API调用，我们需要将参数作为URL组件发送。我们可以编写一个方法，将所有参数附加到URL中，然后我们可以创建一个URL请求，并将其发送到我们的URLSession。</p><pre class="je jf jg jh fd kd ke kf kg aw kh bi"><span id="21e6" class="ki kj hi ke b fi kk kl l km kn">private func createGetRequestWithURLComponents(url:URL,</span><span id="f2f3" class="ki kj hi ke b fi ko kl l km kn">parameters: [String:Any],</span><span id="83b7" class="ki kj hi ke b fi ko kl l km kn">requestType: RequestType) -&gt; URLRequest? {</span><span id="21a8" class="ki kj hi ke b fi ko kl l km kn">var components = URLComponents(string: url.absoluteString)!</span><span id="a1b6" class="ki kj hi ke b fi ko kl l km kn">components.queryItems = parameters.map { (key, value) in</span><span id="05d7" class="ki kj hi ke b fi ko kl l km kn">URLQueryItem(name: key, value: "\(value)")</span><span id="cf36" class="ki kj hi ke b fi ko kl l km kn">}</span><span id="7bc1" class="ki kj hi ke b fi ko kl l km kn">components.percentEncodedQuery = components.percentEncodedQuery?.replacingOccurrences(of: "+", with: "%2B")</span><span id="7f4f" class="ki kj hi ke b fi ko kl l km kn">request = URLRequest(url: components.url ?? url)</span><span id="24bf" class="ki kj hi ke b fi ko kl l km kn">request?.httpMethod = requestType.rawValue</span><span id="4ae8" class="ki kj hi ke b fi ko kl l km kn">return request</span><span id="aae4" class="ki kj hi ke b fi ko kl l km kn">}</span></pre><p id="5cee" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">对于我们的POST请求，我们需要创建一个URL请求和一个httpBody，我们需要将它们发送到我们的API。</p><pre class="je jf jg jh fd kd ke kf kg aw kh bi"><span id="f725" class="ki kj hi ke b fi kk kl l km kn">private func createPostRequestWithBody(url:URL, parameters: [String:Any], requestType: RequestType) -&gt; URLRequest? {</span><span id="6ee4" class="ki kj hi ke b fi ko kl l km kn">request = URLRequest(url: url)</span><span id="5650" class="ki kj hi ke b fi ko kl l km kn">request?.httpMethod = requestType.rawValue</span><span id="044c" class="ki kj hi ke b fi ko kl l km kn">request?.addValue("application/json", forHTTPHeaderField: "Content-Type")</span><span id="04f1" class="ki kj hi ke b fi ko kl l km kn">request?.addValue("application/json", forHTTPHeaderField: "Accept")</span><span id="aafc" class="ki kj hi ke b fi ko kl l km kn">if let requestBody = getParameterBody(with: parameters) {</span><span id="7c24" class="ki kj hi ke b fi ko kl l km kn">request?.httpBody = requestBody</span><span id="2303" class="ki kj hi ke b fi ko kl l km kn">}</span><span id="18ae" class="ki kj hi ke b fi ko kl l km kn">request?.httpMethod = requestType.rawValue</span><span id="5f0f" class="ki kj hi ke b fi ko kl l km kn">return request</span><span id="d989" class="ki kj hi ke b fi ko kl l km kn">}</span></pre><p id="b538" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这个方法将我们的参数字典转换成我们需要分配给httpBody的数据。</p><pre class="je jf jg jh fd kd ke kf kg aw kh bi"><span id="a3d1" class="ki kj hi ke b fi kk kl l km kn">private func getParameterBody(with parameters: [String:Any]) -&gt; Data? {</span><span id="e46c" class="ki kj hi ke b fi ko kl l km kn">guard let httpBody = try? JSONSerialization.data(withJSONObject: parameters, options: .prettyPrinted) else {</span><span id="db24" class="ki kj hi ke b fi ko kl l km kn">return nil</span><span id="8a7f" class="ki kj hi ke b fi ko kl l km kn">}</span><span id="68b8" class="ki kj hi ke b fi ko kl l km kn">return httpBody</span><span id="c894" class="ki kj hi ke b fi ko kl l km kn">}</span></pre><p id="3b1e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">创建一个方法来区分我们的get/post请求并相应地操作。</p><pre class="je jf jg jh fd kd ke kf kg aw kh bi"><span id="a5f4" class="ki kj hi ke b fi kk kl l km kn">private func createRequest(with url: URL, requestType: RequestType, parameters: [String: Any]) -&gt; URLRequest? {</span><span id="8841" class="ki kj hi ke b fi ko kl l km kn">if requestType == .getRequest {</span><span id="0c1d" class="ki kj hi ke b fi ko kl l km kn">return createGetRequestWithURLComponents(url: url,</span><span id="6271" class="ki kj hi ke b fi ko kl l km kn">parameters: parameters,</span><span id="7e5d" class="ki kj hi ke b fi ko kl l km kn">requestType: requestType)</span><span id="55b6" class="ki kj hi ke b fi ko kl l km kn">}</span><span id="240a" class="ki kj hi ke b fi ko kl l km kn">else {</span><span id="f3f2" class="ki kj hi ke b fi ko kl l km kn">return createPostRequestWithBody(url: url,</span><span id="9e8b" class="ki kj hi ke b fi ko kl l km kn">parameters: parameters,</span><span id="aeab" class="ki kj hi ke b fi ko kl l km kn">requestType: requestType)</span><span id="4f5a" class="ki kj hi ke b fi ko kl l km kn">}</span><span id="af9d" class="ki kj hi ke b fi ko kl l km kn">}</span></pre><p id="ab7b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="kp">现在终于到了有趣的部分！！！:D </em> <strong class="ih hj"> <em class="kp"> <br/> </em>确保你在模型中使用了可编码协议。</strong></p><p id="8bcc" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们将有一个单独的方法，每当我们发出一个API请求时，这个方法都会被调用，这个方法会处理所有的事情。我们使用泛型来直接转换我们的可编码模型，所以我们不必单独创建方法来转换每个特定的模型。</p><pre class="je jf jg jh fd kd ke kf kg aw kh bi"><span id="ae75" class="ki kj hi ke b fi kk kl l km kn">func sendRequest&lt;T:Codable&gt;(model: T.Type,</span><span id="c7f2" class="ki kj hi ke b fi ko kl l km kn">with endpoint: Endpoint,</span><span id="71b4" class="ki kj hi ke b fi ko kl l km kn">requestType: RequestType,</span><span id="d6e4" class="ki kj hi ke b fi ko kl l km kn">parameters: [String:Any]) async -&gt; Result&lt;T, Error&gt;? {</span><span id="9cd8" class="ki kj hi ke b fi ko kl l km kn">if #available(iOS 15.0, *) {</span><span id="108f" class="ki kj hi ke b fi ko kl l km kn">do {</span><span id="bce9" class="ki kj hi ke b fi ko kl l km kn">let url = URL(string: baseURL+endpoint.rawValue)!</span><span id="2743" class="ki kj hi ke b fi ko kl l km kn">guard let urlRequest = createRequest(with: url,</span><span id="1972" class="ki kj hi ke b fi ko kl l km kn">requestType: requestType,</span><span id="42a4" class="ki kj hi ke b fi ko kl l km kn">parameters: parameters) else {</span><span id="f65b" class="ki kj hi ke b fi ko kl l km kn">return nil</span><span id="8ad9" class="ki kj hi ke b fi ko kl l km kn">}</span><span id="a8e4" class="ki kj hi ke b fi ko kl l km kn">let (data, _) = try await URLSession.shared.data(for: urlRequest)</span><span id="a66b" class="ki kj hi ke b fi ko kl l km kn">let parsedData = try JSONDecoder().decode(model.self, from: data)</span><span id="d73f" class="ki kj hi ke b fi ko kl l km kn">return .success(parsedData)</span><span id="6874" class="ki kj hi ke b fi ko kl l km kn">}</span><span id="c168" class="ki kj hi ke b fi ko kl l km kn">catch {</span><span id="a5b0" class="ki kj hi ke b fi ko kl l km kn">return .failure(error)</span><span id="38e9" class="ki kj hi ke b fi ko kl l km kn">}</span><span id="38cb" class="ki kj hi ke b fi ko kl l km kn">}</span><span id="6933" class="ki kj hi ke b fi ko kl l km kn">return nil</span><span id="cc66" class="ki kj hi ke b fi ko kl l km kn">}</span></pre><p id="6cc8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">需要注意的三件事:</strong></p><ol class=""><li id="d63f" class="kq kr hi ih b ii ij im in iq ks iu kt iy ku jc kv kw kx ky bi translated">我们用async标记了我们的方法，因为我们在方法中使用await。一个aysnc函数可以被挂起，并且可以以一种非常独特的方式移交线程的控制权。</li><li id="236b" class="kq kr hi ih b ii kz im la iq lb iu lc iy ld jc kv kw kx ky bi translated">我们使用了await关键字，告诉编译器暂停对函数的控制，并将控制交给系统，而不是将控制交还给我们的函数，由系统决定哪个任务更重要。酷吧？！！</li><li id="6c61" class="kq kr hi ih b ii kz im la iq lb iu lc iy ld jc kv kw kx ky bi translated">为了使用异步函数，我们总是需要将我们调用的函数也标记为异步。</li></ol><p id="6d53" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在将我们的所有代码添加到ApiManager类中以使用它。；)</p><p id="6919" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们用可编码协议创建一个演示模型</p><pre class="je jf jg jh fd kd ke kf kg aw kh bi"><span id="d672" class="ki kj hi ke b fi kk kl l km kn">struct MyModel: Codable {</span><span id="5340" class="ki kj hi ke b fi ko kl l km kn">var id: String?</span><span id="28bb" class="ki kj hi ke b fi ko kl l km kn">var description: String?</span><span id="d566" class="ki kj hi ke b fi ko kl l km kn">}</span></pre><p id="6f14" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在在你的任何一个方法中都这样调用它！</p><pre class="je jf jg jh fd kd ke kf kg aw kh bi"><span id="68f1" class="ki kj hi ke b fi kk kl l km kn">class YourClass {</span><span id="b608" class="ki kj hi ke b fi ko kl l km kn">func sendApiCall() async {</span><span id="5e45" class="ki kj hi ke b fi ko kl l km kn">guard let result = await ApiManager.shared.sendRequest(model: MyModel.self, with: .getProducts, requestType: .postRequest, parameters: ["":""]) else {</span><span id="24b5" class="ki kj hi ke b fi ko kl l km kn">return</span><span id="4a9a" class="ki kj hi ke b fi ko kl l km kn">}</span><span id="a888" class="ki kj hi ke b fi ko kl l km kn">switch result {</span><span id="1e82" class="ki kj hi ke b fi ko kl l km kn">case .success(let mymodel):</span><span id="f6fb" class="ki kj hi ke b fi ko kl l km kn">print(mymodel)</span><span id="d1d5" class="ki kj hi ke b fi ko kl l km kn">case .failure(let error):</span><span id="ca07" class="ki kj hi ke b fi ko kl l km kn">print(error.localizedDescription)</span><span id="48f4" class="ki kj hi ke b fi ko kl l km kn">}</span><span id="765a" class="ki kj hi ke b fi ko kl l km kn">}</span><span id="b9ab" class="ki kj hi ke b fi ko kl l km kn">}</span></pre><p id="7e7f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这就是现在，请让我知道如果你们有任何问题。</p><p id="05f4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">谢谢大家！<br/>快乐编码。</p><p id="574e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><a class="ae jt" rel="noopener" href="/@shirazkhan030">设拉子汗</a></p></div></div>    
</body>
</html>