<html>
<head>
<title>O of N Log N method</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">o/N 对数 N 法</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/o-of-n-log-n-method-7963db98c185?source=collection_archive---------6-----------------------#2022-01-19">https://medium.com/nerd-for-tech/o-of-n-log-n-method-7963db98c185?source=collection_archive---------6-----------------------#2022-01-19</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="d8a9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在我们已经看了 4 个大的 O 符号<a class="ae jd" href="https://jevans4114.medium.com/understanding-big-o-69c02aa59bd2" rel="noopener">这里</a>，让我们花点时间看看 O(n log n)。这也称为合并排序。这里发生的事情是，我们将数组分成两半，然后按顺序将它们缝合在一起:</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div class="er es je"><img src="../Images/4d0391e3a74ff42e9717b0a57fa38493.png" data-original-src="https://miro.medium.com/v2/resize:fit:1236/format:webp/0*zk2w7658YJsk-5dz.png"/></div></figure><p id="ab0c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在我们可以看到合并排序是如何完成的了，让我们开始尝试找出如何编码这个方法。首先，我们将使用上一个示例中使用的同一组数字，首先将所有数字转换为各自的值:</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jn jo di jp bf jq"><div class="er es jm"><img src="../Images/3e554fa8fe7a243b38d470e69377bb97.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RqAfA3lgQhG1FymVeZZ7bQ.png"/></div></div></figure><p id="81d0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们在这里做的是创建一个左列表和一个右列表。然后，这些列表将继续进行排序，直到每个列表中只剩下 1 个值。完成后，我们可以看到每个值是否都显示在我们的控制台上:</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jn jo di jp bf jq"><div class="er es jr"><img src="../Images/b4a162c2f8d57b9249d5aa6d2568f1fe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZYbSCkJ1mkrCH5ufH-PVqQ.png"/></div></div></figure><p id="d7a5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">正如我们所看到的，个体价值正在显现。接下来，我们需要编写一个方法，让我们将这些值按数字顺序排序:</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div class="er es js"><img src="../Images/3aca102b3d98a499aca3db1cfa9c921a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1340/format:webp/1*a65PsmWcfZpL2RVshId1xw.png"/></div></figure><p id="ca64" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们在这里所做的是告诉 unity，根据哪个数字小，我们想把它添加到我们的列表的末尾，并重复直到我们完成排序。为了让我们在控制台中查看流程，我们将在新 while 循环的开头运行 foreach 循环，以告诉我们循环在流程中的位置:</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jn jo di jp bf jq"><div class="er es jr"><img src="../Images/895c680bf0e2f9b3d46985965425d224.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IakwNT1Q_RX7hs75fZdbrg.png"/></div></div></figure><p id="53b1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">从控制台开始我们就可以看到，列表开始整理了。它将我们的值移动到下一个数字顺序，并移动到下一个数字:</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jn jo di jp bf jq"><div class="er es jt"><img src="../Images/35d58553d8edbe822679115b4a472bb6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2LcW9SvIPFvQIqLXWsxtkg.png"/></div></div></figure><p id="da75" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在控制台的最后，我们可以看到我们的列表已经按数字排序，除了最后一个数字，因为一旦最后一个数字被正确放置，我们的循环就不会回到开头:</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div class="er es ju"><img src="../Images/7cf97dc35aecf0400b5a1d4cc32d668e.png" data-original-src="https://miro.medium.com/v2/resize:fit:924/format:webp/1*floeI973wjmSO2trKQJFPg.png"/></div></figure><figure class="jf jg jh ji fd jj er es paragraph-image"><div class="er es jv"><img src="../Images/7eb20587b64e1df90e896b11ecda9261.png" data-original-src="https://miro.medium.com/v2/resize:fit:952/format:webp/1*5V0_K7C8DGvixbITQ0ZRjA.png"/></div></figure><p id="a761" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在我们的检查器中，我们可以看到从未排序列表到排序列表的变化。</p><p id="a2d3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在让我们快速看一下 O(n log n)和 O(n)之间有多大的差别。为此，我们将创建一个包含 1000 个项目的随机列表，并计算对每个列表进行排序需要多少个过程:</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jn jo di jp bf jq"><div class="er es jw"><img src="../Images/c44315863efeef4bf1aeefc4e2434052.png" data-original-src="https://miro.medium.com/v2/resize:fit:680/format:webp/1*LYiD3qYjQXBfaLghSDTblQ.png"/></div></div></figure><p id="dd29" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在我们的两种分类中设置好这个之后，我们只需在每个流程循环中添加一些计数，让我们看看 2:</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jn jo di jp bf jq"><div class="er es jm"><img src="../Images/10381f714191ee2c9d57854f2843c55b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*krS_pvlvw1gsjG_qJxZwbQ.png"/></div></div></figure><p id="3bd3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">正如我们所看到的，只有 1000 个条目的列表，我们的冒泡搜索需要 50 万次计数，而合并排序方法只需要不到 23 万次计数。</p><p id="5500" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们找到了。我们建立了一个 O(n log n)来排序我们的列表。这个方法需要一点代码来构建，但是作为 O(n)的竞争对手，当处理需要排序的数千个不同的值时，它通常是一个更好的方法。否则，我们通常最好使用 O(n)方法。</p></div></div>    
</body>
</html>