<html>
<head>
<title>React native: Creating chat bot assistant with splash screen animation</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">React native:创建带有闪屏动画的聊天机器人助手</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/react-native-creating-chat-bot-assistant-with-splash-screen-animation-9b800b65d842?source=collection_archive---------4-----------------------#2020-12-24">https://medium.com/nerd-for-tech/react-native-creating-chat-bot-assistant-with-splash-screen-animation-9b800b65d842?source=collection_archive---------4-----------------------#2020-12-24</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/bc313da0b8fc594652098ad909169af4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xa_g8QGid2LrVMBivZoCSg.jpeg"/></div></div></figure><p id="97ce" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我在一个react本机应用程序中工作，该应用程序需要实现一个聊天机器人助手来回答客户的询问，该助手能够根据客户选择的答案继续对话。相关的问题和答案集是经过训练的机器学习模型的预测输出。这里，客户选择的答案被发送到后端API，并通过后端调用第三方API来获得机器学习模型的预测输出，这将是向客户显示的下一个问题和答案集。在这篇文章中，我将分享我如何根据机器学习模型预测在react native中构建它。</p><p id="418c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这是完成后的聊天机器人助手的样子:</p><figure class="jp jq jr js fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es jo"><img src="../Images/53ac0fff481a10115ffc3183d6f02e38.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*isvZ5Xx9Y4WfspfjB-o3pw.gif"/></div></div></figure><p id="9d8c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">所以让我们开始吧。</p><h2 id="4655" class="jt ju hi bd jv jw jx jy jz ka kb kc kd jb ke kf kg jf kh ki kj jj kk kl km kn bi translated">定义示例后端Json响应:</h2><p id="af0b" class="pw-post-body-paragraph iq ir hi is b it ko iv iw ix kp iz ja jb kq jd je jf kr jh ji jj ks jl jm jn hb bi translated">这里我为每个数组项定义了一个类型，比如文本、列表。如果答案数组为空，我将数据项的类型定义为文本，如果有答案列表，我将类型定义为列表。这将有助于你创建对话项目的用户界面。如果你需要你可以根据相同的格式添加更多的类型，使功能丰富的输出。</p><figure class="jp jq jr js fd ij"><div class="bz dy l di"><div class="kt ku l"/></div></figure><h2 id="0891" class="jt ju hi bd jv jw jx jy jz ka kb kc kd jb ke kf kg jf kh ki kj jj kk kl km kn bi translated">实施:</h2><p id="4b5f" class="pw-post-body-paragraph iq ir hi is b it ko iv iw ix kp iz ja jb kq jd je jf kr jh ji jj ks jl jm jn hb bi translated">作为我的初始实现，我在聊天机器人视图中调用后端API<em class="kv">组件卸载</em>方法<em class="kv">。</em></p><pre class="jp jq jr js fd kw kx ky kz aw la bi"><span id="158b" class="jt ju hi kx b fi lb lc l ld le">this.props.chatBotInitiate(requestParams, this);</span></pre><p id="2a2b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">然后，我需要将后端响应更新为redux状态。在这里，我将创建另一个聊天临时对象来操作应用程序端的数据，与后端响应格式相同。然后，我在一个<em class="kv"> setTimeout </em>方法内将应用程序端temp对象更新为不同的redux状态，并在其中调用另一个<em class="kv"> setTimeout </em>，以仅更新对应用程序端temp对象的后端响应的欢迎消息。在这里，我的目标是以秒为单位延迟渲染点指示器，然后渲染带有欢迎消息的闪屏。</p><p id="0620" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">下面是<em class="kv"> chatBotInitiate </em>函数<em class="kv">的实现。</em></p><figure class="jp jq jr js fd ij"><div class="bz dy l di"><div class="kt ku l"/></div></figure><p id="9049" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这里我使用redux状态通过<em class="kv"> </em>渲染<em class="kv"> ChatBotMainView.js </em>中的内容。这是它在<em class="kv"> ChatBotMainView.js. </em>中的样子，正如我在上面的第一个<em class="kv"> setTimeout </em>方法中解释的那样，我用空数据数组和空欢迎消息更新redux状态，以呈现<em class="kv"> dotIndicatorView。</em>然后<em class="kv"> </em>在第二个<em class="kv"> setTimeout </em>方法中，我用欢迎消息更新redux状态以呈现闪屏。</p><figure class="jp jq jr js fd ij"><div class="bz dy l di"><div class="kt ku l"/></div></figure><p id="a1ce" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在更新闪屏后的第二个<em class="kv"> setTimeout </em>方法中，接下来我将通过使用另一个<em class="kv"> setTimeout </em>递归更新数据项来将数据列表呈现为平面列表。这里我们需要将欢迎消息更新为空，以呈现转换内容。然后，我递归地将数组项更新为redux状态。下面是我实现的递归函数。</p><figure class="jp jq jr js fd ij"><div class="bz dy l di"><div class="kt ku l"/></div></figure><p id="7b03" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">最后，我们需要使用redux state实现对话项的UI。为此，我使用了一个单独的<em class="kv"> chatItemView.js </em>来呈现列表项。这里的列表和文本类型项来自后端响应，该响应更新为应用程序端聊天临时对象。然后，我们需要使用不同的类型将用户选择的答案更新到相同的redux状态，因为UI在问题、答案列表和选择的答案方面是不同的。这里我用类型作为答案。在<em class="kv"> clickAnswer </em>函数中，如果是列表类型的项目，我将调用<em class="kv"> updateChatBotAnswers </em>来更新app端的redux状态。</p><pre class="jp jq jr js fd kw kx ky kz aw la bi"><span id="c6ba" class="jt ju hi kx b fi lb lc l ld le">this.props.updateChatBotAnswers(item, this.props.chat_bot_ui_data, this.props.screen_context);</span></pre><figure class="jp jq jr js fd ij"><div class="bz dy l di"><div class="kt ku l"/></div></figure><p id="9fe9" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">下面是<em class="kv"> updateChatBotAnswers的实现。</em>这里我将用户选择的答案更新到app端redux状态，最后需要调用后端API来获得基于用户选择的答案的响应。</p><figure class="jp jq jr js fd ij"><div class="bz dy l di"><div class="kt ku l"/></div></figure><p id="9da0" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">因此，从上面的聊天机器人的例子，你可以创建一个简单的聊天机器人助手，你可以建立在它的基础上，使你的聊天机器人助手功能丰富和动态。此外，您可以集成语音到文本组件和文本输入，以获得来自客户的查询，使其更加复杂。</p><p id="9898" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">感谢您的阅读！</p></div></div>    
</body>
</html>