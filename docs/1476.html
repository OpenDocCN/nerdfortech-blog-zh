<html>
<head>
<title>Solving 8 puzzle: building the graph</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">解决8个难题:构建图形</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/solving-8-puzzle-with-search-e17c71000780?source=collection_archive---------7-----------------------#2021-03-21">https://medium.com/nerd-for-tech/solving-8-puzzle-with-search-e17c71000780?source=collection_archive---------7-----------------------#2021-03-21</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="4f75" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我开始了我的人工智能之旅，似乎对搜索的研究是这个领域的首要条件。最初的成年问题看起来是一个简单的难题，八个难题。当我还是个孩子的时候，我就接触到了这个难题，40年后当我回来的时候，我又想起了它。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es jd"><img src="../Images/df489aacd3505b16e4ec0b248b026721.png" data-original-src="https://miro.medium.com/v2/resize:fit:450/format:webp/1*vhe_2pM0_lovBNQlS1_G-w.png"/></div><figcaption class="jl jm et er es jn jo bd b be z dx translated">8-拼图猫形象</figcaption></figure><p id="9bd5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我的第一个谜题和左边的猫谜题没有太大的不同。我的玩具不是由15个移动的棋子组成的4x4，而是由8个移动的棋子组成的3x3(哦，它是一列沿着轨道移动的火车)。这个游戏允许你将一个棋子滑动到空白的位置，当你通过再现图像解决问题时游戏结束。原来有更多的变体，其中每个瓷砖都是一个a数字，解决方案是将这些数字按顺序排列。不管瓷砖上是否有图像或显示它们的数值，数值是通过计算解决这个问题的正确方法(至少在我的AI旅程中的这一点上)。</p><p id="6768" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">第一个决定是如何代表董事会。我想保持简单，所以我决定我的棋盘应该用一个1 x 9的<code class="du jp jq jr js b">array</code>来表示，每个元素都是从集合<code class="du jp jq jr js b">{ 1,2,3,4,5,6,7,8, null }</code>中选择的(没有替换)。有9个选择9个排列= 362，880的棋盘，最好用一个图形来表示。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="ju jv di jw bf jx"><div class="er es jt"><img src="../Images/4423ee1c0165e0e2dbb18cd15b1f77bc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Y42cbN4y2aEnYiHBn6IQMA.png"/></div></div><figcaption class="jl jm et er es jn jo bd b be z dx translated">代表四种板状态和六种转换的图形部分</figcaption></figure><p id="47e2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">棋盘通过将瓷砖滑入空位来改变状态。通过利用一个数组来表示棋盘状态，您需要首先确定空的(<code class="du jp jq jr js b">null</code>)点在哪里。</p><p id="8674" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">一旦确定了空单元格，您就可以通过一些计算来确定另一个单元格是否可以滑入该位置:1、取空单元格的索引与其他所有单元格的索引之间的差；2.相距一个单位的单元格可以向左或向右滑动，相距三个单位的单元格可以向上或向下滑动；3.你需要意识到从不同的行滑动一个单元，那不是合法的移动。该代码看起来像:</p><pre class="je jf jg jh fd jy js jz ka aw kb bi"><span id="10eb" class="kc kd hi js b fi ke kf l kg kh">// boardPermutation is an array of all possible premutations<br/>boardPermutations.map(permutation =&gt; {<br/>    const emptyIndex = permutation.findIndex(x =&gt; x == null)<br/>    const allowLeft = emptyIndex % 3 != 2<br/>    const allowRight = emptyIndex % 3 != 0</span><span id="7826" class="kc kd hi js b fi ki kf l kg kh">    const moves = permutation.map((state, index) =&gt; {<br/>        const delta = emptyIndex - index<br/>        return {index, delta}</span><span id="0c03" class="kc kd hi js b fi ki kf l kg kh">    }).filter(node =&gt; {<br/>        return    node.delta == 1 &amp;&amp; allowRight <br/>               || node.delta == -1 &amp;&amp; allowLeft <br/>               || <em class="kj">Math</em>.abs(node.delta) == 3</span><span id="4578" class="kc kd hi js b fi ki kf l kg kh">    }).map(node =&gt; {<br/>        let label = ""<br/>        if (node.delta == 1 &amp;&amp; allowRight) {<br/>            label = "RIGHT"<br/>        } else if(node.delta == -1 &amp;&amp; allowLeft) {<br/>            label = "LEFT"<br/>        } else if(node.delta == 3) {<br/>            label = "DOWN"<br/>        } else if(node.delta == -3) {<br/>            label = "UP"<br/>        }<br/><br/>        const nextPermutation = permutation.slice(0)<br/>        const temp = nextPermutation[emptyIndex]<br/>        nextPermutation[emptyIndex] = nextPermutation[node.index]<br/>        nextPermutation[node.index] = temp</span><span id="c401" class="kc kd hi js b fi ki kf l kg kh">        return nextPermutation<br/>    })<br/>})</span></pre><p id="1308" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为了理解我们将需要添加多少条边，如果任何给定的单元格为空，设想可能的移动次数是有用的:</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es kk"><img src="../Images/a97ecd02607cdc3bfd3bf20ead91bbca.png" data-original-src="https://miro.medium.com/v2/resize:fit:1132/format:webp/1*3_xqVAtplH5qwa8jYppOlg.png"/></div><figcaption class="jl jm et er es jn jo bd b be z dx translated">可能的移动，如果每个单元格都是空白的</figcaption></figure><p id="cb3a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在所有可能的棋盘状态中，平均有2.66步棋。当乘以362，880个棋盘状态时，等于967，680个可能的移动。这些移动中的每一个(如棋盘状态/转换图形所示)都成为我们图形中的一条边。</p><p id="a26d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在定义图表时，我希望可读性高于效率，并喜欢它的流动方式(psuedo):</p><pre class="je jf jg jh fd jy js jz ka aw kb bi"><span id="251e" class="kc kd hi js b fi ke kf l kg kh">const graph = Graph()<br/>graph.addNode( Node("a") )<br/>graph.addNode( Node("b") )<br/>graph.from("a").to("b").withEdge("a-to-b", <em class="kj">Edge.UNIDIRECTIOAL</em>)</span></pre><p id="eaf7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在8 Puzzle中，节点既有id又有值，我们用这两个组件实例化了<code class="du jp jq jr js b">Node("1,,6,2,3,5,4,7,8", [1,null,6,2,3,5,4,7,8])</code>；边具有与之相关的成本(1个单位),并且也是用该值构建的。</p><p id="dcd8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为了生成完整的图形，我们需要生成棋盘的所有362，880种排列。此函数从堆栈(<em class="kj">https://stack overflow . com/questions/27177026/derive-every-possible-combination-of-elements-in-array):</em></p><pre class="je jf jg jh fd jy js jz ka aw kb bi"><span id="50a7" class="kc kd hi js b fi ke kf l kg kh">function <em class="kj">makePermutations</em>(length, data) {<br/>    <em class="kj"><br/>    </em>const current = new <em class="kj">Array</em>(length)<br/>        , used = new <em class="kj">Array</em>(length)<br/>        , seen = {}, result = [];<br/><br/>    function <em class="kj">permute</em>(pos) {<br/>        if (pos == length) {                   <em class="kj"><br/>            </em>if (!seen[current]) {<em class="kj"><br/>                </em>seen[current] = true;       <em class="kj"><br/>                </em>result.push(current.slice());<br/>            }<br/>            return;<br/>        }<br/>        for (var i = 0; i &lt; data.length; ++i) {<br/>            if (!used[i]) {<em class="kj"><br/>                </em>used[i] = true;<em class="kj"><br/>                </em>current[pos] = data[i];<br/>                <em class="kj">permute</em>(pos+1);<br/>                used[i] = false;                <em class="kj"><br/>            </em>}<br/>        }<br/>    }<br/>    <em class="kj">permute</em>(0);<br/>    return result;<br/>}</span></pre><p id="3edb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">并且能够通过以下方式创建所有可能的棋盘排列:</p><pre class="je jf jg jh fd jy js jz ka aw kb bi"><span id="ea50" class="kc kd hi js b fi ke kf l kg kh">const boardPermutations = <em class="kj">makePermutations</em>(9, [1,2,3,4,5,6,7,8,null])</span></pre><p id="5ec2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我选择编写一个脚本来构建图表，并独立地将它保存到一个文件中，这样我就可以将它“要求”到内存中。我认为每次我想运行模型时，这将比动态生成节省时间。事实证明，相对于搜索时间来说，加载是微不足道的——但我还是要提供这样的好处:</p><pre class="je jf jg jh fd jy js jz ka aw kb bi"><span id="b6b7" class="kc kd hi js b fi ke kf l kg kh">const fs = require('fs')<br/>const {<em class="kj">makePermutations</em>} = require("../../../utility/array-permutations")<br/><br/><br/><em class="kj">// make all combinations of where the elements can be<br/></em>const boardPermutations = <em class="kj">makePermutations</em>(9, [1,2,3,4,5,6,7,8,null])<br/>const answer = [null,1,2,3,4,5,6,7,8]<br/><br/>const builder = fs.createWriteStream('./eight-puzzle-graph.js')<br/><em class="kj"><br/><br/><br/></em>builder.write(`const {Graph, Edge, Node} = require("../../../abstract-data-types/graph.js")\n`)<br/>builder.write(`const graph = Graph()\n`)<br/><br/><em class="kj">// add each permutation of the board to the graph<br/></em>boardPermutations.map(permutation =&gt; {<br/>    builder.write(<br/>       `graph.addNode(Node("${permutation.join(",")}",<br/>       [${permutation}], ${h(permutation, answer)}))\n`)<br/>})<br/><br/><em class="kj">// identify and add edges<br/></em>boardPermutations.map(permutation =&gt; {<br/>    const emptyIndex = permutation.findIndex(x =&gt; x == null)<br/>    const allowLeft = emptyIndex % 3 != 2<br/>    const allowRight = emptyIndex % 3 != 0<br/>    const moves = permutation.map((state, index) =&gt; {<br/>        const delta = emptyIndex - index<br/>        return {index, delta}</span><span id="d65b" class="kc kd hi js b fi ki kf l kg kh">    }).filter(node =&gt; {<br/>        <strong class="js hj">return    </strong>node.delta == 1 &amp;&amp; allowRight <br/>               || node.delta == -1 &amp;&amp; allowLeft <br/>               || <strong class="js hj"><em class="kj">Math</em></strong>.abs(node.delta) == 3</span><span id="7381" class="kc kd hi js b fi ki kf l kg kh">    }).map((node) =&gt; {<br/>        let label = ""<br/>        if (node.delta == 1 &amp;&amp; allowRight) {<br/>            label = "RIGHT"<br/>        } else if(node.delta == -1 &amp;&amp; allowLeft) {<br/>            label = "LEFT"<br/>        } else if(node.delta == 3) {<br/>            label = "DOWN"<br/>        } else if(node.delta == -3) {<br/>            label = "UP"<br/>        }<br/><br/>        label += `(${permutation[node.index]})`<br/><br/>        const nextPermutation = permutation.slice(0)<br/>        const temp = nextPermutation[emptyIndex]<br/>        nextPermutation[emptyIndex] = nextPermutation[node.index]<br/>        nextPermutation[node.index] = temp<br/>                    <br/>       builder.write(<br/>          `graph.from("${permutation.join(",")}").<br/>            to("${nextPermutation.join(",")}").<br/>            withEdge(Edge("${label}", 1, Edge.UNIDIRECTIOAL))\n`)<br/>    })<br/>})<br/><br/>builder.write(`module.exports = graph\n`)<br/>builder.end()</span></pre><p id="9b6d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在我的下一篇<a class="ae kl" href="https://akaphenom.medium.com/solving-8-puzzle-exploring-search-options-2e446e29d21" rel="noopener">文章</a>中，我将介绍我的搜索实现。</p><ul class=""><li id="2292" class="km kn hi ih b ii ij im in iq ko iu kp iy kq jc kr ks kt ku bi translated">「工作实例」:<a class="ae kl" href="https://github.com/tb01923/aima-js/blob/main/search/eight-puzzle/eight-puzzle-graph-generator.js" rel="noopener ugc nofollow" target="_blank">https://github . com/TB 01923/艾玛-js/blob/main/search/eight-puzzle/eight-puzzle-graph-generator . js</a></li></ul><h1 id="5c88" class="kv kd hi bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">关于我</h1><div class="ls lt ez fb lu lv"><a href="https://www.linkedin.com/in/tb02118/" rel="noopener  ugc nofollow" target="_blank"><div class="lw ab dw"><div class="lx ab ly cl cj lz"><h2 class="bd hj fi z dy ma ea eb mb ed ef hh bi translated">Todd Brown——副总裁&amp;创新和敏捷工程高级总监——Liberty…</h2><div class="mc l"><h3 class="bd b fi z dy ma ea eb mb ed ef dx translated">Todd在软件行业有20多年的经验，专注于架构、安全和…</h3></div><div class="md l"><p class="bd b fp z dy ma ea eb mb ed ef dx translated">www.linkedin.com</p></div></div><div class="me l"><div class="mf l mg mh mi me mj jj lv"/></div></div></a></div></div></div>    
</body>
</html>