<html>
<head>
<title>CI/CD for Android using Bitbucket Pipelines and Gradle Play Publisher</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用 Bitbucket 管道和 Gradle Play Publisher 的 Android CI/CD</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/ci-cd-for-android-using-bitbucket-pipelines-and-gradle-play-publisher-f00d6047ecb5?source=collection_archive---------1-----------------------#2021-03-30">https://medium.com/nerd-for-tech/ci-cd-for-android-using-bitbucket-pipelines-and-gradle-play-publisher-f00d6047ecb5?source=collection_archive---------1-----------------------#2021-03-30</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/549ea8814211843636f991e4497d1771.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*kvlk61jHfkDt409H.jpg"/></div></div></figure><h1 id="849f" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">前言:科特林构建文件</h1><p id="518c" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">本文中的所有 gradle 文件都是用 Groovy 编写的。如果您使用 Kotlin 构建文件(build.gradle.kts)，请查看我的示例项目:<a class="ae km" href="https://github.com/1gravity/Android-TichuCounter" rel="noopener ugc nofollow" target="_blank">https://github.com/1gravity/Android-TichuCounter</a>。它使用的是最新版本的 AGP (Android Gradle 插件):7.0.0-beta01。</p><h1 id="96fd" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">动机</h1><p id="89cd" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">构建、测试、部署和发布 Android 应用程序的方法有很多。</p><p id="08ba" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">你可以手动操作<strong class="jq hj"/>。<br/>在 Android Studio 中创建一个签名的 APK 或捆绑包，将其上传到 Google Play，并通过不同的测试途径推广到生产，这并不困难，也不耗时。我做了很多年。我认为自动化节省的时间无法弥补建立工作管道的努力。我错了。自动化不仅节省了时间，还使流程更加可靠，更不容易出错(人为错误),并鼓励更频繁地部署/发布。总的来说，开发周期加快了，不仅仅是 bug 修复，还有特性发布。当功能可以通过简单的 pr/merge 推向客户时，为什么要等到捆绑一个大版本呢？</p><p id="51f4" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">可以用<a class="ae km" href="https://fastlane.tools/" rel="noopener ugc nofollow" target="_blank"> <strong class="jq hj">浪子</strong> </a>。我对我的大多数应用程序都是这样做的。输入<code class="du ks kt ku kv b">fastlane build_deploy</code>并自动构建、签名并发布到 Google Play 非常方便。如果您是团队中唯一的开发人员，这可能已经足够好了。对于团队来说，有一些主要问题:</p><ol class=""><li id="a5a1" class="kw kx hi jq b jr kn jv ko jz ky kd kz kh la kl lb lc ld le bi translated">浪子需要安装在每台构建机器上。如果有多个开发人员或者使用多台计算机进行开发，您需要多次设置和维护它。在我看来，浪子的文档不是很好，尤其是在 Linux 上的设置不是很直接(耗时)。拥有多台构建机器也会影响构建的可重复性，浪子依赖关系(Ruby libs)的差异会导致不同的结果。</li><li id="22dc" class="kw kx hi jq b jr lf jv lg jz lh kd li kh lj kl lb lc ld le bi translated">签名和部署需要签名/上传密钥和 Google Play API 密钥。应该尽可能少的人能接触到那些钥匙。每次有权限使用密钥的员工离开公司时，都可以创建新的密钥(前提是上传密钥用于签署应用程序)，但这肯定不是一个理想的过程。</li><li id="054a" class="kw kx hi jq b jr lf jv lg jz lh kd li kh lj kl lb lc ld le bi translated">我的需求之一是在合并时开始构建过程。浪子不是实现这一目标的工具，除非它与其他工具相结合，引导我们…</li></ol><p id="21ef" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">可以用<a class="ae km" href="https://www.jenkins.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="jq hj">詹金斯</strong> </a>。<br/>詹金斯是一个伟大的工具。它非常灵活，我们成功地使用它(结合 Rundeck)来构建微服务后端并将其部署到 AWS 托管的 Docker/Kubernetes 环境中。我们还有一个专门的 DevOps 团队来维护它。如果您不想托管自己的 CI/CD 基础架构，并且没有专家负责安装和配置，那么 Jenkins 可能不是合适的工具。</p><p id="b0bc" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">您可以使用<strong class="jq hj"> &lt;在此处插入您的 SAAS CI/CD 解决方案&gt;。<br/> </strong>有许多基于云的 CI/CD 解决方案，例如<a class="ae km" href="https://circleci.com/" rel="noopener ugc nofollow" target="_blank"> CircleCI </a>、<a class="ae km" href="https://www.travis-ci.com/" rel="noopener ugc nofollow" target="_blank"> Travis CI </a>或<a class="ae km" href="https://www.jetbrains.com/teamcity/" rel="noopener ugc nofollow" target="_blank"> TeamCity </a>等等。我确信它们都很棒，并且与您首选的 Git 提供商相集成，但这是另一个需要集成的工具(虽然 Bitbucket Pipeline 显然已经紧密集成)，它们似乎是我的需求的大锤，这些需求是:</p><h2 id="c131" class="lk ir hi bd is ll lm ln iw lo lp lq ja jz lr ls je kd lt lu ji kh lv lw jm lx bi translated"><strong class="ak">要求</strong></h2><ul class=""><li id="c7be" class="kw kx hi jq b jr js jv jw jz ly kd lz kh ma kl mb lc ld le bi translated"><strong class="jq hj">合并到特定分支时触发</strong>(在我的例子中是 master)</li><li id="1229" class="kw kx hi jq b jr lf jv lg jz lh kd li kh lj kl mb lc ld le bi translated">运行<strong class="jq hj">单元测试</strong>(我也有 ui 测试，但是它们还不是管道的一部分)</li><li id="fc94" class="kw kx hi jq b jr lf jv lg jz lh kd li kh lj kl mb lc ld le bi translated">如果检测到错误，运行<strong class="jq hj"> lint </strong>并使构建失败</li><li id="499e" class="kw kx hi jq b jr lf jv lg jz lh kd li kh lj kl mb lc ld le bi translated">将应用程序的免费和付费版本捆绑在一起</li><li id="dee8" class="kw kx hi jq b jr lf jv lg jz lh kd li kh lj kl mb lc ld le bi translated"><strong class="jq hj">签署</strong>app</li><li id="0e3f" class="kw kx hi jq b jr lf jv lg jz lh kd li kh lj kl mb lc ld le bi translated">自动增加<strong class="jq hj">内部版本号</strong></li><li id="af8c" class="kw kx hi jq b jr lf jv lg jz lh kd li kh lj kl mb lc ld le bi translated">如果需要，上传应用程序<strong class="jq hj">元数据</strong>(发行说明、描述、屏幕截图)</li><li id="45ae" class="kw kx hi jq b jr lf jv lg jz lh kd li kh lj kl mb lc ld le bi translated"><strong class="jq hj">将</strong>app 部署到<strong class="jq hj">内部测试轨道</strong></li><li id="f60f" class="kw kx hi jq b jr lf jv lg jz lh kd li kh lj kl mb lc ld le bi translated"><strong class="jq hj">手动推广</strong>由 app flavor 从内测轨道到生产轨道(我的情况是免费/付费)</li><li id="d212" class="kw kx hi jq b jr lf jv lg jz lh kd li kh lj kl mb lc ld le bi translated"><strong class="jq hj">秘密</strong>(签名密钥、Google Play API 密钥、密码)不能被访问回购的开发者取回</li></ul><p id="5b41" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">原来<a class="ae km" href="https://bitbucket.org/" rel="noopener ugc nofollow" target="_blank"> Bitbucket </a>和<a class="ae km" href="https://github.com/Triple-T/gradle-play-publisher" rel="noopener ugc nofollow" target="_blank"> Gradle Play Publisher </a>是我实现这一切所需要的工具。让我们看看怎么做。</p><h1 id="57e5" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">概观</h1><p id="8b0f" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">设置管道有四个步骤:</p><ol class=""><li id="6048" class="kw kx hi jq b jr kn jv ko jz ky kd kz kh la kl lb lc ld le bi translated">我们需要通过编程访问 Google Play 来发布和推广应用程序(并管理元数据)-&gt;我们需要一个用于<strong class="jq hj"> Google Play 开发者 API </strong>的 API 密匙。</li><li id="df5c" class="kw kx hi jq b jr lf jv lg jz lh kd li kh lj kl lb lc ld le bi translated">我们需要配置<strong class="jq hj"> Gradle build </strong>来使用从环境变量中读取签名信息的签名配置。</li><li id="f4db" class="kw kx hi jq b jr lf jv lg jz lh kd li kh lj kl lb lc ld le bi translated">我们需要配置<strong class="jq hj"> Gradle Play Publisher </strong>插件来与 Google Play 交互(上传、发布应用和管理元数据)。</li><li id="2192" class="kw kx hi jq b jr lf jv lg jz lh kd li kh lj kl lb lc ld le bi translated">我们需要配置<strong class="jq hj">位桶管道</strong>来将所有的东西联系在一起。管道配置定义触发器(在合并时)、构建步骤(Gradle)、部署步骤(Gradle Play Publisher)并注入环境变量(机密、构建号)。</li></ol><h1 id="95e1" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">Google Play 开发者 API</h1><p id="0ac8" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">官方文档详细解释了所有步骤:<a class="ae km" href="https://developers.google.com/android-publisher/getting_started" rel="noopener ugc nofollow" target="_blank">https://developers . Google . com/Android-publisher/getting _ started</a>。</p><h2 id="6c55" class="lk ir hi bd is ll lm ln iw lo lp lq ja jz lr ls je kd lt lu ji kh lv lw jm lx bi translated"><strong class="ak">TL；TLTR(太长；懒得看):</strong></h2><ul class=""><li id="6355" class="kw kx hi jq b jr js jv jw jz ly kd lz kh ma kl mb lc ld le bi translated">以帐户所有者的身份进入您的<a class="ae km" href="https://play.google.com/console/developers" rel="noopener ugc nofollow" target="_blank"> Google Play 开发者控制台</a>，打开<a class="ae km" href="https://play.google.com/console/api-access" rel="noopener ugc nofollow" target="_blank"> <em class="mc"> API 访问</em> </a>页面:</li></ul><figure class="me mf mg mh fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es md"><img src="../Images/e8dc28fd801599c604442bc5742022ab.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ULinxJPaf-6NE8yatlVbzw.png"/></div></div></figure><ul class=""><li id="f868" class="kw kx hi jq b jr kn jv ko jz ky kd kz kh la kl mb lc ld le bi translated">接受服务条款(如果尚未接受)</li><li id="1b24" class="kw kx hi jq b jr lf jv lg jz lh kd li kh lj kl mb lc ld le bi translated">如果您还没有创建一个新的 Google Cloud 项目，请创建一个新的 Google Cloud 项目(否则请链接一个现有的项目)。</li><li id="5170" class="kw kx hi jq b jr lf jv lg jz lh kd li kh lj kl mb lc ld le bi translated">在<em class="mc">服务账户</em>下，点击<em class="mc">“创建新服务账户”</em>，打开指向谷歌云平台的链接:</li></ul><figure class="me mf mg mh fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mi"><img src="../Images/5ec30be911383d0c6e39a77505d97618.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WZHLaRZY4fzb8x7b5QuDYg.png"/></div></div></figure><figure class="me mf mg mh fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mj"><img src="../Images/714e70ae62512df2a622de1d991f17f2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cLHKT5ZgQY6RRp88wZfZgQ.png"/></div></div></figure><ul class=""><li id="6a0c" class="kw kx hi jq b jr kn jv ko jz ky kd kz kh la kl mb lc ld le bi translated">在谷歌云平台点击<em class="mc">“创建服务账户”</em>:</li></ul><figure class="me mf mg mh fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mk"><img src="../Images/1820ec6a540a391658c809f2f32bf28d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JfQLT5MwDuV8LmkDmP2XWA.png"/></div></div></figure><ul class=""><li id="098f" class="kw kx hi jq b jr kn jv ko jz ky kd kz kh la kl mb lc ld le bi translated">点击<em class="mc">“创建”</em>按钮之前，选择一个有意义的名称和描述:</li></ul><figure class="me mf mg mh fd ij er es paragraph-image"><div class="er es ml"><img src="../Images/1b7821bbd1b58b523e9a3c358a0f29f9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1110/format:webp/1*0TxEcn2YtQPfhUP9Y332Uw.png"/></div></figure><ul class=""><li id="c885" class="kw kx hi jq b jr kn jv ko jz ky kd kz kh la kl mb lc ld le bi translated">账户需要角色<em class="mc">“服务账户用户】</em>:</li></ul><figure class="me mf mg mh fd ij er es paragraph-image"><div class="er es mm"><img src="../Images/0f4ad3f0a90fed8691a9829f1932cb1f.png" data-original-src="https://miro.medium.com/v2/resize:fit:988/format:webp/1*YTIA947mEXAE62-r4LTTqA.png"/></div></figure><ul class=""><li id="419c" class="kw kx hi jq b jr kn jv ko jz ky kd kz kh la kl mb lc ld le bi translated">您不需要授予用户访问新服务帐户的权限，Google Cloud 会自动添加具有正确权限的所需用户(Google Play 服务和您自己的用户)，因此只需点击<em class="mc">“完成】</em>:</li></ul><figure class="me mf mg mh fd ij er es paragraph-image"><div class="er es mn"><img src="../Images/b84555ed2938a69d94602818be447a1b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1380/format:webp/1*ZE9N69VqSxBA7C7poXF2og.png"/></div></figure><ul class=""><li id="88a6" class="kw kx hi jq b jr kn jv ko jz ky kd kz kh la kl mb lc ld le bi translated">接下来，您需要为该帐户创建一个 API 密钥。<br/>打开操作菜单(三个点)，选择<em class="mc">“管理密钥”</em>:</li></ul><figure class="me mf mg mh fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mo"><img src="../Images/7574617cfffc69ce10574e9bee4a80f3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zLnWbs0VWLAcVVVJmYkB9A.png"/></div></div></figure><ul class=""><li id="5410" class="kw kx hi jq b jr kn jv ko jz ky kd kz kh la kl mb lc ld le bi translated">在<em class="mc">“添加密钥”</em>下选择<em class="mc">“创建新密钥”</em>:</li></ul><figure class="me mf mg mh fd ij er es paragraph-image"><div class="er es mp"><img src="../Images/a5bd5161faa4a8f1c7e1bff062ad487a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1028/format:webp/1*FnEbtoRiQbCzJYTRrlw5Bg.png"/></div></figure><ul class=""><li id="8995" class="kw kx hi jq b jr kn jv ko jz ky kd kz kh la kl mb lc ld le bi translated">创建一个 JSON 密钥:</li></ul><figure class="me mf mg mh fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mq"><img src="../Images/597d8fcc5686eb4b559617ec5b22f9c4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1144/format:webp/1*RSvH8P5d73APCs9H4A0BjA.png"/></div></div></figure><ul class=""><li id="9679" class="kw kx hi jq b jr kn jv ko jz ky kd kz kh la kl mb lc ld le bi translated">点击<em class="mc">“创建”</em>按钮后，密钥文件将被下载到您的电脑上。我建议重命名该文件，使其目的更加明显:</li></ul><figure class="me mf mg mh fd ij er es paragraph-image"><div class="er es mr"><img src="../Images/e4521cbcdbd27c47c1f0e8f940657fd7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1184/format:webp/1*MlT7Ar-Y1rxx9s9p0RrblQ.png"/></div></figure><ul class=""><li id="e950" class="kw kx hi jq b jr kn jv ko jz ky kd kz kh la kl mb lc ld le bi translated">现在，您已经在 Google 云平台中完成了，您可以返回到 Google Play 控制台(到 API 访问屏幕)。新创建的账户应该出现在<em class="mc">“服务账户”</em>下(点击<em class="mc">“刷新服务账户”</em>按钮)。点击<em class="mc">“授权访问”</em>:</li></ul><figure class="me mf mg mh fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ms"><img src="../Images/65de7fbefd2543919ce9f6d92b4e75d7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*aJvZNniR8VspVh3Mw1-HoQ.png"/></div></div></figure><ul class=""><li id="d485" class="kw kx hi jq b jr kn jv ko jz ky kd kz kh la kl mb lc ld le bi translated">点击<em class="mc">“添加应用程序”</em>，选择您想要使用此服务帐户管理的所有应用程序:</li></ul><figure class="me mf mg mh fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mt"><img src="../Images/aecc24e3e65a865e6a4892728c1d8500.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CLykgZ0X6TtlPamQER1Ouw.png"/></div></div></figure><ul class=""><li id="a076" class="kw kx hi jq b jr kn jv ko jz ky kd kz kh la kl mb lc ld le bi translated">已经正确设置了帐户权限，因此服务可以管理所有与发布相关的活动(创建发布，包括发布到生产、元数据管理等。).</li><li id="016a" class="kw kx hi jq b jr lf jv lg jz lh kd li kh lj kl mb lc ld le bi translated">点击<em class="mc">“邀请用户”</em>，大功告成。<br/>我们稍后将使用 Gradle Play Publisher 插件来验证 API 密钥设置。</li></ul><h1 id="27b1" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">Gradle Build</h1><p id="8ae0" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">Gradle build 需要配置成包含一个<a class="ae km" href="https://developer.android.com/studio/publish/app-signing" rel="noopener ugc nofollow" target="_blank">签名配置</a>，它从环境变量(或者您的<em class="mc"> ~/中的 gradle.properties 文件)中读取秘密。gradle 文件夹</em>。如果你已经有了，那么你可以跳过这一章。</p><p id="4216" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">假设您在 Google Play 中有一个已发布的应用程序，并且您可以访问密钥库和包括密码在内的签名密钥(或上传密钥)。</p><p id="c1dd" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">对于本地构建，密钥库的位置、密钥库密码、密钥别名和密钥密码将在您的<em class="mc"> ~/中配置。gradle/gradle.properties </em>文件。</p><p id="7fa9" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">如果你没有<em class="mc"> ~/。gradle/gradle.properties </em>文件，请创建一个并添加这四个参数(粗体部分需要进行配置以适应您的设置):</p><pre class="me mf mg mh fd mu kv mv mw aw mx bi"><span id="7f57" class="lk ir hi kv b fi my mz l na nb">KEYSTORE_FILE=/<strong class="kv hj">path to the keystore file</strong>/<strong class="kv hj">playstore.keystore</strong><br/>KEYSTORE_PASSWORD=<strong class="kv hj">keystore password</strong><br/>KEY_ALIAS=<strong class="kv hj">key alias</strong><br/>KEY_PASSWORD=<strong class="kv hj">key password</strong></span></pre><p id="f69e" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">注意:不要使用~作为您的主目录，而是使用绝对路径。~在 shell 上下文中工作，但不能与 Gradle、Gradle Play Publisher 和 Bitbucket Pipeline 一起使用。</p><p id="a642" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">在应用的 gradle.build 文件中创建签名配置:</p><pre class="me mf mg mh fd mu kv mv mw aw mx bi"><span id="4a1f" class="lk ir hi kv b fi my mz l na nb"><strong class="kv hj">signingConfigs {<br/>    release {<br/>        storeFile file(KEYSTORE_FILE)<br/>        storePassword KEYSTORE_PASSWORD<br/>        keyAlias KEY_ALIAS<br/>        keyPassword KEY_PASSWORD<br/>    }<br/>}</strong></span></pre><p id="d55d" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">将签名配置添加到生成类型:</p><pre class="me mf mg mh fd mu kv mv mw aw mx bi"><span id="e29e" class="lk ir hi kv b fi my mz l na nb">buildTypes <strong class="kv hj">{<br/>   </strong>debug <strong class="kv hj">{<br/></strong>        // debug build type configuration ...<br/><strong class="kv hj">   }<br/><br/>   </strong>release <strong class="kv hj">{<br/>        </strong>// release build type configuration ...</span><span id="fd10" class="lk ir hi kv b fi nc mz l na nb">        <strong class="kv hj">signingConfig signingConfigs.release</strong><br/><strong class="kv hj">   }<br/>}</strong></span></pre><p id="8c6a" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">如果签名配置是正确的，那么下面的命令应该运行并在您的<em class="mc">构建/输出/捆绑包</em>文件夹中创建一个或多个 aab 文件</p><pre class="me mf mg mh fd mu kv mv mw aw mx bi"><span id="fb9e" class="lk ir hi kv b fi my mz l na nb">./gradlew bundleRelease</span></pre><h2 id="51a9" class="lk ir hi bd is ll lm ln iw lo lp lq ja jz lr ls je kd lt lu ji kh lv lw jm lx bi translated">内部版本号</h2><p id="5c25" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">其中一个要求是内部版本号/版本代码的自动递增。我们将使用 Bitbucket 的<em class="mc">$</em><a class="ae km" href="https://bitbucket.org/blog/bitbucket-pipelines-can-count-builds-numbered" rel="noopener ugc nofollow" target="_blank"><em class="mc">bit bucket _ BUILD _ NUMBER</em></a><em class="mc"/>来设置一个定义版本代码的环境变量。为了处理这个环境变量，将您的<em class="mc"> build.gradle </em>文件从:</p><pre class="me mf mg mh fd mu kv mv mw aw mx bi"><span id="a600" class="lk ir hi kv b fi my mz l na nb">versionCode <strong class="kv hj">124</strong></span></pre><p id="c269" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">收件人:</p><pre class="me mf mg mh fd mu kv mv mw aw mx bi"><span id="9006" class="lk ir hi kv b fi my mz l na nb">versionCode project.hasProperty('BUILD_NUMBER') ? project['BUILD_NUMBER'].toInteger() : <strong class="kv hj">124</strong></span></pre><p id="54d8" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">最后但同样重要的是，我们需要为<em class="mc">$</em><a class="ae km" href="https://bitbucket.org/blog/bitbucket-pipelines-can-count-builds-numbered" rel="noopener ugc nofollow" target="_blank"><em class="mc">bit bucket _ BUILD _ NUMBER</em></a>设置初始值，因为它需要高于最后使用的版本代码。请按照这篇文章来做:<em class="mc"/><a class="ae km" href="https://support.atlassian.com/bitbucket-cloud/docs/set-a-new-value-for-the-pipelines-build-number/" rel="noopener ugc nofollow" target="_blank">https://support . atlassian . com/bit bucket-cloud/docs/set-a-new-value-for-the-pipelines-build-number/</a></p><h1 id="19cd" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">格雷尔戏剧出版商</h1><p id="fbdb" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">虽然我们现在能够构建应用程序并创建签名捆绑包(或 apk)，但我们仍然需要配置<a class="ae km" href="https://github.com/Triple-T/gradle-play-publisher" rel="noopener ugc nofollow" target="_blank"> Gradle Play Publisher </a>将签名应用程序发布到 Google Play(并管理元数据，如屏幕截图、描述等。).</p><p id="deec" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">我们也可以在这方面使用浪子，但我不建议走那条路(去过那里，做过)。相信我就好；-)</p><p id="abe4" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">设置 Gradle Play Publisher 插件很容易(参见 https://github.com/Triple-T/gradle-play-publisher<a class="ae km" href="https://github.com/Triple-T/gradle-play-publisher" rel="noopener ugc nofollow" target="_blank"/>):</p><ul class=""><li id="5101" class="kw kx hi jq b jr kn jv ko jz ky kd kz kh la kl mb lc ld le bi translated">将类路径添加到项目的<em class="mc"> build.gradle </em>文件中:</li></ul><pre class="me mf mg mh fd mu kv mv mw aw mx bi"><span id="ee54" class="lk ir hi kv b fi my mz l na nb">buildscript {<br/>    repositories {<br/><strong class="kv hj">        maven { url 'https://oss.sonatype.org/content/repositories/snapshots' <br/>        }<br/></strong>    }<br/>    dependencies {<br/><strong class="kv hj">       classpath 'com.github.triplet.gradle:play-publisher:3.4.0-agp7.0'<br/></strong>    }<br/>}</span></pre><ul class=""><li id="c420" class="kw kx hi jq b jr kn jv ko jz ky kd kz kh la kl mb lc ld le bi translated">将插件添加到应用程序的<em class="mc"> build.gradle </em>文件中:</li></ul><pre class="me mf mg mh fd mu kv mv mw aw mx bi"><span id="6b7b" class="lk ir hi kv b fi my mz l na nb">plugins <strong class="kv hj">{<br/>    </strong>id 'com.android.application'<br/>    <strong class="kv hj">id 'com.github.triplet.play' version '3.3.0'<br/></strong>    // other plugins...<br/><strong class="kv hj">}</strong></span></pre><ul class=""><li id="2ae6" class="kw kx hi jq b jr kn jv ko jz ky kd kz kh la kl mb lc ld le bi translated">向应用程序的<em class="mc"> build.gradle </em>文件添加一个配置块(在 android 块之后):</li></ul><pre class="me mf mg mh fd mu kv mv mw aw mx bi"><span id="0df8" class="lk ir hi kv b fi my mz l na nb">android { ... }</span><span id="da98" class="lk ir hi kv b fi nc mz l na nb"><strong class="kv hj">play {<br/>    serviceAccountCredentials = file(GOOGLE_PLAY_API_KEY)<br/>}</strong></span></pre><p id="7cf6" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">您会注意到<em class="mc"> GOOGLE_PLAY_API_KEY </em>参数。它是对我们在为服务帐户设置密钥时得到的 api 密钥文件的引用-&gt;<em class="mc">Google-play-API-key . JSON</em>。该参数需要在<em class="mc"> ~/中定义。gradle/gradle.properties </em>文件(类似于签名配置参数):</p><pre class="me mf mg mh fd mu kv mv mw aw mx bi"><span id="95e5" class="lk ir hi kv b fi my mz l na nb">GOOGLE_PLAY_API_KEY=/<strong class="kv hj">path to the api key file/google-play-api-key.json</strong></span></pre><p id="5f3e" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">如果一切设置正确，以下命令从应用程序的根目录运行时将下载应用程序的元数据:</p><pre class="me mf mg mh fd mu kv mv mw aw mx bi"><span id="dcba" class="lk ir hi kv b fi my mz l na nb">./gradlew bootstrap</span></pre><h1 id="68ab" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">比特桶流水线</h1><p id="cd04" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">要开始使用 Bitbucket 管道并创建您的第一个管道，请阅读这篇精彩的文章:</p><div class="nd ne ez fb nf ng"><a href="https://www.rockandnull.com/android-continuous-integration-bitbucket/" rel="noopener  ugc nofollow" target="_blank"><div class="nh ab dw"><div class="ni ab nj cl cj nk"><h2 class="bd hj fi z dy nl ea eb nm ed ef hh bi translated">在 1 分钟内为 Bitbucket 设置 Android 持续集成(CI)</h2><div class="nn l"><h3 class="bd b fi z dy nl ea eb nm ed ef dx translated">持续集成(CI)是团队成员每次提交代码时自动构建和测试代码的过程。</h3></div><div class="no l"><p class="bd b fp z dy nl ea eb nm ed ef dx translated">www.rockandnull.com</p></div></div><div class="np l"><div class="nq l nr ns nt np nu io ng"/></div></div></a></div><p id="0f45" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">阅读完那篇文章后，你现在应该在你的应用程序的根目录下有一个<strong class="jq hj"><em class="mc">bit bucket-pipelines . yml</em></strong>文件。</p><p id="6fba" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">我们现在想要的是创建这个特定的管道:</p><figure class="me mf mg mh fd ij er es paragraph-image"><div class="er es nv"><img src="../Images/947db375e6504bef4933b2ab3d002762.png" data-original-src="https://miro.medium.com/v2/resize:fit:758/format:webp/1*jrsIbh97X1sQQXfgR7PL2w.png"/></div></figure><p id="5352" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">它由五个步骤组成(每个步骤运行一个单独的 Docker 容器):</p><ol class=""><li id="ab5c" class="kw kx hi jq b jr kn jv ko jz ky kd kz kh la kl lb lc ld le bi translated">创建秘密文件(密钥库和 API 密钥文件)并使其对管道可用</li><li id="ec15" class="kw kx hi jq b jr lf jv lg jz lh kd li kh lj kl lb lc ld le bi translated">运行单元测试</li><li id="4a8c" class="kw kx hi jq b jr lf jv lg jz lh kd li kh lj kl lb lc ld le bi translated">构建应用捆绑包，并将其部署到内部测试轨道</li><li id="1e68" class="kw kx hi jq b jr lf jv lg jz lh kd li kh lj kl lb lc ld le bi translated">将应用程序的免费版本提升到生产轨道(手动步骤)</li><li id="9b7d" class="kw kx hi jq b jr lf jv lg jz lh kd li kh lj kl lb lc ld le bi translated">将应用程序的专业/付费版本提升到生产轨道(手动步骤)</li></ol><h2 id="8c8d" class="lk ir hi bd is ll lm ln iw lo lp lq ja jz lr ls je kd lt lu ji kh lv lw jm lx bi translated">1.创建秘密文件</h2><p id="5b5d" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">签名密钥(keystore + key)和 Google Play API 密钥都不应该添加到 repo 中，否则每个具有 repo 访问权限的开发人员都可以读取它们。</p><p id="e8fa" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">Bitbucket 能够定义存储库变量。默认情况下，它们是加密的，普通用户无法读取，只有脚本可以读取。我们将使用这个特性来定义我们的构建/发布脚本需要的五个参数:</p><ul class=""><li id="4b1c" class="kw kx hi jq b jr kn jv ko jz ky kd kz kh la kl mb lc ld le bi translated"><em class="mc"> KEYSTORE_FILE </em></li><li id="93fc" class="kw kx hi jq b jr lf jv lg jz lh kd li kh lj kl mb lc ld le bi translated"><em class="mc">密钥库 _ 密码</em></li><li id="0345" class="kw kx hi jq b jr lf jv lg jz lh kd li kh lj kl mb lc ld le bi translated"><em class="mc"> KEY_ALIAS </em></li><li id="007e" class="kw kx hi jq b jr lf jv lg jz lh kd li kh lj kl mb lc ld le bi translated"><em class="mc">密钥 _ 密码</em></li><li id="7f40" class="kw kx hi jq b jr lf jv lg jz lh kd li kh lj kl mb lc ld le bi translated"><em class="mc"> GOOGLE_PLAY_API_KEY </em></li></ul><p id="c099" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">很容易为<em class="mc"> KEYSTORE_PASSWORD、KEY_ALIAS </em>和<em class="mc"> KEY_PASSWORD </em>定义三个值，因为它们只是文本值。为此，进入<em class="mc">“储存库设置”</em>，向下滚动至<em class="mc">“储存库变量”</em>。用正确的值输入所有三个变量:</p><figure class="me mf mg mh fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es nw"><img src="../Images/493dc8625da19afefa4db5ebcd32fd7d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8M_1GdaRj8RfWl16rabx2w.png"/></div></div></figure><figure class="me mf mg mh fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es nx"><img src="../Images/d9802faf1d8932f5d94c07c35e1e8d3c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*eQKVbvFhDvoBTBJWZdzLvQ.png"/></div></div></figure><p id="1779" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">为了将<em class="mc"> KEYSTORE_FILE 和 GOOGLE_PLAY_API_KEY </em>存储在存储库变量中，我们用 base64 编码这些文件。构建管道将解码文本并重新创建原始文件。</p><p id="0ebc" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">运行以下命令对这两个文件进行编码:</p><pre class="me mf mg mh fd mu kv mv mw aw mx bi"><span id="bccd" class="lk ir hi kv b fi my mz l na nb">base64 google-play-api-key.json<br/>base64 playstore.keystore</span></pre><p id="9bd3" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">复制 base64 字符串并在 Bitbucket 中创建存储库变量。这些字符串看起来应该有点像这样(尽管要长得多):<em class="mc">ymfzzty 0 ig dvb 2 dszs 1 wbgf 5 lwfwas 1 rzxkuannvbg = =</em></p><figure class="me mf mg mh fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ny"><img src="../Images/e2fe7a5a5ebe3a1aa3b4ec0fd2e94f12.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rMRdGnm6QOjRvqABrbsVRQ.png"/></div></div></figure><figure class="me mf mg mh fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es nz"><img src="../Images/977e9a287e8aff9c27d211eea3a3a765.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8Gk5oJUlwBb1Ix5m5zvvmg.png"/></div></div></figure><p id="c94f" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">我还创建了两个变量<em class="mc"> KEYSTORE_FILE </em>和<em class="mc"> GOOGLE_PLAY_API_KEY </em>来定义用于解码的秘密的文件名:</p><figure class="me mf mg mh fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es oa"><img src="../Images/1ee394c23dac1799df2d27e2fe9f557f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*n98cfRNTIcVWwEDGfS4tcg.png"/></div></div></figure><p id="9f67" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">现在我们准备在<em class="mc">bit bucket-pipelines . yml</em>文件中定义实际管道的第一步。</p><pre class="me mf mg mh fd mu kv mv mw aw mx bi"><span id="d93a" class="lk ir hi kv b fi my mz l na nb">image: androidsdk/android-30<br/><br/>pipelines:<br/>  branches:<br/>    master:<br/>      - step:<br/>          name: Create keystore and API key<br/>          script:<br/>            <em class="mc"># create the keystore file and the google play api key file<br/>            </em>- mkdir keys<br/>            - echo $KEYSTORE_FILE_BASE64 | base64 --decode &gt; keys/$KEYSTORE_FILE<br/>            - echo $GOOGLE_PLAY_API_KEY_BASE64 | base64 --decode &gt; keys/$GOOGLE_PLAY_API_KEY<br/>          artifacts:<br/>            - keys/**</span></pre><ul class=""><li id="a020" class="kw kx hi jq b jr kn jv ko jz ky kd kz kh la kl mb lc ld le bi translated">我们使用<strong class="jq hj"> androidsdk/android-30 </strong>作为 Docker 镜像。该映像拥有构建 API 30 应用程序的所有工具，因此无需“手动”安装构建工具和编写代码来接受许可证。</li><li id="7e2d" class="kw kx hi jq b jr lf jv lg jz lh kd li kh lj kl mb lc ld le bi translated">在我们的例子中，我们希望在提交时构建主分支，因此</li></ul><pre class="me mf mg mh fd mu kv mv mw aw mx bi"><span id="533b" class="lk ir hi kv b fi my mz l na nb">branches:<br/>    master:</span></pre><ul class=""><li id="e57e" class="kw kx hi jq b jr kn jv ko jz ky kd kz kh la kl mb lc ld le bi translated">这就是如何从存储库变量中提取密钥存储文件和 api 密钥文件:</li></ul><p id="463e" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">创建新目录:</p><pre class="me mf mg mh fd mu kv mv mw aw mx bi"><span id="3d1f" class="lk ir hi kv b fi my mz l na nb">mkdir keys</span></pre><p id="72d2" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">解码密钥库文件并将其写入<em class="mc">。/keys/$ KEYSTORE _ FILE</em>(<em class="mc">$ KEYSTORE _ FILE _ BASE64</em>是 BASE64 编码的密钥库文件，<em class="mc"> $KEYSTORE_FILE </em>是要在 Docker 容器中创建的密钥库文件的名称)。</p><pre class="me mf mg mh fd mu kv mv mw aw mx bi"><span id="cffb" class="lk ir hi kv b fi my mz l na nb">echo $KEYSTORE_FILE_BASE64 | base64 --decode &gt; keys/$KEYSTORE_FILE</span></pre><p id="13d0" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">解码 api 密钥文件并写入<em class="mc">。/keys/$ GOOGLE _ PLAY _ API _ KEY</em>(<em class="mc">$</em>GOOGLE _ PLAY _ API _ KEY _ BASE64 是 BASE64 编码的 API 密钥文件，<em class="mc"> $ </em> GOOGLE_PLAY_API_KEY 是要在 Docker 容器中创建的 API 密钥文件的名称)。</p><pre class="me mf mg mh fd mu kv mv mw aw mx bi"><span id="9d86" class="lk ir hi kv b fi my mz l na nb">echo $GOOGLE_PLAY_API_KEY_BASE64 | base64 --decode &gt; keys/$GOOGLE_PLAY_API_KEY</span></pre><p id="edf7" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">artifacts 标签定义了哪些文件被保留，哪些文件可以被后续的管道步骤访问。在这种情况下，我们希望保留两个关键文件:</p><pre class="me mf mg mh fd mu kv mv mw aw mx bi"><span id="3939" class="lk ir hi kv b fi my mz l na nb">artifacts:<br/>            - keys/**</span></pre><h2 id="cca1" class="lk ir hi bd is ll lm ln iw lo lp lq ja jz lr ls je kd lt lu ji kh lv lw jm lx bi translated">2.运行单元测试</h2><p id="c7f6" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">在本地运行时，Gradle 从<em class="mc"> ~/中读取构建参数。gradle/gradle.properties </em>文件。当在构建管道中运行时，我们需要将参数作为环境变量传递，如下所示:</p><pre class="me mf mg mh fd mu kv mv mw aw mx bi"><span id="6b6a" class="lk ir hi kv b fi my mz l na nb">./gradlew -PKEYSTORE_FILE=../keys/$KEYSTORE_FILE<br/>          -PKEYSTORE_PASSWORD=$KEYSTORE_PASSWORD<br/>          -PKEY_ALIAS=$KEY_ALIAS<br/>          -PKEY_PASSWORD=$KEY_PASSWORD<br/>          -PGOOGLE_PLAY_API_KEY=../keys/$GOOGLE_PLAY_API_KEY<br/>          test</span></pre><p id="da60" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated"><em class="mc">密钥存储文件</em>为 Gradle 创建一个名为<em class="mc">密钥存储文件</em>和值为<em class="mc">的参数../keys/$KEYSTORE_FILE </em>，其中$ <em class="mc"> KEYSTORE_FILE </em>引用了我们之前定义的存储库变量(翻译为<em class="mc">../keys/playstore.keystore) </em>。</p><p id="a6c4" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">把所有东西放在一起，我们得到这一步:</p><pre class="me mf mg mh fd mu kv mv mw aw mx bi"><span id="40c8" class="lk ir hi kv b fi my mz l na nb">step:<br/>    name: Run unit tests<br/>    caches:<br/>      - gradle<br/>    script:<br/>      - export GRADLE_OPTS='-XX:+UseG1GC -XX:MaxGCPauseMillis=1000 -Dorg.gradle.jvmargs="-Xmx2048m -XX:MaxPermSize=1024m -XX:ReservedCodeCacheSize=440m -XX:+UseCompressedOops -XX:+HeapDumpOnOutOfMemoryError -Dfile.encoding=UTF-8" -Dorg.gradle.parallel=false -Dorg.gradle.daemon=false -Dorg.gradle.configureondemand=true'<br/>      - "./gradlew -PKEYSTORE_FILE=../keys/$KEYSTORE_FILE<br/>                   -PKEYSTORE_PASSWORD=$KEYSTORE_PASSWORD<br/>                   -PKEY_ALIAS=$KEY_ALIAS<br/>                   -PKEY_PASSWORD=$KEY_PASSWORD<br/>                   -PGOOGLE_PLAY_API_KEY=../keys/$GOOGLE_PLAY_API_KEY<br/>                   test"<br/>    artifacts:<br/>      - app/build/outputs/**<br/>      - app/build/reports/**</span></pre><p id="6b60" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">梯度选项是可选的。最令人感兴趣的是 org.gradle.daemon 选项。它可以防止脚本在运行多个 Gradle 任务时失败(例如，通过执行。/gradlew …干净的测试)。由于某种原因，Gradle 守护进程在第一个任务完成后被终止，第二个任务失败</p><pre class="me mf mg mh fd mu kv mv mw aw mx bi"><span id="ee90" class="lk ir hi kv b fi my mz l na nb">Gradle build daemon disappeared unexpectedly (it may have been killed or may have crashed)</span></pre><p id="f5b6" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">我肯定有更好的解决方案，但目前 org.gradle.daemon 对我来说已经足够好了。</p><h2 id="f4d9" class="lk ir hi bd is ll lm ln iw lo lp lq ja jz lr ls je kd lt lu ji kh lv lw jm lx bi translated">3.构建和部署包</h2><p id="ef1a" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">通过正确配置 Gradle Play Publisher 插件，构建应用程序并将其部署到 Google Play 非常简单。任务<em class="mc"> publishFreeReleaseBundle </em>和<em class="mc"> publishProReleaseBundle </em>(带有免费和专业版的应用程序)将完成所有繁重的工作。流水线步骤是:</p><pre class="me mf mg mh fd mu kv mv mw aw mx bi"><span id="d57c" class="lk ir hi kv b fi my mz l na nb">- step:<br/>    name: Build &amp; deploy<br/>    caches:<br/>      - gradle<br/>    script:<br/><em class="mc">      </em>- export GRADLE_OPTS='-XX:+UseG1GC -XX:MaxGCPauseMillis=1000 -Dorg.gradle.jvmargs="-Xmx2048m -XX:MaxPermSize=1024m -XX:ReservedCodeCacheSize=440m -XX:+UseCompressedOops -XX:+HeapDumpOnOutOfMemoryError -Dfile.encoding=UTF-8" -Dorg.gradle.parallel=false -Dorg.gradle.daemon=false -Dorg.gradle.configureondemand=true'<br/>      - "./gradlew -PKEYSTORE_FILE=../keys/$KEYSTORE_FILE<br/>                   -PKEYSTORE_PASSWORD=$KEYSTORE_PASSWORD<br/>                   -PKEY_ALIAS=$KEY_ALIAS<br/>                   -PKEY_PASSWORD=$KEY_PASSWORD<br/>                   -PGOOGLE_PLAY_API_KEY=../keys/$GOOGLE_PLAY_API_KEY<br/>                   -PBUILD_NUMBER=$BITBUCKET_BUILD_NUMBER<br/>                   clean :app:publishFreeReleaseBundle :app:publishProReleaseBundle"<br/>    artifacts:<br/>      - app/build/outputs/</span></pre><ul class=""><li id="b2b8" class="kw kx hi jq b jr kn jv ko jz ky kd kz kh la kl mb lc ld le bi translated">我们传入<em class="mc">-PBUILD _ NUMBER = $ bit bucket _ BUILD _ NUMBER</em>来设置应用的<em class="mc">版本代码</em></li><li id="7087" class="kw kx hi jq b jr lf jv lg jz lh kd li kh lj kl mb lc ld le bi translated">默认情况下，插件发布到内部测试轨道，使用- <em class="mc">轨道</em>参数发布到不同的轨道(内部、alpha、beta、生产)</li></ul><h2 id="d9e5" class="lk ir hi bd is ll lm ln iw lo lp lq ja jz lr ls je kd lt lu ji kh lv lw jm lx bi translated">4.提升到生产</h2><p id="b7fe" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">最后这些步骤同样简单:</p><pre class="me mf mg mh fd mu kv mv mw aw mx bi"><span id="e1a1" class="lk ir hi kv b fi my mz l na nb">- parallel:<br/>    - step:<br/>        name: Promote free version<br/>        caches:<br/>          - gradle<br/>        trigger: manual<br/>        script:<br/><em class="mc">          </em>- export GRADLE_OPTS='-XX:+UseG1GC -XX:MaxGCPauseMillis=1000 -Dorg.gradle.jvmargs="-Xmx2048m -XX:MaxPermSize=1024m -XX:ReservedCodeCacheSize=440m -XX:+UseCompressedOops -XX:+HeapDumpOnOutOfMemoryError -Dfile.encoding=UTF-8" -Dorg.gradle.parallel=false -Dorg.gradle.daemon=false -Dorg.gradle.configureondemand=true'<br/>          - "./gradlew -PKEYSTORE_FILE=../keys/$KEYSTORE_FILE<br/>                   -PKEYSTORE_PASSWORD=$KEYSTORE_PASSWORD<br/>                   -PKEY_ALIAS=$KEY_ALIAS<br/>                   -PKEY_PASSWORD=$KEY_PASSWORD<br/>                   -PGOOGLE_PLAY_API_KEY=../keys/$GOOGLE_PLAY_API_KEY<br/>                   -PBUILD_NUMBER=$BITBUCKET_BUILD_NUMBER<br/>                        promoteFreeReleaseArtifact --from-track internal --promote-track production --release-status completed"<br/>    - step:<br/>        name: Promote pro version<br/>        caches:<br/>          - gradle<br/>        trigger: manual<br/>        script:<br/><em class="mc">          </em>- export GRADLE_OPTS='-XX:+UseG1GC -XX:MaxGCPauseMillis=1000 -Dorg.gradle.jvmargs="-Xmx2048m -XX:MaxPermSize=1024m -XX:ReservedCodeCacheSize=440m -XX:+UseCompressedOops -XX:+HeapDumpOnOutOfMemoryError -Dfile.encoding=UTF-8" -Dorg.gradle.parallel=false -Dorg.gradle.daemon=false -Dorg.gradle.configureondemand=true'<br/>          - "./gradlew -PKEYSTORE_FILE=../keys/$KEYSTORE_FILE<br/>                   -PKEYSTORE_PASSWORD=$KEYSTORE_PASSWORD<br/>                   -PKEY_ALIAS=$KEY_ALIAS<br/>                   -PKEY_PASSWORD=$KEY_PASSWORD<br/>                   -PGOOGLE_PLAY_API_KEY=../keys/$GOOGLE_PLAY_API_KEY<br/>                   -PBUILD_NUMBER=$BITBUCKET_BUILD_NUMBER<br/>                        promoteProReleaseArtifact --from-track internal --promote-track production --release-status inProgress --user-fraction .5"</span></pre><p id="2a4d" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">这为所有用户将免费版本从内部测试阶段提升到生产阶段:</p><pre class="me mf mg mh fd mu kv mv mw aw mx bi"><span id="c6f4" class="lk ir hi kv b fi my mz l na nb">promoteFreeReleaseArtifact --from-track internal --promote-track production --release-status completed</span></pre><p id="b07a" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">这使得 50%的用户将专业版从内部测试阶段提升到生产阶段(分阶段推广):</p><pre class="me mf mg mh fd mu kv mv mw aw mx bi"><span id="02b3" class="lk ir hi kv b fi my mz l na nb">promoteProReleaseArtifact --from-track internal --promote-track production --release-status inProgress --user-fraction .5</span></pre><p id="6d1b" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">我们定义手动触发</p><pre class="me mf mg mh fd mu kv mv mw aw mx bi"><span id="f6d8" class="lk ir hi kv b fi my mz l na nb">trigger: manual</span></pre><p id="0ba9" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">因此管道需要人工干预来运行这些步骤。如果您希望自动部署到生产跟踪，只需移除手动触发器。我更喜欢在点击发布按钮之前至少做一个快速的冒烟测试。</p><p id="9a04" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">下面是完整的<strong class="jq hj">bit bucket-pipelines . yml</strong>文件供参考:<a class="ae km" href="https://gist.github.com/1gravity/d5a160094e5408fbff8f54c27b6c9e5c" rel="noopener ugc nofollow" target="_blank">https://gist . github . com/1 gravity/d5a 160094 e 5408 fbff 8 f 54 c 27 b 6 c 9 e5c</a>。</p><p id="4e02" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">编码快乐！</p></div></div>    
</body>
</html>