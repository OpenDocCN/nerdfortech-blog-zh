<html>
<head>
<title>Intro to Convolutional Coding — Part II</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">卷积编码简介—第二部分</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/intro-to-convolutional-coding-part-ii-d289c109ff7a?source=collection_archive---------10-----------------------#2021-06-05">https://medium.com/nerd-for-tech/intro-to-convolutional-coding-part-ii-d289c109ff7a?source=collection_archive---------10-----------------------#2021-06-05</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="d54f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这篇文章描述了使用维特比算法的卷积码的解码过程。它延续了我关于这个主题的前一篇文章，这篇文章更全面地介绍了这些代码和编码过程。</p><h1 id="c8d3" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">解码问题</h1><p id="5406" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">给定一系列<em class="kh">接收比特</em>，解码问题可以表述为寻找发射机状态(或符号)的“最佳可能”序列。然而，这个定义是模糊的，因为没有什么是最佳的明确定义。维特比算法找到最有可能<em class="kh">的</em>序列，因此被称为<em class="kh">最大似然</em> (ML)解码器。</p><h2 id="a37b" class="ki jf hi bd jg kj kk kl jk km kn ko jo iq kp kq js iu kr ks jw iy kt ku ka kv bi translated">可能性和汉明距离</h2><p id="8b61" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">最有可能发送的序列与<em class="kh">汉明距离有关。</em>两位序列之间的汉明距离是两个序列的异或之和。例如，C₁=1101001和C₂=1100111的距离是:d(C₁，C₂)=3.然而，对于C₁和C₃=1100001，d(C₁，C₃)=1.因此，如果C₁被接收，C₃更有可能是发送的序列，因为它意味着较少的比特翻转发生。从概念上讲，我们检查所有可能的码字，并根据最小权重来决定找到最有可能发送的序列。也就是说，这个概念(在校正子解码中使用)是有挑战性的，因为卷积码的长度是无限的。</p><h2 id="b86f" class="ki jf hi bd jg kj kk kl jk km kn ko jo iq kp kq js iu kr ks jw iy kt ku ka kv bi translated">沿着格子架的小路</h2><p id="27fa" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">使用维特比算法解决了该问题，该算法使用在<a class="ae jd" href="https://yair-mz.medium.com/into-to-convolutional-coding-part-i-d63decab56a0" rel="noopener">之前的</a>帖子中显示的代码的网格表示。例如，考虑以下编码器:</p><figure class="kx ky kz la fd lb er es paragraph-image"><div role="button" tabindex="0" class="lc ld di le bf lf"><div class="er es kw"><img src="../Images/cbd5cc10b9d98289ec5e78ff3a52c5a8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EovIav4x4TBoC_nLF_Zngg.png"/></div></div><figcaption class="li lj et er es lk ll bd b be z dx translated">码率为<em class="lm"> R=，约束长度为K=2 </em>的卷积编码器</figcaption></figure><p id="919e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">该代码的网格表示如下所示。假设输入序列为101100，沿网格的路径显示为红色。</p><figure class="kx ky kz la fd lb er es paragraph-image"><div role="button" tabindex="0" class="lc ld di le bf lf"><div class="er es ln"><img src="../Images/4b76da0ea7a873ceec47e11744fbe7c3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gSlzlxMymL6bAhkJvxB44w.png"/></div></div><figcaption class="li lj et er es lk ll bd b be z dx translated">代码的网格表示。红色表示沿着格子架的路径。</figcaption></figure><p id="7cfc" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">维特比解码器沿着网格找到最可能的<strong class="ih hj">路径</strong>。给定接收的比特序列，可以遍历网格。图中红色箭头所示的每个转换都告诉我们另一个原始信息承载位(沿每个箭头显示为单个位)。解码器维护几个可能的路径和它们的累积误差，以防错误发生。为了避免为一个<em class="kh"> N </em>位长的序列保留所有<em class="kh"> 2ᴺ </em>可能的路径，只保留最可能的路径，而不太可能的路径则被丢弃。</p></div><div class="ab cl lo lp gp lq" role="separator"><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt"/></div><div class="hb hc hd he hf"><h1 id="9220" class="je jf hi bd jg jh lv jj jk jl lw jn jo jp lx jr js jt ly jv jw jx lz jz ka kb bi translated">维特比解码器</h1><p id="7d31" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">解码器使用两个度量，一个<em class="kh">分支度量</em>和一个<em class="kh">路径度量</em>。在给定状态和输入的情况下，分支度量测量接收到的码字和可能发送的码字之间沿着网格的每个边缘的距离(汉明距离用于硬解码)。下图显示了分支度量(红色)，假设收到的代码字是00。在黑色部分，您可以看到输入和相应的新状态。</p><figure class="kx ky kz la fd lb er es paragraph-image"><div class="er es ma"><img src="../Images/a4d78ee2c6fa6806d1890e450b616a2a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1172/format:webp/1*5M3_g4bqgEoZredCgYhDXA.png"/></div><figcaption class="li lj et er es lk ll bd b be z dx translated">给定接收到的码字00的分支度量</figcaption></figure><p id="bdfc" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="kh">路径度量</em>是沿着每条路径的分支度量的总和。如果我们在某个时间<em class="kh"> t+1，</em>观察解码器，我们注意到它可能已经到达那里，只是来自两个不同的状态。因此，如果我们不想记住所有的状态，最好是丢弃其中的一个。幸运的是我们可以。解码器通常寻找具有最小路径度量的路径。当讨论通向特定状态的两条路径时，我们可以丢弃具有更重要路径度量的路径。因此，在解码时，我们只需要记住<em class="kh"> 2ᴸ </em>路径，每条路径通向一个状态。</p><p id="ded7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">最后，我们遍历网格(连同所有接收到的码字)并选择最可能的路径作为解码路径。如果使用预定的终止方案，例如零尾终止，这可以简化最终状态的选择。算法迭代步骤:</p><ol class=""><li id="6867" class="mb mc hi ih b ii ij im in iq md iu me iy mf jc mg mh mi mj bi translated"><em class="kh">将</em>分支度量加到旧状态的路径度量上。</li><li id="8d6b" class="mb mc hi ih b ii mk im ml iq mm iu mn iy mo jc mg mh mi mj bi translated"><em class="kh">比较</em>进入相同新状态的路径的总和。</li><li id="c13f" class="mb mc hi ih b ii mk im ml iq mm iu mn iy mo jc mg mh mi mj bi translated"><em class="kh">选择</em>度量最小的路径，进入每个状态作为幸存路径。</li></ol><p id="fdfb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">最后，选择具有最小路径度量的最可能的路径或通过先验已知的终止方案。</p><h1 id="c133" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">来源</h1><p id="fb3c" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">在写这篇文章时，我使用了:</p><ul class=""><li id="06e6" class="mb mc hi ih b ii ij im in iq md iu me iy mf jc mp mh mi mj bi translated"><a class="ae jd" href="https://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-02-introduction-to-eecs-ii-digital-communication-systems-fall-2012/readings/MIT6_02F12_chap07.pdf" rel="noopener ugc nofollow" target="_blank">麻省理工学院开放式课件笔记</a> —编码</li><li id="ee75" class="mb mc hi ih b ii mk im ml iq mm iu mn iy mo jc mp mh mi mj bi translated"><a class="ae jd" href="https://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-02-introduction-to-eecs-ii-digital-communication-systems-fall-2012/readings/MIT6_02F12_chap08.pdf" rel="noopener ugc nofollow" target="_blank">麻省理工学院开放课件笔记</a> —解码</li></ul></div></div>    
</body>
</html>