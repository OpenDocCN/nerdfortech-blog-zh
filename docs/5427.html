<html>
<head>
<title>JUnit5, Mockito, TDD with Camunda BPMN2.0 spring-boot</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">6 月 5 日，Mockito，TDD，带 Camunda BPMN2.0 弹簧靴</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/junit5-mockito-tdd-with-camunda-bpmn2-0-spring-boot-dd18e7f2b8dc?source=collection_archive---------0-----------------------#2021-09-30">https://medium.com/nerd-for-tech/junit5-mockito-tdd-with-camunda-bpmn2-0-spring-boot-dd18e7f2b8dc?source=collection_archive---------0-----------------------#2021-09-30</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><blockquote class="if"><p id="bb15" class="ig ih hi bd ii ij ik il im in io ip dx translated"><em class="iq">“哦不！！更新的代码有效。但是……现有的工作流程正在崩溃。怎么回事？”</em></p></blockquote><p id="8d9c" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn ip hb bi translated">如果您现有的流程有一个<em class="jo">测试用例</em>，并且您已经在部署之前运行了测试用例，那么这可能是可以避免的。如果这是一个自动化的部署，那么你将有<strong class="it hj">测试步骤</strong>在某个地方会失败。</p><blockquote class="jp jq jr"><p id="db33" class="ir is jo it b iu js iw ix iy jt ja jb ju jv je jf jw jx ji jj jy jz jm jn ip hb bi translated">这个博客回答的问题是<strong class="it hj">Camunda 如何帮助编写 cam unda 工作流的测试用例</strong>？</p></blockquote><p id="eec8" class="pw-post-body-paragraph ir is hi it b iu js iw ix iy jt ja jb jc jv je jf jg jx ji jj jk jz jm jn ip hb bi translated"><em class="jo">你可以阅读我早前的博客来</em> <a class="ae ka" rel="noopener" href="/nerd-for-tech/bpmn2-0-camunda-workflow-spring-boot-application-2381f3d42e5f"> <em class="jo">了解 BPMN 2.0 卡蒙达样片</em> </a> <em class="jo">。你可以在 GitHub </em>   <em class="jo">上找到这两个博客的</em> <a class="ae ka" href="https://github.com/sourabhparsekar/camunda-masala-noodles" rel="noopener ugc nofollow" target="_blank"> <strong class="it hj"> <em class="jo">代码。</em></strong></a></p><figure class="kc kd ke kf fd kg er es paragraph-image"><div class="er es kb"><img src="../Images/9207e30b5d31866ef65dcb514af37970.png" data-original-src="https://miro.medium.com/v2/resize:fit:790/format:webp/1*laR5tEyU9XA8tgD1DxCnNw.png"/></div></figure><p id="4819" class="pw-post-body-paragraph ir is hi it b iu js iw ix iy jt ja jb jc jv je jf jg jx ji jj jk jz jm jn ip hb bi translated"><a class="ae ka" href="https://rezaid.co.uk/services/software-testing/" rel="noopener ugc nofollow" target="_blank"> <strong class="it hj">软件测试</strong> </a>检查软件应用程序和产品的缺陷和错误，以确保其性能高效可靠。</p><p id="66d8" class="pw-post-body-paragraph ir is hi it b iu js iw ix iy jt ja jb jc jv je jf jg jx ji jj jk jz jm jn ip hb bi translated">软件测试是一个连续的过程，用于识别、评估和确认业务需求规格是否得到满足。</p><p id="744e" class="pw-post-body-paragraph ir is hi it b iu js iw ix iy jt ja jb jc jv je jf jg jx ji jj jk jz jm jn ip hb bi translated"><a class="ae ka" href="https://camunda.com/developers/getting-started/" rel="noopener ugc nofollow" target="_blank"> <strong class="it hj"> <em class="jo"> Camunda 工作流引擎</em> </strong> </a>嵌入 springboot 在测试用例方面没有什么不同。我们可以为每个 camunda 流程步骤(单元测试)或整个流程(集成测试)编写测试，但我们必须为两者都编写测试，以符合业务需求规范。</p></div><div class="ab cl kj kk gp kl" role="separator"><span class="km bw bk kn ko kp"/><span class="km bw bk kn ko kp"/><span class="km bw bk kn ko"/></div><div class="hb hc hd he hf"><h1 id="8ffc" class="kq kr hi bd ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln bi translated">JUnit 5 是什么？</h1><p id="4777" class="pw-post-body-paragraph ir is hi it b iu lo iw ix iy lp ja jb jc lq je jf jg lr ji jj jk ls jm jn ip hb bi translated">根据 JUnit 用户指南:</p><p id="e18e" class="pw-post-body-paragraph ir is hi it b iu js iw ix iy jt ja jb jc jv je jf jg jx ji jj jk jz jm jn ip hb bi translated">JUnit 5 由来自三个不同子项目的几个不同模块组成。</p><p id="1370" class="pw-post-body-paragraph ir is hi it b iu js iw ix iy jt ja jb jc jv je jf jg jx ji jj jk jz jm jn ip hb bi translated"><a class="ae ka" href="https://junit.org/junit5/docs/current/user-guide/" rel="noopener ugc nofollow" target="_blank"><strong class="it hj">JUnit 5</strong></a><strong class="it hj">=<em class="jo">JUnit 平台</em> + <em class="jo"> JUnit 木星</em>+<em class="jo">JUnit Vintage</em></strong></p><p id="a6fd" class="pw-post-body-paragraph ir is hi it b iu js iw ix iy jt ja jb jc jv je jf jg jx ji jj jk jz jm jn ip hb bi translated"><strong class="it hj"> JUnit 平台</strong>作为<a class="ae ka" href="https://junit.org/junit5/docs/current/user-guide/#launcher-api" rel="noopener ugc nofollow" target="_blank">在 JVM 上发布测试框架</a>的基础。它还定义了用于开发在平台上运行的测试框架的<code class="du lt lu lv lw b"><a class="ae ka" href="https://junit.org/junit5/docs/current/api/org.junit.platform.engine/org/junit/platform/engine/TestEngine.html" rel="noopener ugc nofollow" target="_blank"><strong class="it hj">TestEngine</strong></a></code> <strong class="it hj"> </strong> API。</p><p id="8a6c" class="pw-post-body-paragraph ir is hi it b iu js iw ix iy jt ja jb jc jv je jf jg jx ji jj jk jz jm jn ip hb bi translated"><strong class="it hj"> JUnit Jupiter </strong>是新的<a class="ae ka" href="https://junit.org/junit5/docs/current/user-guide/#writing-tests" rel="noopener ugc nofollow" target="_blank">编程模型</a>和<a class="ae ka" href="https://junit.org/junit5/docs/current/user-guide/#extensions" rel="noopener ugc nofollow" target="_blank">扩展模型</a>的组合，用于在 JUnit 5 中编写测试和扩展。Jupiter 子项目提供了一个<code class="du lt lu lv lw b"><strong class="it hj">TestEngine</strong></code> <strong class="it hj"> </strong>用于在平台上运行基于 Jupiter 的测试。</p><p id="3ad7" class="pw-post-body-paragraph ir is hi it b iu js iw ix iy jt ja jb jc jv je jf jg jx ji jj jk jz jm jn ip hb bi translated"><strong class="it hj"> JUnit Vintage </strong>为在平台上运行基于 JUnit 3 和 JUnit 4 的测试提供了一个<code class="du lt lu lv lw b"><strong class="it hj">TestEngine</strong></code> <strong class="it hj"> </strong>。它要求 JUnit 4.12 或更高版本出现在类/模块路径中。</p><p id="95d9" class="pw-post-body-paragraph ir is hi it b iu js iw ix iy jt ja jb jc jv je jf jg jx ji jj jk jz jm jn ip hb bi translated">您可以访问<a class="ae ka" href="https://junit.org/junit5/docs/current/user-guide/#overview" rel="noopener ugc nofollow" target="_blank"> JUnit 5 用户指南</a>了解更多信息。</p></div><div class="ab cl kj kk gp kl" role="separator"><span class="km bw bk kn ko kp"/><span class="km bw bk kn ko kp"/><span class="km bw bk kn ko"/></div><div class="hb hc hd he hf"><h1 id="6a7f" class="kq kr hi bd ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln bi translated">什么是莫奇托？</h1><p id="2502" class="pw-post-body-paragraph ir is hi it b iu lo iw ix iy lp ja jb jc lq je jf jg lr ji jj jk ls jm jn ip hb bi translated">顾名思义，Mockito 框架用于创建 Mocks，从接口到最终的类。它让你用一个干净简单的 API 编写漂亮的测试。Mockito 测试可读性很强，并且产生干净的验证错误</p><p id="4a87" class="pw-post-body-paragraph ir is hi it b iu js iw ix iy jt ja jb jc jv je jf jg jx ji jj jk jz jm jn ip hb bi translated">可以访问<a class="ae ka" href="https://site.mockito.org/" rel="noopener ugc nofollow" target="_blank"> Mockito 框架</a>了解更多。</p><h1 id="12fb" class="kq kr hi bd ks kt lx kv kw kx ly kz la lb lz ld le lf ma lh li lj mb ll lm ln bi translated">什么是 Camunda Mockito？</h1><p id="38c2" class="pw-post-body-paragraph ir is hi it b iu lo iw ix iy lp ja jb jc lq je jf jg lr ji jj jk ls jm jn ip hb bi translated">如果你做过 Camunda 工作流代码，写过一些测试，那么你肯定知道 Camunda 中有太多的东西需要模仿和 stub。Camunda Mockito 简化了这个模拟和测试过程。</p><p id="3e7b" class="pw-post-body-paragraph ir is hi it b iu js iw ix iy jt ja jb jc jv je jf jg jx ji jj jk jz jm jn ip hb bi translated">camunda-bpm-mockito 是 Camunda BPM 流程引擎的社区扩展，旨在简化和自动化流程应用程序的模拟。</p><p id="c4da" class="pw-post-body-paragraph ir is hi it b iu js iw ix iy jt ja jb jc jv je jf jg jx ji jj jk jz jm jn ip hb bi translated">可以访问<a class="ae ka" href="https://github.com/camunda-community-hub/camunda-bpm-mockito" rel="noopener ugc nofollow" target="_blank">cam unda-BPM-mock ITO</a>github 资源库了解更多。</p><p id="5711" class="pw-post-body-paragraph ir is hi it b iu js iw ix iy jt ja jb jc jv je jf jg jx ji jj jk jz jm jn ip hb bi translated">我们将使用 JUnit 5 和 Camunda Mockito 来编写单元和集成测试。然而，我们还可以用 Camunda 工作流做一件事，即 TDD——测试驱动开发</p></div><div class="ab cl kj kk gp kl" role="separator"><span class="km bw bk kn ko kp"/><span class="km bw bk kn ko kp"/><span class="km bw bk kn ko"/></div><div class="hb hc hd he hf"><h1 id="012d" class="kq kr hi bd ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln bi translated">什么是 TDD？</h1><p id="2a50" class="pw-post-body-paragraph ir is hi it b iu lo iw ix iy lp ja jb jc lq je jf jg lr ji jj jk ls jm jn ip hb bi translated">这是一个有争议的话题。然而，根据定义，“<a class="ae ka" href="https://www.agilealliance.org/glossary/tdd/#q=~(infinite~false~filters~(postType~(~'page~'post~'aa_book~'aa_event_session~'aa_experience_report~'aa_glossary~'aa_research_paper~'aa_video)~tags~(~'tdd))~searchTerm~'~sort~false~sortDirection~'asc~page~1)" rel="noopener ugc nofollow" target="_blank">测试驱动开发</a>”指的是三种活动紧密交织的编程风格:编码、测试(<a class="ae ka" href="https://www.agilealliance.org/glossary/unit-test/" rel="noopener ugc nofollow" target="_blank">单元测试</a>)和设计。</p><p id="5dd7" class="pw-post-body-paragraph ir is hi it b iu js iw ix iy jt ja jb jc jv je jf jg jx ji jj jk jz jm jn ip hb bi translated">下面是我们在使用 TDD 时可以记住的一些规则:</p><ul class=""><li id="0ac5" class="mc md hi it b iu js iy jt jc me jg mf jk mg ip mh mi mj mk bi translated">编写一个“单一的”单元测试，描述程序的一个方面</li><li id="19f9" class="mc md hi it b iu ml iy mm jc mn jg mo jk mp ip mh mi mj mk bi translated">运行测试，这应该会失败，因为程序缺少该特性</li><li id="a471" class="mc md hi it b iu ml iy mm jc mn jg mo jk mp ip mh mi mj mk bi translated">编写“刚好够用”的代码，尽可能简单，以使测试通过</li><li id="ba95" class="mc md hi it b iu ml iy mm jc mn jg mo jk mp ip mh mi mj mk bi translated">“重构”代码，直到它符合<a class="ae ka" href="https://www.agilealliance.org/glossary/rules-of-simplicity/" rel="noopener ugc nofollow" target="_blank">简单性标准</a></li><li id="1ad6" class="mc md hi it b iu ml iy mm jc mn jg mo jk mp ip mh mi mj mk bi translated">重复，随着时间“积累”单元测试</li></ul><figure class="kc kd ke kf fd kg"><div class="bz dy l di"><div class="mq mr l"/></div></figure><p id="2f77" class="pw-post-body-paragraph ir is hi it b iu js iw ix iy jt ja jb jc jv je jf jg jx ji jj jk jz jm jn ip hb bi translated">例如，假设我们正在为一个计算器程序编写 add 功能。</p><p id="396a" class="pw-post-body-paragraph ir is hi it b iu js iw ix iy jt ja jb jc jv je jf jg jx ji jj jk jz jm jn ip hb bi translated">我们知道 add 做什么，所以我们编写一个测试来将两个整数相加。要解决编译问题，请编写将通过测试的函数和代码。</p><p id="042d" class="pw-post-body-paragraph ir is hi it b iu js iw ix iy jt ja jb jc jv je jf jg jx ji jj jk jz jm jn ip hb bi translated">因此，您将最终写出可测试和可追踪的代码。</p><p id="a549" class="pw-post-body-paragraph ir is hi it b iu js iw ix iy jt ja jb jc jv je jf jg jx ji jj jk jz jm jn ip hb bi translated">就像任何其他方面一样，TDD 方法也有缺陷。调整需要时间，开发人员要在测试用例与代码之间来回跳跃。但是，总的来说，TDD 方法提高了代码的设计质量。随着时间的推移，它有助于减少产品中的缺陷。</p><p id="cfcc" class="pw-post-body-paragraph ir is hi it b iu js iw ix iy jt ja jb jc jv je jf jg jx ji jj jk jz jm jn ip hb bi translated">有了 Camunda，我们就有了实施 TDD 的大好机会。ca munda 工作流程中的每一步都可以被视为一个单元。对于每个单元，可以使用该步骤的预期输入和输出来编写测试用例。在这一点上，如果您运行测试，那么它将会失败，这在 TDD 中是预料之中的。然后，我们可以添加最少的代码来通过测试。</p><p id="e557" class="pw-post-body-paragraph ir is hi it b iu js iw ix iy jt ja jb jc jv je jf jg jx ji jj jk jz jm jn ip hb bi translated">让我们结合上一节中的所有细节，在 Camunda 中实现单元和集成测试用例。<em class="jo">你可以在 GitHub </em>  上找到 <a class="ae ka" href="https://github.com/sourabhparsekar/camunda-masala-noodles" rel="noopener ugc nofollow" target="_blank"> <strong class="it hj"> <em class="jo">代码</em></strong></a></p></div><div class="ab cl kj kk gp kl" role="separator"><span class="km bw bk kn ko kp"/><span class="km bw bk kn ko kp"/><span class="km bw bk kn ko"/></div><div class="hb hc hd he hf"><figure class="kc kd ke kf fd kg er es paragraph-image"><div class="er es ms"><img src="../Images/fe0bc9886fec8623b7e05be2277b93c9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1270/format:webp/1*Okf664Ns0ZZ6ZORFgFR63A.png"/></div><figcaption class="mt mu et er es mv mw bd b be z dx translated">6 月 5 日，springboot 嵌入式 Camunda 引擎的 Mockito 测试</figcaption></figure><p id="d836" class="pw-post-body-paragraph ir is hi it b iu js iw ix iy jt ja jb jc jv je jf jg jx ji jj jk jz jm jn ip hb bi translated">为了使用 JUnit5、Mockito、CamundaMockito，我们必须首先设置我们的<em class="jo"> POM(项目对象模型)文件</em>。以下是 Camunda 引擎 7.15.0 和 Springboot 2.4.3 的最小依赖项。</p><figure class="kc kd ke kf fd kg"><div class="bz dy l di"><div class="mq mr l"/></div></figure><blockquote class="jp jq jr"><p id="3654" class="ir is jo it b iu js iw ix iy jt ja jb ju jv je jf jw jx ji jj jy jz jm jn ip hb bi translated"><a class="ae ka" href="https://www.mvndoc.com/c/org.camunda.bpm.extension.mockito/camunda-bpm-mockito/index.html?org/camunda/bpm/extension/mockito/CamundaMockito.html" rel="noopener ugc nofollow" target="_blank"><strong class="it hj">Camunda mocks ITO</strong></a><strong class="it hj">javadocs</strong>描述了可以使用它创建的各种 mock。在测试用例中你会经常看到的一个例子是使用类<a class="ae ka" href="https://www.mvndoc.com/c/org.camunda.bpm.extension.mockito/camunda-bpm-mockito/org/camunda/bpm/extension/mockito/delegate/DelegateExecutionFake.html" rel="noopener ugc nofollow" target="_blank"> DelegateExecutionFake </a>。</p></blockquote><figure class="kc kd ke kf fd kg"><div class="bz dy l di"><div class="mq mr l"/></div></figure><p id="8205" class="pw-post-body-paragraph ir is hi it b iu js iw ix iy jt ja jb jc jv je jf jg jx ji jj jk jz jm jn ip hb bi translated">DelegateExecutionFake 可能不支持所有操作，但是如果需要，我们可以扩展它并实现模拟。</p><p id="244c" class="pw-post-body-paragraph ir is hi it b iu js iw ix iy jt ja jb jc jv je jf jg jx ji jj jk jz jm jn ip hb bi translated">它提供了一个假的/模仿的 delegateExecution 来测试简单的委托/侦听器，而没有模仿。</p><p id="6c80" class="pw-post-body-paragraph ir is hi it b iu js iw ix iy jt ja jb jc jv je jf jg jx ji jj jk jz jm jn ip hb bi translated">该项目的一个测试展示了假 delegateExecution()的使用。</p><p id="77b1" class="pw-post-body-paragraph ir is hi it b iu js iw ix iy jt ja jb jc jv je jf jg jx ji jj jk jz jm jn ip hb bi translated">这里，我们触发了 OrderOnline JavaDelegate 步骤，然后尝试检查变量集的值。</p><p id="8056" class="pw-post-body-paragraph ir is hi it b iu js iw ix iy jt ja jb jc jv je jf jg jx ji jj jk jz jm jn ip hb bi translated">这也可以使用 Mockito 来完成，但是 CamundaMockito 包含了用于模仿的锅炉板代码。</p><p id="c787" class="pw-post-body-paragraph ir is hi it b iu js iw ix iy jt ja jb jc jv je jf jg jx ji jj jk jz jm jn ip hb bi translated">另一个例子可能是假的 VariableScope，当我们从 BPMN 工作流中调用的活动接收响应时，就需要它。</p><p id="f881" class="pw-post-body-paragraph ir is hi it b iu js iw ix iy jt ja jb jc jv je jf jg jx ji jj jk jz jm jn ip hb bi translated">对于更多模拟类，您可以查看 camunda-mockito 的<a class="ae ka" href="https://www.mvndoc.com/c/org.camunda.bpm.extension.mockito/camunda-bpm-mockito/index.html?org/camunda/bpm/extension/mockito/CamundaMockito.html" rel="noopener ugc nofollow" target="_blank"> javadocs </a></p><p id="c58a" class="pw-post-body-paragraph ir is hi it b iu js iw ix iy jt ja jb jc jv je jf jg jx ji jj jk jz jm jn ip hb bi translated">我们可以将此视为单元测试用例，并使用 TDD 方法来设计测试。另外，这些样本是使用 JUnit 5 Jupiter TestEngine 开发的。</p><h2 id="b9a9" class="mx kr hi bd ks my mz na kw nb nc nd la jc ne nf le jg ng nh li jk ni nj lm nk bi translated">现在，我们来谈谈集成测试。一个完整的流量测试！！</h2><p id="2f78" class="pw-post-body-paragraph ir is hi it b iu lo iw ix iy lp ja jb jc lq je jf jg lr ji jj jk ls jm jn ip hb bi translated">我使用 Mockito 为 Camunda 流编写集成测试。想想我们的<a class="ae ka" href="https://github.com/sourabhparsekar/camunda-masala-noodles" rel="noopener ugc nofollow" target="_blank">卡蒙达面条项目</a>，我们根据现有的配料来煮面。Camunda 告诉我们食谱，然后希望我们告诉我们是否能够烹饪它。</p><p id="c876" class="pw-post-body-paragraph ir is hi it b iu js iw ix iy jt ja jb jc jv je jf jg jx ji jj jk jz jm jn ip hb bi translated"><a class="ae ka" href="https://camunda.com/blog/2020/10/testing-entire-process-paths/" rel="noopener ugc nofollow" target="_blank">为了测试整个流程</a>，我们可以创建一个模拟实例<a class="ae ka" href="https://github.com/camunda-community-hub/camunda-platform-scenario/blob/master/runner/src/main/java/org/camunda/bpm/scenario/ProcessScenario.java" rel="noopener ugc nofollow" target="_blank"><strong class="it hj"><em class="jo">process scenario</em></strong></a>接口，它扩展了<a class="ae ka" href="https://github.com/camunda-community-hub/camunda-platform-scenario/blob/b22b8e971b3122675550ce63d306506a84203522/runner/src/main/java/org/camunda/bpm/scenario/run/Runnable.java#L6" rel="noopener ugc nofollow" target="_blank"> <em class="jo"> Runnable </em> </a>。然后，当我们想要调用一个 Camunda 流时，比如说“CookMasalaVeggiesNoodles”，我们可以简单地通过使用 Scenario.run()和使用 key 来启动这个过程。</p><pre class="kc kd ke kf fd nl lw nm nn aw no bi"><span id="9440" class="mx kr hi lw b fi np nq l nr ns">ProcessScenario scenario = <strong class="lw hj">Mockito.mock(ProcessScenario.class)</strong>;</span><span id="5c6f" class="mx kr hi lw b fi nt nq l nr ns">//this will trigger the BPMN Flow to invoke the cooking process<br/>Scenario handler = <strong class="lw hj">Scenario.<em class="jo">run</em>(scenario).startByKey</strong>("CookMasalaVeggiesNoodles", variables)<strong class="lw hj">.execute()</strong>;</span></pre><p id="5401" class="pw-post-body-paragraph ir is hi it b iu js iw ix iy jt ja jb jc jv je jf jg jx ji jj jk jz jm jn ip hb bi translated">让我们检查我们运行的流的一个输出变量值。我们可以从<a class="ae ka" href="https://github.com/camunda/camunda-bpm-assert/blob/master/core/src/main/java/org/camunda/bpm/engine/test/assertions/bpmn/BpmnAwareTests.java" rel="noopener ugc nofollow" target="_blank"><strong class="it hj"><em class="jo">BpmnAwareTests</em></strong></a><em class="jo">中使用<em class="jo">as sert that()</em>。</em>代码如下所示，我们获取流程实例变量并检查其中是否存在键值。</p><pre class="kc kd ke kf fd nl lw nm nn aw no bi"><span id="d4b3" class="mx kr hi lw b fi np nq l nr ns">// check the final output if it has all the values<br/><em class="jo">assertThat</em>(<strong class="lw hj">handler.instance(scenario)).variables().containsEntry</strong>(Constants.<em class="jo">DID_WE_EAT_NOODLES</em>, true);</span></pre><p id="57a2" class="pw-post-body-paragraph ir is hi it b iu js iw ix iy jt ja jb jc jv je jf jg jx ji jj jk jz jm jn ip hb bi translated">流程测试的剩余部分是验证 bpmn 流程步骤是否被访问。这可以使用<strong class="it hj"> <em class="jo"> Mockito </em> </strong>中的<em class="jo"> verify() </em>进行验证。代码看起来像下面这样，它也采用流程场景实例，并检查 id 为“LetsCook”的步骤是否已经完成/开始。</p><pre class="kc kd ke kf fd nl lw nm nn aw no bi"><span id="f89e" class="mx kr hi lw b fi np nq l nr ns">// check the order of the desired steps in the success flow  </span><span id="9809" class="mx kr hi lw b fi nt nq l nr ns">// process start  <br/><strong class="lw hj"><em class="jo">verify</em></strong>(scenario, <strong class="lw hj"><em class="jo">times</em>(1)</strong>).<strong class="lw hj">hasFinished</strong>("Start_Process");   </span><span id="9bc6" class="mx kr hi lw b fi nt nq l nr ns">// exclusive gateway  <br/><strong class="lw hj"><em class="jo">verify</em></strong>(scenario, <strong class="lw hj"><em class="jo">atMostOnce</em>()</strong>).<strong class="lw hj">hasCompleted</strong>("CanWeCook");   </span><span id="7e40" class="mx kr hi lw b fi nt nq l nr ns">// cooking service step  <br/><strong class="lw hj"><em class="jo">verify</em></strong>(scenario, <em class="jo">atMostOnce</em>()).<strong class="lw hj">hasCompleted</strong>("LetsCook");   </span><span id="766d" class="mx kr hi lw b fi nt nq l nr ns">// check for the event  <br/><strong class="lw hj"><em class="jo">verify</em></strong>(scenario, <em class="jo">atMostOnce</em>()).<strong class="lw hj">hasCompleted</strong>("IsItReady");   </span><span id="ec1d" class="mx kr hi lw b fi nt nq l nr ns">// All went well so call eat service  <br/><strong class="lw hj"><em class="jo">verify</em></strong>(scenario, <em class="jo">atMostOnce</em>()).<strong class="lw hj">hasCompleted</strong>("LetUsEat");  <br/><strong class="lw hj"><em class="jo">verify</em></strong>(scenario, <strong class="lw hj"><em class="jo">never</em>()</strong>).<strong class="lw hj">hasStarted</strong>("OrderOnline");  </span><span id="2aac" class="mx kr hi lw b fi nt nq l nr ns">// end event  <br/><strong class="lw hj"><em class="jo">verify</em></strong>(scenario, <em class="jo">times</em>(1)).<strong class="lw hj">hasFinished</strong>("End_Process");  </span></pre><p id="2672" class="pw-post-body-paragraph ir is hi it b iu js iw ix iy jt ja jb jc jv je jf jg jx ji jj jk jz jm jn ip hb bi translated">除此之外，ProcessScenario 可以使用 Mockito 来扩展，以模拟事件或其他步骤。如果我们希望事件网关说“IsItReady”来捕捉消息“IsReady ”,那么我们可以使用下面的代码。或者，您可以传递事件网关可能需要的变量，以供进一步处理。</p><pre class="kc kd ke kf fd nl lw nm nn aw no bi"><span id="cfb1" class="mx kr hi lw b fi np nq l nr ns">//event based gateway response set for mocking<br/><em class="jo">when</em>(<strong class="lw hj">scenario.waitsAtEventBasedGateway("IsItReady")</strong>).thenReturn(gateway -&gt; {<br/>    System.<em class="jo">out</em>.println("ReceivedEvent");<br/>    Map recVariables = new HashMap&lt;String, Object&gt;();<br/>    <strong class="lw hj">gateway.getEventSubscription("IsReady").receive(recVariables);</strong><br/>});</span></pre><p id="2186" class="pw-post-body-paragraph ir is hi it b iu js iw ix iy jt ja jb jc jv je jf jg jx ji jj jk jz jm jn ip hb bi translated">但是，如果我们希望事件网关失败，比如说超时场景，那么我们可以像下面这样写它。我们基本上声明它是空的，即什么也不做。因此导致立即超时的情况，而不是等待事件。</p><pre class="kc kd ke kf fd nl lw nm nn aw no bi"><span id="444b" class="mx kr hi lw b fi np nq l nr ns">//event based gateway timeout<br/><em class="jo">when</em>(<strong class="lw hj">scenario.waitsAtEventBasedGateway("IsItReady")</strong>).thenReturn(gateway -&gt; {<br/>    System.<em class="jo">out</em>.println("Do Nothing to simulate a timeout");<br/>});</span></pre><p id="8a4f" class="pw-post-body-paragraph ir is hi it b iu js iw ix iy jt ja jb jc jv je jf jg jx ji jj jk jz jm jn ip hb bi translated">对于<strong class="it hj"><em class="jo">process scenario</em></strong>使用上述概念的测试用例如下，或者您也可以在<a class="ae ka" href="https://github.com/sourabhparsekar/camunda-masala-noodles" rel="noopener ugc nofollow" target="_blank"> Github </a>库中查看。</p><figure class="kc kd ke kf fd kg"><div class="bz dy l di"><div class="mq mr l"/></div></figure><p id="1c69" class="pw-post-body-paragraph ir is hi it b iu js iw ix iy jt ja jb jc jv je jf jg jx ji jj jk jz jm jn ip hb bi translated">人们只能体会到通过使用 JUnit5、Mockito 和 CamundaMockito 框架在不同的步骤/流程中移动并验证完整的处理来测试整个流程是多么容易。</p></div><div class="ab cl kj kk gp kl" role="separator"><span class="km bw bk kn ko kp"/><span class="km bw bk kn ko kp"/><span class="km bw bk kn ko"/></div><div class="hb hc hd he hf"><h1 id="3f80" class="kq kr hi bd ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln bi translated">结论</h1><p id="fd64" class="pw-post-body-paragraph ir is hi it b iu lo iw ix iy lp ja jb jc lq je jf jg lr ji jj jk ls jm jn ip hb bi translated">查看我们上面的单元测试和集成测试，我们可以得出结论，Junit5、Mockito 和 Camunda Mockito 将帮助我们:</p><ul class=""><li id="1840" class="mc md hi it b iu js iy jt jc me jg mf jk mg ip mh mi mj mk bi translated">模拟侦听器和委托行为——由于委托和侦听器方法是无效的，它们可以修改流程变量或引发错误。您可以使用这些选项，而不是弄乱 mockito 的 doAnswer()。</li><li id="f058" class="mc md hi it b iu ml iy mm jc mn jg mo jk mp ip mh mi mj mk bi translated">模拟子进程——子进程能够等待计时器、设置变量、等待消息、发送消息、抛出异常或做任何你想做的事情。</li><li id="6b45" class="mc md hi it b iu ml iy mm jc mn jg mo jk mp ip mh mi mj mk bi translated">自动模仿进程中的所有表达式和委托，而无需显式注册模仿</li></ul><p id="481e" class="pw-post-body-paragraph ir is hi it b iu js iw ix iy jt ja jb jc jv je jf jg jx ji jj jk jz jm jn ip hb bi translated"><em class="jo">希望你已经发现这是一个</em> <strong class="it hj"> <em class="jo">有趣的</em> </strong> <em class="jo">使用嵌入式卡蒙达工作流引擎开发的测试烹饪方便面的故事。</em></p><p id="c19b" class="pw-post-body-paragraph ir is hi it b iu js iw ix iy jt ja jb jc jv je jf jg jx ji jj jk jz jm jn ip hb bi translated">请留下您的反馈或给予一些掌声。如往常一样，对于在设置您的本地环境方面的任何疑问或问题，我们可以通过电子邮件或下面的评论进行联系。</p><p id="9d3f" class="pw-post-body-paragraph ir is hi it b iu js iw ix iy jt ja jb jc jv je jf jg jx ji jj jk jz jm jn ip hb bi translated"><em class="jo">下次见，快乐烹饪！！</em></p></div><div class="ab cl kj kk gp kl" role="separator"><span class="km bw bk kn ko kp"/><span class="km bw bk kn ko kp"/><span class="km bw bk kn ko"/></div><div class="hb hc hd he hf"><h1 id="8c4d" class="kq kr hi bd ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln bi translated">参考资料:</h1><div class="nu nv ez fb nw nx"><a href="https://junit.org/junit5/docs/current/user-guide/" rel="noopener  ugc nofollow" target="_blank"><div class="ny ab dw"><div class="nz ab oa cl cj ob"><h2 class="bd hj fi z dy oc ea eb od ed ef hh bi translated">JUnit 5 用户指南</h2><div class="oe l"><h3 class="bd b fi z dy oc ea eb od ed ef dx translated">所有事件:Event [type = STARTED，test descriptor = JupiterEngineDescriptor:[engine:JUnit-Jupiter]，时间戳=…</h3></div><div class="of l"><p class="bd b fp z dy oc ea eb od ed ef dx translated">junit.org</p></div></div><div class="og l"><div class="oh l oi oj ok og ol kh nx"/></div></div></a></div><div class="nu nv ez fb nw nx"><a href="https://rezaid.co.uk/7-reasons-why-software-testing-is-necessary/" rel="noopener  ugc nofollow" target="_blank"><div class="ny ab dw"><div class="nz ab oa cl cj ob"><h2 class="bd hj fi z dy oc ea eb od ed ef hh bi translated">为什么软件测试是必要的 7 个基本原因</h2><div class="oe l"><h3 class="bd b fi z dy oc ea eb od ed ef dx translated">什么是软件测试？软件测试是检查软件应用程序和产品的错误和缺陷的过程</h3></div><div class="of l"><p class="bd b fp z dy oc ea eb od ed ef dx translated">rezaid.co.uk</p></div></div><div class="og l"><div class="om l oi oj ok og ol kh nx"/></div></div></a></div><div class="nu nv ez fb nw nx"><a rel="noopener follow" target="_blank" href="/nerd-for-tech/bpmn2-0-camunda-workflow-spring-boot-application-2381f3d42e5f"><div class="ny ab dw"><div class="nz ab oa cl cj ob"><h2 class="bd hj fi z dy oc ea eb od ed ef hh bi translated">BPMN2.0 - camunda 工作流春季启动应用程序</h2><div class="oe l"><h3 class="bd b fi z dy oc ea eb od ed ef dx translated">有意思……这种与 spring boot 集成的 DIY camunda 工作流程旨在给你一种 camunda…</h3></div><div class="of l"><p class="bd b fp z dy oc ea eb od ed ef dx translated">medium.com</p></div></div><div class="og l"><div class="on l oi oj ok og ol kh nx"/></div></div></a></div><div class="nu nv ez fb nw nx"><a href="https://github.com/sourabhparsekar/camunda-masala-noodles" rel="noopener  ugc nofollow" target="_blank"><div class="ny ab dw"><div class="nz ab oa cl cj ob"><h2 class="bd hj fi z dy oc ea eb od ed ef hh bi translated">GitHub-sourabhparsekar/cam unda-masala-noodles:这个独立的流程应用程序就是一个例子…</h2><div class="oe l"><h3 class="bd b fi z dy oc ea eb od ed ef dx translated">这个独立的流程应用程序是使用 Camunda 工作流引擎和 Springboot 的一个例子。至于用例，我们…</h3></div><div class="of l"><p class="bd b fp z dy oc ea eb od ed ef dx translated">github.com</p></div></div><div class="og l"><div class="oo l oi oj ok og ol kh nx"/></div></div></a></div><div class="nu nv ez fb nw nx"><a href="https://www.mvndoc.com/c/org.camunda.bpm.extension.mockito/camunda-bpm-mockito/index.html?org/camunda/bpm/extension/mockito/CamundaMockito.html" rel="noopener  ugc nofollow" target="_blank"><div class="ny ab dw"><div class="nz ab oa cl cj ob"><h2 class="bd hj fi z dy oc ea eb od ed ef hh bi translated">camunda-bpm-mockito 4.0.0 API</h2><div class="oe l"><h3 class="bd b fi z dy oc ea eb od ed ef dx translated">您的浏览器禁用了 JavaScript。本文档旨在使用框架功能查看。如果你看到…</h3></div><div class="of l"><p class="bd b fp z dy oc ea eb od ed ef dx translated">www.mvndoc.com</p></div></div></div></a></div><div class="nu nv ez fb nw nx"><a href="https://camunda.com/" rel="noopener  ugc nofollow" target="_blank"><div class="ny ab dw"><div class="nz ab oa cl cj ob"><h2 class="bd hj fi z dy oc ea eb od ed ef hh bi translated">工作流和决策自动化平台| Camunda</h2><div class="oe l"><h3 class="bd b fi z dy oc ea eb od ed ef dx translated">BPMN 工作流和 DMN 决策自动化的开源平台。立即下载。</h3></div><div class="of l"><p class="bd b fp z dy oc ea eb od ed ef dx translated">camunda.com</p></div></div><div class="og l"><div class="op l oi oj ok og ol kh nx"/></div></div></a></div><div class="nu nv ez fb nw nx"><a href="https://camunda.com/blog/2020/10/testing-entire-process-paths/" rel="noopener  ugc nofollow" target="_blank"><div class="ny ab dw"><div class="nz ab oa cl cj ob"><h2 class="bd hj fi z dy oc ea eb od ed ef hh bi translated">测试整个过程路径- Camunda</h2><div class="oe l"><h3 class="bd b fi z dy oc ea eb od ed ef dx translated">为什么我应该测试我的过程模型？简短的回答是:从技术角度来看，BPMN 是一个编程…</h3></div><div class="of l"><p class="bd b fp z dy oc ea eb od ed ef dx translated">camunda.com</p></div></div><div class="og l"><div class="oq l oi oj ok og ol kh nx"/></div></div></a></div></div></div>    
</body>
</html>