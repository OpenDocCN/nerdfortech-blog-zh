<html>
<head>
<title>Angular recommendations and good practices</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">角度建议和良好实践</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/angular-recommendations-and-good-practices-d4b732965cad?source=collection_archive---------0-----------------------#2021-03-27">https://medium.com/nerd-for-tech/angular-recommendations-and-good-practices-d4b732965cad?source=collection_archive---------0-----------------------#2021-03-27</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/118f801527864b4683393d243de197de.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iZm0nUbEDAgANJOCLfuDUg.png"/></div></div></figure><h1 id="11d7" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">配置文件:</h1><h1 id="92bd" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">tsconfig.json</h1><h2 id="0838" class="jo ir hi bd is jp jq jr iw js jt ju ja jv jw jx je jy jz ka ji kb kc kd jm ke bi translated">路径别名:</h2><p id="6bf9" class="pw-post-body-paragraph kf kg hi kh b ki kj kk kl km kn ko kp jv kq kr ks jy kt ku kv kb kw kx ky kz hb bi translated">它们是我们文件的快捷方式，有了它们，我们可以用一种更舒适、更快捷的方式实现导入。</p><pre class="la lb lc ld fd le lf lg lh aw li bi"><span id="e4c2" class="jo ir hi lf b fi lj lk l ll lm">"paths":{  <br/>   "@src/*":[  <br/>      "src/*"<br/>   ],<br/>   "@assets/*":[  <br/>      "src/assets/*"<br/>   ],<br/>   "@shared/*":[  <br/>      "src/app/shared/*"<br/>   ]<br/>}</span></pre><h1 id="a3e6" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">angular.json</h1><h2 id="5580" class="jo ir hi bd is jp jq jr iw js jt ju ja jv jw jx je jy jz ka ji kb kc kd jm ke bi translated">stylePreprocessorOptions选项:</h2><p id="f35a" class="pw-post-body-paragraph kf kg hi kh b ki kj kk kl km kn ko kp jv kq kr ks jy kt ku kv kb kw kx ky kz hb bi translated">它需要一个具有以下属性的JSON“include paths ”,该属性在同一个路径别名中声明我们的样式文件的快捷方式，唯一的区别是它不需要“@”来在scss文件中使用它。</p><pre class="la lb lc ld fd le lf lg lh aw li bi"><span id="40b9" class="jo ir hi lf b fi lj lk l ll lm">"stylePreprocessorOptions": {<br/>   "includePaths": ["src/app/shared/styles"]<br/> },</span></pre><h2 id="7983" class="jo ir hi bd is jp jq jr iw js jt ju ja jv jw jx je jy jz ka ji kb kc kd jm ke bi translated">配置:</h2><p id="359a" class="pw-post-body-paragraph kf kg hi kh b ki kj kk kl km kn ko kp jv kq kr ks jy kt ku kv kb kw kx ky kz hb bi translated">我们的项目可以在编译中使用的每一种配置。</p><p id="e34a" class="pw-post-body-paragraph kf kg hi kh b ki ln kk kl km lo ko kp jv lp kr ks jy lq ku kv kb lr kx ky kz hb bi translated">我为开发和生产推荐以下内容:</p><pre class="la lb lc ld fd le lf lg lh aw li bi"><span id="72a7" class="jo ir hi lf b fi lj lk l ll lm">"configurations": {<br/>            "local": {<br/>              "fileReplacements": [<br/>                {<br/>                  "replace": "src/environments/environment.ts",<br/>                  "with": "src/environments/environment.local.ts"<br/>                }<br/>              ],<br/>              "optimization": false,<br/>              "outputHashing": "all",<br/>              "sourceMap": true,<br/>              "extractCss": true,<br/>              "namedChunks": false,<br/>              "aot": true,<br/>              "extractLicenses": true,<br/>              "vendorChunk": false,<br/>              "buildOptimizer": false,<br/>              "budgets": [<br/>                {<br/>                  "type": "initial",<br/>                  "maximumWarning": "2mb",<br/>                  "maximumError": "5mb"<br/>                }<br/>              ]<br/>            },<br/>            "production": {<br/>              "fileReplacements": [<br/>                {<br/>                  "replace": "src/environments/environment.ts",<br/>                  "with": "src/environments/environment.prod.ts"<br/>                }<br/>              ],<br/>              "optimization": true,<br/>              "outputHashing": "all",<br/>              "sourceMap": false,<br/>              "extractCss": true,<br/>              "namedChunks": false,<br/>              "aot": true,<br/>              "extractLicenses": true,<br/>              "vendorChunk": false,<br/>              "buildOptimizer": true,<br/>              "budgets": [<br/>                {<br/>                  "type": "initial",<br/>                  "maximumWarning": "2mb",<br/>                  "maximumError": "5mb"<br/>                }<br/>              ]<br/>            }<br/>}</span></pre><h1 id="2e74" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">结构:</h1><h2 id="33a8" class="jo ir hi bd is jp jq jr iw js jt ju ja jv jw jx je jy jz ka ji kb kc kd jm ke bi translated">桶:</h2><p id="057f" class="pw-post-body-paragraph kf kg hi kh b ki kj kk kl km kn ko kp jv kq kr ks jy kt ku kv kb kw kx ky kz hb bi translated">为了组织我们的项目导入，我们将使用“桶”的概念，主要思想是将名为“index.ts”的文件添加到包含。ts文件。在它的内部，我们将把每个可导出变量导出到所有。ts文件以这种方式创建了一个隐藏的层次结构，这将有助于我们在导入时隐藏长而深的路径。</p><p id="b96d" class="pw-post-body-paragraph kf kg hi kh b ki ln kk kl km lo ko kp jv lp kr ks jy lq ku kv kb lr kx ky kz hb bi translated">示例:</p><p id="56e3" class="pw-post-body-paragraph kf kg hi kh b ki ln kk kl km lo ko kp jv lp kr ks jy lq ku kv kb lr kx ky kz hb bi translated">“组件”文件夹中的Index.ts</p><pre class="la lb lc ld fd le lf lg lh aw li bi"><span id="5376" class="jo ir hi lf b fi lj lk l ll lm">export * from './component-folder-1';<br/>export * from './component-folder-2';</span></pre><p id="977a" class="pw-post-body-paragraph kf kg hi kh b ki ln kk kl km lo ko kp jv lp kr ks jy lq ku kv kb lr kx ky kz hb bi translated">在模块中导入</p><pre class="la lb lc ld fd le lf lg lh aw li bi"><span id="7a75" class="jo ir hi lf b fi lj lk l ll lm">import { <br/>   Component1, <br/>   Component2, <br/>   Component3, <br/>   Component4 <br/>} from './component-folder';</span></pre><p id="3f4b" class="pw-post-body-paragraph kf kg hi kh b ki ln kk kl km lo ko kp jv lp kr ks jy lq ku kv kb lr kx ky kz hb bi translated">请检查index.ts文件中的组件数量是否多于导出的数量，发生这种情况是因为在我们导出的每个路径中，有更多的index.ts文件同时导出更多的路径。</p><p id="161e" class="pw-post-body-paragraph kf kg hi kh b ki ln kk kl km lo ko kp jv lp kr ks jy lq ku kv kb lr kx ky kz hb bi translated">正如您所看到的，这更清晰，同时也更容易实现，我们减少了导入文件所需的行数，并且缩短了路径。</p><h2 id="5b89" class="jo ir hi bd is jp jq jr iw js jt ju ja jv jw jx je jy jz ka ji kb kc kd jm ke bi translated">主要结构:</h2><p id="3cdb" class="pw-post-body-paragraph kf kg hi kh b ki kj kk kl km kn ko kp jv kq kr ks jy kt ku kv kb kw kx ky kz hb bi translated">除了app.module、app.component等。我们将为每个模块创建一个文件夹，在其中我们会发现以下结构:</p><figure class="la lb lc ld fd ij er es paragraph-image"><div class="er es ls"><img src="../Images/3de16c9f882309341c1d09b2f4b17e48.png" data-original-src="https://miro.medium.com/v2/resize:fit:1066/0*uAgAslbQ7pH-NtIo"/></div></figure><p id="87a4" class="pw-post-body-paragraph kf kg hi kh b ki ln kk kl km lo ko kp jv lp kr ks jy lq ku kv kb lr kx ky kz hb bi translated">主要思想是将逻辑按类别分开，每个模块包含它自己的，以加强模块的惰性加载的概念，其中每个模块将在需要时被加载，并且必须彼此独立。</p><p id="b6de" class="pw-post-body-paragraph kf kg hi kh b ki ln kk kl km lo ko kp jv lp kr ks jy lq ku kv kb lr kx ky kz hb bi translated">对于那些组件、服务等。我们需要一个以上的模块(例如:角材料模块)，我们将创建一个“共享模块”来导入和导出他们的应用程序。</p><p id="7e41" class="pw-post-body-paragraph kf kg hi kh b ki ln kk kl km lo ko kp jv lp kr ks jy lq ku kv kb lr kx ky kz hb bi translated">对于共享服务，我建议直接在app.module中实现它们，如果我们在共享模块中实现它们，我们将为它们中的每一个创建一个不同的服务实例，这样就不可能在整个应用程序中使用该服务进行通信。</p><h2 id="3ab5" class="jo ir hi bd is jp jq jr iw js jt ju ja jv jw jx je jy jz ka ji kb kc kd jm ke bi translated">核心服务:</h2><p id="5540" class="pw-post-body-paragraph kf kg hi kh b ki kj kk kl km kn ko kp jv kq kr ks jy kt ku kv kb kw kx ky kz hb bi translated">核心或实用程序服务文件是在app.module中实现的共享服务，包含可在整个应用程序中重用的所有方法。请记住，每个函数都必须是声明性的，没有副作用，并且必须随结果返回值，如果您需要修改参数，请使用它的值创建一个变量。</p><h2 id="9c2a" class="jo ir hi bd is jp jq jr iw js jt ju ja jv jw jx je jy jz ka ji kb kc kd jm ke bi translated">微调器实现:</h2><p id="b26c" class="pw-post-body-paragraph kf kg hi kh b ki kj kk kl km kn ko kp jv kq kr ks jy kt ku kv kb kw kx ky kz hb bi translated">我推荐使用observable来实现spinner，它可以接收一个布尔值来显示或隐藏它。</p><p id="a6de" class="pw-post-body-paragraph kf kg hi kh b ki ln kk kl km lo ko kp jv lp kr ks jy lq ku kv kb lr kx ky kz hb bi translated">core.service.ts</p><pre class="la lb lc ld fd le lf lg lh aw li bi"><span id="57c8" class="jo ir hi lf b fi lj lk l ll lm">import { Injectable } from '@angular/core';<br/>import { AbstractControl } from '@angular/forms';<br/>import { MatAutocomplete, MatAutocompleteSelectedEvent, MatChipInputEvent } from '@angular/material';<br/>import { Subject } from 'rxjs';<br/>export interface LoaderState {<br/>  show: boolean;<br/>}</span><span id="ea9e" class="jo ir hi lf b fi lt lk l ll lm">@Injectable({<br/>  providedIn: 'root'<br/>})<br/>export class CoreService {<br/>  spinnerStatusState = new Subject&lt;any&gt;();<br/></span><span id="d567" class="jo ir hi lf b fi lt lk l ll lm">  constructor() {}<br/></span><span id="5e2d" class="jo ir hi lf b fi lt lk l ll lm">  displaySpinner(value: boolean) {<br/>    this.spinnerStatusState.next(&lt;LoaderState&gt;{ show: value });<br/>  }<br/>}<br/>  }</span></pre><p id="2ce7" class="pw-post-body-paragraph kf kg hi kh b ki ln kk kl km lo ko kp jv lp kr ks jy lq ku kv kb lr kx ky kz hb bi translated">应用程序组件</p><pre class="la lb lc ld fd le lf lg lh aw li bi"><span id="67c7" class="jo ir hi lf b fi lj lk l ll lm">import { Component, ChangeDetectionStrategy, OnInit } from '@angular/core';<br/>import { CoreService } from './shared/services/core.service';<br/></span><span id="31bc" class="jo ir hi lf b fi lt lk l ll lm">@Component({<br/>  selector: 'app-root',<br/>  templateUrl: './app.component.html',<br/>  styleUrls: ['./app.component.scss']<br/>})<br/>export class AppComponent implements OnInit {<br/>  show = false;<br/></span><span id="c655" class="jo ir hi lf b fi lt lk l ll lm">  constructor(private coreService: CoreService) {}<br/></span><span id="ba88" class="jo ir hi lf b fi lt lk l ll lm">  ngOnInit() {<br/>    this.coreService.spinnerStatusState.subscribe(state =&gt; {<br/>      setTimeout(() =&gt; {<br/>        this.show = state.show;<br/>      }, 0);<br/>    });<br/>  }<br/>}</span></pre><p id="a02e" class="pw-post-body-paragraph kf kg hi kh b ki ln kk kl km lo ko kp jv lp kr ks jy lq ku kv kb lr kx ky kz hb bi translated">app.component.html</p><pre class="la lb lc ld fd le lf lg lh aw li bi"><span id="4ae7" class="jo ir hi lf b fi lj lk l ll lm">&lt;ng-container&gt;&lt;span *ngIf="show"&gt;&lt;app-spinner&gt;&lt;/app-spinner&gt;&lt;/span&gt;<br/>    &lt;app-navbar&gt; &lt;router-outlet&gt;&lt;/router-outlet&gt; &lt;/app-navbar&gt;<br/>&lt;/ng-container&gt;</span></pre><p id="0ff0" class="pw-post-body-paragraph kf kg hi kh b ki ln kk kl km lo ko kp jv lp kr ks jy lq ku kv kb lr kx ky kz hb bi translated">spinner.component.ts</p><pre class="la lb lc ld fd le lf lg lh aw li bi"><span id="6050" class="jo ir hi lf b fi lj lk l ll lm">import { Component, OnInit } from '@angular/core';<br/></span><span id="0289" class="jo ir hi lf b fi lt lk l ll lm">@Component({<br/>  selector: 'app-spinner',<br/>  template: `<br/>    &lt;div class="loading"&gt;&lt;/div&gt;<br/>  `,<br/>  styleUrls: ['./spinner.component.scss']<br/>})<br/>export class SpinnerComponent implements OnInit {<br/>  constructor() {}<br/></span><span id="b649" class="jo ir hi lf b fi lt lk l ll lm">  ngOnInit() {}<br/>}</span></pre><p id="048d" class="pw-post-body-paragraph kf kg hi kh b ki ln kk kl km lo ko kp jv lp kr ks jy lq ku kv kb lr kx ky kz hb bi translated">实现你的spinner scss来设计你自己的风格，或者用gif或其他文件替换模板。</p><p id="f5ce" class="pw-post-body-paragraph kf kg hi kh b ki ln kk kl km lo ko kp jv lp kr ks jy lq ku kv kb lr kx ky kz hb bi translated">如何使用它:</p><p id="73b7" class="pw-post-body-paragraph kf kg hi kh b ki ln kk kl km lo ko kp jv lp kr ks jy lq ku kv kb lr kx ky kz hb bi translated">在组件的构造函数中注入核心服务，在调用端点之前:</p><p id="bcf9" class="pw-post-body-paragraph kf kg hi kh b ki ln kk kl km lo ko kp jv lp kr ks jy lq ku kv kb lr kx ky kz hb bi translated">this . coreservice . display spinner(true)；</p><p id="937c" class="pw-post-body-paragraph kf kg hi kh b ki ln kk kl km lo ko kp jv lp kr ks jy lq ku kv kb lr kx ky kz hb bi translated">得到结果后，即使成功与否:</p><pre class="la lb lc ld fd le lf lg lh aw li bi"><span id="292f" class="jo ir hi lf b fi lj lk l ll lm">this.yourService.getInformation().subscribe(<br/>  response =&gt; {<br/>   ...<br/>   this.coreService.displaySpinner(false);<br/>  },<br/>  error =&gt; {<br/>   ...<br/>   this.coreService.displaySpinner(false);<br/>  }<br/>);</span></pre><h1 id="889e" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">可观察到的:</h1><p id="70be" class="pw-post-body-paragraph kf kg hi kh b ki kj kk kl km kn ko kp jv kq kr ks jy kt ku kv kb kw kx ky kz hb bi translated">结合可观测的！！在你的组件中，有时你会同时调用多个端点…与其订阅它们中的每一个，为什么不合并它们呢？。</p><p id="5870" class="pw-post-body-paragraph kf kg hi kh b ki ln kk kl km lo ko kp jv lp kr ks jy lq ku kv kb lr kx ky kz hb bi translated">我建议使用来自rxjs的combineLatest来做这件事，这样即使一些值没有出现，我们仍然要输入subscribe的结果或错误，当缺少的值出现时，我们将保留最后一个值。</p><pre class="la lb lc ld fd le lf lg lh aw li bi"><span id="9257" class="jo ir hi lf b fi lj lk l ll lm">import { combineLatest } from 'rxjs';</span><span id="9891" class="jo ir hi lf b fi lt lk l ll lm">...</span><span id="9d83" class="jo ir hi lf b fi lt lk l ll lm">ngOnInit() {<br/>  combineLatest(<br/>    this.yourService.getObservable1(),<br/>    this.yourService.getObservable2()<br/>  ).subscribe(<br/>    ([result1, result2]) = {<br/>      ...<br/>    }<br/>  ) <br/>}</span></pre><p id="ca57" class="pw-post-body-paragraph kf kg hi kh b ki ln kk kl km lo ko kp jv lp kr ks jy lq ku kv kb lr kx ky kz hb bi translated">这样我们可以更容易地在ngOnDestroy取消订阅:)</p><p id="0eee" class="pw-post-body-paragraph kf kg hi kh b ki ln kk kl km lo ko kp jv lp kr ks jy lq ku kv kb lr kx ky kz hb bi translated">呼叫端点推荐！！！！(在端点给出结果后，角度自动退订，但我认为这是一个很好的做法，仍然使用它来获得头脑中的良好做法)，如果您知道您的可观察对象将只从后面获得一次信息，请使用。pipe(first())在您订阅之前，这样它将获得信息并自动取消订阅。</p><pre class="la lb lc ld fd le lf lg lh aw li bi"><span id="4d30" class="jo ir hi lf b fi lj lk l ll lm">import { first } from 'rxjs/operators';</span><span id="444a" class="jo ir hi lf b fi lt lk l ll lm">...</span><span id="c592" class="jo ir hi lf b fi lt lk l ll lm">this.yourService.getObservable().pipe(first()).subscribe(...);</span></pre><h1 id="0cc7" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">应用程序状态的自定义管理:</h1><p id="04f9" class="pw-post-body-paragraph kf kg hi kh b ki kj kk kl km kn ko kp jv kq kr ks jy kt ku kv kb kw kx ky kz hb bi translated">我们建议使用工厂模式在旅途中创建、管理和销毁可观察对象！</p><p id="1875" class="pw-post-body-paragraph kf kg hi kh b ki ln kk kl km lo ko kp jv lp kr ks jy lq ku kv kb lr kx ky kz hb bi translated">为此，我创建了这个非常酷的共享服务，并与你分享:)</p><p id="4805" class="pw-post-body-paragraph kf kg hi kh b ki ln kk kl km lo ko kp jv lp kr ks jy lq ku kv kb lr kx ky kz hb bi translated">observable.service.ts</p><pre class="la lb lc ld fd le lf lg lh aw li bi"><span id="fb2b" class="jo ir hi lf b fi lj lk l ll lm">import { BehaviorSubject } from 'rxjs';<br/>import { Injectable } from '@angular/core';<br/></span><span id="df8d" class="jo ir hi lf b fi lt lk l ll lm">export interface ObserverArrayItem {<br/>  key: string;<br/>  observable: BehaviorSubject&lt;any&gt;;<br/>}<br/></span><span id="155d" class="jo ir hi lf b fi lt lk l ll lm">@Injectable({<br/>  providedIn: 'root'<br/>})<br/>export class ObservableService {<br/>  private observerArray: ObserverArrayItem[] = [];<br/></span><span id="6304" class="jo ir hi lf b fi lt lk l ll lm">  createObservable(key: string) {<br/>    const observable = new BehaviorSubject(null);<br/>    this.observerArray.push({ key, observable });<br/>  }<br/></span><span id="dd79" class="jo ir hi lf b fi lt lk l ll lm">  getObservable(key: string) {<br/>    const observableArrayItem = this.observerArray.find(obs =&gt; obs.key === key);<br/>    return observableArrayItem.observable;<br/>  }<br/></span><span id="f489" class="jo ir hi lf b fi lt lk l ll lm">  emitValue(key: string, data: any) {<br/>    const observableArrayItem = this.observerArray.find(obs =&gt; obs.key === key);<br/>    observableArrayItem.observable.next(data);<br/>  }<br/></span><span id="0b0b" class="jo ir hi lf b fi lt lk l ll lm">  destroyObservable(key: string) {<br/>    const selectedObservable = this.observerArray.find(obs =&gt; obs.key === key);<br/>    selectedObservable.observable.unsubscribe();<br/>    this.observerArray = this.observerArray.filter(obs =&gt; obs.key !== key);<br/>  }<br/>}</span></pre><p id="ccb7" class="pw-post-body-paragraph kf kg hi kh b ki ln kk kl km lo ko kp jv lp kr ks jy lq ku kv kb lr kx ky kz hb bi translated">如何使用:</p><p id="c5c1" class="pw-post-body-paragraph kf kg hi kh b ki ln kk kl km lo ko kp jv lp kr ks jy lq ku kv kb lr kx ky kz hb bi translated">将通过可观察对象发送数据的组件将负责创建和销毁数据:</p><p id="bb99" class="pw-post-body-paragraph kf kg hi kh b ki ln kk kl km lo ko kp jv lp kr ks jy lq ku kv kb lr kx ky kz hb bi translated">在您的组件上</p><pre class="la lb lc ld fd le lf lg lh aw li bi"><span id="7735" class="jo ir hi lf b fi lj lk l ll lm">export const NameOfYourObservable = 'observable1';<br/>...<br/>ngOnInit() {<br/>  this.observableService.createObservable(NameOfYourObservable);<br/>}</span><span id="c887" class="jo ir hi lf b fi lt lk l ll lm">...</span><span id="a91a" class="jo ir hi lf b fi lt lk l ll lm">// after getting the information</span><span id="3de3" class="jo ir hi lf b fi lt lk l ll lm">this.observableService.emitValue(NameOfYourObservable, 'Hi! im the information !!');<br/></span><span id="66ad" class="jo ir hi lf b fi lt lk l ll lm">// when we destroy our component<br/>ngOnDestroy() {<br/>  this.observableService.destroyObservable(NameOfYourObservable);<br/>}</span></pre><p id="aa81" class="pw-post-body-paragraph kf kg hi kh b ki ln kk kl km lo ko kp jv lp kr ks jy lq ku kv kb lr kx ky kz hb bi translated">为什么要在发出数据的组件上管理可观察的生命周期？？</p><p id="9293" class="pw-post-body-paragraph kf kg hi kh b ki ln kk kl km lo ko kp jv lp kr ks jy lq ku kv kb lr kx ky kz hb bi translated">因为如果发出数据的组件不在了…为什么要继续拥有一个不再有任何作用的可观察对象呢？:)</p><p id="671f" class="pw-post-body-paragraph kf kg hi kh b ki ln kk kl km lo ko kp jv lp kr ks jy lq ku kv kb lr kx ky kz hb bi translated">使用它的另一种方式是让组件的父组件创建和销毁可观察对象，这样我们可以放心，可观察对象将为其子组件做好准备，当父组件不在时，可观察对象也将准备好。</p><p id="f954" class="pw-post-body-paragraph kf kg hi kh b ki ln kk kl km lo ko kp jv lp kr ks jy lq ku kv kb lr kx ky kz hb bi translated">在您的订阅组件上</p><pre class="la lb lc ld fd le lf lg lh aw li bi"><span id="6744" class="jo ir hi lf b fi lj lk l ll lm">import { NameOfYourObservable } from './component-emitter-forlder';</span><span id="85ce" class="jo ir hi lf b fi lt lk l ll lm">...</span><span id="fd40" class="jo ir hi lf b fi lt lk l ll lm">ngOnInit() {<br/>  this.observableService(NameOfYourObservable).subscribe(...)<br/>}</span></pre><blockquote class="lu lv lw"><p id="bd0d" class="kf kg lx kh b ki ln kk kl km lo ko kp ly lp kr ks lz lq ku kv ma lr kx ky kz hb bi translated">就是这样！这些是我能给你的一些建议！！如果你喜欢它，请分享，我愿意回答问题。</p><p id="3eb5" class="kf kg lx kh b ki ln kk kl km lo ko kp ly lp kr ks lz lq ku kv ma lr kx ky kz hb bi translated"><em class="hi">我还想邀请你来我的前端社区过</em> <a class="ae mb" href="https://discord.gg/KEavKkDc5Y" rel="noopener ugc nofollow" target="_blank"> <em class="hi">不和</em> </a> <em class="hi">！我通过我的</em><a class="ae mb" href="https://www.youtube.com/watch?v=2jfIfeY4lrQ&amp;t=1006s&amp;ab_channel=GentlemanProgramming" rel="noopener ugc nofollow" target="_blank"><em class="hi">YouTube</em></a><em class="hi">频道进行指导和授课。</em></p><p id="5ce5" class="kf kg lx kh b ki ln kk kl km lo ko kp ly lp kr ks lz lq ku kv ma lr kx ky kz hb bi translated"><em class="hi">大家编码快乐！！</em></p></blockquote></div></div>    
</body>
</html>