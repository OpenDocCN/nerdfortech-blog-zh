<html>
<head>
<title>Top 3 Pandas Tricks I Wish I Knew Before</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">我希望我以前就知道的3大熊猫把戏</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/top-3-pandas-tricks-i-wish-i-knew-before-604cbe4166ea?source=collection_archive---------1-----------------------#2021-05-23">https://medium.com/nerd-for-tech/top-3-pandas-tricks-i-wish-i-knew-before-604cbe4166ea?source=collection_archive---------1-----------------------#2021-05-23</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="f5e1" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">关于熊猫一些有用功能的重要提示和技巧</h2></div><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ix"><img src="../Images/1f9e94e99c2f77189787268fe9d4f3e7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*dy90B9o6wSSybp--"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">Christopher Gower 在<a class="ae jn" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><p id="4b5c" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><strong class="jq hj"> Pandas </strong>是一个快速、强大、灵活且易于使用的开源数据分析和操作工具，构建于<a class="ae jn" href="https://www.python.org/" rel="noopener ugc nofollow" target="_blank"> Python </a>编程语言之上。</p><p id="62da" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">许多数据分析师和科学家一直在使用Python，并且通常在清理和预处理步骤中使用大量的Pandas。</p><p id="8c12" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">因此，我想到写这篇文章，因为我自己也努力寻找这些问题的解决方案，希望我以前知道如何解决它们。</p><h1 id="5950" class="kk kl hi bd km kn ko kp kq kr ks kt ku io kv ip kw ir kx is ky iu kz iv la lb bi translated">1.各组内的百分比</h1><p id="2f2c" class="pw-post-body-paragraph jo jp hi jq b jr lc ij jt ju ld im jw jx le jz ka kb lf kd ke kf lg kh ki kj hb bi translated">我遇到的最令人沮丧的事情之一是如何找到一个组中每个值的百分比。在翻了一遍关于堆栈溢出的答案，翻了一大堆文章之后，我找到了使用<code class="du lh li lj lk b">apply</code>和<code class="du lh li lj lk b">lambda</code>函数的解决方案。</p><p id="8871" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">考虑下面的数据框架:</p><pre class="iy iz ja jb fd ll lk lm ln aw lo bi"><span id="43af" class="lp kl hi lk b fi lq lr l ls lt">names = ['Hemant', 'John', 'ABC', 'XYZ', 'Hemant', 'John', 'Hemant', 'Hemant', 'John', 'ABC']</span><span id="3102" class="lp kl hi lk b fi lu lr l ls lt">cost = [9, 10, 1, 5, 2, 6, 4, 1, 12, 7]</span><span id="6f70" class="lp kl hi lk b fi lu lr l ls lt">df = pd.DataFrame({'Name': names, 'Order_Cost': cost})</span></pre><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es lv"><img src="../Images/0fb5388e47758de8e5f45cc610d5cecd.png" data-original-src="https://miro.medium.com/v2/resize:fit:462/format:webp/1*q1HRs19m8NNeZEe-iAgfCQ.jpeg"/></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">来源:作者图片</figcaption></figure><p id="7e98" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">现在，给定数据框架，我想找出一组中每一行的百分比，即每一项占总数的百分比。这可以使用下面的<code class="du lh li lj lk b">apply()</code>和<code class="du lh li lj lk b">lambda</code>命令来完成。</p><pre class="iy iz ja jb fd ll lk lm ln aw lo bi"><span id="a050" class="lp kl hi lk b fi lq lr l ls lt">perc_order_cost = df.groupby('Name')['Order_Cost'].apply(lambda x : x/x.sum()*100)</span><span id="f6cf" class="lp kl hi lk b fi lu lr l ls lt">df['perc_order_cost'] = perc_order_cost</span></pre><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es lw"><img src="../Images/cacf03a95744ac63c589fd763bef4845.png" data-original-src="https://miro.medium.com/v2/resize:fit:732/format:webp/1*p_oeVgga-RlxOkyYeeyNkA.jpeg"/></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">来源:作者图片</figcaption></figure><p id="5ac0" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">如你所见，我们首先按每个名字分组，即4个组，即<em class="lx">赫曼特、约翰、ABC、</em>和<em class="lx"> XYZ。</em>然后，我们对<em class="lx">订单成本</em>列应用lambda函数<code class="du lh li lj lk b"> x/x.sum()</code>，而不是汇总数据。例如，对于<strong class="jq hj"> <em class="lx">赫曼特</em> </strong>组，订单总成本为9 + 2 + 4 + 1 = 16。百分比分别计算为9/16 = 56%、2/16 = 12%、4/16 = 25%和1/16 = 6%。对于每一行(x ),它将除以该组的总和。</p><h1 id="b9be" class="kk kl hi bd km kn ko kp kq kr ks kt ku io kv ip kw ir kx is ky iu kz iv la lb bi translated">2.将一列词典转换成单独的列</h1><p id="39fb" class="pw-post-body-paragraph jo jp hi jq b jr lc ij jt ju ld im jw jx le jz ka kb lf kd ke kf lg kh ki kj hb bi translated">很多时候，尤其是在使用JSON时，您得到的数据可能在列中存储了字典。例如，<em class="lx">污染物</em>列有一个字典，其中有3个关键字，即<em class="lx"> a、b、</em>和<em class="lx"> c. </em></p><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es ly"><img src="../Images/0728809c1d5d4266c0b969465f4b69f6.png" data-original-src="https://miro.medium.com/v2/resize:fit:962/format:webp/1*VAe8FTkvJHU-J6lFn9zFFA.jpeg"/></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">来源:作者图片</figcaption></figure><p id="adc6" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">我们可以<em class="lx"> </em>使用<code class="du lh li lj lk b">pd.json_normalize()</code>和<code class="du lh li lj lk b">.apply(pd.Series)</code>两种方法将这个字典列转换成多个以关键字为头的列。让我们来看看下面的实际情况:</p><h2 id="8df1" class="lp kl hi bd km lz ma mb kq mc md me ku jx mf mg kw kb mh mi ky kf mj mk la ml bi translated">a)使用pd.json_normalize()</h2><pre class="iy iz ja jb fd ll lk lm ln aw lo bi"><span id="0b22" class="lp kl hi lk b fi lq lr l ls lt">pd.json_normalize(df['Pollutants'])</span></pre><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es mm"><img src="../Images/9be76ac03efdbacd23209671809b3049.png" data-original-src="https://miro.medium.com/v2/resize:fit:340/format:webp/1*NBARChq0hR_k1shzInEfAQ.jpeg"/></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">来源:作者图片</figcaption></figure><p id="21a6" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">如你所见，在<code class="du lh li lj lk b">json_normalize()</code>之后，凡是键不存在的地方，值都将是NaN，其他地方的值都将被相应地填充。</p><p id="5467" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">由于它返回一个数据帧，我们可以将它连接回原始数据帧。</p><pre class="iy iz ja jb fd ll lk lm ln aw lo bi"><span id="d26a" class="lp kl hi lk b fi lq lr l ls lt">pd.concat([df, pd.json_normalize(df['Pollutants'])], axis = 1)</span></pre><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es mn"><img src="../Images/7a22de424a12d840bd2dd3a014406cb7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1174/format:webp/1*1n7GKKpgDWcRvT2PPh7OIA.jpeg"/></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">来源:作者图片</figcaption></figure><h2 id="9f12" class="lp kl hi bd km lz ma mb kq mc md me ku jx mf mg kw kb mh mi ky kf mj mk la ml bi translated">b)使用。应用(pd。系列)</h2><pre class="iy iz ja jb fd ll lk lm ln aw lo bi"><span id="c77f" class="lp kl hi lk b fi lq lr l ls lt">df['Pollutants'].apply(pd.Series)</span></pre><p id="42b2" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">类似地，如果我们<em class="lx">对包含字典值的列应用</em>函数<code class="du lh li lj lk b">pd.Series</code>，也可以获得相同的结果。这将给出与上面相同的结果。</p><p id="ee25" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">将它添加到原始数据帧的另一种方式是以传统方式分配它，即选择与键的数量相等的列的数量。</p><pre class="iy iz ja jb fd ll lk lm ln aw lo bi"><span id="8ba1" class="lp kl hi lk b fi lq lr l ls lt">df[['a', 'b', 'c']] = df['Pollutants'].apply(pd.Series)</span></pre><h1 id="b8bf" class="kk kl hi bd km kn ko kp kq kr ks kt ku io kv ip kw ir kx is ky iu kz iv la lb bi translated">3.对时间序列数据进行分组和重采样</h1><p id="aaa5" class="pw-post-body-paragraph jo jp hi jq b jr lc ij jt ju ld im jw jx le jz ka kb lf kd ke kf lg kh ki kj hb bi translated">在对数据进行重采样后获得分组的意义上，重采样与分组非常相似。但是重采样用于DateTime数据类型。</p><p id="3097" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">然而，当对数据帧进行分组时，您是按可以是任何数据类型的某个列进行分组的。</p><p id="46a6" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">它可以是数据帧中的索引或任何列，但<code class="du lh li lj lk b">resample()</code>总是用于日期时间对象。此外，在大多数情况下，当处理时间序列数据时，您会将索引设置为DateTime列，因为这有助于简化分析。</p><p id="cab4" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">重采样的基础是你需要传递一个频率，比如D代表天，M代表月，等等。这些信息也可以在文档中找到。</p><p id="7a01" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">让我们看一个重采样如何工作的例子。考虑以下数据:</p><pre class="iy iz ja jb fd ll lk lm ln aw lo bi"><span id="072b" class="lp kl hi lk b fi lq lr l ls lt">dates = pd.date_range(start = '2021-05-01', end = '2021-05-31')</span><span id="6f54" class="lp kl hi lk b fi lu lr l ls lt">values = np.random.randint(100, size = 31)</span><span id="6cad" class="lp kl hi lk b fi lu lr l ls lt">df = pd.DataFrame({'date': dates, 'Value': values})</span><span id="aa86" class="lp kl hi lk b fi lu lr l ls lt">df.set_index('date', inplace=True)</span></pre><p id="e8c2" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">这给了我们一个有31天的数据帧和一些随机值用于<em class="lx">值</em>列。下面是数据的快照:</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es mo"><img src="../Images/631c3fc608dbc63034fba7140e904b9b.png" data-original-src="https://miro.medium.com/v2/resize:fit:780/format:webp/1*_smCp_Cu0A4tZ70M3eNS9Q.jpeg"/></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">来源:作者图片</figcaption></figure><h2 id="6c94" class="lp kl hi bd km lz ma mb kq mc md me ku jx mf mg kw kb mh mi ky kf mj mk la ml bi translated">a)对数据进行上采样</h2><p id="911a" class="pw-post-body-paragraph jo jp hi jq b jr lc ij jt ju ld im jw jx le jz ka kb lf kd ke kf lg kh ki kj hb bi translated">上采样是增加DateTime对象频率的过程，即您将较高的单位(如<em class="lx">年</em>)转换为较低的单位(如<em class="lx">天)。</em>例如，如果您每年都有定期数据，并且您想要月级别的数据，那么您可以传递月的频率，pandas将在每年的间隔之间插入每个月的值。</p><p id="5f70" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">假设我们想给所有的日子添加一些每小时的数据，我们可以通过每小时重新采样来做到这一点，只要值不存在，我们就会得到NaN值。</p><pre class="iy iz ja jb fd ll lk lm ln aw lo bi"><span id="8bbb" class="lp kl hi lk b fi lq lr l ls lt">hourly = df.resample('H').ffill()</span></pre><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es mp"><img src="../Images/e15f8eb928887c7670f1da3ba0b80966.png" data-original-src="https://miro.medium.com/v2/resize:fit:818/format:webp/1*_lQxrCIED45KNNPMOmR8zw.jpeg"/></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">来源:作者图片</figcaption></figure><p id="58cd" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">在这里，因为每天从00:00开始，所以我们插入每小时的时间间隔，并使用<code class="du lh li lj lk b">ffill()</code>填充数据集中的nan。通常，当你对数据进行上采样时，你会结束插值或填充NANs。</p><h2 id="5d23" class="lp kl hi bd km lz ma mb kq mc md me ku jx mf mg kw kb mh mi ky kf mj mk la ml bi translated">b)对数据进行下采样</h2><p id="c721" class="pw-post-body-paragraph jo jp hi jq b jr lc ij jt ju ld im jw jx le jz ka kb lf kd ke kf lg kh ki kj hb bi translated">下采样与上采样相反，应用某种聚合函数来降低频率，即从几天到几个月，并通过应用某种聚合函数将数据分组在一起。</p><p id="f45b" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">假设我们希望将每日数据缩减采样为每周数据，并获得每周平均值。</p><pre class="iy iz ja jb fd ll lk lm ln aw lo bi"><span id="bd0d" class="lp kl hi lk b fi lq lr l ls lt">weekly = df.resample('W').mean()</span></pre><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es mq"><img src="../Images/5c59fc792d530ba62820d970ff133d03.png" data-original-src="https://miro.medium.com/v2/resize:fit:612/format:webp/1*et2PzKlxX4k_0ogLpaNIhA.jpeg"/></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">来源:作者图片</figcaption></figure><p id="4c21" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">这里，我们每周对指数进行分组，并应用<code class="du lh li lj lk b">mean()</code>作为聚合函数。</p></div><div class="ab cl mr ms gp mt" role="separator"><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw"/></div><div class="hb hc hd he hf"><p id="cb77" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">这些是一些最常见的提示，我希望我以前就知道。我希望这能帮助你走出困境。</p><p id="a092" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">请随时给我同样的反馈。</p><p id="07e4" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">来打个招呼吧！在<a class="ae jn" href="https://twitter.com/hemantrattey" rel="noopener ugc nofollow" target="_blank">推特上给我</a>。</p></div></div>    
</body>
</html>