<html>
<head>
<title>Declarative UIKit? Why Not?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">声明式 UIKit？为什么不呢？</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/declarative-uikit-why-not-348e4532d1f9?source=collection_archive---------0-----------------------#2022-06-16">https://medium.com/nerd-for-tech/declarative-uikit-why-not-348e4532d1f9?source=collection_archive---------0-----------------------#2022-06-16</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div class="er es if"><img src="../Images/dd9883a54a75c3c186059f37d91c9bcc.png" data-original-src="https://miro.medium.com/v2/resize:fit:384/format:webp/1*PzI55dbXh6S3pnM03QrPVw.png"/></div></figure><p id="440b" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">我知道你们所有人都对新的 SwiftUI 感到兴奋。声明式方法比 UIKit 提供的任何方法都更好、更优雅。是的，UIKit 有故事板和 XIB，但那最终会成为 a**的痛。</p><h1 id="e629" class="jk jl hi bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">声明式 UIKit？</h1><p id="410f" class="pw-post-body-paragraph im in hi io b ip ki ir is it kj iv iw ix kk iz ja jb kl jd je jf km jh ji jj hb bi translated">是啊！我们仍然可以使用 UIKit，但是以声明的方式！你所需要做的就是使用<strong class="io hj">绘图员</strong>(是的这是我自己的库)作为 UIKit 声明式 UI 构建器。可以查看其<a class="ae kn" href="https://github.com/hainayanda/Draftsman" rel="noopener ugc nofollow" target="_blank"> <strong class="io hj"> <em class="ko"> Github 页面</em> </strong> </a>了解更多信息。</p><h1 id="0dc6" class="jk jl hi bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">让我们试试绘图员！</h1><p id="f319" class="pw-post-body-paragraph im in hi io b ip ki ir is it kj iv iw ix kk iz ja jb kl jd je jf km jh ji jj hb bi translated">让我们创建一个迷你项目来尝试这个库。我们的目标是用绘图员创建一个这样的简单用户界面:</p><figure class="kq kr ks kt fd ij er es paragraph-image"><div class="er es kp"><img src="../Images/f4a111f499f0df7dd96fe9857c39e460.png" data-original-src="https://miro.medium.com/v2/resize:fit:526/format:webp/1*uHkf0Ee-Sqy95og4nyr6EQ.png"/></div></figure><p id="91b0" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">确实非常简单。但是我们想要实现的不是一个复杂的 UI，而是证明我们可以使用 UIKit 使用声明式的方法。</p><p id="eaa1" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">让我们创建一个项目！</p><figure class="kq kr ks kt fd ij er es paragraph-image"><div role="button" tabindex="0" class="kv kw di kx bf ky"><div class="er es ku"><img src="../Images/322702a2caa6dfeb495ebbd0a4327445.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*np0BUevbrSsVAJZmfQun0A.png"/></div></div></figure><p id="1e49" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">别忘了加上绘图员作为它的依赖。您可以使用 Swift Package Manager 或 Cocoapods，您更喜欢哪个。在本例中，我使用的是 Swift Package Manager，因为它是现成的:</p><figure class="kq kr ks kt fd ij er es paragraph-image"><div role="button" tabindex="0" class="kv kw di kx bf ky"><div class="er es kz"><img src="../Images/103c8ac379320fa163eb5b13c7c7e734.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DFysPlniuWRa3m-_L_inTQ.png"/></div></div></figure><p id="a0ed" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">完成后，请查看一下新自动创建的 ViewController 类:</p><figure class="kq kr ks kt fd ij"><div class="bz dy l di"><div class="la lb l"/></div></figure><p id="b426" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">现在导入<strong class="io hj">绘图员</strong>并执行<strong class="io hj">计划的</strong>协议；</p><figure class="kq kr ks kt fd ij"><div class="bz dy l di"><div class="la lb l"/></div></figure><p id="4b0e" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">我们在这里做的是声明 ViewController 视图的子视图将在<strong class="io hj"> viewPlan </strong>属性中包含什么。不要忘记<strong class="io hj"> LayoutPlan </strong>属性，正是<em class="ko"> resultBuilder </em>实现使这种方法成为可能。<strong class="io hj"> applyPlan() </strong>然后将读取 viewPlan 声明并构建一个在那里声明的视图。我们将主要关注我们在视图计划中写的内容。</p><p id="4d23" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">现在让我们看看如果我们编译这个项目会发生什么:</p><figure class="kq kr ks kt fd ij er es paragraph-image"><div class="er es kp"><img src="../Images/8461e82c487eaa91cbbf1ebc0b64f6c8.png" data-original-src="https://miro.medium.com/v2/resize:fit:526/format:webp/1*F6vF9dsW6fCU4aBde1O3Yw.png"/></div><figcaption class="lc ld et er es le lf bd b be z dx translated">空白？</figcaption></figure><p id="9f71" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">不要慌，UILabel 其实是有的，只是大小为零，这就是原因。缺少的是 UILabel 约束。让我们在<strong class="io hj">视图计划</strong>中添加一个:</p><figure class="kq kr ks kt fd ij"><div class="bz dy l di"><div class="la lb l"/></div></figure><p id="c615" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">如您所见，您需要使用视图中的<strong class="io hj"> drf </strong>来提取兼容的锚。我们这里使用的<strong class="io hj">中心</strong>代表<em class="ko">中心锚</em>和<em class="ko">中心锚</em> <strong class="io hj">、</strong>，我们用来自其父节点的同一个锚来约束它。现在，如果你编译它，标签应该在屏幕的正中央:</p><figure class="kq kr ks kt fd ij er es paragraph-image"><div class="er es kp"><img src="../Images/9f26b7256ed413ae5e3f22f51272ec32.png" data-original-src="https://miro.medium.com/v2/resize:fit:526/format:webp/1*gSmwGX5RZBrBv_fSXGjm1w.png"/></div></figure><h1 id="b0a0" class="jk jl hi bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">使用 UIStackView</h1><p id="c6d5" class="pw-post-body-paragraph im in hi io b ip ki ir is it kj iv iw ix kk iz ja jb kl jd je jf km jh ji jj hb bi translated">嗯，如果你看到我们想要实现的，使用<strong class="io hj"> UIStackView </strong>会更容易，对吗？那我们就用一个:</p><figure class="kq kr ks kt fd ij"><div class="bz dy l di"><div class="la lb l"/></div></figure><p id="27d8" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">现在我们声明 UIStackView 及其约束。<strong class="io hj">横</strong>代表<em class="ko">左锚</em>和<em class="ko">右锚</em>，竖<strong class="io hj">代表<em class="ko">上锚</em>和<em class="ko">下锚</em>。现在为了确保它将使用<strong class="io hj">安全区域布局指南</strong>，我们用<strong class="io hj">安全区域</strong>对其进行了约束。</strong></p><p id="ea2b" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><strong class="io hj"> insertStacked </strong>等同于<strong class="io hj"> addArrangedSubview </strong>，因为现在 UILabel 是 ui stack view<em class="ko">arranged subviews</em>的一部分。由于现在 UILabel 约束由 UIStackView 管理，我们需要将其对齐设置为中心，使其居中。绘图员使用<a class="ae kn" href="https://github.com/hainayanda/Builder" rel="noopener ugc nofollow" target="_blank"> <strong class="io hj"> <em class="ko">构建器</em> </strong> </a>(是的，我自己的库也是)来启用开箱即用构建器模式的能力。你所需要做的就是在<strong class="io hj"> drf </strong>之后使用<strong class="io hj">构建器</strong>。</p><p id="dd6b" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">让我们继续构建 UIStackView 内容:</p><figure class="kq kr ks kt fd ij"><div class="bz dy l di"><div class="la lb l"/></div></figure><p id="7e31" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">myverylontext 是一个变量，应该是这样的:</p><figure class="kq kr ks kt fd ij"><div class="bz dy l di"><div class="la lb l"/></div></figure><p id="f00e" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">现在我们来编译:</p><figure class="kq kr ks kt fd ij er es paragraph-image"><div class="er es kp"><img src="../Images/fc2ac892d1a02ba1563ec82ff62bdc4c.png" data-original-src="https://miro.medium.com/v2/resize:fit:526/format:webp/1*j6rVvwwgD6QNiyFjPN-DmQ.png"/></div><figcaption class="lc ld et er es le lf bd b be z dx translated">不太对是吗？</figcaption></figure><p id="2d70" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">这个结果其实是意料之中的。这是因为我们的 UILabel 没有设置<strong class="io hj"> verticalCompression </strong>优先级，所以它压缩标签并截断其文本。修复很简单:</p><figure class="kq kr ks kt fd ij"><div class="bz dy l di"><div class="la lb l"/></div></figure><p id="2bc6" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">看起来不太好，是吗？我们实际上可以像这样将<strong class="io hj">视图计划</strong>组合成另一个<strong class="io hj">视图计划</strong>:</p><figure class="kq kr ks kt fd ij"><div class="bz dy l di"><div class="la lb l"/></div></figure><p id="0cc4" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">好多了，对吧？您可以使用 function 或 property getter 根据需要编写 ViewPlan。只是不要忘记在其上添加 LayoutPlan 属性。</p><p id="e5f1" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">正如你在代码中看到的，我在 UIStackView 的垂直和水平方向添加了<strong class="io hj"> offset(by: 24) </strong>。这将为视图的外部增加 24 的空间。如果你想增加内部空间，使用<strong class="io hj">插图(by:)。</strong></p><p id="5173" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">现在让我们编译一下，看看:</p><figure class="kq kr ks kt fd ij er es paragraph-image"><div class="er es kp"><img src="../Images/44ccc3f25c363fa91df29daf5d6602fd.png" data-original-src="https://miro.medium.com/v2/resize:fit:526/format:webp/1*OilkvBfhfoQ8OWdp9fjEFQ.png"/></div><figcaption class="lc ld et er es le lf bd b be z dx translated">快好了！</figcaption></figure><h1 id="1944" class="jk jl hi bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">UITextField 和键盘</h1><p id="452a" class="pw-post-body-paragraph im in hi io b ip ki ir is it kj iv iw ix kk iz ja jb kl jd je jf km jh ji jj hb bi translated">现在到最后一部分。我们将需要<strong class="io hj"> UITextField </strong>，当然，它将显示一个<strong class="io hj">键盘</strong>。添加 UITextField 是容易的部分，但是不要担心，受限于键盘也很容易！</p><p id="fc17" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">让我们先从 TextField 开始:</p><figure class="kq kr ks kt fd ij"><div class="bz dy l di"><div class="la lb l"/></div></figure><p id="b0f4" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">我们希望将 UIStackView 底部约束到 UITextField 容器的顶部，这就是为什么我们需要将它存储为一个变量，以便可以在 viewPlan 中使用。<em class="ko">自定义字段</em>被约束在视图的底部。一切看起来都很好，除了一件事。它忽略了键盘:</p><figure class="kq kr ks kt fd ij er es paragraph-image"><div class="er es kp"><img src="../Images/5929cd4be5b3f3a649d7ab184fd32595.png" data-original-src="https://miro.medium.com/v2/resize:fit:526/format:webp/1*SRtR-MCaGR3hpfuCeYbUGw.png"/></div><figcaption class="lc ld et er es le lf bd b be z dx translated">不好吗？</figcaption></figure><p id="ba86" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">幸运的是，你可以随时使用键盘锚作为约束，即使你支持的是一个旧的 iOS 版本，因为它是由<a class="ae kn" href="https://github.com/hainayanda/Clavier" rel="noopener ugc nofollow" target="_blank"><strong class="io hj"><em class="ko"/></strong></a>(再次，这也是我的)。我们来补充一下:</p><figure class="kq kr ks kt fd ij"><div class="bz dy l di"><div class="la lb l"/></div></figure><p id="7c3b" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">现在应该完成了，但是我们总是可以让<em class="ko">自定义字段</em>成为它自己的独立视图组件，以防它被其他组件使用。要定制一个<strong class="io hj"> UIView </strong>，你需要做的只是创建一个扩展任何 UIView 的类，并实现<strong class="io hj">计划的</strong>，就像之前一样:</p><figure class="kq kr ks kt fd ij"><div class="bz dy l di"><div class="la lb l"/></div></figure><p id="ccd3" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">然后它可以在我们的<strong class="io hj">视图控制器</strong>中用作<strong class="io hj">自定义字段</strong>:</p><figure class="kq kr ks kt fd ij"><div class="bz dy l di"><div class="la lb l"/></div></figure><p id="a17e" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">我们来编译一下，看看:</p><figure class="kq kr ks kt fd ij er es paragraph-image"><div class="er es lg"><img src="../Images/6616e4e056bacfc50be9b6382087bf71.png" data-original-src="https://miro.medium.com/v2/resize:fit:1052/format:webp/1*h8P2keci8WcSfU4Sky3cSw.jpeg"/></div><figcaption class="lc ld et er es le lf bd b be z dx translated">耶！</figcaption></figure><p id="bac6" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">你做到了！您可以使用 UIKit 的声明性方法创建一个简单的应用程序！让我们回顾一下完成的 ViewController 代码:</p><figure class="kq kr ks kt fd ij"><div class="bz dy l di"><div class="la lb l"/></div></figure><p id="4fa8" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">你可以在这个仓库中克隆这个例子-&gt;<a class="ae kn" href="https://github.com/hainayanda/DeclarativeUIKitExample" rel="noopener ugc nofollow" target="_blank"><strong class="io hj"><em class="ko">DeclarativeUIKitExample</em></strong></a></p><h1 id="7fcc" class="jk jl hi bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">最终注释</h1><p id="66b1" class="pw-post-body-paragraph im in hi io b ip ki ir is it kj iv iw ix kk iz ja jb kl jd je jf km jh ji jj hb bi translated">如果你错过了起草人的知识库链接，这里就是-&gt; <a class="ae kn" href="https://github.com/hainayanda/Draftsman" rel="noopener ugc nofollow" target="_blank"> <strong class="io hj"> <em class="ko">起草人</em> </strong> </a>。这只是声明式 UIKit 的第 1 部分。第 2 部分将讨论如何在这里添加一个反应式方法，最后一部分我们将据此创建一个完整的 MVVM 架构。</p></div></div>    
</body>
</html>