<html>
<head>
<title>Swift Leetcode Series: Flatten Binary Tree to Linked List</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Swift Leetcode 系列:将二叉树扁平化为链表</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/swift-leetcode-series-flatten-binary-tree-to-linked-list-6049f114f51f?source=collection_archive---------20-----------------------#2021-05-15">https://medium.com/nerd-for-tech/swift-leetcode-series-flatten-binary-tree-to-linked-list-6049f114f51f?source=collection_archive---------20-----------------------#2021-05-15</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="b750" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated"><strong class="ak"> Swift +二叉树+链表= Leetcode 114 ✅✅✅ </strong></h2></div><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ix"><img src="../Images/ad9f090fe4262f16624e63d22d447b8a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZmvElcNcQefpZJvb_5uS2g.png"/></div></div></figure><div class="jj jk ez fb jl jm"><a href="https://theswiftnerd.com/flatten-binary-tree-to-linked-list/" rel="noopener  ugc nofollow" target="_blank"><div class="jn ab dw"><div class="jo ab jp cl cj jq"><h2 class="bd hj fi z dy jr ea eb js ed ef hh bi translated">将二叉树展平为链表(Leetcode 114)</h2><div class="jt l"><h3 class="bd b fi z dy jr ea eb js ed ef dx translated">给定一棵二叉树的根，把树展平成一个“链表”。“链表”应该使用相同的 TreeNode…</h3></div><div class="ju l"><p class="bd b fp z dy jr ea eb js ed ef dx translated">theswiftnerd.com</p></div></div><div class="jv l"><div class="jw l jx jy jz jv ka jh jm"/></div></div></a></div><p id="ded9" class="pw-post-body-paragraph kb kc hi kd b ke kf ij kg kh ki im kj kk kl km kn ko kp kq kr ks kt ku kv kw hb bi translated">点击上面的链接查看 Swift Nerd 博客上的完整故事。</p><h1 id="1e23" class="kx ky hi bd kz la lb lc ld le lf lg lh io li ip lj ir lk is ll iu lm iv ln lo bi translated">问题描述</h1><p id="05c9" class="pw-post-body-paragraph kb kc hi kd b ke lp ij kg kh lq im kj kk lr km kn ko ls kq kr ks lt ku kv kw hb bi translated">给定一棵二叉树的<code class="du lu lv lw lx b">root</code>，将该树展平成一个“链表”:</p><ul class=""><li id="0d1a" class="ly lz hi kd b ke kf kh ki kk ma ko mb ks mc kw md me mf mg bi translated">“链表”应该使用相同的<code class="du lu lv lw lx b">TreeNode</code>类，其中<code class="du lu lv lw lx b">right</code>子指针指向列表中的下一个节点，而<code class="du lu lv lw lx b">left</code>子指针总是<code class="du lu lv lw lx b">null</code>。</li><li id="ba89" class="ly lz hi kd b ke mh kh mi kk mj ko mk ks ml kw md me mf mg bi translated">“链表”的顺序应该与二叉树的<a class="ae mm" href="https://en.wikipedia.org/wiki/Tree_traversal#Pre-order,_NLR" rel="noopener ugc nofollow" target="_blank"> <strong class="kd hj">前序遍历</strong> </a>相同。</li></ul><h1 id="cd01" class="kx ky hi bd kz la lb lc ld le lf lg lh io li ip lj ir lk is ll iu lm iv ln lo bi translated">例子</h1><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es mn"><img src="../Images/a3dd89dd60353d3de0fbe28a9322e7ba.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*5a0Yh4MdtJnmYcS0.jpg"/></div></div></figure><pre class="iy iz ja jb fd mo lx mp mq aw mr bi"><span id="14ee" class="ms ky hi lx b fi mt mu l mv mw"><strong class="lx hj">Input:</strong> root = [1,2,5,3,4,null,6]<br/><strong class="lx hj">Output:</strong> [1,null,2,null,3,null,4,null,5,null,6]</span><span id="d12f" class="ms ky hi lx b fi mx mu l mv mw"><strong class="lx hj">Input:</strong> root = []<br/><strong class="lx hj">Output:</strong> []</span><span id="772f" class="ms ky hi lx b fi mx mu l mv mw"><strong class="lx hj">Input:</strong> root = [0]<br/><strong class="lx hj">Output:</strong> [0]</span></pre><h1 id="4415" class="kx ky hi bd kz la lb lc ld le lf lg lh io li ip lj ir lk is ll iu lm iv ln lo bi translated">限制</h1><ul class=""><li id="df7f" class="ly lz hi kd b ke lp kh lq kk my ko mz ks na kw md me mf mg bi translated">树中的节点数在范围<code class="du lu lv lw lx b">[0, 2000]</code>内。</li><li id="6af0" class="ly lz hi kd b ke mh kh mi kk mj ko mk ks ml kw md me mf mg bi translated"><code class="du lu lv lw lx b">-100 &lt;= Node.val &lt;= 100</code></li></ul><p id="ec5a" class="pw-post-body-paragraph kb kc hi kd b ke kf ij kg kh ki im kj kk kl km kn ko kp kq kr ks kt ku kv kw hb bi translated"><strong class="kd hj">跟进:</strong>你能原地把树放平吗(有<code class="du lu lv lw lx b">O(1)</code>额外空间)？</p><h1 id="0d20" class="kx ky hi bd kz la lb lc ld le lf lg lh io li ip lj ir lk is ll iu lm iv ln lo bi translated">解决办法</h1><p id="7bfc" class="pw-post-body-paragraph kb kc hi kd b ke lp ij kg kh lq im kj kk lr km kn ko ls kq kr ks lt ku kv kw hb bi translated">我们可以直观地想到一种递归方法来遍历预排序方法中的列表，并递归地将左右子树转换为偏斜树。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es nb"><img src="../Images/a958b7dafbd62bd9e9430e020ad52135.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*lHVhseUDTTEAx-75.png"/></div></div></figure><p id="1207" class="pw-post-body-paragraph kb kc hi kd b ke kf ij kg kh ki im kj kk kl km kn ko kp kq kr ks kt ku kv kw hb bi translated">递归求解左右子树后，我们需要做的就是修正一些关于房间的指针。这种递归将自下而上移动，当根节点被处理时，我们确信我们已经转换了左边和右边的子树。现在保留一个指针来遍历左边子树中最右边的节点(这是连接右边子树作为 tail 所需要的)。当我们到达左子树中的终端节点时，只需将左子树设置为根的右子树，并将原始的右子树与终端左节点的右子树连接起来。</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="nc nd l"/></div></figure><h1 id="4c53" class="kx ky hi bd kz la lb lc ld le lf lg lh io li ip lj ir lk is ll iu lm iv ln lo bi translated">追问:O(1)空间？</h1><p id="7516" class="pw-post-body-paragraph kb kc hi kd b ke lp ij kg kh lq im kj kk lr km kn ko ls kq kr ks lt ku kv kw hb bi translated">关注<a class="ae mm" href="https://theswiftnerd.com/flatten-binary-tree-to-linked-list/" rel="noopener ugc nofollow" target="_blank">博客</a>了解优化的解决方案。</p><h1 id="e2e0" class="kx ky hi bd kz la lb lc ld le lf lg lh io li ip lj ir lk is ll iu lm iv ln lo bi translated">复杂性分析</h1><p id="3487" class="pw-post-body-paragraph kb kc hi kd b ke lp ij kg kh lq im kj kk lr km kn ko ls kq kr ks lt ku kv kw hb bi translated"><strong class="kd hj">时间= O(N) </strong></p><p id="49ec" class="pw-post-body-paragraph kb kc hi kd b ke kf ij kg kh ki im kj kk kl km kn ko kp kq kr ks kt ku kv kw hb bi translated"><strong class="kd hj"> Space = O(N </strong> ) ( <em class="ne">用于递归的堆栈空间</em>)。</p></div><div class="ab cl nf ng gp nh" role="separator"><span class="ni bw bk nj nk nl"/><span class="ni bw bk nj nk nl"/><span class="ni bw bk nj nk"/></div><div class="hb hc hd he hf"><p id="031b" class="pw-post-body-paragraph kb kc hi kd b ke kf ij kg kh ki im kj kk kl km kn ko kp kq kr ks kt ku kv kw hb bi translated">感谢您的阅读。如果你喜欢这篇文章，并发现它很有用，请分享并像野火一样传播它！</p><p id="ea5c" class="pw-post-body-paragraph kb kc hi kd b ke kf ij kg kh ki im kj kk kl km kn ko kp kq kr ks kt ku kv kw hb bi translated">你可以在<a class="ae mm" href="https://theswiftnerd.com/" rel="noopener ugc nofollow" target="_blank">the swift nerd</a>|<a class="ae mm" href="https://www.linkedin.com/in/varunrathi28/" rel="noopener ugc nofollow" target="_blank">LinkedIn</a>|<a class="ae mm" href="https://github.com/varunrathi28" rel="noopener ugc nofollow" target="_blank">Github</a>上找到我</p></div></div>    
</body>
</html>