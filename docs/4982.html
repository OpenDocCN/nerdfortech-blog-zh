<html>
<head>
<title>DETECTION OF FRAUDULENT TRANSACTION-CREDIT CARD</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">欺诈交易的检测-信用卡</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/credit-card-detection-of-fraudulent-transaction-d833b8a49926?source=collection_archive---------6-----------------------#2021-08-18">https://medium.com/nerd-for-tech/credit-card-detection-of-fraudulent-transaction-d833b8a49926?source=collection_archive---------6-----------------------#2021-08-18</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><a href="https://medium.com/p/d833b8a49926/edit"><div class="er es if"><img src="../Images/e8923fe61ac4b749faf0744aefcc53d5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*I9HV9CyhYQVQVTbeZS9tKA.jpeg"/></div></a></figure><p id="244b" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">在本文中，我们将建立一个有监督的机器学习模型来检测信用卡欺诈。这里使用的数据可以在 Kaggles 网站上公开获得。该数据集具有适当定义的要素和标注。首先设置环境——我们需要在 Google Colab 中打开一个 Jupyter 笔记本。下一步是安装/导入基本库(包)，如<strong class="io hj"> pandas </strong>、<strong class="io hj"> numpy </strong>、<strong class="io hj"> matplotlib </strong>，分别用于操纵数据帧、进行数学运算和绘制图形。为此要执行的代码如下所示</p><p id="7863" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><strong class="io hj"> <em class="jk">导入熊猫为 pd </em> </strong></p><p id="ba5c" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><strong class="io hj"> <em class="jk">导入 numpy 为 np </em> </strong></p><p id="d84a" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><strong class="io hj"> <em class="jk">导入 matplotlib.pyplot 为 plt </em> </strong></p><p id="f9e1" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><strong class="io hj"><em class="jk">% matplotlib inline</em>T21】</strong></p><p id="3a6d" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">下一步是加载数据集并使用该数据集创建数据框。在 python 中，将数据集加载到 Jupyter Notebook 的方法不止一种。我们将使用 pandas 从<strong class="io hj"> url </strong>路径加载数据集。一旦数据被导入到我们的 Jupyter 笔记本中，下一步将是分析数据集，并使用由此获得的洞察力来解决问题。这将通过可视化表中的数据集(<strong class="io hj"> df.head() </strong>)来实现，也通过确定关于数据集的信息(<strong class="io hj"> df.info()和 df.shape </strong>)来实现，该信息将给出列索引名称以及列的属性以及数据集中存在多少空值。将确定作为标签的最后一列(类)的数据类型是整数，如果交易是欺诈性的，则具有值“1 ”,如果是合法的，则具有值“0”。最后一列被转换为“类别”类型。为所有这些执行的命令如下:-</p><p id="4f86" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><strong class="io hj"><em class="jk">URL = ' https://raw . githubusercontent . com/nsethi 31/ka ggle-Data-Credit-Card-Fraud-Detection/master/Credit Card . CSV '</em></strong></p><p id="1060" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><strong class="io hj"><em class="jk">df = PD . read _ CSV(URL)</em></strong></p><p id="39b7" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><strong class="io hj"> <em class="jk"> df.head(2) </em> </strong></p><p id="7553" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><strong class="io hj"><em class="jk">df . shape</em>T43】</strong></p><p id="8fd7" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><strong class="io hj"> <em class="jk"> df.info() </em> </strong></p><p id="be69" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><strong class="io hj"> <em class="jk"> df。class . value _ counts()</em></strong><em class="jk">#数据不平衡 Nonfraud= 284315，fraud= 492 </em></p><p id="f965" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><strong class="io hj"> <em class="jk"> df['类']= df['类']。astype('category') </em> </strong></p><p id="b32f" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">“数量”列的值与其他列的值相差很大，如果不进行标准化就使用，会导致其他列在回归模型中的贡献减少到可以忽略不计。为了调节/缩放 Amount 列的值，我们可以导入并使用函数<strong class="io hj"> StandardScaling </strong>。然而，在当前情况下，我们只需要标准化一列，即介于 0 和 1 之间的数量值。我们将通过执行下面给出的命令来实现这一点</p><p id="8cce" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><strong class="io hj"> <em class="jk"> a，b = 0，</em>1</strong></p><p id="1c7f" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><strong class="io hj"> <em class="jk"> c，d = X.Amount.min()，X.Amount.max() </em> </strong></p><p id="17bb" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><strong class="io hj"> <em class="jk"> X['金额'] = (X .金额— c) / (d — c) * (b — a) + a </em> </strong></p><p id="89da" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><strong class="io hj"> <em class="jk"> X.head(5) </em> </strong></p><p id="9583" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">接下来，我们需要将数据集分为特征(在 ML 模型中用作输入的列)和标签(这将表明交易是欺诈性的还是合法的)。分离特征和标签后，下一步是使用从<strong class="io hj"> sklearn </strong>包导入的<strong class="io hj"> test_train_split </strong>函数将数据集(<strong class="io hj">特征(X) </strong>和<strong class="io hj">标签(y </strong>))划分为训练和测试数据集。训练数据集将用于训练机器学习模型，其中机器学习模型尚未看到的测试数据集稍后将用于验证它。上述步骤通过执行下面给出的命令来实现:-</p><p id="fb71" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><strong class="io hj"><em class="jk">features _ columns = df . columns[:-1]</em></strong></p><p id="f7ea" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><strong class="io hj"><em class="jk">X = df【features _ columns】</em></strong></p><p id="b1e2" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><strong class="io hj"><em class="jk">y = df[' Class ']</em></strong></p><p id="cde4" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><strong class="io hj"><em class="jk">from sk learn . model _ selection 导入 train_test_split </em> </strong></p><p id="98e7" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><strong class="io hj">T43【train _ X，test_X，train_y，test_y= train_test_split(X，y，train_size= 0.80，random _ state = 14)T45】</strong></p><p id="7633" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">在分析过程中，我们已经确定数据集是不平衡的，这基本上意味着欺诈交易微乎其微。因此，这个数据集不会给我们提供想要的结果。因此，我们将人工创建模拟数据集，以平衡数据集中的合法交易和欺诈交易。这将通过导入 SMOTE 函数并通过执行下面给出的命令将其应用于训练数据集来实现</p><p id="7aa2" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">#平衡列车数据</p><p id="3437" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><strong class="io hj"> <em class="jk">从 imblearn.over_sampling 导入 SMOTE </em> </strong></p><p id="2d51" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><strong class="io hj"><em class="jk">SMOTE = SMOTE(random _ state = 14)</em></strong></p><p id="6527" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><strong class="io hj"> <em class="jk">重采样 _X，重采样 _ y = smote.fit _ 重采样(train_X，train_y) </em> </strong></p><p id="eb75" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">数据集现在准备好了。我们将把<strong class="io hj"> LogisticRegression </strong>模型导入到笔记本中，并通过传递训练数据集(<strong class="io hj">重采样 _X </strong>和<strong class="io hj">重采样 _y </strong>)来训练该模型。该模型一旦被训练，就可以用于预测交易是合法的还是欺诈的。训练模型之前没有看到的测试数据现在将用于验证模型的有效性。</p><p id="f994" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><strong class="io hj"><em class="jk">from sk learn . linear _ model 导入 LogisticRegression </em> </strong></p><p id="926e" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><strong class="io hj"><em class="jk">lr = LogisticRegression(random _ state = 14，max_iter= 200) </em> </strong></p><p id="11ee" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><strong class="io hj"> <em class="jk"> lr.fit(重采样 _X，重采样 _y) </em> </strong></p><p id="1c2d" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><strong class="io hj"><em class="jk">y _ predict = lr . predict(test _ X)#</em></strong><em class="jk">这是预测</em></p><p id="b2e5" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">当我们将测试数据传递到模型中时，它会生成一个数组，该数组基本上是一个 0/1 的输出，表明它是一个欺诈/不是一个欺诈(合法)交易。此外，我们现在将从指标模块导入某些功能，这将有助于我们检查模型的有效性。这些指标是<strong class="io hj">混淆矩阵</strong>——这个矩阵提供了我们分类模型细节的更好的洞察力。一个好的混淆矩阵在对角线上有大的值，在对角线外有小的值。此外，我们还将使用<strong class="io hj">准确度分数，该分数</strong>实际上暗示了我们的模型在预测正确类别(标签)方面有多好。</p><p id="f33f" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><strong class="io hj"> <em class="jk"> from sklearn.metrics 导入混淆 _ 矩阵，准确度 _ 得分，精确度 _ 得分，召回 _ 得分，roc _ auc _ 得分</em> </strong></p><p id="8a57" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><strong class="io hj"> <em class="jk">【混淆 _ 矩阵(测试 _y，y _ 预测)】</em> </strong></p><p id="82b8" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><strong class="io hj"> <em class="jk"> tn，fn，fp，tp =混淆 _ 矩阵(test_y，y_predict)。</em>ravel()</strong></p><p id="9f9c" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><strong class="io hj"> <em class="jk">打印(' true_negative:'，tn) # </em> </strong> 56004</p><p id="67da" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><strong class="io hj"> <em class="jk">打印(' false_negative:'，fn) # </em> </strong> 860</p><p id="44bb" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><strong class="io hj"> <em class="jk">打印(' false_positive:'，fp) #9 </em> </strong></p><p id="0fd2" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><strong class="io hj"> <em class="jk">打印(' True_positive:'，tp) # </em> </strong> 89</p><p id="68c5" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><strong class="io hj"><em class="jk">print(round(accuracy _ score(test _ y，y_predict)，2)) # </em> </strong> 0.98</p><p id="89ea" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">我们还创建了一个 roc_auc_curve 用于可视化描述，以总结分类器在所有可能的概率阈值上的性能。这些将通过执行以下命令来实现:-</p><p id="9e7e" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><strong class="io hj"> <em class="jk">从 sklearn.metrics 导入 plot_roc_curve </em> </strong></p><p id="b338" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><strong class="io hj"> <em class="jk"> plot_roc_curve(lr，test_X，test _ y)；</em> </strong></p><p id="154d" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><strong class="io hj"><em class="jk">print(' ROC 曲线下面积: '，roc_auc_score(test_y，lr.predict_proba(test_X)[:，1])</em></strong></p><figure class="jm jn jo jp fd ij er es paragraph-image"><div class="er es jl"><img src="../Images/008045ce868e99ec2d01da4ca28439db.png" data-original-src="https://miro.medium.com/v2/resize:fit:772/format:webp/1*ZCZnExy2OX_SeWqnWuP_nA.png"/></div></figure><p id="53ab" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">最后，为了验证，我们将通过模型传递特征(X)的整个数据集。我们将通过连接 X( <strong class="io hj">原始要素数据集</strong>)、y( <strong class="io hj">原始标注</strong>)和预测 y( <strong class="io hj">预测标注</strong>)来创建一个新的数据框架。该数据集已导出为 csv 文件，可用于分析模型在进行预测时的有效性。</p><p id="71f8" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><strong class="io hj"><em class="jk">Predicted _ Class = lr . predict(X)</em></strong></p><p id="e837" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><strong class="io hj"> <em class="jk"> df_1 = pd。DataFrame(预测类，列=['预测类']) </em> </strong></p><p id="394d" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><strong class="io hj"> <em class="jk"> result =pd.concat([X，y，df_1]，轴=1) </em> </strong></p><p id="3ce1" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><strong class="io hj"><em class="jk"/></strong></p><p id="8cea" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><strong class="io hj"><em class="jk">result . to _ CSV(' Final _ predictions . CSV ')</em></strong></p><p id="c7ec" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><strong class="io hj"> #需要给出保存 Final_Predictions.csv 的路径</strong></p><figure class="jm jn jo jp fd ij er es paragraph-image"><div role="button" tabindex="0" class="jq jr di js bf jt"><div class="er es if"><img src="../Images/e8923fe61ac4b749faf0744aefcc53d5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*I9HV9CyhYQVQVTbeZS9tKA.jpeg"/></div></div></figure><h1 id="ab67" class="ju jv hi bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated"><strong class="ak">参考文献</strong></h1><p id="2a50" class="pw-post-body-paragraph im in hi io b ip ks ir is it kt iv iw ix ku iz ja jb kv jd je jf kw jh ji jj hb bi translated"><strong class="io hj">数据集已从 ka ggle-</strong><a class="ae kx" href="https://www.kaggle.com/mlg-ulb/creditcardfraud" rel="noopener ugc nofollow" target="_blank"><strong class="io hj">https://www.kaggle.com/mlg-ulb/creditcardfraud</strong></a>获得</p><p id="fc0c" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">应用从<strong class="io hj"> TalentEdge </strong>平台的<strong class="io hj">财务分析</strong>课程中获得的知识</p></div></div>    
</body>
</html>