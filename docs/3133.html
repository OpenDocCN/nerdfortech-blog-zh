<html>
<head>
<title>Buffer Overflow Attacks</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">缓冲区溢出攻击</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/buffer-overflow-attacks-b5e62a522e6e?source=collection_archive---------10-----------------------#2021-05-30">https://medium.com/nerd-for-tech/buffer-overflow-attacks-b5e62a522e6e?source=collection_archive---------10-----------------------#2021-05-30</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="800a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">用简单的例子理解缓冲区溢出攻击</p><p id="b7a1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">什么是缓冲？</strong></p><p id="191c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在计算机内存中，缓冲区是一个固定大小的临时存储区域。它可以用于在上下文切换时存储数据，或者临时存储用户输入，直到它被传输到专用的存储区域。</p><p id="ae12" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">什么是缓冲区溢出？</strong></p><p id="09f5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">当程序试图向缓冲区写入超过缓冲区大小的数据量时，这是一种不寻常的行为。因此，缓冲区的相邻存储位置被覆盖。这种异常称为缓冲区溢出。</p><p id="3c1f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">缓冲区溢出的类型</strong></p><p id="d72f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">通常会发生三种类型的缓冲区溢出。它们如下所示:</p><p id="82ad" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">1基于堆栈的缓冲区溢出</p><p id="1411" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">2基于堆的缓冲区溢出</p><p id="7cc8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">3全局缓冲区溢出</p><blockquote class="jd je jf"><p id="08f5" class="if ig jg ih b ii ij ik il im in io ip jh ir is it ji iv iw ix jj iz ja jb jc hb bi translated">注意:在这里，我们将考虑非常简单的程序来理解3种类型的缓冲区溢出攻击，实际上攻击可能会有所不同。要理解实际的缓冲区溢出，需要了解寄存器及其操作方式。</p></blockquote><p id="e6a2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">基于堆栈的缓冲区溢出</strong></p><p id="180b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们将考虑用C语言来演示这种攻击。C中有几个易受缓冲区溢出攻击的内置函数，如gets()、strcpy()。gets()用于获取用户输入，strcpy()用于将一个字符串复制到另一个字符串。gets()函数在接受用户输入时不检查数组边界，而只是接受用户输入的所有输入字符，与strcpy()函数检查数组边界并只是将一个字符串复制到另一个字符串的方式相同。这可能导致缓冲区溢出。下面的C程序演示了同样的情况。在下面给出的C代码中，一个大小为3的变量字符串被声明并初始化为9，另一个大小为4的变量缓冲区被声明并初始化为空字符串。在输出中可以观察到，string和buffer具有相邻的内存区域，这使得它容易受到缓冲区溢出攻击。获取(缓冲区)；用于接收用户的输入。恶意攻击者为了利用此漏洞，会输入超过缓冲区所能容纳的大小的输入，如输入大小为6 (&gt;4)的输出所示，这会导致缓冲区溢出和字符串中的数据被覆盖。可以观察到，字符串中的数据已被更改为ck。这是因为输入“attack”的大小是6，缓冲区的大小是4，所以输入“attack”的最后2个字符会溢出并被复制到string。</p><pre class="jk jl jm jn fd jo jp jq jr aw js bi"><span id="508c" class="jt ju hi jp b fi jv jw l jx jy">include&lt;stdio.h&gt;<br/>#include&lt;string.h&gt;<br/><strong class="jp hj">int</strong> main()<br/>{<br/> <strong class="jp hj">char</strong> string[3] = "9";<br/> <strong class="jp hj">char</strong> buffer[4] = " ";<br/> printf("Buffer[4] Memory Allocation: \n");<br/> <strong class="jp hj">for</strong>(<strong class="jp hj">int</strong> i=0;i&lt;4;i++)<br/> {<br/> printf("%d %u\n",i,&amp;buffer[i]);<br/> }<br/> printf("\nString[3] Memory Allocation: \n");<br/> <strong class="jp hj">for</strong>(<strong class="jp hj">int</strong> i=0;i&lt;3;i++)<br/> {<br/> printf("%d %u\n",i,&amp;string[i]);<br/> }<br/> printf("\n\nBefore Attack &gt;&gt; Buffer: %s String:%s\n",buffer,string);<br/> printf("\n\nPerforming the Attack....\n");<br/> <em class="jg">//strcpy(buffer,"Attack");</em><br/> printf("Enter the input:");<br/> gets(buffer);<br/> printf("After Attack &gt;&gt; Buffer: %s String:%s\n",buffer,string);<br/> printf("\n\nReinitializing variables and securing the code....\n");<br/> strcpy(string,"9");<br/> strcpy(buffer," ");<br/> printf("Reinitialized &gt;&gt; Buffer: %s String:%s\n",buffer,string);<br/> printf("\n\nPerforming the Attack....\n");<br/> <em class="jg">//strcpy_s(buffer,4,"Attack");</em><br/> printf("Enter the input:");<br/> fgets(buffer,4,stdin);<br/> printf("After Attack &gt;&gt; Buffer: %s String:%s\n",buffer,string);<br/> <strong class="jp hj">return</strong> 0;<br/>}</span></pre><figure class="jk jl jm jn fd ka er es paragraph-image"><div role="button" tabindex="0" class="kb kc di kd bf ke"><div class="er es jz"><img src="../Images/34524cc43fbce1f133f2b6db15bf649b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*N1twaICc9cQ_icv-Tk_eCQ.png"/></div></div><figcaption class="kh ki et er es kj kk bd b be z dx translated">基于堆栈的缓冲区溢出</figcaption></figure><blockquote class="jd je jf"><p id="909a" class="if ig jg ih b ii ij ik il im in io ip jh ir is it ji iv iw ix jj iz ja jb jc hb bi translated">注意:您可以删除程序中的注释，看看strcpy()函数如何容易受到缓冲区溢出的攻击。</p></blockquote><p id="4362" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">从输出中可以看出，当使用fgets()函数执行攻击时，由于没有缓冲区溢出，所以攻击没有成功。这是因为fgets()函数与gets()函数不同，它只接受小于或等于存储输入的变量大小的输入字符。fgets()在其参数中取变量的最大值。因此，从输出中可以看出，它只将“att”作为输入，并拒绝来自输入的“ack”。由于存储的最后一个字符是“\0”，因此只接受三个字符“att”。同样，strcpy()不检查数组边界，直接将一个字符串复制到另一个字符串，如果源字符串比目标字符串大，就会导致缓冲区溢出。为了防止这种情况发生，应该使用strcpy_s()。strcpy_s()将目标字符串的最大大小作为参数，如果它发现源字符串的大小大于目标字符串的大小，它不会将一个字符复制到目标字符串，从而防止缓冲区溢出</p></div><div class="ab cl kl km gp kn" role="separator"><span class="ko bw bk kp kq kr"/><span class="ko bw bk kp kq kr"/><span class="ko bw bk kp kq"/></div><div class="hb hc hd he hf"><p id="c72c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">基于堆的缓冲区溢出</strong></p><p id="3bb7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">基于堆的缓冲区溢出以相同的方式发生，不同之处在于这里以动态方式为缓冲区分配内存。所以我们来看一个简单的C程序。</p><pre class="jk jl jm jn fd jo jp jq jr aw js bi"><span id="b37d" class="jt ju hi jp b fi jv jw l jx jy">#include&lt;stdio.h&gt;<br/>#include&lt;stdlib.h&gt;<br/>#include&lt;string.h&gt;<br/><strong class="jp hj">int</strong> main()<br/>{<br/> <strong class="jp hj">char</strong> *buffer;<br/> buffer = (<strong class="jp hj">char</strong>*)malloc(5*<strong class="jp hj">sizeof</strong>(<strong class="jp hj">char</strong>));<br/> <strong class="jp hj">char</strong> *string;<br/> string = (<strong class="jp hj">char</strong>*)malloc(5*<strong class="jp hj">sizeof</strong>(<strong class="jp hj">char</strong>));<br/> printf("Heap Overflow Attack: \n\n");<br/> printf("Memory Addresses of String and Buffer: \n");<br/> printf("String: %p \n", string);<br/> printf("Buffer: %p \n\n", buffer);<br/> printf("Performing attack using strcpy().........\n\n");<br/> <em class="jg">//strcpy(buffer,"abcdefghijklmnopqrstuvwxyz1234567890");</em><br/> gets(buffer);<br/> printf("Buffer overflowed and overwrites empty String:\n");<br/> printf("String: %s \n\n", string);<br/> printf("Reinitializing Variables to empty string:\n");<br/> strcpy(string, " ");<br/> strcpy(buffer, " ");<br/> printf("String: %s \n", string);<br/> printf("Buffer: %s \n\n", buffer);<br/> printf("Performing attack using strcpy_s().......\n\n");<br/> <em class="jg">//strcpy_s(buffer, 5, "abcdefghijklmnopqrstuvwxyz1234567890");</em><br/> fgets(buffer,5,stdin);<br/> printf("No overflow:\n");<br/> printf("String: %s", string);<br/> <strong class="jp hj">return</strong> 0;<br/>}</span></pre><figure class="jk jl jm jn fd ka er es paragraph-image"><div role="button" tabindex="0" class="kb kc di kd bf ke"><div class="er es ks"><img src="../Images/1000197141e5ad45f8c25bcd4f27f0bd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ElAhzV-3gFftB3GGc1H3Bg.png"/></div></div><figcaption class="kh ki et er es kj kk bd b be z dx translated">基于堆的缓冲区溢出</figcaption></figure><p id="cc22" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">可见gets()和strcpy()函数有多不安全。</p></div><div class="ab cl kl km gp kn" role="separator"><span class="ko bw bk kp kq kr"/><span class="ko bw bk kp kq kr"/><span class="ko bw bk kp kq"/></div><div class="hb hc hd he hf"><p id="012a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">全局缓冲区溢出</strong></p><p id="b486" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这里，缓冲区具有全局范围。</p><pre class="jk jl jm jn fd jo jp jq jr aw js bi"><span id="4ed4" class="jt ju hi jp b fi jv jw l jx jy">#include&lt;stdlib.h&gt;<br/>#include&lt;stdio.h&gt;<br/>#include&lt;string.h&gt;<br/><strong class="jp hj">char</strong> access;<br/><strong class="jp hj">char</strong> buffer[4]; <em class="jg">//global buffer</em><br/><strong class="jp hj">int</strong> main(<strong class="jp hj">int</strong> argc, <strong class="jp hj">char</strong> **argv)<br/>{<br/> <strong class="jp hj">char</strong> *A = argv[1];<br/> <strong class="jp hj">char</strong> *B = "pass";<br/> access = 'n';<br/> strcpy(buffer,A);<br/> <em class="jg">//strcpy_s(buffer,4,A);</em><br/> <strong class="jp hj">if</strong> (strcmp(buffer,B)==0)<br/> {<br/> access = 'y';<br/> }<br/> <strong class="jp hj">if</strong>(access == 'y')<br/> {<br/> printf("\nThis is a secret");<br/> }<br/> <strong class="jp hj">else</strong><br/> {<br/> printf("\nAccess Denied");<br/> }<br/><strong class="jp hj">return</strong> 0;<br/>}</span></pre><figure class="jk jl jm jn fd ka er es paragraph-image"><div class="er es kt"><img src="../Images/a0a7ab4f878da369bd714d18266f6293.png" data-original-src="https://miro.medium.com/v2/resize:fit:914/format:webp/1*YjLDnJPYlWeOhfozc-BLeQ.png"/></div><figcaption class="kh ki et er es kj kk bd b be z dx translated">全局缓冲区溢出</figcaption></figure><p id="8fa8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">从上面的程序中可以看出，我们试图溢出全局声明的缓冲区。首先，我们声明了一个全局变量“access ”,它将用于执行访问控制。还有，还有一个全局缓冲区“buffer”。当使用strcpy()将命令行参数复制到“buffer”时，缓冲区可能会溢出。因此，正如在输出中看到的，当我们给定输入为“abcyyyyyyyyyy”时，它将溢出，并且“y”将在“access”变量中被覆盖，这将非法访问代码的密码保护部分。</p><p id="2a69" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">结论</strong></p><p id="e6b9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">可以得出这样的结论:如果使用不净化用户输入的易受攻击的函数，缓冲区溢出攻击很容易被利用，并可能导致灾难性的破坏。因此，为了防止这些攻击的发生，最好使用fgets()和strcpy_s()之类的函数来净化用户输入。应该使用strcpy()或strcpy()来防止缓冲区溢出攻击，而不是使用strcpy()。另外，应该使用strcmp()来代替strcmp()。</p></div><div class="ab cl kl km gp kn" role="separator"><span class="ko bw bk kp kq kr"/><span class="ko bw bk kp kq kr"/><span class="ko bw bk kp kq"/></div><div class="hb hc hd he hf"><p id="8755" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">对于任何技术或其他错误，随时与我联系，以便进一步的读者受益。</p><p id="a7c1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">感谢您的阅读。知识就是力量，所以不断获取！😈</p><p id="b620" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在<a class="ae ku" href="https://github.com/gandhidevansh" rel="noopener ugc nofollow" target="_blank"> GitHub </a>上关注我吧！</p></div></div>    
</body>
</html>