<html>
<head>
<title>Auto Deploy a React app to Firebase Hosting using CircleCI</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用CircleCI将React应用程序自动部署到Firebase主机</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/auto-deploy-a-react-app-to-firebase-hosting-using-circleci-4ccf4e3a1fdb?source=collection_archive---------1-----------------------#2021-09-25">https://medium.com/nerd-for-tech/auto-deploy-a-react-app-to-firebase-hosting-using-circleci-4ccf4e3a1fdb?source=collection_archive---------1-----------------------#2021-09-25</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="3ba8" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">对任何静态应用程序使用类似的步骤。</h2></div><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ix"><img src="../Images/80d006d71e9945df3a08cde2dbbcf9a7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LvhSzebVAGm9KIZw9NpPCQ.png"/></div></div></figure><p id="26dc" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">目标很简单:开发你的应用，承诺回购，看到实时变化。</p><p id="7015" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">假设:您至少理解CI/CD背后的思想和概念，并且确信这是正确的道路。这不是对React或持续集成或Firebase的介绍。</p><p id="a780" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">这篇文章是对现有文档的补充，也许可以帮助那些陷入困境的人摆脱困境。</p><p id="fb95" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">上下文:您不希望每次需要推送补丁或功能时都手动构建和部署应用程序。您希望至少自动化构建和部署步骤。当与团队一起工作时，它也很方便，因为没有一个开发人员必须承担运行构建和部署它们的任务。</p><p id="5d19" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">这是我们将要使用的配置，我将尽力解释每个部分的作用。想法是将您在本地运行的手动步骤转移到CI服务器中，使其自动化。</p><p id="a15e" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">我们将使用<code class="du kf kg kh ki b">CircleCI</code>，因此检查官方<a class="ae kj" href="https://circleci.com/docs/" rel="noopener ugc nofollow" target="_blank">文档</a>会有所帮助。</p><p id="d59a" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">货单<code class="du kf kg kh ki b">.circleci/config.yml</code>。写于<a class="ae kj" href="https://yaml.org/" rel="noopener ugc nofollow" target="_blank"> YAML </a>。</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="kk kl l"/></div></figure><p id="1bcd" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">您的应用在本地运行，并成功编译——太棒了！您已经在本地repo上初始化了<code class="du kf kg kh ki b">git</code>,并与远程存储库(可能在Github上)同步——太棒了！</p><p id="a8cc" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">您的工作流程可能会有所不同，但是我想假设您正在处理一个特性分支，您稍后会通过打开一个pull request (PR)将该特性分支合并到一个默认分支中，比如说<code class="du kf kg kh ki b">develop</code>——您的团队成员可以对其进行审查。</p><p id="c4b5" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">接下来我们<a class="ae kj" href="https://circleci.com/docs/2.0/hello-world/" rel="noopener ugc nofollow" target="_blank">将CircleCI连接到我们的repo </a>，这样每次我们按下代码时它都会被触发。我们可以指定分支来触发构建——在我们的例子中是<code class="du kf kg kh ki b">develop</code>和<code class="du kf kg kh ki b">master</code>。您还可以为不同的环境添加不同的规则— <code class="du kf kg kh ki b">dev</code>和<code class="du kf kg kh ki b">prod</code>。</p><p id="aeb4" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">在CircleCI上，作业(可能)在Docker容器中运行，所以我们指定了我们的<code class="du kf kg kh ki b">node.js</code>运行时，因为我们是用React构建的。我们最终得到一个预装了<code class="du kf kg kh ki b">npm</code>和<code class="du kf kg kh ki b">yarn</code>的环境。</p><p id="228b" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">构建过程的<code class="du kf kg kh ki b">checkout</code>步骤将代码从我们的(连接的)repo中提取到构建环境中——一个指定的工作目录，或者在我们的例子中是一个默认目录。</p><p id="173f" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">然后，我们安装所需的依赖项，并将我们的React代码构建到静态应用程序中— <code class="du kf kg kh ki b">HTML</code>、<code class="du kf kg kh ki b">CSS</code>、<code class="du kf kg kh ki b">JS</code>和其他资产，如<code class="du kf kg kh ki b">images</code>。这些静态文件(又名生产构建)将被部署到Firebase主机。</p><p id="e7b3" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">我想突出线条<code class="du kf kg kh ki b">15</code>。</p><pre class="iy iz ja jb fd km ki kn ko aw kp bi"><span id="0bc0" class="kq kr hi ki b fi ks kt l ku kv">yarn global add firebase-tools &amp;&amp; firebase deploy --only hosting --token ${FIREBASE_TOKEN}</span></pre><p id="05a8" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">为了能够使用<code class="du kf kg kh ki b">firebase</code>命令，我们需要在<code class="du kf kg kh ki b">PATH</code>中包含二进制文件，所以我们在全局范围内安装了firebase工具。我曾见过工具作为开发依赖项安装在本地的设置，但这可能需要使用绝对路径调用<code class="du kf kg kh ki b">firebase</code>——类似于<code class="du kf kg kh ki b">./node_modules/.bin/firebase</code>——很难看。</p><p id="802a" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">之后，我们部署应用程序，就像在本地一样。添加<code class="du kf kg kh ki b">--only hosting</code>标志有助于firebase知道您只想部署主机，而不是功能或其他任何东西。</p><p id="390a" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">由于忽略了标志，我遇到了这个错误。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es kw"><img src="../Images/aaad2c49c07064291715169aac2014e7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0vhzDf6q4E_FTUokWyL0Eg.png"/></div></div></figure><p id="a2fa" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">由于CircleCI是一个非交互式CLI环境，您将没有浏览器来登录到<a class="ae kj" href="https://firebase.google.com/docs/cli#linux" rel="noopener ugc nofollow" target="_blank"> Firebase </a>中，因此您需要一个令牌来进行身份验证。此外，您应该已经在本地初始化了firebase以获得<code class="du kf kg kh ki b">.firebaserc</code>和<code class="du kf kg kh ki b">firebase.json</code>文件。</p><p id="d8e2" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">使用<code class="du kf kg kh ki b">firebase login:ci</code>在本地终端登录，获取令牌，并将其添加到CircleCI上的项目环境变量中。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es kx"><img src="../Images/606305348f77655bd0da9309fd22d20c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*28C9J1AU10UqgrgWLSUlvw.png"/></div></div></figure><p id="5f49" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">最后，不要忘记在范围中包含必要的环境变量；将它们添加到您的项目中。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ky"><img src="../Images/775ccfe77c6b22c39af9b92b9cffc086.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*u9vBCs1J-NqnxB6e45bczA.png"/></div></div></figure><p id="1005" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">就是这样——至少对我来说是这样。一如既往，我在这里寻求任何反馈。</p></div></div>    
</body>
</html>