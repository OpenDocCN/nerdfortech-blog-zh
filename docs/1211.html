<html>
<head>
<title/>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1/>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/moving-oracle-to-postgres-be-aware-of-fillfactor-and-indexing-implications-fcec6596827a?source=collection_archive---------15-----------------------#2021-03-09">https://medium.com/nerd-for-tech/moving-oracle-to-postgres-be-aware-of-fillfactor-and-indexing-implications-fcec6596827a?source=collection_archive---------15-----------------------#2021-03-09</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><p id="7629" class="pw-post-body-paragraph hg hh hi hj b hk hl hm hn ho hp hq hr hs ht hu hv hw hx hy hz ia ib ic id ie hb bi translated"><strong class="hj if">从Oracle迁移到Postgres？注意填充因子和索引含义</strong></p><p id="0faf" class="pw-post-body-paragraph hg hh hi hj b hk hl hm hn ho hp hq hr hs ht hu hv hw hx hy hz ia ib ic id ie hb bi translated">我们知道索引对于加速关系数据库中的SQL是多么有用。尽管索引增加了DMLs处理的一些开销，因为对于一个表上的任何DML，所有对应的索引都需要与堆表同步。</p><p id="109d" class="pw-post-body-paragraph hg hh hi hj b hk hl hm hn ho hp hq hr hs ht hu hv hw hx hy hz ia ib ic id ie hb bi translated">Postgres已经成为一个非常受欢迎的开源数据库，许多组织正在将其工作负载从Oracle迁移到Postgres。这两种RDBMS的主要区别之一是多版本并发控制(MVCC)的实现。让我们明白这一点。</p><figure class="ih ii ij ik fd il er es paragraph-image"><div class="er es ig"><img src="../Images/bb57c22f94d3646a509cdc544078dd75.png" data-original-src="https://miro.medium.com/v2/resize:fit:1370/format:webp/1*XQMxtvIIEPH45CPA0MpkMQ.png"/></div></figure><p id="06b3" class="pw-post-body-paragraph hg hh hi hj b hk hl hm hn ho hp hq hr hs ht hu hv hw hx hy hz ia ib ic id ie hb bi translated"><strong class="hj if">Oracle中更新查询的工作原理</strong></p><p id="57b3" class="pw-post-body-paragraph hg hh hi hj b hk hl hm hn ho hp hq hr hs ht hu hv hw hx hy hz ia ib ic id ie hb bi translated">在Oracle中，当用户运行更新查询来更新一列时，该行的旧图像存储在全局撤消段中，这是一个单独管理的专用撤消空间。在这种情况下，因为Oracle在适当的位置更改了行<strong class="hj if">，因此行位置(在Oracle中称为rowid)没有更改，因此不需要更改相应的索引条目(除非更新查询修改了索引列本身的数据)。</strong></p><p id="64ac" class="pw-post-body-paragraph hg hh hi hj b hk hl hm hn ho hp hq hr hs ht hu hv hw hx hy hz ia ib ic id ie hb bi translated"><strong class="hj if">更新查询如何在PostgreSQL中工作</strong></p><p id="9cf8" class="pw-post-body-paragraph hg hh hi hj b hk hl hm hn ho hp hq hr hs ht hu hv hw hx hy hz ia ib ic id ie hb bi translated">在PostgreSQL中，当用户运行更新查询来更新列时，它会将旧行标记为死元组/行，并使用更新的列数据创建新版本的行(<strong class="hj if">错位</strong>更改)。这里，因为行的物理位置(在Postgres中称为ctid)会发生变化，而且似乎每更新一行，相应的索引条目也会发生变化。如果所有的索引条目都需要随着每一行的更新而改变，这在Postgres中看起来是一个巨大的缺点。</p><p id="a784" class="pw-post-body-paragraph hg hh hi hj b hk hl hm hn ho hp hq hr hs ht hu hv hw hx hy hz ia ib ic id ie hb bi translated"><strong class="hj if">等等！</strong> Postgres开发人员社区在这个过程中提出了一个很好的优化，称为HOT ( <strong class="hj if"> Heap Only Tuples </strong>)，其中即使ctid对一行进行了更改，也不需要更改索引条目，它在表块中放置了一个定位器，指向同一块中的新行位置。HOT还会在某个时间点(当空间压力施加到块上时)进行块级微型真空处理，以清理死元组。</p><p id="3dbe" class="pw-post-body-paragraph hg hh hi hj b hk hl hm hn ho hp hq hr hs ht hu hv hw hx hy hz ia ib ic id ie hb bi translated">Postgres中的HOT特性与Oracle相当，只有当更新查询正在更改属于任何索引一部分的列数据时，任何更新的行才会更改索引条目。</p><p id="4bbd" class="pw-post-body-paragraph hg hh hi hj b hk hl hm hn ho hp hq hr hs ht hu hv hw hx hy hz ia ib ic id ie hb bi translated"><strong class="hj if">下一个问题:如果当前块中没有空闲空间来容纳新更新的行怎么办？</strong></p><p id="b66d" class="pw-post-body-paragraph hg hh hi hj b hk hl hm hn ho hp hq hr hs ht hu hv hw hx hy hz ia ib ic id ie hb bi translated">在这种情况下，Oracle和Postgres的行为方式不同。</p><p id="92a0" class="pw-post-body-paragraph hg hh hi hj b hk hl hm hn ho hp hq hr hs ht hu hv hw hx hy hz ia ib ic id ie hb bi translated"><strong class="hj if">在Oracle </strong>中，它就地更新行，因此只有当新更新的行大小大于旧的行大小时，块才会满。在这种情况下，该行将被迁移到新的块中，并且指向新的行id的指针将出现在当前块中。</p><ul class=""><li id="3dd3" class="io ip hi hj b hk hl ho hp hs iq hw ir ia is ie it iu iv iw bi translated"><strong class="hj if">优点</strong> —无需更改索引条目，因为索引条目仍将指向旧块。</li><li id="b1e0" class="io ip hi hj b hk ix ho iy hs iz hw ja ia jb ie it iu iv iw bi translated"><strong class="hj if">缺点</strong> —索引扫描将变得更慢，因为索引条目仍然将行位置指向旧块，然后旧块将行位置指向新块，然后获取行是两步过程，因此更慢。</li></ul><p id="2c5c" class="pw-post-body-paragraph hg hh hi hj b hk hl hm hn ho hp hq hr hs ht hu hv hw hx hy hz ia ib ic id ie hb bi translated"><strong class="hj if">在Postgres </strong>中，当新更新的行在当前块中找不到空间时，它将被存储在一个有空闲空间的新块中。这里，Postgres选择改变所有相应的索引条目，而不是将定位器放入旧块中。</p><ul class=""><li id="7769" class="io ip hi hj b hk hl ho hp hs iq hw ir ia is ie it iu iv iw bi translated"><strong class="hj if">优点</strong> —对索引扫描没有影响，因为该行的索引条目包含该行的实际ctid。</li><li id="f13e" class="io ip hi hj b hk ix ho iy hs iz hw ja ia jb ie it iu iv iw bi translated"><strong class="hj if">缺点</strong> —因为所有的索引条目都需要更改，这导致了以下问题。</li></ul><ol class=""><li id="d8fa" class="io ip hi hj b hk hl ho hp hs iq hw ir ia is ie jc iu iv iw bi translated">UPDATE语句延迟较高，因为每次行更新都需要更改表条目和所有索引条目。</li><li id="78c5" class="io ip hi hj b hk ix ho iy hs iz hw ja ia jb ie jc iu iv iw bi translated">长时间运行的<strong class="hj if"> VACUUM </strong>需要随着表一起清理索引死元组。</li><li id="558d" class="io ip hi hj b hk ix ho iy hs iz hw ja ia jb ie jc iu iv iw bi translated">写放大，结果更多的数据被发送到所有备用/读副本。</li></ol><p id="4060" class="pw-post-body-paragraph hg hh hi hj b hk hl hm hn ho hp hq hr hs ht hu hv hw hx hy hz ia ib ic id ie hb bi translated"><strong class="hj if">摘要:</strong>默认情况下，Postgres表是用<strong class="hj if"> FILLFACTOR 100 </strong>创建的，由于其上面解释的MVCC架构，使用UPDATE语句，新行更倾向于转到新块，从而导致所有索引更新。为了防止这些索引更新，我们需要减少频繁更新的表的FILLFACTOR值，并删除任何不需要的索引或索引列(以防这些索引中的任何列被更新)。</p><p id="1269" class="pw-post-body-paragraph hg hh hi hj b hk hl hm hn ho hp hq hr hs ht hu hv hw hx hy hz ia ib ic id ie hb bi translated">让我们在下一篇<a class="ae jd" href="https://virender-cse.medium.com/postgres-fillfactor-baf3117aca0a" rel="noopener">帖子</a>中更深入地探讨Postgres FILLFACTOR。</p></div></div>    
</body>
</html>