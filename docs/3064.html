<html>
<head>
<title>Topological Sort in Python with a Mughal touch</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">带有莫卧儿风格的Python中的拓扑排序</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/topological-sort-in-python-with-a-mughal-touch-7e66e68465d6?source=collection_archive---------20-----------------------#2021-05-28">https://medium.com/nerd-for-tech/topological-sort-in-python-with-a-mughal-touch-7e66e68465d6?source=collection_archive---------20-----------------------#2021-05-28</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><figure class="hh hi ez fb hj hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es hg"><img src="../Images/112143afad15263127a1c3e947cd5fd1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*m2nBqK7DGm8-xzkJ54-Yrw.jpeg"/></div></div></figure><div class=""/><p id="e239" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">莫卧儿王朝已经统治了南亚两个世纪，并对印度次大陆产生了巨大影响。一个这样的例子是<a class="ae jo" href="https://en.wikipedia.org/wiki/Taj_Mahal" rel="noopener ugc nofollow" target="_blank">泰姬陵</a>。在这篇博客中，我们将使用莫卧儿帝国的家谱来理解图论中的拓扑排序。</p><p id="3c7f" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在<a class="ae jo" href="https://en.wikipedia.org/wiki/Graph_theory" rel="noopener ugc nofollow" target="_blank">图论</a>中，拓扑排序是最有趣的话题之一。这个博客将涵盖拓扑排序的理论，拓扑排序在python中的实现，拓扑排序解决的问题以及关于莫卧儿帝国的有趣事实。</p></div><div class="ab cl jp jq gp jr" role="separator"><span class="js bw bk jt ju jv"/><span class="js bw bk jt ju jv"/><span class="js bw bk jt ju"/></div><div class="hb hc hd he hf"><p id="4e59" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><a class="ae jo" href="https://en.wikipedia.org/wiki/Topological_sorting" rel="noopener ugc nofollow" target="_blank">拓扑排序</a>在<a class="ae jo" href="https://en.wikipedia.org/wiki/Directed_acyclic_graph" rel="noopener ugc nofollow" target="_blank">有向无环图(DAG) </a>中也称为拓扑排序，是顶点的线性排序，使得对于从顶点U到顶点V的每条边UV，在排序中U在V之前。</p><p id="ed70" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在以家族成员的名字作为树的顶点的家族树上运行拓扑排序将导致家族代1首先被处理，然后是家族代2。</p><figure class="jx jy jz ka fd hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es jw"><img src="../Images/2e46fd18fbf5d17b6c1dbffca9bec575.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*shCGOt9F5vYQwAXn5yHdhQ.png"/></div></div></figure><p id="fad2" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">上面显示的有向图代表了修剪下来的莫卧儿族谱。详细的家庭可以访问<a class="ae jo" href="https://en.wikipedia.org/wiki/Template:Mughal_family_tree" rel="noopener ugc nofollow" target="_blank">这里</a>。在上图中，顶点代表家庭成员的姓名，边代表家庭成员之间的父子关系。灰色顶点代表莫卧儿帝国皇帝的家庭成员。</p><p id="3e89" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">让我们看看实现拓扑排序的算法，</p><ul class=""><li id="765e" class="kb kc ht is b it iu ix iy jb kd jf ke jj kf jn kg kh ki kj bi translated"><strong class="is hu">初始化数据结构定义图:</strong> <br/>对于拓扑排序我们需要初始化顶点(父子)之间的关系以及每个顶点的<a class="ae jo" href="https://en.wikipedia.org/wiki/Directed_graph#Indegree_and_outdegree" rel="noopener ugc nofollow" target="_blank">的度数</a>。使用顶点之间的父子关系，可以创建图的<a class="ae jo" href="https://www.geeksforgeeks.org/graph-and-its-representations/" rel="noopener ugc nofollow" target="_blank">邻接表</a>。<br/> <a class="ae jo" href="https://en.wikipedia.org/wiki/Directed_graph#Indegree_and_outdegree" rel="noopener ugc nofollow" target="_blank">需要Inde degree</a>来推导顶点之间的依赖关系。如果一个顶点度数为零，这意味着该顶点没有传入边，且不依赖于任何其他顶点。<br/>在代码中，使用了一个字典来存储graph和indegree。它也可以表示为一个类。</li></ul><pre class="jx jy jz ka fd kk kl km kn aw ko bi"><span id="ad3a" class="kp kq ht kl b fi kr ks l kt ku">indegree = {i: 0 for i in vertices}<br/>graph = {i: [] for i in vertices}</span></pre><ul class=""><li id="6508" class="kb kc ht is b it iu ix iy jb kd jf ke jj kf jn kg kh ki kj bi translated"><strong class="is hu">填充索引和图:</strong> <br/>从给定的一组边中，用邻接表和每个顶点的索引更新图字典</li></ul><pre class="jx jy jz ka fd kk kl km kn aw ko bi"><span id="c04f" class="kp kq ht kl b fi kr ks l kt ku">for edge in edges:<br/>    parent, child = edge[0], edge[1]<br/>    graph[parent].append(child)<br/>    indegree[child] += 1</span></pre><ul class=""><li id="dcc7" class="kb kc ht is b it iu ix iy jb kd jf ke jj kf jn kg kh ki kj bi translated"><strong class="is hu">将零度顶点加入队列:</strong> <br/>零度顶点不依赖于任何其他顶点。将其添加到队列中以供进一步处理。</li></ul><pre class="jx jy jz ka fd kk kl km kn aw ko bi"><span id="a7cb" class="kp kq ht kl b fi kr ks l kt ku">sources = deque()<br/>for source, degree in indegree.items():<br/>    # store vertex with indegree zero<br/>    if degree == 0:<br/>    sources.append(source)</span></pre><ul class=""><li id="73e1" class="kb kc ht is b it iu ix iy jb kd jf ke jj kf jn kg kh ki kj bi translated"><strong class="is hu">处理加入队列的顶点:</strong> <br/>从队列中弹出顶点，处理弹出顶点的所有子顶点。如果索引变为零，则将子顶点添加到队列中。</li></ul><pre class="jx jy jz ka fd kk kl km kn aw ko bi"><span id="c75e" class="kp kq ht kl b fi kr ks l kt ku">while sources:<br/>    source = sources.popleft()<br/>    sortedOrder.append(source)<br/>    for child in graph[source]:<br/>    # decrement indegree of child vertex<br/>        indegree[child] -= 1<br/>        # if indegree is zero then add it to the queue<br/>        if indegree[child] == 0:<br/>            sources.append(child)</span></pre><ul class=""><li id="d069" class="kb kc ht is b it iu ix iy jb kd jf ke jj kf jn kg kh ki kj bi translated"><strong class="is hu">检查顶点之间的循环:</strong> <br/>当顶点A依赖于顶点B，顶点B依赖于顶点A时，会出现循环，这样顶点A和顶点B的度数都永远为1，永远不会被拓扑排序处理。可以通过比较排序列表的长度和图字典的长度来检测循环。在运行拓扑排序后，如果不是所有的顶点都被添加到sorted_list中，那么这意味着即使在移除所有的依赖关系后，也只有少数顶点的度数不等于零。</li></ul><pre class="jx jy jz ka fd kk kl km kn aw ko bi"><span id="e7a1" class="kp kq ht kl b fi kr ks l kt ku">if len(sortedOrder) != len(vertices):<br/>    return list()</span></pre><p id="ee72" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">下面是拓扑排序的python代码，</p><figure class="jx jy jz ka fd hk"><div class="bz dy l di"><div class="kv kw l"/></div></figure><p id="e947" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">上述程序的输出是:</p><pre class="jx jy jz ka fd kk kl km kn aw ko bi"><span id="6f05" class="kp kq ht kl b fi kr ks l kt ku">Topological sort: ['Babur', 'Humayun', 'Askari', 'Akbar', 'Mirza', 'Jahangir', 'Daniyal', 'Shah Jahan', 'Khusrau', 'Aurangzeb', 'Murad']</span></pre></div><div class="ab cl jp jq gp jr" role="separator"><span class="js bw bk jt ju jv"/><span class="js bw bk jt ju jv"/><span class="js bw bk jt ju"/></div><div class="hb hc hd he hf"><p id="7889" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在哪里使用拓扑排序:</p><ul class=""><li id="fa66" class="kb kc ht is b it iu ix iy jb kd jf ke jj kf jn kg kh ki kj bi translated"><strong class="is hu">顶点排序:</strong> <br/>可以用来解决多个项目之间的依赖关系。例如，安装软件包，其中一个软件包是安装另一个软件包的先决条件。</li><li id="af86" class="kb kc ht is b it kx ix ky jb kz jf la jj lb jn kg kh ki kj bi translated"><strong class="is hu">在图中寻找回路:<br/> </strong>这是上述观点的延伸。例如，顶点A依赖于顶点B，顶点B依赖于顶点C，顶点C依赖于顶点A。这在顶点A、B和C之间创建了一个循环。拓扑排序可用于检测此类循环。在上面的代码示例中，这是在第44行实现的。</li></ul></div><div class="ab cl jp jq gp jr" role="separator"><span class="js bw bk jt ju jv"/><span class="js bw bk jt ju jv"/><span class="js bw bk jt ju"/></div><div class="hb hc hd he hf"><p id="477d" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">关于莫卧儿帝国的有趣事实</p><ul class=""><li id="8b3d" class="kb kc ht is b it iu ix iy jb kd jf ke jj kf jn kg kh ki kj bi translated">泰姬陵由沙贾汗建造，是世界遗产中的杰作之一。</li><li id="fd5a" class="kb kc ht is b it kx ix ky jb kz jf la jj lb jn kg kh ki kj bi translated">皇帝<a class="ae jo" href="https://en.wikipedia.org/wiki/Humayunhttps://en.wikipedia.org/wiki/Humayun" rel="noopener ugc nofollow" target="_blank">胡马云</a>被赶下台，但他克服一切困难重新夺回了帝国，这对所有人来说都是一个很好的教训。一个人完全可以通过努力工作来克服障碍。</li><li id="c70c" class="kb kc ht is b it kx ix ky jb kz jf la jj lb jn kg kh ki kj bi translated">皇帝<a class="ae jo" href="https://en.wikipedia.org/wiki/Akbar" rel="noopener ugc nofollow" target="_blank">阿克巴</a>被认为是<a class="ae jo" href="https://en.wikipedia.org/wiki/Dyslexia" rel="noopener ugc nofollow" target="_blank">诵读困难</a>。</li></ul></div><div class="ab cl jp jq gp jr" role="separator"><span class="js bw bk jt ju jv"/><span class="js bw bk jt ju jv"/><span class="js bw bk jt ju"/></div><div class="hb hc hd he hf"><p id="0a60" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">另外，本博客中讨论的例子也可以用BFS来解决，因为我们正在处理一棵树(图的特例)。我选择拓扑排序来解释算法。</p><p id="1cc4" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">谢谢你阅读博客。我希望它对你有用。</p></div></div>    
</body>
</html>