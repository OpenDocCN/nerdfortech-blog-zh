# 累进指数

> 原文：<https://medium.com/nerd-for-tech/progressive-index-7686d8be97a7?source=collection_archive---------16----------------------->

## 启用非对称数据点流的随机可访问性

![](img/3e644b7dbff99c1997a7008f09ab0810.png)

当我们在一个流中存储多个数据点时，我们需要确保该流是可解构的。

一个简单的例子是对称数据点。我说的对称是什么意思？我的意思是每个数据点的大小(以字节为单位)是相等的。如果我们有一个 100 字节的数据流，并且每个数据点的长度都是 10 字节，那么将这 100 个字节分解成 10 个 10 字节的数据点是微不足道的。

在一个流中存储非对称数据点(每个数据点有一个随机的 T2 大小)有点复杂。我们可以使用多种技术:

1.  在数据点之间放置一个**可区分的分隔符**。例如，英语句子中的单词由空格或其他标点符号分隔。英语单词不能包含空格或标点符号，因此它们是**可区分的分隔符**。一个更技术性的例子是一个 [NDJSON](http://ndjson.org) 文件格式。对于 NDJSON，数据点是有效的缩小 JSON 对象，分隔符是`\n`(新行字符)。新行字符是一个**可区分的分隔符**，因为缩小的 JSON 对象不包含新行字符。
2.  对我们人类来说,**可辨别分离器**技术是非常普通和自然的，但是它有一些缺陷。首先，**可区分的分隔符**可能很难识别，特别是当你的数据是随机的二进制流时。另一个问题是将数据流分解成独立数据点的效率。在**可区分分隔符**的情况下，我们必须线性扫描流以识别一个数据点的结束和另一个数据点的开始。借助 SIMD 指令(参见 [simdjson](https://github.com/simdjson/simdjson#documentation) 背后的概念)，通过构建字符位向量来加速任务是可能的，但这仍然是一个复杂而乏味的过程。解决前面提到的两个缺陷的技术是**长度前缀**。使用这种技术，我们在存储数据点之前存储数据点的长度，这样我们就知道即将到来的数据点的长度是`X`字节。如果我们需要知道流中存储了多少数据点，我们可以读取第一个**长度前缀**，然后跳过我们刚刚读取的字节数到下一个**长度前缀**等等。这样，我们可以跳过数据本身，而不必全盘接收。这比搜索**可区分分隔符**更有效，特别是当数据点很大时。
3.  **长度前缀**技术听起来像是一个完美的计划，但它有它的问题。首先，我们如何确定数据点的长度值在哪里结束，数据点的数据在哪里开始？对此，有两种解决方案。我们将长度值存储在固定数量的字节中(例如，每个值 4 个字节，这使我们能够表示高达 4GB 的数据值)，或者我们将长度值表示为一个 [VLQ](https://en.wikipedia.org/wiki/Variable-length_quantity) 。当一个数表示为 [VLQ](https://en.wikipedia.org/wiki/Variable-length_quantity) 时，每读取一个字节的第 8 位标志着，我们是否需要继续读取下一个字节，或者我们已经读取了代表该值的所有字节。仔细想想， [VLQ](https://en.wikipedia.org/wiki/Variable-length_quantity) 本身就是一种**可区分分隔符**技术，每值`X`字节是一种固定大小/ **对称值**解决方案**。**长度前缀**的一个更大的问题是，即使我们可以线性跳过数据点，我们也不能进行随机值访问。随机值访问意味着，我们可以访问流中的第`X`个数据点，而无需复杂的计算和摄取所有优先数据点。为了启用这种能力，我们需要存储一个索引**。**索引**本身就是一串数据点，我们可以使用它从数据流中高效地读取单个随机数据点。但是如果索引是一串数据点，我们如何以可分解的方式存储这些数据点呢？这个问题变成了递归的。存储**索引**的最常见解决方案是将数值存储为对称数据点…

将索引值存储为对称数据点意味着，我们必须在数据点表示及其长度上达成一致。

对于数据点表示，我推荐一个单一的`unsigned integer`值，它存储了添加数据点后数据流的大小。

让我举一个例子。假设我们有一个字符串数组:

```
["Hello", "my", "name", "is", "Maxim"]
```

我们希望将它存储为一个连续的流:

```
HellomynameisMaxim
```

为了解构流并使数据点可随机访问，我们创建了以下索引流:

```
[5, 7, 11, 13, 18]
```

我们可以根据一个简单的计算从数据流中读取随机值:

假设我们需要读取数据流中索引`n`处的数据点。我们在索引流中查找`n-1`值(或者如果`n==0`返回`0`)，并在索引流中查找`n`值。给定这两个值，我们得到了数据流中第`n`个元素所在的范围。

所以在我们之前的例子中，数据流中的第一个值在范围`0..<5`内，第二个值在范围`5..<7`内，第三个`7..<11`，第四个`11..<13`，第五个`13..<18`。

现在，我们需要就值的大小达成一致，或者我们希望在每个索引数据点上花费多少字节。记住，为了使索引可以随机访问，它的数据点必须是对称的。

我们知道索引值是单调递增的正数，但我们可能无法说出最后/最大的数字会有多大。因此，最简单的解决方案是防御性的，用大块表示所有的数字(例如，每个数字 4 个字节)。这意味着，我们将把少量物品储存在更大的块中，类似于亚马逊如何将小件物品放入装满包装材料的更大的盒子中，以简化运输的复杂性。

另一种选择是将索引值保存在运行时内存的大块中，当我们将最后一个数据点添加到数据流中时，将索引流值重新打包成较小的块。这种解决方案更节省空间，但是计算量更大。

这是我想最终介绍我的想法的地方:

> 不对称数据的渐进式索引

这个想法基于这样一个事实，即索引流中的值是单调递增的正数。我们可以根据值的大小将数字分组到多个流中，而不是将数字放在一个流中并对小数字进行填充。这就是*递进*的意思。第一个项目可能适合 1 字节，然后 2 字节，然后 3 字节等

## 但是，我们如何建立多个流呢？

基于不同的使用情形，有多种解决方案。在这篇博文中，我将只介绍其中一个。

假设我们开发了某种时间序列数据持久层。数据本身。我们追加到一个`xxx.data`文件。追加之后，我们检查`xxx.data`文件的新大小是否可以用 1 字节表示，如果可以，我们将数字追加到一个`xxx.index1`文件，该文件存储了所有可以用 1 字节表示的索引。如果不是，我们将索引值附加到`xxx.index2`、`xxx.index3`、`xxx.index4`等…

在读取随机值时，我们需要做一些计算。以便识别哪个索引文件包含元素`n`的数据。我们需要计算哪个文件代表多少个元素。这很简单，我们用索引文件的大小除以值的大小:

```
count1 = sizeOf("xxx.idx1") / 1
count2 = sizeOf("xxx.idx2") / 2
count3 = sizeOf("xxx.idx3") / 3
// etc ...
```

当我们有了*计数*时，我们可以很容易地识别出哪个索引文件包含了`n-1`和`n`的值。

```
localIndex = n
counts = [count1, count2, count3]
for (fileIndex, count) in counts.enumerated() {
  if count > localIndex {
    return (fileIndex, localIndex)
  }
  localIndex -= count
}
```

现在我们只需要获取这些值并从范围`n-1..<n`的`xxx.data`文件中读取数据。

显然，对**渐进式索引**的读取操作比简单的索引查找要复杂得多，但是计算并不十分昂贵，并且还带来了空间效率的好处。

谢谢你看我的帖子。如果您有问题，或者您最终在您的项目中使用了**渐进式索引**，请告诉我。