<html>
<head>
<title>Making sense of Objects and Object Oriented Programming in JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">理解JavaScript中的对象和面向对象编程</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/making-sense-of-objects-and-object-oriented-programming-in-javascript-226fd0414961?source=collection_archive---------13-----------------------#2021-03-07">https://medium.com/nerd-for-tech/making-sense-of-objects-and-object-oriented-programming-in-javascript-226fd0414961?source=collection_archive---------13-----------------------#2021-03-07</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/420439669389b0ea48f601cdd553a442.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AvRcx3NtubkKAc6nRALLJA.png"/></div></div></figure><p id="f331" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我想谈谈JavaScript中的对象以及它们是如何用于面向对象编程(OOP)的。我将谈一点关于对象和它们的属性，以及关于带有构造函数和类的OOP。</p><p id="adb3" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我将报道:</p><p id="5448" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">1-什么是对象？</p><p id="5fe8" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">2-作为属性集合的对象</p><p id="b287" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">JavaScript对象</p><p id="6676" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">4-克隆对象-引用类型</p><p id="6b69" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">5 —一般的面向对象编程</p><p id="33de" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">JavaScript中的面向对象编程</p><p id="0b1f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">7 —使用什么类型的OOP？</p><h1 id="cd8d" class="jo jp hi bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">1 —什么是对象？</h1><p id="3bcb" class="pw-post-body-paragraph iq ir hi is b it km iv iw ix kn iz ja jb ko jd je jf kp jh ji jj kq jl jm jn hb bi translated">对象用于保存不同类型的数据。JavaScript中拥有对象的一种常见方式是这样的:</p><p id="1bec" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><code class="du kr ks kt ku b">{name:”my name”, age: “my age”}</code></p><p id="e999" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">但是在JavaScript中，除了原始类型，所有东西都是对象。即使是基本类型，也有办法将它们创建为对象，而不仅仅是基本类型。</p><pre class="kv kw kx ky fd kz ku la lb aw lc bi"><span id="2f71" class="ld jp hi ku b fi le lf l lg lh">const num = 19;<br/>console.log(typeof(num));//returns <strong class="ku hj">number</strong><br/>console.log (num <strong class="ku hj">===</strong> 19); //returns <strong class="ku hj">true</strong></span><span id="90e7" class="ld jp hi ku b fi li lf l lg lh">const num2 = <strong class="ku hj">new Number</strong>(20);<br/>console.log(typeof(num2)); //returns <strong class="ku hj">object</strong><br/>console.log (num <strong class="ku hj">===</strong> 20); //returns <strong class="ku hj">false</strong></span></pre><p id="abcf" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">JavaScript在命名属性时也非常灵活，我将在下一节展示这一点。</p><h1 id="223f" class="jo jp hi bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">2-作为属性集合的对象</h1><p id="3b72" class="pw-post-body-paragraph iq ir hi is b it km iv iw ix kn iz ja jb ko jd je jf kp jh ji jj kq jl jm jn hb bi translated">请看下面的例子，了解我们使用对象属性的不同方式。</p><pre class="kv kw kx ky fd kz ku la lb aw lc bi"><span id="3557" class="ld jp hi ku b fi le lf l lg lh">//label the property and assign it a value<br/>let someObject = {<br/>     <strong class="ku hj">property1</strong>:"prop1",<br/>     property2: "prop2"<br/>}<br/>console.log(someObject.<strong class="ku hj">property1</strong>); //prints prop1<br/>console.log(someObject.<strong class="ku hj">property101</strong>); // prints undefined</span></pre><p id="2bf5" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">属性可以包含函数:</p><pre class="kv kw kx ky fd kz ku la lb aw lc bi"><span id="1546" class="ld jp hi ku b fi le lf l lg lh">const someObject = {<br/>     prop1:function () {console.log("I am 1");},<br/>}</span><span id="861e" class="ld jp hi ku b fi li lf l lg lh">someObject.prop1;//will not do anything (not calling the function)<br/>someObject.<strong class="ku hj">prop1()</strong>;//prints "I am 1"<br/>let aux = someObject.prop1; // assign the function<br/><strong class="ku hj">aux();</strong> // prints "I am 1"</span></pre><p id="947f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">属性可以根据另一个变量命名:</p><pre class="kv kw kx ky fd kz ku la lb aw lc bi"><span id="5b67" class="ld jp hi ku b fi le lf l lg lh">const <strong class="ku hj">propertyName </strong>= "Jane";</span><span id="3969" class="ld jp hi ku b fi li lf l lg lh">//use <strong class="ku hj">[]</strong> to use the variable name<br/>const someObject = {<br/>     <strong class="ku hj">[propertyName]</strong>:"hello"<br/>}</span><span id="fed3" class="ld jp hi ku b fi li lf l lg lh">console.log(someObject<strong class="ku hj">.Jane</strong>);//prints "hello"<br/>console.log(someObject<strong class="ku hj">[propertyName]</strong>); //prints "hello" </span></pre><p id="ab3e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">注意如何使用变量来访问属性我们没有使用点符号，而是用括号符号代替</strong>。当访问嵌套属性时，可以使用点和括号符号的组合。</p><p id="3db9" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如果我们愿意，我们也可以这样做:</p><pre class="kv kw kx ky fd kz ku la lb aw lc bi"><span id="b582" class="ld jp hi ku b fi le lf l lg lh">const someObject = {<br/>     <strong class="ku hj">[2+2]</strong>:"hello"<br/>}</span><span id="bc37" class="ld jp hi ku b fi li lf l lg lh">//access with [] notation.<br/>console.log(someObject<strong class="ku hj">[4]</strong>); //prints "hello"<br/>console.log(someObject<strong class="ku hj">[1+3]</strong>); // prints "hello"</span></pre><p id="56dd" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">要添加额外的属性，我们只需使用它，它就会被添加。</p><pre class="kv kw kx ky fd kz ku la lb aw lc bi"><span id="b7c1" class="ld jp hi ku b fi le lf l lg lh">const someObject = {<br/>     p1:"hello"<br/>}<br/>someObject.p2 = "hello 2"<br/>console.log(someObject.p2); //prints "hello 2"</span></pre><p id="098d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">要删除属性，我们需要执行以下操作:</p><pre class="kv kw kx ky fd kz ku la lb aw lc bi"><span id="7926" class="ld jp hi ku b fi le lf l lg lh">const someObject = {<br/>     p1:"hello 1",<br/>     p2:"hello 2"<br/>}</span><span id="b39a" class="ld jp hi ku b fi li lf l lg lh">console.log(someObject.p2); //prints "hello 2"<br/><strong class="ku hj">delete </strong>someObject.p2;<br/>console.log(someObject.p2); // prints undefined.</span></pre><h1 id="0d0a" class="jo jp hi bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">JavaScript对象</h1><p id="47cf" class="pw-post-body-paragraph iq ir hi is b it km iv iw ix kn iz ja jb ko jd je jf kp jh ji jj kq jl jm jn hb bi translated">除了上面的例子中所展示的，对象还可以用其他方式创建，其中之一就是使用Object()构造函数。JavaScript对象是Object的实例。</p><pre class="kv kw kx ky fd kz ku la lb aw lc bi"><span id="6973" class="ld jp hi ku b fi le lf l lg lh">const someObject = {<br/>     p1:"hello 1",<br/>     p2:"hello 2"<br/>}</span><span id="b3a6" class="ld jp hi ku b fi li lf l lg lh">const anotherObject = <strong class="ku hj">new Object</strong>();<br/>anotherObject.p1 = "from new 1";<br/>anotherObject.p2 = "from new 2";</span><span id="a34b" class="ld jp hi ku b fi li lf l lg lh">console.log(typeof(someObject)); //they both print "object"<br/>console.log(typeof(anotherObject));</span></pre><p id="52b9" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">对于对象类型，我们得到“值”、“条目”和“键”方法，如下所示。</p><pre class="kv kw kx ky fd kz ku la lb aw lc bi"><span id="24bd" class="ld jp hi ku b fi le lf l lg lh">const someObject = {<br/>     p1:"hello 1",<br/>     p2:"hello 2"<br/>}</span><span id="5312" class="ld jp hi ku b fi li lf l lg lh">console.log(<strong class="ku hj">Object.values</strong>(someObject));//[ 'hello 1', 'hello 2' ]<br/>console.log(<strong class="ku hj">Object.keys</strong>(someObject));//[ 'p1', 'p2' ]<br/>console.log(<strong class="ku hj">Object.entries</strong>(someObject));//[ [ 'p1', 'hello 1' ], [ 'p2', 'hello 2' ] ]</span></pre><p id="0cc8" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">当您将对象创建为常量时，对象变量本身将是常量，但属性不是。</p><pre class="kv kw kx ky fd kz ku la lb aw lc bi"><span id="2f1e" class="ld jp hi ku b fi le lf l lg lh"><strong class="ku hj">const </strong>someObject = {<br/>     p1:"hello 1",<br/>     p2:"hello 2"<br/>}</span><span id="e10f" class="ld jp hi ku b fi li lf l lg lh">//This will throw an "Assignment to constant variable" error.someObject <strong class="ku hj">= {p1:"hey"};</strong></span><span id="24e1" class="ld jp hi ku b fi li lf l lg lh">//but this will work<br/><strong class="ku hj">const </strong>someObjec2t = {<br/>     p1:"hello 1",<br/>     p2:"hello 2"<br/>}<br/>someObject2<strong class="ku hj">.p1</strong> = "modifed";</span></pre><p id="6ffc" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如果希望整个对象是一个常量，可以执行以下操作，这不会引发错误，但不会更改属性:</p><pre class="kv kw kx ky fd kz ku la lb aw lc bi"><span id="2e66" class="ld jp hi ku b fi le lf l lg lh">const obj1 = <strong class="ku hj">Object.freeze</strong>({prop1: 'hey const 1', prop2: "hey const 2"});<br/>obj1.prop1 = "CHANGED IT";<br/>console.log(obj1.prop1);//prints "hey const 1"</span></pre><p id="63a7" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">作为Object的实例，我们的对象将拥有一些方法，即使我们没有创建它们，我们也可以使用它们。其中一个允许我们检查一个对象是否有属性。</p><pre class="kv kw kx ky fd kz ku la lb aw lc bi"><span id="8555" class="ld jp hi ku b fi le lf l lg lh">const obj1 = {<br/>     p1 : "I am 1",<br/>     p2 : "I am 2"<br/>}</span><span id="f3d9" class="ld jp hi ku b fi li lf l lg lh">console.log(<strong class="ku hj">obj1.hasOwnProperty("p3")</strong>);//false<br/>console.log(obj1.hasOwnProperty("p1"));//true</span></pre><h1 id="7b3e" class="jo jp hi bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">4-克隆对象-引用类型</h1><p id="840c" class="pw-post-body-paragraph iq ir hi is b it km iv iw ix kn iz ja jb ko jd je jf kp jh ji jj kq jl jm jn hb bi translated">对象是引用类型。这意味着当我们复制或传递它们时，我们实际上是在移动保存对象的内存引用，而不是对象(及其内容)的副本。当我们将一个对象变量赋给另一个对象变量时，对象“说”的是“这里，这是我的数据所在的盒子，我会与你分享它，如果你改变它，你也会为我改变它。”</p><pre class="kv kw kx ky fd kz ku la lb aw lc bi"><span id="7a13" class="ld jp hi ku b fi le lf l lg lh">//create object and primitive<br/>const obj<strong class="ku hj">1</strong> = { p:<strong class="ku hj">1</strong>};<br/>const x = <strong class="ku hj">1</strong>;</span><span id="c839" class="ld jp hi ku b fi li lf l lg lh">//assign them to new variables<br/>const obj2 = obj1;<br/>let y = x;</span><span id="4087" class="ld jp hi ku b fi li lf l lg lh">//change the recently created variables<br/>obj<strong class="ku hj">2</strong>.p = <strong class="ku hj">2</strong>;<br/>y = <strong class="ku hj">2</strong>;</span><span id="8c7e" class="ld jp hi ku b fi li lf l lg lh">//check the values of all<br/>console.log("objects");<br/><strong class="ku hj">console.log(obj1.p);// 2, the content in the box has changed to 2<br/>console.log(obj2.p);//2</strong><br/>console.log("primitives")<br/><strong class="ku hj">console.log(x);//1<br/>console.log(y);//2</strong></span></pre><p id="0550" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">因此，如果我们想要的是一个行为类似于原始类型副本的副本，我们需要做我们称之为<strong class="is hj">深度克隆</strong>的事情。使用深度克隆，所有属性都将获得一个新副本。</p><pre class="kv kw kx ky fd kz ku la lb aw lc bi"><span id="cb65" class="ld jp hi ku b fi le lf l lg lh">const obj1 = { p:1};<br/>const obj2 = <strong class="ku hj">JSON.parse(JSON.stringify(obj1))</strong>;</span><span id="71c6" class="ld jp hi ku b fi li lf l lg lh">obj2.p = 2;</span><span id="0cf7" class="ld jp hi ku b fi li lf l lg lh">console.log(obj1.p); //1<br/>console.log(obj2.p); //2</span></pre><p id="bb6c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我已经谈到了对象的常规赋值，它只是与另一个变量共享内存位置，还谈到了使用JSON获得一个<strong class="is hj">深度克隆</strong>。还有一种两者兼而有之的叫做<strong class="is hj">浅克隆</strong>。在浅层克隆中，对象的基本元素将被复制，但引用类型仍将共享内存位置。</p><p id="aa2e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">请参见以下示例:</p><p id="4792" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">原始(值):</p><pre class="kv kw kx ky fd kz ku la lb aw lc bi"><span id="10e8" class="ld jp hi ku b fi le lf l lg lh">let obj1 = { p:1};<br/>let obj2 = <strong class="ku hj">Object.assign({},obj1)</strong>; // or <strong class="ku hj">{...obj1};</strong><br/>obj2.p = 2;<br/>console.log(obj1);//{ p: 1 }<br/>console.log(obj2);{ p: 2}</span></pre><p id="eeac" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">数组(引用)。请注意将属性重新指定给新数组和更改数组本身之间的区别。改变数组本身会影响两个对象，因为我们改变了数组所在的盒子的内容。对于obj2，我们为它分配了一个新数组:</p><pre class="kv kw kx ky fd kz ku la lb aw lc bi"><span id="0ed0" class="ld jp hi ku b fi le lf l lg lh">let obj1 = { p:[1,2,3,4]};<br/>let obj2 = Object.assign({},obj1);<br/>let obj3 = Object.assign({},obj1);</span><span id="cf8b" class="ld jp hi ku b fi li lf l lg lh">obj2.p <strong class="ku hj">= [5,6];</strong><br/>obj3.<strong class="ku hj">p.push(1000);</strong></span><span id="b732" class="ld jp hi ku b fi li lf l lg lh">console.log(obj<strong class="ku hj">1</strong>);<br/>console.log(obj<strong class="ku hj">2</strong>);<br/>console.log(obj<strong class="ku hj">3</strong>);</span><span id="a45b" class="ld jp hi ku b fi li lf l lg lh">//the above will print:<br/>//{ p: [ 1, 2, 3, 4, <strong class="ku hj">1000</strong> ] }<br/>//{ p: [ 5, 6 ] }<br/>//{ p: [ 1, 2, 3, 4, <strong class="ku hj">1000 </strong>] }</span></pre><p id="d05a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">一个对象(引用):</p><pre class="kv kw kx ky fd kz ku la lb aw lc bi"><span id="b1ec" class="ld jp hi ku b fi le lf l lg lh">let <strong class="ku hj">obj1 = { p:{a:1, b:2, c:["a"]}};</strong><br/>let obj2 = Object.assign({},obj1);<br/>let obj3 = Object.assign({},obj1);</span><span id="91c6" class="ld jp hi ku b fi li lf l lg lh">obj2.p = {a:2, b:3, c: ["b"]};</span><span id="bc3a" class="ld jp hi ku b fi li lf l lg lh">obj3.<strong class="ku hj">p.a</strong> =<strong class="ku hj"> 3</strong>;//Notice this one will change for both<br/>obj3.<strong class="ku hj">p.c.push</strong>("AAAAAAA");</span><span id="7937" class="ld jp hi ku b fi li lf l lg lh">console.log(obj1);<br/>console.log(obj2);<br/>console.log(obj3);</span><span id="c078" class="ld jp hi ku b fi li lf l lg lh">//Will print<br/>{ p: { <strong class="ku hj">a: 3</strong>, b: 2, c: [ 'a', <strong class="ku hj">'AAAAAAA'</strong> ] } }<br/>{ p: { a: 2, b: 3, c: [ 'b' ] } }<br/>{ p: { <strong class="ku hj">a: 3</strong>, b: 2, c: [ 'a', <strong class="ku hj">'AAAAAAA'</strong> ] } }</span></pre><h1 id="9554" class="jo jp hi bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">5 —一般的面向对象编程</h1><p id="9395" class="pw-post-body-paragraph iq ir hi is b it km iv iw ix kn iz ja jb ko jd je jf kp jh ji jj kq jl jm jn hb bi translated">在OOP中，我们以对象为中心编写代码。OOP将提供封装、抽象、继承和多态。</p><p id="a08e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">封装</strong>:拥有方法和它们所作用的数据，并对外隐藏细节。</p><p id="371c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">抽象</strong>:对对象隐藏细节降低了复杂性。函数可以使用对象及其方法，而不必知道它们是如何工作的。</p><p id="2caf" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">继承</strong>:你可以利用已经执行你需要的功能的对象(或类)，这样你就不必重新发明轮子。</p><p id="cd65" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">多态性</strong>:不同的类(对象)可以使用同一个接口。方法重载就是一个例子。方法名是相同的，但是根据传递给它的参数，执行的事情会有所不同。</p><h1 id="6ffb" class="jo jp hi bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">JavaScript中的面向对象编程</h1><p id="aec3" class="pw-post-body-paragraph iq ir hi is b it km iv iw ix kn iz ja jb ko jd je jf kp jh ji jj kq jl jm jn hb bi translated">我们已经看到了面向对象的基本方式。我前面提到过，当我们创建一个对象时，我们正在创建一个object类型的实例。对象有一些静态方法(需要通过对象使用)和一些实例方法(可以通过实例调用)。让我们看几个方法，我们的对象可以使用，因为对象。</p><pre class="kv kw kx ky fd kz ku la lb aw lc bi"><span id="d87d" class="ld jp hi ku b fi le lf l lg lh">let ob = { p1:"hello", p2:"good morning", p3:"bye"};<br/>//STATIC Object.isFrozen()<br/>console.log(<strong class="ku hj">Object.isFrozen(ob)</strong>);//false</span><span id="8e0e" class="ld jp hi ku b fi li lf l lg lh">//INSTANCE Object.prototype.hasOwnProperty()<br/>console.log(<strong class="ku hj">ob.hasOwnProperty("p1")</strong>);//true</span></pre><p id="8ab8" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">让我们看看如何用OOP获得更多。</p><p id="373e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">用构造函数创建对象</strong></p><p id="e671" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们将使用一些函数来创建新对象。标准是以大写字母开始命名这些函数。</p><p id="7399" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">下面我们正在创建一个新的车辆类型的对象。</p><pre class="kv kw kx ky fd kz ku la lb aw lc bi"><span id="4cbf" class="ld jp hi ku b fi le lf l lg lh">function <strong class="ku hj">V</strong>ehicle(typearg, yeararg){<br/>     <strong class="ku hj">this</strong>.type = typearg;<br/>     <strong class="ku hj">this</strong>.year = yeararg;<br/>}</span><span id="618e" class="ld jp hi ku b fi li lf l lg lh">let cartype = <strong class="ku hj">new Vehicle</strong>("car", 2003);</span><span id="1b07" class="ld jp hi ku b fi li lf l lg lh">console.log(<strong class="ku hj">Object.getPrototypeOf(cartype)</strong>); //Vehicle {}<br/>console.log(cartype.type); //car<br/>console.log(cartype instanceof Vehicle); //true<br/>console.log(Vehicle.prototype); //Vehicle {}</span></pre><p id="a202" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">对车辆原型更详细的观察</p><pre class="kv kw kx ky fd kz ku la lb aw lc bi"><span id="c3bb" class="ld jp hi ku b fi le lf l lg lh"><em class="lj">{constructor: ƒ}<br/></em>constructor: <em class="lj">ƒ Vehicle(typearg, yeararg)<br/></em>arguments: null<br/>caller: null<br/>length: 2<br/>name: “Vehicle”<br/>prototype: {constructor: <em class="lj">ƒ</em>}<br/>__proto__: <em class="lj">ƒ ()</em></span></pre><p id="d131" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如果我们希望原型有一个变量在车辆的所有实例中共享(而不是每个实例都有自己的副本),我们可以这样做:</p><pre class="kv kw kx ky fd kz ku la lb aw lc bi"><span id="7467" class="ld jp hi ku b fi le lf l lg lh">function Vehicle(typearg, yeararg){<br/>     this.type = typearg;<br/>     this.year = yeararg;<br/>}<br/>Vehicle.<strong class="ku hj">prototype.maxwheels</strong> = 6;<br/>let cartype = new Vehicle("car", 2003);<br/>console.log(Vehicle.prototype);</span><span id="d9c7" class="ld jp hi ku b fi li lf l lg lh">//the vehicle prototype will not look like this<br/><em class="lj">{</em><strong class="ku hj"><em class="lj">maxwheels: 6</em></strong><em class="lj">, constructor: ƒ}<br/></em>maxwheels: 6<br/>constructor: <em class="lj">ƒ Vehicle(typearg, yeararg)<br/></em>__proto__: Object</span></pre><p id="8330" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">让我们在原型改变后检查实例。记得我说过，添加到原型的属性将在不同的实例之间共享，所以它并不真正属于实例。</p><pre class="kv kw kx ky fd kz ku la lb aw lc bi"><span id="a32b" class="ld jp hi ku b fi le lf l lg lh">function Vehicle(typearg, yeararg){<br/>     this.type = typearg;<br/>     this.year = yeararg;<br/>}<br/><strong class="ku hj">Vehicle.prototype.maxwheels = 6;</strong></span><span id="61c0" class="ld jp hi ku b fi li lf l lg lh">let cartype = new Vehicle("car", 2003);</span><span id="58e6" class="ld jp hi ku b fi li lf l lg lh">console.log(cartype.maxwheels); //6</span><span id="8305" class="ld jp hi ku b fi li lf l lg lh">console.log(cartype.<strong class="ku hj">hasOwnProperty</strong>("<strong class="ku hj">type</strong>")); //true<br/>console.log(cartype.<strong class="ku hj">hasOwnProperty</strong>("<strong class="ku hj">maxwheels</strong>"));//<strong class="ku hj">false</strong></span></pre><p id="14b8" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">注意:您也可以通过赋值将原型设置为一个全新的原型，但是如果您这样做，您需要在其中包含构造函数(constructor:Vehicle ),因为它将被赋值移除。</p><p id="c589" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">就像你可以给原型添加一个属性一样，你也可以添加一个方法。</p><pre class="kv kw kx ky fd kz ku la lb aw lc bi"><span id="9859" class="ld jp hi ku b fi le lf l lg lh">function Vehicle(typearg, yeararg){<br/>     this.type = typearg;<br/>     this.year = yeararg;<br/>}</span><span id="ceb4" class="ld jp hi ku b fi li lf l lg lh">Vehicle.prototype.maxwheels = 6;<br/>Vehicle.prototype.<strong class="ku hj">printMyInfo </strong>= function () {<br/>     console.log(this.type);<br/>     console.log(this.year);<br/>     console.log(this.maxwheels);<br/>}</span><span id="e758" class="ld jp hi ku b fi li lf l lg lh">let cartype = new Vehicle("car", 2003);<br/>cartype.<strong class="ku hj">printMyInfo</strong>();</span><span id="c57b" class="ld jp hi ku b fi li lf l lg lh">//prints<br/>car<br/>2003<br/>6</span></pre><p id="6fc4" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">不要为此使用箭头函数，因为箭头函数不会得到它们自己的“this”,“this”将引用全局范围。即使是常规函数，我们也会对“这个”得到的东西感到惊讶。请参见下面的示例。</p><pre class="kv kw kx ky fd kz ku la lb aw lc bi"><span id="3c3c" class="ld jp hi ku b fi le lf l lg lh">function Vehicle(typearg, yeararg){<br/>     this.type = typearg;<br/>     this.year = yeararg;<br/>}<br/>Vehicle.prototype.maxwheels = 6;<br/>Vehicle.prototype.<strong class="ku hj">functionWithFunction </strong>= function () {<br/>   console.log(<strong class="ku hj">this</strong>);<br/>   function <strong class="ku hj">innerFunction</strong>() {<br/>       console.log(<strong class="ku hj">this</strong>);<br/>   }<br/>   <strong class="ku hj">innerFunction</strong>();<br/>}<br/>let cartype = new Vehicle("car", 2003);<br/>cartype.functionWithFunction();</span><span id="8ed3" class="ld jp hi ku b fi li lf l lg lh">//both functions will not have the same value for "this"<br/>//the inner function has this set to global.<br/><strong class="ku hj">Vehicle </strong>{ type: 'car', year: 2003 }<br/><strong class="ku hj">Object [global]</strong> {<br/>  global: [Circular],<br/>  clearInterval: [Function: clearInterval],<br/>  clearTimeout: [Function: clearTimeout],<br/>  setInterval: [Function: setInterval],<br/>  setTimeout: [Function: setTimeout] {<br/>    [Symbol(nodejs.util.promisify.custom)]: [Function]<br/>  },<br/>  queueMicrotask: [Function: queueMicrotask],<br/>  clearImmediate: [Function: clearImmediate],<br/>  setImmediate: [Function: setImmediate] {<br/>    [Symbol(nodejs.util.promisify.custom)]: [Function]<br/>  }<br/>}</span></pre><p id="a096" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这意味着我们将无法通过内部函数中的“this”来访问对象属性。要解决这个问题，我们可以这样做:</p><pre class="kv kw kx ky fd kz ku la lb aw lc bi"><span id="4e8c" class="ld jp hi ku b fi le lf l lg lh">function Vehicle(typearg, yeararg){<br/>     this.type = typearg;<br/>     this.year = yeararg;<br/>}<br/>Vehicle.prototype.maxwheels = 6;<br/>Vehicle.prototype.functionWithFunction = function () <br/>     console.log(this);<br/>     c<strong class="ku hj">onst self = this;</strong><br/>     function innerFunction() {<br/>          console.log(<strong class="ku hj">self</strong>);<br/>     }<br/>     innerFunction();<br/>}</span><span id="4192" class="ld jp hi ku b fi li lf l lg lh">let cartype = new Vehicle("car", 2003);cartype.functionWithFunction();</span><span id="1f0c" class="ld jp hi ku b fi li lf l lg lh">//prints<br/>Vehicle { type: 'car', year: 2003 }<br/>Vehicle { type: 'car', year: 2003 }</span></pre><p id="7488" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">那么，如果我们想拥有另一个继承自vehicle的小型Vehicle类型的对象呢？这就是我们如何用构造函数获得继承。</p><pre class="kv kw kx ky fd kz ku la lb aw lc bi"><span id="dd94" class="ld jp hi ku b fi le lf l lg lh">function <strong class="ku hj">Vehicle</strong>(typearg, yeararg){<br/>     this.type = typearg;<br/>     this.year = yeararg;<br/>}</span><span id="1d70" class="ld jp hi ku b fi li lf l lg lh">Vehicle.prototype.<strong class="ku hj">printType </strong>= function () {<br/>     console.log(this.type);<br/>     console.log(this.year);<br/>}</span><span id="6545" class="ld jp hi ku b fi li lf l lg lh">//new constructor function inheriting from Vehicle<br/>function <strong class="ku hj">SmallVehicle</strong>(<strong class="ku hj">wheels, type, year</strong>) {<br/>     <strong class="ku hj">Vehicle.call(this, type, year);</strong><br/>     this.wheels = wheels;<br/>}<br/><strong class="ku hj">SmallVehicle.prototype = Object.create(Vehicle.prototype);</strong><br/>Object.<strong class="ku hj">defineProperty</strong>(SmallVehicle.prototype, 'constructor', {<br/>    <strong class="ku hj"> value: SmallVehicle,</strong><br/>     enumerable: false,<br/>     writable: true });</span><span id="879a" class="ld jp hi ku b fi li lf l lg lh">let small = new SmallVehicle(2, "small", 2006);<br/>small.<strong class="ku hj">printType</strong>();</span></pre><p id="f687" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如果需要，我们可以添加针对小型车辆原型的功能。在我看来，上述作品得到继承，但它有点丑陋。我更喜欢上课。</p><p id="4a40" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">用类创建对象</strong></p><p id="0e95" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们在JavaScript中并没有真正的类，因为在幕后它们会被转化为我们见过的构造函数，但是就编码而言，它们看起来很像类。</p><p id="0c9c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">上面带有额外静态方法的Vehicle和SmallVehicle类如下所示。</p><pre class="kv kw kx ky fd kz ku la lb aw lc bi"><span id="0de1" class="ld jp hi ku b fi le lf l lg lh"><strong class="ku hj">class Vehicle</strong>{<br/>     <strong class="ku hj">constructor</strong>(typearg, yeararg){<br/>          this.type = typearg;<br/>          this.year = yeararg;<br/>     }<br/>     //getter<br/>     <strong class="ku hj">get </strong>theType(){<br/>          return this.type;<br/>     }<br/>     //setter<br/>     <strong class="ku hj">set </strong>theYear(year){<br/>          this.year = year;<br/>     }<br/>     //Just a method<br/>     printTypeYear (){<br/>          console.log(this.type);<br/>          console.log(this.year);<br/>     }</span><span id="4872" class="ld jp hi ku b fi li lf l lg lh">     static printSomething(){<br/>          console.log("printing something");<br/>     }<br/>}</span><span id="9c6a" class="ld jp hi ku b fi li lf l lg lh"><strong class="ku hj">class SmallVehicle extends Vehicle</strong>{<br/>     <strong class="ku hj">constructor </strong>(wheels, type, year){<br/>          <strong class="ku hj">super</strong>(type, year); //<strong class="ku hj">call super before using "this"</strong><br/>          this.wheels = wheels;<br/>     }<br/>}</span><span id="3c0a" class="ld jp hi ku b fi li lf l lg lh">let small = <strong class="ku hj">new </strong>SmallVehicle(2, "small", 2006);<br/>small.printTypeYear();<br/>console.log(small.wheels);<br/>small.<strong class="ku hj">theYear </strong>= 2011; //use the getter<br/>small.printTypeYear();<br/>SmallVehicle.printSomething(); //static method</span><span id="a15d" class="ld jp hi ku b fi li lf l lg lh">//the above will print<br/>small<br/>2006<br/>2<br/>small<br/>2011<br/>printing something</span></pre><p id="3e3b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">注意:不要在构造函数中放入超过你需要的代码。构造函数将在每次使用new创建新对象时运行。</p><p id="7217" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">注意:你不必在getter和setter方法的名称中使用get和set，但这是一个好主意(尽管我上面没有提到)。</p><h1 id="a2b9" class="jo jp hi bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">7 —使用什么类型的OOP？</h1><p id="0320" class="pw-post-body-paragraph iq ir hi is b it km iv iw ix kn iz ja jb ko jd je jf kp jh ji jj kq jl jm jn hb bi translated">有些人喜欢使用构造函数，有些人喜欢类语法。这是一个偏好的问题。我更喜欢这些类，因为我习惯了C#，它看起来更熟悉(也更简洁)。</p><p id="7a45" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">感谢您的阅读。我希望这有助于澄清事情。</p></div></div>    
</body>
</html>