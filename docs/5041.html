<html>
<head>
<title>Microservices Best Practices Every Developer Should Follow</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">每个开发人员都应该遵循的微服务最佳实践</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/microservices-best-practices-every-developer-should-follow-a977740dc70a?source=collection_archive---------0-----------------------#2021-08-23">https://medium.com/nerd-for-tech/microservices-best-practices-every-developer-should-follow-a977740dc70a?source=collection_archive---------0-----------------------#2021-08-23</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/6f5b03c1f362f4473086b625d5bcd156.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zHOnYsGws6Bb17fGJr3uow.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">图片来自- <a class="ae iu" href="https://www.sv.uio.no/psi/english/research/projects/human-time-data/documents/data-management/best-practice/" rel="noopener ugc nofollow" target="_blank">服务编号</a></figcaption></figure><p id="af62" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这篇文章将引导你了解开发人员在从事微服务项目时应该遵循的9个最佳实践。让我们深入了解一下每一个。</p><h1 id="664d" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">1.拥有领域驱动的设计</h1><p id="2282" class="pw-post-body-paragraph iv iw hi ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated">每个服务都应该有<strong class="ix hj">自己定义好的范围</strong>。从您的服务中删除任何与其范围不相关的内容，只保留实现特定服务目标所必需的元素。</p><p id="f163" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在设计微服务时，确保你有一个全新的领域驱动的设计。如果你已经在运行微服务，那就重新思考一下设计是否是域驱动的？您可能不需要重写所有内容，但是您可以做一些小的调整，使它成为一个更好的隔离服务，具有独立的、定义良好的范围。</p><blockquote class="kw kx ky"><p id="0d5e" class="iv iw kz ix b iy iz ja jb jc jd je jf la jh ji jj lb jl jm jn lc jp jq jr js hb bi translated">使用来自几个域的模块来创建一个单一的服务是一个非常糟糕的实践。</p></blockquote><h1 id="159f" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">2.不要硬编码值</h1><p id="4938" class="pw-post-body-paragraph iv iw hi ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated">假设服务“A”调用服务“B”。在这种情况下，为了找到服务“B”而将服务“B”的地址硬编码在服务“A”中是一种不好的做法。因为它最初可能工作得很好，但是如果网络团队决定改变服务“B”的主机名或IP地址，服务“A”将无法定位服务“B”，因为它是硬编码的。</p><p id="022d" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">因此，不应硬编码外部服务的地址。为此，您应该利用服务发现工具。</p><h1 id="3af2" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">3.维护日志记录</h1><blockquote class="kw kx ky"><p id="b8b3" class="iv iw kz ix b iy iz ja jb jc jd je jf la jh ji jj lb jl jm jn lc jp jq jr js hb bi translated">保持无日志是可怕的，但是有太多的日志也是不好的。</p></blockquote><p id="6e6a" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如果你不记录日志，你永远不会知道哪里出错了。另一方面，假设服务“A”调用服务“B”，且服务“B”调用服务“C”。如果服务“C”失败，则错误被记录在服务“C”中，并且请求被返回给服务“B”。然后，由于服务“B”返回错误，服务“A”也记录相同的错误。</p><p id="b2cd" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">因此，在上面的场景中，相同的错误记录在三个不同的位置。所以这显然是一种不好的做法，对吗？</p><p id="5f6e" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">所以解决的办法是“<strong class="ix hj">快失败，晚日志！”</strong>。如果某个东西失败了，立即返回，不要到处日志。仅记录您启动流程的错误。因此，对于上述场景，您应该只在服务“A”中记录错误。</p><p id="9dc3" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">此外，您必须用一些附加信息记录错误，以找出错误出在哪里。为此，您可以使用一个<strong class="ix hj">相关ID </strong>。</p><p id="585e" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">关联ID是一个唯一的、随机生成的标识符值，它被添加到每个请求和响应中。当您在微服务架构中调用其他服务时，初始关联ID被传递给其他服务。如果该服务调用另一个服务，相关ID也将被传递给该服务。这有助于我们找出微服务架构中实际发生错误的地方。</p><p id="1170" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">但是要确保在记录的时候不要遗漏任何信息。下面列出了一些可以添加到日志语句中以使其更容易理解的字段，</p><ul class=""><li id="a193" class="ld le hi ix b iy iz jc jd jg lf jk lg jo lh js li lj lk ll bi translated">日期和时间</li><li id="a0f9" class="ld le hi ix b iy lm jc ln jg lo jk lp jo lq js li lj lk ll bi translated">服务器的IP地址</li><li id="fbfe" class="ld le hi ix b iy lm jc ln jg lo jk lp jo lq js li lj lk ll bi translated">客户端请求的IP地址</li><li id="5481" class="ld le hi ix b iy lm jc ln jg lo jk lp jo lq js li lj lk ll bi translated">服务的名称</li><li id="2df2" class="ld le hi ix b iy lm jc ln jg lo jk lp jo lq js li lj lk ll bi translated">日志级别</li><li id="ca21" class="ld le hi ix b iy lm jc ln jg lo jk lp jo lq js li lj lk ll bi translated">堆栈错误</li></ul><h1 id="b8b1" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">4.版本控制</h1><p id="c256" class="pw-post-body-paragraph iv iw hi ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated">久而久之，我们会根据需要对我们的服务做一些修改。因此，可能会提供同一服务的多个版本。因此，其中一个服务版本可能会破坏系统，而另一个版本可能会包含bug补丁，等等。因此，<strong class="ix hj">需要一种正确的版本化方法</strong>来确定该版本的服务是否与该系统兼容。因此，在这一节中，我们将看看一种叫做<strong class="ix hj">语义版本控制</strong>的常见版本控制技术。</p><p id="ca14" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">语义版本</strong>是由三部分组成的数字，格式为<strong class="ix hj"> X.Y.Z </strong>，其中:</p><ul class=""><li id="9832" class="ld le hi ix b iy iz jc jd jg lf jk lg jo lh js li lj lk ll bi translated">主<strong class="ix hj">版本由字母<strong class="ix hj"> X </strong>表示。</strong></li><li id="e9f9" class="ld le hi ix b iy lm jc ln jg lo jk lp jo lq js li lj lk ll bi translated">一个<strong class="ix hj">次要</strong>版本由字母<strong class="ix hj"> Y </strong>表示。</li><li id="18b4" class="ld le hi ix b iy lm jc ln jg lo jk lp jo lq js li lj lk ll bi translated">一个<strong class="ix hj">贴片</strong>由字母<strong class="ix hj"> Z </strong>表示。</li></ul><p id="5157" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">所以，语义版本控制是以<strong class="ix hj"> Major的形式出现的。未成年人.补丁</strong></p><figure class="ls lt lu lv fd ij er es paragraph-image"><div class="er es lr"><img src="../Images/37a68b9442e1259559e6dc386cec550c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1048/format:webp/1*c2lrK2Bqvntq1p-frD2KcQ.png"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">图片来自—<a class="ae iu" href="https://www.geeksforgeeks.org/introduction-semantic-versioning/" rel="noopener ugc nofollow" target="_blank">geekforgeeks.org</a></figcaption></figure><p id="70c2" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">提到语义版本化时要记住的几点:</strong></p><ul class=""><li id="6ee0" class="ld le hi ix b iy iz jc jd jg lf jk lg jo lh js li lj lk ll bi translated">因为一开始没有进行bug修复，所以初始版本从0.1.0开始，而不是0.0.1。我们从一组特性开始，作为项目的初稿。</li><li id="4c7a" class="ld le hi ix b iy lm jc ln jg lo jk lp jo lq js li lj lk ll bi translated">1.0.0将是第一个稳定版本。在1.0.0之前，只有开发阶段，在此期间，您专注于完成工作。</li></ul><blockquote class="kw kx ky"><p id="1ea4" class="iv iw kz ix b iy iz ja jb jc jd je jf la jh ji jj lb jl jm jn lc jp jq jr js hb bi translated"><strong class="ix hj">注意:-【强制升级】</strong>是我们迁移到另一个版本时要重点关注的一个概念。</p></blockquote><p id="a0b9" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">让我们通过一个例子来理解这一点，</p><p id="3c23" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">假设您有一个名为A的服务，这个服务A调用服务B，服务B需要更新。在此更新过程中，您正在修改服务B的数据库结构。因此，服务请求会有所不同。如果部署服务b的更新版本，服务A将会中断。</p><p id="5008" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">那么我们该如何解决这个问题呢？</p><p id="38f6" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这里可以使用版本控制，您可以增加主版本号，并将其作为单独的服务进行部署(现在我们有两个版本的服务B)。但是，我们应该继续允许旧版本的流量，并警告我们的客户必须在特定日期之前升级到新版本，因为旧版本的服务B将在该日期之后关闭。当那一天到来时，或者在您的所有客户端都迁移到新版本之后，您可以关闭旧版本。</p><p id="9d00" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">有另一种方法可以解决这个问题。首先，我们应该有更多的旧版本实例和更少的新版本实例。当客户升级到新版本时，您可以增加新版本实例的数量，同时减少旧版本实例的数量。您可以用这种方式处理您的服务，而不会对您的客户造成任何干扰。这种方法称为<strong class="ix hj">弹性机构</strong>。</p><h1 id="ad62" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">5.认证和授权</h1><p id="b30f" class="pw-post-body-paragraph iv iw hi ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated">微服务架构中的一个请求可能会通过许多服务。因此，如果每个服务都试图验证用户，您的往返行程将会更长。</p><blockquote class="kw kx ky"><p id="33c1" class="iv iw kz ix b iy iz ja jb jc jd je jf la jh ji jj lb jl jm jn lc jp jq jr js hb bi translated"><strong class="ix hj">例如:- </strong>假设您正在使用OAuth令牌来验证消费者，如果您有三个服务，每个服务需要20毫秒来验证一个用户，那么系统将需要60毫秒来验证用户。</p></blockquote><p id="e4c7" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">最佳实践是创建一个单独的身份验证服务，并将所有进入服务层的请求定向到该服务。如果验证成功，您可以将他们引向路径的其余部分。这被称为<strong class="ix hj">【强制转发】</strong>。通过这种技术，您可以防止一些延迟。</p><h1 id="04cf" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">6.属国</h1><p id="4b87" class="pw-post-body-paragraph iv iw hi ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated">微服务世界里的每一项服务都应该能够独立运行，不依赖他人。它们必须被视为孤立的单元。</p><blockquote class="kw kx ky"><p id="dbb7" class="iv iw kz ix b iy iz ja jb jc jd je jf la jh ji jj lb jl jm jn lc jp jq jr js hb bi translated"><strong class="ix hj">考虑以下场景:</strong>我们有两个服务，A和B。如果A依赖于B，那么当我们想要部署A时，在生产中未能部署B将会导致大量问题。</p></blockquote><p id="ce29" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">因此，<strong class="ix hj">独立是必要的</strong>。这些服务中的每一个都应该能够彼此独立地部署，没有共享的依赖关系。因此，我们应该能够独立地启动服务A或B，而不用担心破坏其他服务。</p><h1 id="dc76" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">7.签订可执行的合同</h1><p id="79ab" class="pw-post-body-paragraph iv iw hi ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated">这是一个消费者和公司签订合同的过程。这份合同是可执行的，因为无论如何都不能撕毁。一组定义良好的测试用例/测试脚本/请求可以包含在这个契约中。每次构建应用程序时，都会执行这些测试。如果所有的测试用例都通过了，你就没有破坏任何消费者。但是，如果这些测试中有任何一个失败了，您可以修复它们。</p><h1 id="3837" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">8.容错</h1><p id="a2b6" class="pw-post-body-paragraph iv iw hi ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated">容错是指即使一个或多个组件出现故障，系统仍能保持正常运行的能力。由于微服务架构包含多种服务，因此我们有各种故障场景。我们必须有效地管理发生的任何故障。</p><p id="6a43" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们需要一个健壮的容错方法。如果服务超时、失败缓慢或需要很长时间才能做出反应，您必须确保它快速失败，以避免创建等待服务响应的队列。</p><p id="9d71" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">有几种模式可以实现容错，如断路器、超时、重试等。</p><h1 id="af93" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">9.证明文件</h1><p id="d09d" class="pw-post-body-paragraph iv iw hi ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated">你应该记录你所做的一切。这样其他人(开发者，你的服务的用户等等。)能理解你的所作所为。你可以使用<a class="ae iu" href="https://swagger.io/" rel="noopener ugc nofollow" target="_blank"> Swagger </a>以技术的方式写文档。Swagger会将您输入到Swagger控制台的任何技术术语转换成有吸引力的文档。它还为用户提供了一个用户界面(UI ),以便他们可以参考它并尝试各种服务。</p><h2 id="8dfb" class="lw ju hi bd jv lx ly lz jz ma mb mc kd jg md me kh jk mf mg kl jo mh mi kp mj bi translated">继续学习❤️</h2></div><div class="ab cl mk ml gp mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="hb hc hd he hf"><h1 id="bdb5" class="jt ju hi bd jv jw mr jy jz ka ms kc kd ke mt kg kh ki mu kk kl km mv ko kp kq bi translated">参考</h1><figure class="ls lt lu lv fd ij"><div class="bz dy l di"><div class="mw mx l"/></div></figure><div class="my mz ez fb na nb"><a href="https://www.geeksforgeeks.org/introduction-semantic-versioning/" rel="noopener  ugc nofollow" target="_blank"><div class="nc ab dw"><div class="nd ab ne cl cj nf"><h2 class="bd hj fi z dy ng ea eb nh ed ef hh bi translated">语义版本控制介绍- GeeksforGeeks</h2><div class="ni l"><h3 class="bd b fi z dy ng ea eb nh ed ef dx translated">语义版本化(也称为SemVer)是一个版本化系统，在过去几年中一直处于上升趋势。它…</h3></div><div class="nj l"><p class="bd b fp z dy ng ea eb nh ed ef dx translated">www.geeksforgeeks.org</p></div></div><div class="nk l"><div class="nl l nm nn no nk np io nb"/></div></div></a></div></div></div>    
</body>
</html>