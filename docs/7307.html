<html>
<head>
<title>Policies as Code in Kubernetes using jsPolicy</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用 jsPolicy 在 Kubernetes 中将策略作为代码</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/policies-as-code-in-kubernetes-using-jspolicy-8d358d064bfd?source=collection_archive---------0-----------------------#2022-09-24">https://medium.com/nerd-for-tech/policies-as-code-in-kubernetes-using-jspolicy-8d358d064bfd?source=collection_archive---------0-----------------------#2022-09-24</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="7ddb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">使用 jsPolicy 在 Kubernetes 中进行开发</p><p id="caa4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">库伯内特星团现在到处都是。要运行 ML 模型，您需要 Kubernetes 集群；要运行数据分析，您需要 Kubernetes 集群；要部署前端应用程序、后端应用程序或任何类型的应用程序，您都需要 Kubernetes 集群。但是您的集群安全吗？您曾经担心过集群的安全性吗？假设您正试图运行一些自动化脚本，它意外地删除了生产中的所有名称空间。嘣，这将是 DevOps 工程师一生中最漫长的一天。甚至想到这一点可能会让 DevOps 的工程师们感到不寒而栗。有办法避免这种情况吗？有没有有效控制这类灾害的方法？jsPolicy 来拯救。jsPolicy 是 Kubernetes 的一个策略引擎，允许您用 JavaScript 或 TypeScript 编写策略。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es jd"><img src="../Images/0a24db18d14f17776e006e1539d1b2c4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Cfejv83uu9oCfh7Y5QXvjg.png"/></div></div><figcaption class="jp jq et er es jr js bd b be z dx translated">jsPolicy 的优势</figcaption></figure><h2 id="bf6f" class="jt ju hi bd jv jw jx jy jz ka kb kc kd iq ke kf kg iu kh ki kj iy kk kl km kn bi translated"><strong class="ak">js policy 的优势</strong></h2><p id="361c" class="pw-post-body-paragraph if ig hi ih b ii ko ik il im kp io ip iq kq is it iu kr iw ix iy ks ja jb jc hb bi translated">a) <strong class="ih hj">闪电般的速度&amp;安全的策略执行</strong> : jsPolicy 通过谷歌的超高速 V8 JavaScript 引擎在一个预先加热的沙盒环境中运行策略。大多数策略执行起来甚至不需要一毫秒。</p><p id="eb58" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">b) <strong class="ih hj">伟大的策略语言</strong> : JavaScript 是为处理和操纵 JSON 对象而生的(简称“JavaScript Object Notation”(！))而 Kubernetes 通过在每个 API 请求期间将您的 YAML 转换为 JSON 来使用 JSON。</p><h1 id="c388" class="kt ju hi bd jv ku kv kw jz kx ky kz kd la lb lc kg ld le lf kj lg lh li km lj bi translated">整个故事是关于什么的？(TLDR)</h1><ol class=""><li id="4158" class="lk ll hi ih b ii ko im kp iq lm iu ln iy lo jc lp lq lr ls bi translated">使用 jsPolicy 保护您的 K8s 集群。</li><li id="77cd" class="lk ll hi ih b ii lt im lu iq lv iu lw iy lx jc lp lq lr ls bi translated">使用 jsPolicy 在 JavaScript 中创建安全策略。</li></ol><h1 id="8434" class="kt ju hi bd jv ku kv kw jz kx ky kz kd la lb lc kg ld le lf kj lg lh li km lj bi translated">先决条件</h1><ol class=""><li id="32c0" class="lk ll hi ih b ii ko im kp iq lm iu ln iy lo jc lp lq lr ls bi translated">一个 Kubernetes 集群(EKS、AKS、Kind 等)。</li></ol><h1 id="e8ba" class="kt ju hi bd jv ku kv kw jz kx ky kz kd la lb lc kg ld le lf kj lg lh li km lj bi translated">故事资源</h1><ol class=""><li id="cef2" class="lk ll hi ih b ii ko im kp iq lm iu ln iy lo jc lp lq lr ls bi translated">GitHub 链接:<a class="ae ly" href="https://github.com/pavan-kumar-99/medium-manifests" rel="noopener ugc nofollow" target="_blank">https://github.com/pavan-kumar-99/medium-manifests</a></li><li id="390a" class="lk ll hi ih b ii lt im lu iq lv iu lw iy lx jc lp lq lr ls bi translated">GitHub 分支:<a class="ae ly" href="https://github.com/pavan-kumar-99/medium-manifests/tree/jsPolicy" rel="noopener ugc nofollow" target="_blank"> jsPolicy </a></li></ol><h2 id="0fe1" class="jt ju hi bd jv jw jx jy jz ka kb kc kd iq ke kf kg iu kh ki kj iy kk kl km kn bi translated">jsPolicy 安装和架构</h2><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es lz"><img src="../Images/cd9f43d3e24ca53d89e09f7fb5c7b37f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*E1G1kWYeNLsosLcKw8RxwA.png"/></div></div><figcaption class="jp jq et er es jr js bd b be z dx translated">jsPolicy 架构</figcaption></figure><h1 id="4f36" class="kt ju hi bd jv ku kv kw jz kx ky kz kd la lb lc kg ld le lf kj lg lh li km lj bi translated">成分</h1><p id="8fcd" class="pw-post-body-paragraph if ig hi ih b ii ko ik il im kp io ip iq kq is it iu kr iw ix iy ks ja jb jc hb bi translated">尽管 jsPolicy 在单个容器中运行其所有组件(当您增加副本数量以获得高可用性时，不考虑副本)，但 jsPolicy 在逻辑上由三个主要组件组成:</p><ul class=""><li id="6bbb" class="lk ll hi ih b ii ij im in iq ma iu mb iy mc jc md lq lr ls bi translated"><a class="ae ly" href="https://www.jspolicy.com/docs/architecture#webhook-manager" rel="noopener ugc nofollow" target="_blank"> Webhook 管理器</a></li><li id="4882" class="lk ll hi ih b ii lt im lu iq lv iu lw iy lx jc md lq lr ls bi translated"><a class="ae ly" href="https://www.jspolicy.com/docs/architecture#v8-javascript-sandbox-pool" rel="noopener ugc nofollow" target="_blank"> V8 JavaScript 沙盒池</a></li><li id="4a8e" class="lk ll hi ih b ii lt im lu iq lv iu lw iy lx jc md lq lr ls bi translated"><a class="ae ly" href="https://www.jspolicy.com/docs/architecture#policy-compiler" rel="noopener ugc nofollow" target="_blank">策略编译器</a></li></ul><h1 id="ad69" class="kt ju hi bd jv ku kv kw jz kx ky kz kd la lb lc kg ld le lf kj lg lh li km lj bi translated">Webhook 管理器</h1><p id="dfd1" class="pw-post-body-paragraph if ig hi ih b ii ko ik il im kp io ip iq kq is it iu kr iw ix iy ks ja jb jc hb bi translated">webhook 管理器负责向 Kubernetes API 服务器注册和管理许可 web hook，以便 API 服务器请求将应用定义为<code class="du me mf mg mh b">JsPolicy</code>对象的变异和验证 web hook。</p><h1 id="eea8" class="kt ju hi bd jv ku kv kw jz kx ky kz kd la lb lc kg ld le lf kj lg lh li km lj bi translated">V8 JavaScript 沙盒池</h1><p id="ace5" class="pw-post-body-paragraph if ig hi ih b ii ko ik il im kp io ip iq kq is it iu kr iw ix iy ks ja jb jc hb bi translated">为了更快地执行策略代码，jsPolicy 维护了一个预热的 V8 JavaScript 沙箱池，可用于运行包含策略逻辑的 JavaScript 代码。</p><h1 id="c32c" class="kt ju hi bd jv ku kv kw jz kx ky kz kd la lb lc kg ld le lf kj lg lh li km lj bi translated">策略编译器</h1><p id="2516" class="pw-post-body-paragraph if ig hi ih b ii ko ik il im kp io ip iq kq is it iu kr iw ix iy ks ja jb jc hb bi translated">策略编译器是一个控制器，它监控<code class="du me mf mg mh b">JsPolicy</code>资源，并为定义<code class="du me mf mg mh b">spec.javascript</code>字段的所有<code class="du me mf mg mh b">JsPolicy</code>对象创建和更新<code class="du me mf mg mh b">JsPolicyBundle</code>对象。编译过程大概是这样的:</p><ol class=""><li id="70ab" class="lk ll hi ih b ii ij im in iq ma iu mb iy mc jc lp lq lr ls bi translated">检索<code class="du me mf mg mh b">spec.dependencies</code>中指定的所有必需的<code class="du me mf mg mh b">npm</code>包(类似于<code class="du me mf mg mh b">npm install</code>下载常规 JavaScript 项目的<code class="du me mf mg mh b">package.json</code>文件中指定的<code class="du me mf mg mh b">dependencies</code>)</li><li id="ff3a" class="lk ll hi ih b ii lt im lu iq lv iu lw iy lx jc lp lq lr ls bi translated">运行<code class="du me mf mg mh b">webpack</code>创建一个高度优化的 JavaScript 代码包，其中包含来自<code class="du me mf mg mh b">spec.javascript</code>的代码和所有依赖项，同时只捆绑执行代码所需的函数。</li><li id="1a9e" class="lk ll hi ih b ii lt im lu iq lv iu lw iy lx jc lp lq lr ls bi translated">使用<code class="du me mf mg mh b">gzip</code>压缩管束。</li><li id="9a5a" class="lk ll hi ih b ii lt im lu iq lv iu lw iy lx jc lp lq lr ls bi translated">使用<code class="du me mf mg mh b">base64</code>对包进行编码。</li><li id="37a3" class="lk ll hi ih b ii lt im lu iq lv iu lw iy lx jc lp lq lr ls bi translated">将<code class="du me mf mg mh b">spec.bundle</code>中的包存储在各自的<code class="du me mf mg mh b">JsPolicyBundle</code>对象中。</li></ol><h2 id="0723" class="jt ju hi bd jv jw jx jy jz ka kb kc kd iq ke kf kg iu kh ki kj iy kk kl km kn bi translated">安装 jsPolicy</h2><p id="0149" class="pw-post-body-paragraph if ig hi ih b ii ko ik il im kp io ip iq kq is it iu kr iw ix iy ks ja jb jc hb bi translated">jsPolicy 在一个容器中运行它的所有组件。这可以很容易地安装使用舵图表。</p><pre class="je jf jg jh fd mi mh mj mk aw ml bi"><span id="3efc" class="jt ju hi mh b fi mm mn l mo mp">$ helm install jspolicy jspolicy -n jspolicy --create-namespace --repo <a class="ae ly" href="https://charts.loft.sh" rel="noopener ugc nofollow" target="_blank">https://charts.loft.sh</a></span></pre><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es mq"><img src="../Images/9f1fcf4e37bcbe63f7989d677314f936.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LAA9yT1ua0UtK1Qfui0oEw.png"/></div></div><figcaption class="jp jq et er es jr js bd b be z dx translated">jsPolicy pods</figcaption></figure><h2 id="1fed" class="jt ju hi bd jv jw jx jy jz ka kb kc kd iq ke kf kg iu kh ki kj iy kk kl km kn bi translated">是时候看看 jsPolicy 的实际应用了</h2><p id="e94a" class="pw-post-body-paragraph if ig hi ih b ii ko ik il im kp io ip iq kq is it iu kr iw ix iy ks ja jb jc hb bi translated">这些策略有三种类型</p><p id="6350" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">a)变更:在 API 服务器执行认证和授权(RBAC)之后，变更策略作为<code class="du me mf mg mh b">kubectl</code>请求的一部分被执行。变更策略的目的是改变请求中提供的有效负载(Kubernetes 对象),例如，在创建 pod 时自动添加一个边车容器。</p><p id="5ebe" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">b)验证:在执行变异策略之后，验证策略作为<code class="du me mf mg mh b">kubectl</code>请求的一部分被执行。验证策略的目的是检查请求，然后拒绝或允许它。例如，如果名称空间是默认的，则拒绝创建 pod，或者如果图像来自公共储存库，则拒绝创建 pod。</p><p id="606c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">c)控制器:与变更和验证策略不同，控制器策略不是 Kubernetes API 服务器请求生命周期的一部分。控制器策略由 Kubernetes 为 etcd 中集群状态的每次变化创建的<code class="du me mf mg mh b">Events</code>触发，例如，在每个新创建的名称空间中自动创建某些资源(例如<code class="du me mf mg mh b">LimitRange</code>、<code class="du me mf mg mh b">NetworkPolicy</code>等)。)</p><p id="69d7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们看看他们三人的行动。</p><h2 id="40dd" class="jt ju hi bd jv jw jx jy jz ka kb kc kd iq ke kf kg iu kh ki kj iy kk kl km kn bi translated">变更策略:</h2><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="mr ms l"/></div></figure><p id="f1bb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这个 jsPolicy 说它属于变异类型(第 6 行)，并且在创建 pod 时适用(第 7、8 行)，并且该策略说如果正在创建的 pod 具有注释<strong class="ih hj">“inject-agent”:“true”(第 10 行)</strong>，那么 pod 应该通过一个额外的边车容器进行变异(第 16 行)。现在让我们创建策略和 pod 来测试这一点。</p><pre class="je jf jg jh fd mi mh mj mk aw ml bi"><span id="25f8" class="jt ju hi mh b fi mm mn l mo mp">$ git clone <a class="ae ly" href="https://github.com/pavan-kumar-99/medium-manifests.git" rel="noopener ugc nofollow" target="_blank">https://github.com/pavan-kumar-99/medium-manifests.git</a> \<br/>-b jsPolicy</span><span id="208f" class="jt ju hi mh b fi mt mn l mo mp">$ cd medium-manifests</span><span id="8e70" class="jt ju hi mh b fi mt mn l mo mp">$ kubectl apply -f <a class="ae ly" href="https://github.com/pavan-kumar-99/medium-manifests/blob/jsPolicy/mutate-policy.yaml" rel="noopener ugc nofollow" target="_blank">mutate-policy.yaml</a></span><span id="6735" class="jt ju hi mh b fi mt mn l mo mp">$ kubectl apply -f <a class="ae ly" href="https://github.com/pavan-kumar-99/medium-manifests/blob/jsPolicy/pod.yaml" rel="noopener ugc nofollow" target="_blank">pod.yaml</a></span></pre><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es mu"><img src="../Images/7197b2fbebe443070ec92dfd74cb16aa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vXWO8k3Ca2QNcRZTg70pQw.png"/></div></div></figure><p id="7dd0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">pod 具有所需的注释，并且现在应该创建了两个容器(并且边车被自动变异)。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es mv"><img src="../Images/23f3f16a42976563b7fc97615f609495.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-c6YAKYeNWX-NtPiVfRSCg.png"/></div></div><figcaption class="jp jq et er es jr js bd b be z dx translated">边车自动注入</figcaption></figure><h2 id="66d9" class="jt ju hi bd jv jw jx jy jz ka kb kc kd iq ke kf kg iu kh ki kj iy kk kl km kn bi translated">验证策略:</h2><p id="7877" class="pw-post-body-paragraph if ig hi ih b ii ko ik il im kp io ip iq kq is it iu kr iw ix iy ks ja jb jc hb bi translated">让我们删除之前创建的 pod，然后应用验证策略。</p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="mr ms l"/></div><figcaption class="jp jq et er es jr js bd b be z dx translated">默认拒绝</figcaption></figure><p id="eea9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">验证策略要求拒绝在默认命名空间中创建任何资源。</p><pre class="je jf jg jh fd mi mh mj mk aw ml bi"><span id="63c0" class="jt ju hi mh b fi mm mn l mo mp">$ git clone <a class="ae ly" href="https://github.com/pavan-kumar-99/medium-manifests.git" rel="noopener ugc nofollow" target="_blank">https://github.com/pavan-kumar-99/medium-manifests.git</a> \<br/>-b jsPolicy</span><span id="f2a2" class="jt ju hi mh b fi mt mn l mo mp">$ cd medium-manifests</span><span id="e4ba" class="jt ju hi mh b fi mt mn l mo mp">## Delete the Pod created earlier</span><span id="1f6a" class="jt ju hi mh b fi mt mn l mo mp">$ kubectl delete -f <a class="ae ly" href="https://github.com/pavan-kumar-99/medium-manifests/blob/jsPolicy/pod.yaml" rel="noopener ugc nofollow" target="_blank">pod.yaml</a></span><span id="d7f4" class="jt ju hi mh b fi mt mn l mo mp">## Apply the validation webhook</span><span id="3f3c" class="jt ju hi mh b fi mt mn l mo mp">$ kubectl apply -f <a class="ae ly" href="https://github.com/pavan-kumar-99/medium-manifests/blob/jsPolicy/default-ns-deny.yaml" rel="noopener ugc nofollow" target="_blank">default-ns-deny.yaml</a></span></pre><p id="5a3f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在让我们再次尝试创建相同的 pod。</p><pre class="je jf jg jh fd mi mh mj mk aw ml bi"><span id="5635" class="jt ju hi mh b fi mm mn l mo mp">$ kubectl apply -f <a class="ae ly" href="https://github.com/pavan-kumar-99/medium-manifests/blob/jsPolicy/pod.yaml" rel="noopener ugc nofollow" target="_blank">pod.yaml</a></span></pre><blockquote class="mw mx my"><p id="6c1b" class="if ig mz ih b ii ij ik il im in io ip na ir is it nb iv iw ix nc iz ja jb jc hb bi translated"><strong class="ih hj">服务器出错(禁止):创建“pod”时出错。YAML ":admission web hook " deny-default-namespace . devsecops . com "拒绝了请求:不允许在默认命名空间内创建资源！</strong></p></blockquote><p id="f473" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">当您尝试在默认名称空间中创建任何资源时，您将会看到这种情况。</p><h2 id="5e3a" class="jt ju hi bd jv jw jx jy jz ka kb kc kd iq ke kf kg iu kh ki kj iy kk kl km kn bi translated">控制器策略:</h2><p id="4865" class="pw-post-body-paragraph if ig hi ih b ii ko ik il im kp io ip iq kq is it iu kr iw ix iy ks ja jb jc hb bi translated">在本例中，我们将尝试在创建名称空间时自动创建资源配额。假设命名空间应该有标签<strong class="ih hj">“create-rq”:“true”。</strong></p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="mr ms l"/></div></figure><pre class="je jf jg jh fd mi mh mj mk aw ml bi"><span id="e2de" class="jt ju hi mh b fi mm mn l mo mp">$ git clone <a class="ae ly" href="https://github.com/pavan-kumar-99/medium-manifests.git" rel="noopener ugc nofollow" target="_blank">https://github.com/pavan-kumar-99/medium-manifests.git</a> \<br/>-b jsPolicy</span><span id="ad3e" class="jt ju hi mh b fi mt mn l mo mp">$ cd medium-manifests</span><span id="d038" class="jt ju hi mh b fi mt mn l mo mp">$ kubectl apply -f <a class="ae ly" href="https://github.com/pavan-kumar-99/medium-manifests/blob/jsPolicy/controller-policy.yaml" rel="noopener ugc nofollow" target="_blank">controller-policy.yaml</a></span><span id="6b84" class="jt ju hi mh b fi mt mn l mo mp">## Let us now create the namespace with the required labels</span><span id="5a92" class="jt ju hi mh b fi mt mn l mo mp">$ kubectl apply -f <a class="ae ly" href="https://github.com/pavan-kumar-99/medium-manifests/blob/jsPolicy/namespace.yaml" rel="noopener ugc nofollow" target="_blank">namespace.yaml</a></span></pre><p id="4e87" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">一旦创建了名称空间，您会发现 ResourceQouta 也会自动创建。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es nd"><img src="../Images/5f223ca3e26dd12d5e0606175aacec3a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wpfZbfV56V8OLTgAP22Rxw.png"/></div></div><figcaption class="jp jq et er es jr js bd b be z dx translated">自动创建资源配额</figcaption></figure><p id="97ea" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这就是如何利用 jsPolicy 在 JavaScript 和 TypeScript 中使用 jsPolicy 编写各种类型的策略。请在评论区分享你在制定这些政策时的经验。</p><p id="d329" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">直到下一次…..</p><h1 id="fb1d" class="kt ju hi bd jv ku kv kw jz kx ky kz kd la lb lc kg ld le lf kj lg lh li km lj bi translated">被推荐的</h1><div class="ne nf ez fb ng nh"><a rel="noopener follow" target="_blank" href="/nerd-for-tech/mlops-machine-learning-pipelines-using-kubeflow-fc06508a3f0d"><div class="ni ab dw"><div class="nj ab nk cl cj nl"><h2 class="bd hj fi z dy nm ea eb nn ed ef hh bi translated">MlOps:使用 kubeflow 的机器学习管道</h2><div class="no l"><h3 class="bd b fi z dy nm ea eb nn ed ef dx translated">使用 Kubeflow 对 Kubernetes 进行有效的 MLOps</h3></div><div class="np l"><p class="bd b fp z dy nm ea eb nn ed ef dx translated">medium.com</p></div></div><div class="nq l"><div class="nr l ns nt nu nq nv jn nh"/></div></div></a></div><div class="ne nf ez fb ng nh"><a href="https://pavan1999-kumar.medium.com/hashicvault-secrets-in-kubernetes-with-csi-driver-ec917d4a2672" rel="noopener follow" target="_blank"><div class="ni ab dw"><div class="nj ab nk cl cj nl"><h2 class="bd hj fi z dy nm ea eb nn ed ef hh bi translated">与 CSI 司机在 Kubernetes 哈希克沃特秘密</h2><div class="no l"><h3 class="bd b fi z dy nm ea eb nn ed ef dx translated">使用 Vault CSI 驱动程序向 Kubernetes Pods 注入秘密</h3></div><div class="np l"><p class="bd b fp z dy nm ea eb nn ed ef dx translated">pavan1999-kumar.medium.com</p></div></div><div class="nq l"><div class="nw l ns nt nu nq nv jn nh"/></div></div></a></div><div class="ne nf ez fb ng nh"><a rel="noopener follow" target="_blank" href="/nerd-for-tech/terraforming-the-gitops-way-9417cf4abf58"><div class="ni ab dw"><div class="nj ab nk cl cj nl"><h2 class="bd hj fi z dy nm ea eb nn ed ef hh bi translated">地球化吉托普斯之路！！！</h2><div class="no l"><h3 class="bd b fi z dy nm ea eb nn ed ef dx translated">使用 Atlantis(拉式请求自动化)通过 GitOps 建立 Terraform。</h3></div><div class="np l"><p class="bd b fp z dy nm ea eb nn ed ef dx translated">medium.com</p></div></div><div class="nq l"><div class="nx l ns nt nu nq nv jn nh"/></div></div></a></div><div class="ne nf ez fb ng nh"><a rel="noopener follow" target="_blank" href="/nerd-for-tech/using-hashicorp-vault-as-a-certificate-issuer-in-cert-manager-9e19d7239d3d"><div class="ni ab dw"><div class="nj ab nk cl cj nl"><h2 class="bd hj fi z dy nm ea eb nn ed ef hh bi translated">在证书管理器中将 Hashicorp Vault 用作证书颁发者</h2><div class="no l"><h3 class="bd b fi z dy nm ea eb nn ed ef dx translated">在证书管理器中将 vault PKI 后端配置为证书提供商</h3></div><div class="np l"><p class="bd b fp z dy nm ea eb nn ed ef dx translated">medium.com</p></div></div><div class="nq l"><div class="ny l ns nt nu nq nv jn nh"/></div></div></a></div></div></div>    
</body>
</html>