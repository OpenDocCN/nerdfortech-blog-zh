<html>
<head>
<title>Spawning Objects in Unity without the Clutter</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在Unity中生成对象，没有杂乱</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/spawning-objects-in-unity-without-the-clutter-8a680e7427be?source=collection_archive---------8-----------------------#2021-04-03">https://medium.com/nerd-for-tech/spawning-objects-in-unity-without-the-clutter-8a680e7427be?source=collection_archive---------8-----------------------#2021-04-03</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="7b00" class="pw-post-body-paragraph ig ih hi ii b ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd hb bi translated"><strong class="ii hj"> <em class="je">产卵的敌人！！！</em>T3】</strong></p><p id="8444" class="pw-post-body-paragraph ig ih hi ii b ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd hb bi translated">我们致力于移动玩家，让玩家发射激光，并创造了一个基本的敌人行为。但是现在是时候让敌人在给定的时间间隔内产卵了。</p><p id="4972" class="pw-post-body-paragraph ig ih hi ii b ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd hb bi translated">正如在以前的文章中所讨论的，当处理任何与时间相关的事情时，我们可以使用协程。所以让我们从创建一个每5秒产生一个敌人的产卵管理器开始。</p><figure class="jg jh ji jj fd jk er es paragraph-image"><div role="button" tabindex="0" class="jl jm di jn bf jo"><div class="er es jf"><img src="../Images/7bdf05abcf76db13e4720a23967b56e9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*cfNYdi9ods6cV2rKGwbDow.gif"/></div></div></figure><p id="fae9" class="pw-post-body-paragraph ig ih hi ii b ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd hb bi translated">这个空的游戏对象将负责生成我们的游戏对象。现在，让我们给它添加一个<strong class="ii hj">产卵管理器</strong>行为脚本，它将包含我们负责为敌人产卵计时的协程。</p><figure class="jg jh ji jj fd jk er es paragraph-image"><div role="button" tabindex="0" class="jl jm di jn bf jo"><div class="er es jr"><img src="../Images/79b95a98ddd0de414614ba0a6267293f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*p8d0BYykDPmkqDAe7y3_HA.png"/></div></div></figure><p id="62f6" class="pw-post-body-paragraph ig ih hi ii b ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd hb bi translated">这里，<em class="je"> _posToSpawn </em>是一个<strong class="ii hj"> Vector3 </strong>变量，它存储一个随机位置，这个位置将用于<strong class="ii hj">实例化</strong>没有旋转的<em class="je">_敌人</em>游戏对象。</p><p id="442f" class="pw-post-body-paragraph ig ih hi ii b ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd hb bi translated">这里，<em class="je">yield return WaitForSeconds()</em>用于暂停我们的执行。这整个代码块只在<strong class="ii hj">玩家</strong>游戏对象活着的时候运行。其中<em class="je"> _player </em> GameObject在哪里，</p><figure class="jg jh ji jj fd jk er es paragraph-image"><div role="button" tabindex="0" class="jl jm di jn bf jo"><div class="er es js"><img src="../Images/bb264e6c76350f9a2e8dc7767b99ae9c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1dyFtGGKyHk-6-69mkyc9g.png"/></div></div><figcaption class="jt ju et er es jv jw bd b be z dx translated">游戏对象。Find用于获取具有所需名称的游戏对象。</figcaption></figure><p id="da98" class="pw-post-body-paragraph ig ih hi ii b ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd hb bi translated">使用这个我们可以访问<strong class="ii hj">玩家</strong>行为脚本中的所有公共函数，它包含<strong class="ii hj">玩家状态()</strong>方法。</p><figure class="jg jh ji jj fd jk er es paragraph-image"><div role="button" tabindex="0" class="jl jm di jn bf jo"><div class="er es jx"><img src="../Images/b54850d4ff78f300e3f8cf47f9a60404.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*J4Mf53FGmFuhUamhO62R8Q.png"/></div></div></figure><p id="a393" class="pw-post-body-paragraph ig ih hi ii b ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd hb bi translated">其中<em class="je"> _isAlive </em>是一个布尔变量，其默认值设置为<strong class="ii hj"> true </strong>。</p><figure class="jg jh ji jj fd jk er es paragraph-image"><div role="button" tabindex="0" class="jl jm di jn bf jo"><div class="er es jy"><img src="../Images/251b262e111d2752908f2060fb79f7ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RIZi8Uxda9BTrASLDgm6GQ.png"/></div></div><figcaption class="jt ju et er es jv jw bd b be z dx translated">当健康值达到0时，_isAlive设置为false。</figcaption></figure><p id="b050" class="pw-post-body-paragraph ig ih hi ii b ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd hb bi translated">伤害行为在<a class="ae jz" rel="noopener" href="/nerd-for-tech/simple-enemy-behaviour-in-unity-b38f88009635">简单敌人行为</a>文章中有解释。</p><p id="05d1" class="pw-post-body-paragraph ig ih hi ii b ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd hb bi translated">这给了我们以下结果，</p><figure class="jg jh ji jj fd jk er es paragraph-image"><div role="button" tabindex="0" class="jl jm di jn bf jo"><div class="er es jf"><img src="../Images/3609e7e82f7ad692c1f67e110e7ab54b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*WaQUe7zDAY4dKVavdC37rg.gif"/></div></div></figure></div><div class="ab cl ka kb gp kc" role="separator"><span class="kd bw bk ke kf kg"/><span class="kd bw bk ke kf kg"/><span class="kd bw bk ke kf"/></div><div class="hb hc hd he hf"><p id="d98f" class="pw-post-body-paragraph ig ih hi ii b ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd hb bi translated"><strong class="ii hj"> <em class="je">清理编辑杂物:</em> </strong></p><figure class="jg jh ji jj fd jk er es paragraph-image"><div role="button" tabindex="0" class="jl jm di jn bf jo"><div class="er es jf"><img src="../Images/91ee007c5cca68919f8fa03078241c71.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*SGT7Tmmz2H-sPGkYLz_Xcg.gif"/></div></div></figure><p id="26a5" class="pw-post-body-paragraph ig ih hi ii b ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd hb bi translated">我们可以观察到等级随着更多敌人的产生而增加，当我们增加能量或者让收藏品产生时,<strong class="ii hj">等级</strong>面板会变得非常混乱。这种混乱可以通过在我们的协程中添加以下内容来清理，</p><figure class="jg jh ji jj fd jk er es paragraph-image"><div role="button" tabindex="0" class="jl jm di jn bf jo"><div class="er es jr"><img src="../Images/9ab6d48403388b0ec1fefc260fd8f1ae.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8aYyYvItZ8bDYcqkP-PyMA.png"/></div></div></figure><p id="914a" class="pw-post-body-paragraph ig ih hi ii b ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd hb bi translated">我们基本上是让所有衍生的敌人成为我们的敌人容器游戏对象的子对象。其中，<em class="je"> _enemyContainer </em>为，</p><figure class="jg jh ji jj fd jk er es paragraph-image"><div role="button" tabindex="0" class="jl jm di jn bf jo"><div class="er es jf"><img src="../Images/3f2577491ad2ba071d56e997e5a29cb3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*r8n8nLdDH65KkvTPTOmz0Q.gif"/></div></div></figure><p id="219f" class="pw-post-body-paragraph ig ih hi ii b ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd hb bi translated">这给了我们以下结果，</p><figure class="jg jh ji jj fd jk er es paragraph-image"><div role="button" tabindex="0" class="jl jm di jn bf jo"><div class="er es jf"><img src="../Images/cb930ff2a2b7dcf4d9685b25591f55da.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*KZJdo9CI6TzqwTev-2HJ-g.gif"/></div></div></figure><p id="bfb2" class="pw-post-body-paragraph ig ih hi ii b ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd hb bi translated">感谢您的阅读！！！更多即将到来。</p></div></div>    
</body>
</html>