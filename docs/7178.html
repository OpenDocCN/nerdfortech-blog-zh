<html>
<head>
<title>Airflow features — Callback, Trigger &amp; Cluster Policy</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">气流功能—回拨、触发和集群策略</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/airflow-features-callback-trigger-clsuter-policy-cc7f8022e7d3?source=collection_archive---------0-----------------------#2022-08-18">https://medium.com/nerd-for-tech/airflow-features-callback-trigger-clsuter-policy-cc7f8022e7d3?source=collection_archive---------0-----------------------#2022-08-18</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="08ac" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">较少讨论的气流特征</p><p id="3421" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在这篇博客中，我们将讨论气流的以下特征</p><ul class=""><li id="fb3d" class="jd je hi ih b ii ij im in iq jf iu jg iy jh jc ji jj jk jl bi translated">复试</li><li id="1c89" class="jd je hi ih b ii jm im jn iq jo iu jp iy jq jc ji jj jk jl bi translated">集群策略</li><li id="e71d" class="jd je hi ih b ii jm im jn iq jo iu jp iy jq jc ji jj jk jl bi translated">任务依赖性</li><li id="54aa" class="jd je hi ih b ii jm im jn iq jo iu jp iy jq jc ji jj jk jl bi translated">触发规则</li></ul><p id="28d5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们走吧！</p><h2 id="3752" class="jr js hi bd jt ju jv jw jx jy jz ka kb iq kc kd ke iu kf kg kh iy ki kj kk kl bi translated">复试</h2><p id="a997" class="pw-post-body-paragraph if ig hi ih b ii km ik il im kn io ip iq ko is it iu kp iw ix iy kq ja jb jc hb bi translated">回调提供了一种对给定任务或 DAG 的状态变化进行操作的方式。使用回调有三种方式</p><ol class=""><li id="913e" class="jd je hi ih b ii ij im in iq jf iu jg iy jh jc kr jj jk jl bi translated">通过 DAG 初始化—所有叶任务完成后将调用操作/功能</li><li id="3cac" class="jd je hi ih b ii jm im jn iq jo iu jp iy jq jc kr jj jk jl bi translated">通过任务初始化—任务完成后将调用动作/功能</li><li id="02dc" class="jd je hi ih b ii jm im jn iq jo iu jp iy jq jc kr jj jk jl bi translated">通过默认参数，这些参数作为关键字参数传递给所有运算符</li></ol><figure class="kt ku kv kw fd kx er es paragraph-image"><div role="button" tabindex="0" class="ky kz di la bf lb"><div class="er es ks"><img src="../Images/8b271e3c73914f406acc0e0b12641d05.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Zrl2JLTtpH8wfnonQA5Jhw.png"/></div></div></figure><p id="2c45" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">有 5 大回调</strong></p><ul class=""><li id="c10d" class="jd je hi ih b ii ij im in iq jf iu jg iy jh jc ji jj jk jl bi translated">在执行回调时</li><li id="22e0" class="jd je hi ih b ii jm im jn iq jo iu jp iy jq jc ji jj jk jl bi translated">在 _ 成功 _ 回调时</li><li id="0e56" class="jd je hi ih b ii jm im jn iq jo iu jp iy jq jc ji jj jk jl bi translated">on _ 重试 _ 回调</li><li id="9794" class="jd je hi ih b ii jm im jn iq jo iu jp iy jq jc ji jj jk jl bi translated">打开 _ 失败 _ 回调</li><li id="de06" class="jd je hi ih b ii jm im jn iq jo iu jp iy jq jc ji jj jk jl bi translated">sla _ 错过 _ 回调</li></ul><p id="f025" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">操作员挂钩</strong></p><p id="d0da" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">上面提到的回调是在任务/dag 级别定义的。气流在操作员级执行任务(操作员的 execute 方法)之前为某些操作提供了一种机制。我们有在实际执行函数之前被调用的钩子。</p><figure class="kt ku kv kw fd kx er es paragraph-image"><div role="button" tabindex="0" class="ky kz di la bf lb"><div class="er es le"><img src="../Images/7919e8dcda01a2dc2151abf8ad283166.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fa2KIBR6zIvWAAB0mUhN2g.png"/></div></div></figure><p id="ac47" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们主要有三种类型的钩子。</p><ul class=""><li id="66cd" class="jd je hi ih b ii ij im in iq jf iu jg iy jh jc ji jj jk jl bi translated">pre_execute —这将在实际任务开始之前调用所需的函数。如果我们希望在不中断依赖关系的情况下跳过某些 dag 运行的某些任务，这可能会很有用。</li><li id="7b65" class="jd je hi ih b ii jm im jn iq jo iu jp iy jq jc ji jj jk jl bi translated">post _ 执行</li><li id="8eb5" class="jd je hi ih b ii jm im jn iq jo iu jp iy jq jc ji jj jk jl bi translated">on_kill —用于清理线程或进程等资源。</li></ul><h2 id="dc50" class="jr js hi bd jt ju jv jw jx jy jz ka kb iq kc kd ke iu kf kg kh iy ki kj kk kl bi translated">集群策略</h2><ul class=""><li id="0a62" class="jd je hi ih b ii km im kn iq lf iu lg iy lh jc ji jj jk jl bi translated">Dag 策略—作为 DAG 加载时间运行。</li></ul><figure class="kt ku kv kw fd kx er es paragraph-image"><div role="button" tabindex="0" class="ky kz di la bf lb"><div class="er es li"><img src="../Images/7ce360b9d968945403f113d7b4501677.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rFkBy1W-eDKmWXir0XshKg.png"/></div></div></figure><ul class=""><li id="f0d3" class="jd je hi ih b ii ij im in iq jf iu jg iy jh jc ji jj jk jl bi translated">任务策略—作为 DAG 加载时间运行。</li></ul><figure class="kt ku kv kw fd kx er es paragraph-image"><div role="button" tabindex="0" class="ky kz di la bf lb"><div class="er es lj"><img src="../Images/4ea8c44649c0b9b82f6438f406824371.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nF2V54ZPDTgbZTDCJHB5gg.png"/></div></div></figure><ul class=""><li id="98c2" class="jd je hi ih b ii ij im in iq jf iu jg iy jh jc ji jj jk jl bi translated">任务实例变异—这仅在调度任务时变异任务属性。如果您手动运行该任务，它不会生效。挂钩仅在创建 dag 运行时调用。突变就发生在任务执行之前。</li></ul><h2 id="d531" class="jr js hi bd jt ju jv jw jx jy jz ka kb iq kc kd ke iu kf kg kh iy ki kj kk kl bi translated">任务相关性</h2><p id="d79f" class="pw-post-body-paragraph if ig hi ih b ii km ik il im kn io ip iq ko is it iu kp iw ix iy kq ja jb jc hb bi translated">在 DAG 中，节点是任务，依赖关系是有向边。边决定了我们如何在图中移动。从属关系是定义柔性管线的关键。</p><p id="0382" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们可以设置任务之间的依赖关系或者更精确地说是流水线流程，使用以下两种方法。</p><ul class=""><li id="1e9d" class="jd je hi ih b ii ij im in iq jf iu jg iy jh jc ji jj jk jl bi translated">设置 _ 下游</li><li id="e623" class="jd je hi ih b ii jm im jn iq jo iu jp iy jq jc ji jj jk jl bi translated">设置 _ 上游</li></ul><figure class="kt ku kv kw fd kx er es paragraph-image"><div class="er es lk"><img src="../Images/4763488630c27837e18033b207cb0e48.png" data-original-src="https://miro.medium.com/v2/resize:fit:1372/format:webp/1*lWKwXL1CuGC6sXf5UUUgBA.png"/></div></figure><p id="cf11" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们还可以设置 DAG 当前运行和之前运行中的任务之间的依赖关系。</p><ul class=""><li id="83b0" class="jd je hi ih b ii ij im in iq jf iu jg iy jh jc ji jj jk jl bi translated"><strong class="ih hj"> depends_on_past </strong> —如果设置为 true，则当前 DAG 运行中的任务将仅在同一任务在先前运行中成功或被跳过的情况下运行。</li><li id="c756" class="jd je hi ih b ii jm im jn iq jo iu jp iy jq jc ji jj jk jl bi translated"><strong class="ih hj"> wait_for_downstream </strong> —如果设置为 true，则当前运行中的任务将仅在同一任务在前一次运行中成功或被跳过并且前一次运行中的<strong class="ih hj">直接下游</strong>任务也成功或被跳过的情况下运行。</li></ul><figure class="kt ku kv kw fd kx er es paragraph-image"><div role="button" tabindex="0" class="ky kz di la bf lb"><div class="er es ll"><img src="../Images/cc155a8e9703d40ad0ea981db013f47e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Y4HQv-mKIJKH_jPk_oWEtg.png"/></div></div></figure><h2 id="bc1f" class="jr js hi bd jt ju jv jw jx jy jz ka kb iq kc kd ke iu kf kg kh iy ki kj kk kl bi translated">触发规则</h2><figure class="kt ku kv kw fd kx er es paragraph-image"><div role="button" tabindex="0" class="ky kz di la bf lb"><div class="er es lm"><img src="../Images/d1940d3332e22e5cff291c59f2dd4f7c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CTAmaEBOQjnw5buDHjIi5A.png"/></div></div></figure><ul class=""><li id="3bbf" class="jd je hi ih b ii ij im in iq jf iu jg iy jh jc ji jj jk jl bi translated"><strong class="ih hj"> all_success(默认)</strong>:如果所有上游任务都成功，则执行相关任务，否则跳过的任务将导致相关任务被跳过。<code class="du ln lo lp lq b">All upstream task == all successful up stream task</code>。</li><li id="2296" class="jd je hi ih b ii jm im jn iq jo iu jp iy jq jc ji jj jk jl bi translated"><strong class="ih hj"> all_failed: </strong>当所有上游任务都处于<code class="du ln lo lp lq b">failed</code>或<code class="du ln lo lp lq b">upstream_failed</code>状态时，依赖任务运行。</li><li id="4ffe" class="jd je hi ih b ii jm im jn iq jo iu jp iy jq jc ji jj jk jl bi translated"><strong class="ih hj"> all_done: </strong>所有上游任务执行完毕后，相关任务运行，成功、失败或跳过都无关紧要。他们一定已经被处决了。在这个案例中<code class="du ln lo lp lq b">all upstream task ≤ count of succeeded, failed, upstream_failed, skipped tasks</code>。</li><li id="f593" class="jd je hi ih b ii jm im jn iq jo iu jp iy jq jc ji jj jk jl bi translated"><strong class="ih hj"> one_failed: </strong>当至少一个上游任务失败时，相关任务运行(不等待所有上游任务完成)。</li><li id="c006" class="jd je hi ih b ii jm im jn iq jo iu jp iy jq jc ji jj jk jl bi translated"><strong class="ih hj"> one_success: </strong>当至少一个上游任务成功时，相关任务运行(不等待所有上游任务完成)。</li><li id="ff43" class="jd je hi ih b ii jm im jn iq jo iu jp iy jq jc ji jj jk jl bi translated"><strong class="ih hj"> none_failed: </strong>依赖任务仅在所有上游任务都没有<code class="du ln lo lp lq b">failed</code>或<code class="du ln lo lp lq b">upstream_failed</code>时运行——即所有上游任务都有<code class="du ln lo lp lq b">succeeded </code>或<code class="du ln lo lp lq b">skipped</code>。</li><li id="21b8" class="jd je hi ih b ii jm im jn iq jo iu jp iy jq jc ji jj jk jl bi translated"><strong class="ih hj">none _ failed _ min _ one _ success</strong>:依赖任务只有在所有上游任务都没有<code class="du ln lo lp lq b">failed</code>或<code class="du ln lo lp lq b">upstream_failed</code>且至少有一个上游任务成功时才运行。</li><li id="18a1" class="jd je hi ih b ii jm im jn iq jo iu jp iy jq jc ji jj jk jl bi translated"><strong class="ih hj"> none_skipped </strong>:依赖任务仅在没有上游任务处于<code class="du ln lo lp lq b">skipped</code>状态时运行——即所有上游任务都处于<code class="du ln lo lp lq b">success</code>、<code class="du ln lo lp lq b">failed</code>或<code class="du ln lo lp lq b">upstream_failed</code>状态。</li><li id="0f3a" class="jd je hi ih b ii jm im jn iq jo iu jp iy jq jc ji jj jk jl bi translated"><strong class="ih hj">总是</strong>:依赖任务会随时运行。</li></ul><p id="10c3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">快乐的工作流程！！！</p></div></div>    
</body>
</html>