<html>
<head>
<title>C# — Compare Images so you Can Remove Duplicates</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">C# —比较图像，以便删除重复的图像</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/c-compare-images-so-you-can-remove-duplicates-b313539b68cb?source=collection_archive---------6-----------------------#2021-09-20">https://medium.com/nerd-for-tech/c-compare-images-so-you-can-remove-duplicates-b313539b68cb?source=collection_archive---------6-----------------------#2021-09-20</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="07a4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">你会一直保存你的照片吗？会仔细查看日期以确保你不会一遍又一遍地保存同样的照片吗？我知道，但不知何故，我总是在不同的文件夹里找到相同的照片。这让我抓狂，所以我决定写一个小工具来找到它们。</p><p id="4797" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这些是守则的要点。</p><p id="79ba" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">您可以输入想要比较的两个文件夹。最初我也有它只是采取一个文件夹，并通过所有的子文件夹循环，但这可能会结束与吨的迭代，所以最好还是选择你的文件夹。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es jd"><img src="../Images/23973335f328736b8e24c3e3bdbc530d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*O-qyUIH5V5M4P0tdD8IZNA.png"/></div></div></figure><p id="6812" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我不包括关于点击[…]按钮来获取文件夹之类的任何东西的代码，只是与图像有关的代码。</p><p id="8672" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我创建这个结构只是为了跟踪图片所在的两个文件夹中的名称:</p><pre class="je jf jg jh fd jp jq jr js aw jt bi"><span id="c903" class="ju jv hi jq b fi jw jx l jy jz">private struct DuplicatePicNames{<br/>   public string nameInFolder1;<br/>   public string nameInFolder2;<br/>}</span></pre><p id="7863" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我有一个方法接受一个文件名数组，以及它们的路径。它返回重复名称的列表:</p><pre class="je jf jg jh fd jp jq jr js aw jt bi"><span id="3462" class="ju jv hi jq b fi jw jx l jy jz">private List&lt;DuplicatePicNames&gt; findDuplicatePics(string[] originalArray1, string[] originalArray2)</span></pre><p id="8ccd" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">要调用上面的方法，我们需要我们想从目录中获取的文件的类型，所以对上面方法的调用是(类型是*。jpg 或任何文件类型)。我没有任何验证，因为这只是为了让我找到它们:</p><pre class="je jf jg jh fd jp jq jr js aw jt bi"><span id="628c" class="ju jv hi jq b fi jw jx l jy jz">List&lt;DuplicatePicNames&gt; duplicatesNamesList = this.findDuplicatePics(<strong class="jq hj">Directory.GetFiles(path1, type)</strong>, Directory.GetFiles(path2, type));</span></pre><p id="fa92" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我将比较一个文件夹中的每张图片和另一个文件夹中的每张图片，因此进度条的最大值将是:</p><pre class="je jf jg jh fd jp jq jr js aw jt bi"><span id="dbc6" class="ju jv hi jq b fi jw jx l jy jz">this.progressBar1.Maximum = originalArray1.Count() * originalArray2.Count();<br/>this.progressBar1.Value = 1;<br/>this.progressBar1.Step = 1;</span></pre><p id="3946" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">对于循环，我有这个。我不得不添加使用，因为否则没有足够的内存来处理这个。</p><pre class="je jf jg jh fd jp jq jr js aw jt bi"><span id="4c6e" class="ju jv hi jq b fi jw jx l jy jz">foreach (string filenameMain in originalArray1)<br/>{<br/>   <strong class="jq hj">using </strong>(imageMain = getImageForFile(filenameMain))<br/>   {<br/>      foreach (string filenameAux in originalArray2)</span></pre><p id="c472" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">getImageForFile 只是从传入的文件名中获取图像:</p><pre class="je jf jg jh fd jp jq jr js aw jt bi"><span id="f5e0" class="ju jv hi jq b fi jw jx l jy jz">private Bitmap getImageForFile(string filename)<br/>{<br/>   Bitmap image = new Bitmap(filename);<br/>   return image;<br/>}</span></pre><p id="cc88" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">对于外部 For each 的每次迭代，更新进度栏:</p><pre class="je jf jg jh fd jp jq jr js aw jt bi"><span id="f1c8" class="ju jv hi jq b fi jw jx l jy jz">this.progressBar1.PerformStep();</span></pre><p id="7680" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">之后，在内部 foreach 中再次使用 using:</p><pre class="je jf jg jh fd jp jq jr js aw jt bi"><span id="d884" class="ju jv hi jq b fi jw jx l jy jz">using (imageAux = getImageForFile(filenameAux))</span></pre><p id="faf8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">一旦我们有了两张图片，一张来自第一个文件夹，一张来自第二个文件夹，比较就开始了！</p><pre class="je jf jg jh fd jp jq jr js aw jt bi"><span id="c4f6" class="ju jv hi jq b fi jw jx l jy jz">//if the sizes are not the same they are not the same image<br/>if (imageMain.Width != imageAux.Width || imageMain.Height != imageAux.Height)<br/>{<br/>   imageIsDifferent = true;<br/>   continue;<br/>}</span></pre><p id="5f75" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">比较的一种方法是遍历图像的像素，如果其中一个像素不同，您就知道它们不是同一个图像:</p><pre class="je jf jg jh fd jp jq jr js aw jt bi"><span id="b542" class="ju jv hi jq b fi jw jx l jy jz">for (int i = 0; i &lt; imageMain.Width; i++)<br/>{<br/>   for (int j = 0; j &lt; imageMain.Height; j++)<br/>   {<br/>      imgMain_ref = imageMain.GetPixel(i, j).ToString();<br/>      imgAux_ref = imageAux.GetPixel(i, j).ToString();<br/>      //if one pixel is different we know this one is not duplicate<br/>      if (imgMain_ref != imgAux_ref)<br/>      {<br/>         imageIsDifferent = true;<br/>         break;<br/>      }<br/>   }<br/>}</span></pre><p id="3dd8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">C#还提供了一个带有一些很酷的方法的<strong class="ih hj"> ImageComparer </strong>，当我有了一些这样的例子时，我会更新这篇文章。<a class="ae ka" href="https://docs.microsoft.com/en-us/dotnet/api/microsoft.visualstudio.testtools.uitesting.imagecomparer.compare?view=visualstudiosdk-2017" rel="noopener ugc nofollow" target="_blank">图像比较器。</a></p><p id="1193" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我将相同的图片添加到重复图片名称列表中，如上所述，该列表包括两个文件中相同图片的名称。很多时候，只要有相同的名字就足以知道这是同一张照片，但并不总是如此。另外，我可能重命名了一些图片，所以不同的名称并不意味着图片是不同的。</p><p id="a601" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为了显示重复的图片，我使用了这个:</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es kb"><img src="../Images/02602e912cc8118623349fdf4737bfda.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nqr1OLnrnTOB6oNuT9NR4g.png"/></div></div></figure><p id="79bf" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">首先，重置面板(请不要介意名称):</p><pre class="je jf jg jh fd jp jq jr js aw jt bi"><span id="fa72" class="ju jv hi jq b fi jw jx l jy jz">this.flowLayoutPanel3.Controls.Clear();</span><span id="ccd4" class="ju jv hi jq b fi kc jx l jy jz">this.flowLayoutPanel1.Controls.Clear();</span></pre><p id="bd9c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">接下来，我将遍历重复列表来显示它们。我创建了一个 PictureBox 来显示在面板中。我为每一个设置了一些属性，包括一个工具提示。即使你看到了，也很难在一个有大量图片的文件夹中找到一张图片，所以工具提示帮了大忙。</p><p id="9ae2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">对于列表中的每个迭代，对第一个文件夹上的名称执行此操作，然后对第二个文件夹上的名称执行类似的操作，并将其添加到第二个面板(名为 3)。注意再次使用。</p><pre class="je jf jg jh fd jp jq jr js aw jt bi"><span id="2c44" class="ju jv hi jq b fi jw jx l jy jz">PictureBox pic = new PictureBox();<br/><strong class="jq hj">using </strong>(tmp = new Bitmap(dup.nameInFolder1))<br/>{<br/>   pic.Image = new Bitmap(tmp);<br/>}</span><span id="b427" class="ju jv hi jq b fi kc jx l jy jz">pic.ClientSize = new Size(100, 100);<br/>pic.SizeMode = PictureBoxSizeMode.Zoom;<br/>pic.Name = dup.nameInFolder1;<br/>ToolTip toolTip = new ToolTip();<br/>toolTip.SetToolTip(pic, pic.Name);</span><span id="a38b" class="ju jv hi jq b fi kc jx l jy jz">pic.Parent = this.flowLayoutPanel1;</span></pre><p id="92fb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这是两个文件夹。</p><p id="e14b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">对于一个文件夹，当你有一堆子目录和一堆子目录时，这需要很长时间。为此，我试着添加了一个按钮，这样用户在浏览了几个文件夹后必须点击下一步。我在这里添加这个只是作为一般信息，因为，如果你有许多子文件夹，它仍然是不切实际的。</p><p id="09ca" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在你的班级上创建这个:</p><pre class="je jf jg jh fd jp jq jr js aw jt bi"><span id="54cd" class="ju jv hi jq b fi jw jx l jy jz">TaskCompletionSource&lt;bool&gt; _tcs;</span></pre><p id="d508" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">然后，在您希望等待用户输入的每一点上，都应该这样:</p><pre class="je jf jg jh fd jp jq jr js aw jt bi"><span id="74be" class="ju jv hi jq b fi jw jx l jy jz">this._tcs = new TaskCompletionSource&lt;bool&gt;();<br/>await this._tcs.Task;</span></pre><p id="af05" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">然后在按钮上，用户将按下指示代码可以继续，你有这个:</p><pre class="je jf jg jh fd jp jq jr js aw jt bi"><span id="5919" class="ju jv hi jq b fi jw jx l jy jz">this._tcs.SetResult(true);</span></pre><p id="7185" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这将使 await 等待完成，之后的代码将继续执行。</p><p id="28ee" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">任何想法请让我知道。我想我已经摆脱了我的副本，但我肯定我最终会有新的:-)</p><p id="ba1b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">感谢阅读！</p></div></div>    
</body>
</html>