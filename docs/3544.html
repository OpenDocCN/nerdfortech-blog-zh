<html>
<head>
<title>LeetCode — Maximum Subarray</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">LeetCode —最大子阵列</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/leetcode-maximum-subarray-313d3227826b?source=collection_archive---------12-----------------------#2021-06-13">https://medium.com/nerd-for-tech/leetcode-maximum-subarray-313d3227826b?source=collection_archive---------12-----------------------#2021-06-13</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div class="er es if"><img src="../Images/202428b3fed8906d135c55ae882c657c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1128/format:webp/0*0zQdeah0L7fW0UsU.png"/></div></figure><h1 id="cef1" class="im in hi bd io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj bi translated">问题陈述</h1><p id="f341" class="pw-post-body-paragraph jk jl hi jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh hb bi translated">给定一个整数数组<strong class="jm hj"> nums </strong>，找出具有最大和的连续子数组(至少包含一个数)并返回其和<em class="ki"/>。</p><p id="fa28" class="pw-post-body-paragraph jk jl hi jm b jn kj jp jq jr kk jt ju jv kl jx jy jz km kb kc kd kn kf kg kh hb bi translated">问题陈述摘自:<a class="ae ko" href="https://leetcode.com/problems/maximum-subarray" rel="noopener ugc nofollow" target="_blank">https://leetcode.com/problems/maximum-subarray</a></p><p id="5f4e" class="pw-post-body-paragraph jk jl hi jm b jn kj jp jq jr kk jt ju jv kl jx jy jz km kb kc kd kn kf kg kh hb bi translated"><strong class="jm hj">例 1: </strong></p><pre class="kp kq kr ks fd kt ku kv kw aw kx bi"><span id="4410" class="ky in hi ku b fi kz la l lb lc">Input: nums = [-2, 1, -3, 4, -1, 2, 1, -5, 4]<br/>Output: 6<br/>Explanation: [4, -1, 2, 1] has the largest sum = 6.</span></pre><p id="b926" class="pw-post-body-paragraph jk jl hi jm b jn kj jp jq jr kk jt ju jv kl jx jy jz km kb kc kd kn kf kg kh hb bi translated"><strong class="jm hj">例 2: </strong></p><pre class="kp kq kr ks fd kt ku kv kw aw kx bi"><span id="f104" class="ky in hi ku b fi kz la l lb lc">Input: nums = [1]<br/>Output: 1</span></pre><p id="7000" class="pw-post-body-paragraph jk jl hi jm b jn kj jp jq jr kk jt ju jv kl jx jy jz km kb kc kd kn kf kg kh hb bi translated"><strong class="jm hj">例 3: </strong></p><pre class="kp kq kr ks fd kt ku kv kw aw kx bi"><span id="7675" class="ky in hi ku b fi kz la l lb lc">Input: nums = [5, 4, -1, 7, 8] <br/>Output: 23</span></pre><p id="97ea" class="pw-post-body-paragraph jk jl hi jm b jn kj jp jq jr kk jt ju jv kl jx jy jz km kb kc kd kn kf kg kh hb bi translated"><strong class="jm hj">约束:</strong></p><pre class="kp kq kr ks fd kt ku kv kw aw kx bi"><span id="8193" class="ky in hi ku b fi kz la l lb lc">- 1 &lt;= nums.length &lt;= 3 * 10^4 - <br/>-10^5 &lt;= nums[i] &lt;= 10^5</span></pre><h1 id="e351" class="im in hi bd io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj bi translated">说明</h1><h2 id="8026" class="ky in hi bd io ld le lf is lg lh li iw jv lj lk ja jz ll lm je kd ln lo ji lp bi translated">强力</h2><p id="8654" class="pw-post-body-paragraph jk jl hi jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh hb bi translated">强力方法是生成所有子阵列并打印具有最大和的子阵列。</p><p id="0157" class="pw-post-body-paragraph jk jl hi jm b jn kj jp jq jr kk jt ju jv kl jx jy jz km kb kc kd kn kf kg kh hb bi translated">上述逻辑的一段 C++代码如下:</p><pre class="kp kq kr ks fd kt ku kv kw aw kx bi"><span id="05b9" class="ky in hi ku b fi kz la l lb lc">for (int i = 0; i &lt; n; i++){<br/>    for (int j = i; j &lt; n; j++){<br/>        for (int k = i; k &lt;= j; k++){<br/>            // calculate sum of all the elements<br/>        }<br/>    }<br/>}</span></pre><p id="43b6" class="pw-post-body-paragraph jk jl hi jm b jn kj jp jq jr kk jt ju jv kl jx jy jz km kb kc kd kn kf kg kh hb bi translated">上述方法的时间复杂度为<strong class="jm hj"> O(N ) </strong>。我们可以使用<a class="ae ko" href="https://www.geeksforgeeks.org/largest-sum-contiguous-subarray/" rel="noopener ugc nofollow" target="_blank">卡丹算法</a>改进上述逻辑。</p><h2 id="5f50" class="ky in hi bd io ld le lf is lg lh li iw jv lj lk ja jz ll lm je kd ln lo ji lp bi translated">Kadane 算法</h2><p id="26e1" class="pw-post-body-paragraph jk jl hi jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh hb bi translated">Kadane 算法的简单思想是寻找数组中所有正的连续段(<code class="du lq lr ls ku b">max_sum</code>用于此)。并跟踪所有正片段中最大和连续片段(<code class="du lq lr ls ku b">max_sum_so_far</code>用于此)。每次我们得到一个正的和，就把它与<code class="du lq lr ls ku b">max_sum</code>比较，如果它大于<code class="du lq lr ls ku b">max_sum_so_far</code>，就更新<code class="du lq lr ls ku b">max_sum</code>。</p><p id="bfc2" class="pw-post-body-paragraph jk jl hi jm b jn kj jp jq jr kk jt ju jv kl jx jy jz km kb kc kd kn kf kg kh hb bi translated">让我们检查下面的算法:</p><pre class="kp kq kr ks fd kt ku kv kw aw kx bi"><span id="6a5c" class="ky in hi ku b fi kz la l lb lc">- set max_sum_so_far = 0, max_sum = INT_MIN<br/><br/>- Loop for i = 0; i &lt; nums.length; i++<br/>  - add max_sum_so_far = max_sum_so_far + nums[i]<br/><br/>  - if max_sum &lt; max_sum_so_far<br/>    - set max_sum = max_sum_so_far<br/><br/>  - if max_sum_so_far &lt; 0<br/>    - set max_sum_so_far = 0<br/><br/>- return max_sum</span></pre><p id="54ea" class="pw-post-body-paragraph jk jl hi jm b jn kj jp jq jr kk jt ju jv kl jx jy jz km kb kc kd kn kf kg kh hb bi translated">上述方法的时间复杂度为<strong class="jm hj"> O(N) </strong>，空间复杂度为<strong class="jm hj"> O(1) </strong>。</p><p id="926f" class="pw-post-body-paragraph jk jl hi jm b jn kj jp jq jr kk jt ju jv kl jx jy jz km kb kc kd kn kf kg kh hb bi translated"><strong class="jm hj"> C++解决方案</strong></p><pre class="kp kq kr ks fd kt ku kv kw aw kx bi"><span id="9154" class="ky in hi ku b fi kz la l lb lc">class Solution {<br/>public:<br/>    int maxSubArray(vector&lt;int&gt;&amp; nums) {<br/>        int max_sum = INT_MIN;<br/>        int max_sum_so_far = 0;<br/><br/>        for(int i = 0; i &lt; nums.size(); i++){<br/>            max_sum_so_far += nums[i];<br/><br/>            if(max_sum &lt; max_sum_so_far){<br/>                max_sum = max_sum_so_far;<br/>            }<br/><br/>            if(max_sum_so_far &lt; 0){<br/>                max_sum_so_far = 0;<br/>            }<br/>        }<br/><br/>        return max_sum;<br/>    }<br/>};</span></pre><p id="d43f" class="pw-post-body-paragraph jk jl hi jm b jn kj jp jq jr kk jt ju jv kl jx jy jz km kb kc kd kn kf kg kh hb bi translated"><strong class="jm hj">戈朗解决方案</strong></p><pre class="kp kq kr ks fd kt ku kv kw aw kx bi"><span id="a244" class="ky in hi ku b fi kz la l lb lc">func maxSubArray(nums []int) int {<br/>    maxSum := math.MinInt32<br/>    maxSumSoFar := 0<br/><br/>    for i := 0; i &lt; len(nums); i++ {<br/>        maxSumSoFar += nums[i]<br/><br/>        if maxSum &lt; maxSumSoFar {<br/>            maxSum = maxSumSoFar<br/>        }<br/><br/>        if maxSumSoFar &lt; 0 {<br/>            maxSumSoFar = 0<br/>        }<br/>    }<br/><br/>    return maxSum<br/>}</span></pre><p id="74d8" class="pw-post-body-paragraph jk jl hi jm b jn kj jp jq jr kk jt ju jv kl jx jy jz km kb kc kd kn kf kg kh hb bi translated"><strong class="jm hj"> Javascript 解决方案</strong></p><pre class="kp kq kr ks fd kt ku kv kw aw kx bi"><span id="fcec" class="ky in hi ku b fi kz la l lb lc">var maxSubArray = function(nums) {<br/>    let maxSumSoFar = 0;<br/>    let maxSum = -Infinity;<br/><br/>    if(nums.length === 0) return 0;<br/>    if(nums.length === 1) return nums[0]<br/><br/>    for( let i = 0; i&lt;nums.length; i++) {<br/>        maxSumSoFar += nums[i];<br/><br/>        maxSum = Math.max(maxSum, maxSumSoFar);<br/><br/>        if(maxSumSoFar &lt; 0) {<br/>            maxSumSoFar = 0;<br/>        }<br/>    }<br/><br/>    return maxSum;<br/>};</span></pre><p id="ebfe" class="pw-post-body-paragraph jk jl hi jm b jn kj jp jq jr kk jt ju jv kl jx jy jz km kb kc kd kn kf kg kh hb bi translated">让我们试运行一下我们的算法，看看解决方案是如何工作的。</p><pre class="kp kq kr ks fd kt ku kv kw aw kx bi"><span id="6509" class="ky in hi ku b fi kz la l lb lc">nums = [-2, 1, -3, 4, -1, 2, 1, -5, 4]<br/><br/>Step 1: max_sum_so_far = 0<br/>        max_sum = INT_MIN<br/><br/>Step 2: for i = 0; i &lt; nums.length<br/>        0 &lt; 9<br/>        true<br/><br/>        max_sum_so_far += nums[0]<br/>        max_sum_so_far = 0 + -2<br/>        max_sum_so_far = -2<br/><br/>        max_sum &lt; max_sum_so_far<br/>        -2^31 - 1 &lt; -2<br/>        true<br/><br/>        max_sum = max_sum_so_far<br/>        max_sum = -2<br/><br/>        max_sum_so_far &lt; 0<br/>        -2 &lt; 0<br/>        true<br/><br/>        max_sum_so_far = 0<br/><br/>        i++<br/>        i = 1<br/><br/>Step 3: i &lt; nums.length<br/>        1 &lt; 9<br/>        true<br/><br/>        max_sum_so_far += nums[1]<br/>        max_sum_so_far = 0 + 1<br/>        max_sum_so_far = 1<br/><br/>        max_sum &lt; max_sum_so_far<br/>        -2 &lt; 1<br/>        true<br/><br/>        max_sum = max_sum_so_far<br/>        max_sum = 1<br/><br/>        max_sum_so_far &lt; 0<br/>        1 &lt; 0<br/>        false<br/><br/>        i++<br/>        i = 2<br/><br/>Step 4: i &lt; nums.length<br/>        2 &lt; 9<br/>        true<br/><br/>        max_sum_so_far += nums[2]<br/>        max_sum_so_far = 1 + -3<br/>        max_sum_so_far = -2<br/><br/>        max_sum &lt; max_sum_so_far<br/>        1 &lt; -2<br/>        false<br/><br/>        max_sum_so_far &lt; 0<br/>        -2 &lt; 0<br/>        true<br/><br/>        max_sum_so_far = 0<br/><br/>        i++<br/>        i = 3<br/><br/>Step 5: i &lt; nums.length<br/>        3 &lt; 9<br/>        true<br/><br/>        max_sum_so_far += nums[3]<br/>        max_sum_so_far = 0 + 4<br/>        max_sum_so_far = 4<br/><br/>        max_sum &lt; max_sum_so_far<br/>        1 &lt; 4<br/>        true<br/><br/>        max_sum = max_sum_so_far<br/>        max_sum = 4<br/><br/>        max_sum_so_far &lt; 0<br/>        false<br/><br/>        i++<br/>        i = 4<br/><br/>Step 6: i &lt; nums.length<br/>        4 &lt; 9<br/>        true<br/><br/>        max_sum_so_far += nums[4]<br/>        max_sum_so_far = 4 + -1<br/>        max_sum_so_far = 3<br/><br/>        max_sum &lt; max_sum_so_far<br/>        4 &lt; 3<br/>        false<br/><br/>        max_sum_so_far &lt; 0<br/>        false<br/><br/>        i++<br/>        i = 5<br/><br/>Step 7: i &lt; nums.length<br/>        5 &lt; 9<br/>        true<br/><br/>        max_sum_so_far += nums[5]<br/>        max_sum_so_far = 3 + 2<br/>        max_sum_so_far = 5<br/><br/>        max_sum &lt; 5<br/>        4 &lt; 5<br/>        true<br/><br/>        max_sum = max_sum_so_far<br/>        max_sum = 5<br/><br/>        max_sum_so_far &lt; 0<br/>        false<br/><br/>        i++<br/>        i = 6<br/><br/>Step 8: i &lt; nums.length<br/>        6 &lt; 9<br/>        true<br/><br/>        max_sum_so_far += nums[6]<br/>        max_sum_so_far = 5 + 1<br/>        max_sum_so_far = 6<br/><br/>        max_sum &lt; 6<br/>        5 &lt; 6<br/>        true<br/><br/>        max_sum = max_sum_so_far<br/>        max_sum = 6<br/><br/>        max_sum_so_far &lt; 0<br/>        false<br/><br/>        i++<br/>        i = 7<br/><br/>Step 9: i &lt; nums.length<br/>        7 &lt; 9<br/>        true<br/><br/>        max_sum_so_far += nums[7]<br/>        max_sum_so_far = 6 + -5<br/>        max_sum_so_far = 1<br/><br/>        max_sum &lt; 6<br/>        6 &lt; 1<br/>        false<br/><br/>        max_sum_so_far &lt; 0<br/>        false<br/><br/>        i++<br/>        i = 8<br/><br/>Step 10: i &lt; nums.length<br/>         8 &lt; 9<br/>         true<br/><br/>         max_sum_so_far += nums[8]<br/>         max_sum_so_far = 1 + 4<br/>         max_sum_so_far = 5<br/><br/>         max_sum &lt; 6<br/>         6 &lt; 5<br/>         false<br/><br/>         max_sum_so_far &lt; 0<br/>         false<br/><br/>         i++<br/>         i = 9<br/><br/>Step 11: i &lt; nums.length<br/>         9 &lt; 9<br/>         false<br/><br/>Step 12: return max_sum<br/>         Answer is 6</span></pre></div><div class="ab cl lt lu gp lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="hb hc hd he hf"><p id="9cdb" class="pw-post-body-paragraph jk jl hi jm b jn kj jp jq jr kk jt ju jv kl jx jy jz km kb kc kd kn kf kg kh hb bi translated"><em class="ki">原载于</em><a class="ae ko" href="https://alkeshghorpade.me/post/leetcode-maximum-subarray" rel="noopener ugc nofollow" target="_blank"><em class="ki">https://alkeshghorpade . me</em></a><em class="ki">。</em></p></div></div>    
</body>
</html>