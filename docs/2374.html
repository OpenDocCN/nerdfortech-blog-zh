<html>
<head>
<title>A Taste of Erlang</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">一尝二郎</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/a-taste-of-erlang-15556adfd916?source=collection_archive---------13-----------------------#2021-05-03">https://medium.com/nerd-for-tech/a-taste-of-erlang-15556adfd916?source=collection_archive---------13-----------------------#2021-05-03</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/e5566c25129b49c54011430c8f763d0f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dVH9Sw89D0tPLG_nDqaUEg.jpeg"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">托马斯·索贝克在<a class="ae iu" href="https://unsplash.com/s/photos/telecommunication?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><p id="20a0" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">Erlang以一种极度渴求糖的语法而闻名，这导致了从Ruby引入优点，并最终发明了Elixir语言。然而，对于来自ML语言的人来说，比如OCaml或Haskell，甚至会感到熟悉。</p><p id="3dc0" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在本文中，我将探究这种语言是关于什么的，围绕它的讨论是什么，以及它有时是如何试图欺骗不知情的开发人员的。</p><h1 id="8717" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">从实验室到你的手掌</h1><p id="841f" class="pw-post-body-paragraph iv iw hi ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated">大约40年前，爱立信计算机科学实验室开始研究特别适合于实现电信解决方案的编程语言。逻辑编程语言Prolog是它的直接前身，但后来证明它对于实现核心功能来说太慢了，然后这些部分最终用c重写。在开发过程中，团队专注于发明一种适合电信需求的最小语言，这种语言还能够以高性能大规模并行运行，同时提供最大的正常运行时间。这些关键需求决定了该语言和相关生态系统的特性，并使该语言适用于使用一组称为开放电信平台(OTP)的Erlang库以接近实时的速度执行的编写服务器。</p><p id="9f54" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这种表现吸引了一些公司，他们的目标是为移动设备实现新的即时消息解决方案。其中一家公司是WhatsApp，他们的成功也让一些人开始关注Erlang及其平台。</p><h1 id="1e67" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">二郎是什么动物？</h1><p id="d1fc" class="pw-post-body-paragraph iv iw hi ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated">使Erlang适合于实现电信解决方案的需求也决定了该语言将具有什么样的特性。Erlang是一种函数式编程语言。它运行在一个需要编译的虚拟机中，但是它也能够在被称为<em class="kw"> erl </em>的REPL(读取-评估-打印循环)中解释运行。Erlang的虚拟机被称为BEAM(波格丹一世/比约恩的Erlang抽象机)，因此类似于Java或. NET的虚拟机。它们一起使得编写具有以下特征的应用程序成为可能:</p><ul class=""><li id="b436" class="kx ky hi ix b iy iz jc jd jg kz jk la jo lb js lc ld le lf bi translated"><strong class="ix hj">分布式</strong> —可以在几台机器上并行运行，同时仍然作为一个整体工作</li><li id="442e" class="kx ky hi ix b iy lg jc lh jg li jk lj jo lk js lc ld le lf bi translated"><strong class="ix hj">容错</strong> —优雅地接受错误，并能够在必要时重启自身的某些部分</li><li id="8b99" class="kx ky hi ix b iy lg jc lh jg li jk lj jo lk js lc ld le lf bi translated"><strong class="ix hj">软实时</strong> —它的响应时间几乎和那些用来驱动心脏起搏器或火箭的程序一样低</li><li id="24e7" class="kx ky hi ix b iy lg jc lh jg li jk lj jo lk js lc ld le lf bi translated"><strong class="ix hj">高可用性</strong> —系统始终保持在线，主要是因为它的容错能力，也因为它</li><li id="dc81" class="kx ky hi ix b iy lg jc lh jg li jk lj jo lk js lc ld le lf bi translated"><strong class="ix hj">热插拔</strong> —这意味着无需停止系统或应用程序本身就可以重新加载、替换或重启部分应用程序</li></ul><p id="c7e3" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">该语言实现了以下函数式编程概念(在一定程度上):</p><ul class=""><li id="fe25" class="kx ky hi ix b iy iz jc jd jg kz jk la jo lb js lc ld le lf bi translated"><strong class="ix hj">高阶函数</strong> —函数可以接受其他函数作为参数</li><li id="d951" class="kx ky hi ix b iy lg jc lh jg li jk lj jo lk js lc ld le lf bi translated"><strong class="ix hj">一级函数</strong> —函数可以匿名定义</li><li id="7e59" class="kx ky hi ix b iy lg jc lh jg li jk lj jo lk js lc ld le lf bi translated"><strong class="ix hj">不变性</strong> —变量的值在第一次赋值后不能改变</li><li id="90a9" class="kx ky hi ix b iy lg jc lh jg li jk lj jo lk js lc ld le lf bi translated"><strong class="ix hj">模式匹配</strong> —存储在复合数据类型中的值可以在参数、守卫、案例中提取；又名<em class="kw">解构</em></li><li id="7810" class="kx ky hi ix b iy lg jc lh jg li jk lj jo lk js lc ld le lf bi translated"><strong class="ix hj">急切求值</strong> —表达式一被赋值给变量就被求值，这与懒惰求值相反，懒惰求值只计算实际使用的时间</li><li id="d5b4" class="kx ky hi ix b iy lg jc lh jg li jk lj jo lk js lc ld le lf bi translated"><strong class="ix hj">单一赋值</strong> —变量在首次初始化后不能被重新赋值给新值</li><li id="a32d" class="kx ky hi ix b iy lg jc lh jg li jk lj jo lk js lc ld le lf bi translated"><strong class="ix hj">列表理解</strong> —从现有列表生成列表</li></ul><p id="fd35" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">它还具有<strong class="ix hj">动态类型</strong>，这意味着变量的类型不是在编译时强制或确保的，而是在运行时强制或确保的(尽管静态类型检查可以与名为<em class="kw">透析器</em>的可选工具一起使用)。</p><p id="e24c" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">Erlang应用程序通常作为大量轻量级进程运行，其中Erlang进程“比操作系统线程轻得多”。</p><p id="3ce0" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">运行时为Erlang变量分配的内存由单独运行的垃圾收集器动态自动释放。</p><h1 id="a94e" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">哪种动物不是？</h1><p id="10c2" class="pw-post-body-paragraph iv iw hi ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated">出于性能和其他实际原因，Erlang不得不做出一些牺牲，以区别于其他FP语言。Erlang不是一种纯粹的函数式语言，这意味着它不能避免副作用，事实上，出于实际原因，它在任何必要的时候都严重依赖于这些副作用。它也不是静态类型的，尽管可以在编译时用可选的工具检查类型。尽管Erlang运行时是软实时的，但它并不适用于实现高性能应用程序，因为在这些应用程序中，性能还会受到常数因素的影响，例如图像和信号处理以及大容量数据排序，以及必须进行低级访问的应用程序，如编写操作系统驱动程序。</p><h1 id="43f6" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">向二郎问好</h1><figure class="ll lm ln lo fd ij"><div class="bz dy l di"><div class="lp lq l"/></div></figure><p id="7086" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这里我们定义了一个模块(FP封装容器),它只导出一个函数，这个函数与除以零无关，但是不接受任何参数(因此是0 ),并在标准输出中打印一个字符串。在Erlang中，如果我们想要记录代码，百分号的数量会迅速增加(这里我只保留了两个百分号)。此外，新行不允许像往常一样在字符串中标记<code class="du lr ls lt lu b">\n</code>，而是使用<code class="du lr ls lt lu b">~n</code>，这增加了语言的怪异语法。</p><p id="22f9" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们可以在Erlang中这样声明一个值:<code class="du lr ls lt lu b">Value = 5</code>，但是这不能在模块级别上工作，只能在函数中工作。这令人困惑，因为我们被允许在REPL自由使用它们。然而，定义一个只返回我们指定的值的函数是完全有效的，以后可以随时调用:</p><pre class="ll lm ln lo fd lv lu lw lx aw ly bi"><span id="7c44" class="lz ju hi lu b fi ma mb l mc md">days() -&gt; [ mon, tue, wed, thu, fri, sat, sun ].<br/>months() -&gt; [ jan, feb, mar, apr, may, jun, jul, aug, sep, oct, nov, dec ].</span></pre><p id="94ae" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这些列表只包含<em class="kw"> atom </em> s，它们是类似于<em class="kw"> enum </em> s的自包含值，但是不必担心它们的值。</p><p id="d829" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">请注意，在Erlang中，指令以句点结尾，但这并不意味着逗号和分号将保持无效。</p><h1 id="34ba" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">潜入水中</h1><p id="f700" class="pw-post-body-paragraph iv iw hi ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated">假设我们想要编写一些日历函数，因为我们在Erlang的文档中找不到已经实现的函数，或者因为我们对它给出的结果不满意(<a class="ae iu" href="https://erlang.org/doc/man/calendar.html#date_to_gregorian_days-3" rel="noopener ugc nofollow" target="_blank">calendar:date _ to _ Gregorian _ days/3</a>返回0年和所提供的日期之间的天数，但是在公历中没有<a class="ae iu" href="https://en.wikipedia.org/wiki/Year_zero" rel="noopener ugc nofollow" target="_blank">0年</a>)。</p><p id="117d" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们可以这样做:</p><figure class="ll lm ln lo fd ij"><div class="bz dy l di"><div class="lp lq l"/></div></figure><p id="cc14" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">现在让我提一下在这个片段中我们可以当场抓住的一些Erlang特性。</p><ul class=""><li id="1c81" class="kx ky hi ix b iy iz jc jd jg kz jk la jo lb js lc ld le lf bi translated">第1行:为了立即执行，使用<code class="du lr ls lt lu b">.</code></li><li id="e310" class="kx ky hi ix b iy lg jc lh jg li jk lj jo lk js lc ld le lf bi translated">第29–33行:带<code class="du lr ls lt lu b">when</code>的守卫</li><li id="b025" class="kx ky hi ix b iy lg jc lh jg li jk lj jo lk js lc ld le lf bi translated">36:与<code class="du lr ls lt lu b">=:=</code>逻辑相等</li><li id="32b0" class="kx ky hi ix b iy lg jc lh jg li jk lj jo lk js lc ld le lf bi translated">37: <em class="kw">我们还没有结束</em>和<code class="du lr ls lt lu b">;</code>——编写替代实现的Erlang方式，这里是<code class="du lr ls lt lu b">else if</code></li><li id="8f50" class="kx ky hi ix b iy lg jc lh jg li jk lj jo lk js lc ld le lf bi translated">39:如果我有另外一个<em class="kw">或者</em> …</li><li id="8ffe" class="kx ky hi ix b iy lg jc lh jg li jk lj jo lk js lc ld le lf bi translated">42，47:多态函数——我们为二月定义了单独的逻辑</li><li id="8a49" class="kx ky hi ix b iy lg jc lh jg li jk lj jo lk js lc ld le lf bi translated">53:列表理解生成一个月中每一天的列表</li><li id="1f49" class="kx ky hi ix b iy lg jc lh jg li jk lj jo lk js lc ld le lf bi translated">55:获取列表头部和尾部的模式匹配</li><li id="ce7d" class="kx ky hi ix b iy lg jc lh jg li jk lj jo lk js lc ld le lf bi translated">58:匿名函数是<code class="du lr ls lt lu b">fun</code></li><li id="d0c7" class="kx ky hi ix b iy lg jc lh jg li jk lj jo lk js lc ld le lf bi translated">58:更诡异的逻辑不等式<code class="du lr ls lt lu b">=/=</code></li><li id="adcd" class="kx ky hi ix b iy lg jc lh jg li jk lj jo lk js lc ld le lf bi translated">70–76:函数重载</li><li id="9344" class="kx ky hi ix b iy lg jc lh jg li jk lj jo lk js lc ld le lf bi translated">75:迷惑不知情的人:<code class="du lr ls lt lu b">=&lt;</code></li><li id="8911" class="kx ky hi ix b iy lg jc lh jg li jk lj jo lk js lc ld le lf bi translated">81:带花括号的元组</li><li id="01ea" class="kx ky hi ix b iy lg jc lh jg li jk lj jo lk js lc ld le lf bi translated">81、82:用<code class="du lr ls lt lu b">,</code>连续做事</li></ul><p id="ed8b" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">《准则》中没有提到的荣誉奖，但会引起很多令人头疼的问题:</p><pre class="ll lm ln lo fd lv lu lw lx aw ly bi"><span id="66f8" class="lz ju hi lu b fi ma mb l mc md">Y = 1.<br/>M = jan.<br/>Y =:= 1 and M =:= jan.</span></pre><p id="9535" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这将给你:</p><pre class="ll lm ln lo fd lv lu lw lx aw ly bi"><span id="bac1" class="lz ju hi lu b fi ma mb l mc md">* 1: syntax error before: '=:='</span></pre><p id="7b47" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这不是很有帮助，但是在Erlang中会出现错误消息。对于那些好奇的人来说，问题不在于相等运算符，而在于享有优先权的<code class="du lr ls lt lu b">and</code>，因此<code class="du lr ls lt lu b">1 and M</code>抢了风头，让解释器对<code class="du lr ls lt lu b">Y =:=</code>可能意味着什么一无所知。要解决这个问题，请使用括号:</p><pre class="ll lm ln lo fd lv lu lw lx aw ly bi"><span id="4005" class="lz ju hi lu b fi ma mb l mc md">(Y =:= 1) and (M =:= jan).</span></pre><p id="f8b8" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">返回<code class="du lr ls lt lu b">true</code>。宇宙平衡恢复了。</p><h1 id="d495" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">变得无助</h1><p id="39c1" class="pw-post-body-paragraph iv iw hi ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated">不知何故，Erlang网站上的<a class="ae iu" href="https://www.erlang.org/docs" rel="noopener ugc nofollow" target="_blank">文档忠实地反映了这种语言的怪异之处，并且很容易让人迷失。有些函数看起来并不合理(<code class="du lr ls lt lu b">hd</code>、<code class="du lr ls lt lu b">tl</code>——列表的头部和尾部，但不在<code class="du lr ls lt lu b">lists</code>模块中)，有些类别(如<code class="du lr ls lt lu b">erts</code>)对新手来说毫无意义。</a></p><p id="c3f3" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们可以把这理解为一种尝试，让不熟悉的开发人员在获得他们所寻找的信息之前浏览整个文档。这有时会使我们感到无助，而不是得到帮助。然而，内容本身足够清晰明了，所以花在文档上的时间并没有浪费。</p><h1 id="8757" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">裁决</h1><p id="e378" class="pw-post-body-paragraph iv iw hi ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated">我有什么资格评判像Erlang这样强大而伟大的语言呢？我甚至还没有触及到这里的表面！我应该谈过Erlang控制并发性的方式、OTP库、它对<a class="ae iu" href="https://en.wikipedia.org/wiki/Actor_model" rel="noopener ugc nofollow" target="_blank"> Actor模型</a>的实现等等，但是正如标题所示，我在这里的目标只是尝试一下语言本身。说到这里，我可以说<strong class="ix hj"> Erlang非常有趣！</strong></p><p id="ef25" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">尽管它有些古怪，但其著名的性能和(否则)干净的风格吸引人们去了解更多。毕竟，它与其他FP语言没有太大的不同，尤其是与ML领域的语言。虽然它没有那么严格，这使得潜水相对容易。伟大的书籍也可以开始使用，安装工具集也是小菜一碟。</p><p id="8451" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我想说，对于那些对消息传递和类似特性感兴趣，但不是纯粹主义者的人来说，这绝对值得一试，熟悉一下。这也意味着对那些打算使用它的副产品——长生不老药的人来说是一个巨大的好处。Erlang可以提供很多东西，并且在自己的领域做得非常好，证明了它最近受到的关注。</p></div></div>    
</body>
</html>