<html>
<head>
<title>Binary Heaps</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">二进制堆</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/binary-heaps-2ff5b484a002?source=collection_archive---------0-----------------------#2022-07-16">https://medium.com/nerd-for-tech/binary-heaps-2ff5b484a002?source=collection_archive---------0-----------------------#2022-07-16</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/63142294b299132e465b5f67966d71b7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*ai0fwmDDl1ZM9g-u"/></div></div></figure><p id="6c89" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">二进制堆是一种有自己一套规则的<a class="ae jo" rel="noopener" href="/nerd-for-tech/binary-search-tree-a0b0e7d8567a">二叉树</a>。有两种类型的二进制堆，即最大堆和最小堆。</p><p id="9faf" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">规则</strong></p><p id="a188" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">二进制 max-heap 遵循的第一条规则是，每个节点的值必须大于其所有后代的值。这意味着，如果您正在查看的节点是 8，那么后面的所有节点都必须小于 8。在二进制最小堆中，每个节点的值必须小于其所有后代的值。如您所见，根据您创建的二进制堆的类型，规则是相反的。</p><p id="223e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">二进制最大堆示例</p><figure class="jq jr js jt fd ij er es paragraph-image"><div class="er es jp"><img src="../Images/9c800d578401600488fcb8ad84b18fe7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1160/format:webp/1*yKPzoqz4bv6x5JIFcmYDuA.png"/></div></figure><p id="9b5b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">第二条规则是二进制堆必须是一棵完整的树。一个完整的树是一个完全充满节点的树。这意味着当从左向右阅读树时，所有节点都在那里。例外情况是，只要空节点右侧没有节点，底部行上的节点就可能会丢失。</p><p id="151e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">左边是一个完整树的示例，缺少底部行中的节点。右边是一个不完整树的例子，因为空节点的右边有节点。</p><div class="jq jr js jt fd ab cb"><figure class="ju ij jv jw jx jy jz paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><img src="../Images/30b61560b44f0569c50d7df9393c70e2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1024/format:webp/1*zN0CvT76FTPQZ2HvLSZNCQ.png"/></div></figure><figure class="ju ij ka jw jx jy jz paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><img src="../Images/32f66c78d9ed70ba4271a902a5cacdcc.png" data-original-src="https://miro.medium.com/v2/resize:fit:978/format:webp/1*VCO2_JGrJjhytQhW0_basw.png"/></div></figure></div><p id="7fab" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">插入</strong></p><p id="aa9c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">为了插入一个值，我们创建一个新的节点，并把它放在堆底层的最右边。在 max-heap 中，我们将比较新节点和它的父节点，如果新节点大于父节点，就交换它们。这将被重复，直到新值得到一个大于它自身的父节点或者它是新的根节点。对于最小堆，这是相同的过程，只是如果新节点小于父节点，您将切换值。</p><p id="d90b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在最大堆中插入 45</p><figure class="jq jr js jt fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es kb"><img src="../Images/62f7f8b6a9fc7c65698b516b52cbcbba.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zX3sSz36YH8DI8jbcCbEBw.png"/></div></div></figure><p id="de88" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这里的方块代表最右边的点。我们将把 45 和它的父代 12 进行比较。45 大于 12，因此我们将交换它们。</p><figure class="jq jr js jt fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es kc"><img src="../Images/e8cf6f68709cc02bca87ebb957996097.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ij_n3UOBYL25ryhmb69lDw.png"/></div></div></figure><p id="1c3f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">再次将 45 与其新的父代 33 进行比较。45 大于 33，因此我们将交换它们。</p><figure class="jq jr js jt fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es kd"><img src="../Images/04796c97358afd07cf041ab9660d8664.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hnsrcDqRJmwjdQwAau1OYg.png"/></div></div></figure><p id="927e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">最后，我们将比较 45 和它的新父代 50。50 大于 45，所以我们知道 45 在正确的位置。</p><p id="d3aa" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">删除</strong></p><p id="3465" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">当从二进制堆中删除时，我们将只删除根节点。要删除，我们将把最后一个节点移到根节点。这将删除根节点的原始值。如果你使用的是最大堆，那么你将比较父堆和子堆的值，并用两个值中较大的一个来交换。这将继续下去，直到节点在正确的位置。对于最小堆，除了父堆将与两个值中最小的一个交换之外，其他都是一样的。</p><p id="35a1" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">从最大堆中删除 50</p><figure class="jq jr js jt fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es kc"><img src="../Images/0d4279059aa2cdd288b21ce265ff08bf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4FxkF87rdJEU8egShnIO_g.png"/></div></div></figure><p id="6c36" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">首先，用堆中的最后一个节点替换 50。</p><figure class="jq jr js jt fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ke"><img src="../Images/c6be3d6887b68ace55f43f7c44889044.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lZNFWImGHP6DACS2lTmiww.png"/></div></div></figure><p id="8afb" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这个方块表示 12 是从这个位置开始的，因为它是堆中的最后一个节点。</p><p id="f793" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">接下来，将 12 与其子节点 45 和 25 进行比较。我们将把 12 和 45 交换，因为它是两个孩子之间的较大值。</p><figure class="jq jr js jt fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es kf"><img src="../Images/bf91cf5c9c85d7189d79ce4edcfaba2d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lUtmotlnvvFQ4gkLF73Evw.png"/></div></div></figure><p id="e58b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在比较一下 12 和它的新成员 20 和 33。33 是最大值，因此我们将交换 33 和 12。</p><figure class="jq jr js jt fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es kg"><img src="../Images/c61f88cf8af1dab3e597d81c742fd4da.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CdKgx9hO0woe1DMHWVAGuA.png"/></div></div></figure><p id="8774" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们现在完成了，因为这 12 个孩子已经没有了。</p><p id="48f0" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">用例</strong></p><p id="bb63" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">二进制堆是实现优先级队列的最佳选择。优先级队列类似于常规队列，删除和访问是相同的。不同之处在于这些值是以特定的顺序插入的。优先队列的一个完美例子是急诊室中使用的分类系统。当患者进入急诊室时，他们的病情严重程度会得到评估，并据此将他们加入队列。这使得医院可以先治疗病情较重的病人。二进制堆很好地解决了这个问题，因为根总是优先级最高的病人。</p><p id="6d2e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">关于二进制堆实现的更多信息，请查看 G<a class="ae jo" href="https://www.geeksforgeeks.org/binary-heap/" rel="noopener ugc nofollow" target="_blank">eeksforgeks</a>的这篇文章。</p></div></div>    
</body>
</html>