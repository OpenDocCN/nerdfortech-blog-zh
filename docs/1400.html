<html>
<head>
<title>Matt’s Tidbits #91 — The power of sharing</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Matt的第91期花絮——分享的力量</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/matts-tidbits-91-the-power-of-sharing-31e5407d456c?source=collection_archive---------23-----------------------#2021-03-16">https://medium.com/nerd-for-tech/matts-tidbits-91-the-power-of-sharing-31e5407d456c?source=collection_archive---------23-----------------------#2021-03-16</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/38aac84142469fb3e19295382d341213.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*emarK1xFUj42xdKh6D2nAA.jpeg"/></div></div></figure><p id="dd3e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><a class="ae jo" href="https://matthew-b-groves.medium.com/matts-tidbits-90-all-about-dashboards-and-another-milestone-9695a68f0ee" rel="noopener">上周，我写了关于仪表盘和庆祝马特两周年的花絮！</a>这一次，我想分享…关于分享！</p><p id="e8ee" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">你写过类似这样的代码吗？</p><figure class="jp jq jr js fd ij"><div class="bz dy l di"><div class="jt ju l"/></div></figure><p id="76d6" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如果是这样，你可能遇到了问题——如果某个特定的<code class="du jv jw jx jy b">start()</code>呼叫者忘记呼叫<code class="du jv jw jx jy b">stop()</code>或者更糟——呼叫它不止一次怎么办？这类问题非常普遍，尤其是在多线程环境中。</p><p id="807e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如果再加上尝试将引用计数与RxJava结合起来，问题就变得更加复杂了。然而，我最近发现了一个相当神奇的操作者——<code class="du jv jw jx jy b">share</code>。</p><p id="266e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">从文档中:</p><blockquote class="jz ka kb"><p id="4aac" class="iq ir kc is b it iu iv iw ix iy iz ja kd jc jd je ke jg jh ji kf jk jl jm jn hb bi translated">返回一个新的<code class="du jv jw jx jy b">Observable</code>，它多播(并共享一个订阅)当前的<code class="du jv jw jx jy b">Observable</code>。只要至少有一个<code class="du jv jw jx jy b">Observer</code>，电流<code class="du jv jw jx jy b">Observable</code>就会保持订阅，不断发出信号。当所有观察者都被处置后，操作员将处置对当前<code class="du jv jw jx jy b">Observable</code>的订阅。</p></blockquote><figure class="jp jq jr js fd ij er es paragraph-image"><a href="https://raw.githubusercontent.com/wiki/ReactiveX/RxJava/images/rx-operators/publishRefCount.o.v3.png"><div class="er es kg"><img src="../Images/370c79cb59fc56d064b42bfef4362af5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GWjDMSA0gyLMlcg4820BDQ.png"/></div></a></figure><p id="2a9e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这意味着我们可以使用这个操作符来导致底层的可观察对象被重新计数！但是，除此之外——您的底层代码实际上不必使用RxJava——我们可以使用rx Java作为实现引用计数的机制，在我看来，这提供了一个稍微干净的实现。</p><p id="e3d9" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">下面是一个可能的例子:</p><figure class="jp jq jr js fd ij"><div class="bz dy l di"><div class="jt ju l"/></div></figure><p id="c5c5" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这个解决方案的神奇之处在于，我们让RxJava为我们执行引用计数！</p><p id="8e04" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">浏览代码，主要部分如下:</p><ol class=""><li id="9482" class="kh ki hi is b it iu ix iy jb kj jf kk jj kl jn km kn ko kp bi translated">想要使用它的客户机将调用<code class="du jv jw jx jy b">runSomeOperationThatStartsAndStopsAutomatically()</code>，订阅返回的<code class="du jv jw jx jy b">Completable</code>，并在它们不再希望操作运行时处理它。</li><li id="7400" class="kh ki hi is b it kq ix kr jb ks jf kt jj ku jn km kn ko kp bi translated">在幕后，我们的manager类检查操作是否已经在运行——如果没有，就启动它(以线程安全的方式)。</li><li id="41da" class="kh ki hi is b it kq ix kr jb ks jf kt jj ku jn km kn ko kp bi translated">当可观察对象被创建时(注意它实际上是一个可观察对象——rx Java没有为<code class="du jv jw jx jy b">Single</code>或<code class="du jv jw jx jy b">Completable</code>类型提供<code class="du jv jw jx jy b">share()</code>操作符)，我们使用<code class="du jv jw jx jy b">.doOnSubscribe</code>和<code class="du jv jw jx jy b">.doOnDispose</code>操作符来启动/停止底层操作。使这个工作的是对<code class="du jv jw jx jy b">share()</code>的调用，这意味着这些副作用方法只运行一次。</li><li id="4cb6" class="kh ki hi is b it kq ix kr jb ks jf kt jj ku jn km kn ko kp bi translated">当所有客户端都取消订阅时，底层操作将停止，<code class="du jv jw jx jy b">completable</code>将被清除，因此下一个尝试使用它的客户端将再次启动操作。</li></ol><p id="e671" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这种机制允许多个客户端使用这种共享功能，并确保它实际上只运行一次。这种解决方案的一个好处是底层操作可能会抛出一个错误，任何订阅的人都会得到通知，以便他们可以对此做出反应。</p><p id="9a49" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">请注意，这种方法仍然容易受到某人忘记取消订阅的影响(因此可能会阻止底层操作关闭)——但是单个客户端取消订阅超过一次是不可能的。这是我喜欢这种模式的主要原因之一——它通过使用更具表现力的API减少了程序员出错的可能性。</p></div><div class="ab cl kv kw gp kx" role="separator"><span class="ky bw bk kz la lb"/><span class="ky bw bk kz la lb"/><span class="ky bw bk kz la"/></div><div class="hb hc hd he hf"><p id="4024" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><a class="ae jo" href="https://jeff-padgett.medium.com/how-to-make-viewmodel-observe-android-lifecycle-events-and-how-to-unit-test-lifecycle-events-d5be727da8d7" rel="noopener">本着分享的精神，你也应该看看我的同事杰夫·帕吉特关于ViewModel生命周期管理的精彩新帖！</a></p></div><div class="ab cl kv kw gp kx" role="separator"><span class="ky bw bk kz la lb"/><span class="ky bw bk kz la lb"/><span class="ky bw bk kz la"/></div><div class="hb hc hd he hf"><p id="215a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">您是如何在项目中使用<code class="du jv jw jx jy b">share()</code>操作符的？请在下面的评论中分享！</p><p id="aeea" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">有兴趣和我一起在埃森哲出色的数字产品团队工作吗？<a class="ae jo" href="https://www.intrepid.io/careers" rel="noopener ugc nofollow" target="_blank">我们在招人！</a></p></div></div>    
</body>
</html>