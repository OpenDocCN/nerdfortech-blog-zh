<html>
<head>
<title>Nested recycler in Android done right!</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Android 中的嵌套回收器做得很好！</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/nested-recycler-in-android-done-right-b101744e2a9a?source=collection_archive---------0-----------------------#2021-02-22">https://medium.com/nerd-for-tech/nested-recycler-in-android-done-right-b101744e2a9a?source=collection_archive---------0-----------------------#2021-02-22</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/616b8133d130e2461d6ac274d2db195e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*f-_87yu5u9MWFb4KRFzxdQ.jpeg"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">米卡·鲍梅斯特在<a class="ae iu" href="https://unsplash.com/s/photos/mobile-phone-android?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><p id="1182" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">TL；DR </strong> : <em class="jt">这篇文章解决了垂直滚动和水平滚动手势被注册为垂直时水平滚动位置丢失的问题。参考</em> <a class="ae iu" href="https://github.com/minarja1/NestedRecyclerSample" rel="noopener ugc nofollow" target="_blank"> <em class="jt">本 GitHub repo 带示例 app </em> </a> <em class="jt">查看解决方案。</em></p><p id="796d" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">包括<em class="jt">网飞</em>和<em class="jt"> Play Store </em>在内的许多应用程序使用嵌套回收器模式，在一个垂直视图中嵌入多个水平可滚动视图。用<a class="ae iu" href="https://developer.android.com/guide/topics/ui/layout/recyclerview" rel="noopener ugc nofollow" target="_blank"> RecyclerView </a>在 Android 中实现这样的结构看起来很简单。的确如此。</p><p id="e2af" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">但是…有几件事需要调整，以使一切顺利并按预期运行。让我们直入主题吧。</p><p id="a8a4" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">让我们创建一个显示动物部分的应用程序。每个部分都有一个<em class="jt">标题</em>，每个动物都有一个<em class="jt">名字</em>和一个<em class="jt">图像。结果应该是这样的:</em></p><figure class="jv jw jx jy fd ij er es paragraph-image"><div class="er es ju"><img src="../Images/a725987d9101c8afda321424e99407a4.png" data-original-src="https://miro.medium.com/v2/resize:fit:540/format:webp/1*glCjJXRvKaraAjBwx1XfPw.png"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">示例应用程序截图:嵌套回收器和动物部分。</figcaption></figure><h1 id="27f8" class="jz ka hi bd kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw bi translated">数据</h1><p id="eabb" class="pw-post-body-paragraph iv iw hi ix b iy kx ja jb jc ky je jf jg kz ji jj jk la jm jn jo lb jq jr js hb bi translated">数据结构如下:</p><figure class="jv jw jx jy fd ij"><div class="bz dy l di"><div class="lc ld l"/></div></figure><h1 id="9eb3" class="jz ka hi bd kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw bi translated">布局</h1><p id="aafc" class="pw-post-body-paragraph iv iw hi ix b iy kx ja jb jc ky je jf jg kz ji jj jk la jm jn jo lb jq jr js hb bi translated">我们需要一个动物个体的布局。布局<a class="ae iu" href="https://github.com/minarja1/NestedRecyclerSample/blob/developv2/app/src/main/res/layout/item_animal.xml" rel="noopener ugc nofollow" target="_blank"><em class="jt">item _ animal . XML</em></a><em class="jt"/>包含一个 CardView，带有 ImageView、TextView 和渐变，使文本弹出。</p><figure class="jv jw jx jy fd ij er es paragraph-image"><div class="er es le"><img src="../Images/8c3868ea0685f6fb8294afb16f69bfb3.png" data-original-src="https://miro.medium.com/v2/resize:fit:912/format:webp/1*xTlQhRWzmi8YhIqkncNkaA.png"/></div></figure><p id="cdf1" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">接下来，我们需要标题部分的布局和嵌套的 recycler view:<a class="ae iu" href="https://github.com/minarja1/NestedRecyclerSample/blob/developv2/app/src/main/res/layout/item_animal_section.xml" rel="noopener ugc nofollow" target="_blank"><em class="jt">item _ animal _ section . XML</em></a></p><figure class="jv jw jx jy fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lf"><img src="../Images/fae33e3adb6105a2057e1899c2ce742f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qLCkmtgCY4XGzrIhVLYn-A.png"/></div></div></figure><p id="9912" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><a class="ae iu" href="https://github.com/minarja1/NestedRecyclerSample/blob/developv2/app/src/main/res/layout/activity_main.xml" rel="noopener ugc nofollow" target="_blank"> activity_main.xml </a>只包含一个回收器。</p><h1 id="c5d8" class="jz ka hi bd kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw bi translated">适配器</h1><p id="6e18" class="pw-post-body-paragraph iv iw hi ix b iy kx ja jb jc ky je jf jg kz ji jj jk la jm jn jo lb jq jr js hb bi translated">接下来，我们需要我们的适配器。为了这个教程，我使用一个简单的<a class="ae iu" href="https://developer.android.com/reference/androidx/recyclerview/widget/RecyclerView.Adapter" rel="noopener ugc nofollow" target="_blank"> RecyclerView。适配器</a>。在现实生活中，你可能会想去<a class="ae iu" href="https://developer.android.com/reference/androidx/recyclerview/widget/ListAdapter" rel="noopener ugc nofollow" target="_blank">看看回收。列表适配器</a>。</p><p id="3d67" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><a class="ae iu" href="https://github.com/minarja1/NestedRecyclerSample/blob/developv2/app/src/main/java/com/example/nestedrecyclersample/ui/adapter/AnimalAdapter.kt" rel="noopener ugc nofollow" target="_blank"><em class="jt">animaladapter . kt</em></a><em class="jt">使用</em><a class="ae iu" href="https://github.com/minarja1/NestedRecyclerSample/blob/developv2/app/src/main/res/layout/item_animal.xml" rel="noopener ugc nofollow" target="_blank"><em class="jt">item _ animal . XML</em></a>和<em class="jt"> onBindViewHolder </em>方法设置名称并加载图像(使用<a class="ae iu" href="https://github.com/coil-kt/coil" rel="noopener ugc nofollow" target="_blank">线圈库</a>):</p><figure class="jv jw jx jy fd ij"><div class="bz dy l di"><div class="lc ld l"/></div></figure><p id="6e87" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><a class="ae iu" href="https://github.com/minarja1/NestedRecyclerSample/blob/developv2/app/src/main/java/com/example/nestedrecyclersample/ui/adapter/AnimalSectionAdapter.kt" rel="noopener ugc nofollow" target="_blank"><em class="jt">animalsectionadapter . kt</em></a>使用<a class="ae iu" href="https://github.com/minarja1/NestedRecyclerSample/blob/developv2/app/src/main/res/layout/item_animal_section.xml" rel="noopener ugc nofollow" target="_blank"><em class="jt">item _ animal _ section . XML</em></a><em class="jt"/>和<em class="jt"> onBindViewHolder </em>方法设置节的标题和嵌套回收器的适配器:</p><figure class="jv jw jx jy fd ij"><div class="bz dy l di"><div class="lc ld l"/></div></figure><h1 id="ae8b" class="jz ka hi bd kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw bi translated">把所有的放在一起</h1><p id="8fb1" class="pw-post-body-paragraph iv iw hi ix b iy kx ja jb jc ky je jf jg kz ji jj jk la jm jn jo lb jq jr js hb bi translated">对于父回收器(垂直)，我们将使用一个<a class="ae iu" href="https://developer.android.com/reference/androidx/recyclerview/widget/ConcatAdapter" rel="noopener ugc nofollow" target="_blank"> ConcatAdapter </a>。这在技术上是不必要的，但这是一个好习惯，因为如果你决定以此为基础，它会让你的生活更容易。该结构如下图所示(MS 绘画技能:10/10):</p><figure class="jv jw jx jy fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lg"><img src="../Images/376bb0aa616082d5b17b7638d3a6759d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SLJEGS_fu3y6uqYfnGXwmg.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">图示的单个适配器。</figcaption></figure><p id="d466" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们现在需要做的就是创建一些假数据(这不是本教程的重点；在 GitHub repo 查看我的<a class="ae iu" href="https://medium.com/r?url=https%3A%2F%2Fgithub.com%2Fminarja1%2FNestedRecyclerSample%2Fblob%2Fdevelopv2%2Fapp%2Fsrc%2Fmain%2Fjava%2Fcom%2Fexample%2Fnestedrecyclersample%2Fdata%2FDataSource.kt" rel="noopener">数据源，看看我如何创建列表，或者创建自己的逻辑)并填充适配器。</a></p><p id="7fdb" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><a class="ae iu" href="https://github.com/minarja1/NestedRecyclerSample/blob/developv2/app/src/main/java/com/example/nestedrecyclersample/ui/MainActivity.kt" rel="noopener ugc nofollow" target="_blank"><em class="jt">main activity . kt:</em>T3】</a></p><figure class="jv jw jx jy fd ij"><div class="bz dy l di"><div class="lc ld l"/></div></figure><p id="678b" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">瞧，我们已经创建了工作嵌套回收视图！</p><p id="119f" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">但是我们真的做到了吗？</p><h1 id="20a2" class="jz ka hi bd kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw bi translated">这些问题</h1><h2 id="7fbe" class="lh ka hi bd kb li lj lk kf ll lm ln kj jg lo lp kn jk lq lr kr jo ls lt kv lu bi translated">1.回收再利用者</h2><p id="821c" class="pw-post-body-paragraph iv iw hi ix b iy kx ja jb jc ky je jf jg kz ji jj jk la jm jn jo lb jq jr js hb bi translated">第一个问题是由我们的<em class="jt"> AnimalSectionAdapter </em>(意思是整行)中的单个视图被回收这一事实引起的。这导致垂直滚动时水平滚动位置丢失:</p><figure class="jv jw jx jy fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lv"><img src="../Images/971e468d70341d6a9ff014279dbb71c3.png" data-original-src="https://miro.medium.com/v2/resize:fit:394/1*Pvah38QzC22yMRmPxPA3hQ.gif"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">垂直滚动时，首行的水平滚动位置丢失。</figcaption></figure><p id="1e9c" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">为了解决这个问题，我们需要在每行被回收或绑定时分别手动保存和恢复每行的水平滚动状态。</p><p id="3ff5" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">为此，我们需要在我们的<em class="jt"/><a class="ae iu" href="https://github.com/minarja1/NestedRecyclerSample/blob/developv2/app/src/main/java/com/example/nestedrecyclersample/ui/adapter/AnimalSectionAdapter.kt" rel="noopener ugc nofollow" target="_blank"><em class="jt">AnimalSectionAdapter</em></a><em class="jt">a</em>中保存<em class="jt"> onViewRecycled </em>方法中的状态，并在<em class="jt"> onBindViewHolder </em>方法<em class="jt">中恢复状态。</em></p><p id="49be" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">为了保持状态，将使用一个<em class="jt">可变映射</em>，其键是相应行的 ID。</p><p id="ee72" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><a class="ae iu" href="https://github.com/minarja1/NestedRecyclerSample/blob/developv2/app/src/main/java/com/example/nestedrecyclersample/ui/adapter/AnimalSectionAdapter.kt" rel="noopener ugc nofollow" target="_blank"><em class="jt">animalsectionadapter . kt</em></a></p><figure class="jv jw jx jy fd ij"><div class="bz dy l di"><div class="lc ld l"/></div></figure><h2 id="b20d" class="lh ka hi bd kb li lj lk kf ll lm ln kj jg lo lp kn jk lq lr kr jo ls lt kv lu bi translated">2.注册为垂直的水平刷卡</h2><figure class="jv jw jx jy fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lw"><img src="../Images/a7072f7713423a2edc251b65b8bacaeb.png" data-original-src="https://miro.medium.com/v2/resize:fit:396/1*0XajJqI-TC-NNrnvCKJ2vQ.gif"/></div></div></figure><p id="0d8a" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">第二个问题是，我们有两个视图，滚动方向相反。Christophe Beyls 已经在他的文章中解决了这个问题。)我们将使用他的出色解决方案，而不是重新发明轮子。</p><p id="2315" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">基于 Christophe 的解决方案，我们将创建一个<a class="ae iu" href="https://github.com/minarja1/NestedRecyclerSample/blob/developv2/app/src/main/java/com/example/nestedrecyclersample/utils/ViewExtensions.kt" rel="noopener ugc nofollow" target="_blank"> <em class="jt"> Kotlin 扩展</em> </a>来解决这个问题。</p><p id="aba7" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi">.</p><figure class="jv jw jx jy fd ij"><div class="bz dy l di"><div class="lc ld l"/></div></figure><p id="8e7a" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">并在我们的<a class="ae iu" href="https://github.com/minarja1/NestedRecyclerSample/blob/developv2/app/src/main/java/com/example/nestedrecyclersample/ui/MainActivity.kt" rel="noopener ugc nofollow" target="_blank"><em class="jt">main activity . kt</em></a>的<em class="jt"> initViews </em>方法<em class="jt"> : </em>中调用它</p><figure class="jv jw jx jy fd ij"><div class="bz dy l di"><div class="lc ld l"/></div></figure><h1 id="64ff" class="jz ka hi bd kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw bi translated">奖金:优化！</h1><h2 id="6dcc" class="lh ka hi bd kb li lj lk kf ll lm ln kj jg lo lp kn jk lq lr kr jo ls lt kv lu bi translated">观景池</h2><p id="d12f" class="pw-post-body-paragraph iv iw hi ix b iy kx ja jb jc ky je jf jg kz ji jj jk la jm jn jo lb jq jr js hb bi translated">默认情况下，每个嵌套的 RecyclerView 都有自己的<a class="ae iu" href="https://developer.android.com/reference/androidx/recyclerview/widget/RecyclerView.RecycledViewPool" rel="noopener ugc nofollow" target="_blank">视图池</a>来回收。这不是最佳选择，因为我们知道视图总是相同的，所以一个池就足够了。</p><p id="da9a" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们可以通过在我们的<a class="ae iu" href="https://github.com/minarja1/NestedRecyclerSample/blob/developv2/app/src/main/java/com/example/nestedrecyclersample/ui/adapter/AnimalSectionAdapter.kt" rel="noopener ugc nofollow" target="_blank"><em class="jt">AnimalSectionAdapter</em></a><em class="jt"/>中创建一个池并将其设置为每个嵌套的 RecyclerViews 来轻松实现这一点。</p><figure class="jv jw jx jy fd ij"><div class="bz dy l di"><div class="lc ld l"/></div></figure><h2 id="e864" class="lh ka hi bd kb li lj lk kf ll lm ln kj jg lo lp kn jk lq lr kr jo ls lt kv lu bi translated">初始预取项目计数</h2><p id="b67b" class="pw-post-body-paragraph iv iw hi ix b iy kx ja jb jc ky je jf jg kz ji jj jk la jm jn jo lb jq jr js hb bi translated">正如 Christophe Beyls 自己所指出的:</p><blockquote class="lx ly lz"><p id="d703" class="iv iw jt ix b iy iz ja jb jc jd je jf ma jh ji jj mb jl jm jn mc jp jq jr js hb bi translated">在嵌套的 RecyclerView 的<code class="du md me mf mg b">LinearLayoutManager</code>上，您应该使用将可见的水平项目的估计数量来调用<code class="du md me mf mg b">setInitialPrefetechItemCount()</code>。当预取包含水平 RecyclerView 的<code class="du md me mf mg b">ViewHolder</code>时，父 RecyclerView 将要求子 RecyclerView 预绑定一整行项目，由于子 RecyclerView 在布局之前无法知道将显示多少项目，因此您需要自己提供该信息。如果不这样做，默认情况下只有 2 个项目会被预绑定，其余的将在预取后当行被布局并可见时被绑定，这会导致性能降低。</p></blockquote><p id="2382" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们将在<a class="ae iu" href="https://github.com/minarja1/NestedRecyclerSample/blob/developv2/app/src/main/java/com/example/nestedrecyclersample/ui/adapter/AnimalSectionAdapter.kt" rel="noopener ugc nofollow" target="_blank"> <em class="jt"> AnimalSectionAdapter 的</em></a><em class="jt">onBindViewHolder:</em>中做同样的事情</p><figure class="jv jw jx jy fd ij"><div class="bz dy l di"><div class="lc ld l"/></div></figure><h1 id="54e2" class="jz ka hi bd kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw bi translated">结论</h1><p id="28a9" class="pw-post-body-paragraph iv iw hi ix b iy kx ja jb jc ky je jf jg kz ji jj jk la jm jn jo lb jq jr js hb bi translated">完整代码可从 this <a class="ae iu" href="https://github.com/minarja1/NestedRecyclerSample" rel="noopener ugc nofollow" target="_blank"> GitHub repo </a>获得。</p><p id="fe09" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">构建一个相当复杂的嵌套 RecyclerView 布局是一项如此常见的任务，以至于人们会认为它开箱即可完美工作。然而，不幸的是，在 Android 世界中，情况并非如此。我在这篇文章中解决了这个问题，创建了一个示例应用程序，您可以用它来解决自己的类似问题。祝你好运！</p></div></div>    
</body>
</html>