<html>
<head>
<title>Naming (in code) — The ultimate guide and reference</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">命名(用代码)——终极指南和参考</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/naming-in-code-the-ultimate-guide-and-reference-d356c8f7c387?source=collection_archive---------18-----------------------#2021-06-15">https://medium.com/nerd-for-tech/naming-in-code-the-ultimate-guide-and-reference-d356c8f7c387?source=collection_archive---------18-----------------------#2021-06-15</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/006cb93addb2e41a9f221a814f173a0e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QpLKavD3LDJSpLltH3JxQw.jpeg"/></div></div></figure><figure class="iq ir is it fd ij"><div class="bz dy l di"><div class="iu iv l"/></div></figure><p id="efb6" class="pw-post-body-paragraph iw ix hi iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt hb bi translated"><a class="ae ju" href="https://programmingduck.com/articles/programming-principles" rel="noopener ugc nofollow" target="_blank">编程原则</a>告诉我们代码中的命名很重要。本文旨在成为一个完整的代码命名学习指南。它还旨在成为一个关于命名的参考，如果你将来需要的话可以参考。</p><p id="a377" class="pw-post-body-paragraph iw ix hi iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt hb bi translated">对于某些事情，比如命名方法，有不同的命名约定。我们将提到一些，以便您了解它们是如何工作的，以及您可以从中选择的选项。</p><p id="0d8b" class="pw-post-body-paragraph iw ix hi iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt hb bi translated">总的来说，我们将检查:</p><ol class=""><li id="f9e4" class="jv jw hi iy b iz ja jd je jh jx jl jy jp jz jt ka kb kc kd bi translated">想要好名字的动机</li><li id="ee8d" class="jv jw hi iy b iz ke jd kf jh kg jl kh jp ki jt ka kb kc kd bi translated">所有代码的一般命名提示</li><li id="b3b2" class="jv jw hi iy b iz ke jd kf jh kg jl kh jp ki jt ka kb kc kd bi translated">为变量和类等特定事物建立命名约定</li></ol><h1 id="b52a" class="kj kk hi bd kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg bi translated">好名字的动机</h1><p id="6cf5" class="pw-post-body-paragraph iw ix hi iy b iz lh jb jc jd li jf jg jh lj jj jk jl lk jn jo jp ll jr js jt hb bi translated">好名字的动机来自于<a class="ae ju" href="https://programmingduck.com/articles/programming-principles" rel="noopener ugc nofollow" target="_blank">干净的代码和编程原则</a>。代码应该是:</p><ul class=""><li id="316a" class="jv jw hi iy b iz ja jd je jh jx jl jy jp jz jt lm kb kc kd bi translated">显而易见，易于理解</li><li id="0e0e" class="jv jw hi iy b iz ke jd kf jh kg jl kh jp ki jt lm kb kc kd bi translated">容易改变</li></ul><p id="12ca" class="pw-post-body-paragraph iw ix hi iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt hb bi translated">易于理解很有帮助，因为:</p><ul class=""><li id="b63d" class="jv jw hi iy b iz ja jd je jh jx jl jy jp jz jt lm kb kc kd bi translated">容易理解的代码理解起来会更快。这意味着你可以更快地工作。你将花更少的时间去理解旧代码，花更多的时间去写新代码。</li><li id="62bf" class="jv jw hi iy b iz ke jd kf jh kg jl kh jp ki jt lm kb kc kd bi translated">代码将有可能被理解。相比之下，如果一些代码很难理解，即使花很长时间阅读，你也可能看不懂。经验不足的人可能运气更差。此外，你可能会误解代码是如何工作的，尤其是如果你那天没有全神贯注的话。误解代码非常容易产生bug。</li></ul><p id="a2ed" class="pw-post-body-paragraph iw ix hi iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt hb bi translated">好名字对这两种情况都有帮助。</p><h1 id="2955" class="kj kk hi bd kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg bi translated">好名字如何让代码更容易理解</h1><p id="ac6e" class="pw-post-body-paragraph iw ix hi iy b iz lh jb jc jd li jf jg jh lj jj jk jl lk jn jo jp ll jr js jt hb bi translated">如果一件事名副其实，那么你不需要更进一步的细节来理解它。这可以节省您的时间。</p><p id="d881" class="pw-post-body-paragraph iw ix hi iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt hb bi translated">例如，考虑:</p><ul class=""><li id="5703" class="jv jw hi iy b iz ja jd je jh jx jl jy jp jz jt lm kb kc kd bi translated">名为<code class="du ln lo lp lq b">printHelloToTheScreen</code>的函数</li><li id="5cb1" class="jv jw hi iy b iz ke jd kf jh kg jl kh jp ki jt lm kb kc kd bi translated">名为<code class="du ln lo lp lq b">multiplyBy2</code>的函数</li><li id="c4f8" class="jv jw hi iy b iz ke jd kf jh kg jl kh jp ki jt lm kb kc kd bi translated">一个名叫<code class="du ln lo lp lq b">PI</code>的常数</li><li id="adb4" class="jv jw hi iy b iz ke jd kf jh kg jl kh jp ki jt lm kb kc kd bi translated">名为<code class="du ln lo lp lq b">MAXIMUM_ALLOWED_LOGIN_ATTEMPTS</code>的常数</li><li id="a771" class="jv jw hi iy b iz ke jd kf jh kg jl kh jp ki jt lm kb kc kd bi translated">名为<code class="du ln lo lp lq b">Math</code>的静态类或模块</li><li id="61ac" class="jv jw hi iy b iz ke jd kf jh kg jl kh jp ki jt lm kb kc kd bi translated">一个名为<code class="du ln lo lp lq b">circumference</code>的变量</li><li id="c189" class="jv jw hi iy b iz ke jd kf jh kg jl kh jp ki jt lm kb kc kd bi translated">一个名为<code class="du ln lo lp lq b">userInfo</code>的变量</li></ul><p id="d544" class="pw-post-body-paragraph iw ix hi iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt hb bi translated">在代码库中，你可以从名字中很好地了解它们的功能。</p><h1 id="870c" class="kj kk hi bd kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg bi translated">好名字如何让代码更容易理解</h1><p id="d889" class="pw-post-body-paragraph iw ix hi iy b iz lh jb jc jd li jf jg jh lj jj jk jl lk jn jo jp ll jr js jt hb bi translated">阅读代码时，您必须:</p><ol class=""><li id="a0dd" class="jv jw hi iy b iz ja jd je jh jx jl jy jp jz jt ka kb kc kd bi translated">读取(解析)它做了什么</li><li id="7590" class="jv jw hi iy b iz ke jd kf jh kg jl kh jp ki jt ka kb kc kd bi translated">理解它为什么这样做，或者更确切地说，从概念上理解它试图做什么</li></ol><p id="44d0" class="pw-post-body-paragraph iw ix hi iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt hb bi translated">例如，认为“这段代码删除了字符串中的初始空格，然后它发送了一个网络请求”是不够的。相反，你必须理解“这个代码格式化用户名，然后发送一个密码重置请求”。</p><p id="dd3e" class="pw-post-body-paragraph iw ix hi iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt hb bi translated">下面是一个难以理解的代码示例:</p><pre class="iq ir is it fd lr lq ls lt aw lu bi"><span id="aa5d" class="lv kk hi lq b fi lw lx l ly lz">function foo(a, b) {<br/>  const c = PI * a ** 2 * 8 / b;<br/>  return c &gt; 1 ? c : 1;<br/>}</span></pre><p id="594d" class="pw-post-body-paragraph iw ix hi iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt hb bi translated">那里的<code class="du ln lo lp lq b">8</code>是干什么用的？什么是<code class="du ln lo lp lq b">b</code>？为什么它返回最小的<code class="du ln lo lp lq b">1</code>？这个函数的目的是什么？</p><p id="acba" class="pw-post-body-paragraph iw ix hi iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt hb bi translated">如果你想做一些事情，比如改变面积，你不知道这个函数是否相关。即使你怀疑它是，你也不知道它是做什么的，也不知道为什么。</p><p id="7a44" class="pw-post-body-paragraph iw ix hi iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt hb bi translated">类似这样的事情会好得多:</p><pre class="iq ir is it fd lr lq ls lt aw lu bi"><span id="00cd" class="lv kk hi lq b fi lw lx l ly lz">function calculateRemainingArea(radius, reductionFactor) {<br/>  const area = PI * radius ** 2;<br/>  const remainingArea = area * AREA_REDUCTION_RESISTANCE / reductionFactor;<br/>  return Math.min(remainingArea, MINIMUM_AREA);<br/>}</span></pre><p id="0b7a" class="pw-post-body-paragraph iw ix hi iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt hb bi translated">所以，好名字是有帮助的，因为<strong class="iy hj">它们提供了意义</strong>。它们帮助您理解代码做什么以及为什么要这样做。</p><p id="0104" class="pw-post-body-paragraph iw ix hi iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt hb bi translated">为了得到好处，你所要做的就是给这个东西起一个好名字。</p><p id="a224" class="pw-post-body-paragraph iw ix hi iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt hb bi translated">再比如，可能有人不理解<code class="du ln lo lp lq b">PI * a ** 2</code>。他们可能认为“<code class="du ln lo lp lq b">PI</code>、<code class="du ln lo lp lq b">a</code>、2的力量...那是什么鬼东西？?"。为了使它更简单，您所要做的就是用<code class="du ln lo lp lq b">const circleArea = PI * radius ** 2</code>替换那一行。很有帮助。</p><figure class="iq ir is it fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ma"><img src="../Images/80fe81d8fe19d7d9bfbad4bfc0c2bc75.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*i6WIzBjJHHlzJaeY.jpg"/></div></div></figure><h1 id="7aea" class="kj kk hi bd kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg bi translated">代码的一般命名提示</h1><p id="b54b" class="pw-post-body-paragraph iw ix hi iy b iz lh jb jc jd li jf jg jh lj jj jk jl lk jn jo jp ll jr js jt hb bi translated">简而言之，一个好名字是能立刻告诉你某事是什么或做什么的东西。这并不奇怪。理解它并不需要努力。你不用想就明白了。</p><p id="e54b" class="pw-post-body-paragraph iw ix hi iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt hb bi translated">坏名字是你读到的东西，你想知道“那是什么”，或者“那有什么用？”。需要你多思考的事情。</p><p id="c7b3" class="pw-post-body-paragraph iw ix hi iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt hb bi translated">当写名字时，他们应该能被以前从未见过这些代码的人理解。它们需要有意义，前后一致，并有足够的描述性。</p><p id="8b73" class="pw-post-body-paragraph iw ix hi iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt hb bi translated">这里有一些实现这一点的方法。</p><h1 id="da98" class="kj kk hi bd kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg bi translated">有明确的命名约定</h1><p id="90ad" class="pw-post-body-paragraph iw ix hi iy b iz lh jb jc jd li jf jg jh lj jj jk jl lk jn jo jp ll jr js jt hb bi translated">你的代码库应该有清晰的约定。这大概是本文最重要的一点。如果你已经在遵循一个惯例，那么最好坚持下去，即使有一个替代方案可能更具描述性。</p><p id="bbba" class="pw-post-body-paragraph iw ix hi iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt hb bi translated">惯例适用于一致性。<a class="ae ju" href="https://programmingduck.com/articles/programming-principles" rel="noopener ugc nofollow" target="_blank">编程原则</a>告诉我们，一致性非常重要。</p><p id="1ba5" class="pw-post-body-paragraph iw ix hi iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt hb bi translated">它能让你工作得更快。您可以对代码如何工作以及某些事情的含义做出某些假设。此外，在考虑某个事物的名称时，公约可能已经有了相应的规则。这使得事情变得更容易。</p><p id="2b8e" class="pw-post-body-paragraph iw ix hi iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt hb bi translated">此外，不遵循惯例会导致错误。您可能会认为代码库中遵循了一个通用的约定。如果你错了，那么你可能对一些代码的工作原理有错误的理解。在这种情况下，很容易产生bug。</p><p id="0b51" class="pw-post-body-paragraph iw ix hi iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt hb bi translated">理想情况下，您应该遵循您的编程语言或框架中已经存在的约定。这对公司的新开发人员来说更容易。一些例子是<a class="ae ju" href="https://docs.microsoft.com/en-us/dotnet/standard/design-guidelines/naming-guidelines" rel="noopener ugc nofollow" target="_blank">。NET命名指南</a>和<a class="ae ju" href="https://github.com/airbnb/javascript" rel="noopener ugc nofollow" target="_blank"> Airbnb JavaScript风格指南</a>。否则，您也可以为您的项目或公司创建自己的自定义约定。</p><h1 id="9b58" class="kj kk hi bd kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg bi translated">偏好描述性名称</h1><p id="7689" class="pw-post-body-paragraph iw ix hi iy b iz lh jb jc jd li jf jg jh lj jj jk jl lk jn jo jp ll jr js jt hb bi translated">总是在考虑，下一个看这个名字的人会不会很容易理解？</p><h2 id="2126" class="lv kk hi bd kl mb mc md kp me mf mg kt jh mh mi kx jl mj mk lb jp ml mm lf mn bi translated">使用完整的单词</h2><p id="4abe" class="pw-post-body-paragraph iw ix hi iy b iz lh jb jc jd li jf jg jh lj jj jk jl lk jn jo jp ll jr js jt hb bi translated">一般全字比较好理解。例如<code class="du ln lo lp lq b">calculateArea</code>或<code class="du ln lo lp lq b">createWindow</code>。缩写词可能更难理解。一般来说，避免使用像<code class="du ln lo lp lq b">calcArea</code>或<code class="du ln lo lp lq b">cWin</code>这样的名字。</p><h2 id="11f0" class="lv kk hi bd kl mb mc md kp me mf mg kt jh mh mi kx jl mj mk lb jp ml mm lf mn bi translated">避免非常短的变量名</h2><p id="19e9" class="pw-post-body-paragraph iw ix hi iy b iz lh jb jc jd li jf jg jh lj jj jk jl lk jn jo jp ll jr js jt hb bi translated">特别是，避免单个字母或非常短的变量，如<code class="du ln lo lp lq b">d</code>。它可能意味着任何事情:T5、T6、T7或T8。</p><p id="a0ad" class="pw-post-body-paragraph iw ix hi iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt hb bi translated">例外情况是，当名称在非常小的范围内使用，并且它所代表的内容很明显时。在这种情况下，很容易向上看一两行，看看它是在哪里定义的。下面是一个使用变量<code class="du ln lo lp lq b">e</code>的代码示例。</p><pre class="iq ir is it fd lr lq ls lt aw lu bi"><span id="6206" class="lv kk hi lq b fi lw lx l ly lz">function sendData() { /* sends a network request */ }<br/>function handleFormSubmission(e) {<br/>  const formElement = e.target;<br/>  const formData = FormData(formElement);<br/>  sendData(formData);<br/>}</span></pre><p id="2485" class="pw-post-body-paragraph iw ix hi iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt hb bi translated">这里，变量<code class="du ln lo lp lq b">e</code>代表事件对象。我们知道这一点，因为名称<code class="du ln lo lp lq b">handleFormSubmission</code>和函数签名代表一个事件处理程序。<code class="du ln lo lp lq b">e</code>只在它被定义的地方下一行使用，所以仍然很容易使用。</p><p id="6d0c" class="pw-post-body-paragraph iw ix hi iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt hb bi translated">不过，我个人还是会用<code class="du ln lo lp lq b">event</code>。我认为可读性比像这样节省一点点按键更重要。</p><p id="2949" class="pw-post-body-paragraph iw ix hi iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt hb bi translated">另一个可接受的例子是在for循环等中使用<code class="du ln lo lp lq b">i</code>。那是每个人都明白的惯例。</p><h2 id="4575" class="lv kk hi bd kl mb mc md kp me mf mg kt jh mh mi kx jl mj mk lb jp ml mm lf mn bi translated">首字母缩略词</h2><p id="7f5f" class="pw-post-body-paragraph iw ix hi iy b iz lh jb jc jd li jf jg jh lj jj jk jl lk jn jo jp ll jr js jt hb bi translated">如果一个缩略词很常见，那么就可以使用它。一些例子是缩写HTML，UI，IO，OS，JSON，XML，HTTP。</p><p id="2320" class="pw-post-body-paragraph iw ix hi iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt hb bi translated">如果首字母缩写不常见，那么最好使用全称。如果有疑问，你应该使用完整版。</p><h1 id="67cc" class="kj kk hi bd kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg bi translated">简洁很重要</h1><p id="a8e0" class="pw-post-body-paragraph iw ix hi iy b iz lh jb jc jd li jf jg jh lj jj jk jl lk jn jo jp ll jr js jt hb bi translated">首先是具有充分描述性的名称。然而，这并不意味着你需要超长的名字。</p><p id="37a8" class="pw-post-body-paragraph iw ix hi iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt hb bi translated">超长的名字，比如一个名为<code class="du ln lo lp lq b">integerNumberOfEnginesInObject</code>的变量很难处理。<code class="du ln lo lp lq b">engineCount</code>就够了。</p><p id="923b" class="pw-post-body-paragraph iw ix hi iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt hb bi translated">一般来说，如果你可以用一个更短的名字来表达同样的意思，那就用更短的名字。</p><h1 id="4d46" class="kj kk hi bd kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg bi translated">考虑一下背景</h1><p id="557b" class="pw-post-body-paragraph iw ix hi iy b iz lh jb jc jd li jf jg jh lj jj jk jl lk jn jo jp ll jr js jt hb bi translated">周围上下文的名称可以为某事的目的提供有用的线索。这意味着，有时，您可以使用较短的名称。</p><p id="23b3" class="pw-post-body-paragraph iw ix hi iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt hb bi translated">例如，如果您有一个名为<code class="du ln lo lp lq b">Users</code>的类，那么创建新用户的方法可以称为<code class="du ln lo lp lq b">create</code>。它的用法类似于<code class="du ln lo lp lq b">users.create()</code>(其中<code class="du ln lo lp lq b">users</code>是<code class="du ln lo lp lq b">Users</code>的一个实例)。这已经足够说明问题了。这种情况下不需要调用方法<code class="du ln lo lp lq b">createUser</code>。</p><h1 id="3575" class="kj kk hi bd kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg bi translated">套</h1><p id="4b90" class="pw-post-body-paragraph iw ix hi iy b iz lh jb jc jd li jf jg jh lj jj jk jl lk jn jo jp ll jr js jt hb bi translated">编程中流行的大小写(不包括HTML和CSS)有pascal大小写、camel大小写和snake大小写。您使用哪一种取决于您的编程语言或框架的约定。</p><h2 id="a3e1" class="lv kk hi bd kl mb mc md kp me mf mg kt jh mh mi kx jl mj mk lb jp ml mm lf mn bi translated">每个外壳的一般格式</h2><p id="210a" class="pw-post-body-paragraph iw ix hi iy b iz lh jb jc jd li jf jg jh lj jj jk jl lk jn jo jp ll jr js jt hb bi translated">蛇形大写是小写的，使用下划线来分隔单词。比如<code class="du ln lo lp lq b">this_is_snake_case</code>。</p><p id="8c92" class="pw-post-body-paragraph iw ix hi iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt hb bi translated">在pascal大小写中，每个单词都以大写字母开头。比如<code class="du ln lo lp lq b">ThisIsPascalCase</code>。</p><p id="cc07" class="pw-post-body-paragraph iw ix hi iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt hb bi translated">Camel大小写类似于pascal大小写，只是第一个单词以小写字母开头。比如<code class="du ln lo lp lq b">thisIsCamelCase</code>。</p><h2 id="9cf9" class="lv kk hi bd kl mb mc md kp me mf mg kt jh mh mi kx jl mj mk lb jp ml mm lf mn bi translated">首字母缩写词的大小写</h2><p id="a0b9" class="pw-post-body-paragraph iw ix hi iy b iz lh jb jc jd li jf jg jh lj jj jk jl lk jn jo jp ll jr js jt hb bi translated">对于首字母缩写词，约定各不相同。</p><p id="d4a7" class="pw-post-body-paragraph iw ix hi iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt hb bi translated">在前端，缩略词似乎总是完全大写，不管长度如何。一些例子是<code class="du ln lo lp lq b">performance.toJSON()</code>、<code class="du ln lo lp lq b">XMLDocument</code>、<code class="du ln lo lp lq b">HTMLCollection</code>和<code class="du ln lo lp lq b">DOMString</code>。</p><p id="d1ce" class="pw-post-body-paragraph iw ix hi iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt hb bi translated">但是，在其他一些语言中，如。NET语言，约定是:</p><ul class=""><li id="b791" class="jv jw hi iy b iz ja jd je jh jx jl jy jp jz jt lm kb kc kd bi translated">如果首字母缩略词只有两个字母，第二个字母的大小写应该与第一个字母相同(大写或小写)。比如<code class="du ln lo lp lq b">UIInput</code>(帕斯卡案)<code class="du ln lo lp lq b">uiInput</code>(骆驼案)<code class="du ln lo lp lq b">fooUIInput</code>。</li><li id="38bd" class="jv jw hi iy b iz ke jd kf jh kg jl kh jp ki jt lm kb kc kd bi translated">如果首字母缩略词是三个字母或更长，必要时只需大写第一个字母。比如<code class="du ln lo lp lq b">JsonFoo</code>(帕斯卡案)<code class="du ln lo lp lq b">jsonFoo</code>(骆驼案)。</li></ul><h2 id="1572" class="lv kk hi bd kl mb mc md kp me mf mg kt jh mh mi kx jl mj mk lb jp ml mm lf mn bi translated">复合词的大写</h2><p id="e45e" class="pw-post-body-paragraph iw ix hi iy b iz lh jb jc jd li jf jg jh lj jj jk jl lk jn jo jp ll jr js jt hb bi translated">从大写的角度来看，将复合词视为一个词是一种惯例。比如用<code class="du ln lo lp lq b">callback</code>和<code class="du ln lo lp lq b">endpoint</code>代替<code class="du ln lo lp lq b">callBack</code>和<code class="du ln lo lp lq b">endPoint</code>。您可以在<a class="ae ju" href="https://docs.microsoft.com/en-us/dotnet/standard/design-guidelines/capitalization-conventions" rel="noopener ugc nofollow" target="_blank">上找到编程中使用的常见复合词的完整列表。资本化的网络命名指南</a>。</p><h1 id="cfc2" class="kj kk hi bd kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg bi translated">偏好语义命名</h1><p id="63a5" class="pw-post-body-paragraph iw ix hi iy b iz lh jb jc jd li jf jg jh lj jj jk jl lk jn jo jp ll jr js jt hb bi translated">语义命名是指以事物的目的或意义来命名事物。按照优先顺序，这意味着:</p><ol class=""><li id="28b5" class="jv jw hi iy b iz ja jd je jh jx jl jy jp jz jt ka kb kc kd bi translated">它的目的是什么，或者它有什么作用</li><li id="f58d" class="jv jw hi iy b iz ke jd kf jh kg jl kh jp ki jt ka kb kc kd bi translated">它是如何做到的</li></ol><p id="903b" class="pw-post-body-paragraph iw ix hi iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt hb bi translated">作为一个额外的好处，它也导致代码在未来不太可能改变。</p><p id="4253" class="pw-post-body-paragraph iw ix hi iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt hb bi translated">给事物命名时，考虑:你要命名的事物最重要的是什么？最适合别人从概念上理解的名字是什么？</p><p id="8be7" class="pw-post-body-paragraph iw ix hi iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt hb bi translated">通常，用户更关心某个东西在做什么，而不是它是如何做的。虽然，有时候,“如何”才是最重要的。</p><p id="dfba" class="pw-post-body-paragraph iw ix hi iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt hb bi translated">这里有一些语义命名的例子。</p><h2 id="b0e7" class="lv kk hi bd kl mb mc md kp me mf mg kt jh mh mi kx jl mj mk lb jp ml mm lf mn bi translated">带有变量名的示例</h2><p id="43c9" class="pw-post-body-paragraph iw ix hi iy b iz lh jb jc jd li jf jg jh lj jj jk jl lk jn jo jp ll jr js jt hb bi translated">如果您有一个保存用户集合的变量，重要的是它包含用户。是列表还是地图就不那么重要了。更不用说您的IDE和类型声明提供了这些信息。</p><p id="db50" class="pw-post-body-paragraph iw ix hi iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt hb bi translated">因此，名曰:</p><ul class=""><li id="de3f" class="jv jw hi iy b iz ja jd je jh jx jl jy jp jz jt lm kb kc kd bi translated"><code class="du ln lo lp lq b">users</code>会比较合适</li><li id="2a7d" class="jv jw hi iy b iz ke jd kf jh kg jl kh jp ki jt lm kb kc kd bi translated"><code class="du ln lo lp lq b">userList</code>不太可取。“列表”部分没有<code class="du ln lo lp lq b">users</code>部分重要。此外，如果您在将来更改数据结构，您将不得不更新变量名。</li><li id="0fb0" class="jv jw hi iy b iz ke jd kf jh kg jl kh jp ki jt lm kb kc kd bi translated"><code class="du ln lo lp lq b">userCollection</code>也不太可取，因为“收藏”部分不如“用户”部分重要。但是，如果您将来更改数据结构，至少您不必更新变量名。</li></ul><h2 id="20be" class="lv kk hi bd kl mb mc md kp me mf mg kt jh mh mi kx jl mj mk lb jp ml mm lf mn bi translated">接口和实现示例</h2><p id="0598" class="pw-post-body-paragraph iw ix hi iy b iz lh jb jc jd li jf jg jh lj jj jk jl lk jn jo jp ll jr js jt hb bi translated">在OOP代码中，你倾向于拥有可能有多个实现的接口。对于一个排序算法，一个接口可能被称为语义和通用的东西，比如<code class="du ln lo lp lq b">Sorter</code>。这就是它的重要之处，它可以排序。如何在接口层面上并不重要。</p><p id="5dbe" class="pw-post-body-paragraph iw ix hi iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt hb bi translated">不同的实现可以根据它们实现的排序算法来调用。这是他们的重要之处，也是他们之间唯一的区别。这是特定类别的用户想要的信息。比如<code class="du ln lo lp lq b">BubbleSort</code>、<code class="du ln lo lp lq b">MergeSort</code>、<code class="du ln lo lp lq b">Quicksort</code>。</p><h2 id="8afb" class="lv kk hi bd kl mb mc md kp me mf mg kt jh mh mi kx jl mj mk lb jp ml mm lf mn bi translated">排序方法示例</h2><p id="0e4c" class="pw-post-body-paragraph iw ix hi iy b iz lh jb jc jd li jf jg jh lj jj jk jl lk jn jo jp ll jr js jt hb bi translated">假设您有一个包含某个集合的类。你也有一个排序的方法，比如说，按字母顺序。</p><p id="71af" class="pw-post-body-paragraph iw ix hi iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt hb bi translated">如果你只有一种排序方法，那么最好将其命名为<code class="du ln lo lp lq b">sort</code>。像<code class="du ln lo lp lq b">sortWithQuicksort</code>或<code class="du ln lo lp lq b">quicksort</code>这样的名字是用户不关心的不必要的信息。你想想，代码的调用者想要排序。他们对你的类使用的特定算法并不特别感兴趣。(唯一的例外是，如果您的类确实是性能瓶颈之类的，但那是另一个话题。)</p><p id="e4f7" class="pw-post-body-paragraph iw ix hi iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt hb bi translated">此外，将来您可以更改该类用于合并排序的排序算法。那样的话，<code class="du ln lo lp lq b">sortWithQuicksort</code>这个名字就没有意义了。</p><p id="d2eb" class="pw-post-body-paragraph iw ix hi iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt hb bi translated">解决方案是将你的公共方法命名为<code class="du ln lo lp lq b">sort</code>。</p><p id="9a6f" class="pw-post-body-paragraph iw ix hi iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt hb bi translated">你使用快速排序的事实仍然很重要。致力于实现该类的开发人员会想知道这一点。一些选项是拥有一个名为<code class="du ln lo lp lq b">quicksort</code>的私有方法，或者从代码库中的其他地方导入并使用一个<code class="du ln lo lp lq b">quicksort</code>函数。</p><p id="8bbf" class="pw-post-body-paragraph iw ix hi iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt hb bi translated">例如:</p><pre class="iq ir is it fd lr lq ls lt aw lu bi"><span id="1d30" class="lv kk hi lq b fi lw lx l ly lz">// pseudocode<br/><br/>class Users<br/>{<br/>  // the public method with a name that's useful to callers<br/>  public User[] Sort()<br/>  {<br/>    return _quicksort(this.users);<br/>  }<br/><br/>  // the private method with a name that's userful to someone working on this class<br/>  private T[] _quicksort&lt;T&gt;(T[] items)<br/>  {<br/>    /* implementation of quicksort */<br/>  }<br/>}</span></pre><h2 id="1f47" class="lv kk hi bd kl mb mc md kp me mf mg kt jh mh mi kx jl mj mk lb jp ml mm lf mn bi translated">前端CSS示例</h2><p id="69e1" class="pw-post-body-paragraph iw ix hi iy b iz lh jb jc jd li jf jg jh lj jj jk jl lk jn jo jp ll jr js jt hb bi translated">在前端CSS中，有几种方法。您选择的方法决定了类名的重要性。</p><p id="4bc1" class="pw-post-body-paragraph iw ix hi iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt hb bi translated">使用BEM命名约定时，重要的是元素的用途，而不是样式。例如，你可以使用CSS类<code class="du ln lo lp lq b">page-heading</code>而不是<code class="du ln lo lp lq b">large-heading-red</code>。这是因为，明天，页面标题的样式可能会改变。此时，非语义名称不再有意义，但是语义名称有意义。</p><p id="e852" class="pw-post-body-paragraph iw ix hi iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt hb bi translated">如果您使用的是UI组件库，那么组件的样式比组件的用途更重要。例如用<code class="du ln lo lp lq b">button-primary</code>代替<code class="du ln lo lp lq b">add-to-cart-button</code>。这是因为像<code class="du ln lo lp lq b">button-primary</code>这样的类是你将在整个代码中使用的主要类。</p><h1 id="a35c" class="kj kk hi bd kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg bi translated">鲍勃叔叔的其他建议</h1><p id="cec1" class="pw-post-body-paragraph iw ix hi iy b iz lh jb jc jd li jf jg jh lj jj jk jl lk jn jo jp ll jr js jt hb bi translated">鲍勃叔叔的书《干净的代码》中提到的一些技巧是:</p><ul class=""><li id="66dc" class="jv jw hi iy b iz ja jd je jh jx jl jy jp jz jt lm kb kc kd bi translated">进行有意义的区分。避免看起来相似或相同的变量，如<code class="du ln lo lp lq b">accountInfo</code>或<code class="du ln lo lp lq b">accountData</code>。使用该代码的用户将无法分辨其中的区别。</li><li id="a796" class="jv jw hi iy b iz ke jd kf jh kg jl kh jp ki jt lm kb kc kd bi translated">使用容易发音的名字。名字应该易于大声读出。一些要避免的例子是像<code class="du ln lo lp lq b">genymdhms</code>和<code class="du ln lo lp lq b">modymdhms</code>这样的名字。更好的名字应该是<code class="du ln lo lp lq b">generationTimestamp</code>和<code class="du ln lo lp lq b">modificationTimestamp</code>。</li><li id="dee1" class="jv jw hi iy b iz ke jd kf jh kg jl kh jp ki jt lm kb kc kd bi translated">使用可搜索的名称。名称应该易于使用代码编辑器进行搜索。本质上，避免一两个字母长的名字，因为搜索它们会返回太多匹配。</li><li id="b1e9" class="jv jw hi iy b iz ke jd kf jh kg jl kh jp ki jt lm kb kc kd bi translated">避免使用可爱/攻击性的词语。避免使用<code class="du ln lo lp lq b">whack()</code>和<code class="du ln lo lp lq b">seeYouLaterFiles()</code>这样的名字。要专业，要一致。</li><li id="45a0" class="jv jw hi iy b iz ke jd kf jh kg jl kh jp ki jt lm kb kc kd bi translated">为每个概念选择一个单词。例如，不要在你的代码库中混合使用“获取”、“获取”和“检索”这三个词来表示同一种操作。选择其中一个，坚持使用。</li><li id="d97c" class="jv jw hi iy b iz ke jd kf jh kg jl kh jp ki jt lm kb kc kd bi translated">避免双关语。避免用同一个词表达不同的概念。例如，如果在一个类中<code class="du ln lo lp lq b">add()</code>添加两个数字，在另一个类中<code class="du ln lo lp lq b">add()</code>不应该插入到一个列表中。</li></ul><h1 id="5b01" class="kj kk hi bd kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg bi translated">的其他提示。网络命名约定</h1><p id="8937" class="pw-post-body-paragraph iw ix hi iy b iz lh jb jc jd li jf jg jh lj jj jk jl lk jn jo jp ll jr js jt hb bi translated">。NET提出了一些额外的建议。有些是专门针对。网络语言。然而，无论如何你都要记住它们。</p><p id="637e" class="pw-post-body-paragraph iw ix hi iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt hb bi translated">建议如下:</p><ul class=""><li id="2811" class="jv jw hi iy b iz ja jd je jh jx jl jy jp jz jt lm kb kc kd bi translated">更喜欢自然易读的名字。比如用<code class="du ln lo lp lq b">HorizontalAlignment</code>代替<code class="du ln lo lp lq b">AlignmentHorizontal</code>。</li><li id="9a3f" class="jv jw hi iy b iz ke jd kf jh kg jl kh jp ki jt lm kb kc kd bi translated">避免使用与其他编程语言中常见关键字冲突的名称</li><li id="fbb1" class="jv jw hi iy b iz ke jd kf jh kg jl kh jp ki jt lm kb kc kd bi translated">更喜欢语义名称，而不是特定语言的名称。比如用<code class="du ln lo lp lq b">GetLength</code>代替<code class="du ln lo lp lq b">GetInt</code>。</li><li id="a081" class="jv jw hi iy b iz ke jd kf jh kg jl kh jp ki jt lm kb kc kd bi translated">首选通用CLR类型名称，而不是特定于语言的名称。例如命名一个方法<code class="du ln lo lp lq b">ToInt64</code>而不是<code class="du ln lo lp lq b">ToLong</code>。这是因为像这样的方法可能在其他CLR兼容语言中使用，而数据类型<code class="du ln lo lp lq b">long</code>并不存在。因此，该名称在那些语言中没有意义。然而，<code class="du ln lo lp lq b">Int64</code>是存在的，对所有CLR语言都有意义。</li></ul><figure class="iq ir is it fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ma"><img src="../Images/a8e4b84a236d24d5d588cbc220ce0893.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*pVVuzZtxecOEQRNV.jpg"/></div></div></figure><h1 id="1ccc" class="kj kk hi bd kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg bi translated">特定用例的命名约定</h1><p id="6e0c" class="pw-post-body-paragraph iw ix hi iy b iz lh jb jc jd li jf jg jh lj jj jk jl lk jn jo jp ll jr js jt hb bi translated">以下是一些常见的命名惯例，如变量、函数、类等。</p><h1 id="acab" class="kj kk hi bd kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg bi translated">变量</h1><p id="ffa0" class="pw-post-body-paragraph iw ix hi iy b iz lh jb jc jd li jf jg jh lj jj jk jl lk jn jo jp ll jr js jt hb bi translated">变量只是值和对象的名称或标签。它们的一些通用惯例是:</p><p id="e966" class="pw-post-body-paragraph iw ix hi iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt hb bi translated">对于保存布尔值的常量和变量，规则稍有改变。</p><h2 id="b6e9" class="lv kk hi bd kl mb mc md kp me mf mg kt jh mh mi kx jl mj mk lb jp ml mm lf mn bi translated">常数</h2><p id="48b0" class="pw-post-body-paragraph iw ix hi iy b iz lh jb jc jd li jf jg jh lj jj jk jl lk jn jo jp ll jr js jt hb bi translated">一些编程语言写常量完全大写，并带有蛇的大小写。这包括JavaScript、Python和Java。一些示例常数是:</p><p id="8be2" class="pw-post-body-paragraph iw ix hi iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt hb bi translated">在这里，“常数”指的是特殊值。这些值不依赖于运行时。它们可以很容易地放在配置文件中，远离您的应用程序代码。</p><p id="7d88" class="pw-post-body-paragraph iw ix hi iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt hb bi translated">“常量”不是指一个普通的局部变量，只是碰巧是不可变的。这些变量遵循与正态变量相同的规则。</p><p id="f17e" class="pw-post-body-paragraph iw ix hi iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt hb bi translated">以下是一些“常量”和“恰好是不可变的正常变量”的例子:</p><ul class=""><li id="1a23" class="jv jw hi iy b iz ja jd je jh jx jl jy jp jz jt lm kb kc kd bi translated"><code class="du ln lo lp lq b">final MAX_ATTEMPS_BEFORE_LOCKOUT = 5</code>(这可能在配置文件中，它是一个特殊的常量)</li><li id="3ea1" class="jv jw hi iy b iz ke jd kf jh kg jl kh jp ki jt lm kb kc kd bi translated"><code class="du ln lo lp lq b">final float result = SomeClass.factorial(someNumber)</code>(这只是一个碰巧不可变的局部变量。它根据<code class="du ln lo lp lq b">someNumber</code>在运行时变化。它不能放在配置文件中)</li><li id="fd81" class="jv jw hi iy b iz ke jd kf jh kg jl kh jp ki jt lm kb kc kd bi translated"><code class="du ln lo lp lq b">const URL_ENDPOINT = '/ajax/foo'</code>(这可能在配置文件中，它是一个特殊的常量)</li><li id="b29a" class="jv jw hi iy b iz ke jd kf jh kg jl kh jp ki jt lm kb kc kd bi translated"><code class="du ln lo lp lq b">const filteredArray = array.filter(a =&gt; !a)</code>(这只是一个不可变的局部变量。它在运行时根据<code class="du ln lo lp lq b">array</code>而变化。它不能放在配置文件中)</li></ul><h2 id="fd7e" class="lv kk hi bd kl mb mc md kp me mf mg kt jh mh mi kx jl mj mk lb jp ml mm lf mn bi translated">布尔运算</h2><p id="044f" class="pw-post-body-paragraph iw ix hi iy b iz lh jb jc jd li jf jg jh lj jj jk jl lk jn jo jp ll jr js jt hb bi translated">对于具有布尔值的变量，约定是将它们表述为一个问题。以谓语开始，如“是”、“已经”、“曾经”和“可以”。这清楚地表明该变量包含一个布尔值。</p><p id="70e9" class="pw-post-body-paragraph iw ix hi iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt hb bi translated">布尔变量的一些例子是:</p><p id="916a" class="pw-post-body-paragraph iw ix hi iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt hb bi translated">除了可以独立阅读之外，它们在条件语句中也很容易阅读:</p><pre class="iq ir is it fd lr lq ls lt aw lu bi"><span id="0ebb" class="lv kk hi lq b fi lw lx l ly lz">if (hasLoaded) {<br/>  doSomething();<br/>} else {<br/>  doSomethingElse();<br/>}</span></pre><p id="c033" class="pw-post-body-paragraph iw ix hi iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt hb bi translated">相比之下，如果你不使用谓词，你可以使用一个名字，比如<code class="du ln lo lp lq b">complete</code>。这既是动词又是形容词。它可以表示许多事情。它可以是一个运行来完成某件事情的函数，或者是一个保存已经完成的事情的变量，或者是一个表示某件事情是否已经完成的布尔值，或者是一个事件名称。它所代表的含义更加模糊，所以更倾向于使用谓词。</p><p id="0559" class="pw-post-body-paragraph iw ix hi iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt hb bi translated">像<code class="du ln lo lp lq b">completing</code>这样的动词稍微好一点。它不能表示功能，因为“完成”中的“ing”意味着某事已经发生。它不是你现在就可以开始运行的东西(比如函数调用)。然而，它仍然可以是任何其他选项。总的来说，使用谓词仍然更好。</p><h1 id="b131" class="kj kk hi bd kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg bi translated">功能</h1><p id="b37e" class="pw-post-body-paragraph iw ix hi iy b iz lh jb jc jd li jf jg jh lj jj jk jl lk jn jo jp ll jr js jt hb bi translated">函数是做某些事情的代码单元。函数名的约定是:</p><ul class=""><li id="b9bf" class="jv jw hi iy b iz ja jd je jh jx jl jy jp jz jt lm kb kc kd bi translated">它们应该是动词</li><li id="ae15" class="jv jw hi iy b iz ke jd kf jh kg jl kh jp ki jt lm kb kc kd bi translated">他们通常使用骆驼大小写或蛇大小写，这取决于你的编程语言</li></ul><p id="d559" class="pw-post-body-paragraph iw ix hi iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt hb bi translated">一些示例函数名称如下:</p><p id="5c48" class="pw-post-body-paragraph iw ix hi iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt hb bi translated">对于返回布尔值的函数，常见的约定是从谓词开始。这类似于包含布尔值的变量。</p><p id="db88" class="pw-post-body-paragraph iw ix hi iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt hb bi translated">返回布尔值的函数的一些示例名称如下:</p><p id="3111" class="pw-post-body-paragraph iw ix hi iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt hb bi translated">我见过的另一个约定是“变压器”或“转换器”功能。这些是从一件事物转换到另一件事物的功能。它们通常以“to”开头，后面是它们要转换成的类型。</p><p id="dc60" class="pw-post-body-paragraph iw ix hi iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt hb bi translated">转换器函数名称的一些示例如下:</p><h1 id="9f65" class="kj kk hi bd kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg bi translated">班级</h1><p id="d4ec" class="pw-post-body-paragraph iw ix hi iy b iz lh jb jc jd li jf jg jh lj jj jk jl lk jn jo jp ll jr js jt hb bi translated">类是包含方法和属性的代码单元。</p><p id="dd90" class="pw-post-body-paragraph iw ix hi iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt hb bi translated">类的一些约定是:</p><ul class=""><li id="7eb0" class="jv jw hi iy b iz ja jd je jh jx jl jy jp jz jt lm kb kc kd bi translated">他们使用帕斯卡格</li><li id="bb88" class="jv jw hi iy b iz ke jd kf jh kg jl kh jp ki jt lm kb kc kd bi translated">它们应该是名词(或名词短语)</li></ul><p id="01d4" class="pw-post-body-paragraph iw ix hi iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt hb bi translated">一些示例类名如下:</p><h2 id="a3c6" class="lv kk hi bd kl mb mc md kp me mf mg kt jh mh mi kx jl mj mk lb jp ml mm lf mn bi translated">常规属性名称</h2><p id="9c01" class="pw-post-body-paragraph iw ix hi iy b iz lh jb jc jd li jf jg jh lj jj jk jl lk jn jo jp ll jr js jt hb bi translated">一般来说，属性的命名类似于变量。方法的命名类似于函数。</p><p id="5089" class="pw-post-body-paragraph iw ix hi iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt hb bi translated">然而，如前所述，类名提供了一些上下文。</p><p id="cc47" class="pw-post-body-paragraph iw ix hi iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt hb bi translated">这意味着你可以为一个方法/属性使用一个比等价的函数/变量更简单的名字。</p><p id="97d1" class="pw-post-body-paragraph iw ix hi iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt hb bi translated">例如，在一个类<code class="du ln lo lp lq b">Users</code>中，你可能有一个名为<code class="du ln lo lp lq b">create</code>的方法。它的用法类似于<code class="du ln lo lp lq b">users.create()</code>(其中<code class="du ln lo lp lq b">users</code>是<code class="du ln lo lp lq b">Users</code>的一个实例)，这就足够说明问题了。</p><h2 id="1dfc" class="lv kk hi bd kl mb mc md kp me mf mg kt jh mh mi kx jl mj mk lb jp ml mm lf mn bi translated">属性的套管和前缀</h2><p id="2bbb" class="pw-post-body-paragraph iw ix hi iy b iz lh jb jc jd li jf jg jh lj jj jk jl lk jn jo jp ll jr js jt hb bi translated">在大小写和前缀方面，不同的语言和框架有不同的约定。</p><p id="fac5" class="pw-post-body-paragraph iw ix hi iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt hb bi translated">例如，<a class="ae ju" href="https://www.oracle.com/java/technologies/javase/codeconventions-namingconventions.html" rel="noopener ugc nofollow" target="_blank"> Java命名约定</a>提到方法和属性应该是骆驼大小写的。</p><p id="6fc0" class="pw-post-body-paragraph iw ix hi iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt hb bi translated"><a class="ae ju" href="https://www.python.org/dev/peps/pep-0008/" rel="noopener ugc nofollow" target="_blank"> PEP 8 Python命名约定</a>也提到了骆驼大小写。但是，它补充说私有属性应该以下划线为前缀。比如(<code class="du ln lo lp lq b">_privateProperty</code>)。</p><p id="0457" class="pw-post-body-paragraph iw ix hi iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt hb bi translated">C#编码惯例似乎是最严格的。他们指出:</p><ul class=""><li id="69d8" class="jv jw hi iy b iz ja jd je jh jx jl jy jp jz jt lm kb kc kd bi translated">公共属性应该是pascal大小写的(例如<code class="du ln lo lp lq b">PublicMethod</code>或<code class="du ln lo lp lq b">PublicVariable</code>)</li><li id="48c4" class="jv jw hi iy b iz ke jd kf jh kg jl kh jp ki jt lm kb kc kd bi translated">私有或内部属性应该以下划线为前缀并区分大小写(例如<code class="du ln lo lp lq b">private void _privateMethod</code>)</li><li id="5be0" class="jv jw hi iy b iz ke jd kf jh kg jl kh jp ki jt lm kb kc kd bi translated">私有或内部静态属性应该以<code class="du ln lo lp lq b">s_</code>为前缀，并采用骆驼格式(例如<code class="du ln lo lp lq b">private static foo s_workerQueue</code>)</li><li id="f928" class="jv jw hi iy b iz ke jd kf jh kg jl kh jp ki jt lm kb kc kd bi translated">私有或内部线程属性应该以<code class="du ln lo lp lq b">t_</code>为前缀，并采用骆驼格式(例如<code class="du ln lo lp lq b">private static foo t_timeSpan</code></li></ul><p id="b0ce" class="pw-post-body-paragraph iw ix hi iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt hb bi translated">无论出于什么原因，如果你正在创建自己的惯例，我个人建议:</p><ul class=""><li id="60ad" class="jv jw hi iy b iz ja jd je jh jx jl jy jp jz jt lm kb kc kd bi translated">方法使用pascal大小写，属性使用camel大小写(这是Unity游戏引擎中使用的约定)。这样做的原因是为了区分布尔属性(如<code class="du ln lo lp lq b">isValid</code>)和返回布尔的方法(如<code class="du ln lo lp lq b">IsValid(data)</code>)。作为第二种选择，我将使用camel case作为方法。</li><li id="0eea" class="jv jw hi iy b iz ke jd kf jh kg jl kh jp ki jt lm kb kc kd bi translated">非公共属性的下划线前缀</li><li id="e7f1" class="jv jw hi iy b iz ke jd kf jh kg jl kh jp ki jt lm kb kc kd bi translated">可能是(还不确定)来自C#的<code class="du ln lo lp lq b">s</code>和<code class="du ln lo lp lq b">t</code>前缀。正如Python 的<a class="ae ju" href="https://www.python.org/dev/peps/pep-0020/" rel="noopener ugc nofollow" target="_blank"> Zen所说的“名称空间是一个非常棒的想法——让我们做更多这样的事情吧！”(我认为前缀也有类似的效果)</a></li></ul><h1 id="bbc0" class="kj kk hi bd kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg bi translated">接口</h1><p id="bfeb" class="pw-post-body-paragraph iw ix hi iy b iz lh jb jc jd li jf jg jh lj jj jk jl lk jn jo jp ll jr js jt hb bi translated">接口的名称类似于类名。它们使用帕斯卡格，通常是名词。有时它们可以用一个形容词来命名，例如“可读的”。</p><p id="8021" class="pw-post-body-paragraph iw ix hi iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt hb bi translated">在《清洁代码》一书中，鲍勃大叔建议避免使用<code class="du ln lo lp lq b">I</code>前缀作为接口。Java命名约定<a class="ae ju" href="https://www.oracle.com/java/technologies/javase/codeconventions-namingconventions.html" rel="noopener ugc nofollow" target="_blank">推荐相同的方式。比如<code class="du ln lo lp lq b">interface Foo</code>。</a></p><p id="41b3" class="pw-post-body-paragraph iw ix hi iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt hb bi translated">C#编码惯例建议在接口前加上I .前缀，例如<code class="du ln lo lp lq b">interface IFoo</code>。</p><p id="1d20" class="pw-post-body-paragraph iw ix hi iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt hb bi translated">就我个人而言，我倾向于避免使用前缀。这是因为，作为代码的用户，我对我使用的是接口还是类并不特别感兴趣。</p><h1 id="c375" class="kj kk hi bd kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg bi translated">枚举</h1><p id="1595" class="pw-post-body-paragraph iw ix hi iy b iz lh jb jc jd li jf jg jh lj jj jk jl lk jn jo jp ll jr js jt hb bi translated">Java惯例是将枚举视为具有常数的类。这意味着用pascal大小写和全部大写的字段来命名枚举类型。</p><p id="264c" class="pw-post-body-paragraph iw ix hi iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt hb bi translated">C#也把它们和类一样对待。这意味着使用pascal大小写来命名枚举类型和字段。</p><p id="00ce" class="pw-post-body-paragraph iw ix hi iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt hb bi translated">就个人而言，我更喜欢Java约定，因为它区分了常量和其他值。</p><h1 id="95c4" class="kj kk hi bd kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg bi translated">事件、事件处理程序、消息传递系统和命令</h1><p id="f953" class="pw-post-body-paragraph iw ix hi iy b iz lh jb jc jd li jf jg jh lj jj jk jl lk jn jo jp ll jr js jt hb bi translated">关于事件及其相关功能，需要考虑一些事情。</p><h2 id="867a" class="lv kk hi bd kl mb mc md kp me mf mg kt jh mh mi kx jl mj mk lb jp ml mm lf mn bi translated">事件名称</h2><p id="3214" class="pw-post-body-paragraph iw ix hi iy b iz lh jb jc jd li jf jg jh lj jj jk jl lk jn jo jp ll jr js jt hb bi translated">事件名称:</p><ul class=""><li id="e086" class="jv jw hi iy b iz ja jd je jh jx jl jy jp jz jt lm kb kc kd bi translated">提及一项行动</li><li id="2918" class="jv jw hi iy b iz ke jd kf jh kg jl kh jp ki jt lm kb kc kd bi translated">通常用动词来命名。例如“下载”、“加载”、“删除”、“损坏”、“移动”。</li><li id="051a" class="jv jw hi iy b iz ke jd kf jh kg jl kh jp ki jt lm kb kc kd bi translated">通常用现在时来描述在动作开始前发生的事件。例如，在提交密码重置请求之前，您可以触发一个名为“passwordResetRequestSubmitting”的事件。</li><li id="e526" class="jv jw hi iy b iz ke jd kf jh kg jl kh jp ki jt lm kb kc kd bi translated">通常使用过去式来描述动作完成后触发的事件。例如，在提交密码重置请求后，您可能会触发一个名为“passwordResetRequestSubmitted”的事件。</li></ul><p id="e503" class="pw-post-body-paragraph iw ix hi iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt hb bi translated">根据我的经验，这些约定在许多语言中都很常见。然而，没有太多关于它们的官方文档。一个例外是<a class="ae ju" href="https://docs.microsoft.com/en-us/dotnet/standard/design-guidelines/names-of-type-members" rel="noopener ugc nofollow" target="_blank">。在那里他们正式陈述了这些指导方针</a>。</p><p id="354d" class="pw-post-body-paragraph iw ix hi iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt hb bi translated">对于事件的实际名称，您可以使用任何对您有意义的名称。如果您的事件是在一个类中创建的，那么类名可以提供足够的上下文。例如，如果您有一个类<code class="du ln lo lp lq b">Shape</code>，您可能有一个名为<code class="du ln lo lp lq b">areaChanged</code>的事件。用法类似于<code class="du ln lo lp lq b">myShape.areaChanged += someHandler</code>或<code class="du ln lo lp lq b">myShape.areaChanged.subscribe(someHandler)</code>。在这种情况下，事件名“areaChanged”就足够说明问题了。</p><p id="3106" class="pw-post-body-paragraph iw ix hi iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt hb bi translated">就大小写而言，遵循编程语言中的约定。C#对公共成员(包括事件)使用pascal大小写。大多数其他语言使用骆驼大小写。</p><p id="eb4c" class="pw-post-body-paragraph iw ix hi iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt hb bi translated">一些事件名称示例如下:</p><ul class=""><li id="f39c" class="jv jw hi iy b iz ja jd je jh jx jl jy jp jz jt lm kb kc kd bi translated">文件下载/文件下载</li><li id="00e6" class="jv jw hi iy b iz ke jd kf jh kg jl kh jp ki jt lm kb kc kd bi translated">用户注册/用户注册</li><li id="34b8" class="jv jw hi iy b iz ke jd kf jh kg jl kh jp ki jt lm kb kc kd bi translated">uielementxupdate/uiElementXUpdated</li></ul><h2 id="6db9" class="lv kk hi bd kl mb mc md kp me mf mg kt jh mh mi kx jl mj mk lb jp ml mm lf mn bi translated">事件处理程序</h2><p id="ab72" class="pw-post-body-paragraph iw ix hi iy b iz lh jb jc jd li jf jg jh lj jj jk jl lk jn jo jp ll jr js jt hb bi translated">对于事件处理函数，有一些约定。在前端，<a class="ae ju" href="https://reactjs.org/docs/handling-events.html" rel="noopener ugc nofollow" target="_blank"> React倾向于使用前缀“handle”</a>。C#推荐后缀“EventHandler”。其他语言可能有其他约定。</p><p id="e178" class="pw-post-body-paragraph iw ix hi iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt hb bi translated">事件处理函数的一些示例名称如下:</p><ul class=""><li id="3143" class="jv jw hi iy b iz ja jd je jh jx jl jy jp jz jt lm kb kc kd bi translated">handle user subscribed/usersubscribed handler/UserSubscribedEventHandler</li><li id="5beb" class="jv jw hi iy b iz ke jd kf jh kg jl kh jp ki jt lm kb kc kd bi translated">handle file downloaded/file downloaded handler/file downloaded eventhandler</li></ul><p id="dcf4" class="pw-post-body-paragraph iw ix hi iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt hb bi translated">我个人倾向于使用“handle”前缀。这使函数保持动词形式，这是函数的惯例。</p><h2 id="8749" class="lv kk hi bd kl mb mc md kp me mf mg kt jh mh mi kx jl mj mk lb jp ml mm lf mn bi translated">“开”功能</h2><p id="134e" class="pw-post-body-paragraph iw ix hi iy b iz lh jb jc jd li jf jg jh lj jj jk jl lk jn jo jp ll jr js jt hb bi translated">仅仅用来引发事件的函数往往被命名为<code class="du ln lo lp lq b">on&lt;EventName&gt;</code>。比如“onAreaChanged”。</p><p id="b866" class="pw-post-body-paragraph iw ix hi iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt hb bi translated">使用它们的一个例子是在可能被派生的类中。</p><p id="992c" class="pw-post-body-paragraph iw ix hi iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt hb bi translated">下面是一个C#示例:</p><pre class="iq ir is it fd lr lq ls lt aw lu bi"><span id="a2fb" class="lv kk hi lq b fi lw lx l ly lz">class Foo<br/>{<br/>  public event EventHandler FileDownloaded;<br/><br/>  protected virtual void OnFileDownloaded(EventArgs e)<br/>  {<br/>    EventHandler handler = FileDownloaded;<br/>    if (handler != null) {<br/>      FileDownloaded(this, e);<br/>    }<br/>  }<br/><br/>  public void Something()<br/>  {<br/>    OnFileDownloaded(EventArgs.Empty);<br/>  }<br/>}</span></pre><p id="640e" class="pw-post-body-paragraph iw ix hi iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt hb bi translated">这里，我们有一个名为<code class="du ln lo lp lq b">OnFileDownloaded</code>的方法，它的唯一目的是引发事件。</p><p id="35b4" class="pw-post-body-paragraph iw ix hi iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt hb bi translated">这种约定在前端可能有点不同，但它仍然遵循一般的思想。例如，在React中，可以将道具命名为“onClick”或“onSomeEvent”。在组件内部定义的事件处理函数可以使用“handle”前缀。</p><p id="25a4" class="pw-post-body-paragraph iw ix hi iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt hb bi translated">下面是一个React示例:</p><pre class="iq ir is it fd lr lq ls lt aw lu bi"><span id="5971" class="lv kk hi lq b fi lw lx l ly lz">import React from 'react';<br/><br/>const ParentComponent = () =&gt; {<br/>  function handleButtonClicked() {/* do something */}<br/>  return &lt;ChildComponent onClick={handleButtonClicked} /&gt;;<br/>};<br/><br/>const ChildComponent = ({ onClick }) =&gt; {<br/>  const handleClick = (e) =&gt; {<br/>    console.log("clicked");<br/>    onClick("foo");<br/>  };<br/>  return &lt;button onClick={handleClick}&gt;Click me&lt;/button&gt;;<br/>};</span></pre><p id="b676" class="pw-post-body-paragraph iw ix hi iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt hb bi translated">这里，每个组件都创建以“handle”为前缀的事件处理函数。子组件有一个名为“onClick”的属性。在子组件中，<code class="du ln lo lp lq b">handleClick</code>函数调用<code class="du ln lo lp lq b">onClick</code>属性。</p><h2 id="f62d" class="lv kk hi bd kl mb mc md kp me mf mg kt jh mh mi kx jl mj mk lb jp ml mm lf mn bi translated">更多全局消息名称</h2><p id="46d0" class="pw-post-body-paragraph iw ix hi iy b iz lh jb jc jd li jf jg jh lj jj jk jl lk jn jo jp ll jr js jt hb bi translated">PubSub(消息总线)和分析与本地事件有相似之处，但它们更具全球性。它们跨越了更大范围的代码库。甚至可以跨越多个应用程序(分析可能就是这种情况)。</p><p id="6ddb" class="pw-post-body-paragraph iw ix hi iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt hb bi translated">有了这些，使用更具体的名称就很重要了，否则你就不知道他们指的是什么了。</p><p id="a24c" class="pw-post-body-paragraph iw ix hi iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt hb bi translated">一个好的方法是使用名称空间和前缀，以及指定的分隔符。</p><p id="090a" class="pw-post-body-paragraph iw ix hi iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt hb bi translated">例如，使用PubSub事件名称，您可以为代码库的相关区域指定一个名称空间。事件名称的格式可以是<code class="du ln lo lp lq b">&lt;areaOfCodebase&gt;/&lt;eventName&gt;</code>。例如:</p><ul class=""><li id="f696" class="jv jw hi iy b iz ja jd je jh jx jl jy jp jz jt lm kb kc kd bi translated">ui/主题已更改</li><li id="3d60" class="jv jw hi iy b iz ke jd kf jh kg jl kh jp ki jt lm kb kc kd bi translated">ui/font size已更改</li><li id="84b5" class="jv jw hi iy b iz ke jd kf jh kg jl kh jp ki jt lm kb kc kd bi translated">播放器/损坏</li><li id="c3d2" class="jv jw hi iy b iz ke jd kf jh kg jl kh jp ki jt lm kb kc kd bi translated">播放器/电源关闭</li><li id="d4b1" class="jv jw hi iy b iz ke jd kf jh kg jl kh jp ki jt lm kb kc kd bi translated">用户/注册</li><li id="6f2f" class="jv jw hi iy b iz ke jd kf jh kg jl kh jp ki jt lm kb kc kd bi translated">用户/注册</li><li id="6463" class="jv jw hi iy b iz ke jd kf jh kg jl kh jp ki jt lm kb kc kd bi translated">用户/已删除</li></ul><p id="6370" class="pw-post-body-paragraph iw ix hi iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt hb bi translated">正如大卫·威尔斯在<a class="ae ju" href="https://davidwells.io/blog/clean-analytics" rel="noopener ugc nofollow" target="_blank">的《干净的分析》中所解释的那样</a>，对于分析，你可以使用像<code class="du ln lo lp lq b">&lt;Source&gt;:&lt;object&gt;_&lt;actionName&gt;</code>这样的格式。例如:</p><ul class=""><li id="4a30" class="jv jw hi iy b iz ja jd je jh jx jl jy jp jz jt lm kb kc kd bi translated">站点:时事通讯_已订阅</li><li id="0ebd" class="jv jw hi iy b iz ke jd kf jh kg jl kh jp ki jt lm kb kc kd bi translated">app:site_deployed</li><li id="109d" class="jv jw hi iy b iz ke jd kf jh kg jl kh jp ki jt lm kb kc kd bi translated">cli:用户登录</li><li id="3a76" class="jv jw hi iy b iz ke jd kf jh kg jl kh jp ki jt lm kb kc kd bi translated">api:站点_已创建</li></ul><p id="b236" class="pw-post-body-paragraph iw ix hi iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt hb bi translated">这些只是例子。在您自己的代码库中，您可以使用任意多的名称空间。名称空间可以是任何东西。</p><p id="f519" class="pw-post-body-paragraph iw ix hi iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt hb bi translated">同样，分隔符可以是您想要的任何东西。例如“/”、“::”、“:”、“_”，甚至没有分隔符。</p><h2 id="afbe" class="lv kk hi bd kl mb mc md kp me mf mg kt jh mh mi kx jl mj mk lb jp ml mm lf mn bi translated">命令</h2><p id="0e13" class="pw-post-body-paragraph iw ix hi iy b iz lh jb jc jd li jf jg jh lj jj jk jl lk jn jo jp ll jr js jt hb bi translated">命令的编写类似于函数。它们是祈使语气的动词。它们也在PubSub中使用。上面提到的关于名称空间和分隔符的注释适用于它们。</p><p id="3e7c" class="pw-post-body-paragraph iw ix hi iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt hb bi translated">命令通常也需要响应。换句话说，像“CreateUser”这样的命令会有“CreateUserResult”、“CreateUserSucceeded”甚至“UserCreatedNotification”这样的响应消息。总的来说，我不知道这些有什么强约定，所以你可以使用你喜欢的任何东西。</p><p id="eabd" class="pw-post-body-paragraph iw ix hi iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt hb bi translated">我个人对响应名称的偏好来自于Jimmy Bogard关于消息命名约定的文章。我通常在原来的命令名后面加上“Result”、“Reply”或“Response”。</p><p id="ade4" class="pw-post-body-paragraph iw ix hi iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt hb bi translated">命令名及其名称空间的一些示例格式是<code class="du ln lo lp lq b">&lt;Verb&gt;&lt;Subject&gt;</code>和<code class="du ln lo lp lq b">&lt;subject&gt;/&lt;verb&gt;</code>。例如:</p><ul class=""><li id="6af7" class="jv jw hi iy b iz ja jd je jh jx jl jy jp jz jt lm kb kc kd bi translated">可能的命令是“注册用户”或“用户/注册”。可能的响应是“注册用户响应”或“用户/注册结果”</li><li id="0177" class="jv jw hi iy b iz ke jd kf jh kg jl kh jp ki jt lm kb kc kd bi translated">可能的命令有“损坏播放器”、“播放器/损坏”。可能的响应是“损坏玩家响应”、“玩家/损坏_结果”</li></ul><h1 id="d9d4" class="kj kk hi bd kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg bi translated">文件名</h1><p id="a1c9" class="pw-post-body-paragraph iw ix hi iy b iz lh jb jc jd li jf jg jh lj jj jk jl lk jn jo jp ll jr js jt hb bi translated">对于文件名，您需要考虑大小写的约定，以及根据文件包含的代码来命名文件。</p><h2 id="9aab" class="lv kk hi bd kl mb mc md kp me mf mg kt jh mh mi kx jl mj mk lb jp ml mm lf mn bi translated">文件名大小写约定和分隔符</h2><p id="5abb" class="pw-post-body-paragraph iw ix hi iy b iz lh jb jc jd li jf jg jh lj jj jk jl lk jn jo jp ll jr js jt hb bi translated">对于文件命名，根据您遵循的语言、框架和风格指南，有不同的约定。</p><p id="d19e" class="pw-post-body-paragraph iw ix hi iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt hb bi translated">许多惯例建议文件名都是小写字母。单词可以用连字符(-)或下划线(_)分隔。例如:</p><ul class=""><li id="c436" class="jv jw hi iy b iz ja jd je jh jx jl jy jp jz jt lm kb kc kd bi translated">在HTML中，约定都是小写，用连字符作为分隔符。下划线很少出现。其中一个原因是HTML文件名可能会反映在URL中(尤其是对于较旧的服务器)。URL中的下划线远不如连字符常见。</li><li id="7893" class="jv jw hi iy b iz ke jd kf jh kg jl kh jp ki jt lm kb kc kd bi translated">在CSS中，约定都是小写，用连字符或下划线作为分隔符</li><li id="ed91" class="jv jw hi iy b iz ke jd kf jh kg jl kh jp ki jt lm kb kc kd bi translated">在Python中，PEP 8建议文件名全部小写，用下划线作为分隔符</li><li id="ba72" class="jv jw hi iy b iz ke jd kf jh kg jl kh jp ki jt lm kb kc kd bi translated">Google JavaScript风格指南建议文件名全部小写，用下划线或连字符作为分隔符</li></ul><p id="032b" class="pw-post-body-paragraph iw ix hi iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt hb bi translated">在连字符和下划线之间，你可以使用任何一个。两者都可以接受。一般来说，我更喜欢使用连字符来与我的CSS类保持一致(CSS类通常使用连字符),这也是HTML中提到的原因。但是，如果您在编程语言中经常使用snake case，或者如果您不编写HTML和CSS，那么使用下划线而不是连字符可能会更一致。</p><p id="9fda" class="pw-post-body-paragraph iw ix hi iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt hb bi translated">一些文件名示例如下:</p><ul class=""><li id="46ec" class="jv jw hi iy b iz ja jd je jh jx jl jy jp jz jt lm kb kc kd bi translated">index.html</li><li id="588e" class="jv jw hi iy b iz ke jd kf jh kg jl kh jp ki jt lm kb kc kd bi translated">第三方分析网站</li><li id="e240" class="jv jw hi iy b iz ke jd kf jh kg jl kh jp ki jt lm kb kc kd bi translated">敌人-移动者. js</li></ul><p id="bffd" class="pw-post-body-paragraph iw ix hi iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt hb bi translated">除此之外，还有其他约定推荐您的文件使用camel或pascal case。例如:</p><ul class=""><li id="da70" class="jv jw hi iy b iz ja jd je jh jx jl jy jp jz jt lm kb kc kd bi translated">C#和Java建议将你的文件命名为与你的文件中的main一样。这意味着使用pascal大小写，就像你的类和接口一样。</li><li id="68b3" class="jv jw hi iy b iz ke jd kf jh kg jl kh jp ki jt lm kb kc kd bi translated">AirBnB JavaScript风格指南建议将文件命名为与默认导出相同的名称。同样，这意味着使用camel或pascal case，至少对于您的JavaScript文件是这样。</li></ul><p id="9084" class="pw-post-body-paragraph iw ix hi iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt hb bi translated"><a class="ae ju" href="https://reactjs.org/docs/faq-structure.html" rel="noopener ugc nofollow" target="_blank"> React更进一步，建议在每个文件夹中用一致的名称命名所有文件</a>。例如:</p><ul class=""><li id="e601" class="jv jw hi iy b iz ja jd je jh jx jl jy jp jz jt lm kb kc kd bi translated">MyComponent.js</li><li id="be5f" class="jv jw hi iy b iz ke jd kf jh kg jl kh jp ki jt lm kb kc kd bi translated">MyComponent.css</li><li id="5978" class="jv jw hi iy b iz ke jd kf jh kg jl kh jp ki jt lm kb kc kd bi translated">MyComponent.test.js(测试文件通常有特殊的扩展名. test.js)</li></ul><p id="7302" class="pw-post-body-paragraph iw ix hi iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt hb bi translated">那么应该选择哪个呢？首先，考虑对于您的编程语言或框架来说，是否有一种约定比其他约定更常见。那是自然的选择。否则，你可以为所欲为。我个人的建议是选择与文件中的代码最匹配的命名约定。例如，在前端工作时，惯例是HTML和CSS中的所有内容都是小写，用连字符作为分隔符。因此，您可能希望使用它作为命名约定。</p><p id="1575" class="pw-post-body-paragraph iw ix hi iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt hb bi translated">作为另一个例子，当处理使用CSS模块的React应用程序时，您可能更喜欢使用pascal大小写和下划线来编写CSS。这使得在JavaScript中使用CSS更加容易，例如<code class="du ln lo lp lq b">styles.Foo_bar</code>(其中<code class="du ln lo lp lq b">Foo_bar</code>是CSS类)，因为JavaScript中不允许使用连字符。在这种情况下，使用pascal case命名文件可能会感觉更自然。</p><h2 id="6950" class="lv kk hi bd kl mb mc md kp me mf mg kt jh mh mi kx jl mj mk lb jp ml mm lf mn bi translated">根据文件名包含的代码选择文件名</h2><p id="4134" class="pw-post-body-paragraph iw ix hi iy b iz lh jb jc jd li jf jg jh lj jj jk jl lk jn jo jp ll jr js jt hb bi translated">通常，您希望根据文件的用途来命名文件。</p><p id="8fb6" class="pw-post-body-paragraph iw ix hi iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt hb bi translated">这受到C#命名约定和Java命名约定的支持。它们规定你的文件名应该和你在文件中定义的主要内容相同。例如，如果你定义了一个Foo类，你的文件名应该是Foo.cs或者Foo.java。</p><p id="e31e" class="pw-post-body-paragraph iw ix hi iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt hb bi translated">AirBnB JavaScript风格指南也同意这一点。它规定您的文件应该以您的默认导出命名。是否使用默认导出是另一回事。但重点是一样的。意思是以目的命名，或者以你文件中最重要的东西命名。通常(但不总是)，如果你使用导出默认值，你会这么做。</p><p id="0deb" class="pw-post-body-paragraph iw ix hi iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt hb bi translated">一个例外是，如果您的默认导出被命名为“main”、“setup”或类似名称。将一个文件称为“main”是没有意义的，尤其是如果许多文件都有类似的默认导出。在这种情况下，请考虑该文件的用途。另一种方法是考虑等价的OOP代码是什么。</p><p id="f008" class="pw-post-body-paragraph iw ix hi iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt hb bi translated">例如，假设您有一个处理转盘功能的类。你的OOP代码可能是一个名为“Carousel”的类。相比之下，如果您使用函数编写它，它可能看起来像这样:</p><pre class="iq ir is it fd lr lq ls lt aw lu bi"><span id="92f2" class="lv kk hi lq b fi lw lx l ly lz">function handleChangeToNextSlide() {<br/>  // code to change to next slide when user clicks the relevant button<br/>}<br/><br/>function main() {<br/>  // find DOM elements that are supposed to be carousels<br/>  // set up event listeners on those elements<br/>}<br/><br/>export default main;</span></pre><p id="8339" class="pw-post-body-paragraph iw ix hi iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt hb bi translated">在等价的OOP代码中，<code class="du ln lo lp lq b">main</code>中的代码应该在<code class="du ln lo lp lq b">Carousel</code>类的构造函数中。在这种情况下，我建议将文件命名为<code class="du ln lo lp lq b">carousel</code>。这才是它的真正目的。或者，你也可以把<code class="du ln lo lp lq b">main</code>改成<code class="du ln lo lp lq b">setupCarousel</code>或者别的什么，然后给这个文件命名。</p><p id="6fcb" class="pw-post-body-paragraph iw ix hi iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt hb bi translated">至于其他一些情况:</p><ul class=""><li id="63e9" class="jv jw hi iy b iz ja jd je jh jx jl jy jp jz jt lm kb kc kd bi translated">如果你的文件定义了多个类:好吧，大多数风格指南会告诉你避免包含多个类的文件。考虑是否可以将每个类分离到自己的文件中。虽然，如果你只有一个公共类，那也没问题。以一个公共类命名文件，而不是私有类。</li><li id="8567" class="jv jw hi iy b iz ke jd kf jh kg jl kh jp ki jt lm kb kc kd bi translated">如果使用函数而不是类，可能会出现没有一个函数适合导出默认值的情况。同样，您需要考虑文件的用途。例如，如果您的测试文件中使用了一些函数，那么“test-utilities”可能是一个好名字。或者，您可以考虑等价的OOP代码是什么。你可能会有一个包含静态方法的静态类。用静态类的名字命名你的文件。</li></ul><h1 id="a1ae" class="kj kk hi bd kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg bi translated">包名和名称空间</h1><p id="5d91" class="pw-post-body-paragraph iw ix hi iy b iz lh jb jc jd li jf jg jh lj jj jk jl lk jn jo jp ll jr js jt hb bi translated">实际上，许多包根本不遵循命名约定。这是因为开发人员可以上传他们想要的任何名称的包。通常不会有很多支票。</p><p id="c3b4" class="pw-post-body-paragraph iw ix hi iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt hb bi translated">但是，包和不同的包存储库有命名约定。</p><p id="fec3" class="pw-post-body-paragraph iw ix hi iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt hb bi translated">Java和<a class="ae ju" href="https://search.maven.org/" rel="noopener ugc nofollow" target="_blank"> Maven </a>使用<code class="du ln lo lp lq b">&lt;groupID&gt;&lt;artifactID&gt;</code>的格式。组ID部分通常是反向域名。例如，如果您的域是example.com，组ID将是“com.example”。它可以有子组(附加的名称空间)。例如“com.example.plugins”。artifactID是jar的名称。例如“junit”或“spring-web”。一般来说，工件id倾向于完全小写，用连字符来分隔单词。</p><p id="93df" class="pw-post-body-paragraph iw ix hi iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt hb bi translated"><a class="ae ju" href="https://www.npmjs.com/" rel="noopener ugc nofollow" target="_blank"> NPM(节点包管理器)</a>倾向于使用直接的包名，比如“react-dom”，或者以名称空间或公司名称为前缀，比如“@babel/preset-env”。它们倾向于完全小写，用连字符来分隔单词。</p><p id="ead5" class="pw-post-body-paragraph iw ix hi iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt hb bi translated">用<a class="ae ju" href="https://www.nuget.org/" rel="noopener ugc nofollow" target="_blank"> NuGet </a>(包存储库为。NET)，名称空间的数量是变化的，就像Maven和子组一样。有很多套餐只有一个名字，比如“Moq”。还有很多格式<code class="du ln lo lp lq b">&lt;CompanyName&gt;.&lt;Package&gt;</code>的包，比如“AWSSDK。核心”。也有带有许多名称空间的包，比如“Microsoft。extensions . file providers . abstracts”。如果你想效仿微软发布的软件包，那么就使用pascal case，可以选择一个公司前缀和你需要的名称空间。</p><p id="99b8" class="pw-post-body-paragraph iw ix hi iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt hb bi translated">名称空间(在代码中)似乎遵循类似于包的概念和约定。</p><h1 id="40b9" class="kj kk hi bd kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg bi translated">最终提示</h1><p id="3f28" class="pw-post-body-paragraph iw ix hi iy b iz lh jb jc jd li jf jg jh lj jj jk jl lk jn jo jp ll jr js jt hb bi translated">记住命名是困难的。</p><blockquote class="mo mp mq"><p id="b5ce" class="iw ix mr iy b iz ja jb jc jd je jf jg ms ji jj jk mt jm jn jo mu jq jr js jt hb bi translated"><em class="hi">计算机科学只有两个硬东西:缓存失效和事物命名。—菲尔·卡尔顿</em></p></blockquote><p id="fd59" class="pw-post-body-paragraph iw ix hi iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt hb bi translated">然而，花些时间想出一个合理的名字通常是值得的。</p><p id="6364" class="pw-post-body-paragraph iw ix hi iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt hb bi translated">还有，一如既往的务实。偶尔打破这些惯例也没什么。他们只是在这里帮助你在大多数时候做出好的和一致的决定。比如你觉得在名字里加上数据结构会有帮助，比如<code class="du ln lo lp lq b">userList</code>，那也没关系。由你来决定什么对你的项目最有利。</p><p id="e00f" class="pw-post-body-paragraph iw ix hi iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt hb bi translated">此外，你可能不能花不合理的时间想出好名字。所以，有时候，如果你已经花了太长时间，你可能需要用你目前想到的最好的名字，然后继续前进。</p><p id="6aba" class="pw-post-body-paragraph iw ix hi iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt hb bi translated">总的来说，从这篇文章中最重要的是你理解了命名背后的原则。特别是，这些名称应该使代码易于理解。如果你明白这一点，那么你会没事的。即使在不熟悉的情况下，你也能想出自己的解决方案和惯例。</p><h1 id="46f5" class="kj kk hi bd kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg bi translated">最终注释</h1><p id="d63f" class="pw-post-body-paragraph iw ix hi iy b iz lh jb jc jd li jf jg jh lj jj jk jl lk jn jo jp ll jr js jt hb bi translated">这篇文章到此为止。我希望你觉得有用。</p><p id="ce01" class="pw-post-body-paragraph iw ix hi iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt hb bi translated">如果你在你工作过的代码中遇到任何糟糕的名字，请留下评论！</p><p id="5ab3" class="pw-post-body-paragraph iw ix hi iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt hb bi translated">此外，如果你想讨论什么，不同意什么，或有任何反馈，请在下面留下评论。</p><p id="2b85" class="pw-post-body-paragraph iw ix hi iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt hb bi translated">好吧，下次见🙂</p><h1 id="9869" class="kj kk hi bd kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg bi translated">图像制作者名单</h1><ul class=""><li id="5efa" class="jv jw hi iy b iz lh jd li jh mv jl mw jp mx jt lm kb kc kd bi translated">封面照片(修改)——由Paul Stollery在Unsplash上拍摄</li><li id="ec24" class="jv jw hi iy b iz ke jd kf jh kg jl kh jp ki jt lm kb kc kd bi translated">白色表面上白色记事本旁边的透明灯泡—照片由Burak Kebapci在Pexels上拍摄</li><li id="ecb6" class="jv jw hi iy b iz ke jd kf jh kg jl kh jp ki jt lm kb kc kd bi translated">带有白色卡片的绿叶——照片由Helena Hertz在Unsplash上拍摄</li></ul></div><div class="ab cl my mz gp na" role="separator"><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd"/></div><div class="hb hc hd he hf"><p id="0bc3" class="pw-post-body-paragraph iw ix hi iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt hb bi translated"><em class="mr">原载于2021年6月15日</em><a class="ae ju" href="https://programmingduck.com/articles/naming" rel="noopener ugc nofollow" target="_blank"><em class="mr">【https://programmingduck.com】</em></a><em class="mr">。</em></p></div></div>    
</body>
</html>