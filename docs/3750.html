<html>
<head>
<title>Redline — A Redshift Pipeline</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">红线——红移管道</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/redline-a-redshift-pipeline-ca07d5e1ddcb?source=collection_archive---------13-----------------------#2021-06-22">https://medium.com/nerd-for-tech/redline-a-redshift-pipeline-ca07d5e1ddcb?source=collection_archive---------13-----------------------#2021-06-22</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="1009" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这是我作为数据工程师做过的最好的事情之一。让我带你和我们最好的朋友— <strong class="ih hj"> Data </strong>一起踏上一段奇妙的旅程。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es jd"><img src="../Images/cc0f65fc09952acc4f7fe7fbaca03a94.png" data-original-src="https://miro.medium.com/v2/resize:fit:1224/format:webp/1*FVsb3OJrWFATlyP7GfnHag.jpeg"/></div><figcaption class="jl jm et er es jn jo bd b be z dx translated">来源:谷歌</figcaption></figure><p id="575f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">简要介绍这条管道</strong> — <br/>创建这条管道是为了从s3中挑选数据，并使用Redshift Copy命令将其加载到红移数据库中，然后在成功加载<strong class="ih hj"> staging tables(原始数据表)</strong>之后，使用查询文件中编写的查询刷新<strong class="ih hj"> DW tables(自定义查询)</strong>。看起来很简单，对吗？💭但是，为了使这个管道通用，我们引入了许多阶段和许多功能，使这个管道非常大。</p><p id="2c76" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们把它分成2部分- <br/> 1。装载载物台<br/> 2。刷新数据仓库表</p><p id="2f05" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">甚至在数据加载开始之前，我们需要验证管道是否已经为相同的输入运行，因为它会弄乱我们的表数据。<strong class="ih hj">我们如何做到这一点？</strong> <br/>我在博客里已经详细分享了这个策略——<strong class="ih hj"><em class="jp"/></strong><a class="ae jq" rel="noopener" href="/nerd-for-tech/i-m-a-pipeline-571c49ab225b"><strong class="ih hj"><em class="jp">我是管道</em> </strong> </a> <strong class="ih hj"> <em class="jp">。</em> </strong> <br/>因此，当流水线启动时，我们将作业细节写入日志表，然后在每次运行开始时进行检查，如果有一个作业处于处理状态，具有相同的输入，我们返回，给出一个错误，否则继续。这个阶段实际上是一个AWS Lambda函数。</p><p id="eae5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">阶跃函数的初始输入—</p><pre class="je jf jg jh fd jr js jt ju aw jv bi"><span id="9cb9" class="jw jx hi js b fi jy jz l ka kb">{ "jobs":<br/>   {  "job_name": "some_job_name",<br/>      "stage":[{<br/>             "table_name": "table1",<br/>             "active": true,<br/>             "pre_processing": true,<br/>             "type": "incremental",<br/>             "delta": "2:days",<br/>             "s3path": "path/to/s3/"<br/>             },<br/>             {<br/>             "table_name": "table2",<br/>             "active": true,<br/>             "pre_processing": false,<br/>             "type": "full",<br/>             "delta": "",<br/>             "s3path": "path/to/s3/"<br/>             }],<br/>       "dw": [{<br/>              "table": "dwTable1",<br/>              "active": true<br/>              },<br/>              {<br/>              "table": "dwTable2",<br/>              "active": false<br/>             }]<br/>     }<br/>}</span></pre><p id="911b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">输入</strong> — <br/> <strong class="ih hj">类型</strong>和<strong class="ih hj">增量</strong>在此定义s3中上传文件的频率。例如，对于表1，如果s3路径是s3://testbucket/files/因此，任何最新的文件都有完整的数据。<br/>如果数据源是增量的，只有更新的记录到来，那么这里的类型将是增量的，增量被定义为时间范围。因此，如果delta是2:days，这意味着应该选择路径中时间戳在最后两天以内的所有文件。<br/>* *所有其他输入解释如下。</p><p id="6556" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们在这里对AWS Step函数有一个清晰的了解。</p><h2 id="b0cf" class="jw jx hi bd kc kd ke kf kg kh ki kj kk iq kl km kn iu ko kp kq iy kr ks kt ku bi translated">加载暂存表—</h2><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="kw kx di ky bf kz"><div class="er es kv"><img src="../Images/7f743c5221117e4caa910a52a9e7d862.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BDlSYhfZu1BxxZcC3iBeBg.png"/></div></div><figcaption class="jl jm et er es jn jo bd b be z dx translated">加载阶段表-按作者分类的图像</figcaption></figure><p id="ea97" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">除了检查作业状态，我们的第一个Lambda函数还为我们做了几件事——I .检查给定的表是否存在于红移中。<br/>二。检查提供的S3路径是否有效。<br/>三世。根据提供的增量(预期时间段)检查文件是否存在。<br/>并按表传递所有相关信息。JSON被拆分并并行传递给装载阶段表部分。因此，加载阶段表部分的输入将是—</p><pre class="je jf jg jh fd jr js jt ju aw jv bi"><span id="0638" class="jw jx hi js b fi jy jz l ka kb">{<br/>    "table_name": "table1",<br/>    "active": true,<br/>    "pre_processing": true,<br/>    "type": "incremental",<br/>    "delta": "2:days",<br/>    "s3path": "s3://bucket/path/to/s3/",<br/>    "table_exists": true,<br/>    "job_name": "some_job_name",<br/>    "job_status": "Processing",<br/>    "job_id": "timestampvalue"<br/>}</span></pre><p id="3c12" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在<strong class="ih hj"> ValidateInputs </strong>阶段将检查所有这些输入，并根据这些值继续流程。这个阶段是由阶跃函数提供的选择状态。</p><p id="26de" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这里我们来谈谈额外的价值——<br/>1。table_exists —如果table_name(这里是table1)中提供的名称的表存在，则为true，否则为false。<br/> 2。job_status — <em class="jp">处理</em>如果同名的作业已经在运行，则根据上次运行判断是失败还是成功。<br/> 3。job_id —在红移表中标记正在进行的作业时分配为作业id的时间戳值。<br/> 4。现在将解析S3路径，这意味着如果路径存在并且作业类型已满，则将选择最新的时间戳分区。并且如果类型是增量的，那么将挑选落在增量范围内的所有分区。</p><h2 id="d02c" class="jw jx hi bd kc kd ke kf kg kh ki kj kk iq kl km kn iu ko kp kq iy kr ks kt ku bi translated"><strong class="ak">流程</strong>:</h2><p id="6f96" class="pw-post-body-paragraph if ig hi ih b ii la ik il im lb io ip iq lc is it iu ld iw ix iy le ja jb jc hb bi translated">如果<strong class="ih hj"> table_exist </strong>为<strong class="ih hj"> false </strong>或者<strong class="ih hj"> job_status </strong>为<strong class="ih hj"> Processing </strong>或者该表的<strong class="ih hj"> active </strong>标志为<strong class="ih hj"> false </strong>，则该表的作业将通过验证失败触发SNS进入StageEndState。<br/>否则，如果pre_processing为真，则流程将转到数据预处理阶段，否则转到StageLoad。<br/>如果任何数据后处理或阶段加载失败，流程将通过触发SNS的ExceptionSNS阶段转到StageEndState。(参见上面的<strong class="ih hj">负载阶段表</strong>流程)</p><p id="12c0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> # DataProcessing </strong> stage实际上是一个AWS胶水，编写它是为了让数据不嵌套。例如，如果一列包含数组—</p><pre class="je jf jg jh fd jr js jt ju aw jv bi"><span id="92f3" class="jw jx hi js b fi jy jz l ka kb">"col1":"main", "col2":[{"name":"xyz","type":"data","value":123},{"name":"abc","type":"data","value":1234}]</span></pre><p id="781f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这将扩展到—</p><pre class="je jf jg jh fd jr js jt ju aw jv bi"><span id="22f1" class="jw jx hi js b fi jy jz l ka kb">"col1":"main", "col2":{"name":"xyz","type":"data","value":123}<br/>"col1":"main", "col2":{"name":"abc","type":"data","value":1234}</span></pre><p id="9e48" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"># <strong class="ih hj"> StageLoad </strong>也是一个AWS Glue，它将使用Redshift UNLOAD命令将S3数据加载到Redshift。</p></div><div class="ab cl lf lg gp lh" role="separator"><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk"/></div><div class="hb hc hd he hf"><h2 id="69b3" class="jw jx hi bd kc kd ke kf kg kh ki kj kk iq kl km kn iu ko kp kq iy kr ks kt ku bi translated">2.刷新数据仓库表—</h2><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="kw kx di ky bf kz"><div class="er es lm"><img src="../Images/4036e71990f13d10cb005d74d7f048cb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tnnq7gfYE_r1-zMVzUchSg.png"/></div></div><figcaption class="jl jm et er es jn jo bd b be z dx translated">刷新DW表—按作者排序的图像</figcaption></figure><p id="995c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在成功运行装载阶段表之后，流程进行到下一部分。在这里，输入也被验证，输入到验证输入阶段的样本——</p><pre class="je jf jg jh fd jr js jt ju aw jv bi"><span id="3068" class="jw jx hi js b fi jy jz l ka kb">{<br/>    "table": "dwTable1",<br/>    "active": false,<br/>    "table_exists": true,<br/>    "status": "SUCCESSFUL"<br/>}</span></pre><p id="9a63" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">与前一部分类似，如果状态不是正在处理，table_exists为真，active标志为真，那么作业将针对给定的表运行。现在，这个RefreshDW阶段到底是什么？这也是一个AWS粘合作业，它从一个文件中提取查询并在Redshift DB中运行它们。</p><p id="0a64" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">此外，如果任何作业(DataPreprocessing、StageLoad或RefreshDW)在退出之前失败，这些作业将被标记为失败。</p><p id="9b68" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">最后，将再次触发CheckJobs lambda来关闭所有作业，这样在下一次运行时，我们的管道就不会发现它们处于处理状态。</p><p id="6dfe" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">谢谢大家！！</p></div></div>    
</body>
</html>