<html>
<head>
<title>LeetCode — Jump Game</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">LeetCode —跳跃游戏</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/leetcode-jump-game-7b549ff1ccc2?source=collection_archive---------8-----------------------#2021-10-24">https://medium.com/nerd-for-tech/leetcode-jump-game-7b549ff1ccc2?source=collection_archive---------8-----------------------#2021-10-24</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><h1 id="f46b" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">问题陈述</h1><p id="a670" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">给你一个整数数组<strong class="jf hj"> nums </strong>。您最初位于数组的<strong class="jf hj">第一个索引</strong>，数组中的每个元素代表您在该位置的最大跳跃长度。</p><p id="d0f4" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">如果可以到达最后一个索引，则返回<strong class="jf hj"> true </strong>，否则返回<strong class="jf hj"> false </strong>。</p><p id="a90a" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">问题陈述摘自:<a class="ae kg" href="https://leetcode.com/problems/jump-game" rel="noopener ugc nofollow" target="_blank">https://leetcode.com/problems/jump-game</a></p><p id="5e79" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated"><strong class="jf hj">例 1: </strong></p><pre class="kh ki kj kk fd kl km kn ko aw kp bi"><span id="4d91" class="kq ig hi km b fi kr ks l kt ku">Input: nums = [2, 3, 1, 1, 4]<br/>Output: true<br/>Explanation: Jump 1 step from index 0 to 1, then 3 steps to the last index.</span></pre><p id="9719" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated"><strong class="jf hj">例 2: </strong></p><pre class="kh ki kj kk fd kl km kn ko aw kp bi"><span id="0ee2" class="kq ig hi km b fi kr ks l kt ku">Input: nums = [3, 2, 1, 0, 4]<br/>Output: false<br/>Explanation: You will always arrive at index 3 no matter what. Its maximum jump length is 0, which makes it impossible to reach the last index.</span></pre><p id="1dbe" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated"><strong class="jf hj">约束:</strong></p><pre class="kh ki kj kk fd kl km kn ko aw kp bi"><span id="0e50" class="kq ig hi km b fi kr ks l kt ku">- 1 &lt;= nums.length &lt;= 10^4 <br/>- 0 &lt;= nums[i] &lt;= 10^5</span></pre><h1 id="4db3" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">说明</h1><h2 id="e139" class="kq ig hi bd ih kv kw kx il ky kz la ip jo lb lc it js ld le ix jw lf lg jb lh bi translated">强力方法</h2><p id="982d" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">一种简单的方法是从第一个元素开始，递归调用从第一个元素可以到达的所有元素。我们可以用下面的方法来解决这个问题。</p><pre class="kh ki kj kk fd kl km kn ko aw kp bi"><span id="fe26" class="kq ig hi km b fi kr ks l kt ku">minJumps(start, end) = Min ( minJumps(k, end) ) for all k reachable from start</span></pre><p id="8dec" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">上述方法的一小段 C++代码如下所示:</p><pre class="kh ki kj kk fd kl km kn ko aw kp bi"><span id="e922" class="kq ig hi km b fi kr ks l kt ku">int minJumps(int arr[], int n){<br/>    if (n == 1)<br/>        return 0;<br/><br/>    int res = INT_MAX;<br/>    for (int i = n - 2; i &gt;= 0; i--) {<br/>        if (i + arr[i] &gt;= n - 1) {<br/>            int sub_res = minJumps(arr, i + 1);<br/>            if (sub_res != INT_MAX)<br/>                res = min(res, sub_res + 1);<br/>        }<br/>    }<br/><br/>    return res;<br/>}</span></pre><p id="dbc5" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">由于从一个元素移动有 N 种最大可能的方式，上述方法的时间复杂度为<strong class="jf hj"> O(N ) </strong>。</p><h2 id="565f" class="kq ig hi bd ih kv kw kx il ky kz la ip jo lb lc it js ld le ix jw lf lg jb lh bi translated">优化解决方案</h2><p id="1913" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">这个问题可以在线性时间内解决。我们需要确定我们可以从当前索引<strong class="jf hj"> i </strong>中获得的最大跳转。只有当当前跳转大于最大跳转时，我们才使用该索引并递增计数。</p><p id="9318" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">让我们检查下面的算法:</p><pre class="kh ki kj kk fd kl km kn ko aw kp bi"><span id="f267" class="kq ig hi km b fi kr ks l kt ku">- set max = nums[0] the first element of the array.<br/><br/>- if nums.size() == 1 &amp;&amp; nums[0] == 0<br/>  - return true<br/><br/>- loop for i = 0; i &lt; nums.size(); i++<br/>  - if max &lt;= i &amp;&amp; nums[i] == 0<br/>    - return false<br/><br/>  - if i + nums[i] &gt; max<br/>    - max = i + nums[i]<br/><br/>  - if max &gt;= nums.length - 1<br/>    - return true<br/><br/>- return false</span></pre><h2 id="5fa7" class="kq ig hi bd ih kv kw kx il ky kz la ip jo lb lc it js ld le ix jw lf lg jb lh bi translated">C++解决方案</h2><pre class="kh ki kj kk fd kl km kn ko aw kp bi"><span id="8384" class="kq ig hi km b fi kr ks l kt ku">class Solution {<br/>public:<br/>    bool canJump(vector&lt;int&gt;&amp; nums) {<br/>        int max = nums[0];<br/><br/>        if(nums.size() == 1 &amp;&amp; nums[0] == 0)<br/>            return true;<br/><br/>        for(int i = 0; i &lt; nums.size(); i++){<br/>            if(max &lt;= i &amp;&amp; nums[i] == 0)<br/>                return false;<br/><br/>            if(i + nums[i] &gt; max)<br/>                max = i + nums[i];<br/><br/>            if(max &gt;= nums.size() - 1)<br/>                return true;<br/>        }<br/><br/>        return false;<br/>    }<br/>};</span></pre><h2 id="7488" class="kq ig hi bd ih kv kw kx il ky kz la ip jo lb lc it js ld le ix jw lf lg jb lh bi translated">戈朗溶液</h2><pre class="kh ki kj kk fd kl km kn ko aw kp bi"><span id="24f1" class="kq ig hi km b fi kr ks l kt ku">func canJump(nums []int) bool {<br/>    max := nums[0]<br/>    length := len(nums)<br/><br/>    if length == 1 &amp;&amp; nums[0] == 0 {<br/>        return true<br/>    }<br/><br/>    for i := 0; i &lt; length; i++ {<br/>        if max &lt;= i &amp;&amp; nums[i] == 0 {<br/>            return false<br/>        }<br/><br/>        if i + nums[i] &gt; max {<br/>            max = i + nums[i]<br/>        }<br/><br/>        if max &gt;= length - 1 {<br/>            return true<br/>        }<br/>    }<br/><br/>    return false<br/>}</span></pre><h2 id="2d91" class="kq ig hi bd ih kv kw kx il ky kz la ip jo lb lc it js ld le ix jw lf lg jb lh bi translated">Javascript 解决方案</h2><pre class="kh ki kj kk fd kl km kn ko aw kp bi"><span id="75e5" class="kq ig hi km b fi kr ks l kt ku">var canJump = function(nums) {<br/>    let max = nums[0];<br/>    const size = nums.length;<br/><br/>    if( size == 1 &amp;&amp; nums[0] == 0 ){<br/>        return true;<br/>    }<br/><br/>    for(let i = 0; i &lt; size; i++){<br/>        if( max &lt;= i &amp;&amp; nums[i] == 0 ){<br/>            return false;<br/>        }<br/><br/>        if( i + nums[i] &gt; max ){<br/>            max = i + nums[i];<br/>        }<br/><br/>        if( max &gt;= size - 1 ){<br/>            return size;<br/>        }<br/>    }<br/><br/>    return false;<br/>};</span></pre><p id="cc6a" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">让我们试运行一下我们的算法，看看解决方案是如何工作的。</p><pre class="kh ki kj kk fd kl km kn ko aw kp bi"><span id="46ef" class="kq ig hi km b fi kr ks l kt ku">Input: nums = [2, 3, 1, 1, 4]<br/><br/>Step 1: max = nums[0]<br/>            = 2<br/><br/>Step 2: if nums.size() == 1 &amp;&amp; nums[0] == 0<br/>           5 == 1 &amp;&amp; 2 == 0<br/>           false<br/><br/>Step 3: loop for i = 0; i &lt; nums.size()<br/>        0 &lt; 5<br/>        true<br/><br/>        max &lt;= i &amp;&amp; nums[i] == 0<br/>        2 &lt;= 0 &amp;&amp; nums[0] == 0<br/>        2 &lt;= 0 &amp;&amp; 2 == 0<br/>        false<br/><br/>        i + nums[i] &gt; max<br/>        0 + nums[0] &gt; 2<br/>        0 + 2 &gt; 2<br/>        false<br/><br/>        max &gt;= nums.size() - 1<br/>        2 &gt;= 5 - 1<br/>        2 &gt;= 4<br/>        false<br/><br/>        i++<br/>        i = 1<br/><br/>Step 4: i &lt; nums.size()<br/>        1 &lt; 5<br/>        true<br/><br/>        max &lt;= i &amp;&amp; nums[i] == 0<br/>        2 &lt;= 1 &amp;&amp; nums[1] == 0<br/>        2 &lt;= 1 &amp;&amp; 3 == 0<br/>        false<br/><br/>        i + nums[i] &gt; max<br/>        1 + nums[1] &gt; 2<br/>        1 + 3 &gt; 2<br/>        4 &gt; 2<br/>        true<br/><br/>        max = i + nums[i]<br/>            = 1 + nums[1]<br/>            = 1 + 3<br/>            = 4<br/><br/>        max &gt;= nums.size() - 1<br/>        4 &gt;= 5 - 1<br/>        4 &gt;= 4<br/>        true<br/><br/>        return true<br/><br/>So the answer we return is true.</span></pre><p id="e0cd" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">让我们试运行一下负面测试用例。</p><pre class="kh ki kj kk fd kl km kn ko aw kp bi"><span id="b03b" class="kq ig hi km b fi kr ks l kt ku">Input: nums = [3, 2, 1, 0, 4]<br/><br/>Step 1: max = nums[0]<br/>            = 3<br/><br/>Step 2: if nums.size() == 1 &amp;&amp; nums[0] == 0<br/>           5 == 1 &amp;&amp; 3 == 0<br/>           false<br/><br/>Step 3: loop for i = 0; i &lt; nums.size()<br/>        0 &lt; 5<br/>        true<br/><br/>        max &lt;= i &amp;&amp; nums[i] == 0<br/>        3 &lt;= 0 &amp;&amp; nums[0] == 0<br/>        3 &lt;= 0 &amp;&amp; 3 == 0<br/>        false<br/><br/>        i + nums[i] &gt; max<br/>        0 + nums[3] &gt; 3<br/>        0 + 3 &gt; 3<br/>        false<br/><br/>        max &gt;= nums.size() - 1<br/>        3 &gt;= 5 - 1<br/>        3 &gt;= 4<br/>        false<br/><br/>        i++<br/>        i = 1<br/><br/>Step 4: i &lt; nums.size()<br/>        1 &lt; 5<br/>        true<br/><br/>        max &lt;= i &amp;&amp; nums[i] == 0<br/>        3 &lt;= 1 &amp;&amp; nums[2] == 0<br/>        3 &lt;= 1 &amp;&amp; 2 == 0<br/>        false<br/><br/>        i + nums[i] &gt; max<br/>        1 + nums[2] &gt; 3<br/>        1 + 2 &gt; 3<br/>        3 &gt; 3<br/>        false<br/><br/>        max &gt;= nums.size() - 1<br/>        3 &gt;= 5 - 1<br/>        3 &gt;= 4<br/>        false<br/><br/>        i++<br/>        i = 2<br/><br/>Step 5: i &lt; nums.size()<br/>        2 &lt; 5<br/>        true<br/><br/>        max &lt;= i &amp;&amp; nums[i] == 0<br/>        3 &lt;= 2 &amp;&amp; nums[2] == 0<br/>        3 &lt;= 2 &amp;&amp; 1 == 0<br/>        false<br/><br/>        i + nums[i] &gt; max<br/>        2 + nums[2] &gt; 3<br/>        2 + 1 &gt; 3<br/>        3 &gt; 3<br/>        false<br/><br/>        max &gt;= nums.size() - 1<br/>        3 &gt;= 5 - 1<br/>        3 &gt;= 4<br/>        false<br/><br/>        i++<br/>        i = 3<br/><br/>Step 6: i &lt; nums.size()<br/>        3 &lt; 5<br/>        true<br/><br/>        max &lt;= i &amp;&amp; nums[i] == 0<br/>        3 &lt;= 3 &amp;&amp; nums[3] == 0<br/>        3 &lt;= 3 &amp;&amp; 0 == 0<br/>        true<br/><br/>        return false<br/><br/>So the answer we return is false.</span></pre></div><div class="ab cl li lj gp lk" role="separator"><span class="ll bw bk lm ln lo"/><span class="ll bw bk lm ln lo"/><span class="ll bw bk lm ln"/></div><div class="hb hc hd he hf"><p id="db0b" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated"><em class="lp">原载于</em><a class="ae kg" href="https://alkeshghorpade.me/post/leetcode-jump-game" rel="noopener ugc nofollow" target="_blank"><em class="lp">https://alkeshghorpade . me</em></a><em class="lp">。</em></p></div></div>    
</body>
</html>