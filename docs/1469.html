<html>
<head>
<title>Understanding Database Isolation Levels</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">了解数据库隔离级别</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/understanding-database-isolation-levels-c4ebcd55c6b9?source=collection_archive---------0-----------------------#2021-03-21">https://medium.com/nerd-for-tech/understanding-database-isolation-levels-c4ebcd55c6b9?source=collection_archive---------0-----------------------#2021-03-21</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div class="er es if"><img src="../Images/db79a70f22c6a1862ad83f4f880d07e1.png" data-original-src="https://miro.medium.com/v2/resize:fit:900/format:webp/1*mVdCbKYV_5M6lLELVG5yBQ.png"/></div></figure><h1 id="2cc3" class="im in hi bd io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj bi translated">什么是<strong class="ak">隔离</strong>等级<strong class="ak">？</strong></h1><p id="02a7" class="pw-post-body-paragraph jk jl hi jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh hb bi translated">我们知道，为了保持数据库的一致性，它遵循<strong class="jm hj">酸</strong>属性。在这四个属性(原子性、一致性、隔离性和持久性)中，隔离意味着事务应该以这样一种方式在系统中发生，即它是访问数据库系统中资源的唯一事务。</p><h1 id="1ed5" class="im in hi bd io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj bi translated">为什么我们需要隔离？</h1><p id="9854" class="pw-post-body-paragraph jk jl hi jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh hb bi translated">假设您正在为大型电子商务实现一个系统。许多操作必须同时进行，多个客户可能同时想要购买相同的产品，一些产品的价格可能改变，新产品仍在交付中，等等。如您所知，用户执行的单个操作在数据库中作为事务运行，因此我们需要添加一些逻辑来保持一致性，这就是隔离的作用，因为它控制:</p><ul class=""><li id="e0e1" class="ki kj hi jm b jn kk jr kl jv km jz kn kd ko kh kp kq kr ks bi translated">读取数据时是否锁定，以及请求何种类型的锁定。</li><li id="68ab" class="ki kj hi jm b jn kt jr ku jv kv jz kw kd kx kh kp kq kr ks bi translated">持有读锁的时间。</li><li id="d7d7" class="ki kj hi jm b jn kt jr ku jv kv jz kw kd kx kh kp kq kr ks bi translated">一个读操作是否引用了被另一个事务修改的行，因此它会阻塞，直到该行上的独占锁被释放，或者检索语句或事务启动时存在的行的已提交版本，这取决于隔离级别</li></ul><h1 id="9a77" class="im in hi bd io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj bi translated">什么是“隔离级别”？</h1><p id="983d" class="pw-post-body-paragraph jk jl hi jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh hb bi translated"><strong class="jm hj">数据库隔离</strong>定义了一个事务必须与任何其他事务所做的数据修改隔离的程度(即使实际上可能有大量并发运行的事务)。首要目标是防止并发事务对临时数据、中止数据或其他不正确数据的读写。</p><h1 id="42ce" class="im in hi bd io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj bi translated">事务隔离级别由以下现象定义</h1><h2 id="a159" class="ky in hi bd io kz la lb is lc ld le iw jv lf lg ja jz lh li je kd lj lk ji ll bi translated">脏读</h2><p id="cdb1" class="pw-post-body-paragraph jk jl hi jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh hb bi translated">事务读取由并发未提交事务写入的数据。(未提交的数据称为“脏数据”)</p><figure class="ln lo lp lq fd ij er es paragraph-image"><div role="button" tabindex="0" class="lr ls di lt bf lu"><div class="er es lm"><img src="../Images/0640000e965d5dd37004206a03380888.png" data-original-src="https://miro.medium.com/v2/resize:fit:758/format:webp/1*3Rb475q3vk7UMGFW4rB4IQ.png"/></div></div></figure><p id="e77f" class="pw-post-body-paragraph jk jl hi jm b jn kk jp jq jr kl jt ju jv lv jx jy jz lw kb kc kd lx kf kg kh hb bi translated">例如，假设事务 1 更新了一行并使其未提交，同时，事务 2 读取更新的行。如果事务 1 回滚更改，事务 2 将读取被认为从未存在过的数据。</p><h2 id="33c0" class="ky in hi bd io kz la lb is lc ld le iw jv lf lg ja jz lh li je kd lj lk ji ll bi translated">不可重复读取和读取偏差</h2><p id="05c9" class="pw-post-body-paragraph jk jl hi jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh hb bi translated">一个事务重新读取它以前读取的数据，并发现数据已被另一个事务修改(自初始读取以来已被提交)。</p><p id="4794" class="pw-post-body-paragraph jk jl hi jm b jn kk jp jq jr kl jt ju jv lv jx jy jz lw kb kc kd lx kf kg kh hb bi translated">请注意，这不同于脏读，因为另一个事务已经提交。同样，这种现象需要两次阅读才能显现。</p><figure class="ln lo lp lq fd ij er es paragraph-image"><div class="er es ly"><img src="../Images/8f77ec7b16042006e3d32d0a1e9e432a.png" data-original-src="https://miro.medium.com/v2/resize:fit:832/format:webp/1*NRQAi5Y4GYYJ_uXmsHhPpA.png"/></div></figure><p id="f752" class="pw-post-body-paragraph jk jl hi jm b jn kk jp jq jr kl jt ju jv lv jx jy jz lw kb kc kd lx kf kg kh hb bi translated">例如，假设事务 T1 读取数据。由于并发性，另一个事务 T2 更新相同的数据并提交，现在如果事务 T1 重新读取相同的数据，它将检索不同的值</p><h2 id="63fa" class="ky in hi bd io kz la lb is lc ld le iw jv lf lg ja jz lh li je kd lj lk ji ll bi translated">幻像读取</h2><p id="0da4" class="pw-post-body-paragraph jk jl hi jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh hb bi translated">事务重新执行返回满足搜索条件的一组行的查询，并发现满足条件的一组行由于另一个最近提交的事务而改变了。</p><p id="ce04" class="pw-post-body-paragraph jk jl hi jm b jn kk jp jq jr kl jt ju jv lv jx jy jz lw kb kc kd lx kf kg kh hb bi translated">这类似于一个不可重复的读取，除了它涉及一个变化的集合匹配一个谓词，而不是一个单独的项目。</p><figure class="ln lo lp lq fd ij er es paragraph-image"><div class="er es lz"><img src="../Images/1e3a26dac25fa75c47231bc2afe7e048.png" data-original-src="https://miro.medium.com/v2/resize:fit:730/format:webp/1*R1pXxAd0PQu0bzHe2YPgAQ.png"/></div></figure><p id="ed59" class="pw-post-body-paragraph jk jl hi jm b jn kk jp jq jr kl jt ju jv lv jx jy jz lw kb kc kd lx kf kg kh hb bi translated">例如，假设事务 T1 检索一组满足某些搜索条件的行。现在，事务 T2 生成了一些与事务 T1 的搜索标准相匹配的新行。如果事务 T1 重新执行读取行的语句，它这次将获得一组不同的行。</p><h2 id="feed" class="ky in hi bd io kz la lb is lc ld le iw jv lf lg ja jz lh li je kd lj lk ji ll bi translated">写入偏斜</h2><p id="35f2" class="pw-post-body-paragraph jk jl hi jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh hb bi translated">两个并发事务中的每一个都基于读取与另一个正在写入的内容重叠的数据集来确定它们正在写入的内容。</p><figure class="ln lo lp lq fd ij er es paragraph-image"><div class="er es ma"><img src="../Images/54ff227e2a036b3797639b02af4e80ca.png" data-original-src="https://miro.medium.com/v2/resize:fit:1028/format:webp/1*P8iNcRGHzc267FaQC_jXVw.png"/></div></figure><p id="a466" class="pw-post-body-paragraph jk jl hi jm b jn kk jp jq jr kl jt ju jv lv jx jy jz lw kb kc kd lx kf kg kh hb bi translated">例如，假设 2 个事务读取 x 和 y 的值为 100，那么每个事务单独取其中一个值的反是可以的，总数仍然是非负的。然而，否定这两个值会导致 x+y=-200，违反了约束。对于情感重力，这通常是以银行账户为框架的，只要共同持有的余额总和保持非负，账户余额就可以为负。</p><h1 id="9b93" class="im in hi bd io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj bi translated">基于这些现象，定义了这四个隔离级别</h1><h2 id="8a9d" class="ky in hi bd io kz la lb is lc ld le iw jv lf lg ja jz lh li je kd lj lk ji ll bi translated"><strong class="ak">未提交读取</strong></h2><figure class="ln lo lp lq fd ij er es paragraph-image"><div class="er es mb"><img src="../Images/9101958bbec4ceb334ffb43dec664b98.png" data-original-src="https://miro.medium.com/v2/resize:fit:846/format:webp/1*r-alkyoITFPb1OJG9W3AeA.png"/></div></figure><p id="5ca6" class="pw-post-body-paragraph jk jl hi jm b jn kk jp jq jr kl jt ju jv lv jx jy jz lw kb kc kd lx kf kg kh hb bi translated">未提交读取是最低的隔离级别。在这个级别，确保<strong class="jm hj">如果另一个事务已经更新了数据库行并且没有提交</strong>，则没有事务可以更新该行。这可以防止更新丢失，但不会妨碍脏读</p><h2 id="9280" class="ky in hi bd io kz la lb is lc ld le iw jv lf lg ja jz lh li je kd lj lk ji ll bi translated"><strong class="ak">读犯</strong></h2><figure class="ln lo lp lq fd ij er es paragraph-image"><div class="er es mb"><img src="../Images/7ff8ae486e9839f6effe593a5adcc859.png" data-original-src="https://miro.medium.com/v2/resize:fit:846/format:webp/1*R8zg5BQVwrF8_VHUOKDiaA.png"/></div></figure><p id="253a" class="pw-post-body-paragraph jk jl hi jm b jn kk jp jq jr kl jt ju jv lv jx jy jz lw kb kc kd lx kf kg kh hb bi translated">该隔离级别<strong class="jm hj">不允许任何其他事务写入或读取另一个事务已经写入但尚未提交的行</strong>。因此，它不允许脏读。该事务持有当前行的读或写锁，从而防止其他事务读取、更新或删除该行。</p><h2 id="d1bd" class="ky in hi bd io kz la lb is lc ld le iw jv lf lg ja jz lh li je kd lj lk ji ll bi translated"><strong class="ak">可重复读取</strong></h2><figure class="ln lo lp lq fd ij er es paragraph-image"><div class="er es mc"><img src="../Images/33e02ed1224ddb71bd521f5b1516ccb9.png" data-original-src="https://miro.medium.com/v2/resize:fit:822/format:webp/1*cIyttWsKt2sx90JavM3WUw.png"/></div></figure><p id="8d6d" class="pw-post-body-paragraph jk jl hi jm b jn kk jp jq jr kl jt ju jv lv jx jy jz lw kb kc kd lx kf kg kh hb bi translated">这个隔离级别确保任何从一行读取数据的<strong class="jm hj">事务都会阻止任何其他写事务访问同一行。</strong>这是最严格的隔离级别，它在引用的所有行上持有读锁，在插入、更新或删除的所有行上持有写锁。由于其他事务不能读取、更新或删除这些行，因此避免了不可重复的读取。</p><h2 id="9457" class="ky in hi bd io kz la lb is lc ld le iw jv lf lg ja jz lh li je kd lj lk ji ll bi translated"><strong class="ak">可序列化</strong></h2><figure class="ln lo lp lq fd ij er es paragraph-image"><div class="er es md"><img src="../Images/885a4cdbf44421da079cf162317919c0.png" data-original-src="https://miro.medium.com/v2/resize:fit:976/format:webp/1*bPZH7erIMV4J14kfLlL0-A.png"/></div></figure><p id="c820" class="pw-post-body-paragraph jk jl hi jm b jn kk jp jq jr kl jt ju jv lv jx jy jz lw kb kc kd lx kf kg kh hb bi translated">这个隔离级别是最高的隔离级别。可序列化隔离级别需要的不仅仅是限制对单行的访问。通常，这种隔离模式会<strong class="jm hj">锁定整个表</strong>，以防止任何其他事务从其中插入或读取数据。</p><p id="93c9" class="pw-post-body-paragraph jk jl hi jm b jn kk jp jq jr kl jt ju jv lv jx jy jz lw kb kc kd lx kf kg kh hb bi translated">可串行化执行被定义为操作的执行，其中并发执行的事务看起来是串行执行的。</p><h2 id="4cae" class="ky in hi bd io kz la lb is lc ld le iw jv lf lg ja jz lh li je kd lj lk ji ll bi translated">快照隔离</h2><figure class="ln lo lp lq fd ij er es paragraph-image"><div class="er es me"><img src="../Images/26bbf4e82653ea36b799489c120ecb9f.png" data-original-src="https://miro.medium.com/v2/resize:fit:980/format:webp/1*VZuYyGkbBDcbSuwRmuufEw.png"/></div></figure><p id="763f" class="pw-post-body-paragraph jk jl hi jm b jn kk jp jq jr kl jt ju jv lv jx jy jz lw kb kc kd lx kf kg kh hb bi translated">这种隔离级别可以以比事务隔离更低的成本大大提高并发性。当数据被修改时，受影响的行的已提交版本被复制到 temp 并被赋予版本号。这种操作称为写时复制，用于使用这种技术的所有插入、更新和删除操作。当另一个会话读取相同的数据时，将返回读取事务开始时提交的数据版本。</p><h1 id="586d" class="im in hi bd io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj bi translated">选择哪种事务隔离</h1><figure class="ln lo lp lq fd ij er es paragraph-image"><div role="button" tabindex="0" class="lr ls di lt bf lu"><div class="er es mf"><img src="../Images/24f67c7b82a8e818ae94a16a1c5c77a3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*W1YGmFT6j4GTVndNUzA7pA.jpeg"/></div></div></figure><p id="de82" class="pw-post-body-paragraph jk jl hi jm b jn kk jp jq jr kl jt ju jv lv jx jy jz lw kb kc kd lx kf kg kh hb bi translated">事务隔离级别的选择取决于每个具体情况的细节。这些提示可能会有帮助，但请单独考虑每种情况。</p><p id="a6ce" class="pw-post-body-paragraph jk jl hi jm b jn kk jp jq jr kl jt ju jv lv jx jy jz lw kb kc kd lx kf kg kh hb bi translated">在设计您的应用程序时，您肯定希望确保您的数据库事务不会读取其他事务<strong class="jm hj">的未提交更改。</strong></p><p id="d074" class="pw-post-body-paragraph jk jl hi jm b jn kk jp jq jr kl jt ju jv lv jx jy jz lw kb kc kd lx kf kg kh hb bi translated">因为更改很容易损害您的数据完整性，因为一个事务中的恢复更改可能会被另一个事务读取并接受。因此，在应用程序中确保的最低隔离级别是提交读。<br/>大多数时候你可能不需要可串行化隔离，因为它会在大量并发事务中导致严重的性能问题。<br/>所以这总是取决于您的业务需求</p><h1 id="8949" class="im in hi bd io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj bi translated">结论</h1><p id="c580" class="pw-post-body-paragraph jk jl hi jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh hb bi translated">在这篇文章的最后，是一些阅读和获取更多知识的资源</p><p id="8f21" class="pw-post-body-paragraph jk jl hi jm b jn kk jp jq jr kl jt ju jv lv jx jy jz lw kb kc kd lx kf kg kh hb bi translated"><a class="ae mg" href="https://begriffs.com/posts/2017-08-01-practical-guide-sql-isolation.html" rel="noopener ugc nofollow" target="_blank">T5【SQL 事务隔离实用指南】T6</a></p><p id="dcbb" class="pw-post-body-paragraph jk jl hi jm b jn kk jp jq jr kl jt ju jv lv jx jy jz lw kb kc kd lx kf kg kh hb bi translated"><a class="ae mg" href="https://www.geeksforgeeks.org/transaction-isolation-levels-dbms/" rel="noopener ugc nofollow" target="_blank"><strong class="jm hj">DBMS 中的事务隔离级别</strong> </a></p><p id="02f2" class="pw-post-body-paragraph jk jl hi jm b jn kk jp jq jr kl jt ju jv lv jx jy jz lw kb kc kd lx kf kg kh hb bi translated"><a class="ae mg" href="https://docs.microsoft.com/en-us/sql/connect/jdbc/understanding-isolation-levels?view=sql-server-ver15" rel="noopener ugc nofollow" target="_blank"> <strong class="jm hj">了解隔离级别</strong> </a></p></div></div>    
</body>
</html>