<html>
<head>
<title>Unit Testing Streams in Dart/Flutter</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Dart/Flutter 中的单元测试流</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/unit-testing-streams-in-dart-flutter-6ed72c19f761?source=collection_archive---------0-----------------------#2021-07-09">https://medium.com/nerd-for-tech/unit-testing-streams-in-dart-flutter-6ed72c19f761?source=collection_archive---------0-----------------------#2021-07-09</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="5ad4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Stream 是 dart 中异步编程的构建块之一。大部分时间我们可能不会直接与它们打交道，但是它们在幕后为许多功能工作，如 Bloc、changeNotifier provider 等。但是有时我们需要创建我们自己的流，所以我们需要学习如何对流进行单元测试。这就是我们在这篇文章中将要看到的。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es jd"><img src="../Images/eb06e531ad768b4c4508ac1209420905.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*THpGvEma6OELd04Haybh_g.jpeg"/></div></div><figcaption class="jp jq et er es jr js bd b be z dx translated">照片由<a class="ae jt" href="https://unsplash.com/@dynamo10?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">拉胡尔·戴伊</a>在<a class="ae jt" href="https://unsplash.com/s/photos/streams?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄</figcaption></figure><p id="ac98" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">因为这篇文章仅仅是关于单元测试流，所以我将只指定为我们的应用程序提供流服务的类。</p><p id="ed79" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">我们简单的 app 是做什么的？</strong></p><p id="2a76" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">它将根据我们选择的开关以升序或降序运行计数器。</p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="ju jv l"/></div></figure><p id="fd37" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们为我们的计数器创建一个接口</p><h2 id="5a53" class="jw jx hi bd jy jz ka kb kc kd ke kf kg iq kh ki kj iu kk kl km iy kn ko kp kq bi translated">计数器. dart</h2><pre class="je jf jg jh fd kr ks kt ku aw kv bi"><span id="7a11" class="jw jx hi ks b fi kw kx l ky kz">abstract class MyCounter{<br/>  Stream&lt;int&gt; countStream(int bound);<br/>}</span></pre><p id="a498" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这创建了一个契约，实现 MyCounter 的类将<strong class="ih hj">覆盖 countStream()方法</strong>。</p><p id="a4c1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们将有两个接口 Mycounter 的实现</p><p id="76bf" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> 1。正向计数器</strong></p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="la jv l"/></div></figure><p id="0ec7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">2.反向计数器</p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="la jv l"/></div></figure></div><div class="ab cl lb lc gp ld" role="separator"><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg"/></div><div class="hb hc hd he hf"><p id="5a5d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在我们完成了设置，让我们编写测试</p><h2 id="6b3d" class="jw jx hi bd jy jz ka kb kc kd ke kf kg iq kh ki kj iu kk kl km iy kn ko kp kq bi translated">颤振 _ 测试相关性</h2><p id="15f3" class="pw-post-body-paragraph if ig hi ih b ii li ik il im lj io ip iq lk is it iu ll iw ix iy lm ja jb jc hb bi translated">我们不想自己为单元测试添加任何额外的依赖，因为 flutter 已经有了它。确保您的 dev_dependencies 下的 pubspec.yaml <strong class="ih hj">中有<code class="du ln lo lp ks b"><a class="ae jt" href="https://api.flutter.dev/flutter/flutter_test/flutter_test-library.html" rel="noopener ugc nofollow" target="_blank">flutter_test </a></code>。</strong></p><pre class="je jf jg jh fd kr ks kt ku aw kv bi"><span id="ce24" class="jw jx hi ks b fi kw kx l ky kz">dev_dependencies:<br/>  flutter_test:<br/>    sdk: flutter<br/>  //other dependencies</span></pre><h2 id="b97d" class="jw jx hi bd jy jz ka kb kc kd ke kf kg iq kh ki kj iu kk kl km iy kn ko kp kq bi translated">创建测试文件</h2><p id="3943" class="pw-post-body-paragraph if ig hi ih b ii li ik il im lj io ip iq lk is it iu ll iw ix iy lm ja jb jc hb bi translated">我们通常在<code class="du ln lo lp ks b">test </code>文件夹下编写测试，开发人员在编写测试时通常会遵循一些惯例</p><ol class=""><li id="2614" class="lq lr hi ih b ii ij im in iq ls iu lt iy lu jc lv lw lx ly bi translated">你的<code class="du ln lo lp ks b">test </code>文件夹的结构应该和你的<code class="du ln lo lp ks b">lib</code>文件夹一样。</li><li id="72c8" class="lq lr hi ih b ii lz im ma iq mb iu mc iy md jc lv lw lx ly bi translated">所有的测试都必须以<code class="du ln lo lp ks b">*_test.dart ,</code>结尾，这不仅仅是一个惯例，它有助于 flutter 将那些 dart 文件识别为测试。</li></ol><p id="8124" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们测试一下我们的 MyCounter 实现之一<code class="du ln lo lp ks b">reverse_counter.dart </code>并一个接一个地检查它们</p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="la jv l"/></div></figure><p id="4798" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们已经写了 4 个测试用例，让我们一个一个来</p><ol class=""><li id="cc34" class="lq lr hi ih b ii ij im in iq ls iu lt iy lu jc lv lw lx ly bi translated"><strong class="ih hj"> emitsInOrder() </strong></li></ol><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="la jv l"/></div></figure><blockquote class="me"><p id="b495" class="mf mg hi bd mh mi mj mk ml mm mn jc dx translated"><strong class="ak"> emitsInOrder() — </strong>这个方法确保值按照我们指定的顺序发出。</p></blockquote><ul class=""><li id="f4f8" class="lq lr hi ih b ii mo im mp iq mq iu mr iy ms jc mt lw lx ly bi translated"><strong class="ih hj"> <em class="mu">为什么我们要在上面的代码中使用 emitsInOrder()。</em> </strong> —我们正在测试从流中发出的值是否按降序排列<code class="du ln lo lp ks b">3-&gt;2-&gt;1-&gt;0</code>。</li><li id="04dc" class="lq lr hi ih b ii lz im ma iq mb iu mc iy md jc mt lw lx ly bi translated"><strong class="ih hj"> <em class="mu">怎么用？</em></strong>—emitsInOrder()以<code class="du ln lo lp ks b">Iterable matchers </code>为参数。这就是为什么我们要给这个方法传递一个匹配器列表。</li><li id="b48e" class="lq lr hi ih b ii lz im ma iq mb iu mc iy md jc mt lw lx ly bi translated">我们本可以传递<code class="du ln lo lp ks b">emitsInOrder([ equals(3), equals(2), equals(1),equals(0)] ) </code>，但是没有必要，因为我们不想显式地使用<em class="mu"> equals() </em>。</li><li id="db9a" class="lq lr hi ih b ii lz im ma iq mb iu mc iy md jc mt lw lx ly bi translated"><strong class="ih hj"> <em class="mu">我们什么时候用 emitsDone？</em> </strong> —如果我们想要验证从流中发出的所有值都按照我们指定的顺序排列，我们使用这个匹配器。</li><li id="f3ae" class="lq lr hi ih b ii lz im ma iq mb iu mc iy md jc mt lw lx ly bi translated">如果我们想验证所有的值都是在不考虑顺序的情况下发出的，那么我们可以使用<strong class="ih hj"><em class="mu">emissinanyorder(Iterable Matcher)</em></strong></li></ul><blockquote class="me"><p id="4e7a" class="mf mg hi bd mh mi mj mk ml mm mn jc dx translated"><code class="du ln lo lp ks b"><a class="ae jt" href="https://pub.dev/documentation/test_api/latest/test_api/emitsInAnyOrder.html" rel="noopener ugc nofollow" target="_blank"><em class="mv">emitsInAnyOrder()</em></a></code>工作方式类似于 emitsInOrder()，但是它允许匹配器以任何顺序进行匹配。</p></blockquote><ul class=""><li id="f826" class="lq lr hi ih b ii mo im mp iq mq iu mr iy ms jc mt lw lx ly bi translated">为了只匹配一个事件，使用<strong class="ih hj">发射(matcher) </strong> —这是最简单的一个，并且只使用它来构建所有其他复杂的 Streammatcher。</li></ul><h2 id="80ef" class="jw jx hi bd jy jz ka kb kc kd ke kf kg iq kh ki kj iu kk kl km iy kn ko kp kq bi translated">2.emitsThrough() &amp; emitsDone</h2><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="la jv l"/></div></figure><p id="9882" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这个测试看起来和第一个相似，对吗？但不完全是！</p><h2 id="47fb" class="jw jx hi bd jy jz ka kb kc kd ke kf kg iq kh ki kj iu kk kl km iy kn ko kp kq bi translated">发射穿过</h2><blockquote class="me"><p id="9e01" class="mf mg hi bd mh mi mw mx my mz na jc dx translated"><strong class="ak">emit through(matcher)</strong>—这将消耗由【matcher】匹配的所有事件，以及<strong class="ak">在</strong>之前的所有事件。如果流发出一个没有匹配[matcher]的 done 事件，这将失败并且不消耗任何事件。</p></blockquote><ul class=""><li id="24c9" class="lq lr hi ih b ii mo im mp iq mq iu mr iy ms jc mt lw lx ly bi translated"><strong class="ih hj"> <em class="mu">为什么我们在上面的代码</em>中使用 emit through(0)？</strong> —它<strong class="ih hj"> </strong>消耗所有值，直到匹配到 0(等于(0))。所以它会消耗<code class="du ln lo lp ks b"> 3-&gt;2-&gt;1-&gt;0</code></li><li id="4287" class="lq lr hi ih b ii lz im ma iq mb iu mc iy md jc mt lw lx ly bi translated"><strong class="ih hj"> <em class="mu">当我们使用 emitThough()？</em> </strong> —当我们不关心与【匹配器】匹配的值之前发出的值时。在上面的测试中，我们不关心值 3，2，1。</li></ul><h2 id="60f5" class="jw jx hi bd jy jz ka kb kc kd ke kf kg iq kh ki kj iu kk kl km iy kn ko kp kq bi translated">emitsDone</h2><blockquote class="me"><p id="021b" class="mf mg hi bd mh mi mw mx my mz na jc dx translated"><strong class="ak">emit done—</strong>这个匹配器用于验证流中是否没有剩余的项目。(流已完成)</p></blockquote><ul class=""><li id="9011" class="lq lr hi ih b ii mo im mp iq mq iu mr iy ms jc mt lw lx ly bi translated"><em class="mu">为什么我们在上面的</em>代码中使用<strong class="ih hj"><em class="mu">emit sdone</em></strong><em class="mu">？—我们使用它来确保在发出最后一个值“0”后<strong class="ih hj">不会发出其他值。</strong></em></li><li id="2318" class="lq lr hi ih b ii lz im ma iq mb iu mc iy md jc mt lw lx ly bi translated"><em class="mu">当我们使用 emit sone</em>？—确保流中没有其他要发出的值。</li></ul><h2 id="4fda" class="jw jx hi bd jy jz ka kb kc kd ke kf kg iq kh ki kj iu kk kl km iy kn ko kp kq bi translated">3.ExpectAsync()</h2><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="la jv l"/></div></figure><blockquote class="me"><p id="159f" class="mf mg hi bd mh mi mj mk ml mm mn jc dx translated"><strong class="ak">expect async 1(callback)——</strong>这个函数用于包装一个回调(带一个参数)并确保测试框架保持等待，直到这个回调被调用[count]次。如果它没有被调用[count]次或任何匹配器失败(在回调中)，测试将失败。</p></blockquote><blockquote class="nb nc nd"><p id="59fa" class="if ig mu ih b ii mo ik il im mp io ip ne nf is it ng nh iw ix ni nj ja jb jc hb bi translated">基于回调的参数，expectAsync()有许多变体，如 expectAsync2()、expectAsync3()、…expectAsync6()</p></blockquote><ul class=""><li id="22ed" class="lq lr hi ih b ii ij im in iq ls iu lt iy lu jc mt lw lx ly bi translated"><strong class="ih hj"> <em class="mu">为什么我们在上面的代码中使用 ExpectAsync1(回调)？</em> </strong> <em class="mu"> — </em>我们希望我们对<strong class="ih hj"> <em class="mu">的回调恰好运行四次</em> </strong> <em class="mu">(这是我们在</em><strong class="ih hj"><em class="mu">count</em></strong><em class="mu">关键字参数中指定的)</em>，并且我们还希望检查所有发出的值是否都在范围 0 和 3 之间(包括 0 和 3 两个结束值&amp; 3)。</li><li id="f978" class="lq lr hi ih b ii lz im ma iq mb iu mc iy md jc mt lw lx ly bi translated"><strong class="ih hj"> <em class="mu">我们什么时候用 ExpectAsyncN(回调)？— </em> </strong> <em class="mu">当我们想要验证传递给回调函数的所有值都符合同一个匹配器，并确保回调函数被调用的次数正好为[count]次时。</em></li></ul><h2 id="0478" class="jw jx hi bd jy jz ka kb kc kd ke kf kg iq kh ki kj iu kk kl km iy kn ko kp kq bi translated">4.从不发射</h2><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="la jv l"/></div></figure><blockquote class="me"><p id="8188" class="mf mg hi bd mh mi mj mk ml mm mn jc dx translated"><strong class="ak">never emissues(inner matcher)</strong>—此匹配器用于检查流是否没有发出任何与内部匹配器匹配的值。</p></blockquote><ul class=""><li id="6291" class="lq lr hi ih b ii mo im mp iq mq iu mr iy ms jc mt lw lx ly bi translated"><strong class="ih hj"> <em class="mu">为什么我们在上面的代码中使用 never emitters(is negative)？</em> </strong> <em class="mu"> —我们用来检查我们的流是否没有发出任何负值。</em></li><li id="f3fe" class="lq lr hi ih b ii lz im ma iq mb iu mc iy md jc mt lw lx ly bi translated"><strong class="ih hj"> <em class="mu">当我们使用 never emitters(inner matcher)时？— </em> </strong> <em class="mu">当我们希望确保没有任何异常值(根据我们的业务逻辑)从我们的流中发出时。</em></li></ul></div><div class="ab cl lb lc gp ld" role="separator"><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg"/></div><div class="hb hc hd he hf"><h1 id="fbbb" class="nk jx hi bd jy nl nm nn kc no np nq kg nr ns nt kj nu nv nw km nx ny nz kp oa bi translated">测试非确定性行为</h1><p id="3031" class="pw-post-body-paragraph if ig hi ih b ii li ik il im lj io ip iq lk is it iu ll iw ix iy lm ja jb jc hb bi translated">所有上述行为都是确定的，</p><blockquote class="nb nc nd"><p id="9e48" class="if ig mu ih b ii ij ik il im in io ip ne ir is it ng iv iw ix ni iz ja jb jc hb bi translated">确定性-对于给定的输入，输出总是相同的。在我们的例子中，当我们将 3 传递给我们的反向流时，它将总是产生 3-&gt;2-&gt;1-&gt;0。</p></blockquote><p id="6d2d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们如何测试非确定性行为，flutter 为我们提供了答案。我们可以用<code class="du ln lo lp ks b"><a class="ae jt" href="https://pub.dev/documentation/test_api/latest/test_api/mayEmit.html" rel="noopener ugc nofollow" target="_blank">mayEmit(</a>) or <a class="ae jt" href="https://pub.dev/documentation/test_api/latest/test_api/mayEmitMultiple.html" rel="noopener ugc nofollow" target="_blank">mayEmitMultiple(</a>), </code>来描述这些行为。让我们用一个例子来理解它们。</p><p id="8cde" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们创建 MyCounter 接口的另一个实现，名为<strong class="ih hj"> SurpriseForwardCounter </strong>，它的工作方式类似于 ForwardCounter，但有时可能会在末尾打印一个随机数(一种不确定的行为)。</p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="la jv l"/></div></figure><p id="9d1f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这个类和 ForwardCounter 一样，但是我们在最后引入了一些随机性。</p><p id="e9ec" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">但是等等。我们如何测试呢？让我们看看</p><h2 id="69dc" class="jw jx hi bd jy jz ka kb kc kd ke kf kg iq kh ki kj iu kk kl km iy kn ko kp kq bi translated">1 . mayemitters()</h2><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="la jv l"/></div></figure><blockquote class="me"><p id="98e8" class="mf mg hi bd mh mi mj mk ml mm mn jc dx translated">may emitters(matcher)—此匹配器将始终成功，如果它与[matcher]匹配，它将消耗流中的值，否则将消耗流中的值。</p></blockquote><ul class=""><li id="efa0" class="lq lr hi ih b ii mo im mp iq mq iu mr iy ms jc mt lw lx ly bi translated"><strong class="ih hj"> <em class="mu">为什么我们在上面的代码中使用</em>may emitters(matcher)<em class="mu">？— </em> </strong> <em class="mu">由于流可能不总是在最后发出随机值，所以我们使用 mayEmit()来消耗随机值，只要它在测试用例中没有失败。</em></li><li id="d653" class="lq lr hi ih b ii lz im ma iq mb iu mc iy md jc mt lw lx ly bi translated"><strong class="ih hj"> <em class="mu">当我们使用</em>may emitters(matcher)<em class="mu">？— </em> </strong> <em class="mu">当我们希望仅当一个值与[matcher]匹配时才使用它，如果不匹配，测试用例就会失败。它用于处理非确定性行为。</em></li></ul><blockquote class="me"><p id="82a7" class="mf mg hi bd mh mi mj mk ml mm mn jc dx translated">mayEmitMultiple(matcher) —工作方式类似于<code class="du ln lo lp ks b">mayEmit()</code>，但是它尽可能多地将事件与匹配器进行匹配。</p></blockquote><blockquote class="nb nc nd"><p id="a191" class="if ig mu ih b ii mo ik il im mp io ip ne nf is it ng nh iw ix ni nj ja jb jc hb bi translated"><strong class="ih hj">scene Rio</strong>——当你用<code class="du ln lo lp ks b"><strong class="ih hj">while</strong><em class="hi">(random.nextBool())</em>.</code>替换了<strong class="ih hj"> </strong> <code class="du ln lo lp ks b"><strong class="ih hj">if</strong>(random.nextBool())</code>的 SurpriseForwardCounter 语句后，计数器会发出类似<em class="hi">0-&gt;1-&gt;2-&gt;3-&gt;random value 1-&gt;random value 2-&gt;…-&gt;random value n 的值，直到 random boolean 变为 false。在这些场景中，我们必须使用 mayEmitMultiple()来消耗所有的随机值。</em></p></blockquote></div><div class="ab cl lb lc gp ld" role="separator"><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg"/></div><div class="hb hc hd he hf"><p id="9ca3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我已经介绍了关于单元测试流的大部分主题。要了解更多信息，您可以查看测试包的官方文档。</p><p id="5edd" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">谢谢💖在阅读这篇文章时，如果你发现任何错误，欢迎在评论中提出来📃。如果你喜欢这篇文章，鼓掌👏</p></div></div>    
</body>
</html>