<html>
<head>
<title>Consistent Hashing</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">一致散列法</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/consistent-hashing-6524e48ac648?source=collection_archive---------6-----------------------#2021-06-11">https://medium.com/nerd-for-tech/consistent-hashing-6524e48ac648?source=collection_archive---------6-----------------------#2021-06-11</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><blockquote class="if ig ih"><p id="b4f0" class="ii ij ik il b im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg hb bi translated">在计算机科学中，一致散列是一种特殊的散列，使得当调整散列表大小时，平均只需要重新映射n/m个键，其中n是键的数量，m是槽的数量</p></blockquote><p id="7f32" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jh iv iw ix ji iz ja jb jj jd je jf jg hb bi translated">这就是维基百科对一致性哈希的定义！首先，谁理解维基百科的定义？不多吧？所以让我们试着打破这个定义，看看有什么值得我们学习的。</p><p id="a8cc" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jh iv iw ix ji iz ja jb jj jd je jf jg hb bi translated">假设我们想要创建一个允许用户分享帖子的社交媒体网站。现在让我们把这篇文章作为一个简单的消息。那么这个系统的架构会是什么样的呢？停下来思考几分钟。</p><p id="5e15" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jh iv iw ix ji iz ja jb jj jd je jf jg hb bi translated">如下图所示，用户使用客户端(也称为网站/移动设备)创建并共享随机帖子，该客户端将请求转发给我们的后端服务，即post服务，后者立即向db发出创建帖子条目的请求。</p><figure class="jl jm jn jo fd jp er es paragraph-image"><div class="er es jk"><img src="../Images/f2bef10c7416840842bd6ada1dbe7e77.png" data-original-src="https://miro.medium.com/v2/resize:fit:1362/format:webp/1*4P5_XUaVa2fp-vEIiUX2SQ.png"/></div><figcaption class="js jt et er es ju jv bd b be z dx translated">我们社交媒体应用的系统架构</figcaption></figure><p id="6460" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jh iv iw ix ji iz ja jb jj jd je jf jg hb bi translated">这一流程目前运作良好，因为我们的社交媒体网站现在还不出名，也没有多少帖子被创建。最近，我们的网站获得了用户的关注，我们开始每天收到1000万个帖子请求。你认为我们现有的系统会发生什么变化？</p><p id="7812" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jh iv iw ix ji iz ja jb jj jd je jf jg hb bi translated">下面给出了每天1000万次post请求的存储需求预测。</p><figure class="jl jm jn jo fd jp er es paragraph-image"><div role="button" tabindex="0" class="jx jy di jz bf ka"><div class="er es jw"><img src="../Images/4c7f46b93ebadd42ff7c36316c1cfe7f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3USXghvkoHct6a01yN9bTw.png"/></div></div><figcaption class="js jt et er es ju jv bd b be z dx translated">存储需求预测</figcaption></figure><p id="e963" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jh iv iw ix ji iz ja jb jj jd je jf jg hb bi translated">我们将需要5 GB的磁盘存储来存储一天的帖子。这是海量的数据！如果我们试图在我们可怜的单机数据库实例中存储如此巨大的数据，会发生什么？</p><p id="8310" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jh iv iw ix ji iz ja jb jj jd je jf jg hb bi translated">简单的回答——它会崩溃。</p><p id="36ba" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jh iv iw ix ji iz ja jb jj jd je jf jg hb bi translated">长回答—在某些时候，我们可能需要为帖子添加搜索功能，在这种情况下，我们需要为数据库添加某种索引。大多数索引都存储在数据库机的RAM中，以便快速访问。但是在我们的例子中，索引会很大(由于大量的数据，感谢我们网站的流行),很难将索引完全放入RAM中。这可能会影响我们的数据库性能，降低我们的搜索速度。因此，将我们的数据存储在单一数据库中可能不再有效。</p><p id="f173" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jh iv iw ix ji iz ja jb jj jd je jf jg hb bi translated">假设我们已经理解了这个问题，让我们试着找到一个解决办法。</p><p id="f0f4" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jh iv iw ix ji iz ja jb jj jd je jf jg hb bi translated">我们创建多个数据库实例，每个实例只存储数据的一个子集，怎么样？</p><p id="fade" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jh iv iw ix ji iz ja jb jj jd je jf jg hb bi translated">如下图所示，我们创建了3 db机器，只存储下图所示的文章id范围。我们的后端服务基于post id将post create请求路由到正确的db机器。这种技术会将我们的写入吞吐量提高3倍，并将写入分布在3台机器上。问题解决了！恭喜你。</p><figure class="jl jm jn jo fd jp er es paragraph-image"><div role="button" tabindex="0" class="jx jy di jz bf ka"><div class="er es kb"><img src="../Images/2b0c55ce9868d87a931dcd61be2ad64d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AuZcRPGNq0XBpFqcNCh9wg.png"/></div></div><figcaption class="js jt et er es ju jv bd b be z dx translated">数据库分区</figcaption></figure><p id="39b3" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jh iv iw ix ji iz ja jb jj jd je jf jg hb bi translated">但是这种方法有一些问题，</p><ul class=""><li id="c824" class="kc kd hi il b im in iq ir jh ke ji kf jj kg jg kh ki kj kk bi translated">我们需要通过对数据进行大量假设来预先手动定义分区范围。这真的很糟糕，因为我们可能会得到偏斜。</li><li id="36bd" class="kc kd hi il b im kl iq km jh kn ji ko jj kp jg kh ki kj kk bi translated">在我们的示例中，数据可能不会均匀分布在3 db机器上。为什么这是个问题？假设我们网站的大部分阅读请求来自id在50米到100米之间的帖子，会发生什么呢？与其他数据库相比，在我们的示例中只有第二个数据库可以获得大多数请求，对吗？这称为热点，在我们的示例中，数据库机2将成为热点。</li><li id="efcb" class="kc kd hi il b im kl iq km jh kn ji ko jj kp jg kh ki kj kk bi translated">当我们想要添加更多的数据库机器或者将一个热点机器分成子机器时会发生什么？我们将如何处理分区范围的重新平衡？难题本身！</li></ul><h1 id="5f0d" class="kq kr hi bd ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln bi translated">一致哈希到救援</h1><p id="613b" class="pw-post-body-paragraph ii ij hi il b im lo io ip iq lp is it jh lq iw ix ji lr ja jb jj ls je jf jg hb bi translated">一致散列法解决了上述所有问题。即</p><ul class=""><li id="ac8f" class="kc kd hi il b im in iq ir jh ke ji kf jj kg jg kh ki kj kk bi translated">热点</li><li id="e67e" class="kc kd hi il b im kl iq km jh kn ji ko jj kp jg kh ki kj kk bi translated">扭曲的数据</li><li id="b346" class="kc kd hi il b im kl iq km jh kn ji ko jj kp jg kh ki kj kk bi translated">重新平衡分区</li></ul><figure class="jl jm jn jo fd jp er es paragraph-image"><div role="button" tabindex="0" class="jx jy di jz bf ka"><div class="er es lt"><img src="../Images/d1d0eb06d0e3bcf8953614b4281345ba.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pLUZF7R3HXYjsMnZ4YDICA.png"/></div></div><figcaption class="js jt et er es ju jv bd b be z dx translated">一致散列法</figcaption></figure><p id="0142" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jh iv iw ix ji iz ja jb jj jd je jf jg hb bi translated">一致散列是如何做到的？让我们来看看。</p><p id="bd50" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jh iv iw ix ji iz ja jb jj jd je jf jg hb bi translated">通过post id进行分区的思想保持不变。但是，我们可以通过散列函数传递post id，并使用输出编号来查找db机器，而不是盲目地根据post id将创建post请求转发到特定的分区。迷茫？让我解释一下。</p><p id="0474" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jh iv iw ix ji iz ja jb jj jd je jf jg hb bi translated">哈希函数接收数据，可以是字符串、数字或任何东西，然后输出一个数字。哈希函数的重要特性是，对于给定的输入，输出总是相同的。此外，来自哈希函数的数字将均匀分布，因此没有偏斜分布。</p><pre class="jl jm jn jo fd lu lv lw lx aw ly bi"><span id="675d" class="lz kr hi lv b fi ma mb l mc md">// hash functions take anything and return a number <br/>h(anything) -&gt; number  </span><span id="f5a4" class="lz kr hi lv b fi me mb l mc md">// Hash function return the same number for same input <br/>h(abc) -&gt; 3241 <br/>h(abc) -&gt; 3241</span></pre><p id="ec25" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jh iv iw ix ji iz ja jb jj jd je jf jg hb bi translated">例如，让我们看看当我们试图创建一个id为101的帖子时会发生什么。</p><ol class=""><li id="174f" class="kc kd hi il b im in iq ir jh ke ji kf jj kg jg mf ki kj kk bi translated">用户创建了id为101的帖子</li><li id="4075" class="kc kd hi il b im kl iq km jh kn ji ko jj kp jg mf ki kj kk bi translated">客户端将帖子转发到我们的后端服务</li><li id="3cdd" class="kc kd hi il b im kl iq km jh kn ji ko jj kp jg mf ki kj kk bi translated">后端服务使用散列函数并为给定的帖子id 101生成一个数字2002</li><li id="1d95" class="kc kd hi il b im kl iq km jh kn ji ko jj kp jg mf ki kj kk bi translated">数据存储在db3中，因为它包含分区范围2001–3000，如上图所示</li></ol><pre class="jl jm jn jo fd lu lv lw lx aw ly bi"><span id="b2d6" class="lz kr hi lv b fi ma mb l mc md">post 101 -&gt; h(101) -&gt; 2002 -&gt; store in db3</span></pre><p id="6240" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jh iv iw ix ji iz ja jb jj jd je jf jg hb bi translated">让我们用许多帖子来推断这个想法，</p><pre class="jl jm jn jo fd lu lv lw lx aw ly bi"><span id="5b0e" class="lz kr hi lv b fi ma mb l mc md">post 101 -&gt; h(101) -&gt; 2002 -&gt; store in db3 <br/>post 102 -&gt; h(102) -&gt; 98 -&gt; store in db1 <br/>post 103 -&gt; h(103) -&gt; 1987 -&gt; store in db2 <br/>post 104 -&gt; h(104) -&gt; 3444 -&gt; store in db4 <br/>post 105 -&gt; h(105) -&gt; 44 -&gt; store in db1 <br/>get post 101 -&gt; h(101) -&gt; 2002 -&gt; get from db3</span></pre><p id="df70" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jh iv iw ix ji iz ja jb jj jd je jf jg hb bi translated">所以散列函数确保将帖子均匀地分布在我们拥有的所有数据库机器上。该函数通过将分区分割成围绕一个圆的虚拟段来实现这一点，其中落入该段的任何键都将由负责该分区的特定机器来服务。下图很好地说明了这个想法。</p><figure class="jl jm jn jo fd jp er es paragraph-image"><div class="er es mg"><img src="../Images/91375f6a76556abb6235c41d7f2704d2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1302/format:webp/1*-LX8DSjwVzj7sX7d4SsawQ.png"/></div><figcaption class="js jt et er es ju jv bd b be z dx translated">一致散列分区</figcaption></figure><p id="8f77" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jh iv iw ix ji iz ja jb jj jd je jf jg hb bi translated">在上图中，范围为1–1000的分区将由db1提供服务，范围为1001–2000的分区将由db2提供服务，依此类推。</p><p id="13a6" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jh iv iw ix ji iz ja jb jj jd je jf jg hb bi translated">我们最初提到的两个问题使用一致散列法解决了，</p><ul class=""><li id="d163" class="kc kd hi il b im in iq ir jh ke ji kf jj kg jg kh ki kj kk bi translated">热点(已解决)</li><li id="85c6" class="kc kd hi il b im kl iq km jh kn ji ko jj kp jg kh ki kj kk bi translated">倾斜数据(已解决)</li></ul><p id="a1c3" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jh iv iw ix ji iz ja jb jj jd je jf jg hb bi translated">让我们解决最后一个问题，即当添加或删除新节点时，如何正确地重新平衡分区？</p><p id="fee6" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jh iv iw ix ji iz ja jb jj jd je jf jg hb bi translated">当我们向集群添加一个新的数据库机器时，假设在db4的分区范围(即3001–4000)之间，将会发生以下变化:</p><ol class=""><li id="ecb3" class="kc kd hi il b im in iq ir jh ke ji kf jj kg jg mf ki kj kk bi translated">db4将使用缩小的范围重新划分，例如，eg的范围为3001–3500。</li><li id="daed" class="kc kd hi il b im kl iq km jh kn ji ko jj kp jg mf ki kj kk bi translated">db5将从d4获得剩余的分区范围，即eg的3501–4000。</li><li id="fab7" class="kc kd hi il b im kl iq km jh kn ji ko jj kp jg mf ki kj kk bi translated">数据需要从db4移动到db5(注意，剩余的db1、db2和db3不受影响)</li><li id="398c" class="kc kd hi il b im kl iq km jh kn ji ko jj kp jg mf ki kj kk bi translated">最后，我们的群集重新平衡到5 db机器，没有任何停机时间，并且可以获得5X写入吞吐量。</li></ol><figure class="jl jm jn jo fd jp er es paragraph-image"><div class="er es mh"><img src="../Images/cd4edc65aabe7c4cdd3407dfab8ea1b9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1066/format:webp/1*y7lB8C5Vvt3KwYx3wwEl7Q.png"/></div><figcaption class="js jt et er es ju jv bd b be z dx translated">一致性哈希重新平衡</figcaption></figure><p id="3a45" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jh iv iw ix ji iz ja jb jj jd je jf jg hb bi translated">删除节点的逻辑也以类似的方式工作。你可以试着把它作为一个练习来解决。</p><p id="d5f0" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jh iv iw ix ji iz ja jb jj jd je jf jg hb bi translated">这就是我们如何使用一致散列法有效地对数据库集群(多个数据库的组合)进行分区。现在，我们的社交媒体网站可以毫无问题地扩展许多倍。</p><p id="21fe" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jh iv iw ix ji iz ja jb jj jd je jf jg hb bi translated">但是如果你很好奇，你可能会有一个问题——我们需要在后端服务中自己计算散列吗？</p><p id="b955" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jh iv iw ix ji iz ja jb jj jd je jf jg hb bi translated">好问题。</p><p id="172a" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jh iv iw ix ji iz ja jb jj jd je jf jg hb bi translated">答案是，我们不需要计算任何哈希值。Apache Cassandra等生产数据库将自动计算散列，并跟踪每台数据库机器中分区范围到数据库的映射。与dbs中的实际数据相比，该元信息相对较小。然后，我们的后端服务可以连接到任何数据库机器获取数据，如果没有找到数据，请求将自动重新路由到包含数据的正确机器。这种技术是通过一个叫做流言协议的概念实现的。以下是代表这一想法的图表。</p><figure class="jl jm jn jo fd jp er es paragraph-image"><div role="button" tabindex="0" class="jx jy di jz bf ka"><div class="er es mg"><img src="../Images/350ebb2b756842fb6d601c79abca1b09.png" data-original-src="https://miro.medium.com/v2/resize:fit:1302/format:webp/1*nTTJY4wG4J2xYnAV_-McVg.png"/></div></div><figcaption class="js jt et er es ju jv bd b be z dx translated">请求路由</figcaption></figure><p id="dde2" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jh iv iw ix ji iz ja jb jj jd je jf jg hb bi translated">如果一致散列的初始定义现在没有什么意义，请在评论中告诉我。</p><blockquote class="if ig ih"><p id="5e4a" class="ii ij ik il b im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg hb bi translated">在计算机科学中，一致散列是一种特殊的散列，使得当调整散列表大小时，平均只需要重新映射n/m个键，其中n是键的数量，m是槽的数量</p></blockquote><h1 id="8609" class="kq kr hi bd ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln bi translated">奖金概念</h1><p id="e955" class="pw-post-body-paragraph ii ij hi il b im lo io ip iq lp is it jh lq iw ix ji lr ja jb jj ls je jf jg hb bi translated">我们的社交媒体网站能够很好地适应大负载，我们很高兴，我们的客户也很高兴。很好，但是很快我们可能会在重新平衡期间面临数据库机器停机。为什么？如果您还记得，当我们向集群中添加一台新机器db5时，我们需要重新平衡db4和db5之间的分区，对吗？这需要将键的子集从db4移动到db5。如果子集很大，可能会使db4负担过重，导致失败。</p><p id="24a3" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jh iv iw ix ji iz ja jb jj jd je jf jg hb bi translated">如何克服这一点？智能和简单，我们可以引入许多虚拟节点(在下图中显示为黄色),这些虚拟节点代表实际的数据库并分布在不同的部分。它们不是真正的机器，只是为了在集群中均匀分布数据。</p><p id="b92c" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jh iv iw ix ji iz ja jb jj jd je jf jg hb bi translated">例如，在下图中，我们可以看到每个段中的数据分布在多个数据库中，即段1数据现在分布在db2和db1机器上，段2数据分布在db1、db2和db5上，依此类推。在重新平衡期间，即添加db5时，仅灰色标记的虚拟节点(即db3和db4)表示的数据需要进行数据迁移。因此，从技术上来说，我们没有给db4增加负担，而是在一小部分db3和db4机器之间分担迁移负载。随着虚拟节点数量的增加，这种重新平衡过程会变得更加高效。</p><figure class="jl jm jn jo fd jp er es paragraph-image"><div class="er es mi"><img src="../Images/6ff330a058f3f62a427dc6c280984415.png" data-original-src="https://miro.medium.com/v2/resize:fit:1224/format:webp/1*1aDQQoUsHP7KYLo_Aqt_rQ.png"/></div><figcaption class="js jt et er es ju jv bd b be z dx translated">一致散列虚拟节点</figcaption></figure><p id="4ad6" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jh iv iw ix ji iz ja jb jj jd je jf jg hb bi translated">本帖到此为止，感谢阅读。我们下次再见，在那之前保重，继续学习:)</p></div></div>    
</body>
</html>