<html>
<head>
<title>Check for number of available paths in an Obstacle Game board — JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">检查障碍游戏板中可用路径的数量— JavaScript</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/check-for-number-of-available-paths-in-an-obstaclegame-board-javascript-949680737258?source=collection_archive---------2-----------------------#2022-02-25">https://medium.com/nerd-for-tech/check-for-number-of-available-paths-in-an-obstaclegame-board-javascript-949680737258?source=collection_archive---------2-----------------------#2022-02-25</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="acf0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">嗨，伙计们，这些类型的问题在编码能力测试和其他类型的编程测试中非常流行。考虑一个场景，我们有一张带网格的纸，我们只允许某人进入标有“0”的单元格。如果你在途中发现“1”，那就是一个障碍。当这样做时，有各种各样的方法，但在这里我将讨论使用动态规划的最佳解决方案。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es jd"><img src="../Images/0c4a884cc1723f3cb34222504df6b832.png" data-original-src="https://miro.medium.com/v2/resize:fit:848/format:webp/1*RJ9hkfIjXhCyQaZw6SwjiQ.png"/></div><figcaption class="jl jm et er es jn jo bd b be z dx translated">游戏板</figcaption></figure><p id="8322" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这里我们应该考虑的事情如下:</p><ul class=""><li id="109c" class="jp jq hi ih b ii ij im in iq jr iu js iy jt jc ju jv jw jx bi translated">我们需要一步一步地到达网格右下角的单元格</li><li id="f96a" class="jp jq hi ih b ii jy im jz iq ka iu kb iy kc jc ju jv jw jx bi translated">我们每走一步都要做出选择，选择是:向右走还是向下走！</li><li id="d850" class="jp jq hi ih b ii jy im jz iq ka iu kb iy kc jc ju jv jw jx bi translated">在这条路上有些地方我们踩不到</li><li id="1404" class="jp jq hi ih b ii jy im jz iq ka iu kb iy kc jc ju jv jw jx bi translated">我们需要知道有多少种独特的方式可以到达终点！</li></ul><p id="79d9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">所以我们将使用如下方法，</p><ul class=""><li id="dfa5" class="jp jq hi ih b ii ij im in iq jr iu js iy jt jc ju jv jw jx bi translated">开始逐行遍历给定的游戏棋盘 2D 矩阵，并填充其中的值。</li><li id="df8a" class="jp jq hi ih b ii jy im jz iq ka iu kb iy kc jc ju jv jw jx bi translated">对于第一行和第一列，如果没有发现障碍物，则将值设置为 1。</li><li id="8533" class="jp jq hi ih b ii jy im jz iq ka iu kb iy kc jc ju jv jw jx bi translated">对于第一行和第一列，如果发现障碍，则开始填充 0，直到该特定行或列中的最后一个索引。</li><li id="a48e" class="jp jq hi ih b ii jy im jz iq ka iu kb iy kc jc ju jv jw jx bi translated">现在从第二行第二列开始遍历(例如:board[ 1 ][ 1 ])。</li><li id="a078" class="jp jq hi ih b ii jy im jz iq ka iu kb iy kc jc ju jv jw jx bi translated">如果发现一个障碍，在特定的格子上设置 0(例如:棋盘[ i ][ j ])，否则在棋盘[ i ][ j ]上设置上下值之和。</li><li id="3c09" class="jp jq hi ih b ii jy im jz iq ka iu kb iy kc jc ju jv jw jx bi translated">返回 2D 矩阵的最后一个值。</li></ul><p id="5e60" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">该解决方案的 JavaScript 代码如下。</p><pre class="je jf jg jh fd kd ke kf kg aw kh bi"><span id="e618" class="ki kj hi ke b fi kk kl l km kn">function uniquePathsWithObstacles(board) {<br/>    let r = board.length;<br/>    let c = board[0].length;<br/><br/>    if (board[0][0] != 0) return 0;<br/><br/>    board[0][0] = 1;<br/><br/>    for (let j = 1; j &lt; c; j++) {<br/>        if (board[0][j] == 0) {<br/>            board[0][j] = board[0][j - 1];<br/>        } else {<br/>            board[0][j] = 0;<br/>        }<br/>    }<br/><br/>    for (let i = 1; i &lt; r; i++) {<br/>        if (board[i][0] == 0) {<br/>            board[i][0] = board[i - 1][0];<br/>        } else {<br/>            board[i][0] = 0;<br/>        }<br/>    }<br/><br/>    for (let i = 1; i &lt; r; i++) {<br/>        for (let j = 1; j &lt; c; j++) {<br/>            if (board[i][j] == 0) {<br/>                board[i][j] = board[i - 1][j] + board[i][j - 1];<br/>            } else {<br/>                board[i][j] = 0;<br/>            }<br/>        }<br/>    }<br/><br/><br/>    return board[r-1][c-1];<br/>}<br/><br/><br/>let <strong class="ke hj"><em class="ko">board </em></strong>= [[0, 0, 0], [0, 1, 0], [0, 1, 0]];<br/><br/><strong class="ke hj"><em class="ko">console</em></strong>.log(uniquePathsWithObstacles(<strong class="ke hj"><em class="ko">board</em></strong>));</span></pre><p id="ab39" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">将该文件保存为 game-board.js，然后使用以下命令运行该程序。</p><pre class="je jf jg jh fd kd ke kf kg aw kh bi"><span id="db13" class="ki kj hi ke b fi kk kl l km kn">node game-<strong class="ke hj"><em class="ko">board</em></strong>.js</span></pre><p id="72a0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">快乐的编码伙计们！！！</p></div></div>    
</body>
</html>