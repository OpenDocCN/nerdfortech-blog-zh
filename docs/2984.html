<html>
<head>
<title>Reverse Polish Notation — Daily Challenge May</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">反向波兰符号—每日挑战五月</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/reverse-polish-notation-daily-challenge-may-f0ddadc67b5f?source=collection_archive---------28-----------------------#2021-05-25">https://medium.com/nerd-for-tech/reverse-polish-notation-daily-challenge-may-f0ddadc67b5f?source=collection_archive---------28-----------------------#2021-05-25</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><figure class="hh hi ez fb hj hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es hg"><img src="../Images/ba59d93a830e7e051aff3dc646ff8492.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iwiyKRb2obAnl7py5tYP2g.jpeg"/></div></div><figcaption class="hr hs et er es ht hu bd b be z dx translated">照片由<a class="ae hv" href="https://unsplash.com/@michalmatlon?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">米哈尔·马特隆</a>在<a class="ae hv" href="https://unsplash.com/s/photos/math?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><div class=""/><p id="3f2c" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">今天的问题来自每日Leetcode编码挑战赛——五月版。这是一个中等标签的问题。让我们看看问题陈述。</p><h2 id="7a91" class="jt ju hy bd jv jw jx jy jz ka kb kc kd jg ke kf kg jk kh ki kj jo kk kl km kn bi translated"><a class="ae hv" href="https://leetcode.com/problems/evaluate-reverse-polish-notation/" rel="noopener ugc nofollow" target="_blank"> 150 </a>。评估反向波兰符号</h2><p id="c21c" class="pw-post-body-paragraph iv iw hy ix b iy ko ja jb jc kp je jf jg kq ji jj jk kr jm jn jo ks jq jr js hb bi translated">评估<a class="ae hv" href="http://en.wikipedia.org/wiki/Reverse_Polish_notation" rel="noopener ugc nofollow" target="_blank">反向波兰符号</a>中算术表达式的值。</p><p id="b2f7" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">有效的运算符有<code class="du kt ku kv kw b">+</code>、<code class="du kt ku kv kw b">-</code>、<code class="du kt ku kv kw b">*</code>和<code class="du kt ku kv kw b">/</code>。每个操作数可以是整数或其他表达式。</p><p id="1101" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hz">注意</strong>两个整数之间的除法应该向零截断。</p><h2 id="1415" class="jt ju hy bd jv jw jx jy jz ka kb kc kd jg ke kf kg jk kh ki kj jo kk kl km kn bi translated">示例:</h2><pre class="kx ky kz la fd lb kw lc ld aw le bi"><span id="1505" class="jt ju hy kw b fi lf lg l lh li"><strong class="kw hz">Input:</strong> tokens = ["2","1","+","3","*"]<br/><strong class="kw hz">Output:</strong> 9<br/><strong class="kw hz">Explanation:</strong> ((2 + 1) * 3) = 9</span></pre><h2 id="1edc" class="jt ju hy bd jv jw jx jy jz ka kb kc kd jg ke kf kg jk kh ki kj jo kk kl km kn bi translated">理解问题:</h2><p id="e408" class="pw-post-body-paragraph iv iw hy ix b iy ko ja jb jc kp je jf jg kq ji jj jk kr jm jn jo ks jq jr js hb bi translated">从上面的例子中，我们了解到，每当我们遇到一个操作符时，最后两个元素就变成了操作数。同样，一旦我们计算出结果，这个值就成为最后一个操作数。为了跟踪操作数和计算结果，我们可以使用堆栈并将操作数保存在其中。当我们在列表中看到一个操作符时，我们弹出最后两个元素并执行所需的操作。我们还将结果放回堆栈中。</p><figure class="kx ky kz la fd hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es lj"><img src="../Images/3a373ee601f81b5ced642a7cb5d0103d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3aVnby8t81UjyPciZQtT6Q.png"/></div></div></figure><h2 id="c923" class="jt ju hy bd jv jw jx jy jz ka kb kc kd jg ke kf kg jk kh ki kj jo kk kl km kn bi translated">代码实现:</h2><pre class="kx ky kz la fd lb kw lc ld aw le bi"><span id="afde" class="jt ju hy kw b fi lf lg l lh li">def evalRPN(tokens):<br/>    stack = []<br/>    for token in tokens:<br/>        if token in '/+-*':<br/>            op1 = stack.pop()<br/>            op2 = stack.pop()<br/>            if token == '/':<br/>                val = op2 / op1<br/>            elif token == '+':<br/>                val = op2 + op1<br/>            elif token == '-':<br/>                val = op2 - op1<br/>            elif token == '*':<br/>                val = op2 * op1<br/>            stack.append(int(val))<br/>        else:<br/>            stack.append(int(token))<br/>    return stack[0]</span></pre><h2 id="dcd0" class="jt ju hy bd jv jw jx jy jz ka kb kc kd jg ke kf kg jk kh ki kj jo kk kl km kn bi translated">复杂性分析:</h2><p id="fc62" class="pw-post-body-paragraph iv iw hy ix b iy ko ja jb jc kp je jf jg kq ji jj jk kr jm jn jo ks jq jr js hb bi translated"><strong class="ix hz">时间复杂度:</strong> O(N)，我们对给定的数组做一次遍历。</p><p id="71ff" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hz">空间复杂度:</strong> O(N)我们使用堆栈来存储操作数。</p><p id="4d14" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">编码快乐！！</p></div></div>    
</body>
</html>