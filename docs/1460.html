<html>
<head>
<title>Caching in Express App</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Express应用程序中的缓存</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/caching-in-express-app-ada148fa7a70?source=collection_archive---------10-----------------------#2021-03-20">https://medium.com/nerd-for-tech/caching-in-express-app-ada148fa7a70?source=collection_archive---------10-----------------------#2021-03-20</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/0d07d9a68d6306fca8212fb3bb7827ac.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*B5_TsLDxfHhy4N0O"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">玛利亚·博布罗娃在<a class="ae iu" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><p id="7202" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">你有没有觉得你应该更快，性能更好，但你不能控制的东西，对不对？但是，如果您将数据处理从终端移除，肯定会节省您的时间。缓存作为一种拯救来了，你可以将数据存储在ram中，只要需要，它就会迅速出现，原因很简单，缓存是从RAM而不是从磁盘存储器提供的。但问题是，我们应该缓存所有东西吗？让我们详细讨论一下这个事情。</p><h2 id="fb9c" class="jt ju hi bd jv jw jx jy jz ka kb kc kd jg ke kf kg jk kh ki kj jo kk kl km kn bi translated">什么是缓存？</h2><p id="17a3" class="pw-post-body-paragraph iv iw hi ix b iy ko ja jb jc kp je jf jg kq ji jj jk kr jm jn jo ks jq jr js hb bi translated">每当我们将任何数据集/数据库用于任何类型的应用程序时，它都会从磁盘内存和使用内部排序机制(称为索引)中获得更快的响应时间，但可能会出现数据量变得巨大且磁盘处理将花费一些时间的情况。那么作为一个软件人员，我们应该推荐缓存作为解决方案之一，它将数据存储在RAM中，并在需要时从那里而不是从磁盘提供服务。这是这个概念的直观表示。</p><figure class="ku kv kw kx fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es kt"><img src="../Images/79de7a5433c4c4678fd8791126656236.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iyHDq6KuoWlF_1MdvvjixQ.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">缓存架构</figcaption></figure><h2 id="bd46" class="jt ju hi bd jv jw jx jy jz ka kb kc kd jg ke kf kg jk kh ki kj jo kk kl km kn bi translated">用在哪里？</h2><p id="67c9" class="pw-post-body-paragraph iv iw hi ix b iy ko ja jb jc kp je jf jg kq ji jj jk kr jm jn jo ks jq jr js hb bi translated">这取决于用例，但是大多数缓存都是通过静态数据或用户间的相同数据进行的。个性化内容不喜欢存储在缓存机制中，因为它会在每次请求时改变。</p><h2 id="261e" class="jt ju hi bd jv jw jx jy jz ka kb kc kd jg ke kf kg jk kh ki kj jo kk kl km kn bi translated">怎么用？</h2><p id="2fa8" class="pw-post-body-paragraph iv iw hi ix b iy ko ja jb jc kp je jf jg kq ji jj jk kr jm jn jo ks jq jr js hb bi translated">我使用节点来演示缓存流以及<em class="ky"> Redis </em>，还有其他几个选项，如<em class="ky"> Memcached </em>、<em class="ky"> Mongo、</em>或任何键值对数据集等等。我将使用这个<a class="ae iu" href="https://github.com/Piyush-Use-Personal/Role-Based-Access" rel="noopener ugc nofollow" target="_blank">回购</a>作为开始，您可以像专家一样切换分支进入我上一篇关于<a class="ae iu" href="https://piyush-d-11623.medium.com/role-based-access-like-a-pro-eb8f1207ca29" rel="noopener">基于角色的访问的文章。文章的完整代码可以在同一个repo的分支</a><a class="ae iu" href="https://github.com/Piyush-Use-Personal/Role-Based-Access/tree/caching" rel="noopener ugc nofollow" target="_blank">缓存</a>中找到。可以通过运行<strong class="ix hj"><em class="ky">NPM run dev/node index</em></strong>打开服务器。</p><p id="d44f" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">为了给你演示这个功能，我创建了一个名为<strong class="ix hj"> MockDatabase </strong>的类，每当我们调用这个类的get方法时，它会在3秒钟内给我们一些数据</p><figure class="ku kv kw kx fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es kz"><img src="../Images/d955e33a10de5d0947c9e8b4004a15a1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*r0zlartdDDMRsX59qSYEeQ.png"/></div></div></figure><p id="b286" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这是我们正在使用的模拟类的代码，这将有助于我们维护基础中的奇点。<em class="ky"> get </em>方法将为我们提供数据，而<em class="ky"> wait </em>方法将让我们在这里创建我们想要的延迟。</p><p id="1fb1" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">接下来，我们将更新路线，我为本文的目的创建了两条路线<em class="ky">/带缓存</em>和<em class="ky">/不带缓存</em>，这将帮助我们了解每条路线的时间延迟。</p><figure class="ku kv kw kx fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es kz"><img src="../Images/3f774190d44ca84332e1dba834585903.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nnB2vrDhPc9Y1CfflXcJfw.png"/></div></div></figure><p id="9df0" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">不要担心，你会在文章的顶部和底部找到带有回购链接的完整源代码。</p><p id="669d" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">现在，更新路由的控制器以调用我们之前创建的DB来获取。</p><p id="451a" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们现在对这两个函数调用完全相同的代码。</p><figure class="ku kv kw kx fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es kz"><img src="../Images/7243f1bf25ca6b9c1fdf562b73b9cf00.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Yce0kJPYa5Cq5G-Lap70kw.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">路线的控制器功能</figcaption></figure><p id="0f89" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">现在，如果您移动到任何路线，您将看到以下结果，但有3秒钟的延迟。</p><figure class="ku kv kw kx fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es la"><img src="../Images/a291c17af8cb011ad00d539265c7ed87.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZmjsD2NUe1UTIAPMFu-acQ.png"/></div></div></figure><p id="193e" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">注意用红框突出显示的区域，你可以看到延迟。</p><p id="47ec" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">现在，我们将在小应用程序中集成缓存。我们将使用<a class="ae iu" href="https://www.npmjs.com/package/redis" rel="noopener ugc nofollow" target="_blank"> Redis </a>包来缓存我们的数据。</p><p id="7390" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">首先，您需要下载Redis并在本地安装它，要在本地安装Redis包中使用它，请编写命令<strong class="ix hj"> <em class="ky"> npm i redis </em> </strong></p><p id="6200" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">并像这样用缓存控制器更新它们，</p><figure class="ku kv kw kx fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es kz"><img src="../Images/03d56f67a25709f404047ef9d0ddd9de.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Pq-l3QdSvcztjDWm1Zx-RA.png"/></div></div></figure><p id="3ddd" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">不要忘记导入顶部的Redis。</p><p id="59d6" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在代码片段中，如果你看到，我们显然是在为我在文章开头使用的图表编写代码。首先，我们检查Redis是否有数据，如果有，就直接发送给客户端，如果没有，就调用数据库并存储它，然后用我们用来获取数据的同一密钥将数据发送给客户端。注意- Redis不存储直接对象，首先我们需要将它字符串化或者使它成为缓冲区，如果你想做一些处理，你可以使用JSON parse使它再次成为JSON。</p><p id="ff50" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">一旦你这样做了，当你刷新服务器并再次点击请求时，你将再次看到变化。</p><p id="5018" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">也就是说，我们将在这里结束，你可以在这个<a class="ae iu" href="https://github.com/Piyush-Use-Personal/Role-Based-Access/tree/caching" rel="noopener ugc nofollow" target="_blank">分支</a>找到完整的源代码。希望你们喜欢这篇文章并获得一些知识，保重。</p></div></div>    
</body>
</html>