<html>
<head>
<title>Spring Boot Annotations</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Spring Boot 注解</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/spring-boot-annotations-cb2487304062?source=collection_archive---------3-----------------------#2021-04-04">https://medium.com/nerd-for-tech/spring-boot-annotations-cb2487304062?source=collection_archive---------3-----------------------#2021-04-04</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/d4479c91eb7d114b37c3fc94aacb551c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ajoMpPPmBrHul59YDR5Nrg.png"/></div></div></figure><p id="d25d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">注释使得在 spring 中配置依赖注入和定义/管理 beans 变得更加容易。</p><p id="c4c1" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">org . Spring framework . context . application context 接口代表 Spring IoC 容器，负责实例化、配置和组装 beans</p><p id="890c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">Spring Boots<strong class="is hj">Spring application</strong>类用于从 Java main 方法引导和启动 Spring 应用程序。该类从类路径自动创建 ApplicationContext，扫描配置类并启动应用程序。</p><p id="2306" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">@ spring foot application</strong></p><p id="2329" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">从 Spring Boot 1.2.0 开始，我们可以使用这个注释，它和声明@Configuration、@EnableAutoConfiguration、@ComponentScan 是一样的。</p><pre class="jo jp jq jr fd js jt ju jv aw jw bi"><span id="e358" class="jx jy hi jt b fi jz ka l kb kc">import org.springframework.boot.SpringApplication;<br/>import org.springframework.boot.autoconfigure.SpringBootApplication;</span><span id="2a6f" class="jx jy hi jt b fi kd ka l kb kc">@SpringBootApplication // same as @Configuration, //@EnableAutoConfiguration, and @ComponentScan<br/>public class Application {</span><span id="10d7" class="jx jy hi jt b fi kd ka l kb kc">    public static void main(String[] args) {          </span><span id="97ab" class="jx jy hi jt b fi kd ka l kb kc">        SpringApplication.run(Application.class, args);<br/>    <br/>    }</span><span id="4dec" class="jx jy hi jt b fi kd ka l kb kc">}</span></pre><p id="2053" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">@配置</strong></p><p id="2b64" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">从 spring 2 开始，我们一直将 bean 配置写入 xml 文件。但是 Spring 3+提供了将 bean 定义移出 xml 文件的自由。</p><p id="7491" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在任何类的顶部使用@Configuration 来声明该类提供了一个或多个@bean 方法，并将由 Spring 容器处理，以便在运行时为这些 Bean 生成 Bean 定义和服务请求。</p><p id="a7f8" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">@启用自动配置</strong></p><p id="3537" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">@EnableAutoConfiguration 注释使 Spring Boot 能够自动配置应用程序上下文。因此，它会根据类路径中包含的 jar 文件和我们定义的 bean 自动创建和注册 bean。</p><p id="fba6" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">当我们在 classpath/pom 中定义 spring-boot-starter-web 依赖时，Spring boot 会自动配置 Tomcat 和 Spring MVC。但是，在我们定义自己的配置时，这种自动配置的优先级较低。</p><p id="9056" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj"> @ComponentScan </strong></p><p id="aa40" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这用于自动挑选所有 Spring 组件(@Component、@Controller、@Service、@Repository)，包括@Configuration 类作为 beans。</p><p id="f640" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">@自动连线</strong></p><p id="3e8f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">用于将 spring bean 管理器中的对象依赖注入到使用该注释的类中。</p><pre class="jo jp jq jr fd js jt ju jv aw jw bi"><span id="9947" class="jx jy hi jt b fi jz ka l kb kc">@Controller // Defines that this class is a spring bean<br/>@RequestMapping(“/admin”)</span><span id="a8e0" class="jx jy hi jt b fi kd ka l kb kc">public class ExampleController {</span><span id="b910" class="jx jy hi jt b fi kd ka l kb kc">    //Tells the application context to inject an instance of     <br/>    AdminService here</span><span id="d43a" class="jx jy hi jt b fi kd ka l kb kc">    @Autowired<br/>    private AdminService adminService;</span><span id="c1ae" class="jx jy hi jt b fi kd ka l kb kc">    @RequestMapping(“/login”)<br/>    public void login(@RequestParam(“name”) String name,<br/>          @RequestParam(“password”) String password) {</span><span id="fe87" class="jx jy hi jt b fi kd ka l kb kc">      //The AdminService is already injected and you can use it</span><span id="3fb6" class="jx jy hi jt b fi kd ka l kb kc">         adminService.login(name, password); </span><span id="11d1" class="jx jy hi jt b fi kd ka l kb kc">   }</span><span id="b8ca" class="jx jy hi jt b fi kd ka l kb kc">}</span></pre><p id="e2af" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">@Autowired 用于注入 AdminService bean 依赖项。如果这不是 Spring，而是一个普通的 Java 应用程序，那么我们必须使用 new 运算符创建 AdminService 对象:</p><p id="859b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">AdminService AdminService = new AdminService()；</p><p id="007c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这种用法使对象的管理变得重复和复杂，因为 AdminService 本身可以处理其他对象，这对于主要关注业务逻辑的应用程序来说变得难以管理。</p><p id="3404" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">@组件</strong></p><p id="89bf" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">用@Component 标记类使得它有资格在 SpringApplicationContext 中被扫描和配置为 Spring Bean。</p><p id="39c7" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">下面是组件接口的源代码:</p><pre class="jo jp jq jr fd js jt ju jv aw jw bi"><span id="5e55" class="jx jy hi jt b fi jz ka l kb kc">@Target(ElementType.TYPE)<br/>@Retention(RetentionPolicy.RUNTIME)<br/>@Documented<br/>public @interface Component {<br/>}</span></pre><p id="f8d3" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj"> @Bean </strong></p><p id="4d37" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这也用于将类配置为 Bean。然而，它不同于@Component。</p><ol class=""><li id="61f1" class="ke kf hi is b it iu ix iy jb kg jf kh jj ki jn kj kk kl km bi translated">组件是类级别的注释，而 Bean 是方法级别的注释。</li><li id="234b" class="ke kf hi is b it kn ix ko jb kp jf kq jj kr jn kj kk kl km bi translated">@Bean 必须在一个类中使用，并且该类应该用@Configuration 标记。</li><li id="4914" class="ke kf hi is b it kn ix ko jb kp jf kq jj kr jn kj kk kl km bi translated">如果类在 Spring 容器之外，我们不能从@Component 创建 bean，但是我们可以从任何地方从@bean 创建 Bean。</li></ol><p id="db27" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj"> <em class="ks">我们在哪里用@Bean 代替@Component？</em>T3】</strong></p><p id="7223" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">当您想要将一个类配置为来自第三方库的 bean，而该库的代码不在您身边时。在这种情况下，您没有在类中使用@Component 的自由，因为您没有代码。</p><pre class="jo jp jq jr fd js jt ju jv aw jw bi"><span id="8e81" class="jx jy hi jt b fi jz ka l kb kc">@Configuration<br/>public class App {</span><span id="9653" class="jx jy hi jt b fi kd ka l kb kc">  @Bean<br/>  public TestService testService() {</span><span id="174d" class="jx jy hi jt b fi kd ka l kb kc">    return new TestService();</span><span id="074f" class="jx jy hi jt b fi kd ka l kb kc">  }</span><span id="537f" class="jx jy hi jt b fi kd ka l kb kc">}</span></pre><p id="1a58" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这将执行该方法，并将返回值注册为 SpringContext 中的 bean，方法名为 Bean 名，即 testService</p><p id="82d5" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">@控制器</strong></p><p id="622f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">通过使用这个注释，我们做了两件事，首先，我们声明这个类是一个 Spring bean，应该由 SpringApplicationContext 创建和维护，其次，它表明它是 MVC 设置中的一个控制器。</p><blockquote class="kt ku kv"><p id="8d1c" class="iq ir ks is b it iu iv iw ix iy iz ja kw jc jd je kx jg jh ji ky jk jl jm jn hb bi translated">@Controller 是一个@组件(就像@Service、@Repository、@Endpoint 等。)</p></blockquote><p id="34e1" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">以下是控制器界面的源代码:</p><pre class="jo jp jq jr fd js jt ju jv aw jw bi"><span id="6133" class="jx jy hi jt b fi jz ka l kb kc">@Target({ElementType.TYPE})<br/>@Retention(RetentionPolicy.RUNTIME)<br/>@Documented<br/>@Component<br/>public @interface Controller {</span><span id="06a6" class="jx jy hi jt b fi kd ka l kb kc">}</span></pre><p id="b05d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">当发出请求时，该注释告诉 dispatcher servlet 在标有@Controller 的组件中寻找所需的端点请求路径。</p><p id="b8e9" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">@服务</strong></p><p id="1eed" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在服务层注释类。服务层保存从控制器层调用的业务逻辑。</p><p id="1fcf" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">@仓库</strong></p><p id="5338" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在持久层注释类，持久层将充当数据库存储库。它使 beans 有资格进行持久性异常转换——这意味着将低级别的 ORM 异常转换为通用异常，由 Spring 管理和处理，而不是像 Hibernate、JDBC 这样的 O/R 映射工具。</p><p id="bbf8" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">@Controller @Serivce 和@Repository 不能被@Component 替代，因为它有自己的特定角色，为开发人员提供了每个类角色的清晰思路，并且 SpringBoot 团队很容易对其进行更改以获得更多功能。</p></div><div class="ab cl kz la gp lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="hb hc hd he hf"><p id="da11" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如有任何疑问或自由职业工作，请联系我。<a class="ae lg" href="https://www.linkedin.com/in/vivek-singh-a109b511a/" rel="noopener ugc nofollow" target="_blank">领英</a>。或者发邮件给我，地址是<a class="ae lg" href="mailto:vivek.sinless@gmail.com" rel="noopener ugc nofollow" target="_blank">vivek.sinless@gmail.com</a></p><p id="ec5f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">快乐学习！干杯。</p></div></div>    
</body>
</html>