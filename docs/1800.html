<html>
<head>
<title>Explore Coding Question: Minimum Depth of Binary Tree</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">探究编码问题:二叉树的最小深度</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/explore-coding-question-minimum-depth-of-binary-tree-2069d0ed2e1a?source=collection_archive---------7-----------------------#2021-04-07">https://medium.com/nerd-for-tech/explore-coding-question-minimum-depth-of-binary-tree-2069d0ed2e1a?source=collection_archive---------7-----------------------#2021-04-07</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="38af" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">这是Leetcode中的一个简单问题。我们将使用广度优先遍历来解决这个问题。</h2></div><p id="40ff" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">(免责声明:代码将以Javascript编写。)</p><figure class="ju jv jw jx fd jy er es paragraph-image"><div class="er es jt"><img src="../Images/13624145f2b2c3fa68844dfc07cfcb61.png" data-original-src="https://miro.medium.com/v2/resize:fit:938/format:webp/0*N8nvfzEUmOWOoyEX.jpg"/></div><figcaption class="kb kc et er es kd ke bd b be z dx translated">有关联。信用:<a class="ae kf" href="https://www.google.com/url?sa=i&amp;url=https%3A%2F%2Fmemegenerator.net%2Finstance%2F53436530%2Fspiderman-desk-while-everyone-else-is-partying-and-sleeping-im-sitting-here-studying-binary-search-t&amp;psig=AOvVaw1wzWkaAw-LTYe37IkYuT2m&amp;ust=1617856110777000&amp;source=images&amp;cd=vfe&amp;ved=0CAMQjB1qFwoTCMjmue2l6-8CFQAAAAAdAAAAABAh" rel="noopener ugc nofollow" target="_blank">模因发生器</a></figcaption></figure><p id="676d" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">你好。在本文中，我们将探讨“二叉树的<a class="ae kf" href="https://leetcode.com/problems/minimum-depth-of-binary-tree/" rel="noopener ugc nofollow" target="_blank">最小深度</a>的问题。这个问题不像中等水平的问题那么流行，比如“<a class="ae kf" href="https://leetcode.com/problems/binary-tree-level-order-traversal/" rel="noopener ugc nofollow" target="_blank">二叉树水平顺序遍历</a>”。但是！这个问题是一个很好的方法来介绍一个常见的主题:使用广度优先搜索(BFS)遍历二叉树(注意:我知道这不是最优化的解决方案。与使用BFS相比，递归具有更快的时间复杂度)。</p><figure class="ju jv jw jx fd jy er es paragraph-image"><div class="er es kg"><img src="../Images/043168b12d13cb1e6ceff9dfa1fbc268.png" data-original-src="https://miro.medium.com/v2/resize:fit:906/format:webp/1*29szsjJUFWcXv-U5tdoUIQ.png"/></div><figcaption class="kb kc et er es kd ke bd b be z dx translated">曾询问英国电信“最小深度”的公司</figcaption></figure><p id="20c5" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">对抗</p><figure class="ju jv jw jx fd jy er es paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="er es kh"><img src="../Images/a986ed541f4052e6f13d86e647f5f32f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1296/format:webp/1*Lq0wB3oR6165Il4O6m1WvA.png"/></div></div><figcaption class="kb kc et er es kd ke bd b be z dx translated">公司已要求BT水平顺序遍历… Wow🥲</figcaption></figure><p id="dcd6" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在我们开始之前，我想澄清一下，BFS是水平的，而DFS(深度优先搜索，在本例中是遍历)是垂直的。</p><figure class="ju jv jw jx fd jy er es paragraph-image"><div class="er es km"><img src="../Images/48d06f75a9fbbe02deaacaf2e4009385.png" data-original-src="https://miro.medium.com/v2/resize:fit:730/format:webp/0*KY_s6d9I_Q72lEq4.png"/></div><figcaption class="kb kc et er es kd ke bd b be z dx translated">信用:<a class="ae kf" href="https://www.geeksforgeeks.org/level-order-tree-traversal/" rel="noopener ugc nofollow" target="_blank">极客暴富</a></figcaption></figure><p id="f535" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">上述树的层次顺序遍历为1👉🏻2👉🏻3👉🏻四👉🏻 5;</p><p id="eee6" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">对于DFS，这取决于:</p><ul class=""><li id="453c" class="kn ko hi iz b ja jb jd je jg kp jk kq jo kr js ks kt ku kv bi translated">其他(左、根、根):4👉🏻2👉🏻5👉🏻一👉🏻 3;</li><li id="7649" class="kn ko hi iz b ja kw jd kx jg ky jk kz jo la js ks kt ku kv bi translated">预定(根、左、右):1👉🏻2👉🏻四👉🏻5👉🏻 3;</li><li id="cf6f" class="kn ko hi iz b ja kw jd kx jg ky jk kz jo la js ks kt ku kv bi translated">Postorder(左、右、根):4👉🏻5👉🏻2👉🏻3👉🏻一</li></ul><p id="f584" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">对于这个问题，我们将使用BFS —广度优先遍历来获得我们的结果。二话没说，让我们开始吧！</p></div><div class="ab cl lb lc gp ld" role="separator"><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg"/></div><div class="hb hc hd he hf"><h1 id="265b" class="li lj hi bd lk ll lm ln lo lp lq lr ls io lt ip lu ir lv is lw iu lx iv ly lz bi translated">目录</h1><ul class=""><li id="aee5" class="kn ko hi iz b ja ma jd mb jg mc jk md jo me js ks kt ku kv bi translated"><a class="ae kf" href="#6f1f" rel="noopener ugc nofollow"> <strong class="iz hj">提问</strong> </a></li><li id="e753" class="kn ko hi iz b ja kw jd kx jg ky jk kz jo la js ks kt ku kv bi translated"><a class="ae kf" href="#5d74" rel="noopener ugc nofollow"> <strong class="iz hj">解</strong> </a></li><li id="8e3b" class="kn ko hi iz b ja kw jd kx jg ky jk kz jo la js ks kt ku kv bi translated"><a class="ae kf" href="#78e9" rel="noopener ugc nofollow"> <strong class="iz hj">故障</strong> </a></li><li id="4a08" class="kn ko hi iz b ja kw jd kx jg ky jk kz jo la js ks kt ku kv bi translated"><a class="ae kf" href="#cdfe" rel="noopener ugc nofollow"> <strong class="iz hj">时间&amp;空间复杂度</strong> </a></li><li id="76e3" class="kn ko hi iz b ja kw jd kx jg ky jk kz jo la js ks kt ku kv bi translated"><a class="ae kf" href="#219e" rel="noopener ugc nofollow">类似问题:二叉树最大深度 </a></li><li id="c228" class="kn ko hi iz b ja kw jd kx jg ky jk kz jo la js ks kt ku kv bi translated"><a class="ae kf" href="#f322" rel="noopener ugc nofollow">结论 </a></li></ul></div><div class="ab cl lb lc gp ld" role="separator"><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg"/></div><div class="hb hc hd he hf"><h2 id="6f1f" class="mf lj hi bd lk mg mh mi lo mj mk ml ls jg mm mn lu jk mo mp lw jo mq mr ly ms bi translated">问题</h2><pre class="ju jv jw jx fd mt mu mv mw aw mx bi"><span id="7949" class="mf lj hi mu b fi my mz l na nb">Given a binary tree, find its minimum depth.</span><span id="45a7" class="mf lj hi mu b fi nc mz l na nb">The minimum depth is the number of nodes along the shortest path from the root node down to the nearest leaf node.</span><span id="140a" class="mf lj hi mu b fi nc mz l na nb"><strong class="mu hj">Note:</strong> A leaf is a node with no children.</span></pre><p id="8bc5" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="iz hj">例1 </strong></p><figure class="ju jv jw jx fd jy er es paragraph-image"><div class="er es nd"><img src="../Images/ab6fe090091c928325357bc8a07a7701.png" data-original-src="https://miro.medium.com/v2/resize:fit:864/format:webp/0*QNgolYQllPclwdEW.jpg"/></div><figcaption class="kb kc et er es kd ke bd b be z dx translated">信用:<a class="ae kf" href="https://leetcode.com/problems/minimum-depth-of-binary-tree/" rel="noopener ugc nofollow" target="_blank"> Leetcode </a></figcaption></figure><pre class="ju jv jw jx fd mt mu mv mw aw mx bi"><span id="fa9e" class="mf lj hi mu b fi my mz l na nb"><strong class="mu hj">Input:</strong> root = [3,9,20,null,null,15,7]<br/><strong class="mu hj">Output:</strong> 2</span></pre><p id="faba" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="iz hj">例2 </strong></p><figure class="ju jv jw jx fd jy er es paragraph-image"><div class="er es ne"><img src="../Images/5dbc238a14a11d732f214e32fd582dc6.png" data-original-src="https://miro.medium.com/v2/resize:fit:600/format:webp/1*Folp5mQAdmBb7Mumz7UBUA.png"/></div></figure><pre class="ju jv jw jx fd mt mu mv mw aw mx bi"><span id="c8a0" class="mf lj hi mu b fi my mz l na nb"><strong class="mu hj">Input:</strong> root = [2,null,3,null,4,null,5,null,6]<br/><strong class="mu hj">Output:</strong> 5</span></pre><p id="00d7" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">树节点的定义</p><pre class="ju jv jw jx fd mt mu mv mw aw mx bi"><span id="d283" class="mf lj hi mu b fi my mz l na nb">/**<br/> * Definition for a binary tree node.<br/> * function TreeNode(val, left, right) {<br/> *     this.val = (val===undefined ? 0 : val)<br/> *     this.left = (left===undefined ? null : left)<br/> *     this.right = (right===undefined ? null : right)<br/> * }<br/> */</span></pre></div><div class="ab cl lb lc gp ld" role="separator"><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg"/></div><div class="hb hc hd he hf"><h2 id="5d74" class="mf lj hi bd lk mg mh mi lo mj mk ml ls jg mm mn lu jk mo mp lw jo mq mr ly ms bi translated">先解决问题，再解决问题</h2><figure class="ju jv jw jx fd jy er es paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="er es nf"><img src="../Images/b435531fd8ae9d4ed4f331fe003110df.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*upPVcYtdvHqQ4_kjwkVJmQ.png"/></div></div></figure><p id="3b13" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">✋🏻在我们深入分析故障之前，请花点时间阅读解决方案。</p></div><div class="ab cl lb lc gp ld" role="separator"><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg"/></div><div class="hb hc hd he hf"><h2 id="78e9" class="mf lj hi bd lk mg mh mi lo mj mk ml ls jg mm mn lu jk mo mp lw jo mq mr ly ms bi translated">分解⤵️</h2><p id="0a3f" class="pw-post-body-paragraph ix iy hi iz b ja ma ij jc jd mb im jf jg ng ji jj jk nh jm jn jo ni jq jr js hb bi translated">本质上，我们想要做的是创建一个队列来存储树中的节点。随着我们一层一层地进行下去，当我们找到第一个叶节点(换句话说，没有子节点)时，我们最终想要返回二叉树的最小深度。</p><p id="bbf9" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="iz hj">下面是细目分类(连同示例1): </strong></p><pre class="ju jv jw jx fd mt mu mv mw aw mx bi"><span id="b8ed" class="mf lj hi mu b fi my mz l na nb">root = [3,9,20,null,null,15,7]</span></pre><ol class=""><li id="479a" class="kn ko hi iz b ja jb jd je jg kp jk kq jo kr js nj kt ku kv bi translated">我们将首先设置一个空数组<code class="du nk nl nm mu b">queue</code>来存储我们想要迭代的所有节点，作为变量<code class="du nk nl nm mu b">minDepth</code>来保持计数。</li></ol><pre class="ju jv jw jx fd mt mu mv mw aw mx bi"><span id="2243" class="mf lj hi mu b fi my mz l na nb">queue = []<br/>minDepth = 0</span></pre><p id="8ccf" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">2.我们还想确保长度数组<code class="du nk nl nm mu b">queue</code>大于0，这样我们可以继续迭代，同时继续推进子节点(如果存在的话)。</p><pre class="ju jv jw jx fd mt mu mv mw aw mx bi"><span id="eaad" class="mf lj hi mu b fi my mz l na nb">queue.push(root)<br/>queue = [3]</span></pre><p id="e089" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">3.每当我们开始<code class="du nk nl nm mu b">while</code>循环时，这意味着我们将一次迭代一个级别。我们会将<code class="du nk nl nm mu b">1</code>添加到变量<code class="du nk nl nm mu b">minDepth</code>中。</p><pre class="ju jv jw jx fd mt mu mv mw aw mx bi"><span id="7008" class="mf lj hi mu b fi my mz l na nb">minDepth = 1<br/>queue = [3]</span></pre><p id="a4fc" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">4.在<code class="du nk nl nm mu b">while</code>循环中，我们也想用<code class="du nk nl nm mu b">for</code>循环来循环通过关卡。我们还想确保设置一个新变量来跟踪当前<code class="du nk nl nm mu b">queue</code>的长度。然后，我们将获取队列的第一个元素，并检查它是否有子元素(左和右)。本质上我们想检查我们是否碰到了第一片叶子。如果我们这样做，我们将返回<code class="du nk nl nm mu b">minDepth</code>。</p><pre class="ju jv jw jx fd mt mu mv mw aw mx bi"><span id="ded7" class="mf lj hi mu b fi my mz l na nb">levelSize = queue.length // 1 <br/>let currentNode = queue.shift();<br/>// currentNode = 3 </span></pre><p id="172f" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">5.如果在左边或右边，或者两者都有子节点，这也意味着我们还没有碰到任何叶子，我们将会推入队列。</p><pre class="ju jv jw jx fd mt mu mv mw aw mx bi"><span id="81e6" class="mf lj hi mu b fi my mz l na nb">// check if currentNode has left or right children -- and yes, it does.<br/>queue = [9, 20]</span></pre><p id="41a9" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">6.我们将不断迭代，直到我们有一个返回值。</p><p id="948e" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">现在:</p><pre class="ju jv jw jx fd mt mu mv mw aw mx bi"><span id="b439" class="mf lj hi mu b fi my mz l na nb">queue = [9, 20]<br/>minDepth = 1</span></pre><p id="2d00" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">因为<code class="du nk nl nm mu b">queue</code>的长度大于0，所以<code class="du nk nl nm mu b">while</code>循环继续。</p><pre class="ju jv jw jx fd mt mu mv mw aw mx bi"><span id="b742" class="mf lj hi mu b fi my mz l na nb">minDepth++ // minDepth = 2<br/>levelSize = 2</span></pre><p id="56be" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">进入<code class="du nk nl nm mu b">for</code>循环以遍历该级别。</p><pre class="ju jv jw jx fd mt mu mv mw aw mx bi"><span id="ed87" class="mf lj hi mu b fi my mz l na nb">currentNode = 9 <br/>// root = [3,9,20,null,null,15,7]<br/>// check if there is any children...and there is not! -&gt; two nulls<br/>// 20 has two children: 15 on the left and 7 on the right.<br/>if (!currentNode.left &amp;&amp; !currentNode.right) // YES!<br/>   return minDepth; // 2</span></pre><p id="f7de" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">现在我们的返回值是<code class="du nk nl nm mu b">2</code>。</p><p id="55c8" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">就是这样！</p><p id="d5ff" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">哦，我差点忘了7号(顺便说一下，我最喜欢的数字)。</p><p id="d752" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">7.不要忘记边缘情况，如果是一棵空树，我们可以返回0。</p><pre class="ju jv jw jx fd mt mu mv mw aw mx bi"><span id="ae1c" class="mf lj hi mu b fi my mz l na nb">if (!root) return 0<br/>// or some people prefer: if (root === null) return 0</span></pre></div><div class="ab cl lb lc gp ld" role="separator"><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg"/></div><div class="hb hc hd he hf"><p id="8530" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这里的解决方案再次刷新你的记忆</p><figure class="ju jv jw jx fd jy er es paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="er es nf"><img src="../Images/b435531fd8ae9d4ed4f331fe003110df.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*upPVcYtdvHqQ4_kjwkVJmQ.png"/></div></div></figure></div><div class="ab cl lb lc gp ld" role="separator"><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg"/></div><div class="hb hc hd he hf"><h2 id="cdfe" class="mf lj hi bd lk mg mh mi lo mj mk ml ls jg mm mn lu jk mo mp lw jo mq mr ly ms bi translated">时间复杂度</h2><p id="5a9d" class="pw-post-body-paragraph ix iy hi iz b ja ma ij jc jd mb im jf jg ng ji jj jk nh jm jn jo ni jq jr js hb bi translated">最坏的情况是，我们不得不探索一个不平衡的树，我们不得不遍历整个树(参见示例2)。因为我们只迭代N/2个节点(逐层)，所以时间复杂度是O(N)。</p><h2 id="6a68" class="mf lj hi bd lk mg mh mi lo mj mk ml ls jg mm mn lu jk mo mp lw jo mq mr ly ms bi translated">空间复杂性</h2><p id="f714" class="pw-post-body-paragraph ix iy hi iz b ja ma ij jc jd mb im jf jg ng ji jj jk nh jm jn jo ni jq jr js hb bi translated">至于空间复杂度，我们正在创建一个数组来存储我们正在迭代的节点。在任何级别，我们最多可以有N/2个节点，我们需要O(N)空间来存储这些节点。</p></div><div class="ab cl lb lc gp ld" role="separator"><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg"/></div><div class="hb hc hd he hf"><h2 id="219e" class="mf lj hi bd lk mg mh mi lo mj mk ml ls jg mm mn lu jk mo mp lw jo mq mr ly ms bi translated">类似问题</h2><p id="9b24" class="pw-post-body-paragraph ix iy hi iz b ja ma ij jc jd mb im jf jg ng ji jj jk nh jm jn jo ni jq jr js hb bi translated">对于二叉树的最大深度<a class="ae kf" href="https://leetcode.com/problems/maximum-depth-of-binary-tree/" rel="noopener ugc nofollow" target="_blank">，我们也有类似的解决方案。当我们找到一个叶节点时，我们不是返回<code class="du nk nl nm mu b">minDepth</code>，而是遍历整个二叉树，以在每次完成一个级别时增加<code class="du nk nl nm mu b">maxDepth</code>。</a></p><p id="2e38" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">解决方案应该是这样的:</p><figure class="ju jv jw jx fd jy er es paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="er es nn"><img src="../Images/e30c3031dc155aab73d2190fe1b3808d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*J--Yrr6UpdrP3YEsJERmmg.png"/></div></div><figcaption class="kb kc et er es kd ke bd b be z dx translated">BFS溶液中BT最大深度的求解</figcaption></figure><p id="3dba" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">然而，正如本文开头提到的，递归是一个更好的解决方案，因为与使用BFS相比，它将只使用O(log N)时间，在这种情况下，它将继续消除树中不必要的部分，并继续将树切成两半，直到找到它的答案。</p><pre class="ju jv jw jx fd mt mu mv mw aw mx bi"><span id="d93e" class="mf lj hi mu b fi my mz l na nb">Recursion solution (which I would not go in depth):<br/>var maxDepth = function(root) {<br/>    if (!root) return 0;<br/>    return Math.max(maxDepth(root.left), maxDepth(root.right)) + 1;<br/>}</span></pre></div><div class="ab cl lb lc gp ld" role="separator"><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg"/></div><div class="hb hc hd he hf"><h2 id="f322" class="mf lj hi bd lk mg mh mi lo mj mk ml ls jg mm mn lu jk mo mp lw jo mq mr ly ms bi translated">结论:我的观察</h2><p id="995b" class="pw-post-body-paragraph ix iy hi iz b ja ma ij jc jd mb im jf jg ng ji jj jk nh jm jn jo ni jq jr js hb bi translated">当我做更多的BFS问题时，我实际上注意到大多数解都非常相似，除了你可能需要在循环中做一些修改，这样你才能得到答案。但是在大多数情况下，我注意到DFS(和递归)是比BFS更好的解决方案，特别是当你处理像<a class="ae kf" href="https://leetcode.com/problems/binary-tree-level-order-traversal/" rel="noopener ugc nofollow" target="_blank">二叉树层次顺序遍历</a>和<a class="ae kf" href="https://leetcode.com/problems/binary-tree-zigzag-level-order-traversal/" rel="noopener ugc nofollow" target="_blank">二叉树曲折层次顺序遍历</a>这样的问题时(希望能写另一篇关于这些问题的分解文章，比较BFS和DFS策略)。</p><p id="b77d" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">无论如何，你对广度优先遍历怎么看？希望你对这个话题感觉稍微舒服一点，不会吓到你！</p><p id="a291" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">祝你好运，解决越来越多的难题！最后但同样重要的是，感谢您成为一名出色的读者和快乐编码！</p><figure class="ju jv jw jx fd jy er es paragraph-image"><div class="er es no"><img src="../Images/7493a5b563d3e8be83f3dd87f9018b04.png" data-original-src="https://miro.medium.com/v2/resize:fit:640/0*-Xy7Oh5ANh8qltKD"/></div></figure></div></div>    
</body>
</html>