<html>
<head>
<title>The Dependency Inversion Principle</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">依存倒置原则</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/the-dependency-inversion-principle-a51209b70efb?source=collection_archive---------4-----------------------#2021-10-26">https://medium.com/nerd-for-tech/the-dependency-inversion-principle-a51209b70efb?source=collection_archive---------4-----------------------#2021-10-26</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="4deb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这最后一个原则在设计软件及其职责时有很大关系。大型软件是以模块的形式出现的，正如前面的许多原则所述，开发人员试图避免它们之间的紧密结合，但是，大多数时候情况并非如此。</p><p id="1176" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这个原则规定高级模块不应该依赖于低级模块，两者都应该依赖于代码抽象，我把这看作是一个中间人组件。</p><p id="6a3b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">抽象不应该依赖于细节，恰恰相反。</p><p id="c640" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">高层模块指的是主要的业务功能，当然这个就要看别人了。低级模块处理实现细节</p><p id="f4a0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在下面的例子中，一个SQL目录和存储库，<code class="du jd je jf jg b">ProductCatalog</code>是高级模块，<code class="du jd je jf jg b">SQLProductRepository</code>类是低级模块</p><p id="9d3d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这是代码。</p><p id="c0f8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><code class="du jd je jf jg b">ProductCatalog</code>类实例化一个<code class="du jd je jf jg b">SQLProductRepository</code>并调用方法<code class="du jd je jf jg b">gettAllProductsNames()</code></p><pre class="jh ji jj jk fd jl jg jm jn aw jo bi"><span id="b694" class="jp jq hi jg b fi jr js l jt ju">// starting as high-level - depending on the SQlProductRepository<br/>public class ProductCatalog {<br/>  public void listAllProducts() {<br/>    SQLProductRepository sqlProductRepository = new SQLProductRepository();<br/>    sqlProductRepository.getAllProductNames();<br/>  }<br/>}</span></pre><p id="46e4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">而<code class="du jd je jf jg b">SQLProductRepository</code>类包含了运行Select语句并返回产品列表的方法代码。</p><pre class="jh ji jj jk fd jl jg jm jn aw jo bi"><span id="504e" class="jp jq hi jg b fi jr js l jt ju">import java.util.Arrays;<br/>import java.util.List;</span><span id="aa4e" class="jp jq hi jg b fi jv js l jt ju">// starting as low-level<br/>public class SQlProductRepository {<br/>  public List&lt;String&gt; getAllProductNames() {<br/>    return Array.asList("item1", "item2");<br/>  }<br/>}</span></pre><p id="ac6e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">另一个常见的例子是在电子商务网站上，支付处理器是高级模块，每个支付解决方案都是低级模块。</p><p id="5822" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这当然是相对的，因为你的代码可以有一个更低的模块，但是有N个模块在更高的位置。同样，在这个原则中，最高的依赖于较低的(也可能是最低的)级别。</p><p id="ee80" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">上面的例子违反了这个原则，因为两个类都依赖于产品。两者都应该依赖于抽象，代码抽象。</p><p id="da2f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为此:</p><ol class=""><li id="eb80" class="jw jx hi ih b ii ij im in iq jy iu jz iy ka jc kb kc kd ke bi translated">为<code class="du jd je jf jg b">ProductCatalog</code>类创建一个接口，姑且称之为<code class="du jd je jf jg b">ProductRepository</code></li><li id="e5f7" class="jw jx hi ih b ii kf im kg iq kh iu ki iy kj jc kb kc kd ke bi translated">SQLProductRepository将实现<code class="du jd je jf jg b">ProductRepository</code>接口</li><li id="910c" class="jw jx hi ih b ii kf im kg iq kh iu ki iy kj jc kb kc kd ke bi translated"><code class="du jd je jf jg b">SQLProductRepository</code>将以某种方式从<code class="du jd je jf jg b">SQLProductRepository</code>对象检索到<code class="du jd je jf jg b">ProductCatalog</code>，即“以某种方式”是一个ProductFactory，这是一个返回<code class="du jd je jf jg b">SQLProductRepository</code>的单一方法</li></ol><p id="a26d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这都是关于使用抽象。</p><p id="c4ea" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">综上所述，<code class="du jd je jf jg b">ProductCatalog</code>将与<code class="du jd je jf jg b">ProductRepository</code>对话，从而与<code class="du jd je jf jg b">SQLProductRepository</code>对话</p><p id="ed2f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">细节依赖于抽象，它们根据定义是严格的。</p><p id="313a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这是代码</p><p id="d08b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这是<code class="du jd je jf jg b">ProductCatalog</code>类。</p><pre class="jh ji jj jk fd jl jg jm jn aw jo bi"><span id="1935" class="jp jq hi jg b fi jr js l jt ju">// starting as high-level - depending on the SQlProductRepository<br/>public class ProductCatalog {</span><span id="7943" class="jp jq hi jg b fi jv js l jt ju">private ProductRepository productRepository;</span><span id="64d8" class="jp jq hi jg b fi jv js l jt ju">public ProductCatalog(ProductRepository productRepository) {<br/>    this.productRepository = productRepository;<br/>  }</span><span id="6827" class="jp jq hi jg b fi jv js l jt ju">public void listAllProducts() {</span><span id="c878" class="jp jq hi jg b fi jv js l jt ju">List&lt;String&gt; getAllProductNames = productRepository.getAllProductNames();</span><span id="d37a" class="jp jq hi jg b fi jv js l jt ju">// going for the factory method<br/>    // ProductRepository productRepository = ProductFactory.create();<br/>    // productRepository.getAllProductNames();</span><span id="afbe" class="jp jq hi jg b fi jv js l jt ju">// going for the SQL low-level repository <br/>    // SQLProductRepository sqlProductRepository = new SQLProductRepository();<br/>    // sqlProductRepository.getAllProductNames();</span><span id="abdc" class="jp jq hi jg b fi jv js l jt ju">}<br/>}</span></pre><p id="889b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">下面是<code class="du jd je jf jg b">ProductFactory</code>类。</p><pre class="jh ji jj jk fd jl jg jm jn aw jo bi"><span id="0710" class="jp jq hi jg b fi jr js l jt ju">public class ProductFactory {<br/>  public static ProductRepository create() {<br/>    // instantiate and return a SQlProductRepository<br/>    return new SQLProductRepository();<br/>  }<br/>}</span></pre><p id="5be9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">下面是<code class="du jd je jf jg b">ProductRepository</code>类。</p><pre class="jh ji jj jk fd jl jg jm jn aw jo bi"><span id="3ae0" class="jp jq hi jg b fi jr js l jt ju">import java.util.List;</span><span id="a402" class="jp jq hi jg b fi jv js l jt ju">public interface ProductRepository {<br/>  public List&lt;String&gt; getAllProductNames();<br/>}</span></pre><p id="8f0f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">还有<code class="du jd je jf jg b">SQLProductRepository</code>级。</p><pre class="jh ji jj jk fd jl jg jm jn aw jo bi"><span id="d930" class="jp jq hi jg b fi jr js l jt ju">import java.util.Arrays;<br/>import java.util.List;</span><span id="95c7" class="jp jq hi jg b fi jv js l jt ju">// starting as low-level<br/>public class SQlProductRepository {<br/>  public List&lt;String&gt; getAllProductNames() {<br/>    return Array.asList("item1", "item2");<br/>  }<br/>}</span></pre><p id="9862" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">应用程序:</p><pre class="jh ji jj jk fd jl jg jm jn aw jo bi"><span id="fbe8" class="jp jq hi jg b fi jr js l jt ju">public class MainApplication {<br/>  public static void main(String[] args) {<br/>    // dependency injection<br/>    ProductRepository productRepository = ProductFactory.create();<br/>    // product catalog<br/>    ProductCatalog productCatalog = new ProductCatalog(productRepository);<br/>    // listing products<br/>    productCatalog.listAllProducts();<br/>  }<br/>}</span></pre><p id="1282" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">此时，我们将依赖注入到<code class="du jd je jf jg b">ProductCatalog</code>中，而不是<code class="du jd je jf jg b">ProductCatalog</code>担心依赖的实例化。所有需要的独立性都是从外部注入的，而不用担心如何解决依赖性。</p><p id="0eb6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">依赖注入</strong>避免了紧耦合，领先一步，完全脱离了一个类，让它的依赖被实例化。</p><p id="6915" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">还有另一个术语与这个原则相关，它就是<strong class="ih hj">控制反转(IoC) </strong>。此时，<code class="du jd je jf jg b">ProductCatalog</code>有一个接受了<code class="du jd je jf jg b">productRepository</code>对象的构造函数。</p><p id="0cc7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">注入发生在<code class="du jd je jf jg b">ProductCatalog</code>之外，注入仍然发生在<code class="du jd je jf jg b">MainApplication</code>控制流上，这是主线程执行。</p><p id="e377" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">但是，如果我们希望所有的注入都在一个单独的线程/上下文中呢？通过使用框架，主控制流与注入保持隔离。</p><p id="3d5e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">许多框架会负责注入类的必需依赖项，而不是自己去做。</p><p id="66a5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这是一个巨大而完全不同的世界。</p></div></div>    
</body>
</html>