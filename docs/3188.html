<html>
<head>
<title>How to properly create NestJs Interceptor or Guard factory</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何正确创建 NestJs 拦截器或守卫工厂</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/how-to-properly-create-nestjs-interceptor-or-guard-factory-5211b40a8718?source=collection_archive---------3-----------------------#2021-06-01">https://medium.com/nerd-for-tech/how-to-properly-create-nestjs-interceptor-or-guard-factory-5211b40a8718?source=collection_archive---------3-----------------------#2021-06-01</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="d93e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们每天都在使用 NestJs 拦截器和守卫，大多数情况下我们不需要将它们封装到工厂中，但是偶尔当我们修饰某个控制器或某个控制器的方法时，我们需要静态地向它们传递一个参数。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es jd"><img src="../Images/b02b05cba9aafa0982fc69e7f9d40b4a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BiNQv8cmKeVTe80FvV09rQ.jpeg"/></div></div></figure><h1 id="459b" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated"><strong class="ak">任务:</strong></h1><p id="d40b" class="pw-post-body-paragraph if ig hi ih b ii kn ik il im ko io ip iq kp is it iu kq iw ix iy kr ja jb jc hb bi translated">假设我们需要发送一些指标 KPI 来跟踪应用程序的使用情况。因此，本质上，对于某些操作，我们希望向消息队列发送一个事件，以便它可以在以后由一些分析服务处理。</p><h1 id="7564" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">解决办法</h1><p id="d54f" class="pw-post-body-paragraph if ig hi ih b ii kn ik il im ko io ip iq kp is it iu kq iw ix iy kr ja jb jc hb bi translated">所以我们知道我们需要一个特定的 KPI 事件来配合消息，所以整个分析是有意义的(lol)，而不是在实际的控制器或一些服务中这样做，让我们只是创建一个<strong class="ih hj">拦截器</strong>来实现这个目标。</p><p id="0cb0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们创建一个枚举来保存我们的 KPI 操作名称<br/><em class="ks">src/common/enums/warehouse-event-KPI-name . ts</em></p><pre class="je jf jg jh fd kt ku kv kw aw kx bi"><span id="c1a1" class="ky jq hi ku b fi kz la l lb lc"><em class="ks">export enum </em>WarehouseEventKpiName {<br/>  <em class="ks">CheckIn </em>= 'check-in',<br/>  <em class="ks">GuestArrival </em>= 'guest-arrival',<br/>}</span></pre><p id="0245" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">首先，让我们创建 KPI 模块<br/><em class="ks">src/common/modules/KPI/KPI . Module . ts</em></p><pre class="je jf jg jh fd kt ku kv kw aw kx bi"><span id="9e17" class="ky jq hi ku b fi kz la l lb lc"><em class="ks">import </em>{ <em class="ks">Module </em>} <em class="ks">from </em>'@nestjs/common';<br/><em class="ks">import </em>{ KpiService } <em class="ks">from </em>'./kpi.service';<br/><em class="ks">import </em>{ ConfigModule } <em class="ks">from </em>'@nestjs/config';<br/><br/>@Module({<br/>  imports: [ConfigModule],<br/>  providers: [KpiService],<br/>  exports: [KpiService],<br/>})<br/><em class="ks">export class </em>KpiModule {}</span></pre><p id="bdc4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">然后，让我们创建 KPI 服务<br/><em class="ks">src/common/modules/KPI/KPI . Service . ts</em></p><pre class="je jf jg jh fd kt ku kv kw aw kx bi"><span id="0410" class="ky jq hi ku b fi kz la l lb lc"><em class="ks">import </em>{ <em class="ks">Injectable </em>} <em class="ks">from </em>'@nestjs/common';<br/><em class="ks">import </em>{ <em class="ks">Channel</em>, <em class="ks">connect as </em>amqpConnect, <em class="ks">Connection </em>} <em class="ks">from </em>'amqplib';<br/><em class="ks">import </em>{ ConfigService } <em class="ks">from </em>'@nestjs/config';<br/><br/>@Injectable()<br/><em class="ks">export class </em>KpiService {<br/>  <em class="ks">private </em>connection: <em class="ks">Connection</em>;<br/><br/>  <em class="ks">constructor</em>(<em class="ks">private readonly </em>config: ConfigService) {<br/>    <em class="ks">this</em>.connect()<br/>      .then(() =&gt; {<br/>        console.log('Connected');<br/>      })<br/>      .catch((<em class="ks">e</em>) =&gt; console.error(<em class="ks">e</em>));<br/>  }<br/><br/>  <em class="ks">async </em>publish&lt;T&gt;(<em class="ks">message</em>: T, <em class="ks">exchangeName</em>: <em class="ks">string</em>, <em class="ks">routingKey</em>: <em class="ks">string</em>) {<br/>    <em class="ks">const </em>channel = <em class="ks">await this</em>.prepareChannel(<em class="ks">exchangeName</em>);<br/>    channel.publish(<br/>      <em class="ks">exchangeName</em>,<br/>      <em class="ks">routingKey</em>,<br/>      Buffer.<em class="ks">from</em>(JSON.stringify(<em class="ks">message</em>)),<br/>    );<br/>  }<br/><br/>  <em class="ks">protected async </em>prepareChannel(<em class="ks">exchangeName</em>): <em class="ks">Promise</em>&lt;<em class="ks">Channel</em>&gt; {<br/>    <em class="ks">const </em>channel = <em class="ks">await this</em>.connection.createChannel();<br/>    <em class="ks">await </em>channel.assertExchange(...);<br/>    <em class="ks">return </em>channel;<br/>  }<br/><br/>  <em class="ks">private async </em>connect() {<br/>    <em class="ks">this</em>.connection = <em class="ks">await amqpConnect</em>(<br/>      ...<br/>    );<br/>  }<br/>}</span></pre><p id="499c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在让我们为 KPI 拦截器<br/><em class="ks">src/common/Interceptors/KPI . interceptor . ts</em>创建一个基类</p><pre class="je jf jg jh fd kt ku kv kw aw kx bi"><span id="99c5" class="ky jq hi ku b fi kz la l lb lc"><em class="ks">import </em>{<br/>  <em class="ks">CallHandler</em>,<br/>  <em class="ks">ExecutionContext</em>,<br/>  <em class="ks">Injectable</em>,<br/>  <em class="ks">NestInterceptor</em>,<br/>} <em class="ks">from </em>'@nestjs/common';<br/><em class="ks">import </em>{ Observable } <em class="ks">from </em>'rxjs';<br/><em class="ks">import </em>{ KpiService } <em class="ks">from </em>'src/common/modules/kpi/kpi.service';<br/><em class="ks">import </em>UserResponseDTO <em class="ks">from </em>'...../dto/user.dto';<br/><br/>@Injectable()<br/><em class="ks">export abstract class </em>KpiInterceptor <em class="ks">implements NestInterceptor </em>{<br/>  <em class="ks">abstract readonly </em>exchange: <em class="ks">string</em>;<br/>  <em class="ks">abstract readonly </em>routingKey: <em class="ks">string</em>;<br/><br/>  <em class="ks">abstract </em>intercept(<br/>    <em class="ks">context</em>: <em class="ks">ExecutionContext</em>,<br/>    <em class="ks">next</em>: <em class="ks">CallHandler</em>,<br/>  ): Observable&lt;<em class="ks">any</em>&gt;;<br/><br/>  <em class="ks">constructor</em>(<em class="ks">protected readonly </em>kpiService: KpiService) {}<br/><br/>  <em class="ks">protected async </em>dispatch(<em class="ks">data</em>, <em class="ks">user</em>: UserResponseDTO) {<br/>    <em class="ks">try </em>{<br/>      <em class="ks">await this</em>.kpiService.publish(<br/>        <em class="ks">this</em>.prepareMessage(<em class="ks">data</em>, <em class="ks">user</em>),<br/>        <em class="ks">this</em>.exchange,<br/>        <em class="ks">this</em>.routingKey,<br/>      );<br/>    } <em class="ks">catch </em>(<em class="ks">e</em>) {<br/>      console.error(<em class="ks">e</em>);<br/>    }<br/>  }<br/><br/>  <em class="ks">protected </em>extractUser(<em class="ks">request</em>): UserResponseDTO {<br/>    <em class="ks">return // EXTRACT USER FROM REQUEST</em>;<br/>  } <br/>  <br/>  protected isResponseSuccessfull(response) {<br/>    return response.statusCode &gt;= 200 &amp;&amp; response.statusCode &lt; 300<br/>  }</span><span id="fb70" class="ky jq hi ku b fi ld la l lb lc">  <em class="ks">private </em>prepareMessage(<em class="ks">data</em>, <em class="ks">user</em>: UserResponseDTO) {<br/>    <em class="ks">return </em>{<br/>      // COMBINE DATA AND ACTOR TO CREATE MESSAGE<br/>      timestamp: Date.now(),<br/>    };<br/>  }<br/>}</span></pre></div><div class="ab cl le lf gp lg" role="separator"><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj"/></div><div class="hb hc hd he hf"><h1 id="9b99" class="jp jq hi bd jr js ll ju jv jw lm jy jz ka ln kc kd ke lo kg kh ki lp kk kl km bi translated">为了预定义 KPI 操作，我们需要创建拦截器工厂</h1><p id="a3af" class="pw-post-body-paragraph if ig hi ih b ii kn ik il im ko io ip iq kp is it iu kq iw ix iy kr ja jb jc hb bi translated">基本原则是:</p><pre class="je jf jg jh fd kt ku kv kw aw kx bi"><span id="951b" class="ky jq hi ku b fi kz la l lb lc">type InterceptorFactory = (action: KPIEventName) =&gt; <em class="ks">ClassDecorator</em></span></pre><p id="30f3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">所以真的很简单。</p><p id="1047" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在让我们为仓库事件创建一个专门的 KPI 拦截器。<br/><em class="ks">src/common/interceptors/warehouse-event-KPI . interceptor . ts</em></p><pre class="je jf jg jh fd kt ku kv kw aw kx bi"><span id="2704" class="ky jq hi ku b fi kz la l lb lc"><em class="ks">import </em>{<br/>  <em class="ks">CallHandler</em>,<br/>  <em class="ks">ExecutionContext</em>,<br/>  <em class="ks">Injectable</em>,<br/>  <em class="ks">mixin</em>,<br/>  <em class="ks">NestInterceptor</em>,<br/>} <em class="ks">from </em>'@nestjs/common'; <br/><em class="ks">import </em>{ <em class="ks">tap </em>} <em class="ks">from </em>'rxjs/operators';</span><span id="5a75" class="ky jq hi ku b fi ld la l lb lc"><em class="ks">import </em>{ KpiInterceptor } <em class="ks">from </em>'...';<br/><em class="ks">import </em>{ KpiService } <em class="ks">from </em>'...';<br/><br/><br/><em class="ks">export function WarehouseEventKPI</em>(<br/>  <em class="ks">kpi</em>: <em class="ks">string</em><br/>): <em class="ks">ClassDecorator </em>{<br/>  @Injectable()<br/>  <em class="ks">class </em>WarehouseEventKpiInterceptor<br/>    <em class="ks">extends </em>KpiInterceptor<br/>    <em class="ks">implements NestInterceptor </em>{</span><span id="48c9" class="ky jq hi ku b fi ld la l lb lc">    exchange = '...';<br/>    routingKey = '...';<br/><br/>    <em class="ks">constructor</em>(<em class="ks">protected readonly </em>kpiService: KpiService) {<br/>      <em class="ks">super</em>(kpiService);<br/>    }<br/><br/>    intercept(<em class="ks">context</em>: <em class="ks">ExecutionContext</em>, <em class="ks">next</em>: <em class="ks">CallHandler</em>){<br/>      <em class="ks">const </em>request = <em class="ks">context</em>.switchToHttp().getRequest();<br/>      <em class="ks">const </em>response = <em class="ks">context</em>.switchToHttp().getResponse();<br/><br/>      <em class="ks">return next</em>.handle().pipe(<br/>        <em class="ks">tap</em>((<em class="ks">data</em>) =&gt; { <br/>          if (this.isResponseSuccessfull(response))<br/>            <em class="ks">this</em>.dispatch(<br/>              {<br/>                warehouseId: this.getWarehouseId(<em class="ks">data</em>), <br/>                action: <em class="ks">kpi // HERE WE USE PREDEFINED KPI<br/>              </em>},<br/>              <em class="ks">this</em>.extractUser(request),<br/>            );<br/>        }),<br/>      );<br/>    }<br/><br/>    <em class="ks">private </em>getWarehouseId({ <em class="ks">event </em>}): <em class="ks">number </em>{<br/>      <em class="ks">return // EXTRACT WAREHOUSE ID</em>;<br/>    }<br/>  }</span><span id="b5e8" class="ky jq hi ku b fi ld la l lb lc">  <em class="ks">return mixin</em>(WarehouseEventKpiInterceptor);<br/>}</span></pre><p id="da33" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这就够了。</p><h1 id="184b" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">使用拦截器工厂</h1><pre class="je jf jg jh fd kt ku kv kw aw kx bi"><span id="406a" class="ky jq hi ku b fi kz la l lb lc">@Put(':id/check-in')<br/>@UseGuards(AuthGuard('jwt'))<br/>@UseInterceptors(<br/>  <em class="ks">WarehouseEventKPI</em>(WarehouseEventKpiName.<em class="ks">CheckIn</em>)<br/>)<br/><em class="ks">async </em>eventCheckIn(<br/>  ...<br/>) {<br/>  ...<br/>}</span></pre><p id="98aa" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们已经成功地创建了拦截器工厂。我们的代码看起来干净多了。所有的 KPI 逻辑都封装在 KPI 拦截器中，所以我们不会污染控制器或服务层。</p><p id="53c7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="ks">快乐编码！</em></p></div></div>    
</body>
</html>