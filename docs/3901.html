<html>
<head>
<title>Microservices (Part 5) — Design Patterns for Microservices(Proxy Pattern)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">微服务(第 5 部分)——微服务的设计模式(代理模式)</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/microservices-part-5-design-patterns-for-microservices-proxy-pattern-12562f5987d2?source=collection_archive---------11-----------------------#2021-06-28">https://medium.com/nerd-for-tech/microservices-part-5-design-patterns-for-microservices-proxy-pattern-12562f5987d2?source=collection_archive---------11-----------------------#2021-06-28</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/8ddbfccb6c3d84ddbe0ab95ce9b8d60a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jA3LQjldv6ybr3-WkZ4Fwg.jpeg"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">图 1:代理模式(来源:Google)</figcaption></figure><p id="3760" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">代理模式只是聚合器模式的另一种变体。在这种模式中，聚合不会发生在客户端。将根据需求调用单独的微服务。</p><p id="98d0" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">区别在于，</p><p id="70ae" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw hj">聚合器模式:</strong>调用多个服务来获得应用程序所需的响应。数据的汇总。</p><p id="75b1" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw hj">代理模式:</strong>无数据聚合。</p><p id="93dd" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">让我们借助一个例子来理解代理模式。</p><p id="24b8" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">想象一个场景，我们有一个大型的单片应用程序，管理团队决定将其迁移到新的微服务架构。我们可以使用不同的软件开发方法来实现这一点。如果我们使用敏捷方法，</p><ul class=""><li id="682e" class="jt ju hi iw b ix iy jb jc jf jv jj jw jn jx jr jy jz ka kb bi translated">开始一部分一部分地部署应用程序。这意味着一个接一个的功能。完成整个系统可能需要几个月的时间。</li><li id="4f27" class="jt ju hi iw b ix kc jb kd jf ke jj kf jn kg jr jy jz ka kb bi translated">但是，在某些情况下，我们可能需要更改以前部署的服务。这可能会产生问题。</li></ul><p id="66bf" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw hj">举例:</strong>考虑以下场景。</p><p id="a15d" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">假设我们有一个微服务来获取酒店客人信息。绕过客户代码检索该信息。</p><p id="8b8f" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">然而，随着即将到来的变化，开发人员决定最好借助“客人 ID”而不是“客人代码”来检索客人信息。</p><p id="4f4a" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw hj">更新要求:</strong>用客人 ID 而不是客人代码获取信息。</p><p id="5f4b" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">我们可以在版本控制的帮助下实现这一点。</p><p id="4fc3" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">版本 01:传递来宾代码。</p><p id="359b" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">版本 02:传递来宾 ID</p><p id="4591" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">但是，我们不能按原样部署该系统。我们必须使用代理模式并创建一个单独的代理服务。所有的消费者都必须通过这个代理服务。我们可以通过检查特定的字段值(访客代码或访客 ID)来配置代理将请求路由到正确的版本。这种实现有助于在不打扰客户的情况下部署服务。</p><p id="ebcb" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw hj">服务发现呢？</strong></p><figure class="ki kj kk kl fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es kh"><img src="../Images/fc724411e686fb20d2b21d2ad72a178a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*n7yBkqvpOLpxeAdpv-iVKg.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">图 2:服务发现(来源:NGINX)</figcaption></figure><p id="a4e5" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">每当我们创建一个服务时，使用外部团体来发现服务总是更好的。为什么？</p><p id="8f92" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">轻松应对基础设施变更。在微服务架构中，主机名、IP 地址等可以改变。我们可以实现一个服务发现工具，并配置代理与该工具进行通信。那么该工具可以向代理提供服务的位置。HashiCorp 的 Consul、WSO2 治理注册中心是一些流行的服务发现工具。</p><h1 id="e024" class="km kn hi bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">要点</h1><ul class=""><li id="56ca" class="jt ju hi iw b ix lk jb ll jf lm jj ln jn lo jr jy jz ka kb bi translated">代理模式的实现类似于服务链。这带来了级联故障的风险。这可能会导致系统资源阻塞和一些服务失败。</li></ul><p id="987a" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">解决方案，</p><h2 id="ccc7" class="lp kn hi bd ko lq lr ls ks lt lu lv kw jf lw lx la jj ly lz le jn ma mb li mc bi translated">消息队列</h2><figure class="ki kj kk kl fd ij er es paragraph-image"><div class="er es md"><img src="../Images/8c1b52c286139096c0cb7310a5f24c33.png" data-original-src="https://miro.medium.com/v2/resize:fit:886/format:webp/1*Xu8RnlfibaHx1zzf9w5QeQ.jpeg"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">图 3:消息队列</figcaption></figure><p id="f066" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">它基本上是两个应用程序之间发送的消息队列。换句话说，它包含一个需要处理的对象列表(按照正确的顺序)。这有助于克服级联故障。但是在实现消息队列之前，必须考虑诸如队列失败之类的事实。因此，在这种类型的架构中，我们需要冗余机制。</p><ul class=""><li id="9300" class="jt ju hi iw b ix iy jb jc jf jv jj jw jn jx jr jy jz ka kb bi translated">在实现代理模式之前，开发人员必须注意线程池。这是因为线程的不正确实现会阻塞体系结构中的某些服务。作为解决方案，开发人员可以使用多线程池或线程移交机制。</li><li id="8ea5" class="jt ju hi iw b ix kc jb kd jf ke jj kf jn kg jr jy jz ka kb bi translated">超时也是代理模式的另一个重要概念。考虑这样一种情况，我们有一个代理服务，它将流量导向服务的两个版本。超时对于确保一个版本在失败时不会影响另一个版本是很重要的。</li></ul><p id="c25f" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">我使用了 Krishntha Dinesh 先生的以下播放列表来收集所需的信息。</p><figure class="ki kj kk kl fd ij"><div class="bz dy l di"><div class="me mf l"/></div></figure></div><div class="ab cl mg mh gp mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="hb hc hd he hf"><h1 id="ac17" class="km kn hi bd ko kp mn kr ks kt mo kv kw kx mp kz la lb mq ld le lf mr lh li lj bi translated">参考</h1><div class="ms mt ez fb mu mv"><a href="https://www.nginx.com/blog/service-discovery-in-a-microservices-architecture/" rel="noopener  ugc nofollow" target="_blank"><div class="mw ab dw"><div class="mx ab my cl cj mz"><h2 class="bd hj fi z dy na ea eb nb ed ef hh bi translated">微服务架构中的服务发现- NGINX</h2><div class="nc l"><h3 class="bd b fi z dy na ea eb nb ed ef dx translated">微服务简介构建微服务:使用 API 网关构建微服务:进程间…</h3></div><div class="nd l"><p class="bd b fp z dy na ea eb nb ed ef dx translated">www.nginx.com</p></div></div><div class="ne l"><div class="nf l ng nh ni ne nj io mv"/></div></div></a></div><div class="ms mt ez fb mu mv"><a href="https://www.tutorialspoint.com/design_pattern/proxy_pattern.htm" rel="noopener  ugc nofollow" target="_blank"><div class="mw ab dw"><div class="mx ab my cl cj mz"><h2 class="bd hj fi z dy na ea eb nb ed ef hh bi translated">设计模式-代理模式</h2><div class="nc l"><h3 class="bd b fi z dy na ea eb nb ed ef dx translated">在代理模式中，一个类代表另一个类的功能。这种类型的设计模式属于结构化…</h3></div><div class="nd l"><p class="bd b fp z dy na ea eb nb ed ef dx translated">www.tutorialspoint.com</p></div></div><div class="ne l"><div class="nk l ng nh ni ne nj io mv"/></div></div></a></div><div class="ms mt ez fb mu mv"><a href="https://en.wikipedia.org/wiki/Proxy_pattern" rel="noopener  ugc nofollow" target="_blank"><div class="mw ab dw"><div class="mx ab my cl cj mz"><h2 class="bd hj fi z dy na ea eb nb ed ef hh bi translated">代理模式-维基百科</h2><div class="nc l"><h3 class="bd b fi z dy na ea eb nb ed ef dx translated">在计算机编程中，代理模式是一种软件设计模式。一个代理，在其最一般的形式，是一个类…</h3></div><div class="nd l"><p class="bd b fp z dy na ea eb nb ed ef dx translated">en.wikipedia.org</p></div></div><div class="ne l"><div class="nl l ng nh ni ne nj io mv"/></div></div></a></div></div></div>    
</body>
</html>