<html>
<head>
<title>Monitoring across frameworks</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">跨框架监控</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/monitoring-across-frameworks-c47378ed33fe?source=collection_archive---------19-----------------------#2021-02-28">https://medium.com/nerd-for-tech/monitoring-across-frameworks-c47378ed33fe?source=collection_archive---------19-----------------------#2021-02-28</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/0e0d9a31a74d1cb7bd950ac93245a965.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*m-Nr20LFpX0kzcw7.jpg"/></div></div></figure><p id="10c2" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">开发人员的工作随着应用程序的发布而结束的时代已经一去不复返了。如今，开发人员越来越关心 IT 的运营方面:也许他们自己操作应用程序，但更可能的是，他们的组织促进了开发和运营之间的合作。</p><p id="a963" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">当我还是一名顾问时，我就开始对软件的运营方面感兴趣。当 Spring Boot 释放致动器时，我变得很兴奋。通过其“约定-其他-配置”的特性，只需一个附加的依赖项就可以添加监控端点。</p><p id="2748" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">从那以后，其他框架不断涌现。它们还提供监控功能。在这篇文章中，我想就这些能力对这些框架进行比较。</p><h1 id="f79e" class="jo jp hi bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">Spring Boot</h1><p id="6bde" class="pw-post-body-paragraph iq ir hi is b it km iv iw ix kn iz ja jb ko jd je jf kp jh ji jj kq jl jm jn hb bi translated"><a class="ae kr" href="https://spring.io/projects/spring-boot" rel="noopener ugc nofollow" target="_blank"> Spring Boot </a>是开启监控功能趋势的框架。要启用它们，只需添加一个称为<strong class="is hj">致动器</strong>的依赖关系:</p><pre class="ks kt ku kv fd kw kx ky kz aw la bi"><span id="d003" class="lb jp hi kx b fi lc ld l le lf">&lt;dependency&gt;<br/>    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;<br/>    &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;<br/>    &lt;version&gt;2.4.1&lt;/version&gt;<br/>&lt;/dependency&gt;</span></pre><p id="fe4e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">执行器提供三种端点:</p><ul class=""><li id="6a98" class="lg lh hi is b it iu ix iy jb li jf lj jj lk jn ll lm ln lo bi translated">默认端点<em class="lp">，如</em> <code class="du lq lr ls kx b">/health</code>、<code class="du lq lr ls kx b">/metrics</code>、<code class="du lq lr ls kx b">/beans</code>等。</li><li id="a709" class="lg lh hi is b it lt ix lu jb lv jf lw jj lx jn ll lm ln lo bi translated">依赖项提供的端点。例如，添加 Flyway 将启用<code class="du lq lr ls kx b">/flyway</code>端点。</li><li id="a205" class="lg lh hi is b it lt ix lu jb lv jf lw jj lx jn ll lm ln lo bi translated">您可以提供的自定义端点</li></ul><p id="6c51" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">使用 Spring Boot，可以通过 JMX 和 HTTP 暴露端点。出于安全原因，默认情况下，所有终端都启用了 JMX。另一方面，HTTP 只对<code class="du lq lr ls kx b">/health</code>(以压缩形式)和<code class="du lq lr ls kx b">/info</code>启用。</p><p id="d357" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">您可以通过 Spring Security 保护 HTTP 端点。这允许广泛的用例。例如，您可以启用特定的端点，但只允许经过身份验证的客户端访问它。</p><h1 id="9621" class="jo jp hi bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">微型机器人</h1><p id="37f9" class="pw-post-body-paragraph iq ir hi is b it km iv iw ix kn iz ja jb ko jd je jf kp jh ji jj kq jl jm jn hb bi translated"><a class="ae kr" href="https://micronaut.io/" rel="noopener ugc nofollow" target="_blank"> Micronaut </a>还提供监控端点。这些端点大多映射到 Spring Boot 提供的端点，只有少数例外。</p><p id="48a6" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">要添加管理功能，请添加一个依赖项:</p><pre class="ks kt ku kv fd kw kx ky kz aw la bi"><span id="304c" class="lb jp hi kx b fi lc ld l le lf">&lt;dependency&gt;<br/>    &lt;groupId&gt;io.micronaut&lt;/groupId&gt;<br/>    &lt;artifactId&gt;micronaut-management&lt;/artifactId&gt;<br/>    &lt;version&gt;2.2.2&lt;/version&gt;<br/>&lt;/dependency&gt;</span></pre><p id="9ac8" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">微机器人通过 HTTP 暴露端点。为了通过 JMX 公开它们，您需要添加一个额外的依赖项。</p><pre class="ks kt ku kv fd kw kx ky kz aw la bi"><span id="aacc" class="lb jp hi kx b fi lc ld l le lf">&lt;dependency&gt;<br/>    &lt;groupId&gt;io.micronaut.jmx&lt;/groupId&gt;<br/>    &lt;artifactId&gt;micronaut-jmx&lt;/artifactId&gt;<br/>    &lt;version&gt;2.1.0&lt;/version&gt;<br/>&lt;/dependency&gt;</span></pre><p id="b310" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">默认情况下，除了<code class="du lq lr ls kx b">/cache</code>和<code class="du lq lr ls kx b">/stop</code>之外，所有端点都被启用。</p><p id="5697" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">注意<code class="du lq lr ls kx b">/metrics</code>端点需要依赖于千分尺芯。</p><h1 id="19ed" class="jo jp hi bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">夸库斯</h1><p id="2c98" class="pw-post-body-paragraph iq ir hi is b it km iv iw ix kn iz ja jb ko jd je jf kp jh ji jj kq jl jm jn hb bi translated">最后但并非最不重要的是夸夸其谈。Quarkus 的方法不同于 Spring Boot 和 Micronaut 的方法:它本身不实现端点，而是依赖于第三方。在进入核心之前，让我离题一点。</p><p id="8931" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">很久以前，有一个概念叫做 Java EE，由 Sun 提出，然后由 Oracle 提出。这个想法是设计一套规范，并让行业参与者实现它们。这将使客户受益，因为他们可以透明地从一个兼容 Java EE 的平台迁移到另一个平台。尽管现实并不理想，但它或多或少地发挥了作用，直到两件事情发生。</p><p id="d7ee" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">Java EE 平台是在资源稀缺的时候设计的，要在几个应用程序之间共享。工作中的第一个难题是敏捷和云的兴起，它们支持更小、更高效的运行时。</p><p id="9dac" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">第二个问题是 Oracle 对 Java EE 失去了兴趣，因为它没有产生足够的(任何？)营收。Java EE 以 Jakarta EE 的名字在 Eclipse Foundation 找到了一个新家，但这不是一夜之间发生的——它花了大约三年时间。在那段时间里，Java EE 没有任何技术上的改进。</p><p id="4c5b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">随着科技的发展，这是一个致命的威胁。为了防止 Jakarta EE 在迁移期结束时变得过时，并行出现了一组称为<a class="ae kr" href="https://projects.eclipse.org/projects/technology.microprofile" rel="noopener ugc nofollow" target="_blank">微概要文件</a>的新规范。MicroProfile 提供了一组集中的子规范(括号中是实际版本):</p><ul class=""><li id="494b" class="lg lh hi is b it iu ix iy jb li jf lj jj lk jn ll lm ln lo bi translated">配置(2.0)</li><li id="8a67" class="lg lh hi is b it lt ix lu jb lv jf lw jj lx jn ll lm ln lo bi translated">容错(3.0)</li><li id="2eaf" class="lg lh hi is b it lt ix lu jb lv jf lw jj lx jn ll lm ln lo bi translated">健康(3.0)</li><li id="ff4d" class="lg lh hi is b it lt ix lu jb lv jf lw jj lx jn ll lm ln lo bi translated">JWT·RBAC(1.2)</li><li id="515d" class="lg lh hi is b it lt ix lu jb lv jf lw jj lx jn ll lm ln lo bi translated">指标(3.0)</li><li id="e1f2" class="lg lh hi is b it lt ix lu jb lv jf lw jj lx jn ll lm ln lo bi translated">开放式 API (2.0)</li><li id="14aa" class="lg lh hi is b it lt ix lu jb lv jf lw jj lx jn ll lm ln lo bi translated">开放式跟踪(2.0)</li><li id="f2df" class="lg lh hi is b it lt ix lu jb lv jf lw jj lx jn ll lm ln lo bi translated">Rest 客户端(2.0)</li></ul><p id="d7b9" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">有趣的是，我发现至少有两个库形式的微文件实现——而不是一个成熟的应用服务器:富士通的<a class="ae kr" href="https://smallrye.io/" rel="noopener ugc nofollow" target="_blank"> SmallRye </a>和<a class="ae kr" href="https://github.com/fujitsu/launcher" rel="noopener ugc nofollow" target="_blank"> Launcher </a>。应用服务器的提供商和开发人员可以使用这些依赖关系，而不是自己重新实现规范。这就是夸库斯遵循的方法。</p><p id="fff5" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">每项功能都由特定的依赖项来实现。</p><pre class="ks kt ku kv fd kw kx ky kz aw la bi"><span id="4c73" class="lb jp hi kx b fi lc ld l le lf">&lt;dependency&gt;<br/>    &lt;groupId&gt;io.quarkus&lt;/groupId&gt;<br/>    &lt;artifactId&gt;quarkus-smallrye-metrics&lt;/artifactId&gt;<br/>    &lt;version&gt;1.10.5.Final&lt;/version&gt;<br/>&lt;/dependency&gt;<br/>&lt;dependency&gt;<br/>    &lt;groupId&gt;io.quarkus&lt;/groupId&gt;<br/>    &lt;artifactId&gt;quarkus-smallrye-health&lt;/artifactId&gt;<br/>    &lt;version&gt;1.10.5.Final&lt;/version&gt;<br/>&lt;/dependency&gt;</span></pre><p id="31f3" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">此外，Quarkus 提供了多个特定于其 CDI 实现(ArC)的端点。由于其专注于云原生，Quarkus 实现了编译时 CDI。因此，它能够检测没有在其他地方使用的 beans，并且不会实例化它们。请注意，除非明确启用，否则 ArC 端点仅在开发模式下可用。</p><p id="765b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">当编译时类路径上有一个 SmallRye 依赖项时，默认情况下它是启用的。专用标志允许单独禁用它们。对于其他配置属性也是如此，<em class="lp">，例如</em>，到端点的路径。</p><h1 id="966f" class="jo jp hi bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">赫利登</h1><p id="79dc" class="pw-post-body-paragraph iq ir hi is b it km iv iw ix kn iz ja jb ko jd je jf kp jh ji jj kq jl jm jn hb bi translated"><a class="ae kr" href="https://helidon.io/" rel="noopener ugc nofollow" target="_blank"> Helidon </a>是 Oracle 提供的基于 Jakarta EE APIs 和 MicroProfile 子集的框架。</p><p id="d6c1" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我知道它支持开箱即用的<code class="du lq lr ls kx b">/health</code>和<code class="du lq lr ls kx b">/metrics</code>。对于它们中的每一个，您都需要添加一个依赖项。</p><p id="2f6f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我必须承认我没有花足够的时间来讲述更多。有兴趣的请自行查看。</p><h1 id="8569" class="jo jp hi bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">总结</h1><p id="c5cb" class="pw-post-body-paragraph iq ir hi is b it km iv iw ix kn iz ja jb ko jd je jf kp jh ji jj kq jl jm jn hb bi translated">这里总结了所有框架的端点。</p><figure class="ks kt ku kv fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ly"><img src="../Images/b73d062f41b36ca1cbba947ca1915d5e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uHSgvg5r39UNsfecfeb7IA.png"/></div></div></figure><h1 id="3661" class="jo jp hi bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">为了更进一步:</h1><ul class=""><li id="5f42" class="lg lh hi is b it km ix kn jb lz jf ma jj mb jn ll lm ln lo bi translated"><a class="ae kr" href="https://docs.spring.io/spring-boot/docs/current/reference/html/production-ready-features.html" rel="noopener ugc nofollow" target="_blank"> Spring Boot 执行器</a></li><li id="cc2d" class="lg lh hi is b it lt ix lu jb lv jf lw jj lx jn ll lm ln lo bi translated"><a class="ae kr" href="https://docs.micronaut.io/latest/guide/#management" rel="noopener ugc nofollow" target="_blank"> Micronaut 的管理&amp;监控</a></li><li id="ae06" class="lg lh hi is b it lt ix lu jb lv jf lw jj lx jn ll lm ln lo bi translated"><a class="ae kr" href="https://projects.eclipse.org/projects/technology.microprofile" rel="noopener ugc nofollow" target="_blank">微文件</a></li><li id="1120" class="lg lh hi is b it lt ix lu jb lv jf lw jj lx jn ll lm ln lo bi translated"><a class="ae kr" href="https://smallrye.io/" rel="noopener ugc nofollow" target="_blank">小黑麦</a></li><li id="bdcc" class="lg lh hi is b it lt ix lu jb lv jf lw jj lx jn ll lm ln lo bi translated"><a class="ae kr" href="https://quarkus.io/guides/microprofile-health" rel="noopener ugc nofollow" target="_blank"> Quarkus —微档案健康</a></li><li id="b074" class="lg lh hi is b it lt ix lu jb lv jf lw jj lx jn ll lm ln lo bi translated"><a class="ae kr" href="https://quarkus.io/guides/microprofile-metrics" rel="noopener ugc nofollow" target="_blank"> Quarkus —微轮廓度量</a></li><li id="8604" class="lg lh hi is b it lt ix lu jb lv jf lw jj lx jn ll lm ln lo bi translated"><a class="ae kr" href="https://quarkus.io/guides/cdi-reference#dev-mode" rel="noopener ugc nofollow" target="_blank"> Quarkus —上下文和依赖注入</a></li></ul></div><div class="ab cl mc md gp me" role="separator"><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh"/></div><div class="hb hc hd he hf"><p id="ee30" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><em class="lp">最初发表于 2021 年 2 月 28 日</em> <a class="ae kr" href="https://blog.frankel.ch/monitoring-across-frameworks/" rel="noopener ugc nofollow" target="_blank"> <em class="lp">一个 Java 怪胎</em> </a> <em class="lp">。</em></p></div></div>    
</body>
</html>