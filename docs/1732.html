<html>
<head>
<title>Build the Forest in Python Series: Single-Threaded Binary Search Trees</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在Python系列中构建森林:单线程二分搜索法树</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/build-the-forest-in-python-series-single-threaded-binary-search-trees-323465dd70db?source=collection_archive---------18-----------------------#2021-04-03">https://medium.com/nerd-for-tech/build-the-forest-in-python-series-single-threaded-binary-search-trees-323465dd70db?source=collection_archive---------18-----------------------#2021-04-03</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="959d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">本文是<a class="ae jd" href="https://shunsvineyard.info/build-the-forest-series/" rel="noopener ugc nofollow" target="_blank">营造森林系列</a>的第三篇。在上一篇文章<a class="ae jd" href="https://shunsvineyard.info/2021/03/17/build-the-forest-in-python-series-binary-tree-traversal/" rel="noopener ugc nofollow" target="_blank">二叉树遍历</a>中，我们讨论了使用递归方法和辅助堆栈的二叉树遍历。本文将构建二叉查找树的一个变体——线程二叉查找树。线程二分搜索法树利用空的左或右节点的属性来实现某些遍历，而不使用堆栈或递归方法。</p><h1 id="c79c" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">项目设置</h1><p id="92e5" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">像<a class="ae jd" href="https://shunsvineyard.info/build-the-forest-series/" rel="noopener ugc nofollow" target="_blank">构建森林系列</a>中的其他文章一样，实现假设使用Python 3.9或更新版本。本文为我们的项目添加了两个模块:<em class="kh">single _ threaded _ binary _ trees . py</em>用于线程化二叉查找树实现，以及<em class="kh">test _ single _ threaded _ binary _ trees . py</em>用于其单元测试。添加这两个文件后，我们的项目布局如下:</p><pre class="ki kj kk kl fd km kn ko kp aw kq bi"><span id="881b" class="kr jf hi kn b fi ks kt l ku kv">forest-python<br/>├── forest<br/>│   ├── __init__.py<br/>│   ├── binary_trees<br/>│   │   ├── __init__.py<br/>│   │   ├── binary_search_tree.py<br/>│   │   ├── single_threaded_binary_trees.py<br/>│   │   └── traversal.py<br/>│   └── tree_exceptions.py<br/>└── tests<br/>    ├── __init__.py<br/>    ├── conftest.py<br/>    ├── test_binary_search_tree.py<br/>    ├── test_single_threaded_binary_trees.py<br/>    └── test_traversal.py</span></pre><p id="d3f4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">(完整代码可从<a class="ae jd" href="https://github.com/shunsvineyard/forest-python" rel="noopener ugc nofollow" target="_blank"> forest-python </a>获得)</p><h1 id="b532" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">什么是线索二叉树？</h1><p id="9164" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">线程二叉树是一种二叉树变体，它通过利用节点的空左或空右属性来优化特定顺序的遍历。有两种类型的线索二叉树:</p><p id="9fea" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">单线程二叉树</strong>:对于一个节点的任何一个空的左或右属性，空属性被线程化到有序的前一个或后一个。换句话说，不是让left或right属性为空，而是left或right属性指向节点的前任或继任者。单线程二叉树有两种实现方式:左单线程二叉树和右单线程二叉树。</p><ul class=""><li id="5a44" class="kw kx hi ih b ii ij im in iq ky iu kz iy la jc lb lc ld le bi translated"><strong class="ih hj">右单线程二叉树</strong>:一个节点的空右属性指向该节点的<strong class="ih hj">后继节点</strong>，如果一个节点有空左属性，则该属性保持为空。</li><li id="1f71" class="kw kx hi ih b ii lf im lg iq lh iu li iy lj jc lb lc ld le bi translated"><strong class="ih hj">左单线程二叉树</strong>:一个节点的空左属性指向该节点的<strong class="ih hj">前任</strong>，如果一个节点有空右属性，则该属性保持为空。</li></ul><p id="b69a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">双线索二叉树</strong>:对于任意空的左属性或右属性，空属性被线索化到有序的前一个或后一个:如果左属性为空，则左属性指向该节点的前一个；如果右属性为空，则右属性指向该节点的后继节点。</p><p id="318d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">尽管线程可以被添加到任何二叉树，但是将线程添加到二叉查找树或其变体，即满足<a class="ae jd" href="https://shunsvineyard.info/2021/03/13/build-the-forest-in-python-series-binary-search-tree/#2-what-is-the-binary-search-tree" rel="noopener ugc nofollow" target="_blank">二叉搜索树属性</a>的树，是最有益的。因此，在这个项目中，我们将实现的线程二叉树是带线程的二分搜索法树(线程二分搜索法树)。在本文的其余部分，我们提到的所有线索二叉树也是二分搜索法树，以避免冗长的阶段。</p><p id="3773" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">此外，线程不需要指向其有序的前任或继任者。也可以是预购或后购。但是，按序是二叉查找树中的一种排序顺序，因此指向其按序前导或后继的线程是最常见的。</p><h1 id="a8bc" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">为什么我们需要线？</h1><p id="9301" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">向二叉树添加线程会增加复杂性，那么我们为什么需要线程呢？有几个原因:</p><ul class=""><li id="ebed" class="kw kx hi ih b ii ij im in iq ky iu kz iy la jc lb lc ld le bi translated">快速后继或前任访问</li><li id="4271" class="kw kx hi ih b ii lf im lg iq lh iu li iy lj jc lb lc ld le bi translated">对于某些遍历，没有辅助堆栈或递归方法</li><li id="35b0" class="kw kx hi ih b ii lf im lg iq lh iu li iy lj jc lb lc ld le bi translated">减少了执行遍历时的内存消耗，因为不需要辅助堆栈或递归</li><li id="6a2c" class="kw kx hi ih b ii lf im lg iq lh iu li iy lj jc lb lc ld le bi translated">利用浪费的空间。由于节点的空left或right属性不存储任何东西，我们可以将它们用作线程</li></ul><p id="5e42" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">对于每种类型的线程二叉树，我们可以总结如下添加线程的好处。</p><ul class=""><li id="1ae1" class="kw kx hi ih b ii ij im in iq ky iu kz iy la jc lb lc ld le bi translated">右线程二叉树可以在不使用堆栈或递归方法的情况下执行有序和前序遍历。它还具有快速后继访问。</li><li id="a3d4" class="kw kx hi ih b ii lf im lg iq lh iu li iy lj jc lb lc ld le bi translated">左线程二叉树可以在没有堆栈或递归方法的情况下执行反向有序遍历，并且具有快速的前任访问。</li><li id="9750" class="kw kx hi ih b ii lf im lg iq lh iu li iy lj jc lb lc ld le bi translated">双线程二叉树具有两种单线程二叉树的优点。</li></ul><h1 id="e265" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">构建单线程二分搜索法树</h1><p id="db63" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">正如我们在<a class="ae jd" href="https://shunsvineyard.info/2021/03/13/build-the-forest-in-python-series-binary-search-tree/#3-build-the-binary-search-tree" rel="noopener ugc nofollow" target="_blank">构建二叉查找树</a>一节中所做的，这一节将遍历实现并讨论实现选择背后的一些想法。</p><h1 id="dd56" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">结节</h1><p id="6d86" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">节点结构类似于<a class="ae jd" href="https://shunsvineyard.info/2021/03/13/build-the-forest-in-python-series-binary-search-tree/#4-node" rel="noopener ugc nofollow" target="_blank">二叉查找树节点</a>，除了它有一个额外的字段<em class="kh">是_线程</em>。<em class="kh"> is_thread </em>属性的目的是知道左或右属性是否是线程。</p><figure class="ki kj kk kl fd ll er es paragraph-image"><div class="er es lk"><img src="../Images/3b7e7e82d7f8cc71ced0dd501e6be468.png" data-original-src="https://miro.medium.com/v2/resize:fit:564/format:webp/0*GD2Kmnl6_ddcRltu.png"/></div></figure><p id="e6d5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="kh"> is_thread </em>属性为布尔变量:<em class="kh"> True </em>如果属性(左或右取决于单线程二叉树的类型)为线程；<em class="kh">假</em>否则。</p><pre class="ki kj kk kl fd km kn ko kp aw kq bi"><span id="216e" class="kr jf hi kn b fi ks kt l ku kv">@dataclasses.dataclass<br/>class Node:<br/>    key: Any<br/>    data: Any<br/>    left: Optional["Node"] = None<br/>    right: Optional["Node"] = None<br/>    parent: Optional["Node"] = None<br/>    is_thread: bool = False</span></pre><p id="9766" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">作为二叉查找树节点，我们将线程二叉树的节点类定义为<a class="ae jd" href="https://www.python.org/dev/peps/pep-0557/" rel="noopener ugc nofollow" target="_blank">数据类</a>。</p><h1 id="b57b" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">右单线程二叉查找树</h1><p id="3677" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">顾名思义，我们可以把右边的单线程二叉树形象化为下图。</p><figure class="ki kj kk kl fd ll er es paragraph-image"><div class="er es lo"><img src="../Images/de557bf41f32df1bd8e779a18423c910.png" data-original-src="https://miro.medium.com/v2/resize:fit:1082/format:webp/0*Z8conA3yWfm38Zzx.png"/></div></figure><p id="9e65" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">每个节点的空右属性指向其有序后继，其<em class="kh"> is_thread </em>变量设置为<em class="kh"> True </em>除了最右边的节点。最右边的节点的right属性保持为空，它的is_thread为False，所以我们知道它是最右边的节点(即没有后续节点)。</p><p id="2428" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">像二叉查找树一样，右线程二叉树具有构建和修改的核心函数(插入、删除和搜索)以及其他不依赖于特定树的辅助函数，例如获取最左边的节点和树的高度。我们在二叉查找树中实现的同一个<em class="kh"> __repr__() </em>函数也可以用于调试目的。</p><p id="9975" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这里的主要区别是，我们实现了不使用堆栈或递归方法的有序和预序遍历。</p><pre class="ki kj kk kl fd km kn ko kp aw kq bi"><span id="5f7b" class="kr jf hi kn b fi ks kt l ku kv">class RightThreadedBinaryTree:<br/><br/>    def __init__(self) -&gt; None:<br/>        self.root: Optional[Node] = None<br/><br/>    def __repr__(self) -&gt; str:<br/>        """Provie the tree representation to visualize its layout."""<br/>        if self.root:<br/>            return (<br/>                f"{type(self)}, root={self.root}, "<br/>                f"tree_height={str(self.get_height(self.root))}"<br/>            )<br/>        return "empty tree"<br/><br/>    def search(self, key: Any) -&gt; Optional[Node]:<br/>        …<br/><br/>    def insert(self, key: Any, data: Any) -&gt; None:<br/>        …<br/><br/>    def delete(self, key: Any) -&gt; None:<br/>        …<br/><br/>    @staticmethod<br/>    def get_leftmost(node: Node) -&gt; Node:<br/>        …<br/><br/>    @staticmethod<br/>    def get_rightmost(node: Node) -&gt; Node:<br/>        …<br/><br/>    @staticmethod<br/>    def get_successor(node: Node) -&gt; Optional[Node]:<br/>        …<br/><br/>    @staticmethod<br/>    def get_predecessor(node: Node) -&gt; Optional[Node]:<br/>        …<br/><br/>    @staticmethod<br/>    def get_height(node: Optional[Node]) -&gt; int:<br/>        …<br/><br/>    def inorder_traverse(self) -&gt; traversal.Pairs:<br/>        …<br/><br/>    def preorder_traverse(self) -&gt; traversal.Pairs:<br/>        …</span></pre><h2 id="e3f7" class="kr jf hi bd jg lp lq lr jk ls lt lu jo iq lv lw js iu lx ly jw iy lz ma ka mb bi translated">插入</h2><p id="19b9" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">插入操作类似于二叉查找树的<a class="ae jd" href="https://shunsvineyard.info/2021/03/13/build-the-forest-in-python-series-binary-search-tree/#7-insert" rel="noopener ugc nofollow" target="_blank">插入</a>。不同的是，线程二叉树需要考虑线程更新。因此，插入步骤如下。</p><ol class=""><li id="430d" class="kw kx hi ih b ii ij im in iq ky iu kz iy la jc mc lc ld le bi translated">通过从根开始遍历树，并将新节点的键与沿途每个节点的键进行比较，找到插入新节点的适当位置(即新节点的父节点)。当走到右边的子树时，同样检查<em class="kh"> is_thread </em>变量。如果变量为<em class="kh"> True </em>，我们到达叶子层，叶子节点就是新节点的父节点。</li><li id="de36" class="kw kx hi ih b ii lf im lg iq lh iu li iy lj jc mc lc ld le bi translated">更新新节点的父属性以指向父节点。</li><li id="486b" class="kw kx hi ih b ii lf im lg iq lh iu li iy lj jc mc lc ld le bi translated">如果新节点是父节点的左子节点，则将新节点的右属性设置为父节点，并将<em class="kh"> is_thread </em>变量设置为<em class="kh"> True </em>。更新父节点的left属性以指向新节点。</li><li id="62e4" class="kw kx hi ih b ii lf im lg iq lh iu li iy lj jc mc lc ld le bi translated">如果新节点是其父节点的右子节点，则将父节点的右属性复制到新节点的右属性中(父节点的右属性必须是插入前的线程)，并将<em class="kh"> is_thread </em>变量设置为<em class="kh"> True </em>。更新父节点的right属性指向新节点，并将父节点的<em class="kh"> is_thread </em>设置为<em class="kh"> False </em>。</li></ol><p id="891b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">下图演示了节点插入的步骤。</p><figure class="ki kj kk kl fd ll er es paragraph-image"><div class="er es md"><img src="../Images/4fd368da3f654389db26b2824f4a26d0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1042/0*Mobfdi5hczO93V7M.gif"/></div></figure><p id="2bc7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们可以如下实现插入。</p><pre class="ki kj kk kl fd km kn ko kp aw kq bi"><span id="fdd9" class="kr jf hi kn b fi ks kt l ku kv">def insert(self, key: Any, data: Any) -&gt; None:<br/>    new_node = Node(key=key, data=data)<br/>    parent: Optional[Node] = None<br/>    current: Optional[Node] = self.root<br/><br/>    while current:<br/>        parent = current<br/>        if new_node.key &lt; current.key:<br/>            current = current.left<br/>        elif new_node.key &gt; current.key:<br/>            # If the node is thread, meaning it's a leaf node.<br/>            if current.is_thread:<br/>                current = None<br/>            else:<br/>                current = current.right<br/>        else:<br/>            raise tree_exceptions.DuplicateKeyError(key=new_node.key)<br/>    new_node.parent = parent<br/>    # If the tree is empty<br/>    if parent is None:<br/>        self.root = new_node<br/>    elif new_node.key &lt; parent.key:<br/>        parent.left = new_node<br/><br/>        # Update thread<br/>        new_node.right = parent<br/>        new_node.is_thread = True<br/><br/>    else:<br/>        # Update thread<br/>        new_node.is_thread = parent.is_thread<br/>        new_node.right = parent.right<br/>        parent.is_thread = False<br/>        # Parent's right must be set after thread update<br/>        parent.right = new_node</span></pre><h2 id="7de2" class="kr jf hi bd jg lp lq lr jk ls lt lu jo iq lv lw js iu lx ly jw iy lz ma ka mb bi translated">搜索</h2><p id="89c3" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">搜索操作也类似于二叉查找树的搜索，但是它需要检查<em class="kh"> is_thread </em>变量来确定我们是否到达了叶级。</p><ol class=""><li id="40bd" class="kw kx hi ih b ii ij im in iq ky iu kz iy la jc mc lc ld le bi translated">从根开始遍历树，并沿着树遍历将键与每个节点的键进行比较</li><li id="5437" class="kw kx hi ih b ii lf im lg iq lh iu li iy lj jc mc lc ld le bi translated">如果一个键匹配，我们就找到了节点。</li><li id="84dd" class="kw kx hi ih b ii lf im lg iq lh iu li iy lj jc mc lc ld le bi translated">如果到达叶子后没有键匹配(如果is_thread为True，则表示该节点是叶子节点)，则它不存在于树中。</li></ol><p id="16d5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">该工具类似于我们在<a class="ae jd" href="https://shunsvineyard.info/2021/03/13/build-the-forest-in-python-series-binary-search-tree/#8-search" rel="noopener ugc nofollow" target="_blank">二叉查找树中制作的二叉查找树:搜索</a>并进行简单修改——检查<em class="kh"> is_thread </em>。</p><pre class="ki kj kk kl fd km kn ko kp aw kq bi"><span id="5b2f" class="kr jf hi kn b fi ks kt l ku kv">def search(self, key: Any) -&gt; Optional[Node]:<br/>    current = self.root<br/>    while current:<br/>        if key == current.key:<br/>            return current<br/>        elif key &lt; current.key:<br/>            current = current.left<br/>        else:  # key &gt; current.key<br/>            if current.is_thread:<br/>                break<br/>            current = current.right<br/>    return None</span></pre><h2 id="feb2" class="kr jf hi bd jg lp lq lr jk ls lt lu jo iq lv lw js iu lx ly jw iy lz ma ka mb bi translated">删除</h2><p id="a90e" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">像二叉查找树一样，要删除的右线程树节点有三种情况:没有孩子、只有一个孩子、两个孩子。我们还使用我们在<a class="ae jd" href="https://shunsvineyard.info/2021/03/13/build-the-forest-in-python-series-binary-search-tree/#9-delete" rel="noopener ugc nofollow" target="_blank">二叉查找树中使用的移植技术:删除</a>来用要删除的节点替换子树。虽然基本思想是相同的，但是<em class="kh">移植</em>函数和<em class="kh">删除</em>函数都需要将正确的线程放入计数中。我们需要记住的最重要的事情是，当我们删除一个节点时，如果有另一个节点的右属性指向要删除的节点，我们需要更新该节点的线程(即右属性)。</p><p id="3ad3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">案例1:没有孩子</p><p id="e13d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果要删除的节点没有子节点，则其left属性为空，其<em class="kh">为_thread </em>为<em class="kh"> True </em>。关于线程，我们需要考虑两种情况。见下图。</p><figure class="ki kj kk kl fd ll er es paragraph-image"><div class="er es md"><img src="../Images/7bdac1dcd621e26897db6f517b09fc03.png" data-original-src="https://miro.medium.com/v2/resize:fit:1042/format:webp/0*4BxKbdral9pNw3Zi.png"/></div></figure><p id="ab51" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">案例2a:只剩下一个孩子</p><p id="d26a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果要删除的节点只有一个左子节点，则表示该节点的<em class="kh"> is_thread </em>为<em class="kh"> True </em>(例外情况是当要删除的节点是根节点且只有一个左子节点时；这种情况下，节点的<em class="kh">为_thread </em>为<em class="kh"> False </em>，其右属性为<em class="kh"> None </em>。我们需要更新线程的情况如下图所示。</p><figure class="ki kj kk kl fd ll er es paragraph-image"><div class="er es me"><img src="../Images/0d95ce78be7b6ae104a5adcdf5b14d0a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1024/format:webp/0*CLHqQ04NpU-_28wb.png"/></div></figure><p id="2dd1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">案例2b:只有一个正确的孩子</p><p id="79fc" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果要删除的节点只有一个右子节点，则表示该节点的左属性为空，<em class="kh"> is_thread </em>为False。由于要删除的节点没有左子节点，这意味着没有人指向该节点。</p><figure class="ki kj kk kl fd ll er es paragraph-image"><div class="er es mf"><img src="../Images/49aaaee74e526566ce879c5682f96f1f.png" data-original-src="https://miro.medium.com/v2/resize:fit:802/format:webp/0*XmSx1tdsno-A1nMu.png"/></div></figure><p id="3bcb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">案例3:两个孩子</p><p id="cbd2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">类似于二叉查找树删除，要删除的节点有两个孩子的情况可以分解成两个子情况:</p><p id="f057" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">3.a删除节点的右边子节点也是右边子树中最左边的节点。在这种情况下，正确的孩子必须只有一个正确的孩子。因此，我们可以将删除节点替换为它的右子节点，如下图所示。</p><figure class="ki kj kk kl fd ll er es paragraph-image"><div class="er es mg"><img src="../Images/b81817d8fd5e60944deaeda15eecc1a2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1162/format:webp/0*RCy5chSR6Y-j1gt3.png"/></div></figure><p id="7a97" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">3.b .删除节点的右子节点也有两个子节点。</p><p id="f8fc" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在这种情况下，我们从右边的子树中找到最左边的节点来替换要删除的节点。注意，当我们从右边的子树中取出最左边的节点时，它也属于删除情况:情况1:没有子节点或情况2:只有一个右边的子节点。否则，它不能是最左边的节点。</p><p id="9553" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">因此，我们使用了两次<em class="kh">移植</em>函数:一次取出最左边的节点，另一次用原来最左边的节点替换删除的节点。下图展示了我们执行删除时的线程考虑。</p><p id="dc7f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">替换节点没有子节点:</strong></p><figure class="ki kj kk kl fd ll er es paragraph-image"><div class="er es mh"><img src="../Images/79f5f13f967ae9824025dca8b4f22b75.png" data-original-src="https://miro.medium.com/v2/resize:fit:952/format:webp/0*xsW3hQqbn6XNs_IK.png"/></div></figure><p id="95d0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">替换节点只有一个右子节点</strong>:</p><figure class="ki kj kk kl fd ll er es paragraph-image"><div class="er es mi"><img src="../Images/b234edd7f8a0cefdb1471dcc192a2503.png" data-original-src="https://miro.medium.com/v2/resize:fit:674/format:webp/0*nj9XBwne9Dw3TphQ.png"/></div></figure><p id="101c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">基于上面的图片，我们可以实现如下的删除和移植功能。</p><pre class="ki kj kk kl fd km kn ko kp aw kq bi"><span id="6fc1" class="kr jf hi kn b fi ks kt l ku kv">def delete(self, key: Any) -&gt; None:<br/>    if self.root and (deleting_node := self.search(key=key)):<br/>        # Case 1: no child<br/>        if deleting_node.left is None and (<br/>            deleting_node.right is None or deleting_node.is_thread<br/>        ):<br/>            self._transplant(deleting_node=deleting_node, replacing_node=None)<br/><br/>        # Case 2a: only one left child<br/>        elif deleting_node.left and (<br/>            deleting_node.is_thread or deleting_node.right is None<br/>            # deleting_node.right is None means the deleting node is the root.<br/>        ):<br/>            predecessor = self.get_predecessor(node=deleting_node)<br/>            if predecessor:<br/>                predecessor.right = deleting_node.right<br/>            self._transplant(<br/>                deleting_node=deleting_node, replacing_node=deleting_node.left<br/>            )<br/><br/>        # Case 2b: only one right child<br/>        elif deleting_node.left is None and deleting_node.is_thread is False:<br/>            self._transplant(<br/>                deleting_node=deleting_node, replacing_node=deleting_node.right<br/>            )<br/><br/>        # Case 3: two children<br/>        elif (<br/>            deleting_node.left<br/>            and deleting_node.right<br/>            and deleting_node.is_thread is False<br/>        ):<br/>            predecessor = self.get_predecessor(node=deleting_node)<br/>            replacing_node: Node = self.get_leftmost(node=deleting_node.right)<br/>            # the leftmost node is not the direct child of the deleting node<br/>            if replacing_node.parent != deleting_node:<br/>                if replacing_node.is_thread:<br/>                    self._transplant(<br/>                        deleting_node=replacing_node, replacing_node=None<br/>                    )<br/>                else:<br/>                    self._transplant(<br/>                        deleting_node=replacing_node,<br/>                        replacing_node=replacing_node.right,<br/>                   )<br/>                replacing_node.right = deleting_node.right<br/>                replacing_node.right.parent = replacing_node<br/>                replacing_node.is_thread = False<br/><br/>            self._transplant(<br/>                deleting_node=deleting_node, replacing_node=replacing_node<br/>            )<br/>            replacing_node.left = deleting_node.left<br/>            replacing_node.left.parent = replacing_node<br/>            if predecessor and predecessor.is_thread:<br/>                predecessor.right = replacing_node<br/>        else:<br/>            raise RuntimeError("Invalid case. Should never happened")<br/><br/>def _transplant(self, deleting_node: Node, replacing_node: Optional[Node]) -&gt; None:<br/>    if deleting_node.parent is None:<br/>        self.root = replacing_node<br/>        if self.root:<br/>            self.root.is_thread = False<br/>    elif deleting_node == deleting_node.parent.left:<br/>        deleting_node.parent.left = replacing_node<br/>        if replacing_node:<br/>            if deleting_node.is_thread:<br/>                if replacing_node.is_thread:<br/>                    replacing_node.right = replacing_node.right<br/>    else:  # deleting_node == deleting_node.parent.right<br/>        deleting_node.parent.right = replacing_node<br/>        if replacing_node:<br/>            if deleting_node.is_thread:<br/>                if replacing_node.is_thread:<br/>                    replacing_node.right = replacing_node.right<br/>        else:<br/>            deleting_node.parent.right = deleting_node.right<br/>            deleting_node.parent.is_thread = True<br/><br/>    if replacing_node:<br/>        replacing_node.parent = deleting_node.parent</span></pre><h2 id="4c43" class="kr jf hi bd jg lp lq lr jk ls lt lu jo iq lv lw js iu lx ly jw iy lz ma ka mb bi translated">获得高度</h2><p id="d2c3" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">为了计算一个线程二叉树的树高，我们可以像在<a class="ae jd" href="https://shunsvineyard.info/2021/03/13/build-the-forest-in-python-series-binary-search-tree/#14-get-the-height" rel="noopener ugc nofollow" target="_blank">二叉查找树:获取高度</a>中所做的那样，为每个孩子的高度递归地增加1。如果一个节点有两个子节点，我们使用<a class="ae jd" href="https://docs.python.org/3/library/functions.html#max" rel="noopener ugc nofollow" target="_blank"> max </a>函数从子节点中获取较大的高度，并将最高值增加1。主要区别是我们使用<em class="kh"> is_thread </em>来检查一个节点是否有一个正确的子节点。</p><pre class="ki kj kk kl fd km kn ko kp aw kq bi"><span id="15d1" class="kr jf hi kn b fi ks kt l ku kv">@staticmethod<br/>def get_height(node: Optional[Node]) -&gt; int:<br/>    if node:<br/>        if node.left and node.is_thread is False:<br/>            return (<br/>                max(<br/>                    RightThreadedBinaryTree.get_height(node.left),<br/>                    RightThreadedBinaryTree.get_height(node.right),<br/>                )<br/>                + 1<br/>            )<br/><br/>        if node.left:<br/>            return RightThreadedBinaryTree.get_height(node=node.left) + 1<br/><br/>        if node.is_thread is False:<br/>            return RightThreadedBinaryTree.get_height(node=node.right) + 1<br/>    return 0</span></pre><h2 id="8435" class="kr jf hi bd jg lp lq lr jk ls lt lu jo iq lv lw js iu lx ly jw iy lz ma ka mb bi translated">获取最左边和最右边的节点</h2><p id="7eb4" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">获取最左最右节点的实现类似于<a class="ae jd" href="https://shunsvineyard.info/2021/03/13/build-the-forest-in-python-series-binary-search-tree/#15-get-the-leftmost-and-rightmost-nodes" rel="noopener ugc nofollow" target="_blank">二叉查找树:获取最左最右节点</a>。要得到最右边的节点，除了检查right属性是否为空，我们还需要检查<em class="kh"> is_thread </em>是否为<em class="kh"> True </em>。所以，我们可以像下面这样修改<em class="kh"> get_rightmost </em>函数。</p><pre class="ki kj kk kl fd km kn ko kp aw kq bi"><span id="8e19" class="kr jf hi kn b fi ks kt l ku kv">@staticmethod<br/>def get_rightmost(node: Node) -&gt; Node:<br/>    current_node = node<br/>     while current_node.is_thread is False and current_node.right:<br/>        current_node = current_node.right<br/>    return current_node</span></pre><p id="e3b7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="kh">get _ leftsmall</em>的实现与二叉查找树中的<em class="kh">get _ leftsmall</em>相同。</p><pre class="ki kj kk kl fd km kn ko kp aw kq bi"><span id="98b6" class="kr jf hi kn b fi ks kt l ku kv">@staticmethod<br/>def get_leftmost(node: Node) -&gt; Node:<br/>    current_node = node<br/>    while current_node.left:<br/>        current_node = current_node.left<br/>    return current_node</span></pre><h2 id="6f30" class="kr jf hi bd jg lp lq lr jk ls lt lu jo iq lv lw js iu lx ly jw iy lz ma ka mb bi translated">前任和继任者</h2><p id="de84" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">由于右线程树提供了快速的有序后继访问(如果节点的右属性是线程，则右属性指向节点的有序后继)，如果右属性是线程，则我们可以通过跟随其右属性来获得节点的后继。否则，该节点的后继节点是该节点的右子树的最左边的节点。</p><pre class="ki kj kk kl fd km kn ko kp aw kq bi"><span id="6e2d" class="kr jf hi kn b fi ks kt l ku kv">@staticmethod<br/>def get_successor(node: Node) -&gt; Optional[Node]:<br/>    if node.is_thread:<br/>        return node.right<br/>    else:<br/>        if node.right:<br/>            return RightThreadedBinaryTree.get_leftmost(node=node.right)<br/>        # if node.right is None, it means no successor of the given node.<br/>        return None</span></pre><p id="2a40" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="kh"> get_predecessor </em>的实现与<a class="ae jd" href="https://shunsvineyard.info/2021/03/13/build-the-forest-in-python-series-binary-search-tree/#16-predecessor-and-successor" rel="noopener ugc nofollow" target="_blank">二叉查找树:Predecessor </a>相同。</p><pre class="ki kj kk kl fd km kn ko kp aw kq bi"><span id="2cf3" class="kr jf hi kn b fi ks kt l ku kv">@staticmethod<br/>def get_predecessor(node: Node) -&gt; Optional[Node]:<br/>    if node.left:<br/>        return RightThreadedBinaryTree.get_rightmost(node=node.left)<br/>    parent = node.parent<br/>    while parent and node == parent.left:<br/>        node = parent<br/>        parent = parent.parent<br/>    return parent</span></pre><h2 id="75b1" class="kr jf hi bd jg lp lq lr jk ls lt lu jo iq lv lw js iu lx ly jw iy lz ma ka mb bi translated">有序遍历</h2><p id="2ea3" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">右线索树提供的一个好处是，我们可以在不使用辅助或递归方法的情况下进行有序遍历。算法如下:</p><ol class=""><li id="040b" class="kw kx hi ih b ii ij im in iq ky iu kz iy la jc mc lc ld le bi translated">从整个树的最左边的节点开始。</li><li id="eaf5" class="kw kx hi ih b ii lf im lg iq lh iu li iy lj jc mc lc ld le bi translated">如果右属性是线程，则跟随右属性；如果右边的属性不是线程，那么转到子树最左边的节点。</li><li id="3873" class="kw kx hi ih b ii lf im lg iq lh iu li iy lj jc mc lc ld le bi translated">重复步骤2，直到正确的属性为<em class="kh">无</em>。</li></ol><p id="263a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">下图中的红色箭头演示了线程的有序遍历。</p><figure class="ki kj kk kl fd ll er es paragraph-image"><div class="er es mj"><img src="../Images/35b0f4ae79884ae7104ecd7dafd8b3cf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1142/format:webp/0*A-nQc5CikQobRanX.png"/></div></figure><p id="6bd3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">并且在不使用辅助堆栈或递归的情况下实现函数。</p><pre class="ki kj kk kl fd km kn ko kp aw kq bi"><span id="41d6" class="kr jf hi kn b fi ks kt l ku kv">def inorder_traverse(self) -&gt; traversal.Pairs:<br/>    if self.root:<br/>        current: Optional[Node] = self.get_leftmost(node=self.root)<br/>        while current:<br/>            yield (current.key, current.data)<br/><br/>            if current.is_thread:<br/>                current = current.right<br/>            else:<br/>                if current.right is None:<br/>                    break<br/>                current = self.get_leftmost(current.right)</span></pre><h2 id="ce75" class="kr jf hi bd jg lp lq lr jk ls lt lu jo iq lv lw js iu lx ly jw iy lz ma ka mb bi translated">前序遍历</h2><p id="b556" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">右线程树还提供了一种更简单的方法来进行前序遍历，并且比按序遍历更简单。</p><ol class=""><li id="ebe9" class="kw kx hi ih b ii ij im in iq ky iu kz iy la jc mc lc ld le bi translated">从根开始。</li><li id="7272" class="kw kx hi ih b ii lf im lg iq lh iu li iy lj jc mc lc ld le bi translated">如果left属性不为空，则转到左边的子元素。</li><li id="8c13" class="kw kx hi ih b ii lf im lg iq lh iu li iy lj jc mc lc ld le bi translated">如果left属性为空，则跟随线程到右边。</li><li id="2ee6" class="kw kx hi ih b ii lf im lg iq lh iu li iy lj jc mc lc ld le bi translated">重复步骤2和3，直到右侧属性为空。</li></ol><p id="3d36" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">下图中下面的红色箭头表示的是线程化方式的有序遍历。</p><figure class="ki kj kk kl fd ll er es paragraph-image"><div class="er es md"><img src="../Images/ca70f306e4efbdab38c45f5df84ac226.png" data-original-src="https://miro.medium.com/v2/resize:fit:1042/format:webp/0*aqWY6yuwc9WHscHm.png"/></div></figure><p id="32b2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">前序遍历可以如下实现。</p><pre class="ki kj kk kl fd km kn ko kp aw kq bi"><span id="09de" class="kr jf hi kn b fi ks kt l ku kv">def preorder_traverse(self) -&gt; traversal.Pairs:<br/>    current = self.root<br/>    while current:<br/>        yield (current.key, current.data)<br/><br/>        if current.is_thread:<br/>            # If a node is thread, it must have a right child.<br/>            current = current.right.right  # type: ignore<br/>        else:<br/>            current = current.left</span></pre><h1 id="1158" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">左单线程二叉查找树</h1><p id="c367" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">左线索树与右线索树对称。如果左线程树中任一节点的左属性为空，则左属性为线程并指向该节点的有序前任，并且<em class="kh"> is_thread </em>变量设置为<em class="kh"> True </em>。下图中可以看到一个左螺纹树。</p><figure class="ki kj kk kl fd ll er es paragraph-image"><div class="er es mk"><img src="../Images/78c5d315962fe13763225dfe3a163567.png" data-original-src="https://miro.medium.com/v2/resize:fit:1002/format:webp/0*2fxfurzZQQiK-zpI.png"/></div></figure><p id="d68e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">左线程树的类布局与右线程树几乎相同。唯一的区别是左边的线程树提供了一个简单的反向有序遍历，而不是有序和前序遍历。</p><pre class="ki kj kk kl fd km kn ko kp aw kq bi"><span id="7b9e" class="kr jf hi kn b fi ks kt l ku kv">class LeftThreadedBinaryTree:<br/><br/>    def __init__(self) -&gt; None:<br/>        self.root: Optional[Node] = None<br/><br/>    def __repr__(self) -&gt; str:<br/>        """Provie the tree representation to visualize its layout."""<br/>        if self.root:<br/>            return (<br/>                f"{type(self)}, root={self.root}, "<br/>                f"tree_height={str(self.get_height(self.root))}"<br/>            )<br/>        return "empty tree"<br/><br/>    def search(self, key: Any) -&gt; Optional[Node]:<br/>        …<br/><br/>    def insert(self, key: Any, data: Any) -&gt; None:<br/>        …<br/><br/>    def delete(self, key: Any) -&gt; None:<br/>        …<br/><br/>    @staticmethod<br/>    def get_leftmost(node: Node) -&gt; Node:<br/>        …<br/><br/>    @staticmethod<br/>    def get_rightmost(node: Node) -&gt; Node:<br/>        …<br/><br/>    @staticmethod<br/>    def get_successor(node: Node) -&gt; Optional[Node]:<br/>        …<br/><br/>    @staticmethod<br/>    def get_predecessor(node: Node) -&gt; Optional[Node]:<br/>        …<br/><br/>    @staticmethod<br/>    def get_height(node: Optional[Node]) -&gt; int:<br/>        …<br/><br/>    def reverse_inorder_traverse(self) -&gt; traversal.Pairs:<br/>        …</span></pre><h2 id="77b5" class="kr jf hi bd jg lp lq lr jk ls lt lu jo iq lv lw js iu lx ly jw iy lz ma ka mb bi translated">插入</h2><p id="93b5" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">插入操作类似于右螺纹树。不同的是线在左边。</p><ol class=""><li id="fdf4" class="kw kx hi ih b ii ij im in iq ky iu kz iy la jc mc lc ld le bi translated">通过从根开始遍历树，并将新节点的键与沿途每个节点的键进行比较，找到插入新节点的适当位置(即新节点的父节点)。当走到左边的子树时，同样检查<em class="kh"> is_thread </em>变量。如果变量<em class="kh">为真</em>，我们到达叶级，叶节点就是父节点。</li><li id="0a70" class="kw kx hi ih b ii lf im lg iq lh iu li iy lj jc mc lc ld le bi translated">找到父节点后，更新父节点的左侧(或右侧，取决于关键点)以指向新节点。</li><li id="239e" class="kw kx hi ih b ii lf im lg iq lh iu li iy lj jc mc lc ld le bi translated">更新新节点的父属性以指向父节点。</li><li id="6b84" class="kw kx hi ih b ii lf im lg iq lh iu li iy lj jc mc lc ld le bi translated">如果新节点是其父节点的右子节点，将新节点的左属性指向父节点，并将<em class="kh"> is_thread </em>变量设置为<em class="kh"> True </em>。</li><li id="1d41" class="kw kx hi ih b ii lf im lg iq lh iu li iy lj jc mc lc ld le bi translated">如果新节点是父节点的左子节点，则将父节点的左属性复制到新节点的左属性中(父节点的左属性在插入前必须是线程)，并设置<em class="kh">为_线程</em> <em class="kh">真</em>。更新父节点的left属性以指向新节点。</li></ol><p id="17df" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">下图演示了节点插入的步骤。</p><figure class="ki kj kk kl fd ll er es paragraph-image"><div class="er es ml"><img src="../Images/b66f1eac02f2ae9e6ecd16b23528d5a7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1102/0*A2uXv-jZxwJfSaMI.gif"/></div></figure><p id="5427" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">实现如下。</p><pre class="ki kj kk kl fd km kn ko kp aw kq bi"><span id="986f" class="kr jf hi kn b fi ks kt l ku kv">def insert(self, key: Any, data: Any) -&gt; None:<br/>    new_node = Node(key=key, data=data)<br/>    parent: Optional[Node] = None<br/>    current: Optional[Node] = self.root<br/><br/>    while current:<br/>        parent = current<br/>        if new_node.key &lt; current.key:<br/>            # If the node is thread, meaning it's a leaf node.<br/>            if current.is_thread:<br/>                current = None<br/>            else:<br/>                current = current.left<br/>        elif new_node.key &gt; current.key:<br/>            current = current.right<br/>        else:<br/>            raise tree_exceptions.DuplicateKeyError(key=new_node.key)<br/>    new_node.parent = parent<br/>    # If the tree is empty<br/>    if parent is None:<br/>        self.root = new_node<br/>    elif new_node.key &gt; parent.key:<br/>        parent.right = new_node<br/>        # Update thread<br/>        new_node.left = parent<br/>        new_node.is_thread = True<br/><br/>    else:<br/>        # Update thread<br/>        new_node.is_thread = parent.is_thread<br/>        new_node.left = parent.left<br/>        parent.is_thread = False<br/>        # Parent's left must be set after thread update<br/>        parent.left = new_node</span></pre><h2 id="12d4" class="kr jf hi bd jg lp lq lr jk ls lt lu jo iq lv lw js iu lx ly jw iy lz ma ka mb bi translated">搜索</h2><p id="f26e" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">搜索操作类似于右线程二叉树，所以我们需要检查<em class="kh"> is_thread </em>变量来确定我们是否到达了叶子。</p><ol class=""><li id="8fd1" class="kw kx hi ih b ii ij im in iq ky iu kz iy la jc mc lc ld le bi translated">从根开始遍历树，并沿着树遍历将键与每个节点的键进行比较</li><li id="2451" class="kw kx hi ih b ii lf im lg iq lh iu li iy lj jc mc lc ld le bi translated">如果一个键匹配，我们就找到了节点。</li><li id="bfa4" class="kw kx hi ih b ii lf im lg iq lh iu li iy lj jc mc lc ld le bi translated">如果到达叶子后没有匹配的键(如果is_thread为True，也意味着该节点是叶子节点)，则它不存在于树中。</li></ol><p id="633c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">该实现非常类似于右边的线索树中的搜索。</p><pre class="ki kj kk kl fd km kn ko kp aw kq bi"><span id="e21b" class="kr jf hi kn b fi ks kt l ku kv">def search(self, key: Any) -&gt; Optional[Node]:<br/>    current = self.root<br/><br/>    while current:<br/>        if key == current.key:<br/>            return current<br/>        elif key &lt; current.key:<br/>            if current.is_thread is False:<br/>                current = current.left<br/>            else:<br/>                break<br/>        else:  # key &gt; current.key:<br/>            current = current.right<br/>    return None</span></pre><h2 id="228e" class="kr jf hi bd jg lp lq lr jk ls lt lu jo iq lv lw js iu lx ly jw iy lz ma ka mb bi translated">删除</h2><p id="5c0b" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">类似地，左线索二叉树的删除与右线索二叉树对称，并且有三种情况:没有孩子、只有一个孩子、两个孩子。</p><p id="bc10" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">案例1:没有孩子</p><figure class="ki kj kk kl fd ll er es paragraph-image"><div class="er es mm"><img src="../Images/563a1dcab03d1e8ecab7cb208918dfa2.png" data-original-src="https://miro.medium.com/v2/resize:fit:962/format:webp/0*Da_IQ4BbSgSRmsnp.png"/></div></figure><p id="5fac" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">案例2a:只剩下一个孩子</p><figure class="ki kj kk kl fd ll er es paragraph-image"><div class="er es mf"><img src="../Images/97164a4718c807ba3810f028848bb58f.png" data-original-src="https://miro.medium.com/v2/resize:fit:802/format:webp/0*HhOhZz0FjsYkXb7W.png"/></div></figure><p id="8f47" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">案例2b:只有一个正确的孩子</p><figure class="ki kj kk kl fd ll er es paragraph-image"><div class="er es mh"><img src="../Images/5dc5167e649433324d110ffa9e5bbdf8.png" data-original-src="https://miro.medium.com/v2/resize:fit:952/format:webp/0*mD3xNaGyEeGZgLGe.png"/></div></figure><p id="269d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">案例3:两个孩子</p><p id="f7fe" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">3.a删除节点的右边子节点也是右边子树中最左边的节点。</p><figure class="ki kj kk kl fd ll er es paragraph-image"><div class="er es lo"><img src="../Images/b0970d396c438a8085670cb1965e2c90.png" data-original-src="https://miro.medium.com/v2/resize:fit:1082/format:webp/0*j6lEXOk-RHuMcJjl.png"/></div></figure><p id="23c2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">3.b .删除节点的右子节点也有两个子节点。</p><p id="cddc" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">替换节点没有子节点:</strong></p><figure class="ki kj kk kl fd ll er es paragraph-image"><div class="er es mn"><img src="../Images/abc40cdc6282794df0cbf9cdcaa0d856.png" data-original-src="https://miro.medium.com/v2/resize:fit:988/format:webp/0*RDz0uQm3SUG-DnoM.png"/></div></figure><p id="647b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">替换节点只有一个右子节点</strong>:</p><figure class="ki kj kk kl fd ll er es paragraph-image"><div class="er es mo"><img src="../Images/916752ada5b7e4c070c249716897c3c8.png" data-original-src="https://miro.medium.com/v2/resize:fit:594/format:webp/0*353FX_krTluqDZSt.png"/></div></figure><p id="41b6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">像右线程二叉树一样，我们也使用在<a class="ae jd" href="https://shunsvineyard.info/2021/03/13/build-the-forest-in-python-series-binary-search-tree/#9-delete" rel="noopener ugc nofollow" target="_blank">二叉查找树删除</a>中使用的移植技术，用要删除的节点替换子树。</p><pre class="ki kj kk kl fd km kn ko kp aw kq bi"><span id="7d38" class="kr jf hi kn b fi ks kt l ku kv">def delete(self, key: Any) -&gt; None:<br/>    if self.root and (deleting_node := self.search(key=key)):<br/>        # Case 1: no child<br/>        if deleting_node.right is None and (<br/>            deleting_node.left is None or deleting_node.is_thread<br/>        ):<br/>            self._transplant(deleting_node=deleting_node, replacing_node=None)<br/><br/>        # Case 2a: only one left child<br/>        elif (deleting_node.right is None) and (deleting_node.is_thread is False):<br/>            self._transplant(<br/>                deleting_node=deleting_node, replacing_node=deleting_node.left<br/>            )<br/><br/>        # Case 2b: only one right child<br/>        elif deleting_node.right and (<br/>            deleting_node.is_thread or deleting_node.left is None<br/>            # deleting_node.left is None means the deleting node is the root.<br/>        ):<br/>            successor = self.get_successor(node=deleting_node)<br/>            if successor:<br/>                successor.left = deleting_node.left<br/>            self._transplant(<br/>                deleting_node=deleting_node, replacing_node=deleting_node.right<br/>            )<br/><br/>        # Case 3: two children<br/>        elif deleting_node.right and deleting_node.left:<br/>            replacing_node: Node = self.get_leftmost(node=deleting_node.right)<br/>            successor = self.get_successor(node=replacing_node)<br/>            # the leftmost node is not the direct child of the deleting node<br/>            if replacing_node.parent != deleting_node:<br/>                self._transplant(<br/>                    deleting_node=replacing_node,<br/>                    replacing_node=replacing_node.right,<br/>                )<br/>                replacing_node.right = deleting_node.right<br/>                replacing_node.right.parent = replacing_node<br/><br/>            self._transplant(<br/>                deleting_node=deleting_node, replacing_node=replacing_node<br/>            )<br/>            replacing_node.left = deleting_node.left<br/>            replacing_node.left.parent = replacing_node<br/>            replacing_node.is_thread = False<br/>            if successor and successor.is_thread:<br/>                successor.left = replacing_node<br/>        else:<br/>            raise RuntimeError("Invalid case. Should never happened")<br/><br/>def _transplant(self, deleting_node: Node, replacing_node: Optional[Node]) -&gt; None:<br/>    if deleting_node.parent is None:<br/>        self.root = replacing_node<br/>        if self.root:<br/>            self.root.is_thread = False<br/>    elif deleting_node == deleting_node.parent.left:<br/>        deleting_node.parent.left = replacing_node<br/>        if replacing_node:<br/>            if deleting_node.is_thread:<br/>                if replacing_node.is_thread:<br/>                    replacing_node.left = deleting_node.left<br/>        else:<br/>            deleting_node.parent.left = deleting_node.left<br/>            deleting_node.parent.is_thread = True<br/>    else:  # deleting_node == deleting_node.parent.right<br/>        deleting_node.parent.right = replacing_node<br/>        if replacing_node:<br/>            if deleting_node.is_thread:<br/>                if replacing_node.is_thread:<br/>                    replacing_node.left = deleting_node.left<br/><br/>    if replacing_node:<br/>        replacing_node.parent = deleting_node.parent</span></pre><h2 id="87b5" class="kr jf hi bd jg lp lq lr jk ls lt lu jo iq lv lw js iu lx ly jw iy lz ma ka mb bi translated">获得高度</h2><p id="f2e8" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated"><em class="kh"> get_height </em>函数与右线程二叉树对称。</p><pre class="ki kj kk kl fd km kn ko kp aw kq bi"><span id="72e3" class="kr jf hi kn b fi ks kt l ku kv">@staticmethod<br/>def get_height(node: Optional[Node]) -&gt; int:<br/>    if node:<br/>        if node.right and node.is_thread is False:<br/>            return (<br/>                max(<br/>                    LeftThreadedBinaryTree.get_height(node.left),<br/>                    LeftThreadedBinaryTree.get_height(node.right),<br/>                )<br/>                + 1<br/>            )<br/><br/>        if node.right:<br/>            return LeftThreadedBinaryTree.get_height(node=node.right) + 1<br/><br/>        if node.is_thread is False:<br/>            return LeftThreadedBinaryTree.get_height(node=node.left) + 1<br/><br/>    return 0</span></pre><h2 id="b7d1" class="kr jf hi bd jg lp lq lr jk ls lt lu jo iq lv lw js iu lx ly jw iy lz ma ka mb bi translated">获取最左边和最右边的节点</h2><p id="f06a" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">由于左线程树与右线程树是对称的，所以我们需要检查<em class="kh"> is_thread </em>是否为<em class="kh"> True </em>，并在尝试获取最左边的节点时检查left属性是否为空。</p><pre class="ki kj kk kl fd km kn ko kp aw kq bi"><span id="2ed6" class="kr jf hi kn b fi ks kt l ku kv">@staticmethod<br/>def get_leftmost(node: Node) -&gt; Node:<br/>    current_node = node<br/><br/>    while current_node.left and current_node.is_thread is False:<br/>        current_node = current_node.left<br/>    return current_node</span></pre><p id="af9f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="kh">获取_最右侧</em>的实现与二叉查找树中的<em class="kh">获取_最右侧</em>相同。</p><pre class="ki kj kk kl fd km kn ko kp aw kq bi"><span id="1c16" class="kr jf hi kn b fi ks kt l ku kv">@staticmethod<br/>def get_rightmost(node: Node) -&gt; Node:<br/>    current_node = node<br/>    while current_node.right:<br/>        current_node = current_node.right<br/>    return current_node</span></pre><h2 id="3d8e" class="kr jf hi bd jg lp lq lr jk ls lt lu jo iq lv lw js iu lx ly jw iy lz ma ka mb bi translated">前任和继任者</h2><p id="9e92" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">根据左螺纹树的定义:节点的空左属性指向其有序的前一个节点。如果节点的<em class="kh">是_线程</em>是<em class="kh">真</em>，我们可以通过跟踪线程简单地得到节点的前任。</p><pre class="ki kj kk kl fd km kn ko kp aw kq bi"><span id="2ffd" class="kr jf hi kn b fi ks kt l ku kv">@staticmethod<br/>def get_predecessor(node: Node) -&gt; Optional[Node]:<br/>    if node.is_thread:<br/>        return node.left<br/>    else:<br/>        if node.left:<br/>            return LeftThreadedBinaryTree.get_rightmost(node=node.left)<br/>        # if node.left is None, it means no predecessor of the given node.<br/>        return None</span></pre><p id="c73f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="kh"> get_successor </em>的实现与<a class="ae jd" href="https://shunsvineyard.info/2021/03/13/build-the-forest-in-python-series-binary-search-tree/#16-predecessor-and-successor" rel="noopener ugc nofollow" target="_blank">二叉查找树:Successor </a>相同。</p><pre class="ki kj kk kl fd km kn ko kp aw kq bi"><span id="72f0" class="kr jf hi kn b fi ks kt l ku kv">@staticmethod<br/>def get_successor(node: Node) -&gt; Optional[Node]:<br/>    if node.right:<br/>        return LeftThreadedBinaryTree.get_leftmost(node=node.right)<br/>    parent = node.parent<br/>    while parent and node == parent.right:<br/>        node = parent<br/>        parent = parent.parent<br/>    return parent</span></pre><h2 id="68b5" class="kr jf hi bd jg lp lq lr jk ls lt lu jo iq lv lw js iu lx ly jw iy lz ma ka mb bi translated">反向有序遍历</h2><p id="9c41" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">对于左线程，左线程树执行反向有序遍历既不需要递归也不需要辅助堆栈。</p><ol class=""><li id="ab26" class="kw kx hi ih b ii ij im in iq ky iu kz iy la jc mc lc ld le bi translated">从整个树的最右边的节点开始。</li><li id="388d" class="kw kx hi ih b ii lf im lg iq lh iu li iy lj jc mc lc ld le bi translated">如果左边的属性是线程，则跟随线程；如果左边的属性不是线程，那么转到子树最右边的节点。</li><li id="1afa" class="kw kx hi ih b ii lf im lg iq lh iu li iy lj jc mc lc ld le bi translated">重复步骤2，直到左侧属性为<em class="kh">无</em>。</li></ol><p id="5bb2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">下图中的红色箭头演示了反向顺序遍历的线程方式。</p><figure class="ki kj kk kl fd ll er es paragraph-image"><div class="er es mg"><img src="../Images/90ee38422076ecf4f08cf97059a0aaec.png" data-original-src="https://miro.medium.com/v2/resize:fit:1162/format:webp/0*bQV0NZo5HKd36KfB.png"/></div></figure><p id="2469" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">下面是实现。</p><pre class="ki kj kk kl fd km kn ko kp aw kq bi"><span id="66b9" class="kr jf hi kn b fi ks kt l ku kv">def reverse_inorder_traverse(self) -&gt; traversal.Pairs:<br/>    if self.root:<br/>        current: Optional[Node] = self.get_rightmost(node=self.root)<br/>        while current:<br/>            yield (current.key, current.data)<br/><br/>            if current.is_thread:<br/>                current = current.left<br/>            else:<br/>                if current.left is None:<br/>                    break<br/>                current = self.get_rightmost(current.left)</span></pre><h1 id="a659" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">试验</h1><p id="b8d3" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">和往常一样，我们应该尽可能多地对代码进行单元测试。这里，我们使用在<a class="ae jd" href="https://shunsvineyard.info/2021/03/13/build-the-forest-in-python-series-binary-search-tree/" rel="noopener ugc nofollow" target="_blank">构建二叉查找树</a>中创建的<a class="ae jd" href="https://github.com/shunsvineyard/forest-python/blob/main/tests/conftest.py" rel="noopener ugc nofollow" target="_blank"> conftest.py </a>中的<em class="kh"> basic_tree </em>函数来测试我们的单线程二叉树。检查<a class="ae jd" href="https://github.com/shunsvineyard/forest-python/blob/main/tests/test_single_threaded_binary_trees.py" rel="noopener ugc nofollow" target="_blank">test _ single _ threaded _ binary _ trees . py</a>进行完整的单元测试。</p><h1 id="5233" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">分析</h1><p id="91ca" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">线程二叉树操作的运行时间与普通二叉查找树相同。</p><figure class="ki kj kk kl fd ll er es paragraph-image"><div role="button" tabindex="0" class="mq mr di ms bf mt"><div class="er es mp"><img src="../Images/35582b416f34e6ec32484b319aab34a0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rjBuEwhYACR0DlMIh24Qkw.png"/></div></div></figure><p id="f1e9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">尽管右线程树提供了一种更容易的方法来检索节点的后继节点，而左线程树提供了一种更直接的方法来获得节点的前任节点，但是线程并没有节省很多运行时间。主要原因是这些函数还需要调用<em class="kh"> get_leftmost </em>和<em class="kh"> get_rightmost </em>函数，平均运行时间为O(lg n)，最坏情况下运行时间为O(n)。</p><p id="59bd" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">然而，线程确实有助于特定遍历的空间复杂度。</p><figure class="ki kj kk kl fd ll er es paragraph-image"><div role="button" tabindex="0" class="mq mr di ms bf mt"><div class="er es mu"><img src="../Images/c34b0adea40e2abee298241a86430bbc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0xGNeMF5jVmHB3EFpg487A.png"/></div></div></figure><h1 id="e23d" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">例子</h1><p id="83d2" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">向二叉查找树添加线程会使其实现变得更加复杂，但当遍历非常重要，但又涉及到空间消耗时，它们可能是一种解决方案。例如，我们希望构建一个数据库，用户可以频繁地以升序或降序访问数据，但是我们的内存有限(即，由于空间消耗的原因，无法使用辅助堆栈或递归方法)。在这种情况下，我们可以使用线程二叉树来实现升序和降序访问的索引。</p><pre class="ki kj kk kl fd km kn ko kp aw kq bi"><span id="f267" class="kr jf hi kn b fi ks kt l ku kv">from typing import Any<br/><br/>from forest.binary_trees import single_threaded_binary_trees<br/>from forest.binary_trees import traversal<br/><br/>class MyDatabase:<br/>    """Example using threaded binary trees to build an index."""<br/><br/>    def __init__(self) -&gt; None:<br/>        self._left_bst = single_threaded_binary_trees.LeftThreadedBinaryTree()<br/>        self._right_bst = single_threaded_binary_trees.RightThreadedBinaryTree()<br/><br/>    def _persist(self, payload: Any) -&gt; str:<br/>        """Fake function pretent storing data to file system.<br/><br/>        Returns<br/>        -------<br/>        str<br/>            Path to the payload.<br/>        """<br/>        return f"path_to_{payload}"<br/><br/>    def insert_data(self, key: Any, payload: Any) -&gt; None:<br/>        """Insert data.<br/><br/>        Parameters<br/>        ----------<br/>        key: Any<br/>            Unique key for the payload<br/>        payload: Any<br/>            Any data<br/>        """<br/>        path = self._persist(payload=payload)<br/>        self._left_bst.insert(key=key, data=path)<br/>        self._right_bst.insert(key=key, data=path)<br/><br/>    def dump(self, ascending: bool = True) -&gt; traversal.Pairs:<br/>        """Dump the data.<br/><br/>        Parameters<br/>        ----------<br/>        ascending: bool<br/>            The order of data.<br/><br/>        Yields<br/>        ------<br/>        Pairs<br/>            The next (key, data) pair.<br/>        """<br/>        if ascending:<br/>            return self._right_bst.inorder_traverse()<br/>        else:<br/>            return self._left_bst.reverse_inorder_traverse()<br/><br/>if __name__ == "__main__":<br/><br/>    # Initialize the database.<br/>    my_database = MyDatabase()<br/><br/>    # Add some items.<br/>    my_database.insert_data("Adam", "adam_data")<br/>    my_database.insert_data("Bob", "bob_data")<br/>    my_database.insert_data("Peter", "peter_data")<br/>    my_database.insert_data("David", "david_data")<br/><br/>    # Dump the items in ascending order.<br/>    print("Ascending...")<br/>    for contact in my_database.dump():<br/>        print(contact)<br/><br/>    print("\nDescending...")<br/>    # Dump the data in decending order.<br/>    for contact in my_database.dump(ascending=False):<br/>        print(contact)</span></pre><p id="3986" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">(完整示例可从<a class="ae jd" href="https://github.com/shunsvineyard/forest-python/blob/main/examples/single_tbst_database.py" rel="noopener ugc nofollow" target="_blank"> single_tbst_database.py </a>获得)</p><p id="3062" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">输出将如下所示。</p><pre class="ki kj kk kl fd km kn ko kp aw kq bi"><span id="5500" class="kr jf hi kn b fi ks kt l ku kv">Ascending...<br/>('Adam', 'path_to_adam_data')<br/>('Bob', 'path_to_bob_data')<br/>('David', 'path_to_david_data')<br/>('Peter', 'path_to_peter_data')<br/><br/>Descending...<br/>('Peter', 'path_to_peter_data')<br/>('David', 'path_to_david_data')<br/>('Bob', 'path_to_bob_data')<br/>('Adam', 'path_to_adam_data')</span></pre><h1 id="1fce" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">摘要</h1><p id="0a81" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">尽管添加线程会增加复杂性，并且不会提高运行时性能，但是线程二叉树利用了浪费的左或右属性，并且提供了一种简单的方法来检索前一个或后一个，并且提供了一种不使用堆栈或递归方法来执行特定遍历的解决方案。当涉及到空间复杂性，并且特定遍历(例如，有序遍历)很关键时，线程二叉树可能是一种解决方案。</p><p id="780c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">下一篇文章将构建具有单线程二叉树优点的双线程二叉树，也更复杂。</p></div><div class="ab cl mv mw gp mx" role="separator"><span class="my bw bk mz na nb"/><span class="my bw bk mz na nb"/><span class="my bw bk mz na"/></div><div class="hb hc hd he hf"><p id="e0b1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="kh">原载于2021年4月2日</em><a class="ae jd" href="https://shunsvineyard.info/2021/04/02/build-the-forest-in-python-series-single-threaded-binary-search-trees/" rel="noopener ugc nofollow" target="_blank"><em class="kh">https://shunsvineyard . info</em></a><em class="kh">。</em></p></div></div>    
</body>
</html>