<html>
<head>
<title>Gossip Protocol in distributed systems</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">分布式系统中的流言协议</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/gossip-protocol-in-distributed-systems-e2b0665c7135?source=collection_archive---------1-----------------------#2022-04-23">https://medium.com/nerd-for-tech/gossip-protocol-in-distributed-systems-e2b0665c7135?source=collection_archive---------1-----------------------#2022-04-23</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/e305f45c8dc402690014555e7b058f68.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sy9fDAy1KLb7mYflAP_F_A.jpeg"/></div></div></figure><h1 id="73cc" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">问题</h1><p id="78eb" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">在一个分布式系统场景中，人们能想到的最基本的问题有:<br/> 1。系统状态:系统节点如何知道其他系统节点的状态，无论它们是死的还是活的。<br/> 2。通信:系统节点如何与其他节点交互。</p><p id="887c" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">对于一个希望使用分布式系统的系统来说，上述问题并不重要，它所关心的只是最终结果。但是对于一个分布式系统，这是评估最终结果的一个核心问题，不管是数据库、搜索引擎、对象存储、负载平衡器还是其他什么。</p><p id="c929" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">针对上述问题，可以有两种可能的解决方案:<br/> 1 .管理系统状态的<strong class="jq hj">集中式系统，例如卡夫卡中的动物园管理员。这样的问题是<strong class="jq hj">单点故障</strong>。但更好的一面是，这种设置倾向于CAP定理的CP侧，提供了更高的一致性保证。<br/> 2。用于跟踪系统状态的<strong class="jq hj">点对点</strong>解决方案。这个解决方案倾向于提供最终一致性的CAP定理的AP侧。但是解决方案是<strong class="jq hj">高度可扩展和更有弹性的</strong>。基于Gossip协议的算法属于这一类，并且在<strong class="jq hj"> cassandra </strong>中被广泛使用。</strong></p><p id="7d2a" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">在分布式系统中，至少需要两个独立的信息源来标记一个节点。仅仅说因为你的节点联系不上另一个节点就说明另一个节点宕机了是不够的。很有可能你的节点坏了，另一个节点没事。但是，如果系统中的其他节点也发现另一个节点已经死亡，那么您可以有把握地断定该节点已经死亡。这里隐藏着许多复杂的难以调试的bug。你怎么知道其他节点在看什么？通过八卦协议交换这种可达性数据。</p></div><div class="ab cl kr ks gp kt" role="separator"><span class="ku bw bk kv kw kx"/><span class="ku bw bk kv kw kx"/><span class="ku bw bk kv kw"/></div><div class="hb hc hd he hf"><h1 id="b233" class="iq ir hi bd is it ky iv iw ix kz iz ja jb la jd je jf lb jh ji jj lc jl jm jn bi translated">八卦协议</h1><p id="c529" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">Gossip是一种点对点的通信协议，在这种协议中，节点定期交换关于它们自己以及它们所知道的其他节点的状态信息。</p><p id="4eec" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">基于Gossip协议的算法是最健壮和可扩展的算法之一，用于强有力的最终一致的成员列表、故障检测，并且可以在gossip消息之上携带任何信息。</p><p id="33b9" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">流言是让每个节点将它碰巧拥有的最新信息发送给一些其他节点，最终将这些信息传播到整个网络。这是节点从有限的局部交互中构建全局地图的一种方式。</p><p id="4bb8" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">流言协议最终充其量是一致的，但也不一定是一致的。如果有一个分区，子分区中的节点仍然会愉快地互相八卦。因此，一个请求击中一个分区的一边可能会得到与击中另一边完全不同的答案。</p><h2 id="e33b" class="le ir hi bd is lf lg lh iw li lj lk ja jz ll lm je kd ln lo ji kh lp lq jm lr bi translated">关于协议的高级细节</h2><ul class=""><li id="2bce" class="ls lt hi jq b jr js jv jw jz lu kd lv kh lw kl lx ly lz ma bi translated">在集群中，每个成员都有一个已知成员及其地址和一些元数据的子集列表。</li><li id="a47f" class="ls lt hi jq b jr mb jv mc jz md kd me kh mf kl lx ly lz ma bi translated">每个成员根据不同节点发出的数据定期更新其邻居心跳计数器列表，并将更新后的信息发送给其他邻居。</li><li id="b447" class="ls lt hi jq b jr mb jv mc jz md kd me kh mf kl lx ly lz ma bi translated">在接收到这样的八卦消息时，节点将消息中的列表与它自己的列表合并，并为每个成员采用最大心跳计数器。</li><li id="e2f7" class="ls lt hi jq b jr mb jv mc jz md kd me kh mf kl lx ly lz ma bi translated">只要节点的心跳计数器持续增加，就可以保证它是健康的，如果心跳没有增加超过某个阈值时间段，则认为它是死的。</li><li id="e58f" class="ls lt hi jq b jr mb jv mc jz md kd me kh mf kl lx ly lz ma bi translated">显然，您应该将节点属性传输给其他节点。像平均负载、空闲内存等统计数据。例如，允许本地节点决定将工作发送到哪里。如果一个节点空闲，就给它发送工作(只要每个人不同时给它发送工作)。这个局部决策角度是规模化的关键。没有中央控制器。本地节点基于本地数据做出本地决策。这可以扩展到gossip协议所能扩展的程度。</li></ul></div><div class="ab cl kr ks gp kt" role="separator"><span class="ku bw bk kv kw kx"/><span class="ku bw bk kv kw kx"/><span class="ku bw bk kv kw"/></div><div class="hb hc hd he hf"><h2 id="7cc5" class="le ir hi bd is lf lg lh iw li lj lk ja jz ll lm je kd ln lo ji kh lp lq jm lr bi translated">了解一些八卦算法的相关链接</h2><p id="55a3" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated"><a class="ae mg" href="https://en.wikipedia.org/wiki/Gossip_protocol" rel="noopener ugc nofollow" target="_blank"> Gossip协议wiki</a><a class="ae mg" href="https://cwiki.apache.org/confluence/display/cassandra/ArchitectureGossip" rel="noopener ugc nofollow" target="_blank"><br/>Gossip in Cassandra</a><br/><a class="ae mg" href="https://dl.acm.org/doi/10.1145/1317379.1317382" rel="noopener ugc nofollow" target="_blank">Gossip协议的局限性</a> <br/> <a class="ae mg" href="https://managementfromscratch.wordpress.com/2016/04/01/introduction-to-gossip/#strength" rel="noopener ugc nofollow" target="_blank">协议底层细节的有趣阅读</a> <br/> <a class="ae mg" href="https://www.baeldung.com/cs/distributed-systems-guide" rel="noopener ugc nofollow" target="_blank">分布式系统基础</a></p></div><div class="ab cl kr ks gp kt" role="separator"><span class="ku bw bk kv kw kx"/><span class="ku bw bk kv kw kx"/><span class="ku bw bk kv kw"/></div><div class="hb hc hd he hf"><h1 id="acd7" class="iq ir hi bd is it ky iv iw ix kz iz ja jb la jd je jf lb jh ji jj lc jl jm jn bi translated">结尾注释</h1><p id="1be6" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">这篇文章试图提供对流言协议的高度理解。由于协议有多种实现方式，因此不可能解释每一种变体。深入探讨这个主题的方法是选择一个特定的算法并深入研究。已经提供了一些相关的链接，但是列表是巨大的，并且依赖于使用它们的协议实现的特定软件。</p><p id="6f9f" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">希望这有所帮助。如果你在帖子中发现任何不一致的地方，请在评论中告诉我。感谢阅读！！！</p></div></div>    
</body>
</html>