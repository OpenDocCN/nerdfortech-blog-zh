<html>
<head>
<title>Script Communication in Unity using GetComponent</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用GetComponent编写Unity中的通信脚本</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/script-communication-in-unity-using-getcomponent-45fba58f322a?source=collection_archive---------12-----------------------#2021-05-22">https://medium.com/nerd-for-tech/script-communication-in-unity-using-getcomponent-45fba58f322a?source=collection_archive---------12-----------------------#2021-05-22</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ih ii ij ik er es paragraph-image"><div role="button" tabindex="0" class="il im di in bf io"><div class="er es ig"><img src="../Images/a87ccb1cbda5512983189e1b9c5fca99.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9ymouVqV_VdG994sjGeuBw.png"/></div></div></figure></div><div class="ab cl ir is gp it" role="separator"><span class="iu bw bk iv iw ix"/><span class="iu bw bk iv iw ix"/><span class="iu bw bk iv iw"/></div><div class="hb hc hd he hf"><p id="69a6" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated">组件是所有游戏对象的基类。</p><p id="7938" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated">它定义了游戏对象的每个方面及其行为。基本上任何附加到游戏对象上的脚本都会编译成一种<em class="jw">组件</em>。</p><figure class="jy jz ka kb fd ik er es paragraph-image"><div role="button" tabindex="0" class="il im di in bf io"><div class="er es jx"><img src="../Images/0763022a7877b0a3df7673e45f813397.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tzwWPyrgbKuFZTlhNbnbtA.png"/></div></div></figure><p id="127e" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated">然而，如果我们只想存储数据，我们可以创建一个名为<strong class="ja hj"> ScriptableObject </strong>的可访问类，这个类<em class="jw">不直接与游戏对象</em>关联。我们稍后肯定会对此进行调查，但如果您希望了解更多信息，请点击此处。</p><p id="63ff" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated">如果您想了解更多关于使用某个特定组件的信息，您可以随时点击<strong class="ja hj">中的小图标来访问组件的参考页面。</strong>在检查器中的组件头上。</p><figure class="jy jz ka kb fd ik er es paragraph-image"><div class="er es kd"><img src="../Images/84923cd7e3376d555574c5de64fb0ec4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1380/format:webp/1*CtMrDzVURHOiphla4gbcZA.png"/></div></figure><blockquote class="ke kf kg"><p id="6a08" class="iy iz jw ja b jb jc jd je jf jg jh ji kh jk jl jm ki jo jp jq kj js jt ju jv hb bi translated"><strong class="ja hj">提示:</strong>当使用<strong class="ja hj">复制组件</strong> t命令时，组件的类型和当前属性设置被保存。这些可以通过<strong class="ja hj">粘贴组件值</strong>粘贴到同类型的另一个组件中，也可以通过<strong class="ja hj">粘贴组件为新</strong> <em class="hi">创建为一个新组件，并带有各自的值和设置。</em>最近以来你还可以分别复制粘贴位置、旋转和缩放。</p></blockquote></div><div class="ab cl ir is gp it" role="separator"><span class="iu bw bk iv iw ix"/><span class="iu bw bk iv iw ix"/><span class="iu bw bk iv iw"/></div><div class="hb hc hd he hf"><h1 id="35f3" class="kk kl hi bd km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh bi translated"><strong class="ak">脚本通信</strong></h1><p id="b924" class="pw-post-body-paragraph iy iz hi ja b jb li jd je jf lj jh ji jj lk jl jm jn ll jp jq jr lm jt ju jv hb bi translated"><strong class="ja hj"> GetComponent() </strong></p><p id="5637" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated">Unity为我们提供了一个方法，返回我们想要获取的游戏对象的组件，以便访问它的属性或行为。</p><p id="a401" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated">如果游戏对象有一个附加的组件，则返回类型为'<strong class="ja hj"> type </strong>的<strong class="ja hj">组件</strong>，如果没有，则返回“<strong class="ja hj"> <em class="jw"> null </em> </strong>”，包括禁用的游戏对象。</p><figure class="jy jz ka kb fd ik er es paragraph-image"><div class="er es ln"><img src="../Images/d497910e4b88cf5599fa2c1204724520.png" data-original-src="https://miro.medium.com/v2/resize:fit:698/format:webp/1*KZXR3xcIqotbaAkJSv8zvg.png"/></div><figcaption class="lo lp et er es lq lr bd b be z dx translated">声明和一般声明</figcaption></figure><figure class="jy jz ka kb fd ik er es paragraph-image"><div class="er es ls"><img src="../Images/03c46336fb65c9dbd696b9798cd584d7.png" data-original-src="https://miro.medium.com/v2/resize:fit:934/format:webp/1*2RuhlqQRGNv7H_9Vwj-Hig.png"/></div><figcaption class="lo lp et er es lq lr bd b be z dx translated">使用示例</figcaption></figure></div><div class="ab cl ir is gp it" role="separator"><span class="iu bw bk iv iw ix"/><span class="iu bw bk iv iw ix"/><span class="iu bw bk iv iw"/></div><div class="hb hc hd he hf"><p id="626b" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated"><strong class="ja hj">游戏对象。Find() </strong></p><p id="a056" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated">为了在一个<strong class="ja hj">不同的</strong>游戏对象上获得一个组件，我们可以使用<strong class="ja hj"> <em class="jw">游戏对象。找到</em> </strong>来获得另一个游戏对象的引用，然后使用<strong class="ja hj"> <em class="jw">游戏对象。GetComponent </em> </strong>。</p><figure class="jy jz ka kb fd ik er es paragraph-image"><div class="er es lt"><img src="../Images/86396f0f0b15e8ad52a272ab3fe3d624.png" data-original-src="https://miro.medium.com/v2/resize:fit:640/format:webp/1*y2P2xH0s5UlCamzmxL5q7g.png"/></div><figcaption class="lo lp et er es lq lr bd b be z dx translated">通过<strong class="bd km">名称</strong>找到游戏对象并返回</figcaption></figure><p id="e112" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated">这对于在加载时自动连接对其他对象的引用很有用，例如在Monobehaviour的<strong class="ja hj"><em class="jw">【Awake()</em></strong>和<strong class="ja hj"> <em class="jw"> Start() </em> </strong>方法中。通常我们在启动时将结果缓存在一个成员变量中，并让它的函数代码在<strong class="ja hj"> <em class="jw"> Update() </em> </strong>方法中运行。</p><figure class="jy jz ka kb fd ik er es paragraph-image"><div role="button" tabindex="0" class="il im di in bf io"><div class="er es lu"><img src="../Images/4821322a0e9445b5fe59962a2b101c23.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*eUpiIIKXybXXOT5M-PDJ9g.png"/></div></div></figure><p id="25e4" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated">在下面的文章中，我们将添加一个产卵管理器来协调我们敌人的产卵，我们将开始利用<strong class="ja hj"> <em class="jw">游戏对象。</em> </strong>寻找()【方法:</p><figure class="jy jz ka kb fd ik er es paragraph-image"><div role="button" tabindex="0" class="il im di in bf io"><div class="er es lv"><img src="../Images/68d8247f536fd1e7e2c8272a0e28ab9a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nxoSD0-e5DnEZ3zf3rW5Qw.png"/></div></div><figcaption class="lo lp et er es lq lr bd b be z dx translated">永远记得做一个<em class="if">零点检查。</em></figcaption></figure></div><div class="ab cl ir is gp it" role="separator"><span class="iu bw bk iv iw ix"/><span class="iu bw bk iv iw ix"/><span class="iu bw bk iv iw"/></div><div class="hb hc hd he hf"><p id="a435" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated">在某些情况下，我们将不得不使用<strong class="ja hj"> <em class="jw"> GetComponent() </em> </strong>方法的变体，通过<strong class="ja hj">名称</strong>而不是<strong class="ja hj">类型</strong>来访问组件，但是出于性能原因，最好避免使用带有字符串的GetComponent。</p><figure class="jy jz ka kb fd ik er es paragraph-image"><div class="er es lw"><img src="../Images/036b4a14851e407eb6c928e24ae901dc.png" data-original-src="https://miro.medium.com/v2/resize:fit:732/format:webp/1*hXmp1N5Zy-SOzU5u0PmPQQ.png"/></div></figure><blockquote class="ke kf kg"><p id="69f3" class="iy iz jw ja b jb jc jd je jf jg jh ji kh jk jl jm ki jo jp jq kj js jt ju jv hb bi translated"><strong class="ja hj">提示:</strong> <strong class="ja hj">组件。GetComponent </strong>将返回找到的第一个组件，没有任何特定的顺序。如果你期望有多个相同类型的组件，使用<strong class="ja hj">组件。取而代之的是GetComponents </strong>，并通过获取一个唯一的属性来遍历返回的组件。</p></blockquote></div><div class="ab cl ir is gp it" role="separator"><span class="iu bw bk iv iw ix"/><span class="iu bw bk iv iw ix"/><span class="iu bw bk iv iw"/></div><div class="hb hc hd he hf"><p id="a9e9" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated">在本文中，我们已经了解了Unity的组件系统，以及如何通过脚本与它们交互。在下面的文章中，我们将通过添加一个种子管理器来处理我们的敌人，掉落，加电等等，来实现这个逻辑。</p><p id="9c64" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated">← <a class="ae kc" rel="noopener" href="/nerd-for-tech/oncollisionenter-vs-ontriggerenter-when-to-use-them-37b08f3249a5">上一张</a> | <a class="ae kc" rel="noopener" href="/nerd-for-tech/spawn-manager-a7c0e6446b2a">下一张</a> →</p></div></div>    
</body>
</html>