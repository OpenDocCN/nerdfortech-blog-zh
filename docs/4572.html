<html>
<head>
<title>How to Bypass Angular HTTP Interceptor.</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何绕过Angular HTTP拦截器？</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/how-to-bypass-angular-http-interceptor-2491afca16a3?source=collection_archive---------2-----------------------#2021-07-27">https://medium.com/nerd-for-tech/how-to-bypass-angular-http-interceptor-2491afca16a3?source=collection_archive---------2-----------------------#2021-07-27</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/46f603367b8f109bd4712571732f09e2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vZhTP9Dli5_cA6MaJQ3kew.jpeg"/></div></div></figure><p id="5e5e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">是的，您没听错，有时您需要绕过angular HTTP拦截器来处理特定的HTTP请求。</p><p id="aac4" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在我们继续之前，让我们修改一下什么是角拦截器？。根据文件。</p><blockquote class="jo jp jq"><p id="8139" class="iq ir jr is b it iu iv iw ix iy iz ja js jc jd je jt jg jh ji ju jk jl jm jn hb bi translated">使用拦截，您可以声明<em class="hi">拦截器</em>来检查并转换从您的应用程序到服务器的HTTP请求。相同的拦截器还可以在返回应用程序的途中检查和转换服务器的响应。多个拦截器形成了一个<em class="hi">向前和向后</em>的请求/响应处理程序链。</p></blockquote><p id="f7a0" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我知道很专业。让我们用简单的话来说。angular interceptor检查您发送给服务的每个请求。并检查从服务器返回的响应。</p><p id="5271" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">下面是这个拦截器的一些用法。</p><ul class=""><li id="5dc2" class="jv jw hi is b it iu ix iy jb jx jf jy jj jz jn ka kb kc kd bi translated">添加令牌HTTP请求</li><li id="af50" class="jv jw hi is b it ke ix kf jb kg jf kh jj ki jn ka kb kc kd bi translated">为所有HTTP请求添加自定义HTTP头</li><li id="229d" class="jv jw hi is b it ke ix kf jb kg jf kh jj ki jn ka kb kc kd bi translated">自定义错误处理的逻辑</li><li id="147f" class="jv jw hi is b it ke ix kf jb kg jf kh jj ki jn ka kb kc kd bi translated">记录所有HTTP活动</li></ul><p id="010d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我想我们对角拦截器有了一个基本的概念。</p><p id="4d9e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我知道用角拦截器很好。但在某些情况下，我们需要绕过它。这就是解决方案。</p><h1 id="61b0" class="kj kk hi bd kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg bi translated">创建新的HttpClient</h1><p id="c757" class="pw-post-body-paragraph iq ir hi is b it lh iv iw ix li iz ja jb lj jd je jf lk jh ji jj ll jl jm jn hb bi translated">这里我们使用<code class="du lm ln lo lp b"><a class="ae lq" href="https://angular.io/api/common/http/HttpBackend" rel="noopener ugc nofollow" target="_blank">HttpBackend</a></code>创建一个新的HttpClient。拦截器位于<code class="du lm ln lo lp b"><a class="ae lq" href="https://angular.io/api/common/http/HttpClient" rel="noopener ugc nofollow" target="_blank">HttpClient</a></code>接口和<code class="du lm ln lo lp b"><a class="ae lq" href="https://angular.io/api/common/http/HttpBackend" rel="noopener ugc nofollow" target="_blank">HttpBackend</a></code>之间。所以诀窍是我们需要将<code class="du lm ln lo lp b"><a class="ae lq" href="https://angular.io/api/common/http/HttpBackend" rel="noopener ugc nofollow" target="_blank">HttpBackend</a></code>直接注入到我们的服务中，并使用<code class="du lm ln lo lp b"><a class="ae lq" href="https://angular.io/api/common/http/HttpBackend" rel="noopener ugc nofollow" target="_blank">HttpBackend</a></code>创建一个新的HttpClient。</p><p id="68f7" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">根据官方文件</p><blockquote class="jo jp jq"><p id="2689" class="iq ir jr is b it iu iv iw ix iy iz ja js jc jd je jt jg jh ji ju jk jl jm jn hb bi translated">当被注入时，<code class="du lm ln lo lp b"><a class="ae lq" href="https://angular.io/api/common/http/HttpBackend" rel="noopener ugc nofollow" target="_blank">HttpBackend</a></code> <strong class="is hj">将请求直接发送到后端</strong>，而不经过拦截器链。</p></blockquote><pre class="lr ls lt lu fd lv lp lw lx aw ly bi"><span id="5470" class="lz kk hi lp b fi ma mb l mc md">import {HttpBackend, HttpClient} from '@angular/common/http';<br/>import {<strong class="lp hj"><em class="jr">Injectable</em></strong>} from '@angular/core';<br/><br/>@Injectable({<br/>  providedIn: 'root'<br/>})<br/>export class AdmissionHttpService {</span><span id="859b" class="lz kk hi lp b fi me mb l mc md">  private httpClient: HttpClient;</span><span id="0754" class="lz kk hi lp b fi me mb l mc md">  constructor(<br/>    private handler: HttpBackend,<br/>  ) {<br/>    this.httpClient = new HttpClient(handler);<br/>  }<br/><br/><br/>  getData() {<br/>    return this.httpClient.get(url);<br/>  }<br/><br/>}</span></pre><p id="c1c0" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">所以今天就到这里。感谢阅读。</p></div></div>    
</body>
</html>