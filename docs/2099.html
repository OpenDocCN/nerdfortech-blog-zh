<html>
<head>
<title>Swift Leetcode Series: N-ary Tree Preorder Traversal</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Swift Leetcode 系列:N 元树前序遍历</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/n-ary-tree-preorder-traversal-afcabc3ec313?source=collection_archive---------13-----------------------#2021-04-20">https://medium.com/nerd-for-tech/n-ary-tree-preorder-traversal-afcabc3ec313?source=collection_archive---------13-----------------------#2021-04-20</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="3ffd" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">迭代+递归= Leetcode 589</h2></div><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es ix"><img src="../Images/e01b5ba94ae1f2ff5fa4324c948c215f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1340/format:webp/1*f-TRZn8KQcT-EJwYcnM0Ig.png"/></div></figure><div class="jf jg ez fb jh ji"><a href="https://theswiftnerd.com/n-ary-tree-preorder-traversal-leetcode-589/" rel="noopener  ugc nofollow" target="_blank"><div class="jj ab dw"><div class="jk ab jl cl cj jm"><h2 class="bd hj fi z dy jn ea eb jo ed ef hh bi translated">n 元树前序遍历(Leetcode 589)</h2><div class="jp l"><h3 class="bd b fi z dy jn ea eb jo ed ef dx translated">难度:链接:April Leetcoding 挑战:第 20 天给定一个 n 元树的根，返回…</h3></div><div class="jq l"><p class="bd b fp z dy jn ea eb jo ed ef dx translated">theswiftnerd.com</p></div></div><div class="jr l"><div class="js l jt ju jv jr jw jd ji"/></div></div></a></div><p id="d4f6" class="pw-post-body-paragraph jx jy hi jz b ka kb ij kc kd ke im kf kg kh ki kj kk kl km kn ko kp kq kr ks hb bi translated">你也可以通过上面的链接在 Swift Nerd 博客上阅读完整的故事。</p><h1 id="a779" class="kt ku hi bd kv kw kx ky kz la lb lc ld io le ip lf ir lg is lh iu li iv lj lk bi translated">问题陈述</h1><p id="c632" class="pw-post-body-paragraph jx jy hi jz b ka ll ij kc kd lm im kf kg ln ki kj kk lo km kn ko lp kq kr ks hb bi translated">给定 n 元树的<code class="du lq lr ls lt b">root</code>，返回<em class="lu">其节点值</em>的前序遍历。</p><p id="2d22" class="pw-post-body-paragraph jx jy hi jz b ka kb ij kc kd ke im kf kg kh ki kj kk kl km kn ko kp kq kr ks hb bi translated">四叉树输入序列化以它们的层次顺序遍历来表示。每组子代由空值分隔(参见示例)</p><p id="8092" class="pw-post-body-paragraph jx jy hi jz b ka kb ij kc kd ke im kf kg kh ki kj kk kl km kn ko kp kq kr ks hb bi translated"><strong class="jz hj">例 1: </strong></p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="lw lx di ly bf lz"><div class="er es lv"><img src="../Images/1513e88a7dc1c68bd3becbd0dd1dd355.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*hUwWVjw8jF9nZCEW.png"/></div></div></figure><pre class="iy iz ja jb fd ma lt mb mc aw md bi"><span id="52db" class="me ku hi lt b fi mf mg l mh mi"><strong class="lt hj">Input:</strong> root = [1,null,3,2,4,null,5,6]<br/><strong class="lt hj">Output:</strong> [1,3,5,6,2,4]</span></pre><p id="0a66" class="pw-post-body-paragraph jx jy hi jz b ka kb ij kc kd ke im kf kg kh ki kj kk kl km kn ko kp kq kr ks hb bi translated"><strong class="jz hj">例 2: </strong></p><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es mj"><img src="../Images/ae38407fbf82605d4b6cf46c3d1bf626.png" data-original-src="https://miro.medium.com/v2/resize:fit:1192/format:webp/0*fNEVepqd7HKRAT5z.png"/></div></figure><pre class="iy iz ja jb fd ma lt mb mc aw md bi"><span id="6c3e" class="me ku hi lt b fi mf mg l mh mi"><strong class="lt hj">Input:</strong> root = [1,null,2,3,4,5,null,null,6,7,null,8,null,9,10,null,null,11,null,12,null,13,null,null,14]<br/><strong class="lt hj">Output:</strong> [1,2,3,6,7,11,14,4,8,12,5,9,13,10]</span></pre><h1 id="f8eb" class="kt ku hi bd kv kw kx ky kz la lb lc ld io le ip lf ir lg is lh iu li iv lj lk bi translated">限制</h1><ul class=""><li id="779b" class="mk ml hi jz b ka ll kd lm kg mm kk mn ko mo ks mp mq mr ms bi translated">树中的节点数量在范围<code class="du lq lr ls lt b">[0, 104]</code>内。</li><li id="0cc5" class="mk ml hi jz b ka mt kd mu kg mv kk mw ko mx ks mp mq mr ms bi translated"><code class="du lq lr ls lt b">0 &lt;= Node.val &lt;= 104</code></li><li id="708a" class="mk ml hi jz b ka mt kd mu kg mv kk mw ko mx ks mp mq mr ms bi translated">n 叉树的高度小于等于<code class="du lq lr ls lt b">1000</code>。</li></ul><p id="d5f5" class="pw-post-body-paragraph jx jy hi jz b ka kb ij kc kd ke im kf kg kh ki kj kk kl km kn ko kp kq kr ks hb bi translated"><strong class="jz hj">跟进:</strong>递归求解很简单，你能迭代吗？</p><h1 id="f540" class="kt ku hi bd kv kw kx ky kz la lb lc ld io le ip lf ir lg is lh iu li iv lj lk bi translated">解决办法</h1><h1 id="3a87" class="kt ku hi bd kv kw kx ky kz la lb lc ld io le ip lf ir lg is lh iu li iv lj lk bi translated">递归的</h1><p id="921f" class="pw-post-body-paragraph jx jy hi jz b ka ll ij kc kd lm im kf kg ln ki kj kk lo km kn ko lp kq kr ks hb bi translated">使用递归，这个问题相当简单。在二叉树的前序遍历中，我们首先递归地遍历左子树，然后是右子树。这里，子节点以层级顺序的形式出现在一个数组中。因此，我们可以在 for 循环中遍历节点，并在当前元素上递归调用遍历函数。我们创建一个输出数组来存储结果，首先添加根，最后在遍历整个树之后，简单地返回输出数组。</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="my mz l"/></div></figure><h1 id="7a52" class="kt ku hi bd kv kw kx ky kz la lb lc ld io le ip lf ir lg is lh iu li iv lj lk bi translated">跟进:迭代</h1><p id="907a" class="pw-post-body-paragraph jx jy hi jz b ka ll ij kc kd lm im kf kg ln ki kj kk lo km kn ko lp kq kr ks hb bi translated">如果我们仔细观察，所有遍历(前序、中序、后序)都是对树的深度优先搜索，而树是一种特殊的祖先图。所以我们可以在树上使用深度优先遍历，使用堆栈并处理节点。方法是:-</p><ol class=""><li id="ce53" class="mk ml hi jz b ka kb kd ke kg na kk nb ko nc ks nd mq mr ms bi translated">创建一个空堆栈来存储叶节点</li><li id="7ae3" class="mk ml hi jz b ka mt kd mu kg mv kk mw ko mx ks nd mq mr ms bi translated">将根节点推送到堆栈上。</li><li id="45a9" class="mk ml hi jz b ka mt kd mu kg mv kk mw ko mx ks nd mq mr ms bi translated">创建一个输出数组来存储已处理的元素</li><li id="273c" class="mk ml hi jz b ka mt kd mu kg mv kk mw ko mx ks nd mq mr ms bi translated">当堆栈不为空时，从堆栈中弹出()元素，添加到输出结果中，以相反的顺序添加子节点。</li><li id="d27d" class="mk ml hi jz b ka mt kd mu kg mv kk mw ko mx ks nd mq mr ms bi translated">最后返回输出数组</li></ol><p id="6534" class="pw-post-body-paragraph jx jy hi jz b ka kb ij kc kd ke im kf kg kh ki kj kk kl km kn ko kp kq kr ks hb bi translated">为什么我们需要以相反的顺序添加子节点？因为问题中给出子节点是按层次顺序序列化的，而且由于<em class="lu">栈是一个</em><strong class="jz hj"><em class="lu">LIFO</em></strong><em class="lu">结构</em>，<em class="lu">我们需要先将右节点加入栈，最后将左节点加入栈，这样左节点最先弹出</em>。在 Swift 中，我们可以直接调用数组上的<strong class="jz hj"> reversed() </strong>，而在 C++中，我们必须反向遍历迭代器，在 python 中，我们可以使用<strong class="jz hj">切片操作符</strong>(<strong class="jz hj">[::-1】</strong>)。</p><h2 id="c6f4" class="me ku hi bd kv ne nf ng kz nh ni nj ld kg nk nl lf kk nm nn lh ko no np lj nq bi translated">密码</h2><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="my mz l"/></div></figure><h1 id="2b4f" class="kt ku hi bd kv kw kx ky kz la lb lc ld io le ip lf ir lg is lh iu li iv lj lk bi translated">复杂性分析</h1><p id="3369" class="pw-post-body-paragraph jx jy hi jz b ka ll ij kc kd lm im kf kg ln ki kj kk lo km kn ko lp kq kr ks hb bi translated">每个元素都被遍历一次。由于递归，堆栈空间将是 O(h)，其中 h 是树的最大高度。我们也可以说<strong class="jz hj"> <em class="lu"> O(logn) </em> </strong>因为<code class="du lq lr ls lt b">h</code>以<code class="du lq lr ls lt b">logn</code>为界。同样在迭代方法中，因为我们使用了与递归调用相同的堆栈，所以空间会受到<strong class="jz hj"> LogN </strong>的限制。</p><p id="276f" class="pw-post-body-paragraph jx jy hi jz b ka kb ij kc kd ke im kf kg kh ki kj kk kl km kn ko kp kq kr ks hb bi translated">时间= <strong class="jz hj"> O(N) </strong></p><p id="1bc7" class="pw-post-body-paragraph jx jy hi jz b ka kb ij kc kd ke im kf kg kh ki kj kk kl km kn ko kp kq kr ks hb bi translated">Space = <strong class="jz hj"> O(LogN) </strong></p></div><div class="ab cl nr ns gp nt" role="separator"><span class="nu bw bk nv nw nx"/><span class="nu bw bk nv nw nx"/><span class="nu bw bk nv nw"/></div><div class="hb hc hd he hf"><p id="3e77" class="pw-post-body-paragraph jx jy hi jz b ka kb ij kc kd ke im kf kg kh ki kj kk kl km kn ko kp kq kr ks hb bi translated">感谢您的阅读。如果你喜欢这篇文章，并发现它很有用，请分享并像野火一样传播它！</p><p id="6576" class="pw-post-body-paragraph jx jy hi jz b ka kb ij kc kd ke im kf kg kh ki kj kk kl km kn ko kp kq kr ks hb bi translated">你可以在<a class="ae ny" href="https://theswiftnerd.com/" rel="noopener ugc nofollow" target="_blank">the swift nerd</a>|<a class="ae ny" href="https://www.linkedin.com/in/varunrathi28/" rel="noopener ugc nofollow" target="_blank">LinkedIn</a>|<a class="ae ny" href="https://github.com/varunrathi28" rel="noopener ugc nofollow" target="_blank">Github</a>上找到我</p></div></div>    
</body>
</html>