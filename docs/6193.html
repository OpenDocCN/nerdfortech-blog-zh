<html>
<head>
<title>LeetCode — Merge Intervals</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">LeetCode —合并间隔</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/leetcode-merge-intervals-80444a6b2d4b?source=collection_archive---------7-----------------------#2022-01-13">https://medium.com/nerd-for-tech/leetcode-merge-intervals-80444a6b2d4b?source=collection_archive---------7-----------------------#2022-01-13</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><h1 id="9969" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">问题陈述</h1><p id="6352" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">给定一个<em class="kb">区间</em>数组，其中<em class="kb">区间[I]=【starti，迪恩】</em>，合并所有重叠区间，<em class="kb">返回一个非重叠区间数组，覆盖输入</em>中的所有区间。</p><p id="9f7c" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated">问题陈述摘自:<a class="ae kh" href="https://leetcode.com/problems/merge-intervals" rel="noopener ugc nofollow" target="_blank">https://leetcode.com/problems/merge-intervals</a></p><p id="3b4f" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated"><strong class="jf hj">例1: </strong></p><pre class="ki kj kk kl fd km kn ko kp aw kq bi"><span id="dceb" class="kr ig hi kn b fi ks kt l ku kv">Input: intervals = [[1, 3], [2, 6], [8, 10], [15, 18]]<br/>Output: [[1, 6], [8, 10], [15, 18]]<br/>Explanation: Since intervals [1, 3] and [2, 6] overlaps, merge them into [1, 6].</span></pre><p id="2679" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated"><strong class="jf hj">例2: </strong></p><pre class="ki kj kk kl fd km kn ko kp aw kq bi"><span id="4d0e" class="kr ig hi kn b fi ks kt l ku kv">Input: intervals = [[1, 4], [4, 5]]<br/>Output: [[1, 5]]<br/>Explanation: Intervals [1, 4] and [4, 5] are considered overlapping.</span></pre><p id="ec7b" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated"><strong class="jf hj">约束:</strong></p><pre class="ki kj kk kl fd km kn ko kp aw kq bi"><span id="9eac" class="kr ig hi kn b fi ks kt l ku kv">- 1 &lt;= intervals.length &lt;= 10^4 <br/>- intervals[i].length == 2 <br/>- 0 &lt;= starti &lt;= endi &lt;= 10^4</span></pre><h1 id="ef2d" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">说明</h1><h2 id="96a2" class="kr ig hi bd ih kw kx ky il kz la lb ip jo lc ld it js le lf ix jw lg lh jb li bi translated">强力</h2><p id="cc35" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">蛮力法是从第一个区间开始，每隔一个区间比较一次。如果它与任何其他间隔重叠，请删除该间隔，并将其他间隔合并到第一个间隔中。</p><p id="562d" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated">我们在第一次之后的剩余间隔重复这些相同的步骤。该方法的时间复杂度为O(N ) 。</p><h2 id="ad1b" class="kr ig hi bd ih kw kx ky il kz la lb ip jo lc ld it js le lf ix jw lg lh jb li bi translated">高效的解决方案:排序</h2><p id="9298" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">一种有效的方法是首先按开始时间对时间间隔进行排序。一旦区间排序，我们就线性时间合并所有区间。如果区间[i]与区间[i — 1]重叠，那么我们合并这两个区间。如果没有，我们将这个区间加到最终答案中。</p><p id="9add" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated">让我们检查下面的算法:</p><pre class="ki kj kk kl fd km kn ko kp aw kq bi"><span id="b5ba" class="kr ig hi kn b fi ks kt l ku kv">- sort the intervals array sort(intervals.begin(), intervals.end())<br/><br/>- initialize vector result<br/><br/>- loop for interval in intervals<br/>  - if result.empty() || result.back()[1] &lt; interval[0]<br/>    - result.push_back({interval[0], interval[1]})<br/>  - else<br/>    - result.back()[1] = max(result.back()[1], interval[1])<br/><br/>- return result</span></pre><h2 id="70c4" class="kr ig hi bd ih kw kx ky il kz la lb ip jo lc ld it js le lf ix jw lg lh jb li bi translated">C++解决方案</h2><pre class="ki kj kk kl fd km kn ko kp aw kq bi"><span id="e841" class="kr ig hi kn b fi ks kt l ku kv">class Solution {<br/>public:<br/>    vector&lt;vector&lt;int&gt;&gt; merge(vector&lt;vector&lt;int&gt;&gt;&amp; intervals) {<br/>        sort(intervals.begin(), intervals.end());<br/><br/>        vector&lt;vector&lt;int&gt;&gt; result;<br/><br/>        for(auto interval: intervals){<br/>            if(result.empty() || (result.back()[1] &lt; interval[0])){<br/>                result.push_back({interval[0], interval[1]});<br/>            } else {<br/>                result.back()[1] = max(result.back()[1], interval[1]);<br/>            }<br/>        }<br/><br/>        return result;<br/>    }<br/>};</span></pre><h2 id="2797" class="kr ig hi bd ih kw kx ky il kz la lb ip jo lc ld it js le lf ix jw lg lh jb li bi translated">戈朗溶液</h2><pre class="ki kj kk kl fd km kn ko kp aw kq bi"><span id="7420" class="kr ig hi kn b fi ks kt l ku kv">func merge(intervals [][]int) [][]int {<br/>    result := [][]int{}<br/><br/>    sort.Slice(intervals, func(i, j int) bool {<br/>        return intervals[i][0] &lt; intervals[j][0]<br/>    })<br/><br/>    for i, interval := range intervals {<br/>        if i == 0 {<br/>            result = append(result, interval)<br/>            continue<br/>        }<br/><br/>        lastInterval := result[len(result) - 1]<br/><br/>        if lastInterval[1] &lt; interval[0] {<br/>            result = append(result, interval)<br/>        } else if interval[1] &gt; lastInterval[1] {<br/>            lastInterval[1] = interval[1]<br/>        }<br/>    }<br/><br/>    return result<br/>}</span></pre><h2 id="48fb" class="kr ig hi bd ih kw kx ky il kz la lb ip jo lc ld it js le lf ix jw lg lh jb li bi translated">Javascript解决方案</h2><pre class="ki kj kk kl fd km kn ko kp aw kq bi"><span id="b1d7" class="kr ig hi kn b fi ks kt l ku kv">var merge = function(intervals) {<br/>    intervals.sort((i, j) =&gt; {<br/>        return i[0] - j[0];<br/>    })<br/><br/>    let result = [];<br/><br/>    for(let i = 0; i &lt; intervals.length; i++) {<br/>        if(i == 0) {<br/>            result.push(intervals[i]);<br/>            continue<br/>        }<br/><br/>        let lastInterval = result[result.length - 1];<br/>        if(lastInterval[1] &lt; intervals[i][0]) {<br/>            result.push(intervals[i]);<br/>        } else if (lastInterval[1] &gt; intervals[i][0]) {<br/>            lastInterval[1] = intervals[i][1];<br/>        }<br/>    }<br/><br/>    return result;<br/>};</span></pre><p id="fe20" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated">让我们试运行一下我们的算法，看看解决方案是如何工作的。</p><pre class="ki kj kk kl fd km kn ko kp aw kq bi"><span id="e418" class="kr ig hi kn b fi ks kt l ku kv">Input: intervals = [[1, 3], [2, 6], [8, 10], [15, 18]]<br/><br/>Step 1: sort(intervals.begin(), intervals.end())<br/>        - intervals = [[1, 3], [2, 6], [8, 10], [15, 18]]<br/><br/>Step 2: vector&lt;vector&lt;int&gt;&gt; result<br/><br/>Step 3: loop for(auto interval: intervals)<br/>        interval = [1, 3]<br/><br/>        - if result.empty() || (result.back()[1] &lt; interval[0])<br/>             true // as result is empty array<br/>          - result.push_back({interval[0], interval[1]})<br/>            result = [[1, 3]]<br/><br/>Step 4: for(auto interval: intervals)<br/>        interval = [2, 6]<br/><br/>        - if result.empty() || (result.back()[1] &lt; interval[0])<br/>             false || (3 &lt; 2)<br/>             false || false<br/>             false<br/><br/>        - else<br/>          - result.back()[1] = max(result.back()[1], interval[1])<br/>            result.back()[1] = max(3, 6)<br/>            result.back()[1] = 6<br/><br/>            result = [[1, 6]]<br/><br/>Step 5: for(auto interval: intervals)<br/>        interval = [8, 10]<br/><br/>        - if result.empty() || (result.back()[1] &lt; interval[0])<br/>             false || (6 &lt; 8)<br/>             false || true<br/>             true<br/>          - result.push_back({interval[0], interval[1]})<br/>            result.push_back({8, 10})<br/><br/>            result = [[1, 6], [8, 10]]<br/><br/>Step 6: for(auto interval: intervals)<br/>        interval = [15, 18]<br/><br/>        - if result.empty() || (result.back()[1] &lt; interval[0])<br/>             false || (10 &lt; 15)<br/>             false || true<br/>             true<br/><br/>          - result.push_back({interval[0], interval[1]})<br/>            result.push_back({15, 18})<br/><br/>            result = [[1, 6], [8, 10], [15, 18]]<br/><br/>Step 7: loop ends<br/><br/>Step 9: return result<br/><br/>So we return the result as [[1, 6], [8, 10], [15, 18]].</span></pre></div><div class="ab cl lj lk gp ll" role="separator"><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo"/></div><div class="hb hc hd he hf"><p id="73c4" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated"><em class="kb">最初发布于</em><a class="ae kh" href="https://alkeshghorpade.me/post/leetcode-merge-intervals" rel="noopener ugc nofollow" target="_blank"><em class="kb">https://alkeshghorpade . me</em></a><em class="kb">。</em></p></div></div>    
</body>
</html>