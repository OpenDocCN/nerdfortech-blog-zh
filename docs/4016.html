<html>
<head>
<title>ReactJS: Selective Context Consumer</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">ReactJS:选择性上下文消费者</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/reactjs-selective-context-consumer-939464e9ca02?source=collection_archive---------12-----------------------#2021-07-03">https://medium.com/nerd-for-tech/reactjs-selective-context-consumer-939464e9ca02?source=collection_archive---------12-----------------------#2021-07-03</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="36ae" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">如果选定的值/值的子集更改，则重新呈现组件</h2></div><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ix"><img src="../Images/24112716100df9b2d981bd752dbce653.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6PJJqHW_302QoaduS34ibA.png"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">“反应分析器”输出</figcaption></figure><p id="b962" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">不久前，我们遇到了一个问题，使用一个<code class="du kj kk kl km b">object</code>作为包含<code class="du kj kk kl km b">states</code>和<code class="du kj kk kl km b">methods</code>的上下文值来更新所述的<code class="du kj kk kl km b">states</code></p><h2 id="68f3" class="kn ko hi bd kp kq kr ks kt ku kv kw kx jw ky kz la ka lb lc ld ke le lf lg lh bi translated">相关链接:</h2><p id="5a07" class="pw-post-body-paragraph jn jo hi jp b jq li ij js jt lj im jv jw lk jy jz ka ll kc kd ke lm kg kh ki hb bi translated">项目库(重构源代码)可以在<a class="ae ln" href="https://github.com/arbaz52/selective-context-consumer" rel="noopener ugc nofollow" target="_blank"> <strong class="jp hj"> Github </strong> </a>访问。可以在<a class="ae ln" href="https://codesandbox.io/s/github/arbaz52/raw-selective-context-values-consumer" rel="noopener ugc nofollow" target="_blank"> <strong class="jp hj"> CodeSandbox </strong> </a>访问沙盒的链接。</p><h2 id="9ce7" class="kn ko hi bd kp kq kr ks kt ku kv kw kx jw ky kz la ka lb lc ld ke le lf lg lh bi translated">问题:</h2><p id="9290" class="pw-post-body-paragraph jn jo hi jp b jq li ij js jt lj im jv jw lk jy jz ka ll kc kd ke lm kg kh ki hb bi translated">如果当<code class="du kj kk kl km b">object</code>内的任何一个或多个值改变时<code class="du kj kk kl km b">context value</code>更新，它会导致使用带有<code class="du kj kk kl km b">useContext</code>钩子的所述上下文的每个组件重新呈现，即使组件没有使用更新的上下文内的值。</p><p id="5f8d" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">这导致了不必要的重新渲染，我们不想使用一个库，因为时间线已经快完成了。</p><h2 id="462e" class="kn ko hi bd kp kq kr ks kt ku kv kw kx jw ky kz la ka lb lc ld ke le lf lg lh bi translated">我如何创建一个变通办法:</h2><p id="2644" class="pw-post-body-paragraph jn jo hi jp b jq li ij js jt lj im jv jw lk jy jz ka ll kc kd ke lm kg kh ki hb bi translated">我使用了<code class="du kj kk kl km b">memoization</code>技术来减少不必要的重新渲染。</p><p id="dbcd" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">我创建了一个将<code class="du kj kk kl km b">context</code>和<code class="du kj kk kl km b">selection</code>函数作为<code class="du kj kk kl km b">props</code>的<code class="du kj kk kl km b">Functional Component</code>。然后，我缓存选择并将选择传递给一个<code class="du kj kk kl km b">memoized</code> React组件。</p><p id="bee7" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">然后，<code class="du kj kk kl km b">memoized</code> React组件呈现结果。我写了一个自定义的<code class="du kj kk kl km b">function</code>来检查传递的属性是否被改变，如果是，我<code class="du kj kk kl km b">flag</code>组件来渲染，否则它不会重新渲染。</p><h2 id="499a" class="kn ko hi bd kp kq kr ks kt ku kv kw kx jw ky kz la ka lb lc ld ke le lf lg lh bi translated">上述方法背后的原因:</h2><p id="0bf2" class="pw-post-body-paragraph jn jo hi jp b jq li ij js jt lj im jv jw lk jy jz ka ll kc kd ke lm kg kh ki hb bi translated">我创建两个组件的原因在于我们面临的问题。</p><p id="89cc" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">第一个/父组件使用带有<code class="du kj kk kl km b">useContext</code>的上下文，每次上下文值更新时，它都会重新渲染。</p><p id="cb31" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">子/第二个组件将<code class="du kj kk kl km b">selection</code>作为<code class="du kj kk kl km b">prop</code>接受，自定义<code class="du kj kk kl km b">shouldComponentUpdate</code>函数作为第二个参数传递给<code class="du kj kk kl km b">React.memo</code>检查下一个<code class="du kj kk kl km b">selection prop</code>与旧的<code class="du kj kk kl km b">selection prop</code>是否匹配，如果不匹配，则<code class="du kj kk kl km b">flags</code>将其渲染。</p><p id="009e" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">这样，作为子道具传递给第一个组件的组件只有在选择改变时才会重新渲染。</p><h1 id="6867" class="lo ko hi bd kp lp lq lr kt ls lt lu kx io lv ip la ir lw is ld iu lx iv lg ly bi translated">代码解释</h1><h2 id="38e5" class="kn ko hi bd kp kq kr ks kt ku kv kw kx jw ky kz la ka lb lc ld ke le lf lg lh bi translated">项目结构:</h2><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es lz"><img src="../Images/71d7ebe3d22e09e8d6dfecce36ee9c06.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9yd9PO7JWsyTjTHNCRrupw.png"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">项目结构</figcaption></figure><h2 id="7e16" class="kn ko hi bd kp kq kr ks kt ku kv kw kx jw ky kz la ka lb lc ld ke le lf lg lh bi translated">“选择性上下文消费者”组件:</h2><p id="fe6d" class="pw-post-body-paragraph jn jo hi jp b jq li ij js jt lj im jv jw lk jy jz ka ll kc kd ke lm kg kh ki hb bi translated"><code class="du kj kk kl km b">context</code>接受一个<code class="du kj kk kl km b">React Context</code>，<code class="du kj kk kl km b">selector</code>接受一个函数，该函数将上下文作为道具传递给它，并返回<code class="du kj kk kl km b">selection</code>。</p><p id="4dfe" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">该组件遵循一种<code class="du kj kk kl km b">render prop</code>模式，并将选择作为参数传递给函数<code class="du kj kk kl km b">children</code>，然后该函数返回一个<code class="du kj kk kl km b">React Node</code>。</p><p id="6e80" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated"><code class="du kj kk kl km b">name</code>只是为了调试，所以我们可以看看是怎么回事。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ma"><img src="../Images/1775bb441f6f501ebf62b20aac342c70.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*P2ZJfRzttSjX4ZRD3pk7Hw.png"/></div></div></figure><p id="0687" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">它只是使用传递给它的上下文，并使用传递给它的<code class="du kj kk kl km b">selection function</code>从中提取所需的内容。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es mb"><img src="../Images/204b61c09a668d6ddc8d959c4b9e603f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NyqIKHNRDDPrt-j1qZ9zMA.png"/></div></div></figure><h2 id="d1a9" class="kn ko hi bd kp kq kr ks kt ku kv kw kx jw ky kz la ka lb lc ld ke le lf lg lh bi translated">选择性上下文消费者子代:</h2><p id="7070" class="pw-post-body-paragraph jn jo hi jp b jq li ij js jt lj im jv jw lk jy jz ka ll kc kd ke lm kg kh ki hb bi translated">它接受<code class="du kj kk kl km b">memoized</code>选择和<code class="du kj kk kl km b">render function</code>作为道具。<code class="du kj kk kl km b">name</code>只是为了调试组件的生命周期。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es mc"><img src="../Images/3f235c5a980b058a360b0d52f9096e80.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*V2YXGM_qnlew2GeD1w6Ilg.png"/></div></div></figure><p id="470c" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">它只包含渲染，主要逻辑来自于<code class="du kj kk kl km b">memoizing</code>它。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es md"><img src="../Images/2c6e9c26d75920f5b31fedc204e6b698.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tCnR-Fg4cue-RAvkwvW7oA.png"/></div></div></figure><h2 id="d2ce" class="kn ko hi bd kp kq kr ks kt ku kv kw kx jw ky kz la ka lb lc ld ke le lf lg lh bi translated">组件是否应该更新:</h2><p id="ce2e" class="pw-post-body-paragraph jn jo hi jp b jq li ij js jt lj im jv jw lk jy jz ka ll kc kd ke lm kg kh ki hb bi translated"><code class="du kj kk kl km b">pvProps.value</code> &amp; <code class="du kj kk kl km b">nxtProps.value</code>包含选择，所以我们检查选择是否已经更新，如果是，我们重新渲染它。如果没有，我们检查传递给它的<code class="du kj kk kl km b">render function</code>是否已经改变。如果是，它会重新渲染它。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es me"><img src="../Images/632c45720d1d59e12d39e79623f8636b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kOimcH1iiuBaGMrsoRqTdg.png"/></div></div></figure><h2 id="bc14" class="kn ko hi bd kp kq kr ks kt ku kv kw kx jw ky kz la ka lb lc ld ke le lf lg lh bi translated">状态上下文:</h2><p id="4956" class="pw-post-body-paragraph jn jo hi jp b jq li ij js jt lj im jv jw lk jy jz ka ll kc kd ke lm kg kh ki hb bi translated">包含了两种状态:<code class="du kj kk kl km b">beer</code> &amp; <code class="du kj kk kl km b">honey</code>。两个功能分别对<code class="du kj kk kl km b">addBeer</code> &amp; <code class="du kj kk kl km b">addHoney</code>状态进行突变。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es mf"><img src="../Images/e02d6e01bfcc604bdd87161c6a5bb420.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ftYoKNmfRIp8sFvuG_ov7g.png"/></div></div></figure><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es mg"><img src="../Images/5a4d091aa139a36b826e14c31af6fcac.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PRVu8QZW7iAeDeN2MOV-GQ.png"/></div></div></figure><h2 id="b601" class="kn ko hi bd kp kq kr ks kt ku kv kw kx jw ky kz la ka lb lc ld ke le lf lg lh bi translated">应用程序组件:</h2><p id="9ae0" class="pw-post-body-paragraph jn jo hi jp b jq li ij js jt lj im jv jw lk jy jz ka ll kc kd ke lm kg kh ki hb bi translated">创建状态和调度并用<code class="du kj kk kl km b">StateContext.Provider</code>包装记忆组件。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es mh"><img src="../Images/d60048b0e99dd2de0582ec023eda456f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*c3rOMvwKZvCtupr-GmSNlg.png"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">应用程序组件</figcaption></figure><h2 id="9a6a" class="kn ko hi bd kp kq kr ks kt ku kv kw kx jw ky kz la ka lb lc ld ke le lf lg lh bi translated">“组件”组件:</h2><p id="f3dc" class="pw-post-body-paragraph jn jo hi jp b jq li ij js jt lj im jv jw lk jy jz ka ll kc kd ke lm kg kh ki hb bi translated">只是一个<code class="du kj kk kl km b">memoized</code>组件，其中包含实际的糖。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es mi"><img src="../Images/8907e61a0885620065d732c59ceebe8f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Z35JJD30Bv8EAVkf2lXI1Q.png"/></div></div></figure><h2 id="ebda" class="kn ko hi bd kp kq kr ks kt ku kv kw kx jw ky kz la ka lb lc ld ke le lf lg lh bi translated">蜂蜜成分:</h2><p id="2586" class="pw-post-body-paragraph jn jo hi jp b jq li ij js jt lj im jv jw lk jy jz ka ll kc kd ke lm kg kh ki hb bi translated">我们传递我们定义的选择函数，它从上下文中提取出<code class="du kj kk kl km b">honey</code>和<code class="du kj kk kl km b">addHoney</code>。我必须<code class="du kj kk kl km b">memoize</code>选择器函数，因为它对选择进行类型转换，所以在第21行，我们知道值的类型。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es mj"><img src="../Images/86b0c969d184cb80e0ec50d6c05addbf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*M-YwqLXashoF04PirKL1Uw.png"/></div></div></figure><h1 id="de48" class="lo ko hi bd kp lp lq lr kt ls lt lu kx io lv ip la ir lw is ld iu lx iv lg ly bi translated">了解组件的生命周期:</h1><p id="8eb2" class="pw-post-body-paragraph jn jo hi jp b jq li ij js jt lj im jv jw lk jy jz ka ll kc kd ke lm kg kh ki hb bi translated">使用<code class="du kj kk kl km b">console logs</code>我们可以通过调用<code class="du kj kk kl km b">addHoney</code>函数来解释增加<code class="du kj kk kl km b">honey</code>值后的流程。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es mk"><img src="../Images/875d80b03ff1d4dfdec3941faeaa0e60.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BEOuxPrP6ppQSXdNJ55LTw.png"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">选择改变了，所以增加蜂蜜的按钮的渲染函数被调用，而增加啤酒的按钮保持不变。</figcaption></figure><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ml"><img src="../Images/3020e2c2bae01806c3a784ed8a57c3e5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*St4JEyQoV-1AgjsrkpHk8g.png"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">具有增加蜂蜜的按钮的呈现功能的选择性上下文消费者子代被重新呈现，而具有增加啤酒的按钮的呈现功能的子代不被呈现。</figcaption></figure><h1 id="93c3" class="lo ko hi bd kp lp lq lr kt ls lt lu kx io lv ip la ir lw is ld iu lx iv lg ly bi translated">结论</h1><p id="87e8" class="pw-post-body-paragraph jn jo hi jp b jq li ij js jt lj im jv jw lk jy jz ka ll kc kd ke lm kg kh ki hb bi translated">是的，有一些库可以达到相同甚至更好的效果。动机是以一种可重用的方式实现优化，并在优化过程中学习。本文提供了问题的解决方案，以及旅程和旅程本身背后的智慧。</p><p id="ce09" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">我想把这篇文章献给我的未婚夫<strong class="jp hj"> Badria Arshad </strong>，是他激励了我，并在旅途中陪伴着我。</p></div></div>    
</body>
</html>