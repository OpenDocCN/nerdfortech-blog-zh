<html>
<head>
<title>How to understand Higher-order functions and Callbacks in JS</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何理解 JS 中的高阶函数和回调</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/how-to-understand-higher-order-functions-and-callbacks-in-js-342a10dac63?source=collection_archive---------4-----------------------#2022-12-11">https://medium.com/nerd-for-tech/how-to-understand-higher-order-functions-and-callbacks-in-js-342a10dac63?source=collection_archive---------4-----------------------#2022-12-11</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="acb8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在深潜之前，</p><p id="d6f1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们首先理解为什么我们需要函数。</p><p id="3b1c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">每一个代码都遵循<strong class="ih hj">干</strong>的原则(<strong class="ih hj">D</strong>on t<strong class="ih hj">R</strong>EPE at<strong class="ih hj">Y</strong>yourself)。干原理的基石是<strong class="ih hj">功能</strong>。</p><p id="731f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们把两个数相加，<strong class="ih hj"> 10 </strong>和<strong class="ih hj"> 20，</strong></p><pre class="jd je jf jg fd jh ji jj bn jk jl bi"><span id="d59b" class="jm jn hi ji b be jo jp l jq jr">const sum1 = 10 + 20;</span></pre><p id="4510" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">再加上<strong class="ih hj"> 50 </strong>和<strong class="ih hj"> 60、</strong></p><pre class="jd je jf jg fd jh ji jj bn jk jl bi"><span id="4129" class="jm jn hi ji b be jo jp l jq jr">const sum2 = 50 + 60</span></pre><p id="82ed" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">坐在这里问这个问题——我在重复我自己吗？我们该怎么办？</p><p id="944a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如前所述，<strong class="ih hj">功能</strong>来救援！</p><p id="87a1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">首先，让我们将上面几行转换成函数。</p><pre class="jd je jf jg fd jh ji jj bn jk jl bi"><span id="59e2" class="jm jn hi ji b be jo jp l jq jr">function sum1() { <br/>return 10 + 20 <br/>}</span></pre><p id="4a77" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">然后，</p><pre class="jd je jf jg fd jh ji jj bn jk jl bi"><span id="765f" class="jm jn hi ji b be jo jp l jq jr">function sum2() {<br/>return 50 + 60<br/>}</span></pre><p id="8641" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">万岁！我们已经将它转换成函数，但是等待并询问，<strong class="ih hj">‘我们在这里使用的是 DRY 吗？’。</strong></p><p id="6115" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">不，我们仍然在重复两个数的加法。</p><blockquote class="js jt ju"><p id="e411" class="if ig jv ih b ii ij ik il im in io ip jw ir is it jx iv iw ix jy iz ja jb jc hb bi translated">仅仅因为你把你的代码转换成函数并不意味着你遵循了 <strong class="ih hj"> <em class="hi">干</em> </strong> <em class="hi">的原则。</em></p><p id="3a2a" class="if ig jv ih b ii ij ik il im in io ip jw ir is it jx iv iw ix jy iz ja jb jc hb bi translated"><strong class="ih hj"> <em class="hi">干</em> </strong> <em class="hi"> =识别什么是变的，什么是不变的。</em></p></blockquote><p id="c977" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">什么在改变=数字。</p><p id="34b2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">不变的=加法运算。</p><p id="ec26" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们可以在函数中插入不变的模式，但是<strong class="ih hj">改变</strong>怎么办？</p><blockquote class="js jt ju"><p id="be11" class="if ig jv ih b ii ij ik il im in io ip jw ir is it jx iv iw ix jy iz ja jb jc hb bi translated"><em class="hi">不变=在函数内部。</em></p><p id="30c6" class="if ig jv ih b ii ij ik il im in io ip jw ir is it jx iv iw ix jy iz ja jb jc hb bi translated"><em class="hi">已更改=欢迎使用</em> <strong class="ih hj"> <em class="hi">参数</em> </strong> <em class="hi">。</em></p></blockquote><pre class="jd je jf jg fd jh ji jj bn jk jl bi"><span id="ae5a" class="jm jn hi ji b be jo jp l jq jr">function sum(a,b) {<br/>return a + b // Addition inside the function<br/>}</span></pre><p id="e53e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这里的<strong class="ih hj">‘a’</strong>和<strong class="ih hj">‘b’</strong>是<strong class="ih hj">参数</strong>负责改变一个。</p><p id="4236" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">因此使用<strong class="ih hj">参数</strong>调用函数。</p><pre class="jd je jf jg fd jh ji jj bn jk jl bi"><span id="a2ed" class="jm jn hi ji b be jo jp l jq jr">const sum1 = sum(10,20)<br/>const sum2 = sum(50,60)</span></pre><h2 id="d8bf" class="jz jn hi bd ka kb kc kd ke kf kg kh ki iq kj kk kl iu km kn ko iy kp kq kr ks bi translated">有点复杂:</h2><p id="dfe0" class="pw-post-body-paragraph if ig hi ih b ii kt ik il im ku io ip iq kv is it iu kw iw ix iy kx ja jb jc hb bi translated">我们将研究数组。</p><p id="15a2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们将<strong class="ih hj">把数组<strong class="ih hj">中的每个元素</strong>加 5 </strong>。</p><pre class="jd je jf jg fd jh ji jj bn jk jl bi"><span id="814d" class="jm jn hi ji b be jo jp l jq jr">const arr = [1,2,3];</span></pre><p id="9a35" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">怎么办？</strong></p><p id="66d9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们将遍历数组中的每个元素，并将结果推入一个新的数组。</p><pre class="jd je jf jg fd jh ji jj bn jk jl bi"><span id="ec10" class="jm jn hi ji b be jo jp l jq jr">const arr = [1,2,3];<br/><br/>function arrAddFive(inputArray) {<br/>    let output = [] // Initializing empty array<br/>    for(i=0;i&lt;inputArray.length;i++) {<br/>        let addingFive = inputArray[i] + 5; // addingFive to each element<br/>        output.push(addingFive); // Pushing it to output array<br/>    }<br/> return output // Returns the output array(contains added 5 element)<br/>};<br/><br/>const addresult1 = arrAddFive(arr); <br/>// [6,7,8]</span></pre><p id="0288" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">对于不同的阵列，</strong></p><pre class="jd je jf jg fd jh ji jj bn jk jl bi"><span id="8ba8" class="jm jn hi ji b be jo jp l jq jr">// Same code above<br/>const addresult2 = arrAddFive([11,12,13]); // [16,17,18]<br/>const addresult3 = arrAddFive([20,21,22]); // [25,26,27]</span></pre><p id="31c7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们对不同的阵列使用相同的函数来对齐<strong class="ih hj">干</strong>。很好！</p><p id="cf30" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们将做一个不同的操作，比如说<strong class="ih hj">乘以 5 </strong></p><pre class="jd je jf jg fd jh ji jj bn jk jl bi"><span id="af0e" class="jm jn hi ji b be jo jp l jq jr">const arr = [1,2,3];<br/><br/>function arrMultiplyFive(inputArray) {<br/>    let output = [] // Initializing empty array<br/>    for(i=0;i&lt;inputArray.length;i++) {<br/>    let multiplyingFive = inputArray[i] * 5; // Multiply 5 to each element<br/>        output.push(multiplyingFive); // Pushing it to output array<br/>    }<br/> return output // Returns the output array(contains added 5 element)<br/>};<br/><br/>const mulresult1 = arrMultiplyFive(arr); // [5,10,15]</span></pre><p id="1d79" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">对于不同的阵列，</p><pre class="jd je jf jg fd jh ji jj bn jk jl bi"><span id="c14f" class="jm jn hi ji b be jo jp l jq jr">const mulresult2 = arrMultiplyFive([11,12,13]) // [50,60,65]<br/>const mulresult3 = arrMultiplyFive([20,21,22]) // [100,105,110]</span></pre><p id="e7bf" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们这里用<strong class="ih hj">干</strong>吗？当然可以！因为不同的数组调用同一个函数。</p><h2 id="9915" class="jz jn hi bd ka kb kc kd ke kf kg kh ki iq kj kk kl iu km kn ko iy kp kq kr ks bi translated">如果我们希望在同一个代码中既有乘法又有加法呢？</h2><pre class="jd je jf jg fd jh ji jj bn jk jl bi"><span id="d1fc" class="jm jn hi ji b be jo jp l jq jr">const arr = [1,2,3];<br/><br/>function arrAddFive(inputArray) {<br/>    let output = [] // Initializing empty array<br/>    for(i=0;i&lt;inputArray.length;i++) {<br/>        let addingFive = inputArray[i] + 5; // adding 5 to each element<br/>        output.push(addingFive); // Pushing it to output array<br/>    }<br/> return output // Returns the output array(contains added 5 element)<br/>};<br/><br/>function arrMultiplyFive(inputArray) {<br/>    let output = [] // Initializing empty array<br/>    for(i=0;i&lt;inputArray.length;i++) {<br/>    let multiplyingFive = inputArray[i] * 5; // Multiply 5 to each element<br/>        output.push(multiplyingFive); // Pushing it to output array<br/>    }<br/> return output // Returns the output array(contains added 5 element)<br/>};<br/><br/>const addresult1 = arrAddFive(arr);<br/>const mulresult1 = arrMultiplyFive(arr);</span></pre><p id="fd91" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在告诉我答案，我们是在这里跟随<strong class="ih hj">干</strong>的脚步吗？</p><blockquote class="js jt ju"><p id="7793" class="if ig jv ih b ii ij ik il im in io ip jw ir is it jx iv iw ix jy iz ja jb jc hb bi translated">部分是！因为我们对不同的数组使用相同的函数进行相同的操作。</p></blockquote><p id="28ba" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">当你想加 5 时，不考虑数组→我们使用'<strong class="ih hj"> arrAddFive '函数。</strong></p><p id="de4b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">当你想乘以 5 而不考虑数组时→我们使用'<strong class="ih hj"> arrMultiplyFive '函数。</strong></p><blockquote class="js jt ju"><p id="b003" class="if ig jv ih b ii ij ik il im in io ip jw ir is it jx iv iw ix jy iz ja jb jc hb bi translated">但是不管<strong class="ih hj">数组</strong>和<strong class="ih hj">运算</strong>(乘法或加法)，我们都不使用同一个函数。</p><p id="0fe5" class="if ig jv ih b ii ij ik il im in io ip jw ir is it jx iv iw ix jy iz ja jb jc hb bi translated">我们可以说我们一直在使用一阶或更低阶的函数。</p></blockquote><h2 id="7acc" class="jz jn hi bd ka kb kc kd ke kf kg kh ki iq kj kk kl iu km kn ko iy kp kq kr ks bi translated">干就是找到一个共同的模式:</h2><p id="0605" class="pw-post-body-paragraph if ig hi ih b ii kt ik il im ku io ip iq kv is it iu kw iw ix iy kx ja jb jc hb bi translated">我们将在这里看到这两个函数的共同模式，</p><figure class="jd je jf jg fd kz er es paragraph-image"><div role="button" tabindex="0" class="la lb di lc bf ld"><div class="er es ky"><img src="../Images/e18715bc70104ee85ff95c532a1b795d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*RuN9LJSSQ9VkHOr-.png"/></div></div></figure><blockquote class="js jt ju"><p id="3a71" class="if ig jv ih b ii ij ik il im in io ip jw ir is it jx iv iw ix jy iz ja jb jc hb bi translated">任何变化(不同)都将作为参数传递给函数。</p></blockquote><p id="f927" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">什么变化？</strong></p><pre class="jd je jf jg fd jh ji jj bn jk jl bi"><span id="5d9e" class="jm jn hi ji b be jo jp l jq jr">let multiplyingFive = inputArray[i] * 5;<br/>let addingFive = inputArray[i] + 5;</span></pre><p id="9b38" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们能不能像这样放一个参数，</p><pre class="jd je jf jg fd jh ji jj bn jk jl bi"><span id="ac58" class="jm jn hi ji b be jo jp l jq jr">// Don't do this<br/>const mulresult1=arrFunction(multiplyingFive=InputArray[i]*5,inputArray)</span></pre><p id="3dde" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我知道这很傻，但我想说明一点。</p><p id="6e67" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我可以创建一个函数，它总是返回输入数字乘以 5 或加 5。</p><p id="8de7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我来编码这个，</p><pre class="jd je jf jg fd jh ji jj bn jk jl bi"><span id="8b4f" class="jm jn hi ji b be jo jp l jq jr">const arr = [1,2,3];<br/><br/>function arrFunc(callBackFn,inputArray) {<br/>    let output = [] // Initializing empty array<br/>    for(i=0;i&lt;inputArray.length;i++) {<br/>     output.push(callBackFn(inputArray[i])); // Invoking the callBackFn<br/>    }<br/> return output // Returns the output array(contains added 5 element)<br/>};<br/><br/>function multiplyFive(input) {<br/>    return input * 5;<br/>}<br/><br/>function addingFive(input) {<br/>    return input + 5;<br/>}<br/><br/>const addresult1 = arrFunc(multiplyFive,arr); // [6,7,8]<br/>const mulresult1 = arrFunc(addingFive,arr);  // [5,10,15]</span></pre><p id="3440" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">因此，当您将函数作为参数传递时，它被称为<strong class="ih hj">回调</strong>函数。</p><p id="671b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这里的<strong class="ih hj"> multiplyFive 和 addingFive </strong>被称为<strong class="ih hj">回调</strong>函数。</p><blockquote class="js jt ju"><p id="5153" class="if ig jv ih b ii ij ik il im in io ip jw ir is it jx iv iw ix jy iz ja jb jc hb bi translated">为什么使用术语'<strong class="ih hj">回调</strong>'？因为它不会立即被调用或者在另一个函数中被调用。</p></blockquote><p id="416c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">调用另一个函数的函数必须比回调函数更高阶，对吗？</p><p id="4d39" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这里的<strong class="ih hj"> arrFunc </strong>是<strong class="ih hj">高阶函数</strong>，因为它需要一个<strong class="ih hj">回调</strong>(另一个函数作为参数)。</p><p id="1d69" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">arrFunc 在其内部调用回调函数— <strong class="ih hj"> multiplyFive 和 addingFive </strong>。</p><pre class="jd je jf jg fd jh ji jj bn jk jl bi"><span id="9e92" class="jm jn hi ji b be jo jp l jq jr">output.push(callBackFn(inputArray[i])); // Invoking the callBackFn</span></pre><blockquote class="js jt ju"><p id="3e3f" class="if ig jv ih b ii ij ik il im in io ip jw ir is it jx iv iw ix jy iz ja jb jc hb bi translated"><em class="hi">回调函数是</em> <strong class="ih hj"> <em class="hi">通过一些更高级的函数回调</em> </strong> <em class="hi">。</em></p><p id="5bb0" class="if ig jv ih b ii ij ik il im in io ip jw ir is it jx iv iw ix jy iz ja jb jc hb bi translated"><em class="hi">或者我们可以说它是</em> <strong class="ih hj"> <em class="hi">被调用后</em> </strong> <em class="hi">更高的功能被调用。</em></p><p id="5b35" class="if ig jv ih b ii ij ik il im in io ip jw ir is it jx iv iw ix jy iz ja jb jc hb bi translated"><em class="hi">接受或给出另一个函数的函数称为</em> <strong class="ih hj"> <em class="hi">高阶函数。</em>T45】</strong></p></blockquote><p id="d379" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们将看到一个高阶函数稍后返回另一个函数。</p></div><div class="ab cl lg lh gp li" role="separator"><span class="lj bw bk lk ll lm"/><span class="lj bw bk lk ll lm"/><span class="lj bw bk lk ll"/></div><div class="hb hc hd he hf"><p id="49c5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="jv">最初发表于 2022 年 12 月 11 日</em><a class="ae ln" href="https://www.pansofarjun.com/post/how-to-understand-higher-order-functions-and-callbacks-in-js" rel="noopener ugc nofollow" target="_blank"><em class="jv">https://www.pansofarjun.com</em></a><em class="jv">。</em></p></div></div>    
</body>
</html>