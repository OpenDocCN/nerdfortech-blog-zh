<html>
<head>
<title>Beyond Jupyter Notebooks</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">超越Jupyter笔记本</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/beyond-jupyter-notebooks-6fd11322d313?source=collection_archive---------0-----------------------#2020-12-07">https://medium.com/nerd-for-tech/beyond-jupyter-notebooks-6fd11322d313?source=collection_archive---------0-----------------------#2020-12-07</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="71ad" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">第1部分:使用Flask和Docker的非ML模型部署</p><p id="4c47" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">欢迎学习第1部分。很高兴你完成了第0部分(<a class="ae jd" href="https://gregjan.medium.com/beyond-jupyter-notebooks-11af930c6bf7" rel="noopener">第0部分:建立一个ML项目</a>)，老实说，这并不是最令人兴奋的。在本文中，您将学习如何使用Flask部署一个非常简单的非机器学习模型，并使用Docker构建一个容器。</p><p id="f8d7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">更准确地说，我们将:</p><ul class=""><li id="d58d" class="je jf hi ih b ii ij im in iq jg iu jh iy ji jc jj jk jl jm bi translated"><strong class="ih hj">用我们的非机器学习模型创建一个生产就绪代码</strong></li><li id="a4d1" class="je jf hi ih b ii jn im jo iq jp iu jq iy jr jc jj jk jl jm bi translated"><strong class="ih hj">测试我们的模型</strong></li><li id="2015" class="je jf hi ih b ii jn im jo iq jp iu jq iy jr jc jj jk jl jm bi translated"><strong class="ih hj">创建一个服务于我们模型的web应用</strong></li><li id="6d12" class="je jf hi ih b ii jn im jo iq jp iu jq iy jr jc jj jk jl jm bi translated"><strong class="ih hj">将我们的网络应用容器化</strong></li></ul><figure class="jt ju jv jw fd jx er es paragraph-image"><div role="button" tabindex="0" class="jy jz di ka bf kb"><div class="er es js"><img src="../Images/5aa7fac1aae41021f124ea869c85dea9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*j4JWzSbdvA4P2LUS.jpg"/></div></div></figure></div><div class="ab cl ke kf gp kg" role="separator"><span class="kh bw bk ki kj kk"/><span class="kh bw bk ki kj kk"/><span class="kh bw bk ki kj"/></div><div class="hb hc hd he hf"><h2 id="ad40" class="kl km hi bd kn ko kp kq kr ks kt ku kv iq kw kx ky iu kz la lb iy lc ld le lf bi translated"><strong class="ak">非机器学习模型</strong></h2><p id="8a7f" class="pw-post-body-paragraph if ig hi ih b ii lg ik il im lh io ip iq li is it iu lj iw ix iy lk ja jb jc hb bi translated">非机器学习模型看起来是这样的:</p><figure class="jt ju jv jw fd jx er es paragraph-image"><div class="er es ll"><img src="../Images/459028231d12f0981c309296e910e863.png" data-original-src="https://miro.medium.com/v2/resize:fit:350/format:webp/0*PWCTiQFWx6i8H2CG.png"/></div></figure><p id="6894" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">模型的简单性应该让你的注意力从建模部分移开。下面的Python类<em class="lm">建模器</em>什么也没做，只是返回上面的函数，将<em class="lm"> x </em>作为<em class="lm">预测</em>函数的输入。</p><figure class="jt ju jv jw fd jx"><div class="bz dy l di"><div class="ln lo l"/></div></figure><p id="49d6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">上面这段代码中有几个函数没有用到。其背后的原因是，我们将在下面的文章中使用相同的代码结构，而模型的复杂性将会增加。基本上，我们将在未来构建相同的代码。</p></div><div class="ab cl ke kf gp kg" role="separator"><span class="kh bw bk ki kj kk"/><span class="kh bw bk ki kj kk"/><span class="kh bw bk ki kj"/></div><div class="hb hc hd he hf"><h2 id="441d" class="kl km hi bd kn ko kp kq kr ks kt ku kv iq kw kx ky iu kz la lb iy lc ld le lf bi translated">单元测试</h2><p id="822d" class="pw-post-body-paragraph if ig hi ih b ii lg ik il im lh io ip iq li is it iu lj iw ix iy lk ja jb jc hb bi translated">测试<strong class="ih hj"> </strong>是自然的下一步，因为我们现在有了一个模型。Pytest 是一个让用Python写小测试变得容易的框架。要安装它，请运行:</p><pre class="jt ju jv jw fd lp lq lr ls aw lt bi"><span id="57ff" class="kl km hi lq b fi lu lv l lw lx">conda install -c anaconda pytest</span></pre><p id="8a47" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="lm"> Pytest </em>将运行任何文件名以“test_”开头的测试代码。下面是测试我们的Mo <em class="lm"> deler </em>类的代码:</p><figure class="jt ju jv jw fd jx"><div class="bz dy l di"><div class="ln lo l"/></div></figure><p id="1307" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在导入我们的<em class="lm"> Modeler </em>类和<em class="lm"> pytest </em>库之后，我们使用decorator @ pytest . mark . parameterize来定义输入值/预期输出对。在assert语句中，我们评估预期输出是否等于实际输出。</p><p id="29bf" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">要启动测试，只需在终端中写入<em class="lm"> pytest </em>。如果成功，输出应该如下所示:</p><figure class="jt ju jv jw fd jx er es paragraph-image"><div role="button" tabindex="0" class="jy jz di ka bf kb"><div class="er es ly"><img src="../Images/37d56cdde5c7756051ca3c0f675dd32b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*U0bL58do8zFWRDC2-I32Vw.png"/></div></div></figure></div><div class="ab cl ke kf gp kg" role="separator"><span class="kh bw bk ki kj kk"/><span class="kh bw bk ki kj kk"/><span class="kh bw bk ki kj"/></div><div class="hb hc hd he hf"><h2 id="5ee5" class="kl km hi bd kn ko kp kq kr ks kt ku kv iq kw kx ky iu kz la lb iy lc ld le lf bi translated"><strong class="ak">烧瓶app </strong></h2><p id="2558" class="pw-post-body-paragraph if ig hi ih b ii lg ik il im lh io ip iq li is it iu lj iw ix iy lk ja jb jc hb bi translated">现在我们的测试成功了，我们可以构建我们的web应用程序了。你可能会问烧瓶是什么？Flask是一个web应用程序的微型框架。换句话说，它让你创建一个网络应用变得容易。如果你想了解更多关于Flask的信息，可以查看它的网站:<a class="ae jd" href="https://flask.palletsprojects.com/en/1.1.x/" rel="noopener ugc nofollow" target="_blank">https://flask.palletsprojects.com/en/1.1.x/</a>。</p><figure class="jt ju jv jw fd jx"><div class="bz dy l di"><div class="ln lo l"/></div></figure><p id="188e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们来分解这个程序:</p><ol class=""><li id="0b30" class="je jf hi ih b ii ij im in iq jg iu jh iy ji jc lz jk jl jm bi translated">首先，<em class="lm"> Flask </em>类与我们的<em class="lm">建模器</em>类一起被导入。</li><li id="d05e" class="je jf hi ih b ii jn im jo iq jp iu jq iy jr jc lz jk jl jm bi translated">接下来，我们创建这个类的一个实例。第一个参数是应用程序的模块或包的名称。<em class="lm"> __name__ </em>是默认包。</li><li id="4ce7" class="je jf hi ih b ii jn im jo iq jp iu jq iy jr jc lz jk jl jm bi translated">然后，<em class="lm"> @app.route </em> decorator告诉Flask什么URL应该触发我们的函数(在本例中是<em class="lm"> localhost:5000/predict </em>)并且使用的方法将是POST。POST请求意味着我们将向我们的web应用程序发送数据。</li><li id="a04d" class="je jf hi ih b ii jn im jo iq jp iu jq iy jr jc lz jk jl jm bi translated">然后我们进入<em class="lm"> post() </em>函数:<br/> 4.1。由于我们将以JSON格式将数据发送到我们的web应用程序，因此我们使用<em class="lm"> request.get_json() </em>读取数据，并将其存储在<em class="lm"> data </em>中。<br/> 4.2。从<em class="lm">数据</em>中提取<em class="lm"> x </em>的值，并存储在<em class="lm"> </em>变量<em class="lm"><br/></em>4.3中。<em class="lm"> </em>调用我们的<em class="lm">建模器</em>类到<em class="lm"> m </em>中，用<em class="lm"> x. <br/> </em> 4.4馈入函数predict。返回JSON格式下的输入<em class="lm"> x </em>和输出<em class="lm">预测</em>。</li><li id="d27f" class="je jf hi ih b ii jn im jo iq jp iu jq iy jr jc lz jk jl jm bi translated">最后的<em class="lm"> if </em>条件检查我们的Python程序<em class="lm"> app.py </em>已经导入。如果没有，它将通过端口5000在默认的<em class="lm">localhost</em>URL(127 . 0 . 0 . 1)上运行来启动Flask服务器。</li></ol><p id="34cf" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在，要运行我们的Flask应用程序，您只需在终端中编写:</p><pre class="jt ju jv jw fd lp lq lr ls aw lt bi"><span id="2f05" class="kl km hi lq b fi lu lv l lw lx">python app.py</span></pre><p id="c3cd" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在，您应该会看到类似这样的内容:</p><figure class="jt ju jv jw fd jx er es paragraph-image"><div role="button" tabindex="0" class="jy jz di ka bf kb"><div class="er es ma"><img src="../Images/e9487eb6dcb606155151f01593ab4399.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fSsqf3rDrJrNglTq3CzbIw.png"/></div></div></figure><p id="7cf9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们的web应用上没有前端。因此，如果您打开浏览器并输入给定的URL (http://127.0.0.1:5000/)，您将得到一条<strong class="ih hj">未找到</strong>的错误消息。</p><p id="dddc" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">也就是说，后端应该是完美的工作，我们现在可以查询我们的应用程序。我们试试吧！</p><p id="c9bf" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这里笔记本是一个不错的选择(但不是必须的):</p><figure class="jt ju jv jw fd jx er es paragraph-image"><div class="er es mb"><img src="../Images/c5d779acebe62db35eada6fedf811b77.png" data-original-src="https://miro.medium.com/v2/resize:fit:1136/format:webp/1*1KQuqbzj_e5KQvWc2cz8_w.png"/></div></figure><p id="f21e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们使用<em class="lm">请求</em>包将我们的POST请求发送到web应用程序。我们需要指定的只是URL和JSON格式的输入。这个模型给了我们预测值<em class="lm"> y = 10000 </em>，在我看来，这个值正好等于<em class="lm"> 100 </em>。</p></div><div class="ab cl ke kf gp kg" role="separator"><span class="kh bw bk ki kj kk"/><span class="kh bw bk ki kj kk"/><span class="kh bw bk ki kj"/></div><div class="hb hc hd he hf"><h2 id="68bb" class="kl km hi bd kn ko kp kq kr ks kt ku kv iq kw kx ky iu kz la lb iy lc ld le lf bi translated">用码头工人集装箱化</h2><p id="44d2" class="pw-post-body-paragraph if ig hi ih b ii lg ik il im lh io ip iq li is it iu lj iw ix iy lk ja jb jc hb bi translated">我们现在有一个本地web应用程序，它成功地部署了我们的非机器学习模型。恭喜你！</p><p id="152f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">但我们希望我们的应用程序被这个世界上的每个人看到并闪耀，不是吗？我们当然知道。为此，我们引入了<em class="lm"> Docker </em>容器。如果你不熟悉码头集装箱，就把它想象成船上的集装箱。你的程序将在一个与外部世界隔离的容器中运行，这样它就可以完全按照你的要求运行，并且完全可移植。欲了解更多信息并安装<em class="lm">Docker</em>:<a class="ae jd" href="https://docs.docker.com/get-docker/" rel="noopener ugc nofollow" target="_blank">https://docs.docker.com/get-docker/</a></p></div><div class="ab cl ke kf gp kg" role="separator"><span class="kh bw bk ki kj kk"/><span class="kh bw bk ki kj kk"/><span class="kh bw bk ki kj"/></div><div class="hb hc hd he hf"><p id="d854" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">所以我们现在只需要一个Docker文件来配置我们的容器(假设已经安装了<em class="lm"> Docker </em>)。您可以将以下文件放在项目文件夹的根目录下:</p><figure class="jt ju jv jw fd jx"><div class="bz dy l di"><div class="ln lo l"/></div></figure><p id="e901" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这里使用的基本映像是<em class="lm"> python 3.7-slim </em>(基于Debian)。所有运行命令都使用最新的软件包更新基础映像。<em class="lm">docker文件</em>中的两个关键行是从<em class="lm"> requirements.txt </em>文件中复制并安装所有的python库。这意味着容器和本地anaconda环境将使用相同的库版本。要创建这个文件，请在终端中运行(您的anaconda环境<strong class="ih hj">必须</strong>被激活):</p><pre class="jt ju jv jw fd lp lq lr ls aw lt bi"><span id="b98a" class="kl km hi lq b fi lu lv l lw lx">pip freeze &gt; requirements.txt</span></pre><p id="2889" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">然后,<em class="lm"> COPY </em>行将所有文件和文件夹复制到容器中。最后，CMD行将通过将app.py作业运行到URL 0.0.0.0和端口8080来启动web应用程序。此URL是一个“所有接口”地址，可通过使用localhost进行本地访问。</p><p id="b26a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">在构建我们的容器之前，不要忘记通过取消注释第21行来更新<em class="lm"> app.py </em>，以便通过端口8080(和注释行19)将应用程序路由到URL 0.0.0.0。</strong></p><p id="47f4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">好了，现在我们都准备好了。让我们制作这个容器:</p><pre class="jt ju jv jw fd lp lq lr ls aw lt bi"><span id="a00d" class="kl km hi lq b fi lu lv l lw lx">docker build --tag &lt;containername&gt; .</span></pre><p id="73d2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这可能需要一点时间，取决于您的连接速度。但是一旦完成，您就可以启动容器了:</p><pre class="jt ju jv jw fd lp lq lr ls aw lt bi"><span id="44f2" class="kl km hi lq b fi lu lv l lw lx">docker run  -p 8080:8080 &lt;containername&gt;:latest</span></pre><p id="2626" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">下一步，我们测试。在我们的本地版本中，我们可以运行以下笔记本，只需将端口从5000更新到8080:</p><figure class="jt ju jv jw fd jx er es paragraph-image"><div class="er es mb"><img src="../Images/8460539cf46de89385107e7a1c614a7f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1136/format:webp/1*lNFFUMdeiaImfrLechrIgg.png"/></div></figure><p id="422a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们得到了和当地一样的回应。你成功了。恭喜你！</p><p id="2482" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在，我们可以将这个容器注册到任何云供应商，如GCP、Azure或AWS，并向全世界开放。但是我不会在本文中涉及它。</p></div><div class="ab cl ke kf gp kg" role="separator"><span class="kh bw bk ki kj kk"/><span class="kh bw bk ki kj kk"/><span class="kh bw bk ki kj"/></div><div class="hb hc hd he hf"><p id="435d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">尽管我们的模型非常简单，但仍然需要学习很多东西。希望这已经让您对如何部署模型有了更好的了解。除了测试我们的应用程序，Jupyter笔记本没有被使用。相反，我们使用生产代码和配置文件。</p><p id="fe27" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">你可以访问我的GitHub回购中的所有代码:<a class="ae jd" href="https://github.com/GregoireJan/xflask" rel="noopener ugc nofollow" target="_blank">https://github.com/GregoireJan/xflask</a></p><p id="b2e8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在下一篇文章中，我们将使用Streamlit为我们的web应用程序创建一个漂亮的前端！</p></div><div class="ab cl ke kf gp kg" role="separator"><span class="kh bw bk ki kj kk"/><span class="kh bw bk ki kj kk"/><span class="kh bw bk ki kj"/></div><div class="hb hc hd he hf"><p id="171a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">以下是Jupyter笔记本之外的系列<em class="lm">部分:</em></p><ul class=""><li id="c202" class="je jf hi ih b ii ij im in iq jg iu jh iy ji jc jj jk jl jm bi translated"><a class="ae jd" href="https://gregjan.medium.com/beyond-jupyter-notebooks-11af930c6bf7" rel="noopener">第0部分:设置ML项目</a></li><li id="7e12" class="je jf hi ih b ii jn im jo iq jp iu jq iy jr jc jj jk jl jm bi translated"><a class="ae jd" href="https://gregjan.medium.com/beyond-jupyter-notebooks-6fd11322d313" rel="noopener">第1部分:使用烧瓶和对接器的非ML模型部署</a></li><li id="cc32" class="je jf hi ih b ii jn im jo iq jp iu jq iy jr jc jj jk jl jm bi translated"><a class="ae jd" rel="noopener" href="/nerd-for-tech/beyond-jupyter-notebooks-63b169c43c44">第2部分:使用Streamlit和Docker的非ML模型部署</a></li><li id="bebc" class="je jf hi ih b ii jn im jo iq jp iu jq iy jr jc jj jk jl jm bi translated"><a class="ae jd" href="https://gregjan.medium.com/beyond-jupyter-notebooks-8fc0333517f3" rel="noopener">第3部分:带烧瓶和对接器的ML模型部署</a></li><li id="1dc4" class="je jf hi ih b ii jn im jo iq jp iu jq iy jr jc jj jk jl jm bi translated">第4部分:使用Streamlit和Docker的ML模型部署<em class="lm">(未发布)</em></li></ul></div></div>    
</body>
</html>