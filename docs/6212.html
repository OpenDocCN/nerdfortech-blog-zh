<html>
<head>
<title>Starting with Microservices in PHP</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">从PHP中的微服务开始</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/starting-with-microservices-in-php-6e3c411f3d27?source=collection_archive---------0-----------------------#2022-01-18">https://medium.com/nerd-for-tech/starting-with-microservices-in-php-6e3c411f3d27?source=collection_archive---------0-----------------------#2022-01-18</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/e50597acd7cb5523034a3457928bcb75.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*htJ-VkmgsUIUKv5aRL0_yQ.jpeg"/></div></div></figure><p id="0ec6" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这是对“<a class="ae jo" href="https://dariuszgafka.medium.com/how-to-integrate-microservices-a506fe2d1a48" rel="noopener">如何集成微服务</a>”帖子的跟进。<br/>先读一读以前的文章，感觉受到了鼓励。<br/>在本文中，我们将利用PHP将理论应用于实践。</p><p id="cacf" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们将使用<a class="ae jo" href="https://github.com/ecotoneFramework/ecotone" rel="noopener ugc nofollow" target="_blank">生态交错带框架</a>和<a class="ae jo" href="https://www.rabbitmq.com/" rel="noopener ugc nofollow" target="_blank"> RabbitMQ </a>，将两种服务整合在一起。</p></div><div class="ab cl jp jq gp jr" role="separator"><span class="js bw bk jt ju jv"/><span class="js bw bk jt ju jv"/><span class="js bw bk jt ju"/></div><div class="hb hc hd he hf"><h1 id="6b9d" class="jw jx hi bd jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt bi translated">在PHP中实现消息传递</h1><p id="2e7e" class="pw-post-body-paragraph iq ir hi is b it ku iv iw ix kv iz ja jb kw jd je jf kx jh ji jj ky jl jm jn hb bi translated">在开始之前，我们需要为使用的<a class="ae jo" href="https://docs.ecotone.tech/install-php-service-bus" rel="noopener ugc nofollow" target="_blank">框架</a> (Symfony/Laravel/Lite)启用<a class="ae jo" href="https://docs.ecotone.tech/modules/amqp-support-rabbitmq#configuration" rel="noopener ugc nofollow" target="_blank"> RabbitMQ模块</a>。</p><p id="55c7" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们将构建两个服务。<br/>消费消息的服务，我们称之为“订单服务”和发布消息的服务，<em class="kz">“我的服务”</em>。<br/>命名很重要，我们需要<a class="ae jo" href="https://docs.ecotone.tech/messaging/service-application-configuration#ecotone-core-configuration" rel="noopener ugc nofollow" target="_blank">在配置</a>中设置服务名。</p><p id="b361" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在“<em class="kz">订单服务</em>中，我们将使消费者能够消费来自其他微服务的消息。</p><figure class="la lb lc ld fd ij"><div class="bz dy l di"><div class="le lf l"/></div></figure><p id="b6d3" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在“<em class="kz">我的服务</em>中，我们将启用分布式总线，这将允许我们向其他微服务发送事件和命令。</p><figure class="la lb lc ld fd ij"><div class="bz dy l di"><div class="le lf l"/></div></figure><h1 id="2d87" class="jw jx hi bd jy jz lg kb kc kd lh kf kg kh li kj kk kl lj kn ko kp lk kr ks kt bi translated">向订单服务发送命令</h1><p id="05d4" class="pw-post-body-paragraph iq ir hi is b it ku iv iw ix kv iz ja jb kw jd je jf kx jh ji jj ky jl jm jn hb bi translated">让我们从定义<em class="kz">订单服务</em>中的<a class="ae jo" href="https://blog.ecotone.tech/cqrs-in-php/" rel="noopener ugc nofollow" target="_blank">命令处理程序</a>开始。</p><figure class="la lb lc ld fd ij"><div class="bz dy l di"><div class="le lf l"/></div></figure><p id="ba9e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">命令处理程序在<em class="kz">“place order”</em>路由键下可用。</p><p id="d1eb" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们现在可以使用分布式总线从<em class="kz"> My Service </em>发送命令来下订单:</p><figure class="la lb lc ld fd ij"><div class="bz dy l di"><div class="le lf l"/></div></figure><ol class=""><li id="478a" class="ll lm hi is b it iu ix iy jb ln jf lo jj lp jn lq lr ls lt bi translated">命令应该发送到的服务名</li><li id="3615" class="ll lm hi is b it lu ix lv jb lw jf lx jj ly jn lq lr ls lt bi translated">路由到<em class="kz">订单服务</em>内的命令处理程序</li><li id="4025" class="ll lm hi is b it lu ix lv jb lw jf lx jj ly jn lq lr ls lt bi translated">要发送的数据(命令的有效载荷)</li><li id="f00e" class="ll lm hi is b it lu ix lv jb lw jf lx jj ly jn lq lr ls lt bi translated">和可选的数据内容类型</li></ol><p id="a1cf" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">执行该代码后，命令消息将被发送到<em class="kz">订单服务</em>。<br/> <em class="kz">订单服务</em>现在可以通过运行以下命令来消耗它:</p><pre class="la lb lc ld fd lz ma mb mc aw md bi"><span id="2c50" class="me jx hi ma b fi mf mg l mh mi">(bin/console|artisan) ecotone:run order_service -vvv</span></pre><h1 id="5d40" class="jw jx hi bd jy jz lg kb kc kd lh kf kg kh li kj kk kl lj kn ko kp lk kr ks kt bi translated">发布事件</h1><p id="b10d" class="pw-post-body-paragraph iq ir hi is b it ku iv iw ix kv iz ja jb kw jd je jf kx jh ji jj ky jl jm jn hb bi translated">假设我们想取消用户的所有订单，以防他的帐户被禁止。<br/> <em class="kz">我的服务</em>将发布关于用户被禁止的事件，而<em class="kz">订单服务</em>将订阅该事件。</p><figure class="la lb lc ld fd ij"><div class="bz dy l di"><div class="le lf l"/></div></figure><p id="9474" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">事件处理程序现在将订阅用路由关键字“<em class="kz"> user.was_banned </em>”发布的事件。</p><figure class="la lb lc ld fd ij"><div class="bz dy l di"><div class="le lf l"/></div></figure><ol class=""><li id="a8b2" class="ll lm hi is b it iu ix iy jb ln jf lo jj lp jn lq lr ls lt bi translated">事件的名称(路由关键字)</li><li id="c815" class="ll lm hi is b it lu ix lv jb lw jf lx jj ly jn lq lr ls lt bi translated">要发送的数据(事件的有效载荷)</li><li id="026a" class="ll lm hi is b it lu ix lv jb lw jf lx jj ly jn lq lr ls lt bi translated">有效负载的可选内容类型</li></ol><p id="e1f1" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">执行该代码后，事件消息将被传递给<em class="kz">订单服务</em>。<br/> <em class="kz">订单服务</em>现在可以通过跑步来消耗:</p><pre class="la lb lc ld fd lz ma mb mc aw md bi"><span id="acf6" class="me jx hi ma b fi mf mg l mh mi">(bin/console|artisan) ecotone:run order_service -vvv</span></pre><h1 id="5b76" class="jw jx hi bd jy jz lg kb kc kd lh kf kg kh li kj kk kl lj kn ko kp lk kr ks kt bi translated">进入更多细节…</h1><figure class="la lb lc ld fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mj"><img src="../Images/bfacd6ca96251dd2521c0ad4f775082c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*98zIkMpgTdjku1Bg_6pNQQ.jpeg"/></div></div></figure><h1 id="159b" class="jw jx hi bd jy jz lg kb kc kd lh kf kg kh li kj kk kl lj kn ko kp lk kr ks kt bi translated">路由方式</h1><pre class="la lb lc ld fd lz ma mb mc aw md bi"><span id="685e" class="me jx hi ma b fi mf mg l mh mi">#[Distributed]<br/>#[CommandHandler("placeOrder")]<br/>public function placeOrder(PlaceOrderCommand $command): void</span></pre><p id="04ec" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们使用<em class="kz">“place order”路由名称</em>将命令路由到特定的处理程序。</p><pre class="la lb lc ld fd lz ma mb mc aw md bi"><span id="e465" class="me jx hi ma b fi mf mg l mh mi">$this-&gt;distributedBus-&gt;sendCommand("order_service","placeOrder",...)</span></pre><p id="13d3" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">您可能会遇到这样的解决方案:路由是基于类名的，或者需要在服务之间共享实际的类实现。<br/>服务之间共享PHP类，使其成为公共API。我们不能再简单地更改类名，因为这会中断其他服务。这个职业变得很难改变，因为现在修改涉及到其他人。</p><p id="eff3" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">第二个选择是同意非PHP的公共API。<br/>我们可以用JSON模式代替PHP类，并基于自定义名称进行路由，如<em class="kz">“place order”，就像我们在上面的例子</em>中所做的一样。</p><blockquote class="mk ml mm"><p id="cf68" class="iq ir kz is b it iu iv iw ix iy iz ja mn jc jd je mo jg jh ji mp jk jl jm jn hb bi translated">生态交错带是灵活的，可以根据你的需要进行调整。<br/>如果通过共享类来耦合服务在您的环境中没问题，那么您可以这样做。如果你想分离服务，你可以使用自定义名称。</p></blockquote><h1 id="878e" class="jw jx hi bd jy jz lg kb kc kd lh kf kg kh li kj kk kl lj kn ko kp lk kr ks kt bi translated">使用具有自定义路由的类</h1><p id="333b" class="pw-post-body-paragraph iq ir hi is b it ku iv iw ix kv iz ja jb kw jd je jf kx jh ji jj ky jl jm jn hb bi translated">即使如此，我们已经使用了自定义路由，我们仍然期待PlaceOrderCommand类。</p><pre class="la lb lc ld fd lz ma mb mc aw md bi"><span id="138a" class="me jx hi ma b fi mf mg l mh mi">#[Distributed]<br/>#[CommandHandler("placeOrder")]<br/>public function placeOrder(PlaceOrderCommand $command): void</span></pre><p id="fd23" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">基于路由，生态区知道它应该执行哪些处理程序，并基于方法声明知道它应该反序列化到哪个类。<br/>你所需要做的就是注册<a class="ae jo" href="https://docs.ecotone.tech/messaging/conversion/conversion" rel="noopener ugc nofollow" target="_blank">媒体类型转换器</a>，这样Content就知道如何将给定的内容类型反序列化为PHP类。</p><blockquote class="mk ml mm"><p id="c6f3" class="iq ir kz is b it iu iv iw ix iy iz ja mn jc jd je mo jg jh ji mp jk jl jm jn hb bi translated">如果您想使用简单类型，也可以为string键入提示以获取JSON，或者为array键入提示。</p><p id="ab71" class="iq ir kz is b it iu iv iw ix iy iz ja mn jc jd je mo jg jh ji mp jk jl jm jn hb bi translated">也可以没有任何参数，只根据路由名执行处理程序。</p></blockquote><h1 id="1d3b" class="jw jx hi bd jy jz lg kb kc kd lh kf kg kh li kj kk kl lj kn ko kp lk kr ks kt bi translated">发送/发布类</h1><p id="330b" class="pw-post-body-paragraph iq ir hi is b it ku iv iw ix kv iz ja jb kw jd je jf kx jh ji jj ky jl jm jn hb bi translated">如果您在发布者端注册了<a class="ae jo" href="https://docs.ecotone.tech/messaging/conversion/conversion" rel="noopener ugc nofollow" target="_blank">媒体类型转换器</a>，那么您可以发送命令和事件类。在发送到RabbitMQ之前，econtero会处理序列化。</p><figure class="la lb lc ld fd ij"><div class="bz dy l di"><div class="le lf l"/></div></figure><h1 id="194a" class="jw jx hi bd jy jz lg kb kc kd lh kf kg kh li kj kk kl lj kn ko kp lk kr ks kt bi translated">传递元数据</h1><p id="e1b4" class="pw-post-body-paragraph iq ir hi is b it ku iv iw ix kv iz ja jb kw jd je jf kx jh ji jj ky jl jm jn hb bi translated">有些情况下，您会希望用一些元数据来丰富消息。<br/>例如，您可以发布事件并添加当前登录用户的个人Id。如果我们将它放在有效载荷中，它很容易模糊事件，特别是可能有更多的元数据要存储。</p><p id="a01d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">消息类似于信件，信件包含标题(元数据)。<br/> Ecotone提供的解决方案允许我们以直接的方式添加和发送带有命令和事件的元数据。</p><figure class="la lb lc ld fd ij"><div class="bz dy l di"><div class="le lf l"/></div></figure><p id="7a63" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">假设我们有审计服务，它存储了谁禁止了用户的信息。</p><figure class="la lb lc ld fd ij"><div class="bz dy l di"><div class="le lf l"/></div></figure><p id="7892" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">或者，如果你想更具体，你可以直接传递具体的头</p><figure class="la lb lc ld fd ij"><div class="bz dy l di"><div class="le lf l"/></div></figure><h1 id="bb6f" class="jw jx hi bd jy jz lg kb kc kd lh kf kg kh li kj kk kl lj kn ko kp lk kr ks kt bi translated">交货保证</h1><p id="e49d" class="pw-post-body-paragraph iq ir hi is b it ku iv iw ix kv iz ja jb kw jd je jf kx jh ji jj ky jl jm jn hb bi translated">有些情况下，您可能希望一次发送多条消息。</p><figure class="la lb lc ld fd ij"><div class="bz dy l di"><div class="le lf l"/></div></figure><p id="a607" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如果在发送第二个命令之前或期间，由于任何原因，我们的代码会失败，那么我们可能会陷入只有第一个命令发出的情况。<br/>这会造成服务之间的不一致。</p><p id="17a8" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如果你使用本地的<a class="ae jo" href="https://docs.ecotone.tech/modelling/command-handling/external-command-handlers" rel="noopener ugc nofollow" target="_blank">命令</a> / <a class="ae jo" href="https://docs.ecotone.tech/modelling/event-handling/handling-events" rel="noopener ugc nofollow" target="_blank">事件</a>处理程序，默认情况下，econtero在RabbitMQ事务中包装这些处理程序。<br/>这保证了您的所有消息将在成功流结束时一起发送。</p><h1 id="dc50" class="jw jx hi bd jy jz lg kb kc kd lh kf kg kh li kj kk kl lj kn ko kp lk kr ks kt bi translated">处理大量消息</h1><p id="69db" class="pw-post-body-paragraph iq ir hi is b it ku iv iw ix kv iz ja jb kw jd je jf kx jh ji jj ky jl jm jn hb bi translated">如果我们将发送大量消息，那么我们将希望只将消息发送给能够处理特定消息的服务，以避免系统上不必要的负载。</p><blockquote class="mk ml mm"><p id="5352" class="iq ir kz is b it iu iv iw ix iy iz ja mn jc jd je mo jg jh ji mp jk jl jm jn hb bi translated">生态区仅向订阅它的服务发送事件。<br/>命令只发送给特定的目标服务。</p></blockquote><h1 id="924d" class="jw jx hi bd jy jz lg kb kc kd lh kf kg kh li kj kk kl lj kn ko kp lk kr ks kt bi translated">处理错误消息</h1><p id="ddc4" class="pw-post-body-paragraph iq ir hi is b it ku iv iw ix kv iz ja jb kw jd je jf kx jh ji jj ky jl jm jn hb bi translated">可能会出现事件或命令处理程序失败的情况。在这种情况下，RabbitMQ将尝试重新传递消息，直到成功。在此期间，其他消息将被阻止。</p><p id="d9e1" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">生态交错带<a class="ae jo" href="https://docs.ecotone.tech/modelling/asynchronous-handling#handling-error-messages" rel="noopener ugc nofollow" target="_blank">有解决方案</a>，允许你设置延迟重试。<br/>因此，如果消息失败，我们可以在X分钟后重试，在此期间，其他消息将被解除阻止。<br/>在规定的重试次数后，您可以将错误信息存储在<a class="ae jo" href="https://docs.ecotone.tech/modules/dbal-support#dead-letter" rel="noopener ugc nofollow" target="_blank">死信</a>(数据库)中，以便进一步调查。</p><h1 id="c879" class="jw jx hi bd jy jz lg kb kc kd lh kf kg kh li kj kk kl lj kn ko kp lk kr ks kt bi translated">摘要</h1><p id="222e" class="pw-post-body-paragraph iq ir hi is b it ku iv iw ix kv iz ja jb kw jd je jf kx jh ji jj ky jl jm jn hb bi translated">生态交错区为构建微服务提供了丰富的支持。<br/>由于它是基于消息传递概念构建的，所以所有工具都是自然的扩展。<br/>消息传递提供了稳定的基础，有助于跳过分布式架构带来的许多复杂性。<br/>econtero的目标是为开发者提供强大且易于使用的可靠工具。</p><p id="15da" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如果你想看econtero Lite中微服务集成的演示实现，你可以在这里查看。<br/>跟进生态交错带框架<a class="ae jo" href="https://github.com/ecotoneFramework/ecotone" rel="noopener ugc nofollow" target="_blank">点击此处</a>。</p></div></div>    
</body>
</html>