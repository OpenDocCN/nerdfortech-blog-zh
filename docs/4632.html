<html>
<head>
<title>Equatable and Comparable in Swift</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Swift中的等价和可比</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/equatable-and-comparable-in-swift-77f626d2d3d5?source=collection_archive---------9-----------------------#2021-07-30">https://medium.com/nerd-for-tech/equatable-and-comparable-in-swift-77f626d2d3d5?source=collection_archive---------9-----------------------#2021-07-30</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="baee" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">探索可比性和等价性，帮助你解决常见问题。</h2></div><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ix"><img src="../Images/247c98591dcf0de4c5763d9e8e26c796.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*PzWqzhKUm869gzxp"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">格伦·卡斯滕斯-彼得斯在<a class="ae jn" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><h2 id="bfab" class="jo jp hi bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">介绍</h2><p id="53c4" class="pw-post-body-paragraph km kn hi ko b kp kq ij kr ks kt im ku jz kv kw kx kd ky kz la kh lb lc ld le hb bi translated">在本文中，我将展示实现Comparable和Equatable在大多数情况下是如何帮助你的。我们走吧…</p><h2 id="7e1d" class="jo jp hi bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">等价的</h2><p id="c80e" class="pw-post-body-paragraph km kn hi ko b kp kq ij kr ks kt im ku jz kv kw kx kd ky kz la kh lb lc ld le hb bi translated">基于苹果的Swift文档:</p><blockquote class="lf lg lh"><p id="f3d5" class="km kn li ko b kp lj ij kr ks lk im ku ll lm kw kx ln lo kz la lp lq lc ld le hb bi translated">可以比较其值是否相等的类型。符合<code class="du lr ls lt lu b"><strong class="ko hj">Equatable</strong></code>协议的类型可以使用等于运算符(<code class="du lr ls lt lu b"><strong class="ko hj">==</strong></code>)比较相等性，或者使用不等于运算符(<code class="du lr ls lt lu b"><strong class="ko hj">!=</strong></code>)比较不相等性。Swift标准库中的大多数基本类型都符合<code class="du lr ls lt lu b"><strong class="ko hj">Equatable</strong></code>。</p></blockquote><h2 id="2813" class="jo jp hi bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">问题</h2><pre class="iy iz ja jb fd lv lu lw lx aw ly bi"><span id="1aa8" class="jo jp hi lu b fi lz ma l mb mc">struct Employee {<br/>   let department: String<br/>   let name: String<br/>   let happinessIndex: Int<br/>}</span><span id="398d" class="jo jp hi lu b fi md ma l mb mc"><strong class="lu hj">///employee we want to compare<br/>let</strong> johnFromIT = Employee(department: "IT", name: "John Doe", happinessIndex: <strong class="lu hj">0.8</strong>)</span><span id="1158" class="jo jp hi lu b fi md ma l mb mc"><strong class="lu hj">let</strong> johnFromHR = Employee(department: "HR", name: "John Doe", happinessIndex: <strong class="lu hj">0.8</strong>)</span><span id="2cac" class="jo jp hi lu b fi md ma l mb mc"><strong class="lu hj">let</strong> alsoJohnFromIT = Employee(department: "IT", name: "John Doe", happinessIndex: <strong class="lu hj">0.3</strong>)</span></pre><p id="4a7b" class="pw-post-body-paragraph km kn hi ko b kp lj ij kr ks lk im ku jz lm kw kx kd lo kz la kh lq lc ld le hb bi translated">如果我们想要检查是否是同一个员工，我们必须检查那个人是否有<strong class="ko hj">相同的名字</strong>和<strong class="ko hj">相同的部门</strong>。</p><pre class="iy iz ja jb fd lv lu lw lx aw ly bi"><span id="f3c1" class="jo jp hi lu b fi lz ma l mb mc"><strong class="lu hj">func</strong> isSamePerson(lhs: Employee, rhs: Employee) -&gt; <strong class="lu hj">Bool</strong> {<br/>   <strong class="lu hj">return</strong> lhs.name == rhs.name &amp;&amp; lhs.department == rhs.department<br/>}</span><span id="cb4a" class="jo jp hi lu b fi md ma l mb mc"><strong class="lu hj">///result<br/></strong>isSamePerson(lhs: johnFromIT, rhs: johnFromHR) <strong class="lu hj">//false</strong><br/>isSamePerson(lhs: johnFromIT, rhs: alsoJohnFromIT) <strong class="lu hj">//true</strong></span></pre><p id="2aab" class="pw-post-body-paragraph km kn hi ko b kp lj ij kr ks lk im ku jz lm kw kx kd lo kz la kh lq lc ld le hb bi translated">让我们用等式操作符(<code class="du lr ls lt lu b"><strong class="ko hj"><em class="li">==</em></strong></code>)或(<code class="du lr ls lt lu b"><strong class="ko hj"><em class="li">!=</em></strong></code>)来简化，要做到这一点，我们必须让我们的雇员符合等价的扩展。</p><pre class="iy iz ja jb fd lv lu lw lx aw ly bi"><span id="9647" class="jo jp hi lu b fi lz ma l mb mc">struct Employee: Equatable {<br/>   let department: String<br/>   let name: String<br/>   let happinessIndex: Int<br/>}</span><span id="9528" class="jo jp hi lu b fi md ma l mb mc"><strong class="lu hj">///result<br/></strong>johnFromHR == johnFromIT <strong class="lu hj">//false</strong><br/>johnFromIT == alsoJohnFromIT <strong class="lu hj">//false</strong></span></pre><p id="f825" class="pw-post-body-paragraph km kn hi ko b kp lj ij kr ks lk im ku jz lm kw kx kd lo kz la kh lq lc ld le hb bi translated">从上面的结果来看，<strong class="ko hj"> johnFromIT </strong>和<strong class="ko hj">alsohanfromit</strong>T21不是同一个人，因为编译器会比较存储的每一个等价属性(包括<strong class="ko hj"> happinessIndex </strong>)。所以要使这成为我们想要的，我们必须实现我们自己的比较方法。</p><pre class="iy iz ja jb fd lv lu lw lx aw ly bi"><span id="4106" class="jo jp hi lu b fi lz ma l mb mc"><strong class="lu hj">struct</strong> Employee: Equatable {<br/>   <strong class="lu hj">let</strong> department: String<br/>   <strong class="lu hj">let</strong> name: String<br/>   <strong class="lu hj">let</strong> happinessIndex: Double</span><span id="a09d" class="jo jp hi lu b fi md ma l mb mc"><strong class="lu hj">   static</strong> <strong class="lu hj">func</strong> == (lhs: Employee, rhs: Employee) -&gt; <strong class="lu hj">Bool</strong> {<br/>      <strong class="lu hj">return</strong> lhs.name == rhs.name &amp;&amp; <br/>             lhs.department == rhs.department<br/>   }<br/>}</span><span id="6bea" class="jo jp hi lu b fi md ma l mb mc"><strong class="lu hj">///result<br/></strong>johnFromHR == johnFromIT <strong class="lu hj">//false</strong><br/>johnFromIT == alsoJohnFromIT <strong class="lu hj">//true<br/></strong>[johnFromHR, johnFromIT].contains(alsoJohnFromIT) <strong class="lu hj">//true</strong></span></pre></div><div class="ab cl me mf gp mg" role="separator"><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj"/></div><div class="hb hc hd he hf"><h2 id="e709" class="jo jp hi bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">可比较的</h2><p id="55c7" class="pw-post-body-paragraph km kn hi ko b kp kq ij kr ks kt im ku jz kv kw kx kd ky kz la kh lb lc ld le hb bi translated">基于苹果的Swift文档:</p><blockquote class="lf lg lh"><p id="7b8f" class="km kn li ko b kp lj ij kr ks lk im ku ll lm kw kx ln lo kz la lp lq lc ld le hb bi translated"><code class="du lr ls lt lu b"><strong class="ko hj">Comparable</strong></code>协议用于具有固有顺序的类型，比如数字和字符串。当您希望能够使用关系操作符比较实例或者使用为<code class="du lr ls lt lu b"><strong class="ko hj">Comparable</strong></code>类型设计的标准库方法时，将<code class="du lr ls lt lu b"><strong class="ko hj">Comparable</strong></code>一致性添加到您自己的定制类型中。</p></blockquote><p id="fc25" class="pw-post-body-paragraph km kn hi ko b kp lj ij kr ks lk im ku jz lm kw kx kd lo kz la kh lq lc ld le hb bi translated">简而言之，可比协议允许值被认为小于或大于其他值。所以让我们继续以员工为例。</p><pre class="iy iz ja jb fd lv lu lw lx aw ly bi"><span id="9279" class="jo jp hi lu b fi lz ma l mb mc"><strong class="lu hj">let</strong> geralt = Employee(department: "Finance", name: "Geralt Rivia", happinessIndex: 0.9)</span><span id="ccbe" class="jo jp hi lu b fi md ma l mb mc"><strong class="lu hj">let</strong> anna = Employee(department: "HR", name: "Anna Henrietta", happinessIndex: 0.7)</span><span id="a39a" class="jo jp hi lu b fi md ma l mb mc"><strong class="lu hj">let</strong> triss = Employee(department: "IT", name: "Triss Merigold", happinessIndex: 0.8)</span><span id="e430" class="jo jp hi lu b fi md ma l mb mc"><strong class="lu hj">let</strong> employees = [geralt, anna, triss]</span></pre><p id="994f" class="pw-post-body-paragraph km kn hi ko b kp lj ij kr ks lk im ku jz lm kw kx kd lo kz la kh lq lc ld le hb bi translated">假设我们的目标是从员工列表中找到最快乐的员工</p><pre class="iy iz ja jb fd lv lu lw lx aw ly bi"><span id="1b5d" class="jo jp hi lu b fi lz ma l mb mc"><strong class="lu hj">struct</strong> Employee: Comparable {<br/>...<br/>   <strong class="lu hj">static</strong> <strong class="lu hj">func</strong> &lt; (lhs: Employee, rhs: Employee) -&gt; Bool {<br/>      <strong class="lu hj">return</strong> lhs.happinessIndex &lt; rhs.happinessIndex<br/>   }<br/>}<br/><strong class="lu hj">///result<br/></strong>empployees.sorted() <strong class="lu hj">//[Anna, Triss, Geralt] sort by lowest index<br/></strong>empployees.max() <strong class="lu hj">//Geralt, is happiest employee<br/></strong>empployees.min() <strong class="lu hj">//Anna</strong></span></pre><p id="6286" class="pw-post-body-paragraph km kn hi ko b kp lj ij kr ks lk im ku jz lm kw kx kd lo kz la kh lq lc ld le hb bi translated">欢迎提问和指正。</p></div></div>    
</body>
</html>