<html>
<head>
<title>Lets Talk About Tree DS:</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">让我们来谈谈树d:</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/lets-talk-about-tree-ds-2f9ebad303ac?source=collection_archive---------1-----------------------#2020-08-25">https://medium.com/nerd-for-tech/lets-talk-about-tree-ds-2f9ebad303ac?source=collection_archive---------1-----------------------#2020-08-25</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div class="er es if"><img src="../Images/f16db635c8dce467a9aa29cfe16f01fc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1240/format:webp/1*2YtvQ3DW-9zS2XiJfkS-Cg.jpeg"/></div></figure><h1 id="f0f3" class="im in hi bd io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj bi translated">简介:</h1><p id="c4c0" class="pw-post-body-paragraph jk jl hi jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh hb bi translated">它是一种非线性数据结构，用于表示分层数据。我们有不同的数据结构，在选择数据结构之前，当检查以下几点时，会出现使用哪一个的问题:</p><ol class=""><li id="d473" class="ki kj hi jm b jn kk jr kl jv km jz kn kd ko kh kp kq kr ks bi translated">需要储存什么？？</li><li id="165d" class="ki kj hi jm b jn kt jr ku jv kv jz kw kd kx kh kp kq kr ks bi translated">使用哪种数据结构会使常用操作的成本最小化？？</li><li id="d4b6" class="ki kj hi jm b jn kt jr ku jv kv jz kw kd kx kh kp kq kr ks bi translated">哪种方式需要的内存最少？？</li><li id="5046" class="ki kj hi jm b jn kt jr ku jv kv jz kw kd kx kh kp kq kr ks bi translated">易于实施..</li></ol><p id="496c" class="pw-post-body-paragraph jk jl hi jm b jn kk jp jq jr kl jt ju jv ky jx jy jz kz kb kc kd la kf kg kh hb bi translated"><strong class="jm hj">在深入探讨之前，让我们先来看看树形数据结构在我们日常生活中的一些应用:</strong></p><p id="c4d4" class="pw-post-body-paragraph jk jl hi jm b jn kk jp jq jr kl jt ju jv ky jx jy jz kz kb kc kd la kf kg kh hb bi translated">I)我的计算机中的信息是按层次顺序存储的。</p><p id="11f4" class="pw-post-body-paragraph jk jl hi jm b jn kk jp jq jr kl jt ju jv ky jx jy jz kz kb kc kd la kf kg kh hb bi translated">ii)动态拼写检查(字典)</p><p id="7721" class="pw-post-body-paragraph jk jl hi jm b jn kk jp jq jr kl jt ju jv ky jx jy jz kz kb kc kd la kf kg kh hb bi translated">iii)网络路由算法</p><p id="aa3a" class="pw-post-body-paragraph jk jl hi jm b jn kk jp jq jr kl jt ju jv ky jx jy jz kz kb kc kd la kf kg kh hb bi translated">iv)公司员工的组织及其他..</p><h2 id="1e04" class="lb in hi bd io lc ld le is lf lg lh iw jv li lj ja jz lk ll je kd lm ln ji lo bi translated">与树形数据结构相关的术语:</h2><figure class="lq lr ls lt fd ij er es paragraph-image"><div role="button" tabindex="0" class="lu lv di lw bf lx"><div class="er es lp"><img src="../Images/5cbaa6aa41c9fabf6d72b4a109e5b343.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*54AFwYcU4iq7-J8QL8Rn2w.png"/></div></div><figcaption class="ly lz et er es ma mb bd b be z dx translated">来源谷歌图片</figcaption></figure><p id="102a" class="pw-post-body-paragraph jk jl hi jm b jn kk jp jq jr kl jt ju jv ky jx jy jz kz kb kc kd la kf kg kh hb bi translated">→ <strong class="jm hj">根</strong>节点没有任何父节点。</p><p id="2688" class="pw-post-body-paragraph jk jl hi jm b jn kk jp jq jr kl jt ju jv ky jx jy jz kz kb kc kd la kf kg kh hb bi translated">→ <strong class="jm hj">叶</strong>节点没有任何子节点</p><p id="25b3" class="pw-post-body-paragraph jk jl hi jm b jn kk jp jq jr kl jt ju jv ky jx jy jz kz kb kc kd la kf kg kh hb bi translated">→ <strong class="jm hj">同一个父节点的子节点</strong>被称为<strong class="jm hj">兄弟节点</strong></p><p id="61d5" class="pw-post-body-paragraph jk jl hi jm b jn kk jp jq jr kl jt ju jv ky jx jy jz kz kb kc kd la kf kg kh hb bi translated">→在有n个节点的树中，将有n-1条边或链接</p><p id="ef48" class="pw-post-body-paragraph jk jl hi jm b jn kk jp jq jr kl jt ju jv ky jx jy jz kz kb kc kd la kf kg kh hb bi translated">→ <strong class="jm hj">任意节点x的深度</strong>是从根到x的路径长度。</p><p id="e8be" class="pw-post-body-paragraph jk jl hi jm b jn kk jp jq jr kl jt ju jv ky jx jy jz kz kb kc kd la kf kg kh hb bi translated">→<strong class="jm hj">根</strong>节点的<strong class="jm hj">深度</strong>为<strong class="jm hj"> 0 </strong></p><p id="78c6" class="pw-post-body-paragraph jk jl hi jm b jn kk jp jq jr kl jt ju jv ky jx jy jz kz kb kc kd la kf kg kh hb bi translated">→ <strong class="jm hj">任意节点x的高度</strong>是从x到一个叶节点的最长路径中的边数。所以叶节点的高度为0。</p><h2 id="c3ad" class="lb in hi bd io lc ld le is lf lg lh iw jv li lj ja jz lk ll je kd lm ln ji lo bi translated">树形数据结构的类型:</h2><p id="e4a3" class="pw-post-body-paragraph jk jl hi jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh hb bi translated">a) <strong class="jm hj">一般树</strong>:它可以有无限多个子树。它是所有其他类型树的超集。</p><figure class="lq lr ls lt fd ij er es paragraph-image"><div class="er es mc"><img src="../Images/449f947dc07215e00dcc28871fdd861f.png" data-original-src="https://miro.medium.com/v2/resize:fit:914/format:webp/1*p_GfAlQHp4btK9Monl4wQQ.png"/></div><figcaption class="ly lz et er es ma mb bd b be z dx translated">源-检查雷达</figcaption></figure><p id="478a" class="pw-post-body-paragraph jk jl hi jm b jn kk jp jq jr kl jt ju jv ky jx jy jz kz kb kc kd la kf kg kh hb bi translated">b) <strong class="jm hj">二叉树</strong>:二叉树的任何节点最多可以有两个子节点。</p><figure class="lq lr ls lt fd ij er es paragraph-image"><div class="er es md"><img src="../Images/5ec4f634aabf2bb30b31a319e6d0125e.png" data-original-src="https://miro.medium.com/v2/resize:fit:834/format:webp/1*fLRe-YsCU_Er4BkHumIjZQ.png"/></div><figcaption class="ly lz et er es ma mb bd b be z dx translated">源代码级升级编码</figcaption></figure><p id="c2f5" class="pw-post-body-paragraph jk jl hi jm b jn kk jp jq jr kl jt ju jv ky jx jy jz kz kb kc kd la kf kg kh hb bi translated">c) <strong class="jm hj">二叉查找树</strong>:就像二叉树一样，它的任何节点都不能有两个以上的子节点。与二叉查找树的情况一样，左子码的值总是小于或等于父节点，而右节点的值大于或等于父节点。它也被称为搜索树，因为借助上述属性，它可以帮助我们进行比较和相应的搜索。</p><figure class="lq lr ls lt fd ij er es paragraph-image"><div class="er es me"><img src="../Images/2dd754614cce631053ae6c544b0bdb79.png" data-original-src="https://miro.medium.com/v2/resize:fit:700/format:webp/1*M1wVV2FrTRQrjFdh--oQOw.jpeg"/></div><figcaption class="ly lz et er es ma mb bd b be z dx translated">来源-教程点</figcaption></figure><p id="127d" class="pw-post-body-paragraph jk jl hi jm b jn kk jp jq jr kl jt ju jv ky jx jy jz kz kb kc kd la kf kg kh hb bi translated">d) <strong class="jm hj"> AVL树:N </strong>以发明者<strong class="jm hj">A</strong>delson-<strong class="jm hj">V</strong>elsky和<strong class="jm hj"> L </strong>命名，是第一棵动态平衡树。在该树中，任何节点的两个子子树的高度最多相差1，即对于任何节点的子子树:</p><p id="364c" class="pw-post-body-paragraph jk jl hi jm b jn kk jp jq jr kl jt ju jv ky jx jy jz kz kb kc kd la kf kg kh hb bi translated"><code class="du mf mg mh mi b">-1 ≤ height of left subtree — height of right subtree ≤1</code></p><p id="eef5" class="pw-post-body-paragraph jk jl hi jm b jn kk jp jq jr kl jt ju jv ky jx jy jz kz kb kc kd la kf kg kh hb bi translated">如果执行任何违反上述条件的操作，就会发生重新排序。</p><figure class="lq lr ls lt fd ij er es paragraph-image"><div class="er es mj"><img src="../Images/79d791529fd27e53afc229125f41f156.png" data-original-src="https://miro.medium.com/v2/resize:fit:524/format:webp/1*Cji3x98gdMJ0j6S7DCqdRQ.png"/></div><figcaption class="ly lz et er es ma mb bd b be z dx translated">来源-维基百科</figcaption></figure><p id="0ce8" class="pw-post-body-paragraph jk jl hi jm b jn kk jp jq jr kl jt ju jv ky jx jy jz kz kb kc kd la kf kg kh hb bi translated">e) <strong class="jm hj">红黑树</strong>:这是另一种自平衡树，节点被涂上红色和黑色，以保持树的平衡。因为它应该遵循某些规则:根节点是黑色的，没有两个相邻的节点可以是红色的，叶节点是黑色的，一个节点到它的任何子代空节点的每条路径必须具有相等数量的黑色节点。</p><figure class="lq lr ls lt fd ij er es paragraph-image"><div class="er es mk"><img src="../Images/e590fe885cb1f3fc180602746d8a64e0.png" data-original-src="https://miro.medium.com/v2/resize:fit:852/format:webp/1*gP1XrkOPweE4yJNKn5IPMQ.png"/></div><figcaption class="ly lz et er es ma mb bd b be z dx translated">来源-极客的极客</figcaption></figure><p id="f5e5" class="pw-post-body-paragraph jk jl hi jm b jn kk jp jq jr kl jt ju jv ky jx jy jz kz kb kc kd la kf kg kh hb bi translated">f) <strong class="jm hj"> N叉树</strong>:这里任何节点最多可以有N个子节点。在全N元树的情况下，每个节点可以有0或N个子节点。在完整的N元树的情况下，所有的叶节点都在同一层。Trie是N元树最常见的实现。例如，二叉树就是二叉树的一个例子。</p><p id="7421" class="pw-post-body-paragraph jk jl hi jm b jn kk jp jq jr kl jt ju jv ky jx jy jz kz kb kc kd la kf kg kh hb bi translated">g) <strong class="jm hj"> B树</strong>:也是一种自平衡树数据结构。它概括了一个二叉查找树，因为它可以有两个以上的孩子。</p><p id="3895" class="pw-post-body-paragraph jk jl hi jm b jn kk jp jq jr kl jt ju jv ky jx jy jz kz kb kc kd la kf kg kh hb bi translated">我希望上面的文章能够很好地概述树数据结构。我将尝试就这些不同类型的树的细节和实现写单独的文章。</p><p id="baef" class="pw-post-body-paragraph jk jl hi jm b jn kk jp jq jr kl jt ju jv ky jx jy jz kz kb kc kd la kf kg kh hb bi translated">文章结尾。</p><p id="6874" class="pw-post-body-paragraph jk jl hi jm b jn kk jp jq jr kl jt ju jv ky jx jy jz kz kb kc kd la kf kg kh hb bi translated">希望有帮助:)</p><p id="a355" class="pw-post-body-paragraph jk jl hi jm b jn kk jp jq jr kl jt ju jv ky jx jy jz kz kb kc kd la kf kg kh hb bi translated">谢谢你，读者...</p><p id="a8f1" class="pw-post-body-paragraph jk jl hi jm b jn kk jp jq jr kl jt ju jv ky jx jy jz kz kb kc kd la kf kg kh hb bi translated">快乐编码...</p></div></div>    
</body>
</html>