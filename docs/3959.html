<html>
<head>
<title>S O L I D Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">蟒蛇皮</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/solid-principles-python-f09915698d85?source=collection_archive---------0-----------------------#2021-07-01">https://medium.com/nerd-for-tech/solid-principles-python-f09915698d85?source=collection_archive---------0-----------------------#2021-07-01</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><blockquote class="if"><p id="f373" class="ig ih hi bd ii ij ik il im in io ip dx translated">"如果建筑者像程序员写程序那样建造房屋，那么第一只啄木鸟就会毁灭文明"。(杰拉尔德·温伯格)</p></blockquote><h2 id="3783" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">在建筑商那里，建筑应该是坚固的，纯粹的坚固；) .</h2></div><div class="ab cl jo jp gp jq" role="separator"><span class="jr bw bk js jt ju"/><span class="jr bw bk js jt ju"/><span class="jr bw bk js jt"/></div><div class="hb hc hd he hf"><h1 id="88cb" class="jv ir hi bd is jw jx jy iw jz ka kb ja kc kd ke je kf kg kh ji ki kj kk jm kl bi translated"><strong class="ak"> S O L I D </strong></h1><p id="1182" class="pw-post-body-paragraph km kn hi ko b kp kq kr ks kt ku kv kw jb kx ky kz jf la lb lc jj ld le lf ip hb bi translated">在软件工程中，我们为高效的应用程序编写高效的算法。一旦算法到位，最重要和最关键的事情将是确保应用程序是按照最佳设计和架构实践来设计的。<strong class="ko hj"> SOLID </strong>据说是最好的设计实践之一。</p><p id="8a75" class="pw-post-body-paragraph km kn hi ko b kp lg kr ks kt lh kv kw jb li ky kz jf lj lb lc jj lk le lf ip hb bi translated">术语<strong class="ko hj">固体</strong>描述了由<strong class="ko hj"> <em class="ll">鲍勃大叔发明的用于更好编码风格的</em></strong>设计原则的<strong class="ko hj">集合！ </strong> <em class="ll">哦你知道</em> <strong class="ko hj"> <em class="ll">鲍勃叔叔</em> </strong> <em class="ll">是谁吗？嗯，他不是别人，正是</em> <strong class="ko hj">罗伯特·c·马丁</strong>，你是对的，<strong class="ko hj">干净代码之父。</strong></p><blockquote class="if"><p id="dfe0" class="ig ih hi bd ii ij lm ln lo lp lq ip dx translated">"如果两者都冻结了，在水面上行走和根据规范开发软件是容易的. "爱德华·v·贝拉德</p></blockquote><figure class="lr ls lt lu lv lw er es paragraph-image"><div class="ab fe cl lx"><img src="../Images/6f8ba2b6672ba542053060e6c85df8fa.png" data-original-src="https://miro.medium.com/v2/0*tdjkcO9SOpRCx9tp"/></div><figcaption class="ma mb et er es mc md bd b be z dx translated">资料来源:unsplash。功劳归于@templecerulean</figcaption></figure><p id="06f4" class="pw-post-body-paragraph km kn hi ko b kp lg kr ks kt lh kv kw jb li ky kz jf lj lb lc jj lk le lf ip hb bi translated">当你遵循坚实的基础时，你实际上是在编写更简单、更容易理解、可维护和可扩展的代码，这将为你的团队节省大量时间。特别是当一群人在一个有几十万行代码的更大的代码库上一起工作时，坚实的基础就成了必须。让我们马上进入主题。</p><p id="303f" class="pw-post-body-paragraph km kn hi ko b kp lg kr ks kt lh kv kw jb li ky kz jf lj lb lc jj lk le lf ip hb bi translated">缩写<strong class="ko hj"> SOLID </strong>实际上涵盖了 5 个重要原则:</p><ul class=""><li id="7492" class="me mf hi ko b kp lg kt lh jb mg jf mh jj mi ip mj mk ml mm bi translated">单一责任原则</li><li id="3e9b" class="me mf hi ko b kp mn kt mo jb mp jf mq jj mr ip mj mk ml mm bi translated">开闭原则(OCP)</li><li id="8be9" class="me mf hi ko b kp mn kt mo jb mp jf mq jj mr ip mj mk ml mm bi translated">利斯科夫替代原理(LSP)</li><li id="34cc" class="me mf hi ko b kp mn kt mo jb mp jf mq jj mr ip mj mk ml mm bi translated">接口隔离原则(ISP)</li><li id="1834" class="me mf hi ko b kp mn kt mo jb mp jf mq jj mr ip mj mk ml mm bi translated">依赖性倒置原则</li></ul><p id="745d" class="pw-post-body-paragraph km kn hi ko b kp lg kr ks kt lh kv kw jb li ky kz jf lj lb lc jj lk le lf ip hb bi translated">让我们从单一责任原则开始</p></div><div class="ab cl jo jp gp jq" role="separator"><span class="jr bw bk js jt ju"/><span class="jr bw bk js jt ju"/><span class="jr bw bk js jt"/></div><div class="hb hc hd he hf"><h1 id="71cf" class="jv ir hi bd is jw jx jy iw jz ka kb ja kc kd ke je kf kg kh ji ki kj kk jm kl bi translated"><strong class="ak">单一责任原则</strong></h1><p id="b9e2" class="pw-post-body-paragraph km kn hi ko b kp kq kr ks kt ku kv kw jb kx ky kz jf la lb lc jj ld le lf ip hb bi translated">单一职责原则或 SRP 声明每个类或功能应该处理单一任务。这意味着如果您定义了一个类来加载数据，您就不应该使用同一个类来更新您的数据库。每个职能都有一个单一的责任，因此也有一个单一的变革理由。因此，如果你的类或函数加载数据，修改数据，并绘制数据，那么在返回结果之前，一切都要马上停止。罗伯特·c·马丁对此的解释是:</p><blockquote class="if"><p id="7366" class="ig ih hi bd ii ij lm ln lo lp lq ip dx translated">“一个<!-- -->类应该只有一个改变的理由”。</p></blockquote><p id="28b5" class="pw-post-body-paragraph km kn hi ko b kp ms kr ks kt mt kv kw jb mu ky kz jf mv lb lc jj mw le lf ip hb bi translated">所以，仅仅因为你可以在你的类或函数中添加任何你想要的东西并不意味着你应该这样做。</p><p id="be61" class="pw-post-body-paragraph km kn hi ko b kp lg kr ks kt lh kv kw jb li ky kz jf lj lb lc jj lk le lf ip hb bi translated">我们来举个<code class="du mx my mz na b">PhoneBook</code>的例子。我们的<code class="du mx my mz na b">PhoneBook</code>只包含<code class="du mx my mz na b">person</code>的<code class="du mx my mz na b">name</code>和<code class="du mx my mz na b">number</code>。它的主要职责是管理联系号码。因此，我们的类的功能将是<code class="du mx my mz na b">adding new contact</code>、<code class="du mx my mz na b">deleting existing contact</code>、<code class="du mx my mz na b">change a contact number </code>和<code class="du mx my mz na b">search a number by name</code>。所以我们的<code class="du mx my mz na b">PhoneBook</code>类可能是这样的:</p><figure class="nb nc nd ne fd lw"><div class="bz dy l di"><div class="nf ng l"/></div></figure><p id="36cb" class="pw-post-body-paragraph km kn hi ko b kp lg kr ks kt lh kv kw jb li ky kz jf lj lb lc jj lk le lf ip hb bi translated">现在，假设我们有另一个将<code class="du mx my mz na b">contacts</code>的所有数据保存到<code class="du mx my mz na b">database</code>的需求，所以我们添加了另一个将联系人保存到<code class="du mx my mz na b">db</code>的函数，我们还想将数据保存到<code class="du mx my mz na b">csv file</code>。让我们也添加存储数据到<code class="du mx my mz na b">csv</code>文件的功能。</p><figure class="nb nc nd ne fd lw"><div class="bz dy l di"><div class="nf ng l"/></div></figure><p id="f4e4" class="pw-post-body-paragraph km kn hi ko b kp lg kr ks kt lh kv kw jb li ky kz jf lj lb lc jj lk le lf ip hb bi translated">等等！我们是否违反了单一责任的原则？是的，我们是！</p><p id="05df" class="pw-post-body-paragraph km kn hi ko b kp lg kr ks kt lh kv kw jb li ky kz jf lj lb lc jj lk le lf ip hb bi translated">在给<code class="du mx my mz na b">db</code>和<code class="du mx my mz na b">csv</code>增加存储数据的额外功能时，我们实际上打破了单一责任的原则。因为，通过增加这些功能，我们给我们的类增加了额外的责任，除了它的主要责任。将来，如果需要对保存到<code class="du mx my mz na b">db</code>的数据进行任何更改，也可以更改我们的类别电话簿。因此，除了它的主要职责之外，这个类很容易改变。</p><blockquote class="if"><p id="a772" class="ig ih hi bd ii ij lm ln lo lp lq ip dx translated">单一责任原则只是要求我们不要给一个类增加额外的责任，这样我们就不必修改一个类，除非它的主要责任发生了变化。</p></blockquote><p id="00e7" class="pw-post-body-paragraph km kn hi ko b kp ms kr ks kt mt kv kw jb mu ky kz jf mv lb lc jj mw le lf ip hb bi translated">让我们解决违规问题。我们需要做的就是定义单独的类来处理<code class="du mx my mz na b">database</code>存储和保存到<code class="du mx my mz na b">csv</code>。我们将把联系对象传递给那些类。</p><figure class="nb nc nd ne fd lw"><div class="bz dy l di"><div class="nf ng l"/></div></figure></div><div class="ab cl jo jp gp jq" role="separator"><span class="jr bw bk js jt ju"/><span class="jr bw bk js jt ju"/><span class="jr bw bk js jt"/></div><div class="hb hc hd he hf"><h1 id="36c3" class="jv ir hi bd is jw jx jy iw jz ka kb ja kc kd ke je kf kg kh ji ki kj kk jm kl bi translated">开闭原则:</h1><p id="fc5d" class="pw-post-body-paragraph km kn hi ko b kp kq kr ks kt ku kv kw jb kx ky kz jf la lb lc jj ld le lf ip hb bi translated"><strong class="ko hj">开闭原则</strong>也叫迈耶的开闭原则，是由 Berterd Meyer 于 1988 年在其著作<a class="ae nh" href="https://en.wikipedia.org/wiki/Object-Oriented_Software_Construction" rel="noopener ugc nofollow" target="_blank"> <em class="ll">面向对象软件构造</em> </a> <em class="ll">中首次概念化的。鲍勃大叔</em>提到这是“面向对象设计最重要的原则”。开闭原则规定:</p><blockquote class="if"><p id="bf92" class="ig ih hi bd ii ij lm ln lo lp lq ip dx translated"><em class="ni">软件实体(类、模块、功能等。)应为扩展打开，但为修改关闭</em>"</p></blockquote><p id="ea09" class="pw-post-body-paragraph km kn hi ko b kp ms kr ks kt mt kv kw jb mu ky kz jf mv lb lc jj mw le lf ip hb bi translated">也就是说，这样的实体可以允许其行为被扩展，而无需修改其源代码。</p><ul class=""><li id="11c1" class="me mf hi ko b kp lg kt lh jb mg jf mh jj mi ip mj mk ml mm bi translated">如果一个模块仍然可以扩展，那么这个模块就被认为是开放的。例如，应该可以向它包含的数据结构添加字段，或者向它执行的功能集添加新元素。</li><li id="e1a4" class="me mf hi ko b kp mn kt mo jb mp jf mq jj mr ip mj mk ml mm bi translated">如果一个模块可供其他模块使用，那么这个模块就是关闭的。这假设模块已经被赋予了一个定义良好的、稳定的描述(信息隐藏意义上的接口)。</li></ul><p id="24af" class="pw-post-body-paragraph km kn hi ko b kp lg kr ks kt lh kv kw jb li ky kz jf lj lb lc jj lk le lf ip hb bi translated">这个原则确保了一个类被定义为做它应该做的事情。</p><p id="e428" class="pw-post-body-paragraph km kn hi ko b kp lg kr ks kt lh kv kw jb li ky kz jf lj lb lc jj lk le lf ip hb bi translated">如果我们想要添加任何进一步的特性，我们可以通过创建新的实体来扩展现有类的特性，并向其自身添加更多的特性。从而防止对已建立的低级类进行频繁而琐碎的更改。</p><p id="a6b1" class="pw-post-body-paragraph km kn hi ko b kp lg kr ks kt lh kv kw jb li ky kz jf lj lb lc jj lk le lf ip hb bi translated">假设我们有一个针对 m 的申请，我们系统的一个特性是根据服装类型应用折扣。很好，所以在下面的例子中我们有一个类<code class="du mx my mz na b">CalculateDiscount</code>，它有一个<em class="ll">属性</em>来保存<code class="du mx my mz na b"><em class="ll">cloths</em></code>的类型。它有一个基于衣服类型计算折扣并返回折扣金额的功能。</p><figure class="nb nc nd ne fd lw"><div class="bz dy l di"><div class="nf ng l"/></div></figure><p id="ed43" class="pw-post-body-paragraph km kn hi ko b kp lg kr ks kt lh kv kw jb li ky kz jf lj lb lc jj lk le lf ip hb bi translated">这种设计明显违反了开闭原则，因为在以下情况下需要修改:</p><ol class=""><li id="05f7" class="me mf hi ko b kp lg kt lh jb mg jf mh jj mi ip nj mk ml mm bi translated">折扣列表中将包括新的服装类型</li><li id="27f9" class="me mf hi ko b kp mn kt mo jb mp jf mq jj mr ip nj mk ml mm bi translated">任何服装变更的折扣金额。</li></ol><p id="1601" class="pw-post-body-paragraph km kn hi ko b kp lg kr ks kt lh kv kw jb li ky kz jf lj lb lc jj lk le lf ip hb bi translated">为了避免这种违反，我们可以做的是用抽象方法<code class="du mx my mz na b">apply_discount</code>创建一个类。让我们看看这个例子:</p><figure class="nb nc nd ne fd lw"><div class="bz dy l di"><div class="nf ng l"/></div></figure><p id="bf78" class="pw-post-body-paragraph km kn hi ko b kp lg kr ks kt lh kv kw jb li ky kz jf lj lb lc jj lk le lf ip hb bi translated">在这里，我们有带单个<code class="du mx my mz na b">abstract</code>方法<code class="du mx my mz na b">apply_discount</code>的类<code class="du mx my mz na b">CalculateDiscount</code>，我们有扩展<code class="du mx my mz na b">CalculateDiscount</code>的单个服装的单个类，所以每个子类需要自己实现<code class="du mx my mz na b">apply_discount</code>，这避免了修改基类的约束。如果需要，我们可以添加新产品并更改折扣金额，而无需更改基本类别。</p></div><div class="ab cl jo jp gp jq" role="separator"><span class="jr bw bk js jt ju"/><span class="jr bw bk js jt ju"/><span class="jr bw bk js jt"/></div><div class="hb hc hd he hf"><h1 id="ccb1" class="jv ir hi bd is jw jx jy iw jz ka kb ja kc kd ke je kf kg kh ji ki kj kk jm kl bi translated">利斯科夫替代原理</h1><p id="d11b" class="pw-post-body-paragraph km kn hi ko b kp kq kr ks kt ku kv kw jb kx ky kz jf la lb lc jj ld le lf ip hb bi translated">利斯科夫替代原理或<a class="ae nh" href="http://c2.com/cgi/wiki?LiskovSubstitutionPrinciple" rel="noopener ugc nofollow" target="_blank"> <strong class="ko hj"> LSP </strong> </a>指出:</p><blockquote class="if"><p id="6c58" class="ig ih hi bd ii ij lm ln lo lp lq ip dx translated">“程序中的对象应该可以用其子类型的实例来替换，而不会改变程序的正确性”</p></blockquote><p id="049c" class="pw-post-body-paragraph km kn hi ko b kp ms kr ks kt mt kv kw jb mu ky kz jf mv lb lc jj mw le lf ip hb bi translated"><strong class="ko hj">利斯科夫替代原理</strong> ( <strong class="ko hj"> LSP </strong>)是一种子类型关系的特殊定义，称为(<strong class="ko hj">强</strong> ) <a class="ae nh" href="https://en.wikipedia.org/wiki/Behavioral_subtyping" rel="noopener ugc nofollow" target="_blank"> <strong class="ko hj">行为子类型</strong> </a>，最初是由<a class="ae nh" href="https://en.wikipedia.org/wiki/Barbara_Liskov" rel="noopener ugc nofollow" target="_blank"> Barbara Liskov </a>在 1988 年提出的。该原则指出:</p><blockquote class="nk nl nm"><p id="3ab9" class="km kn ll ko b kp lg kr ks kt lh kv kw nn li ky kz no lj lb lc np lk le lf ip hb bi translated">如果 S 是 T 的子类型，那么类型为 T 的<a class="ae nh" href="https://en.wikipedia.org/wiki/Datatype" rel="noopener ugc nofollow" target="_blank">对象可以用类型为 S 的对象替换<em class="hi">(即，类型为 T 的对象可以用类型为 S 的任何对象<em class="hi">替换</em>，而不改变程序的任何期望属性(正确性、执行的任务等)。)</em></a></p></blockquote><p id="2d5a" class="pw-post-body-paragraph km kn hi ko b kp lg kr ks kt lh kv kw jb li ky kz jf lj lb lc jj lk le lf ip hb bi translated">让我们有一个基类<code class="du mx my mz na b">Animal</code>来表示动物的类型。<code class="du mx my mz na b">Cat</code>类继承自<code class="du mx my mz na b">Animal</code>。类似地，<code class="du mx my mz na b">Cat</code>类也可以被其他类继承。</p><figure class="nb nc nd ne fd lw"><div class="bz dy l di"><div class="nf ng l"/></div></figure><p id="56eb" class="pw-post-body-paragraph km kn hi ko b kp lg kr ks kt lh kv kw jb li ky kz jf lj lb lc jj lk le lf ip hb bi translated">假设我们必须找出所有白色的猫。让我们定义一个<code class="du mx my mz na b">function</code>，让所有的<code class="du mx my mz na b">cats</code>都是白色，然后运行程序:</p><figure class="nb nc nd ne fd lw"><div class="bz dy l di"><div class="nf ng l"/></div></figure><blockquote class="nk nl nm"><p id="e5bb" class="km kn ll ko b kp lg kr ks kt lh kv kw nn li ky kz no lj lb lc np lk le lf ip hb bi translated"><strong class="ko hj">注</strong>:由于没有添加<em class="hi">动物属性的标准规范。你可以将它实现为一个字典，你的团队成员可以将它用作元组，因此它可以实现为多种方式</em></p></blockquote><p id="ef58" class="pw-post-body-paragraph km kn hi ko b kp lg kr ks kt lh kv kw jb li ky kz jf lj lb lc jj lk le lf ip hb bi translated">输出将如下所示:</p><figure class="nb nc nd ne fd lw er es paragraph-image"><div role="button" tabindex="0" class="nr ns di nt bf nu"><div class="er es nq"><img src="../Images/5fd9a27ce3ffc196efb50b510e02031f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CxIYGd_L9QaPDMMNJmPwEw.png"/></div></div></figure><p id="22ec" class="pw-post-body-paragraph km kn hi ko b kp lg kr ks kt lh kv kw jb li ky kz jf lj lb lc jj lk le lf ip hb bi translated">在这里，我们可以看到，在遍历动物列表时，我们违反了 liskov 替换原则，因为我们不能用子类型<code class="du mx my mz na b"><em class="ll">Cat</em></code> <em class="ll"> </em>的对象替换超类型<code class="du mx my mz na b"><em class="ll">Animal’s</em></code> <em class="ll"> </em>对象，这是为了获得白色<code class="du mx my mz na b">cats</code>而编写的函数。</p><p id="06fb" class="pw-post-body-paragraph km kn hi ko b kp lg kr ks kt lh kv kw jb li ky kz jf lj lb lc jj lk le lf ip hb bi translated">更好的方法可能是在超类<code class="du mx my mz na b"><em class="ll">Animal</em></code> <em class="ll"> </em>中引入<code class="du mx my mz na b">setter</code>和<code class="du mx my mz na b">getter</code>方法，使用它们我们可以设置和获取<code class="du mx my mz na b"><em class="ll">Animal's</em></code> <em class="ll"> </em>属性，而不会将实现留给个人。</p><p id="b8bc" class="pw-post-body-paragraph km kn hi ko b kp lg kr ks kt lh kv kw jb li ky kz jf lj lb lc jj lk le lf ip hb bi translated">因此，我们可以使用如下所示的<code class="du mx my mz na b">getter</code>和<code class="du mx my mz na b">setter</code>遵循利斯科夫替代原理:</p><figure class="nb nc nd ne fd lw"><div class="bz dy l di"><div class="nf ng l"/></div></figure></div><div class="ab cl jo jp gp jq" role="separator"><span class="jr bw bk js jt ju"/><span class="jr bw bk js jt ju"/><span class="jr bw bk js jt"/></div><div class="hb hc hd he hf"><h1 id="9760" class="jv ir hi bd is jw jx jy iw jz ka kb ja kc kd ke je kf kg kh ji ki kj kk jm kl bi translated">界面分离原理</h1><p id="eae6" class="pw-post-body-paragraph km kn hi ko b kp kq kr ks kt ku kv kw jb kx ky kz jf la lb lc jj ld le lf ip hb bi translated"><a class="ae nh" href="https://en.wikipedia.org/wiki/Interface_segregation_principle#:~:text=In%20the%20field%20of%20software,methods%20it%20does%20not%20use.&amp;text=ISP%20is%20intended%20to%20keep,refactor%2C%20change%2C%20and%20redeploy." rel="noopener ugc nofollow" target="_blank">界面分离原理</a>指出，</p><blockquote class="if"><p id="111d" class="ig ih hi bd ii ij lm ln lo lp lq ip dx translated">“不应该强迫任何客户依赖它不使用的方法”。</p></blockquote><p id="0386" class="pw-post-body-paragraph km kn hi ko b kp ms kr ks kt mt kv kw jb mu ky kz jf mv lb lc jj mw le lf ip hb bi translated">罗伯特·C·马丁在为施乐公司做咨询时介绍了<strong class="ko hj"> <em class="ll">界面分离原理</em> </strong>。这个原则建议使用更小的接口，称为“<em class="ll">角色接口</em> s”。ISP 将较大的接口分成较小的角色接口。所以客户将依赖于与他们相关的方法。</p><blockquote class="nk nl nm"><p id="0933" class="km kn ll ko b kp lg kr ks kt lh kv kw nn li ky kz no lj lb lc np lk le lf ip hb bi translated"><a class="ae nh" href="https://www.linkedin.com/pulse/solid-design-principles-python-examples-hiral-amodia/" rel="noopener ugc nofollow" target="_blank"> <strong class="ko hj">注</strong> </a>:这个例子来源于<a class="ae nh" href="https://www.linkedin.com/pulse/solid-design-principles-python-examples-hiral-amodia/" rel="noopener ugc nofollow" target="_blank">Hiral Amodia 发布的这个</a>博客</p></blockquote><p id="9fb6" class="pw-post-body-paragraph km kn hi ko b kp lg kr ks kt lh kv kw jb li ky kz jf lj lb lc jj lk le lf ip hb bi translated">假设我们正在为不同的通信设备设计一个应用程序。通信设备最常见特征是:a)打电话，b)。发送短信和 c)。浏览互联网。因此，让我们创建一个名为<code class="du mx my mz na b">CommunicationDevice</code>的接口，并为每个特性添加各自的<code class="du mx my mz na b">abstract</code>方法，这样任何实现类都需要实现这些方法。</p><p id="9434" class="pw-post-body-paragraph km kn hi ko b kp lg kr ks kt lh kv kw jb li ky kz jf lj lb lc jj lk le lf ip hb bi translated">到目前为止一切顺利。但是现在假设我们想要实现一个传统的固定电话，它也是一个<code class="du mx my mz na b">communication</code>设备，所以我们使用相同的<code class="du mx my mz na b">CommunicationDevice</code>接口创建了一个新的类<code class="du mx my mz na b">LandlinePhone</code>。这正是我们面临的问题，因为我们创建了一个大的<code class="du mx my mz na b">CommunicationDevice</code>接口。在类<code class="du mx my mz na b">LandlinePhone</code>中，我们实现了<code class="du mx my mz na b">make_calls() </code>方法，但是由于我们也继承了抽象方法<code class="du mx my mz na b">send_sms()</code>和<code class="du mx my mz na b">browse_internet() </code>，我们必须在<code class="du mx my mz na b">LandlinePhone</code>类中提供这两个抽象方法的实现，即使<br/>不适用于这个类<code class="du mx my mz na b">LandlinePhone</code>。我们可以在实现中抛出一个异常或者只写 pass，但是我们仍然需要提供一个实现。</p><figure class="nb nc nd ne fd lw"><div class="bz dy l di"><div class="nf ng l"/></div></figure><p id="51fd" class="pw-post-body-paragraph km kn hi ko b kp lg kr ks kt lh kv kw jb li ky kz jf lj lb lc jj lk le lf ip hb bi translated">让我们通过隔离接口来解决冲突。我们将为每个方法创建较小的角色接口，而不是创建一个大的接口。各个类将只使用相关的接口。</p><figure class="nb nc nd ne fd lw"><div class="bz dy l di"><div class="nf ng l"/></div></figure></div><div class="ab cl jo jp gp jq" role="separator"><span class="jr bw bk js jt ju"/><span class="jr bw bk js jt ju"/><span class="jr bw bk js jt"/></div><div class="hb hc hd he hf"><h1 id="fbc8" class="jv ir hi bd is jw jx jy iw jz ka kb ja kc kd ke je kf kg kh ji ki kj kk jm kl bi translated">从属倒置原则</h1><p id="614f" class="pw-post-body-paragraph km kn hi ko b kp kq kr ks kt ku kv kw jb kx ky kz jf la lb lc jj ld le lf ip hb bi translated"><strong class="ko hj">依赖倒置原则</strong>是<a class="ae nh" href="https://en.wikipedia.org/wiki/Coupling_(computer_programming)" rel="noopener ugc nofollow" target="_blank">松耦合</a>软件<a class="ae nh" href="https://en.wikipedia.org/wiki/Modular_programming" rel="noopener ugc nofollow" target="_blank">模块</a>的一种具体形式。该原则指出:</p><ol class=""><li id="59cb" class="me mf hi ko b kp lg kt lh jb mg jf mh jj mi ip nj mk ml mm bi translated">高层模块不应该依赖低层模块。两者都应该依赖于抽象(例如接口)。</li><li id="9c33" class="me mf hi ko b kp mn kt mo jb mp jf mq jj mr ip nj mk ml mm bi translated">抽象不应该依赖于细节。细节(具体的实现)应该依赖于抽象。</li></ol><p id="b21e" class="pw-post-body-paragraph km kn hi ko b kp lg kr ks kt lh kv kw jb li ky kz jf lj lb lc jj lk le lf ip hb bi translated">当我们的应用程序主要由模块组成时，我们需要遵循依赖注入。我们所有的模块应该是松散耦合和独立的。</p><figure class="nb nc nd ne fd lw er es paragraph-image"><div class="er es nv"><img src="../Images/42b43c0d57aa0fda2b23b7a7a335aed0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1042/format:webp/0*wJYVeFP9_DJOJn8c.png"/></div><figcaption class="ma mb et er es mc md bd b be z dx translated">传统图层模式(来源维基百科)</figcaption></figure><figure class="nb nc nd ne fd lw er es paragraph-image"><div class="er es nw"><img src="../Images/96d6a077633f1e93dbd2f23a9bbb5a77.png" data-original-src="https://miro.medium.com/v2/resize:fit:1020/format:webp/0*kMqH96Dg0I92ra9M.png"/></div><figcaption class="ma mb et er es mc md bd b be z dx translated">依赖倒置模式(来源维基百科)</figcaption></figure><p id="d32d" class="pw-post-body-paragraph km kn hi ko b kp lg kr ks kt lh kv kw jb li ky kz jf lj lb lc jj lk le lf ip hb bi translated">有趣的是，如果我们的代码遵循开闭原则和 Liskov 替换原则，它也符合依赖反转原则。因为</p><ol class=""><li id="8e65" class="me mf hi ko b kp lg kt lh jb mg jf mh jj mi ip nj mk ml mm bi translated">遵循开放-封闭原则，我们创建了接口来提供不同的高级实现</li><li id="924c" class="me mf hi ko b kp mn kt mo jb mp jf mq jj mr ip nj mk ml mm bi translated">Liskov 替换确保我们可以用高级类对象替换低级类对象，而不会对应用程序造成任何负面影响。</li></ol><p id="ea34" class="pw-post-body-paragraph km kn hi ko b kp lg kr ks kt lh kv kw jb li ky kz jf lj lb lc jj lk le lf ip hb bi translated">让我们假设我们有一个班级玩家和一个班级俱乐部会员，它拥有不同学生在不同俱乐部的会员资格。现在，我们定义了一个高级类 MembershipReportOfBarcelona，它将包含巴塞罗那俱乐部的所有球员及其净资产。</p><figure class="nb nc nd ne fd lw"><div class="bz dy l di"><div class="nf ng l"/></div></figure><p id="bf15" class="pw-post-body-paragraph km kn hi ko b kp lg kr ks kt lh kv kw jb li ky kz jf lj lb lc jj lk le lf ip hb bi translated">如你所见，我们直接从高级类<code class="du mx my mz na b">MembershipReportOfBarcelona</code>访问<code class="du mx my mz na b">ClubMembership</code>类的成员。通过这样做，我们违反了依赖倒置的原则。</p><p id="685d" class="pw-post-body-paragraph km kn hi ko b kp lg kr ks kt lh kv kw jb li ky kz jf lj lb lc jj lk le lf ip hb bi translated">怎么会？假设我们将来需要将<code class="du mx my mz na b">members</code>的实现从<code class="du mx my mz na b">list</code>修改为<code class="du mx my mz na b">dict</code>或<code class="du mx my mz na b">tuple</code>或任何其他数据类型。在这种情况下，我们的高级类<code class="du mx my mz na b">MembershipReportOfBarcelona</code>将会中断，因为它依赖于低级类<code class="du mx my mz na b">ClubMembership</code>的<br/>实现。这太荒谬了！</p><p id="4ca3" class="pw-post-body-paragraph km kn hi ko b kp lg kr ks kt lh kv kw jb li ky kz jf lj lb lc jj lk le lf ip hb bi translated">让我们尽快解决这个根本性的问题:</p><figure class="nb nc nd ne fd lw"><div class="bz dy l di"><div class="nf ng l"/></div></figure><p id="6faa" class="pw-post-body-paragraph km kn hi ko b kp lg kr ks kt lh kv kw jb li ky kz jf lj lb lc jj lk le lf ip hb bi translated">坚持<em class="ll">依赖倒置原则</em>的首要任务是确保我们的任何高级类都不依赖于任何低级类的实现。</p><p id="4ab0" class="pw-post-body-paragraph km kn hi ko b kp lg kr ks kt lh kv kw jb li ky kz jf lj lb lc jj lk le lf ip hb bi translated">因此，像<em class="ll">开闭</em>原理一样，我们用一个抽象方法<code class="du mx my mz na b">find_players_of_club</code>创建了一个新的接口<code class="du mx my mz na b">FindClubMembership</code>，它将查找<strong class="ko hj">一个俱乐部的所有球员。任何继承这个<code class="du mx my mz na b">FindClubMembership</code>类的<code class="du mx my mz na b">class</code>都必须自己实现这个抽象的<code class="du mx my mz na b">method</code>。</strong></p><p id="f65e" class="pw-post-body-paragraph km kn hi ko b kp lg kr ks kt lh kv kw jb li ky kz jf lj lb lc jj lk le lf ip hb bi translated">在我们的例子中，我们的<code class="du mx my mz na b">ClubMembership</code>类扩展了接口，所以我们在这里实现了查找部分，方法将<code class="du mx my mz na b">yield</code>得到结果。在我们的<code class="du mx my mz na b">MembershipReportOfBarcelona</code>类中完成的流程现在由<code class="du mx my mz na b">ClubMembership</code>类的<br/>负责。我们通过接口<code class="du mx my mz na b">FindClubMembership</code>做到了。通过这样做，我们已经从低级类<code class="du mx my mz na b">ClubMembership</code>中消除了高级类<code class="du mx my mz na b">MembershipReportOfBarcelona</code>的依赖性，并且<br/>将依赖性转移到了我们的接口<code class="du mx my mz na b">FindClubMembership</code>。因此，低级类实现的任何变化都不会再影响我们的高级类。</p></div><div class="ab cl jo jp gp jq" role="separator"><span class="jr bw bk js jt ju"/><span class="jr bw bk js jt ju"/><span class="jr bw bk js jt"/></div><div class="hb hc hd he hf"><p id="b369" class="pw-post-body-paragraph km kn hi ko b kp lg kr ks kt lh kv kw jb li ky kz jf lj lb lc jj lk le lf ip hb bi translated">开始编写<strong class="ko hj">扎实的</strong>代码。你的队友会一直感激你。</p><p id="f299" class="pw-post-body-paragraph km kn hi ko b kp lg kr ks kt lh kv kw jb li ky kz jf lj lb lc jj lk le lf ip hb bi translated"><strong class="ko hj">参考文献:</strong></p><ol class=""><li id="bd0e" class="me mf hi ko b kp lg kt lh jb mg jf mh jj mi ip nj mk ml mm bi translated"><a class="ae nh" href="https://en.wikipedia.org/wiki/SOLID" rel="noopener ugc nofollow" target="_blank">https://en.wikipedia.org/wiki/SOLID</a></li><li id="94b9" class="me mf hi ko b kp mn kt mo jb mp jf mq jj mr ip nj mk ml mm bi translated"><a class="ae nh" href="https://www.linkedin.com/pulse/solid-design-principles-python-examples-hiral-amodia/" rel="noopener ugc nofollow" target="_blank">https://www . LinkedIn . com/pulse/solid-design-principles-python-examples-hiral-amodia/</a></li><li id="4675" class="me mf hi ko b kp mn kt mo jb mp jf mq jj mr ip nj mk ml mm bi translated"><a class="ae nh" href="https://towardsdatascience.com/5-principles-to-write-solid-code-examples-in-python-9062272e6bdc" rel="noopener" target="_blank">https://towards data science . com/5-principles-to-write-solid-code-examples-in-python-9062272 e6bdc</a></li></ol></div></div>    
</body>
</html>