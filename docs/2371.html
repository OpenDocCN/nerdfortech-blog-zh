<html>
<head>
<title>Re-visit JavaScript Iterations (using Iterators and Generators)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">重新访问JavaScript迭代(使用迭代器和生成器)</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/re-visit-javascript-iterations-using-iterators-and-generators-1cbcfd042d82?source=collection_archive---------10-----------------------#2021-05-03">https://medium.com/nerd-for-tech/re-visit-javascript-iterations-using-iterators-and-generators-1cbcfd042d82?source=collection_archive---------10-----------------------#2021-05-03</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><h1 id="609d" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">介绍</h1><p id="fccd" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">来到<strong class="jf hj">优步</strong>后，我最近对JavaScript 很感兴趣。当我还在学习的时候，我想和你分享一些关于循环和迭代的有趣的东西。</p><p id="f736" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated"><strong class="jf hj">迭代</strong>是任何算法设计的<strong class="jf hj">基础部分。现在有很多方法可以学习循环和条件(或类似的基础)，但是在这里，我想<strong class="jf hj">采取一种特殊的方式思考</strong>关于<strong class="jf hj">迭代</strong>和<strong class="jf hj">在各种各样的日常用例</strong>中推广</strong>相同的想法<strong class="jf hj">。因此，没有进一步的到期让我们开始。</strong></p><p id="420c" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">如果你简单地<code class="du kg kh ki kj b"><strong class="jf hj">console.log()</strong> </code>这个<code class="du kg kh ki kj b"><strong class="jf hj">Array.prototype</strong></code>，展开它，再往下一点，你会发现一个<strong class="jf hj">符号迭代器</strong>函数。就像这样，这里的符号只不过是获取函数引用的一个键。</p><figure class="km kn ko kp fd kq er es paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="er es kl"><img src="../Images/1a34f46c50039370a91dcdae1aa1fe8d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AW8mgOe2zxLh2a98QtLB4A.png"/></div></div><figcaption class="kx ky et er es kz la bd b be z dx translated">数组.原型</figcaption></figure><p id="1186" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">现在，有了这个属性，我们可以得到一个迭代器，它可以遍历数组。</p><figure class="km kn ko kp fd kq er es paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="er es lb"><img src="../Images/ef5086188d2ffffc21262d2644f7a3fd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zRvfuRYAZw0kxZy1GdWwVQ.png"/></div></div><figcaption class="kx ky et er es kz la bd b be z dx translated">数组迭代器</figcaption></figure><p id="a12e" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated"><strong class="jf hj">注意</strong> : <em class="lc">迭代器函数在调用时应该绑定到上下文中的数组，否则将无法创建迭代器。例如，在上面的例子中，如果我们只是获取对</em> <code class="du kg kh ki kj b"><strong class="jf hj"><em class="lc">funActs[Symbol.iterator]</em></strong></code> <em class="lc">的引用并在稍后调用它来获取引用，而不是获取</em> <code class="du kg kh ki kj b"><strong class="jf hj"><em class="lc">funItr</em></strong></code> <em class="lc">。不会像预期的那样起作用。在这种情况下，我们可以做我们想做的，把函数表达成这样</em> <code class="du kg kh ki kj b"><strong class="jf hj"><em class="lc">const createIterator = funActs[Symbol.iterator].bind(funActs)</em></strong></code></p><h1 id="dc82" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">默认数组迭代器</h1><p id="770d" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">根据定义，<strong class="jf hj">迭代器</strong>有一个特殊的<code class="du kg kh ki kj b"><strong class="jf hj">.next()</strong> </code>函数与之相关联。当调用 <strong class="jf hj">时，哪个<strong class="jf hj">从</strong>集合</strong>(数组)中返回 <strong class="jf hj">一个值</strong> <strong class="jf hj">。每次调用<code class="du kg kh ki kj b"><strong class="jf hj">.next()</strong> </code>时，它从数组中一次返回一个连续的项目，直到数组结束。类似这样的事情，</strong></p><figure class="km kn ko kp fd kq er es paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="er es ld"><img src="../Images/a2ccc526be739d136f7488baabb42809.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TRMym5O-_O9ggbbbV5nqhg.png"/></div></div><figcaption class="kx ky et er es kz la bd b be z dx translated">使用。默认迭代器上的next()</figcaption></figure><p id="5bb4" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">请注意，<code class="du kg kh ki kj b"><strong class="jf hj">.next()</strong></code>的返回值产生一个<strong class="jf hj">结果</strong>(对象)，它有两个键<strong class="jf hj"/>。首先是名为<code class="du kg kh ki kj b"><strong class="jf hj">value</strong></code>的键，它可以存在也可以不存在，这取决于集合中是否有更多的项目需要循环。其次，它有一个强制的<code class="du kg kh ki kj b"><strong class="jf hj">done</strong></code>布尔变量，指示<strong class="jf hj">集合中是否有更多的值</strong>，<strong class="jf hj">或者我们已经完成了对集合的迭代</strong>。</p><figure class="km kn ko kp fd kq er es paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="er es le"><img src="../Images/8169a534c528b2a174214f38de611048.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IvhXK_PKi5Qve0PEFdB5UA.png"/></div></div></figure><h1 id="9537" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">可迭代接口</h1><p id="d8e7" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">我们可以用下面的<strong class="jf hj">可迭代</strong>(数组是一个<strong class="jf hj">可迭代</strong>元素)的接口来总结我们到目前为止学到的东西。基本上，它需要一个<strong class="jf hj">符号.迭代器</strong>函数，返回一个迭代器，这个迭代器基本上就是一个附加了<code class="du kg kh ki kj b"><strong class="jf hj">.next() </strong></code>函数的<code class="du kg kh ki kj b"><strong class="jf hj">Object</strong></code>。调用下一个函数时，返回此格式的结果<code class="du kg kh ki kj b"><strong class="jf hj">{value: any, done: boolean}</strong></code> <strong class="jf hj">。</strong></p><figure class="km kn ko kp fd kq er es paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="er es lf"><img src="../Images/93375c900d0c015930f7281b68444c59.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LOh8ftGtQcGAemkpJE2HXg.png"/></div></div><figcaption class="kx ky et er es kz la bd b be z dx translated">可迭代接口</figcaption></figure><p id="8f77" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">在JavaScript中，我们有一个特殊的<strong class="jf hj">迭代语法，叫做</strong> <code class="du kg kh ki kj b"><strong class="jf hj">for..of</strong></code>，这个<strong class="jf hj">遵守这个可迭代契约</strong>的 <strong class="jf hj">。这使得使用<code class="du kg kh ki kj b"><strong class="jf hj">for..of</strong></code>循环遍历对象变得轻而易举。看一看，</strong></p><figure class="km kn ko kp fd kq er es paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="er es lg"><img src="../Images/8854c39742b608a32c1e03ce158cd3c5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6dPiBFgUA-pOYy8ZFoJ7ag.png"/></div></div><figcaption class="kx ky et er es kz la bd b be z dx translated">为..具有数组迭代器的循环的</figcaption></figure><h1 id="3b37" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">创建自定义数组迭代器</h1><p id="0bb6" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">我们已经经历了学习围绕<strong class="jf hj"> iterables </strong>的所有细节的艰苦工作，因为现在我们可以开始<strong class="jf hj"> <em class="lc">使用它，并修改它</em> </strong>来创建我们自己的定制迭代器。</p><p id="347b" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">所以，假设有人要求你以相反的方式迭代<strong class="jf hj">数组</strong>。不讨论基于循环的索引肯定可以实现这一点，让我们看看如何通过创建我们自己的第一个自定义迭代器来实现这一点。首先，让我们从<code class="du kg kh ki kj b"><strong class="jf hj">.next()</strong></code>函数开始，当我们试图得到迭代器时，</p><figure class="km kn ko kp fd kq er es paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="er es lh"><img src="../Images/d73f81fd2db5d1eb1b80578ddd3002bd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mfGL1ddc_6j69PVSC76nPg.png"/></div></div><figcaption class="kx ky et er es kz la bd b be z dx translated">创建反向查找</figcaption></figure><p id="fbe3" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">为了让它与<code class="du kg kh ki kj b"><strong class="jf hj">for..of</strong></code>循环一起工作，我们将用一个<strong class="jf hj">符号.迭代器</strong>函数来修饰它，使它看起来像一个数组<strong class="jf hj">可迭代</strong>，然后我们可以像往常一样使用<code class="du kg kh ki kj b"><strong class="jf hj">for..of</strong></code>循环，它会以相反的顺序打印值。</p><figure class="km kn ko kp fd kq er es paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="er es li"><img src="../Images/6a8455b2d96c1ecca7b46bdbcb9d3790.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Y1wkjWh58P6ofJthPVhHQw.png"/></div></div><figcaption class="kx ky et er es kz la bd b be z dx translated">完全反向查找</figcaption></figure><h1 id="e09e" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">迭代生成器</h1><p id="aa61" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">虽然自定义迭代器是一个有用的工具，但是由于需要显式维护它们的内部状态，因此创建它们需要仔细编程。<strong class="jf hj">生成器函数</strong>提供了一个强大的选择:它们允许你通过编写一个不连续执行的函数来定义一个迭代算法。生成器函数是使用<code class="du kg kh ki kj b"><a class="ae kk" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/function*" rel="noopener ugc nofollow" target="_blank">function*</a></code>语法编写的(这允许我们使用神奇的<strong class="jf hj"> yield </strong>关键字来暂停执行)</p><figure class="km kn ko kp fd kq er es paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="er es lj"><img src="../Images/8ed7415ac38f86990c18a20b29482d50.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cEPkfYwEaDk_plc6Rm6hsw.png"/></div></div><figcaption class="kx ky et er es kz la bd b be z dx translated">函数生成器</figcaption></figure><blockquote class="lk ll lm"><p id="2528" class="jd je lc jf b jg kb ji jj jk kc jm jn ln kd jq jr lo ke ju jv lp kf jy jz ka hb bi translated">生成器允许我们用更简洁的语法编写迭代器，并在每次迭代中给我们更多的灵活性。</p></blockquote><p id="9760" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">让我们使用生成器来重构它。我们将从上面取出所有的片段，并在我们的<strong class="jf hj"> reverseGen </strong>中使用它们，这次是生成器函数，</p><figure class="km kn ko kp fd kq er es paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="er es lq"><img src="../Images/ad3023a8bc164f2138e179cc50b06a50.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fVI0fWmlktIqFCuFcq4Uog.png"/></div></div></figure><h1 id="defc" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">控制迭代</h1><p id="be41" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">请注意，在讨论<strong class="jf hj"> Iterables </strong>特别是关于生成器的时候，我们只关注了<code class="du kg kh ki kj b"><strong class="jf hj">.next()</strong></code>函数，因为它是最常用的。但是还有其他方法可以让你控制迭代器的行为。例如，如果我们在迭代器中随时使用<code class="du kg kh ki kj b"><strong class="jf hj">.return()</strong></code>方法，迭代器将立即完成，任何对<code class="du kg kh ki kj b"><strong class="jf hj">.next()</strong></code>的调用都将被忽略。看一看，</p><figure class="km kn ko kp fd kq er es paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="er es lr"><img src="../Images/6476d8090378b8c07462ad738f9f83ad.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BGovtnXktvoACLGZGJy_Dw.png"/></div></div><figcaption class="kx ky et er es kz la bd b be z dx translated">迭代器。return()效果</figcaption></figure><p id="e2e3" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">我们可以<strong class="jf hj"> <em class="lc">也可以定制生成器</em> </strong>内部的逻辑，然而我们希望哪个能够<strong class="jf hj">自动影响</strong>如何使<strong class="jf hj">迭代</strong>整体运行。比如这里<em class="lc">说当数组的长度剩下的是1的时候，我们就不想再循环了。</em>所以，在我们的例子中，当<strong class="jf hj"> <em class="lc">长度为1</em></strong>时，我们<strong class="jf hj">简单地从生成器</strong>返回。这不会循环遍历最后一项并跳过它。看一看，</p><figure class="km kn ko kp fd kq er es paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="er es ls"><img src="../Images/8297b250095fc413c294b855bed0ad00.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*p2uGxXjxIhk5aPeFr9-2vQ.png"/></div></div><figcaption class="kx ky et er es kz la bd b be z dx translated">带返回的短路迭代逻辑</figcaption></figure><h1 id="1294" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">嵌套迭代产生(yield*)</h1><p id="4e99" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">函数生成器<strong class="jf hj">的一个巨大好处是能够迭代其他嵌套生成器</strong>。如果我们正在生成的<strong class="jf hj">值</strong> <strong class="jf hj">本身是另一个生成器</strong>，那么我们可以<strong class="jf hj">使用特殊的语法yield* </strong>，这将<strong class="jf hj">确保遍历yield中嵌套生成器的所有值</strong>，然后继续执行其他yield。让我们举一个简单的例子，来阐明我的意思，</p><figure class="km kn ko kp fd kq er es paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="er es lt"><img src="../Images/6af1c34843ac38cf07daa43eca61497c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*URPVTZ-BNsqjeex-fkgVIg.png"/></div></div></figure><p id="05bc" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">在这个例子中，你可以清楚地看到，我们的<strong class="jf hj"> someOtherGen() </strong>是一个独立的生成器，它<strong class="jf hj">生成“Hello”作为第一个值</strong>。然后，由于<strong class="jf hj">需要从reverseGen() </strong>中一次获取一个值，因此<strong class="jf hj">我们使用了</strong>语法<strong class="jf hj"> yield* </strong>，最后，在其完成后，外部生成器照常继续，并产生独立于<strong class="jf hj"> reverseGen </strong>()的最后一个值作为“<strong class="jf hj"> World </strong>”。因此，您可以看到在生成器中使用生成器来处理复杂执行场景的好处。</p><h1 id="5e1c" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">用于生成数据的生成器</h1><p id="c917" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">我们可以巧妙地利用生成器的工作方式，非常容易地生成自定义数据。让我们以一个<strong class="jf hj">范围操作符</strong>为例，它采用类似<code class="du kg kh ki kj b"><strong class="jf hj">range(start, end, inc)</strong></code>的格式，从开始到结束产生所有值，并带有一个增量(inc)。它在JS语言中并不存在，但是让我们看看如何在生成器的帮助下，在JS中轻松添加类似于<strong class="jf hj"> range() </strong>的功能。</p><figure class="km kn ko kp fd kq er es paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="er es lu"><img src="../Images/d8040789315e4d15e651e0dfc1567ab1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3uC9bFpF-lYQTvF0GEw2WQ.png"/></div></div><figcaption class="kx ky et er es kz la bd b be z dx translated">JS中的range()运算符</figcaption></figure><p id="e2a2" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">当你想用一些数据(基于自定义逻辑)生成一个预填充的数组时，这个<strong class="jf hj">也非常方便，就像这样，</strong></p><figure class="km kn ko kp fd kq er es paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="er es lv"><img src="../Images/2d542c3242574ed555165d7fa2dda4f4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6hp_6PaSKRQmdUgcIDxljg.png"/></div></div><figcaption class="kx ky et er es kz la bd b be z dx translated">用生成器生成预填充数组</figcaption></figure><h1 id="0cdb" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">用于管理状态的生成器</h1><p id="7cb9" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">在本帖中，我们将探讨的关于生成器的最后一个方面，<strong class="jf hj">是它们保存和管理应用程序/变量的内部状态的能力</strong>。因为我们<strong class="jf hj">可以在我们的生成器</strong>函数中捕获状态，并且还可以在需要时暂停和执行，所以我们可以在没有任何外部库或代码的情况下做类似<strong class="jf hj">创建状态机</strong>的事情。</p><p id="dca4" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">这里有一个简单的例子，基于增量/减量计数器的状态机使用生成器实现<strong class="jf hj">，</strong></p><figure class="km kn ko kp fd kq er es paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="er es lw"><img src="../Images/c9397721da3b7a75e01a5ab245fad4ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5zO-UppraVsrgMOKVPzliA.png"/></div></div><figcaption class="kx ky et er es kz la bd b be z dx translated">带生成器的状态机</figcaption></figure><h1 id="c264" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">结论</h1><p id="6ceb" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">如果到目前为止你和我在一起，我们涵盖了一些好的东西，我们从一个简单的<strong class="jf hj">可迭代</strong>接口和适用于许多可迭代数据结构的<strong class="jf hj">契约开始。</strong>然后<strong class="jf hj">看了自定义迭代器</strong>以及<strong class="jf hj">如何创建你想要的任何类型的循环</strong>。然后我们看了看<strong class="jf hj">生成器，它给了你一个自然的可迭代接口</strong>，这个接口<strong class="jf hj">产生所有的值。在它上面调用next()</strong>。我们使用函数生成器重新实现了我们的<strong class="jf hj">自定义迭代器。最后，我们看了使用生成器、嵌套循环、数据生成和状态机类应用程序的好处，我们可以很容易地实现它们。</strong></p><p id="6e5d" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated"><strong class="jf hj"> <em class="lc">额外收获:</em> </strong>我相信拥有这些基础知识对于处理手头的各种任务非常有用。有时，你可以发挥创造力，开发一些独特而有用的模式。所以，作为总结，我留给你最后一个创造性地使用生成器的例子，使用类似于<strong class="jf hj">的方法来处理集合。map()，。过滤器()</strong></p><figure class="km kn ko kp fd kq er es paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="er es lx"><img src="../Images/d5d17a8a915d7572dfb8caa561ac1e18.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*W4ODQZ122KGL6bAOEWtTtQ.png"/></div></div><figcaption class="kx ky et er es kz la bd b be z dx translated">使用生成器处理集合</figcaption></figure></div></div>    
</body>
</html>