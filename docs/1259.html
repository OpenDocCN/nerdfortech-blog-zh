<html>
<head>
<title>Recursion, Fibonacci, and Speed with Ruby</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">递归、斐波那契和Ruby速度</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/recursion-fibonacci-and-speed-with-ruby-1a2491cb8e8e?source=collection_archive---------14-----------------------#2021-03-11">https://medium.com/nerd-for-tech/recursion-fibonacci-and-speed-with-ruby-1a2491cb8e8e?source=collection_archive---------14-----------------------#2021-03-11</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="c9c9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">斐波纳契数列是一个数字序列，序列中的下一个数字是前两个数字的和。典型的例子是这样的:</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es jd"><img src="../Images/8fcf9d736b26ce6f69a8edd6a152df77.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MfNncOticBx-ctXBHoTI7Q.png"/></div></div><figcaption class="jp jq et er es jr js bd b be z dx translated">斐波那契数列</figcaption></figure><p id="6100" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在这篇博客中，我将尝试递归的基本原理。我将在Ruby中实现两种不同的解决方案来查找指定的Fibonacci序列的元素。第一种解决方案是更标准的编码实践，而第二种使用更优雅的递归解决方案来完成这项工作。</p><p id="0a27" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">第一个解决方案接受一个数字n，并创建一个斐波那契数列，从开始一直到我们要寻找的元素:</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es jt"><img src="../Images/90761821812b7c87709d598c215680c8.png" data-original-src="https://miro.medium.com/v2/resize:fit:324/format:webp/1*TRo645aUPZBfziL8wrVwzw.png"/></div></figure><p id="e661" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这种方法简单快捷。它以两个变量为1开始，然后将它们相加得到第三个变量，然后将第三个变量移入第二个变量，第二个变量移入第一个变量。它一遍又一遍地这样做，直到我们提取出我们正在寻找的价值。</p><p id="4a66" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">第二种解决方案使用递归来实现相同的结果:</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es ju"><img src="../Images/48482f9768461d8beff2e7301abb31f9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1124/format:webp/1*8xGQt1FU32oaRhuJxDc88g.png"/></div></figure><p id="367b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这个方法比第一个方法代码少得多，而且看起来更优雅。将一个数字n传递给该方法，并检查它是否大于2。如果它不大于2，它将遇到返回值为1的方法的所谓“基本情况”。如果它大于2，它用小于n的1来调用自己，并将该值加到用小于n的2来调用的自己上。该递归循环一直运行，直到n达到基本情况，并最终返回值。</p><p id="606f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为了有助于可视化这种方法中发生的情况，请参见下面的专业图表:</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es jv"><img src="../Images/22f2a9181fb4ce3d38d46f1a9968ec9c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cD0W3Ix2udWK4ABQlxJhnQ.jpeg"/></div></div><figcaption class="jp jq et er es jr js bd b be z dx translated">图解递归</figcaption></figure><p id="9749" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为了找出哪种方法更快，我对结果进行了基准测试:</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es jw"><img src="../Images/166a70b19f9350f4ac452e97be64df1d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1120/format:webp/1*LoUDFe9mX9Y3VsZTng-P8w.png"/></div><figcaption class="jp jq et er es jr js bd b be z dx translated">标杆管理</figcaption></figure><p id="e7bc" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">哪种方法其实更快？这里:</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es jx"><img src="../Images/cb5161840114720433289037ea79a1a7.png" data-original-src="https://miro.medium.com/v2/resize:fit:812/format:webp/1*xGuaI2TfrL8EbnflXorWqw.png"/></div><figcaption class="jp jq et er es jr js bd b be z dx translated">结果</figcaption></figure><p id="b09c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">非递归解决方案要快得多。递归似乎在函数中发挥了神奇的作用，但是在这种情况下，它并不是解决问题的最佳方法。递归是一个令人头脑麻木的话题，勾勒出正在发生的事情对你理解它有很大的帮助。</p></div></div>    
</body>
</html>