<html>
<head>
<title>JVM Architecture</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JVM 架构</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/jvm-architecture-8898cc86ad83?source=collection_archive---------8-----------------------#2021-05-06">https://medium.com/nerd-for-tech/jvm-architecture-8898cc86ad83?source=collection_archive---------8-----------------------#2021-05-06</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="ad03" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在我们学习一项新技术之前，我们必须首先了解和理解它的基本原理。每个 Java 开发人员都必须理解一些基础知识，比如 Java 如何工作和 JVM 体系结构，以便在实际场景中有效地创建 Java 程序并对其进行故障排除。本文将为您提供理解 JVM 架构所需的知识，希望对您有用。</p></div><div class="ab cl jd je gp jf" role="separator"><span class="jg bw bk jh ji jj"/><span class="jg bw bk jh ji jj"/><span class="jg bw bk jh ji"/></div><div class="hb hc hd he hf"><h1 id="55e0" class="jk jl hi bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated"><strong class="ak"> JAVA 环境</strong></h1><figure class="kj kk kl km fd kn er es paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="er es ki"><img src="../Images/a9d06ddbd1a710f8dab84f469f9ead55.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*El3x_ERtCSTsU7mfzlTR8Q.png"/></div></div><figcaption class="ku kv et er es kw kx bd b be z dx translated">JDK 建筑</figcaption></figure><p id="8b22" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在深入 JVM 体系结构之前，让我们先看一下 Java 环境的概述，比如 JVM 附带的 JDK 和 JRE。</p><h2 id="c28c" class="ky jl hi bd jm kz la lb jq lc ld le ju iq lf lg jy iu lh li kc iy lj lk kg ll bi translated">JDK</h2><ul class=""><li id="995c" class="lm ln hi ih b ii lo im lp iq lq iu lr iy ls jc lt lu lv lw bi translated">作为 Java 开发人员，我们必须在我们的生产环境中安装和配置<strong class="ih hj"> JDK (Java 开发工具包)</strong>，以便构建和运行 Java 程序。JDK 是完整的开发环境。它包括 JRE 和开发工具，如编译器(javac)、归档器(jar)、文档生成器(Javadoc)等。</li></ul><h2 id="6b9d" class="ky jl hi bd jm kz la lb jq lc ld le ju iq lf lg jy iu lh li kc iy lj lk kg ll bi translated">Java 运行时环境</h2><ul class=""><li id="6e6f" class="lm ln hi ih b ii lo im lp iq lq iu lr iy ls jc lt lu lv lw bi translated"><strong class="ih hj"> JRE </strong>是<strong class="ih hj">“Java 运行时环境”的缩写。JRE 提供了运行 Java 程序的最低要求。没有 JRE，任何 java 应用程序都无法运行。JRE 包含 Java 虚拟机(JVM)、核心类和支持文件。</strong></li><li id="eb42" class="lm ln hi ih b ii lx im ly iq lz iu ma iy mb jc lt lu lv lw bi translated">通常 JRE 和 JDK 是捆绑在一起的。但是如果我们的目的只是执行一个 java 应用程序，那么我们可以在没有 JDK 的情况下安装 JRE。</li></ul><blockquote class="mc md me"><p id="db5d" class="if ig mf ih b ii ij ik il im in io ip mg ir is it mh iv iw ix mi iz ja jb jc hb bi translated">注意:- JDK 是给开发者的，JRE 是给用户的。</p></blockquote></div><div class="ab cl jd je gp jf" role="separator"><span class="jg bw bk jh ji jj"/><span class="jg bw bk jh ji jj"/><span class="jg bw bk jh ji"/></div><div class="hb hc hd he hf"><h1 id="0089" class="jk jl hi bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">JVM 是什么？</h1><p id="2929" class="pw-post-body-paragraph if ig hi ih b ii lo ik il im lp io ip iq mj is it iu mk iw ix iy ml ja jb jc hb bi translated"><strong class="ih hj"> JVM </strong>代表<strong class="ih hj">“Java 虚拟机”</strong>。<strong class="ih hj"/>JVM 的职责是将 java 字节码作为输入，并将其转换为底层操作系统(OS)可以理解的机器码。</p><p id="e647" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"><em class="mf">JVM 真的存在吗？</em> </strong>答案是<strong class="ih hj"> <em class="mf">不是</em> </strong>，顾名思义是虚拟机。我们不能安装或卸载 JVM，因为 JVM 完全是一个规范。当我们下载 JRE 时，JVM 与 JRE 一起提供。当我们安装 JRE 时，它会部署所需的代码来创建一个 JVM 实例。</p><blockquote class="mc md me"><p id="86dc" class="if ig mf ih b ii ij ik il im in io ip mg ir is it mh iv iw ix mi iz ja jb jc hb bi translated">注意:- JRE 与平台紧密相关，而 JVM 与平台无关，因为 JVM 是一种规范。例如:如果我们在 windows 平台上安装 JRE 的 windows 版本，JRE 会部署所需的代码，以便在 windows 平台上创建一个 JVM 实例。如果我们在 Linux 平台上安装 Linux 版本的 JRE，JRE 会部署所需的代码，以便在 Linux 平台上创建一个 JVM 实例。</p></blockquote><p id="7291" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">因此，当我们执行一个 java 应用程序时，一个全新的 JVM 实例被创建，当应用程序结束时，JVM 也被销毁。因此 JVM 驻留在 RAM 上。为了更容易理解，假设我们的系统中有三个 Java 应用程序同时运行，那么我们的系统中将有 3 个 JVM 在运行，如果这三个中的一个结束了它的执行，那么我们的系统中将只剩下 2 个 JVM。如果我们的系统上没有运行 java 应用程序，这意味着我们的系统中没有可用的 JVM 实例。</p><p id="5277" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">所以现在你可能想知道<strong class="ih hj"> <em class="mf">当一个 Java 应用程序被执行时，一个 JVM 实例是如何被创建的，当应用程序结束执行时，这个 JVM 实例是如何被销毁的？。</em> </strong>嗯，这是怎么回事。</p><ul class=""><li id="130b" class="lm ln hi ih b ii ij im in iq mm iu mn iy mo jc lt lu lv lw bi translated">当您执行一个 java 类文件(。class)使用 java 关键字，<em class="mf">(例如:Java hello world)</em>Java 关键字将请求您的底层操作系统创建一个 JVM 实例。因此，将创建一个 JVM 实例和一个非守护线程(用户线程)来执行 java 应用程序。</li><li id="3b84" class="lm ln hi ih b ii lx im ly iq lz iu ma iy mb jc lt lu lv lw bi translated">JVM 有一条规则，规定如果发生以下任何事件，JVM 必须被销毁。</li></ul><blockquote class="mp"><p id="302d" class="mq mr hi bd ms mt mu mv mw mx my jc dx translated">1)如果所有非守护进程线程(用户线程)都结束了它的执行(如果没有可用的非守护进程线程)，那么应该销毁 JVM 实例。</p><p id="d4ec" class="mq mr hi bd ms mt mz na nb nc nd jc dx translated">2)如果 java 应用程序使用<em class="ne"> System.exit()方法</em>杀死自己，那么 JVM 实例应该被销毁。</p></blockquote><p id="9273" class="pw-post-body-paragraph if ig hi ih b ii nf ik il im ng io ip iq nh is it iu ni iw ix iy nj ja jb jc hb bi translated">你有没有想过 Java 中的<strong class="ih hj">“编写一次，随处运行”(WORA) </strong>概念是如何工作的？以上是它的理由。编译后的 Java 字节码将由 JVM 执行。因为 JVM 是独立于平台的，所以 java 应用程序也可以在任何能够启动 JVM 实例的平台上运行。</p></div><div class="ab cl jd je gp jf" role="separator"><span class="jg bw bk jh ji jj"/><span class="jg bw bk jh ji jj"/><span class="jg bw bk jh ji"/></div><div class="hb hc hd he hf"><h1 id="5b91" class="jk jl hi bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">JVM 的组件</h1><p id="da39" class="pw-post-body-paragraph if ig hi ih b ii lo ik il im lp io ip iq mj is it iu mk iw ix iy ml ja jb jc hb bi translated">JVM 由三个组件组成，它们是</p><ol class=""><li id="05ab" class="lm ln hi ih b ii ij im in iq mm iu mn iy mo jc nk lu lv lw bi translated">类加载器。</li><li id="6f1a" class="lm ln hi ih b ii lx im ly iq lz iu ma iy mb jc nk lu lv lw bi translated">记忆区。</li><li id="42a9" class="lm ln hi ih b ii lx im ly iq lz iu ma iy mb jc nk lu lv lw bi translated">执行引擎。</li></ol><p id="c255" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们更深入地了解一下每个组件。</p><h1 id="5045" class="jk jl hi bd jm jn nl jp jq jr nm jt ju jv nn jx jy jz no kb kc kd np kf kg kh bi translated">类加载器</h1><p id="7a33" class="pw-post-body-paragraph if ig hi ih b ii lo ik il im lp io ip iq mj is it iu mk iw ix iy ml ja jb jc hb bi translated">类装入器的主要职责有三。</p><ol class=""><li id="53db" class="lm ln hi ih b ii ij im in iq mm iu mn iy mo jc nk lu lv lw bi translated">装货</li><li id="107c" class="lm ln hi ih b ii lx im ly iq lz iu ma iy mb jc nk lu lv lw bi translated">连接</li><li id="d38c" class="lm ln hi ih b ii lx im ly iq lz iu ma iy mb jc nk lu lv lw bi translated">初始化</li></ol><h2 id="0ca5" class="ky jl hi bd jm kz la lb jq lc ld le ju iq lf lg jy iu lh li kc iy lj lk kg ll bi translated">装货</h2><p id="b2df" class="pw-post-body-paragraph if ig hi ih b ii lo ik il im lp io ip iq mj is it iu mk iw ix iy ml ja jb jc hb bi translated">JVM 的 Classloader 子系统负责<strong class="ih hj">加载类文件</strong>(。class)存储在<strong class="ih hj">存储区</strong>中。每当我们运行 java 程序时，类装入器首先装入它。每当 JVM 加载一个类时，它都会在<strong class="ih hj">方法区</strong>中存储以下信息。</p><ul class=""><li id="562f" class="lm ln hi ih b ii ij im in iq mm iu mn iy mo jc lt lu lv lw bi translated">加载的类的完全限定名。</li><li id="8b6e" class="lm ln hi ih b ii lx im ly iq lz iu ma iy mb jc lt lu lv lw bi translated">加载的类的直接父类。(如果没有父类，JVM 会将加载的类作为父类)</li><li id="c7d5" class="lm ln hi ih b ii lx im ly iq lz iu ma iy mb jc lt lu lv lw bi translated">是否该”。“class”文件是一个类、接口或枚举。</li><li id="b2f0" class="lm ln hi ih b ii lx im ly iq lz iu ma iy mb jc lt lu lv lw bi translated">关于修饰符、变量和方法信息的细节，等等。</li></ul><p id="b44b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">当 JVM 第一次加载用户定义的类时，JVM 会生成一个类类型对象，并将用户定义的对象分配给它，并将其存储在堆内存中。这个类类型对象是在<strong class="ih hj"> java.lang 包</strong>中预定义的类的对象。程序员将使用这些类对象来获取类级别的信息，如类名、父名、方法和变量信息等等。在加载过程之后，将进行链接过程。</p><h2 id="453e" class="ky jl hi bd jm kz la lb jq lc ld le ju iq lf lg jy iu lh li kc iy lj lk kg ll bi translated">连接</h2><p id="e137" class="pw-post-body-paragraph if ig hi ih b ii lo ik il im lp io ip iq mj is it iu mk iw ix iy ml ja jb jc hb bi translated">我们可以把链接分为三个主要部分。他们是，</p><ol class=""><li id="9737" class="lm ln hi ih b ii ij im in iq mm iu mn iy mo jc nk lu lv lw bi translated">确认</li><li id="dda2" class="lm ln hi ih b ii lx im ly iq lz iu ma iy mb jc nk lu lv lw bi translated">准备</li><li id="4e9c" class="lm ln hi ih b ii lx im ly iq lz iu ma iy mb jc nk lu lv lw bi translated">解决</li></ol><p id="7c08" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们更深入地看看每个主题</p><h2 id="7cf3" class="ky jl hi bd jm kz la lb jq lc ld le ju iq lf lg jy iu lh li kc iy lj lk kg ll bi translated"><strong class="ak"> 1。验证</strong></h2><p id="c5cf" class="pw-post-body-paragraph if ig hi ih b ii lo ik il im lp io ip iq mj is it iu mk iw ix iy ml ja jb jc hb bi translated">Java 为其应用提供了安全性。JVM 有一个<strong class="ih hj">字节码验证器</strong>来确保安全。这个字节码检验器检查加载的类是否是用合法的编译器编译的，加载的类的结构和格式是否正确，等等。在验证过程中。如果这些测试中的任何一个失败，JVM 都会抛出一个<strong class="ih hj"> "java.lang.VerifyError" </strong>错误。如果加载的类通过了验证过程，那么准备过程将开始。</p><h2 id="6201" class="ky jl hi bd jm kz la lb jq lc ld le ju iq lf lg jy iu lh li kc iy lj lk kg ll bi translated">2.准备</h2><p id="d20d" class="pw-post-body-paragraph if ig hi ih b ii lo ik il im lp io ip iq mj is it iu mk iw ix iy ml ja jb jc hb bi translated">Java 的数据类型有一个默认值。例如:一个对象的默认值是 null，对于 int 它是零，对于 boolean 默认值是 false 等等。在准备过程中，JVM 为每个实例和静态变量分配默认值<strong class="ih hj">和</strong>。</p><blockquote class="mc md me"><p id="637a" class="if ig mf ih b ii ij ik il im in io ip mg ir is it mh iv iw ix mi iz ja jb jc hb bi translated">注意:请注意，在准备阶段，JVM 为变量分配默认值，而不是初始值。比如:<em class="hi">int a = 10；</em>对于这段代码，JVM 没有给变量“a”赋 10，而是赋零，因为 Int 的缺省值是零。</p></blockquote><h2 id="952a" class="ky jl hi bd jm kz la lb jq lc ld le ju iq lf lg jy iu lh li kc iy lj lk kg ll bi translated">3.解决</h2><p id="1d7a" class="pw-post-body-paragraph if ig hi ih b ii lo ik il im lp io ip iq mj is it iu mk iw ix iy ml ja jb jc hb bi translated">在解析过程中，JVM 将加载的类的符号链接转换成直接链接。换句话说，它替换了类和变量等的符号名。用直接分配的内存地址。</p><p id="e798" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在链接过程之后，将进行初始化。</p><h2 id="6249" class="ky jl hi bd jm kz la lb jq lc ld le ju iq lf lg jy iu lh li kc iy lj lk kg ll bi translated">初始化</h2><p id="bb5d" class="pw-post-body-paragraph if ig hi ih b ii lo ik il im lp io ip iq mj is it iu mk iw ix iy ml ja jb jc hb bi translated">在这个阶段，JVM 将为每个变量分配实际(初始)值。此外，如果该类包含一个静态块，它将被执行。</p><blockquote class="mc md me"><p id="ee3c" class="if ig mf ih b ii ij ik il im in io ip mg ir is it mh iv iw ix mi iz ja jb jc hb bi translated">JVM 有一个规则，声明在一个类成为活动使用之前，初始化过程必须发生。一个类有 6 种方法可以被激活使用。</p><p id="3d3b" class="if ig mf ih b ii ij ik il im in io ip mg ir is it mh iv iw ix mi iz ja jb jc hb bi translated">1.使用“new”关键字(for ex:Employee = new Employee()；)</p><p id="3a54" class="if ig mf ih b ii ij ik il im in io ip mg ir is it mh iv iw ix mi iz ja jb jc hb bi translated">2.调用静态方法</p><p id="4a9e" class="if ig mf ih b ii ij ik il im in io ip mg ir is it mh iv iw ix mi iz ja jb jc hb bi translated">3.给静态变量赋值</p></blockquote><p id="a665" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">注意:如果我们将“<strong class="ih hj"> final </strong>”关键字与“static”关键字一起使用，那么 JVM 不会将该类视为“活动使用”。</p><blockquote class="mc md me"><p id="eac0" class="if ig mf ih b ii ij ik il im in io ip mg ir is it mh iv iw ix mi iz ja jb jc hb bi translated">4.有主要方法的</p><p id="fce3" class="if ig mf ih b ii ij ik il im in io ip mg ir is it mh iv iw ix mi iz ja jb jc hb bi translated">5.实例化子类</p><p id="1950" class="if ig mf ih b ii ij ik il im in io ip mg ir is it mh iv iw ix mi iz ja jb jc hb bi translated">6.使用反射 API &amp;通过获取对象类型方法返回一个对象</p></blockquote></div><div class="ab cl jd je gp jf" role="separator"><span class="jg bw bk jh ji jj"/><span class="jg bw bk jh ji jj"/><span class="jg bw bk jh ji"/></div><div class="hb hc hd he hf"><h1 id="6de6" class="jk jl hi bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">存储区</h1><p id="ad61" class="pw-post-body-paragraph if ig hi ih b ii lo ik il im lp io ip iq mj is it iu mk iw ix iy ml ja jb jc hb bi translated">内存区域是 JVM 用来存储数据的地方。存储区分为 5 个子区。</p><figure class="kj kk kl km fd kn er es paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="er es nq"><img src="../Images/da10725aaa9389f1f4bdeccf8687a4ee.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JGXUwYQ7eWDdmwuYJGAxYA.png"/></div></div><figcaption class="ku kv et er es kw kx bd b be z dx translated">存储区</figcaption></figure><h2 id="1b6d" class="ky jl hi bd jm kz la lb jq lc ld le ju iq lf lg jy iu lh li kc iy lj lk kg ll bi translated">方法区域</h2><p id="e97c" class="pw-post-body-paragraph if ig hi ih b ii lo ik il im lp io ip iq mj is it iu mk iw ix iy ml ja jb jc hb bi translated">所有类级别的信息，如类名、直接父类名、方法和变量信息(包括静态变量等)都存储在方法区域中。方法区域是共享资源，每个 JVM 只有一个方法区域。</p><h2 id="d094" class="ky jl hi bd jm kz la lb jq lc ld le ju iq lf lg jy iu lh li kc iy lj lk kg ll bi translated">堆区域</h2><p id="1372" class="pw-post-body-paragraph if ig hi ih b ii lo ik il im lp io ip iq mj is it iu mk iw ix iy ml ja jb jc hb bi translated">堆区域存储所有对象信息。每个 JVM 将有一个堆区域。这也是一种共享资源。</p><h2 id="2364" class="ky jl hi bd jm kz la lb jq lc ld le ju iq lf lg jy iu lh li kc iy lj lk kg ll bi translated">堆</h2><p id="df0c" class="pw-post-body-paragraph if ig hi ih b ii lo ik il im lp io ip iq mj is it iu mk iw ix iy ml ja jb jc hb bi translated">堆栈保存方法信息，如局部变量。JVM 为每个线程创建一个运行时堆栈。每次调用方法时，都会在堆栈中创建一个新的框架(push ),用于存储方法调用。一个方法的所有局部变量都将存储在它们对应的框架中。当方法调用结束时，框架也被销毁(pop)。当相应的线程 get 终止时，堆栈被 JVM 销毁。这不是共享资源。</p><h2 id="1806" class="ky jl hi bd jm kz la lb jq lc ld le ju iq lf lg jy iu lh li kc iy lj lk kg ll bi translated">PC 寄存器</h2><p id="3f8e" class="pw-post-body-paragraph if ig hi ih b ii lo ik il im lp io ip iq mj is it iu mk iw ix iy ml ja jb jc hb bi translated">线程的执行指令存储在 PC 寄存器中。如果该方法是非本机方法，PC 寄存器将保存关于下一次执行的信息。Pc 寄存器是为每个线程创建的。</p><h2 id="58a9" class="ky jl hi bd jm kz la lb jq lc ld le ju iq lf lg jy iu lh li kc iy lj lk kg ll bi translated">本机方法区域</h2><p id="15df" class="pw-post-body-paragraph if ig hi ih b ii lo ik il im lp io ip iq mj is it iu mk iw ix iy ml ja jb jc hb bi translated">如果 JVM 访问任何本机方法，则本机方法信息存储在本机方法区域中。</p><blockquote class="mc md me"><p id="4590" class="if ig mf ih b ii ij ik il im in io ip mg ir is it mh iv iw ix mi iz ja jb jc hb bi translated">本地方法是用 Java 以外的语言(通常是 C/C++)编写的方法。</p></blockquote><p id="16db" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">每个线程都会创建一个本机方法区域。</p><h1 id="c82b" class="jk jl hi bd jm jn nl jp jq jr nm jt ju jv nn jx jy jz no kb kc kd np kf kg kh bi translated">执行引擎</h1><p id="cd84" class="pw-post-body-paragraph if ig hi ih b ii lo ik il im lp io ip iq mj is it iu mk iw ix iy ml ja jb jc hb bi translated">加载之后，字节码在执行引擎中执行。执行引擎包含 3 个主要组件。</p><ol class=""><li id="95e0" class="lm ln hi ih b ii ij im in iq mm iu mn iy mo jc nk lu lv lw bi translated">解释者</li><li id="088f" class="lm ln hi ih b ii lx im ly iq lz iu ma iy mb jc nk lu lv lw bi translated">JIT 编译器(实时编译器)</li><li id="c1f7" class="lm ln hi ih b ii lx im ly iq lz iu ma iy mb jc nk lu lv lw bi translated">垃圾收集器</li></ol><h2 id="5c9d" class="ky jl hi bd jm kz la lb jq lc ld le ju iq lf lg jy iu lh li kc iy lj lk kg ll bi translated">解释者</h2><p id="1ad9" class="pw-post-body-paragraph if ig hi ih b ii lo ik il im lp io ip iq mj is it iu mk iw ix iy ml ja jb jc hb bi translated">解释器读取字节码并逐行执行。解释器的缺点是当一个方法被调用多次时，解释器每次都必须执行新的解释，导致执行速度变慢。</p><h2 id="f1dc" class="ky jl hi bd jm kz la lb jq lc ld le ju iq lf lg jy iu lh li kc iy lj lk kg ll bi translated">JIT 编译器(实时编译器)</h2><p id="04c9" class="pw-post-body-paragraph if ig hi ih b ii lo ik il im lp io ip iq mj is it iu mk iw ix iy ml ja jb jc hb bi translated">JIT 编译器克服了解释器执行缓慢的问题。它首先将所有字节码编译成本机代码(机器码)。那么将为重复的方法调用的执行提供本机代码。执行本机代码比逐行解释指令要容易得多。由于本机代码存储在缓存中，编译后的代码运行速度会更快。</p><h2 id="542b" class="ky jl hi bd jm kz la lb jq lc ld le ju iq lf lg jy iu lh li kc iy lj lk kg ll bi translated">垃圾收集器</h2><p id="9385" class="pw-post-body-paragraph if ig hi ih b ii lo ik il im lp io ip iq mj is it iu mk iw ix iy ml ja jb jc hb bi translated">如果没有对一个对象的引用，就说它是不可达的。当对象不再被引用并且不能被 JVM 直接访问时，垃圾收集器从堆中移除对象并回收未使用的内存。通常，垃圾收集由后台守护线程处理。</p><p id="e096" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">除了上面提到的之外，JVM 中还有另外两个组件。分别是<strong class="ih hj"> Java 原生接口(JNI) </strong>和<strong class="ih hj">原生方法库。</strong></p><h2 id="4c1d" class="ky jl hi bd jm kz la lb jq lc ld le ju iq lf lg jy iu lh li kc iy lj lk kg ll bi translated">Java 本地接口(JNI)</h2><p id="6d52" class="pw-post-body-paragraph if ig hi ih b ii lo ik il im lp io ip iq mj is it iu mk iw ix iy ml ja jb jc hb bi translated">用于与本地方法库交互的 Java 本地接口，这是程序执行所必需的。</p><h2 id="155e" class="ky jl hi bd jm kz la lb jq lc ld le ju iq lf lg jy iu lh li kc iy lj lk kg ll bi translated"><strong class="ak">本地方法库。</strong></h2><p id="158e" class="pw-post-body-paragraph if ig hi ih b ii lo ik il im lp io ip iq mj is it iu mk iw ix iy ml ja jb jc hb bi translated">这是执行引擎执行程序所需的 C/C++本地库的集合。这可以通过提供的本机接口来访问。</p></div><div class="ab cl jd je gp jf" role="separator"><span class="jg bw bk jh ji jj"/><span class="jg bw bk jh ji jj"/><span class="jg bw bk jh ji"/></div><div class="hb hc hd he hf"><h1 id="a141" class="jk jl hi bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">参考</h1><p id="1e90" class="pw-post-body-paragraph if ig hi ih b ii lo ik il im lp io ip iq mj is it iu mk iw ix iy ml ja jb jc hb bi translated">2016.<em class="mf">什么是 JVM — Java 虚拟机</em>。[视频]可在:&lt;【https://www.youtube.com/watch?v=bUtIIWbaFKc T2】&amp;list = RDCMUCi5H-zh 48 t5tjsax 636 dn2a&amp;index = 2&gt;【2021 年 5 月 6 日访问】。</p><p id="c5cd" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">极客之福。2021.<em class="mf">JVM 是如何工作的——JVM 架构？— GeeksforGeeks </em>。[在线]可在:&lt;<a class="ae nr" href="https://www.geeksforgeeks.org/jvm-works-jvm-architecture/" rel="noopener ugc nofollow" target="_blank">https://www.geeksforgeeks.org/jvm-works-jvm-architecture/</a>&gt;【2021 年 5 月 6 日访问】。</p><p id="0140" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><a class="ae nr" href="http://www.javatpoint.com." rel="noopener ugc nofollow" target="_blank">www.javatpoint.com。2021 年。<em class="mf"> JVM | Java 虚拟机—Java point</em>。[在线]可在:&lt;</a><a class="ae nr" href="https://www.javatpoint.com/jvm-java-virtual-machine" rel="noopener ugc nofollow" target="_blank">【https://www.javatpoint.com/jvm-java-virtual-machine</a>&gt;【2021 年 5 月 6 日访问】。</p></div></div>    
</body>
</html>