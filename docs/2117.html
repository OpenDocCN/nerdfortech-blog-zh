<html>
<head>
<title>The streaming model, and how to estimate the most frequent elements with the Misra-Gries algorithm.</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">流模型，以及如何用 Misra-Gries 算法估计最频繁的元素。</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/the-streaming-model-and-how-to-estimate-the-most-frequent-elements-with-the-misra-gries-algorithm-c880bbe7218b?source=collection_archive---------1-----------------------#2021-04-22">https://medium.com/nerd-for-tech/the-streaming-model-and-how-to-estimate-the-most-frequent-elements-with-the-misra-gries-algorithm-c880bbe7218b?source=collection_archive---------1-----------------------#2021-04-22</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><figure class="hh hi ez fb hj hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es hg"><img src="../Images/2a928cdd0f65dc130ca9606a17da33b8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*O1G3pRl5HtAPU6_oXmY-3g.jpeg"/></div></div></figure><div class=""/><p id="d9c1" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">嘿大家好！我正在攻读计算机科学硕士学位，目前正在研究一些在主流文献中不太被提及的算法(又名。中型文章和其他博客文章)。如果你想了解那些不太为人所知的算法，但又没有耐心去钻研厚厚的研究论文，那么这篇文章就是为你准备的。</p><p id="bc07" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这篇帖子是关于<strong class="is hu">梅萨-格里斯</strong>算法的。这是一个相当简单的算法，在<strong class="is hu">流模型</strong>中用来计算所谓的<strong class="is hu">重量级人物。重量级元素</strong>指的是流中出现<strong class="is hu">比其他元素</strong>更频繁的元素。</p><p id="af8f" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hu">让我首先定义流模型</strong>:在这个模型中，我们有一个项目序列(我将使用字母<em class="jo"> m </em>来表示<em class="jo"> </em>项目的数量)被流传输到一个计算单元，其中计算机没有关于数据进入的<strong class="is hu">信息</strong>。</p><p id="aebf" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">项目流的一个有趣的属性是其中不同元素的数量。你可能会想<em class="jo">“这很容易计算，我们只需跟踪来自流的所有项目，然后计算有多少不同的元素！”，</em>但是这种方法需要<strong class="is hu">存储所有的流项目</strong>。我们也可以只为流中的每一项保留一个计数器，但是在每一项都不同的情况下，这最终会成为存储所有元素的相同问题。</p><p id="56d5" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">事实上，在流模型中，我们说流中的 item <strong class="is hu"> <em class="jo"> m </em> </strong>的数量远远大于计算机所能存储的数量。这有点像如果你看着河上漂浮着的物体:你可以看着它们经过，也许可以抓住一两个，但你可能没有足够的手抓住所有的东西。</p><figure class="jq jr js jt fd hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es jp"><img src="../Images/2778a7584106eaa279d46bb8a429aa22.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*56uYphQ1BZ1v20aER9zD8Q.png"/></div></div><figcaption class="ju jv et er es jw jx bd b be z dx translated">流式模型</figcaption></figure><p id="ffa7" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">那么，在只有一点内存空间的情况下，如何计算所有不同的元素呢？使用<strong class="is hu"> Misra-Gries </strong>算法，可以<strong class="is hu">估计</strong>哪些元素是<strong class="is hu">重要元素</strong>。使用这种算法，可以估计项目的频率，甚至更好的是，<strong class="is hu">找到在流中出现超过<em class="jo"> m/k </em>次的所有元素，对于定义的<em class="jo"> k </em>。</strong>例如在带有<strong class="is hu"> <em class="jo"> k=3 </em> </strong>的数组[1，1，2，3，4，5，1，1，2]中，我们要查找出现次数超过<strong class="is hu"><em class="jo">15/3 = 5</em></strong><em class="jo"/>的元素。</p><p id="c254" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">以下是一些其他的符号:我们使用一个流<strong class="is hu"> <em class="jo"> S </em> </strong>，大小为<strong class="is hu"> <em class="jo"> m </em> </strong>，它包含一个元素列表<strong class="is hu"><em class="jo">【aₓ】</em></strong>来自一个宇宙<strong class="is hu"><em class="jo">【n】= {1，2，…，n} </em> </strong> <em class="jo">(每个元素 aₓ</em><strong class="is hu"><em class="jo"/></strong><em class="jo">可以有一个取自集合{ 1，2</em></p><p id="277d" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">对所有元素进行计数的<strong class="is hu">一遍</strong>算法将需要计算机中的<strong class="is hu"><em class="jo">ω(m)</em></strong>空间，这不是我们想要的。但是通过用 Mesa-Gries 算法估计一个元素的频率，可以用<strong class="is hu">O(<em class="jo">k *(log(m)+log(n)))</em></strong>来限定空间使用量。该算法所做的估计允许单边误差。这意味着即使所有最频繁的项目都在最后的输出中，也可能有一些<strong class="is hu">不频繁的元素</strong>。</p><h2 id="499a" class="jy jz ht bd ka kb kc kd ke kf kg kh ki jb kj kk kl jf km kn ko jj kp kq kr ks bi translated">该算法</h2><p id="3333" class="pw-post-body-paragraph iq ir ht is b it kt iv iw ix ku iz ja jb kv jd je jf kw jh ji jj kx jl jm jn hb bi translated">算法本身相当简单。假设我们有一个流<strong class="is hu"> <em class="jo"> S </em> </strong>带有来自它的<strong class="is hu"> <em class="jo"> m </em> </strong>元素。我们使用一个字典<strong class="is hu"> <em class="jo"> D </em> </strong>来保存流项目的计数器。</p><p id="ab48" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hu">为来自流<em class="jo"> S </em> : <br/> ▹的每一项<em class="jo"> D </em> <br/>初始化一个字典如果 a 在<em class="jo"> D </em>中，则<em class="jo">d【a】++</em><br/>▹否则如果<em class="jo"> D </em>的大小小于<em class="jo"> k-1 </em>，则插入<em class="jo">a</em></strong></p><figure class="jq jr js jt fd hk er es paragraph-image"><div class="er es ky"><img src="../Images/38151840cc638401108315563fd0623e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1300/1*BNruQNfhnQ6ZBulfqMCZ1g.gif"/></div><figcaption class="ju jv et er es jw jx bd b be z dx translated">米斯拉-格里斯算法动画</figcaption></figure><h2 id="b6fc" class="jy jz ht bd ka kb kc kd ke kf kg kh ki jb kj kk kl jf km kn ko jj kp kq kr ks bi translated">为什么会起作用</h2><p id="caa5" class="pw-post-body-paragraph iq ir ht is b it kt iv iw ix ku iz ja jb kv jd je jf kw jh ji jj kx jl jm jn hb bi translated">设<strong class="is hu"> f̂ <em class="jo"> </em> </strong>为某一项的频率估计值，<strong class="is hu"> f </strong>为该项在码流<strong class="is hu"> <em class="jo"> S </em> </strong>中的真实频率。我们可以宣称<strong class="is hu"><em class="jo">f-m/k</em></strong><em class="jo">≤</em><strong class="is hu"><em class="jo">f̂</em></strong><em class="jo">≤</em><strong class="is hu"><em class="jo">f .</em></strong>即<strong class="is hu"><em class="jo">f̂</em></strong><strong class="is hu"><em class="jo"/></strong>项的估计频率大于或等于真实频率</p><p id="3abd" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">假设<strong class="is hu"> <em class="jo"> e </em> </strong>是一个频率大于<strong class="is hu"> m <em class="jo"> /k </em> </strong>的元素。</p><p id="fd26" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">当元素<strong class="is hu"> <em class="jo"> e </em> </strong>的出现没有被计数时，可能有两个原因:</p><ul class=""><li id="3aad" class="kz la ht is b it iu ix iy jb lb jf lc jj ld jn le lf lg lh bi translated">因为我们试图将它插入到<strong class="is hu"> D </strong>中，但是它已经有了<strong class="is hu"> k-1 </strong>项</li><li id="f0a1" class="kz la ht is b it li ix lj jb lk jf ll jj lm jn le lf lg lh bi translated">或者因为当<strong class="is hu"> <em class="jo"> D </em> </strong>已经满时发生了另一次插入，使得<strong class="is hu"> <em class="jo"> e </em> </strong>的计数递减。</li></ul><p id="0378" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">由于<strong class="is hu"> <em class="jo"> |D| = k-1 </em> </strong>，这样的事件最多有<strong class="is hu"> m <em class="jo"> /k </em> </strong>次发生。</p><p id="603a" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">因此如果<strong class="is hu"> <em class="jo"> e </em> </strong>在算法结束时仍在<strong class="is hu"> D </strong>中，它发生的次数超过<strong class="is hu"> m <em class="jo"> /k </em> </strong>次。</p><h2 id="96b0" class="jy jz ht bd ka kb kc kd ke kf kg kh ki jb kj kk kl jf km kn ko jj kp kq kr ks bi translated">算法空间界限</h2><p id="971e" class="pw-post-body-paragraph iq ir ht is b it kt iv iw ix ku iz ja jb kv jd je jf kw jh ji jj kx jl jm jn hb bi translated"><strong class="is hu"><em class="jo"/></strong>中最多有<strong class="is hu"> <em class="jo"> k-1 </em> </strong>个计数器(这个我们可以简化为<strong class="is hu"> <em class="jo"> k </em> </strong>)。对于每个计数器，我们持有一个可以从<strong class="is hu"> <em class="jo"> 1 </em> </strong>到<strong class="is hu"> <em class="jo"> n </em> </strong>的 key，以及一个可以从<strong class="is hu"> <em class="jo"> 1 </em> </strong>到<strong class="is hu"> <em class="jo"> m </em> </strong>的对应值。</p><p id="f8da" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">存储一个键<strong class="is hu"><em class="jo">【n】</em></strong>需要<strong class="is hu"><em class="jo">【n】</em></strong>空间(想想二进制表示)，而一个计数器<strong class="is hu"><em class="jo">【m】</em></strong>需要<strong class="is hu"><em class="jo">【m】</em></strong>空间。因此一个键-值对代表<strong class="is hu"><em class="jo">log(n)+log(m)</em></strong>空间。</p><p id="1dc6" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">因为我们有 k-1 个密钥，所以对于算法空间的使用，我们最终得到一个更高的界限<strong class="is hu">O(<em class="jo">k *(log(m)+log(n)))</em></strong>)。</p><h2 id="7f6e" class="jy jz ht bd ka kb kc kd ke kf kg kh ki jb kj kk kl jf km kn ko jj kp kq kr ks bi translated">限制</h2><p id="23b4" class="pw-post-body-paragraph iq ir ht is b it kt iv iw ix ku iz ja jb kv jd je jf kw jh ji jj kx jl jm jn hb bi translated">Misra-Gries 算法是一个简单的算法，可以很好地估计重要的项目，但是正如我上面提到的，它也可以输出不常见的项目。可以修改算法，或者甚至使用不同的算法来估计重拳出击的频率，而不输出不频繁的项目。</p><figure class="jq jr js jt fd hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es hg"><img src="../Images/2a928cdd0f65dc130ca9606a17da33b8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*O1G3pRl5HtAPU6_oXmY-3g.jpeg"/></div></div></figure><p id="f10d" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如果你有兴趣了解更多，我推荐阅读关于流算法和数据结构的书籍——比如 Bloom filters 和 Count-min sketch。</p><p id="6e54" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如果您对本文有任何问题或评论，请告诉我！干杯，斯蒂芬</p></div></div>    
</body>
</html>