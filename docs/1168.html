<html>
<head>
<title>Reactdroid — Reactive MVI Architecture, in Kotlin</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">反应体——反应式MVI建筑，科特林</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/reactdroid-reactive-mvi-architecture-for-android-with-a-pure-kotlin-core-multiplatform-587726a5045f?source=collection_archive---------9-----------------------#2021-03-07">https://medium.com/nerd-for-tech/reactdroid-reactive-mvi-architecture-for-android-with-a-pure-kotlin-core-multiplatform-587726a5045f?source=collection_archive---------9-----------------------#2021-03-07</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><h2 id="0e60" class="hg hh hi bd b fp hj hk hl hm hn ho dx hp translated" aria-label="kicker paragraph">移动应用中的反应式编程——一次旅行</h2><div class=""/><div class=""><h2 id="5c5d" class="pw-subtitle-paragraph io hr hi bd b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf dx translated">一个全面的移动开发库，采用纯Kotlin内核设计，并扩展了Android层。用于快速、结构化和可靠的应用程序开发。</h2></div><h2 id="7f6c" class="jg jh hi bd ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc ho bi translated">介绍</h2><p id="1a07" class="pw-post-body-paragraph kd ke hi kf b kg kh is ki kj kk iv kl jr km kn ko jv kp kq kr jz ks kt ku kv hb bi translated">在之前的文章中，我们谈到了<a class="ae kw" rel="noopener" href="/nerd-for-tech/what-is-wrong-with-current-mobile-development-3675ce94ccf5"> <em class="kx">为什么</em> </a>当前的原生移动开发方法不够好，以及<a class="ae kw" rel="noopener" href="/@gguymi/25229937d4f"> <em class="kx">什么是</em> </a>是建议的方法(<em class="kx"> React+Redux </em>)。这次我们将看到<em class="kx">如何在<em class="kx"> Kotlin </em>中实现类似<em class="kx"> React </em>的架构，下一篇文章将讨论<em class="kx">如何使用<em class="kx"> RxKotlin实现类似<em class="kx"> Redux </em>的架构。<br/></em><a class="ae kw" href="https://github.com/GuyMichael/Reactdroid" rel="noopener ugc nofollow" target="_blank">最终库——<em class="kx">react droid</em>——在<em class="kx"> GitHub </em> </a>上。</em></em></p><figure class="kz la lb lc fd ld er es paragraph-image"><div role="button" tabindex="0" class="le lf di lg bf lh"><div class="er es ky"><img src="../Images/1a1a2a0d96a83827690a9e9714d77909.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XrF6-SF2pyYprLrXfjSchw.jpeg"/></div></div><figcaption class="lk ll et er es lm ln bd b be z dx translated">本土手机开发中的MVI。一个光明的新世界。</figcaption></figure></div><div class="ab cl lo lp gp lq" role="separator"><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt"/></div><div class="hb hc hd he hf"><h1 id="4f09" class="lv jh hi bd ji lw lx ly jm lz ma mb jq ix mc iy ju ja md jb jy jd me je kc mf bi translated">(这个架构是怎么搭建的)？</h1><p id="6896" class="pw-post-body-paragraph kd ke hi kf b kg kh is ki kj kk iv kl jr km kn ko jv kp kq kr jz ks kt ku kv hb bi translated"><em class="kx">React</em>like和<em class="kx"> Redux- </em> like实现都是纯粹的<em class="kx"> Kotlin </em>，允许<a class="ae kw" href="https://kotlinlang.org/docs/multiplatform.html" rel="noopener ugc nofollow" target="_blank"> <em class="kx">多平台</em> </a>开发；而且两者都多了一个<em class="kx"> Android- </em>特定层。</p><blockquote class="mg mh mi"><p id="e13c" class="kd ke kx kf b kg mj is ki kj mk iv kl ml mm kn ko mn mo kq kr mp mq kt ku kv hb bi translated">如果你还不熟悉<em class="hi">反应</em>和<em class="hi">还原</em>的原理，请<a class="ae kw" rel="noopener" href="/@gguymi/25229937d4f">回到上一篇文章</a>。</p><p id="f273" class="kd ke kx kf b kg mj is ki kj mk iv kl ml mm kn ko mn mo kq kr mp mq kt ku kv hb bi translated"><em class="hi">编辑:在完成这个系列的时候，Android终于发布了一个稳定版的</em><a class="ae kw" href="https://developer.android.com/jetpack/compose" rel="noopener ugc nofollow" target="_blank"><em class="hi">JetpackCompose</em></a><em class="hi">，基本上模仿了React的功能组件。与</em> <a class="ae kw" href="https://kotlinlang.org/docs/coroutines-overview.html" rel="noopener ugc nofollow" target="_blank"> <em class="hi">协同例程</em> </a> <em class="hi">和</em><a class="ae kw" href="https://reduxkotlin.org/" rel="noopener ugc nofollow" target="_blank"><em class="hi">Kotlin-Redux</em></a><em class="hi">一起，它是一个强大的“包”，只需一些努力，就可以用来替换或重写</em><a class="ae kw" href="https://github.com/GuyMichael/Reactdroid" rel="noopener ugc nofollow" target="_blank"><em class="hi">react droid</em></a><em class="hi">。<br/>虽然所有这些都是真的(而且你应该熟悉上面的技术)，我们将在这个系列中学习的概念是</em> <strong class="kf hs"> <em class="hi"> </em> </strong> <em class="hi">现在</em> <strong class="kf hs"> <em class="hi"> </em> </strong> <em class="hi">甚至</em> <strong class="kf hs"> <em class="hi">比以往更相关</em> </strong> <em class="hi"> —“标准”的编写移动应用程序的方式越来越接近提到的概念。</em></p></blockquote><p id="aef3" class="pw-post-body-paragraph kd ke hi kf b kg mj is ki kj mk iv kl jr mm kn ko jv mo kq kr jz mq kt ku kv hb bi translated">在高层次上，这就是<em class="kx"> Reactdroid </em>的<em class="kx"> Kotlin </em>内核的结构:</p><figure class="kz la lb lc fd ld er es paragraph-image"><div class="er es mr"><img src="../Images/55f630655e10de467c7be6a05d2ad311.png" data-original-src="https://miro.medium.com/v2/resize:fit:868/format:webp/1*FpE9uM0Ln5dCT2Qjtb1L8A.png"/></div><figcaption class="lk ll et er es lm ln bd b be z dx translated">反应性类固醇的科特林核心</figcaption></figure><p id="db4a" class="pw-post-body-paragraph kd ke hi kf b kg mj is ki kj mk iv kl jr mm kn ko jv mo kq kr jz mq kt ku kv hb bi translated">而下面是它的<em class="kx"> Android </em>层。它的型号扩展了<em class="kx">科特林</em>核心的型号:</p><figure class="kz la lb lc fd ld er es paragraph-image"><div class="er es ms"><img src="../Images/f2a868c3248caf9a6e991414c9d2092e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1060/format:webp/1*PEfBLv2Mn1Yb4CwCzotZ3A.png"/></div><figcaption class="lk ll et er es lm ln bd b be z dx translated">Reactdroid的Android层</figcaption></figure></div><div class="ab cl lo lp gp lq" role="separator"><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt"/></div><div class="hb hc hd he hf"><h1 id="fa14" class="lv jh hi bd ji lw lx ly jm lz ma mb jq ix mc iy ju ja md jb jy jd me je kc mf bi translated">我们将在本文中讨论的内容</h1><p id="46a8" class="pw-post-body-paragraph kd ke hi kf b kg kh is ki kj kk iv kl jr km kn ko jv kp kq kr jz ks kt ku kv hb bi translated">在本文中，我们将只讨论(<em class="kx"> Kotlin </em> -core's) <em class="kx">组件</em>模型。<br/>我们将介绍:</p><ol class=""><li id="1b5b" class="mt mu hi kf b kg mj kj mk jr mv jv mw jz mx kv my mz na nb bi translated"><em class="kx">组件</em>类</li><li id="18d3" class="mt mu hi kf b kg nc kj nd jr ne jv nf jz ng kv my mz na nb bi translated"><em class="kx">组件</em>的API — <em class="kx"> onRender/setState </em></li><li id="6b31" class="mt mu hi kf b kg nc kj nd jr ne jv nf jz ng kv my mz na nb bi translated"><em class="kx">组件的生命周期回调</em></li><li id="c6d7" class="mt mu hi kf b kg nc kj nd jr ne jv nf jz ng kv my mz na nb bi translated"><em class="kx">组件</em>的【重新】<em class="kx">渲染</em>逻辑。</li><li id="ce44" class="mt mu hi kf b kg nc kj nd jr ne jv nf jz ng kv my mz na nb bi translated">在<em class="kx"> Kotlin </em>中创建我们的第一个自定义<em class="kx"> React组件</em></li></ol><p id="6c76" class="pw-post-body-paragraph kd ke hi kf b kg mj is ki kj mk iv kl jr mm kn ko jv mo kq kr jz mq kt ku kv hb bi translated">下一篇文章将是关于<em class="kx"> Redux </em>和<em class="kx"> Store </em>车型的。</p></div><div class="ab cl lo lp gp lq" role="separator"><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt"/></div><div class="hb hc hd he hf"><h1 id="18ed" class="lv jh hi bd ji lw lx ly jm lz ma mb jq ix mc iy ju ja md jb jy jd me je kc mf bi translated">该组件</h1><p id="3efe" class="pw-post-body-paragraph kd ke hi kf b kg kh is ki kj kk iv kl jr km kn ko jv kp kq kr jz ks kt ku kv hb bi translated">组件本身包含了整个<em class="kx">反应</em>架构，真的。<br/>它定义了一个小的<a class="ae kw" href="https://www.techopedia.com/definition/16447/state-machine" rel="noopener ugc nofollow" target="_blank">状态机</a>，是这样的:</p><p id="7a33" class="pw-post-body-paragraph kd ke hi kf b kg mj is ki kj mk iv kl jr mm kn ko jv mo kq kr jz mq kt ku kv hb bi translated">从外部来看，一个想要更新其<em class="kx">组件</em>的‘父级’:</p><p id="01c0" class="pw-post-body-paragraph kd ke hi kf b kg mj is ki kj mk iv kl jr mm kn ko jv mo kq kr jz mq kt ku kv hb bi translated">[<em class="kx">on render(props)</em>]➡[<em class="kx">check-if-new-props-different</em>]➡[<em class="kx">render</em></p><p id="a89c" class="pw-post-body-paragraph kd ke hi kf b kg mj is ki kj mk iv kl jr mm kn ko jv mo kq kr jz mq kt ku kv hb bi translated">或者在内部，一个<em class="kx">组件</em>可以这样更新自己:</p><p id="2459" class="pw-post-body-paragraph kd ke hi kf b kg mj is ki kj mk iv kl jr mm kn ko jv mo kq kr jz mq kt ku kv hb bi translated">[<em class="kx">setstate(ownstate)</em>]➡[<em class="kx">check-if-new-state-different</em>]➡[<em class="kx">render</em></p><blockquote class="mg mh mi"><p id="8c40" class="kd ke kx kf b kg mj is ki kj mk iv kl ml mm kn ko mn mo kq kr mp mq kt ku kv hb bi translated">注意:这种必须经历整个周期而不是直接调用<code class="du nh ni nj nk b"><em class="hi">this.render()</em></code>的方法称为“<a class="ae kw" href="https://www.geeksforgeeks.org/unidirectional-data-flow/" rel="noopener ugc nofollow" target="_blank">单向数据流</a>”。</p></blockquote><p id="3124" class="pw-post-body-paragraph kd ke hi kf b kg mj is ki kj mk iv kl jr mm kn ko jv mo kq kr jz mq kt ku kv hb bi translated">让我们使用一个<em class="kx">抽象类</em>来定义我们的<em class="kx">组件</em>:</p><figure class="kz la lb lc fd ld"><div class="bz dy l di"><div class="nl nm l"/></div><figcaption class="lk ll et er es lm ln bd b be z dx translated">类反应组件的核心</figcaption></figure><p id="43dc" class="pw-post-body-paragraph kd ke hi kf b kg mj is ki kj mk iv kl jr mm kn ko jv mo kq kr jz mq kt ku kv hb bi translated">你可以看到，我们的<code class="du nh ni nj nk b">props</code>和<code class="du nh ni nj nk b">ownState</code>是<em class="kx">类型化的</em>(使用<a class="ae kw" href="https://www.baeldung.com/kotlin/generics" rel="noopener ugc nofollow" target="_blank"> <em class="kx">泛型</em> </a>，这样<em class="kx">组件</em>就可以有自己特定的<em class="kx">道具</em>和<em class="kx">状态</em>。<br/>我们稍后会定义<code class="du nh ni nj nk b">OwnProps</code>和<code class="du nh ni nj nk b">OwnState</code>。</p><blockquote class="mg mh mi"><p id="7c93" class="kd ke kx kf b kg mj is ki kj mk iv kl ml mm kn ko mn mo kq kr mp mq kt ku kv hb bi translated">注意:特定于平台的实现将<em class="hi">扩展</em> it以将其绑定到他们自己的环境(例如，在<em class="hi"> Android </em>中，它将是与<em class="hi">视图</em>绑定的<code class="du nh ni nj nk b"><em class="hi">AComponent</em></code>)。</p></blockquote><p id="0056" class="pw-post-body-paragraph kd ke hi kf b kg mj is ki kj mk iv kl jr mm kn ko jv mo kq kr jz mq kt ku kv hb bi translated">下一步是<em class="kx">组件</em>的API和生命周期回调。</p></div><div class="ab cl lo lp gp lq" role="separator"><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt"/></div><div class="hb hc hd he hf"><h2 id="6dca" class="jg jh hi bd ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc ho bi translated">组件的API — onRender()</h2><p id="9423" class="pw-post-body-paragraph kd ke hi kf b kg kh is ki kj kk iv kl jr km kn ko jv kp kq kr jz ks kt ku kv hb bi translated">我们<a class="ae kw" rel="noopener" href="/nerd-for-tech/react-redux-in-kotlin-for-truly-native-mobile-development-25229937d4f#77e9">已经知道<strong class="kf hs">唯一让<em class="kx">组件</em>更新UI(重新<em class="kx">渲染)</em>的</strong>方式是给它传递新的<em class="kx">道具</em>(或者在内部，<em class="kx"> ownState </em>)。这就是<em class="kx"> onRender </em>方法(和<em class="kx"> setState </em>)的用途:</a></p><figure class="kz la lb lc fd ld"><div class="bz dy l di"><div class="nl nm l"/></div><figcaption class="lk ll et er es lm ln bd b be z dx translated">组件的(唯一)API — onRender()</figcaption></figure><p id="3ef3" class="pw-post-body-paragraph kd ke hi kf b kg mj is ki kj mk iv kl jr mm kn ko jv mo kq kr jz mq kt ku kv hb bi translated">API完成:)<br/>我们后面会定义实际的<em class="kx">渲染</em>逻辑。</p><p id="6f01" class="pw-post-body-paragraph kd ke hi kf b kg mj is ki kj mk iv kl jr mm kn ko jv mo kq kr jz mq kt ku kv hb bi translated">下一步— UI生命周期回调。</p></div><div class="ab cl lo lp gp lq" role="separator"><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt"/></div><div class="hb hc hd he hf"><h2 id="a457" class="jg jh hi bd ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc ho bi translated">组件生命周期</h2><p id="cdf7" class="pw-post-body-paragraph kd ke hi kf b kg kh is ki kj kk iv kl jr km kn ko jv kp kq kr jz ks kt ku kv hb bi translated">作为UI的负责人，<em class="kx">组件</em>有生命周期回调来帮助我们根据<strong class="kf hs"> U </strong> ser <strong class="kf hs"> I </strong>与它交互的时间来控制我们的应用程序会发生什么。让我们直接进入主题，看看3个最重要也是最直观的回调，所有解释都在代码中:</p><figure class="kz la lb lc fd ld"><div class="bz dy l di"><div class="nl nm l"/></div><figcaption class="lk ll et er es lm ln bd b be z dx translated">组件生命周期的简化版本</figcaption></figure><p id="11bf" class="pw-post-body-paragraph kd ke hi kf b kg mj is ki kj mk iv kl jr mm kn ko jv mo kq kr jz mq kt ku kv hb bi translated">嗯，<a class="ae kw" href="https://github.com/GuyMichael/Reactdroid/blob/master/reactdroid/src/main/java/com/guymichael/kotlinreact/model/Component.kt" rel="noopener ugc nofollow" target="_blank">还有更多</a>，但这些都是基本面。<br/>它们只是空实现的<code class="du nh ni nj nk b">open</code>函数，供定制<em class="kx">组件</em>使用。我们会看到<em class="kx">当</em>他们很快被召唤的时候。</p><blockquote class="mg mh mi"><p id="638e" class="kd ke kx kf b kg mj is ki kj mk iv kl ml mm kn ko mn mo kq kr mp mq kt ku kv hb bi translated">注意:<em class="hi"> componentDidMount </em>有点类似于<em class="hi"> Android Activity </em>的<code class="du nh ni nj nk b">onPostCreate()</code>或者<em class="hi"> View </em>的<code class="du nh ni nj nk b"><em class="hi">onViewAttachedToWindow()</em></code>。<br/><em class="hi">component will unmount—</em>或者更好的称呼，<em class="hi"> componentDidUnmount — </em>有点类似于<em class="hi">安卓活动</em>的<code class="du nh ni nj nk b">onDestroy()</code>或者<em class="hi">视图</em>的<code class="du nh ni nj nk b"><em class="hi">onViewDetachedFromWindow()</em></code> <em class="hi">。</em></p></blockquote><p id="f382" class="pw-post-body-paragraph kd ke hi kf b kg mj is ki kj mk iv kl jr mm kn ko jv mo kq kr jz mq kt ku kv hb bi translated">在我们进入最后一步之前——组件<em class="kx">的<em class="kx">渲染</em>逻辑——</em>让我们看看整个事情(到目前为止),以获得一些视角:</p><figure class="kz la lb lc fd ld"><div class="bz dy l di"><div class="nl nm l"/></div><figcaption class="lk ll et er es lm ln bd b be z dx translated">组件—概述</figcaption></figure><p id="f6db" class="pw-post-body-paragraph kd ke hi kf b kg mj is ki kj mk iv kl jr mm kn ko jv mo kq kr jz mq kt ku kv hb bi translated">差不多就是这样了。<br/>剩下的唯一问题是关于<code class="du nh ni nj nk b">props</code>和<code class="du nh ni nj nk b">ownState</code>,<em class="kx">渲染</em>逻辑是如何工作的。<br/>我们将只讨论<em class="kx">道具</em>，因为它们更有趣，而且我们已经确定<a class="ae kw" rel="noopener" href="/@gguymi/25229937d4f#78a6"> <em class="kx"> ownState </em>应该很少使用</a>。</p><blockquote class="mg mh mi"><p id="740a" class="kd ke kx kf b kg mj is ki kj mk iv kl ml mm kn ko mn mo kq kr mp mq kt ku kv hb bi translated"><em class="hi"> ownState </em>流程本质上完全相同…</p></blockquote></div><div class="ab cl lo lp gp lq" role="separator"><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt"/></div><div class="hb hc hd he hf"><h2 id="1f13" class="jg jh hi bd ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc ho bi translated">组件的(重新)呈现逻辑</h2><p id="de40" class="pw-post-body-paragraph kd ke hi kf b kg kh is ki kj kk iv kl jr km kn ko jv kp kq kr jz ks kt ku kv hb bi translated">这是有趣的东西。其他一切都很基本。<br/>总的想法还是“<a class="ae kw" href="https://www.geeksforgeeks.org/unidirectional-data-flow/" rel="noopener ugc nofollow" target="_blank">单向数据流</a>”:一旦新的<em class="kx">道具</em>(或<em class="kx">自身状态</em> ) <em class="kx"> </em>被传递——使用<em class="kx"> onRender </em>(或<em class="kx">set state</em>)—<em class="kx">组件</em>将它们与先前的进行检查，如果它们不同，它将重新<em class="kx">呈现</em></p><p id="eca1" class="pw-post-body-paragraph kd ke hi kf b kg mj is ki kj mk iv kl jr mm kn ko jv mo kq kr jz mq kt ku kv hb bi translated">我们不会面面俱到，因为内容很多，但是让我们回顾一下基本原理:</p><figure class="kz la lb lc fd ld"><div class="bz dy l di"><div class="nl nm l"/></div><figcaption class="lk ll et er es lm ln bd b be z dx translated">组件在Render()上。简化。</figcaption></figure><p id="8ca1" class="pw-post-body-paragraph kd ke hi kf b kg mj is ki kj mk iv kl jr mm kn ko jv mo kq kr jz mq kt ku kv hb bi translated">我们使用我们的<a class="ae kw" href="https://stackoverflow.com/questions/37618738/how-to-check-if-a-lateinit-variable-has-been-initialized" rel="noopener ugc nofollow" target="_blank"> <em class="kx"> lateinit var </em> </a> <em class="kx">道具</em>来知道我们是否曾经<em class="kx">渲染过</em>。<br/>让我们回顾一下<code class="du nh ni nj nk b">onFirstRender()</code>和<code class="du nh ni nj nk b">onStandardRender()</code>的区别，进一步理解其中的逻辑。</p></div><div class="ab cl lo lp gp lq" role="separator"><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt"/></div><div class="hb hc hd he hf"><h2 id="fbe5" class="jg jh hi bd ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc ho bi translated">组件的首次渲染</h2><p id="5a1b" class="pw-post-body-paragraph kd ke hi kf b kg kh is ki kj kk iv kl jr km kn ko jv kp kq kr jz ks kt ku kv hb bi translated"><code class="du nh ni nj nk b">onFirstRender()</code>背后的逻辑就是这样:<br/>‘等待<em class="kx">挂载</em>事件，然后<em class="kx">渲染</em>’。</p><blockquote class="mg mh mi"><p id="33a7" class="kd ke kx kf b kg mj is ki kj mk iv kl ml mm kn ko mn mo kq kr mp mq kt ku kv hb bi translated">以<em class="hi">安卓</em>为例，<em class="hi">挂载</em>是当<em class="hi">视图</em>被<em class="hi">附着</em>到<em class="hi"> </em>窗口<em class="hi">时。</em></p></blockquote><p id="71c1" class="pw-post-body-paragraph kd ke hi kf b kg mj is ki kj mk iv kl jr mm kn ko jv mo kq kr jz mq kt ku kv hb bi translated">这是它的简化版:</p><figure class="kz la lb lc fd ld"><div class="bz dy l di"><div class="nl nm l"/></div><figcaption class="lk ll et er es lm ln bd b be z dx translated">组件首先呈现流程。简化。</figcaption></figure><p id="5beb" class="pw-post-body-paragraph kd ke hi kf b kg mj is ki kj mk iv kl jr mm kn ko jv mo kq kr jz mq kt ku kv hb bi translated"><code class="du nh ni nj nk b">waitForMount</code>是一个<em class="kx">抽象</em>函数，具体平台的<em class="kx">基类</em>(如<em class="kx"> Android </em> <em class="kx">组件</em>)应该实现它，告诉<em class="kx">组件</em>何时被<em class="kx">挂载</em>(如<em class="kx">视图</em>的<em class="kx"> onAttach() </em>事件在<em class="kx"> Android </em>中)。</p><p id="1b01" class="pw-post-body-paragraph kd ke hi kf b kg mj is ki kj mk iv kl jr mm kn ko jv mo kq kr jz mq kt ku kv hb bi translated"><code class="du nh ni nj nk b">createIntialState(props)</code>也是一个<em class="kx">抽象</em>函数。这是<em class="kx">组件</em>定义它们的初始<em class="kx"> ownState </em>的地方，给定一些(初始)<em class="kx">道具</em>。没什么太有趣的。</p><blockquote class="mg mh mi"><p id="056b" class="kd ke kx kf b kg mj is ki kj mk iv kl ml mm kn ko mn mo kq kr mp mq kt ku kv hb bi translated">注意:我简化了这个例子，还有更多的内容；和一些边缘情况</p></blockquote><p id="c45b" class="pw-post-body-paragraph kd ke hi kf b kg mj is ki kj mk iv kl jr mm kn ko jv mo kq kr jz mq kt ku kv hb bi translated">好了，那只是第一次<em class="kx">渲染</em>。让我们继续有趣的部分。</p></div><div class="ab cl lo lp gp lq" role="separator"><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt"/></div><div class="hb hc hd he hf"><h2 id="9593" class="jg jh hi bd ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc ho bi translated">组件的标准(非第一)渲染</h2><p id="42f4" class="pw-post-body-paragraph kd ke hi kf b kg kh is ki kj kk iv kl jr km kn ko jv kp kq kr jz ks kt ku kv hb bi translated">在非第一个<em class="kx">呈现</em>请求时调用<code class="du nh ni nj nk b">onStandardRender(props)</code>。它的逻辑也很简单:<br/>‘如果新的<em class="kx">道具</em>和以前的不一样——<em class="kx">重新渲染【T66’:</em></p><figure class="kz la lb lc fd ld"><div class="bz dy l di"><div class="nl nm l"/></div><figcaption class="lk ll et er es lm ln bd b be z dx translated">组件非第一渲染流。</figcaption></figure><p id="f943" class="pw-post-body-paragraph kd ke hi kf b kg mj is ki kj mk iv kl jr mm kn ko jv mo kq kr jz mq kt ku kv hb bi translated">正如您现在所希望理解的，这个<em class="kx">等式</em>检查，就在那里，是<em class="kx"> React </em>  <em class="kx">，</em>与其他架构的权衡:</p><ul class=""><li id="566a" class="mt mu hi kf b kg mj kj mk jr mv jv mw jz mx kv nn mz na nb bi translated">我们可以做<a class="ae kw" href="https://stackoverflow.com/questions/36084515/how-does-shallow-compare-work-in-react" rel="noopener ugc nofollow" target="_blank"> <em class="kx">浅相等</em> </a>(就像在<em class="kx">反应</em>中一样)，但是会导致更多(不必要)<em class="kx">渲染</em>(也是‘重’)——就像一些<em class="kx">相等</em>检查<a class="ae kw" href="https://codeburst.io/react-array-re-render-performance-ee23f34c5d66" rel="noopener" target="_blank">会无缘无故返回<em class="kx">假</em></a>。</li><li id="bb50" class="mt mu hi kf b kg nc kj nd jr ne jv nf jz ng kv nn mz na nb bi translated">或者我们可以做一个完整的<em class="kx">相等</em>检查——这也是“繁重”的。</li></ul><p id="61ca" class="pw-post-body-paragraph kd ke hi kf b kg mj is ki kj mk iv kl jr mm kn ko jv mo kq kr jz mq kt ku kv hb bi translated">解决方案总是介于两者之间:)<br/>它内置在<code class="du nh ni nj nk b">OwnProps</code>模型的<code class="du nh ni nj nk b">equals()</code>方法中。这就是我把它留到最后的原因。</p></div><div class="ab cl lo lp gp lq" role="separator"><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt"/></div><div class="hb hc hd he hf"><h2 id="e284" class="jg jh hi bd ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc ho bi translated">组件的OwnProps及其equals()</h2><p id="e6b9" class="pw-post-body-paragraph kd ke hi kf b kg kh is ki kj kk iv kl jr km kn ko jv kp kq kr jz ks kt ku kv hb bi translated"><code class="du nh ni nj nk b">OwnProps</code> / <code class="du nh ni nj nk b">OwnState</code>有一个<code class="du nh ni nj nk b">React</code>的<em class="kx">道具</em>没有的方法(只是一个<em class="kx"> JavaScript </em>普通<em class="kx">对象)——</em><code class="du nh ni nj nk b">getAllMembers()</code>。<br/> <em class="kx"> Reactdroid </em>的<em class="kx">相等</em>检查使用<strong class="kf hs">真实</strong>相等，但它们是在一个<strong class="kf hs">选定的<em class="kx">道具</em> / <em class="kx"> ownState </em>成员<em class="kx">上完成的，而不是盲目地在整个<em class="kx">对象</em>上完成的。这就是诀窍。</em></strong></p><p id="8cb7" class="pw-post-body-paragraph kd ke hi kf b kg mj is ki kj mk iv kl jr mm kn ko jv mo kq kr jz mq kt ku kv hb bi translated">让我们回顾一下<code class="du nh ni nj nk b">OwnProps</code>:</p><figure class="kz la lb lc fd ld"><div class="bz dy l di"><div class="nl nm l"/></div><figcaption class="lk ll et er es lm ln bd b be z dx translated">组件的道具模型。简化了的</figcaption></figure><p id="74cf" class="pw-post-body-paragraph kd ke hi kf b kg mj is ki kj mk iv kl jr mm kn ko jv mo kq kr jz mq kt ku kv hb bi translated">就是这样:<em class="kx">等于<em class="kx">上的</em>道具</em> / <em class="kx">自身状态</em>定义为当一个<strong class="kf hs">选择的</strong>集合的成员<em class="kx">等于</em>时。这提供了两大特性:</p><ol class=""><li id="e3ac" class="mt mu hi kf b kg mj kj mk jr mv jv mw jz mx kv my mz na nb bi translated">开发者可以先定义<em class="kx">原语</em>成员(为了效率— <a class="ae kw" href="https://stackoverflow.com/questions/1162583/optimizing-equals-method" rel="noopener ugc nofollow" target="_blank">早破</a>)。</li><li id="8951" class="mt mu hi kf b kg nc kj nd jr ne jv nf jz ng kv my mz na nb bi translated">开发人员可能会省略不应该影响重新<em class="kx">渲染</em>的成员。<br/>例如，如果某些<em class="kx">属性</em>包含回调(例如<em class="kx">按钮组件</em>的“onClick”)，最好不要重新<em class="kx">渲染</em>，以防提供新的回调——因为这不会影响UI。<br/>另一个例子是，如果你的<em class="kx">组件</em>呈现一些<em class="kx">数据</em>模型(例如一部<em class="kx">网飞</em>电影)，你可能会认为这些数据在应用程序会话的过程中不会改变——只返回电影的“id”——不需要深入检查整个<em class="kx">网飞</em>电影<em class="kx">数据</em>的<em class="kx">相等性</em>。超级高效。</li></ol><p id="056f" class="pw-post-body-paragraph kd ke hi kf b kg mj is ki kj mk iv kl jr mm kn ko jv mo kq kr jz mq kt ku kv hb bi translated">因此，每次(非第一次)调用<code class="du nh ni nj nk b">onRender()</code>时，<code class="du nh ni nj nk b">onStandardRender()</code>检查<em class="kx">道具</em>之间的(特殊)<em class="kx">相等</em>，如果它们不同，<em class="kx">组件</em>【re】<em class="kx">渲染</em>。同样的逻辑也适用于<code class="du nh ni nj nk b">setState()</code> …</p><p id="be23" class="pw-post-body-paragraph kd ke hi kf b kg mj is ki kj mk iv kl jr mm kn ko jv mo kq kr jz mq kt ku kv hb bi translated">我们到此为止💪。<br/>让我们回顾一下整个<em class="kx">组件</em>的简化版本，以便了解:</p><figure class="kz la lb lc fd ld"><div class="bz dy l di"><div class="nl nm l"/></div><figcaption class="lk ll et er es lm ln bd b be z dx translated">组件的基本原理。简化。</figcaption></figure><p id="f134" class="pw-post-body-paragraph kd ke hi kf b kg mj is ki kj mk iv kl jr mm kn ko jv mo kq kr jz mq kt ku kv hb bi translated">这个，就在那里👆，是<em class="kx">反应过来</em>，在<em class="kx">科特林</em>🤘<em class="kx"> </em>🤓 🤘<em class="kx">。</em></p></div><div class="ab cl lo lp gp lq" role="separator"><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt"/></div><div class="hb hc hd he hf"><h2 id="e3bd" class="jg jh hi bd ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc ho bi translated">定制组件</h2><p id="7185" class="pw-post-body-paragraph kd ke hi kf b kg kh is ki kj kk iv kl jr km kn ko jv kp kq kr jz ks kt ku kv hb bi translated">在结束本文之前，让我们定义我们的第一个定制组件<em class="kx">和它的<em class="kx">道具</em>😎。</em></p><p id="47f2" class="pw-post-body-paragraph kd ke hi kf b kg mj is ki kj mk iv kl jr mm kn ko jv mo kq kr jz mq kt ku kv hb bi translated">下面是一个简单的<em class="kx">按钮组件</em>:</p><figure class="kz la lb lc fd ld"><div class="bz dy l di"><div class="nl nm l"/></div><figcaption class="lk ll et er es lm ln bd b be z dx translated">一个简单的自定义按钮组件</figcaption></figure><p id="6b4c" class="pw-post-body-paragraph kd ke hi kf b kg mj is ki kj mk iv kl jr mm kn ko jv mo kq kr jz mq kt ku kv hb bi translated">这有多简单？现在你可以用这个<em class="kx">组件</em>来包装<strong class="kf hs">任何</strong> <em class="kx">安卓</em> <em class="kx">按钮</em>，无论实际布局如何，并且有一个简洁的方式来控制它。在接下来的文章中，我们将会看到更复杂、更有趣的例子，来理解这种方法到底有多强大。</p><blockquote class="mg mh mi"><p id="06d3" class="kd ke kx kf b kg mj is ki kj mk iv kl ml mm kn ko mn mo kq kr mp mq kt ku kv hb bi translated">注意:<code class="du nh ni nj nk b">EmptyState</code>只是<code class="du nh ni nj nk b">OwnState</code>的一个空实现(没有成员)。这仅仅意味着我们的<em class="hi">组件</em>没有使用它的<em class="hi">自身状态</em>。</p></blockquote></div><div class="ab cl lo lp gp lq" role="separator"><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt"/></div><div class="hb hc hd he hf"><h1 id="8027" class="lv jh hi bd ji lw lx ly jm lz ma mb jq ix mc iy ju ja md jb jy jd me je kc mf bi translated">摘要</h1><p id="70e0" class="pw-post-body-paragraph kd ke hi kf b kg kh is ki kj kk iv kl jr km kn ko jv kp kq kr jz ks kt ku kv hb bi translated">在本文中，我们学习了<em class="kx">如何在<em class="kx"> Kotlin </em>中</em>实现<em class="kx"> React </em>式的架构。虽然还有更多细节，但它基本上是如何构建的<a class="ae kw" href="https://github.com/GuyMichael/Reactdroid" rel="noopener ugc nofollow" target="_blank"> <em class="kx"> Reactdroid </em> </a>并且它允许创建可预测、高效和简洁的UI，非常快。<br/> <a class="ae kw" href="https://gguymi.medium.com/44c3c2810f52" rel="noopener">下一篇文章</a>将教你如何创建一个<em class="kx"> Redux </em>般的架构(也是<a class="ae kw" href="https://github.com/GuyMichael/Reactdroid" rel="noopener ugc nofollow" target="_blank"> <em class="kx"> Reactdroid </em> </a>的一部分)。接下来的文章将深入展示一些很酷的例子。<br/> <a class="ae kw" href="https://gguymi.medium.com/44c3c2810f52" rel="noopener">那里见</a>👋。</p></div></div>    
</body>
</html>