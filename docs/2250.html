<html>
<head>
<title>Dealing with Asynchronous Requests on APIs</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">处理 API 上的异步请求</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/dealing-with-asynchronous-requests-on-apis-4439cbeaaeb?source=collection_archive---------8-----------------------#2021-04-28">https://medium.com/nerd-for-tech/dealing-with-asynchronous-requests-on-apis-4439cbeaaeb?source=collection_archive---------8-----------------------#2021-04-28</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/60aa66a14149ea4dbb661a4435ed5ebb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*5-Xpc3TYuoCnlk3_"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">丹·伯顿在<a class="ae iu" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="10fc" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">当开发一个 API 时，有时你的服务可能依赖于提供者，即第三方服务，来执行某种行为。</p><p id="f781" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">您可能面临的一个问题是，是否存在<em class="jt">异步请求</em>，以及您应该如何处理它们。</p><p id="18de" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这里我将提到:</p><ul class=""><li id="ca66" class="ju jv hi ix b iy iz jc jd jg jw jk jx jo jy js jz ka kb kc bi translated"><em class="jt">同步请求</em>—当你的 API 在请求结束时收到最终的回答；</li><li id="ca34" class="ju jv hi ix b iy kd jc ke jg kf jk kg jo kh js jz ka kb kc bi translated"><em class="jt">异步请求</em> —当你的 API 通过对你的 API 的请求，即通知，收到最终的回答时；</li></ul><h1 id="2d93" class="ki kj hi bd kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf bi translated">同步请求</h1><p id="ef6b" class="pw-post-body-paragraph iv iw hi ix b iy lg ja jb jc lh je jf jg li ji jj jk lj jm jn jo lk jq jr js hb bi translated">最常见的情况是，当联系一个 API 时，客户端会收到对其请求的最终答复。这意味着在相同的连接中，您将收到一个答案。</p><figure class="lm ln lo lp fd ij er es paragraph-image"><div class="er es ll"><img src="../Images/ea85d3da3cdbbd7b6164c9ff27ca3f2d.png" data-original-src="https://miro.medium.com/v2/resize:fit:776/format:webp/1*eqcaj-rh0Ay7STuWmMNIYA.png"/></div></figure><p id="668d" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如果由于任何原因，您的请求由于可用性问题而失败，您可以稍后重试相同的请求。希望在重试时，提供商的服务将是可用的。</p><h1 id="9ec5" class="ki kj hi bd kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf bi translated">异步请求</h1><p id="4245" class="pw-post-body-paragraph iv iw hi ix b iy lg ja jb jc lh je jf jg li ji jj jk lj jm jn jo lk jq jr js hb bi translated">有时，提供者的服务依赖于行为，由于依赖性或其他因素，<strong class="ix hj">可能会</strong>花费比预期更多的时间或精力。为了确保较短的响应时间，服务分为两部分:</p><ol class=""><li id="5f1f" class="ju jv hi ix b iy iz jc jd jg jw jk jx jo jy js lq ka kb kc bi translated">提供者启动请求并返回状态；</li><li id="4c64" class="ju jv hi ix b iy kd jc ke jg kf jk kg jo kh js lq ka kb kc bi translated">提供者继续计算请求，并通过将最终结果通知给客户端 API 来结束；</li></ol><figure class="lm ln lo lp fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lr"><img src="../Images/8becf84aedfff3d8daea69e3d14b818a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1202/format:webp/1*jRV9hwXumGGZds17DvUJ4Q.png"/></div></div></figure><p id="9c4c" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">当您有这种行为时，数据首先处于<em class="jt">“已创建”</em>，只有在收到“通知”请求后，它才会转换到<em class="jt">“完成”</em>。</p><p id="d569" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这意味着数据需要在两个请求之间持久化，这意味着在第一个请求之后，API 不能返回正确的结果<em class="jt">(为了简单起见，我们将忽略 API 客户端的可能性)</em>。</p><p id="80ba" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">有了这个通知，API 将能够继续工作。以回答提供商结束。</p><p id="52c2" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">但是</strong>，如果“通知”服务工作复杂，可能会失败怎么办？如果它需要很长的时间间隔来完成它的工作呢？</p><p id="42a8" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">当 API 正在处理通知服务时，我们希望提供者等待吗？还是可以在特定的时刻释放？</p><p id="3cbf" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">一种方法是将“通知”服务分成两部分:</p><ul class=""><li id="bc1b" class="ju jv hi ix b iy iz jc jd jg jw jk jx jo jy js jz ka kb kc bi translated"><em class="jt">准备</em> —服务准备计算，之后提供者可以被释放，计算可以开始；</li><li id="436a" class="ju jv hi ix b iy kd jc ke jg kf jk kg jo kh js jz ka kb kc bi translated"><em class="jt">计算</em> —完成异步请求的逻辑；</li></ul><figure class="lm ln lo lp fd ij er es paragraph-image"><div class="er es ls"><img src="../Images/b23e8bf826aa7306cbb15571a919c6ec.png" data-original-src="https://miro.medium.com/v2/resize:fit:1034/format:webp/1*IzpLG3__XT9Xmc1ekXek2g.png"/></div></figure><p id="1a80" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">通过这种方法，<em class="jt">准备</em>将产生一个答案，供提供商了解准备<em class="jt">计算</em>是否成功。</p><p id="3150" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">但是</strong>，万一失败了呢？</p><p id="eb1a" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">该逻辑可能在<em class="jt">准备</em>或<em class="jt">计算的两个瞬间失效。</em><em class="jt">准备</em>部分在成功保存“通知”上的答案时结束。此后，<em class="jt">计算</em>部分开始。</p><p id="621e" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">但是，如果由于任何原因 API 不能成功保存通知，那么这个逻辑将会中断，需要重新启动。</p><p id="cb0b" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">希望提供商重试“通知”请求</strong>。如果我们有任何类型的重试机制，它应该只表示对准备“通知”服务的必要计算的依赖。</p><figure class="lm ln lo lp fd ij er es paragraph-image"><div class="er es lt"><img src="../Images/a981bebcee5818af2ced8b90ad955b7f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1290/format:webp/1*5zybEYfRHingeXie2J2mkQ.png"/></div></figure><p id="c9ae" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">一种方法是使用 HTTP 状态作为一种方法来通知是否应该进行重试。在这种情况下，如果“通知”服务返回不同于 200 OK 的 HTTP 状态，则进行重试。</p><p id="4144" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">当提供者接收到不同于 200 OK 的 HTTP 状态时，它计划稍后重试“通知”请求。</p><p id="ba17" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在我们完成<em class="jt">后，准备</em>零件，没有失败，然后我们可以开始<em class="jt">计算</em>部分。这里也可能失败，但从这里开始，恢复并不意味着依赖于第三方，而是可以更容易地依靠资源的可用性来管理。</p><h1 id="0925" class="ki kj hi bd kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf bi translated">重新开始</h1><p id="6fc7" class="pw-post-body-paragraph iv iw hi ix b iy lg ja jb jc lh je jf jg li ji jj jk lj jm jn jo lk jq jr js hb bi translated">这里可以讨论的还有很多，所有这些都代表了一种处理<em class="jt">异步请求</em>的方法。</p><p id="3911" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">例如，我们没有详细说明<em class="jt">准备</em>在技术上代表什么，或者如何从<em class="jt">计算</em>的故障中恢复。根据你在做什么和你计划如何去做，这些会有很大的变化。</p><p id="5293" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">但在继续之前，我想以我认为是这篇文章的要点来结束:</p><ul class=""><li id="3c34" class="ju jv hi ix b iy iz jc jd jg jw jk jx jo jy js jz ka kb kc bi translated">依赖关系——总是尽可能快地移除依赖关系，以提高工作和资源的可管理性；</li><li id="925a" class="ju jv hi ix b iy kd jc ke jg kf jk kg jo kh js jz ka kb kc bi translated"><strong class="ix hj">恢复</strong> —准备重试机制；</li><li id="a7e6" class="ju jv hi ix b iy kd jc ke jg kf jk kg jo kh js jz ka kb kc bi translated"><strong class="ix hj">重试能力</strong> —规划恢复点，确保服务的幂等性和一致性；</li></ul><p id="8580" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我希望你能从这里得到一些关于如何处理异步请求的想法。</p></div></div>    
</body>
</html>