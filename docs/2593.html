<html>
<head>
<title>Java Threads From Zero To Hero</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Java线程从零到英雄</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/java-threads-from-zero-to-hero-4001da5d2727?source=collection_archive---------14-----------------------#2021-05-12">https://medium.com/nerd-for-tech/java-threads-from-zero-to-hero-4001da5d2727?source=collection_archive---------14-----------------------#2021-05-12</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/5104e4c90ff59acc7dc9fb572564d8ef.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5EA1SpejXGCnXQjpMIPovg.jpeg"/></div></div></figure><p id="278e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">什么是线程？</p><p id="c1ee" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">线程意味着执行的底线。那么多线程意味着多重执行层。</p><p id="03b9" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">多任务可以分为两种类型。</p><ol class=""><li id="0d2d" class="jo jp hi is b it iu ix iy jb jq jf jr jj js jn jt ju jv jw bi translated">基于流程</li><li id="4ea2" class="jo jp hi is b it jx ix jy jb jz jf ka jj kb jn jt ju jv jw bi translated">基于线程</li></ol><p id="da09" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">基于流程的</strong></p><p id="c820" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">举个例子，你边听音乐边输入一个word文档。所以如果你停止播放音乐，不会影响你打字。同样，如果您停止键入word文档，也不会影响您的音乐播放。想想你在下载电影的时候玩游戏。与上面的场景相同。都是相互独立的。</p><p id="9dae" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">螺纹基础</strong></p><p id="1f9a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在基于线程中，这些线程属于同一个项目或同一个主进程。操作系统将此视为一个进程。在这个过程中，我们将它分成多个任务。</p><figure class="kd ke kf kg fd ij er es paragraph-image"><div class="er es kc"><img src="../Images/c1d97055982be8b9b3841ef61b9208d0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1276/format:webp/1*3FhA4KYUmK3NhAzP3vMdtA.jpeg"/></div></figure></div><div class="ab cl kh ki gp kj" role="separator"><span class="kk bw bk kl km kn"/><span class="kk bw bk kl km kn"/><span class="kk bw bk kl km"/></div><div class="hb hc hd he hf"><h1 id="4f4a" class="ko kp hi bd kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll bi translated">线程生命周期</h1><figure class="kd ke kf kg fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lm"><img src="../Images/b43111b2516b2f08762c367578a9f560.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VN7__2PPEKHrELv8be6oxA.png"/></div></div></figure><h1 id="062a" class="ko kp hi bd kq kr ln kt ku kv lo kx ky kz lp lb lc ld lq lf lg lh lr lj lk ll bi translated">线程类的构造函数</h1><ol class=""><li id="7de0" class="jo jp hi is b it ls ix lt jb lu jf lv jj lw jn jt ju jv jw bi translated"><strong class="is hj">螺纹</strong>()</li><li id="96e1" class="jo jp hi is b it jx ix jy jb jz jf ka jj kb jn jt ju jv jw bi translated"><strong class="is hj">线程</strong>(字符串str)</li><li id="c6e7" class="jo jp hi is b it jx ix jy jb jz jf ka jj kb jn jt ju jv jw bi translated"><strong class="is hj">螺纹</strong>(可运行r)</li><li id="5b75" class="jo jp hi is b it jx ix jy jb jz jf ka jj kb jn jt ju jv jw bi translated"><strong class="is hj">线程</strong>(可运行r，字符串str)</li><li id="a4e4" class="jo jp hi is b it jx ix jy jb jz jf ka jj kb jn jt ju jv jw bi translated"><strong class="is hj">线程</strong> ( <strong class="is hj">线程组</strong>组，<strong class="is hj">可运行</strong>目标)</li><li id="64db" class="jo jp hi is b it jx ix jy jb jz jf ka jj kb jn jt ju jv jw bi translated"><strong class="is hj">线程</strong> ( <strong class="is hj">线程组</strong>组，<strong class="is hj">可运行</strong>目标，字符串名称)</li><li id="8e47" class="jo jp hi is b it jx ix jy jb jz jf ka jj kb jn jt ju jv jw bi translated"><strong class="is hj">线程</strong>(<strong class="is hj">Thread group</strong>group，<strong class="is hj"> Runnable </strong> target，String name，long stackSize)</li><li id="5c63" class="jo jp hi is b it jx ix jy jb jz jf ka jj kb jn jt ju jv jw bi translated"><strong class="is hj">线程</strong> ( <strong class="is hj">线程组</strong>组，<strong class="is hj">字符串</strong>名称)</li></ol></div><div class="ab cl kh ki gp kj" role="separator"><span class="kk bw bk kl km kn"/><span class="kk bw bk kl km kn"/><span class="kk bw bk kl km"/></div><div class="hb hc hd he hf"><h1 id="e309" class="ko kp hi bd kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll bi translated">如何在Java中创建线程</h1><p id="d20b" class="pw-post-body-paragraph iq ir hi is b it ls iv iw ix lt iz ja jb lx jd je jf ly jh ji jj lz jl jm jn hb bi translated">在java中有两种方法可以创建线程，</p><ol class=""><li id="e7b9" class="jo jp hi is b it iu ix iy jb jq jf jr jj js jn jt ju jv jw bi translated">扩展线程类</li><li id="5d15" class="jo jp hi is b it jx ix jy jb jz jf ka jj kb jn jt ju jv jw bi translated">实现可运行的接口</li></ol><p id="8cc2" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj"> 1。扩展线程类</strong></p><p id="e474" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们可以扩展Thread类，在run方法中，我们可以编写应该由线程完成的任务。</p><pre class="kd ke kf kg fd ma mb mc md aw me bi"><span id="2b03" class="mf kp hi mb b fi mg mh l mi mj">public class ChildThread extends Thread{<br/><br/>    @Override<br/>    public void run() {<br/>        //tasks to do by thread<br/>    }<br/>}</span></pre><p id="525a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">然后在我们的主类中，我们可以创建一个新的线程并启动它。</p><pre class="kd ke kf kg fd ma mb mc md aw me bi"><span id="47c5" class="mf kp hi mb b fi mg mh l mi mj">public class Main {<br/><br/>    public static void main(String[] args) {<br/><br/>        ChildThread thread1 =new ChildThread();<br/>        thread1.start();<br/>        System.<em class="mk">out</em>.println("I'm Main Thread");<br/>    }<br/>}</span></pre><p id="c25e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">所以当我们这样做时，实际上是ChildThread类检查它是否包含任何start方法。然后，由于它不包含开始方法，它将转到线程类的父类，检查它是否包含开始方法。所以父类包含了start方法，在start方法中调用run方法。所以我们的ChildThread类检查我有没有run方法。然后是，因为它包含一个run方法，所以它将被执行。</p><p id="a9b1" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">当我们启动一个线程时，我们不能保证执行的顺序。当你启动一个线程时，它所做的是，如果它满足所有的要求，它将添加到你的线程调度器中。所以线程调度器如何工作完全取决于你的JVM。</p><p id="d4e4" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这里有一些令人困惑的地方。我把它作为问答格式放在下面</p><p id="781c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">必须覆盖run方法吗？</p><blockquote class="ml mm mn"><p id="bd43" class="iq ir mk is b it iu iv iw ix iy iz ja mo jc jd je mp jg jh ji mq jk jl jm jn hb bi translated">不，当我们使用线程类扩展时，不一定要覆盖Run方法。</p></blockquote><p id="402c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们可以调用run方法而不是start方法吗？</p><blockquote class="ml mm mn"><p id="1ea5" class="iq ir mk is b it iu iv iw ix iy iz ja mo jc jd je mp jg jh ji mq jk jl jm jn hb bi translated">是的，您可以调用run方法，但是这样您就没有机会创建新的线程了。这就像普通的方法调用。</p></blockquote><p id="f938" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">你能覆盖启动方法吗？</strong></p><blockquote class="ml mm mn"><p id="754f" class="iq ir mk is b it iu iv iw ix iy iz ja mo jc jd je mp jg jh ji mq jk jl jm jn hb bi translated">答案是肯定的，你可以重写start方法，但是它会阻止创建新的线程。</p></blockquote><p id="6f18" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">但是我们能在创建新线程的时候覆盖start方法吗？</strong></p><blockquote class="ml mm mn"><p id="b3e9" class="iq ir mk is b it iu iv iw ix iy iz ja mo jc jd je mp jg jh ji mq jk jl jm jn hb bi translated">是的，我们可以。我们只需将super.start()放在override start方法中，它就会完成这项工作。</p></blockquote><p id="1b14" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们可以重载run方法吗？</p><blockquote class="ml mm mn"><p id="30b4" class="iq ir mk is b it iu iv iw ix iy iz ja mo jc jd je mp jg jh ji mq jk jl jm jn hb bi translated">是的，我们可以重载run方法，但是线程类start方法总是不带参数地执行run方法。</p></blockquote><p id="4503" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj"> 2。实现可运行接口</strong></p><pre class="kd ke kf kg fd ma mb mc md aw me bi"><span id="51bd" class="mf kp hi mb b fi mg mh l mi mj">public class ChildThread implements Runnable{<br/><br/>    @Override<br/>    public void run() {<br/>        //tasks to do by thread<br/>    }<br/>}</span></pre><p id="3cd6" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">当我们使用Runnable接口实现时，必须覆盖run方法。同样，当我们实现Runnable接口时，我们不能像在Extend中那样在main类中创建线程并启动线程。因为没有开始方法。<strong class="is hj">所以在这里我们必须从Thread类创建一个实例(对象),并且必须将runnable接口传递给它。然后只有我们可以开始线程。</strong></p><pre class="kd ke kf kg fd ma mb mc md aw me bi"><span id="b465" class="mf kp hi mb b fi mg mh l mi mj">public class Main {<br/><br/>    public static void main(String[] args) {<br/><br/>        ChildThread thread1 =new ChildThread();<br/>        Thread t1=new Thread(thread1);<br/>        t1.start();<br/>        System.<em class="mk">out</em>.println("I'm Main Thread");<br/>    }<br/>}</span></pre></div><div class="ab cl kh ki gp kj" role="separator"><span class="kk bw bk kl km kn"/><span class="kk bw bk kl km kn"/><span class="kk bw bk kl km"/></div><div class="hb hc hd he hf"><h1 id="04a3" class="ko kp hi bd kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll bi translated">何时使用Extend和Runnabale</h1><p id="1d65" class="pw-post-body-paragraph iq ir hi is b it ls iv iw ix lt iz ja jb lx jd je jf ly jh ji jj lz jl jm jn hb bi translated">正如我在上面提到的，大多数人知道有两种方法可以创建线程，但是大多数人不知道什么时候使用从线程类扩展和实现Runnable接口。所以简单地说，如果你和下面的类有任何关系，那么你应该创建实现Runnable接口的线程。因为从线程类扩展会打破那些关系。</p><figure class="kd ke kf kg fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/bacc79f5867834fa5323a2b75d7b0c4c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Q7V-_LUySVdvF440hTm80w.jpeg"/></div></div></figure><p id="bcda" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如果类之间没有任何关系，那么可以创建扩展Thread类的线程或者实现Runnable接口。由你决定。</p><h1 id="abe5" class="ko kp hi bd kq kr ln kt ku kv lo kx ky kz lp lb lc ld lq lf lg lh lr lj lk ll bi translated">守护线程</h1><p id="18ac" class="pw-post-body-paragraph iq ir hi is b it ls iv iw ix lt iz ja jb lx jd je jf ly jh ji jj lz jl jm jn hb bi translated">守护线程是一个<strong class="is hj">低优先级线程，在后台</strong>运行，执行垃圾收集等任务。java.lang.Thread类为java守护进程线程提供了两种方法。</p><pre class="kd ke kf kg fd ma mb mc md aw me bi"><span id="52fd" class="mf kp hi mb b fi mg mh l mi mj">public final void setDaemon(boolean on)<br/>public final boolean isDaemon()</span></pre><p id="27a6" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">大多数人认为，当你的主线程终止你的java程序时，你的Java程序也终止了。这是完全错误的，因为主线程可能完成了它的工作，但它允许子线程继续它的工作。但是如果一个子线程是一个守护线程，当主线程结束的时候，这个子线程(守护子线程)也会被终止。</p><p id="164b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">简单地说，当所有非守护线程都被执行时，程序终止。如果你的子线程是一个守护线程，那么主线程不会等到子线程完成它的工作。</p><h1 id="1378" class="ko kp hi bd kq kr ln kt ku kv lo kx ky kz lp lb lc ld lq lf lg lh lr lj lk ll bi translated">线程优先级</h1><p id="a318" class="pw-post-body-paragraph iq ir hi is b it ls iv iw ix lt iz ja jb lx jd je jf ly jh ji jj lz jl jm jn hb bi translated">线程优先级不是索引。线程优先级总是从1开始，以10结束。</p><p id="66b3" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">1=最低优先级</p><p id="71cb" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">10 =最高优先级</p><p id="7252" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们可以设置一个线程优先级，并从下面的方法中得到一个线程优先级。</p><pre class="kd ke kf kg fd ma mb mc md aw me bi"><span id="2231" class="mf kp hi mb b fi mg mh l mi mj">public final void setPriority(int newPriority)<br/>public final int getPriority()</span></pre><p id="86bd" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">例子</p><pre class="kd ke kf kg fd ma mb mc md aw me bi"><span id="be41" class="mf kp hi mb b fi mg mh l mi mj">ChildThread thread1 =new ChildThread();<br/>Thread t1=new Thread(thread1);<br/>t1.start();<br/>t1.setPriority(7);<br/>System.<em class="mk">out</em>.println(t1.getPriority());</span></pre><p id="0f0d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在任何应用程序中<strong class="is hj">主线程的默认优先级是5 </strong>。因为没有人在创建那个线程，只有系统在创建主线程。<strong class="is hj">在你创建的任何线程之后，它都会继承父线程的优先级值</strong></p><figure class="kd ke kf kg fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mr"><img src="../Images/0265f69bad3e3aaae2fe136c66f4896a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KLiTggg-sor8P_-lcDk6Tw.png"/></div></div></figure><p id="7c8f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">这是另一个令人困惑地方，因为线程优先级从1开始，从10结束，如果你给的优先级值超过了这个限制会发生什么呢？</strong></p><blockquote class="ml mm mn"><p id="7dcb" class="iq ir mk is b it iu iv iw ix iy iz ja mo jc jd je mp jg jh ji mq jk jl jm jn hb bi translated">简单地回答这个问题，它将抛出一个异常，称为非法参数异常</p></blockquote></div><div class="ab cl kh ki gp kj" role="separator"><span class="kk bw bk kl km kn"/><span class="kk bw bk kl km kn"/><span class="kk bw bk kl km"/></div><div class="hb hc hd he hf"><h1 id="3e78" class="ko kp hi bd kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll bi translated">线程中使用的方法(加入、睡眠、让步、中断)</h1><h2 id="5680" class="mf kp hi bd kq ms mt mu ku mv mw mx ky jb my mz lc jf na nb lg jj nc nd lk ne bi translated"><strong class="ak"> 1。Join() </strong></h2><p id="b4be" class="pw-post-body-paragraph iq ir hi is b it ls iv iw ix lt iz ja jb lx jd je jf ly jh ji jj lz jl jm jn hb bi translated">join方法允许一个线程等待另一个线程完成它的执行</p><div class="kd ke kf kg fd ab cb"><figure class="nf ij ng nh ni nj nk paragraph-image"><img src="../Images/b73510795e3909ed5d599e0a52beb8e4.png" data-original-src="https://miro.medium.com/v2/resize:fit:746/format:webp/1*BOYYHIakONI6tGWXOpk-ew.png"/></figure><figure class="nf ij nl nh ni nj nk paragraph-image"><img src="../Images/f1f809268298f428c3c876c54b435bdb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1032/format:webp/1*Q0lAfNHKMLPhhEE8nNV33w.png"/></figure></div><p id="be09" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">螺纹连接有三种方法。</p><pre class="kd ke kf kg fd ma mb mc md aw me bi"><span id="6191" class="mf kp hi mb b fi mg mh l mi mj">public final void join()<br/>public final synchronized void join(long millis)<br/>public final synchronized void join(long millis, int nanos)</span></pre><h2 id="7a58" class="mf kp hi bd kq ms mt mu ku mv mw mx ky jb my mz lc jf na nb lg jj nc nd lk ne bi translated">2.睡眠()</h2><p id="ccec" class="pw-post-body-paragraph iq ir hi is b it ls iv iw ix lt iz ja jb lx jd je jf ly jh ji jj lz jl jm jn hb bi translated">当我们使用sleep方法时，线程会在给定的时间内进入等待状态。睡觉有两种方法。</p><pre class="kd ke kf kg fd ma mb mc md aw me bi"><span id="d681" class="mf kp hi mb b fi mg mh l mi mj">public static void sleep(long milliseconds)<br/>public static void sleep(long milliseconds, int nanoseconds)</span></pre><p id="31b1" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj"> sleep(long毫秒)</strong>方法让一个线程只休眠特定的毫秒。</p><p id="646c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj"> sleep(long毫秒，int纳秒)</strong>方法让一个线程休眠几个特定的毫秒加纳秒。</p><h2 id="36ec" class="mf kp hi bd kq ms mt mu ku mv mw mx ky jb my mz lc jf na nb lg jj nc nd lk ne bi translated">3.中断()</h2><p id="63ba" class="pw-post-body-paragraph iq ir hi is b it ls iv iw ix lt iz ja jb lx jd je jf ly jh ji jj lz jl jm jn hb bi translated">thread类的interrupt()方法用于中断线程。如果有任何线程处于休眠或等待状态(即调用了sleep()或wait()，那么使用interrupt()方法，我们可以通过抛出InterruptedException来中断线程执行。</p><h2 id="4cd1" class="mf kp hi bd kq ms mt mu ku mv mw mx ky jb my mz lc jf na nb lg jj nc nd lk ne bi translated">4.产量()</h2><p id="c812" class="pw-post-body-paragraph iq ir hi is b it ls iv iw ix lt iz ja jb lx jd je jf ly jh ji jj lz jl jm jn hb bi translated">每当线程调用yield方法时，它都会向线程调度器发出提示/信号，表明它准备暂停执行。所以当前正在执行的线程将会停止，给其他等待的线程一个机会。</p><h1 id="3227" class="ko kp hi bd kq kr ln kt ku kv lo kx ky kz lp lb lc ld lq lf lg lh lr lj lk ll bi translated">线程同步</h1><p id="8665" class="pw-post-body-paragraph iq ir hi is b it ls iv iw ix lt iz ja jb lx jd je jf ly jh ji jj lz jl jm jn hb bi translated">多线程程序经常会遇到这样的情况:多个线程试图访问相同的资源，最终产生错误的和不可预见的结果。有两种类型的线程同步。</p><ol class=""><li id="59d6" class="jo jp hi is b it iu ix iy jb jq jf jr jj js jn jt ju jv jw bi translated">互斥的</li><li id="95da" class="jo jp hi is b it jx ix jy jb jz jf ka jj kb jn jt ju jv jw bi translated">协作(java中的线程间通信)</li></ol><p id="60f0" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">由于这篇博客几乎很长，包含了关于Java线程的大部分信息，我将另外发表一篇关于线程同步的博客。所以保持联系。</p></div><div class="ab cl kh ki gp kj" role="separator"><span class="kk bw bk kl km kn"/><span class="kk bw bk kl km kn"/><span class="kk bw bk kl km"/></div><div class="hb hc hd he hf"><h1 id="a788" class="ko kp hi bd kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll bi translated">参考</h1><p id="30db" class="pw-post-body-paragraph iq ir hi is b it ls iv iw ix lt iz ja jb lx jd je jf ly jh ji jj lz jl jm jn hb bi translated">由Krishantha Dinesh制作的Java视频系列中的线程。</p><figure class="kd ke kf kg fd ij"><div class="bz dy l di"><div class="nm nn l"/></div></figure><div class="no np ez fb nq nr"><a href="https://www.tutorialspoint.com/what-is-the-use-of-thread-sleep-method-in-java" rel="noopener  ugc nofollow" target="_blank"><div class="ns ab dw"><div class="nt ab nu cl cj nv"><h2 class="bd hj fi z dy nw ea eb nx ed ef hh bi translated">Java中的Thread.sleep()方法有什么用？</h2><div class="ny l"><h3 class="bd b fi z dy nw ea eb nx ed ef dx translated">sleep()方法是线程类的一个静态方法，它让线程休眠/停止工作一段特定的时间…</h3></div><div class="nz l"><p class="bd b fp z dy nw ea eb nx ed ef dx translated">www.tutorialspoint.com</p></div></div><div class="oa l"><div class="ob l oc od oe oa of io nr"/></div></div></a></div><div class="no np ez fb nq nr"><a href="https://www.geeksforgeeks.org/joining-threads-in-java/" rel="noopener  ugc nofollow" target="_blank"><div class="ns ab dw"><div class="nt ab nu cl cj nv"><h2 class="bd hj fi z dy nw ea eb nx ed ef hh bi translated">在Java中连接线程</h2><div class="ny l"><h3 class="bd b fi z dy nw ea eb nx ed ef dx translated">java.lang.Thread类提供join()方法，该方法允许一个线程等待另一个线程完成它的…</h3></div><div class="nz l"><p class="bd b fp z dy nw ea eb nx ed ef dx translated">www.geeksforgeeks.org</p></div></div><div class="oa l"><div class="og l oc od oe oa of io nr"/></div></div></a></div><div class="no np ez fb nq nr"><a href="https://www.javatpoint.com/daemon-thread" rel="noopener  ugc nofollow" target="_blank"><div class="ns ab dw"><div class="nt ab nu cl cj nv"><h2 class="bd hj fi z dy nw ea eb nx ed ef hh bi translated">Java-Java point中的守护线程</h2><div class="ny l"><h3 class="bd b fi z dy nw ea eb nx ed ef dx translated">java中的守护线程是一个服务提供者线程，为用户线程提供服务。它的生命依赖于…</h3></div><div class="nz l"><p class="bd b fp z dy nw ea eb nx ed ef dx translated">www.javatpoint.com</p></div></div></div></a></div></div></div>    
</body>
</html>