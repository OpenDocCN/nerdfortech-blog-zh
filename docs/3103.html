<html>
<head>
<title>Understand More By Thinking Less</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">少思考多理解</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/the-perils-of-knowledge-4548c4779f2?source=collection_archive---------23-----------------------#2021-05-29">https://medium.com/nerd-for-tech/the-perils-of-knowledge-4548c4779f2?source=collection_archive---------23-----------------------#2021-05-29</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/ef2f2cc9b3af3575ae3035f60a54c2c3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NjApQQCn14ShUk5YhWRgZA.jpeg"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">戴维·马托斯在<a class="ae iu" href="https://unsplash.com/?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="e8bb" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">据说“知识就是力量”。也有人说“权力容易腐败”。这些原则在我们的代码中是正确的，在生活中也是正确的。让我解释一下。</p><p id="fb9a" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">当我们在我们的代码库中工作时，我们倾向于一次在我们的头脑中拥有不同程度的应用程序逻辑。它帮助我们理解我们正在工作的系统的相关部分。这是好事。理解特性 A 的变化如何影响特性 b 对我们来说很重要。根据我们设计应用程序的方式，我们需要立刻记住或多或少的知识，以便提高工作效率。</p><p id="3975" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">然而，提高效率的诀窍是不要把更多的应用知识记在脑子里。诀窍是创建一个应用程序，它需要尽可能少的信息来让<em class="jt">需要</em>在某个时间被任何人记住，以便能够做他们需要做的事情。</p><p id="9653" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">对我来说，我发现在活动内存中保存大量的应用程序逻辑往往会导致我过度工程化。换句话说，虽然我可能会为一个巨大的思想宫殿而奋斗，但我喜欢保持思想宫殿里的桌子小而整洁；当我处理完信息后，在为下一个问题检索新的信息之前，重新整理信息。我们用一个词来形容编程中的这种行为。叫做<em class="jt">封装</em>。</p><h2 id="aae5" class="ju jv hi bd jw jx jy jz ka kb kc kd ke jg kf kg kh jk ki kj kk jo kl km kn ko bi translated">包装</h2><p id="71ab" class="pw-post-body-paragraph iv iw hi ix b iy kp ja jb jc kq je jf jg kr ji jj jk ks jm jn jo kt jq jr js hb bi translated"><a class="ae iu" href="https://en.wikipedia.org/wiki/Encapsulation_(computer_programming)" rel="noopener ugc nofollow" target="_blank">封装</a>是指某些信息完全包含在某些界限内。就像小胶囊里的药物。</p><p id="0855" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">为什么我们在编程中重视封装？并不是让计算机更好的理解。事实上，如果有的话，它可能会增加一定程度的执行开销，因为现在计算机必须创建更多的上下文和范围来表示这种封装。不，我们担心封装使<em class="jt">用户</em>更容易推理代码。是给下一个人的。限制事物范围的代码更容易推理。如果我们不让代码的其他部分访问某些信息或功能，代码就不需要在其逻辑中考虑这些信息或功能，我们也一样。</p><p id="2ba7" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">但是这个想法也可以反过来。比方说，我们需要验证某个用户的角色。假设他们需要成为贡献者，以便在系统中做一些特定的事情。我们可以像这样写一个验证函数:</p><pre class="ku kv kw kx fd ky kz la lb aw lc bi"><span id="03ef" class="ju jv hi kz b fi ld le l lf lg">const isContributor(user) =&gt; user.role === `contributor`</span></pre><p id="3e2b" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这是非常正常和常见的做法。但是这也鼓励了作用域随着时间的推移而蔓延，这样随着更多的手接触到代码库和需要更多的特性，<code class="du lh li lj kz b">isContributor</code>函数更有可能开始做其他的事情。</p><pre class="ku kv kw kx fd ky kz la lb aw lc bi"><span id="747f" class="ju jv hi kz b fi ld le l lf lg">const isContributor(user) =&gt; user.role === `contributor` || user.id === `0000001`</span></pre><p id="a8ab" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">现在，也许用户<code class="du lh li lj kz b">0000001</code>有一个合法的理由去做一个贡献者所做的一切，但是这个功能现在是一个谎言。它不再告诉我们一个给定的用户是否是一个贡献者，而是告诉我们他们是否是一个贡献者或者他们是否有这个非常特殊的 id。</p><blockquote class="lk ll lm"><p id="2640" class="iv iw jt ix b iy iz ja jb jc jd je jf ln jh ji jj lo jl jm jn lp jp jq jr js hb bi translated">但那只是糟糕的编程。做那种事的人是白痴。</p></blockquote><p id="a989" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><em class="jt"> —你，在你刚才的脑海里</em></p><p id="2541" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">嗯，这有点苛刻。诚然，这是糟糕的编程，但我已经经历了足够长的时间来理解给定的对(错？)激励，好的程序员往往写不好的代码。也许有一个严格的截止日期，也许是老板的 id，他们要求现在就能做一些事情。也许他们的祖母刚刚去世，他们的头脑没有 100%投入到工作中。真的不重要<em class="jt">为什么</em>它发生了。重要的是，它曾经发生过，现在也确实发生了。经常。我们应该问自己的问题是“我们如何减少像这样写代码的动机？”</p><p id="0b9d" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">为此，我们可以依靠一种叫做“最少知识原则”的东西，也称为“得墨忒耳定律”。</p><p id="be0e" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">最少知识原则是"<a class="ae iu" href="https://en.wikipedia.org/wiki/Law_of_Demeter" rel="noopener ugc nofollow" target="_blank">一个给定的对象应该尽可能少地假设任何其他东西(包括它的子组件)的结构或属性</a>"这实际上意味着一个函数或一个对象应该是它完成工作所需要的信息，而不是其他。那么我们前面的例子是如何违反这个原则的呢？</p><p id="8921" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在这种情况下，我们传递的是我们有时称之为“域对象”的东西，它是一个封装了(又是这个词)的对象🤔)单一概念；一个领域。在这种情况下，它是<code class="du lh li lj kz b">user</code>域。有时这些也被称为“众所周知的对象”。在我们的应用程序的上下文中，一个<code class="du lh li lj kz b">user</code>的概念以及它所包含的所有属性和方法是一个贯穿整个应用程序的概念。这样做的理由是，我们可以使用知识和信息共享来更快地构建我们的应用程序。</p><p id="1f08" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这个逻辑有些错误。例如，生产率的提高随着领域的不稳定性而降低。如果域对象的结构随着时间的推移相对固定，那么会有有意义的生产率提高。但是如果领域是不稳定的，如果我们发现我们需要相当有规律地改变属性或方法，生产力会迅速下降。尤其是如果域对象被广泛使用且高度不稳定。根据我的经验，我们经常低估我们的领域模型的易变性，它们往往比我们认为的更频繁地变化。所以我发现域对象经常是大型合并请求的根本原因，因为对这些域对象的更改会辐射到依赖它们的应用程序的每个部分。</p><p id="8422" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">为了解决这个问题，我们可以调整我们的函数，使其只接受完成设计任务所需的信息。</p><pre class="ku kv kw kx fd ky kz la lb aw lc bi"><span id="05ba" class="ju jv hi kz b fi ld le l lf lg">const isContributor(role) =&gt; role === `contributor`</span></pre><p id="c9f9" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们不是接受一个有很多属性的对象，其中一个属性是<code class="du lh li lj kz b">role</code>，而是简单地从对象传入<code class="du lh li lj kz b">role</code>的值。</p><p id="aee1" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这看起来很小，也许无关紧要，但是请回想一下我们之前的例子。当我们传入整个用户对象时，扩大函数作用范围的诱惑是很大的。毕竟，我们已经在传递对象了，只是提取另一个属性又有什么坏处呢？</p><p id="34d3" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">毫无疑问，这是一个简单的改变<em class="jt">现在</em>。但是我们摆脱了清晰和决定论。错误经常是由于开发人员的错误假设而引入的。增加假设发生的表面积必然会增加坏假设发生的表面积。</p><p id="3588" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这里有一个最近发生在我身上的真实用例。我重构了一些代码来适应一个新的特性，无意中引入了一个 bug(别担心，我在它进入生产之前就发现了它😅).注意，它甚至有静态类型。理论上，这应该被编译器捕捉到。我不完全确定为什么没被抓到，但确实没有。</p><pre class="ku kv kw kx fd ky kz la lb aw lc bi"><span id="d403" class="ju jv hi kz b fi ld le l lf lg">const hasError = (message: MESSAGE_TYPE): boolean =&gt; (<br/>  message.status === UNKNOWN_ERROR ||<br/>  message.status === UNKNOWN_STATUS ||<br/>  message.status === ERROR<br/>)</span></pre><p id="afe0" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这段代码失败了，因为<code class="du lh li lj kz b">message</code>以<code class="du lh li lj kz b">undefined</code>的形式出现，导致应用程序抛出一个巨大的空白屏幕。编译器没有发现这一点，但是应用最少知识原则可以防止抛出错误。</p><pre class="ku kv kw kx fd ky kz la lb aw lc bi"><span id="9f8e" class="ju jv hi kz b fi ld le l lf lg">const hasError = (messageStatus: MESSAGE_STATUS_ENUM): boolean =&gt; (<br/>  messageStatus === UNKNOWN_ERROR ||<br/>  messageStatus === UNKNOWN_STATUS ||<br/>  messageStatus === ERROR<br/>)</span></pre><p id="27ce" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们可以更进一步，减少一点点 bug 的表面积，同时也更加明确我们的意图是什么:</p><pre class="ku kv kw kx fd ky kz la lb aw lc bi"><span id="b37a" class="ju jv hi kz b fi ld le l lf lg">const hasError = (messageStatus: MessageStatusEnum) =&gt;<br/>  [UNKNOWN_ERROR, UNKNOWN_STATUS, ERROR].includes(messageStatus)</span></pre><p id="4143" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如果你想消除很多 bug 爬进来的机会，让你的代码库对很多人更有弹性，并帮助 JR 工程师或新员工更快地变得有生产力，实践最少知识原则。在需要知道的基础上制作您的数据。如果函数不需要知道，就不要给它。这是一件小事，有时会以意想不到的方式带来回报。</p><p id="52f6" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">关于这一点还有很多可以说的，但我们将开始进入整个事情。我认为现在最好把它留在这里。只要记住。当在整个应用程序中传播关于应用程序假设时，随着业务需求的变化，不仅会使更改这些假设变得更加困难，从某种意义上说，还会使应用程序具有自我意识，我们都知道这种情况会如何发展。</p><figure class="ku kv kw kx fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lq"><img src="../Images/a761a8deb96ba9945b4f44ea8f73104f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nOfhB6B-vVbbJnD-sI_t5Q.jpeg"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">终结者</figcaption></figure></div></div>    
</body>
</html>