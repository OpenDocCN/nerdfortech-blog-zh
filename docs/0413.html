<html>
<head>
<title>Ruby’s Self-Consciousness</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">露比的自我意识</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/rubys-self-consciousness-d8b6db3d2a40?source=collection_archive---------1-----------------------#2020-12-01">https://medium.com/nerd-for-tech/rubys-self-consciousness-d8b6db3d2a40?source=collection_archive---------1-----------------------#2020-12-01</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="7f2a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在你进一步阅读之前，不，这不是一个关于一个名叫鲁比的女孩的精神启蒙的故事。相反，我们将探索 Ruby 编程语言中的 <code class="du je jf jg jh b">self</code> <em class="jd">关键字，并理解它是如何被普遍使用的。</em></p><blockquote class="ji jj jk"><p id="1062" class="if ig jd ih b ii ij ik il im in io ip jl ir is it jm iv iw ix jn iz ja jb jc hb bi translated">红宝石&amp; <code class="du je jf jg jh b"><em class="hi">self</em></code></p></blockquote><p id="d077" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">根据定义，自我意识被描述为一种高度的自我意识(T21 意识)。在像 Ruby 这样的面向对象程序中，这句话再正确不过了。</p><p id="b7af" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">从字面上看，每个对象都是有自我意识的，并且可以在自身上操作方法。稍后会有更多的介绍，但首先是一个简短的历史。</p><blockquote class="ji jj jk"><p id="5fbd" class="if ig jd ih b ii ij ik il im in io ip jl ir is it jm iv iw ix jn iz ja jb jc hb bi translated">面向对象的起源</p></blockquote><p id="e783" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Simula 67 被广泛认为是第一种面向对象的编程语言。当它在 1967 年首次亮相时，它引入了对象、类、子类和许多其他概念，为今天使用的 OO 语言提供了框架。其中一个概念是创建一个关键字来显式引用本地对象；关键词是<code class="du je jf jg jh b">this</code>。</p><p id="8735" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">从那时起，编程语言不断进化和发展，但大多数仍然有一些关键字服务于相同的目的。在 Ruby 中是<code class="du je jf jg jh b">self</code>。</p><blockquote class="ji jj jk"><p id="c0bd" class="if ig jd ih b ii ij ik il im in io ip jl ir is it jm iv iw ix jn iz ja jb jc hb bi translated">什么是<code class="du je jf jg jh b">self</code>？</p></blockquote><p id="9e65" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在 Ruby 中，<code class="du je jf jg jh b">self</code>是一个关键字，用于访问与当前正在执行的代码<strong class="ih hj"><em class="jd"/></strong>相关联的对象——这意味着使用<code class="du je jf jg jh b">self</code>的上下文将决定该代码中的对象<code class="du je jf jg jh b">self</code>。</p><blockquote class="ji jj jk"><p id="c92a" class="if ig jd ih b ii ij ik il im in io ip jl ir is it jm iv iw ix jn iz ja jb jc hb bi translated">如何确定和使用<code class="du je jf jg jh b">self</code></p></blockquote><p id="6b24" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">要理解<code class="du je jf jg jh b">self</code>是什么，首先要看它使用的语境。它的使用有三个一般准则。</p><p id="6d3c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> 1。</strong>如果上下文在任何<code class="du je jf jg jh b">method</code> / <code class="du je jf jg jh b">class</code> / <code class="du je jf jg jh b">module</code>定义之外，<code class="du je jf jg jh b">self</code>始终代表<code class="du je jf jg jh b">main</code>。<code class="du je jf jg jh b">main</code>是直接内置到 Ruby 中的顶级对象。</p><figure class="jp jq jr js fd jt er es paragraph-image"><div role="button" tabindex="0" class="ju jv di jw bf jx"><div class="er es jo"><img src="../Images/4667f854196e81b0246a234563d52035.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EpkTWmMltaIj3GM0UIGidQ.png"/></div></div><figcaption class="ka kb et er es kc kd bd b be z dx translated">当<strong class="bd ke"> self </strong>在任何方法、类或模块之外使用时，Ruby 自动将<strong class="bd ke"> self </strong>解释为<strong class="bd ke"> main </strong>。</figcaption></figure><p id="043c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> 2。</strong>如果上下文在<code class="du je jf jg jh b">class</code> / <code class="du je jf jg jh b">module</code>定义<strong class="ih hj">内，并且</strong>在<code class="du je jf jg jh b">method</code>定义之外，<code class="du je jf jg jh b">self</code>表示具体的<code class="du je jf jg jh b">class</code> / <code class="du je jf jg jh b">module</code>本身。</p><figure class="jp jq jr js fd jt er es paragraph-image"><div role="button" tabindex="0" class="ju jv di jw bf jx"><div class="er es kf"><img src="../Images/b0b7a9d392bb70b701e027dd45a940dd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*R8YYOCf2CufGRnLiqD90YA.png"/></div></div><figcaption class="ka kb et er es kc kd bd b be z dx translated">Ruby 将<strong class="bd ke"> self </strong>解释为计算机类。</figcaption></figure><figure class="jp jq jr js fd jt er es paragraph-image"><div role="button" tabindex="0" class="ju jv di jw bf jx"><div class="er es kg"><img src="../Images/e0f664c717939a19bf0435d60cb01cce.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jZJ4aRn4jkDJSXh_OC16yA.png"/></div></div><figcaption class="ka kb et er es kc kd bd b be z dx translated">当在一个模块的上下文中使用<strong class="bd ke"> self </strong>时，<strong class="bd ke"> self </strong>代表模块本身。</figcaption></figure><p id="f7d4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在这个上下文中使用<code class="du je jf jg jh b">self</code>还提供了通过在类方法名前面加上<code class="du je jf jg jh b">self.</code>来构建类级方法的能力</p><figure class="jp jq jr js fd jt er es paragraph-image"><div role="button" tabindex="0" class="ju jv di jw bf jx"><div class="er es kf"><img src="../Images/ad3e834b680899f24be5ed5c7a4aa10b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kJCwj1VNxz-59wIMoCUM6Q.png"/></div></div><figcaption class="ka kb et er es kc kd bd b be z dx translated">这里的<code class="du je jf jg jh b"><strong class="bd ke">self</strong></code>相当于<code class="du je jf jg jh b"><strong class="bd ke">Computer</strong></code>，类名。</figcaption></figure><p id="5e10" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">3.最后，如果上下文在实例方法定义中，<code class="du je jf jg jh b">self</code>是方法的接收者。它将表示调用该方法的特定实例。</p><figure class="jp jq jr js fd jt er es paragraph-image"><div role="button" tabindex="0" class="ju jv di jw bf jx"><div class="er es kf"><img src="../Images/91015910c916ae36066b15d9a08b07a9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xrG6Oa-g0aYdLehf36t-qw.png"/></div></div><figcaption class="ka kb et er es kc kd bd b be z dx translated">在<strong class="bd ke"> change_name </strong>方法中，<strong class="bd ke"> self </strong>代表执行该方法时被调用的<strong class="bd ke"> Team </strong>实例。因此，当<strong class="bd ke">giants . change _ name(" Dolphins ")</strong>被执行时，我们调用<strong class="bd ke"> giants.name </strong>来等于<strong class="bd ke"> "Dolphins" </strong>的新参数。</figcaption></figure><blockquote class="ji jj jk"><p id="4dca" class="if ig jd ih b ii ij ik il im in io ip jl ir is it jm iv iw ix jn iz ja jb jc hb bi translated">隐式与显式<code class="du je jf jg jh b">self</code></p></blockquote><p id="1059" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">根据经验，当试图访问一个类、类方法或实例方法中的<code class="du je jf jg jh b">self</code>时，有一种东西被称为隐式自我。如果一个方法在没有显式 self 的情况下被调用(实际上在方法之前写出了<code class="du je jf jg jh b">self.</code>), Ruby 使用隐式 self，这是它对方法(如果之前定义的话)正在调用对象本身的理解。让我们在下面的例子中进一步探讨这一点。</p><figure class="jp jq jr js fd jt er es paragraph-image"><div role="button" tabindex="0" class="ju jv di jw bf jx"><div class="er es jo"><img src="../Images/d744f29d6f92ce2f3527de8d2f310c0b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_p1ZNZQTn9xjngE-_x2cyw.png"/></div></div><figcaption class="ka kb et er es kc kd bd b be z dx translated">在<strong class="bd ke"> full_name </strong>方法中，Ruby 使用隐式 self 对<strong class="bd ke"> first_name </strong>和<strong class="bd ke"> last_name </strong>进行字符串插值，因为它通过 attr_reader 宏识别这些方法。</figcaption></figure><p id="1bd9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Student#full_name 方法使用来自 Student#first_name 和 Student#last_name 的值，但不显式使用<code class="du je jf jg jh b">self.</code>，而是依赖于隐式 self 的值。</p><blockquote class="ji jj jk"><p id="bd8f" class="if ig jd ih b ii ij ik il im in io ip jl ir is it jm iv iw ix jn iz ja jb jc hb bi translated">最后</p></blockquote><p id="eeae" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Ruby 中的<code class="du je jf jg jh b">self</code>关键字是一个强大的工具，它允许开发者<strong class="ih hj"> <em class="jd">根据上下文</em> </strong>引用一个特定的对象。当试图弄清楚<code class="du je jf jg jh b">self</code>在你的代码中是什么或者将会是什么时，试着记住关于上下文的一般准则，并问自己:“在这个特定的用法中，<code class="du je jf jg jh b">self</code>是谁？”</p><p id="9eed" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">有意识地理解如何使用<code class="du je jf jg jh b">self</code>将为阅读和编写 Ruby 代码提供坚实的基础。</p></div></div>    
</body>
</html>