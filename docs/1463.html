<html>
<head>
<title>Getting started with Kotlin</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Kotlin 入门</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/getting-started-with-kotlin-f78140a44b6f?source=collection_archive---------13-----------------------#2021-03-20">https://medium.com/nerd-for-tech/getting-started-with-kotlin-f78140a44b6f?source=collection_archive---------13-----------------------#2021-03-20</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/c9cf2a3b29a4cd54d660f7aff42974c5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kJS8ibbpYfrKlk7cMtaf3Q.jpeg"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">由<a class="ae iu" href="https://unsplash.com/@mikeshkaos?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Mikesh Kaos </a>在 Unsplash 上拍摄的照片</figcaption></figure><p id="415c" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这个博客主要是为打算开始学习科特林的初学者(当然像我一样)准备的。这不是一个项目或一个教程，而是我觉得我每天都需要的东西。所以不要再浪费时间了，让我们开始吧。</p></div><div class="ab cl jt ju gp jv" role="separator"><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy"/></div><div class="hb hc hd he hf"><h2 id="72c9" class="ka kb hi bd kc kd ke kf kg kh ki kj kk jg kl km kn jk ko kp kq jo kr ks kt ku bi translated">声明一个变量</h2><p id="d533" class="pw-post-body-paragraph iv iw hi ix b iy kv ja jb jc kw je jf jg kx ji jj jk ky jm jn jo kz jq jr js hb bi translated">变量可以分为两类</p><ol class=""><li id="b198" class="la lb hi ix b iy iz jc jd jg lc jk ld jo le js lf lg lh li bi translated">val:只读(不能修改)</li><li id="beb1" class="la lb hi ix b iy lj jc lk jg ll jk lm jo ln js lf lg lh li bi translated">var:声明为 var 的变量可以被重新分配和修改。</li></ol><p id="e673" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这里最好的部分是变量可以用任何类型赋值，可以是字符串也可以是整数。</p><p id="8ebb" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">所以在 kotlin 中声明一个变量很简单:</p><pre class="lo lp lq lr fd ls lt lu lv aw lw bi"><span id="5f1a" class="ka kb hi lt b fi lx ly l lz ma">var thisIsModifiable = 1<br/>val youCannotChangeMe = "abc"</span></pre><p id="f5c9" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">你可以在声明的时候定义变量的类型。在下面的例子中，我们明确提到变量的类型是整数，为此我们使用“:”</p><pre class="lo lp lq lr fd ls lt lu lv aw lw bi"><span id="4a83" class="ka kb hi lt b fi lx ly l lz ma">val thisIsInt: Int</span></pre><h2 id="49a1" class="ka kb hi bd kc kd ke kf kg kh ki kj kk jg kl km kn jk ko kp kq jo kr ks kt ku bi translated">条件语句</h2><p id="ac0d" class="pw-post-body-paragraph iv iw hi ix b iy kv ja jb jc kw je jf jg kx ji jj jk ky jm jn jo kz jq jr js hb bi translated">否则:</p><pre class="lo lp lq lr fd ls lt lu lv aw lw bi"><span id="a5a9" class="ka kb hi lt b fi lx ly l lz ma">if (condition) { <br/>    println("Inside if") <br/>} else if (condition) { <br/>    println("Inside else if") <br/>} else {<br/>    println("Inside else")<br/>}</span></pre><p id="675d" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">when:这类似于 c 中的<code class="du mb mc md lt b">switch</code>语句。</p><pre class="lo lp lq lr fd ls lt lu lv aw lw bi"><span id="3d51" class="ka kb hi lt b fi lx ly l lz ma">when(x) {<br/>    1 -&gt; println("x is 1")<br/>    2 -&gt; println("x is 2")<br/> else -&gt; println("Neither 1 or 2")<br/>}</span></pre><h2 id="2c2b" class="ka kb hi bd kc kd ke kf kg kh ki kj kk jg kl km kn jk ko kp kq jo kr ks kt ku bi translated">数组、列表、集合和映射</h2><ul class=""><li id="36ab" class="la lb hi ix b iy kv jc kw jg me jk mf jo mg js mh lg lh li bi translated">Kotlin 中的<em class="mi">数组</em>由<code class="du mb mc md lt b">Array</code>类表示。它们是<em class="mi">不变量</em>。这意味着 Kotlin 不允许我们将一个<code class="du mb mc md lt b">Array&lt;String&gt;</code>赋值给一个<code class="du mb mc md lt b">Array&lt;Any&gt;</code>，这可以防止可能的运行时故障</li></ul><pre class="lo lp lq lr fd ls lt lu lv aw lw bi"><span id="48d9" class="ka kb hi lt b fi lx ly l lz ma">val hellos = arrayOf("hi", "hello", "hola", "hello")<br/>// [hi, hello, hola, hello]</span></pre><p id="a4a7" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">Kotlin 也有表示原始类型数组的类，没有装箱开销:<code class="du mb mc md lt b">ByteArray</code>、<code class="du mb mc md lt b">ShortArray</code>、<code class="du mb mc md lt b">IntArray</code>。示例:</p><pre class="lo lp lq lr fd ls lt lu lv aw lw bi"><span id="4850" class="ka kb hi lt b fi lx ly l lz ma"><strong class="lt hj">val</strong> x: IntArray = intArrayOf(1, 2, 3)</span></pre><ul class=""><li id="e990" class="la lb hi ix b iy iz jc jd jg lc jk ld jo le js mh lg lh li bi translated"><em class="mi"> List </em>是一个有序集合，可以通过索引访问元素。元素可以在一个列表中出现多次。</li></ul><pre class="lo lp lq lr fd ls lt lu lv aw lw bi"><span id="800a" class="ka kb hi lt b fi lx ly l lz ma">val hellos = listOf("hi", "hello", "hola", "hello")<br/>// [hi, hello, hola, hello]</span></pre><ul class=""><li id="e813" class="la lb hi ix b iy iz jc jd jg lc jk ld jo le js mh lg lh li bi translated"><em class="mi">集合</em>是唯一元素的集合。</li></ul><pre class="lo lp lq lr fd ls lt lu lv aw lw bi"><span id="2c7c" class="ka kb hi lt b fi lx ly l lz ma">val hellos = setOf("hi", "hello", "hola", "hello")<br/>// [hi, hello, hola]</span></pre><ul class=""><li id="1782" class="la lb hi ix b iy iz jc jd jg lc jk ld jo le js mh lg lh li bi translated"><em class="mi"> Map </em>(或<em class="mi"> dictionary </em>)是一组键值对。键是唯一的，每个键映射到一个值。这些值可以重复。</li></ul><pre class="lo lp lq lr fd ls lt lu lv aw lw bi"><span id="3a0a" class="ka kb hi lt b fi lx ly l lz ma">val numbersMap = mapOf("key1" to 1, "key2" to 2, "key3" to 3, "key4" to 1)</span><span id="25dd" class="ka kb hi lt b fi mj ly l lz ma">println("All keys: ${numbersMap.keys}")  <br/>println("All values: ${numbersMap.values}")  </span><span id="00b4" class="ka kb hi lt b fi mj ly l lz ma">All keys: [key1, key2, key3, key4] <br/>All values: [1, 2, 3, 1]</span></pre><p id="9e5b" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">Kotlin 为每种集合类型提供了两个接口——只读的和可变的。注意，改变一个可变集合并不要求它是一个<code class="du mb mc md lt b"><a class="ae iu" href="https://kotlinlang.org/docs/basic-syntax.html#variables" rel="noopener ugc nofollow" target="_blank">var</a></code>:写操作修改同一个可变集合对象，所以引用不会改变。虽然，重新分配一个<code class="du mb mc md lt b">val</code>集合会给出一个编译错误。</p><h2 id="2d86" class="ka kb hi bd kc kd ke kf kg kh ki kj kk jg kl km kn jk ko kp kq jo kr ks kt ku bi translated">环</h2><p id="e224" class="pw-post-body-paragraph iv iw hi ix b iy kv ja jb jc kw je jf jg kx ji jj jk ky jm jn jo kz jq jr js hb bi translated">这可能是最重要的部分之一，因为我大部分时间都被困在这里😛</p><p id="9af5" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">For 循环:<code class="du mb mc md lt b">for</code>循环遍历任何提供迭代器的东西。</p><pre class="lo lp lq lr fd ls lt lu lv aw lw bi"><span id="2173" class="ka kb hi lt b fi lx ly l lz ma">val marks = listOf(1,2,3)<br/>for(mark in marks) {<br/>   println(mark)<br/>}</span></pre><p id="ae98" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">要使用列表的索引进行迭代，我们可以做如下工作:</p><pre class="lo lp lq lr fd ls lt lu lv aw lw bi"><span id="b3ca" class="ka kb hi lt b fi lx ly l lz ma">val marks = listOf(1,2,3)<br/>for(i in marks.indices) {<br/>   println(marks[i])<br/>}</span></pre><p id="dcd9" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">还有一种东西叫做<code class="du mb mc md lt b">forEach</code>。使用<code class="du mb mc md lt b">forEach</code>，我们可以简化循环逻辑。</p><pre class="lo lp lq lr fd ls lt lu lv aw lw bi"><span id="5916" class="ka kb hi lt b fi lx ly l lz ma">val marks = listOf(1,2,3)<br/>marks.forEach { mark -&gt;<br/>     println(mark)<br/>}</span></pre><h2 id="f0da" class="ka kb hi bd kc kd ke kf kg kh ki kj kk jg kl km kn jk ko kp kq jo kr ks kt ku bi translated">定义函数</h2><pre class="lo lp lq lr fd ls lt lu lv aw lw bi"><span id="e3d3" class="ka kb hi lt b fi lx ly l lz ma">fun myFirstFunction(x : Int, y: String) : Boolean {<br/>    var result = false<br/>    .... <br/>    return result <br/>}</span></pre><p id="22c1" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这里我们定义了一个名为<code class="du mb mc md lt b">myFirstFunction</code>的函数，有两个参数，一个整数和一个字符串。这有一个布尔返回类型。</p><p id="52c0" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">就是这样！这些只是你们所有人的几个起点。这肯定是不够的，但它会增强你的信心，帮助你学习科特林。快乐学习！:)</p></div></div>    
</body>
</html>