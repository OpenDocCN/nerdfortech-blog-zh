<html>
<head>
<title>Level Order Traversal — Daily Challenge May</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">等级顺序遍历—每日挑战可能</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/level-order-traversal-daily-challenge-may-1e5a2ce56a16?source=collection_archive---------28-----------------------#2021-05-20">https://medium.com/nerd-for-tech/level-order-traversal-daily-challenge-may-1e5a2ce56a16?source=collection_archive---------28-----------------------#2021-05-20</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><figure class="hh hi ez fb hj hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es hg"><img src="../Images/7f1c6416ef3b10be9002d6fe38a3b794.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oqSLv6FBDqmGqbT4rYU4Tg.jpeg"/></div></div><figcaption class="hr hs et er es ht hu bd b be z dx translated">由<a class="ae hv" href="https://unsplash.com/@caminouflet?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">卡米尔·米努夫莱特</a>在<a class="ae hv" href="https://unsplash.com/s/photos/stair?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄的照片</figcaption></figure><div class=""/><p id="6861" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">今天的问题来自每日Leetcode编码挑战赛——五月版。这是一个中等标签的问题。让我们看看问题陈述。</p><h2 id="1a21" class="jt ju hy bd jv jw jx jy jz ka kb kc kd jg ke kf kg jk kh ki kj jo kk kl km kn bi translated"><a class="ae hv" href="https://leetcode.com/problems/binary-tree-level-order-traversal/" rel="noopener ugc nofollow" target="_blank"> 102。</a>二叉树层次顺序遍历</h2><p id="0003" class="pw-post-body-paragraph iv iw hy ix b iy ko ja jb jc kp je jf jg kq ji jj jk kr jm jn jo ks jq jr js hb bi translated">给定二叉树的<code class="du kt ku kv kw b">root</code>，返回<em class="kx">其节点值</em>的层次顺序遍历。(即从左到右，逐层)。</p><h2 id="41e6" class="jt ju hy bd jv jw jx jy jz ka kb kc kd jg ke kf kg jk kh ki kj jo kk kl km kn bi translated">示例:</h2><pre class="ky kz la lb fd lc kw ld le aw lf bi"><span id="a73c" class="jt ju hy kw b fi lg lh l li lj"><strong class="kw hz">Input:</strong> root = [3,9,20,null,null,15,7]<br/><strong class="kw hz">Output:</strong> [[3],[9,20],[15,7]]</span></pre><h2 id="f692" class="jt ju hy bd jv jw jx jy jz ka kb kc kd jg ke kf kg jk kh ki kj jo kk kl km kn bi translated">理解问题:</h2><p id="8c8f" class="pw-post-body-paragraph iv iw hy ix b iy ko ja jb jc kp je jf jg kq ji jj jk kr jm jn jo ks jq jr js hb bi translated">等级顺序遍历类似于BFS。在进入下一个级别之前，我们处理一个级别的所有节点。换句话说，首先，我们覆盖所有祖父母，然后是所有父母，然后是所有子女。</p><figure class="ky kz la lb fd hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es lk"><img src="../Images/1d243599e0322ec2aa018c4f56d56645.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2GEDEG7awVlPHZXrSy2vkQ.png"/></div></div></figure><p id="b868" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">方法:</p><p id="aae2" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">将当前级别的所有元素添加到列表中<br/>获取上一步中元素的所有子元素<br/>将当前级别的元素设置到上一个列表中<br/>继续这样做，直到遍历完所有项目。</p><figure class="ky kz la lb fd hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es ll"><img src="../Images/0e5f65fd4585870d372fea0f6ee46c52.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gMYR5UCumBfbb7Tb7JixsA.png"/></div></div></figure><h2 id="ab84" class="jt ju hy bd jv jw jx jy jz ka kb kc kd jg ke kf kg jk kh ki kj jo kk kl km kn bi translated">代码实现:</h2><pre class="ky kz la lb fd lc kw ld le aw lf bi"><span id="fd06" class="jt ju hy kw b fi lg lh l li lj"># Definition for a binary tree node.<br/># class TreeNode:<br/>#     def __init__(self, val=0, left=None, right=None):<br/>#         self.val = val<br/>#         self.left = left<br/>#         self.right = right<br/>class Solution:<br/>    def levelOrder(self, root: TreeNode) -&gt; List[List[int]]:<br/>        queue = [root]<br/>        answer = []<br/>        <br/>        while queue:<br/>            temp = []<br/>            level = [ el.val for el in queue if el]<br/>            if level:<br/>                answer.append(level)<br/>                <br/>            for el in queue:<br/>                if el:<br/>                    if el.left != None:<br/>                        temp.append(el.left)<br/>                    if el.right != None:<br/>                        temp.append(el.right)<br/>            queue = temp<br/>    <br/>        return answer</span></pre><h1 id="45b7" class="lm ju hy bd jv ln lo lp jz lq lr ls kd lt lu lv kg lw lx ly kj lz ma mb km mc bi translated">复杂性分析:</h1><ul class=""><li id="a589" class="md me hy ix b iy ko jc kp jg mf jk mg jo mh js mi mj mk ml bi translated">时间复杂度:O(N)每个节点只处理一次。</li><li id="7235" class="md me hy ix b iy mm jc mn jg mo jk mp jo mq js mi mj mk ml bi translated">存储级别的空间复杂度:O(N)</li></ul><p id="a0e3" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">编码快乐！！</p></div></div>    
</body>
</html>