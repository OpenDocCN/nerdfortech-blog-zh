<html>
<head>
<title>Cross-Validation</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">交叉验证</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/cross-validation-6270341658ae?source=collection_archive---------11-----------------------#2021-07-01">https://medium.com/nerd-for-tech/cross-validation-6270341658ae?source=collection_archive---------11-----------------------#2021-07-01</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/852a8e931d8437b7f4b7b86c71103cb6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*zQlKOXU0f4MClKZR"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">照片由<a class="ae iu" href="https://unsplash.com/@flyd2069?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">飞:D </a>在<a class="ae iu" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a></figcaption></figure><p id="f960" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi jt translated"><span class="l ju jv jw bm jx jy jz ka kb di"> W </span>每当我们遇到机器学习问题或纸牌游戏比赛时，我们经常会困惑于我们应该使用哪种机器学习算法/模型，或者哪种算法/模型会给出最好的结果。我们需要验证我们的机器学习模型的稳定性，以便在部署后它能给出我们想要的输出。通常，它会在各种模型上迭代，以找到性能最佳的模型。然而，由于过拟合，选择模型所基于的精度可能在训练期间给出好的结果。在机器学习中，我们无法使模型适合训练数据，也无法假设它会准确地适用于真实世界的数据。为此，训练数据必须从没有噪声的数据中获取真实或正确的模式。在机器学习中，有一种重要的技术叫做<strong class="ix hj"> <em class="kc">交叉验证</em> </strong>，它不仅有助于选择正确的模型，还有助于选择模型的正确参数。</p><h1 id="a301" class="kd ke hi bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated"><strong class="ak"> Train_test_split Vs 交叉验证:</strong></h1><p id="ceb1" class="pw-post-body-paragraph iv iw hi ix b iy lb ja jb jc lc je jf jg ld ji jj jk le jm jn jo lf jq jr js hb bi translated"><strong class="ix hj">保持方法或验证集方法:</strong></p><p id="8fa9" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这是最常见和最简单的方法，我们随机保留一些数据用于训练，其余的用于测试目的。由于我们随机获取数据，因此在训练我们的模型时很可能会跳过可能包含重要信息的数据。让我们以一个名为“iris”的著名数据集为例。</p><p id="f4fe" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">加载所需的库和数据集。</p><pre class="lg lh li lj fd lk ll lm ln aw lo bi"><span id="af6a" class="lp ke hi ll b fi lq lr l ls lt">from sklearn import datasets<br/>import pandas as pd<br/>import numpy as np<br/>import matplotlib.pyplot as plt<br/>import seaborn as sns<br/>%matplotlib inline</span><span id="7fa7" class="lp ke hi ll b fi lu lr l ls lt">iris = datasets.load_iris()<br/>X = iris.data<br/>y = iris.target</span></pre><p id="db17" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">使用<strong class="ix hj"> train_test_split </strong>将自变量(X)和因变量(y)拆分为训练和测试数据集。</p><pre class="lg lh li lj fd lk ll lm ln aw lo bi"><span id="2a0e" class="lp ke hi ll b fi lq lr l ls lt">from sklearn.model_selection import train_test_split<br/>X_train, X_test, y_train, y_test = train_test_split(X, y, random_state=4)</span></pre><p id="bd07" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这里，我们使用<em class="kc"> random_state </em>随机选取数据用于训练和测试。接下来，我们用 k 近邻算法来计算模型的精度。</p><pre class="lg lh li lj fd lk ll lm ln aw lo bi"><span id="4281" class="lp ke hi ll b fi lq lr l ls lt">from sklearn.neighbors import KNeighborsClassifier<br/>from sklearn import metrics<br/>knn = KNeighborsClassifier(n_neighbors=5)<br/>knn.fit(X_train, y_train)<br/>y_pred = knn.predict(X_test)<br/>print(metrics.accuracy_score(y_test, y_pred))</span></pre><p id="0879" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">输出将是 0.97368。现在，我们将更改 random_state 的值，并再次计算精度。</p><pre class="lg lh li lj fd lk ll lm ln aw lo bi"><span id="a57a" class="lp ke hi ll b fi lq lr l ls lt">X_train, X_test, y_train, y_test = train_test_split(X, y, random_state=42)<br/>knn = KNeighborsClassifier(n_neighbors=5)<br/>knn.fit(X_train, y_train)<br/>y_pred = knn.predict(X_test)<br/>print(metrics.accuracy_score(y_test, y_pred))</span></pre><p id="5e91" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">输出将是 1.0。</p><p id="2d99" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">因此，根据 random_state 的值，精度会随着训练和测试数据的随机分配而变化。不同 random_state 值的模型精度如下所示。</p><figure class="lg lh li lj fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lv"><img src="../Images/19d20b7b1a4a88cc314fc63454198631.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cGoUNA5Mc5F84ZlNpOfdTA.jpeg"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">作者图片</figcaption></figure><p id="601f" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj"> K 倍交叉验证:</strong></p><p id="e652" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">为了克服 hold out 方法的缺点，还有一种方法叫做 K-Fold 交叉验证。这里，数据集被分成 k 个子集或折叠，然后在所有子集上进行训练，留下 1 个折叠用于测试训练的模型。K-fold 交叉验证的主要步骤是:</p><p id="a4dc" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">I .将数据集分成 K 个相等的分区或折叠。</p><p id="3261" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">二。使用 1 个折叠作为测试集，其他折叠作为训练集。</p><p id="e586" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">三。计算准确度。</p><p id="f659" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">四。重复步骤 2 和 3 K 次，每次使用不同的折叠作为测试集。</p><p id="d181" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">动词 （verb 的缩写）取所有精度的平均值。</p><p id="1eaf" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">五重交叉验证的示例如下所示:</p><figure class="lg lh li lj fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lw"><img src="../Images/9f31a829a92d6d7442f87c8d2158462e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*i1ufhDsvJBlEZq9B6aTjiQ.jpeg"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">作者图片</figcaption></figure><h1 id="d001" class="kd ke hi bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated"><strong class="ak">型号选择:</strong></h1><p id="785f" class="pw-post-body-paragraph iv iw hi ix b iy lb ja jb jc lc je jf jg ld ji jj jk le jm jn jo lf jq jr js hb bi translated">让我们再次使用 iris 数据集来看看交叉验证如何帮助模型选择。这里我们必须导入 cross_val_score，它将通过交叉验证来评估分数。</p><p id="f198" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">首先，我们将对 KNN 使用 10 倍交叉验证，K=15。</p><pre class="lg lh li lj fd lk ll lm ln aw lo bi"><span id="eaa2" class="lp ke hi ll b fi lq lr l ls lt">from sklearn.model_selection import cross_val_score</span><span id="4f96" class="lp ke hi ll b fi lu lr l ls lt">knn = KNeighborsClassifier(n_neighbors=15)</span><span id="60ee" class="lp ke hi ll b fi lu lr l ls lt">scores = cross_val_score(knn, X, y, cv=10, scoring='accuracy')</span><span id="101f" class="lp ke hi ll b fi lu lr l ls lt">print(scores)</span></pre><p id="d27a" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">输出:[0.93333333 0.9333333 1。1.1.0.93333333 0.93333333 1.1.1.]</p><p id="bebd" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这里我们可以看到它被迭代了 10 次，因此给出了 10 个精度值。</p><p id="b685" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">取上述所有精度的平均值。</p><pre class="lg lh li lj fd lk ll lm ln aw lo bi"><span id="eae6" class="lp ke hi ll b fi lq lr l ls lt">print(scores.mean())</span></pre><p id="062a" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">输出:<strong class="ix hj">0.9733333333333</strong></p><p id="dffb" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">现在用同样的 10 倍交叉验证，我们将使用逻辑回归。</p><pre class="lg lh li lj fd lk ll lm ln aw lo bi"><span id="e176" class="lp ke hi ll b fi lq lr l ls lt">from sklearn.linear_model import LogisticRegression</span><span id="40b2" class="lp ke hi ll b fi lu lr l ls lt">logreg = LogisticRegression(solver='liblinear')</span><span id="b338" class="lp ke hi ll b fi lu lr l ls lt">scores_logreg = cross_val_score(logreg, X, y, cv=10, scoring='accuracy')</span><span id="886b" class="lp ke hi ll b fi lu lr l ls lt">print(scores_logreg)</span></pre><p id="91dd" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">输出:[1。1.1.0.93333333 0.93333333 0.93333333 0.8 0.93333333 1.1.]</p><pre class="lg lh li lj fd lk ll lm ln aw lo bi"><span id="8f38" class="lp ke hi ll b fi lq lr l ls lt">print(scores_logreg.mean())</span></pre><p id="e1d3" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">并且平均值将是<strong class="ix hj">0.95333333333334</strong></p><p id="9aee" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">从上面的输出，很明显，KNN 将比逻辑回归表现更好。</p><h1 id="cc90" class="kd ke hi bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated"><strong class="ak">参数调整:</strong></h1><p id="95e4" class="pw-post-body-paragraph iv iw hi ix b iy lb ja jb jc lc je jf jg ld ji jj jk le jm jn jo lf jq jr js hb bi translated">模型的合适参数(或超参数)的选择在预测精度中起着重要作用。一般来说，我们使用机器学习模型的默认参数。但是一组最佳的参数可以显著提高模型的性能。例如，KNN 的 n_neighbor 参数，SVM 的 C 和γ参数等。交叉验证有助于选择合适的模型超参数。我们可以针对 n_neighbor 参数的不同值来评估上述 KNN 模型的准确性。</p><pre class="lg lh li lj fd lk ll lm ln aw lo bi"><span id="829a" class="lp ke hi ll b fi lq lr l ls lt">k_value = list(range(1, 36))</span><span id="32f3" class="lp ke hi ll b fi lu lr l ls lt">k_scores = []</span><span id="c416" class="lp ke hi ll b fi lu lr l ls lt">for k in k_value:</span><span id="4431" class="lp ke hi ll b fi lu lr l ls lt">knn = KNeighborsClassifier(n_neighbors=k)</span><span id="d47b" class="lp ke hi ll b fi lu lr l ls lt">scores = cross_val_score(knn, X, y, cv=10, scoring='accuracy')</span><span id="6389" class="lp ke hi ll b fi lu lr l ls lt">k_scores.append(scores.mean())</span></pre><figure class="lg lh li lj fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lx"><img src="../Images/5b1c484dce6a0455f9a87b628bf808bc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*R-z_aYhP3mCgnKH_6gKVlw.jpeg"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">作者图片</figcaption></figure><p id="2721" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">从上图可以看出，选择 k 值为 13、18 或 20 时，模型将给出最佳结果。</p><h1 id="a0ef" class="kd ke hi bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">结论:</h1><p id="54f9" class="pw-post-body-paragraph iv iw hi ix b iy lb ja jb jc lc je jf jg ld ji jj jk le jm jn jo lf jq jr js hb bi translated">交叉验证是机器学习中非常强大的工具。这对于评估我们的机器学习模型的有效性非常有用。它在超参数调谐中的使用使它成为一种更重要的技术。交叉验证有助于我们更好地使用我们的数据，并为我们提供更多关于算法性能的信息。</p><p id="b41d" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">今天到此为止。祝您愉快:)</p></div></div>    
</body>
</html>