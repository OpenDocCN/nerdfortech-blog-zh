<html>
<head>
<title>Constraints: Creation In Code (II)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">约束:在代码中创建(II)</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/constraints-creation-in-code-ii-68ec2bf7505d?source=collection_archive---------13-----------------------#2021-07-31">https://medium.com/nerd-for-tech/constraints-creation-in-code-ii-68ec2bf7505d?source=collection_archive---------13-----------------------#2021-07-31</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="faf5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在之前的<a class="ae jd" rel="noopener" href="/nerd-for-tech/constraints-introduction-part-i-5f6fb459704e">文章</a>中，我们谈到了约束，考虑了它们的属性。让我们揭示用代码创建它们的不同方法。</p><p id="b63a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">就个人而言，我更喜欢在代码中创建约束，而不是在IB中构造或使用XIB文件。特别是，如果你有一些“助手”来创建约束。对于复杂的UI，可视化地创建约束可能比在代码中创建更容易。然而，即使在代码中也有一些技巧，我将在文章中演示…</p><h2 id="82b0" class="je jf hi bd jg jh ji jj jk jl jm jn jo iq jp jq jr iu js jt ju iy jv jw jx jy bi translated">我是如何开始并喜欢在代码中进行约束的:)</h2><p id="1f74" class="pw-post-body-paragraph if ig hi ih b ii jz ik il im ka io ip iq kb is it iu kc iw ix iy kd ja jb jc hb bi translated">最初，我用视觉来创造它们。但是很久以前没有(故事板)SB的参考，如果它们被不同的开发者改变，合并SB会有问题。我开始使用<strong class="ih hj"> SnapKit </strong>，但是在那些日子里你必须写一些额外的，有点难看的代码来修改约束的<em class="ke">常量</em>值。我相信事情已经改变，但我的习惯“留”在我身边:)该库基于块的使用，不允许在不重新创建或重新激活它们的情况下激活约束，这是相当繁重的操作。另外，对于自定义大小的{Collection}ViewCell ，您必须返回单元格的预期高度(通常从静态高度开始)。所以同步调用应该返回height，而不是在主线程上异步执行:</p><figure class="kg kh ki kj fd kk er es paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="er es kf"><img src="../Images/934fed611bfcef08ab491d0a01fc82f2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3TkciY80Ox_zmNrC1d-9zw.png"/></div></div><figcaption class="kr ks et er es kt ku bd b be z dx translated">数据源的预期单元格高度。</figcaption></figure><p id="63f9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我的意思是<strong class="ih hj"> calculateHeight </strong>应该是同步的，它内部的异步调用可能会影响单元格的返回高度。</p><p id="0b4a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这就是我开始为约束创建自己的“助手”的方式…在简单关系的情况下，可以直接使用“锚”。例如:</p><pre class="kg kh ki kj fd kv kw kx ky aw kz bi"><span id="543a" class="je jf hi kw b fi la lb l lc ld">view.topAnchor.constraint(equalTo:<strong class="kw hj">self</strong>.collectionView.bottomAnchor).isActive = <strong class="kw hj">true</strong></span></pre><p id="9fea" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">不要忘记约束的<strong class="ih hj">标识符</strong>和视图的<strong class="ih hj">可访问性标识符</strong></p><p id="b12f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在Xcode的控制台中跟踪约束会容易得多，否则你必须打印对象(<strong class="ih hj"> po </strong>)，将其转换为某种类型等等。</p><p id="5fcc" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">与其复制约束，不如使用扩展来“锚定”这个和“锚定”那个。例如，让我们创建一个子视图，将它放置在父视图的中心:</p><figure class="kg kh ki kj fd kk er es paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="er es le"><img src="../Images/c452142e031229749050c9545795c1c6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gWOJF2SYVBsRT5nCA9xTBg.png"/></div></div><figcaption class="kr ks et er es kt ku bd b be z dx translated">中心约束</figcaption></figure><figure class="kg kh ki kj fd kk er es paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="er es lf"><img src="../Images/71529c2fff31743e6a6caca82932d656.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cpvqQHu_PyVVnxrePIYbog.png"/></div></div><figcaption class="kr ks et er es kt ku bd b be z dx translated">不同种类的布局锚点</figcaption></figure><p id="e434" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">锚点可以相对于视图，或者可以考虑视图周围的<strong class="ih hj">方向布局边距</strong>或<strong class="ih hj">安全区域</strong>。</p><p id="860c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">边距</strong>可以在不激活、取消激活约束的情况下移动视图，非常方便，加上属性<em class="ke">preserveparentlayyoumargin</em>可以确保内容放在父级的边距内。</p><h2 id="c973" class="je jf hi bd jg jh ji jj jk jl jm jn jo iq jp jq jr iu js jt ju iy jv jw jx jy bi translated">更新约束</h2><p id="6743" class="pw-post-body-paragraph if ig hi ih b ii jz ik il im ka io ip iq kb is it iu kc iw ix iy kd ja jb jc hb bi translated">批量更改、创建约束要高效得多。在视图中有一个<strong class="ih hj"> updateConstraints </strong>方法，您可以在其中添加约束。(例如，如果约束数组为空，则填充它)</p><pre class="kg kh ki kj fd kv kw kx ky aw kz bi"><span id="7922" class="je jf hi kw b fi la lb l lc ld"><strong class="kw hj">override</strong> <strong class="kw hj">func</strong> updateConstraints() { <br/>     <strong class="kw hj">super</strong>.updateConstraints()  <br/>     <strong class="kw hj">guard</strong> rtcRendererConstraints.first?.isActive == <strong class="kw hj">false</strong> <strong class="kw hj">else</strong> { <strong class="kw hj">return</strong> }<br/>     rtcRendererConstraints.activateConstraints()<br/>}</span></pre><p id="18d6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">顺便说一句，因为有forceLayout，所以也有force update约束，请参见下面的要点:)</p><h1 id="9c4b" class="lg jf hi bd jg lh li lj jk lk ll lm jo ln lo lp jr lq lr ls ju lt lu lv jx lw bi translated">细胞的特性</h1><p id="3b7c" class="pw-post-body-paragraph if ig hi ih b ii jz ik il im ka io ip iq kb is it iu kc iw ix iy kd ja jb jc hb bi translated">如果我们有表格或集合视图，它在单元格中的初始框架由布局的<strong class="ih hj">项大小决定。因此，当在代码中创建约束时，不要忘记默认情况下为(50，50)的框架可能会导致违反约束。如果没有足够的空间或大小大于50，则在计算大小之前，将验证约束。</strong></p><pre class="kg kh ki kj fd kv kw kx ky aw kz bi"><span id="867e" class="je jf hi kw b fi la lb l lc ld"><strong class="kw hj">override</strong> <strong class="kw hj">init</strong>(frame: CGRect) {<br/>   <strong class="kw hj">super</strong>.init(frame: frame)<br/>   setup()<br/>}</span><span id="2d3b" class="je jf hi kw b fi lx lb l lc ld">func setup() {<br/>  // don't forget about initial, when you define vertical margins, otherwise constraints activation might lead to their violation... </span><span id="b27c" class="je jf hi kw b fi lx lb l lc ld">}</span></pre><h1 id="a08c" class="lg jf hi bd jg lh li lj jk lk ll lm jo ln lo lp jr lq lr ls ju lt lu lv jx lw bi translated">视觉格式语言</h1><p id="9d7a" class="pw-post-body-paragraph if ig hi ih b ii jz ik il im ka io ip iq kb is it iu kc iw ix iy kd ja jb jc hb bi translated">可视格式还允许在另一个方向添加约束。例如，不仅要水平排列元素，还要定义项目的垂直方向(例如，将它们放在中间或顶部)。如果失败，你将得到<em class="ke">运行时</em>异常。让我们在代码中创建一种垂直堆栈视图，然后在不执行的情况下可视化它。</p><figure class="kg kh ki kj fd kk"><div class="bz dy l di"><div class="ly lz l"/></div></figure><p id="b3c8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这里，我们从设置方法添加2个标签，并强制更新约束。我们对齐标签的前导锚和尾随锚，并考虑<strong class="ih hj">方向布局边距。</strong>描述标签也可以在垂直方向上扩展和压缩(内容抱紧&amp;抗压)。</p><p id="80a0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为了可视化视图，我们需要使它成为可设计的，并覆盖prepareForInterfaceBuilder方法。上面我们定义了背景颜色(黄色，绿色&amp;蓝色)并提供了一些文本。之后只需为<strong class="ih hj"> VerticalStackView </strong>创建一个XIB，但是<strong class="ih hj">不要将它包含到目标</strong>中:</p><figure class="kg kh ki kj fd kk er es paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="er es ma"><img src="../Images/28bb3ff2f2a85892598006ea3ac3556d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Fo6cisr8LqlMxOfMZPu8GQ.png"/></div></div><figcaption class="kr ks et er es kt ku bd b be z dx translated">假XIB，不纳入目标</figcaption></figure><p id="6c20" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">对于定位视图，验证约束系统，即求解方程组。即使没有违反约束，它们也会被“检查”。因此，在单元格中，通过直接设置其框架来调整视图可能更容易。</p><p id="ec77" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">当在代码<strong class="ih hj">中创建视图时，translatesAutoresizingMaskIntoConstraints</strong>为<strong class="ih hj">真，自动调整掩码</strong>不会添加额外的约束。因此，如果需要，可以在<strong class="ih hj">布局子视图</strong>方法<strong class="ih hj">、</strong>内“调整”子视图的框架，而不是依赖约束:</p><pre class="kg kh ki kj fd kv kw kx ky aw kz bi"><span id="ba45" class="je jf hi kw b fi la lb l lc ld"><strong class="kw hj">override</strong> <strong class="kw hj">func</strong> layoutSubviews() {<br/>  <strong class="kw hj">super</strong>.layoutSubviews()<br/>  assert(lblDescr.translatesAutoresizingMaskIntoConstraints)<br/>  assert(lblDescr.autoresizingMask.isEmpty)<br/>  // set frame w/o constraints, it might be faster especially in  //Collection(table) view cells <br/>  //lblDescr.frame = ...<br/>}</span></pre><p id="190e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">另外，不要忘记<strong class="ih hj"> hasAmbiguousLayout </strong>属性，这可能揭示一些约束的问题。另一个问题是，我们不能在基于<strong class="ih hj"> traitCollection，</strong>的约束中添加“变化”，这在<strong class="ih hj"> Interface Builder中是可能的。我们必须处理尺寸变化(旋转)和激活，去激活不同的约束。</strong></p></div><div class="ab cl mb mc gp md" role="separator"><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg"/></div><div class="hb hc hd he hf"><p id="c8f3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在本文中，我们检查了在代码中创建约束的可能方式。谈到不运行应用程序的布局可视化，只是通过使用“假”的xib。</p></div></div>    
</body>
</html>