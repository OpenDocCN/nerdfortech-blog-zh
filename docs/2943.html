<html>
<head>
<title>Spawn Manager</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">产卵管理器</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/spawn-manager-a7c0e6446b2a?source=collection_archive---------19-----------------------#2021-05-24">https://medium.com/nerd-for-tech/spawn-manager-a7c0e6446b2a?source=collection_archive---------19-----------------------#2021-05-24</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/dcfb06150b252f1f4166dbd68fbf0ba2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vqqIDEcpqyZuCGyKiBWVFw.png"/></div></div></figure></div><div class="ab cl iq ir gp is" role="separator"><span class="it bw bk iu iv iw"/><span class="it bw bk iu iv iw"/><span class="it bw bk iu iv"/></div><div class="hb hc hd he hf"><p id="9274" class="pw-post-body-paragraph ix iy hi iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hb bi translated">在本文中，我将解释我通过使用一种称为协程的强大方法来实现 Space Shooter 项目的基本 Spawn 管理器的步骤。通过将产卵的敌人分配给一个新的父代，我们保持了层次概观的整洁，并防止它聚集。我们还将学习如何创建一个玩家脚本的引用，以防止玩家死亡时产卵管理器产生敌人。</p><h2 id="0ea4" class="jv jw hi bd jx jy jz ka kb kc kd ke kf ji kg kh ki jm kj kk kl jq km kn ko kp bi translated"><strong class="ak">产卵管理器脚本</strong></h2><p id="28d4" class="pw-post-body-paragraph ix iy hi iz b ja kq jc jd je kr jg jh ji ks jk jl jm kt jo jp jq ku js jt ju hb bi translated">通过创建一个繁殖管理器，我们可以自动繁殖我们的敌人，这样我们就不必在场景中手动设置他们。</p><p id="92ab" class="pw-post-body-paragraph ix iy hi iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hb bi translated">首先为产卵管理器创建一个新的脚本，并将其附加到一个名为<strong class="iz hj"> <em class="kv">【产卵管理器】</em> </strong>的新的空游戏对象上。</p><p id="87c7" class="pw-post-body-paragraph ix iy hi iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hb bi translated">现在让我们把我们想要生成的敌人预置存储到一个私有的游戏对象变量中。在新的 SpawnManager 脚本中，我们通过创建一个<em class="kv">private</em><strong class="iz hj"><em class="kv">GameObject _ Enemy Prefab 来创建一个对敌人预设的引用；</em>T11】</strong></p><figure class="kx ky kz la fd ij er es paragraph-image"><div class="er es kw"><img src="../Images/3c49545d76c71232bdf65df390d3bd2e.png" data-original-src="https://miro.medium.com/v2/resize:fit:682/format:webp/1*xKrcsnWIXZJzP8ZLhpkDLQ.png"/></div></figure><p id="c519" class="pw-post-body-paragraph ix iy hi iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hb bi translated">然后将敌人预置从项目窗口拖到检查器的种子管理器脚本的新位置。</p><figure class="kx ky kz la fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lb"><img src="../Images/7d63f193444a4461a4b55b872e922b78.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GuGQCkVfqS5i8aU41RthuA.png"/></div></div></figure><p id="1842" class="pw-post-body-paragraph ix iy hi iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hb bi translated">为了产生敌人，我将向你介绍一个新概念，<strong class="iz hj">协程</strong>。</p><p id="5f0f" class="pw-post-body-paragraph ix iy hi iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hb bi translated">这是一种特殊的功能，可以等待<strong class="iz hj">根据<strong class="iz hj">给出的指令</strong>执行其功能，并在下一帧从停止的地方恢复。</strong></p><p id="1618" class="pw-post-body-paragraph ix iy hi iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hb bi translated">协程能够包含一个名为<strong class="iz hj"> <em class="kv"> Yield </em> </strong>的语句，任何类型的让步，包括 null，都会导致执行返回到后面的帧，除非协程已经停止或者已经完成。</p><p id="bc57" class="pw-post-body-paragraph ix iy hi iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hb bi translated">在我们设置协程之前，我们需要一个布尔类型<strong class="iz hj"><em class="kv">_ stop spashing</em></strong>，默认设置为<strong class="iz hj"> false </strong>。</p><figure class="kx ky kz la fd ij er es paragraph-image"><div class="er es lc"><img src="../Images/154f028daf29f4044e0fc0ed537e60f6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1038/format:webp/1*bEe1Mqe1VEwq_sU7PlP-5w.png"/></div></figure><p id="7d9b" class="pw-post-body-paragraph ix iy hi iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hb bi translated">为了设置我们的协程，我们创建了一个类型为<strong class="iz hj"> <em class="kv"> IEnumerator </em> </strong>的方法<strong class="iz hj"><em class="kv">【method name】</em></strong>，其中我们将建模一个<strong class="iz hj"> <em class="kv"> while() </em> </strong>循环，如果<strong class="iz hj"><em class="kv">_ stop spasing</em></strong>设置为 false，该循环将运行它的代码。</p><figure class="kx ky kz la fd ij er es paragraph-image"><div class="er es lc"><img src="../Images/b4bd9e4986fdaaf0fd260d9d522b99b9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1038/format:webp/1*8jR_Wr8HlX9Ew4JVCCidJg.png"/></div></figure><p id="ca9c" class="pw-post-body-paragraph ix iy hi iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hb bi translated">在<strong class="iz hj"> <em class="kv"> while() </em> </strong>循环中，我们声明我们想要实例化哪个对象，并定义一个新的产卵位置及其方向。现在，我已经为我们实例化的敌人分配了一个随机的位置到新的产卵位置。</p><figure class="kx ky kz la fd ij er es paragraph-image"><div class="er es ld"><img src="../Images/9e814e3de42a168aea8079a2edf991ca.png" data-original-src="https://miro.medium.com/v2/resize:fit:1266/format:webp/1*-52Tq0YG1efm5lzMURfdYA.png"/></div></figure><p id="bb95" class="pw-post-body-paragraph ix iy hi iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hb bi translated">最后，我们使用<strong class="iz hj"><em class="kv">Yield return new WaitForSeconds(5.0f)</em></strong>语句来指示重新运行代码之间的暂停。在我们的例子中是 5 秒。</p><p id="3532" class="pw-post-body-paragraph ix iy hi iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hb bi translated">由于<strong class="iz hj"> <em class="kv"> while() </em> </strong>方法中的代码在循环中运行，我们还需要一个单独的函数来启动实际的协程方法。</p><p id="532e" class="pw-post-body-paragraph ix iy hi iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hb bi translated">在<strong class="iz hj"> <em class="kv"> Start() </em> </strong>函数中我们在游戏开始时启动我们的<strong class="iz hj"> <em class="kv"> SpawnRoutine() </em> </strong>。</p><figure class="kx ky kz la fd ij er es paragraph-image"><div class="er es ld"><img src="../Images/fafbfff33888a2bf0e737553b992fd6c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1266/format:webp/1*v_qelI8JTI365TGvpUPeHg.png"/></div></figure><blockquote class="le lf lg"><p id="a10b" class="ix iy kv iz b ja jb jc jd je jf jg jh lh jj jk jl li jn jo jp lj jr js jt ju hb bi translated"><strong class="iz hj">重要提示:</strong>虽然协程在代码清晰性和声明多个帧的行为方面非常出色，但由于协程的 CPU 代码总是出现在跟踪中的两个位置，它们会带来更高的内存开销。将一系列操作浓缩到尽可能少的单个协程是一个很好的实践。</p></blockquote><p id="7891" class="pw-post-body-paragraph ix iy hi iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hb bi translated">我们将在另一个专门讨论 Unity 优化的系列教程中更彻底地研究协程的最佳用法。</p></div><div class="ab cl iq ir gp is" role="separator"><span class="it bw bk iu iv iw"/><span class="it bw bk iu iv iw"/><span class="it bw bk iu iv"/></div><div class="hb hc hd he hf"><p id="b760" class="pw-post-body-paragraph ix iy hi iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hb bi translated"><strong class="iz hj">让我们保持干净<br/> </strong>为了防止等级聚集，我们应该为敌人创建一个新的父级，当他们在运行时繁殖时可以附着。</p><p id="e2f5" class="pw-post-body-paragraph ix iy hi iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hb bi translated">创建一个新的私有游戏对象<strong class="iz hj"><em class="kv">_ enemy container</em></strong>并将其作为子对象附加到层级窗口中的 SpawnManager。</p><figure class="kx ky kz la fd ij er es paragraph-image"><div class="er es lk"><img src="../Images/cb675f2278f1ee3b3e9c4b3eda6c8811.png" data-original-src="https://miro.medium.com/v2/resize:fit:766/format:webp/1*N2SchA0n7o7vsZ-rD5kp8A.png"/></div></figure><p id="196c" class="pw-post-body-paragraph ix iy hi iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hb bi translated">然后我们在实例化敌人的<strong class="iz hj"> <em class="kv"> while() </em> </strong>循环中将它的新父代设置为<strong class="iz hj"><em class="kv">_ enemy container</em></strong>。</p><p id="43b5" class="pw-post-body-paragraph ix iy hi iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hb bi translated">我们还应该在内存中缓存新的敌人，把它存储在一个本地变量中，最后我们可以声明另一个变量，这个变量可以在 inspector 中的组件上调整，这样我们就可以很容易地调整产卵率。</p><figure class="kx ky kz la fd ij er es paragraph-image"><div class="er es ll"><img src="../Images/8429c8bd01e87b493bf11a23b3d77c99.png" data-original-src="https://miro.medium.com/v2/resize:fit:910/format:webp/1*WyCgJZsf_G_SEqd2WOFShg.png"/></div></figure><figure class="kx ky kz la fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lm"><img src="../Images/c92a4df293bb2a0f0f1e3733f9ea6c35.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*01XX7IkoBMOBNXIYUQ15hg.png"/></div></div></figure></div><div class="ab cl iq ir gp is" role="separator"><span class="it bw bk iu iv iw"/><span class="it bw bk iu iv iw"/><span class="it bw bk iu iv"/></div><div class="hb hc hd he hf"><h2 id="dee0" class="jv jw hi bd jx jy jz ka kb kc kd ke kf ji kg kh ki jm kj kk kl jq km kn ko kp bi translated">玩家脚本</h2><p id="258f" class="pw-post-body-paragraph ix iy hi iz b ja kq jc jd je kr jg jh ji ks jk jl jm kt jo jp jq ku js jt ju hb bi translated">在玩家脚本中，我们必须做一些修改，以防止玩家死亡时产卵管理器产生敌人。然而，SpawnManager 有自己的脚本，所以我们需要通过使用脚本通信来获得对它的引用。</p><p id="0740" class="pw-post-body-paragraph ix iy hi iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hb bi translated">首先我们创建一个新的私有成员变量<strong class="iz hj"><em class="kv">spawn manager _ spawn manager；</em> </strong> <em class="kv"> </em>来缓存我们曾经抢过的那个 SpawnManager。</p><figure class="kx ky kz la fd ij er es paragraph-image"><div class="er es ln"><img src="../Images/42a4e7473e5592ab81bb12e49c6a5fa9.png" data-original-src="https://miro.medium.com/v2/resize:fit:716/format:webp/1*HfxE_Oxg7xms0EegV4sK6w.png"/></div></figure><p id="2da5" class="pw-post-body-paragraph ix iy hi iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hb bi translated">在<strong class="iz hj"> <em class="kv"> Start() </em> </strong>方法中，我们获取了<strong class="iz hj"> "SpawnManager" </strong>，但是首先我们执行了一个<em class="kv">空值检查</em>以确保存在一个空值，否则我们打印一个错误。</p><p id="1b39" class="pw-post-body-paragraph ix iy hi iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hb bi translated">如果你不熟悉<strong class="iz hj"> <em class="kv">游戏对象。find()</em></strong>&amp;<strong class="iz hj"><em class="kv">get component&lt;spawn manager&gt;()；</em> </strong>方法<a class="ae lo" href="https://gert-coppens100.medium.com/script-communication-in-unity-using-getcomponent-45fba58f322a" rel="noopener">在这里</a>我想邀请你，在这里我将向你介绍 Unity 中的脚本通信。</p><figure class="kx ky kz la fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lp"><img src="../Images/5b9537358fcb4e5337617d81b9fd055b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dNFsFWG9NqbS01brFRZSng.png"/></div></div></figure><p id="34fe" class="pw-post-body-paragraph ix iy hi iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hb bi translated">为了在我们的例子中停止协程方法，我们将首先在 Spawn Manager 脚本中创建一个<strong class="iz hj"><em class="kv">【OnPlayerDeath()</em></strong>方法，该方法简单地将<strong class="iz hj"><em class="kv">_ Stop spacing</em></strong>的条件设置为 true。请注意，有多种方法可以停止协程。</p><figure class="kx ky kz la fd ij er es paragraph-image"><div class="er es ld"><img src="../Images/699073260f35034f6691463c30c9897a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1266/format:webp/1*yOXgXVy973nie472GEE3KA.png"/></div></figure><p id="421e" class="pw-post-body-paragraph ix iy hi iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hb bi translated">为了让 SpawnManager 在玩家死亡时停止繁殖敌人，我们随后添加了<strong class="iz hj"> <em class="kv"> _spawnManager。OnPlayerDeath() </em> </strong>函数给我们的<strong class="iz hj"> <em class="kv">破坏()</em> </strong>方法放在播放器脚本中。</p><figure class="kx ky kz la fd ij er es paragraph-image"><div class="er es lq"><img src="../Images/9414f381731100ada0af33a267ae9de8.png" data-original-src="https://miro.medium.com/v2/resize:fit:826/format:webp/1*aRojShChHuD1uCIg7Lt_Lw.png"/></div><figcaption class="lr ls et er es lt lu bd b be z dx translated">当玩家死亡时，<strong class="bd jx"> OnPlayerDeath() </strong>中的 _ stopSpawning 被设置为 false</figcaption></figure></div><div class="ab cl iq ir gp is" role="separator"><span class="it bw bk iu iv iw"/><span class="it bw bk iu iv iw"/><span class="it bw bk iu iv"/></div><div class="hb hc hd he hf"><figure class="kx ky kz la fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lv"><img src="../Images/5f31676e85aeb0e9b3778b1980a0903c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*nqSPMaamxDeEwm-KBp8z9g.gif"/></div></div></figure></div><div class="ab cl iq ir gp is" role="separator"><span class="it bw bk iu iv iw"/><span class="it bw bk iu iv iw"/><span class="it bw bk iu iv"/></div><div class="hb hc hd he hf"><p id="ec7f" class="pw-post-body-paragraph ix iy hi iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hb bi translated">← <a class="ae lo" rel="noopener" href="/nerd-for-tech/script-communication-in-unity-using-getcomponent-45fba58f322a">上一张</a> | <a class="ae lo" rel="noopener" href="/geekculture/scrolling-sprite-background-cfa82fbccc0d">下一张</a> →</p></div></div>    
</body>
</html>