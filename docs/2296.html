<html>
<head>
<title>Distributed system models</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">分布式系统模型</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/distributed-system-models-966ff15fe84d?source=collection_archive---------4-----------------------#2021-04-30">https://medium.com/nerd-for-tech/distributed-system-models-966ff15fe84d?source=collection_archive---------4-----------------------#2021-04-30</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div class="er es if"><img src="../Images/018543a8b1a4e6e46a30eea8779956ee.png" data-original-src="https://miro.medium.com/v2/resize:fit:1024/format:webp/1*9iwaR3rY_ZFTc-gcxXLwGg.png"/></div></figure><p id="6bfb" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">在分布式系统世界中，没有什么是 100 %可靠的，所以我们总是考虑故障，所以当设计一个分布式系统模型时，我们是如何指定我们关于故障的前提的。</p><p id="1060" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">一般来说，我们可以将模型分为三类</p><p id="1049" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">1-网络行为</p><p id="ac34" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">2 节点行为</p><p id="292e" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">3-计时行为</p><h2 id="72f5" class="jk jl hi bd jm jn jo jp jq jr js jt ju ix jv jw jx jb jy jz ka jf kb kc kd ke bi translated"><strong class="ak">网络行为</strong></h2><p id="accf" class="pw-post-body-paragraph im in hi io b ip kf ir is it kg iv iw ix kh iz ja jb ki jd je jf kj jh ji jj hb bi translated">因为在现实世界中没有网络是可靠的，即使我们设计了具有重复网络链接的系统，因为可能有人容易错误地拔掉网络电缆，网络可能过载或网络可能受到攻击，等等。当我们处理网络和消息丢失中的可靠性问题时，我们可以从以下三个模型中选择一个来表明我们想要的可靠性。</p><p id="7943" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><strong class="io hj"> 1-完美链接或可靠链接</strong></p><p id="678b" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">在这个模型中，消息只有在被发送时才被接收，所以我们将正确地接收消息是一个高层次的被授权者，可能消息被重新排序，但事实上，在现实世界中这个模型并不容易被假设。</p><p id="730c" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><strong class="io hj"> 2-公平损失链接</strong></p><p id="6f50" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">在这个模型中，消息可能会丢失或错误地复制，并且重新排序，但是如果您不断重试发送消息，它最终会通过，但是我们无法确定通过的时间，但是理论上，如果我们在一个开放的时间内不断重试，可能是 100 年:)消息会通过，并且我们可以通过不断重试将公平损失转化为可靠的链路。这意味着任何网络分区(网络中断)只会持续有限的一段时间，而不是永远，因此我们可以保证每个消息最终都会被接收到。</p><p id="1415" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><strong class="io hj"> 3-任意</strong></p><p id="6e3c" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">当我们在星巴克或任何咖啡厅使用公共不安全网络链接时，这种模式正是在互联网通信中发生的情况。网络运营商可能会干扰和操纵您的网络数据包。这也称为主动对手，但也有可能我们可以通过使用加密来保护我们的连接和网络数据包，如传输层安全性(TLS) 防止主动对手丢弃或欺骗我们的流量的协议，但 TLS 也不能防止通信阻塞，在变成公平损失后，我们最终可以将公平损失变成可靠的。</p><blockquote class="kk kl km"><p id="f881" class="im in kn io b ip iq ir is it iu iv iw ko iy iz ja kp jc jd je kq jg jh ji jj hb bi translated">因此，可靠网络链路的假设也许并不像乍看上去那样不切实际。一般来说，只要我们愿意在网络分区期间等待一段可能任意长的重试时间，就有可能接收到所有发送的消息</p></blockquote><h2 id="7a3b" class="jk jl hi bd jm jn jo jp jq jr js jt ju ix jv jw jx jb jy jz ka jf kb kc kd ke bi translated">节点行为</h2><p id="8367" class="pw-post-body-paragraph im in hi io b ip kf ir is it kg iv iw ix kh iz ja jb ki jd je jf kj jh ji jj hb bi translated">在这种情况下，我们必须确定节点有故障，每个节点执行以下指定的算法</p><p id="b86f" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><strong class="io hj"> 1-急停(故障停止)</strong></p><p id="6852" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">在这种模型中，如果一个节点在任何时候崩溃，那么它就是有故障的，崩溃之后，它将永远停止响应或执行作业，并且永远不会恢复。这对于不可恢复的硬件是合理的，例如，如果您的硬件着火或掉到火车下面等等。如果我们假设死机，算法就变得更简单了。</p><p id="dd31" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><strong class="io hj"> 2-崩溃恢复(故障恢复)</strong></p><p id="fc78" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">在此模型中，节点也可能在任何时候崩溃，但有时它可能会再次恢复，例如操作系统停滞或内核错误，然后节点需要重新启动以再次加入分布式系统并在崩溃后恢复处理，任何不可恢复的存储都将丢失，例如内存，但我们可以通过使用可恢复存储来避免这种情况，我们还应考虑到节点可能会无限期地处于崩溃恢复模式，这也可能导致故障停止。</p><p id="c119" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><strong class="io hj"> 3-拜占庭(失败-任意)</strong></p><p id="1aef" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">这是最常见的节点行为，在拜占庭问题中，故障节点不仅会崩溃，而且由于系统中的每个节点都应该遵循一种算法，如果节点以不可预测或任意的方式偏离该算法，例如我们之前提到的恶意行为，我们可以认为节点有故障，节点实现错误也可以归类为拜占庭故障。</p><blockquote class="kk kl km"><p id="d119" class="im in kn io b ip iq ir is it iu iv iw ko iy iz ja kp jc jd je kq jg jh ji jj hb bi translated">就网络而言，可以从一种模式转变为另一种模式。节点行为的不同模型并非如此。例如，为故障恢复设计的算法可能看起来与拜占庭算法非常不同，等等</p></blockquote><h2 id="5be1" class="jk jl hi bd jm jn jo jp jq jr js jt ju ix jv jw jx jb jy jz ka jf kb kc kd ke bi translated"><strong class="ak">定时</strong>行为<strong class="ak">假设</strong></h2><p id="d53f" class="pw-post-body-paragraph im in hi io b ip kf ir is it kg iv iw ix kh iz ja jb ki jd je jf kj jh ji jj hb bi translated">计时行为与同步假设有关，因此我们有三种模型同步、异步或部分同步，但请考虑到这些术语的定义在计算机科学的不同领域有所不同，因此我们在分布式计算领域定义它们，以免混淆。</p><p id="4fb7" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><strong class="io hj"> 1-同步</strong></p><p id="22c4" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">在这个模型中， 我们有一个传递消息的最大时间，所以消息等待时间不大于一个已知的上限，我们也可以考虑节点以一个已知的速度执行算法，每个处理分布式系统的人都喜欢这个模型，如果你假设一个同步系统，分布式计算中的许多问题就容易得多:)但不幸的是，大多数时候节点没有相同的行为，如果违反了有限等待时间和有限执行速度的假设，为同步模型设计的算法经常会失败。</p><p id="e482" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><strong class="io hj"> 2-异步</strong></p><p id="9aae" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">在这个模型中，我们根本不做任何时间假设，例如，我们允许消息被不可预测地延迟，并且节点可以以彼此不同的处理速度执行算法。基于异步的算法非常强大，因为它们不受网络中断或延迟的影响，但另一方面，一些分布式计算问题也无法通过异步算法解决，因此我们有了第三种模型<em class="kn">部分同步</em>来解决。</p><p id="c993" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><strong class="io hj"> 3-部分同步</strong></p><p id="51dd" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">在这个模型中，我们假设我们的系统是同步的，并且在大多数时间表现良好，但有时它可能会变成异步模式，在这种模式下，所有的定时保证都是关闭的，这可能会不可预测地发生。</p><p id="fcde" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><strong class="io hj">资源:</strong></p><p id="6f3c" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><a class="ae kr" href="https://www.springer.com/gp/book/9783642152597" rel="noopener ugc nofollow" target="_blank">可靠安全的分布式编程书籍介绍</a></p></div></div>    
</body>
</html>