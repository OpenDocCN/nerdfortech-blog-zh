<html>
<head>
<title>Linear Search vs Binary Search</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">线性搜索vs二分搜索法</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/linear-search-vs-binary-search-1e55be4e2565?source=collection_archive---------10-----------------------#2021-02-04">https://medium.com/nerd-for-tech/linear-search-vs-binary-search-1e55be4e2565?source=collection_archive---------10-----------------------#2021-02-04</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="b77f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">TLDR—</strong><strong class="ih hj"/>线性搜索从头到尾循环遍历一个数组，而二分搜索法将数组分成两半，进行半区间搜索。如果找不到变量，它会根据其相对于搜索主题的位置过高或过低，将数组分成另一半，如下所示。在T4，一般来说，二分搜索法对于大型阵列来说要快得多。</p><p id="46a7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">看看下面这张gif:</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div class="er es je"><img src="../Images/a6bab85fba15863a3cc9d9fab3db329c.png" data-original-src="https://miro.medium.com/v2/resize:fit:960/1*9ucnO1Ymbl-qDhJFpgZ6Tw.gif"/></div><figcaption class="jm jn et er es jo jp bd b be z dx translated"><a class="ae jq" href="https://www.interviewbit.com/courses/programming/topics/binary-search/" rel="noopener ugc nofollow" target="_blank">来源</a></figcaption></figure><h1 id="4035" class="jr js hi bd jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko bi translated">线性搜索</h1><p id="8a8e" class="pw-post-body-paragraph if ig hi ih b ii kp ik il im kq io ip iq kr is it iu ks iw ix iy kt ja jb jc hb bi translated">线性搜索在特定情况下更有意义:</p><ul class=""><li id="7776" class="ku kv hi ih b ii ij im in iq kw iu kx iy ky jc kz la lb lc bi translated">如果你的数组保证很小。为长度为3的数组设计一个花哨的二分搜索法没有多大意义。[“萨博”、“沃尔沃”、“宝马”]</li><li id="8ec8" class="ku kv hi ih b ii ld im le iq lf iu lg iy lh jc kz la lb lc bi translated">如果您只是实现最简单的解决方案，并且不关心速度，那么线性搜索将是一个不错的选择。</li></ul><h1 id="1906" class="jr js hi bd jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko bi translated">二进位检索</h1><p id="2072" class="pw-post-body-paragraph if ig hi ih b ii kp ik il im kq io ip iq kr is it iu ks iw ix iy kt ja jb jc hb bi translated">二分搜索法是:</p><ul class=""><li id="d3c7" class="ku kv hi ih b ii ij im in iq kw iu kx iy ky jc kz la lb lc bi translated">比线性搜索更大数组要快得多。</li><li id="d482" class="ku kv hi ih b ii ld im le iq lf iu lg iy lh jc kz la lb lc bi translated">实现起来相对简单的算法。</li></ul><p id="a2e9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">最大的优势是二分搜索法的工作速度，这可以通过大O符号来衡量——如果你没有更新大O符号，你可以在这里看到我的帖子<a class="ae jq" href="https://medium.com/r?url=https%3A%2F%2Fdanleitch.medium.com%2Fbig-o-notation-basics-for-web-developers-af02ec3b89f" rel="noopener">并在完成后返回。</a></p><h1 id="c899" class="jr js hi bd jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko bi translated">大O符号</h1><p id="5c37" class="pw-post-body-paragraph if ig hi ih b ii kp ik il im kq io ip iq kr is it iu ks iw ix iy kt ja jb jc hb bi translated">让我们比较一下这两个搜索，以便正确理解二进制能给我们带来的性能提升。</p><p id="47c6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">使用<strong class="ih hj">线性</strong>搜索，时间复杂度将总是O(n ),这是因为随着阵列的增加，迭代次数也随之增加。例如，一个包含100项的数组可能意味着100次迭代，因为我们需要的项可能是数组中的最后一项。</p><p id="0d56" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">二进制</strong>搜索有点混合了<strong class="ih hj"> O(log n) </strong>和<strong class="ih hj"> O(n) </strong>，但通常会更接近于<strong class="ih hj"> O(log n) </strong>。这使得二分搜索法方法成为一种更有效的搜索算法，因为它可以更好地适应数组的大小。</p><p id="786b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">回到页面顶部的gif，您会发现查找“37”的总迭代次数是</p><ul class=""><li id="3a85" class="ku kv hi ih b ii ij im in iq kw iu kx iy ky jc kz la lb lc bi translated">3为二进制<strong class="ih hj"> O(3) </strong></li><li id="6444" class="ku kv hi ih b ii ld im le iq lf iu lg iy lh jc kz la lb lc bi translated">11顺序<strong class="ih hj"> O(11) </strong></li></ul><p id="27c5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在我们的例子中，使<strong class="ih hj">二进制的效率提高了3.6倍。</strong></p><figure class="jf jg jh ji fd jj er es paragraph-image"><div class="er es li"><img src="../Images/31e8af29dab3a58f7d85dd33a1b74b3e.png" data-original-src="https://miro.medium.com/v2/resize:fit:950/format:webp/1*YBHid6bqpPYdgEVwDoi-Yg.jpeg"/></div></figure></div><div class="ab cl lj lk gp ll" role="separator"><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo"/></div><div class="hb hc hd he hf"><p id="32ce" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">脚注:</strong></p><p id="7042" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> </strong>它实际上会是max值/ 2。例如，如果你从1-100中随机抽取100万个数字，很明显50是平均值。</p><p id="e3bf" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">使用的资源</strong></p><ul class=""><li id="03b1" class="ku kv hi ih b ii ij im in iq kw iu kx iy ky jc kz la lb lc bi translated"><a class="ae jq" href="https://qr.ae/pNzzm5" rel="noopener ugc nofollow" target="_blank"> Quora </a></li><li id="666a" class="ku kv hi ih b ii ld im le iq lf iu lg iy lh jc kz la lb lc bi translated">I <a class="ae jq" href="https://www.interviewbit.com/courses/programming/topics/binary-search/" rel="noopener ugc nofollow" target="_blank">nterviewbit.com </a></li></ul></div></div>    
</body>
</html>