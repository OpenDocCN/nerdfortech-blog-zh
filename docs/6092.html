<html>
<head>
<title>Optimisation, part 4</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">优化，第4部分</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/optimisation-part-4-2d9b7a5cfd91?source=collection_archive---------6-----------------------#2021-12-28">https://medium.com/nerd-for-tech/optimisation-part-4-2d9b7a5cfd91?source=collection_archive---------6-----------------------#2021-12-28</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="d106" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">论执著的错误</h2></div><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ix"><img src="../Images/496ce90f6e3dfdbce44d3baaf000144e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*tn3qXXWov9Q2oTvn"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">加布里埃尔·索尔曼在<a class="ae jn" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><p id="15b1" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">以前，我曾经写过向GPXmagic添加一个简单的四叉树。这使得一些操作在时间上(大致)与点数的对数成正比。</p><p id="a1bd" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">我的基本结构仍然是GPS跟踪点列表。为什么不呢，那是骑自行车或者走路的体验。你通过一个点，然后另一个点。</p><p id="392c" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">尽管简单，所有证据表明，该程序与几万个点斗争。四叉树只是暂时缓解了症状。这也是一个明确的信号，天真的结构并不总是最好的，也不明显。</p><p id="f9c6" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">我很早就做了一个错误的决定。我给每个点一个数字索引，并把它放入列表中。似乎有道理；给定一个点，我知道它的索引，给定一个索引，我可以找到这个点。我还将<code class="du kk kl km kn b">distanceFromStart</code>放入每个点的数据中。这太棒了，我可以很容易地获得相关信息。我出于良好的动机添加了<code class="du kk kl km kn b">directionChange</code>，因为发现明显的偏差是平滑过程的关键。</p><p id="a2cd" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">这些选择和类似选择的结果是，加载文件需要多次遍历点列表，代码片段如下:</p><pre class="iy iz ja jb fd ko kn kp kq aw kr bi"><span id="40d3" class="ks kt hi kn b fi ku kv l kw kx">firstPassSetsForwardLooking =<br/>        List.map2<br/>            deriveForward<br/>            preFilterDuplicates<br/>            (List.drop 1 preFilterDuplicates)<br/>            ++ List.drop (List.length preFilterDuplicates - 1) preFilterDuplicates</span></pre><p id="d4b6" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">这些都是无伤大雅的。这是增长的代价，并且随着名单的增长而越来越大。不明显的是这段代码幕后的内存分配、释放和垃圾收集的数量。甚至那个<code class="du kk kl km kn b">List.length</code>也是整个名单中的一员。</p><p id="4ddb" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">另外值得注意的是<code class="du kk kl km kn b">index</code>和<code class="du kk kl km kn b">distanceFromStart</code>是<strong class="jq hj">坏</strong>。如果我删除了路线中的第二个点，我必须更新所有剩余的点。这明智吗？不。这是可以避免的吗？让我们找出答案。</p><p id="18af" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">我用304000分的文件做了一个“快速”测试:</p><blockquote class="kz la lb"><p id="f70d" class="jo jp ky jq b jr js ij jt ju jv im jw lc jy jz ka ld kc kd ke le kg kh ki kj hb bi translated"><em class="hi">版本2.7.13 : &lt;测试坏了Chrome，无结果&gt; <br/>版本2.8.1:约4分钟，内存使用不可用</em></p></blockquote><p id="055b" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">(测试破坏工具时很难得到数据。)</p><p id="1119" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">最后，本着在V3上工作的心态，我决定尝试一些不同的东西。我在考虑使用一些混合的跳过列表或差异列表。一天晚上，躺在黑暗中，我决定尝试一个简单的二叉树，每个节点都增加了从其子节点聚合的关键数据。</p><pre class="iy iz ja jb fd ko kn kp kq aw kr bi"><span id="c443" class="ks kt hi kn b fi ku kv l kw kx">type alias RoadSection =<br/>    -- A piece of road, in local, conformal, space.<br/>    -- Can be based between two 'fundamental' points from GPX, or an assembly of them.<br/>    { startsAt : LocalPoint<br/>    , endsAt : LocalPoint<br/>    , boundingBox : BoundingBox3d Meters LocalCoords<br/>    , trueLength : Quantity Float Meters<br/>    , skipCount : Int<br/>    }<br/></span><span id="c404" class="ks kt hi kn b fi lf kv l kw kx">type<br/>    PeteTree<br/>    -- Absurdly simple tree may work.<br/>    = Leaf RoadSection<br/>    | Node<br/>        { nodeContent : RoadSection<br/>        , left : PeteTree<br/>        , right : PeteTree<br/>        }</span></pre><p id="43f4" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">有趣的是。对于一个点没有<code class="du kk kl km kn b">index</code>，但是通过计数<code class="du kk kl km kn b">skipCount</code>我们可以从它的索引中导出一个点，或者一个点的索引。如果我删除一个点，我只需要更新它在树中的祖先节点，而不是所有剩余的点。同样，<code class="du kk kl km kn b">trueLength</code>代替了<code class="du kk kl km kn b">distanceFromStart</code>。</p><blockquote class="kz la lb"><p id="92c0" class="jo jp ky jq b jr js ij jt ju jv im jw lc jy jz ka ld kc kd ke le kg kh ki kj hb bi translated">当然，皮特，建造这个建筑需要很长时间。您基本上是将叶节点所需的空间增加了一倍(如果您知道如何对一个几何级数求和)。</p></blockquote><p id="301a" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">嗯，答案花了点时间。为了公平测试，我需要能够加载文件，填充树结构，以类似于v2的图形呈现它，通过滑块或单击图像提供基本导航。这些证明了我们的索引机制是有效的，并且我们可以在没有四叉树的情况下有效地搜索树。</p><p id="e2f4" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">我们可以使用该结构在任意深度进行渲染，因此从一开始就实现了选择性渲染，给出了当前点周围的更多细节，而没有v2中涉及的诡计。</p><blockquote class="kz la lb"><p id="7b1d" class="jo jp ky jq b jr js ij jt ju jv im jw lc jy jz ka ld kc kd ke le kg kh ki kj hb bi translated"><em class="hi">版本3测试:4.5秒，265MB堆</em></p></blockquote><p id="0a13" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">什么？对，4.5 <em class="ky">秒</em>，不是分钟。根据Chrome开发者工具，其中只有1.5秒是我的脚本，所以(根据推断)3秒只是加载文件内容。我不得不请一个朋友检查窗户。同样的结果:不到五秒钟333000分。</p><p id="82ba" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">当然，这是一个相当根本性的改变，所有的编辑功能都需要重写。我很抱歉吗？不会吧！</p><p id="f4f1" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">不要因为你早期的决定看起来是无辜的，就坚持不放。</p></div></div>    
</body>
</html>