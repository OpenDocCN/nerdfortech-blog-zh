<html>
<head>
<title>Python vs C++ Series: Polymorphism and Duck Typing</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python vs C++系列:多态性和Duck类型</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/python-vs-c-series-polymorphism-and-duck-typing-31dbbc3739d5?source=collection_archive---------7-----------------------#2021-10-11">https://medium.com/nerd-for-tech/python-vs-c-series-polymorphism-and-duck-typing-31dbbc3739d5?source=collection_archive---------7-----------------------#2021-10-11</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="d342" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这是<a class="ae jd" rel="noopener" href="/nerd-for-tech/python-vs-c-series-getter-setter-and-property-e92d7801c21a"> Python vs C++系列</a>的第二篇文章。在本文中，我们将讨论另一个基本的面向对象编程概念——多态性。</p><p id="4bc7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">(注意，本系列中的Python代码假设使用Python 3.7或更高版本)</p><h1 id="2738" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">多态性的简要回顾</h1><p id="5206" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">多态性是一个希腊词，意思是有多种形式。支持多态性的编程语言意味着变量、函数或对象可以采用多种形式，比如函数接受不同类型的参数。此外，使用多态性，我们可以用相同的名称(即相同的接口)定义函数，但是这些函数有多个实现。</p><h1 id="9957" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">C++中的多态性</h1><p id="e2df" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">C++支持静态(编译时解析)和动态(运行时解析)多态性。</p><p id="68c4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在C++中，静态多态性也称为函数重载，允许程序声明多个同名但参数不同的函数。下面展示了一个C++中函数重载的例子。</p><pre class="kh ki kj kk fd kl km kn ko aw kp bi"><span id="d214" class="kq jf hi km b fi kr ks l kt ku">#include &lt;string&gt;<br/><br/>void myOverloadingFunction(int parameter)<br/>{<br/>    // Do something<br/>}<br/><br/>void myOverloadingFunction(std::string parameter)<br/>{<br/>    // Do something<br/>}<br/><br/>void myOverloadingFunction(int parameter1, std::string parameter2, float parameter3)<br/>{<br/>    // Do something<br/>}</span></pre><p id="8666" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">(示例代码可在<a class="ae jd" href="https://github.com/shunsvineyard/shunsvineyard/blob/main/python_vs_cpp_series/polymorphism_and_duck_typing/cpp_function_overloading.cpp" rel="noopener ugc nofollow" target="_blank">CPP _ function _ overloading . CPP</a>获得)</p><h1 id="cd6b" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">虚函数和抽象类</h1><p id="3548" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">通过使用具有虚函数的类层次结构，C++实现了运行时多态性。当派生类中的方法重写其基类时，要调用的方法由运行时对象的类型决定。下面的代码展示了它在C++中是如何工作的。</p><pre class="kh ki kj kk fd kl km kn ko aw kp bi"><span id="d32e" class="kq jf hi km b fi kr ks l kt ku">#include &lt;memory&gt;<br/><br/>class BaseClass<br/>{<br/>    public:<br/>        virtual void doWork()<br/>        {<br/>            // do some work<br/>        }<br/>};<br/><br/>class DerivedClassA: public BaseClass<br/>{<br/>    public:<br/>        virtual void doWork() override<br/>        {<br/>            // do some work<br/>        }<br/>};<br/><br/>class DerivedClassB: public BaseClass<br/>{<br/>    public:<br/>        virtual void doWork() override<br/>        {<br/>            // do some work<br/>        }<br/>};<br/><br/>void myFunction(std::shared_ptr&lt;BaseClass&gt; p)<br/>{<br/>    // The appropriate doWork() to be called will be determined by<br/>    // the instance of p at the runtime.<br/>    p-&gt;doWork();<br/>}</span></pre><p id="08a7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">(示例代码可在<a class="ae jd" href="https://github.com/shunsvineyard/shunsvineyard/blob/main/python_vs_cpp_series/polymorphism_and_duck_typing/cpp_virtual_function.cpp" rel="noopener ugc nofollow" target="_blank"> cpp_virtual_function.cpp </a>获得)</p><p id="7dd1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">接口和纯虚函数</strong></p><p id="10b8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">当虚函数追加<em class="kv"> = 0 </em>后，就变成了纯虚函数，包含纯虚函数的类称为抽象类。如果支持实例化，任何从抽象类派生的类都必须定义它的纯虚函数。因此，我们通常使用抽象类来定义程序的接口。举个例子，</p><pre class="kh ki kj kk fd kl km kn ko aw kp bi"><span id="b37c" class="kq jf hi km b fi kr ks l kt ku">class MyInterface<br/>{<br/>    // Since this class contains a pure virtual class; it becomes an abstract<br/>    // class, and cannot be instantiated.<br/>    public:<br/>        // Use a pure virtual function to define an interface.<br/>        virtual int method(int parameter) = 0;<br/>};<br/><br/>class DerivedClass: public MyInterface<br/>{<br/>    public:<br/>        // If the derived class needs to be instantiated, the derived class<br/>        // must implement its parent's pure virtual function.<br/>        virtual int method(int parameter) override<br/>        {<br/>            // do something<br/>        }<br/>};</span></pre><p id="980a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">(示例代码可从<a class="ae jd" href="https://github.com/shunsvineyard/shunsvineyard/blob/main/python_vs_cpp_series/polymorphism_and_duck_typing/cpp_interface.cpp" rel="noopener ugc nofollow" target="_blank"> cpp_interface.cpp </a>获得)</p><h1 id="f93f" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">Python中的鸭子打字</h1><p id="12d1" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">鸭子分类是鸭子测试的一个应用，它说，“如果它看起来像鸭子，像鸭子一样游泳，像鸭子一样嘎嘎叫，那么它可能是一只鸭子。”使用duck类型，函数不检查参数的类型；相反，它会检查参数是否存在。Duck typing是Python这样的动态语言的精髓。</p><p id="6278" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们在C++中需要多态性的一个原因是C++是一种静态语言。多态允许我们用相同的名字定义函数，但是使用不同的类型参数或者不同数量的参数。相反，Python是一种动态语言。所以函数重载对于Python来说不是必须的，也不被支持(见<a class="ae jd" href="https://www.python.org/dev/peps/pep-3124/" rel="noopener ugc nofollow" target="_blank"> PEP3142 </a>)。以下示例显示了Python函数如何处理不同类型的参数。</p><pre class="kh ki kj kk fd kl km kn ko aw kp bi"><span id="8716" class="kq jf hi km b fi kr ks l kt ku">def my_function(parameter):<br/><br/>    if type(parameter) is str:<br/>        print("Do something when the type is string")<br/><br/>    elif type(parameter) is int:<br/>        print("Do something when the type is integer")<br/><br/>    else:<br/>        raise TypeError("Invalid type")<br/><br/>if __name__ == "__main__":<br/>    # Valid<br/>    my_function(10)<br/>    my_function("hello")<br/><br/>    # TypeError exception will be thrown<br/>    my_function(2.3)</span></pre><p id="76f4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">(示例代码可在<a class="ae jd" href="https://github.com/shunsvineyard/shunsvineyard/blob/main/python_vs_cpp_series/polymorphism_and_duck_typing/python_overloading_1.py" rel="noopener ugc nofollow" target="_blank"> python_overloading_1.py </a>获得)</p><p id="3657" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在这个例子中，<em class="kv"> my_function </em>由于duck类型的性质，可以接受任何参数。因此，如果我们希望函数根据参数的类型执行不同的操作，函数需要检查参数是否存在，以确定要做什么。该示例的输出如下所示。</p><pre class="kh ki kj kk fd kl km kn ko aw kp bi"><span id="9e72" class="kq jf hi km b fi kr ks l kt ku">Do something when the type is integer<br/>Do something when the type is string<br/>Traceback (most recent call last):<br/>    ….<br/>    raise TypeError("Invalid type")<br/>TypeError: Invalid type</span></pre><p id="1767" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">如果我们用同一个名字定义多个函数会怎么样？</strong></p><p id="ab95" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果我们定义了两个或更多同名的函数，Python解释器将使用它扫描的最后一个函数。例如，下面的代码可以工作，但是只使用最后一个<em class="kv"> my_function </em>。</p><pre class="kh ki kj kk fd kl km kn ko aw kp bi"><span id="a230" class="kq jf hi km b fi kr ks l kt ku">def my_function(parameter):<br/><br/>    if type(parameter) is str:<br/>        print("Do something when the type is string")<br/><br/>    elif type(parameter) is int:<br/>        print("Do something when the type is integer")<br/><br/>    else:<br/>        raise TypeError("Invalid type")<br/><br/>def my_function(parameter):<br/>    print(parameter)<br/><br/>if __name__ == "__main__":<br/>    my_function(10)<br/>    my_function(2.3)</span></pre><p id="cb77" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">(示例代码可从<a class="ae jd" href="https://github.com/shunsvineyard/shunsvineyard/blob/main/python_vs_cpp_series/polymorphism_and_duck_typing/python_overloading_2.py" rel="noopener ugc nofollow" target="_blank">python _ overloading _ 2 . py</a>获得)</p><p id="d93f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">它的输出如下所示。</p><pre class="kh ki kj kk fd kl km kn ko aw kp bi"><span id="3e98" class="kq jf hi km b fi kr ks l kt ku">10 <br/>2.3</span></pre><p id="4454" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">最后一个<em class="kv"> my_function(parameter) </em>才是真正被调用的，这也是为什么<em class="kv"> my_function(2.3) </em>起作用的原因。</p><p id="f9f8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">带可选参数的函数</strong></p><p id="58e8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">除了定义同名但参数类型不同的函数之外，通过多态，我们还可以定义同名但参数数量不同的函数。Python不支持函数重载，但是它的<a class="ae jd" href="https://docs.python.org/3/tutorial/controlflow.html#keyword-arguments" rel="noopener ugc nofollow" target="_blank">关键字参数</a>和<a class="ae jd" href="https://docs.python.org/3/tutorial/controlflow.html#default-argument-values" rel="noopener ugc nofollow" target="_blank">默认参数</a>能力提供了一种定义接受不同数量参数的函数的方法。下面的代码片段演示了关键字参数和默认参数的用法。</p><pre class="kh ki kj kk fd kl km kn ko aw kp bi"><span id="7832" class="kq jf hi km b fi kr ks l kt ku">def my_function(parameter1, parameter2=None, parameter3="hello"):<br/>    print(parameter1)<br/>    if parameter2:<br/>        print(parameter2)<br/>    print(parameter3)<br/><br/>if __name__ == "__main__":<br/>    # Use default parameter2 and parameter3; parameter 1 does not<br/>    # have default value, so it cannot be omitted.<br/>    my_function(10)<br/><br/>    # Use default parameter2<br/>    my_function(parameter1=1, parameter3=5)<br/><br/>    # Use default parameter3; also notice that the order does not matter<br/>    # when using keyword arguments.<br/>    my_function(parameter2="world", parameter1=1)</span></pre><p id="e6a5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">(示例代码可在<a class="ae jd" href="https://github.com/shunsvineyard/shunsvineyard/blob/main/python_vs_cpp_series/polymorphism_and_duck_typing/python_overloading_3.py" rel="noopener ugc nofollow" target="_blank"> python_overloading_3.py </a>获得)</p><p id="817d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="kv"> my_function(10)的输出</em></p><pre class="kh ki kj kk fd kl km kn ko aw kp bi"><span id="d229" class="kq jf hi km b fi kr ks l kt ku">10<br/>hello</span></pre><p id="7cba" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="kv"> my_function(参数1=1，参数3=5) </em>的输出</p><pre class="kh ki kj kk fd kl km kn ko aw kp bi"><span id="be08" class="kq jf hi km b fi kr ks l kt ku">1<br/>5</span></pre><p id="c0f4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="kv">my _ function(parameter 2 = " world "，parameter1=1) </em>的输出</p><pre class="kh ki kj kk fd kl km kn ko aw kp bi"><span id="f1fc" class="kq jf hi km b fi kr ks l kt ku">1<br/>world<br/>hello</span></pre><p id="b387" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">使用鸭式打字时的缺点</strong></p><p id="7ba8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">使用duck typing，Python允许我们用不同的类型和不同数量的参数编写一个函数。然而，当我们需要函数基于参数执行某些操作时，我们将需要针对每种类型的几个if-else语句，如果if-else语句越来越长，其可读性就会降低。当这种情况发生时，我们可能需要考虑重构我们的代码。Python没有函数重载的好处，我们可以像在C++中一样，利用函数重载使用几个小函数来执行不同的操作。</p><h1 id="6812" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">类型安全和类型检查</h1><p id="e6d1" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">虽然Python是一种动态语言，但这并不意味着Python不关心类型安全。与C++不同，编译器会捕捉大多数与类型相关的错误，Python依靠林挺工具来完成这项工作。</p><p id="9b9d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">从Python 3.5开始，<a class="ae jd" href="https://www.python.org/dev/peps/pep-0484/" rel="noopener ugc nofollow" target="_blank"> PEP484 </a>引入了对类型提示的支持，类型检查工具如<a class="ae jd" href="http://mypy-lang.org/" rel="noopener ugc nofollow" target="_blank"> mypy </a>可以利用这些提示来检查Python程序。下面的示例显示了类型提示的示例。</p><p id="bc3a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">(Python类型提示的更多细节可以在<a class="ae jd" href="https://docs.python.org/3/library/typing.html" rel="noopener ugc nofollow" target="_blank">对类型提示的支持</a>中找到)</p><pre class="kh ki kj kk fd kl km kn ko aw kp bi"><span id="c149" class="kq jf hi km b fi kr ks l kt ku">from typing import Dict, Optional, Union<br/><br/>class MyClass:<br/><br/>    def my_method_1(self, parameter1: int, parameter2: str) -&gt; None:<br/>        pass<br/><br/>    def my_method_2(self, parameter: Union[int, str]) -&gt; Dict:<br/>        pass<br/><br/>def my_function(parameter: Optional[MyClass]):<br/>    pass</span></pre><p id="32f1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">(示例代码可从<a class="ae jd" href="https://github.com/shunsvineyard/shunsvineyard/blob/main/python_vs_cpp_series/polymorphism_and_duck_typing/python_type_hints_1.py" rel="noopener ugc nofollow" target="_blank"> python_type_hints_1.py </a>获得)</p><p id="ec2d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">尽管我们可以使用类型提示和林挺工具来确保类型安全，但是Python运行时并不强制函数或变量来满足其类型注释。如果我们忽略类型检查器生成的错误或警告，并且仍然传递无效的类型参数，Python解释器仍然会执行它。</p><p id="35e4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">比如下面例子中的<em class="kv"> my_function </em>期望<em class="kv">参数1 </em>为<em class="kv"> int </em>类型，<em class="kv">参数2 </em>为<em class="kv">字符串</em>类型。但是，当函数被调用并且<em class="kv">参数1 </em>的类型为<em class="kv">字符串</em>并且<em class="kv">参数2 </em>为<em class="kv">浮点</em>时，Python解释器会执行它。</p><pre class="kh ki kj kk fd kl km kn ko aw kp bi"><span id="53e8" class="kq jf hi km b fi kr ks l kt ku">def my_function(parameter1: int, parameter2: str) -&gt; None:<br/>    print(f"Parameter 1: {parameter1}")<br/>    print(f"Parameter 2: {parameter2}")<br/><br/>if __name__ == "__main__":<br/>    my_function(parameter1="Hello", parameter2=3.5)</span></pre><p id="ec4b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">(示例代码可从<a class="ae jd" href="https://github.com/shunsvineyard/shunsvineyard/blob/main/python_vs_cpp_series/polymorphism_and_duck_typing/python_type_hints_2.py" rel="noopener ugc nofollow" target="_blank"> python_type_hints_2.py </a>获得)</p><p id="67bf" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果我们运行类型检查器(在例子中使用<em class="kv"> mypy </em>，它将显示不兼容的类型错误。(以mypy为例)</p><pre class="kh ki kj kk fd kl km kn ko aw kp bi"><span id="1aaf" class="kq jf hi km b fi kr ks l kt ku">$ mypy python_type_hints_2.py <br/>python_type_hints_2.py:12: error: Argument "parameter1" to "my_function" has incompatible type "str"; expected "int"<br/>python_type_hints_2.py:12: error: Argument "parameter2" to "my_function" has incompatible type "float"; expected "str"<br/>Found 2 errors in 1 file (checked 1 source file)</span></pre><p id="fc76" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">然而，如果我们执行代码，它仍然会工作。</p><pre class="kh ki kj kk fd kl km kn ko aw kp bi"><span id="a6e1" class="kq jf hi km b fi kr ks l kt ku">$ python python_type_hints_2.py <br/>Parameter 1: Hello<br/>Parameter 2: 3.5</span></pre><p id="9e8d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Python类型提示仅用于林挺工具检查类型，但对运行时没有影响。</p><h1 id="031e" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">抽象基类和接口</h1><p id="8198" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">Python不像C++那样有虚函数或者接口的概念。然而，Python提供了一个基础设施，允许我们构建类似于接口功能的东西— <a class="ae jd" href="https://docs.python.org/3/library/abc.html" rel="noopener ugc nofollow" target="_blank">抽象基类</a> (ABC)。</p><p id="e214" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">ABC是一个不需要提供具体实现的类，但用于两个目的:</p><ol class=""><li id="cbb0" class="kw kx hi ih b ii ij im in iq ky iu kz iy la jc lb lc ld le bi translated">检查隐式接口兼容性。ABC定义了一个类的蓝图，可以用来检查类型兼容性。这个概念类似于c++中抽象类和虚函数的概念。</li><li id="f725" class="kw kx hi ih b ii lf im lg iq lh iu li iy lj jc lb lc ld le bi translated">检查实现的完整性。ABC定义了一组派生类必须实现的方法和属性。</li></ol><p id="2e24" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在下面的例子中，<em class="kv"> BasicBinaryTree </em>定义了二叉树的接口。任何派生的二叉树(如AVL树或二叉查找树)必须实现<em class="kv">基础二叉树</em>中定义的方法。</p><p id="7def" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">要使用ABC定义一个接口，接口类需要继承助手类— <a class="ae jd" href="https://docs.python.org/3/library/abc.html#abc.ABC" rel="noopener ugc nofollow" target="_blank"> abc。ABC </a>。派生类必须实现的方法使用<a class="ae jd" href="https://docs.python.org/3/library/abc.html#abc.abstractmethod" rel="noopener ugc nofollow" target="_blank">@ ABC . abstract method</a>decorator(相当于C++中的纯虚函数)</p><pre class="kh ki kj kk fd kl km kn ko aw kp bi"><span id="5e32" class="kq jf hi km b fi kr ks l kt ku">class BasicBinaryTree(abc.ABC):<br/><br/>    @abc.abstractmethod<br/>    def insert(self, key: int) -&gt; None:<br/>        raise NotImplementedError()<br/><br/>    @abc.abstractmethod<br/>    def delete(self, key: int) -&gt; None:<br/>        raise NotImplementedError()<br/><br/>    @abc.abstractmethod<br/>    def search(self, key: int) -&gt; Node:<br/>        raise NotImplementedError()</span></pre><p id="8871" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">派生类(以AVLTree为例)继承了抽象基类(即本例中的<em class="kv"> BasicBinaryTree </em>)并实现了用<em class="kv">@ ABC . abstactmethod</em>decorator定义的方法。</p><pre class="kh ki kj kk fd kl km kn ko aw kp bi"><span id="9051" class="kq jf hi km b fi kr ks l kt ku">class AVLTree(BasicBinaryTree):<br/>    """AVL Tree implementation."""<br/><br/>    def insert(self, key: int) -&gt; None:<br/>        # The AVL Tree implementation<br/>        pass<br/><br/>    def delete(self, key: int) -&gt; None:<br/>        # The AVL Tree implementation<br/>        pass<br/><br/>    def search(self, key: int) -&gt; AVLNode:<br/>        # The AVL Tree implementation<br/>        pass</span></pre><p id="8230" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">二叉树接口的完整例子如下(也可以在<a class="ae jd" href="https://github.com/shunsvineyard/shunsvineyard/blob/main/python_vs_cpp_series/polymorphism_and_duck_typing/python_interface.py" rel="noopener ugc nofollow" target="_blank"> python_interface.py </a>获得)。</p><pre class="kh ki kj kk fd kl km kn ko aw kp bi"><span id="4c59" class="kq jf hi km b fi kr ks l kt ku">import abc<br/><br/>from typing import Optional<br/>from dataclasses import dataclass<br/><br/>@dataclass<br/>class Node:<br/>    """Basic binary tree node definition."""<br/><br/>    key: int<br/>    left: Optional["Node"] = None<br/>    right: Optional["Node"] = None<br/>    parent: Optional["Node"] = None<br/><br/>class BasicBinaryTree(abc.ABC):<br/>    """An abstract base class defines the interface for any type of binary trees.<br/><br/>    The derived class should implement the abstract method defined in the abstract<br/>    base class.<br/>    """<br/><br/>    @abc.abstractmethod<br/>    def insert(self, key: int) -&gt; None:<br/>        raise NotImplementedError()<br/><br/>    @abc.abstractmethod<br/>    def delete(self, key: int) -&gt; None:<br/>        raise NotImplementedError()<br/><br/>    @abc.abstractmethod<br/>    def search(self, key: int) -&gt; Node:<br/>        raise NotImplementedError()<br/><br/>class BinarySearchTree(BasicBinaryTree):<br/>    """Binary Search Tree."""<br/><br/>    def insert(self, key: int) -&gt; None:<br/>        # The BST implementation<br/>        pass<br/><br/>    def delete(self, key: int) -&gt; None:<br/>        # The BST implementation<br/>        pass<br/><br/>    def search(self, key: int) -&gt; Node:<br/>        # The BST implementation<br/>        pass<br/><br/>@dataclass<br/>class AVLNode(Node):<br/>    """AVL Tree node definition. Derived from Node."""<br/><br/>    left: Optional["AVLNode"] = None<br/>    right: Optional["AVLNode"] = None<br/>    parent: Optional["AVLNode"] = None<br/>    height: int = 0<br/><br/>class AVLTree(BasicBinaryTree):<br/>    """AVL Tree implementation."""<br/><br/>    def insert(self, key: int) -&gt; None:<br/>        # The AVL Tree implementation<br/>        pass<br/><br/>    def delete(self, key: int) -&gt; None:<br/>        # The AVL Tree implementation<br/>        pass<br/><br/>    def search(self, key: int) -&gt; AVLNode:<br/>        # The AVL Tree implementation<br/>        pass</span></pre><h1 id="a606" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">结论</h1><p id="eb0f" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">Python对多态性的支持可能与C++不同，但多态性的概念仍然有效，并在Python程序中广泛使用，类型安全的重要性对于Python程序仍然至关重要。</p></div><div class="ab cl lk ll gp lm" role="separator"><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp"/></div><div class="hb hc hd he hf"><p id="172a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="kv">原载于2021年10月10日</em><a class="ae jd" href="https://shunsvineyard.info/2021/10/10/python-vs-c-series-polymorphism-and-duck-typing/" rel="noopener ugc nofollow" target="_blank"><em class="kv">https://shunsvineyard . info</em></a><em class="kv">。</em></p></div></div>    
</body>
</html>