<html>
<head>
<title>MVVM — Bind views</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">MVVM —绑定视图</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/mvvm-bind-views-6eb261579bb?source=collection_archive---------5-----------------------#2021-05-19">https://medium.com/nerd-for-tech/mvvm-bind-views-6eb261579bb?source=collection_archive---------5-----------------------#2021-05-19</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="b856" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">一种使用香草雨燕的方法</h2></div><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ix"><img src="../Images/261b6649f355e1d7594a9e3020a029fb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lTuOz6-sra__NJ8gZS440w.png"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">照片由<a class="ae jn" href="https://unsplash.com/@greg_rosenke?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">格雷格·罗森克</a>在<a class="ae jn" href="https://unsplash.com/s/photos/bind?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="8198" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">嗨，开发者。我将要向您展示的是我通常使用 Swift 将<code class="du kk kl km kn b">ViewModel</code>属性与<code class="du kk kl km kn b">Views/ViewControllers</code>挂钩的方式。如果你的项目使用<code class="du kk kl km kn b">SwiftUI and/or Combine</code>，这可能与你无关。然而，将视图绑定到属性更改的概念非常相似。我将尽可能地清晰和简洁，所以像将 UIViews 添加到层次结构或 DispatchQueues 之类的细节都会被考虑。</p><p id="0c42" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">在我继续下去之前，一个快速的免责声明<em class="ko">——我发现这是一个有用的方法，这并不意味着它是对的或错的。</em></p></div><div class="ab cl kp kq gp kr" role="separator"><span class="ks bw bk kt ku kv"/><span class="ks bw bk kt ku kv"/><span class="ks bw bk kt ku"/></div><div class="hb hc hd he hf"><p id="f314" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">也就是说，这些是我们将在这篇文章中看到的演员:</p><ul class=""><li id="dd52" class="kw kx hi jq b jr js ju jv jx ky kb kz kf la kj lb lc ld le bi translated">男— <em class="ko">人</em></li><li id="f018" class="kw kx hi jq b jr lf ju lg jx lh kb li kf lj kj lb lc ld le bi translated">V — <em class="ko">视图控制器</em></li><li id="6d4d" class="kw kx hi jq b jr lf ju lg jx lh kb li kf lj kj lb lc ld le bi translated">虚拟机— <em class="ko">视图模型</em></li></ul><p id="88ae" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">要构建的特性包括获取这个人的信息并在标签上显示它——这个概念可以推广到任何类型的视图、表格、集合等。下面是一个 MVVM 模式的基本实现。</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="lk ll l"/></div><figcaption class="jj jk et er es jl jm bd b be z dx translated"><em class="lm">关于 MVVM 工作的更多细节，这里有一个不错的帖子【链接】</em></figcaption></figure></div><div class="ab cl kp kq gp kr" role="separator"><span class="ks bw bk kt ku kv"/><span class="ks bw bk kt ku kv"/><span class="ks bw bk kt ku"/></div><div class="hb hc hd he hf"><p id="dc5f" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi ln translated"><span class="l lo lp lq bm lr ls lt lu lv di"> L </span> et's say <code class="du kk kl km kn b">ViewModel</code>需要从一个 API 或任何外部服务中获取这个人的信息(我在这篇文章中没有深入探讨)。一旦检索到数据，<code class="du kk kl km kn b">ViewModel</code>执行块<code class="du kk kl km kn b">onPersonChanged</code>来通知视图数据已经更新。</p><pre class="iy iz ja jb fd lw kn lx ly aw lz bi"><span id="9300" class="ma mb hi kn b fi mc md l me mf">class ViewModel {<br/>    <br/>    var onPersonChanged: ((Person) -&gt; Void)?<br/>    <br/>    func fetchPosts() {<br/>        // these values are hard-coded. Not relevant(to this post)<br/>        // where this data is coming from.<br/>        let person = Person(id: 1, name: "Cristhian", age: 26)<br/>        onPersonChanged?(person)<br/>    }<br/>}</span></pre><p id="0772" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">这意味着，<code class="du kk kl km kn b">ViewController</code>需要设置我们上面提到的那个块，所以当这个人的信息改变时，视图可以“刷新”UI 组件值。</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="lk ll l"/></div></figure><p id="3a7b" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">函数<code class="du kk kl km kn b">refreshUI</code>简单地获取一个人并将值设置到标签上。另一方面，<code class="du kk kl km kn b">addObservers</code>函数设置人员数据更新时的回调。</p><blockquote class="mg mh mi"><p id="8ea9" class="jo jp ko jq b jr js ij jt ju jv im jw mj jy jz ka mk kc kd ke ml kg kh ki kj hb bi translated">到目前为止，这个实现没有什么不好，但是，当视图增长时，即使一些值没有改变，也会调用函数 refreshUI。</p></blockquote><p id="7a8b" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">这就是为什么我现在的计划是挑选出 viewModel 的每一个属性，以获得完全的独立性和可测试性。</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="lk ll l"/></div></figure><p id="f096" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">现在你可能想知道——那个<code class="du kk kl km kn b">Dynamic</code>类是什么？嗯，这就是这篇文章的重点。<code class="du kk kl km kn b">Dynamic</code>是一个泛型类，它允许我们对其值的变化做出反应。这意味着，<code class="du kk kl km kn b">ViewController</code>可以观察到<code class="du kk kl km kn b">ViewModel</code>的动态属性的变化，然后对其进行操作，但首先，让我们看看类。</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="lk ll l"/></div></figure><p id="86f1" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">正如您所看到的，这是一个非常简单但功能强大的类，只要设置了值，它就会执行块<code class="du kk kl km kn b">listener</code>。<code class="du kk kl km kn b">Dynamic</code>还公开了一个名为<code class="du kk kl km kn b">bind</code>的函数来设置监听器。现在让我们看看<code class="du kk kl km kn b">ViewController</code>是如何挂钩到<code class="du kk kl km kn b">ViewModel</code>属性的。</p><pre class="iy iz ja jb fd lw kn lx ly aw lz bi"><span id="a8b4" class="ma mb hi kn b fi mc md l me mf">private func addObservers() {<br/>    viewModel.personName.bind { [weak self] name in<br/>        self?.nameLabel.text = name<br/>    }<br/>    <br/>    viewModel.personAge.bind { [weak self] age in<br/>        self?.ageLabel.text = "\(age)"<br/>    }<br/>}</span></pre></div><div class="ab cl kp kq gp kr" role="separator"><span class="ks bw bk kt ku kv"/><span class="ks bw bk kt ku kv"/><span class="ks bw bk kt ku"/></div><div class="hb hc hd he hf"><p id="5d7d" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><em class="ko">感谢阅读。我希望你喜欢这段代码，如果它对你有用，不要害羞👏关于这篇文章。下次见。</em></p></div></div>    
</body>
</html>