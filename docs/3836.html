<html>
<head>
<title>Binary Search Problems- Search a 2D Matrix [Leetcode — 74]</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">二分搜索法问题-搜索一个2D矩阵[Leetcode — 74]</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/binary-search-problems-search-a-2d-matrix-leetcode-74-7facd6f2db53?source=collection_archive---------5-----------------------#2021-06-26">https://medium.com/nerd-for-tech/binary-search-problems-search-a-2d-matrix-leetcode-74-7facd6f2db53?source=collection_archive---------5-----------------------#2021-06-26</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="e7c3" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">链接到问题:</h2></div><div class="ix iy ez fb iz ja"><a href="https://leetcode.com/problems/search-a-2d-matrix/" rel="noopener  ugc nofollow" target="_blank"><div class="jb ab dw"><div class="jc ab jd cl cj je"><h2 class="bd hj fi z dy jf ea eb jg ed ef hh bi translated">搜索2D矩阵- LeetCode</h2><div class="jh l"><h3 class="bd b fi z dy jf ea eb jg ed ef dx translated">写一个在m×n矩阵中搜索一个值的有效算法。该矩阵具有以下特性…</h3></div><div class="ji l"><p class="bd b fp z dy jf ea eb jg ed ef dx translated">leetcode.com</p></div></div><div class="jj l"><div class="jk l jl jm jn jj jo jp ja"/></div></div></a></div><h2 id="7f67" class="jq jr hi bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">问题描述</h2><p id="0105" class="pw-post-body-paragraph ko kp hi kq b kr ks ij kt ku kv im kw kb kx ky kz kf la lb lc kj ld le lf lg hb bi translated">编写一个有效的算法，在一个<code class="du lh li lj lk b">m x n</code>矩阵中搜索一个值。该矩阵具有以下特性:</p><ul class=""><li id="b4a7" class="ll lm hi kq b kr ln ku lo kb lp kf lq kj lr lg ls lt lu lv bi translated">每行中的整数从左到右排序。</li><li id="e072" class="ll lm hi kq b kr lw ku lx kb ly kf lz kj ma lg ls lt lu lv bi translated">每行的第一个整数大于前一行的最后一个整数。</li></ul><div class="mb mc md me fd ab cb"><figure class="mf mg mh mi mj mk ml paragraph-image"><div role="button" tabindex="0" class="mm mn di mo bf mp"><img src="../Images/d204bb4ad25bf7a2b6212775fb84d08d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1032/format:webp/1*WDwaM7s2mIvS7l6TPLaRAA.jpeg"/></div></figure><figure class="mf mg mr mi mj mk ml paragraph-image"><div role="button" tabindex="0" class="mm mn di mo bf mp"><img src="../Images/fcd24e72c3ba92a5abf634b5c9fa5a1f.png" data-original-src="https://miro.medium.com/v2/resize:fit:970/format:webp/1*2lddYQj7pybr6HvvCC8iUA.jpeg"/></div></figure></div><h2 id="58f8" class="jq jr hi bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">天真的解决方案:</h2><p id="f17c" class="pw-post-body-paragraph ko kp hi kq b kr ks ij kt ku kv im kw kb kx ky kz kf la lb lc kj ld le lf lg hb bi translated">遍历矩阵中的每个元素，并将其与目标值进行比较。时间复杂度为O(mn)，效率非常低。</p><h2 id="483e" class="jq jr hi bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">体面的解决方案:</h2><p id="dce1" class="pw-post-body-paragraph ko kp hi kq b kr ks ij kt ku kv im kw kb kx ky kz kf la lb lc kj ld le lf lg hb bi translated">因为每一行都是排序的，我们可以利用二分搜索法来搜索每一行。这个解的时间复杂度是O(nlogm)。logm是二分搜索法在一行中花费的时间，因为我们对每一行都这样做，所以O(n*logm)是总的时间复杂度。</p><h2 id="de6b" class="jq jr hi bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">高效解决方案:</h2><p id="a6d1" class="pw-post-body-paragraph ko kp hi kq b kr ks ij kt ku kv im kw kb kx ky kz kf la lb lc kj ld le lf lg hb bi translated">上面提出的O(nlogm)解决方案是一个不错的解决方案，但我们可以进一步优化它。我们不需要遍历每一行。该问题指出每一行的第一个整数大于前一行的最后一个整数。因此，每一行都被排序，下一行包含的元素也比前一行多。</p><p id="315e" class="pw-post-body-paragraph ko kp hi kq b kr ln ij kt ku lo im kw kb ms ky kz kf mt lb lc kj mu le lf lg hb bi translated">因此，我们可以使用二分搜索法来查找所需的行。我们从矩阵的中间行开始，如果目标元素在该行的范围内，我们就对该行应用二分搜索法。否则，如果目标元素小于行的起始元素，我们在前一行中搜索，如果目标元素大于行的最后一个元素，我们在下一行中搜索。</p><p id="437b" class="pw-post-body-paragraph ko kp hi kq b kr ln ij kt ku lo im kw kb ms ky kz kf mt lb lc kj mu le lf lg hb bi translated">这样，我们将搜索的行数从n减少到logn。</p><figure class="mb mc md me fd mg"><div class="bz dy l di"><div class="mv mw l"/></div></figure><p id="b805" class="pw-post-body-paragraph ko kp hi kq b kr ln ij kt ku lo im kw kb ms ky kz kf mt lb lc kj mu le lf lg hb bi translated">总体时间复杂度为O(logm + logn)。返回二分搜索法的结果需要logm，我们在logn行中搜索。</p><h2 id="1ae6" class="jq jr hi bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">注意:</h2><p id="03ff" class="pw-post-body-paragraph ko kp hi kq b kr ks ij kt ku kv im kw kb kx ky kz kf la lb lc kj ld le lf lg hb bi translated">时间复杂度是O(logm + logn)而不是O(logm*logn)。只有当我们确定目标在该行的范围内时，我们才连续进行二分搜索法。因此，操作总数将是O(logm + logn)。</p><p id="d5f7" class="pw-post-body-paragraph ko kp hi kq b kr ln ij kt ku lo im kw kb ms ky kz kf mt lb lc kj mu le lf lg hb bi translated">将在我的下一篇文章中解决“2D矩阵中的搜索II”。</p></div></div>    
</body>
</html>