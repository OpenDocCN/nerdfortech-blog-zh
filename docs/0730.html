<html>
<head>
<title>C++ Libraries — Part II: Implementation</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">C++库—第二部分:实现</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/c-libraries-part-ii-implementation-44dab21e50ae?source=collection_archive---------4-----------------------#2021-02-09">https://medium.com/nerd-for-tech/c-libraries-part-ii-implementation-44dab21e50ae?source=collection_archive---------4-----------------------#2021-02-09</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="d540" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这篇博文是<a class="ae jd" href="https://inballevi.medium.com/c-libraries-part-i-design-9ed997dca8f3" rel="noopener"> C++库的延续——第一部分:设计</a></p><p id="9d81" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在这一部分，我们将回顾创建C++库的基础知识。</p></div><div class="ab cl je jf gp jg" role="separator"><span class="jh bw bk ji jj jk"/><span class="jh bw bk ji jj jk"/><span class="jh bw bk ji jj"/></div><div class="hb hc hd he hf"><h1 id="a2c7" class="jl jm hi bd jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki bi translated">二。为C++库创建代码的技术</h1><p id="40db" class="pw-post-body-paragraph if ig hi ih b ii kj ik il im kk io ip iq kl is it iu km iw ix iy kn ja jb jc hb bi translated">C++提供了多种创建库代码的方法:</p><figure class="kp kq kr ks fd kt er es paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="er es ko"><img src="../Images/394eb1baaf84890e6932a39488fad01c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YofkLaqumk_5AFt5OuRigA.png"/></div></div></figure><p id="654a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> (I)和(IV)可以打包成一个包(。o /。a /。so)，而(II)和(III)必须作为源代码提供。</strong></p><h1 id="8865" class="jl jm hi bd jn jo la jq jr js lb ju jv jw lc jy jz ka ld kc kd ke le kg kh ki bi translated">三。打包库代码的技术</h1><p id="9bf0" class="pw-post-body-paragraph if ig hi ih b ii kj ik il im kk io ip iq kl is it iu km iw ix iy kn ja jb jc hb bi translated">(注意:博客的其余部分将解释创建库的技术细节。示例和说明假设基于Linux的操作系统使用CMake工具，基于Windows的操作系统具有非常相似的过程)</p><p id="42c7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">正如在上面的“代码合成”一节中详细提到的，一般来说，用户有三种主要的方式来使用库:</p><ol class=""><li id="66b6" class="lf lg hi ih b ii ij im in iq lh iu li iy lj jc lk ll lm ln bi translated"><strong class="ih hj">使用库源代码</strong> —这通常与上面的选项(III)一起使用，因为模板可以用来“按需”创建代码，但是你也可以轻松地将源代码打包到库中。</li><li id="347b" class="lf lg hi ih b ii lo im lp iq lq iu lr iy ls jc lk ll lm ln bi translated"><strong class="ih hj">与库静态链接</strong> —库代码将作为使用程序的一部分嵌入<strong class="ih hj">(库代码将是二进制的一部分)。<br/>该库可以作为:<br/> -一个目标文件(。o) <br/> -目标文件的集合(“目标库”)<br/> -与“索引”文件打包在一起的目标文件的集合。一)<br/>(一个“档案库”)</strong></li><li id="751a" class="lf lg hi ih b ii lo im lp iq lq iu lr iy ls jc lk ll lm ln bi translated"><strong class="ih hj">与库动态链接</strong> —用户代码将<strong class="ih hj">引用库代码</strong>(符号)。当运行用户代码时，加载程序将库加载到RAM中，并且<strong class="ih hj">提供这些引用</strong>。<br/>在这种情况下，<strong class="ih hj">定义组合的是库</strong>提供的符号(ABI——应用二进制接口)。<br/>如果库不能提供它们(在编译时，被链接器发现，或者在加载时，被加载器发现)<strong class="ih hj">我们将得到一个链接器/加载器错误。</strong></li></ol><p id="7166" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">还存在其他类型，但在本文中不会讨论。</p><p id="7e87" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">以上所有选项都可以在库项目(或文件夹)的CMakeLists文件中配置</p><ol class=""><li id="6c0e" class="lf lg hi ih b ii ij im in iq lh iu li iy lj jc lk ll lm ln bi translated">对于源库—创建“接口”库。</li></ol><figure class="kp kq kr ks fd kt er es paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="er es lt"><img src="../Images/a06b6fcb4f455cc2e4cf50daf0baeaa4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1316/format:webp/1*IEpLV9E7FBQzrPzf8bdOTg.png"/></div></div></figure><p id="a4ad" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">2.创建对象/静态库:</p><p id="a6b4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">。o(目标库)</p><figure class="kp kq kr ks fd kt er es paragraph-image"><div class="er es lu"><img src="../Images/1eea3e43f3c5f91014a24a28feadc364.png" data-original-src="https://miro.medium.com/v2/resize:fit:1326/format:webp/1*sygr3VD772btITB-si_8FQ.png"/></div></figure><p id="9320" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">。a(静态库—存档)</p><figure class="kp kq kr ks fd kt er es paragraph-image"><div class="er es lt"><img src="../Images/f754d35c4649b2252b95fc26ae2f0874.png" data-original-src="https://miro.medium.com/v2/resize:fit:1316/format:webp/1*PHszmU3hJNrCSYLJfPkOLA.png"/></div></figure><p id="519c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">3.创建动态库:</p><p id="1edb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">。so(共享对象)</p><figure class="kp kq kr ks fd kt er es paragraph-image"><div class="er es lv"><img src="../Images/f354c52598f918c55832a7e400633abd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1308/format:webp/1*XP9XLy6TbTGhqIfqEbFssA.png"/></div></figure><p id="cfa2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">有关如何在gcc中手动创建每个选项的更多细节和技术规范，请参见:<a class="ae jd" href="https://www.cprogramming.com/tutorial/shared-libraries-linux-gcc.html" rel="noopener ugc nofollow" target="_blank">https://www . c programming . com/tutorial/shared-libraries-Linux-gcc . html</a></p><h1 id="506f" class="jl jm hi bd jn jo la jq jr js lb ju jv jw lc jy jz ka ld kc kd ke le kg kh ki bi translated">四。用用户代码组成库</h1><p id="ef19" class="pw-post-body-paragraph if ig hi ih b ii kj ik il im kk io ip iq kl is it iu km iw ix iy kn ja jb jc hb bi translated">这是创建main.out可执行文件的过程。</p><h2 id="69dc" class="lw jm hi bd jn lx ly lz jr ma mb mc jv iq md me jz iu mf mg kd iy mh mi kh mj bi translated">用用户代码构成源代码库</h2><p id="ce14" class="pw-post-body-paragraph if ig hi ih b ii kj ik il im kk io ip iq kl is it iu km iw ix iy kn ja jb jc hb bi translated">编译源代码时，“main.out”是唯一需要在目标上的文件。</p><figure class="kp kq kr ks fd kt er es paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="er es mk"><img src="../Images/901f54e86d86a964be9162906e44c9c7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6DTiYjZi0kxPVh-VaLmCdQ.png"/></div></div></figure><h2 id="f032" class="lw jm hi bd jn lx ly lz jr ma mb mc jv iq md me jz iu mf mg kd iy mh mi kh mj bi translated">将库组成为对象(静态/动态库)</h2><figure class="kp kq kr ks fd kt er es paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="er es ml"><img src="../Images/2498ea873bc9f3262e1912ff42871c15.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ru3c2zlKWqeo1ji5T98lRg.png"/></div></div></figure><p id="60af" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">重要的是:以防万一。因此，main.out将不包含库的二进制文件。相反，加载程序将加载。所以当main.out被执行时。</p><h1 id="dbeb" class="jl jm hi bd jn jo la jq jr js lb ju jv jw lc jy jz ka ld kc kd ke le kg kh ki bi translated">动词 （verb的缩写）交付新图书馆的方式</h1><p id="2f84" class="pw-post-body-paragraph if ig hi ih b ii kj ik il im kk io ip iq kl is it iu km iw ix iy kn ja jb jc hb bi translated">C++提供了交付库的多个原因(部分列表):</p><figure class="kp kq kr ks fd kt er es paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="er es mm"><img src="../Images/d9980ab00f2b15c3a4ea933ece4fef31.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9xndEGvTfEuBiI41woDO0w.png"/></div></div></figure><p id="7120" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> (*)重要提示:注意(III)和(IV)的区别仅在于出现在主文件中的预期用途(而不是库的创建)。</strong></p><p id="2c0e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">以上选项之间的比较:</p><figure class="kp kq kr ks fd kt er es paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="er es mn"><img src="../Images/dbeec7e3e3992c8cbedc01c38e6281a2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TN8yKYaNyvBk8krRsFAZSg.png"/></div></div></figure><p id="ded4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">最小大小:只有用户使用的那部分代码的大小(如果分成。o文件—只有。o包含用户调用的函数)</p><p id="1343" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">最大大小:库中所有代码的大小(因为动态链接不知道用户将使用代码的哪一部分，所以。所以必须包含所有代码)</p><h2 id="c8e6" class="lw jm hi bd jn lx ly lz jr ma mb mc jv iq md me jz iu mf mg kd iy mh mi kh mj bi translated">与表格相关的附加信息的链接:</h2><ul class=""><li id="8472" class="lf lg hi ih b ii kj im kk iq mo iu mp iy mq jc mr ll lm ln bi translated">相同的代码可以用多种方式创建:<br/> <a class="ae jd" href="https://stackoverflow.com/questions/25606736/library-design-allow-user-to-decide-between-header-only-and-dynamically-linke" rel="noopener ugc nofollow" target="_blank">库-设计-允许用户-仅在头间决定-和-动态-克林</a></li><li id="ea7f" class="lf lg hi ih b ii lo im lp iq lq iu lr iy ls jc mr ll lm ln bi translated">静态与动态库大小:<br/> <a class="ae jd" href="https://stackoverflow.com/questions/27728385/how-statically-linked-binaries-could-be-smaller-than-dynamically-linked-binaries" rel="noopener ugc nofollow" target="_blank">静态链接的二进制文件比动态链接的二进制文件小多少</a></li></ul><h1 id="0bc8" class="jl jm hi bd jn jo la jq jr js lb ju jv jw lc jy jz ka ld kc kd ke le kg kh ki bi translated">不及物动词收场白</h1><p id="487d" class="pw-post-body-paragraph if ig hi ih b ii kj ik il im kk io ip iq kl is it iu km iw ix iy kn ja jb jc hb bi translated">当然，还有其他的主题需要解决，这篇博客试图涵盖最基本和最常见的技术。</p><p id="61f2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">C++20支持“可组合”代码的新结构形式，这可以改变构建库的过程，特别是——消除对头文件的需要。这种形式被称为<em class="ms">模块</em>。这是一个完全不同的话题，值得单独发表。</p></div><div class="ab cl je jf gp jg" role="separator"><span class="jh bw bk ji jj jk"/><span class="jh bw bk ji jj jk"/><span class="jh bw bk ji jj"/></div><div class="hb hc hd he hf"><p id="969a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">感谢Hana Dusíková和Billy Baker审阅这篇文章。</p><p id="0cb4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">感谢您的阅读，希望这篇博文对您有所帮助。:)</p><p id="be8c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">更新(2022年3月):我已经创建了<a class="ae jd" href="https://github.com/inbal2l/TestCMake" rel="noopener ugc nofollow" target="_blank"> TestCMake </a> repo，其中包含针对静态和仅头文件库的CMake文件的简化示例(很大程度上与<a class="ae jd" href="https://cmake.org/cmake/help/latest/guide/tutorial/index.html#" rel="noopener ugc nofollow" target="_blank">官方教程</a>一致)。</p></div></div>    
</body>
</html>