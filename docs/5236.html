<html>
<head>
<title>Using Net::HTTP in a Rails Project</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在Rails项目中使用Net::HTTP</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/using-net-http-in-a-rails-project-1cdcc5b3a99c?source=collection_archive---------3-----------------------#2021-09-10">https://medium.com/nerd-for-tech/using-net-http-in-a-rails-project-1cdcc5b3a99c?source=collection_archive---------3-----------------------#2021-09-10</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/fb086b88033e5e98fe76bfa483759f50.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*45UF8Ym2PogrZqJ735NiCQ.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">我的项目主页</figcaption></figure><p id="63de" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">我最近完成了我的第一个Ruby on Rails项目，我很兴奋地创建了它。我的项目名为<a class="ae js" href="https://life-lister.herokuapp.com" rel="noopener ugc nofollow" target="_blank"> Life-Lister </a>，是一个允许用户创建生活列表(详细列出一个人见过的每一种生物)并与其他人分享的应用程序。生命列表主要由鸟类和蝴蝶使用，但我的应用程序适用于所有类型的生物。</p><p id="1ed2" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">我希望实现的一个特性是能够提交一个生物体的名称(以及关于观察的细节),并让我的前端神奇地生成一个记录，其中包含生物体的学名、俗名和照片，以及用户输入的细节。为了做到这一点，我计划再次利用Naturalist API (我在我的第一个<a class="ae js" href="https://megan-mccarty.medium.com/javascript-and-scope-what-i-learned-from-my-first-javascript-project-9fecc0943a1b" rel="noopener">普通JavaScript项目</a>中使用了它)，但是我必须在后端处理fetch请求，这是我以前从未做过的事情。</p><p id="e44c" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">但是，在我开始处理获取请求之前，我需要首先为项目绘制模型。我决定我需要三个模型:一个用户、一个分类单元(保存一个有机体对象)和一个记录(保存关于一个特定发现的信息)。一个用户可能有许多记录，一个分类单元也可能有许多记录。一个记录可能同时属于一个用户和一个分类单元。下面是我提出的数据库模式的图表，使用<a class="ae js" href="https://dbdiagram.io/home" rel="noopener ugc nofollow" target="_blank"> db.diagram </a>生成:</p><figure class="ju jv jw jx fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es jt"><img src="../Images/2d8d5c10816dc971effeb2c6fdc04a8c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pHVW8RNuoZJAlUhwB3I__Q.png"/></div></div></figure><p id="c5fa" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">一旦我建立了我的模型，我就使用一个名为Net:HTTP的库，它内置在Rails中。在我的项目的app文件夹中，我创建了一个名为services的新目录，在里面，我创建了一个新的类来处理我的fetch请求:</p><pre class="ju jv jw jx fd jy jz ka kb aw kc bi"><span id="d8f9" class="kd ke hi jz b fi kf kg l kh ki"># services/inaturalist_api.rb</span><span id="d94f" class="kd ke hi jz b fi kj kg l kh ki">require 'net/http'</span><span id="a21c" class="kd ke hi jz b fi kj kg l kh ki">class InaturalistApi<br/>  def self.fetch(taxon)<br/>    url = URI("https://api.inaturalist.org/v1/taxa?q=#{taxon}&amp;rank_level=10")<br/>    res = Net::HTTP.get(url)<br/>    JSON.parse(res)<br/>  end<br/>end</span></pre><p id="87dd" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">HTTP使得在Rails中进行获取请求变得非常容易。在我的自定义类方法<code class="du kk kl km jz b">#fetch</code>中，我为用户通过前端提交的生物体名称传递了一个参数。因为iNaturalist API超级灵活，我不用写什么复杂的逻辑来判断输入的名字是通用名还是学名；我可以把它直接插入网址。获取请求的响应被保存到变量<code class="du kk kl km jz b">res</code>，最后一行将<code class="du kk kl km jz b">res</code>解析成JSON。</p><p id="03b4" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">接下来，我在分类模型中创建了一个定制的类方法，<code class="du kk kl km jz b">#taxon_from_api</code>:</p><pre class="ju jv jw jx fd jy jz ka kb aw kc bi"><span id="4d93" class="kd ke hi jz b fi kf kg l kh ki"># models/taxon.rb</span><span id="b4d2" class="kd ke hi jz b fi kj kg l kh ki">class Taxon &lt; ApplicationRecord<br/>  ...</span><span id="0666" class="kd ke hi jz b fi kj kg l kh ki">  def self.taxon_from_api(result)<br/>    self.find_or_create_by(<br/>      species: result['results'].first['name'],<br/>      common_name: result['results'].first['preferred_common_name'],<br/>      image: result['results'].first['default_photo']['medium_url']<br/>    )<br/>  end<br/>end</span></pre><p id="645f" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">正如我的自定义类方法的名字所暗示的那样，我从iNaturalist API中获取信息并保存到我的数据库中。我使用了活动记录中的一个内置类方法<code class="du kk kl km jz b">#find_or_create_by</code>，这样，如果几个用户看到了帝王蝶，我就没有重复的帝王蝶分类对象。相反，如果帝王蝶已经存在，我们就使用它；如果没有，则创建一个新的分类对象。从JSON响应中，我可以获取物种名、通用名和图像，并将其保存到我的API的数据库中。</p><p id="7e0a" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">最后，我需要将所有东西连接在一起。因为用户实际上是提交一个表单来创建一个新的记录对象(而不是一个新的分类对象)，所以我需要处理记录控制器内部的一切，特别是在<code class="du kk kl km jz b">#create</code>方法中:</p><pre class="ju jv jw jx fd jy jz ka kb aw kc bi"><span id="8875" class="kd ke hi jz b fi kf kg l kh ki"># controllers/records_controller.rb</span><span id="ec68" class="kd ke hi jz b fi kj kg l kh ki">class RecordsController &lt; ApplicationController<br/>  ...</span><span id="2276" class="kd ke hi jz b fi kj kg l kh ki">  def create<br/>    taxon_entered = params[:taxon]<br/>    result = InaturalistApi.fetch(taxon_entered)<br/>    taxon = Taxon.taxon_from_api(result)</span></pre><p id="9413" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">首先，我在前端从用户输入中获取分类单元的名称(使用params)，并将其保存到变量<code class="du kk kl km jz b">taxon_entered</code>。我将该变量传递到我的自定义<code class="du kk kl km jz b">#fetch</code>方法中，并将结果保存到名副其实的变量<code class="du kk kl km jz b">result</code>中。(我喜欢Rails的一点是，不像使用Django或React JS，我不需要导出<code class="du kk kl km jz b">InaturalistApi</code>类及其自定义的<code class="du kk kl km jz b">#fetch</code>方法，并将它们导入我的控制器。)接下来，我将<code class="du kk kl km jz b">result</code>传递给分类定制方法<code class="du kk kl km jz b">#taxon_from_api</code>，查看该记录是否已经存在于我的数据库中，如果不存在，为我创建一个新对象。到目前为止一切顺利！</p><p id="cf61" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">然后我在我的<code class="du kk kl km jz b">#create</code>方法中添加了另一行来获取当前登录的用户(因为我需要知道这个新记录属于谁！):</p><pre class="ju jv jw jx fd jy jz ka kb aw kc bi"><span id="1ad3" class="kd ke hi jz b fi kf kg l kh ki">user = User.find_by(id: session[:user_id])</span></pre><p id="c37a" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">然后，剩下的方法如下:</p><pre class="ju jv jw jx fd jy jz ka kb aw kc bi"><span id="e8c0" class="kd ke hi jz b fi kf kg l kh ki">record = Record.create!(<br/>  category: params[:category],<br/>  date_seen: params[:date],<br/>  notes: params[:notes],<br/>  taxon_id: taxon.id,<br/>  user_id: user.id<br/>)</span><span id="792d" class="kd ke hi jz b fi kj kg l kh ki">render json: record, status: :created</span></pre><p id="3351" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">既然我已经有了分类单元和用户，那么我可以用用户从前端输入的细节创建一个新的记录对象。</p><p id="b9e3" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">总之，我的<code class="du kk kl km jz b">#create</code>方法看起来是这样的:</p><pre class="ju jv jw jx fd jy jz ka kb aw kc bi"><span id="4ce9" class="kd ke hi jz b fi kf kg l kh ki">def create<br/>  taxon_entered = params[:taxon]<br/>  result = InaturalistApi.fetch(taxon_entered)<br/>  taxon = Taxon.taxon_from_api(result)</span><span id="f777" class="kd ke hi jz b fi kj kg l kh ki">  user = User.find_by(id: session[:user_id])</span><span id="3861" class="kd ke hi jz b fi kj kg l kh ki">  record = Record.create!(<br/>    category: params[:category],<br/>    date_seen: params[:date],<br/>    notes: params[:notes],<br/>    taxon_id: taxon.id,<br/>    user_id: user.id<br/>  )</span><span id="3edb" class="kd ke hi jz b fi kj kg l kh ki">  render json: record, status: :created<br/>end</span></pre><p id="01ce" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">就是这样！现在，用户可以提交一个详细记录(包括分类单元和观察细节)的表单，并让该记录显示用户不需要提供的图像和专有名称。成功！</p><p id="e650" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">如果你想看我的项目，在Github上有回购:<a class="ae js" href="https://github.com/Meganmccarty/life-lister-rails" rel="noopener ugc nofollow" target="_blank">后端</a> (Rails)和<a class="ae js" href="https://github.com/Meganmccarty/life-lister-react" rel="noopener ugc nofollow" target="_blank">前端</a> (React JS)。还可以查看<a class="ae js" href="https://life-lister.herokuapp.com" rel="noopener ugc nofollow" target="_blank">直播项目</a>。</p></div></div>    
</body>
</html>