<html>
<head>
<title>Here’s How Quadratic Sieve Factorization Works</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">以下是二次筛分解的工作原理</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/heres-how-quadratic-sieve-factorization-works-1c878bc94f81?source=collection_archive---------0-----------------------#2022-02-06">https://medium.com/nerd-for-tech/heres-how-quadratic-sieve-factorization-works-1c878bc94f81?source=collection_archive---------0-----------------------#2022-02-06</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/d72241ad2b6fa54014e6f1784b9f3e4a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9g-A3B0TT8cfUB-7p9hTqA.jpeg"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">尼克·希利尔在<a class="ae iu" href="https://unsplash.com/photos/3UbsiRcrFV4?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><p id="adf0" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">寻找两个或更多数字的乘积是一个简单的数学运算，但是将一个数字分解成它的因子的逆运算却不是在公园里散步。因式分解的困难是<a class="ae iu" href="https://en.wikipedia.org/wiki/RSA_(cryptosystem)" rel="noopener ugc nofollow" target="_blank"> RSA密码系统</a>的基础。</p><p id="d335" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">因式分解一直是人们非常感兴趣的，随着现代密码学的兴起，这种兴趣更加浓厚。</p><p id="6769" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">给定一个数<strong class="ix hj"> N </strong>，一个正整数，我们可以对N进行哪些计算操作来获得它的因子？基本的，甚至是粗糙的方法是试除法；用较小的数(从2到N的平方根)除N，看看哪些数没有余数。</p><p id="f78b" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">另一种初等的方法是费马因式分解法，这种方法基于两个平方的<em class="jt">差</em>恒等式:<strong class="ix hj"> x - y = (x-y)(x+ y) </strong>。<br/>为了使用这种方法分解<strong class="ix hj"> N </strong>，我们必须寻找两个整数<strong class="ix hj"> x </strong>和<strong class="ix hj"> y </strong>使得<strong class="ix hj"> x -y = N </strong>或者，同样的事情，x <strong class="ix hj"> -N </strong> <strong class="ix hj"> = y </strong>。那么<strong class="ix hj"> N </strong>的因子根据所述恒等式将为(<strong class="ix hj"> x-y </strong>)和(<strong class="ix hj"> x+y </strong>)。在算法上，我们为<strong class="ix hj"> x </strong>选择一个初始值，并以1为步长递增，每一步计算x <strong class="ix hj"> -N </strong>，当它(x <strong class="ix hj"> -N </strong>)是一个完美的平方(<strong class="ix hj"> y </strong>)时停止。<strong class="ix hj"> x </strong>的初始值将是使x <strong class="ix hj"> -N &gt; 0 </strong>的最小正整数，即<strong class="ix hj"> x &gt; N </strong>。因此，<strong class="ix hj"> x </strong>的起始值将是大于<strong class="ix hj"> N </strong>的平方根的最小正整数，假设N不是完美的平方。注意，这种方法仅产生两个可能不全是质数的因数，如果我们对质数感兴趣，我们可能需要测试输出的质数或再次对它们进行因式分解，除非我们事先知道<strong class="ix hj"> N </strong>仅由两个质数组成，就像RSA模数的情况一样。</p><p id="5e66" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">二次筛法因式分解算法和更高级的数域筛法算法都是基于费马因式分解方法的基本思想，所以，我们举个例子来看看它是如何工作的。<br/> <strong class="ix hj">例</strong>:因式分解<strong class="ix hj">N</strong>= 125513。<br/>125513的平方根是354.2781… <br/>我们取我们的初始值为<strong class="ix hj"> x </strong> = 355。<br/>现在，依次计算x <strong class="ix hj"> - N </strong>，检查是否是正方:</p><p id="be8f" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">355 - 125，513 = 126，025 - 125，513 =512(不是完美的正方形)。<br/>356<strong class="ix hj"/>-125513 = 126737-125513 = 1223(不是正方)。<br/>357<strong class="ix hj"/>-125513 = 127449-125513 = 1936 = 44<strong class="ix hj"/>(一个正方)。</p><p id="2b9f" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们在第三步得到了一个完美的正方形；357 <strong class="ix hj"> </strong> - <strong class="ix hj"> </strong> 125，513 =44 <strong class="ix hj"> </strong>，所以<br/> 125，513 = 357-44 =(357–44)(357+44)=<strong class="ix hj">127 * 181</strong>。</p><p id="00bb" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这个例子特意选择了几个步骤，相比之下，这样因式分解80，723将需要214个步骤才能得到一个完美的正方形。</p><h2 id="9480" class="ju jv hi bd jw jx jy jz ka kb kc kd ke jg kf kg kh jk ki kj kk jo kl km kn ko bi translated">走向二次筛因子分解</h2><p id="0541" class="pw-post-body-paragraph iv iw hi ix b iy kp ja jb jc kq je jf jg kr ji jj jk ks jm jn jo kt jq jr js hb bi translated">简介中描述的两种因式分解方法对于分解小数字(比如说，小于20位的数字)很有用。对于更大的数字，如在密码学中使用的数字，需要更有效的算法。</p><p id="d6a0" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">二次筛法的基础是比利时数学家莫里斯·克赖奇克提出的费马方法的一种改进。这里求满足同余式<strong class="ix hj">x</strong>≦<strong class="ix hj">y</strong>(mod N)的整数<strong class="ix hj"> x </strong>和<strong class="ix hj"> y </strong>，或者是什么一回事，表达式<strong class="ix hj">x</strong>-<strong class="ix hj">y</strong>=<strong class="ix hj">kN</strong>，其中<strong class="ix hj"> k </strong>是某个正整数(不等于1，否则成为费马方法)。如果按照我们将要描述的方式，这可能是实现我们分解N的目标的更快的方法。背后的理论是:如果<br/><strong class="ix hj">x</strong>-<strong class="ix hj">y</strong>=<strong class="ix hj">kN</strong>，那么<strong class="ix hj"> x - y </strong>和<strong class="ix hj"> N </strong>，<strong class="ix hj"> gcd </strong> ( <strong class="ix hj"> x - y </strong>，<strong class="ix hj"> N </strong>)的最大公约数是<strong class="ix hj"> N </strong>的一个适当因子，所以</p><p id="ed8b" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">据此，求<strong class="ix hj"> N </strong>的因子，搜索满足同余<strong class="ix hj">x</strong>≦<strong class="ix hj">y</strong>(mod<strong class="ix hj">N</strong>)的整数<strong class="ix hj"> x </strong>和<strong class="ix hj"> y </strong>。然后计算<strong class="ix hj"> gcd </strong> ( <strong class="ix hj"> x - y </strong>，<strong class="ix hj"> N </strong>)和<strong class="ix hj"> gcd </strong> ( <strong class="ix hj"> x + y </strong>，<strong class="ix hj"> N </strong>)。<strong class="ix hj"> gcd </strong>可以用<a class="ae iu" href="https://en.wikipedia.org/wiki/Euclidean_algorithm" rel="noopener ugc nofollow" target="_blank">欧几里德算法</a>高效计算。让我们举一个玩具的例子来看看它是如何工作的。</p><p id="2ef2" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">例</strong>:因式分解227179。<br/>我们要搜索满足<strong class="ix hj">x</strong>≦<strong class="ix hj">y</strong>(mod 227179)的整数<strong class="ix hj"> x </strong>和<strong class="ix hj"> y </strong>，或者是什么一回事，<strong class="ix hj"> x </strong> mod 227179 = <strong class="ix hj"> y </strong>。和费马方法的情况一样，我们从<strong class="ix hj"> x </strong>等于227179的平方根的上限开始，依次计算<strong class="ix hj"> x mod </strong> <strong class="ix hj"> 227179 </strong>得到一系列<em class="jt">关系</em>。<br/> <strong class="ix hj"> x mod 227179 </strong>与<strong class="ix hj"> x - 227179 </strong>在我们将要工作的范围(<em class="jt">筛分间隔</em>)内具有相同的值，因此我们改为计算。<br/>227，179的平方根是476.6329…，我们从477开始。</p><p id="4b65" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">477 - 227179 <strong class="ix hj"> </strong> = <strong class="ix hj"> 350 </strong>(非正方)= 2×5×7<br/>478-227179<strong class="ix hj"/>=<strong class="ix hj">1305</strong>(非正方)= 3×5×29<br/>479-227179<strong class="ix hj"/>=<strong class="ix hj">2262</strong>(非正方)= 2×3×100 = 3221<br/>481-227179<strong class="ix hj"/>=<strong class="ix hj">4182</strong>(非正方)= 2×3×17×41<br/>482-227179<strong class="ix hj"/>=<strong class="ix hj">5145</strong>(非正方)= 3×5×7<br/>483-227179<strong class="ix hj"/>=<strong class="ix hj"> = 3×7×337<br/>485-227179<strong class="ix hj"/>=<strong class="ix hj">8046</strong>(非正方)= 2×3×149<br/>486-227179<strong class="ix hj"/>=<strong class="ix hj">9017</strong>(非正方)= 71×127<br/>487-227179<strong class="ix hj">=</strong> = 3×5×17×43<br/>489-227179<strong class="ix hj"/>=<strong class="ix hj">11942</strong>(非正方)= 2×7×853<br/>490-227179<strong class="ix hj"/>=<strong class="ix hj">12921</strong>(非正方)= 3×59×73<br/>491-491 = 2×3×7×331<br/>492-227179<strong class="ix hj"/>=<strong class="ix hj">14885</strong>(非正方)= 5×13×229<br/>493-227179<strong class="ix hj"/>=<strong class="ix hj">15870</strong>(非正方)= 2 × 3 × 5 × 23 <br/> 494 - 22 = 3×1873<br/>495-227179<strong class="ix hj"/>=<strong class="ix hj">17846</strong>(非正方)= 2×8923<br/>496-227179<strong class="ix hj"/>=<strong class="ix hj">18837</strong>(非正方)= 3 × 7 × 13 × 23</strong></p><p id="05d5" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">二十步之后，我们仍然没有得到一个完美的正方形。这个算法的想法并不是用这种方法得到一个完美的正方形，而是通过将上面的一些关系相乘得到一个完美的正方形。通过观察，我们发现我们可以将关系式1、6和17相乘，得到一个完美的平方:</p><p id="5f87" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">477≡2×5×7(mod 227179)<br/>482≡3×5×7(mod 227179)<br/>493≡2×3×5×23(mod 227179)</p><p id="ae75" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们将同余式对应边上的项相乘，得到我们想要的关系；</p><p id="06e2" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">477×482×493≦(2×5×7)×(3×5×7)×(2×3×5×23)<br/>(477×482×493)≦(2×3×5⁴×7⁴×23)(mod 227179)<br/>(113，347，602)8801(2×3×5×7×23)(mod 227179)<br/>所以，227179的一个因子是<strong class="ix hj"> gcd </strong> (212460 - 169050，227179)<br/>=<strong class="ix hj">gcd</strong>(43410，227179) = <strong class="ix hj"> 1447 </strong>。<strong class="ix hj"> <br/> </strong>我们通过计算<strong class="ix hj"> gcd </strong> (212460 +169050，227179)或将227179除以1447得到另一个因子。</p><p id="609d" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">当我们有一大组关系时，手动检查哪些关系相乘得到一个完美的正方形显然是不切实际的，而且，需要<em class="jt">算法化</em>该过程，以便计算机程序可以处理它；计算机没有自己的思想。当检查时，我们寻找一组关系，其中右手边的每个质因数的指数加起来是偶数，我们可以用线性代数<em class="jt">算法化</em>这个“检查”；首先，我们在右边建立一个质因数的指数矩阵。集合中最大的质因数是8923。从2(集合中最小的)到8923的素数的指数矩阵对于我们试图分解的小数字来说太大了，所以我们为我们想要处理的素数选择一个(较小的)界限，称为<em class="jt">平滑界限</em>，B。例如，如果我们选择B为50，我们可以忽略那些素数因子大于50的关系，只处理那些素数因子不超过50的关系，称为<em class="jt">平滑关系，</em>，或者更具体地说，上述关系1、2、3、5、6、7、11、12、17和20符合条件；</p><p id="00e2" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">2×5×7<br/>3×5×29<br/>2×3×13×29<br/>2×3×17×41<br/>3×5×7<br/>2×5×13×47<br/>2×3×5×37<br/>3×5×17×43<br/>2×3×5×23<br/>3×7×13×23</p><p id="d9c8" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们用上述质因数的指数构成一个矩阵。到50有十五个素数(2，3，5，7，11，13，17，19，23，29，31，37，41，43，47)，所以我们的矩阵将有十五列。放置0来表示2到47之间任何丢失的素数p的指数(有意义，因为1 = P⁰).该矩阵如下:</p><figure class="kv kw kx ky fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ku"><img src="../Images/b8f274922e724bfe83b7781df195e8bb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9jIeNhKXgi3VmmONZIdBNA.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">黑客帝国</figcaption></figure><p id="c88e" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">通过只记录条目的奇偶性，矩阵可以被简化以使计算更快；0代表偶数，1代表奇数:</p><figure class="kv kw kx ky fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es kz"><img src="../Images/e7ab9f971722147f6523826f4c3a1b9a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ICoBCoN49syJ8_J-9QcCwg.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">母体复活</figcaption></figure><p id="38ac" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">现在，对于这个矩阵，我们感兴趣的是加起来等于偶数的行，即[0 0 0 0 0 0 0 0 0 0 0 0 0]。这些可以通过使用标准线性代数程序计算矩阵的<em class="jt">左零空间</em>来找到，这些程序可以在计算机程序中编码。如果<strong class="ix hj"> M </strong>表示上面的矩阵，而<strong class="ix hj"> S </strong>表示上面的矩阵，那么，我们有:</p><p id="2b8b" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">S</strong>×<strong class="ix hj">M</strong>=[0 0 0 0 0 0 0 0 0 0 0 0]</p><p id="26b1" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">求解矩阵方程(通过高斯消去法，只处理条目的奇偶校验)得到<strong class="ix hj">S</strong>=[1 0 0 1 0 0 1 0 0 1 0]。<strong class="ix hj"> S </strong>的第1、第5和第9个条目的值为1，这表明我们的指数矩阵<strong class="ix hj"> M </strong>中的第1、第5和第9行(对应于关系1、第6、第17行)是将加起来形成偶数的行，并且对应的关系将结合起来形成一个完美的正方形。</p><p id="840f" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">重要提示</strong>:我们很幸运得到了一个只有十个光滑关系(十个矩阵行)的因式分解，通常，我们需要更多的行而不是列(比素因子更光滑的关系)来保证矩阵行的线性相关性，并且左边的空空间是非平凡的——当编写一个实现时，扩展筛选间隔以便有比素因子更光滑的关系，你不希望在一个算法中把事情留给偶然。</p><h2 id="c8b0" class="ju jv hi bd jw jx jy jz ka kb kc kd ke jg kf kg kh jk ki kj kk jo kl km kn ko bi translated">二次筛分</h2><p id="f8a1" class="pw-post-body-paragraph iv iw hi ix b iy kp ja jb jc kq je jf jg kr ji jj jk ks jm jn jo kt jq jr js hb bi translated">我们还没有做任何筛选。这是算法的核心，是由Carl Pomerance引入的一个想法，目的是使我们到目前为止讨论的过程更加有效，但是在我们深入讨论这个之前，让我们引入<em class="jt">因子库</em>的概念。回想一下，在开始的时候，我们对<strong class="ix hj"> x </strong>的各种值计算<strong class="ix hj"> x - 227179 </strong>得到一个数列；350，1305，2262，3221，…，17846，18837。<br/>然后我们对这些数字进行因式分解，并使用<em class="jt">质因数</em>的指数来形成一个矩阵。利用<strong class="ix hj"> 227179 </strong>或任何要被因式分解的数是这些素数中的每一个的<em class="jt">二次余数</em> mod这一事实，可以预先确定这些<em class="jt">质因数</em><em class="jt"/>而无需因式分解序列中的数。一个数<em class="jt"> N </em>是一个二次剩余模<em class="jt"> p </em>如果它全等于一个平方，即存在一个整数<strong class="ix hj"> <em class="jt"> T </em> </strong>使得<strong class="ix hj"><em class="jt">T</em></strong>≦<em class="jt">N</em>(模<em class="jt"> p </em>)。<br/>现在，为了得到<em class="jt"> N </em>(本例中为227179)是二次剩余的素数，我们使用<a class="ae iu" href="https://en.wikipedia.org/wiki/Euler%27s_criterion" rel="noopener ugc nofollow" target="_blank">欧拉判据</a>。</p><p id="1d04" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如果我们已经选择了光滑边界B，下一个任务就是把欧拉准则应用到B以内的所有素数；通过测试的构成了所谓的<em class="jt">因子库</em>。这些素数将用于从筛选区间的数列中筛选出<em class="jt">非光滑</em>数。<em class="jt">非平滑</em>数是指质因数大于平滑度界限的数。我们希望只处理平滑的数字，这样我们就可以有一个可管理的指数矩阵，如前所述。</p><p id="e57c" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">为了说明这些新观点，让我们再来看看227179的因式分解。我们选择B为50。素数最多为B，<em class="jt"> B </em> = {2，3，5，7，11，13，17，19，23，29，31，37，41，43，47}。</p><p id="54dc" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">将<a class="ae iu" href="https://en.wikipedia.org/wiki/Euler%27s_criterion" rel="noopener ugc nofollow" target="_blank">欧拉判据</a>应用于以227179为基数的<em class="jt"> B </em>中的每个素数，我们发现227179是模以下{2，3，5，7，13，17，23，29，37，41，43，47}的二次剩余。每个整数都是以2为模的二次剩余，可能不需要用2来测试。<br/>所以，我们的因子库是<strong class="ix hj"> {2，3，5，7，13，17，23，29，37，41，43，47} </strong>。</p><p id="fdec" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">现在，开始筛选。筛选的好处是，它有助于识别平滑的数字，而不必像我们一样先对它们进行因式分解，从而节省我们的时间和精力。</p><p id="2919" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这是怎么做到的？再回忆一下，筛选区间的数字，即350，1305，2262，3221，…，17846，18837是通过计算得到的(477 + <strong class="ix hj"> n </strong> ) <strong class="ix hj"> - </strong> 227179对于<strong class="ix hj"> n </strong> = 0，1，2，…)。</p><p id="f86c" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">现在的挑战是，在这些数字中，我们如何在不进行因子分解的情况下，识别出那些完全超过因子基数的数字，这些数字将是平滑的数字。这就相当于问(477 + <strong class="ix hj"> n </strong> ) <strong class="ix hj"> - </strong> 227179的什么值能被因子库中的素数整除，并且只能被因子库中的素数整除。如果能解出二次同余<br/>(477+<strong class="ix hj">n</strong>)<strong class="ix hj">-</strong>227179≡0(mod<strong class="ix hj">p</strong>)其中<strong class="ix hj"> p </strong>是因子基的成员，那么就有了我们的答案。幸运的是，有一个有效的算法来解决这样的同余；<a class="ae iu" href="https://en.wikipedia.org/wiki/Tonelli%E2%80%93Shanks_algorithm" rel="noopener ugc nofollow" target="_blank">托内利-桑克斯<strong class="ix hj">T21【算法</strong></a>。<br/>于是，我们从因子库中为每个<strong class="ix hj"> p </strong>求解出(477+<strong class="ix hj">n</strong>)<strong class="ix hj">-</strong>227179≡0(mod<strong class="ix hj">p</strong>)，并将(477+<strong class="ix hj">n</strong>)<strong class="ix hj">-</strong>227179对应的值除以<strong class="ix hj"> p </strong>。</p><p id="bd05" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">用p = 2，求解(477+<strong class="ix hj">n</strong>)<strong class="ix hj">-</strong>227179≡0(mod 2)给出<strong class="ix hj"> n ≡ 0 (mod 2) </strong>，或者<br/> <strong class="ix hj"> n = 2k </strong>，对于k = 0，1，2，3，…，所以<strong class="ix hj"> n </strong> = 0，2，4，6，…这就告诉我们<br/>(477+【47</p><p id="43a0" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">下面是在我们的筛选间隔中以表格形式计算的数字，顶行包含<strong class="ix hj"> n </strong>值，底行包含相应的(477+<strong class="ix hj">n</strong>)<strong class="ix hj">-</strong>227179值。</p><figure class="kv kw kx ky fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es la"><img src="../Images/9899633013b096552a8b707857b664ea.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Mcjpchzj0h8lVfQCu8MXww.png"/></div></div></figure><p id="aa11" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">将底行中的条目除以2，其中<strong class="ix hj"> n </strong> = 0，2，4，6，…，16，18得出:</p><figure class="kv kw kx ky fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es la"><img src="../Images/52438ab962b8d44e86b9ce0334efb3ed.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*noAUY_spD7QTw-xQ2KpnyQ.png"/></div></div></figure><p id="e958" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">对于每个p &gt; 2，同余式将有两个解。p = 3时，两个解分别是<strong class="ix hj"> n ≡ 1(mod 3) </strong>或<strong class="ix hj"> n = </strong> <strong class="ix hj"> 3k + 1 </strong>，<strong class="ix hj"> n ≡ 2(mod 3) </strong>或<strong class="ix hj"> n = 3k + 2 </strong>。<br/>所以，<strong class="ix hj"> n </strong> = 1，4，7，10，…，而<strong class="ix hj"> n </strong> = 2，5，8，11，…。<br/>将表中与<strong class="ix hj"> n </strong>的这些值相对应的条目除以3，我们得到:</p><figure class="kv kw kx ky fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es la"><img src="../Images/3392a0ce9d2674a0ee3f4a312d576bb7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yPuVdRvxvJoxrhnySbhMwA.png"/></div></div></figure><p id="88e3" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">p = 5时，两个解分别是<strong class="ix hj"> n ≡ 0(mod 5) </strong>或<strong class="ix hj"> n = </strong> 5 <strong class="ix hj"> k </strong>，和<strong class="ix hj"> n ≡ 1(mod 5) </strong>或<strong class="ix hj"> n = 5k + 1 </strong>。所以，<strong class="ix hj"> n </strong> = 0，5，10，15，…，而<strong class="ix hj"> n </strong> = 1，6，11，16，…。<br/>将表中对应于<strong class="ix hj"> n </strong>的这些值的条目除以5，我们得到:</p><figure class="kv kw kx ky fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es la"><img src="../Images/8e65749fb4b321f98fe9aa304b10a28a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FVsy8bSqffA6EchFb1GIOw.png"/></div></div></figure><p id="350a" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">对因子库中的其余素数执行相同的过程，我们最终获得:</p><figure class="kv kw kx ky fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lb"><img src="../Images/a314aa750e36a1a3430774a1a6630cdb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*aUFRjdslgy-5ayHB0TyTrQ.png"/></div></div></figure><p id="a1a7" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">减少到1的条目是平滑的数字，我们已经在这个过程中获得了它们的因式分解，所以我们可以用它构建一个矩阵，然后像以前一样继续。</p><p id="5873" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在该区间中，我们只能捕获四个平滑数，部分原因是我们没有考虑因子基素数的幂的除法，这不足以保证n的因子分解，为了获得更多的平滑数/平滑关系，我们要么增加平滑度界限，要么也筛选素数幂(<strong class="ix hj"> pᵐ </strong>)。同余式(477+<strong class="ix hj">n</strong>)—227179≡0(mod<strong class="ix hj">pᵐ</strong>)，其中<strong class="ix hj"> m </strong> &gt; 1的解可以很容易地从用托内利-尚克斯算法得到的(477+<strong class="ix hj">n</strong>)—227179≡0(mod<strong class="ix hj">p</strong>的解中得到<a class="ae iu" href="https://en.wikipedia.org/w/index.php?title=Tonelli%E2%80%93Shanks_algorithm&amp;oldid=1014170710#Tonelli%27s_algorithm_will_work_on_mod_p%5Ek" rel="noopener ugc nofollow" target="_blank">。</a></p><h2 id="1697" class="ju jv hi bd jw jx jy jz ka kb kc kd ke jg kf kg kh jk ki kj kk jo kl km kn ko bi translated">选择光滑度界限</h2><p id="6888" class="pw-post-body-paragraph iv iw hi ix b iy kp ja jb jc kq je jf jg kr ji jj jk ks jm jn jo kt jq jr js hb bi translated">选择平滑度边界B是二次筛选算法中至关重要的第一步。一个非常小的界限可能不能产生足够的关系来组合成一个偶宇称，而一个非常大的界限将导致一个难以使用的矩阵。那么，我们如何为光滑度界限选择一个最佳值呢？有一个启发式公式可以作为指导:</p><figure class="kv kw kx ky fd ij er es paragraph-image"><div class="er es lc"><img src="../Images/e4b7ad77759e41a7d84a61bbd6dd5338.png" data-original-src="https://miro.medium.com/v2/resize:fit:1306/format:webp/1*MY8OURL9V7cU8lYLgSMawA.jpeg"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">光滑界的粗糙公式</figcaption></figure><p id="addf" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">其中<strong class="ix hj"> N </strong>为被因式分解的数，<strong class="ix hj"> log </strong>为自然对数，<strong class="ix hj"> exp </strong> (x)表示<strong class="ix hj"> eˣ </strong>，e =自然对数的底数(约为2.71828)。o(1)是一个接近0的值，你可以粗略地把它设置为0。</p><h2 id="5cec" class="ju jv hi bd jw jx jy jz ka kb kc kd ke jg kf kg kh jk ki kj kk jo kl km kn ko bi translated">总结/结尾注释</h2><p id="fba0" class="pw-post-body-paragraph iv iw hi ix b iy kp ja jb jc kq je jf jg kr ji jj jk ks jm jn jo kt jq jr js hb bi translated">概括地说，算法中涉及到的步骤如下:</p><p id="c53f" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">1.选择一个平滑度界限b。</p><p id="b147" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">2.让所有的质数都达到b。厄拉多塞算法的筛子能帮上忙。</p><p id="8f02" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">3.使用欧拉准则确定N是否是步骤2中每个素数的二次剩余模。将通过测试的素数保存在因子基数组中。这一步可以和第二步结合起来，这样一切都在一个循环中完成；一旦检测到质数，就对它应用欧拉判据。</p><p id="5a12" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">4.计算一个数列Qₙ = (x +n) — N对于n = 0，1，2，3…，其中x是n的平方根的上限，这个数列应该有多长？我们至少需要一个比因数基数中的素数更光滑的关系。只有一小部分Qₙ's将是B-smooth，所以我们可以相当宽容地允许Qₙ's至少是因子基数中素数数量的六倍。</p><p id="1c86" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">5.使用Tonelli-Shanks算法求解因子库中每个<strong class="ix hj"> p </strong>的同余式(x + <strong class="ix hj"> n </strong> ) — N ≡ 0(mod <strong class="ix hj"> p </strong>)中的<strong class="ix hj"> n </strong>。根据同余式的解，通过执行除法<strong class="ix hj"> Qₙ </strong> / <strong class="ix hj"> p </strong>来筛选<strong class="ix hj"> Qₙ </strong>的b平滑值，记下每个Qₙ.的因子</p><p id="3609" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">6.用步骤5中得到的平滑Qₙ's的素因子的指数构成一个矩阵。找出矩阵的(左)零空间——用它来确定将组合起来给出偶奇偶性的一组关系。<br/>对于大型矩阵，简单的高斯消元不适合计算零空间，通常使用更有效的算法，如<em class="jt">块Lanczos </em>或<strong class="ix hj"> </strong> <em class="jt">块威德曼</em>算法。</p><p id="2706" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">7.在步骤6中组合关系将产生形式为<br/><strong class="ix hj">a</strong>≦<strong class="ix hj">b</strong>(mod<strong class="ix hj">N</strong>)的单个关系。由此我们通过使用欧几里德算法计算<strong class="ix hj"> gcd </strong> ( <strong class="ix hj"> a — b </strong>，<strong class="ix hj"> N </strong>)和<strong class="ix hj"> gcd </strong> ( <strong class="ix hj"> a + b </strong>，<strong class="ix hj"> N </strong>)得到了备受追捧的因子<strong class="ix hj"> N </strong>。</p><p id="ee0f" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这是二次筛分解的基本思想，有几个改进的算法变体。</p></div></div>    
</body>
</html>