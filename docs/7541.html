<html>
<head>
<title>Golang: Build a simple web server and interact with it</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Golang:构建一个简单的 web 服务器并与之交互</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/golang-build-a-simple-web-server-and-interact-with-it-689ee0f4d1de?source=collection_archive---------0-----------------------#2022-11-27">https://medium.com/nerd-for-tech/golang-build-a-simple-web-server-and-interact-with-it-689ee0f4d1de?source=collection_archive---------0-----------------------#2022-11-27</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/b665f44b5cbfe9ca2a9f86d06630982d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*e1rMFYMI5gUU3F5RoqEbEA.png"/></div></div></figure><p id="bd13" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><a class="ae jo" href="https://github.com/golang/go" rel="noopener ugc nofollow" target="_blank"> Golang </a>是 Google 支持的开源编程语言。它以强大的性能而闻名，也为我们构建各种应用提供了许多有用的包。在这篇文章中，我想分享如何使用一些 Golang 包来构建一个简单的 web 服务器。</p><h2 id="d967" class="jp jq hi bd jr js jt ju jv jw jx jy jz jb ka kb kc jf kd ke kf jj kg kh ki kj bi translated"><strong class="ak"> 1。环境准备</strong></h2><p id="3f21" class="pw-post-body-paragraph iq ir hi is b it kk iv iw ix kl iz ja jb km jd je jf kn jh ji jj ko jl jm jn hb bi translated">首先，我们需要安装 Go。下载和安装的方法可以在 Golang 官网的这里看到<a class="ae jo" href="https://go.dev/doc/install" rel="noopener ugc nofollow" target="_blank">。安装后，可以运行<code class="du kp kq kr ks b">go version</code>来检查安装的版本。</a></p><figure class="ku kv kw kx fd ij er es paragraph-image"><div class="er es kt"><img src="../Images/48aad0a2ac31428a6aa0d1d0da3d58a6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1056/format:webp/1*orq4CNBNkGMpQtSxNSmUDA.png"/></div></figure><p id="e0f7" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">接下来，需要准备 Golang 项目环境。在这里可以按照步骤<a class="ae jo" href="https://quii.gitbook.io/learn-go-with-tests/go-fundamentals/install-go" rel="noopener ugc nofollow" target="_blank">进行</a>。基本上，你应该创建一个文件夹，然后运行<code class="du kp kq kr ks b">go mod init &lt;modulepath&gt;</code>命令来生成一个<code class="du kp kq kr ks b">go.mod</code>文件。</p><pre class="ku kv kw kx fd ky ks kz bn la lb bi"><span id="8bd6" class="lc jq hi ks b be ld le l lf lg">mkdir my-project<br/>cd my-project<br/>go mod init &lt;modulepath&gt;</span></pre><p id="1cd7" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">Golang 使用<code class="du kp kq kr ks b">go.mod</code>来管理这个项目中需要导入的所有模块(类似于 Rails 项目中的<code class="du kp kq kr ks b">Gemfile</code>)。项目本身也是一个模块，<code class="du kp kq kr ks b">&lt;modulepath&gt;</code>是模块内包路径(项目中文件夹的路径)的路径前缀。关于<code class="du kp kq kr ks b">&lt;modulepath&gt;</code>命名的更多细节可以在<a class="ae jo" href="https://go.dev/ref/mod" rel="noopener ugc nofollow" target="_blank"> Go 模块参考</a>中找到。以下是部分描述。通常，它会包含项目的根路径。</p><blockquote class="lh li lj"><p id="f144" class="iq ir lk is b it iu iv iw ix iy iz ja ll jc jd je lm jg jh ji ln jk jl jm jn hb bi translated">模块路径应该描述模块做什么以及在哪里可以找到它。通常，模块路径由存储库根路径、存储库中的目录(通常为空)和主版本后缀(仅适用于主版本 2 或更高版本)组成。</p><p id="cab7" class="iq ir lk is b it iu iv iw ix iy iz ja ll jc jd je lm jg jh ji ln jk jl jm jn hb bi translated"><a class="ae jo" href="https://go.dev/ref/mod" rel="noopener ugc nofollow" target="_blank">围棋模块参考</a></p></blockquote><p id="f7cf" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如果运行<code class="du kp kq kr ks b">go mod init my-project</code>，将在项目中生成一个<code class="du kp kq kr ks b">go.mod</code>文件，该<code class="du kp kq kr ks b">go.mod</code>文件内容如下。</p><pre class="ku kv kw kx fd ky ks kz bn la lb bi"><span id="8b8c" class="lc jq hi ks b be ld le l lo lg">// go.mod<br/><br/>module my-project <br/><br/>go 1.19</span></pre><p id="c672" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">Golang 使用<code class="du kp kq kr ks b">go.mod</code>管理项目的方式与使用<code class="du kp kq kr ks b">GOPATH</code>不同。Golang 会通过<code class="du kp kq kr ks b">go.mod</code>的位置检测我们要执行的文件，而不是检入<code class="du kp kq kr ks b">GOPATH</code>。<code class="du kp kq kr ks b">go.mod</code>是 Go 1.16 以后的默认构建模式，因此不推荐使用<code class="du kp kq kr ks b">GOPATH</code>。</p></div><div class="ab cl lp lq gp lr" role="separator"><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu"/></div><div class="hb hc hd he hf"><p id="4504" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在 Golang 项目中，它们通常是一个<code class="du kp kq kr ks b">main.go</code>文件和一个<code class="du kp kq kr ks b">main</code>函数，我们将执行<code class="du kp kq kr ks b">go run main.go</code>来运行我们的项目，所以我们需要创建<code class="du kp kq kr ks b">main.go</code>并在其中添加<code class="du kp kq kr ks b">main</code>函数，然后我们可以开始在<code class="du kp kq kr ks b">main</code>函数中编写一些代码来构建 web 服务器。</p><pre class="ku kv kw kx fd ky ks kz bn la lb bi"><span id="2aee" class="lc jq hi ks b be ld le l lo lg">package main<br/><br/>func main() {<br/><br/>}</span></pre><p id="8519" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">项目结构如下。</p><figure class="ku kv kw kx fd ij er es paragraph-image"><div class="er es lw"><img src="../Images/da7829f5d60aba6bb623cbc453936188.png" data-original-src="https://miro.medium.com/v2/resize:fit:876/format:webp/1*8MyG46scgcHB_vnnWGqVZw.png"/></div></figure></div><div class="ab cl lp lq gp lr" role="separator"><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu"/></div><div class="hb hc hd he hf"><h2 id="a5c4" class="jp jq hi bd jr js jt ju jv jw jx jy jz jb ka kb kc jf kd ke kf jj kg kh ki kj bi translated">2.U <strong class="ak"> seful 包介绍</strong></h2><p id="3a52" class="pw-post-body-paragraph iq ir hi is b it kk iv iw ix kl iz ja jb km jd je jf kn jh ji jj ko jl jm jn hb bi translated">对于构建 web 服务器，Golang 提供了几个包，如<code class="du kp kq kr ks b">net</code>、<code class="du kp kq kr ks b">net/http</code>、<code class="du kp kq kr ks b">log</code>、<code class="du kp kq kr ks b">fmt</code>，包中有几个函数对于构建一个简单的 web 服务器很有用。以下是这些软件包和功能的介绍:</p><ul class=""><li id="c6d4" class="lx ly hi is b it iu ix iy jb lz jf ma jj mb jn mc md me mf bi translated"><a class="ae jo" href="https://pkg.go.dev/net" rel="noopener ugc nofollow" target="_blank">网</a></li></ul><p id="1018" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">包<code class="du kp kq kr ks b">net</code>为网络 I/O 提供了一个接口，它提供了简单的功能，如<code class="du kp kq kr ks b">Dial</code>用于连接服务器，<code class="du kp kq kr ks b">Listen</code>用于创建服务器。在<code class="du kp kq kr ks b">Listen</code>函数中，我们可以传递<code class="du kp kq kr ks b">network</code>和<code class="du kp kq kr ks b">address</code>，它将在本地网络<code class="du kp kq kr ks b">address</code>上启动一个服务器，并使用<code class="du kp kq kr ks b">network</code>的类型。网络必须是<code class="du kp kq kr ks b">tcp</code>、<code class="du kp kq kr ks b">tcp4</code>、<code class="du kp kq kr ks b">tcp6</code>、<code class="du kp kq kr ks b">unix</code>或<code class="du kp kq kr ks b">unixpacket</code>。</p><blockquote class="lh li lj"><p id="211e" class="iq ir lk is b it iu iv iw ix iy iz ja ll jc jd je lm jg jh ji ln jk jl jm jn hb bi translated">对于 TCP 网络，如果 address 参数中的 host 为空或未指定的 IP 地址，Listen 将侦听本地系统的所有可用单播和任播 IP 地址。要仅使用 IPv4，请使用网络“tcp4”。该地址可以使用主机名，但不建议这样做，因为它最多会为主机的一个 IP 地址创建一个侦听器。如果地址参数中的端口为空或“0”，如“127.0.0.1:”或“[::1]:0”，则自动选择一个端口号。Listener 的 Addr 方法可用于发现所选的端口。</p><p id="a17c" class="iq ir lk is b it iu iv iw ix iy iz ja ll jc jd je lm jg jh ji ln jk jl jm jn hb bi translated">从<code class="du kp kq kr ks b"><a class="ae jo" href="https://pkg.go.dev/net#Listen" rel="noopener ugc nofollow" target="_blank">net package func Listen online document</a></code></p></blockquote><pre class="ku kv kw kx fd ky ks kz bn la lb bi"><span id="fddf" class="lc jq hi ks b be ld le l lo lg">func Listen(network, address string) (Listener, error)</span></pre><p id="bb72" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><code class="du kp kq kr ks b">Listen</code>的示例代码如下。它将在<code class="du kp kq kr ks b">localhost:8080</code>上启动一个服务器并使用 TCP 网络。</p><pre class="ku kv kw kx fd ky ks kz bn la lb bi"><span id="4110" class="lc jq hi ks b be ld le l lo lg">listener, error := net.Listen("tcp", ":8080")<br/>if error != nil {<br/> // handle error<br/>}</span></pre><ul class=""><li id="9795" class="lx ly hi is b it iu ix iy jb lz jf ma jj mb jn mc md me mf bi translated"><a class="ae jo" href="https://pkg.go.dev/net/http" rel="noopener ugc nofollow" target="_blank"> net/http </a></li></ul><p id="c5be" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">包<code class="du kp kq kr ks b">net/http</code>提供了 HTTP 客户端和服务器实现。它可以用于 HTTP(或 HTTPS)请求，并提供类似于<code class="du kp kq kr ks b">HandleFunc</code>的功能，用于在<code class="du kp kq kr ks b">DefaultServeMux</code>中注册 URL 路径的给定模式的处理函数，这是一个默认的<code class="du kp kq kr ks b"><a class="ae jo" href="https://pkg.go.dev/net/http#ServeMux" rel="noopener ugc nofollow" target="_blank">ServeMux</a></code>，Golang 中用于路由收集的结构，这样我们就可以实现当向特定 URL 发送 HTTP(或 HTTPS)请求时的响应。</p><blockquote class="lh li lj"><p id="08d4" class="iq ir lk is b it iu iv iw ix iy iz ja ll jc jd je lm jg jh ji ln jk jl jm jn hb bi translated">ServeMux 是一个 HTTP 请求复用器。它将每个传入请求的 URL 与注册模式列表进行匹配，并调用与 URL 最匹配的模式的处理程序。</p><p id="f49f" class="iq ir lk is b it iu iv iw ix iy iz ja ll jc jd je lm jg jh ji ln jk jl jm jn hb bi translated">来自<code class="du kp kq kr ks b"><a class="ae jo" href="https://pkg.go.dev/net/http#ServeMux" rel="noopener ugc nofollow" target="_blank">net/http ServeMux<em class="hi"> online document</em></a></code></p></blockquote><p id="9d62" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在<code class="du kp kq kr ks b">HandleFunc</code>中，我们只需要传递一个引用 URL 路径的模式和一个处理程序，在向这个 URL 路径发送 HTTP(或 HTTPS)请求时处理响应。</p><pre class="ku kv kw kx fd ky ks kz bn la lb bi"><span id="2f37" class="lc jq hi ks b be ld le l lo lg">func HandleFunc(pattern string, handler func(ResponseWriter, *Request))</span></pre><p id="c900" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">示例代码如下所示，将在向<code class="du kp kq kr ks b">/bar</code>发送 HTTP(或 HTTPS)请求时工作，响应将在网页上打印<code class="du kp kq kr ks b">Hello /bar</code>。</p><pre class="ku kv kw kx fd ky ks kz bn la lb bi"><span id="5e7b" class="lc jq hi ks b be ld le l lo lg">http.HandleFunc("/bar", func(w http.ResponseWriter, r *http.Request) {<br/> fmt.Fprintf(w, "Hello, %q", html.EscapeString(r.URL.Path))<br/>})</span></pre><p id="0da7" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">包<code class="du kp kq kr ks b">net/http</code>提供<code class="du kp kq kr ks b">Serve</code>功能，接受到服务器的传入的 HTTP 连接。它应该给这个函数传递两个参数。第一个是从<code class="du kp kq kr ks b">listener, error :=net.Listen(“tcp”, “localhost:8080”)</code>得到的<code class="du kp kq kr ks b">Listener</code>，第二个是当 HTTP 连接到<code class="du kp kq kr ks b">Listener</code>时处理响应的<code class="du kp kq kr ks b">Handler</code>。<code class="du kp kq kr ks b">Handler</code>通常为零，它将使用<code class="du kp kq kr ks b">DefaultServeMux</code>，这意味着当接收到 HTTP(或 HTTPS)请求时，它将检查路径并找到已经在<code class="du kp kq kr ks b">DefaultServeMux</code>中注册的处理函数(通过<code class="du kp kq kr ks b">HandleFunc</code>注册)。</p><pre class="ku kv kw kx fd ky ks kz bn la lb bi"><span id="726e" class="lc jq hi ks b be ld le l lo lg">func Serve(l net.Listener, handler Handler) error</span></pre><p id="a2d1" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这是<code class="du kp kq kr ks b">Serve</code>功能的示例代码。我们首先注册<code class="du kp kq kr ks b">/bar</code>到<code class="du kp kq kr ks b">HandleFunc</code>的处理程序，在<code class="du kp kq kr ks b">localhost:8080</code>上启动一个侦听器，并使用<code class="du kp kq kr ks b">Serve</code>为该侦听器接受一个 HTTP 连接。当向<code class="du kp kq kr ks b">localhost:8080/bar</code>发送 HTTP(或 HTTPS)请求时，我们会看到<code class="du kp kq kr ks b">Hello /bar</code>打印在网页上。</p><pre class="ku kv kw kx fd ky ks kz bn la lb bi"><span id="46f8" class="lc jq hi ks b be ld le l lo lg">http.HandleFunc("/bar", func(w http.ResponseWriter, r *http.Request) {<br/> fmt.Fprintf(w, "Hello, %q", html.EscapeString(r.URL.Path))<br/>})<br/>listener, error := net.Listen("tcp", ":8080")<br/>http.Serve(listener, nil)</span></pre><p id="504c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在运行<code class="du kp kq kr ks b">http.Serve</code>之前运行<code class="du kp kq kr ks b">http.HandleFunc</code>很重要，因为如果在<code class="du kp kq kr ks b">DefaultServeMux</code>中没有注册 URL 路径和处理函数(响应处理函数)，当运行<code class="du kp kq kr ks b">http.Serve</code>时，当接收到针对特定 URL 路径的 HTTP(或 HTTPS)请求时，服务器在<code class="du kp kq kr ks b">DefaultServeMux</code>中找不到相关的处理函数来进行响应。</p><p id="fab5" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">包中还有另一个功能<code class="du kp kq kr ks b">http</code>，结合了<code class="du kp kq kr ks b">net.Listen</code>和<code class="du kp kq kr ks b">http.Serve</code>功能。是<code class="du kp kq kr ks b">ListenAndServe</code>。我们可以将本地网络<code class="du kp kq kr ks b">address</code>和<code class="du kp kq kr ks b">handler</code>传递给<code class="du kp kq kr ks b">ListenAndServe</code>，它将使用 TCP 网络并监听本地网络地址，然后用处理程序调用<code class="du kp kq kr ks b">Serve</code>来处理传入连接上的请求。像<code class="du kp kq kr ks b">http.Serve</code>一样，处理器通常为零，它将使用<code class="du kp kq kr ks b">DefaultServeMux</code>。</p><pre class="ku kv kw kx fd ky ks kz bn la lb bi"><span id="8a3e" class="lc jq hi ks b be ld le l lo lg">func (srv *Server) ListenAndServe() error</span></pre><p id="9718" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">示例代码如下，函数的工作方式与上面的示例代码相同。</p><pre class="ku kv kw kx fd ky ks kz bn la lb bi"><span id="b520" class="lc jq hi ks b be ld le l lo lg">http.HandleFunc("/bar", func(w http.ResponseWriter, r *http.Request) {<br/> fmt.Fprintf(w, "Hello, %q", html.EscapeString(r.URL.Path))<br/>})<br/>http.ListenAndServe(":8080", nil)</span></pre><ul class=""><li id="b330" class="lx ly hi is b it iu ix iy jb lz jf ma jj mb jn mc md me mf bi translated"><a class="ae jo" href="https://pkg.go.dev/log" rel="noopener ugc nofollow" target="_blank">日志</a></li></ul><p id="8a99" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">包<code class="du kp kq kr ks b">log</code>提供了一个日志功能。它打印每个日志消息的日期和时间，并且每个日志消息在单独的行上输出。基本功能和<code class="du kp kq kr ks b">Println</code>一样</p><pre class="ku kv kw kx fd ky ks kz bn la lb bi"><span id="0f66" class="lc jq hi ks b be ld le l lo lg">func Println(v ...any)</span></pre><p id="de96" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">示例代码如下所示。它会打印出<code class="du kp kq kr ks b">2022/11/12 15:53:05 haha</code>。</p><pre class="ku kv kw kx fd ky ks kz bn la lb bi"><span id="d8c9" class="lc jq hi ks b be ld le l lo lg">log.Println("haha")</span></pre><p id="0d1e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><code class="du kp kq kr ks b">log</code>包还提供了<code class="du kp kq kr ks b">Fatal</code>功能，可以打印错误等内容并退出程序。</p><pre class="ku kv kw kx fd ky ks kz bn la lb bi"><span id="4a9f" class="lc jq hi ks b be ld le l lo lg">log.Fatal(error)</span></pre><ul class=""><li id="5653" class="lx ly hi is b it iu ix iy jb lz jf ma jj mb jn mc md me mf bi translated"><a class="ae jo" href="https://pkg.go.dev/fmt" rel="noopener ugc nofollow" target="_blank"> fmt </a></li></ul><p id="7bed" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">包<code class="du kp kq kr ks b">fmt</code>提供了<code class="du kp kq kr ks b">Sprintf</code>打印特定格式内容的功能。如何使用该格式可以在<code class="du kp kq kr ks b">fmt</code>上查看在线<a class="ae jo" href="https://pkg.go.dev/fmt@go1.19.3#section-documentation" rel="noopener ugc nofollow" target="_blank">文档</a>。</p><pre class="ku kv kw kx fd ky ks kz bn la lb bi"><span id="99ba" class="lc jq hi ks b be ld le l lo lg">func Sprintf(format string, a ...any) string</span></pre><p id="023e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">例如，下面的代码将打印<code class="du kp kq kr ks b">12.00</code>。</p><pre class="ku kv kw kx fd ky ks kz bn la lb bi"><span id="87c9" class="lc jq hi ks b be ld le l lo lg">fmt.Sprintf("%6.2f", 12.0)</span></pre></div><div class="ab cl lp lq gp lr" role="separator"><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu"/></div><div class="hb hc hd he hf"><h2 id="c93b" class="jp jq hi bd jr js jt ju jv jw jx jy jz jb ka kb kc jf kd ke kf jj kg kh ki kj bi translated">3.<strong class="ak">编写我们的代码并运行它</strong></h2><p id="3557" class="pw-post-body-paragraph iq ir hi is b it kk iv iw ix kl iz ja jb km jd je jf kn jh ji jj ko jl jm jn hb bi translated">在阅读了上面的介绍之后，我们知道我们可以用什么包和函数来构建 web 服务器。我们现在的目标是在<code class="du kp kq kr ks b">localhost:8080</code>构建一个服务器主机，如果向<code class="du kp kq kr ks b">localhost:8080/greeting</code>发送一个 HTTP 请求，它将在网页上返回问候词<code class="du kp kq kr ks b">Hello World</code>，因此<code class="du kp kq kr ks b">main.go</code>中的代码可能如下所示。</p><pre class="ku kv kw kx fd ky ks kz bn la lb bi"><span id="29cb" class="lc jq hi ks b be ld le l lo lg">// main.go<br/><br/>package main<br/><br/>// import the package we need to use<br/>import (<br/>  "fmt"<br/>  "log"<br/>  "net"<br/>  "net/http"<br/>)<br/><br/>func main() {<br/><br/>  // set a HTTP request handle function for path /greeting and registrate it<br/>    http.HandleFunc("/greeting", func (w http.ResponseWriter, <br/>        r *http.Request) {<br/>  <br/>        // when receive the request, print the greeting meassage<br/>        fmt.Fprint(w, "Hello World")<br/>  <br/>      })<br/><br/>  // print out the server is going to start and show the time<br/>  log.Println("Starting server....")<br/><br/>  // create server at localhost:8080 and using tcp as the network<br/>  listener, err := net.Listen("tcp", ":8080")<br/><br/>  // if recieve error, record it and exit the program<br/>  if err != nil {<br/>    log.Fatal(err)<br/>  }<br/><br/>  // setup HTTP connection for the listener of the server<br/>  http.Serve(listener, nil)<br/><br/>}</span></pre><p id="fff6" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在在项目根目录的终端运行<code class="du kp kq kr ks b">go run main.go</code>，会显示<code class="du kp kq kr ks b">Starting server</code>的日志。</p><figure class="ku kv kw kx fd ij er es paragraph-image"><div class="er es mg"><img src="../Images/a45fceb3c688c5e905151733173c8d3d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1216/format:webp/1*e7aLD6qEL5kxYPXFAL_77A.png"/></div></figure><p id="e9dd" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">然后在网络浏览器中打开<code class="du kp kq kr ks b">localhost:8080/greeting</code>。问候语<code class="du kp kq kr ks b">Hello word</code>将显示在网页上。</p><figure class="ku kv kw kx fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mh"><img src="../Images/f652420ba4679b7e877b0e19945d106a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pWqr1QxMYa7EILcPlpv8HQ.png"/></div></div></figure></div><div class="ab cl lp lq gp lr" role="separator"><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu"/></div><div class="hb hc hd he hf"><h2 id="6c8d" class="jp jq hi bd jr js jt ju jv jw jx jy jz jb ka kb kc jf kd ke kf jj kg kh ki kj bi translated">4.重构代码</h2><p id="57ba" class="pw-post-body-paragraph iq ir hi is b it kk iv iw ix kl iz ja jb km jd je jf kn jh ji jj ko jl jm jn hb bi translated">我们现在构建一个简单的 web 服务器，但是所有的代码都放在<code class="du kp kq kr ks b">main</code>函数中。乍一看很难知道每一行代码的目的，所以我们可以通过将它们分成不同的函数来使它变得清晰。我们可以通过将 handler 函数移动到一个<code class="du kp kq kr ks b">Greeting</code>函数并在<code class="du kp kq kr ks b">http.HandleFunc</code>中调用这个函数来重构<code class="du kp kq kr ks b">http.HandleFunc</code>。</p><pre class="ku kv kw kx fd ky ks kz bn la lb bi"><span id="8f01" class="lc jq hi ks b be ld le l lo lg">http.HandleFunc("/greeting", func (w http.ResponseWriter, <br/>    r *http.Request) {<br/>    fmt.Fprint(w, "Hello World")<br/>})</span></pre><p id="2188" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这样做之后，<code class="du kp kq kr ks b">http.HandleFunc</code>部分将变得更加干净。</p><pre class="ku kv kw kx fd ky ks kz bn la lb bi"><span id="21fc" class="lc jq hi ks b be ld le l lo lg">http.HandleFunc("/greeting", Greeting)</span></pre><p id="50a5" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><code class="du kp kq kr ks b">Greeting</code>函数的内容与 handler 函数相同，但我们将其命名为<code class="du kp kq kr ks b">Greeting</code>。</p><pre class="ku kv kw kx fd ky ks kz bn la lb bi"><span id="8c0f" class="lc jq hi ks b be ld le l lo lg">func Greeting(w http.ResponseWriter, r *http.Request) {<br/>    fmt.Fprint(w, "Hello World")<br/>})</span></pre><p id="fd8a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">而<code class="du kp kq kr ks b"> Greeting</code>函数将在项目根路径中放置一个新创建的名为<code class="du kp kq kr ks b">greeting.go</code>的文件。</p><pre class="ku kv kw kx fd ky ks kz bn la lb bi"><span id="33df" class="lc jq hi ks b be ld le l lo lg">// greeting.go<br/><br/>package main<br/><br/>import (<br/>  "fmt"<br/>  "net/http"<br/>)<br/><br/>func Greeting(w http.ResponseWriter, r *http.Request) {<br/>  fmt.Fprint(w, "Hello world")<br/>}</span></pre><p id="4a02" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">项目中的文件树如下所示</p><figure class="ku kv kw kx fd ij er es paragraph-image"><div class="er es mi"><img src="../Images/7938b645508cc5147b716fbeef50a6de.png" data-original-src="https://miro.medium.com/v2/resize:fit:908/format:webp/1*n5DZHX4OpdcJjU6hAfkOJg.png"/></div></figure><p id="34ad" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在再次运行<code class="du kp kq kr ks b">go run main.go</code>，但是我们会得到一个错误消息<code class="du kp kq kr ks b">undefined: Greeting</code></p><figure class="ku kv kw kx fd ij er es paragraph-image"><div class="er es mj"><img src="../Images/c05ef1aa8179bf39e4e9085e6ea9331b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1180/format:webp/1*VWNPbjcJUywj9-PvYNlj_w.png"/></div></figure><p id="9df5" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这是因为它只会在运行<code class="du kp kq kr ks b">go run main.go</code>时加载<code class="du kp kq kr ks b">main.go</code>，所以找不到<code class="du kp kq kr ks b">Greeting</code>功能。为了解决这个错误，我们应该改为运行<code class="du kp kq kr ks b">go run main.go greeting.go</code>，因此再次运行<code class="du kp kq kr ks b">go run main.go greeting.go</code>，然后它将在 web 浏览器中显示启动服务器和打开<code class="du kp kq kr ks b">localhost:8080/greeting</code>的日志，<code class="du kp kq kr ks b">Hello word</code>将显示在网页上。</p><figure class="ku kv kw kx fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mk"><img src="../Images/7ad1721f6a5eb2ebe0c8e8226364f2fa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cIQ36eCbreclX29zGMLRyQ.png"/></div></div></figure><p id="ad5a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在我们重构我们的代码，让它更干净，但是启动服务器时需要调用两个文件，这有点烦人。应该有更好的重构方法，我们仍然可以运行<code class="du kp kq kr ks b">go run main.go</code>来启动 web 服务器。我们可以使用 Golang 项目的一个好处，即不同文件夹中的每个文件就像一个单独的包，我们可以将它们导入到其他文件中来使用它们。我们可以创建一个<code class="du kp kq kr ks b">greeting</code>文件夹并将<code class="du kp kq kr ks b">greeting.go</code>移动到其中，然后将<code class="du kp kq kr ks b">greeting.go</code>定义为一个包<code class="du kp kq kr ks b">greeting</code>。我们项目的结构将会如下图所示。</p><figure class="ku kv kw kx fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ml"><img src="../Images/6061774cc495d64ea89137799a1c7187.png" data-original-src="https://miro.medium.com/v2/resize:fit:892/format:webp/1*rNmmC6UZNoF7zF06yuy0PA.png"/></div></div></figure><p id="7790" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><code class="du kp kq kr ks b">greeting.go</code>中的代码如下。它需要将这个包命名为<code class="du kp kq kr ks b">greeting</code>，这样我们就可以用这个名字来调用<code class="du kp kq kr ks b">Greeting</code>函数。它也可以用另一个词来命名，但是需要用包名来调用包中的函数。例如，如果我们想调用<code class="du kp kq kr ks b">Greeting</code>函数，当包名为<code class="du kp kq kr ks b">greeting</code>时，调用的方式是<code class="du kp kq kr ks b">greeting.Greeting</code>，但是如果我们将包命名为<code class="du kp kq kr ks b">words</code>，那么它就会像<code class="du kp kq kr ks b">words.Greeting</code>一样。</p><pre class="ku kv kw kx fd ky ks kz bn la lb bi"><span id="0ef8" class="lc jq hi ks b be ld le l lo lg">// greeting.go<br/><br/>package greeting<br/><br/>import (<br/>"fmt"<br/>"net/http"<br/>)<br/><br/>func Greeting(w http.ResponseWriter, r *http.Request) {<br/>  fmt.Fprint(w, "Hello World")<br/>}</span></pre><p id="c264" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们需要在<code class="du kp kq kr ks b">main.go</code>中导入包<code class="du kp kq kr ks b">greeting</code>。导入的方式是在导入列表中添加包<code class="du kp kq kr ks b">greeting</code>的路径，路径是我们在<code class="du kp kq kr ks b">go.mod</code>中定义的<code class="du kp kq kr ks b">prefix</code>即<code class="du kp kq kr ks b">my-project</code>和文件夹名<code class="du kp kq kr ks b">greeting</code>的组合，所以路径是<code class="du kp kq kr ks b">my-project/greeting</code>。之后，在<code class="du kp kq kr ks b">main</code>函数中，我们可以通过<code class="du kp kq kr ks b">greeting.Greeting</code>使用<code class="du kp kq kr ks b">Greeting</code>函数。</p><pre class="ku kv kw kx fd ky ks kz bn la lb bi"><span id="20ce" class="lc jq hi ks b be ld le l lo lg">// main.go<br/><br/>package main<br/><br/>import (<br/>  "log"<br/>  "net"<br/>  "net/http"<br/>  "my-project/greeting" // import greeting the path is like module/package name<br/>)<br/><br/>func main() {<br/>  http.HandleFunc("/greeting", greeting.Greeting)<br/><br/>  log.Println("Starting server....")<br/><br/>  listener, err := net.Listen("tcp", "localhost:8080")<br/>  if err != nil {<br/>    log.Fatal(err)<br/>  }<br/><br/>  http.Serve(listener, nil)<br/>}</span></pre><p id="15f0" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如果我们不想通过<code class="du kp kq kr ks b">greeting.Greeting</code>调用<code class="du kp kq kr ks b">Greeting</code>，我们可以用别名导入<code class="du kp kq kr ks b">greeting</code>，例如<code class="du kp kq kr ks b">controller</code>，然后我们可以通过<code class="du kp kq kr ks b">controller.Greeting</code>调用<code class="du kp kq kr ks b">Greeting</code>。</p><pre class="ku kv kw kx fd ky ks kz bn la lb bi"><span id="966e" class="lc jq hi ks b be ld le l lo lg">import (<br/>  controller "my-project/greeting" // import greeting the path is like module/package name<br/>)<br/><br/>func main() {<br/>  http.HandleFunc("/greeting", controller.Greeting)<br/>.......</span></pre><p id="ff94" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在运行<code class="du kp kq kr ks b">go run main.go</code>并且 web 服务器可以成功启动，在 web 浏览器中打开<code class="du kp kq kr ks b">localhost:8080/greeting</code>，<code class="du kp kq kr ks b">Hello word</code>也显示在网页上。我们再也不需要叫<code class="du kp kq kr ks b">greeting.go</code>了。</p><figure class="ku kv kw kx fd ij er es paragraph-image"><div class="er es mm"><img src="../Images/0b9175097dc50d83557814ca9482e81e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1272/format:webp/1*fDG9S1jgW5_rELNQqKBI_g.png"/></div></figure><h2 id="8be2" class="jp jq hi bd jr js jt ju jv jw jx jy jz jb ka kb kc jf kd ke kf jj kg kh ki kj bi translated">参考</h2><p id="381b" class="pw-post-body-paragraph iq ir hi is b it kk iv iw ix kl iz ja jb km jd je jf kn jh ji jj ko jl jm jn hb bi translated"><a class="ae jo" href="https://go.dev/ref/mod" rel="noopener ugc nofollow" target="_blank"> Go 模块参考</a></p><p id="9f6b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><a class="ae jo" href="https://quii.gitbook.io/learn-go-with-tests/build-an-application/app-intro" rel="noopener ugc nofollow" target="_blank">边学边考</a></p><p id="bd9d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><a class="ae jo" href="https://go.dev/doc/install" rel="noopener ugc nofollow" target="_blank"> Go 官方在线文档</a></p><ul class=""><li id="6121" class="lx ly hi is b it iu ix iy jb lz jf ma jj mb jn mc md me mf bi translated"><a class="ae jo" href="https://pkg.go.dev/net" rel="noopener ugc nofollow" target="_blank">网</a></li><li id="c9d4" class="lx ly hi is b it mn ix mo jb mp jf mq jj mr jn mc md me mf bi translated"><a class="ae jo" href="https://pkg.go.dev/net/http" rel="noopener ugc nofollow" target="_blank"> net/http </a></li><li id="e640" class="lx ly hi is b it mn ix mo jb mp jf mq jj mr jn mc md me mf bi translated"><a class="ae jo" href="https://pkg.go.dev/log" rel="noopener ugc nofollow" target="_blank">日志</a></li><li id="eec8" class="lx ly hi is b it mn ix mo jb mp jf mq jj mr jn mc md me mf bi translated"><a class="ae jo" href="https://pkg.go.dev/fmt" rel="noopener ugc nofollow" target="_blank"> fmt </a></li></ul><p id="e512" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi"><a class="ae jo" href="https://willh.gitbook.io/build-web-application-with-golang-zhtw/" rel="noopener ugc nofollow" target="_blank">使用 Golang 打造 web 應用程式</a></p><p id="21a0" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><a class="ae jo" href="https://github.com/astaxie/build-web-application-with-golang" rel="noopener ugc nofollow" target="_blank">用 Golang 构建 Web 应用</a></p><p id="70a7" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><a class="ae jo" rel="noopener" href="/微峯飛翔/golang-go-mod-起手勢-39a0be969ffc">关于 go.mod </a></p><figure class="ku kv kw kx fd ij"><div class="bz dy l di"><div class="ms mt l"/></div></figure></div></div>    
</body>
</html>