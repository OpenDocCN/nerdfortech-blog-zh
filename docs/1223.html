<html>
<head>
<title>Many happy early returns</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">祝早日康复</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/many-happy-early-returns-2e0d71bfa691?source=collection_archive---------27-----------------------#2021-03-09">https://medium.com/nerd-for-tech/many-happy-early-returns-2e0d71bfa691?source=collection_archive---------27-----------------------#2021-03-09</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><figure class="hh hi ez fb hj hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es hg"><img src="../Images/66eee47946cedf4388fa9a5d4eded098.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*598Rz1Dmhb8I4SFO9GUxfg.jpeg"/></div></div></figure><div class=""/><p id="bb44" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我决定写这篇文章，因为我记得当我在 2013-2014 年左右开始学习 Scala 时，如何从循环中提前返回的问题确实在我身上发生过几次。我有一个集合，我想通过它来寻找满足某些要求的第一个条目，然后我想跳出这个循环，把那个合适的结果带走。当时我正在用 Java 开发一个时间管理 webapp，上面描述的情况经常发生在我身上:有一个很长的条目集合，记录了一个给定的人在给定的一天中在给定的项目上工作了多少时间，我对它们进行了复杂的查询。<em class="jo">“找出一天中团队工作超过 X 人时的事件”</em>。<em class="jo">“找出一个花了 Y 天以上修复的 bug 的例子”</em>。诸如此类。在 Java 中，我通常遵循同一个模式<strong class="is hu"> — </strong>我收集原始条目(姑且称之为<code class="du jp jq jr js b">Foo</code>类型的<code class="du jp jq jr js b">foos</code>),执行有时相当昂贵的到衍生条目(类型<code class="du jp jq jr js b">Bar</code>的<code class="du jp jq jr js b">bar</code>)的转换，然后对那个<code class="du jp jq jr js b">bar</code>进行有时也相当复杂的验证，检查它是否满足要求，如果是，那么我返回它。如果没发现什么，就返回<code class="du jp jq jr js b">null</code>。</p><pre class="jt ju jv jw fd jx js jy jz aw ka bi"><span id="beaa" class="kb kc ht js b fi kd ke l kf kg">Bar complexConversion(Foo foo) {<br/>  ...<br/>}</span><span id="ee18" class="kb kc ht js b fi kh ke l kf kg">bool complexValidation(Bar bar) {<br/>  ...<br/>}</span><span id="8b3c" class="kb kc ht js b fi kh ke l kf kg">Bar findFirstValidBar(Collection&lt;Foo&gt; foos) {<br/>  for(Foo foo : foos) {<br/>    Bar bar = complexConversion(foo)<br/>    if (complexValidation(bar)) return bar<br/>  }<br/>  return null<br/>}</span></pre><h2 id="ce39" class="kb kc ht bd ki kj kk kl km kn ko kp kq jb kr ks kt jf ku kv kw jj kx ky kz la bi translated">命令式方法</h2><p id="81e3" class="pw-post-body-paragraph iq ir ht is b it lb iv iw ix lc iz ja jb ld jd je jf le jh ji jj lf jl jm jn hb bi translated">很自然，作为一名 Java 开发人员，我在 Scala 中的第一步就是将 Java 代码几乎一对一地逐字翻译成 Scala:</p><pre class="jt ju jv jw fd jx js jy jz aw ka bi"><span id="e382" class="kb kc ht js b fi kd ke l kf kg">def complexConversion(foo: Foo): Bar = ...<br/>def complexValidation(bar: Bar): Boolean = ...</span><span id="1bca" class="kb kc ht js b fi kh ke l kf kg">def findFirstValidBar(seq: Seq[Foo]): Option[Bar] = {<br/>  for (foo &lt;- seq) {<br/>    val bar = complexConversion(foo)<br/>    if (complexValidation(bar)) return Some(bar)<br/>  }<br/>  None<br/>}</span></pre><p id="3775" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这里唯一真正的区别是我避免了<code class="du jp jq jr js b">null</code>，而是使用了<code class="du jp jq jr js b"><a class="ae lg" href="https://www.scala-lang.org/api/current/scala/Option.html" rel="noopener ugc nofollow" target="_blank">Option</a></code>。对于我们这里的所有实际目的来说，<code class="du jp jq jr js b">Option</code>是一个集合，它可以由零个元素或一个元素组成。要么是<code class="du jp jq jr js b">Some(bar)</code>，然后我以后可以从中提取出那个<code class="du jp jq jr js b">bar</code>，要么就是<code class="du jp jq jr js b">None</code>。</p><p id="c3af" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">但这不是好的 Scala 代码，远非如此。关键字<code class="du jp jq jr js b">return</code>，即使它存在于 Scala 中，也是强烈不鼓励的。大多数情况下，开发人员使用<code class="du jp jq jr js b">return</code>作为一个块中的最后一条语句。在 Scala 中，每个代码块都是一个表达式，它自动返回代码块中最后一个表达式的结果。因此，你可以简单地在最后一行写下<code class="du jp jq jr js b">x</code>，而不是<code class="du jp jq jr js b">return x</code>，但大多数情况下你甚至不会这么做<strong class="is hu"> — </strong>事实上，一切都是一个表达式，这给了你重新排序整个代码块的能力，这在 Java 中看起来非常笨拙，最终得到更加简洁的 Scala 代码。这就排除了 90%的退货。至于另外的 10%，即大部分来自循环的早期回报，嗯...早期回报被认为是一种代码气味。它们降低了表达式序列的可读性，因为程序员不再依赖最后一条语句是从块中返回结果的语句。如果可能的话，你应该以这样一种方式重新排序代码，使得<code class="du jp jq jr js b">return</code>不再必要。</p><p id="82c6" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">但在这种情况下，这并不容易。首先，我学习了一些半解决方案来绕过它，然后我终于学会了正确的方法，然后我就把它忘得一干二净了，因为那时我有太多的东西要在同一时间学习，这只是让我的大脑为其他新概念腾出空间，直到最近我才想起我不时编写的代码实际上是旧 Java 早期版本的 FP 等价物。因此这篇文章。答案是…</p><h2 id="b0da" class="kb kc ht bd ki kj kk kl km kn ko kp kq jb kr ks kt jf ku kv kw jj kx ky kz la bi translated">婴儿学步</h2><p id="f180" class="pw-post-body-paragraph iq ir ht is b it lb iv iw ix lc iz ja jb ld jd je jf le jh ji jj lf jl jm jn hb bi translated">…我们将一步一步来。或者你可以跳过接下来的几段。但是我想邀请你和我一起看一下方法<code class="du jp jq jr js b">findFirstValidBar</code>的几个中间版本，这样最终你会更好地理解为什么最终的解决方案看起来是这样，以及你还可以用它做什么。</p><p id="09c9" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">首先，让我们沿着阻力最小的路线:Scala 中的每个标准集合都定义了方法<code class="du jp jq jr js b"><a class="ae lg" href="https://www.scala-lang.org/api/current/scala/collection/Seq.html#find(p:A=%3EBoolean):Option[A]" rel="noopener ugc nofollow" target="_blank">find</a></code>和<code class="du jp jq jr js b"><a class="ae lg" href="https://www.scala-lang.org/api/current/scala/collection/Seq.html#map[B](f:A=%3EB):CC[B]" rel="noopener ugc nofollow" target="_blank">map</a></code>。<code class="du jp jq jr js b">find</code>返回集合中满足谓词的第一个元素作为选项<strong class="is hu"> — </strong>如果没有元素满足要求，将返回<code class="du jp jq jr js b">None</code>。<code class="du jp jq jr js b">map</code>将一种类型的元素集合转换为另一种类型的元素集合。由于<code class="du jp jq jr js b">Option</code>也是一个集合，我们可以在这里使用它，因此将整个<code class="du jp jq jr js b">findFirstValidBar</code>方法变成这样:</p><pre class="jt ju jv jw fd jx js jy jz aw ka bi"><span id="998e" class="kb kc ht js b fi kd ke l kf kg">def findFirstValidBar(seq: Seq[Foo]): Option[Bar] = <br/>  seq.find(foo =&gt; complexValidation(complexConversion(foo)))<br/>     .map(complexConversion)</span></pre><p id="5852" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">对于<code class="du jp jq jr js b">seq</code>中的每个<code class="du jp jq jr js b">foo</code>，我们将其转换成一个<code class="du jp jq jr js b">bar</code>，然后我们验证它，如果它通过了验证，那么我们停止对<code class="du jp jq jr js b">seq</code>的迭代，并返回...嗯，<code class="du jp jq jr js b">find</code>返回的是原<code class="du jp jq jr js b">foo</code>，而不是导数<code class="du jp jq jr js b">bar</code>，所以我们需要把那个<code class="du jp jq jr js b">foo</code>再转换一次才能返回。如果转换是微不足道的，我们可以忽略这个缺点<strong class="is hu"> — </strong>毕竟，它只是一个额外的转换，或者如果我们没有<code class="du jp jq jr js b">find</code>任何有效的元素就等于零<strong class="is hu"> — </strong>但是一般来说，我不喜欢满足于一个次优的解决方案，特别是如果一个更好的解决方案不是那么复杂的话。</p><p id="36e2" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在 Scala 标准集合库中有一个名为<code class="du jp jq jr js b"><a class="ae lg" href="https://www.scala-lang.org/api/current/scala/collection/Seq.html#collect[B](pf:PartialFunction[A,B]):CC[B]" rel="noopener ugc nofollow" target="_blank">collect</a></code>的方法，它合并了<code class="du jp jq jr js b"><a class="ae lg" href="https://www.scala-lang.org/api/current/scala/collection/Seq.html#filter(pred:A=%3EBoolean):C" rel="noopener ugc nofollow" target="_blank">filter</a></code>和<code class="du jp jq jr js b">map</code>的功能。过滤一个集合，然后将结果映射到其他东西的集合，这种情况非常普遍，因此用更短的代码编写会更有优势。同样，还有一个方法<code class="du jp jq jr js b"><a class="ae lg" href="https://www.scala-lang.org/api/current/scala/collection/Seq.html#collectFirst[B](pf:PartialFunction[A,B]):Option[B]" rel="noopener ugc nofollow" target="_blank">collectFirst</a></code>合并了<code class="du jp jq jr js b">find</code>和<code class="du jp jq jr js b">map</code> <strong class="is hu"> — </strong>毕竟<code class="du jp jq jr js b">find</code>只是一个在找到第一个有效元素后停止的<code class="du jp jq jr js b">filter</code>。因此，我们可以修改上面的版本，并将其编写为:</p><pre class="jt ju jv jw fd jx js jy jz aw ka bi"><span id="147f" class="kb kc ht js b fi kd ke l kf kg">def findFirstValidBar(seq: Seq[Foo]): Option[Bar] =   <br/>  seq.collectFirst {<br/>    case foo if complexValidation(complexConversion(foo)) =&gt; complexConversion(foo) <br/>  }</span></pre><p id="ca21" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">花括号和以 case 开头的一行表示<code class="du jp jq jr js b">collectFirst</code>接受一个参数<strong class="is hu"> — </strong>一个部分函数。只有满足条件(<code class="du jp jq jr js b">complexValidation(complexConversion(foo))</code>)时，该功能才会产生结果(<code class="du jp jq jr js b">complexConversion(foo)</code>)。如果产生了结果，<code class="du jp jq jr js b">collectFirst</code>将停止对<code class="du jp jq jr js b">seq</code>的迭代并返回。否则，它将尝试另一个<code class="du jp jq jr js b">foo</code>。</p><h2 id="c4b1" class="kb kc ht bd ki kj kk kl km kn ko kp kq jb kr ks kt jf ku kv kw jj kx ky kz la bi translated"><code class="du jp jq jr js b">unapply</code></h2><p id="dafa" class="pw-post-body-paragraph iq ir ht is b it lb iv iw ix lc iz ja jb ld jd je jf le jh ji jj lf jl jm jn hb bi translated">就其本身而言，<code class="du jp jq jr js b">collectFirst</code>仍然不能解决我们的问题。为了检查条件是否满足，我们需要执行转换和验证，然后，如果验证成功，我们需要再次转换原始的<code class="du jp jq jr js b">foo</code>，就像在带有<code class="du jp jq jr js b">find</code>和<code class="du jp jq jr js b">map</code>的版本中发生的一样。但是这次我们得到了一个提示。Scala 中的部分函数利用了模式匹配<strong class="is hu"> — </strong>就像我们做<code class="du jp jq jr js b">match/case</code>一样，部分函数中的 case 可能被用来将元素<code class="du jp jq jr js b">foo</code>解构为其他东西，而这种解构机制，也称为<code class="du jp jq jr js b">unapply</code>方法，可以用于转换和验证。</p><p id="46e7" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">但是等等，<code class="du jp jq jr js b">unapply</code>不就是单纯用来从 case 类中提取字段值的吗？</p><p id="50c8" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">没有。</p><pre class="jt ju jv jw fd jx js jy jz aw ka bi"><span id="8c3b" class="kb kc ht js b fi kd ke l kf kg">object ValidBar {<br/>  def unapply(foo: Foo): Option[Bar] = {<br/>    val bar = complexConversion(foo)<br/>    if (complexValidation(bar)) Some(bar) else None<br/>  }<br/>}</span></pre><p id="0347" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">实际上，在代码的任何地方，我们都可以创建一个新的对象，将其命名为有意义的对象(注意，对象不一定总是类的伙伴对象)，并在其中实现一个<code class="du jp jq jr js b">unapply</code>方法，该方法将接受一种类型的实例，并返回另一种类型的<code class="du jp jq jr js b">Option</code>。在我们的例子中，它使用一个<code class="du jp jq jr js b">foo</code>，转换它，验证它，如果验证成功，返回<code class="du jp jq jr js b">Some(bar)</code>，否则返回<code class="du jp jq jr js b">None</code>。之后，我们可以在任何地方使用<code class="du jp jq jr js b">unapply</code>方法进行模式匹配，就像这样:</p><pre class="jt ju jv jw fd jx js jy jz aw ka bi"><span id="80d8" class="kb kc ht js b fi kd ke l kf kg">foo match {<br/>  case ValidBar(bar) =&gt; // do something with our valid bar<br/>  case _ =&gt; // ...<br/>}</span></pre><p id="52b3" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">所以我们用在<code class="du jp jq jr js b">collectFirst</code>里吧:</p><pre class="jt ju jv jw fd jx js jy jz aw ka bi"><span id="6110" class="kb kc ht js b fi kd ke l kf kg">object ValidBar {<br/>  def unapply(foo: Foo): Option[Bar] = {<br/>    val bar = complexConversion(foo)<br/>    if (complexValidation(bar)) Some(bar) else None<br/>  }<br/>}</span><span id="f57d" class="kb kc ht js b fi kh ke l kf kg">def findFirstValidBar(seq: Seq[Foo]): Option[Bar] =   <br/>  seq.collectFirst {<br/>    case ValidBar(bar) =&gt; bar <br/>  }</span></pre><p id="591c" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">胜利！现在我们只有一次转换，一次验证，当我们找到第一个有效元素时，我们就完成了对<code class="du jp jq jr js b">seq</code>的迭代。最重要的是，我们也可以在<code class="du jp jq jr js b">collect</code>方法中使用它:简单的<code class="du jp jq jr js b">seq.collect { case ValidBar(bar) =&gt; bar }</code>将使用所有通过验证的条。</p><p id="399e" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">然而，我们可能不喜欢这个解决方案的冗长之处。这不再是一句俏皮话了。其实比原来的<code class="du jp jq jr js b">findFirstValidBar</code>命令版还要长。但这只是因为这个解决方案在开始时需要一定的开销:即使对于最简单的应用程序，我们也需要一个对象和一个<code class="du jp jq jr js b">unapply</code>方法。但是随着应用程序<strong class="is hu"> — </strong>即转换和验证<strong class="is hu"> — </strong>变得更加复杂，开销变得不那么重要。我们只需要把<code class="du jp jq jr js b">unapply</code>写一遍，然后就可以在<code class="du jp jq jr js b">collectFirst</code>里到处用了。事实上，有一种情况下<code class="du jp jq jr js b">unapply</code>甚至可能让我们节省几行。</p><p id="18db" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">想象一下，从<code class="du jp jq jr js b">Foo</code>到<code class="du jp jq jr js b">Bar</code>的转换并不总是可能的。我们需要用<code class="du jp jq jr js b">def safeComplexConversion(foo: Foo): Option[Bar]</code>代替<code class="du jp jq jr js b">def complexConversion(foo: Foo): Bar</code>，如果转换成功，我们返回<code class="du jp jq jr js b">Some(bar)</code>，否则返回<code class="du jp jq jr js b">None</code>。现在我们的命令式版本<code class="du jp jq jr js b">findFirstValidBar</code>需要看起来像这样:</p><pre class="jt ju jv jw fd jx js jy jz aw ka bi"><span id="6a6c" class="kb kc ht js b fi kd ke l kf kg">def safeComplexConversion(foo: Foo): Option[Bar] = ...<br/>def complexValidation(bar: Bar): Boolean = ...</span><span id="c59c" class="kb kc ht js b fi kh ke l kf kg">def findFirstValidBar(seq: Seq[Foo]): Option[Bar] = {  <br/>  for (foo &lt;- seq) <br/>    safeComplexConversion(foo) match { <br/>      case Some(bar) if complexValidation(bar) =&gt; return Some(bar)    <br/>      case _ =&gt; <br/>    } <br/>  None<br/>}</span></pre><p id="da19" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">它更复杂，也更丑陋。<code class="du jp jq jr js b">return</code>关键字不仅嵌套在 for 循环中，还嵌套在<code class="du jp jq jr js b">match/case</code>中。这里我们再次遇到了为什么不应该使用<code class="du jp jq jr js b">return</code>的原因。在 Scala 代码中，多层嵌套非常常见<strong class="is hu">—</strong>lambdas、匿名类和模式匹配等特性让我们的代码更加简洁。但是这些代码中的关键字<code class="du jp jq jr js b">return</code>使得阅读起来更加困难。</p><h2 id="fdca" class="kb kc ht bd ki kj kk kl km kn ko kp kq jb kr ks kt jf ku kv kw jj kx ky kz la bi translated">防止不可能转换的安全</h2><p id="af0a" class="pw-post-body-paragraph iq ir ht is b it lb iv iw ix lc iz ja jb ld jd je jf le jh ji jj lf jl jm jn hb bi translated">同时，由于我们的<code class="du jp jq jr js b">unapply</code>方法处理选项，所以<code class="du jp jq jr js b">findFirstValidBar</code>的上一版本中的变化使得代码比以前更加简单:</p><pre class="jt ju jv jw fd jx js jy jz aw ka bi"><span id="bcae" class="kb kc ht js b fi kd ke l kf kg">def safeComplexConversion(foo: Foo): Option[Bar] = ...<br/>def complexValidation(bar: Bar): Boolean = ...</span><span id="c564" class="kb kc ht js b fi kh ke l kf kg">object ValidBar {<br/>  def unapply(foo: Foo): Option[Bar] =     <br/>    safeComplexConversion(foo).find(complexValidation)<br/>}</span><span id="d09e" class="kb kc ht js b fi kh ke l kf kg">def findFirstValidBar(seq: Seq[Foo]): Option[Bar] =   <br/>  seq.collectFirst {<br/>    case ValidBar(bar) =&gt; bar <br/>  }</span></pre><p id="bf35" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">此外，转换和验证方法也需要放在某个地方——如果它们总是一起使用，现在它们可以放在对象内的<code class="du jp jq jr js b">unapply</code>旁边。这意味着如果<code class="du jp jq jr js b">Foo</code>需要在您的代码中以多种方式进行解构——从一个原始数据结构中派生出一个以上的二级类型是很常见的——您将只需要关心那些派生的有意义的对象名称:</p><pre class="jt ju jv jw fd jx js jy jz aw ka bi"><span id="f396" class="kb kc ht js b fi kd ke l kf kg">object ValidBar {<br/>  def convert(foo: Foo): Option[Bar] = ...<br/>  def validate(bar: Bar): Boolean = ...<br/>  def unapply(foo: Foo): Option[Bar] = convert(foo).find(validate)<br/>}<br/>// use as case ValidBar(bar) =&gt; ...</span><span id="f7ad" class="kb kc ht js b fi kh ke l kf kg">object ValidBaz {<br/>  def convert(foo: Foo): Option[Baz] = ...<br/>  def validate(baz: Baz): Boolean = ...<br/>  def unapply(foo: Foo): Option[Baz] = convert(foo).find(validate)<br/>}<br/>// use as case ValidBaz(baz) =&gt; ...</span><span id="334e" class="kb kc ht js b fi kh ke l kf kg">object BarValidInADifferentWay {<br/>  def convert(foo: Foo): Option[Bar] = ...<br/>  def validate(bar: Bar): Boolean = ...<br/>  def unapply(foo: Foo): Option[Bar] = convert(foo).find(validate)<br/>}<br/>// use as case BarValidInADifferentWay(bar) =&gt; ...</span></pre><p id="9f66" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这允许大量的代码重用。我们现在不仅可以在<code class="du jp jq jr js b">collectFirst</code>和<code class="du jp jq jr js b">collect</code>中使用那些<code class="du jp jq jr js b">unapply</code>方法，还可以在<code class="du jp jq jr js b">match/case</code>和 Scala collections 库中几乎任何接受部分函数的方法中使用。<code class="du jp jq jr js b">map</code>、<code class="du jp jq jr js b">flatMap</code>、<code class="du jp jq jr js b">foreach</code> —随你所需。我们还可以在部分函数中组合它们，比如说，如果我们寻找一个可以以某种方式转换和验证的 foo:</p><pre class="jt ju jv jw fd jx js jy jz aw ka bi"><span id="9770" class="kb kc ht js b fi kd ke l kf kg">seq.collectFirst {<br/>  case ValidBar(bar) =&gt; bar<br/>  case BarValidInADifferentWay(bar) =&gt; bar<br/>} // stops at the first element valid in any of those ways</span></pre><h2 id="f591" class="kb kc ht bd ki kj kk kl km kn ko kp kq jb kr ks kt jf ku kv kw jj kx ky kz la bi translated">所有解构的共同特征</h2><p id="2275" class="pw-post-body-paragraph iq ir ht is b it lb iv iw ix lc iz ja jb ld jd je jf le jh ji jj lf jl jm jn hb bi translated">如果你习惯了这种模式，你可能会注意到<code class="du jp jq jr js b">unapply</code>总是相同的，并提取出一个特征的共同逻辑:</p><pre class="jt ju jv jw fd jx js jy jz aw ka bi"><span id="041a" class="kb kc ht js b fi kd ke l kf kg">// one such trait for the whole codebase<br/>trait Deconstruct[From, To] {<br/>  def convert(from: From): Option[To]<br/>  def validate(to: To): Boolean<br/>  def unapply(from: From): Option[To] = <br/>    convert(from).find(validate)<br/>}</span><span id="16a4" class="kb kc ht js b fi kh ke l kf kg">// one for each implementation of convert and validate<br/>object ValidBar extends Deconstruct[Foo, Bar] {<br/>  override def convert(foo: Foo): Option[Bar] = ...<br/>  override def validate(bar: Bar): Boolean = ...<br/>}</span><span id="9e80" class="kb kc ht js b fi kh ke l kf kg">// for each use<br/>def findFirstValidBar(seq: Seq[Foo]): Option[Bar] =   <br/>  seq.collectFirst {<br/>    case ValidBar(bar) =&gt; bar <br/>  }</span></pre><h2 id="41dd" class="kb kc ht bd ki kj kk kl km kn ko kp kq jb kr ks kt jf ku kv kw jj kx ky kz la bi translated">懒惰的收藏</h2><p id="dfb2" class="pw-post-body-paragraph iq ir ht is b it lb iv iw ix lc iz ja jb ld jd je jf le jh ji jj lf jl jm jn hb bi translated">在我发表了这篇博客的最初版本后，我注意到至少有一种方法可以达到懒惰收集的相同效果(谢谢你，Balmung-san！).惰性集合是这样一种集合，它不是已经计算好元素并准备好访问，而是在需要时计算给定元素。这意味着，由于我们只在找到满足特定条件的第一个元素之前遍历集合，并且当我们找到它时，我们不再对访问任何其他元素感兴趣，因此集合不会为它们运行转换和验证方法。</p><p id="49b1" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">Scala 中的一个懒惰集合是<a class="ae lg" href="https://www.scala-lang.org/api/current/scala/collection/Iterator.html" rel="noopener ugc nofollow" target="_blank">迭代器</a>。我们可以简单地通过编写<code class="du jp jq jr js b">seq.iterator</code>从原始的<code class="du jp jq jr js b">Seq[Foo]</code>创建一个迭代器。查找有效条形所需的全部代码如下所示:</p><pre class="jt ju jv jw fd jx js jy jz aw ka bi"><span id="e457" class="kb kc ht js b fi kd ke l kf kg">def findFirstValidBar(seq: Seq[Foo]): Option[Bar] =<br/>  seq.iterator<br/>     .map(safeComplexConversion)<br/>     .find(_.exists(complexValidation))<br/>     .flatten</span></pre><p id="23d3" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">然而，这涉及到一些开销。保留迭代器是不安全的——我们每次都应该从原始的<code class="du jp jq jr js b">seq</code>开始创建它。此外，代码的可重用性也降低了——如果我们有多种方法来转换和验证一个元素，我们将需要编写比<code class="du jp jq jr js b">unapply</code> + <code class="du jp jq jr js b">collectFirst</code>更多的代码。但总的来说，这是一个很好的例子，说明在 Scala 中，任何事情都可以用多种方式来完成，这取决于我们愿意接受什么样的权衡。</p><p id="e486" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">仅此而已。感谢阅读。希望这些都能对你有用。</p><h2 id="33de" class="kb kc ht bd ki kj kk kl km kn ko kp kq jb kr ks kt jf ku kv kw jj kx ky kz la bi translated">几个链接:</h2><ul class=""><li id="dba6" class="lh li ht is b it lb ix lc jb lj jf lk jj ll jn lm ln lo lp bi translated">一个包含所有例子的要点。</li><li id="7668" class="lh li ht is b it lq ix lr jb ls jf lt jj lu jn lm ln lo lp bi translated">一个关于<code class="du jp jq jr js b">unapply</code>方法的<a class="ae lg" href="https://www.youtube.com/watch?v=83DmfRHQxfE" rel="noopener ugc nofollow" target="_blank">视频</a>(和它的<a class="ae lg" href="https://makingthematrix.wordpress.com/2021/02/09/programming-with-functions-4-the-unapply-method-and-the-newtype-pattern/" rel="noopener ugc nofollow" target="_blank">同伴博客笔记</a>)。</li><li id="53d7" class="lh li ht is b it lq ix lr jb ls jf lt jj lu jn lm ln lo lp bi translated"><a class="ae lg" href="https://www.youtube.com/watch?v=RX1_EJp9Vxk" rel="noopener ugc nofollow" target="_blank">另一个视频</a>和一个关于部分功能的<a class="ae lg" href="https://makingthematrix.wordpress.com/2020/12/15/programming-with-functions-2-functions-as-data/" rel="noopener ugc nofollow" target="_blank">博客笔记</a>。</li></ul><p id="418a" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><a class="ae lg" href="https://www.flickr.com/photos/lucian-f/50409684038/in/photolist-2jNwNPq-5fGemX-2kfZ1fh-p6fR58-2cB5d9K-tbSUku-tRixxy-2jFX2fQ-26oFLhW-RV79UJ-tRiy93-VwPLqk-Zb3RuG-KCyzGP-cTxypj-FNu2ih-jgZLQu-cM6sg7-2irxaoQ-EYj6Wg-2kASpXv-e4XpVS-2i1aP32-2hVrG7g-2i8p7CE-6aqKYa-G8HLT4-2ktepSS-eSaj9W-2gx78WG-2aZLS5D-EntzFH-S8s5W5-wBXnkt-2jrwvu6-2k2dRGw-2hGWzmX-zqYien-4MuqbD-2huW4ev-2i6f37D-8CXUBh-2gk9DyB-aageGi-27FfkR4-2dfGbjY-224CPPX-L4MpDK-23McGB2-9Z7MNB" rel="noopener ugc nofollow" target="_blank">封面照片</a>由 Lucian 从 Flickr 制作，<a class="ae lg" href="https://creativecommons.org/licenses/by-nc-nd/2.0/" rel="noopener ugc nofollow" target="_blank">知识共享，版权所有</a>。</p></div></div>    
</body>
</html>