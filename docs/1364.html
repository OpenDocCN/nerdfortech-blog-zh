<html>
<head>
<title>Social application with Vue.js and GO</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Vue.js和GO的社交应用</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/social-application-with-vue-js-and-go-a22a1afb76eb?source=collection_archive---------15-----------------------#2021-03-15">https://medium.com/nerd-for-tech/social-application-with-vue-js-and-go-a22a1afb76eb?source=collection_archive---------15-----------------------#2021-03-15</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><figure class="hh hi ez fb hj hk er es paragraph-image"><div class="er es hg"><img src="../Images/4cdfb643ef90df60dcd8aaa1429ba169.png" data-original-src="https://miro.medium.com/v2/resize:fit:1088/format:webp/1*9RcvJALOdCOUBieIJCCMEg.jpeg"/></div><figcaption class="hn ho et er es hp hq bd b be z dx translated">标志归功于vuejs.org和golang.org</figcaption></figure><div class=""/><div class=""><h2 id="2613" class="pw-subtitle-paragraph iq hs ht bd b ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh dx translated">用vue.js和golang创建和服务一个类似twitter的应用程序第6部分:VUEX中的表单和数据</h2></div><p id="c5a5" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">这是本系列的第六部分。在这里检查所有零件:</p><ul class=""><li id="bced" class="ke kf ht jk b jl jm jo jp jr kg jv kh jz ki kd kj kk kl km bi translated"><a class="ae kn" href="https://ivano-dalmasso.medium.com/social-application-with-vue-js-and-go-4e4db0cdde64" rel="noopener">第一部分:设置</a></li><li id="e9bc" class="ke kf ht jk b jl ko jo kp jr kq jv kr jz ks kd kj kk kl km bi translated"><a class="ae kn" href="https://ivano-dalmasso.medium.com/social-application-with-vue-js-and-go-64b3adee8dac" rel="noopener">第二部分:VUE入门</a></li><li id="8e37" class="ke kf ht jk b jl ko jo kp jr kq jv kr jz ks kd kj kk kl km bi translated"><a class="ae kn" href="https://ivano-dalmasso.medium.com/social-application-with-vue-js-and-go-24a1d1e7137d" rel="noopener">第三部分:组件&amp;插槽</a></li><li id="c040" class="ke kf ht jk b jl ko jo kp jr kq jv kr jz ks kd kj kk kl km bi translated"><a class="ae kn" rel="noopener" href="/nerd-for-tech/social-application-with-vue-js-and-go-3a11d506fc38">第4部分:Vuex首次设置</a></li><li id="5b86" class="ke kf ht jk b jl ko jo kp jr kq jv kr jz ks kd kj kk kl km bi translated"><a class="ae kn" rel="noopener" href="/nerd-for-tech/social-application-with-vue-js-and-go-ef364b572422">第5部分:Vuex终结</a></li><li id="6dcf" class="ke kf ht jk b jl ko jo kp jr kq jv kr jz ks kd kj kk kl km bi translated">第6部分:Vuex中的表单和数据(this)</li><li id="f4eb" class="ke kf ht jk b jl ko jo kp jr kq jv kr jz ks kd kj kk kl km bi translated"><a class="ae kn" href="https://ivano-dalmasso.medium.com/social-application-with-vue-js-and-go-d9e563466b66" rel="noopener">第七部分:与golang服务器的连接</a></li><li id="d6a2" class="ke kf ht jk b jl ko jo kp jr kq jv kr jz ks kd kj kk kl km bi translated"><a class="ae kn" href="https://ivano-dalmasso.medium.com/social-application-with-vue-js-and-go-64978f7c381f" rel="noopener">第8部分:基于令牌的认证</a></li><li id="2aca" class="ke kf ht jk b jl ko jo kp jr kq jv kr jz ks kd kj kk kl km bi translated"><a class="ae kn" href="https://ivano-dalmasso.medium.com/social-application-with-vue-js-and-go-4d0caa37ddac" rel="noopener">第9部分:存储索引为DB的认证令牌</a></li></ul><p id="3faf" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">在本章中，我们将最终创建一些表单，这样我们就可以使用之前创建的存储，并在其中插入/更新一些数据。请注意，在本部分的最后，我们将有一个应用程序，它有一个客户端内存存储，我们可以在其中添加和更新值。此外，我们还没有一个持久的数据层:为此，我们将不得不等待更多的教训。</p><p id="0d0e" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">这里的主要目标是更新前端项目，你可以在这里找到代码<a class="ae kn" href="https://github.com/idalmasso/go-vue-tutorial-frontend/releases/tag/v0.6" rel="noopener ugc nofollow" target="_blank"/>。</p><h2 id="f32b" class="kt ku ht bd kv kw kx ky kz la lb lc ld jr le lf lg jv lh li lj jz lk ll lm ln bi translated">商店的更新</h2><p id="f178" class="pw-post-body-paragraph ji jj ht jk b jl lo iu jn jo lp ix jq jr lq jt ju jv lr jx jy jz ls kb kc kd hb bi translated">在插入实际的表单之前，让我们对post store做一些最后的更新，以便可以接受帖子和评论的插入。</p><p id="afe8" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">首先，删除状态列表中的所有post对象，这样它将作为一个空数组开始。然后，更新ADD_POST变体，使其也有一些逻辑来填充帖子的id(记住:当有一个工作的后端时，它将不再被使用)，并添加一个变体来为帖子添加评论，如下所示:</p><pre class="lt lu lv lw fd lx ly lz ma aw mb bi"><span id="aaf0" class="kt ku ht ly b fi mc md l me mf">ADD_POST(state, post) {<br/>      if (state.posts.length &lt; 1) {<br/>        post.id = 1;<br/>      } else {<br/>        const max = state.posts.reduce((prev, current) =&gt;<br/>          prev.id &gt; current.id ? prev : current<br/>        );<br/>        post.id = max.id + 1;<br/>      }<br/>      post.comments = [];<br/>      state.posts.push(post);<br/>    },</span><span id="798a" class="kt ku ht ly b fi mg md l me mf">ADD_COMMENT(state, { postId, comment }) {<br/>      const post = state.posts.find(post =&gt; post.id === postId);<br/>      if (post.comments.length &lt; 1) {<br/>        comment.id = 1;<br/>      } else {<br/>        const max = post.comments.reduce((prev, current) =&gt;<br/>          prev.id &gt; current.id ? prev : current<br/>        );<br/>        comment.id = max.id + 1;<br/>      }<br/>      post.comments.push(comment);<br/>    }<br/></span></pre><p id="fdfc" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">这里的代码非常简单。它为每个插入的帖子分配一个id，增量。第二个突变对评论也是如此。在actions中，在调用ADD_POST突变之前，还要插入帖子的日期，还要创建一个action，可以用一个comment做同样的事情，并调用相应的突变:</p><pre class="lt lu lv lw fd lx ly lz ma aw mb bi"><span id="9d79" class="kt ku ht ly b fi mc md l me mf">async addPost(context, post) {<br/>      post.date = getFormattedDate();<br/>      context.commit("ADD_POST", post);<br/>},<br/>async addComment(context, { postId, comment })<br/>{<br/>      comment.date = getFormattedDate();<br/>      context.commit("ADD_COMMENT", { postId, comment });<br/>}</span></pre><p id="6ed9" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">“<em class="mh"> getFormattedDate </em>”函数实际上是我之前在同一个文件中创建的一个实用函数，只是为了给帖子和评论添加一个格式良好的日期。</p></div><div class="ab cl mi mj gp mk" role="separator"><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn"/></div><div class="hb hc hd he hf"><h2 id="1fd5" class="kt ku ht bd kv kw kx ky kz la lb lc ld jr le lf lg jv lh li lj jz lk ll lm ln bi translated">更新帖子视图</h2><p id="ef2e" class="pw-post-body-paragraph ji jj ht jk b jl lo iu jn jo lp ix jq jr lq jt ju jv lr jx jy jz ls kb kc kd hb bi translated">现在我们有了一个可以添加帖子和评论的商店，我们必须在组件中实际使用这些新功能。</p><p id="121b" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">让我们添加一个新的组件，它可以用于输入单个文本，并且可以重用。在<em class="mh"> src/components </em>文件夹中添加一个新文件<em class="mh"> AddTextForm.vue </em>，并填入以下内容:</p><pre class="lt lu lv lw fd lx ly lz ma aw mb bi"><span id="c4aa" class="kt ku ht ly b fi mc md l me mf">&lt;template&gt;<br/>  &lt;form&gt;<br/>    &lt;label v-if="showLabel" :for="'text' + this._uid"&gt;<br/>     {{ textRequest }}&lt;/label&gt;<br/>    &lt;input<br/>      :id="'text' + this._uid"<br/>      type="text"<br/>      :placeholder="textRequest"<br/>      v-model="textValue"<br/>    /&gt;<br/>    &lt;button @click.prevent="submitted"&gt;submit&lt;/button&gt;<br/>  &lt;/form&gt;<br/>&lt;/template&gt;<br/><br/>&lt;script&gt;<br/>export default {<br/>  data() {<br/>    return {<br/>      textValue: ""<br/>    };<br/>  },<br/>  props: {<br/>    textRequest: { type: String, default: "" },<br/>    showLabel: { type: Boolean, default: false }<br/>  },<br/>  methods: {<br/>    submitted() {<br/>      this.$emit("text-added", this.textValue);<br/>      this.textValue = "";<br/>    }<br/>  },<br/>  emits: ["text-added"]<br/>};<br/>&lt;/script&gt;<br/><br/>&lt;style scoped&gt;<br/>label {<br/>  padding-right: 1rem;<br/>  display: block;<br/>}<br/>button {<br/>  margin-top: 1rem;<br/>  width: 10%;<br/>  border-top-right-radius: 8px;<br/>  border-bottom-right-radius: 8px;<br/>  background-color: darksalmon;<br/>  padding: 8px;<br/>}<br/>input {<br/>  box-sizing: border-box;<br/>  border-top-left-radius: 8px;<br/>  border-bottom-left-radius: 8px;<br/>  width: 80%;<br/>  padding: 8px 20px;<br/>}<br/>input:focus {<br/>  outline: 0;<br/>  background-color: wheat;<br/>}<br/>&lt;/style&gt;</span></pre><p id="0caf" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">这里一切都应该很清楚:我们使用了一对道具，一个决定是否在表单中显示标签，另一个决定要显示的文本框的占位符。</p><p id="71b5" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">这个文件中唯一的新东西实际上是使用了"<em class="mh"> v-model </em>"指令，它与输入字段一起使用，以一种反应的方式将输入中的值实际连接到组件数据中的变量。</p><p id="c9ac" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">在按钮的clicked事件中，调用的方法向任何使用它的父组件发出一个事件"<em class="mh"> text-added </em>"。另外，请注意，我们实现了一个“<em class="mh">发射</em>”配置参数，以让父节点知道，这不是强制性的，而是一个很好的最佳实践。</p><p id="6d83" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">这个事件发射为我们提供了vue中组件之间的第二种通信方式，第一种是“<em class="mh"> props </em>”，因此我们可以从父组件向子组件发送数据，反之亦然。</p><p id="8c76" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">这样，任何使用AddTextForm的组件都将能够监听事件"<em class="mh">文本添加的</em>"并获得插入的数据。</p><p id="b047" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">现在，让我们使用这个表单在Posts.vue组件中添加一些文章。更新模板，像这样</p><pre class="lt lu lv lw fd lx ly lz ma aw mb bi"><span id="3f3d" class="kt ku ht ly b fi mc md l me mf">&lt;div class="posts"&gt;<br/>    &lt;h1&gt;All Posts&lt;/h1&gt;<br/>    &lt;add-text-form<br/>      textRequest="Add Post"<br/>      v-if="loggedIn"<br/>      :showLabel="true"<br/>      @text-added="addPost"<br/>    &gt;&lt;/add-text-form&gt;<br/>    &lt;post-list :posts="posts" title="" /&gt;<br/>  &lt;/div&gt;</span></pre><p id="839f" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">所以，这一切都像以前一样，但我们添加了一个小标题和新的组件。只有当用户登录时，我们才显示这个组件，我们显示一个标签“Add Post ”,在事件“text-added”时，我们调用addPost方法。这其实很简单:</p><pre class="lt lu lv lw fd lx ly lz ma aw mb bi"><span id="e092" class="kt ku ht ly b fi mc md l me mf">methods: {<br/>    addPost(text) {<br/>      this.$store.dispatch("posts/addPost", {<br/>        user: this.$store.getters["auth/currentUser"].username,<br/>        post: text<br/>      });<br/>    }<br/>  }</span></pre><p id="82d9" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">因此，这只是分派addPost Post，传递实际的认证用户用户名和文本post。这将在操作中使用，并将文章添加到实际商店中。</p><p id="f12a" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">下一步自然是使用相同的add-text-form向帖子添加评论。这可以分两步完成。首先，我们必须更改BaseCard模板，这样它也可以有一些“actions”插槽，我们可以在其中插入一些其他代码。这很容易做到，在页脚后添加:</p><pre class="lt lu lv lw fd lx ly lz ma aw mb bi"><span id="7260" class="kt ku ht ly b fi mc md l me mf">&lt;div class="actions"&gt;<br/>   &lt;slot name="actions"&gt;&lt;/slot&gt;<br/>&lt;/div&gt;</span></pre><p id="5728" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">然后，我们可以在SinglePost组件中使用此插槽，在BaseCard的结束标记之前的页脚后添加以下行:</p><pre class="lt lu lv lw fd lx ly lz ma aw mb bi"><span id="8bfb" class="kt ku ht ly b fi mc md l me mf">&lt;template v-if="loggedIn" v-slot:actions&gt;<br/>   &lt;add-text-form<br/>        textRequest="Add comment"<br/>        :showLabel="false"<br/>        @text-added="text =&gt; addComment(text, post)"&gt;<br/>    &lt;/add-text-form&gt;<br/>&lt;/template&gt;</span></pre><p id="764b" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">注意，为此我们必须向存储的loggedIn getter添加一个mapGetter，以便仅在用户实际登录时呈现按钮。</p><p id="88a4" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">在事件“text-added”的发射上，它被称为函数<em class="mh"> addComment </em>，我们必须像这样添加到方法中:</p><pre class="lt lu lv lw fd lx ly lz ma aw mb bi"><span id="4d55" class="kt ku ht ly b fi mc md l me mf">addComment(text, post) {<br/>      this.$store.dispatch("posts/addComment", <br/>          {<br/>             postId: post.id,<br/>             comment: <br/>             {<br/>                user: this.currentUser.username,<br/>                post: text<br/>            }<br/>      });</span></pre><p id="d558" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">这显然会将评论添加到商店中，因此其他页面可以在需要时加载评论。</p><h2 id="4c8c" class="kt ku ht bd kv kw kx ky kz la lb lc ld jr le lf lg jv lh li lj jz lk ll lm ln bi translated">添加登录页面</h2><p id="9ee6" class="pw-post-body-paragraph ji jj ht jk b jl lo iu jn jo lp ix jq jr lq jt ju jv lr jx jy jz ls kb kc kd hb bi translated">到目前为止，登录按钮只是将实际用户的登录状态从“已登录”转换为“未登录”。将来，用户将不得不通过用户/密码表单请求登录，所以现在让我们创建一个登录页面来完成这项工作。现在它将是一个占位符，只有一个“登录”按钮，但它将很快完成其他功能。</p><p id="214a" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">在视图文件夹中，使用以下内容创建Login.vue文件:</p><pre class="lt lu lv lw fd lx ly lz ma aw mb bi"><span id="8447" class="kt ku ht ly b fi mc md l me mf">&lt;template&gt;<br/>  &lt;div class="login"&gt;<br/>    &lt;button @click="loginButtonClicked"&gt;LOGIN&lt;/button&gt;<br/>  &lt;/div&gt;<br/>&lt;/template&gt;<br/><br/>&lt;script&gt;<br/>import { mapActions } from "vuex";<br/>export default {<br/>  methods: {<br/>    ...mapActions({ login: "auth/login" }),<br/>    loginButtonClicked() {<br/>      this.login().then(() =&gt; {<br/>        this.$router.push({ name: "Posts" });<br/>      });<br/>    }<br/>  }<br/>};<br/>&lt;/script&gt;<br/><br/>&lt;style scoped&gt;<br/>button {<br/>  margin-top: 1rem;<br/>  width: 20rem;<br/>  height: 5rem;<br/>  border-radius: 8px;<br/>  background-color: darksalmon;<br/>  padding: 8px;<br/>}<br/>&lt;/style&gt;</span></pre><p id="85ed" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">这里没有什么新东西，只需要注意"<em class="mh"> router.push </em>"指令，它会在登录存储操作成功完成后将浏览器重定向到Posts视图。</p><p id="edc5" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">要完成这一步，我们现在只需更改应用程序栏，当按下登录按钮时，应用程序栏必须导航到登录视图。为此，只需稍微修改一下登录链接，从一个“<em class="mh">标签和一个</em>标签改为一个路由器链接，该链接指向登录视图:</p><pre class="lt lu lv lw fd lx ly lz ma aw mb bi"><span id="4cc9" class="kt ku ht ly b fi mc md l me mf">&lt;router-link<br/>        class="app-bar-item"<br/>        href="#"<br/>        v-if="!loggedIn"<br/>        @click.prevent :to="{ name: 'Login' }"LOGIN        &gt;LOGIN&lt;/router-link&gt;</span></pre><p id="9f47" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">此外，为了完成此更新，我们可以确保当用户从应用程序注销时，会自动转到登录页面，并将此新方法附加到注销链接点击事件:</p><pre class="lt lu lv lw fd lx ly lz ma aw mb bi"><span id="5d2b" class="kt ku ht ly b fi mc md l me mf">logoutButtonClicked() {<br/>      this.logout().then(() =&gt; {<br/>        this.$router.push({ name: "Login" });<br/>      });<br/>    }</span></pre><p id="7549" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">最后要做的是，更新路由器文件以添加新的“登录”路由，如下所示:</p><pre class="lt lu lv lw fd lx ly lz ma aw mb bi"><span id="073a" class="kt ku ht ly b fi mc md l me mf">import Login from "../views/Login.vue";</span><span id="b5e4" class="kt ku ht ly b fi mg md l me mf">...<br/>{<br/>     path: "/login",   <br/>     name: "Login",    <br/>     component: Login<br/>}</span></pre><h2 id="44c9" class="kt ku ht bd kv kw kx ky kz la lb lc ld jr le lf lg jv lh li lj jz lk ll lm ln bi translated">在登录状态下增加一些导航守卫</h2><p id="0125" class="pw-post-body-paragraph ji jj ht jk b jl lo iu jn jo lp ix jq jr lq jt ju jv lr jx jy jz ls kb kc kd hb bi translated">如果用户没有登录，我们希望用户不能进入某些页面(例如，用户页面)。因此，首先，我们可以转到应用程序栏组件，如果用户未被启用，则只显示一些链接:在模板中，将实际存在的<em class="mh"> v-for="link in links" </em>更改为<em class="mh">v-for = " link in active links "</em>，并添加如下的<em class="mh"> activeLinks </em>计算方法:</p><pre class="lt lu lv lw fd lx ly lz ma aw mb bi"><span id="713d" class="kt ku ht ly b fi mc md l me mf">activeLinks() {<br/>      return this.links.filter(<br/>        link =&gt; link.visibleIfLoggedOut || this.loggedIn<br/>      );<br/>    }</span></pre><p id="3931" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">这样，所显示的链接只有在用户注销或登录时才可见。我们还应该将属性"<em class="mh">visibleifloggeout</em>"添加到链接中，如下所示:</p><pre class="lt lu lv lw fd lx ly lz ma aw mb bi"><span id="b041" class="kt ku ht ly b fi mc md l me mf">links: [<br/>        {<br/>          visibleIfLoggedOut: true,<br/>          name: "Posts",<br/>          to: { name: "Posts" }<br/>        },<br/>        {<br/>          visibleIfLoggedOut: false,<br/>          name: "User",<br/>          to: {<br/>            name: "User",<br/>            params: {<br/>              userid: this.$store.getters["auth/currentUser"].username<br/>            }<br/>          }<br/>        }</span></pre><p id="9c8b" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">如果用户被注销，这段代码实际上会隐藏“用户”的链接，但这实际上并不是我们需要做的全部。事实上，如果用户将用户页面的url放在浏览器的地址栏中，就会看到该页面。在这种情况下，我们需要确保路由器进行某种处理来决定用户是否可以查看某些页面。</p><p id="72ff" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">这实际上是通过导航卫士来完成的:这些配置方法可以用来指示路由器在导航事件调用之前和之后要做的事情。</p><p id="dce7" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">这些可以在路由或全局级别设置，在这种情况下，例如，我们将在用户路由上设置导航保护，告知如果用户实际上没有登录，则应该将其路由到登录页面。同样，我们希望已经登录的用户不要转到登录页面，而是被重定向到例如posts页面。</p><p id="c79b" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">在路由器文件中，更新两条路由，如下所示:</p><pre class="lt lu lv lw fd lx ly lz ma aw mb bi"><span id="7d93" class="kt ku ht ly b fi mc md l me mf">import store from "@/store/index.js";<br/>...<br/>  {<br/>    path: "/user/:userid",<br/>    name: "User",<br/>    component: User,<br/>    props: true,<br/>    beforeEnter: (to, from, next) =&gt; {<br/>      if (!store.getters["auth/isLoggedIn"]) {<br/>        next({ name: "Login" });<br/>      } else {<br/>        next();<br/>      }<br/>    }<br/>  },<br/>  {<br/>    path: "/login",<br/>    name: "Login",<br/>    component: Login,<br/>    //This is not needed right by now, because the store is  refreshed on page refresh... Will be needed!<br/>    beforeEnter: (to, from, next) =&gt; {<br/>      if (store.getters["auth/isLoggedIn"]) {<br/>        next({ name: "Posts" });<br/>      } else {<br/>        next();<br/>      }<br/>    }<br/>  }</span></pre><p id="e0b4" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">beforeEnter配置实际上是一个具有三个输入参数的函数:</p><ol class=""><li id="b042" class="ke kf ht jk b jl jm jo jp jr kg jv kh jz ki kd mp kk kl km bi translated">to:被导航到的目标<a class="ae kn" href="https://router.vuejs.org/api/#the-route-object" rel="noopener ugc nofollow" target="_blank">路线对象</a>。</li><li id="2638" class="ke kf ht jk b jl ko jo kp jr kq jv kr jz ks kd mp kk kl km bi translated">出发地:当前被导航离开的路线</li><li id="2f50" class="ke kf ht jk b jl ko jo kp jr kq jv kr jz ks kd mp kk kl km bi translated">下一个:解析导航的函数。当它被调用时，取决于传递给它的参数，解析将会不同:如果没有参数被传递，解析将是正常的解析，如果我们传递给它一个route对象，这将被推入浏览器的历史中(在我们的例子中，我们将去那里，而不是正常的路由)。</li></ol><p id="aa51" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">因此，在我们的例子中，我们可以对这两条路线有我们想要的行为。显然，没有什么可以阻止恶意用户强制请求，如果他真的想要的话，所以也要记住在后端复制所有的“安全”控制！</p><p id="eee5" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">现在，我们已经在前端达到了一个几乎停止的点，所以下一步将开始添加一个go后端，它将为一些api提供实际的帖子，以及我们需要的身份验证功能。</p></div></div>    
</body>
</html>