# 一尝二郎

> 原文：<https://medium.com/nerd-for-tech/a-taste-of-erlang-15556adfd916?source=collection_archive---------13----------------------->

![](img/e5566c25129b49c54011430c8f763d0f.png)

托马斯·索贝克在 [Unsplash](https://unsplash.com/s/photos/telecommunication?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText) 上的照片

Erlang 以一种极度渴求糖的语法而闻名，这导致了从 Ruby 引入优点，并最终发明了 Elixir 语言。然而，对于来自 ML 语言的人来说，比如 OCaml 或 Haskell，甚至会感到熟悉。

在本文中，我将探究这种语言是关于什么的，围绕它的讨论是什么，以及它有时是如何试图欺骗不知情的开发人员的。

# 从实验室到你的手掌

大约 40 年前，爱立信计算机科学实验室开始研究特别适合于实现电信解决方案的编程语言。逻辑编程语言 Prolog 是它的直接前身，但后来证明它对于实现核心功能来说太慢了，然后这些部分最终用 c 重写。在开发过程中，团队专注于发明一种适合电信需求的最小语言，这种语言还能够以高性能大规模并行运行，同时提供最大的正常运行时间。这些关键需求决定了该语言和相关生态系统的特性，并使该语言适用于使用一组称为开放电信平台(OTP)的 Erlang 库以接近实时的速度执行的编写服务器。

这种表现吸引了一些公司，他们的目标是为移动设备实现新的即时消息解决方案。其中一家公司是 WhatsApp，他们的成功也让一些人开始关注 Erlang 及其平台。

# 二郎是什么动物？

使 Erlang 适合于实现电信解决方案的需求也决定了该语言将具有什么样的特性。Erlang 是一种函数式编程语言。它运行在一个需要编译的虚拟机中，但是它也能够在被称为 *erl* 的 REPL(读取-评估-打印循环)中解释运行。Erlang 的虚拟机被称为 BEAM(波格丹一世/比约恩的 Erlang 抽象机)，因此类似于 Java 或. NET 的虚拟机。它们一起使得编写具有以下特征的应用程序成为可能:

*   **分布式** —可以在几台机器上并行运行，同时仍然作为一个整体工作
*   **容错** —优雅地接受错误，并能够在必要时重启自身的某些部分
*   **软实时** —它的响应时间几乎和那些用来驱动心脏起搏器或火箭的程序一样低
*   **高可用性** —系统始终保持在线，主要是因为它的容错能力，也因为它
*   **热插拔** —这意味着无需停止系统或应用程序本身就可以重新加载、替换或重启部分应用程序

该语言实现了以下函数式编程概念(在一定程度上):

*   **高阶函数** —函数可以接受其他函数作为参数
*   **一级函数** —函数可以匿名定义
*   **不变性** —变量的值在第一次赋值后不能改变
*   **模式匹配** —存储在复合数据类型中的值可以在参数、守卫、案例中提取；又名*解构*
*   **急切求值** —表达式一被赋值给变量就被求值，这与懒惰求值相反，懒惰求值只计算实际使用的时间
*   **单一赋值** —变量在首次初始化后不能被重新赋值给新值
*   **列表理解** —从现有列表生成列表

它还具有**动态类型**，这意味着变量的类型不是在编译时强制或确保的，而是在运行时强制或确保的(尽管静态类型检查可以与名为*透析器*的可选工具一起使用)。

Erlang 应用程序通常作为大量轻量级进程运行，其中 Erlang 进程“比操作系统线程轻得多”。

运行时为 Erlang 变量分配的内存由单独运行的垃圾收集器动态自动释放。

# 哪种动物不是？

出于性能和其他实际原因，Erlang 不得不做出一些牺牲，以区别于其他 FP 语言。Erlang 不是一种纯粹的函数式语言，这意味着它不能避免副作用，事实上，出于实际原因，它在任何必要的时候都严重依赖于这些副作用。它也不是静态类型的，尽管可以在编译时用可选的工具检查类型。尽管 Erlang 运行时是软实时的，但它并不适用于实现高性能应用程序，因为在这些应用程序中，性能还会受到常数因素的影响，例如图像和信号处理以及大容量数据排序，以及必须进行低级访问的应用程序，如编写操作系统驱动程序。

# 向二郎问好

这里我们定义了一个模块(FP 封装容器),它只导出一个函数，这个函数与除以零无关，但是不接受任何参数(因此是 0 ),并在标准输出中打印一个字符串。在 Erlang 中，如果我们想要记录代码，百分号的数量会迅速增加(这里我只保留了两个百分号)。此外，新行不允许像往常一样在字符串中标记`\n`，而是使用`~n`，这增加了语言的怪异语法。

我们可以在 Erlang 中这样声明一个值:`Value = 5`，但是这不能在模块级别上工作，只能在函数中工作。这令人困惑，因为我们被允许在 REPL 自由使用它们。然而，定义一个只返回我们指定的值的函数是完全有效的，以后可以随时调用:

```
days() -> [ mon, tue, wed, thu, fri, sat, sun ].
months() -> [ jan, feb, mar, apr, may, jun, jul, aug, sep, oct, nov, dec ].
```

这些列表只包含 *atom* s，它们是类似于 *enum* s 的自包含值，但是不必担心它们的值。

请注意，在 Erlang 中，指令以句点结尾，但这并不意味着逗号和分号将保持无效。

# 潜入水中

假设我们想要编写一些日历函数，因为我们在 Erlang 的文档中找不到已经实现的函数，或者因为我们对它给出的结果不满意([calendar:date _ to _ Gregorian _ days/3](https://erlang.org/doc/man/calendar.html#date_to_gregorian_days-3)返回 0 年和所提供的日期之间的天数，但是在公历中没有[0 年](https://en.wikipedia.org/wiki/Year_zero))。

我们可以这样做:

现在让我提一下在这个片段中我们可以当场抓住的一些 Erlang 特性。

*   第 1 行:为了立即执行，使用`.`
*   第 29–33 行:带`when`的守卫
*   36:与`=:=`逻辑相等
*   37: *我们还没有结束*和`;`——编写替代实现的 Erlang 方式，这里是`else if`
*   39:如果我有另外一个*或者* …
*   42，47:多态函数——我们为二月定义了单独的逻辑
*   53:列表理解生成一个月中每一天的列表
*   55:获取列表头部和尾部的模式匹配
*   58:匿名函数是`fun`
*   58:更诡异的逻辑不等式`=/=`
*   70–76:函数重载
*   75:迷惑不知情的人:`=<`
*   81:带花括号的元组
*   81、82:用`,`连续做事

《准则》中没有提到的荣誉奖，但会引起很多令人头疼的问题:

```
Y = 1.
M = jan.
Y =:= 1 and M =:= jan.
```

这将给你:

```
* 1: syntax error before: '=:='
```

这不是很有帮助，但是在 Erlang 中会出现错误消息。对于那些好奇的人来说，问题不在于相等运算符，而在于享有优先权的`and`，因此`1 and M`抢了风头，让解释器对`Y =:=`可能意味着什么一无所知。要解决这个问题，请使用括号:

```
(Y =:= 1) and (M =:= jan).
```

返回`true`。宇宙平衡恢复了。

# 变得无助

不知何故，Erlang 网站上的[文档忠实地反映了这种语言的怪异之处，并且很容易让人迷失。有些函数看起来并不合理(`hd`、`tl`——列表的头部和尾部，但不在`lists`模块中)，有些类别(如`erts`)对新手来说毫无意义。](https://www.erlang.org/docs)

我们可以把这理解为一种尝试，让不熟悉的开发人员在获得他们所寻找的信息之前浏览整个文档。这有时会使我们感到无助，而不是得到帮助。然而，内容本身足够清晰明了，所以花在文档上的时间并没有浪费。

# 裁决

我有什么资格评判像 Erlang 这样强大而伟大的语言呢？我甚至还没有触及到这里的表面！我应该谈过 Erlang 控制并发性的方式、OTP 库、它对 [Actor 模型](https://en.wikipedia.org/wiki/Actor_model)的实现等等，但是正如标题所示，我在这里的目标只是尝试一下语言本身。说到这里，我可以说 **Erlang 非常有趣！**

尽管它有些古怪，但其著名的性能和(否则)干净的风格吸引人们去了解更多。毕竟，它与其他 FP 语言没有太大的不同，尤其是与 ML 领域的语言。虽然它没有那么严格，这使得潜水相对容易。伟大的书籍也可以开始使用，安装工具集也是小菜一碟。

我想说，对于那些对消息传递和类似特性感兴趣，但不是纯粹主义者的人来说，这绝对值得一试，熟悉一下。这也意味着对那些打算使用它的副产品——长生不老药的人来说是一个巨大的好处。Erlang 可以提供很多东西，并且在自己的领域做得非常好，证明了它最近受到的关注。