<html>
<head>
<title>Meeting Room — Amazon Interview Problem</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">会议室——亚马逊面试问题</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/meeting-room-amazon-interview-problem-72609de8d776?source=collection_archive---------2-----------------------#2021-05-25">https://medium.com/nerd-for-tech/meeting-room-amazon-interview-problem-72609de8d776?source=collection_archive---------2-----------------------#2021-05-25</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><figure class="hh hi ez fb hj hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es hg"><img src="../Images/9dd995e4606f9aaed71508dfc50e708e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zQJZHgEZ-jBZMgLyIDejlw.jpeg"/></div></div><figcaption class="hr hs et er es ht hu bd b be z dx translated"><a class="ae hv" href="https://unsplash.com/@bchild311?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">本杰明·蔡尔德</a>在<a class="ae hv" href="https://unsplash.com/s/photos/meeting?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><div class=""/><p id="28e8" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在这篇博客中，我们将讨论一个中等标签的问题。这个问题在亚马逊和脸书的采访中经常被问到。</p><h2 id="6250" class="jt ju hy bd jv jw jx jy jz ka kb kc kd jg ke kf kg jk kh ki kj jo kk kl km kn bi translated">253。第二会议室</h2><p id="f6a4" class="pw-post-body-paragraph iv iw hy ix b iy ko ja jb jc kp je jf jg kq ji jj jk kr jm jn jo ks jq jr js hb bi translated">给定一组会议时间间隔<code class="du kt ku kv kw b">intervals</code>，其中<code class="du kt ku kv kw b">intervals[i] = [starti, endi]</code>，返回<em class="kx">所需会议室的最小数量</em>。</p><p id="b0f3" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">示例:</p><pre class="ky kz la lb fd lc kw ld le aw lf bi"><span id="3ff3" class="jt ju hy kw b fi lg lh l li lj"><strong class="kw hz">Input:</strong> intervals = [[9,10],[4,9],[5,17]]<br/><strong class="kw hz">Output:</strong> 2</span></pre><h2 id="a3f6" class="jt ju hy bd jv jw jx jy jz ka kb kc kd jg ke kf kg jk kh ki kj jo kk kl km kn bi translated">方法:</h2><p id="0877" class="pw-post-body-paragraph iv iw hy ix b iy ko ja jb jc kp je jf jg kq ji jj jk kr jm jn jo ks jq jr js hb bi translated">我们需要找出有多少同时发生的会议。一旦我们有了这些信息，我们就可以找到所需会议室的数量。要找到任何给定时间的并发会议，我们需要知道有多少会议的开始和结束时间。</p><p id="b385" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们可以采用一种强力方法，从最小开始时间开始，一直到最大结束时间，然后检查哪个时间能让我们同时召开最多的会议。</p><p id="aedb" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">为了改进蛮力方法，我们可以做的不是一直这样做，而是只对接触点计时，即开始和结束。我们知道，只有当另一个会议开始，并且已经有一个会议开始但尚未结束时，会议之间才会发生重叠。因此，如果我们遇到两个连续的开始时间，这意味着我们在那个时候需要两个会议室。当我们遇到结束时间时，这表明我们已经结束了会议，我们不需要那个会议室。</p><figure class="ky kz la lb fd hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es lk"><img src="../Images/f571ff029f79a003f7d36f9ce4786be6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YNm9XcVcqFweFW-wvBYOow.png"/></div></div></figure><h2 id="bd7a" class="jt ju hy bd jv jw jx jy jz ka kb kc kd jg ke kf kg jk kh ki kj jo kk kl km kn bi translated">代码实现:</h2><pre class="ky kz la lb fd lc kw ld le aw lf bi"><span id="b5ce" class="jt ju hy kw b fi lg lh l li lj">def minMeetingRooms(intervals):<br/>    starts = sorted([interval[0] for interval in intervals])<br/>    ends = sorted([interval[1] for interval in intervals])<br/>    meet_count, cur_count = 0, 0<br/>    s_ptr, e_ptr = 0, 0<br/>    while s_ptr &lt; len(intervals):<br/>        if starts[s] &lt; ends[e]:<br/>            s_ptr += 1<br/>            cur_count += 1<br/>        else:<br/>            e_ptr += 1<br/>            cur_count -= 1<br/>        meet_count = max(meet_count, cur_count)<br/>    return meet_count</span></pre><p id="81f7" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hz">时间复杂度:</strong> O(NlogN)进行排序。While循环是n的一次传递。</p><p id="4555" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hz">空间复杂度:</strong> O(N)当我们在数组中存储开始和结束时间时</p><h2 id="29dd" class="jt ju hy bd jv jw jx jy jz ka kb kc kd jg ke kf kg jk kh ki kj jo kk kl km kn bi translated">替代实施:</h2><p id="bb6c" class="pw-post-body-paragraph iv iw hy ix b iy ko ja jb jc kp je jf jg kq ji jj jk kr jm jn jo ks jq jr js hb bi translated">我们可以跟踪会议结束时间。每当我们看到一个会议的开始时间小于最小的会议结束时间，我们就增加计数。一旦我们到达比计划首先结束的会议的结束时间更长的开始时间，我们就删除该会议的结束时间，因为到那时会议已经结束了。我们一直这样做，直到我们达到最后的会议日程。为了跟踪会议结束时间并删除最早的结束时间，我们使用堆数据结构。因为在min heap中总是会弹出最小的元素，这里是第一个结束的会议。</p><figure class="ky kz la lb fd hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es ll"><img src="../Images/e3fdee956abf9d2f0556b65d260b6269.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SxqhSPGfx-HgJX7oX-G3Vg.png"/></div></div></figure><pre class="ky kz la lb fd lc kw ld le aw lf bi"><span id="6a60" class="jt ju hy kw b fi lg lh l li lj">from heapq import *<br/>def minMeetingRooms( intervals):<br/>    intervals.sort(key=lambda x: x[0])<br/>    heap = []<br/>    res = 0<br/>    for interval in intervals:<br/>        if len(heap)==0 or heap[0]&gt;interval[0]:<br/>            res += 1<br/>        else:<br/>            heappop(heap)<br/>        heappush(heap, interval[1])<br/>    return res</span></pre><p id="f3fb" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hz">时间复杂度:</strong> O(NlogN)进行排序。While循环是n的一次传递。</p><p id="1a48" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hz">空间复杂度:</strong> O(N)当我们在数组中存储开始和结束时间时</p><p id="b5ca" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">快乐的编码！！</p></div></div>    
</body>
</html>