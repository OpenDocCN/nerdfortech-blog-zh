<html>
<head>
<title>Back To Basics: Rewind, React!</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">返璞归真:倒带，反应！</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/back-to-basics-rewind-react-aaf96639e9ea?source=collection_archive---------13-----------------------#2021-04-17">https://medium.com/nerd-for-tech/back-to-basics-rewind-react-aaf96639e9ea?source=collection_archive---------13-----------------------#2021-04-17</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="58be" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">反应堆基础复习</h2></div><p id="2967" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">当我经历毕业后找工作的过程时，我想回到基础，以此来巩固我在过去四个月中学到的知识。在我命名为“回归基础”的这个系列中，我着眼于广泛的主题，并将其分解到核心。也许它可以帮助另一个程序员经历一个新兵训练营或任何需要它的人的复习。</p><figure class="ju jv jw jx fd jy er es paragraph-image"><div class="er es jt"><img src="../Images/b90c38a989adae6b21c93d85199d7a85.png" data-original-src="https://miro.medium.com/v2/resize:fit:1330/format:webp/1*C31HhCACb8TWhto7sVVezQ.jpeg"/></div><figcaption class="kb kc et er es kd ke bd b be z dx translated">让我们回顾反应！</figcaption></figure><p id="291b" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在这篇文章中，我将回顾一下<strong class="iz hj">反应</strong>的基本原理。我将分解核心概念，这些概念可以被视为对JavaScript库的回顾或介绍。</p></div><div class="ab cl kf kg gp kh" role="separator"><span class="ki bw bk kj kk kl"/><span class="ki bw bk kj kk kl"/><span class="ki bw bk kj kk"/></div><div class="hb hc hd he hf"><h1 id="7f78" class="km kn hi bd ko kp kq kr ks kt ku kv kw io kx ip ky ir kz is la iu lb iv lc ld bi translated">什么是反应？</h1><p id="563e" class="pw-post-body-paragraph ix iy hi iz b ja le ij jc jd lf im jf jg lg ji jj jk lh jm jn jo li jq jr js hb bi translated">直接从官方文件上撕下来的:</p><blockquote class="lj lk ll"><p id="b4be" class="ix iy lm iz b ja jb ij jc jd je im jf ln jh ji jj lo jl jm jn lp jp jq jr js hb bi translated">React是一个用于构建用户界面的JavaScript库。</p></blockquote><p id="a1c4" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">需要指出的是，React实际上是一个JavaScript库，而<em class="lm">不是</em>框架。取决于你和谁交谈，这可能是一个激烈辩论的话题。然而，React的魅力在于它提供了比框架更多的灵活性。React具有模块化、关注点分离，甚至允许您在单个应用程序中反复重用组件。您可以在web应用程序中自由使用React的数量。</p><p id="376d" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">React用于构建用户界面。它是UI库，是构建UI组件的工具。我们告诉React我们希望UI的每个组件应该如何外观、更新和呈现。这就是为什么我们说React是声明性的。它引入了虚拟DOM的概念。当我们用React编写代码时，我们不会直接改变屏幕上的内容。相反，我们操纵虚拟DOM。让我们打破这个概念！</p><h1 id="5aea" class="km kn hi bd ko kp lq kr ks kt lr kv kw io ls ip ky ir lt is la iu lu iv lc ld bi translated">虚拟DOM &amp;和解的过程</h1><p id="4de0" class="pw-post-body-paragraph ix iy hi iz b ja le ij jc jd lf im jf jg lg ji jj jk lh jm jn jo li jq jr js hb bi translated">在我们开始之前，让我们先定义一下什么是<strong class="iz hj"> DOM </strong>。<strong class="iz hj"> DOM <em class="lm">又名</em>文档对象模型</strong>是构成HTLM或XML文档的结构和内容的数据的面向对象表示。每个元素的样式、结构和内容都可以用JavaScript这样的脚本语言来操作。</p><p id="df04" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">那么，为什么React让我们与虚拟DOM而不是真实的DOM进行交互呢？</p><p id="0875" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">嗯，DOM操作很慢。频繁地修改和更新DOM会影响性能。让我们看看DOM的层次结构。</p><figure class="ju jv jw jx fd jy er es paragraph-image"><div role="button" tabindex="0" class="lw lx di ly bf lz"><div class="er es lv"><img src="../Images/223bd1e4a1eafbdfeb937337ec64fd5d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*W-eDMePPMuYpaf7W.png"/></div></div></figure><h2 id="a658" class="ma kn hi bd ko mb mc md ks me mf mg kw jg mh mi ky jk mj mk la jo ml mm lc mn bi translated">DOM树</h2><p id="ad09" class="pw-post-body-paragraph ix iy hi iz b ja le ij jc jd lf im jf jg lg ji jj jk lh jm jn jo li jq jr js hb bi translated">DOM的层次结构被组织成一个树形结构，如图所示。所有元素和对象都表示为<strong class="iz hj">节点</strong>。每个节点都有自己的属性和方法。节点可以有一个父节点，也可以有许多子节点。</p><p id="2a84" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">当我们改变一个元素时，DOM会更新该元素，但也会重新呈现它的所有子元素。</p><p id="85de" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">网页可能很复杂，由许多UI组件组成。因此，重新渲染越来越多组件的过程可能会非常缓慢。</p><p id="1152" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">大多数网页都是动态的单页应用程序，其中包含成千上万的<code class="du mo mp mq mr b">&lt;div&gt;</code>和许多与之相关的事件处理程序。想象一下，在所有这些&lt; div &gt;中寻找你需要更新的元素。最重要的是，遍历它的所有子对象来重新渲染它们。这不仅在调试时难以管理，而且非常耗时且效率低下。这就是虚拟DOM的用武之地！</p><h2 id="4b76" class="ma kn hi bd ko mb mc md ks me mf mg kw jg mh mi ky jk mj mk la jo ml mm lc mn bi translated"><strong class="ak">虚拟DOM </strong></h2><p id="43c2" class="pw-post-body-paragraph ix iy hi iz b ja le ij jc jd lf im jf jg lg ji jj jk lh jm jn jo li jq jr js hb bi translated"><strong class="iz hj">虚拟DOM </strong>只是实际DOM的一个表示，UI保存在内存中。它和真实的DOM有相同的属性，但是它没有能力直接改变所看到的东西。因此，您可以将它视为真实DOM的轻量级副本。</p><h2 id="3b28" class="ma kn hi bd ko mb mc md ks me mf mg kw jg mh mi ky jk mj mk la jo ml mm lc mn bi translated"><strong class="ak">对账</strong></h2><p id="253c" class="pw-post-body-paragraph ix iy hi iz b ja le ij jc jd lf im jf jg lg ji jj jk lh jm jn jo li jq jr js hb bi translated">React用来对真实DOM进行更改的过程被称为<strong class="iz hj">协调</strong>。</p><p id="0b4b" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">当呈现元素时，React元素树虚拟表示将被保存在内存中。当react组件的状态发生变化或者添加了新元素时，会有一个带有必要更新的新版本的虚拟DOM。React然后会挖掘出它保存在内存中的旧版本的虚拟DOM。在那里，React使用<strong class="iz hj">差分算法</strong>来比较新版本和快照。</p><h2 id="fe47" class="ma kn hi bd ko mb mc md ks me mf mg kw jg mh mi ky jk mj mk la jo ml mm lc mn bi translated">差分算法</h2><p id="eeeb" class="pw-post-body-paragraph ix iy hi iz b ja le ij jc jd lf im jf jg lg ji jj jk lh jm jn jo li jq jr js hb bi translated"><strong class="iz hj">“Diffing”</strong>是指检查虚拟DOM的to版本之间的差异的过程。</p><p id="42ed" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">React通过实现启发式O(n)算法来实现这一点。(时间复杂度加成事实！).</p><p id="7c3f" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">它这样做基于两个假设。在React文档中，它声明:</p><blockquote class="lj lk ll"><p id="4d91" class="ix iy lm iz b ja jb ij jc jd je im jf ln jh ji jj lo jl jm jn lp jp jq jr js hb bi translated">1.两种不同类型的元素会产生不同的树。</p><p id="21e0" class="ix iy lm iz b ja jb ij jc jd je im jf ln jh ji jj lo jl jm jn lp jp jq jr js hb bi translated">2.开发者可以用一个<code class="du mo mp mq mr b">key</code>道具提示哪些子元素在不同的<br/>渲染中是稳定的。</p></blockquote><p id="7b6f" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">现在，行为可以根据根元素的类型而变化。有兴趣的可以在这里了解更多<a class="ae ms" href="https://reactjs.org/docs/reconciliation.html#the-diffing-algorithm" rel="noopener ugc nofollow" target="_blank">！</a></p><p id="7ff3" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">通过计算差异，React pin指出实际DOM中需要更新哪些子树。React将只对真正DOM上的那些子树进行修改。这就是为什么它更快更有效。更新虚拟DOM是即时的，React通过将DOM更新限制在一定数量的对象上，减少了DOM操作的时间。因此，性能明显更好。</p><p id="dd5f" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="iz hj">反应组分</strong></p><p id="d653" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">React就是把UI分解成组件！每一个都是独立的，可以自由地重复使用。React组件的核心基本上是JavaScript函数，这些函数返回React元素，这些元素详细说明了应该在浏览器上显示什么。</p><p id="a798" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">每个组件都会收到一个属性列表，我们称之为<strong class="iz hj">道具</strong>。它们可以作为第一个参数传递给其他组件。它本质上是一个填充了属性和相应值的对象。</p><p id="fa2e" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">有两种类型的组件:函数组件和类组件。</p><p id="3353" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="iz hj">功能组件</strong>定义为:</p><figure class="ju jv jw jx fd jy"><div class="bz dy l di"><div class="mt mu l"/></div></figure><p id="5a7e" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">正如你所看到的，功能组件几乎就是JavaScript函数！</p><p id="ae8b" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="iz hj">类组件:</strong></p><figure class="ju jv jw jx fd jy"><div class="bz dy l di"><div class="mt mu l"/></div></figure><p id="11b2" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">类组件的定义略有不同。一个明显的区别是<code class="du mo mp mq mr b">render()</code>函数。在你回来之前不要忘记渲染！</p><p id="a119" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">那我用哪个呢？嗯，如果一个组件需要跟踪它的数据(即状态)，那么它必须被定义为一个类组件。功能组件<em class="lm">无法</em>处理状态，并且<em class="lm">无法</em>访问<a class="ae ms" rel="noopener" href="/codex/the-lifecycle-of-a-react-component-8e01332a068d">反应生命周期方法</a>。</p><p id="d5d7" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如果状态不重要，您应该使用功能组件，因为它们更容易阅读和测试。然而，在React 16.8中，React团队向世界介绍了<a class="ae ms" href="https://reactjs.org/docs/hooks-intro.html" rel="noopener ugc nofollow" target="_blank"> React Hooks </a>。它们允许功能组件拥有与类组件相同的能力，而无需编写它们！它肯定会变得越来越流行，但我会在以后的文章中更多地谈论它，因为我正在学习它:)</p><h1 id="3399" class="km kn hi bd ko kp lq kr ks kt lr kv kw io ls ip ky ir lt is la iu lu iv lc ld bi translated">反应+ JSX</h1><p id="fd37" class="pw-post-body-paragraph ix iy hi iz b ja le ij jc jd lf im jf jg lg ji jj jk lh jm jn jo li jq jr js hb bi translated">在这两个例子中，我都返回了看起来像HTML的内容，但是不要被愚弄了。那是<strong class="iz hj"> JSX，<em class="lm">不是HTML也不是JavaScript。</em> </strong> JSX是JavaScript的语法扩展，它让我们能够生成React元素。这些元素以类似于HTML的语法编写，但是具有JavaScript的强大功能。然后通过编译器进行翻译。</p><p id="e4c1" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在上面的例子中，标题标签<code class="du mo mp mq mr b">&lt;h1&gt; Welcome! &lt;/h1&gt;</code>实际上是<code class="du mo mp mq mr b">React.createElement(“h1”, null, “ Welcome! “)</code>。我们可以通过使用JSX并在之后翻译它来避免反复写<code class="du mo mp mq mr b">React.createElement()</code>。</p><p id="1652" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">关于JSX的另一个很酷的事情是你可以在你的代码中的任何地方使用JavaScript，只要它写在花括号内！</p></div><div class="ab cl kf kg gp kh" role="separator"><span class="ki bw bk kj kk kl"/><span class="ki bw bk kj kk kl"/><span class="ki bw bk kj kk"/></div><div class="hb hc hd he hf"><h1 id="c438" class="km kn hi bd ko kp kq kr ks kt ku kv kw io kx ip ky ir kz is la iu lb iv lc ld bi translated">结论</h1><p id="1328" class="pw-post-body-paragraph ix iy hi iz b ja le ij jc jd lf im jf jg lg ji jj jk lh jm jn jo li jq jr js hb bi translated">React的基本概念就是这样！我希望你喜欢这篇文章，我希望这在某种程度上帮助了你！下一集再见。</p><h1 id="3566" class="km kn hi bd ko kp lq kr ks kt lr kv kw io ls ip ky ir lt is la iu lu iv lc ld bi translated">参考</h1><ul class=""><li id="f85b" class="mv mw hi iz b ja le jd lf jg mx jk my jo mz js na nb nc nd bi translated"><a class="ae ms" href="https://reactjs.org/" rel="noopener ugc nofollow" target="_blank">反应文件</a></li><li id="a233" class="mv mw hi iz b ja ne jd nf jg ng jk nh jo ni js na nb nc nd bi translated"><a class="ae ms" href="https://jscomplete.com/learn/complete-intro-react" rel="noopener ugc nofollow" target="_blank">React完整介绍</a> —强烈推荐！</li><li id="a02e" class="mv mw hi iz b ja ne jd nf jg ng jk nh jo ni js na nb nc nd bi translated"><a class="ae ms" rel="noopener" href="/codex/the-lifecycle-of-a-react-component-8e01332a068d">反应生命周期</a> —我的文章:)</li></ul></div></div>    
</body>
</html>