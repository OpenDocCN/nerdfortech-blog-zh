<html>
<head>
<title>Gardening App: Creating APIs for Database Connections</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">园艺应用程序:为数据库连接创建 API</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/gardening-app-creating-apis-for-database-connections-fcff65603e89?source=collection_archive---------12-----------------------#2021-08-15">https://medium.com/nerd-for-tech/gardening-app-creating-apis-for-database-connections-fcff65603e89?source=collection_archive---------12-----------------------#2021-08-15</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="4611" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">试图让 Buildozer、SQLALchemy 和一个数据库驱动程序在 Android 上工作已经成为一个死胡同。有几个问题，包括 Postgres 的一个基本模块(psycopg2)由于某种原因与 Buildozer 不兼容。相反，我使用 Flask 创建自己的 API，这样我的 Kivy 应用程序只需发送一个 web 请求，而不是直接与数据库交互。我将使用 Heroku Postgres 来托管数据库，目前我正在使用 Postman 测试我的 API。我为以下内容创建了单独的 API:</p><ul class=""><li id="9441" class="jd je hi ih b ii ij im in iq jf iu jg iy jh jc ji jj jk jl bi translated">搜索植物——这要用到两次:显式植物搜索和花园页面。每次用户查看一个特定的花园时，他们将看到该花园中的植物列表。</li><li id="7525" class="jd je hi ih b ii jm im jn iq jo iu jp iy jq jc ji jj jk jl bi translated">为主页生成一个花园列表，用户可以在主页上看到他们所有的花园。</li><li id="e933" class="jd je hi ih b ii jm im jn iq jo iu jp iy jq jc ji jj jk jl bi translated">添加工厂—可在两个位置访问:主页和工厂搜索页面。</li><li id="ba2e" class="jd je hi ih b ii jm im jn iq jo iu jp iy jq jc ji jj jk jl bi translated">添加花园—从主页访问。</li><li id="7f8d" class="jd je hi ih b ii jm im jn iq jo iu jp iy jq jc ji jj jk jl bi translated">更新工厂—在查看单个工厂的完整信息时访问。</li><li id="089b" class="jd je hi ih b ii jm im jn iq jo iu jp iy jq jc ji jj jk jl bi translated">更新花园-从花园页面访问。</li><li id="b15b" class="jd je hi ih b ii jm im jn iq jo iu jp iy jq jc ji jj jk jl bi translated">删除花园-从花园的页面访问。</li><li id="6d14" class="jd je hi ih b ii jm im jn iq jo iu jp iy jq jc ji jj jk jl bi translated">删除工厂-查看单个工厂的完整信息时访问。</li></ul><p id="a69b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">代码如下:</p><pre class="jr js jt ju fd jv jw jx jy aw jz bi"><span id="9666" class="ka kb hi jw b fi kc kd l ke kf">from flask import Flask, request<br/>from sqlalchemy import MetaData, create_engine, Table, Column, String, Integer, and_<br/>from sqlalchemy.sql.expression import Update<br/>import json<br/><br/>app = Flask(__name__)<br/><br/>meta = MetaData()<br/>engine = create_engine("postgresql+psycopg2:// , echo=True)<br/>connection = engine.connect()<br/>my_plants = Table(<br/>    "plants", meta,<br/>    Column("id", Integer, primary_key=True),<br/>    Column("name", String(length=50), ),<br/>    Column("common_name", String(length=50)),<br/>    Column("category", String(length=50)),<br/>    Column("location", String(length=50)),<br/>    Column("year", Integer),<br/>    Column("notes", String(length=500)),<br/>)<br/>my_gardens = Table(<br/>    "gardens", meta,<br/>    Column("id", Integer, primary_key=True),<br/>    Column("name", String(length=50)),<br/>    Column("notes", String(length=250)),<br/>)<br/>meta.create_all(engine)<br/><br/>@app.route("/gardens/create", methods=["POST"])<br/>def create_garden():<br/>    name = request.form['name']<br/>    notes = request.form['notes']<br/>    new_garden = [<br/>        {"name": name,<br/>         "notes": notes}<br/>    ]<br/>    connection.execute(my_gardens.insert(), new_garden)<br/>    return ''  # --- I needed a return statement, even though this API doesn't return anything to the app --- #<br/><br/>@app.route("/plants/create", methods=["POST"])<br/>def create_plant():<br/>    name = request.form["name"]<br/>    common_name = request.form["common_name"]<br/>    category = request.form["category"]<br/>    location = request.form["location"]<br/>    year = request.form["year"]<br/>    notes = request.form["notes"]<br/>    new_plant = [<br/>        {"name": name,<br/>         "common_name": common_name,<br/>         "category": category,<br/>         "location": location,<br/>         "year": year,<br/>         "notes": notes}<br/>    ]<br/>    connection.execute(my_plants.insert(), new_plant)<br/>    return ""<br/><br/>@app.route("/gardens/update/&lt;int:garden_id&gt;", methods=["UPDATE"])<br/>def update_garden(garden_id):<br/>    updated_name = request.form['updated_name']<br/>    updated_notes = request.form['updated_notes']<br/>    updated_garden_info = Update(my_gardens).where(my_gardens.columns.id == garden_id).values(name=updated_name, notes=updated_notes)<br/>    connection.execute(updated_garden_info)<br/>    return ""<br/><br/>@app.route("/plants/update/&lt;int:plant_id&gt;", methods=["UPDATE"])<br/>def update_plant(plant_id):<br/>    updated_name = request.form["updated_name"]<br/>    updated_common_name = request.form["updated_common_name"]<br/>    updated_category = request.form["updated_category"]<br/>    updated_location = request.form["updated_location"]<br/>    updated_year = request.form["updated_year"]<br/>    updated_notes = request.form["updated_notes"]<br/>    updated_plant_info = Update(my_plants).where(my_plants.columns.id == plant_id).values(name=updated_name, common_name=updated_common_name, category=updated_category, location=updated_location, year=updated_year, notes=updated_notes)<br/>    connection.execute(updated_plant_info)<br/>    return ""<br/><br/>@app.route("/plants/delete/&lt;int:plant_id&gt;", methods=["DELETE"])<br/>def delete_plant(plant_id):<br/>    deletion = my_plants.delete().where(my_plants.columns.ids == plant_id)<br/>    connection.execute(deletion)<br/>    return ""<br/><br/>@app.route("/gardens/delete/&lt;int:garden_id&gt;", methods=["DELETE"])<br/>def delete_garden(garden_id):<br/>    deletion = my_gardens.delete().where(my_gardens.columns.ids == garden_id)<br/>    connection.execute(deletion)<br/>    return ""<br/><br/>@app.route("/plants/search", methods=["POST"])<br/>def search_plants():<br/>    name = request.form["name"]<br/>    common_name = request.form["common_name"]<br/>    category = request.form["category"]<br/>    location = request.form["location"]<br/>    year = request.form["year"]<br/>    notes = request.form["notes"]<br/>    filters = []<br/>    if name != "":<br/>        filters.append(my_plants.columns.name.contains(name))<br/>    if common_name != "":<br/>        filters.append(my_plants.columns.common_name.contains(common_name))<br/>    if category != "":<br/>        filters.append(my_plants.columns.category == category)<br/>    if location != "":<br/>        filters.append(my_plants.columns.location == location)<br/>    if year != "":<br/>        filters.append(my_plants.columns.year == year)<br/>    if notes != "":<br/>        filters.append(my_plants.columns.notes.contains(notes))<br/>    search = my_plants.select().where(and_(*filters))<br/>    results = connection.execute(search).fetchall()<br/>    return json.dumps([list(x) for x in results])<br/><br/>@app.route("/gardens", methods=["GET"])<br/>def all_gardens():<br/>    info = my_gardens.select()<br/>    results = connection.execute(info).fetchall()<br/>    return json.dumps([dict(x) for x in results])</span></pre></div></div>    
</body>
</html>