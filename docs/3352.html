<html>
<head>
<title>Common data fetching patterns for real apps with react-query</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">react-query 真实应用程序的通用数据获取模式</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/common-data-fetching-patterns-for-real-apps-with-react-query-4b83188a95c1?source=collection_archive---------1-----------------------#2021-06-07">https://medium.com/nerd-for-tech/common-data-fetching-patterns-for-real-apps-with-react-query-4b83188a95c1?source=collection_archive---------1-----------------------#2021-06-07</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/8d4d6e37257e3147772255d21286aff5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pkxFDeAINYupda0XIYSDfQ.png"/></div></div></figure><p id="e0ac" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><a class="ae jo" href="https://react-query.tanstack.com/" rel="noopener ugc nofollow" target="_blank"> React-query </a>是一个华丽的数据抓取库，获得了当之无愧的赞誉。本文将详细介绍 CRUD 应用程序的模式，以及一些额外的模式。</p><p id="2dd1" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">react-query 的文档非常好，但是我发现自己在学习它的时候希望有更多的实际例子。这些例子将假设<strong class="is hj">对 react-query 有一些熟悉，比如对<code class="du jp jq jr js b">useQuery</code>钩子的熟悉，但不会超出基础。这个示例应用程序将是一个像<strong class="is hj"> Evernote、</strong>一样的笔记工具，我将只概述数据获取案例。</strong></p><p id="c2f3" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">获取数据:</strong></p><ol class=""><li id="20d1" class="jt ju hi is b it iu ix iy jb jv jf jw jj jx jn jy jz ka kb bi translated"><em class="kc">获取数据并处理结果</em> : <code class="du jp jq jr js b">useQueries</code>。</li><li id="91d5" class="jt ju hi is b it kd ix ke jb kf jf kg jj kh jn jy jz ka kb bi translated"><em class="kc">使用查询字符串或查询参数获取数据子集:</em> <code class="du jp jq jr js b">useQuery</code>带参数。</li><li id="a501" class="jt ju hi is b it kd ix ke jb kf jf kg jj kh jn jy jz ka kb bi translated"><em class="kc">有条件取数据:</em> <code class="du jp jq jr js b">useQuery</code>带<code class="du jp jq jr js b">enabled</code>。</li><li id="41cd" class="jt ju hi is b it kd ix ke jb kf jf kg jj kh jn jy jz ka kb bi translated"><em class="kc">查询结束后动作:</em> <code class="du jp jq jr js b">useQuery</code>带<code class="du jp jq jr js b">onSuccess</code>、<code class="du jp jq jr js b">onError</code>或<code class="du jp jq jr js b">onSettled</code>。</li><li id="5afd" class="jt ju hi is b it kd ix ke jb kf jf kg jj kh jn jy jz ka kb bi translated"><em class="kc">分页取数据:</em> <code class="du jp jq jr js b">useInfiniteQuery</code>。</li></ol><blockquote class="ki kj kk"><p id="244e" class="iq ir kc is b it iu iv iw ix iy iz ja kl jc jd je km jg jh ji kn jk jl jm jn hb bi translated">开始前阅读:</p></blockquote><p id="4e4c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我使用库<code class="du jp jq jr js b">axios</code>进行所有 API 调用，这里也会用到，但是<strong class="is hj">不是必须</strong>。Axios 和 react-query 都返回封装在一个名为<code class="du jp jq jr js b">data</code>的信封中的响应，所以这将导致需要钻取像<code class="du jp jq jr js b">data.data</code>这样的对象来获得结果。这是一种丑陋的语法。为了可读性，我把所有的 API 调用写成独立的函数，并在<code class="du jp jq jr js b">useQuery</code>钩子中调用它们。还是那句话，这只是个人对清晰的偏好，没有必要。</p><p id="fa2f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">对于一个更大的应用程序，我会推荐<strong class="is hj">将所有 API 调用存储在自定义钩子</strong>中，在这个例子中概述的模式来自文档<a class="ae jo" href="https://react-query.tanstack.com/examples/custom-hooks" rel="noopener ugc nofollow" target="_blank">这里的</a>和这个媒介<a class="ae jo" href="https://betterprogramming.pub/7-tips-for-using-react-query-in-large-projects-22ccc49d61c2" rel="noopener ugc nofollow" target="_blank">文章</a>。</p><p id="f0f3" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">本文将描述如何使用从经过身份验证的用户获取数据的 API。构建这个 API 的细节超出了本文的范围。</p></div><div class="ab cl ko kp gp kq" role="separator"><span class="kr bw bk ks kt ku"/><span class="kr bw bk ks kt ku"/><span class="kr bw bk ks kt"/></div><div class="hb hc hd he hf"><ol class=""><li id="40b2" class="jt ju hi is b it iu ix iy jb jv jf jw jj jx jn jy jz ka kb bi translated"><strong class="is hj"> <em class="kc">取数据并处理结果</em> : </strong> <code class="du jp jq jr js b">useQueries</code></li></ol><p id="f457" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们想获取我们所有的笔记，以查看一个广泛的概述，但我们也将在不同的文件夹中存储笔记，并只显示特定文件夹中的笔记。对于主屏幕，我们想获取<strong class="is hj">所有文章和所有文件夹。</strong>所有的帖子都将显示在主屏幕上，所有的文件夹都将显示为侧边导航菜单。</p><p id="f133" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们将使用两个查询:一个获取文章，一个获取文件夹。</p><p id="51c1" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这里，<code class="du jp jq jr js b">all</code>是存储查询结果<code class="du jp jq jr js b">fetchFolders</code>和<code class="du jp jq jr js b">fetchPosts</code>的数组。</p><pre class="kv kw kx ky fd kz js la lb aw lc bi"><span id="14ca" class="ld le hi js b fi lf lg l lh li">const fetchFolders = async () =&gt; {</span><span id="1fa5" class="ld le hi js b fi lj lg l lh li">const res = await axios.get('/folders')</span><span id="bf1a" class="ld le hi js b fi lj lg l lh li">return res.data</span><span id="50e7" class="ld le hi js b fi lj lg l lh li">}</span><span id="2364" class="ld le hi js b fi lj lg l lh li">const fetchPosts = async () =&gt; {</span><span id="9c1a" class="ld le hi js b fi lj lg l lh li">const res = await axios.get('/posts')</span><span id="4f54" class="ld le hi js b fi lj lg l lh li">return res.data</span><span id="6c98" class="ld le hi js b fi lj lg l lh li">}</span><span id="5769" class="ld le hi js b fi lj lg l lh li">const all = useQueries([</span><span id="eff8" class="ld le hi js b fi lj lg l lh li">{ queryKey: 'fetchFolders', queryFn: () =&gt; fetchFolders() },</span><span id="9313" class="ld le hi js b fi lj lg l lh li">{ queryKey: 'fetchPosts', queryFn: () =&gt; fetchPosts() },</span><span id="8ade" class="ld le hi js b fi lj lg l lh li">]);</span><span id="276b" class="ld le hi js b fi lj lg l lh li">if(all.some(e =&gt; e.isLoading)) return &lt;Loading/&gt;</span><span id="92ad" class="ld le hi js b fi lj lg l lh li">if(all.some(e =&gt; e.error)) return &lt;Error/&gt;</span><span id="f7d2" class="ld le hi js b fi lj lg l lh li">return (</span><span id="f1d1" class="ld le hi js b fi lj lg l lh li">   &lt;Home data={all}/&gt;</span><span id="789e" class="ld le hi js b fi lj lg l lh li">)</span></pre><p id="5e43" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">对<code class="du jp jq jr js b">useQueries</code>使用<code class="du jp jq jr js b">some</code>方法是我个人的偏好，当你想返回一个组件时，我发现这很有用，除非<em class="kc">所有的</em>查询都从<code class="du jp jq jr js b">useQueries</code>调用中返回。</p><p id="4d6c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><code class="du jp jq jr js b">some</code>是一个普通的 JS 运算符，如果数组中的任何元素满足某个条件，它将返回一个布尔值。<a class="ae jo" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/some" rel="noopener ugc nofollow" target="_blank"> MDN 文档。</a></p><h2 id="ff53" class="ld le hi bd lk ll lm ln lo lp lq lr ls jb lt lu lv jf lw lx ly jj lz ma mb mc bi translated"><strong class="ak"> <em class="md"> 2a。用查询参数取数据子集:</em> </strong> <code class="du jp jq jr js b">useQuery</code></h2><p id="5b4c" class="pw-post-body-paragraph iq ir hi is b it me iv iw ix mf iz ja jb mg jd je jf mh jh ji jj mi jl jm jn hb bi translated">所有的帖子都存储在<code class="du jp jq jr js b">/posts</code>端点，但是有时候我们不想返回每一个帖子。如果用户导航到一个文件夹，我们只想返回存储在该文件夹中的文章。请注意，所有帖子都必须保存在文件夹中，以便按文件夹准确搜索帖子。</p><p id="bd39" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">假设文件夹“Book notes”有一个 slug <code class="du jp jq jr js b">book-notes</code>，当我们点击文件夹名称时会被带到这个文件夹。</p><p id="1267" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这是一个展示带有附加参数的两个不同查询的机会。首先，我们通过 slug <code class="du jp jq jr js b">book-notes</code>查找文件夹，并获得它的 id。</p><p id="8175" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">为了通过 slug 查找文件夹，我们正在识别一个资源，因此我们使用了一个查询参数来构建一个端点，该端点通过 slug 查找文件夹(注意，文件夹 slug 必须是唯一的，这样才能正确工作)。</p><pre class="kv kw kx ky fd kz js la lb aw lc bi"><span id="27be" class="ld le hi js b fi lf lg l lh li">const slug = props.match.params.folder;</span><span id="6b1a" class="ld le hi js b fi lj lg l lh li">const fetchFolder = async (slug) =&gt; { <br/>const res = await axios.get(`/groups/${slug}`)<br/>return res.data<br/>}</span><span id="1551" class="ld le hi js b fi lj lg l lh li">const { data, isLoading, error } = useQuery(<br/>  <strong class="js hj">  ['fetchFolder', slug]</strong>, <br/>    () =&gt; fetchFolder()<br/>);</span></pre><p id="16c1" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">从<a class="ae jo" href="https://react-query.tanstack.com/guides/query-keys" rel="noopener ugc nofollow" target="_blank">反应过来——查询单据</a>:</p><blockquote class="ki kj kk"><p id="9bc9" class="iq ir kc is b it iu iv iw ix iy iz ja kl jc jd je km jg jh ji kn jk jl jm jn hb bi translated">当一个查询需要更多信息来唯一地描述它的数据时，您可以使用一个带有字符串和任意数量的可序列化对象的数组来描述它。这有助于:</p><p id="9371" class="iq ir kc is b it iu iv iw ix iy iz ja kl jc jd je km jg jh ji kn jk jl jm jn hb bi translated">-分层或嵌套资源—通常传递 ID、索引或其他原语来唯一标识项目</p><p id="cc55" class="iq ir kc is b it iu iv iw ix iy iz ja kl jc jd je km jg jh ji kn jk jl jm jn hb bi translated">-带有附加参数的查询-传递附加选项的对象是很常见的</p></blockquote><p id="7786" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">所谓“更多信息来唯一地描述其数据”，是指指定特定资源或条件以从数据集合返回文档的查询参数或字符串。因此，这个查询的查询关键字是<code class="du jp jq jr js b">[fetchFolder, slug]</code>，其中<code class="du jp jq jr js b">slug</code>是一个变量，对应于 URL 参数中的 slug 值。因此，如果我们的完整 URL 是<code class="du jp jq jr js b"><a class="ae jo" href="http://www.notesapp.com/book-notes," rel="noopener ugc nofollow" target="_blank">www.notesapp.com/book-notes</a></code> <a class="ae jo" href="http://www.notesapp.com/book-notes," rel="noopener ugc nofollow" target="_blank">，</a>查询关键字是<code class="du jp jq jr js b">[fetchFolder, book-notes]</code>。这单独为这个房间创建了一个唯一的查询。如果不同的查询使用相同的键，查询行为可能是不可预测的。</p><p id="39cd" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">通过在<code class="du jp jq jr js b">data</code>对象中返回文件夹，我们可以从<code class="du jp jq jr js b">data._id</code>属性中获得文件夹 id。然后，我们查找文件夹值为该 id 的所有帖子。</p><h2 id="b88f" class="ld le hi bd lk ll lm ln lo lp lq lr ls jb lt lu lv jf lw lx ly jj lz ma mb mc bi translated">2b。获取带有查询字符串的数据子集:<code class="du jp jq jr js b">useQuery</code>。</h2><p id="f6c7" class="pw-post-body-paragraph iq ir hi is b it me iv iw ix mf iz ja jb mg jd je jf mh jh ji jj mi jl jm jn hb bi translated">这是展示带有查询字符串的<code class="du jp jq jr js b">useQuery</code>的好机会。它非常类似于查询参数。</p><pre class="kv kw kx ky fd kz js la lb aw lc bi"><span id="a65a" class="ld le hi js b fi lf lg l lh li">const fetchFolderPosts = async (id) =&gt; { <br/>const res = await axios.get(`/posts?folder=${id}`)<br/>return res.data<br/>}</span><span id="bc66" class="ld le hi js b fi lj lg l lh li">const { data, isLoading, error } = useQuery(<br/>  <strong class="js hj"> ['fetchFolderPosts', {folder: id}]</strong>, <br/>   () =&gt; fetchFolderPosts()<br/>});</span></pre><p id="be56" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">正如我们在文档中读到的，在查询键数组中以字符串的形式传递唯一标识符，以及传递附加选项的对象是很常见的。通常，查询参数，如唯一 id 和 slugs，将作为字符串在查询键中传递，而查询字符串的一部分，如过滤选项，将作为键传递给对象。如果我们有很多选择，它们会像，<code class="du jp jq jr js b">{folder: id, sort: date, tag: category }</code>等一样被通过。</p><p id="f740" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">请注意，只要查询有唯一的键，将值作为对象而不是字符串传递应该不会影响功能。这只是一个惯例。</p><h2 id="e9f0" class="ld le hi bd lk ll lm ln lo lp lq lr ls jb lt lu lv jf lw lx ly jj lz ma mb mc bi translated">3.有条件地获取数据:</h2><p id="5993" class="pw-post-body-paragraph iq ir hi is b it me iv iw ix mf iz ja jb mg jd je jf mh jh ji jj mi jl jm jn hb bi translated"><code class="du jp jq jr js b">useQuery</code>同<code class="du jp jq jr js b">enabled</code>。</p><p id="5ef8" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这个查询实际上依赖于前一个查询，在它可以执行之前完成。如果没有传递文件夹 id，它就不应该运行。因此，这个查询应该是空闲的，除非获取文件夹的前一个查询成功返回了一个 id。这是使用作为 useQuery 钩子一部分的<code class="du jp jq jr js b">enabled</code>布尔值来完成的。</p><pre class="kv kw kx ky fd kz js la lb aw lc bi"><span id="7d5d" class="ld le hi js b fi lf lg l lh li">const fetchFolderPosts = async (id) =&gt; { <br/>const res = await axios.get(`/posts?folder=${id}`)<br/>return res.data<br/>}</span><span id="db6a" class="ld le hi js b fi lj lg l lh li">const { data, isLoading, <strong class="js hj">isIdle</strong>, error } = useQuery(<br/>  <strong class="js hj"> ['fetchFolderPosts', {folder: id}]</strong>, <br/>   () =&gt; fetchFolderPosts(), <br/>  {<br/>   enabled: !!id<br/>  }<br/>});</span></pre><blockquote class="ki kj kk"><p id="059a" class="iq ir kc is b it iu iv iw ix iy iz ja kl jc jd je km jg jh ji kn jk jl jm jn hb bi translated">注意:使用<code class="du jp jq jr js b">!!</code>将非布尔值转换为布尔值。更多<a class="ae jo" href="https://www.samanthaming.com/tidbits/19-2-ways-to-convert-to-boolean/" rel="noopener ugc nofollow" target="_blank">见此</a>。</p></blockquote><p id="2c50" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这个查询现在将处于空闲状态，除非我们传递给它的<code class="du jp jq jr js b">id</code>值存在，也就是说它不是<code class="du jp jq jr js b">null</code>、<code class="du jp jq jr js b">undefined</code>、“”等等。</p><p id="3019" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">因为我们向这个查询引入了一个新的可能状态，即<strong class="is hj">空闲</strong>状态，所以我们需要将它与<code class="du jp jq jr js b">isLoading</code>和<code class="du jp jq jr js b">isError</code>状态一起处理。空闲状态是指查询尚未开始提取。</p><pre class="kv kw kx ky fd kz js la lb aw lc bi"><span id="5598" class="ld le hi js b fi lf lg l lh li">const fetchFolderPosts = async (id) =&gt; { <br/>const res = await axios.get(`/posts?folder=${id}`)<br/>return res.data<br/>}</span><span id="8fdf" class="ld le hi js b fi lj lg l lh li">const { data, isLoading, isIdle, error } = useQuery(<br/>   ['fetchFolderPosts', {folder: id}], <br/>   () =&gt; fetchFolderPosts(), <br/>  {<br/>   enabled: !!id<br/>  }<br/>});</span><span id="b945" class="ld le hi js b fi lj lg l lh li">if<strong class="js hj">(isLoading || isIdle)</strong> return &lt;Loading/&gt;</span><span id="d007" class="ld le hi js b fi lj lg l lh li">if(error) return &lt;Error/&gt; </span></pre><p id="1281" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如果这里没有处理<code class="du jp jq jr js b">isIdle</code>状态，这个函数将会在获取数据和出错之前尝试渲染组件。</p><h2 id="c87a" class="ld le hi bd lk ll lm ln lo lp lq lr ls jb lt lu lv jf lw lx ly jj lz ma mb mc bi translated"><em class="md"> 4。查询结束后动作:</em> <code class="du jp jq jr js b">useQuery</code>带<code class="du jp jq jr js b">onSuccess</code>、<code class="du jp jq jr js b">onError</code>或<code class="du jp jq jr js b">onSettled</code></h2><p id="3bd6" class="pw-post-body-paragraph iq ir hi is b it me iv iw ix mf iz ja jb mg jd je jf mh jh ji jj mi jl jm jn hb bi translated">react-query 提供了<code class="du jp jq jr js b">onSuccess</code>、<code class="du jp jq jr js b">onError</code>和<code class="du jp jq jr js b">onSettled</code>函数，在查询完成后执行。这些函数中的每一个都有不同的内置参数:</p><p id="bae1" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><code class="du jp jq jr js b">onSuccess (data, payload)</code></p><p id="e674" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><code class="du jp jq jr js b">onError(error, payload)</code></p><p id="1a98" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><code class="du jp jq jr js b">onSettled(data, error, payload)</code></p><p id="18ee" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">您可以访问<code class="du jp jq jr js b">payload</code>，或者传入查询函数的数据，作为每个函数的最终参数。我在 react-query 文档中找不到这个，但是它可以工作，它的 PR 在 GH <a class="ae jo" href="https://github.com/tannerlinsley/react-query/issues/268" rel="noopener ugc nofollow" target="_blank">这里</a>。</p><p id="399a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们将使用<code class="du jp jq jr js b">onSuccess</code>从我们的搜索中获取返回到全局状态的文件夹，这样我们就可以用它来做其他事情，比如创建一个“最近访问过的”文件夹列表，用户可以使用它作为快捷方式。</p><p id="7f82" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在父组件中，存储最近访问的文件夹名称的状态列表。使用道具或状态库将<code class="du jp jq jr js b">setRecents</code>方法传给孩子们。</p><pre class="kv kw kx ky fd kz js la lb aw lc bi"><span id="1523" class="ld le hi js b fi lf lg l lh li">const [recents, setRecents] = useState([]);</span><span id="fd37" class="ld le hi js b fi lj lg l lh li">return (<br/>/// return children <br/>)</span></pre><p id="1e44" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在原始文件夹组件中:</p><pre class="kv kw kx ky fd kz js la lb aw lc bi"><span id="e7eb" class="ld le hi js b fi lf lg l lh li">const fetchFolderPosts = async (id) =&gt; { <br/>const res = await axios.get(`/posts?folder=${id}`)<br/>return res.data<br/>}</span><span id="cc05" class="ld le hi js b fi lj lg l lh li">const { data, isLoading, error } = useQuery(<br/>  <strong class="js hj"> ['fetchFolderPosts', {folder: id}]</strong>, <br/>   () =&gt; fetchFolderPosts(), {<br/>       <strong class="js hj"> onSuccess: </strong>(res) =&gt; {<br/>             const newList = recents.concat(res.data);<br/>             setRecents(newList); }<br/>}<br/>});</span></pre><h2 id="0086" class="ld le hi bd lk ll lm ln lo lp lq lr ls jb lt lu lv jf lw lx ly jj lz ma mb mc bi translated"><em class="md"> 5。分页提取数据:</em> <code class="du jp jq jr js b">useInfiniteQuery</code></h2><p id="f8db" class="pw-post-body-paragraph iq ir hi is b it me iv iw ix mf iz ja jb mg jd je jf mh jh ji jj mi jl jm jn hb bi translated">对数据进行分页是一种巨大的痛苦，这是生活中的事实。react-query 的<code class="du jp jq jr js b">useInfiniteQuery</code>钩子使事情变得简单多了，但是我发现分页确实有点麻烦。</p><p id="c3ee" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我用 mongose 的<a class="ae jo" href="https://www.npmjs.com/package/mongoose-paginate-v2" rel="noopener ugc nofollow" target="_blank">mongose 分页库</a>来帮助后端分页。</p><p id="0186" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">让我们重构查询，按文件夹获取文章，以包含分页。假设我们只希望 20 篇文章出现在一个文件夹的单个视图中。</p><pre class="kv kw kx ky fd kz js la lb aw lc bi"><span id="f700" class="ld le hi js b fi lf lg l lh li">const fetchPosts = async (pg, id, limit) =&gt; {<br/>   const offset = (pg - 1) * limit;<br/>   const res = await axios.get<br/>       (`/posts?folder=${id}&amp;offset=${offset}&amp;limit=${limit}`)<br/>    return res.data<br/>}</span><span id="2826" class="ld le hi js b fi lj lg l lh li">const {<br/>fetchNextPage,<br/>hasNextPage,<br/>isLoading,<br/>isError,<br/>data }  = useInfiniteQuery(<br/>   ['fetchPosts', { folder: id }],<br/>   ({ pageParam = 1}) =&gt; fetchPosts(pageParam, id, 20),<br/>   {<br/>    getNextPageParam: (lastGroup, allGroups) =&gt; { <br/>return lastGroup?.nextPage || null; }<br/>}<br/>);</span></pre><p id="823f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">先说<code class="du jp jq jr js b">fetchPosts</code>函数。这是获取分页数据的标准调用，这些分页数据在的查询字符串中包含变量:1。文件夹<code class="du jp jq jr js b">id</code>(同上)，2。<code class="du jp jq jr js b">limit</code>(要获取的帖子数量)，以及 3。<code class="du jp jq jr js b">offset</code>(抓取前忽略的帖子数量)。</p><p id="b4a4" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><a class="ae jo" href="https://react-query.tanstack.com/reference/useInfiniteQuery#_top" rel="noopener ugc nofollow" target="_blank">关于<code class="du jp jq jr js b">useInfiniteQuery</code>钩子的文档</a>对此有详细的解释，也有专门的<a class="ae jo" href="https://react-query.tanstack.com/guides/infinite-queries" rel="noopener ugc nofollow" target="_blank">分页指南</a>。</p><p id="cfce" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">挂钩有<code class="du jp jq jr js b">getNextPageParam</code>和<code class="du jp jq jr js b">getPreviousPageParam</code>功能，用于向前翻页+1 和向后翻页-1。我这里只使用<code class="du jp jq jr js b">getNextPageParam</code>函数。</p><p id="1ff2" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><code class="du jp jq jr js b">data</code>从钩子返回的现在包含分页数据。默认情况下，数据<em class="kc">会逐步累积。</em></p><p id="6a05" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如果我们 console.log 从 useInfiniteQuery 钩子返回的<code class="du jp jq jr js b">data</code>,我们会看到一个具有两个属性的对象:</p><pre class="kv kw kx ky fd kz js la lb aw lc bi"><span id="25e7" class="ld le hi js b fi lf lg l lh li">{<br/>  pageParams<br/>  pages<br/>}</span></pre><p id="e880" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><code class="du jp jq jr js b">data.pages</code>包含提取的页面+关联的元数据</p><ul class=""><li id="7a76" class="jt ju hi is b it iu ix iy jb jv jf jw jj jx jn mj jz ka kb bi translated">Pages 是从 fetchPages API 调用返回的每个数据的数组</li><li id="2075" class="jt ju hi is b it kd ix ke jb kf jf kg jj kh jn mj jz ka kb bi translated">为了显示文章，我们需要遍历数组并获取嵌套属性<code class="du jp jq jr js b">docs</code>，它实际上包含了文章(示例如下)。</li></ul><p id="39c2" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><code class="du jp jq jr js b">data.pageParams</code>是用于获取页面的页面参数</p><ul class=""><li id="ed31" class="jt ju hi is b it iu ix iy jb jv jf jw jj jx jn mj jz ka kb bi translated">其值仅随来自<code class="du jp jq jr js b">getNextPageParam</code>的计算返回。<a class="ae jo" href="https://www.notion.so/react-query-d6f772c31bd64cd8939aababa950b25f#d51a222702a044729080445da910d49d" rel="noopener ugc nofollow" target="_blank">react-query GH 上关于此</a>的讨论。</li><li id="a291" class="jt ju hi is b it kd ix ke jb kf jf kg jj kh jn mj jz ka kb bi translated"><code class="du jp jq jr js b">pageParams</code>跟踪当前页面。它是 render 上的<code class="du jp jq jr js b">undefined</code>，所以默认设置当前页面为 1 是个好主意，正如我们通过传递参数<code class="du jp jq jr js b">({ pageParam = 1 })</code>调用函数时所做的那样。</li></ul><p id="33f5" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">实际的对象返回如下所示(对于第 1 页):</p><pre class="kv kw kx ky fd kz js la lb aw lc bi"><span id="b1c9" class="ld le hi js b fi lf lg l lh li">pageParams: [undefined] <br/>pages:[{ <br/>  docs: (20) [{...} {...} {...}]    <br/>  hasNextPage: true    <br/>  hasPrevPage: false    <br/>  limit: 20   <br/>  nextPage: 2    <br/>  offset: 0    <br/>  page: 1    <br/>  pagingCounter: 1    <br/>  prevPage: null    <br/>  totalDocs: 26    <br/>  totalPages: 2 <br/>}<br/>]</span></pre><p id="01f9" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">对于第 2 页:</p><pre class="kv kw kx ky fd kz js la lb aw lc bi"><span id="625d" class="ld le hi js b fi lf lg l lh li">pageParams: [undefined, 2] <br/>pages:[{ <br/>  docs: (20) [{...} {...} {...}]    <br/>  hasNextPage: true    <br/>  hasPrevPage: false    <br/>  limit: 20   <br/>  nextPage: 2    <br/>  offset: 0    <br/>  page: 1    <br/>  pagingCounter: 1    <br/>  prevPage: null    <br/>  totalDocs: 26    <br/>  totalPages: 2 <br/>},<br/>{ <br/>  docs: (6) [{...} {...} {...}]    <br/>  hasNextPage: false    <br/>  hasPrevPage: false    <br/>  limit: 20   <br/>  nextPage: 2    <br/>  offset: 0    <br/>  page: 2   <br/>  pagingCounter: 2   <br/>  prevPage: 1    <br/>  totalDocs: 26    <br/>  totalPages: 2 <br/>}<br/>]</span></pre><p id="dbaa" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">显示分页数据的完整组件可能如下所示:</p><pre class="kv kw kx ky fd kz js la lb aw lc bi"><span id="fc22" class="ld le hi js b fi lf lg l lh li">const fetchPosts = async (pg, id, limit) =&gt; {<br/>   const offset = (pg - 1) * limit;<br/>   const res = await axios.get<br/>       (`/posts?folder=${id}&amp;offset=${offset}&amp;limit=${limit}`)<br/>    return res.data<br/>}</span><span id="4d80" class="ld le hi js b fi lj lg l lh li">const {<br/>fetchNextPage,<br/>hasNextPage,<br/>isLoading,<br/>isError,<br/>data }  = useInfiniteQuery(<br/>   ['fetchPosts', { folder: id }],<br/>   ({ pageParam = 1}) =&gt; fetchPosts(pageParam, id, 20),<br/>   {<br/>    getNextPageParam: (lastGroup, allGroups) =&gt; { <br/>return lastGroup?.nextPage || null; }<br/>}<br/>);</span><span id="7ea1" class="ld le hi js b fi lj lg l lh li">if(isLoading) return &lt;Loading/&gt;</span><span id="297c" class="ld le hi js b fi lj lg l lh li">if(error) return &lt;Error/&gt;</span><span id="045f" class="ld le hi js b fi lj lg l lh li">return (<br/>&lt;div&gt;</span><span id="f77e" class="ld le hi js b fi lj lg l lh li">{data.pages.map((el, i) =&gt; {</span><span id="04ae" class="ld le hi js b fi lj lg l lh li">  return el?.docs.map((post, i) =&gt; {</span><span id="7993" class="ld le hi js b fi lj lg l lh li">     return (&lt;Post key={post._id} post={post}/&gt;)</span><span id="1711" class="ld le hi js b fi lj lg l lh li">})</span><span id="e3b9" class="ld le hi js b fi lj lg l lh li">})}</span><span id="c4a9" class="ld le hi js b fi lj lg l lh li">{hasNextPage &amp;&amp;</span><span id="abd6" class="ld le hi js b fi lj lg l lh li">   &lt;InlineButton label="more" handleClick={fetchNextPage}/&gt; }</span><span id="fe8c" class="ld le hi js b fi lj lg l lh li">&lt;/div&gt;<br/>)</span></pre><p id="019d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这就是本教程使用 react-query 获取数据的全部五个部分。我喜欢这个图书馆。如果有兴趣，我可以为这个图坦卡门创建一个回购和/或为突变数据做另一个指南。本指南没有深入 react-query 的所有更高级的用例(我也还在学习)，但是我希望它比早期初学者的信息更进一步。</p><p id="a529" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">参考文献:</strong></p><p id="e3bd" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><a class="ae jo" href="https://react-query.tanstack.com/" rel="noopener ugc nofollow" target="_blank">反应-查询单据</a></p><p id="21d3" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">bits | <a class="ae jo" href="https://www.notion.so/react-query-d6f772c31bd64cd8939aababa950b25f#54a29bd61f7e42a786b6cb84a16a2aad" rel="noopener ugc nofollow" target="_blank">开始使用 react-query </a></p><p id="0708" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">dev.to | <a class="ae jo" href="https://dev.to/otamnitram/react-query-a-practical-example-167j" rel="noopener ugc nofollow" target="_blank"> react-query:实际例子</a></p><p id="3b51" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">YouTube | <a class="ae jo" href="https://www.youtube.com/watch?v=4jMAnIIEI3M" rel="noopener ugc nofollow" target="_blank"> useInfiniteQuery 教程</a></p><p id="bbb6" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">YouTube | <a class="ae jo" href="https://www.notion.so/react-query-d6f772c31bd64cd8939aababa950b25f#d1282981e66d4f389fb15f98a65fedb7" rel="noopener ugc nofollow" target="_blank"> Tanner 对 react-query 的介绍</a></p><p id="9eef" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">YouTube |<a class="ae jo" href="https://www.youtube.com/watch?v=4UCwA2n4gsA&amp;list=PLIvCYh5AD3HxH9574Xco1sr_o8TO5VWIJ" rel="noopener ugc nofollow" target="_blank">react-查询 CRUD (1 小时)</a></p></div></div>    
</body>
</html>