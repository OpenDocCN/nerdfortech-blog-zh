<html>
<head>
<title>Webpack + React Optimised Fix ChunkLoadError</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Webpack + React优化修复ChunkLoadError</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/webpack-react-fix-optimised-chunkloaderror-2e411f298b4?source=collection_archive---------12-----------------------#2021-03-09">https://medium.com/nerd-for-tech/webpack-react-fix-optimised-chunkloaderror-2e411f298b4?source=collection_archive---------12-----------------------#2021-03-09</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/63fb5b2b352e2055d2548642c1b13ddc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*NMNqoarQG8it1Nkj"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">马库斯·温克勒在<a class="ae iu" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><p id="f3e2" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如果您使用react进行延迟加载，很可能会遇到块加载问题，这通常是由网络中断引起的，会中断用户体验。</p><blockquote class="jt ju jv"><p id="199c" class="iv iw jw ix b iy iz ja jb jc jd je jf jx jh ji jj jy jl jm jn jz jp jq jr js hb bi translated">查看本系列的前一篇文章。<br/> <a class="ae iu" href="https://premeena.medium.com/webpack-react-optimised-from-scratch-da8f75024ba4?source=your_stories_page-------------------------------------" rel="noopener"> Webpack + React从头优化</a> <br/> <a class="ae iu" href="https://premeena.medium.com/webpack-react-optimised-differential-serving-b53d4cf2a3da?source=your_stories_page-------------------------------------" rel="noopener"> Webpack + React优化差分服务</a></p></blockquote><figure class="kb kc kd ke fd ij er es paragraph-image"><div class="er es ka"><img src="../Images/2d57ea63e925ce31c34a554694def9fc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1394/format:webp/0*RdaxsaLD_nnDwBKc.png"/></div></figure><p id="7b65" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这个问题不容易重现，但会间歇性地出现。</p><p id="9eed" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们能解决这个问题吗？</p><p id="ead0" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">是的，我们可以解决这个问题。</p><p id="afc3" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">为了解决这个问题，我们将尝试重新下载模块，如果我们在一段时间内再次遇到相同的问题，我们将重复这个过程一段时间。</p><p id="36ea" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">让我们一步一步地解决这个问题:</p><ol class=""><li id="1d9c" class="kf kg hi ix b iy iz jc jd jg kh jk ki jo kj js kk kl km kn bi translated"><strong class="ix hj">我们将用react-lazy导入我们的组件。</strong></li></ol><pre class="kb kc kd ke fd ko kp kq kr aw ks bi"><span id="a1a7" class="kt ku hi kp b fi kv kw l kx ky">const Component = React.lazy(()=&gt; import('./to/component'));</span></pre><p id="26be" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">你已经这么做了，也遇到了同样的问题。为了解决这个问题，我们需要在这里做些改变。让我们继续前进。</p><p id="73a6" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj"> 2。创建一个函数来重新下载我们失败的模块</strong></p><pre class="kb kc kd ke fd ko kp kq kr aw ks bi"><span id="5515" class="kt ku hi kp b fi kv kw l kx ky">const retry = (fn, <em class="jw">retriesLeft = 5, interval=1000</em>) =&gt; {...}</span></pre><p id="ea18" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在上面，我们写了一个函数，将重试下载失败的模块。</p><p id="92d5" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在上面的函数中，你可以看到三个参数</p><p id="a59f" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj"> fn: </strong>这是我们的导入回调函数<strong class="ix hj"> ()= &gt; import('。/to/component’)</strong>同1中所述。点。</p><p id="ae1d" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj"> retriesLeft: </strong>它告诉我们可以尝试重新下载模块的调用次数。</p><p id="8982" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj"> interval: </strong>过了多少时间我们要重新触发我们的调用重新下载包。</p><p id="8f07" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj"> 3。现在我们将看到内部工作。</strong></p><pre class="kb kc kd ke fd ko kp kq kr aw ks bi"><span id="865b" class="kt ku hi kp b fi kv kw l kx ky">const retry = (fn, <em class="jw">retriesLeft = 5, interval=1000</em>) =&gt; {<br/>return new Promise((<em class="jw">resolve</em>, <em class="jw">reject</em>) =&gt; {</span><span id="a384" class="kt ku hi kp b fi kz kw l kx ky">fn()</span><span id="ae41" class="kt ku hi kp b fi kz kw l kx ky">  .then(resolve)</span><span id="6f9c" class="kt ku hi kp b fi kz kw l kx ky">  .catch((<em class="jw">error</em>) =&gt; {</span><span id="6cd6" class="kt ku hi kp b fi kz kw l kx ky">      setTimeout(() =&gt; {</span><span id="3f42" class="kt ku hi kp b fi kz kw l kx ky">          if (<em class="jw">retriesLeft</em> === 1) {</span><span id="fa46" class="kt ku hi kp b fi kz kw l kx ky"><em class="jw">              // reject('maximum retries exceeded');</em></span><span id="1be1" class="kt ku hi kp b fi kz kw l kx ky">              reject(<em class="jw">error</em>);</span><span id="e5ea" class="kt ku hi kp b fi kz kw l kx ky">              return;</span><span id="0a67" class="kt ku hi kp b fi kz kw l kx ky">           }</span><span id="20b2" class="kt ku hi kp b fi kz kw l kx ky"><em class="jw">           // Passing on "reject" is the important part</em></span><span id="9a60" class="kt ku hi kp b fi kz kw l kx ky">           retry(<em class="jw">fn</em>, <em class="jw">retriesLeft</em> - 1, <em class="jw">interval</em>)<br/>           .then(resolve, reject);</span><span id="8752" class="kt ku hi kp b fi kz kw l kx ky">        }, <em class="jw">interval</em>);</span><span id="1388" class="kt ku hi kp b fi kz kw l kx ky">     });</span><span id="2b1c" class="kt ku hi kp b fi kz kw l kx ky">   });<br/>}</span></pre><figure class="kb kc kd ke fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es la"><img src="../Images/ec26a0d4650f4185aad2d9e6469a045c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*aCk849ylQGLyXrhpx-AYwQ.png"/></div></div></figure><p id="aa8b" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj"> 4。让我们创建最后一个lazyLoad函数</strong></p><pre class="kb kc kd ke fd ko kp kq kr aw ks bi"><span id="f7e4" class="kt ku hi kp b fi kv kw l kx ky">const lazyLoad = (<em class="jw">fn</em>) =&gt; React.lazy(() =&gt; retry(<em class="jw">fn, 4, 1500</em>));</span><span id="b5a1" class="kt ku hi kp b fi kz kw l kx ky">// or default</span><span id="8f4b" class="kt ku hi kp b fi kz kw l kx ky">const lazyLoad = (<em class="jw">fn</em>) =&gt; React.lazy(() =&gt; retry(<em class="jw">fn</em>));</span><span id="99d5" class="kt ku hi kp b fi kz kw l kx ky">export default lazyLoad;</span></pre><p id="b344" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们将导出这个lazyLoad，我们可以用它来代替React.lazy，我们曾经在组件中导入过它。</p><p id="2e28" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj"> 5。现在我们将在我们的项目</strong>中使用这个函数</p><pre class="kb kc kd ke fd ko kp kq kr aw ks bi"><span id="4803" class="kt ku hi kp b fi kv kw l kx ky">const Component = lazyLoad(()=&gt; import('./to/component'));</span></pre></div><div class="ab cl lb lc gp ld" role="separator"><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg"/></div><div class="hb hc hd he hf"><p id="c5bc" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">结论</strong></p><p id="a3a8" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们已经创建了一个函数，它将在给定的时间间隔内，按照我们想要的重试次数，尝试重新下载失败的模块。通过这种方式，我们可以提供更好的用户体验，而不用担心网络中断，并利用分块优势。</p><p id="c889" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">谢谢，快乐阅读❤️</p></div></div>    
</body>
</html>