<html>
<head>
<title>LeetCode — Implement strStr()</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">LeetCode —实现 strStr()</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/leetcode-implement-strstr-9b0499ecfd88?source=collection_archive---------10-----------------------#2021-07-18">https://medium.com/nerd-for-tech/leetcode-implement-strstr-9b0499ecfd88?source=collection_archive---------10-----------------------#2021-07-18</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><h1 id="42cc" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">问题陈述</h1><p id="d93d" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">实现<strong class="jf hj"> strStr() </strong>。</p><p id="6911" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">返回针在草堆中第一次出现的索引，如果<strong class="jf hj">针</strong>不是<strong class="jf hj">草堆</strong>的一部分，则返回<strong class="jf hj"> -1 </strong>。</p><p id="c5b9" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated"><strong class="jf hj">澄清:</strong></p><p id="c1c4" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">当<strong class="jf hj">针</strong>为空串时我们应该返回什么？这是在面试中问的一个很好的问题。</p><p id="0a80" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">针对这个问题，当<strong class="jf hj">针</strong>为空字符串时，我们将返回 0。这与 C 的<strong class="jf hj"> strstr() </strong>和 Java 的<strong class="jf hj"> indexOf() </strong>是一致的。</p><p id="b2a4" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">问题陈述摘自:<a class="ae kg" href="https://leetcode.com/problems/implement-strstr" rel="noopener ugc nofollow" target="_blank">https://leetcode.com/problems/implement-strstr</a></p><p id="3ca5" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">例 1: </p><pre class="kh ki kj kk fd kl km kn ko aw kp bi"><span id="ac0d" class="kq ig hi km b fi kr ks l kt ku">Input: haystack = "hello", needle = "ll"<br/>Output: 2</span></pre><p id="75f4" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated"><strong class="jf hj">例 2: </strong></p><pre class="kh ki kj kk fd kl km kn ko aw kp bi"><span id="f498" class="kq ig hi km b fi kr ks l kt ku">Input: haystack = "aaaaa", needle = "bba"<br/>Output: -1</span></pre><p id="8ee7" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated"><strong class="jf hj">例 3: </strong></p><pre class="kh ki kj kk fd kl km kn ko aw kp bi"><span id="a4ab" class="kq ig hi km b fi kr ks l kt ku">Input: haystack = "", needle = ""<br/>Output: 0</span></pre><p id="0965" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated"><strong class="jf hj">约束:</strong></p><pre class="kh ki kj kk fd kl km kn ko aw kp bi"><span id="0b95" class="kq ig hi km b fi kr ks l kt ku">- 0 &lt;= haystack.length, needle.length &lt;= 5 * 10^4 <br/>- haystack and needle consist of only lower-case English characters.</span></pre><h1 id="a41d" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">说明</h1><h2 id="3176" class="kq ig hi bd ih kv kw kx il ky kz la ip jo lb lc it js ld le ix jw lf lg jb lh bi translated">迭代实现(暴力)</h2><p id="8b09" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">迭代方法是使用两个嵌套的 for 循环。外部循环将迭代<strong class="jf hj">干草堆</strong>，对于每个索引，我们将<strong class="jf hj">干草堆</strong>串与<strong class="jf hj">针</strong>串匹配。如果我们到达<strong class="jf hj">针</strong>串的末端，我们返回开始索引，否则我们返回-1。</p><p id="be81" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">上述逻辑的一个 C++片段如下。</p><pre class="kh ki kj kk fd kl km kn ko aw kp bi"><span id="fad8" class="kq ig hi km b fi kr ks l kt ku">for (int i = 0; i &lt;= haystack.length() - needle.length(); i++){<br/>    int j;<br/><br/>    for (j = 0; j &lt; needle.length(); j++) {<br/>        if (needle.charAt(j) != haystack.charAt(i + j)) {<br/>            break;<br/>        }<br/>    }<br/><br/>    if (j == needle.length()) {<br/>        return i;<br/>    }<br/>}</span></pre><p id="f72e" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">上述程序的时间复杂度为<strong class="jf hj"> O(m*n) </strong>。</p><h2 id="3e4e" class="kq ig hi bd ih kv kw kx il ky kz la ip jo lb lc it js ld le ix jw lf lg jb lh bi translated">递归实现</h2><p id="1985" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">我们可以使用如下递归方法来解决这个问题:</p><pre class="kh ki kj kk fd kl km kn ko aw kp bi"><span id="93a4" class="kq ig hi km b fi kr ks l kt ku">int strStr(string haystack, string needle) {<br/>    // ...basic condition check code<br/><br/>    for (int i = 0; i &lt; haystack.length(); i++){<br/>        if (haystack.charAt(i) == needle.charAt(0))<br/>        {<br/>            String s = strStr(haystack.substring(i + 1), needle.substring(1));<br/>            return (s != null) ? haystack.charAt(i) + s : null;<br/>        }<br/>    }<br/><br/>    return null;<br/>}</span></pre><p id="0d87" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">对于非常大的字符串，递归方法是不合适的。</p><h2 id="caed" class="kq ig hi bd ih kv kw kx il ky kz la ip jo lb lc it js ld le ix jw lf lg jb lh bi translated">使用 KMP 算法</h2><p id="9ee8" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">我们可以用 KMP 算法在<strong class="jf hj"> O(m + n) </strong>时间内解决这个问题。</p><p id="8038" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">让我们检查下面的算法:</p><pre class="kh ki kj kk fd kl km kn ko aw kp bi"><span id="64f9" class="kq ig hi km b fi kr ks l kt ku">- return 0 if needle.size == 0<br/><br/>- return -1 if haystack.size &lt; needle.size<br/><br/>- set i = 0, j = 0<br/>- initialize index<br/><br/>- loop while i &lt; haystack.size<br/>  - if haystack[i] == needle[j]<br/>    - index = i<br/><br/>    - loop while haystack[i] == needle[j] &amp;&amp; j &lt; needle.size()<br/>      - i++<br/>      - j++<br/><br/>    - if j == needle.size<br/>      - return index<br/>    - else<br/>      - j = 0<br/>      - i = index + 1<br/>  - else<br/>    - i++<br/><br/>- return -1</span></pre><p id="e220" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated"><strong class="jf hj"> C++解决方案</strong></p><pre class="kh ki kj kk fd kl km kn ko aw kp bi"><span id="a79b" class="kq ig hi km b fi kr ks l kt ku">class Solution {<br/>public:<br/>    int strStr(string haystack, string needle) {<br/>        if(needle.size() == 0){<br/>            return 0;<br/>        }<br/><br/>        if(haystack.size() &lt; needle.size()){<br/>            return -1;<br/>        }<br/><br/>        int i = 0, j = 0;<br/>        int index;<br/>        while(i &lt; haystack.size()){<br/>            if(haystack[i] == needle[j]){<br/>                index = i;<br/>                while(haystack[i] == needle[j] &amp;&amp; j &lt; needle.size()){<br/>                    i++;<br/>                    j++;<br/>                }<br/>                if(j == needle.size()){<br/>                    return index;<br/>                } else {<br/>                    j = 0;<br/>                    i = index + 1;<br/>                }<br/>            } else {<br/>                i++;<br/>            }<br/>        }<br/><br/>        return -1;<br/>    }<br/>};</span></pre><p id="df91" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated"><strong class="jf hj">戈朗解</strong></p><pre class="kh ki kj kk fd kl km kn ko aw kp bi"><span id="5fa0" class="kq ig hi km b fi kr ks l kt ku">func strStr(haystack string, needle string) int {<br/>    needleLen := len(needle)<br/>    haystackLen := len(haystack)<br/><br/>    if needleLen == 0 {<br/>        return 0<br/>    }<br/><br/>    if haystackLen &lt; needleLen {<br/>        return -1<br/>    }<br/><br/>    i := 0<br/>    j := 0<br/>    index := 0<br/><br/>    for i &lt; haystackLen {<br/>        if haystack[i] == needle[j] {<br/>            index = i<br/><br/>            for j &lt; needleLen &amp;&amp; haystack[i] == needle[j] {<br/>                i++<br/>                j++<br/>            }<br/><br/>            if j == needleLen {<br/>                return index<br/>            } else {<br/>                j = 0<br/>                i = index + 1<br/>            }<br/>        } else {<br/>            i++<br/>        }<br/>    }<br/><br/>    return -1<br/>}</span></pre><p id="45f0" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated"><strong class="jf hj"> Javascript 解决方案</strong></p><pre class="kh ki kj kk fd kl km kn ko aw kp bi"><span id="608a" class="kq ig hi km b fi kr ks l kt ku">var strStr = function(haystack, needle) {<br/>    if(needle.length == 0){<br/>        return 0;<br/>    }<br/><br/>    if(haystack.length &lt; needle.length){<br/>        return -1;<br/>    }<br/><br/>    let i = 0, j = 0;<br/>    let index;<br/><br/>    while( i &lt; haystack.length ){<br/>        if( haystack[i] == needle[j] ){<br/>            index = i;<br/>            while( haystack[i] == needle[j] &amp;&amp; j &lt; needle.length ){<br/>                i++;<br/>                j++;<br/>            }<br/><br/>            if( j == needle.length ){<br/>                return index;<br/>            } else {<br/>                j = 0;<br/>                i = index + 1;<br/>            }<br/>        } else {<br/>            i++;<br/>        }<br/>    }<br/><br/>    return -1;<br/>};</span></pre><p id="205d" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">让我们试运行一下我们的算法，看看解决方案是如何工作的。</p><pre class="kh ki kj kk fd kl km kn ko aw kp bi"><span id="c8be" class="kq ig hi km b fi kr ks l kt ku">Input: haystack = "hello", needle = "ll"<br/><br/>Step 1: needle.size() == 0<br/>        false<br/><br/>Step 2: haystack.size() &lt; needle.size()<br/>        5 &lt; 2<br/>        false<br/><br/>Step 3: i, j, k = 0, 0, 0<br/><br/>Step 4: while i &lt; haystack.size()<br/>        0 &lt; 5<br/>        true<br/><br/>        haystack[i] == needle[j]<br/>        haystack[0] == needle[0]<br/>        'h' == 'l'<br/>        false<br/><br/>        i++<br/>        i = 1<br/><br/>Step 5: while i &lt; haystack.size()<br/>        1 &lt; 5<br/>        true<br/><br/>        haystack[i] == needle[j]<br/>        haystack[1] == needle[0]<br/>        'e' == 'l'<br/>        false<br/><br/>        i++<br/>        i = 2<br/><br/>Step 6: while i &lt; haystack.size()<br/>        2 &lt; 5<br/>        true<br/><br/>        haystack[i] == needle[j]<br/>        haystack[2] == needle[0]<br/>        'l' == 'l'<br/>        true<br/>        index = i<br/>        index = 2<br/><br/>        j &lt; needle.length &amp;&amp; haystack[i] == needle[j]<br/>        0 &lt; 2 &amp;&amp; haystack[2] == needle[0]<br/>        true &amp;&amp; 'l' == 'l'<br/>        true<br/><br/>        i++;<br/>        j++;<br/><br/>        i = 3<br/>        j = 1<br/><br/>        j &lt; needle.length &amp;&amp; haystack[i] == needle[j]<br/>        1 &lt; 2 &amp;&amp; haystack[3] == needle[1]<br/>        true &amp;&amp; 'l' == 'l'<br/>        true<br/><br/>        i++;<br/>        j++;<br/><br/>        i = 4<br/>        j = 2<br/><br/>        j &lt; needle.length &amp;&amp; haystack[i] == needle[j]<br/>        2 &lt; 2<br/>        false<br/><br/>Step 7: j == needle.length<br/>        2 == 2<br/>        true<br/><br/>The answer returned is index: 2</span></pre></div><div class="ab cl li lj gp lk" role="separator"><span class="ll bw bk lm ln lo"/><span class="ll bw bk lm ln lo"/><span class="ll bw bk lm ln"/></div><div class="hb hc hd he hf"><p id="15b5" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated"><em class="lp">原发布于</em><a class="ae kg" href="https://alkeshghorpade.me/post/leetcode-implement-strstr" rel="noopener ugc nofollow" target="_blank"><em class="lp">https://alkeshghorpade . me</em></a><em class="lp">。</em></p></div></div>    
</body>
</html>