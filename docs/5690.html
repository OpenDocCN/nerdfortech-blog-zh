<html>
<head>
<title>How to Ignore a Collider on a GameObject</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何忽略游戏对象上的碰撞器</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/how-to-ignore-a-collider-on-a-gameobject-eeb1ed6a6acb?source=collection_archive---------3-----------------------#2021-11-01">https://medium.com/nerd-for-tech/how-to-ignore-a-collider-on-a-gameobject-eeb1ed6a6acb?source=collection_archive---------3-----------------------#2021-11-01</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="6bb3" class="pw-post-body-paragraph ig ih hi ii b ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd hb bi translated">现在让我们来看看如何为我们的射手实现一个血液飞溅系统。首先，我们只需要找到一个好的飞溅来工作，并附上它的预置作为我们拍摄脚本的游戏对象:</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div class="er es je"><img src="../Images/f041d4ef284783533347ad5944ce44f1.png" data-original-src="https://miro.medium.com/v2/resize:fit:988/format:webp/1*Pd3YJJxaIQPr31F8A1vGJQ.png"/></div></figure><p id="9603" class="pw-post-body-paragraph ig ih hi ii b ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd hb bi translated">为了使我们的飞溅不总是以相同的旋转值产生，无论我们是正面拍摄还是从侧面拍摄，我们都需要将lookrotation逻辑应用于实例化方法，以便它可以很好地围绕我们的对象旋转:</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jn jo di jp bf jq"><div class="er es jm"><img src="../Images/8e7207a7a0893a88bf7087b9cf9fb903.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*wFzIcrmNFHFaVtWACBJscw.gif"/></div></div></figure><p id="0563" class="pw-post-body-paragraph ig ih hi ii b ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd hb bi translated">现在我们有了一个漂亮的飞溅，它将根据我们撞击物体的位置来改变它的旋转，我们可以看到一个小问题。如上所述，我们正在攻击敌人周围的一个隐形球。这是因为我们的镜头被攻击状态碰撞器阻止了，我们之前在处理实现各种攻击状态时应用于敌人。为了解决这个问题，我们将不得不对我们的脚本做一些调整，因为我们想让这个碰撞器成为敌人的子物体。首先，我们将把状态变化的逻辑转换到一个新的脚本中，并对其进行一些小的调整:</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jn jo di jp bf jq"><div class="er es jm"><img src="../Images/d4dfec89f95e1a1cfc8a8b768a6d42b2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*aGG9glSQ-MsIwZ5D00Qo2A.png"/></div></div></figure><p id="3e1d" class="pw-post-body-paragraph ig ih hi ii b ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd hb bi translated">这些改变只是召唤我们必须在敌人剧本中设置的特定空白，将敌人的状态改变成我们想要的状态:</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div class="er es jr"><img src="../Images/1b0ddf61c6b08a98683b49e67d887410.png" data-original-src="https://miro.medium.com/v2/resize:fit:696/format:webp/1*0Q3UVZmX57R66TfgTfKMnw.png"/></div></figure><p id="4e54" class="pw-post-body-paragraph ig ih hi ii b ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd hb bi translated">现在我们已经有了这个部分，并且已经在游戏中测试过，以确保敌人有相同类型的行为，让我们看看我们现在如何能够忽略状态碰撞器，只击中敌人:</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div class="er es js"><img src="../Images/a6352aad886dea37eaba4aaae410edcb.png" data-original-src="https://miro.medium.com/v2/resize:fit:994/format:webp/1*ZxRP3ngS8oGbIqY1wgSYYA.png"/></div></figure><p id="c00d" class="pw-post-body-paragraph ig ih hi ii b ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd hb bi translated">通过对光线投射游戏代码的调整，我们告诉Unity我们想让第0层的所有东西都被击中。如果我们决定添加额外的目标层，我们只需在该行代码的最后一部分添加“| 1 &lt;&lt; x”。现在我们已经准备好了，让我们看看它在游戏中的样子:</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jn jo di jp bf jq"><div class="er es jm"><img src="../Images/b0848236544406ff1d433fa8046e3def.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*eWY4UDJZ9SWsUuvdCGjbig.gif"/></div></div></figure><p id="ffc3" class="pw-post-body-paragraph ig ih hi ii b ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd hb bi translated">现在我们有了一个正常工作的飞溅系统，我们可以开始游戏的下一部分了。</p></div></div>    
</body>
</html>