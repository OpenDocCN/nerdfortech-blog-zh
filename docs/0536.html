<html>
<head>
<title>Breadth-First Search &amp; Depth-First Search</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">广度优先搜索和深度优先搜索</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/breadth-first-search-depth-first-search-dcd18fb18e0c?source=collection_archive---------3-----------------------#2021-01-11">https://medium.com/nerd-for-tech/breadth-first-search-depth-first-search-dcd18fb18e0c?source=collection_archive---------3-----------------------#2021-01-11</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/1b2db626fff7b146006a5290b0e3dfad.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*3Gz_gbt5_AZmclWn.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">图表—维基百科</figcaption></figure></div><div class="ab cl iu iv gp iw" role="separator"><span class="ix bw bk iy iz ja"/><span class="ix bw bk iy iz ja"/><span class="ix bw bk iy iz"/></div><div class="hb hc hd he hf"><p id="84b7" class="pw-post-body-paragraph jb jc hi jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hb bi translated">继续我最近的学习树和图数据结构的博客，我还想写两种使用<strong class="jd hj">广度优先搜索</strong> &amp; <strong class="jd hj">深度优先搜索遍历这些数据结构的方法！</strong></p><h1 id="2ec7" class="jz ka hi bd kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw bi translated"><strong class="ak">什么是深度优先搜索算法？</strong></h1><p id="5d3c" class="pw-post-body-paragraph jb jc hi jd b je kx jg jh ji ky jk jl jm kz jo jp jq la js jt ju lb jw jx jy hb bi translated">深度优先搜索是一种算法，它搜索或遍历图形或树形数据结构。从选定的根节点开始(这可以是为图形数据结构选择的任何节点)，该算法沿着它能找到的每个可能的分支探索，直到它必须从探索的节点向下回溯到未访问的节点。</p><figure class="ld le lf lg fd ij er es paragraph-image"><div class="er es lc"><img src="../Images/e1486b5328790639d3af71002dfe7f9e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/0*JTVAjOLwTaxMX5Bl.gif"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">深度优先搜索树数据结构的动画—维基百科</figcaption></figure><h1 id="5101" class="jz ka hi bd kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw bi translated"><strong class="ak">深度优先搜索的伪代码</strong></h1><p id="c98e" class="pw-post-body-paragraph jb jc hi jd b je kx jg jh ji ky jk jl jm kz jo jp jq la js jt ju lb jw jx jy hb bi translated"><strong class="jd hj">递归代码:</strong></p><pre class="ld le lf lg fd lh li lj lk aw ll bi"><span id="0d58" class="lm ka hi li b fi ln lo l lp lq"><strong class="li hj">procedure</strong> DFS(<em class="lr">G</em>, <em class="lr">v</em>) <strong class="li hj">is</strong><br/>    label <em class="lr">v</em> as discovered<br/>    <strong class="li hj">for all</strong> directed edges from <em class="lr">v</em> to <em class="lr">w that are</em> <strong class="li hj">in</strong> <em class="lr">G</em>.adjacentEdges(<em class="lr">v</em>) <strong class="li hj">do</strong><br/>        <strong class="li hj">if</strong> vertex <em class="lr">w</em> is not labeled as discovered <strong class="li hj">then</strong><br/>            recursively call DFS(<em class="lr">G</em>, <em class="lr">w</em>)</span><span id="d954" class="lm ka hi li b fi ls lo l lp lq">--Wikipedia</span></pre><p id="5e30" class="pw-post-body-paragraph jb jc hi jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hb bi translated"><strong class="jd hj">迭代代码:</strong></p><pre class="ld le lf lg fd lh li lj lk aw ll bi"><span id="e7e7" class="lm ka hi li b fi ln lo l lp lq"><strong class="li hj">const </strong>DFS = (node) <em class="lr">=&gt;</em>{</span><span id="3658" class="lm ka hi li b fi ls lo l lp lq">create and empty stack</span><span id="19cc" class="lm ka hi li b fi ls lo l lp lq">push node into stack</span><span id="ee97" class="lm ka hi li b fi ls lo l lp lq">while (stack is not empty){</span><span id="c2a6" class="lm ka hi li b fi ls lo l lp lq">reassign the node to the popped off element in the stack</span><span id="1f1b" class="lm ka hi li b fi ls lo l lp lq">if(node has not been visited){</span><span id="647f" class="lm ka hi li b fi ls lo l lp lq">mark the node as now visited<br/>}</span><span id="76a3" class="lm ka hi li b fi ls lo l lp lq"><strong class="li hj">for each </strong>(edge to vertices in the graph){</span><span id="62fe" class="lm ka hi li b fi ls lo l lp lq">push that vertex into the stack<br/>}<br/>}<br/>}</span></pre><p id="5577" class="pw-post-body-paragraph jb jc hi jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hb bi translated">深度优先搜索访问每个顶点一次，检查图中的每个边一次。因此，DFS 复杂度为<em class="lr">O</em>(<em class="lr">V</em>+<em class="lr">E</em>)。</p></div><div class="ab cl iu iv gp iw" role="separator"><span class="ix bw bk iy iz ja"/><span class="ix bw bk iy iz ja"/><span class="ix bw bk iy iz"/></div><div class="hb hc hd he hf"><h1 id="1fa4" class="jz ka hi bd kb kc lt ke kf kg lu ki kj kk lv km kn ko lw kq kr ks lx ku kv kw bi translated">什么是广度优先搜索算法？</h1><p id="f734" class="pw-post-body-paragraph jb jc hi jd b je kx jg jh ji ky jk jl jm kz jo jp jq la js jt ju lb jw jx jy hb bi translated">广度优先搜索是一种算法，它搜索或遍历图形或树形数据结构。从树根节点开始，该算法在移动到下一深度级别的节点之前，探索当前深度的所有相邻节点。</p><figure class="ld le lf lg fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ly"><img src="../Images/5060274381b516570a1748ec5a3a8ea6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*WAkA73-8Jqyz11hC.gif"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">广度优先搜索开发社区的 Gif</figcaption></figure><h1 id="5e15" class="jz ka hi bd kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw bi translated">广度优先搜索的伪代码</h1><p id="a3eb" class="pw-post-body-paragraph jb jc hi jd b je kx jg jh ji ky jk jl jm kz jo jp jq la js jt ju lb jw jx jy hb bi translated"><strong class="jd hj">迭代代码:</strong></p><pre class="ld le lf lg fd lh li lj lk aw ll bi"><span id="f09b" class="lm ka hi li b fi ln lo l lp lq"><strong class="li hj">Input</strong>: A graph <em class="lr">G</em> and a <em class="lr">starting vertex</em> <em class="lr">root</em> of <em class="lr">G</em></span><span id="66b4" class="lm ka hi li b fi ls lo l lp lq"><strong class="li hj">Output</strong>: Goal state. The <em class="lr">parent</em> links trace the shortest path back to <em class="lr">root</em><a class="ae lz" href="https://en.wikipedia.org/wiki/Breadth-first_search#cite_note-7" rel="noopener ugc nofollow" target="_blank">[7]</a></span><span id="9a04" class="lm ka hi li b fi ls lo l lp lq"><strong class="li hj">function</strong> BFS(G,root){<br/>create and empty queue array<br/>label the root as visited in an array<br/>assign the root to the queue</span><span id="62ae" class="lm ka hi li b fi ls lo l lp lq"><strong class="li hj">while</strong>(queue is not empty){<br/>assign a visited variable to the popped off element in the queue</span><span id="19c2" class="lm ka hi li b fi ls lo l lp lq"><strong class="li hj">for (all neighbors</strong> w of v in G){<br/><strong class="li hj">if</strong>(w is not visited){<br/>push w into back of queue to visit its neighbors (if has any)<br/>mark w as visited (true)<br/>}<br/>}<br/>}<br/>return visited<br/>}</span></pre></div><div class="ab cl iu iv gp iw" role="separator"><span class="ix bw bk iy iz ja"/><span class="ix bw bk iy iz ja"/><span class="ix bw bk iy iz"/></div><div class="hb hc hd he hf"><h1 id="a7e7" class="jz ka hi bd kb kc lt ke kf kg lu ki kj kk lv km kn ko lw kq kr ks lx ku kv kw bi translated">资源:</h1><blockquote class="ma mb mc"><p id="1893" class="jb jc lr jd b je jf jg jh ji jj jk jl md jn jo jp me jr js jt mf jv jw jx jy hb bi translated">一个非常有用的媒体博客，由<a class="ae lz" href="https://codeburst.io/implementing-dfs-and-bfs-using-javascript-5034f3cee9a1" rel="noopener" target="_blank">感谢上帝 Ukachukwu </a></p></blockquote><div class="mg mh ez fb mi mj"><a href="https://en.wikipedia.org/wiki/Breadth-first_search#Pseudocode" rel="noopener  ugc nofollow" target="_blank"><div class="mk ab dw"><div class="ml ab mm cl cj mn"><h2 class="bd hj fi z dy mo ea eb mp ed ef hh bi translated">广度优先搜索</h2><div class="mq l"><h3 class="bd b fi z dy mo ea eb mp ed ef dx translated">广度优先搜索(BFS)是一种遍历或搜索树或图数据结构的算法。它始于…</h3></div><div class="mr l"><p class="bd b fp z dy mo ea eb mp ed ef dx translated">en.wikipedia.org</p></div></div><div class="ms l"><div class="mt l mu mv mw ms mx io mj"/></div></div></a></div><div class="mg mh ez fb mi mj"><a href="https://en.wikipedia.org/wiki/Depth-first_search" rel="noopener  ugc nofollow" target="_blank"><div class="mk ab dw"><div class="ml ab mm cl cj mn"><h2 class="bd hj fi z dy mo ea eb mp ed ef hh bi translated">深度优先搜索</h2><div class="mq l"><h3 class="bd b fi z dy mo ea eb mp ed ef dx translated">深度优先搜索(DFS)是一种遍历或搜索树或图数据结构的算法。算法…</h3></div><div class="mr l"><p class="bd b fp z dy mo ea eb mp ed ef dx translated">en.wikipedia.org</p></div></div><div class="ms l"><div class="my l mu mv mw ms mx io mj"/></div></div></a></div><blockquote class="ma mb mc"><p id="6f5f" class="jb jc lr jd b je jf jg jh ji jj jk jl md jn jo jp me jr js jt mf jv jw jx jy hb bi translated">我发现 youtube 上的两个视频非常有助于了解<a class="ae lz" href="https://youtu.be/aWEKe7lQxNw" rel="noopener ugc nofollow" target="_blank">呼吸优先搜索</a> &amp; <a class="ae lz" href="https://youtu.be/pDxbtrVDwSU" rel="noopener ugc nofollow" target="_blank">深度优先搜索</a>由<a class="ae lz" href="https://www.youtube.com/channel/UCFhHB5_2UkzB4V5iL1oaI-Q" rel="noopener ugc nofollow" target="_blank">逻辑优先</a></p></blockquote></div></div>    
</body>
</html>