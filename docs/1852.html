<html>
<head>
<title>Network Policies demystified in Kubernetes</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Kubernetes 揭秘网络政策</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/network-policies-demystified-in-kubernetes-d57fc2548043?source=collection_archive---------9-----------------------#2021-04-10">https://medium.com/nerd-for-tech/network-policies-demystified-in-kubernetes-d57fc2548043?source=collection_archive---------9-----------------------#2021-04-10</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="b22c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">使用 Cilium 编辑器在 Kubernetes 中可视化网络策略</p><p id="e2fa" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">你可能会在 Kubernetes 上运行一些微服务。考虑一个简单的架构，你可能有一个 web 服务器(前端)和一个数据库服务器(后端)以及一些其他的微服务(例如:像 Kafka、RabbitMQ 等消息队列)。您可能希望数据库服务器只能由 Kafka、RabbitMQ Pods 访问。messaging broker pods(即 Kafka)应该只接收来自 web 服务器 pod 的流量。所有这些是如何实现的？我们如何控制进出 Kubernetes 资源的流量？<a class="ae jd" href="https://kubernetes.io/docs/concepts/services-networking/network-policies/" rel="noopener ugc nofollow" target="_blank"> <strong class="ih hj">网络政策</strong> </a>在 Kubernetes 来我们这里救援。<strong class="ih hj">网络策略</strong>是 Kubernetes 资源，控制 Kubernetes 资源之间的流量，如 pod、网络端点。它定义了 pod 和网络端点之间通信的网络访问策略。网络策略允许我们指定 Pod 被授权连接的实体。可以通过在数据库单元上实施联网策略来解决上述单元之间通信受限的问题，这将允许来自标签为 app=messaging-server 的单元的流量，Kafka/RabbitMQ 单元也同样允许来自标签为 app=web-server 的单元的流量。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es je"><img src="../Images/5921f38f74fd3529ae27b2af407fb20a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vKjH-Q7ZHKSagW9P_XC4yw.png"/></div></div><figcaption class="jq jr et er es js jt bd b be z dx translated">使用 cilium 编辑器实现网络策略可视化</figcaption></figure><h1 id="7410" class="ju jv hi bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">整个故事是关于什么的？(TLDR)</h1><ol class=""><li id="314d" class="ks kt hi ih b ii ku im kv iq kw iu kx iy ky jc kz la lb lc bi translated">了解 Kubernetes 中的各种网络策略。</li><li id="8e5a" class="ks kt hi ih b ii ld im le iq lf iu lg iy lh jc kz la lb lc bi translated">使用<a class="ae jd" href="https://editor.cilium.io/" rel="noopener ugc nofollow" target="_blank"> <em class="li">纤毛编辑器</em>可视化这些网络策略。</a></li></ol><h1 id="13c8" class="ju jv hi bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">先决条件</h1><ol class=""><li id="b0b8" class="ks kt hi ih b ii ku im kv iq kw iu kx iy ky jc kz la lb lc bi translated">Kubernetes 集群(可以是本地、AKS、EKS、GKE、Kind)。</li></ol><h1 id="0092" class="ju jv hi bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">故事资源</h1><ol class=""><li id="d158" class="ks kt hi ih b ii ku im kv iq kw iu kx iy ky jc kz la lb lc bi translated">GitHub 链接:<a class="ae jd" href="https://github.com/pavan-kumar-99/medium-manifests" rel="noopener ugc nofollow" target="_blank">https://github.com/pavan-kumar-99/medium-manifests</a></li><li id="4235" class="ks kt hi ih b ii ld im le iq lf iu lg iy lh jc kz la lb lc bi translated">GitHub 分支:网络-策略</li></ol><h2 id="530f" class="lj jv hi bd jw lk ll lm ka ln lo lp ke iq lq lr ki iu ls lt km iy lu lv kq lw bi translated">创建网络策略</h2><blockquote class="lx ly lz"><p id="ecce" class="if ig li ih b ii ij ik il im in io ip ma ir is it mb iv iw ix mc iz ja jb jc hb bi translated">网络策略由网络插件实现。要使用网络策略，您必须使用支持网络策略的网络解决方案。</p></blockquote><p id="36a8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">默认情况下，单元是非隔离的。这意味着</p><ol class=""><li id="b7be" class="ks kt hi ih b ii ij im in iq md iu me iy mf jc kz la lb lc bi translated">每个 pod 可以与同一命名空间中的所有其他 Pod 通信。</li><li id="92f7" class="ks kt hi ih b ii ld im le iq lf iu lg iy lh jc kz la lb lc bi translated">一个名称空间中的所有 pod 可以与不同名称空间中的所有其他 pod 通信。</li><li id="4ddf" class="ks kt hi ih b ii ld im le iq lf iu lg iy lh jc kz la lb lc bi translated">没有入口或出口策略应用于 pod。默认情况下，允许入站和出站流量进出 Pod。</li></ol><p id="999a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们从创建 3 个部署开始。在本演示的范围内，所有三个部署将使用相同的映像(即 Nginx ),因为本文的主要目的是理解网络策略的概念，而不是从头开始开发应用程序。让我们创建 web 服务器组件。</p><pre class="jf jg jh ji fd mg mh mi mj aw mk bi"><span id="4bf2" class="lj jv hi mh b fi ml mm l mn mo">$ kubectl create ns netpol</span><span id="3305" class="lj jv hi mh b fi mp mm l mn mo">$ kubectl config set-context --current --namespace=netpol</span><span id="6152" class="lj jv hi mh b fi mp mm l mn mo">$ kubectl create deploy web-server --image=nginx </span><span id="4df7" class="lj jv hi mh b fi mp mm l mn mo">$ kubectl expose deploy web-server --port=80 </span></pre><p id="5195" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们现在创建卡夫卡组件</p><pre class="jf jg jh ji fd mg mh mi mj aw mk bi"><span id="65e0" class="lj jv hi mh b fi ml mm l mn mo">$ kubectl create deploy kafka-server --image=nginx</span><span id="57f5" class="lj jv hi mh b fi mp mm l mn mo">$ kubectl expose deploy kafka-server --port=80</span></pre><p id="7228" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在让我们创建数据库组件</p><pre class="jf jg jh ji fd mg mh mi mj aw mk bi"><span id="4f61" class="lj jv hi mh b fi ml mm l mn mo">$ kubectl create deploy database-server --image=nginx</span><span id="e3bc" class="lj jv hi mh b fi mp mm l mn mo">$ kubectl expose deploy database-server --port=80</span></pre><p id="9511" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们现在将尝试从 web 服务器访问数据库服务器。</p><pre class="jf jg jh ji fd mg mh mi mj aw mk bi"><span id="d005" class="lj jv hi mh b fi ml mm l mn mo">$ export role="web-server"</span><span id="d821" class="lj jv hi mh b fi mp mm l mn mo">$ server_name=$(kubectl get po -l app=$role -o jsonpath='{.items[0].metadata.name}')</span><span id="9e2d" class="lj jv hi mh b fi mp mm l mn mo">$ kubectl exec $server_name -- /bin/sh -c "curl -s database-server" </span></pre><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es mq"><img src="../Images/a5cbad61f6c8dc7a39a851ca1daf7ffb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*m4N1D-nbTh8IeuJtEmBa8g.png"/></div></div><figcaption class="jq jr et er es js jt bd b be z dx translated">web 服务器和数据库服务器之间的通信</figcaption></figure><p id="62b8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">您应该注意到 web 服务器可以与数据库服务器通信。其他的豆荚也是如此。您可以通过在上面的命令中将角色更改为 kafka-server 或任何其他服务器来检查这一点。</p><p id="d9fc" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">所以，不，我们不希望名称空间中的每个 pod 都可以访问数据库服务器。相反，只有 kafka 服务器应该访问它。即，只有标签为 app=kafka-server 的 pod 才能与数据库服务器通信(即，标签为 app=database-server)。</p><figure class="jf jg jh ji fd jj"><div class="bz dy l di"><div class="mr ms l"/></div></figure><p id="9f2c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在让我们仔细看看清单。</p><blockquote class="lx ly lz"><p id="b348" class="if ig li ih b ii ij ik il im in io ip ma ir is it mb iv iw ix mc iz ja jb jc hb bi translated">spec.podSelector:要应用此网络策略的 pod 的标签。</p><p id="3a90" class="if ig li ih b ii ij ik il im in io ip ma ir is it mb iv iw ix mc iz ja jb jc hb bi translated">入口. from.podSelector:允许入口流量的 pod 的标签。</p><p id="e647" class="if ig li ih b ii ij ik il im in io ip ma ir is it mb iv iw ix mc iz ja jb jc hb bi translated">ingress.ports:允许进入通信的端口。</p></blockquote><p id="d454" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在，让我们应用网络策略来查看变化。</p><pre class="jf jg jh ji fd mg mh mi mj aw mk bi"><span id="9e94" class="lj jv hi mh b fi ml mm l mn mo">$ git clone <a class="ae jd" href="https://github.com/pavan-kumar-99/medium-manifests.git" rel="noopener ugc nofollow" target="_blank">https://github.com/pavan-kumar-99/medium-manifests.git</a> \<br/>-b network-policies</span><span id="8068" class="lj jv hi mh b fi mp mm l mn mo">$ cd medium-manifests/</span><span id="910a" class="lj jv hi mh b fi mp mm l mn mo">$ kubectl apply -f access-db-from-kafka-netpol.yaml</span></pre><p id="109b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">好啊，我们的第一个政策现在开始实施了。让我们尝试从两个不同的 pod 访问数据库服务器，即</p><ol class=""><li id="1854" class="ks kt hi ih b ii ij im in iq md iu me iy mf jc kz la lb lc bi translated">从 web 服务器 pod(这应该会失败)。</li><li id="7f82" class="ks kt hi ih b ii ld im le iq lf iu lg iy lh jc kz la lb lc bi translated">来自卡夫卡豆荚(这个应该会过去)。</li></ol><pre class="jf jg jh ji fd mg mh mi mj aw mk bi"><span id="b92b" class="lj jv hi mh b fi ml mm l mn mo">$ export role="web-server"</span><span id="fd8c" class="lj jv hi mh b fi mp mm l mn mo">$ server_name=$(kubectl get po -l app=$role -o jsonpath='{.items[0].metadata.name}')</span><span id="a90f" class="lj jv hi mh b fi mp mm l mn mo">$ kubectl exec $server_name -- /bin/sh -c "curl -s database-server"<br/>  <br/>command terminated with exit code 7</span></pre><p id="42bc" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">请求现在将会超时。现在让我们从 Kafka 服务器尝试同样的方法。</p><pre class="jf jg jh ji fd mg mh mi mj aw mk bi"><span id="c5b5" class="lj jv hi mh b fi ml mm l mn mo">$ export role="kafka-server"</span><span id="f545" class="lj jv hi mh b fi mp mm l mn mo">$ server_name=$(kubectl get po -l app=$role -o jsonpath='{.items[0].metadata.name}')</span><span id="a281" class="lj jv hi mh b fi mp mm l mn mo">$ kubectl exec $server_name -- /bin/sh -c "curl -s database-server"</span></pre><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es mt"><img src="../Images/ce753db3f57be50127aaa3840eda2a91.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Bv3VHwxc16AcigCNx7hZxQ.png"/></div></div><figcaption class="jq jr et er es js jt bd b be z dx translated">curl 命令现在成功了</figcaption></figure><p id="532d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在，您应该能够从 kafka-server pod 连接到数据库服务器 pod。</p><p id="baeb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们还应该限制 kafka-server pod 的流量，只允许来自 web-server pod 的入站流量。但这一次，让我们通过可视化网络策略使它更具交互性。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div class="er es mu"><img src="../Images/68728d8efad14b262b82f7ca22fe4817.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/0*-YadQJKdNO6Dj2yZ.gif"/></div><figcaption class="jq jr et er es js jt bd b be z dx translated">图片来源:谷歌</figcaption></figure><p id="8772" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">是的，你没看错。<strong class="ih hj"/><a class="ae jd" href="https://editor.cilium.io/" rel="noopener ugc nofollow" target="_blank"><strong class="ih hj">editor . cilium . io</strong></a>可以轻松构建和可视化网络策略，然后可以作为 YAML 下载并在任何 Kubernetes 集群中运行。YAML 的也可以上传到一个适当的图形用户界面可视化。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es mv"><img src="../Images/32abd4dea4f6120fb602c8b1ecdcd841.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Yds7rptZEfOAtls3VEayrA.png"/></div></div><figcaption class="jq jr et er es js jt bd b be z dx translated">纤毛编辑器</figcaption></figure><p id="2546" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">中间的方框代表您尝试应用网络策略的资源。左边的资源代表入口策略，右边的资源代表出口策略。我们现在应该限制 kafka-server pod 的流量，只允许来自 web-server pod 的入站流量。</p><p id="266a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">一旦创建了策略，您应该会在屏幕上找到 yaml 创建的策略。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es mw"><img src="../Images/a100587f24389ce6f533b6668b063f99.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dB71dB0J5HSBq4PY7aLSIQ.png"/></div></div><figcaption class="jq jr et er es js jt bd b be z dx translated">来自 cilium 编辑器的网络策略</figcaption></figure><p id="9ff1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们现在将下载该策略并将其应用到我们的 Kubernetes 集群。我已经把这个下载到我的 GitHub repo 里了。</p><pre class="jf jg jh ji fd mg mh mi mj aw mk bi"><span id="295b" class="lj jv hi mh b fi ml mm l mn mo">$ git clone <a class="ae jd" href="https://github.com/pavan-kumar-99/medium-manifests.git" rel="noopener ugc nofollow" target="_blank">https://github.com/pavan-kumar-99/medium-manifests.git</a> \<br/>-b network-policies</span><span id="f092" class="lj jv hi mh b fi mp mm l mn mo">$ cd medium-manifests/</span><span id="78ae" class="lj jv hi mh b fi mp mm l mn mo">$ kubectl apply -f access-kafka-from-web.yaml</span></pre><figure class="jf jg jh ji fd jj"><div class="bz dy l di"><div class="mr ms l"/></div></figure><p id="5588" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">万岁，我们的第二个政策也适用。让我们尝试从两个不同的 pod 访问 kafka 服务器，即</p><ol class=""><li id="a2b3" class="ks kt hi ih b ii ij im in iq md iu me iy mf jc kz la lb lc bi translated">从 web 服务器 pod(这应该会通过)。</li><li id="8bd2" class="ks kt hi ih b ii ld im le iq lf iu lg iy lh jc kz la lb lc bi translated">从数据库窗格(这应该会失败)。</li></ol><pre class="jf jg jh ji fd mg mh mi mj aw mk bi"><span id="9ccd" class="lj jv hi mh b fi ml mm l mn mo">$ export role="database-server"</span><span id="2950" class="lj jv hi mh b fi mp mm l mn mo">$ server_name=$(kubectl get po -l app=$role -o jsonpath='{.items[0].metadata.name}')</span><span id="087e" class="lj jv hi mh b fi mp mm l mn mo">$ kubectl exec $server_name -- /bin/sh -c "curl -s kafka-server"<br/>  <br/>command terminated with exit code 7</span></pre><p id="aa0c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们现在将尝试从 web 服务器访问 kafka 服务器</p><pre class="jf jg jh ji fd mg mh mi mj aw mk bi"><span id="07ee" class="lj jv hi mh b fi ml mm l mn mo">$ export role="web-server"</span><span id="ba9a" class="lj jv hi mh b fi mp mm l mn mo">$ server_name=$(kubectl get po -l app=$role -o jsonpath='{.items[0].metadata.name}')</span><span id="9304" class="lj jv hi mh b fi mp mm l mn mo">$ kubectl exec $server_name -- /bin/sh -c "curl -s kafka-server"</span></pre><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es mx"><img src="../Images/e8a586698a8a6dc3b7cb00d03f9b5741.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*obOTToGfTb_qgfDj8BriOw.png"/></div></div><figcaption class="jq jr et er es js jt bd b be z dx translated">网络策略按预期工作</figcaption></figure><h1 id="7e1d" class="ju jv hi bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">结论</h1><p id="b181" class="pw-post-body-paragraph if ig hi ih b ii ku ik il im kv io ip iq my is it iu mz iw ix iy na ja jb jc hb bi translated">在像<a class="ae jd" href="https://editor.cilium.io/" rel="noopener ugc nofollow" target="_blank">https://editor.cilium.io/</a>理解和可视化工具的帮助下，网络政策现在变得更加容易。许多更复杂的网络策略包括选择器，如 CIDR 块、名称空间等。我将在下一篇文章中用一个实际的 golang 应用程序来介绍它们。</p><p id="6575" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">直到下一次…..</p><h1 id="066a" class="ju jv hi bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">被推荐的</h1><div class="nb nc ez fb nd ne"><a href="https://www.techmanyu.com/creating-self-hosted-github-runners-in-a-kubernetes-cluster-fd05560de34a" rel="noopener  ugc nofollow" target="_blank"><div class="nf ab dw"><div class="ng ab nh cl cj ni"><h2 class="bd hj fi z dy nj ea eb nk ed ef hh bi translated">在 Kubernetes 集群中创建自托管 GitHub 运行程序</h2><div class="nl l"><h3 class="bd b fi z dy nj ea eb nk ed ef dx translated">在您自己的 Kubernetes 集群上运行 GitHub 操作</h3></div><div class="nm l"><p class="bd b fp z dy nj ea eb nk ed ef dx translated">www.techmanyu.com</p></div></div><div class="nn l"><div class="no l np nq nr nn ns jo ne"/></div></div></a></div><div class="nb nc ez fb nd ne"><a rel="noopener follow" target="_blank" href="/nerd-for-tech/introduction-to-crossplane-2f873ae0f9f3"><div class="nf ab dw"><div class="ng ab nh cl cj ni"><h2 class="bd hj fi z dy nj ea eb nk ed ef hh bi translated">交叉平面简介</h2><div class="nl l"><h3 class="bd b fi z dy nj ea eb nk ed ef dx translated">如何使用 Kubernetes 清单和 Crossplane 在云上创建任何资源。</h3></div><div class="nm l"><p class="bd b fp z dy nj ea eb nk ed ef dx translated">medium.com</p></div></div><div class="nn l"><div class="nt l np nq nr nn ns jo ne"/></div></div></a></div><div class="nb nc ez fb nd ne"><a href="https://faun.pub/introduction-to-bitnami-sealed-secrets-bb5ae74d9a25" rel="noopener  ugc nofollow" target="_blank"><div class="nf ab dw"><div class="ng ab nh cl cj ni"><h2 class="bd hj fi z dy nj ea eb nk ed ef hh bi translated">比特纳米密封秘密介绍</h2><div class="nl l"><h3 class="bd b fi z dy nj ea eb nk ed ef dx translated">如何使用 Sealed Secrets 和 Kubese 在 GitHub 中存储您的秘密</h3></div><div class="nm l"><p class="bd b fp z dy nj ea eb nk ed ef dx translated">faun.pub</p></div></div><div class="nn l"><div class="nu l np nq nr nn ns jo ne"/></div></div></a></div><div class="nb nc ez fb nd ne"><a rel="noopener follow" target="_blank" href="/nerd-for-tech/autoscaling-in-kubernetes-hpa-vpa-ab61a2177950"><div class="nf ab dw"><div class="ng ab nh cl cj ni"><h2 class="bd hj fi z dy nj ea eb nk ed ef hh bi translated">Kubernetes 中的自动缩放(HPA / VPA)</h2><div class="nl l"><h3 class="bd b fi z dy nj ea eb nk ed ef dx translated">使用垂直 Pod 自动缩放器(VPA)和水平 Pod 自动缩放器(HPA)在 Kubernetes 中自动缩放您的应用程序</h3></div><div class="nm l"><p class="bd b fp z dy nj ea eb nk ed ef dx translated">medium.com</p></div></div><div class="nn l"><div class="nv l np nq nr nn ns jo ne"/></div></div></a></div><h2 id="9580" class="lj jv hi bd jw lk ll lm ka ln lo lp ke iq lq lr ki iu ls lt km iy lu lv kq lw bi translated">参考</h2><div class="nb nc ez fb nd ne"><a href="https://kubernetes.io/docs/concepts/services-networking/network-policies/#the-networkpolicy-resource" rel="noopener  ugc nofollow" target="_blank"><div class="nf ab dw"><div class="ng ab nh cl cj ni"><h2 class="bd hj fi z dy nj ea eb nk ed ef hh bi translated">网络策略</h2><div class="nl l"><h3 class="bd b fi z dy nj ea eb nk ed ef dx translated">如果您想在 IP 地址或端口级别(OSI 第 3 层或第 4 层)控制流量，那么您可以考虑使用…</h3></div><div class="nm l"><p class="bd b fp z dy nj ea eb nk ed ef dx translated">kubernetes.io</p></div></div><div class="nn l"><div class="nw l np nq nr nn ns jo ne"/></div></div></a></div></div></div>    
</body>
</html>