<html>
<head>
<title>Vue.js and Symfony — User Authentication</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Vue.js和Symfony —用户认证</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/vue-js-and-symfony-user-authentication-19ca983126d?source=collection_archive---------3-----------------------#2021-05-02">https://medium.com/nerd-for-tech/vue-js-and-symfony-user-authentication-19ca983126d?source=collection_archive---------3-----------------------#2021-05-02</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="6199" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="jd">在</em><strong class="ih hj"><em class="jd">Symfony</em></strong><em class="jd">—以</em><strong class="ih hj"><em class="jd">vue . js</em></strong><em class="jd">为前端框架</em></p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es je"><img src="../Images/9dd2ee00dd48279ef66af3ac9571356b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5yTswPY7EVA3b0OA_8lRxg.png"/></div></div></figure><p id="5080" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在本文中，我将跳过Symfony认证过程，因为这可以在官方文档中找到(它更多地是关于在使用<strong class="ih hj"> Vue.js </strong>的情况下呈现解决方案):</p><ul class=""><li id="1c2c" class="jq jr hi ih b ii ij im in iq js iu jt iy ju jc jv jw jx jy bi translated"><a class="ae jz" href="https://symfony.com/doc/current/components/security/authentication.html" rel="noopener ugc nofollow" target="_blank"> Symfony认证</a>，</li><li id="5d8a" class="jq jr hi ih b ii ka im kb iq kc iu kd iy ke jc jv jw jx jy bi translated"><a class="ae jz" href="https://symfony.com/doc/current/security/form_login_setup.html" rel="noopener ugc nofollow" target="_blank"> Symfony登录表单</a>，</li><li id="8d41" class="jq jr hi ih b ii ka im kb iq kc iu kd iy ke jc jv jw jx jy bi translated"><a class="ae jz" href="https://symfony.com/doc/current/security/guard_authentication.html" rel="noopener ugc nofollow" target="_blank">赛峰守卫认证</a>，</li></ul></div><div class="ab cl kf kg gp kh" role="separator"><span class="ki bw bk kj kk kl"/><span class="ki bw bk kj kk kl"/><span class="ki bw bk kj kk"/></div><div class="hb hc hd he hf"><p id="6e1b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi km translated">基于WT令牌的认证——一定要这样吗？</p><p id="8743" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> Vue.js </strong>允许我们创建一个<strong class="ih hj"> SPA </strong> ( <strong class="ih hj">单页应用</strong>)或者以混合的形式使用，在这种情况下，我们可以将组件注入到已经存在的代码中，或者使用<strong class="ih hj"> Vue.js </strong>作为当前前端代码的扩展(<em class="jd">，在这种情况下，我经历了惨痛的教训，它可能会变得非常混乱——你可以在这里</em> 找到更多的)</p><p id="50d8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">就我个人而言，我甚至没有打算测试这两种解决方案，因为混合解决方案工作得非常好——但是——我已经有机会在<strong class="ih hj"> Symfony </strong>中看到一些有趣/令人困惑的认证，通过使用<strong class="ih hj"> JWT </strong>在基于<strong class="ih hj"> Angular </strong>的前端上验证用户(在这种情况下<em class="jd">解决方案/最终目标不同于简单的登录表单</em>)。</p><p id="7f12" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">总的来说，JWT的解决方案确实有效，使一切都正常，没有任何问题——那么有什么意义呢？由于<strong class="ih hj"> Vue.js </strong>是我自己使用的第一个现代js框架，我想知道:</p><p id="fff2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我真的需要使用一些令牌吗，因为Symfony auth不再像它应该的那样工作了？现代JS都是这样的吗？”T55】</p><p id="d1ce" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">长话短说——不需要这样，在认证过程中实际上不需要神奇的、特殊的令牌——尽管完整的<strong class="ih hj"> SPA </strong>确实需要特殊的逻辑，但它仍然是“<em class="jd">几乎</em>标准的<strong class="ih hj"> Symfony </strong>逻辑。</p></div><div class="ab cl kf kg gp kh" role="separator"><span class="ki bw bk kj kk kl"/><span class="ki bw bk kj kk kl"/><span class="ki bw bk kj kk"/></div><div class="hb hc hd he hf"><p id="6b7a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi km translated"><span class="l kn ko kp bm kq kr ks kt ku di">T</span>T3】他最简单的解决方案——混合认证</p><p id="695c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在这种情况下，来自works的登录是唯一一个完全由<strong class="ih hj">分支</strong>呈现的页面——这里没有使用js逻辑，因此使用了正常的认证过程。</p><ol class=""><li id="75e1" class="jq jr hi ih b ii ij im in iq js iu jt iy ju jc kv jw jx jy bi translated"><strong class="ih hj">认证页面</strong> —简单的基于树枝的模板，带有登录路径</li></ol><figure class="jf jg jh ji fd jj"><div class="bz dy l di"><div class="kw kx l"/></div></figure><p id="ea65" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> 2。认证路径</strong> —返回登录页面的路径</p><figure class="jf jg jh ji fd jj"><div class="bz dy l di"><div class="kw kx l"/></div></figure><p id="1686" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">就这样(自然假设project已经配置为使用上面链接中提供的Symfony身份验证)，身份验证已经在这一步工作了——只需向<strong class="ih hj"> security.yaml </strong>添加一些规则，一切都会按预期工作。</p><p id="a66d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">请注意，用<strong class="ih hj"> Vue-Router添加的每个路由必须</strong>也存在于Symfony中，否则后端如何知道访问了什么页面？毕竟<strong class="ih hj"> Vue.js </strong>只推送浏览器历史中的新状态，除非使用简单的<code class="du ky kz la lb b">location.pathname = url</code>。</p></div><div class="ab cl kf kg gp kh" role="separator"><span class="ki bw bk kj kk kl"/><span class="ki bw bk kj kk kl"/><span class="ki bw bk kj kk"/></div><div class="hb hc hd he hf"><p id="1d64" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi km translated"><span class="l kn ko kp bm kq kr ks kt ku di"> A </span> <strong class="ih hj">添加</strong> <strong class="ih hj"> Vue.js路由到Symfony </strong></p><p id="7a80" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">就我个人而言，我有一个非常简单的解决方案，那就是定义一个方法(用基本树枝模板——它包含<strong class="ih hj"> Vue-App </strong>的<strong class="ih hj"> mounting #id </strong>):</p><ol class=""><li id="da64" class="jq jr hi ih b ii ij im in iq js iu jt iy ju jc kv jw jx jy bi translated"><strong class="ih hj">后端处理器</strong></li></ol><figure class="jf jg jh ji fd jj"><div class="bz dy l di"><div class="kw kx l"/></div></figure><p id="87bb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> 2。安装编号为</strong>的树枝</p><figure class="jf jg jh ji fd jj"><div class="bz dy l di"><div class="kw kx l"/></div></figure><p id="19ae" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这样，如果我们打开SPA页面的“new”选项卡，它仍将工作，因为它只是模板，稍后将由<strong class="ih hj"> Vue.js. </strong>重建/控制</p><p id="f1fd" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> 3。安装Vue.js </strong></p><figure class="jf jg jh ji fd jj"><div class="bz dy l di"><div class="kw kx l"/></div></figure><p id="0a5c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi km translated"><span class="l kn ko kp bm kq kr ks kt ku di"> T </span> <strong class="ih hj"> he棘手的解决方案——API调用认证</strong></p><p id="2d34" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在这个解决方案中，除了使用基<strong class="ih hj">枝</strong>模板之外，一切都在<strong class="ih hj"> Vue.js </strong>中处理(<em class="jd">只需向上滚动到</em> <strong class="ih hj"> <em class="jd">“将Vue.js路由添加到symfony】</em></strong>)。</p><ol class=""><li id="abba" class="jq jr hi ih b ii ij im in iq js iu jt iy ju jc kv jw jx jy bi translated"><strong class="ih hj">登录认证器(<em class="jd">后端</em> ) </strong></li></ol><p id="3959" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="jd">那么这个认证器有什么特别之处呢？</em></p><p id="eff5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">响应——这很重要，它是每个调用在前端消耗的<strong class="ih hj">JSON response</strong>(BaseApiDTO)。</p><figure class="jf jg jh ji fd jj"><div class="bz dy l di"><div class="kw kx l"/></div></figure><p id="9c1c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">2.<strong class="ih hj">处理Vue.js中的调用(<em class="jd">前端</em> ) </strong></p><figure class="jf jg jh ji fd jj"><div class="bz dy l di"><div class="kw kx l"/></div></figure><p id="ac86" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">3.<strong class="ih hj">回应</strong></p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es lc"><img src="../Images/642771982963aa82755184827a7303ef.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mlEk5WNDHJS2TXW0fJtWlw.png"/></div></div><figcaption class="ld le et er es lf lg bd b be z dx translated">未经授权的响应</figcaption></figure><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es lh"><img src="../Images/804c0a6c9c89c48e62e2b6f3a8b42004.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5Z52kr0XjBeDPpPERaSLgw.png"/></div></div><figcaption class="ld le et er es lf lg bd b be z dx translated">授权响应</figcaption></figure><p id="2729" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">4.<strong class="ih hj">注销用户</strong></p><figure class="jf jg jh ji fd jj"><div class="bz dy l di"><div class="kw kx l"/></div></figure></div><div class="ab cl kf kg gp kh" role="separator"><span class="ki bw bk kj kk kl"/><span class="ki bw bk kj kk kl"/><span class="ki bw bk kj kk"/></div><div class="hb hc hd he hf"><figure class="jf jg jh ji fd jj"><div class="bz dy l di"><div class="kw kx l"/></div></figure></div><div class="ab cl kf kg gp kh" role="separator"><span class="ki bw bk kj kk kl"/><span class="ki bw bk kj kk kl"/><span class="ki bw bk kj kk"/></div><div class="hb hc hd he hf"><p id="c3a5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi km translated"><span class="l kn ko kp bm kq kr ks kt ku di">S</span>T67】总结</p><p id="55ae" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这两种解决方案都非常有效，但是如果我要选择更快的一个，那么它肯定是<strong class="ih hj">混合动力-one </strong>。</p><p id="92e7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">请记住，对于这两种解决方案，都需要将<strong class="ih hj"> JsonResponse </strong>发送到前端，因此使用一些<strong class="ih hj"> BaseResponse </strong>是个好主意，它将始终包含用户认证状态。</p></div></div>    
</body>
</html>