<html>
<head>
<title>Mobile Games In Unity: Enemy Design — Abstract Classes</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Unity 中的手机游戏:敌人设计——抽象类</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/mobile-games-in-unity-enemy-design-abstract-classes-e055d55fdc6e?source=collection_archive---------8-----------------------#2021-09-08">https://medium.com/nerd-for-tech/mobile-games-in-unity-enemy-design-abstract-classes-e055d55fdc6e?source=collection_archive---------8-----------------------#2021-09-08</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="14ea" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在所有的敌人都通过他们自己的脚本共享敌人类的数据。想让苔藓巨人有独特的攻击方式怎么办？在 Moss Giant 脚本中编写一个全新的方法来处理攻击是没有意义的，特别是如果我想从敌人的攻击方法中借用一些功能的话。这就是虚方法派上用场的地方。</p><p id="403d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">虚拟方法允许我覆盖父攻击方法，但也允许我使用它的实现。敌方等级我想把攻击方式从<code class="du jd je jf jg b">public void</code>改成<code class="du jd je jf jg b">public virtual void</code>。<code class="du jd je jf jg b">virtual</code>关键字将允许我重写基本实现。</p><figure class="ji jj jk jl fd jm er es paragraph-image"><div class="er es jh"><img src="../Images/12e46e7a5b415bb095c1aa3db704e815.png" data-original-src="https://miro.medium.com/v2/resize:fit:978/format:webp/1*ESC53XiKQQ043bjdtbGgDA.png"/></div></figure><p id="054c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">所以现在在 MossGiant 脚本中，为了覆盖来自敌人类的实现，我需要做的就是做一个攻击方法，说:</p><p id="6e3c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><code class="du jd je jf jg b">public override void Attack()</code>。</p><p id="9e0c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在无论我想放什么实现进去，我都可以。如果我想从基本的敌人脚本中运行实现，我只需要在新的虚拟方法中的实现之前说<code class="du jd je jf jg b">base.Attack</code>。</p><p id="00a0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">例如:</p><figure class="ji jj jk jl fd jm er es paragraph-image"><div role="button" tabindex="0" class="jq jr di js bf jt"><div class="er es jp"><img src="../Images/abdbe77d0d7cdc17ada76c5faf11b422.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*66k6aVf55Mc7RI9TYeOm5Q.png"/></div></div></figure><p id="b800" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这是运行游戏后的控制台。我有苔藓巨人调用自己的攻击方法而蜘蛛敌人调用基础敌人职业的攻击方法。</p><figure class="ji jj jk jl fd jm er es paragraph-image"><div class="er es ju"><img src="../Images/0f260ab3ef8ef3de12fd4fb99301175c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1150/format:webp/1*ZQUek0bYGNL2BVbjS8cMlQ.png"/></div><figcaption class="jv jw et er es jx jy bd b be z dx translated">敌人阶级</figcaption></figure><figure class="ji jj jk jl fd jm er es paragraph-image"><div role="button" tabindex="0" class="jq jr di js bf jt"><div class="er es jz"><img src="../Images/db8f2ab2c527eebe4987b568150a3d4b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*a7iHxYwafaJPf-vT_NtJcQ.png"/></div></div><figcaption class="jv jw et er es jx jy bd b be z dx translated">苔藓巨人级</figcaption></figure><figure class="ji jj jk jl fd jm er es paragraph-image"><div class="er es ka"><img src="../Images/70702e943903ae9fb9c4801e2de5db57.png" data-original-src="https://miro.medium.com/v2/resize:fit:1324/format:webp/1*Nb5T0wUDvCnNKt2QTzO88A.png"/></div><figcaption class="jv jw et er es jx jy bd b be z dx translated">蜘蛛类</figcaption></figure><p id="b452" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我想让这个敌人脚本定义敌人的行为。如果我有 50 个敌人，我不想为每一个都键入一堆代码。我的目标是确定敌人进出的路径。这将通过更新方法来控制。</p><p id="c730" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">所以我可以强迫敌人使用更新方法，但是每个敌人都有不同的路点。所以我能做的一件事就是强迫他们有自己的更新方法。所以利用我们已经学过的知识，我可以在敌人的职业中放一个<code class="du jd je jf jg b">public void Update()</code>，他们可以共享它，或者我可以使用一个虚拟的方法来覆盖每个敌人的脚本。<code class="du jd je jf jg b">public vitual void Update()</code>。这个实现使得 update 方法成为可选的。我不想那样。这就是<strong class="ih hj">抽象类</strong>派上用场的地方。</p><p id="66d4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">简单的把敌人职业从<code class="du jd je jf jg b">public class Enemy</code>改成<code class="du jd je jf jg b">public abstract class Enemy</code>就是如何开始的。</p><figure class="ji jj jk jl fd jm er es paragraph-image"><div class="er es kb"><img src="../Images/816c2bbf5c5bb1a9bcc231aa94e863a6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1090/format:webp/1*Mg3OjVGa_e_7XPJWoQv0aA.png"/></div></figure><p id="6b38" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这样做允许我创建所谓的抽象方法。接下来我会做一个抽象的更新方法。</p><figure class="ji jj jk jl fd jm er es paragraph-image"><div class="er es kc"><img src="../Images/f914f5ccff9da9ac2223aba4fc86663a.png" data-original-src="https://miro.medium.com/v2/resize:fit:776/format:webp/1*XJDxjpfGM7q2KfXltxXGng.png"/></div></figure><p id="330c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">它在没有任何实现代码的情况下被初始化。</p><p id="72f3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在在我的 MossGiant 脚本和 Spider 脚本中，我应该会得到一个错误。这是因为我没有在这些脚本中实现抽象的 update 方法。</p><figure class="ji jj jk jl fd jm er es paragraph-image"><div class="er es kd"><img src="../Images/d24b6f227b3f2814e8a95a24b91bd206.png" data-original-src="https://miro.medium.com/v2/resize:fit:1202/format:webp/1*-Zx2HMrv0xVeL4eCNGCcLw.png"/></div></figure><p id="523c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">因此，我需要确保每个敌人都有自己独特的更新方法来覆盖父对象。</p><figure class="ji jj jk jl fd jm er es paragraph-image"><div class="er es ke"><img src="../Images/585d9d4e0ffdd34cbbe3dcc464149f68.png" data-original-src="https://miro.medium.com/v2/resize:fit:730/format:webp/1*ax2LyJQJnA4mwXU7Ocj0iw.png"/></div></figure><p id="fec7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这确保了每个敌人都以完全相同的方式建造。如果我们在不被敌人发现的情况下运行这个程序，它就不会起作用。为了测试这一点，我将进行一些简单的调试。登录他们各自的类并运行游戏。</p><figure class="ji jj jk jl fd jm er es paragraph-image"><div role="button" tabindex="0" class="jq jr di js bf jt"><div class="er es kf"><img src="../Images/305b4c12bb6e1d6bd821344bbfaa43a5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*Abs8cg6GvYG5FmyyM4QX6w.gif"/></div></div></figure><p id="8f8a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">每个敌人都在用他们自己独特的更新方法进行更新，同时分享一些共同的特征，比如生命值。:)</p><p id="089b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在接下来的文章中，我将介绍如何设置一些动作，这样我们就能真正看到使用抽象类是多么的方便！</p></div></div>    
</body>
</html>