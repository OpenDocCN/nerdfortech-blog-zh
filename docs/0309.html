<html>
<head>
<title>Gitlab CI and stage re-usability</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Gitlab CI和stage可重用性</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/gitlab-ci-and-stage-re-usability-ad87bb381cc6?source=collection_archive---------2-----------------------#2020-09-20">https://medium.com/nerd-for-tech/gitlab-ci-and-stage-re-usability-ad87bb381cc6?source=collection_archive---------2-----------------------#2020-09-20</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/></div><div class="ab cl if ig gp ih" role="separator"><span class="ii bw bk ij ik il"/><span class="ii bw bk ij ik il"/><span class="ii bw bk ij ik"/></div><div class="hb hc hd he hf"><p id="ac1f" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">在任何应用程序中创建可重用的方法或函数都是管理常用代码的有效方法。当您考虑多分支管道时，CICD管道以及许多重复使用的级引用都是这种情况。</p></div><div class="ab cl if ig gp ih" role="separator"><span class="ii bw bk ij ik il"/><span class="ii bw bk ij ik il"/><span class="ii bw bk ij ik"/></div><div class="hb hc hd he hf"><p id="61fb" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">以下面这个为例:</p></div><div class="ab cl if ig gp ih" role="separator"><span class="ii bw bk ij ik il"/><span class="ii bw bk ij ik il"/><span class="ii bw bk ij ik"/></div><div class="hb hc hd he hf"><ul class=""><li id="ce9a" class="jk jl hi io b ip iq it iu ix jm jb jn jf jo jj jp jq jr js bi translated"><strong class="io hj">开发分支</strong> : <strong class="io hj">构建，测试</strong>，<em class="jt">部署到沙盒</em>，<em class="jt">部署后测试</em></li></ul></div><div class="ab cl if ig gp ih" role="separator"><span class="ii bw bk ij ik il"/><span class="ii bw bk ij ik il"/><span class="ii bw bk ij ik"/></div><div class="hb hc hd he hf"><ul class=""><li id="8803" class="jk jl hi io b ip iq it iu ix jm jb jn jf jo jj jp jq jr js bi translated"><strong class="io hj">主分支</strong> : <strong class="io hj">构建，测试</strong>，上传到artifactory，<em class="jt">部署到开发环境，发布测试，部署到测试环境</em></li><li id="cca9" class="jk jl hi io b ip ju it jv ix jw jb jx jf jy jj jp jq jr js bi translated"><strong class="io hj">发布标签</strong>:从artifactory下载构建工件，<em class="jt">部署到生产环境，部署后测试</em></li></ul><p id="858f" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">构建和测试阶段可能有也可能没有驱动它们的环境特定变量。另一方面，“<em class="jt">部署到&lt; env &gt;环境</em>”&amp;“<em class="jt">部署后测试</em>”将有关于您所针对的环境的细节。举个例子。让我们看看如何使用Gitlab CI，以及如何使它成为一个相当好的模块化。</p><p id="8922" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">一个简单的Gitlab yaml可能如下所示(是的，它很长)</p><pre class="jz ka kb kc fd kd ke kf kg aw kh bi"><span id="16a1" class="ki kj hi ke b fi kk kl l km kn">build:<br/>  stage: build<br/>  only:<br/>    - develop<br/>    - master<br/>  script: &lt;build steps&gt;<br/>  artifacts:<br/>    paths:<br/>      - build_artifacts/<br/>      <br/>test:<br/>  stage: test<br/>  only:<br/>    - develop<br/>    - master<br/>  script: &lt;test steps&gt;<br/>   <br/>deploy to sandbox:<br/>  stage: deploy<br/>  only:<br/>    - develop<br/>  script: &lt;deploy steps&gt;<br/>  variables:<br/>    ENVIRONMENT: sbox<br/>    PROFILE: default<br/>      <br/>post deploy tests sandbox: <br/>  stage: post deploy tests<br/>  only:<br/>    - develop<br/>  script: &lt;post deploy test steps&gt;</span><span id="3d4a" class="ki kj hi ke b fi ko kl l km kn">deploy to dev:<br/>  stage: deploy<br/>  only:<br/>    - master<br/>  script: &lt;deploy steps&gt;<br/>  variables:<br/>    ENVIRONMENT: dev<br/>    PROFILE: default<br/>      <br/>post deploy tests dev:<br/>  stage: post deploy tests<br/>  only:<br/>    - master<br/>  script: &lt;post deploy test steps&gt;<br/>  variables:<br/>    ENVIRONMENT: dev<br/>    PROFILE: default</span><span id="718c" class="ki kj hi ke b fi ko kl l km kn">deploy to test:<br/>  stage: deploy<br/>  only:<br/>    - master<br/>  script: &lt;deploy steps&gt;<br/>  variables:<br/>    ENVIRONMENT: test<br/>    PROFILE: default</span><span id="8b32" class="ki kj hi ke b fi ko kl l km kn">upload to artifactory:<br/>  stage: upload to artifactory<br/>  only:<br/>    - master<br/>  script: &lt;upload to rt steps&gt;<br/>  variables:<br/>    ENVIRONMENT: dev<br/>    PROFILE: default</span><span id="fa33" class="ki kj hi ke b fi ko kl l km kn">post deploy tests:<br/>  stage: post deploy tests<br/>  only:<br/>    - master<br/>  script: &lt;deploy steps&gt;<br/>  variables:<br/>    ENVIRONMENT: dev<br/>    PROFILE: default      <br/>      <br/>dl from artifactory:<br/>  stage: deploy<br/>  only:<br/>    - tags<br/>  script: &lt;artifactory download steps&gt;<br/> <br/> deploy to prod:<br/>  stage: deploy<br/>  only:<br/>    - tags<br/>  script: &lt;deploy steps&gt;<br/>  variables:<br/>    ENVIRONMENT: prod<br/>    PROFILE: default<br/>      <br/> post deploy tests prod:<br/>  stage: post deploy tests<br/>  only:<br/>    - tags<br/>  script: &lt;post deploy test steps&gt;<br/>  variables:<br/>    ENVIRONMENT: prod<br/>    PROFILE: default</span></pre><h1 id="dcdd" class="kp kj hi bd kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll bi translated">缺点:</h1><ul class=""><li id="03e3" class="jk jl hi io b ip lm it ln ix lo jb lp jf lq jj jp jq jr js bi translated">《YAML》只有100行，仅包含舞台背景。</li><li id="87ff" class="jk jl hi io b ip ju it jv ix jw jb jx jf jy jj jp jq jr js bi translated">许多可以重复使用的常用参考资料</li><li id="f02a" class="jk jl hi io b ip ju it jv ix jw jb jx jf jy jj jp jq jr js bi translated">如果需要，很难维护和更新。</li><li id="4f5b" class="jk jl hi io b ip ju it jv ix jw jb jx jf jy jj jp jq jr js bi translated">YAML最终可能会被应用程序锁定，尽管并不需要如此。</li></ul><h1 id="ce9b" class="kp kj hi bd kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll bi translated">第一步:</h1><p id="10e5" class="pw-post-body-paragraph im in hi io b ip lm ir is it ln iv iw ix lr iz ja jb ls jd je jf lt jh ji jj hb bi translated">将YAML划分为多个YAML，并使用Gitlab提供的“include”语句。将舞台上聪明的YAML台词移到他们自己的YAML中，并如下引用它们。</p><pre class="jz ka kb kc fd kd ke kf kg aw kh bi"><span id="03f6" class="ki kj hi ke b fi kk kl l km kn">include: '/templates/build.yml'<br/>include: '/templates/test.yml'<br/>include: '/templates/deploy.yml'<br/>include: '/templates/post_deploy_tests.yml'<br/>include: '/templates/artifactory_upload.yml'<br/>include: '/templates/artifactory_download.yml'</span></pre><h1 id="3831" class="kp kj hi bd kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll bi translated">隐藏的工作&amp; YAML主播。</h1><p id="0514" class="pw-post-body-paragraph im in hi io b ip lm ir is it ln iv iw ix lr iz ja jb ls jd je jf lt jh ji jj hb bi translated">一旦阶段被划分到他们自己的YAMLs中，让我们来看看如何减少维护。由于我们已经将阶段关注点分开，它们看起来更容易维护，只需添加或更新一个阶段。</p><p id="a216" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">Gitlab特有的yaml行为之一:</p><ul class=""><li id="572e" class="jk jl hi io b ip iq it iu ix jm jb jn jf jo jj jp jq jr js bi translated">gitlab里任何带“.”的工作默认情况下，它前面是一个隐藏的未执行作业。我们可以将它与“锚”的YAML解析器功能结合使用，带来一些非常需要的可重用性。让我们看看部署阶段(开发、测试和生产)。</li></ul><p id="25f4" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><strong class="io hj">无yaml锚: (移除测试和戳以保持yaml较小)</strong></p><pre class="jz ka kb kc fd kd ke kf kg aw kh bi"><span id="ccd7" class="ki kj hi ke b fi kk kl l km kn">deploy to sandbox:<br/>  stage: deploy<br/>  only:<br/>    - develop<br/>  script: &lt;deploy steps&gt;<br/>  variables:<br/>    ENVIRONMENT: sbox<br/>    PROFILE: default<br/>     <br/>deploy to dev:<br/>  stage: deploy<br/>  only:<br/>    - master<br/>  script: &lt;deploy steps&gt;<br/>  variables:<br/>    ENVIRONMENT: dev<br/>    PROFILE: default</span></pre><p id="af9a" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><strong class="io hj">带yaml锚</strong></p><pre class="jz ka kb kc fd kd ke kf kg aw kh bi"><span id="e2d0" class="ki kj hi ke b fi kk kl l km kn">.deploy_template: &amp;deploy_template<br/>  stage: deploy<br/>  script: &lt;deploy steps&gt;<br/>  artifacts:<br/>    paths:<br/>      - binaries/</span><span id="34a8" class="ki kj hi ke b fi ko kl l km kn">deploy to sandbox:<br/>  &lt;&lt;: *deploy_template<br/>  only:<br/>    - develop<br/>  variables:<br/>    ENVIRONMENT: sbox<br/>    PROFILE: default<br/>     <br/>deploy to dev:<br/>  &lt;&lt;: *deploy_template<br/>  only:<br/>    - master<br/>  variables:<br/>    ENVIRONMENT: dev<br/>    PROFILE: default</span></pre><h1 id="a67b" class="kp kj hi bd kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll bi translated">常见引用和扩展关键字</h1><p id="e78c" class="pw-post-body-paragraph im in hi io b ip lm ir is it ln iv iw ix lr iz ja jb ls jd je jf lt jh ji jj hb bi translated">但这看起来比我们开始的要大。我们刚才是不是走了几步回到这里？</p><p id="a8a6" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">如果你还记得其他的阶段，有跨阶段的公共引用，比如变量，阶段运行的分支。让我们看看如何以模块化的方式使用它们。</p><p id="048b" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">这可以通过两个选项有效地实现:</p><ul class=""><li id="282f" class="jk jl hi io b ip iq it iu ix jm jb jn jf jo jj jp jq jr js bi translated">创建一个单独的yaml来存放公共元素，如变量、分支引用或跨多个阶段使用的任何yaml元素。</li><li id="2904" class="jk jl hi io b ip ju it jv ix jw jb jx jf jy jj jp jq jr js bi translated">在Gitlab CI中使用<strong class="io hj"> extends </strong>关键字。</li></ul><pre class="jz ka kb kc fd kd ke kf kg aw kh bi"><span id="f512" class="ki kj hi ke b fi kk kl l km kn">include: '/templates/build.yml'<br/>include: '/templates/test.yml'<br/>include: '/templates/deploy.yml'<br/>include: '/templates/post_deploy_tests.yml'<br/>include: '/templates/artifactory_upload.yml'<br/>include: '/templates/common.yml'</span></pre><p id="9564" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">“extends”关键字帮助您使用来自另一个yaml的附加元素或引用来扩展作业模板。可以把它想象成Gitlab CI将所有的模板合并在一起，然后重用“.”你做的任何参考中的隐藏工作。</p><p id="25bf" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><strong class="io hj"> Sample common.yml(下面有三个参考..)</strong></p><pre class="jz ka kb kc fd kd ke kf kg aw kh bi"><span id="a26a" class="ki kj hi ke b fi kk kl l km kn">.artifact_template: &amp;artifact_template<br/>  artifacts:<br/>    paths:<br/>      - binaries/<br/>.when_develop: &amp;when_develop<br/>  only:<br/>    - develop<br/> <br/> .variables_sbox: &amp;variables_sbox<br/>  variables:<br/>    ENVIRONMENT: sbox<br/>    PROFILE: default</span></pre><p id="af31" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">重温最初的部署yaml，包括来自common.yml的引用</p><pre class="jz ka kb kc fd kd ke kf kg aw kh bi"><span id="431b" class="ki kj hi ke b fi kk kl l km kn">.deploy_template: &amp;deploy_template<br/>  extends:<br/>    - .artifact_template  <br/>  stage: deploy<br/>  script: &lt;deploy steps&gt;</span><span id="0bf2" class="ki kj hi ke b fi ko kl l km kn">deploy to sandbox:<br/>  extends:<br/>    - .deploy_template<br/>    - .when_develop<br/>    - .variables_sbox<br/>    <br/>deploy to dev:<br/>  extends:<br/>    - .deploy_template<br/>    - .when_develop<br/>    - .variables_dev</span></pre><p id="2c0c" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">这可以通过使用Gitlab的stage yaml 的<strong class="io hj">远程加载来进一步扩展，git lab允许您将这些可重用的模板作为git存储库的一部分，供应用程序团队使用。</strong></p><h1 id="0c59" class="kp kj hi bd kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll bi translated">这种方法的优点:</h1><ul class=""><li id="00ab" class="jk jl hi io b ip lm it ln ix lo jb lp jf lq jj jp jq jr js bi translated">在一个地方定义变量和公共元素，并在任何地方重用它的扩展。</li><li id="75ed" class="jk jl hi io b ip ju it jv ix jw jb jx jf jy jj jp jq jr js bi translated">单独阶段的维护更容易执行。</li><li id="3214" class="jk jl hi io b ip ju it jv ix jw jb jx jf jy jj jp jq jr js bi translated">如果您希望对每个阶段中存在的内容进行集中的管道控制，请实施标准或阶段特定的步骤。</li></ul><ol class=""><li id="395e" class="jk jl hi io b ip iq it iu ix jm jb jn jf jo jj lu jq jr js bi translated">混合远程加载和本地存在的YAML的加载，以使用应用程序的变量引用，同时从中央repo使用stage yamls。</li></ol></div></div>    
</body>
</html>