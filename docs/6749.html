<html>
<head>
<title>Designing and implementing shared safe objects in Multithreading</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">多线程中共享安全对象的设计与实现</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/designing-and-implementing-shared-safe-objects-in-multithreading-f55a03d6abc?source=collection_archive---------3-----------------------#2022-05-02">https://medium.com/nerd-for-tech/designing-and-implementing-shared-safe-objects-in-multithreading-f55a03d6abc?source=collection_archive---------3-----------------------#2022-05-02</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div class="er es if"><img src="../Images/b2afabe004bdbfc10b9d78e903048047.png" data-original-src="https://miro.medium.com/v2/resize:fit:462/format:webp/1*VcLuowptAK0ka-9lPX8dnQ.jpeg"/></div></figure><p id="b515" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">我在读一本关于操作系统设计的书，发现这一部分会有人编写安全的同步代码，但首先我将谈论一些定义，然后谈论实现和最佳实践</p><h1 id="8f5d" class="jk jl hi bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">一、什么是多线程？</h1><p id="c05d" class="pw-post-body-paragraph im in hi io b ip ki ir is it kj iv iw ix kk iz ja jb kl jd je jf km jh ji jj hb bi translated">多线程是一种程序执行模型，允许在一个进程中创建多个线程，独立执行但同时共享进程资源。根据硬件的不同，如果线程被分配到各自的 CPU 内核，它们可以完全并行运行。</p><h1 id="7a95" class="jk jl hi bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">二、什么是共享对象？</h1><p id="8590" class="pw-post-body-paragraph im in hi io b ip ki ir is it kj iv iw ix kk iz ja jb kl jd je jf km jh ji jj hb bi translated">共享对象是可以被多个线程安全访问的对象。程序中的所有共享状态，包括在堆上分配的变量(例如，用<strong class="io hj"> malloc() </strong>或<strong class="io hj"> new() </strong>分配的对象)和静态全局变量，应该封装在一个或多个共享对象中。共享对象扩展了传统的面向对象编程，在面向对象编程中，对象将它们的实现细节隐藏在干净的接口后面。同样，共享对象在干净的接口后面隐藏了同步多个线程的动作的细节。使用共享对象的线程只需要理解接口，它们不需要知道共享对象如何在内部处理同步。就像常规对象一样，共享对象是完全通用的程序员，他们为应用程序需要的任何模块、接口和语义实现共享对象。每个共享对象的类定义了一组线程操作的公共方法。然后，为了从这些共享对象中组装出整个程序，每个线程执行一些“主循环”,这些“主循环”是根据共享对象的公共方法上的动作编写的。</p><h1 id="ae1b" class="jk jl hi bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">设计和实现共享对象</h1><p id="60e4" class="pw-post-body-paragraph im in hi io b ip ki ir is it kj iv iw ix kk iz ja jb kl jd je jf km jh ji jj hb bi translated">尽管多线程编程以困难著称，但共享对象为编写简单、安全的多线程程序代码提供了基础。在本文中，我们首先定义一种设计共享对象的高级方法。然后，我们定义一些具体的规则，你在实现的时候应该遵守。我们的经验是，遵循这种方法和这些规则更有可能使您编写的代码不仅正确，而且易于他人阅读、理解和维护</p><h1 id="a3f4" class="jk jl hi bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">高层设计</h1><p id="e000" class="pw-post-body-paragraph im in hi io b ip ki ir is it kj iv iw ix kk iz ja jb kl jd je jf km jh ji jj hb bi translated">在上面的讨论中，注意到共享对象有公共方法、私有方法、状态变量和同步变量，其中共享对象的同步变量是一个锁和一个或多个条件变量。在这个层次上，共享对象编程基本上类似于标准的面向对象编程，只是我们为每个共享对象添加了同步变量。这种相似性是有意的:同步变量被仔细定义，以便我们可以继续应用熟悉的技术对对象进行编程和推理。与在单线程程序中实现类相比，多线程情况下共享对象所需的新步骤非常简单。</p><p id="e851" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">添加一把锁</p><p id="b2df" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">添加获取和释放锁的代码</p><p id="3cb0" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">识别和添加条件变量</p><p id="0334" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">使用条件变量添加循环等待</p><ul class=""><li id="846c" class="kn ko hi io b ip iq it iu ix kp jb kq jf kr jj ks kt ku kv bi translated">添加信号()和广播()呼叫</li></ul><h2 id="9938" class="kw jl hi bd jm kx ky kz jq la lb lc ju ix ld le jy jb lf lg kc jf lh li kg lj bi translated">1.添加锁</h2><p id="87ac" class="pw-post-body-paragraph im in hi io b ip ki ir is it kj iv iw ix kk iz ja jb kl jd je jf km jh ji jj hb bi translated">为类中的每个对象添加一个锁作为成员变量，以便在访问每个对象的共享状态时强制互斥。注意，在这一章中，我们关注的是每个共享对象只包含一个锁的简单情况。稍后，我们将讨论更高级的变化，如所有权设计模式，其中高级程序结构通过确保一次最多一个线程拥有并可以访问一个对象来强制互斥，以及细粒度锁定，其中单个对象可以将其状态细分为多个部分，每个部分都由自己的锁保护。</p><h2 id="c253" class="kw jl hi bd jm kx ky kz jq la lb lc ju ix ld le jy jb lf lg kc jf lh li kg lj bi translated">2.获取和释放锁</h2><p id="985e" class="pw-post-body-paragraph im in hi io b ip ki ir is it kj iv iw ix kk iz ja jb kl jd je jf km jh ji jj hb bi translated">所有访问由多个线程共享的对象状态的代码都必须持有该对象的锁。通常，对象的所有成员变量都是共享状态。最简单也是最常见的做法是在每个公共方法开始时获取锁，并在每个公共方法结束时释放锁。如果这样做，就很容易检查您的代码，以验证在需要时锁总是被持有。此外，如果您这样做，那么当调用每个私有方法时，锁已经被持有，您不需要重新获取它。</p><h2 id="bf0c" class="kw jl hi bd jm kx ky kz jq la lb lc ju ix ld le jy jb lf lg kc jf lh li kg lj bi translated">3.识别条件变量</h2><p id="bb4c" class="pw-post-body-paragraph im in hi io b ip ki ir is it kj iv iw ix kk iz ja jb kl jd je jf km jh ji jj hb bi translated">我们应该如何决定一个共享对象需要什么条件变量？解决这个问题的一个系统的方法是考虑每一种方法，并问，<strong class="io hj">“这个方法什么时候可以等？”然后，您可以将方法可以等待的每种情况映射到一个条件变量。程序员有相当大的自由来决定一个类应该有多少个条件变量以及每个条件变量应该代表什么。一种选择是添加一个条件变量，对应于对方法的调用必须等待的每种情况——也许为每个可能阻塞的方法创建一个不同的条件变量。</strong></p><h2 id="066e" class="kw jl hi bd jm kx ky kz jq la lb lc ju ix ld le jy jb lf lg kc jf lh li kg lj bi translated">4.使用条件变量等待</h2><p id="b4a7" class="pw-post-body-paragraph im in hi io b ip ki ir is it kj iv iw ix kk iz ja jb kl jd je jf km jh ji jj hb bi translated">添加一个</p><blockquote class="lk"><p id="c55b" class="ll lm hi bd ln lo lp lq lr ls lt jj dx translated">while(…) {cv。等待()}</p></blockquote><p id="aa4e" class="pw-post-body-paragraph im in hi io b ip lu ir is it lv iv iw ix lw iz ja jb lx jd je jf ly jh ji jj hb bi translated">循环进入您刚刚确定为在返回之前可能需要等待的每个方法。请记住，对<strong class="io hj"> Condition::Wait() </strong>的每个调用都必须包含在 while 循环中，该循环测试一个适当的谓词。现代实现几乎总是强制执行 Hansen 语义，并且经常允许虚假的唤醒(一个线程可以从<strong class="io hj"> Wait() </strong>返回，即使没有线程调用<strong class="io hj"> Signal() </strong>或<strong class="io hj"> Broadcast() </strong>)。因此，线程在继续执行之前必须始终检查条件，即使在发生<strong class="io hj"> Signal() </strong>或<strong class="io hj"> Broadcast() </strong>调用时条件为真，当等待线程恢复执行时，条件可能不再为真。</p><h2 id="7b11" class="kw jl hi bd jm kx ky kz jq la lb lc ju ix ld le jy jb lf lg kc jf lh li kg lj bi translated">5.信号()和广播()呼叫</h2><p id="091e" class="pw-post-body-paragraph im in hi io b ip ki ir is it kj iv iw ix kk iz ja jb kl jd je jf km jh ji jj hb bi translated">正如您必须决定方法何时可以等待一样，您也必须决定方法何时可以让其他等待的线程继续进行。通常很容易问“对这个方法的调用能允许另一个线程继续吗？”然后如果答案为是，则添加一个信号()或<strong class="io hj">广播()</strong>呼叫。但是你应该使用哪个调用呢？<strong class="io hj">信号()</strong>适用于:</p><ul class=""><li id="b8fe" class="kn ko hi io b ip iq it iu ix kp jb kq jf kr jj ks kt ku kv bi translated">最多一个等待线程可以取得进展</li><li id="3ca1" class="kn ko hi io b ip lz it ma ix mb jb mc jf md jj ks kt ku kv bi translated">等待条件变量的任何线程都可以取得进展。</li></ul><p id="9175" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">相反，在以下情况下需要<strong class="io hj">广播()</strong></p><ul class=""><li id="2523" class="kn ko hi io b ip iq it iu ix kp jb kq jf kr jj ks kt ku kv bi translated">多个等待线程可能都能够取得进展</li><li id="a540" class="kn ko hi io b ip lz it ma ix mb jb mc jf md jj ks kt ku kv bi translated">不同的线程使用相同的条件</li><li id="0d81" class="kn ko hi io b ip lz it ma ix mb jb mc jf md jj ks kt ku kv bi translated">变量来等待不同的谓词，因此一些等待的线程可以取得进展，而另一些则不能。</li></ul><h1 id="f0c5" class="jk jl hi bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">实施最佳实践:</h1><p id="879f" class="pw-post-body-paragraph im in hi io b ip ki ir is it kj iv iw ix kk iz ja jb kl jd je jf km jh ji jj hb bi translated">用共享对象编写简单、安全的代码上面我们描述了在共享对象中包含和使用锁和条件变量的基本思路。更具体地说，这一节描述了五个简单的规则，我们强烈建议将它们作为编写共享对象代码的一组最佳实践。结构一致。这些规则的核心是一个简单的原则:遵循一致的结构。这是一个元规则，是其他规则的基础。尽管使用清晰、一致的结构进行编程总是有用的，但是对于共享对象来说，严格遵循可靠的设计模式尤为重要。</p><p id="2268" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><strong class="io hj">五大法则</strong>。这五条规则旨在帮助您避免我们在学生和有经验的程序员的多线程代码中看到的常见陷阱。</p><h2 id="e332" class="kw jl hi bd jm kx ky kz jq la lb lc ju ix ld le jy jb lf lg kc jf lh li kg lj bi translated">1.总是与锁和条件变量同步。</h2><p id="467f" class="pw-post-body-paragraph im in hi io b ip ki ir is it kj iv iw ix kk iz ja jb kl jd je jf km jh ji jj hb bi translated">锁和条件变量或信号量都可以用来实现共享对象。我们建议您能够阅读和理解信号量，这样您就可以理解遗留代码，但是您只能使用锁和条件变量来编写新代码。99%的带有锁和条件变量的代码比同等的信号量代码更清晰，因为它更加“自文档化”。如果代码结构良好，通常每个同步动作都很清楚。诚然，有时信号量似乎非常适合您正在做的事情，因为您可以将对象的不变量精确地映射到信号量的内部状态，例如，您可以使用信号量编写一个极其简洁的阻塞有界队列版本，但是如果下个月代码有一点变化，会发生什么情况呢？合身吗？为了一致性和简单性，您应该选择两种风格中的一种并坚持使用，在我们看来，正确的选择是使用锁和条件变量。</p><h2 id="01e3" class="kw jl hi bd jm kx ky kz jq la lb lc ju ix ld le jy jb lf lg kc jf lh li kg lj bi translated">2.总是在方法开始时获取锁，然后释放</h2><p id="dec8" class="pw-post-body-paragraph im in hi io b ip ki ir is it kj iv iw ix kk iz ja jb kl jd je jf km jh ji jj hb bi translated">就在回归之前，这主要是一致结构原则的延伸:选择一种做事方式，并始终遵循它。这样做的好处是可以很容易地阅读代码，了解哪里有锁，哪里没有，因为同步是基于一个方法一个方法地构造的。相反，如果 Lock::Acquire()和 Lock::Release()调用隐藏在一个方法的中间，则很难快速检查和理解代码。退一步说，如果有一个逻辑代码块，您可以将其识别为一组需要锁的操作，那么该部分可能应该是它自己的过程，它是一组逻辑上相关的操作。如果你发现自己想在一个过程中抓住一个锁，这通常是一个危险信号，你应该把你正在考虑的部分分解成一个单独的过程。当我们应该创造新程序的时候，我们有时都很懒。利用这个信号，你会写出更清晰的代码。</p><h2 id="9b70" class="kw jl hi bd jm kx ky kz jq la lb lc ju ix ld le jy jb lf lg kc jf lh li kg lj bi translated">3.对条件变量进行操作时，请始终保持锁定状态。</h2><p id="3a1a" class="pw-post-body-paragraph im in hi io b ip ki ir is it kj iv iw ix kk iz ja jb kl jd je jf km jh ji jj hb bi translated">您在条件变量上发出信号的原因是，您刚刚完成了对共享状态的操作——其他一些线程正在循环中等待对共享状态的一些测试变为真。条件变量在没有共享状态的情况下是没有用的，只有在持有锁的情况下才能访问共享状态。许多库执行这个规则——除非持有相应的锁，否则不能调用任何条件变量方法。但是一些运行时系统和库允许马虎，所以要小心。</p><h2 id="d098" class="kw jl hi bd jm kx ky kz jq la lb lc ju ix ld le jy jb lf lg kc jf lh li kg lj bi translated">4.总是在 while()循环中等待</h2><p id="7f94" class="pw-post-body-paragraph im in hi io b ip ki ir is it kj iv iw ix kk iz ja jb kl jd je jf km jh ji jj hb bi translated">模式总是</p><blockquote class="lk"><p id="7253" class="ll lm hi bd ln lo lp lq lr ls lt jj dx translated">while(cond(…)){条件→等待(&amp; lock)；}</p></blockquote><p id="1aea" class="pw-post-body-paragraph im in hi io b ip lu ir is it lv iv iw ix lw iz ja jb lx jd je jf ly jh ji jj hb bi translated">从不</p><blockquote class="lk"><p id="84a6" class="ll lm hi bd ln lo lp lq lr ls lt jj dx translated">if(cond(…)){ condition→Wait(&amp; lock)；}</p></blockquote><p id="dd12" class="pw-post-body-paragraph im in hi io b ip lu ir is it lv iv iw ix lw iz ja jb lx jd je jf ly jh ji jj hb bi translated">这里，<strong class="io hj"> cond(…) </strong>是查看当前对象的状态变量以决定是否可以继续的代码。当人们确切地知道什么线程正在采取什么动作，并且人们可以从程序的全局结构中推断出，不管 Hansen 语义如何，任何时候线程从<strong class="io hj"> wait() </strong>返回，它都可以继续进行时，人们有时会试图用 if 条件而不是 while 循环来保护<strong class="io hj"> wait() </strong>调用。避免这种诱惑。While 在任何时候都有效，在无效的情况下也有效。根据结构一致的原则，你每次都应该以同样的方式做事。但是还有另外三个问题。首先，如果打破模块化。在上面的例子中，我们需要考虑程序的全局结构——有哪些线程，在哪里调用了<strong class="io hj"> signal() </strong>等等，以确定是否可以工作。问题是，一个方法中代码的变化(比如说，添加一个<strong class="io hj">信号()</strong>)会导致另一个方法中的错误(这里是<strong class="io hj"> wait() </strong>)。虽然代码也是自文档化的——人们可以查看<strong class="io hj"> wait() </strong>并确切地了解线程何时可以继续。第二，当你总是使用 while 时，你会在放置<strong class="io hj">信号()的地方获得难以置信的自由。</strong>事实上，<strong class="io hj"> signal() </strong>变成了一个提示，你可以在一个正确的程序的任意位置添加更多的信号，它仍然是一个正确的程序。第三，它打破了便携性。条件变量的一些实现可能允许虚假唤醒，其中<strong class="io hj"> wait() </strong>返回，即使没有线程被调用<strong class="io hj"> signal() </strong>或<strong class="io hj"> broadcast()。</strong></p><h2 id="752b" class="kw jl hi bd jm kx ky kz jq la lb lc ju ix ld le jy jb lf lg kc jf lh li kg lj bi translated">5.(几乎)从不睡觉()。</h2><p id="98d5" class="pw-post-body-paragraph im in hi io b ip ki ir is it kj iv iw ix kk iz ja jb kl jd je jf km jh ji jj hb bi translated">许多线程库都有一个 sleep()函数，该函数将调用线程的执行挂起一段时间。一旦这段时间过去，线程就被返回到调度程序的就绪队列，并可以再次运行。永远不要使用<strong class="io hj"> sleep() </strong>让一个线程等待另一个线程做某事。等待条件变为真的正确方法是对条件变量执行<strong class="io hj"> wait() </strong>一般来说，<strong class="io hj"> sleep() </strong>只有在你想执行某个动作的特定实时时刻才是合适的。如果你发现自己在写</p><blockquote class="lk"><p id="9aaf" class="ll lm hi bd ln lo lp lq lr ls lt jj dx translated">while(testOnObjectState(){ sleep()；}</p></blockquote><p id="1851" class="pw-post-body-paragraph im in hi io b ip lu ir is it lv iv iw ix lw iz ja jb lx jd je jf ly jh ji jj hb bi translated">把这当作一个大的危险信号，你可能正在犯一个错误。同样，如果一个线程需要等待一个对象的状态改变，它应该等待一个条件变量，而不仅仅是调用<strong class="io hj"> yield()。</strong>相反，<strong class="io hj"> yield() </strong>是合适的，当一个可以取得进展的低优先级线程让出处理器，让更高优先级的线程运行。</p><h1 id="7081" class="jk jl hi bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">摘要</h1><p id="39f9" class="pw-post-body-paragraph im in hi io b ip ki ir is it kj iv iw ix kk iz ja jb kl jd je jf km jh ji jj hb bi translated">多线程编程是一个很大的话题，背后有很多的概念，但是在本文的最后，我会放一些有助于获得更多知识的资源，我们可以改天再讨论这些资源</p><ul class=""><li id="dac8" class="kn ko hi io b ip iq it iu ix kp jb kq jf kr jj ks kt ku kv bi translated"><a class="ae me" href="https://applied-programming.github.io/Operating-Systems-Notes/" rel="noopener ugc nofollow" target="_blank">操作系统注释</a></li><li id="3086" class="kn ko hi io b ip lz it ma ix mb jb mc jf md jj ks kt ku kv bi translated"><a class="ae me" href="https://www.amazon.com/Operating-Systems-Principles-Thomas-Anderson/dp/0985673524" rel="noopener ugc nofollow" target="_blank">操作系统原理</a></li></ul></div></div>    
</body>
</html>