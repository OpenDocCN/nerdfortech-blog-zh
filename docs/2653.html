<html>
<head>
<title>Safe Retrofit calls extension with kotlin Coroutines for Android in 2021 — Part I</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">2021年Android安全改造调用kotlin协同程序扩展—第一部分</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/safe-retrofit-calls-extension-with-kotlin-coroutines-for-android-in-2021-part-i-d47e9e2962ad?source=collection_archive---------3-----------------------#2021-05-15">https://medium.com/nerd-for-tech/safe-retrofit-calls-extension-with-kotlin-coroutines-for-android-in-2021-part-i-d47e9e2962ad?source=collection_archive---------3-----------------------#2021-05-15</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/09009555fe6b4edbfcba051efa70e842.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*SiY7zaIcI99Uow6v"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">照片由<a class="ae iu" href="https://unsplash.com/@ffstop?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Fotis Fotopoulos </a>在<a class="ae iu" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="1c22" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">你好👋，今天我将教你如何以一种安全和kotlin惯用的方式执行网络呼叫。在这个小系列的结尾，您可能会看到这样的内容:</p><figure class="jt ju jv jw fd ij"><div class="bz dy l di"><div class="jx jy l"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">从数据层到领域层和表示层，这里有一个清晰的架构结构。</figcaption></figure><p id="09a0" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">以上要点是向您展示如何在您的ViewModel / Presenter/ etc中执行改造呼叫并处理失败或成功的结果。<br/>如果你不明白要点的内容，不要担心，我会一步一步地做一个非常简单但具体的解释。</p><p id="7483" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如果你想直接看代码，看看我做的这个关于电影的游乐场项目。</p><div class="jz ka ez fb kb kc"><a href="https://github.com/ChristopherME/movies-android" rel="noopener  ugc nofollow" target="_blank"><div class="kd ab dw"><div class="ke ab kf cl cj kg"><h2 class="bd hj fi z dy kh ea eb ki ed ef hh bi translated">Christopher me/电影-android</h2><div class="kj l"><h3 class="bd b fi z dy kh ea eb ki ed ef dx translated">Movies是一个简单的项目，可以学习和使用一些android组件、架构和Android工具…</h3></div><div class="kk l"><p class="bd b fp z dy kh ea eb ki ed ef dx translated">github.com</p></div></div><div class="kl l"><div class="km l kn ko kp kl kq io kc"/></div></div></a></div><h1 id="a555" class="kr ks hi bd kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo bi translated">有什么问题？</h1><p id="6462" class="pw-post-body-paragraph iv iw hi ix b iy lp ja jb jc lq je jf jg lr ji jj jk ls jm jn jo lt jq jr js hb bi translated">首先，为什么需要协程来执行网络调用(使用retrofit或任何其他HTTP客户端)？我的朋友，正如你已经知道的(或者可能不知道),当你启动你的android应用程序时，它会创建一个新的Linux进程，只有一个线程(主线程或者UI线程，如果你愿意的话)。这个线程负责绘制视图组件、小部件等。与UI相关的一切。完全禁止在这个线程上做其他事情，因为应用程序可能会崩溃。查看官方<a class="ae iu" href="https://developer.android.com/guide/components/processes-and-threads#Threads" rel="noopener ugc nofollow" target="_blank">文档</a>了解更多详细信息。</p><p id="9ec7" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">现在我们知道，我们不允许在UI线程上执行繁重的任务，如网络调用、数据库操作、读/写文件，因为它会变慢，我们可能会遇到<a class="ae iu" href="https://developer.android.com/training/articles/perf-anr#anr" rel="noopener ugc nofollow" target="_blank"> ANR </a>异常，我们的应用程序会崩溃。</p><h1 id="e5c7" class="kr ks hi bd kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo bi translated">有什么解决办法吗？</h1><p id="443a" class="pw-post-body-paragraph iv iw hi ix b iy lp ja jb jc lq je jf jg lr ji jj jk ls jm jn jo lt jq jr js hb bi translated">在旧的android编码时代，人们习惯于创建自己的线程池，并自己管理线程的创建和维护🤯！相信我，孩子，这不是你想做的事。其他解决方案暗示<a class="ae iu" href="https://developer.android.com/reference/android/os/AsyncTask" rel="noopener ugc nofollow" target="_blank"> AsyncTasks </a>不太灵活，现在已被弃用。那些真实的虽然岁月。我对那些开发android应用程序的开发者表示敬意。</p><p id="4891" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">然后，作为一个不断演变的平台，挑战和克服这些挑战的方法需要新的和更灵活的方法。那时RxJava是Android应用程序的新救世主。RxJava对于异步任务来说是一个很好的解决方案，但是它也有自己的缺陷:</p><ul class=""><li id="1194" class="lu lv hi ix b iy iz jc jd jg lw jk lx jo ly js lz ma mb mc bi translated">漫长的学习过程。第一次理解起来并不容易，因为你必须将你的思维模式转变为一种反应式编程，有很多操作符和马贝尔图😵。</li><li id="2c56" class="lu lv hi ix b iy md jc me jg mf jk mg jo mh js lz ma mb mc bi translated">它给你最终的APK尺寸增加了2MB以上</li><li id="b9c1" class="lu lv hi ix b iy md jc me jg mf jk mg jo mh js lz ma mb mc bi translated">这就像用火箭筒打死一只虫子。您可能不会使用该库中50%的实用程序，而只会将它用于一个问题，即异步任务。</li></ul><h1 id="1af5" class="kr ks hi bd kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo bi translated">救援协管员</h1><p id="c1de" class="pw-post-body-paragraph iv iw hi ix b iy lp ja jb jc lq je jf jg lr ji jj jk ls jm jn jo lt jq jr js hb bi translated">2017年，谷歌正式将Kotlin用于Android开发，此后事情发展得非常快。他们在该语言的1.1版本中为异步任务提供了一个集成的解决方案，即著名的协程。对于那些用Kotlin编码的人来说，这是一个开箱即用的解决方案！</p><blockquote class="mi mj mk"><p id="b5a4" class="iv iw ml ix b iy iz ja jb jc jd je jf mm jh ji jj mn jl jm jn mo jp jq jr js hb bi translated"><em class="hi">协程</em>是可挂起计算的一个实例。它在概念上类似于一个线程，因为它需要一个代码块与其余代码同时运行。然而，协程并不绑定到任何特定的线程。它可以在一个线程中暂停执行，然后在另一个线程中继续执行。</p><p id="a6b9" class="iv iw ml ix b iy iz ja jb jc jd je jf mm jh ji jj mn jl jm jn mo jp jq jr js hb bi translated">协程可以被认为是轻量级的线程，但是有许多重要的区别使得它们在现实生活中的用法与线程非常不同。</p><p id="d2ff" class="iv iw ml ix b iy iz ja jb jc jd je jf mm jh ji jj mn jl jm jn mo jp jq jr js hb bi translated"><a class="ae iu" href="https://kotlinlang.org/docs/coroutines-basics.html#your-first-coroutine" rel="noopener ugc nofollow" target="_blank">科特林文件</a></p></blockquote></div><div class="ab cl mp mq gp mr" role="separator"><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu"/></div><div class="hb hc hd he hf"><h1 id="44cb" class="kr ks hi bd kt ku mw kw kx ky mx la lb lc my le lf lg mz li lj lk na lm ln lo bi translated">让我们一起把它包起来</h1><p id="461f" class="pw-post-body-paragraph iv iw hi ix b iy lp ja jb jc lq je jf jg lr ji jj jk ls jm jn jo lt jq jr js hb bi translated">为了安全地执行网络呼叫，我们需要做以下事情:</p><ul class=""><li id="166c" class="lu lv hi ix b iy iz jc jd jg lw jk lx jo ly js lz ma mb mc bi translated"><strong class="ix hj">确保它没有在主线程</strong>中执行——协程<a class="ae iu" href="https://developer.android.com/kotlin/coroutines/coroutines-adv?hl=es-419" rel="noopener ugc nofollow" target="_blank">调度程序</a>将成为我们这里的工具。</li><li id="99cb" class="lu lv hi ix b iy md jc me jg mf jk mg jo mh js lz ma mb mc bi translated">我们可能还需要<strong class="ix hj">解析一些后端错误响应</strong>——我们将使用<a class="ae iu" href="https://github.com/square/moshi" rel="noopener ugc nofollow" target="_blank"> Moshi </a>解析JSON。</li><li id="3f91" class="lu lv hi ix b iy md jc me jg mf jk mg jo mh js lz ma mb mc bi translated">如果我们愿意，我们可以添加某种中间件功能，以便<strong class="ix hj">仅在所有这些中间件都满足条件的情况下执行我们的网络调用</strong>。—这是可选的。</li></ul><p id="1d7c" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们得到了对网络调用扩展包装器的要求，但是还有一个问题悬而未决……如何用协程处理异常🤔？</p><p id="a69b" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">使用<code class="du nb nc nd ne b">try catch</code>块非常直接地处理异常。看看这篇来自<a class="nf ng ge" href="https://medium.com/u/3b5622dd813c?source=post_page-----d47e9e2962ad--------------------------------" rel="noopener" target="_blank"> Manuel Vivo </a>的<a class="ae iu" rel="noopener" href="/androiddevelopers/exceptions-in-coroutines-ce8da1ec060c">博客</a>谈论它。事实上，我们还将使用一个try catch块来处理我们的异常🤫但是，我们不会通过应用程序的各个层传递异常。</p><p id="7fd5" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">相反，我们将传递包装在awsome " <a class="ae iu" href="https://github.com/ChristopherME/movies-android/blob/master/functional-programming/src/main/java/com/christopher_elias/functional_programming/Either.kt" rel="noopener ugc nofollow" target="_blank">要么</a>"类中的自定义<a class="ae iu" href="https://github.com/ChristopherME/movies-android/blob/master/functional-programming/src/main/java/com/christopher_elias/functional_programming/Failure.kt" rel="noopener ugc nofollow" target="_blank">故障</a>(您甚至可以在google示例中找到类似的实现，就像这个<a class="ae iu" href="https://github.com/google/iosched/blob/main/shared/src/main/java/com/google/samples/apps/iosched/shared/result/Result.kt" rel="noopener ugc nofollow" target="_blank">结果</a>密封类)。</p><p id="404b" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这两个类都是一个密封的类，在给定的时间里可以是一个错误或成功的对象。它还包含一些我实现的额外方法，用于基于<a class="ae iu" href="https://github.com/arrow-kt/arrow" rel="noopener ugc nofollow" target="_blank">箭头</a>函数编程库执行某种映射操作。这两种课都不是什么新鲜事，我是在阅读费尔南多·切哈斯的这篇令人惊叹的文章时发现的。</p><p id="d203" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如果你不知道什么是密封类，看看弗洛里纳·芒特内斯库的视频</p><figure class="jt ju jv jw fd ij"><div class="bz dy l di"><div class="nh jy l"/></div></figure><p id="3ed8" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们已经建立了基础，该编码了。查看第2部分👉<a class="ae iu" href="https://christopher-elias.medium.com/safe-retrofit-calls-extension-with-kotlin-coroutines-for-android-in-2021-part-ii-fd55842951cf" rel="noopener">此处</a>。</p></div></div>    
</body>
</html>