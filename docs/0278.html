<html>
<head>
<title>Production logging feature enhancements atop Jersey/JAX-RS</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">新泽西/JAX-RS顶部的生产测井功能增强</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/production-logging-feature-enhancements-atop-jersey-and-jax-rs-991127a36c88?source=collection_archive---------0-----------------------#2020-09-05">https://medium.com/nerd-for-tech/production-logging-feature-enhancements-atop-jersey-and-jax-rs-991127a36c88?source=collection_archive---------0-----------------------#2020-09-05</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="5572" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">以及如何在生产中的重要用例中充分利用它们</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es jd"><img src="../Images/a6991ac065987ced78e8aaabc5ef04cc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*itc0HjvTh2JT-LsN.jpg"/></div></div><figcaption class="jp jq et er es jr js bd b be z dx translated">即将旋转和倾倒的圆木</figcaption></figure><p id="02e3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">日志</strong>是在生产环境中运行的任何重要应用程序的生命线。任何在工作场所随叫随到的人都可以证实，当事情在凌晨3点变糟时，正确的应用程序日志记录的重要性。</p><p id="f2af" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">对于构建在JAX-RS框架之上的应用程序来说，解决方案通常是向环境注册。<em class="jy">这在客户端和服务器端都有效。</em></p><pre class="je jf jg jh fd jz jw ka kb aw kc bi"><span id="899b" class="kd ke hi jw b fi kf kg l kh ki">environment.jersey().register(<br/>  new LoggingFeature(<br/>     Logger.getLogger(LoggingFeature.DEFAULT_LOGGER_NAME),<br/>     Level.INFO,<br/>     LoggingFeature.Verbosity.PAYLOAD_ANY, <br/>     1000<br/>   )<br/>);</span></pre><p id="eebf" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">通过这个简单的注册，您可以立即在服务器上看到请求<code class="du jt ju jv jw b">&gt;</code>和响应<code class="du jt ju jv jw b">&lt;</code>日志。中间是应用程序日志(如果有的话)</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es kj"><img src="../Images/4b4ff44f1748c7b28de44d9f973d53e9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Iteor8B3cks8pY4Zipc9hw.png"/></div></div></figure><p id="374f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我承认，这在开始时非常简洁和方便。但是，也有一些问题。</p><ul class=""><li id="5a21" class="kk kl hi ih b ii ij im in iq km iu kn iy ko jc kp kq kr ks bi translated"><strong class="ih hj">每个请求和响应都会被记录。无论使用何种情况。</strong> <br/>以监控为目的的请求，比如健康检查或其他清理API，会得到与其他潜在业务关键请求相同的处理。我们无法控制我们想要实际查看日志的请求。</li><li id="75cc" class="kk kl hi ih b ii kt im ku iq kv iu kw iy kx jc kp kq kr ks bi translated"><strong class="ih hj">无法只记录失败的请求，比如用4xx / 5xx </strong> <br/>检查<code class="du jt ju jv jw b"><a class="ae jx" href="https://github.com/jersey/jersey/blob/faa809da43538ce31076b50f969b4bd64caa5ac9/core-common/src/main/java/org/glassfish/jersey/logging/ServerLoggingFilter.java#L112" rel="noopener ugc nofollow" target="_blank">Logging Filter</a></code>的源代码来解释原因。在<code class="du jt ju jv jw b"><a class="ae jx" href="https://www.baeldung.com/jersey-filters-interceptors" rel="noopener ugc nofollow" target="_blank">Jersey request lifecycle</a></code>中，在服务实际<em class="jy">请求</em>和处理<em class="jy">响应</em>之前，执行<em class="jy">过滤器</em>。因此，不管结果如何，<em class="jy">请求</em>日志记录肯定会发生。</li></ul><blockquote class="ky kz la"><p id="c834" class="if ig jy ih b ii ij ik il im in io ip lb ir is it lc iv iw ix ld iz ja jb jc hb bi translated">这种影响至少是双重的。</p></blockquote><ul class=""><li id="261b" class="kk kl hi ih b ii ij im in iq km iu kn iy ko jc kp kq kr ks bi translated"><strong class="ih hj">日志文件以更快的速度填充和循环</strong> <br/>因为所有请求都被记录，所以对于生成的日志量几乎没有什么可做的。是<code class="du jt ju jv jw b">O(N)</code>，其中<code class="du jt ju jv jw b">N</code>是请求的数量。实际上，我们希望这是<code class="du jt ju jv jw b">O(K)</code>，其中<code class="du jt ju jv jw b">K</code>是我们感兴趣的请求数量(值得记录)和<code class="du jt ju jv jw b">K &lt; N</code></li><li id="7f48" class="kk kl hi ih b ii kt im ku iq kv iu kw iy kx jc kp kq kr ks bi translated"><strong class="ih hj">日志文件包含大多数不可操作的请求</strong> <br/>通常我们想要调试失败的请求。由于成功的请求(<code class="du jt ju jv jw b">2xx</code>)和失败的请求之间没有区别，我们通常以失败的响应告终。这再加上更快的轮换意味着，对于高QPS服务，我们有很多事情要做。</li></ul><p id="5db3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们在生产应用程序中遇到了同样的问题。他们中的一些人一直在击打<code class="du jt ju jv jw b">600 QPS</code>，错误率为<code class="du jt ju jv jw b">0.01%</code>，原木以相当高的速度旋转。</p><p id="2fc5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们想独立解决这两个问题。<em class="jy">我们的第一个目标是在请求级别过滤日志。</em></p><p id="7a30" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们深入研究了这些过滤器的Jersey实现。我们在扩展这些类时遇到了一些问题。可能是因为它们是内部的，而不是用来扩展的。但是我们的用例需要它。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es le"><img src="../Images/61431075f1f053b2b743a9b7482e7df8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lO9FY2nfj9YBCjbHwOtnUA.png"/></div></div><figcaption class="jp jq et er es jr js bd b be z dx translated">为什么你是最后一名？:/ Hmph:</figcaption></figure></div><div class="ab cl lf lg gp lh" role="separator"><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk"/></div><div class="hb hc hd he hf"><h2 id="a9e4" class="kd ke hi bd lm ln lo lp lq lr ls lt lu iq lv lw lx iu ly lz ma iy mb mc md me bi translated"><strong class="ak">列入白名单的服务器日志过滤器</strong></h2><p id="dc0e" class="pw-post-body-paragraph if ig hi ih b ii mf ik il im mg io ip iq mh is it iu mi iw ix iy mj ja jb jc hb bi translated">为了解决第一个问题，我们采用了Jersey实现，并创建了一个实现必要过滤器的类。逻辑很简单。</p><ul class=""><li id="4167" class="kk kl hi ih b ii ij im in iq km iu kn iy ko jc kp kq kr ks bi translated">维护一套你感兴趣的<em class="jy">资源URI路径</em>。</li><li id="c111" class="kk kl hi ih b ii kt im ku iq kv iu kw iy kx jc kp kq kr ks bi translated">为请求和响应主体重写<code class="du jt ju jv jw b">filter</code>方法。检查请求URI上下文是否与我们的任何合格请求相匹配。如果是，<strong class="ih hj"> <em class="jy"> log it </em> </strong>否则做<strong class="ih hj"> <em class="jy"> nothing </em> </strong>。</li></ul><p id="a5c5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这个开销是<code class="du jt ju jv jw b">O(K) * O(1)</code>在<code class="du jt ju jv jw b">K</code> URIs必须被一个集合匹配支持。对于我们在日志记录上节省的磁盘空间来说，这是一个很好的权衡。</p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="mk ml l"/></div></figure><p id="1982" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这种记录器的变体现在可以安装在服务中，以排除某些具有重负载的请求。</p><pre class="je jf jg jh fd jz jw ka kb aw kc bi"><span id="5d0d" class="kd ke hi jw b fi kf kg l kh ki">Set&lt;String&gt; excludedPaths = ImmutableSet.of(...);</span><span id="40d2" class="kd ke hi jw b fi mm kg l kh ki">environment.jersey()<br/>  .register(new WhitelistedServerLoggingFilter(excludedPaths));</span></pre></div><div class="ab cl lf lg gp lh" role="separator"><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk"/></div><div class="hb hc hd he hf"><h2 id="6d04" class="kd ke hi bd lm ln lo lp lq lr ls lt lu iq lv lw lx iu ly lz ma iy mb mc md me bi translated">延迟请求响应日志过滤器</h2><p id="2fe9" class="pw-post-body-paragraph if ig hi ih b ii mf ik il im mg io ip iq mh is it iu mi iw ix iy mj ja jb jc hb bi translated">解决第二个问题(只记录响应失败或满足特定条件的请求)需要一点思考。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es mn"><img src="../Images/70e5a725efbf432067e03761fa28476f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kHieeI-6K-FQH6kTg--Z-Q.png"/></div></div><figcaption class="jp jq et er es jr js bd b be z dx translated">服务器请求响应处理生命周期</figcaption></figure><p id="fbe0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为了理解这一点，我们需要理解请求在Jersey世界中的生命周期。</p><p id="39d6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">请求记录在<code class="du jt ju jv jw b">ContainerRequestFilter</code>层中，此时响应还不可用。</p><p id="28ef" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">既然没有办法“<strong class="ih hj"> unlog </strong>”一个已记录的请求，我们需要找到一个更好的方法。更好的方法是将请求日志延迟到响应可用的最后。</p><p id="d52c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们可以确定的一件事是，所有主要的框架都遵循每个请求一个线程的模型。这意味着有一个专门的工作线程被分派来处理传入的请求。</p><p id="7606" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们可以利用这一点。什么是可用于存储线程本地属性的数据结构？</p><p id="f317" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">你猜对了。这是一个<a class="ae jx" href="https://docs.oracle.com/javase/8/docs/api/java/lang/ThreadLocal.html" rel="noopener ugc nofollow" target="_blank"> <strong class="ih hj">线程本地</strong> </a> <strong class="ih hj">。</strong>我们可以在请求线程的本地设置请求日志。一旦我们稍后得到了响应，我们就将一个<em class="jy">用户定义的谓词</em>与响应代码进行匹配。</p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="mk ml l"/></div></figure><p id="f342" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果测试通过，<em class="jy">请求和响应都被记录</em>。如果不是，<em class="jy">两者都被丢弃</em>。这可以根据需要进行配置和增强。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es mo"><img src="../Images/197ef8baf74b2a212f9d8d4b409a7961.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*x5Bmxj4mMtQariHRGg2zaA.png"/></div></div><figcaption class="jp jq et er es jr js bd b be z dx translated">延迟记录器的蓝图</figcaption></figure><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="mk ml l"/></div></figure><p id="4738" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">这个简单的变奏以空间换空间</strong>。由于只针对我们想要的响应谓词生成日志，我们节省了大量不必要的磁盘使用。但是我们也通过在每个线程缓存请求日志来占用内存。</p><p id="7b4a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在我们的情况下，这种权衡也是值得的。我们的应用程序只记录我们需要的内容。将响应谓词设置为<code class="du jt ju jv jw b">{4xx, 5xx} — {404}</code>有助于我们实现可调试性和磁盘使用的目标。</p><h2 id="c574" class="kd ke hi bd lm ln lo lp lq lr ls lt lu iq lv lw lx iu ly lz ma iy mb mc md me bi translated">逮到你了</h2><ul class=""><li id="9110" class="kk kl hi ih b ii mf im mg iq mp iu mq iy mr jc kp kq kr ks bi translated">敏锐的读者可能已经注意到，由于请求日志记录被延迟，应用程序日志在实际日志之前被写入磁盘，因此妨碍了事件的顺序。</li><li id="4957" class="kk kl hi ih b ii kt im ku iq kv iu kw iy kx jc kp kq kr ks bi translated">我们只是延迟了请求日志，应用程序日志<code class="du jt ju jv jw b">log.info({})</code>将会以通常的速度继续。这对我们来说根本不是问题。可能是给你的。</li><li id="5f7e" class="kk kl hi ih b ii kt im ku iq kv iu kw iy kx jc kp kq kr ks bi translated">需要小心地取消线程的本地设置，并使对象符合垃圾收集的条件。对于非常高的QPS，额外的内存可能是一个问题。但是他们可能不需要这种级别的日志记录。</li></ul><p id="0ffa" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">总而言之，这些增强帮助我们在高QPS下维护我们的生产服务，在可调试性和日志轮换之间取得了充分的平衡。对于客户端的增强，我们也跟着做了。</p><p id="5404" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我已经开源了<a class="ae jx" href="https://github.com/isopropylcyanide/jersey-log-utils" rel="noopener ugc nofollow" target="_blank">组件</a>发布了一个<a class="ae jx" href="https://mvnrepository.com/artifact/com.github.isopropylcyanide/jersey-log-utils" rel="noopener ugc nofollow" target="_blank">包</a>给Maven Central。将这些实用程序集成到应用程序中非常简单。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es ms"><img src="../Images/90d73032fdd58c6d345d1b0736a9dd81.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FIFdZTmWp_u6kRJgPeVjgQ.png"/></div></div></figure><p id="c48c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">希望你学到了新东西。请随时留下一些可以进一步改进的意见。随时欢迎投稿。</p></div></div>    
</body>
</html>