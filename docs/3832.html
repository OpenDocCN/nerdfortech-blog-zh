<html>
<head>
<title>Factory Constructor in Dart — Part 2</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Dart中的工厂构造器—第2部分</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/factory-constructor-in-dart-part-2-7db2a5981ac3?source=collection_archive---------1-----------------------#2021-06-26">https://medium.com/nerd-for-tech/factory-constructor-in-dart-part-2-7db2a5981ac3?source=collection_archive---------1-----------------------#2021-06-26</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="07b5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在<a class="ae jd" href="https://imsaravananm.medium.com/factory-constructor-in-dart-part-1-1bbdf0d0f7f0" rel="noopener">上一篇文章</a>中，我们已经讨论了如何使用工厂构造函数实现简单的工厂设计模式。然而，我们还没有完全探索和理解工厂构造函数的力量。在本文中，我们将学习如何使用工厂构造函数实现缓存。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es je"><img src="../Images/dcedf7b128e35adbe600affcfea50005.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-6dwUnjJLiSAnQtqhKucAQ.jpeg"/></div></div></figure><p id="7531" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">什么是缓存？</strong></p><p id="d481" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">缓存是一种在本地存储中存储数据的方法，这样我们就可以重用它，而不是再次进行相同的计算。</p><p id="6246" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">示例</strong> : <em class="jq">您的脸书个人资料图片会缓存在您手机的本地存储中，这样就不需要一直从互联网上获取了。</em></p><p id="05f2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">但是在本文中，我们将要对工厂构造函数进行的缓存是完全不同的。我们将在地图中缓存实例。</p><p id="3890" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我能给出的关于缓存的最好例子是不同记录器的<strong class="ih hj">缓存</strong>，如果你不知道一个记录器做什么，它被用来打印消息到控制台用于调试目的。我们通常为每个类都准备了一个日志记录器来打印它们自己的调试消息，消息前面有它们的类名(这样我们就可以识别“哪个消息属于哪个类”)</p><p id="241c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">假设我们已经实现了自己的简单日志类</p><figure class="jf jg jh ji fd jj"><div class="bz dy l di"><div class="jr js l"/></div></figure><p id="64c3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这个Logger类非常明显，它只有一个属性<strong class="ih hj"> <em class="jq">名称</em> </strong>和一个方法<strong class="ih hj"><em class="jq">void log(String msg)</em></strong>。我们将为每个类创建一个日志记录器的实例，将它的类名作为参数传递。但是如果你每次都为同一个类创建同一个实例(从头开始),这不是一个好的做法，而且当实例非常昂贵时，将花费大量的计算时间。</p><p id="270c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">示例场景，</p><pre class="jf jg jh ji fd jt ju jv jw aw jx bi"><span id="2aac" class="jy jz hi ju b fi ka kb l kc kd">class A{<br/> late final Logger _logger;<br/> A(){<br/>    _logger = Logger(‘A’);<br/> }<br/>}</span></pre><p id="9b58" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在main()方法中，让我们创建5个A的实例，</p><pre class="jf jg jh ji fd jt ju jv jw aw jx bi"><span id="ed4b" class="jy jz hi ju b fi ka kb l kc kd">main() {<br/>   for(int i=1;i&lt;=5;i++){<br/>       print("Creating instance ${i}");<br/>       A a = A();<br/>       print(""); //newline<br/>   }<br/>}</span></pre><p id="fddd" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">输出将是</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div class="er es ke"><img src="../Images/04ab6d2569654ccd7f591655de614c3b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1066/format:webp/1*kxDE9zVrAfSAnJHRsVnLTg.png"/></div></figure><p id="32de" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">每当创建的实例时，也会创建相应的记录器实例。有什么方法可以重用logger实例吗？是的，我们有，通过缓存我们可以做到这一点。</p><h2 id="fa79" class="jy jz hi bd kf kg kh ki kj kk kl km kn iq ko kp kq iu kr ks kt iy ku kv kw kx bi translated">启用缓存的记录器类</h2><figure class="jf jg jh ji fd jj"><div class="bz dy l di"><div class="jr js l"/></div></figure><blockquote class="ky kz la"><p id="0e0e" class="if ig jq ih b ii ij ik il im in io ip lb ir is it lc iv iw ix ld iz ja jb jc hb bi translated"><strong class="ih hj">注意</strong>:工厂建造者无权访问<code class="du le lf lg ju b">this</code>。这就是我们将_cache声明为<strong class="ih hj">静态的原因。</strong></p></blockquote><p id="8871" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果你看看这个新的logger类，我做了一些显著的改变。</p><ol class=""><li id="81f5" class="lh li hi ih b ii ij im in iq lj iu lk iy ll jc lm ln lo lp bi translated">移除了公共构造函数并添加了私有构造函数记录器。_internal()，这样我们就不能直接创建Logger类的实例了。</li><li id="f1ee" class="lh li hi ih b ii lq im lr iq ls iu lt iy lu jc lm ln lo lp bi translated">引入了一个映射'<strong class="ih hj"> <em class="jq"> _cache </em> </strong>'，用于存储之前创建的实例，并以它们的类名作为关键字。</li><li id="3105" class="lh li hi ih b ii lq im lr iq ls iu lt iy lu jc lm ln lo lp bi translated">添加了一个工厂构造函数，它将决定是返回一个新的实例还是一个已经存在的实例。</li></ol><p id="25f0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果您再次运行main()方法，我们的输出将是</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div class="er es lv"><img src="../Images/a6bf99318c524127b3ea10908447971d.png" data-original-src="https://miro.medium.com/v2/resize:fit:894/format:webp/1*edudw3r-VExQaBnW7iS-Kg.png"/></div></figure><p id="c10c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">正如您所看到的，logger实例仅在我们初始化时第一次创建，然后在后续的实例化中被重用。</p><h2 id="1a09" class="jy jz hi bd kf kg kh ki kj kk kl km kn iq ko kp kq iu kr ks kt iy ku kv kw kx bi translated">它是如何工作的？</h2><ol class=""><li id="58dc" class="lh li hi ih b ii lw im lx iq ly iu lz iy ma jc lm ln lo lp bi translated">当您第一次创建A的实例时，它会要求Logger的工厂构造函数给它一个名为“A”的Logger实例。</li><li id="f7ea" class="lh li hi ih b ii lq im lr iq ls iu lt iy lu jc lm ln lo lp bi translated">工厂构造函数将在_cache映射中查找关键字为“A”的记录器实例。由于这是第一次，它找不到任何带有关键字' A '的日志记录器。因此，它创建了一个名为“A”的Logger的新实例，将它存储在map中，键为“A ”,并返回相同的结果。</li><li id="b661" class="lh li hi ih b ii lq im lr iq ls iu lt iy lu jc lm ln lo lp bi translated">对于后续调用，由于缓存中已经存在键为“A”的记录器，因此它不会创建新的实例并返回缓存的实例。</li></ol><p id="b89b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果我们需要创建的实例非常昂贵(需要大量计算时间)，这种缓存技术会非常方便。</p><p id="3237" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">你可以争辩说，缓存本身可能会占用大量空间。是的，你是对的，但是我们可以使用各种缓存算法来解决这个问题，但是如果你只有几个实例要缓存，这也可以。</p><p id="ace0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在下一篇文章中，我将告诉您命名构造函数和工厂构造函数之间的区别，以及何时更喜欢哪一个。谢谢你。</p></div></div>    
</body>
</html>