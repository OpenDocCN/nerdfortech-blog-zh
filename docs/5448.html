<html>
<head>
<title>Distributed Transaction — Implementation using REDIS and NodeJS</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">分布式事务—使用 REDIS 和 NodeJS 实现</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/distributed-transaction-implementation-using-redis-and-nodejs-c27c00328e4a?source=collection_archive---------0-----------------------#2021-10-02">https://medium.com/nerd-for-tech/distributed-transaction-implementation-using-redis-and-nodejs-c27c00328e4a?source=collection_archive---------0-----------------------#2021-10-02</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><figure class="hh hi ez fb hj hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es hg"><img src="../Images/1d30334c64c531cf613bdc138ad513f0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Pk4X9TsBud4RVFfZtUfKnQ.png"/></div></div></figure><div class=""/><p id="8f10" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">由于其分布式特性，分布式事务实现已经成为微服务开发中最大的挑战之一。有一些众所周知的模式可以解决这个问题。在本文中，我将解释一个使用<code class="du jo jp jq jr b">Redis</code>和<code class="du jo jp jq jr b">Nodejs</code>完成的示例实现。首先，让我们讨论一下我们要解决的问题的背景。</p><p id="cad1" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在设计上，<code class="du jo jp jq jr b">RDBMS</code>系统支持<code class="du jo jp jq jr b">ACID</code>交易。如果任何语句失败，事务会自行恢复。微服务模型不支持这一点，因为专用数据存储可用于服务。大多数数据存储根据<code class="du jo jp jq jr b">BASE</code>属性运行。你可以从这篇文章中了解更多关于<code class="du jo jp jq jr b">ACID</code> vs <code class="du jo jp jq jr b">BASE</code>的内容(<a class="ae js" href="https://phoenixnap.com/kb/acid-vs-base" rel="noopener ugc nofollow" target="_blank">链接</a>)。</p><p id="5fc9" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">重要的是要明白，在微服务模型中，完全的<code class="du jo jp jq jr b">ACID transaction</code>是不可能的。因此，您的分布式事务实现对于系统的问题域和期望来说是高度主观的。在实现这个示例时，我做了一些假设。</p><p id="c219" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">先来看看解决方案的组件设计。</p></div><div class="ab cl jt ju gp jv" role="separator"><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy"/></div><div class="hb hc hd he hf"><figure class="kb kc kd ke fd hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es ka"><img src="../Images/05b9b8462f7f22bb8452e1a62c203bcf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6WZExk-r0J7QgFadcK5yyw.png"/></div></div><figcaption class="kf kg et er es kh ki bd b be z dx translated">成功交易</figcaption></figure><h2 id="6b4a" class="kj kk ht bd kl km kn ko kp kq kr ks kt jb ku kv kw jf kx ky kz jj la lb lc ld bi translated">成分</h2><ul class=""><li id="622b" class="le lf ht is b it lg ix lh jb li jf lj jj lk jn ll lm ln lo bi translated">休息服务</li><li id="f989" class="le lf ht is b it lp ix lq jb lr jf ls jj lt jn ll lm ln lo bi translated">订单服务</li><li id="1460" class="le lf ht is b it lp ix lq jb lr jf ls jj lt jn ll lm ln lo bi translated">支付服务</li><li id="40cb" class="le lf ht is b it lp ix lq jb lr jf ls jj lt jn ll lm ln lo bi translated">送货服务</li><li id="02a4" class="le lf ht is b it lp ix lq jb lr jf ls jj lt jn ll lm ln lo bi translated">状态服务</li></ul></div><div class="ab cl jt ju gp jv" role="separator"><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy"/></div><div class="hb hc hd he hf"><h2 id="1ce5" class="kj kk ht bd kl km kn ko kp kq kr ks kt jb ku kv kw jf kx ky kz jj la lb lc ld bi translated">休息服务</h2><p id="e270" class="pw-post-body-paragraph iq ir ht is b it lg iv iw ix lh iz ja jb lu jd je jf lv jh ji jj lw jl jm jn hb bi translated">REST 服务是切入点。它在为事务生成 id 之前接受并验证请求。生成的 id 在 http 响应中返回给客户端。经验证的请求转发到<code class="du jo jp jq jr b"><em class="lx">ORDER: QUEUE</em></code> <em class="lx"> </em>进行进一步处理。</p><figure class="kb kc kd ke fd hk"><div class="bz dy l di"><div class="ly lz l"/></div></figure><h2 id="7496" class="kj kk ht bd kl km kn ko kp kq kr ks kt jb ku kv kw jf kx ky kz jj la lb lc ld bi translated">REST 服务请求和响应</h2><p id="fa23" class="pw-post-body-paragraph iq ir ht is b it lg iv iw ix lh iz ja jb lu jd je jf lv jh ji jj lw jl jm jn hb bi translated">数据以最终一致的方式存储，因此我们可以随时重放交易，并在失败时进行手动或批量对账。</p><figure class="kb kc kd ke fd hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es ma"><img src="../Images/db0ad84e26b55ef696f8ff591893c8ad.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*odJZBVlrqwFvRxRxJFhnBA.png"/></div></div><figcaption class="kf kg et er es kh ki bd b be z dx translated">发布创建订单的请求</figcaption></figure><figure class="kb kc kd ke fd hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es mb"><img src="../Images/df3e259da041ba22d1c9932dc58f2414.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tARrdas7wtjXA6jpN9dlrg.png"/></div></div><figcaption class="kf kg et er es kh ki bd b be z dx translated">获取轮询事务状态的请求</figcaption></figure><h2 id="aa06" class="kj kk ht bd kl km kn ko kp kq kr ks kt jb ku kv kw jf kx ky kz jj la lb lc ld bi translated">订单服务/支付/交付服务</h2><p id="a685" class="pw-post-body-paragraph iq ir ht is b it lg iv iw ix lh iz ja jb lu jd je jf lv jh ji jj lw jl jm jn hb bi translated">每个服务读取请求，进一步处理它，并嵌入额外的细节，如成本。然后将事件转发到下一个队列。协调过程也在同一服务中实现。因此，撤销事务的责任就交给了相关的服务。</p><figure class="kb kc kd ke fd hk"><div class="bz dy l di"><div class="ly lz l"/></div></figure></div><div class="ab cl jt ju gp jv" role="separator"><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy"/></div><div class="hb hc hd he hf"><h2 id="f856" class="kj kk ht bd kl km kn ko kp kq kr ks kt jb ku kv kw jf kx ky kz jj la lb lc ld bi translated">恢复</h2><p id="ef15" class="pw-post-body-paragraph iq ir ht is b it lg iv iw ix lh iz ja jb lu jd je jf lv jh ji jj lw jl jm jn hb bi translated">我们来看看对账流程。</p><figure class="kb kc kd ke fd hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es mc"><img src="../Images/2a465ed07825aa07a2ccdf88646a1c07.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*eiLDQ2R2pmekE4OvvB2Zpw.png"/></div></div></figure><p id="b516" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">该图显示了当支付操作失败时如何执行恢复过程。我通过将项目 id 200 设置为失败案例来模拟这种情况。在这种情况下，支付服务通知订单服务恢复交易。订单服务将软状态更改为失败。前端可以看到交易失败。设计冲销事务时有一些最佳实践。相反的过程应该很简单，不应该轻易失败。发送短信等步骤应在交易结束时执行。</p></div><div class="ab cl jt ju gp jv" role="separator"><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy"/></div><div class="hb hc hd he hf"><h2 id="30e3" class="kj kk ht bd kl km kn ko kp kq kr ks kt jb ku kv kw jf kx ky kz jj la lb lc ld bi translated">结论</h2><p id="2d27" class="pw-post-body-paragraph iq ir ht is b it lg iv iw ix lh iz ja jb lu jd je jf lv jh ji jj lw jl jm jn hb bi translated">本文中的实现非常简单。实际的问题域要复杂得多，可能涉及几十个服务和数百个事件。但是基本概念保持不变。有很多技术和概念可以帮助解决类似的问题(<a class="ae js" href="https://developers.redhat.com/blog/2018/10/01/patterns-for-distributed-transactions-within-a-microservices-architecture" rel="noopener ugc nofollow" target="_blank">链接</a>)。</p><p id="6fa6" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在这个示例中，我使用了<code class="du jo jp jq jr b">Redis</code>作为队列。但是，<code class="du jo jp jq jr b">Kafka</code>可能是更好的生产队列选择，因为我们可以使用<code class="du jo jp jq jr b"><em class="lx">Kafka ack</em></code>实现应用级容错，使用<code class="du jo jp jq jr b">Debezium</code>的<code class="du jo jp jq jr b"><em class="lx">Kafka Connect</em></code>作为 CDC 解决方案，<code class="du jo jp jq jr b">Kafka</code>本身作为事件源数据库。</p></div></div>    
</body>
</html>