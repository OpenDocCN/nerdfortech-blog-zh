<html>
<head>
<title>Futures in Scala</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Scala中的期货</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/futures-in-scala-201677bc5d97?source=collection_archive---------9-----------------------#2021-05-23">https://medium.com/nerd-for-tech/futures-in-scala-201677bc5d97?source=collection_archive---------9-----------------------#2021-05-23</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="6f29" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">异步执行</strong></p><p id="ff99" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">考虑下面scala中给出的代码，它休眠10秒钟并返回结果。也就是21+21。</p><pre class="jd je jf jg fd jh ji jj jk aw jl bi"><span id="b4ac" class="jm jn hi ji b fi jo jp l jq jr"><strong class="ji hj">Thread</strong>.sleep(<strong class="ji hj">10000</strong>); <strong class="ji hj">21</strong> + <strong class="ji hj">21</strong></span></pre><p id="56cb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果代码需要10分钟睡眠，而不是10秒。你能想象一个10分钟后返回结果的API吗？！。当然不是，我们期望API在几秒钟内响应，这是异步执行发挥作用的场景。Java为在后台执行线程提供了多线程支持，但是这种机制是由监视器管理的，监视器提供锁，并且一次只允许一个线程进入。Python提供了celery，这是一个完全不同的进程，在后台执行任务。这些流程可用于在后台异步执行不同的任务。</p><p id="bc2b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这些在后台执行的任务是死锁和竞争条件的雷区。一千件事情都可能出错，现在让我们看看如何使用scala futures来避免这些死锁和竞争情况。</p><figure class="jd je jf jg fd jt er es paragraph-image"><div role="button" tabindex="0" class="ju jv di jw bf jx"><div class="er es js"><img src="../Images/c8158858eb1db88dccc6560c5ee94eb3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1UiQE3M1WFTft87zwYa-hA.png"/></div></div></figure><p id="ccb7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> Scala期货</strong></p><p id="9e70" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">当您调用一个函数时，线程会等待函数执行完毕并返回结果，如果结果是未来的，那么执行将由一个完全不同的线程异步执行。</p><pre class="jd je jf jg fd jh ji jj jk aw jl bi"><span id="df28" class="jm jn hi ji b fi jo jp l jq jr">scala&gt; <strong class="ji hj">import</strong> <strong class="ji hj">scala.concurrent.ExecutionContext.Implicits.global<br/></strong>import scala.concurrent.ExecutionContext.Implicits.global</span><span id="a842" class="jm jn hi ji b fi ka jp l jq jr">scala&gt; <strong class="ji hj">val</strong> fut <strong class="ji hj">=</strong> <strong class="ji hj">Future</strong> { <strong class="ji hj">Thread</strong>.sleep(<strong class="ji hj">10000</strong>); <strong class="ji hj">21</strong> + <strong class="ji hj">21</strong> }<br/>fut: scala.concurrent.Future[Int] = Future(&lt;not completed&gt;)</span></pre><p id="a198" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">上述函数将继续执行该方法，通常是通过一个完全不同的线程。无论执行是否完成，无论状态是成功还是失败，我们都可以继续轮询以获得未来的状态。</p><pre class="jd je jf jg fd jh ji jj jk aw jl bi"><span id="b294" class="jm jn hi ji b fi jo jp l jq jr">scala&gt; fut.isCompleted<br/>res0: Boolean = true</span><span id="9430" class="jm jn hi ji b fi ka jp l jq jr">scala&gt; fut.value<br/>res3: Option[scala.util.Try[Int]] = Some(Success(42))</span></pre><p id="12ac" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">10秒钟后，未来的结果将如上图所示。在完成之前,<em class="kb"> isCompleted结果将为假，值将为无。</em></p><p id="c8f2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">用地图改变未来</strong></p><p id="4d8a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">映射函数可用于将一个未来的结果映射到另一个未来。我们可以明确指定如何处理未来的结果。</p><pre class="jd je jf jg fd jh ji jj jk aw jl bi"><span id="dbf3" class="jm jn hi ji b fi jo jp l jq jr">scala&gt; <strong class="ji hj">val</strong> fut <strong class="ji hj">=</strong> <strong class="ji hj">Future</strong> { <strong class="ji hj">Thread</strong>.sleep(<strong class="ji hj">10000</strong>); <strong class="ji hj">21</strong> + <strong class="ji hj">21</strong> }<br/>fut: scala.concurrent.Future[Int] = ...</span><span id="bda4" class="jm jn hi ji b fi ka jp l jq jr">scala&gt; <strong class="ji hj">val</strong> result <strong class="ji hj">=</strong> fut.map(x <strong class="ji hj">=&gt;</strong> x + <strong class="ji hj">1</strong>)<br/>result: scala.concurrent.Future[Int] = ...</span><span id="b229" class="jm jn hi ji b fi ka jp l jq jr">//After 10 seconds</span><span id="26c2" class="jm jn hi ji b fi ka jp l jq jr">scala&gt; result.value<br/>res6: Option[scala.util.Try[Int]] = Some(Success(43))</span></pre><p id="aec7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">用for表达式转换未来</strong></p><p id="0f3f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们可以并行运行两个未来，并结合它们的结果，创造一个新的未来。</p><pre class="jd je jf jg fd jh ji jj jk aw jl bi"><span id="74e9" class="jm jn hi ji b fi jo jp l jq jr">scala&gt; <strong class="ji hj">val</strong> fut1 <strong class="ji hj">=</strong> <strong class="ji hj">Future</strong> { <strong class="ji hj">Thread</strong>.sleep(<strong class="ji hj">10000</strong>); <strong class="ji hj">21</strong> + <strong class="ji hj">21</strong> }<br/>fut1: scala.concurrent.Future[Int] = Future(&lt;not completed&gt;)</span><span id="6c01" class="jm jn hi ji b fi ka jp l jq jr">scala&gt; <strong class="ji hj">val</strong> fut2 <strong class="ji hj">=</strong> <strong class="ji hj">Future</strong> { <strong class="ji hj">Thread</strong>.sleep(<strong class="ji hj">10000</strong>); <strong class="ji hj">23</strong> + <strong class="ji hj">23</strong> }<br/>fut2: scala.concurrent.Future[Int] = Future(&lt;not completed&gt;)</span><span id="7f3a" class="jm jn hi ji b fi ka jp l jq jr">scala&gt; <strong class="ji hj">val</strong> rs2<strong class="ji hj">=for</strong> {<br/>     | x <strong class="ji hj">&lt;-</strong> fut1<br/>     | y <strong class="ji hj">&lt;-</strong> fut2<br/>     | } <strong class="ji hj">yield</strong> x + y<br/>rs2: scala.concurrent.Future[Int] = Future(&lt;not completed&gt;)</span><span id="2c78" class="jm jn hi ji b fi ka jp l jq jr">scala&gt; rs2.value<br/>res20: Option[scala.util.Try[Int]] = Some(Success(88))</span></pre><p id="68a2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果您不想并行运行期货，请在for循环中指定它。例如</p><pre class="jd je jf jg fd jh ji jj jk aw jl bi"><span id="c07a" class="jm jn hi ji b fi jo jp l jq jr">scala&gt; <strong class="ji hj">for</strong> {<br/>x <strong class="ji hj">&lt;-</strong> <strong class="ji hj">Future</strong> { <strong class="ji hj">Thread</strong>.sleep(<strong class="ji hj">10000</strong>); <strong class="ji hj">21</strong> + <strong class="ji hj">21</strong> }<br/>y <strong class="ji hj">&lt;-</strong> <strong class="ji hj">Future</strong> { <strong class="ji hj">Thread</strong>.sleep(<strong class="ji hj">10000</strong>); <strong class="ji hj">23</strong> + <strong class="ji hj">23</strong> }<br/>} <strong class="ji hj">yield</strong> x + y<br/>res9: scala.concurrent.Future[Int] = ...</span></pre><p id="c2aa" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">成功和失败的方法可以用来创造一个已经失败或者已经成功的未来。</p><pre class="jd je jf jg fd jh ji jj jk aw jl bi"><span id="f004" class="jm jn hi ji b fi jo jp l jq jr">scala&gt; <strong class="ji hj">Future</strong>.successful { <strong class="ji hj">21</strong> + <strong class="ji hj">21</strong> }<br/>res21: scala.concurrent.Future[Int] = Future(Success(42))</span><span id="50aa" class="jm jn hi ji b fi ka jp l jq jr">scala&gt; <strong class="ji hj">Future</strong>.failed(<strong class="ji hj">new</strong> <strong class="ji hj">Exception</strong>("hackkkkkkkkkkkkk!"))<br/>res23: scala.concurrent.Future[Nothing] = Future(Failure(java.lang.Exception: hackkkkkkkkkkkkk!))</span></pre><p id="e8e5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">未来可以用承诺来创造和控制。承诺是创造和控制未来最普遍的方式。当你完成了承诺，未来也就完成了。承诺可以以成功、失败或完成的形式完成。</p><pre class="jd je jf jg fd jh ji jj jk aw jl bi"><span id="e81e" class="jm jn hi ji b fi jo jp l jq jr">scala&gt; <strong class="ji hj">import</strong> <strong class="ji hj">scala.concurrent._</strong><br/>import scala.concurrent._</span><span id="0f3a" class="jm jn hi ji b fi ka jp l jq jr">scala&gt; <strong class="ji hj">val</strong> pro<strong class="ji hj">=Promise</strong>[<strong class="ji hj">Int</strong>]<br/>pro: scala.concurrent.Promise[Int] = Future(&lt;not completed&gt;)</span><span id="bcf7" class="jm jn hi ji b fi ka jp l jq jr">scala&gt; <strong class="ji hj">val</strong> fut <strong class="ji hj">=</strong> pro.future<br/>fut: scala.concurrent.Future[Int] = Future(&lt;not completed&gt;)</span><span id="e909" class="jm jn hi ji b fi ka jp l jq jr">scala&gt; fut.value<br/>res24: Option[scala.util.Try[Int]] = None</span><span id="3010" class="jm jn hi ji b fi ka jp l jq jr">scala&gt; pro.success(<strong class="ji hj">42</strong>)<br/>res25: pro.type = Future(Success(42))</span></pre><p id="fe3b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">过滤、收集和转换期货</strong></p><p id="4819" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">filter和collect是用于从future中过滤出来并对其执行一些操作的两种方法。</p><p id="4f1c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">以下示例显示了对未来值的筛选操作，筛选大于零的值。如果我们应用过滤操作来过滤小于零的值，结果将是零。</p><pre class="jd je jf jg fd jh ji jj jk aw jl bi"><span id="41f0" class="jm jn hi ji b fi jo jp l jq jr">scala&gt; <strong class="ji hj">val</strong> fut <strong class="ji hj">=</strong> <strong class="ji hj">Future</strong> { <strong class="ji hj">42</strong> }<br/>fut: scala.concurrent.Future[Int] = Future(&lt;not completed&gt;)</span><span id="1061" class="jm jn hi ji b fi ka jp l jq jr">scala&gt; <strong class="ji hj">val</strong> valid <strong class="ji hj">=</strong> fut.filter(res <strong class="ji hj">=&gt;</strong> res &gt; <strong class="ji hj">0</strong>)<br/>valid: scala.concurrent.Future[Int] = Future(&lt;not completed&gt;)</span><span id="359f" class="jm jn hi ji b fi ka jp l jq jr">scala&gt; valid.value<br/>res26: Option[scala.util.Try[Int]] = Some(Success(42))</span></pre><p id="eb4b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">collect方法用于验证未来的输出，并对其执行一些转换操作。</p><pre class="jd je jf jg fd jh ji jj jk aw jl bi"><span id="0ed3" class="jm jn hi ji b fi jo jp l jq jr">scala&gt; <strong class="ji hj">val</strong> fut <strong class="ji hj">=</strong> <strong class="ji hj">Future</strong> { <strong class="ji hj">42</strong> }<br/>fut: scala.concurrent.Future[Int] = Future(Success(42))</span><span id="40a9" class="jm jn hi ji b fi ka jp l jq jr">scala&gt; <strong class="ji hj">val</strong> valid<strong class="ji hj">=</strong>fut collect { <strong class="ji hj">case</strong> res <strong class="ji hj">if</strong> res &gt; <strong class="ji hj">0</strong> <strong class="ji hj">=&gt;</strong> res + <strong class="ji hj">46</strong> }<br/>valid: scala.concurrent.Future[Int] = Future(&lt;not completed&gt;)</span><span id="e56e" class="jm jn hi ji b fi ka jp l jq jr">scala&gt; valid.value<br/>res31: Option[scala.util.Try[Int]] = Some(Success(88))</span></pre><p id="2244" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">转换操作可以应用于条件执行的未来，以指定如果未来成功该做什么以及如果失败该做什么。在下面的例子中，如果未来是成功的，它将用于第一个条件，如果未来是失败的，它将用于第二个条件。</p><pre class="jd je jf jg fd jh ji jj jk aw jl bi"><span id="453d" class="jm jn hi ji b fi jo jp l jq jr">scala&gt;  <strong class="ji hj">val</strong> success <strong class="ji hj">=</strong> <strong class="ji hj">Future</strong> { <strong class="ji hj">42</strong> }<br/>success: scala.concurrent.Future[Int] = Future(&lt;not completed&gt;)</span><span id="8304" class="jm jn hi ji b fi ka jp l jq jr">scala&gt; <strong class="ji hj">val</strong> first <strong class="ji hj">=</strong> success.transform(<br/>| res <strong class="ji hj">=&gt;</strong> res * -<strong class="ji hj">1</strong>,<br/>| ex <strong class="ji hj">=&gt;</strong> <strong class="ji hj">new</strong> <strong class="ji hj">Exception</strong>("see cause", ex)<br/>| )<br/>first: scala.concurrent.Future[Int] = Future(&lt;not completed&gt;)</span><span id="c842" class="jm jn hi ji b fi ka jp l jq jr">scala&gt; first.value<br/>res34: Option[scala.util.Try[Int]] = Some(Success(-42))</span></pre><p id="ef2b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">编写期货测试用例</strong></p><p id="40c9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们已经看到了如何创造未来。现在让我们看看如何编写测试用例并成功测试我们的未来。Scala提供了一个名为await的方法来阻塞我们的线程一段时间。在那之后，我们将得到结果，并可以测试它。在下面的例子中，await接受一个时间延迟参数，等待特定的时间量并返回结果。获得结果后，我们可以断言结果并测试函数。</p><pre class="jd je jf jg fd jh ji jj jk aw jl bi"><span id="9d2c" class="jm jn hi ji b fi jo jp l jq jr">scala&gt; <strong class="ji hj">import</strong> <strong class="ji hj">scala.concurrent.Await</strong><br/>import scala.concurrent.Await</span><span id="28d4" class="jm jn hi ji b fi ka jp l jq jr">scala&gt; <strong class="ji hj">import</strong> <strong class="ji hj">scala.concurrent.duration._</strong><br/>import scala.concurrent.duration._</span><span id="6d52" class="jm jn hi ji b fi ka jp l jq jr">scala&gt; <strong class="ji hj">val</strong> fut <strong class="ji hj">=</strong> <strong class="ji hj">Future</strong> { <strong class="ji hj">Thread</strong>.sleep(<strong class="ji hj">10000</strong>); <strong class="ji hj">21</strong> + <strong class="ji hj">21</strong> }<br/>fut: scala.concurrent.Future[Int] = Future(&lt;not completed&gt;)</span><span id="f81b" class="jm jn hi ji b fi ka jp l jq jr">scala&gt; <strong class="ji hj">val</strong> x <strong class="ji hj">=</strong> <strong class="ji hj">Await</strong>.result(fut, <strong class="ji hj">15.</strong>seconds)<br/>x: Int = 42</span></pre></div></div>    
</body>
</html>