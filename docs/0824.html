<html>
<head>
<title>JavaScript Proxy: What and Why?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript代理:什么和为什么？</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/javascript-proxy-what-and-why-fca16f6e0088?source=collection_archive---------11-----------------------#2021-02-16">https://medium.com/nerd-for-tech/javascript-proxy-what-and-why-fca16f6e0088?source=collection_archive---------11-----------------------#2021-02-16</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/d23374af4c51d3c15a2e06609c223c2b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*XjtXg3nNdpyi381S.png"/></div></div></figure><p id="bb46" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">EcmaScript 2015引入了另一个尚未广泛使用的特性。JavaScript代理允许我们用一个层来包装现有的对象。该层可以为我们提供诸如拦截属性和方法之类的功能。即使属性不存在，也可以做到这一点！</p><p id="2544" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">那是什么意思？</p><p id="197e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">JavaScript代理让我们能够改变对象和函数的底层行为。它们可以被认为是JavaScript对象的中间件。它允许我们覆盖内部操作，比如对象属性查找、赋值、枚举、函数调用、生成器行为、迭代等等。</p><p id="dd65" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在我们开始声明JavaScript代理之前，让我们先了解一下术语。</p><h1 id="e1a4" class="jo jp hi bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">随身行李</h1><p id="c1a4" class="pw-post-body-paragraph iq ir hi is b it km iv iw ix kn iz ja jb ko jd je jf kp jh ji jj kq jl jm jn hb bi translated">我们可以覆盖的内部方法被称为陷阱。JavaScript代理API允许我们覆盖以下内容:</p><h1 id="e216" class="jo jp hi bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">对象方法:</h1><p id="ab25" class="pw-post-body-paragraph iq ir hi is b it km iv iw ix kn iz ja jb ko jd je jf kp jh ji jj kq jl jm jn hb bi translated">getPrototypeOf()<br/>setPrototypeOf()<br/>isExtensible()<br/>prevent extensions()<br/>getOwnPropertyDescriptor()<br/>ownKeys()</p><h1 id="f546" class="jo jp hi bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">属性获取器/设置器:</h1><p id="ad62" class="pw-post-body-paragraph iq ir hi is b it km iv iw ix kn iz ja jb ko jd je jf kp jh ji jj kq jl jm jn hb bi translated">has()<br/>get()<br/>set()<br/>delete property()</p><h1 id="d280" class="jo jp hi bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">函数方法:</h1><p id="7f6e" class="pw-post-body-paragraph iq ir hi is b it km iv iw ix kn iz ja jb ko jd je jf kp jh ji jj kq jl jm jn hb bi translated">apply() <br/>构造()</p><h1 id="b650" class="jo jp hi bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">目标</h1><p id="b1f1" class="pw-post-body-paragraph iq ir hi is b it km iv iw ix kn iz ja jb ko jd je jf kp jh ji jj kq jl jm jn hb bi translated">需要覆盖其属性的对象称为目标。它可以是我们想要的任何物体。这意味着它可以是一个常规的JS对象，或者是一个第三方模块，一个函数，或者是一个代理本身。</p><h1 id="409e" class="jo jp hi bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">处理者</h1><p id="be71" class="pw-post-body-paragraph iq ir hi is b it km iv iw ix kn iz ja jb ko jd je jf kp jh ji jj kq jl jm jn hb bi translated">由于一个对象上有多个陷阱，因此我们可以为单个对象设置多个配置。因此，代理配置被称为处理程序。它可以有多个陷阱。读取目标属性的get陷阱，写入目标属性的set陷阱，等等。</p><h1 id="d65d" class="jo jp hi bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">定义JavaScript代理</h1><p id="5154" class="pw-post-body-paragraph iq ir hi is b it km iv iw ix kn iz ja jb ko jd je jf kp jh ji jj kq jl jm jn hb bi translated">现在我们知道了术语，让我们定义一个JavaScript代理！</p><pre class="kr ks kt ku fd kv kw kx ky aw kz bi"><span id="6758" class="la jp hi kw b fi lb lc l ld le">let proxy = new Proxy(target, handler);</span></pre><p id="6358" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在，每当我们在代理上执行操作时，JavaScript将在内部引用处理程序。如果代理上存在相应的陷阱，它将被调用。否则将在目标上执行操作。</p><p id="25de" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如果我们要创建一个在处理程序上没有任何陷阱的代理，</p><pre class="kr ks kt ku fd kv kw kx ky aw kz bi"><span id="b0e7" class="la jp hi kw b fi lb lc l ld le">let proxy = new Proxy(target, {});</span></pre><p id="bbf2" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">代理是目标对象周围的透明包装。</p><p id="ef4b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">代理本身没有任何属性。在我们开始拦截处理程序之前，让我们看一下处理程序方法是什么时候被触发的。</p><p id="85cc" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj"> get: </strong>读取一个属性<br/> <strong class="is hj"> set: </strong>写入一个属性<br/> <strong class="is hj"> has: </strong> in运算符<br/> <strong class="is hj"> deleteProperty: </strong>删除运算符<br/> <strong class="is hj"> apply: </strong>函数调用<br/> <strong class="is hj"> construct: </strong> new运算符<br/><strong class="is hj">getPrototypeOf:</strong>object . getPrototypeOf<br/><strong class="is hj">set prototypeof:</strong>object . setPrototypeOf..在，Object.keys/values/entries<br/><strong class="is hj">ownKeys:</strong>object . getownpropertymanames，object . getownpropertymodals，for..在Object.keys/values/entries</p><p id="4405" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在我们已经知道了JavaScript代理的所有细节，让我们来看一些例子吧！</p><h1 id="a84f" class="jo jp hi bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">使用获取陷阱分配默认值</h1><p id="729d" class="pw-post-body-paragraph iq ir hi is b it km iv iw ix kn iz ja jb ko jd je jf kp jh ji jj kq jl jm jn hb bi translated">让我们为未定义的属性指定一个默认值。</p><pre class="kr ks kt ku fd kv kw kx ky aw kz bi"><span id="55f3" class="la jp hi kw b fi lb lc l ld le">const handler = {<br/>	get: (obj, property) =&gt; <br/>  	property in obj ? obj[property] : 'you forgot to assign a value to this property bruh'<br/>}<br/><br/>const objectWithDefaultValue = new Proxy({}, handler);<br/><br/>objectWithDefaultValue.foo = 'bar';<br/><br/>console.log(objectWithDefaultValue.foo); // bar<br/>console.log(objectWithDefaultValue['hello there']); // you forgot to assign a value to this property bruh</span></pre><p id="a1eb" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们定义的get陷阱会覆盖查找行为。如果对象有已定义的属性，我们返回值。否则我们返回我们的自定义消息。</p><h1 id="c833" class="jo jp hi bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">使用设置的陷阱执行验证</h1><p id="a1c4" class="pw-post-body-paragraph iq ir hi is b it km iv iw ix kn iz ja jb ko jd je jf kp jh ji jj kq jl jm jn hb bi translated">JavaScript在集合陷阱上有一个不变量。也就是说，这个内部方法需要满足一个条件。如果值写入成功，处理程序必须返回true。否则它会返回false或抛出错误。</p><p id="89f6" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">让我们在设置age属性之前创建一个代理来验证它。</p><pre class="kr ks kt ku fd kv kw kx ky aw kz bi"><span id="cbd9" class="la jp hi kw b fi lb lc l ld le">let handler = {<br/>  set: function(obj, property, value) {<br/>    if (property === 'age') {<br/>      if (!Number.isInteger(value)) {<br/>        throw new TypeError('Age is not an integer');<br/>      }<br/>      if (value &gt; 200) {<br/>        throw new RangeError('Age is invalid, enter value less than 200');<br/>      }<br/>    }<br/><br/>    // Default behavior of storing the value<br/>    obj[prop] = value;<br/><br/>    return true;<br/>  }<br/>};<br/><br/>const person = new Proxy({}, handler);<br/><br/>person.age = 18;<br/>console.log(person.age); // 18<br/>person.age = 'old';    // Throws exception: Age is not an intege<br/>person.age = 250;        // Throws exception: Age is invalid, enter value less than 200</span></pre><h1 id="59b3" class="jo jp hi bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">使用HAS、OWNKEYS、SET、GET和DELETE陷阱的私有属性</h1><pre class="kr ks kt ku fd kv kw kx ky aw kz bi"><span id="57d1" class="la jp hi kw b fi lb lc l ld le">const hidePrivateFields = (target, prefix = "_") {<br/>  return new Proxy(target, {<br/>    has: (target, prop) =&gt; {<br/>      if(typeof prop === "string" &amp;&amp; prop.startsWith(prefix)){<br/>        return false;<br/>      }<br/>      return prop in target<br/>    },<br/>    ownKeys: target =&gt; {<br/>      return Reflect.ownKeys(target).filter(<br/>        prop =&gt; typeof prop !== "string" || !prop.startsWith(prefix)<br/>      )<br/>    },<br/>    get: (target, prop) =&gt; {<br/>      if(typeof prop === "string" &amp;&amp; prop.startsWith(prefix)){<br/>        return undefined;<br/>      }<br/>      return target[prop];<br/>    },<br/>    deleteProperty(target, prop) { <br/>      if (prop.startsWith('_')) {<br/>        return true;<br/>      } else {<br/>        delete target[prop];<br/>        return true;<br/>    }<br/>  },<br/><br/>  });<br/>}<br/><br/>let userInfo = hidePrivateFields({<br/>  firstName: 'Saransh',<br/>  _password: 'password'<br/>})<br/><br/>userInfo._password           // undefined<br/>('_password' in userInfo)    // false<br/>Object.keys(userInfo)        // ['firstName']<br/>delete userInfo._password    // returns true, but does not delete the password</span></pre><h1 id="bb01" class="jo jp hi bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">结论</h1><p id="1205" class="pw-post-body-paragraph iq ir hi is b it km iv iw ix kn iz ja jb ko jd je jf kp jh ji jj kq jl jm jn hb bi translated">我们关于JavaScript代理的帖子到此结束！</p><p id="03d1" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在我们结束这篇文章之前，有几个问题:</p><ul class=""><li id="a54d" class="lf lg hi is b it iu ix iy jb lh jf li jj lj jn lk ll lm ln bi translated">目前，IE中不支持代理。<br/>并且没有完整的聚合填充可用🙁</li><li id="176d" class="lf lg hi is b it lo ix lp jb lq jf lr jj ls jn lk ll lm ln bi translated">没有办法确定一个对象是否是代理。</li><li id="075d" class="lf lg hi is b it lo ix lp jb lq jf lr jj ls jn lk ll lm ln bi translated">一旦定义，就不可能改变目标或处理程序对象。</li><li id="32b2" class="lf lg hi is b it lo ix lp jb lq jf lr jj ls jn lk ll lm ln bi translated">代理性能相对较慢。</li><li id="38e6" class="lf lg hi is b it lo ix lp jb lq jf lr jj ls jn lk ll lm ln bi translated">目标必须是对象，代理不能应用于基本体。</li></ul><p id="2b3d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">让我们知道您的使用体验，或者您是否面临任何问题。你打算创建什么样的代理？请在下面留言，让我们知道。</p></div><div class="ab cl lt lu gp lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="hb hc hd he hf"><p id="5832" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><em class="ma">原载于2021年2月16日https://www.wisdomgeek.com</em><em class="ma">T42</em><a class="ae mb" href="https://www.wisdomgeek.com/development/web-development/javascript/javascript-proxy-what-and-why/" rel="noopener ugc nofollow" target="_blank">。</a></p></div></div>    
</body>
</html>