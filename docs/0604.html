<html>
<head>
<title>Apache Kafka: Quick Start</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">阿帕奇卡夫卡:快速入门</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/apache-kafka-quick-start-1edeef53773e?source=collection_archive---------2-----------------------#2021-01-26">https://medium.com/nerd-for-tech/apache-kafka-quick-start-1edeef53773e?source=collection_archive---------2-----------------------#2021-01-26</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/57fbc68b6b46fcc099c30fee48c25c26.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OJzmfjjNmdttDBCLZV6IAA.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">阿帕奇卡夫卡</figcaption></figure><p id="9ce2" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">在这篇文章中，我们将探讨Kafka基础，这有助于Kafka初学者了解Kafka的组成部分。</p><p id="0809" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">1.制作人<br/> 2。消费者<br/> 3。消费者群体<br/> 4。话题<br/> 5。分区<br/> 6。偏移<br/> 7。分段<br/> 8。复制因子<br/> 9。领导者和追随者<br/> 10。ISR-In同步副本<br/> 11。确认(Acks，1，all) <br/> 12。动物园管理员13。代理/节点/引导服务器<br/> 14。控制器</p><p id="62db" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">Apache Kafka是一个可扩展、容错的分布式流媒体平台，具有以下主要功能。</p><p id="8494" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">-发布和订阅记录/事件流。<br/> -以容错的持久方式存储记录/事件流。<br/> -记录/事件流发生时进行处理。</p><p id="12fb" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">Kafka最适合实时流需求</p><p id="3935" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">-构建在应用程序之间获取数据的实时流数据管道<br/> -构建对数据流做出反应的实时流应用程序(事件驱动系统)</p><figure class="jt ju jv jw fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es js"><img src="../Images/4031ebde1225ccd39bb75639da89909d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*aGS6pfVxcXuE_fAJelZfig.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">阿帕奇卡夫卡生态系统</figcaption></figure><p id="23e1" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw hj">监制</strong>:</p><p id="367e" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">Producer创建新消息并将数据发布到主题。生产者负责选择将哪个记录分配给主题中的哪个分区。</p><p id="221d" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">默认情况下，生产者并不关心消息被写到哪个主题分区，而是在一个主题的所有分区中公平地平衡消息。生产者基于消息键和分割器将消息/记录定向到分区。</p><p id="30dd" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw hj">消费者和消费群体</strong></p><p id="9392" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">消费者可以订阅一个或多个主题，并按照消息产生的顺序阅读消息。消费者还可以借助消息偏移量来跟踪已经阅读的消息。</p><p id="cdb0" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">使用者组指的是一个或多个分担工作负载的使用者组成的组。消费者被映射到具有group-id/name的特定消费者组。</p><p id="067f" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">使用者组确保发布到主题的每个记录都可以被同一使用者组中的一个使用者实例读取。这些记录将在来自同一个使用者组的使用者之间进行负载平衡。</p><p id="0ac5" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">一个记录可以被来自不同消费者组的多个消费者读取。</p><p id="e5fc" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw hj">题目及分区:</strong></p><p id="7b38" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">主题可以被认为是数据库中的表或文件系统中的文件夹。Kafka将记录发布到主题中，可以有零个或一个或多个消费者来读取写入主题的数据。此外，主题还被分成几个部分。Kafka集群为每个主题维护一个提交日志。</p><p id="b143" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">下图显示了一个包含3个分区的主题</p><figure class="jt ju jv jw fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es jx"><img src="../Images/896984f1da1e521aa93a41818c079c37.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*itnF8GMulEvFgivuK5gMnQ.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">示例:包含3个分区的Kafka主题</figcaption></figure><p id="ace3" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">分区可以被描述为一个不可变的消息集合，其中消息可以以仅附加的方式编写。Kafka中的记录排序可以保证每个分区。</p><p id="06b8" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">每个主题可以有一个或多个分区。主题的分区副本数量取决于主题创建期间配置的复制因子(RF)。</p><p id="de09" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">示例:<br/> -如果RF=1，则只有领导者拥有该分区，并且该分区没有追随者。<br/> -如果RF=2，意味着有2个分区副本。一个有领导者，另一个有跟随者。<br/> -如果RF=3，意味着有3份分区。一个有领导者，两个有追随者。</p><p id="3a43" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw hj">偏移:</strong></p><p id="b76b" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">Offset是分配给分区上的记录的唯一数字。每当发布新记录时，current offset将递增1，并将该记录添加到分区上。从消费者处读取数据时，偏移量起着至关重要的作用(消费者根据上次提交的偏移量读取数据)。</p><figure class="jt ju jv jw fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es jy"><img src="../Images/ede116d0e230cf0bfee9562f9c35c312.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Dr4aXVPDL7-_lE-SwKN1Bw.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">例如:卡夫卡消费-电流偏移</figcaption></figure><p id="fcc1" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw hj">段</strong>:</p><p id="9e73" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">每个分区被细分为段，段是一个分区的记录集合。Kafka没有将一个分区的所有信息保存在一个日志中，而是将它分成更小的块(段)。</p><p id="f959" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">Kafka总是将记录写入分区的活动段。如果达到段大小，将创建一个新的段，并作为活动段。</p><figure class="jt ju jv jw fd ij er es paragraph-image"><div class="er es jz"><img src="../Images/d6b3468561024e4bee0861acdb767646.png" data-original-src="https://miro.medium.com/v2/resize:fit:860/format:webp/1*SRL3tD0XsyCO0F_IPRYkOQ.png"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">例如:卡夫卡片段</figcaption></figure><p id="a316" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw hj">复制因子</strong></p><p id="4df2" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">它表示一个分区存在的副本数量。复制因子配置在可用性方面起着重要作用。N的复制因子允许您失去N-1个代理，同时仍然能够可靠地读取/写入记录到主题。</p><p id="cfa0" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">有两种类型的副本</p><ul class=""><li id="54cc" class="ka kb hi iw b ix iy jb jc jf kc jj kd jn ke jr kf kg kh ki bi translated"><strong class="iw hj"> <em class="kj">领导者</em> </strong>:</li></ul><p id="742e" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">一个分区由集群中的一个代理拥有，该代理被称为该分区的领导者。正如我们所知，生产者和消费者在领导者分区上执行写/读数据，同样的操作将在从者分区上复制。一旦分区领导者通过领导者选举被选出，关于新领导者的信息将被通知给所有代理</p><ul class=""><li id="43b0" class="ka kb hi iw b ix iy jb jc jf kc jj kd jn ke jr kf kg kh ki bi translated"><strong class="iw hj"> <em class="kj">跟随者</em> </strong> <em class="kj"> : </em></li></ul><p id="0d7d" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">从分区负责监控分区领导者，以复制与领导者中相同的读/写，并与领导者保持最新。最新的或与当前领导者同步的追随者是ISR列表的一部分，当当前领导者副本去世时，他们有资格参加领导者选举。</p><p id="5fe6" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw hj"> <em class="kj">一条记录如何从生产者传播到主题分区？</em> </strong></p><p id="5326" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">生产者从Zookeeper获取分区领导者信息，并且它总是向分区领导者发送记录，从者从分区领导者获取记录。当生产者向分区的领导者发送记录时，记录将被复制到从者(副本)分区，如下所示。</p><ol class=""><li id="e2f2" class="ka kb hi iw b ix iy jb jc jf kc jj kd jn ke jr kk kg kh ki bi translated">生产者向分区0(代理0处的领导者)发送记录，该记录将被传播到跟随者分区(如图中的代理1和代理2)。</li><li id="c2ec" class="ka kb hi iw b ix kl jb km jf kn jj ko jn kp jr kk kg kh ki bi translated">生产者向分区1(代理2处的领导者)发送记录，该记录将被传播到跟随者分区(如图中的代理0和代理1)。</li><li id="b68f" class="ka kb hi iw b ix kl jb km jf kn jj ko jn kp jr kk kg kh ki bi translated">生产者向分区2(代理1处的领导者)发送记录，该记录将被传播到跟随者分区(如图中的代理0和代理2)。</li></ol><figure class="jt ju jv jw fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es kq"><img src="../Images/fa4b3ff63c821bde0acb2d6dda0d5387.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*guEDe4fkl6WRMx738V1FBg.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">例子:卡夫卡领导，追随者记录从领导流向追随者</figcaption></figure><p id="f48a" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw hj"> ISR —同步副本</strong></p><p id="45c9" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">ISR是与当前分区领导者数据完全同步的代理(即，分区偏移号反映领导者和ISR的相同)，当当前分区领导者失败时，控制器负责通过领导者选举从ISR列表中选择一个代理作为分区领导者。</p><p id="ffb2" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw hj">确认(ack)</strong></p><p id="c2cd" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">确认—“确认”表示在将消息视为成功写入之前，确认消息的代理数量。ack将在生产者处配置。</p><p id="a110" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">“ack”接受3个值“0”、“1”和“全部”</p><ol class=""><li id="df8c" class="ka kb hi iw b ix iy jb jc jf kc jj kd jn ke jr kk kg kh ki bi translated"><strong class="iw hj">T5】ack = 0T7】</strong></li></ol><figure class="jt ju jv jw fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es kr"><img src="../Images/05f26ebc38ea1544a5815c164bdfef6a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BRaYRgcP4zhL6Obgv2tXaw.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">例如:Kafka acknowledge-acks = 0</figcaption></figure><p id="36eb" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">这里，Producer不会等待来自代理的确认，而是转到下一个请求。一旦制作者发送了记录，就认为记录发送成功。在这种情况下，producer不知道记录是成功发布到代理，还是由于某些错误而失败。使用此设置，消息丢失的可能性很高。</p><p id="d922" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">该设置可用于实现非常高的吞吐量，因为生产者可以以网络支持的速度发送消息。</p><p id="fac0" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><em class="kj"> 2。</em><strong class="iw hj"><em class="kj">ack = 1</em></strong></p><figure class="jt ju jv jw fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ks"><img src="../Images/d11a45d27a9c0160bd0a29c69eb2d5e1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZEwkh5u4J4vqpldlVgkMyg.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">示例:卡夫卡确认—确认=1</figcaption></figure><p id="c20c" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">一旦主副本收到消息，代理(带有主分区)就向生产者发送成功响应。</p><p id="0f93" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">如果主代理终止/未能接收到消息，生产者可能会收到错误响应，并可以重试发送消息。</p><p id="153b" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">与“acks = 0”相比，此设置减少了丢失消息的百分比，因为生产者等待来自领导者副本的确认，但是吞吐量可能下降(取决于同步/异步传输),因为生产者等待领导者确认。</p><p id="17ba" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">3.<strong class="iw hj"><em class="kj">ack = All</em></strong></p><figure class="jt ju jv jw fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es kt"><img src="../Images/ec85fda219c99cd15b8735495ad74f62.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yuzAAkJHGSSZq1p1Jnk8Ng.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">例如:卡夫卡致谢—确认=全部</figcaption></figure><p id="5f9d" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">在这里，一旦所有同步副本接收到记录，生产者将认为写入成功。</p><p id="fd04" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">该设置确保记录是安全的，因为多个代理接收该消息，并且该消息即使在崩溃的情况下也将继续存在。</p><p id="f1e7" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">注意:有些情况下，leader是使用复制因子为1、分区为1、一个代理创建的唯一同步副本(or)主题。设置“acks = all”可能会根据最低ISR配置给出错误响应。</p><p id="e39c" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw hj">动物园管理员</strong></p><p id="854c" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">动物园管理员负责</p><ul class=""><li id="bb5a" class="ka kb hi iw b ix iy jb jc jf kc jj kd jn ke jr kf kg kh ki bi translated">集群成员 : Kafka使用Zookeeper来维护当前集群成员的经纪人列表。每个代理用唯一的代理id向Zookeeper注册。</li><li id="af63" class="ka kb hi iw b ix kl jb km jf kn jj ko jn kp jr kf kg kh ki bi translated"><em class="kj">控制器选举</em> <strong class="iw hj"> : </strong>在集群中启动的第一个代理通过在Zookeeper中创建一个ephermal节点成为控制器。Zookeeper维护控制器信息和其他代理信息。当当前控制者死亡时，Zookeeper从列表中的活动代理中选择新的控制者。</li><li id="ff72" class="ka kb hi iw b ix kl jb km jf kn jj ko jn kp jr kf kg kh ki bi translated"><em class="kj">主题配置</em> : Zookeeper维护主题元数据——如所有主题的列表、每个主题的分区数量、所有副本的分区领导信息和位置、主题的定制/覆盖配置等..</li><li id="9a31" class="ka kb hi iw b ix kl jb km jf kn jj ko jn kp jr kf kg kh ki bi translated">ACL(访问控制列表) : Zookeeper维护ACL信息，帮助控制谁可以做什么。</li></ul><p id="df22" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw hj">代理(或)节点(或)引导服务器</strong></p><p id="1b28" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">它是一个实例/虚拟机/物理机，Kafka在其中运行。在卡夫卡的世界里，服务器被称为代理。</p><p id="b011" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">Kafka Broker负责管理分区，处理来自客户端(生产者、消费者)的读/写请求，管理分区复制。</p><p id="194f" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw hj">控制器代理(或)集群控制器(或)控制器:</strong></p><p id="fa64" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">Kafka集群只不过是一组一个或多个代理，其中一个代理充当集群控制器(当活动控制器由于某种原因死亡/失败时，在集群中启动的第一个代理成为从集群的活动成员中自动选出的控制器)。在任一时间点，群集只能有一个活动控制器。</p><p id="d9fd" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">控制者就像一个普通的经纪人，有额外的责任。它将履行管理分区、处理读/写请求、管理分区复制等常见代理职责。</p><p id="82db" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">控制器的其他职责包括—将分区分配给代理，跟踪节点，适当处理加入/失败/离开集群的代理，并相应地重新分配分区。</p></div><div class="ab cl ku kv gp kw" role="separator"><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz"/></div><div class="hb hc hd he hf"><p id="1c21" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">这就是这篇关于Kafka基础的文章，希望它有助于从Kafka学习开始对Kafka组件有一个基本的概述。</p><p id="e62f" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">将撰写新文章来深入理解这些组件。</p><p id="911e" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">学习Kafka Connect: <a class="ae lb" href="https://techcolors.medium.com/kafka-connect-quick-start-e9249ec2bbaa" rel="noopener"> Kafka Connect:快速入门</a></p><p id="d8cf" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">参考:<br/><a class="ae lb" href="https://kafka.apache.org/documentation/" rel="noopener ugc nofollow" target="_blank">https://kafka.apache.org/documentation/</a><br/><a class="ae lb" href="https://docs.confluent.io/home/kafka-intro.html" rel="noopener ugc nofollow" target="_blank">https://docs.confluent.io/home/kafka-intro.html</a></p></div></div>    
</body>
</html>