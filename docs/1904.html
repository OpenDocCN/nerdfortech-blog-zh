<html>
<head>
<title>Difference between var, let and const</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">var、let 和 const 之间的差异</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/difference-between-var-let-and-const-7aec1b81da2?source=collection_archive---------9-----------------------#2021-04-12">https://medium.com/nerd-for-tech/difference-between-var-let-and-const-7aec1b81da2?source=collection_archive---------9-----------------------#2021-04-12</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/025c28c582876a8445cd15090ed07f54.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*1ARTK5_5yA8GO6_e"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">由<a class="ae iu" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上<a class="ae iu" href="https://unsplash.com/@grakozy?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Greg Rakozy </a>拍摄的照片</figcaption></figure><p id="9c4c" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">注意:</strong>这篇文章只写给 JavaScript 初学者，他们不明白为什么做同样的工作(声明变量)有三个关键字，以及何时何地使用哪一个。</p><p id="9583" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">随着 ES6 (ES 2015)的出现，JavaScript 的一些缺点随着许多新功能的实现而得到了解决，其中之一是 let 和 const 关键字。以前版本的 JavaScript 只有一种声明变量的方法，即使用“var”关键字。ES6 随后引入了“let”和“const”关键字，它们也用于声明和初始化变量，但应用程序不同。在本文中，我们将看到这三者是如何变化的。</p><h1 id="f806" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated"><strong class="ak"> 1。var </strong></h1><p id="0de9" class="pw-post-body-paragraph iv iw hi ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated">在早期的 JavaScript 代码中，你只会看到用这个关键字声明的变量。Var 是一个全局作用域或函数作用域的关键字，具体取决于它的声明位置。在函数外部声明的变量具有全局作用域，而在函数内部声明的变量具有函数作用域。可以通过浏览器窗口访问全局范围的变量。尽管不使用全局变量是明智的，但是在一些应用中需要使用全局变量。</p><p id="7a66" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">使用 var 的示例</p><pre class="kw kx ky kz fd la lb lc ld aw le bi"><span id="cc66" class="lf ju hi lb b fi lg lh l li lj">var name;           //declared globally<br/>name = ”John” //Initialization<br/>function greet(){<br/>     var lastname = “Doe”    // Declared and initialized locally<br/>     console.log("Hello " +name+" "+lastname);<br/>}<br/>greet()</span></pre><p id="b2a2" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如果我们试图在函数之外访问 lastname，它会抛出一个错误</p><pre class="kw kx ky kz fd la lb lc ld aw le bi"><span id="35ce" class="lf ju hi lb b fi lg lh l li lj">var name = "John"<br/>function greet(){<br/>   var lastname = “Doe”             <br/>   console.log("Hello " +name+" "+lastname);  <br/>}<br/>console.log(lastname)   //Error: lastname is not defined<br/>greet()</span></pre><p id="323d" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">输出:</p><figure class="kw kx ky kz fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lk"><img src="../Images/45ab509179fbc38026f1042e8509fe6e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LZVe8piIPSDDHnXAurSweA.png"/></div></div></figure><p id="8b84" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">注意:</strong>在 JS 中声明全局变量的另一种方式是直接在窗口对象上声明，比如</p><p id="2a6b" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">window.name = "John "</p><p id="7b2f" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">尽管默认情况下，所有用 var 关键字声明的全局变量也可以用 window 对象访问。在上面的例子中，尝试使用 window 对象访问“name ”,如下所示，并查看输出。</p><pre class="kw kx ky kz fd la lb lc ld aw le bi"><span id="ed9b" class="lf ju hi lb b fi lg lh l li lj">console.log(window.name)</span></pre><p id="4c1e" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">上面应该印着“约翰”。</p><p id="34c9" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">值得注意的一点是，使用 var 关键字，变量<strong class="ix hj">可以被重新声明和重新分配</strong>来存储一个新值，而不会有任何错误。</p><p id="a3c1" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">例如:</p><pre class="kw kx ky kz fd la lb lc ld aw le bi"><span id="f4dd" class="lf ju hi lb b fi lg lh l li lj">var name = ”John”<br/>var name = “John Doe”<br/>function greet(){<br/>    var age = 23   <br/>    console.log(“Hello I am “ +name+" and I am"+age+" years old");<br/>}<br/>greet()</span></pre><p id="0201" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">输出:</p><figure class="kw kx ky kz fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ll"><img src="../Images/6f28ffd4304ef9c074ea5ab2d7b4bc79.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EhqeEEE0c81GKRqpQjQSNg.png"/></div></div></figure><p id="9d37" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这可能会有问题，因为如果在代码的其他地方声明了同名的变量，而我们在不知情的情况下重新定义了它，这可能会破坏代码。这个缺点已经在“let”关键字中解决了。</p><h2 id="2b90" class="lf ju hi bd jv lm ln lo jz lp lq lr kd jg ls lt kh jk lu lv kl jo lw lx kp ly bi translated"><strong class="ak">带 var 的吊装</strong></h2><p id="ff79" class="pw-post-body-paragraph iv iw hi ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated">简而言之，提升是 JS“提升”的一个概念，即它在执行之前将变量声明移动到脚本的顶部。</p><p id="505a" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">用 var 关键字声明的变量被提升，这意味着变量声明被移动到脚本的顶部，尽管<strong class="ix hj">值没有被初始化</strong>。当一个变量被提升时，它会自动初始化为<strong class="ix hj">未定义。因此，即使我们使用变量，然后声明它，它也不会给我们一个错误！</strong></p><p id="9fdd" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">举例:</strong></p><pre class="kw kx ky kz fd la lb lc ld aw le bi"><span id="1bc5" class="lf ju hi lb b fi lg lh l li lj">z= z+2; <br/>console.log(z)<br/>var z = 1;</span></pre><p id="2370" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">输出:</p><figure class="kw kx ky kz fd ij er es paragraph-image"><div class="er es lz"><img src="../Images/4168961ebc9984e2c8415d344a3d9872.png" data-original-src="https://miro.medium.com/v2/resize:fit:1182/format:webp/1*QFFq7y0T6ZUsyI68iqzE4Q.png"/></div></figure><p id="d879" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">上面的代码执行如下:</p><pre class="kw kx ky kz fd la lb lc ld aw le bi"><span id="b1e5" class="lf ju hi lb b fi lg lh l li lj">var z; //initialised to undefined<br/>z = z+2;<br/>console.log(z)<br/>z = 1;</span></pre><h1 id="37d7" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated"><strong class="ak"> 2。让</strong></h1><p id="fb68" class="pw-post-body-paragraph iv iw hi ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated">let 是对 var 关键字的重大改进。用 let 关键字声明的变量是块范围的。块是写在花括号{ }之间的任何代码。块范围的变量只能在该块中访问。</p><p id="931a" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">示例:</p><pre class="kw kx ky kz fd la lb lc ld aw le bi"><span id="ce11" class="lf ju hi lb b fi lg lh l li lj">let x = 1;<br/>if(x == 1){<br/>  let y = 2;<br/>  console.log(y) //2<br/>}<br/>console.log(x) //1</span></pre><p id="0c00" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如果我们在一个块中声明一个变量，并试图在外部访问它，它会给我们一个错误。</p><p id="6290" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">例如:</p><pre class="kw kx ky kz fd la lb lc ld aw le bi"><span id="2767" class="lf ju hi lb b fi lg lh l li lj">let x = 1;<br/>if(x == 1){<br/>  let y = x+x;<br/>  console.log(y) // 2<br/>}<br/>console.log(y) // Uncaught ReferenceError: y is not defined</span></pre><p id="3e4b" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">正如我们已经看到的，var 关键字会自动更新到全局对象，这与 let 不一样。</p><p id="b9ae" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">示例:</p><pre class="kw kx ky kz fd la lb lc ld aw le bi"><span id="4b59" class="lf ju hi lb b fi lg lh l li lj">var name = “Jane”<br/>let first_name = “Jane”<br/>console.log(window.name)<br/>console.log(window.first_name)</span></pre><p id="d28a" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">输出:</p><figure class="kw kx ky kz fd ij er es paragraph-image"><div class="er es ma"><img src="../Images/6e32933c704debf60e7d81d35262dcfc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1326/format:webp/1*gHI1B64WtRhADs4ddM--uA.png"/></div></figure><p id="654d" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在上一节中，我们还看到了如何重新声明带有 var 关键字的变量。对于用 let 声明的变量，情况就不一样了。如果我们试图在同一个作用域中重新声明<strong class="ix hj">变量，它将抛出一个错误。</strong></p><p id="127d" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">示例:</p><pre class="kw kx ky kz fd la lb lc ld aw le bi"><span id="c2e7" class="lf ju hi lb b fi lg lh l li lj">//While this will work<br/>let x = 1;<br/>if(x == 1){<br/>  let x = 2;<br/>  console.log(x)  //2 <br/>}<br/>console.log(x)   // 1</span><span id="a1db" class="lf ju hi lb b fi mb lh l li lj">//This redeclaration in the same scope will throw an error<br/>let x = 1;<br/>let x = 2;<br/>console.log(x) </span></pre><p id="3512" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">输出:</p><figure class="kw kx ky kz fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mc"><img src="../Images/48844ac4be844f1800739153c130eef6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Uxkd407TH00Rznlm3seynA.png"/></div></div></figure><p id="bba4" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">带 let 的变量不能<strong class="ix hj">重新声明，只能重新赋值。</strong></p><pre class="kw kx ky kz fd la lb lc ld aw le bi"><span id="6475" class="lf ju hi lb b fi lg lh l li lj">let x = 1;<br/>x = 2;</span></pre><h2 id="c97f" class="lf ju hi bd jv lm ln lo jz lp lq lr kd jg ls lt kh jk lu lv kl jo lw lx kp ly bi translated"><strong class="ak">用滑轮提升</strong></h2><p id="760e" class="pw-post-body-paragraph iv iw hi ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated">与 var 类似，let 变量声明也是悬挂的。然而，var 和 let 之间的主要区别在于<strong class="ix hj"> let 不是用值‘undefined’</strong>初始化的。只有当解析器对它求值时，才会给它赋值。</p><p id="540c" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">示例:</p><pre class="kw kx ky kz fd la lb lc ld aw le bi"><span id="f3e8" class="lf ju hi lb b fi lg lh l li lj">z = z + 2; <br/>console.log(z)<br/>let z = 1</span></pre><p id="547a" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">输出:</p><figure class="kw kx ky kz fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es md"><img src="../Images/3f06fbb2dd2d3a3c78aae9a964371159.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WXJ5mBk6dSC1SIi1qvVXkg.png"/></div></div></figure><p id="c721" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">因此，最佳实践是始终在变量使用范围的顶部声明变量，以避免错误。</p><h1 id="47e1" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">3.常数</h1><p id="6a8c" class="pw-post-body-paragraph iv iw hi ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated">顾名思义，const 用于具有常量值的变量。在程序的整个生命周期中，const 变量的值永远不会改变。就像 let 一样，const 也是块范围的，也就是说，它被限制在声明它的块中。当用 const 声明变量时，有必要用一个值来初始化它。这样做会导致错误:</p><pre class="kw kx ky kz fd la lb lc ld aw le bi"><span id="e06b" class="lf ju hi lb b fi lg lh l li lj">const PI; //By convention, constants are written in all caps.<br/>PI = 3.14;</span></pre><p id="94ac" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">使用 const，您<strong class="ix hj">不能重新声明或重新分配</strong>变量的值。</p><pre class="kw kx ky kz fd la lb lc ld aw le bi"><span id="0787" class="lf ju hi lb b fi lg lh l li lj">const PI = 3.14;<br/>PI = 22/7;    //TypeError</span><span id="29c5" class="lf ju hi lb b fi mb lh l li lj">const PI = 3.14159; //SyntaxError</span></pre><p id="00c7" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">用 var 或 let 重新声明 PI 也会导致错误:</p><pre class="kw kx ky kz fd la lb lc ld aw le bi"><span id="bc12" class="lf ju hi lb b fi lg lh l li lj">const PI = 3.14;<br/>var PI = 3.14; //SyntaxError<br/>let PI = 3.14; //SyntaxError</span></pre><p id="dac1" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">const 也可以处理对象和数组。对象文字有键值对。键也称为对象的属性。对象的编写方式如下:</p><pre class="kw kx ky kz fd la lb lc ld aw le bi"><span id="f341" class="lf ju hi lb b fi lg lh l li lj">OBJ1 = {<br/>first_name: ’John’,<br/>last_name: ‘Doe’<br/>}</span></pre><p id="8f28" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">用 const 声明的对象不能更新或重新声明对象本身，但它只能更新对象的属性。</p><p id="754b" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">现在，让我们尝试通过添加新属性来更新对象:</p><pre class="kw kx ky kz fd la lb lc ld aw le bi"><span id="9368" class="lf ju hi lb b fi lg lh l li lj">const OBJ1 = {<br/>   first_name : “John”,<br/>   last_name: "Doe”<br/>}<br/>OBJ1 = {<br/>  first_name : “Jane”,<br/>  last_name : “Doe”,<br/>  age:23<br/>}</span></pre><p id="4596" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">输出:</p><figure class="kw kx ky kz fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es me"><img src="../Images/80fc2856cffb91c56a52d801ebe405bb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_NCXGuTNxExbZlGdUp5dUg.png"/></div></div></figure><p id="cace" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这导致了如上所示的错误。</p><p id="b2e0" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">但是我们可以这样做:</p><pre class="kw kx ky kz fd la lb lc ld aw le bi"><span id="b9c1" class="lf ju hi lb b fi lg lh l li lj">const OBJ1 = {<br/>first_name : “John”,<br/>last_name : "Doe"<br/>}<br/>console.log(OBJ1)<br/>OBJ1.first_name = “Jane”<br/>OBJ1.last_name = “Doe”<br/>console.log(OBJ1)</span></pre><p id="d70b" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">输出:</p><figure class="kw kx ky kz fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mf"><img src="../Images/f5aeabc5def51cd8348224dc8d9a0e60.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nko4J-_WRN1Hmo46a3anqw.png"/></div></div></figure><p id="d34f" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们可以看到对象中的属性值已经更新。</p><p id="0de8" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">数组也是一样，我们可以把值放入变量中，也可以更新数组中的值，但是我们不能给数组重新赋值。</p><pre class="kw kx ky kz fd la lb lc ld aw le bi"><span id="95e3" class="lf ju hi lb b fi lg lh l li lj">const ARR1 = [];<br/>ARR1.push(1);<br/>ARR1.push(2)<br/>ARR1[0] = 2;<br/>console.log(ARR1) //2,2<br/>ARR1 =[3] //Error: Assignment to constant variable.</span></pre><h2 id="7839" class="lf ju hi bd jv lm ln lo jz lp lq lr kd jg ls lt kh jk lu lv kl jo lw lx kp ly bi translated"><strong class="ak">用常量吊装</strong></h2><p id="1629" class="pw-post-body-paragraph iv iw hi ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated">像 let 一样，const 声明被提升但不初始化。</p><h1 id="be2e" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated"><strong class="ak">结论</strong></h1><p id="c1b3" class="pw-post-body-paragraph iv iw hi ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated">let 和 const 是声明变量的 var 的新替代方法，现在可以安全使用。虽然三个都可以。大多数 JS 专家都强烈反对使用 var，因为它容易出错，大型应用程序很难维护。我个人已经用 let 和 const 代替了 var，这是一个很好的实践。</p><h2 id="6d43" class="lf ju hi bd jv lm ln lo jz lp lq lr kd jg ls lt kh jk lu lv kl jo lw lx kp ly bi translated">参考</h2><p id="af2f" class="pw-post-body-paragraph iv iw hi ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated"><a class="ae iu" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/const" rel="noopener ugc nofollow" target="_blank">https://developer . Mozilla . org/en-US/docs/Web/JavaScript/Reference/Statements/const</a></p><p id="9a13" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><a class="ae iu" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/let" rel="noopener ugc nofollow" target="_blank">https://developer . Mozilla . org/en-US/docs/Web/JavaScript/Reference/Statements/let</a></p><p id="dbe9" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><a class="ae iu" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/var" rel="noopener ugc nofollow" target="_blank">https://developer . Mozilla . org/en-US/docs/Web/JavaScript/Reference/Statements/var</a></p><p id="524f" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><a class="ae iu" href="https://developer.mozilla.org/en-US/docs/Learn/JavaScript/First_steps/Variables" rel="noopener ugc nofollow" target="_blank">https://developer . Mozilla . org/en-US/docs/Learn/JavaScript/First _ steps/Variables</a></p></div></div>    
</body>
</html>