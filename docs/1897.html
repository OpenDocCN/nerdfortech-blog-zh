<html>
<head>
<title>Fetch API, Async/Await in a few bites</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">几分钟后获取API、Async/Await</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/fetch-api-async-await-in-a-few-bites-6b4f19f7db9e?source=collection_archive---------2-----------------------#2021-04-12">https://medium.com/nerd-for-tech/fetch-api-async-await-in-a-few-bites-6b4f19f7db9e?source=collection_archive---------2-----------------------#2021-04-12</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/5a3819e0464d6da40af8cbe68977df93.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XiQR9iuI1iomPscAwUdOug.jpeg"/></div></div></figure><h1 id="c71c" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">获取API</h1><p id="d8d1" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">Fetch允许通过编写比使用XMLHttpRequest更少的代码来执行网络请求，并且它在幕后实现了promise API。</p><p id="79fa" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">使用fetch的代码示例:</p><pre class="kr ks kt ku fd kv kw kx ky aw kz bi"><span id="2a50" class="la ir hi kw b fi lb lc l ld le">fetch("./data/list.json")<br/>  .then((response) =&gt; {<br/>    console.log("resolved", response);<br/>  })<br/>  .catch((err) =&gt; {<br/>    console.log("error retrieving data", err);<br/>  });</span></pre><ol class=""><li id="13bc" class="lf lg hi jq b jr km jv kn jz lh kd li kh lj kl lk ll lm ln bi translated">Fetch将获取数据的URL端点作为参数。这可以是内部或外部资源。</li><li id="10db" class="lf lg hi jq b jr lo jv lp jz lq kd lr kh ls kl lk ll lm ln bi translated"><strong class="jq hj"> Fetch返回一个可以用<strong class="jq hj">处理的承诺</strong>。那么方法</strong>我们已经在<a class="ae lt" href="https://alicemoretti.medium.com/xmlhttprequest-callbacks-and-promises-257a4e63fe9a" rel="noopener">以前的博文</a>中看到了。</li><li id="e664" class="lf lg hi jq b jr lo jv lp jz lq kd lr kh ls kl lk ll lm ln bi translated">如果承诺被<strong class="jq hj">解决</strong>，则回调函数。然后被开除。如果承诺被<strong class="jq hj">拒绝</strong>(例如检索数据时出现问题)，的回调函数。catch被解雇了。</li></ol><p id="c850" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated"><strong class="jq hj">URL端点出错</strong></p><p id="84f2" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">需要强调的一件有趣的事情是，如果我们拼错了URL端点，承诺仍然会被解析，但是响应对象statusText属性将为空。</p><figure class="kr ks kt ku fd ij er es paragraph-image"><div class="er es lu"><img src="../Images/a1d2a8c08de4b37ef8ef0a6e5394094c.png" data-original-src="https://miro.medium.com/v2/resize:fit:416/format:webp/1*6zVpgD08qz6E8g0oW97Tiw.png"/></div><figcaption class="lv lw et er es lx ly bd b be z dx translated">响应对象的statusText属性</figcaption></figure><p id="edfd" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">为了确保获得包含实际数据的对象，我们可以检查请求状态值，如果该值不同于200，则突出显示一个错误(下面我们将看到如何抛出一个错误，以便捕获错误对象)。</p><pre class="kr ks kt ku fd kv kw kx ky aw kz bi"><span id="dde8" class="la ir hi kw b fi lb lc l ld le">fetch("./data/listsssss.json")<br/>  .then((response) =&gt; {<br/>    if (response.status !== 200) {<br/>      console.log("there is an error");<br/>    }<br/>    console.log("resolved", response);<br/>  })<br/>  .catch((err) =&gt; {<br/>    console.log("error retrieving data", err);<br/>  });</span></pre><p id="9abe" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated"><strong class="jq hj">我的数据在哪里？</strong></p><p id="259e" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">假设端点拼写正确，并且我们获得了数据对象，如果您console.log响应，您会注意到实际的数据并不在那里。为了能够看到和使用这些数据，我们需要应用<strong class="jq hj">。json方法</strong>解析数据字符串并返回一个js对象。这个方法是我们通过使用fetch API得到的响应对象的一部分，并且<strong class="jq hj">返回一个承诺。</strong>这意味着我们不能将它的值存储在如下所示的变量中:</p><pre class="kr ks kt ku fd kv kw kx ky aw kz bi"><span id="4382" class="la ir hi kw b fi lb lc l ld le">let myData = response.json() THIS IS WROOOOOONG!</span></pre><p id="c72b" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">相反，我们可以退回承诺，然后再锁住另一个。then方法将实际解析的数据作为参数:</p><pre class="kr ks kt ku fd kv kw kx ky aw kz bi"><span id="e6a2" class="la ir hi kw b fi lb lc l ld le">fetch("./data/list.json")<br/>  .then((response) =&gt; {<br/>    console.log("resolved", response);</span><span id="8ee3" class="la ir hi kw b fi lz lc l ld le">return response.json();<br/>  })<br/>  .then((data) =&gt; {<br/>    console.log(data);<br/>  })<br/>  .catch((err) =&gt; {<br/>    console.log("error retrieving data", err);<br/>  });</span></pre><p id="8e78" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">有一件事可能超级简单，但我不想想当然:“响应”和“数据”都是任意的词。是的，我把“response”改成了“MarioRossi”，这样代码就工作了(然后我想恢复文本可能是明智的，特别是当我知道有一些约定可以使代码更可读和更容易理解时:-))。</p><p id="029c" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated"><strong class="jq hj">分三步获取API</strong></p><p id="cba6" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">总结一下，当我们使用fetch时:</p><ol class=""><li id="4c25" class="lf lg hi jq b jr km jv kn jz lh kd li kh lj kl lk ll lm ln bi translated">我们通过提供URL端点来获取数据</li><li id="9826" class="lf lg hi jq b jr lo jv lp jz lq kd lr kh ls kl lk ll lm ln bi translated">我们返回response.json承诺</li><li id="7773" class="lf lg hi jq b jr lo jv lp jz lq kd lr kh ls kl lk ll lm ln bi translated">我们链接了一个. then方法，最终可以访问数据</li></ol><p id="87a2" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">最重要的是，代码比编写一个<a class="ae lt" href="https://alicemoretti.medium.com/xmlhttprequest-callbacks-and-promises-257a4e63fe9a" rel="noopener"> XMLHttpRequest </a>要简单得多！</p><h1 id="f935" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">异步/等待</h1><p id="ba87" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">async和await语法允许我们更容易、更干净地链接承诺。要使用async创建异步函数，我们编写:</p><pre class="kr ks kt ku fd kv kw kx ky aw kz bi"><span id="ad53" class="la ir hi kw b fi lb lc l ld le">let myAsyncFunction = async () =&gt; {<br/>...here we write all the asynchronous code...<br/>}</span></pre><p id="3a26" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated"><strong class="jq hj">通过添加“async”关键字，整个函数返回一个承诺</strong>。我们可以通过将该函数放入一个变量中来证明这一点，然后console.log它:</p><pre class="kr ks kt ku fd kv kw kx ky aw kz bi"><span id="97c6" class="la ir hi kw b fi lb lc l ld le">let newVariable = myAsyncFunction()<br/>console.log(newVariable)</span></pre><figure class="kr ks kt ku fd ij er es paragraph-image"><div class="er es ma"><img src="../Images/e7c018bfc704e15728f9659ab15f0279.png" data-original-src="https://miro.medium.com/v2/resize:fit:922/format:webp/1*oJdF7nDgimqXdsY_vA9fvA.png"/></div><figcaption class="lv lw et er es lx ly bd b be z dx translated">承诺</figcaption></figure><p id="316c" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">async/await与fetch配合得很好，因为它允许以一种超级简单的方式处理承诺。让我们来看看:</p><p id="b301" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">Fetch返回一个承诺，因此我们不能将结果对象存储在变量中。<strong class="jq hj">为了解决这个问题，async附带了一个有用的关键字“await”</strong>:</p><pre class="kr ks kt ku fd kv kw kx ky aw kz bi"><span id="411c" class="la ir hi kw b fi lb lc l ld le">let myAsyncFunction = async () =&gt; {<br/>  let response = await fetch("./data/list.json");<br/>  console.log(response);<br/>};</span></pre><p id="9644" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated"><strong class="jq hj">通过添加“await”关键字，响应对象不会存储在响应变量中，直到承诺被解析。</strong></p><p id="f415" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">继续，通过console.log响应，我们将看到实际的数据是不可见的，如上所述，我们需要应用。返回承诺的json方法。同样，我们可以通过使用“await”关键字来处理这个承诺:</p><pre class="kr ks kt ku fd kv kw kx ky aw kz bi"><span id="fdd7" class="la ir hi kw b fi lb lc l ld le">let myAsyncFunction = async () =&gt; {<br/>  let response = await fetch("./data/list.json");<br/>  let data = await response.json;<br/>  console.log(data);<br/>  return data;</span><span id="0ec3" class="la ir hi kw b fi lz lc l ld le">};</span></pre><p id="1a91" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">调用myAsyncFunction()返回一个承诺，由于函数内部的代码返回数据，我们可以应用。然后，将数据作为参数的方法(我们将在下一段描述错误情况下会发生什么):</p><pre class="kr ks kt ku fd kv kw kx ky aw kz bi"><span id="8927" class="la ir hi kw b fi lb lc l ld le">myAsyncFunction().then((data) =&gt; {<br/>  console.log("resolved", data);<br/>});</span></pre><p id="d2d9" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">由于是一个异步函数，<strong class="jq hj"> myAsyncFunction()不会阻止其余代码运行</strong>，我们可以用下面的代码来证明这一点:</p><pre class="kr ks kt ku fd kv kw kx ky aw kz bi"><span id="8336" class="la ir hi kw b fi lb lc l ld le">console.log("1");<br/>console.log("2");<br/>console.log("3");<br/>myAsyncFunction()<br/>  .then((data) =&gt; {<br/>    console.log("resolved", data);<br/>  })<br/>  .catch((err) =&gt; {<br/>    console.log("rejected", err);<br/>  });<br/>console.log("4");</span></pre><p id="c26e" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">在控制台中，我们将看到1、2、3、4，最后是响应对象。</p><p id="bfda" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated"><strong class="jq hj">async/await语法不仅允许我们用await关键字更清晰地链接承诺，还允许我们在变量中存储一个异步函数，这使得调用函数更容易。</strong></p><h1 id="d6a8" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">投掷错误</h1><p id="f533" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">如果json文件的语法有问题(假设我们忘记在键上加双引号)，那么response.json返回的承诺将被拒绝，整个异步函数的承诺也将被拒绝。这意味着我们可以捕捉错误。在下面的示例中，我们访问err对象的error属性:</p><pre class="kr ks kt ku fd kv kw kx ky aw kz bi"><span id="410a" class="la ir hi kw b fi lb lc l ld le">.catch((err) =&gt; {<br/>    console.log("rejected", err.message);<br/>  });</span></pre><figure class="kr ks kt ku fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mb"><img src="../Images/99e759d269d98869b93b7a7b13738bad.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nppQXLNGyP2OfEE-r1cGqw.png"/></div></div><figcaption class="lv lw et er es lx ly bd b be z dx translated">我们在控制台上看到的。</figcaption></figure><p id="bcd3" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">我想谈的另一个错误场景稍微有点难以处理。如果ULR端点拼写错误，该承诺仍将被解析。json方法仍然会解析响应，结果将是一个错误。</p><p id="52e7" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">为了防止这种情况发生，我们需要手动检查响应的状态，如果这与200 <strong class="jq hj">不同，我们将抛出一个错误</strong>。这将防止。来自“踢进”的json方法。</p><pre class="kr ks kt ku fd kv kw kx ky aw kz bi"><span id="8e0d" class="la ir hi kw b fi lb lc l ld le">let myAsyncFunction = async () =&gt; {<br/>  const response = await fetch("./data/lists.json");<br/>  if (response.status !== 200) {<br/>    throw new Error("cannot fetch data");<br/>  }<br/>  let data = await response.json();<br/>  return data;<br/>};</span><span id="a48b" class="la ir hi kw b fi lz lc l ld le">myAsyncFunction()<br/>  .then((data) =&gt; {<br/>    console.log("resolved", data);<br/>  })<br/>  .catch((err) =&gt; {<br/>    console.log("rejected", err.message);<br/>  });</span></pre><p id="6094" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">通过编写“抛出新错误”,我们创建了一个新的错误对象。每当我们在一个异步函数中抛出一个错误，那么它返回的承诺就会被拒绝，这样我们就可以捕捉到这个错误。</p><p id="25f1" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">错误消息现在将是“无法获取数据”。</p><p id="ec0e" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">我希望这篇博文和前一篇有助于理解更多关于网络请求的话题。</p></div><div class="ab cl mc md gp me" role="separator"><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh"/></div><div class="hb hc hd he hf"><p id="dde9" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">如果你认为文章的某些部分可以改进，或者你有任何想法想分享，请在下面留下评论。</p></div></div>    
</body>
</html>