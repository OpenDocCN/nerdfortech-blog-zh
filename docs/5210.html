<html>
<head>
<title>Generative art in Processing — Dot matrix printer style</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">加工中的生成艺术—点阵打印机风格</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/generative-art-in-processing-dot-matrix-printer-style-ab4b5cb4f53e?source=collection_archive---------5-----------------------#2021-09-08">https://medium.com/nerd-for-tech/generative-art-in-processing-dot-matrix-printer-style-ab4b5cb4f53e?source=collection_archive---------5-----------------------#2021-09-08</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/81b37e248d8820031be7e499fd99c277.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3abBKV9ypglV_KQ13cxLSA.jpeg"/></div></div></figure><h1 id="a4b7" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">介绍</h1><h2 id="0ad4" class="jo ir hi bd is jp jq jr iw js jt ju ja jv jw jx je jy jz ka ji kb kc kd jm ke bi translated">什么是加工？</h2><p id="8e73" class="pw-post-body-paragraph kf kg hi kh b ki kj kk kl km kn ko kp jv kq kr ks jy kt ku kv kb kw kx ky kz hb bi translated"><a class="ae la" href="https://processing.org/" rel="noopener ugc nofollow" target="_blank"> Processing </a>是一种相对不太为人所知的编程语言，这很遗憾，因为它是对<a class="ae la" href="https://en.wikipedia.org/wiki/Creative_coding" rel="noopener ugc nofollow" target="_blank">创造性编码</a>和可视化最有用的语言之一。“开放处理”和“<a class="ae la" href="https://www.creativeapplications.net/category/processing/" rel="noopener ugc nofollow" target="_blank">CreativeApplications.Net</a>”网站展示了人们利用处理技术创造艺术和现场装置的天才方式。2013 年偶然发现了这门语言，在工作太忙之前学了一段时间。对生成艺术的兴趣突然复苏，让我再次思考美丽的语言。虽然它是基于 Java 的，但是语法更加简单和直观，有许多定制的内置函数和可用的模块来扩展功能。</p><h2 id="04f0" class="jo ir hi bd is jp jq jr iw js jt ju ja jv jw jx je jy jz ka ji kb kc kd jm ke bi translated">什么是点阵打印机？</h2><p id="8b78" class="pw-post-body-paragraph kf kg hi kh b ki kj kk kl km kn ko kp jv kq kr ks jy kt ku kv kb kw kx ky kz hb bi translated">出生于 80 年代或之前的人可能听说过<a class="ae la" href="https://en.wikipedia.org/wiki/Dot_matrix_printing" rel="noopener ugc nofollow" target="_blank">点阵打印机</a>。当时它们在办公室里很受欢迎。打印机使用针在纸上打印点，因此在打印任意图案时很有用。与现代打印机相比，它们非常慢，但是看到一个人创造的图案会引起怀旧之情！上学的时候，我经常让我哥哥用他办公室的打印机打印<a class="ae la" href="https://blog.hubspot.com/marketing/clip-art-history" rel="noopener ugc nofollow" target="_blank">剪贴画</a>，然后把它们当贴纸贴在我的书上。</p><figure class="lc ld le lf fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lb"><img src="../Images/437fafee6c3838f11d62d7809837e116.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*25ar8wCq32fKj_X_"/></div></div><figcaption class="lg lh et er es li lj bd b be z dx translated">点阵打印机打印的图像示例(来源:<a class="ae la" href="https://www.hackster.io/news/3d-printer-becomes-2d-dot-matrix-printer-using-web-app-8de2be90b09a" rel="noopener ugc nofollow" target="_blank"> hackster.io </a></figcaption></figure></div><div class="ab cl lk ll gp lm" role="separator"><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp"/></div><div class="hb hc hd he hf"><h1 id="ee61" class="iq ir hi bd is it lr iv iw ix ls iz ja jb lt jd je jf lu jh ji jj lv jl jm jn bi translated">创造艺术</h1><h2 id="f140" class="jo ir hi bd is jp jq jr iw js jt ju ja jv jw jx je jy jz ka ji kb kc kd jm ke bi translated">原象</h2><p id="5989" class="pw-post-body-paragraph kf kg hi kh b ki kj kk kl km kn ko kp jv kq kr ks jy kt ku kv kb kw kx ky kz hb bi translated">我用玛丽莲·梦露的肖像(来源:<a class="ae la" href="https://www.pexels.com/photo/marilyn-monroe-53453/" rel="noopener ugc nofollow" target="_blank"> Pexels </a>)来创作生成艺术，原图如下:</p><figure class="lc ld le lf fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lw"><img src="../Images/b98221178ce38693821d1ae754597c94.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lc5RL2_XwxrEeoRrzkZZng.jpeg"/></div></div></figure><h2 id="e4f2" class="jo ir hi bd is jp jq jr iw js jt ju ja jv jw jx je jy jz ka ji kb kc kd jm ke bi translated">代码背后的逻辑:</h2><p id="d5f6" class="pw-post-body-paragraph kf kg hi kh b ki kj kk kl km kn ko kp jv kq kr ks jy kt ku kv kb kw kx ky kz hb bi translated">点阵打印机用于修改点的密度，以描绘图像中的亮区和暗区。我计划做的是改变点的大小，而不是密度。较小的点将描绘较亮的区域，较大的点将描绘较暗的区域。代码不会像打印机一样打印图像，而是在画布上随机绘制一些点，玛丽莲的肖像就会从这些点显现出来。</p><h2 id="1129" class="jo ir hi bd is jp jq jr iw js jt ju ja jv jw jx je jy jz ka ji kb kc kd jm ke bi translated">初始设置:</h2><p id="c881" class="pw-post-body-paragraph kf kg hi kh b ki kj kk kl km kn ko kp jv kq kr ks jy kt ku kv kb kw kx ky kz hb bi translated">打开处理 IDE 后，首先编写这两个命令:</p><figure class="lc ld le lf fd ij"><div class="bz dy l di"><div class="lx ly l"/></div></figure><p id="ff68" class="pw-post-body-paragraph kf kg hi kh b ki lz kk kl km ma ko kp jv mb kr ks jy mc ku kv kb md kx ky kz hb bi translated"><code class="du me mf mg mh b">setup()</code>功能用于设置画布及其属性，如画布的大小、背景颜色、帧速率(如果是动画)等。</p><p id="7385" class="pw-post-body-paragraph kf kg hi kh b ki lz kk kl km ma ko kp jv mb kr ks jy mc ku kv kb md kx ky kz hb bi translated"><code class="du me mf mg mh b">draw()</code>函数本质上是一个循环，一遍又一遍地重复相同的命令，因此对于创建动画非常有用。如果你想要一个静态图像，同样的<code class="du me mf mg mh b">draw()</code>功能会被使用，它只会重复显示相同的图像。</p><h2 id="c560" class="jo ir hi bd is jp jq jr iw js jt ju ja jv jw jx je jy jz ka ji kb kc kd jm ke bi translated">设置画布:</h2><p id="d12e" class="pw-post-body-paragraph kf kg hi kh b ki kj kk kl km kn ko kp jv kq kr ks jy kt ku kv kb kw kx ky kz hb bi translated">我将创建一个大小为 600 x 600 像素的画布，动画的帧速率为 10。</p><figure class="lc ld le lf fd ij"><div class="bz dy l di"><div class="lx ly l"/></div></figure><h2 id="c4fa" class="jo ir hi bd is jp jq jr iw js jt ju ja jv jw jx je jy jz ka ji kb kc kd jm ke bi translated">在代码中导入图像:</h2><p id="0d30" class="pw-post-body-paragraph kf kg hi kh b ki kj kk kl km kn ko kp jv kq kr ks jy kt ku kv kb kw kx ky kz hb bi translated">第二步是导入原始图像，因为艺术将基于此生成。</p><figure class="lc ld le lf fd ij"><div class="bz dy l di"><div class="lx ly l"/></div></figure><p id="69df" class="pw-post-body-paragraph kf kg hi kh b ki lz kk kl km ma ko kp jv mb kr ks jy mc ku kv kb md kx ky kz hb bi translated"><code class="du me mf mg mh b">PImage</code>类用于导入和存储图像数据类型。首先，我将<code class="du me mf mg mh b">img</code>声明为<code class="du me mf mg mh b">PImage</code>类的变量，然后使用<code class="du me mf mg mh b">loadImage</code>将图像加载到变量中。最后，我调整图像大小以适合画布。<code class="du me mf mg mh b">width</code>和<code class="du me mf mg mh b">height</code>是两个存储画布尺寸的内置变量。</p><p id="aa62" class="pw-post-body-paragraph kf kg hi kh b ki lz kk kl km ma ko kp jv mb kr ks jy mc ku kv kb md kx ky kz hb bi translated">注意<code class="du me mf mg mh b">img</code>变量是在设置函数之外声明的，因为它被声明为一个全局变量。全局变量可以在代码中的任何地方使用，甚至可以在其他函数中使用。在函数中声明的局部变量只能在该函数中使用。</p><h2 id="1a84" class="jo ir hi bd is jp jq jr iw js jt ju ja jv jw jx je jy jz ka ji kb kc kd jm ke bi translated">准备拉伸循环:</h2><figure class="lc ld le lf fd ij"><div class="bz dy l di"><div class="lx ly l"/></div></figure><p id="b8f3" class="pw-post-body-paragraph kf kg hi kh b ki lz kk kl km ma ko kp jv mb kr ks jy mc ku kv kb md kx ky kz hb bi translated">画在画布上随机位置的点将是黑色的，没有笔画。<code class="du me mf mg mh b">fill</code>命令声明填充颜色。如果在命令中使用了 0 到 255 之间的单个数字，则处理将使用灰度。如果使用 3 个逗号分隔的数字，处理使用颜色(RGB 或 HSB，取决于提到的<code class="du me mf mg mh b">colorMode</code>)。<code class="du me mf mg mh b">noStroke</code>命令声明圆圈中没有笔划。</p><p id="7c7f" class="pw-post-body-paragraph kf kg hi kh b ki lz kk kl km ma ko kp jv mb kr ks jy mc ku kv kb md kx ky kz hb bi translated">重要的是将画布分成网格，并在网格的单元格内绘制点。这样，当(假想的)网格叠加在原始图像上时，我们可以提取每个单元格的亮度，并使用它们来决定要在里面绘制的点的大小。我声明单元格的大小为 5 个像素。</p><h2 id="4e98" class="jo ir hi bd is jp jq jr iw js jt ju ja jv jw jx je jy jz ka ji kb kc kd jm ke bi translated">在画布的随机位置画点:</h2><p id="48d0" class="pw-post-body-paragraph kf kg hi kh b ki kj kk kl km kn ko kp jv kq kr ks jy kt ku kv kb kw kx ky kz hb bi translated"><code class="du me mf mg mh b">draw</code>循环是一个非常好的迭代工具，因为它消除了使用<code class="du me mf mg mh b">for</code>或<code class="du me mf mg mh b">while</code>循环的需要。但是在每一帧画一个点会花很长时间来完成图像，所以我在每一帧画 100 个点来加速这个过程。</p><figure class="lc ld le lf fd ij"><div class="bz dy l di"><div class="lx ly l"/></div></figure><p id="1b54" class="pw-post-body-paragraph kf kg hi kh b ki lz kk kl km ma ko kp jv mb kr ks jy mc ku kv kb md kx ky kz hb bi translated">首先，使用两个<code class="du me mf mg mh b">for</code>循环创建一个嵌套循环，第一个用于 x 轴(行)，第二个用于 y 轴(列)。每个循环将运行 100 次迭代，以在画布中选择 100 个 x，y 坐标。使用<code class="du me mf mg mh b">random</code>选择随机坐标。在每次迭代中，随机的 x 和 y 位置作为整数保存在<code class="du me mf mg mh b">xloc</code>和<code class="du me mf mg mh b">yloc</code>变量中。将值保存为整数是必要的，因为我们将使用它们来提取每个像素的颜色，像素的数量是整数。</p><figure class="lc ld le lf fd ij"><div class="bz dy l di"><div class="lx ly l"/></div></figure><p id="667f" class="pw-post-body-paragraph kf kg hi kh b ki lz kk kl km ma ko kp jv mb kr ks jy mc ku kv kb md kx ky kz hb bi translated">下一步，我们提取每个细胞的颜色，并使用每个细胞颜色的亮度值，我们在里面画点。直接使用<code class="du me mf mg mh b">xloc</code>和<code class="du me mf mg mh b">yloc</code>值来提取颜色是错误的，因为它们会指向每个单元格左上角的像素。为了纠正错误，我将这些值乘以像元大小。<code class="du me mf mg mh b">PImage</code>类的<code class="du me mf mg mh b">get</code>方法用于提取每个随机选择的单元格的颜色。此后，使用<code class="du me mf mg mh b">brightness</code>功能提取每个单元颜色的亮度值。</p><p id="ada2" class="pw-post-body-paragraph kf kg hi kh b ki lz kk kl km ma ko kp jv mb kr ks jy mc ku kv kb md kx ky kz hb bi translated">由于亮度值的范围是从 0 到 255，如果直接使用这些值，产生的点将会太大。因此，为了限制单元格内点的大小，我使用<code class="du me mf mg mh b">map</code>函数将亮度值映射到 0–5(单元格大小)的范围内。映射被反转以停止结果图像的反转。</p><p id="daa6" class="pw-post-body-paragraph kf kg hi kh b ki lz kk kl km ma ko kp jv mb kr ks jy mc ku kv kb md kx ky kz hb bi translated">在最后一步，我们使用<code class="du me mf mg mh b">ellipse</code>功能在调整后的坐标中画出点。点的大小由映射的亮度值决定。</p><p id="6169" class="pw-post-body-paragraph kf kg hi kh b ki lz kk kl km ma ko kp jv mb kr ks jy mc ku kv kb md kx ky kz hb bi translated">不过，我需要做一个更正。由于<code class="du me mf mg mh b">xloc</code>和<code class="du me mf mg mh b">yloc</code>值的最小值为 0，并且由于加工以点的中心坐标绘制点(默认情况下)，左边缘和上边缘的点将被切成两半。为了防止这种情况，我们使用<code class="du me mf mg mh b">translate</code>函数将整个画布移动单元格大小的一半。</p><figure class="lc ld le lf fd ij"><div class="bz dy l di"><div class="lx ly l"/></div></figure><h2 id="c890" class="jo ir hi bd is jp jq jr iw js jt ju ja jv jw jx je jy jz ka ji kb kc kd jm ke bi translated">将帧存储为动画 GIF:</h2><p id="58e0" class="pw-post-body-paragraph kf kg hi kh b ki kj kk kl km kn ko kp jv kq kr ks jy kt ku kv kb kw kx ky kz hb bi translated">当您点击运行按钮时，创成式艺术在处理窗口中显示为动画，但是为了能够保存动画，我们需要提取帧。在<code class="du me mf mg mh b">draw</code>循环内部使用了<code class="du me mf mg mh b">saveFrame</code>函数来保存每一帧(记住，我在开始时将帧速率设置为 24)。</p><figure class="lc ld le lf fd ij"><div class="bz dy l di"><div class="lx ly l"/></div></figure><p id="48ec" class="pw-post-body-paragraph kf kg hi kh b ki lz kk kl km ma ko kp jv mb kr ks jy mc ku kv kb md kx ky kz hb bi translated">我把这些帧保存在一个名为 render 的文件夹中，每一帧都有一个数字序列，并保存为 PNG 格式(render001.png，render001.png 等)。).您也可以保存为 TIFF、TARGA 或 JPEG 文件，但 PNG 在质量和文件大小之间取得了最佳平衡。</p><p id="1513" class="pw-post-body-paragraph kf kg hi kh b ki lz kk kl km ma ko kp jv mb kr ks jy mc ku kv kb md kx ky kz hb bi translated">在处理过程中，可以使用 Movie Maker 工具将这些帧拼接成一个电影文件，但为了便于共享，我将其拼接成了一个动画 GIF。我用<a class="ae la" href="https://www.ffmpeg.org/" rel="noopener ugc nofollow" target="_blank"> FFMPEG </a>做了拼接，使用了以下命令(鸣谢:<a class="ae la" href="https://stackoverflow.com/a/29542944" rel="noopener ugc nofollow" target="_blank">栈溢出</a>):</p><pre class="lc ld le lf fd mi mh mj mk aw ml bi"><span id="f079" class="jo ir hi mh b fi mm mn l mo mp">ffmpeg -f image2 -framerate 24 -i render-%3d.png render.gif</span></pre></div><div class="ab cl lk ll gp lm" role="separator"><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp"/></div><div class="hb hc hd he hf"><h1 id="46ff" class="iq ir hi bd is it lr iv iw ix ls iz ja jb lt jd je jf lu jh ji jj lv jl jm jn bi translated">结果呢</h1><figure class="lc ld le lf fd ij er es paragraph-image"><div class="er es mq"><img src="../Images/f2d2f9e905c6450a4466336f54eee651.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/1*DXDo7mrMFJEaViF8yYZDbA.gif"/></div><figcaption class="lg lh et er es li lj bd b be z dx translated">版权:作者</figcaption></figure><p id="ba35" class="pw-post-body-paragraph kf kg hi kh b ki lz kk kl km ma ko kp jv mb kr ks jy mc ku kv kb md kx ky kz hb bi translated">结果看起来几乎像一个点阵打印的图像，从随机绘制的点出现的图像是美丽的。</p><p id="429e" class="pw-post-body-paragraph kf kg hi kh b ki lz kk kl km ma ko kp jv mb kr ks jy mc ku kv kb md kx ky kz hb bi translated">完整的代码如下所示:</p><figure class="lc ld le lf fd ij"><div class="bz dy l di"><div class="lx ly l"/></div></figure></div><div class="ab cl lk ll gp lm" role="separator"><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp"/></div><div class="hb hc hd he hf"><h1 id="f883" class="iq ir hi bd is it lr iv iw ix ls iz ja jb lt jd je jf lu jh ji jj lv jl jm jn bi translated">信用</h1><p id="df54" class="pw-post-body-paragraph kf kg hi kh b ki kj kk kl km kn ko kp jv kq kr ks jy kt ku kv kb kw kx ky kz hb bi translated">丹尼尔·希夫曼的《编码训练》——学习处理和获得灵感沉迷于创造性编码的最佳场所。</p></div></div>    
</body>
</html>