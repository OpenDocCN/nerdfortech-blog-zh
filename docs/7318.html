<html>
<head>
<title>Let’s play with Heterogeneous data types — purescript-heterogeneous — Exploring purescript-modules #2</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">让我们玩玩异构数据类型——pure script-异构——探索 pure script-模块#2</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/lets-play-with-heterogeneous-data-types-purescript-heterogeneous-847391430d00?source=collection_archive---------11-----------------------#2022-09-24">https://medium.com/nerd-for-tech/lets-play-with-heterogeneous-data-types-purescript-heterogeneous-847391430d00?source=collection_archive---------11-----------------------#2022-09-24</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="d412" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这是本系列的第二篇文章。在本文中，我们将研究专门为异构数据结构的映射和折叠开发的<code class="du jd je jf jg b">purescript-heterogeneous</code>包。好的，我这里说的异构数据结构是什么意思？</p><p id="8e48" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">所有一次可以保存多个值的类型被称为异构数据结构，或类型。例如，元组可以一次保存多个值，一个左值和一个右值。因此它们被称为异构数据类型。但是数组并不是异构的，因为所有的元素只能是一种类型。</p><figure class="ji jj jk jl fd jm er es paragraph-image"><div role="button" tabindex="0" class="jn jo di jp bf jq"><div class="er es jh"><img src="../Images/679f43310a73a2a245412e959df14a20.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6fOIDby58VpuhKTlhJKdGw.jpeg"/></div></div><figcaption class="jt ju et er es jv jw bd b be z dx translated">由<a class="ae jx" href="https://unsplash.com/@sharonmccutcheon?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">亚历山大·格雷</a>在<a class="ae jx" href="https://unsplash.com/s/photos/different-colors?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="bc5d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们在 purescript 中处理的最常见的异构类型是 Record。我一直想知道我们如何才能映射记录，然后我发现了这个奇妙的包<code class="du jd je jf jg b"><a class="ae jx" href="https://pursuit.purescript.org/packages/purescript-heterogeneous/0.3.0" rel="noopener ugc nofollow" target="_blank">purescript-heterogeneous</a></code></p><p id="4e8b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">首先，假设记录中的所有字段都是同类的(相同类型)</p><pre class="ji jj jk jl fd jy jg jz ka aw kb bi"><span id="c4a3" class="kc kd hi jg b fi ke kf l kg kh">type Names = <br/>  {  father     :: String<br/>  ,  mother     :: String<br/>  ,  son        :: String<br/>  ,  daughter   :: String<br/>  }</span></pre><p id="4bc7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">你想让每个字段都大写，你能用普通的<code class="du jd je jf jg b">map</code>做到吗？当然没有，为什么？因为 record 不是<a class="ae jx" href="https://pursuit.purescript.org/packages/purescript-prelude/6.0.1/docs/Data.Functor#t:Functor" rel="noopener ugc nofollow" target="_blank">函子</a>。</p><p id="2adf" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">那么我们如何做到这一点呢？</p><pre class="ji jj jk jl fd jy jg jz ka aw kb bi"><span id="31d2" class="kc kd hi jg b fi ke kf l kg kh">capitalizeNames :: Names -&gt; Names <br/>capitalizeNames names = hmap toUpper names</span></pre><p id="8e33" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">仔细看，我没用过<code class="du jd je jf jg b">map</code>我用的是<code class="du jd je jf jg b">hmap</code>，是套装提供的<code class="du jd je jf jg b">purescript-heterogeneous.</code></p></div><div class="ab cl ki kj gp kk" role="separator"><span class="kl bw bk km kn ko"/><span class="kl bw bk km kn ko"/><span class="kl bw bk km kn"/></div><div class="hb hc hd he hf"><p id="071f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我遇到过这样一种情况，我有一个记录，我只想给记录中的每个值加上<code class="du jd je jf jg b">Just</code>。我想知道我怎么能做到呢？我们能做类似上面的事情吗？</p><pre class="ji jj jk jl fd jy jg jz ka aw kb bi"><span id="b717" class="kc kd hi jg b fi ke kf l kg kh">justRecords names = hmap Just names -- will throw error</span></pre><p id="e647" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">不，我们不能，为什么？因为每个字段都可能是不同的类型，那么<code class="du jd je jf jg b">Just</code>的类型会是什么呢？<code class="du jd je jf jg b">String -&gt; Maybe String</code>或<code class="du jd je jf jg b">Int -&gt; Maybe Int</code>等……理想情况下应该是<code class="du jd je jf jg b">a -&gt; Maybe a</code></p><p id="12a3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为了封装<code class="du jd je jf jg b">a</code>,我们需要创建一个类型，(不要担心它非常简单)</p><p id="af80" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">首先创建一个类型，</p><pre class="ji jj jk jl fd jy jg jz ka aw kb bi"><span id="b207" class="kc kd hi jg b fi ke kf l kg kh">data MakeMaybe = MakeMaybe</span></pre><p id="f683" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">然后为异构包中定义的<code class="du jd je jf jg b">Mapping</code>类派生一个实例。</p><pre class="ji jj jk jl fd jy jg jz ka aw kb bi"><span id="b331" class="kc kd hi jg b fi ke kf l kg kh">instance makeMaybeMapping :: Mapping MakeMaybe a (Maybe a) <br/> where<br/>     mapping MakeMaybe = Just</span></pre><p id="bd3a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">映射类型类有 3 个参数，第一个是你创建的单态类型，第二个和第三个是映射函数<code class="du jd je jf jg b">(a -&gt; b).</code>中的<code class="du jd je jf jg b">a</code>和<code class="du jd je jf jg b">b</code>，在我们的例子中是<code class="du jd je jf jg b">a -&gt; Maybe a</code></p><p id="8ac7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在上面的代码中，我告诉使用<code class="du jd je jf jg b">Just</code>将类型<code class="du jd je jf jg b">a</code>转换为<code class="du jd je jf jg b">Maybe a</code>，你也可以用<code class="du jd je jf jg b">Nothing</code>代替<code class="du jd je jf jg b">Just</code>，这将把每个字段转换为<code class="du jd je jf jg b">Nothing</code>(但是谁会想要这样的函数呢？😑)</p><p id="3d75" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">使用它也很容易，你只需要使用你已经创建的类型。</p><pre class="ji jj jk jl fd jy jg jz ka aw kb bi"><span id="c41f" class="kc kd hi jg b fi ke kf l kg kh">makeMaybe names = hmap MakeMaybe names</span></pre><p id="a5db" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">makeMaybe 的类型签名将类似于，</p><pre class="ji jj jk jl fd jy jg jz ka aw kb bi"><span id="e7bb" class="kc kd hi jg b fi ke kf l kg kh">type MaybeNames = {  father     :: Maybe String<br/>                  ,  mother     :: Maybe String<br/>                  ,  son        :: Maybe String<br/>                  ,  daughter   :: Maybe String<br/>                  }</span><span id="42eb" class="kc kd hi jg b fi kp kf l kg kh">makeMaybe :: Names -&gt; MaybeNames <br/>makeMaybe = ....</span></pre><blockquote class="kq kr ks"><p id="dedc" class="if ig kt ih b ii ij ik il im in io ip ku ir is it kv iv iw ix kw iz ja jb jc hb bi translated">注意:在上面的例子中，字段可以是任何类型，直到它们用 Maybe 包装起来。</p></blockquote><p id="20db" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">请看，<code class="du jd je jf jg b">hmap</code>已经将我们的记录类型转变为全新的类型。我们可以用<code class="du jd je jf jg b">hmap</code>做很多事情，例如，如果你想把所有的字段类型转换成字符串，你可以这样做</p><pre class="ji jj jk jl fd jy jg jz ka aw kb bi"><span id="d483" class="kc kd hi jg b fi ke kf l kg kh">--- create a type<br/>data MakeString = MakeString</span><span id="9139" class="kc kd hi jg b fi kp kf l kg kh">--- create the Mapping instance <br/>instance makeMakeString :: (Show a) =&gt; Mapping MakeString a String<br/>  where<br/>     mapping MakeString = show</span><span id="d4dd" class="kc kd hi jg b fi kp kf l kg kh">--- create a method that does the mapping<br/>makeString names = hmap MakeString names</span></pre><p id="9d3b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">太容易了，不是吗？</p><p id="50a1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">但是如果不能像上面那样统一类型(通过使用类似<code class="du jd je jf jg b">Show</code>的约束说所有字段都有 show instance 或者盲目使用类似<code class="du jd je jf jg b">forall a</code>的全称量词)怎么办？</p><p id="b43d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果您希望每个字段都有单独的映射函数，该怎么办？我们能用这个包做到吗？是的，我的朋友！！</p><p id="ecf8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">但是你在创建实例的时候已经写了一些模板，但是请相信我，它非常简单&amp;你会很快习惯的。</p><p id="992c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">首先，像往常一样，让我们创建一个包装记录的数据类型(在本例中是函数)。</p><pre class="ji jj jk jl fd jy jg jz ka aw kb bi"><span id="e757" class="kc kd hi jg b fi ke kf l kg kh">data ZipProps fns = ZipProps { | fns}</span></pre><p id="8fa3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">之前我们创建了<code class="du jd je jf jg b">Mapping</code> typeclass 实例，但是在这种情况下我们将使用<code class="du jd je jf jg b">MappingWithIndex</code>，它通过<code class="du jd je jf jg b">Proxy</code>为我们提供字段名</p><pre class="ji jj jk jl fd jy jg jz ka aw kb bi"><span id="1bd7" class="kc kd hi jg b fi ke kf l kg kh">instance zipProps ::<br/>  (IsSymbol sym, Row.Cons sym (a -&gt; b) tail fns) =&gt;<br/>  MappingWithIndex (ZipProps fns) (Proxy sym) a b where<br/>  mappingWithIndex (ZipProps fns) prop = Record.get prop fns</span></pre><p id="fa8b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">好吧，这可能会令人困惑，让我来分析一下</p><p id="6dda" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">MapWithIndex 采用 4 个参数</p><ol class=""><li id="c033" class="kx ky hi ih b ii ij im in iq kz iu la iy lb jc lc ld le lf bi translated"><code class="du jd je jf jg b">ZipProps fns</code> —您已经创建的数据类型，在我们的例子中是它的 ZipProps，它包装了函数的记录。</li><li id="9331" class="kx ky hi ih b ii lg im lh iq li iu lj iy lk jc lc ld le lf bi translated"><code class="du jd je jf jg b">Proxy sym</code> —这给出了字段的名称。</li><li id="15e2" class="kx ky hi ih b ii lg im lh iq li iu lj iy lk jc lc ld le lf bi translated"><code class="du jd je jf jg b">a</code> —字段的类型</li><li id="a4d5" class="kx ky hi ih b ii lg im lh iq li iu lj iy lk jc lc ld le lf bi translated"><code class="du jd je jf jg b">b</code> —用函数转换后的字段类型。</li></ol><pre class="ji jj jk jl fd jy jg jz ka aw kb bi"><span id="9595" class="kc kd hi jg b fi ke kf l kg kh">IsSymbol sym, Row.Cons sym (a -&gt; b) tail fns</span></pre><p id="5616" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在让我们看看约束条件，</p><ol class=""><li id="b637" class="kx ky hi ih b ii ij im in iq kz iu la iy lb jc lc ld le lf bi translated"><code class="du jd je jf jg b">IsSymbol sym</code> —表示代理中的<code class="du jd je jf jg b">sym</code>是一个符号(S <a class="ae jx" href="https://pursuit.purescript.org/packages/purescript-prelude/6.0.1/docs/Data.Symbol" rel="noopener ugc nofollow" target="_blank">符号</a>只是类型级别的字符串，您可以使用<code class="du jd je jf jg b">reflectSymbol</code>将符号转换成字符串)</li><li id="979f" class="kx ky hi ih b ii lg im lh iq li iu lj iy lk jc lc ld le lf bi translated"><code class="du jd je jf jg b">Row.Cons sym (a -&gt; b) tail fns</code> —该约束告诉字段名<code class="du jd je jf jg b">sym</code>具有类型<code class="du jd je jf jg b">a-&gt;b</code>(从 a 到 b 的函数)以及剩余的行<code class="du jd je jf jg b">tail</code>将构成整个记录<code class="du jd je jf jg b">fns</code>。它翻译成类似下面的块</li></ol><pre class="ji jj jk jl fd jy jg jz ka aw kb bi"><span id="50f6" class="kc kd hi jg b fi ke kf l kg kh">fns = { sym :: (a -&gt; b)<br/>      , ... tail <br/>      }</span></pre><p id="8b7d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在让我们看看这个定义是什么意思，</p><pre class="ji jj jk jl fd jy jg jz ka aw kb bi"><span id="904f" class="kc kd hi jg b fi ke kf l kg kh">mappingWithIndex (ZipProps fns) prop = Record.get prop fns</span></pre><p id="2a6f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><code class="du jd je jf jg b">Record.get</code>接受两个参数，一个以字段名作为符号的代理和实际记录，并返回值。就像访问</p><pre class="ji jj jk jl fd jy jg jz ka aw kb bi"><span id="0446" class="kc kd hi jg b fi ke kf l kg kh">fns.prop -- where fns is an object and prop is the field name</span></pre><p id="70b3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">上面的行将返回一个从<code class="du jd je jf jg b">a -&gt; b</code>开始的函数，其中同名的对应字段的类型是<code class="du jd je jf jg b">a</code>。例如，如果<code class="du jd je jf jg b">father</code>字段属于<code class="du jd je jf jg b">String</code>类型，那么 fns 中的<code class="du jd je jf jg b">father</code>字段是来自<code class="du jd je jf jg b">String -&gt; sometype</code>的函数(它必须采用与参数相同的类型)</p></div><div class="ab cl ki kj gp kk" role="separator"><span class="kl bw bk km kn ko"/><span class="kl bw bk km kn ko"/><span class="kl bw bk km kn"/></div><div class="hb hc hd he hf"><p id="7fb5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在让我们创建一个压缩函数，它获取函数的记录并将它们应用到具有相同字段名的元素的记录中。</p><pre class="ji jj jk jl fd jy jg jz ka aw kb bi"><span id="e93d" class="kc kd hi jg b fi ke kf l kg kh">--- the zipping function<br/>zipRecord fns record = hmapWithIndex (ZipProps fns) record</span><span id="70e0" class="kc kd hi jg b fi kp kf l kg kh">--- the mapping function <br/>fns =  { aNumber :  \num  -&gt; num + 1<br/>       , aString. : \str  -&gt; str &lt;&gt; "!!"<br/>       , aBool    : \bool -&gt; not bool <br/>       }</span><span id="adbc" class="kc kd hi jg b fi kp kf l kg kh">--- the record to be transformed<br/>num = { aNumber : 2 <br/>      , aString:"Hello"<br/>      , aBool : false }</span><span id="aa3c" class="kc kd hi jg b fi kp kf l kg kh">&gt;&gt;&gt; zipRecord fns num<br/>{ aNumber: 3, aString: "Hello!!", aBool: true }</span></pre><blockquote class="kq kr ks"><p id="9472" class="if ig kt ih b ii ij ik il im in io ip ku ir is it kv iv iw ix kw iz ja jb jc hb bi translated">注意:字段名应该相互匹配</p></blockquote><p id="8e1d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">异构包还提供了一种折叠记录的方法，但是我们不打算在本文中讨论它，那将是另外一个话题。</p><p id="6652" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我希望你学到了一些很酷的东西，并且知道有多酷😎异构包是，这可以使工作与记录超级灵活和容易。</p></div><div class="ab cl ki kj gp kk" role="separator"><span class="kl bw bk km kn ko"/><span class="kl bw bk km kn ko"/><span class="kl bw bk km kn"/></div><div class="hb hc hd he hf"><p id="3058" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">将在下一篇文章中看到其他一些很酷的包。拍手声👏如果你喜欢这篇文章，如果你觉得这篇文章有帮助，就分享给你的朋友。</p></div></div>    
</body>
</html>