<html>
<head>
<title>Quick and Dirty Notes / Mini-Quiz on Arrays</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">关于阵列的快速笔记/小测验</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/quick-and-dirty-notes-mini-quiz-on-arrays-431f72db3162?source=collection_archive---------21-----------------------#2021-03-14">https://medium.com/nerd-for-tech/quick-and-dirty-notes-mini-quiz-on-arrays-431f72db3162?source=collection_archive---------21-----------------------#2021-03-14</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div class="er es if"><img src="../Images/0cca1ac7873eb10790354a8619121037.png" data-original-src="https://miro.medium.com/v2/resize:fit:858/format:webp/1*7RN0uNj_VYiprxrRVHfc8Q.png"/></div></figure><p id="4f78" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">关于阵列的快速备忘单/小测验，用于复习基础知识。</p><p id="a503" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">这篇博客文章将被格式化为一个问题，然后是相应的答案。我发现提出问题有助于巩固我回忆信息的能力，并迫使我对主题有更好的理解。看看它是否对你有同样的作用。</p><p id="fced" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">当你浏览博客时，试着用自己的话回答问题，然后再看提供的答案。</p><h2 id="4938" class="jk jl hi bd jm jn jo jp jq jr js jt ju ix jv jw jx jb jy jz ka jf kb kc kd ke bi translated">尽可能多的描述一个数组。</h2><ul class=""><li id="6a6b" class="kf kg hi io b ip kh it ki ix kj jb kk jf kl jj km kn ko kp bi translated">相同数据类型(通常)的项目集合。</li><li id="660f" class="kf kg hi io b ip kq it kr ix ks jb kt jf ku jj km kn ko kp bi translated">可以是多个维度。</li><li id="d5cc" class="kf kg hi io b ip kq it kr ix ks jb kt jf ku jj km kn ko kp bi translated">可以是静态的或动态的。</li><li id="e4ad" class="kf kg hi io b ip kq it kr ix ks jb kt jf ku jj km kn ko kp bi translated">按顺序组织项目并在内存中连续(按顺序)存储数据。因此是所有数据结构中占用空间最小的。</li><li id="9ac8" class="kf kg hi io b ip kq it kr ix ks jb kt jf ku jj km kn ko kp bi translated">有一个标识每个数据位置的索引。</li></ul><h2 id="93e9" class="jk jl hi bd jm jn jo jp jq jr js jt ju ix jv jw jx jb jy jz ka jf kb kc kd ke bi translated">阵列的常见操作有哪些？</h2><ul class=""><li id="83c9" class="kf kg hi io b ip kh it ki ix kj jb kk jf kl jj km kn ko kp bi translated">检查</li><li id="cd31" class="kf kg hi io b ip kq it kr ix ks jb kt jf ku jj km kn ko kp bi translated">推</li><li id="83dc" class="kf kg hi io b ip kq it kr ix ks jb kt jf ku jj km kn ko kp bi translated">插入</li><li id="102e" class="kf kg hi io b ip kq it kr ix ks jb kt jf ku jj km kn ko kp bi translated">删除</li></ul><h2 id="94a0" class="jk jl hi bd jm jn jo jp jq jr js jt ju ix jv jw jx jb jy jz ka jf kb kc kd ke bi translated">上述数组操作的bigO是什么？除了上面的，你还能列举一些吗？</h2><ul class=""><li id="f205" class="kf kg hi io b ip kh it ki ix kj jb kk jf kl jj km kn ko kp bi translated">查找→O(1) →常数时间</li><li id="360b" class="kf kg hi io b ip kq it kr ix ks jb kt jf ku jj km kn ko kp bi translated">push → O(1) →恒定时间→除非增加阵列大小→然后O(n)由于数据的拷贝/位置调整</li><li id="4dbd" class="kf kg hi io b ip kq it kr ix ks jb kt jf ku jj km kn ko kp bi translated">插入→ O(n) →线性时间</li><li id="420a" class="kf kg hi io b ip kq it kr ix ks jb kt jf ku jj km kn ko kp bi translated">删除→ O(n) →线性时间</li><li id="dc49" class="kf kg hi io b ip kq it kr ix ks jb kt jf ku jj km kn ko kp bi translated">搜索→ O(n) →线性时间</li><li id="6267" class="kf kg hi io b ip kq it kr ix ks jb kt jf ku jj km kn ko kp bi translated">* pop→O(1)——-&gt;常数时间——-&gt;<em class="kv">能解释一下为什么吗？</em></li></ul><h2 id="debb" class="jk jl hi bd jm jn jo jp jq jr js jt ju ix jv jw jx jb jy jz ka jf kb kc kd ke bi translated">为什么数组的插入和删除是线性时间？</h2><p id="c05e" class="pw-post-body-paragraph im in hi io b ip kh ir is it ki iv iw ix kw iz ja jb kx jd je jf ky jh ji jj hb bi translated">因为每当插入或删除一个元素时，数组都需要为它后面的每个值重新分配索引。因此，数组需要找到用于插入或删除的索引，然后为以下值重新分配索引，这需要接触数组的剩余部分→数组的剩余部分1/x→O(n * 1/x)→其计算结果为O(n)。</p><p id="4db7" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">例如</p><p id="7a00" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">设arr = [1，2，3，4，5，6]</p><p id="4e45" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">假设我们在索引3处插入10，使→ arr = [1，2，3，10，4，5，6]</p><p id="c5e7" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">当我们在索引3处插入时，将该索引的值设置为10。因此，以下所有值都需要重新分配给它们的索引+1。所以在这种情况下，我们仍然需要接触数组中的3个元素→ 3 =原始数组长度的1/2→这意味着我们的bigO是O(n*1/2)，其计算结果为O(n)。</p><h2 id="428d" class="jk jl hi bd jm jn jo jp jq jr js jt ju ix jv jw jx jb jy jz ka jf kb kc kd ke bi translated">Array.pop()的bigO是什么？</h2><p id="7ae6" class="pw-post-body-paragraph im in hi io b ip kh ir is it ki iv iw ix kw iz ja jb kx jd je jf ky jh ji jj hb bi translated">*pop → O(1) — -&gt;常数时间— -&gt;因为它直接转到最后一个索引，不需要重新分配它之前或之后的元素的索引(因为它是最后一个索引)。</p><h2 id="9536" class="jk jl hi bd jm jn jo jp jq jr js jt ju ix jv jw jx jb jy jz ka jf kb kc kd ke bi translated">数组中的数据存储在哪里？</h2><p id="9e42" class="pw-post-body-paragraph im in hi io b ip kh ir is it ki iv iw ix kw iz ja jb kx jd je jf ky jh ji jj hb bi translated">随机存取存储器(RAM) →连续存储器。</p><h2 id="579b" class="jk jl hi bd jm jn jo jp jq jr js jt ju ix jv jw jx jb jy jz ka jf kb kc kd ke bi translated">阵列的优势/劣势是什么？</h2><ul class=""><li id="4bcd" class="kf kg hi io b ip kh it ki ix kj jb kk jf kl jj km kn ko kp bi translated">快速查找。很快。推()。很快。pop()。→ O(1) →恒定时间</li><li id="1845" class="kf kg hi io b ip kq it kr ix ks jb kt jf ku jj km kn ko kp bi translated">较慢的插入(。splice())。较慢的删除(也叫拼接)。较慢的未换档()。更慢的搜索。→ O(n) →线性时间</li></ul><h2 id="b652" class="jk jl hi bd jm jn jo jp jq jr js jt ju ix jv jw jx jb jy jz ka jf kb kc kd ke bi translated">静态数组和动态数组有什么区别？</h2><ul class=""><li id="908c" class="kf kg hi io b ip kh it ki ix kj jb kk jf kl jj km kn ko kp bi translated">静态数组的大小是预先决定的。</li><li id="fc5d" class="kf kg hi io b ip kq it kr ix ks jb kt jf ku jj km kn ko kp bi translated">动态数组会相应地增长/收缩。</li></ul><h2 id="f304" class="jk jl hi bd jm jn jo jp jq jr js jt ju ix jv jw jx jb jy jz ka jf kb kc kd ke bi translated">如何调整动态数组的大小？</h2><p id="021d" class="pw-post-body-paragraph im in hi io b ip kh ir is it ki iv iw ix kw iz ja jb kx jd je jf ky jh ji jj hb bi translated">如果需要更大的空间，动态数组允许您<strong class="io hj">在新位置</strong>复制并重建数组。它们将进行复制，然后移动到内存中的一个空间，其<strong class="io hj"/><strong class="io hj">通常是初始空间</strong>的两倍。</p><p id="0cf2" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">*这种复制需要一个循环，这意味着大小的增加将创建一个实例。push()将是O(n)而不是O(1)</p><p id="217e" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">*在Javascript和Python中，数组被视为动态数组。高级语言对此进行推断。而更关心内存的低级语言允许您设置大小(静态数组)。</p><h2 id="0a0d" class="jk jl hi bd jm jn jo jp jq jr js jt ju ix jv jw jx jb jy jz ka jf kb kc kd ke bi translated">你如何构建一个数组？</h2><p id="ea86" class="pw-post-body-paragraph im in hi io b ip kh ir is it ki iv iw ix kw iz ja jb kx jd je jf ky jh ji jj hb bi translated">根据你最熟悉的语言，答案可能会有所不同。但是花一些时间来完成一个解决方案。考虑数组固有的操作，并尝试用伪代码(或实际代码)写出数组的类定义，看看您对它的理解程度如何。</p><p id="f6f7" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">这就是这个小测验/小抄的全部内容。希望它能让你开心，让你开心！</p></div></div>    
</body>
</html>