# 科特林的“承诺”模型

> 原文：<https://medium.com/nerd-for-tech/the-promise-model-in-kotlin-1c121f22d35a?source=collection_archive---------2----------------------->

## 移动应用中的反应式编程——一次旅行

## 对于纯粹的 Kotlin 使用，特别是对于 Android，您需要的唯一异步任务链模型构建在 RxKotlin 之上——第 1 部分

## 介绍

这是我即将撰写的一长串文章的第一部分，这些文章将全面涵盖移动(特别是 Android)开发，并将提供一个全面的架构来构建伟大的现代应用程序。上述架构是一个反应式的、基于组件的 MVI，它已经在两个生产应用程序中完美地工作，现在是它见光的时候了。它让我的职业生活变得更好，应该分享。

![](img/6108f13da1a365ad0dffc9b79e88fe0d.png)

哥伦比亚 Cabo 圣胡安德尔阿桂

现代编程最重要的工具之一，尤其是当我们谈到*移动开发*的时候，是一个*异步任务链接工具*。
这也是这几天非常热门的话题，从各种 *rx* 用法到 *Kotlin* 自己的实现(例如 [*协程*](https://kotlinlang.org/docs/reference/coroutines/basics.html) )。甚至还有适用于 Android 的 [*支持 Livecycle 的协程作用域。*](https://developer.android.com/topic/libraries/architecture/coroutines#lifecycle-aware)

为了启动你的引擎，下面是 *JavaScript* 的任务链接工具——*Promise*——的样子，使用起来很简单(对于一个实际的应用程序来说):

JavaScript 的承诺。那真是太好了。如果你还不熟悉它，[请到这里阅读](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise)，它将帮助你理解本文的其余部分。

这里我们从数字“5”开始，但通常这是一个 API 请求。然后我们处理第一个结果(在我们的例子中是' 5 ')并返回另一个结果(B)。
*然后*我们用并行任务处理‘B’，每个任务都有自己的结果(“C1”、“C2”)。
*然后*我们处理两个‘C’结果。

现在再读一遍代码。现在再读一遍这个描述。我的意思是，这段代码有多清楚，对吗？描述就是这么写的。

为了提高热度，这里是(几乎)相同的链，在 *Kotlin 协程中。* 注意:*协程*提供了许多方法来完成类似的任务。不过，一般的方法是 [*命令式(过程式)编程*](https://zach-gollwitzer.medium.com/imperative-vs-declarative-programming-procedural-functional-and-oop-b03a53ba745c) :

协程方法

关于*协程*的实际工作方式还有很多(因此这段代码的运行方式与上面的*承诺*略有不同),它们可以做的不仅仅是任务链接。我想这甚至不公平。我想这就是我的观点。

*注意:我是 Kotlin 的超级粉丝，如果能在语言中内置一个可靠的任务链接工具，我会非常高兴。不过在我看来，协程现在还不够成熟，不像 rx 那样成熟。随着时间的推移，rx 库会在协程的基础上重新发布。没有理由不在以后用它们来重建这个承诺。*

那么，如果你问我，一个好的任务链接工具应该是什么样的呢？嗯，像 [JavaScript 的承诺](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise)，坦白说。这简直太棒了。

# 我们将在本文中做什么

这篇文章讲述了一个名为 *Promise* 的*异步任务链接工具*的全能实现，它建立在 *RxKotlin* 的`Single`模型([的基础上，现在可以在 GitHub 上获得，看看吧！](https://github.com/GuyMichael/APromise))。
这篇文章是写给任何用 *Kotlin* 编程的人的，无论是*手机*还是*服务器*开发，无论是 *Android* 还是 *iOS。你将学到的是如何做适当的*任务链*，反应式的。*

> 您将学习如何编写上面的 JavaScript 的 Promise 示例，但是更加强大，并且使用 Kotlin 编写

那为什么不直接用 *rx* 呢？因为没那么容易。它有一个很长的学习曲线，它涵盖的范围远不止任务链接——就像*协程*(和 [*流*](https://kotlinlang.org/docs/reference/coroutines/flow.html) *)* 所做的那样。

当我们知道我们的工具应该是什么样子，但不想被绑定到任何特定的实现(*rx/Coroutine/rx-on-top-of-Coroutine)*时，我们该怎么办？我们创建所需的 API，并抽象出底层实现:)

> 创建工具的第一步是定义它应该是什么样子，也就是它的 API

好吧，我们开始吃吧，好吗？

# “承诺”模式

*创建工具的第一步*是定义它应该是什么样子，意思是，它的 API，以及它应该服务于哪个平台/环境。
所以我们决定我们想要类似于 *JavaScript* 的 *Promise* 的东西，但是纯粹的 *Kotlin* ，以虚拟方式服务于所有平台。嗯，因为我们喜欢科特林。

我们希望我们的工具是健壮的。我是说，防弹的。请注意，这不是一个简单的任务。所以我们会用 [*RxKotlin*](https://github.com/ReactiveX/RxKotlin) 。在网上快速搜索一下，就会看到来自 *rx* 专家的一些好建议，包括但不限于:“就用*单个*！”。

## *Rx* 单为救援

[反应信号](http://reactivex.io/documentation/single.html)是一种特殊类型的`Observable`，它只发出一个值，或一个错误通知。它非常适合我们的任务。我们只需要让它看起来整洁、简单和易于使用，然后我们就可以得到 rx 所能提供的一切，那是一吨重！我们需要用*承诺*来包装它。我们走吧。

## 用一个人来建立一个承诺

我不会面面俱到，你可以访问[项目的 GitHub 页面](https://github.com/GuyMichael/APromise)或者具体来说，[实际承诺实现](https://github.com/GuyMichael/APromise/blob/master/apromise/src/main/java/com/guymichael/promise/Promise.kt)。我将讲述基础知识，然后讲述我是如何实现错误处理的:

我们首先定义新的 Promise 类:

新 Promise 类声明的简化版本

如上所述，构造函数接收到一个*rx*实例，该实例被保存为成员。此外，我们还有另一位同学，`promiseSubscriber`——我们很快就会谈到它。实际上在最终的实现中有更多的成员，但是它们现在不那么重要了。我们将在下一篇文章中讨论它们— *Promise 错误处理*。
接下来要定义的是，链接*动作/子句/任务*看起来是什么样子。

## 给定单个，为链接操作创建新的承诺实例

我们将为大多数连锁动作创建一个新的`Promise`(就像`Single`动作一样):

新的承诺创建者功能，供内部使用，已简化

*注意:我使用了一个专用的私有方法来创建新的实例，而不是仅仅调用默认的公共构造函数，因为这样更容易控制所有的内部类调用。很快，将会有更多的特性支持和添加到这个方法中，所以最好将它与公共构造函数区分开来。在实际代码中，这个方法甚至调用另一个方法* `*createInstanceImpl*` *来创建新的*`*Promise*`*——这样做是为了允许扩展这个 Promise 模型，例如*`*APromise*` *——一个 Android Promise (wink wink)。*

好了，我们有了一个新的*承诺*模型，它包装了 *rx* 的`Single`，我们有了一个实用方法来创建新的承诺，用于链接操作。在我们着手将`Single`的行动包装成我们自己的行动(例如，令人惊叹的‘然后’行动)这一几乎是例行公事的任务之前，唯一缺少的是*执行*我们的*承诺*的方法。

## 履行承诺，通过订阅单

记住，我们的承诺动作链是异步的。这也(最好)意味着它不会计算(late-init ),直到我们希望它这样做。就像 *Java Streams、Kotlin 协程、*和 *rx Observables* 一样。这实际上意味着我们可以将*承诺*作为方法参数( [*一等公民*](https://en.wikipedia.org/wiki/First-class_citizen) )进行修改，在其他*承诺*链中使用，并在以后执行。
对于 *JavaScript Promise* 爱好者来说，这可能会感觉不可思议，需要手动*执行* a `Promise`，而不是它神奇地启动([提示:它立即启动，一点也不神奇](https://stackoverflow.com/questions/42118900/when-is-the-body-of-a-promise-executed))，但从各方面来看，这是一个惊人的特性。
那么让我们来看看我们的`execute` 方法(从原始代码简化而来):

Promise 的 execute 方法的简化版本

所以基本上，`execute`方法订阅了底层的`Single`，它是执行链的 *rx* 方式，并返回一个`Disposable`。
我们保存/缓存这个*一次性*作为我们来自类声明的`promiseSubscriber`(还记得吗？往上一点)。这很重要。它确保底层`Single` *rx* 链不会*处置*并取消(例如由于*垃圾收集*)。
作为奖励，我们返回这个非常`Disposable`，它可以用来取消( *dispose* )我们的 *Promise* 链(实际上我们用另一个`Disposable` 实例将它包装在真实代码中，但想法是一样的)。
多么神奇，一个*可取消的承诺*。

*注意:如您所见，* `*promiseSubscriber*` *仅由链中的最后一个承诺持有，因为它仅由我们称为* `*execute()*` *on 的实例保存(就像在 rx 中一样，您订阅整个链，而不是其中的每个操作/行)。这是有意义的，因为当一个* `*promise*` *的* ***整个*** *链已经成功完成时，它就被认为是解决了。正是如此。*

如今，现在..到了**好玩的**部分！

# 链接操作

让我们从最简单的动作开始，一个‘然后’。不用说，它应该返回一个(新的)`Promise`，因为这就是*反应式*链接的全部内容:)

## 消费者的“然后”

最基本的“然后”操作，原样(未简化)

就是这样！多有趣啊。我们现在可以连锁(简单- *消费者* ) *行动/任务/条款*！但是等等，我们还没完，还有很多事情要做。更多相同的，但更多。让我们从那个让你再次平静的电话开始。

`singleOfConsumer`只是一个实用方法，用于根据给定的*消费者*参数创建新的`Single`实例(消费者*消费者*只是一个接收参数并返回 *void* 的函数)。

*注意:因为我们想要创建许多类型的‘then’方法(例如，使用异步参数)，我们将有一些实用方法，它们很简单，但也是核心逻辑，这就是我们的 rx 知识派上用场的地方。*

那么让我们来看看非常简单的`singleOfConsumer`方法:

从一个消费者创建一个新单的实用程序方法。原样

没什么特别的——只是调用了`Single.map()`(通常用于将一些`Single<T>`映射到另一些类型`Single<R>`)，但是我们返回给*消费者*(`T`类型的`it`)的相同参数。
这实际上是一个‘then’回调，它只消耗 *Promise* 链中的当前参数，而不对链的其余部分做任何更改。这与在 *JavaScript* 中的用法完全相同，在这里您将使用‘then’参数，并且*在‘then’块的末尾返回*它，将它向前传递给链的其余部分。

*注意:Single 的* `*map*` *方法创建(并返回)一个新的* `*Single*` *，就像我们的‘then’方法创建一个新的* `Promise` *。所以实际上，每当我们使用‘then’时，我们既创建了一个新的* `*Single*` *，又创建了一个新的* `*Promise*` *。你可能不喜欢，但这就是反应式编程的全部——映射值，不可变的值。这意味着一遍又一遍地重新创建实例。*

以完全相同的方式，我们可以定义一个“thenMap”动作，其中*将*映射到我们的类型，例如从`Promise<T>`到`Promise<R>`。这现在非常容易:

一个简单的“then”动作，它将承诺链从类型“T”映射到类型“R”

其中`singleOfMap()`与`singleOfConsumer()`完全相同，但没有最后一行，返回*函数*响应，而不是输入参数`it`。
不过这一次，参数是一个*映射器*而不是一个*消费者(*一个*映射器*，或者仅仅是一个*函数*，实际上，是一个接收参数并返回参数的函数。在反应式编程中，*函数*被大量用作*映射器，*在某种意义上，它在*反应式*链内将一个值映射到另一个值，或将一种类型映射到另一种类型。

一个实用的方法，创建一个新的单一的映射函数

*注意:在这一点上，有必要指出这样一个事实，我并没有仅仅使用“then”来命名所有的* *动作。相反，我通过名字和签名使它们显式化(* [*因为 Kotlin 是一种静态类型语言*](https://stackoverflow.com/questions/1517582/what-is-the-difference-between-statically-typed-and-dynamically-typed-languages) *)。
对于那些习惯了 JavaScript 承诺的人，我只能说:“欢迎来到显式代码的神奇世界，我相信你会爱上它的！”。*

你已经冷静下来了吗？太好了，让我们把它变得更有趣。

## 然后等待连锁承诺

在 *JavaScript Promise* 中，这是‘then’的(令人敬畏的)用法，在这里你返回一个新的`promise`。它的行为是等待这个新的`promise` ，并将其结果传递给链中将要使用的下一个‘then’。这就是去掉错误处理代码后的结果——我们将在下一篇文章中讨论:

最常用的“然后”动作，在完成/恢复链之前等待另一个承诺。简化了的

现在你肯定明白了，这个方法的核心逻辑在于 *rx* ，在实用方法`singleOfAsync`内。
这个方法的作用是接收一个*函数*，该函数将接收*承诺*链中的“当前”参数(`T`)和*返回* ( *将*映射到)一个新的`Promise`，具有新的类型`R`(当然，很可能是同一类型`T`)。
这种将*承诺*如此轻松地链接起来的能力就是*承诺*的全部意义所在。与 *JavaScript* 相反，我们知道编译时的类型！现在我们感到(几乎)满意了。让我们让*排版*爱好者冷静一分钟，因为他们对*排版*的泛型非常满意，我敢肯定；)

现在我们来看看`singleOfAsync`的简化版:

从映射器创建新单的实用方法——从某个参数 T 到新的承诺

所以基本上，链接异步动作的`Single`方式是一个`flatMap`，它接受一个*映射器/函数*，这个映射器/函数*将链中的【当前】值`T`映射到一个新的`Single` (某种类型的`R`)。
函数*的参数*也差不多，但是它返回一个新的`Promise<R>` 而不是一个新的`Single<R>`，对吗？所以我们将只手动执行给定的*功能*并取(*返回*到`flatMap`)新的*承诺*的`Single`，忽略新的`Promise`。真是偷窃。*

*注:我们的* `*Promise*` *只是一个包装器，这里真正重要的是* `*Single*` *。所以基本上，一个* `*Promise*` *是由它的* `*Single*` *定义的，从另一个* `*Single*` *创建一个新的* `*Promise*` *，基本上与复制那个* `*Promise*` *是一样的。*
*或者是？！？！:)
我们将在下一篇文章中讨论错误处理，这是我刚才所说的一个例外。但是这个想法仍然存在——单身是我们承诺的定义。*

遵循上述原则，我们可以(非常容易地，[参见源代码](https://github.com/GuyMichael/APromise/blob/master/apromise/src/main/java/com/guymichael/promise/Promise.kt))创建更多的‘then’动作并改进这些动作，以允许线程管理和更具体的用法。以下是一些让你兴奋的事情:

## “然后”用穿线

简单的线程管理和*承诺*

## 实用程序操作

如果你对我们的“那么”感到满意，让我们来看看一些非那么实用的行动:

所有 *rx* 的力量，在一个*承诺*般的语法中。

## 回到起点

在我们总结之前，让我们用一个例子来结束这篇文章开始的 [*JavaScript* 链是如何使用这个 *Kotlin Promise* 编写的:](#5da1)

同样的 JavaScript 链，在一个*科特林承诺*

# 摘要

所以这些是如何从 *rx Single、*创建 *Promise* 的基础，从而产生一个无所不能的 *Promise* 模型，它可以做`Single`可以做的任何事情，但以一种直观、专注的方式，专门为*任务链*制作。
希望你喜欢它，也希望你学到了一些新东西:)
还有更多，尤其是我们如何处理错误(*拒绝*)，这将在下一篇文章中介绍。

我想感谢您的阅读，并鼓励您等待本*旅程*到*移动应用中的反应式编程*中的其余文章。它们将涵盖一切，从 Android 特有的 T21 承诺到构建现代应用的 MVI 架构。
*提示:我瞄准* [*科特林多平台*](https://kotlinlang.org/docs/reference/multiplatform.html) *。*

这个项目，包括 Android 的 *APromise* ，在 GitHub 上，[去看看吧。](https://github.com/GuyMichael/APromise)

请随时留下您的意见和/或直接联系我。
直到下一章——*承诺错误处理*——过得愉快。

编辑:[下一章准备好了](/@gguymi/ebb5b66bb745)！