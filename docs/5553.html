<html>
<head>
<title>Golang with protobuf &amp; GRPC/HTTP2</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用protobuf和GRPC的golang/http 2</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/golang-with-protobuf-grpc-http2-d11e1d32a02c?source=collection_archive---------3-----------------------#2021-10-15">https://medium.com/nerd-for-tech/golang-with-protobuf-grpc-http2-d11e1d32a02c?source=collection_archive---------3-----------------------#2021-10-15</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class="ev ex if ig ih ab cb"><figure class="ii ij ik il im in io paragraph-image"><div role="button" tabindex="0" class="ip iq di ir bf is"><img src="../Images/553ccc6fe74920d8cb6eebbe86c61a03.png" data-original-src="https://miro.medium.com/v2/resize:fit:736/format:webp/1*C2zST_Bn4rtZ1GLhbC5gxQ.png"/></div></figure><figure class="ii ij iv il im in io paragraph-image"><div role="button" tabindex="0" class="ip iq di ir bf is"><img src="../Images/f15a537917bc16ea4f415a55604d200d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1266/format:webp/1*6ufkIOzURh0WBg_q9jrSgQ.png"/></div></figure></div><p id="730f" class="pw-post-body-paragraph iw ix hi iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt hb bi translated">作为我在以前的雇主那里工作的一个项目的一部分，我正在开发一个新的栈来替代ReST over HTTP with JSON。我使用protobuf作为传输消息，通过HTTP2对GRPC进行了试验。与基于ReST API的设计相比，这是一种全新的构建后端的方式。</p><p id="28d3" class="pw-post-body-paragraph iw ix hi iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt hb bi translated">我正在做一个新的兼职项目，从零开始构建一个基于<strong class="iy hj">分布式哈希表(DHT) </strong>概念的简单点对点应用程序。如果您不了解一致性散列，我建议在继续之前先阅读它。我试图模拟一个简单的对等节点，它在2个docker实例中的一台机器上工作。但这是一个非常幼稚的版本，需要努力才能有一个像样的版本。我必须在应用程序实例中对节点的ip进行硬编码，以便一个实例连接到另一个实例并在彼此之间进行同步。参考<a class="ae ju" href="https://github.com/prateekgupta3991/contraption/tree/p2p/src" rel="noopener ugc nofollow" target="_blank">回购</a>。</p><blockquote class="jv jw jx"><p id="cfe4" class="iw ix jy iy b iz ja jb jc jd je jf jg jz ji jj jk ka jm jn jo kb jq jr js jt hb bi translated">这篇文章是关于grpc/protobuf/HTTP2的工作知识，而不是使用这些技术背后的设计决策。我假设你对grpc/protobuf/HTTP2有一些了解，并正在寻找一个理解的工作示例。这些决定将会在我以后的文章中单独发表。</p></blockquote><p id="6e5d" class="pw-post-body-paragraph iw ix hi iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt hb bi translated">我列出了这个项目试图解决的用例:<br/> 1。创建一个基本服务器。这将是应用程序运行的第一台服务器。<br/> 2。在环中添加新的服务器。这是通过在不同的docker节点上启动第二台服务器来处理的。从我们的客户端使用<strong class="iy hj">RPC</strong>T8】insert node()方法将这个新节点的IP更新到原始服务器。<br/> 3。如果具有<strong class="iy hj">特定id(散列关键字)</strong>的节点存在或不存在，则请求节点做出响应。该请求可以到达对等环中的任何服务器，如果该节点出现在该环中，它应该使用<strong class="iy hj">RPC</strong><strong class="iy hj">findDestNode()</strong>进行响应。</p><p id="0354" class="pw-post-body-paragraph iw ix hi iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt hb bi translated"><strong class="iy hj">未来扩展</strong> <br/> 1。在这个环中存储一个值。尚不支持。<br/> 2。附近节点自动同步新节点加入环的信息。</p><h1 id="0d09" class="kc kd hi bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated">原蟾蜍</h1><p id="5d37" class="pw-post-body-paragraph iw ix hi iy b iz la jb jc jd lb jf jg jh lc jj jk jl ld jn jo jp le jr js jt hb bi translated">首先要讨论的是消息格式本身。因为它有自己的语义、类型和用例。<br/>proto buf是一种消息格式，在传输消息时使用的是二进制格式。</p><p id="c7b1" class="pw-post-body-paragraph iw ix hi iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt hb bi translated">protobuf消息需要存储为一个<strong class="iy hj">。原型</strong>文件。我的项目的原型文件如下:</p><figure class="lf lg lh li fd ij"><div class="bz dy l di"><div class="lj lk l"/></div></figure><p id="5170" class="pw-post-body-paragraph iw ix hi iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt hb bi translated">基于上面讨论的用例，proto由<strong class="iy hj">RPC</strong>和以<strong class="iy hj">消息</strong>关键字形式的相应契约组成。</p><p id="2fc3" class="pw-post-body-paragraph iw ix hi iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt hb bi translated">由于proto文件可以用于生成服务器和客户机，所以我将它存储为一个名为vault的独立repo。参考<a class="ae ju" href="https://github.com/prateekgupta3991/vault" rel="noopener ugc nofollow" target="_blank">回购</a>。</p><p id="e3d5" class="pw-post-body-paragraph iw ix hi iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt hb bi translated">然后运行grpc命令来生成<strong class="iy hj"> pb.go </strong>文件。请参考原型<a class="ae ju" href="https://developers.google.com/protocol-buffers/docs/reference/go-generated" rel="noopener ugc nofollow" target="_blank">文档</a>了解这一点。附上文件，但它太大了。</p><figure class="lf lg lh li fd ij"><div class="bz dy l di"><div class="lj lk l"/></div></figure><h1 id="80ca" class="kc kd hi bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated">核心</h1><p id="bf31" class="pw-post-body-paragraph iw ix hi iy b iz la jb jc jd lb jf jg jh lc jj jk jl ld jn jo jp le jr js jt hb bi translated">具有逻辑的核心文件如下。<br/> 1。node . go——当新的对等体想要加入DHT环时，该文件具有创建NewNode()实例的逻辑，Insert()通知现有节点关于新节点的添加，FindSuccessor()查找环中的节点。FindSuccessor仍未实现。</p><figure class="lf lg lh li fd ij"><div class="bz dy l di"><div class="lj lk l"/></div></figure><p id="d680" class="pw-post-body-paragraph iw ix hi iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt hb bi translated">2.fingertable.go —该文件的逻辑是为每个节点创建一个新的fingertable，以存储附近的对等元信息，在FT中添加新对等元信息，并从FT中读取数据。</p><figure class="lf lg lh li fd ij"><div class="bz dy l di"><div class="lj lk l"/></div></figure><h1 id="8d3e" class="kc kd hi bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated">主要的</h1><p id="045f" class="pw-post-body-paragraph iw ix hi iy b iz la jb jc jd lb jf jg jh lc jj jk jl ld jn jo jp le jr js jt hb bi translated">该文件使用核心文件来操作DHT环操作</p><figure class="lf lg lh li fd ij"><div class="bz dy l di"><div class="lj lk l"/></div></figure><h1 id="18a2" class="kc kd hi bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated">计算机网络服务器</h1><p id="2637" class="pw-post-body-paragraph iw ix hi iy b iz la jb jc jd lb jf jg jh lc jj jk jl ld jn jo jp le jr js jt hb bi translated">现在，应用程序将使用上面的原型生成文件来编写服务器。</p><figure class="lf lg lh li fd ij"><div class="bz dy l di"><div class="lj lk l"/></div></figure><h1 id="db05" class="kc kd hi bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated">客户</h1><figure class="lf lg lh li fd ij"><div class="bz dy l di"><div class="lj lk l"/></div></figure><p id="7bd9" class="pw-post-body-paragraph iw ix hi iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt hb bi translated">这是我制作的非常简单的DHT版本。对我来说，这是获得有价值知识的垫脚石。我为什么选择对等作为grpc实验的辅助项目，主要是因为对等是rpc调用的一个很好的用例。</p><p id="fc9a" class="pw-post-body-paragraph iw ix hi iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt hb bi translated">在另一篇关于WIP的半生不熟的文章中，我已经将这个项目移植到一个简单的区块链项目中，就像点对点项目一样。我刚刚移除了grpc，转而在HTTP和API上使用JSON。它仍然是WIP，但已经能够在2个docker节点上进行测试，在那里它们添加到环中，并同步它们的分类帐。当它变得更好的时候我会分享它。</p><p id="8e80" class="pw-post-body-paragraph iw ix hi iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt hb bi translated">如果你发现任何不一致的地方，请通过评论让我知道，或者联系我就此进行讨论。谢谢！！！</p></div></div>    
</body>
</html>