<html>
<head>
<title>Understanding Middleware in Redux</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">了解Redux中的中间件</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/understanding-middleware-in-redux-9d664cc6f5a5?source=collection_archive---------1-----------------------#2021-01-12">https://medium.com/nerd-for-tech/understanding-middleware-in-redux-9d664cc6f5a5?source=collection_archive---------1-----------------------#2021-01-12</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/36cdb06b97713127555440d4a752e3bc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QNlAqx3M6BcwofMyLuCZFg.png"/></div></div></figure><p id="5027" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在本文中，我将解释Redux中“中间件”的概念</p><p id="1d3e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">本文是系列文章的一部分</p><ol class=""><li id="e8db" class="jo jp hi is b it iu ix iy jb jq jf jr jj js jn jt ju jv jw bi translated"><a class="ae jx" href="https://www.linkedin.com/pulse/create-redux-hello-world-rany-elhousieny-phd%E1%B4%AC%E1%B4%AE%E1%B4%B0/" rel="noopener ugc nofollow" target="_blank">https://lnkd.in/guBuBVP</a>:<a class="ae jx" href="https://lnkd.in/guBuBVP" rel="noopener ugc nofollow" target="_blank">𝑪𝒓𝒆𝒂𝒕𝒆𝒂𝑹𝒆𝒅𝒖𝒙</a></li></ol><p id="8988" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">2.【https://lnkd.in/gDWG7AC】创建React原生App  <a class="ae jx" href="https://www.linkedin.com/pulse/create-react-native-base-project-run-rany-elhousieny-phd%25E1%25B4%25AC%25E1%25B4%25AE%25E1%25B4%25B0/?trackingId=fVq%2FbGEzug0okFdN6aGbPQ%3D%3D" rel="noopener ugc nofollow" target="_blank">此处</a><a class="ae jx" href="https://lnkd.in/gDWG7AC" rel="noopener ugc nofollow" target="_blank"/></p><p id="8717" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">3.redux with React Native:1-读取状态:<a class="ae jx" href="https://lnkd.in/gUbBRs8" rel="noopener ugc nofollow" target="_blank">https://lnkd.in/gUbBRs8</a></p><p id="7bc5" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">4.<a class="ae jx" href="https://www.linkedin.com/pulse/redux-react-native-2-updating-state-rany-elhousieny-phd%E1%B4%AC%E1%B4%AE%E1%B4%B0/?published=t" rel="noopener ugc nofollow" target="_blank">Redux with React Native:2-更新状态https://lnkd.in/gPcUcMx</a></p><p id="7aa0" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">5.<a class="ae jx" href="https://www.linkedin.com/pulse/understanding-middleware-redux-rany-elhousieny-phd%25E1%25B4%25AC%25E1%25B4%25AE%25E1%25B4%25B0/?trackingId=GsQ4UhEkEn%2BEfwplsSNWxA%3D%3D" rel="noopener ugc nofollow" target="_blank">本文:了解Redux中的中间件</a>:<a class="ae jx" href="https://lnkd.in/g5tVFn8" rel="noopener ugc nofollow" target="_blank">https://lnkd.in/g5tVFn8</a></p><p id="393d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">该应用的最终代码可以在<a class="ae jx" href="https://github.com/ranyelhousieny/ReactNativeFoodApplication" rel="noopener ugc nofollow" target="_blank">Github https://Github . com/ranyelhousieny/ReactNativeFoodApplication</a>中找到</p><p id="2be9" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">您可以克隆并使用</p><pre class="jy jz ka kb fd kc kd ke kf aw kg bi"><span id="bde1" class="kh ki hi kd b fi kj kk l kl km">git clone <a class="ae jx" href="https://github.com/ranyelhousieny/ReactNativeFoodApplication.git" rel="noopener ugc nofollow" target="_blank">https://github.com/ranyelhousieny/ReactNativeFoodApplication.git</a></span></pre><p id="5a1a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi">================================================================</p><p id="95ac" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我将继续上一篇文章中留下的内容。我们现在有了下图:</p><figure class="jy jz ka kb fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es kn"><img src="../Images/1708314b3efeea537a56a8f4a84aea79.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*iMWj2jAjrz9cu09c"/></div></div></figure><p id="6ab4" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">下面是分派操作的步骤:</p><figure class="jy jz ka kb fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ko"><img src="../Images/61805482b64d1315c19ee880f099c97f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*r2SeBLwNPWoErhyr"/></div></div></figure><ol class=""><li id="517f" class="jo jp hi is b it iu ix iy jb jq jf jr jj js jn jt ju jv jw bi translated">当点击按钮时，一个事件将通过mapDispatchToProps设置的props分派一个动作</li><li id="824d" class="jo jp hi is b it kp ix kq jb kr jf ks jj kt jn jt ju jv jw bi translated">在这种情况下，仅使用类型构建操作</li></ol><pre class="jy jz ka kb fd kc kd ke kf aw kg bi"><span id="b655" class="kh ki hi kd b fi kj kk l kl km">action =<br/>{<br/>  type: "LAST_NAME"<br/>}</span></pre><p id="1e96" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">3.此操作将被发送到reducer，reducer将通过switch语句来决定与此操作相关的状态。请键入。在这种情况下，请添加姓氏(Rany ElHouieny)</p><figure class="jy jz ka kb fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ku"><img src="../Images/212ba16a5ea805989bb51d1706aeeca2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*EpwgN4A_Bc_T5Euu"/></div></div></figure><p id="1fc1" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这是中间件在第3步之前截取动作并在将动作发送给缩减器之前对其进行管理的地方。如下图所示:</p><figure class="jy jz ka kb fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/9df10b805951c26dbe17cdfbb61e92b3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*A1CMmWAJnSMilxUg"/></div></div></figure><p id="7271" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">你可能会问“我们为什么要这么做？”这是一个合理的问题。</p><p id="4643" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在这种情况下，这可能很有意义。然而，在现实生活中，该操作将主要尝试从服务器获取数据。在异步调用中从服务器获取数据，我们不想等待响应。等待响应将导致显示器上的大延迟。相反，我们触发动作并释放调用者，直到收到响应。</p><p id="5882" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">为了能够清楚地解释这个概念，我将尝试构建一个小的中间件，它带有一些控制台日志记录，以显示中间件何时被注入。当我们调用applyMiddleware时，所有这些魔法都是由Redux完成的。</p><h1 id="a5d7" class="kv ki hi bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">1.从redux导入applyMiddleware</h1><p id="8555" class="pw-post-body-paragraph iq ir hi is b it ls iv iw ix lt iz ja jb lu jd je jf lv jh ji jj lw jl jm jn hb bi translated">在Redux/store.js中，从Redux导入applyMiddleware</p><pre class="jy jz ka kb fd kc kd ke kf aw kg bi"><span id="6430" class="kh ki hi kd b fi kj kk l kl km">import { createStore, applyMiddleware } from 'redux';</span></pre><h1 id="25ce" class="kv ki hi bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">创建一个日志中间件</h1><p id="ba5c" class="pw-post-body-paragraph iq ir hi is b it ls iv iw ix lt iz ja jb lu jd je jf lv jh ji jj lw jl jm jn hb bi translated">在Redux/store.js文件中，在创建商店之前，让我们创建一个简单的日志记录中间件，它将打印沿途的状态。一个有效的中间件由如下3个嵌套函数组成</p><p id="3f18" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">第一个函数将商店作为参数，因为它将与商店一起工作。</p><pre class="jy jz ka kb fd kc kd ke kf aw kg bi"><span id="cf0a" class="kh ki hi kd b fi kj kk l kl km">// Logging Middleware<br/>const logging = ( store ) =&gt; {</span><span id="2348" class="kh ki hi kd b fi lx kk l kl km">};</span></pre><p id="f26f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">第一个函数将返回第二个函数，该函数采用“next”参数，因为它将是reducer的下一步。</p><pre class="jy jz ka kb fd kc kd ke kf aw kg bi"><span id="ab62" class="kh ki hi kd b fi kj kk l kl km">// Logging Middleware<br/>const logging = ( store ) =&gt; {<br/>    return ( next ) =&gt; {<br/>        <br/>    };<br/>};</span></pre><p id="e5e1" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">只是为了让它更混乱:)，第二个函数将返回第三个函数，该函数将接收一个动作作为参数。</p><pre class="jy jz ka kb fd kc kd ke kf aw kg bi"><span id="9720" class="kh ki hi kd b fi kj kk l kl km">// Logging Middleware<br/>const logging = ( store ) =&gt; {<br/>    return ( next ) =&gt; {<br/>        return ( action ) =&gt; {<br/>            <br/>        };<br/>    };<br/>};</span></pre><p id="e087" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这是一个有效的中间件，但非常简单的中间件。让我们给它添加一些代码。所有代码都在内部函数中，因为它可以访问store、next和action。</p><p id="c65a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">让我们首先记录该操作的值</p><pre class="jy jz ka kb fd kc kd ke kf aw kg bi"><span id="1205" class="kh ki hi kd b fi kj kk l kl km">// Logging Middleware<br/>const logging = ( store ) =&gt; {<br/>    return ( next ) =&gt; {<br/>        return ( action ) =&gt; {<br/>            console.log( "[inside logging],  action = ", action );<br/>            console.log( "[inside logging],  State before next = ", store.getState() );<br/>        };<br/>    };<br/>};</span></pre><p id="5f2d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在，接下来让我们使用中间函数将动作发送到reducer，并在它返回后记录存储值，如下所示:</p><pre class="jy jz ka kb fd kc kd ke kf aw kg bi"><span id="c94b" class="kh ki hi kd b fi kj kk l kl km">// Logging Middleware<br/>const logging = ( store ) =&gt; {<br/>    return ( next ) =&gt; {<br/>        return ( action ) =&gt; {<br/>            console.log( "[inside logging],  action = ", action );<br/>            console.log( "[inside logging],  State before next = ", store.getState() );<br/>            const result = next( action );<br/>            console.log( "[logging], store value after next", store.getState() );<br/>            return result;<br/>        };<br/>    };<br/>};</span></pre><p id="cddb" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在，让我们将这个中间件应用到商店，以允许它拦截分派的动作，如下所示</p><pre class="jy jz ka kb fd kc kd ke kf aw kg bi"><span id="6035" class="kh ki hi kd b fi kj kk l kl km">export const store = createStore( reducer, applyMiddleware(logging) );</span></pre><figure class="jy jz ka kb fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ly"><img src="../Images/870f90fd2adbc02b5be5d2ea6c06bf81.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*MoBnGEtUpc43Pswf"/></div></div></figure><p id="fcfd" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">让我们运行应用程序并观看日志记录(npm run web)</p><figure class="jy jz ka kb fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lz"><img src="../Images/f3a86826944ce0034b41097f45460029.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*uD33u8SBM76a7oST"/></div></div></figure><p id="7f57" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如您所见，next之前的状态是Rany，next之后的状态是Rany ElHousieny，这将它发送到reducer以添加姓氏。让我们在Redux/reducers/rootReducer.js的reducer中添加一些日志来验证这一点。</p><figure class="jy jz ka kb fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ma"><img src="../Images/35b1fd7e919ae76f42fae43b954c4c16.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*XjVbPPibLTdTBrt0"/></div></div></figure><p id="87c1" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这是记录</p><figure class="jy jz ka kb fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mb"><img src="../Images/0caacb2d12d52768f76cb861967ba6ac.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*eGPKfaBSAXNw2sYW"/></div></div></figure><ol class=""><li id="d9f5" class="jo jp hi is b it iu ix iy jb jq jf jr jj js jn jt ju jv jw bi translated">中间件</li><li id="e38b" class="jo jp hi is b it kp ix kq jb kr jf ks jj kt jn jt ju jv jw bi translated">中间件调用next来调用reducer，并在发送前传递可以修改的动作</li><li id="0833" class="jo jp hi is b it kp ix kq jb kr jf ks jj kt jn jt ju jv jw bi translated">Reducer根据动作类型修改存储，并将其返回给中间件</li></ol><p id="8033" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这就是中间件的工作原理。在下一篇文章中，我将添加另一个已知的中间件(Thunk)</p></div></div>    
</body>
</html>