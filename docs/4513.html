<html>
<head>
<title>Compare and Contrast: CSR, SSR, and SSG in NextJS</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">比较和对比:下一个JS中的CSR、SSR和SSG</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/compare-and-contrast-csr-ssr-and-ssg-in-nextjs-58e3caf2e15e?source=collection_archive---------0-----------------------#2021-07-24">https://medium.com/nerd-for-tech/compare-and-contrast-csr-ssr-and-ssg-in-nextjs-58e3caf2e15e?source=collection_archive---------0-----------------------#2021-07-24</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/d3c0bc2852472b5e8345fb228ebf4201.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Mnu2bKfTTxIBuVa_"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">照片由<a class="ae iu" href="https://unsplash.com/@cebbbinghaus?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">克里斯托弗·罗宾·艾宾浩斯</a>在<a class="ae iu" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="8510" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">自从NextJS v9.3发布以来，我们已经为React应用程序提供了三种不同的渲染选项。</p><ul class=""><li id="17fe" class="jt ju hi ix b iy iz jc jd jg jv jk jw jo jx js jy jz ka kb bi translated">客户端渲染</li><li id="e654" class="jt ju hi ix b iy kc jc kd jg ke jk kf jo kg js jy jz ka kb bi translated">服务器端渲染</li><li id="b246" class="jt ju hi ix b iy kc jc kd jg ke jk kf jo kg js jy jz ka kb bi translated">静态站点生成</li></ul><p id="5128" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">每种方法都有其使用案例和优点。让我们探索一下我们想要选择其中一个而不是另一个的情况，以及如何在我们的代码中实现每一个的一些例子。</p><h2 id="a6d7" class="kh ki hi bd kj kk kl km kn ko kp kq kr jg ks kt ku jk kv kw kx jo ky kz la lb bi translated">1)客户端渲染</h2><figure class="ld le lf lg fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lc"><img src="../Images/375ba2b64980cb8138ed12502f50772c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*yqHrt5Nr2bMwKTCq"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">照片由<a class="ae iu" href="https://unsplash.com/@remotarjobs?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Remotar乔布斯</a>在<a class="ae iu" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a></figcaption></figure><p id="34a6" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">它是如何工作的？</p><p id="26d7" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">客户端呈现本质上意味着大部分工作(获取数据和创建HTML)是由浏览器根据用户的需求来完成的。</p><p id="010e" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">a)客户端通过URL请求页面。</p><p id="c7eb" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">b)服务器用一个空白页响应客户机，并引用JavaScript文件。</p><p id="db3c" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">c)这些由浏览器下载并运行，用于构建页面。</p><p id="0f0c" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">d)根据JavaScript的需要，从API获取和填充数据。</p><p id="0ef0" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这有一些好处，但也存在一些问题:</p><p id="f84a" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">客户端渲染优点:</strong></p><ul class=""><li id="967c" class="jt ju hi ix b iy iz jc jd jg jv jk jw jo jx js jy jz ka kb bi translated">好快啊！服务器很容易出售一个空白页面，而且这个方法只生成需要显示的HTML，所以您的浏览器可以很容易地用hide和show事件处理一大块元素。虽然要处理的代码比较多，但是渲染的时间并不多。由于延迟加载，客户端渲染可能比服务器端渲染快得多。</li><li id="9158" class="jt ju hi ix b iy kc jc kd jg ke jk kf jo kg js jy jz ka kb bi translated">这是表演！与需要刷新或重新呈现整个页面的传统HTML页面不同，客户端呈现模拟不同的页面，但将它们加载到单个页面上。这减轻了内存和处理能力的压力，比服务器端渲染的结果更快。</li><li id="3841" class="jt ju hi ix b iy kc jc kd jg ke jk kf jo kg js jy jz ka kb bi translated">非常适合单页应用程序。没有其他模型支持SPA，这允许我们在应用程序中重用UI组件，而无需再次从服务器请求它们。这与企业社会责任的快速和高效的本质密切相关。</li></ul><p id="171a" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">客户端渲染缺点:</strong></p><ul class=""><li id="e6fc" class="jt ju hi ix b iy iz jc jd jg jv jk jw jo jx js jy jz ka kb bi translated">你最初提供的是一个空白页，所以当客户第一次访问你的页面时，他们看到的也是一个空白页。在JavaScript应用程序的初始加载和页面构建过程中，等待时间比服务器端呈现要长。</li><li id="f0c0" class="jt ju hi ix b iy kc jc kd jg ke jk kf jo kg js jy jz ka kb bi translated">搜索引擎优化或SEO。由于您的元数据是由JavaScript在第一次加载时加载的，所以当搜索引擎的网络爬虫访问您的页面时，搜索引擎将看不到这些数据。这对于服务器端呈现来说不是问题，因为提供给客户端的初始页面已经包含了所有这些数据。</li><li id="54b1" class="jt ju hi ix b iy kc jc kd jg ke jk kf jo kg js jy jz ka kb bi translated">如今，JavaScript包可能非常大，所以特别是在慢速连接上，将所有这些代码下载到客户端可能需要一些时间，这又使得页面的初始加载比理想情况慢。</li></ul><h2 id="a379" class="kh ki hi bd kj kk kl km kn ko kp kq kr jg ks kt ku jk kv kw kx jo ky kz la lb bi translated">履行</h2><p id="250c" class="pw-post-body-paragraph iv iw hi ix b iy lh ja jb jc li je jf jg lj ji jj jk lk jm jn jo ll jq jr js hb bi translated">我们如何告诉NextJS我们想使用CSR？让我们来看看一些代码。</p><p id="f78e" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们不需要在用于CSR的React组件中使用任何特殊的NextJS函数。我们可以使用input或类似于<code class="du lm ln lo lp b">useEffect</code>的钩子发出传统的HTTP请求。</p><pre class="ld le lf lg fd lq lp lr ls aw lt bi"><span id="fa0f" class="kh ki hi lp b fi lu lv l lw lx">import React, { useState, useEffect } from 'react'<br/><br/>const Home = () =&gt; {<br/>  const [data, setData] = useState([])<br/>  useEffect(() =&gt; {<br/>    const getData = async () =&gt; {<br/>      const response = await fetch('<a class="ae iu" href="https://official-joke-api.appspot.com/random_ten" rel="noopener ugc nofollow" target="_blank">https://official-joke-api.appspot.com/random_ten</a>')<br/>      const data = await response.json()<br/>      setData(data)<br/>    }<br/>    getData()<br/>  })<br/>  return (<br/>    &lt;main&gt;<br/>      &lt;h1&gt;Here are some Jokes!&lt;/h1&gt;<br/>      &lt;ul&gt;<br/>        {data.map(joke =&gt; (<br/>          &lt;li key={joke.id}&gt;{joke.setup} - {joke.punchline}&lt;/li&gt;<br/>        ))}<br/>      &lt;/ul&gt;<br/>    &lt;/main&gt;<br/>  )<br/>}<br/><br/>export default Home</span></pre><p id="1c9f" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">简单的设置，服务器不做任何繁重的工作。客户端将接收此代码，自己发出请求并构建页面。</p><h2 id="1c9c" class="kh ki hi bd kj kk kl km kn ko kp kq kr jg ks kt ku jk kv kw kx jo ky kz la lb bi translated">2)服务器端渲染</h2><figure class="ld le lf lg fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ly"><img src="../Images/ea94ef15e67f7b63a3381f026027d0fd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*ykXoweFWXwjFY-zE"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">泰勒·维克在Unsplash<a class="ae iu" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">上的照片</a></figcaption></figure><p id="edf1" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">它是如何工作的？</p><p id="a56c" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">服务器端渲染允许我们在服务器上运行React应用程序，因此在站点到达浏览器之前，我们就完成了繁重的工作。</p><p id="7b5d" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">a)客户端通过URL请求页面。</p><p id="a65c" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">b)服务器接收请求并运行附加的Javascript，构建自己的DOM元素。</p><p id="cdf6" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">c)服务器从API请求所需的数据，并将这些数据作为道具提供给React组件。</p><p id="b564" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">d)服务器构建HTML并将完成的页面作为响应发送给客户端。</p><p id="7846" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">服务器端渲染优点:</strong></p><ul class=""><li id="e597" class="jt ju hi ix b iy iz jc jd jg jv jk jw jo jx js jy jz ka kb bi translated">立竿见影！当客户端收到第一页时，数据已经可用。这是慢速连接的理想选择。</li><li id="1dd6" class="jt ju hi ix b iy kc jc kd jg ke jk kf jo kg js jy jz ka kb bi translated">没有客户端获取！服务器已经检索并实现了数据，因此客户端不需要自己发出任何HTTP请求。</li><li id="49eb" class="jt ju hi ix b iy kc jc kd jg ke jk kf jo kg js jy jz ka kb bi translated">伟大的搜索引擎优化！因为当页面被请求时，所有的元数据都已经呈现到HTML中，所以网络爬虫将会看到来自应用程序的所有数据，这对于SEO可见性是理想的。</li></ul><p id="d245" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">服务器端渲染缺点:</strong></p><ul class=""><li id="4565" class="jt ju hi ix b iy iz jc jd jg jv jk jw jo jx js jy jz ka kb bi translated">缓慢的页面转换。你基本上要渲染你的应用两次，一次在服务器上，一次在客户端，所以特别是如果你的应用很大，这会影响页面之间的加载时间。</li><li id="0baa" class="jt ju hi ix b iy kc jc kd jg ke jk kf jo kg js jy jz ka kb bi translated">潜伏。由于服务器正在执行渲染工作，如果有许多用户同时访问应用程序，他们可能会在加载应用程序时遇到延迟。</li><li id="8dbc" class="jt ju hi ix b iy kc jc kd jg ke jk kf jo kg js jy jz ka kb bi translated">UI兼容性。一些UI组件可能严重依赖于window对象，当服务器呈现页面时，window对象实际上并不存在。这可能会导致某些库的兼容性问题。</li></ul><h2 id="8298" class="kh ki hi bd kj kk kl km kn ko kp kq kr jg ks kt ku jk kv kw kx jo ky kz la lb bi translated">履行</h2><p id="7b13" class="pw-post-body-paragraph iv iw hi ix b iy lh ja jb jc li je jf jg lj ji jj jk lk jm jn jo ll jq jr js hb bi translated">让我们看看如何创建一个服务器端呈现的组件。</p><pre class="ld le lf lg fd lq lp lr ls aw lt bi"><span id="d297" class="kh ki hi lp b fi lu lv l lw lx">import React from 'react'</span><span id="40be" class="kh ki hi lp b fi lz lv l lw lx">export async function getServerSideProps(context) {<br/>    const response = await fetch('<a class="ae iu" href="https://official-joke-api.appspot.com/random_ten" rel="noopener ugc nofollow" target="_blank">https://official-joke-api.appspot.com/random_ten</a>')<br/>    const data = await response.json()</span><span id="f1a3" class="kh ki hi lp b fi lz lv l lw lx">return {<br/>    props: { data }<br/>  }<br/>}</span><span id="9b87" class="kh ki hi lp b fi lz lv l lw lx">const Home = ({ data }) =&gt; {<br/>  return (<br/>    &lt;main&gt;<br/>      &lt;h1&gt;Here are some Jokes!&lt;/h1&gt;<br/>      &lt;ul&gt;<br/>        {data.map(joke =&gt; (<br/>          &lt;li key={joke.id}&gt;{joke.setup} - {joke.punchline}&lt;/li&gt;<br/>        ))}<br/>      &lt;/ul&gt;<br/>    &lt;/main&gt;<br/>  )<br/>}<br/><br/>export default Home</span></pre><p id="9837" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">导出这个NextJS函数<code class="du lm ln lo lp b">getServerSideProps</code>将指示应用程序在离开服务器之前检索它的数据，并将其作为props提供给组件。然后，HTML被呈现并发送给客户端。</p><h2 id="59b0" class="kh ki hi bd kj kk kl km kn ko kp kq kr jg ks kt ku jk kv kw kx jo ky kz la lb bi translated">2)静态站点生成</h2><figure class="ld le lf lg fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ma"><img src="../Images/7cba48076d051ec45ae1387d54c2131a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*qrn5Zoz1ThVwBh3r"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">照片由<a class="ae iu" href="https://unsplash.com/@zvessels55?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">扎克船只</a>在<a class="ae iu" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄</figcaption></figure><p id="7db6" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">它是如何工作的？</p><p id="d79c" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">静态站点生成基于页面所需的数据创建了许多静态路径。在构建时，这些路径被呈现到静态页面中，并以令人难以置信的速度提供给客户端。</p><p id="5131" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">a)客户端向服务器发出请求。</p><p id="333f" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">b)服务器接收请求，并且已经为静态数据构建了所需的HTML页面。</p><p id="c636" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">c)服务器基于所请求的URL以完整的、预先构建的页面进行响应。</p><p id="e550" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">静态站点生成优点:</strong></p><ul class=""><li id="8fca" class="jt ju hi ix b iy iz jc jd jg jv jk jw jo jx js jy jz ka kb bi translated">就像服务器端呈现一样，静态站点生成是立即可用的，并且不需要从API获取额外的数据。</li><li id="9f3b" class="jt ju hi ix b iy kc jc kd jg ke jk kf jo kg js jy jz ka kb bi translated">伟大的搜索引擎优化！由于HTML是在发送给客户端之前构建的，所以SSG的SEO可见性是理想的。</li><li id="e747" class="jt ju hi ix b iy kc jc kd jg ke jk kf jo kg js jy jz ka kb bi translated">难以置信的快！静态页面的服务时间快得令人难以置信，与我们在客户端渲染中发送的空白页面的出售时间相当。</li><li id="bb9d" class="jt ju hi ix b iy kc jc kd jg ke jk kf jo kg js jy jz ka kb bi translated">无服务器！提供静态页面不需要服务器来监控，所以您可以充分利用为提供静态页面而设计的服务。</li></ul><p id="38d6" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">静态站点生成缺点:</strong></p><ul class=""><li id="c674" class="jt ju hi ix b iy iz jc jd jg jv jk jw jo jx js jy jz ka kb bi translated">如果你的站点很大很复杂，构建时间会很长。</li><li id="b747" class="jt ju hi ix b iy kc jc kd jg ke jk kf jo kg js jy jz ka kb bi translated">数据在构建时只提取一次，所以不能动态地重新提取和刷新数据。</li><li id="1f82" class="jt ju hi ix b iy kc jc kd jg ke jk kf jo kg js jy jz ka kb bi translated">您可能会遇到与服务器端生成相同的UI兼容性问题，因为window对象在构建时不可用。</li></ul><h2 id="3c67" class="kh ki hi bd kj kk kl km kn ko kp kq kr jg ks kt ku jk kv kw kx jo ky kz la lb bi translated">履行</h2><p id="541c" class="pw-post-body-paragraph iv iw hi ix b iy lh ja jb jc li je jf jg lj ji jj jk lk jm jn jo ll jq jr js hb bi translated">NextJS文档描述了静态站点生成的两种场景。首先是创建一个不依赖于任何外部数据的静态页面。在这种情况下，我们只需要使用NextJS <code class="du lm ln lo lp b">getStaticProps</code>函数来加载一些静态资产。</p><pre class="ld le lf lg fd lq lp lr ls aw lt bi"><span id="a0de" class="kh ki hi lp b fi lu lv l lw lx">function Blog({ posts }) {<br/>  return (<br/>    &lt;ul&gt;<br/>      {posts.map((post) =&gt; (<br/>        &lt;li&gt;{post.title}&lt;/li&gt;<br/>      ))}<br/>    &lt;/ul&gt;<br/>  )<br/>}<br/><br/>export async function getStaticProps() {<br/>  const res = await fetch('https://.../posts')<br/>  const posts = await res.json()<br/><br/>  return {<br/>    props: {<br/>      posts,<br/>    },<br/>  }<br/>}<br/><br/>export default Blog</span></pre><p id="b613" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">就像<code class="du lm ln lo lp b">getServerSideProps</code>一样，我们在构建时将数据作为道具输入到组件中，页面生成为静态页面，并根据客户端的请求提供服务。</p><p id="e316" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如果我们需要为我们的数据创建动态路由，例如，转到博客文章页面查看更多信息。为了处理这个问题，Next.js允许您使用语法(pages/* resource */[* paramater *]):<code class="du lm ln lo lp b">pages/posts/[id].js </code>从动态页面导出一个名为<code class="du lm ln lo lp b">getStaticPaths</code>的异步函数。</p><p id="e001" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这允许您在构建时挑选要预先呈现到静态页面中的路径。</p><pre class="ld le lf lg fd lq lp lr ls aw lt bi"><span id="76a6" class="kh ki hi lp b fi lu lv l lw lx">export async function getStaticPaths() {<br/>  const res = await fetch('https://.../posts')<br/>  const posts = await res.json()</span><span id="db70" class="kh ki hi lp b fi lz lv l lw lx">  const paths = posts.map((post) =&gt; ({<br/>    params: { id: post.id },<br/>  }))</span><span id="0dc6" class="kh ki hi lp b fi lz lv l lw lx">  return { paths, fallback: false }<br/>}</span></pre><p id="9470" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们还可以设置一个回退，在这个例子中是<code class="du lm ln lo lp b">false</code>，所以如果没有找到路径，我们将只呈现一个404。</p><h1 id="e2f8" class="mb ki hi bd kj mc md me kn mf mg mh kr mi mj mk ku ml mm mn kx mo mp mq la mr bi translated">结论(用例):</h1><ul class=""><li id="c2f2" class="jt ju hi ix b iy lh jc li jg ms jk mt jo mu js jy jz ka kb bi translated">客户端渲染非常适合登录体验和单页面应用程序。如果您需要在每次交互时对用户进行身份验证，CSR是一个不错的选择。在性能不重要的情况下，创建概念证明是另一个用例。</li><li id="8f84" class="jt ju hi ix b iy kc jc kd jg ke jk kf jo kg js jy jz ka kb bi translated">服务器端呈现非常适合为慢速连接创建页面，并保持SEO可见性。</li><li id="3dea" class="jt ju hi ix b iy kc jc kd jg ke jk kf jo kg js jy jz ka kb bi translated">如果我需要服务器端呈现的好处，但只依赖于不经常改变的数据集，静态站点生成将是完美的，因为页面需要重新构建以反映新的依赖数据。</li></ul><p id="65c8" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">NextJS处于最大化互联网体验的前沿，这些选项为我们的网站生成方案提供了广泛的灵活性。查看文档以了解更多信息！</p></div><div class="ab cl mv mw gp mx" role="separator"><span class="my bw bk mz na nb"/><span class="my bw bk mz na nb"/><span class="my bw bk mz na"/></div><div class="hb hc hd he hf"><p id="0b1e" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">附加阅读:</p><div class="nc nd ez fb ne nf"><a href="https://nextjs.org/docs/basic-features/pages" rel="noopener  ugc nofollow" target="_blank"><div class="ng ab dw"><div class="nh ab ni cl cj nj"><h2 class="bd hj fi z dy nk ea eb nl ed ef hh bi translated">基本功能:Pages | Next.js</h2><div class="nm l"><h3 class="bd b fi z dy nk ea eb nl ed ef dx translated">Next.js页面是在pages目录下的文件中导出的React组件。了解他们如何在这里工作。</h3></div><div class="nn l"><p class="bd b fp z dy nk ea eb nl ed ef dx translated">nextjs.org</p></div></div><div class="no l"><div class="np l nq nr ns no nt io nf"/></div></div></a></div></div></div>    
</body>
</html>