<html>
<head>
<title>Write better tests with Jest and Testing Library</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用Jest和测试库编写更好的测试</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/write-better-tests-with-jest-and-testing-library-e7eee393e583?source=collection_archive---------1-----------------------#2021-11-05">https://medium.com/nerd-for-tech/write-better-tests-with-jest-and-testing-library-e7eee393e583?source=collection_archive---------1-----------------------#2021-11-05</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="61e9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">采取渐进的步骤来编写无实现细节的测试</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es jd"><img src="../Images/83dccccabc95fd965bd88da0848e35f5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*S4GfPGAVUQWg7_TkYwC3gA.png"/></div></div></figure><h1 id="5897" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">放弃</h1><p id="1dae" class="pw-post-body-paragraph if ig hi ih b ii kn ik il im ko io ip iq kp is it iu kq iw ix iy kr ja jb jc hb bi translated">在这个演示中，我使用从Angular CLI生成的应用程序代码和测试(当创建新项目时),并假设这是实际的生产应用程序。我相信这足以指出如何改进我们的测试策略。</p><h1 id="a7d9" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">先决条件</h1><h2 id="c8bc" class="ks jq hi bd jr kt ku kv jv kw kx ky jz iq kz la kd iu lb lc kh iy ld le kl lf bi translated">角度投影</h2><p id="7c66" class="pw-post-body-paragraph if ig hi ih b ii kn ik il im ko io ip iq kp is it iu kq iw ix iy kr ja jb jc hb bi translated">遵循<a class="ae lg" href="https://angular.io/cli" rel="noopener ugc nofollow" target="_blank">角度命令</a>创建新项目。创建一个之后，尝试使用以下命令在本地提供服务。</p><pre class="je jf jg jh fd lh li lj lk aw ll bi"><span id="7b58" class="ks jq hi li b fi lm ln l lo lp">ng serve</span></pre><p id="7566" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在浏览器中，打开<a class="ae lg" href="http://localhost:4200/" rel="noopener ugc nofollow" target="_blank"> http://localhost:4200/ </a>查看新应用程序的运行。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es lq"><img src="../Images/97e9ee0e70f68855210dde5749642d55.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pog532PYSyYNoXmpeJzcXA.png"/></div></div><figcaption class="lr ls et er es lt lu bd b be z dx translated">应用程序在本地启动并运行</figcaption></figure><h1 id="8a19" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">重写测试# 0——从初始测试开始</h1><p id="9728" class="pw-post-body-paragraph if ig hi ih b ii kn ik il im ko io ip iq kp is it iu kq iw ix iy kr ja jb jc hb bi translated">角度应用由示例代码和测试生成。通过运行下面的命令，您会看到所有测试都通过了。</p><pre class="je jf jg jh fd lh li lj lk aw ll bi"><span id="1eb3" class="ks jq hi li b fi lm ln l lo lp">ng test</span></pre><p id="b694" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">仔细看看。您会看到这些是实现细节测试。</p><ul class=""><li id="a9fe" class="lv lw hi ih b ii ij im in iq lx iu ly iy lz jc ma mb mc md bi translated">测试#1断言创建了组件的一个实例— <em class="me">除了组件可以被实例化之外，它什么也没说</em></li><li id="3e21" class="lv lw hi ih b ii mf im mg iq mh iu mi iy mj jc ma mb mc md bi translated">测试#2断言组件属性的值— <em class="me">，即使测试通过，但这并不保证该属性将被正确地绑定到视图，并且对用户可见</em></li><li id="6c0c" class="lv lw hi ih b ii mf im mg iq mh iu mi iy mj jc ma mb mc md bi translated">test#3查询class和html标记以在显示的文本上断言— <em class="me">这比前两个要好。但是css选择器对最终用户是不可见的(他们也不在乎)。如果开发人员决定重新设计/重构，例如类名的改变，测试将会失败，但是应用程序仍然可以工作(假阴性)。</em></li></ul><pre class="je jf jg jh fd lh li lj lk aw ll bi"><span id="00b7" class="ks jq hi li b fi lm ln l lo lp">import { TestBed } from '@angular/core/testing';<br/>import { AppComponent } from './app.component';</span><span id="b43a" class="ks jq hi li b fi mk ln l lo lp">describe('AppComponent', () =&gt; {<br/>  beforeEach(async () =&gt; {<br/>    await TestBed.configureTestingModule({<br/>      declarations: [AppComponent],<br/>    }).compileComponents();<br/>  });</span><span id="e9ec" class="ks jq hi li b fi mk ln l lo lp">//test#1<br/>  it('should create the app', () =&gt; {<br/>    const fixture = TestBed.createComponent(AppComponent);<br/>    const app = fixture.componentInstance;<br/>    expect(app).toBeTruthy();<br/>  });</span><span id="b237" class="ks jq hi li b fi mk ln l lo lp">//test#2<br/>  it(`should have as title 'my-first-project'`, () =&gt; {<br/>    const fixture = TestBed.createComponent(AppComponent);<br/>    const app = fixture.componentInstance;<br/>    expect(app.title).toEqual('my-first-project');<br/>  });</span><span id="a275" class="ks jq hi li b fi mk ln l lo lp">//test#3<br/>  it('should render title', () =&gt; {<br/>    const fixture = TestBed.createComponent(AppComponent);<br/>    fixture.detectChanges();<br/>    const compiled = fixture.nativeElement as HTMLElement;<br/>    expect(compiled.querySelector('.content span')?.textContent).toContain('my-first-project app is running!');<br/>  });<br/>});</span></pre><h1 id="97af" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">重写测试# 1——考虑用例</h1><p id="93cd" class="pw-post-body-paragraph if ig hi ih b ii kn ik il im ko io ip iq kp is it iu kq iw ix iy kr ja jb jc hb bi translated">我提出了两个新的用例(最初可能更多，但是对于这个演示来说两个用例就足够了)，即用户可以看到应用程序的标题(测试#1)，用户可以单击按钮并看到自动生成的命令(测试#2，测试#3)。</p><ul class=""><li id="3c4e" class="lv lw hi ih b ii ij im in iq lx iu ly iy lz jc ma mb mc md bi translated">测试#1在显示的文本上断言</li><li id="239e" class="lv lw hi ih b ii mf im mg iq mh iu mi iy mj jc ma mb mc md bi translated">测试#2单击“新组件”按钮，并在终端显示的命令上断言</li><li id="ae9f" class="lv lw hi ih b ii mf im mg iq mh iu mi iy mj jc ma mb mc md bi translated">测试#3点击“角材料”按钮，并在终端显示的命令上断言</li></ul><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es lq"><img src="../Images/24eaec0c9b2c8eba9b0769cd4c848c51.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*afYfcpOb1A8-VibGzWRVUw.png"/></div></div></figure><pre class="je jf jg jh fd lh li lj lk aw ll bi"><span id="fd3e" class="ks jq hi li b fi lm ln l lo lp">import { TestBed } from '@angular/core/testing';<br/>import { AppComponent } from './app.component';</span><span id="565c" class="ks jq hi li b fi mk ln l lo lp">describe('AppComponent', () =&gt; {</span><span id="d9e7" class="ks jq hi li b fi mk ln l lo lp">beforeEach(async () =&gt; {<br/>    await TestBed.configureTestingModule({<br/>      declarations: [AppComponent],<br/>    }).compileComponents();<br/>  });</span><span id="31a9" class="ks jq hi li b fi mk ln l lo lp">test('should render title and display angular cli command after clicking button - using Karma and Jasmine', async () =&gt; {</span><span id="d468" class="ks jq hi li b fi mk ln l lo lp">//test#1 assert on the displayed text<br/>    const fixture = TestBed.createComponent(AppComponent);<br/>    fixture.detectChanges();<br/>    const compiled = fixture.nativeElement as HTMLElement;<br/>    expect(compiled.querySelector('.content span')?.textContent).toContain('my-first-project app is running!');</span><span id="c534" class="ks jq hi li b fi mk ln l lo lp">//test#2 click ‘New Component’ button and assert on the <br/>//displayed command in terminal<br/>    const terminal = fixture.nativeElement.querySelector('.terminal');<br/>    let buttonElement = fixture.debugElement.query(debugEl =&gt; debugEl.name === 'button' &amp;&amp; debugEl.nativeElement.textContent === 'New Component');<br/>    buttonElement.triggerEventHandler('click', null);<br/>    fixture.detectChanges();<br/>    await fixture.whenStable();<br/>    expect(terminal.textContent).toBe('ng generate component xyz');</span><span id="9830" class="ks jq hi li b fi mk ln l lo lp">//test#3 click ‘Angular Material’ button and assert on the  <br/>//displayed command in terminal<br/>    buttonElement = fixture.debugElement.query(debugEl =&gt; debugEl.name === 'button' &amp;&amp; debugEl.nativeElement.textContent === 'Angular Material');<br/>    buttonElement.triggerEventHandler('click', null);<br/>    fixture.detectChanges();<br/>    await fixture.whenStable();<br/>    expect(terminal.textContent).toBe('ng add @angular/material');<br/>    expect(terminal.textContent).not.toBe('ng generate component xyz');<br/>  });<br/>});</span></pre><p id="010b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">它更好，但是…语法似乎非常复杂，没有人能一目了然。</p><h1 id="db68" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">重写测试# 2——使用角度测试库编写实现细节自由的测试</h1><p id="73ef" class="pw-post-body-paragraph if ig hi ih b ii kn ik il im ko io ip iq kp is it iu kq iw ix iy kr ja jb jc hb bi translated">在这个增量步骤中，我用<code class="du ml mm mn li b">jest</code>替换了<code class="du ml mm mn li b">Karma</code>和<code class="du ml mm mn li b">Jasmine</code>，还添加了<code class="du ml mm mn li b">@testing-library/angular-testing-library</code>。</p><h2 id="6a27" class="ks jq hi bd jr kt ku kv jv kw kx ky jz iq kz la kd iu lb lc kh iy ld le kl lf bi translated">用笑话代替因果报应和茉莉</h2><p id="17cb" class="pw-post-body-paragraph if ig hi ih b ii kn ik il im ko io ip iq kp is it iu kq iw ix iy kr ja jb jc hb bi translated">遵循<a class="ae lg" href="https://thymikee.github.io/jest-preset-angular/docs/getting-started/installation/" rel="noopener ugc nofollow" target="_blank">预设角度文档</a></p><h2 id="6241" class="ks jq hi bd jr kt ku kv jv kw kx ky jz iq kz la kd iu lb lc kh iy ld le kl lf bi translated">添加角度测试库</h2><p id="7aa5" class="pw-post-body-paragraph if ig hi ih b ii kn ik il im ko io ip iq kp is it iu kq iw ix iy kr ja jb jc hb bi translated">遵循其<a class="ae lg" href="https://github.com/testing-library/angular-testing-library" rel="noopener ugc nofollow" target="_blank">文档</a></p><p id="0006" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">重写测试后，您可以看到这些测试不依赖于实现细节。我们现在测试应用程序的方式与用户使用它的方式相同，并根据用户在屏幕上看到的内容进行断言。这些实用程序函数使测试易于理解。</p><pre class="je jf jg jh fd lh li lj lk aw ll bi"><span id="430a" class="ks jq hi li b fi lm ln l lo lp">import { fireEvent, render, screen } from '@testing-library/angular';<br/>import { AppComponent } from './app.component';</span><span id="3b10" class="ks jq hi li b fi mk ln l lo lp">describe('AppComponent', () =&gt; {<br/>  test('should render title and display angular cli command after clicking button - using angular testing library', async () =&gt; {<br/>    <strong class="li hj">await render(AppComponent);</strong></span><span id="ce70" class="ks jq hi li b fi mk ln l lo lp">//test#1 assert on the displayed text     <br/>    <strong class="li hj">expect(screen.getByText(`my-first-project app is running!`))</strong></span><span id="ae4f" class="ks jq hi li b fi mk ln l lo lp">//test#2 click ‘New Component’ button and assert on the <br/>//displayed command in terminal    <br/>    <strong class="li hj">fireEvent.click(screen.getByRole('button', { name: /New Component/i }));<br/>    expect(screen.getByText(`ng generate component xyz`));</strong></span><span id="9d7a" class="ks jq hi li b fi mk ln l lo lp">//test#3 click ‘Angular Material’ button and assert on the  <br/>//displayed command in terminal    <br/>    <strong class="li hj">fireEvent.click(screen.getByRole('button', { name: /Angular Material/i }));<br/>    expect(screen.getByText(`ng add @angular/material`));<br/>    expect(screen.queryByText(`ng generate component xyz`)).toBeNull;</strong><br/>  });<br/>});</span></pre><h1 id="f3a1" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">重写测试# 3——用<code class="du ml mm mn li b">userEvent</code>替换<code class="du ml mm mn li b">fireEvent</code></h1><p id="6b0f" class="pw-post-body-paragraph if ig hi ih b ii kn ik il im ko io ip iq kp is it iu kq iw ix iy kr ja jb jc hb bi translated">这是相对较小的一步。我添加了<code class="du ml mm mn li b">@testing-library/user-event</code>库——“它模拟了用户与浏览器交互时会在浏览器中发生的真实事件”。您可以看到它提供了来自<code class="du ml mm mn li b">fireEvent</code>的高级API。</p><h2 id="a618" class="ks jq hi bd jr kt ku kv jv kw kx ky jz iq kz la kd iu lb lc kh iy ld le kl lf bi translated">添加用户事件</h2><p id="c96a" class="pw-post-body-paragraph if ig hi ih b ii kn ik il im ko io ip iq kp is it iu kq iw ix iy kr ja jb jc hb bi translated">遵循其<a class="ae lg" href="https://github.com/testing-library/user-event" rel="noopener ugc nofollow" target="_blank">文档</a></p><pre class="je jf jg jh fd lh li lj lk aw ll bi"><span id="8f53" class="ks jq hi li b fi lm ln l lo lp">import { render, screen } from '@testing-library/angular';<br/><strong class="li hj">import userEvent from '</strong><a class="ae lg" href="http://twitter.com/testing" rel="noopener ugc nofollow" target="_blank"><strong class="li hj">@testing</strong></a><strong class="li hj">-library/user-event';</strong><br/>import { AppComponent } from './app.component';</span><span id="6358" class="ks jq hi li b fi mk ln l lo lp">describe('AppComponent', () =&gt; {<br/>  test('should render title and display angular cli command after clicking button - using angular testing library, userEvent', async () =&gt; {<br/>    await render(AppComponent);<br/>    <br/>    //test#1 assert on the displayed text<br/>    expect(screen.getByText(`my-first-project app is running!`))<br/>    <br/>    //test#2 click ‘New Component’ button and assert on the <br/>    //displayed command in terminal<br/>    <strong class="li hj">userEvent.click</strong>(screen.getByRole('button', { name: /New Component/i }));<br/>    expect(screen.getByText(`ng generate component xyz`));</span><span id="d4b5" class="ks jq hi li b fi mk ln l lo lp">//test#3 click ‘Angular Material’ button and assert on the  <br/>    //displayed command in terminal<br/>    <strong class="li hj">userEvent.click</strong>(screen.getByRole('button', { name: /Angular Material/i }));<br/>    expect(screen.getByText(`ng add @angular/material`));<br/>    expect(screen.queryByText(`ng generate component xyz`)).toBeNull;<br/>  });<br/>});</span></pre><h1 id="7c68" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">重写测试#4 —用<code class="du ml mm mn li b">toBeInTheDocument</code>替换<code class="du ml mm mn li b">toBeNull</code></h1><p id="2f2d" class="pw-post-body-paragraph if ig hi ih b ii kn ik il im ko io ip iq kp is it iu kq iw ix iy kr ja jb jc hb bi translated">另一个小步骤是，<code class="du ml mm mn li b">@testing-library/jest-dom</code>库提供了一组自定义的jest匹配器来扩展<code class="du ml mm mn li b">jest</code>。这将使测试更具声明性，更易于阅读和维护。</p><h2 id="d94a" class="ks jq hi bd jr kt ku kv jv kw kx ky jz iq kz la kd iu lb lc kh iy ld le kl lf bi translated">添加笑话</h2><p id="1bd5" class="pw-post-body-paragraph if ig hi ih b ii kn ik il im ko io ip iq kp is it iu kq iw ix iy kr ja jb jc hb bi translated">遵循其<a class="ae lg" href="https://github.com/testing-library/jest-dom" rel="noopener ugc nofollow" target="_blank">文档</a></p><p id="dcb6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在我们将从<code class="du ml mm mn li b">toBeNull</code>改为<code class="du ml mm mn li b">toBeInTheDocument</code>——这将使测试更具声明性。<code class="du ml mm mn li b">toBeInTheDocument</code>允许断言文档中是否存在某个元素。</p><pre class="je jf jg jh fd lh li lj lk aw ll bi"><span id="5aeb" class="ks jq hi li b fi lm ln l lo lp">import { render, screen } from '@testing-library/angular';<br/>import userEvent from '<a class="ae lg" href="http://twitter.com/testing" rel="noopener ugc nofollow" target="_blank">@testing</a>-library/user-event';<br/>import { AppComponent } from './app.component';</span><span id="0cfc" class="ks jq hi li b fi mk ln l lo lp">describe('AppComponent', () =&gt; {<br/>  test('should render title and display angular cli command after clicking button - using angular testing library, userEvent, jest-dom', async () =&gt; {<br/>    await render(AppComponent);</span><span id="6cf9" class="ks jq hi li b fi mk ln l lo lp">//test#1 assert on the displayed text     <br/>    expect(screen.getByText(`my-first-project app is running!`))<br/>    <br/>//test#2 click ‘New Component’ button and assert on the <br/>//displayed command in  terminal<br/>    userEvent.click(screen.getByRole('button', { name: /New Component/i }));<br/>    expect(screen.getByText(`ng generate component xyz`));</span><span id="70c5" class="ks jq hi li b fi mk ln l lo lp">//test#3 click ‘Angular Material’ button and assert on the  <br/>//displayed command in terminal<br/>    userEvent.click(screen.getByRole('button', { name: /Angular Material/i }));<br/>    expect(screen.getByText(`ng add @angular/material`));<br/>    expect(screen.queryByText(`ng generate component xyz`))<strong class="li hj">.not.toBeInTheDocument();</strong><br/>  });<br/>});</span></pre><h1 id="72fb" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">摘要</h1><p id="44d7" class="pw-post-body-paragraph if ig hi ih b ii kn ik il im ko io ip iq kp is it iu kq iw ix iy kr ja jb jc hb bi translated">我有3个理由来说明为什么我们需要编写测试，测试库可以帮助我在各个方面进行改进。</p><ol class=""><li id="9e99" class="lv lw hi ih b ii ij im in iq lx iu ly iy lz jc mo mb mc md bi translated"><strong class="ih hj">将代码交付到产品的信心</strong>:让我引用<a class="ae lg" href="https://testing-library.com/docs/guiding-principles/" rel="noopener ugc nofollow" target="_blank">来自测试库<em class="me">的指导原则</em></a>你的测试越像你的软件被使用的方式，他们就能给你越多的信心。”</li><li id="7805" class="lv lw hi ih b ii mf im mg iq mh iu mi iy mj jc mo mb mc md bi translated"><strong class="ih hj">重构/实现附加特性的安全网</strong>:编写实现细节自由测试可以避免重构带来的测试失败。我们现在可以肯定，测试失败是有原因的❎误报❎误报。</li><li id="0073" class="lv lw hi ih b ii mf im mg iq mh iu mi iy mj jc mo mb mc md bi translated">文档:测试库提供了更高级的API，使得测试更具声明性和可理解性。任何人都可以查看测试，并且应该能够理解这些被测试组件中的用例。</li></ol></div></div>    
</body>
</html>