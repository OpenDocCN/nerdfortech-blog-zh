<html>
<head>
<title>Graph Traversal in Python:A* algorithm</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python中的图遍历:A*算法</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/graph-traversal-in-python-a-algorithm-27c30d67e0d0?source=collection_archive---------0-----------------------#2021-03-29">https://medium.com/nerd-for-tech/graph-traversal-in-python-a-algorithm-27c30d67e0d0?source=collection_archive---------0-----------------------#2021-03-29</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="d00f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们之前在Python中经历了<a class="ae jd" rel="noopener" href="/nerd-for-tech/graph-traversal-in-python-breadth-first-search-bfs-b6cff138d516">广度优先搜索(BFS) </a>、<a class="ae jd" rel="noopener" href="/nerd-for-tech/graph-traversal-in-python-depth-first-search-dfs-ce791f48af5b">深度优先搜索(DFS) </a>、<a class="ae jd" rel="noopener" href="/nerd-for-tech/graph-traversal-in-python-dijkstras-search-895c1d5aa1b1"> Dijkstra的搜索</a>。在本文中，我们将通过几个例子和说明来介绍A*算法。然后我们将尝试并行比较这些算法。</p><p id="a16c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">简而言之，BFS和DFS实际上是遍历整个图中的所有节点，没有特定的“目的地”或“目标”。Dijkstra做了同样的事情，但是它的目的地是“无处不在”(所有节点)。</p><p id="ebca" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这不是我们想要的，因为直觉上，搜索算法应该从某处开始，到某处结束，点到点。现在我们有了A*算法来完成这个任务。</p><p id="ee45" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们不能责怪BFS、DFS和Dijkstra不去任何地方或只是去任何地方。因为我们从来没有告诉算法这样做。事情是这样的，我们需要通过给它一些点击来“告诉”算法有一个目标，这被称为启发式，可以如下图所示:2，~5是那个节点到最终目标的估计距离。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div class="er es je"><img src="../Images/50d4ba2507c9fa506ee6555fad605901.png" data-original-src="https://miro.medium.com/v2/resize:fit:794/format:webp/1*rmQwx1CK1L65KFim8rRB0Q.png"/></div></figure><p id="ccfe" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">由于这些新信息，我们需要创建新的容器来存储它，并根据新的特性进行“放松”。我们还有节点间的初始距离，人们称之为g-score。我们有启发式值，也是一个权重或距离，称为h-score。g-score和h-score的总和就是所谓的f-score的新特征。</p><p id="f485" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">放松现在应用于f分数，并选择最小的分数以推入下一轮循环的临时队列。</p><p id="de11" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">上面的图形示例表示如下:节点每个节点都有一个以上的信息。我们创建了一个列表来存储边长以及启发式权重(即从该节点到最终目的地的距离)。</p><pre class="jf jg jh ji fd jm jn jo jp aw jq bi"><span id="d6c0" class="jr js hi jn b fi jt ju l jv jw">graph={<br/>    # now we need a list as the value to store g-score and h-score<br/>    # list first value is the g-score, second value is the h-score,i.e., heuristic<br/>    'A':{'B':[2,2],'C':[3,2]},<br/>    'B':{'D':[3,5],'E':[1,1]},<br/>    'C':{'F':[2,0]},<br/>    'D':{},<br/>    'E':{'F':[1,0]},<br/>    'F':{}<br/>}<br/># the algorithm will retrieve the graph as follow:<br/>graph['A']<br/># this return {'B':[2,2],'C':[3,2]}<br/>graph['A']['B']<br/># this return [2,2]<br/>graph['A']['B'][0]# return the edge length<br/>graph['A']['B'][1]# return the distance of the node to destination</span></pre><p id="f316" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们把整个算法放在这里，以后再解释。(对缩进表示抱歉，如有必要，请调整缩进。)</p><pre class="jf jg jh ji fd jm jn jo jp aw jq bi"><span id="39cb" class="jr js hi jn b fi jt ju l jv jw">def astar(graph,start_node,end_node):<br/>    # astar: F=G+H, we name F as f_distance, G as g_distance, <br/>    # H as heuristic</span><span id="ecec" class="jr js hi jn b fi jx ju l jv jw">    f_distance={node:float('inf') for node in graph}<br/>    f_distance[start_node]=0<br/>    <br/>    g_distance={node:float('inf') for node in graph}<br/>    g_distance[start_node]=0<br/>    <br/>    came_from={node:None for node in graph}<br/>    came_from[start_node]=start_node<br/>    <br/>    queue=[(0,start_node)]</span><span id="62cd" class="jr js hi jn b fi jx ju l jv jw">    while queue:<br/>        current_f_distance,current_node=heapq.heappop(queue)<br/><br/>        if current_node == end_node:<br/>            print('found the end_node')<br/>            return f_distance, came_from<br/>        for next_node,weights in graph[current_node].items():</span><span id="b409" class="jr js hi jn b fi jx ju l jv jw">            temp_g_distance=g_distance[current_node]+weights[0]</span><span id="d82a" class="jr js hi jn b fi jx ju l jv jw">            if temp_g_distance&lt;g_distance[next_node]:</span><span id="fb58" class="jr js hi jn b fi jx ju l jv jw">                g_distance[next_node]=temp_g_distance<br/>                heuristic=weights[1]</span><span id="3600" class="jr js hi jn b fi jx ju l jv jw">                f_distance[next_node]=temp_g_distance+heuristic<br/>                came_from[next_node]=current_node<br/>                <br/>                heapq.heappush(queue,(f_distance[next_node],next_node))</span><span id="c614" class="jr js hi jn b fi jx ju l jv jw">return f_distance, came_from</span><span id="ff99" class="jr js hi jn b fi jx ju l jv jw">astar(graph,'A','F')<br/># return {'A': 0, 'B': 4, 'C': 5, 'D': 10, 'E': 4, 'F': 4} and <br/># {'A': 'A', 'B': 'A', 'C': 'A', 'D': 'B', 'E': 'B', 'F': 'E'}</span></pre><p id="20a0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">的确，集装箱多了，辅助线也多了。然而，这感觉就像Dijkstra的算法，只有一行不同。正是这种新的特征构建方式产生了这种差异。这是:初始边长(g_distance)现在必须累加启发式。</p><pre class="jf jg jh ji fd jm jn jo jp aw jq bi"><span id="5ed1" class="jr js hi jn b fi jt ju l jv jw">f_distance[next_node]=temp_g_distance+heuristic</span></pre><p id="bf10" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">下面是一个例子:通过使用我们的“提示”，算法绕过一些节点，直接到达目的地。注意边上有箭头。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jz ka di kb bf kc"><div class="er es jy"><img src="../Images/e3457f4280a01b0ca8dfbd01cf6fb011.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NbyRmnU1Dz9M5YyasOMrPw.png"/></div></div></figure><p id="b9fb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">有一点需要注意，我们需要一个g-score容器来存储从起点到那个节点的距离，这解释了为什么节点D的权重被计算为2+3+5，其中2是A-&gt;B之间的距离，3是B-&gt;D之间的距离，5是节点D本身的启发式。在代码中，我们如何累加2+3？我们需要下面的容器并用infinity初始化它。</p><pre class="jf jg jh ji fd jm jn jo jp aw jq bi"><span id="aa22" class="jr js hi jn b fi jt ju l jv jw">g_distance={node:float('inf') for node in graph}</span></pre><p id="aec8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">就像Dijkstra算法一样。heappop()方法确保弹出最小f值。虽然我们得到了当前的f距离，但是我们没有利用它，因为我们只需要那个节点的g距离。</p><pre class="jf jg jh ji fd jm jn jo jp aw jq bi"><span id="0a61" class="jr js hi jn b fi jt ju l jv jw">current_f_distance,current_node=heapq.heappop(queue)</span></pre><p id="48ad" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">与Dijkstra一样，我们使用came _ from容器来存储到目前为止形成最便宜路径的前任节点。但是我们不需要填满这个容器。有些人直到最后还是一无所有。</p><pre class="jf jg jh ji fd jm jn jo jp aw jq bi"><span id="ced1" class="jr js hi jn b fi jt ju l jv jw">came_from={node:None for node in graph}</span></pre></div><div class="ab cl kd ke gp kf" role="separator"><span class="kg bw bk kh ki kj"/><span class="kg bw bk kh ki kj"/><span class="kg bw bk kh ki"/></div><div class="hb hc hd he hf"><p id="cfb6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这是另一个稍微复杂一点的例子。该示例摘自参考youtube链接。那个视频里的讲师已经很好的解释了A*的概念。强烈推荐详细过一遍他的视频。</p><pre class="jf jg jh ji fd jm jn jo jp aw jq bi"><span id="9c5d" class="jr js hi jn b fi jt ju l jv jw">complex_graph={<br/>    'S':{'A':[5,7],'B':[9,3],'D':[6,6]},<br/>    'A':{'B':[3,3],'G1':[9,0]},<br/>    'B':{'A':[2,7],'C':[1,4]},<br/>    'C':{'S':[6,4],'G2':[5,0],'F':[7,6]},<br/>    'D':{'S':[1,5],'C':[2,4],'E':[2,5]},<br/>    'E':{'G3':[7,0]},<br/>    'F':{'G3':[8,0]},<br/>    'G1':{},<br/>    'G2':{},<br/>    'G3':{}<br/>}<br/></span></pre><p id="db55" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">下图所示:请注意，在某些节点之间有向上或向后的箭头。请自己试一下代码。你会注意到算法绕过了一些节点，直接到达它的目标。此外，算法可能会四处漫游，以确保它不会错过潜在的选项(漫游是由。heappop()方法，它总是寻找更小的f-score并检查它们，尽管对人类来说我们可以看到目标只是前进了一步！).</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div class="er es kk"><img src="../Images/3e64df95012cb89e9a34b25e43c98b93.png" data-original-src="https://miro.medium.com/v2/resize:fit:1348/format:webp/1*oXEZVVC3UC7iIl4AjvHUtw.png"/></div></figure></div><div class="ab cl kd ke gp kf" role="separator"><span class="kg bw bk kh ki kj"/><span class="kg bw bk kh ki kj"/><span class="kg bw bk kh ki"/></div><div class="hb hc hd he hf"><p id="58af" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">参考阅读:</strong></p><p id="978e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">【https://www.youtube.com/watch?v=6TsL96NAZCo】T2&amp;t = 7s</p></div></div>    
</body>
</html>