<html>
<head>
<title>NLP Zero to One: Recurrent Neural Networks Basics Part(8/30)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">NLP 零到一:递归神经网络基础部分(8/30)</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/nlp-zero-to-one-recurrent-neural-networks-basics-part-8-30-ca77af9d47ff?source=collection_archive---------22-----------------------#2021-03-02">https://medium.com/nerd-for-tech/nlp-zero-to-one-recurrent-neural-networks-basics-part-8-30-ca77af9d47ff?source=collection_archive---------22-----------------------#2021-03-02</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="de02" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">通过时间的反向传播、消失梯度、剪辑</h2></div><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ix"><img src="../Images/4c3e6db40260ffbc3e82874963608041.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rkn8UaJreN9Qmf4L56zpnw.png"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">由作者生成</figcaption></figure><h1 id="6d4c" class="jn jo hi bd jp jq jr js jt ju jv jw jx io jy ip jz ir ka is kb iu kc iv kd ke bi translated">介绍</h1><p id="e8b5" class="pw-post-body-paragraph kf kg hi kh b ki kj ij kk kl km im kn ko kp kq kr ks kt ku kv kw kx ky kz la hb bi translated">到目前为止，我们研究了不考虑单词之间的长期依赖性和上下文顺序的方法。即使在开发单词嵌入时，在上下文单词中仍然不考虑单词的顺序。词的顺序在许多自然语言处理任务中起着非常重要的作用。例如“人咬狗”和“狗咬人”这两个句子用词相同，但意思完全不同。所以，我们到目前为止对<em class="lb">包词</em>的理解必须延伸到<em class="lb">词序</em>。在这篇博客中，我们介绍了将深度学习扩展到序列的递归神经网络(RNNs ),我们还将描述 RNN 的训练过程。</p><h1 id="f823" class="jn jo hi bd jp jq jr js jt ju jv jw jx io jy ip jz ir ka is kb iu kc iv kd ke bi translated">重复…</h1><p id="fb70" class="pw-post-body-paragraph kf kg hi kh b ki kj ij kk kl km im kn ko kp kq kr ks kt ku kv kw kx ky kz la hb bi translated">RNN 是简单的前馈网络，就像我们之前介绍的神经网络一样，它采用一系列向量作为输入。但是有一个额外的组件使它能够学习序列。这个成分叫做记忆/历史。让我们试着理解记忆的概念。</p><p id="4e57" class="pw-post-body-paragraph kf kg hi kh b ki lc ij kk kl ld im kn ko le kq kr ks lf ku kv kw lg ky kz la hb bi translated">如前所述，RNN 消耗一系列向量作为输入，让我们将输入序列定义为时间步长为 T 的 X，其中<strong class="kh hj"> X = {x1，x2，.。。，xT } </strong>其中 xT 是在时间 t 的向量输入。然后我们将直到时间 t 的记忆或历史定义为<strong class="kh hj"> ht。</strong></p><p id="d825" class="pw-post-body-paragraph kf kg hi kh b ki lc ij kk kl ld im kn ko le kq kr ks lf ku kv kw lg ky kz la hb bi translated">为了将连续上下文结合到下一个时间步的预测中，必须保留序列中先前时间步的记忆<strong class="kh hj"> (ht) </strong>。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es lh"><img src="../Images/b3a7032a94f0775f4247aa1b6b352389.png" data-original-src="https://miro.medium.com/v2/resize:fit:682/format:webp/1*ek3NWKRmLFQ50HwR1Ul_Qw.png"/></div></figure><p id="16a4" class="pw-post-body-paragraph kf kg hi kh b ki lc ij kk kl ld im kn ko le kq kr ks lf ku kv kw lg ky kz la hb bi translated">函数<strong class="kh hj"> f(。)</strong>将<strong class="kh hj">存储器和输入</strong>映射到时间 t 的输出。上一时间步的存储器为<strong class="kh hj">ht1</strong>，输入为<strong class="kh hj"> xt </strong>。很明显，输出直接依赖于上一步的结果，这就是<strong class="kh hj">循环</strong>概念的来源。</p><h1 id="e541" class="jn jo hi bd jp jq jr js jt ju jv jw jx io jy ip jz ir ka is kb iu kc iv kd ke bi translated">神经网络..</h1><p id="a9f5" class="pw-post-body-paragraph kf kg hi kh b ki kj ij kk kl km im kn ko kp kq kr ks kt ku kv kw kx ky kz la hb bi translated">如果映射函数 f(。)是用神经网络近似的，那么我们称这种建模为递归神经网络</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es lh"><img src="../Images/1ad0de41f383ff043b76eb587c702703.png" data-original-src="https://miro.medium.com/v2/resize:fit:682/format:webp/1*3H6MAXNQGK1DC61Cm-tV5Q.png"/></div></figure><p id="1a16" class="pw-post-body-paragraph kf kg hi kh b ki lc ij kk kl ld im kn ko le kq kr ks lf ku kv kw lg ky kz la hb bi translated">其中<strong class="kh hj"> W 和 U </strong>是可学习的权重矩阵。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es li"><img src="../Images/20c6b60ccb139c6b753647d5bf58d0a0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oIW5EtcqdO2cJcaK--rpUA.png"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">递归神经网络图</figcaption></figure><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es lj"><img src="../Images/8b794c3ec3fb9d8021cc4c4215a277e5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UCIP0V5AaJQp7lHmc0OTkg.png"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">RNN 的训练过程</figcaption></figure><p id="4c57" class="pw-post-body-paragraph kf kg hi kh b ki lc ij kk kl ld im kn ko le kq kr ks lf ku kv kw lg ky kz la hb bi translated">RNN 的训练与前向网络非常相似，前向网络在本系列的<a class="ae lk" href="https://medium.com/p/98eb23e5c589/edit" rel="noopener">前一篇博客中介绍过。通常的步骤包括计算预测误差，通过反向传播计算每组权重的梯度，并根据梯度下降优化方法更新权重。尽管 RNN 的训练过程看起来非常类似于前馈网络，但是在梯度的计算过程中存在偏差。递归连接的权重矩阵 V。因此，计算梯度与标准多层感知器前馈网络完全相同。</a></p><h2 id="3857" class="ll jo hi bd jp lm ln lo jt lp lq lr jx ko ls lt jz ks lu lv kb kw lw lx kd ly bi translated">穿越时间的反向传播(BPTT)</h2><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es lz"><img src="../Images/27542e4e39da3452a65a7c260d066947.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XlvKiqkSxO4SbsCuElLcVQ.png"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">穿越时间的反向传播(BPTT)</figcaption></figure><p id="1f6c" class="pw-post-body-paragraph kf kg hi kh b ki lc ij kk kl ld im kn ko le kq kr ks lf ku kv kw lg ky kz la hb bi translated">在 RNN，所有早期时间步长的权重对网络的输出有贡献，因此所有时间步长的权重必须用梯度下降优化方法计算。通过评估对预测有贡献的每条路径来计算梯度。这个过程被称为时间反向传播(BPTT)。</p><p id="ff1e" class="pw-post-body-paragraph kf kg hi kh b ki lc ij kk kl ld im kn ko le kq kr ks lf ku kv kw lg ky kz la hb bi translated">在上图中，我们说明了如何针对在时间步长 t 计算的损失<strong class="kh hj"> (Et) </strong>更新权重。所有时间步长的误差是 Et 的总和，我们可以对网络(U、V 和 W)中每个权重的梯度求和，然后使用累积的梯度进行更新。</p><h2 id="6370" class="ll jo hi bd jp lm ln lo jt lp lq lr jx ko ls lt jz ks lu lv kb kw lw lx kd ly bi translated">消失渐变</h2><p id="af1b" class="pw-post-body-paragraph kf kg hi kh b ki kj ij kk kl km im kn ko kp kq kr ks kt ku kv kw kx ky kz la hb bi translated">在作为标准前馈网络的多层感知器中，当用反向传播训练多层神经网络时，消失问题出现。如果你仔细观察反向传播中的梯度，我们将梯度乘以每个连续层的输出。这意味着，如果它沿其路径拾取的偏导数项小于 1，则接近输入的层中存在的权重/偏差的梯度会越来越小。<br/>这种现象被称为消失梯度:梯度可以小到误差反向传播到层中的权重/偏差项在更新任何权重时都是无效的。这阻止了早期层的学习。神经网络越深入，问题就越大。</p><h2 id="760e" class="ll jo hi bd jp lm ln lo jt lp lq lr jx ko ls lt jz ks lu lv kb kw lw lx kd ly bi translated">RNN 的消失渐变</h2><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ma"><img src="../Images/0b53e803610f1e6f5320144f72776a13.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NisPlpgM10gGdlqda1hivg.png"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">RNN 的消失渐变</figcaption></figure><p id="b3b5" class="pw-post-body-paragraph kf kg hi kh b ki lc ij kk kl ld im kn ko le kq kr ks lf ku kv kw lg ky kz la hb bi translated">渐变消失的问题在 RNN 非常明显。由于递归方面，在通过时间的反向传播期间，梯度乘以每个时间步长上权重对误差的贡献。这种在每个时间步长上相乘的影响显著地减少了传播到前一个时间步长上的梯度，而前一个时间步长又会再次相乘。这导致了与上面讨论的相同的问题。当梯度很小时，权值更新可以忽略不计，网络不再学习。我们可以给 RNN 增加门来对抗消失梯度。</p><h2 id="16ec" class="ll jo hi bd jp lm ln lo jt lp lq lr jx ko ls lt jz ks lu lv kb kw lw lx kd ly bi translated">注意:</h2><p id="9d26" class="pw-post-body-paragraph kf kg hi kh b ki kj ij kk kl km im kn ko kp kq kr ks kt ku kv kw kx ky kz la hb bi translated"><strong class="kh hj">渐变裁剪:</strong>限制渐变爆炸的一个简单的<strong class="kh hj"> </strong>方法就是强制渐变到一个特定的范围。这防止了训练时的溢出错误。此外，梯度剪辑有助于改善收敛。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es mb"><img src="../Images/1f25b94e9e735d81faaa5391824dd85a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8Beuz1nMOAgZRT_x8Kslhw.png"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">由作者生成</figcaption></figure><p id="a360" class="pw-post-body-paragraph kf kg hi kh b ki lc ij kk kl ld im kn ko le kq kr ks lf ku kv kw lg ky kz la hb bi translated">接下来:<a class="ae lk" href="https://kowshikchilamkurthy.medium.com/nlp-zero-to-one-lstm-part-9-40-98e8cc4c296d?source=your_stories_page-------------------------------------" rel="noopener"> <strong class="kh hj"> NLP 零比一:LSTM 部分(9/40) </strong> </a></p><p id="03dc" class="pw-post-body-paragraph kf kg hi kh b ki lc ij kk kl ld im kn ko le kq kr ks lf ku kv kw lg ky kz la hb bi translated">上一篇:<a class="ae lk" href="https://kowshikchilamkurthy.medium.com/nlp-zero-to-one-training-embeddings-using-gensim-and-visualisation-part-7-30-f0540e976568?source=your_stories_page-------------------------------------" rel="noopener"> <strong class="kh hj"> NLP 零对一:使用 Gensim 和可视化训练嵌入(第 7/30 部分)</strong> </a></p></div></div>    
</body>
</html>