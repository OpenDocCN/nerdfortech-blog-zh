<html>
<head>
<title>Swift Leetcode Series: Count Primes</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Swift Leetcode 系列:计算素数</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/swift-leetcode-series-count-primes-f48b02e5351d?source=collection_archive---------21-----------------------#2021-05-11">https://medium.com/nerd-for-tech/swift-leetcode-series-count-primes-f48b02e5351d?source=collection_archive---------21-----------------------#2021-05-11</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="77d8" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">厄拉多塞的 Swift +筛子=🤔 🧠</h2></div><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ix"><img src="../Images/95c477f2b4e678fce2bb07b858741eeb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8xTbI3WD9kqgGip_hjLLSg.png"/></div></div></figure><div class="jj jk ez fb jl jm"><a href="https://theswiftnerd.com/count-primes-leetcode/" rel="noopener  ugc nofollow" target="_blank"><div class="jn ab dw"><div class="jo ab jp cl cj jq"><h2 class="bd hj fi z dy jr ea eb js ed ef hh bi translated">计算质数-</h2><div class="jt l"><h3 class="bd b fi z dy jr ea eb js ed ef dx translated">难度:链接:第二天:LeetCode Challenge 可以统计出小于一个非负数的素数个数，n…</h3></div><div class="ju l"><p class="bd b fp z dy jr ea eb js ed ef dx translated">theswiftnerd.com</p></div></div><div class="jv l"><div class="jw l jx jy jz jv ka jh jm"/></div></div></a></div><p id="fea2" class="pw-post-body-paragraph kb kc hi kd b ke kf ij kg kh ki im kj kk kl km kn ko kp kq kr ks kt ku kv kw hb bi translated">你可以查看 Swift Nerd 博客上的完整解释，以及上面链接上的其他酷帖。</p><h1 id="7ac1" class="kx ky hi bd kz la lb lc ld le lf lg lh io li ip lj ir lk is ll iu lm iv ln lo bi translated">问题描述</h1><p id="f592" class="pw-post-body-paragraph kb kc hi kd b ke lp ij kg kh lq im kj kk lr km kn ko ls kq kr ks lt ku kv kw hb bi translated">计算小于非负数的素数的个数，<code class="du lu lv lw lx b">n</code>。</p><h1 id="d02b" class="kx ky hi bd kz la lb lc ld le lf lg lh io li ip lj ir lk is ll iu lm iv ln lo bi translated">例子</h1><pre class="iy iz ja jb fd ly lx lz ma aw mb bi"><span id="2304" class="mc ky hi lx b fi md me l mf mg"><strong class="lx hj">Input:</strong> n = 10<br/><strong class="lx hj">Output:</strong> 4<br/><strong class="lx hj">Explanation:</strong> There are 4 prime numbers less than 10, they are 2, 3, 5, 7.</span><span id="b5e8" class="mc ky hi lx b fi mh me l mf mg"><strong class="lx hj">Input:</strong> n = 0<br/><strong class="lx hj">Output:</strong> 0</span><span id="dba7" class="mc ky hi lx b fi mh me l mf mg"><strong class="lx hj">Input:</strong> n = 1<br/><strong class="lx hj">Output:</strong> 0</span></pre><h1 id="e112" class="kx ky hi bd kz la lb lc ld le lf lg lh io li ip lj ir lk is ll iu lm iv ln lo bi translated">限制</h1><ul class=""><li id="2b1f" class="mi mj hi kd b ke lp kh lq kk mk ko ml ks mm kw mn mo mp mq bi translated"><code class="du lu lv lw lx b">0 &lt;= n &lt;= 5 * 106</code></li></ul><h1 id="43f7" class="kx ky hi bd kz la lb lc ld le lf lg lh io li ip lj ir lk is ll iu lm iv ln lo bi translated">解决办法</h1><p id="49cb" class="pw-post-body-paragraph kb kc hi kd b ke lp ij kg kh lq im kj kk lr km kn ko ls kq kr ks lt ku kv kw hb bi translated">这个问题是不言而喻的，解决起来很简单，但是优化起来有点棘手。质数是只能被 1 和它本身整除的数。你可以对 0 到 n 之间的整数进行布特力素性检查，更新计数。然而，复杂度将是 O(N2)的阶，并且因为 N 被给定为 106 的阶，所以 N2 将被 1012 限制，这将肯定导致<strong class="kd hj"> TLE </strong>(时限超过误差)。</p><h1 id="f0de" class="kx ky hi bd kz la lb lc ld le lf lg lh io li ip lj ir lk is ll iu lm iv ln lo bi translated">厄拉多塞筛</h1><p id="115d" class="pw-post-body-paragraph kb kc hi kd b ke lp ij kg kh lq im kj kk lr km kn ko ls kq kr ks lt ku kv kw hb bi translated">这是一个计算一定范围内的素数的古老算法，在竞争性编程中非常流行(阅读厄拉多塞的<a class="ae mr" href="https://en.wikipedia.org/wiki/Sieve_of_Eratosthenes" rel="noopener ugc nofollow" target="_blank">筛子)。在这个算法中，我们创建了一个可能的数字列表，从最小的可能数字开始，我们丢弃该数字范围内的所有倍数，依此类推。我们可以从最小的质数 2 开始，把它的所有倍数一直标到“n”都标为非质数。然后，我们对数组中未标记为复合的下一个可用数字重复相同的过程，依此类推。最后，我们可以列出所有没有标质数的数字，这就是我们的结果集。</a></p><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es ms"><img src="../Images/963fe6bb1b6bb5f84352ffd8ee9b8150.png" data-original-src="https://miro.medium.com/v2/resize:fit:890/0*Xw_5aIi78DMelMXR.gif"/></div></figure><p id="428f" class="pw-post-body-paragraph kb kc hi kd b ke kf ij kg kh ki im kj kk kl km kn ko kp kq kr ks kt ku kv kw hb bi translated">为了简化我们的逻辑，每当我们把一个指数作为非主要的，我们可以保持一个非主要市场数字的计数器，并增加它。最初 1 被标记为非素数。因为我们只检查到 n-1</p><pre class="iy iz ja jb fd ly lx lz ma aw mb bi"><span id="34d1" class="mc ky hi lx b fi md me l mf mg">num_primes = n - 1 - no_non_primes</span></pre><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="mt mu l"/></div></figure><h1 id="b9b5" class="kx ky hi bd kz la lb lc ld le lf lg lh io li ip lj ir lk is ll iu lm iv ln lo bi translated">复杂性分析</h1><p id="c76c" class="pw-post-body-paragraph kb kc hi kd b ke lp ij kg kh lq im kj kk lr km kn ko ls kq kr ks lt ku kv kw hb bi translated">时间复杂度由 loglogN 限定。然而，由于因式分解定理，外部循环运行<em class="mv"> √n </em>。因此总复杂度变成了<em class="mv"> O(√n </em> * Log(LogN))。我们只存储 N + 1 个元素来生成非素数，因此空间以 O(N)为界。</p><p id="7af6" class="pw-post-body-paragraph kb kc hi kd b ke kf ij kg kh ki im kj kk kl km kn ko kp kq kr ks kt ku kv kw hb bi translated"><strong class="kd hj">Time =<em class="mv">O(√n</em>* Log(LogN))</strong></p><p id="37bc" class="pw-post-body-paragraph kb kc hi kd b ke kf ij kg kh ki im kj kk kl km kn ko kp kq kr ks kt ku kv kw hb bi translated"><strong class="kd hj">空格= O(N) </strong></p><p id="9c5e" class="pw-post-body-paragraph kb kc hi kd b ke kf ij kg kh ki im kj kk kl km kn ko kp kq kr ks kt ku kv kw hb bi translated">复杂度的证明在这里给出<a class="ae mr" href="http://www.cs.umd.edu/~gasarch/BLOGPAPERS/sump.pdf" rel="noopener ugc nofollow" target="_blank">。你也可以在 leetcode 论坛上查看</a><a class="ae mr" href="https://leetcode.com/problems/count-primes/discuss/473021/Time-Complexity-O(log(log(n))-Explained" rel="noopener ugc nofollow" target="_blank">讨论</a>。</p></div><div class="ab cl mw mx gp my" role="separator"><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb"/></div><div class="hb hc hd he hf"><p id="fb12" class="pw-post-body-paragraph kb kc hi kd b ke kf ij kg kh ki im kj kk kl km kn ko kp kq kr ks kt ku kv kw hb bi translated">感谢您的阅读。如果你喜欢这篇文章，并发现它很有用，请分享并像野火一样传播它！</p><p id="4da0" class="pw-post-body-paragraph kb kc hi kd b ke kf ij kg kh ki im kj kk kl km kn ko kp kq kr ks kt ku kv kw hb bi translated">你可以在<a class="ae mr" href="https://theswiftnerd.com/" rel="noopener ugc nofollow" target="_blank">swift 网站</a>|<a class="ae mr" href="https://www.linkedin.com/in/varunrathi28/" rel="noopener ugc nofollow" target="_blank">LinkedIn</a>|<a class="ae mr" href="https://github.com/varunrathi28" rel="noopener ugc nofollow" target="_blank">Github</a>上找到我</p></div></div>    
</body>
</html>