<html>
<head>
<title>Understanding Async, Event loop, Task queue in JS</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">理解 JS 中的异步、事件循环、任务队列</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/understanding-async-event-loop-task-queue-in-js-86e956985dc2?source=collection_archive---------0-----------------------#2022-09-16">https://medium.com/nerd-for-tech/understanding-async-event-loop-task-queue-in-js-86e956985dc2?source=collection_archive---------0-----------------------#2022-09-16</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="394f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们知道 Javascript 是单线程和同步的。在此阅读更多关于此<a class="ae jd" href="https://www.pansofarjun.com/post/understanding-execution-context-hoisting-call-stack-closures-scope-block-in-javascript" rel="noopener ugc nofollow" target="_blank">的内容。</a></p><blockquote class="je jf jg"><p id="76e9" class="if ig jh ih b ii ij ik il im in io ip ji ir is it jj iv iw ix jk iz ja jb jc hb bi translated"><strong class="ih hj"> <em class="hi">单线程</em> </strong> <em class="hi"> =一次处理一行。</em></p><p id="c99e" class="if ig jh ih b ii ij ik il im in io ip ji ir is it jj iv iw ix jk iz ja jb jc hb bi translated"><strong class="ih hj"> <em class="hi">同步</em> </strong> <em class="hi"> =顺序=一个接一个。</em></p></blockquote><p id="8df6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">下面给罗生门对<strong class="ih hj">同步性的影响。</strong></p><ul class=""><li id="5d0b" class="jl jm hi ih b ii ij im in iq jn iu jo iy jp jc jq jr js jt bi translated">如果它一个接一个地处理，第二行等待第一行，第三行等待代码中的第二行，依此类推。</li><li id="2b8b" class="jl jm hi ih b ii ju im jv iq jw iu jx iy jy jc jq jr js jt bi translated">如果任何一行或块花费更多的时间，后面的行或块将不得不等到前者完成。</li><li id="3b50" class="jl jm hi ih b ii ju im jv iq jw iu jx iy jy jc jq jr js jt bi translated">但是我们可能在代码中有一些行的完成时间不受 javascript 执行的控制。</li><li id="cf4d" class="jl jm hi ih b ii ju im jv iq jw iu jx iy jy jc jq jr js jt bi translated">如果那些不受控的需要'<strong class="ih hj"> x </strong>秒才能完成，那么后面的行或块应该等待'<strong class="ih hj"> x </strong>秒。所以<strong class="ih hj">同步</strong>是</li></ul><blockquote class="je jf jg"><p id="b546" class="if ig jh ih b ii ij ik il im in io ip ji ir is it jj iv iw ix jk iz ja jb jc hb bi translated">我不知道完成这个过程需要多少时间。 <strong class="ih hj"> <em class="hi">请等待</em> </strong> <em class="hi">这个任意的时间对你执行死刑。</em></p></blockquote><ul class=""><li id="b7ae" class="jl jm hi ih b ii ij im in iq jn iu jo iy jp jc jq jr js jt bi translated">这是同步系统或执行的限制。我们无法承受特定块或代码不受控制的时间来执行其余的代码。</li><li id="bfac" class="jl jm hi ih b ii ju im jv iq jw iu jx iy jy jc jq jr js jt bi translated">这就是<strong class="ih hj">异步编程</strong>的进化点。</li></ul><p id="ed45" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">所以<strong class="ih hj">异步</strong>是</p><blockquote class="je jf jg"><p id="2de8" class="if ig jh ih b ii ij ik il im in io ip ji ir is it jj iv iw ix jk iz ja jb jc hb bi translated">我不知道完成这个过程需要多少时间。 <strong class="ih hj"> <em class="hi">不要为了我而暂停你的执行</em> </strong> <em class="hi">。</em></p></blockquote><p id="8c5e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">异步主要来自 API 调用和超时。我们稍后会看到这一点。</p><p id="2758" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">举个例子，</p><pre class="jz ka kb kc fd kd ke kf kg aw kh bi"><span id="4a0e" class="ki kj hi ke b fi kk kl l km kn">const a = 1; <br/>let b = 2;  </span><span id="bd2c" class="ki kj hi ke b fi ko kl l km kn">// After 3 seconds,it will  run <br/>setTimeout(() =&gt; {   <br/>console.log(a)   <br/>console.log(b)   <br/>},3000);    </span><span id="0ce4" class="ki kj hi ke b fi ko kl l km kn">console.log('Hello')    <br/>b = 3;</span></pre><p id="22f3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">当您运行上面的代码时，输出将是</p><pre class="jz ka kb kc fd kd ke kf kg aw kh bi"><span id="63e5" class="ki kj hi ke b fi kk kl l km kn">Hello <br/>// After 3 seconds, <br/>1 <br/>3</span></pre><p id="2eac" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">当 JS 识别 setTimeout 函数时，超时运行 3 秒。当超时结束时，它将其放入一个<strong class="ih hj">队列</strong>。谁运行超时？在大多数情况下，它将是运行它的一些内部机制(浏览器引擎或节点 js)。</p><p id="a338" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">还记得排队吗？</strong></p><p id="6eab" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">发生这种情况是因为 JS 不能等待 3 秒来执行其余的代码。所以异步操作因为这个<strong class="ih hj">队列</strong>而发生。</p><blockquote class="je jf jg"><p id="1be4" class="if ig jh ih b ii ij ik il im in io ip ji ir is it jj iv iw ix jk iz ja jb jc hb bi translated"><strong class="ih hj"> <em class="hi">栈</em> </strong> <em class="hi">用于同步执行。</em></p><p id="6cc9" class="if ig jh ih b ii ij ik il im in io ip ji ir is it jj iv iw ix jk iz ja jb jc hb bi translated"><strong class="ih hj"> <em class="hi">队列</em> </strong> <em class="hi">用于异步执行。</em></p></blockquote><p id="be53" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">因此，它将 setTimeout 放入队列中，并跳转到下面的代码。它打印<strong class="ih hj">‘你好’。</strong></p><p id="abcb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">然后'<strong class="ih hj"> b' </strong>被重新分配给<strong class="ih hj"> 3。</strong></p><p id="fe67" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">3 秒钟后，setTimeout 函数被推入<strong class="ih hj">队列。</strong>反正 setTimeout 里面有回调函数(匿名)。</p><p id="f024" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这个匿名回调函数被推入调用堆栈。为此函数和作用域创建了单独的执行上下文。</p><p id="c9f6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">当到达安慰<strong class="ih hj">‘a’</strong>时，打印<strong class="ih hj"> 1。</strong></p><p id="45b2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">当到达安慰【T6’b’时，打印<strong class="ih hj"> 3。等等！为什么不是 2？</strong></p><p id="d465" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这是因为<strong class="ih hj"> b </strong>的第一次重新分配发生，然后 setTimeout 发生，即使 setTimeout 在代码中的重新分配之前发生。感谢 JS 的异步性。</p><p id="e64d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">谁来协调堆栈和队列？等等！我们将这个队列命名为<strong class="ih hj">任务队列。</strong></p><p id="82b8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这个协调器被称为<strong class="ih hj">事件循环。</strong></p><p id="9c4e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">堆栈 vs 队列？</strong></p><figure class="jz ka kb kc fd kq er es paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="er es kp"><img src="../Images/2225ea5cc065f75d4d2025ce953a456b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QtGNetbTnQ279RMUv-84sg.png"/></div></div><figcaption class="kx ky et er es kz la bd b be z dx translated">堆栈与队列</figcaption></figure><p id="61ef" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">堆叠</strong> =垂直排列=便于移除<strong class="ih hj">顶部</strong>最多账面= <strong class="ih hj">最后</strong>增加账面=后进先出(LIFO)</p><p id="79ca" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">队列</strong> =水平排列=便于取出<strong class="ih hj">第一个</strong>书= <strong class="ih hj">第一个</strong>加书=先进先出(FIFO)</p><figure class="jz ka kb kc fd kq er es paragraph-image"><div class="er es lb"><img src="../Images/6317e77b0796548bbbbff75e482535e5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1306/format:webp/1*L3MblEjDp0jTSWu2F-bz3w.png"/></div><figcaption class="kx ky et er es kz la bd b be z dx translated">事件循环</figcaption></figure><p id="a555" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="jh">在执行调用堆栈中的程序时，假设某个任务被添加到任务队列中(例如超时结束)。这种情况下</em> <strong class="ih hj"> <em class="jh">事件循环</em> </strong> <em class="jh">做什么？</em></p><p id="dc8a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这个答案很重要！我们知道 JS 是<strong class="ih hj">同步</strong>，然后我们添加<strong class="ih hj">异步</strong>作为<strong class="ih hj">附加</strong>特性。</p><p id="bc40" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">由于同步与调用栈有关，只有当<strong class="ih hj">调用栈</strong>为空时，事件循环<strong class="ih hj">才会寻找<strong class="ih hj">任务队列。</strong></strong></p><p id="0d1c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">任务队列程序的运行方式和同步程序一样。两者的唯一区别是谁控制着程序完成的时间。</p><blockquote class="je jf jg"><p id="e8ef" class="if ig jh ih b ii ij ik il im in io ip ji ir is it jj iv iw ix jk iz ja jb jc hb bi translated"><strong class="ih hj"> <em class="hi">事件循环</em> </strong>只在<strong class="ih hj"> <em class="hi">调用栈</em> </strong>为空时寻找任务队列。</p></blockquote><p id="fafa" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果队列中有更多任务，将首先挑选哪些任务？先进先出。队列中最先到达的任务=任务中最早的任务。</p><p id="e222" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">嗯！异步没有那么简单。</p><p id="b0c2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">还记得 setTimeout 函数吧？在某种程度上，我们确定代码将在 3 秒后运行，但是时间不是由 javascript 管理的。因为我们作为开发者通过指定时间打破了同步性。</p><blockquote class="je jf jg"><p id="59e0" class="if ig jh ih b ii ij ik il im in io ip ji ir is it jj iv iw ix jk iz ja jb jc hb bi translated">任何打破同步的东西=异步。</p></blockquote><p id="f81b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们看另一个场景，</p><p id="9413" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们需要来自另一个应用程序的数据。所以我们向那个应用程序发送一个<strong class="ih hj"> <em class="jh"> API </em> </strong> <strong class="ih hj"> <em class="jh">请求</em> </strong>，最后由<strong class="ih hj"> <em class="jh"> API 响应</em> </strong>获取数据。</p><p id="4d6e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">基于我们获得的数据，我们使用这些数据进行一些操作，比如在屏幕上呈现表格。</p><p id="cc1c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们将在这里做一些调查。</p><p id="308c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> setTimeout </strong>和<strong class="ih hj"> API </strong>调用都会中断同步操作，因为这需要时间来完成，因此会中断执行的同步流程。因此<strong class="ih hj">异步</strong>！</p><p id="7e96" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在 setTimeout 的情况下，我们将执行的代码是预定义的和谨慎的，但是在 API 调用的情况下，代码取决于我们作为响应获得的<strong class="ih hj">数据</strong>。</p><p id="9512" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们确定 setTimeout 函数中的<strong class="ih hj">结果/输出</strong>，除非代码中出现一些错误。</p><p id="b8da" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">API 代码的预期结果/输出为<strong class="ih hj">不确定</strong>。如果我们想把它显示在表格中，我们事先不知道有多少行和列。这类场景在 JS 中被称为<strong class="ih hj">承诺</strong>。</p><p id="0e9d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">承诺超出了本文的范围，我们将有一个不同的专用帖子。</p><p id="357d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">根据经验，记住这一点。</p><blockquote class="je jf jg"><p id="9f5c" class="if ig jh ih b ii ij ik il im in io ip ji ir is it jj iv iw ix jk iz ja jb jc hb bi translated"><strong class="ih hj">承诺</strong> =代码依赖于响应数据，并且数据来自代码执行的另一个应用程序=结果/输出不确定。</p></blockquote><p id="70bf" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">所以有两种类型的异步任务——独立的和相关的。</p><p id="76b7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">它们需要分别对待。如果分开，哪一个需要优先？谁优先？再次事件循环！</p><p id="0897" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">哪一个故意打破同步性？它是 setTimeout，因为我们通过给定一个指定的时间来推迟执行。但是在 API 调用的情况下，时间不在我们手中。我们需要在收到回复后立即使用这些数据。所以我们没有刻意推迟行刑。</p><p id="576e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">自然要优先考虑 API 调用。</strong></p><p id="7e6f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们如何区分任务？</p><p id="30ea" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">需要有另一个队列，这个队列称为<strong class="ih hj">微任务队列</strong>。所以我们将已经建立的队列重命名为<strong class="ih hj">宏任务队列。</strong></p><figure class="jz ka kb kc fd kq er es paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="er es lc"><img src="../Images/6528b8aba3f68eac958f9879195ea6a3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*o3PV7ib6Sq9Ed-9skkTDsw.png"/></div></div></figure><p id="3f63" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">要记住的一点:</p><ul class=""><li id="01e6" class="jl jm hi ih b ii ij im in iq jn iu jo iy jp jc jq jr js jt bi translated">JS 利用任务队列进行异步操作。</li><li id="a991" class="jl jm hi ih b ii ju im jv iq jw iu jx iy jy jc jq jr js jt bi translated">有两种异步操作——依赖的(承诺)和独立的(Settimeout)。</li><li id="0a9e" class="jl jm hi ih b ii ju im jv iq jw iu jx iy jy jc jq jr js jt bi translated">因此有两个队列——微任务和宏任务队列。</li><li id="2806" class="jl jm hi ih b ii ju im jv iq jw iu jx iy jy jc jq jr js jt bi translated">相对于宏任务队列，微任务队列被给予优先权。微任务将基于承诺的调用(API 调用)排队。</li><li id="6a41" class="jl jm hi ih b ii ju im jv iq jw iu jx iy jy jc jq jr js jt bi translated">调用栈-微任务和宏任务队列的总协调器称为<strong class="ih hj">事件循环。</strong></li><li id="23a2" class="jl jm hi ih b ii ju im jv iq jw iu jx iy jy jc jq jr js jt bi translated"><strong class="ih hj"> <em class="jh">事件循环</em> </strong>只在<strong class="ih hj"> <em class="jh">调用栈</em> </strong>为空时寻找任何任务队列。</li></ul></div><div class="ab cl ld le gp lf" role="separator"><span class="lg bw bk lh li lj"/><span class="lg bw bk lh li lj"/><span class="lg bw bk lh li"/></div><div class="hb hc hd he hf"><p id="6f64" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="jh">原载于 2022 年 9 月 16 日 https://www.pansofarjun.com</em><em class="jh">的</em> <a class="ae jd" href="https://www.pansofarjun.com/post/understanding-async-event-loop-task-queue-in-js" rel="noopener ugc nofollow" target="_blank"> <em class="jh">。</em></a></p></div></div>    
</body>
</html>