<html>
<head>
<title>Non-Linear Models: High Order Feature Vectors and Kernel Functions.</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">非线性模型:高阶特征向量和核函数。</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/non-linear-models-high-order-feature-vectors-and-kernel-functions-6a8aa4e39e98?source=collection_archive---------16-----------------------#2021-03-02">https://medium.com/nerd-for-tech/non-linear-models-high-order-feature-vectors-and-kernel-functions-6a8aa4e39e98?source=collection_archive---------16-----------------------#2021-03-02</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="c52b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">对于本文，我假设您知道感知器算法的基础。</p><p id="da8e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">线性模型通常可以很好地实现数据建模的目的，但有时这还不够。更具体地说，我将用一个例子来介绍这个主题:</p><p id="3153" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">假设我们正在处理一个简单的特征向量，它位于实直线上。换句话说:</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es jd"><img src="../Images/fda95c94343fc2e36236e97287cb58f6.png" data-original-src="https://miro.medium.com/v2/resize:fit:266/format:webp/1*m1FumKxabcGBs3uxWHZJRA.png"/></div></figure><p id="3dfd" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为了简单起见，让我们考虑如下描述的 3 个数据点:</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es jl"><img src="../Images/0bfc22795abf407837ce60e1362e757e.png" data-original-src="https://miro.medium.com/v2/resize:fit:340/format:webp/1*-SL3Ke_edeq7agJUps2i2Q.png"/></div></figure><p id="325f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果你试图在这些特征向量中实现一个线性分类器，你会失败，因为没有线性分类器能把这个分开。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es jm"><img src="../Images/871fd757495e66d2002f57d69ec7d7d2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1142/format:webp/1*kFnqKhEAPyzhu9Sy9jjP-A.png"/></div></figure><p id="19f9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为了解决这个问题，高阶特征向量开始发挥作用。这个想法简单而优雅:如果我们建立一个函数，允许我们扩展高维空间和这个空间中的特征信息，我们使用我们已经知道的线性模型？</p><p id="444b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我这么说是什么意思？让我们更精确地说:</p><p id="7459" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">选一个我之前举过的例子，让我们定义一个函数，它可以在高维空间中转换这个特征向量:</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jo jp di jq bf jr"><div class="er es jn"><img src="../Images/99f98bb8a1005476b46a6ecfd0313066.png" data-original-src="https://miro.medium.com/v2/resize:fit:314/format:webp/1*X9raKf702H4_oHzAH5cgtw.png"/></div></div></figure><p id="3ba7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在，让我们看看能否在变换后的空间中分离这些特征向量:</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es js"><img src="../Images/e241605825a95375ad35c38e5e2dcb25.png" data-original-src="https://miro.medium.com/v2/resize:fit:1178/format:webp/1*UoMG88J4bZc5Kj_aM07bpg.png"/></div></figure><p id="f8fc" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在我们可以画出一组可能的决策边界(虚线)来分隔这些例子。我第一次看到它的时候，真是太棒了！</p><p id="db3e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这太棒了，但是如果我们的特征向量存在于一个更复杂的空间呢？我有好消息也有坏消息:好消息是同样的过程可以用于更复杂的特征向量，除此之外，我们可以使用其他非 x (t)的变换。坏消息是这个过程会导致我们进行非常长的计算。让我举个例子:假设</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es jt"><img src="../Images/75b8d0d59995b4a74f81a83064e4a921.png" data-original-src="https://miro.medium.com/v2/resize:fit:178/format:webp/1*6ZPfPPunctd6XPYjXQC2BQ.png"/></div></figure><p id="3165" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">到这样的程度</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es ju"><img src="../Images/bd6453c5afac17b3edd9faaf5658d816.png" data-original-src="https://miro.medium.com/v2/resize:fit:492/format:webp/1*CjTi4hln4pKhhKXlYNg8Nw.png"/></div></figure><p id="9882" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在，如果我们用一个 2 次多项式构造一个变换的特征向量，我们有:</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es jv"><img src="../Images/3cc1df0053f352199c5135ac3ff60884.png" data-original-src="https://miro.medium.com/v2/resize:fit:882/format:webp/1*8ufxgo0qQWt6EFJ6OQsl-Q.png"/></div></figure><p id="ebc2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">你可以看到，只使用一个 2 次多项式，我们得到了比以前更多的功能。在这种情况下，我们有 5150。更具体地说，当我们有“n”项并且我们得到“p”阶多项式时，我们的变换特征向量将具有的总项数可以计算如下:</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es jw"><img src="../Images/24df9128a37e074ebe334cb44ff678dc.png" data-original-src="https://miro.medium.com/v2/resize:fit:570/format:webp/1*PT6csuDYA4VPgfskd3TZ2Q.png"/></div></figure><p id="766d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为了便于练习，让我们将多项式的次数改为 3，看看项数会发生什么变化:</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es jx"><img src="../Images/15f16314a0abeb443a5f45554265e164.png" data-original-src="https://miro.medium.com/v2/resize:fit:1094/format:webp/1*GiPt69XB8PmTnj-ySLlEPg.png"/></div></figure><p id="5243" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">哇！它迅速扩展。看到这里，我就想:瓶颈来了。我们能做得更好吗？答案是肯定的！</p><p id="cb6e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">到目前为止，这篇文章激发了接下来的内容:内核函数。</p><p id="b625" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">什么是内核函数？</p><p id="c00f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">核函数是使用两个向量之间的点积将“n”维向量映射到“m”维向量的函数。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es jy"><img src="../Images/4a57f3cf52ffbcee673e26235d7fd854.png" data-original-src="https://miro.medium.com/v2/resize:fit:374/format:webp/1*fcq-OxOoFLorepUNp90eig.png"/></div></figure><p id="c5aa" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">核函数的精髓如下:我们选择一个性能良好的核函数(简单且易于计算点积),并且我们不明确定义我们使用什么特征变换，而是根据核来定义。</p><p id="6397" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">好吧…但是为什么有用呢？答案是:我们可以模拟一个无限次多项式(并将这种复杂程度添加到模型中)，而不需要计算我们在不使用核函数的情况下看到的所有项。什么？？？是的。你没听错。让我们看看最初的感知器是如何工作的，以及我们如何修改最初的算法来处理内核。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es jz"><img src="../Images/853770873bc7b03be4af7e7e446ce7a6.png" data-original-src="https://miro.medium.com/v2/resize:fit:842/format:webp/1*7uoKL7sl4dRlNWtg2NhZIg.png"/></div></figure><p id="db18" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为了修改这个算法，我们将使用</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es ka"><img src="../Images/8f52d4421e64da75cd10aeb8f0aae4b0.png" data-original-src="https://miro.medium.com/v2/resize:fit:300/format:webp/1*5XtFQsKO_Fi_3Y9DYmW9PQ.png"/></div></figure><p id="4aa3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">得到这个表格:</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es kb"><img src="../Images/87ffaf26bb5d902b33ac934749c3a4e2.png" data-original-src="https://miro.medium.com/v2/resize:fit:572/format:webp/1*OGiY2u9A2oW8EODyMjD__Q.png"/></div></figure><p id="69e6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">好的……如果我们考虑一下，我们会意识到最终的θ是这样的:</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es kc"><img src="../Images/a606c7f4d98f092cbf266e633b3ecf68.png" data-original-src="https://miro.medium.com/v2/resize:fit:282/format:webp/1*30eELIwA7BDLg__b5bSg6w.png"/></div></figure><p id="3320" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">其中α是“j”数据点所犯错误的数量。如果我们将两边乘以应用于 x_i 的特征变换，我们得到:</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es kd"><img src="../Images/b559ded0075e1237af8e16a63794a0b6.png" data-original-src="https://miro.medium.com/v2/resize:fit:450/format:webp/1*N5Iv46T3dUG2tywDkZG4WA.png"/></div></figure><p id="66be" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在魔法开始了:这个等式和…</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es ke"><img src="../Images/922228b69ec8eabf467bc411d23df1b1.png" data-original-src="https://miro.medium.com/v2/resize:fit:430/format:webp/1*Iyr8170KJFTbsPl-Yn2GNA.png"/></div></figure><p id="1cd3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">好的内核…现在你引起了我的注意！</p><p id="2ffa" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">所以…如果我们再次修改算法，使其适用于α而不是θ，我们会得到:</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es kf"><img src="../Images/1c7d50f83f386f1d32b6dcc94851a58e.png" data-original-src="https://miro.medium.com/v2/resize:fit:674/format:webp/1*M3hsNSc7LdNC8hZs5EYmZQ.png"/></div></figure><p id="0fe0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">请注意，alphas 的更新与 thetas 的更新是一样的。(试证明一下。)提示:展开这个等式。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es kg"><img src="../Images/aa07db6bddc168ec9d60b760644a2c06.png" data-original-src="https://miro.medium.com/v2/resize:fit:254/format:webp/1*dk7-c6p5HLWXV7jkjLornQ.png"/></div></figure><p id="c588" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">好了……现在我们有了一个基于 alphas 和核函数的算法，可以处理感知器算法，但是我们仍然需要选择一些方便的核函数来处理。让我们看一个展示内核威力的例子:</p><p id="76fe" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们把这个核定义为径向基核。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es kh"><img src="../Images/d5b71b10995ef1dee1b1573c258658ea.png" data-original-src="https://miro.medium.com/v2/resize:fit:474/format:webp/1*3Gnixa-_FqLIt6gpJiI8LA.png"/></div></figure><p id="75fe" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果你还记得傅立叶，你可能还记得指数函数可以用无穷次多项式来描述，通过调用这个核，我们隐式地向表中添加了一个任意强大的模型，最好的部分是:我们甚至没有定义我们使用什么变换函数，这一点都不重要，我们需要的只是这个行为良好的核。厉害！！</p><p id="23b8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">概括地说，使用这种方法，我们通过巧妙使用核函数，在变换空间上间接使用线性方法，解决了原始空间中的非线性问题(获得非线性决策边界)。</p><p id="54a7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">一些警告:</p><ol class=""><li id="7f29" class="ki kj hi ih b ii ij im in iq kk iu kl iy km jc kn ko kp kq bi translated">我们有一些规则来构造新的内核函数:</li></ol><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es kr"><img src="../Images/4d2cce1624db4e948136d2f7483554af.png" data-original-src="https://miro.medium.com/v2/resize:fit:760/format:webp/1*2BmczIlR8TYMx_YrA01ZBQ.png"/></div><figcaption class="ks kt et er es ku kv bd b be z dx translated">来源:麻省理工学院-机器学习课程</figcaption></figure><p id="06e8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">2.还有其他几个内核函数可以使用。</p><p id="12b8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">希望你和我一样喜欢这个主题=)</p></div></div>    
</body>
</html>