<html>
<head>
<title>LeetCode — Decode Ways</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">LeetCode —解码方式</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/leetcode-decode-ways-30f6d8c05e66?source=collection_archive---------0-----------------------#2021-11-04">https://medium.com/nerd-for-tech/leetcode-decode-ways-30f6d8c05e66?source=collection_archive---------0-----------------------#2021-11-04</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><h1 id="a34b" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">问题陈述</h1><p id="23d9" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">包含从<em class="kb"> A-Z </em>的字母的消息可以使用以下映射被<strong class="jf hj">编码</strong>成数字:</p><pre class="kc kd ke kf fd kg kh ki kj aw kk bi"><span id="5f8f" class="kl ig hi kh b fi km kn l ko kp">'A' -&gt; "1"<br/>'B' -&gt; "2"<br/>...<br/>'Z' -&gt; "26"</span></pre><p id="c92b" class="pw-post-body-paragraph jd je hi jf b jg kq ji jj jk kr jm jn jo ks jq jr js kt ju jv jw ku jy jz ka hb bi translated">为了<strong class="jf hj">解码</strong>一个编码的信息，所有的数字必须被分组，然后使用上面映射的逆过程映射回字母(可能有多种方法)。例如，<em class="kb">“11106”</em>可以映射成:</p><pre class="kc kd ke kf fd kg kh ki kj aw kk bi"><span id="8d7b" class="kl ig hi kh b fi km kn l ko kp">"AAJF" with the grouping (1 1 10 6)</span><span id="b93e" class="kl ig hi kh b fi kv kn l ko kp">"KJF" with the grouping (11 10 6)</span></pre><p id="96c2" class="pw-post-body-paragraph jd je hi jf b jg kq ji jj jk kr jm jn jo ks jq jr js kt ju jv jw ku jy jz ka hb bi translated">请注意，分组(1 11 06)无效，因为“6”不同于“06”，因此“06”不能映射到“F”。</p><p id="8b29" class="pw-post-body-paragraph jd je hi jf b jg kq ji jj jk kr jm jn jo ks jq jr js kt ju jv jw ku jy jz ka hb bi translated">给定一个只包含数字的字符串<em class="kb"> s </em>，<em class="kb">返回数字</em><strong class="jf hj"><em class="kb"/></strong><em class="kb">的方式为</em> <strong class="jf hj"> <em class="kb">解码</em> </strong> <em class="kb"> it </em>。</p><p id="96a8" class="pw-post-body-paragraph jd je hi jf b jg kq ji jj jk kr jm jn jo ks jq jr js kt ju jv jw ku jy jz ka hb bi translated">答案保证适合 32 位整数。</p><p id="f8ed" class="pw-post-body-paragraph jd je hi jf b jg kq ji jj jk kr jm jn jo ks jq jr js kt ju jv jw ku jy jz ka hb bi translated">问题陈述摘自:<a class="ae kw" href="https://leetcode.com/problems/decode-ways" rel="noopener ugc nofollow" target="_blank">https://leetcode.com/problems/decode-ways</a></p><p id="89ab" class="pw-post-body-paragraph jd je hi jf b jg kq ji jj jk kr jm jn jo ks jq jr js kt ju jv jw ku jy jz ka hb bi translated"><strong class="jf hj">例 1: </strong></p><pre class="kc kd ke kf fd kg kh ki kj aw kk bi"><span id="a3ca" class="kl ig hi kh b fi km kn l ko kp">Input: s = "12"<br/>Output: 2<br/>Explanation: "12" could be decoded as "AB" (1 2) or "L" (12).</span></pre><p id="b82e" class="pw-post-body-paragraph jd je hi jf b jg kq ji jj jk kr jm jn jo ks jq jr js kt ju jv jw ku jy jz ka hb bi translated"><strong class="jf hj">例 2: </strong></p><pre class="kc kd ke kf fd kg kh ki kj aw kk bi"><span id="a64f" class="kl ig hi kh b fi km kn l ko kp">Input: s = "226"<br/>Output: 3<br/>Explanation: "226" could be decoded as "BZ" (2 26), "VF" (22 6), or "BBF" (2 2 6).</span></pre><p id="b9b9" class="pw-post-body-paragraph jd je hi jf b jg kq ji jj jk kr jm jn jo ks jq jr js kt ju jv jw ku jy jz ka hb bi translated"><strong class="jf hj">例 3: </strong></p><pre class="kc kd ke kf fd kg kh ki kj aw kk bi"><span id="d94d" class="kl ig hi kh b fi km kn l ko kp">Input: s = "0"<br/>Output: 0<br/>Explanation: There is no character that is mapped to a number starting with 0.<br/>The only valid mappings with 0 are 'J' -&gt; "10" and 'T' -&gt; "20", neither of which start with 0.<br/>Hence, there are no valid ways to decode this since all digits need to be mapped.</span></pre><p id="8c5f" class="pw-post-body-paragraph jd je hi jf b jg kq ji jj jk kr jm jn jo ks jq jr js kt ju jv jw ku jy jz ka hb bi translated"><strong class="jf hj">例 4: </strong></p><pre class="kc kd ke kf fd kg kh ki kj aw kk bi"><span id="ff5c" class="kl ig hi kh b fi km kn l ko kp">Input: s = "06"<br/>Output: 0<br/>Explanation: "06" cannot be mapped to "F" because of the leading zero ("6" is different from "06").</span></pre><p id="0920" class="pw-post-body-paragraph jd je hi jf b jg kq ji jj jk kr jm jn jo ks jq jr js kt ju jv jw ku jy jz ka hb bi translated"><strong class="jf hj">约束:</strong></p><pre class="kc kd ke kf fd kg kh ki kj aw kk bi"><span id="1344" class="kl ig hi kh b fi km kn l ko kp">- 1 &lt;= s.length &lt;= 100<br/>- s contains only digits and may contain leading zero(s).</span></pre><h1 id="a931" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">说明</h1><h2 id="fcf9" class="kl ig hi bd ih kx ky kz il la lb lc ip jo ld le it js lf lg ix jw lh li jb lj bi translated">强力解决方案</h2><p id="b354" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">一种简单的方法是生成所有可能的组合，并计算正确序列的数量。</p><p id="80d6" class="pw-post-body-paragraph jd je hi jf b jg kq ji jj jk kr jm jn jo ks jq jr js kt ju jv jw ku jy jz ka hb bi translated">这种方法易于实现，但是具有<strong class="jf hj"> O(2^N) </strong>的时间复杂度。</p><h2 id="82ca" class="kl ig hi bd ih kx ky kz il la lb lc ip jo ld le it js lf lg ix jw lh li jb lj bi translated">动态规划</h2><p id="c52b" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">这个问题可以用动态规划方法来解决。</p><p id="84d1" class="pw-post-body-paragraph jd je hi jf b jg kq ji jj jk kr jm jn jo ks jq jr js kt ju jv jw ku jy jz ka hb bi translated">我们拿字符串<strong class="jf hj">“12”</strong>来说吧。我们可以用两种方式解码字符串<strong class="jf hj">【1，2】</strong>或<strong class="jf hj"> 12 </strong>。现在让我们在字符串的末尾追加<em class="kb"> 6 </em>。对于新的字符串，解码方式是 2 + 1 = 3。对于<strong class="jf hj">【1，2，3】</strong>或<strong class="jf hj">【12，3】</strong>为 2，对于<strong class="jf hj">【1，23】</strong>为 1。</p><p id="5a69" class="pw-post-body-paragraph jd je hi jf b jg kq ji jj jk kr jm jn jo ks jq jr js kt ju jv jw ku jy jz ka hb bi translated">我们先解决子问题，然后用它的解来解决更大的问题。那只不过是一种动态编程方法。</p><p id="4b33" class="pw-post-body-paragraph jd je hi jf b jg kq ji jj jk kr jm jn jo ks jq jr js kt ju jv jw ku jy jz ka hb bi translated">我们来检查一下算法。</p><pre class="kc kd ke kf fd kg kh ki kj aw kk bi"><span id="278a" class="kl ig hi kh b fi km kn l ko kp">- initialize count array: count[n + 1]<br/>- set count[0] = count[1] = 1</span><span id="d47b" class="kl ig hi kh b fi kv kn l ko kp">- if s[0] == 0 // first character of string is 0<br/>  - return 0</span><span id="559e" class="kl ig hi kh b fi kv kn l ko kp">- loop for i = 2; i &lt;= n; i++<br/>  - set count[i] = 0</span><span id="7e74" class="kl ig hi kh b fi kv kn l ko kp">  // if string is "02" we should not count "02" as a valid case.<br/>  // But if the previous char is greater than 0 we set the current index count same<br/>  // as the previous index count.<br/>  - if s[i - 1] &gt; '0'<br/>    - count[i] = count[i - 1]</span><span id="58d7" class="kl ig hi kh b fi kv kn l ko kp">  // if string is "32" it is not possible to map to any character.<br/>  // hence we have (i - 2)th index for 1 or 2 and<br/>  // if s[i - 2] is 2 we additionally check for (i - 1)th index to<br/>  // be less than 7.<br/>  - if s[i - 2] == '1' || (s[i - 2] == '2' &amp;&amp; s[i - 1] &lt; '7')<br/>    - count[i] += count[i - 2]</span><span id="2455" class="kl ig hi kh b fi kv kn l ko kp">- return count[n]</span></pre><h2 id="24b0" class="kl ig hi bd ih kx ky kz il la lb lc ip jo ld le it js lf lg ix jw lh li jb lj bi translated">C++解决方案</h2><pre class="kc kd ke kf fd kg kh ki kj aw kk bi"><span id="7895" class="kl ig hi kh b fi km kn l ko kp">class Solution {<br/>public:<br/>    int countWays(string s, int n){<br/>        int count[n + 1];<br/>        count[0] = 1;<br/>        count[1] = 1;</span><span id="0156" class="kl ig hi kh b fi kv kn l ko kp">        if(s[0] == '0')<br/>            return 0;</span><span id="7a09" class="kl ig hi kh b fi kv kn l ko kp">        for(int i = 2; i &lt;= n; i++){<br/>            count[i] = 0;</span><span id="439b" class="kl ig hi kh b fi kv kn l ko kp">            if(s[i - 1] &gt; '0')<br/>                count[i] = count[i - 1];</span><span id="bfbe" class="kl ig hi kh b fi kv kn l ko kp">            if(s[i - 2] == '1' || (s[i - 2] == '2' &amp;&amp; s[i - 1] &lt; '7')){<br/>                count[i] += count[i - 2];<br/>            }<br/>        }</span><span id="b29b" class="kl ig hi kh b fi kv kn l ko kp">        return count[n];<br/>    }</span><span id="a928" class="kl ig hi kh b fi kv kn l ko kp">public:<br/>    int numDecodings(string s) {<br/>        return countWays(s, s.size());<br/>    }<br/>};</span></pre><h2 id="9676" class="kl ig hi bd ih kx ky kz il la lb lc ip jo ld le it js lf lg ix jw lh li jb lj bi translated">戈朗溶液</h2><pre class="kc kd ke kf fd kg kh ki kj aw kk bi"><span id="c989" class="kl ig hi kh b fi km kn l ko kp">func numDecodings(s string) int {<br/>    count := make([]int, len(s) + 1)<br/>    count[0], count[1] = 1, 1</span><span id="2738" class="kl ig hi kh b fi kv kn l ko kp">    if s[0] == '0' {<br/>        return 0<br/>    }</span><span id="4946" class="kl ig hi kh b fi kv kn l ko kp">    for i := 2; i &lt;= len(s); i++ {<br/>        if s[i - 1] &gt; '0' {<br/>            count[i] = count[i - 1]<br/>        }</span><span id="67e7" class="kl ig hi kh b fi kv kn l ko kp">        if s[i - 2] == '1' || (s[i - 2] == '2' &amp;&amp; s[i - 1] &lt; '7') {<br/>            count[i] += count[i - 2]<br/>        }<br/>    }</span><span id="a41e" class="kl ig hi kh b fi kv kn l ko kp">    return count[len(s)]<br/>}</span></pre><h2 id="0f17" class="kl ig hi bd ih kx ky kz il la lb lc ip jo ld le it js lf lg ix jw lh li jb lj bi translated">Javascript 解决方案</h2><pre class="kc kd ke kf fd kg kh ki kj aw kk bi"><span id="7a39" class="kl ig hi kh b fi km kn l ko kp">var numDecodings = function(s) {<br/>    let count = [];<br/>    count[0] = 1;<br/>    count[1] = 1;</span><span id="1d80" class="kl ig hi kh b fi kv kn l ko kp">    for(let i = 2; i &lt;= s.length; i++){<br/>        count[i] = 0;</span><span id="09fd" class="kl ig hi kh b fi kv kn l ko kp">        if(s[i - 1] &gt; '0'){<br/>            count[i] = count[i - 1];<br/>        }</span><span id="e3d2" class="kl ig hi kh b fi kv kn l ko kp">        if(s[i - 2] == '1' || (s[i - 2]) == '2' &amp;&amp; s[i - 1] &lt; '7'){<br/>            count[i] += count[i - 2];<br/>        }<br/>    }</span><span id="d675" class="kl ig hi kh b fi kv kn l ko kp">    return count[s.length];<br/>};</span></pre><p id="a8df" class="pw-post-body-paragraph jd je hi jf b jg kq ji jj jk kr jm jn jo ks jq jr js kt ju jv jw ku jy jz ka hb bi translated">让我们试运行一下我们的算法，看看解决方案是如何工作的。</p><pre class="kc kd ke kf fd kg kh ki kj aw kk bi"><span id="1c84" class="kl ig hi kh b fi km kn l ko kp">Input: s = "226"<br/><br/>Step 1: int count[n + 1]<br/>        count[0] = count[1] = 1<br/><br/>Step 2: if s[0] == '0'<br/>        '2' == '0'<br/>        false<br/><br/>Step 3: loop for i = 2; i &lt;= n;<br/>        2 &lt;= 3<br/>        true<br/><br/>        if s[i - 1] &gt; '0'<br/>        s[2 - 1] &gt; '0'<br/>        s[1] &gt; '0'<br/>        '2' &gt; '0'<br/>        true<br/><br/>        count[i] = count[i - 1]<br/>        count[2] = count[2 - 1]<br/>                 = count[1]<br/>                 = 1<br/><br/>        if s[i - 2] == '1' || (s[i - 2] == '2' &amp;&amp; s[i - 1] &lt; '7'))<br/>        s[2 - 2] == '1'<br/>        s[0] == '1'<br/>        '2' == '1'<br/>        false<br/><br/>        s[i - 2] == '2' &amp;&amp; s[i - 1] &lt; '7'<br/>        s[2 - 2] == '2' &amp;&amp; s[2 - 1] &lt; '7'<br/>        s[0] == '2' &amp;&amp; s[1] &lt; '7'<br/>        '2' == '2' &amp;&amp; '2' &lt; '7'<br/>        true<br/><br/>        count[2] = count[i] + count[i - 2]<br/>                 = count[2] + count[2 - 2]<br/>                 = 1 + 1<br/>                 = 2<br/><br/>        i++<br/>        i = 3<br/><br/>Step 4: loop for i &lt;= n;<br/>        3 &lt;= 3<br/>        true<br/><br/>        if s[i - 1] &gt; '0'<br/>        s[3 - 1] &gt; '0'<br/>        s[2] &gt; '0'<br/>        '6' &gt; '0'<br/>        true<br/><br/>        count[i] = count[i - 1]<br/>        count[3] = count[3 - 1]<br/>                 = count[2]<br/>                 = 2<br/><br/>        if s[i - 2] == '1' || (s[i - 2] == '2' &amp;&amp; s[i - 1] &lt; '7'))<br/>        s[3 - 2] == '1'<br/>        s[1] == '1'<br/>        '2' == '1'<br/>        false<br/><br/>        s[i - 2] == '2' &amp;&amp; s[i - 1] &lt; '7'<br/>        s[3 - 2] == '2' &amp;&amp; s[3 - 1] &lt; '7'<br/>        s[1] == '2' &amp;&amp; s[2] &lt; '7'<br/>        '2' == '2' &amp;&amp; '6' &lt; '7'<br/>        true<br/><br/>        count[3] = count[i] + count[i - 2]<br/>                 = count[3] + count[3 - 2]<br/>                 = 2 + 1<br/>                 = 3<br/><br/>        i++<br/>        i = 4<br/><br/>Step 5: loop for i &lt;= n;<br/>        4 &lt;= 3<br/>        false<br/><br/>Step 6: return count[n]<br/>        count[3] = 3<br/><br/>So the answer we return is 3.</span></pre></div><div class="ab cl lk ll gp lm" role="separator"><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp"/></div><div class="hb hc hd he hf"><p id="dd6a" class="pw-post-body-paragraph jd je hi jf b jg kq ji jj jk kr jm jn jo ks jq jr js kt ju jv jw ku jy jz ka hb bi translated"><em class="kb">原发表于</em><a class="ae kw" href="https://alkeshghorpade.me/post/leetcode-decode-ways" rel="noopener ugc nofollow" target="_blank"><em class="kb">https://alkeshghorpade . me</em></a><em class="kb">。</em></p></div></div>    
</body>
</html>