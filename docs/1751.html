<html>
<head>
<title>Why ReferenceError In JS(Temporary Dead Zone And Hoisting)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">为什么在 JS 中引用错误(临时死区和吊装)</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/referenceerror-in-js-temporary-dead-zone-and-hoisting-3ea442715791?source=collection_archive---------14-----------------------#2021-04-04">https://medium.com/nerd-for-tech/referenceerror-in-js-temporary-dead-zone-and-hoisting-3ea442715791?source=collection_archive---------14-----------------------#2021-04-04</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/3bdd9df490e3c4350842aa2d2a10056d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qTKLJYZ25QysLVZOW9eGHQ.png"/></div></div></figure><h1 id="55ae" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated"><strong class="ak">你在这里会学到什么？</strong></h1><ul class=""><li id="42fb" class="jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf bi translated"><strong class="jq hj"> <em class="kg">让 vs var — </em> </strong>一般区别。</li><li id="e0d0" class="jo jp hi jq b jr kh jt ki jv kj jx kk jz kl kb kc kd ke kf bi translated"><strong class="jq hj"> <em class="kg">吊装</em> </strong></li><li id="d084" class="jo jp hi jq b jr kh jt ki jv kj jx kk jz kl kb kc kd ke kf bi translated"><strong class="jq hj"> <em class="kg">暂时死区</em> </strong></li></ul><p id="ce18" class="pw-post-body-paragraph km kn hi jq b jr ko kp kq jt kr ks kt jv ku kv kw jx kx ky kz jz la lb lc kb hb bi translated">要理解<em class="kg">提升</em>和<em class="kg">临时死区</em>首先我们应该知道 let 和 var 的范围差异。</p><h2 id="95cd" class="ld ir hi bd is le lf lg iw lh li lj ja jv lk ll je jx lm ln ji jz lo lp jm lq bi translated">let vs var</h2><ul class=""><li id="0374" class="jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf bi translated"><em class="kg"> var 和 let </em>都用于 javascript 中的变量声明，但它们之间的区别在于 var 是<em class="kg">函数作用域</em>而 let 是<em class="kg">块作用域</em>。</li></ul><pre class="lr ls lt lu fd lv lw lx ly aw lz bi"><span id="1525" class="ld ir hi lw b fi ma mb l mc md">function fun(){<br/> if(true){<br/> var foo = 5<br/> let bar = 5<br/> }<br/> console.log(foo)<br/> console.log(bar) //ReferenceError: bar is not defined , because bar varible isn't function scope, bar is only block scope variable<br/>}<br/>fun()</span></pre><p id="0f0b" class="pw-post-body-paragraph km kn hi jq b jr ko kp kq jt kr ks kt jv ku kv kw jx kx ky kz jz la lb lc kb hb bi translated">"在 JavaScript 中，我们可以在声明变量并提供适当的初始化(赋值)后使用变量."'</p><h1 id="497f" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">声明和初始化有什么区别？</h1><pre class="lr ls lt lu fd lv lw lx ly aw lz bi"><span id="58e5" class="ld ir hi lw b fi ma mb l mc md">{<br/>  let age; // declaring<br/>  age = 20; // <!-- -->initializing<br/>  let hands = 2; // declaring and <!-- -->initializing<br/>}</span></pre><p id="fd57" class="pw-post-body-paragraph km kn hi jq b jr ko kp kq jt kr ks kt jv ku kv kw jx kx ky kz jz la lb lc kb hb bi translated">如果我们在声明或赋值之前访问，会发生什么？</p><p id="e95f" class="pw-post-body-paragraph km kn hi jq b jr ko kp kq jt kr ks kt jv ku kv kw jx kx ky kz jz la lb lc kb hb bi translated">这里提升和临时死区(TDZ)进入画面。</p><p id="c6b3" class="pw-post-body-paragraph km kn hi jq b jr ko kp kq jt kr ks kt jv ku kv kw jx kx ky kz jz la lb lc kb hb bi translated"><strong class="jq hj"> JS 引擎</strong>即<em class="kg">解析和执行</em>你的代码有<strong class="jq hj"> 2 个步骤</strong>要做:</p><ol class=""><li id="27db" class="jo jp hi jq b jr ko jt kr jv me jx mf jz mg kb mh kd ke kf bi translated">将代码解析成<em class="kg">抽象语法树/可执行字节代码</em>，以及</li><li id="2827" class="jo jp hi jq b jr kh jt ki jv kj jx kk jz kl kb mh kd ke kf bi translated"><strong class="jq hj">运行时执行</strong>。</li></ol><ul class=""><li id="d7d4" class="jo jp hi jq b jr ko jt kr jv me jx mf jz mg kb kc kd ke kf bi translated"><strong class="jq hj">编译时</strong>:运行所有代码，寻找变量/函数声明</li><li id="c563" class="jo jp hi jq b jr kh jt ki jv kj jx kk jz kl kb kc kd ke kf bi translated"><strong class="jq hj">运行时</strong>:执行代码，包括赋值和函数调用</li></ul><p id="cfbc" class="pw-post-body-paragraph km kn hi jq b jr ko kp kq jt kr ks kt jv ku kv kw jx kx ky kz jz la lb lc kb hb bi translated">提升发生在步骤 1，这是由 JS 引擎完成的。因此，它实际上会将所有变量声明移动到它们作用域的顶部。</p><pre class="lr ls lt lu fd lv lw lx ly aw lz bi"><span id="8b66" class="ld ir hi lw b fi ma mb l mc md">var hoistedVariable;<br/>console.log(hoistedVariable); // undefined<br/>hoistedVariable = 1;</span></pre><h1 id="b137" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated"><strong class="ak">吊装</strong></h1><p id="2cf3" class="pw-post-body-paragraph km kn hi jq b jr js kp kq jt ju ks kt jv mi kv kw jx mj ky kz jz mk lb lc kb hb bi translated"><strong class="jq hj">提升</strong>是一个在 ECMAScript 2015 语言规范之前的任何规范性规范中都不会使用的术语。提升被认为是一种思考执行上下文(特别是创建和执行阶段)在 JavaScript 中如何工作的一般方式。然而，这个概念一开始可能会有点混乱。</p><pre class="lr ls lt lu fd lv lw lx ly aw lz bi"><span id="0394" class="ld ir hi lw b fi ma mb l mc md">{        <br/>        var age; // variable declaring<br/>        console.log(age); // Undefined<br/>	// Hoisting zone<br/>	var = 25;// value assigning<br/>	console.log(age); // 25 <br/>}</span></pre><p id="4095" class="pw-post-body-paragraph km kn hi jq b jr ko kp kq jt kr ks kt jv ku kv kw jx kx ky kz jz la lb lc kb hb bi translated">从概念上讲，<strong class="jq hj">提升</strong>的严格定义表明，在代码执行之前，变量和函数声明被移到代码或作用域的顶部，但事实上并不是这样。相反，在<em class="kg">编译</em>阶段，变量和函数声明被放入内存，但是停留在您在代码中键入它们的地方。</p><h1 id="02b8" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">暂时死区</h1><p id="1077" class="pw-post-body-paragraph km kn hi jq b jr js kp kq jt ju ks kt jv mi kv kw jx mj ky kz jz mk lb lc kb hb bi translated"><strong class="jq hj">临时死区</strong>是 JavaScript 中的一种行为，在用 let 和 const 关键字声明变量时会发生，而不是用 var。</p><p id="68a8" class="pw-post-body-paragraph km kn hi jq b jr ko kp kq jt kr ks kt jv ku kv kw jx kx ky kz jz la lb lc kb hb bi translated"><code class="du ml mm mn lw b">let</code>和<code class="du ml mm mn lw b">const</code> <strong class="jq hj"> </strong>变量从它们的封闭范围开始一直存在于 TDZ 中，直到它们被声明。</p><pre class="lr ls lt lu fd lv lw lx ly aw lz bi"><span id="0c06" class="ld ir hi lw b fi ma mb l mc md">{<br/>        console.log(age); // RefrenceError Due to TDZ<br/>	// This is the temporal dead zone for the age variable!<br/>	// This is the temporal dead zone for the age variable!<br/>	// This is the temporal dead zone for the age variable!<br/> 	// This is the temporal dead zone for the age variable!<br/>	let age = 25; // When, we got there! No more TDZ<br/>	console.log(age);<br/>}</span></pre><p id="4ccc" class="pw-post-body-paragraph km kn hi jq b jr ko kp kq jt kr ks kt jv ku kv kw jx kx ky kz jz la lb lc kb hb bi translated">你也可以说变量存在于<strong class="jq hj"> TDZ </strong>中，从它们被绑定的地方(当变量被绑定到它所在的作用域时)直到它被声明(当一个名字在内存中为那个变量保留时)。</p><p id="4b43" class="pw-post-body-paragraph km kn hi jq b jr ko kp kq jt kr ks kt jv ku kv kw jx kx ky kz jz la lb lc kb hb bi translated">如果我们在 TDZ 地区加入年龄变量会怎么样？</p><figure class="lr ls lt lu fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mo"><img src="../Images/642572cc1e6b082a430839303102fbd9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BhaTG9IDGwWPneeuGPWFLw.png"/></div></div></figure><p id="5191" class="pw-post-body-paragraph km kn hi jq b jr ko kp kq jt kr ks kt jv ku kv kw jx kx ky kz jz la lb lc kb hb bi translated">带功能的 TDZ</p><pre class="lr ls lt lu fd lv lw lx ly aw lz bi"><span id="30a7" class="ld ir hi lw b fi ma mb l mc md">let a = f(); // <!-- -->ReferenceError 'Cannot access 'b' before initialization'<br/>const b = 2;<br/>function f() { return b; } // 2, b is in the TDZ<br/>const a = f();<br/>console.log(a) // 2</span></pre><h1 id="dfe2" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">要点</h1><ul class=""><li id="a1c4" class="jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf bi translated">结果是一样的。请记住，当使用<code class="du ml mm mn lw b">let/const/var</code>时，你应该<em class="kg">总是将变量声明移动到你的作用域</em>的顶部，以避免<strong class="jq hj">时间死区和提升</strong>。</li><li id="9f8b" class="jo jp hi jq b jr kh jt ki jv kj jx kk jz kl kb kc kd ke kf bi translated">如果你需要阻塞的作用域，就去找<code class="du ml mm mn lw b">let/const</code>，否则就去找 var，var 是函数作用域。</li><li id="583a" class="jo jp hi jq b jr kh jt ki jv kj jx kk jz kl kb kc kd ke kf bi translated">总是尝试使用<em class="kg"> let/const </em>，因为如果代码中存在与变量相关的 bug，那么调试将变得更加容易。</li></ul><p id="ea2e" class="pw-post-body-paragraph km kn hi jq b jr ko kp kq jt kr ks kt jv ku kv kw jx kx ky kz jz la lb lc kb hb bi translated">我希望你在这里学到了新东西。</p><p id="ab2e" class="pw-post-body-paragraph km kn hi jq b jr ko kp kq jt kr ks kt jv ku kv kw jx kx ky kz jz la lb lc kb hb bi translated">谢谢你的 time☺️</p></div><div class="ab cl mp mq gp mr" role="separator"><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu"/></div><div class="hb hc hd he hf"><p id="c90c" class="pw-post-body-paragraph km kn hi jq b jr ko kp kq jt kr ks kt jv ku kv kw jx kx ky kz jz la lb lc kb hb bi translated">其他与 Javascript 相关的东西</p><h2 id="7c8a" class="ld ir hi bd is le lf lg iw lh li lj ja jv lk ll je jx lm ln ji jz lo lp jm lq bi translated"><a class="ae mw" href="https://ritik-chopra28.medium.com/understand-scopes-and-scope-chain-in-javascript-12ee91161abb?source=your_stories_page-------------------------------------" rel="noopener">理解 JavaScript 中的作用域和作用域链</a></h2><h2 id="9e36" class="ld ir hi bd is le lf lg iw lh li lj ja jv lk ll je jx lm ln ji jz lo lp jm lq bi translated"><a class="ae mw" href="https://ritik-chopra28.medium.com/the-call-stack-in-javascript-291edfaa74e9?source=your_stories_page-------------------------------------" rel="noopener">JavaScript 中的调用栈</a></h2></div></div>    
</body>
</html>