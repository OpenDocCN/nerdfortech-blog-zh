<html>
<head>
<title>Programming with Functions #3 — Pattern Matching</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">函数编程#3 —模式匹配</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/programming-with-functions-3-pattern-matching-64d3fba6929f?source=collection_archive---------4-----------------------#2021-01-26">https://medium.com/nerd-for-tech/programming-with-functions-3-pattern-matching-64d3fba6929f?source=collection_archive---------4-----------------------#2021-01-26</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex if ig ih ii"><div class="bz dy l di"><div class="ij ik l"/></div></figure><p id="c3d2" class="pw-post-body-paragraph il im hi in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji hb bi translated">模式匹配是Scala最重要的特性之一。它如此重要，以至于我可以冒险说它不是Scala的“a”特性，而是特性。它影响了编程语言的每一个部分，以至于在讨论Scala时，很难不在代码示例中提及或使用它。您已经看到了——match/case语句、部分函数和case类实例的析构。正是因为这个原因，我在这里要讲的很多东西你们都已经知道了，所以请不要介意。我想谈谈它们，以确保在我专注于我觉得最有趣的细节之前，我不会错过任何东西。</p><figure class="jk jl jm jn fd ii er es paragraph-image"><div role="button" tabindex="0" class="jo jp di jq bf jr"><div class="er es jj"><img src="../Images/257f9c26aee3e78631b46cb06d743262.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*DBvY5Trd93RdciG3"/></div></div></figure><h2 id="ad10" class="ju jv hi bd jw jx jy jz ka kb kc kd ke iw kf kg kh ja ki kj kk je kl km kn ko bi translated">案例类别</h2><p id="10f3" class="pw-post-body-paragraph il im hi in b io kp iq ir is kq iu iv iw kr iy iz ja ks jc jd je kt jg jh ji hb bi translated">早期C++中的一个关键概念是用更强大的类来代替简单、粗糙的C结构。一个结构就是一个数据结构。一个在其上扩展了方法、虚拟性、从其他类继承和实现接口的能力等等的类。我们很快就有了UI小部件、管理器、构建器、工厂和许多其他类型的对象的深层结构，这些对象不再是真正的数据，而是应用程序的半自治部分。我们开始开发面向对象的设计模式，并讨论<a class="ae ku" href="https://en.wikipedia.org/wiki/Circle%E2%80%93ellipse_problem" rel="noopener ugc nofollow" target="_blank">正方形是矩形</a>的子类还是相反。在所有这一切中，有一段时间我们忘记了有时数据只是数据。但是程序是用来处理数据的。没有它，所有那些花哨的经理和工人、工厂和门面就没有存在的理由。</p><p id="5b25" class="pw-post-body-paragraph il im hi in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji hb bi translated">通过在Scala中将一个类标记为case类，我们声明它被设计为一个数据结构。Scala编译器会对它进行一些限制，但是它也会自动增加一些特性，否则我们就必须自己编码。默认情况下，case类的所有字段都是不可变的和公共的。我们可以使用copy方法，将新值作为某些或所有字段的参数，而不是更改其中的某些内容——这将创建一个新实体，其中给定字段和所有其他字段的新值都是从原始实体中复制的。case类不能是另一个类的超类，但是它可以从其他类和特征继承。(我做完视频之后才知道，其实是可以扩展一个案例类的。但是a)我找到的所有资料都说这是一种不好的做法，b)在这么做的时候，你会经常遇到错误，这暗示着Scala的创造者并没有真正考虑到它是这门语言的一个特性。你可以在这个主题上找到一点moe<a class="ae ku" href="https://www.quora.com/Why-was-case-to-case-inheritance-removed-from-Scala" rel="noopener ugc nofollow" target="_blank">这里</a>。case类有一个等式操作符，用于检查底层字段的相等性，最重要的是，case类有默认的apply和unapply方法，这意味着它可以用于模式匹配。</p><h2 id="63d0" class="ju jv hi bd jw jx jy jz ka kb kc kd ke iw kf kg kh ja ki kj kk je kl km kn ko bi translated"><code class="du kv kw kx ky b">apply</code>方法和智能构造函数</h2><p id="6225" class="pw-post-body-paragraph il im hi in b io kp iq ir is kq iu iv iw kr iy iz ja ks jc jd je kt jg jh ji hb bi translated">apply唯一真正的超能力是，它可以不使用实际名称就被调用。不用写<code class="du kv kw kx ky b">X.apply(...)</code>，你可以写<code class="du kv kw kx ky b">X(...)</code>，编译器会知道你想调用apply，但是懒得写下来。除此之外，您可以根据需要定义应用...</p><p id="68d5" class="pw-post-body-paragraph il im hi in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji hb bi translated">…但是请不要。</p><figure class="jk jl jm jn fd ii er es paragraph-image"><div role="button" tabindex="0" class="jo jp di jq bf jr"><div class="er es jj"><img src="../Images/eaca02a9dd8ef1ca524042480f548830.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*2T-sGXkfpr7j1Tz6"/></div></div></figure><p id="4b19" class="pw-post-body-paragraph il im hi in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji hb bi translated">我相信保持事情简单是有价值的，所以我要告诉你:使用<code class="du kv kw kx ky b">apply</code>方法作为构造函数，并且只作为构造函数。不要在类中使用重载的构造函数，使用<code class="du kv kw kx ky b">apply</code>。是的，您可以出于任何目的使用这个名称定义一个方法，并将其放在类或伴随对象中，但是如果您关心代码的可读性，请只将它放在伴随对象中，而不要放在类中，并且只将其用作构造函数。还有一些其他方式可以使用apply，例如，collections库经常使用它从一个集合中检索数据，这个集合表面上看起来好像Scala将更多传统语言的方括号换成了圆括号:</p><pre class="jk jl jm jn fd kz ky la lb aw lc bi"><span id="fe85" class="ju jv hi ky b fi ld le l lf lg">val entry1 = listOfEntries(5) // listOfEntries: List[Entry]<br/>val entry2 = listOfEntries.apply(5) // this is the same as above</span></pre><p id="4a7c" class="pw-post-body-paragraph il im hi in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji hb bi translated">这种用法非常受欢迎，以至于人们看到它时就能理解它，但是如果你试图用它来做一些非常不同的事情，你只会让其他程序员感到困惑。还有你自己，几个月后。</p><p id="70dc" class="pw-post-body-paragraph il im hi in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji hb bi translated">但是，即使您坚持使用<code class="du kv kw kx ky b">apply</code>作为构造函数，您仍然可以利用它可以接受任何参数并返回任何类型的结果这一事实——您可以创建一个智能构造函数。它仍然是一个构造函数，但是它可以做更多的事情:根据参数，它可以返回一个实现trait的子类或类(也可以为trait定义<code class="du kv kw kx ky b">apply</code>方法)，外界只知道它是超类的一个实体。隐藏了底层逻辑。</p><pre class="jk jl jm jn fd kz ky la lb aw lc bi"><span id="aee7" class="ju jv hi ky b fi ld le l lf lg">sealed trait CatColour<br/>sealed trait PrimaryCatColour extends CatColour<br/>object CatColour {<br/>  case object Black  extends PrimaryCatColour<br/>  case object White  extends PrimaryCatColour<br/>  case object Grey   extends PrimaryCatColour<br/>  case object Ginger extends PrimaryCatColour<br/>  case object Tabby  extends CatColour<br/>  case object Calico extends CatColour</span><span id="f28b" class="ju jv hi ky b fi lh le l lf lg">  case class Mixed(first:  PrimaryCatColour, <br/>                   second: PrimaryCatColour) extends CatColour <br/>}</span></pre><p id="6942" class="pw-post-body-paragraph il im hi in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji hb bi translated">然后创建一个case类，它将其中一个作为参数:</p><pre class="jk jl jm jn fd kz ky la lb aw lc bi"><span id="e9b0" class="ju jv hi ky b fi ld le l lf lg">case class Cat(colour: CatColour)</span><span id="f4bb" class="ju jv hi ky b fi lh le l lf lg">import CatColour._</span><span id="cd90" class="ju jv hi ky b fi lh le l lf lg">val blackCat = Cat(Black)<br/>val tabbyCat = Cat(Tabby)<br/>val cowCat   = Cat(Mixed(White, Black))</span></pre><p id="18e0" class="pw-post-body-paragraph il im hi in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji hb bi translated">到目前为止一切顺利。但是有一天，你的经理有了一个绝妙的主意:让我们介绍<code class="du kv kw kx ky b">CheshireCat</code>，它是隐形的(所以没有颜色)并且有超能力。显然，需要对设计进行一些修改。智能构造函数在这里很有用:</p><pre class="jk jl jm jn fd kz ky la lb aw lc bi"><span id="e1af" class="ju jv hi ky b fi ld le l lf lg">sealed trait Cat<br/>case class RealCat(colour: CatColour) extends Cat<br/>case object CheshireCat extends Cat</span><span id="38d2" class="ju jv hi ky b fi lh le l lf lg">object Cat {<br/>  def apply(colour: CatColour): Cat = RealCat(colour)<br/>  def apply(): Cat = CheshireCat<br/>}</span><span id="8ce0" class="ju jv hi ky b fi lh le l lf lg">val blackCat    = Cat(Black)<br/>val tabbyCat    = Cat(Tabby)<br/>val cowCat      = Cat(Mixed(White, Black))<br/>val cheshireCat = Cat()</span></pre><p id="de92" class="pw-post-body-paragraph il im hi in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji hb bi translated">从代码用户的角度来看，几乎没有什么变化。这就好像<code class="du kv kw kx ky b">Cat</code>仍然是一个案例类。唯一的区别是，现在，不知何故，你可以调用<code class="du kv kw kx ky b">Cat.apply</code>方法，而没有参数，它将产生<code class="du kv kw kx ky b">CheshireCat</code>——出于所有实际原因，它仍然可以被视为一只普通的猫，除非我们真的需要看下面。</p><p id="a115" class="pw-post-body-paragraph il im hi in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji hb bi translated">顺便说一下，如果您对Haskell中如何使用智能构造函数感兴趣，请看看Mark Karpov的这篇文章:[ <a class="ae ku" href="https://markkarpov.com/post/smart-constructors-that-cannot-fail.html" rel="noopener ugc nofollow" target="_blank"> link </a> ]</p><h2 id="d5d1" class="ju jv hi bd jw jx jy jz ka kb kc kd ke iw kf kg kh ja ki kj kk je kl km kn ko bi translated">作为枚举的密封特征</h2><p id="903c" class="pw-post-body-paragraph il im hi in b io kp iq ir is kq iu iv iw kr iy iz ja ks jc jd je kt jg jh ji hb bi translated">好吧。封闭的特征。这个问题我们已经谈了一点，现在让我们再谈一点。Scala 2没有枚举(它们将在Scala 3中添加)，但密封特征可以用于基本相同的目的，甚至更多。sealed关键字意味着实现所讨论的sealed特征的所有类和对象都必须在同一个文件中定义。这反过来允许编译器检查密封特征实例的匹配/大小写是否覆盖了所有可能性。</p><p id="0d33" class="pw-post-body-paragraph il im hi in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji hb bi translated">让我们扩展一下上一段的例子:</p><pre class="jk jl jm jn fd kz ky la lb aw lc bi"><span id="dcbd" class="ju jv hi ky b fi ld le l lf lg">val cat: Cat = ...</span><span id="d283" class="ju jv hi ky b fi lh le l lf lg">cat match {<br/>  case CheshireCat =&gt; println("We're all mad here")<br/>}</span></pre><p id="85fc" class="pw-post-body-paragraph il im hi in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji hb bi translated">如果猫是柴郡猫，它会工作并显示“<code class="du kv kw kx ky b">We’re all mad here</code>”，这是它应该做的，但是在编译过程中你会看到一个警告:<code class="du kv kw kx ky b">match may not be exhaustive. It would fail on the following input: RealCat(_)</code>。它不仅告诉你你错过了一些亚型，甚至试图给你一个你错过了什么的提示——<code class="du kv kw kx ky b">RealCat</code>是封闭性状<code class="du kv kw kx ky b">Cat</code>的另一个可能的亚型。您可能真的想编写一个不包含所有可能的子类型的匹配/案例，但这是极不可能的。更有可能的是，这是一个错误，使用密封的特征是防止它发生的一种方式。只需添加一行</p><pre class="jk jl jm jn fd kz ky la lb aw lc bi"><span id="fcf6" class="ju jv hi ky b fi ld le l lf lg">case RealCat(_) =&gt; println(“meow”)<br/>// or case _: RealCat =&gt; …<br/>// or just case _ =&gt; …</span></pre><p id="5afc" class="pw-post-body-paragraph il im hi in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji hb bi translated">它会达到目的。</p><p id="06ab" class="pw-post-body-paragraph il im hi in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji hb bi translated">科特林中密封特征的对应物是密封类。它的工作原理几乎完全相同，只是语法有点不同。您可以在<a class="ae ku" href="https://kotlinlang.org/docs/reference/sealed-classes.html" rel="noopener ugc nofollow" target="_blank">官方文件</a>中了解更多。此外,<a class="ae ku" href="https://kotlinlang.org/docs/reference/enum-classes.html" rel="noopener ugc nofollow" target="_blank"> Kotlin有适当的枚举</a>,如果您不需要您的枚举做任何非标准的事情(在这种情况下，密封类会处理它),这使得语法更加简洁。</p><figure class="jk jl jm jn fd ii er es paragraph-image"><div role="button" tabindex="0" class="jo jp di jq bf jr"><div class="er es jj"><img src="../Images/26dffd2aa8058ae6d6ac1301d2b93f6f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*GMgJaY6ivlrrAuYI"/></div></div></figure><p id="4dc2" class="pw-post-body-paragraph il im hi in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji hb bi translated">在下一个视频中，我们将继续所谓的<code class="du kv kw kx ky b">unapply</code>方法，与<code class="du kv kw kx ky b">apply</code>相反，以及新型模式。谢谢你阅读这一切。如果您有任何问题或想出于其他原因与我联系，您可以在下面留言。或者你也可以在推特上找到我。</p><h1 id="1942" class="li jv hi bd jw lj lk ll ka lm ln lo ke lp lq lr kh ls lt lu kk lv lw lx kn ly bi translated">更多阅读材料</h1><p id="385d" class="pw-post-body-paragraph il im hi in b io kp iq ir is kq iu iv iw kr iy iz ja ks jc jd je kt jg jh ji hb bi translated">*<a class="ae ku" href="https://markkarpov.com/post/smart-constructors-that-cannot-fail.html" rel="noopener ugc nofollow" target="_blank">Haskell中的智能构造函数由Mark Karpov <br/> * </a><a class="ae ku" href="https://alvinalexander.com/scala/how-to-use-pattern-matching-scala-match-case-expressions/" rel="noopener ugc nofollow" target="_blank">编写更多关于模式匹配的信息由Elvin Alexander<br/>*</a><a class="ae ku" href="https://underscore.io/blog/posts/2015/06/02/everything-about-sealed.html" rel="noopener ugc nofollow" target="_blank">编写关于密封特性</a>的详细信息由Noel Welsh编写</p><p id="26f3" class="pw-post-body-paragraph il im hi in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji hb bi translated">先前:<a class="ae ku" href="https://makingthematrix.medium.com/programming-with-functions-2-functions-as-data-efe2dd227a9f?source=friends_link&amp;sk=d0b2d1d4e6954a9c7ae105c228d0ef84" rel="noopener">用函数#2编程-函数为数据</a></p><p id="ddfc" class="pw-post-body-paragraph il im hi in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji hb bi translated">接下来:<a class="ae ku" href="https://makingthematrix.medium.com/programming-with-functions-4-unapply-and-the-newtype-pattern-7584cceb3e9?source=friends_link&amp;sk=76a17a4f1ba7b7e895c0de0027286eef" rel="noopener">用函数#4 — </a> <code class="du kv kw kx ky b"><a class="ae ku" href="https://makingthematrix.medium.com/programming-with-functions-4-unapply-and-the-newtype-pattern-7584cceb3e9?source=friends_link&amp;sk=76a17a4f1ba7b7e895c0de0027286eef" rel="noopener">unapply</a></code> <a class="ae ku" href="https://makingthematrix.medium.com/programming-with-functions-4-unapply-and-the-newtype-pattern-7584cceb3e9?source=friends_link&amp;sk=76a17a4f1ba7b7e895c0de0027286eef" rel="noopener">和新类型模式</a>编程</p></div></div>    
</body>
</html>