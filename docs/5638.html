<html>
<head>
<title>The Single Responsibility Principle</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">单一责任原则</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/the-single-responsibility-principle-6f74574ccede?source=collection_archive---------3-----------------------#2021-10-26">https://medium.com/nerd-for-tech/the-single-responsibility-principle-6f74574ccede?source=collection_archive---------3-----------------------#2021-10-26</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="a25c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这是<strong class="ih hj">坚实</strong>原则的 5 条规则中的第一条。</p><p id="258c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">单一责任又名<strong class="ih hj"> SRP </strong>规定每个软件组件应该有且只有一个责任。这个组件可以是一个类，一个方法，甚至是一个模块。</p><p id="2d80" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">与其有一把<strong class="ih hj">解决一切的瑞士军刀</strong>，不如有一堆可以适合单一责任的单刀，只待切割。</p><p id="2ff6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">SRP 的目标是以一种有效的方式击败凝聚力。在一个更正式的定义中，内聚性是软件组件的各个部分相关的程度。</p><p id="e3a6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">一个很好的类比是，当一个地方有一堆垃圾时，这些垃圾按照垃圾的类型进行隔离和分类。这种分离过程可能产生高内聚力，也可能产生相反的结果。</p><p id="0ded" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这里有一个应用程序中可能的实际解决方案的快速示例。</p><pre class="jd je jf jg fd jh ji jj jk aw jl bi"><span id="82d6" class="jm jn hi ji b fi jo jp l jq jr">public class Square {</span><span id="535f" class="jm jn hi ji b fi js jp l jq jr">  int side = 5;</span><span id="a96f" class="jm jn hi ji b fi js jp l jq jr">  public int calculateArea() {<br/>    return side * side;<br/>  }</span><span id="d8ef" class="jm jn hi ji b fi js jp l jq jr">  public int calculatePerimeter() {<br/>    return side * 4;<br/>  }</span><span id="431a" class="jm jn hi ji b fi js jp l jq jr">  public void draw() {<br/>   if (highResolutionMonitor) {<br/>    // render high resolution image<br/>   } else {<br/>    // render normal image<br/>   }<br/>  }</span><span id="2289" class="jm jn hi ji b fi js jp l jq jr"> public void rotate(int degree) {<br/>  // rotate the image with the selected degree<br/> }<br/>}</span></pre><p id="4aac" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这段代码提供了 4 个方法，但是<code class="du jt ju jv ji b">calculateArea</code>和<code class="du jt ju jv ji b">calculatePermiter</code>是具有真正紧密内聚级别的方法，而<code class="du jt ju jv ji b">draw</code>和<code class="du jt ju jv ji b">rotate</code>方法没有那么紧密。</p><p id="8801" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果你还记得的话，我们的目标是获得好的内聚性，我们应该总是以在一个组件中编写高内聚性为目标。</p><p id="ff9f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><code class="du jt ju jv ji b">draw</code>和<code class="du jt ju jv ji b">rotate</code>方法都可以放在别处，并“委托”呈现功能的责任。所以，请假设这两个方法都将从<code class="du jt ju jv ji b">Square.java</code>文件和<code class="du jt ju jv ji b">Square</code>类定义中消失。</p><p id="a0ed" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为了简单起见，这个新的渲染代码将被命名为<code class="du jt ju jv ji b">SquareUI.java</code>，下面是它的样子</p><pre class="jd je jf jg fd jh ji jj jk aw jl bi"><span id="5b4a" class="jm jn hi ji b fi jo jp l jq jr">public class SquareUI {</span><span id="fc40" class="jm jn hi ji b fi js jp l jq jr"> public void draw() {<br/>  if(highResolutionMonitor) {<br/>    // render high resolution image<br/>  } else {<br/>    // render normal image<br/>  }<br/> }</span><span id="bc74" class="jm jn hi ji b fi js jp l jq jr"> public void rotate(int degree) {<br/>  // rotate the image with the selected degree<br/> }<br/>}</span></pre><p id="3fbb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><code class="du jt ju jv ji b">Square.java</code>现在看起来像这样。</p><pre class="jd je jf jg fd jh ji jj jk aw jl bi"><span id="e9be" class="jm jn hi ji b fi jo jp l jq jr">public class Square {</span><span id="1d92" class="jm jn hi ji b fi js jp l jq jr"> int side = 5;</span><span id="a8b6" class="jm jn hi ji b fi js jp l jq jr"> public int calculateArea() {<br/>  return side * side;<br/>}</span><span id="ec62" class="jm jn hi ji b fi js jp l jq jr"> public int calculatePerimeter() {<br/>  return side * 4;<br/> }<br/>}</span></pre><p id="32d9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">所以。</p><ol class=""><li id="809e" class="jw jx hi ih b ii ij im in iq jy iu jz iy ka jc kb kc kd ke bi translated"><code class="du jt ju jv ji b">Square.java</code>仅用于测量方块</li><li id="fd8e" class="jw jx hi ih b ii kf im kg iq kh iu ki iy kj jc kb kc kd ke bi translated"><code class="du jt ju jv ji b">SquareUI.java</code>用于渲染目的。</li></ol><p id="a08f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这是用于演示目的的最简单的示例。但这可以适用于一切。</p><pre class="jd je jf jg fd jh ji jj jk aw jl bi"><span id="cd4a" class="jm jn hi ji b fi jo jp l jq jr">public class Student {</span><span id="512f" class="jm jn hi ji b fi js jp l jq jr">private String studentId;<br/>private Date studentDOB;<br/>private String address;</span><span id="2e7d" class="jm jn hi ji b fi js jp l jq jr">public void save() {<br/>    String objectStr = MyUtils.serializeIntoAString(this);<br/>    Connection connection = null;<br/>    Statement stmt = null;<br/>    try {<br/>      Class.forName("com.mysql.jdbc.Driver");<br/>      DriverManager.getConnection("jdbc:mysql://localhost:3306", "MyDB", "root", "password");<br/>      stmt = connection.createStatement;<br/>      stmt.execute("INSERT INTO STUDENT VALUES (" + objectStr + ")");<br/>    } catch (Exception e) {<br/>      e.printStackTrace();<br/>    }<br/>  }</span><span id="2a57" class="jm jn hi ji b fi js jp l jq jr">public String getStudentId() {<br/>    return studentId;<br/>  }</span><span id="e47e" class="jm jn hi ji b fi js jp l jq jr">public void setStudentId(String studentId) {<br/>    this.studentId = studentId;<br/>  }</span><span id="45d2" class="jm jn hi ji b fi js jp l jq jr">}</span></pre><p id="aa16" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这段代码在<code class="du jt ju jv ji b">save</code>方法中执行数据库连接，这也基于启动的实例获取数据(OOP 视角)。</p><p id="7463" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这在 ORM 实现中很常见。但是当然，这可以改变，并分裂成具有特定关注点的文件。</p><p id="6ac8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这里发现的另一个有趣的概念是耦合，它被定义为各种软件组件之间的相互依赖程度。耦合越紧密，就越不理想。</p><p id="94a7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">那么，是如何实现的呢？</p><p id="a64d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">嗯，<code class="du jt ju jv ji b">save</code>方法只是执行到数据库的连接，它只是将<code class="du jt ju jv ji b">Student</code>类序列化为持久化的形式，但是类属性、<code class="du jt ju jv ji b">getStudentId</code>和<code class="du jt ju jv ji b">setStudentId</code>与数据交互。</p><p id="6434" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><code class="du jt ju jv ji b">Student</code>类应该理想地处理相关的功能，而不应该知道与处理后端接口相关的底层细节。</p><p id="838e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">所以，再一次。</p><p id="0878" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">对于<code class="du jt ju jv ji b">Student.java</code>类，重构将如下所示</p><pre class="jd je jf jg fd jh ji jj jk aw jl bi"><span id="4a50" class="jm jn hi ji b fi jo jp l jq jr">public class Student {</span><span id="ff44" class="jm jn hi ji b fi js jp l jq jr">private String studentId;<br/>  private Date studentDOB;<br/>  private String address;</span><span id="6d5f" class="jm jn hi ji b fi js jp l jq jr">public void save() {<br/>     new StudentRepository().save(this);<br/>  }</span><span id="f4fc" class="jm jn hi ji b fi js jp l jq jr">public String getStudentId() {<br/>    return studentId;<br/>  }</span><span id="1f9a" class="jm jn hi ji b fi js jp l jq jr">public void setStudentId(String studentId) {<br/>    this.studentId = studentId;<br/>  }</span><span id="d5e6" class="jm jn hi ji b fi js jp l jq jr">}</span></pre><p id="1b7e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">另一个文件将被创建，称为<code class="du jt ju jv ji b">StudentRepository.java</code>将用于后端实例</p><pre class="jd je jf jg fd jh ji jj jk aw jl bi"><span id="a47a" class="jm jn hi ji b fi jo jp l jq jr">public class StudentRepository {</span><span id="f713" class="jm jn hi ji b fi js jp l jq jr">public void save() {<br/>    String objectStr = MyUtils.serializeIntoAString(this);<br/>    Connection connection = null;<br/>    Statement stmt = null;<br/>    try {<br/>      Class.forName("com.mysql.jdbc.Driver");<br/>      DriverManager.getConnection("jdbc:mysql://localhost:3306", "MyDB", "root", "password");<br/>      stmt = connection.createStatement;<br/>      stmt.execute("INSERT INTO STUDENT VALUES (" + objectStr + ")");<br/>    } catch (Exception e) {<br/>      e.printStackTrace();<br/>    }<br/>  }</span><span id="c4eb" class="jm jn hi ji b fi js jp l jq jr">}</span></pre><p id="9ac6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这有助于更好地遵守 SRP</p><p id="ec82" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><code class="du jt ju jv ji b">Student</code>类将处理核心学生档案数据，而<code class="du jt ju jv ji b">StudentRespository</code>类将处理后端/数据库操作。</p><p id="a78c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我认为在这一点上，整个原则变得非常清晰。</p><p id="49f2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">软件从不休眠，它总是在不断变化。如果你有任何改变的理由，改变的频率就会增加，错误的数量也会增加。</p><p id="d194" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">遵循 SRP 可以节省大量的软件维护成本。</p><p id="48b6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们在下一篇文章中继续讨论开闭原则。</p></div></div>    
</body>
</html>