<html>
<head>
<title>Implementing the ideas behind React router</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">实现React路由器背后的理念</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/implementing-the-ideas-behind-react-router-390b5f99307c?source=collection_archive---------11-----------------------#2021-02-23">https://medium.com/nerd-for-tech/implementing-the-ideas-behind-react-router-390b5f99307c?source=collection_archive---------11-----------------------#2021-02-23</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><figure class="hh hi ez fb hj hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es hg"><img src="../Images/bbc7d773b9936fd18c68e7dfc2e427b7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZyPFqxMMmh5__8y8aKdj1A.jpeg"/></div></div><figcaption class="hr hs et er es ht hu bd b be z dx translated">【https://unsplash.com/photos/1SAnrIxw5OY T4】</figcaption></figure><div class=""/><p id="3dfa" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我正在建立我的Next.js网站。然后我偶然发现了这个简单的特性，由于忽略了组件生命周期的一个基本原则，我花了比预期更长的时间来实现它。我想在页面上创建路线之间的渐变过渡，但这让我陷入了兔子洞。稍微思考了一下谷歌，我还没有找到任何一个关于这一切是如何工作的深入解释，所以我决定跟进我自己的解释。</p><p id="a5b7" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">让我们从探索我们正在构建的东西开始。为了缩小这个练习的范围，我决定将<code class="du jt ju jv jw b">create-react-app</code>和<code class="du jt ju jv jw b">tailwindcss</code>以及我们信任的朋友<a class="ae hv" href="https://codesandbox.io" rel="noopener ugc nofollow" target="_blank">代码沙箱</a>一起使用。</p><figure class="jx jy jz ka fd hk"><div class="bz dy l di"><div class="kb kc l"/></div><figcaption class="hr hs et er es ht hu bd b be z dx translated">我们正在构建的小玩具应用程序</figcaption></figure><p id="e640" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">既然我们已经想通了，让我们开始一步一步地做这个，并解释大致的想法。</p><p id="d3e7" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如果您想跟进，您所要做的就是用React模板创建一个新的CodeSandbox项目，并通过CDN添加Tailwinds。</p><p id="24db" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">(只需转到左边的外部资源部分，添加这个网址<code class="du jt ju jv jw b">https://unpkg.com/tailwindcss@^2/dist/tailwind.min.css</code>)</p><p id="3008" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hz">注意，在原型项目之外不建议这样做</strong></p><h1 id="e0b1" class="kd ke hy bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">制作标记</h1><p id="68db" class="pw-post-body-paragraph iv iw hy ix b iy lb ja jb jc lc je jf jg ld ji jj jk le jm jn jo lf jq jr js hb bi translated">让我们做一些标记！我们需要一个左侧导航栏和一些占位符内容来呈现。我们将通过创建两个额外的组件作为页面来实现这一点。</p><figure class="jx jy jz ka fd hk"><div class="bz dy l di"><div class="lg kc l"/></div><figcaption class="hr hs et er es ht hu bd b be z dx translated">初始加价</figcaption></figure><p id="8879" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">注意，现在我们只是硬编码了<code class="du jt ju jv jw b">&lt;Home /&gt;</code>组件。</p><p id="8c1f" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">接下来，我们想想办法将组件“切换”到正确的位置，这意味着我们需要<strong class="ix hz">一个状态</strong>来跟踪用户当前所在的URL，并需要一个方法<strong class="ix hz">在用户点击其中一个链接时更新状态</strong>。</p><p id="32d7" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">给定我们当前的标记，放置这种状态的唯一逻辑位置应该是在App组件内部，但是我们想更进一步！我们希望与路线相关的州与VDOM的其他州共享。</p><p id="2d07" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们不知道用户会把他的导航放在哪里，或者他会在哪里改变它，我们需要这样的分散化。幸运的是，这种状态共享有一个React特性，那就是<a class="ae hv" href="https://reactjs.org/docs/context.html" rel="noopener ugc nofollow" target="_blank">上下文API </a>。</p><p id="ac60" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">最终结果看起来会像这样:</p><figure class="jx jy jz ka fd hk"><div class="bz dy l di"><div class="lg kc l"/></div><figcaption class="hr hs et er es ht hu bd b be z dx translated">上下文的示例</figcaption></figure><h1 id="8126" class="kd ke hy bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">背景</h1><p id="fd82" class="pw-post-body-paragraph iv iw hy ix b iy lb ja jb jc lc je jf jg ld ji jj jk le jm jn jo lf jq jr js hb bi translated">为了定义上下文，我们需要一个<code class="du jt ju jv jw b">Provider </code>和一个<code class="du jt ju jv jw b">Consumer </code>，当然，还有上下文要传递的对象。</p><figure class="jx jy jz ka fd hk"><div class="bz dy l di"><div class="lg kc l"/></div><figcaption class="hr hs et er es ht hu bd b be z dx translated">路由器上下文</figcaption></figure><p id="651e" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们还为这个上下文提供了默认值，主要是路线，并指出<code class="du jt ju jv jw b">push</code>将是一个函数。</p><p id="015a" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">现在，我们需要一个组件，它将<strong class="ix hz">向上下文提供状态</strong>，负责实际处理“路由”逻辑。让我们制作一个组件，并用它需要的正确值初始化它。</p><figure class="jx jy jz ka fd hk"><div class="bz dy l di"><div class="lg kc l"/></div><figcaption class="hr hs et er es ht hu bd b be z dx translated">路由处理逻辑</figcaption></figure><p id="02b0" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">需要注意的是，这必须<strong class="ix hz">包装在</strong>我们的应用程序中，并将路由状态提供给应用程序的其余部分。最后，我们需要创建一个组件，该组件将根据哪个路由是活动的来注入组件。</p><p id="c3aa" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这里最有趣的一点是，我们还需要利用<code class="du jt ju jv jw b">useEffect </code> hook，以便在我们更改路由后让浏览器更新URL <strong class="ix hz">。</strong></p><figure class="jx jy jz ka fd hk"><div class="bz dy l di"><div class="lg kc l"/></div><figcaption class="hr hs et er es ht hu bd b be z dx translated">动态显示子组件</figcaption></figure><p id="aa8a" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">简单地说，我们传递给它一个“路线”数组，并使用<code class="du jt ju jv jw b">||</code>操作符，我们计算出我们需要动态呈现哪个组件。</p></div><div class="ab cl lh li gp lj" role="separator"><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm"/></div><div class="hb hc hd he hf"><h1 id="2eba" class="kd ke hy bd kf kg lo ki kj kk lp km kn ko lq kq kr ks lr ku kv kw ls ky kz la bi translated">让我们回顾一下</h1><p id="6d1e" class="pw-post-body-paragraph iv iw hy ix b iy lb ja jb jc lc je jf jg ld ji jj jk le jm jn jo lf jq jr js hb bi translated">以下是我们目前的情况:</p><figure class="jx jy jz ka fd hk"><div class="bz dy l di"><div class="lg kc l"/></div><figcaption class="hr hs et er es ht hu bd b be z dx translated">简单看一下到目前为止的代码</figcaption></figure><p id="3c9d" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">到目前为止，我们已经创建了一个功能路由器的所有必要结构，现在我们只需将所有部分连接在一起。</p><p id="df41" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">值得注意的是，在这一点上，我们有一个部分工作的例子。如果您转到浏览器开发工具并手动切换<code class="du jt ju jv jw b">setState </code>钩子的值，您可以看到页面呈现了适当的组件。</p><h1 id="73fc" class="kd ke hy bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">家政</h1><p id="a175" class="pw-post-body-paragraph iv iw hy ix b iy lb ja jb jc lc je jf jg ld ji jj jk le jm jn jo lf jq jr js hb bi translated">在我们继续之前，我们需要做一些整理工作来保持代码库的整洁。<br/>首先，注意<code class="du jt ju jv jw b">useContext </code>函数是如何通过暴露上下文来泄露内部实现细节的。我们不需要这样做，我们应该用自定义的钩子把它包起来！这样，我们将有一个干净的API与外界进行交互。此外，我们应该将所有与路由器相关的功能从App.js模块中移出，放到一个单独的模块中。</p><p id="0a4a" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">接下来，让我们将所有的功能移到一个单独的<code class="du jt ju jv jw b">router/index.js</code>模块中，以保持代码的整洁。</p><figure class="jx jy jz ka fd hk"><div class="bz dy l di"><div class="lg kc l"/></div><figcaption class="hr hs et er es ht hu bd b be z dx translated">经过一些内务路由器/索引. js</figcaption></figure><h1 id="6e31" class="kd ke hy bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">点击路线</h1><p id="613c" class="pw-post-body-paragraph iv iw hy ix b iy lb ja jb jc lc je jf jg ld ji jj jk le jm jn jo lf jq jr js hb bi translated">让我们来测试一下！为了点击路由，我们需要在实际链接上设置事件监听器，并让它们实际导航。我们可以通过利用我们编写的<code class="du jt ju jv jw b">useRouter</code>钩子和一个简单的<code class="du jt ju jv jw b">onClick</code>事件监听器来做到这一点。</p><figure class="jx jy jz ka fd hk"><div class="bz dy l di"><div class="lg kc l"/></div><figcaption class="hr hs et er es ht hu bd b be z dx translated">工作路线</figcaption></figure><p id="36c9" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">请记住，我们必须在上下文中的某个地方声明<code class="du jt ju jv jw b">useRouter</code><strong class="ix hz">，否则它将无法工作。因为在内部它依赖于上下文。这正是我们将按钮移到<code class="du jt ju jv jw b">&lt;Navigation&gt;</code>组件内部的原因。</strong></p><p id="2785" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">就是这样！我们有一个全功能的小应用程序，它有<strong class="ix hz">工作</strong> <strong class="ix hz">路线</strong>。</p><h1 id="f688" class="kd ke hy bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">临时演员</h1><p id="531d" class="pw-post-body-paragraph iv iw hy ix b iy lb ja jb jc lc je jf jg ld ji jj jk le jm jn jo lf jq jr js hb bi translated">到目前为止，我认为API <strong class="ix hz">已经完成</strong>。然而，我们可以改善一些位，因为它们只是生活质量的改善，我已经决定把它放在这里，所以请随意阅读结论。</p><p id="ef2a" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">React路由器提供的一个东西是导航用的更优秀的API，我们的实现只有<strong class="ix hz">一个</strong> <strong class="ix hz">低级API。为了让用户体验更干净，我们应该创建自己的<code class="du jt ju jv jw b">&lt;Link&gt;</code>组件，它应该自动处理点击逻辑，我们应该只提供一个<code class="du jt ju jv jw b">href</code>和一个子组件，要么是<code class="du jt ju jv jw b">&lt;a&gt;</code>，要么是<code class="du jt ju jv jw b">&lt;button&gt;</code>。</strong></p><pre class="jx jy jz ka fd lt jw lu lv aw lw bi"><span id="195b" class="lx ke hy jw b fi ly lz l ma mb">&lt;Link href='/some/path/1'&gt;<br/>  &lt;a&gt;My Link&lt;/a&gt;<br/>&lt;/Link&gt;</span></pre><p id="42b7" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">另一件事，我们应该提供的是一种方式来设计<strong class="ix hz">活动链接。最简单的方法是为一个活动类提供一个道具。</strong></p><figure class="jx jy jz ka fd hk"><div class="bz dy l di"><div class="lg kc l"/></div><figcaption class="hr hs et er es ht hu bd b be z dx translated">链接组件</figcaption></figure><p id="17a6" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这里最独特的代码是<code class="du jt ju jv jw b">React.cloneElement</code>，我们在这里使用它是因为我们想要动态地读取<strong class="ix hz">和修改</strong>链接组件的子组件，并对它们应用一个事件监听器。代码与我们的click listener几乎相同，除了现在<strong class="ix hz">它被封装在<code class="du jt ju jv jw b">&lt;Link&gt;</code>组件中</strong>。</p><p id="b139" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">最后，我们应该为我们的<code class="du jt ju jv jw b">&lt;RouterView&gt;</code>处理<strong class="ix hz">未找到</strong>的情况</p><figure class="jx jy jz ka fd hk"><div class="bz dy l di"><div class="lg kc l"/></div></figure><h1 id="e6a4" class="kd ke hy bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">最后</h1><p id="400f" class="pw-post-body-paragraph iv iw hy ix b iy lb ja jb jc lc je jf jg ld ji jj jk le jm jn jo lf jq jr js hb bi translated">非常感谢你能走到这一步！这是一次不可思议的经历，希望你能像我一样在这个过程中学到一些东西！</p><p id="21b4" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><em class="mc">免责声明:我认为</em> <a class="ae hv" href="https://reactrouter.com/" rel="noopener ugc nofollow" target="_blank"> <em class="mc"> React路由器</em> </a> <em class="mc">是一个很棒的库，你应该经常使用它！问题是，大多数博客都专注于探索现有的API并解释它们，我想探索它们是如何在内部工作的，而不是实际使用它们。</em></p></div></div>    
</body>
</html>