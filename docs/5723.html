<html>
<head>
<title>LeetCode — Word Search</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">LeetCode —单词搜索</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/leetcode-word-search-516d236b9515?source=collection_archive---------2-----------------------#2021-11-07">https://medium.com/nerd-for-tech/leetcode-word-search-516d236b9515?source=collection_archive---------2-----------------------#2021-11-07</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><h1 id="959d" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">问题陈述</h1><p id="4c45" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">给定一个<em class="kb"> m x n </em>的字符网格<em class="kb">棋盘</em>和一串<em class="kb">字</em>，如果网格中存在<em class="kb">字</em>，则返回<em class="kb">真</em>。</p><p id="42ac" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated">该单词可以由顺序相邻单元的字母构成，其中相邻单元水平或垂直相邻。同一个字母单元格不能使用多次。</p><p id="d6ba" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated">问题陈述摘自:<a class="ae kh" href="https://leetcode.com/problems/word-search" rel="noopener ugc nofollow" target="_blank">https://leetcode.com/problems/word-search</a></p><p id="0a57" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated"><strong class="jf hj">例 1: </strong></p><figure class="kj kk kl km fd kn er es paragraph-image"><div class="er es ki"><img src="../Images/7b12d12b7b878f131240dcf4622ca910.png" data-original-src="https://miro.medium.com/v2/resize:fit:644/format:webp/1*HeCwFN-QkxH7j6BObAkzYQ.png"/></div></figure><pre class="kj kk kl km fd kq kr ks kt aw ku bi"><span id="a8b4" class="kv ig hi kr b fi kw kx l ky kz">Input: board = [["A", "B", "C", "E"], ["S", "F", "C", "S"], ["A", "D", "E", "E"]], word = "ABCCED"<br/>Output: true</span></pre><p id="f246" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated"><strong class="jf hj">例 2: </strong></p><pre class="kj kk kl km fd kq kr ks kt aw ku bi"><span id="0291" class="kv ig hi kr b fi kw kx l ky kz">Input: board = [["A", "B", "C", "E"], ["S", "F", "C", "S"], ["A", "D", "E", "E"]], word = "SEE"<br/>Output: true</span></pre><p id="d4fe" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated"><strong class="jf hj">例 3: </strong></p><pre class="kj kk kl km fd kq kr ks kt aw ku bi"><span id="c689" class="kv ig hi kr b fi kw kx l ky kz">Input: board = [["A", "B", "C", "E"], ["S", "F", "C", "S"], ["A", "D", "E", "E"]], word = "ABCB"<br/>Output: false</span></pre><p id="53b9" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated"><strong class="jf hj">约束条件</strong></p><pre class="kj kk kl km fd kq kr ks kt aw ku bi"><span id="f1bf" class="kv ig hi kr b fi kw kx l ky kz">- m == board.length<br/>- n = board[i].length<br/>- 1 &lt;= m, n &lt;= 6<br/>- 1 &lt;= word.length &lt;= 15<br/>- board and word consists of only lowercase and uppercase English letters.</span></pre><h1 id="c019" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">说明</h1><h2 id="0a0a" class="kv ig hi bd ih la lb lc il ld le lf ip jo lg lh it js li lj ix jw lk ll jb lm bi translated">DFS 算法</h2><p id="85bf" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">在 m * n 板上的移动被限制在水平和垂直相邻区域。所以我们只能沿着四个方向移动，而不是八个方向，因为对角线方向的移动受到限制。</p><p id="5fd7" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated">当我们指向一个特定的单元格时，我们检查单词的第一个字符是否与当前单元格中的字符匹配。如果是，我们在当前网格单元的所有四个方向上匹配单词的下一个字符。我们继续这样做，直到我们找到完整的单词。</p><p id="5ddd" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated">我们穿越网格的方式类似于<strong class="jf hj">深度优先搜索</strong>。</p><p id="8d50" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated">让我们检查算法:</p><pre class="kj kk kl km fd kq kr ks kt aw ku bi"><span id="3b3d" class="kv ig hi kr b fi kw kx l ky kz">// function main<br/>- set x[4] = {1, -1, 0, 0}<br/>      y[4] = {0, 0, 1, -1}<br/><br/>- initialize i and j<br/><br/>- loop for i = 0; i &lt; board.size(); i++<br/>  - loop for j = 0; j &lt; board[0].size(); j++<br/>    - if dfs(board, i, j, 0, word)<br/>      - return true<br/><br/>// function dfs(board, i, j, position, word)<br/>- if position &gt;= word.size()<br/>  - return true<br/><br/>// call resolvable function to check the boundary conditions of grid<br/>// and see if the char at word position matches the board index board[i][j]<br/>- if resolvable(board, i, j, position, word)<br/>  - char t = board[i][j]<br/>  - board[i][j] = '.'<br/><br/>  // if the current char matches we move across all the four directions to match the next char<br/>  - loop for k = 0; k &lt; 4; k++<br/>    - if dfs(board, i + x[k], j + y[k], position + 1, word)<br/>      - return true<br/><br/>  - board[i][j] = t<br/><br/>- return false<br/><br/>// function resolvable(board, i, j, position, word)<br/>- return i &gt;= 0 &amp;&amp; i &lt; board.size() &amp;&amp; j &gt;= 0 &amp;&amp; j &lt; board[0].size() &amp;&amp; board[i][j] == word[position]</span></pre><h2 id="14de" class="kv ig hi bd ih la lb lc il ld le lf ip jo lg lh it js li lj ix jw lk ll jb lm bi translated">C++解决方案</h2><pre class="kj kk kl km fd kq kr ks kt aw ku bi"><span id="62f2" class="kv ig hi kr b fi kw kx l ky kz">class Solution {<br/>int x[4] = {1, -1, 0, 0};<br/>int y[4] = {0, 0, 1, -1};<br/><br/>public:<br/>bool resolvable(vector&lt;vector&lt;char&gt;&gt;&amp; board, int i, int j, int position, string word){<br/>    return (i &gt;= 0 &amp;&amp; i &lt; board.size() &amp;&amp; j &gt;= 0 &amp;&amp; j &lt; board[0].size() &amp;&amp; board[i][j] == word[position]);<br/>}<br/><br/>public:<br/>bool dfs(vector&lt;vector&lt;char&gt;&gt;&amp; board, int i, int j, int position, string word){<br/>    if(position &gt;= word.size()){<br/>        return true;<br/>    }<br/><br/>    if(resolvable(board, i, j, position, word)){<br/>        char t = board[i][j];<br/>        board[i][j] = '.';<br/>        for(int k = 0; k &lt; 4; ++k){<br/>            if(dfs(board, i + x[k], j + y[k], position + 1, word)){<br/>                return true;<br/>            }<br/>        }<br/><br/>        board[i][j] = t;<br/>    }<br/><br/>    return false;<br/>}<br/><br/>public:<br/>bool exist(vector&lt;vector&lt;char&gt;&gt;&amp; board, string word) {<br/>    int i, j;<br/><br/>    for(i = 0; i &lt; board.size(); i++){<br/>        for(j = 0; j &lt; board[0].size(); j++){<br/>            if(dfs(board, i, j, 0, word)){<br/>                return true;<br/>            }<br/>        }<br/>    }<br/><br/>    return false;<br/>}<br/>};</span></pre><h2 id="d3d1" class="kv ig hi bd ih la lb lc il ld le lf ip jo lg lh it js li lj ix jw lk ll jb lm bi translated">戈朗溶液</h2><pre class="kj kk kl km fd kq kr ks kt aw ku bi"><span id="19c8" class="kv ig hi kr b fi kw kx l ky kz">var x [4]int<br/>var y [4]int<br/><br/>func resolvable(board [][]byte, i, j, position int, word string) bool {<br/>    return i &gt;= 0 &amp;&amp; i &lt; len(board) &amp;&amp; j &gt;= 0 &amp;&amp; j &lt; len(board[0]) &amp;&amp; word[position] == board[i][j]<br/>}<br/><br/>func dfs(board [][]byte, i, j, position int, word string) bool {<br/>    if position &gt;= len(word) {<br/>        return true<br/>    }<br/><br/>    if resolvable(board, i, j, position, word) {<br/>        t := board[i][j]<br/>        board[i][j] = '.'<br/><br/>        for k := 0; k &lt; 4; k++ {<br/>            if dfs(board, i + x[k], j + y[k], position + 1, word) {<br/>                return true<br/>            }<br/>        }<br/><br/>        board[i][j] = t<br/>    }<br/><br/>    return false<br/>}<br/><br/>func exist(board [][]byte, word string) bool {<br/>    x = [...]int{1, -1, 0, 0}<br/>    y = [...]int{0, 0 , 1, -1}<br/><br/>    for i := 0; i &lt; len(board); i++ {<br/>        for j := 0; j &lt; len(board[0]); j++ {<br/>            if dfs(board, i, j, 0, word) {<br/>                return true<br/>            }<br/>        }<br/>    }<br/><br/>    return false<br/>}</span></pre><h2 id="fece" class="kv ig hi bd ih la lb lc il ld le lf ip jo lg lh it js li lj ix jw lk ll jb lm bi translated">Javascript 解决方案</h2><pre class="kj kk kl km fd kq kr ks kt aw ku bi"><span id="2652" class="kv ig hi kr b fi kw kx l ky kz">var x = [1, -1, 0, 0];<br/>var y = [0, 0, 1, -1];<br/><br/>function resolvable(board, i, j, position, word){<br/>    return i &gt;= 0 &amp;&amp; i &lt; board.length &amp;&amp; j &gt;= 0 &amp;&amp; j &lt; board[0].length &amp;&amp; word[position] == board[i][j]<br/>}<br/><br/>function dfs(board, i, j, position, word){<br/>    if(position &gt;= word.length) {<br/>        return true;<br/>    }<br/><br/>    if(resolvable(board, i, j, position, word)) {<br/>        var t = board[i][j];<br/>        board[i][j] = '.';<br/><br/>        for(var k = 0 ; k &lt; 4; k++){<br/>            if(dfs(board, i + x[k], j + y[k], position + 1, word)){<br/>                return true;<br/>            }<br/>        }<br/><br/>        board[i][j] = t;<br/>    }<br/><br/>    return false;<br/>}<br/><br/>var exist = function(board, word) {<br/>    for(var i = 0; i &lt; board.length; i++){<br/>        for(var j = 0; j &lt; board[0].length; j++){<br/>            if(dfs(board, i, j, 0, word)) {<br/>                return true;<br/>            }<br/>        }<br/>    }<br/><br/>    return false;<br/>}</span></pre><p id="5e12" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated">让我们试运行一下我们的算法，看看解决方案是如何工作的。</p><pre class="kj kk kl km fd kq kr ks kt aw ku bi"><span id="91d3" class="kv ig hi kr b fi kw kx l ky kz">Input: board = [["A", "B", "C", "E"], ["S", "F", "C", "S"], ["A", "D", "E", "E"]]<br/>       word = "SEE"<br/><br/>Step 1: initialize i, j<br/><br/>Step 2: loop for i = 0; i &lt; board.size()<br/>        0 &lt; 3<br/>        true<br/><br/>        loop for j = 0; j &lt; board[0].size()<br/>        0 &lt; 4<br/>        true<br/><br/>        dfs(board, i, j, 0, word)<br/>        dfs(board, 0, 0, 0, word)<br/><br/>Step 3: //in function dfs<br/>        if position &gt;= word.size()<br/>           0 &gt;= 3<br/>           false<br/><br/>        if resolvable(board, i, j, position, word)<br/>          - i &gt;= 0 &amp;&amp; i &lt; board.size() &amp;&amp; j &gt;= 0 &amp;&amp; j &lt; board[0].size &amp;&amp; word[position] == board[i][j]<br/>          - 0 &gt;= 0 &amp;&amp; 0 &lt; 3 &amp;&amp; j &gt;= 0 &amp;&amp; 0 &lt; 4 &amp;&amp; word[0] == board[0][0]<br/>          - true &amp;&amp; 'S' == 'A'<br/>          - false<br/><br/>        return false<br/><br/>Step 4: We reach at step 2 and increment j<br/>        i = 0<br/>        j = 1<br/><br/>        dfs(board, i, j, 0, word)<br/>        dfs(board, 0, 1, 0, word)<br/><br/>Step 5: //in function dfs<br/>        if position &gt;= word.size()<br/>           0 &gt;= 3<br/>           false<br/><br/>        if resolvable(board, i, j, position, word)<br/>          - i &gt;= 0 &amp;&amp; i &lt; board.size() &amp;&amp; j &gt;= 0 &amp;&amp; j &lt; board[0].size &amp;&amp; word[position] == board[i][j]<br/>          - 0 &gt;= 0 &amp;&amp; 0 &lt; 3 &amp;&amp; 1 &gt;= 0 &amp;&amp; 1 &lt; 4 &amp;&amp; word[0] == board[0][1]<br/>          - true &amp;&amp; 'S' == 'B'<br/>          - false<br/><br/>        return false<br/><br/>Step 6: We reach at step 2 and increment j<br/>        i = 0<br/>        j = 2<br/><br/>        dfs(board, i, j, 0, word)<br/>        dfs(board, 0, 2, 0, word)<br/><br/>Step 7: //in function dfs<br/>        if position &gt;= word.size()<br/>           0 &gt;= 3<br/>           false<br/><br/>        if resolvable(board, i, j, position, word)<br/>          - i &gt;= 0 &amp;&amp; i &lt; board.size() &amp;&amp; j &gt;= 0 &amp;&amp; j &lt; board[0].size &amp;&amp; word[position] == board[i][j]<br/>          - 0 &gt;= 0 &amp;&amp; 0 &lt; 3 &amp;&amp; 2 &gt;= 0 &amp;&amp; 2 &lt; 4 &amp;&amp; word[0] == board[0][2]<br/>          - true &amp;&amp; 'S' == 'C'<br/>          - false<br/><br/>        return false<br/><br/>Step 8: We reach at step 2 and increment j<br/>        i = 0<br/>        j = 3<br/><br/>        dfs(board, i, j, 0, word)<br/>        dfs(board, 0, 3, 0, word)<br/><br/>Step 9: //in function dfs<br/>        if position &gt;= word.size()<br/>           0 &gt;= 3<br/>           false<br/><br/>        if resolvable(board, i, j, position, word)<br/>          - i &gt;= 0 &amp;&amp; i &lt; board.size() &amp;&amp; j &gt;= 0 &amp;&amp; j &lt; board[0].size &amp;&amp; word[position] == board[i][j]<br/>          - 0 &gt;= 0 &amp;&amp; 0 &lt; 3 &amp;&amp; 3 &gt;= 0 &amp;&amp; 3 &lt; 4 &amp;&amp; word[0] == board[0][3]<br/>          - true &amp;&amp; 'S' == 'E'<br/>          - false<br/><br/>        return false<br/><br/>Step 10: We reach at step 2 and increment j<br/>        i = 0<br/>        j = 4<br/><br/>        dfs(board, i, j, 0, word)<br/>        dfs(board, 0, 3, 0, word)<br/><br/>Step 11: //in function dfs<br/>        if position &gt;= word.size()<br/>           0 &gt;= 3<br/>           false<br/><br/>        if resolvable(board, i, j, position, word)<br/>          - i &gt;= 0 &amp;&amp; i &lt; board.size() &amp;&amp; j &gt;= 0 &amp;&amp; j &lt; board[0].size &amp;&amp; word[position] == board[i][j]<br/>          - 0 &gt;= 0 &amp;&amp; 0 &lt; 3 &amp;&amp; 3 &gt;= 0 &amp;&amp; 4 &lt; 4 &amp;&amp; word[0] == board[0][3]<br/>          - false &amp;&amp; 'S' == 'E'<br/>          - false<br/><br/>        return false<br/><br/>Step 12: We reach at step 2 and increment i and j is 0<br/>        i = 1<br/>        j = 0<br/><br/>        dfs(board, i, j, 0, word)<br/>        dfs(board, 1, 0, 0, word)<br/><br/>Step 13: //in function dfs<br/>        if position &gt;= word.size()<br/>           0 &gt;= 3<br/>           false<br/><br/>        if resolvable(board, i, j, position, word)<br/>          - i &gt;= 0 &amp;&amp; i &lt; board.size() &amp;&amp; j &gt;= 0 &amp;&amp; j &lt; board[0].size &amp;&amp; word[position] == board[i][j]<br/>          - 1 &gt;= 0 &amp;&amp; 1 &lt; 3 &amp;&amp; 0 &gt;= 0 &amp;&amp; 0 &lt; 4 &amp;&amp; word[0] == board[1][0]<br/>          - true &amp;&amp; 'S' == 'S'<br/>          - true<br/><br/>          - t = board[i][j]<br/>          - t = 'S'<br/>          - board[i][j] = '.'<br/>          - board[1][0] = '.'<br/><br/>          loop for k = 0; k &lt; 4<br/>            - dfs(board, i + x[k], j + y[k], position + 1, word)<br/>            - dfs(board, 1 + x[0], 0 + y[0], 0 + 1, word)<br/>            - dfs(board, 1 + 1, 0 + 0, 0 + 1, word)<br/>            - dfs(board, 2, 0 + 0, 1, word)<br/><br/>        // recursive call to dfs function<br/>        if position &gt;= word.size()<br/>           1 &gt;= 3<br/>           false<br/><br/>        if resolvable(board, i, j, position, word)<br/>          - i &gt;= 0 &amp;&amp; i &lt; board.size() &amp;&amp; j &gt;= 0 &amp;&amp; j &lt; board[0].size &amp;&amp; word[position] == board[i][j]<br/>          - 2 &gt;= 0 &amp;&amp; 2 &lt; 3 &amp;&amp; 0 &gt;= 0 &amp;&amp; 0 &lt; 4 &amp;&amp; word[1] == board[2][0]<br/>          - true &amp;&amp; 'E' == 'A'<br/>          - false<br/><br/><br/>          k++<br/>          k = 1<br/><br/>          loop for k &lt; 4<br/>            - dfs(board, i + x[k], j + y[k], position + 1, word)<br/>            - dfs(board, 1 + x[1], 0 + y[1], 0 + 1, word)<br/>            - dfs(board, 1 - 1, 0 + 0, 0 + 1, word)<br/>            - dfs(board, 0, 0, 1, word)<br/><br/>        // recursive call to dfs function<br/>        if position &gt;= word.size()<br/>           1 &gt;= 3<br/>           false<br/><br/>        if resolvable(board, i, j, position, word)<br/>          - i &gt;= 0 &amp;&amp; i &lt; board.size() &amp;&amp; j &gt;= 0 &amp;&amp; j &lt; board[0].size &amp;&amp; word[position] == board[i][j]<br/>          - 0 &gt;= 0 &amp;&amp; 0 &lt; 3 &amp;&amp; 0 &gt;= 0 &amp;&amp; 0 &lt; 4 &amp;&amp; word[1] == board[0][0]<br/>          - true &amp;&amp; 'E' == 'A'<br/>          - false<br/><br/>          k++<br/>          k = 2<br/><br/>          loop for k &lt; 4<br/>            - dfs(board, i + x[k], j + y[k], position + 1, word)<br/>            - dfs(board, 1 + x[2], 0 + y[2], 0 + 1, word)<br/>            - dfs(board, 1 + 0, 0 + 1, 0 + 1, word)<br/>            - dfs(board, 1, 1, 1, word)<br/><br/>        // recursive call to dfs function<br/>        if position &gt;= word.size()<br/>           1 &gt;= 3<br/>           false<br/><br/>        if resolvable(board, i, j, position, word)<br/>          - i &gt;= 0 &amp;&amp; i &lt; board.size() &amp;&amp; j &gt;= 0 &amp;&amp; j &lt; board[0].size &amp;&amp; word[position] == board[i][j]<br/>          - 1 &gt;= 0 &amp;&amp; 1 &lt; 3 &amp;&amp; 1 &gt;= 0 &amp;&amp; 1 &lt; 4 &amp;&amp; word[1] == board[1][1]<br/>          - true &amp;&amp; 'E' == 'F'<br/>          - false<br/><br/>          k++<br/>          k = 3<br/><br/>          loop for k &lt; 4<br/>            - dfs(board, i + x[k], j + y[k], position + 1, word)<br/>            - dfs(board, 1 + x[3], 0 + y[3], 0 + 1, word)<br/>            - dfs(board, 1 + 0, 0 - 1, 0 + 1, word)<br/>            - dfs(board, 1, -1, 1, word)<br/><br/>        // recursive call to dfs function<br/>        if position &gt;= word.size()<br/>           1 &gt;= 3<br/>           false<br/><br/>        if resolvable(board, i, j, position, word)<br/>          - i &gt;= 0 &amp;&amp; i &lt; board.size() &amp;&amp; j &gt;= 0 &amp;&amp; j &lt; board[0].size &amp;&amp; word[position] == board[i][j]<br/>          - 1 &gt;= 0 &amp;&amp; 1 &lt; 3 &amp;&amp; -1 &gt;= 0 &amp;&amp; 1 &lt; 4 &amp;&amp; word[1] == board[1][1]<br/>          - false<br/><br/>          k++<br/>          k = 4<br/><br/>          loop for k &lt; 4<br/>            - false<br/><br/>        return false<br/><br/>Step 14: We reach at step 2 and increment i and j is 0<br/>        i = 1<br/>        j = 1<br/><br/>        dfs(board, i, j, 0, word)<br/>        dfs(board, 1, 1, 0, word)<br/><br/>        This is false since word[0] != board[1][1]<br/>        'S' != 'F'<br/><br/>Step 15: We reach at step 2 and increment i and j is 1<br/>        i = 1<br/>        j = 2<br/><br/>        dfs(board, i, j, 0, word)<br/>        dfs(board, 1, 2, 0, word)<br/><br/>        This is false since word[0] != board[1][2]<br/>        'S' != 'C'<br/><br/>Step 16: We reach at step 2 and increment i and j is 2<br/>        i = 1<br/>        j = 3<br/><br/>        dfs(board, i, j, 0, word)<br/>        dfs(board, 1, 3, 0, word)<br/><br/>Step 17: //in function dfs<br/>        if position &gt;= word.size()<br/>           0 &gt;= 3<br/>           false<br/><br/>        if resolvable(board, i, j, position, word)<br/>          - i &gt;= 0 &amp;&amp; i &lt; board.size() &amp;&amp; j &gt;= 0 &amp;&amp; j &lt; board[0].size &amp;&amp; word[position] == board[i][j]<br/>          - 1 &gt;= 0 &amp;&amp; 1 &lt; 3 &amp;&amp; 3 &gt;= 0 &amp;&amp; 3 &lt; 4 &amp;&amp; word[0] == board[1][3]<br/>          - true &amp;&amp; 'S' == 'S'<br/>          - true<br/><br/>          - t = board[i][j]<br/>          - t = 'S'<br/>          - board[i][j] = '.'<br/>          - board[1][3] = '.'<br/><br/>          loop for k = 0; k &lt; 4<br/>            - dfs(board, i + x[k], j + y[k], position + 1, word)<br/>            - dfs(board, 1 + x[0], 3 + y[0], 0 + 1, word)<br/>            - dfs(board, 1 + 1, 3 + 0, 0 + 1, word)<br/>            - dfs(board, 2, 3, 1, word)<br/><br/>        // recursive call to dfs function<br/>        if position &gt;= word.size()<br/>           1 &gt;= 3<br/>           false<br/><br/>        if resolvable(board, i, j, position, word)<br/>          - i &gt;= 0 &amp;&amp; i &lt; board.size() &amp;&amp; j &gt;= 0 &amp;&amp; j &lt; board[0].size &amp;&amp; word[position] == board[i][j]<br/>          - 2 &gt;= 0 &amp;&amp; 2 &lt; 3 &amp;&amp; 3 &gt;= 0 &amp;&amp; 3 &lt; 4 &amp;&amp; word[1] == board[2][3]<br/>          - true &amp;&amp; 'E' == 'E'<br/>          - true<br/><br/>          - t = board[i][j]<br/>          - t = 'E'<br/>          - board[i][j] = '.'<br/>          - board[2][3] = '.'<br/><br/>          loop for k = 0; k &lt; 4<br/>            - dfs(board, i + x[k], j + y[k], position + 1, word)<br/>            - dfs(board, 2 + x[0], 3 + y[0], 1 + 1, word)<br/>            - dfs(board, 2 + 1, 3 + 0, 2, word)<br/>            - dfs(board, 3, 3, 1, word)<br/><br/>        // recursive call to dfs function<br/>        if position &gt;= word.size()<br/>           2 &gt;= 3<br/>           false<br/><br/>        if resolvable(board, i, j, position, word)<br/>          - i &gt;= 0 &amp;&amp; i &lt; board.size() &amp;&amp; j &gt;= 0 &amp;&amp; j &lt; board[0].size &amp;&amp; word[position] == board[i][j]<br/>          - 3 &gt;= 0 &amp;&amp; 3 &lt; 3 &amp;&amp; 3 &gt;= 0 &amp;&amp; 3 &lt; 4 &amp;&amp; word[2] == board[2][3]<br/>          - false &amp;&amp; 'E' == 'E'<br/>          - false<br/><br/>          k++<br/>          k = 1<br/><br/>          loop for k = 0; k &lt; 4<br/>            - dfs(board, i + x[k], j + y[k], position + 1, word)<br/>            - dfs(board, 2 + x[1], 3 + y[1], 1 + 1, word)<br/>            - dfs(board, 2 - 1, 3 + 0, 2, word)<br/>            - dfs(board, 1, 3, 2, word)<br/><br/>        // recursive call to dfs function<br/>        if position &gt;= word.size()<br/>           2 &gt;= 3<br/>           false<br/><br/>        if resolvable(board, i, j, position, word)<br/>          - i &gt;= 0 &amp;&amp; i &lt; board.size() &amp;&amp; j &gt;= 0 &amp;&amp; j &lt; board[0].size &amp;&amp; word[position] == board[i][j]<br/>          - 1 &gt;= 0 &amp;&amp; 1 &lt; 3 &amp;&amp; 3 &gt;= 0 &amp;&amp; 3 &lt; 4 &amp;&amp; word[2] == board[1][3]<br/>          - false &amp;&amp; 'E' == 'C'<br/>          - false<br/><br/>          k++<br/>          k = 2<br/><br/>          loop for k = 0; k &lt; 4<br/>            - dfs(board, i + x[k], j + y[k], position + 1, word)<br/>            - dfs(board, 2 + x[2], 3 + y[2], 1 + 1, word)<br/>            - dfs(board, 2 + 0, 3 + 1, 2, word)<br/>            - dfs(board, 2, 4, 2, word)<br/><br/>        // recursive call to dfs function<br/>        if position &gt;= word.size()<br/>           2 &gt;= 3<br/>           false<br/><br/>        if resolvable(board, i, j, position, word)<br/>          - i &gt;= 0 &amp;&amp; i &lt; board.size() &amp;&amp; j &gt;= 0 &amp;&amp; j &lt; board[0].size &amp;&amp; word[position] == board[i][j]<br/>          - 2 &gt;= 0 &amp;&amp; 2 &lt; 3 &amp;&amp; 4 &gt;= 0 &amp;&amp; 4 &lt; 4 &amp;&amp; word[2] == board[2][4]<br/>          - false<br/><br/>          k++<br/>          k = 3<br/><br/>          loop for k = 0; k &lt; 4<br/>            - dfs(board, i + x[k], j + y[k], position + 1, word)<br/>            - dfs(board, 2 + x[3], 3 + y[3], 1 + 1, word)<br/>            - dfs(board, 2 + 0, 3 - 1, 2, word)<br/>            - dfs(board, 2, 2, 2, word)<br/><br/>        // recursive call to dfs function<br/>        if position &gt;= word.size()<br/>           2 &gt;= 3<br/>           false<br/><br/>        if resolvable(board, i, j, position, word)<br/>          - i &gt;= 0 &amp;&amp; i &lt; board.size() &amp;&amp; j &gt;= 0 &amp;&amp; j &lt; board[0].size &amp;&amp; word[position] == board[i][j]<br/>          - 2 &gt;= 0 &amp;&amp; 2 &lt; 3 &amp;&amp; 2 &gt;= 0 &amp;&amp; 2 &lt; 4 &amp;&amp; word[2] == board[2][2]<br/>          - true &amp;&amp; 'E' == 'E'<br/>          - true<br/><br/>          - t = board[i][j]<br/>          - t = 'E'<br/>          - board[i][j] = '.'<br/>          - board[2][2] = '.'<br/><br/>          loop for k = 0; k &lt; 4<br/>            - dfs(board, i + x[k], j + y[k], position + 1, word)<br/>            - dfs(board, 2 + x[0], 2 + y[0], 2 + 1, word)<br/>            - dfs(board, 2 + 1, 2 + 0, 3, word)<br/>            - dfs(board, 2, 2, 3, word)<br/><br/>        // recursive call to dfs function<br/>        if position &gt;= word.size()<br/>           3 &gt;= 3<br/>           true<br/><br/>Step 18: // Here we have covered all chars of the string "SEE" and found in the grid.<br/>         // So we return true from this recursive calls and return to exist function.<br/><br/>So the answer we return is true.</span></pre></div><div class="ab cl ln lo gp lp" role="separator"><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls"/></div><div class="hb hc hd he hf"><p id="01df" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated"><em class="kb">原载于</em><a class="ae kh" href="https://alkeshghorpade.me/post/leetcode-word-search" rel="noopener ugc nofollow" target="_blank"><em class="kb">https://alkeshghorpade . me</em></a><em class="kb">。</em></p></div></div>    
</body>
</html>