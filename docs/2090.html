<html>
<head>
<title>OpenAPI Generation with Ktor</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用Ktor生成OpenAPI</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/openapi-generation-with-ktor-d57879ec5ab0?source=collection_archive---------4-----------------------#2021-04-20">https://medium.com/nerd-for-tech/openapi-generation-with-ktor-d57879ec5ab0?source=collection_archive---------4-----------------------#2021-04-20</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div class="er es if"><img src="../Images/6c2f19da96f635f7b850e3184665c1a7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1116/format:webp/0*YuI9_aSXNgbVZlbj.png"/></div></figure><h1 id="7e0e" class="im in hi bd io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj bi translated">介绍</h1><p id="c7ba" class="pw-post-body-paragraph jk jl hi jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh hb bi translated">作为我的系列“<a class="ae ki" rel="noopener" href="/p/87f814e3dffd">一个固执己见的Kotlin后端服务</a>”的一部分，我正在研究如何<strong class="jm hj">自动生成</strong> <a class="ae ki" href="https://www.openapis.org/" rel="noopener ugc nofollow" target="_blank"> <strong class="jm hj"> OpenAPI </strong> </a> <strong class="jm hj">文档</strong>(问题)。在解释如何从代码(解决方案)中<strong class="jm hj">生成api文档之前，我将简要概述生成这种文档的不同方法。</strong></p><h1 id="1136" class="im in hi bd io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj bi translated">OpenAPI</h1><p id="93e9" class="pw-post-body-paragraph jk jl hi jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh hb bi translated"><a class="ae ki" href="https://www.openapis.org/" rel="noopener ugc nofollow" target="_blank"> OpenAPI </a>是描述API的标准，因为<a class="ae ki" href="https://raml.org/" rel="noopener ugc nofollow" target="_blank"> RAML </a>的开发者加入了<a class="ae ki" href="https://www.openapis.org/" rel="noopener ugc nofollow" target="_blank"> OpenAPI倡议</a>(这有点复杂，但这不是一篇关于不同标准的文章……)。如果你想让你的后端服务被正确使用，它应该有一个OpenAPI文档。</p><h1 id="a381" class="im in hi bd io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj bi translated">我已经有一个API了</h1><p id="a2cd" class="pw-post-body-paragraph jk jl hi jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh hb bi translated">如果你已经有一个API，只需要文档，使用各种Swagger工具中的一个(像<a class="ae ki" href="https://inspector.swagger.io/builder" rel="noopener ugc nofollow" target="_blank"> Swagger Inspector </a>、<a class="ae ki" href="https://swagger.io/tools/swagger-editor" rel="noopener ugc nofollow" target="_blank"> Swagger Editor </a>或<a class="ae ki" href="https://editor.swagger.io/" rel="noopener ugc nofollow" target="_blank">另一个Swagger Editor </a>)来记录你的API，然后将其作为你的应用的一部分发布，或者用<a class="ae ki" href="https://app.swaggerhub.com/" rel="noopener ugc nofollow" target="_blank"> SwaggerHub </a>托管它。顺便说一句，我不是靠招摇过市来赚钱的，我也知道，除了招摇过市，还有其他选择；-).</p><h1 id="f5a6" class="im in hi bd io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj bi translated">我还没有API</h1><p id="d1d9" class="pw-post-body-paragraph jk jl hi jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh hb bi translated">如果你没有API或者想将现有的API转换成自动生成的文档，imo有三种方法:</p><ol class=""><li id="9240" class="kj kk hi jm b jn kl jr km jv kn jz ko kd kp kh kq kr ks kt bi translated">从API文档生成路由/服务器存根:<br/> <strong class="jm hj"> API文档</strong> ➔ <strong class="jm hj">代码生成</strong></li><li id="ff4a" class="kj kk hi jm b jn ku jr kv jv kw jz kx kd ky kh kq kr ks kt bi translated">从您的代码文档生成API文档:<br/> <strong class="jm hj">代码文档</strong> ➔ <strong class="jm hj"> API文档</strong></li><li id="5931" class="kj kk hi jm b jn ku jr kv jv kw jz kx kd ky kh kq kr ks kt bi translated">从路由代码<br/> <strong class="jm hj">生成API文档路由代码</strong> ➔ <strong class="jm hj"> API文档</strong></li></ol></div><div class="ab cl kz la gp lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="hb hc hd he hf"><h2 id="456b" class="lg in hi bd io lh li lj is lk ll lm iw jv ln lo ja jz lp lq je kd lr ls ji lt bi translated">API文档➔代码生成</h2><p id="898c" class="pw-post-body-paragraph jk jl hi jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh hb bi translated">在这种情况下，编写API文档，代码生成器生成服务器和/或客户端存根。</p><p id="5306" class="pw-post-body-paragraph jk jl hi jm b jn kl jp jq jr km jt ju jv lu jx jy jz lv kb kc kd lw kf kg kh hb bi translated">最受欢迎和最完整的发电机可能是https://github.com/OpenAPITools/openapi-generator。它支持许多不同的目标平台，kotlin-server就是其中之一。如果你想查看生成的代码，我建议你先试试<a class="ae ki" href="https://swagger.io/tools/swagger-codegen/" rel="noopener ugc nofollow" target="_blank"> Swagger Codegen </a>。它比<a class="ae ki" href="https://github.com/OpenAPITools/openapi-generator" rel="noopener ugc nofollow" target="_blank">的openapi-generator </a>更容易使用，并且还有一个kotlin-server选项:</p><figure class="ly lz ma mb fd ij er es paragraph-image"><div role="button" tabindex="0" class="mc md di me bf mf"><div class="er es lx"><img src="../Images/fc28758de9abc5bab85020cfa3dae4bf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1NRQFzoq4Hjlf2N_A63X9g.png"/></div></div></figure><h2 id="fab0" class="lg in hi bd io lh li lj is lk ll lm iw jv ln lo ja jz lp lq je kd lr ls ji lt bi translated"><strong class="ak">代码文档</strong> ➔ <strong class="ak"> API文档</strong></h2><p id="3004" class="pw-post-body-paragraph jk jl hi jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh hb bi translated">在这种情况下，通过使用注释和/或文档生成器(如<a class="ae ki" href="https://www.oracle.com/java/technologies/javase/javadoc-tool.html" rel="noopener ugc nofollow" target="_blank"> JavaDoc </a>、<a class="ae ki" href="https://jsdoc.app/" rel="noopener ugc nofollow" target="_blank"> JSDoc </a>或<a class="ae ki" href="https://yardoc.org/" rel="noopener ugc nofollow" target="_blank"> YARD </a>)来记录代码。扩展可用于在常规代码文档之上创建OpenAPI文档。</p><p id="be05" class="pw-post-body-paragraph jk jl hi jm b jn kl jp jq jr km jt ju jv lu jx jy jz lv kb kc kd lw kf kg kh hb bi translated">例如，对于nodejs，有<a class="ae ki" href="https://www.npmjs.com/package/swagger-jsdoc" rel="noopener ugc nofollow" target="_blank"> swagger-jsdoc </a>从注释和jsdoc生成OpenAPI文档:</p><figure class="ly lz ma mb fd ij"><div class="bz dy l di"><div class="mg mh l"/></div></figure><p id="5a34" class="pw-post-body-paragraph jk jl hi jm b jn kl jp jq jr km jt ju jv lu jx jy jz lv kb kc kd lw kf kg kh hb bi translated">对于Java，有一个<a class="ae ki" href="https://github.com/swagger-api/swagger-core" rel="noopener ugc nofollow" target="_blank"> Swagger核心</a>:</p><figure class="ly lz ma mb fd ij"><div class="bz dy l di"><div class="mg mh l"/></div></figure><h2 id="7c77" class="lg in hi bd io lh li lj is lk ll lm iw jv ln lo ja jz lp lq je kd lr ls ji lt bi translated">路由代码➔ API文档</h2><p id="821a" class="pw-post-body-paragraph jk jl hi jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh hb bi translated">在这种情况下，API被记录为代码的一部分，并且生成器通过解析代码(例如插件)或者通过扩展路由库以添加文档特征来创建OpenAPI文档。</p><p id="0467" class="pw-post-body-paragraph jk jl hi jm b jn kl jp jq jr km jt ju jv lu jx jy jz lv kb kc kd lw kf kg kh hb bi translated">该选项不同于“代码文档➔ API文档”选项，因为它对实际路线和API文档使用相同的语言(与注释、配置文件或特定文档“语言”相比)。</p><p id="4b74" class="pw-post-body-paragraph jk jl hi jm b jn kl jp jq jr km jt ju jv lu jx jy jz lv kb kc kd lw kf kg kh hb bi translated">对于Ruby on Rails，例如有<a class="ae ki" href="https://github.com/rswag/rswag" rel="noopener ugc nofollow" target="_blank"> rswag </a>:</p><figure class="ly lz ma mb fd ij"><div class="bz dy l di"><div class="mg mh l"/></div></figure><p id="83a8" class="pw-post-body-paragraph jk jl hi jm b jn kl jp jq jr km jt ju jv lu jx jy jz lv kb kc kd lw kf kg kh hb bi translated">对于Ktor/Kotlin，有<a class="ae ki" href="https://github.com/papsign/Ktor-OpenAPI-Generator" rel="noopener ugc nofollow" target="_blank"> Ktor-OpenAPI-Generator </a>:</p><figure class="ly lz ma mb fd ij"><div class="bz dy l di"><div class="mg mh l"/></div></figure><h2 id="e3ae" class="lg in hi bd io lh li lj is lk ll lm iw jv ln lo ja jz lp lq je kd lr ls ji lt bi translated">决定</h2><p id="0882" class="pw-post-body-paragraph jk jl hi jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh hb bi translated">有两个决定:</p><ol class=""><li id="1242" class="kj kk hi jm b jn kl jr km jv kn jz ko kd kp kh kq kr ks kt bi translated">生成代码或文档？</li><li id="fdfa" class="kj kk hi jm b jn ku jr kv jv kw jz kx kd ky kh kq kr ks kt bi translated">从代码还是从注释/特定文档生成文档？</li></ol><p id="5ce6" class="pw-post-body-paragraph jk jl hi jm b jn kl jp jq jr km jt ju jv lu jx jy jz lv kb kc kd lw kf kg kh hb bi translated">当我检查了生成的代码后，第一个决定对我来说很容易。与Java不同的是，<a class="ae ki" href="https://github.com/OpenAPITools/openapi-generator" rel="noopener ugc nofollow" target="_blank">https://github.com/OpenAPITools/openapi-generator</a>生成的kotlin-server代码非常简单，没有增加什么价值，因为每一次代码生成都需要手工集成。似乎也没有太多兴趣将它用于Ktor(在<a class="ae ki" href="https://stackoverflow.com/questions/tagged/openapi-generator%20ktor" rel="noopener ugc nofollow" target="_blank">上只有一个问题与openapi-generator和ktor </a>相关)。如果实际的业务逻辑可以很容易地插入，并且在代码生成运行后不需要手动更改，那么代码生成将会很有用。</p><p id="192f" class="pw-post-body-paragraph jk jl hi jm b jn kl jp jq jr km jt ju jv lu jx jy jz lv kb kc kd lw kf kg kh hb bi translated">第二个决定对我来说也很容易。正如在<a class="ae ki" rel="noopener" href="/nerd-for-tech/object-validation-in-kotlin-c7e02b5dabc">https://medium . com/nerd-for-tech/object-validation-in-kot Lin-c 7 e 02 b 5 dabc</a>中已经解释过的，我提倡使用单一语言，而不是为特定目的(配置、文档、路由定义等)使用不同的语言。)所以我决定深入研究，并使用<a class="ae ki" href="https://github.com/papsign/Ktor-OpenAPI-Generator" rel="noopener ugc nofollow" target="_blank"> Ktor-OpenAPI-Generator </a>来实现我的目的。</p><h1 id="9b91" class="im in hi bd io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj bi translated">ktor-open API-生成器</h1><h2 id="8fad" class="lg in hi bd io lh li lj is lk ll lm iw jv ln lo ja jz lp lq je kd lr ls ji lt bi translated">坏事</h2><p id="22c0" class="pw-post-body-paragraph jk jl hi jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh hb bi translated">项目<a class="ae ki" href="https://github.com/papsign/Ktor-OpenAPI-Generator" rel="noopener ugc nofollow" target="_blank">https://github.com/papsign/Ktor-OpenAPI-Generator</a>不是很活跃，8个守望者，122个星，25个叉。上次提交时间是2021年3月17日，版本是0.2-beta.16。</p><p id="f4b5" class="pw-post-body-paragraph jk jl hi jm b jn kl jp jq jr km jt ju jv lu jx jy jz lv kb kc kd lw kf kg kh hb bi translated">文档非常缺乏，这里的例子<a class="ae ki" href="https://github.com/papsign/Ktor-OpenAPI-Generator/wiki/A-few-examples" rel="noopener ugc nofollow" target="_blank">https://github . com/papsign/Ktor-open API-Generator/wiki/A-first-examples</a>让人困惑多于启发。演示项目<a class="ae ki" href="https://github.com/SerVB/e-shop" rel="noopener ugc nofollow" target="_blank">https://github.com/SerVB/e-shop</a>相当古老。它确实比“<a class="ae ki" href="https://github.com/papsign/Ktor-OpenAPI-Generator/wiki/A-few-examples" rel="noopener ugc nofollow" target="_blank">几个例子</a>”解释得更多，但作为快速入门指南，它肯定不理想。</p><p id="05cf" class="pw-post-body-paragraph jk jl hi jm b jn kl jp jq jr km jt ju jv lu jx jy jz lv kb kc kd lw kf kg kh hb bi translated">有一件事我马上就被绊倒了，而且几乎让我放弃了图书馆，那就是所谓的DSL。它是嵌套对象生成、构造函数对象实例化、扩展函数和实际DSL的混合体。</p><p id="81d3" class="pw-post-body-paragraph jk jl hi jm b jn kl jp jq jr km jt ju jv lu jx jy jz lv kb kc kd lw kf kg kh hb bi translated">设置插件看起来还是有希望的(实际DSL):</p><figure class="ly lz ma mb fd ij"><div class="bz dy l di"><div class="mg mh l"/></div></figure><p id="08c4" class="pw-post-body-paragraph jk jl hi jm b jn kl jp jq jr km jt ju jv lu jx jy jz lv kb kc kd lw kf kg kh hb bi translated">设置路线已经很尴尬了:</p><figure class="ly lz ma mb fd ij"><div class="bz dy l di"><div class="mg mh l"/></div></figure><p id="acf8" class="pw-post-body-paragraph jk jl hi jm b jn kl jp jq jr km jt ju jv lu jx jy jz lv kb kc kd lw kf kg kh hb bi translated">添加异常处理会使情况变得更糟(这是来自<a class="ae ki" href="https://github.com/SerVB/e-shop" rel="noopener ugc nofollow" target="_blank">https://github.com/SerVB/e-shop</a>的一个真实例子):</p><figure class="ly lz ma mb fd ij"><div class="bz dy l di"><div class="mg mh l"/></div></figure><p id="9eab" class="pw-post-body-paragraph jk jl hi jm b jn kl jp jq jr km jt ju jv lu jx jy jz lv kb kc kd lw kf kg kh hb bi translated">虽然我可以看到分层路由的好处，但我不明白为什么throws语句要包装路由，为什么它们需要包装彼此(事实上它们不需要包装，但缺乏文档使这很难弄清楚)。</p><h2 id="9684" class="lg in hi bd io lh li lj is lk ll lm iw jv ln lo ja jz lp lq je kd lr ls ji lt bi translated">好人</h2><p id="be61" class="pw-post-body-paragraph jk jl hi jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh hb bi translated">生成的文档看起来不错:</p><figure class="ly lz ma mb fd ij er es paragraph-image"><div role="button" tabindex="0" class="mc md di me bf mf"><div class="er es mi"><img src="../Images/c1b2a4f5ffcbbb4081db2b15a8afdffa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*aZm0TAisZiqihJjK-O-WIA.png"/></div></div></figure><p id="a1c9" class="pw-post-body-paragraph jk jl hi jm b jn kl jp jq jr km jt ju jv lu jx jy jz lv kb kc kd lw kf kg kh hb bi translated">是开源的！</p><p id="0517" class="pw-post-body-paragraph jk jl hi jm b jn kl jp jq jr km jt ju jv lu jx jy jz lv kb kc kd lw kf kg kh hb bi translated">也就是说，我分叉了这个项目，并开始消除一些缺点:【https://github.com/1gravity/Ktor-OpenAPI-Generator<a class="ae ki" href="https://github.com/1gravity/Ktor-OpenAPI-Generator" rel="noopener ugc nofollow" target="_blank"/>。</p><p id="022d" class="pw-post-body-paragraph jk jl hi jm b jn kl jp jq jr km jt ju jv lu jx jy jz lv kb kc kd lw kf kg kh hb bi translated">首先，我改变了异常处理，使层次变平。APIExceptionBuilder可用于构建一个异常(使用Builder模式时，属性是可选的)，而不是具有不同签名的多个扩展函数:</p><figure class="ly lz ma mb fd ij"><div class="bz dy l di"><div class="mg mh l"/></div></figure><p id="0f9b" class="pw-post-body-paragraph jk jl hi jm b jn kl jp jq jr km jt ju jv lu jx jy jz lv kb kc kd lw kf kg kh hb bi translated">其次，我将exception作为参数添加到route函数中，这样就可以将异常定义传递到路由定义中，而不是将路由包装到throws调用中:</p><figure class="ly lz ma mb fd ij"><div class="bz dy l di"><div class="mg mh l"/></div></figure><p id="950d" class="pw-post-body-paragraph jk jl hi jm b jn kl jp jq jr km jt ju jv lu jx jy jz lv kb kc kd lw kf kg kh hb bi translated">我计划取消构造函数调用，用一个使用路由构建器的DSL来代替它，以得到这样的结构:</p><figure class="ly lz ma mb fd ij"><div class="bz dy l di"><div class="mg mh l"/></div></figure><p id="55b6" class="pw-post-body-paragraph jk jl hi jm b jn kl jp jq jr km jt ju jv lu jx jy jz lv kb kc kd lw kf kg kh hb bi translated">另一个想法是完全废弃这个新的DSL，并围绕常规的Ktor路由编写扩展函数或包装器，将其用作一个插件，使Ktor开发人员易于采用。</p><p id="cef7" class="pw-post-body-paragraph jk jl hi jm b jn kl jp jq jr km jt ju jv lu jx jy jz lv kb kc kd lw kf kg kh hb bi translated">请和我一起参加https://github.com/1gravity/Ktor-OpenAPI-Generator<a class="ae ki" href="https://github.com/1gravity/Ktor-OpenAPI-Generator" rel="noopener ugc nofollow" target="_blank">的</a>活动，让这一切成为现实！</p><p id="36f3" class="pw-post-body-paragraph jk jl hi jm b jn kl jp jq jr km jt ju jv lu jx jy jz lv kb kc kd lw kf kg kh hb bi translated">像往常一样，请不要犹豫，提供反馈和快乐编码！</p></div></div>    
</body>
</html>