<html>
<head>
<title>Multi Cron Job with “Distributed lock” using MYSQL</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用 MYSQL 的带“分布式锁”的多 Cron 作业</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/multi-cron-job-with-distributed-lock-using-mysql-9e89de4aa1b9?source=collection_archive---------5-----------------------#2021-04-30">https://medium.com/nerd-for-tech/multi-cron-job-with-distributed-lock-using-mysql-9e89de4aa1b9?source=collection_archive---------5-----------------------#2021-04-30</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/89f4fb36ebf532b04de975a6af0d5f11.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*-Dl9BBNd56mEZP2T"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">归功于亚历山大·埃伦霍弗(<a class="ae iu" href="https://unsplash.com/photos/yI4pFmN9ges" rel="noopener ugc nofollow" target="_blank">https://unsplash.com/photos/yI4pFmN9ges</a>)</figcaption></figure><p id="1885" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">几分钟前，我想知道我们是否有运行相同二进制文件的多个 cron 作业，但我们需要确保每个作业/任务进程只由一个实例运行，有没有办法实现这一点。我知道这很奇怪，为什么我们要有多个二进制文件呢？只需为 cron 作业创建一个即可！虽然这是对的，但我想知道这个问题，如果我们可以用 MYSQL 做到这一点，我会被触发，而<strong class="ix hj">可以</strong>。</p><h1 id="b288" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">给出问题陈述和解决方案</h1><p id="c1b9" class="pw-post-body-paragraph iv iw hi ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated">总而言之，挑战在这里</p><ol class=""><li id="563d" class="kw kx hi ix b iy iz jc jd jg ky jk kz jo la js lb lc ld le bi translated">您有多个运行 cron 的二进制文件，它可以在您指定的时间运行多个作业(每 5 点钟、每两分钟、每一小时等等)</li><li id="0853" class="kw kx hi ix b iy lf jc lg jg lh jk li jo lj js lb lc ld le bi translated">你需要确定<strong class="ix hj">每个工作/任务</strong>是否“在同一时间”只能被<strong class="ix hj">一个二进制/进程</strong>处理</li><li id="00c4" class="kw kx hi ix b iy lf jc lg jg lh jk li jo lj js lb lc ld le bi translated">利用 Mysql 实现类似“分布式锁”的机制</li></ol><p id="d03a" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">想到的解决方案</p><ol class=""><li id="3d0b" class="kw kx hi ix b iy iz jc jd jg ky jk kz jo la js lb lc ld le bi translated">每一对作业及其运行时间都应该用一个<strong class="ix hj">唯一键</strong>标记/标注</li><li id="f859" class="kw kx hi ix b iy lf jc lg jg lh jk li jo lj js lb lc ld le bi translated">通过利用 Mysql 中<strong class="ix hj">唯一键约束</strong>来使用这些键</li><li id="0f9b" class="kw kx hi ix b iy lf jc lg jg lh jk li jo lj js lb lc ld le bi translated">任何由另一个具有<strong class="ix hj">相同键的 cron 触发的作业/任务将被拒绝</strong>(不处理)，只有第一个被触发的作业/任务将被处理。</li></ol><p id="1f40" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">免责声明首先</strong>，说明这并不完全是一种分布式锁机制，重点是同一时间只有一个东西可以运行同一任务。因此，只有一个人可以获得“锁”，但不需要“释放锁”。所以我们把“获取锁”的调用改为“<strong class="ix hj">获取权限</strong>”。“获得许可”的人可以运行该流程，否则不能。</p><h1 id="1104" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">克朗</h1><figure class="lk ll lm ln fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/1b922cd9a47f93ebf0a65b96b36eda8b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*d_20Alzd1GYSLNan"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">尹英松(<a class="ae iu" href="https://unsplash.com/photos/w2JtIQQXoRU" rel="noopener ugc nofollow" target="_blank">https://unsplash.com/photos/w2JtIQQXoRU</a>)的功劳</figcaption></figure><p id="5d5a" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">例如，假设我们有一个 cron 运行这些:</p><ol class=""><li id="1f51" class="kw kx hi ix b iy iz jc jd jg ky jk kz jo la js lb lc ld le bi translated">RemoveExpiredUserCart(每天凌晨 01:00 运行)</li><li id="f883" class="kw kx hi ix b iy lf jc lg jg lh jk li jo lj js lb lc ld le bi translated">提醒用户购买通知(每 1 小时运行一次)</li></ol><p id="310a" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">出于某种原因，你可能会在多个 pod 或多个 VM 实例中运行由这些 cron 组成的二进制文件。</p><h1 id="3649" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">获取许可流程</h1><p id="e139" class="pw-post-body-paragraph iv iw hi ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated">那么我们要怎么做呢？该过程包含以下步骤</p><ol class=""><li id="4ced" class="kw kx hi ix b iy iz jc jd jg ky jk kz jo la js lb lc ld le bi translated">创建一个只包含一列的表(即"<strong class="ix hj"> job_list </strong>")。以类型为<strong class="ix hj"> VARCHAR (100) </strong>的列<strong class="ix hj"> job_key </strong>为例。将此键设置为唯一的(为列添加约束)</li><li id="8c4b" class="kw kx hi ix b iy lf jc lg jg lh jk li jo lj js lb lc ld le bi translated">对于每个与其运行时间配对的任务/作业，以字符串形式创建一个唯一的组合键</li><li id="550b" class="kw kx hi ix b iy lf jc lg jg lh jk li jo lj js lb lc ld le bi translated">将这个键插入到我们的“jobs_list”表中，如果检测到它是重复的，就什么也不做</li></ol><p id="4d97" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">通过这两个步骤，我们确保<strong class="ix hj">只有一个键被插入</strong>，因此<strong class="ix hj">只有一个逻辑/二进制将运行任务</strong>。</p><p id="e566" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">例如，以下是可能适合作为唯一标识符的键(唯一键):</p><ol class=""><li id="ec9f" class="kw kx hi ix b iy iz jc jd jg ky jk kz jo la js lb lc ld le bi translated">RemoveExpiredUserCart process | key(string)= " exp _ usr _ cart:<date_pattern>" | example:"<strong class="ix hj">exp _ usr _ cart:15–01–2021</strong></date_pattern></li><li id="6dc4" class="kw kx hi ix b iy lf jc lg jg lh jk li jo lj js lb lc ld le bi translated">reminderuserbuynnotification process | key(string)= " rmnd _ usr _ buy _ notif:<timestamp_until_hour>" | example:"<strong class="ix hj">rmn _ usr _ buy _ notif:15–01–2021:15</strong>"(如果在 15.00，或者 15.20 或者 15.13，基本上所有的 3PM 都转换成 15)或者"<strong class="ix hj">rmn _ usr _ buy _ notif:15–01–2021:23【T11</strong></timestamp_until_hour></li></ol><p id="d538" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">选择用户购物车唯一键是因为它每天运行一次，所以日期(年-月-日)应该足以确定它的唯一性(例如，如果我们有 3 个 crons，当在同一天运行时，所有的都将使用相同的日期)。</p><p id="bad3" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">对于用户提醒通知，由于它是每小时一次，我们需要将唯一性细化到小时细节(15 →下午 3 点，或 23 →晚上 11 点)左右。由于假定 Cron A 在 15.01 运行，Cron B 在 15.02 运行→ <em class="lo">,这两个分钟将被视为一个在下午 3 点运行的进程== </em> cron，因此使用相同的关键字 exp _ usr _ cart:15–01–2021:15<strong class="ix hj">。</strong></p><p id="8ef5" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在获得惟一键之后，我们将使用这个查询在表("<strong class="ix hj"> job_list </strong>")上执行插入操作。</p><blockquote class="lp lq lr"><p id="72cd" class="iv iw lo ix b iy iz ja jb jc jd je jf ls jh ji jj lt jl jm jn lu jp jq jr js hb bi translated"><strong class="ix hj">在重复键上插入 job_list (job_key)值(&lt;your _ cron _ task _ KEY&gt;’)更新 job_key = job_key </strong></p></blockquote><p id="d3e0" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">流程详情:</p><ol class=""><li id="fda7" class="kw kx hi ix b iy iz jc jd jg ky jk kz jo la js lb lc ld le bi translated">我们将把密钥插入表中，以“标记”该进程正在请求运行许可，并将其记录到表中</li><li id="1dfe" class="kw kx hi ix b iy lf jc lg jg lh jk li jo lj js lb lc ld le bi translated">如果键是重复的(相同的作业键已经被另一个进程首先插入)，将 job_key 更新为它自己的值(在 MYSQL 中也称为不更新它的值)</li><li id="83f1" class="kw kx hi ix b iy lf jc lg jg lh jk li jo lj js lb lc ld le bi translated">Mysql 将返回更新/受影响/插入的行数，如果大于零，则意味着我们是第一个成功获得权限然后运行流程的作业，否则(零行受影响)意味着我们未能获得权限，因此只返回或不运行下一个流程。</li></ol><p id="61c3" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">简化的流程可以画成这样:</p><figure class="lk ll lm ln fd ij er es paragraph-image"><div class="er es lv"><img src="../Images/de4ebccb4ae15b1c8cdac47bf8556001.png" data-original-src="https://miro.medium.com/v2/resize:fit:852/format:webp/1*rqRRGXMTg9IDeSZO3Ay6rQ.png"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">3 Cron，每个都有两个作业(A 和 B)，使用 KeyJobATimestamp 的查询更新，只有一个得到了更新的行(受影响)&gt; 0，这是红色的一个</figcaption></figure><p id="2ca0" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">只有一个作业 A 将与另一个作业 A 一起运行(cron 1 和 2)未能获得权限。它之所以有效，是因为 MYSQL 防止了键插入和更新的重复，即使有这么多实例/ pods 运行相同的二进制文件，它也是安全的(注意，选择正确的唯一键对于防止多台机器在相同的“时间范围”运行相同的作业非常重要)。还要记住，对于任何未使用的旧键，我们需要删除表中的旧键。</p><p id="417b" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">希望对你有用，感谢阅读，祝你愉快:)</strong></p></div></div>    
</body>
</html>