<html>
<head>
<title>Recover Binary Search Tree [Leetcode 99]</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">恢复二叉查找树[Leetcode 99]</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/recover-binary-search-tree-leetcode-99-7faf94241044?source=collection_archive---------1-----------------------#2022-05-30">https://medium.com/nerd-for-tech/recover-binary-search-tree-leetcode-99-7faf94241044?source=collection_archive---------1-----------------------#2022-05-30</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="59f5" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">Leetcode问题，树问题，递归</h2></div><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ix"><img src="../Images/a5baba55f769750b617f6f5b1f8945be.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vPQmdoS1IaGyG9CTos14kw.jpeg"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">约翰尼斯·普莱尼奥在Unsplash<a class="ae jn" href="https://unsplash.com/s/photos/binary-tree?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">拍摄的照片</a></figcaption></figure><p id="6aa7" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">这篇文章旨在解决恢复二叉查找树Leetcode 99问题</p><h1 id="17c6" class="kk kl hi bd km kn ko kp kq kr ks kt ku io kv ip kw ir kx is ky iu kz iv la lb bi translated">问题陈述</h1><p id="7981" class="pw-post-body-paragraph jo jp hi jq b jr lc ij jt ju ld im jw jx le jz ka kb lf kd ke kf lg kh ki kj hb bi translated">给你一个二叉查找树(BST)的<code class="du lh li lj lk b">root</code>，其中<strong class="jq hj">的值正好是</strong>树的两个节点被错误地交换了。<em class="ll">恢复树而不改变其结构</em>。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es lm"><img src="../Images/95e4c18a0ec85b023dfb93dd1b58d72a.png" data-original-src="https://miro.medium.com/v2/resize:fit:844/format:webp/1*pPz-aBOrtvSJJiDMoX8RHw.jpeg"/></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">源Leetcode</figcaption></figure><h1 id="5a85" class="kk kl hi bd km kn ko kp kq kr ks kt ku io kv ip kw ir kx is ky iu kz iv la lb bi translated">示例1</h1><pre class="iy iz ja jb fd ln lk lo lp aw lq bi"><span id="4a69" class="lr kl hi lk b fi ls lt l lu lv"><strong class="lk hj">Input:</strong> [10,5,15,6]<br/>    10   <br/>   /  \<br/>  5    15   <br/> /<br/>6 <br/>  <br/><strong class="lk hj">Output:</strong> [10,6,15,5]<br/>    10   <br/>   /  \<br/>  6   15   <br/> /<br/>5</span></pre><h1 id="b4f7" class="kk kl hi bd km kn ko kp kq kr ks kt ku io kv ip kw ir kx is ky iu kz iv la lb bi translated">示例2</h1><pre class="iy iz ja jb fd ln lk lo lp aw lq bi"><span id="89c9" class="lr kl hi lk b fi ls lt l lu lv"><strong class="lk hj">Input:</strong> [3,1,4,null,null,2]   <br/>  3  <br/> / \ <br/>1   4    <br/>   /   <br/>  2 <br/><strong class="lk hj">Output:</strong> [2,1,4,null,null,3]   <br/>  2  <br/> / \ <br/>1   4    <br/>   /   <br/>  3</span></pre></div><div class="ab cl lw lx gp ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="hb hc hd he hf"><blockquote class="md me mf"><p id="53ca" class="jo jp ll jq b jr js ij jt ju jv im jw mg jy jz ka mh kc kd ke mi kg kh ki kj hb bi translated"><strong class="jq hj"> <em class="hi">如果你正在准备你的技术编码面试，或者你想学习递归来提高你解决问题的技能，那么你应该查看这个udemy课程</em> </strong> <a class="ae jn" href="https://www.udemy.com/course/master-the-recursion-from-beginner-to-advance-level/?referralCode=75F57675BDABF6D104C0" rel="noopener ugc nofollow" target="_blank"> <strong class="jq hj">递归大师班，从C++ </strong> </a> <strong class="jq hj"> <em class="hi">的初级到高级水平，或者你可以在</em></strong><a class="ae jn" href="https://skl.sh/3PTOCns" rel="noopener ugc nofollow" target="_blank"><strong class="jq hj"><em class="hi">Skillshare</em></strong></a><strong class="jq hj"><em class="hi">上查看这个递归课程。</em> </strong></p><p id="3ec0" class="jo jp ll jq b jr js ij jt ju jv im jw mg jy jz ka mh kc kd ke mi kg kh ki kj hb bi translated"><strong class="jq hj"> <em class="hi">如果你想从初学者到专家水平学习ARKit 3，那么点击</em> </strong> <a class="ae jn" href="https://www.udemy.com/course/ios-13-swift-5-the-complete-arkit-3-course/?referralCode=7A726FE5CBCEF5839185" rel="noopener ugc nofollow" target="_blank"> <strong class="jq hj"> <em class="hi">这里</em> </strong> </a> <strong class="jq hj"> <em class="hi">获得课程，你还将获得97%的折扣。</em>T44】</strong></p><p id="1b83" class="jo jp ll jq b jr js ij jt ju jv im jw mg jy jz ka mh kc kd ke mi kg kh ki kj hb bi translated"><strong class="jq hj"> <em class="hi">如果你对学习iOS移动开发充满热情，并希望将你的iOS开发技能提升到一个新的水平，那么使用CloudKit framework的核心数据应该是你的首选。点击</em> </strong> <a class="ae jn" href="https://www.udemy.com/course/mastering-coredata-with-cloudkit-in-swift-5-for-ios/?couponCode=FORDEVS" rel="noopener ugc nofollow" target="_blank"> <strong class="jq hj"> <em class="hi">此处</em> </strong> </a> <strong class="jq hj"> <em class="hi">获取课程，您还将获得97%的折扣。</em> </strong></p><p id="9252" class="jo jp ll jq b jr js ij jt ju jv im jw mg jy jz ka mh kc kd ke mi kg kh ki kj hb bi translated"><strong class="jq hj"> <em class="hi">从头开始学习SwiftUI点击</em> </strong> <a class="ae jn" href="https://www.udemy.com/course/swiftui-the-complete-course-building-real-world-apps/?couponCode=FORCODERS" rel="noopener ugc nofollow" target="_blank"> <strong class="jq hj"> <em class="hi">此处</em> </strong> </a> <strong class="jq hj"> <em class="hi">获取课程，因为在本课程中，我们将使用SwiftUI构建许多应用，如脸书克隆、新闻应用、笔记应用等等。</em>T13】</strong></p></blockquote></div><div class="ab cl lw lx gp ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="hb hc hd he hf"><h1 id="999b" class="kk kl hi bd km kn mj kp kq kr mk kt ku io ml ip kw ir mm is ky iu mn iv la lb bi translated">强力方法</h1><p id="5afe" class="pw-post-body-paragraph jo jp hi jq b jr lc ij jt ju ld im jw jx le jz ka kb lf kd ke kf lg kh ki kj hb bi translated">首先，我们将创建一个向量，我们将按顺序遍历树(您可以使用任何遍历算法)，我们将推回向量中的元素，然后我们将按升序对向量进行排序。</p><p id="e63b" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">之后，我们将再次遍历树，我们将使用向量值更改树的值，但这一次我们必须以有序的方式遍历，因为二叉查找树由小于左侧节点的元素和大于右侧节点的元素组成，有序遍历将使元素按<strong class="jq hj">升序排列。</strong></p><h1 id="0d87" class="kk kl hi bd km kn ko kp kq kr ks kt ku io kv ip kw ir kx is ky iu kz iv la lb bi translated">暴力方法的代码</h1><pre class="iy iz ja jb fd ln lk lo lp aw lq bi"><span id="97fa" class="lr kl hi lk b fi ls lt l lu lv">class Solution {<br/>public:</span><span id="701c" class="lr kl hi lk b fi mo lt l lu lv">vector&lt;int&gt; v;</span><span id="da41" class="lr kl hi lk b fi mo lt l lu lv">void solve(TreeNode* root) {<br/>        if(root == NULL) {<br/>            return;<br/>        }<br/>        solve(root-&gt;left);<br/>        v.push_back(root-&gt;val);<br/>        solve(root-&gt;right);<br/>    }</span><span id="d42c" class="lr kl hi lk b fi mo lt l lu lv">int i = 0;<br/>    void inOrderTraversal(TreeNode* root) {<br/>        if(root == NULL) {<br/>            return;<br/>        }<br/>        inOrderTraversal(root-&gt;left);<br/>        root-&gt;val = v[i];<br/>        i++;<br/>        inOrderTraversal(root-&gt;right);<br/>    }<br/>    <br/>    void recoverTree(TreeNode* root) {<br/>        solve(root);<br/>        sort(v.begin(), v.end());<br/>        inOrderTraversal(root);<br/>    }<br/>};</span></pre><h1 id="6865" class="kk kl hi bd km kn ko kp kq kr ks kt ku io kv ip kw ir kx is ky iu kz iv la lb bi translated">蛮力方法时间和空间复杂性</h1><p id="dcfe" class="pw-post-body-paragraph jo jp hi jq b jr lc ij jt ju ld im jw jx le jz ka kb lf kd ke kf lg kh ki kj hb bi translated"><strong class="jq hj">时间复杂度:O(n) </strong></p><p id="982e" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><strong class="jq hj">空间复杂度:O(n) </strong></p></div><div class="ab cl lw lx gp ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="hb hc hd he hf"><h1 id="7024" class="kk kl hi bd km kn mj kp kq kr mk kt ku io ml ip kw ir mm is ky iu mn iv la lb bi translated">最佳方法</h1><p id="e954" class="pw-post-body-paragraph jo jp hi jq b jr lc ij jt ju ld im jw jx le jz ka kb lf kd ke kf lg kh ki kj hb bi translated">在强力方法中，空间复杂度是O(n)我们必须做得更好，如果你认为在这个问题中只有两个节点被交换， 我们能做的是以有序的方式遍历树，创建一个先前的节点，并将值设置为空，之后我们将遍历树，并将当前节点值与先前节点值进行比较。如果先前节点不为空，并且先前节点值大于当前节点值，那么我们可以将先前节点和当前节点推回到我们的对向量中，因为这是被交换的节点。</p><p id="25c5" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">我们的数组中有所有这样的对。数组大小将是1或2不超过2，因为只有两个节点被交换。如果数组大小为1，这意味着只有两个相邻的节点被交换，否则数组大小将为2。</p><p id="a9b6" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">因此，我们必须相应地交换数字，以回到原来的树。</p><h1 id="e8e1" class="kk kl hi bd km kn ko kp kq kr ks kt ku io kv ip kw ir kx is ky iu kz iv la lb bi translated">最佳进场代码</h1><pre class="iy iz ja jb fd ln lk lo lp aw lq bi"><span id="c04b" class="lr kl hi lk b fi ls lt l lu lv">class Solution {<br/>public:</span><span id="15b1" class="lr kl hi lk b fi mo lt l lu lv">TreeNode* prev = NULL;<br/>vector&lt;pair&lt;TreeNode*, TreeNode*&gt;&gt; v;</span><span id="4537" class="lr kl hi lk b fi mo lt l lu lv">void solve(TreeNode* root) {<br/>        if(root == NULL) {<br/>            return;<br/>        }<br/>        <br/>        solve(root-&gt;left);<br/>        if(prev != NULL) {<br/>            if(prev-&gt;val &gt; root-&gt;val) {<br/>                v.push_back(make_pair(root, prev));<br/>            }<br/>        }<br/>        prev = root;<br/>        solve(root-&gt;right);<br/>    }<br/>    <br/>    void recoverTree(TreeNode* root) {<br/>        solve(root);<br/>        if(v.size() == 1) {<br/>            swap(v[0].first-&gt;val, v[0].second-&gt;val);<br/>        } else {<br/>            swap(v[0].second-&gt;val, v[1].first-&gt;val);    <br/>        }<br/>        <br/>    }<br/>};</span></pre><h1 id="5552" class="kk kl hi bd km kn ko kp kq kr ks kt ku io kv ip kw ir kx is ky iu kz iv la lb bi translated">最优进场时间和空间复杂度</h1><p id="43e7" class="pw-post-body-paragraph jo jp hi jq b jr lc ij jt ju ld im jw jx le jz ka kb lf kd ke kf lg kh ki kj hb bi translated"><strong class="jq hj">时间复杂度:O(n) </strong></p><p id="3f2f" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><strong class="jq hj">空间复杂度:O(1) //我们不考虑堆栈空间</strong></p></div><div class="ab cl lw lx gp ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="hb hc hd he hf"><h1 id="2899" class="kk kl hi bd km kn mj kp kq kr mk kt ku io ml ip kw ir mm is ky iu mn iv la lb bi translated">结论</h1><p id="c72e" class="pw-post-body-paragraph jo jp hi jq b jr lc ij jt ju ld im jw jx le jz ka kb lf kd ke kf lg kh ki kj hb bi translated">这件作品到此为止。我希望你喜欢这篇文章，并且你已经学会了如何解决三个问题。</p></div><div class="ab cl lw lx gp ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="hb hc hd he hf"><h1 id="2b5a" class="kk kl hi bd km kn mj kp kq kr mk kt ku io ml ip kw ir mm is ky iu mn iv la lb bi translated">额外资源</h1><blockquote class="md me mf"><p id="050d" class="jo jp ll jq b jr js ij jt ju jv im jw mg jy jz ka mh kc kd ke mi kg kh ki kj hb bi translated"><strong class="jq hj"> <em class="hi">如果你正在准备你的技术编码面试，或者你想学习递归来提高你解决问题的技能，那么你应该查看这个udemy课程</em> </strong> <a class="ae jn" href="https://www.udemy.com/course/master-the-recursion-from-beginner-to-advance-level/?referralCode=75F57675BDABF6D104C0" rel="noopener ugc nofollow" target="_blank"> <strong class="jq hj">递归大师班，从C++ </strong> </a> <strong class="jq hj"> <em class="hi">的初级到高级水平，或者你可以在</em></strong><a class="ae jn" href="https://skl.sh/3PTOCns" rel="noopener ugc nofollow" target="_blank"><strong class="jq hj"><em class="hi">skill share</em></strong></a><strong class="jq hj"><em class="hi">上查看这个递归课程。</em> </strong></p><p id="4e09" class="jo jp ll jq b jr js ij jt ju jv im jw mg jy jz ka mh kc kd ke mi kg kh ki kj hb bi translated"><strong class="jq hj">如果你想从初学者到专家水平学习ARKit 3，那么点击</strong> <a class="ae jn" href="https://www.udemy.com/course/ios-13-swift-5-the-complete-arkit-3-course/?couponCode=FORCREATOR" rel="noopener ugc nofollow" target="_blank"> <strong class="jq hj">这里</strong> </a> <strong class="jq hj">获得课程，你还将获得97%的折扣。</strong></p><p id="6bb2" class="jo jp ll jq b jr js ij jt ju jv im jw mg jy jz ka mh kc kd ke mi kg kh ki kj hb bi translated"><strong class="jq hj">如果你对学习iOS移动开发充满热情，并希望将你的iOS开发技能提升到一个新的水平，那么使用CloudKit framework的核心数据应该是你的首选。点击</strong> <a class="ae jn" href="https://www.udemy.com/course/mastering-coredata-with-cloudkit-in-swift-5-for-ios/?couponCode=FORDEVS" rel="noopener ugc nofollow" target="_blank"> <strong class="jq hj">此处</strong> </a> <strong class="jq hj">获取课程，您还将获得97%的折扣。</strong></p><p id="ecae" class="jo jp ll jq b jr js ij jt ju jv im jw mg jy jz ka mh kc kd ke mi kg kh ki kj hb bi translated"><strong class="jq hj">从头开始学习SwiftUI点击</strong> <a class="ae jn" href="https://www.udemy.com/course/swiftui-the-complete-course-building-real-world-apps/?couponCode=FORCODERS" rel="noopener ugc nofollow" target="_blank"> <strong class="jq hj">此处</strong> </a> <strong class="jq hj">获取课程，因为在本课程中，我们将使用SwiftUI构建许多应用，如脸书克隆、新闻应用、笔记应用等等。</strong></p></blockquote></div></div>    
</body>
</html>