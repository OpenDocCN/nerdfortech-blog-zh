<html>
<head>
<title>Java Virtual Machine: Anatomy</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Java 虚拟机:剖析</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/java-virtual-machine-anatomy-196638478e50?source=collection_archive---------3-----------------------#2021-10-10">https://medium.com/nerd-for-tech/java-virtual-machine-anatomy-196638478e50?source=collection_archive---------3-----------------------#2021-10-10</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="d643" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Java 是当今世界使用最广泛的技术平台之一。使用 java 或 JVM 的一些技术有。</p><ul class=""><li id="7e53" class="jd je hi ih b ii ij im in iq jf iu jg iy jh jc ji jj jk jl bi translated"><strong class="ih hj"> Apache spark </strong>用于大数据处理，数据分析运行在 JVM 之上。</li><li id="acb5" class="jd je hi ih b ii jm im jn iq jo iu jp iy jq jc ji jj jk jl bi translated"><strong class="ih hj">用于数据流的 Apache nifi </strong>在内部使用 JVM。</li><li id="03fa" class="jd je hi ih b ii jm im jn iq jo iu jp iy jq jc ji jj jk jl bi translated"><strong class="ih hj"> React native </strong>在现代 web 和移动应用开发中使用 JVM 和 java 线程。</li></ul><p id="e252" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这个清单还在继续。</p><figure class="js jt ju jv fd jw er es paragraph-image"><div role="button" tabindex="0" class="jx jy di jz bf ka"><div class="er es jr"><img src="../Images/935fa5b2350305314d9f2c4ff46ccd24.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iK1EFamgj6pjOvuhROEFNA.jpeg"/></div></div></figure><p id="31b2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">虚拟化</strong></p><p id="e4f8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">JVM 基于<strong class="ih hj">虚拟化技术</strong>(应用级虚拟化)，它基本上是裸机硬件之上的一个抽象层。</p><figure class="js jt ju jv fd jw er es paragraph-image"><div role="button" tabindex="0" class="jx jy di jz bf ka"><div class="er es kd"><img src="../Images/b57041fa5e286541b298aff37169ad58.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Obz5bC1Iz26lqL5P-U6kSA.png"/></div></div><figcaption class="ke kf et er es kg kh bd b be z dx translated">传统计算机与虚拟机</figcaption></figure><p id="6747" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">JVM 是应用程序级虚拟化的一个例子，它基本上是主机操作系统上的一个额外的层。我们可以在操作系统内部的沙箱中编译和运行 java 程序，而不是直接使用操作系统例程。</p><p id="a73f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">代码编译和字节码</strong></p><p id="7490" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Java 代码在执行前要经过一系列转换。第一个编译过程从 java 编译器或<strong class="ih hj"> javac </strong>开始。javac 将 java 代码转换成中间字节码，可以使用 javap 等<strong class="ih hj">反汇编器</strong>工具读取，字节码独立于机器架构，这就是 java 编程语言可移植性的原因。</p><p id="70de" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">类解剖学</strong></p><p id="4538" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">以下是使用<strong class="ih hj"> javap 反汇编后的类文件的组件。</strong></p><figure class="js jt ju jv fd jw er es paragraph-image"><div role="button" tabindex="0" class="jx jy di jz bf ka"><div class="er es ki"><img src="../Images/766690097ca96cb0965ead3cbcf3bf66.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cT9GYhYJSsm0G-JXj9ozAA.png"/></div></div><figcaption class="ke kf et er es kg kh bd b be z dx translated">类文件组件</figcaption></figure><p id="e19a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">每个类文件都以一个神奇的数字开始，这是给定文件是类文件的确认，接下来是类格式的版本，用于检查 JVM 版本和用于编译类文件的版本的兼容性。如果有任何不匹配，将抛出一个<em class="kj">unsupportdclassversionerror</em>。</p><p id="8b32" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">其他组件用于存储类中使用的常量，访问标志存储访问说明符(公共、私有、抽象等)。类似地，其他组件存储超类的名称、类中使用的接口和方法。</p><pre class="js jt ju jv fd kk kl km kn aw ko bi"><span id="cd8c" class="kp kq hi kl b fi kr ks l kt ku">public class HelloWorld {<br/>  public static void main(String[] args) {<br/>    for (int i = 0; i &lt; 10; i++) {<br/>      System.out.println("Hello World");<br/>    }<br/>  }<br/>}</span><span id="e141" class="kp kq hi kl b fi kv ks l kt ku">javac HelloWorld.java</span><span id="e486" class="kp kq hi kl b fi kv ks l kt ku">javap -v HelloWorld</span></pre><p id="d160" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">反汇编上面的 hello world 程序，结果如下</p><pre class="js jt ju jv fd kk kl km kn aw ko bi"><span id="9ef9" class="kp kq hi kl b fi kr ks l kt ku">Classfile /home/xxxxxxxx/Documents/learning/java/jvm/HelloWorld.class<br/>  Last modified 7 Oct 2021; size 478 bytes<br/>  SHA-256 checksum 93080c0483aa97ce4c226f31f22ed95c633e0da00b997fe229bfa676f6fb53c0<br/>  Compiled from "HelloWorld.java"<br/>public class HelloWorld<br/>  minor version: 0<br/>  major version: 52<br/>  flags: (0x0021) ACC_PUBLIC, ACC_SUPER<br/>  this_class: #5                          // HelloWorld<br/>  super_class: #6                         // java/lang/Object<br/>  interfaces: 0, fields: 0, methods: 2, attributes: 1</span></pre><p id="411c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">相应的机器语言指令将是。</p><pre class="js jt ju jv fd kk kl km kn aw ko bi"><span id="a7f9" class="kp kq hi kl b fi kr ks l kt ku">0: iconst_0</span><span id="bbe3" class="kp kq hi kl b fi kv ks l kt ku">1: istore_1</span><span id="307b" class="kp kq hi kl b fi kv ks l kt ku">2: iload_1</span><span id="fe7a" class="kp kq hi kl b fi kv ks l kt ku">3: bipush        10</span><span id="7db2" class="kp kq hi kl b fi kv ks l kt ku">5: if_icmpge     22</span><span id="641c" class="kp kq hi kl b fi kv ks l kt ku">8: getstatic     #2                  // Field java/lang/System.out:Ljava/io/PrintStream;</span><span id="5cf4" class="kp kq hi kl b fi kv ks l kt ku">11: ldc           #3                  // String Hello World</span><span id="c9ed" class="kp kq hi kl b fi kv ks l kt ku">13: invokevirtual #4                  // Method java/io/PrintStream.println:(Ljava/lang/String;)V</span><span id="1414" class="kp kq hi kl b fi kv ks l kt ku">16: iinc          1, 1</span><span id="ef71" class="kp kq hi kl b fi kv ks l kt ku">19: goto          2</span><span id="f66e" class="kp kq hi kl b fi kv ks l kt ku">22: return</span></pre><p id="d762" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">解释</strong>:</p><p id="2752" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">将常量存入 JVM 堆栈 load 并与 10 进行比较，如果大于或等于 10，则停止并退出函数 else print " <em class="kj"> Hello world </em>"直到满足条件。</p><p id="4079" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">解释和类加载</strong></p><figure class="js jt ju jv fd jw er es paragraph-image"><div role="button" tabindex="0" class="jx jy di jz bf ka"><div class="er es kw"><img src="../Images/3977d9c07ee65865193af0617c1dc9bb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nYYYc0TzmJkFtKpVt5skfA.png"/></div></div><figcaption class="ke kf et er es kg kh bd b be z dx translated">JVM 架构</figcaption></figure><p id="cb12" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在将给定的源代码转换成字节后，JVM 将开始逐行解释类文件。JVM 是一个基于堆栈的解释器，因此 JVM 将使用内部堆栈来存储执行结果，而不是使用<strong class="ih hj"> CPU 寄存器</strong>。这个过程从将执行所需的所有类加载到方法缓存开始。</p><p id="bf04" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">级装载</strong></p><p id="efbc" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">代码执行中三个重要过程</p><p id="46fb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">加载</strong>:加载所有需要执行的类。</p><p id="4ad0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">链接</strong>:验证类文件，解析所有符号引用。</p><p id="d22a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">初始化</strong>:初始化程序中定义的所有静态变量。</p><p id="7bce" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">类加载器的类型</strong></p><p id="c8be" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> Bootstrap 类加载器:</strong> Bootstrap 类加载器将加载源代码中的所有核心类，包括包含 main 函数的类。</p><p id="2275" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">扩展类加载器:</strong>扩展类加载器以 bootstrap 类作为其父类加载器。如果核心 java 类中的任何方法被覆盖，那么扩展类加载器将加载该类而不是原始类。</p><p id="3a6a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">应用程序类加载器:</strong>加载在类路径中找到的所有类。如果在类路径中找不到类，将抛出一个<em class="kj"> classnotfound </em>异常。</p><p id="3d38" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">热点编译</strong></p><blockquote class="kx ky kz"><p id="54bc" class="if ig kj ih b ii ij ik il im in io ip la ir is it lb iv iw ix lc iz ja jb jc hb bi translated">C++实现遵循零开销原则:不用的东西，不用付钱。此外，你所使用的，你不可能比手工编码更好。</p><p id="cdfc" class="if ig kj ih b ii ij ik il im in io ip la ir is it lb iv iw ix lc iz ja jb jc hb bi translated"><strong class="ih hj">比雅尼·斯特劳斯特鲁普</strong></p><p id="2358" class="if ig kj ih b ii ij ik il im in io ip la ir is it lb iv iw ix lc iz ja jb jc hb bi translated">Java 是一种蓝领语言。这不是博士论文材料，而是一种工作语言。</p><p id="bb4d" class="if ig kj ih b ii ij ik il im in io ip la ir is it lb iv iw ix lc iz ja jb jc hb bi translated"><strong class="ih hj">詹姆斯·高斯林</strong></p></blockquote><p id="34e6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">与 C 和 C++等语言相比，Hotspot 编译是一种使 java 代码执行更快、更高效的方法。热点编译是一种方法，在这种方法中，随着解释过程的进行，分析器将开始收集关于执行的信息，根据这些信息<strong class="ih hj"> Just In Time(JIT) </strong>编译器将应用一组优化。</p><p id="8ed4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> Java 内存分配和内存管理</strong></p><p id="0738" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在 JVM 中运行的所有线程将拥有一个公共堆，运行一个程序所需的所有内存将从这个堆中分配，如果所需内存大于当前 JVM 堆内存，将抛出<strong class="ih hj">内存越界</strong>异常。默认情况下，对象是可变的，除非它们由 final 关键字定义。</p><blockquote class="kx ky kz"><p id="f33d" class="if ig kj ih b ii ij ik il im in io ip la ir is it lb iv iw ix lc iz ja jb jc hb bi translated">一个线程创建的任何对象都可以被另一个线程访问，不希望出现的情况(一个线程引用的内存被另一个线程改变)可以通过一种叫做互斥锁或互斥锁的技术来避免。</p></blockquote><p id="8092" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> JIT 编译</strong></p><p id="9bea" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这个过程也称为轮廓导向优化。配置文件将跟踪当前正在运行的信息子系统，当该值达到某个阈值时，将应用优化设置。一些概要文件引导的优化策略是。</p><p id="674e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">基于计数器的优化:</strong> Profiler 将记录方法被调用的次数。如果计数达到大于某个阈值的值，该方法将被缓存，并且下一次不是再次解释它，而是从缓存中取出值。</p><p id="d697" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">关于栈替换:</strong>不常用但包含循环的缓存方法。</p><p id="b301" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">内联:</strong>例如，它是用更高效的代码进行替换的过程。</p><pre class="js jt ju jv fd kk kl km kn aw ko bi"><span id="2848" class="kp kq hi kl b fi kr ks l kt ku">int result = add(a, b);</span><span id="32ea" class="kp kq hi kl b fi kv ks l kt ku">private int add(int x, int y) {</span><span id="784e" class="kp kq hi kl b fi kv ks l kt ku">return x + y;</span><span id="bdc6" class="kp kq hi kl b fi kv ks l kt ku">}</span></pre><p id="0292" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">上述代码块将被替换为。</p><pre class="js jt ju jv fd kk kl km kn aw ko bi"><span id="52fe" class="kp kq hi kl b fi kr ks l kt ku">int result = a + b;</span></pre><p id="f3c8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">编译器内的热点</strong></p><p id="2c06" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">JIT 编译器内部由两个编译器组成。它们是<strong class="ih hj"> c1 和 c2 </strong>，传统上称为客户端和服务器编译器，当计数器达到特定值时，系统将得到通知，c1 和 c2 编译器将开始为分析信息创建内部表示。但是在 c1 和 c2 编译器之间有一个重要的权衡，c1 将提供更快但不太优化的表示，而 c2 将提供更慢但更优化的表示。</p><p id="5d5f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">JIT 不会等待 c2 表示，而是从 c1 开始，一旦 c2 结束，c1 表示将被 c2 替换。执行流程将如下所示。</p><ul class=""><li id="ccde" class="jd je hi ih b ii ij im in iq jf iu jg iy jh jc ji jj jk jl bi translated"><strong class="ih hj">0 级</strong>:解释器</li><li id="4247" class="jd je hi ih b ii jm im jn iq jo iu jp iy jq jc ji jj jk jl bi translated"><strong class="ih hj">级别 1 </strong>:完全优化的 C1(无分析)</li><li id="ec89" class="jd je hi ih b ii jm im jn iq jo iu jp iy jq jc ji jj jk jl bi translated"><strong class="ih hj">2 级</strong>:带调用和后沿计数器的 C1</li><li id="7ee9" class="jd je hi ih b ii jm im jn iq jo iu jp iy jq jc ji jj jk jl bi translated"><strong class="ih hj">第三级</strong>:全剖析 C1</li></ul><p id="b5e4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">代码缓存</strong></p><p id="d8a8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">所有编译后的代码将存储在<strong class="ih hj">代码缓存</strong>中。缓存主要包含未分配的堆和一个包含内存块的链表。在最初缓存代码时，它将检查是否有空闲的可用块，如果有，它将立即缓存代码，否则它将从堆中分配内存用于缓存。名为<strong class="ih hj"> sweeper </strong>的进程负责管理这些块。</p></div></div>    
</body>
</html>