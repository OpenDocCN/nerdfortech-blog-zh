<html>
<head>
<title>Grid-locked Movement in Unity</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Unity 中的网格锁定运动</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/grid-locked-movement-in-unity-e34146ee8992?source=collection_archive---------2-----------------------#2021-08-26">https://medium.com/nerd-for-tech/grid-locked-movement-in-unity-e34146ee8992?source=collection_archive---------2-----------------------#2021-08-26</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="da2b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">目标:</strong>创建一个将玩家锁定在一个格子里的移动系统。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es jd"><img src="../Images/766ba39ad69e55d274f3ae8df7d9e84a.png" data-original-src="https://miro.medium.com/v2/resize:fit:876/1*QfUAc1POIriqqPObrw5V6w.gif"/></div></figure><p id="ffd7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">假设我们想创建一个类似于<em class="jl">推箱子</em>的推方块游戏。在这样的游戏中，玩家角色被限制为一次向上、向下、向左或向右移动一个棋子。</p><p id="6496" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们需要以下变量:</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es jm"><img src="../Images/9aa7f5259f0601cdb00ded0cb5acf0d2.png" data-original-src="https://miro.medium.com/v2/resize:fit:940/format:webp/1*KbqiI1HKjNSdeCw4m0rVCQ.png"/></div></figure><p id="a149" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="jl">_ 区块遮罩</em>将被设置为检测<em class="jl">区块</em>层上的任何东西；这将包括墙壁和我们必须推动的板条箱。</p><p id="4f38" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="jl"> _destination </em>将被分配给玩家在<em class="jl"> Start </em>方法中的初始位置。</p><p id="680b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在<em class="jl">更新</em>方法中，我们将检查玩家是否非常接近目的地。我们通过计算到<em class="jl">_ 目的地</em>的距离并检查它是否小于<em class="jl"> Mathf 来实现这一点。Epsilon </em>，这是一个非常小的数字(它是一个浮点型可以具有的不为 0 的最小值)。</p><p id="b8bd" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果距离<em class="jl">不是</em>接近 0，我们将移动玩家到目的地，如下图<em class="jl"> else </em>块所示。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es jn"><img src="../Images/544d4157a01409c32c51d8643f693ec8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1272/format:webp/1*4qIBBRIDQNV9KHyiV4DOrw.png"/></div></figure><p id="dec5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果玩家非常接近目的地，我们将执行上面隐藏的<em class="jl">检查方向</em>区域。</p><p id="0c95" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这是我们收集玩家意见的时候。四个方向中的每一个都执行相同的基本代码，将方向传递给<em class="jl"> CheckDirection </em>方法(稍后会详细介绍)。如果该方法返回<em class="jl"> true </em>，我们将付款人的目的地设置在那个方向。如果它返回<em class="jl"> false </em>，那么一定有什么东西阻碍了玩家，我们将忽略他们对这一帧的输入。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es jo"><img src="../Images/ef5eb12eed0097057518330169b56b23.png" data-original-src="https://miro.medium.com/v2/resize:fit:1030/format:webp/1*9MT-r7daeBhA26B6uKDfng.png"/></div></figure><p id="2b8e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在<em class="jl"> CheckDirection </em>方法中，我们将传入要检查的方向。我们将从玩家向我们正在检查的方向投射一束光线，距离为<em class="jl">_ 探测半径</em>，忽略<em class="jl">块</em>层上<em class="jl">而非</em>的任何东西。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es jp"><img src="../Images/f1fb4d6672b4cadbd04397a0603e6c3d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1140/format:webp/1*6lKe5FhsN0cQiwHhSkCQ7Q.png"/></div></figure><p id="0d8e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果光线击中了<em class="jl">块</em>层上的对象，我们将在该对象上寻找<em class="jl">可按下的</em>标签。如果我们找不到它，我们就碰壁了，将返回<em class="jl"> false </em>，不允许玩家朝那个方向移动。如果对象被标记为<em class="jl"> Pushable </em>，我们将调用它的<em class="jl"> Push </em>方法。我们不希望玩家能够移动到<em class="jl">可推</em>的空间，直到<em class="jl">可推</em>本身移动，所以我们将返回<em class="jl"> false </em>。</p><p id="48eb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果光线在<em class="jl">块</em>层上没有发现任何东西，空间是空的，我们将返回<em class="jl">真</em>，允许玩家移动。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jr js di jt bf ju"><div class="er es jq"><img src="../Images/3b8624af02eefaafe0f332399fc6b3aa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Ynx8lccDHOZkHR9xGySRkg.png"/></div></div></figure><p id="c676" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">明天我们将学习如何推积木！</p></div></div>    
</body>
</html>