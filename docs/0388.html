<html>
<head>
<title>Learning Go — Arrays &amp; slices</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">学习围棋—数组和切片</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/learning-go-arrays-slices-bc8106f345e6?source=collection_archive---------4-----------------------#2020-11-20">https://medium.com/nerd-for-tech/learning-go-arrays-slices-bc8106f345e6?source=collection_archive---------4-----------------------#2020-11-20</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/f5bb59682f6053470d75c70cac45c605.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AJAGtpn_f7wMFdcwFn95LA.png"/></div></div></figure><p id="9e62" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在这篇文章中，我将讨论数据类型——数组和切片。</p><h1 id="b4c9" class="jo jp hi bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated"><strong class="ak">数组</strong></h1><p id="a84f" class="pw-post-body-paragraph iq ir hi is b it km iv iw ix kn iz ja jb ko jd je jf kp jh ji jj kq jl jm jn hb bi translated">数组是存储在连续内存位置的数据集合。Go中的数组可以初始化为</p><pre class="kr ks kt ku fd kv kw kx ky aw kz bi"><span id="9a62" class="la jp hi kw b fi lb lc l ld le"><strong class="kw hj">Method 1</strong><br/>&lt;variable&gt; := [size of array] &lt;type&gt; {valueset}<br/>This will initialize an array of size as specified in - &lt;size of array&gt;<br/>grades := [3] int{97, 98, 99}</span><span id="7ac7" class="la jp hi kw b fi lf lc l ld le"><strong class="kw hj">Method 2</strong><br/>&lt;variable&gt; := [...] &lt;type&gt; {valueset}<br/>This will initialize an array with size as in the number of elements in the valueset.<br/>grades := [...] int{97,98, 99, 100}<br/>size - 4</span><span id="560e" class="la jp hi kw b fi lf lc l ld le"><strong class="kw hj">Method 3</strong><br/>var &lt;variable&gt; [size of array] &lt;type&gt;<br/>This is declaration without initialising values.<br/>var grades [3] int<br/>grades[0] = 5<br/>grades[1] = 10</span><span id="88a2" class="la jp hi kw b fi lf lc l ld le">fmt.Printf("Grades : %v", grades)</span><span id="2cac" class="la jp hi kw b fi lf lc l ld le">Result<br/>Grades : [97 98 99]<br/>Grades 2 : [97 98 99 100]<br/>Grades 3 : [5 10 0]</span></pre><h1 id="431e" class="jo jp hi bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated"><strong class="ak">访问特定的索引元素</strong></h1><p id="f730" class="pw-post-body-paragraph iq ir hi is b it km iv iw ix kn iz ja jb ko jd je jf kp jh ji jj kq jl jm jn hb bi translated">和其他语言一样，访问元素非常简单</p><pre class="kr ks kt ku fd kv kw kx ky aw kz bi"><span id="9220" class="la jp hi kw b fi lb lc l ld le">&lt;variable&gt;[&lt;index&gt;]<br/>Access 2nd element from our grades array - grades[1]</span></pre><h1 id="086c" class="jo jp hi bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated"><strong class="ak">数组长度</strong></h1><p id="98a6" class="pw-post-body-paragraph iq ir hi is b it km iv iw ix kn iz ja jb ko jd je jf kp jh ji jj kq jl jm jn hb bi translated">内置函数len()返回数组的大小。</p><pre class="kr ks kt ku fd kv kw kx ky aw kz bi"><span id="64cd" class="la jp hi kw b fi lb lc l ld le">fmt.Printf("Grades : %v has size : %d\n", grades, len(grades))</span><span id="dba7" class="la jp hi kw b fi lf lc l ld le">Result<br/>Grades : [5 10 0] has size : 3</span></pre><h1 id="649d" class="jo jp hi bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated"><strong class="ak"> 2D阵</strong></h1><p id="c191" class="pw-post-body-paragraph iq ir hi is b it km iv iw ix kn iz ja jb ko jd je jf kp jh ji jj kq jl jm jn hb bi translated">2D数组是指数组的数组。它们可以按如下方式初始化</p><pre class="kr ks kt ku fd kv kw kx ky aw kz bi"><span id="068d" class="la jp hi kw b fi lb lc l ld le">var matrix [3][3] int<br/>matrix[0] = [3] int{1, 0, 0}<br/>matrix[1] = [3] int{0, 1, 0}<br/>matrix[2] = [3] int{0, 0, 1}<br/>OR<br/>var matrix [3][3] int = [3][3] int{[3] int{1, 0, 0}, [3] int{0, 1, 0}, [3] int{0, 0, 1}}</span><span id="af14" class="la jp hi kw b fi lf lc l ld le">fmt.Printf("2D matrix : %v\n", matrix)</span><span id="04e9" class="la jp hi kw b fi lf lc l ld le">Result<br/>2D matrix : [[1 0 0] [0 1 0] [0 0 1]]<br/>2D matrix : [[1 0 0] [0 1 0] [0 0 1]]</span><span id="8115" class="la jp hi kw b fi lf lc l ld le">fmt.Printf("2D matrix : %v, no of rows : %d, now of columns : %d\n", matrix, len(matrix), len(matrix[0]))<br/>2D matrix : [[1 0 0] [0 1 0] [0 0 1]], no of rows : 3, now of columns : 3</span></pre><blockquote class="lg lh li"><p id="c123" class="iq ir lj is b it iu iv iw ix iy iz ja lk jc jd je ll jg jh ji lm jk jl jm jn hb bi translated"><strong class="is hj">数组是值类型<br/> </strong>正如我们在Java、C和C++等编程语言中习惯于理解数组是引用类型一样，在Go中情况有所不同。Go中的<strong class="is hj">数组</strong>是<strong class="is hj">值类型</strong>，即它们保存的是值，而不是对该值的内存位置的引用。</p></blockquote><pre class="kr ks kt ku fd kv kw kx ky aw kz bi"><span id="42d0" class="la jp hi kw b fi lb lc l ld le">arrA := [...] int{1, 3, 5}<br/>arrB := arrA<br/>arrB[1] = 6<br/>fmt.Println("arrA : ", arrA)<br/>fmt.Println("arrB : ", arrB)</span><span id="7779" class="la jp hi kw b fi lf lc l ld le">Result<br/>arrA :  [1 3 5]<br/>arrB :  [1 6 5]</span><span id="48aa" class="la jp hi kw b fi lf lc l ld le">The value in arrA[1] did not change even though we updated arrB[1]</span></pre><blockquote class="lg lh li"><p id="743b" class="iq ir lj is b it iu iv iw ix iy iz ja lk jc jd je ll jg jh ji lm jk jl jm jn hb bi translated"><strong class="is hj">注意</strong>:通过给变量赋值将一个数组复制到另一个变量实际上创建了一个新数组。请记住，如果您将一个大数组复制到另一个数组，这在您的代码中可能是致命的。</p></blockquote><h1 id="49aa" class="jo jp hi bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated"><strong class="ak"> &amp;(地址操作符)用于数组引用</strong></h1><p id="d327" class="pw-post-body-paragraph iq ir hi is b it km iv iw ix kn iz ja jb ko jd je jf kp jh ji jj kq jl jm jn hb bi translated">为了通过引用提供Java/C/C++数组副本，Go提供了&amp; operator。</p><pre class="kr ks kt ku fd kv kw kx ky aw kz bi"><span id="5a8e" class="la jp hi kw b fi lb lc l ld le">arrAA := [...] int{1, 3, 5}<br/>arrBB := &amp;arrAA<br/>arrBB[1] = 6<br/>fmt.Println("arrAA : ", arrAA)<br/>fmt.Println("arrBB : ", arrBB)</span><span id="e6d4" class="la jp hi kw b fi lf lc l ld le">Result<br/>arrAA :  [1 6 5]<br/>arrBB :  &amp;[1 6 5]</span></pre></div><div class="ab cl ln lo gp lp" role="separator"><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls"/></div><div class="hb hc hd he hf"><h1 id="9c13" class="jo jp hi bd jq jr lu jt ju jv lv jx jy jz lw kb kc kd lx kf kg kh ly kj kk kl bi translated"><strong class="ak">切片</strong></h1><p id="40dd" class="pw-post-body-paragraph iq ir hi is b it km iv iw ix kn iz ja jb ko jd je jf kp jh ji jj kq jl jm jn hb bi translated">数组适合在类似值类型、随机访问、连续内存位置等情况下使用数据类型。但是它们必须有固定的大小。</p><p id="5fa3" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj"> <em class="lj">从而解决了固定尺寸的问题，将切片变成图片</em> </strong>。它们类似于具有可变长度的强大的轻量级数组数据结构。</p><p id="02df" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">Slice在内部将数据存储在数组中。Slice只是对这个内部数组的引用。</p><pre class="kr ks kt ku fd kv kw kx ky aw kz bi"><span id="1b16" class="la jp hi kw b fi lb lc l ld le">An array is of fixed length. Slice stores a reference to the array. So how does slice manage to be variable length?<br/>When a slice is added a value and the internal array is full, slice initialises a new array.</span></pre><h1 id="5018" class="jo jp hi bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated"><strong class="ak">初始化</strong></h1><pre class="kr ks kt ku fd kv kw kx ky aw kz bi"><span id="33f1" class="la jp hi kw b fi lb lc l ld le"><strong class="kw hj">Method 1</strong><br/>&lt;variable&gt; := [empty] &lt;type&gt; {&lt;initial elements&gt;}<br/>sliceA := [] int{1, 2, 5}<br/>sliceAA := [] int  // is a nil slice with no internal array initialised. has some specific behaviour.</span><span id="a820" class="la jp hi kw b fi lf lc l ld le"><strong class="kw hj">Method 2</strong><br/>arrC := [...] int{1,2,3,4,5,6,7}<br/>sliceB := arrC[2:4]</span><span id="2549" class="la jp hi kw b fi lf lc l ld le">fmt.Printf("sliceA : %v, length of sliceA : %v, capacity of sliceA : %v", sliceA, len(sliceA), cap(sliceA))</span><span id="68b3" class="la jp hi kw b fi lf lc l ld le">Result<br/>sliceA : [1 2 5], length of sliceA : 3, capacity of sliceA : 3</span></pre><h1 id="a6d0" class="jo jp hi bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated"><strong class="ak">切片的容量— cap() </strong></h1><p id="d00d" class="pw-post-body-paragraph iq ir hi is b it km iv iw ix kn iz ja jb ko jd je jf kp jh ji jj kq jl jm jn hb bi translated">除了数组的长度函数，还有一个切片的容量函数。<strong class="is hj">容量是指切片可以容纳的元素数量</strong>。这取决于切片开始的数组的索引。<strong class="is hj">片可以保存从起始索引开始的值，直到内部数组</strong>结束。</p><pre class="kr ks kt ku fd kv kw kx ky aw kz bi"><span id="5688" class="la jp hi kw b fi lb lc l ld le">arrA := [...] int {1,2,3,4,5,6,7}<br/>sliceA := arr[2:4]  // [3, 4]<br/>len(sliceA) = 2<br/>cap(sliceA) = 5  // indices - 2,3,4,5,6</span></pre></div><div class="ab cl ln lo gp lp" role="separator"><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls"/></div><div class="hb hc hd he hf"><h1 id="ca46" class="jo jp hi bd jq jr lu jt ju jv lv jx jy jz lw kb kc kd lx kf kg kh ly kj kk kl bi translated"><strong class="ak">标准内置功能</strong></h1><h2 id="dbcd" class="la jp hi bd jq lz ma mb ju mc md me jy jb mf mg kc jf mh mi kg jj mj mk kk ml bi translated"><strong class="ak"> ### make()函数</strong></h2><pre class="kr ks kt ku fd kv kw kx ky aw kz bi"><span id="0985" class="la jp hi kw b fi lb lc l ld le">makeSlice := make([]int, 4)<br/>makeSlice := make([]int, 4, 100)</span><span id="a2ea" class="la jp hi kw b fi lf lc l ld le">fmt.Printf("makeSlice : %v, length of makeSlice : %v, capacity of makeSlice : %v", makeSlice, len(makeSlice), cap(makeSlice))</span><span id="2954" class="la jp hi kw b fi lf lc l ld le">Result<br/>makeSlice : [0 0 0 0], length of makeSlice : 4, capacity of makeSlice : 4<br/>makeSlice : [0 0 0 0], length of makeSlice : 4, capacity of makeSlice : 100</span></pre><blockquote class="lg lh li"><p id="c5ac" class="iq ir lj is b it iu iv iw ix iy iz ja lk jc jd je ll jg jh ji lm jk jl jm jn hb bi translated"><strong class="is hj">注</strong>:根据论点观察容量差异。您可以使用不同的初始长度0和容量来初始化切片。</p></blockquote><h2 id="cf7d" class="la jp hi bd jq lz ma mb ju mc md me jy jb mf mg kc jf mh mi kg jj mj mk kk ml bi translated"><strong class="ak"> ### append()函数</strong></h2><p id="f06c" class="pw-post-body-paragraph iq ir hi is b it km iv iw ix kn iz ja jb ko jd je jf kp jh ji jj kq jl jm jn hb bi translated">可以通过内部append()函数向slice添加值。<br/>类似于java中的hashmap大小行为，当新元素被添加到hashmap中并且hashmap已满时，hashmap大小以2的顺序递增。</p><pre class="kr ks kt ku fd kv kw kx ky aw kz bi"><span id="ab53" class="la jp hi kw b fi lb lc l ld le">makeSlice := make([]int, 4, 100)<br/>fmt.Printf("makeSlice : %v, length of makeSlice : %v, capacity of makeSlice : %v\n", makeSlice, len(makeSlice), cap(makeSlice))<br/>makeSlice = append(makeSlice, 1, 2, 4, 6)<br/>fmt.Printf("makeSlice : %v, length of makeSlice : %v, capacity of makeSlice : %v\n", makeSlice, len(makeSlice), cap(makeSlice))</span><span id="9f29" class="la jp hi kw b fi lf lc l ld le">Result</span><span id="651c" class="la jp hi kw b fi lf lc l ld le">makeSlice : [0 0 0 0], length of makeSlice : 4, capacity of makeSlice : 100<br/>makeSlice : [0 0 0 0 1 2 4 6], length of makeSlice : 8, capacity of makeSlice : 100</span></pre><p id="6e96" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">用例</strong> <br/>追加在尝试处理以下内容时很方便:</p><ul class=""><li id="ad9e" class="mm mn hi is b it iu ix iy jb mo jf mp jj mq jn mr ms mt mu bi translated">追加两个切片</li><li id="37bf" class="mm mn hi is b it mv ix mw jb mx jf my jj mz jn mr ms mt mu bi translated">final slice = append(make slice 1[0:1]，makeSlice2[4:6]…)</li><li id="04c4" class="mm mn hi is b it mv ix mw jb mx jf my jj mz jn mr ms mt mu bi translated">在单个切片中追加两组数据</li><li id="1108" class="mm mn hi is b it mv ix mw jb mx jf my jj mz jn mr ms mt mu bi translated">final slice = append(make slice[0:2]，makeSlice[4，6]…)</li></ul><blockquote class="lg lh li"><p id="3d8b" class="iq ir lj is b it iu iv iw ix iy iz ja lk jc jd je ll jg jh ji lm jk jl jm jn hb bi translated"><strong class="is hj">注意— </strong>请记住在append()的第二个参数末尾使用扩展运算符(…)</p></blockquote><h2 id="d57e" class="la jp hi bd jq lz ma mb ju mc md me jy jb mf mg kc jf mh mi kg jj mj mk kk ml bi translated"><strong class="ak">不寻常的行为</strong></h2><pre class="kr ks kt ku fd kv kw kx ky aw kz bi"><span id="2ebd" class="la jp hi kw b fi lb lc l ld le">fmt.Println(makeSlice)<br/>newSlice := append(makeSlice[0:2], makeSlice[4:6]...)<br/>fmt.Println(makeSlice)<br/>fmt.Println(newSlice)</span><span id="cc7e" class="la jp hi kw b fi lf lc l ld le">Result</span><span id="78f8" class="la jp hi kw b fi lf lc l ld le">[0 0 0 0 1 2 4 6]  // makeSlice initial<br/>[0 0 1 2 1 2 4 6]  // makeSlice got updated!!! HOW?<br/>[0 0 1 2]  // newSlice</span></pre><blockquote class="lg lh li"><p id="e335" class="iq ir lj is b it iu iv iw ix iy iz ja lk jc jd je ll jg jh ji lm jk jl jm jn hb bi translated"><strong class="is hj">注意</strong>:注意makeSlice在对其中的值进行切片形成newSlice时的异常修改。我们将在后面的帖子中讨论这个问题！！！</p></blockquote><p id="d295" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj"> ### copy()函数<br/> </strong> Go提供了一个内置的<strong class="is hj"> copy() </strong>函数，用于将值从一个片复制到另一个片</p><pre class="kr ks kt ku fd kv kw kx ky aw kz bi"><span id="f216" class="la jp hi kw b fi lb lc l ld le">func copy(dst []Type, src []Type) int<br/>copy (sliceA, sliceB)  // copies value from sliceB to sliceA till length min (sliceA, sliceB)</span></pre><blockquote class="lg lh li"><p id="838b" class="iq ir lj is b it iu iv iw ix iy iz ja lk jc jd je ll jg jh ji lm jk jl jm jn hb bi translated"><strong class="is hj">注意</strong>:如果你在python中遇到过slicing()，那么你将能够在Go的上下文中更好地关联slice</p></blockquote><p id="9114" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">不同类型的切片<br/> </strong>以下是可以创建的各种类型的切片</p><pre class="kr ks kt ku fd kv kw kx ky aw kz bi"><span id="305d" class="la jp hi kw b fi lb lc l ld le">a := [...] int{1,2,3,4,5,6}<br/>b := a[:]  // slice of all elements<br/>c := a[3:]  // slice of all elements from index 3<br/>d := a[:6]  // slice of all elements till index 6-1 = 5<br/>e := a[3:6]  // slice of elements starting index 3 till 6-1 = 5</span></pre></div><div class="ab cl ln lo gp lp" role="separator"><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls"/></div><div class="hb hc hd he hf"><p id="e617" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我已经到了帖子的末尾。这对我来说是一次有趣的学习。我未来的帖子将会有更多基于学习的东西，只要我能够分享。到那时再见。我还会发布一个关于golang中常量和枚举器的小帖子。我以前错过了它，将在适当的时候发布。</p></div></div>    
</body>
</html>