<html>
<head>
<title>HTTP Request Smuggling: Part-1 (Concepts)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">HTTP请求走私:第1部分(概念)</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/http-request-smuggling-part-1-concepts-b89bfe17b210?source=collection_archive---------1-----------------------#2021-07-10">https://medium.com/nerd-for-tech/http-request-smuggling-part-1-concepts-b89bfe17b210?source=collection_archive---------1-----------------------#2021-07-10</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="b8be" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">简而言之:对于笔测试者</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es jd"><img src="../Images/d9cf922e3fa8f6942f62f976d64a1c1d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1010/format:webp/1*tpTmZEtJh7OMc4ZERgZhrQ.png"/></div></figure><p id="08a3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这是一个关于HTTP请求走私的两部分博客。第1部分侧重于理解基本概念，第2部分侧重于识别和利用HTTP请求走私。我们开始吧。</p><h1 id="c872" class="jm jn hi bd jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj bi translated">语境</h1><p id="5a37" class="pw-post-body-paragraph if ig hi ih b ii kk ik il im kl io ip iq km is it iu kn iw ix iy ko ja jb jc hb bi translated">当安全研究员詹姆斯·凯特尔(James Kettle)在2019年发现利用该漏洞的有趣方法时，HTTP请求走私漏洞这个老计时器重新浮出水面。当我最初读他的论文时，我个人觉得很难，我决定一步一步来。经过一些研究后，我意识到，这需要的只是对一些HTTP概念的理解。这个博客尽可能简化HTTP请求走私及其概念。我们走吧。</p><h1 id="c723" class="jm jn hi bd jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj bi translated">客户端服务器架构</h1><p id="fe85" class="pw-post-body-paragraph if ig hi ih b ii kk ik il im kl io ip iq km is it iu kn iw ix iy ko ja jb jc hb bi translated">在我们深入研究请求走私及其概念之前，让我们看看我们一直以来是如何想象客户机-服务器架构的:</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="kq kr di ks bf kt"><div class="er es kp"><img src="../Images/fe62db9bb06c5329d0a677f3f36252dc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*J8NBOXRcg53k53qNCc7eMg.png"/></div></div><figcaption class="ku kv et er es kw kx bd b be z dx translated">客户端服务器架构</figcaption></figure><p id="383b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">有一个客户端和一个服务器，首先建立一个TCP连接，然后是一个TLS，然后你发送一个HTTP请求，你从服务器得到一个HTTP响应。这有问题吗，有什么变化吗？嗯，没什么太大的不同，除了架构是实时多层的。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="kq kr di ks bf kt"><div class="er es ky"><img src="../Images/5a78f576a18614518386ebea1f8af890.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hAbLz0b4BZltn6icycZOpg.png"/></div></div><figcaption class="ku kv et er es kw kx bd b be z dx translated">客户端服务器架构(多层)</figcaption></figure><p id="c886" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">有两个服务器，前端和后端。前端服务器通常是反向代理或负载平衡器。还在前端服务器和后端服务器之间建立了新的TCP、TLS连接，以交换HTTP请求。</p><p id="0e81" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在，您是否发现后端服务器交换HTTP请求有什么可疑之处？好吧，在我们继续理解一些HTTP概念的时候，请继续思考。</p><h1 id="5ac9" class="jm jn hi bd jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj bi translated">HTTP和TCP(持续连接)</h1><p id="8cc2" class="pw-post-body-paragraph if ig hi ih b ii kk ik il im kl io ip iq km is it iu kn iw ix iy ko ja jb jc hb bi translated">OSI层，TCP/IP，已经有一段时间了，不是吗？现在，让我们后退一步，接触一下我们的网络基础知识。HTTP是应用层协议，TCP是传输层协议。HTTP不可靠，这意味着它不能处理数据丢失，而TCP是可靠的。因此，每当必须建立可靠的HTTP连接时，HTTP将依赖于TCP。现在，这是否意味着您需要为每个HTTP请求建立一个单独的TCP连接？嗯，事情就是这样开始的。</p><p id="1eb7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">默认情况下，HTTP/1.0 </strong>会为每个HTTP请求打开一个TCP连接。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="kq kr di ks bf kt"><div class="er es kz"><img src="../Images/236f3ca330b2ff9cebab2b3c457f8199.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*m2dusYrt03j0yFJABt581A.png"/></div></div><figcaption class="ku kv et er es kw kx bd b be z dx translated">HTTP/1.0(默认)</figcaption></figure><p id="7682" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果您在请求中添加了<strong class="ih hj">连接:keep-alive </strong>，可以手动更改这种行为，TCP连接将保持打开，或者您所说的持久化，HTTP请求可以一个接一个地发送。</p><p id="5626" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在<strong class="ih hj"> HTTP/1.1中，</strong>默认情况下，一个TCP连接是持久的，在同一个连接下可以发送多个HTTP请求。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="kq kr di ks bf kt"><div class="er es la"><img src="../Images/cfadc22e54abbb6ffe5805ce3e98128d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*T9HQElm2otdkewIeeJYF4A.png"/></div></div><figcaption class="ku kv et er es kw kx bd b be z dx translated">HTTP/1.1(默认保持活动状态)</figcaption></figure><p id="be8a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">或者，<strong class="ih hj"> Connection: close </strong> header可用于在收到完整响应或超时后关闭连接。</p><h1 id="efff" class="jm jn hi bd jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj bi translated">内容长度和传输编码(找到请求的结尾)</h1><p id="ff80" class="pw-post-body-paragraph if ig hi ih b ii kk ik il im kl io ip iq km is it iu kn iw ix iy ko ja jb jc hb bi translated">好了，现在我们知道HTTP/1.1允许在一个TCP连接下有多个HTTP请求。让我们暂停一下，再次看看我们的多层客户机服务器架构，尤其是后端。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="kq kr di ks bf kt"><div class="er es ky"><img src="../Images/5a78f576a18614518386ebea1f8af890.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hAbLz0b4BZltn6icycZOpg.png"/></div></div><figcaption class="ku kv et er es kw kx bd b be z dx translated">又是大局</figcaption></figure><p id="7c9c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">好像是在HTTP 1.1上，为什么？在同一个TCP连接上发送多个HTTP请求，答对了！转到下一个奇怪的问题，后端服务器如何区分这些HTTP请求？如果每个请求都有一个单独的TCP连接，那肯定会容易得多，对吗？</p><p id="2458" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们从GET请求开始。</p><pre class="je jf jg jh fd lb lc ld le aw lf bi"><span id="6401" class="lg jn hi lc b fi lh li l lj lk">GET https://abcdefsecurity.com/api/search <strong class="lc hj">HTTP/1.1</strong><br/><strong class="lc hj">Host</strong>: abcdefsecurity.com<br/><strong class="lc hj">Accept-Encoding</strong>: gzip, deflate<br/><strong class="lc hj">Accept-Language</strong>: en-GB,en-US;q=0.9,en;q=0.8</span></pre><p id="ba0f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">GET有URL和头。URL有一个表示结束的HTTP/version-number，标准的头和值被服务器理解，而那些服务器不理解的，它简单地拒绝，所以头的结束标志着GET请求的结束。得到请求似乎不是什么大问题，不是吗。</p><p id="fe4f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">帖子请求怎么样？POST主体可能因应用程序和框架的不同而不同。这就是下面的HTTP头派上用场的地方。</p><ul class=""><li id="7e98" class="ll lm hi ih b ii ij im in iq ln iu lo iy lp jc lq lr ls lt bi translated">内容长度</li><li id="740d" class="ll lm hi ih b ii lu im lv iq lw iu lx iy ly jc lq lr ls lt bi translated">传输编码:分块</li></ul><blockquote class="lz ma mb"><p id="6b29" class="if ig mc ih b ii ij ik il im in io ip md ir is it me iv iw ix mf iz ja jb jc hb bi translated">注意-上述头适用于HTTP/1.1，部分适用于HTTP/1.0，但不适用于HTTP/2。</p></blockquote><h1 id="f446" class="jm jn hi bd jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj bi translated">内容长度</h1><p id="83c4" class="pw-post-body-paragraph if ig hi ih b ii kk ik il im kl io ip iq km is it iu kn iw ix iy ko ja jb jc hb bi translated">此头计算文章正文的内容长度，包括CRLF (\r\n)字符。在下面的例子中，文章主体“search=http”的总字符数是Content-Length的值，即11。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="kq kr di ks bf kt"><div class="er es mg"><img src="../Images/734c39b60f3882debe187f16ab0eb183.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sWbeQpm8X-89LF9rIQTESw.png"/></div></div><figcaption class="ku kv et er es kw kx bd b be z dx translated">内容长度格式—示例1</figcaption></figure><p id="2c98" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">考虑下面的例子，文章正文下面有一个额外的空行，在这种情况下，新行字符' \r\n '被计算为两个额外的字符，因此内容长度是13。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="kq kr di ks bf kt"><div class="er es mh"><img src="../Images/6f575c91ab5f4fd4bdb98c9da7eb6557.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lobr_NJHstxbxq7PVMmzXg.png"/></div></div><figcaption class="ku kv et er es kw kx bd b be z dx translated">内容长度格式—示例2</figcaption></figure><h1 id="9ea9" class="jm jn hi bd jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj bi translated">传输编码:分块(TE)</h1><p id="c809" class="pw-post-body-paragraph if ig hi ih b ii kk ik il im kl io ip iq km is it iu kn iw ix iy ko ja jb jc hb bi translated">或者，在您想要上传数据块的文件上传期间使用Transfer-Encoding头。除了头部之外，它还希望主体采用特定的格式。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="kq kr di ks bf kt"><div class="er es mi"><img src="../Images/66072debeae7d4a923772d760d39c0db.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bgJHFtJIfmJE0TEPir1JHg.png"/></div></div><figcaption class="ku kv et er es kw kx bd b be z dx translated">传输编码:分块格式</figcaption></figure><p id="678d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">“测试上传”是块内容，其长度为14。e是14的十六进制值，在“0”之后有一行标记消息的结束。可以有多个这样的块。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="kq kr di ks bf kt"><div class="er es mj"><img src="../Images/df9308e0a697ad7f67966f93b7f11db6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*U2Mu52zQTtZztZgcIjbu4w.png"/></div></div><figcaption class="ku kv et er es kw kx bd b be z dx translated">传输编码:分块格式</figcaption></figure><blockquote class="lz ma mb"><p id="de68" class="if ig mc ih b ii ij ik il im in io ip md ir is it me iv iw ix mf iz ja jb jc hb bi translated">注意——HTTP 1.1允许您在同一个请求中发送Content-Length和Transfer-Encoding头，但是当两者都发送时，Transfer-Encoding优先。</p></blockquote><h1 id="9878" class="jm jn hi bd jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj bi translated">什么是HTTP请求走私？</h1><p id="cf51" class="pw-post-body-paragraph if ig hi ih b ii kk ik il im kl io ip iq km is it iu kn iw ix iy ko ja jb jc hb bi translated">让我们把这一切放在一张图片中——我们在HTTP/1.1中已经了解到，单个TCP连接是持久的，多个HTTP请求可以在同一连接下发送，后端服务器可以根据内容长度(CL)和传输编码(te)头来区分这些请求。现在你可以看到每个服务器都有一种方法来识别请求的结束。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="kq kr di ks bf kt"><div class="er es mg"><img src="../Images/bf37801713d413dc9bac5222197801c0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ovP0rwODM38gtkU1fUO7tQ.png"/></div></div><figcaption class="ku kv et er es kw kx bd b be z dx translated">两台服务器都使用内容长度</figcaption></figure><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="kq kr di ks bf kt"><div class="er es kp"><img src="../Images/7ebc6515f41527e985e037a5132637d4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-eu8wnjSCwrh0_hfz6D6ig.png"/></div></div><figcaption class="ku kv et er es kw kx bd b be z dx translated">两台服务器都使用传输编码</figcaption></figure><p id="673a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">它的画面很完美，两个服务器要么使用内容长度，要么使用传输编码来标记请求的结束。等等，我们是笔测试者，我们想要不完美的东西，我们很好奇，那么如果出现混淆，一个服务器接受CL，另一个接受TE，或者相反，会发生什么呢？</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="kq kr di ks bf kt"><div class="er es mk"><img src="../Images/93b28ff5e867bc431ea65d998a8f3a19.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nBOcoj4YtUJ6UKtM1-0tTw.png"/></div></div><figcaption class="ku kv et er es kw kx bd b be z dx translated">混合标题</figcaption></figure><p id="0682" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这正是HTTP请求走私的攻击场景，现在暂停一下，想想如果有这样的场景，你会怎么做。</p><p id="17d6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">美国东南部。</p><p id="3853" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在，作为一名pen-tester，希望在请求中一起发送两个报头，并查看服务器如何处理它们，检查所有可能的组合:</p><ul class=""><li id="77c3" class="ll lm hi ih b ii ij im in iq ln iu lo iy lp jc lq lr ls lt bi translated">当两个报头都被发送时，前端服务器拒绝该请求(预期行为和安全)</li><li id="8645" class="ll lm hi ih b ii lu im lv iq lw iu lx iy ly jc lq lr ls lt bi translated">当两个报头都被发送时，TE在它必须优先的地方优先，而另一个服务器拒绝它(安全)</li></ul><p id="6d47" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们能想到哪些不安全的选择？</p><ul class=""><li id="791c" class="ll lm hi ih b ii ij im in iq ln iu lo iy lp jc lq lr ls lt bi translated"><strong class="ih hj"> (CL，TE) </strong> -前端服务器忽略TE，将其作为CL处理，请求发送到后端，将其作为TE处理</li><li id="b9ef" class="ll lm hi ih b ii lu im lv iq lw iu lx iy ly jc lq lr ls lt bi translated"><strong class="ih hj"> (TE，CL) - </strong>前端服务器忽略CL并将其作为TE处理，请求到达后端并作为CL处理</li><li id="73d0" class="ll lm hi ih b ii lu im lv iq lw iu lx iy ly jc lq lr ls lt bi translated"><strong class="ih hj"> (TE，TE) - </strong>前端服务器和后端服务器都接受TE，但其中一个服务器无法处理</li></ul><p id="263f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">但是对于上面的场景，发送两个报头的标准方式不起作用，因为如果我们发送两个报头，要么TE优先，要么请求会被拒绝，因为大多数系统都是这样设计的。我们将需要发送两个标头，但是在某种程度上，前端服务器会错过其中一个标头，这听起来很有趣，对吗？这就是James Kettle进行研究的地方，他提出了传输编码报头上的多个有效载荷，当发送时，会使前端服务器无法处理报头。</p><pre class="je jf jg jh fd lb lc ld le aw lf bi"><span id="f9cb" class="lg jn hi lc b fi lh li l lj lk"><strong class="lc hj">PAYLOADS</strong></span><span id="9880" class="lg jn hi lc b fi ml li l lj lk"> Transfer-Encoding : chunked</span><span id="26d5" class="lg jn hi lc b fi ml li l lj lk">Transfer-Encoding: xchunked</span><span id="522f" class="lg jn hi lc b fi ml li l lj lk">Transfer-Encoding : chunked</span><span id="cf64" class="lg jn hi lc b fi ml li l lj lk">Transfer-Encoding: chunked<br/>Transfer-Encoding: x</span><span id="9829" class="lg jn hi lc b fi ml li l lj lk">and many more</span></pre><p id="6e6e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这些有效载荷之间的差异是微小而微妙的，让我们以第一个为例，在标题前面只有一个空格，真棒吧:)</p><p id="b8c0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在，百万美元的问题，我们该怎么办，什么是HTTP请求走私？</p><p id="39ee" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为了更好地理解，让我们选择更简单的方法，记住在传输编码中，我们如何在同一个请求中发送多个数据块，如果我们实际上将另一个HTTP请求作为一个数据块发送，如下所示，但没有按预期关闭数据块，会怎么样呢:</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="kq kr di ks bf kt"><div class="er es mi"><img src="../Images/4eb9d0ae81985eb8f8ce0c2ba9964a12.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SU0XBEBLPqaCghRiGOzJFA.png"/></div></div><figcaption class="ku kv et er es kw kx bd b be z dx translated">使用CE走私请求。元素铊的符号</figcaption></figure><p id="9188" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在，当我们发送这个请求时，队列会发生什么情况。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="kq kr di ks bf kt"><div class="er es mm"><img src="../Images/140805ffe7208321edba045f7cf6e088.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*65qOmOGq1nj7EzEYEnLuSg.png"/></div></div><figcaption class="ku kv et er es kw kx bd b be z dx translated">创建了未处理的区块数据并附加到用户绿色请求</figcaption></figure><ul class=""><li id="ab7a" class="ll lm hi ih b ii ij im in iq ln iu lo iy lp jc lq lr ls lt bi translated">在用户蓝色和绿色的请求中，用户红色发送了一个恶意的请求请求，如上图-'请求走私有效载荷'。该请求的末尾还有一个额外的/404.html请求。但是请注意，这个块没有用0和新的一行正确地结束。</li><li id="5131" class="ll lm hi ih b ii lu im lv iq lw iu lx iy ly jc lq lr ls lt bi translated">前端服务器计算内容长度，由于“空格”的原因，它忽略了传输编码头。所以，根据前端服务器它的一个请求，但它的实际上两个<strong class="ih hj"> <em class="mc"> /404.html请求被偷运到这里的队列中:)</em> </strong></li><li id="5606" class="ll lm hi ih b ii lu im lv iq lw iu lx iy ly jc lq lr ls lt bi translated">后端服务器现在拾取传输编码报头，处理第一个块，并且当它移动到下一个块时，它读取该块，但是因为它没有“0”并且在wards之后没有新的行，所以该块未被处理并且被附加到下一个传入的请求。</li></ul><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="kq kr di ks bf kt"><div class="er es mn"><img src="../Images/14441698098514bdf532c839c737d5ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lmiw2dyKeUx9ndFof4s_WQ.png"/></div></div><figcaption class="ku kv et er es kw kx bd b be z dx translated">走私请求(红色)</figcaption></figure><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="kq kr di ks bf kt"><div class="er es mo"><img src="../Images/1d4b05578010bb48f001fbdb900a13d7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*C90pyio3VI_O_OkAABb0AA.png"/></div></div><figcaption class="ku kv et er es kw kx bd b be z dx translated">后端服务器中剩余的未处理块</figcaption></figure><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="kq kr di ks bf kt"><div class="er es kp"><img src="../Images/0d8dbfd9ae2a415583d0fcf7bb8039e1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ovBt0yoQn5OpwwnP2Fwmsg.png"/></div></div><figcaption class="ku kv et er es kw kx bd b be z dx translated">下一个即将到来的绿色请求(红色之后的下一个请求)</figcaption></figure><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="kq kr di ks bf kt"><div class="er es mp"><img src="../Images/1da4b26be324b3d6d95427bfefa95659.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*V2OeieTKZoLizQplfV9NCQ.png"/></div></div><figcaption class="ku kv et er es kw kx bd b be z dx translated">未处理的块被添加到绿色请求</figcaption></figure><p id="9d7a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Random-Header屏蔽了新请求的路径。现在，当用户实际请求/account时，用户green将收到/404.html。</p><blockquote class="lz ma mb"><p id="fc73" class="if ig mc ih b ii ij ik il im in io ip md ir is it me iv iw ix mf iz ja jb jc hb bi translated">由于它还对队列进行了去同步，而在理想情况下，响应是按照接收顺序提供的，但现在却没有，所以它也被称为HTTP去同步攻击。</p></blockquote><p id="c999" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">你现在可以阅读我的博客<a class="ae jl" rel="noopener" href="/nerd-for-tech/http-request-smuggling-part-2-tl-ce-exploit-ec1171a88459">第二部分</a>来识别和利用HTTP请求走私！</p><p id="69c1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我希望你喜欢看这个博客:)如果你喜欢的话，请发来。日安！</p><p id="49c4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">参考资料:</p><ul class=""><li id="daf8" class="ll lm hi ih b ii ij im in iq ln iu lo iy lp jc lq lr ls lt bi translated"><a class="ae jl" href="https://portswigger.net/research/http-desync-attacks-request-smuggling-reborn" rel="noopener ugc nofollow" target="_blank">https://ports wigger . net/research/http-desync-attacks-request-走私-重生</a></li><li id="9706" class="ll lm hi ih b ii lu im lv iq lw iu lx iy ly jc lq lr ls lt bi translated"><a class="ae jl" href="https://portswigger.net/web-security/request-smuggling" rel="noopener ugc nofollow" target="_blank">https://portswigger.net/web-security/request-smuggling</a></li></ul></div></div>    
</body>
</html>