<html>
<head>
<title>An Interesting Approach to Implement Factory Pattern in Java</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">一种用 Java 实现工厂模式的有趣方法</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/an-interesting-approach-to-implement-factory-pattern-in-java-d59615f562b5?source=collection_archive---------10-----------------------#2021-06-27">https://medium.com/nerd-for-tech/an-interesting-approach-to-implement-factory-pattern-in-java-d59615f562b5?source=collection_archive---------10-----------------------#2021-06-27</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="3bbe" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">使用 Spring 注释</h2></div><p id="9d8e" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">每当添加新的接口实现时，Java 中接口的传统工厂类都需要更新工厂。通常有几种方法可以做到这一点，让我们首先通过一个例子来理解一种流行的方法。这里我创建了一个<em class="jt">车辆</em>接口，它是由一个<a class="ae ju" href="https://spring.io/projects/spring-framework" rel="noopener ugc nofollow" target="_blank">弹簧</a> <a class="ae ju" href="https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/stereotype/Component.html" rel="noopener ugc nofollow" target="_blank">组件</a>类— <em class="jt">汽车</em>实现的，</p><figure class="jv jw jx jy fd jz"><div class="bz dy l di"><div class="ka kb l"/></div></figure><p id="a778" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如果您想知道<a class="ae ju" href="https://projectlombok.org/features/GetterSetter" rel="noopener ugc nofollow" target="_blank"> <em class="jt"> Setter </em> </a>注释，这是一个为类字段生成 Setter 的<a class="ae ju" href="https://projectlombok.org/" rel="noopener ugc nofollow" target="_blank"> Lombok </a>注释。现在让我们为这个接口创建一个工厂，</p><figure class="jv jw jx jy fd jz"><div class="bz dy l di"><div class="ka kb l"/></div></figure><p id="2881" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这里，工厂是用一种更传统的方法实现的，它有一个 register 方法，每个实现类都将使用这个方法向工厂注册自己，如下所示:</p><figure class="jv jw jx jy fd jz"><div class="bz dy l di"><div class="ka kb l"/></div></figure><p id="dc8a" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">务必注意<em class="jt">车辆工厂</em> bean 将通过<a class="ae ju" href="https://spring.io/projects/spring-framework" rel="noopener ugc nofollow" target="_blank">弹簧</a>自动连线<a class="ae ju" href="https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/beans/factory/annotation/Autowired.html" rel="noopener ugc nofollow" target="_blank"><em class="jt"/></a>。这种方法有一个问题——你总是需要向工厂注册一个实现，这是一个额外的手动步骤，并不真正有助于应用程序的业务逻辑，但在执行过程中是至关重要的。如果一个新的开发人员编写了一个接口的实现，并且不知道工厂，他/她可能会忘记向工厂注册 bean，这可能会破坏应用程序。这也意味着<strong class="iz hj">工厂与接口实现</strong>紧密耦合，因为添加新的工厂需要手工更新工厂。通过构造函数手动将每个 bean 注册到工厂也可以被称为样板文件，因为这是重复的，而且如上所述，不会增加业务逻辑。</p></div><div class="ab cl kc kd gp ke" role="separator"><span class="kf bw bk kg kh ki"/><span class="kf bw bk kg kh ki"/><span class="kf bw bk kg kh"/></div><div class="hb hc hd he hf"><p id="a3b8" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这就是使用注释的地方。注释的核心目的是存储与类或其组件相关联的元数据。我们是否可以利用这些注释在不调用任何 register 方法的情况下自动向工厂注册新的 beans？我们当然可以。这里是如何—</p><ol class=""><li id="7847" class="kj kk hi iz b ja jb jd je jg kl jk km jo kn js ko kp kq kr bi translated"><strong class="iz hj">既然我们在这些例子中使用的是 S</strong><a class="ae ju" href="https://spring.io/projects/spring-framework" rel="noopener ugc nofollow" target="_blank"><strong class="iz hj">spring</strong></a><strong class="iz hj">框架，那就让我们重用一下</strong> <a class="ae ju" href="https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/stereotype/Component.html" rel="noopener ugc nofollow" target="_blank"> <strong class="iz hj"> <em class="jt">组件</em> </strong> </a> <strong class="iz hj">注释来达到我们的目的。</strong></li><li id="49d1" class="kj kk hi iz b ja ks jd kt jg ku jk kv jo kw js ko kp kq kr bi translated"><strong class="iz hj">我们将为每个带注释的类命名，我们的工厂将使用它来注册 bean。</strong></li><li id="206c" class="kj kk hi iz b ja ks jd kt jg ku jk kv jo kw js ko kp kq kr bi translated"><strong class="iz hj">我们将</strong><a class="ae ju" href="https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/beans/factory/annotation/Autowired.html" rel="noopener ugc nofollow" target="_blank"><strong class="iz hj"><em class="jt">Autowire</em></strong></a><strong class="iz hj">的所有接口实现，我们将通过它们来浏览，然后读取注释，然后将它们注册到工厂。</strong></li></ol><p id="cf33" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">让我们看看它的实际效果。我们现在将用在<a class="ae ju" href="https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/stereotype/Component.html" rel="noopener ugc nofollow" target="_blank"> <em class="jt">组件</em> </a>注释中配置的名称更新<em class="jt">汽车</em>类，</p><figure class="jv jw jx jy fd jz"><div class="bz dy l di"><div class="ka kb l"/></div></figure><p id="1fc3" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">现在让我们更新工厂的逻辑来读取这些注释，并在实例化期间向工厂注册相应的 beans，</p><figure class="jv jw jx jy fd jz"><div class="bz dy l di"><div class="ka kb l"/></div></figure><p id="ac45" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">同样，请注意<em class="jt">列表&lt;车辆&gt; </em>将在实例化期间与<em class="jt">车辆</em>接口实现列表<a class="ae ju" href="https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/beans/factory/annotation/Autowired.html" rel="noopener ugc nofollow" target="_blank"><em class="jt"/></a>自动关联。让我们来理解这种说法，</p><pre class="jv jw jx jy fd kx ky kz la aw lb bi"><span id="657d" class="lc ld hi ky b fi le lf l lg lh">vehicles.forEach(vehicle -&gt;                      vehicleMap.put(vehicle.getClass().<br/>getAnnotationsByType(Component.class)[0].value(), vehicle));</span></pre><p id="9c62" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在这里，我们遍历每个实现，并把它放入工厂映射，key 作为<a class="ae ju" href="https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/stereotype/Component.html" rel="noopener ugc nofollow" target="_blank"> <em class="jt">组件</em> </a> <em class="jt"> </em>注释的值，value 作为实现的 bean 本身。该键在检索过程中用于返回接口的正确实现。</p></div><div class="ab cl kc kd gp ke" role="separator"><span class="kf bw bk kg kh ki"/><span class="kf bw bk kg kh ki"/><span class="kf bw bk kg kh"/></div><div class="hb hc hd he hf"><p id="8bd3" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">因此，我们在这里，不像实现工厂模式的更传统的方法需要更新工厂类本身或 bean 注册的附加语句，<strong class="iz hj">这种基于注释的方法与</strong> <a class="ae ju" href="https://spring.io/projects/spring-framework" rel="noopener ugc nofollow" target="_blank"> <strong class="iz hj"> Spring </strong> </a> <strong class="iz hj">框架一起通过自动向工厂注册任何新的实现来处理它。这不仅导致了工厂与底层实现的解耦，还确保了应用程序中样板代码的减少。</strong></p></div></div>    
</body>
</html>