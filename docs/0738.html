<html>
<head>
<title>Programming with Functions #4: “unapply” and the newtype pattern</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用函数编程#4:“取消应用”和新类型模式</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/programming-with-functions-4-unapply-and-the-newtype-pattern-7584cceb3e9?source=collection_archive---------12-----------------------#2021-02-09">https://medium.com/nerd-for-tech/programming-with-functions-4-unapply-and-the-newtype-pattern-7584cceb3e9?source=collection_archive---------12-----------------------#2021-02-09</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex if ig ih ii"><div class="bz dy l di"><div class="ij ik l"/></div></figure><h2 id="812f" class="il im hi bd in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji bi translated"><code class="du jj jk jl jm b">unapply</code>法</h2><p id="ea85" class="pw-post-body-paragraph jn jo hi jp b jq jr js jt ju jv jw jx iw jy jz ka ja kb kc kd je ke kf kg kh hb bi translated">你可以把<code class="du jj jk jl jm b">unapply</code>方法看作是<code class="du jj jk jl jm b">apply</code>的反义词...哦。比方说，你有那个密封的特征<code class="du jj jk jl jm b">Cat</code>和它的伴随对象。定义了两个应用方法:它们获取猫的颜色(或者说它缺少颜色)并创建给定颜色(或者没有颜色)的猫。既然现在颜色是猫的唯一属性，那么稍微发挥一下想象力，你可能会认为它是把猫包在颜色周围……好吧，让我们换个例子来讨论正方形。</p><p id="d633" class="pw-post-body-paragraph jn jo hi jp b jq ki js jt ju kj jw jx iw kk jz ka ja kl kc kd je km kf kg kh hb bi translated">正方形是由它的边长来定义的，只有边长:</p><pre class="kn ko kp kq fd kr jm ks kt aw ku bi"><span id="4e2c" class="il im hi jm b fi kv kw l kx ky">case class Square(a: Int)</span></pre><p id="90fb" class="pw-post-body-paragraph jn jo hi jp b jq ki js jt ju kj jw jx iw kk jz ka ja kl kc kd je km kf kg kh hb bi translated">case类自动实现apply方法，因此您可以通过编写以下代码来创建一个新的正方形:</p><pre class="kn ko kp kq fd kr jm ks kt aw ku bi"><span id="83f9" class="il im hi jm b fi kv kw l kx ky">val aSquare = Square(1)</span></pre><p id="7c80" class="pw-post-body-paragraph jn jo hi jp b jq ki js jt ju kj jw jx iw kk jz ka ja kl kc kd je km kf kg kh hb bi translated">由于对正方形没有什么了解，你可能会认为<code class="du jj jk jl jm b">Square.apply</code>方法将关于边长的数据包装在一个类型为<code class="du jj jk jl jm b">Square</code>的容器中。这个容器是用来给数据赋予意义的。如果有人只告诉你<em class="kz">“边的长度是1”</em>你会有数据，但你还是要问<em class="kz">“什么的边？”</em>。有了我们谈到的正方形的附加信息，这幅图就完整了。</p><figure class="kn ko kp kq fd ii er es paragraph-image"><div role="button" tabindex="0" class="lb lc di ld bf le"><div class="er es la"><img src="../Images/af7085ae4c52bdaff146d1e90a11b32d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*hHiZB0C-eFkZh0BU"/></div></div></figure><p id="8267" class="pw-post-body-paragraph jn jo hi jp b jq ki js jt ju kj jw jx iw kk jz ka ja kl kc kd je km kf kg kh hb bi translated">unapply方法以另一种方式工作。它是在伴随对象中定义的，通常将相关类的实例作为其唯一的参数，并返回实例内部内容的选项。在最简单的情况下，这将只是类的字段:如果类中只有一个字段，则为1，否则为一对、三对、四对等等。<code class="du jj jk jl jm b">Square</code> case类为我们实现了unapply方法，但是如果我们想要编写自己的方法，它应该是这样的:</p><pre class="kn ko kp kq fd kr jm ks kt aw ku bi"><span id="af3b" class="il im hi jm b fi kv kw l kx ky">class Square(a: Int)</span><span id="fee8" class="il im hi jm b fi lh kw l kx ky">object Square {<br/>  def unapply(square: Square): Option[Int] = Some(square.a)<br/>  def apply(a: Int): Square = new Square(a)<br/>}</span></pre><p id="0dcd" class="pw-post-body-paragraph jn jo hi jp b jq ki js jt ju kj jw jx iw kk jz ka ja kl kc kd je km kf kg kh hb bi translated">我还添加了<code class="du jj jk jl jm b">apply</code>方法，这样你可以更好地看到它们基本上是如何对立的。唯一突出的是unapply方法返回一个<code class="du jj jk jl jm b">Option</code>。为什么？因为就像<code class="du jj jk jl jm b">apply</code>一样，<code class="du jj jk jl jm b">unapply</code>在返回“解包”的结果之前，可以用来执行更复杂的运算，有时甚至可以证明预期的结果与我们得到的结果不符。不幸的是，为了提供一个例子，我不得不回到猫:我们可以<code class="du jj jk jl jm b">unapply</code>一个<code class="du jj jk jl jm b">RealCat</code>的实例，并获得它的颜色，但我们不能为虚幻的猫这样做，比如Cheshire猫:</p><pre class="kn ko kp kq fd kr jm ks kt aw ku bi"><span id="11bf" class="il im hi jm b fi kv kw l kx ky">object Cat {<br/>  def apply(colour: CatColour): Cat = RealCat(colour)<br/>  def apply(): Cat = CheshireCat<br/> <br/>  def unapply(cat: Cat): Option[Colour] = cat match {<br/>    case realCat: RealCat =&gt; Some(realCat.colour)<br/>    case _ =&gt; None<br/>  }<br/>}</span><span id="c452" class="il im hi jm b fi lh kw l kx ky">val cat: Cat = ...<br/>cat match {<br/>  case Cat(colour) =&gt; println(colour)<br/>  case _: Cat      =&gt; println("invisible")<br/>}</span></pre><p id="a949" class="pw-post-body-paragraph jn jo hi jp b jq ki js jt ju kj jw jx iw kk jz ka ja kl kc kd je km kf kg kh hb bi translated">现在，如果我们的猫是一只姜黄色的猫(<code class="du jj jk jl jm b">RealCat(Ginger)</code>)，我们将能够用我们崭新的<code class="du jj jk jl jm b">unapply</code>方法提取它的颜色并打印出来。但是对于没有颜色的猫，我们不能这样做——<code class="du jj jk jl jm b">unapply</code>方法必须为它们返回<code class="du jj jk jl jm b">None</code>,当我们对猫使用<code class="du jj jk jl jm b">match/case</code>时，我们将被迫使用默认情况。</p><figure class="kn ko kp kq fd ii er es paragraph-image"><div role="button" tabindex="0" class="lb lc di ld bf le"><div class="er es la"><img src="../Images/5c4d57fad583ccc85e5698c4db810d94.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*B61aUvlSLGpYj3Q1"/></div></div></figure><p id="a764" class="pw-post-body-paragraph jn jo hi jp b jq ki js jt ju kj jw jx iw kk jz ka ja kl kc kd je km kf kg kh hb bi translated">还有一件有趣的事情你可能已经注意到了:在这些例子中没有一个地方明确地调用了<code class="du jj jk jl jm b">unapply</code>方法。但是这比我们简单地使用<code class="du jj jk jl jm b">X(...)</code>而不是<code class="du jj jk jl jm b">X.apply(...)</code>的apply方法要复杂一些。在<code class="du jj jk jl jm b">unapply</code>的情况下，显式调用应该是这样的:</p><pre class="kn ko kp kq fd kr jm ks kt aw ku bi"><span id="148a" class="il im hi jm b fi kv kw l kx ky">val catColour: Option[CatColour] = Cat.unapply(cat)</span></pre><p id="e0e8" class="pw-post-body-paragraph jn jo hi jp b jq ki js jt ju kj jw jx iw kk jz ka ja kl kc kd je km kf kg kh hb bi translated">如果我们绝对肯定猫有一种颜色，那么我们可以把它简化为:</p><pre class="kn ko kp kq fd kr jm ks kt aw ku bi"><span id="a75a" class="il im hi jm b fi kv kw l kx ky">val Cat(catColour) = cat</span></pre><p id="7667" class="pw-post-body-paragraph jn jo hi jp b jq ki js jt ju kj jw jx iw kk jz ka ja kl kc kd je km kf kg kh hb bi translated">您有时可以看到像这样的语句被用作数据转换的一种形式。在声明中:</p><pre class="kn ko kp kq fd kr jm ks kt aw ku bi"><span id="154d" class="il im hi jm b fi kv kw l kx ky">val B(data) = a</span></pre><p id="3c47" class="pw-post-body-paragraph jn jo hi jp b jq ki js jt ju kj jw jx iw kk jz ka ja kl kc kd je km kf kg kh hb bi translated">右边的实体<code class="du jj jk jl jm b">a</code>是类型<code class="du jj jk jl jm b">A</code>，对象<code class="du jj jk jl jm b">B</code>有一个<code class="du jj jk jl jm b">unapply</code>方法声明为:</p><pre class="kn ko kp kq fd kr jm ks kt aw ku bi"><span id="2c8f" class="il im hi jm b fi kv kw l kx ky">B.unapply(a: A): Option[B]</span></pre><p id="2b7c" class="pw-post-body-paragraph jn jo hi jp b jq ki js jt ju kj jw jx iw kk jz ka ja kl kc kd je km kf kg kh hb bi translated">它必须总是返回<code class="du jj jk jl jm b">Some(data)</code>。(顺便说一下，返回的<code class="du jj jk jl jm b">Option[B]</code>中的类型<code class="du jj jk jl jm b">B</code>不一定必须与我们定义<code class="du jj jk jl jm b">unapply</code>的对象<code class="du jj jk jl jm b">B</code>中的类型相同，但是同样，为了可读性，最好是相同的类型)。</p><p id="a5ec" class="pw-post-body-paragraph jn jo hi jp b jq ki js jt ju kj jw jx iw kk jz ka ja kl kc kd je km kf kg kh hb bi translated">请注意，代码中从未强制要求<code class="du jj jk jl jm b">unapply</code>方法返回<code class="du jj jk jl jm b">Some</code>。有可能在将来的某个时候，某个不知道这个假设的人会通过在某些情况下使它返回None来“改进”<code class="du jj jk jl jm b">unapply</code>，然后下一次我们运行这个应用程序时，我们会有一个bug。</p><p id="5c43" class="pw-post-body-paragraph jn jo hi jp b jq ki js jt ju kj jw jx iw kk jz ka ja kl kc kd je km kf kg kh hb bi translated">更常见的是<code class="du jj jk jl jm b">unapply</code>被留给其他构造隐式使用。在Scala中随处可见:在<code class="du jj jk jl jm b">match/case</code>，在<code class="du jj jk jl jm b">map</code>，<code class="du jj jk jl jm b">flatMap</code>，<code class="du jj jk jl jm b">collect</code>，等等。您也可以在<code class="du jj jk jl jm b">for/yield</code>中看到它，它用于声明只有当我们在此时成功展开数据时，执行才会继续:</p><pre class="kn ko kp kq fd kr jm ks kt aw ku bi"><span id="ee05" class="il im hi jm b fi kv kw l kx ky">for {<br/>  …<br/>  cat &lt;- ...<br/>  Cat(colour) &lt;- cat<br/>  … // will be executed only if the cat has colour<br/>} yield colour</span></pre><p id="3036" class="pw-post-body-paragraph jn jo hi jp b jq ki js jt ju kj jw jx iw kk jz ka ja kl kc kd je km kf kg kh hb bi translated">这是一种无处不在的东西，但你只有学会发现它，才会发现它。</p><h2 id="3fc3" class="il im hi bd in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji bi translated">新型模式</h2><p id="a6f6" class="pw-post-body-paragraph jn jo hi jp b jq jr js jt ju jv jw jx iw jy jz ka ja kb kc kd je ke kf kg kh hb bi translated">所以，现在你可以看到模式匹配和类型安全是如何携手并进的:通过仔细设计(<code class="du jj jk jl jm b">sealed</code>)特征、(<code class="du jj jk jl jm b">case</code>)类和case对象的层次结构，以及<code class="du jj jk jl jm b">apply</code>和<code class="du jj jk jl jm b">unapply</code>方法，你可以使你的代码更具可读性，并让编译器告诉你那些你只能通过运行应用程序才能发现的错误。调试和重构也变得更加容易。如果除此之外，你还会使用这一系列关于函数式编程的文章中的其他技巧，那么过一段时间后，你甚至会意识到你喜欢你的工作。</p><p id="e6cf" class="pw-post-body-paragraph jn jo hi jp b jq ki js jt ju kj jw jx iw kk jz ka ja kl kc kd je km kf kg kh hb bi translated">有一件事可能会毁了你的一天，那就是另一个程序员，他没有你那么细心，你不得不使用他的代码。你有那些漂亮的猫的等级和颜色，你从他那里得到了什么？数字。弦乐。数组。元组。呃。就好像他们是用Python写的一样。</p><p id="ebbe" class="pw-post-body-paragraph jn jo hi jp b jq ki js jt ju kj jw jx iw kk jz ka ja kl kc kd je km kf kg kh hb bi translated">或者也许没那么糟糕，但是通常不同的程序员使用稍微不同的方法，你从同事那里得到的可能不完全符合你的思维方式。或者，您可能只是希望对数据类型有更多的控制。例如，一个密码是<code class="du jj jk jl jm b">String</code>，但它是一个满足特定要求的字符串:它包含大写和小写字母、数字、特殊字符、一定长度等。拥有一个特殊的<code class="du jj jk jl jm b">Password</code>类是有意义的，而不是以字符串的形式传递密码并记住它们是特殊的。</p><figure class="kn ko kp kq fd ii er es paragraph-image"><div role="button" tabindex="0" class="lb lc di ld bf le"><div class="er es la"><img src="../Images/2941bc54aee339e7026d1bd029d8353b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*_GPdt6aJAHQs85SV"/></div></div></figure><p id="93f1" class="pw-post-body-paragraph jn jo hi jp b jq ki js jt ju kj jw jx iw kk jz ka ja kl kc kd je km kf kg kh hb bi translated">有一个简单的技巧可以解决这个问题:将那些丑陋的实例包装成你自己的漂亮的类。比方说，你从某个地方收到了这个类<code class="du jj jk jl jm b">WeirdCat</code>。<code class="du jj jk jl jm b">WeirdCat</code>并没有扩展你的<code class="du jj jk jl jm b">sealed trait Cat</code>，它使用了单词<code class="du jj jk jl jm b">color</code>的美国化版本，而不是猫颜色的字段<code class="du jj jk jl jm b">colour</code>。然而，除了这些细节，它几乎符合。你想使用那些丑陋的猫，如果你不必因为那些小的差异而重复你的代码，那就太好了。下面是newtype模式的用处:</p><pre class="kn ko kp kq fd kr jm ks kt aw ku bi"><span id="bd52" class="il im hi jm b fi kv kw l kx ky">// from another module<br/>class WeirdCat(val color: Int) // 0 - Black, 1 - White</span><span id="e2b9" class="il im hi jm b fi lh kw l kx ky">// the wrapper over WeirdCat<br/>case class CatInBox(private val weirdCat: WeirdCat) extends Cat {<br/>  val colour: CatColour = weirdCat.color match {<br/>    case 0 =&gt; Black<br/>    case 1 =&gt; White<br/>  }  <br/>}</span><span id="e3d6" class="il im hi jm b fi lh kw l kx ky">// and some changes to the companion object<br/>object Cat {<br/>  …<br/>  def apply(weirdCat: WeirdCat): Cat = CatInBox(weirdCat)</span><span id="ab4f" class="il im hi jm b fi lh kw l kx ky">  def unapply(cat: Cat): Option[Colour] = cat match {<br/>    case realCat: RealCat   =&gt; Some(realCat.colour)<br/>    case catInBox: CatInBox =&gt; Some(catInBox.colour)<br/>    case CheshireCat        =&gt; None<br/>  }<br/>}</span><span id="c439" class="il im hi jm b fi lh kw l kx ky">// and we’re good to go:<br/>val weirdCat: WeirdCat = … // taken from another module<br/>val cat = Cat(weirdCat)<br/>cat match {<br/>  case Cat(colour) =&gt; println(colour)<br/>  case _: Cat      =&gt; println("invisible")<br/>}</span></pre><p id="a92d" class="pw-post-body-paragraph jn jo hi jp b jq ki js jt ju kj jw jx iw kk jz ka ja kl kc kd je km kf kg kh hb bi translated">这只怪异的猫将被包装在实现了<code class="du jj jk jl jm b">sealed trait Cat</code>的类<code class="du jj jk jl jm b">CatInBox</code>的一个实例中，而<code class="du jj jk jl jm b">Cat.unapply</code>方法将被用来提取这只猫的颜色作为<code class="du jj jk jl jm b">sealed trait CatColour</code>的一个子类型——就像它是一只普通的猫一样。</p><p id="52e6" class="pw-post-body-paragraph jn jo hi jp b jq ki js jt ju kj jw jx iw kk jz ka ja kl kc kd je km kf kg kh hb bi translated">newtype模式已经存在了很长时间，但最近因为生锈而变得更加流行。Rust试图将函数式编程和类型安全与非常低级的攻击结合起来，程序员经常发现自己在处理原始类型，但仍然希望对它们使用模式匹配。Newtype是一种方法。它变得如此普遍，以至于Rust引入了一个优化:当一个<code class="du jj jk jl jm b">struct</code>只有一个字段时，编译器将去掉包装器，这样就不会浪费额外的内存。在科特林，同样的事情可以通过实验性的<code class="du jj jk jl jm b">inline class</code>来实现。在Scala中这也是可能的，但不是在所有情况下。你可以通过让你的包装类扩展一个特殊的超类<code class="du jj jk jl jm b">AnyVal</code>来做到这一点:</p><pre class="kn ko kp kq fd kr jm ks kt aw ku bi"><span id="51ed" class="il im hi jm b fi kv kw l kx ky">case class CatInBox(private val weirdCat: WeirdCat) extends AnyVal</span></pre><p id="c4b7" class="pw-post-body-paragraph jn jo hi jp b jq ki js jt ju kj jw jx iw kk jz ka ja kl kc kd je km kf kg kh hb bi translated">不幸的是，这意味着你不再被允许加入<code class="du jj jk jl jm b">Cat</code>特征:</p><pre class="kn ko kp kq fd kr jm ks kt aw ku bi"><span id="6adf" class="il im hi jm b fi kv kw l kx ky">case class CatInBox(private val weirdCat: WeirdCat) <br/>  extends AnyVal with Cat<br/>// illegal inheritance; superclass AnyVal is not a subclass <br/>// of the superclass Object of the mixin trait Cat</span></pre><p id="d5e7" class="pw-post-body-paragraph jn jo hi jp b jq ki js jt ju kj jw jx iw kk jz ka ja kl kc kd je km kf kg kh hb bi translated">它仍然有用，只是没那么有用了:例如，你仍然可以直接使用<code class="du jj jk jl jm b">match/case</code>而不是<code class="du jj jk jl jm b">CatInBox</code>。</p><p id="b12d" class="pw-post-body-paragraph jn jo hi jp b jq ki js jt ju kj jw jx iw kk jz ka ja kl kc kd je km kf kg kh hb bi translated">然而，有一个替代方案:<a class="ae li" href="https://github.com/estatico/scala-newtype" rel="noopener ugc nofollow" target="_blank">Cary Robbins</a>的一个 <code class="du jj jk jl jm b"><a class="ae li" href="https://github.com/estatico/scala-newtype" rel="noopener ugc nofollow" target="_blank">scala-newtype</a></code> <a class="ae li" href="https://github.com/estatico/scala-newtype" rel="noopener ugc nofollow" target="_blank">库，它试图在宏的帮助下绕过这个限制。</a></p><p id="ec2d" class="pw-post-body-paragraph jn jo hi jp b jq ki js jt ju kj jw jx iw kk jz ka ja kl kc kd je km kf kg kh hb bi translated">好吧。让我们暂时停在这里。下一次我们将讨论不变性，所以var与val，可变与不可变集合。我们也会学到一些关于懒惰的知识。</p><p id="a3aa" class="pw-post-body-paragraph jn jo hi jp b jq ki js jt ju kj jw jx iw kk jz ka ja kl kc kd je km kf kg kh hb bi translated">先前:<a class="ae li" href="https://makingthematrix.medium.com/programming-with-functions-3-pattern-matching-64d3fba6929f?source=friends_link&amp;sk=484b7abb953d3b61c35ad23fb5c0bba3" rel="noopener">使用功能#3编程—模式匹配</a></p><p id="0471" class="pw-post-body-paragraph jn jo hi jp b jq ki js jt ju kj jw jx iw kk jz ka ja kl kc kd je km kf kg kh hb bi translated">接下来:<a class="ae li" href="https://makingthematrix.medium.com/programming-with-functions-5-immutability-41611bb7a044?source=friends_link&amp;sk=b662ae767c939b52697f26c6e5f780da" rel="noopener">用函数#5编程—不变性</a></p></div></div>    
</body>
</html>