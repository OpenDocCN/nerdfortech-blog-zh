<html>
<head>
<title>Kubernetes Operator Demystified</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Kubernetes运营商揭秘</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/kubernetes-operator-demystified-dd8336c056dd?source=collection_archive---------7-----------------------#2021-08-06">https://medium.com/nerd-for-tech/kubernetes-operator-demystified-dd8336c056dd?source=collection_archive---------7-----------------------#2021-08-06</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/7442b0513fd03c083f1ab6cfae584c9f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lh9Rmm0d3FezBLMdQnoThA.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">Kubernetes运营商背后的奥秘！</figcaption></figure><p id="3790" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">让我们去掉一件事— Kubernetes操作符不是一个对象。这是一种设计模式。说完了，让我们来了解一下什么是Kubernetes算子。</p><h1 id="905f" class="js jt hi bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">运算符模式</h1><p id="ca06" class="pw-post-body-paragraph iu iv hi iw b ix kq iz ja jb kr jd je jf ks jh ji jj kt jl jm jn ku jp jq jr hb bi translated">从<a class="ae kv" href="https://kubernetes.io/docs/concepts/extend-kubernetes/operator/" rel="noopener ugc nofollow" target="_blank">官方文件</a>来看，</p><blockquote class="kw kx ky"><p id="0306" class="iu iv kz iw b ix iy iz ja jb jc jd je la jg jh ji lb jk jl jm lc jo jp jq jr hb bi translated">操作员是Kubernetes的软件扩展，它利用定制资源来管理应用程序及其组件。操作员遵循Kubernetes原则，特别是控制回路。</p></blockquote><p id="df89" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">那么，这意味着什么呢？这意味着Kubernetes操作符是一种结合了定制资源和定制控制器的设计模式。</p><p id="0242" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">再问一遍，这是什么意思？</p><figure class="le lf lg lh fd ij er es paragraph-image"><div class="er es ld"><img src="../Images/6ce1550925a30a824fb0dd26566133ea.png" data-original-src="https://miro.medium.com/v2/resize:fit:1164/format:webp/1*zV1GEb54qS12fOE_Ozl12g.png"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">Kubernetes操作符是一种设计模式。</figcaption></figure><h1 id="74be" class="js jt hi bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">自定义资源</h1><p id="7dbf" class="pw-post-body-paragraph iu iv hi iw b ix kq iz ja jb kr jd je jf ks jh ji jj kt jl jm jn ku jp jq jr hb bi translated">一个<em class="kz">资源</em>是Kubernetes API中的端点。<br/>这个端点管理特定对象类型的数据——添加、编辑、删除。<br/>例如，Pod资源是Kubernetes API中管理Pod对象数据的端点。</p><p id="13c9" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">同样地，<em class="kz">自定义资源</em>是Kubernetes API中的自定义端点，不是默认安装的一部分。一旦在集群中创建了自定义资源定义(CRD ),就可以使用为管理自定义资源对象的数据而创建的自定义端点来执行所有基本的REST API调用——GET、PUT、POST、DELETE、PATCH等等。</p><h1 id="f806" class="js jt hi bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">控制器或控制回路</h1><p id="008d" class="pw-post-body-paragraph iu iv hi iw b ix kq iz ja jb kr jd je jf ks jh ji jj kt jl jm jn ku jp jq jr hb bi translated"><em class="kz">再一次，让我们把这个也去掉——控制器不是Kubernetes对象。这是一种设计模式。继续前进…</em></p><p id="c630" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">自定义资源定义将只创建一个自定义端点来盲目地存储和检索与自定义对象相关的数据。但是，这个自定义资源应该做什么呢？例如，ReplicaSet资源创建Pod，Pod资源创建容器—您的资源将做什么？这就是<em class="kz">定制控制器</em>发挥作用的地方。</p><p id="5d47" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><em class="kz">控制器</em>是一个控制循环/非终止进程，它不断检查至少一个Kubernetes对象(内置或自定义)的状态。这是在添加、删除或修改特定资源类型的对象时通知的脚本。然后，您可以决定您想要对该事件做什么——创建容器、调用外部URL，无论您喜欢什么。</p><p id="5056" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">要创建一个控制循环脚本，您只需要一种方法来检测集群中发生的变化——比如添加、删除或修改特定类型的新对象。Kubernetes对此有一个内置的特性叫做<strong class="iw hj"> <em class="kz">手表</em> </strong>。</p><h1 id="2f78" class="js jt hi bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">Kubernetes API手表</h1><p id="6d1b" class="pw-post-body-paragraph iu iv hi iw b ix kq iz ja jb kr jd je jf ks jh ji jj kt jl jm jn ku jp jq jr hb bi translated">文档<a class="ae kv" href="https://kubernetes.io/docs/reference/using-api/api-concepts/#efficient-detection-of-changes" rel="noopener ugc nofollow" target="_blank">很好地解释了这一点，</a></p><blockquote class="kw kx ky"><p id="ce9b" class="iu iv kz iw b ix iy iz ja jb jc jd je la jg jh ji lb jk jl jm lc jo jp jq jr hb bi translated">为了使客户机能够构建一个集群当前状态的模型，所有Kubernetes对象资源类型都需要支持一致的列表和一个称为<strong class="iw hj"> watch </strong>的增量变更通知提要。每个Kubernetes对象都有一个<code class="du li lj lk ll b">resourceVersion</code>字段，表示存储在底层数据库中的资源版本。当检索资源集合(命名空间或集群范围)时，来自服务器的响应将包含一个<code class="du li lj lk ll b">resourceVersion</code>值，该值可用于启动对服务器的监视。服务器将返回在提供的<code class="du li lj lk ll b">resourceVersion</code>之后发生的所有更改(创建、删除和更新)。这允许客户端获取当前状态，然后观察变化，而不会错过任何更新。如果客户端观察器断开连接，它们可以从最后返回的<code class="du li lj lk ll b">resourceVersion</code>开始重新启动新的观察器，或者执行新的收集请求并重新开始。</p></blockquote><p id="6fca" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">我们试着用一个例子来理解这一点。</p><p id="8170" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">这是一个示例API调用，用于获取默认名称空间中的窗格列表。<br/>响应返回3个pod。注意每个Pod的元数据中的<em class="kz"> resourceVersion </em>。<em class="kz"> resourceVersion </em>类似于数据库中对象的ID。</p><pre class="le lf lg lh fd lm ll ln lo aw lp bi"><span id="671a" class="lq jt hi ll b fi lr ls l lt lu"><em class="kz">curl --insecure -H "Authorization: Bearer $TOKEN" </em><a class="ae kv" href="https://kubernetes/api/v1/namespaces/default/pods" rel="noopener ugc nofollow" target="_blank"><em class="kz">https://kubernetes/api/v1/namespaces/default/pods</em></a><em class="kz"><br/></em>{<br/>  "kind": "PodList",<br/>  "apiVersion": "v1",<br/>  "metadata": {<br/>    "resourceVersion": "1291"<br/>  },<br/>  "items": [<br/>    {<br/>      "metadata": {<br/>        "name": "test-ccdc9b768-nxtcw",<br/>        "namespace": "default",<br/><strong class="ll hj">        "resourceVersion": "918",</strong><br/>        ...<br/>      },<br/>      "spec": {<br/>      ...  <br/>      },<br/>      "status": {<br/>        ...<br/>      }<br/>    },<br/>    {<br/>      "metadata": {<br/>        "name": "test-ccdc9b768-vwsxn",<br/>        "namespace": "default",<br/><strong class="ll hj">        "resourceVersion": "953",</strong><br/>        ...<br/>      },<br/>      "spec": {<br/>        ...<br/>      },<br/>      "status": {<br/>        ...<br/>      }<br/>    },<br/>    {<br/>      "metadata": {<br/>        "name": "test-ccdc9b768-vxhds",<br/>        "namespace": "default",<br/><strong class="ll hj">        "resourceVersion": "<em class="kz">987</em>",</strong><br/>        ...<br/>      },<br/>      "spec": {<br/>        ...<br/>      },<br/>      "status": {<br/>        ...<br/>      }<br/>    }<br/>  ]<br/>}</span></pre><p id="52b2" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">现在，您可以通过在API调用中发送<code class="du li lj lk ll b">watch=1</code>和<code class="du li lj lk ll b">resourceVersion=&lt;resourceVersion&gt;</code>来启动对默认名称空间中的pod的<em class="kz">监视</em>。这将会做的是，</p><ul class=""><li id="981c" class="lv lw hi iw b ix iy jb jc jf lx jj ly jn lz jr ma mb mc md bi translated">在此resourceVersion之后，返回默认命名空间中对象类型窗格的所有事件。</li><li id="8bd0" class="lv lw hi iw b ix me jb mf jf mg jj mh jn mi jr ma mb mc md bi translated">保持连接打开(使用长轮询)，以便您可以继续获取事件。</li></ul><p id="44c2" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">例如，如果我创建了一个名为“my-new-test-pod”的新Pod，然后使用上一次调用的最新资源版本(在我们的示例中是987)启动了一个观察器，那么我将得到如下响应…</p><pre class="le lf lg lh fd lm ll ln lo aw lp bi"><span id="6e2d" class="lq jt hi ll b fi lr ls l lt lu"><em class="kz">curl --insecure -H "Authorization: Bearer $TOKEN" </em><a class="ae kv" href="https://kubernetes/api/v1/namespaces/default/pods?watch=1&amp;resourceVersion=987" rel="noopener ugc nofollow" target="_blank"><em class="kz">https://kubernetes/api/v1/namespaces/default/pods?</em><strong class="ll hj"><em class="kz">watch=1&amp;resourceVersion=987</em></strong></a></span><span id="1713" class="lq jt hi ll b fi mj ls l lt lu">{"type":"ADDED","object":{"kind":"Pod","apiVersion":"v1","metadata":{"name":"my-new-test-pod","resourceVersion":"11046"...},"spec":{...}...}}<br/>{"type":"MODIFIED","object":{"kind":"Pod","apiVersion":"v1","metadata":{"resourceVersion":"11047"...},"spec":{...}...}}</span></pre><p id="9986" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">每当与默认名称空间中的Pod相关联的事件发生时，我将获取事件类型和具有resourceVersion和specs的对象信息。这个连接不会关闭——因此，我将继续获取事件列表。我现在可以决定如何处理这些事件了！</p></div><div class="ab cl mk ml gp mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="hb hc hd he hf"><h1 id="dcab" class="js jt hi bd ju jv mr jx jy jz ms kb kc kd mt kf kg kh mu kj kk kl mv kn ko kp bi translated">我们用一个例子来理解流程。</h1><p id="1e83" class="pw-post-body-paragraph iu iv hi iw b ix kq iz ja jb kr jd je jf ks jh ji jj kt jl jm jn ku jp jq jr hb bi translated">Kubernetes操作符是定制资源定义&amp;定制资源的控制循环脚本(控制器)。就是这样。</p><p id="50ad" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">这些是我们将遵循的步骤:</p><ol class=""><li id="fab5" class="lv lw hi iw b ix iy jb jc jf lx jj ly jn lz jr mw mb mc md bi translated">创建自定义资源</li><li id="b894" class="lv lw hi iw b ix me jb mf jf mg jj mh jn mi jr mw mb mc md bi translated">创建一个将运行我们的控制循环脚本的Pod</li><li id="e581" class="lv lw hi iw b ix me jb mf jf mg jj mh jn mi jr mw mb mc md bi translated">决定我们的脚本将如何处理这些事件</li></ol><h2 id="3580" class="lq jt hi bd ju mx my mz jy na nb nc kc jf nd ne kg jj nf ng kk jn nh ni ko nj bi translated">步骤1:创建自定义资源</h2><p id="2df7" class="pw-post-body-paragraph iu iv hi iw b ix kq iz ja jb kr jd je jf ks jh ji jj kt jl jm jn ku jp jq jr hb bi translated">为了创建一个定制资源，我们需要创建一个<em class="kz">定制资源定义</em> (CRD)。查看官方文档了解更多关于自定义资源定义的<a class="ae kv" href="https://kubernetes.io/docs/tasks/extend-kubernetes/custom-resources/custom-resource-definitions/" rel="noopener ugc nofollow" target="_blank">语法</a></p><p id="567b" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">CRD将描述我们的新资源的模式(模式意味着什么字段可以在我们的新资源中使用，什么是值的数据类型，默认值，验证等)。</p><pre class="le lf lg lh fd lm ll ln lo aw lp bi"><span id="f9ff" class="lq jt hi ll b fi lr ls l lt lu"><em class="kz">mycrd.yaml</em></span><span id="7951" class="lq jt hi ll b fi mj ls l lt lu">apiVersion: apiextensions.k8s.io/v1<br/>kind: CustomResourceDefinition<br/>metadata:<br/>  name: mywebservers.k8sobjects.gsa.com<br/>spec:<br/>  group: k8sobjects.gsa.com<br/>  scope: Namespaced<br/>  names:<br/>    kind: MyWebserver<br/>    singular: mywebserver<br/>    plural: mywebservers<br/>    shortNames:<br/>    - myweb<br/>    - mws<br/>  versions:<br/>    - name: v2<br/>      served: true<br/>      storage: true<br/>      schema:<br/>        openAPIV3Schema:<br/>          type: object<br/>          properties:<br/>            spec:<br/>              type: object<br/>              properties:<br/>                image:<br/>                  type: string<br/>                port:<br/>                  type: integer<br/>                replicas:<br/>                  type: integer</span></pre><p id="6f9d" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">上图中，CRD为一个名为“MyWebserver”的新对象定义了模式。可以用名字<em class="kz"> mywebserver </em>、<em class="kz"> mywebservers </em>、<em class="kz"> myweb </em>、<em class="kz"> mws </em>来指代。</p><pre class="le lf lg lh fd lm ll ln lo aw lp bi"><span id="6417" class="lq jt hi ll b fi lr ls l lt lu">kubectl apply -f mycrd.yaml</span></pre><p id="abd8" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">这个定制资源定义将在Kubernetes API中创建新的端点</p><pre class="le lf lg lh fd lm ll ln lo aw lp bi"><span id="ff8e" class="lq jt hi ll b fi lr ls l lt lu"><strong class="ll hj"># Get the list of API groups available. You should see your custom resource listed here</strong><br/><em class="kz">curl --insecure -X GET -H "Authorization: Bearer $TOKEN" </em><a class="ae kv" href="https://kubernetes/apis/" rel="noopener ugc nofollow" target="_blank"><em class="kz">https://kubernetes/apis/</em></a></span><span id="1e56" class="lq jt hi ll b fi mj ls l lt lu">{<br/>  "kind": "APIGroupList",<br/>  "apiVersion": "v1",<br/>  "groups": [<br/>    ...<br/>    {<br/>      "name": "apps",<br/>      "versions": [<br/>        {<br/>          "groupVersion": "apps/v1",<br/>          "version": "v1"<br/>        }<br/>      ],<br/>      "preferredVersion": {<br/>        "groupVersion": "apps/v1",<br/>        "version": "v1"<br/>      }<br/>    },<br/>    ...<br/>    {<br/>      "name": "k8sobjects.gsa.com",<br/>      "versions": [<br/>        {<br/>          "groupVersion": "k8sobjects.gsa.com/v2",<br/>          "version": "v2"<br/>        }<br/>      ],<br/>      "preferredVersion": {<br/>        "groupVersion": "k8sobjects.gsa.com/v2",<br/>        "version": "v2"<br/>      }<br/>    }<br/>  ]<br/>}</span><span id="b756" class="lq jt hi ll b fi mj ls l lt lu"><strong class="ll hj"># Get list of <em class="kz">mywebserver</em> objects in any namespace</strong><br/><em class="kz">curl --insecure -X GET -H "Authorization: Bearer $TOKEN" </em><a class="ae kv" href="https://kubernetes/apis/k8sobjects.gsa.com/v2/mywebservers" rel="noopener ugc nofollow" target="_blank"><em class="kz">https://kubernetes/apis/k8sobjects.gsa.com/v2/mywebservers</em></a></span><span id="71ea" class="lq jt hi ll b fi mj ls l lt lu">{<br/>  "apiVersion":"k8sobjects.gsa.com/v2",<br/>  "items":[....],<br/>  "kind":"MyWebserverList",<br/>  "metadata":{"continue":"","resourceVersion":"16800"}<br/>}</span></pre><p id="5981" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">因此，基于这个自定义资源定义创建我的新对象的YAML将如下所示</p><pre class="le lf lg lh fd lm ll ln lo aw lp bi"><span id="e270" class="lq jt hi ll b fi lr ls l lt lu"><em class="kz">myobj.yaml</em></span><span id="2b16" class="lq jt hi ll b fi mj ls l lt lu">apiVersion: "k8sobjects.gsa.com/v2"<br/>kind: MyWebserver<br/>metadata:<br/>  name: webapp<br/>spec:<br/>  image: nginx<br/>  port: 80<br/>  replicas: 2</span><span id="8943" class="lq jt hi ll b fi mj ls l lt lu"><strong class="ll hj">kubectl apply -f myobj.yaml</strong></span></pre><p id="9e7e" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><code class="du li lj lk ll b"><em class="kz">apiVersion</em></code>是您的CRD &lt;组名&gt; / &lt;版本名&gt; <br/>对象有一个属性<em class="kz"> spec </em>，它有类型string的子属性<em class="kz"> image </em>、类型integer的<em class="kz"> port </em>和类型integer的<em class="kz"> replicas </em>。<br/>您现在可以使用<code class="du li lj lk ll b">kubectl</code>来管理该对象。</p><pre class="le lf lg lh fd lm ll ln lo aw lp bi"><span id="259a" class="lq jt hi ll b fi lr ls l lt lu"><strong class="ll hj">kubectl get mws</strong><br/>NAME     AGE<br/>webapp   67s</span><span id="53fe" class="lq jt hi ll b fi mj ls l lt lu"><strong class="ll hj">kubectl describe mws webapp</strong><br/>Name:         webapp<br/>Namespace:    default<br/>Labels:       &lt;none&gt;<br/>Annotations:  &lt;none&gt;<br/>API Version:  k8sobjects.gsa.com/v2<br/>Kind:         MyWebserver<br/>Metadata:<br/>  Creation Timestamp:  2021-08-06T18:57:09Z<br/>  Generation:          1<br/>  Managed Fields:<br/>    API Version:  k8sobjects.gsa.com/v2<br/>    Fields Type:  FieldsV1<br/>    fieldsV1:<br/>      f:metadata:<br/>        f:annotations:<br/>          .:<br/>          f:kubectl.kubernetes.io/last-applied-configuration:<br/>      f:spec:<br/>        .:<br/>        f:image:<br/>        f:port:<br/>        f:replicas:<br/>    Manager:         kubectl-client-side-apply<br/>    Operation:       Update<br/>    Time:            2021-08-06T18:57:09Z<br/>  Resource Version:  17033<br/>  UID:               ce87c872-ad71-4092-a0ec-a10f65a4b132<br/>Spec:<br/>  Image:     nginx<br/>  Port:      80<br/>  Replicas:  2<br/>Events:      &lt;none&gt;</span><span id="46ed" class="lq jt hi ll b fi mj ls l lt lu"><strong class="ll hj"># List mywebserver objects in the default namespace</strong><br/><em class="kz">curl --insecure -X GET -H "Authorization: Bearer $TOKEN" </em><a class="ae kv" href="https://kubernetes/apis/k8sobjects.gsa.com/v2/namespaces/default/mywebservers" rel="noopener ugc nofollow" target="_blank"><em class="kz">https://kubernetes/apis/k8sobjects.gsa.com/v2/namespaces/default/mywebservers</em></a></span><span id="d43f" class="lq jt hi ll b fi mj ls l lt lu">{<br/>  "apiVersion":"k8sobjects.gsa.com/v2",<br/>  "items":[<br/>    {<br/>      "apiVersion":"k8sobjects.gsa.com/v2",<br/>      "kind":"MyWebserver",<br/>      "metadata":{<br/>        "annotations":{...},<br/>        "creationTimestamp":"2021-08-06T18:57:09Z",<br/>        "generation":1,<br/>        "managedFields":[...],<br/>        "name":"webapp",<br/>        "namespace":"default",<br/>        "resourceVersion":"17033",<br/>        "uid":"ce87c872-ad71-4092-a0ec-a10f65a4b132"<br/>      },<br/>      "spec":{<br/>        "image":"nginx",<br/>        "port":80,"replicas":2<br/>      }<br/>    }<br/>  ],<br/>  "kind":"MyWebserverList",<br/>  "metadata":{<br/>    "continue":"",<br/>    "resourceVersion":"17265"<br/>  }<br/>}</span></pre><h2 id="1934" class="lq jt hi bd ju mx my mz jy na nb nc kc jf nd ne kg jj nf ng kk jn nh ni ko nj bi translated"><strong class="ak">步骤2:创建一个Pod，它将运行我们的控制循环脚本</strong></h2><p id="6f9f" class="pw-post-body-paragraph iu iv hi iw b ix kq iz ja jb kr jd je jf ks jh ji jj kt jl jm jn ku jp jq jr hb bi translated">既然已经创建了定制资源，我们需要一个控制循环脚本来监视这个定制资源，并在创建、删除或修改这个定制资源类型的对象时获取事件。</p><p id="4050" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">为什么我们要在Pod中运行这个控制循环脚本？</p><ul class=""><li id="a4a4" class="lv lw hi iw b ix iy jb jc jf lx jj ly jn lz jr ma mb mc md bi translated">使用服务帐户向我们的脚本授予必要的权限更容易。</li><li id="fe4d" class="lv lw hi iw b ix me jb mf jf mg jj mh jn mi jr ma mb mc md bi translated">您可以将pod作为守护进程运行，以确保它始终在运行。</li></ul><p id="a8b1" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">为了简单起见，我将使用PHP来运行我们的控制循环脚本。你可以随意使用任何你喜欢的编程语言。认为控制循环脚本只能用Go、Python或Java编写是一种误解！</p><p id="c757" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">这里是<em class="kz">服务帐号</em>来给我们的脚本必要的权限。我们允许自己在任何名称空间中使用自定义资源(MyWebserver)、部署和pod。</p><pre class="le lf lg lh fd lm ll ln lo aw lp bi"><span id="6141" class="lq jt hi ll b fi lr ls l lt lu"><em class="kz">permissions.yaml</em></span><span id="c28d" class="lq jt hi ll b fi mj ls l lt lu">---<br/>apiVersion: v1<br/>kind: ServiceAccount<br/>metadata:<br/>  name: mywebservers-sa</span><span id="caac" class="lq jt hi ll b fi mj ls l lt lu">---<br/>apiVersion: rbac.authorization.k8s.io/v1<br/>kind: ClusterRole<br/>metadata:<br/>  name: mywebservers-cr<br/>rules:<br/>- apiGroups:<br/>  - apiextensions.k8s.io<br/>  resources:<br/>  - customresourcedefinitions<br/>  verbs:<br/>  - list<br/>- apiGroups: ["extensions", "apps"]<br/>  resources: ["deployments"]<br/>  verbs: ['*']<br/>- apiGroups:<br/>  - ""<br/>  resources:<br/>  - pods<br/>  verbs:<br/>   - '*'<br/>- apiGroups:<br/>  - "k8sobjects.gsa.com"<br/>  - "k8sobjects.gsa.com/v2"<br/>  resources:<br/>  - mywebservers<br/>  verbs:<br/>   - '*'</span><span id="915d" class="lq jt hi ll b fi mj ls l lt lu">---<br/>kind: ClusterRoleBinding<br/>apiVersion: rbac.authorization.k8s.io/v1<br/>metadata:<br/>  name: mywebservers-crb<br/>subjects:<br/>- kind: ServiceAccount<br/>  name: mywebservers-sa<br/>  namespace: default<br/>roleRef:<br/>  kind: ClusterRole<br/>  name: mywebservers-cr<br/>  apiGroup: rbac.authorization.k8s.io</span></pre><p id="fbff" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">这个部署将运行我的控制循环脚本。它当然在自定义Docker图像中。</p><pre class="le lf lg lh fd lm ll ln lo aw lp bi"><span id="75e2" class="lq jt hi ll b fi lr ls l lt lu">apiVersion: apps/v1<br/>kind: Deployment<br/>metadata:<br/>  name: php-client<br/>spec:<br/>  replicas: 1<br/>  selector:<br/>    matchLabels:<br/>      app: php-client<br/>  template:<br/>    metadata:<br/>      labels:<br/>        app: php-client<br/>    spec:<br/>      serviceAccountName: mywebservers-sa<br/>      containers:<br/>        - name: n1<br/>          image: gayatrisa/learn-k8s:client<br/>          ports:<br/>            - containerPort: 80</span></pre><h2 id="3cab" class="lq jt hi bd ju mx my mz jy na nb nc kc jf nd ne kg jj nf ng kk jn nh ni ko nj bi translated">第三步:决定你想在你的脚本中做什么</h2><p id="7d02" class="pw-post-body-paragraph iu iv hi iw b ix kq iz ja jb kr jd je jf ks jh ji jj kt jl jm jn ku jp jq jr hb bi translated">最终，我希望做的是，当创建一个类型为<em class="kz"> mywebserver </em>的对象时，必须使用在<em class="kz"> mywebserver </em>对象中指定的映像名称和端口号创建一个部署&amp;服务对象。</p><p id="b4ce" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">我的控制循环脚本如下所示。(我隐藏了流等的PHP编码复杂性。在<a class="ae kv" href="https://github.com/gayatri-sa/k8s-operator" rel="noopener ugc nofollow" target="_blank"> GitHub </a>上有一个工作代码。)</p><pre class="le lf lg lh fd lm ll ln lo aw lp bi"><span id="2f5f" class="lq jt hi ll b fi lr ls l lt lu">&lt;?php<br/>$myop = new K8sClient();</span><span id="098a" class="lq jt hi ll b fi mj ls l lt lu">$resourceVersion = '';<br/>do {<br/>    $events = $myop-&gt;watchObject($resourceVersion);<br/>    if (!empty($events) &amp;&amp; is_array($events)) {<br/>       $latestResourceVersion = $events[sizeof($events)-1]['object']['metadata']['resourceVersion'];</span><span id="7034" class="lq jt hi ll b fi mj ls l lt lu">if ($resourceVersion &gt;= $latestResourceVersion) {<br/>            break;<br/>        }<br/>        $resourceVersion = $latestResourceVersion;<br/>    }<br/>    foreach ($events as $event) {       <br/>        switch ($event['type']) {<br/>            case 'ADDED':<br/>                echo '----- EVENT TYPE: ADDED -----' . "\n";<br/>                <strong class="ll hj"><em class="kz">// Create a deployment and service based on the object data we got from the event</em></strong><br/>                break;<br/>            case 'DELETED':<br/>                echo '----- EVENT TYPE: DELETED -----' . "\n";<br/>                <strong class="ll hj"><em class="kz">// Delete the deployment and service we created based on the object data we got from the event</em></strong><br/>                break;<br/>        }<br/>    }<br/>    <br/>} while (!empty($events));</span></pre><p id="d892" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">因此，对于添加的每个<em class="kz"> mywebserver </em>对象，我的控制器(控制循环脚本)会创建1个部署和1个服务对象。类似地，对于每个<em class="kz"> mywebserver </em>对象，您删除相应的1个部署和1个服务对象将被我的控制器删除。</p><p id="d6e8" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">现在，您拥有全部的权力——您甚至可以选择触发一个外部操作！</p><h1 id="fe84" class="js jt hi bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">结论</h1><p id="5e35" class="pw-post-body-paragraph iu iv hi iw b ix kq iz ja jb kr jd je jf ks jh ji jj kt jl jm jn ku jp jq jr hb bi translated">那么，在一个简单的Kubernetes操作符设计中，您需要什么:</p><ul class=""><li id="7d28" class="lv lw hi iw b ix iy jb jc jf lx jj ly jn lz jr ma mb mc md bi translated">自定义资源定义，用于创建自定义API端点</li><li id="abe2" class="lv lw hi iw b ix me jb mf jf mg jj mh jn mi jr ma mb mc md bi translated">自定义控制器/控制循环脚本，它将获取与您的自定义资源相关的事件</li><li id="4bdb" class="lv lw hi iw b ix me jb mf jf mg jj mh jn mi jr ma mb mc md bi translated">一个Pod，用于运行您的控制循环脚本</li><li id="38fc" class="lv lw hi iw b ix me jb mf jf mg jj mh jn mi jr ma mb mc md bi translated">服务帐户，为您的控制循环脚本提供必要的权限</li></ul><p id="cd6b" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">许多精彩的SDK隐藏了这些复杂性和步骤，使所有这些对您来说都很顺利和容易。其中最受欢迎的是<a class="ae kv" href="https://sdk.operatorframework.io/" rel="noopener ugc nofollow" target="_blank"> OperatorSDK </a>。一旦这个流程清晰了，我会推荐使用SDK，而不是自己做所有的事情。</p></div></div>    
</body>
</html>