<html>
<head>
<title>Java Threads!</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Java线程！</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/java-threads-d9ae5e231419?source=collection_archive---------6-----------------------#2021-05-09">https://medium.com/nerd-for-tech/java-threads-d9ae5e231419?source=collection_archive---------6-----------------------#2021-05-09</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/7de78fddef8395b9ce06b6d612e7e668.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9PZUW-TqRAy4_mqtiwNXMQ.jpeg"/></div></div></figure><h1 id="681b" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">我们能否增加线程的数量，并将进程缩短到1秒或2秒？那是多线程吗？</h1><p id="7b10" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">我们通过一个小例子来寻找这个问题的答案。</p><pre class="km kn ko kp fd kq kr ks kt aw ku bi"><span id="780e" class="kv ir hi kr b fi kw kx l ky kz">Validate      = 2s<br/>Preparation   = 3s<br/>Currancy rate = 4s<br/>Update model  = 2s<br/>Save          = 4s<br/>              -----<br/>               15s<br/>//So Can we use 5 threads and take this to 3 seconds? <br/>No! That's not possible as there are dependency tasks here.</span><span id="72a0" class="kv ir hi kr b fi la kx l ky kz">✦ <em class="lb">But we may do these tasks parallelly by using 2 different threads for first 2 steps.(Because all last 3 are dependency tasks) Then you could cut down the time little bit shorter than 15s.</em></span><span id="b7cf" class="kv ir hi kr b fi la kx l ky kz">✦✦✦ <strong class="kr hj">So accordingly there's no way that you can increase the no of threads and cutdown the process upto 1s or 2s and That's not Multi Threading.</strong></span></pre><h1 id="e8fa" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated"><strong class="ak">T3】多线程T5】</strong></h1><p id="c432" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">多线程可以定义为多个进程/多任务。</p><figure class="km kn ko kp fd ij er es paragraph-image"><div class="er es ld"><img src="../Images/fbca8230f67c0e09c8c8c3af42bdf136.png" data-original-src="https://miro.medium.com/v2/resize:fit:1002/format:webp/1*b7ysTkhTXgptCshTW-uoVQ.png"/></div></figure><p id="e0a8" class="pw-post-body-paragraph jo jp hi jq b jr le jt ju jv lf jx jy jz lg kb kc kd lh kf kg kh li kj kk kl hb bi translated"><strong class="jq hj">重要...</strong></p><p id="8b0a" class="pw-post-body-paragraph jo jp hi jq b jr le jt ju jv lf jx jy jz lg kb kc kd lh kf kg kh li kj kk kl hb bi translated"><em class="lb">如果您正在使用数量为</em> <strong class="jq hj"> <em class="lb"> n </em> </strong> <em class="lb">的文件，并且没有任何依赖关系，您希望将其工作时间缩短到最低，而这无法通过超过线程数甚至超过</em><strong class="jq hj"><em class="lb">【n .</em></strong><em class="lb">(当然，您可以使用n个线程，但不能超过n个)来实现，因为使用相同的线程来完成相同的任务是没有意义的。</em></p><h1 id="88f2" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated"><strong class="ak"> <em class="lc">我们怎样才能创建一个线程？</em>T25】</strong></h1><p id="5658" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">◾️通过扩展线程类</p><p id="5f6c" class="pw-post-body-paragraph jo jp hi jq b jr le jt ju jv lf jx jy jz lg kb kc kd lh kf kg kh li kj kk kl hb bi translated">◾️通过实现一个可运行的接口</p><h1 id="8ad7" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">如果子类扩展了线程类会怎么样？</h1><p id="28c8" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">让我们通过一个简单的例子来理解这一点</p><figure class="km kn ko kp fd ij er es paragraph-image"><div class="er es ld"><img src="../Images/ec741b7a262c1bc119cf3d611bec1a9e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1002/format:webp/1*gr93FfDEnv9_4gi-HNc1OQ.png"/></div></figure><p id="dc9e" class="pw-post-body-paragraph jo jp hi jq b jr le jt ju jv lf jx jy jz lg kb kc kd lh kf kg kh li kj kk kl hb bi translated">所以如果你想把这个Runner转换成一个线程，那么你必须从一个thread类扩展Runner类。所以当它扩展一个thread类时，Runner-Sportsman关系就会破裂。(我们可以通过实现Runnable接口来创建线程来解决这个问题)</p><blockquote class="lj"><p id="ee86" class="lk ll hi bd lm ln lo lp lq lr ls kl dx translated">一些与线程相关的隐藏场景</p></blockquote></div><div class="ab cl lt lu gp lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="hb hc hd he hf"><blockquote class="ma mb mc"><p id="ca92" class="jo jp lb jq b jr le jt ju jv lf jx jy md lg kb kc me lh kf kg mf li kj kk kl hb bi translated"><strong class="jq hj"> <em class="hi">场景1️⃣ </em> </strong></p></blockquote><p id="a1f5" class="pw-post-body-paragraph jo jp hi jq b jr le jt ju jv lf jx jy jz lg kb kc kd lh kf kg kh li kj kk kl hb bi translated"><strong class="jq hj">扩展线程类的时候一定要覆盖run()吗？</strong></p><figure class="km kn ko kp fd ij"><div class="bz dy l di"><div class="mg mh l"/></div></figure><figure class="km kn ko kp fd ij"><div class="bz dy l di"><div class="mg mh l"/></div></figure><pre class="km kn ko kp fd kq kr ks kt aw ku bi"><span id="571b" class="kv ir hi kr b fi kw kx l ky kz">Output - It will execute. But nothing will happen.</span></pre><p id="52b1" class="pw-post-body-paragraph jo jp hi jq b jr le jt ju jv lf jx jy jz lg kb kc kd lh kf kg kh li kj kk kl hb bi translated"><em class="lb">程序在这里发生:</em></p><p id="6fb4" class="pw-post-body-paragraph jo jp hi jq b jr le jt ju jv lf jx jy jz lg kb kc kd lh kf kg kh li kj kk kl hb bi translated">✦当转到应用程序类中的start()方法；它将转到Printer类并检查start()方法。</p><p id="dd7c" class="pw-post-body-paragraph jo jp hi jq b jr le jt ju jv lf jx jy jz lg kb kc kd lh kf kg kh li kj kk kl hb bi translated">✦但是因为在Printer类中没有start方法，所以它转到它的父类(Thread类)并检查start()方法。</p><p id="ca2c" class="pw-post-body-paragraph jo jp hi jq b jr le jt ju jv lf jx jy jz lg kb kc kd lh kf kg kh li kj kk kl hb bi translated">✦因为在Thread类中有一个start()方法，它将进入Thread类中的这个start()方法。</p><p id="86cc" class="pw-post-body-paragraph jo jp hi jq b jr le jt ju jv lf jx jy jz lg kb kc kd lh kf kg kh li kj kk kl hb bi translated">✦Within启动()，他们调用运行()。</p><p id="09de" class="pw-post-body-paragraph jo jp hi jq b jr le jt ju jv lf jx jy jz lg kb kc kd lh kf kg kh li kj kk kl hb bi translated">✦:所以它再次来到打印机类，检查是否有任何run()方法。因为没有run()方法，所以它转到Thread类并检查那里是否有可用的run()方法。</p><p id="4f68" class="pw-post-body-paragraph jo jp hi jq b jr le jt ju jv lf jx jy jz lg kb kc kd lh kf kg kh li kj kk kl hb bi translated">✦，然后它将执行线程类中的run()方法。</p><figure class="km kn ko kp fd ij er es paragraph-image"><div class="er es mi"><img src="../Images/fa389ef9be3180c19442b09937dd3bf0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1266/format:webp/1*ZIBMOEYa0czRRDe6CSRAlA.png"/></div></figure><p id="b715" class="pw-post-body-paragraph jo jp hi jq b jr le jt ju jv lf jx jy jz lg kb kc kd lh kf kg kh li kj kk kl hb bi translated">但是如果你正在实现一个可运行的接口，你必须覆盖接口中的所有方法，包括run()方法。</p><blockquote class="ma mb mc"><p id="b143" class="jo jp lb jq b jr le jt ju jv lf jx jy md lg kb kc me lh kf kg mf li kj kk kl hb bi translated"><strong class="jq hj"> <em class="hi">场景2️⃣ </em> </strong></p></blockquote><p id="fea7" class="pw-post-body-paragraph jo jp hi jq b jr le jt ju jv lf jx jy jz lg kb kc kd lh kf kg kh li kj kk kl hb bi translated"><strong class="jq hj">当多次执行下面的程序时，每次执行都会有不同的顺序。为什么？</strong></p><figure class="km kn ko kp fd ij"><div class="bz dy l di"><div class="mg mh l"/></div></figure><figure class="km kn ko kp fd ij"><div class="bz dy l di"><div class="mg mh l"/></div></figure><p id="4e7e" class="pw-post-body-paragraph jo jp hi jq b jr le jt ju jv lf jx jy jz lg kb kc kd lh kf kg kh li kj kk kl hb bi translated"><em class="lb">在执行时，没有办法知道主线程或子线程会先执行，因为没有这样的规则。</em></p><p id="3bc7" class="pw-post-body-paragraph jo jp hi jq b jr le jt ju jv lf jx jy jz lg kb kc kd lh kf kg kh li kj kk kl hb bi translated"><em class="lb">当启动一个线程时，它会将我们的线程添加到线程调度器中。而这个线程调度器如何工作完全取决于JRE(最后是它的JVM)。并且这个顺序从JVM到JVM是变化的。</em></p><blockquote class="ma mb mc"><p id="54ba" class="jo jp lb jq b jr le jt ju jv lf jx jy md lg kb kc me lh kf kg mf li kj kk kl hb bi translated"><strong class="jq hj"> <em class="hi">场景3️⃣ </em> </strong></p></blockquote><p id="6498" class="pw-post-body-paragraph jo jp hi jq b jr le jt ju jv lf jx jy jz lg kb kc kd lh kf kg kh li kj kk kl hb bi translated"><strong class="jq hj">这个start()方法有什么必要？那么如果我们直接调用run方法而不调用start方法会怎么样呢？</strong></p><p id="c709" class="pw-post-body-paragraph jo jp hi jq b jr le jt ju jv lf jx jy jz lg kb kc kd lh kf kg kh li kj kk kl hb bi translated"><em class="lb">让我们使用下面的代码示例来理解这个场景:</em></p><figure class="km kn ko kp fd ij"><div class="bz dy l di"><div class="mg mh l"/></div></figure><figure class="km kn ko kp fd ij"><div class="bz dy l di"><div class="mg mh l"/></div></figure><pre class="km kn ko kp fd kq kr ks kt aw ku bi"><span id="0aed" class="kv ir hi kr b fi kw kx l ky kz">OUTPUT - It will always execute the child class first before executing the main.</span></pre><p id="6472" class="pw-post-body-paragraph jo jp hi jq b jr le jt ju jv lf jx jy jz lg kb kc kd lh kf kg kh li kj kk kl hb bi translated"><em class="lb">根据这个场景，我们没有2个线程。</em></p><figure class="km kn ko kp fd ij er es paragraph-image"><div class="er es mi"><img src="../Images/c48a05b941e0d8bcf38b6d458c8dd35f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1266/format:webp/1*Su_YNJYQfmOcbuPadIjHXw.png"/></div></figure><p id="8aec" class="pw-post-body-paragraph jo jp hi jq b jr le jt ju jv lf jx jy jz lg kb kc kd lh kf kg kh li kj kk kl hb bi translated"><em class="lb">start()方法的使用:</em></p><p id="9060" class="pw-post-body-paragraph jo jp hi jq b jr le jt ju jv lf jx jy jz lg kb kc kd lh kf kg kh li kj kk kl hb bi translated"><em class="lb"> ✦✦✦✦在启动线程之前，它做一些如下的任务，</em></p><figure class="km kn ko kp fd ij er es paragraph-image"><div class="er es mj"><img src="../Images/d7eecd89f6ecfe5aa85d14078f89aece.png" data-original-src="https://miro.medium.com/v2/resize:fit:870/format:webp/1*fZbl8XeLGqMGZygZu3C3JA.png"/></div></figure><p id="c5c1" class="pw-post-body-paragraph jo jp hi jq b jr le jt ju jv lf jx jy jz lg kb kc kd lh kf kg kh li kj kk kl hb bi translated">但是如果我们调用一个start方法，我们不需要做上面的任何任务，JVM会做的。所以最后 <strong class="jq hj"> <em class="lb">当调用start()方法时，JVM做必要的事情并调用run方法。</em>T19】</strong></p><blockquote class="ma mb mc"><p id="e168" class="jo jp lb jq b jr le jt ju jv lf jx jy md lg kb kc me lh kf kg mf li kj kk kl hb bi translated"><strong class="jq hj"> <em class="hi">场景4️⃣ </em> </strong></p></blockquote><p id="f5db" class="pw-post-body-paragraph jo jp hi jq b jr le jt ju jv lf jx jy jz lg kb kc kd lh kf kg kh li kj kk kl hb bi translated">如果我们在printer类(一个扩展了thread类的类)中覆盖一个start方法会发生什么？</p><figure class="km kn ko kp fd ij"><div class="bz dy l di"><div class="mg mh l"/></div></figure><p id="0029" class="pw-post-body-paragraph jo jp hi jq b jr le jt ju jv lf jx jy jz lg kb kc kd lh kf kg kh li kj kk kl hb bi translated"><em class="lb">所以在这里，Printer类有一个start方法。所以它将在调用主类中的start方法时被执行。</em></p><p id="f44c" class="pw-post-body-paragraph jo jp hi jq b jr le jt ju jv lf jx jy jz lg kb kc kd lh kf kg kh li kj kk kl hb bi translated"><em class="lb">当覆盖start方法时，它会阻止创建新线程。(因为它阻止调用线程类的start方法)</em></p><p id="3d63" class="pw-post-body-paragraph jo jp hi jq b jr le jt ju jv lf jx jy jz lg kb kc kd lh kf kg kh li kj kk kl hb bi translated"><em class="lb">通过使用超级。start()，我们可以覆盖start方法，也将能够创建一个线程。</em></p><blockquote class="ma mb mc"><p id="5849" class="jo jp lb jq b jr le jt ju jv lf jx jy md lg kb kc me lh kf kg mf li kj kk kl hb bi translated"><strong class="jq hj"> <em class="hi"> Scenario5️⃣ </em> </strong></p></blockquote><p id="16a8" class="pw-post-body-paragraph jo jp hi jq b jr le jt ju jv lf jx jy jz lg kb kc kd lh kf kg kh li kj kk kl hb bi translated">如果我们重载run方法会发生什么？</p><p id="9611" class="pw-post-body-paragraph jo jp hi jq b jr le jt ju jv lf jx jy jz lg kb kc kd lh kf kg kh li kj kk kl hb bi translated">什么都不会发生，它会创建一个线程。因为<strong class="jq hj"><em class="lb">start方法总是会不带参数的调用run方法。</em> </strong></p><blockquote class="ma mb mc"><p id="a535" class="jo jp lb jq b jr le jt ju jv lf jx jy md lg kb kc me lh kf kg mf li kj kk kl hb bi translated"><strong class="jq hj"> <em class="hi"> Scenario6️⃣ </em> </strong></p></blockquote><p id="0783" class="pw-post-body-paragraph jo jp hi jq b jr le jt ju jv lf jx jy jz lg kb kc kd lh kf kg kh li kj kk kl hb bi translated"><strong class="jq hj">主线程终止会发生什么？会影响子线程吗？</strong></p><p id="ee6c" class="pw-post-body-paragraph jo jp hi jq b jr le jt ju jv lf jx jy jz lg kb kc kd lh kf kg kh li kj kk kl hb bi translated">没有！尽管主线程终止了，子线程可以继续执行。</p><p id="c3ec" class="pw-post-body-paragraph jo jp hi jq b jr le jt ju jv lf jx jy jz lg kb kc kd lh kf kg kh li kj kk kl hb bi translated"><em class="lb">但是如果我们想让子线程在主线程终止后终止，我们就得把子线程设置成守护线程。</em> <strong class="jq hj"> <em class="lb">(。setDaemon(true)) </em> </strong></p><figure class="km kn ko kp fd ij er es paragraph-image"><div class="er es mk"><img src="../Images/596c72e037da12d4220a0998fbdac758.png" data-original-src="https://miro.medium.com/v2/resize:fit:1270/format:webp/1*Ogc7vXuCgiBnrHGssK0gBw.png"/></div></figure><h1 id="3754" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">如何通过实现可运行接口☛来创建线程</h1><p id="6878" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">下面的代码片段展示了通过实现Runnable接口来创建线程类的方法。</p><figure class="km kn ko kp fd ij"><div class="bz dy l di"><div class="mg mh l"/></div></figure><p id="b162" class="pw-post-body-paragraph jo jp hi jq b jr le jt ju jv lf jx jy jz lg kb kc kd lh kf kg kh li kj kk kl hb bi translated">所以当这个类实现Runnable接口来给出线程行为时，这个类没有start方法来调用。因此，我们必须从thread类创建一个实例，然后将Runnable实例传递给它，如下所示。</p><figure class="km kn ko kp fd ij"><div class="bz dy l di"><div class="mg mh l"/></div></figure><h1 id="ea99" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">Thread类的构造函数</h1><p id="c263" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">✦螺纹()</p><p id="ea59" class="pw-post-body-paragraph jo jp hi jq b jr le jt ju jv lf jx jy jz lg kb kc kd lh kf kg kh li kj kk kl hb bi translated">✦线程(可运行目标)</p><p id="d0ba" class="pw-post-body-paragraph jo jp hi jq b jr le jt ju jv lf jx jy jz lg kb kc kd lh kf kg kh li kj kk kl hb bi translated">✦线程(可运行目标，字符串名称)</p><p id="1d59" class="pw-post-body-paragraph jo jp hi jq b jr le jt ju jv lf jx jy jz lg kb kc kd lh kf kg kh li kj kk kl hb bi translated">✦线程(字符串名称)</p><p id="f248" class="pw-post-body-paragraph jo jp hi jq b jr le jt ju jv lf jx jy jz lg kb kc kd lh kf kg kh li kj kk kl hb bi translated">✦线程(线程组组，可运行目标)</p><p id="dfdc" class="pw-post-body-paragraph jo jp hi jq b jr le jt ju jv lf jx jy jz lg kb kc kd lh kf kg kh li kj kk kl hb bi translated">✦线程(线程组组，可运行目标，字符串名称)</p><p id="5f54" class="pw-post-body-paragraph jo jp hi jq b jr le jt ju jv lf jx jy jz lg kb kc kd lh kf kg kh li kj kk kl hb bi translated">✦线程(线程组组，可运行目标，字符串名称，长堆栈大小)</p><p id="9094" class="pw-post-body-paragraph jo jp hi jq b jr le jt ju jv lf jx jy jz lg kb kc kd lh kf kg kh li kj kk kl hb bi translated">✦线程(线程组组，字符串名称)</p><h1 id="c214" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">线程优先级</h1><p id="07fc" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">在java中，线程优先级的范围是从1到10。最高线程优先级是10，最低线程优先级是1。</p><p id="991a" class="pw-post-body-paragraph jo jp hi jq b jr le jt ju jv lf jx jy jz lg kb kc kd lh kf kg kh li kj kk kl hb bi translated">主线程的默认线程优先级是5。此后，我们创建的任何线程都将继承父线程的值。</p><figure class="km kn ko kp fd ij er es paragraph-image"><div class="er es ml"><img src="../Images/748e80ca064004ca237dd4a0398eb08c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1204/format:webp/1*3su9aH2_46CgbYcNrGCMAg.png"/></div></figure><p id="c84f" class="pw-post-body-paragraph jo jp hi jq b jr le jt ju jv lf jx jy jz lg kb kc kd lh kf kg kh li kj kk kl hb bi translated">如果设置的优先级超出了期望的范围，会发生什么情况？</p><p id="14a6" class="pw-post-body-paragraph jo jp hi jq b jr le jt ju jv lf jx jy jz lg kb kc kd lh kf kg kh li kj kk kl hb bi translated"><em class="lb">抛出非法参数异常。</em></p><p id="f184" class="pw-post-body-paragraph jo jp hi jq b jr le jt ju jv lf jx jy jz lg kb kc kd lh kf kg kh li kj kk kl hb bi translated"><strong class="jq hj">如果两个线程拥有相同的优先级会发生什么？</strong></p><p id="5500" class="pw-post-body-paragraph jo jp hi jq b jr le jt ju jv lf jx jy jz lg kb kc kd lh kf kg kh li kj kk kl hb bi translated">不会发生什么事情。线程调度器将选择一个线程来运行。</p><h1 id="0e21" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">线程生命周期</h1><figure class="km kn ko kp fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mm"><img src="../Images/1186f29dad80aff83246397001a707dd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fotwb2GAGHgAqGZQ5g6t9Q.png"/></div></div><figcaption class="mn mo et er es mp mq bd b be z dx translated">图片说明:线程的生命周期</figcaption></figure><blockquote class="ma mb mc"><p id="a55b" class="jo jp lb jq b jr le jt ju jv lf jx jy md lg kb kc me lh kf kg mf li kj kk kl hb bi translated"><strong class="jq hj"> <em class="hi">螺纹连接方法</em> </strong></p></blockquote><p id="0eef" class="pw-post-body-paragraph jo jp hi jq b jr le jt ju jv lf jx jy jz lg kb kc kd lh kf kg kh li kj kk kl hb bi translated">线程连接方法允许等待，直到另一个线程完成它的执行。</p><p id="829c" class="pw-post-body-paragraph jo jp hi jq b jr le jt ju jv lf jx jy jz lg kb kc kd lh kf kg kh li kj kk kl hb bi translated">join方法中的三个不同的重载函数如下</p><p id="b3ed" class="pw-post-body-paragraph jo jp hi jq b jr le jt ju jv lf jx jy jz lg kb kc kd lh kf kg kh li kj kk kl hb bi translated">✯ .加入()</p><p id="58d9" class="pw-post-body-paragraph jo jp hi jq b jr le jt ju jv lf jx jy jz lg kb kc kd lh kf kg kh li kj kk kl hb bi translated">✯ .加入(长毫秒)</p><p id="4ab5" class="pw-post-body-paragraph jo jp hi jq b jr le jt ju jv lf jx jy jz lg kb kc kd lh kf kg kh li kj kk kl hb bi translated">✯ .join(长毫秒，int纳秒)</p><p id="49b6" class="pw-post-body-paragraph jo jp hi jq b jr le jt ju jv lf jx jy jz lg kb kc kd lh kf kg kh li kj kk kl hb bi translated">任何线程进入等待状态后，都无法直接进入运行状态。因此它必须再次进入“就绪/可运行”状态。</p><p id="c266" class="pw-post-body-paragraph jo jp hi jq b jr le jt ju jv lf jx jy jz lg kb kc kd lh kf kg kh li kj kk kl hb bi translated">下面是线程可以进入可运行状态的情况。</p><p id="6313" class="pw-post-body-paragraph jo jp hi jq b jr le jt ju jv lf jx jy jz lg kb kc kd lh kf kg kh li kj kk kl hb bi translated"><em class="lb"> ✯✯✯ </em> <strong class="jq hj"> <em class="lb">是否超时。</em> </strong></p><p id="c7a7" class="pw-post-body-paragraph jo jp hi jq b jr le jt ju jv lf jx jy jz lg kb kc kd lh kf kg kh li kj kk kl hb bi translated"><em class="lb"> ✯✯✯ </em> <strong class="jq hj"> <em class="lb">如果另一个线程完成了它的任务。</em> </strong></p><p id="9a2a" class="pw-post-body-paragraph jo jp hi jq b jr le jt ju jv lf jx jy jz lg kb kc kd lh kf kg kh li kj kk kl hb bi translated"><em class="lb"/><strong class="jq hj"><em class="lb">如果有人打断了等待状态。</em>T29】</strong></p><h1 id="e5af" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">Thread yield()方法</h1><p id="d7dc" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">★产量法是原生法。</p><p id="3acd" class="pw-post-body-paragraph jo jp hi jq b jr le jt ju jv lf jx jy jz lg kb kc kd lh kf kg kh li kj kk kl hb bi translated">★可用于调试场景。(当我们想给特定场景更多机会时)</p><p id="8832" class="pw-post-body-paragraph jo jp hi jq b jr le jt ju jv lf jx jy jz lg kb kc kd lh kf kg kh li kj kk kl hb bi translated">当一个线程使用让步方法时，那个<strong class="jq hj"> <em class="lb">给线程调度器一个信号，给其他线程一个机会。</em> </strong>因此，如果线程调度程序决定给予机会，那么调用yield方法的特定线程将进入其“等待状态”，另一个线程将执行。</p><p id="7076" class="pw-post-body-paragraph jo jp hi jq b jr le jt ju jv lf jx jy jz lg kb kc kd lh kf kg kh li kj kk kl hb bi translated">示例:</p><figure class="km kn ko kp fd ij er es paragraph-image"><div class="er es mr"><img src="../Images/221ac9f2b040dc9b82d363a6508cc598.png" data-original-src="https://miro.medium.com/v2/resize:fit:1382/format:webp/1*LGhkZdcLbOJnTFn5nwmCUQ.png"/></div></figure><h1 id="02e1" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">线程sleep()方法</h1><p id="eba1" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">★没有不带参数的方法。</p><p id="ac58" class="pw-post-body-paragraph jo jp hi jq b jr le jt ju jv lf jx jy jz lg kb kc kd lh kf kg kh li kj kk kl hb bi translated">★可以等待一定的给定时间。</p><p id="117b" class="pw-post-body-paragraph jo jp hi jq b jr le jt ju jv lf jx jy jz lg kb kc kd lh kf kg kh li kj kk kl hb bi translated">★有两个不同的方法签名。</p><ol class=""><li id="7dd9" class="ms mt hi jq b jr le jv lf jz mu kd mv kh mw kl mx my mz na bi translated">。睡眠(长毫秒)⇾这是一个本地方法</li><li id="0e57" class="ms mt hi jq b jr nb jv nc jz nd kd ne kh nf kl mx my mz na bi translated">。(长毫秒睡眠，nanoseconds)⇾这是<strong class="jq hj">而不是</strong>一个原生方法</li></ol><p id="04a6" class="pw-post-body-paragraph jo jp hi jq b jr le jt ju jv lf jx jy jz lg kb kc kd lh kf kg kh li kj kk kl hb bi translated">★当调用sleep()时，</p><p id="2900" class="pw-post-body-paragraph jo jp hi jq b jr le jt ju jv lf jx jy jz lg kb kc kd lh kf kg kh li kj kk kl hb bi translated">⇾线程在特定的给定时间内进入等待状态。如果等待时间到期或发生任何中断，则返回<strong class="jq hj"> <em class="lb">。</em> </strong></p><h1 id="4971" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">线程中断()方法</h1><p id="4488" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">★一次中断只对一个睡眠时刻有效。</p><p id="610f" class="pw-post-body-paragraph jo jp hi jq b jr le jt ju jv lf jx jy jz lg kb kc kd lh kf kg kh li kj kk kl hb bi translated">★如果我们在一个没有休眠的线程上调用一个中断方法，⇾中断会一直等到那个线程进入“休眠”或“等待”状态，然后会戳到那个线程。</p><p id="4c60" class="pw-post-body-paragraph jo jp hi jq b jr le jt ju jv lf jx jy jz lg kb kc kd lh kf kg kh li kj kk kl hb bi translated"><strong class="jq hj"> <em class="lb">参考文献</em> </strong></p><figure class="km kn ko kp fd ij"><div class="bz dy l di"><div class="ng mh l"/></div></figure><div class="nh ni ez fb nj nk"><a href="https://www.geeksforgeeks.org/java-concurrency-yield-sleep-and-join-methods/" rel="noopener  ugc nofollow" target="_blank"><div class="nl ab dw"><div class="nm ab nn cl cj no"><h2 class="bd hj fi z dy np ea eb nq ed ef hh bi translated">Java并发性——yield()、sleep()和join()方法——GeeksforGeeks</h2><div class="nr l"><h3 class="bd b fi z dy np ea eb nq ed ef dx translated">Java Concurrency - yield()、sleep()和join()方法我们可以通过使用一个…</h3></div><div class="ns l"><p class="bd b fp z dy np ea eb nq ed ef dx translated">www.geeksforgeeks.org</p></div></div><div class="nt l"><div class="nu l nv nw nx nt ny io nk"/></div></div></a></div><div class="nh ni ez fb nj nk"><a href="https://www.w3schools.com/java/java_threads.asp" rel="noopener  ugc nofollow" target="_blank"><div class="nl ab dw"><div class="nm ab nn cl cj no"><h2 class="bd hj fi z dy np ea eb nq ed ef hh bi translated">Java线程</h2><div class="nr l"><h3 class="bd b fi z dy np ea eb nq ed ef dx translated">线程允许程序通过同时做多件事情来更有效地运行。螺纹可用于…</h3></div><div class="ns l"><p class="bd b fp z dy np ea eb nq ed ef dx translated">www.w3schools.com</p></div></div><div class="nt l"><div class="nz l nv nw nx nt ny io nk"/></div></div></a></div></div></div>    
</body>
</html>