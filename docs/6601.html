<html>
<head>
<title>React18: New Features and Updates</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">React18:新功能和更新</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/react18-new-features-and-updates-939624e07301?source=collection_archive---------0-----------------------#2022-03-31">https://medium.com/nerd-for-tech/react18-new-features-and-updates-939624e07301?source=collection_archive---------0-----------------------#2022-03-31</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/53e3ba5848ddf5dfbc57955d8849d3b9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5aL3z_DZkbtfAccFdp9h0Q.png"/></div></div></figure><p id="b1e8" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">React 18现已在npm上可用，并为React.js开发社区提供了一些令人兴奋的功能和更新。所有更新的主要目的是通过引入开箱即用的功能和改进来维护第三方库。</p><p id="0933" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">React 18新功能和改进是可能的，这要归功于React 18中新的选择加入“并发渲染”机制，该机制使React能够同时创建多个版本的UI。虽然这种变化主要是在幕后，但它将开启新的可能性，以提高应用程序的性能。</p><h1 id="fb83" class="jo jp hi bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">安装</h1><p id="e50a" class="pw-post-body-paragraph iq ir hi is b it km iv iw ix kn iz ja jb ko jd je jf kp jh ji jj kq jl jm jn hb bi translated">要安装React的最新版本:</p><pre class="kr ks kt ku fd kv kw kx ky aw kz bi"><span id="f488" class="la jp hi kw b fi lb lc l ld le">npm install react react-dom</span></pre><p id="70c7" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">或者如果你用的是纱线:</p><pre class="kr ks kt ku fd kv kw kx ky aw kz bi"><span id="5bc3" class="la jp hi kw b fi lb lc l ld le">yarn add react react-dom</span></pre><h1 id="8702" class="jo jp hi bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">介绍新的根API</h1><p id="5854" class="pw-post-body-paragraph iq ir hi is b it km iv iw ix kn iz ja jb ko jd je jf kp jh ji jj kq jl jm jn hb bi translated">React中的一个<strong class="is hj">根</strong>指向呈现树的顶层数据结构。在React 18中，我们将有两个根API:遗留的根API和新的根API。</p><h1 id="8772" class="jo jp hi bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">传统根API</h1><p id="6554" class="pw-post-body-paragraph iq ir hi is b it km iv iw ix kn iz ja jb ko jd je jf kp jh ji jj kq jl jm jn hb bi translated">遗留根API是用<strong class="is hj"> ReactDOM.render </strong>方法调用的现有API。它将创建一个在<strong class="is hj">遗留</strong>模式下运行的根，这类似于React版本17中的用法。它将逐步强制使用新的根API。在即将到来的版本中，旧的根API将被弃用。</p><p id="889a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">请参考下面的代码示例。</p><pre class="kr ks kt ku fd kv kw kx ky aw kz bi"><span id="3a8e" class="la jp hi kw b fi lb lc l ld le">import * as ReactDOM from 'react-dom';<br/>import App from 'App';</span><span id="7f76" class="la jp hi kw b fi lf lc l ld le">const container = document.getElementById(‘root’);</span><span id="c55a" class="la jp hi kw b fi lf lc l ld le">// Initial render.<br/>ReactDOM.render(&lt;App tab="home" /&gt;, container);</span><span id="47d1" class="la jp hi kw b fi lf lc l ld le">// During an update, React will access the container element again. <br/>ReactDOM.render(&lt;App tab="profile" /&gt;, container);</span></pre><h1 id="e67a" class="jo jp hi bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">新建根API</h1><p id="c8cf" class="pw-post-body-paragraph iq ir hi is b it km iv iw ix kn iz ja jb ko jd je jf kp jh ji jj kq jl jm jn hb bi translated">新的根API将通过<strong class="is hj"> ReactDOM.createRoot </strong>方法调用。要使用它，首先，我们必须用root元素作为参数通过<strong class="is hj"> createRoot </strong>方法创建根。然后，我们调用<strong class="is hj"> <em class="lg"> root.render </em> </strong>方法，将app组件作为参数传递。通过使用新的根API，我们可以使用React 18中所有可用的增强和并发特性。</p><p id="84c1" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">参考下面的代码。</p><pre class="kr ks kt ku fd kv kw kx ky aw kz bi"><span id="b466" class="la jp hi kw b fi lb lc l ld le">import * as ReactDOM from 'react-dom';<br/>import App from 'App';</span><span id="c67a" class="la jp hi kw b fi lf lc l ld le">// Create a root.<br/>const root = ReactDOM.createRoot(document.getElementById('root'));<br/></span><span id="1da9" class="la jp hi kw b fi lf lc l ld le">// Initial render: Render an element to the root.<br/>root.render(&lt;App tab="home" /&gt;);</span><span id="14ca" class="la jp hi kw b fi lf lc l ld le">// During an update, there's no need to access the container again since we have already defined the root instance. <br/>root.render(&lt;App tab="profile" /&gt;);</span></pre><h1 id="797e" class="jo jp hi bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">水合物法的变化</h1><p id="a878" class="pw-post-body-paragraph iq ir hi is b it km iv iw ix kn iz ja jb ko jd je jf kp jh ji jj kq jl jm jn hb bi translated"><strong class="is hj">水合物</strong>方法类似于渲染方法。但是它有助于将事件监听器附加到由服务器端的<strong class="is hj"> ReactDOMServer </strong>方法呈现的容器中的HTML元素。</p><p id="cae8" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">React 18将这种<strong class="is hj">水合物</strong>方法替换为<strong class="is hj">水合物</strong>方法。</p><p id="eb5a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">请参考下面的代码示例。</p><pre class="kr ks kt ku fd kv kw kx ky aw kz bi"><span id="776b" class="la jp hi kw b fi lb lc l ld le">import * as ReactDOM from 'react-dom';</span><span id="b36d" class="la jp hi kw b fi lf lc l ld le">import App from 'App';</span><span id="ced1" class="la jp hi kw b fi lf lc l ld le">const container = document.getElementById('app');</span><span id="e7ff" class="la jp hi kw b fi lf lc l ld le">// Create and render a root with hydration.<br/>const root = ReactDOM.hydrateRoot(container, &lt;App tab="home" /&gt;);<br/>// Unlike the createRoot method, you don't need a separate root.render() call here.</span></pre><h1 id="1a8f" class="jo jp hi bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">渲染回调中的更改</h1><p id="7cd2" class="pw-post-body-paragraph iq ir hi is b it km iv iw ix kn iz ja jb ko jd je jf kp jh ji jj kq jl jm jn hb bi translated">渲染回调从新的根API中移除。但是我们可以将它作为属性传递给根组件。</p><p id="1314" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">请参考下面的代码示例。</p><pre class="kr ks kt ku fd kv kw kx ky aw kz bi"><span id="270d" class="la jp hi kw b fi lb lc l ld le">import * as ReactDOM from 'react-dom';</span><span id="9a5c" class="la jp hi kw b fi lf lc l ld le">function App({ callback }) {<br/> // Callback will be called when the div element is first created.<br/> return (<br/> &lt;div ref={callback}&gt;<br/>   &lt;h1&gt;Hello &lt;/h1&gt;<br/> &lt;/div&gt;<br/> );<br/>}<br/>const rootElement = document.getElementById("root");</span><span id="2711" class="la jp hi kw b fi lf lc l ld le">const root = ReactDOM.createRoot(rootElement);<br/>root.render(&lt;App callback={() =&gt; console.log("renderered")} /&gt;);</span></pre><h1 id="d90e" class="jo jp hi bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">自动配料</h1><p id="5b83" class="pw-post-body-paragraph iq ir hi is b it km iv iw ix kn iz ja jb ko jd je jf kp jh ji jj kq jl jm jn hb bi translated">批处理是一次重新渲染中的多次反应状态更新。</p><pre class="kr ks kt ku fd kv kw kx ky aw kz bi"><span id="a1c5" class="la jp hi kw b fi lb lc l ld le">function Counter() {<br/>  const [count, setCount] = useState(0);<br/>  const [disabled, setDisabled] = useState(false);</span><span id="2abe" class="la jp hi kw b fi lf lc l ld le">  function handleClick() {<br/>    setCount(c =&gt; c + 1); // does not re-render yet<br/>    setDisabled(f =&gt; !f); // does not re-render yet<br/>    // React will only re-render once (that's batching!)<br/>  }</span><span id="ce35" class="la jp hi kw b fi lf lc l ld le">  return (<br/>    &lt;div&gt;<br/>      &lt;h1&gt;{count}&lt;/h1&gt;<br/>      &lt;button disabled={disabled} onClick={handleClick}&gt;<br/>        Increment<br/>      &lt;/button&gt;<br/>    &lt;/div&gt;<br/>  );<br/>}</span></pre><p id="e0d0" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">上面，我们有<code class="du lh li lj kw b">count</code>和<code class="du lh li lj kw b">disabled</code>两种反应状态。当我们点击一个按钮时，React总是批处理并在一次重新渲染中更新它们。</p><p id="0a57" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这避免了不必要的重新渲染，提高了我们的性能。异步请求呢？React 17不进行批处理，而是进行两次独立的更新。</p><pre class="kr ks kt ku fd kv kw kx ky aw kz bi"><span id="7b50" class="la jp hi kw b fi lb lc l ld le">function Counter() {<br/>  const [count, setCount] = useState(0);<br/>  const [disabled, setDisabled] = useState(false);</span><span id="a991" class="la jp hi kw b fi lf lc l ld le">  function handleClick() {<br/>    doPostRequest()<br/>      .then(() =&gt; {<br/>        setCount(c =&gt; c + 1); // does re-render<br/>        setDisabled(f =&gt; !f); // does re-render<br/>      })<br/>  }</span><span id="9244" class="la jp hi kw b fi lf lc l ld le">  return (<br/>    &lt;div&gt;<br/>      &lt;h1&gt;{count}&lt;/h1&gt;<br/>      &lt;button disabled={disabled} onClick={handleClick}&gt;<br/>        Increment<br/>      &lt;/button&gt;<br/>    &lt;/div&gt;<br/>  );<br/>}</span></pre><p id="140d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在，在React 18中，我们可以在<code class="du lh li lj kw b">promises</code>、<code class="du lh li lj kw b">setTimeout</code>、<code class="du lh li lj kw b">native event handlers</code>或任何其他事件中批量更新状态。</p><h1 id="7b89" class="jo jp hi bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">禁用自动批处理</h1><p id="0b29" class="pw-post-body-paragraph iq ir hi is b it km iv iw ix kn iz ja jb ko jd je jf kp jh ji jj kq jl jm jn hb bi translated">有时，我们需要在每次状态改变后立即重新呈现组件。在这种情况下，使用<strong class="is hj"> flushSync </strong>方法来禁用自动批处理。</p><pre class="kr ks kt ku fd kv kw kx ky aw kz bi"><span id="f3c0" class="la jp hi kw b fi lb lc l ld le">import { flushSync } from 'react-dom'; // Note: react-dom, not react</span><span id="4e2d" class="la jp hi kw b fi lf lc l ld le">function handleClick() {<br/>  flushSync(() =&gt; {<br/>    setCounter(c =&gt; c + 1);<br/>  });<br/>  // React has updated the DOM by now.<br/>  flushSync(() =&gt; {<br/>    setFlag(f =&gt; !f);<br/>  });<br/>  // React has updated the DOM by now.<br/>}</span></pre><h1 id="446e" class="jo jp hi bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">服务器端渲染</h1><p id="55af" class="pw-post-body-paragraph iq ir hi is b it km iv iw ix kn iz ja jb ko jd je jf kp jh ji jj kq jl jm jn hb bi translated">通过<code class="du lh li lj kw b">Suspense</code>，React 18通过使异步服务应用程序的各个部分成为可能，对SSR进行了重大的性能改进。</p><p id="ebd3" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">服务器端呈现允许您从提供的React组件生成HTML文本，然后加载JavaScript代码并与HTML合并(称为水合)。</p><p id="ed79" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在，有了<code class="du lh li lj kw b">Suspense</code>，你可以把你的应用分成小的、独立的单元，这些单元可以独立呈现，不需要应用的其他部分，让你的用户可以比以前更快地获得内容。</p><p id="85d1" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">假设您有两个组件:一个文本组件和一个图像组件。如果你像这样把它们叠在一起:</p><pre class="kr ks kt ku fd kv kw kx ky aw kz bi"><span id="3bfa" class="la jp hi kw b fi lb lc l ld le">&lt;Text /&gt;<br/> &lt;Image /&amp;gt;</span></pre><p id="c150" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">然后，服务器试图立刻呈现它们，减慢了整个页面的速度。如果文本对您的读者更重要，您可以通过将<code class="du lh li lj kw b">Image</code>组件包装在<code class="du lh li lj kw b">Suspense</code>标签中，使其优先于图像:</p><pre class="kr ks kt ku fd kv kw kx ky aw kz bi"><span id="1331" class="la jp hi kw b fi lb lc l ld le">&lt;Text /&gt;<br/>    &lt;Suspense fallback={&lt;Spinner /&gt;}&gt;<br/>         &lt;Image /&gt;   <br/>    &lt;/Suspense&gt;</span></pre><p id="71f9" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这一次，服务器首先为您的文本组件提供服务，当您的图像等待加载时，会显示一个微调器。</p><h1 id="a17c" class="jo jp hi bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">过渡</h1><p id="2a4f" class="pw-post-body-paragraph iq ir hi is b it km iv iw ix kn iz ja jb ko jd je jf kp jh ji jj kq jl jm jn hb bi translated">React 18最重要的更新之一是引入了<strong class="is hj"><em class="lg">start transition</em></strong>API，即使在大屏幕更新期间，也能让你的应用保持响应。<br/>有时在繁重的更新操作过程中，你的应用程序变得没有响应，<strong class="is hj"><em class="lg">start transition</em></strong>API对于处理这种情况非常有用。<br/>API允许用户控制并发方面，以改善用户交互。这是通过将繁重的更新包装为“<strong class="is hj"><em class="lg">start transition</em></strong>”来完成的，并且只有在启动更紧急的更新时才会被中断。因此，它实际上分类紧急更新和缓慢更新。<br/>如果过渡被用户操作中断，React将会抛出尚未完成的陈旧渲染工作，并且将只渲染最新的更新。</p><h1 id="421e" class="jo jp hi bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">结论</h1><p id="7703" class="pw-post-body-paragraph iq ir hi is b it km iv iw ix kn iz ja jb ko jd je jf kp jh ji jj kq jl jm jn hb bi translated">感谢阅读，希望这篇文章对你有用。即将发布的React 18稳定版将为开发者社区带来一系列激动人心的新功能。主要重点是并发性和逐步升级到新版本。</p></div></div>    
</body>
</html>