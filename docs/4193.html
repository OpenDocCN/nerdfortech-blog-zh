<html>
<head>
<title>Count the triplets:</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">数三胞胎:</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/count-the-triplets-5e5b4c03d90c?source=collection_archive---------9-----------------------#2021-07-10">https://medium.com/nerd-for-tech/count-the-triplets-5e5b4c03d90c?source=collection_archive---------9-----------------------#2021-07-10</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="19fd" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">数组</p><p id="9efa" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">问题:</strong>这里他们给了一个N个整数的数组A[ ]。我们必须找出三元组(I，j，k)的个数，其中I，j和k是指数，并且(1≤i &lt; j &lt; k≤N)使得在集合{Ai，Aj，Ak}中至少有一个数可以写成另外两个数的和。</p><pre class="jd je jf jg fd jh ji jj jk aw jl bi"><span id="2144" class="jm jn hi ji b fi jo jp l jq jr"><strong class="ji hj">input </strong>: A[] = {1, 2, 3, 4, 5}<br/><strong class="ji hj">Output </strong>: 4<br/>The valid triplets are:<br/>(1, 2, 3), (1, 3, 4), (1, 4, 5), (2, 3, 5)</span></pre><p id="139b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">基本上，上面的问题陈述意味着，你必须从给定的数组中找出三个元素，使得两个元素相加得到第三个元素。</p><div class="js jt ez fb ju jv"><a href="https://practice.geeksforgeeks.org/problems/count-the-triplets4615/1" rel="noopener  ugc nofollow" target="_blank"><div class="jw ab dw"><div class="jx ab jy cl cj jz"><h2 class="bd hj fi z dy ka ea eb kb ed ef hh bi translated">数三胞胎|练习|极客</h2><div class="kc l"><h3 class="bd b fi z dy ka ea eb kb ed ef dx translated">给定一个不同整数的数组。任务是计算所有的三元组，使得两个元素的和等于…</h3></div><div class="kd l"><p class="bd b fp z dy ka ea eb kb ed ef dx translated">practice.geeksforgeeks.org</p></div></div><div class="ke l"><div class="kf l kg kh ki ke kj kk jv"/></div></div></a></div><p id="215d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">解决方案:</p><p id="ed4d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这里我们需要跟踪两个重要的细节:</p><ol class=""><li id="2956" class="kl km hi ih b ii ij im in iq kn iu ko iy kp jc kq kr ks kt bi translated">数组元素的最大值。</li><li id="a1c3" class="kl km hi ih b ii ku im kv iq kw iu kx iy ky jc kq kr ks kt bi translated">创建一个频率表或哈希表，范围从0到最大值，并跟踪每个元素的频率(出现的次数)。</li></ol><p id="ccee" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">以上是需要注意的两个基本步骤。然后，我们需要考虑四种情况来解决这个问题。</p><h1 id="8459" class="kz jn hi bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated"><strong class="ak">数组元素的最大值</strong></h1><p id="46bb" class="pw-post-body-paragraph if ig hi ih b ii lw ik il im lx io ip iq ly is it iu lz iw ix iy ma ja jb jc hb bi translated">这里，我们使用内置的max函数来查找给定数组元素的最大值。</p><p id="0132" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">for(int I = 0；I&lt;N；i++)<br/>{<br/>max _ value = max(array[I]，max _ value)；<br/> } </strong></p><p id="999a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">注意:这里，我们将创建频率表，并通过频率表而不是给定的数组遍历元素。</p><h1 id="00b1" class="kz jn hi bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated"><strong class="ak">创建频率表</strong></h1><p id="6955" class="pw-post-body-paragraph if ig hi ih b ii lw ik il im lx io ip iq ly is it iu lz iw ix iy ma ja jb jc hb bi translated">这里，我们将处理满足三联体条件的四种不同类型的组合。为此，我们将遍历频率表，直到它满足条件并取值。我们不会遍历数组并获取值。</p><p id="2a47" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">频率表不过是一个数组，甚至可以说是一种数组数据结构，在这种结构中，我们记录一个特定元素在数组中出现的次数，从0到数组中出现的最大元素。</p><p id="f296" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">例如，假设数组为:</p><figure class="jd je jf jg fd mc er es paragraph-image"><div class="er es mb"><img src="../Images/7b8fb2842b2591c9d9eb11968baa4297.png" data-original-src="https://miro.medium.com/v2/resize:fit:744/format:webp/1*tNwN7_svWSbJlcMKAmOD0w.png"/></div></figure><p id="8dbc" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">然后频率表存储，</p><figure class="jd je jf jg fd mc er es paragraph-image"><div class="er es me"><img src="../Images/202ef5a59f7ec17d7100b944ac7c185e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1108/format:webp/1*qszyxzX7IodatKNx1K1Ecw.png"/></div></figure><p id="3440" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">用于创建频率表的代码如下:</p><p id="85af" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">int freq[max _ value+1]= { 0 }；</strong></p><p id="540b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这就是我们初始化频率表的方式。我们使用(max_value+1)是因为，计数为0也将与它一起被计数。</p><p id="ea52" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">for(int I = 0；我&lt;N；i++) // N表示数组元素的个数<br/>{<br/>freq[array[I]]++；<br/> } </strong></p><p id="7444" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">对我个人来说，这一步有点难以理解，但是当你想象在每一次迭代中发生的过程时，这是非常简单的。</p><figure class="jd je jf jg fd mc er es paragraph-image"><div role="button" tabindex="0" class="mg mh di mi bf mj"><div class="er es mf"><img src="../Images/82c8fab2677a5b087252fc17040acfc8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jWIQBdCIKqPsAmjR34NjJQ.png"/></div></div></figure><figure class="jd je jf jg fd mc er es paragraph-image"><div role="button" tabindex="0" class="mg mh di mi bf mj"><div class="er es mk"><img src="../Images/a8be9a6eb4590fb057318524c62f7c8b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VvzwUYOKOFkadZ44lW_AOA.png"/></div></div></figure><p id="bfec" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">借助上图，你可以理解数组中每个元素的频率是如何统计和存储的。</p><p id="4541" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在下一步之前，我们必须声明并初始化一些变量，比如ans为0，以存储根据案例解决问题的方法。例如，如果它满足情况1，那么它的计数将被增加。最后，我们必须返回这个值作为最终答案，因为它代表了形成的三元组的总数。</p><h1 id="9482" class="kz jn hi bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">案例1: (0，0，0)</h1><p id="0f51" class="pw-post-body-paragraph if ig hi ih b ii lw ik il im lx io ip iq ly is it iu lz iw ix iy ma ja jb jc hb bi translated">因为0 + 0 = 0(满足三元组的条件)，所以属于三元组的所有三个数都可以是0</p><p id="0bc0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们需要找到所有包含频率为零的组合。</p><p id="88fb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">数学上，上面的语句表示<strong class="ih hj"> <em class="ml"> f(0)C3 </em> </strong>(因为在零频率中，我们只想选择三个一组)</p><p id="8a6b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">C3 = [f(0)！] / [(f(0)-3)！— 3!]</p><p id="e5dc" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">当你简化上面的步骤时，你会得到下面的等式。</p><p id="c0db" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">ans+=(freq[0])*(freq[0]-1)*(freq[0]-2)/6；</strong></p><h1 id="c248" class="kz jn hi bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">情况2: (0，x，x)</h1><p id="869c" class="pw-post-body-paragraph if ig hi ih b ii lw ik il im lx io ip iq ly is it iu lz iw ix iy ma ja jb jc hb bi translated">0 + x = x，因此它满足三联体条件。</p><p id="d4a4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在，我们需要找到包含一个0和两个x的组合。作为一个等式，它如下:</p><p id="ce0c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">f(x)C2 * f(0)C1(这里，我们将对x的每个值使用循环来遍历数组)</p><p id="0ccc" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">for(int I = 1；I&lt;= max _ value；i++)<br/>{<br/>ans+= freq[0]* freq[I]*(freq[I]-1)/2；<br/> } </strong></p><h1 id="8b76" class="kz jn hi bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">案例3: (x，x，2x)</h1><p id="d9bb" class="pw-post-body-paragraph if ig hi ih b ii lw ik il im lx io ip iq ly is it iu lz iw ix iy ma ja jb jc hb bi translated">这里，x+x=2x，因此它满足三联体条件。</p><p id="a128" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">所以这里我们需要找到包含两个x和一个2*x的组合，大概是这样的:</p><p id="6bc1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">f(x)C2 * f(2x)C1。(这里，我们将进行循环，直到索引值小于2*x，因为2*x也应该在循环内)</p><p id="7a7d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">for(int I = 1；2 * I&lt;= max _ value；i++) // 2次I应该也在max value<br/>{<br/>ans+= freq[I]*(freq[I]-1)/2 * freq[2 * I]里面；<br/> } </strong></p><h1 id="481d" class="kz jn hi bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">情况4: (x，y，x+y)</h1><p id="fe78" class="pw-post-body-paragraph if ig hi ih b ii lw ik il im lx io ip iq ly is it iu lz iw ix iy ma ja jb jc hb bi translated">这里，前两个值的和等于第三个值，因此它满足三元组条件。</p><p id="3d11" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这里，我们需要找到包含一个x，一个y和一个x+y的组合，简化的组合如下:</p><p id="7e39" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">f(x)C1*f(y)C1*f(x+y)C1(这里我们将创建两个循环，其中一个嵌套在另一个中，在第二个循环中，x+y应该小于max_value，因为x+y也应该出现在循环中)</p><p id="ce8e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">for(int I = 1；I&lt;= max _ value；i++)<br/>{<br/>for(int j = I+1；j+I&lt;= max _ value；j++)<br/>{<br/>ans+= freq[I]* freq[j]* freq[I+j]；<br/> } <br/> } </strong></p><p id="d109" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">而我的朋友们，最后一步无非是在使用上述步骤得出解决方案后返回答案。如果它满足一个特定的情况，那么它的计数将被增加，并返回适当的解决方案。</p><p id="bc60" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我希望你们发现这篇文章是有用和有帮助的，如果你们能给我宝贵的反馈，我会非常感激。干杯！</p></div></div>    
</body>
</html>