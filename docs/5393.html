<html>
<head>
<title>LeetCode — 3Sum closest</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">LeetCode — 3Sum最接近</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/leetcode-3sum-closest-dbe05ad5a779?source=collection_archive---------6-----------------------#2021-09-26">https://medium.com/nerd-for-tech/leetcode-3sum-closest-dbe05ad5a779?source=collection_archive---------6-----------------------#2021-09-26</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><h1 id="1ec7" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">问题陈述</h1><p id="5a8a" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">给定一个长度为<strong class="jf hj"> n </strong>的整数数组<strong class="jf hj"> nums </strong>和一个整数<strong class="jf hj"> target </strong>，在<strong class="jf hj"> nums </strong>中找出三个整数，使得总和最接近<strong class="jf hj"> target </strong>。</p><p id="ab3d" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">返回三个整数之和。</p><p id="02d7" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">你可以假设每个输入都有一个解。</p><p id="d385" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">问题陈述摘自:<a class="ae kh" href="https://leetcode.com/problems/3sum-closest" rel="noopener ugc nofollow" target="_blank">https://leetcode.com/problems/3sum-closest</a></p><p id="b9d3" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated"><strong class="jf hj">例1: </strong></p><pre class="ki kj kk kl fd km kn ko kp aw kq bi"><span id="2cb3" class="kr ig hi kn b fi ks kt l ku kv">Input: nums = [-1, 2, 1, -4], target = 1 <br/>Output: 2 <br/>Explanation: The sum that is closest to the target is 2. (-1 + 2 + 1 = 2).</span></pre><p id="b4ca" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated"><strong class="jf hj">例2: </strong></p><pre class="ki kj kk kl fd km kn ko kp aw kq bi"><span id="ae10" class="kr ig hi kn b fi ks kt l ku kv">Input: nums = [0, 0, 0], target = 1 <br/>Output: 0</span></pre><p id="1436" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated"><strong class="jf hj">约束:</strong></p><pre class="ki kj kk kl fd km kn ko kp aw kq bi"><span id="c192" class="kr ig hi kn b fi ks kt l ku kv">- 3 &lt;= nums.length &lt;= 1000 <br/>- -1000 &lt;= nums[i] &lt;= 1000 <br/>- -10^4 &lt;= target &lt;= 10^4</span></pre><h1 id="9c38" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">说明</h1><h2 id="8716" class="kr ig hi bd ih kw kx ky il kz la lb ip jo lc ld it js le lf ix jw lg lh jb li bi translated">强力方法</h2><p id="735b" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">解决该问题的一个简单方法是探索所有大小为3的子集，并跟踪<strong class="jf hj">目标</strong>和该子集之和之间的差异。然后返回sum和target之差最小的子集。</p><p id="1206" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">上述方法的C++实现如下所示:</p><pre class="ki kj kk kl fd km kn ko kp aw kq bi"><span id="92f9" class="kr ig hi kn b fi ks kt l ku kv">for (int i = 0; i &lt; arr.size() ; i++)<br/>{<br/>    for(int j =i + 1; j &lt; arr.size(); j++)<br/>    {<br/>        for(int k =j + 1; k &lt; arr.size(); k++)<br/>        {<br/>            //update the closestSum<br/>            if(abs(x - closestSum) &gt; abs(x - (arr[i] + arr[j] + arr[k])))<br/>                closestSum = (arr[i] + arr[j] + arr[k]);<br/>        }<br/>    }<br/>}<br/><br/>return closestSum</span></pre><p id="c02e" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">由于我们使用了三个嵌套循环，上述方法的时间复杂度为<strong class="jf hj"> O(N ) </strong>并且不需要额外的空间，空间复杂度为<strong class="jf hj"> O(1) </strong>。</p><h2 id="c6b7" class="kr ig hi bd ih kw kx ky il kz la lb ip jo lc ld it js le lf ix jw lg lh jb li bi translated">双指针技术</h2><p id="70aa" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">通过对数组进行排序，可以提高算法的效率。一旦数组排序完毕，我们就可以使用双指针技术。</p><p id="9bd7" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">我们遍历数组并修复三元组的第一个元素。我们使用两点算法来找到最接近<strong class="jf hj">目标的数字— nums[i] </strong>。更新最接近的总和。因为双指针占用线性时间，所以它比嵌套循环好。</p><p id="d66f" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated"><strong class="jf hj">算法</strong></p><pre class="ki kj kk kl fd km kn ko kp aw kq bi"><span id="1d23" class="kr ig hi kn b fi ks kt l ku kv">- if nums.size &lt; 3<br/>  - return 0<br/><br/>- sort(nums.begin(), nums.end())<br/><br/>- set i = 0, minDiff = INT_MAX<br/>- initialize sum<br/><br/>- loop while i &lt; nums.size() - 2<br/>  - set left = i + 1<br/>  - set right = nums.size() - 1<br/><br/>  - loop while right &gt; left<br/>    - set temp = nums[i] + nums[left] + nums[right]<br/>    - set diff = abs(temp - target)<br/><br/>    - if diff == 0<br/>      - return target<br/><br/>    - if diff &lt; minDiff<br/>      - minDiff = diff<br/>      - sum = temp<br/><br/>    - if temp &lt; target<br/>      - left++<br/>    - else<br/>      - right++<br/><br/>  - loop end<br/><br/>  - i++<br/>- loop end<br/><br/>- return sum</span></pre><p id="99e8" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated"><strong class="jf hj"> C++解决方案</strong></p><pre class="ki kj kk kl fd km kn ko kp aw kq bi"><span id="f51f" class="kr ig hi kn b fi ks kt l ku kv">class Solution {<br/>public:<br/>    int threeSumClosest(vector&lt;int&gt;&amp; nums, int target) {<br/>        if(nums.size() &lt; 3){<br/>            return 0;<br/>        }<br/><br/>        sort(nums.begin(), nums.end());<br/><br/>        int i = 0;<br/>        int sum, minDiff = INT_MAX;<br/><br/>        while(i &lt; nums.size() - 2){<br/>            int left = i + 1;<br/>            int right = nums.size() - 1;<br/>            while(right &gt; left){<br/>                int temp = nums[i] + nums[left] + nums[right];<br/>                int diff = abs(temp - target);<br/><br/>                if(diff == 0){<br/>                    return target;<br/>                }<br/><br/>                if(diff &lt; minDiff){<br/>                    minDiff = diff;<br/>                    sum = temp;<br/>                }<br/><br/>                if(temp &lt; target){<br/>                    left++;<br/>                }<br/>                else{<br/>                    right--;<br/>                }<br/>            }<br/>            i++;<br/>        }<br/><br/>    return sum;<br/>  }<br/>};</span></pre><p id="7c75" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated"><strong class="jf hj"> Golang解决方案</strong></p><pre class="ki kj kk kl fd km kn ko kp aw kq bi"><span id="83da" class="kr ig hi kn b fi ks kt l ku kv">const MaxUint = ^uint(0)<br/>const MaxInt = int(MaxUint &gt;&gt; 1)<br/><br/>func absInt(x int) int{<br/>    if x &lt; 0 {<br/>        return x*-1<br/>    }<br/><br/>    return x<br/>}<br/><br/>func threeSumClosest(nums []int, target int) int {<br/>    numsLength := len(nums)<br/>    if numsLength &lt; 3 {<br/>        return 0<br/>    }<br/><br/>    sort.Ints(nums)<br/><br/>    i, sum := 0, 0<br/>    minDiff := MaxInt<br/><br/>    for i &lt; numsLength - 2 {<br/>        left := i + 1<br/>        right := numsLength - 1<br/><br/>        for right &gt; left {<br/>            temp := nums[i] + nums[left] + nums[right]<br/>            diff := absInt(temp - target)<br/><br/>            if diff == 0 {<br/>                return target<br/>            }<br/><br/>            if diff &lt; minDiff {<br/>                minDiff = diff<br/>                sum = temp<br/>            }<br/><br/>            if temp &lt; target {<br/>                left++<br/>            } else {<br/>                right--<br/>            }<br/>        }<br/><br/>        i++<br/>    }<br/><br/>    return sum<br/>}</span></pre><p id="d8bc" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated"><strong class="jf hj"> Javascript解决方案</strong></p><pre class="ki kj kk kl fd km kn ko kp aw kq bi"><span id="4c79" class="kr ig hi kn b fi ks kt l ku kv">var threeSumClosest = function(nums, target) {<br/>    if(nums.length &lt; 3) {<br/>        return 0;<br/>    }<br/><br/>    nums.sort();<br/><br/>    let i = 0, minDiff = Number.MAX_VALUE;<br/>    let sum;<br/><br/>    while( i &lt; nums.length - 2 ){<br/>        let left = i + 1;<br/>        let right = nums.length - 1<br/><br/>        while( right &gt; left ){<br/>            let temp = nums[i] + nums[left] + nums[right];<br/>            let diff = Math.abs(temp - target);<br/><br/>            if( diff == 0 ){<br/>                return target;<br/>            }<br/><br/>            if( diff &lt; minDiff ){<br/>                minDiff = diff;<br/>                sum = temp;<br/>            }<br/><br/>            if( temp &lt; target ){<br/>                left++;<br/>            } else {<br/>                right--;<br/>            }<br/>        }<br/>        i++;<br/>    }<br/><br/>    return sum;<br/>};</span></pre><p id="daf7" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">让我们试运行一下我们的算法，看看解决方案是如何工作的。</p><pre class="ki kj kk kl fd km kn ko kp aw kq bi"><span id="5bb5" class="kr ig hi kn b fi ks kt l ku kv">Input: nums = [-1, 2, 1, -4], target = 1<br/><br/>Step 1: if nums.size() &lt; 3<br/>           4 &lt; 3<br/>           false<br/><br/>Step 2: sort(nums.start(), nums.end())<br/>          - [-4, -1, 1, 2]<br/><br/>Step 3: int i = 0;<br/>        int sum, minDiff = INT_MAX;<br/><br/>Step 4: loop while i &lt; nums.size() - 2<br/>        0 &lt; 4 - 2<br/>        0 &lt; 2<br/>        true<br/><br/>        left = i + 1<br/>             = 0 + 1<br/>             = 1<br/>        right = nums.size() - 1<br/>              = 4 - 1<br/>              = 3<br/><br/>        loop while right &gt; left<br/>        3 &gt; 1<br/>        true<br/><br/>        temp = nums[i] + nums[left] + nums[right]<br/>             = nums[0] + nums[1] + nums[3]<br/>             = -4 + -1 + 2<br/>             = -3<br/><br/>        diff = abs(temp - target)<br/>             = abs(-3 - 1)<br/>             = abs(-4)<br/>             = 4<br/><br/>        if diff == 0<br/>           4 == 0<br/>           false<br/><br/>        if diff &lt; minDiff<br/>           4 &lt; INT_MAX<br/>           true<br/><br/>           minDiff = diff<br/>                   = 4<br/>           sum = temp<br/>               = -3<br/><br/>        if temp &lt; target<br/>           -3 &lt; 4<br/>           true<br/><br/>           left++<br/>           left = 2<br/><br/>        loop while right &gt; left<br/>        3 &gt; 2<br/>        true<br/><br/>        temp = nums[i] + nums[left] + nums[right]<br/>             = nums[0] + nums[2] + nums[3]<br/>             = -4 + 1 + 2<br/>             = -1<br/><br/>        diff = abs(temp - target)<br/>             = abs(-1 - 1)<br/>             = abs(-2)<br/>             = 2<br/><br/>        if diff == 0<br/>           2 == 0<br/>           false<br/><br/>        if diff &lt; minDiff<br/>           2 &lt; 4<br/>           true<br/><br/>           minDiff = diff<br/>                   = 2<br/>           sum = temp<br/>               = -1<br/><br/>        if temp &lt; target<br/>           -1 &lt; 4<br/>           true<br/><br/>           left++<br/>           left = 3<br/><br/>        loop while right &gt; left<br/>        3 &gt; 3<br/>        false<br/><br/>        i++<br/>        i = 1<br/><br/>Step 5: loop while i &lt; nums.size() - 2<br/>        1 &lt; 4 - 2<br/>        1 &lt; 2<br/>        true<br/><br/>        left = i + 1<br/>             = 1 + 1<br/>             = 2<br/>        right = nums.size() - 1<br/>              = 4 - 1<br/>              = 3<br/><br/>        loop while right &gt; left<br/>        3 &gt; 2<br/>        true<br/><br/>        temp = nums[i] + nums[left] + nums[right]<br/>             = nums[1] + nums[2] + nums[3]<br/>             = -1 + 1 + 2<br/>             = 2<br/><br/>        diff = abs(temp - target)<br/>             = abs(2 - 1)<br/>             = abs(1)<br/>             = 1<br/><br/>        if diff == 0<br/>           1 == 0<br/>           false<br/><br/>        if diff &lt; minDiff<br/>           1 &lt; 2<br/>           true<br/><br/>           minDiff = diff<br/>                   = 1<br/>           sum = temp<br/>               = 2<br/><br/>        if temp &lt; target<br/>           2 &lt; 4<br/>           true<br/><br/>           left++<br/>           left = 3<br/><br/>        loop while right &gt; left<br/>        3 &gt; 3<br/>        false<br/><br/>        i++<br/>        i = 2<br/><br/>Step 6: loop while i &lt; nums.size() - 2<br/>        2 &lt; 4 - 2<br/>        2 &lt; 2<br/>        false<br/><br/>Step 7: return sum<br/>        return 2<br/><br/>So the answer is 2.</span></pre></div><div class="ab cl lj lk gp ll" role="separator"><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo"/></div><div class="hb hc hd he hf"><p id="d1ba" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated"><em class="kg">原载于</em><a class="ae kh" href="https://alkeshghorpade.me/post/leetcode-3sum-closest" rel="noopener ugc nofollow" target="_blank"><em class="kg">https://alkeshghorpade . me</em></a><em class="kg">。</em></p></div></div>    
</body>
</html>