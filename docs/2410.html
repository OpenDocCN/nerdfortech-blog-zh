<html>
<head>
<title>Adding a Custom Star-Field Background with three.js</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用 three.js 添加自定义星域背景</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/adding-a-custom-star-field-background-with-three-js-79a1d18fd35d?source=collection_archive---------0-----------------------#2021-05-05">https://medium.com/nerd-for-tech/adding-a-custom-star-field-background-with-three-js-79a1d18fd35d?source=collection_archive---------0-----------------------#2021-05-05</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><figure class="hh hi ez fb hj hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es hg"><img src="../Images/7e9cea5c668ef5707199e5f658366d14.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*A6Z2r5E4NVcnkLhA"/></div></div><figcaption class="hr hs et er es ht hu bd b be z dx translated">照片由<a class="ae hv" href="https://unsplash.com/@jdiegoph?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Diego PH </a>在<a class="ae hv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><div class=""/><p id="192d" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">今天，我将添加一个类似星空的背景，这是我在之前的帖子<a class="ae hv" href="https://25ckuntaldas.medium.com/taking-a-simple-contact-form-to-the-next-level-with-css-animation-and-three-js-part-1-cb9093ef9d64" rel="noopener"> <em class="jt">中调侃过的，通过 css 动画和 three.js </em> </a>将一个简单的联系人表单提升到下一个级别，这将对鼠标移动做出响应。</p><p id="a1e5" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我将从上一篇文章离开的地方开始，继续添加内容。如果您只想用 three.js 创建背景，也可以从一个基本的空白 HTML 页面开始。</p><h1 id="7d6f" class="ju jv hy bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">three.js 是什么？</h1><p id="6492" class="pw-post-body-paragraph iv iw hy ix b iy ks ja jb jc kt je jf jg ku ji jj jk kv jm jn jo kw jq jr js hb bi translated">Three.js 是一个轻量级跨浏览器 JavaScript 库/API，用于在 Web 浏览器上创建和显示动画 3D 计算机图形。Three.js 脚本可以与 HTML5 canvas 元素、SVG 或 WebGL 结合使用。</p><p id="bcda" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hz">添加 canvas 标签:</strong>当我决定使用<a class="ae hv" href="https://developer.mozilla.org/en-US/docs/Web/API/Canvas_API" rel="noopener ugc nofollow" target="_blank"> HTML5 canvas 元素</a>时，我们需要在 HTML 中添加一个<code class="du kx ky kz la b">&lt;canvas&gt; </code>标签，就在<code class="du kx ky kz la b">&lt;body&gt;</code>标签[ <code class="du kx ky kz la b">&lt;canvas id=”c”&gt;&lt;/canvas&gt;</code> ]之后。我还添加了一个 id，以便在我的 JavaScript 中引用它。</p><p id="8c25" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hz">一位 CSS : </strong>这位 CSS 会通过应用<code class="du kx ky kz la b">position: absolute;</code>和<code class="du kx ky kz la b">width:100%;height:100%;</code>使其横跨整个屏幕。这里它是相对于 HTML 的<code class="du kx ky kz la b">body</code>的，所以<code class="du kx ky kz la b">width:100%;</code>将表示<code class="du kx ky kz la b">body</code>元素的 100%宽度，高度也是如此。一个<code class="du kx ky kz la b">z-index:-1;</code>会把它放在所有 HTML 元素的后面。此外，如果注意到<code class="du kx ky kz la b">transition</code>属性，它会使背景平滑地出现，因为它会在页面和 JavaScript 加载后需要一些计算，它也会给低端计算机一些时间在渲染第一幅图像前进行计算。</p><pre class="lb lc ld le fd lf la lg lh aw li bi"><span id="6d90" class="lj jv hy la b fi lk ll l lm ln">#c {<br/>    display: block;<br/>    position: absolute;<br/>    z-index: -1;<br/>    width: 100%;<br/>    height: 100%;<br/>    opacity: 0;<br/>    transition: opacity 1500ms ease-out;<br/>}</span></pre><p id="1119" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">给 js 接线:我们将在 JS 的帮助下制作<code class="du kx ky kz la b">opacity:1;</code></p><pre class="lb lc ld le fd lf la lg lh aw li bi"><span id="f8c3" class="lj jv hy la b fi lk ll l lm ln">const canvas = document.getElementById("c");</span><span id="c261" class="lj jv hy la b fi lo ll l lm ln">document.addEventListener("DOMContentLoaded", () =&gt; {<br/>  canvas.style.opacity = 1;<br/>});</span></pre><p id="e53f" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">现在让我们先用 threejs 声明，我们需要通过<br/> <code class="du kx ky kz la b">import THREE form “<a class="ae hv" href="https://cdnjs.cloudflare.com/ajax/libs/three.js/r127/three.min.js" rel="noopener ugc nofollow" target="_blank">https://cdnjs.cloudflare.com/ajax/libs/three.js/r127/three.min.js</a>”</code> <br/>将它导入到我们的项目中，或者我们可以简单地用 HTML <br/> <code class="du kx ky kz la b">&lt;script src=“<a class="ae hv" href="https://cdnjs.cloudflare.com/ajax/libs/three.js/r127/three.min.js" rel="noopener ugc nofollow" target="_blank">https://cdnjs.cloudflare.com/ajax/libs/three.js/r127/three.min.js</a>”&gt;</code>中的脚本标签链接它</p><p id="8a1b" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">为了在我们在 HTML 中定义的画布上完成三项工作，我们需要在创建<code class="du kx ky kz la b">renderer</code>时传递它:</p><pre class="lb lc ld le fd lf la lg lh aw li bi"><span id="ead4" class="lj jv hy la b fi lk ll l lm ln">const starFieldBG = () =&gt;{<br/>    const renderer = new THREE.WebGLRenderer({canvas});<br/>    renderer.setClearColor(new THREE.Color("#1c1624"));</span><span id="976b" class="lj jv hy la b fi lo ll l lm ln">   ...<br/>}</span></pre><p id="ec06" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hz"> setClearColor() </strong>函数设置我们将要绘制的画布的颜色。渲染器将一个<code class="du kx ky kz la b">scene</code>对象和一个<code class="du kx ky kz la b">camera</code>对象作为参数来正确渲染它。</p><pre class="lb lc ld le fd lf la lg lh aw li bi"><span id="3c20" class="lj jv hy la b fi lk ll l lm ln">const scene = new THREE.Scene();</span><span id="cca4" class="lj jv hy la b fi lo ll l lm ln">const fov = 75, aspect = 2, near = 1.5, far = 5;<br/>const camera = new THREE.PerspectiveCamera(fov, aspect, near, far);</span><span id="6ce6" class="lj jv hy la b fi lo ll l lm ln">renderer.render(scene, camera);</span></pre><figure class="lb lc ld le fd hk er es paragraph-image"><div class="er es lp"><img src="../Images/b748988d8a76e1845f636d04a5e1ef81.png" data-original-src="https://miro.medium.com/v2/resize:fit:1024/format:webp/1*g9b7FCWoE6-Do7G2Wc1UQQ.png"/></div></figure><p id="6c2f" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在这里，我使用了<strong class="ix hz">透视相机</strong>，它给出了一个 3d 视图，在这个视图中，远处的东西看起来比近处的小。<code class="du kx ky kz la b">fov</code>是以度为单位的视野，<code class="du kx ky kz la b">aspect</code>是宽高比，<code class="du kx ky kz la b">near</code> <code class="du kx ky kz la b">far</code>将决定渲染多少空间。</p><p id="6570" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">为了更好地了解 three.js 中的<a class="ae hv" href="https://threejsfundamentals.org/threejs/lessons/threejs-cameras.html" rel="noopener ugc nofollow" target="_blank">摄像机，请看这个</a><a class="ae hv" href="https://threejsfundamentals.org/threejs/threejs-cameras-perspective-2-scenes.html" rel="noopener ugc nofollow" target="_blank">在</a><a class="ae hv" href="https://threejsfundamentals.org" rel="noopener ugc nofollow" target="_blank">https://threejsfundamentals.org</a>的真实例子</p><p id="aeed" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">此时，我们将看不到任何东西，因为在<code class="du kx ky kz la b">scene</code>中没有<strong class="ix hz">光</strong>和任何物体。Three.js 库中有很多种类的灯，如<code class="du kx ky kz la b"><strong class="ix hz">AmbientLight</strong></code>、<code class="du kx ky kz la b"><strong class="ix hz">AmbientLightProbe</strong></code>、<code class="du kx ky kz la b"><strong class="ix hz">DirectionalLight</strong></code>、<strong class="ix hz">、</strong>、<strong class="ix hz">、</strong>等。你可以在这里了解更多关于灯光<a class="ae hv" href="https://threejsfundamentals.org/threejs/lessons/threejs-lights.html" rel="noopener ugc nofollow" target="_blank">的信息。我选择了使用平行光，因为它可以创造出类似太阳光线的效果。</a></p><pre class="lb lc ld le fd lf la lg lh aw li bi"><span id="bcb9" class="lj jv hy la b fi lk ll l lm ln">// light source<br/>  const color = 0xffffff, intensity = 1;<br/>  const light = new THREE.DirectionalLight(color, intensity);<br/>  light.position.set(-1, 2, 4);<br/>  scene.add(light);</span></pre><p id="2805" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><code class="du kx ky kz la b">color</code> &amp; <code class="du kx ky kz la b">intensity</code>分别指光线的颜色和它会照亮表面的程度。<code class="du kx ky kz la b">position.set(x, y, z)</code>设置光源在 3d 空间的位置。虽然光源不会被渲染，但它与对象的交互将被渲染。</p><p id="3322" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">现在让我们添加一个对象，这样我们至少可以在画布上看到一些东西。为此，我们需要<strong class="ix hz">网格</strong>，它是以下各项的组合:</p><ul class=""><li id="3dc8" class="lq lr hy ix b iy iz jc jd jg ls jk lt jo lu js lv lw lx ly bi translated">一个<code class="du kx ky kz la b"><a class="ae hv" href="https://threejs.org/docs/?q=Geometry" rel="noopener ugc nofollow" target="_blank">Geometry</a></code> <a class="ae hv" href="https://threejs.org/docs/?q=Geometry" rel="noopener ugc nofollow" target="_blank"> </a> —物体的形状</li><li id="90e8" class="lq lr hy ix b iy lz jc ma jg mb jk mc jo md js lv lw lx ly bi translated">一个<code class="du kx ky kz la b"><a class="ae hv" href="https://threejs.org/docs/#api/en/materials/Material" rel="noopener ugc nofollow" target="_blank">Material</a></code>——如何绘制物体，发亮还是扁平，什么颜色，应用什么纹理。等等。</li><li id="d7e0" class="lq lr hy ix b iy lz jc ma jg mb jk mc jo md js lv lw lx ly bi translated">场景中对象相对于其父对象位置、方向和比例。在下面的代码中，父对象是场景。</li></ul><p id="fbe8" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hz">让我们先画一个立方体:</strong>这将画一个在点(0，0，0)上有<code class="du kx ky kz la b"><a class="ae hv" href="https://threejs.org/docs/?q=Geometry#api/en/geometries/BoxGeometry" rel="noopener ugc nofollow" target="_blank">BoxGeometry</a></code>的立方体来看它，我们需要用<code class="du kx ky kz la b">camera.position.z = 2;</code>在后面拍摄一点，这里我只改变<code class="du kx ky kz la b">z</code>轴的值，你也可以用一些不同的单位来尝试<code class="du kx ky kz la b">x</code>或<code class="du kx ky kz la b">y</code>。</p><pre class="lb lc ld le fd lf la lg lh aw li bi"><span id="6410" class="lj jv hy la b fi lk ll l lm ln">const boxWidth = 1, boxHeight = 1, boxDepth = 1;<br/>const geometry = new THREE.BoxGeometry(boxWidth, boxHeight, boxDepth);</span><span id="dba3" class="lj jv hy la b fi lo ll l lm ln">const material = new THREE.MeshBasicMaterial({color: 0x44aa88});</span><span id="a079" class="lj jv hy la b fi lo ll l lm ln">const cube = new THREE.Mesh(geometry, material);</span><span id="a6a6" class="lj jv hy la b fi lo ll l lm ln">scene.add(cube);</span></pre><p id="b7c4" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hz">使其具有响应性:</strong>到现在为止，您可能在显示器上显示立方体时有问题，或者当您调整浏览器大小时有问题。为了解决这个问题，我们需要知道窗口的宽度和高度何时改变，并根据它进行调整。</p><pre class="lb lc ld le fd lf la lg lh aw li bi"><span id="846e" class="lj jv hy la b fi lk ll l lm ln">const resizeRendererToDisplaySize = (renderer) =&gt; {<br/>  const canvas = renderer.domElement;<br/>  const width = canvas.clientWidth;<br/>  const height = canvas.clientHeight;<br/>  const needResize = canvas.width !== width || canvas.height !== height;<br/>  // resize only when necessary<br/>  if (needResize) {<br/>    //3rd parameter `false` to change the internal canvas size<br/>    renderer.setSize(width, height, false);<br/>  }<br/>  return needResize;<br/>};</span></pre><p id="700e" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这个函数将通过用<code class="du kx ky kz la b">renderer.setSize()</code>调整画布的 drawingbuffer 大小(画布的内部大小，它的分辨率)来消除缩放问题。的“drawingbuffer”可以与<code class="du kx ky kz la b">&lt;svg&gt;</code>元素的<code class="du kx ky kz la b">viewbox</code>或<code class="du kx ky kz la b">&lt;img&gt;</code>标签内的图像进行比较(图像尺寸可以不同于<code class="du kx ky kz la b">&lt;img&gt;</code>标签的尺寸)。</p><p id="a032" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在我们的<code class="du kx ky kz la b">main()</code>中调用这个函数时，我们将利用它的返回语句来改变摄像机的<strong class="ix hz">宽高比</strong>。</p><pre class="lb lc ld le fd lf la lg lh aw li bi"><span id="a28a" class="lj jv hy la b fi lk ll l lm ln">const render = (time) =&gt; {<br/>  if (resizeRendererToDisplaySize(renderer)) {<br/>    const canvas = renderer.domElement;</span><span id="280f" class="lj jv hy la b fi lo ll l lm ln">    // changing the camera aspect to remove the strechy problem<br/>    camera.aspect = canvas.clientWidth / canvas.clientHeight;<br/>    camera.updateProjectionMatrix();<br/>  }</span><span id="b36e" class="lj jv hy la b fi lo ll l lm ln">   // Re-render the scene<br/>   renderer.render(scene, camera);<br/>   // loop<br/>   requestAnimationFrame(render);<br/>};<br/>requestAnimationFrame(render);</span></pre><p id="e3d5" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">因为我们需要跟踪窗口尺寸并调用这个代码块来使画布在所有屏幕上响应，所以我将这个代码块包含在一个函数中，并用浏览器提供的<code class="du kx ky kz la b"><a class="ae hv" href="https://developer.mozilla.org/en-US/docs/Web/API/window/requestAnimationFrame" rel="noopener ugc nofollow" target="_blank">requestAnimationFrame()</a></code> <a class="ae hv" href="https://developer.mozilla.org/en-US/docs/Web/API/window/requestAnimationFrame" rel="noopener ugc nofollow" target="_blank"> </a>进行递归循环。</p><p id="9c73" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hz">增加一些交互性:</strong>用鼠标指针定位。为此，我在文档中附加了一个<code class="du kx ky kz la b">mousemove</code> EventListener，并更新了两个全局变量<code class="du kx ky kz la b">mouseX</code> &amp; <code class="du kx ky kz la b">mouseY</code>。</p><pre class="lb lc ld le fd lf la lg lh aw li bi"><span id="5b32" class="lj jv hy la b fi lk ll l lm ln">// mouse<br/>let mouseX = 0;<br/>let mouseY = 0;<br/>document.addEventListener("mousemove", (e) =&gt; {<br/>  mouseX = e.clientX;<br/>  mouseY = e.clientY;<br/>});</span></pre><p id="d9e9" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">现在在<code class="du kx ky kz la b">render()</code>中添加两行代码来改变它基于鼠标移动的旋转。</p><pre class="lb lc ld le fd lf la lg lh aw li bi"><span id="c0e2" class="lj jv hy la b fi lk ll l lm ln">const render = (time) =&gt; {<br/>    ...<br/>    ...<br/>    <br/>    cube.rotation.x = mouseY * 0.005;<br/>    cube.rotation.y = mouseX * 0.005;<br/>    <br/>    renderer.render(scene, camera);<br/>    // loop<br/>    requestAnimationFrame(render);<br/>  };</span></pre><p id="bb3d" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">你最终会变成这样。</p><figure class="lb lc ld le fd hk"><div class="bz dy l di"><div class="me mf l"/></div></figure><p id="6393" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">到目前为止，我使用一个立方体来使响应部分易于理解。但是我们不需要立方体，我们需要点，所以我们将使用<code class="du kx ky kz la b"><a class="ae hv" href="https://threejs.org/docs/index.html?q=points#api/en/objects/Points" rel="noopener ugc nofollow" target="_blank">THREE.Points</a></code>来代替<code class="du kx ky kz la b">THREE.Mesh</code>，为了让它工作，我们还需要使用不同的材料，<code class="du kx ky kz la b"><a class="ae hv" href="https://threejs.org/docs/?q=PointsMaterial#api/en/materials/PointsMaterial" rel="noopener ugc nofollow" target="_blank"><strong class="ix hz">PointsMaterial</strong></a></code>现在你会看到立方体的 8 个角上有 8 个点。我们需要更多的分数。就像这样:</p><figure class="lb lc ld le fd hk"><div class="bz dy l di"><div class="me mf l"/></div></figure><p id="3131" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">现在使用<code class="du kx ky kz la b">size:0.05</code>使它变得明显</p><pre class="lb lc ld le fd lf la lg lh aw li bi"><span id="6dfd" class="lj jv hy la b fi lk ll l lm ln">const material = new THREE.PointsMaterial({<br/>    size: 0.05,<br/>    color: 0x44aa88 // remove it if you want white points.<br/>});</span></pre><p id="a127" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们还需要大量的点盒——几何在这种情况下没有太大的帮助，所以我们需要使用<code class="du kx ky kz la b"><a class="ae hv" href="https://threejs.org/docs/?q=BufferGeometry()#api/en/core/BufferGeometry" rel="noopener ugc nofollow" target="_blank">BufferGeometry()</a></code></p><pre class="lb lc ld le fd lf la lg lh aw li bi"><span id="508c" class="lj jv hy la b fi lk ll l lm ln">const geometry = new THREE.BufferGeometry();</span></pre><p id="76f5" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><code class="du kx ky kz la b">BufferGeometry()</code>创建几何图形时不需要参数，但我们需要改变一些属性来定义我们的点位置。</p><pre class="lb lc ld le fd lf la lg lh aw li bi"><span id="0d61" class="lj jv hy la b fi lk ll l lm ln">geometry.setAttribute(<br/>    "position",<br/>    new THREE.BufferAttribute(getRandomParticelPos(350), 3)<br/>);</span></pre><p id="37de" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">该部分通过使用由<code class="du kx ky kz la b"> getRandomParticelPos()</code>返回的随机浮点值数组来设置位置，该数组以<strong class="ix hz">点数</strong>作为参数。<code class="du kx ky kz la b"><a class="ae hv" href="https://threejs.org/docs/?q=BufferAttribute#api/en/core/BufferAttribute" rel="noopener ugc nofollow" target="_blank">BufferAttribute</a></code>使用该数组通过从数组中每个点取 3 个值来设置位置属性。</p><pre class="lb lc ld le fd lf la lg lh aw li bi"><span id="7e82" class="lj jv hy la b fi lk ll l lm ln">const getRandomParticelPos = (particleCount) =&gt; {<br/>  const arr = new Float32Array(particleCount * 3);<br/>  for (let i = 0; i &lt; particleCount; i++) {<br/>    arr[i] = (Math.random() - 0.5) * 10;<br/>  }<br/>  return arr;<br/>};</span></pre><p id="470c" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这将看起来像这样:</p><figure class="lb lc ld le fd hk"><div class="bz dy l di"><div class="me mf l"/></div></figure><p id="2971" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">为了改变悬停效果，我们需要改变<code class="du kx ky kz la b">render()</code>中的这两行，并从材质中移除<code class="du kx ky kz la b">color</code>属性，使其为白色。</p><pre class="lb lc ld le fd lf la lg lh aw li bi"><span id="c7ec" class="lj jv hy la b fi lk ll l lm ln">...<br/>const render = (time) =&gt; {<br/>    ...<br/>    ...<br/>    <br/>    //cube.rotation.x = mouseY * 0.005;<br/>    //cube.rotation.y = mouseX * 0.005;</span><span id="5237" class="lj jv hy la b fi lo ll l lm ln">    cube.position.x = mouseY * 0.0001;<br/>    cube.position.y = mouseX * -0.0001;<br/>    <br/>    renderer.render(scene, camera);<br/>    // loop<br/>    requestAnimationFrame(render);<br/>  };<br/>...</span></pre><p id="c1a7" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">不幸的是，我们不能把这些点做成圆形或任何类似的形状。但是我们可以使用<code class="du kx ky kz la b">texture</code>让它们看起来像我们想要的任何样子。我在 Figma 中制作了两张<strong class="ix hz"> PNG </strong>图片作为纹理，并上传到 GitHub <a class="ae hv" href="https://github.com/Kuntal-Das/textures" rel="noopener ugc nofollow" target="_blank"> <strong class="ix hz"> repo </strong> </a>中。为了使用纹理，我们需要<code class="du kx ky kz la b"><a class="ae hv" href="https://threejs.org/docs/?q=TextureLoader()#api/en/loaders/TextureLoader" rel="noopener ugc nofollow" target="_blank">TextureLoader()</a></code>，我们还需要在创建材质时改变传递给<code class="du kx ky kz la b"><a class="ae hv" href="https://threejs.org/docs/?q=PointsMaterial#api/en/materials/PointsMaterial" rel="noopener ugc nofollow" target="_blank">PointsMaterial()</a></code>的对象。</p><pre class="lb lc ld le fd lf la lg lh aw li bi"><span id="0eb1" class="lj jv hy la b fi lk ll l lm ln">const loader = new THREE.TextureLoader();<br/>...</span><span id="ee98" class="lj jv hy la b fi lo ll l lm ln">const material = new THREE.PointsMaterial({<br/>    size: 0.05,<br/>    map: loader.load(<br/>      "<a class="ae hv" href="https://raw.githubusercontent.com/Kuntal-Das/textures/main/sp2.png" rel="noopener ugc nofollow" target="_blank">https://raw.githubusercontent.com/Kuntal-Das/textures/main/sp2.png</a>"<br/>    ),<br/>    transparent: true<br/>    // color: 0x44aa88<br/>});</span></pre><p id="7152" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><code class="du kx ky kz la b">loader.load()</code>从给定的 PNG 文件创建纹理，并将其作为<code class="du kx ky kz la b">map</code>传递，以使点看起来像它，但我们还需要<code class="du kx ky kz la b">transparent:true</code>使之前渲染的白色方块消失。</p><p id="bfb1" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">唷，我们终于成功了。仅限此背景。</p><figure class="lb lc ld le fd hk"><div class="bz dy l di"><div class="me mf l"/></div></figure><p id="3de5" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在这个最终版本中，我添加了两种不同的纹理和不同的点数。这个帖子已经很长了，我不想让它变得更长，所以我会把它留给你自己去实现，并弄脏你的手。(或者只是在我的代码中有一个峰值🤭)</p><p id="3731" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">现在，那些跟随<a class="ae hv" href="https://25ckuntaldas.medium.com/taking-a-simple-contact-form-to-the-next-level-with-css-animation-and-three-js-part-1-cb9093ef9d64" rel="noopener">上一篇文章</a>的人应该有这个:</p><figure class="lb lc ld le fd hk"><div class="bz dy l di"><div class="me mf l"/></div></figure><p id="66f7" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">所以我们今天学到了:</p><ul class=""><li id="e3c8" class="lq lr hy ix b iy iz jc jd jg ls jk lt jo lu js lv lw lx ly bi translated">如何将 threejs 与 canvas 配合使用？</li><li id="fd72" class="lq lr hy ix b iy lz jc ma jg mb jk mc jo md js lv lw lx ly bi translated">我们知道我们需要<code class="du kx ky kz la b">scene</code>和<code class="du kx ky kz la b">camera</code>来渲染我们的场景。</li><li id="3e3c" class="lq lr hy ix b iy lz jc ma jg mb jk mc jo md js lv lw lx ly bi translated">我们还需要将<code class="du kx ky kz la b">light</code>添加到<code class="du kx ky kz la b">scene</code>中，以查看我们添加到<code class="du kx ky kz la b">scene</code>中的对象。</li><li id="da6e" class="lq lr hy ix b iy lz jc ma jg mb jk mc jo md js lv lw lx ly bi translated">我们学习了用<code class="du kx ky kz la b">BoxGeometry</code> &amp; <code class="du kx ky kz la b">MeshBasicMaterial</code>创建<code class="du kx ky kz la b">Mesh</code>。</li><li id="89ab" class="lq lr hy ix b iy lz jc ma jg mb jk mc jo md js lv lw lx ly bi translated">我们通过监听窗口的宽度和高度使画布内部的图像做出响应。</li><li id="2605" class="lq lr hy ix b iy lz jc ma jg mb jk mc jo md js lv lw lx ly bi translated">如何渲染大量的点<code class="du kx ky kz la b">BufferGeometry</code> &amp; <code class="du kx ky kz la b">PointsMaterial</code>。</li><li id="5a15" class="lq lr hy ix b iy lz jc ma jg mb jk mc jo md js lv lw lx ly bi translated">我们在 threejs 中学到了一些关于<code class="du kx ky kz la b">textures</code>的知识。</li><li id="30da" class="lq lr hy ix b iy lz jc ma jg mb jk mc jo md js lv lw lx ly bi translated">我们还学习了两种使 canvas 元素交互的方法。</li></ul></div></div>    
</body>
</html>