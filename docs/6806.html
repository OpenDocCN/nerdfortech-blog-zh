<html>
<head>
<title>Facebook scraper bot using Node JS and Mongo DB</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Node JS和Mongo DB的脸书刮刀机器人</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/facebook-scraper-bot-using-node-js-and-mongo-db-cb5864208126?source=collection_archive---------0-----------------------#2022-05-15">https://medium.com/nerd-for-tech/facebook-scraper-bot-using-node-js-and-mongo-db-cb5864208126?source=collection_archive---------0-----------------------#2022-05-15</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex io ip iq ir er es paragraph-image"><div role="button" tabindex="0" class="is it di iu bf iv"><div class="er es in"><img src="../Images/9c34ae1606e414e69b2a2349b165ad18.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JxYs1DB1iefe1QbHKagoVA.png"/></div></div></figure><p id="21b7" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated">我正在开发一个应用程序，该应用程序需要使用脸书oEmbed端点根据话题频道呈现脸书供稿，可以在社交媒体上找到、过滤并与客户互动。脸书oEmbed端点允许您获取页面、帖子和视频的嵌入式HTML和基本元数据，以便在另一个网站或应用程序中显示它们。由于脸书官方API文档不赞成获取最近的媒体，包括提要内容，URL，创建时间戳，喜欢/评论和提要的共享计数，我设计了一个脸书刮刀来提取这些信息。在这里，我将使用Node JS<a class="ae jw" href="https://www.npmjs.com/package/puppeteer" rel="noopener ugc nofollow" target="_blank">puppet er</a>作为自动化工具，使用Mongo DB存储收集到的提要数据来实现我的解决方案。</p><p id="5b05" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated">Puppeteer是一个节点库，提供高级API来控制chrome或chrome，我们可以在浏览器中手动做的大多数事情都可以使用puppeteer来完成。</p><p id="ec78" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated">我研究了很多第三方库，但是有一些限制，因为脸书平台更新了他们的CSS样式和类，我们不能使用动态生成的类样式来获得稳定的解决方案。因此，依赖第三方解决方案不是一个好的做法，因为我们不能确保它是否能与脸书最新的更新一起工作。所以我用Node JS设计了一个自己的脸书包装器，下面我会一步一步解释我的实现。</p><p id="1164" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated">所以让我们开始吧。</p><p id="1622" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated"><strong class="ja hj">先决条件:</strong></p><ul class=""><li id="ae4e" class="jx jy hi ja b jb jc jf jg jj jz jn ka jr kb jv kc kd ke kf bi translated">节点JS的基础知识</li></ul><p id="1097" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated"><strong class="ja hj">步骤01 : </strong></p><p id="ae00" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated">作为第一步，添加了导入木偶库的<code class="du kg kh ki kj b">initPuppeteer()</code>方法，启动浏览器并创建一个新页面，以及设置浏览器的宽度和高度并覆盖权限。</p><figure class="kk kl km kn fd ir"><div class="bz dy l di"><div class="ko kp l"/></div></figure><p id="4cac" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated"><strong class="ja hj">步骤02 : </strong></p><p id="fd8b" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated">在这一步中，我在一个单独的文件中添加了一些常见的配置消息，如下所示。</p><figure class="kk kl km kn fd ir"><div class="bz dy l di"><div class="ko kp l"/></div></figure><p id="4bd6" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated">这里我们将添加一个<code class="du kg kh ki kj b">loginFacebook()</code>来访问脸书网站，并等待网络空闲，直到它出现在登录界面并执行登录操作，如下所示。</p><p id="0e0e" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated">我设置了随机超时来等待动作，因为如果动作太快，我们的机器人将很容易被脸书检测到，这可能会导致我们的帐户被阻止或列入黑名单。</p><p id="a350" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated">这里我通过评估内部HTML来选择UI元素，因为在脸书选择器是随机变化的。</p><figure class="kk kl km kn fd ir"><div class="bz dy l di"><div class="ko kp l"/></div></figure><p id="4882" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated"><strong class="ja hj">步骤03 : </strong></p><p id="37c9" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated">在这一步，我们将开始基于过滤标签如<code class="du kg kh ki kj b">@mentions/keywords/hashtags</code>的抓取。因此，我的下一步将是根据下面的过滤器标签直接到脸书页面。我已经在我的配置文件中配置了基本URL。</p><pre class="kk kl km kn fd kq kj kr ks aw kt bi"><span id="b141" class="ku kv hi kj b fi kw kx l ky kz">const page_url = config.base_url + filter_tag;</span><span id="577b" class="ku kv hi kj b fi la kx l ky kz">await this.page.goto(page_url, {</span><span id="a575" class="ku kv hi kj b fi la kx l ky kz">waitUntil: "networkidle2",</span><span id="385c" class="ku kv hi kj b fi la kx l ky kz">});</span></pre><p id="6301" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated">接下来，我要检查页面是否可用，以启动如下的抓取步骤。这里我使用了一些UI显示文本内容，向用户表明页面的存在。所以我在配置文件中配置了这些可能的消息。</p><figure class="kk kl km kn fd ir"><div class="bz dy l di"><div class="ko kp l"/></div></figure><p id="65f6" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated"><strong class="ja hj">步骤04 : </strong></p><p id="aefd" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated">接下来，如果相关过滤器标签的脸书页面可用，我将滚动页面，并呈现如下DOM内容的提要。在这里，我们可以使用<code class="du kg kh ki kj b">post_count</code>参数配置要删除的帖子数量。在这里，我发现有一个帖子是围绕着<code class="du kg kh ki kj b">div[role="article"]</code>标签的。所以我要数不。通过在页面上滚动来呈现DOM内容的<code class="du kg kh ki kj b">div[role="article"]</code>标签。</p><figure class="kk kl km kn fd ir"><div class="bz dy l di"><div class="ko kp l"/></div></figure><p id="63e9" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated"><strong class="ja hj">步骤05 : </strong></p><p id="3512" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated">我的下一步是识别要提取的帖子，因为在上一步中，我们完成了基于<code class="du kg kh ki kj b">div[role="article"]</code>标签的滚动逻辑，但我发现它还包括一些其他文本内容。所以我们需要过滤掉那些。在这里，作为一个独特的元素，我已经确定，如果它是一个要提取的帖子，它的<code class="du kg kh ki kj b">ariaLabel</code>是一个空值。在此基础上，我将添加一个过滤器如下，对于每一篇文章，我将返回文本内容和内部HTML。</p><figure class="kk kl km kn fd ir"><div class="bz dy l di"><div class="ko kp l"/></div></figure><p id="1bf8" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated"><strong class="ja hj">步骤06 : </strong></p><p id="258c" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated">下一步，我将遍历我的过滤器列表，提取帖子内容、反应计数、分享计数和评论计数以及帖子创建的时间戳。这里提取这些数字需要通过一个html解析器解析post内部HTML，并得到如下的根HTML。为此，我使用了<a class="ae jw" href="https://www.npmjs.com/package/node-html-parser" rel="noopener ugc nofollow" target="_blank"> node-html-parser </a>，它将生成一个简化的DOM树，支持元素查询。</p><pre class="kk kl km kn fd kq kj kr ks aw kt bi"><span id="e99c" class="ku kv hi kj b fi kw kx l ky kz">import { parse } from “node-html-parser”;</span><span id="ae58" class="ku kv hi kj b fi la kx l ky kz">const root_html = parse(filtered_list[i].html);</span></pre><p id="1578" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated"><strong class="ja hj">提取帖子内容:</strong></p><figure class="kk kl km kn fd ir"><div class="bz dy l di"><div class="ko kp l"/></div></figure><p id="1f80" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated"><strong class="ja hj">提取评论数:</strong></p><figure class="kk kl km kn fd ir"><div class="bz dy l di"><div class="ko kp l"/></div></figure><p id="c99e" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated"><strong class="ja hj">提取反应计数:</strong></p><figure class="kk kl km kn fd ir"><div class="bz dy l di"><div class="ko kp l"/></div></figure><p id="a345" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated"><strong class="ja hj">提取股份数:</strong></p><figure class="kk kl km kn fd ir"><div class="bz dy l di"><div class="ko kp l"/></div></figure><p id="a920" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated">作为我的下一步，我需要如下格式化这些数据计数。</p><figure class="kk kl km kn fd ir"><div class="bz dy l di"><div class="ko kp l"/></div></figure><p id="0e19" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated"><strong class="ja hj">提取帖子创建的时间戳:</strong></p><p id="8e6c" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated">这里，脸书平台不允许我们直接从DOM内容中抓取时间戳。他们使用样式标签对时间戳字符串中的每个元素进行了排序。所以我们需要遍历span标签，并且需要找到这些元素的样式来找到它们的顺序。接下来，在我的逻辑中，我使用样式顺序作为数组索引，将这些元素插入到一个数组中。接下来，我发现有<code class="du kg kh ki kj b">{display:none;}</code>样式类，它们以样式顺序注入到这些元素中。所以我需要跳过下面这些元素。</p><figure class="kk kl km kn fd ir"><div class="bz dy l di"><div class="ko kp l"/></div></figure><p id="2786" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated">接下来，我们需要将post创建的时间戳格式化为通用格式，以便保存在数据库中，为此，我将通过格式化抓取的post创建的时间戳来返回纪元时间。</p><figure class="kk kl km kn fd ir"><div class="bz dy l di"><div class="ko kp l"/></div></figure><p id="9cca" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated">之后，我可以创建后创建的时间保存在数据库如下。</p><pre class="kk kl km kn fd kq kj kr ks aw kt bi"><span id="6acf" class="ku kv hi kj b fi kw kx l ky kz">const ymd_timestamp = moment</span><span id="f6e3" class="ku kv hi kj b fi la kx l ky kz">.unix(timestamp / 1000)</span><span id="cb1d" class="ku kv hi kj b fi la kx l ky kz">.format(config.date_time_format);</span></pre><p id="c95e" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated"><strong class="ja hj">步骤07 : </strong></p><p id="6c90" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated">作为我的下一步，我需要提取帖子的URL，以使用脸书oEmbed在web应用程序中呈现脸书提要，如下所示。从帖子操作中，我将提取feed oEmbed，并使用此字符串提取帖子URL和帖子id，如下所示。</p><figure class="kk kl km kn fd ir"><div class="bz dy l di"><div class="ko kp l"/></div></figure><p id="44a5" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated"><strong class="ja hj">步骤08 : </strong></p><p id="f398" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated">作为最后一步，我将使用提取的脸书feed记录更新Mongo DB，格式如下。</p><pre class="kk kl km kn fd kq kj kr ks aw kt bi"><span id="3e0e" class="ku kv hi kj b fi kw kx l ky kz">let dataObj = {</span><span id="c0e0" class="ku kv hi kj b fi la kx l ky kz">post_id: post_id,</span><span id="a555" class="ku kv hi kj b fi la kx l ky kz">post_text: post_text,</span><span id="0300" class="ku kv hi kj b fi la kx l ky kz">screen_name: filter_tag,</span><span id="5c8b" class="ku kv hi kj b fi la kx l ky kz">post_created_at: ymd_timestamp,</span><span id="74f2" class="ku kv hi kj b fi la kx l ky kz">attributes: {</span><span id="e422" class="ku kv hi kj b fi la kx l ky kz">share_count: share_count,</span><span id="6fce" class="ku kv hi kj b fi la kx l ky kz">comment_count: comment_count,</span><span id="5392" class="ku kv hi kj b fi la kx l ky kz">reaction_count: reaction_count,</span><span id="78ce" class="ku kv hi kj b fi la kx l ky kz">page_link: page_url,</span><span id="5ee4" class="ku kv hi kj b fi la kx l ky kz">link: post_url,</span><span id="fbad" class="ku kv hi kj b fi la kx l ky kz">},</span><span id="d66a" class="ku kv hi kj b fi la kx l ky kz">time_stamp: Math.round(new Date().getTime() / 1000),</span><span id="99fb" class="ku kv hi kj b fi la kx l ky kz">};</span></pre><figure class="kk kl km kn fd ir"><div class="bz dy l di"><div class="ko kp l"/></div></figure><p id="cc64" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated">这种解决方案有局限性，因为</p><p id="0395" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated">脸书经常更改UI元素选择器，因为我已经对页面进行了评估，以找出可见文本内容并执行抓取。但是也有改变这些因素的风险。所以我们需要维持我们的解决方案。</p><p id="887b" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated">有安全方面的担忧，好像铲运机在短时间内做了很多动作脸书·布莱克因为超过速率限制上市了一段时间。</p><p id="431c" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated">感谢您的阅读！</p></div></div>    
</body>
</html>