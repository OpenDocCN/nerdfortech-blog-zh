<html>
<head>
<title>How to solve Dijkstra’s Problem(Pathfinding Problem)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何解决 Dijkstra 的问题(寻路问题)</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/how-to-solve-dijkstras-problem-pathfinding-problem-4ba4dbe43e8f?source=collection_archive---------15-----------------------#2021-04-01">https://medium.com/nerd-for-tech/how-to-solve-dijkstras-problem-pathfinding-problem-4ba4dbe43e8f?source=collection_archive---------15-----------------------#2021-04-01</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="dcb2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果我们搜索<strong class="ih hj"> Dijkstra 的算法</strong>，那么我们看到定义为<em class="jd">寻找从源顶点到所有其他顶点或任何特定顶点</em>的最短路径。我们在任何地方都能看到这种说法，这一点也很清楚。</p><p id="b321" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">首先，Dijkstra 的算法是基于贪婪方法的，那么什么是贪婪方法呢？<strong class="ih hj">贪婪方法</strong>是一种方法，在这种方法中，我们找到可用的最佳选择，并假设它会引导我们找到最佳解决方案。</p><h2 id="9bb0" class="je jf hi bd jg jh ji jj jk jl jm jn jo iq jp jq jr iu js jt ju iy jv jw jx jy bi translated">Dijkstra 算法的基础</h2><ul class=""><li id="0c70" class="jz ka hi ih b ii kb im kc iq kd iu ke iy kf jc kg kh ki kj bi translated">从我们选择的源节点开始，它分析图形以找到该节点和图形中所有其他节点之间的最短路径。</li><li id="6477" class="jz ka hi ih b ii kk im kl iq km iu kn iy ko jc kg kh ki kj bi translated">跟踪当前已知的最短路径，如果找到更短的路径，它会更新这些值。</li><li id="e322" class="jz ka hi ih b ii kk im kl iq km iu kn iy ko jc kg kh ki kj bi translated">一旦一个特定的节点访问了所有的相邻节点，那么我们就将该节点标记为<em class="jd">已访问。</em></li><li id="7fc2" class="jz ka hi ih b ii kk im kl iq km iu kn iy ko jc kg kh ki kj bi translated">过程继续，直到所有节点都没有被标记。这样我们就找到了从每个节点到所有其他节点的最短路径。</li></ul><h2 id="1403" class="je jf hi bd jg jh ji jj jk jl jm jn jo iq jp jq jr iu js jt ju iy jv jw jx jy bi translated">例子</h2><figure class="kq kr ks kt fd ku er es paragraph-image"><div role="button" tabindex="0" class="kv kw di kx bf ky"><div class="er es kp"><img src="../Images/54152b42cfc1c58cf8961b6ba0819649.png" data-original-src="https://miro.medium.com/v2/resize:fit:800/format:webp/1*z3lIU--PQZlC2P4gRq6lFw.png"/></div></div></figure><p id="744c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果我们以上图为例，那么我们必须首先选择我们的源节点。之后，我们用 0(零)初始化源节点，用无穷大(∞)初始化所有其他节点。现在我们通过首先访问邻居节点来开始寻找较短的路径。</p><p id="8e42" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">假设“A”作为源节点，并将源节点值初始化为 0，并将所有其他节点值初始化为无穷大(∞)。“A”的邻居是“B”和“C ”,如果我们从 A 访问 B，那么节点 B 的值将变为 3，因为 3 小于无穷大。类似地，对于节点 C，从 A 到现在的较短路径是(A -&gt; C)。因此，节点 C 的值将变为 1。</p><p id="aaf0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果我们看到这里(B 和 C 之间)，我们发现 B 和 C 之间的路径值是 7，比我们通过 A 访问的路径值大，所以我们不改变 B 的节点值。</p><p id="0289" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果我们坚持使用这个算法，我们现在可以完成任何来源的所有节点的最短路径。</p><h2 id="802c" class="je jf hi bd jg jh ji jj jk jl jm jn jo iq jp jq jr iu js jt ju iy jv jw jx jy bi translated">履行</h2><pre class="kq kr ks kt fd lb lc ld le aw lf bi"><span id="f654" class="je jf hi lc b fi lg lh l li lj">function Dijkstra(Graph, source):<br/>       dist[source]  := 0         <br/>       for each vertex v in Graph:            <br/>           if v ≠ source<br/>               dist[v]  := infinity           <br/>           add v to Q                         </span><span id="d77d" class="je jf hi lc b fi lk lh l li lj">      while Q is not empty:                  <br/>          v := vertex in Q with min dist[v]  <br/>          remove v from Q </span><span id="8b87" class="je jf hi lc b fi lk lh l li lj">          for each neighbor u of v:           <br/>              alt := dist[v] + length(v, u)<br/>              if alt &lt; dist[u]:               <br/>                  dist[u]  := alt            <br/>      return dist[]<br/>  end function</span></pre><h2 id="3b87" class="je jf hi bd jg jh ji jj jk jl jm jn jo iq jp jq jr iu js jt ju iy jv jw jx jy bi translated">代码片段</h2><pre class="kq kr ks kt fd lb lc ld le aw lf bi"><span id="d0a9" class="je jf hi lc b fi lg lh l li lj">from numpy import inf</span><span id="4175" class="je jf hi lc b fi lk lh l li lj">def search(source, target, graph, costs, parents):<br/>    <br/>    nextNode = source<br/>    <br/>    while nextNode != target:<br/>        <br/>        for neighbor in graph[nextNode]:<br/>            <br/>            if graph[nextNode][neighbor] + costs[nextNode] &lt; costs[neighbor]:<br/>                <br/>                costs[neighbor] = graph[nextNode][neighbor] + costs[nextNode]<br/>                <br/>                parents[neighbor] = nextNode<br/>                <br/>            del graph[neighbor][nextNode]<br/>            <br/>        del costs[nextNode]<br/>        <br/>        nextNode = min(costs, key=costs.get)<br/>        <br/>    return parents</span><span id="7210" class="je jf hi lc b fi lk lh l li lj">def backpedal(source, target, searchResult):<br/>    <br/>    node = target<br/>    <br/>    backpath = [target]<br/>    <br/>    path = []<br/>    <br/>    while node != source:<br/>        <br/>        backpath.append(searchResult[node])<br/>        <br/>        node = searchResult[node]<br/>        <br/>    for i in range(len(backpath)):<br/>        <br/>        path.append(backpath[-i - 1])<br/>        <br/>    return path<br/>    <br/>    <br/>graph = {'A': {'C': 5, 'D': 1, 'E': 2}, 'B': {'H': 1, 'G': 3}, 'C': {'I': 2, 'D': 3, 'A': 5},<br/>         'D': {'C': 3, 'A': 1, 'H': 2}, 'E': {'A': 2, 'F': 3},<br/>         'F': {'E': 3, 'G': 1}, 'G': {'F': 1, 'B': 3, 'H': 2}, 'H': {'I': 2, 'D': 2, 'B': 1, 'G': 2},<br/>         'I': {'C': 2, 'H': 2}}</span><span id="ccc6" class="je jf hi lc b fi lk lh l li lj">costs = {'A': 0, 'B': inf, 'C': inf, 'D': inf, 'E': inf, 'F': inf, 'G': inf, 'H': inf, 'I': inf}</span><span id="3a95" class="je jf hi lc b fi lk lh l li lj">parents = {}</span><span id="aac4" class="je jf hi lc b fi lk lh l li lj">result = search('A', 'B', graph, costs, parents)</span><span id="03e9" class="je jf hi lc b fi lk lh l li lj">print('parent dictionary={}'.format(result))</span><span id="0a28" class="je jf hi lc b fi lk lh l li lj">print('longest path={}'.format(backpedal('A', 'B', result)))</span></pre><figure class="kq kr ks kt fd ku er es paragraph-image"><div role="button" tabindex="0" class="kv kw di kx bf ky"><div class="er es ll"><img src="../Images/f7a42b69819d7cf3faec4a33c4a0bdd7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ulYakkMHKx3w1HgDRp1GhQ.png"/></div></div></figure><p id="f280" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">上面的代码给出了以下输出:</p><figure class="kq kr ks kt fd ku er es paragraph-image"><div role="button" tabindex="0" class="kv kw di kx bf ky"><div class="er es lm"><img src="../Images/a4d9ef279a2d1b36b5c8d7ba7ed85309.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bY-AaGCs5o298STLlD8QNw.png"/></div></div></figure></div></div>    
</body>
</html>