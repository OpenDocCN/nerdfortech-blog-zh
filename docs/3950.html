<html>
<head>
<title>Dynamic page generation in GatsbyJS</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">GatsbyJS 中的动态页面生成</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/dynamic-page-generation-in-gatsbyjs-60c8a4609036?source=collection_archive---------12-----------------------#2021-06-30">https://medium.com/nerd-for-tech/dynamic-page-generation-in-gatsbyjs-60c8a4609036?source=collection_archive---------12-----------------------#2021-06-30</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="749f" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">避免复制粘贴 HTML，支持使用布局、组件和 GraphQL 变量！</h2></div><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ix"><img src="../Images/8b2a087ae91a4cd8e8384a21c72b38c5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*cr9-kjp-jyrQBBpC.jpg"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">"照片由<a class="ae jn" href="https://unsplash.com/@isaac_slo?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">艾萨克·斯洛曼</a>在<a class="ae jn" href="https://unsplash.com/s/photos/dynamic?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄"</figcaption></figure><p id="91a6" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">🔔这篇文章最初发布在我的网站上，<a class="ae jn" href="https://mihaibojin.com/personal-site/dynamic-page-generation-gatsbyjs?utm_source=Medium&amp;utm_medium=organic&amp;utm_campaign=rss" rel="noopener ugc nofollow" target="_blank">MihaiBojin.com</a>。🔔</p></div><div class="ab cl kk kl gp km" role="separator"><span class="kn bw bk ko kp kq"/><span class="kn bw bk ko kp kq"/><span class="kn bw bk ko kp"/></div><div class="hb hc hd he hf"><p id="9571" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">最近，我一直在努力为我的网站生成内容。因此，很自然地，它分为多个类别。</p><p id="bd37" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">我发现自己在复制粘贴页面，更改标题、描述和 GraphQL 查询，这对于我的喜好来说有点太多了。</p><p id="e0a6" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">我没有受到启发！</p><p id="e4d2" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">并决定做一些更好的事情…</p><p id="0935" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">下面是我使用一个通用模板动态生成分类页面的方法。</p><h2 id="732b" class="kr ks hi bd kt ku kv kw kx ky kz la lb jx lc ld le kb lf lg lh kf li lj lk ll bi translated">在 gatsby-config.js 中创建类别元数据</h2><p id="6224" class="pw-post-body-paragraph jo jp hi jq b jr lm ij jt ju ln im jw jx lo jz ka kb lp kd ke kf lq kh ki kj hb bi translated">首先，我在<code class="du lr ls lt lu b">gatsby-config.js</code>的<code class="du lr ls lt lu b">siteMetadata</code>数组中定义了我的类别。</p><pre class="iy iz ja jb fd lv lu lw lx aw ly bi"><span id="92d6" class="kr ks hi lu b fi lz ma l mb mc">"categories": [<br/>    {<br/>      "title": "Blog",<br/>      "href": "/blog",<br/>      "description": "My blog. I write about my journey as a software engineering lead and content creator.",<br/>      "pageHeading": "From the blog",<br/>      "pageSubtitle": "Explore some of my blog posts as I embark on a journey to build my site from scratch using GatsbyJS and TailwindUI."<br/>    },<br/>    ...<br/>  ]</span></pre><h2 id="3494" class="kr ks hi bd kt ku kv kw kx ky kz la lb jx lc ld le kb lf lg lh kf li lj lk ll bi translated">在 gatsby-node.js 中动态创建页面</h2><p id="60a2" class="pw-post-body-paragraph jo jp hi jq b jr lm ij jt ju ln im jw jx lo jz ka kb lp kd ke kf lq kh ki kj hb bi translated">然后，我扩展了 Gatsby 的页面创建 API:</p><pre class="iy iz ja jb fd lv lu lw lx aw ly bi"><span id="2e6c" class="kr ks hi lu b fi lz ma l mb mc">exports.createPages = async ({ graphql, actions, reporter }) =&gt; {<br/>  await createCategoryPages({ graphql, actions, reporter }); // a new async function I created<br/>};</span></pre><p id="05d9" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">我根据上下文来划分不同的功能。我定义了一个负责创建类别的函数。</p><pre class="iy iz ja jb fd lv lu lw lx aw ly bi"><span id="91d0" class="kr ks hi lu b fi lz ma l mb mc">async function createCategoryPages({ graphql, actions, reporter }) {<br/>  const { createPage } = actions;<br/><br/>  // logic here, see below<br/>}</span></pre><p id="b511" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">我在函数体中加载了站点的元数据；我需要关于我的类别和作者的信息。</p><pre class="iy iz ja jb fd lv lu lw lx aw ly bi"><span id="b804" class="kr ks hi lu b fi lz ma l mb mc">const result = await graphql(<br/>    `<br/>      {<br/>        site {<br/>          siteMetadata {<br/>            categories {<br/>              title<br/>              href<br/>              description<br/>              pageHeading<br/>              pageSubtitle<br/>            }<br/>            author {<br/>              name<br/>              href<br/>            }<br/>          }<br/>        }<br/>      }<br/>    `,<br/>  );</span></pre><p id="f1a1" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">接下来是验证步骤。我跳过了验证代码，但基本上，这是对这些对象的空检查，然后调用<code class="du lr ls lt lu b">reporter.warn</code>或<code class="du lr ls lt lu b">reporter.panicOnBuild</code>。</p><pre class="iy iz ja jb fd lv lu lw lx aw ly bi"><span id="6bbe" class="kr ks hi lu b fi lz ma l mb mc">const siteMetadata = result.data.site?.siteMetadata;<br/>  const categories = siteMetadata?.categories;<br/>  const author = siteMetadata?.author;</span></pre><p id="56fd" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">因为组件不会改变，所以我在迭代之前缓存了它。</p><pre class="iy iz ja jb fd lv lu lw lx aw ly bi"><span id="c5c1" class="kr ks hi lu b fi lz ma l mb mc">const component = path.resolve(`./src/components/category.js`);</span></pre><p id="8fe9" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">最后，我遍历了所有类别来创建每个页面。</p><pre class="iy iz ja jb fd lv lu lw lx aw ly bi"><span id="a2be" class="kr ks hi lu b fi lz ma l mb mc">categories.forEach((page) =&gt; {<br/>    createPage({<br/>      path: page.href,<br/>      component,<br/>      context: {<br/>        ...page,<br/>        author,<br/>      },<br/>    });<br/>  });</span></pre><p id="b802" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">注意:<code class="du lr ls lt lu b">component</code>将需要加载每个类别的文章列表。由于站点有多个类别的文章，我们需要传递一些东西来构造正确的查询。在 Gatsby 中，这是通过页面上下文传递数据来实现的。GraphQL 页面查询可以利用由上下文传递的任何<a class="ae jn" href="https://www.gatsbyjs.com/docs/how-to/querying-data/page-query/#how-to-add-query-variables-to-a-page-query" rel="noopener ugc nofollow" target="_blank">变量。</a></p><h2 id="89c0" class="kr ks hi bd kt ku kv kw kx ky kz la lb jx lc ld le kb lf lg lh kf li lj lk ll bi translated">使用变量按类别过滤文章</h2><p id="1389" class="pw-post-body-paragraph jo jp hi jq b jr lm ij jt ju ln im jw jx lo jz ka kb lp kd ke kf lq kh ki kj hb bi translated">对于我的网站，我选择按每个类别的标题进行过滤。我可以很容易地通过类别的 href 进行过滤，但我也不打算做太多改变。时间会证明这是否是正确的选择…</p><p id="cfde" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">我更新了旧的查询:</p><pre class="iy iz ja jb fd lv lu lw lx aw ly bi"><span id="a3af" class="kr ks hi lu b fi lz ma l mb mc">query {<br/>    allMarkdownRemark(<br/>        sort: { fields: [frontmatter___date], order: DESC }<br/>        filter: {<br/>          frontmatter: {<br/>            category: {<br/>              title: { eq: "A category title" }<br/>            }<br/>          }<br/>        }<br/>    ) {<br/>        nodes {<br/>        ...<br/>        }<br/>    }<br/>}</span></pre><p id="c32a" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">通过给它一个名字并传递<code class="du lr ls lt lu b">$title</code>变量。</p><p id="7911" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">这个变量从页面的上下文中自动填充——🪄<strong class="jq hj">魔法</strong> 🪄！</p><pre class="iy iz ja jb fd lv lu lw lx aw ly bi"><span id="3aac" class="kr ks hi lu b fi lz ma l mb mc">query CategoryQuery($title: String!) {<br/>    allMarkdownRemark(<br/>        sort: { fields: [frontmatter___date], order: DESC }<br/>        filter: {<br/>          frontmatter: {<br/>            category: {<br/>              title: { eq: $title }<br/>            }<br/>          }<br/>        }<br/>    ) {<br/>        nodes {<br/>        ...<br/>        }<br/>    }<br/>}</span></pre><p id="f72e" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">我剩下要做的就是加载页面数据并填充我的模板:</p><pre class="iy iz ja jb fd lv lu lw lx aw ly bi"><span id="f605" class="kr ks hi lu b fi lz ma l mb mc">export default function Page({ data, pageContext }) {<br/>  const {<br/>    title,<br/>    description,<br/>    pageHeading,<br/>    pageSubtitle,<br/>    author,<br/>  } = pageContext;<br/>  const posts = data.allMarkdownRemark.nodes;<br/>  return (<br/>    &lt;&gt;<br/>        ...<br/>    &lt;/&gt;<br/>  );<br/>}</span></pre><p id="521d" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">瞧啊。动态生成的页面:</p><ul class=""><li id="2219" class="md me hi jq b jr js ju jv jx mf kb mg kf mh kj mi mj mk ml bi translated"><a class="ae jn" href="https://mihaibojin.com/blog?utm_source=Medium&amp;utm_medium=organic&amp;utm_campaign=rss" rel="noopener ugc nofollow" target="_blank">博客</a></li><li id="9894" class="md me hi jq b jr mm ju mn jx mo kb mp kf mq kj mi mj mk ml bi translated"><a class="ae jn" href="https://mihaibojin.com/coding-puzzles?utm_source=Medium&amp;utm_medium=organic&amp;utm_campaign=rss" rel="noopener ugc nofollow" target="_blank">编码拼图</a></li><li id="0224" class="md me hi jq b jr mm ju mn jx mo kb mp kf mq kj mi mj mk ml bi translated"><a class="ae jn" href="https://mihaibojin.com/ic?utm_source=Medium&amp;utm_medium=organic&amp;utm_campaign=rss" rel="noopener ugc nofollow" target="_blank">个人贡献者</a></li></ul></div><div class="ab cl kk kl gp km" role="separator"><span class="kn bw bk ko kp kq"/><span class="kn bw bk ko kp kq"/><span class="kn bw bk ko kp"/></div><div class="hb hc hd he hf"><p id="7bb8" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">如果你喜欢这篇文章，并想阅读更多类似的文章，请订阅我的简讯。我每隔几周就发一封！</p></div></div>    
</body>
</html>