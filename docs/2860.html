<html>
<head>
<title>Middleware — The heart of express</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">中间件express的心脏</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/middleware-the-heart-of-express-671fccd24dc?source=collection_archive---------42-----------------------#2021-05-21">https://medium.com/nerd-for-tech/middleware-the-heart-of-express-671fccd24dc?source=collection_archive---------42-----------------------#2021-05-21</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/d6ff227548153f0b58ad970e379853dc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*sBqRa6W5m4tzzs_a"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">尼古拉·菲奥拉万蒂在<a class="ae iu" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><p id="c478" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">Express是一个非常容易执行和学习的最小框架。但是是什么让express如此简单却如此强大呢？答案是中间件。</p></div><div class="ab cl jt ju gp jv" role="separator"><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy"/></div><div class="hb hc hd he hf"><h2 id="cba6" class="ka kb hi bd kc kd ke kf kg kh ki kj kk jg kl km kn jk ko kp kq jo kr ks kt ku bi translated">但是中间件到底是什么？</h2><p id="8449" class="pw-post-body-paragraph iv iw hi ix b iy kv ja jb jc kw je jf jg kx ji jj jk ky jm jn jo kz jq jr js hb bi translated">中间件是一种功能。这是一个在收到请求之后、响应发送之前执行的函数。在处理实际请求之前，它通常包含额外的业务逻辑或任务，如验证等。让我们看一个关于中间件的简单例子。</p><pre class="la lb lc ld fd le lf lg lh aw li bi"><span id="afad" class="ka kb hi lf b fi lj lk l ll lm">const express = require("express");</span><span id="43a9" class="ka kb hi lf b fi ln lk l ll lm">const app = express();</span><span id="0768" class="ka kb hi lf b fi ln lk l ll lm">// using this function as middleware<br/>const toUpper = (req, res, next) =&gt; {</span><span id="c2e1" class="ka kb hi lf b fi ln lk l ll lm">  req.query.name = req.query.name.toUpperCase();</span><span id="bd29" class="ka kb hi lf b fi ln lk l ll lm">  // pass control to next middleware<br/>  next();</span><span id="44bb" class="ka kb hi lf b fi ln lk l ll lm">};</span><span id="2a8b" class="ka kb hi lf b fi ln lk l ll lm">app.get("/", toUpper, (req, res) =&gt; {</span><span id="fb4b" class="ka kb hi lf b fi ln lk l ll lm">  res.send(req.query.name);</span><span id="4aab" class="ka kb hi lf b fi ln lk l ll lm">});</span><span id="7574" class="ka kb hi lf b fi ln lk l ll lm">app.listen(5000, () =&gt; {</span><span id="e24d" class="ka kb hi lf b fi ln lk l ll lm">  console.log("listening on port %s", 5000);</span><span id="c716" class="ka kb hi lf b fi ln lk l ll lm">});</span></pre></div><div class="ab cl jt ju gp jv" role="separator"><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy"/></div><div class="hb hc hd he hf"><h2 id="2997" class="ka kb hi bd kc kd ke kf kg kh ki kj kk jg kl km kn jk ko kp kq jo kr ks kt ku bi translated">下一个关键字</h2><p id="30e5" class="pw-post-body-paragraph iv iw hi ix b iy kv ja jb jc kw je jf jg kx ji jj jk ky jm jn jo kz jq jr js hb bi translated">在使用多个中间件功能时，有一个特殊的关键字<em class="lo"> next </em>会派上用场。每当一个中间件完成了它的工作，您可以使用<em class="lo"> next() </em>语句调用下一个中间件。就像上面的例子一样，如果您从代码中删除了<em class="lo"> next() </em>，控制权将不会传递给下一个中间件，客户端也不会收到任何响应。因此，请记住，要么使用<em class="lo"> res </em>函数进行响应，要么使用<em class="lo"> next()。</em></p></div><div class="ab cl jt ju gp jv" role="separator"><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy"/></div><div class="hb hc hd he hf"><h2 id="4299" class="ka kb hi bd kc kd ke kf kg kh ki kj kk jg kl km kn jk ko kp kq jo kr ks kt ku bi translated">但是我为什么要用中间件呢？</h2><p id="919b" class="pw-post-body-paragraph iv iw hi ix b iy kv ja jb jc kw je jf jg kx ji jj jk ky jm jn jo kz jq jr js hb bi translated">问得好，您可能会想，所有这些都可以在单个函数中不使用中间件函数的情况下完成。嗯，这是正确的，但是使用中间件促进了代码模块化，并在<em class="lo"> err </em>关键字的帮助下简化了错误处理。程序的流程也变得非常容易理解，而不是理解一大块代码。</p><pre class="la lb lc ld fd le lf lg lh aw li bi"><span id="36b1" class="ka kb hi lf b fi lj lk l ll lm">// this function will throw error if parameter name is not defined</span><span id="b247" class="ka kb hi lf b fi ln lk l ll lm">const toUpper = (req, res, next) =&gt; {</span><span id="d094" class="ka kb hi lf b fi ln lk l ll lm">  req.query.name = req.query.name.toUpperCase();</span><span id="81e7" class="ka kb hi lf b fi ln lk l ll lm">  next();</span><span id="74be" class="ka kb hi lf b fi ln lk l ll lm">};</span><span id="c6cd" class="ka kb hi lf b fi ln lk l ll lm">const addGreeting = (err, req, res, next) =&gt; {</span><span id="0de1" class="ka kb hi lf b fi ln lk l ll lm">  // err catches the error from previous middleware<br/>  if (err) {</span><span id="d393" class="ka kb hi lf b fi ln lk l ll lm">    res.send(err.message);</span><span id="fb62" class="ka kb hi lf b fi ln lk l ll lm">  } else {</span><span id="f5c5" class="ka kb hi lf b fi ln lk l ll lm">    // send a greeting if no errors<br/>    req.query.name = "Hello " + req.query.name;</span><span id="e79d" class="ka kb hi lf b fi ln lk l ll lm">    next();</span><span id="5579" class="ka kb hi lf b fi ln lk l ll lm">  }</span><span id="36d7" class="ka kb hi lf b fi ln lk l ll lm">};</span><span id="94ea" class="ka kb hi lf b fi ln lk l ll lm">// we are passing two middleware functions here<br/>app.get("/", toUpper, addGreeting, (req, res) =&gt; {</span><span id="cc7c" class="ka kb hi lf b fi ln lk l ll lm">  res.send(req.query.name);</span><span id="3226" class="ka kb hi lf b fi ln lk l ll lm">});</span></pre></div><div class="ab cl jt ju gp jv" role="separator"><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy"/></div><div class="hb hc hd he hf"><h2 id="ada9" class="ka kb hi bd kc kd ke kf kg kh ki kj kk jg kl km kn jk ko kp kq jo kr ks kt ku bi translated">库函数作为中间件</h2><p id="c997" class="pw-post-body-paragraph iv iw hi ix b iy kv ja jb jc kw je jf jg kx ji jj jk ky jm jn jo kz jq jr js hb bi translated">有许多库提供了用作中间件的功能。通常，这些用于应用程序级路由，并在实际业务逻辑之前对请求执行操作。在下面的例子中，我们使用了来自<em class="lo"> cors </em>和<em class="lo"> body-parser </em>库的函数作为中间件</p><pre class="la lb lc ld fd le lf lg lh aw li bi"><span id="659b" class="ka kb hi lf b fi lj lk l ll lm">const app = express();</span><span id="02c5" class="ka kb hi lf b fi ln lk l ll lm">// all the requests coming in the server will pass through<br/>// the below middlewares<br/>app.use(</span><span id="9daa" class="ka kb hi lf b fi ln lk l ll lm">  cors({origin: "http://localhost:3000"})</span><span id="93de" class="ka kb hi lf b fi ln lk l ll lm">);<br/>app.use(bodyParser.json());</span><span id="71df" class="ka kb hi lf b fi ln lk l ll lm"><br/>/*<br/>   ****all the other middleares and routes here****<br/>*/</span><span id="3e9f" class="ka kb hi lf b fi ln lk l ll lm"><br/>const port = 5000;</span><span id="043d" class="ka kb hi lf b fi ln lk l ll lm">app.listen(port, () =&gt; {</span><span id="b211" class="ka kb hi lf b fi ln lk l ll lm">  console.log("listening on port %s", port);</span><span id="927f" class="ka kb hi lf b fi ln lk l ll lm">});</span></pre></div><div class="ab cl jt ju gp jv" role="separator"><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy"/></div><div class="hb hc hd he hf"><p id="40d2" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这是所有的乡亲。留下掌声👏如果你喜欢这篇文章。下一集见。</p></div></div>    
</body>
</html>