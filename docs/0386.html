<html>
<head>
<title>Learning Go — Pointers</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">学习围棋——指针</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/learning-go-pointers-195b5c1f9b85?source=collection_archive---------2-----------------------#2020-11-20">https://medium.com/nerd-for-tech/learning-go-pointers-195b5c1f9b85?source=collection_archive---------2-----------------------#2020-11-20</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/f5bb59682f6053470d75c70cac45c605.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AJAGtpn_f7wMFdcwFn95LA.png"/></div></div></figure><h1 id="bad1" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated"><strong class="ak">指针</strong></h1><p id="2f0b" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">指针是一个变量，它存储另一个变量引用的内存地址。指针有能力改变它们所指向的数据。</p><p id="436e" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">如果您来自C/C++背景，那么您肯定使用过指针(*)。指针是编程语言中最复杂和最强大的范例之一。</p><h2 id="df5f" class="kr ir hi bd is ks kt ku iw kv kw kx ja jz ky kz je kd la lb ji kh lc ld jm le bi translated"><strong class="ak">初始化一个指针</strong></h2><pre class="lf lg lh li fd lj lk ll lm aw ln bi"><span id="9820" class="kr ir hi lk b fi lo lp l lq lr">arrA := [...] int{1, 3, 5}<br/>var b *int = &amp;arrA[0]</span></pre><p id="df4b" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">观察<strong class="jq hj"> &amp;(地址)</strong>操作符。当我们讨论数组和切片时，我们已经在以前的一篇帖子中讨论过这一点。</p><h2 id="eae8" class="kr ir hi bd is ks kt ku iw kv kw kx ja jz ky kz je kd la lb ji kh lc ld jm le bi translated"><strong class="ak">修改指针参考值</strong></h2><pre class="lf lg lh li fd lj lk ll lm aw ln bi"><span id="7972" class="kr ir hi lk b fi lo lp l lq lr">arrA := [...] int{1, 3, 5}<br/>var b *int = &amp;arrA[0]<br/>fmt.Println("value : ", arrA[0])<br/>*b = 10   // update value of a pointer references address<br/>fmt.Println("New value : ", arrA[0])</span><span id="c52b" class="kr ir hi lk b fi ls lp l lq lr">Result<br/>value :  1<br/>New value :  10</span></pre><p id="3a77" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">注意，当我们使用<strong class="jq hj"> (*b) </strong>更新<strong class="jq hj"> b </strong>引用地址的值并分配一个新值时，原始数组中的值得到更新。</p><p id="16cd" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated"><strong class="jq hj"> *(解引用操作符)<br/></strong>*操作符必须与指针变量名称一起使用，对指针变量引用的内存位置中的值进行操作。</p></div><div class="ab cl lt lu gp lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="hb hc hd he hf"><h1 id="bfee" class="iq ir hi bd is it ma iv iw ix mb iz ja jb mc jd je jf md jh ji jj me jl jm jn bi translated"><strong class="ak">指针和结构</strong></h1><p id="bcc8" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">结构可以通过指针访问。<br/>记住我们上一篇文章中的员工结构！</p><pre class="lf lg lh li fd lj lk ll lm aw ln bi"><span id="8aad" class="kr ir hi lk b fi lo lp l lq lr">type Employee struct {<br/>   id int<br/>   name string<br/>   dept []string<br/>}</span></pre><p id="e2c3" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">让我们尝试使用指针来保存对struct实例的引用。</p><pre class="lf lg lh li fd lj lk ll lm aw ln bi"><span id="823b" class="kr ir hi lk b fi lo lp l lq lr">pntrStr := &amp;Employee{}<br/>fmt.Println(*pntrStr, pntrStr)    // print value of the pointer reference and pointer<br/>pntrStr.name = "value"    // modify the value of name<br/>fmt.Println(pntrStr)     // print value of the pointer</span><span id="d96c" class="kr ir hi lk b fi ls lp l lq lr">Result<br/>{0 []} {0  []}<br/>&amp;{0 value []}</span></pre><p id="291d" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">观察我们使用指针变量访问结构的字段<strong class="jq hj">名称</strong>的方式。这和我们使用正态变量的方法是一样的。但是我们不是讨论过需要在指针变量名后面附加一个*来访问它的值吗？嗯，这是T21合成糖。实际的方法应该是</p><pre class="lf lg lh li fd lj lk ll lm aw ln bi"><span id="ab6a" class="kr ir hi lk b fi lo lp l lq lr">(*pntrStr).name = "look at this"</span></pre><p id="157f" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">但是具有struct的指针可以使用</p><pre class="lf lg lh li fd lj lk ll lm aw ln bi"><span id="203f" class="kr ir hi lk b fi lo lp l lq lr">pntrStr.name = "value"</span></pre></div><div class="ab cl lt lu gp lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="hb hc hd he hf"><h2 id="688c" class="kr ir hi bd is ks kt ku iw kv kw kx ja jz ky kz je kd la lb ji kh lc ld jm le bi translated"><strong class="ak">未初始化的指针</strong></h2><p id="2ad6" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">Go中未初始化的指针有一个唯一的值<strong class="jq hj"> nil。</strong>所以在使用一个指针值之前，你可以保持对它的值不为零的验证。</p></div><div class="ab cl lt lu gp lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="hb hc hd he hf"><h2 id="c821" class="kr ir hi bd is ks kt ku iw kv kw kx ja jz ky kz je kd la lb ji kh lc ld jm le bi translated"><strong class="ak">指针操作</strong></h2><p id="342d" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated"><strong class="jq hj"> ==，！= </strong> <br/>如果两个指针都指向内存中的同一个变量，那么它们可以相等。否则他们是不平等的。</p></div><div class="ab cl lt lu gp lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="hb hc hd he hf"><h2 id="2a8a" class="kr ir hi bd is ks kt ku iw kv kw kx ja jz ky kz je kd la lb ji kh lc ld jm le bi translated"><strong class="ak">作为函数参数的指针</strong></h2><p id="4729" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">指针是围棋中的特殊变量。但是它们仍然是变量，因此可以作为函数签名中的参数传入。</p><pre class="lf lg lh li fd lj lk ll lm aw ln bi"><span id="43ee" class="kr ir hi lk b fi lo lp l lq lr">func f(a<!-- --> *<!-- -->int) {<!-- --> <!-- -->    fmt.Println(*a)<!-- --> <!-- -->}</span></pre><p id="e235" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">不要担心函数定义。我们将在后面的文章中讨论这个问题。观察Println函数中传递的指针值。</p></div><div class="ab cl lt lu gp lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="hb hc hd he hf"><h2 id="9588" class="kr ir hi bd is ks kt ku iw kv kw kx ja jz ky kz je kd la lb ji kh lc ld jm le bi translated"><strong class="ak">新关键字</strong></h2><p id="14df" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">Go中的<strong class="jq hj">新</strong>函数返回一个指向类型的指针</p><pre class="lf lg lh li fd lj lk ll lm aw ln bi"><span id="2b6a" class="kr ir hi lk b fi lo lp l lq lr">var pntrStr2 *Employee<br/>pntrStr2 = new(Employee)<br/>fmt.Println(pntrStr2, *pntrStr2)</span></pre><p id="8469" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">观察使用情况。<strong class="jq hj"> new </strong>返回指向Employee struct新实例的指针。</p></div><div class="ab cl lt lu gp lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="hb hc hd he hf"><h2 id="eacb" class="kr ir hi bd is ks kt ku iw kv kw kx ja jz ky kz je kd la lb ji kh lc ld jm le bi translated"><strong class="ak">结尾注释</strong></h2><p id="f660" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">Go和c语言中的指针有一些重要的区别需要注意。</p><ul class=""><li id="2b68" class="mf mg hi jq b jr km jv kn jz mh kd mi kh mj kl mk ml mm mn bi translated">类似于C/C++中指针的空值，Go对指针有nil。</li><li id="0b94" class="mf mg hi jq b jr mo jv mp jz mq kd mr kh ms kl mk ml mm mn bi translated">Go不像C/C++那样提供指针算法。这使得它比C/C++更安全，同时提供了令人惊叹的功能。</li><li id="7ef5" class="mf mg hi jq b jr mo jv mp jz mq kd mr kh ms kl mk ml mm mn bi translated">使用不安全的包有办法改变指针。但是除非有特殊原因，否则不要玩这个游戏。</li></ul><p id="c333" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">我想这是它的指针。这篇文章给你关于指针和如何使用它的基本理解。当我们到达Go 主题中的<strong class="jq hj">接口时，我们将观察更多的使用风格。</strong></p><p id="dad5" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">就这样，我们的帖子到此结束。我试图尽可能地涵盖更多内容，并为您提供见解及其用例与实现。<strong class="jq hj">你可以在帖子上评论任何细节或不一致的问题</strong>。或者你可能想根据你的兴趣谷歌一下复杂的细节。</p><p id="d2b2" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">下一篇文章将会介绍围棋中的<strong class="jq hj"> <em class="mt">函数和方法</em> </strong>。</p></div></div>    
</body>
</html>