<html>
<head>
<title>Coroutines in Unity</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Unity 中的协程</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/coroutines-in-unity-ab056874bff?source=collection_archive---------2-----------------------#2021-09-17">https://medium.com/nerd-for-tech/coroutines-in-unity-ab056874bff?source=collection_archive---------2-----------------------#2021-09-17</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="97f0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">目标:</strong>每两秒钟随机改变物体的颜色。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es jd"><img src="../Images/44125ae14b57fa66bd0f599c52c345f4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1072/1*BxMzMLseF_xJ4yjwopcw8Q.gif"/></div></figure><p id="5133" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">一个<em class="jl">协程</em>将允许我们在其他进程运行的同时执行一个进程。<em class="jl">当我们想要延迟一个进程时，协程</em>也很有用。在我们的示例中，我们将两者都做:在形状旋转时改变颜色，每次改变之间等待 2 秒钟。</p><p id="fd23" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们将从设置等待时间(2 秒)和缓存对象的<em class="jl"> MeshRenderer </em>和<em class="jl"> WaitForSeconds </em>类的引用开始。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es jm"><img src="../Images/a3aa64fe1821ad16edbbf32f78f56352.png" data-original-src="https://miro.medium.com/v2/resize:fit:906/format:webp/1*Z2pWFYi3NQQEJXcs9J93QQ.png"/></div></figure><p id="3467" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在<em class="jl"> Start </em>方法中，我们将获得对象的<em class="jl"> MeshRenderer </em>组件，并定义<em class="jl"> WaitForSeconds </em>类。然后我们将调用<em class="jl"> ChangeColorRoutine </em>协程(稍后会详细介绍)。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es jn"><img src="../Images/d7c429abc1c30fe7f879c9955d3eab17.png" data-original-src="https://miro.medium.com/v2/resize:fit:1036/format:webp/1*t3yO667TdaPA5u96G84AIA.png"/></div></figure><p id="2126" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">即使我们调用了协程，我们的<em class="jl"> Update </em>方法将继续运行，导致我们的对象旋转。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es jo"><img src="../Images/dcc70e432312ccd4a6a9383378b77e94.png" data-original-src="https://miro.medium.com/v2/resize:fit:642/format:webp/1*0F6jn6866ulq0SOYf2SfkQ.png"/></div></figure><p id="3745" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">当<em class="jl">更新</em>旋转我们的对象时，<em class="jl"> ChangeColorRoutine </em>协程会等待两秒钟，然后给我们的<em class="jl"> MeshRenderer </em>分配一个随机颜色。由于我们的<em class="jl"> while </em>语句总是<em class="jl"> true </em>，脚本将持续等待 2 秒钟，然后改变颜色！</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es jp"><img src="../Images/1cfb1c19955c58369e849b9c26168c4b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1110/format:webp/1*CLZt9TQGDWo5rO_COM1oJw.png"/></div></figure></div></div>    
</body>
</html>