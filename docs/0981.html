<html>
<head>
<title>Solving: findPairsWithGivenDiff</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">求解:findPairsWithGivenDiff</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/solving-findpairswithgivendiff-ee8dd3d747b?source=collection_archive---------8-----------------------#2021-02-27">https://medium.com/nerd-for-tech/solving-findpairswithgivendiff-ee8dd3d747b?source=collection_archive---------8-----------------------#2021-02-27</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="4ee5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在本文中，我将分解 Javascript 中的 findPairsWithGivenDiff 问题。我将遍历我的过程，用两种方法解决问题，以比较他们的 BigO。</p><p id="bb4e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们开始吧！</p><h1 id="0739" class="jd je hi bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">方向:</h1><h2 id="6294" class="kb je hi bd jf kc kd ke jj kf kg kh jn iq ki kj jr iu kk kl jv iy km kn jz ko bi translated">给定一个不同整数的数组<code class="du kp kq kr ks b">arr</code>和一个非负整数<code class="du kp kq kr ks b">k</code>，写一个函数<code class="du kp kq kr ks b">findPairsWithGivenDifference</code>，返回一个包含<code class="du kp kq kr ks b">arr</code>中所有对<code class="du kp kq kr ks b">[x,y]</code>的数组，这样<code class="du kp kq kr ks b">x - y = k</code>。如果不存在这样的对，则返回一个空数组。</h2><h2 id="e1cf" class="kb je hi bd jf kc kd ke jj kf kg kh jn iq ki kj jr iu kk kl jv iy km kn jz ko bi translated"><strong class="ak">注意:</strong>输出数组中对的顺序应该保持原数组中<code class="du kp kq kr ks b">y</code>元素的顺序。"</h2><p id="55fb" class="pw-post-body-paragraph if ig hi ih b ii kt ik il im ku io ip iq kv is it iu kw iw ix iy kx ja jb jc hb bi translated">让我们用自己的话来分析和重述这个问题。</p><p id="56a9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">输入是一组不同的整数和一个非负整数。</p><p id="1125" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们想知道有多少对提供了给定的非负整数‘k’的差。使得(x-y) = k</p><p id="a4f1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果存在这样的数组对，输出应该是数组的数组。每个子数组包含[x，y]值。如果不存在对，则返回一个空数组。</p><p id="bf2d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">子数组的放置应该遵循[x，y]子数组中“y”值的索引。</p><h2 id="036b" class="kb je hi bd jf kc kd ke jj kf kg kh jn iq ki kj jr iu kk kl jv iy km kn jz ko bi translated">从天真的方法开始。</h2><p id="d680" class="pw-post-body-paragraph if ig hi ih b ii kt ik il im ku io ip iq kv is it iu kw iw ix iy kx ja jb jc hb bi translated">让我们来看看如何解决这个问题。</p><p id="1d29" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果我们使用嵌套循环来遍历数组中的每个整数，并将其从自身中减去，那么我们可以使用一个简单的 If 语句来查看这两个值是否通过了(x-y) = k 的条件。一旦我们找到了正确的对，我们就可以将它们添加到结果数组中。为了符合索引条件，因为我们是在一个循环中，所以我们可以使用迭代值(也称为索引)将这些对放置在正确的序列中，然后在填充后过滤掉空值。</p><figure class="kz la lb lc fd ld er es paragraph-image"><div role="button" tabindex="0" class="le lf di lg bf lh"><div class="er es ky"><img src="../Images/79143f16a7eb6b81ff8fd2ab6c2e1a49.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Ug_hy6IUFjn5YyR4zuevhg.png"/></div></div></figure><p id="2d37" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在让我们看看 bigO。</p><p id="d139" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">简单的解决方案有一个 O(n)的 bigO，因为我们有一个嵌套循环在同一个数组上迭代。过滤器是另一个迭代，但是随着输入大小的缩放，我们可以相对忽略它的影响。而我们为结果创建的数组的 bigO 为 O(n ),用于插入、搜索和删除空值。</p><p id="84e4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">所以这是可行的——如果你想出了这个很棒的解决方案。</p><p id="46cc" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">但是我们怎样才能更加努力呢？好些了吗？更快？更强？</p><figure class="kz la lb lc fd ld er es paragraph-image"><div role="button" tabindex="0" class="le lf di lg bf lh"><div class="er es lk"><img src="../Images/c47b35e934dbbd9a834fe99882ba5741.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*i8t7ob6XCdPQf_1T"/></div></div></figure><p id="3b14" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">嗯，我们首先要去掉的是嵌套循环…让我们看看在嵌套循环中我们实际上在做什么。如果我们要遍历这个循环，我们实际上在做什么呢？</p><figure class="kz la lb lc fd ld er es paragraph-image"><div role="button" tabindex="0" class="le lf di lg bf lh"><div class="er es ll"><img src="../Images/3f553677aab86686845474f978fed0ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sva4fwAG9_SZfNN8tBleBQ.png"/></div></div></figure><p id="28e4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们在寻找一个能产生“k”差的数字。</p><p id="66fc" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">另一种方法是什么？</p><p id="fbea" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi">…</p><p id="d04a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi">…</p><p id="a7a4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们都知道</p><h2 id="9f97" class="kb je hi bd jf kc kd ke jj kf kg kh jn iq ki kj jr iu kk kl jv iy km kn jz ko bi translated">如果→ (x-y) = k</h2><h2 id="83b3" class="kb je hi bd jf kc kd ke jj kf kg kh jn iq ki kj jr iu kk kl jv iy km kn jz ko bi translated">那么→ (x-k) = y</h2><p id="39bb" class="pw-post-body-paragraph if ig hi ih b ii kt ik il im ku io ip iq kv is it iu kw iw ix iy kx ja jb jc hb bi translated">因此，与其用嵌套循环来计算哪些值会产生“k ”,不如我们从地图中查找我们需要的值？</p><p id="d544" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">因为我们知道(x-k)将提供匹配的“y ”,所以我们可以仅用“x”和“k”来计算“x”和“y”。因此，通过一个循环，我们可以创建一个散列映射，将所有可能的“y”值与其对应的“x”值进行映射。所以我们有一个映射，它产生{y: x}的键值对。</p><p id="8c90" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">一旦映射被填充，我们可以再次遍历数组，并简单地查找当前值是否存在于映射中。如果是，那么我们知道在数组中有一个匹配的 x。即，因为当前迭代中的值存在于映射中，如果变成我们的‘y’，并且因为我们在填充映射时用‘x’值计算了我们的‘y’，所以我们知道两者都存在于给定的数组中。</p><p id="1aef" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们看看代码:</p><figure class="kz la lb lc fd ld er es paragraph-image"><div role="button" tabindex="0" class="le lf di lg bf lh"><div class="er es lm"><img src="../Images/0c3437c04bef3501cc09e186dedbaf04.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AR7MWAZ9Hm2oFcwFPG9Tfg.png"/></div></div></figure><p id="75d7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">一些注意事项:</p><p id="b25f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">因为我们从第 15 行开始遍历数组一次，所以我们可以简单地将对推入数组，不再需要用过滤器消除任何空值。</p><p id="29fb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">因为我们映射了所有的值，所以键被转换为字符串，所以我们需要确保我们推入结果数组的值实际上是整数。我们可以使用 parseInt 将字符串表示转换为整数。</p><p id="6323" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们对' y '值和' x '值都使用 parseInt，因为在第 13 行，我们实际上是将值设置为一个字符串的键。这对于“y”值等于零的边缘情况很重要。</p><p id="eadf" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在第 17 行我们有一个短路评估，如果 diffMap[arr[i]]返回零，它将评估为假，而不是实际上被推入结果数组。通过在填充地图时将其转换为字符串，我们避免了这种情况。</p><p id="5992" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">BigO</p><p id="89da" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">通过利用哈希映射，我们已经将最坏情况下的时间复杂度提高到 O(n*log(n))，将一般情况下的时间复杂度提高到 O(n)。虽然空间复杂度保持为 O(n ),因为输出本身的大小是 O(n ),并且因为我们制作的地图将只保存 n 个元素，所以它不会增加空间复杂度。</p><p id="e26e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">希望这对你的下一个算法有所帮助！</p></div></div>    
</body>
</html>