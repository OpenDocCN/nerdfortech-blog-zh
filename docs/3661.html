<html>
<head>
<title>TiKV + SPDK: Pushing the Limits of Storage Performance</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">TiKV + SPDK:挑战存储性能的极限</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/tikv-spdk-pushing-the-limits-of-storage-performance-908ff559798b?source=collection_archive---------9-----------------------#2021-06-18">https://medium.com/nerd-for-tech/tikv-spdk-pushing-the-limits-of-storage-performance-908ff559798b?source=collection_archive---------9-----------------------#2021-06-18</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/643c32c0645f61980f8d06bbf0a4763b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*tkd7b1qBQYP6_sGM.jpg"/></div></div></figure><p id="2a8a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">作者:<a class="ae jo" href="https://github.com/YangKeao" rel="noopener ugc nofollow" target="_blank">杨克傲</a>(ping cap软件工程师)</p><p id="2a8d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">Transcreator: <a class="ae jo" href="https://github.com/ran-huang" rel="noopener ugc nofollow" target="_blank">黄然</a>；编辑:汤姆·万德</p><p id="3cb8" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现代软件的核心是分层抽象。在抽象中，每一层都隐藏了与其他层不相关的细节，并提供了一个简单、有效的接口。</p><p id="888a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">然而，因为抽象带来了系统调用的额外开销，它的简单性是以牺牲性能为代价的。因此，对于性能敏感的软件，如数据库，抽象可能会带来不必要的后果。我们如何提升这些应用的性能？</p><p id="f816" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在本文中，我将讨论现代存储结构中抽象的陷阱，以及我们如何在<a class="ae jo" href="https://pingcap.com/community/events/hackathon2020/" rel="noopener ugc nofollow" target="_blank"> TiDB Hackathon 2020 </a>上通过在TiKV中引入存储性能开发套件(SPDK)来解决这个问题。</p><h1 id="eec4" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">抽象的陷阱</h1><p id="0fa6" class="pw-post-body-paragraph iq ir hi is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hb bi translated">在抽象的魔法世界里，一切都井井有条。应用程序没有制定其执行计划；它让数据库来决定。数据库不将数据写入磁盘；它让操作系统来决定。当然，操作系统从不直接在存储单元上操作；相反，它要求磁盘的控制芯片去做。更多的时候是把具体的任务交给有更多知识的一方，让大家都开心满意。</p><p id="2cd0" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">当数据库读写数据时，它利用文件系统中的抽象。通过文件系统，数据库创建、写入和读取文件，而无需直接在硬盘上操作。当数据库启动系统调用时，需要几个步骤才能将数据最终保存到磁盘:</p><ol class=""><li id="f420" class="ks kt hi is b it iu ix iy jb ku jf kv jj kw jn kx ky kz la bi translated">操作系统接收系统调用。</li><li id="2043" class="ks kt hi is b it lb ix lc jb ld jf le jj lf jn kx ky kz la bi translated">操作系统在虚拟文件系统(VFS)和页面缓存机制上运行。</li><li id="4287" class="ks kt hi is b it lb ix lc jb ld jf le jj lf jn kx ky kz la bi translated">文件系统实现特定的行为。</li><li id="39a5" class="ks kt hi is b it lb ix lc jb ld jf le jj lf jn kx ky kz la bi translated">数据从块设备中读取和写入，I/O调度程序和设备映射器在块设备中生效。</li><li id="0394" class="ks kt hi is b it lb ix lc jb ld jf le jj lf jn kx ky kz la bi translated">系统通过硬件驱动程序向存储设备发送指令。</li><li id="a42b" class="ks kt hi is b it lb ix lc jb ld jf le jj lf jn kx ky kz la bi translated">磁盘控制器处理指令并在存储介质上操作。</li></ol><p id="2001" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这个过程可能有四个潜在的问题:</p><ul class=""><li id="faa1" class="ks kt hi is b it iu ix iy jb ku jf kv jj kw jn lg ky kz la bi translated">系统调用有很高的开销。对于I/O操作之类的复杂系统调用，系统从用户模式切换到内核模式，保存进程状态，然后恢复进程状态。如今，随着存储设备的性能大大提高，这种开销占据了更大比例的资源消耗。</li><li id="c456" class="ks kt hi is b it lb ix lc jb ld jf le jj lf jn lg ky kz la bi translated"><strong class="is hj">文件系统实施对高级应用程序有着失控的影响。</strong>不同的文件系统使用不同的数据结构来管理文件，因此适用于不同的场景。例如，<a class="ae jo" href="https://en.wikipedia.org/wiki/XFS" rel="noopener ugc nofollow" target="_blank"> XFS </a>就不擅长处理大量的小文件。高级应用程序可能无法很好地响应文件系统的变化。</li><li id="75e6" class="ks kt hi is b it lb ix lc jb ld jf le jj lf jn lg ky kz la bi translated"><strong class="is hj"> Linux优先考虑其通用性</strong>作为一个通用操作系统，这意味着它的页面缓存算法和硬件支持被设计为适用于所有应用程序和所有硬件。这意味着它没有完全优化特定软件应用程序(如数据库)和硬件(如<a class="ae jo" href="https://en.wikipedia.org/wiki/NVM_Express" rel="noopener ugc nofollow" target="_blank"> NVMe </a>驱动器)的机制。</li><li id="5c78" class="ks kt hi is b it lb ix lc jb ld jf le jj lf jn lg ky kz la bi translated"><strong class="is hj">重复记录也是一个问题。每一层抽象都试图通过日志来维护其稳定性。NVMe控制器、文件系统和RocksDB都有日志。在当前的机制中，这些重复的日志对于系统的健壮性是必不可少的。但是如果我们能从全局的角度重新设计这个系统，我们也许能移除一些日志记录。</strong></li></ul><p id="347a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">所有这些问题的解决方案是将应用程序推向更低的层次，以减少抽象。应用程序自己做的杂务越多，性能提升就越大。</p><h1 id="169a" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">我们如何在TiKV中减少抽象</h1><p id="091b" class="pw-post-body-paragraph iq ir hi is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hb bi translated"><a class="ae jo" href="https://tikv.org/" rel="noopener ugc nofollow" target="_blank"> TiKV </a>是一个分布式事务键值数据库。在TiDB Hackathon 2020上，我们试图通过将TiKV推到上面提到的步骤5来减少TiKV中的抽象，即直接向NVMe磁盘发送指令。这样，我们消除了几个抽象的开销。</p><h2 id="f31d" class="lh jq hi bd jr li lj lk jv ll lm ln jz jb lo lp kd jf lq lr kh jj ls lt kl lu bi translated">SPDK和BlobFS</h2><p id="253f" class="pw-post-body-paragraph iq ir hi is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hb bi translated">应该减少多少抽象层次是一个权衡的问题。由于NVMe的流行及其新特性(4 KB原子写入、低延迟和高并发队列)，我们认为为NVMe磁盘重新设计TiKV是值得的。</p><p id="a09f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">幸运的是，开源社区也这么认为。英特尔提供了<a class="ae jo" href="https://spdk.io/" rel="noopener ugc nofollow" target="_blank"> SPDK </a>、<strong class="is hj">一套用于编写高性能存储应用的开源工具包和库</strong>，其中包括针对NVMe的用户模式驱动程序和软件包。通过虚拟功能I/O (VFIO)等方法，用户模式驱动程序将硬件I/O映射到用户模式可访问的内存，以便应用程序可以访问硬件，而无需绕道操作系统。VFIO广泛应用于虚拟机中，允许虚拟机直接访问显卡或网卡。</p><p id="8297" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">除此之外，<strong class="is hj"> SPDK实现了一个名为BlobFS的文件系统，它提供了类似于</strong> <a class="ae jo" href="https://en.wikipedia.org/wiki/POSIX#:~:text=The%20Portable%20Operating%20System%20Interface,maintaining%20compatibility%20between%20operating%20systems." rel="noopener ugc nofollow" target="_blank"> <strong class="is hj"> POSIX </strong> </a> <strong class="is hj">文件系统</strong>的函数接口。使用BlobFS，应用程序分三步执行I/O操作:</p><ol class=""><li id="206a" class="ks kt hi is b it iu ix iy jb ku jf kv jj kw jn kx ky kz la bi translated">应用程序调用<code class="du lv lw lx ly b">blobfs_create</code>和<code class="du lv lw lx ly b">blobfs_read</code>等函数。</li><li id="4f40" class="ks kt hi is b it lb ix lc jb ld jf le jj lf jn kx ky kz la bi translated">文件系统操作被映射到存储设备操作。</li><li id="07be" class="ks kt hi is b it lb ix lc jb ld jf le jj lf jn kx ky kz la bi translated">BlobFS将指令发送到NVMe磁盘。(严格来说，指令是写入NVMe设备中相应的内存空间的。)</li></ol><p id="1e7b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">与Linux I/O进程相比，SPDK I/O进程更简单、更高效:</p><ul class=""><li id="f360" class="ks kt hi is b it iu ix iy jb ku jf kv jj kw jn lg ky kz la bi translated">函数调用的开销比系统调用低。</li><li id="1605" class="ks kt hi is b it lb ix lc jb ld jf le jj lf jn lg ky kz la bi translated">BlobFS使用NVMe的原子写特性，因此简化了文件系统元数据的管理。</li><li id="48ea" class="ks kt hi is b it lb ix lc jb ld jf le jj lf jn lg ky kz la bi translated">其优化的页面缓存策略适用于连续读写。对于RocksDB，优化对于LSM压缩非常重要，但不幸的是，它也消除了点查询的额外缓存。</li></ul><p id="6630" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这个解决方案解决了我们前面提到的四个问题:<strong class="is hj">它消除了syscall开销，使用了更适合数据库和NVMe磁盘的数据结构和缓存算法，简化了文件系统日志记录。</strong>如果我们将SPDK BlobFS集成到TiKV中，我们可以期待看到巨大的性能提升。</p><h2 id="7fb0" class="lh jq hi bd jr li lj lk jv ll lm ln jz jb lo lp kd jf lq lr kh jj ls lt kl lu bi translated">测量TiKV改进</h2><p id="8b23" class="pw-post-body-paragraph iq ir hi is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hb bi translated">为了对我们的实验进行基准测试，我们使用<a class="ae jo" href="https://github.com/brianfrankcooper/YCSB/wiki/Core-Workloads" rel="noopener ugc nofollow" target="_blank"> YCSB工作负载A </a>(更新重工作负载)来测试最终的I/O。如下图所示，结果超出了我们的预期。数据点上的标签指的是客户端线程的数量。显然，在相同的延迟下，总部位于SPDK的TiKV每秒处理的操作数(OPS)更高:</p><figure class="ma mb mc md fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lz"><img src="../Images/7aa6e9c18a4683837f3fe284c87b3c1d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*jGyy6epEfGHsB73a.png"/></div></div><figcaption class="me mf et er es mg mh bd b be z dx translated"><em class="mi"> YCSB工作负载A读取性能</em></figcaption></figure><figure class="ma mb mc md fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lz"><img src="../Images/b0e16338b5e05eb73e04fe4835b66131.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*yD-_b46zJYhDS0JT.png"/></div></div><figcaption class="me mf et er es mg mh bd b be z dx translated"><em class="mi"> YCSB工作负载A写性能</em></figcaption></figure><h1 id="5bdf" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">前进</h1><p id="25e7" class="pw-post-body-paragraph iq ir hi is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hb bi translated">这个黑客马拉松项目能走多远？答案看情况。随着NVMe磁盘越来越受欢迎，TiKV不断追求更高的性能，我们的项目一定会取得具体的成果。</p><p id="74dd" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">此外，随着完全托管的TiDB服务<a class="ae jo" href="https://pingcap.com/products/tidbcloud/" rel="noopener ugc nofollow" target="_blank"> TiDB Cloud </a>公开化，TiDB用户只需点击几下鼠标就可以启动一个集群。他们可以享受SPDK的好处，而无需忍受自行配置的痛苦。</p><p id="9ff0" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在业内，人们多年来一直在探索相关的话题:</p><ul class=""><li id="1578" class="ks kt hi is b it iu ix iy jb ku jf kv jj kw jn lg ky kz la bi translated">一些研究人员将软件进一步推向第6步——让软件完成NVMe控制器的任务，如开放通道SSD技术。有一篇<a class="ae jo" href="https://dl.acm.org/doi/10.1145/3126545" rel="noopener ugc nofollow" target="_blank">论文</a>关于LSM树中SST文件只读模式和SSD中块只读模式(先擦除后重写)的共性。这可以减少由意外擦除引起的性能降级。</li><li id="3ea3" class="ks kt hi is b it lb ix lc jb ld jf le jj lf jn lg ky kz la bi translated">还有一些项目研究如何在Linux块设备上读写。例如，Ceph的<a class="ae jo" href="https://github.com/ceph/ceph/blob/master/src/os/bluestore/BlueFS.cc" rel="noopener ugc nofollow" target="_blank"> BlueFS </a>具有比直接文件系统读写更高的性能，并显示出比SPDK更好的硬件兼容性和更低的风险。</li></ul><p id="d164" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这些方法各有各的前途。有一天，我们可能会看到它们中的一个或多个集成到TiKV中，创建一个具有更高存储性能的数据库。</p></div></div>    
</body>
</html>