<html>
<head>
<title>LeetCode — Merge Two Sorted Array</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">LeetCode —合并两个排序数组</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/leetcode-merge-two-sorted-array-efbb9790e022?source=collection_archive---------2-----------------------#2021-07-11">https://medium.com/nerd-for-tech/leetcode-merge-two-sorted-array-efbb9790e022?source=collection_archive---------2-----------------------#2021-07-11</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div class="er es if"><img src="../Images/b1b7be3fedac20e2bc8fbcad6da46f07.png" data-original-src="https://miro.medium.com/v2/resize:fit:840/format:webp/1*qPTrxUnJFlftDaZXeyGVrw.png"/></div></figure><h1 id="8706" class="im in hi bd io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj bi translated">问题陈述</h1><p id="2a61" class="pw-post-body-paragraph jk jl hi jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh hb bi translated">给你两个整数数组<strong class="jm hj"> nums1 </strong>和<strong class="jm hj"> nums2 </strong>，按<strong class="jm hj">非递减</strong>顺序排序，还有两个整数<strong class="jm hj"> m </strong>和<strong class="jm hj"> n </strong>，分别代表<strong class="jm hj"> nums1 </strong>和<strong class="jm hj"> nums2 </strong>中的元素个数。</p><p id="77ec" class="pw-post-body-paragraph jk jl hi jm b jn ki jp jq jr kj jt ju jv kk jx jy jz kl kb kc kd km kf kg kh hb bi translated"><strong class="jm hj">将</strong> <strong class="jm hj"> nums1 </strong>和<strong class="jm hj"> nums2 </strong>合并成一个按<strong class="jm hj">非降序</strong>排序的数组。</p><p id="fe28" class="pw-post-body-paragraph jk jl hi jm b jn ki jp jq jr kj jt ju jv kk jx jy jz kl kb kc kd km kf kg kh hb bi translated">最终排序后的数组不应由函数返回，而是存储在数组<strong class="jm hj"> nums1 </strong>中。为了适应这一点，<strong class="jm hj"> nums1 </strong>的长度为<strong class="jm hj"> m + n </strong>，其中第一个<strong class="jm hj"> m </strong>元素表示应该合并的元素，最后一个<strong class="jm hj"> n </strong>元素被设置为<strong class="jm hj"> 0 </strong>并且应该被忽略。<strong class="jm hj"> nums2 </strong>的长度为<strong class="jm hj"> n </strong>。</p><p id="cf85" class="pw-post-body-paragraph jk jl hi jm b jn ki jp jq jr kj jt ju jv kk jx jy jz kl kb kc kd km kf kg kh hb bi translated">问题陈述摘自:<a class="ae kn" href="https://leetcode.com/problems/merge-sorted-array" rel="noopener ugc nofollow" target="_blank">https://leetcode.com/problems/merge-sorted-array</a></p><p id="247e" class="pw-post-body-paragraph jk jl hi jm b jn ki jp jq jr kj jt ju jv kk jx jy jz kl kb kc kd km kf kg kh hb bi translated"><strong class="jm hj">例1: </strong></p><pre class="ko kp kq kr fd ks kt ku kv aw kw bi"><span id="f5cc" class="kx in hi kt b fi ky kz l la lb">Input: nums1 = [1, 2, 3, 0, 0, 0], m = 3, nums2 = [2, 5, 6], n = 3<br/>Output: [1, 2, 2, 3, 5, 6]<br/>Explanation: The arrays we are merging are [1, 2, 3] and [2, 5, 6].<br/>The result of the merge is [1, 2, 2, 3, 5, 6] with the underlined elements coming from nums1.</span></pre><p id="99b8" class="pw-post-body-paragraph jk jl hi jm b jn ki jp jq jr kj jt ju jv kk jx jy jz kl kb kc kd km kf kg kh hb bi translated"><strong class="jm hj">例二:</strong></p><pre class="ko kp kq kr fd ks kt ku kv aw kw bi"><span id="a182" class="kx in hi kt b fi ky kz l la lb">Input: nums1 = [1], m = 1, nums2 = [], n = 0<br/>Output: [1]<br/>Explanation: The arrays we are merging are [1] and [].<br/>The result of the merge is [1].</span></pre><p id="d4fd" class="pw-post-body-paragraph jk jl hi jm b jn ki jp jq jr kj jt ju jv kk jx jy jz kl kb kc kd km kf kg kh hb bi translated"><strong class="jm hj">例3: </strong></p><pre class="ko kp kq kr fd ks kt ku kv aw kw bi"><span id="ac3f" class="kx in hi kt b fi ky kz l la lb">Input: nums1 = [0], m = 0, nums2 = [1], n = 1<br/>Output: [1]<br/>Explanation: The arrays we are merging are [] and [1].<br/>The result of the merge is [1].<br/>Note that because m = 0, there are no elements in nums1.<br/>The 0 is only there to ensure the merge result can fit in nums1.</span></pre><p id="83d7" class="pw-post-body-paragraph jk jl hi jm b jn ki jp jq jr kj jt ju jv kk jx jy jz kl kb kc kd km kf kg kh hb bi translated"><strong class="jm hj">约束:</strong></p><pre class="ko kp kq kr fd ks kt ku kv aw kw bi"><span id="2c95" class="kx in hi kt b fi ky kz l la lb">- nums1.length == m + n<br/>- nums2.length == n<br/>- 0 &lt;= m, n &lt;= 200<br/>- 1 &lt;= m + n &lt;= 200<br/>- -10^9 &lt;= nums1[i], nums2[j] &lt;= 10^9</span></pre><h1 id="354d" class="im in hi bd io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj bi translated">说明</h1><p id="6187" class="pw-post-body-paragraph jk jl hi jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh hb bi translated">解决该问题的强力方法是创建一个新的数组nums3，并不断添加两个排序后的数组中的元素。将nums1和nums2中的所有元素添加到nums3后，我们将nums3复制回nums1。</p><p id="c1e4" class="pw-post-body-paragraph jk jl hi jm b jn ki jp jq jr kj jt ju jv kk jx jy jz kl kb kc kd km kf kg kh hb bi translated">但是上面的解决方案会额外占用<strong class="jm hj"> O(m + n) </strong>的空间。我们需要在没有任何额外空间的情况下对元素进行排序。</p><p id="22c9" class="pw-post-body-paragraph jk jl hi jm b jn ki jp jq jr kj jt ju jv kk jx jy jz kl kb kc kd km kf kg kh hb bi translated">想法是从右到左迭代两个数组，并从右继续向nums1添加元素。</p><p id="beae" class="pw-post-body-paragraph jk jl hi jm b jn ki jp jq jr kj jt ju jv kk jx jy jz kl kb kc kd km kf kg kh hb bi translated">让我们检查下面的算法:</p><pre class="ko kp kq kr fd ks kt ku kv aw kw bi"><span id="66bf" class="kx in hi kt b fi ky kz l la lb">- set i = m - 1, j = n - 1, k = m + n - 1<br/><br/>- loop for i &gt;= 0 &amp;&amp; j &gt;= 0<br/>  - if nums1[i] &gt; nums2[j]<br/>    - set nums1[k] = nums1[i--]<br/>  - else<br/>    - set nums1[k] = nums2[j--]<br/><br/>- loop while i &gt;= 0<br/>  - set nums1[k--] = nums1[i--]<br/><br/>- loop while j &gt;= 0<br/>  - set nums1[k--] = nums2[j--]</span></pre><p id="0a53" class="pw-post-body-paragraph jk jl hi jm b jn ki jp jq jr kj jt ju jv kk jx jy jz kl kb kc kd km kf kg kh hb bi translated"><strong class="jm hj"> C++解决方案</strong></p><pre class="ko kp kq kr fd ks kt ku kv aw kw bi"><span id="7a27" class="kx in hi kt b fi ky kz l la lb">class Solution {<br/>public:<br/>    void merge(vector&lt;int&gt;&amp; nums1, int m, vector&lt;int&gt;&amp; nums2, int n) {<br/>        int i = m - 1, j = n - 1, k = m + n - 1;<br/><br/>        for(; i &gt;=0 &amp;&amp; j &gt;=0; k--){<br/>            if(nums1[i] &gt;= nums2[j]){<br/>                nums1[k] = nums1[i--];<br/>            } else {<br/>                nums1[k] = nums2[j--];<br/>            }<br/>        }<br/><br/><br/>        while(i &gt;= 0) {<br/>            nums1[k--] = nums1[i--];<br/>        }<br/><br/>        while(j &gt;= 0) {<br/>            nums1[k--] = nums2[j--];<br/>        }<br/>    }<br/>};</span></pre><p id="5d88" class="pw-post-body-paragraph jk jl hi jm b jn ki jp jq jr kj jt ju jv kk jx jy jz kl kb kc kd km kf kg kh hb bi translated"><strong class="jm hj">戈朗溶液</strong></p><pre class="ko kp kq kr fd ks kt ku kv aw kw bi"><span id="b48a" class="kx in hi kt b fi ky kz l la lb">func merge(nums1 []int, m int, nums2 []int, n int)  {<br/>    i := m - 1<br/>    j := n - 1<br/>    k := m + n - 1<br/><br/>    for ; i &gt;= 0 &amp;&amp; j &gt;= 0; k-- {<br/>        if nums1[i] &gt;= nums2[j] {<br/>            nums1[k] = nums1[i]<br/>            i--<br/>        } else {<br/>            nums1[k] = nums2[j]<br/>            j--<br/>        }<br/>    }<br/><br/>    for i &gt;= 0 {<br/>        nums1[k] = nums1[i]<br/>        k--<br/>        i--<br/>    }<br/><br/>    for j &gt;= 0 {<br/>        nums1[k] = nums2[j]<br/>        k--<br/>        j--<br/>    }<br/>}</span></pre><p id="0b28" class="pw-post-body-paragraph jk jl hi jm b jn ki jp jq jr kj jt ju jv kk jx jy jz kl kb kc kd km kf kg kh hb bi translated"><strong class="jm hj"> Javascript解决方案</strong></p><pre class="ko kp kq kr fd ks kt ku kv aw kw bi"><span id="a03f" class="kx in hi kt b fi ky kz l la lb">var merge = function(nums1, m, nums2, n) {<br/>    let i, j, k;<br/><br/>    for(i = m - 1, j = n - 1, k = m + n - 1; i &gt;= 0 &amp;&amp; j &gt;= 0; k--){<br/>        if(nums1[i] &gt;= nums2[j]){<br/>            nums1[k] = nums1[i--];<br/>        } else {<br/>            nums1[k] = nums2[j--];<br/>        }<br/>    }<br/><br/>    while(i &gt;= 0) {<br/>        nums1[k--] = nums1[i--];<br/>    }<br/><br/>    while(j &gt;= 0) {<br/>        nums1[k--] = nums2[j--];<br/>    }<br/>};</span></pre><p id="3ce5" class="pw-post-body-paragraph jk jl hi jm b jn ki jp jq jr kj jt ju jv kk jx jy jz kl kb kc kd km kf kg kh hb bi translated">让我们试运行一下我们的算法，看看解决方案是如何工作的。</p><pre class="ko kp kq kr fd ks kt ku kv aw kw bi"><span id="e416" class="kx in hi kt b fi ky kz l la lb">Input:<br/>nums1 = [1, 2, 3, 0, 0, 0]<br/>m = 3<br/><br/>nums2 = [2, 5, 6]<br/>n = 3<br/><br/>Step 1: i = m - 1<br/>          = 3 - 1<br/>          = 2<br/><br/>        j = n - 1<br/>          = 3 - 1<br/>          = 2<br/><br/>        k = m + n - 1<br/>          = 3 + 3 - 1<br/>          = 5<br/><br/>Step 2: loop for i &gt;= 0 &amp;&amp; j &gt;= 0<br/>        2 &gt;= 0 &amp;&amp; 2 &gt;= 0<br/>        true<br/><br/>        if nums1[i] &gt;= nums2[j]<br/>        nums1[2] &gt;= nums2[2]<br/>        3 &gt; 6<br/>        false<br/><br/>        nums1[k] = nums2[j--]<br/>        nums1[5] = 3<br/><br/>        j--<br/>        j = 1<br/><br/>        k--<br/>        k = 4<br/><br/>        nums1 = [1, 2, 3, 0, 0, 6]<br/><br/>Step 3: loop for i &gt;= 0 &amp;&amp; j &gt;= 0<br/>        2 &gt;= 0 &amp;&amp; 1 &gt;= 0<br/>        true<br/><br/>        if nums1[i] &gt;= nums2[j]<br/>        nums1[2] &gt;= nums2[1]<br/>        3 &gt; 5<br/>        false<br/><br/>        nums1[k] = nums2[j--]<br/>        nums1[4] = 6<br/><br/>        j--<br/>        j = 0<br/><br/>        k--<br/>        k = 3<br/><br/>        nums1 = [1, 2, 3, 0, 5, 6]<br/><br/>Step 4: loop for i &gt;= 0 &amp;&amp; j &gt;= 0<br/>        2 &gt;= 0 &amp;&amp; 0 &gt;= 0<br/>        true<br/><br/>        if nums1[i] &gt;= nums2[j]<br/>        nums1[2] &gt;= nums2[0]<br/>        3 &gt; 2<br/>        true<br/><br/>        nums1[k] = nums1[i--]<br/>        nums1[3] = 3<br/><br/>        i--<br/>        i = 1<br/><br/>        k--<br/>        k = 2<br/><br/>        nums1 = [1, 2, 3, 3, 5, 6]<br/><br/>Step 5: loop for i &gt;= 0 &amp;&amp; j &gt;= 0<br/>        1 &gt;= 0 &amp;&amp; 0 &gt;= 0<br/>        true<br/><br/>        if nums1[i] &gt;= nums2[j]<br/>        nums1[1] &gt;= nums2[0]<br/>        2 &gt;= 2<br/>        true<br/><br/>        nums1[k] = nums1[i--]<br/>        nums1[2] = 2<br/><br/>        i--<br/>        i = 0<br/><br/>        k--<br/>        k = 1<br/><br/>        nums1 = [1, 2, 2, 3, 5, 6]<br/><br/>Step 6: loop for i &gt;= 0 &amp;&amp; j &gt;= 0<br/>        0 &gt;= 0 &amp;&amp; 0 &gt;= 0<br/>        true<br/><br/>        if nums1[i] &gt;= nums2[j]<br/>        nums1[0] &gt;= nums2[0]<br/>        1 &gt;= 2<br/>        false<br/><br/>        nums1[k] = nums2[j--]<br/>        nums1[1] = 2<br/><br/>        j--<br/>        j= -1<br/><br/>        k--<br/>        k = 0<br/><br/>        nums1 = [1, 2, 2, 3, 5, 6]<br/><br/>Step 7: loop for i &gt;= 0 &amp;&amp; j &gt;= 0<br/>        0 &gt;= 0 &amp;&amp; -1 &gt;= 0<br/>        false<br/><br/>Step 8: for i &gt;= 0<br/>        0 &gt;= 0<br/>        true<br/><br/>        nums1[k--] = nums1[i--]<br/>        nums1[0] = nums1[0]<br/>        nums1[0] = 1<br/><br/>        k--<br/>        k = -1<br/><br/>        i--<br/>        i = -1<br/><br/>Step 9: for j &gt;= 0<br/>        -1 &gt;= 0<br/>        false<br/><br/>So the answer is [1, 2, 2, 3, 5, 6].</span></pre></div><div class="ab cl lc ld gp le" role="separator"><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh"/></div><div class="hb hc hd he hf"><p id="6072" class="pw-post-body-paragraph jk jl hi jm b jn ki jp jq jr kj jt ju jv kk jx jy jz kl kb kc kd km kf kg kh hb bi translated"><em class="lj">原发表于</em><a class="ae kn" href="https://alkeshghorpade.me/post/leetcode-merge-sorted-array" rel="noopener ugc nofollow" target="_blank"><em class="lj">https://alkeshghorpade . me</em></a><em class="lj">。</em></p></div></div>    
</body>
</html>