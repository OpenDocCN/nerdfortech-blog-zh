<html>
<head>
<title>WHAT IS TOMBSTONE DIAGRAM ?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">什么是墓碑图？</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/what-is-tombstone-diagram-153fae04f613?source=collection_archive---------6-----------------------#2021-07-11">https://medium.com/nerd-for-tech/what-is-tombstone-diagram-153fae04f613?source=collection_archive---------6-----------------------#2021-07-11</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div class="er es if"><img src="../Images/eaada6dda8d67083500aa3fda63defce.png" data-original-src="https://miro.medium.com/v2/resize:fit:1144/format:webp/1*sv5aH5vW0McLtpSsfKNClA.png"/></div><figcaption class="im in et er es io ip bd b be z dx translated"><strong class="bd iq">什么是墓碑图？🤔</strong></figcaption></figure><p id="22c6" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi jp translated"><span class="l jq jr js bm jt ju jv jw jx di"> T </span> <strong class="it hj"> ombstone 图</strong> (T 图)基本上是用来表示编译器和语言处理程序的片段，就像一些拼图。他们演示了在一个<a class="ae jy" href="https://en.wikipedia.org/wiki/Implementation_language" rel="noopener ugc nofollow" target="_blank"> <strong class="it hj">实现语言</strong> </a> (L)中实现的<a class="ae jy" href="https://en.wikipedia.org/wiki/Source_code" rel="noopener ugc nofollow" target="_blank"> <strong class="it hj">源语言</strong> </a> (S)到<a class="ae jy" href="https://en.wikipedia.org/wiki/Target_language_(computing)" rel="noopener ugc nofollow" target="_blank"> <strong class="it hj">目标语言</strong> </a> (T)的转换。</p><figure class="ka kb kc kd fd ij er es paragraph-image"><div class="er es jz"><img src="../Images/e495326a12dd5cb4b516223328cace7d.png" data-original-src="https://miro.medium.com/v2/resize:fit:642/format:webp/0*V4gWihs_iwnJDab0.png"/></div><figcaption class="im in et er es io ip bd b be z dx translated"><strong class="bd iq">通过实现语言(L)将源语言(S)转换为目标语言(T)</strong></figcaption></figure><p id="6fdb" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">它基本上说明了编译器和解释器如何相互合作来开发和执行软件。描述了解释器、编译器和宏处理器的<a class="ae jy" href="https://en.wikipedia.org/wiki/Porting" rel="noopener ugc nofollow" target="_blank"> <strong class="it hj">移植</strong></a><a class="ae jy" href="https://en.wikipedia.org/wiki/Bootstrapping_(compilers" rel="noopener ugc nofollow" target="_blank"><strong class="it hj">自举</strong> </a>和<a class="ae jy" href="https://en.wikipedia.org/wiki/Self-hosting_(compilers" rel="noopener ugc nofollow" target="_blank"> <strong class="it hj">自编译</strong> </a>的复杂功能。块的<strong class="it hj">基</strong>总是包含实现语言。</p><h1 id="aa9d" class="ke kf hi bd iq kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">背景</h1><p id="c9b2" class="pw-post-body-paragraph ir is hi it b iu lb iw ix iy lc ja jb jc ld je jf jg le ji jj jk lf jm jn jo hb bi translated">T-Diagram 的蓝图最初是由<strong class="it hj"> McKeeman 等人</strong>在 1971 年提出的，用于启发引导和交叉编译编译器。就其最初的方面而言，梅尔文·康威在 1958 年以他的<a class="ae jy" href="https://en.wikipedia.org/wiki/UNCOL" rel="noopener ugc nofollow" target="_blank"><strong class="it hj"/></a>展示了一个更广泛的布局。后来，<strong class="it hj">布拉特曼</strong>和<strong class="it hj"> P.D .特里</strong>通过教科书将其概念扩展到编译器设计过程。</p><p id="37be" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">UNCOL(通用计算机导向语言)被设计成让编译器经济地适用于每一种新的<a class="ae jy" href="https://en.wikipedia.org/wiki/Instruction_set" rel="noopener ugc nofollow" target="_blank"> <strong class="it hj">机器架构</strong> </a>和编程语言。每种机器架构只需要一个编译器后端，每种编程语言只需要一个编译器前端。它从未被完全实现，所以最终由于组件的不成熟原则而成为一个失败。由于其<a class="ae jy" href="https://en.wikipedia.org/wiki/Architecture_Neutral_Distribution_Format" rel="noopener ugc nofollow" target="_blank"> <strong class="it hj">架构中性分发格式</strong> </a>，有时会引用<a class="ae jy" href="https://en.wikipedia.org/wiki/Java_bytecode" rel="noopener ugc nofollow" target="_blank"> <strong class="it hj"> Java 字节码</strong> </a>。</p><figure class="ka kb kc kd fd ij er es paragraph-image"><div class="er es lg"><img src="../Images/222ca08899c3f4501c81ca2c826f71e6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1320/format:webp/0*81DWQkHyTfdw2TGy.png"/></div><figcaption class="im in et er es io ip bd b be z dx translated"><strong class="bd iq">uncoll 编译过程</strong></figcaption></figure><p id="d8ea" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">它是 T 图的前身，其中一个<strong class="it hj">uncoll-to-704</strong>编译器(左上)正在<strong class="it hj"> IBM 704 机器上执行</strong>(中)用于编译在<strong class="it hj">uncoll</strong>(左下)中实现的<strong class="it hj">OTN-uncoll</strong>编译器，在一个在<strong class="it hj"> 704 机器代码</strong>(右)中实现的 OTN-uncoll<strong class="it hj"/>编译器中提供结果。这是最初采用的汇编，后来由布拉特曼在 1961 年即兴创作。</p><figure class="ka kb kc kd fd ij er es paragraph-image"><div class="er es lh"><img src="../Images/cca69eae7be84f57bb09d4953173fab9.png" data-original-src="https://miro.medium.com/v2/resize:fit:962/format:webp/0*RBS1K9VyxMQZhlFp.png"/></div><figcaption class="im in et er es io ip bd b be z dx translated"><strong class="bd iq">布拉特曼提出的 T 形图</strong></figcaption></figure><h1 id="9542" class="ke kf hi bd iq kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">问题</h1><p id="0588" class="pw-post-body-paragraph ir is hi it b iu lb iw ix iy lc ja jb jc ld je jf jg le ji jj jk lf jm jn jo hb bi translated">布拉特曼的提议似乎又有一些重大缺陷。由左 T 形件和中间 T 形件组合而成的右 T 形件看起来并不像它应该的那样。接口和对称问题影响了他的模型的效率。</p><h1 id="580b" class="ke kf hi bd iq kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">不同的方法</h1><p id="566f" class="pw-post-body-paragraph ir is hi it b iu lb iw ix iy lc ja jb jc ld je jf jg le ji jj jk lf jm jn jo hb bi translated">后来又提出了其他几种图解系统。<a class="ae jy" href="https://dl.acm.org/doi/10.1145/1463891.1463893" rel="noopener ugc nofollow" target="_blank"><strong class="it hj"/></a>用<strong class="it hj"> X 形件</strong>替换了<strong class="it hj">布拉特曼的 T 形件</strong>。<a class="ae jy" href="https://dl.acm.org/doi/abs/10.1145/321450.321451" rel="noopener ugc nofollow" target="_blank"> <strong class="it hj">斯克兰斯基等人</strong> </a> <strong class="it hj"> </strong>提出<strong class="it hj"> D 形件</strong>。<a class="ae jy" href="https://onlinelibrary.wiley.com/doi/abs/10.1002/spe.4380070214" rel="noopener ugc nofollow" target="_blank"> <strong class="it hj">松香</strong> </a>建议用<strong class="it hj">各种形状的棋子</strong>和<a class="ae jy" href="https://dl.acm.org/doi/10.1145/355598.362740" rel="noopener ugc nofollow" target="_blank"> <strong class="it hj">厄尔利&amp;斯特吉斯</strong> </a>用体现<strong class="it hj">解释者</strong>的<strong class="it hj">工字棋子</strong>交换布拉特曼的丁字棋子。但是他们从未有效地解决上述问题。</p><h2 id="6e50" class="li kf hi bd iq lj lk ll kj lm ln lo kn jc lp lq kr jg lr ls kv jk lt lu kz lv bi translated">1) X 形</h2><figure class="ka kb kc kd fd ij er es paragraph-image"><div class="er es lw"><img src="../Images/07635eed9100f357ae70edbe85680a6c.png" data-original-src="https://miro.medium.com/v2/resize:fit:276/format:webp/0*YL5ycpG2orr9S0NG.png"/></div><figcaption class="im in et er es io ip bd b be z dx translated"><strong class="bd iq">布哈特提出的 X 形件</strong></figcaption></figure><p id="42e6" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">布哈特提出了这种接受语言<strong class="it hj"> N </strong>的程序输入的编译器的框图，即在<strong class="it hj"> IBM 709 机器码</strong>中执行，以开发<strong class="it hj">【SPS】</strong>语言的程序。</p><h2 id="a6fb" class="li kf hi bd iq lj lk ll kj lm ln lo kn jc lp lq kr jg lr ls kv jk lt lu kz lv bi translated">2) D 形</h2><figure class="ka kb kc kd fd ij er es paragraph-image"><div class="er es lx"><img src="../Images/e60cb7864e5207141358cbe51bc11ed9.png" data-original-src="https://miro.medium.com/v2/resize:fit:982/format:webp/0*Ow3N10BGDlKiiCMM.png"/></div><figcaption class="im in et er es io ip bd b be z dx translated"><strong class="bd iq">斯克兰斯基等人提出的 D 形件</strong></figcaption></figure><p id="fa55" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">在<em class="ly">步骤 1 </em>中，它定义了一个用语言<strong class="it hj"> L (q/L) </strong>编写的算法<strong class="it hj"> q </strong>，由机器<strong class="it hj"> M </strong>上<strong class="it hj"> M (L/MM) </strong>中处理的<strong class="it hj"> L-to-M 编译器</strong>编译，产生一个 M (q/MM) 中<strong class="it hj"> q 的实现。在<em class="ly">步骤 2 </em>中，该实现是在具有<strong class="it hj">数据δ </strong>的机器 M 上进行的，以产生结果<strong class="it hj"> q(δ) </strong>。</strong></p><h2 id="5f24" class="li kf hi bd iq lj lk ll kj lm ln lo kn jc lp lq kr jg lr ls kv jk lt lu kz lv bi translated">3)多形态</h2><figure class="ka kb kc kd fd ij er es paragraph-image"><div class="er es lz"><img src="../Images/5cf52cddc0c479bc4c25f971e3feab46.png" data-original-src="https://miro.medium.com/v2/resize:fit:1202/format:webp/0*nA8-M2Ba1MXlhss_.png"/></div><figcaption class="im in et er es io ip bd b be z dx translated"><strong class="bd iq">Rosin 提出的图</strong></figcaption></figure><p id="d956" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">输入数据用<strong class="it hj"> PI 语言</strong>编写，由用<strong class="it hj"> IBM 360 机器码</strong>开发的编译器整理成<strong class="it hj"> PO </strong>语言。它在一个在 IBM 2065 机器上运行的<strong class="it hj"> 2065 机器代码</strong>中实现的<strong class="it hj"> 360 机器代码</strong>的解释器中运行。</p><h2 id="2952" class="li kf hi bd iq lj lk ll kj lm ln lo kn jc lp lq kr jg lr ls kv jk lt lu kz lv bi translated">4)工字形</h2><figure class="ka kb kc kd fd ij er es paragraph-image"><div class="er es ma"><img src="../Images/13b945d91fa8379152f2894a7320b507.png" data-original-src="https://miro.medium.com/v2/resize:fit:562/format:webp/0*uI9hUfVs6Z4Ze6-0.png"/></div><figcaption class="im in et er es io ip bd b be z dx translated"><strong class="bd iq">厄尔利-斯特吉斯提出的工字形件</strong></figcaption></figure><p id="7d3d" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">用<strong class="it hj"> Lisp </strong>编写<strong class="it hj"> f 函数</strong>，然后由用<strong class="it hj"> Lisp </strong>编写的编译器翻译成机器语言<strong class="it hj"> (ML) </strong>。该编译器在用机器语言编写的 Lisp 解释器中执行。虚线表明<strong class="it hj">右边的部分</strong>是合成的结果。</p><h1 id="a3c3" class="ke kf hi bd iq kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">方面</h1><p id="4190" class="pw-post-body-paragraph ir is hi it b iu lb iw ix iy lc ja jb jc ld je jf jg le ji jj jk lf jm jn jo hb bi translated">墓碑图有一个独特的组合规则。</p><figure class="ka kb kc kd fd ij er es paragraph-image"><div class="er es mb"><img src="../Images/ff1fcfdd67c4ad940d43b59cd5c60150.png" data-original-src="https://miro.medium.com/v2/resize:fit:362/format:webp/0*opXobLH_CN10yYq3.png"/></div><figcaption class="im in et er es io ip bd b be z dx translated"><strong class="bd iq"> M-M 右组合</strong></figcaption></figure><figure class="ka kb kc kd fd ij er es paragraph-image"><div class="er es mb"><img src="../Images/72b85f8116d705731b26d6a0374e9462.png" data-original-src="https://miro.medium.com/v2/resize:fit:362/format:webp/0*q6L_HMgibvBLOyNw.png"/></div><figcaption class="im in et er es io ip bd b be z dx translated"><strong class="bd iq"> L-M 错误组合</strong></figcaption></figure><figure class="ka kb kc kd fd ij er es paragraph-image"><div class="er es mc"><img src="../Images/0fa9de1236b98a96e6e5cec5f7c53779.png" data-original-src="https://miro.medium.com/v2/resize:fit:644/format:webp/0*kFO_hnOzopsLvDX0.png"/></div><figcaption class="im in et er es io ip bd b be z dx translated"><strong class="bd iq"> S-S，M-M，T-T 右组合</strong></figcaption></figure><figure class="ka kb kc kd fd ij er es paragraph-image"><div class="er es md"><img src="../Images/5dd0ad06709ec147bdb5b1b70e193714.png" data-original-src="https://miro.medium.com/v2/resize:fit:414/format:webp/0*_NZ7pibfnzPfZ9G2.png"/></div><figcaption class="im in et er es io ip bd b be z dx translated"><strong class="bd iq"> L-S 错误组合</strong></figcaption></figure><p id="bcdf" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">这个<strong class="it hj">组合学</strong>决定棋子的<strong class="it hj">组成，并调节<strong class="it hj">最终输出</strong>。有<strong class="it hj"> 2 </strong>种组合:- (1) <strong class="it hj">水平组合</strong>，其中第一编译器的输出被提供给第二编译器，而(2) <strong class="it hj">对角组合</strong>包括第二编译器对第一编译器本身的编译。</strong></p><h1 id="3bf0" class="ke kf hi bd iq kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">例子</h1><h2 id="d246" class="li kf hi bd iq lj lk ll kj lm ln lo kn jc lp lq kr jg lr ls kv jk lt lu kz lv bi translated">1) C 程序在 x86 机器上编译</h2><figure class="ka kb kc kd fd ij er es paragraph-image"><div class="er es me"><img src="../Images/ff5ce3540ca4a0d0e5c607f8c84ca71a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1122/format:webp/0*fDPP608L3082Y_QI.png"/></div><figcaption class="im in et er es io ip bd b be z dx translated"><strong class="bd iq">x86 机器上 C 程序的编译</strong></figcaption></figure><h2 id="c518" class="li kf hi bd iq lj lk ll kj lm ln lo kn jc lp lq kr jg lr ls kv jk lt lu kz lv bi translated">2) C 交叉编译器编译主机-&gt; x86 到目标-&gt; PPC</h2><figure class="ka kb kc kd fd ij er es paragraph-image"><div class="er es me"><img src="../Images/1328048ca9f86b389d4d75703bdc244b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1122/format:webp/0*VpBbfdrRb9aLPxdU.png"/></div><figcaption class="im in et er es io ip bd b be z dx translated"><strong class="bd iq">C 交叉编译器中的主机- &gt; x86 和目标-&gt;PPC</strong></figcaption></figure><h2 id="6818" class="li kf hi bd iq lj lk ll kj lm ln lo kn jc lp lq kr jg lr ls kv jk lt lu kz lv bi translated">3)两阶段编译过程由两个翻译器组成，其中第一个翻译器的输出作为输入提供给第二个翻译器</h2><figure class="ka kb kc kd fd ij er es paragraph-image"><div class="er es mf"><img src="../Images/2812c956284463c47bfe1caa1a08f642.png" data-original-src="https://miro.medium.com/v2/resize:fit:1042/format:webp/0*_Xh2px4WkcLcp71Y.png"/></div><figcaption class="im in et er es io ip bd b be z dx translated"><strong class="bd iq">两阶段翻译过程</strong></figcaption></figure><h1 id="2a3f" class="ke kf hi bd iq kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">应用</h1><p id="19f4" class="pw-post-body-paragraph ir is hi it b iu lb iw ix iy lc ja jb jc ld je jf jg le ji jj jk lf jm jn jo hb bi translated">(1)墓碑图现在被用来理解<strong class="it hj">客户机-服务器互连性</strong>在<a class="ae jy" href="https://en.wikipedia.org/wiki/World_Wide_Web" rel="noopener ugc nofollow" target="_blank"> <strong class="it hj">万维网</strong> </a>上。T 图的概念特征已经在许多领域得到应用。</p><p id="8fec" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">(2)德国 Leizpig 大学开发了一种教学工具<a class="ae jy" href="http://www.michael-hielscher.de/atocc/Tut_TDiag1.pdf" rel="noopener ugc nofollow" target="_blank"> <strong class="it hj"> TDiag </strong> </a>来说明墓碑图的理论和实践方面。</p><figure class="ka kb kc kd fd ij er es paragraph-image"><div class="er es mg"><img src="../Images/73a3687b26e5f8eb9cb02f99845432f9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1150/format:webp/1*9VMp8mJDqwfiVc2h3fkEtA.png"/></div><figcaption class="im in et er es io ip bd b be z dx translated"><strong class="bd iq"> TDiag 接口</strong></figcaption></figure><p id="133a" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated"><strong class="it hj">资源和数据归维基百科及其各自所有者所有。</strong></p><p id="8fb6" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">保持安全，尽情享受。</p><p id="d6b9" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated"><strong class="it hj">快乐阅读😉</strong></p></div></div>    
</body>
</html>