<html>
<head>
<title>What’s Wrong With the OAuth2 Implicit Grant?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">OAuth2隐式授予有什么问题？</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/whats-wrong-with-the-oauth2-implicit-grant-6e9de71f2bca?source=collection_archive---------8-----------------------#2021-08-13">https://medium.com/nerd-for-tech/whats-wrong-with-the-oauth2-implicit-grant-6e9de71f2bca?source=collection_archive---------8-----------------------#2021-08-13</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/6c1b372395f85078c00e933b6b00da1c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*spvlnPpAwu1AnivkbydPjA.png"/></div></div></figure><p id="2c6a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">隐式授权是OAuth 2 RFC的一部分，但<a class="ae jo" href="https://fusionauth.io/learn/expert-advice/oauth/differences-between-oauth-2-oauth-2-1/" rel="noopener ugc nofollow" target="_blank">是OAuth 2.1规范</a>中省略的特性之一。有了这笔拨款，你就不用写服务器端代码了。您不必用授权码来交换访问令牌，而是在重定向时获得一个访问令牌。</p><p id="c583" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如果您在JAMstack中工作，或者在其他不想运行服务器的情况下，这是很方便的。</p><p id="6c0c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">然而，它非常不安全、不可靠、被弃用，并且永远不应该使用。好吧，也许这有点夸张，但请不要用这笔拨款。OAuth 2.1草案的支持者同意这一点，这也是为什么他们在新规范中没有提到它。</p><blockquote class="jp jq jr"><p id="de3a" class="iq ir js is b it iu iv iw ix iy iz ja jt jc jd je ju jg jh ji jv jk jl jm jn hb bi translated"><em class="hi">根据OAuth 2.0安全最佳实践的第2.1.2节，本规范中省略了隐式授权(“response_type=token”)</em></p></blockquote><h1 id="429c" class="jw jx hi bd jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt bi translated">逃跑</h1><p id="27bd" class="pw-post-body-paragraph iq ir hi is b it ku iv iw ix kv iz ja jb kw jd je jf kx jh ji jj ky jl jm jn hb bi translated">与其告诉你如何使用这笔赠款，不如让我们讨论一下为什么你应该避免它。</p><figure class="la lb lc ld fd ij er es paragraph-image"><div class="er es kz"><img src="../Images/f3381fd6eacb48c342cf4dda6a350551.png" data-original-src="https://miro.medium.com/v2/resize:fit:800/format:webp/0*piqC5CwEB4mSgdj8.jpg"/></div></figure><p id="785e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">之所以删除它，是因为它跳过了一个重要的步骤，这个步骤允许您保护从OAuth服务器收到的令牌。当您的应用程序后端调用令牌端点来检索令牌时，就会发生这一步。</p><p id="0f27" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">与<a class="ae jo" href="https://fusionauth.io/docs/v1/tech/oauth/#example-authorization-code-grant" rel="noopener ugc nofollow" target="_blank">授权码授权</a>不同，隐式授权不会使用授权码将浏览器重定向回您的应用程序后端。相反，它将访问令牌作为重定向的一部分直接放在URL上。这些URL看起来像这样:</p><p id="b3db" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><code class="du le lf lg lh b"><a class="ae jo" href="https://piedpiper.com/#token-goes-here" rel="noopener ugc nofollow" target="_blank">https://piedpiper.com/#token-goes-here</a></code></p><p id="3d37" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">令牌被添加到重定向URL中的<code class="du le lf lg lh b">#</code>符号之后。这将它放在URL的片段部分。这意味着无论OAuth服务器将浏览器重定向到哪里，浏览器中运行的任何代码都可以访问访问令牌。换句话说，基本上对每个人。</p><p id="8902" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">更准确地说，浏览器中运行的任何和所有JavaScript都可以访问访问令牌(包括第三方库)。由于该令牌允许浏览器代表用户进行API调用和web请求，因此让第三方代码可以访问该令牌是极其危险的。</p><p id="6334" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">让我们举一个使用隐式授权的单页面web应用程序的虚拟例子:</p><p id="8d1e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这个HTML包括两个JavaScript库:</p><ul class=""><li id="63ea" class="li lj hi is b it iu ix iy jb lk jf ll jj lm jn ln lo lp lq bi translated">应用程序本身的代码(<code class="du le lf lg lh b">my-spa-code-1.0.0.js</code>)。</li><li id="3c87" class="li lj hi is b it lr ix ls jb lt jf lu jj lv jn ln lo lp lq bi translated">我们在网上找到了一个库，它做了一些很酷的事情，我们只是把它拉了进来。</li></ul><p id="fd6e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">让我们假设我们的代码是100%安全的，我们不必担心它。然而，我们拉进的库是一个未知数。</p><p id="22bc" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">该库也可能包括其他库。记住，DOM是动态的。任何JavaScript都可以简单地通过用<code class="du le lf lg lh b">&lt;script&gt;</code>标签更新DOM来加载任何其他JavaScript库。因此，我们很难确保第三方库中的每一行代码都是安全的。</p><p id="6c9c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">毕竟，<strong class="is hj">每次部署应用程序时，你会审计每个JavaScript库和每个库的每个依赖项吗？</strong></p><p id="5273" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如果一个第三方库想要从我们的虚拟应用程序中窃取一个访问令牌，它需要做的就是运行下面的代码:</p><p id="ef39" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">三行代码和访问令牌被盗。如您所见，泄漏令牌的风险太高，以至于无法考虑使用隐式授权。这就是为什么我们建议任何人都不要使用这笔赠款。</p><h1 id="5d06" class="jw jx hi bd jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt bi translated">如何在SPA中正确使用OAuth</h1><p id="c507" class="pw-post-body-paragraph iq ir hi is b it ku iv iw ix kv iz ja jb kw jd je jf kx jh ji jj ky jl jm jn hb bi translated">那么，如果你正在构建一个很棒的React、Angular、Vue或其他单页应用程序，你应该用什么来代替隐式授权呢？</p><p id="2dc6" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">使用授权码授权！它是安全的、可靠的、经过良好测试的、标准化的，并且将令牌排除在URL之外。</p><p id="2c9a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">除了使用该拨款，请采取以下步骤来保护您的SPA OAuth流程:</p><ul class=""><li id="f142" class="li lj hi is b it iu ix iy jb lk jf ll jj lm jn ln lo lp lq bi translated">在您的SPA中使用<a class="ae jo" href="https://tools.ietf.org/html/rfc7636" rel="noopener ugc nofollow" target="_blank"> PKCE </a>来确保您的应用程序不会受到授权代码拦截攻击，因为它不能维护安全的客户端秘密。</li><li id="8770" class="li lj hi is b it lr ix ls jb lt jf lu jj lv jn ln lo lp lq bi translated">运行服务器。不必复杂。事实上，用几行节点的授权码交换一个访问令牌可能很简单。下面是一个节点应用的例子。这也称为BFF，即前端模式的后端。</li><li id="3177" class="li lj hi is b it lr ix ls jb lt jf lu jj lv jn ln lo lp lq bi translated">将访问令牌存储在浏览器中JavaScript无法触及的地方。您可以将它们存储在服务器端会话中，或者存储在<code class="du le lf lg lh b">secure</code>、<code class="du le lf lg lh b">HttpOnly</code>cookie中。</li></ul><p id="f158" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">想了解更多关于不同OAuth授权的信息吗？查看OAuth现代指南，深入了解所有不同的OAuth授权，以及如何在现实世界中使用它们。</p><p id="5dba" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">编码快乐！</p></div><div class="ab cl lw lx gp ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="hb hc hd he hf"><p id="c770" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><em class="js">最初发布于</em><a class="ae jo" href="https://fusionauth.io/blog/2021/04/29/whats-wrong-with-implicit-grant/" rel="noopener ugc nofollow" target="_blank"><em class="js">https://fusion auth . io</em></a><em class="js">。</em></p></div></div>    
</body>
</html>