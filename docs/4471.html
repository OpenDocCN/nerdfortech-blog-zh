<html>
<head>
<title>Creating a retro-style Game Over screen in Unity and C#</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用 Unity 和 C#创建一个复古风格的游戏</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/creating-a-retro-style-game-over-screen-in-unity-and-c-7ab5069c413f?source=collection_archive---------8-----------------------#2021-07-22">https://medium.com/nerd-for-tech/creating-a-retro-style-game-over-screen-in-unity-and-c-7ab5069c413f?source=collection_archive---------8-----------------------#2021-07-22</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/1fb7f79e5ce6fa38daa95bd78b087f6d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*U-2tPVYo1MVrQ5bKGpizjg.gif"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">游戏结束了兄弟！</figcaption></figure><p id="408c" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">任何游戏的一个主要挑战是尽可能地进步——是什么让这成为一个挑战？当然是有机会<em class="js">而不是</em>更进一步…</p><p id="795b" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">介绍一款游戏主打产品——屏幕游戏！继我上一篇关于 UI 构建的文章之后，我们需要能够在玩家失败并失去所有生命时通知他们。</p><figure class="jv jw jx jy fd ij er es paragraph-image"><div class="er es ju"><img src="../Images/e1cc66da322115967d732b0bf455e51c.png" data-original-src="https://miro.medium.com/v2/resize:fit:924/format:webp/1*Tosa9fq6FvPsjidSpm1YvQ.png"/></div></figure><p id="ffe5" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">和以前一样，我将为此使用 TextMeshPro 组件(虽然，使用正确的名称空间库，编码解决方案也可以和普通的文本组件一样工作)。</p><p id="d392" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">在游戏对象激活而 TMP 组件不激活的情况下，我们可以在对玩家隐藏游戏结束消息的情况下开始游戏。</p><p id="4b56" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">这意味着，很明显，当玩家到达游戏极限时，我们需要激活这个消息——也就是说，已经没有生命了。</p></div><div class="ab cl jz ka gp kb" role="separator"><span class="kc bw bk kd ke kf"/><span class="kc bw bk kd ke kf"/><span class="kc bw bk kd ke"/></div><div class="hb hc hd he hf"><figure class="jv jw jx jy fd ij er es paragraph-image"><div class="er es kg"><img src="../Images/f9c7130e7904dbb09a8c79f97b54e46f.png" data-original-src="https://miro.medium.com/v2/resize:fit:736/format:webp/1*cBOEAgZBq0gkOJkKNODgcA.png"/></div></figure><figure class="jv jw jx jy fd ij er es paragraph-image"><div class="er es kh"><img src="../Images/1c9fe382a38d37be9bc4c4e153883354.png" data-original-src="https://miro.medium.com/v2/resize:fit:774/format:webp/1*Lj8ewdo_TnY_ssIxsuVgZA.png"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">启用游戏结束消息</figcaption></figure><figure class="jv jw jx jy fd ij er es paragraph-image"><div class="er es ki"><img src="../Images/600ecbf09ade519c73116c6aac021476.png" data-original-src="https://miro.medium.com/v2/resize:fit:742/format:webp/1*ctY1Mgeak0WCndN_PW5Xrw.png"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">检查玩家脚本中的生命</figcaption></figure><p id="61c0" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">非常简单，在我们的 UIManager 中，我们可以获取对文本组件上的游戏的引用，并使它能够在被调用时显示给玩家。</p><p id="0011" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">在检查我们的玩家是否还有生命后添加这个调用，将会在适当的时候显示游戏结束的消息。</p></div><div class="ab cl jz ka gp kb" role="separator"><span class="kc bw bk kd ke kf"/><span class="kc bw bk kd ke kf"/><span class="kc bw bk kd ke"/></div><div class="hb hc hd he hf"><p id="1c93" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">不过，仅仅升级一个游戏似乎有点无聊，所以让我们把它修饰一下。</p><p id="4107" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><em class="js">注意:这个屏幕看起来怎么样完全取决于你自己的想象力和创造力。下面将演示用于创建本文顶部示例的方法。</em></p><figure class="jv jw jx jy fd ij er es paragraph-image"><div class="er es kj"><img src="../Images/e14fff1667e76446cde02715c044b3f5.png" data-original-src="https://miro.medium.com/v2/resize:fit:780/format:webp/1*B759y_JmXu859IxBoC0-_g.png"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">声明必需的变量</figcaption></figure><p id="7233" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">首先，我们的变量——当你试图让你的游戏达到期望的效果时，会有很多实验。在 inspector 中赋予变量可以让我们在微调效果的时候快速地重复效果，而不必回到我们的代码。</p><figure class="jv jw jx jy fd ij er es paragraph-image"><div class="er es kk"><img src="../Images/17b89e2dcd6a8ca1f13f2b61dd60bd73.png" data-original-src="https://miro.medium.com/v2/resize:fit:928/format:webp/1*AkJgKtJ6GXPAevh_BuZ87A.png"/></div></figure><p id="c2da" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">我们的 DisplayGameOver 方法中还添加了几行代码—</p><blockquote class="kl km kn"><p id="c722" class="iu iv js iw b ix iy iz ja jb jc jd je ko jg jh ji kp jk jl jm kq jo jp jq jr hb bi translated"><code class="du kr ks kt ku b">string msg = _gameOverText.text;</code></p><p id="4df5" class="iu iv js iw b ix iy iz ja jb jc jd je ko jg jh ji kp jk jl jm kq jo jp jq jr hb bi translated"><code class="du kr ks kt ku b">_gameOverText.text = null;</code></p><p id="cca7" class="iu iv js iw b ix iy iz ja jb jc jd je ko jg jh ji kp jk jl jm kq jo jp jq jr hb bi translated"><code class="du kr ks kt ku b">StartCoroutine(GameOverRoutine(msg));</code></p></blockquote><p id="5e85" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">通过将我们的文本组件的值赋给一个变量<code class="du kr ks kt ku b">msg</code>，然后“清空”或清除它的内容，我们保留了一个对该值的引用——我们的游戏结束消息——它一开始就以空白消息的形式出现在玩家面前。</p><p id="d20d" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">然后，就像你可能想要创建的许多定时效果一样，我们触发一个协同例程，同时将我们的<code class="du kr ks kt ku b">msg</code>字符串传递给它</p><figure class="jv jw jx jy fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es kv"><img src="../Images/272676f0b6d19a356953918c686d8d6e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WY1tPaKp_DE7dH5Iru8fNA.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">效果协同例程</figcaption></figure><p id="c0d7" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">在这个协同程序中，效果被控制。</p><blockquote class="kl km kn"><p id="9d13" class="iu iv js iw b ix iy iz ja jb jc jd je ko jg jh ji kp jk jl jm kq jo jp jq jr hb bi translated"><code class="du kr ks kt ku b">WaitForSeconds letterDelay = new WaitForSeconds(_letterDisplayDelay);</code></p><p id="54fd" class="iu iv js iw b ix iy iz ja jb jc jd je ko jg jh ji kp jk jl jm kq jo jp jq jr hb bi translated"><code class="du kr ks kt ku b">WaitForSeconds flashDelay = new WaitForSeconds(_flashDelay);</code></p></blockquote><p id="e232" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">使用这段代码，我们将变量<code class="du kr ks kt ku b">_letterDisplayDelay</code>和<code class="du kr ks kt ku b">_flashDelay</code>设置为我们将使用的产出延迟。</p><p id="5b25" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">然后“for”循环遍历字符串变量的长度，每次在文本上增加一个字符。通过循环中的延迟，它给出了一次拼出我们的<code class="du kr ks kt ku b">msg</code>一个字符的效果。</p><figure class="jv jw jx jy fd ij er es paragraph-image"><div class="er es kw"><img src="../Images/625b65b2a6f25846e32333382b26563a.png" data-original-src="https://miro.medium.com/v2/resize:fit:764/format:webp/1*BQ97Rr1MXNHNT_LkViSRGA.png"/></div></figure><p id="5d98" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">文本组件的对齐设置决定了我们不断增长的消息的外观。当我将它设置为居中时，消息从文本组件的中间开始增长。</p><p id="95b7" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">一旦我们的信息被拼写出来，我们的代码就进入一个‘while’循环，打开和关闭我们的文本组件，给它一个闪烁的效果，这一直持续到我们的<code class="du kr ks kt ku b">_flashCount</code>变量中指定的次数。</p></div><div class="ab cl jz ka gp kb" role="separator"><span class="kc bw bk kd ke kf"/><span class="kc bw bk kd ke kf"/><span class="kc bw bk kd ke"/></div><div class="hb hc hd he hf"><p id="dc99" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">正如你所看到的，这是一个非常简单而有效的游戏补充。尝试使用文本组件设置和延迟计时器来实现您想要的游戏外观。</p></div></div>    
</body>
</html>