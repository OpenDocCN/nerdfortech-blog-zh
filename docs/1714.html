<html>
<head>
<title>Testing filesystem in Node.js: The easy way</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在Node.js中测试文件系统:简单的方法</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/testing-in-node-js-easy-way-to-mock-filesystem-883b9f822ea4?source=collection_archive---------0-----------------------#2021-04-03">https://medium.com/nerd-for-tech/testing-in-node-js-easy-way-to-mock-filesystem-883b9f822ea4?source=collection_archive---------0-----------------------#2021-04-03</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="8824" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在Node中编写应用程序时，经常需要写入或读取文件的内容。Node.js提供了一个专门用于此目的的<code class="du jd je jf jg b"><a class="ae jh" href="https://nodejs.org/api/fs.html" rel="noopener ugc nofollow" target="_blank">fs</a></code>库。但是当测试我们的代码时，我们如何处理文件系统呢？</p><p id="47ca" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我将介绍解决这个问题的两种方法——模拟单个文件系统方法和使用虚拟文件内存文件系统。我还将解释为什么后者是比前者更好的选择。</p><h1 id="079c" class="ji jj hi bd jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf bi translated">嘲笑个别方法</h1><p id="76c0" class="pw-post-body-paragraph if ig hi ih b ii kg ik il im kh io ip iq ki is it iu kj iw ix iy kk ja jb jc hb bi translated">最简单的解决方案是直接模仿<code class="du jd je jf jg b">fs</code>模块的单个方法。假设我们有一个方法，从文件中读取前5个字节，并检查其内容是否以正确的头开始，例如<em class="kl"> "hello" </em>:</p><figure class="kn ko kp kq fd kr er es paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="er es km"><img src="../Images/52415b9a1dcc19d37e9d10a2e8a1892b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bTEadEnROVPyeKJo0Cpyhg.png"/></div></div><figcaption class="ky kz et er es la lb bd b be z dx translated">测试函数—使用阻塞调用</figcaption></figure><blockquote class="lc ld le"><p id="8384" class="if ig kl ih b ii ij ik il im in io ip lf ir is it lg iv iw ix lh iz ja jb jc hb bi translated"><em class="hi">当然，我们可以使用</em> <code class="du jd je jf jg b"><em class="hi">fs.readFile()</em></code> <em class="hi">来读取整个文件的内容，但是当我们处理大文件时，这真的不是一个好主意。</em></p></blockquote><p id="e91f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们可以很容易地通过模仿<code class="du jd je jf jg b">fs.readSync()</code>来测试这个方法:</p><figure class="kn ko kp kq fd kr er es paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="er es km"><img src="../Images/4dbba827b31c563b1ba129d59392d22f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vko8DpTspsaUSPx6_KwBdg.png"/></div></div><figcaption class="ky kz et er es la lb bd b be z dx translated">测试同步文件系统调用</figcaption></figure><p id="b885" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">测试看起来非常简单，但是我们测试的函数有一个缺点——它的实现使用了阻塞调用，这在执行文件系统I/O操作时阻塞了整个JavaScript线程。让我们重新设计我们的方法，使用异步、非阻塞调用。Node.js附带了用于此目的的<code class="du jd je jf jg b"><a class="ae jh" href="https://nodejs.org/api/fs.html#fs_promises_api" rel="noopener ugc nofollow" target="_blank">fs/promises</a></code>库:</p><figure class="kn ko kp kq fd kr er es paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="er es km"><img src="../Images/5fd5c2e9491e2565c93e43d1f8f7001c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*g1snbmsy2C42bR-x_2H3PA.png"/></div></div><figcaption class="ky kz et er es la lb bd b be z dx translated">修改了函数以使用异步文件系统API</figcaption></figure><p id="d8b0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们重写测试以使用异步<code class="du jd je jf jg b">fs/Promises</code> API:</p><figure class="kn ko kp kq fd kr er es paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="er es km"><img src="../Images/412892866bdcc1e956ac5b6385296122.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dyPEHdQGUzCmDIovpUbLQw.png"/></div></div><figcaption class="ky kz et er es la lb bd b be z dx translated">测试处理文件系统的异步方法</figcaption></figure><p id="5c04" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">哎唷，我们的模拟函数变得越来越大，可读性也越来越差。我们想要模仿<code class="du jd je jf jg b">read()</code>函数，但是为了获得正确的结果，我们还必须模仿<code class="du jd je jf jg b">open()</code>和<code class="du jd je jf jg b">close()</code>。而这只是一个简单的场景！</p><p id="51a6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">上述方法对于基本情况可能已经足够了，但是对于更高级的情况，它变得非常冗长并且容易出错。它还依赖于实现。为了克服这些问题，我们应该改变我们的测试方法。我们可以模拟整个文件系统，而不是模拟单个的fs函数。</p><h1 id="8153" class="ji jj hi bd jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf bi translated">使用虚拟文件系统作为模拟</h1><p id="06aa" class="pw-post-body-paragraph if ig hi ih b ii kg ik il im kh io ip iq ki is it iu kj iw ix iy kk ja jb jc hb bi translated">在这种方法中，我们用内存中的文件系统替换真实的文件系统。有几个库解决了这个问题，一个流行的是<code class="du jd je jf jg b">mock-fs</code>，但是我想让<code class="du jd je jf jg b">memfs</code>试试。这是一个用于管理虚拟卷的简单但功能强大且文档完善的库。它一对一地重新实现了<code class="du jd je jf jg b">fs</code> API，所以把它用作模拟再合适不过了。此外，它的实现是不可知的——它与普通的<code class="du jd je jf jg b">fs</code>、<code class="du jd je jf jg b">fs/promises</code>以及其他像<code class="du jd je jf jg b"><a class="ae jh" href="https://www.npmjs.com/package/fs-extra" rel="noopener ugc nofollow" target="_blank">fs-extra</a></code>这样的库配合得很好。</p><p id="395d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们重做我们的测试来使用虚拟文件系统。首先，我们需要添加<code class="du jd je jf jg b">memfs</code>依赖关系:</p><pre class="kn ko kp kq fd li jg lj lk aw ll bi"><span id="115c" class="lm jj hi jg b fi ln lo l lp lq">yarn add -D memfs<br/># or using npm<br/>npm i --save-dev memfs</span></pre><p id="58a4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们还应该为<code class="du jd je jf jg b">fs</code>和<code class="du jd je jf jg b">fs/promises</code>模块添加<a class="ae jh" href="https://jestjs.io/docs/manual-mocks" rel="noopener ugc nofollow" target="_blank">手动模拟</a>。在我们的项目根目录<em class="kl">中创建一个<code class="du jd je jf jg b">__mocks__</code>目录(或者使用</em> <code class="du jd je jf jg b"><em class="kl">jest.config.js</em></code> <em class="kl">根据您的意愿进行配置)</em>，并在那里创建一个<code class="du jd je jf jg b">fs.js</code>文件:</p><figure class="kn ko kp kq fd kr er es paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="er es lr"><img src="../Images/66167b36b7f97f09e7df63f82efb8967.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*eDv-U306XO94dmMmOQ-LwA.png"/></div></div><figcaption class="ky kz et er es la lb bd b be z dx translated">fs模块模拟</figcaption></figure><p id="178a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果您使用的是<code class="du jd je jf jg b">fs/promises</code> API，您还应该创建<code class="du jd je jf jg b">__mocks__/fs/promises.js</code>文件:</p><figure class="kn ko kp kq fd kr er es paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="er es lr"><img src="../Images/c876e95d0c4935ac7df712384b3f3664.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jmgmCmolulaD_i9mjdSxtQ.png"/></div></div><figcaption class="ky kz et er es la lb bd b be z dx translated">fs/promises模块模拟</figcaption></figure><p id="0785" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在让我们更新我们的测试，使用我们的内存文件系统模拟:</p><figure class="kn ko kp kq fd kr er es paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="er es lr"><img src="../Images/b51e6b0aea8d79dadd258ccc874c0994.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HCWfitbVgS793s5ciPrWVg.png"/></div></div><figcaption class="ky kz et er es la lb bd b be z dx translated">使用memfs作为虚拟文件系统的示例测试</figcaption></figure><p id="bc05" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们的测试变得非常简单明了。我们编写文件内容，就像它是一个真实的文件，然后将它的路径传递给被测试的函数。我们不必关心<code class="du jd je jf jg b">checkHelloAsync</code>中使用的文件系统实现。</p><p id="76c3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在每次测试之前重置虚拟卷是一个很好的做法——如果有多个测试在同一个文件系统路径上操作，这可以避免测试相互干扰。</p><p id="8e05" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们可以看到<code class="du jd je jf jg b">fs</code>和<code class="du jd je jf jg b">fs/promises</code>都被嘲讽了。这是因为<code class="du jd je jf jg b">checkHelloAsync()</code>在其实现中使用了<code class="du jd je jf jg b">fs/promises</code>，但是出于演示的目的，我在测试中使用了<code class="du jd je jf jg b">fs-extra</code>。在现实生活中，你应该处处坚持其中的一条(我个人比较喜欢<code class="du jd je jf jg b">fs-extra</code>)。</p><h2 id="9c05" class="lm jj hi bd jk ls lt lu jo lv lw lx js iq ly lz jw iu ma mb ka iy mc md ke me bi translated">从JSON创建目录结构</h2><p id="85a4" class="pw-post-body-paragraph if ig hi ih b ii kg ik il im kh io ip iq ki is it iu kj iw ix iy kk ja jb jc hb bi translated">模仿文件而不是方法非常方便，但是上面显示的方法有一个缺点。假设您的应用程序不是在单个文件上操作，而是在整个目录结构上操作。使用大量的<code class="du jd je jf jg b">fs.mkdirp</code>和<code class="du jd je jf jg b">fs.writeFile</code>手工创建它可能很麻烦。幸运的是，<code class="du jd je jf jg b">memfs</code>还有另一个有用的特性:从JSON对象创建的目录结构。它的键是路径，值是指文件内容。让我们来看看这个例子:</p><figure class="kn ko kp kq fd kr er es paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="er es mf"><img src="../Images/c71c18488f136cfa572dbf3c778e3052.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OF2VwvRC9kK5ioXhuKS3ow.png"/></div></div><figcaption class="ky kz et er es la lb bd b be z dx translated">使用JSON生成目录结构</figcaption></figure><p id="36ec" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在我们可以使用一个<code class="du jd je jf jg b">vol.fromJSON()</code>调用来创建更复杂的目录结构。我们甚至可以将它分成多个调用，并提取到辅助函数中——这在更复杂的测试套件中可能很有用。或者甚至混合使用<code class="du jd je jf jg b">vol.fromJSON</code>和<code class="du jd je jf jg b">fs</code>方法——它们不会互相覆盖(除非修改完全相同的路径),直到<code class="du jd je jf jg b">vol.reset()</code>被调用。</p><h2 id="20f9" class="lm jj hi bd jk ls lt lu jo lv lw lx js iq ly lz jw iu ma mb ka iy mc md ke me bi translated">混合真实和虚拟文件系统</h2><p id="c0a1" class="pw-post-body-paragraph if ig hi ih b ii kg ik il im kh io ip iq ki is it iu kj iw ix iy kk ja jb jc hb bi translated">还有一件事值得一提。您可能正在使用内存中的文件系统，但是需要到达一些真实的文件——例如一些测试设备，使用<code class="du jd je jf jg b">fs</code>调用不容易准备好。有一个名为<code class="du jd je jf jg b">unionfs</code>的库，可以让你加入两个文件系统。您可以在两个图书馆网站上找到文档和示例:</p><ul class=""><li id="b2cf" class="mg mh hi ih b ii ij im in iq mi iu mj iy mk jc ml mm mn mo bi translated"><code class="du jd je jf jg b"><a class="ae jh" href="https://github.com/streamich/memfs" rel="noopener ugc nofollow" target="_blank">memfs</a></code> <a class="ae jh" href="https://github.com/streamich/memfs" rel="noopener ugc nofollow" target="_blank"> github页面</a></li><li id="fa3b" class="mg mh hi ih b ii mp im mq iq mr iu ms iy mt jc ml mm mn mo bi translated"><code class="du jd je jf jg b"><a class="ae jh" href="https://github.com/streamich/unionfs" rel="noopener ugc nofollow" target="_blank">unionfs</a></code> <a class="ae jh" href="https://github.com/streamich/unionfs" rel="noopener ugc nofollow" target="_blank"> github页面</a></li></ul><h1 id="baf0" class="ji jj hi bd jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf bi translated">结论</h1><p id="e439" class="pw-post-body-paragraph if ig hi ih b ii kg ik il im kh io ip iq ki is it iu kj iw ix iy kk ja jb jc hb bi translated">在测试任何涉及文件系统的代码时，虚拟文件系统绝对是一个值得使用的东西。这是比模仿单个方法更加灵活和直接的方法。</p><p id="e4e9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">本文只是对这种方法的简单介绍。详情请参考图书馆的官方文件。</p><p id="b720" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">本文中的所有代码示例都可以在我的GitHub 上获得<a class="ae jh" href="https://gist.github.com/barthap/e0a672e9000e72cdfbca73e4f2702f5e" rel="noopener ugc nofollow" target="_blank">。</a></p></div></div>    
</body>
</html>