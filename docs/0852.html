<html>
<head>
<title>Easy Way to Grasp JavaScript Closures</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">掌握JavaScript闭包的简单方法</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/easy-way-to-grasp-javascript-closures-7dc45fe998d9?source=collection_archive---------13-----------------------#2021-02-18">https://medium.com/nerd-for-tech/easy-way-to-grasp-javascript-closures-7dc45fe998d9?source=collection_archive---------13-----------------------#2021-02-18</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><h1 id="38b3" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">什么是终结？</h1><p id="acdd" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">简而言之:<strong class="jf hj">闭包是函数访问其外部作用域的能力。</strong></p><p id="55e1" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">在JavaScript中，每次创建一个函数，都会有一个闭包与之关联。多亏了闭包，JavaScript内部函数<strong class="jf hj">可以访问:</strong></p><ul class=""><li id="26c2" class="kg kh hi jf b jg kb jk kc jo ki js kj jw kk ka kl km kn ko bi translated">外部函数的变量</li><li id="617c" class="kg kh hi jf b jg kp jk kq jo kr js ks jw kt ka kl km kn ko bi translated">全局变量</li></ul><figure class="kv kw kx ky fd kz er es paragraph-image"><div role="button" tabindex="0" class="la lb di lc bf ld"><div class="er es ku"><img src="../Images/e9494c126d7b3769a67da1bc792016a1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5I_eMw-_K_ELvsQ-gxxybg.png"/></div></div></figure><p id="9e34" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">函数<code class="du lg lh li lj b">sayHello</code>有一个闭包，允许它访问全局范围变量<code class="du lg lh li lj b">myName</code>。同样，如果<code class="du lg lh li lj b">myName</code>改变了，<code class="du lg lh li lj b">sayHello</code>将打印这个全局变量的新值。</p><h2 id="9967" class="lk ig hi bd ih ll lm ln il lo lp lq ip jo lr ls it js lt lu ix jw lv lw jb lx bi translated">闭包最有趣的部分</h2><figure class="kv kw kx ky fd kz er es paragraph-image"><div role="button" tabindex="0" class="la lb di lc bf ld"><div class="er es ly"><img src="../Images/c7446d8a0ee5b2cf9976a49160e8cac1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*k74a_AV6eNfikEjJ7fcxGw.png"/></div></div></figure><p id="d8e8" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">在大多数情况下，我们认为JavaScript闭包是其他函数内部的函数，如示例所示。</p><ul class=""><li id="acb5" class="kg kh hi jf b jg kb jk kc jo ki js kj jw kk ka kl km kn ko bi translated">函数<code class="du lg lh li lj b">outerFct</code>返回函数<code class="du lg lh li lj b">innerFct</code></li><li id="c06a" class="kg kh hi jf b jg kp jk kq jo kr js ks jw kt ka kl km kn ko bi translated">首先我们调用<code class="du lg lh li lj b">outerFct('ging')</code>并将其传递给<code class="du lg lh li lj b">myFct</code>变量</li><li id="f404" class="kg kh hi jf b jg kp jk kq jo kr js ks jw kt ka kl km kn ko bi translated">然后我们调用<code class="du lg lh li lj b">myFct('gon')</code>来记录<strong class="jf hj"> hi内变量gon </strong>和<strong class="jf hj"> hi外变量ging </strong></li></ul><p id="66fb" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">那么<code class="du lg lh li lj b">myFct('gon')</code>怎么可能在外部变量中记录<em class="lz">呢？</em></p><p id="f483" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">现在是<strong class="jf hj">关闭</strong></p><p id="a9b2" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">当我们调用<code class="du lg lh li lj b">const myFct = outerFct('ging');</code> <strong class="jf hj"> closure </strong>时，让我们的内部函数在外部函数<code class="du lg lh li lj b">outerFct</code>中，外部函数有参数<code class="du lg lh li lj b">'ging' </code>将其保存为一个外部变量，它将在执行的所有时间里记住这个变量。</p><p id="5eff" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">所以当我们调用函数<code class="du lg lh li lj b">myFct('gon')</code>时，我们实际上是在调用内部函数，这个函数在其闭包中仍然有<code class="du lg lh li lj b">outerVar</code>的值，也就是<code class="du lg lh li lj b">ging</code>。</p><p id="1c17" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">请注意，如果我们直接调用:</p><pre class="kv kw kx ky fd ma lj mb mc aw md bi"><span id="d303" class="lk ig hi lj b fi me mf l mg mh">outer('ging')('gon');           | results:<br/>                                | hi inner variable gon<br/>                                | hi outer variable ging       </span></pre></div><div class="ab cl mi mj gp mk" role="separator"><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn"/></div><div class="hb hc hd he hf"><figure class="kv kw kx ky fd kz er es paragraph-image"><div role="button" tabindex="0" class="la lb di lc bf ld"><div class="er es mp"><img src="../Images/27947acb24733bebd44aeb06fb517d82.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7j9WebHvWn4YEQUl-30aaA.png"/></div></div></figure><p id="a40f" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">总之，每当一个函数被创建时，这个函数的一个<strong class="jf hj">闭包</strong>也被创建。这个闭包可以访问三种作用域:</p><ul class=""><li id="38e3" class="kg kh hi jf b jg kb jk kc jo ki js kj jw kk ka kl km kn ko bi translated">全球范围</li><li id="e50c" class="kg kh hi jf b jg kp jk kq jo kr js ks jw kt ka kl km kn ko bi translated">创建内部函数的外部函数范围</li><li id="79c7" class="kg kh hi jf b jg kp jk kq jo kr js ks jw kt ka kl km kn ko bi translated">内部函数的内部范围</li></ul></div></div>    
</body>
</html>