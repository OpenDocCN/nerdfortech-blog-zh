<html>
<head>
<title>Grid Algorithms</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">网格算法</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/grid-algorithms-742d4a0244bd?source=collection_archive---------25-----------------------#2021-03-09">https://medium.com/nerd-for-tech/grid-algorithms-742d4a0244bd?source=collection_archive---------25-----------------------#2021-03-09</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/aa543da6411163257927ad159a1d097f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*itksC-muOmEfTuwjvPPMJA.jpeg"/></div></div></figure><p id="c2e4" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">本周…龙与地下城！</p><p id="0581" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">好吧，不是真正的D&amp;D，但很接近。在我第一次用<a class="ae jo" href="http://www.interviewing.io" rel="noopener ugc nofollow" target="_blank">intervaling . io</a>进行模拟面试的时候(顺便说一下，这是一个很棒的平台——看看吧！)我被要求解决一个类似棋盘游戏的问题，有点像著名的龙与地下城角色扮演游戏。该练习按照给定的数字输入来阅读一些内容，创建一个测量输入值的长度和宽度的二维地图(例如，如果输入值为5，我们需要一个总共有25个空格的5×5网格)。接下来，在板上随机填入4个字符中的1个(“M”、“t”、“#”、“”)。警告？怪物角色不能彼此相邻或成对角线。</p><p id="386f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我必须承认我很紧张。我希望清晰和自信会随着时间和练习而来，但是现在…</p><p id="be71" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我被要求构建的网格实际上是一个x行x列的数组(x是输入值)。例如，给定输入3，生成的网格应该如下所示:</p><figure class="jq jr js jt fd ij er es paragraph-image"><div class="er es jp"><img src="../Images/42b141307aefffa1c7b4687041d4534a.png" data-original-src="https://miro.medium.com/v2/resize:fit:206/format:webp/1*yRj58PhKC7AjHMpxiZDK9g.png"/></div></figure><p id="5e00" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我计划:</p><ol class=""><li id="09ef" class="ju jv hi is b it iu ix iy jb jw jf jx jj jy jn jz ka kb kc bi translated">用x个嵌套数组实例化一个新数组。</li><li id="edbc" class="ju jv hi is b it kd ix ke jb kf jf kg jj kh jn jz ka kb kc bi translated">用4个给定字符中的任意一个随机填充这些数组的列(或行)。</li><li id="4b67" class="ju jv hi is b it kd ix ke jb kf jf kg jj kh jn jz ka kb kc bi translated">循环通过单独的行，以确保怪物字符不相邻，也不对角线彼此。</li></ol><figure class="jq jr js jt fd ij er es paragraph-image"><div class="er es ki"><img src="../Images/decb433766bd90602430eb4da422926e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1022/format:webp/1*J9fIIzz2J1NAmXbLdpxeXw.png"/></div></figure><p id="9b7e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在我的采访中得到一些反馈后，我被要求想出一个更好的解决方案。与其在整个网格中循环不止一次，为什么不在构建网格时创建、填充和检查呢？此外，我们真的需要向左看吗，例如，当我们在最左边的列时？我们在最上面一排的时候怎么样？准备好接受挑战，这是我想到的:</p><figure class="jq jr js jt fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es kj"><img src="../Images/2c4253d68b2d67af56bb7ffbd8f4fee9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qocMS8ANvQBaY7RQzxVg8Q.png"/></div></div></figure><p id="e2e0" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">1)定义外部阵列或网格。</p><p id="91c6" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">2)创建一个while循环，该循环将<em class="kk">将</em> x行推到所述网格上。</p><p id="5528" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">3)设置两个条件句:一个处理第一行，另一个处理第二行以后的内容。</p><p id="47b7" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">4)第二个嵌套while循环负责填充每一行。而row.length &lt; input, generate a random number that will serve as the index when choosing a random character from the array of characters:</p><pre class="jq jr js jt fd kl km kn ko aw kp bi"><span id="c422" class="kq kr hi km b fi ks kt l ku kv">if (grid.length == 1) {<br/>   while (row.length &lt; input) {<br/>      index = Math.floor(Math.random() * characters.length);<br/>      ...<br/>   }<br/>}</span></pre><p id="c64d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">5) A third nested while loop takes care of any adjacent Monsters. Starting at col 2 (index 1), if and as long as the randomly generated character is a Monster and so is the previous input [‘#’, ‘M’, ?], we want to go back to the drawing board to reassign character:</p><pre class="jq jr js jt fd kl km kn ko aw kp bi"><span id="d83b" class="kq kr hi km b fi ks kt l ku kv">if (grid.length == 1) {<br/>   ...<br/>   while (<br/>      row.length &gt;= 1 &amp;&amp;<br/>      characters[index] === "M" &amp;&amp;<br/>      row[col - 1] === "M"<br/>   ) {<br/>      index = Math.floor(Math.random() * characters.length);<br/>   }<br/>   row.push(characters[index]);<br/>   col++;<br/>   ...<br/> }<br/>}</span></pre><p id="22b0" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">6) If the chosen character is not a Monster, we simply <em class="kk">将它推入行中，记住在移动到下一个索引之前增加row。</em></p><p id="c979" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">7)对于第二行及以上，我们希望遵循与上面相同的步骤，但有一个微小但重要的变化。请记住，怪物不能彼此对角，我们现在有以前的行来说明。</p><pre class="jq jr js jt fd kl km kn ko aw kp bi"><span id="dd50" class="kq kr hi km b fi ks kt l ku kv">if (grid.length &gt; 1) {<br/>  let previousRow = grid[subArr];<br/>  while (row.length &lt; input) {<br/>    index = Math.floor(Math.random() * characters.length);<br/>    while (<br/>      characters[index] === "M" &amp;&amp;<br/>      ( <strong class="km hj">previousRow[col + 1] === "M" ||<br/>        previousRow[col - 1] === "M" ||<br/>        previousRow[col] === "M"</strong> <strong class="km hj">||</strong><br/>        row[col - 1] === "M")<br/>    ) {<br/>      index = Math.floor(Math.random() * characters.length);<br/>    }<br/>    row.push(characters[index]);<br/>    col++;<br/>  }<br/>  subArr++;<br/>}</span></pre><p id="dbf2" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">除了检查随机生成的字符是否是怪物，我们还需要确保当前行中的前一个字符以及顶部、左上和右上的字符都不是怪物。如果这些也是怪物，那么我们需要随机生成另一个角色。</p><figure class="jq jr js jt fd ij er es paragraph-image"><div class="er es kw"><img src="../Images/e089574d45be8ea26b1ea97a9d3e0733.png" data-original-src="https://miro.medium.com/v2/resize:fit:242/format:webp/1*Xb2YKR5CqR2wW6cr2CjIyw.png"/></div></figure><p id="41ea" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">8.具备了这些条件，我们现在应该一切就绪了！</p><p id="958f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">虽然这次技术挑战我失败了，但是还是挺好玩挺有意思的！</p><p id="c6b0" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">你在技术面试中遇到过类似的挑战吗？你是如何解决这个问题的？我很想听听！</p><p id="cc37" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">一如既往的感谢阅读！🐉</p></div></div>    
</body>
</html>