<html>
<head>
<title>How session stickiness disrupts auto scaling in k8s</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">会话粘性如何破坏 k8s 中的自动缩放</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/how-session-stickiness-disrupts-pod-auto-scaling-in-kubernetes-17ece8e2ea4f?source=collection_archive---------1-----------------------#2021-10-09">https://medium.com/nerd-for-tech/how-session-stickiness-disrupts-pod-auto-scaling-in-kubernetes-17ece8e2ea4f?source=collection_archive---------1-----------------------#2021-10-09</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/6e075096544a60f08ab6b45d8abaa442.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jgq0Jmn4_F6LFIEdePnrDg.png"/></div></div></figure><p id="2c29" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在孤注一掷地尝试扩展一个庞大的庞然大物时，我偶然发现了 AWS 应用程序负载平衡器(ALB)的一个有趣的限制。自动伸缩和负载平衡是两个完全不同的方面。然而，在形成有效的可扩展子系统时，协调是至关重要的。这就是粘性会话的故事，以及它们如何无情地影响负载平衡和扩展之间的关系。</p><p id="9e8a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这将是一个漫长而又冒险的阅读。拿起你的筹码，继续滚动。</p><h1 id="5589" class="jo jp hi bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">入门指南</h1><h2 id="7ab8" class="km jp hi bd jq kn ko kp ju kq kr ks jy jb kt ku kc jf kv kw kg jj kx ky kk kz bi translated">一个很好的先决条件</h2><p id="d188" class="pw-post-body-paragraph iq ir hi is b it la iv iw ix lb iz ja jb lc jd je jf ld jh ji jj le jl jm jn hb bi translated">对 AWS <a class="ae lf" href="https://searchaws.techtarget.com/definition/application-load-balancer" rel="noopener ugc nofollow" target="_blank">负载平衡</a>和 Kubernetes(或 k8s)水平 pod 自动伸缩(<a class="ae lf" href="https://kubernetes.io/docs/tasks/run-application/horizontal-pod-autoscale/" rel="noopener ugc nofollow" target="_blank"> HPA </a>)的合理理解将会进一步简化阅读。</p><p id="e28a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如果您对这些有一些挥之不去的想法，让我浏览一下本文中使用的概念。</p><p id="5f1e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">库伯内特 HPA </strong></p><p id="8b1f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">假设您的应用程序部署在 Amazon AWS 中，并由 Kubernetes 编排。为了应对应用服务器不断变化的负载需求，k8s HPA 会根据配置的标准(比如所有正在运行的单元的平均 CPU 利用率)在单元中进行横向扩展或纵向扩展。这样，您只需使用所需的 AWS 资源，最大限度地降低利用率，并为您使用的资源付费。</p><p id="58fa" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj"> AWS 应用负载平衡器(ALB) </strong></p><p id="1737" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">假设您为负载平衡需求配置了 AWS ALB。既然 pod 频繁扩展，ALB 必须<em class="lg">高效地</em>将负载分配给底层的 pod。负载均衡器算法达到最优并均匀分配负载至关重要。</p><p id="6fe2" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">粘性会话</strong></p><p id="ee00" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">粘性通常与会话关联性互换使用，它是负载平衡器(这里是 ALB)的一个特性，其中负载平衡算法在分配负载时考虑请求和服务器之间的相关性。换句话说，在 LB 算法的指导下，请求显示了与服务器的“亲缘关系”。</p><p id="e849" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj"> <em class="lg">注意:</em> </strong> <em class="lg">在本文的上下文中，考虑 session ==来自用户会话的一系列‘n’个请求。此外，pod 和服务器可以互换使用。</em></p><figure class="li lj lk ll fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lh"><img src="../Images/57afb21f9b8a2ea06747a8bfb148827b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UXSpiP2sfFh5KvTXJT0ILg.png"/></div></div><figcaption class="lm ln et er es lo lp bd b be z dx translated">来自特定客户端的所有请求被路由到单个 pod</figcaption></figure><figure class="li lj lk ll fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lh"><img src="../Images/1fa6b0cd7a9172a6155b7cb2b29abaf4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*U8K8UG2K9gRuSLhIUuxAjg.png"/></div></div><figcaption class="lm ln et er es lo lp bd b be z dx translated">来自同一客户端的请求被分发到多个 pod</figcaption></figure><p id="81ec" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在服务器上维护会话状态可以优化性能的情况下，例如内存缓存，粘性会话非常有用。</p><p id="1fcc" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">AWS-ALB 中的粘性</strong></p><p id="e247" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">为了识别粘性，ALB 在每个请求之间传递一个名为 AWSALB 的 cookie。对于没有 AWSALB cookie 的新会话，将根据配置的 LB 算法选择服务器。查看<a class="ae lf" href="https://docs.aws.amazon.com/elasticloadbalancing/latest/application/sticky-sessions.html" rel="noopener ugc nofollow" target="_blank">此</a>了解更多信息。</p><p id="dc29" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">既然你已经熟悉了基础知识，让我们进入有趣的内容。</p><h1 id="794e" class="jo jp hi bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated"><strong class="ak">问题 1:粘性会话的平衡</strong></h1><p id="fbca" class="pw-post-body-paragraph iq ir hi is b it la iv iw ix lb iz ja jb lc jd je jf ld jh ji jj le jl jm jn hb bi translated">我们的应用程序有类似的 AWS-ALB 和 k8s 设置来协调伸缩需求。此外，应用程序从在内存中缓存用户的会话状态中获益匪浅，自然倾向于选择 ALB 的会话粘性。</p><p id="befb" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">当我对负载测试场景进行实验时，在 HPA 的上下文中，非粘性会话和粘性会话的区别是明显的。</p><figure class="li lj lk ll fd ij er es paragraph-image"><div class="er es lq"><img src="../Images/08896acc9c7e4b3f728738cbade1d3f4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1018/format:webp/1*ai2oz0naot0CJPUGfP32hg.png"/></div><figcaption class="lm ln et er es lo lp bd b be z dx translated">非粘性场景:将负载分布到扩展的 pod</figcaption></figure><p id="5e10" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">对于非粘性、无状态请求，当 HPA 扩展 pod 时，新创建的 pod 会分担负载。</p><figure class="li lj lk ll fd ij er es paragraph-image"><div class="er es lr"><img src="../Images/10600361ab4032d08a9535fc603aabf4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1038/format:webp/1*AeLrNhXX_QLre4eKHIguQA.png"/></div><figcaption class="lm ln et er es lo lp bd b be z dx translated">棘手场景:将负载分布到扩展的 pod</figcaption></figure><p id="a646" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">对于粘性请求，当 HPA 由于现有单元中的负载增加而扩展单元时，不会为新单元分配任何负载，从而使新单元的扩展无效。</p><h2 id="9b11" class="km jp hi bd jq kn ko kp ju kq kr ks jy jb kt ku kc jf kv kw kg jj kx ky kk kz bi translated">问题的严重性</h2><p id="c50b" class="pw-post-body-paragraph iq ir hi is b it la iv iw ix lb iz ja jb lc jd je jf ld jh ji jj le jl jm jn hb bi translated">如果 pod 上没有活动会话，但是来自这些会话的突发请求突然同时变得活动，该怎么办？</p><p id="4b32" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">负载均衡器默默地将这些请求路由到“粘性”服务器，即使有其他服务器可以轻松地承担负载——最终导致死亡。</p><p id="e26e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">尽管负载场景模拟了我们真实世界的应用程序使用模式，但还是有点人为。它假设大多数会话都是长期存在的，创建新会话的频率相对较低。</p><p id="e212" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">进一步的探索引出了另一个有趣的问题。</p><h1 id="a6bd" class="jo jp hi bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated"><strong class="ak">问题 2:低效的负载均衡算法</strong></h1><p id="7aea" class="pw-post-body-paragraph iq ir hi is b it la iv iw ix lb iz ja jb lc jd je jf ld jh ji jj le jl jm jn hb bi translated">默认情况下，AWS ALB 使用<strong class="is hj">循环</strong>算法来分发请求。它天真地通过可用的服务器循环请求，忽略了系统的负载。</p><p id="c510" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在，让我们考虑一种更“真实”的情况，在这种情况下，旧会话和新会话之间存在平衡。此外，服务器上的负载并不均匀。</p><p id="b35b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">由于显而易见的原因，循环赛<em class="lg">失败</em>。</p><h2 id="7bf0" class="km jp hi bd jq kn ko kp ju kq kr ks jy jb kt ku kc jf kv kw kg jj kx ky kk kz bi translated">LOR 拯救了世界</h2><p id="aa27" class="pw-post-body-paragraph iq ir hi is b it la iv iw ix lb iz ja jb lc jd je jf ld jh ji jj le jl jm jn hb bi translated">AWS ALB 可以配置为使用<a class="ae lf" href="https://aws.amazon.com/about-aws/whats-new/2019/11/application-load-balancer-now-supports-least-outstanding-requests-algorithm-for-load-balancing-requests/" rel="noopener ugc nofollow" target="_blank"> <strong class="is hj">最少未完成请求</strong> </a>策略，而不是默认的循环策略。顾名思义，该算法在路由流量时考虑服务器正在处理的“活动”请求的数量。理论上，在服务器处理不同负载的情况下，LOR 比 RR 更有效。</p><p id="786c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">一个不错的<a class="ae lf" rel="noopener" href="/dazn-tech/aws-application-load-balancer-algorithms-765be2eca158">帖子</a>详细了解</p><h2 id="2fa6" class="km jp hi bd jq kn ko kp ju kq kr ks jy jb kt ku kc jf kv kw kg jj kx ky kk kz bi translated"><strong class="ak">但是粘性破坏了聚会——再一次</strong></h2><p id="37b1" class="pw-post-body-paragraph iq ir hi is b it la iv iw ix lb iz ja jb lc jd je jf ld jh ji jj le jl jm jn hb bi translated"><strong class="is hj">考虑一个假设的场景。</strong></p><p id="9c13" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我有 3 个后端服务器(有粘性会话)服务器 1，服务器 2，服务器 3。每台服务器的最大容量为<em class="lg"> 200 个活动请求</em>。</p><p id="c491" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">将它们在特定时间点服务的活动请求(和负载)视为:</p><blockquote class="ls lt lu"><p id="f229" class="iq ir lg is b it iu iv iw ix iy iz ja lv jc jd je lw jg jh ji lx jk jl jm jn hb bi translated">服务器 1: 150 (75%)个活动请求</p><p id="e146" class="iq ir lg is b it iu iv iw ix iy iz ja lv jc jd je lw jg jh ji lx jk jl jm jn hb bi translated">服务器 2: 200 (100%)个活动请求</p><p id="433e" class="iq ir lg is b it iu iv iw ix iy iz ja lv jc jd je lw jg jh ji lx jk jl jm jn hb bi translated">服务器 3:180 (80%)个活动请求</p></blockquote><p id="d2c6" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">注意</strong> : <em class="lg">此时，并非所有连接到相应服务器的粘性会话都有活动请求，</em> <strong class="is hj"> <em class="lg">即</em> </strong> <em class="lg">服务器 2 可能有多个其他连接的会话，其请求当前未被服务。</em></p><p id="1bb6" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">当来自新会话 session-X 的请求到达时，它应该基于 LOR 算法配置的被路由到服务器 1<em class="lg">，因为服务器 1 具有最少的活动请求。</em></p><p id="cbf8" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">当来自粘性会话 session-N-Server2 的请求到达时，它仍然由 Server2 提供服务，这使得 LOR 无效。</p><blockquote class="ly"><p id="bcab" class="lz ma hi bd mb mc md me mf mg mh jn dx translated">粘性击败了负载平衡并使 HPA 无效</p></blockquote><h1 id="84cc" class="jo jp hi bd jq jr js jt ju jv jw jx jy jz mi kb kc kd mj kf kg kh mk kj kk kl bi translated">那么，我在找什么？</h1><p id="483a" class="pw-post-body-paragraph iq ir hi is b it la iv iw ix lb iz ja jb lc jd je jf ld jh ji jj le jl jm jn hb bi translated">一种智能算法，在路由流量时，考虑与服务器<strong class="is hj">相关联的不一定处于活动状态</strong>的粘性会话的数量。</p><p id="641c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">TL；速度三角形定位法(dead reckoning)</p><ol class=""><li id="c6c1" class="ml mm hi is b it iu ix iy jb mn jf mo jj mp jn mq mr ms mt bi translated">LB 应该将传入的请求路由到“附加最少总会话”的<em class="lg">服务器。</em></li><li id="8d1f" class="ml mm hi is b it mu ix mv jb mw jf mx jj my jn mq mr ms mt bi translated">在服务器过载的情况下，LB 应该将粘性请求重新路由到最佳服务器，从而利用 HPA。</li></ol><p id="230c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如果你还没有猜到，我寻找这个假设的负载平衡器的任务到此结束。</p><p id="824f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">顺便说一下:</strong>我们已经想出了几个主意，比如拒绝应用程序中的会话和速率限制，但这些都不实用。</p><h1 id="fb80" class="jo jp hi bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">几个月后…我发现了这个。</h1><p id="8261" class="pw-post-body-paragraph iq ir hi is b it la iv iw ix lb iz ja jb lc jd je jf ld jh ji jj le jl jm jn hb bi translated">我开始了解到<a class="ae lf" href="https://docs.solo.io/gloo-edge/master/installation/advanced_configuration/session_affinity/" rel="noopener ugc nofollow" target="_blank"> Gloo gateway 的</a>哈希环算法支持会话相似性，并在发生扩展事件的情况下增加了负载重新分配的好处(#2)。</p><p id="d192" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这带有一个星号，表示会话状态需要迁移到一个新发现的服务器。这为其自身的挑战打开了一扇大门。但那是以后的事了。</p><h1 id="22dc" class="jo jp hi bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated"><strong class="ak">关键外卖</strong></h1><ul class=""><li id="c951" class="ml mm hi is b it la ix lb jb mz jf na jj nb jn nc mr ms mt bi translated">粘性更多的是一种“特性”而不是限制。这不符合自动缩放的原则。</li><li id="1757" class="ml mm hi is b it mu ix mv jb mw jf mx jj my jn nc mr ms mt bi translated">没有解决我们所有可伸缩性需求的灵丹妙药。这都是关于同意和生活的权衡。</li><li id="ced7" class="ml mm hi is b it mu ix mv jb mw jf mx jj my jn nc mr ms mt bi translated">攀登巨石是一项艰巨的任务。</li></ul><p id="2eb1" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">接下来:</strong>在下一篇文章中，我将讨论容器化环境中 JVM 应用程序的另一个有趣的可伸缩性限制。</p></div></div>    
</body>
</html>