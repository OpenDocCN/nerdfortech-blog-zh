<html>
<head>
<title>1929. Concatenation of Array</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">1929.数组串联</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/1929-concatenation-of-array-e27cc243f07?source=collection_archive---------1-----------------------#2021-11-11">https://medium.com/nerd-for-tech/1929-concatenation-of-array-e27cc243f07?source=collection_archive---------1-----------------------#2021-11-11</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="4131" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">(LeetCode易题)</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es jd"><img src="../Images/b0b1e4e50984003bc6678959883eb569.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*u9IGAHuJa9xiGX8F.png"/></div></div></figure><p id="d874" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">给定一个长度为<code class="du jp jq jr js b">n</code>的整数数组<code class="du jp jq jr js b">nums</code>，你想创建一个长度为<code class="du jp jq jr js b">2n</code>的数组<code class="du jp jq jr js b">ans</code>，其中<code class="du jp jq jr js b">ans[i] == nums[i]</code>和<code class="du jp jq jr js b">ans[i + n] == nums[i]</code>代表<code class="du jp jq jr js b">0 &lt;= i &lt; n</code>(<strong class="ih hj">0-索引</strong>)。</p><p id="7e0f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">具体来说，<code class="du jp jq jr js b">ans</code>是两个<code class="du jp jq jr js b">nums</code>数组的<strong class="ih hj">串联</strong>。</p><p id="298b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">返回<em class="jt">数组</em>中的<code class="du jp jq jr js b">ans</code>。</p><p id="1286" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">例1: </strong></p><pre class="je jf jg jh fd ju js jv jw aw jx bi"><span id="dd96" class="jy jz hi js b fi ka kb l kc kd"><strong class="js hj">Input:</strong> nums = [1,2,1]<br/><strong class="js hj">Output:</strong> [1,2,1,1,2,1]<br/><strong class="js hj">Explanation:</strong> The array ans is formed as follows:<br/>- ans = [nums[0],nums[1],nums[2],nums[0],nums[1],nums[2]]<br/>- ans = [1,2,1,1,2,1]</span></pre><p id="62da" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">例2: </strong></p><pre class="je jf jg jh fd ju js jv jw aw jx bi"><span id="1fa0" class="jy jz hi js b fi ka kb l kc kd"><strong class="js hj">Input:</strong> nums = [1,3,2,1]<br/><strong class="js hj">Output:</strong> [1,3,2,1,1,3,2,1]<br/><strong class="js hj">Explanation:</strong> The array ans is formed as follows:<br/>- ans = [nums[0],nums[1],nums[2],nums[3],nums[0],nums[1],nums[2],nums[3]]<br/>- ans = [1,3,2,1,1,3,2,1]</span></pre><p id="2a30" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">约束:</strong></p><ul class=""><li id="da14" class="ke kf hi ih b ii ij im in iq kg iu kh iy ki jc kj kk kl km bi translated"><code class="du jp jq jr js b">n == nums.length</code></li><li id="2df3" class="ke kf hi ih b ii kn im ko iq kp iu kq iy kr jc kj kk kl km bi translated"><code class="du jp jq jr js b">1 &lt;= n &lt;= 1000</code></li><li id="8fc2" class="ke kf hi ih b ii kn im ko iq kp iu kq iy kr jc kj kk kl km bi translated"><code class="du jp jq jr js b">1 &lt;= nums[i] &lt;= 1000</code></li></ul><p id="3518" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们首先理解这个问题的含义——它非常非常简单，我们只需要连接，这意味着在现有数组中按顺序加入相同的元素。例如，让我们说nums=[1，4，5]，那么现在在连接之后它应该变成nums=[1，4，5，1，4，5]。我希望这能让你清楚解决方案是什么样的。</p><p id="de0c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">所以解决这个问题有很多方法，但最简单的方法是什么呢？好吧，提示就在上面给出的问题本身中，这将是我们的蛮力方法。让我们开始吧:</p><h1 id="a6e1" class="ks jz hi bd kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo bi translated">强力方法</h1><p id="7b27" class="pw-post-body-paragraph if ig hi ih b ii lp ik il im lq io ip iq lr is it iu ls iw ix iy lt ja jb jc hb bi translated">强力方法是什么意思？你首先想到的最简单的方法是，我们不太关注时间和空间复杂性的优化，对吗？我希望你同意我的话。</p><p id="09d9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">所以现在我们已经知道了:</p><p id="c258" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">给定一个长度为<code class="du jp jq jr js b">n</code>的整数数组<code class="du jp jq jr js b">nums</code>，你想要创建一个长度为<code class="du jp jq jr js b">2n</code>的数组<code class="du jp jq jr js b">ans</code>，其中<code class="du jp jq jr js b">ans[i] == nums[i]</code>和<code class="du jp jq jr js b">ans[i + n] == nums[i]</code>用于<code class="du jp jq jr js b">0 &lt;= i &lt; n</code>(<strong class="ih hj">0-索引</strong>)。</p><p id="0339" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">步骤如下:</p><ol class=""><li id="6755" class="ke kf hi ih b ii ij im in iq kg iu kh iy ki jc lu kk kl km bi translated">首先，创建一个2n大小的数组，其中n是给定数组的大小。</li><li id="6232" class="ke kf hi ih b ii kn im ko iq kp iu kq iy kr jc lu kk kl km bi translated">现在，在for循环中，继续复制第I个和第(i+n)个索引的值。等等，让我帮你更好地想象一下。</li></ol><p id="c5f6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">ans = {}我们的新数组对吗？所以现在对于I从0到(n-1)的每个值，ans中的值将被填充为，</p><p id="652a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">ans[0] = nums[0]</p><p id="fabe" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">ans[1] = nums[1]</p><p id="1036" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">ans[2] = nums[2]</p><p id="2a00" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">ans[3] = nums[0]</p><p id="faef" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">ans[4] = nums[1]</p><p id="8b6c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">ans[5] = nums[2]，所以你能看到这里的重复吗，你能对吗？</p><p id="fd62" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">但是记住我们只有从0到(n-1)的索引值，在这个例子中是从0到2。</p><p id="e499" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">所以看这里ans[0] = nums[0]，ans[1] = nums[1]，ans[2] = nums[2]这些看起来更容易，如何？因为我们可以简单的把值等同为ans[i] = nums[i]对吗？但是剩下的呢？</p><p id="4e3c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">可以写成ans[i+n]吗？当I为0时，它变成ans[n] = ans[3]，当i = 1时，它变成ans[n+1] = ans[4]，而右边的值保持不变。所以我相信这让你清楚了问题背后的概念。</p><p id="76a1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在让我们把代码写下来:</p><pre class="je jf jg jh fd ju js jv jw aw jx bi"><span id="8c27" class="jy jz hi js b fi ka kb l kc kd"><strong class="js hj">class Solution {<br/>public:<br/>    vector&lt;int&gt; getConcatenation(vector&lt;int&gt;&amp; nums) {<br/>        int n = nums.size();<br/>        vector&lt;int&gt;ans(2*n);<br/>        for(int i=0;i&lt;n;i++)<br/>        {<br/>            ans[i] = nums[i];<br/>            ans[i+n] = nums[i];<br/>        }<br/>        return ans;<br/>    }<br/>};</strong></span></pre><p id="7bc0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在你能告诉我这个程序的时空复杂度是多少吗？</p><p id="f0c2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们不是遍历了整个原始数组吗？我们正在做，对吗？</p><p id="5289" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">那么我们的答案来了，我们的<strong class="ih hj"> <em class="jt">时间复杂度变成了O(n) </em> </strong>。</p><p id="a1d7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">空间复杂度呢？我们使用了一个新的数组，大小是原来的两倍。所以<strong class="ih hj"> <em class="jt">空间复杂度变成O(2*n) </em> </strong>当我们忽略常数时可以近似为O(n)。</p><p id="5b46" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我希望这能让你非常清楚第一个概念。</p><blockquote class="lv lw lx"><p id="2cb3" class="if ig jt ih b ii ij ik il im in io ip ly ir is it lz iv iw ix ma iz ja jb jc hb bi translated">PS:我已经做了预演，试着先用例子预演你的概念，然后再编码。试着花至少20分钟在白板或笔记本上解决这个问题。</p></blockquote><p id="f244" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在让我们转到下一个概念。我们看到我们的空间复杂度可以降低/应该降低。我们能不用额外的空间解决这个问题吗？你怎么想呢?</p><p id="501b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">答案就在这里，是的，我们可以。但是怎么做呢？</p><p id="9d60" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">可以肯定的是，如果我们不想使用任何额外的空间，我们需要调整原始向量本身的元素，就像动态地改变它的大小，不是吗？</p><p id="6977" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们的方法是这样的。</p><h1 id="b211" class="ks jz hi bd kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo bi translated">优化方法</h1><pre class="je jf jg jh fd ju js jv jw aw jx bi"><span id="6306" class="jy jz hi js b fi ka kb l kc kd"><strong class="js hj">class Solution {<br/>public:<br/>    vector&lt;int&gt; getConcatenation(vector&lt;int&gt;&amp; nums) {<br/>        int n = nums.size();<br/>        for(int i=0;i&lt;n;i++)<br/>        {<br/>            nums.push_back(nums[i]);<br/>        }<br/>        return nums;<br/>    }<br/>};</strong></span></pre><p id="2a6a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们不使用另一个向量，而是简单地将值插入同一个向量本身。在这里，我们没有使用任何额外的空间来存放任何东西。</p><p id="ab43" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">预演很简单，试着自己做。</p><h1 id="7433" class="ks jz hi bd kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo bi translated">希望这篇文章能帮助你更好地理解这些概念。直到那时，继续编码&amp;继续学习，因为一致性是关键！！！祝您好运🙌💻</h1><p id="3fa7" class="pw-post-body-paragraph if ig hi ih b ii lp ik il im lq io ip iq lr is it iu ls iw ix iy lt ja jb jc hb bi translated">既然你喜欢看我的博客，为什么不请我喝杯咖啡，支持我的工作呢！！<a class="ae mb" href="https://www.buymeacoffee.com/sukanyabharati" rel="noopener ugc nofollow" target="_blank">https://www.buymeacoffee.com/sukanyabharati</a>☕</p></div></div>    
</body>
</html>