<html>
<head>
<title>THREADS IN JAVA</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JAVA中的线程</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/threads-in-java-b3b575d1030d?source=collection_archive---------7-----------------------#2021-05-10">https://medium.com/nerd-for-tech/threads-in-java-b3b575d1030d?source=collection_archive---------7-----------------------#2021-05-10</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/a5f466eb32596d63667a92c827968cc8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Hv60LE95JiRGVLzZAS_fwQ.jpeg"/></div></div></figure><p id="1baa" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">●线程是执行的流程。</p><p id="9f38" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">●一个线程同时执行多条指令。</p><p id="1f35" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">●线程用于在后台执行复杂的任务，而不会中断主程序。</p><h1 id="d788" class="jo jp hi bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated"><strong class="ak">多线程</strong></h1><p id="aca5" class="pw-post-body-paragraph iq ir hi is b it km iv iw ix kn iz ja jb ko jd je jf kp jh ji jj kq jl jm jn hb bi translated">多线程可以被称为同时处理的多个执行流。这也被称为“多任务处理”。</p><figure class="ks kt ku kv fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es kr"><img src="../Images/ddef6bb4545c56adc1b709113dc3f7cd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2hV6nGeb-tDt-ItvaT0F8A.png"/></div></div></figure><figure class="ks kt ku kv fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es kw"><img src="../Images/bb814d84a98cd6220f2d5721ddcda760.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qcyIMRw4yJMde3VL3pnAAQ.png"/></div></div></figure><figure class="ks kt ku kv fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es kx"><img src="../Images/8bb2351157b7892823e582258188e450.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gky7qTo1NEos5leWrGyUYA.png"/></div></div></figure><p id="b745" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">✦有一种可能性，在某一点上，所有的线程可以加入，并作为一个线程从这一点开始。</p><p id="69c5" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">要记住的事实:</strong></p><p id="b384" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">🟠:仅仅通过增加线程的数量是不可能显著减少时间的。</p><p id="0b16" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">🟠在基于线程的多任务处理中，那些线程属于一个进程本身。</p><h1 id="f97e" class="jo jp hi bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated"><strong class="ak">线程生命周期</strong></h1><figure class="ks kt ku kv fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ky"><img src="../Images/f693b24559db49e30bf4d3965155bfcf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*A4u-G-irDk0Okl2AsmMXzg.png"/></div></div></figure><ol class=""><li id="aa37" class="kz la hi is b it iu ix iy jb lb jf lc jj ld jn le lf lg lh bi translated"><strong class="is hj">新增</strong></li></ol><p id="5cc5" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">当你创建一个线程类的实例时，线程进入新的状态。当线程处于新状态时，它还没有开始执行。</p><p id="10b3" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj"> 2。就绪/可运行</strong></p><p id="f154" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">一旦线程进入可运行状态，它就可以执行了。</p><p id="eb7b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj"> 3。正在运行</strong></p><p id="b89f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如果线程调度器选择并分配了一个任务，它就处于运行状态。在某些情况下，线程可以移回就绪状态。</p><p id="6156" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj"> 4。死了</strong></p><p id="944a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">当线程的run()方法退出时，它处于dead状态。一旦线程死了，它就不能回到任何先前的阶段。</p><p id="ca6a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">🔴在这些步骤之间，还有其他多个步骤。</p><p id="c2c5" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">例如:线程可以进入阻塞状态(临时保持状态)</p><figure class="ks kt ku kv fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es li"><img src="../Images/65447b6e8ef0eb9d91f0093748a7576e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-cq1dVbkoKc0Kre-RibeZg.png"/></div></div></figure><p id="c864" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">⚫️ <strong class="is hj">规则:</strong>如果任何线程进入等待状态，没有办法直接进入运行状态。</p><p id="b7ef" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">以便从等待状态进入就绪状态；</p><ol class=""><li id="1a4e" class="kz la hi is b it iu ix iy jb lb jf lc jj ld jn le lf lg lh bi translated">当线程2完成其任务时</li><li id="e977" class="kz la hi is b it lj ix lk jb ll jf lm jj ln jn le lf lg lh bi translated">当超时时</li><li id="4630" class="kz la hi is b it lj ix lk jb ll jf lm jj ln jn le lf lg lh bi translated">当被打断时</li></ol><p id="f32c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">让我们举一个例子。</p><figure class="ks kt ku kv fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lo"><img src="../Images/863dfcbc37aec2a9a63e352a0032076c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4rAh0xXSevXV5XX0a54Icw.png"/></div></div></figure><p id="96f4" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">问题:</strong></p><p id="1bb3" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">为什么我们不能使用5个线程，把时间缩短到11/5秒的❓</p><p id="2047" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">💠因为它们是依赖任务。</p><p id="abc4" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">💠可以并行做任务。为此，您可以使用两个不同的线程，将时间缩短到不到11秒。但是没有办法增加线程的数量，将进程减少到1秒或2秒。</p><p id="5f00" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">如何在Java ❓中创建线程</strong></p><p id="4a8d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">有两种方法。</p><ol class=""><li id="3917" class="kz la hi is b it iu ix iy jb lb jf lc jj ld jn le lf lg lh bi translated">扩展线程类</li><li id="8f73" class="kz la hi is b it lj ix lk jb ll jf lm jj ln jn le lf lg lh bi translated">实现可运行接口</li></ol><p id="5f4e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">🟣无论你如何创建一个线程，线程的行为和它做什么都不会改变。</p><h1 id="9f2d" class="jo jp hi bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated"><strong class="ak">扩展螺纹类</strong></h1><p id="595b" class="pw-post-body-paragraph iq ir hi is b it km iv iw ix kn iz ja jb ko jd je jf kp jh ji jj kq jl jm jn hb bi translated">让我们观察下图。</p><figure class="ks kt ku kv fd ij er es paragraph-image"><div class="er es lp"><img src="../Images/424e9153777fe58167db4692781ccf5e.png" data-original-src="https://miro.medium.com/v2/resize:fit:796/format:webp/1*TZqPlKy_Ze4-kwI2vBRXZA.png"/></div></figure><p id="1211" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如果你把Runner转换成一个线程(即扩展thread类)，就打破了这种关系。当扩展螺纹等级时，跑步者与运动员的关系将会破裂。这是因为Java不支持多重继承。</p><p id="e7ae" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">🔴没有什么叫做“扩展线程类比实现Runnable接口更好”。</p><p id="b11f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">与线程相关的场景</strong></p><pre class="ks kt ku kv fd lq lr ls lt aw lu bi"><span id="2256" class="lv jp hi lr b fi lw lx l ly lz"><strong class="lr hj">Scenario 1: Is it valid to override run() method when you extend thread class?</strong></span></pre><figure class="ks kt ku kv fd ij"><div class="bz dy l di"><div class="ma mb l"/></div></figure><p id="d40a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">当您调用run()方法时，它会检查Printer类中是否有run()方法。</p><figure class="ks kt ku kv fd ij"><div class="bz dy l di"><div class="ma mb l"/></div></figure><p id="e469" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">当您在Application.java中使用printer.start()方法时，它会在printer.start中检查printer类中是否有start()方法。因为什么都没有，所以它转到父类(线程类)</p><p id="4479" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在线程类中；</p><p id="05ff" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">🔹有一个start()方法。</p><p id="18e1" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">🔹在start()方法中，调用run()。</p><p id="ca69" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">输出:</strong></p><p id="def5" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">它将被执行，但什么也不会发生。</p><figure class="ks kt ku kv fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mc"><img src="../Images/ad39e1b0374db5a47817426cf3e075c8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NFNICgAinrsRD1kVex8oFA.png"/></div></div></figure><p id="3c8e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><em class="md">如果你实现一个Runnable接口，它会强制覆盖run()方法，因为这是一个实例的行为。如果实现任何接口，必须重写接口中的所有方法。</em></p><pre class="ks kt ku kv fd lq lr ls lt aw lu bi"><span id="ec62" class="lv jp hi lr b fi lw lx l ly lz"><strong class="lr hj">Scenario 2: Can we stay without overriding run() method when you implement multiple threads?</strong></span></pre><p id="7cf0" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">可以，但是有一个条件。</p><p id="4938" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">它必须来自“扩展线程”类(不是实现)</p><p id="13e9" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如果不覆盖run()方法，该线程将没有任何作业。所以，什么都不会发生。</p><pre class="ks kt ku kv fd lq lr ls lt aw lu bi"><span id="f0e9" class="lv jp hi lr b fi lw lx l ly lz"><strong class="lr hj">Scenario 3: Why do we have different orders in each executions when executing the below program many times?</strong></span></pre><figure class="ks kt ku kv fd ij"><div class="bz dy l di"><div class="ma mb l"/></div></figure><figure class="ks kt ku kv fd ij"><div class="bz dy l di"><div class="ma mb l"/></div></figure><p id="36bf" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><em class="md">在执行时，我们无法预测哪个线程(无论是主线程还是子线程)将首先执行，因为没有执行顺序的规则。当一个线程开始执行时，它会将你的线程添加到完全依赖于你的JRE (JVM)的线程调度器中。线程调度器决定哪个线程去。并且这个顺序从JVM到JVM是变化的。</em></p><pre class="ks kt ku kv fd lq lr ls lt aw lu bi"><span id="3726" class="lv jp hi lr b fi lw lx l ly lz"><strong class="lr hj">Scenario 4: What happens when you invoke run() method instead of start() method?</strong></span></pre><figure class="ks kt ku kv fd ij"><div class="bz dy l di"><div class="ma mb l"/></div></figure><figure class="ks kt ku kv fd ij"><div class="bz dy l di"><div class="ma mb l"/></div></figure><p id="2bb9" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">输出:</strong></p><p id="da46" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">它总是在执行main之前执行子类。</p><p id="73f5" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们只有一根线。(不是两个线程)</p><figure class="ks kt ku kv fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es me"><img src="../Images/34cd22766e5bd56d589630fc809d3a0c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_d-Lwta5v3pjPx6JSRxqvA.png"/></div></div></figure><p id="9163" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">问:为什么强制调用start()方法？</p><p id="26af" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">🟠让你的生活变得简单。</p><figure class="ks kt ku kv fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mf"><img src="../Images/0585561aecbe73b8d0cb8edd7626e6de.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5Gw7apJv1nwfNJDOJJSx8Q.png"/></div></div></figure><p id="b21c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">🟠当你调用start()方法时，JVM会完成上面提到的所有任务，并调用run()方法。</p><pre class="ks kt ku kv fd lq lr ls lt aw lu bi"><span id="343a" class="lv jp hi lr b fi lw lx l ly lz"><strong class="lr hj">Scenario 5: What happens when you override a start() method on your Thread class?</strong></span></pre><figure class="ks kt ku kv fd ij"><div class="bz dy l di"><div class="ma mb l"/></div></figure><p id="c4e3" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><em class="md"> printer.start()方法给出了即时类的机会。当我们调用main类中的start方法时，Printer类中的start()方法被执行。</em></p><p id="24ba" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><em class="md">当重写start方法时，您已经阻止了创建新线程的机会，因为您阻止了线程类调用start()方法。因此，它不会创建一个新线程，不会添加注册，不会做任何事情，所以它不会工作。</em></p><pre class="ks kt ku kv fd lq lr ls lt aw lu bi"><span id="0705" class="lv jp hi lr b fi lw lx l ly lz"><strong class="lr hj">Scenario 6: Can you overload main method?</strong></span></pre><p id="cec8" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><em class="md">是的，但是JVM总是考虑公共静态void main (String[] args)签名。</em></p><pre class="ks kt ku kv fd lq lr ls lt aw lu bi"><span id="338b" class="lv jp hi lr b fi lw lx l ly lz"><strong class="lr hj">Scenario 7: Can you override start() method and allow creating a thread?</strong></span></pre><figure class="ks kt ku kv fd ij"><div class="bz dy l di"><div class="ma mb l"/></div></figure><figure class="ks kt ku kv fd ij"><div class="bz dy l di"><div class="ma mb l"/></div></figure><p id="8fe4" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><em class="md">然后它创建了一个新线程。当您调用super.start()时，它会转到Thread类的start()方法的父类，它会创建一个线程并添加到池中。这一次，该线程立即开始执行。</em></p><figure class="ks kt ku kv fd ij er es paragraph-image"><div class="er es mg"><img src="../Images/8413fb1ef18ab3901f85c27ca5f35b21.png" data-original-src="https://miro.medium.com/v2/resize:fit:1010/format:webp/1*eKUAxtWrDNJCm76sAoxiUA.png"/></div></figure><figure class="ks kt ku kv fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mh"><img src="../Images/c042cfd1c17599f7b4558e78ed18fbe6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*eQlsvEPnxzG9xHpoGaGORA.png"/></div></div></figure><pre class="ks kt ku kv fd lq lr ls lt aw lu bi"><span id="ee67" class="lv jp hi lr b fi lw lx l ly lz"><strong class="lr hj">Scenario 8: What happens if you overload run() method?</strong></span></pre><p id="2361" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><em class="md">什么也不会发生，它会创建一个线程。但是线程类将总是不带参数地调用run()方法。</em></p><pre class="ks kt ku kv fd lq lr ls lt aw lu bi"><span id="8bcd" class="lv jp hi lr b fi lw lx l ly lz"><strong class="lr hj">Scenario 9: What happens if your main thread does more job than your child thread?</strong></span></pre><p id="37bd" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><em class="md">如果主线程离开main方法，不会终止java程序。即使主线程完成了它的工作，子线程也可以继续它的工作。</em></p><p id="2075" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如果要在主线程终止时终止子线程，必须将子线程设置为守护线程。</p><p id="f531" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj"> <em class="md">(。setDaemon(true)) </em> </strong></p><p id="0beb" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">只有当最后一个非守护线程终止时，程序才会终止。</p><h1 id="297e" class="jo jp hi bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated"><strong class="ak">实现可运行接口</strong></h1><p id="2cd4" class="pw-post-body-paragraph iq ir hi is b it km iv iw ix kn iz ja jb ko jd je jf kp jh ji jj kq jl jm jn hb bi translated">● Runnable是一个不包含任何实现方法的接口。</p><figure class="ks kt ku kv fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mi"><img src="../Images/b50e0295e8d0e7af1d0df12c2585922b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Yzfgl_vRc9OumqwoqmvTNg.png"/></div></div></figure><figure class="ks kt ku kv fd ij"><div class="bz dy l di"><div class="ma mb l"/></div></figure><p id="d583" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><em class="md">扩展一个线程类的时候，你的类扩展了线程类，线程实现了Runnable。我们有一个中间类叫做Thread。它从Runnable接口实现了所有有用的方法。</em></p><p id="61ce" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">当您从Thread类创建一个对象时，您可以为它传递Runnable实例。</p><p id="0b7d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在下面的代码片段中，我们创建了一个线程类实例，并从Runnable接口传递我们的实例。那意味着，我们通过打印机实例。</p><figure class="ks kt ku kv fd ij"><div class="bz dy l di"><div class="ma mb l"/></div></figure><figure class="ks kt ku kv fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mj"><img src="../Images/c0e139af1cbdd69d17cdfd6a71106314.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8ZxoD8muQTRVxJih4vBJfA.png"/></div></div></figure><figure class="ks kt ku kv fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mk"><img src="../Images/1ab76758677af7281a3b0df0c658df15.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uWzf1esEs05cI-t7crULTQ.png"/></div></div></figure><h1 id="7f5b" class="jo jp hi bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated"><strong class="ak">线程优先级</strong></h1><p id="62e5" class="pw-post-body-paragraph iq ir hi is b it km iv iw ix kn iz ja jb ko jd je jf kp jh ji jj kq jl jm jn hb bi translated">🔸线程优先级不是一个索引，而是一个值。</p><p id="e997" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">🔸线程优先级范围从1到10。</p><p id="f245" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">最高优先级➞ 10</p><p id="3e40" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">最低优先级➞ 1</p><p id="2231" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">🔸在任何应用程序中，主线程的默认优先级是5。此后，您创建的任何线程都将继承父线程的值。</p><p id="9090" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">🔸没有这样的规则，线程优先级总是为5。</p><p id="92f8" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">示例:</p><p id="ce56" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如果主线程创建t1，t1继承主线程的优先级。然后你可以改变t1的优先级。</p><p id="4e36" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">考虑主线程的线程优先级是5。然后你创建了t1，所以现在t1的优先级变成了5。然后将t1的优先级设置为7。如果你用t1线程创建t2，t2将继承t1线程的优先级。</p><pre class="ks kt ku kv fd lq lr ls lt aw lu bi"><span id="92f9" class="lv jp hi lr b fi lw lx l ly lz"><strong class="lr hj">What happens if you set a priority beyond 1-10?</strong></span></pre><p id="5133" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><em class="md">它会抛出一个非法参数异常，因为你设置的东西超出了线程优先级的限制。</em></p><pre class="ks kt ku kv fd lq lr ls lt aw lu bi"><span id="2469" class="lv jp hi lr b fi lw lx l ly lz"><strong class="lr hj">What happens if two threads carry the same priority?</strong></span></pre><p id="a9d1" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">不会发生什么重大的事情。<em class="md">线程调度器将选择一个线程运行，您无法预测。</em></p><h1 id="b03f" class="jo jp hi bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated"><span class="l ml mm mn bm mo mp mq mr ms di"> T </span> hread连接方法</h1><p id="0007" class="pw-post-body-paragraph iq ir hi is b it km iv iw ix kn iz ja jb ko jd je jf kp jh ji jj kq jl jm jn hb bi translated">它允许当前正在运行的线程停止执行，直到另一个线程完成它的任务。</p><p id="292c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">有3种不同的重载连接函数。</p><ol class=""><li id="4ae7" class="kz la hi is b it iu ix iy jb lb jf lc jj ld jn le lf lg lh bi translated">加入()</li><li id="1b26" class="kz la hi is b it lj ix lk jb ll jf lm jj ln jn le lf lg lh bi translated">加入(长距离)</li><li id="1130" class="kz la hi is b it lj ix lk jb ll jf lm jj ln jn le lf lg lh bi translated">join(长毫秒，整数纳米)</li></ol><p id="b5dc" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">✵如果时间没有提及，它永远等待。如果另一个线程在给定时间之前完成了它的工作，那么它可以继续。</p><h1 id="1d81" class="jo jp hi bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">螺纹屈服法</h1><p id="0784" class="pw-post-body-paragraph iq ir hi is b it km iv iw ix kn iz ja jb ko jd je jf kp jh ji jj kq jl jm jn hb bi translated">● Yield()方法可以用来调试或者改变/给某个特定线程更多的机会。</p><p id="d7ee" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">●使用yield()时，您无法使用多线程。</p><p id="a852" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">●如果有2个不同的线程，任何线程都可以调用yield()。调用yield()的那一刻，线程给线程调度器一个信号，把机会让给其他人。</p><p id="3052" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">● Yield()是原生方法。(未在Java中实现)</p><figure class="ks kt ku kv fd ij er es paragraph-image"><div class="er es mt"><img src="../Images/799a7e467a9f9e59a26d507b575a7f7e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1184/format:webp/1*cgSGR3RzWhY-xlvaDACEkA.png"/></div></figure><p id="66e0" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">✽ T1调用yield()方法。</p><p id="b27b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">✽无论是T2还是T3都会得到机会。</p><p id="3902" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">✽:如果t3得到了机会，不能保证当T3在特定时间段完成工作时，T1还会得到机会。很可能是T2。(这是因为T1又是线程调度器上的一个普通等待线程)</p><h1 id="3517" class="jo jp hi bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">线程睡眠方法</h1><p id="2953" class="pw-post-body-paragraph iq ir hi is b it km iv iw ix kn iz ja jb ko jd je jf kp jh ji jj kq jl jm jn hb bi translated">●它可以等待某个给定的时间。</p><p id="7e1a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">●有两种不同的方法签名(重载)</p><ol class=""><li id="a007" class="kz la hi is b it iu ix iy jb lb jf lc jj ld jn le lf lg lh bi translated">公共静态void sleep(长毫秒)抛出InterruptedException ➞本机方法</li></ol><p id="31fb" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">2.公共静态void sleep(long ms，int nanos)抛出InterruptedException ➞不是本机方法</p><p id="cebf" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">●在这个sleep()方法中，线程将进入等待状态一段时间，如果:</p><p id="1045" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">🟢等待时间已过</p><p id="200c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如果发生任何中断，🟢</p><figure class="ks kt ku kv fd ij er es paragraph-image"><div class="er es mu"><img src="../Images/9e3c2cf694d60a418005c25a5fe73643.png" data-original-src="https://miro.medium.com/v2/resize:fit:1324/format:webp/0*N7Lkw38svtRqhBTz.png"/></div></figure><h1 id="ecbd" class="jo jp hi bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">线程中断方法</h1><p id="6f6d" class="pw-post-body-paragraph iq ir hi is b it km iv iw ix kn iz ja jb ko jd je jf kp jh ji jj kq jl jm jn hb bi translated">●线程类的<strong class="is hj"> interrupt() </strong>方法用于中断线程。</p><p id="7cd1" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">●在你执行interrupt()方法的那一刻，无论什么处于等待状态的线程都会回来。</p><h1 id="bfde" class="jo jp hi bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">参考</h1><div class="mv mw ez fb mx my"><a href="https://www.geeksforgeeks.org/java-concurrency-yield-sleep-and-join-methods/" rel="noopener  ugc nofollow" target="_blank"><div class="mz ab dw"><div class="na ab nb cl cj nc"><h2 class="bd hj fi z dy nd ea eb ne ed ef hh bi translated">Java并发性——yield()、sleep()和join()方法——GeeksforGeeks</h2><div class="nf l"><h3 class="bd b fi z dy nd ea eb ne ed ef dx translated">Java Concurrency - yield()、sleep()和join()方法我们可以通过使用一个…</h3></div><div class="ng l"><p class="bd b fp z dy nd ea eb ne ed ef dx translated">www.geeksforgeeks.org</p></div></div><div class="nh l"><div class="ni l nj nk nl nh nm io my"/></div></div></a></div><div class="mv mw ez fb mx my"><a href="https://www.javatpoint.com/multithreading-in-java" rel="noopener  ugc nofollow" target="_blank"><div class="mz ab dw"><div class="na ab nb cl cj nc"><h2 class="bd hj fi z dy nd ea eb ne ed ef hh bi translated">Java中的多线程-Java point</h2><div class="nf l"><h3 class="bd b fi z dy nd ea eb ne ed ef dx translated">Java中的多线程是同时执行多个线程的过程。线程是一种轻量级的…</h3></div><div class="ng l"><p class="bd b fp z dy nd ea eb ne ed ef dx translated">www.javatpoint.com</p></div></div><div class="nh l"><div class="nn l nj nk nl nh nm io my"/></div></div></a></div><div class="mv mw ez fb mx my"><a href="https://images.app.goo.gl/Y9JY758A8D5e9cD38" rel="noopener  ugc nofollow" target="_blank"><div class="mz ab dw"><div class="na ab nb cl cj nc"><h2 class="bd hj fi z dy nd ea eb ne ed ef hh bi translated">https://bimales.files.wordpress.com/2014/07/af869-wait.png的谷歌图片搜索结果</h2><div class="nf l"><h3 class="bd b fi z dy nd ea eb ne ed ef dx translated">编辑描述</h3></div><div class="ng l"><p class="bd b fp z dy nd ea eb ne ed ef dx translated">images.app.goo.gl</p></div></div><div class="nh l"><div class="no l nj nk nl nh nm io my"/></div></div></a></div><figure class="ks kt ku kv fd ij"><div class="bz dy l di"><div class="np mb l"/></div></figure></div></div>    
</body>
</html>