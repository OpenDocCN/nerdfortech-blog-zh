<html>
<head>
<title>What Is A Partition In Oracle?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Oracle中的分区是什么？</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/what-is-a-partition-in-oracle-29f4d6dc5c2a?source=collection_archive---------2-----------------------#2022-05-09">https://medium.com/nerd-for-tech/what-is-a-partition-in-oracle-29f4d6dc5c2a?source=collection_archive---------2-----------------------#2022-05-09</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="f0c7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在这里，我们将了解oracle中的分区概念</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es jd"><img src="../Images/7ddc4d412d1017fe7c606544ee4082c7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fD-VU2_NxRfZAe75ZUjqcA.png"/></div></div><figcaption class="jp jq et er es jr js bd b be z dx translated">oracle中的表分区</figcaption></figure><p id="d4a6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">什么是隔断？</strong></p><ul class=""><li id="78c1" class="jt ju hi ih b ii ij im in iq jv iu jw iy jx jc jy jz ka kb bi translated">当我们运行查询时，oracle将检查查询结果是否已经存在于结果缓存中。</li><li id="5a6b" class="jt ju hi ih b ii kc im kd iq ke iu kf iy kg jc jy jz ka kb bi translated">如果它不存在，那么是时候从内存中获取了。</li><li id="f3ac" class="jt ju hi ih b ii kc im kd iq ke iu kf iy kg jc jy jz ka kb bi translated">此外，它需要一个适当的执行计划。</li><li id="ac26" class="jt ju hi ih b ii kc im kd iq ke iu kf iy kg jc jy jz ka kb bi translated">首先，它检查共享SQL区域是否有类似的执行计划。</li><li id="5c69" class="jt ju hi ih b ii kc im kd iq ke iu kf iy kg jc jy jz ka kb bi translated">如果没有，它将创建一个新的执行计划。</li><li id="f3bf" class="jt ju hi ih b ii kc im kd iq ke iu kf iy kg jc jy jz ka kb bi translated">因为我们现在有了执行计划，所以它首先检查缓冲区缓存是否有与该查询相关的数据。</li><li id="b294" class="jt ju hi ih b ii kc im kd iq ke iu kf iy kg jc jy jz ka kb bi translated">如果没有，就该去光盘了。</li><li id="9d7d" class="jt ju hi ih b ii kc im kd iq ke iu kf iy kg jc jy jz ka kb bi translated">我们知道，我们的表数据存储在“块”中。当服务器转到光盘时</li><li id="629f" class="jt ju hi ih b ii kc im kd iq ke iu kf iy kg jc jy jz ka kb bi translated">它有许多不同的读取光盘的方法。</li><li id="592b" class="jt ju hi ih b ii kc im kd iq ke iu kf iy kg jc jy jz ka kb bi translated">大多数时候，它会读取一个表的所有块来查找一些数据。</li><li id="af62" class="jt ju hi ih b ii kc im kd iq ke iu kf iy kg jc jy jz ka kb bi translated">如果表很大，这个操作的执行成本会很高。</li></ul><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es kh"><img src="../Images/ef463dd8223563919852201505cd73a2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bKwE1B97qsl51JV1-ZBr1A.png"/></div></div><figcaption class="jp jq et er es jr js bd b be z dx translated">Oracle架构图</figcaption></figure><ul class=""><li id="b799" class="jt ju hi ih b ii ij im in iq jv iu jw iy jx jc jy jz ka kb bi translated">即使您为此创建了索引，有时这也不起作用。因为，您可能知道，索引是通过它们的rowids转到行的。</li><li id="db8c" class="jt ju hi ih b ii kc im kd iq ke iu kf iy kg jc jy jz ka kb bi translated">当您搜索某个范围的数据时，索引将不会如此有效。因为数据将位于许多不同的块中，并且对于每个块和行，服务器将搜索每行的索引并转到不同的块。</li><li id="505a" class="jt ju hi ih b ii kc im kd iq ke iu kf iy kg jc jy jz ka kb bi translated">因此，这将是一个代价高昂的操作，数据库服务器不会这样做。</li><li id="fe0f" class="jt ju hi ih b ii kc im kd iq ke iu kf iy kg jc jy jz ka kb bi translated">例如，如果您在employee表的hire_date列中有一个索引，并且如果您搜索一个单一的hire_date，它将很好地与索引一起工作。</li><li id="f037" class="jt ju hi ih b ii kc im kd iq ke iu kf iy kg jc jy jz ka kb bi translated">但是，如果您查询在某个日期范围内雇用的员工，它将不起作用。相反，它会读取所有的表，然后按日期过滤。</li><li id="50e0" class="jt ju hi ih b ii kc im kd iq ke iu kf iy kg jc jy jz ka kb bi translated">如果您的表非常大，您可能会在几分钟内得到这个结果，也可能需要几个小时。</li></ul><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es ki"><img src="../Images/2ab2c2e2117e0591931aa055e387b5f8.png" data-original-src="https://miro.medium.com/v2/resize:fit:998/format:webp/1*nQm0C-FG1Ge_28mTIi-bLA.png"/></div><figcaption class="jp jq et er es jr js bd b be z dx translated">表分区来源:google</figcaption></figure><ul class=""><li id="0104" class="jt ju hi ih b ii ij im in iq jv iu jw iy jx jc jy jz ka kb bi translated">Oracle发布了一个名为“<strong class="ih hj">表分区</strong>的特性。分区意味着在物理上将一个表划分成更小的表。</li><li id="cce7" class="jt ju hi ih b ii kc im kd iq ke iu kf iy kg jc jy jz ka kb bi translated">例如，在我提到的查询中，我们可以根据hire_date列将表划分成更小的分区。例如，我们可以说，为2018年第一天之前的日期创建一个分区，然后为2019年之前的日期创建一个分区，如果您愿意，您可以创建更多分区。</li><li id="b85a" class="jt ju hi ih b ii kc im kd iq ke iu kf iy kg jc jy jz ka kb bi translated">您可以创建任意多的分区。</li><li id="89ad" class="jt ju hi ih b ii kc im kd iq ke iu kf iy kg jc jy jz ka kb bi translated">因此，当您插入一行时，例如，如果插入行中的雇用日期低于2018年</li><li id="7d1d" class="jt ju hi ih b ii kc im kd iq ke iu kf iy kg jc jy jz ka kb bi translated">它被插入到相关的分区中。</li><li id="619d" class="jt ju hi ih b ii kc im kd iq ke iu kf iy kg jc jy jz ka kb bi translated">如果hire_date在2018年以上2019年以下，那么它也会被插入到相关的分区中，这样继续下去。</li><li id="95c3" class="jt ju hi ih b ii kc im kd iq ke iu kf iy kg jc jy jz ka kb bi translated">因此，我们将把相关数据物理分组到子表中。但是你可以看到并触及这些分区</li></ul><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es kj"><img src="../Images/c403342f917b13f9b7230a126b318616.png" data-original-src="https://miro.medium.com/v2/resize:fit:1172/format:webp/1*4SmZZpVfpv8GaHFLQxzzCw.png"/></div></figure><p id="43c4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">分区对性能有什么影响？</strong></p><ul class=""><li id="23a7" class="jt ju hi ih b ii ij im in iq jv iu jw iy jx jc jy jz ka kb bi translated">当我们在一个表上运行查询时，如果我们的查询搜索存储在一个分区中的重要数据，服务器将不会搜索该表的所有数据。</li><li id="7d1f" class="jt ju hi ih b ii kc im kd iq ke iu kf iy kg jc jy jz ka kb bi translated">相反，它将只从一个分区读取。</li><li id="f92b" class="jt ju hi ih b ii kc im kd iq ke iu kf iy kg jc jy jz ka kb bi translated">假设，如果您的表有100个分区，而您的查询结果只有一个分区，那么您将获得比普通表读取快100倍的速度。</li><li id="0611" class="jt ju hi ih b ii kc im kd iq ke iu kf iy kg jc jy jz ka kb bi translated">因此，如果您的表很大，您需要根据最常用的过滤器将它们划分成分区。</li></ul><p id="08ab" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Oracle支持多种分区方法:</p><ul class=""><li id="1113" class="jt ju hi ih b ii ij im in iq jv iu jw iy jx jc jy jz ka kb bi translated"><strong class="ih hj">范围划分</strong> —数据基于值的范围分布。</li><li id="760c" class="jt ju hi ih b ii kc im kd iq ke iu kf iy kg jc jy jz ka kb bi translated"><strong class="ih hj">列表分区</strong>数据分布由离散的值列表定义。一列或多列可以用作分区键。</li><li id="d2ca" class="jt ju hi ih b ii kc im kd iq ke iu kf iy kg jc jy jz ka kb bi translated"><strong class="ih hj">自动列表分区</strong> —通过为任何新的分区键值自动定义新的分区来扩展列表方法的功能。</li><li id="613d" class="jt ju hi ih b ii kc im kd iq ke iu kf iy kg jc jy jz ka kb bi translated"><strong class="ih hj">哈希分区</strong> —对分区键应用内部哈希算法来确定分区。</li><li id="9fec" class="jt ju hi ih b ii kc im kd iq ke iu kf iy kg jc jy jz ka kb bi translated"><strong class="ih hj">复合分区</strong> —使用两种数据分布方法的组合。首先，通过数据分布方法一对表进行分区，然后使用第二种数据分布方法将每个分区进一步细分为子分区。</li><li id="59a7" class="jt ju hi ih b ii kc im kd iq ke iu kf iy kg jc jy jz ka kb bi translated"><strong class="ih hj">多列范围分区</strong> —当分区键由几列组成时的一个选项，后续列定义了比前几列更高的粒度级别。</li><li id="c984" class="jt ju hi ih b ii kc im kd iq ke iu kf iy kg jc jy jz ka kb bi translated"><strong class="ih hj">区间分区</strong> —通过使用区间定义作为表元数据的一部分，为任何未来分区自动定义均分范围，扩展了范围方法的功能。</li><li id="abc8" class="jt ju hi ih b ii kc im kd iq ke iu kf iy kg jc jy jz ka kb bi translated"><strong class="ih hj">引用分区分区</strong> —利用现有父子关系的表。主键关系用于将父表的分区策略继承到其子表。</li><li id="290b" class="jt ju hi ih b ii kc im kd iq ke iu kf iy kg jc jy jz ka kb bi translated"><strong class="ih hj">基于虚拟列的分区</strong> —允许分区键是一个表达式，使用表中的一个或多个现有列，并将该表达式仅存储为元数据。</li><li id="940d" class="jt ju hi ih b ii kc im kd iq ke iu kf iy kg jc jy jz ka kb bi translated"><strong class="ih hj">区间引用分区</strong> —引用分区的扩展，允许使用区间分区表作为引用分区的父表。</li></ul><p id="6c02" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">结论:</strong></p><ul class=""><li id="f8bc" class="jt ju hi ih b ii ij im in iq jv iu jw iy jx jc jy jz ka kb bi translated">对于分区，我们可以做的是，如果我们的表很大，并且有一个通用的过滤器，这意味着我们需要为特定的表或索引创建分区。</li><li id="5e70" class="jt ju hi ih b ii kc im kd iq ke iu kf iy kg jc jy jz ka kb bi translated">这将大大提高性能。好吧。</li><li id="b16b" class="jt ju hi ih b ii kc im kd iq ke iu kf iy kg jc jy jz ka kb bi translated"><strong class="ih hj">通过只处理相关数据来提高性能</strong>。</li><li id="17a4" class="jt ju hi ih b ii kc im kd iq ke iu kf iy kg jc jy jz ka kb bi translated"><strong class="ih hj">通过独立分区的可管理性提高可用性</strong>。</li><li id="1d4a" class="jt ju hi ih b ii kc im kd iq ke iu kf iy kg jc jy jz ka kb bi translated"><strong class="ih hj">通过适当存储数据降低成本</strong>。</li><li id="8e2e" class="jt ju hi ih b ii kc im kd iq ke iu kf iy kg jc jy jz ka kb bi translated">实现很容易，因为它不需要改变应用程序和查询。</li></ul></div></div>    
</body>
</html>