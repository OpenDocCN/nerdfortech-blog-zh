<html>
<head>
<title>How to securely implement OAuth in Ruby on Rails</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在Ruby on Rails中安全地实现OAuth</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/how-to-securely-implement-oauth-in-ruby-on-rails-2b9546994132?source=collection_archive---------6-----------------------#2021-02-19">https://medium.com/nerd-for-tech/how-to-securely-implement-oauth-in-ruby-on-rails-2b9546994132?source=collection_archive---------6-----------------------#2021-02-19</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="1ef2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在本教程中，我们将逐步设置一个基本的Ruby on Rails应用程序，使用授权码grant安全地向OAuth2服务器进行身份验证。</p><p id="8a00" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">许多Rails应用程序传统上在框架本身中处理身份验证、授权和用户管理。有许多策略可以实现，包括使用像<a class="ae jd" href="https://github.com/heartcombo/devise" rel="noopener ugc nofollow" target="_blank">device</a>这样的便捷工具。然而，使用FusionAuth，我们能够<a class="ae jd" href="https://en.wikipedia.org/wiki/Separation_of_concerns" rel="noopener ugc nofollow" target="_blank">将我们的认证关注点</a>从我们的应用程序中分离出来。现在，我们可以独立于我们的主应用程序来扩展我们的用户群。当我们构建新的应用程序或与其他平台集成时，我们现在有一个集中的地方来处理我们的身份验证和授权需求。</p><p id="beda" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这有什么关系？假设我的公司已经有一个现有的身份提供者，我需要将我的新应用程序与它集成。也许我有许多应用程序需要与我的身份提供者集成。也许我是一家初创公司，想卸载所有用户管理，包括功能和安全问题。通过在一个地方处理我们所有的用户管理问题，我们可以独立地关注应用程序的需求。</p><p id="ef32" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">借助FusionAuth这样的客户身份和访问管理平台，我们获得了完整身份解决方案的优势，能够满足SSO、MFA和社交登录等大多数身份认证要求。</p><p id="3b91" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在本教程结束时，您将拥有一个运行中的Ruby on Rails应用程序，该应用程序利用FusionAuth对用户进行身份验证，完成了<a class="ae jd" href="https://oauth.net/2/grant-types/authorization-code/" rel="noopener ugc nofollow" target="_blank"> OAuth 2.0授权代码</a>流程。</p><p id="da38" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">该代码可以在Github 的Apache2许可<a class="ae jd" href="https://github.com/FusionAuth/fusionauth-example-rails-oauth" rel="noopener ugc nofollow" target="_blank">下获得。</a></p><p id="8aa1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在<a class="ae jd" href="https://fusionauth.io/blog/2020/06/11/building-protected-api-with-rails-and-jwt/" rel="noopener ugc nofollow" target="_blank">之前的帖子</a>中，我们演示了如何编码、解码和验证JWT的真实性，以<a class="ae jd" href="https://fusionauth.io/blog/2020/06/11/building-protected-api-with-rails-and-jwt/" rel="noopener ugc nofollow" target="_blank">保护Ruby on Rails API </a>。在本文中，我们将利用那些相同的概念，FusionAuth是发布令牌的身份验证提供者。</p><h1 id="c262" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">先决条件</h1><ul class=""><li id="e0a2" class="kc kd hi ih b ii ke im kf iq kg iu kh iy ki jc kj kk kl km bi translated">轨道6</li><li id="7f47" class="kc kd hi ih b ii kn im ko iq kp iu kq iy kr jc kj kk kl km bi translated">Docker(可选，但安装FusionAuth时首选)</li></ul><h1 id="1fc4" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">设置融合验证</h1><p id="064d" class="pw-post-body-paragraph if ig hi ih b ii ke ik il im kf io ip iq ks is it iu kt iw ix iy ku ja jb jc hb bi translated">在本教程中，我们将使用Docker进行快速设置:</p><pre class="kv kw kx ky fd kz la lb lc aw ld bi"><span id="37b1" class="le jf hi la b fi lf lg l lh li">curl -o docker-compose.yml https://raw.githubusercontent.com/FusionAuth/fusionauth-containers/master/docker/fusionauth/docker-compose.yml<br/>curl -o .env https://raw.githubusercontent.com/FusionAuth/fusionauth-containers/master/docker/fusionauth/.env<br/>docker-compose up</span></pre><p id="8450" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果您更喜欢在本地安装FusionAuth，请参见<a class="ae jd" href="https://fusionauth.io/docs/v1/tech/5-minute-setup-guide/" rel="noopener ugc nofollow" target="_blank"> 5分钟安装指南</a>进行安装和运行。</p><p id="5077" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">一旦你安装了FusionAuth，它应该运行在<a class="ae jd" href="http://localhost:9011/" rel="noopener ugc nofollow" target="_blank"> localhost:9011 </a>。导航到那里并完成设置步骤。完成这些操作后，以刚刚创建的管理员身份登录。现在我们准备好摇滚了！</p><p id="6232" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">一个FusionAuth应用程序只是用户可以登录的东西。因此，我们希望在FusionAuth中为我们的Rails应用程序创建一个新的应用程序。</p><h1 id="0616" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">创建应用程序</h1><p id="d52f" class="pw-post-body-paragraph if ig hi ih b ii ke ik il im kf io ip iq ks is it iu kt iw ix iy ku ja jb jc hb bi translated">从左侧导航栏中选择“应用程序”。然后单击右上角的绿色加号添加一个新应用程序。我们需要配置一些重要信息:</p><ul class=""><li id="50d9" class="kc kd hi ih b ii ij im in iq lj iu lk iy ll jc kj kk kl km bi translated"><strong class="ih hj"> Name </strong>(必需):我们的应用程序的显示名称。输入<code class="du lm ln lo la b">fusionauth-rails-app</code>。</li><li id="749a" class="kc kd hi ih b ii kn im ko iq kp iu kq iy kr jc kj kk kl km bi translated"><strong class="ih hj">授权重定向URL</strong>:在“OAuth”标签下找到。这个URL告诉FusionAuth在用户成功认证后重定向到哪里。</li><li id="a154" class="kc kd hi ih b ii kn im ko iq kp iu kq iy kr jc kj kk kl km bi translated"><strong class="ih hj">注销URL </strong>:也可以在“OAuth”选项卡下找到。这个URL告诉FusionAuth当用户注销时重定向到哪里。</li></ul><figure class="kv kw kx ky fd lq er es paragraph-image"><div role="button" tabindex="0" class="lr ls di lt bf lu"><div class="er es lp"><img src="../Images/b19c2ffee0bf4866fecb5927100bd815.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*gmWmzZxPXoH77aTb.png"/></div></div></figure><p id="4225" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这个应用程序是在默认租户中创建的。FusionAuth支持无限的租户，但是对于这个示例应用程序，我们可以将所有内容都保留在默认应用程序中。</p><h1 id="65ba" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">创建用户</h1><p id="955c" class="pw-post-body-paragraph if ig hi ih b ii ke ik il im kf io ip iq ks is it iu kt iw ix iy ku ja jb jc hb bi translated">对于本例，我们将手动创建一个用户。单击左侧导航栏中的“Users ”,然后单击右上角的绿色加号添加新用户。</p><figure class="kv kw kx ky fd lq er es paragraph-image"><div role="button" tabindex="0" class="lr ls di lt bf lu"><div class="er es lp"><img src="../Images/f28191d2b4c68955eaf5ee939e2618ba.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*ett_bKyFVDAs-hNZ.png"/></div></div></figure><p id="a509" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">配置以下属性，然后保存新用户:</p><ul class=""><li id="7961" class="kc kd hi ih b ii ij im in iq lj iu lk iy ll jc kj kk kl km bi translated"><strong class="ih hj">电子邮件</strong></li><li id="17d1" class="kc kd hi ih b ii kn im ko iq kp iu kq iy kr jc kj kk kl km bi translated"><strong class="ih hj">密码并确认</strong>:将“向设置密码发送电子邮件”切换为关闭，手动输入用户密码。</li></ul><h1 id="5591" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">注册用户</h1><p id="d3a7" class="pw-post-body-paragraph if ig hi ih b ii ke ik il im kf io ip iq ks is it iu kt iw ix iy ku ja jb jc hb bi translated">看起来不错！现在我们有了新的应用程序和用户。我们要做的最后一件事是向我们的应用程序注册用户。为我们新创建的用户导航到“用户-&gt;管理”。</p><p id="3413" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">单击“添加注册”按钮，选择我们创建的Rails应用程序，然后单击“保存”按钮。</p><figure class="kv kw kx ky fd lq er es paragraph-image"><div role="button" tabindex="0" class="lr ls di lt bf lu"><div class="er es lp"><img src="../Images/fe83ee1ef3ddc968605fb5863d03320c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*me3qC7vqacUDTvbf.png"/></div></div></figure><h1 id="ca26" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">颁发者和签名密钥</h1><p id="14b2" class="pw-post-body-paragraph if ig hi ih b ii ke ik il im kf io ip iq ks is it iu kt iw ix iy ku ja jb jc hb bi translated">我们还想在FusionAuth中配置两个属性。第一个属性是用于签名令牌的命名颁发者值。我们将在登录期间验证访问令牌时使用该值。为此，导航到左侧导航栏上的“租户”，然后单击与“默认”租户对应的“编辑”按钮。在“常规”选项卡下设置“发行人”字段。颁发者的值通常是身份提供者的主机名。由于这是一个演示，我们将使用值<code class="du lm ln lo la b">fusionauth.io</code>。</p><figure class="kv kw kx ky fd lq er es paragraph-image"><div role="button" tabindex="0" class="lr ls di lt bf lu"><div class="er es lp"><img src="../Images/4b8f13680585688869fff767091bcb69.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*T-wdJ0lqpZ7pn2Q7.png"/></div></div></figure><p id="16a6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">第二个属性是用于编码令牌的HMAC签名密钥。从左侧导航栏导航至“设置”，然后导航至“万能钥匙”。然后点击与<code class="du lm ln lo la b">Default Signing Key</code>相对应的“查看”按钮。从这里，“点击显示”密钥，并将其复制到一个安全的位置。我们将需要这个值来成功解码我们的应用程序中的令牌。</p><figure class="kv kw kx ky fd lq er es paragraph-image"><div role="button" tabindex="0" class="lr ls di lt bf lu"><div class="er es lp"><img src="../Images/dc9fff9d1028a9df3c3a60a62d905d80.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*MennGm2xSWyAOX-2.png"/></div></div></figure><h1 id="cf13" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">构建Rails应用程序</h1><p id="5071" class="pw-post-body-paragraph if ig hi ih b ii ke ik il im kf io ip iq ks is it iu kt iw ix iy ku ja jb jc hb bi translated">让我们开始构建一个非常基本的Rails应用程序来演示使用FusionAuth的身份验证。如果你想直接查看代码，请点击这里查看我们的Github repo <a class="ae jd" href="https://github.com/FusionAuth/fusionauth-example-rails-oauth" rel="noopener ugc nofollow" target="_blank">。</a></p><p id="9071" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">创建新的Rails应用程序。</p><pre class="kv kw kx ky fd kz la lb lc aw ld bi"><span id="a59e" class="le jf hi la b fi lf lg l lh li">rails new rails-fusionauth-app</span></pre><p id="3a9f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们的<code class="du lm ln lo la b">Gemfile</code>将使用一些额外的依赖项，所以在我们开始之前继续添加它们。</p><pre class="kv kw kx ky fd kz la lb lc aw ld bi"><span id="6d0c" class="le jf hi la b fi lf lg l lh li">gem 'jwt'<br/>gem 'oauth2'</span></pre><p id="cf5c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">安装我们的依赖</p><pre class="kv kw kx ky fd kz la lb lc aw ld bi"><span id="fbb6" class="le jf hi la b fi lf lg l lh li">bundle install</span></pre><h1 id="0709" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">配置</h1><p id="3ece" class="pw-post-body-paragraph if ig hi ih b ii ke ik il im kf io ip iq ks is it iu kt iw ix iy ku ja jb jc hb bi translated">在我们继续之前，我们需要FusionAuth配置中的一些关键应用程序属性，以便我们的Rails应用程序知道如何成功地与它通信。具体来说:</p><ul class=""><li id="f746" class="kc kd hi ih b ii ij im in iq lj iu lk iy ll jc kj kk kl km bi translated"><strong class="ih hj">客户端Id </strong></li><li id="4b57" class="kc kd hi ih b ii kn im ko iq kp iu kq iy kr jc kj kk kl km bi translated"><strong class="ih hj">客户机密</strong></li><li id="f0b6" class="kc kd hi ih b ii kn im ko iq kp iu kq iy kr jc kj kk kl km bi translated"><strong class="ih hj">授权重定向网址</strong></li><li id="c43c" class="kc kd hi ih b ii kn im ko iq kp iu kq iy kr jc kj kk kl km bi translated"><strong class="ih hj">注销网址</strong></li></ul><p id="c84d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">您可以回忆一下，在FusionAuth中修改应用程序时，可以在“OAuth”选项卡下找到这些。</p><figure class="kv kw kx ky fd lq er es paragraph-image"><div role="button" tabindex="0" class="lr ls di lt bf lu"><div class="er es lp"><img src="../Images/dd5dda367ffee497258505fb13044ebe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*jWFwHogh132yTTi_.png"/></div></div></figure><p id="3b0f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们使用<code class="du lm ln lo la b">development.rb</code>设置<code class="du lm ln lo la b">client_id</code>、<code class="du lm ln lo la b">client_secret</code>、<code class="du lm ln lo la b">idp_url</code>(身份提供者url)和<code class="du lm ln lo la b">redirect_uri</code>值。我选择在这里设置这些值，因为它们可能会在试运行或生产环境中发生变化，但是您可以根据自己的标准随意设置。我们还将初始化一个包含“HMAC秘密”的环境变量，该变量将用于解码在身份验证过程中收到的令牌。我们希望尽可能地保证它的安全，因此我们将在运行时设置它。</p><pre class="kv kw kx ky fd kz la lb lc aw ld bi"><span id="f7c9" class="le jf hi la b fi lf lg l lh li"># OAuth configuration<br/>  config.x.oauth.client_id = "my-client-id"<br/>  config.x.oauth.client_secret = "my-super-secret-oauth-secret"<br/>  config.x.oauth.idp_url = "http://localhost:9011/"<br/>  config.x.oauth.redirect_uri = "http://localhost:3000/oauth2-callback"<br/>  config.x.oauth.hmac = ENV['HMAC_SECRET']</span></pre><h1 id="3944" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">使用FusionAuth认证</h1><p id="fa0d" class="pw-post-body-paragraph if ig hi ih b ii ke ik il im kf io ip iq ks is it iu kt iw ix iy ku ja jb jc hb bi translated">在我们进入代码之前，让我们看一下应用于我们的Rails应用程序、用户和FusionAuth的认证码授权流:</p><figure class="kv kw kx ky fd lq er es paragraph-image"><div role="button" tabindex="0" class="lr ls di lt bf lu"><div class="er es lx"><img src="../Images/f98feca3fa8a7046f8cc27d0d4e79548.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*IYvP-9puNzoBZA-A.png"/></div></div></figure><p id="9174" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这让我们能够深入了解需要在Rails应用程序中定义的路线。</p><h1 id="c132" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">路线</h1><p id="3efc" class="pw-post-body-paragraph if ig hi ih b ii ke ik il im kf io ip iq ks is it iu kt iw ix iy ku ja jb jc hb bi translated">对于此应用程序，我们将设置四条路线:</p><ul class=""><li id="1733" class="kc kd hi ih b ii ij im in iq lj iu lk iy ll jc kj kk kl km bi translated"><strong class="ih hj">欢迎页面</strong>:我们的根页面。</li><li id="58e7" class="kc kd hi ih b ii kn im ko iq kp iu kq iy kr jc kj kk kl km bi translated"><strong class="ih hj">登录端点</strong>:当用户点击登录链接时，请求FusionAuth登录页面。</li><li id="e85f" class="kc kd hi ih b ii kn im ko iq kp iu kq iy kr jc kj kk kl km bi translated"><strong class="ih hj"> OAuth回调端点</strong>:授权码授予时FusionAuth重定向的接收方。</li><li id="041c" class="kc kd hi ih b ii kn im ko iq kp iu kq iy kr jc kj kk kl km bi translated"><strong class="ih hj">注销端点</strong>:成功注销时FusionAuth重定向的接收者。</li></ul><pre class="kv kw kx ky fd kz la lb lc aw ld bi"><span id="780a" class="le jf hi la b fi lf lg l lh li">Rails.application.routes.draw do<br/>   root to: 'welcome#index'<br/>   get '/oauth2-callback', to: 'oauth#oauth_callback'<br/>   get '/logout', to: 'oauth#logout'<br/>   get '/login', to: 'oauth#login'<br/> end</span></pre><h2 id="bbf8" class="le jf hi bd jg ly lz ma jk mb mc md jo iq me mf js iu mg mh jw iy mi mj ka mk bi translated">欢迎页面</h2><p id="113f" class="pw-post-body-paragraph if ig hi ih b ii ke ik il im kf io ip iq ks is it iu kt iw ix iy ku ja jb jc hb bi translated">让我们从一个非常基本的欢迎视图开始，它包含一个用户登录应用程序的链接。这个页面将作为我们应用程序的根页面。</p><pre class="kv kw kx ky fd kz la lb lc aw ld bi"><span id="a2e9" class="le jf hi la b fi lf lg l lh li"># app/views/welcome/index.html.erb</span><span id="0327" class="le jf hi la b fi ml lg l lh li">&lt;p&gt;Welcome! Please &lt;%= link_to 'sign in', controller: 'o_auth', action: :login %&gt; &lt;/p&gt;</span></pre><p id="f2d6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">渲染时应该是这样的。</p><figure class="kv kw kx ky fd lq er es paragraph-image"><div role="button" tabindex="0" class="lr ls di lt bf lu"><div class="er es lp"><img src="../Images/ad25709c1c04d22ff4c3523e4c95dba1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*QhNyW2C24ZIB44qx.png"/></div></div></figure><h2 id="c682" class="le jf hi bd jg ly lz ma jk mb mc md jo iq me mf js iu mg mh jw iy mi mj ka mk bi translated">OAuthController</h2><p id="3fab" class="pw-post-body-paragraph if ig hi ih b ii ke ik il im kf io ip iq ks is it iu kt iw ix iy ku ja jb jc hb bi translated">“OAuthController”将处理完成授权码授权流所需的每个剩余路由。这是我们完成后的样子:</p><pre class="kv kw kx ky fd kz la lb lc aw ld bi"><span id="2fcb" class="le jf hi la b fi lf lg l lh li">class OAuthController &lt; ApplicationController<br/>  def initialize<br/>    @oauth_client = OAuth2::Client.new(Rails.configuration.x.oauth.client_id,<br/>                                       Rails.configuration.x.oauth.client_secret,<br/>                                       authorize_url: '/oauth2/authorize',<br/>                                       site: Rails.configuration.x.oauth.idp_url,<br/>                                       token_url: '/oauth2/token',<br/>                                       redirect_uri: Rails.configuration.x.oauth.redirect_uri)<br/>  end</span><span id="0aee" class="le jf hi la b fi ml lg l lh li">  # The OAuth callback<br/>  def oauth_callback<br/>    # Make a call to exchange the authorization_code for an access_token<br/>    response = @oauth_client.auth_code.get_token(params[:code])</span><span id="8259" class="le jf hi la b fi ml lg l lh li">    # Extract the access token from the response<br/>    token = response.to_hash[:access_token]</span><span id="afa0" class="le jf hi la b fi ml lg l lh li">    # Decode the token<br/>    begin<br/>      decoded = TokenDecoder.new(token, @oauth_client.id).decode<br/>    rescue Exception =&gt; error<br/>      "An unexpected exception occurred: #{error.inspect}"<br/>      head :forbidden<br/>      return<br/>    end</span><span id="09c3" class="le jf hi la b fi ml lg l lh li">    # Set the token on the user session<br/>    session[:user_jwt] = {value: decoded, httponly: true}</span><span id="91cc" class="le jf hi la b fi ml lg l lh li">    redirect_to root_path<br/>  end</span><span id="9ebf" class="le jf hi la b fi ml lg l lh li">  def logout<br/>    # Invalidate session with FusionAuth<br/>    @oauth_client.request(:get, 'oauth2/logout')</span><span id="b750" class="le jf hi la b fi ml lg l lh li">    # Reset Rails session<br/>    reset_session</span><span id="3c27" class="le jf hi la b fi ml lg l lh li">    redirect_to root_path<br/>  end</span><span id="a397" class="le jf hi la b fi ml lg l lh li">  def login<br/>    redirect_to @oauth_client.auth_code.authorize_url<br/>  end<br/>end</span></pre><p id="409d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">首先，我们将使用<a class="ae jd" href="https://github.com/oauth-xx/oauth2" rel="noopener ugc nofollow" target="_blank"> oauth2 </a> gem设置我们的客户端。这为我们提供了OAuth 2.0规范的<a class="ae jd" href="https://www.codecademy.com/articles/what-is-rest" rel="noopener ugc nofollow" target="_blank"> REST </a>客户端包装器。</p><pre class="kv kw kx ky fd kz la lb lc aw ld bi"><span id="da6b" class="le jf hi la b fi lf lg l lh li"># ...<br/>def initialize<br/>  @oauth_client = OAuth2::Client.new(Rails.configuration.x.oauth.client_id,<br/>                                     Rails.configuration.x.oauth.client_secret,<br/>                                     authorize_url: '/oauth2/authorize',<br/>                                     site: Rails.configuration.x.oauth.idp_url,<br/>                                     token_url: '/oauth2/token',<br/>                                     redirect_uri: Rails.configuration.x.oauth.redirect_uri)<br/>end<br/># ...</span></pre><p id="8be8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">当用户点击我们创建的“登录”链接时，登录过程开始。正如在上面的序列图中所看到的，我们希望将这个请求发送给负责验证用户凭证的FusionAuth。接下来，用户将看到一个默认的登录页面，包括用户名和密码字段。FusionAuth提供了通过<a class="ae jd" href="https://fusionauth.io/docs/v1/tech/themes/" rel="noopener ugc nofollow" target="_blank">主题</a>定制表单样式的灵活性，但是对于本教程，我们将坚持使用默认样式。</p><p id="8393" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">下面的方法使用“OAuth2”客户端来构造“authorize_url ”,并相应地重定向请求。</p><pre class="kv kw kx ky fd kz la lb lc aw ld bi"><span id="43be" class="le jf hi la b fi lf lg l lh li"># ...<br/>def login<br/>  redirect_to @oauth_client.auth_code.authorize_url<br/>end<br/># ...</span></pre><p id="a25e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">成功的响应将产生登录页面:</p><figure class="kv kw kx ky fd lq er es paragraph-image"><div role="button" tabindex="0" class="lr ls di lt bf lu"><div class="er es lp"><img src="../Images/b49c661ae8131ea3d281d17d99c3b730.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*v6E6s6R0d2PEgYHq.png"/></div></div></figure><p id="8007" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">认证成功后，FusionAuth使用“redirect_uri”将“授权代码”重定向到Rails应用程序。这个值告诉FusionAuth在成功认证后重定向到哪里，这与我们的<code class="du lm ln lo la b">oauth_callback</code>路由相对应。我们还将它添加到FusionAuth中，因为给定应用程序的每个“redirect_uri”都必须作为“授权的重定向URL”存在。想想安全！</p><p id="f351" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">总之，我们应用中的<code class="du lm ln lo la b">oauth_callback</code>做了几件事:</p><ol class=""><li id="6148" class="kc kd hi ih b ii ij im in iq lj iu lk iy ll jc mm kk kl km bi translated">在通过身份验证并被授予授权代码后，处理来自FusionAuth的重定向。</li><li id="a2cd" class="kc kd hi ih b ii kn im ko iq kp iu kq iy kr jc mm kk kl km bi translated">执行返回给FusionAuth的请求，以将授权码交换为访问令牌。</li><li id="0316" class="kc kd hi ih b ii kn im ko iq kp iu kq iy kr jc mm kk kl km bi translated">对接收到的访问令牌上的声明进行解码和验证。</li><li id="6006" class="kc kd hi ih b ii kn im ko iq kp iu kq iy kr jc mm kk kl km bi translated">在会话上保存访问令牌/JWT，以指示用户已成功通过身份验证。</li></ol><p id="315a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">OAuth流程中的下一步是将我们的授权码换成访问令牌。为此，我们将提出一个额外的<a class="ae jd" href="https://fusionauth.io/docs/v1/tech/oauth/endpoints/#complete-the-authorization-code-grant-request" rel="noopener ugc nofollow" target="_blank">代码交换</a>请求。使用<a class="ae jd" href="https://github.com/oauth-xx/oauth2" rel="noopener ugc nofollow" target="_blank"> oauth2 </a> gem，我们构建一个客户端，然后通过授权代码发出请求，并重定向URI。</p><pre class="kv kw kx ky fd kz la lb lc aw ld bi"><span id="82fc" class="le jf hi la b fi lf lg l lh li"># ...<br/># Make a call to exchange the authorization_code for an access_token<br/>response = @oauth_client.auth_code.get_token(params[:code])</span><span id="7f9a" class="le jf hi la b fi ml lg l lh li"># Extract the access token from the response<br/>token = response.to_hash[:access_token]<br/># ...</span></pre><p id="10bc" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们接收编码为JWT的访问令牌。我们现在想解码JWT并验证声明。对于这个例子，我们验证了分别反映应用程序<code class="du lm ln lo la b">client_id</code>和令牌发放者的<code class="du lm ln lo la b">aud</code>和<code class="du lm ln lo la b">iss</code>声明。回想一下，我们之前在FusionAuth中配置了issuer值。</p><pre class="kv kw kx ky fd kz la lb lc aw ld bi"><span id="4e48" class="le jf hi la b fi lf lg l lh li"># ...<br/># Decode the token<br/>begin<br/>  decoded = TokenDecoder.new(token, client_id).decode<br/>rescue Exception =&gt; error<br/>  "An unexpected exception occurred: #{error.inspect}"<br/>  head :forbidden<br/>  return<br/>end<br/># ...</span></pre><p id="fcd4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">TokenDecoder类解码JWT，验证HMAC秘密，并确认声明。</p><pre class="kv kw kx ky fd kz la lb lc aw ld bi"><span id="4326" class="le jf hi la b fi lf lg l lh li">class TokenDecoder</span><span id="90fd" class="le jf hi la b fi ml lg l lh li">  def initialize(token, aud)<br/>    @token = token<br/>    @aud = aud<br/>    @iss = 'fusionauth.io'<br/>  end</span><span id="62e1" class="le jf hi la b fi ml lg l lh li">  def decode<br/>    begin<br/>      JWT.decode(<br/>        @token,<br/>        Rails.configuration.x.oauth.hmac,<br/>        true,<br/>        {<br/>          verify_iss: true,<br/>          iss: @iss,<br/>          verify_aud: true,<br/>          aud: @aud,<br/>          algorithm: 'HS256'})<br/>    rescue JWT::VerificationError<br/>      puts "verification error"<br/>      raise<br/>    rescue JWT::DecodeError<br/>      puts "bad stuff happened"<br/>      raise<br/>    end<br/>  end<br/>end</span></pre><p id="7b4b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">最后，我们在用户会话上设置令牌，并重定向回我们的欢迎页面，结束我们的<code class="du lm ln lo la b">oauth_callback</code>方法。</p><pre class="kv kw kx ky fd kz la lb lc aw ld bi"><span id="cd99" class="le jf hi la b fi lf lg l lh li"># ...<br/># Set the token on the user session <br/># httponly to prevent XSS attacks<br/>session[:user_jwt] = {value: decoded, httponly: true}</span><span id="50cf" class="le jf hi la b fi ml lg l lh li">redirect_to root_path<br/># ...</span></pre><p id="01cc" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">当用户注销时，我们希望使他们在FusionAuth和我们的应用程序上的会话无效。类似于<code class="du lm ln lo la b">oauth_callback</code>接收<code class="du lm ln lo la b">authorize</code>重定向的方式，我们的<code class="du lm ln lo la b">destroy</code>方法接收<code class="du lm ln lo la b">logout</code>重定向。接收到重定向告诉我们用户已经从FusionAuth注销，我们可以安全地清除用户在Rails中的会话。</p><pre class="kv kw kx ky fd kz la lb lc aw ld bi"><span id="665d" class="le jf hi la b fi lf lg l lh li"># ...<br/>def logout<br/>  # Invalidate session with FusionAuth<br/>  @oauth_client.request(:get, 'oauth2/logout')</span><span id="5041" class="le jf hi la b fi ml lg l lh li">  # Reset Rails session<br/>  reset_session</span><span id="351f" class="le jf hi la b fi ml lg l lh li">  redirect_to root_path<br/>end<br/># ...</span></pre><h1 id="f22c" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">完善我们的Rails会话</h1><p id="e258" class="pw-post-body-paragraph if ig hi ih b ii ke ik il im kf io ip iq ks is it iu kt iw ix iy ku ja jb jc hb bi translated">既然我们已经有了认证用户以及将他们从FusionAuth中注销的功能，我们将希望在我们的Rails应用程序上完成相同的循环。</p><p id="f585" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在Rails中有许多处理用户会话的方法，但是对于这个例子，我决定创建ApplicationController的所有子类都可以访问的helper方法。</p><p id="58fb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><code class="du lm ln lo la b">current_user</code>在会话中查找用户JWT。如果存在，并且电子邮件已经过验证，它将从JWT中检索用户的电子邮件地址。如果不存在，这意味着用户已注销或其会话已过期。</p><pre class="kv kw kx ky fd kz la lb lc aw ld bi"><span id="802c" class="le jf hi la b fi lf lg l lh li"># app/controllers/application_controller.rb</span><span id="fa98" class="le jf hi la b fi ml lg l lh li">class ApplicationController &lt; ActionController::Base<br/>  helper_method :current_user<br/>  helper_method :logged_in?</span><span id="63e7" class="le jf hi la b fi ml lg l lh li">  def current_user<br/>    if session[:user_jwt]<br/>      token = session[:user_jwt]["value"].first</span><span id="cc26" class="le jf hi la b fi ml lg l lh li">      if token &amp;&amp; token["email_verified"]<br/>        @email = token["email"]<br/>      else<br/>        head :forbidden<br/>        return<br/>      end<br/>    end<br/>  end</span><span id="70fd" class="le jf hi la b fi ml lg l lh li">  def logged_in?<br/>    current_user.present?<br/>  end</span><span id="1483" class="le jf hi la b fi ml lg l lh li">end</span></pre><h1 id="233c" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">把所有的放在一起</h1><p id="bef4" class="pw-post-body-paragraph if ig hi ih b ii ke ik il im kf io ip iq ks is it iu kt iw ix iy ku ja jb jc hb bi translated">是时候通过一个登录示例来实现我们的Ruby on Rails OAuth流了。在启动Rails服务器之前，一定要在您的环境中设置<code class="du lm ln lo la b">HMAC_SECRET</code>的“默认签名密钥”值，使它可以被我们的开发配置访问。</p><p id="7286" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">踢轮胎，点火！</p><pre class="kv kw kx ky fd kz la lb lc aw ld bi"><span id="3bfe" class="le jf hi la b fi lf lg l lh li">rails s</span></pre><p id="685b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">导航至<code class="du lm ln lo la b">http://localhost:3000</code>。如果您使用的不是3000，请替换相应的端口。</p><figure class="kv kw kx ky fd lq er es paragraph-image"><div role="button" tabindex="0" class="lr ls di lt bf lu"><div class="er es lp"><img src="../Images/fec990a7093a89eaf90144e0a566a46e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*0F2UufkmOAdLJVgi.png"/></div></div></figure><p id="edc5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">使用我们在FusionAuth中创建和注册的用户登录应用程序。</p><figure class="kv kw kx ky fd lq er es paragraph-image"><div role="button" tabindex="0" class="lr ls di lt bf lu"><div class="er es lp"><img src="../Images/bf1b338a02cb6cb19aa1316cd64b4de1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*gUSjWFmiKflp3e_8.png"/></div></div></figure><p id="eb75" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们成功了！我们登录了，我们的应用程序知道我们是谁。</p><figure class="kv kw kx ky fd lq er es paragraph-image"><div role="button" tabindex="0" class="lr ls di lt bf lu"><div class="er es lp"><img src="../Images/e7c2711a451956f399d8ad8be03b0fd7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*vY93tKQmRLKOaTBu.png"/></div></div></figure><p id="81d8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在让我们假设我们已经完成了与应用程序的交互，并准备好通过导航到相应的URL来注销。</p><figure class="kv kw kx ky fd lq er es paragraph-image"><div role="button" tabindex="0" class="lr ls di lt bf lu"><div class="er es lp"><img src="../Images/a30868e6716867ecdba036bd13abd8ea.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*mBNAOCip0smFKAbP.png"/></div></div></figure><h1 id="6175" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">后续步骤</h1><p id="6629" class="pw-post-body-paragraph if ig hi ih b ii ke ik il im kf io ip iq ks is it iu kt iw ix iy ku ja jb jc hb bi translated">现在我们已经有了OAuth流，我们的基础可以根据需要进行扩展。以下是接下来要解决的一些想法:</p><ul class=""><li id="5f7d" class="kc kd hi ih b ii ij im in iq lj iu lk iy ll jc kj kk kl km bi translated">添加并分配用户<a class="ae jd" href="https://fusionauth.io/docs/v1/tech/core-concepts/roles/#overview" rel="noopener ugc nofollow" target="_blank">角色</a>，以便我们的Rails应用程序中的功能可以相应地显示或隐藏。</li><li id="4775" class="kc kd hi ih b ii kn im ko iq kp iu kq iy kr jc kj kk kl km bi translated">使用<a class="ae jd" href="https://fusionauth.io/docs/v1/tech/themes/" rel="noopener ugc nofollow" target="_blank">主题</a>定制FusionAuth登录页面的外观和感觉。</li><li id="0de1" class="kc kd hi ih b ii kn im ko iq kp iu kq iy kr jc kj kk kl km bi translated">使用<a class="ae jd" href="https://fusionauth.io/docs/v1/tech/core-concepts/identity-providers/#overview" rel="noopener ugc nofollow" target="_blank">身份提供商</a>添加“登录谷歌”或“登录脸书”社交登录按钮。</li></ul><h1 id="4580" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">我们学到了什么？</h1><p id="6367" class="pw-post-body-paragraph if ig hi ih b ii ke ik il im kf io ip iq ks is it iu kt iw ix iy ku ja jb jc hb bi translated">使用Rails中的授权码授权，您可以使用任何OAuth兼容的身份提供者来保护您的应用程序。示例代码可以在Github <a class="ae jd" href="https://github.com/FusionAuth/fusionauth-example-rails-oauth" rel="noopener ugc nofollow" target="_blank">这里</a>找到。</p><p id="5447" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">编码快乐！</p></div><div class="ab cl mn mo gp mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="hb hc hd he hf"><p id="248d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="mu">最初发布于</em><a class="ae jd" href="https://fusionauth.io/blog/2020/12/14/how-to-securely-implement-oauth-rails/" rel="noopener ugc nofollow" target="_blank"><em class="mu">https://fusion auth . io</em></a><em class="mu">。</em></p></div></div>    
</body>
</html>