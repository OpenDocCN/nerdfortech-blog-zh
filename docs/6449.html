<html>
<head>
<title>Apache Kafka: A Basic Intro</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">阿帕奇卡夫卡:基本介绍</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/a-basic-introduction-to-kafka-a7d10a7776e6?source=collection_archive---------1-----------------------#2022-02-26">https://medium.com/nerd-for-tech/a-basic-introduction-to-kafka-a7d10a7776e6?source=collection_archive---------1-----------------------#2022-02-26</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/bccbe7fc1309c093a4421cf4adcc98a9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Z9qWalYYaOPsD77CYpen6g.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated"><a class="ae iu" href="https://www.metricfire.com/blog/kafka-monitoring-using-prometheus/" rel="noopener ugc nofollow" target="_blank">图像来源</a></figcaption></figure><p id="de44" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在这篇博文中，我将简单介绍一下<em class="jt">阿帕奇卡夫卡</em>以及入门卡夫卡所必须知道的术语。</p><h1 id="5116" class="ju jv hi bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">卡夫卡——是什么？</h1><p id="d7cd" class="pw-post-body-paragraph iv iw hi ix b iy ks ja jb jc kt je jf jg ku ji jj jk kv jm jn jo kw jq jr js hb bi translated">简而言之，Kafka 是一个分布式系统，允许多个服务通过其基于队列的架构相互通信。这样一来，让我们开始了解一些基本的卡夫卡术语。让我们开始吧；)</p><figure class="ky kz la lb fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es kx"><img src="../Images/3bb42c6aeea581672c0c92fdd748e923.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yAOr7gDRv-4YatpuMlDbIA.jpeg"/></div></div></figure><p id="be53" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">代理</strong>:一个<em class="jt">代理</em>是一个服务器，上面运行着 Kafka，负责多个服务之间的通信。多个经纪人将形成一个 Kafka 集群。</p><p id="c479" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">事件</strong>:由 Kafka 代理产生或消费的消息被称为<em class="jt">事件</em>。这些消息以字节的形式存储在代理的磁盘存储器中。</p><p id="f0fc" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">生产者和消费者</strong>:向 Kafka broker 产生这些事件的服务被称为<em class="jt">生产者</em>，消费这些事件的被称为<em class="jt">消费者</em>。同样的服务也有可能既产生又消费来自 Kafka 的消息。</p><p id="1eda" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">主题</strong>:为了区分 Kafka 中存储的事件类型，使用了主题。简而言之，<em class="jt">主题</em>就像文件系统中的一个文件夹，其中只存储与特定类型相关的事件或消息。例如:“支付-详情”、“用户-详情”等。</p><p id="5725" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">分区</strong>:为了获得更高的吞吐量，可以将一个主题进一步划分为<em class="jt">分区</em>。它是保存主题数据子集的最小存储单元。</p><p id="fb0a" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">复制因素</strong>:一个分区的副本是那个分区的备份。主题的<em class="jt">复制因子</em>决定了 Kafka 集群应该维护该主题中的多少个分区副本。分区为 1、复制因子为 2 的主题意味着相同数据的相同分区的两个副本将存储在 Kafka 集群中。</p><p id="2457" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">偏移量</strong>:为了跟踪哪些事件已经被消费者消费，指向最近消费的消息的索引被存储在 Kafka 中，该索引被称为<em class="jt">偏移量</em>，并且帮助跟踪哪些事件已经被消费者消费。因此，如果消费者下降，这个偏移值将帮助我们准确地知道消费者必须从哪里开始消费事件。一个为 kafka 主题生成消息的生产者有 3 个分区，如下所示:</p><figure class="ky kz la lb fd ij er es paragraph-image"><div class="er es lc"><img src="../Images/5956cb6c539afaffdb5cbde3a0ae114e.png" data-original-src="https://miro.medium.com/v2/resize:fit:832/format:webp/1*9Qm9qjZbvfV0X1pAlUUxcw.png"/></div><figcaption class="iq ir et er es is it bd b be z dx translated"><a class="ae iu" href="https://docs.cloudera.com/HDPDocuments/HDF3/HDF-3.3.0/kafka-overview/content/apache_kafka_concepts.html" rel="noopener ugc nofollow" target="_blank">图像来源</a></figcaption></figure><p id="64ec" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">Zookeeper</strong>:<em class="jt">Zookeeper</em>是 Kafka 集群中的一个额外服务，帮助维护集群 ACL，存储所有主题的所有分区的偏移量，用于跟踪 Kafka 代理节点的状态并维护客户端配额(允许生产者/消费者读取/写入多少数据)。</p><p id="a713" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">消费者群</strong>:一群消费者可以加入一个群体，以便合作和消费来自一组主题的消息。这个消费者分组被称为<em class="jt">消费者组</em>。如果两个消费者订阅了同一个主题，并且出现在同一个消费者组中，那么这两个消费者将被分配不同的分区集，并且这两个消费者都不会接收到相同的消息。如果多个消费者订阅同一个主题，消费者群体可以帮助获得更高的消费率。</p><p id="24f1" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我在<a class="ae iu" rel="noopener" href="/@ahmedgulabkhan/kafka-partitions-and-consumer-groups-in-6-mins-9e0e336c6c00">这篇文章</a>里已经比较详细的讲过卡夫卡分区和消费群体，一定要去看看。</p><h1 id="7eb0" class="ju jv hi bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">事件是如何产生和消费的？</h1><p id="5bbb" class="pw-post-body-paragraph iv iw hi ix b iy ks ja jb jc kt je jf jg ku ji jj jk kv jm jn jo kw jq jr js hb bi translated">为了更好地理解这一点，让我们考虑两种情况</p><p id="214b" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">场景 1: </strong></p><p id="bccb" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在第一个场景中，我们假设在 Kafka 集群中有 1 个 Kafka 代理，由 1 个主题(比如主题 A，分区计数和复制因子都为 1)、1 个生产者和 1 个消费者组成，如下图所示</p><figure class="ky kz la lb fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ld"><img src="../Images/4d756d2ac9b27a55b71001816c7fc525.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2D11ydIOPPDdi0OmiFcV2w.jpeg"/></div></div></figure><p id="694a" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">考虑我们的生产者向 Kafka 代理的 Topic-A 发送事件(同步或异步)。因为只有一个分区，所以发送到同一个主题的所有消息都存储在 Kafka 队列中，并为每个产生的新事件不断追加到队列中。</p><p id="13c6" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">消费者订阅主题-A，并按照产生的顺序消费来自 Kafka broker 的所有事件。</p><p id="b87b" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">情景二:</strong></p><p id="b6e7" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">现在，如果我们考虑与上面相同的情况，但是假设我们的主题(主题-A)有 2 个分区，而不是以前的 1 个。从生产者发送到主题 A 的事件将以这样一种方式发送到这两个分区，即没有两个分区会接收到相同的事件。并且消费者将从分配给它的分区接收事件。</p><figure class="ky kz la lb fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es le"><img src="../Images/a4cf7892bb9653e9f4101c1b434bd06a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1oCrxmGTVzNiUSBNa8rboA.jpeg"/></div></div></figure><h1 id="18a1" class="ju jv hi bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">常见问答列表</h1><p id="63ce" class="pw-post-body-paragraph iv iw hi ix b iy ks ja jb jc kt je jf jg ku ji jj jk kv jm jn jo kw jq jr js hb bi translated">问:卡夫卡会向消费者传递信息吗？</p><p id="021a" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">A.不，卡夫卡的消费者遵循的是拉策略，而不是推策略。这意味着消费者是负责向 Kafka 代理发起请求以检索消息的人。</p><p id="a6bc" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">问:卡夫卡作品中的信息在被消费后会被删除吗？</p><p id="78f9" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">A.Kafka 中存储的消息在使用后不会被删除，而是通过以下任一方法删除:</p><ul class=""><li id="d627" class="lf lg hi ix b iy iz jc jd jg lh jk li jo lj js lk ll lm ln bi translated">邮件仅在达到特定时间段后被删除(基于时间的保留)或</li><li id="e844" class="lf lg hi ix b iy lo jc lp jg lq jk lr jo ls js lk ll lm ln bi translated">当达到分区的最大消息大小时(基于大小的保留)</li></ul><p id="344b" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">问:相同的消息被发送到相同主题的分区吗？</p><p id="8e2a" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">A.没有两个分区会从生产者那里接收到相同的消息</p><p id="b037" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">问:来自同一主题的不同分区的消费是否以生产者发送它们的相同顺序发生</p><p id="ff49" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">A.Kafka 保证生产者发送到各个分区的消息的顺序，但是如果消费者使用这个主题的分区，这些不同分区使用的消息的顺序与生产者产生的消息的顺序不同</p><p id="ed17" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如果你想知道 Kafka 中的分区和消费群是如何工作的，你可以阅读下一篇文章<a class="ae iu" rel="noopener" href="/@ahmedgulabkhan/kafka-partitions-and-consumer-groups-in-6-mins-9e0e336c6c00"> Kafka 分区和消费群 6 分钟</a></p><p id="73d2" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">你可以浏览这个系列中更多的卡夫卡文章</p><ol class=""><li id="b574" class="lf lg hi ix b iy iz jc jd jg lh jk li jo lj js lt ll lm ln bi translated"><a class="ae iu" rel="noopener" href="/@ahmedgulabkhan/kafka-partitions-and-consumer-groups-in-6-mins-9e0e336c6c00">6 分钟内卡夫卡分区和消费群</a></li><li id="a1c1" class="lf lg hi ix b iy lo jc lp jg lq jk lr jo ls js lt ll lm ln bi translated"><a class="ae iu" rel="noopener" href="/@ahmedgulabkhan/3-simple-steps-to-set-up-kafka-locally-using-docker-b07f71f0e2c9">使用 Docker 在本地设置 Kafka 的三个简单步骤</a></li></ol><p id="1424" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">请关注卡夫卡系列的下一篇博客。我也将发布更多关于软件工程概念的文章。</p><p id="0125" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">你也可以在<br/></strong><a class="ae iu" href="https://github.com/ahmedgulabkhan" rel="noopener ugc nofollow" target="_blank">GitHub</a><br/><a class="ae iu" href="https://dev.to/ahmedgulabkhan" rel="noopener ugc nofollow" target="_blank">dev . to</a>上找到我</p></div></div>    
</body>
</html>