<html>
<head>
<title>Ceph-Ansible Deployment &amp; Testing Using Vagrant (Part 2)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Ceph-Ansible部署和测试(第2部分)</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/ceph-ansible-deployment-testing-using-vagrant-part-2-342ef21d5e43?source=collection_archive---------14-----------------------#2021-03-14">https://medium.com/nerd-for-tech/ceph-ansible-deployment-testing-using-vagrant-part-2-342ef21d5e43?source=collection_archive---------14-----------------------#2021-03-14</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="3bfb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在这个<a class="ae jd" href="https://razmaabari.medium.com/ceph-ansible-deployment-testing-using-vagrant-8205a9f39f2d" rel="noopener">中级</a>过程的第一部分(主要关注部署端)之后，今天将更详细地介绍Ceph &amp;的对象存储能力，使其保持高可用性以确保无故障。</p><p id="c189" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我将首先深入研究Ceph S3用户创建，以及一些使用AWS-CLI解释器的基本S3命令。接下来，我们将使用诸如HAProxy &amp; Keepalived之类的工具，让我们的Ceph集群尽可能地实现故障冗余。</p><p id="d8d4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">请确保在第一部分采取的所有先前步骤都已执行，以确保程序顺利运行。</p><h1 id="cc9e" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">使用亚马逊S3的Ceph对象存储</h1><p id="be4d" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">首先，选择一个集群节点作为Ceph的S3对象存储的客户机。对于这个测试，我们将选择我们的MON节点。选择我们的客户端节点后，对其进行ssh并安装AWS CLI以连接到S3。</p><blockquote class="kh ki kj"><p id="a481" class="if ig kk ih b ii ij ik il im in io ip kl ir is it km iv iw ix kn iz ja jb jc hb bi translated"><em class="hi"> AWS-CLI安装可以使用亚马逊官方指令</em> <a class="ae jd" href="https://docs.aws.amazon.com/cli/latest/userguide/install-linux.html" rel="noopener ugc nofollow" target="_blank"> <em class="hi">这里</em> </a> <em class="hi">来完成。</em></p></blockquote><pre class="ko kp kq kr fd ks kt ku kv aw kw bi"><span id="e596" class="kx jf hi kt b fi ky kz l la lb"><strong class="kt hj">[vagrant@mon0 ~]$ </strong>sudo radosgw-admin user create --uid="razmab" --display-name="Raz S3User"</span></pre><ul class=""><li id="e362" class="lc ld hi ih b ii ij im in iq le iu lf iy lg jc lh li lj lk bi translated"><strong class="ih hj"> razmab </strong>是要创建的用户的名称。</li><li id="1267" class="lc ld hi ih b ii ll im lm iq ln iu lo iy lp jc lh li lj lk bi translated"><strong class="ih hj"> S3User </strong>是用户显示名称。</li></ul><pre class="ko kp kq kr fd ks kt ku kv aw kw bi"><span id="bc2d" class="kx jf hi kt b fi ky kz l la lb">{<br/>    "user_id": "razmab",<br/>    "display_name": "S3User",<br/>    "email": "",<br/>    "suspended": 0,<br/>    "max_buckets": 1000,<br/>    "subusers": [],<br/>    "keys": [<br/>        {<br/>            "user": "razmab",<br/>            "access_key": "AWXD2BYDQ6PGNJX1XKQL",<br/>            "secret_key": "JoKUsq6Sh1PYBCP0WRgWxvh3hRfCiCqz9roDJCC8"<br/>        }<br/>    ],<br/>    "swift_keys": [],<br/>    "caps": [],<br/>    "op_mask": "read, write, delete",<br/>    "default_placement": "",<br/>    "default_storage_class": "",<br/>    "placement_tags": [],<br/>    "bucket_quota": {<br/>        "enabled": false,<br/>        "check_on_raw": false,<br/>        "max_size": -1,<br/>        "max_size_kb": 0,<br/>        "max_objects": -1<br/>    },<br/>    "user_quota": {<br/>        "enabled": false,<br/>        "check_on_raw": false,<br/>        "max_size": -1,<br/>        "max_size_kb": 0,<br/>        "max_objects": -1<br/>    },<br/>    "temp_url_keys": [],<br/>    "type": "rgw",<br/>    "mfa_ids": []<br/>}</span></pre><p id="7564" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">注意<em class="kk">访问密钥</em>和<em class="kk">秘密密钥</em>。</p><pre class="ko kp kq kr fd ks kt ku kv aw kw bi"><span id="6998" class="kx jf hi kt b fi ky kz l la lb">"user": "razmab"<br/>"access_key": "AWXD2BYDQ6PGNJX1XKQL"<br/>"secret_key": "JoKUsq6Sh1PYBCP0WRgWxvh3hRfCiCqz9roDJCC8"</span></pre><p id="7c08" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">使用AWS CLI访问Ceph对象存储。</p><p id="9b3d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在开始使用AWS CLI工具与AWS服务交互之前，您需要通过运行<em class="kk"> AWS configure </em>命令对其进行配置。</p><pre class="ko kp kq kr fd ks kt ku kv aw kw bi"><span id="523e" class="kx jf hi kt b fi ky kz l la lb"><strong class="kt hj">[vagrant@mon0 ~]$</strong> aws configure --profile=ceph<br/>AWS Access Key ID [None]: AWXD2BYDQ6PGNJX1XKQL<br/>AWS Secret Access Key [None]:<br/>JoKUsq6Sh1PYBCP0WRgWxvh3hRfCiCqz9roDJCC8<br/>Default region name [None]:<br/>Default output format [None]: json</span></pre><p id="c9de" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">接下来，通过ssh连接到我们的一个RGW节点，检查RGW的IP地址和端口，(默认情况下应该是8080。)与下一条命令:</p><pre class="ko kp kq kr fd ks kt ku kv aw kw bi"><span id="64d0" class="kx jf hi kt b fi ky kz l la lb"><strong class="kt hj">[vagrant@rgw0 ~]$ sudo netstat -plunt | grep -i rados</strong><br/>tcp        0      0 192.168.42.12:8080      0.0.0.0:*               LISTEN      778/radosgw         <br/>tcp        0      0 192.168.42.12:8081      0.0.0.0:*               LISTEN      779/radosgw</span></pre><p id="6b7f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">正如我们所看到的，我们的RGW IP地址和端口是192.168.42.12:8080。请将此地址作为下一次S3测试的记录，并尝试访问此URL，确保看到此网页:</p><figure class="ko kp kq kr fd lr er es paragraph-image"><div role="button" tabindex="0" class="ls lt di lu bf lv"><div class="er es lq"><img src="../Images/bce49d566bbfd0e4081b03ba68702851.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*78To4kRZ5Z-qDcyF.png"/></div></div><figcaption class="ly lz et er es ma mb bd b be z dx translated">192.168.42.12:8080地址</figcaption></figure><p id="c121" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">很好，现在创建一个名为“test”的测试桶</p><pre class="ko kp kq kr fd ks kt ku kv aw kw bi"><span id="c5a4" class="kx jf hi kt b fi ky kz l la lb"><strong class="kt hj">[vagrant@mon0 ~]$ </strong>aws --profile=ceph --endpoint=<a class="ae jd" href="http://192.168.42.12:8080/" rel="noopener ugc nofollow" target="_blank">http://192.168.42.12:8080</a> s3 mb s3://test</span></pre><p id="8300" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果测试成功，您应该会收到以下输出:</p><pre class="ko kp kq kr fd ks kt ku kv aw kw bi"><span id="b92e" class="kx jf hi kt b fi ky kz l la lb">make_bucket: test</span></pre><p id="def6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">查看现有的可用存储桶:</p><pre class="ko kp kq kr fd ks kt ku kv aw kw bi"><span id="1062" class="kx jf hi kt b fi ky kz l la lb"><strong class="kt hj">[vagrant@mon0 ~]$</strong> /home/vagrant/.local/lib/aws/bin/aws — endpoint <a class="ae jd" href="http://192.168.42.12:8080/" rel="noopener ugc nofollow" target="_blank">http://192.168.42.12:8080</a> s3api list-buckets<br/>{<br/>    "Owner": {<br/>        "DisplayName": "S3User", <br/>        "ID": "razmab"<br/>    }, <br/>    "Buckets": [<br/>        {<br/>            "CreationDate": "2021-02-28T12:59:26.508Z", <br/>            "Name": "test"<br/>        }<br/>    ]<br/>}</span></pre><p id="802b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">要使用AWS-CLI命令进行更多的对象存储，请随意查看这个<a class="ae jd" href="https://www.scaleway.com/en/docs/object-storage-with-aws-cli/" rel="noopener ugc nofollow" target="_blank">页面</a>。</p><h1 id="9e71" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">HAProxy</h1><p id="2fac" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">为了使我们的RGW服务器具有高可用性负载均衡器，我们将在Ceph集群上安装一个HAProxy服务器。出于测试目的，RGW0将充当HAProxy服务器。</p><p id="2826" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">首先将安装wget，然后下载、解压并安装最新稳定版本的HAProxy (2.3.5)。</p><pre class="ko kp kq kr fd ks kt ku kv aw kw bi"><span id="4e64" class="kx jf hi kt b fi ky kz l la lb"><strong class="kt hj">[vagrant@rgw0 ~]$ </strong>sudo<strong class="kt hj"> </strong>yum install -y wget<br/><strong class="kt hj">[vagrant@rgw0 ~]$ </strong>sudo yum install gcc pcre-devel tar make -y<br/><strong class="kt hj">[vagrant@rgw0 ~]$ </strong>wget <a class="ae jd" href="http://www.haproxy.org/download/2.3/src/haproxy-2.3.5.tar.gz" rel="noopener ugc nofollow" target="_blank">http://www.haproxy.org/download/2.3/src/haproxy-2.3.5.tar.gz</a><br/><strong class="kt hj">[vagrant@rgw0 ~]$ </strong>tar -xzf haproxy-2.3.5.tar.gz<strong class="kt hj"><br/>[vagrant@rgw0 ~]$ </strong>cd haproxy-2.3.5<br/><strong class="kt hj">[vagrant@rgw0 ~]$ </strong>sudo<strong class="kt hj"> </strong>make install</span></pre><p id="7c87" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">HAProxy设置以及HAProxy记录和防火墙设置的配置。</p><pre class="ko kp kq kr fd ks kt ku kv aw kw bi"><span id="7c5b" class="kx jf hi kt b fi ky kz l la lb"><strong class="kt hj">[vagrant@rgw0 ~]$ </strong>sudo mkdir -p /etc/haproxy<br/><strong class="kt hj">[vagrant@rgw0 ~]$ </strong>sudo mkdir -p /var/lib/haproxy <br/><strong class="kt hj">[vagrant@rgw0 ~]$ </strong>sudo touch /var/lib/haproxy/stats<br/><strong class="kt hj">[vagrant@rgw0 ~]$ </strong>sudo ln -s /usr/local/sbin/haproxy /usr/sbin/haproxy<br/><strong class="kt hj">[vagrant@rgw0 ~]$ </strong>systemctl start haproxy ; systemctl enable haproxy<br/><strong class="kt hj">[vagrant@rgw0 ~]$ </strong>sudo firewall-cmd --permanent --zone=public --add-service=http<br/><strong class="kt hj">[vagrant@rgw0 ~]$ </strong>sudo firewall-cmd --permanent --zone=public --add-port=8181/tcp<br/><strong class="kt hj">[vagrant@rgw0 ~]$ </strong>sudo firewall-cmd --reload</span></pre><p id="c7b5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">最后，由于我们希望针对高需求增加我们的RGW工作负载，所以更新HAProxy配置文件以实现第4层的负载平衡。当访问RGW0的IP地址192.168.42.12:80时,“循环”算法将流量平均分配给两台RGW服务器</p><blockquote class="kh ki kj"><p id="08cd" class="if ig kk ih b ii ij ik il im in io ip kl ir is it km iv iw ix kn iz ja jb jc hb bi translated"><em class="hi">确保更新用户、组名&amp; IP地址，以匹配您自己的设置环境。</em></p></blockquote><pre class="ko kp kq kr fd ks kt ku kv aw kw bi"><span id="f7a1" class="kx jf hi kt b fi ky kz l la lb"><strong class="kt hj">[vagrant@rgw0 ~]$ </strong>sudo<strong class="kt hj"> </strong>systemctl restart rsyslog.service <br/><strong class="kt hj">[vagrant@rgw0 ~]$</strong> sudo vim /etc/haproxy/haproxy.cfg<br/>global<br/>   log /dev/log local0<br/>   log /dev/log local1 notice<br/>   chroot /var/lib/haproxy<br/>   stats timeout 30s<br/>   user vagrant<br/>   group vagrant<br/>   daemondefaults<br/>   log global<br/>   mode http<br/>   option httplog<br/>   option dontlognull<br/>   timeout connect 5000<br/>   timeout client 50000<br/>   timeout server 50000<br/>frontend http_front<br/>   bind 192.168.42.12:80<br/>   stats uri /haproxy/stats<br/>   default_backend http_back<br/>backend http_back<br/>   balance roundrobin<br/>   server rgw0 192.168.42.12:8080 check<br/>   server rgw1 192.168.42.13:8080 check</span></pre><p id="22c6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">启动并启用代理守护程序，并在防火墙设置中添加HTTP服务规则。</p><pre class="ko kp kq kr fd ks kt ku kv aw kw bi"><span id="ea9c" class="kx jf hi kt b fi ky kz l la lb"><strong class="kt hj">[vagrant@rgw0 ~]$</strong> systemctl start haproxy ; systemctl enable haproxy<br/><strong class="kt hj">[vagrant@rgw0 ~]$</strong> firewall-cmd --permanent --add-service=http<br/><strong class="kt hj">[vagrant@rgw0 ~]$</strong> firewall-cmd --reload</span></pre><p id="ca69" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">完成以上所有工作后，我们可以开始测试我们的负载均衡器，可以通过访问我们的MON0地址，然后访问端口80 (192.168.42.12:80)来完成，我们应该会像前面一样看到我们的RGW网页，这意味着绑定正在工作。对于我们之前选择的“循环”算法，网络流量应该平均分配。</p><p id="511c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们可以检查HAProxy统计数据，以了解有关RGW流量工作负载的更多信息，这可以通过我们的MON0的IP地址后跟“/haproxy？stats”，<a class="ae jd" href="http://192.168.42.10/haproxy?stats" rel="noopener ugc nofollow" target="_blank">http://192 . 168 . 42 . 12/ha proxy？统计数据</a>。</p><figure class="ko kp kq kr fd lr er es paragraph-image"><div role="button" tabindex="0" class="ls lt di lu bf lv"><div class="er es mc"><img src="../Images/2a5e7c8b07ee5e1ef548813cbea66ce4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*JrCfXt_ZsU64C_6e.png"/></div></div></figure><p id="5616" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">更多关于HAProxy的信息，点击<a class="ae jd" href="https://www.haproxy.com/blog/the-four-essential-sections-of-an-haproxy-configuration/" rel="noopener ugc nofollow" target="_blank">这里</a>。</p><h1 id="c051" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">保持存活</h1><p id="ef31" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">现在我们有了一个负载平衡器来平衡我们的RGW工作负载，我们希望确保我们的RGW服务是冗余的，并且对于故障是健壮的。这可以通过使用一项名为“Keepalived”的服务来实现，其目标是即使我们的一台RGW服务器由于某种原因停机，我们的服务也能保持正常运行。</p><p id="fc64" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">首先，我们将在我们的两台RGW服务器上安装守护程序，以接收我们选择的浮动IP(192 . 168 . 42 . 50:80)，因此每当我们想要访问我们的S3网页时，我们将首先被重定向到我们的主RGW(0)。如果由于某种原因，RGW0不可用，请求将被转发到我们的备份RGW(1)服务器，以实现冗余。</p><pre class="ko kp kq kr fd ks kt ku kv aw kw bi"><span id="99d0" class="kx jf hi kt b fi ky kz l la lb"><strong class="kt hj">[vagrant@rgw0 ~]$ </strong>yum install -y keepalived<br/><strong class="kt hj">[vagrant@rgw0 ~]$ </strong>echo "net.ipv4.ip_nonlocal_bind = 1" &gt;&gt; /etc/sysctl.conf<br/><strong class="kt hj">[vagrant@rgw0 ~]$ </strong>sysctl -p <br/>net.ipv4.ip_nonlocal_bind = 1<br/><strong class="kt hj">[vagrant@rgw0 ~]$ </strong>cd /etc/keepalived/<br/><strong class="kt hj">[vagrant@rgw0 ~]$ </strong>vi keepalived.conf<br/>vrrp_instance RGW {<br/>    state MASTER # might not be necessary. This is on the Master LB node.<br/>    <a class="ae jd" href="http://twitter.com/main" rel="noopener ugc nofollow" target="_blank">@main</a> interface eth1<br/>    priority 100<br/>    advert_int 1<br/>    interface eth1<br/>    virtual_router_id 50<br/>    <a class="ae jd" href="http://twitter.com/main" rel="noopener ugc nofollow" target="_blank">@main</a> unicast_src_ip 192.168.42.12 80<br/>    unicast_peer {<br/>           192.168.42.13<br/>           }<br/>    authentication {<br/>        auth_type PASS<br/>        auth_pass 1111<br/>    }<br/>    virtual_ipaddress {<br/>        192.168.42.50<br/>    }<br/>    track_script {<br/>      chk_haproxy<br/>    }<br/>}<br/>virtual_server 192.168.42.50 8080 eth1 { #populate correct interface<br/>    delay_loop 6<br/>    lb_algo wlc<br/>    lb_kind dr<br/>    persistence_timeout 600<br/>    protocol TCP<br/>    real_server 192.168.42.12 80 { # ip address of rgw2 on physical interface, haproxy listens here, rgw listens to localhost:8080 or similar<br/>        weight 100<br/>        TCP_CHECK { # perhaps change these to a HTTP/SSL GET?<br/>            connect_timeout 3<br/>        }<br/>    }<br/>    real_server 192.168.42.13 80 { # ip address of rgw3 on physical interface, haproxy listens here, rgw listens to localhost:8080 or similar<br/>        weight 100<br/>        TCP_CHECK { # perhaps change these to a HTTP/SSL GET?<br/>            connect_timeout 3<br/>        }<br/>    }<br/>}</span></pre><p id="bc43" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">启动并启用保持激活服务。此外，验证您是否有可用的原始和新浮动IP地址。</p><pre class="ko kp kq kr fd ks kt ku kv aw kw bi"><span id="6f38" class="kx jf hi kt b fi ky kz l la lb"><strong class="kt hj">[vagrant@rgw0 ~]$ </strong>systemctl start keepalived ; systemctl enable keepalived<br/><strong class="kt hj">[vagrant@rgw0 ~]$ </strong>ip add</span></pre><figure class="ko kp kq kr fd lr er es paragraph-image"><div role="button" tabindex="0" class="ls lt di lu bf lv"><div class="er es md"><img src="../Images/c127ef99a1bd8d1f35be4eef607be30f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*M1lgA_--aIZNAQCs.png"/></div></div><figcaption class="ly lz et er es ma mb bd b be z dx translated">RGW0 IP</figcaption></figure><p id="ec4d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">请为我们的第二台RGW(1)服务器做同样的事情，但是将它添加到keepalived.conf文件中。</p><pre class="ko kp kq kr fd ks kt ku kv aw kw bi"><span id="162c" class="kx jf hi kt b fi ky kz l la lb">vrrp_instance RGW {<br/>    state BACKUP # might not be necessary.<br/>    priority 99<br/>    advert_int 1<br/>    interface eth1<br/>    virtual_router_id 50<br/>    unicast_src_ip 192.168.42.10 8080<br/>    unicast_peer {<br/>           192.168.42.10<br/>           }<br/>    authentication {<br/>        auth_type PASS<br/>        auth_pass 1111<br/>    }<br/>    virtual_ipaddress {<br/>        192.168.42.50<br/>    }<br/>    track_script {<br/>      chk_haproxy<br/>    }<br/>}<br/>virtual_server 192.168.42.50 8080 eth1 { #populate correct interface<br/>    delay_loop 6<br/>    lb_algo wlc<br/>    lb_kind dr<br/>    persistence_timeout 600<br/>    protocol TCP<br/>    real_server 192.168.42.12 8080 { # ip address of rgw2 on physical interface, haproxy listens here, rgw listens to localhost:8080 or similar<br/>        weight 100<br/>        TCP_CHECK { # perhaps change these to a HTTP/SSL GET?<br/>            connect_timeout 3<br/>        }<br/>    }<br/>    real_server 192.168.42.13 8080 { # ip address of rgw3 on physical interface, haproxy listens here, rgw listens to localhost:8080 or similar<br/>        weight 100<br/>        TCP_CHECK { # perhaps change these to a HTTP/SSL GET?<br/>            connect_timeout 3<br/>       }<br/>    }<br/>}</span></pre><p id="b972" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">启动并启用保持激活服务。此外，验证您是否有可用的原始和新浮动IP地址。</p><pre class="ko kp kq kr fd ks kt ku kv aw kw bi"><span id="dc6b" class="kx jf hi kt b fi ky kz l la lb"><strong class="kt hj">[vagrant@rgw1 ~]$ </strong>systemctl start keepalived ; systemctl enable keepalived<br/><strong class="kt hj">[vagrant@rgw1 ~]$ </strong>ip add</span></pre><figure class="ko kp kq kr fd lr er es paragraph-image"><div role="button" tabindex="0" class="ls lt di lu bf lv"><div class="er es md"><img src="../Images/872d5d1bfed3519b3c11b1420bdc5ffe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*SaDhoxrAVQDmLJmF.png"/></div></div><figcaption class="ly lz et er es ma mb bd b be z dx translated">RGW1 IP</figcaption></figure><p id="ac1c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">流程应该如下图所示。</p><figure class="ko kp kq kr fd lr er es paragraph-image"><div role="button" tabindex="0" class="ls lt di lu bf lv"><div class="er es me"><img src="../Images/01b7e5096778e7ed6a75f87432b2940f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*DdDIGbN221EW0XLl.png"/></div></div></figure><p id="a6b0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们在终端上测试这个。出于这个测试目的，我将上传一个名为“10g.img”的文件到我们的S3存储桶，稍后，关闭一个RGW(0) keepalived守护进程来检查上传是否成功完成，没有中断。</p><pre class="ko kp kq kr fd ks kt ku kv aw kw bi"><span id="03ff" class="kx jf hi kt b fi ky kz l la lb"><strong class="kt hj">[vagrant@mon0 ~]$ </strong>/usr/local/bin/aws --profile=ceph --endpoint=<a class="ae jd" href="http://192.168.42.50:8080/" rel="noopener ugc nofollow" target="_blank">http://192.168.42.50:8080</a> s3 cp big_file s3://test/<br/><strong class="kt hj">[vagrant@rgw0 ~]$</strong> sudo systemctl stop keepalived.service<br/><strong class="kt hj">[vagrant@mon0 ~]$ </strong>upload: ./big_file to s3://test/big_file</span></pre><p id="5b32" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">正如我们所看到的，文件上传并没有停止，而是延迟了几秒钟，直到keepalived切换到充当备份服务器的RGW1。</p><figure class="ko kp kq kr fd lr er es paragraph-image"><div role="button" tabindex="0" class="ls lt di lu bf lv"><div class="er es mf"><img src="../Images/87f020a415a444e51b0665103717dc81.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*liu1yM1tGv92zHaP.gif"/></div></div><figcaption class="ly lz et er es ma mb bd b be z dx translated">失败测试</figcaption></figure><h1 id="9978" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">结论和最终想法</h1><p id="ad47" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">我们学习了如何使用Ceph-Ansible轻松部署Ceph集群，在部署前和部署后更改许多ceph-ansible部署参数，使用RGW S3存储，使用HAProxy和Keepalived作为负载平衡器，以及监控我们的RGW服务器进行故障转移等等…</p><p id="0161" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我希望这个由两部分组成的medium过程为您提供了一些关于Ceph存储的见解，以及如何使用Ceph和其他工具实现高可用性，感谢观看。</p></div></div>    
</body>
</html>