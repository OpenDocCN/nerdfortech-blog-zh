<html>
<head>
<title>What are Events</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">什么是事件</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/what-are-events-559632b2ddc9?source=collection_archive---------1-----------------------#2022-12-05">https://medium.com/nerd-for-tech/what-are-events-559632b2ddc9?source=collection_archive---------1-----------------------#2022-12-05</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="5261" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">C#概念|委托和事件</h2></div><blockquote class="ix iy iz"><p id="11da" class="ja jb jc jd b je jf ij jg jh ji im jj jk jl jm jn jo jp jq jr js jt ju jv jw hb bi translated">目标: <br/>通过编写一个简单的程序，按下屏幕上的一个按钮，将 3 个立方体的颜色变为红色，从而了解事件</p></blockquote><figure class="jy jz ka kb fd kc er es paragraph-image"><div role="button" tabindex="0" class="kd ke di kf bf kg"><div class="er es jx"><img src="../Images/903d085518d25bc8b6ead1a5eebab904.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ycUwfn1yF799obURsEuA3Q.png"/></div></div></figure><h1 id="15a7" class="kj kk hi bd kl km kn ko kp kq kr ks kt io ku ip kv ir kw is kx iu ky iv kz la bi translated">事件的定义是什么？</h1><p id="5a74" class="pw-post-body-paragraph ja jb hi jd b je lb ij jg jh lc im jj ld le jm jn lf lg jq jr lh li ju jv jw hb bi translated">根据<strong class="jd hj"> O'Reilly C# 8.0 </strong>的说法，“事件是一种构造，它仅公开广播公司/订户模型所需的代表功能的子集。事件的主要目的是<em class="jc">防止用户相互干扰。</em></p><p id="2500" class="pw-post-body-paragraph ja jb hi jd b je jf ij jg jh ji im jj ld jl jm jn lf jp jq jr lh jt ju jv jw hb bi translated">但这意味着什么呢？让我们把这个定义分解一下，谈谈事件的关键方面。在上面的定义中，在我们尝试使用事件编码之前，有三个关键术语需要理解。</p><ol class=""><li id="84c3" class="lj lk hi jd b je jf jh ji ld ll lf lm lh ln jw lo lp lq lr bi translated">代表</li><li id="8d44" class="lj lk hi jd b je ls jh lt ld lu lf lv lh lw jw lo lp lq lr bi translated">广播公司</li><li id="d4e1" class="lj lk hi jd b je ls jh lt ld lu lf lv lh lw jw lo lp lq lr bi translated">订户</li></ol><h2 id="a798" class="lx kk hi bd kl ly lz ma kp mb mc md kt ld me mf kv lf mg mh kx lh mi mj kz mk bi translated">代表</h2><p id="b4ba" class="pw-post-body-paragraph ja jb hi jd b je lb ij jg jh lc im jj ld le jm jn lf lg jq jr lh li ju jv jw hb bi translated">如果你不知道什么是代表，请<strong class="jd hj"> | </strong> <a class="ae ml" rel="noopener" href="/@jordantkay21/what-are-delegates-91cfdb2537fd"> <strong class="jd hj">点击这里</strong> </a> <strong class="jd hj"> | </strong>阅读我之前关于代表的文章。</p><h2 id="a9d0" class="lx kk hi bd kl ly lz ma kp mb mc md kt ld me mf kv lf mg mh kx lh mi mj kz mk bi translated">广播公司</h2><p id="e794" class="pw-post-body-paragraph ja jb hi jd b je lb ij jg jh lc im jj ld le jm jn lf lg jq jr lh li ju jv jw hb bi translated">broadcaster 是一种包含委托字段的类型。广播员的工作是通过调用委托来决定何时广播。</p><h2 id="f824" class="lx kk hi bd kl ly lz ma kp mb mc md kt ld me mf kv lf mg mh kx lh mi mj kz mk bi translated">订户</h2><p id="0615" class="pw-post-body-paragraph ja jb hi jd b je lb ij jg jh lc im jj ld le jm jn lf lg jq jr lh li ju jv jw hb bi translated">订阅者是方法目标接收者。订户通过呼叫广播公司代表的+=和-=来决定何时开始和停止收听广播公司。</p><p id="a22a" class="pw-post-body-paragraph ja jb hi jd b je jf ij jg jh ji im jj ld jl jm jn lf jp jq jr lh jt ju jv jw hb bi translated">一个用户不知道或干扰其他用户。</p><p id="7512" class="pw-post-body-paragraph ja jb hi jd b je jf ij jg jh ji im jj ld jl jm jn lf jp jq jr lh jt ju jv jw hb bi translated">现在我们已经学习了事件的基本概念，让我们开始使用这个概念进行编码。</p><h1 id="388e" class="kj kk hi bd kl km kn ko kp kq kr ks kt io ku ip kv ir kw is kx iu ky iv kz la bi translated">作事前的现场（或情况）描述</h1><p id="b953" class="pw-post-body-paragraph ja jb hi jd b je lb ij jg jh lc im jj ld le jm jn lf lg jq jr lh li ju jv jw hb bi translated">因此，我们已经在上面定义了我们的目标… <br/> <em class="jc">创建一个简单的程序，通过按下屏幕上的按钮</em>将 3 个立方体的颜色变为红色</p><h2 id="5403" class="lx kk hi bd kl ly lz ma kp mb mc md kt ld me mf kv lf mg mh kx lh mi mj kz mk bi translated">需要游戏对象</h2><p id="67c7" class="pw-post-body-paragraph ja jb hi jd b je lb ij jg jh lc im jj ld le jm jn lf lg jq jr lh li ju jv jw hb bi translated">为了完成我们的目标，我们在场景中需要以下游戏对象…</p><ul class=""><li id="d9e2" class="lj lk hi jd b je jf jh ji ld ll lf lm lh ln jw mm lp lq lr bi translated">三个立方体</li><li id="8cd7" class="lj lk hi jd b je ls jh lt ld lu lf lv lh lw jw mm lp lq lr bi translated">UI 按钮</li></ul><figure class="jy jz ka kb fd kc er es paragraph-image"><div class="er es mn"><img src="../Images/980bc0177f5273d5187f4c7f898aa093.png" data-original-src="https://miro.medium.com/v2/resize:fit:872/format:webp/1*Zp47TQYodQpc5Y_c6wfZwA.png"/></div></figure><h2 id="2842" class="lx kk hi bd kl ly lz ma kp mb mc md kt ld me mf kv lf mg mh kx lh mi mj kz mk bi translated">需要脚本</h2><p id="692d" class="pw-post-body-paragraph ja jb hi jd b je lb ij jg jh lc im jj ld le jm jn lf lg jq jr lh li ju jv jw hb bi translated">为了完成我们的目标，我们需要脚本来告诉我们的程序做什么。我们需要以下脚本来完成我们的目标…</p><ul class=""><li id="40d2" class="lj lk hi jd b je jf jh ji ld ll lf lm lh ln jw mm lp lq lr bi translated">主脚本</li><li id="ab87" class="lj lk hi jd b je ls jh lt ld lu lf lv lh lw jw mm lp lq lr bi translated">多维数据集脚本</li></ul><h1 id="30ab" class="kj kk hi bd kl km kn ko kp kq kr ks kt io ku ip kv ir kw is kx iu ky iv kz la bi translated">主脚本</h1><p id="9daa" class="pw-post-body-paragraph ja jb hi jd b je lb ij jg jh lc im jj ld le jm jn lf lg jq jr lh li ju jv jw hb bi translated">主脚本将保存我们的 onClick 事件。这意味着主脚本将保存委托变量、事件变量和实例化委托的方法。</p><p id="cb58" class="pw-post-body-paragraph ja jb hi jd b je jf ij jg jh ji im jj ld jl jm jn lf jp jq jr lh jt ju jv jw hb bi translated">这个脚本将被附加到我们的画布上。</p><figure class="jy jz ka kb fd kc er es paragraph-image"><div class="er es mo"><img src="../Images/6cc9c3c03132db86969a4212a179ed9b.png" data-original-src="https://miro.medium.com/v2/resize:fit:910/format:webp/1*toFRtTuQJRVoDuJsg1MKww.png"/></div></figure><p id="0ae1" class="pw-post-body-paragraph ja jb hi jd b je jf ij jg jh ji im jj ld jl jm jn lf jp jq jr lh jt ju jv jw hb bi translated">让我们分析一下这个脚本，弄清楚什么是什么。</p><h2 id="b513" class="lx kk hi bd kl ly lz ma kp mb mc md kt ld me mf kv lf mg mh kx lh mi mj kz mk bi translated">七号线</h2><pre class="jy jz ka kb fd mp mq mr bn ms mt bi"><span id="8630" class="mu kk hi mq b be mv mw l mx my">public delegate void ActionClick();</span></pre><p id="6ebc" class="pw-post-body-paragraph ja jb hi jd b je jf ij jg jh ji im jj ld jl jm jn lf jp jq jr lh jt ju jv jw hb bi translated">如我们的文章<a class="ae ml" rel="noopener" href="/@jordantkay21/what-are-delegates-91cfdb2537fd"> <strong class="jd hj">中所述，什么是委托</strong> </a>第 7 行用下面的签名声明了一个<strong class="jd hj">委托类型</strong>:</p><ul class=""><li id="0248" class="lj lk hi jd b je jf jh ji ld ll lf lm lh ln jw mm lp lq lr bi translated">返回类型—无效</li><li id="fefe" class="lj lk hi jd b je ls jh lt ld lu lf lv lh lw jw mm lp lq lr bi translated">名称—操作单击</li><li id="2622" class="lj lk hi jd b je ls jh lt ld lu lf lv lh lw jw mm lp lq lr bi translated">参数-无</li></ul><p id="e025" class="pw-post-body-paragraph ja jb hi jd b je jf ij jg jh ji im jj ld jl jm jn lf jp jq jr lh jt ju jv jw hb bi translated">通过创建这个委托，我们创建了一个存储 ButtonClick()方法的变量。</p><h2 id="1a33" class="lx kk hi bd kl ly lz ma kp mb mc md kt ld me mf kv lf mg mh kx lh mi mj kz mk bi translated">八号线</h2><pre class="jy jz ka kb fd mp mq mr bn ms mt bi"><span id="5db0" class="mu kk hi mq b be mv mw l mx my">public static event ActionClick onClick;</span></pre><p id="da56" class="pw-post-body-paragraph ja jb hi jd b je jf ij jg jh ji im jj ld jl jm jn lf jp jq jr lh jt ju jv jw hb bi translated">在这一行，我们声明了一个委托类型 ActionClick 的事件。让我们逐字逐句地读一遍这一行，看看它在说什么。</p><ul class=""><li id="9262" class="lj lk hi jd b je jf jh ji ld ll lf lm lh ln jw mm lp lq lr bi translated">Public —将此变量设为公共变量，这意味着其他脚本可以访问它</li><li id="a72c" class="lj lk hi jd b je ls jh lt ld lu lf lv lh lw jw mm lp lq lr bi translated">静态—使该变量属于“类”而不是“对象”。这意味着不管脚本有多少个实例，变量只有一个副本。</li><li id="75bb" class="lj lk hi jd b je ls jh lt ld lu lf lv lh lw jw mm lp lq lr bi translated">事件—将此变量声明为事件。通过这样做，我们创建了一个允许我们的多维数据集向我们的 ButtonClick()订阅的系统</li><li id="8524" class="lj lk hi jd b je ls jh lt ld lu lf lv lh lw jw mm lp lq lr bi translated">ActionClick —将此事件声明为 ActionClick 类型</li><li id="0777" class="lj lk hi jd b je ls jh lt ld lu lf lv lh lw jw mm lp lq lr bi translated">onClick —给我们的事件变量一个唯一的名称</li></ul><h2 id="e24e" class="lx kk hi bd kl ly lz ma kp mb mc md kt ld me mf kv lf mg mh kx lh mi mj kz mk bi translated">第十行</h2><pre class="jy jz ka kb fd mp mq mr bn ms mt bi"><span id="00f5" class="mu kk hi mq b be mv mw l mx my">public void ButtonClick()</span></pre><p id="5177" class="pw-post-body-paragraph ja jb hi jd b je jf ij jg jh ji im jj ld jl jm jn lf jp jq jr lh jt ju jv jw hb bi translated">这一行简单地声明了一个名为 ButtonClick()的公共方法。</p><h2 id="30f2" class="lx kk hi bd kl ly lz ma kp mb mc md kt ld me mf kv lf mg mh kx lh mi mj kz mk bi translated">第十二行</h2><pre class="jy jz ka kb fd mp mq mr bn ms mt bi"><span id="03f2" class="mu kk hi mq b be mv mw l mx my">if (onClick != null)</span></pre><p id="4faf" class="pw-post-body-paragraph ja jb hi jd b je jf ij jg jh ji im jj ld jl jm jn lf jp jq jr lh jt ju jv jw hb bi translated">这是一行重要的代码。这一行确保我们的事件变量在广播之前有订阅者。如果没有订阅者，则事件为空，没有理由进行广播。</p><p id="00bd" class="pw-post-body-paragraph ja jb hi jd b je jf ij jg jh ji im jj ld jl jm jn lf jp jq jr lh jt ju jv jw hb bi translated">如果有订户，则运行下一行代码…</p><h2 id="54da" class="lx kk hi bd kl ly lz ma kp mb mc md kt ld me mf kv lf mg mh kx lh mi mj kz mk bi translated">第十三行</h2><pre class="jy jz ka kb fd mp mq mr bn ms mt bi"><span id="c7e2" class="mu kk hi mq b be mv mw l mx my">onClick();</span></pre><p id="7f4a" class="pw-post-body-paragraph ja jb hi jd b je jf ij jg jh ji im jj ld jl jm jn lf jp jq jr lh jt ju jv jw hb bi translated">实例化我们的事件变量来访问委托变量存储的方法。</p><h1 id="29f7" class="kj kk hi bd kl km kn ko kp kq kr ks kt io ku ip kv ir kw is kx iu ky iv kz la bi translated">多维数据集脚本</h1><p id="e772" class="pw-post-body-paragraph ja jb hi jd b je lb ij jg jh lc im jj ld le jm jn lf lg jq jr lh li ju jv jw hb bi translated">多维数据集脚本将订阅我们的 onClick 事件。单击按钮后，将运行订阅该事件的任何方法。</p><p id="8341" class="pw-post-body-paragraph ja jb hi jd b je jf ij jg jh ji im jj ld jl jm jn lf jp jq jr lh jt ju jv jw hb bi translated">这个脚本将被附加到我们的三个立方体。</p><figure class="jy jz ka kb fd kc er es paragraph-image"><div class="er es mz"><img src="../Images/a6426561a0e34a8b6ce4adb314e9cdea.png" data-original-src="https://miro.medium.com/v2/resize:fit:1260/format:webp/1*4miF8tIDaWpPR7kgOHf5AQ.png"/></div></figure><p id="0423" class="pw-post-body-paragraph ja jb hi jd b je jf ij jg jh ji im jj ld jl jm jn lf jp jq jr lh jt ju jv jw hb bi translated">这个脚本实际上只有两部分需要解释。</p><ol class=""><li id="d374" class="lj lk hi jd b je jf jh ji ld ll lf lm lh ln jw lo lp lq lr bi translated"><strong class="jd hj">第 10 行</strong> —这是 onClick 事件在这个脚本中被实例化的地方，也是我们为该事件订阅 TurnRed()方法的地方。</li><li id="0915" class="lj lk hi jd b je ls jh lt ld lu lf lv lh lw jw lo lp lq lr bi translated"><strong class="jd hj">第 13 行</strong> —用改变立方体红色所需的代码创建 TurnRed()方法。</li></ol><h1 id="63d3" class="kj kk hi bd kl km kn ko kp kq kr ks kt io ku ip kv ir kw is kx iu ky iv kz la bi translated">试验</h1><p id="73dd" class="pw-post-body-paragraph ja jb hi jd b je lb ij jg jh lc im jj ld le jm jn lf lg jq jr lh li ju jv jw hb bi translated">在运行程序之前，首先我们需要将 ButtonClick()方法连接到按钮。</p><figure class="jy jz ka kb fd kc er es paragraph-image"><div role="button" tabindex="0" class="kd ke di kf bf kg"><div class="er es na"><img src="../Images/f87dbc214005aef5be01ee789fca00eb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*_z4pizRm_5b1OhCLMyxI7w.gif"/></div></div></figure><p id="faec" class="pw-post-body-paragraph ja jb hi jd b je jf ij jg jh ji im jj ld jl jm jn lf jp jq jr lh jt ju jv jw hb bi translated">完成后，让我们运行我们的程序。</p><figure class="jy jz ka kb fd kc er es paragraph-image"><div role="button" tabindex="0" class="kd ke di kf bf kg"><div class="er es nb"><img src="../Images/3fa908c8d9387cfdefb1dd23ddced5d2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*0JNdGti6B262kUetZKjF1w.gif"/></div></div></figure><p id="b5f6" class="pw-post-body-paragraph ja jb hi jd b je jf ij jg jh ji im jj ld jl jm jn lf jp jq jr lh jt ju jv jw hb bi translated">有用！现在让我们讨论它是如何工作的，以及为什么这种编程方式更可取。</p><p id="34ed" class="pw-post-body-paragraph ja jb hi jd b je jf ij jg jh ji im jj ld jl jm jn lf jp jq jr lh jt ju jv jw hb bi translated">使用代理和事件的替代方法是让我们的主脚本知道我们拥有的每一个立方体，运行 for each 循环，然后更改与其关联的每个立方体的颜色。</p><p id="3b39" class="pw-post-body-paragraph ja jb hi jd b je jf ij jg jh ji im jj ld jl jm jn lf jp jq jr lh jt ju jv jw hb bi translated">这个程序<em class="jc">隔离了</em>我们的脚本的功能，所以画布(我们的主脚本附加到其上)不知道立方体(我们的立方体脚本附加到何处)，并且我们的立方体不知道我们的画布。</p><p id="25e5" class="pw-post-body-paragraph ja jb hi jd b je jf ij jg jh ji im jj ld jl jm jn lf jp jq jr lh jt ju jv jw hb bi translated">这允许我们创建一个功能性的，但是模块化的程序。</p></div></div>    
</body>
</html>