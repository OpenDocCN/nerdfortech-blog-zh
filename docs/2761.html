<html>
<head>
<title>Using Retrofit-2 for API Calls</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">对API调用使用refuge-2</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/using-retrofit-2-for-api-calls-674f59355383?source=collection_archive---------2-----------------------#2021-05-19">https://medium.com/nerd-for-tech/using-retrofit-2-for-api-calls-674f59355383?source=collection_archive---------2-----------------------#2021-05-19</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/2fc910487c74e0117e09d4949158edc0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4oWbO58ZGsIKraMste_scQ.jpeg"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">照片由<a class="ae iu" href="https://unsplash.com/@aleks_marinkovic?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">阿列克斯·马林科维奇</a>在<a class="ae iu" href="https://unsplash.com/?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄</figcaption></figure><p id="8046" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">Retrofit是一个类型安全的网络库，它使得android应用程序可以轻松地使用RESTful web服务。它由Square构建，使得获取JSON或XML数据变得容易，这些数据被解析成普通的旧Java对象(POJOs)。<br/>用更简单的语言来说,“翻新”是一个库，它通过提供一种简单的方式来进行网络交易，从而使我们的生活变得更容易。通过基于Rest的web服务从服务器上传或检索数据非常快速和容易。</p><p id="bdb2" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">默认情况下，翻新2利用<a class="ae iu" href="https://www.journaldev.com/13629/okhttp-android-example-tutorial" rel="noopener ugc nofollow" target="_blank"> <strong class="ix hj"> OkHttp </strong> </a>作为网络层，并构建于其上。</p><p id="946b" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">翻新使用POJO(Plain Old Java Object)自动序列化JSON响应，POJO必须预先为JSON结构定义。为了序列化JSON，我们首先需要一个转换器将它转换成Gson。</p><p id="6d6f" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">为了改进，我们需要将以下依赖项添加到我们的<code class="du jt ju jv jw b">build.grade</code>文件中。</p><figure class="jx jy jz ka fd ij"><div class="bz dy l di"><div class="kb kc l"/></div></figure><ul class=""><li id="7012" class="kd ke hi ix b iy iz jc jd jg kf jk kg jo kh js ki kj kk kl bi translated">日志拦截器生成返回的整个响应的日志字符串。</li><li id="7a97" class="kd ke hi ix b iy km jc kn jg ko jk kp jo kq js ki kj kk kl bi translated">默认情况下，翻新2利用<a class="ae iu" href="https://www.journaldev.com/13629/okhttp-android-example-tutorial" rel="noopener ugc nofollow" target="_blank"> <strong class="ix hj"> OkHttp </strong> </a>作为网络层，并构建在它的顶部。</li><li id="2668" class="kd ke hi ix b iy km jc kn jg ko jk kp jo kq js ki kj kk kl bi translated">为了序列化JSON，我们首先需要一个转换器将它转换成Gson</li></ul><p id="4017" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">的第一步</strong>是创建一个POJO类，它表示您想要从API读取或发送到API的数据。</p><p id="d93d" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">假设我们在API和JSON中获取客户信息，如下所示</p><figure class="jx jy jz ka fd ij"><div class="bz dy l di"><div class="kb kc l"/></div></figure><p id="f199" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">因此，现在我们必须创建一个相应的Pojo类，它表示这个JSON中的数据，定义如下-</p><figure class="jx jy jz ka fd ij"><div class="bz dy l di"><div class="kb kc l"/></div></figure><p id="9a67" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">第二步是创建我们的接口类，这有助于用方法定义我们的API端点</p><figure class="jx jy jz ka fd ij"><div class="bz dy l di"><div class="kb kc l"/></div></figure><p id="1ceb" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在上面的类中，我们已经定义了一些执行带有注释的HTTP请求的方法。每个HTTP方法的其他可能的注释列表如下:<code class="du jt ju jv jw b">@GET, @POST, @PUT, @DELETE, @PATCH or @HEAD</code>。</p><p id="096e" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><code class="du jt ju jv jw b">@GET("api/users")</code>谓<code class="du jt ju jv jw b">getCustomerList();</code>。</p><p id="5f62" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><code class="du jt ju jv jw b">getCustomerList()</code>是方法名。<code class="du jt ju jv jw b">CustomerDataModel.java</code>是我们的响应对象的模型POJO类，用于将响应参数映射到它们各自的变量。这些POJO类充当方法返回类型。</p><p id="3ff3" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">方法参数</strong>:有各种各样的参数选项可以在方法内部传递:</p><ul class=""><li id="d5e7" class="kd ke hi ix b iy iz jc jd jg kf jk kg jo kh js ki kj kk kl bi translated"><code class="du jt ju jv jw b">@Body</code>–将Java对象作为请求体发送。</li><li id="89ff" class="kd ke hi ix b iy km jc kn jg ko jk kp jo kq js ki kj kk kl bi translated"><code class="du jt ju jv jw b">@Url</code>–使用动态网址。</li><li id="1307" class="kd ke hi ix b iy km jc kn jg ko jk kp jo kq js ki kj kk kl bi translated"><code class="du jt ju jv jw b">@Query</code>–我们可以简单地用@Query()添加一个方法参数和一个查询参数名，描述类型。要对查询进行URL编码，请使用以下格式:<br/> <code class="du jt ju jv jw b">@Query(value = "auth_token",encoded = true) auth_token:String</code></li><li id="ae48" class="kd ke hi ix b iy km jc kn jg ko jk kp jo kq js ki kj kk kl bi translated"><code class="du jt ju jv jw b">@Field</code>–以form-urlencoded格式发送数据。这需要方法附带一个<code class="du jt ju jv jw b">@FormUrlEncoded</code>注释。<br/><code class="du jt ju jv jw b">@Field</code>参数仅适用于POST</li></ul><p id="7652" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">第三步</strong>是创建我们的改造构建器类，用改造创建网络请求REST API。这是您定义API的基本URL以及其他配置的地方。</p><figure class="jx jy jz ka fd ij"><div class="bz dy l di"><div class="kb kc l"/></div></figure><p id="3a50" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">上面代码中的getAPIInterfaceObject <code class="du jt ju jv jw b">()</code>方法在每次设置改造接口时都会被调用。</p><p id="16a6" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">上面代码片段中的几个重要术语</p><h2 id="1c34" class="kr ks hi bd kt ku kv kw kx ky kz la lb jg lc ld le jk lf lg lh jo li lj lk ll bi translated">读取超时:</h2><p id="47be" class="pw-post-body-paragraph iv iw hi ix b iy lm ja jb jc ln je jf jg lo ji jj jk lp jm jn jo lq jq jr js hb bi translated">一旦连接建立，读取超时就开始注意，然后观察每个字节传输的快慢。如果两个字节之间的时间大于读取超时，它会将请求视为失败。每输入一个字节后，计数器复位。</p><h2 id="7964" class="kr ks hi bd kt ku kv kw kx ky kz la lb jg lc ld le jk lf lg lh jo li lj lk ll bi translated"><strong class="ak">写入超时:</strong></h2><p id="1bc3" class="pw-post-body-paragraph iv iw hi ix b iy lm ja jb jc ln je jf jg lo ji jj jk lp jm jn jo lq jq jr js hb bi translated">写超时与读超时方向相反。它检查你发送字节到服务器的速度。当然，它也会在每个成功字节后复位。但是，如果发送一个字节花费的时间超过配置的写入超时限制，翻新会将请求视为失败。</p><h2 id="6602" class="kr ks hi bd kt ku kv kw kx ky kz la lb jg lc ld le jk lf lg lh jo li lj lk ll bi translated">连接超时</h2><p id="ed5c" class="pw-post-body-paragraph iv iw hi ix b iy lm ja jb jc ln je jf jg lo ji jj jk lp jm jn jo lq jq jr js hb bi translated">连接超时可能是最重要的超时。它是从开始请求到完成与服务器的TCP握手之间的时间。换句话说，如果Retrofit无法在设置的连接超时限制内建立到服务器的连接，它会将请求视为失败。</p><h2 id="2c7a" class="kr ks hi bd kt ku kv kw kx ky kz la lb jg lc ld le jk lf lg lh jo li lj lk ll bi translated"><strong class="ak">通话超时</strong></h2><p id="8c28" class="pw-post-body-paragraph iv iw hi ix b iy lm ja jb jc ln je jf jg lo ji jj jk lp jm jn jo lq jq jr js hb bi translated">呼叫超时设置完整呼叫的默认超时。调用超时跨越整个调用:解析DNS、连接、编写请求正文、服务器处理和读取响应正文。换句话说，如果从开始到结束的整个API调用没有在所述时间限制内完成，那么它将把请求计为失败。</p><p id="7868" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">现在我们完成了设置，让我们从活动类中调用API。</p><figure class="jx jy jz ka fd ij"><div class="bz dy l di"><div class="kb kc l"/></div></figure><p id="c57e" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">异步发送请求，并在响应返回时用回调通知你的应用程序。因为这个请求是异步的，所以request在后台线程上处理它，这样主UI线程就不会被阻塞或干扰。</p><p id="461c" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">要使用<code class="du jt ju jv jw b">enqueue()</code>，您必须实现两个回调方法:</p><ul class=""><li id="f893" class="kd ke hi ix b iy iz jc jd jg kf jk kg jo kh js ki kj kk kl bi translated"><code class="du jt ju jv jw b">onResponse()</code></li><li id="6365" class="kd ke hi ix b iy km jc kn jg ko jk kp jo kq js ki kj kk kl bi translated"><code class="du jt ju jv jw b">onFailure()</code></li></ul><p id="3cb4" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如果一切顺利，那么回调将落在OnResponse()方法上，从那里您可以更新您的API，如果有任何错误或异常，那么onFailure()方法将被调用。</p><p id="610c" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><em class="lr">暂时就这样吧！！<br/>感谢阅读，别忘了与你的开发伙伴分享:)<br/>这篇文章最初发表在</em><a class="ae iu" href="https://www.codetheraphy.com/" rel="noopener ugc nofollow" target="_blank"><em class="lr">CodeTheraphy.com</em></a><em class="lr">。</em></p><p id="5fb3" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><em class="lr">更多文章关注我上</em> <a class="ae iu" rel="noopener" href="/@nandishswarup"> <em class="lr">中</em> </a> <em class="lr">和</em><a class="ae iu" href="https://www.codetheraphy.com/" rel="noopener ugc nofollow" target="_blank"><em class="lr">CodeTheraphy.com</em></a><em class="lr">你也可以联系我上</em><a class="ae iu" href="http://www.linkedin.com/in/nandish-swarup" rel="noopener ugc nofollow" target="_blank"><em class="lr">LinkedIn</em></a></p></div></div>    
</body>
</html>