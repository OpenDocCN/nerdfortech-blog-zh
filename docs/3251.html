<html>
<head>
<title>Basics of Javascript · String · match() (method)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Javascript 字符串匹配()的基础知识(方法)</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/basics-of-javascript-string-match-method-ce47295bfd97?source=collection_archive---------12-----------------------#2021-06-03">https://medium.com/nerd-for-tech/basics-of-javascript-string-match-method-ce47295bfd97?source=collection_archive---------12-----------------------#2021-06-03</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/7a65458d5eeaec8dee260447070d54a5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QJp7wWj5r0zAVxKwT7g6ZQ.png"/></div></div></figure><p id="070f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这篇文章是我在 youtube 上免费发表的关于网络开发基础的系列文章的抄本。如果你更喜欢看而不是读，请随时访问我的频道“Dev Newbs”。T3】</p><figure class="jp jq jr js fd ij"><div class="bz dy l di"><div class="jt ju l"/></div></figure><p id="94da" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">各位开发者朋友，你们好！我们今天要讲的方法并不令人愉快。这是一个可以使用的强大工具，但是您需要首先掌握正则表达式。这听起来不像是基本知识，你可能是对的。但是不要太担心。我将指导你完成基本的工作，所以如果你将来需要它，你只需要一点额外的谷歌搜索来覆盖你的特殊情况，就可以实现你需要的任何东西。说够了…让我们开始吧！</p><p id="2745" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">match()方法在字符串中搜索正则表达式的匹配项，并将匹配项作为数组对象返回。</p><p id="0efe" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如果正则表达式不包含“g”标志，我们将在索引 0 处获得数组对象的结果。产生的数组对象的格式与我们调用正则表达式上的方法 exec()传递引用的字符串的格式相同。数组对象包含额外的数据，如匹配第一次出现的索引、原始输入等。</p><p id="9d88" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如果我们使用“g”标志，得到的数组对象只包含匹配项，不包含任何其他内容。</p><p id="787c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">好了，理论到此为止。让我们回到现实世界。或者…你知道…虚拟的那个。</p><pre class="jp jq jr js fd jv jw jx jy aw jz bi"><span id="e6ed" class="ka kb hi jw b fi kc kd l ke kf">let str = "The main bulk of rain will fall in SPAIN. That's our gain.";</span><span id="fb28" class="ka kb hi jw b fi kg kd l ke kf">let regExp = /ain/;<br/>let regExpG = /ain/g;<br/>let regExpGI = /ain/gi;</span><span id="5e68" class="ka kb hi jw b fi kg kd l ke kf">str.match(regExpG)                   // ["ain","ain","ain"]</span><span id="5c05" class="ka kb hi jw b fi kg kd l ke kf">str.match(regExpGI)                  // ["ain","ain","AIN","ain"]</span><span id="a308" class="ka kb hi jw b fi kg kd l ke kf">str.match(regExp)                    <br/>// [<br/>//   "ain",<br/>//   groups: undefined,<br/>//   index: 5, <br/>//   input: "The main bulk of rain will fall in SPAIN. That's...",<br/>//   length: 0<br/>// ]</span><span id="7644" class="ka kb hi jw b fi kg kd l ke kf">regExp.exec(str)<br/>// [<br/>//   "ain",<br/>//   groups: undefined,<br/>//   index: 5, <br/>//   input: "The main bulk of rain will fall in SPAIN. That's...",<br/>//   length: 0<br/>// ]</span><span id="e5aa" class="ka kb hi jw b fi kg kd l ke kf">(str.match(regExp))[0]                   // ain</span></pre><p id="6a30" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">第一种情况使用正则表达式搜索带有附加标志“g”的字符串“ain ”,该标志指定我们希望找到所有匹配。得到的数组包含 3 个匹配项。</p><p id="8527" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">第二种情况使用了一个额外的标志“I ”,告诉该方法它不关心大小写。由于这个事实，它在单词“西班牙”中找到了一个额外的出现。</p><p id="77f5" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">最后一种情况显示了当我们不使用全局标志“g”时会发生什么。结果只是第一个匹配项，它存储在索引为 0 的结果数组对象的第一个位置。</p><p id="f1bb" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">使用正则表达式时，一个非常重要的特性是定义允许的字符集。如果我想找到任何大写字符，我可以显式地将它们写在方括号中，或者我可以使用破折号来指定一个序列，只提供序列的第一个和最后一个字符。</p><pre class="jp jq jr js fd jv jw jx jy aw jz bi"><span id="9644" class="ka kb hi jw b fi kc kd l ke kf">let str2 = "The quick brown fox jumps over the lazy dog. It barked.";</span><span id="8fda" class="ka kb hi jw b fi kg kd l ke kf">let regExpUpper = /[A-Z]/g;<br/>let regExpLower = /[a-z]/g;<br/>let regExpOther = /[ .]/g;</span><span id="b695" class="ka kb hi jw b fi kg kd l ke kf">let regExpCapital = /[A-Z][a-z]*/g;</span><span id="ec47" class="ka kb hi jw b fi kg kd l ke kf">str2.match(regExpUpper)               // ["T","I"]<br/>str2.match(regExpUpper).length        // 2</span><span id="765f" class="ka kb hi jw b fi kg kd l ke kf">str2.match(regExpLower)               // ["h","e","q",...]<br/>str2.match(regExpLower).length        // 41</span><span id="a007" class="ka kb hi jw b fi kg kd l ke kf">str2.match(regExpOther)               // [" ",...," ","."]<br/>str2.match(regExpOther).length        // 12</span><span id="4e07" class="ka kb hi jw b fi kg kd l ke kf">str2.match(regExpCapital)             // ["The","It"]<br/>str2.match(regExpCapital).length      // 2</span></pre><p id="aeea" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我想将字符串中的字符分成三组:大写、小写和剩余的字符。</p><p id="ceca" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">最后有一个额外的正则表达式——假设我们想要获取所有以大写字母开头的单词。我们首先指定第一个字符应该来自一组大写字母，后面是零个或多个小写字母。第二个方括号后的星号表示这一点。仅此而已。</p><p id="e172" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">好了，继续。让我们玩特定类型的角色。数字是一个很好的选择，所以我们就用数字吧。我们可以有一份提及具体章节的文本，我们希望找到所有这些参考资料。让我们来看看如何做到这一点。</p><pre class="jp jq jr js fd jv jw jx jy aw jz bi"><span id="2578" class="ka kb hi jw b fi kc kd l ke kf">let str3 = "Chapter 2.7 This text contains references to chapter 4.2.1 &amp; also to chapter 5";</span><span id="4b09" class="ka kb hi jw b fi kg kd l ke kf">let regExp3 = /chapter \d+(\.\d)*/gi;</span><span id="804e" class="ka kb hi jw b fi kg kd l ke kf">str3.match(regExp3)   // ["Chapter 2.7","chapter 4.2.1","chapter 5"]</span></pre><p id="8e72" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们希望找到单词“chapter ”,后跟由数字组成的章节号，数字之间可能用点分隔。我们不关心单词“chapter”是以小写还是大写开头。我们想找到所有的事件。</p><p id="dc20" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">第一步是指定“g”和“I”标志。然后我们指定单词“章”，空格，然后我们使用反斜杠和字母“d”来表示我们正在寻找一个数字。我们需要至少一个数字，所以我们添加了一个加号字符。现在，这一章可以只有一个数字，没有点，后面跟着一个子章节号。因此，我们目前掌握的信息涵盖了这些案例。然而，子章节数字后面可能有零个或更多的点，所以我们在后面加上带星号的括号来表示。在括号内，我们指定我们期望一个点。点是一个特殊的字符，表示任何字符的一部分，所以我们需要用反斜杠对它进行转义。然后我们用反斜杠加字符“d”来表示另一个数字。仅此而已。</p><p id="8570" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">感谢您坚持使用本系列，即使是在最后两种方法之后，这是迄今为止最具挑战性的方法。我希望你也学到了新的东西。</p><p id="a539" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">感谢您坚定不移的关注，我希望我们能在下一篇文章中再次见面。</p></div></div>    
</body>
</html>