<html>
<head>
<title>Creating a Basic CLI Game with Object Inheritance and Join Class (Repl included)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用对象继承和加入类创建一个基本的 CLI 游戏(包括 Repl)</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/creating-a-basic-cli-game-with-oop-77d7cb7516e8?source=collection_archive---------1-----------------------#2021-02-03">https://medium.com/nerd-for-tech/creating-a-basic-cli-game-with-oop-77d7cb7516e8?source=collection_archive---------1-----------------------#2021-02-03</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/8af400b2a06c4e51c253373e44222712.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*REXJ566QG4HWfgYD-ZICjg.gif"/></div></div></figure><p id="7485" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">所以是时候开始我在熨斗学校的第一个项目了。除了必须抓取一个站点或使用一个 API 和最终结果是一个命令行界面(CLI)应用程序，没有任何其他限制。但是当我第一次开始的时候，我甚至不知道关于抓取/API 的需求，但是这不是这篇文章的重点。</p><p id="8e85" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我一直喜欢游戏，我记得在某处读到过，最早的 RPG 之一是 CLI 游戏！当我给我的团队领导(也就是老师)发消息说我想做一个 CLI RPG 时，我可能极度缺乏睡眠。那时，我认为我们甚至还没有完成课程中 Ruby 部分的面向对象编程(OOP)。</p><p id="3d01" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">所以那时，我很困惑如何才能把生命值和法力值加入到游戏中。我如何记录我杀了多少怪物？我如何攻击怪物？怪物会怎么攻击我？一切事物之间将如何相互联系？谁来记录这一切？</p><p id="f17c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我压力太大了。</p><figure class="jp jq jr js fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es jo"><img src="../Images/4caf9d62aee7bc522cc59d5b3960a322.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*kuvGLmnW-4G0VggV"/></div></div><figcaption class="jt ju et er es jv jw bd b be z dx translated"><a class="ae jx" href="https://unsplash.com/@matthewhenry?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">马太·亨利</a>在<a class="ae jx" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍照</figcaption></figure></div><div class="ab cl jy jz gp ka" role="separator"><span class="kb bw bk kc kd ke"/><span class="kb bw bk kc kd ke"/><span class="kb bw bk kc kd"/></div><div class="hb hc hd he hf"><h1 id="62d5" class="kf kg hi bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc bi translated"><strong class="ak">对象继承</strong></h1><p id="5794" class="pw-post-body-paragraph iq ir hi is b it ld iv iw ix le iz ja jb lf jd je jf lg jh ji jj lh jl jm jn hb bi translated">于是几天过去了，我们学完了对象关系，但我仍然很困惑。</p><p id="22ad" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">但是，嘿，我知道我是那种能从很多很多错误中学习的人。我甚至不知道自己在做什么，就开始编写游戏代码。</p><pre class="jp jq jr js fd li lj lk ll aw lm bi"><span id="9abb" class="ln kg hi lj b fi lo lp l lq lr">class Elf</span><span id="60bb" class="ln kg hi lj b fi ls lp l lq lr">attr_accessor :name, :health, :mana, :evilness, :happiness, :hp_pots, :mp_pots, :friends_made</span><span id="6528" class="ln kg hi lj b fi ls lp l lq lr">   def initialize<br/>       <br/>       @health = 60<br/>       @mana = 60<br/>       @evilness = 0<br/>       @happiness = 2<br/>       @hp_pots = 20<br/>       @mp_pots = 20<br/>       @friends_made = []</span><span id="3406" class="ln kg hi lj b fi ls lp l lq lr">   end</span><span id="3bee" class="ln kg hi lj b fi ls lp l lq lr">end </span></pre><p id="1f6e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在，我认为这是一个很好的主意。看看它有多有条理！但后来我想在未来创造更多的种族。只有一场比赛的游戏会很无聊，你不觉得吗？那么我是不是必须将所有的实例变量复制粘贴到我的其他类中？呀。</p><p id="f08c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">但是后来，我们在课程中进展到了<strong class="is hj">对象继承</strong>。我得救了。对于像我这样的新手来说，Ruby 是一门非常棒的语言。顾名思义，一个对象可以继承另一个对象的特征！多棒啊。</p><figure class="jp jq jr js fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lt"><img src="../Images/3d02035215f1c3ac97be270fde28d697.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*IiUX2jlSEaIdbLJg"/></div></div><figcaption class="jt ju et er es jv jw bd b be z dx translated"><a class="ae jx" href="https://unsplash.com/@honestpaws?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">诚实的爪子</a>在<a class="ae jx" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍照</figcaption></figure><p id="6d5c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">它是如何工作的？让我们首先创建<strong class="is hj">父类</strong>。这是一个拥有我希望我的<strong class="is hj">子类</strong>(或<strong class="is hj">子类</strong>)拥有的所有基本特征的类。我将在/lib 文件夹的 Race.rb 中创建<strong class="is hj">父类</strong>。</p><pre class="jp jq jr js fd li lj lk ll aw lm bi"><span id="3629" class="ln kg hi lj b fi lo lp l lq lr">class Race</span><span id="8f22" class="ln kg hi lj b fi ls lp l lq lr">attr_accessor :health, :mana, :evilness, :happiness, :hp_pots, :mp_pots, :friends_made</span><span id="2fc9" class="ln kg hi lj b fi ls lp l lq lr">   def initialize<br/>      <br/>       @health = 60<br/>       @mana = 60<br/>       @evilness = 0<br/>       @happiness = 2<br/>       @hp_pots = 20<br/>       @mp_pots = 20<br/>       @friends_made = []</span><span id="53b4" class="ln kg hi lj b fi ls lp l lq lr">   end</span><span id="cae7" class="ln kg hi lj b fi ls lp l lq lr">end </span></pre><p id="eb21" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我希望每个<strong class="is hj">子类</strong>都有不同的生命值和法力值，所以我决定把这些特性从<code class="du lu lv lw lj b"><strong class="is hj">initialize</strong></code>方法中去掉。但是我仍然保留了<code class="du lu lv lw lj b"><strong class="is hj">attr_accessor</strong></code> <strong class="is hj"> </strong>，因为我根本<em class="lx"/>不愿意在每次我想要创建一个新类的时候复制并粘贴整个文本块。</p><p id="f311" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">所以现在我们有了一个<strong class="is hj">父类</strong>，我们可以产生一个<strong class="is hj">子类</strong>。我们如何继承那些可爱的特质？让我们看看！</p><p id="c496" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我将创建一些<strong class="is hj">子类</strong>。一个在/lib 文件夹的 Elf.rb 文件中。另一个名为 Giant.rb，也位于/lib 文件夹中。这样，当我在<strong class="is hj">的父类</strong>上调用<code class="du lu lv lw lj b"><strong class="is hj">require_relative</strong></code>时，它不会在目录中很靠前。</p><p id="eac5" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这是 Elf.rb 文件。</p><pre class="jp jq jr js fd li lj lk ll aw lm bi"><span id="5a72" class="ln kg hi lj b fi lo lp l lq lr">require_relative 'Race'</span><span id="a6ec" class="ln kg hi lj b fi ls lp l lq lr">class Elf &lt; Race</span><span id="a18d" class="ln kg hi lj b fi ls lp l lq lr">   def initialize<br/>       super<br/>       self.health = 60<br/>       self.mana = 80<br/>   end</span><span id="ed60" class="ln kg hi lj b fi ls lp l lq lr">end </span></pre><p id="2017" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这是 Giant.rb 文件。</p><pre class="jp jq jr js fd li lj lk ll aw lm bi"><span id="3502" class="ln kg hi lj b fi lo lp l lq lr">require_relative ‘Race’</span><span id="0ef0" class="ln kg hi lj b fi ls lp l lq lr">class Giant &lt; Race</span><span id="2f6f" class="ln kg hi lj b fi ls lp l lq lr">   def initialize <br/>       super<br/>       self.health = 120<br/>       self.mana = 30<br/>       self.happiness = 4</span><span id="fdfc" class="ln kg hi lj b fi ls lp l lq lr">end </span></pre><p id="54bf" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">让我们打破这一点！</p><pre class="jp jq jr js fd li lj lk ll aw lm bi"><span id="2114" class="ln kg hi lj b fi lo lp l lq lr">require_relative ‘Race’</span></pre><p id="2cff" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这一行意味着我所在的当前文件(无论是 Elf.rb 还是 Giant.rb)将需要其他文件中的另一个文件(它是我所在的当前文件的相对路径)才能工作。Ruby 很聪明，知道我指的是一个 Ruby 文件，所以我只保留了“Race”这个文件名。我不需要指出任何目录，因为它们都存在于同一个文件夹中！可爱！</p><p id="fcd7" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">无论如何，如果我不需要“Race ”,并且我试图运行我的 Elf.rb 文件，我将收到一条红色的错误消息，内容如下:</p><pre class="jp jq jr js fd li lj lk ll aw lm bi"><span id="bffb" class="ln kg hi lj b fi lo lp l lq lr">uninitialized constant ‘Race’</span></pre><p id="1e52" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">接下来我们来分解一下。</p><pre class="jp jq jr js fd li lj lk ll aw lm bi"><span id="b952" class="ln kg hi lj b fi lo lp l lq lr">class Elf &lt; Race</span></pre><p id="bf7b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这意味着 Elf 是一个种族的孩子。Elf 将继承种族职业中现有的一切。这包括所有的<code class="du lu lv lw lj b"><strong class="is hj">attr_accessor</strong></code>宏和<code class="du lu lv lw lj b"><strong class="is hj">initialize</strong></code>中实例变量的设置。</p><p id="82d5" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">但是目前种族职业没有任何生命值和法力值！那是因为我希望每场比赛都以不同的生命值和法力值开始！这就是为什么我手动设置生命值和法力值。我使用了<code class="du lu lv lw lj b"><strong class="is hj">self.health=</strong></code>和<code class="du lu lv lw lj b"><strong class="is hj">self.mana=</strong></code>，因为我已经定义了定制的生命和法力设置方法。因此，我没有仅仅设置 health 实例变量和 mana 实例变量，而是调用了<code class="du lu lv lw lj b"><strong class="is hj">self.health=</strong></code>和<code class="du lu lv lw lj b"><strong class="is hj">self.mana=</strong></code>来分别设置 health 和 mana。</p><p id="593b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">再来看巨班。</p><pre class="jp jq jr js fd li lj lk ll aw lm bi"><span id="2a7e" class="ln kg hi lj b fi lo lp l lq lr">def initialize<br/>    super<br/>    self.health = 120<br/>    self.mana = 30<br/>    self.happiness = 4<br/>end</span></pre><p id="d5c0" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在 initialize 方法中写‘super’会告诉 Ruby 我希望 Giant 类继承 Race 类<code class="du lu lv lw lj b"><strong class="is hj">initialize</strong></code>方法拥有的一切。</p><p id="0042" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在，当 Race 类已经设置了 happy 实例变量时，为什么我还要设置<code class="du lu lv lw lj b"><strong class="is hj">self.happiness = 4</strong></code>？这不是错误。我希望巨人职业比其他子种族更快乐，所以我决定覆盖种族职业的设置<code class="du lu lv lw lj b"><strong class="is hj">@happiness</strong></code>。同样，我为 happy 属性创建了一个定制的 setter 方法，所以我调用了那个 setter 方法，而不是简单地将属性设置为 4。</p><p id="841f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如果我愿意，我也可以用<code class="du lu lv lw lj b"><strong class="is hj">@evilness</strong></code>实例变量来做这件事。我要做的就是:</p><pre class="jp jq jr js fd li lj lk ll aw lm bi"><span id="1c5c" class="ln kg hi lj b fi lo lp l lq lr">def initialize<br/>    super<br/>    self.evilness = 8<br/>end</span></pre><p id="2886" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">所以每当我觉得需要改变一些最初在父种族类中设置的属性时，我所要做的就是在<strong class="is hj">子类</strong>中覆盖它。</p><p id="fc8d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">使用<strong class="is hj">对象继承</strong>非常有助于创建共享公共方法和公共统计信息的类(它们将被设置为实例变量)。</p><p id="69eb" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">另一个例子是这些 Race 方法。每当我创建一个新的子种族类，这个孩子将继承所有这些方法！所以现在我连复制粘贴都不用了。那种方式不是比我以前的效率更高吗？</p><pre class="jp jq jr js fd li lj lk ll aw lm bi"><span id="19e1" class="ln kg hi lj b fi lo lp l lq lr">class Race</span><span id="1d19" class="ln kg hi lj b fi ls lp l lq lr">#there are other methods here </span><span id="b786" class="ln kg hi lj b fi ls lp l lq lr">   def check_mana<br/>       self.mana == 0<br/>   end </span><span id="186f" class="ln kg hi lj b fi ls lp l lq lr">   def check_mp_pot<br/>    self.mp_pots == 0<br/>   end </span><span id="930e" class="ln kg hi lj b fi ls lp l lq lr">   def check_hp_pot<br/>       self.hp_pots == 0<br/>   end </span><span id="4547" class="ln kg hi lj b fi ls lp l lq lr">   def death?<br/>       self.health == 0<br/>   end</span><span id="ecc4" class="ln kg hi lj b fi ls lp l lq lr">end </span></pre><p id="fd45" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在我们来看看记录玩家和怪物攻击的问题。谁记录什么？</p><p id="85a4" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">所以每个亚种族类都存在于他们自己的文件中。精灵对怪物的存在一无所知。这也意味着怪物还不知道精灵类的存在。但是，它们可以通过 CLI 类相互“交互”。我调用了我的 CLI 类 Rubytopia。Rubytopia 将是加入所有东西(我所有的怪物和我所有的子种族)的职业！Rubytopia 不仅是我的 CLI 类，也是我的“join”类。</p><h1 id="8ba9" class="kf kg hi bd kh ki ly kk kl km lz ko kp kq ma ks kt ku mb kw kx ky mc la lb lc bi translated">什么是联接类？</h1><p id="d59d" class="pw-post-body-paragraph iq ir hi is b it ld iv iw ix le iz ja jb lf jd je jf lg jh ji jj lh jl jm jn hb bi translated">嗯，那是我为我的亚种族职业和怪物创造方法的地方，这样他们将会有战斗！只有在 Rubytopia 类中，他们才能互相争斗。简单地说，join 类连接所有的东西。一切都可以通过 join 类与彼此的信息进行交互。</p><p id="67ad" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">让我给你看看！</p><p id="a44d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">所以我有一个叫巫师的怪物。这是巫师. rb 文件的一部分。魔法师现在只知道它自己。在初始化时，它本身不能做太多事情。精灵类也是如此。</p><pre class="jp jq jr js fd li lj lk ll aw lm bi"><span id="ff2f" class="ln kg hi lj b fi lo lp l lq lr">class Sorcerer<br/>   attr_accessor :health, :name</span><span id="ac73" class="ln kg hi lj b fi ls lp l lq lr">   def initialize<br/>       self.health = 60<br/>       self.name_set #I have a method that randomly sets the name<br/>   end</span><span id="ef04" class="ln kg hi lj b fi ls lp l lq lr">   def reply<br/>   #####some method that gives a reply as a string<br/>   end</span><span id="bd15" class="ln kg hi lj b fi ls lp l lq lr">end</span></pre><p id="48d7" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这是我的 Rubytopia 文件的一部分。</p><pre class="jp jq jr js fd li lj lk ll aw lm bi"><span id="04e7" class="ln kg hi lj b fi lo lp l lq lr">class Rubytopia<br/>   attr_accessor :monster, :player</span><span id="93ad" class="ln kg hi lj b fi ls lp l lq lr">   def create_elf<br/>       self.player = Elf.new<br/>   end</span><span id="482e" class="ln kg hi lj b fi ls lp l lq lr">   def sorcerer_encounter<br/>       self.monster = Sorcerer.new<br/>   end</span><span id="7f73" class="ln kg hi lj b fi ls lp l lq lr">end</span></pre><p id="8704" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">所以现在鲁比托邦有一个巫师和一个精灵。Rubytopia 有一个名为<code class="du lu lv lw lj b"><strong class="is hj">@monster</strong></code>的属性，它跟踪当前的 monster 对象。稍后，我可以访问怪物对象的健康状况，看看战斗序列是否应该继续。同样，Rubytopia 也有一个<code class="du lu lv lw lj b"><strong class="is hj">@player</strong></code>属性，用于跟踪当前玩家(子种族对象)以及玩家的健康和法力。现在是编码的时候了——神奇！</p><p id="9fa3" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">以下代码存在于 Rubytopia 中。</p><pre class="jp jq jr js fd li lj lk ll aw lm bi"><span id="7db3" class="ln kg hi lj b fi lo lp l lq lr">def player_turn<br/>   counter = 0<br/>   while counter &lt; 7<br/>      self.player_turn_choice<br/>      break if self.monster_or_player_death<br/>      self.monster_turn<br/>      break if self.monster_or_player_death<br/>      counter += 1<br/>   end</span><span id="ae8c" class="ln kg hi lj b fi ls lp l lq lr">   ##there is a little bit more to this method<br/>   ##but it doesn't highlight the beauty of the join class<br/>end </span></pre><p id="4ff6" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">所以即使没有我展示什么是<code class="du lu lv lw lj b"><strong class="is hj">self.player_turn_choice</strong></code>方法，你也可以猜到它可能只是玩家的选择。同样的还有<code class="du lu lv lw lj b"><strong class="is hj">self.monster_or_player_death</strong></code>和<code class="du lu lv lw lj b"><strong class="is hj">self.monster_turn</strong></code>。</p><p id="e9d1" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">只是为了让我的代码更紧凑，我用了一个代码来检查怪物和玩家的健康状况，因此方法名为<code class="du lu lv lw lj b"><strong class="is hj">monster_or_player_death</strong></code>。(但这只是我的偏好。)join 类可以访问 monster 和 sub Race 的信息，因为它们是作为 Rubytopia 的属性存在的(还有 CLI 类和 join 类)。Rubytopia 可以通过对象的 reader 方法访问数据，比如每个对象的健康状况！编码魔术！</p><p id="e8b8" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">所以这是怪物和次种族可以相互影响的例子之一。虽然从来没有直接，但由于 join 类，它们能够存在于同一个方法中。如果我愿意，我还可以创建一个方法，让他们互相交谈！这就是 join 类的神奇之处。它(同时)赋予了两个阶层生命，否则他们不会知道彼此的存在！</p><h1 id="0b1c" class="kf kg hi bd kh ki ly kk kl km lz ko kp kq ma ks kt ku mb kw kx ky mc la lb lc bi translated">while/until 循环</h1><p id="eaeb" class="pw-post-body-paragraph iq ir hi is b it ld iv iw ix le iz ja jb lf jd je jf lg jh ji jj lh jl jm jn hb bi translated">上面显示的<code class="du lu lv lw lj b"><strong class="is hj">player_turn</strong></code>方法是我想解决的最后一个方法之一，因为我对<em class="lx"/><strong class="is hj">while 循环</strong>的理解很肤浅。</p><p id="aec7" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">那么为什么我要在我的方法中使用它呢？</p><p id="9035" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">因为它能完成任务。只要<code class="du lu lv lw lj b"><strong class="is hj">self.monster_or_player_death</strong></code>是假的，我就想让玩家留在战斗中(由<code class="du lu lv lw lj b"><strong class="is hj"> player_turn</strong></code>处理)。想象一下，必须编写一个没有循环的遇到怪物的简单游戏！我将不得不硬编码每一个怪物的遭遇！这听起来…很痛苦。</p><p id="fb5e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">让我们再看一遍 while 循环代码片段，但这次我们将着眼于<code class="du lu lv lw lj b"><strong class="is hj">while</strong></code>循环的功能，而不是类交互。</p><pre class="jp jq jr js fd li lj lk ll aw lm bi"><span id="7393" class="ln kg hi lj b fi lo lp l lq lr">def player_turn<br/>   counter = 0<br/>   while counter &lt; 7<br/>      self.player_turn_choice<br/>      break if self.monster_or_player_death<br/>      self.monster_turn<br/>      break if self.monster_or_player_death<br/>      counter += 1<br/>   end</span><span id="7ac1" class="ln kg hi lj b fi ls lp l lq lr">   ##there is a little bit more to this method<br/>   ##but it doesn't highlight the beauty of the join class<br/>end</span></pre><p id="5795" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">只要计数器小于 7，<code class="du lu lv lw lj b"><strong class="is hj">player_turn</strong></code>方法就会遍历 while 循环中的块。每次循环时，它都会执行:</p><ul class=""><li id="4254" class="md me hi is b it iu ix iy jb mf jf mg jj mh jn mi mj mk ml bi translated"><code class="du lu lv lw lj b"><strong class="is hj">self.player_turn_choice</strong></code></li><li id="7263" class="md me hi is b it mm ix mn jb mo jf mp jj mq jn mi mj mk ml bi translated">检查<code class="du lu lv lw lj b"><strong class="is hj">self.monster_or_player_death</strong></code>是否为真(如果为真将中断循环)</li><li id="3699" class="md me hi is b it mm ix mn jb mo jf mp jj mq jn mi mj mk ml bi translated"><code class="du lu lv lw lj b"><strong class="is hj">self.monster_turn</strong></code></li><li id="000b" class="md me hi is b it mm ix mn jb mo jf mp jj mq jn mi mj mk ml bi translated">检查<code class="du lu lv lw lj b"><strong class="is hj">self.monster_or_player_death</strong></code>是否为真(如果为真将中断循环)</li><li id="725b" class="md me hi is b it mm ix mn jb mo jf mp jj mq jn mi mj mk ml bi translated">将本地变量<code class="du lu lv lw lj b"><strong class="is hj">counter</strong></code>加 1，并重新分配<code class="du lu lv lw lj b"><strong class="is hj">counter</strong></code>的值</li><li id="c9ce" class="md me hi is b it mm ix mn jb mo jf mp jj mq jn mi mj mk ml bi translated">回到循环的起点。</li></ul><p id="055b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">因此，在一个正常运行的循环中，有两件事会打破这个循环:</p><ul class=""><li id="c98a" class="md me hi is b it iu ix iy jb mf jf mg jj mh jn mi mj mk ml bi translated">循环结束时到达 7</li><li id="11e7" class="md me hi is b it mm ix mn jb mo jf mp jj mq jn mi mj mk ml bi translated"><code class="du lu lv lw lj b"><strong class="is hj">self.monster_or_player_death</strong></code>返回 true。</li></ul><p id="ac60" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">起初我只在循环中检查了一次<code class="du lu lv lw lj b"><strong class="is hj">self.monster_or_player_death</strong></code>。然后我玩了一遍游戏来测试 bug，看到怪物攻击我，尽管它的生命值为 0！这时我意识到我必须在<code class="du lu lv lw lj b"><strong class="is hj">self.monster_turn</strong></code>之后再投入一张支票。</p><p id="6446" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">虽然循环肯定是有帮助的，但可能需要尝试几次才能让方法运行起来，但它绝对值得使用！</p><h2 id="0a40" class="ln kg hi bd kh mr ms mt kl mu mv mw kp jb mx my kt jf mz na kx jj nb nc lb nd bi translated">现在开始直到循环！</h2><p id="0aa5" class="pw-post-body-paragraph iq ir hi is b it ld iv iw ix le iz ja jb lf jd je jf lg jh ji jj lh jl jm jn hb bi translated">我在<code class="du lu lv lw lj b"><strong class="is hj">start</strong></code>方法中使用了一个<code class="du lu lv lw lj b"><strong class="is hj">until</strong></code>循环。<code class="du lu lv lw lj b"><strong class="is hj">start</strong></code>方法是让 Rubytopia 实例开始运行的方法。你可以想象在我们到达<code class="du lu lv lw lj b"><strong class="is hj">until</strong></code>循环之前还有其他方法，但是这些现在并不重要。</p><pre class="jp jq jr js fd li lj lk ll aw lm bi"><span id="3b26" class="ln kg hi lj b fi lo lp l lq lr">class Rubytopia<br/>   #the list of attr_accessor</span><span id="c330" class="ln kg hi lj b fi ls lp l lq lr">   def start <br/>      #other methods that get invoked prior to this loop<br/>      until self.over?<br/>         self.event_generator<br/>      end<br/>   end</span><span id="3918" class="ln kg hi lj b fi ls lp l lq lr">end</span></pre><p id="2fde" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这段代码只是说，在<code class="du lu lv lw lj b"><strong class="is hj">self.over?</strong></code>方法返回真值之前，<code class="du lu lv lw lj b"><strong class="is hj">self.event_generator</strong></code>(随机生成大量其他事件的方法)将继续执行。</p><p id="e5b1" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">虽然你可能不知道<code class="du lu lv lw lj b"><strong class="is hj">over?</strong></code>的确切代码，但你可以从它的名字中猜出它测试游戏是否结束。</p><p id="43fd" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">使用 until 循环比手动告诉我的程序生成一个事件一定次数要好得多。</p><h1 id="02b2" class="kf kg hi bd kh ki ly kk kl km lz ko kp kq ma ks kt ku mb kw kx ky mc la lb lc bi translated">结论</h1><p id="1f28" class="pw-post-body-paragraph iq ir hi is b it ld iv iw ix le iz ja jb lf jd je jf lg jh ji jj lh jl jm jn hb bi translated">唷！要读的东西太多了！</p><figure class="jp jq jr js fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ne"><img src="../Images/e9770814665f8224be14c24ef5b1b75d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*DxyjQEiZSsq7CaCUesnW6w.gif"/></div></div></figure><p id="9897" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">起初，对象关系可能真的令人困惑。一开始我不知道该如何构建我的游戏。老实说，我甚至不知道 join 类将如何与我的游戏一起工作。在我尝试构建我的游戏的第一天，我试图让我的 Elf 类访问关于怪物的数据。我的一些脑细胞死于这种混乱的想法。</p><p id="0558" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">学习如何优化项目中的每一个对象关系确实需要时间！我试错了很多次，才明白什么是可行的，什么是绝对疯狂的。在旅程的开始，我在 Rubytopia 类中为<code class="du lu lv lw lj b"><strong class="is hj">@player_health</strong></code>和<code class="du lu lv lw lj b"><strong class="is hj">@player_mana</strong></code>创建了实例变量。好像我已经完全忘记了 getter 方法。</p><p id="bd82" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我知道我必须使用循环来让我的游戏生成怪物，但是我太害怕使用它们了！我不想陷入无限循环！但是我很高兴我复习了关于循环的知识，这样我对游戏的设想就变成了现实。</p><p id="1287" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">当我在写我的游戏时，我了解到当你的大脑疲劳时，或者当你饥饿时，休息一下是非常重要的。如果你不充满能量，你的大脑就无法工作。因此，拥有一个休息良好的大脑绝对有助于处理任何项目！</p><p id="2e36" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这是对我的游戏的回复，给任何感兴趣的人！请单击绿色的播放按钮继续。</p><figure class="jp jq jr js fd ij"><div class="bz dy l di"><div class="nf ng l"/></div></figure><p id="a506" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">随着我在熨斗之旅中继续创建更多的项目，我很高兴能够加深对对象关系的了解！</p></div></div>    
</body>
</html>