<html>
<head>
<title>How Python deals with its Lists internally?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python 如何在内部处理它的列表？</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/there-wasnt-any-clear-explanation-on-how-python-deals-with-lists-internally-so-i-wrote-one-533961a8c202?source=collection_archive---------7-----------------------#2022-10-09">https://medium.com/nerd-for-tech/there-wasnt-any-clear-explanation-on-how-python-deals-with-lists-internally-so-i-wrote-one-533961a8c202?source=collection_archive---------7-----------------------#2022-10-09</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><figure class="hh hi ez fb hj hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es hg"><img src="../Images/cc216b2eb089d16807c47d6ddb39b84b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*snAruf-m1X0UUgeX"/></div></div><figcaption class="hr hs et er es ht hu bd b be z dx translated"><a class="ae hv" href="https://unsplash.com/@steve_j?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">斯蒂夫·约翰森</a>在<a class="ae hv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍照</figcaption></figure><div class=""/><p id="033c" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我花了一段时间在一本关于 Python DSA 的书中偶然发现了一个清晰的解释，所以我需要分享一下。</p></div><div class="ab cl jt ju gp jv" role="separator"><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy"/></div><div class="hb hc hd he hf"><h1 id="610b" class="ka kb hy bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated">存储器地址的访问</h1><p id="4c4a" class="pw-post-body-paragraph iv iw hy ix b iy ky ja jb jc kz je jf jg la ji jj jk lb jm jn jo lc jq jr js hb bi translated">我们有记忆。特别是随机存取存储器。RAM 的硬件结构是以这样一种方式设计的，即可以有效地访问存储器地址(这也取决于存储器在硬件级的布局)。</p><p id="3647" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">上述信息表明，在内存地址(比如 0x7655384)检索内容的难度相当于访问存储在 0x3625 的内容。这是真的，而且有效。这种内存访问的便利性很重要，我将在后面解释它的<strong class="ix hz">原因</strong>。</p><p id="efb1" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">所以，当你在编程语言中给一个变量赋值时，比如 x = 5。这里 x 是<em class="ld">标识符</em>，5 是该标识符的值。编程语言的工作是记录存储 5 的内存地址。</p><p id="53fa" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在 C 之类的语言中，可以使用“&amp; <em class="ld"> x </em>”来知道存储在变量/标识符中的值的地址，Python 使用<strong class="ix hz"> <em class="ld"> id() </em> </strong>方法来提供类似的功能。</p><p id="a2f6" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">此外，您还必须考虑将用于存储每个变量的内存。存储整数的内存不同于存储字符的内存，存储字符串的内存也不同，依此类推。</p></div><div class="ab cl jt ju gp jv" role="separator"><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy"/></div><div class="hb hc hd he hf"><h1 id="24c2" class="ka kb hy bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated">数组！</h1><p id="fd39" class="pw-post-body-paragraph iv iw hy ix b iy ky ja jb jc kz je jf jg la ji jj jk lb jm jn jo lc jq jr js hb bi translated">当你必须存储一些相关/同类的信息时，事情就变得有趣了。例如，如果您想在给定的实例中存储板球比赛或足球比赛的比分，您不会坐下来为每个样本创建几个变量。</p><p id="6d59" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这就是数组发挥作用的地方。不是像疯子一样创建几个变量，而是在每个实例的所有那些样本/值可以存储在存储器容器中。这个内存容器将有更小的容器来存储单个的值。</p><p id="3d4a" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">假设我们有一个列表。现在我将交替使用单词 List 和 Array。</p><p id="66f1" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">一个字符列表:[A，B，C，D，E，…你明白了]</p><p id="40a9" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在大多数机器上，上面的每一个 Unicode 字符都存储在一个更大的 2 字节或 16 位容器中。更大的容器/列表的大小将取决于有多少个字符。</p><p id="6211" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">所以，如果你要在一个数组中存储所有的大写字母，你需要 26*2 = 52 字节的内存作为代价。</p><p id="1cb1" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">数组要求每个单独的容器都具有相同的大小。所以每个角色都有相同数量的内存分配给它。但是你可能会问，为什么要这样做呢？</p></div><div class="ab cl jt ju gp jv" role="separator"><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy"/></div><div class="hb hc hd he hf"><p id="97e4" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">数组中的任何索引都可以在常数时间或 O(1)中访问。当你在解决复杂的问题时，这是一个巨大的优势。但是这怎么可能呢？</p><p id="0627" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">你创建了一个我们称之为数组的大容器，并把它存储在一个变量中，比如说，<em class="ld"> big_container。</em></p><p id="3e5b" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">变量<em class="ld"> big_container </em>现在存储了一个<strong class="ix hz"> <em class="ld">指针</em> </strong>指向我们创建的数组的第一个索引。让我们假设指针中有内存地址 2761，我们知道一个字符将被存储在 2 个字节中。如果每个字符仅存储在 2 个字节中。然后，这只是一个简单的任务，做一些数学计算，以达到理想的指数。</p><p id="47f2" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">确切的公式是，</p><p id="7d77" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><em class="ld">desired _ memory _ index = start _ address+cellsize * index</em></p></div><div class="ab cl jt ju gp jv" role="separator"><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy"/></div><div class="hb hc hd he hf"><h1 id="fabd" class="ka kb hy bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated"><em class="le">麻花</em></h1><p id="0dbb" class="pw-post-body-paragraph iv iw hy ix b iy ky ja jb jc kz je jf jg la ji jj jk lb jm jn jo lc jq jr js hb bi translated">现在，假设您有不同大小的容器，您不能执行上面的等式来达到所需的索引。因此，没有 O(1)访问时间。</p><p id="cd9a" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">但是，转折来了。</p><p id="307b" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">你知道 Python 列表可以存储各种各样的东西。就像你可以用一些整数，一些字符，一些字符串，甚至一些更小的 Python 列表来创建一个 Python 列表，它会忠实地为你存储它们。</p><p id="adfb" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">但是，当列表中的每个元素都可以是另一个列表、字符串、元组或其他大小可变的元素时，它如何做到这一点呢？现在 Python 如何管理对任意索引处元素的 O(1)访问时间？</p><p id="8659" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">答案是引用数组。</p><h1 id="cc65" class="ka kb hy bd kc kd lf kf kg kh lg kj kk kl lh kn ko kp li kr ks kt lj kv kw kx bi translated">引用数组</h1><p id="e0f2" class="pw-post-body-paragraph iv iw hy ix b iy ky ja jb jc kz je jf jg la ji jj jk lb jm jn jo lc jq jr js hb bi translated">假设我们有一个一定大小的列表，其中包含住在某个房间的人的名字。标识房间号的列表索引。方便。</p><p id="61ab" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">所以，假设列表是这样的:["Emaila "，" Joseph "，" Rene" …]</p><p id="7a98" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">列表中的每个名称都有不同的长度，所以如果您只是通过为每个字符串分配可变长度的块来创建一个列表，那么除了第一个元素之外，您将无法获得对任何元素的恒定时间访问。</p><p id="833f" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">Python 不是简单地存储对象要存储的内容，而是做了一些聪明的事情，在列表中存储每个元素的地址，而不是实际的元素/对象。</p><p id="4155" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">所以，现在你可以有相同大小的单个块。但是他们的规模有多大，谁来决定呢？这完全取决于你使用的机器的类型。</p><p id="4e7e" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hz">注意</strong>:在前面的例子中，如果您要正确地存储元素，并且仍然保持 O(1)的访问时间，您必须创建每个块，其大小满足最长字符串的要求。那会是对内存空间的极大浪费。</p><p id="bfae" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">相反，如果机器是 32 位的，则为每个元素创建大小为 32 位的块。当然是存储元素的地址。然而，大多数机器将有一个 64 位的体系结构，并有一个 64 位的地址来存储我们想要存储的任何元素，块的大小也将随之变化。</p><h1 id="b2b7" class="ka kb hy bd kc kd lf kf kg kh lg kj kk kl lh kn ko kp li kr ks kt lj kv kw kx bi translated">结论</h1><p id="7b7d" class="pw-post-body-paragraph iv iw hy ix b iy ky ja jb jc kz je jf jg la ji jj jk lb jm jn jo lc jq jr js hb bi translated">这就是 Python 如何获取一个基本数组，并对其进行调整，以创建可以用来在更短时间内做很多事情的东西。</p></div></div>    
</body>
</html>