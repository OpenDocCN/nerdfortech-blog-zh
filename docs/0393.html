<html>
<head>
<title>Hive data organization — Partitioning &amp; Clustering</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Hive 数据组织—分区和聚类</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/hive-data-organization-partitioning-clustering-3e14ef6ab121?source=collection_archive---------0-----------------------#2020-11-22">https://medium.com/nerd-for-tech/hive-data-organization-partitioning-clustering-3e14ef6ab121?source=collection_archive---------0-----------------------#2020-11-22</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><figure class="hh hi ez fb hj hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es hg"><img src="../Images/07f8f5ce21028f454333e0e9616d7c1b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_ZVqk395KNQiGgZpgZ-Qrg.jpeg"/></div></div><figcaption class="hr hs et er es ht hu bd b be z dx translated">在<a class="ae hv" href="https://unsplash.com/s/photos/book-shelf?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上由<a class="ae hv" href="https://unsplash.com/@waldemarbrandt67w?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Waldemar Brandt </a>拍照</figcaption></figure><div class=""/><p id="33ca" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">数据组织影响任何数据仓库系统的查询性能。Hive 也不例外。这个博客旨在讨论分区、集群(分桶)以及围绕它们的考虑。</p><figure class="ju jv jw jx fd hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es jt"><img src="../Images/f23b3908f6f6e276853bf4852f56c523.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1xyX3aEx8zWGOylgZkZj4g.png"/></div></div></figure><p id="cf64" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">上图描述了一个被分区和分桶的表的 Hive 所处理的文件的层次结构。表和分区是目录或子目录，而桶是实际的文件。如果我们不应用这些，我们将在员工目录下有一个单独的文件。如果我们应用分桶且不分区，那么我们将有<em class="jy"> N </em>个文件，命名为 000000_1 …… 00000_N。如果进行分区，我们将拥有与数据分区所在列的基数相等的目录。如果我们对多个列进行分区，那么子目录的数量就变成了列 1 的基数*列 2 的基数。如果我们同时应用分区和存储桶，那么我们将在分区子目录下得到 N(存储桶数量)个文件。</p><p id="b4ce" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我提到这些是因为它们有助于决定如何有效地使用这些概念来优化查询执行时间。</p><h1 id="45a8" class="jz ka hy bd kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw bi translated">分割</h1><blockquote class="kx ky kz"><p id="3dbd" class="iv iw jy ix b iy iz ja jb jc jd je jf la jh ji jj lb jl jm jn lc jp jq jr js hb bi translated"><em class="hy">分区依据(Dept_id INT) </em></p></blockquote><p id="c5d5" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">分区是一种将数据负载水平分布到更易管理的块/目录和子目录中的方法。这允许我们以更符合逻辑的方式组织数据。在上图中，我们在 Dept_id 上创建了分区。假设我们有 3 个部门，员工平均分布。在这种情况下，我们将以三个子目录结束。这将基于 Dept_id。这将有助于我们跳过查询中没有与之交互的部门的数据。如果我们处理大量谓词(WHERE 子句)中有 Dept_id 的查询，这有助于提高查询性能。<strong class="ix hz">分区列的数据不存储在文件中。这也很直观，因为我们没有在 create table 表达式中添加进行分区的列。</strong></p><h2 id="8e1e" class="ld ka hy bd kb le lf lg kf lh li lj kj jg lk ll kn jk lm ln kr jo lo lp kv lq bi translated">动态和静态分区</h2><p id="ca24" class="pw-post-body-paragraph iv iw hy ix b iy lr ja jb jc ls je jf jg lt ji jj jk lu jm jn jo lv jq jr js hb bi translated">Hive 中的分区管理有两种方式。静态(用户管理器)或动态(由配置单元管理)。</p><p id="0c27" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在<strong class="ix hz">静态分区</strong>中，我们需要指定我们想要加载数据的分区。也可以使用添加分区操作来添加分区。</p><p id="0f78" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在<strong class="ix hz">动态分区</strong>中，当数据加载操作发生时，根据定义分区的列的值自动创建分区。</p><p id="88ab" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">要启用动态分区，我们需要使用 set below hive 配置</p><blockquote class="kx ky kz"><p id="e369" class="iv iw jy ix b iy iz ja jb jc jd je jf la jh ji jj lb jl jm jn lc jp jq jr js hb bi translated"><em class="hy">SET hive . exec . dynamic . partition = true<br/>SET hive . exec . dynamic . partition . mode = non strict</em></p></blockquote><p id="8372" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如果我们不设置第二个选项，那么我们就不能创建动态分区，除非我们至少有一个静态分区。</p><h1 id="5274" class="jz ka hy bd kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw bi translated">使聚集</h1><blockquote class="kx ky kz"><p id="806b" class="iv iw jy ix b iy iz ja jb jc jd je jf la jh ji jj lb jl jm jn lc jp jq jr js hb bi translated"><em class="hy">由(雇员标识)聚类成 3 个</em></p></blockquote><p id="ec13" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">分桶或群集是一种将数据负载分配到用户提供的一组桶中的方法，方法是计算关键字的哈希，并以桶/群集的数量为模。如果我们已经根据员工 id 对表进行了聚类。在散列和取模后给出相同值的 Emp_id 将进入同一个文件。</p><blockquote class="kx ky kz"><p id="152d" class="iv iw jy ix b iy iz ja jb jc jd je jf la jh ji jj lb jl jm jn lc jp jq jr js hb bi translated"><em class="hy">设置 hive.enforce.bucketing=true </em></p></blockquote><p id="042f" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">假设我们有 9 GB 的员工数据，每个部门有 3Gb 的数据(假设员工平均分布在各个部门)。在这种情况下，我们将有大约 9 个文件(9Gb)/(部门数量(3) *集群数量(3))= 1Gb/文件存储员工数据。</p><p id="9fd1" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">分桶适用于采样和连接优化技术。在星型模式中，事实表分桶是一个很好的起点。</p><p id="dde6" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">分桶可以独立于分区进行。在这种情况下，文件将位于表的目录下。</p><h1 id="1327" class="jz ka hy bd kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw bi translated">考虑</h1><ol class=""><li id="29b3" class="lw lx hy ix b iy lr jc ls jg ly jk lz jo ma js mb mc md me bi translated">使用中的分区方案应反映普通过滤。</li></ol><p id="be6f" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">2.分区列应该具有非常低的基数。较高的基数会创建太多的分区。这将创建大量的文件和目录。这将增加 hive metastore 的开销，因为它需要保存分区的元数据。</p><blockquote class="kx ky kz"><p id="3fc6" class="iv iw jy ix b iy iz ja jb jc jd je jf la jh ji jj lb jl jm jn lc jp jq jr js hb bi translated">SET hive . partition . pruning = strict</p></blockquote><p id="057d" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">3.这确保了如果有人在没有谓词的情况下对分区表发出查询，它将抛出编译错误。</p><p id="6431" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">4.小心处理动态分区，因为它会导致大量的分区。</p><p id="66b0" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">5.确保创建存储桶时每个文件都不会太小(小于 HDFS 数据块大小)。好的阈值应该在 1GB 左右。</p><p id="dadf" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">6.虽然我们可以基于多个列进行聚类，但是应该谨慎使用。</p><p id="bf92" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">7.分桶适用于高基数属性。一般通过选择<em class="jy">组中常用的属性，或者通过</em>子句选择<em class="jy">顺序</em></p><p id="e142" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">8.创建表后，不能更改存储桶的数量。</p><p id="1b91" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">9.(文件大小/存储桶数量)&gt; HDFS 块大小。</p><p id="445e" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">希望对你有用。</p><blockquote class="kx ky kz"><p id="fe66" class="iv iw jy ix b iy iz ja jb jc jd je jf la jh ji jj lb jl jm jn lc jp jq jr js hb bi translated">参考资料:</p></blockquote><p id="3fd2" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><a class="ae hv" href="https://journalofbigdata.springeropen.com/articles/10.1186/s40537-019-0196-1" rel="noopener ugc nofollow" target="_blank">https://journalofbigdata . springer open . com/articles/10.1186/s 40537-019-0196-1</a></p></div></div>    
</body>
</html>