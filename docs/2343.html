<html>
<head>
<title>Exception Aggregation — a new validation pattern</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">异常聚合——一种新的验证模式</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/exception-aggregation-a-new-validation-pattern-71d26f2ffee8?source=collection_archive---------10-----------------------#2021-05-02">https://medium.com/nerd-for-tech/exception-aggregation-a-new-validation-pattern-71d26f2ffee8?source=collection_archive---------10-----------------------#2021-05-02</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="bbe3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">验证是我们保证系统完整性和一致性的方法，因此，几乎每一个软件都有验证，不管它有多大。</p><p id="63e4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="jd">这是关于验证的系列文章的第一篇，点击关注以获得关于后续文章的更新！</em></p><h1 id="f729" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">介绍</h1><p id="c867" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">从验证的角度来看，我们可以将大多数软件系统分成 3 个主要部分:用例、实体和构建者，以及数据存储。</p><figure class="ki kj kk kl fd km er es paragraph-image"><div role="button" tabindex="0" class="kn ko di kp bf kq"><div class="er es kh"><img src="../Images/f97a7cbc907d3583ac11297913e0934e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8fsHbiGKLXFAn2w-0pwquA.jpeg"/></div></div><figcaption class="kt ku et er es kv kw bd b be z dx translated">图 1:验证约束与上下文感知的关系</figcaption></figure><h2 id="cbd6" class="kx jf hi bd jg ky kz la jk lb lc ld jo iq le lf js iu lg lh jw iy li lj ka lk bi translated">用例</h2><p id="11d1" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">用例是您的实体和其他系统组件满足业务需求的使用场景，因此用例是您的系统中最了解上下文的组件，因为它掌握了用户以某种方式使用系统的真实意图。</p><p id="3bce" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们可以指定一个用例需要的所有验证，而不依赖于系统中的任何其他部分，但这些规则中的一些不是任何用例都可以违反的，而是它们跨越许多用例和场景，这些被称为“<strong class="ih hj">不变量</strong>”。</p><h2 id="aabd" class="kx jf hi bd jg ky kz la jk lb lc ld jo iq le lf js iu lg lh jw iy li lj ka lk bi translated">实体和不变量</h2><blockquote class="ll lm ln"><p id="0acf" class="if ig jd ih b ii ij ik il im in io ip lo ir is it lp iv iw ix lq iz ja jb jc hb bi translated"><em class="hi">不变量是一组断言，在一个对象的生命周期中，这些断言必须始终为真，程序才能有效。</em></p></blockquote><p id="ea14" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">因此，最好将这些封装在它们的相关对象中，这保证了使用这些对象的任何客户端代码都将相应地执行这些规则，因此<strong class="ih hj">不变量是横切</strong>在您的应用程序中，我们将持有不变业务规则的对象称为“<strong class="ih hj">实体</strong>”。</p><h2 id="2417" class="kx jf hi bd jg ky kz la jk lb lc ld jo iq le lf js iu lg lh jw iy li lj ka lk bi translated">数据存储</h2><p id="2120" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">一些规则具有另一种性质，如并发问题和状态持久性，在某些情况下，可以委托给数据存储，但数据存储必须比用例或实体更能容忍它可以应用的验证，数据存储只能在验证方面提供任何帮助，因为它必须为实体状态的变化(如可空字段)留出空间。</p><h1 id="16e6" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">验证和错误报告</h1><p id="9f23" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">虽然验证对几乎所有系统都至关重要，但如果应用不正确，它也可能是有害的，例如，来自后端的不完整的错误反馈可能会损害您的用户体验，此外，不一致的错误处理和报告可能会导致系统出错，或者充其量是难以调试的系统。</p><h2 id="a99f" class="kx jf hi bd jg ky kz la jk lb lc ld jo iq le lf js iu lg lh jw iy li lj ka lk bi translated">异常与自定义错误</h2><p id="7ff1" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">根据我的经验，我遇到了两种验证方式，要么抛出<br/>“异常”，要么返回“验证错误”，这两种方式都有一些严重的缺点。在本文中，我想向您介绍第三种模式，它结合了两者的优点。</p><h2 id="9d45" class="kx jf hi bd jg ky kz la jk lb lc ld jo iq le lf js iu lg lh jw iy li lj ka lk bi translated">方法 1:使用异常</h2><figure class="ki kj kk kl fd km er es paragraph-image"><div role="button" tabindex="0" class="kn ko di kp bf kq"><div class="er es lr"><img src="../Images/2e30a62751e3b0cafeb29b98f85e6505.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ebCwEU4fLqIUhhMnKu-LPA.png"/></div></div></figure><p id="bf10" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">正如你在上面的例子中看到的，抛出的“异常”会破坏代码执行的连续性，它们不允许进一步的错误处理，这使得错误报告非常麻烦，并且不允许收集更多的错误。</p><p id="1faa" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们不应该在每个请求上一个错误接一个错误地返回，因为这会毁掉 UX。</p><p id="f6dc" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">想象一下，一个用户看到一个“短名称”的错误，然后在修复并重新提交后，我们向他发送另一个关于同一字段的“非法字符”的错误。这将令人沮丧。</p><p id="a561" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">优点:</p><ul class=""><li id="cfd1" class="ls lt hi ih b ii ij im in iq lu iu lv iy lw jc lx ly lz ma bi translated">防止构造无效实体。</li></ul><p id="b3c0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">缺点:</p><ul class=""><li id="f77e" class="ls lt hi ih b ii ij im in iq lu iu lv iy lw jc lx ly lz ma bi translated">破坏代码执行的连续性。</li><li id="dad7" class="ls lt hi ih b ii mb im mc iq md iu me iy mf jc lx ly lz ma bi translated">一错再错会破坏用户体验。</li></ul><h2 id="bab1" class="kx jf hi bd jg ky kz la jk lb lc ld jo iq le lf js iu lg lh jw iy li lj ka lk bi translated">方法 2:使用自定义错误</h2><p id="bb0f" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">我们可以在我们的方法中使用某种错误收集机制，并使用错误包作为进行验证的方法的返回值，这解决了破坏代码执行连续性的问题。</p><figure class="ki kj kk kl fd km er es paragraph-image"><div role="button" tabindex="0" class="kn ko di kp bf kq"><div class="er es mg"><img src="../Images/2254eb8a4a6eb4ba6252166f3a233de6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ty8pVlXxRG1LTUdLnZFXdA.png"/></div></div></figure><p id="6a83" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">乍一看，返回一个错误集合似乎是个好主意，但是正如你所看到的，另一方面，这会污染你的设计，因为太多的方法会有一些验证逻辑。</p><p id="800b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">仅仅这一点就会阻止你使用有意义的返回类型，阻止你的接口暴露出它们背后的真实意图，这反过来会使设计处于更糟糕的状态。</p><p id="036d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">但是让我们再来看看客户端代码:</p><figure class="ki kj kk kl fd km er es paragraph-image"><div role="button" tabindex="0" class="kn ko di kp bf kq"><div class="er es ml"><img src="../Images/1dcee1d4bc8d401ef42404b89b86431b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*D57GDfE9AvojjGhCBeOMiQ.png"/></div></div></figure><p id="6003" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在<code class="du mh mi mj mk b">const errBag1 = x.setAge(16);</code>上，是的，我们正在返回一个错误包，但我们仍然依赖于客户端开发人员足够警惕地使用这些返回类型，因为他/她可以很容易地忽略返回值，导致可以存储和操作的无效实体，这反过来违反了总是有效实体的原则。</p><p id="bcd7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">阅读 Greg Young 的更多关于永远有效的实体的文章:<a class="ae mm" href="http://codebetter.com/gregyoung/2009/05/22/always-valid/" rel="noopener ugc nofollow" target="_blank">点击这里</a>。</p><p id="bed3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">优点:</p><ul class=""><li id="484b" class="ls lt hi ih b ii ij im in iq lu iu lv iy lw jc lx ly lz ma bi translated">一种更好的向用户返回错误的方式。</li></ul><p id="bb71" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">缺点:</p><ul class=""><li id="9e25" class="ls lt hi ih b ii ij im in iq lu iu lv iy lw jc lx ly lz ma bi translated">对返回的错误的可能消除将导致无效实体被处理。</li><li id="b6e8" class="ls lt hi ih b ii mb im mc iq md iu me iy mf jc lx ly lz ma bi translated">严重损害了界面设计。</li></ul><h2 id="b26a" class="kx jf hi bd jg ky kz la jk lb lc ld jo iq le lf js iu lg lh jw iy li lj ka lk bi translated">方法 3:异常聚合</h2><p id="267b" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">这里提出的解决方案是我所谓的“异常聚合”——IDK，如果这是一个好名字的话，这是一个结合了两种解决方案的模式，使用异常(不中断)*代码执行连续性进行报告。</p><p id="14d1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">首先是<code class="du mh mi mj mk b">AggregateException</code>，一个继承自<code class="du mh mi mj mk b">Exception</code>基类的类(在 typescript 中它是<code class="du mh mi mj mk b">Error</code>类，但是我在这里使用<code class="du mh mi mj mk b">Exception</code>是为了不与非 typescript 用户的自定义错误解决方案相混淆)。</p><figure class="ki kj kk kl fd km er es paragraph-image"><div role="button" tabindex="0" class="kn ko di kp bf kq"><div class="er es mn"><img src="../Images/4bdfbea0f1e906142104876372d0f9f5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UvUnjWwYS9dwJQeikid8qA.png"/></div></div></figure><p id="be48" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">客户端代码将如下所示:</p><figure class="ki kj kk kl fd km er es paragraph-image"><div role="button" tabindex="0" class="kn ko di kp bf kq"><div class="er es mo"><img src="../Images/5a50bb53953c58ee70f3faa03db279a6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RExGJoMpqKA9WTFFKhnvDQ.png"/></div></div></figure><p id="0367" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">或者更好:</p><figure class="ki kj kk kl fd km er es paragraph-image"><div role="button" tabindex="0" class="kn ko di kp bf kq"><div class="er es mp"><img src="../Images/0790eba266e3ab9ad045fc9bf7db6a27.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*l6F3tNEfZdjyk5dFiKJE2A.png"/></div></div></figure><p id="59ba" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">虽然这显然比正常的流程需要更多的击键，但是这种简单的模式迫使客户端通过聚集异常来主动处理异常，而不会破坏执行的连续性，也不会牺牲实体的界面整洁性或传达其意图。</p><p id="c388" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">优点:</p><ul class=""><li id="6859" class="ls lt hi ih b ii ij im in iq lu iu lv iy lw jc lx ly lz ma bi translated">强制客户端主动处理异常。</li><li id="da02" class="ls lt hi ih b ii mb im mc iq md iu me iy mf jc lx ly lz ma bi translated">它不会牺牲你的设计。</li><li id="12b2" class="ls lt hi ih b ii mb im mc iq md iu me iy mf jc lx ly lz ma bi translated">一种更好的向用户返回错误的方式。</li></ul><p id="e864" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">缺点:</p><ul class=""><li id="0d3b" class="ls lt hi ih b ii ij im in iq lu iu lv iy lw jc lx ly lz ma bi translated">需要使用闭包。</li></ul><p id="ab4d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="jd">注 1:使用这种模式的最佳场合是您构建或重建工厂、建筑商等实体的地方，在那里错误将被主动处理，在那里您能够控制是</em> <strong class="ih hj"> <em class="jd">返回有效实体</em> </strong> <em class="jd">还是</em> <strong class="ih hj"> <em class="jd">抛出</em></strong><em class="jd"/><strong class="ih hj"><em class="jd">聚合异常</em> </strong> <em class="jd">。</em></p><h1 id="f943" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">结论</h1><p id="9e61" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">“异常聚合”是在不中断代码执行连续性的情况下处理错误的好方法，因为它结合了两者的优点，而不会牺牲您的设计或破坏用户体验。</p><p id="3c58" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这种模式可以与映射器结合使用，以遍历聚合异常中的错误，并为客户端应用程序返回更具描述性的验证错误。</p><p id="d1de" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">关于验证还有很多要说的，但是我想从介绍这个模式开始，因为它已经被证明是有用的。</p><p id="5b9f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果你觉得这篇文章有用，请分享并关注更多类似的文章。</p></div></div>    
</body>
</html>