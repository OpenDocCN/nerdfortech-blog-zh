<html>
<head>
<title>Binary Search with Go, Python and C</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">二分搜索法用围棋、Python和C</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/binary-search-with-go-python-and-c-3eaf3ed5f761?source=collection_archive---------15-----------------------#2021-03-20">https://medium.com/nerd-for-tech/binary-search-with-go-python-and-c-3eaf3ed5f761?source=collection_archive---------15-----------------------#2021-03-20</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/9dfe08305d129dc7b0605adbd4475207.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*z_dbrlK81_jL1cd8"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">澳大利亚八月在<a class="ae iu" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄的照片</figcaption></figure><p id="6220" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><em class="jt">二分搜索法算法</em>是一种搜索算法，适用于排序集合(例如排序数组)。它将一个集合、该集合的长度和要查找的元素作为输入，并将集合中元素的索引(如果存在)作为输出。</p><p id="15c6" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">由于算法简单，所以它既高效又易学。</p><p id="91a0" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这个算法只做<em class="jt"> O(log n) </em>比较。</p><p id="63ac" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">另一方面，它只对排序的集合有效，这使得它被限制在一些特定的情况下。</p><p id="6439" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这篇文章旨在展示这三种编程语言之间的一些基本差异。该算法本身在许多应用程序中使用，但是，大多数时候，我们不必从头实现它，因为每一个处理数据结构的值得尊敬的库都实现了这一点。</p><h1 id="1e46" class="ju jv hi bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated"><strong class="ak">伪代码</strong></h1><p id="ff18" class="pw-post-body-paragraph iv iw hi ix b iy ks ja jb jc kt je jf jg ku ji jj jk kv jm jn jo kw jq jr js hb bi translated">该算法的伪代码如下:</p><pre class="kx ky kz la fd lb lc ld le aw lf bi"><span id="7b1b" class="lg jv hi lc b fi lh li l lj lk">function BSA(A, n, T):</span><span id="a064" class="lg jv hi lc b fi ll li l lj lk">    L := 0</span><span id="5d6d" class="lg jv hi lc b fi ll li l lj lk">    R := n − 1</span><span id="eb60" class="lg jv hi lc b fi ll li l lj lk">    while L &lt;= R:</span><span id="3a1f" class="lg jv hi lc b fi ll li l lj lk">        m := floor((L + R) / 2)</span><span id="f4a5" class="lg jv hi lc b fi ll li l lj lk">        if A[m] &lt; T:</span><span id="6b21" class="lg jv hi lc b fi ll li l lj lk">            L := m + 1</span><span id="1d03" class="lg jv hi lc b fi ll li l lj lk">        else if A[m] &gt; T:</span><span id="3109" class="lg jv hi lc b fi ll li l lj lk">            R := m - 1</span><span id="2642" class="lg jv hi lc b fi ll li l lj lk">       else:</span><span id="2ca6" class="lg jv hi lc b fi ll li l lj lk">            return m</span><span id="f84a" class="lg jv hi lc b fi ll li l lj lk">    return unsuccessful</span></pre><p id="895f" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">让我们解释一下这段伪代码:</p><ul class=""><li id="fe2f" class="lm ln hi ix b iy iz jc jd jg lo jk lp jo lq js lr ls lt lu bi translated">该算法将数组<code class="du lv lw lx lc b">A</code>、数组长度<code class="du lv lw lx lc b">n</code>和要搜索的元素<code class="du lv lw lx lc b">T</code>作为输入；</li><li id="df0c" class="lm ln hi ix b iy ly jc lz jg ma jk mb jo mc js lr ls lt lu bi translated">我们初始化两个变量:<code class="du lv lw lx lc b">L</code>到<code class="du lv lw lx lc b">0</code>和<code class="du lv lw lx lc b">R</code>到<code class="du lv lw lx lc b">n-1</code>，即数组<code class="du lv lw lx lc b">A</code>的第一个和最后一个元素的索引；</li><li id="7d3f" class="lm ln hi ix b iy ly jc lz jg ma jk mb jo mc js lr ls lt lu bi translated">我们迭代直到<code class="du lv lw lx lc b">L</code>变得等于或大于<code class="du lv lw lx lc b">R</code>，也就是说我们迭代了整个数组；</li><li id="45b3" class="lm ln hi ix b iy ly jc lz jg ma jk mb jo mc js lr ls lt lu bi translated">我们将<code class="du lv lw lx lc b">m</code>初始化为floor或<code class="du lv lw lx lc b">(L+R)/2</code>，即数组中间元素的索引；</li><li id="6edf" class="lm ln hi ix b iy ly jc lz jg ma jk mb jo mc js lr ls lt lu bi translated">然后，我们将索引<code class="du lv lw lx lc b">m</code>处的元素与所需的元素<code class="du lv lw lx lc b">T</code>进行比较:</li><li id="bf53" class="lm ln hi ix b iy ly jc lz jg ma jk mb jo mc js lr ls lt lu bi translated">如果<code class="du lv lw lx lc b">A[m]</code>比<code class="du lv lw lx lc b">T</code>小，我们应该在数组的大半部分搜索<code class="du lv lw lx lc b">T</code>:在<em class="jt">【m+1，R】</em>中的那个；</li><li id="59b6" class="lm ln hi ix b iy ly jc lz jg ma jk mb jo mc js lr ls lt lu bi translated">如果<code class="du lv lw lx lc b">A[m]</code>大于<code class="du lv lw lx lc b">T</code>，我们应该在数组的下半部分搜索<code class="du lv lw lx lc b">T</code>:在<em class="jt">【L，m-1】</em>中的那个；</li><li id="4908" class="lm ln hi ix b iy ly jc lz jg ma jk mb jo mc js lr ls lt lu bi translated">否则<code class="du lv lw lx lc b">A[m]</code>等于<code class="du lv lw lx lc b">T</code>，我们可以返回<code class="du lv lw lx lc b">m</code>，因为我们找到了元素。</li></ul><h1 id="7da6" class="ju jv hi bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated"><strong class="ak"> Python </strong></h1><p id="0a19" class="pw-post-body-paragraph iv iw hi ix b iy ks ja jb jc kt je jf jg ku ji jj jk kv jm jn jo kw jq jr js hb bi translated">让我们看看使用Python的BSA。</p><figure class="kx ky kz la fd ij"><div class="bz dy l di"><div class="md me l"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">Python中的二进制搜索</figcaption></figure><p id="2421" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如你所见，用Python写的<em class="jt"> BSA </em>和伪代码非常相似。当我们找不到想要的元素时，我们返回<em class="jt"> -1 </em>。</p><h1 id="ccb2" class="ju jv hi bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated"><strong class="ak">出发</strong></h1><p id="d96f" class="pw-post-body-paragraph iv iw hi ix b iy ks ja jb jc kt je jf jg ku ji jj jk kv jm jn jo kw jq jr js hb bi translated"><em class="jt"> BSA </em>的<em class="jt"> Go </em>版本如下:</p><figure class="kx ky kz la fd ij"><div class="bz dy l di"><div class="md me l"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">围棋中的二分搜索法</figcaption></figure><p id="854b" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">与<em class="jt"> Python </em>版本不同，这段代码看起来不像伪代码，因为Go的强类型化迫使我们进行两次强制转换(<a class="ae iu" href="https://gist.github.com/dariodip/d54976e361fec510afe68a64cfa90e82#file-binary-search-go-L7" rel="noopener ugc nofollow" target="_blank"> <em class="jt">第7行</em> </a>)。同样在<em class="jt"> Go </em>实现中，如果我们找不到元素<em class="jt"> T </em>，我们返回<em class="jt"> -1 </em>。由于算法本身的简单性，无需考虑其他因素。</p><h1 id="a8ed" class="ju jv hi bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated"><strong class="ak"> C </strong></h1><p id="ad94" class="pw-post-body-paragraph iv iw hi ix b iy ks ja jb jc kt je jf jg ku ji jj jk kv jm jn jo kw jq jr js hb bi translated"><em class="jt"> _BSA_ </em>的<em class="jt"> C </em>版本可能如下:</p><figure class="kx ky kz la fd ij"><div class="bz dy l di"><div class="md me l"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">C语言中的二进制搜索</figcaption></figure><p id="a35b" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><em class="jt"> C </em>实现看起来与<em class="jt"> Go </em>实现非常相似，但是没有强制转换，因为<em class="jt"> C </em>具有弱类型。</p></div><div class="ab cl mf mg gp mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="hb hc hd he hf"><p id="1445" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这是我的第一篇博文。</p></div></div>    
</body>
</html>