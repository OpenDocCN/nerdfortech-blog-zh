<html>
<head>
<title>Gracefully Mimicking Clojure’s Threading Macros in Golang</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">优雅地模仿Clojure在Golang中的线程宏</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/gracefully-mimicking-clojures-threading-macros-in-golang-656827a12421?source=collection_archive---------6-----------------------#2021-02-13">https://medium.com/nerd-for-tech/gracefully-mimicking-clojures-threading-macros-in-golang-656827a12421?source=collection_archive---------6-----------------------#2021-02-13</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><h1 id="d78a" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">介绍</h1><p id="d9d8" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">智者说，如果你在生活中找不到幸福，那不仅仅是别人的错，因为你是唯一一个对此负责的人。他们说，为了获得幸福，你必须想出一种方法，自己去创造，而不是在哪里都找不到。</p><p id="a417" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">奇妙的事情之一是看Clojure如何以一种可爱的方式顺序执行一组函数，这感觉非常奇怪地令人满意，Golang没有提供同样的东西。</p><p id="fd2b" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">实际上我喜欢这两种编程语言，但是自从我加入Gojek后，我用Clojure编写代码的次数比用Golang多。Clojure中有一个特性是我最喜欢的。叫做<strong class="jf hj">线程宏</strong>。到底是什么？</p><h2 id="6b37" class="kg ig hi bd ih kh ki kj il kk kl km ip jo kn ko it js kp kq ix jw kr ks jb kt bi translated">Clojure的线程宏</h2><p id="6adb" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">简单地说，它是一种模式，可以帮助您设置一组函数，并让每个函数在执行时进行数据转换，然后将转换后的数据作为参数传递给该组中的下一个函数，以生成新信息。</p><figure class="kv kw kx ky fd kz er es paragraph-image"><div role="button" tabindex="0" class="la lb di lc bf ld"><div class="er es ku"><img src="../Images/308a4f5c190960977166742f6083ed8b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dmjgvO7AlZ_pLbiotFbugg.png"/></div></div><figcaption class="lg lh et er es li lj bd b be z dx translated">图Clojure中的线程化宏</figcaption></figure><p id="0dd0" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">如图1所示，<em class="lk"> Clojure的线程宏</em>有一组函数，包括:</p><ul class=""><li id="8b85" class="ll lm hi jf b jg kb jk kc jo ln js lo jw lp ka lq lr ls lt bi translated"><strong class="jf hj"> (get-restaurants) </strong>返回餐厅列表</li><li id="81a4" class="ll lm hi jf b jg lu jk lv jo lw js lx jw ly ka lq lr ls lt bi translated"><strong class="jf hj"> (get-menus) </strong>从<em class="lk"> (get-restaurants) </em>返回餐馆列表中返回一个菜单列表</li><li id="880e" class="ll lm hi jf b jg lu jk lv jo lw js lx jw ly ka lq lr ls lt bi translated"><strong class="jf hj">(获取价格最高食物)</strong>从<em class="lk">(获取菜单)</em>返回的菜单列表中返回价格最高的食物</li></ul><p id="536b" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">我们可以看到数据以一种新的形式从一个函数流向另一个函数，非常整洁！</p></div><div class="ab cl lz ma gp mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="hb hc hd he hf"><p id="1c67" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">顺便说一下，如果你想了解更多关于<em class="lk"> Clojure的线程宏</em>，去<a class="ae mg" href="https://clojure.org/guides/threading_macros" rel="noopener ugc nofollow" target="_blank"> Clojure的文档官方页面</a>上找吧。</p></div><div class="ab cl lz ma gp mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="hb hc hd he hf"><h2 id="bb26" class="kg ig hi bd ih kh ki kj il kk kl km ip jo kn ko it js kp kq ix jw kr ks jb kt bi translated">在Golang中模仿Clojure的线程宏</h2><p id="21ab" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">是啊，我知道。我们都会喜欢这个功能的。谁没有呢？它为我们的代码库引入了一种语法上的甜蜜，这使得事情更容易阅读或表达。哎呀…当心糖尿病！🤗</p><figure class="kv kw kx ky fd kz er es paragraph-image"><div role="button" tabindex="0" class="la lb di lc bf ld"><div class="er es mh"><img src="../Images/3dbfdc3db808f862e8852ba0c7dbe180.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*L0hLuuxPGbi4NLuVWEP1jw.png"/></div></div></figure><p id="b571" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">所有人都必须承认，静态类型的编程语言在性能方面通常比动态类型的更好，但事实并非如此，因为我们有时也渴望编写代码的简单性！</p><p id="3d41" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">我试图通过引入一个名为<a class="ae mg" href="https://github.com/parinpan/pipe" rel="noopener ugc nofollow" target="_blank"> <strong class="jf hj"> Pipe </strong> </a> <strong class="jf hj">，</strong>的小库，将这种简单性从Clojure带到Golang。它基本上做了和<em class="lk"> Clojure的线程宏</em>一样的事情，复制了它的概念。</p><p id="f186" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">让我们变脏，给我看看代码！</p><figure class="kv kw kx ky fd kz"><div class="bz dy l di"><div class="mi mj l"/></div></figure><p id="be42" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">开始了。我们只是在文件的顶部导入了<code class="du mk ml mm mn b">github.com/parinpan/pipe</code>库。这个库有两个核心函数来使<em class="lk"> Clojure的线程宏</em>在Golang中运行的功能相同，它们是:<strong class="jf hj"> <em class="lk"> pipe。Do() </em> </strong>和<strong class="jf hj"> <em class="lk">管。</em>应用()</strong></p><ul class=""><li id="b265" class="ll lm hi jf b jg kb jk kc jo ln js lo jw lp ka lq lr ls lt bi translated"><strong class="jf hj">管子<em class="lk">管子。Do() </em> </strong>函数接受一组<strong class="jf hj"> <em class="lk">管道。Apply() </em> </strong>函数注册所有的函数，以便顺序执行。</li><li id="745b" class="ll lm hi jf b jg lu jk lv jo lw js lx jw ly ka lq lr ls lt bi translated"><strong class="jf hj">管道。Apply() </strong> function <strong class="jf hj"> </strong>接受任何带有参数的函数，否则我们可以将它们留空，因为默认情况下，传递的函数的参数将是集合中上一次执行的函数的最新返回值。</li></ul><p id="e92b" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">好吧，如果所有的函数只有一个参数也没关系，这样这个库就可以把之前执行的函数的最新返回值传递给它。现在，问题是:<strong class="jf hj">有多个参数的函数怎么办？👀🧐 </strong></p><p id="cb96" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">放松点。让我再给你看一遍代码。我们有答案了！🙈</p><figure class="kv kw kx ky fd kz"><div class="bz dy l di"><div class="mi mj l"/></div></figure><p id="41b6" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">让我们看看这里有什么变化。现在一些函数接受不止一个参数。</p><ul class=""><li id="6693" class="ll lm hi jf b jg kb jk kc jo ln js lo jw lp ka lq lr ls lt bi translated"><strong class="jf hj"> getMenusWithFilter(…) </strong>函数第一个参数接受餐馆位置，第二个参数接受餐馆列表，第三个参数接受餐馆成立年份</li><li id="d3cd" class="ll lm hi jf b jg lu jk lv jo lw js lx jw ly ka lq lr ls lt bi translated"><strong class="jf hj"> getFoodByName(…) </strong>函数第一个参数接受菜单列表，第二个参数接受食物名称</li></ul><p id="ebec" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">那么，现在，<strong class="jf hj">库如何知道应该在什么索引处传递带有上一次执行函数返回值的参数呢？</strong>应该在函数自变量的<em class="lk">第一个索引</em>、<em class="lk">第二个索引</em>，还是<em class="lk">第n个索引</em>？</p><p id="eab3" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">如果你注意到了，从上面的代码中有一些<strong class="jf hj">管道。Pass() </strong>函数在<strong class="jf hj">管道中传递。Apply() </strong>我们已经知道它接受一个函数及其参数。因此，在<strong class="jf hj">管道所在的参数索引处，库将用载体返回值替换参数值。Pass() </strong>正在被传递。</p><p id="dc80" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">特别的是<strong class="jf hj">管。Pass() </strong>也可以接受一个函数，在执行之前将载体返回值更改为新的形式，如下所示。</p><figure class="kv kw kx ky fd kz"><div class="bz dy l di"><div class="mi mj l"/></div></figure><p id="ff82" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">你可以想<strong class="jf hj">管。Pass() </strong>是一个等价于Clojure的匿名函数“<em class="lk">%”</em>的符号。</p><pre class="kv kw kx ky fd mo mn mp mq aw mr bi"><span id="21ce" class="kg ig hi mn b fi ms mt l mu mv"><strong class="mn hj"># this is clojure!</strong></span><span id="7f8e" class="kg ig hi mn b fi mw mt l mu mv"><em class="lk">(-&gt; (get-restaurant)<br/>    (#(get-menus-with-filter "Bay Area" </em><strong class="mn hj"><em class="lk">%</em></strong><em class="lk"> 1940))<br/>    (#(get-food-name </em><strong class="mn hj"><em class="lk">%</em></strong><em class="lk"> "BigMac"))<br/>    (#(say (format "I love %s so much!" </em><strong class="mn hj"><em class="lk">%</em></strong><em class="lk">)))</em></span></pre><p id="9abd" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">很酷吧？😎</p><h2 id="2e9f" class="kg ig hi bd ih kh ki kj il kk kl km ip jo kn ko it js kp kq ix jw kr ks jb kt bi translated">在后台</h2><figure class="kv kw kx ky fd kz er es paragraph-image"><div class="er es mx"><img src="../Images/9910f17cfcf8fd2ceb575da612900b6b.png" data-original-src="https://miro.medium.com/v2/resize:fit:500/0*t93Y3LrMvw4v-kGy.gif"/></div></figure><p id="cd39" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">在经历了这些很酷的东西之后，我们必须感谢Golang的反射功能，这使得这一切成为可能！是的，库实际上只是它上面的一个抽象，隐藏了所有的复杂性。</p><p id="d1f8" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">让我们通过下面的代码片段先睹为快:</p><pre class="kv kw kx ky fd mo mn mp mq aw mr bi"><span id="111f" class="kg ig hi mn b fi ms mt l mu mv"><strong class="mn hj">returnValue</strong> := reflect.ValueOf(<strong class="mn hj">function</strong>).Call([]reflect.Value{<strong class="mn hj"><em class="lk">arg1, arg2, arg3</em></strong>})[0]</span></pre><p id="de57" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">基本上，这个库使用Golang的<code class="du mk ml mm mn b">reflect.ValueOf()</code>函数来调用我们使用<strong class="jf hj">管道组合逐个注册的所有函数。Do() </strong>和<strong class="jf hj">管道。Apply() </strong>函数连同它们的参数。</p><p id="fe0b" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">在我们从<code class="du mk ml mm mn b">reflect.ValueOf()</code>执行中获得了<code class="du mk ml mm mn b">returnValue</code>之后，我们将再次使用该值作为下一个执行的函数的参数。👻</p><h2 id="c79a" class="kg ig hi bd ih kh ki kj il kk kl km ip jo kn ko it js kp kq ix jw kr ks jb kt bi translated">标杆管理</h2><p id="241b" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">在MacBook Pro 16英寸2019上测试。处理器:2,3 GHz八核英特尔酷睿i9。内存:16 GB 2667 MHz DDR4。</p><figure class="kv kw kx ky fd kz er es paragraph-image"><div role="button" tabindex="0" class="la lb di lc bf ld"><div class="er es my"><img src="../Images/ca56d16217773aad8150fd50c08e607d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8G6ZlrnJK8JWCthHG5ExKw.png"/></div></div></figure><p id="e235" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">从上图来看，结果是:</p><ul class=""><li id="14e8" class="ll lm hi jf b jg kb jk kc jo ln js lo jw lp ka lq lr ls lt bi translated"><code class="du mk ml mm mn b">ExecutedWithoutPipe</code>在166ms内计算60.675.291次，每次操作持续时间为18.3ns。</li><li id="1664" class="ll lm hi jf b jg lu jk lv jo lw js lx jw ly ka lq lr ls lt bi translated"><code class="du mk ml mm mn b">ExecutedWithPipe</code>在166ms内计算了603.291次，每次操作持续时间为1825ns。</li></ul><p id="4c41" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">没有比赛。难怪。首先我们已经知道谁是赢家。不使用<strong class="jf hj">管道</strong>执行操作比使用<strong class="jf hj">管道</strong>执行性能好100倍。Golang的倒影肯定贵。</p><p id="95a4" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">又回到你身上了。我们仍然可以考虑每个操作1825ns，因为根据上下文和情况，相当快。</p><h2 id="d1c7" class="kg ig hi bd ih kh ki kj il kk kl km ip jo kn ko it js kp kq ix jw kr ks jb kt bi translated">结论</h2><p id="4a1b" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated"><em class="lk"> Clojure的线程宏</em>提供了一种简洁的方式来构建一系列函数的执行，这是一种语法上的糖，鼓励我们再次热爱编码。😍</p><p id="58cf" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">在Golang中模仿这一特性并不困难，问题只是我们如何在Golang的反射特性之上构建一个抽象，这在性能方面的成本确实非常昂贵。</p><p id="e3f7" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">但只要这样能让你开心，多编码。为什么不呢？<em class="lk">好的，这是一个opinion✌️ </em></p><h2 id="dc6c" class="kg ig hi bd ih kh ki kj il kk kl km ip jo kn ko it js kp kq ix jw kr ks jb kt bi translated">进一步讨论</h2><p id="9fcd" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">如果您有任何疑问，请通过<a class="ae mg" href="https://twitter.com/fachrinFAN" rel="noopener ugc nofollow" target="_blank"> Twitter </a>或<a class="ae mg" href="https://www.linkedin.com/in/fachrinfan/" rel="noopener ugc nofollow" target="_blank"> LinkedIn </a>联系我。哦，是的，如果你对这个图书馆感兴趣的话。你可以在https://github.com/parinpan/pipe的<a class="ae mg" href="https://github.com/parinpan/pipe" rel="noopener ugc nofollow" target="_blank">找到它</a></p><p id="f39c" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">谢谢！</p></div></div>    
</body>
</html>