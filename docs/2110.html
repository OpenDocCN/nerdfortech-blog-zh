<html>
<head>
<title>Swift Leetcode Series: Triangle</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Swift Leetcode 系列:三角形</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/swift-leetcode-series-triangle-medium-9cb748d779c7?source=collection_archive---------7-----------------------#2021-04-21">https://medium.com/nerd-for-tech/swift-leetcode-series-triangle-medium-9cb748d779c7?source=collection_archive---------7-----------------------#2021-04-21</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="7f27" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">Swift +动态编程+记忆=🔥🔥🔥</h2></div><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ix"><img src="../Images/8fa0618d84b433fd64bc0343ea69d242.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0zphgeGQhU32Ci7lv_pYTQ.png"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">Leetcode 120(中号)</figcaption></figure><div class="jn jo ez fb jp jq"><a href="https://theswiftnerd.com/triangle-leetcode/" rel="noopener  ugc nofollow" target="_blank"><div class="jr ab dw"><div class="js ab jt cl cj ju"><h2 class="bd hj fi z dy jv ea eb jw ed ef hh bi translated">三角形(Leetcode 120)</h2><div class="jx l"><h3 class="bd b fi z dy jv ea eb jw ed ef dx translated">难度:链接:第 21 天:四月 Leetcode 挑战赛给定一个三角形数组，返回从顶部到…</h3></div><div class="jy l"><p class="bd b fp z dy jv ea eb jw ed ef dx translated">theswiftnerd.com</p></div></div><div class="jz l"><div class="ka l kb kc kd jz ke jh jq"/></div></div></a></div><p id="3dd0" class="pw-post-body-paragraph kf kg hi kh b ki kj ij kk kl km im kn ko kp kq kr ks kt ku kv kw kx ky kz la hb bi translated">你也可以通过上面的链接在 Swift Nerd 博客上阅读完整的故事。</p><h1 id="437f" class="lb lc hi bd ld le lf lg lh li lj lk ll io lm ip ln ir lo is lp iu lq iv lr ls bi translated">问题描述</h1><p id="e382" class="pw-post-body-paragraph kf kg hi kh b ki lt ij kk kl lu im kn ko lv kq kr ks lw ku kv kw lx ky kz la hb bi translated">给定一个<code class="du ly lz ma mb b">triangle</code>数组，返回<em class="mc">从上到下的最小路径和</em>。</p><p id="522e" class="pw-post-body-paragraph kf kg hi kh b ki kj ij kk kl km im kn ko kp kq kr ks kt ku kv kw kx ky kz la hb bi translated">对于每一步，您可以移动到下一行的相邻数字。更正式地说，如果您在当前行的索引<code class="du ly lz ma mb b">i</code>上，您可以移动到下一行的索引<code class="du ly lz ma mb b">i</code>或索引<code class="du ly lz ma mb b">i + 1</code>。</p><p id="8955" class="pw-post-body-paragraph kf kg hi kh b ki kj ij kk kl km im kn ko kp kq kr ks kt ku kv kw kx ky kz la hb bi translated"><strong class="kh hj">例 1: </strong></p><pre class="iy iz ja jb fd md mb me mf aw mg bi"><span id="dfbf" class="mh lc hi mb b fi mi mj l mk ml"><strong class="mb hj">Input:</strong> triangle = [[2],[3,4],[6,5,7],[4,1,8,3]]<br/><strong class="mb hj">Output:</strong> 11<br/><strong class="mb hj">Explanation:</strong> The triangle looks like:<br/>   2<br/>  3 4<br/> 6 5 7<br/>4 1 8 3<br/>The minimum path sum from top to bottom is 2 + 3 + 5 + 1 = 11 (underlined above).</span></pre><p id="b45f" class="pw-post-body-paragraph kf kg hi kh b ki kj ij kk kl km im kn ko kp kq kr ks kt ku kv kw kx ky kz la hb bi translated"><strong class="kh hj">例 2: </strong></p><pre class="iy iz ja jb fd md mb me mf aw mg bi"><span id="c1c3" class="mh lc hi mb b fi mi mj l mk ml"><strong class="mb hj">Input:</strong> triangle = [[-10]]<br/><strong class="mb hj">Output:</strong> -10</span></pre><h1 id="ec82" class="lb lc hi bd ld le lf lg lh li lj lk ll io lm ip ln ir lo is lp iu lq iv lr ls bi translated">限制</h1><ul class=""><li id="8637" class="mm mn hi kh b ki lt kl lu ko mo ks mp kw mq la mr ms mt mu bi translated"><code class="du ly lz ma mb b">1 &lt;= triangle.length &lt;= 200</code></li><li id="42b8" class="mm mn hi kh b ki mv kl mw ko mx ks my kw mz la mr ms mt mu bi translated"><code class="du ly lz ma mb b">triangle[0].length == 1</code></li><li id="4774" class="mm mn hi kh b ki mv kl mw ko mx ks my kw mz la mr ms mt mu bi translated"><code class="du ly lz ma mb b">triangle[i].length == triangle[i - 1].length + 1</code></li><li id="0a65" class="mm mn hi kh b ki mv kl mw ko mx ks my kw mz la mr ms mt mu bi translated"><code class="du ly lz ma mb b">-104 &lt;= triangle[i][j] &lt;= 104</code></li></ul><p id="e743" class="pw-post-body-paragraph kf kg hi kh b ki kj ij kk kl km im kn ko kp kq kr ks kt ku kv kw kx ky kz la hb bi translated"><strong class="kh hj">跟进:</strong>你能否只用<code class="du ly lz ma mb b">O(n)</code>额外的空间来做这件事，其中<code class="du ly lz ma mb b">n</code>是三角形的总行数？</p><h1 id="c025" class="lb lc hi bd ld le lf lg lh li lj lk ll io lm ip ln ir lo is lp iu lq iv lr ls bi translated">解决办法</h1><h1 id="926f" class="lb lc hi bd ld le lf lg lh li lj lk ll io lm ip ln ir lo is lp iu lq iv lr ls bi translated">递归</h1><p id="20f2" class="pw-post-body-paragraph kf kg hi kh b ki lt ij kk kl lu im kn ko lv kq kr ks lw ku kv kw lx ky kz la hb bi translated">这是一个经典的动态规划问题，但重点是将问题分解成更小的子问题。如果我们把三角形想象成一个 n×n 的表示，那么就更容易设想下一个可能的子问题。在每一行中，列数与行数相同，因此第一行有 1 列，第 N 行有 N 列。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es na"><img src="../Images/b7e46148775359d49121d33e1b6ba3d0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*Vi41uu1DVNm5dXig.png"/></div></div></figure><p id="7e6f" class="pw-post-body-paragraph kf kg hi kh b ki kj ij kk kl km im kn ko kp kq kr ks kt ku kv kw kx ky kz la hb bi translated">我们可以观察到，在矩阵中的任何单元，可能有最多两条路径，即向下的<strong class="kh hj"/>(同一列)和对角的<strong class="kh hj"/>(增加)列。因此，对于<strong class="kh hj"> [i，j] </strong>元素，可能的路径将是<strong class="kh hj"> [i + 1，j ] </strong> ( <em class="mc">向下</em>)或<strong class="kh hj"> [i +1，j + 1] </strong> ( <em class="mc">对角线</em>)路径。无论我们选择哪条路径，该路径的总和将等于可能路径的元素+ min(向下/对角线)。</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="nb nc l"/></div></figure><p id="43d5" class="pw-post-body-paragraph kf kg hi kh b ki kj ij kk kl km im kn ko kp kq kr ks kt ku kv kw kx ky kz la hb bi translated">我们可以从第一排开始，一直做到最后一排。子问题将按以下方式解决。我们还需要注意 row 和 cols 的终止条件，<strong class="kh hj"> 0 &lt; = row &lt; n </strong>。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es nd"><img src="../Images/3caeace12ff99f5debdb9c028d9d5720.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*2h8yu603ojQc-ZYH.png"/></div></div></figure><h1 id="84b7" class="lb lc hi bd ld le lf lg lh li lj lk ll io lm ip ln ir lo is lp iu lq iv lr ls bi translated">密码</h1><h1 id="9097" class="lb lc hi bd ld le lf lg lh li lj lk ll io lm ip ln ir lo is lp iu lq iv lr ls bi translated">Swift:递归方法(自上而下)</h1><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="nb nc l"/></div></figure><h1 id="4be7" class="lb lc hi bd ld le lf lg lh li lj lk ll io lm ip ln ir lo is lp iu lq iv lr ls bi translated">动态编程:记忆化</h1><p id="435a" class="pw-post-body-paragraph kf kg hi kh b ki lt ij kk kl lu im kn ko lv kq kr ks lw ku kv kw lx ky kz la hb bi translated">当提交相同的解决方案时，我们会因为巨大的输入值而得到 TLE(超过时间限制)。因此，我们可以使用动态编程来缓存子问题的结果，以节省时间。我们可以维护一个存储表来存储每个[行][列]的结果。我在这里使用了一个字典，因为我们不需要随机访问，并使用键格式“row:col”来查询和保存键值对。</p><h1 id="8162" class="lb lc hi bd ld le lf lg lh li lj lk ll io lm ip ln ir lo is lp iu lq iv lr ls bi translated">Swift: DP</h1><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="nb nc l"/></div></figure><h1 id="4dfc" class="lb lc hi bd ld le lf lg lh li lj lk ll io lm ip ln ir lo is lp iu lq iv lr ls bi translated">复杂性分析</h1><p id="d4d2" class="pw-post-body-paragraph kf kg hi kh b ki lt ij kk kl lu im kn ko lv kq kr ks lw ku kv kw lx ky kz la hb bi translated">由于有 n 行，列数与行数相同，所以总元素数为 O(n2)。对于每个元素，递归助手函数至少调用一次，因此需要 O(n2)次运算。类似地，即使递归堆栈是 O(N) 空间，但是我们能存储的最大元素数是 n2。</p><p id="208f" class="pw-post-body-paragraph kf kg hi kh b ki kj ij kk kl km im kn ko kp kq kr ks kt ku kv kw kx ky kz la hb bi translated">时间= <strong class="kh hj"> O(n2) </strong></p><p id="55af" class="pw-post-body-paragraph kf kg hi kh b ki kj ij kk kl km im kn ko kp kq kr ks kt ku kv kw kx ky kz la hb bi translated">空间= <strong class="kh hj"> O(n2) </strong></p></div><div class="ab cl ne nf gp ng" role="separator"><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj"/></div><div class="hb hc hd he hf"><p id="c36b" class="pw-post-body-paragraph kf kg hi kh b ki kj ij kk kl km im kn ko kp kq kr ks kt ku kv kw kx ky kz la hb bi translated">感谢您的阅读。如果你喜欢这篇文章，并发现它很有用，请分享并像野火一样传播它！</p><p id="8c69" class="pw-post-body-paragraph kf kg hi kh b ki kj ij kk kl km im kn ko kp kq kr ks kt ku kv kw kx ky kz la hb bi translated">你可以在<a class="ae nl" href="https://theswiftnerd.com/" rel="noopener ugc nofollow" target="_blank">swift 网站</a>|<a class="ae nl" href="https://www.linkedin.com/in/varunrathi28/" rel="noopener ugc nofollow" target="_blank">LinkedIn</a>|<a class="ae nl" href="https://github.com/varunrathi28" rel="noopener ugc nofollow" target="_blank">Github</a>上找到我</p></div></div>    
</body>
</html>