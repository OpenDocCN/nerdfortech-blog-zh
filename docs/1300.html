<html>
<head>
<title>Cartoonize Images with Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用 Python 卡通化图像</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/cartoonize-images-with-python-10e2a466b5fb?source=collection_archive---------4-----------------------#2021-03-13">https://medium.com/nerd-for-tech/cartoonize-images-with-python-10e2a466b5fb?source=collection_archive---------4-----------------------#2021-03-13</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/1347da6bdffc0767d9a38333efb876de.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WXUB76OzBkZglTV-_h7jfg.jpeg"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">丹尼尔·戈麦斯在 Unsplash 上拍摄的照片</figcaption></figure><p id="35a2" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">对于本教程，您需要 Python 和两个库，Numpy 和 OpenCV。Numpy 是 Python 中高效数组的黄金标准，OpenCV 是一个计算机视觉库。它提供了几个方便的工具，这将使本教程非常容易。</p><p id="6517" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在本教程中，我不会深入研究算法，但是我会提供文档链接。</p></div><div class="ab cl jt ju gp jv" role="separator"><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy"/></div><div class="hb hc hd he hf"><h2 id="d5ce" class="ka kb hi bd kc kd ke kf kg kh ki kj kk jg kl km kn jk ko kp kq jo kr ks kt ku bi translated">导入语句+打开图像</h2><p id="559d" class="pw-post-body-paragraph iv iw hi ix b iy kv ja jb jc kw je jf jg kx ji jj jk ky jm jn jo kz jq jr js hb bi translated">我们从导入两个库开始:</p><pre class="la lb lc ld fd le lf lg lh aw li bi"><span id="f8e0" class="ka kb hi lf b fi lj lk l ll lm"># Import necessary libraries<br/>import cv2<br/>import numpy as np</span></pre><p id="c935" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们可以使用 cv2 库直接打开一个图像:</p><pre class="la lb lc ld fd le lf lg lh aw li bi"><span id="ae8a" class="ka kb hi lf b fi lj lk l ll lm"># Opens an image with cv2<br/>img = cv2.imread('DanielGomez.jpg')</span></pre><p id="d37b" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">Cv2 使用 numpy 来打开图像,“img”变量现在包含一个 3 维的 numpy 数组。一个小注意，cv2 打开图像作为 BGR(光谱的顺序)，而不是大多数人习惯的 RGB。如果你摆弄一下笔记本(见本文末尾)，你会发现为了绘图，我把图像从 BGR 转换成了 RGB。</p><p id="9e2d" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在本教程中，我将使用拉普拉斯过滤器来检测图像边缘。拉普拉斯过滤器是一个非常好的过滤器(阅读更多关于它的信息<a class="ae iu" href="https://docs.opencv.org/3.4/d5/db5/tutorial_laplace_operator.html" rel="noopener ugc nofollow" target="_blank">这里</a>)。然而，它很容易产生噪音。这就是为什么我们将在应用拉普拉斯过滤器之前应用一些图像过滤:</p><h2 id="b9cf" class="ka kb hi bd kc kd ke kf kg kh ki kj kk jg kl km kn jk ko kp kq jo kr ks kt ku bi translated">过滤</h2><pre class="la lb lc ld fd le lf lg lh aw li bi"><span id="89a9" class="ka kb hi lf b fi lj lk l ll lm"># Apply some Gaussian blur on the image<br/>img_gb = cv2.GaussianBlur(img, (7, 7) ,0)<br/># Apply some Median blur on the image<br/>img_mb = cv2.medianBlur(img_gb, 5)<br/># Apply a bilateral filer on the image<br/>img_bf = cv2.bilateralFilter(img_mb, 5, 80, 80)</span></pre><p id="1421" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">当然，我们也可以将结果可视化，以查看差异。</p><figure class="la lb lc ld fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ln"><img src="../Images/185a3ef02a387dc9ff7894528f4ab872.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MYvxrxLgAnGr09C6ReMQ4Q.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">照片由<a class="ae iu" href="https://unsplash.com/@mundodeparra?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">丹尼尔·戈麦斯</a>在 Unsplash 上拍摄——由作者编辑</figcaption></figure><p id="ff0b" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">看不出图像之间的差异？我也没有那么好，如果你知道每个过滤器是做什么的，你就能发现不同之处！拉普拉斯滤波器将检测差异。</p><h2 id="29e2" class="ka kb hi bd kc kd ke kf kg kh ki kj kk jg kl km kn jk ko kp kq jo kr ks kt ku bi translated">边缘检测</h2><p id="40a5" class="pw-post-body-paragraph iv iw hi ix b iy kv ja jb jc kw je jf jg kx ji jj jk ky jm jn jo kz jq jr js hb bi translated">接下来，我们可以应用拉普拉斯过滤器，为了比较起见，我们对所有 4 个不同的图像应用过滤器，并可视化结果。对于每个拉普拉斯滤波器，我们使用 5 的核大小。你当然可以玩一会儿，但在我看来，这将给出最好的结果。“CV_8U”意味着我们使用 8 位值(0–255)。</p><pre class="la lb lc ld fd le lf lg lh aw li bi"><span id="c853" class="ka kb hi lf b fi lj lk l ll lm"># Use the laplace filter to detect edges<br/>img_lp_im = cv2.Laplacian(img, cv2.CV_8U, ksize=5)<br/>img_lp_gb = cv2.Laplacian(img_gb, cv2.CV_8U, ksize=5)<br/>img_lp_mb = cv2.Laplacian(img_mb, cv2.CV_8U, ksize=5)<br/>img_lp_al = cv2.Laplacian(img_bf, cv2.CV_8U, ksize=5)</span></pre><p id="0c8d" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们再次将结果可视化:</p><figure class="la lb lc ld fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ln"><img src="../Images/c895710320adfb716b6043264aee87dc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TT3kWaiN9ZmpukIzaoFJFg.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">丹尼尔·戈麦斯在 Unsplash 上拍摄的照片——由作者编辑</figcaption></figure><p id="0241" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">你现在可以看到原始图像的拉普拉斯算子检测到了很多噪声。使用所有滤镜的图像是最清晰的，这一点很方便。然而，这还不是我们想要的。我们需要一个图像最好是黑白的，我们可以用它作为一个面具。让我们继续编辑这张图片。让我们首先将其转换为灰度图像:</p><pre class="la lb lc ld fd le lf lg lh aw li bi"><span id="9f19" class="ka kb hi lf b fi lj lk l ll lm"># Convert the image to greyscale (1D)<br/>img_lp_im_grey = cv2.cvtColor(img_lp_im, cv2.COLOR_BGR2GRAY)<br/>img_lp_gb_grey = cv2.cvtColor(img_lp_gb, cv2.COLOR_BGR2GRAY)<br/>img_lp_mb_grey = cv2.cvtColor(img_lp_mb, cv2.COLOR_BGR2GRAY)<br/>img_lp_al_grey = cv2.cvtColor(img_lp_al, cv2.COLOR_BGR2GRAY)</span></pre><p id="3e2c" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">现在，每个变量都包含一个一维数组，而不是三维数组。接下来，我们将使用图像阈值来设置接近黑色的值和接近白色的值。我们可以通过以下方式创建手动阈值:</p><pre class="la lb lc ld fd le lf lg lh aw li bi"><span id="34c6" class="ka kb hi lf b fi lj lk l ll lm"># Manual image thresholding<br/>_, EdgeImage = cv2.threshold(img, 127, 255, cv2.THRESH_BINARY)</span></pre><p id="c773" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">有很多不同的方法来使用图像阈值，尝试一下，找出最适合你的方法，你可以在这里阅读更多信息。在本教程中，我们使用 Otsu 阈值。在应用 Otsu 阈值之前，我们先去除一些额外的噪声。</p><pre class="la lb lc ld fd le lf lg lh aw li bi"><span id="a81c" class="ka kb hi lf b fi lj lk l ll lm"># Remove some additional noise<br/>blur_im = cv2.GaussianBlur(img_lp_im_grey, (5, 5), 0)<br/>blur_gb = cv2.GaussianBlur(img_lp_gb_grey, (5, 5), 0)<br/>blur_mb = cv2.GaussianBlur(img_lp_mb_grey, (5, 5), 0)<br/>blur_al = cv2.GaussianBlur(img_lp_al_grey, (5, 5), 0)</span><span id="9639" class="ka kb hi lf b fi lo lk l ll lm"># Apply a threshold (Otsu)<br/>_, tresh_im = cv2.threshold(blur_im, 245, 255,cv2.THRESH_BINARY +  cv2.THRESH_OTSU)<br/>_, tresh_gb = cv2.threshold(blur_gb, 245, 255,cv2.THRESH_BINARY + cv2.THRESH_OTSU)<br/>_, tresh_mb = cv2.threshold(blur_mb, 245, 255,cv2.THRESH_BINARY + cv2.THRESH_OTSU)<br/>_, tresh_al = cv2.threshold(blur_al, 245, 255,cv2.THRESH_BINARY + cv2.THRESH_OTSU)</span></pre><p id="ed14" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们现在有一个带有白色边缘的黑色图像，我们只需要将蒙版的黑色和白色反转。</p><pre class="la lb lc ld fd le lf lg lh aw li bi"><span id="5306" class="ka kb hi lf b fi lj lk l ll lm"># Invert the black and the white<br/>inverted_original = cv2.subtract(255, tresh_im)<br/>inverted_GaussianBlur = cv2.subtract(255, tresh_gb)<br/>inverted_MedianBlur = cv2.subtract(255, tresh_mb)<br/>inverted_Bilateral = cv2.subtract(255, tresh_al)</span></pre><p id="ce38" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">让我们想象一下结果:</p><figure class="la lb lc ld fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ln"><img src="../Images/027b193894fcf48c416ea67783b76be8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HrBUAA7NnNL0HmySiqu7Ww.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">照片由<a class="ae iu" href="https://unsplash.com/@mundodeparra?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">丹尼尔·戈麦斯</a>在 Unsplash 上拍摄——由作者编辑</figcaption></figure><p id="ec0d" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">最后一张看起来很适合做我们的面具。</p><h2 id="2461" class="ka kb hi bd kc kd ke kf kg kh ki kj kk jg kl km kn jk ko kp kq jo kr ks kt ku bi translated">颜色量化</h2><p id="d283" class="pw-post-body-paragraph iv iw hi ix b iy kv ja jb jc kw je jf jg kx ji jj jk ky jm jn jo kz jq jr js hb bi translated">现在我们有了蒙版的图像，我们必须减少卡通图像的颜色。我们可以通过两种方式实现这一点，使用 Kmeans 算法或简单的楼层划分。Kmeans 算法用于解释性数据分析，但在这种情况下非常有用。你可以在这里阅读更多关于算法和它如何在<a class="ae iu" href="https://opencv-python-tutroals.readthedocs.io/en/latest/py_tutorials/py_ml/py_kmeans/py_kmeans_opencv/py_kmeans_opencv.html#kmeans-opencv" rel="noopener ugc nofollow" target="_blank">上工作的信息。对于 Kmeans，我们需要在运行它之前进行一些修改，代码如下:</a></p><pre class="la lb lc ld fd le lf lg lh aw li bi"><span id="113f" class="ka kb hi lf b fi lj lk l ll lm"># Reshape the image<br/>img_reshaped = img.reshape((-1,3))<br/># convert to np.float32<br/>img_reshaped = np.float32(img_reshaped)<br/># Set the Kmeans criteria<br/>criteria = (cv2.TERM_CRITERIA_EPS + cv2.TERM_CRITERIA_MAX_ITER, 10, 1.0)<br/># Set the amount of K (colors)<br/>K = 8<br/># Apply Kmeans<br/>_, label, center = cv2.kmeans(img_reshaped, K, None, criteria, 10, cv2.KMEANS_RANDOM_CENTERS)</span><span id="bc2a" class="ka kb hi lf b fi lo lk l ll lm"># Covert it back to np.int8<br/>center = np.uint8(center)<br/>res = center[label.flatten()]<br/># Reshape it back to an image<br/>img_Kmeans = res.reshape((img.shape))</span></pre><p id="27f0" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如您所见，要让 Kmeans 运行起来需要做相当多的工作。这也需要一些时间，这取决于迭代、聚类的数量，当然还有图像的大小。减少图像颜色数量的更好方法可能是简单的楼层划分。</p><pre class="la lb lc ld fd le lf lg lh aw li bi"><span id="4863" class="ka kb hi lf b fi lj lk l ll lm"># Reduce the colors of the original image<br/>div = 64<br/>img_bins = img // div * div + div // 2</span></pre><p id="ccc4" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">就这么简单，一眨眼就搞定了！因为我们使用的是 numpy 数组，所以这个公式可以快速应用到 3D numpy 数组中的每个数字上。通过应用此公式，每个数字返回 32、96、160 或 224。这意味着我们最终得到 4 * 4 * 4 = 64 种颜色。让我们对两者进行比较:</p><figure class="la lb lc ld fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ln"><img src="../Images/a65b774d915bd4603e2b738a9e237ac3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AB3ZGp1sQdsgGKCdezBRjw.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">丹尼尔·戈麦斯在 Unsplash 上拍摄的照片——由作者编辑</figcaption></figure><p id="445e" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我个人更喜欢右边的那个，它能更好地保持纹身的颜色。</p><h2 id="615f" class="ka kb hi bd kc kd ke kf kg kh ki kj kk jg kl km kn jk ko kp kq jo kr ks kt ku bi translated">组合图像</h2><p id="e4c5" class="pw-post-body-paragraph iv iw hi ix b iy kv ja jb jc kw je jf jg kx ji jj jk ky jm jn jo kz jq jr js hb bi translated">现在剩下要做的就是合并两幅图像并保存结果:</p><pre class="la lb lc ld fd le lf lg lh aw li bi"><span id="dd24" class="ka kb hi lf b fi lj lk l ll lm"># Convert the mask image back to color <br/>inverted_Bilateral = cv2.cvtColor(inverted_Bilateral, cv2.COLOR_GRAY2RGB)<br/># Combine the edge image and the binned image<br/>cartoon_Bilateral = cv2.bitwise_and(inverted_Bilateral, img_bins)</span><span id="1d49" class="ka kb hi lf b fi lo lk l ll lm"># Save the image<br/>cv2.imwrite('CartoonImage.png', cartoon_Bilateral)</span></pre><figure class="la lb lc ld fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/d4de87fa7da5cf6b8d7fb85483728208.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CVzryWArVK6gzsCqsTnW-A.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">丹尼尔·戈麦斯在 Unsplash 上拍摄的照片——由作者编辑</figcaption></figure></div><div class="ab cl jt ju gp jv" role="separator"><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy"/></div><div class="hb hc hd he hf"><p id="09e4" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">就是这样！你可以在这里找到整个<a class="ae iu" href="https://github.com/RobertvdV/Medium/blob/9bf76be39233c5e8a0f18f59f3241fc494e2757b/CartoonizeWithPython/Cartoonize.ipynb" rel="noopener ugc nofollow" target="_blank">朱庇特笔记本(包括绘图)。试试看，调整一些参数，看看你能得到你想要的结果！</a></p></div></div>    
</body>
</html>