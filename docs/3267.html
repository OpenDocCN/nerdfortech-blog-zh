<html>
<head>
<title>Basics of Javascript · String · matchAll() (method)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Javascript String matchAll()的基础知识(方法)</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/basics-of-javascript-string-matchall-method-1dd7fdc90e21?source=collection_archive---------3-----------------------#2021-06-04">https://medium.com/nerd-for-tech/basics-of-javascript-string-matchall-method-1dd7fdc90e21?source=collection_archive---------3-----------------------#2021-06-04</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/3e1a75bf3a168d8b7aa96b49e254964f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*g9cFepYi4dKtYFg-fSN-nw.png"/></div></div></figure><p id="c7e7" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这篇文章是我在youtube上免费发表的关于网络开发基础的系列文章的抄本。如果你更喜欢看而不是读，请随时访问我的频道“Dev Newbs”。T3】</p><figure class="jp jq jr js fd ij"><div class="bz dy l di"><div class="jt ju l"/></div></figure><p id="eeb1" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">matchAll()方法返回所有匹配正则表达式字符串的结果的迭代器，包括捕获组。</p><p id="f13e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们需要提供一个正则表达式来查找匹配，作为该方法的强制参数。这必须有一个全局标志“g”，否则我们会抛出一个TypeError。</p><p id="d661" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">matchAll()方法的结果是找到的匹配项的迭代器。</p><p id="af5f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">每个匹配都表示为一个数组。数组中的第一个值是一个匹配的字符串，然后是零个、一个或多个表示每个捕获组的项，后面是表示找到的匹配项的起始位置的额外属性索引和表示用于查找匹配项的字符串的额外属性输入。</p><p id="e70a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">唷，真了不起。好的，让我们确定在第一个例子中没有那么难。</p><pre class="jp jq jr js fd jv jw jx jy aw jz bi"><span id="96f8" class="ka kb hi jw b fi kc kd l ke kf">let str = "The main bulk of rain will fall in SPAIN. That's our gain.";</span><span id="89b7" class="ka kb hi jw b fi kg kd l ke kf">let regExp = /(a)i(n)/;<br/>let regExpG = /(a)i(n)/g;<br/>let regExpGI = /(a)i(n)/gi;<br/>try {<br/>    console.log(...str.matchAll(regExp));<br/>}<br/>catch(err){<br/>    console.log(err);<br/>}</span><span id="094b" class="ka kb hi jw b fi kg kd l ke kf">// TypeError: String.prototype.matchAll called with a non-global <br/>// RegExp argument at String.matchAll</span><span id="568e" class="ka kb hi jw b fi kg kd l ke kf">console.log(...str.matchAll(regExpG));</span><span id="da41" class="ka kb hi jw b fi kg kd l ke kf">// outputs 3 arrays containing matches 3x "ain"</span><span id="9ab5" class="ka kb hi jw b fi kg kd l ke kf">console.log(...str.matchAll(regExpGI));</span><span id="4449" class="ka kb hi jw b fi kg kd l ke kf">// outputs 4 arrays containing matches 3x "ain" + 1x "AIN"</span></pre><p id="89e5" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我优雅地借用了前一个方法的示例输入，因此您可以看到两个姐妹方法的行为差异。</p><p id="04ab" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">一个区别是我们必须使用全球国旗。否则，我们会看到第一种情况——我们会看到TypeError通知我们这种确切的情况。</p><p id="d356" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">第二个区别是我们得到的不是一个数组，而是一个可迭代的对象。不用担心——我们使用spread语法将它转换成一个数组，这样就万事大吉了。</p><p id="49b5" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">第三个区别是每场比赛的内容。正如本文理论部分所述，我们不仅可以获得匹配的字符串，还可以获得捕获的组、索引和输入属性。</p><p id="ec76" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我使用括号在正则表达式中制造了一些捕获组。捕获的组只不过是括号中的任何表达式。</p><p id="f2d9" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">除此之外，我们的结果基本相同。由于有“I”标志，第一组结果区分大小写，而另一组不区分大小写。继续前进。</p><p id="f941" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我在理论部分没有提到，但是作为匹配结果的迭代器是不可重启的。这意味着一旦我们遍历了所有的匹配，我们就不能再使用这个结果了。我知道，这听起来很奇怪，所以让我们在示例2中检查一下。</p><pre class="jp jq jr js fd jv jw jx jy aw jz bi"><span id="e377" class="ka kb hi jw b fi kc kd l ke kf">let str2 = "The quick brown fox jumps over the lazy dog. It barked.";</span><span id="2f86" class="ka kb hi jw b fi kg kd l ke kf">let regExpCapital = /[A-Z][a-z]*/g;</span><span id="a47e" class="ka kb hi jw b fi kg kd l ke kf">// "FOR..OF with ITERATOR (NON-RESTARTABLE)"<br/>let foundMatches = str2.matchAll(regExpCapital);</span><span id="d446" class="ka kb hi jw b fi kg kd l ke kf">for (const match of foundMatches) {<br/>    console.log(match);<br/>}<br/>// this iteration returns 2 arrays for matches "The" &amp; "It"</span><span id="2ad5" class="ka kb hi jw b fi kg kd l ke kf">for (const match of foundMatches) {<br/>    console.log(match);<br/>}<br/>// this iteration doesn't return anything - iterator exhausted</span><span id="f749" class="ka kb hi jw b fi kg kd l ke kf">// "FOR..OF with ARRAY created by SPREAD OPERATOR (RESTARTABLE)"<br/>let foundMatchesArray = [...str2.matchAll(regExpCapital)];</span><span id="6f1b" class="ka kb hi jw b fi kg kd l ke kf">for (const match of foundMatchesArray) {<br/>    console.log(match);<br/>}<br/>// this iteration returns 2 arrays for matches "The" &amp; "It"</span><span id="0ba4" class="ka kb hi jw b fi kg kd l ke kf">for (const match of foundMatchesArray) {<br/>    console.log(match);<br/>}<br/>// this iteration also returns 2 arrays for matches "The" &amp; "It"</span><span id="5be0" class="ka kb hi jw b fi kg kd l ke kf">console.log("OUTPUT NEW MATCHALL RESULT EACH TIME");<br/>console.log(...str2.matchAll(regExpCapital));<br/>// this iteration returns 2 arrays for matches "The" &amp; "It"</span><span id="40b2" class="ka kb hi jw b fi kg kd l ke kf">console.log(...str2.matchAll(regExpCapital));<br/>// this iteration also returns 2 arrays for matches "The" &amp; "It"</span></pre><p id="af4d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们有正则表达式来查找所有以大写字母开头的单词。在第一种情况下，我们将matchall()的结果赋给变量“foundMatches”。我们尝试使用“for”对其进行迭代..“循环的。第一次一切正常。但是第二次——我们什么也没得到。因为没有什么可迭代的。保存在变量中的迭代器是不可重启的。</p><p id="3eba" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">幸运的是，还有第二种情况，首先使用spread语法将迭代器转换成数组。众所周知，数组的迭代器是可重启的，我们可以任意多次循环遍历数组。</p><p id="ccbf" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">另一种选择是第三种情况，我们根据需要多次执行该方法，并且总是输出结果。</p><p id="04b0" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我想展示的最后一点是，当使用matchAll()方法时，您总是可以访问附加属性，如“索引”和捕获的组。因为有时我们需要的不仅仅是实际的比赛。但是，当与全局标志一起使用时，这就是match()所能提供全部内容。但这对我们来说可能还不够。我们可能需要一些额外的信息。那么接下来该怎么办呢？让我们在最后一个例子中找出答案。</p><pre class="jp jq jr js fd jv jw jx jy aw jz bi"><span id="79f8" class="ka kb hi jw b fi kc kd l ke kf">let str3 = "Chapter 2.7 This text contains references to chapter 4.2.1 &amp; also to chapter 5";</span><span id="0ca4" class="ka kb hi jw b fi kg kd l ke kf">let regExp3 = /chapter \d+(\.\d)*/gi;</span><span id="3ab4" class="ka kb hi jw b fi kg kd l ke kf">console.log("MATCH()");<br/>console.log(str3.match(regExp3));<br/>// return 1 array with 3 found matches (no added data of matches)</span><span id="96a1" class="ka kb hi jw b fi kg kd l ke kf">console.log("MATCHALL()");<br/>console.log(...str3.matchAll(regExp3));<br/>// returns 3 arrays with additional details about matches</span><span id="e361" class="ka kb hi jw b fi kg kd l ke kf">console.log("EASY ACCESS TO ADDITIONAL INFORMATION");<br/>let matches = str3.matchAll(regExp3);</span><span id="2c0d" class="ka kb hi jw b fi kg kd l ke kf">for (const match of matches) {<br/>    console.log('MATCH: ' + match[0]);<br/>    console.log('START: ' + match.index);<br/>    console.log('  END: ' + (match.index + match[0].length));<br/>}</span><span id="9a7b" class="ka kb hi jw b fi kg kd l ke kf">// MATCH: Chapter 2.7<br/>// START: 0<br/>// END:   11<br/>//<br/>// MATCH: chapter 4.2.1<br/>// START: 45<br/>// END:   58<br/>//<br/>// MATCH: chapter 5<br/>// START: 69<br/>// END:   78</span></pre><p id="8e56" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如果我们想在不使用matchAll()方法的情况下访问附加信息，我们就必须使用exec()方法。然后，我们必须使用“while”循环迭代结果。这绝对是一个不太舒服的解决方案。</p><p id="3504" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">好了，matchAll()到此结束。当然，我们可以涵盖更多的用例，但我相信我们至少解释了重要的部分。当你遇到具体的事情时，你必须用谷歌搜索，但至少现在，你会对正在发生的事情有所了解。</p><p id="da7a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">一如既往——非常感谢您的关注，我们将在下一篇文章中再见。</p></div></div>    
</body>
</html>