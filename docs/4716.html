<html>
<head>
<title>DB Dead Lock, Complete Case Study Using GoLang</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">DB 死锁，使用 GoLang 的完整案例研究</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/db-dead-lock-complete-case-study-using-golang-15dd754e5cb8?source=collection_archive---------1-----------------------#2021-08-04">https://medium.com/nerd-for-tech/db-dead-lock-complete-case-study-using-golang-15dd754e5cb8?source=collection_archive---------1-----------------------#2021-08-04</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="191b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在这个故事中，我们将经历如何在 Postgres 数据库中调试死锁的过程。如何避免死锁或如何实时最小化死锁情况。为此，我将深入探讨事务性用例中并发请求的 DB 事务。</p><p id="b57d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我选择了 golang、Postgres 和一些支持事务特性的 go lang 模块。</p><p id="5f21" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">什么是数据库事务？</strong></p><p id="5631" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">它是一个工作单元，通常由多个数据库操作组成。</p><p id="e8bd" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">例如:假设我们是一个简单的银行系统，当我们启动从账户 A 到账户 b 的资金转移时，该系统保存用户的账户详细信息。这将最终执行多个数据库操作，如:-</p><ul class=""><li id="00af" class="jd je hi ih b ii ij im in iq jf iu jg iy jh jc ji jj jk jl bi translated">启动转账详情。</li><li id="a233" class="jd je hi ih b ii jm im jn iq jo iu jp iy jq jc ji jj jk jl bi translated">为这些帐户创建交易记录。例如:对于从账户 A 到账户 B 的 100 美元账户转账，交易表中将有两个记录，账户 A → -100 美元，账户 B → +100 美元。</li><li id="5dd3" class="jd je hi ih b ii jm im jn iq jo iu jp iy jq jc ji jj jk jl bi translated">最后，用-100 美元和+100 美元更新帐户 A 和 B 的余额。</li></ul><p id="db79" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">所以总的来说，从账户 A 到账户 B 的简单金额转账将有 5 个操作。</p><blockquote class="jr js jt"><p id="610a" class="if ig ju ih b ii ij ik il im in io ip jv ir is it jw iv iw ix jx iz ja jb jc hb bi translated">开始转移。</p><p id="464c" class="if ig ju ih b ii ij ik il im in io ip jv ir is it jw iv iw ix jx iz ja jb jc hb bi translated">为帐户 a 创建交易记录。</p><p id="35c1" class="if ig ju ih b ii ij ik il im in io ip jv ir is it jw iv iw ix jx iz ja jb jc hb bi translated">为帐户 b 创建交易记录。</p><p id="1cb6" class="if ig ju ih b ii ij ik il im in io ip jv ir is it jw iv iw ix jx iz ja jb jc hb bi translated">更新帐户 a 中的余额。</p><p id="2224" class="if ig ju ih b ii ij ik il im in io ip jv ir is it jw iv iw ix jx iz ja jb jc hb bi translated">更新帐户 b 中的余额。</p></blockquote><p id="de68" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">我们为什么需要数据库事务？</strong></p><ol class=""><li id="b25e" class="jd je hi ih b ii ij im in iq jf iu jg iy jh jc jy jj jk jl bi translated">即使在系统故障时，RDBMS 也能提供可靠和一致的数据。</li><li id="5e45" class="jd je hi ih b ii jm im jn iq jo iu jp iy jq jc jy jj jk jl bi translated">提供并发访问数据库的进程/程序之间的数据隔离。</li></ol><p id="96c4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">RDBMS 通过其<strong class="ih hj"> ACID 属性支持上述功能。</strong></p><figure class="ka kb kc kd fd ke er es paragraph-image"><div role="button" tabindex="0" class="kf kg di kh bf ki"><div class="er es jz"><img src="../Images/ac2495bd0ee9de8b8ed3986a1531f956.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bgrCWIcWgHV9aicvTguYjw.png"/></div></div></figure><p id="0001" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">如何在事务中运行 DB？</strong></p><p id="6f79" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">答案很简单，使用<code class="du kl km kn ko b">Begin</code>，然后是 SQL 语句，最后是<code class="du kl km kn ko b">commit</code>。对于失败，它是<code class="du kl km kn ko b">rollback</code>。</p><p id="8dc7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">对于成功的交易</strong></p><pre class="ka kb kc kd fd kp ko kq kr aw ks bi"><span id="4a00" class="kt ku hi ko b fi kv kw l kx ky"><strong class="ko hj">BEGIN;<br/>-- <br/>SQL Statements<br/>--</strong><br/><strong class="ko hj">COMMIT;</strong></span></pre><p id="05c0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">成功提交后，数据库表将具有修改后的值。</p><p id="ceed" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">失败交易</strong></p><pre class="ka kb kc kd fd kp ko kq kr aw ks bi"><span id="56b3" class="kt ku hi ko b fi kv kw l kx ky"><strong class="ko hj">BEGIN;<br/>-- <br/>SQL Statements -- Exception occurred<br/>--</strong><br/><strong class="ko hj">ROLLBACK;</strong></span></pre><p id="84c1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">回滚后，对表所做的所有更改都将丢失，DB 将保留以前的成功状态。</p><p id="ce4d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">让我们用 goLang 运行一个代码示例</strong></p><p id="662f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们将采取同样的例子(账户转账)，我前面解释过。</p><figure class="ka kb kc kd fd ke er es paragraph-image"><div role="button" tabindex="0" class="kf kg di kh bf ki"><div class="er es kz"><img src="../Images/502f8aeb392e83f4cfcf5b4818a4a786.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MYqhh6Vk2WkKqi9H8lVXfA.png"/></div></div></figure><p id="6941" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">围棋郎实现</strong></p><p id="468d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我考虑了 Golang 和一些有助于演示这个用例的模块</p><blockquote class="jr js jt"><p id="086c" class="if ig ju ih b ii ij ik il im in io ip jv ir is it jw iv iw ix jx iz ja jb jc hb bi translated">GOLang Migrate → For DB Migration 要了解更多细节，请点击<a class="ae la" rel="noopener" href="/geekculture/db-migration-in-go-lang-d325effc55de">这里</a>查看我之前的博客。</p><p id="327f" class="if ig ju ih b ii ij ik il im in io ip jv ir is it jw iv iw ix jx iz ja jb jc hb bi translated">SQLC →对于 DB CRUD 操作的自动生成代码，这纯粹是为了 Postgres 支持。</p><p id="c32b" class="if ig ju ih b ii ij ik il im in io ip jv ir is it jw iv iw ix jx iz ja jb jc hb bi translated">测试用例→使用 TDD 和测试用例来解释和实现。</p></blockquote><p id="b0c1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">由于我们没有为此使用任何 ORM 模块，我认为如果我们使用任何 ORM 模块，解释数据库事务会变得很困难，因为它隐藏了底层的数据库功能，而且 ORM 比普通 SQL 慢。</p><p id="2305" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们使用 begin、commit 和 rollback 在 go 文件中创建事务功能。下面的方法为一组数据库操作设置事务边界上下文。</p><figure class="ka kb kc kd fd ke"><div class="bz dy l di"><div class="lb lc l"/></div></figure><p id="5cc4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">实际的 initiate transaction 方法在事务中运行。下面的方法将根据业务规则以特定的顺序执行一些 SQL 语句。您可以看到，在更新源和目标之前，我已经查询了帐户详细信息。这是不需要的，我们可以直接更新余额，而无需获取数据。对于展示，我遵循了这种方法。</p><figure class="ka kb kc kd fd ke"><div class="bz dy l di"><div class="lb lc l"/></div></figure><p id="ca0f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在我们将编写一个测试用例来演示并发请求。在下面的测试用例中，我对并发请求使用了 goroutines，并使用通道来捕获结果并在以后进行验证。下面的测试用例启动了 5 次从源到目标的资金转移，每次 10 美元。最后，在 5 个并发请求中，从源到目标需要 50 美元。</p><figure class="ka kb kc kd fd ke"><div class="bz dy l di"><div class="lb lc l"/></div></figure><p id="3606" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">使用当前的代码库，如果我运行测试用例，测试用例会失败，因为在并发模式下，每个进程都不会从之前的提交中获得更新的余额。所以会有不一致的平衡导致断言失败。</p><figure class="ka kb kc kd fd ke er es paragraph-image"><div role="button" tabindex="0" class="kf kg di kh bf ki"><div class="er es ld"><img src="../Images/8b0ff3be6154432a35db2fa599455f02.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AKzgc-HdLA966PLlWCWkzw.png"/></div></div></figure><p id="cf41" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果您观察交易前的日志，源帐户的余额是 728，目标帐户的余额是 799。</p><blockquote class="jr js jt"><p id="1eeb" class="if ig ju ih b ii ij ik il im in io ip jv ir is it jw iv iw ix jx iz ja jb jc hb bi translated">第一笔交易→ S (718)，T (809)</p><p id="3f34" class="if ig ju ih b ii ij ik il im in io ip jv ir is it jw iv iw ix jx iz ja jb jc hb bi translated">第二次交易→ S(708)，T (819)</p><p id="79f5" class="if ig ju ih b ii ij ik il im in io ip jv ir is it jw iv iw ix jx iz ja jb jc hb bi translated">第三次交易→ S(708)，T(829)</p></blockquote><p id="8058" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在第二次交易之后，来源的余额不会更新，它与前一次交易保持相同。但是目标帐户更新了它的余额，导致了一致性问题。</p><p id="97b6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">原因是我们已经使用了一个简单的 select 查询来使用<code class="du kl km kn ko b">SELECT * FROM account_details WHERE id = 1;</code>获取帐户细节。这是一个普通的 SELECT 语句，不会阻止更新。因此并发请求将获得相同的数据，并最终导致不一致。</p><p id="bb06" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们在单独的 psql 窗口中运行并行事务，并尝试获取数据。</p><figure class="ka kb kc kd fd ke er es paragraph-image"><div role="button" tabindex="0" class="kf kg di kh bf ki"><div class="er es le"><img src="../Images/e3deb94b336c5274905aa1dca8c67ef9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vEPaW0HmDR2VHzyNzIO2_w.png"/></div></div></figure><figure class="ka kb kc kd fd ke er es paragraph-image"><div role="button" tabindex="0" class="kf kg di kh bf ki"><div class="er es lf"><img src="../Images/e6ec76cdb1f5733d83fc03d7bcfb652e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fcwXbjMz7NR_wd6F58CjLw.png"/></div></div></figure><p id="859f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">它立即返回，没有阻拦。</p><p id="f941" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">解决方案 1 : </strong></p><p id="c4cc" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">将选择查询更改为`<code class="du kl km kn ko b">SELECT * FROM account_details WHERE id = 1 FOR UPDATE</code></p><p id="41a2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">事务中第一个窗口立即返回</p><figure class="ka kb kc kd fd ke er es paragraph-image"><div role="button" tabindex="0" class="kf kg di kh bf ki"><div class="er es lg"><img src="../Images/29790f47b8b05faefaf9ccd7e1f34aca.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vmBAJ9E9q7TiFposWtOzlA.png"/></div></div></figure><p id="387c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">第二个被阻塞，依赖于前一个事务。它要么提交，要么回滚。</p><figure class="ka kb kc kd fd ke er es paragraph-image"><div role="button" tabindex="0" class="kf kg di kh bf ki"><div class="er es lh"><img src="../Images/42e80d5bb3a32863fc797a12c370e8b0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ProW7l2wDPH_LvVqjQgHJA.png"/></div></div></figure><p id="8f3d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果我通过更新余额提交第一个事务，第二个事务将获得更新后的值。</p><figure class="ka kb kc kd fd ke er es paragraph-image"><div role="button" tabindex="0" class="kf kg di kh bf ki"><div class="er es li"><img src="../Images/bd86dac65ed181e26e994acfbf71849a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pWRByEz3FUDMt5npTFPDWA.png"/></div></div></figure><figure class="ka kb kc kd fd ke er es paragraph-image"><div role="button" tabindex="0" class="kf kg di kh bf ki"><div class="er es lj"><img src="../Images/20f2e6a37e1654818bcfb7667ab910e1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*d_J9ffCFkQNIHruKwey2sQ.png"/></div></div></figure><p id="6550" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在我已经更新了查询并再次执行了测试用例。让我们看看这是否可行，并在实际方法中添加一些日志以供调试。</p><figure class="ka kb kc kd fd ke er es paragraph-image"><div role="button" tabindex="0" class="kf kg di kh bf ki"><div class="er es lk"><img src="../Images/b70b042569294af22c566abb4027b3df.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*f5Tc-WnnGyVkWJL-8XzzwA.png"/></div></div></figure><p id="c844" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">测试用例返回以下错误，一个死锁</p><figure class="ka kb kc kd fd ke er es paragraph-image"><div role="button" tabindex="0" class="kf kg di kh bf ki"><div class="er es ll"><img src="../Images/22a24599451086587c08cae5ef754f51.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*59JYnS4UUGl4HiS5RwEAnw.png"/></div></div></figure><p id="03b4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这些是我们得到的日志，如果你注意到并发请求的顺序是没有保证的。让我们在 PSQL 的两个独立窗口中复制同样的东西。</p><p id="1f74" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> <em class="ju">第二笔交易:</em> </strong></p><p id="e252" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">选择查询在这里被阻塞。</p><figure class="ka kb kc kd fd ke er es paragraph-image"><div role="button" tabindex="0" class="kf kg di kh bf ki"><div class="er es lm"><img src="../Images/be496aa9c6d3f0a4d6d2d11d79aad0ab.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sJ6I8XBClPf90cDlZzoT2A.png"/></div></div></figure><p id="ebaa" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">第一笔交易</p><figure class="ka kb kc kd fd ke er es paragraph-image"><div role="button" tabindex="0" class="kf kg di kh bf ki"><div class="er es ln"><img src="../Images/46c2b058dd1a5dd1a3ab925ae292af73.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MgMVB-FGtE_5-nNnQyjS1w.png"/></div></div></figure><p id="0892" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们看看 PG 锁为什么 Select 查询被阻塞。</p><p id="6a9a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">查询以检查被阻止的查询列表以及阻止它们的原因。</p><pre class="ka kb kc kd fd kp ko kq kr aw ks bi"><span id="9815" class="kt ku hi ko b fi kv kw l kx ky"><strong class="ko hj">SELECT blocked_locks.pid     AS blocked_pid,<br/>         blocked_activity.usename  AS blocked_user,<br/>         blocking_locks.pid     AS blocking_pid,<br/>         blocking_activity.usename AS blocking_user,<br/>         blocked_activity.query    AS blocked_statement,<br/>         blocking_activity.query   AS current_statement_in_blocking_process<br/>   FROM  pg_catalog.pg_locks         blocked_locks<br/>    JOIN pg_catalog.pg_stat_activity blocked_activity  ON blocked_activity.pid = blocked_locks.pid<br/>    JOIN pg_catalog.pg_locks         blocking_locks <br/>        ON blocking_locks.locktype = blocked_locks.locktype<br/>        AND blocking_locks.database IS NOT DISTINCT FROM blocked_locks.database<br/>        AND blocking_locks.relation IS NOT DISTINCT FROM blocked_locks.relation<br/>        AND blocking_locks.page IS NOT DISTINCT FROM blocked_locks.page<br/>        AND blocking_locks.tuple IS NOT DISTINCT FROM blocked_locks.tuple<br/>        AND blocking_locks.virtualxid IS NOT DISTINCT FROM blocked_locks.virtualxid<br/>        AND blocking_locks.transactionid IS NOT DISTINCT FROM blocked_locks.transactionid<br/>        AND blocking_locks.classid IS NOT DISTINCT FROM blocked_locks.classid<br/>        AND blocking_locks.objid IS NOT DISTINCT FROM blocked_locks.objid<br/>        AND blocking_locks.objsubid IS NOT DISTINCT FROM blocked_locks.objsubid<br/>        AND blocking_locks.pid != blocked_locks.pid</strong></span><span id="2db2" class="kt ku hi ko b fi lo kw l kx ky"><strong class="ko hj">JOIN pg_catalog.pg_stat_activity blocking_activity ON blocking_activity.pid = blocking_locks.pid<br/>   WHERE NOT blocked_locks.granted;</strong></span></pre><p id="d822" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">结果是:</p><pre class="ka kb kc kd fd kp ko kq kr aw ks bi"><span id="76cf" class="kt ku hi ko b fi kv kw l kx ky">blocked_pid|blocked_user|blocking_pid|blocking_user|blocked_statement                                     |current_statement_in_blocking_process                                                              |<br/>-----------+------------+------------+-------------+------------------------------------------------------+---------------------------------------------------------------------------------------------------+<br/>        987|developer   |         975|developer    |<strong class="ko hj"><em class="ju">select * from account_details where id = 1 for update;</em></strong>|<strong class="ko hj"><em class="ju">insert into transfers (source_account_id, target_account_id, amount) values (1, 2, 10) returning *;</em></strong>|</span></pre><p id="41ae" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果您注意到，第二个事务中的 select 查询被我们在不同表的第一个事务中执行的 insert 阻塞了。让我们理解为什么，但在此之前，让我们看看数据库中尚未释放的所有锁。</p><pre class="ka kb kc kd fd kp ko kq kr aw ks bi"><span id="e75d" class="kt ku hi ko b fi kv kw l kx ky"><strong class="ko hj">SELECT a.datname,<br/>         l.relation::regclass,<br/>         l.transactionid,<br/>         l.mode,<br/>         l.GRANTED,<br/>         a.usename,<br/>         a.query,<br/>         a.query_start,<br/>         a.pid<br/>FROM pg_stat_activity a<br/>JOIN pg_locks l ON l.pid = a.pid<br/>where granted = false<br/>ORDER BY a.pid;</strong></span><span id="fd3b" class="kt ku hi ko b fi lo kw l kx ky">----------------------------------------------</span><span id="2c00" class="kt ku hi ko b fi lo kw l kx ky">datname|relation|transactionid|mode     |granted|usename  |query                                                 |query_start        |pid|<br/>-------+--------+-------------+---------+-------+---------+------------------------------------------------------+-------------------+---+<br/><strong class="ko hj"><em class="ju">movieDB</em></strong>|        |5210113      |<strong class="ko hj"><em class="ju">ShareLock</em></strong>|false  |developer|select * from account_details where id = 1 for update;|2021-08-04 10:44:24|987|</span></pre><p id="c722" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">锁定模式为<code class="du kl km kn ko b">ShareLock</code>。让我们分析一下为什么我们的查询列表中有<code class="du kl km kn ko b">ShareLock</code>，然后让我们继续第<strong class="ih hj">个事务</strong>直到死锁。</p><p id="1afe" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">第一笔交易完成:</strong></p><figure class="ka kb kc kd fd ke er es paragraph-image"><div role="button" tabindex="0" class="kf kg di kh bf ki"><div class="er es lp"><img src="../Images/832b3fd546cd715afc2de62070ea4c59.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rDXfLN2L60PrVliHQu8kgw.png"/></div></div></figure><p id="d900" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">这里为什么会出现僵局？</strong></p><p id="036b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果您观察这个模式，<code class="du kl km kn ko b">transfers</code>表在<code class="du kl km kn ko b">account_details(id)</code>表上有外键约束<code class="du kl km kn ko b">source_account_id and target_account_id</code>。对表的任何更新都会影响这些外键约束。所以当我们使用<code class="du kl km kn ko b">SELECT For UPDATE ON account_details</code>时，它需要获得外键约束的锁，并保证数据的一致性。</p><p id="9c67" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">绕过</strong></p><p id="52d8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">最简单的方法是删除 transactions 表上的外键约束。但不建议这样做。</p><p id="e1b6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">一个完美的解决方案</strong></p><p id="c5de" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果您查看更新查询，您会发现我们从未更改过表的主键。我们修改底层的列。那么，如果我们让 Select query 知道我们没有更新 ID，我们更新了其他列。这应该能解决我们的问题。如下所示更新选择查询</p><pre class="ka kb kc kd fd kp ko kq kr aw ks bi"><span id="126c" class="kt ku hi ko b fi kv kw l kx ky">SELECT * FROM account_details where account_id = 1 <strong class="ko hj">FOR NO KEY UPDATE</strong>;</span></pre><p id="abfa" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们重新运行测试用例。</p><figure class="ka kb kc kd fd ke er es paragraph-image"><div role="button" tabindex="0" class="kf kg di kh bf ki"><div class="er es lq"><img src="../Images/4cc369b9d289c0aa0ecaba25608888cd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SiCVQ8b9piC67AA0aEYZbA.png"/></div></div></figure><p id="8490" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">方案二</strong></p><p id="6201" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果您观察代码，就会发现有一个不必要的 select 语句来获取帐户余额。在 SQL 中，这是不需要的，我们可以编写更新查询来将余额从以前的值修改为新值。</p><pre class="ka kb kc kd fd kp ko kq kr aw ks bi"><span id="0987" class="kt ku hi ko b fi kv kw l kx ky"><strong class="ko hj"><em class="ju">UPDATE account_details SET balance = balance + $(amount) where ID = :ID;</em></strong></span></pre><p id="63bd" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们修改代码并重新运行测试。</p><figure class="ka kb kc kd fd ke er es paragraph-image"><div role="button" tabindex="0" class="kf kg di kh bf ki"><div class="er es lr"><img src="../Images/9f28b81daaa8fec358ee4d6a162b3d61.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cVc7DsaxjEhfiOSiwt6PhQ.png"/></div></div></figure><figure class="ka kb kc kd fd ke er es paragraph-image"><div role="button" tabindex="0" class="kf kg di kh bf ki"><div class="er es ls"><img src="../Images/e551adadd847b756ace7c788af519cf9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_S47VJjulsV4UHl9_D36ug.png"/></div></div></figure><h1 id="36ff" class="lt ku hi bd lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp bi translated"><strong class="ak">学习:</strong></h1><p id="1ba6" class="pw-post-body-paragraph if ig hi ih b ii mq ik il im mr io ip iq ms is it iu mt iw ix iy mu ja jb jc hb bi translated">有两种方法可以修复死锁情况，一种是修复潜在的问题，另一种是逃离或避免死锁情况。我们在上面的用例中已经看到了这两种情况。<code class="du kl km kn ko b">Solution 1</code>正在解决问题，<code class="du kl km kn ko b">Solution 2</code>正在避免死锁情况。</p><p id="8257" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我更喜欢第二种方法，不要陷入死锁状态，总是正确的，干净的代码。<strong class="ih hj"> <em class="ju">说到清理上面的代码库还是有一些问题让我们来看看。</em>T3】</strong></p><p id="835e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">问题二</strong></p><p id="a4f3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">到目前为止，我们所做的是总是以同样的顺序更新余额。，帐户 ID: 1 到帐户 Id: 2。如果出现不知道更新 ie 顺序的场景怎么办？，它可以是源到目标，反之亦然。</p><p id="3927" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们在 psql 中运行并行事务</p><p id="b001" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">交易 1 </strong></p><pre class="ka kb kc kd fd kp ko kq kr aw ks bi"><span id="5cdd" class="kt ku hi ko b fi kv kw l kx ky"><strong class="ko hj">begin</strong>;<br/><strong class="ko hj">update</strong> account_details <strong class="ko hj">set</strong> balance = balance - 10 <strong class="ko hj">where</strong> id = 1 <strong class="ko hj">returning</strong> *;</span><span id="3e6c" class="kt ku hi ko b fi lo kw l kx ky"><strong class="ko hj">update</strong> account_details <strong class="ko hj">set</strong> balance = balance + 10 <strong class="ko hj">where</strong> id = 2 <strong class="ko hj">returning</strong> *;</span><span id="8230" class="kt ku hi ko b fi lo kw l kx ky"><strong class="ko hj">rollback</strong></span></pre><p id="864d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">交易 2 </strong></p><pre class="ka kb kc kd fd kp ko kq kr aw ks bi"><span id="8176" class="kt ku hi ko b fi kv kw l kx ky"><strong class="ko hj">begin</strong>;<br/><strong class="ko hj">update</strong> account_details <strong class="ko hj">set</strong> balance = balance - 10 <strong class="ko hj">where</strong> id = 2 <strong class="ko hj">returning</strong> *;</span><span id="a63c" class="kt ku hi ko b fi lo kw l kx ky"><strong class="ko hj">update</strong> account_details <strong class="ko hj">set</strong> balance = balance + 10 <strong class="ko hj">where</strong> id = 1 <strong class="ko hj">returning</strong> *;</span><span id="e39f" class="kt ku hi ko b fi lo kw l kx ky"><strong class="ko hj">rollback</strong></span></pre><figure class="ka kb kc kd fd ke er es paragraph-image"><div role="button" tabindex="0" class="kf kg di kh bf ki"><div class="er es mv"><img src="../Images/6e9f93b1490a48d421d8e467143dda8e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*eElJNTP2ASJ_nbSociZqTA.png"/></div></div></figure><figure class="ka kb kc kd fd ke er es paragraph-image"><div role="button" tabindex="0" class="kf kg di kh bf ki"><div class="er es mw"><img src="../Images/d1902b8b9d4107c5a54a3d63cab5d2a3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rPQ9nyWHys-B3wIj4HBdVQ.png"/></div></div></figure><p id="13a6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们看看被阻塞的查询以及阻塞它们的原因。再次运行与之前相同的查询。</p><pre class="ka kb kc kd fd kp ko kq kr aw ks bi"><span id="8211" class="kt ku hi ko b fi kv kw l kx ky">blocked_pid|blocked_user|blocking_pid|blocking_user|blocked_statement                                                          |current_statement_in_blocking_process                                      |<br/>-----------+------------+------------+-------------+---------------------------------------------------------------------------+---------------------------------------------------------------------------+<br/>       2485|developer   |        2492|developer    |<strong class="ko hj"><em class="ju">update account_details set balance = balance + 10 where id = 2 returning *;</em></strong>|<strong class="ko hj">update account_details set balance = balance - 10 where id = 2 returning *;</strong>|</span></pre><p id="6573" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">还要分析锁的类型。</p><pre class="ka kb kc kd fd kp ko kq kr aw ks bi"><span id="bc10" class="kt ku hi ko b fi kv kw l kx ky">datname|relation|transactionid|mode     |granted|usename  |query                                                                      |query_start        |pid |<br/>-------+--------+-------------+---------+-------+---------+---------------------------------------------------------------------------+-------------------+----+<br/>movieDB|        |5210137      |<strong class="ko hj">ShareLock</strong>|false  |developer|update account_details set balance = balance + 10 where id = 2 returning *;|2021-08-04 11:39:56|2485|</span></pre><p id="601e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果我们在第二个事务中更新 id 1，就会检测到死锁。</p><figure class="ka kb kc kd fd ke er es paragraph-image"><div role="button" tabindex="0" class="kf kg di kh bf ki"><div class="er es mx"><img src="../Images/0bf6d4bde50e1e3c8d79de830ca88bd8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Re-klgxJ9fiELFdeEzidDA.png"/></div></div></figure><p id="8fd0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">因为我们在第二个事务中执行了对 ID 2 的更新，该事务尚未提交。如果我们试图在另一个事务中更新相同的 id，那么就会检测到死锁。</p><p id="6ab8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">以测试用例的形式实现相同的功能。启动了 10 个并发传输并循环运行。对于偶数索引，源和目标是相同的。对于奇数索引，则相反。</p><figure class="ka kb kc kd fd ke"><div class="bz dy l di"><div class="lb lc l"/></div></figure><p id="e29e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这是测试用例的结果，一个死锁。</p><figure class="ka kb kc kd fd ke er es paragraph-image"><div role="button" tabindex="0" class="kf kg di kh bf ki"><div class="er es my"><img src="../Images/f099a968a11321fe5f5a97296b9e2f4a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xtD_ZojX5K4LoKmajT_LMg.png"/></div></div></figure><p id="1931" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">解决方案</strong></p><p id="6a04" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">死锁的原因是不同事务中的插入顺序，我们必须遵循事务中相同的更新/插入顺序。我已经修改了主 go 文件中的代码。<strong class="ih hj"> <em class="ju">始终从较低的帐户 id 更新，然后从较高的帐户 id 更新。</em>T15】</strong></p><figure class="ka kb kc kd fd ke er es paragraph-image"><div role="button" tabindex="0" class="kf kg di kh bf ki"><div class="er es mz"><img src="../Images/eefaa8eec09553dfeae3be489d3c16a8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xZ-rcXL_zLN55ZGSQ1Zjsw.png"/></div></div></figure><figure class="ka kb kc kd fd ke er es paragraph-image"><div role="button" tabindex="0" class="kf kg di kh bf ki"><div class="er es na"><img src="../Images/1b08fee83eb468d1278330eca735194e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uBHHWKN0JszCwx6yhBreWg.png"/></div></div></figure><h1 id="781b" class="lt ku hi bd lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp bi translated"><strong class="ak">学习</strong></h1><p id="49a3" class="pw-post-body-paragraph if ig hi ih b ii mq ik il im mr io ip iq ms is it iu mt iw ix iy mu ja jb jc hb bi translated">In transactions 总是以相同的顺序实现插入/更新。这将有助于事务以干净的方式进行，并避免数据库获得不必要的锁。</p><p id="6f4b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">请从<a class="ae la" href="https://github.com/ereshzealous/movielikes" rel="noopener ugc nofollow" target="_blank">这里</a>找到源代码</p></div></div>    
</body>
</html>