<html>
<head>
<title>Creating a Homing Projectile in Unity</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在 Unity 中创建一个寻的射弹</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/creating-a-homing-projectile-in-unity-81787b4316e2?source=collection_archive---------1-----------------------#2022-07-07">https://medium.com/nerd-for-tech/creating-a-homing-projectile-in-unity-81787b4316e2?source=collection_archive---------1-----------------------#2022-07-07</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/4f3f9ee59f6c98fd9bb731a3cce0ba93.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*0ObjrY4Fsz2LHKjNOcUfRw.gif"/></div></div></figure><p id="b7b0" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">今天的核心编码挑战将会有点重数学和物理，但不用担心！一如既往，我们将一步一步来，并在前进的过程中分解每件事情。</p><p id="2b8e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">目标</strong>:制造一个自动瞄准最近敌人的制导炮弹，<em class="jo">瞄准</em>直到它击中目标。</p></div><div class="ab cl jp jq gp jr" role="separator"><span class="js bw bk jt ju jv"/><span class="js bw bk jt ju jv"/><span class="js bw bk jt ju"/></div><div class="hb hc hd he hf"><h1 id="0467" class="jw jx hi bd jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt bi translated">设置全局变量</h1><p id="fb50" class="pw-post-body-paragraph iq ir hi is b it ku iv iw ix kv iz ja jb kw jd je jf kx jh ji jj ky jl jm jn hb bi translated">您将需要两组全局变量:第一组用于目标逻辑，第二组用于运动物理。</p><blockquote class="kz la lb"><p id="7313" class="iq ir jo is b it iu iv iw ix iy iz ja lc jc jd je ld jg jh ji le jk jl jm jn hb bi translated"><strong class="is hj">注意</strong>:这个脚本将会附加到射弹/导弹物体上。</p></blockquote><figure class="lg lh li lj fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lf"><img src="../Images/bb66e5371de30d645a30708cfd88c510.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rthyCF_Bb1MSXkSuruKVSg.png"/></div></div></figure><ul class=""><li id="26d5" class="lk ll hi is b it iu ix iy jb lm jf ln jj lo jn lp lq lr ls bi translated">目标变量将是 Transform 类型的，因为所有对象都有一个转换，我们将利用它来找到我们想要的特定对象。</li><li id="1b78" class="lk ll hi is b it lt ix lu jb lv jf lw jj lx jn lp lq lr ls bi translated"><strong class="is hj">目标</strong>将是一个游戏对象数组，因为这将用于捕捉场景中每个有敌人标签的对象，这就是我们如何指定目标(这将在本文后面显示)。</li></ul><figure class="lg lh li lj fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ly"><img src="../Images/82aa03fa36715b5dd29cbaeb9f07a9cb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*I8vi-OjcDRWPSYISeVBbkg.png"/></div></div></figure><ul class=""><li id="455b" class="lk ll hi is b it iu ix iy jb lm jf ln jj lo jn lp lq lr ls bi translated"><strong class="is hj">刚体 2D </strong>是附着在抛射体物体上的刚体组件。刚体使得在 unity 中使用物理成为可能，我们将使用物理来解释抛射体的运动逻辑。这个变量是一个<strong class="is hj"> SerializeField </strong>，因为我们需要在检查器中分配抛射体对象的刚体。为此，只需将带有附加刚体的对象拖放到检查器中。</li></ul><figure class="lg lh li lj fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lz"><img src="../Images/27e4d6e75204d8f96bb2c1234f502529.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*AYuALFKDOnl0RmFQ0yz2cw.gif"/></div></div></figure><ul class=""><li id="9eb4" class="lk ll hi is b it iu ix iy jb lm jf ln jj lo jn lp lq lr ls bi translated"><strong class="is hj"> _distance </strong>这有助于我们确定我们的抛射体需要穿越的<em class="jo">距离</em>以到达<strong class="is hj">_ 最近的目标</strong>，该目标是它将撞击的物体。</li><li id="bae9" class="lk ll hi is b it lt ix lu jb lv jf lw jj lx jn lp lq lr ls bi translated"><strong class="is hj"> _closestTarget </strong>正在使用 Unity 的 Mathf 类，这是一个常用数学函数的集合，其中一些包括三角函数。这里我们使用<strong class="is hj"> Infinity </strong>因为我们在寻找可以在我们场景的任何无限点上的物体，当然，我们很快会缩小范围。</li><li id="c707" class="lk ll hi is b it lt ix lu jb lv jf lw jj lx jn lp lq lr ls bi translated"><strong class="is hj">_ 速度</strong>:物体直线运动的速度。</li><li id="e9ec" class="lk ll hi is b it lt ix lu jb lv jf lw jj lx jn lp lq lr ls bi translated"><strong class="is hj">_ rotations speed</strong>对象的轴心点向给定目标方向旋转的速度。下图展示了更好的视觉效果。</li></ul><figure class="lg lh li lj fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ma"><img src="../Images/2ede83a788671c36bfa5c2615119b4f4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Tp95yp2joPTztEjM.gif"/></div></div><figcaption class="mb mc et er es md me bd b be z dx translated"><a class="ae mf" href="https://80.lv/articles/tutorial-an-orbital-parallax-effect-with-hexels/" rel="noopener ugc nofollow" target="_blank">图像来源</a></figcaption></figure><blockquote class="kz la lb"><p id="fc1b" class="iq ir jo is b it iu iv iw ix iy iz ja lc jc jd je ld jg jh ji le jk jl jm jn hb bi translated"><strong class="is hj">注</strong>:先前的速度值有很高的数字，如你所见，这是这些值相互配合并产生足够的力使物体相应移动所必需的。否则，<strong class="is hj">抛射物体可能会卡在围绕目标的轨道上，而不是真正击中它</strong>。你可以随意摆弄这些价值观，看看什么对你有用，但是<strong class="is hj">如果你在 akward 运动中遇到问题，很可能就是这些价值观。</strong></p></blockquote></div><div class="ab cl jp jq gp jr" role="separator"><span class="js bw bk jt ju jv"/><span class="js bw bk jt ju jv"/><span class="js bw bk jt ju"/></div><div class="hb hc hd he hf"><h1 id="1d73" class="jw jx hi bd jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt bi translated">寻找最近的目标</h1><p id="8ef4" class="pw-post-body-paragraph iq ir hi is b it ku iv iw ix kv iz ja jb kw jd je jf kx jh ji jj ky jl jm jn hb bi translated">现在所有的变量都设置好了，是时候寻找最近的目标了！第一个 void 方法是寻找最近的目标，并指定什么是目标。</p><ol class=""><li id="8ea9" class="lk ll hi is b it iu ix iy jb lm jf ln jj lo jn mg lq lr ls bi translated">使用你的 targets 变量(GameObject 数组)，并将其设置为专门查找带有“敌人”标签的对象。它可以是你的目标对象拥有的任何标签，它都一样工作。</li></ol><figure class="lg lh li lj fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mh"><img src="../Images/538a56169ac4d2678ab3612c4aa4d1cb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*j8HsAf0nrkpQZ8LYVfGErw.png"/></div></div></figure><blockquote class="kz la lb"><p id="24f5" class="iq ir jo is b it iu iv iw ix iy iz ja lc jc jd je ld jg jh ji le jk jl jm jn hb bi translated"><strong class="is hj">注意:</strong>这个方法要求你已经给你的对象分配了标签。通过选择对象并转到顶部，可以在检查器中分配标签。</p></blockquote><p id="5759" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">2.这里我们使用一个 foreach 循环，因为它将为在我们的目标游戏对象数组中找到的每个敌人对象运行<em class="jo">。</em></p><figure class="lg lh li lj fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mi"><img src="../Images/9406286a31016895ffab5f754ca190e9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wxqPZgOrznUVSAn7HPdpvQ.png"/></div></div></figure><ul class=""><li id="efe1" class="lk ll hi is b it iu ix iy jb lm jf ln jj lo jn lp lq lr ls bi translated"><strong class="is hj"> _distance </strong>变量被设置为敌人的变形位置，从当前射弹的位置中减去。</li><li id="4e22" class="lk ll hi is b it lt ix lu jb lv jf lw jj lx jn lp lq lr ls bi translated"><a class="ae mf" href="https://docs.unity3d.com/ScriptReference/Mathf.Sqrt.html" rel="noopener ugc nofollow" target="_blank"> <strong class="is hj"> sqrMagnitude </strong> </a>实际上是允许我们使用毕达哥拉斯理论(是的，你实际上在校外使用它！).</li></ul><figure class="lg lh li lj fd ij er es paragraph-image"><div class="er es mj"><img src="../Images/cc6a75e1b4fae87a2ae53ffd7ee32d87.png" data-original-src="https://miro.medium.com/v2/resize:fit:1158/format:webp/1*LWmSlQL4YzCOw-LUs-HXGQ.png"/></div><figcaption class="mb mc et er es md me bd b be z dx translated"><a class="ae mf" href="http://www.nabla.hr/BA-PlaneFigureTrianA.htm" rel="noopener ugc nofollow" target="_blank">图像来源</a></figcaption></figure><p id="1667" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">让我进一步分析一下…</p><p id="ef66" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">所以，想象你要击中的目标在下面三角形的<strong class="is hj">位置 B </strong>，你在<strong class="is hj">位置 C </strong>。要计算两点之间的距离，需要求解长边，或者说<strong class="is hj">斜边</strong>。</p><figure class="lg lh li lj fd ij er es paragraph-image"><div class="er es mj"><img src="../Images/f928693c30ca6844d46287c086722134.png" data-original-src="https://miro.medium.com/v2/resize:fit:1158/format:webp/1*D-1gaX4y9iFqI8KQf2bI7w.png"/></div></figure><p id="a788" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">Unity 是一个非常棒的工具，你所要做的就是使用简单的 sqrMagnitude！</p><p id="ed5b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">2.对于 foreach 的最后一部分，我们将添加一个 if 语句来检查<strong class="is hj"> _distance </strong>是否小于<strong class="is hj"> _closerDistance。如果条件满足，我们将我们的目标，也就是变换变量，分配给敌人的变换变量。</strong></p><blockquote class="kz la lb"><p id="e134" class="iq ir jo is b it iu iv iw ix iy iz ja lc jc jd je ld jg jh ji le jk jl jm jn hb bi translated">注意:记住，一个对象的变换携带了它所有的位置信息。这就是为什么这行得通。</p></blockquote><figure class="lg lh li lj fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mi"><img src="../Images/6cb24a6637649a2415fbd5bda7ecc6e5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2j-GE1E0XrCYomums11iag.png"/></div></div></figure></div><div class="ab cl jp jq gp jr" role="separator"><span class="js bw bk jt ju jv"/><span class="js bw bk jt ju jv"/><span class="js bw bk jt ju"/></div><div class="hb hc hd he hf"><h1 id="0fa5" class="jw jx hi bd jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt bi translated">创建点火方法</h1><p id="8f66" class="pw-post-body-paragraph iq ir hi is b it ku iv iw ix kv iz ja jb kw jd je jf kx jh ji jj ky jl jm jn hb bi translated">创建点火方法主要是使用 Unity 的引擎物理。</p><ol class=""><li id="20a8" class="lk ll hi is b it iu ix iy jb lm jf ln jj lo jn mg lq lr ls bi translated">在开始，得到刚体组件。您还可以在这里添加 findClosestEnemy 函数。</li></ol><blockquote class="kz la lb"><p id="86d7" class="iq ir jo is b it iu iv iw ix iy iz ja lc jc jd je ld jg jh ji le jk jl jm jn hb bi translated"><strong class="is hj">注意</strong>:当获取一个组件时，最好检查它是否为空，以避免不必要的错误和问题。</p></blockquote><figure class="lg lh li lj fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mk"><img src="../Images/1bb121c2df812678a5db9251a91d4c5d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oyiiOvdtZVnQPMNmfbvSDw.png"/></div></div></figure><p id="c3c5" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">2.创建一个 void 方法来发射炮弹。我们要在这个方法中加入的第一件事是抛射体的速度。</p><p id="58d9" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在物理学中，我们认为<strong class="is hj">速度</strong>是一个<strong class="is hj">矢量</strong>，它包含了给定时刻物体的<strong class="is hj">方向</strong>和<strong class="is hj">速度</strong>。所以，这正是我们将在这里指定的。</p><figure class="lg lh li lj fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mk"><img src="../Images/af324539746c7ca47a551c7e0f196918.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ESzP4mZpTB5RPhTu-tLTpw.png"/></div></div></figure><p id="a526" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">3.接下来，我们添加一个 if 语句来检查目标数组是否不为空。</p><figure class="lg lh li lj fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ml"><img src="../Images/77e50c7cb094b0abb5d18f764cd6d55b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yEhe5bL7y3kv448YrN-jug.png"/></div></div></figure><ul class=""><li id="b6f9" class="lk ll hi is b it iu ix iy jb lm jf ln jj lo jn lp lq lr ls bi translated">如果满足这个条件，我们就有了一个方向向量，它负责减去目标的位置和刚体的位置(我们的抛射体)。这将使物体之间的距离减少，导致它开始接近。</li><li id="218e" class="lk ll hi is b it lt ix lu jb lv jf lw jj lx jn lp lq lr ls bi translated"><strong class="is hj">方向向量被归一化</strong>。当我们归一化一个向量时，它本质上意味着我们希望向量<strong class="is hj">保持相同的方向</strong>——我们希望它保持稳定不变。这也将使向量成为一个单位向量，这意味着它的长度现在是 1.0(这不影响行进的距离)。</li></ul><p id="b3de" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">4.最后，该方法需要实际设置射弹在行进所需距离时将进行的适当运动。如前所述，如果没有正确设置，抛射体可能会漫无目的地游荡或绕着目标旋转，而不是击中目标。让我们一步步来看这个。</p><figure class="lg lh li lj fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ml"><img src="../Images/93350a0d794f3cf8d5520e00dc3e81a9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*11972DNu0DHOLznWk15mRw.png"/></div></div></figure><ul class=""><li id="dac1" class="lk ll hi is b it iu ix iy jb lm jf ln jj lo jn lp lq lr ls bi translated"><strong class="is hj">旋转值</strong>使用 Unity 的<a class="ae mf" href="https://docs.unity3d.com/ScriptReference/Vector3.Cross.html" rel="noopener ugc nofollow" target="_blank"> Vector3.Cross。两个向量的叉积产生第三个向量，该向量垂直于两个输入向量</a>。垂直意味着它的结果将是一条从其他两个向量展开的 90 度线。</li></ul><figure class="lg lh li lj fd ij er es paragraph-image"><div class="er es mm"><img src="../Images/490c1f82b3c2b70fca0d019dc8eaf685.png" data-original-src="https://miro.medium.com/v2/resize:fit:758/format:webp/0*71KcJ5mK4-SEhvZi.png"/></div><figcaption class="mb mc et er es md me bd b be z dx translated">图片由 Unity AP 提供</figcaption></figure><ul class=""><li id="efdc" class="lk ll hi is b it iu ix iy jb lm jf ln jj lo jn lp lq lr ls bi translated">HomingProjectileRB 的<a class="ae mf" href="https://docs.unity3d.com/ScriptReference/Rigidbody-angularVelocity.html" rel="noopener ugc nofollow" target="_blank"> <strong class="is hj">角速率</strong> </a>，也被称为抛射体的刚体，是 Unity 的引擎内物理系统的一部分。这是刚体的速度矢量，单位是弧度每秒。我们将使用之前建立的旋转变量来进一步操纵它。</li><li id="3f2f" class="lk ll hi is b it lt ix lu jb lv jf lw jj lx jn lp lq lr ls bi translated">为了结束 if 语句，我们最后一次设置<strong class="is hj">速度</strong>。这需要在 if 语句的外部和内部，因为无论是否有目标，射弹都会在发射时移动。我们需要 if 语句块来修改这种移动，以便在找到目标时，它能够正确地向目标移动。</li></ul><p id="dc5b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">5.将触发方法添加到 FixedUpdate。每当我们的方法依赖于引擎物理的统一性时，我们就使用固定更新。</p><figure class="lg lh li lj fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mn"><img src="../Images/ca91bd479abd13591223eb425ce28ff8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5mAZ27iUuPuENNBk1IOtww.png"/></div></div></figure></div><div class="ab cl jp jq gp jr" role="separator"><span class="js bw bk jt ju jv"/><span class="js bw bk jt ju jv"/><span class="js bw bk jt ju"/></div><div class="hb hc hd he hf"><h1 id="9b34" class="jw jx hi bd jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt bi translated">可选的越界参数</h1><p id="3439" class="pw-post-body-paragraph iq ir hi is b it ku iv iw ix kv iz ja jb kw jd je jf kx jh ji jj ky jl jm jn hb bi translated">你在 fire 方法中看到的最后一个方法只是一个死区参数，我设置这个参数是为了让抛射体对象在出界时被销毁。这种情况只发生在没有目标并且射弹被发射的情况下，这意味着它会在场景中无限移动直到被摧毁。如果您愿意，您可以设置自己的参数或使用其他方法来消除该对象。这些是我的参数。</p><figure class="lg lh li lj fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ml"><img src="../Images/9c41bc86f6ce5ca8f09f350008b39e81.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xpjEPs8Wld0i5bT_nqCoNA.png"/></div></div></figure></div><div class="ab cl jp jq gp jr" role="separator"><span class="js bw bk jt ju jv"/><span class="js bw bk jt ju jv"/><span class="js bw bk jt ju"/></div><div class="hb hc hd he hf"><h1 id="49ce" class="jw jx hi bd jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt bi translated">结果呢</h1><figure class="lg lh li lj fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mo"><img src="../Images/b2c63333526d7cd9940267ed6abeda0b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*qaW22EqM5ujRs1Q39C8-6A.gif"/></div></div></figure></div><div class="ab cl jp jq gp jr" role="separator"><span class="js bw bk jt ju jv"/><span class="js bw bk jt ju jv"/><span class="js bw bk jt ju"/></div><div class="hb hc hd he hf"><p id="c8ae" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这是来自 GameDevHQ 的一系列编码挑战的一部分！在下一个，也是最后一个挑战中，我们将会看到有多个阶段的 boss 战斗代码！</p><p id="216f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">特别感谢 Hiren Namera 帮助我找到了这次挑战的逻辑！我喜欢分解编码逻辑，并期待了解更多！</p></div></div>    
</body>
</html>