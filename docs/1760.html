<html>
<head>
<title>Strategy Pattern in Microservices</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">微服务中的策略模式</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/strategy-pattern-in-microservices-d93c67f7d5f0?source=collection_archive---------3-----------------------#2021-04-05">https://medium.com/nerd-for-tech/strategy-pattern-in-microservices-d93c67f7d5f0?source=collection_archive---------3-----------------------#2021-04-05</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="0254" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如今，对于任何主要的应用程序开发项目来说，微服务体系结构已经成为首选的解决方案。</p><p id="2811" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们可以把<a class="ae jd" rel="noopener" href="/javarevisited/10-best-java-microservices-courses-with-spring-boot-and-spring-cloud-6d04556bdfed?source=rss-bb36d8439904------2&amp;utm_source=dlvr.it&amp;utm_medium=linkedin">微服务</a>想象成一组处理单元任务的轻量级服务，而不是一个完成所有任务的单片软件。这种架构解决了各种问题，但是构建微服务架构有其自身的挑战。</p><p id="c481" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在本文中，我们不会讨论如何构建微服务解决方案，而是讨论在单个微服务中，策略模式会有多大帮助。</p></div><div class="ab cl je jf gp jg" role="separator"><span class="jh bw bk ji jj jk"/><span class="jh bw bk ji jj jk"/><span class="jh bw bk ji jj"/></div><div class="hb hc hd he hf"><h1 id="1c34" class="jl jm hi bd jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki bi translated"><strong class="ak">用例</strong></h1><p id="e384" class="pw-post-body-paragraph if ig hi ih b ii kj ik il im kk io ip iq kl is it iu km iw ix iy kn ja jb jc hb bi translated">为了理解它，让我们来看一个简单的问题陈述:</p><p id="61b2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们将开发一个“地理定位”服务，它将返回给定地址的纬度/经度。</p><p id="bf7c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">服务将有一个端点，它将为我提供给定地址的纬度/经度。为了获得纬度/经度，让我们假设客户端已经请求使用Google地图地理编码API。</p><p id="b69b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这方面的步骤非常简单:</p><ol class=""><li id="949b" class="ko kp hi ih b ii ij im in iq kq iu kr iy ks jc kt ku kv kw bi translated">定义一个采用城市名称的端点(/coordinates/for/city/{ city name })</li><li id="d1ba" class="ko kp hi ih b ii kx im ky iq kz iu la iy lb jc kt ku kv kw bi translated">编写一个服务类，调用带有城市名称的外部API，并返回纬度/经度结果。</li></ol><p id="8bd2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">到目前为止还不错，我们有一个服务，可以根据谷歌地图API给我提供位置信息。</p><p id="8f83" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在我们决定在多个客户机上使用这个服务，或者说我们想在另一个应用程序中使用这个服务。直到顾客/客户同意我们使用谷歌地图应用编程接口没有问题，但说一些客户想利用其他地理定位应用编程接口，如地理边界，telize，地图瓦片等。为了同样的任务。在这种情况下，我们必须更新服务代码来处理它。</p><p id="b7cb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这种变化的需求需要一种策略来决定内部使用哪个服务来获得相同的纬度/经度响应，但是底层服务或者说底层算法是不同的。</p><p id="3d36" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">此外，有一个单一的<a class="ae jd" href="https://javarevisited.blogspot.com/2021/09/microservices-design-patterns-principles.html" rel="noopener ugc nofollow" target="_blank">微服务</a>来执行让地理定位对不同的地理定位API提供者提供底层支持的任务也是有意义的。因此，让我们看看什么是战略模式，以及它如何适应这种情况。</p></div><div class="ab cl je jf gp jg" role="separator"><span class="jh bw bk ji jj jk"/><span class="jh bw bk ji jj jk"/><span class="jh bw bk ji jj"/></div><div class="hb hc hd he hf"><h1 id="aee0" class="jl jm hi bd jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki bi translated">战略模式</h1><p id="0668" class="pw-post-body-paragraph if ig hi ih b ii kj ik il im kk io ip iq kl is it iu km iw ix iy kn ja jb jc hb bi translated">正如Wiki所言，“这是一种行为设计模式，支持在运行时选择算法。代码不是直接实现单个算法，而是接收运行时指令，以决定使用哪一组算法。”</p><p id="e026" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这正好符合我们的问题陈述，我们现在将支持一组地理定位服务并返回纬度/经度，但是选择哪个底层服务将根据客户端提供的运行时指令而有所不同。</p><p id="0445" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">下图U <a class="ae jd" rel="noopener" href="/javarevisited/5-best-uml-books-and-courses-for-java-programmers-13c551a9235d?source=user_profile---------25----------------------------"> ML图</a>显示了我们将如何构建解决方案。GoogleMapLocationContext将被注入rest控制器中。</p><figure class="ld le lf lg fd lh er es paragraph-image"><a href="https://www.java67.com/2014/12/strategy-pattern-in-java-with-example.html"><div class="er es lc"><img src="../Images/00b9d07ba4d2368f69fa87e722c7a4aa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*P4SSOj9qv9zGOEBBDpt0IQ.png"/></div></a><figcaption class="lk ll et er es lm ln bd b be z dx translated">战略地理位置</figcaption></figure></div><div class="ab cl je jf gp jg" role="separator"><span class="jh bw bk ji jj jk"/><span class="jh bw bk ji jj jk"/><span class="jh bw bk ji jj"/></div><div class="hb hc hd he hf"><h1 id="2533" class="jl jm hi bd jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki bi translated">实际设置</h1><p id="8196" class="pw-post-body-paragraph if ig hi ih b ii kj ik il im kk io ip iq kl is it iu km iw ix iy kn ja jb jc hb bi translated">我们将使用springboot 2.4.4来演示该解决方案，其中我们将有一个单一的端点，它将根据城市和服务提供商来确定底层服务。在服务中，我们将打印日志语句并返回虚拟数据。</p><h1 id="ec32" class="jl jm hi bd jn jo lo jq jr js lp ju jv jw lq jy jz ka lr kc kd ke ls kg kh ki bi translated">解决办法</h1><figure class="ld le lf lg fd lh"><div class="bz dy l di"><div class="lt lu l"/></div></figure><h1 id="6cdf" class="jl jm hi bd jn jo lo jq jr js lp ju jv jw lq jy jz ka lr kc kd ke ls kg kh ki bi translated">Swagger UI</h1><figure class="ld le lf lg fd lh er es paragraph-image"><a href="https://javarevisited.blogspot.com/2022/01/top-5-courses-to-learn-swagger-or-open.html"><div class="er es lv"><img src="../Images/c1be9c9dfa9006bb24762249e9edd01d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Vc-PGEjMNMi-EDECGU1FIA.png"/></div></a></figure><h1 id="6371" class="jl jm hi bd jn jo lo jq jr js lp ju jv jw lq jy jz ka lr kc kd ke ls kg kh ki bi translated">优势</h1><p id="9569" class="pw-post-body-paragraph if ig hi ih b ii kj ik il im kk io ip iq kl is it iu km iw ix iy kn ja jb jc hb bi translated">通过这种方法，我们获得了一种灵活的设计，其中选择哪个底层服务的决定被推迟到运行时，使其模块化并可以在多个应用程序中作为服务使用。</p><p id="7fe3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">当客户端尝试通过swagger测试提供程序选择类型时，使用Enum而不是String来定义GeoProviders会使提供程序选择类型变得安全。此外，我们现在可以利用<a class="ae jd" href="https://www.java67.com/2016/09/difference-between-identityhashmap-weakhashmap-enummap-in-java.html" rel="noopener ugc nofollow" target="_blank">枚举映射</a>，在我们的例子中，它比<a class="ae jd" href="https://www.java67.com/2017/08/top-10-java-hashmap-interview-questions.html" rel="noopener ugc nofollow" target="_blank">散列表</a>性能更好，在这里我们为不同的策略创建上下文。</p><p id="bed5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这种方法也使得代码更加清晰和易于维护。我们可以在单个服务中使用条件检查(if，switch case ),而不是<a class="ae jd" href="https://javarevisited.blogspot.com/2014/11/strategy-design-pattern-in-java-using-Enum-Example.html" rel="noopener ugc nofollow" target="_blank">策略模式</a>,但是这将使服务中的一切变得混乱，使得维护起来有点困难。另外，对于一个看代码的新人来说，理解起来会有点困难。</p><p id="c50a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">使用strategy pattern，为新的geoprovider扩展代码将很容易，因为我们不必接触任何现有的代码，相反，我们在我们定义的<a class="ae jd" href="https://javarevisited.blogspot.com/2011/08/enum-in-java-example-tutorial.html" rel="noopener ugc nofollow" target="_blank"> Enum </a>中添加一个新的geoprovider类型，然后为新的提供者实现geo provider服务接口。就是这样！</p><p id="b4eb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">将增加对新地理位置类型的支持，从而避免破坏任何现有代码的机会。</p><h1 id="f97a" class="jl jm hi bd jn jo lo jq jr js lp ju jv jw lq jy jz ka lr kc kd ke ls kg kh ki bi translated">摘要</h1><p id="7970" class="pw-post-body-paragraph if ig hi ih b ii kj ik il im kk io ip iq kl is it iu km iw ix iy kn ja jb jc hb bi translated">我们从一个简单的地理定位服务的陈述开始，扩展到支持多个地理定位服务，并看到了策略模式如何在构建解决方案中发挥重要作用。</p><p id="3de4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">然后我们也看到了这种设计的优势。</p><p id="1d97" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我希望你们喜欢阅读这篇文章，并在开始设计策略时收获颇丰。</p></div></div>    
</body>
</html>