# 构建富文本编辑器:第 3 天

> 原文：<https://medium.com/nerd-for-tech/building-a-rich-text-editor-day-3-a5cf6a2ef600?source=collection_archive---------16----------------------->

## 设计模型事件

## [索引](https://svr8.medium.com/building-a-rich-text-editor-index-5d11d23c5111)

继续上一篇文章…我一直在思考通过事件发射器实现严格耦合和完全松散耦合之间的中间地带。

一整天，我都在开发设计，并且总是以数百个事件结束。为了在块中设置数据，我尝试将数据从 DOM 传递到文档、页面和块。当我从 DOM→Doc 级过渡到 Page→Block 级甚至逆向流时，我触发了一系列无用的事件，这些事件永远不会被使用。问题是将会有大量的块和相对较少的页面。

如果我选择严格耦合，我将失去在一个空间中让多个模型交互的优势。所以，我放弃了，开始写下每个模块将要订阅的事件。通过观察 DOM 事件，这很简单:

1.  鼠标按下
2.  鼠标移动
3.  鼠标抬起
4.  按键
5.  击键

就是这样。这些事件的所有组合都可能触发以下任何事件:

1.  caretUpdate
2.  块溢出
3.  splitAtCaret
4.  mergePreviousBlock
5.  mergeNextBlock
6.  选择

就是这样。这 6 个事件足以引起连锁反应，并让每个模型独立处理行为。这就是我看到 events:2–5 只与父页面交互的地方。*目录*和*选择*将直接与*文档*交互。因此，如果有 2 个应用程序，那么其他块将永远不会收到该页面的事件。类似地，一个页面将永远不会广播到其他页面的块，因为房间已经被限制。

这是我可以完全开发模型设计的地方。今天，我将建立一些我在第一天为发展建立的指导方针。

# 如何设计活动

每个模型都将订阅和发布与其直接可视化交互的事件。如果其他模型受到间接影响，接收模型有责任将事件传递到所需的位置。

例如，输入将触发 *keydown* 事件。这个 *keydown* 事件应该由特定的块来处理。与该模块直接交互的模型是其父模块*页面*和*插入符号*。

*Caret* 是一个跨不同页面与多个块交互的模型。但是，它始终是*文档*的一部分。在这种情况下，将假设 caret 是 *Doc* 模型的一部分，因此定位和与它通信将变得容易。

所以，规则如下:

1.  每个属性都将是*私有*或*公共只读*。该属性只能由 getter/setter 方法访问。
2.  每个 setter 方法都会更新值并触发任何必要的事件。
3.  通过模型触发的每个事件都应该到达在 DOM 中与它直接交互的模型。
4.  模型将只订阅直接与。
5.  如果模型不处理事件，它将不得不把事件传递给与之交互的其他模型。事件的目的也可以被认为是阻止事件的传播。

我已经为 Block 设计了模型。为所有模型设计完整的活动需要一些时间。明天，我将分享这个文档的完整设计，它将帮助任何人开发一个编辑器。

拜拜。

## [下一篇文章](https://svr8.medium.com/building-a-rich-text-editor-day-4-bb6af36521e7)