<html>
<head>
<title>Anatomy of a Microservice</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">微服务剖析</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/anatomy-of-a-microservice-c52b3cb30d30?source=collection_archive---------4-----------------------#2021-09-20">https://medium.com/nerd-for-tech/anatomy-of-a-microservice-c52b3cb30d30?source=collection_archive---------4-----------------------#2021-09-20</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="07dd" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">微服务如何工作</h2></div><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ix"><img src="../Images/54bb45dc69aa5fae591e0548e3318071.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qRHEjCsV0otqf7k-R6mRdQ.jpeg"/></div></div></figure><p id="f930" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated"><strong class="jl hj"> <em class="kf">微服务是软件</em> </strong> <a class="ae kg" href="https://en.wikipedia.org/wiki/Lego" rel="noopener ugc nofollow" target="_blank"> <strong class="jl hj"> <em class="kf">乐高</em> </strong> </a> <strong class="jl hj"> <em class="kf">我们需要它们来构建可靠的、可扩展的、支持云的应用——因为它们简单、有意义，并且可以整合在一起构建更大的东西。我们将单独剖析一个微服务参与者，以便了解它是如何工作的。</em>T13】</strong></p><h2 id="7fb5" class="kh ki hi bd kj kk kl km kn ko kp kq kr js ks kt ku jw kv kw kx ka ky kz la lb bi translated"><strong class="ak">什么是微服务，为什么要关注微服务？</strong></h2><p id="283e" class="pw-post-body-paragraph jj jk hi jl b jm lc ij jo jp ld im jr js le ju jv jw lf jy jz ka lg kc kd ke hb bi translated">微服务架构模式提供了一种有效的方法，将应用程序的功能分解为可管理的、可独立部署的组件，这些组件可以连接在一起形成一个集成的应用程序。微服务解决了当今一些更紧迫的软件开发、部署和操作需求。</p><p id="9112" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">一个<a class="ae kg" rel="noopener" href="/nerd-for-tech/designing-microservices-4130bc41c046#4ef7">微服务</a> <strong class="jl hj"> </strong>被创建为<strong class="jl hj"> </strong>一个无状态的、可重入的、可独立部署的软件组件。它通过执行逻辑、发送消息或发布事件来对收到的消息做出反应。如果它是一个<a class="ae kg" rel="noopener" href="/nerd-for-tech/designing-microservices-4130bc41c046#12ac"> <em class="kf">资源处理器角色</em> </a>，它也可以从永久存储器中读取和写入。如果想了解更多关于微服务的内容，请查看<a class="ae kg" rel="noopener" href="/nerd-for-tech/designing-microservices-4130bc41c046"> <strong class="jl hj"> <em class="kf">设计微服务</em> </strong> </a> <strong class="jl hj"> <em class="kf">。</em> </strong>在本文中，我们特别关注微服务剖析——一个典型的微服务<a class="ae kg" rel="noopener" href="/nerd-for-tech/designing-microservices-4130bc41c046#87c0"> <em class="kf">应用任务参与者</em> </a>内部发生了什么。</p><h2 id="29a9" class="kh ki hi bd kj kk kl km kn ko kp kq kr js ks kt ku jw kv kw kx ka ky kz la lb bi translated">应用程序任务参与者</h2><p id="440e" class="pw-post-body-paragraph jj jk hi jl b jm lc ij jo jp ld im jr js le ju jv jw lf jy jz ka lg kc kd ke hb bi translated">在旧的<a class="ae kg" rel="noopener" href="/nerd-for-tech/software-architecture-for-the-cloud-c9226150c1f3#c5f5"> <em class="kf">分层架构模式</em></a><strong class="jl hj"><em class="kf"/></strong>中，一个应用任务执行者会落在<em class="kf">业务层</em>中。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es lh"><img src="../Images/ddb86e11f9f023396f97712eec13a69f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ekZcEiOU_zlAOJi9KMBWMw.png"/></div></div><figcaption class="li lj et er es lk ll bd b be z dx translated"><strong class="bd kj">图1:分层架构模式</strong></figcaption></figure><p id="22fe" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">应用程序任务参与者从用户的角度实现离散的应用程序任务。他们往往是开发和修改最频繁的参与者，也是应用程序功能涉及最多的微服务。任务参与者只能通过<a class="ae kg" rel="noopener" href="/nerd-for-tech/designing-microservices-4130bc41c046#a5c9"> <em class="kf">上下文处理者参与者</em> </a> <strong class="jl hj"> <em class="kf"> </em> </strong>来访问、创建和修改持久数据，这些都在分层架构的<em class="kf">持久层</em>中。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es lm"><img src="../Images/670a84bb49ab3e35c901599220f6e4d1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Re739Zue-9erEzG2ZVNt5A.png"/></div></div><figcaption class="li lj et er es lk ll bd b be z dx translated"><strong class="bd kj">图2:微服务参与者类型之间的关系</strong></figcaption></figure><h2 id="c2af" class="kh ki hi bd kj kk kl km kn ko kp kq kr js ks kt ku jw kv kw kx ka ky kz la lb bi translated">消息和事件</h2><p id="e32f" class="pw-post-body-paragraph jj jk hi jl b jm lc ij jo jp ld im jr js le ju jv jw lf jy jz ka lg kc kd ke hb bi translated">微服务参与者的形状是由其主要目的决定的。微服务参与者的核心是一个<a class="ae kg" href="https://www.reactivemanifesto.org/" rel="noopener ugc nofollow" target="_blank"> <em class="kf">反应式</em> </a>异步消息处理器。它被设计和优化为使用单线程一次处理一条消息，尽可能地快速高效。很像<a class="ae kg" href="https://nodejs.org/en/about/" rel="noopener ugc nofollow" target="_blank"><strong class="jl hj"><em class="kf">node . js</em></strong></a><strong class="jl hj"><em class="kf"/></strong>它是一个高性能、异步的消息处理器。这个YouTube视频，<a class="ae kg" href="https://www.youtube.com/watch?v=eRxLfUIMJwk" rel="noopener ugc nofollow" target="_blank"> <strong class="jl hj"> <em class="kf">什么是反应式系统？</em> </strong> </a>，很好的解释了为什么反应系统这么快。</p><p id="1c5c" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">微服务优化处理的消息属于<a class="ae kg" href="https://docs.google.com/document/d/16bSPSb-_gzi3QZADhdU4NceHSoXjuldXfPldfCBLbCA/edit?usp=sharing" rel="noopener ugc nofollow" target="_blank"> <em class="kf">代表性状态转移</em> </a> (REST)架构风格。有三种基本的消息类别:任务(请求)、响应和错误。这些信息可以通过以下两种方式之一传递:</p><ol class=""><li id="9b88" class="ln lo hi jl b jm jn jp jq js lp jw lq ka lr ke ls lt lu lv bi translated">作为异步REST消息。</li><li id="ddeb" class="ln lo hi jl b jm lw jp lx js ly jw lz ka ma ke ls lt lu lv bi translated">作为<a class="ae kg" href="https://prateek-ashtikar512.medium.com/microservices-design-patterns-event-carried-state-transfer-c4b66a58df00" rel="noopener"> <em class="kf">事件承载的状态转移</em> </a> (ECST)事件。</li></ol><p id="5f24" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated"><em class="kf">消息总是异步发送或作为事件发布。没有同步消息传递。每条消息都被发送到微服务逻辑地址或发布到事件主题。本文的重点不是如何将消息传输到正确的目标，而是微服务在接受、发送或发布消息时对消息做什么。</em></p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es mb"><img src="../Images/5a5414963d18ce3cdda13012a37f1dc7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*anhKG6fwtjNDxTxPBzo7CQ.png"/></div></div><figcaption class="li lj et er es lk ll bd b be z dx translated"><strong class="bd kj">图3:演员解剖</strong></figcaption></figure><h2 id="0e1e" class="kh ki hi bd kj kk kl km kn ko kp kq kr js ks kt ku jw kv kw kx ka ky kz la lb bi translated">一个微服演员有哪些部分？</h2><ul class=""><li id="be73" class="ln lo hi jl b jm lc jp ld js mc jw md ka me ke mf lt lu lv bi translated">一个m <strong class="jl hj"> ailbox </strong>附在每一个微服务演员身上。它负责为参与者接收和发送消息。</li><li id="8b3c" class="ln lo hi jl b jm lw jp lx js ly jw lz ka ma ke mf lt lu lv bi translated"><strong class="jl hj">智能适配器</strong>是基于规则的消息解析器适配器，在将消息传递到输入通道(<em class="kf">前置条件</em>)之前以及从输出通道(<em class="kf">后置条件</em>)接收到消息时，由邮箱调用。</li><li id="fcbe" class="ln lo hi jl b jm lw jp lx js ly jw lz ka ma ke mf lt lu lv bi translated">i <strong class="jl hj"> nput通道</strong>是Java微服务 actor的<em class="kf">静态方法。每种输入消息类型都有一个输入通道。它负责对消息类型做出反应。</em></li><li id="aadb" class="ln lo hi jl b jm lw jp lx js ly jw lz ka ma ke mf lt lu lv bi translated">一个<strong class="jl hj">输出通道</strong>是一个Java微服务 actor的<em class="kf">静态方法。每种输出消息类型都有一个输出通道。它负责发送或发布消息类型。</em></li></ul><h2 id="556b" class="kh ki hi bd kj kk kl km kn ko kp kq kr js ks kt ku jw kv kw kx ka ky kz la lb bi translated">邮筒</h2><p id="6574" class="pw-post-body-paragraph jj jk hi jl b jm lc ij jo jp ld im jr js le ju jv jw lf jy jz ka lg kc kd ke hb bi translated">从20世纪70年代早期开始使用actor模型，邮箱就与actor配对，以便为actor接收和缓冲传入的消息。对于<em class="kf">微服务参与者模型</em>，我们将邮箱扩展为双向的，并处理传入和传出消息。我们这样做是为了促进Kubernetes集群内部和之间的<a class="ae kg" rel="noopener" href="/nerd-for-tech/designing-microservices-4130bc41c046#126e">自组织消息传递</a>。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es mg"><img src="../Images/5f9621c8193cdbae6c57f1f73ae905a6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bYPnvkpvkuyFzzIqzByHEQ.png"/></div></div><figcaption class="li lj et er es lk ll bd b be z dx translated"><strong class="bd kj">图4:行动中的演员邮箱</strong></figcaption></figure><p id="10c0" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">在启动时，每个pod的微服务参与者的邮箱向pod的<em class="kf">消息代理服务器</em>注册它，后者又向最近的<em class="kf">消息代理服务器</em>注册微服务参与者。这可能会将它连接到云集群中所有其他注册的微服务参与者。</p><p id="ceb8" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">pod中的微服务参与者通过他们的邮箱相互通信。它们通过pod的消息代理与pod外部的参与者进行通信。邮箱知道哪些微服务在pod内，哪些在外部。</p><p id="0175" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">在启动时，邮箱还设置任何为其微服务参与者的消息类型配置的智能适配器。它通过为单个消息类型选择的适配器传递传入和传出消息。</p><h2 id="d5a4" class="kh ki hi bd kj kk kl km kn ko kp kq kr js ks kt ku jw kv kw kx ka ky kz la lb bi translated">智能适配器</h2><p id="d987" class="pw-post-body-paragraph jj jk hi jl b jm lc ij jo jp ld im jr js le ju jv jw lf jy jz ka lg kc kd ke hb bi translated">智能适配器完成了大量重复的消息处理工作，例如:</p><ul class=""><li id="ab15" class="ln lo hi jl b jm jn jp jq js lp jw lq ka lr ke mf lt lu lv bi translated">验证消息的数据内容和格式。</li><li id="962d" class="ln lo hi jl b jm lw jp lx js ly jw lz ka ma ke mf lt lu lv bi translated">将一种格式的消息内容转换成另一种格式的消息。</li><li id="823d" class="ln lo hi jl b jm lw jp lx js ly jw lz ka ma ke mf lt lu lv bi translated">从大消息中提取数据，为更具体的目的创建更小的消息。</li></ul><p id="ecd8" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">在一个典型的应用程序中，这些功能经常会在整个应用程序中重复多次——每个实例都是由不同的程序员从不同的角度使用不精确或不完整的规范编写的。这充其量是浪费宝贵资源的重复努力。在最坏的情况下，这是一个容易出错且需要大量维护的工作。</p><p id="6143" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">与通常用于实现这些任务的过程代码不同，智能适配器使用声明性规范来完成这些任务。根据声明性规范，智能适配器执行实现它们所必需的过程步骤——在整个应用程序中，只要需要，就会使用同一个智能适配器。</p><p id="7a93" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">从上面的<a class="ae kg" href="https://medium.com/p/c52b3cb30d30/edit#6574" rel="noopener"> <em class="kf">图4:行动中的演员邮箱</em> </a> <strong class="jl hj">，</strong>中可以看出，微服务演员的邮箱使用智能适配器在将消息传递到输入通道之前强制执行<em class="kf">前置条件</em>，并使用智能适配器在从输出通道接受消息之前强制执行<em class="kf">后置条件</em>。对于更复杂的处理，智能适配器可以作为管道链接在一起。</p><p id="c46b" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">总而言之，智能适配器:</p><ul class=""><li id="99be" class="ln lo hi jl b jm jn jp jq js lp jw lq ka lr ke mf lt lu lv bi translated">实施邮件验证和格式规则。</li><li id="9428" class="ln lo hi jl b jm lw jp lx js ly jw lz ka ma ke mf lt lu lv bi translated">减少劳动力、重复劳动和组件维护。</li><li id="eb22" class="ln lo hi jl b jm lw jp lx js ly jw lz ka ma ke mf lt lu lv bi translated">执行微服务前提条件和后期条件的实时测试。</li><li id="da46" class="ln lo hi jl b jm lw jp lx js ly jw lz ka ma ke mf lt lu lv bi translated">保证相同的数据处理规则适用于整个系统。</li></ul><h2 id="5015" class="kh ki hi bd kj kk kl km kn ko kp kq kr js ks kt ku jw kv kw kx ka ky kz la lb bi translated">输入通道</h2><p id="8edf" class="pw-post-body-paragraph jj jk hi jl b jm lc ij jo jp ld im jr js le ju jv jw lf jy jz ka lg kc kd ke hb bi translated">微服务对于它接受的每种消息类型都有一个输入通道。输入通道被实现为一个静态Java方法，该方法接受一个参数——实现它的特定类型的消息。它是反应式的、完全可重入的、线程安全的。它只能通过向适当的上下文处理器微服务发送消息来读写持久数据。</p><p id="c20f" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">输入通道从其参与者的邮箱中调用，并在邮箱分配的线程中执行。邮箱使用智能适配器来保证在调用输入通道之前满足所有消息的前提条件。</p><p id="a329" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated"><em class="kf">复杂的任务可以通过一个或多个参与者中的多个输入通道来实现——每个参与者通过对消息做出反应来执行其任务部分。</em></p><p id="a7bb" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">输入通道是微服务在实现应用任务时的工蜂。当输入通道对消息做出反应时，它完成自己的工作，然后调用输出通道来:</p><ul class=""><li id="e992" class="ln lo hi jl b jm jn jp jq js lp jw lq ka lr ke mf lt lu lv bi translated">向另一个微服务发送请求消息。</li><li id="a279" class="ln lo hi jl b jm lw jp lx js ly jw lz ka ma ke mf lt lu lv bi translated">将事件发布到主题。</li><li id="1f9c" class="ln lo hi jl b jm lw jp lx js ly jw lz ka ma ke mf lt lu lv bi translated">向另一个微服务发送成功消息。</li><li id="de29" class="ln lo hi jl b jm lw jp lx js ly jw lz ka ma ke mf lt lu lv bi translated">将成功事件发布到主题。</li><li id="5216" class="ln lo hi jl b jm lw jp lx js ly jw lz ka ma ke mf lt lu lv bi translated">向另一个微服务发送错误消息。</li><li id="7703" class="ln lo hi jl b jm lw jp lx js ly jw lz ka ma ke mf lt lu lv bi translated">将错误事件发布到主题。</li></ul><h2 id="1791" class="kh ki hi bd kj kk kl km kn ko kp kq kr js ks kt ku jw kv kw kx ka ky kz la lb bi translated">输出通道</h2><p id="f13a" class="pw-post-body-paragraph jj jk hi jl b jm lc ij jo jp ld im jr js le ju jv jw lf jy jz ka lg kc kd ke hb bi translated">微服务对于它发送或发布的每种消息类型都有一个输出通道。输出通道被实现为一个静态Java方法，该方法接受一个参数，即实现它的特定类型的消息。它是反应式的、完全可重入的、线程安全的。默认情况下，输出通道会准备一条消息，并将其发送到邮箱进行输出。但是，它可以执行任何所需的逻辑，在将输入发送到邮箱之前对其进行转换，或者将其发送到另一个输出通道。</p><h2 id="20a2" class="kh ki hi bd kj kk kl km kn ko kp kq kr js ks kt ku jw kv kw kx ka ky kz la lb bi translated">把所有的放在一起</h2><p id="b31c" class="pw-post-body-paragraph jj jk hi jl b jm lc ij jo jp ld im jr js le ju jv jw lf jy jz ka lg kc kd ke hb bi translated">这种微服务方法的真正优势是我们在从actor模型微服务组合应用程序时所拥有的能力和灵活性。Kubernetes的最小部署、故障转移和扩展单元是pod。</p><p id="7206" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">通过这种特定微服务架构模式的动态服务发现和自组织，您可以将微服务放入不同的容器中，微服务将会找到彼此，建立连接，并开始对消息做出反应。因为它们是反应式的和无状态的，相同类型的单个微服务实例是完全可以互换的。</p><p id="7528" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated"><em class="kf">这也意味着该模型可以使用Kubernetes来扩展处理或通过启动新的pods来实施故障转移，然后动态配置和使用这些pods。</em></p><p id="8192" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">每个联合消息代理将了解哪个微服务实例对其消息的响应最快，并将选择它们。从单个代理的角度来看，这些代理将始终选择平均消息延迟最低的微服务实例，从而不断优化整体系统消息传递路径，以响应不断变化的可用性、负载和消息模式。</p><h2 id="c3a8" class="kh ki hi bd kj kk kl km kn ko kp kq kr js ks kt ku jw kv kw kx ka ky kz la lb bi translated">优化微服务部署</h2><p id="cd44" class="pw-post-body-paragraph jj jk hi jl b jm lc ij jo jp ld im jr js le ju jv jw lf jy jz ka lg kc kd ke hb bi translated">因为相同类型的微服务实例是可互换的，并且服务发现是动态的，所以我们在如何将相关的微服务打包到pods中时具有很大的灵活性。我们可以根据需要满足的运行时目标来制定决策——调整原始性能、网络性能、水平可伸缩性、可靠性和故障转移、数据库性能和镜像等的组合。</p><p id="bd2d" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">以下三幅图显示了不同的pod配置。由于动态发现和自组织，它们无需任何额外配置即可发挥各自的功能。在上面列出的运行时目标中，它们每一个都有偏差，但是它们都可以工作。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es mh"><img src="../Images/84f6b1654047d61beb36a4794c80eb1a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2BTl1GtzGEu3BYuKgJQTGw.png"/></div></div><figcaption class="li lj et er es lk ll bd b be z dx translated"><strong class="bd kj">图5:一个吊舱部署</strong></figcaption></figure><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es mi"><img src="../Images/f2621e378fa5fbf4aac456028aa5e5fc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*H3ND3DzSF393QaFjBtgf_Q.png"/></div></div><figcaption class="li lj et er es lk ll bd b be z dx translated"><strong class="bd kj">图6:两个吊舱展开</strong></figcaption></figure><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es mj"><img src="../Images/2e3fba59a75be7ece1ab7278e435f515.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*W6SKytiL70llWiPdetnNww.png"/></div></div><figcaption class="li lj et er es lk ll bd b be z dx translated"><strong class="bd kj">图7:三个吊舱部署</strong></figcaption></figure><p id="96d9" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">微服务架构模式的许多好处来自于它的组件可以被实现和部署的细粒度。实际上，部署和管理真正的微服务需要<a class="ae kg" rel="noopener" href="/nerd-for-tech/designing-microservices-4130bc41c046#ff29">容器化</a>和容器编排(<a class="ae kg" href="https://kubernetes.io/docs/tutorials/kubernetes-basics/" rel="noopener ugc nofollow" target="_blank"> Kubernetes </a>)的力量。</p><p id="9b4f" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated"><em class="kf"> Kubernetes可以部署在云和本地数据中心，也可以部署在Linux、Windows和Mac电脑上。</em></p><p id="d5cb" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">单个微服务参与者被封装在容器中。简单来说，<em class="kf">容器</em>是一个虚拟化的可执行映像。该映像可以被推送到一个集中的容器注册中心，Kubernetes使用该注册中心将容器实例部署到集群的pod。</p><p id="548a" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">一个<em class="kf"> pod </em>可以被看作是容器实例的一种包装器。每个pod都有自己的IP地址，通过该地址它可以与群集中的其他pod进行交互。通常，一个pod只包含一个容器。但是如果容器需要共享资源，一个pod可以包含多个容器。如果一个pod中有多个容器，这些容器通过<em class="kf"> localhost </em> IP地址相互通信。</p><p id="4a3f" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">在实现这种微服务架构模式时，一个pod至少包含一个应用程序容器和一个<a class="ae kg" rel="noopener" href="/nerd-for-tech/designing-microservices-4130bc41c046#126e"> <em class="kf"> message broker代理</em> </a> sidecar容器(以将其连接到其余的应用程序微服务)。通常，主微服务容器将与它直接发送消息的任何从属微服务容器一起打包在一个pod中。</p><p id="bac2" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated"><em class="kf">关于微服务的一个常见问题是多个容器的运行时开销以及它们之间连接的延迟。实际上，对于设计合理的微服务来说，这很少是个问题。</em></p><blockquote class="mk ml mm"><p id="88d6" class="jj jk kf jl b jm jn ij jo jp jq im jr mn jt ju jv mo jx jy jz mp kb kc kd ke hb bi translated"><strong class="jl hj"> <em class="hi">讨论:</em> </strong> <em class="hi">微服务被设计为水平扩展以满足性能目标。对于某些应用程序用例来说，这不是一个选项，在这些用例中，直接优化CPU、内存、I/O或网络资源的使用是满足性能要求的唯一方法。这些用例可能不适合微服务架构模式。</em></p></blockquote></div><div class="ab cl mq mr gp ms" role="separator"><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv"/></div><div class="hb hc hd he hf"><h2 id="647a" class="kh ki hi bd kj kk kl km kn ko kp kq kr js ks kt ku jw kv kw kx ka ky kz la lb bi translated">推荐阅读</h2><p id="c476" class="pw-post-body-paragraph jj jk hi jl b jm lc ij jo jp ld im jr js le ju jv jw lf jy jz ka lg kc kd ke hb bi translated">如果您觉得这篇文章有趣，我们想推荐以下内容:</p><ul class=""><li id="607a" class="ln lo hi jl b jm jn jp jq js lp jw lq ka lr ke mf lt lu lv bi translated"><a class="ae kg" rel="noopener" href="/nerd-for-tech/designing-microservices-4130bc41c046"> <strong class="jl hj"> <em class="kf">设计微服务</em> </strong> </a></li><li id="f059" class="ln lo hi jl b jm lw jp lx js ly jw lz ka ma ke mf lt lu lv bi translated"><a class="ae kg" rel="noopener" href="/nerd-for-tech/microservice-architecture-622e4148f1"> <strong class="jl hj"> <em class="kf">微服务架构</em> </strong> </a></li><li id="d3d8" class="ln lo hi jl b jm lw jp lx js ly jw lz ka ma ke mf lt lu lv bi translated"><a class="ae kg" rel="noopener" href="/nerd-for-tech/software-architecture-for-the-cloud-c9226150c1f3"> <strong class="jl hj"> <em class="kf">云软件架构</em> </strong> </a></li><li id="0655" class="ln lo hi jl b jm lw jp lx js ly jw lz ka ma ke mf lt lu lv bi translated"><a class="ae kg" rel="noopener" href="/nerd-for-tech/containerized-microservices-a5dce87fab82"> <strong class="jl hj"> <em class="kf">集装箱化微服务</em> </strong> </a></li></ul></div></div>    
</body>
</html>