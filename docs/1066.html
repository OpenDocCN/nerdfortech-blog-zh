<html>
<head>
<title>GraphQL with Apollo Android , why it’s worth taking a look.</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">采用Apollo Android的GraphQL，为什么值得一看。</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/graphql-with-apollo-android-why-its-worth-taking-a-look-f30ceb4a23ae?source=collection_archive---------2-----------------------#2021-03-03">https://medium.com/nerd-for-tech/graphql-with-apollo-android-why-its-worth-taking-a-look-f30ceb4a23ae?source=collection_archive---------2-----------------------#2021-03-03</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/8ae2579325a254977db60c6fbad0cc96.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*s49iJ_XztsYtvOUw"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">在<a class="ae iu" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上<a class="ae iu" href="https://unsplash.com/@fotografierende?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">摄影师ende </a>拍摄的照片</figcaption></figure><h1 id="3d94" class="iv iw hi bd ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js bi translated"><strong class="ak">简介</strong></h1><p id="c805" class="pw-post-body-paragraph jt ju hi jv b jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq hb bi translated">不久前，我从我的同事<a class="ae iu" href="https://twitter.com/ramy17ak" rel="noopener ugc nofollow" target="_blank">Ramy</a>那里听说了在<a class="ae iu" href="https://www.proxym-group.com/" rel="noopener ugc nofollow" target="_blank">proxy m</a>中工作的GraphQL，我很想了解这种消费API的新方式，因为到目前为止，在android俱乐部中，REST方法是主导者。</p><p id="dcfa" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">这看起来很有趣，我决定研究一下，然后我做了任何好奇的开发者都会做的事情，在互联网上询问这个问题。</p><p id="16c3" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">事实证明这并不新鲜，GraphQL是脸书从2012年开始开发的，并于2015年公开发布，所以让我们先问一些问题。</p><h1 id="03ac" class="iv iw hi bd ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js bi translated"><strong class="ak">什么是GraphQL </strong></h1><p id="ecd8" class="pw-post-body-paragraph jt ju hi jv b jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq hb bi translated"><strong class="jv hj"/></p><p id="4e28" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated"><strong class="jv hj"> <em class="kw">长答案</em> </strong> : GraphQL都是数据通信。您有一个客户端和一个服务器，它们都需要相互通信。客户机需要告诉服务器它需要什么数据，而服务器需要用实际数据来满足客户机的数据需求。GraphQL介入了这种交流。</p><p id="12fe" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">GraphQL服务器为客户机提供预定义的<em class="kw">模式</em>——可以从服务器请求的数据模型。换句话说，模式在定义如何访问数据时，充当了客户机和服务器之间的中间地带。</p><p id="f274" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated"><strong class="jv hj"> <em class="kw">模式</em> </strong>是描述您的数据的东西，它基本上是一个功能文档，列出了客户端可以向GraphQL层提出的所有问题。在如何使用模式方面有一些灵活性，因为我们在这里讨论的是节点图。T</p><p id="a535" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">该模式主要表示GraphQL层所能回答的限制。关于Schema和GraphQL的更多细节可以在这篇详细的文章中找到<a class="ae iu" href="https://jscomplete.com/learn/complete-intro-graphql/why-graphql" rel="noopener ugc nofollow" target="_blank"/></p><h1 id="9688" class="iv iw hi bd ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js bi translated"><strong class="ak"> GraphQL操作</strong></h1><p id="ef18" class="pw-post-body-paragraph jt ju hi jv b jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq hb bi translated">GraphQL有三个主要操作:</p><ol class=""><li id="e3d4" class="kx ky hi jv b jw kr ka ks ke kz ki la km lb kq lc ld le lf bi translated"><strong class="jv hj"> <em class="kw">查询</em> </strong>读取数据</li><li id="5a52" class="kx ky hi jv b jw lg ka lh ke li ki lj km lk kq lc ld le lf bi translated"><strong class="jv hj"> <em class="kw">突变</em> </strong>为写入数据</li><li id="9cfc" class="kx ky hi jv b jw lg ka lh ke li ki lj km lk kq lc ld le lf bi translated"><strong class="jv hj"> <em class="kw">订阅</em> </strong>用于自动接收一段时间内的实时数据。</li></ol><p id="6b3a" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">最常用的操作是查询和变异，你可以把<em class="kw">查询</em>想象成GET请求的等价物，而<em class="kw">变异就像POST、PUT和DELETE。</em></p><p id="4726" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated"><a class="ae iu" href="https://www.apollographql.com/docs/react/data/subscriptions/" rel="noopener ugc nofollow" target="_blank">订阅</a>使用WebSocket保持与您的GraphQL服务器的活动连接，这使您的服务器能够随着时间的推移推送订阅结果的更新</p></div><div class="ab cl ll lm gp ln" role="separator"><span class="lo bw bk lp lq lr"/><span class="lo bw bk lp lq lr"/><span class="lo bw bk lp lq"/></div><div class="hb hc hd he hf"><h1 id="74c5" class="iv iw hi bd ix iy ls ja jb jc lt je jf jg lu ji jj jk lv jm jn jo lw jq jr js bi translated"><strong class="ak">为什么选择GraphQL </strong></h1><p id="8554" class="pw-post-body-paragraph jt ju hi jv b jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq hb bi translated">GraphQL旨在使API快速、灵活且对开发人员友好。GraphQL允许开发人员在单个API调用中构造从多个数据源提取数据的请求。换句话说，在一个请求中获得许多资源，并要求得到你所需要的，确切地得到它。</p><h1 id="c699" class="iv iw hi bd ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js bi translated"><strong class="ak">graph QL与REST的主要区别</strong></h1><p id="d1d8" class="pw-post-body-paragraph jt ju hi jv b jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq hb bi translated">REST APIs的最大问题是多端点的性质。一个中等规模的应用程序可以轻松拥有100多个端点，这需要客户端进行多次往返以获取数据。</p><p id="c346" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">为了说明REST和GraphQL在从API获取数据时的主要区别，让我们考虑一个真实的场景，假设我们将在脸书获取用户资料页面，为了便于讨论，我们将保持简单</p><p id="66c6" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">使用REST API，您通常会通过访问多个端点来收集数据。在本例中，这些可能是获取初始用户数据的<code class="du lx ly lz ma b">/user/&lt;id&gt;</code>端点，其次，可能有一个返回朋友列表的<code class="du lx ly lz ma b">/user/&lt;id&gt;/friends</code>端点，第三个端点将是返回帖子列表的<code class="du lx ly lz ma b">/user/&lt;id&gt;/posts</code>。</p><p id="7c28" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">然而，一个GraphQL API只有一个端点，通常是<code class="du lx ly lz ma b">/graphql</code>。我们可以轻松地创建一个查询来替换上面所有的三个端点调用，并指定我们想要接收的确切属性。</p></div><div class="ab cl ll lm gp ln" role="separator"><span class="lo bw bk lp lq lr"/><span class="lo bw bk lp lq lr"/><span class="lo bw bk lp lq"/></div><div class="hb hc hd he hf"><h1 id="f026" class="iv iw hi bd ix iy ls ja jb jc lt je jf jg lu ji jj jk lv jm jn jo lw jq jr js bi translated"><strong class="ak">采用安卓系统的GraphQL】</strong></h1><p id="11f3" class="pw-post-body-paragraph jt ju hi jv b jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq hb bi translated">为了在android应用程序中使用GraphQL，我们将需要使用<a class="ae iu" href="https://www.apollographql.com/docs/android/" rel="noopener ugc nofollow" target="_blank">Apollo库</a>，这是一个强类型客户端，它从GraphQL查询中生成Java和Kotlin模型，所以让我们讨论一下在android项目中运行Apollo所需的步骤。</p><h2 id="edaf" class="mb iw hi bd ix mc md me jb mf mg mh jf ke mi mj jj ki mk ml jn km mm mn jr mo bi translated">阿波罗装置</h2><p id="eb8a" class="pw-post-body-paragraph jt ju hi jv b jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq hb bi translated">我们将从在项目级别添加这个插件开始</p><pre class="mp mq mr ms fd mt ma mu mv aw mw bi"><span id="c32c" class="mb iw hi ma b fi mx my l mz na">//project dependencies<br/>dependencies <strong class="ma hj">{</strong><br/>    classpath "com.apollographql.apollo:apollo-gradle-plugin:2.4.6" <br/><strong class="ma hj">}</strong></span></pre><p id="841f" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">然后在模块级别添加插件</p><pre class="mp mq mr ms fd mt ma mu mv aw mw bi"><span id="23e9" class="mb iw hi ma b fi mx my l mz na">plugins <strong class="ma hj">{</strong><br/>    id 'com.apollographql.apollo'<br/><strong class="ma hj">}</strong></span></pre><p id="6bcd" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">要让Apollo运行，我们还需要实现Apollo运行时库，如果我们想用Apollo操作支持协程，我们还需要添加Apollo协程库，Apollo还可以支持RxJava和缓存。</p><pre class="mp mq mr ms fd mt ma mu mv aw mw bi"><span id="e545" class="mb iw hi ma b fi mx my l mz na">dependencies <strong class="ma hj">{</strong><br/>    def apollo = "2.4.6"<br/>    implementation "com.apollographql.apollo:apollo-runtime:$apollo"<br/>    implementation "com.apollographql.apollo:apollo-coroutines-support:$apollo"<br/><br/><strong class="ma hj">}</strong></span></pre><h2 id="3eea" class="mb iw hi bd ix mc md me jb mf mg mh jf ke mi mj jj ki mk ml jn km mm mn jr mo bi translated">模型生成</h2><p id="a067" class="pw-post-body-paragraph jt ju hi jv b jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq hb bi translated">Apollo有一个很好的特性，你可以生成Kotlin模型，你可以通过在gradle文件的模块层添加下面的代码来实现。</p><pre class="mp mq mr ms fd mt ma mu mv aw mw bi"><span id="d90e" class="mb iw hi ma b fi mx my l mz na">apollo <strong class="ma hj">{<br/>    </strong>generateKotlinModels.set(true)<br/><strong class="ma hj">}</strong></span></pre><h2 id="ed08" class="mb iw hi bd ix mc md me jb mf mg mh jf ke mi mj jj ki mk ml jn km mm mn jr mo bi translated">添加模式</h2><p id="bbaf" class="pw-post-body-paragraph jt ju hi jv b jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq hb bi translated">为了生成java模型，需要一个GraphQL模式和一个查询。模式通常可以从你的<a class="ae iu" href="https://rickandmortyapi.com/graphql" rel="noopener ugc nofollow" target="_blank"> API playground </a>下载，在android应用程序中，模式应该添加在主文件夹下，如下例所示"<a class="ae iu" href="https://github.com/HamdiBoumaiza/ApolloRickAndMorty/blob/master/app/src/main/graphql/com/hb/rickandmortyapollo/schema.sdl" rel="noopener ugc nofollow" target="_blank">https://github . com/HamdiBoumaiza/apolloricandmorty/blob/master/app/src/main/graph QL/com/HB/rickandmortyapollo/Schema . SDL</a></p><h2 id="39d2" class="mb iw hi bd ix mc md me jb mf mg mh jf ke mi mj jj ki mk ml jn km mm mn jr mo bi translated">添加查询</h2><p id="dbff" class="pw-post-body-paragraph jt ju hi jv b jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq hb bi translated">下面是一个GraphQL的示例查询，我使用了<a class="ae iu" href="https://rickandmortyapi.com/graphql" rel="noopener ugc nofollow" target="_blank"> Rick和Morty API </a></p><pre class="mp mq mr ms fd mt ma mu mv aw mw bi"><span id="1d58" class="mb iw hi ma b fi mx my l mz na">query GetCharacters($page: Int) {<br/>    characters(page: $page) {<br/>        info {<br/>            pages, count, next<br/>        }<br/>        results {<br/>            id, name, image,<br/>            episode {<br/>                id, name<br/>            }<br/>        }<br/>    }<br/>}</span></pre><h2 id="5de4" class="mb iw hi bd ix mc md me jb mf mg mh jf ke mi mj jj ki mk ml jn km mm mn jr mo bi translated">构建阿波罗客户端</h2><p id="f4b2" class="pw-post-body-paragraph jt ju hi jv b jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq hb bi translated">创建一个基本的Apollo客户端是非常容易的，正如你在下面看到的，客户端可以用很多方式配置，例如你可以添加一个<em class="kw"> OkHttpClient </em>或者添加一个<em class="kw">拦截器</em>。</p><pre class="mp mq mr ms fd mt ma mu mv aw mw bi"><span id="6a3a" class="mb iw hi ma b fi mx my l mz na">private fun apolloClient()=<br/>    ApolloClient.builder().serverUrl(<em class="kw">BASE_URL</em>).build()</span></pre><h2 id="cef2" class="mb iw hi bd ix mc md me jb mf mg mh jf ke mi mj jj ki mk ml jn km mm mn jr mo bi translated">执行查询</h2><p id="1a2c" class="pw-post-body-paragraph jt ju hi jv b jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq hb bi translated">设置好客户端后，我们现在可以执行我们的查询，正如您在下面看到的，我们只需使用查询函数，并将查询生成的类作为参数传递给它</p><pre class="mp mq mr ms fd mt ma mu mv aw mw bi"><span id="b4ed" class="mb iw hi ma b fi mx my l mz na">apolloClient().query(GetCharactersQuery(Input.optional(page)))</span></pre><p id="5d71" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">从那以后，剩下的数据流就是你的责任了，我在<a class="ae iu" href="https://github.com/HamdiBoumaiza/ApolloRickAndMorty" rel="noopener ugc nofollow" target="_blank">中加入了一个小应用</a>，它展示了如何实现Apollo，并演示了如何添加模式和查询并执行它们，我还用MVVM的匕首柄实现了一个干净的架构，请随意查看。</p></div><div class="ab cl ll lm gp ln" role="separator"><span class="lo bw bk lp lq lr"/><span class="lo bw bk lp lq lr"/><span class="lo bw bk lp lq"/></div><div class="hb hc hd he hf"><h1 id="1063" class="iv iw hi bd ix iy ls ja jb jc lt je jf jg lu ji jj jk lv jm jn jo lw jq jr js bi translated"><strong class="ak">最终想法</strong></h1><p id="b840" class="pw-post-body-paragraph jt ju hi jv b jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq hb bi translated">读完这篇文章和其他关于GraphQL的文章后，你可能会想到一个问题，为什么REST仍然是主导者？</p><p id="5bbd" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">在这篇文章中，我主要讨论了为什么我们应该考虑GraphQL，以及如何在android应用程序中实现它，但我也应该明确告诉你，GraphQL有一些弱点，比如缓存和速率限制的复杂性</p><p id="62c3" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">即使我喜欢GraphQL，并且认为将来会有更多的人使用它，我也不认为REST会很快出现，特别是随着<a class="ae iu" href="https://developers.google.com/web/fundamentals/performance/http2" rel="noopener ugc nofollow" target="_blank"> HTTP/2 </a>的出现，但是对于移动和web应用程序来说，它可能是选择加入的更好的解决方案，绝对值得研究和考虑。</p><p id="3945" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">感谢阅读！</p><p id="f83b" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">特别感谢<a class="ae iu" href="https://twitter.com/RimGazzeh" rel="noopener ugc nofollow" target="_blank"> Rim Gazzeh </a>花时间审阅这篇文章并反馈意见，使之成为一个更好的版本。</p><p id="6406" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">如果你喜欢这篇文章，请随意分享，并在<a class="ae iu" href="https://www.linkedin.com/in/hamdi-boumaiza" rel="noopener ugc nofollow" target="_blank"> LinkedIn </a>或<a class="ae iu" href="https://twitter.com/HamdiBoumaiza1" rel="noopener ugc nofollow" target="_blank"> Twitter </a>上加我</p><div class="nb nc ez fb nd ne"><a href="https://github.com/HamdiBoumaiza/ApolloRickAndMorty" rel="noopener  ugc nofollow" target="_blank"><div class="nf ab dw"><div class="ng ab nh cl cj ni"><h2 class="bd hj fi z dy nj ea eb nk ed ef hh bi translated">HamdiBoumaiza/ApolloRickAndMorty</h2><div class="nl l"><h3 class="bd b fi z dy nj ea eb nk ed ef dx translated">你好，在这个项目中，我试图展示如何用干净的架构和MVVM构建一个Android应用程序…</h3></div><div class="nm l"><p class="bd b fp z dy nj ea eb nk ed ef dx translated">github.com</p></div></div><div class="nn l"><div class="no l np nq nr nn ns io ne"/></div></div></a></div></div></div>    
</body>
</html>