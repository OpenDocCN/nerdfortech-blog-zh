<html>
<head>
<title>Puppeteer best practices</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">木偶师最佳实践</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/puppeteer-best-practices-3a1a72c912b0?source=collection_archive---------0-----------------------#2022-10-29">https://medium.com/nerd-for-tech/puppeteer-best-practices-3a1a72c912b0?source=collection_archive---------0-----------------------#2022-10-29</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="506a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这些帮助我减少自动化剥落</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es jd"><img src="../Images/e394de7515600002ad29ab5e59592ab7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*QBwZrhyVn487wrGn"/></div></div><figcaption class="jp jq et er es jr js bd b be z dx translated">阿图尔·潘迪在<a class="ae jt" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><h1 id="1ec3" class="ju jv hi bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">介绍</h1><p id="2625" class="pw-post-body-paragraph if ig hi ih b ii ks ik il im kt io ip iq ku is it iu kv iw ix iy kw ja jb jc hb bi translated">Puppeteer 非常容易使用，因为它提供了许多 API 来与 dom 交互，并执行复杂的自动化和测试。但是对于初学者来说，有一些开发人员可能没有意识到的复杂性。</p><p id="f361" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">所以我在这里分享一些我从经验中学到的最佳实践(在我看来)。让我们开始吧！</p><h1 id="ba09" class="ju jv hi bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">使用文本/内容而不是 CSS 选择器进行搜索</h1><p id="5129" class="pw-post-body-paragraph if ig hi ih b ii ks ik il im kt io ip iq ku is it iu kv iw ix iy kw ja jb jc hb bi translated">第三方网站使用的 CSS 类或 id 经常变化。大多数知名网站使用随机加密/散列字符串，这可能会妨碍 CSS 选择器的使用。</p><p id="2ccd" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">当开发人员重构一个网站时，CSS 也会发生变化。所以，最好使用 HTML 元素的文本内容作为事实的来源。</p><p id="adaa" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">例如，您可能需要单击登录按钮。因此，不要使用 CSS 选择器来选择按钮，而是使用按钮文本“Login”。</p><p id="88d9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">以下是实现上述目标的一些方法:</p><pre class="je jf jg jh fd kx ky kz la aw lb bi"><span id="2206" class="lc jv hi ky b fi ld le l lf lg">// using XPath api, the easiest way</span><span id="d18c" class="lc jv hi ky b fi lh le l lf lg">const loginBtn = await page.$x('//button[contains(., "Login")]')</span><span id="a886" class="lc jv hi ky b fi lh le l lf lg">await loginBtn[0].click()</span><span id="e085" class="lc jv hi ky b fi lh le l lf lg"><br/>// using query selector api</span><span id="4e8c" class="lc jv hi ky b fi lh le l lf lg">const buttons = await page.$$('button')</span><span id="dfba" class="lc jv hi ky b fi lh le l lf lg">for(const button of buttons) {</span><span id="135e" class="lc jv hi ky b fi lh le l lf lg">  const btnText = await (await button.getProperty('textContent')).jsonValue()</span><span id="1a54" class="lc jv hi ky b fi lh le l lf lg">  if(btnText.includes("Login")) {</span><span id="aa9c" class="lc jv hi ky b fi lh le l lf lg">    await button.click()</span><span id="ba9d" class="lc jv hi ky b fi lh le l lf lg">  }</span><span id="ddf4" class="lc jv hi ky b fi lh le l lf lg">}</span><span id="8f0a" class="lc jv hi ky b fi lh le l lf lg"><br/>// using evaluate</span><span id="6dfd" class="lc jv hi ky b fi lh le l lf lg">await page.evaluate(() =&gt; {</span><span id="6f20" class="lc jv hi ky b fi lh le l lf lg">  const buttons = document.querySelectorAll('button')<br/>  <br/>  buttons.forEach(button =&gt; {</span><span id="f169" class="lc jv hi ky b fi lh le l lf lg">      if(button.innerText.includes("Login")) {</span><span id="87ec" class="lc jv hi ky b fi lh le l lf lg">        button.click()</span><span id="a38c" class="lc jv hi ky b fi lh le l lf lg">      }</span><span id="d434" class="lc jv hi ky b fi lh le l lf lg">  })</span><span id="6236" class="lc jv hi ky b fi lh le l lf lg">})</span></pre><p id="5cd1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">还有其他像<code class="du li lj lk ky b">$$eval</code>和<code class="du li lj lk ky b">$eval</code>这样的方法可以用来代替上面的方法，但是你领会了它的要旨吧？</p><h1 id="733b" class="ju jv hi bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">等待元素加载</h1><p id="fd42" class="pw-post-body-paragraph if ig hi ih b ii ks ik il im kt io ip iq ku is it iu kv iw ix iy kw ja jb jc hb bi translated">使用<code class="du li lj lk ky b">page.waitForTimeout</code>方法等待元素加载可能很诱人，但是下面有更好的方法。这不是一个理想的解决方案，因为您不知道加载元素需要多长时间。</p><p id="ff5f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在对一个元素执行任何操作之前，总是使用<code class="du li lj lk ky b">page.waitForSelector</code>，尤其是在一个新页面被加载之后。这一点很重要，因为您想要访问的元素可能需要一些时间来加载，或者在经过一些处理后使用 JavaScript 插入到 DOM 中。</p><p id="ea83" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">你不能猜测什么时候一个元素会在 dom 上可用，如果你试图执行一个操作，比如说<code class="du li lj lk ky b">click</code>，它可能会抛出一个错误，因为这个元素还没有被加载到 DOM 中。</p><p id="01a3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">因此，使用如下等待方法几乎总是必不可少的:</p><pre class="je jf jg jh fd kx ky kz la aw lb bi"><span id="1a55" class="lc jv hi ky b fi ld le l lf lg">// for CSS selectors</span><span id="f76b" class="lc jv hi ky b fi lh le l lf lg">await page.waitForSelector('button[id=loginBtn]')</span><span id="1798" class="lc jv hi ky b fi lh le l lf lg">await page.click('button[id=loginBtn]')</span><span id="42d5" class="lc jv hi ky b fi lh le l lf lg">// for XPath</span><span id="968c" class="lc jv hi ky b fi lh le l lf lg">await page.waitForXPath('//button[@id="loginBtn"]')</span><span id="e2f3" class="lc jv hi ky b fi lh le l lf lg">await page.click('button[id=loginBtn]')</span></pre><p id="6fc3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">有时，包含一个自定义超时选项和<code class="du li lj lk ky b">visible</code>属性也很方便。</p><p id="b5e4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><code class="du li lj lk ky b">timeout</code>意味着如果在<code class="du li lj lk ky b">n</code>分钟后没有找到元素，抛出一个错误。<code class="du li lj lk ky b">visible</code>意味着该元素在 DOM 中被发现并且可见。否则，它可能隐藏在另一个元素后面，或者可能具有使其不可见的 CSS 属性。</p><pre class="je jf jg jh fd kx ky kz la aw lb bi"><span id="7d00" class="lc jv hi ky b fi ld le l lf lg">// for CSS selectors</span><span id="70ce" class="lc jv hi ky b fi lh le l lf lg">// throw an error if the element is still not found after 60000 ms<br/>await page.waitForSelector('button[id=loginBtn]', { visible: true, timeout: 60000 }) // timeout is in milliseconds</span><span id="b045" class="lc jv hi ky b fi lh le l lf lg">await page.click('button[id=loginBtn]')</span><span id="5ba9" class="lc jv hi ky b fi lh le l lf lg">// for XPath</span><span id="077a" class="lc jv hi ky b fi lh le l lf lg">await page.waitForXPath('//button[@id="loginBtn"], { visible: true, timeout: 60000 }')</span><span id="a3cd" class="lc jv hi ky b fi lh le l lf lg">await page.click('button[id=loginBtn]')</span></pre><h1 id="4a44" class="ju jv hi bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">等待导航</h1><p id="e010" class="pw-post-body-paragraph if ig hi ih b ii ks ik il im kt io ip iq ku is it iu kv iw ix iy kw ja jb jc hb bi translated">当浏览器从一个页面导航到另一个页面或重新加载时，总是需要等待导航完成。否则，如果您试图在要导航的页面上执行操作，而它还没有完成加载，它将抛出一个错误。</p><p id="c892" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">可能触发导航的事件一般有<code class="du li lj lk ky b">page.goto</code>、<code class="du li lj lk ky b">page.click</code>、<code class="du li lj lk ky b">page.reload</code>、<code class="du li lj lk ky b">page.goBack</code>和<code class="du li lj lk ky b">page.goForward</code>。</p><p id="2be1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">等待导航(直到 dom 完全加载)</p><pre class="je jf jg jh fd kx ky kz la aw lb bi"><span id="ddb0" class="lc jv hi ky b fi ld le l lf lg">await page.click('button[id=submitForm]') // triggers navigation</span><span id="6b5b" class="lc jv hi ky b fi lh le l lf lg">await page.waitForNavigation() // wait till the next page has loaded</span><span id="9d8e" class="lc jv hi ky b fi lh le l lf lg">// your operations on the next page...</span></pre><p id="6b3c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果您只想等待 DOM 加载，以上内容可能就足够了。如果您还想在后台等待 fetch/XHR 调用完成，那么<code class="du li lj lk ky b">page.waitForNavigation</code>方法允许您传递该选项。</p><pre class="je jf jg jh fd kx ky kz la aw lb bi"><span id="fdaa" class="lc jv hi ky b fi ld le l lf lg">// wait till there have been atmost 0 requests in 500ms timeframe</span><span id="7c32" class="lc jv hi ky b fi lh le l lf lg">// for surity, use this instead of 'networkidle2'</span><span id="24a0" class="lc jv hi ky b fi lh le l lf lg">await page.waitForNavigation({ waitFor: 'networkidle0' })</span><span id="d08b" class="lc jv hi ky b fi lh le l lf lg">// wait till there have been atmost 2 requests in 500ms timeframe<br/>await page.waitForNavigation({ waitFor: 'networkidle2' })</span></pre><p id="c07e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果需要，您还可以延长默认的 30 秒超时时间以等待更长时间</p><pre class="je jf jg jh fd kx ky kz la aw lb bi"><span id="620d" class="lc jv hi ky b fi ld le l lf lg">await page.waitForNavigation({ waitFor: 'networkidle0', timeout: 60000 })</span></pre><p id="a6ff" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">另一个好的做法是在等待导航时使用<code class="du li lj lk ky b">Promise.all</code>。将第一个承诺作为<code class="du li lj lk ky b">page.waitForNavigation</code>传递，将第二个承诺作为可能触发导航的动作传递。</p><pre class="je jf jg jh fd kx ky kz la aw lb bi"><span id="1f73" class="lc jv hi ky b fi ld le l lf lg">await Promise.all([</span><span id="a6a7" class="lc jv hi ky b fi lh le l lf lg">  page.waitForNavigation(),</span><span id="ced8" class="lc jv hi ky b fi lh le l lf lg">  page.click("#loginBtn") // triggers navigation</span><span id="ddf3" class="lc jv hi ky b fi lh le l lf lg">])</span></pre><p id="725a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这是必要的，因为下面的代码可能不会像预期的那样工作，因为<code class="du li lj lk ky b">page.waitForNavigation</code>可能会继续等待并最终超时。</p><pre class="je jf jg jh fd kx ky kz la aw lb bi"><span id="4880" class="lc jv hi ky b fi ld le l lf lg">await page.click("#loginBtn") // triggers navigation</span><span id="2219" class="lc jv hi ky b fi lh le l lf lg">await page.waitForNavigation() // use the above appraoch instead!</span></pre><h1 id="4577" class="ju jv hi bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">等待网络呼叫</h1><p id="b082" class="pw-post-body-paragraph if ig hi ih b ii ks ik il im kt io ip iq ku is it iu kv iw ix iy kw ja jb jc hb bi translated">您可能会遇到等待 API 调用来填充页面内容的常见用例。在这些类型的用例中，<code class="du li lj lk ky b">page.waitForNetworkIdle</code>可能会派上用场。</p><pre class="je jf jg jh fd kx ky kz la aw lb bi"><span id="b02b" class="lc jv hi ky b fi ld le l lf lg">await page.click("#fetchUsers") // makes an API call (no navigation)</span><span id="62cd" class="lc jv hi ky b fi lh le l lf lg">await page.waitForNetworkIdle() // wait till the page has no more fetch/XHR calls pending</span></pre><p id="67e9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">有两个可选属性可以传递给这个方法，<code class="du li lj lk ky b">idleTime</code>和<code class="du li lj lk ky b">timeout</code>。</p><p id="a523" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><code class="du li lj lk ky b">idleTime</code>:指定没有 API 调用之前的最小毫秒数</p><p id="9711" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><code class="du li lj lk ky b">timeout</code>:指定等待到没有 API 调用的时间限制(毫秒)</p><p id="3231" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">同样，对于<code class="du li lj lk ky b">page.waitForNetworkIdle</code>，我们应该使用<code class="du li lj lk ky b">Promise.all</code>，原因如上所述。</p><pre class="je jf jg jh fd kx ky kz la aw lb bi"><span id="49ef" class="lc jv hi ky b fi ld le l lf lg">await Promise.all([</span><span id="d4f6" class="lc jv hi ky b fi lh le l lf lg">  page.waitForNetworkIdle(),</span><span id="046c" class="lc jv hi ky b fi lh le l lf lg">  page.click("#loginBtn")</span><span id="85fb" class="lc jv hi ky b fi lh le l lf lg">])</span></pre><h1 id="08d6" class="ju jv hi bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">尽可能使用评估方法</h1><p id="8e78" class="pw-post-body-paragraph if ig hi ih b ii ks ik il im kt io ip iq ku is it iu kv iw ix iy kw ja jb jc hb bi translated">我们在 Puppeteer 中编写的代码被转换成浏览器可以理解的普通 JavaScript，并在浏览器上下文中执行。如果您正在编写许多本来可以用<code class="du li lj lk ky b">evaluate</code>方法编写的木偶方法，这可能是低效的。</p><p id="cfd4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><code class="du li lj lk ky b">evaluate</code>方法提供了更好的性能，因为<br/> 1)代码是用普通的 JavaScript 编写的，从木偶师那里得到的处理更少，并且更容易为大多数开发人员编写<br/> 2)大多数单独的木偶师调用可以合并到一个<code class="du li lj lk ky b">evaluate</code>脚本中，这意味着浏览器和木偶师之间的调用更少</p><p id="1ac1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我这里说的是<code class="du li lj lk ky b">evaluate</code>，但是所有这些点也适用于其他的帮助器方法，比如<code class="du li lj lk ky b">evaluateHandle</code>、<code class="du li lj lk ky b">$eval</code>和<code class="du li lj lk ky b">$$eval</code>。</p><p id="a530" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">例如，假设您想阅读每<code class="du li lj lk ky b">table</code>行<code class="du li lj lk ky b">tr</code>的第一个<code class="du li lj lk ky b">td</code>中的文本</p><pre class="je jf jg jh fd kx ky kz la aw lb bi"><span id="63d3" class="lc jv hi ky b fi ld le l lf lg">// with usual Puppeteer methods</span><span id="4d9f" class="lc jv hi ky b fi lh le l lf lg">const tdList = []</span><span id="fc9d" class="lc jv hi ky b fi lh le l lf lg">const trs = await page.$('table &gt; tr')</span><span id="305a" class="lc jv hi ky b fi lh le l lf lg">for(const tr of trs) {</span><span id="5437" class="lc jv hi ky b fi lh le l lf lg">  const td = await tr.$('td')</span><span id="1b22" class="lc jv hi ky b fi lh le l lf lg">  const tdValue = await (await td.getProperty('textContent')).jsonValue()</span><span id="4f5c" class="lc jv hi ky b fi lh le l lf lg">  tdList.push(tdValue)</span><span id="7871" class="lc jv hi ky b fi lh le l lf lg">}</span></pre><p id="413f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">正如你在上面看到的，木偶师将在<code class="du li lj lk ky b">table</code>中为每个<code class="du li lj lk ky b">tr</code>调用浏览器，这意味着许多来回。相反，我们可以使用单个<code class="du li lj lk ky b">evaluate</code>脚本和相对较短的代码来实现这一点。</p><pre class="je jf jg jh fd kx ky kz la aw lb bi"><span id="6435" class="lc jv hi ky b fi ld le l lf lg">// with evaluate method</span><span id="c306" class="lc jv hi ky b fi lh le l lf lg">const tdList = await page.evaluate(() =&gt; {</span><span id="d841" class="lc jv hi ky b fi lh le l lf lg">  const tempList = []</span><span id="088d" class="lc jv hi ky b fi lh le l lf lg">  document.querySelectorAll('table &gt; tr').forEach(tr =&gt; {</span><span id="648c" class="lc jv hi ky b fi lh le l lf lg">    tempList.push(tr.querySelector('td').textContent)</span><span id="5c3c" class="lc jv hi ky b fi lh le l lf lg">  })</span><span id="3727" class="lc jv hi ky b fi lh le l lf lg">  return tempList</span><span id="f6d6" class="lc jv hi ky b fi lh le l lf lg">})</span></pre><p id="f3da" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这只需要对浏览器进行一次调用！</p><h1 id="3e4f" class="ju jv hi bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">何时不使用评估</h1><p id="11b9" class="pw-post-body-paragraph if ig hi ih b ii ks ik il im kt io ip iq ku is it iu kv iw ix iy kw ja jb jc hb bi translated"><code class="du li lj lk ky b">evaluate</code>一旦你掌握了窍门，它似乎是任何事情的最佳解决方案。但是，有些时候你应该避免使用<code class="du li lj lk ky b">evaulate</code>，而是最好使用木偶方法。</p><p id="f963" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这通常包括用户交互，如鼠标点击、键盘事件、打字、悬停、聚焦等。这些可以使用<code class="du li lj lk ky b">evaulate</code>实现，但可能不会引发副作用。</p><p id="8641" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">所以，作为一个经验法则，当你需要做浏览器交互的时候，总是使用像<code class="du li lj lk ky b">click</code>、<code class="du li lj lk ky b">type</code>、<code class="du li lj lk ky b">select</code>、<code class="du li lj lk ky b">hover</code>这样的方法。</p><h1 id="f3a0" class="ju jv hi bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">不要忘记关闭您的浏览器实例</h1><p id="bdef" class="pw-post-body-paragraph if ig hi ih b ii ks ik il im kt io ip iq ku is it iu kv iw ix iy kw ja jb jc hb bi translated">就这样，这就是建议。记得做<code class="du li lj lk ky b">await browser.close().</code></p></div><div class="ab cl ll lm gp ln" role="separator"><span class="lo bw bk lp lq lr"/><span class="lo bw bk lp lq lr"/><span class="lo bw bk lp lq"/></div><div class="hb hc hd he hf"><p id="932d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">那都是乡亲们！我希望这将有助于你做令人敬畏的事情与木偶戏。</p><p id="7081" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">下一场见！</p><h1 id="fa00" class="ju jv hi bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">有用的链接:</h1><p id="183a" class="pw-post-body-paragraph if ig hi ih b ii ks ik il im kt io ip iq ku is it iu kv iw ix iy kw ja jb jc hb bi translated"><a class="ae jt" href="https://pptr.dev/" rel="noopener ugc nofollow" target="_blank">https://pptr.dev/</a></p><p id="fd00" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">https://stack overflow . com/questions/55664420/page-evaluate-vs-puppet er-methods</p></div></div>    
</body>
</html>