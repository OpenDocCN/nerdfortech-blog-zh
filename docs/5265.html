<html>
<head>
<title>LeetCode — Next Permutation</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">LeetCode —下一个排列</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/leetcode-next-permutation-6b21b9519ebf?source=collection_archive---------3-----------------------#2021-09-12">https://medium.com/nerd-for-tech/leetcode-next-permutation-6b21b9519ebf?source=collection_archive---------3-----------------------#2021-09-12</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><h1 id="4550" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">问题陈述</h1><p id="0043" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">实现<strong class="jf hj"> next permutation </strong>，将数字重新排列成按字典顺序排列的下一个更大的数字。</p><p id="90e7" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">如果这样的安排是不可能的，它必须重新安排它作为最低可能的顺序(即，按升序排序)。</p><p id="c523" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">替换必须到位，并且只使用恒定的额外内存。</p><p id="48cf" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">问题陈述摘自:【https://leetcode.com/problems/next-permutation】T2</p><p id="dfdc" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated"><strong class="jf hj">例一:</strong></p><pre class="kh ki kj kk fd kl km kn ko aw kp bi"><span id="54a5" class="kq ig hi km b fi kr ks l kt ku">Input: nums = [1, 2, 3]<br/>Output: [1, 3, 2]</span></pre><p id="330d" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated"><strong class="jf hj">例 2: </strong></p><pre class="kh ki kj kk fd kl km kn ko aw kp bi"><span id="c5c5" class="kq ig hi km b fi kr ks l kt ku">Input: nums = [3, 2, 1]<br/>Output: [1, 2, 3]</span></pre><p id="5d1a" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated"><strong class="jf hj">例 3: </strong></p><pre class="kh ki kj kk fd kl km kn ko aw kp bi"><span id="295b" class="kq ig hi km b fi kr ks l kt ku">Input: nums = [1, 1, 5]<br/>Output: [1, 5, 1]</span></pre><p id="0598" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated"><strong class="jf hj">例 4: </strong></p><pre class="kh ki kj kk fd kl km kn ko aw kp bi"><span id="4d38" class="kq ig hi km b fi kr ks l kt ku">Input: nums = [1]<br/>Output: [1]</span></pre><p id="ef73" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated"><strong class="jf hj">约束:</strong></p><pre class="kh ki kj kk fd kl km kn ko aw kp bi"><span id="607e" class="kq ig hi km b fi kr ks l kt ku">- 1 &lt;= nums.length &lt;= 100<br/>- 0 &lt;= nums[i] &lt;= 100</span></pre><h1 id="cca4" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">说明</h1><h2 id="2b60" class="kq ig hi bd ih kv kw kx il ky kz la ip jo lb lc it js ld le ix jw lf lg jb lh bi translated">强力方法</h2><p id="d48c" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">强力方法是找到数组元素的所有可能排列，并找出下一个最大的排列。</p><p id="8942" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">这里的问题是，我们要生成数组元素的所有排列，这需要很多时间。</p><p id="83b6" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">这种方法的时间复杂度是 O(N！)而空间复杂度是<strong class="jf hj"> O(N) </strong>。</p><h2 id="bb43" class="kq ig hi bd ih kv kw kx il ky kz la ip jo lb lc it js ld le ix jw lf lg jb lh bi translated">单程方法</h2><p id="c26e" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">对于按如下降序排列的给定序列</p><p id="f5d4" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi">[8, 5, 3, 2, 1]</p><p id="b45f" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">不可能有下一个更大的排列了。这给了我们一个识别下一个更大排列的提示。</p><p id="ff00" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">我们需要从右边找到第一对两个连续的数字<strong class="jf hj"> nums[i] </strong>和<strong class="jf hj">nums[i1]</strong>，它们满足<strong class="jf hj">nums[I]&gt;nums[i1]</strong>。</p><p id="d074" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">一旦我们找到索引<strong class="jf hj">I-1</strong>，我们需要用位于其右边部分<strong class="jf hj"> nums[i]的数字中刚好大于自身的数字来替换数字<strong class="jf hj">nums[I-1]</strong>..nums[nums.size() — 1] </strong>，说<strong class="jf hj"> nums[j] </strong>。</p><p id="6cb9" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">我们交换数字<strong class="jf hj"> nums[i — 1] </strong>和<strong class="jf hj"> nums[j] </strong>。我们从索引<strong class="jf hj"> i </strong>和<strong class="jf hj"> nums.size() — 1 </strong>中反转所有的数字。</p><p id="7fc9" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated"><strong class="jf hj">算法</strong></p><pre class="kh ki kj kk fd kl km kn ko aw kp bi"><span id="d1d6" class="kq ig hi km b fi kr ks l kt ku">- return if nums.size() &lt;= 1<br/>- set n = nums.size(), i = n - 1<br/>- loop while i &gt; 0<br/>  - if nums[i] &gt; nums[i - 1]<br/>    - break<br/><br/>- if i &lt;= 0<br/>  - i = 0<br/><br/>- set x = ( i == 0 ) ? nums[i] : nums[i - 1]<br/>- smallest = i<br/><br/>- loop for j = i + 1; j &lt; n; j++<br/>  - nums[j] &gt; x &amp;&amp; nums[j] &lt; nums[smallest]<br/>    - smallest = j<br/><br/>- swap(&amp;nums[smallest], (i == 0 ? &amp;nums[i] : &amp;nums[i - 1]));<br/><br/>- sort(nums.begin() + i, nums.end());</span></pre><p id="ed2e" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated"><strong class="jf hj"> C++解决方案</strong></p><pre class="kh ki kj kk fd kl km kn ko aw kp bi"><span id="aff3" class="kq ig hi km b fi kr ks l kt ku">class Solution {<br/>public: void swap(int *a, int *b)<br/>    {<br/>        int temp = *a;<br/>        *a = *b;<br/>        *b = temp;<br/>    }<br/>public:<br/>    void nextPermutation(vector&lt;int&gt;&amp; nums) {<br/>        if(nums.size() &lt;= 1){<br/>            return;<br/>        }<br/><br/>        int n = nums.size();<br/>        int i = n - 1;<br/>        for(;i &gt; 0; i--){<br/>            if(nums[i] &gt; nums[i-1])<br/>                break;<br/>        }<br/><br/>        if(i &lt;= 0){<br/>            i = 0;<br/>        }<br/><br/>        int x = (i == 0 ? nums[i] : nums[i - 1]);<br/>        int smallest = i;<br/><br/>        for(int j = i + 1; j &lt; n; j++){<br/>            if(nums[j] &gt; x &amp;&amp; nums[j] &lt; nums[smallest])<br/>                smallest = j;<br/>        }<br/><br/>        swap(&amp;nums[smallest], (i == 0 ? &amp;nums[i] : &amp;nums[i - 1]));<br/><br/>        // we can also use reverse<br/>        sort(nums.begin() + i, nums.end());<br/>    }<br/>};</span></pre><p id="c888" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated"><strong class="jf hj">戈朗解决方案</strong></p><pre class="kh ki kj kk fd kl km kn ko aw kp bi"><span id="a0d4" class="kq ig hi km b fi kr ks l kt ku">func reverse(nums []int) {<br/>    for i := 0; i &lt; len(nums); i++ {<br/>        j := len(nums) - 1 - i<br/>        if i &gt;= j {<br/>            break<br/>        }<br/><br/>        nums[i], nums[j] = nums[j], nums[i]<br/>    }<br/>}<br/><br/>func nextPermutation(nums []int)  {<br/>    i := 0<br/>    for i = len(nums) - 2; i &gt;= 0; i-- {<br/>        if nums[i] &lt; nums[i + 1] {<br/>            break<br/>        }<br/>    }<br/><br/>    if i == -1 {<br/>        reverse(nums)<br/>        return<br/>    }<br/><br/>    var j int<br/>    for j = len(nums)-1; j &gt; i; j-- {<br/>        if nums[j] &gt; nums[i] {<br/>            break<br/>        }<br/>    }<br/><br/>    nums[i], nums[j] = nums[j], nums[i]<br/>    reverse(nums[i + 1:])<br/>}</span></pre><p id="b05e" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated"><strong class="jf hj"> Javascript 解决方案</strong></p><pre class="kh ki kj kk fd kl km kn ko aw kp bi"><span id="21e7" class="kq ig hi km b fi kr ks l kt ku">var nextPermutation = function(nums) {<br/>    if (nums === null || nums.length === 0) {<br/>        return nums;<br/>    }<br/><br/>    let index = -1;<br/>    for (let i = nums.length - 2; i &gt;= 0; i--) {<br/>        if (nums[i] &lt; nums[i + 1]) {<br/>            index = i;<br/>            break;<br/>        }<br/>    }<br/><br/>    if (index &gt;= 0) {<br/>        for (let i = nums.length - 1; i &gt; index; i--) {<br/>            if (nums[i] &gt; nums[index]) {<br/>                let temp = nums[i];<br/>                nums[i] = nums[index];<br/>                nums[index] = temp;<br/>                break;<br/>            }<br/>        }<br/>    }<br/><br/>    let start = index + 1;<br/>    let end = nums.length - 1;<br/>    while (start &lt; end) {<br/>        let temp = nums[start];<br/>        nums[start] = nums[end];<br/>        nums[end] = temp;<br/>        start++;<br/>        end--;<br/>    }<br/>};</span></pre><p id="9afb" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">让我们试运行一下我们的算法，看看解决方案是如何工作的。</p><pre class="kh ki kj kk fd kl km kn ko aw kp bi"><span id="efb4" class="kq ig hi km b fi kr ks l kt ku">Input: nums = [1, 2, 3, 6, 5, 4]<br/>Output: [1, 2, 4, 3, 5, 6]<br/><br/>Step 1: nums.size() &lt;= 1<br/>        6 &lt;= 1<br/>        false<br/><br/>Step 2: n = nums.size()<br/>        n = 6<br/><br/>        i = n - 1<br/>          = 6 - 1<br/>          = 5<br/><br/>Step 3: loop for i &gt; 0<br/>        5 &gt; 0<br/>        true<br/><br/>        if nums[i] &gt; nums[i - 1]<br/>           nums[5] &gt; nums[4]<br/>           4 &gt; 5<br/>           false<br/><br/>        i--<br/>        i = 4<br/><br/>Step 4: loop for i &gt; 0<br/>        4 &gt; 0<br/>        true<br/><br/>        if nums[i] &gt; nums[i - 1]<br/>           nums[4] &gt; nums[3]<br/>           5 &gt; 6<br/>           false<br/><br/>        i--<br/>        i = 3<br/><br/>Step 5: loop for i &gt; 0<br/>        3 &gt; 0<br/>        true<br/><br/>        if nums[i] &gt; nums[i - 1]<br/>           nums[3] &gt; nums[2]<br/>           6 &gt; 3<br/>           true<br/><br/>           break<br/><br/>Step 6: i &lt;= 0<br/>        3 &lt;= 0<br/>        false<br/><br/>Step 7: x = (i == 0 ? nums[i] : nums[i - 1])<br/>          = (3 == 0 ? nums[3] : nums[2])<br/>          = (false ? nums[3] : nums[2])<br/>          = nums[2]<br/>          = 3<br/><br/>        smallest = i<br/>                 = 3<br/><br/>Step 8: loop for(j = i + 1; j &lt; n; j++)<br/>        j = 3 + 1<br/>          = 4<br/><br/>        j &lt; n<br/>        4 &lt; 6<br/>        true<br/><br/>        nums[j] &gt; x &amp;&amp; nums[j] &lt; nums[smallest]<br/>        nums[4] &gt; 3 &amp;&amp; nums[4] &lt; nums[3]<br/>        5 &gt; 3 &amp;&amp; 5 &lt; 6<br/>        true<br/><br/>        smallest = j<br/>                 = 4<br/><br/>        j++<br/>        j = 5<br/><br/>Step 9: loop for(j = i + 1; j &lt; n; j++)<br/>        j &lt; n<br/>        5 &lt; 6<br/>        true<br/><br/>        nums[j] &gt; x &amp;&amp; nums[j] &lt; nums[smallest]<br/>        nums[5] &gt; 3 &amp;&amp; nums[5] &lt; nums[4]<br/>        4 &gt; 3 &amp;&amp; 4 &lt; 6<br/>        true<br/><br/>        smallest = j<br/>                 = 5<br/><br/>        j++<br/>        j = 6<br/><br/>Step 10: loop for(j = i + 1; j &lt; n; j++)<br/>         j &lt; 6<br/>         6 &lt; 6<br/>         false<br/><br/>Step 11: swap(&amp;nums[smallest], (i == 0 ? &amp;nums[i] : &amp;nums[i - 1]));<br/>         swap(&amp;nums[5], 3 == 0 ? &amp;nums[3] : &amp;nums[2])<br/>         swap(&amp;nums[5], &amp;nums[2])<br/>         swap(3, 4)<br/><br/>         [1, 2, 4, 6, 5, 3]<br/><br/>Step 12: reverse(nums[i], nums[n - 1])<br/>         reverse(nums[3], nums[5])<br/><br/>         [1, 2, 4, 3, 5, 6]</span></pre></div><div class="ab cl li lj gp lk" role="separator"><span class="ll bw bk lm ln lo"/><span class="ll bw bk lm ln lo"/><span class="ll bw bk lm ln"/></div><div class="hb hc hd he hf"><p id="8120" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated"><em class="lp">原发布于</em><a class="ae kg" href="https://alkeshghorpade.me/post/leetcode-next-permutation" rel="noopener ugc nofollow" target="_blank"><em class="lp">https://alkeshghorpade . me</em></a><em class="lp">。</em></p></div></div>    
</body>
</html>