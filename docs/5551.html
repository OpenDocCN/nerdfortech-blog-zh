<html>
<head>
<title>Find the duplicate number</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">找到重复的号码</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/find-the-duplicate-number-aaf426ded83d?source=collection_archive---------1-----------------------#2021-10-15">https://medium.com/nerd-for-tech/find-the-duplicate-number-aaf426ded83d?source=collection_archive---------1-----------------------#2021-10-15</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="973e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">(LeetCode:中)</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es jd"><img src="../Images/a75dd0194b5f10251ef74071c487b40c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/0*zPjK1tWdieyPcv7q.png"/></div></figure><p id="7419" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">给定一个包含<code class="du jl jm jn jo b">n + 1</code>个整数的整数数组<code class="du jl jm jn jo b">nums</code>，其中每个整数都在<code class="du jl jm jn jo b">[1, n]</code>范围内。</p><p id="ecfd" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><code class="du jl jm jn jo b">nums</code>中只有<strong class="ih hj">一个重复数</strong>，返回<em class="jp">这个重复数</em>。</p><p id="41f4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">你必须在不修改数组<code class="du jl jm jn jo b">nums</code>的情况下解决<strong class="ih hj">问题，并且只使用恒定的额外空间。</strong></p><p id="b397" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">例 1: </strong></p><pre class="je jf jg jh fd jq jo jr js aw jt bi"><span id="a1a1" class="ju jv hi jo b fi jw jx l jy jz"><strong class="jo hj">Input:</strong> nums = [1,3,4,2,2]<br/><strong class="jo hj">Output:</strong> 2</span></pre><p id="6c9e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">例 2: </strong></p><pre class="je jf jg jh fd jq jo jr js aw jt bi"><span id="acc3" class="ju jv hi jo b fi jw jx l jy jz"><strong class="jo hj">Input:</strong> nums = [3,1,3,4,2]<br/><strong class="jo hj">Output:</strong> 3</span></pre><p id="2430" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">例 3: </strong></p><pre class="je jf jg jh fd jq jo jr js aw jt bi"><span id="5fc1" class="ju jv hi jo b fi jw jx l jy jz"><strong class="jo hj">Input:</strong> nums = [1,1]<br/><strong class="jo hj">Output:</strong> 1</span></pre><p id="2860" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">例 4: </strong></p><pre class="je jf jg jh fd jq jo jr js aw jt bi"><span id="58b4" class="ju jv hi jo b fi jw jx l jy jz"><strong class="jo hj">Input:</strong> nums = [1,1,2]<br/><strong class="jo hj">Output:</strong> 1</span></pre><p id="b686" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">约束:</strong></p><ul class=""><li id="2ada" class="ka kb hi ih b ii ij im in iq kc iu kd iy ke jc kf kg kh ki bi translated"><code class="du jl jm jn jo b">1 &lt;= n &lt;= 10^5</code></li><li id="195d" class="ka kb hi ih b ii kj im kk iq kl iu km iy kn jc kf kg kh ki bi translated"><code class="du jl jm jn jo b">nums.length == n + 1</code></li><li id="13fe" class="ka kb hi ih b ii kj im kk iq kl iu km iy kn jc kf kg kh ki bi translated"><code class="du jl jm jn jo b">1 &lt;= nums[i] &lt;= n</code></li><li id="c354" class="ka kb hi ih b ii kj im kk iq kl iu km iy kn jc kf kg kh ki bi translated">除了<strong class="ih hj">恰好有一个整数</strong>出现<strong class="ih hj">两次或更多次</strong>外，<code class="du jl jm jn jo b">nums</code>中的所有整数都只出现<strong class="ih hj">一次</strong>。</li></ul><p id="3f7c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我将在这里讨论四种类型的方法，从蛮力到优化方法。让我们开始吧:</p><h1 id="9483" class="ko jv hi bd kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk bi translated">方法 1</h1><p id="ab22" class="pw-post-body-paragraph if ig hi ih b ii ll ik il im lm io ip iq ln is it iu lo iw ix iy lp ja jb jc hb bi translated">运行两个循环，一个在另一个里面，看看它是否满足条件 arr[i]==arr[j]，是否满足。</p><p id="48df" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> <em class="jp">时间复杂度-O(n*n)，空间复杂度-O(1) </em> </strong></p><pre class="je jf jg jh fd jq jo jr js aw jt bi"><span id="f5de" class="ju jv hi jo b fi jw jx l jy jz">PS : Try to code this by yourself, I have given the logic above.</span></pre><h1 id="978b" class="ko jv hi bd kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk bi translated"><strong class="ak">方法 2 </strong></h1><p id="3b66" class="pw-post-body-paragraph if ig hi ih b ii ll ik il im lm io ip iq ln is it iu lo iw ix iy lp ja jb jc hb bi translated">步骤 1:对数组进行排序，时间复杂度为 O(nlogn)</p><p id="6950" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">第二步:运行一个循环，查找相邻元素是否相同？</p><p id="35d5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">TC-O(n)，所以总<strong class="ih hj"> <em class="jp">时间复杂度-O(nlogn)+O(n) </em> </strong></p><p id="8a48" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> <em class="jp">空间复杂度-O(1) </em> </strong></p><pre class="je jf jg jh fd jq jo jr js aw jt bi"><span id="be37" class="ju jv hi jo b fi jw jx l jy jz">PS : Try to code this by yourself, I have given the logic above.</span></pre><h1 id="fa51" class="ko jv hi bd kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk bi translated">方法 3</h1><p id="8a69" class="pw-post-body-paragraph if ig hi ih b ii ll ik il im lm io ip iq ln is it iu lo iw ix iy lp ja jb jc hb bi translated">利用鸽子原理/二分搜索法的概念。</p><pre class="je jf jg jh fd jq jo jr js aw jt bi"><span id="0062" class="ju jv hi jo b fi jw jx l jy jz"><strong class="jo hj">class Solution {<br/>public:<br/>int findDuplicate(vector&amp; nums) {<br/>int n=nums.size();<br/></strong><strong class="jo hj">int left=1,right=n-1,c,mid;<br/>    <br/>    while(left&lt;right)<br/>    {<br/>        mid=(left+right)/2;<br/>        c=0;<br/>        <br/>        for(int i=0;i&lt;n;i++)<br/>            if(nums[i]&lt;=mid)c++;<br/>        <br/>        if(c&gt;mid)right=mid;<br/>        else left=mid+1;<br/>    }<br/>    return left;<br/>   }<br/></strong><strong class="jo hj">};</strong></span><span id="a709" class="ju jv hi jo b fi lq jx l jy jz"><strong class="jo hj">Time Complexity - O(nlogn)<br/>Space Complexity - O(1)</strong></span><span id="5710" class="ju jv hi jo b fi lq jx l jy jz">PS : I urge you to do a dry run for the above code for a clear understanding. If you face any issues feel free to comment below and ask. </span></pre><h1 id="e9da" class="ko jv hi bd kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk bi translated">方法 4</h1><p id="b36a" class="pw-post-body-paragraph if ig hi ih b ii ll ik il im lm io ip iq ln is it iu lo iw ix iy lp ja jb jc hb bi translated">使用散列的方法</p><p id="be47" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">步骤 1:使用另一个数组来存储元素的频率。频率大于 1 的元素，即重复/重复元素。</p><p id="879a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> <em class="jp">时间复杂度-O(n)，空间复杂度-O(n) </em> </strong></p><h1 id="4fea" class="ko jv hi bd kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk bi translated">方法 5</h1><p id="b597" class="pw-post-body-paragraph if ig hi ih b ii ll ik il im lm io ip iq ln is it iu lo iw ix iy lp ja jb jc hb bi translated">(链表循环法)</p><pre class="je jf jg jh fd jq jo jr js aw jt bi"><span id="623e" class="ju jv hi jo b fi jw jx l jy jz"><strong class="jo hj">class Solution {<br/>public:<br/>    int findDuplicate(vector&lt;int&gt;&amp; nums) {<br/>        int slow = nums[0];<br/>        int fast = nums[0];<br/>        <br/>        do{<br/>            slow = nums[slow];<br/>            fast = nums[nums[fast]];<br/>        }while(slow!=fast);<br/>        <br/>        fast = nums[0];<br/>        <br/>        while(slow!=fast)<br/>        {<br/>            slow = nums[slow];<br/>            fast = nums[fast];<br/>        }<br/>        return slow;<br/>    }<br/>};</strong></span><span id="64e6" class="ju jv hi jo b fi lq jx l jy jz">Let us do a dry run to understand better the approach behind the code :<br/>nums = [1,3,4,2,2]</span><span id="4621" class="ju jv hi jo b fi lq jx l jy jz">slow = nums[0] = 1<br/>fast = nums[0] = 1</span><span id="69d3" class="ju jv hi jo b fi lq jx l jy jz">slow = nums[1] = 3<br/>fast = nums[nums[1]] = nums[3] = 2<br/>since these two are not equal we update the values ,<br/>slow = nums[3] = 2<br/>fast = nums[nums[2]] = nums[4] = 2<br/>Now since these are equal , we exit the loop.</span><span id="d0c5" class="ju jv hi jo b fi lq jx l jy jz">Now fast = nums[0] = 1<br/>slow!=fast , <br/>slow = nums[2] = 4<br/>fast = nums[1] = 3</span><span id="d38a" class="ju jv hi jo b fi lq jx l jy jz">slow!=fast so ,<br/>slow = nums[4] = 2<br/>fast = nums[3] = 2</span><span id="e07e" class="ju jv hi jo b fi lq jx l jy jz">Now slow and fast are equal so , the repeating element is 2.</span><span id="0e0a" class="ju jv hi jo b fi lq jx l jy jz">Intution : The basic thinking is that we keep two counter variables, slow is incremented by +1 and fast by +2 and at one point they will be pointing to the repeating elements, which is returned by the slow pointer. </span></pre><p id="cf69" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">希望这篇文章有所帮助！敬请关注更多内容！！！继续编码💻🙌</p><p id="86d4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">既然你喜欢看我的博客，为什么不请我喝杯咖啡，支持我的工作呢！！<a class="ae lr" href="https://www.buymeacoffee.com/sukanyabharati" rel="noopener ugc nofollow" target="_blank">https://www.buymeacoffee.com/sukanyabharati</a>☕</p></div></div>    
</body>
</html>