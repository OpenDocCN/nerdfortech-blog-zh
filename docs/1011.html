<html>
<head>
<title>A journey from callback hell to Kotlin coroutines, Episode 1</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">从回调地狱到科特林协程的旅程，第 1 集</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/a-journey-from-callback-hell-to-kotlin-coroutines-episode-1-98b52821b323?source=collection_archive---------8-----------------------#2021-03-01">https://medium.com/nerd-for-tech/a-journey-from-callback-hell-to-kotlin-coroutines-episode-1-98b52821b323?source=collection_archive---------8-----------------------#2021-03-01</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/d11c6e5e3841cda52fd49307380f053d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*W1sLzT3MYp-q5kPG"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">马克·赖歇尔在<a class="ae iu" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><p id="b1fc" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">Ahmed 是一名开发人员，他喜欢在业余时间阅读电子书。有一天，他打开一个 pdf 下载 app，开始搜索一些书，然后开始下载，突然 app 开始滞后，然后 UI 变得不负责任，然后嘭，app 崩溃了。<br/>用户可能会对这种体验感到厌烦，可能会从他们的设备上删除这款应用。</p><p id="b537" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">出现上述情况的原因有很多，我们这里考虑的是<strong class="ix hj">线程。</strong></p><p id="17ad" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">作为一名最新的 android 开发者，Ahmed 不希望这种情况发生在他的应用程序用户身上。所以，他做了一些研究，发现 app 需要从<strong class="ix hj">主线程</strong>中转移任何长时间运行的代码</p><p id="e181" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如<a class="ae iu" href="https://developer.android.com/topic/performance/threads#internals" rel="noopener ugc nofollow" target="_blank"> Android 开发者官方网站</a>所述:</p><blockquote class="jt ju jv"><p id="6a55" class="iv iw jw ix b iy iz ja jb jc jd je jf jx jh ji jj jy jl jm jn jz jp jq jr js hb bi translated">如果主线程不能在 16ms 内完成工作块的执行，用户可能会观察到停滞、滞后或缺乏对输入的 UI 响应。如果主线程阻塞大约五秒钟，系统显示<a class="ae iu" href="https://developer.android.com/training/articles/perf-anr" rel="noopener ugc nofollow" target="_blank"> <em class="hi">应用不响应</em> </a> (ANR)对话框，允许用户直接关闭应用。</p></blockquote><p id="4066" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">好了，现在，Ahmed 知道了原因，并继续使用他的研究技能，知道他可以使用什么选项来编写<a class="ae iu" href="https://en.wikipedia.org/wiki/Asynchrony_(computer_programming)" rel="noopener ugc nofollow" target="_blank">异步代码</a>，并找到了一些解决方案，如:</p><ol class=""><li id="e563" class="ka kb hi ix b iy iz jc jd jg kc jk kd jo ke js kf kg kh ki bi translated">穿线</li><li id="0ec4" class="ka kb hi ix b iy kj jc kk jg kl jk km jo kn js kf kg kh ki bi translated">复试</li><li id="60b5" class="ka kb hi ix b iy kj jc kk jg kl jk km jo kn js kf kg kh ki bi translated">未来，承诺</li><li id="d04b" class="ka kb hi ix b iy kj jc kk jg kl jk km jo kn js kf kg kh ki bi translated">反应式延伸(Rx)</li><li id="5a80" class="ka kb hi ix b iy kj jc kk jg kl jk km jo kn js kf kg kh ki bi translated">协同程序</li></ol><h1 id="9c24" class="ko kp hi bd kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll bi translated"><strong class="ak">穿线</strong></h1><blockquote class="jt ju jv"><p id="a788" class="iv iw jw ix b iy iz ja jb jc jd je jf jx jh ji jj jy jl jm jn jz jp jq jr js hb bi translated"><a class="ae iu" href="https://simple.wikipedia.org/wiki/Computer_science" rel="noopener ugc nofollow" target="_blank">计算机科学</a>中的<strong class="ix hj">线程</strong>是执行的<em class="hi">线程的简称。线程是一个<a class="ae iu" href="https://simple.wikipedia.org/wiki/Computer_program" rel="noopener ugc nofollow" target="_blank">程序</a>将自己分成(称为<em class="hi">“split”</em>)两个或更多同时(或伪同时)运行<a class="ae iu" href="https://simple.wikipedia.org/wiki/Task_(computers)" rel="noopener ugc nofollow" target="_blank">任务</a>的一种方式。</em></p></blockquote><p id="7a77" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">Threads 是一个很好的解决方案，但是有一些问题，</p><p id="3750" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">有些语言，比如 javascript，没有线程。此外，它们对于系统来说可能是昂贵的，它需要在上下文(I/O、主线程等)之间切换。).它们不容易调试。</p><h1 id="fbad" class="ko kp hi bd kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll bi translated">复试</h1><blockquote class="jt ju jv"><p id="5dd1" class="iv iw jw ix b iy iz ja jb jc jd je jf jx jh ji jj jy jl jm jn jz jp jq jr js hb bi translated">在<a class="ae iu" href="https://en.wikipedia.org/wiki/Computer_programming" rel="noopener ugc nofollow" target="_blank">计算机编程</a>中，一个<strong class="ix hj">回调</strong>，也称为<strong class="ix hj">调用——在</strong><a class="ae iu" href="https://en.wikipedia.org/wiki/Callback_(computer_programming)#cite_note-1" rel="noopener ugc nofollow" target="_blank">【1】</a><strong class="ix hj">函数</strong>，是任何一个<a class="ae iu" href="https://en.wikipedia.org/wiki/Executable_code" rel="noopener ugc nofollow" target="_blank">可执行代码</a>，作为<a class="ae iu" href="https://en.wikipedia.org/wiki/Argument_(computer_science)" rel="noopener ugc nofollow" target="_blank">参数</a>传递给其他代码；其他代码预计会在给定时间<em class="hi">回调</em>(执行)参数。这种执行可以像在<strong class="ix hj">同步回调</strong>中一样立即进行，也可以像在<strong class="ix hj">异步回调</strong>中一样在稍后的时间点进行。</p></blockquote><figure class="ln lo lp lq fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lm"><img src="../Images/85aa62789151924a0a7551821e0f8828.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ArSI_MhpRXWb5ynGCoj1RA.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">回调示例</figcaption></figure><p id="e8b8" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">他发现它也很有用，直到他遇到了这样一个代码:</p><figure class="ln lo lp lq fd ij er es paragraph-image"><div class="er es lr"><img src="../Images/956d191024f7155079d6ede22044c9eb.png" data-original-src="https://miro.medium.com/v2/resize:fit:792/0*MDSFS8Zy2WRlSlJ2.gif"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">回调地狱 GIF，图片来自<a class="ae iu" href="https://github.com/eladkarako/AsynCallJS" rel="noopener ugc nofollow" target="_blank">https://github.com/eladkarako/AsynCallJS</a></figcaption></figure><p id="2347" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">上面的 GIF 展示了所谓的<strong class="ix hj">回调地狱</strong>，当有太多嵌套回调时，代码变得难以阅读，也难以处理异常和调试。</p><h1 id="c83c" class="ko kp hi bd kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll bi translated">未来，承诺</h1><p id="d984" class="pw-post-body-paragraph iv iw hi ix b iy ls ja jb jc lt je jf jg lu ji jj jk lv jm jn jo lw jq jr js hb bi translated">我保证我会在未来的某个时候回来</p><figure class="ln lo lp lq fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lx"><img src="../Images/db5c434bd028db94ca27700a599d62aa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*t7uzG1o40gc5K9qg-pIA8g.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">承诺范例</figcaption></figure><p id="333d" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">除了调试和错误处理挑战，Promises 在获取数据返回后还需要进一步的工作，因为它返回了数据的承诺，所以我们需要更多的代码行来从那个承诺中获取我们的模型:(。</p><h1 id="f39e" class="ko kp hi bd kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll bi translated"><strong class="ak">无功扩展(Rx) </strong></h1><p id="038f" class="pw-post-body-paragraph iv iw hi ix b iy ls ja jb jc lt je jf jg lu ji jj jk lv jm jn jo lw jq jr js hb bi translated">一切都是一股水流，是可以观察到的</p><p id="68a1" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">Rx 很棒，但它引入了 Ahmed 需要学习的新概念，相反，他决定找到一个可以用他使用的相同框架和语言实现的解决方案(我们例子中的 Kotlin)，所以。他向前走去寻找更好的东西。</p><h1 id="ba0a" class="ko kp hi bd kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll bi translated"><strong class="ak">协程</strong></h1><p id="03b0" class="pw-post-body-paragraph iv iw hi ix b iy ls ja jb jc lt je jf jg lu ji jj jk lv jm jn jo lw jq jr js hb bi translated">Kotlin 处理异步代码的方法。</p><figure class="ln lo lp lq fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ly"><img src="../Images/7919bdd6ab8e97ceb4597ad774b483be.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*x9OKlItKB0dfBN7BnaZlqQ.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">协同程序使代码更具可读性和有序性，就像普通编码一样。</figcaption></figure><figure class="ln lo lp lq fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lz"><img src="../Images/a0a3dda828a3e89d5242396af709bc97.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fg9-h6CWPz8p_pmHGktpyg.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">您可以在同一个线程中使用多个协程。</figcaption></figure><p id="8363" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">从上面的代码和图表中，Ahmed 发现，他只需要在函数前添加<strong class="ix hj"> suspend </strong>关键字，它就变得线程安全了，然后他就可以像调用导致:D 问题的函数一样使用它，而不需要改变返回类型，或者引入新概念，或者依赖于特定的平台。</p><p id="e4e0" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">与线程不同，协程是轻量级的，不昂贵，使得在同一个线程中使用多个协程成为可能。也很容易在线程之间切换。它也可以被停止、重新启动或取消。</p></div><div class="ab cl ma mb gp mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="hb hc hd he hf"><p id="d0f1" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">Ahmed 对协程很满意，但他想用一些例子来测试它，以确保它们值得切换，于是他打开了 IDE，但在大量工作之后，他觉得🥱很困，所以他决定休息一会儿，打个盹，然后在恢复精神后继续练习。</p><p id="859a" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">艾哈迈德醒来后，下集再见👋。</p></div><div class="ab cl ma mb gp mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="hb hc hd he hf"><p id="5a81" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">你可以在这里找到第二集<a class="ae iu" href="https://ahmednmahran.medium.com/a-journey-from-callback-hell-to-kotlin-coroutines-episode-2-c048f9898f" rel="noopener"/></p><h1 id="6fb3" class="ko kp hi bd kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll bi translated">参考</h1><p id="dee4" class="pw-post-body-paragraph iv iw hi ix b iy ls ja jb jc lt je jf jg lu ji jj jk lv jm jn jo lw jq jr js hb bi translated"><a class="ae iu" href="https://kotlinlang.org/docs/coroutines-overview.html" rel="noopener ugc nofollow" target="_blank">科特林官方网站</a></p><p id="0f56" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><a class="ae iu" href="https://developer.android.com/topic/performance/threads#internals" rel="noopener ugc nofollow" target="_blank">安卓开发者官方网站</a></p><p id="0e28" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><a class="ae iu" href="https://simple.wikipedia.org/wiki/Thread_(computer_science)" rel="noopener ugc nofollow" target="_blank">线程，维基百科</a></p></div></div>    
</body>
</html>