<html>
<head>
<title>How to wrap an Angular directive library?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何包装一个角度方向库？</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/how-to-wrap-an-angular-directive-library-d7e25de172?source=collection_archive---------8-----------------------#2021-03-30">https://medium.com/nerd-for-tech/how-to-wrap-an-angular-directive-library-d7e25de172?source=collection_archive---------8-----------------------#2021-03-30</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/32be27317b7830b4b40369c5b256c732.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yO0rBOw3V2qxA1wcaTQEig.png"/></div></div></figure><p id="9236" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">您被要求在工作中实现 Angular 应用程序的一个新功能。当你坐在办公桌前，伸手去拿键盘时，一个想法突然出现在你的脑海里:“我不能成为第一个不得不实现这种东西的人。我打赌有一个图书馆能满足我的需要”。</p><p id="8469" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">对你有好处。在今天的开源世界中，这是一个很好的条件反射。既然可以借用别人的轮子，为什么还要重新发明轮子呢？你很可能是对的；有人不得不解决你正在试图解决的同样的问题，并好心地与世界分享。</p><p id="d615" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">所以在 npmjs.com 上快速搜索一下，你就会找到你想要的东西。完美的 Angular 库，通过几个导出的指令，就可以完成你想要的功能。</p><p id="2388" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在，您意识到在整个应用程序中使用这些指令可能不是最好的主意，并且希望包装这个库，以便您的应用程序不会与它紧密耦合。但是怎么做呢？</p><p id="34a4" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">当我们谈论包装第三方库时，我们通常谈论使用组合来为我们的应用程序提供新的接口，该接口将工作委托给第三方库。这样，第三方库就完成了所有繁重的工作，但我们的应用程序甚至不知道它的存在，它只知道我们为它制作的漂亮包装。</p><p id="8f0d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如果你熟悉设计模式，你可能最终会使用看起来很像<a class="ae jo" href="https://refactoring.guru/design-patterns/adapter" rel="noopener ugc nofollow" target="_blank">适配器</a>、<a class="ae jo" href="https://refactoring.guru/design-patterns/proxy" rel="noopener ugc nofollow" target="_blank">代理</a>或<a class="ae jo" href="https://refactoring.guru/design-patterns/facade" rel="noopener ugc nofollow" target="_blank">外观</a>模式的东西。</p><p id="72cf" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在我们的演示中，我们将包装<a class="ae jo" href="https://github.com/mattlewis92/angular-resizable-element" rel="noopener ugc nofollow" target="_blank">angular-resizable-element</a>库。您可以尝试一下，并在下面的<a class="ae jo" href="https://stackblitz.com/edit/wrapping-angular-directive?file=src/app/app.component.html" rel="noopener ugc nofollow" target="_blank"> Stackblitz </a>中查看与本文相关的代码。</p><figure class="jp jq jr js fd ij"><div class="bz dy l di"><div class="jt ju l"/></div></figure><h1 id="e137" class="jv jw hi bd jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks bi translated">选择您的 API</h1><p id="7caa" class="pw-post-body-paragraph iq ir hi is b it kt iv iw ix ku iz ja jb kv jd je jf kw jh ji jj kx jl jm jn hb bi translated">是一个很酷的小库，可以通过拖动元素的边缘来调整元素的大小。让我们快速看一下它是如何工作的。根据它的<a class="ae jo" href="https://mattlewis92.github.io/angular-resizable-element/docs/modules/ResizableModule.html" rel="noopener ugc nofollow" target="_blank">文档</a>，它通过它的导出模块提供两个指令:<code class="du ky kz la lb b"><a class="ae jo" href="https://mattlewis92.github.io/angular-resizable-element/docs/directives/ResizableDirective.html" rel="noopener ugc nofollow" target="_blank">ResizableDirective</a></code>和<code class="du ky kz la lb b"><a class="ae jo" href="https://mattlewis92.github.io/angular-resizable-element/docs/directives/ResizeHandleDirective.html" rel="noopener ugc nofollow" target="_blank">ResizeHandleDirective</a></code>。</p><p id="79b1" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">经过审查，我们得出结论，我们真的不需要使用<code class="du ky kz la lb b">ResizeHandleDirective</code>。它的目的是对可调整大小的元素两侧的每个句柄进行更精细的控制，我们并不关心这个。所以我们只剩下<code class="du ky kz la lb b">ResizableDirective</code>。查看文档，我们看到它接收 9 个输入，发出 3 个输出。</p><p id="f2d1" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">正如库经常出现的情况一样，它们提供的 API 往往比您实际需要的要广泛得多。不要觉得你必须用你的包装器来镜像第三方库。事实上，你的包装器的 API 应该只提供你的应用程序需要的东西。不多不少。</p><p id="2ebd" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在我们的例子中，在仔细检查了我们的需求之后，我们确定我们不需要提供<code class="du ky kz la lb b">allowNegativeResizes</code>、<code class="du ky kz la lb b">mouseMoveThrottleMS</code>、<code class="du ky kz la lb b">resizeCursors</code>、<code class="du ky kz la lb b">resizeCursorPrecision</code>和<code class="du ky kz la lb b">resizeSnapGrid</code>输入的等价物。除此之外，我们的包装器提供一个类似于第三方库的接口是有意义的，因为它将很好地满足我们的需求。</p><h1 id="cadf" class="jv jw hi bd jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks bi translated">把它包起来</h1><p id="c746" class="pw-post-body-paragraph iq ir hi is b it kt iv iw ix ku iz ja jb kv jd je jf kw jh ji jj kx jl jm jn hb bi translated">目前，我们的演示组件直接使用第三方库，代码如下所示:</p><pre class="jp jq jr js fd lc lb ld le aw lf bi"><span id="62c0" class="lg jw hi lb b fi lh li l lj lk">&lt;div class="text-center"&gt;<br/>  &lt;h1&gt;Drag and pull the edges of the rectangle&lt;/h1&gt;<br/>  &lt;div<br/>    class="rectangle"<br/>    [ngStyle]="style"<br/>    mwlResizable<br/>    [validateResize]="validate"<br/>    [enableGhostResize]="true"<br/>    (resizeEnd)="onResizeEnd($event)"<br/>    [resizeEdges]="{bottom: true, right: true, top: true, left: true}"<br/>  &gt;&lt;/div&gt;<br/>&lt;/div&gt;</span><span id="3aa9" class="lg jw hi lb b fi ll li l lj lk">import { Component } from "@angular/core";<br/>import { ResizeEvent } from "angular-resizable-element";<br/><br/>@Component({<br/>  selector: "my-app",<br/>  templateUrl: "./app.component.html",<br/>  styleUrls: ["./app.component.css"]<br/>})<br/>export class AppComponent {<br/>  public style: object = {};<br/><br/>  validate(event: ResizeEvent): boolean {<br/>    const MIN_DIMENSIONS_PX: number = 50;<br/>    if (<br/>      event.rectangle.width &amp;&amp;<br/>      event.rectangle.height &amp;&amp;<br/>      (event.rectangle.width &lt; MIN_DIMENSIONS_PX ||<br/>        event.rectangle.height &lt; MIN_DIMENSIONS_PX)<br/>    ) {<br/>      return false;<br/>    }<br/>    return true;<br/>  }<br/><br/>  onResizeEnd(event: ResizeEvent): void {<br/>    this.style = {<br/>      position: "fixed",<br/>      left: `${event.rectangle.left}px`,<br/>      top: `${event.rectangle.top}px`,<br/>      width: `${event.rectangle.width}px`,<br/>      height: `${event.rectangle.height}px`<br/>    };<br/>  }<br/>}</span></pre><p id="ce40" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如您所见，我们使用了模板库中的<code class="du ky kz la lb b">mwlResizable</code>指令选择器及其组件中的<code class="du ky kz la lb b">ResizeEvent</code>接口。我们需要使用我们的包装器。让我们开始吧。</p><h2 id="5093" class="lg jw hi bd jx lm ln lo kb lp lq lr kf jb ls lt kj jf lu lv kn jj lw lx kr ly bi translated">第一步:输入和输出</h2><p id="6d43" class="pw-post-body-paragraph iq ir hi is b it kt iv iw ix ku iz ja jb kv jd je jf kw jh ji jj kx jl jm jn hb bi translated">作为第一步，我发现定义包装器的输入和输出非常有用。首先，我们将在新文件中为包装器创建一个新指令。由于我们计划提供一个类似的，但比库公开的接口更简单的接口，我们可以使用它的<a class="ae jo" href="https://github.com/mattlewis92/angular-resizable-element/blob/master/src/resizable.directive.ts" rel="noopener ugc nofollow" target="_blank">源代码</a>作为基础，简单地复制我们计划提供的输入和输出。完成这一步后，我们会得到如下结果:</p><pre class="jp jq jr js fd lc lb ld le aw lf bi"><span id="9562" class="lg jw hi lb b fi lh li l lj lk">@Directive({<br/>  selector: "[resizableWrapper]"<br/>})<br/>export class ResizableDirective implements OnInit, OnChanges, OnDestroy {<br/>  @Input() validateResize: (resizeEvent: ResizeEvent) =&gt; boolean;<br/>  @Input() resizeEdges: Edges = {};<br/>  @Input() enableGhostResize: boolean = false;<br/>  @Input() ghostElementPositioning: "fixed" | "absolute" = "fixed";<br/>  @Output() resizeStart = new EventEmitter&lt;ResizeEvent&gt;();<br/>  @Output() resizing = new EventEmitter&lt;ResizeEvent&gt;();<br/>  @Output() resizeEnd = new EventEmitter&lt;ResizeEvent&gt;();<br/>}</span></pre><p id="2d55" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">您还需要确保不只是重用库的接口，而是提供自己的接口。例如，在上面的代码中，我们有<code class="du ky kz la lb b">ResizeEvent</code>和<code class="du ky kz la lb b">Edges</code>接口。我们确保在单独的文件中定义我们自己的。</p><h2 id="9d7b" class="lg jw hi bd jx lm ln lo kb lp lq lr kf jb ls lt kj jf lu lv kn jj lw lx kr ly bi translated">第二步:构造函数参数</h2><p id="29fa" class="pw-post-body-paragraph iq ir hi is b it kt iv iw ix ku iz ja jb kv jd je jf kw jh ji jj kx jl jm jn hb bi translated">因为每当我们创建包装器的实例时，我们都将创建库指令的实例，所以我们将需要传递适当的依赖项。这里是第三方指令的构造函数:</p><pre class="jp jq jr js fd lc lb ld le aw lf bi"><span id="d9e9" class="lg jw hi lb b fi lh li l lj lk">constructor(<br/>    @Inject(PLATFORM_ID) private platformId: any,<br/>    private renderer: Renderer2,<br/>    public elm: ElementRef,<br/>    private zone: NgZone<br/>  ) {<br/>    this.pointerEventListeners = PointerEventListeners.getInstance(<br/>      renderer,<br/>      zone<br/>    );<br/>}</span></pre><p id="571d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">所以我们需要传递四个依赖项。这四个都是<code class="du ky kz la lb b">@angular/core</code>包的一部分，因此 DI 系统应该很容易解决。让我们现在做那件事。</p><p id="7ea1" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这一步不是特别难。我们所需要做的就是将库的指令添加到我们的包装器的构造函数中，并为 Angular 的 DI 提供一个工厂提供者。</p><pre class="jp jq jr js fd lc lb ld le aw lf bi"><span id="6fc8" class="lg jw hi lb b fi lh li l lj lk">function resizableDirectiveFactory(<br/>  platformId: any,<br/>  renderer: Renderer2,<br/>  elm: ElementRef,<br/>  zone: NgZone<br/>) {<br/>  return new ResizableDirective(platformId, renderer, elm, zone);<br/>}<br/><br/>const resizableDirectiveProvider = { <br/>  provide: ResizableDirective,<br/>  useFactory: resizableDirectiveFactory,<br/>  deps: [PLATFORM_ID, Renderer2, ElementRef, NgZone]<br/>};<br/><br/>@Directive({<br/>  selector: "[resizableWrapper]",<br/>  providers: [resizableDirectiveProvider]<br/>})<br/>export class ResizableWrapperDirective implements OnInit, OnChanges, OnDestroy {<br/>  constructor(private library: ResizableDirective) {}<br/>}</span></pre><h2 id="b1b5" class="lg jw hi bd jx lm ln lo kb lp lq lr kf jb ls lt kj jf lu lv kn jj lw lx kr ly bi translated">第三步:生命周期挂钩</h2><p id="65ea" class="pw-post-body-paragraph iq ir hi is b it kt iv iw ix ku iz ja jb kv jd je jf kw jh ji jj kx jl jm jn hb bi translated">用 Angular 包装指令时要记住的一点是，我们需要考虑生命周期挂钩。它们可以被视为包装器 API 的一部分。您可能希望拥有与您包装的指令相同的生命周期挂钩。记住这一点，让我们看看我们需要实现的三个挂钩。<br/> <br/>先有<code class="du ky kz la lb b">ngOnInit</code>。我们要做的第一件事是连接输出。</p><pre class="jp jq jr js fd lc lb ld le aw lf bi"><span id="50a1" class="lg jw hi lb b fi lh li l lj lk">ngOnInit(): void {<br/>  this.library.resizeStart<br/>    .pipe(takeUntil(this.destroy$))<br/>    .subscribe(event =&gt; this.resizeStart.emit(event));<br/>  this.library.resizing<br/>    .pipe(takeUntil(this.destroy$))<br/>    .subscribe(event =&gt; this.resizing.emit(event));<br/>  this.library.resizeEnd<br/>    .pipe(takeUntil(this.destroy$))<br/>    .subscribe(event =&gt; this.resizeEnd.emit(event));<br/>}</span></pre><p id="86c4" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">记住，这个例子非常简单，因为我们的事件接口是库接口的镜像。如果不是这样，您就必须在发出它们之前将它们映射到您自己的接口。</p><p id="eaa1" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">好了，剩下的就是委托给图书馆自己的<code class="du ky kz la lb b">ngOnInit</code>功能。</p><pre class="jp jq jr js fd lc lb ld le aw lf bi"><span id="39fc" class="lg jw hi lb b fi lh li l lj lk">ngOnInit(): void {<br/>  ...<br/>  <br/>  this.library.ngOnInit();<br/>}</span></pre><p id="6237" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">就这么简单。移动到<code class="du ky kz la lb b">ngOnChanges</code>，它在<code class="du ky kz la lb b">ngOnInit</code>之前被调用，并且每次一个或多个数据绑定输入属性改变时被调用。猜猜在这个函数中我们需要做什么。没错，分配我们的输入属性...并委托给库的<code class="du ky kz la lb b">ngOnChanges</code>函数。</p><pre class="jp jq jr js fd lc lb ld le aw lf bi"><span id="a3db" class="lg jw hi lb b fi lh li l lj lk">ngOnChanges(changes: SimpleChanges): void {<br/>  if (changes.validateResize)<br/>    this.library.validateResize = this.validateResize;<br/>  if (changes.resizeEdges) this.library.resizeEdges = this.resizeEdges;<br/>  if (changes.enableGhostResize)<br/>    this.library.enableGhostResize = this.enableGhostResize;<br/>  if (changes.ghostElementPositioning)<br/>    this.library.ghostElementPositioning = this.ghostElementPositioning;<br/><br/>  this.library.ngOnChanges(changes);<br/>}</span></pre><p id="8cae" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">最后，<code class="du ky kz la lb b">ngOnDestroy</code></p><pre class="jp jq jr js fd lc lb ld le aw lf bi"><span id="11f6" class="lg jw hi lb b fi lh li l lj lk">ngOnDestroy(): void {<br/>  this.library.ngOnDestroy();<br/>  this.destroy$.next();<br/>}</span></pre><h2 id="dd35" class="lg jw hi bd jx lm ln lo kb lp lq lr kf jb ls lt kj jf lu lv kn jj lw lx kr ly bi translated">第四步:声明你的包装器并使用它</h2><p id="898c" class="pw-post-body-paragraph iq ir hi is b it kt iv iw ix ku iz ja jb kv jd je jf kw jh ji jj kx jl jm jn hb bi translated">剩下的就是将我们的包装器添加到我们的模块中，并在我们的模板中使用它。</p><pre class="jp jq jr js fd lc lb ld le aw lf bi"><span id="5309" class="lg jw hi lb b fi lh li l lj lk">import { NgModule } from "@angular/core";<br/>import { BrowserModule } from "@angular/platform-browser";<br/>import { FormsModule } from "@angular/forms";<br/><br/>import { AppComponent } from "./app.component";<br/>import { ResizableWrapperDirective } from "../lib/resizable-wrapper.directive";<br/><br/>@NgModule({<br/>  imports: [BrowserModule, FormsModule],<br/>  declarations: [AppComponent, ResizableWrapperDirective],<br/>  bootstrap: [AppComponent]<br/>})<br/>export class AppModule {}</span></pre><p id="434a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如你所见，我们的模块没有引用第三方<a class="ae jo" href="https://github.com/mattlewis92/angular-resizable-element" rel="noopener ugc nofollow" target="_blank">角度可调整元素</a>库。它只声明了我们的包装指令。我们的模板和组件现在也只依赖于我们的包装指令。</p><pre class="jp jq jr js fd lc lb ld le aw lf bi"><span id="14c7" class="lg jw hi lb b fi lh li l lj lk">&lt;div class="text-center"&gt;<br/>  &lt;h1&gt;Drag and pull the edges of the rectangle&lt;/h1&gt;<br/>  &lt;div<br/>    class="rectangle"<br/>    [ngStyle]="style"<br/>    resizableWrapper<br/>    [validateResize]="validate"<br/>    [enableGhostResize]="true"<br/>    (resizeEnd)="onResizeEnd($event)"<br/>    [resizeEdges]="{bottom: true, right: true, top: true, left: true}"<br/>  &gt;&lt;/div&gt;<br/>&lt;/div&gt;</span></pre><h1 id="b7e4" class="jv jw hi bd jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks bi translated">结论</h1><p id="8833" class="pw-post-body-paragraph iq ir hi is b it kt iv iw ix ku iz ja jb kv jd je jf kw jh ji jj kx jl jm jn hb bi translated">包装第三方库通常是很好的实践，但是在处理角度指令时，这样做可能是一个挑战。每个库都是不同的，需要的方法也略有不同，但是本文中列出的四个步骤应该是一个很好的基础。</p></div></div>    
</body>
</html>