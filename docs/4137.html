<html>
<head>
<title>Dynamic programming explained by shopping list optimization case.</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用购物清单优化案例解释动态规划。</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/dynamic-programming-explained-by-shopping-list-optimization-case-1e5ae31c911f?source=collection_archive---------12-----------------------#2021-07-08">https://medium.com/nerd-for-tech/dynamic-programming-explained-by-shopping-list-optimization-case-1e5ae31c911f?source=collection_archive---------12-----------------------#2021-07-08</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="aa17" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">长话短说:我决定以这样一种方式自动排序我的购物清单，这有助于我沿着最短的路径穿过商店，按照清单上显示的顺序收集食品。</p><p id="8ee8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">令人惊讶的是，这个项目帮助我真正理解了动态编程的原理。在这篇文章中，我想告诉你我的经历，我希望它能帮助人们更好地理解它。</p><p id="be9c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">所以，这里有一个想法:首先，让我们根据它们的类型(肉，牛奶，饮料，等等)将列表中的所有杂货分组，然后记住要访问的部门，就可以计算出穿过商店的最佳路径，并相应地对列表进行排序。</p><p id="31ff" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我使用电报机器人作为接口。在本文中，我将描述它的后端部分。</p><h2 id="d8f9" class="jd je hi bd jf jg jh ji jj jk jl jm jn iq jo jp jq iu jr js jt iy ju jv jw jx bi translated">计算最佳路线</h2><p id="25f6" class="pw-post-body-paragraph if ig hi ih b ii jy ik il im jz io ip iq ka is it iu kb iw ix iy kc ja jb jc hb bi translated">让我们创建一个表示商店各部分之间距离的邻接矩阵M。所以M(i，j)表示从部门I到j的距离。如果列表中没有与某个部分相对应的项目，它将从矩阵中删除，因此矩阵中只包含我要访问的部门。</p><figure class="ke kf kg kh fd ki er es paragraph-image"><div class="er es kd"><img src="../Images/078d0069fb8793ca22bb3ed76e92335d.png" data-original-src="https://miro.medium.com/v2/resize:fit:702/format:webp/0*htXMAmyAOacAmYRU.png"/></div><figcaption class="kl km et er es kn ko bd b be z dx translated">邻接矩阵。主对角线上的正方形完全是黑色的，这意味着各部门到它们自己的距离为零。</figcaption></figure><p id="c5cc" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">首先想到的计算路线的方法是所谓的“贪婪算法”，即总是去最近的点。不幸的是，贪婪算法通常不会返回最佳路径。例如，下图说明了这种算法失败的情况。</p><figure class="ke kf kg kh fd ki er es paragraph-image"><div class="er es kp"><img src="../Images/eb1c1d822458896e1407abd06b53f689.png" data-original-src="https://miro.medium.com/v2/resize:fit:904/format:webp/1*oMmDi7Qqb1qKwuz8YG5M6A.png"/></div><figcaption class="kl km et er es kn ko bd b be z dx translated">要访问从A开始的所有点，首先需要访问B点，它不是最近的。</figcaption></figure><p id="bb37" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">所以，动态编程就是答案。动态编程通过将最初的任务分解成更小的任务，使得解决某些任务比暴力更容易。较小任务的解被存储在存储器中，并用于构建越来越复杂任务的解，直到得到初始任务的解。</p><p id="2107" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在这种情况下，较小的任务是通过给定的点的子集找到在某个点结束的最短路径。存储中间结果的最简单方法是将它们写入矩阵A(i，j ),并使“I”表示中间路线的终点，而“j”将以某种方式对给定路线经过的点的子集进行编码。</p><p id="edc1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">下面是我使用的编码点子集的方法:让我们创建一个大小等于点总数的位掩码。现在，位掩码中的1表示对应点在子集中，0表示不在子集中。例如，01011描述了由5个点组成的集合的第2、第4和第5个点的子集。这个二进制数可以转换成十进制数，用作矩阵索引。</p><p id="1567" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我用下面的例子来阐明这个观点。比如说A(51105)= 10。1105是二进制的10001010001，这意味着该路由访问点1、5、7和11，对应于位掩码中的1。5是该行的编号，表示路线在点№5处结束。综上所述，通过点1、5、7和11并在点№5结束的路线长度为10。</p><p id="f588" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这是算法。首先，只包含一个二进制1的列被填充—这些是只通过一个点的路线。然后是包含两个1、三个1的列，依此类推。这些列按其位掩码中1的数量递增的顺序填充，因为后面的列中的值是基于前面填充的列中的值。</p><p id="4a3d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">例如，让我们假设在它们的位掩码中包含1和2的所有列都已经被填充，这允许我们计算第15列的第1行的值，因为二进制中的15是1101，包含3个1。1101表示通过点1、2和4的路线，行5表示所述路线在点№5结束。</p><figure class="ke kf kg kh fd ki er es paragraph-image"><div class="er es kq"><img src="../Images/5ddeadb15c124649b21cb7d4e3788ea6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1004/1*Ug-KbJxE2RxITVdSRt61WA.gif"/></div></figure><p id="ea6d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这条路线是两个值M(1，2) + A(2，5)和M(1，4) + A(4，5)的最小值。我们考虑第5列，因为它的位掩码是0101，这对应于通过除最后一列之外我们需要的所有点的路线。像这样，所有的细胞都被填满了。对应于不可能状态的单元格用无穷大的值填充。</p><figure class="ke kf kg kh fd ki er es paragraph-image"><div class="er es kr"><img src="../Images/4498c12543d627bdbdb0b7f97e47482a.png" data-original-src="https://miro.medium.com/v2/resize:fit:618/format:webp/1*fzEVeI0dcVs90jMfjViqXg.png"/></div><figcaption class="kl km et er es kn ko bd b be z dx translated">解矩阵。一半的单元代表不可能的状态。</figcaption></figure><p id="d106" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">最终，我们对最后一列感兴趣，因为它对应于通过所有点的路线。现在，我们只需找到最后一行中的最小值，并使用矩阵中的值构建路线。</p><p id="2c07" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">最后一件事，合理的做法是在购物清单的“冷冻产品”部分结束，这样你拿的产品就不会融化。</p><figure class="ke kf kg kh fd ki er es paragraph-image"><div role="button" tabindex="0" class="kt ku di kv bf kw"><div class="er es ks"><img src="../Images/c25fad8c82397a12214ca5b459114ee7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ASrA6HyhW-8tijENgjSPBA.png"/></div></div><figcaption class="kl km et er es kn ko bd b be z dx translated">包含冷冻产品部分的路线</figcaption></figure><figure class="ke kf kg kh fd ki er es paragraph-image"><div role="button" tabindex="0" class="kt ku di kv bf kw"><div class="er es kx"><img src="../Images/7ba10146661b3f179c49acd304d7672d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SZdZV5M191W5qbZhuHJw1A.png"/></div></div><figcaption class="kl km et er es kn ko bd b be z dx translated">除了冷冻产品，通过相同部分的路线是完全不同的</figcaption></figure><p id="52b3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">有趣的是路线是如何根据是否包含“冷冻产品”部分而完全改变的。</p><h2 id="4947" class="jd je hi bd jf jg jh ji jj jk jl jm jn iq jo jp jq iu jr js jt iy ju jv jw jx bi translated">将杂货分类</h2><p id="c3ad" class="pw-post-body-paragraph if ig hi ih b ii jy ik il im jz io ip iq ka is it iu kb iw ix iy kc ja jb jc hb bi translated">例如，我将使用以下列表:</p><pre class="ke kf kg kh fd ky kz la lb aw lc bi"><span id="57bb" class="jd je hi kz b fi ld le l lf lg">- Cheese<br/>- Bananas<br/>- Hazelnuts<br/>- Stakes<br/>- Bread<br/>- Tuna<br/>- Eggs<br/>- Beer<br/>- Cereal<br/>- Apples<br/>- Pepper<br/>- Ketchup<br/>- Soda<br/>- Icecream</span></pre><p id="f37c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们从绘制部门地图开始。我去了最近的杂货店，做了这样的表:</p><figure class="ke kf kg kh fd ki"><div class="bz dy l di"><div class="lh li l"/></div><figcaption class="kl km et er es kn ko bd b be z dx translated">描述商店的表片段</figcaption></figure><p id="ff40" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">第一列包含部门的名称，第二列和第三列包含部门的坐标，它们将用于创建邻接矩阵。</p><p id="e6d5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">第四列包含锚点。主播就是在相应部门可以买到什么的例子。起初，我想在“锚”栏中包含我在相应部门购买的所有商品。这将使将杂货与部门匹配变得容易得多，只需查找与列表中的项目匹配的某个锚点就足够了。不幸的是，所述方法有几个缺点。首先，每次列表中出现一个新条目时，都需要将它添加到锚中。第二，每样东西都可以用不同的方式提及，比如茄子可以被称为aubergine。我决定使用单词嵌入，而不是将所有的可能性都填入“锚”列。</p><p id="e909" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">单词嵌入是一个非常有用的工具，它允许用向量代替字符串。向量代表单词的意思，例如，要了解两个单词的意思有多接近，可以简单地计算代表它们的向量之间的距离。“啤酒”和“饮料”向量之间的距离远小于“啤酒”和“面包店”向量之间的距离，这意味着啤酒更有可能在“饮料”部分中找到。</p><p id="7b68" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我使用俄罗斯Navec嵌入，因为我用俄语编写我的购物清单，但也有许多可用的英语嵌入。</p><p id="46c3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在算法看起来是这样的:对于列表中的每个条目，我们需要测量到第四列中每个锚点的距离。该项目属于具有最接近锚的类别。所述方法解决了以前从未发生过的物品的问题以及同一产品的不同名称的问题，因为“茄子”和“茄子”的单词嵌入几乎相同。</p><p id="0aaf" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">所以，现在列表看起来像这样:</p><pre class="ke kf kg kh fd ky kz la lb aw lc bi"><span id="5fbe" class="jd je hi kz b fi ld le l lf lg">{<br/>'bakery': ['Bread'],<br/>'breakfast': ['Cereal'],<br/>'milk/cheese/eggs': ['Cheese', 'Eggs'],<br/>'meat': ['Stakes'],<br/>'Beverages': ['Beer', 'Soda'],<br/>'Fruits':['Apples','Bananas'],<br/>'Nuts':['Hazelnuts'],<br/>'Canned food':['Tuna'],<br/>'Spices':['Pepper', 'Ketchup'],<br/>'Frozen products':['Icecream'],</span><span id="f802" class="jd je hi kz b fi lj le l lf lg">}</span></pre><p id="f038" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我想指出的是，榛子最终被归入了“坚果”一类，尽管榛子并不属于这一类。</p><p id="038f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们就快到了，现在剩下的是根据最佳路线对各组进行排序。</p><pre class="ke kf kg kh fd ky kz la lb aw lc bi"><span id="edbd" class="jd je hi kz b fi ld le l lf lg">- Apples<br/>- Bananas</span><span id="bfaf" class="jd je hi kz b fi lj le l lf lg">- Tuna</span><span id="9702" class="jd je hi kz b fi lj le l lf lg">- Pepper <br/>- Ketchup</span><span id="cebe" class="jd je hi kz b fi lj le l lf lg">- Cereal</span><span id="c879" class="jd je hi kz b fi lj le l lf lg">- Hazelnuts</span><span id="b79e" class="jd je hi kz b fi lj le l lf lg">- Cheese <br/>- Eggs</span><span id="9dc0" class="jd je hi kz b fi lj le l lf lg">- Stakes</span><span id="4304" class="jd je hi kz b fi lj le l lf lg">- Bread</span><span id="d358" class="jd je hi kz b fi lj le l lf lg">- Beer <br/>- Soda</span><span id="a07a" class="jd je hi kz b fi lj le l lf lg">- Icecream</span></pre><p id="e926" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">所以，结果就是这样。对于那些感兴趣的人，这里有一个到GitHub的链接。</p></div></div>    
</body>
</html>