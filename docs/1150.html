<html>
<head>
<title>Single-Activity?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">单活动？</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/single-activity-2659f6ac09e8?source=collection_archive---------4-----------------------#2021-03-06">https://medium.com/nerd-for-tech/single-activity-2659f6ac09e8?source=collection_archive---------4-----------------------#2021-03-06</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="3dea" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这是系列文章的一部分。目标、基础、项目结构、文章摘要见 <a class="ae je" href="https://sites.google.com/view/migueltt/home_en" rel="noopener ugc nofollow" target="_blank"> <em class="jd"> Android::简体</em> </a></p><p id="f0cf" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">确保先阅读<a class="ae je" href="https://miguelt.medium.com/decoupling-binding-57566dc7b17d" rel="noopener">解耦绑定</a>文章！</p><p id="b502" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">存储库:<a class="ae je" href="https://gitlab.com/migueltt/simpleandroid" rel="noopener ugc nofollow" target="_blank">https://gitlab.com/migueltt/simpleandroid</a></p></div><div class="ab cl jf jg gp jh" role="separator"><span class="ji bw bk jj jk jl"/><span class="ji bw bk jj jk jl"/><span class="ji bw bk jj jk"/></div><div class="hb hc hd he hf"><p id="5501" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi jm translated">关于是否使用单活动架构，一直有很多争论。这有多种好处，但都取决于应用程序的组织方式:</p><ul class=""><li id="9770" class="jv jw hi ih b ii ij im in iq jx iu jy iy jz jc ka kb kc kd bi translated">它不是关于一个“单一”的活动，而是关于“屏幕”是如何组织的——也就是说，一个完整的工作流程</li><li id="311a" class="jv jw hi ih b ii ke im kf iq kg iu kh iy ki jc ka kb kc kd bi translated">“屏幕”是向用户显示信息的任何组件——对于 Android 来说，这些可以是<code class="du kj kk kl km b">Fragments</code>，为什么不可以是<code class="du kj kk kl km b">Activities</code></li><li id="ac02" class="jv jw hi ih b ii ke im kf iq kg iu kh iy ki jc ka kb kc kd bi translated">这不仅仅是把你所有的<code class="du kj kk kl km b">Fragments</code>(或<code class="du kj kk kl km b">Activities</code>)加到一个<code class="du kj kk kl km b">navigation-graph</code>中，然后用一个<code class="du kj kk kl km b">NavHostFragment</code>引用它。您必须清楚地理解用例及其数据需求</li></ul><p id="b97c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><a class="ae je" href="https://developer.android.com/guide/navigation" rel="noopener ugc nofollow" target="_blank"> Jetpack 导航 API </a>使得整个应用程序的组织更加简单，简化了你在应用程序不同部分之间的转换。</p><p id="35c4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">首先，您必须考虑“<em class="jd">模块</em>”:</p><ul class=""><li id="3bf8" class="jv jw hi ih b ii ij im in iq jx iu jy iy jz jc ka kb kc kd bi translated">一个<em class="jd">模块</em>包含一个特性或工作流，并且可以包含几个“屏幕”——在我们的例子中是<code class="du kj kk kl km b">Fragments</code></li><li id="2b66" class="jv jw hi ih b ii ke im kf iq kg iu kh iy ki jc ka kb kc kd bi translated">你应该为每个<em class="jd">模块</em>定义一个<code class="du kj kk kl km b">navigation-graph</code></li><li id="7f34" class="jv jw hi ih b ii ke im kf iq kg iu kh iy ki jc ka kb kc kd bi translated">几个<code class="du kj kk kl km b">navigation-graphs</code>可以从一个主<code class="du kj kk kl km b">nested-graphs</code>引用，或者，它可以直接连接到一个<code class="du kj kk kl km b">NavHostFragment</code></li></ul><p id="319b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在我们的<code class="du kj kk kl km b"><a class="ae je" href="https://gitlab.com/migueltt/simpleandroid" rel="noopener ugc nofollow" target="_blank">Simple::Android</a></code>应用中，<em class="jd">模块</em> <code class="du kj kk kl km b"><a class="ae je" href="https://gitlab.com/migueltt/simpleandroid/-/tree/develop/app/src/debug/java/com/simpleandroid/modules/testui" rel="noopener ugc nofollow" target="_blank"><strong class="ih hj">testui</strong></a></code>(变体<code class="du kj kk kl km b">debug</code>)包含了 10 个不同的<code class="du kj kk kl km b">Fragments</code>，它们实现了几乎每一个<em class="jd"> UI 小部件</em>——这样做只是为了验证我们未来所有的<em class="jd">模块</em>不会受到 UI 库更新的影响(例如材料设计组件。)</p><p id="8cfc" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">实现了两种不同的方法，提供相同的功能:</p><ol class=""><li id="36fd" class="jv jw hi ih b ii ij im in iq jx iu jy iy jz jc kn kb kc kd bi translated"><code class="du kj kk kl km b"><a class="ae je" href="https://gitlab.com/migueltt/simpleandroid/-/blob/develop/app/src/debug/java/com/simpleandroid/modules/testui/ActivityTestMain.kt" rel="noopener ugc nofollow" target="_blank">ActivityTestMain</a></code>包含自己的<code class="du kj kk kl km b">NavHostFragment</code>——这有效地使<em class="jd">模块</em> <code class="du kj kk kl km b">testui</code>自包含并在自己的“窗口”内</li><li id="5d21" class="jv jw hi ih b ii ke im kf iq kg iu kh iy ki jc kn kb kc kd bi translated"><code class="du kj kk kl km b"><a class="ae je" href="https://gitlab.com/migueltt/simpleandroid/-/blob/develop/app/src/debug/java/com/simpleandroid/modules/testui/FragmentTestMain.kt" rel="noopener ugc nofollow" target="_blank">FragmentTestMain</a></code>包含它自己的<code class="du kj kk kl km b">NavHostFragment</code> —这有效地使<em class="jd">模块</em> <code class="du kj kk kl km b">testui</code>自包含，但在<code class="du kj kk kl km b">ActivityMain</code>“窗口”内</li></ol><p id="40f9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">实现的不同之处在于如何处理<em class="jd">反压</em>事件。</p><p id="c21d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">根据您想要管理每个<em class="jd">模块</em>的方式，在您的模块中分离和管理<em class="jd">流</em>是非常简单的，另外还有在不同级别管理视图模型的好处:</p><ul class=""><li id="ed35" class="jv jw hi ih b ii ij im in iq jx iu jy iy jz jc ka kb kc kd bi translated">如果整个应用程序需要一些共享数据(例如登录状态)，只需在<code class="du kj kk kl km b">Activity</code>级别定义一个视图模型—使用<code class="du kj kk kl km b">activityViewModels(..)</code></li><li id="3570" class="jv jw hi ih b ii ke im kf iq kg iu kh iy ki jc ka kb kc kd bi translated">如果一个<em class="jd">模块</em>内的所有<em class="jd">屏幕</em>都应该使用相同的数据，只需在<code class="du kj kk kl km b">navigation-graph</code>级别定义一个视图模型——使用<code class="du kj kk kl km b">navGraphViewModels(..)</code></li><li id="ea0a" class="jv jw hi ih b ii ke im kf iq kg iu kh iy ki jc ka kb kc kd bi translated">如果<em class="jd">屏幕</em>只需要自己的数据，只需在<code class="du kj kk kl km b">Fragment</code>级别定义一个视图模型——使用<code class="du kj kk kl km b">viewModels(..)</code></li></ul><p id="fc5f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">请记住，我们的目标是建立这样的架构:</p><figure class="kp kq kr ks fd kt er es paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="er es ko"><img src="../Images/0dad968a631fbc2b4612e37a61e25ebc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*Q7UdphefEizqEb-e.png"/></div></div></figure></div></div>    
</body>
</html>