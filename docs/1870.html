<html>
<head>
<title>Build the Forest in Python Series: Double-Threaded Binary Search Tree</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用Python构建森林系列:双线程二叉查找树</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/build-the-forest-in-python-series-double-threaded-binary-search-tree-a639f5b2e304?source=collection_archive---------27-----------------------#2021-04-10">https://medium.com/nerd-for-tech/build-the-forest-in-python-series-double-threaded-binary-search-tree-a639f5b2e304?source=collection_archive---------27-----------------------#2021-04-10</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="39f6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">继续讨论<a class="ae jd" href="https://shunsvineyard.info/2021/04/02/build-the-forest-in-python-series-single-threaded-binary-search-trees/" rel="noopener ugc nofollow" target="_blank">线程二叉树</a>；本文将实现双线程二叉查找树，它结合了左右单线程二叉树，具有两者的优点，但也增加了复杂性。</p><h1 id="75e1" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">项目设置</h1><p id="e80b" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">遵循与<a class="ae jd" href="https://shunsvineyard.info/build-the-forest-series/" rel="noopener ugc nofollow" target="_blank">构建森林系列</a>中其他文章相同的风格和假设，实现假设为Python 3.9或更新版本。本文为我们的项目添加了两个模块:<em class="kh">double _ threaded _ binary _ trees . py</em>用于双线程二叉查找树实现，以及<em class="kh">test _ double _ threaded _ binary _ tree . py</em>用于其单元测试。添加这两个文件后，我们的项目布局如下:</p><pre class="ki kj kk kl fd km kn ko kp aw kq bi"><span id="6a8f" class="kr jf hi kn b fi ks kt l ku kv">forest-python<br/>├── forest<br/>│   ├── __init__.py<br/>│   ├── binary_trees<br/>│   │   ├── __init__.py<br/>│   │   ├── binary_search_tree.py<br/>│   │   ├── double_threaded_binary_tree.py<br/>│   │   ├── single_threaded_binary_trees.py<br/>│   │   └── traversal.py<br/>│   └── tree_exceptions.py<br/>└── tests<br/>    ├── __init__.py<br/>    ├── conftest.py<br/>    ├── test_binary_search_tree.py<br/>    ├── test_double_threaded_binary_tree.py<br/>    ├── test_single_threaded_binary_trees.py<br/>    └── test_traversal.py</span></pre><p id="2257" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">(完整代码可从<a class="ae jd" href="https://github.com/shunsvineyard/forest-python" rel="noopener ugc nofollow" target="_blank"> forest-python </a>获得)</p><h1 id="433a" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">什么是双线程二叉树？</h1><p id="1ef0" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">正如我们在<a class="ae jd" href="https://shunsvineyard.info/2021/04/02/build-the-forest-in-python-series-single-threaded-binary-search-trees/#1-what-is-threaded-binary-trees" rel="noopener ugc nofollow" target="_blank">中谈到的什么是线程二叉树</a>，双线程二叉树具有单线程二叉树的两个特征:对于任何空的左或右属性，空属性被线程化到有序的前任或继任者:如果左属性为空，左属性指向节点的前任；如果右属性为空，则右属性指向该节点的后继节点。</p><figure class="ki kj kk kl fd kx er es paragraph-image"><div class="er es kw"><img src="../Images/a960dd327daa1891e48ad7609ab24067.png" data-original-src="https://miro.medium.com/v2/resize:fit:1242/format:webp/0*RZjhkcDeSpcAY_bg.png"/></div></figure><p id="cfa0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">虽然增加左右线程增加了复杂性，但是双线程树具有单线程树的优点。</p><ul class=""><li id="0e0b" class="la lb hi ih b ii ij im in iq lc iu ld iy le jc lf lg lh li bi translated">快速后继和前任访问</li><li id="ac86" class="la lb hi ih b ii lj im lk iq ll iu lm iy ln jc lf lg lh li bi translated">对于按序、前序和反向按序遍历，没有辅助堆栈或递归方法</li><li id="2a79" class="la lb hi ih b ii lj im lk iq ll iu lm iy ln jc lf lg lh li bi translated">因为不需要辅助堆栈或递归，所以减少了内存消耗。</li><li id="e767" class="la lb hi ih b ii lj im lk iq ll iu lm iy ln jc lf lg lh li bi translated">利用浪费的空间。由于节点的空左和空右属性不存储任何东西，所以我们可以将空左和空右属性用作线程。</li></ul><h1 id="9604" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">构建双螺纹二叉查找树</h1><p id="833d" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">正如我们在<a class="ae jd" href="https://shunsvineyard.info/2021/04/02/build-the-forest-in-python-series-single-threaded-binary-search-trees/#3-build-single-threaded-binary-search-trees" rel="noopener ugc nofollow" target="_blank">构建单线程二分搜索法树</a>一节中所做的，这一节将遍历实现并讨论实现选择背后的一些想法。</p><h1 id="f44c" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">结节</h1><p id="84da" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">因为一个节点可能有一个左线程、一个右线程或者两者都有，所以这个节点比<a class="ae jd" href="https://shunsvineyard.info/2021/03/13/build-the-forest-in-python-series-binary-search-tree/#4-node" rel="noopener ugc nofollow" target="_blank">二叉查找树节点</a>多了两个字段——<em class="kh">左线程</em>和<em class="kh">右线程</em>。</p><figure class="ki kj kk kl fd kx er es paragraph-image"><div class="er es lo"><img src="../Images/9c23cb7fc7790b80ecd8c97b605faa82.png" data-original-src="https://miro.medium.com/v2/resize:fit:584/format:webp/0*y9M79mTUwnv-7D2I.png"/></div></figure><p id="de33" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="kh"> left_thread </em>和<em class="kh"> right_thread </em>属性都是布尔变量:<em class="kh"> True </em>如果属性是线程；<em class="kh">假</em>否则。</p><pre class="ki kj kk kl fd km kn ko kp aw kq bi"><span id="779d" class="kr jf hi kn b fi ks kt l ku kv">@dataclass<br/>class Node:<br/>    key: Any<br/>    data: Any<br/>    left: Optional["Node"] = None<br/>    right: Optional["Node"] = None<br/>    parent: Optional["Node"] = None<br/>    left_thread: bool = False<br/>    right_thread: bool = False</span></pre><p id="f85b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">作为二叉查找树节点，我们将线程二叉树的节点类定义为<a class="ae jd" href="https://www.python.org/dev/peps/pep-0557/" rel="noopener ugc nofollow" target="_blank">数据类</a>。</p><p id="7ca6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">双线程二叉树具有构建和修改的核心函数(插入、删除和搜索)以及不与特定树相关的其他辅助函数，例如获取最左边的节点和获取树的高度。我们在二叉查找树中实现的同一个<em class="kh"> __repr__() </em>函数也可以用于调试目的。</p><p id="c77d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">由于双线程二叉树既有左线程又有右线程，所以我们可以实现不使用堆栈也不使用递归方法的按序、前序和反向按序遍历。下面是双线程二叉树的类概述。</p><pre class="ki kj kk kl fd km kn ko kp aw kq bi"><span id="5211" class="kr jf hi kn b fi ks kt l ku kv">class DoubleThreadedBinaryTree:<br/><br/>    def __init__(self) -&gt; None:<br/>        self.root: Optional[Node] = None<br/><br/>    def __repr__(self) -&gt; str:<br/>        """Provie the tree representation to visualize its layout."""<br/>        if self.root:<br/>            return (<br/>                f"{type(self)}, root={self.root}, "<br/>                f"tree_height={str(self.get_height(self.root))}"<br/>            )<br/>        return "empty tree"<br/><br/>    def search(self, key: Any) -&gt; Optional[Node]:<br/>        …<br/><br/>    def insert(self, key: Any, data: Any) -&gt; None:<br/>        …<br/><br/>    def delete(self, key: Any) -&gt; None:<br/>        …<br/><br/>    @staticmethod<br/>    def get_leftmost(node: Node) -&gt; Node:<br/>        …<br/><br/>    @staticmethod<br/>    def get_rightmost(node: Node) -&gt; Node:<br/>        …<br/><br/>    @staticmethod<br/>    def get_successor(node: Node) -&gt; Optional[Node]:<br/>        …<br/><br/>    @staticmethod<br/>    def get_predecessor(node: Node) -&gt; Optional[Node]:<br/>        …<br/><br/>    @staticmethod<br/>    <!-- -->def get_height(node: Optional[Node]) -&gt; int:<br/>        <!-- -->…<br/><br/>    def preorder_traverse(self) -&gt; traversal.Pairs:<br/>        …<br/><br/>    def inorder_traverse(self) -&gt; traversal.Pairs:<br/>        …<br/><br/>    def reverse_inorder_traverse(self) -&gt; traversal.Pairs:<br/>        …</span></pre><h1 id="a4d1" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">插入</h1><p id="9a36" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">插入操作类似于单线程二叉树，但是双线程树需要考虑左右线程更新。</p><ol class=""><li id="f1ba" class="la lb hi ih b ii ij im in iq lc iu ld iy le jc lp lg lh li bi translated">通过从根开始遍历树，并将新节点的键与沿途每个节点的键进行比较，找到插入新节点的适当位置(即新节点的父节点)。当走到右边的子树时，也检查<em class="kh"> right_thread </em>变量。如果变量<em class="kh">为真</em>，我们到达叶节点，那就是父节点。同样，当走到左子树时，我们检查<em class="kh"> left_thread </em>。如果<em class="kh">为真</em>，我们到达叶节点，找到要插入的节点的父节点。</li><li id="9ae7" class="la lb hi ih b ii lj im lk iq ll iu lm iy ln jc lp lg lh li bi translated">更新新节点的父属性以指向父节点。</li><li id="c4c6" class="la lb hi ih b ii lj im lk iq ll iu lm iy ln jc lp lg lh li bi translated">如果新节点是父节点的左子节点，则将父节点的左属性复制到新节点的左属性中(父节点的左属性必须是插入前的线程)，并将<em class="kh"> left_thread </em>变量设置为<em class="kh"> True </em>。更新父节点的left属性指向新节点，并将父节点的<em class="kh"> left_thread </em>设置为<em class="kh"> False </em>。</li><li id="e907" class="la lb hi ih b ii lj im lk iq ll iu lm iy ln jc lp lg lh li bi translated">如果新节点是其父节点的右子节点，则将父节点的右属性复制到新节点的右属性中(父节点的右属性必须是插入前的线程)，并将<em class="kh"> right_thread </em>变量设置为<em class="kh"> True </em>。更新父节点的right属性以指向新节点，并将父节点的<em class="kh"> right_thread </em>设置为<em class="kh"> False </em>。</li></ol><p id="3766" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">下图演示了节点插入的步骤。</p><figure class="ki kj kk kl fd kx er es paragraph-image"><div class="er es lq"><img src="../Images/225c498a47596e50b25a8371b519aa04.png" data-original-src="https://miro.medium.com/v2/resize:fit:1322/0*ClB6-BdVSLPogPZ0.gif"/></div></figure><p id="5730" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">实现必须检查和更新左右线程。</p><pre class="ki kj kk kl fd km kn ko kp aw kq bi"><span id="e5da" class="kr jf hi kn b fi ks kt l ku kv">def insert(self, key: Any, data: Any) -&gt; None:<br/>    node = Node(key=key, data=data)<br/>    if self.root is None:<br/>        self.root = node<br/>    else:<br/>        temp = self.root<br/>        while temp:<br/>            # Move to left subtree<br/>            if node.key &lt; temp.key:<br/>                if temp.left_thread is False and temp.left:<br/>                    temp = temp.left<br/>                    continue<br/>                else:<br/>                    node.left = temp.left<br/>                    temp.left = node<br/>                    node.right = temp<br/>                    node.right_thread = True<br/>                    node.parent = temp<br/>                    temp.left_thread = False<br/>                    if node.left:<br/>                        node.left_thread = True<br/>                    break<br/>            # Move to right subtree<br/>            elif node.key &gt; temp.key:<br/>                if temp.right_thread is False and temp.right:<br/>                    temp = temp.right<br/>                    continue<br/>                else:<br/>                    node.right = temp.right<br/>                    temp.right = node<br/>                    node.left = temp<br/>                    node.left_thread = True<br/>                    temp.right_thread = False<br/>                    node.parent = temp<br/>                    if node.right:<br/>                        node.right_thread = True<br/>                    break<br/>            else:<br/>                raise tree_exceptions.DuplicateKeyError(key=key)</span></pre><h1 id="5c13" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">搜索</h1><p id="5224" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">搜索操作类似于单线程树，但是我们检查<em class="kh"> left_thread </em>和<em class="kh"> right_thread </em>变量来确定我们是否到达了叶子。</p><ol class=""><li id="7cf8" class="la lb hi ih b ii ij im in iq lc iu ld iy le jc lp lg lh li bi translated">从根开始遍历树，并沿着树遍历将键与每个节点的键进行比较</li><li id="a42a" class="la lb hi ih b ii lj im lk iq ll iu lm iy ln jc lp lg lh li bi translated">如果一个键匹配，我们就找到了节点。</li><li id="922e" class="la lb hi ih b ii lj im lk iq ll iu lm iy ln jc lp lg lh li bi translated">如果当<em class="kh"> left_thread </em>或<em class="kh"> right_thread </em>为真时没有关键字匹配，则该节点在树中不存在。</li></ol><p id="1e8f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">其实现类似于单线程二叉树的搜索，只是做了简单的修改——检查<em class="kh">左线程</em>和<em class="kh">右线程</em>。</p><pre class="ki kj kk kl fd km kn ko kp aw kq bi"><span id="5b55" class="kr jf hi kn b fi ks kt l ku kv">def search(self, key: Any) -&gt; Optional[Node]:<br/>    current = self.root<br/>    while current:<br/>        if key == current.key:<br/>            return current<br/>        elif key &lt; current.key:<br/>            if current.left_thread is False:<br/>                current = current.left<br/>            else:<br/>                break<br/>        else:  # key &gt; current.key<br/>            if current.right_thread is False:<br/>                current = current.right<br/>            else:<br/>                break<br/>    return None</span></pre><h1 id="5f70" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">删除</h1><p id="ae1e" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">像任何其他二叉树中的删除一样，双线程二叉树的删除可以分解为三种子情况:要删除的节点没有子节点，只有一个子节点，或者两个子节点。我们还使用我们在<a class="ae jd" href="https://shunsvineyard.info/2021/03/13/build-the-forest-in-python-series-binary-search-tree/#9-delete" rel="noopener ugc nofollow" target="_blank">二叉查找树中使用的移植技术:删除</a>来用要删除的节点替换子树。虽然基本思想是相同的，但是<em class="kh">移植</em>函数和<em class="kh">删除</em>函数都需要将右线程和左线程纳入计数。我们需要记住的最重要的事情是，当我们删除一个节点时，如果有其他节点的右或左属性指向要删除的节点，我们需要更新那些节点的线程(即右或左属性)。</p><h2 id="430a" class="kr jf hi bd jg lr ls lt jk lu lv lw jo iq lx ly js iu lz ma jw iy mb mc ka md bi translated">案例1:没有孩子</h2><p id="90c4" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">如果要删除的节点没有子节点，则left和right属性都为空，并且<em class="kh"> left_thread </em>和<em class="kh"> right_thread </em>都为<em class="kh"> True </em>。关于线程，我们需要考虑两种情况。见下图。</p><figure class="ki kj kk kl fd kx er es paragraph-image"><div class="er es me"><img src="../Images/86df5949abc7878f7f1a50fb7861b609.png" data-original-src="https://miro.medium.com/v2/resize:fit:1082/format:webp/0*6VrP9Gats-H4dKnD.png"/></div></figure><h2 id="508d" class="kr jf hi bd jg lr ls lt jk lu lv lw jo iq lx ly js iu lz ma jw iy mb mc ka md bi translated">案例二:只有一个孩子</h2><p id="2652" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">如果要删除的节点只有一个子节点，不管是左子节点还是右子节点，我们总是需要更新它的线程:如果删除节点是左子节点，更新删除节点与之交互的右线程。如果删除的节点是右子节点，更新指向它的左线程。我们需要更新线程的情况如下图所示。</p><figure class="ki kj kk kl fd kx er es paragraph-image"><div role="button" tabindex="0" class="mg mh di mi bf mj"><div class="er es mf"><img src="../Images/4169b0dab2e9beaab398eb9679add305.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*L6x-hikMPKUK3FvQ.png"/></div></div></figure><h2 id="9449" class="kr jf hi bd jg lr ls lt jk lu lv lw jo iq lx ly js iu lz ma jw iy mb mc ka md bi translated">案例3:两个孩子</h2><p id="ff3c" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">类似于二叉查找树删除，要删除的节点有两个孩子的情况可以分解成两个子情况:</p><p id="33bf" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">3.a删除节点的右边子节点也是右边子树中最左边的节点。在这种情况下，正确的孩子必须只有一个正确的孩子。因此，我们可以将删除节点替换为它的右子节点，如下图所示。</p><figure class="ki kj kk kl fd kx er es paragraph-image"><div class="er es mk"><img src="../Images/161689889d0251c6b95ae0d288a5436f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1162/format:webp/0*FjgH9DbXyIOftkz2.png"/></div></figure><p id="0fd3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">3.b .删除节点的右子节点也有两个子节点。</p><p id="33f7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在这种情况下，我们从右边的子树中找到最左边的节点来替换要删除的节点。注意，当我们从右边的子树中取出最左边的节点时，它也属于删除情况:情况1:没有子节点或情况2:只有一个右边的子节点。否则，它不能是最左边的节点。</p><p id="2758" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">所以我们使用了两次<em class="kh">移植</em>函数:一次是取出最左边的节点，另一次是用原来最左边的节点替换删除的节点。下图展示了我们执行删除时的线程考虑。</p><p id="a215" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">替换节点没有子节点:</strong></p><figure class="ki kj kk kl fd kx er es paragraph-image"><div class="er es ml"><img src="../Images/8adccaac0f8073a101fc7cbcd161a693.png" data-original-src="https://miro.medium.com/v2/resize:fit:988/format:webp/0*2kLw4RHDQzkflCOf.png"/></div></figure><p id="039d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">替换节点只有一个右子节点</strong>:</p><figure class="ki kj kk kl fd kx er es paragraph-image"><div class="er es mm"><img src="../Images/84341516b1ee95a3ee83caa70adfdfb7.png" data-original-src="https://miro.medium.com/v2/resize:fit:610/format:webp/0*bU2aUx8MC9cxWLfK.png"/></div></figure><p id="81a6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">基于上面的图片，我们可以实现如下的删除和移植功能。</p><pre class="ki kj kk kl fd km kn ko kp aw kq bi"><span id="632d" class="kr jf hi kn b fi ks kt l ku kv">def delete(self, key: Any) -&gt; None:<br/>    if self.root and (deleting_node := self.search(key=key)):<br/><br/>        # Case 1: no child<br/>        if (deleting_node.left_thread or deleting_node.left is None) and (<br/>            deleting_node.right_thread or deleting_node.right is None<br/>        ):<br/>            self._transplant(deleting_node=deleting_node, replacing_node=None)<br/><br/>        # Case 2a: only one right child<br/>        elif (<br/>            deleting_node.left_thread or deleting_node.left is None<br/>        ) and deleting_node.right_thread is False:<br/><br/>            successor = self.get_successor(node=deleting_node)<br/>            if successor:<br/>                successor.left = deleting_node.left<br/>            self._transplant(<br/>                deleting_node=deleting_node, replacing_node=deleting_node.right<br/>            )<br/><br/>        # Case 2b: only one left child,<br/>        elif (<br/>            deleting_node.right_thread or deleting_node.right is None<br/>        ) and deleting_node.left_thread is False:<br/><br/>            predecessor = self.get_predecessor(node=deleting_node)<br/>            if predecessor:<br/>                predecessor.right = deleting_node.right<br/>            self._transplant(<br/>                deleting_node=deleting_node, replacing_node=deleting_node.left<br/>            )<br/><br/>        # Case 3: two children<br/>        elif deleting_node.left and deleting_node.right:<br/>            predecessor = self.get_predecessor(node=deleting_node)<br/>            replacing_node: Node = self.get_leftmost(node=deleting_node.right)<br/>            successor = self.get_successor(node=replacing_node)<br/><br/>            # the leftmost node is not the direct child of the deleting node<br/>            if replacing_node.parent != deleting_node:<br/>                if replacing_node.right_thread:<br/>                    self._transplant(<br/>                        deleting_node=replacing_node, replacing_node=None<br/>                    )<br/>                else:<br/>                    self._transplant(<br/>                        deleting_node=replacing_node,<br/>                        replacing_node=replacing_node.right,<br/>                    )<br/>                replacing_node.right = deleting_node.right<br/>                replacing_node.right.parent = replacing_node<br/>                replacing_node.right_thread = False<br/><br/>            self._transplant(<br/>                deleting_node=deleting_node, replacing_node=replacing_node<br/>            )<br/>            replacing_node.left = deleting_node.left<br/>            replacing_node.left.parent = replacing_node<br/>            replacing_node.left_thread = False<br/>            if predecessor and predecessor.right_thread:<br/>                predecessor.right = replacing_node<br/><br/>            if successor and successor.left_thread:<br/>                successor.left = replacing_node<br/>        else:<br/>            raise RuntimeError("Invalid case. Should never happened")<br/><br/>def _transplant(self, deleting_node: Node, replacing_node: Optional[Node]) -&gt; None:<br/>    if deleting_node.parent is None:<br/>        self.root = replacing_node<br/>        if self.root:<br/>            self.root.left_thread = False<br/>            self.root.right_thread = False<br/>    elif deleting_node == deleting_node.parent.left:<br/>        deleting_node.parent.left = replacing_node<br/><br/>        if replacing_node:<br/>            if deleting_node.left_thread:<br/>                if replacing_node.left_thread:<br/>                    replacing_node.left = deleting_node.left<br/><br/>            if deleting_node.right_thread:<br/>                if replacing_node.right_thread:<br/>                    replacing_node.right = replacing_node.right<br/>        else:<br/>            deleting_node.parent.left = deleting_node.left<br/>            deleting_node.parent.left_thread = True<br/><br/>    else:  # deleting_node == deleting_node.parent.right<br/>        deleting_node.parent.right = replacing_node<br/><br/>        if replacing_node:<br/>            if deleting_node.left_thread:<br/>                if replacing_node.left_thread:<br/>                    replacing_node.left = deleting_node.left<br/><br/>            if deleting_node.right_thread:<br/>                if replacing_node.right_thread:<br/>                    replacing_node.right = replacing_node.right<br/>        else:<br/>            deleting_node.parent.right = deleting_node.right<br/>            deleting_node.parent.right_thread = True<br/><br/>    if replacing_node:<br/>        replacing_node.parent = deleting_node.parent</span></pre><h1 id="9183" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">获得高度</h1><p id="14ba" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">为了计算一个双线程二叉树的树高，我们可以像在<a class="ae jd" href="https://shunsvineyard.info/2021/03/13/build-the-forest-in-python-series-binary-search-tree/#14-get-the-height" rel="noopener ugc nofollow" target="_blank">二叉查找树:获取高度</a>中所做的那样，为每个孩子的高度递归地增加1。如果一个节点有两个子节点，我们使用<a class="ae jd" href="https://docs.python.org/3/library/functions.html#max" rel="noopener ugc nofollow" target="_blank"> max </a>函数从子节点中获取较大的高度，并将最大值增加1。主要区别是我们使用<em class="kh"> left_thread </em>和<em class="kh"> right_thread </em>来检查一个节点是否有子节点。</p><pre class="ki kj kk kl fd km kn ko kp aw kq bi"><span id="50cb" class="kr jf hi kn b fi ks kt l ku kv">@staticmethod<br/>def get_height(node: Optional[Node]) -&gt; int:<br/>    if node:<br/>        if node.left_thread is False and node.right_thread is False:<br/>            return (<br/>                max(<br/>                    DoubleThreadedBinaryTree.get_height(node.left),<br/>                    DoubleThreadedBinaryTree.get_height(node.right),<br/>                )<br/>                + 1<br/>            )<br/><br/>        if node.left_thread and node.right_thread is False:<br/>            return DoubleThreadedBinaryTree.get_height(node.right) + 1<br/><br/>        if node.right_thread and node.left_thread is False:<br/>            return DoubleThreadedBinaryTree.get_height(node.left) + 1<br/><br/>    return 0</span></pre><h1 id="8db2" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">获取最左边和最右边的节点</h1><p id="9874" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">由于双线程树节点可能有左线程、右线程或者两者都有，为了得到最右边的节点和最左边的节点，我们需要检查<em class="kh"> right_thread </em>和<em class="kh"> left_thread </em>是否为<em class="kh"> True </em>。<em class="kh">get _ leftsmall</em>的实现如下。</p><pre class="ki kj kk kl fd km kn ko kp aw kq bi"><span id="310b" class="kr jf hi kn b fi ks kt l ku kv">@staticmethod<br/>def get_leftmost(node: Node) -&gt; Node:<br/>    current_node = node<br/>    while current_node.left and current_node.left_thread is False:<br/>        current_node = current_node.left<br/>    return current_node</span></pre><p id="03ad" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="kh"> get_rightmost </em>实现与<em class="kh"> get_leftmost </em>对称。</p><pre class="ki kj kk kl fd km kn ko kp aw kq bi"><span id="e34f" class="kr jf hi kn b fi ks kt l ku kv">@staticmethod<br/>def get_rightmost(node: Node) -&gt; Node:<br/>    current_node = node<br/>    if current_node:<br/>        while current_node.right and current_node.right_thread is False:<br/>            current_node = current_node.right<br/>    return current_node</span></pre><h1 id="e7d9" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">前任和继任者</h1><p id="6851" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">双线索树既有左线索又有右线索，因此它具有快速的有序后继和前趋访问。</p><pre class="ki kj kk kl fd km kn ko kp aw kq bi"><span id="a1e0" class="kr jf hi kn b fi ks kt l ku kv">@staticmethod<br/>def get_predecessor(node: Node) -&gt; Optional[Node]:<br/>    if node.left_thread:<br/>        return node.left<br/>    else:<br/>        if node.left:<br/>            return DoubleThreadedBinaryTree.get_rightmost(node=node.left)<br/>        return None</span></pre><p id="0a3d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="kh">获取_继任者</em>与<em class="kh">获取_前任</em>对称。</p><pre class="ki kj kk kl fd km kn ko kp aw kq bi"><span id="3cbc" class="kr jf hi kn b fi ks kt l ku kv">@staticmethod<br/>def get_successor(node: Node) -&gt; Optional[Node]:<br/>    if node.right_thread:<br/>        return node.right<br/>    else:<br/>        if node.right:<br/>            return DoubleThreadedBinaryTree.get_leftmost(node=node.right)<br/>        return None</span></pre><h1 id="c02a" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">按序、前序和反向按序遍历</h1><p id="68ad" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">双线索树具有左线索树和右线索树的优点，因此它可以在不使用堆栈或递归方法的情况下执行按序、前序和反向按序遍历。</p><p id="a3c8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">有序遍历</strong></p><p id="c342" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">下图中的红色箭头演示了线程树中的有序遍历。</p><ol class=""><li id="7938" class="la lb hi ih b ii ij im in iq lc iu ld iy le jc lp lg lh li bi translated">从整个树的最左边的节点开始。</li><li id="f567" class="la lb hi ih b ii lj im lk iq ll iu lm iy ln jc lp lg lh li bi translated">如果右属性是线程，则跟随右属性；如果右边的属性不是线程，那么转到子树最左边的节点。</li><li id="592b" class="la lb hi ih b ii lj im lk iq ll iu lm iy ln jc lp lg lh li bi translated">重复步骤2，直到右侧属性为<em class="kh">无</em>。</li></ol><figure class="ki kj kk kl fd kx er es paragraph-image"><div class="er es lq"><img src="../Images/c786d61913be079d96232556e1a4ac57.png" data-original-src="https://miro.medium.com/v2/resize:fit:1322/format:webp/0*-zUIS5mhnJ-NAQ2m.png"/></div></figure><p id="8676" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">并且在不使用辅助堆栈或递归的情况下实现函数。</p><pre class="ki kj kk kl fd km kn ko kp aw kq bi"><span id="1830" class="kr jf hi kn b fi ks kt l ku kv">def inorder_traverse(self) -&gt; traversal.Pairs:<br/>    if self.root:<br/>        current: Optional[Node] = self.get_leftmost(node=self.root)<br/>        while current:<br/>            yield (current.key, current.data)<br/>            if current.right_thread:<br/>                current = current.right<br/>            else:<br/>                if current.right is None:<br/>                    break<br/>                current = self.get_leftmost(current.right)</span></pre><p id="6338" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">前序遍历</strong></p><p id="a0ce" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">下图中下面的红色箭头显示了线程化方式的前序遍历。</p><ol class=""><li id="7a0b" class="la lb hi ih b ii ij im in iq lc iu ld iy le jc lp lg lh li bi translated">从根开始。</li><li id="863e" class="la lb hi ih b ii lj im lk iq ll iu lm iy ln jc lp lg lh li bi translated">如果left属性不为空，则转到左边的子元素。</li><li id="2a6e" class="la lb hi ih b ii lj im lk iq ll iu lm iy ln jc lp lg lh li bi translated">如果左边的属性是空的或者是一个线程，那么跟随右边的线程到右边。</li><li id="eae5" class="la lb hi ih b ii lj im lk iq ll iu lm iy ln jc lp lg lh li bi translated">重复步骤2和3，直到右侧属性为空。</li></ol><figure class="ki kj kk kl fd kx er es paragraph-image"><div class="er es lq"><img src="../Images/5fd894c9e7758e4a5c59be5a95dfd9a4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1322/format:webp/0*-gJXLeM23hcqAhmc.png"/></div></figure><p id="df35" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">前序遍历可以如下实现。</p><pre class="ki kj kk kl fd km kn ko kp aw kq bi"><span id="f923" class="kr jf hi kn b fi ks kt l ku kv">def preorder_traverse(self) -&gt; traversal.Pairs:<br/>    current = self.root<br/>    while current:<br/>        yield (current.key, current.data)<br/>        if current.right_thread:<br/>            # If it is right thread, it must have a right child.<br/>            current = current.right.right  # type: ignore<br/>        elif current.left_thread is False:<br/>            current = current.left<br/>        else:<br/>            break</span></pre><p id="fe42" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">反向顺序遍历</strong></p><p id="fe68" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">下图中的红色箭头演示了反向顺序遍历的线程方式。</p><ol class=""><li id="baba" class="la lb hi ih b ii ij im in iq lc iu ld iy le jc lp lg lh li bi translated">从整个树的最右边的节点开始。</li><li id="ba72" class="la lb hi ih b ii lj im lk iq ll iu lm iy ln jc lp lg lh li bi translated">如果左边的属性是线程，则跟随线程；如果左边的属性不是线程，那么转到子树最右边的节点。</li><li id="7a99" class="la lb hi ih b ii lj im lk iq ll iu lm iy ln jc lp lg lh li bi translated">重复步骤2，直到左侧属性为<em class="kh">无</em>。</li></ol><figure class="ki kj kk kl fd kx er es paragraph-image"><div class="er es lq"><img src="../Images/3c6e2ff95350c1c995101d60d734d3ab.png" data-original-src="https://miro.medium.com/v2/resize:fit:1322/format:webp/0*VWkm7HOoFQvPQ60n.png"/></div></figure><p id="71fa" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">下面是实现。</p><pre class="ki kj kk kl fd km kn ko kp aw kq bi"><span id="9dee" class="kr jf hi kn b fi ks kt l ku kv">def reverse_inorder_traverse(self) -&gt; traversal.Pairs:<br/>    if self.root:<br/>        current: Optional[Node] = self.get_rightmost(node=self.root)<br/>        while current:<br/>            yield (current.key, current.data)<br/>            if current.left_thread:<br/>                current = current.left<br/>            else:<br/>                if current.left is None:<br/>                    break<br/>                current = self.get_rightmost(current.left)</span></pre><h1 id="4784" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">试验</h1><p id="f84f" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">和往常一样，我们应该尽可能多地对代码进行单元测试。这里，我们使用在<a class="ae jd" href="https://shunsvineyard.info/2021/03/13/build-the-forest-in-python-series-binary-search-tree/" rel="noopener ugc nofollow" target="_blank">构建二叉查找树</a>中创建的<a class="ae jd" href="https://github.com/shunsvineyard/forest-python/blob/main/tests/conftest.py" rel="noopener ugc nofollow" target="_blank"> conftest.py </a>中的<em class="kh"> basic_tree </em>函数来测试我们的双线程二叉树。检查<a class="ae jd" href="https://github.com/shunsvineyard/forest-python/blob/main/tests/test_double_threaded_binary_tree.py" rel="noopener ugc nofollow" target="_blank">test _ double _ threaded _ binary _ tree . py</a>进行完整的单元测试。</p><h1 id="b775" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">分析</h1><p id="938c" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">由于双线程树是单线程二叉树的组合，其操作的运行时间与单线程二叉树以及普通二叉查找树相同。</p><figure class="ki kj kk kl fd kx er es paragraph-image"><div role="button" tabindex="0" class="mg mh di mi bf mj"><div class="er es mn"><img src="../Images/7532a269563b190c0c83174ccc0aa078.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YDIMId8uJNGVodOxsGvqAA.png"/></div></div></figure><p id="291a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">并且它在有序、前序和逆有序遍历上具有恒定的空间复杂度。</p><figure class="ki kj kk kl fd kx er es paragraph-image"><div role="button" tabindex="0" class="mg mh di mi bf mj"><div class="er es mo"><img src="../Images/49dc6734e061761f007c2ac444f97a9f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9oU-BL6KCHhMYX3KMv-2VQ.png"/></div></div></figure><h1 id="683a" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">例子</h1><p id="bb91" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">虽然双线程二叉树比单线程二叉树更复杂，但当遍历很关键时，它可能是一种解决方案，但空间消耗是关注的，并且对于需要快速访问节点的前任和继任者的用户来说可能更简单。因此，我们在单线程二叉树中讨论的<a class="ae jd" href="https://shunsvineyard.info/2021/04/02/build-the-forest-in-python-series-single-threaded-binary-search-trees/#32-example" rel="noopener ugc nofollow" target="_blank">示例</a>可以简化如下:</p><pre class="ki kj kk kl fd km kn ko kp aw kq bi"><span id="6aa7" class="kr jf hi kn b fi ks kt l ku kv">from typing import Any<br/><br/>from forest.binary_trees import double_threaded_binary_tree<br/>from forest.binary_trees import traversal<br/><br/>class MyDatabase:<br/>    """Example using threaded binary trees to build index."""<br/><br/>    def __init__(self) -&gt; None:<br/>        self._double_bst = double_threaded_binary_tree.DoubleThreadedBinaryTree()<br/><br/>    def _persist(self, payload: Any) -&gt; str:<br/>        """Fake function pretent storing data to file system.<br/><br/>        Returns<br/>        -------<br/>        str<br/>            Path to the payload.<br/>        """<br/>        return f"path_to_{payload}"<br/><br/>    def insert_data(self, key: Any, payload: Any) -&gt; None:<br/>        """Insert data.<br/><br/>        Parameters<br/>        ----------<br/>        key: Any<br/>            Unique key for the payload<br/>        payload: Any<br/>            Any data<br/>        """<br/>        path = self._persist(payload=payload)<br/>        self._double_bst.insert(key=key, data=path)<br/><br/>    def dump(self, ascending: bool = True) -&gt; traversal.Pairs:<br/>        """Dump the data.<br/><br/>        Parameters<br/>        ----------<br/>        ascending: bool<br/>            The order of data.<br/><br/>        Yields<br/>        ------<br/>        `Pairs`<br/>            The next (key, data) pair.<br/>        """<br/>        if ascending:<br/>            return self._double_bst.inorder_traverse()<br/>        else:<br/>            return self._double_bst.reverse_inorder_traverse()<br/><br/>if __name__ == "__main__":<br/><br/>    # Initialize the database.<br/>    my_database = MyDatabase()<br/><br/>    # Add some items.<br/>    my_database.insert_data("Adam", "adam_data")<br/>    my_database.insert_data("Bob", "bob_data")<br/>    my_database.insert_data("Peter", "peter_data")<br/>    my_database.insert_data("David", "david_data")<br/><br/>    # Dump the items in ascending order.<br/>    print("Ascending...")<br/>    for contact in my_database.dump():<br/>        print(contact)<br/><br/>    print("\nDescending...")<br/>    # Dump the data in decending order.<br/>    for contact in my_database.dump(ascending=False):<br/>        print(contact)</span></pre><p id="178b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">(完整示例可从<a class="ae jd" href="https://github.com/shunsvineyard/forest-python/blob/main/examples/double_tbst_database.py" rel="noopener ugc nofollow" target="_blank"> double_tbst_database.py </a>获得)</p><p id="ddfe" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">输出将如下所示。</p><pre class="ki kj kk kl fd km kn ko kp aw kq bi"><span id="aad3" class="kr jf hi kn b fi ks kt l ku kv">Ascending...<br/>('Adam', 'path_to_adam_data')<br/>('Bob', 'path_to_bob_data')<br/>('David', 'path_to_david_data')<br/>('Peter', 'path_to_peter_data')<br/><br/>Descending...<br/>('Peter', 'path_to_peter_data')<br/>('David', 'path_to_david_data')<br/>('Bob', 'path_to_bob_data')<br/>('Adam', 'path_to_adam_data')</span></pre><h1 id="0115" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">摘要</h1><p id="7dcf" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">双线程树确实提供了单线程二叉树的优点，但是它的实现比单线程二叉树更复杂。此外，运行时性能没有显著提高。然而，在某些情况下，例如考虑到空间复杂性，并且特定遍历(例如，有序遍历)是关键的，双线程二叉树可以是一个选项。</p></div><div class="ab cl mp mq gp mr" role="separator"><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu"/></div><div class="hb hc hd he hf"><p id="8d20" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="kh">原载于2021年4月10日</em><a class="ae jd" href="https://shunsvineyard.info/2021/04/09/build-the-forest-in-python-series-double-threaded-binary-search-tree/" rel="noopener ugc nofollow" target="_blank"><em class="kh">https://shunsvineyard . info</em></a><em class="kh">。</em></p></div></div>    
</body>
</html>