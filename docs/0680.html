<html>
<head>
<title>How to make your test set up cleaner and why it’s more important than you think</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何让你的测试设置更整洁，为什么它比你想象的更重要</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/how-to-make-your-test-set-up-cleaner-and-why-its-more-important-than-you-think-172a2ed4f6c2?source=collection_archive---------5-----------------------#2021-02-03">https://medium.com/nerd-for-tech/how-to-make-your-test-set-up-cleaner-and-why-its-more-important-than-you-think-172a2ed4f6c2?source=collection_archive---------5-----------------------#2021-02-03</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="7e70" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我一直认为，如果你认为测试仅仅是为了构建健壮的软件组件和发现错误，那么你就有点误解了。他们比那更强大。</p><p id="d74d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">测试是一种由来已久的交流形式，也是你的公司中唯一真正可靠的文档形式。一个工具，可以围绕边缘案例建立清晰度，探索假设情景，并帮助提高效率，这是迄今为止你的公司最昂贵和最受欢迎的资源，在你为了更好的薪水而离开多年后。</p><p id="c28c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">但是令人沮丧的是，测试设置可能会令人困惑、冗长和不清楚，混淆了很容易成为对应用程序行为方式的集体理解的巨大资产的东西。</p><h1 id="bd44" class="jd je hi bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">代码</h1><p id="ad49" class="pw-post-body-paragraph if ig hi ih b ii kb ik il im kc io ip iq kd is it iu ke iw ix iy kf ja jb jc hb bi translated">出于演示目的进行了简化</p><pre class="kg kh ki kj fd kk kl km kn aw ko bi"><span id="d49c" class="kp je hi kl b fi kq kr l ks kt">public void validatePet(Pet pet, PetRequest petRequest) {<br/>    validateAge(pet, petRequest.getMaxAgeInMonthsExpectation());<br/>    validateColor(pet, petRequest.getColorExpectation());<br/>    validateCuteness(pet, petRequest.getCutenessExpectation());<br/>    validateTail(pet.getTail(), petRequest.getTailRequest());<br/>}<br/><br/>void validateAge(Pet pet, Integer maxAgeExpectation){<br/>    if(pet.getAgeInMonths() &gt; maxAgeExpectation){<br/>        throw new TooOldException();<br/>    }<br/>}<br/><br/>void validateColor(Pet pet, String color){<br/>    if(!pet.getColor().equals(color)){<br/>        throw new WrongColorException();<br/>    }<br/>}<br/><br/>void validateCuteness(Pet pet, Integer minCutenessExpectation){<br/>    if(pet.getCuteness() &lt; minCutenessExpectation){<br/>        throw new NotCuteEnoughException();<br/>    }<br/>}</span><span id="2174" class="kp je hi kl b fi ku kr l ks kt">public void validateTail(Tail tail, TailRequest tailRequest){<br/>    if(!tail.getTailFluff().equals(tailRequest.getTailFluff())){<br/>        throw new TailFluffException(tail.getTailFluff(), tailRequest.getTailFluff());<br/>     }    <br/>    if(tail.getTailLength() &lt; 0) {<br/>        throw new InvalidTailLengthException(tail.getTailLength());<br/>     }    <br/>    if(tail.getTailLength() &lt; tailRequest.getTailLength()){<br/>        throw new TailLengthException(tail.getTailLength(), tailRequest.getTailLength());<br/>    }<br/>}</span></pre><h1 id="ba85" class="jd je hi bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">测试</h1><p id="30b5" class="pw-post-body-paragraph if ig hi ih b ii kb ik il im kc io ip iq kd is it iu ke iw ix iy kf ja jb jc hb bi translated">测试设置通常是这样的。</p><pre class="kg kh ki kj fd kk kl km kn aw ko bi"><span id="92b8" class="kp je hi kl b fi kq kr l ks kt">@Test<br/>void validationFailsWhenPetNotCuteEnough() {<br/>    // difficult to spot straight away which field has an effect on the test<br/>    var pet =<br/>        Pet.<em class="kv">builder</em>()<br/>            .petType(PetType.<em class="kv">DOG</em>)<br/>            .ageInMonths(12)<br/>            .color("brown")<br/>            .cuteness(2)<br/>            .healthRating(10)<br/>            .tail(Tail<br/>                .<em class="kv">builder</em>()<br/>                .tailLength(10)<br/>                .tailFluffiness(TailFluffiness.<em class="kv">SUPER_FLUFFY</em>)<br/>                .build())<br/>            .build();<br/><br/>    var petRequest = PetRequest<br/>        .<em class="kv">builder</em>()<br/>        .petType(PetType.<em class="kv">DOG</em>)<br/>        .maxAgeInMonthsExpectation(120)<br/>        .colorExpectation("brown")<br/>        .cutenessExpectation(8)<br/>        .healthExpectation(8)<br/>        .tailRequest(<br/>            TailRequest<br/>                .<em class="kv">builder</em>()<br/>                .tailFluffiness(TailFluffiness.<em class="kv">SUPER_FLUFFY</em>)<br/>                .tailLength(10)<br/>                .build())<br/>        .build();<br/><br/><em class="kv">assertThrows</em>(NotCuteEnoughException.class,<br/>        () -&gt; petValidatorService.validatePet(pet, petRequest));<br/><br/>}</span></pre><p id="c609" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">虽然这绝对是一个正确的测试，并且显示了验证器的行为。这并不漂亮。实际上，哪个字段与测试失败相关并不明显。是的，虽然你不需要成为一个天才就能想出来，但它确实会让我眯着眼睛，头向前翘了四五秒钟才想出来。虽然您可能会争论异常的名称和显示名称的内容是否给了您所需要的所有信息，但是根据我的经验，依赖开发人员的意愿来命名通常是不好的。</p><p id="af05" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">将这样的测试设置增加到成千上万的测试和比小狗更复杂的领域，它很容易成为一个令人困惑和厌倦的游戏，沃利在哪里。</p><p id="60fe" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">因此，在我看来，这样设置的测试没有履行测试的非常重要的责任，即<em class="kv">创造清晰</em>。</p><p id="cc92" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">此外，如果这个对象在代码库中构建了100次，突然我们<strong class="ih hj">添加了一个大小验证器</strong>会怎么样？是的，没错，你需要改变100个类。</p><p id="fce9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">所以让我们尝试一些不同的东西。</p><h1 id="e26e" class="jd je hi bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated"><strong class="ak">对象母模式</strong></h1><p id="07f1" class="pw-post-body-paragraph if ig hi ih b ii kb ik il im kc io ip iq kd is it iu ke iw ix iy kf ja jb jc hb bi translated">从测试的角度来看，object mother类为我们对这只可怜的小狗不切实际的期望创建了一个更加清晰的解释。然而，像许多母亲一样，随着对象母亲的成熟，它会变得抗拒变化和高维护性，需要许多测试默认对象来适应您的所有需求。下面就来看看吧。</p><pre class="kg kh ki kj fd kk kl km kn aw ko bi"><span id="cbd8" class="kp je hi kl b fi kq kr l ks kt">public class PetObjectMother {<br/>public static Pet getNotSoCuteDog() {<br/>    return Pet.<em class="kv">builder</em>()<br/>        .petType(PetType.<em class="kv">DOG</em>)<br/>        .ageInMonths(12)<br/>        .color("brown")<br/>        .cuteness(2)<br/>        .healthRating(10)<br/>        .tail(<em class="kv">getLongAndFluffyTail</em>())<br/>        .build();<br/>}<br/><br/>public static Pet getOldDoggo() {<br/>    return Pet.<em class="kv">builder</em>()<br/>        .petType(PetType.<em class="kv">DOG</em>)<br/>        .ageInMonths(120)<br/>        .color("brown")<br/>        .cuteness(8)<br/>        .healthRating(10)<br/>        .tail(<em class="kv">getLongAndFluffyTail</em>())<br/>        .build();<br/> }<br/>}</span><span id="76e5" class="kp je hi kl b fi ku kr l ks kt">public class TailObjectMother {<br/>    public static Tail getLongAndFluffyTail(){<br/>        return Tail.<em class="kv">builder</em>()<br/>            .tailFluffiness(TailFluffiness.<em class="kv">SUPER_FLUFFY</em>)<br/>            .tailLength(10)<br/>            .build();<br/>    }<br/>}</span><span id="3934" class="kp je hi kl b fi ku kr l ks kt">@Test<br/>void validationFailsWhenPetNotCuteEnough() {<br/>    var pet = <em class="kv">getNotSoCuteDog</em>();<br/><br/>    var petRequest = <em class="kv">getFairlyDemandingPetRequest</em>();<br/><br/>    <em class="kv">assertThrows</em>(NotCuteEnoughException.class,<br/>        () -&gt; petValidatorService.validatePet(pet, petRequest));<br/>}<br/><br/>@Test<br/>void validationFailsWhenPetIsTooOld() {<br/>    var pet = <em class="kv">getOldDog</em>();<br/><br/>    var petRequest = <em class="kv">getFairlyDemandingPetRequest</em>();<br/><br/>    <em class="kv">assertThrows</em>(TooOldException.class,<br/>        () -&gt; petValidatorService.validatePet(pet, petRequest));<br/>}</span></pre><p id="a8fc" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我相信您可以想象这种解决方案的可伸缩性有多差。您最终需要为每个测试用例使用一个新的方法，并且会很快膨胀。</p><p id="857d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">对此，一个快速而明显的解决方案是将默认对象替换为一种接受参数的默认对象，但这可以很快变成一个普通的测试类，而没有构建器模式的清晰性(如果您确实选择使用构建器模式)。</p><p id="bd75" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">此外，尽管这个解决方案在客户端看起来更漂亮，但它实际上并没有创造出多少清晰度。我们仍然需要依靠方法的名称来检测d to的哪一部分影响了测试的结果。很容易被误命名或过时。</p><p id="88c5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果公司有使用测试人物角色的强大文化，这种模式可以很好地工作，这是我认可的，但是很难减轻伸缩问题，老实说，虽然我发现人物角色是一个好主意，但在我的职业生涯中，我从来没有真正看到它被有效地实现和维护过。</p><p id="b886" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">所以让我们尝试一些新的东西。年轻对象母亲模式。</p><h1 id="dc05" class="jd je hi bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">年轻对象母亲模式</h1><p id="541a" class="pw-post-body-paragraph if ig hi ih b ii kb ik il im kc io ip iq kd is it iu ke iw ix iy kf ja jb jc hb bi translated">年轻对象母亲的概念很简单。它的工作方式是创建一个默认对象，该对象被设置为总是干净地通过验证，依靠toBuilder模式(一个保留其默认值的构建器模式)来更改使测试失败所需的字段。</p><pre class="kg kh ki kj fd kk kl km kn aw ko bi"><span id="8085" class="kp je hi kl b fi kq kr l ks kt">public class PetProvider {<br/>   public static Pet getDefaultDog(){<br/>      return Pet.<em class="kv">builder</em>()<br/>        .petType(PetType.<em class="kv">DOG</em>)<br/>        .ageInMonths(1)<br/>        .color("brown")<br/>        .cuteness(10)<br/>        .healthRating(10)<br/>        .tail(<em class="kv">getDefaultTail</em>())<br/>        .build();<br/>   }<br/>}</span><span id="1822" class="kp je hi kl b fi ku kr l ks kt">public class TailProvider {<br/>    public static Tail getDefaultTail(){<br/>        return Tail<br/>            .<em class="kv">builder</em>()<br/>            .tailFluffiness(TailFluffiness.<em class="kv">SUPER_FLUFFY</em>)<br/>            .tailLength(10)<br/>            .build();<br/>    }<br/>}</span><span id="ee93" class="kp je hi kl b fi ku kr l ks kt">@Test<br/>void validationFailsWhenPetNotCuteEnough() {<br/>    // Immediately obvious that cuteness is effecting the result of the test<br/>    var pet = <em class="kv">getDefaultDog</em>().toBuilder().cuteness(1).build();<br/><br/>    var petRequest = <em class="kv">getDemandingPetRequest</em>();<br/><br/>    NotCuteEnoughException notCuteEnoughException = <em class="kv">assertThrows</em>(NotCuteEnoughException.class,<br/>        () -&gt; petValidatorService.validatePet(pet, petRequest));<br/>}<br/><br/>@Test<br/>void validationFailsWhenPetIsTooOld() {<br/>    var pet = <em class="kv">getDefaultDog</em>().toBuilder().ageInMonths(120).build();<br/><br/>    var petRequest = <em class="kv">getDemandingPetRequest</em>();<br/><br/><em class="kv">assertThrows</em>(TooOldException.class,<br/>        () -&gt; petValidatorService.validatePet(pet, petRequest));<br/>}</span></pre><p id="8f25" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这种方法有三个优点。</p><p id="ac20" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">首先，您只能在任何地方创建一个默认对象。<br/>对你所有的测试。你所有的单元测试，集成测试，所有的合同测试，验收测试和任何其他类型的测试。如果我们现在添加一个大小验证，就我们的测试设置而言，我们需要做的就是修改一行代码。多好啊。</p><p id="df09" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">第二，也是更重要的一点是，哪个字段导致验证失败是显而易见的。这意味着它很容易理解和领会。</p><p id="9d8d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">第三个优点是，通过创建更多的默认提供者方法，可以很容易地随时随地添加语义。但是，当采用这种方法时，我们再次没有明确指定哪个字段会导致测试失败。</p><pre class="kg kh ki kj fd kk kl km kn aw ko bi"><span id="169e" class="kp je hi kl b fi kq kr l ks kt">public class TailProvider {<br/>    public static Tail getDefaultTail(){<br/>        return Tail<br/>            .<em class="kv">builder</em>()<br/>            .tailFluffiness(TailFluffiness.<em class="kv">SUPER_FLUFFY</em>)<br/>            .tailLength(10)<br/>            .build();<br/>    }</span><span id="229f" class="kp je hi kl b fi ku kr l ks kt">public static Tail getInvertedTail(){<br/>        return Tail<br/>            .<em class="kv">builder</em>()<br/>            .tailFluffiness(TailFluffiness.<em class="kv">SUPER_FLUFFY</em>)<br/>            .tailLength(-1)<br/>            .build();<br/>    }<br/>}</span><span id="e482" class="kp je hi kl b fi ku kr l ks kt">@Test<br/>void validationFailsTailNotFluffyEnough() {<br/>    var pet = <em class="kv">getDefaultDog</em>()<br/>        .toBuilder()<br/>        .tail(getInvertedTail())<br/>        .build();<br/><br/>    var petRequest = <em class="kv">getDemandingPetRequest</em>();<br/><br/><em class="kv">assertThrows</em>(InvalidTailLengthException.class,<br/>        () -&gt; petValidatorService.validatePet(pet, petRequest));<br/><br/>}</span></pre><p id="3e8f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这种方法的主要缺点是需要在域对象上实现toBuilder模式(使用Lombok)。</p><p id="15e1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">虽然为了适应测试而将生产代码与模式结合起来被认为是不好的做法，但我总是发现这在实践中很大程度上是不起作用的。</p><p id="8f5c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">然而，为了降低这种风险，您可以使用TestDataTemplate模式。</p><h1 id="1a46" class="jd je hi bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">测试数据模板模式</h1><p id="09b0" class="pw-post-body-paragraph if ig hi ih b ii kb ik il im kc io ip iq kd is it iu ke iw ix iy kf ja jb jc hb bi translated">测试数据模板模式的概念与年轻对象母模式非常相似，唯一的区别是它创建了一个测试对象POJO，该对象包含在原始POJO中创建的所有字段和一个生成器，该生成器不是在build()方法中返回自身，而是返回一个原始POJO进行测试。</p><pre class="kg kh ki kj fd kk kl km kn aw ko bi"><span id="0844" class="kp je hi kl b fi kq kr l ks kt">public class PetTestDataTemplate {<br/>    public static PetTestDataTemplateBuilder builder() {<br/>        return new PetTestDataTemplateBuilder();<br/>    }<br/><br/>    public static class PetTestDataTemplateBuilder {<br/>        private String name = "woofy";<br/>        private Integer ageInMonths = 0;<br/>        private Integer cuteness = 10;<br/>        private Integer healthRating = 10;<br/>        private String color = "brown";<br/>        private PetType petType = PetType.<em class="kv">DOG</em>;<br/>        private Tail tail = TailTestDataTemplate.<em class="kv">builder</em>().build();<br/><br/>        PetTestDataTemplateBuilder() {<br/>        }<br/><br/>        public PetTestDataTemplateBuilder name(String name) {<br/>            this.name = name;<br/>            return this;<br/>        }<br/><br/>        public PetTestDataTemplateBuilder ageInMonths(Integer ageInMonths) {<br/>            this.ageInMonths = ageInMonths;<br/>            return this;<br/>        }<br/><br/>        public PetTestDataTemplateBuilder cuteness(Integer cuteness) {<br/>            this.cuteness = cuteness;<br/>            return this;<br/>        }<br/><br/>        public PetTestDataTemplateBuilder invalidHealthRating(){<br/>            this.healthRating = -1;<br/>            return this;<br/>        }<br/><br/>        public PetTestDataTemplateBuilder healthRating(Integer healthRating) {<br/>            this.healthRating = healthRating;<br/>            return this;<br/>        }<br/><br/>        public PetTestDataTemplateBuilder color(String color) {<br/>            this.color = color;<br/>            return this;<br/>        }<br/><br/>        public PetTestDataTemplateBuilder tail(Tail tail) {<br/>            this.tail = tail;<br/>            return this;<br/>        }<br/><br/>        public PetTestDataTemplateBuilder petType(PetType petType) {<br/>            this.petType = petType;<br/>            return this;<br/>        }<br/><br/>        public Pet build() {<br/>            return Pet.<em class="kv">builder</em>()<br/>                .name(name)<br/>                .ageInMonths(ageInMonths)<br/>                .cuteness(cuteness)<br/>                .healthRating(healthRating)<br/>                .color(color)<br/>                .petType(petType)<br/>                .tail(tail)<br/>                .build();<br/>        }<br/>    }<br/>}</span><span id="f2b2" class="kp je hi kl b fi ku kr l ks kt">@Test<br/>void validationFailsWhenPetHealthRatingIsBelow0() {<br/>    var pet = PetTestDataTemplate.<em class="kv">builder</em>().invalidHealthRating().build();<br/><br/>    var petRequest = PetRequestDataTemplate.<em class="kv">builder</em>().build();<br/><br/> <em class="kv">assertThrows</em>(InvalidHealthRatingException.class,<br/>        () -&gt; petValidatorService.validatePet(pet, petRequest));<br/>}</span></pre><p id="1d3c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">正如我们在测试端看到的，这种模式几乎完全相同，并且在概念上极其相似。您只能看到影响测试结果的字段。好处是它不会把你的POJOs和任何创造模式联系起来，然而它有点<em class="kv">大</em>并且维护起来更痛苦，但是如果你是这样的话，我很高兴。</p><h1 id="9470" class="jd je hi bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">结论</h1><p id="3928" class="pw-post-body-paragraph if ig hi ih b ii kb ik il im kc io ip iq kd is it iu ke iw ix iy kf ja jb jc hb bi translated">总之，虽然您设置测试数据的方法可能看起来微不足道，但事实并非如此。在一个项目中，任何可以创建清晰性和减少faf的事情都不是浪费时间。</p><p id="5866" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果像我一样，你很懒，不介意将你的POJOs耦合到构建器和构建器创建模式，我会推荐YOM(带有lombok)。如果可以理解，你不想或者不能耦合你的POJOs，任何创造性的模式，你可以维护测试对象，我会推荐TDT模式。</p></div></div>    
</body>
</html>