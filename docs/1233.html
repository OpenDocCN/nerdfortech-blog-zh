<html>
<head>
<title>When, Why and How to use Redux</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">何时、为何以及如何使用Redux</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/when-why-and-how-to-use-redux-ee1ce73639f6?source=collection_archive---------7-----------------------#2021-03-10">https://medium.com/nerd-for-tech/when-why-and-how-to-use-redux-ee1ce73639f6?source=collection_archive---------7-----------------------#2021-03-10</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="8e23" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Redux是JavaScript应用程序的可预测状态容器。这意味着您将所有的应用程序状态存储在一个地方，并且可以知道在任何给定时间点的状态。</p><p id="5e30" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在深入研究Redux之前，我们应该熟悉它的基础和前身Flux架构</p><h2 id="a894" class="jd je hi bd jf jg jh ji jj jk jl jm jn iq jo jp jq iu jr js jt iy ju jv jw jx bi translated">什么是通量？</h2><p id="eafa" class="pw-post-body-paragraph if ig hi ih b ii jy ik il im jz io ip iq ka is it iu kb iw ix iy kc ja jb jc hb bi translated">Flux是一种通用的架构或模式，而不是特定的实现。<strong class="ih hj">在Flux中，</strong>事件在一个循环流中一次管理一个事件，有许多参与者:<strong class="ih hj">调度员、商店和动作</strong>。</p><h2 id="56a1" class="jd je hi bd jf jg jh ji jj jk jl jm jn iq jo jp jq iu jr js jt iy ju jv jw jx bi translated"><strong class="ak">一个动作</strong></h2><p id="8417" class="pw-post-body-paragraph if ig hi ih b ii jy ik il im jz io ip iq ka is it iu kb iw ix iy kc ja jb jc hb bi translated">是描述系统中任何变化的结构:鼠标点击、超时事件、网络请求等等。动作被发送给调度程序</p><h2 id="9f7f" class="jd je hi bd jf jg jh ji jj jk jl jm jn iq jo jp jq iu jr js jt iy ju jv jw jx bi translated"><strong class="ak">调度员</strong></h2><p id="7efc" class="pw-post-body-paragraph if ig hi ih b ii jy ik il im jz io ip iq ka is it iu kb iw ix iy kc ja jb jc hb bi translated">是系统中的单点，任何人都可以在这里提交操作进行处理。然后，应用程序状态被保存在存储中。</p><h2 id="46d5" class="jd je hi bd jf jg jh ji jj jk jl jm jn iq jo jp jq iu jr js jt iy ju jv jw jx bi translated">商店</h2><p id="4e31" class="pw-post-body-paragraph if ig hi ih b ii jy ik il im jz io ip iq ka is it iu kb iw ix iy kc ja jb jc hb bi translated">持有部分应用程序状态，并对来自调度程序的命令作出反应。</p><h2 id="fc92" class="jd je hi bd jf jg jh ji jj jk jl jm jn iq jo jp jq iu jr js jt iy ju jv jw jx bi translated"><strong class="ak">简单通量流:</strong></h2><ol class=""><li id="ac95" class="kd ke hi ih b ii jy im jz iq kf iu kg iy kh jc ki kj kk kl bi translated">商店订阅动作的子集。</li><li id="b66c" class="kd ke hi ih b ii km im kn iq ko iu kp iy kq jc ki kj kk kl bi translated">一个动作被发送给调度程序。</li><li id="23ef" class="kd ke hi ih b ii km im kn iq ko iu kp iy kq jc ki kj kk kl bi translated">调度程序将该操作通知订阅的商店。</li><li id="444a" class="kd ke hi ih b ii km im kn iq ko iu kp iy kq jc ki kj kk kl bi translated">商店根据动作更新它们的状态。</li><li id="d92c" class="kd ke hi ih b ii km im kn iq ko iu kp iy kq jc ki kj kk kl bi translated">视图根据商店中的新状态进行更新。</li><li id="03ba" class="kd ke hi ih b ii km im kn iq ko iu kp iy kq jc ki kj kk kl bi translated">然后可以处理下一个动作。</li></ol><figure class="ks kt ku kv fd kw er es paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="er es kr"><img src="../Images/dca2c1d64c5a2ceb7c94279598d27087.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dQ2PnLorU2dJsMVfCti-2w.png"/></div></div></figure><blockquote class="ld le lf"><p id="c076" class="if ig lg ih b ii ij ik il im in io ip lh ir is it li iv iw ix lj iz ja jb jc hb bi translated">这个流程确保很容易推断出动作在系统中是如何流动的，什么会导致状态改变，以及它将如何改变。</p></blockquote><p id="5b6a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在这种情况下，点击事件将产生一个动作，这个动作将改变存储，然后改变视图。在此过程中，由存储或其他组件创建的任何操作都将被排队，并仅在第一个操作完成且视图更新后执行。</p><h2 id="4881" class="jd je hi bd jf jg jh ji jj jk jl jm jn iq jo jp jq iu jr js jt iy ju jv jw jx bi translated">还原与通量</h2><p id="0c5a" class="pw-post-body-paragraph if ig hi ih b ii jy ik il im jz io ip iq ka is it iu kb iw ix iy kc ja jb jc hb bi translated">虽然Redux源自Flux概念，但这两种架构之间还是有一些区别。</p><p id="c6c7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">与Flux相反，Redux只有一个单独的存储，它本身没有逻辑。存储直接调度和处理操作，不需要独立的调度程序。反过来，<strong class="ih hj">存储将动作传递给称为reducers的状态改变函数，</strong>Redux添加的一种新的actor。</p><figure class="ks kt ku kv fd kw er es paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="er es lk"><img src="../Images/cd5b054a04c0def4528aba2710304ac4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*S18b_4jsBrCgiQE9Utwybw.png"/></div></div></figure><h2 id="6247" class="jd je hi bd jf jg jh ji jj jk jl jm jn iq jo jp jq iu jr js jt iy ju jv jw jx bi translated">应用数据</h2><p id="9eda" class="pw-post-body-paragraph if ig hi ih b ii jy ik il im jz io ip iq ka is it iu kb iw ix iy kc ja jb jc hb bi translated">让我们想象一个帮助我们管理移动商店的应用程序。我们的移动商店应用程序的所有数据，包括手机及其附件的列表，都将存储在一个大对象中:商店。最好将这种模式与应用程序前端的数据库进行比较，就像服务器端的数据库一样，可能为每个数据对象保存多个表(或集合)。虽然许多其他框架将数据划分到不同的服务和领域，但在Redux中，我们将所有数据保存在一个中央存储库中，UI的所有部分都可以访问。</p><h2 id="64d9" class="jd je hi bd jf jg jh ji jj jk jl jm jn iq jo jp jq iu jr js jt iy ju jv jw jx bi translated">更改数据</h2><p id="e059" class="pw-post-body-paragraph if ig hi ih b ii jy ik il im jz io ip iq ka is it iu kb iw ix iy kc ja jb jc hb bi translated">因为我们所有的数据都存放在一个JavaScript对象中，所以必须有一种方法以清晰一致的方式修改它。但是允许我们代码中的不同地方直接访问和修改我们的中央存储库将会使跟踪变化和正确更新UI变得非常困难。</p><p id="f50b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在Redux中，对存储的所有更改都是通过发送一个动作来启动的，这个动作是一个普通的JavaScript对象，包含描述所需更改的所有信息。动作被发送(分派)到我们的商店，商店根据动作计算新的状态。</p><p id="e1f6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">由于store是一个通用的实现，在Redux中，我们使用另一个概念(reducers)来计算一旦对它应用了一个动作，我们的当前状态将会是什么样子。</p><p id="08a3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">例如，添加一个新的移动设备会将旧的状态(比如有三个配方的数组)更改为有四个配方的新状态</p><h2 id="8250" class="jd je hi bd jf jg jh ji jj jk jl jm jn iq jo jp jq iu jr js jt iy ju jv jw jx bi translated"><strong class="ak">更新用户界面</strong></h2><p id="fce4" class="pw-post-body-paragraph if ig hi ih b ii jy ik il im jz io ip iq ka is it iu kb iw ix iy kc ja jb jc hb bi translated">每个UI框架使用Redux (React，Angular，Vue等。)负责订阅商店收听其“<em class="lg">商店更新</em>事件并相应更新UI。</p><p id="cadc" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Redux 的<strong class="ih hj">核心理念是我们的UI总是反映应用在商店中的状态。发送一个动作将导致我们的商店使用我们的reducers来计算一个新的状态，并通知UI层相应地更新UI。</strong></p><h2 id="1a45" class="jd je hi bd jf jg jh ji jj jk jl jm jn iq jo jp jq iu jr js jt iy ju jv jw jx bi translated">还在想为什么Redux？</h2><p id="42d3" class="pw-post-body-paragraph if ig hi ih b ii jy ik il im jz io ip iq ka is it iu kb iw ix iy kc ja jb jc hb bi translated">Redux的其他部分使应用程序更容易构建和管理，比如中间件。每一个动作都通过中间件的管道传递。与reducers不同，中间件可以修改、停止或添加更多的动作。示例可能包括日志中间件、检查用户是否有运行操作的必要权限的授权中间件，或者向服务器发送信息的API中间件。</p><figure class="ks kt ku kv fd kw er es paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="er es ll"><img src="../Images/d457d85a79a8bd063384b804a0ff2d28.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uYciYHlDcdv4zKcObg4-pA.png"/></div></div></figure><h2 id="41b1" class="jd je hi bd jf jg jh ji jj jk jl jm jn iq jo jp jq iu jr js jt iy ju jv jw jx bi translated">基本Redux实现:</h2><p id="6ad8" class="pw-post-body-paragraph if ig hi ih b ii jy ik il im jz io ip iq ka is it iu kb iw ix iy kc ja jb jc hb bi translated">Redux背后的基本前提是所有应用程序状态都保存在一个地方，即存储区。</p><p id="ec9d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">要在应用程序中使用这个想法，我们需要找到一种方法:</strong></p><p id="0d10" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">1.作为事件的结果修改状态(用户生成的或来自服务器的)。2.监控状态变化，以便我们可以更新用户界面。</p><p id="32a9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">第一部分可分为两个功能块:</strong></p><ol class=""><li id="de8e" class="kd ke hi ih b ii ij im in iq lm iu ln iy lo jc ki kj kk kl bi translated">通知商店发生了一项行动。</li><li id="8352" class="kd ke hi ih b ii km im kn iq ko iu kp iy kq jc ki kj kk kl bi translated">帮助商店找出如何根据我们的应用程序的逻辑修改状态。</li></ol><p id="67fb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">使用这个结构，</strong>让我们构建一个实现计数器的简单应用程序。</p><p id="962e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们的应用程序将使用纯JavaScript和HTML，不需要任何现代浏览器中的额外库。我们将有两个按钮，允许我们增加和减少一个简单的计数器，以及一个我们可以看到当前计数器值的地方:</p><p id="943a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们为每个按钮创建一个点击处理程序，它将使用dispatch()函数通知我们的存储需要执行一个操作:dispatch(action)；将点击事件连接到dispatch() //侦听点击事件</p><p id="6d4a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">document . query selector(# Inc)。onclick = () = &gt;调度(' INC ')；document.querySelector('#dec ')。onclick =()=&gt;dispatch(' DEC ')；</strong></p><p id="25f4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们定义一个函数，它将根据作为参数接收的应用程序状态更新HTML中的计数器值:</p><p id="70a7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">//更新视图的函数(在真实app中可能是React或者Angular)<strong class="ih hj">函数update view(){ document . query selector(' # counter ')。innerText = state.counter} </strong></p><p id="6fcc" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">因为我们希望我们的视图表示当前的应用程序状态，所以我们需要它在每次状态(和计数器)改变时被更新。为此，我们将使用subscribe()函数，</p><p id="5b0d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">该函数的作用是在每次状态发生变化时调用我们的回调函数:</p><p id="7839" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">订阅(update view)；</strong></p><p id="83f7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在我们的简单示例中，我们的状态将保存一个计数器，它的值将根据动作递增或递减:</p><p id="0fe6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">功能减速器(状态，动作){ </strong></p><p id="c0b3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">开关(动作){ </strong></p><p id="0420" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> case 'INC ':返回Object.assign({}，state，{ counter:state . counter+1 })；case ' DEC ':return object . assign({ }，state，{ counter:state . counter—1 })；默认:返回状态；</strong></p><p id="faf7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> } </strong></p><p id="50aa" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> } </strong></p><blockquote class="ld le lf"><p id="3fad" class="if ig lg ih b ii ij ik il im in io ip lh ir is it li iv iw ix lj iz ja jb jc hb bi translated">需要记住的一件重要的事情是，reducers必须总是返回一个新的、修改过的状态副本。他们不应该改变现有的状态。T19】</p></blockquote><p id="6acd" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">dispatch()函数调用由应用程序创建者实现的reducer()，向它传递当前状态和它接收到的动作。这些信息应该足以让reducer()函数计算出一个新的状态。然后，我们检查新状态是否不同于旧状态，如果不同，我们替换旧状态，并通知所有侦听器这一变化:</p><p id="cd62" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">设状态=空；</strong></p><p id="07ff" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">功能调度(动作){ </strong></p><p id="df75" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> const newState = reducer(状态，动作)；</strong></p><p id="e211" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> if (newState！==状态){ </strong></p><p id="436b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">state = new state；listeners . foreach(listener =&gt;listener())；</strong></p><p id="0af9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> } </strong></p><p id="5471" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> } </strong></p><h2 id="7b3f" class="jd je hi bd jf jg jh ji jj jk jl jm jn iq jo jp jq iu jr js jt iy ju jv jw jx bi translated">使用真正的Redux</h2><p id="b275" class="pw-post-body-paragraph if ig hi ih b ii jy ik il im jz io ip iq ka is it iu kb iw ix iy kc ja jb jc hb bi translated">为了完成我们的例子，让我们切换到真正的Redux库，看看这个解决方案有多相似。</p><p id="6f01" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">首先，我们将添加Redux库</p><p id="d2ee" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">将Redux添加到项目中，然后我们将之前的状态定义更改为一个常量，该常量仅定义状态的初始值:</p><p id="5baa" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">初始状态</p><p id="d7d4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"><em class="lg">const initial state = { counter:3 }；</em> </strong></p><p id="4b53" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在我们可以用它来创建一个Redux存储:</p><p id="c845" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">创建Redux存储</p><p id="6298" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"><em class="lg">const store = redux . createstore(reducer，initial state)；</em>T41】</strong></p><p id="0fbf" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如你所见，我们正在使用以前的减速器。需要对缩减器进行的唯一更改是在switch语句中。我们不仅仅使用action:Previous reducer condition开关(action ),而是包含了强制类型属性，它指示正在执行的操作的类型:New reducer condition</p><p id="d4b6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> <em class="lg">【动作类型】</em> </strong>开关</p><p id="4bf4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Redux store还将提供我们之前自己实现的所有功能，比如subscribe()和dispatch()。</p><p id="a8dc" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">因此，我们可以安全地删除这些方法。要订阅存储更改，我们只需调用存储的subscribe()方法:</p><p id="e524" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">订阅商店更新</p><p id="9d4f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"><em class="lg">(update view)；</em> </strong></p><p id="ad3b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">因为subscribe()没有将状态传递给回调，所以我们需要通过store.getState()来访问它:</p><p id="2bfa" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">通过从存储中读取状态来更新视图</p><p id="3b30" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">//更新视图的函数(实际应用中可能是React或Angular)<strong class="ih hj"><em class="lg">函数updateView() { </em> </strong></p><p id="a733" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"><em class="lg">document . query selector(' # counter ')。innerText = store.getState()。柜台；</em>T15】</strong></p><p id="1488" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">T17)}T19】</strong></p><p id="0836" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> <em class="lg"> store.subscribe(更新视图)；</em> </strong></p><p id="9627" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">最后一个变化是在dispatch()方法中。</p><p id="3280" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如前所述，我们的动作现在需要有type属性。因此，代替发送字符串“INC”作为动作，</p><p id="e94c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们现在需要发送<strong class="ih hj"> <em class="lg"> { type: 'INC' }。</em> </strong></p><figure class="ks kt ku kv fd kw er es paragraph-image"><div class="er es lp"><img src="../Images/079d9efd7dffa845841e7b3d03a24209.png" data-original-src="https://miro.medium.com/v2/resize:fit:1316/format:webp/1*p3EO2YJUyOqlrHY71WfS1w.png"/></div></figure><p id="7782" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们简要介绍了Redux和Flux的历史，以及Redux的核心工作原理</p></div></div>    
</body>
</html>