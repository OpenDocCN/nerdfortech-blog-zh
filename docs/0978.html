<html>
<head>
<title>The Queue Data Structure.</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">队列数据结构。</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/the-queue-data-structure-77be9054e67c?source=collection_archive---------5-----------------------#2021-02-27">https://medium.com/nerd-for-tech/the-queue-data-structure-77be9054e67c?source=collection_archive---------5-----------------------#2021-02-27</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/be7cd4d9c2930f36a19453a92b069f20.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZdViWSGDs3WIZe0-rs1zaA.jpeg"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">阿德里安·德尔福吉在<a class="ae iu" href="https://unsplash.com/s/photos/queue?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><h1 id="207e" class="iv iw hi bd ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js bi translated">基础知识</h1><p id="f5e3" class="pw-post-body-paragraph jt ju hi jv b jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq hb bi translated">队列是一种线性数据结构，它遵循访问元素的顺序。它非常类似于堆栈，但唯一的区别是队列两端都是开放的。一端用于添加元素，另一端用于删除元素。添加和删除元素的技术术语分别叫做<strong class="jv hj"> <em class="kr">入队</em> </strong>和<strong class="jv hj"> <em class="kr">出列，</em> </strong>。</p><figure class="kt ku kv kw fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ks"><img src="../Images/80a1d01035e27cde6f23bf31da42992a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pAUlSS9lDDOw9CToniavtQ.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">队列数据结构的简单说明。</figcaption></figure><p id="e0a6" class="pw-post-body-paragraph jt ju hi jv b jw kx jy jz ka ky kc kd ke kz kg kh ki la kk kl km lb ko kp kq hb bi translated">队列令人兴奋的部分是我们不能对队列中的每个元素进行操作。只有队列的前端和后端可以被访问或操作。</p><blockquote class="lc ld le"><p id="1aba" class="jt ju kr jv b jw kx jy jz ka ky kc kd lf kz kg kh lg la kk kl lh lb ko kp kq hb bi translated"><strong class="jv hj">问题:为什么我们不对队列的每个元素进行操作？<br/>答:</strong>如果我们可以对队列的每个元素进行操作，那么就没有队列点了。然后队列就变成了一个数组。在数组中，每个元素都可以被直接访问和操作。队列的应用不同于数组的应用(在本文中讨论)。</p></blockquote><p id="0841" class="pw-post-body-paragraph jt ju hi jv b jw kx jy jz ka ky kc kd ke kz kg kh ki la kk kl km lb ko kp kq hb bi translated">队列数据结构是先进先出(FIFO)数据结构。队列中的项按照插入的顺序进行检索。</p><blockquote class="lc ld le"><p id="2a7c" class="jt ju kr jv b jw kx jy jz ka ky kc kd lf kz kg kh lg la kk kl lh lb ko kp kq hb bi translated"><strong class="jv hj">注意:</strong>为了实现队列数据结构，我们可以使用数组、堆栈或链表。</p></blockquote><h1 id="1fdb" class="iv iw hi bd ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js bi translated">这些方法</h1><p id="cff6" class="pw-post-body-paragraph jt ju hi jv b jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq hb bi translated">队列使用这五种方法。</p><ol class=""><li id="6fce" class="li lj hi jv b jw kx ka ky ke lk ki ll km lm kq ln lo lp lq bi translated"><em class="kr"> enqueue() </em> —将元素添加到队列中</li><li id="cc49" class="li lj hi jv b jw lr ka ls ke lt ki lu km lv kq ln lo lp lq bi translated"><em class="kr"> dequeue() </em> —删除并返回队列中输入的第一个项目</li><li id="5140" class="li lj hi jv b jw lr ka ls ke lt ki lu km lv kq ln lo lp lq bi translated"><em class="kr"> isEmpty() </em> —根据队列是否为空返回真或假</li><li id="8411" class="li lj hi jv b jw lr ka ls ke lt ki lu km lv kq ln lo lp lq bi translated"><em class="kr"> front() </em> —返回队列的最前面的元素</li><li id="19ed" class="li lj hi jv b jw lr ka ls ke lt ki lu km lv kq ln lo lp lq bi translated"><em class="kr"> print() </em> —返回队列的所有元素</li></ol><blockquote class="lc ld le"><p id="5ff6" class="jt ju kr jv b jw kx jy jz ka ky kc kd lf kz kg kh lg la kk kl lh lb ko kp kq hb bi translated"><strong class="jv hj">注意</strong>:<em class="hi"/>print()函数只是返回队列中的所有元素。这不是一种直接访问队列中特定元素的方法。</p></blockquote><h1 id="dde6" class="iv iw hi bd ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js bi translated">详细的例子</h1><figure class="kt ku kv kw fd ij"><div class="bz dy l di"><div class="lw lx l"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">一个简短的连环画，给出了队列数据结构的基本概念。</figcaption></figure><p id="d32d" class="pw-post-body-paragraph jt ju hi jv b jw kx jy jz ka ky kc kd ke kz kg kh ki la kk kl km lb ko kp kq hb bi translated">现在，让我们稍微从技术上理解一下上面的漫画！</p><figure class="kt ku kv kw fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ly"><img src="../Images/66275ef1349f124f8f3290a44c7b9478.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PrQSuB4WxLY4PclkP0uyGQ.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">展示上面漫画中队列数据结构的插图。</figcaption></figure><p id="ac7e" class="pw-post-body-paragraph jt ju hi jv b jw kx jy jz ka ky kc kd ke kz kg kh ki la kk kl km lb ko kp kq hb bi translated">在上面的连环画中，有四个人在收银台等着买书。一旦第一个人支付了书款，他/她就退出队列(第一个元素出队)。因此，从原始队列(包含所有四个人)中，第一个元素出队，使第二个人成为队列中的第一个元素。类似地，当第二个人完成支付书籍时，他/她退出队列(出列)，之后第三个人成为队列中的第一个元素。如果另一个人加入队列，他/她将被添加到队列的顶部。</p><figure class="kt ku kv kw fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lz"><img src="../Images/5bfb9128363693dcf3ca11e1ecaedc6a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BG3ejkHr4gXtAgvBb4MPiA.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">显示队列数据结构中 enqueue()操作的图示。</figcaption></figure><p id="62c1" class="pw-post-body-paragraph jt ju hi jv b jw kx jy jz ka ky kc kd ke kz kg kh ki la kk kl km lb ko kp kq hb bi translated">这是对队列数据结构如何工作的简单解释。现在让我们了解一下队列的优点以及何时应该使用它们。</p><h1 id="3fd4" class="iv iw hi bd ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js bi translated">大 O 符号</h1><p id="a50a" class="pw-post-body-paragraph jt ju hi jv b jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq hb bi translated">根据队列数据结构理论，所有操作的时间复杂度应该是<strong class="jv hj"> <em class="kr"> O(1)。</em> </strong>对于不知道这是什么意思的人来说，<strong class="jv hj"> <em class="kr"> O(1) </em> </strong>是一个数据结构或者一个算法所能拥有的最高效的时间复杂度。<strong class="jv hj"> <em class="kr"> O(1) </em> </strong>告诉我们，即使队列中的元素数量增加，完成该操作所需的时间也将保持不变。</p><blockquote class="lc ld le"><p id="c5f0" class="jt ju kr jv b jw kx jy jz ka ky kc kd lf kz kg kh lg la kk kl lh lb ko kp kq hb bi translated"><strong class="jv hj">问题:为什么时间复杂度<em class="hi"> O(1) </em>？<br/>答:</strong>当我们在使用入队操作的时候，我们是在后面添加元素。不需要循环整个元素列表来完成操作。因此，时间复杂度为 O(1)。类似地，在出列操作中，您从前面移除元素，并且也没有必要循环所有元素；但是，当使用数组实现队列时，这种出队的复杂性会发生变化。</p><p id="beb1" class="jt ju kr jv b jw kx jy jz ka ky kc kd lf kz kg kh lg la kk kl lh lb ko kp kq hb bi translated"><strong class="jv hj">问题:使用数组实现时，队列的时间复杂度为什么会变化？<br/>答:</strong>在使用数组实现的队列中使用出列操作时，时间复杂度变为 O(N)。原因很简单。由于数组是基于索引的，所以每当从前面移除一个元素时，队列中的每个元素都应该移位一个值-1(每个元素的索引应该是元素的<strong class="jv hj">原始索引- 1 </strong> ) <strong class="jv hj">。</strong>因此，出列操作的时间复杂度发生变化。下图说明了同样的情况。</p><p id="1d68" class="jt ju kr jv b jw kx jy jz ka ky kc kd lf kz kg kh lg la kk kl lh lb ko kp kq hb bi translated">注意:上面的解释适用于我们使用数组实现队列的时候。如果我们使用链表来实现队列，那么入队和出队操作的时间复杂度是<strong class="jv hj"> O(1) </strong>。</p></blockquote><figure class="kt ku kv kw fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ma"><img src="../Images/87919cc9877fcf330d4b0fe7c6d3d091.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uCil-kSWW16uKp5q8qDXOg.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">使用数组实现的队列中的出列操作的图示。</figcaption></figure><h1 id="2119" class="iv iw hi bd ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js bi translated">队列数据结构的应用/用途</h1><p id="cfd5" class="pw-post-body-paragraph jt ju hi jv b jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq hb bi translated">队列数据结构有多种用例。一些涉及到先到先服务的事情可能会用到队列。一些实际应用包括:</p><ol class=""><li id="ae37" class="li lj hi jv b jw kx ka ky ke lk ki ll km lm kq ln lo lp lq bi translated">基于多人视频游戏/皇家战役的视频游戏</li><li id="2041" class="li lj hi jv b jw lr ka ls ke lt ki lu km lv kq ln lo lp lq bi translated">模拟实体队列，人们排队等候超市结账</li><li id="c21d" class="li lj hi jv b jw lr ka ls ke lt ki lu km lv kq ln lo lp lq bi translated">当通过互联网发送数据时，各种数据包在队列中等待发送。</li><li id="8ad3" class="li lj hi jv b jw lr ka ls ke lt ki lu km lv kq ln lo lp lq bi translated">响应请求的服务器。通常，这些请求存储在队列中。在这种情况下，遵循先来后到的政策。</li></ol></div><div class="ab cl mb mc gp md" role="separator"><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg"/></div><div class="hb hc hd he hf"><p id="233c" class="pw-post-body-paragraph jt ju hi jv b jw kx jy jz ka ky kc kd ke kz kg kh ki la kk kl km lb ko kp kq hb bi translated">我还有一篇文章是关于如何在 javascript 中使用数组实现队列数据结构的。这里可以看<a class="ae iu" href="https://meghagarwal.medium.com/implementing-the-queue-data-structure-using-an-array-in-javascript-a39bc2c8ca45" rel="noopener">。</a></p><p id="1caa" class="pw-post-body-paragraph jt ju hi jv b jw kx jy jz ka ky kc kd ke kz kg kh ki la kk kl km lb ko kp kq hb bi translated">如果你喜欢这篇文章，掌声会激励我继续写这样的文章:)</p></div></div>    
</body>
</html>