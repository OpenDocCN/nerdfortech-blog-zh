<html>
<head>
<title>Singleton design pattern in game development for creating managers — Part 1</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">游戏开发中创建经理的单例设计模式—第 1 部分</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/singleton-design-pattern-in-game-development-for-creating-managers-part-1-cf7a84b4217d?source=collection_archive---------2-----------------------#2021-10-26">https://medium.com/nerd-for-tech/singleton-design-pattern-in-game-development-for-creating-managers-part-1-cf7a84b4217d?source=collection_archive---------2-----------------------#2021-10-26</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/74615dc9e80784424cd094a8762a5511.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ScKSP4uOpZUbJUEJpKUjNA.png"/></div></div></figure><p id="ee7f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">本文解释了在多个管理器组件之间进行通信的困难方式，以及使用单体设计模式可以做些什么来使它变得更好。</p><p id="2834" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">游戏经理是一个非常基础的角色，在任何给定的游戏项目中都必须是对象。</p><p id="7c2e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">游戏管理器包含两个非常基本的方法。</p><ul class=""><li id="363b" class="jo jp hi is b it iu ix iy jb jq jf jr jj js jn jt ju jv jw bi translated">重新开始</li><li id="058b" class="jo jp hi is b it jx ix jy jb jz jf ka jj kb jn jt ju jv jw bi translated">放弃</li></ul><p id="02c8" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">下面是这两种方法在游戏管理器中的简单实现。</p><figure class="kd ke kf kg fd ij er es paragraph-image"><div class="er es kc"><img src="../Images/e54fcab10aac6ea26ae944b9ef649d26.png" data-original-src="https://miro.medium.com/v2/resize:fit:630/format:webp/1*pvkerna6jAaY05KJcM_WjA.png"/></div><figcaption class="kh ki et er es kj kk bd b be z dx translated">C#</figcaption></figure><p id="c2b4" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi kl translated">如果另一个游戏对象希望调用这两个方法中的任何一个，那么这个对象必须首先获得对这个游戏管理器的引用，创建一个本地实例，然后调用它们。</p><p id="e872" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">那么，问题是什么？</p><p id="0760" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">想象多个对象出于某种原因希望使用这两种方法。这需要在它们各自的脚本组件中创建游戏管理器对象的多个实例。</strong></p><p id="a2b2" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在更大的环境中，这种方法会导致内存滥用，以及在涉及到要更改的数据的情况下没有同步的操作流。</p><p id="3b37" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">那么，单例设计模式在这里有什么帮助呢？</p><blockquote class="ku kv kw"><p id="0574" class="iq ir kx is b it iu iv iw ix iy iz ja ky jc jd je kz jg jh ji la jk jl jm jn hb bi translated">单例模式通过在脚本本身中创建一个实例，并且不允许任何其他对象创建任何进一步的实例，从而消除了多个实例。</p><p id="8b05" class="iq ir kx is b it iu iv iw ix iy iz ja ky jc jd je kz jg jh ji la jk jl jm jn hb bi translated">相反，它强制所有对象访问 singleton 类的唯一实例。</p></blockquote><p id="e168" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">下面是一个简单的单人游戏管理器的实现。</p><figure class="kd ke kf kg fd ij er es paragraph-image"><div class="er es lb"><img src="../Images/a473418ed04aea23b682c6d6aeaca5bc.png" data-original-src="https://miro.medium.com/v2/resize:fit:898/format:webp/1*EAzcyPdztdUWOIPt8wE-Bg.png"/></div><figcaption class="kh ki et er es kj kk bd b be z dx translated">C#</figcaption></figure><ul class=""><li id="b2b4" class="jo jp hi is b it iu ix iy jb jq jf jr jj js jn jt ju jv jw bi translated">有一个名为“_instance”的私有静态变量，它是一个游戏管理器类本身的对象。无论哪个对象要保存这个脚本，它都会有这个对象。</li><li id="60cb" class="jo jp hi is b it jx ix jy jb jz jf ka jj kb jn jt ju jv jw bi translated">有一个公共属性来获取这个实例(也可以有一个集合)。这里的 get 方法是检查游戏管理器是否连接到某个对象。如果没有对象持有这个实例，任何其他对象试图访问游戏管理器将导致空引用异常。因此，空检查将确保异常不会发生。</li><li id="a62b" class="jo jp hi is b it jx ix jy jb jz jf ka jj kb jn jt ju jv jw bi translated">有一个唤醒方法调用，它总是由引擎在启动和更新方法之前调用。在唤醒调用中，管理器获得对 _ 实例的引用。</li></ul><p id="6e1e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">是时候看看差别了:)</strong></p><p id="649a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">例如，游戏管理器有一个名为 playerHasCard 的变量。</p><figure class="kd ke kf kg fd ij er es paragraph-image"><div class="er es lc"><img src="../Images/5e297c2c35536170adf1c68b917de2b6.png" data-original-src="https://miro.medium.com/v2/resize:fit:960/format:webp/1*eV4kl_nh-9samB_fzYtWYw.png"/></div><figcaption class="kh ki et er es kj kk bd b be z dx translated">C#</figcaption></figure><p id="805d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如果另一个脚本打算使用这个变量属性来触发某个事件，它可以直接使用该变量，而无需创建本地实例。</p><figure class="kd ke kf kg fd ij er es paragraph-image"><div class="er es ld"><img src="../Images/56b3ccdc088b0cb25a42b32f8990a179.png" data-original-src="https://miro.medium.com/v2/resize:fit:938/format:webp/1*71FqSd5zBSaJl0Q3LrYcFA.png"/></div><figcaption class="kh ki et er es kj kk bd b be z dx translated">C#</figcaption></figure><h2 id="90e4" class="le lf hi bd lg lh li lj lk ll lm ln lo jb lp lq lr jf ls lt lu jj lv lw lx ly bi translated">但是旗帜在哪里树立呢？</h2><h2 id="4b48" class="le lf hi bd lg lh li lj lk ll lm ln lo jb lp lq lr jf ls lt lu jj lv lw lx ly bi translated">在另一个脚本中使用相同的方法。</h2><figure class="kd ke kf kg fd ij er es paragraph-image"><div class="er es lz"><img src="../Images/1f7c47547787167a146600c79745fe46.png" data-original-src="https://miro.medium.com/v2/resize:fit:904/format:webp/1*BnGq2OWifjtXQSOcAlPidg.png"/></div><figcaption class="kh ki et er es kj kk bd b be z dx translated">C#</figcaption></figure><p id="abe0" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在这两个脚本中，没有游戏管理器对象的本地实例。相反，它们都使用相同的属性。</p><p id="c6ae" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">那就是单体设计:)</p><p id="0425" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">非常感谢</p></div></div>    
</body>
</html>