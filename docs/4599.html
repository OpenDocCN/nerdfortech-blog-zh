<html>
<head>
<title>INTEGER NUMBER FAMILIES THE NEXT GENERATION</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">整数家族的下一代</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/integer-number-families-the-next-generation-3f298d347b5c?source=collection_archive---------10-----------------------#2021-07-28">https://medium.com/nerd-for-tech/integer-number-families-the-next-generation-3f298d347b5c?source=collection_archive---------10-----------------------#2021-07-28</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="3f16" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated"><strong class="ak">第四部分:整数因式分解的基础知识</strong></h2></div><pre class="ix iy iz ja fd jb jc jd je aw jf bi"><span id="c073" class="jg jh hi jc b fi ji jj l jk jl"><em class="jm">Sometimes it is not what you see that is important,<br/>It is what you do not see.</em></span></pre><figure class="ix iy iz ja fd jo er es paragraph-image"><div class="er es jn"><img src="../Images/0de29a086e0763b492f3c230b90c1a4c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1152/format:webp/1*AfXGJjagpNEd2UQ2MTjMwg.jpeg"/></div><figcaption class="jr js et er es jt ju bd b be z dx translated">禁区和有效的保理行</figcaption></figure><p id="f277" class="pw-post-body-paragraph jv jw hi jx b jy jz ij ka kb kc im kd ke kf kg kh ki kj kk kl km kn ko kp kq hb bi translated"><strong class="jx hj">前言</strong></p><p id="b1ea" class="pw-post-body-paragraph jv jw hi jx b jy jz ij ka kb kc im kd ke kf kg kh ki kj kk kl km kn ko kp kq hb bi translated"><strong class="jx hj">整数因式分解族</strong>还有别的层次吗？答案是肯定的，但这可能不是你所期望的。有些音程可以去掉；然而，开销计算将成比例增长。(表现出惊讶。)请坐好，享受另一次进入数学疯狂王国的旅程！(顺便说一句，请原谅标题中的双关语，我就是忍不住。)</p><p id="966b" class="pw-post-body-paragraph jv jw hi jx b jy jz ij ka kb kc im kd ke kf kg kh ki kj kk kl km kn ko kp kq hb bi translated">本文是“整数分解基础”系列文章的一部分。如果您查看我的<a class="ae kr" href="https://jbjo1956.medium.com/about" rel="noopener">关于</a>的数据，可以看到所有其他文章的列表。</p><p id="ffee" class="pw-post-body-paragraph jv jw hi jx b jy jz ij ka kb kc im kd ke kf kg kh ki kj kk kl km kn ko kp kq hb bi translated"><strong class="jx hj">第 1 章—背景</strong></p><p id="7484" class="pw-post-body-paragraph jv jw hi jx b jy jz ij ka kb kc im kd ke kf kg kh ki kj kk kl km kn ko kp kq hb bi translated"><strong class="jx hj">整数因子分解族</strong>的基础知识在以下网址讨论:</p><p id="2986" class="pw-post-body-paragraph jv jw hi jx b jy jz ij ka kb kc im kd ke kf kg kh ki kj kk kl km kn ko kp kq hb bi translated"><a class="ae kr" href="https://jbjo1956.medium.com/introduction-to-integer-factoring-families-dce2152fba81?source=friends_link&amp;sk=382a4fef0eac9c47673c550db9560761" rel="noopener">https://jbjo 1956 . medium . com/introduction-to-integer-factoring-families-DCE 2152 FBA 81？source = friends _ link&amp;sk = 382 a4 fef 0 EAC 9 c 47673 c 550 db 9560761</a></p><p id="fab4" class="pw-post-body-paragraph jv jw hi jx b jy jz ij ka kb kc im kd ke kf kg kh ki kj kk kl km kn ko kp kq hb bi translated">这里是对材料的回顾。(周二小考……)</p><p id="d7f8" class="pw-post-body-paragraph jv jw hi jx b jy jz ij ka kb kc im kd ke kf kg kh ki kj kk kl km kn ko kp kq hb bi translated">迭代整数分解的主要引擎是<strong class="jx hj">费马因式分解方法</strong>。</p><p id="f822" class="pw-post-body-paragraph jv jw hi jx b jy jz ij ka kb kc im kd ke kf kg kh ki kj kk kl km kn ko kp kq hb bi translated"><a class="ae kr" href="https://en.wikipedia.org/wiki/Fermat's_factorization_method" rel="noopener ugc nofollow" target="_blank">https://en.wikipedia.org/wiki/Fermat's_factorization_method</a></p><p id="f13a" class="pw-post-body-paragraph jv jw hi jx b jy jz ij ka kb kc im kd ke kf kg kh ki kj kk kl km kn ko kp kq hb bi translated">这种方法不使用筛子，并根据以下方程计算:<em class="jm">N = An Bn</em>=<em class="jm">(An+Bn)(An Bn)，</em>其中<em class="jm"> (N) </em>是被调查的数字。(数学定义见<strong class="jx hj">附录 1 </strong>)的初始值<em class="jm"> (An) </em>为<em class="jm"> √N </em>上舍入。反向计算:<em class="jm">Bn =√【An N】</em>；如果<em class="jm"> (Bn) </em>不是整数，则需要下一次迭代。每次迭代将通过将<em class="jm"> (An) </em>加 1 来执行。这种情况会持续下去，直到找到一个整数，或者<em class="jm">(An Bn)</em>的值降至 3(最小的可能奇素数)以下。</p><p id="2b84" class="pw-post-body-paragraph jv jw hi jx b jy jz ij ka kb kc im kd ke kf kg kh ki kj kk kl km kn ko kp kq hb bi translated">一个典型的家庭，其中<em class="jm"> An = 25 </em>看起来是这样的:</p><pre class="ix iy iz ja fd jb jc jd je aw jf bi"><span id="9edd" class="jg jh hi jc b fi ji jj l jk jl">An/Bn: N=Xn×Yn=An^2–Bn^2: Si+6Sn=(Sa+6Sx)(Sb+6Sy): Drop=625–N<br/>--------------------------------------------------------------------<br/>25/0:  625=25×25=625–0:   7+6×103=(7+6×3)(7+6×3):  Drop=0<br/>25/6:  589=19×31=625–36:  7+6×97=(7+6×2)(7+6×4):   Drop=36<br/>25/12: 481=13×37=625–144: 7+6×79=(7+6×1)(7+6×5):   Drop=144<br/>25/18: 301=7×43=625–324:  7+6×49=(7+6×0)(7+6×6):   Drop=324<br/>25/24:  49=1×49=625–576:  7+6×7=(7+6×(-1))(7+6×7): Drop=576</span></pre><p id="8f61" class="pw-post-body-paragraph jv jw hi jx b jy jz ij ka kb kc im kd ke kf kg kh ki kj kk kl km kn ko kp kq hb bi translated"><strong class="jx hj">下降</strong>是家族的<em class="jm"> (N) </em>和<strong class="jx hj">顶值</strong>之差，在本例中为<em class="jm"> 625 </em>。下降的重要方面是这个家族中的所有因子都有可被<em class="jm"> 36 </em>整除的下降，例如<strong class="jx hj">下降</strong>在<em class="jm"> 576 </em>模<em class="jm"> 36 </em>是<em class="jm"> 0 </em>。因此，如果任何一个数和<em class="jm"> 625 </em>的差能被<em class="jm"> 36 </em>整除，那么这个数<strong class="jx hj">可能属于<em class="jm">族=25 </em>。尽管有很多例外，但是<strong class="jx hj">下降</strong>也必须遵循<strong class="jx hj">下降顺序</strong>。对于<em class="jm">族=25，</em>顺序为<em class="jm"> 1×36，4×36，9×36，</em>和<em class="jm"> 16×36 </em>。由于<em class="jm"> 72 </em>为<em class="jm"> 2×36 </em>，故排除。</strong></p><p id="e957" class="pw-post-body-paragraph jv jw hi jx b jy jz ij ka kb kc im kd ke kf kg kh ki kj kk kl km kn ko kp kq hb bi translated">每个<strong class="jx hj">家族</strong>只支持一个<strong class="jx hj">系列</strong>。在观察中发现<strong class="jx hj">因子系列</strong>的来源，除了质数 2 和 3，所有其他质数都在可被 6 整除的数字附近，例如质数 5 和 7 在数字 6 旁边。<em class="jm"> (N) </em>可以属于两个系列。在<em class="jm">系列= 5，Si = 5，N = 5+6×Sn </em>和<em class="jm"> Sn = </em> { <em class="jm"> 0，1，2，3，… </em> } <em class="jm"> </em>中<em class="jm">系列= 5 </em>的例子有<em class="jm"> N = 5，11，</em>和<em class="jm"> 17 </em>。在<em class="jm">级数= 7，Si = 7，N = 7+6×Sn </em>和<em class="jm"> Sn = </em> { <em class="jm"> -1，0，1，2，3，… </em> } <em class="jm"> </em>中<em class="jm">级数= 7 </em>的例子有<em class="jm"> N = 1、</em> <em class="jm"> 7、13、</em>和<em class="jm"> 19。</em> ( <em class="jm">系列= 2 </em>和<em class="jm">系列= 3 </em>是存在的，但是会被排除在这篇短文之外，因为他们有自己的家谱。)</p><p id="d01e" class="pw-post-body-paragraph jv jw hi jx b jy jz ij ka kb kc im kd ke kf kg kh ki kj kk kl km kn ko kp kq hb bi translated">这两个系列可能会产生三种产品。</p><pre class="ix iy iz ja fd jb jc jd je aw jf bi"><span id="9fb6" class="jg jh hi jc b fi ji jj l jk jl">(1) First, a <em class="jm">Series = 5 </em>times a <em class="jm">Series = 7 </em>yields a<em class="jm"> Series = 5.<br/>   </em> There are two subsets:<br/>  (a) <em class="jm">Series = 5 </em>times a <em class="jm">Series = 7 </em>yields <em class="jm">Series = 5A,<br/>      </em>Example: <em class="jm">35 = 5×7 </em>or <br/>  (b) <em class="jm">Series = 7 </em>times a <em class="jm">Series = 5 </em>yields <em class="jm">Series = 5B,<br/>      </em>Example: 77<em class="jm"> = 7×11.<br/></em>(2) Second, a <em class="jm">Series = 7 </em>times a <em class="jm">Series = 7 </em>yields a<em class="jm"> Series = 7,<br/>    </em>Example: <em class="jm">4</em>9<em class="jm"> = 7×7.<br/></em>(3) And finally a <em class="jm">Series = 5 </em>times a <em class="jm">Series = 5 </em>yields a<em class="jm"> Series = 7,<br/>    </em>Example: <em class="jm">25 = 5×5.</em></span></pre><p id="2878" class="pw-post-body-paragraph jv jw hi jx b jy jz ij ka kb kc im kd ke kf kg kh ki kj kk kl km kn ko kp kq hb bi translated">根据<em class="jm"> (An) </em>的值有三组族，其中<em class="jm">组= An mod 3。</em>分别是<em class="jm">组= </em> <em class="jm"> 0，1，</em>和<em class="jm"> 2。</em></p><pre class="ix iy iz ja fd jb jc jd je aw jf bi"><span id="7806" class="jg jh hi jc b fi ji jj l jk jl">(1) If <em class="jm">Group =</em> <em class="jm">0 (An mod 3 = 0),</em> then the entire family is<br/>    <em class="jm">Series = 5 </em>from the product of <em class="jm">Series = 5 </em>times<em class="jm"> Series = 7</em> or<br/>    <em class="jm">Series = 7 </em>times<em class="jm"> Series = 5. <br/></em>(2) If <em class="jm">Group =</em> <em class="jm">1 (An mod 3 = 1),</em> then the entire family is<br/>    <em class="jm">Series = 7</em> from the product of <em class="jm">Series = 7 </em>times<em class="jm"> Series = 7.<br/></em>(3) If <em class="jm">Group =</em> <em class="jm">2 (An mod 3 = 2),</em> then the entire family is <br/>    <em class="jm">Series = 7</em> from the product of <em class="jm">Series = 5 </em>times<em class="jm"> Series = 5.</em></span></pre><p id="ee25" class="pw-post-body-paragraph jv jw hi jx b jy jz ij ka kb kc im kd ke kf kg kh ki kj kk kl km kn ko kp kq hb bi translated">回到<em class="jm"> Family=25，</em>我们发现<em class="jm"> 25 mod 3 = 1，</em>所以是<em class="jm"> Group=1 </em>，将只支持<em class="jm"> Series = 7，</em>例如<em class="jm"> 7+6×103=(7+6×3)(7+6×3)。</em>下一个支持<em class="jm">系列= 7 </em>的家族是<em class="jm">组= 2</em>at<em class="jm">An = An+1 = 25+1；</em> <em class="jm">家族=26。</em></p><pre class="ix iy iz ja fd jb jc jd je aw jf bi"><span id="f21f" class="jg jh hi jc b fi ji jj l jk jl">An/Bn: N=Xn×Yn=An^2–Bn^2: Si+6Sn=(Sa+6Sx)(Sb+6Sy): Drop=625–N<br/>--------------------------------------------------------------------26/3:  667=23×29=676–9:   7+6×110=(5+6×3)(5+6×4):  Drop=0<br/>26/9:  595=17×35=676–81:  7+6×98=(5+6×2)(5+6×5):   Drop=72<br/>26/15: 451=11×41=676–225: 7+6×74=(5+6×1)(5+6×6):   Drop=216<br/>26/21: 235=5×47=676–441:  7+6×38=(5+6×0)(5+6×7):   Drop=432</span></pre><p id="744f" class="pw-post-body-paragraph jv jw hi jx b jy jz ij ka kb kc im kd ke kf kg kh ki kj kk kl km kn ko kp kq hb bi translated"><em class="jm">系列=7 </em>不变，但<strong class="jx hj">公因数</strong>变为<em class="jm"> 72 </em>。新家庭的准入现在由 N mod 72 = 0 决定。这里的教训是，如果您正在评估一个<em class="jm">系列=7 </em>号<em class="jm">，</em>，您必须检查<em class="jm">组=1 </em>中的每个家族和<em class="jm">组=2 中的每个家族。</em>我们可以跳过<em class="jm">An = An+1 = 26+1；</em> <em class="jm">族=27，</em>因为是<em class="jm">组= </em> <em class="jm"> 0 (An mod 3 = 0)。</em>下一个支持<em class="jm">系列= 7 </em>的家族是<em class="jm">组= 1</em>at<em class="jm">An = An+1 = 27+1；</em> <em class="jm">家族=28。</em></p><pre class="ix iy iz ja fd jb jc jd je aw jf bi"><span id="088c" class="jg jh hi jc b fi ji jj l jk jl">An/Bn: N=Xn×Yn=An^2–Bn^2: Si+6Sn=(Sa+6Sx)(Sb+6Sy): Drop=625–N<br/>--------------------------------------------------------------------<br/>28/3:  775=25×31=784–9:   7+6×128=(7+6×3)(7+6×4):  Drop=0<br/>28/9:  703=19×37=784–81:  7+6×116=(7+6×2)(7+6×5):  Drop=72<br/>28/15: 559=13×43=784–225: 7+6×92=(7+6×1)(7+6×6):   Drop=216<br/>28/21: 343=7×49=784–441:  7+6×56=(7+6×0)(7+6×7):   Drop=432<br/>28/27:  55=1×55=784–729:  7+6×8=(7+6×(-1))(7+6×8): Drop=720</span></pre><p id="19c4" class="pw-post-body-paragraph jv jw hi jx b jy jz ij ka kb kc im kd ke kf kg kh ki kj kk kl km kn ko kp kq hb bi translated">现在我们有了一个<em class="jm">组=1 </em>和一个<strong class="jx hj">公因数</strong>的<em class="jm"> 72。</em>看来<em class="jm">(安)</em>是<em class="jm">奇数</em>，<em class="jm">(安)</em>是<em class="jm">偶数</em>之间出现了反转。这就要求我们现在根据<em class="jm"> (An) </em>的值是奇数还是偶数，每组有两种口味。这里的教训是，你必须检查每个<em class="jm">组=1(偶数)，每个</em>组=1(奇数)，每个组=2(偶数)，每个组=2(奇数)。如果在这一点上，这一程序的好处还不明显，深呼吸，当你盯着食谱时，你不能吃蛋糕。最好的解决方案是采取不同的路径，分别通过所有的<em class="jm">偶数</em>和所有的<em class="jm">奇数</em>组。从统计上来说，你会在不追第二组的情况下，找到 50% 的解。</p><p id="ba78" class="pw-post-body-paragraph jv jw hi jx b jy jz ij ka kb kc im kd ke kf kg kh ki kj kk kl km kn ko kp kq hb bi translated"><strong class="jx hj">第 2 章——基本因子分解迭代</strong></p><p id="0293" class="pw-post-body-paragraph jv jw hi jx b jy jz ij ka kb kc im kd ke kf kg kh ki kj kk kl km kn ko kp kq hb bi translated">是时候实际评估一个数了:<em class="jm"> N = 37×967 = 35779 </em>其中<em class="jm"> 35779 mod 6 = 1，</em>所以<em class="jm">系列=7。</em><em class="jm">An 的初始值= √[N] = √[35779] = 189.153(上舍入)= 190。</em>由于<em class="jm"> 190 mod 3 = 1 </em>支持<em class="jm">系列=7 </em>，无需调整。</p><p id="1101" class="pw-post-body-paragraph jv jw hi jx b jy jz ij ka kb kc im kd ke kf kg kh ki kj kk kl km kn ko kp kq hb bi translated">我们在<em class="jm">组= 1 </em>和<em class="jm">组= 2 </em>之间有一个选择。当我们对<em class="jm">组= 1，</em>的<em class="jm"> (An) </em>的值进行同步时，我们会发现<em class="jm"> An = 214 </em>是最合适的。在这个过程中，我们消除了路径中的<em class="jm"> An = Odd。</em>(既然我已经算出了问题，我知道我们会在<em class="jm"> Group = 1，</em>中找到解决方案，所以这次我们可以忽略<em class="jm"> Group = 2 </em>解决方案。)</p><p id="66a8" class="pw-post-body-paragraph jv jw hi jx b jy jz ij ka kb kc im kd ke kf kg kh ki kj kk kl km kn ko kp kq hb bi translated">我们现在运行<em class="jm"> (An) </em>的增量，增量等于<strong class="jx hj">公因数</strong>除以<em class="jm"> 2 </em>。在这种情况下，即<em class="jm"> 72/2=36 </em>。执行迭代，我们直到第 9 次尝试才会找到解决方案，结果是<em class="jm"> An = 502。</em></p><figure class="ix iy iz ja fd jo er es paragraph-image"><div class="er es ks"><img src="../Images/0bd315f2febb8a3000d47715395cdd50.png" data-original-src="https://miro.medium.com/v2/resize:fit:1012/format:webp/1*TNhxl28ap6Uci2gzrIku0w.jpeg"/></div><figcaption class="jr js et er es jt ju bd b be z dx translated"><strong class="bd kt">页面费马迭代块</strong></figcaption></figure><p id="30a6" class="pw-post-body-paragraph jv jw hi jx b jy jz ij ka kb kc im kd ke kf kg kh ki kj kk kl km kn ko kp kq hb bi translated">跳过一些这样的迭代不是很好吗？嗯，实际上，我刚做了。你只是不能从你的角度看到整个表格，但我会尝试解释。看到<em class="jm">列【U】中的<em class="jm">“+”</em>符号了吗？</em>他们告诉我们可以完全跳过<em class="jm"> (An) </em>的这些值。</p><p id="40e7" class="pw-post-body-paragraph jv jw hi jx b jy jz ij ka kb kc im kd ke kf kg kh ki kj kk kl km kn ko kp kq hb bi translated">也许你已经注意到这个<strong class="jx hj">费马迭代块</strong>与以前的版本不同。这个版本基于<strong class="jx hj">全费马矩阵</strong>。在这个版本中，矩阵主干是包含<em class="jm"> (Bn) </em>的值的<em class="jm">列【X】</em>。事实上，在长格式的<em class="jm">列中【X】</em>包含了<em class="jm"> (Bn) </em>的每个值，我们可以在包含<em class="jm"> (N) </em>的最后一个家族中找到这些值。最后一家有<em class="jm"> Xn=1 </em>和<em class="jm"> Yn=N，</em>所以<em class="jm"> An=(Yn+Xn)/2 </em>和<em class="jm"> Bn=(Yn-Xn)/2。</em>在我们的例子中<em class="jm"> N=35779，</em>所以<em class="jm">Xn = 1；Yn = 35779An = 17890</em>和<em class="jm"> Bn=17889。</em><strong class="jx hj">全费马矩阵</strong>从<em class="jm"> An=214 </em>开始，有<em class="jm"> 17889 </em>行，每一行对应<em class="jm">(Bn)</em>的一个值，一直持续到达到值<em class="jm"> An=17890 </em>为止。当<em class="jm"> Xn×Yn &lt; =N 时，<em class="jm"> (An) </em>的值递增；</em>但是，<em class="jm"> (Bn) </em>的值会不间断地持续到最后。(我知道……这本身就是一篇论文，但我就是没有时间。)</p><p id="70e2" class="pw-post-body-paragraph jv jw hi jx b jy jz ij ka kb kc im kd ke kf kg kh ki kj kk kl km kn ko kp kq hb bi translated">如果我们选择不显示每一行，下一个列的<strong class="jx hj">显示了对<em class="jm"> (Bn) </em>的调整。方程为:<em class="jm">Z =(X N-Y N)/12√[(Y N-X N)/4+X nY N]/6。</em>随后的<em class="jm"> Bn=Bn + 6×Z. </em>如果您更喜欢看到所有近 18K 行，这可以省略，<em class="jm"> Bn=Bn + 6 </em>。</strong></p><p id="46bc" class="pw-post-body-paragraph jv jw hi jx b jy jz ij ka kb kc im kd ke kf kg kh ki kj kk kl km kn ko kp kq hb bi translated"><strong class="jx hj">第 3 章——基本保理对准</strong></p><p id="9edf" class="pw-post-body-paragraph jv jw hi jx b jy jz ij ka kb kc im kd ke kf kg kh ki kj kk kl km kn ko kp kq hb bi translated">原来有一个对齐段会显示<em class="jm"> (An) </em>的哪些值可以跳过。</p><figure class="ix iy iz ja fd jo er es paragraph-image"><div class="er es jn"><img src="../Images/0de29a086e0763b492f3c230b90c1a4c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1152/format:webp/1*AfXGJjagpNEd2UQ2MTjMwg.jpeg"/></div><figcaption class="jr js et er es jt ju bd b be z dx translated"><strong class="bd kt">页面纸张对齐块</strong></figcaption></figure><p id="aec3" class="pw-post-body-paragraph jv jw hi jx b jy jz ij ka kb kc im kd ke kf kg kh ki kj kk kl km kn ko kp kq hb bi translated">解释起来很容易。如果校准块中的线有一个“X”，那么与之相关的<em class="jm"> (An) </em>的值可以跳过，并且不需要执行平方根的验证。如果没有找到“X ”,则必须进行验证。如您所见，可以跳过相当多的行。</p><p id="7863" class="pw-post-body-paragraph jv jw hi jx b jy jz ij ka kb kc im kd ke kf kg kh ki kj kk kl km kn ko kp kq hb bi translated">"数学恶魔在做什么？"你可能会问。这需要更多的解释。</p><p id="d034" class="pw-post-body-paragraph jv jw hi jx b jy jz ij ka kb kc im kd ke kf kg kh ki kj kk kl km kn ko kp kq hb bi translated"><strong class="jx hj">第 4 章——下落对准</strong></p><p id="6781" class="pw-post-body-paragraph jv jw hi jx b jy jz ij ka kb kc im kd ke kf kg kh ki kj kk kl km kn ko kp kq hb bi translated">还记得上面<strong class="jx hj">家族图</strong>中的那些点滴吗？从<em class="jm"> (Bn) </em>的值可以容易地计算出压降。适当的<em class="jm">Drop = Bn Top Bn</em>其中<em class="jm"> (Bn) </em>的值取决于<em class="jm"> (An) </em>是奇数还是偶数。</p><p id="8c41" class="pw-post-body-paragraph jv jw hi jx b jy jz ij ka kb kc im kd ke kf kg kh ki kj kk kl km kn ko kp kq hb bi translated">取这些液滴，并通过除以公因数<strong class="jx hj">将其归一化，公因数</strong>在本例中为<em class="jm"> 72 </em>。归一化的序列将是{0，1，3，6，10，…}然后对这些执行各种除法，例如<em class="jm"> Cell[BA6]=10，</em>所以<em class="jm">Cell[BH6]= Cell[BA6]mod Cell[BH1]= 10 mod 7 = 3。整个事情看起来是这样的:</em></p><figure class="ix iy iz ja fd jo er es paragraph-image"><div class="er es ku"><img src="../Images/054be2ece1f99fe2ed64e1c3c4ed7b26.png" data-original-src="https://miro.medium.com/v2/resize:fit:852/format:webp/1*r_i9e4ljYghoR7OyWKLhVQ.jpeg"/></div><figcaption class="jr js et er es jt ju bd b be z dx translated"><strong class="bd kt">页面纸张下降正常化块</strong></figcaption></figure><p id="f0eb" class="pw-post-body-paragraph jv jw hi jx b jy jz ij ka kb kc im kd ke kf kg kh ki kj kk kl km kn ko kp kq hb bi translated">最有趣的一点是，所有的序列都是重复的，并且重复块的深度与除数相同。请注意，这些约数只是我为了测试目的而收集起来的一些，除了你的电子表格可以处理的以外，没有上限。第二个最有趣的方面是序列中有缺失的数字，例如在除数<em class="jm"> "3" </em>下，我们得到序列<em class="jm"> "0:1:0。"</em>没有编号<em class="jm">“2。”</em><em class="jm">【5】</em>缺少<em class="jm">【2】</em><em class="jm">【4】。</em></p><p id="9f26" class="pw-post-body-paragraph jv jw hi jx b jy jz ij ka kb kc im kd ke kf kg kh ki kj kk kl km kn ko kp kq hb bi translated">我们如何识别缺失的数字？</p><figure class="ix iy iz ja fd jo er es paragraph-image"><div class="er es kv"><img src="../Images/41f6bbfac35dd6f8b68bb6a61194f36b.png" data-original-src="https://miro.medium.com/v2/resize:fit:748/format:webp/1*1hqPjiohWg2rMQE6j5fKbQ.jpeg"/></div><figcaption class="jr js et er es jt ju bd b be z dx translated"><strong class="bd kt">页纸缺失值块</strong></figcaption></figure><p id="ba21" class="pw-post-body-paragraph jv jw hi jx b jy jz ij ka kb kc im kd ke kf kg kh ki kj kk kl km kn ko kp kq hb bi translated">这个插图有点混乱。为了找到一个丢失的数字，电子表格查看列<em class="jm">“F”</em>中的期望值，并在<strong class="jx hj">下降标准化块</strong>中搜索该值。如果找到该数字，它会显示为指针，例如<em class="jm">【0】</em>位于<em class="jm">【1】</em>处，而<em class="jm">【1】</em>位于<em class="jm">【2】处</em>如果没有找到号码，则在列中输入一个<em class="jm">“X”</em>，例如<em class="jm">单元格[BV4]= If(＄F4&lt;BV $ 1)，IFNA(MATCH(＄F4，BI$2:BI$33，0)，“X”)，“”)= 5 </em>。</p><p id="a209" class="pw-post-body-paragraph jv jw hi jx b jy jz ij ka kb kc im kd ke kf kg kh ki kj kk kl km kn ko kp kq hb bi translated">现在，我们使用<em class="jm"> (An) </em>和<em class="jm"> (N) </em>产生的实际液滴来重复这一过程。</p><figure class="ix iy iz ja fd jo er es paragraph-image"><div class="er es kw"><img src="../Images/a3d97db226954748261e19546792721d.png" data-original-src="https://miro.medium.com/v2/resize:fit:802/format:webp/1*GGatSvT7XVI_lHz-TuoXhg.jpeg"/></div><figcaption class="jr js et er es jt ju bd b be z dx translated"><strong class="bd kt">页面纸张实际下降标准化块</strong></figcaption></figure><p id="d13e" class="pw-post-body-paragraph jv jw hi jx b jy jz ij ka kb kc im kd ke kf kg kh ki kj kk kl km kn ko kp kq hb bi translated">该模块类似于上面的<strong class="jx hj">页面下降标准化模块</strong>。同样，所有序列重复，重复块的深度与除数相同，我们使用上面的除数。序列中有缺失的数字，但这次我们对它们不感兴趣。我们想知道的是<strong class="jx hj">页面缺失值块</strong>中是否有任何数字缺失。如果它们是，那么我们不能对齐块中的数据。我们可以跳过<em class="jm"> (An) </em>的这些值。</p><p id="97eb" class="pw-post-body-paragraph jv jw hi jx b jy jz ij ka kb kc im kd ke kf kg kh ki kj kk kl km kn ko kp kq hb bi translated">最后，最后一个数据块。我们交换出不匹配的值，并用<em class="jm">“X”</em>替换它们。</p><figure class="ix iy iz ja fd jo er es paragraph-image"><div class="er es kx"><img src="../Images/c2585a88e52672a4c1a71ea5a0c098c4.png" data-original-src="https://miro.medium.com/v2/resize:fit:616/format:webp/1*8mRGjXj9V9NO9teKQl1N6Q.jpeg"/></div><figcaption class="jr js et er es jt ju bd b be z dx translated"><strong class="bd kt">页面纸张复合对齐块</strong></figcaption></figure><p id="bcb5" class="pw-post-body-paragraph jv jw hi jx b jy jz ij ka kb kc im kd ke kf kg kh ki kj kk kl km kn ko kp kq hb bi translated">眼熟吗？没有红色突出显示的是原来的<strong class="jx hj">定位块</strong>。事实上，我们最初看到的只是这个块的循环表查找，例如<em class="jm"> Cell[AP11] =INDEX(CU$2:CU$6，IF(MOD($AE11，AP$1)=0，AP$1，MOD($AE11，AP $ 1))= 3。</em>对了，<em class="jm">单元格【AE11】= 9。</em> <em class="jm">列【AE】</em>(未显示)是一个修改过的计数器，允许移位，但那是另一天的事了。</p><p id="d21a" class="pw-post-body-paragraph jv jw hi jx b jy jz ij ka kb kc im kd ke kf kg kh ki kj kk kl km kn ko kp kq hb bi translated">对于那些真正理解这一切的人来说，你可能会想，“找到每个<em class="jm"> (An) </em>处的压降，并对照<em class="jm"> (Bn) </em>处的压降值进行验证，不是更容易吗？”这将是一个有效的程序，除非我的国际象棋拼图网站不断提醒我，“有一个更好的移动。”</p><p id="e1f5" class="pw-post-body-paragraph jv jw hi jx b jy jz ij ka kb kc im kd ke kf kg kh ki kj kk kl km kn ko kp kq hb bi translated"><a class="ae kr" href="https://chesspuzzle.net/" rel="noopener ugc nofollow" target="_blank">https://chesspuzzle.net/</a></p><p id="597c" class="pw-post-body-paragraph jv jw hi jx b jy jz ij ka kb kc im kd ke kf kg kh ki kj kk kl km kn ko kp kq hb bi translated"><strong class="jx hj">第 5 章—质数中断</strong></p><p id="a5a5" class="pw-post-body-paragraph jv jw hi jx b jy jz ij ka kb kc im kd ke kf kg kh ki kj kk kl km kn ko kp kq hb bi translated">糟糕，我差点忘了包括一个关于质数的片段。让我们将一个已知的质数<em class="jm"> 1013 </em>放入电子表格。</p><figure class="ix iy iz ja fd jo er es paragraph-image"><div class="er es ky"><img src="../Images/5feed31edaa11b357de62bdf512c180c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1162/format:webp/1*nSiRlf8BKA4QPpHqS7Dp4A.jpeg"/></div><figcaption class="jr js et er es jt ju bd b be z dx translated"><strong class="bd kt">带质数的费马迭代</strong></figcaption></figure><p id="b1b2" class="pw-post-body-paragraph jv jw hi jx b jy jz ij ka kb kc im kd ke kf kg kh ki kj kk kl km kn ko kp kq hb bi translated">尽管为了显示的目的，输出被截断，但是电子表格确实将<em class="jm"> (An) </em>的每个值标记为<em class="jm"> "+" </em>，以表明它们都可以被跳过。高亮显示的值表示找到了一个因子，即<em class="jm"> 1013 = 1×1013 </em>，这正是我们所期望的。</p><p id="63ae" class="pw-post-body-paragraph jv jw hi jx b jy jz ij ka kb kc im kd ke kf kg kh ki kj kk kl km kn ko kp kq hb bi translated">说实话，并不是所有的质数都会这么干净。大多数人会打一两个嗝。这是因为<strong class="jx hj">校准块</strong>的初始化仅运行到<em class="jm">“19”我现在的假设是，如果我们再增加一些范围，几乎所有的(小)质数都会被“涂黑”</em></p><p id="bb7e" class="pw-post-body-paragraph jv jw hi jx b jy jz ij ka kb kc im kd ke kf kg kh ki kj kk kl km kn ko kp kq hb bi translated"><strong class="jx hj">第六章——未完待续……</strong></p><p id="9b95" class="pw-post-body-paragraph jv jw hi jx b jy jz ij ka kb kc im kd ke kf kg kh ki kj kk kl km kn ko kp kq hb bi translated">为了避免陷入费马大弟子的最后定理，让我澄清一下我的想法。使用<strong class="jx hj">因子分解校准模块</strong>，我们可以在一个大循环中重复数字串。当它们正确对齐时，你就有很大的机会找到一个因子。这有点像老虎机，但有一个很大的不同。我们知道不倒翁序列！现在，我的经验告诉我，“即使这看起来很容易，也要为一场伟大的斗争做好准备。”我已经看到了很多分歧，因为有很多方式可以将序列连接在一起。它很可能会变成一个浴缸，上面有太多的洞，装不下水。</p><p id="f5d2" class="pw-post-body-paragraph jv jw hi jx b jy jz ij ka kb kc im kd ke kf kg kh ki kj kk kl km kn ko kp kq hb bi translated">运气好的话，我会带些真正好的东西回来。</p><p id="3702" class="pw-post-body-paragraph jv jw hi jx b jy jz ij ka kb kc im kd ke kf kg kh ki kj kk kl km kn ko kp kq hb bi translated"><strong class="jx hj">更新:</strong></p><p id="ebb9" class="pw-post-body-paragraph jv jw hi jx b jy jz ij ka kb kc im kd ke kf kg kh ki kj kk kl km kn ko kp kq hb bi translated">有关<strong class="jx hj">快速费马整数族因子分解</strong>的讨论，请访问:</p><p id="ea8f" class="pw-post-body-paragraph jv jw hi jx b jy jz ij ka kb kc im kd ke kf kg kh ki kj kk kl km kn ko kp kq hb bi translated"><a class="ae kr" href="https://jbjo1956.medium.com/fast-fermat-integer-family-factoring-e2c277943727?source=friends_link&amp;sk=a685a442c14a5fc7d8715a4d449a94cf" rel="noopener">https://jbjo 1956 . medium . com/fast-Fermat-integer-family-factoring-e2c 277943727？source = friends _ link&amp;sk = a 685 a 442 c 14 a5 fc 7d 8715 a 4d 449 a 94 cf</a></p><p id="8020" class="pw-post-body-paragraph jv jw hi jx b jy jz ij ka kb kc im kd ke kf kg kh ki kj kk kl km kn ko kp kq hb bi translated">演示<strong class="jx hj">快速费马整数族因式分解</strong>如何工作<strong class="jx hj"> </strong>的 JavaScript 程序现已推出。</p><p id="c886" class="pw-post-body-paragraph jv jw hi jx b jy jz ij ka kb kc im kd ke kf kg kh ki kj kk kl km kn ko kp kq hb bi translated"><a class="ae kr" href="https://jbjo1956.medium.com/javascript-code-for-fast-fermat-integer-family-factoring-74b738b1db7d?source=friends_link&amp;sk=0e3f81ad1ddcbbaa9daf4ed7b564eac3" rel="noopener">https://jbjo 1956 . medium . com/JavaScript-code-for-fast-Fermat-integer-family-factoring-74b 738 B1 db7d？source = friends _ link&amp;sk = 0 E3 f 81 ad 1 ddcbbaa 9 daf 4 ed 7 b 564 EAC 3</a></p></div><div class="ab cl kz la gp lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="hb hc hd he hf"><p id="a07c" class="pw-post-body-paragraph jv jw hi jx b jy jz ij ka kb kc im kd ke kf kg kh ki kj kk kl km kn ko kp kq hb bi translated"><strong class="jx hj">附录 1 —标准定义和等式</strong></p><pre class="ix iy iz ja fd jb jc jd je aw jf bi"><span id="ca0c" class="jg jh hi jc b fi ji jj l jk jl">…<em class="jm">^…</em>  — Raise to the Power of<br/>√<em class="jm">[…]</em> — Square Root Function<br/><em class="jm">An</em>   — Factor of Base Root Value:         <em class="jm">An = (Yn + Xn)/2<br/>                                                </em>where <em class="jm">An ≥ √[N]<br/>Bn</em>   — Factor of Small Root Value:        <em class="jm">Bn = (Yn — Xn)/2<br/>Ia</em>   — Unity Factor for <em class="jm">Na:</em>               <em class="jm">Ia = ± 1<br/>Ib</em>   — Unity Factor for <em class="jm">Nb:</em>               <em class="jm">Ib = ± 1<br/>N’</em>   — Integer Prime Number:              <em class="jm">N’ = N’×1 ≠ N<br/>N</em>    — Composite Integer Factorization:   <em class="jm">N = Xn×Yn ≠ N’<br/>N</em>    — Fermat’s Factorization:            <em class="jm">N = An² — Bn²<br/>                                            = (An — Bn)(An + Bn)<br/>N</em>    — Series Factorization:              <em class="jm">N = Si+6Sn<br/>                                            = (Sa + 6Sx)(Sb + 6Sy)<br/>Ri   — </em>Fermat Remainder:                  <em class="jm">Ri = An² — N<br/>                                              </em>(Iterate until <em class="jm">Ri=Bn²</em>)<br/><em class="jm">Si   </em>— Series Identifier for Composite <em class="jm">N:</em> <em class="jm">Si = 5 </em>or<em class="jm"> 7 = 6 + In<br/>Sa   </em>— Series Identifier for <em class="jm">Xn:</em>          <em class="jm">Sa = 5</em> or<em class="jm"> 7 = 6 + Ia<br/>Sb   </em>— Series Identifier for <em class="jm">Yn:</em>          <em class="jm">Sb = 5 </em>or <em class="jm">7 = 6 + Ib<br/>Sn   </em>— Series Expansion for Composite<em class="jm"> N:  Sn = (N — Si)/6<br/>Sx   </em>— Series Expansion for <em class="jm">Xn:</em>           <em class="jm">Sx = (Xn — Sa)/6<br/>Sy   </em>— Series Expansion for <em class="jm">Yn:</em>           <em class="jm">Sy = (Yn — Sb)/6<br/>Xn</em>   — Smaller Integer Factor of <em class="jm">N:       Xn = An — Bn<br/>                                               </em>where<em class="jm"> 1 &lt; Xn ≤ Yn<br/>Xn   — </em>Smaller Integer Factor of<em class="jm"> N:       Xn = Sa+ 6Sx<br/>                                          </em>where<em class="jm"> 1&lt;Xn≤Yn;</em> <em class="jm">Sa = 5</em> or<em class="jm"> 7<br/>Yn</em>   — Larger Integer Factor of<em class="jm"> N:</em>        <em class="jm">Yn = An + Bn<br/>                                               </em>where<em class="jm"> Yn ≥ Xn &gt; 1<br/>Yn   — </em>Larger Integer Factor of <em class="jm">N:        Yn = Sb + 6Sy<br/>                                          </em>where<em class="jm"> Yn≥Xn&gt;1;</em> <em class="jm">Sb = 5</em> or<em class="jm"> 7</em></span></pre></div></div>    
</body>
</html>