<html>
<head>
<title>Pagination in Android with Paging 3, Retrofit and kotlin Flow</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Android 中的分页，带有分页 3、翻新和 kotlin 流</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/pagination-in-android-with-paging-3-retrofit-and-kotlin-flow-2c2454ff776e?source=collection_archive---------0-----------------------#2021-05-11">https://medium.com/nerd-for-tech/pagination-in-android-with-paging-3-retrofit-and-kotlin-flow-2c2454ff776e?source=collection_archive---------0-----------------------#2021-05-11</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/b58e596f1fd2a95951319d67558828eb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*0VJ7PLkGe_V5vflF"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">在<a class="ae iu" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上由<a class="ae iu" href="https://unsplash.com/@benceboros?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> BENCE BOROS </a>拍摄的照片</figcaption></figure><p id="5d0b" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">你难道没问过脸书、Instagram、Twitter、Forbes 等等是如何让你“无限滚动”而不到达其应用程序中信息的“尽头”的吗？难道你不想实现这样的东西吗？</p><p id="bb29" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这种“无休止的滚动”特性通常被称为“分页”，这并不是什么新鲜事。简而言之，分页有助于加载与“页面”索引相关联的数据块。</p><p id="d9c9" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">让我们假设您有 200 个项目要显示在您的 RecyclerView 中。您通常要做的只是执行您的请求，获取响应项，并将您的列表提交到您的适配器。我们已经知道 RecyclerView 本身是<a class="ae iu" href="https://blog.mindorks.com/how-does-recyclerview-work-internally" rel="noopener ugc nofollow" target="_blank">为“回收我们的视图”而优化的</a>。但是我们真的需要立即得到那 200 个项目吗？如果我们的用户从未进入前 100 名或前 50 名会怎样？其余未显示的项目仍保留在内存中。</p><p id="267c" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">分页所做的(与我们的<a class="ae iu" href="https://developer.atlassian.com/server/confluence/pagination-in-the-rest-api/" rel="noopener ugc nofollow" target="_blank"> API </a>一起)是让我们建立一个页码，以及每页我们可以加载多少项。这样，当我们到达 RecyclerView 的底部时，我们可以只请求下一页的项目<strong class="ix hj">和</strong>。</p><h1 id="31de" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">非图书馆方法</h1><p id="e935" class="pw-post-body-paragraph iv iw hi ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated">在分页 3 之前，您可以通过向 RecyclerView 添加一些侦听器来实现分页，当您到达列表底部时，这些侦听器将被触发。有一些很好的例子，这里有一个视频有非常详细的解释(这是在 Indi 上，但它是可以理解的)。</p><figure class="kw kx ky kz fd ij"><div class="bz dy l di"><div class="la lb l"/></div></figure><p id="ea82" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">一个真正的生产就绪的例子是在格子应用。看看他们的<a class="ae iu" href="https://github.com/nickbutcher/plaid/blob/main/core/src/main/java/io/plaidapp/core/ui/recyclerview/InfiniteScrollListener.kt" rel="noopener ugc nofollow" target="_blank">infintescrollistener</a>类。</p><h1 id="6787" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">Android Jetpack 寻呼 3 和流程</h1><p id="d472" class="pw-post-body-paragraph iv iw hi ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated">今天，您将学习如何使用 android jetpack 库中的<a class="ae iu" href="https://developer.android.com/topic/libraries/architecture/paging/v3-overview?hl=es-419" rel="noopener ugc nofollow" target="_blank">分页 3 </a>来实现分页。令我惊讶的是，第 3 页的代码实验室是我做过的最简单的代码实验室之一。<a class="lc ld ge" href="https://medium.com/u/d5885adb1ddf?source=post_page-----2c2454ff776e--------------------------------" rel="noopener" target="_blank">弗洛里纳·蒙特内斯库</a>对 codelab 的每一步都做得很好，去看看吧，试一试。如果您想直接查看示例代码，请查看这个<a class="ae iu" href="https://github.com/ChristopherME/movies-android/pull/17/commits/86393b67a286903b715b5f841b92bac055426d86" rel="noopener ugc nofollow" target="_blank"> pull 请求</a>，并一步一步地了解我是如何在这个项目中实现分页 3 的。</p><div class="le lf ez fb lg lh"><a href="https://github.com/ChristopherME/movies-android" rel="noopener  ugc nofollow" target="_blank"><div class="li ab dw"><div class="lj ab lk cl cj ll"><h2 class="bd hj fi z dy lm ea eb ln ed ef hh bi translated">Christopher me/电影-android</h2><div class="lo l"><h3 class="bd b fi z dy lm ea eb ln ed ef dx translated">Movies 是一个简单的项目，可以学习和使用一些 android 组件、架构和 Android 工具…</h3></div><div class="lp l"><p class="bd b fp z dy lm ea eb ln ed ef dx translated">github.com</p></div></div><div class="lq l"><div class="lr l ls lt lu lq lv io lh"/></div></div></a></div><h1 id="23bc" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">逐步地</h1><p id="e968" class="pw-post-body-paragraph iv iw hi ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated">为了使用分页 3，首先我们需要在我们的应用程序级梯度文件中添加依赖关系:</p><pre class="kw kx ky kz fd lw lx ly lz aw ma bi"><span id="b305" class="mb ju hi lx b fi mc md l me mf">dependencies {</span><span id="788a" class="mb ju hi lx b fi mg md l me mf">  def paging_version = "3.0.0" //current version at the time<br/><br/>  implementation "androidx.paging:paging-runtime:$paging_version"<br/><br/>  // alternatively - without Android dependencies for tests<br/>  testImplementation "androidx.paging:paging-common:$paging_version"<br/><br/>  // optional - RxJava2 support<br/>  implementation "androidx.paging:paging-rxjava2:$paging_version"<br/><br/>  // optional - RxJava3 support<br/>  implementation "androidx.paging:paging-rxjava3:$paging_version"<br/><br/>  // optional - Guava ListenableFuture support<br/>  implementation "androidx.paging:paging-guava:$paging_version"<br/><br/>  // Jetpack Compose Integration<br/>  implementation "androidx.paging:paging-compose:1.0.0-alpha08"</span><span id="46da" class="mb ju hi lx b fi mg md l me mf">}</span></pre><p id="b137" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">为了实现我们的“无限滚动”功能，我们基本上需要 4 个类。</p><ul class=""><li id="7a75" class="mh mi hi ix b iy iz jc jd jg mj jk mk jo ml js mm mn mo mp bi translated"><strong class="ix hj">分页数据</strong> —分页数据的容器。每次数据刷新都会有一个单独对应的<code class="du mq mr ms lx b">PagingData</code>。这是您将要从存储库中返回的内容(如果使用存储库模式的话)。</li><li id="6ec3" class="mh mi hi ix b iy mt jc mu jg mv jk mw jo mx js mm mn mo mp bi translated"><strong class="ix hj">paging source</strong>—<code class="du mq mr ms lx b">PagingSource</code>是将数据快照加载到<code class="du mq mr ms lx b">PagingData</code>流中的基类。在这里，您将从服务(通常是翻新的)中检索您的项目，并将它们打包成 LoadResult 类型返回。</li><li id="b314" class="mh mi hi ix b iy mt jc mu jg mv jk mw jo mx js mm mn mo mp bi translated"><strong class="ix hj"> Pager.flow </strong> —构建一个<code class="du mq mr ms lx b">Flow&lt;PagingData&gt;</code>，基于一个<code class="du mq mr ms lx b">PagingConfig</code>和一个定义如何构造已实现的<code class="du mq mr ms lx b">PagingSource</code>的函数。</li><li id="d2dc" class="mh mi hi ix b iy mt jc mu jg mv jk mw jo mx js mm mn mo mp bi translated"><strong class="ix hj"> PagingDataAdapter </strong> —一个在<code class="du mq mr ms lx b">RecyclerView</code>中呈现<code class="du mq mr ms lx b">PagingData</code>的<code class="du mq mr ms lx b">RecyclerView.Adapter</code>。页面加载时，<code class="du mq mr ms lx b">PagingDataAdapter</code>监听内部<code class="du mq mr ms lx b">PagingData</code>加载事件，并在后台线程上使用<code class="du mq mr ms lx b">DiffUtil</code>计算细粒度更新，因为更新的内容是以新的<code class="du mq mr ms lx b">PagingData</code>对象的形式接收的。</li></ul><figure class="kw kx ky kz fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es my"><img src="../Images/fb9740c76b3d4e30c587e9bc2045ca2b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ALQRp8wJsQ8aPyjbIIlE9Q.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">来自第 3 页<a class="ae iu" href="https://developer.android.com/topic/libraries/architecture/paging/v3-overview" rel="noopener ugc nofollow" target="_blank">文档的图像。</a></figcaption></figure><p id="9b4d" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">好了，现在我们已经熟悉了这些类，让我们开始吧！我们要做一个应用程序，加载电影，像网飞。我们将使用<a class="ae iu" href="https://developers.themoviedb.org/3/getting-started/introduction" rel="noopener ugc nofollow" target="_blank"> TMDB API </a> ( <em class="mz">要使用 API，不要忘记注册并请求您的开发者 API 密钥</em>)。</p><h1 id="cfe6" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">1.翻新的电影服务🎬</h1><p id="47c4" class="pw-post-body-paragraph iv iw hi ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated">让我们定义一个返回电影列表的简单翻新服务。(改进实施与本主题无关，因此在本博客中未提及)。</p><figure class="kw kx ky kz fd ij"><div class="bz dy l di"><div class="na lb l"/></div></figure><h1 id="233d" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">2.实现 PagingSource📖</h1><p id="6400" class="pw-post-body-paragraph iv iw hi ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated">为了构建我们的 PagingSource，首先我们需要指出分页键的类型和要加载的数据类型。</p><p id="4b3e" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><code class="du mq mr ms lx b">PagingSource&lt;<em class="mz">Type_Of_Paging_key</em>, <em class="mz">Type_of_Data_to_load</em>&gt;</code></p><blockquote class="nb nc nd"><p id="4088" class="iv iw mz ix b iy iz ja jb jc jd je jf ne jh ji jj nf jl jm jn ng jp jq jr js hb bi translated">在这种情况下，分页键的类型是<strong class="ix hj"> Int </strong>，因为我们的页面索引是基于数字的。我们要加载的数据类型是<strong class="ix hj"> MovieResponse </strong>类型。</p></blockquote><p id="4809" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们需要从“某处”获取信息，这就是<code class="du mq mr ms lx b">MovieService</code>进入游戏的地方。这是我们的<code class="du mq mr ms lx b">MoviesPagingSource</code>最终的样子。</p><figure class="kw kx ky kz fd ij"><div class="bz dy l di"><div class="na lb l"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">这个类的实现通常与几乎所有用例中的实现相同。欲了解更多信息，请查看 codelab。</figcaption></figure><p id="da2e" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们必须在这里重写两个方法。<code class="du mq mr ms lx b">load()</code>和<code class="du mq mr ms lx b">getRefreshKey()</code>。</p><ul class=""><li id="650e" class="mh mi hi ix b iy iz jc jd jg mj jk mk jo ml js mm mn mo mp bi translated"><strong class="ix hj">load(params:load params&lt;Int&gt;)</strong>—这个函数将被分页库调用，以异步获取更多数据，以便在用户滚动时显示。<code class="du mq mr ms lx b">LoadParams</code>对象保存与加载操作相关的信息。我们将使用<code class="du mq mr ms lx b">params.key</code>来获取当前页面索引。如果这是第一次调用 load，<code class="du mq mr ms lx b">params.key</code>将是<code class="du mq mr ms lx b">null</code>。在这种情况下，我们必须用常量<code class="du mq mr ms lx b">TMDB_STARTING_PAGE_INDEX</code>定义初始页面键。最后，<code class="du mq mr ms lx b">params.loadSize</code>是请求加载的项目数。</li><li id="92b4" class="mh mi hi ix b iy mt jc mu jg mv jk mw jo mx js mm mn mo mp bi translated"><strong class="ix hj"> getRefreshKey() </strong> —刷新键用于对<code class="du mq mr ms lx b">PagingSource.load()</code>的后续刷新调用。</li></ul><h1 id="ec79" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">3.构建和配置分页数据🛠️</h1><p id="d4dd" class="pw-post-body-paragraph iv iw hi ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated">我们成功地创建了我们的<code class="du mq mr ms lx b">PagingSource</code>。但是现在我们需要一种方法来发出<code class="du mq mr ms lx b">PagingData</code>的流。为了这个任务，我们需要一个<code class="du mq mr ms lx b">PagingData</code>建造者。在我们的<code class="du mq mr ms lx b">repository</code>或<code class="du mq mr ms lx b">dataSource</code>中，我们必须创建一个<code class="du mq mr ms lx b">Page</code>的实例，它将接受一个<code class="du mq mr ms lx b">PagingConfig</code>和一个<code class="du mq mr ms lx b">pagingSourceFactory</code>。</p><figure class="kw kx ky kz fd ij"><div class="bz dy l di"><div class="na lb l"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">这个远程数据源稍后被注入到一个存储库中。如果您只使用存储库，而没有远程或本地数据源，那么您可能应该直接在该类上创建分页器。</figcaption></figure><p id="2458" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><code class="du mq mr ms lx b">PagingConfig</code>有两个参数，网络页面大小和 enablePlaceHolders。在这种情况下，这将是错误的，因为我们不需要这个样本的“微光”效果。稍后，我们需要定义我们的<code class="du mq mr ms lx b">pagingSourceFactory</code>，这将是我们的<code class="du mq mr ms lx b">MoviesPagingSource</code>。</p><h1 id="4b4d" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">4.在视图模型/演示器中请求您的数据</h1><p id="aac0" class="pw-post-body-paragraph iv iw hi ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated">我们就快成功了，现在我们只需要在 ViewModel / Presenter 中调用我们的<code class="du mq mr ms lx b">getMovies()</code>方法。</p><figure class="kw kx ky kz fd ij"><div class="bz dy l di"><div class="na lb l"/></div></figure><h1 id="69fb" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">5.将它集成到你的用户界面⛓️中</h1><p id="0629" class="pw-post-body-paragraph iv iw hi ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated">到目前为止，我们正在设置如何获取数据。但是现在是时候渲染 UI 了。我们将使用库中的<code class="du mq mr ms lx b">PagingDataAdapter</code>，它是<code class="du mq mr ms lx b">ListAdapter</code>类的另一个实现。</p><figure class="kw kx ky kz fd ij"><div class="bz dy l di"><div class="na lb l"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">MovieAdapter、MovieDiffCallBack 和 MovieViewHolder</figcaption></figure><p id="a445" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">最后，在你的片段/活动中</p><figure class="kw kx ky kz fd ij"><div class="bz dy l di"><div class="na lb l"/></div></figure><p id="eeb1" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这样你就有了一个功能性的“无限滚动”效果。尽管有一些缺失的东西。显示空视图，当我们请求更多项目时显示进度，等等。你可以在 paging 3 <a class="ae iu" href="https://developer.android.com/codelabs/android-paging#0" rel="noopener ugc nofollow" target="_blank"> codelab </a> ( <strong class="ix hj">我真的鼓励你这么做</strong>)或者检查开头提到的示例项目中找到如何实现所有这些。</p><h1 id="8f76" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">最后的想法</h1><p id="5550" class="pw-post-body-paragraph iv iw hi ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated">我喜欢 paging 3 库，但是我觉得它把你附加到了它们的实现上，你失去了灵活性。在这个项目的主要分支中，我使用<a class="ae iu" href="https://github.com/ChristopherME/movies-android/blob/feature/movies-paging3/functional-programming/src/main/java/com/christopher_elias/functional_programming/Either.kt" rel="noopener ugc nofollow" target="_blank">T5 或者</a>密封类来包装我的接口方法，并自己处理可能的失败或成功数据，由于需要返回一个<code class="du mq mr ms lx b">PagingData&lt;UiObject&gt;</code>，我不能再这样做了。此外，我实现了一个安全的改进包装器，用于在调度程序上执行<a class="ae iu" href="https://github.com/ChristopherME/movies-android/blob/feature/movies-paging3/core/network/src/main/java/com/christopher_elias/network/utils/Extensions.kt" rel="noopener ugc nofollow" target="_blank">调用</a>。IO 上下文并避免在我的所有<code class="du mq mr ms lx b">remoteDataSources</code>中重复同样的事情，但那也消失了，因为改造服务的执行是在<code class="du mq mr ms lx b">PagingSource</code>中完成的，并且必须显式返回一个<code class="du mq mr ms lx b">LoadResult</code>，正如你所看到的，异常也在那里处理。是的，您可以修改调用扩展并让它们返回一个 LoadResult，但是像简单登录这样的其他用例呢？🙃</p><p id="a0b9" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">👉检查分支<a class="ae iu" href="https://github.com/ChristopherME/movies-android/tree/feature/movies-paging3" rel="noopener ugc nofollow" target="_blank"> <strong class="ix hj"> <em class="mz">特征/电影-分页 3 </em> </strong> </a>以获得完整的实现。</p><p id="252e" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">试试图书馆，告诉我你过得怎么样！</p><p id="63cb" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">回头见！👋</p></div></div>    
</body>
</html>