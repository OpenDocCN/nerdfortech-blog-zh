<html>
<head>
<title>Automating Microfocus Data Protector using AWS Lambda (Python) + DP APIs + Windows Scheduler + SES</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用AWS Lambda(Python)+DP API+Windows Scheduler+SES实现微焦点数据保护自动化</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/automating-microfocus-data-protector-using-aws-lambda-python-dp-apis-windows-scheduler-ses-d27a589fa19e?source=collection_archive---------1-----------------------#2020-09-17">https://medium.com/nerd-for-tech/automating-microfocus-data-protector-using-aws-lambda-python-dp-apis-windows-scheduler-ses-d27a589fa19e?source=collection_archive---------1-----------------------#2020-09-17</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="dd93" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">互联网默认是不安全的。SSL证书增加了安全级别。</h2></div><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ix"><img src="../Images/79eb7de74b2df953713bc1c12965246e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*FuEIADjtFXSfY8Xy"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx translated"><a class="ae jn" href="https://unsplash.com/photos/4iTPiW1HSSg" rel="noopener ugc nofollow" target="_blank">https://unsplash.com/photos/4iTPiW1HSSg</a></figcaption></figure><h2 id="debe" class="jo jp hi bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">什么是Dataprotector？</h2><p id="ef15" class="pw-post-body-paragraph km kn hi ko b kp kq ij kr ks kt im ku jz kv kw kx kd ky kz la kh lb lc ld le hb bi translated">Micro Focus Data Protector是适用于大型、复杂和异构IT环境的企业级备份和灾难恢复解决方案。它是一种备份解决方案，可为快速增长的业务数据提供可靠的数据保护和高度可访问性，并提供专为企业范围和分布式环境定制的全面备份和恢复功能。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es lf"><img src="../Images/8b8831f514a15e0702a167944cde3541.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*BJgktK4QMu9JU2Ld.jpg"/></div></div></figure><h2 id="d773" class="jo jp hi bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">DP —原料药</h2><p id="0909" class="pw-post-body-paragraph km kn hi ko b kp kq ij kr ks kt im ku jz kv kw kx kd ky kz la kh lb lc ld le hb bi translated">幸运的是，Data Protector使用Swagger作为API的框架。您可以从数据保护器GUI上的<strong class="ko hj">帮助</strong> &gt; <strong class="ko hj"> API文档</strong>菜单选项访问数据保护器API。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es lg"><img src="../Images/dfe7b9677dfbe821084ef2fba7b18057.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*dDEOKQ78kJ92EV8_.png"/></div></div></figure><p id="1751" class="pw-post-body-paragraph km kn hi ko b kp lh ij kr ks li im ku jz lj kw kx kd lk kz la kh ll lc ld le hb bi translated">它有很多API，但是让我们把重点放在这个解决方案需要的API上。基本上，<strong class="ko hj">登录</strong>和<strong class="ko hj">过滤</strong>。</p><ol class=""><li id="08e9" class="lm ln hi ko b kp lh ks li jz lo kd lp kh lq le lr ls lt lu bi translated">登录—<a class="ae jn" href="https://gpcgrbdpcm02.srv.gapac.com:7116/auth/realms/DataProtector/protocol/openid-connect/token" rel="noopener ugc nofollow" target="_blank">https://XXX . XXX . XXX . com:xxxx/auth/realms/data protector/protocol/OpenID-connect/token</a></li><li id="969c" class="lm ln hi ko b kp lv ks lw jz lx kd ly kh lz le lr ls lt lu bi translated">过滤器—<a class="ae jn" href="https://gpcgrbdpcm02.srv.gapac.com:7116/idb/sessions/filter/" rel="noopener ugc nofollow" target="_blank">https://</a><a class="ae jn" href="https://gpcgrbdpcm02.srv.gapac.com:7116/auth/realms/DataProtector/protocol/openid-connect/token" rel="noopener ugc nofollow" target="_blank">XXX . XXX . XXX</a><a class="ae jn" href="https://gpcgrbdpcm02.srv.gapac.com:7116/idb/sessions/filter/" rel="noopener ugc nofollow" target="_blank">。com:xxxx/IDB/sessions/filter/</a></li></ol><p id="b1f8" class="pw-post-body-paragraph km kn hi ko b kp lh ij kr ks li im ku jz lj kw kx kd lk kz la kh ll lc ld le hb bi translated">底线是登录API将为我们提供一个<em class="ma">访问令牌</em>来进行后续请求。</p><h2 id="8c9c" class="jo jp hi bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">登录代码—</h2><pre class="iy iz ja jb fd mb mc md me aw mf bi"><span id="0197" class="jo jp hi mc b fi mg mh l mi mj">url = "https://<a class="ae jn" href="https://gpcgrbdpcm02.srv.gapac.com:7116/auth/realms/DataProtector/protocol/openid-connect/token" rel="noopener ugc nofollow" target="_blank">xxx.xxx.xxx</a><a class="ae jn" href="https://gpcgrbdpcm02.srv.gapac.com:7116/idb/sessions/filter/" rel="noopener ugc nofollow" target="_blank">.com:xxxx</a>/auth/realms/DataProtector/protocol/openid-connect/token"</span><span id="7684" class="jo jp hi mc b fi mk mh l mi mj">payload = {"username":"user_name|*|<a class="ae jn" href="https://gpcgrbdpcm02.srv.gapac.com:7116/auth/realms/DataProtector/protocol/openid-connect/token" rel="noopener ugc nofollow" target="_blank">xxx.xxx.xxx</a><a class="ae jn" href="https://gpcgrbdpcm02.srv.gapac.com:7116/idb/sessions/filter/" rel="noopener ugc nofollow" target="_blank">.com</a>", "password":"password", "client_id":"dp-gui", "grant_type":"password"}</span><span id="c416" class="jo jp hi mc b fi mk mh l mi mj">response =  json.loads(session.post(url, data = payload, verify = r"path_to_cert\<a class="ae jn" href="https://gpcgrbdpcm02.srv.gapac.com:7116/auth/realms/DataProtector/protocol/openid-connect/token" rel="noopener ugc nofollow" target="_blank">xxx.xxx.xxx</a><a class="ae jn" href="https://gpcgrbdpcm02.srv.gapac.com:7116/idb/sessions/filter/" rel="noopener ugc nofollow" target="_blank">.com</a>_cacert.pem").text)</span></pre><p id="9894" class="pw-post-body-paragraph km kn hi ko b kp lh ij kr ks li im ku jz lj kw kx kd lk kz la kh ll lc ld le hb bi translated">现在，这需要一个SSL证书进行身份验证，并且应该存在于您试图向其发出请求的服务器中。这是一个自签名证书，它没有证书链或密钥/证书文件。该pem文件中只有一个证书。您需要直接从服务器(<em class="ma">您将要向</em>发出请求)下载证书到项目目录。然后，在发出请求时，在verify param中提供下载的pem文件的路径。</p><h2 id="84f2" class="jo jp hi bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">SSL问题和解决方案—</h2><p id="6042" class="pw-post-body-paragraph km kn hi ko b kp kq ij kr ks kt im ku jz kv kw kx kd ky kz la kh lb lc ld le hb bi translated">你可能会得到这样的错误—</p><ol class=""><li id="d7c5" class="lm ln hi ko b kp lh ks li jz lo kd lp kh lq le lr ls lt lu bi translated"><strong class="ko hj"> SSL验证失败</strong> —为此，请检查证书路径和验证参数。<strong class="ko hj">不要试图绕过认证</strong>。</li><li id="36fe" class="lm ln hi ko b kp lv ks lw jz lx kd ly kh lz le lr ls lt lu bi translated"><strong class="ko hj">授权类型</strong> — <strong class="ko hj">不尝试对有效载荷进行base 64编码</strong>。按原样发送，即普通的json对象</li></ol><h2 id="e5de" class="jo jp hi bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">可以让它自动化的代码—</h2><p id="a75c" class="pw-post-body-paragraph km kn hi ko b kp kq ij kr ks kt im ku jz kv kw kx kd ky kz la kh lb lc ld le hb bi translated">登录后:</p><ol class=""><li id="0a83" class="lm ln hi ko b kp lh ks li jz lo kd lp kh lq le lr ls lt lu bi translated">它试图根据会话过滤器(在API文档中提供)过滤会话<strong class="ko hj"> check_session </strong>。</li></ol><pre class="iy iz ja jb fd mb mc md me aw mf bi"><span id="f12f" class="jo jp hi mc b fi mg mh l mi mj">url = "<a class="ae jn" href="https://gpcgrbdpcm02.srv.gapac.com:7116/idb/sessions/filter/" rel="noopener ugc nofollow" target="_blank">https://</a><a class="ae jn" href="https://gpcgrbdpcm02.srv.gapac.com:7116/auth/realms/DataProtector/protocol/openid-connect/token" rel="noopener ugc nofollow" target="_blank">xxx.xxx.xxx</a><a class="ae jn" href="https://gpcgrbdpcm02.srv.gapac.com:7116/idb/sessions/filter/" rel="noopener ugc nofollow" target="_blank">.com</a><a class="ae jn" href="https://gpcgrbdpcm02.srv.gapac.com:7116/idb/sessions/filter/" rel="noopener ugc nofollow" target="_blank">:xxx/idb/sessions/filter/</a>"</span><span id="0f57" class="jo jp hi mc b fi mk mh l mi mj">payload = "{\r\n  \"filter\": {\r\n    \"status\": [0,1,12,15],\r\n    \"sessionType\": [0]\r\n  }\r\n}"<br/>    headers = {<br/>        'Authorization': 'Bearer {}'.format(access_token),<br/>        'Content-Type': 'application/json'<br/>        }</span><span id="deb1" class="jo jp hi mc b fi mk mh l mi mj">response = json.loads(session.post(url, headers=headers, data = payload, verify = r"path_to_cert\<a class="ae jn" href="https://gpcgrbdpcm02.srv.gapac.com:7116/auth/realms/DataProtector/protocol/openid-connect/token" rel="noopener ugc nofollow" target="_blank">xxx.xxx.xxx</a><a class="ae jn" href="https://gpcgrbdpcm02.srv.gapac.com:7116/idb/sessions/filter/" rel="noopener ugc nofollow" target="_blank">.com</a>_cacert.pem").text)</span><span id="bccd" class="jo jp hi mc b fi mk mh l mi mj">return response</span></pre><p id="67a2" class="pw-post-body-paragraph km kn hi ko b kp lh ij kr ks li im ku jz lj kw kx kd lk kz la kh ll lc ld le hb bi translated">现在，这里它使用了一个<strong class="ko hj">状态过滤器</strong>和一个<strong class="ko hj">会话类型过滤器</strong>。状态输入可以以两种支持的格式之一提供:</p><p id="6e59" class="pw-post-body-paragraph km kn hi ko b kp lh ij kr ks li im ku jz lj kw kx kd lk kz la kh ll lc ld le hb bi translated">例子—</p><pre class="iy iz ja jb fd mb mc md me aw mf bi"><span id="7460" class="jo jp hi mc b fi mg mh l mi mj">{<br/>   "filter":{<br/>      "status":36<br/>   }<br/>}</span></pre><p id="b8f5" class="pw-post-body-paragraph km kn hi ko b kp lh ij kr ks li im ku jz lj kw kx kd lk kz la kh ll lc ld le hb bi translated">该过滤器将返回状态为“<strong class="ko hj">已完成</strong>”和“<strong class="ko hj">未通过</strong>”的会话。值<strong class="ko hj"> 36 </strong>通过设置位位置<strong class="ko hj"> 2 </strong>和<strong class="ko hj"> 5 </strong>形成。怎么会？—</p><pre class="iy iz ja jb fd mb mc md me aw mf bi"><span id="161b" class="jo jp hi mc b fi mg mh l mi mj"><strong class="mc hj">1*2⁵</strong>+0*2⁴+0*2³+<strong class="mc hj">1*2²</strong>+0*2¹+0*2⁰ = 36</span></pre><p id="f05e" class="pw-post-body-paragraph km kn hi ko b kp lh ij kr ks li im ku jz lj kw kx kd lk kz la kh ll lc ld le hb bi translated">上面这个类似于这个—</p><pre class="iy iz ja jb fd mb mc md me aw mf bi"><span id="3d23" class="jo jp hi mc b fi mg mh l mi mj">{<br/>   "filter":{<br/>      "status":[2,5]<br/>   }<br/>}</span></pre><p id="2cce" class="pw-post-body-paragraph km kn hi ko b kp lh ij kr ks li im ku jz lj kw kx kd lk kz la kh ll lc ld le hb bi translated">上述过滤器将返回“<strong class="ko hj">已完成</strong>”和“<strong class="ko hj">失败</strong>”类型的会话。</p><p id="b45a" class="pw-post-body-paragraph km kn hi ko b kp lh ij kr ks li im ku jz lj kw kx kd lk kz la kh ll lc ld le hb bi translated">下表描述了每种会话类型的位位置映射—</p><pre class="iy iz ja jb fd mb mc md me aw mf bi"><span id="237a" class="jo jp hi mc b fi mg mh l mi mj"><strong class="mc hj">Bit position Status Type</strong><br/>0 Running<br/>1 Running with Errors<br/>2 Completed<br/>3 Completed with Errors<br/>4 Aborted with Failure<br/>5 Failed<br/>6 Aborted<br/>7 Aborted with Errors<br/>8 Mounted<br/>9 Mounted with Errors<br/>10 Queueing<br/>11 Queueing with Errors<br/>12 Running with Failures<br/>13 Completed with Failures<br/>14 Mounted with Failures<br/>15 Queueing with Failures<br/>16 Completed Mirror with Failures<br/>17 Session Status No</span></pre><p id="1be0" class="pw-post-body-paragraph km kn hi ko b kp lh ij kr ks li im ku jz lj kw kx kd lk kz la kh ll lc ld le hb bi translated">类似地，会话输入也可以有两种类型—</p><pre class="iy iz ja jb fd mb mc md me aw mf bi"><span id="2aaf" class="jo jp hi mc b fi mg mh l mi mj">{<br/>   "filter":{<br/>      "sessionType":131073<br/>   }<br/>}</span></pre><p id="ffd1" class="pw-post-body-paragraph km kn hi ko b kp lh ij kr ks li im ku jz lj kw kx kd lk kz la kh ll lc ld le hb bi translated">上述过滤器将返回“<strong class="ko hj">备份</strong>”和“<strong class="ko hj">整合</strong>”类型的会话。通过设置位位置<strong class="ko hj"> 0 </strong>和<strong class="ko hj"> 17 </strong>形成值<strong class="ko hj"> 131073 </strong>。</p><pre class="iy iz ja jb fd mb mc md me aw mf bi"><span id="5864" class="jo jp hi mc b fi mg mh l mi mj">{<br/>   "filter":{<br/>      "sessionType":[0,17]<br/>   }<br/>}</span></pre><p id="48d8" class="pw-post-body-paragraph km kn hi ko b kp lh ij kr ks li im ku jz lj kw kx kd lk kz la kh ll lc ld le hb bi translated">上述筛选将返回“<strong class="ko hj">备份</strong>”和“<strong class="ko hj">合并</strong>”类型的会话。</p><p id="92ee" class="pw-post-body-paragraph km kn hi ko b kp lh ij kr ks li im ku jz lj kw kx kd lk kz la kh ll lc ld le hb bi translated">下表描述了每种会话类型的位位置映射—</p><pre class="iy iz ja jb fd mb mc md me aw mf bi"><span id="c536" class="jo jp hi mc b fi mg mh l mi mj"><strong class="mc hj">Bit position Session Type</strong><br/>0 Backup<br/>1 Restore<br/>2 Database Query<br/>3 Media Management<br/>4 Backup preview<br/>5 Restore preview<br/>6 Test<br/>7 BAR session(backup)<br/>8 BAR session(restore)<br/>9 Media management daemon<br/>10 Purge<br/>11 Restart<br/>12 Admin session<br/>13 Admin UDP<br/>14 Admin purge<br/>15 Backup Diskonly<br/>16 Copy<br/>17 Consolidation<br/>18 Key management daemon</span></pre><p id="9fbd" class="pw-post-body-paragraph km kn hi ko b kp lh ij kr ks li im ku jz lj kw kx kd lk kz la kh ll lc ld le hb bi translated">2.然后使用<strong class="ko hj"> check_duration </strong>中的自定义参数“<strong class="ko hj"> hours </strong>”过滤长时间运行的作业</p><pre class="iy iz ja jb fd mb mc md me aw mf bi"><span id="10e7" class="jo jp hi mc b fi mg mh l mi mj">epoch_time = int(time.time())<br/>    # print(f"Now - {epoch_time} Session Start Time - {session_start_time}")<br/>    if (epoch_time - session_start_time) &gt; hours * 3600:<br/>        return True<br/>    else:<br/>        return False</span></pre><p id="a753" class="pw-post-body-paragraph km kn hi ko b kp lh ij kr ks li im ku jz lj kw kx kd lk kz la kh ll lc ld le hb bi translated">3.它创建了一个小结构，要发送给<strong class="ko hj"> API-gateway </strong>。</p><pre class="iy iz ja jb fd mb mc md me aw mf bi"><span id="4eab" class="jo jp hi mc b fi mg mh l mi mj">if long_run_status:<br/>            output['Name'] = response['items'][item]['name']<br/>            output['Datalist'] = response['items'][item]['datalist']<br/>            output['SessionType'] = session_type_dict[str(response['items'][item]['sessionType'])]<br/>            output['Status'] = status_dict[str(response['items'][item]['status'])]<br/>            output['StartTime'] = convert_epoch_to_datetime(response['items'][item]['startTime'])<br/>            output['Owner'] = response['items'][item]['owner']<br/>            long_running_sessions.append(output)</span></pre><p id="6050" class="pw-post-body-paragraph km kn hi ko b kp lh ij kr ks li im ku jz lj kw kx kd lk kz la kh ll lc ld le hb bi translated">你可以选择扔掉它—</p><pre class="iy iz ja jb fd mb mc md me aw mf bi"><span id="33cd" class="jo jp hi mc b fi mg mh l mi mj">with open ("longrunningjobs.json", 'w+') as fp:<br/>    json.dump(long_running_sessions, fp)</span></pre><p id="e5db" class="pw-post-body-paragraph km kn hi ko b kp lh ij kr ks li im ku jz lj kw kx kd lk kz la kh ll lc ld le hb bi translated">4.最后，它向lambda API-gateway发送一个请求，在那里有效负载JSON被转换成CSV并通过电子邮件发送。(<em class="ma">你可以在我的其他aws lambda博客</em>中找到电子邮件代码和CSV转换器)</p><pre class="iy iz ja jb fd mb mc md me aw mf bi"><span id="b040" class="jo jp hi mc b fi mg mh l mi mj">url = "<a class="ae jn" href="https://6o8iu7eqjg.execute-api.us-east-1.amazonaws.com/default/backuprecovery-sendemail" rel="noopener ugc nofollow" target="_blank">https://api-gateway.us-east-1.amazonaws.com/default/l</a>ambda_name"</span><span id="5224" class="jo jp hi mc b fi mk mh l mi mj">headers = {<br/>        'Content-Type': 'application/json'<br/>    }</span><span id="96db" class="jo jp hi mc b fi mk mh l mi mj">response = requests.get(url, headers=headers, data = json.dumps(long_running_sessions))</span></pre><p id="7910" class="pw-post-body-paragraph km kn hi ko b kp lh ij kr ks li im ku jz lj kw kx kd lk kz la kh ll lc ld le hb bi translated">您可以选择在lambda本身中编写这个函数，并将其与电子邮件代码集成在一起。但是，lambda应该为特定的服务器附加vpc，代码应该在部署包中包含证书。</p><h2 id="d4e8" class="jo jp hi bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">端到端代码—</h2><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="ml mm l"/></div></figure><h2 id="4790" class="jo jp hi bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">带有windows调度程序的EC2(一个实验)—附带VPC</h2><p id="0702" class="pw-post-body-paragraph km kn hi ko b kp kq ij kr ks kt im ku jz kv kw kx kd ky kz la kh lb lc ld le hb bi translated">在我的情况下，我有一个EC2有VPC重视，所以想用它。下一步是安排它。</p><p id="eb92" class="pw-post-body-paragraph km kn hi ko b kp lh ij kr ks li im ku jz lj kw kx kd lk kz la kh ll lc ld le hb bi translated">步骤:</p><ol class=""><li id="606d" class="lm ln hi ko b kp lh ks li jz lo kd lp kh lq le lr ls lt lu bi translated">用以下内容创建一个. bat文件</li></ol><pre class="iy iz ja jb fd mb mc md me aw mf bi"><span id="77e0" class="jo jp hi mc b fi mg mh l mi mj">"path_to_python/python.exe" "path_to_project_folder/main.py"<br/>pause</span></pre><p id="8580" class="pw-post-body-paragraph km kn hi ko b kp lh ij kr ks li im ku jz lj kw kx kd lk kz la kh ll lc ld le hb bi translated">2.在windows任务计划程序中创建基本任务</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es mn"><img src="../Images/efadb9cc1438e217bcf0751f7e9aff42.png" data-original-src="https://miro.medium.com/v2/resize:fit:1392/format:webp/0*BAQCsbJLcZjuqTrG.png"/></div></figure><p id="7caf" class="pw-post-body-paragraph km kn hi ko b kp lh ij kr ks li im ku jz lj kw kx kd lk kz la kh ll lc ld le hb bi translated">选择一个触发器，action as start a program，然后浏览bat文件的路径并完成。</p><p id="1965" class="pw-post-body-paragraph km kn hi ko b kp lh ij kr ks li im ku jz lj kw kx kd lk kz la kh ll lc ld le hb bi translated">到了这一页的这一部分，我希望你喜欢读这篇文章，就像我喜欢写它一样。如果遇到阻挡者，请立即联系我！</p><p id="1743" class="pw-post-body-paragraph km kn hi ko b kp lh ij kr ks li im ku jz lj kw kx kd lk kz la kh ll lc ld le hb bi translated">我可以在这里找到—<a class="ae jn" href="https://www.linkedin.com/in/kuharan/" rel="noopener ugc nofollow" target="_blank">https://www.linkedin.com/in/kuharan/</a></p></div></div>    
</body>
</html>