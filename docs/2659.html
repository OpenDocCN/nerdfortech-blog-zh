<html>
<head>
<title>Minimum Knight Moves — Daily Challenge May</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">最少骑士招式——每日挑战五月</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/minimum-knight-moves-daily-challenge-may-4499e5217df5?source=collection_archive---------9-----------------------#2021-05-15">https://medium.com/nerd-for-tech/minimum-knight-moves-daily-challenge-may-4499e5217df5?source=collection_archive---------9-----------------------#2021-05-15</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><figure class="hh hi ez fb hj hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es hg"><img src="../Images/90b2e7cafcfa170c37887cd771a42ba3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BJlwF5Wdm6APnKWOqOkkTA.jpeg"/></div></div><figcaption class="hr hs et er es ht hu bd b be z dx translated">照片由<a class="ae hv" href="https://unsplash.com/@enzo74?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">亨利·胡斯塔瓦</a>在<a class="ae hv" href="https://unsplash.com/s/photos/knights?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><div class=""/><p id="f307" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">今天的问题来自每日 Leetcode 编码挑战赛——五月版。这是一个中等标签的问题。让我们看看问题陈述。</p><h2 id="2f2f" class="jt ju hy bd jv jw jx jy jz ka kb kc kd jg ke kf kg jk kh ki kj jo kk kl km kn bi translated"><a class="ae hv" href="https://leetcode.com/problems/minimum-knight-moves/" rel="noopener ugc nofollow" target="_blank"> 1197。</a>最小骑士招式</h2><p id="67d6" class="pw-post-body-paragraph iv iw hy ix b iy ko ja jb jc kp je jf jg kq ji jj jk kr jm jn jo ks jq jr js hb bi translated">在一个坐标从<code class="du kt ku kv kw b">-infinity</code>到<code class="du kt ku kv kw b">+infinity</code>的<strong class="ix hz">无限</strong>棋盘中，你在<code class="du kt ku kv kw b">[0, 0]</code>方格中有一个<strong class="ix hz">骑士</strong>。</p><p id="47c8" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">一个骑士有 8 种可能的移动方式，如下图所示。每一步都是在主方向走两个方格，然后在正交方向走一个方格。</p><p id="ad3c" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">返回移动骑士到方格所需的最少步数<code class="du kt ku kv kw b">[x, y]</code>。答案肯定是存在的。</p><h2 id="8026" class="jt ju hy bd jv jw jx jy jz ka kb kc kd jg ke kf kg jk kh ki kj jo kk kl km kn bi translated">示例:</h2><pre class="kx ky kz la fd lb kw lc ld aw le bi"><span id="065e" class="jt ju hy kw b fi lf lg l lh li"><strong class="kw hz">Input:</strong> x = 5, y = 5<br/><strong class="kw hz">Output:</strong> 4<br/><strong class="kw hz">Explanation: </strong>[0, 0] → [2, 1] → [4, 2] → [3, 4] → [5, 5]</span></pre><h2 id="47c5" class="jt ju hy bd jv jw jx jy jz ka kb kc kd jg ke kf kg jk kh ki kj jo kk kl km kn bi translated">了解问题:</h2><figure class="kx ky kz la fd hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es lj"><img src="../Images/0f4e39d6c4278a31eef7c46604d23ca4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9EzJvSmfGD1ZonuGAK6buA.png"/></div></div></figure><p id="84cb" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">考虑到当前位置为 x，y，骑士的移动可以根据坐标增量总结如下:</p><pre class="kx ky kz la fd lb kw lc ld aw le bi"><span id="9be7" class="jt ju hy kw b fi lf lg l lh li">1. (x-1, y+2) ==&gt; (-1, +2)<br/>2. (x+1, y+2) ==&gt; (+1, +2)<br/>3. (x+2, y+1) ==&gt; (+2, +1)<br/>4. (x+2, y-1) ==&gt; (+2, -1)<br/>5. (x+1, y-2) ==&gt; (+1, -2)<br/>6. (x-1, y-2) ==&gt; (-1, -2)<br/>7. (x-2, y-1) ==&gt; (-2, -1)<br/>8. (x-2, y+1) ==&gt; (-2, +1)</span></pre><p id="0318" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">正如我们看到的，在给定的坐标下，骑士可以移动到 8 个不同的位置。从那里它可以移动接下来的七个位置(1 将是起始位置或它来的位置)。使用 BFS 遍历可以找到最少的步骤数。</p><figure class="kx ky kz la fd hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es lj"><img src="../Images/a3a4c849107c90dc43136f4054c65002.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iS0d5uNaoh5lxe5njWPj-w.png"/></div></div></figure><p id="3e54" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">此外，由于初始位置在(0，0)，我们可以将移动限制在正区域或第一象限。如果我们取目标坐标的绝对值，我们就可以这样做。我们可以这样做，因为我们只需要找到最少的步骤。此外，我们跟踪访问位置。</p><h2 id="e8ff" class="jt ju hy bd jv jw jx jy jz ka kb kc kd jg ke kf kg jk kh ki kj jo kk kl km kn bi translated">代码实现:</h2><pre class="kx ky kz la fd lb kw lc ld aw le bi"><span id="af33" class="jt ju hy kw b fi lf lg l lh li">def minKnightMoves(x, y):<br/>    x , y = abs(x), abs(y)<br/>    possible_moves = [<br/>        (1, 2), (2, 1), (-1, 2), <br/>        (-2, 1), (-1, -2), (-2, -1), <br/>        (1, -2), (2, -1)<br/>        ]<br/>    <br/>    que = collections.deque([[0, 0, 0]])<br/>    visited = set()<br/>    visited.add((0, 0))<br/>    while que:<br/>        qx, qy, d = que.popleft()<br/>        if x == qx and y == qy:<br/>            return d<br/>        for dx, dy in possible_moves:<br/>            nx, ny = qx + dx, qy + dy<br/>            if (nx, ny) not in visited and nx &gt;=-2 and ny&gt;=-2:<br/>                visited.add((nx, ny))<br/>                que.append([nx, ny, d + 1])</span></pre><h2 id="15b3" class="jt ju hy bd jv jw jx jy jz ka kb kc kd jg ke kf kg jk kh ki kj jo kk kl km kn bi translated">复杂性分析:</h2><ul class=""><li id="ce56" class="lk ll hy ix b iy ko jc kp jg lm jk ln jo lo js lp lq lr ls bi translated">时间复杂度:O(max(x，y))。这是因为骑士覆盖的每个地方的半径都是 2x 或 2y。这个圆内的细胞数是 x 或 y 的最大值。</li><li id="9400" class="lk ll hy ix b iy lt jc lu jg lv jk lw jo lx js lp lq lr ls bi translated">常数空间:O(max(x，y))在任何一层我们都存储从上一层可以到达的所有节点。</li></ul><h2 id="082b" class="jt ju hy bd jv jw jx jy jz ka kb kc kd jg ke kf kg jk kh ki kj jo kk kl km kn bi translated">方法 2</h2><p id="2cc8" class="pw-post-body-paragraph iv iw hy ix b iy ko ja jb jc kp je jf jg kq ji jj jk kr jm jn jo ks jq jr js hb bi translated">从方向来看，我们可以优化，只在(-1，-2)或(-2，-1)方向移动。换句话说，目的地总是在第一象限。当我们到达(0，2)或(2，0)或(1，1)时，骑士不能再向(0，0)移动，否则可能会进入负轴。如果我们在(0，2)把夜晚移到(2，1)，那么从那里它可以移到(0，0)。这需要两步。这同样适用于(1，1)和(2，0)。类似地，对于(0，1)，需要 3 个步骤才能回到(0，0)</p><pre class="kx ky kz la fd lb kw lc ld aw le bi"><span id="fefd" class="jt ju hy kw b fi lf lg l lh li">def minKnightMoves(self, x: int, y: int) -&gt; int:<br/>    <!-- -->known_point_moves = {(0, 0): 0, (1, 1): 2, (1, 0): 3, (0, 1): 3, (2, 0): 2, (0, 2): 2}</span><span id="d0f3" class="jt ju hy kw b fi ly lg l lh li">    def dfs(x, y):<br/>        if (x, y) in <!-- -->known_point_moves<!-- -->: <br/>            return cache[(x, y)]<br/>        res = min(dfs(abs(x-1), abs(y-2)), dfs(abs(x-2), abs(y-1))) + 1<br/>        <!-- -->known_point_moves<!-- -->[(x, y)] = res<br/>        return res<br/>    return dfs(abs(x), abs(y))</span></pre></div></div>    
</body>
</html>