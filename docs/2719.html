<html>
<head>
<title>Cross-Validation in Statistical Models</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">统计模型中的交叉验证</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/cross-validation-in-statistical-models-60d6ed4058c4?source=collection_archive---------18-----------------------#2021-05-17">https://medium.com/nerd-for-tech/cross-validation-in-statistical-models-60d6ed4058c4?source=collection_archive---------18-----------------------#2021-05-17</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="be90" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">机器学习的最终目标是创建一个可以解决业务问题或充分解决特定问题的模型。在这种情况下，模型是一个具有已定义参数的通用函数，用于进行预测。</p><p id="eac2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">当处理机器学习问题时，建议应该包括验证步骤，该步骤使用已经搁置的验证数据来评估模型如何处理看不见的数据。验证数据上的模型性能允许我们微调模型参数。这种意义上的微调包括:从模型函数中移除某些特征、添加或移除某些特征的权重以及添加新特征。</p></div><div class="ab cl jd je gp jf" role="separator"><span class="jg bw bk jh ji jj"/><span class="jg bw bk jh ji jj"/><span class="jg bw bk jh ji"/></div><div class="hb hc hd he hf"><figure class="jl jm jn jo fd jp er es paragraph-image"><div class="er es jk"><img src="../Images/e0c5f24c5f2813c1c7bb19f303aac745.png" data-original-src="https://miro.medium.com/v2/resize:fit:846/format:webp/1*0plEW7vSBlkwN3ET-sqpsw.png"/></div></figure><p id="ebb5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">交叉验证步骤就在我们将模型暴露给测试数据之前。在将数据分割成训练和测试数据的过程中，我们添加了一个额外的步骤，将训练数据分割成训练集和验证集。</p><p id="60d3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在完成数据探索特征选择和模型训练之后，我们接着进行交叉验证。我们将模型预测值与实际值进行比较，如上所述，我们利用这些信息对模型进行微调。</p><p id="1e2a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在我们已经了解了验证步骤的作用，我们可以研究一些类型的交叉验证。</p></div><div class="ab cl jd je gp jf" role="separator"><span class="jg bw bk jh ji jj"/><span class="jg bw bk jh ji jj"/><span class="jg bw bk jh ji"/></div><div class="hb hc hd he hf"><p id="b1d9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> K倍交叉验证</strong></p><p id="41c1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在K倍交叉验证中，训练数据被分成K倍。交叉验证步骤运行k次，并且在每个阶段，k-1个折叠用于训练，而剩下的一个被搁置并用于验证。</p><p id="fdcb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">对于均方误差是用于估计模型的方法的线性回归应用，我们使用每一步产生的k个均方误差的平均值。</p><figure class="jl jm jn jo fd jp er es paragraph-image"><div role="button" tabindex="0" class="jt ju di jv bf jw"><div class="er es js"><img src="../Images/0382f30e71a52f857e8a18694d4d2ccc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rzf-0tCZYyQaCXpKVUQoOQ.png"/></div></div></figure><p id="560e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">撑出法</strong></p><p id="69c4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这是最常用的交叉验证类型，因此我在上面的交叉验证定义中使用了它。为了重复，当使用保持方法时，训练数据被进一步分成验证集，并且交叉验证步骤被运行一次。</p><figure class="jl jm jn jo fd jp er es paragraph-image"><div role="button" tabindex="0" class="jt ju di jv bf jw"><div class="er es jx"><img src="../Images/a3d71a9a85b11036d3ff271bba887049.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*F5OnbjmOGnE6OoAD_Cnagw.png"/></div></div><figcaption class="jy jz et er es ka kb bd b be z dx translated">举行一个简历的步骤</figcaption></figure><p id="6ad3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">保持一的优点是，与其他方法相比，它的计算量较小。</p><p id="09b2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">留一条出来的方法</strong></p><p id="647d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在这种情况下，我们使用训练数据中排除的每一行，然后使用排除的那一行作为验证集。结果，交叉验证步骤运行<em class="kc"> n次</em>，并且每个步骤的验证集的大小是一行。<em class="kc">注意，在这种情况下，n代表数据集的长度/大小。</em></p><figure class="jl jm jn jo fd jp er es paragraph-image"><div role="button" tabindex="0" class="jt ju di jv bf jw"><div class="er es kd"><img src="../Images/ad7b76cf03ccbd36d0eb23f7e6b3a3b1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uSkoAfB7duAQYIEEcUefgA.png"/></div></div></figure><p id="7cff" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">值得注意的是，这种方法的计算成本很高，因为该步骤需要运行与数据大小相同的次数，因此在大型数据集上实施该方法效率不高。</p><p id="f421" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">分层K折交叉验证</strong></p><p id="cbe7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">分层交叉验证进一步扩展了我们对K-fold验证所做的工作。这种情况下的不同之处在于，在分裂k倍的过程中，我们注意到训练数据中存在的不平衡，并且我们试图保留这些变化，以便保持训练数据的代表性。</p></div><div class="ab cl jd je gp jf" role="separator"><span class="jg bw bk jh ji jj"/><span class="jg bw bk jh ji jj"/><span class="jg bw bk jh ji"/></div><div class="hb hc hd he hf"><p id="9e89" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">交叉验证是机器学习过程中不可或缺的一部分，我希望这篇文章有助于澄清这个话题上任何挥之不去的问题。</p><p id="a8b6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">干杯。</p></div></div>    
</body>
</html>