<html>
<head>
<title>Building a Text Classifier using RNN</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用RNN构建文本分类器</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/building-a-text-classifier-using-rnn-57b546d3d35a?source=collection_archive---------5-----------------------#2021-06-25">https://medium.com/nerd-for-tech/building-a-text-classifier-using-rnn-57b546d3d35a?source=collection_archive---------5-----------------------#2021-06-25</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="4f92" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在我们的<a class="ae jd" rel="noopener" href="/nerd-for-tech/natural-language-processing-using-python-nltk-5c1804d0962d">最后一个故事</a>中，我们讨论了在不使用RNN的情况下构建文本分类器。在本文中，我们将讨论使用递归神经网络(RNN)来构建文本分类器。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es je"><img src="../Images/4f26a12737bf59e06551a74e7db42a70.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OmUs9F4_lPekVCJw3UIYQA.png"/></div></div><figcaption class="jq jr et er es js jt bd b be z dx translated">使用RNN的垃圾短信分类</figcaption></figure><h1 id="d612" class="ju jv hi bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">为什么是RNN &amp;为什么不是安？</h1><p id="ef83" class="pw-post-body-paragraph if ig hi ih b ii ks ik il im kt io ip iq ku is it iu kv iw ix iy kw ja jb jc hb bi translated">让我们想象一下，当我们第一次被教在练习纸上写字母A时，我们会做这样的事情。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div class="er es kx"><img src="../Images/98b4962e9a9b8e80cc37fc005cfdb53b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1104/format:webp/1*7O2oehrVcK6AzFmAzc1pCg.png"/></div><figcaption class="jq jr et er es js jt bd b be z dx translated">练习字母A</figcaption></figure><p id="089d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在书写本身的过程中，我们会意识到笔正在移出线条，笔画必须改变。所以如果可能的话，我们会在适当的时候擦掉或者至少改变钢笔的方向。这正是递归神经网络(RNN)所做的。</p><p id="b068" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">传统的神经网络将处理一个输入，并移动到下一个输入，而不管它的<strong class="ih hj">序列</strong>。人工神经网络完成该过程，并通过<a class="ae jd" href="https://machinelearningmastery.com/gentle-introduction-backpropagation-time/" rel="noopener ugc nofollow" target="_blank">反向传播</a>计算误差。与人工神经网络不同，人工神经网络本质上是在过程开始时给出反馈。RNNs适应<a class="ae jd" href="https://machinelearningmastery.com/gentle-introduction-backpropagation-time/" rel="noopener ugc nofollow" target="_blank">通过时间的反向传播(BPTT) </a>，因为该模型是时间的并且处理时间序列/序列数据。传统的前馈神经网络不能理解这一点，因为每个输入都被假设为彼此独立，而在时间序列/序列数据中，每个输入都依赖于前一个输入。与前馈神经网络不同，rnn可以使用其内部状态(记忆)来处理输入序列。</p><h1 id="968c" class="ju jv hi bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">递归神经网络(RNN)</h1><p id="76ef" class="pw-post-body-paragraph if ig hi ih b ii ks ik il im kt io ip iq ku is it iu kv iw ix iy kw ja jb jc hb bi translated">递归神经网络(RNN)是具有内部存储器组件的前馈神经网络的推广。RNN本质上是递归的，因为它对每个数据输入执行相同的函数，并且当前输入的结果依赖于先前的计算。产生输出后，它被复制并传输回循环网络。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es ky"><img src="../Images/cac280947b0c950152faf9ca08ec4c2c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*7FBVN8qPiEufaSQaEkL5-w.gif"/></div></div><figcaption class="jq jr et er es js jt bd b be z dx translated">将人工神经网络转换为神经网络</figcaption></figure><p id="f2ed" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">神经网络不同层中的节点被压缩以形成单层递归神经网络。a、B和C是网络的参数。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es kz"><img src="../Images/bdcfd98b71b31a2eae68f1ff09d51843.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*jNs4SDkMVQOAF21y2KWK4Q.gif"/></div></div><figcaption class="jq jr et er es js jt bd b be z dx translated">全连接递归神经网络</figcaption></figure><p id="f2f9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">x-输入层，h-隐藏层，y-输出层&amp; A，B，C-影响模型输出的参数</strong>。</p><p id="fad4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> x(t-1)，x(t)，x(t+1)，…。-分别在时间步长t-1、t、t+1的输入向量</strong>。如果<strong class="ih hj"> h(t) </strong>是时间步长t的当前新状态，那么<strong class="ih hj"> h(t-1) </strong>是时间步长t-1的旧状态。</p><p id="33ee" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在任何给定时间t，当前输入将是在<strong class="ih hj"> x(t)和x(t-1) </strong>的输入的组合。在任何给定时间的输出被取回到网络以改进输出。</p><h1 id="cb82" class="ju jv hi bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">递归神经网络的类型(RNN)</h1><p id="6e1f" class="pw-post-body-paragraph if ig hi ih b ii ks ik il im kt io ip iq ku is it iu kv iw ix iy kw ja jb jc hb bi translated">根据RNN接收的输入数量和产生的输出数量，RNN可以分为以下任何一种类型。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es la"><img src="../Images/525a029897dd71118b6e26c422e63451.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tgvADkJxBrFpmaGhjy79RQ.png"/></div></div><figcaption class="jq jr et er es js jt bd b be z dx translated">RNN的类型</figcaption></figure><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es lb"><img src="../Images/0e61f5ed9172479eaa0081537b381702.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TGj1G-PTtf7nKb3q5Jqdmw.png"/></div></div><figcaption class="jq jr et er es js jt bd b be z dx translated">RNN的类型(续)</figcaption></figure><h1 id="ea6a" class="ju jv hi bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">RNN类型的应用</h1><p id="c9a1" class="pw-post-body-paragraph if ig hi ih b ii ks ik il im kt io ip iq ku is it iu kv iw ix iy kw ja jb jc hb bi translated">普通神经网络(甚至CNN)的一个问题是，它们只能处理预先确定的大小:它们接收固定大小的输入，产生固定大小的输出。rnn是有用的，因为它们让我们既有输入又有输出的可变长度序列。</p><p id="1182" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">一对多:</strong>它接受一个输入，产生许多输出。例如<strong class="ih hj">图像字幕</strong>，其中它采用一幅输入图像并产生一系列文本字幕。</p><p id="d193" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">多对一:</strong>它接受一系列输入，只产生一个输出。例如<strong class="ih hj">情感分析</strong>，其中它将连续文本作为输入，如电影评论，并产生情感作为输出，如评论是正面的还是负面的。</p><p id="ddd7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">多对多:</strong>这接收顺序输入并产生顺序输出。有两种情况:在第一种情况下，例如<strong class="ih hj">语言翻译</strong>它采用一种语言的顺序输入，并产生所述翻译语言的顺序输出。在第二种情况下，例如<strong class="ih hj">视频字幕</strong>，其中视频被转换成图像序列并用文本序列加字幕</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es lc"><img src="../Images/4e4d6ccf01168b9ca6e3f7426e76aca5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xhYlUs2umK2MZWrMfUtz8A.png"/></div></div><figcaption class="jq jr et er es js jt bd b be z dx translated">RNN类型的应用</figcaption></figure><h1 id="1da6" class="ju jv hi bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">使用RNN的垃圾短信分类器</h1><p id="1397" class="pw-post-body-paragraph if ig hi ih b ii ks ik il im kt io ip iq ku is it iu kv iw ix iy kw ja jb jc hb bi translated">现在让我们开始使用RNN构建一个文本分类器。关于预处理文本的详细视图，<a class="ae jd" rel="noopener" href="/nerd-for-tech/natural-language-processing-using-python-nltk-5c1804d0962d">点击此处</a>。文本预处理的基础是说明。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es ld"><img src="../Images/337a5c6f78c050abc512f1346f3ba08c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vLiCq0fH1vgoKRhkSwzdkg.png"/></div></div><figcaption class="jq jr et er es js jt bd b be z dx translated">文本预处理的步骤</figcaption></figure><p id="5efb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">垃圾短信分类数据集可以从<a class="ae jd" href="https://archive.ics.uci.edu/ml/machine-learning-databases/00228/" rel="noopener ugc nofollow" target="_blank"> UCI知识库</a>下载。</p><ol class=""><li id="05bd" class="le lf hi ih b ii ij im in iq lg iu lh iy li jc lj lk ll lm bi translated">导入必要的包。</li><li id="4f5c" class="le lf hi ih b ii ln im lo iq lp iu lq iy lr jc lj lk ll lm bi translated">用熊猫下载阅读数据集，做一些探索性的数据分析来理解。</li><li id="fc2d" class="le lf hi ih b ii ln im lo iq lp iu lq iy lr jc lj lk ll lm bi translated">添加一个简单的单词云功能来显示垃圾邮件中的常用单词。这让我们知道在每一类中什么样的单词占主导地位。要创建单词云，首先将类分成两个数据框data_ham和data_spam</li><li id="3ce1" class="le lf hi ih b ii ln im lo iq lp iu lq iy lr jc lj lk ll lm bi translated">通过分成训练和测试数据集来准备用于训练的数据集，并且如上所述预处理包含消息(spam/ ham)的文本列。X_train &amp; X_test是训练和测试数据集中的消息，y_train &amp; y_test是它们对应的spam (1) / ham (0)数字标签</li><li id="c21d" class="le lf hi ih b ii ln im lo iq lp iu lq iy lr jc lj lk ll lm bi translated">从keras添加一个<a class="ae jd" href="https://keras.io/api/layers/recurrent_layers/simple_rnn/" rel="noopener ugc nofollow" target="_blank"> SimpleRNN层</a>。</li><li id="5ed9" class="le lf hi ih b ii ln im lo iq lp iu lq iy lr jc lj lk ll lm bi translated">模型被编译并生成摘要。该模式现在被训练50个历元，但是当它达到最小验证损失时会提前停止。这是通过使用EarlyStopping()并将其传递给model.fit()中的回调参数来实现的。</li><li id="8f0f" class="le lf hi ih b ii ln im lo iq lp iu lq iy lr jc lj lk ll lm bi translated">在用测试数据进行预测之后，生成分类报告(具有精确度、召回率、F分数和支持度)和混淆矩阵以供分析。</li><li id="60bc" class="le lf hi ih b ii ln im lo iq lp iu lq iy lr jc lj lk ll lm bi translated">现在，当模型性能看起来不错时，作为模型构建的最后一步，保存训练好的模型和记号赋予器。保存标记化器可确保您能够以在训练期间处理数据集的相同方式处理新数据集。Python pickle库可以用来保存tokenizer。</li><li id="7a52" class="le lf hi ih b ii ln im lo iq lp iu lq iy lr jc lj lk ll lm bi translated">最后一步是加载模型和标记器，并使用它来预测新消息。如果是垃圾邮件，预测的输出将为0，如果是垃圾邮件，预测的输出将为1。</li></ol><p id="3bda" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">访问完整的<a class="ae jd" href="https://colab.research.google.com/drive/1CVZ4NTO3NRYNDV1MWxvx5Y5HKtgt0OCo#scrollTo=kEWCZzSO_Sa4" rel="noopener ugc nofollow" target="_blank"> COLAB代码</a>。</p><h1 id="f60b" class="ju jv hi bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">谢谢&amp;快乐学习</h1></div></div>    
</body>
</html>