<html>
<head>
<title>A simple auto correct model using Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用 Python 的简单自动校正模型</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/a-simple-auto-correct-model-using-python-723944307026?source=collection_archive---------0-----------------------#2022-07-04">https://medium.com/nerd-for-tech/a-simple-auto-correct-model-using-python-723944307026?source=collection_archive---------0-----------------------#2022-07-04</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="85ae" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们每天在手机和电脑上使用自动更正功能。它已经成为我们日常打字体验中不可或缺的一部分，以至于我们不再把它视为一种功能。但是你有没有想过在你的屏幕后面到底是什么神奇地把“错误”变成了“错误”？</p><p id="4c9d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">当你在谷歌搜索栏中输入下面的句子时:</p><p id="f78f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="jd">如何学习踢足球</em>。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es je"><img src="../Images/653ecfbb63a4aa9323878165553299fb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xkCsvAJ96z4db1JXU02X7w.png"/></div></div></figure><p id="347f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">很有可能你本打算写“<strong class="ih hj"><em class="jd"/></strong>”而不是“<strong class="ih hj"><em class="jd"/></strong><em class="jd"/>”这个单词，但最终却写错了拼写。看到搜索建议已经纠正了错误的单词，并根据正确的单词“<strong class="ih hj"> <em class="jd">足球</em> </strong>”给了我们几个建议。</p><p id="3483" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们将要制作的自动纠正模型将帮助我们了解我们的手机如何理解我们写的单词不正确，并建议一个更合适的单词。我们的模型不是你手机上的镜像模型，但是工作得很好！</p><p id="05e1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">先决条件:Python 基本语法，循环，数据结构(字符串，列表，集合，元组)，库(熊猫，numpy，集合)。</p><p id="9a58" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们开始吧。</p><ol class=""><li id="2d2a" class="jq jr hi ih b ii ij im in iq js iu jt iy ju jc jv jw jx jy bi translated"><strong class="ih hj">编辑距离:</strong></li></ol><p id="24de" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们首先了解编辑距离实际上是什么。</p><p id="10ed" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">当我们说两个单词彼此相距“x”编辑距离时，这意味着我们需要编辑或改变其中一个单词“x”次来形成另一个单词。</p><p id="c5d6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">例如，考虑单词“老鼠”和“猫”。如果我们把单词 rat 中的字母 r 替换成 c，那么它就变成了 cat。所以这意味着单词“rat”和“cat”彼此相距 1 个编辑距离。同样，单词“速度”和“贪婪”彼此相距 2 个编辑距离(在单词“速度”中分别用“g”和“r”替换“s”和“p”以获得“贪婪”)。</p><p id="380e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">编辑下列形式的任何单词/字符串:</p><p id="fdf2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> a)开关</strong></p><p id="96ce" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">交换操作是通过交换一个单词中的任意两个字母来完成的。</p><p id="60de" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">例如:</p><p id="c544" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">男孩'-&gt; 'yob '，' ybo '，' byo '，' oyb '，' oby '。</p><p id="648a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">替换</p><p id="e159" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">替换操作是用一个单词中的一个字母替换另一个字母。</p><p id="7321" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">例如:</p><p id="bb63" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">'猫'-&gt; '垫子'，'帽子'，'蝙蝠'，'老鼠'。</p><p id="4af9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> c)删除</strong></p><p id="7316" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">删除操作是通过删除单词中的 1 个字母而不替换来完成的。</p><p id="fe1c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">例如:</p><p id="2385" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">' cow' -&gt; 'ow '，' cw '，' co '。</p><p id="e7a3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> d)插入</strong></p><p id="dc92" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">插入操作是通过在单词中添加一个字母来完成的。</p><p id="7297" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">吃了'-&gt; '门'，'伴侣'，'恨'，'缘分'。</p><p id="b3cb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在，您已经理解了这 4 个操作，我们将使用它们来构建我们的自动更正模型，为此，我们必须根据给定的输入来计算单词正确的概率。为了计算概率，我们将利用贝耶定理。</p><p id="8b81" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><a class="ae jz" href="https://en.wikipedia.org/wiki/Bayes%27_theorem" rel="noopener ugc nofollow" target="_blank">点击此处了解更多贝叶定理。</a></p><p id="4316" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">贝叶定理的数学方程式如下:</p><p id="6b42" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">P(A|B) = P(B|A) * P(A) / P(B)</p><p id="f6ed" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">上面的等式表示，给定单词“B”(LHS)，单词“A”正确的概率等于给定单词“A”，单词“B”正确的概率乘以单词“A”正确的概率除以单词“B”正确的概率(RHS)。</p><p id="29a4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为了计算上述公式，我们需要读取我们的数据集，并计算我们需要建立模型的所有概率。</p><p id="9741" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> 2。预处理我们的数据:</strong></p><p id="4fc9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">下一步是预处理我们将用来构建模型的数据集。Python 提供了一系列库，使得数据预处理变得非常简单。我们将使用关键字 import 导入这样的库，如下所示。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es je"><img src="../Images/908c4a037c0a5fee9dea89c1953f2841.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jHTw-1azJzbDUiBuId79-w.png"/></div></div></figure><p id="811f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">导入库后，我们将开始预处理我们的数据。</p><p id="b927" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们将创建一个函数 process_data()，该函数将我们的数据集作为输入，将所有句子转换为小写，并将其拆分为一个单词列表，然后返回这个名为“words”的列表。请注意，数据集“shakespeare.txt”是一个包含大量句子的文件。当我们读取它时，它将被保存为一个长字符串。</p><p id="f737" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><a class="ae jz" href="https://drive.google.com/file/d/0BzNAHGvG5wxZZjcwMDc5YjctNGI4OC00YzAxLWJhYTctNGQ3ZDNmMmZlMjNh/view?hl=en&amp;resourcekey=0-TtsP3DAmXlQHuogzn5YDQg" rel="noopener ugc nofollow" target="_blank">你可以在这里访问数据集。</a></p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es je"><img src="../Images/41cf10f43b57370fa658b03a04cb1f1c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mHQLsciMuauXKvo-4a_VpQ.png"/></div></div></figure><p id="18d3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这个单词列表将成为我们的语料库。但是它也可能包含一些重复的单词。我们将从语料库中删除重复的单词，并将其保存在一个名为 vocab 的变量中。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es je"><img src="../Images/bca8b93c2529961317c92629c7a4f39e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3n-2-9l-LgASUEmotrdY-g.png"/></div></div></figure><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es je"><img src="../Images/246127d9aeb3ea6a194804b174e31e92.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jsrLDMM9R8cYlyClB-Vvzw.png"/></div></div></figure><p id="85ff" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">注意，我们已经使用 set()函数从语料库中删除了重复的单词，因此我们的词汇表中有 6116 个唯一的单词。</p><p id="6898" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> 3。字数</strong></p><p id="e36d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在我们需要确定每个单词在我们的语料库中出现了多少次。我们将把这些数据存储在一个 python 字典中。字典的关键字将是出现在我们的语料库中的单词，值将是给定单词在语料库中出现的次数。为此，我们将创建一个 get_count()函数，如下所示。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es je"><img src="../Images/92a652bc8271649998ebf2c9b4411aba.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FVisk1cY7OUe6ju6Ud51lw.png"/></div></div></figure><p id="b0c3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">请注意，我们已经使用了之前导入的“集合”模块中的计数器函数。正如你在下面看到的，单词“你”在我们的语料库中出现了 240 次。同样，你也可以检查其他单词。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es je"><img src="../Images/7284336296a402ea2301150bb05a91a8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EC2hzcRisCb1RlZOb6J7cQ.png"/></div></div></figure><p id="2123" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> 4。单词概率</strong></p><p id="9fbb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">因为我们现在有一个字典“word_count_dict ”,它包含每个单词在语料库中出现的次数，所以如果从语料库中随机选择一个单词，我们可以计算每个单词出现的概率。对于任何给定的单词，比如“alex”，如果我们从语料库中随机选择一个单词，则“alex”出现的概率由以下公式给出:</p><p id="5804" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">p(' Alex ')= Alex 出现在语料库中的次数/语料库的长度</p><p id="8599" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">同样，我们可以计算语料库中每个单词的概率。</p><p id="53e7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们定义了一个函数“get_probs”来计算概率。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es je"><img src="../Images/84f1a38ee743b0e6aeafe96a0fa86ea0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8dw627zfofSnMF0dPIdpMQ.png"/></div></div></figure><p id="0ac9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如下图所示，从语料库中选择单词“thee”的概率等于 0.0045。同样，你也可以检查其他单词。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es je"><img src="../Images/11037773583b65f25ef2a9f13bbf821b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pf5xWwbKFzDqCQ3-hYDqeg.png"/></div></div></figure><p id="cb9e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> 5。字符串操作:</strong></p><p id="1eac" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如前所述，我们将通过 4 个操作(切换、替换、删除、插入)来编辑给定的字符串。在本节中，我们将创建执行这些操作的函数。为了实现这些功能，我们将利用 python 中一个非常强大的特性，即列表理解。</p><p id="dd59" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">列表理解是通过在一行代码中对现有列表执行操作来创建新列表的最简单方法之一。</p><blockquote class="ka kb kc"><p id="586d" class="if ig jd ih b ii ij ik il im in io ip kd ir is it ke iv iw ix kf iz ja jb jc hb bi translated"><a class="ae jz" href="https://www.geeksforgeeks.org/comprehensions-in-python/" rel="noopener ugc nofollow" target="_blank"> <em class="hi">在这里阅读更多关于列表理解。</em> </a></p></blockquote><p id="4bfa" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们利用这个特性来构建我们的函数。</p><p id="d9b3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> a) delete_letter() </strong></p><p id="5524" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">函数 delete_letter()将一个单词(字符串类型)作为输入，从单词中逐个删除单个字母，并返回删除每个字母后形成的单词列表。</p><p id="2841" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">比如:' cow' -&gt; 'ow '，' cw '，' co '。</p><p id="5c92" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在，我们将从列表中生成从给定单词中删除一个字符后得到的所有单词。</p><p id="f62a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">例如，单词“cake”被拆分为:['ake '，' cak '，' ake']</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es je"><img src="../Images/9ff7546527e0ab202f13981a08fba9b6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YySptZGENSBkMATc1oVcDw.png"/></div></div></figure><p id="0439" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">正如您在下面看到的，我们已经在单词“cans”上实现了我们的函数，它在分别从单词“cans”中删除“c”、“a”、“n”、“s”后返回[“ans”、“cns”、“cas”、“can]]，如下所示。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es je"><img src="../Images/51f6a1432432c583dcff0a453349b3d4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*81oI5bpUyv6WabOC89xeIA.png"/></div></div></figure><p id="2af4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> b) switch_letter() </strong></p><p id="3f00" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们将创建一个函数 switch_letter，它将一个单词(string 类型)作为输入，从我们的字符串中逐个交换相邻的字母，并返回给我们交换相邻字母后形成的单词列表。</p><p id="c29a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">比如:‘男孩’-&gt;‘oby’，‘byo’</p><p id="a16e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如前所述，我们使用列表理解来计算 switch_letter，如下所示。注意，在第 17 行，我写了一个 if 条件来处理输入单词有重复字母的情况。</p><p id="e6d5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">例如，如果输入是' zoo '，函数将返回['ozo '，' zoo']，其中也包含输入单词' zoo '。为了排除这一点，我加入了 if 条件。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es je"><img src="../Images/a31307d84fabb8bbcbf610097d75d049.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iIK1srr8ZGOFNF3SIuoEPQ.png"/></div></div></figure><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es je"><img src="../Images/9d77dbaf1f3e58cca5c102bc8c73d939.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ts7PjGpRjLgVkbmAdc3PCQ.png"/></div></div></figure><p id="cd7a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> c) replace_letter() </strong></p><p id="2d6c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们将创建一个函数 replace_letter()，它将一个字符串作为输入，用英语字母表中的每个字母替换其中的每个字母，并返回替换每个字母后形成的单词列表。</p><p id="5a72" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如前所述，我们使用列表理解来计算 replace_letter，如下所示。例如，如果输入是“can ”,函数将返回</p><pre class="jf jg jh ji fd kg kh ki kj aw kk bi"><span id="4933" class="kl km hi kh b fi kn ko l kp kq">['aan', 'ban', 'caa', 'cab', 'cac', 'cad', 'cae', 'caf', 'cag', 'cah', 'cai', 'caj', 'cak', 'cal', 'cam', 'cao', 'cap', 'caq', 'car', 'cas', 'cat', 'cau', 'cav', 'caw', 'cax', 'cay', 'caz', 'cbn', 'ccn', 'cdn', 'cen', 'cfn', 'cgn', 'chn', 'cin', 'cjn', 'ckn', 'cln', 'cmn', 'cnn', 'con', 'cpn', 'cqn', 'crn', 'csn', 'ctn', 'cun', 'cvn', 'cwn', 'cxn', 'cyn', 'czn', 'dan', 'ean', 'fan', 'gan', 'han', 'ian', 'jan', 'kan', 'lan', 'man', 'nan', 'oan', 'pan', 'qan', 'ran', 'san', 'tan', 'uan', 'van', 'wan', 'xan', 'yan', 'zan']<br/> </span></pre><p id="39c3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">请注意，首先我们将用所有其他 25 个字母替换“can”中的第一个字母“c ”,对于字母“a”和“n”也是如此。请注意，在第 15 行，我已经用列表理解将输入单词中的每个字母替换为每个字母表。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es je"><img src="../Images/fada80f542d98f29ecb8faf972485ffc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*p7PcfeeZ7nm4u432e-pljw.png"/></div></div></figure><p id="a6fa" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">正如你在下面看到的，我们用输入单词‘can’运行函数，在用每个字母表替换输入单词中的每个字母后，它返回所有单词。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es je"><img src="../Images/6620142888a19373c673bd261c05d449.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*70RA1wQecYkw-O6paTSfZQ.png"/></div></div></figure><p id="e368" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> d) insert_letter() </strong></p><p id="8558" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们将创建一个函数 insert_letter()，它将一个单词(字符串类型)作为输入，并返回一个单词列表，该列表是通过在每个偏移量处插入一个字母而形成的，这意味着在输入单词的开头、结尾以及连续字母之间插入字母。</p><p id="ea1d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">例如:</p><p id="d637" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果输入单词是“at”，该函数将返回以下内容:</p><pre class="jf jg jh ji fd kg kh ki kj aw kk bi"><span id="4c02" class="kl km hi kh b fi kn ko l kp kq">['aat', 'bat', 'cat', 'dat', 'eat', 'fat', 'gat', 'hat', 'iat', 'jat', 'kat', 'lat', 'mat', 'nat', 'oat', 'pat', 'qat', 'rat', 'sat', 'tat', 'uat', 'vat', 'wat', 'xat', 'yat', 'zat', 'aat', 'abt', 'act', 'adt', 'aet', 'aft', 'agt', 'aht', 'ait', 'ajt', 'akt', 'alt', 'amt', 'ant', 'aot', 'apt', 'aqt', 'art', 'ast', 'att', 'aut', 'avt', 'awt', 'axt', 'ayt', 'azt', 'ata', 'atb', 'atc', 'atd', 'ate', 'atf', 'atg', 'ath', 'ati', 'atj', 'atk', 'atl', 'atm', 'atn', 'ato', 'atp', 'atq', 'atr', 'ats', 'att', 'atu', 'atv', 'atw', 'atx', 'aty', 'atz']</span></pre><p id="6303" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">首先，它将在“at”之前插入所有字母，</p><p id="d2f5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">然后它将在“a”和“t”之间插入所有的字母，</p><p id="a968" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">那么它将在“at”之后插入所有的字母，</p><p id="9e88" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">最后，我们将把所有这些单词添加到一个列表中。</p><p id="ca31" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如前所述，我使用列表理解来计算 insert_letter()，如下所示。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es je"><img src="../Images/f2e18fe68e210fcbc728e71dd2da4a5a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7Bwz_7rWh30Si8i7Wrz3Yg.png"/></div></div></figure><p id="cd02" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">正如你在下面看到的，我们用输入单词‘at’运行函数，它在每个偏移量插入字母后返回所有单词。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es je"><img src="../Images/ce9b1823e7ee260635e23dd2f9068d9d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MJhKWMgtWY2-AJNlw9v1cQ.png"/></div></div></figure><h1 id="b4fb" class="kr km hi bd ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln bi translated">6.组合字符串编辑</h1><p id="1003" class="pw-post-body-paragraph if ig hi ih b ii lo ik il im lp io ip iq lq is it iu lr iw ix iy ls ja jb jc hb bi translated">完成字符串操作后，我们将创建两个函数，即 edit_one_letter()和 edit_two_letters()，它们将一个字符串作为输入，并返回该字符串上所有可能的单次和两次编辑。</p><p id="9719" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们逐一理解和实现这两个功能。</p><p id="a0a8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> a) edit_one_letter() </strong></p><p id="92ec" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">此函数将一个字符串作为输入，并返回与输入字符串相距一个编辑距离的所有可能编辑的集合。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es je"><img src="../Images/f57f8618f19e18c11b0e2264747d8899.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iUBZlF_mkGwCtssY6dwnDQ.png"/></div></div></figure><p id="b517" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">正如您在上面看到的，该函数利用了我们之前实现的所有 4 个函数。我们还使用 set 来确保最终列表中没有重复的值。</p><p id="d86e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在我们将运行我们的函数并检查输入字符串“at”的输出。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es je"><img src="../Images/72c5f8ee403bcd6d2383743b6a4a2b95.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yQQQdG8Gu-tuzAngiwuyTQ.png"/></div></div></figure><p id="80f7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">输出是:</p><pre class="jf jg jh ji fd kg kh ki kj aw kk bi"><span id="353e" class="kl km hi kh b fi kn ko l kp kq">['a', 'aa', 'aat', 'ab', 'abt', 'ac', 'act', 'ad', 'adt', 'ae', 'aet', 'af', 'aft', 'ag', 'agt', 'ah', 'aht', 'ai', 'ait', 'aj', 'ajt', 'ak', 'akt', 'al', 'alt', 'am', 'amt', 'an', 'ant', 'ao', 'aot', 'ap', 'apt', 'aq', 'aqt', 'ar', 'art', 'as', 'ast', 'ata', 'atb', 'atc', 'atd', 'ate', 'atf', 'atg', 'ath', 'ati', 'atj', 'atk', 'atl', 'atm', 'atn', 'ato', 'atp', 'atq', 'atr', 'ats', 'att', 'atu', 'atv', 'atw', 'atx', 'aty', 'atz', 'au', 'aut', 'av', 'avt', 'aw', 'awt', 'ax', 'axt', 'ay', 'ayt', 'az', 'azt', 'bat', 'bt', 'cat', 'ct', 'dat', 'dt', 'eat', 'et', 'fat', 'ft', 'gat', 'gt', 'hat', 'ht', 'iat', 'it', 'jat', 'jt', 'kat', 'kt', 'lat', 'lt', 'mat', 'mt', 'nat', 'nt', 'oat', 'ot', 'pat', 'pt', 'qat', 'qt', 'rat', 'rt', 'sat', 'st', 't', 'ta', 'tat', 'tt', 'uat', 'ut', 'vat', 'vt', 'wat', 'wt', 'xat', 'xt', 'yat', 'yt', 'zat', 'zt']</span></pre><p id="10cd" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> b) edit_two_letters() </strong></p><p id="029b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">该函数将一个字符串作为输入，并返回一组与输入字符串相距两个编辑距离的所有可能的单词，这意味着它将首先获得输入单词的所有可能的编辑，然后对于每个这样的单词，它将再次找到所有可能的编辑。要实现这一点，我们只需要首先在输入单词上运行我们的字符串操作函数，然后在第一个函数的输出上再次运行。然后，我们将所有函数的结果组合起来，得到如下所示的最终结果。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es je"><img src="../Images/ae4b2fc7dc02ca1241cdd336a6155bfd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ahGWz5T2q70T3cvdU0OofA.png"/></div></div></figure><p id="e874" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">正如您在上面看到的，这个函数使用了所有 4 个字符串操作函数两次。我们还使用 set 来确保最终列表中没有重复的值。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es je"><img src="../Images/fa48a6d2c1182855b99c89e17e9a750b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WUjsWo1pxOYKbitCSsK_rg.png"/></div></div></figure><p id="8aaf" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如你所见，有 2654 个单词与单词“a”相距两个编辑距离。我还打印了 20 个这样的单词，如上图所示。</p><h1 id="fedf" class="kr km hi bd ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln bi translated">7.拼写建议</h1><p id="3bfd" class="pw-post-body-paragraph if ig hi ih b ii lo ik il im lp io ip iq lq is it iu lr iw ix iy ls ja jb jc hb bi translated">如您所见，我们创建了一个列表，列出了距离输入单词 1 和 2 的所有单词。现在，我们将使用这些单词来获得最可能的单词，这是我们想要写但错误地写错的实际单词。</p><p id="d06e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为此，我们将创建一个函数<strong class="ih hj"> get_corrections() </strong>，该函数将以一个给定的单词作为输入，然后返回一个 0 到 n 个建议元组的列表，其形式为(word，probability_of_word)。其中“单词”是可能的建议，“单词的概率”是“单词”是输入单词的正确拼写建议的概率。</p><p id="da7b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们将包含一个两步流程来生成最可能的拼写建议，如下所示:</p><blockquote class="ka kb kc"><p id="3095" class="if ig jd ih b ii ij ik il im in io ip kd ir is it ke iv iw ix kf iz ja jb jc hb bi translated"><em class="hi">第一步</em></p></blockquote><p id="f181" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在这一步中，我们将简单地使用前面讨论过的字符串操作为给定的单词生成一组建议。我们将遵循如下 5 步逻辑:</p><p id="ce3c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">a)如果该单词已经存在于词汇表中，建议使用它。</p><p id="3a6e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">b)否则，如果由 edit_one_letter()函数返回的单词存在于词汇表中，则建议它们。</p><p id="b816" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">c)否则，如果存在由 edit_two_letters()函数返回的词汇，则建议它们。</p><p id="8d80" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">d)否则，建议输入单词。</p><p id="02b0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这个想法是，编辑次数少的单词比编辑次数多的单词更有可能是正确的。</p><blockquote class="ka kb kc"><p id="eb14" class="if ig jd ih b ii ij ik il im in io ip kd ir is it ke iv iw ix kf iz ja jb jc hb bi translated"><em class="hi">第二步</em></p></blockquote><p id="c585" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在这一步中，我们将创建一个字典，它的关键字是一个单词，值是这个单词在我们的词汇表中出现的概率。如果这个单词不在词汇表中，我们将赋予它 0 的概率。</p><blockquote class="ka kb kc"><p id="42c0" class="if ig jd ih b ii ij ik il im in io ip kd ir is it ke iv iw ix kf iz ja jb jc hb bi translated"><em class="hi">第三步</em></p></blockquote><p id="0adc" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在这一步中，我们选择“n”个最佳建议。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es je"><img src="../Images/19e7a91a21fdc8c1f763cb6a9cc067a3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2yFtIPwv0AeX4hqqY_pbog.png"/></div></div></figure><p id="09cd" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">请注意，在第 25 行中，我已经根据概率的降序对 best_words 字典进行了排序，因此最有可能的单词将出现在列表的开头。</p><p id="22fc" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">正如你在下面看到的，我在一些单词上使用了 get_correction 函数，我们的模型给出了与之相关的单词。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es je"><img src="../Images/5c0d21b66654ace4af036f0593a96d74.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IsqQA-1_tJ903D9-8mIh2g.png"/></div></div></figure><h1 id="2537" class="kr km hi bd ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln bi translated">8.最小编辑距离</h1><p id="5f86" class="pw-post-body-paragraph if ig hi ih b ii lo ik il im lp io ip iq lq is it iu lr iw ix iy ls ja jb jc hb bi translated">现在我们已经实现了自动更正模型，下一步是确定如何评估两个字符串之间的相似性(比如“yef”和“yes”)，并有效地找到从一个单词到另一个单词的最短路径。最小编辑距离可以用来做到这一点。给定两个字符串，最小编辑距离是将一个给定字符串转换成另一个字符串所需的最小操作成本。为了计算最小编辑距离，我们将使用 3 个字符串操作，即插入、删除和替换。我们将利用动态编程逻辑，它将告诉我们将一个字符串转换成另一个字符串所需的最少编辑次数。</p><p id="548a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">例如，考虑两个字符串“爱好”和“潮湿”。现在，要将 hobby 转换为 soggy，我们需要将 h 替换为 s，将 b 替换为 g，并将下一个 b 替换为 g。</p><p id="f59e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">每个编辑操作都有相关的成本。正如你在上面看到的，它需要 3 个替换操作来将爱好转化为潮湿。如果我们认为一次替换操作的成本等于 2，那么从“爱好”到“潮湿”的最小编辑距离将等于 3*2 = 6。类似地，1 次插入操作的开销是 1，1 次删除操作的开销也是 1。请注意，替换操作可以视为一次删除+一次插入操作，因此一次替换操作的开销等于 2。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div class="er es lt"><img src="../Images/1a2d6d3c788e6a018ba0ec3e4ebac715.png" data-original-src="https://miro.medium.com/v2/resize:fit:1276/format:webp/1*Dimw4vG2cxZ2_ti16D0P5g.jpeg"/></div></figure><p id="ce6b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这种使用替换、插入和删除操作将一个字符串手动转换为另一个字符串的方法不适合长字符串，因为它在计算上开销很大，并且很耗时。</p><p id="5ade" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">或者，我们可以遵循基于动态规划的表格方法，这将比这种方法更有效。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es lu"><img src="../Images/7092ff9e56a71f8389adcd6b0fc60d00.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SCiyTj93kyolVLQeNqvxew.jpeg"/></div></div></figure><p id="91ed" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">正如你在上面看到的，我们必须将源单词“play”转换成目标单词“stay”。请注意，我们在两个单词的开头都附加了一个空字符串' # '，这在您执行进一步的步骤时会有意义。我们的目标是以这样一种方式填充这个矩阵，即第行、第列的每个值代表从源字到第行到目标字到第列的转换成本。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es lv"><img src="../Images/e4a9502d999b4cfff23749a9a24c30a2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HZdvF1a_MEKreJKKtFmUNg.jpeg"/></div></div></figure><p id="25a0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">例如，D[3，2]处的值表示将['pla']转换为['st'] ( 'play'[ : 3] = 'pla '，' stay'[ : 2] = 'st ')所需的成本。同样，D[2，2]处的值表示将['pl']转换为['st'] ( 'play'[ : 2] = 'pl '，' stay'[ : 2] = 'st ')所需的成本。该成本将表示最小编辑距离。</p><p id="26fe" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">D[i，j] =源[ : i] -&gt;目标[: j]</p><p id="a8be" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">D[i，j]将表示源[:i]和目标[:j]之间的最小编辑距离。</p><p id="2533" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">注意，我们将从(0，0)(左上角)的空字符串开始，一直到(4，4)(右下角)。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es lw"><img src="../Images/9b9fbd512d949262645734c84ca65aa7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*B61t2Qm_640yiIs18q353g.jpeg"/></div></div></figure><p id="f596" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如前所述，我们试图解决次要问题，并用它们来构建我们主要问题的解决方案。首先，我们开始寻找较小字符串之间的最小编辑距离，并不断增加字符串大小，以达到最终的解决方案。一旦我们开始填充我们的矩阵，这一切将变得更加清晰。</p><p id="2d1a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们先从空字符串(' # ')开始。</p><p id="306d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">由于源空字符串和目标空字符串都是“#”，因此它们之间的最小编辑距离是 0。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es lx"><img src="../Images/2eff220ab28e6912274278724a37550a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fRzIKlp-jnUBg9ZMbpwpyg.jpeg"/></div></div></figure><p id="c84a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在让我们前进到源字符串“play”中的第一个字母“p”。从' p '到空字符串' # '我们只需要一个删除操作。因此,( 1，0)处的值等于一个为 1 的删除操作的成本。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es lx"><img src="../Images/5db657209883a94c5f8e229dd8985081.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2Hltqvx20f0QIOdiP8r4dA.jpeg"/></div></div></figure><p id="e5ea" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在让我们前进到源字符串“stay”中的第一个字母“s”。从空字符串' # '到' s ',我们只需要一次插入操作。因此,( 0，1)处的值等于一个为 1 的插入操作的成本。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es ly"><img src="../Images/93bfc75bcc9135eec64798fd2c6f88b5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jDVli4h3H5NdkY7hSFg4CA.jpeg"/></div></div></figure><p id="2b1a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在让我们从 p 到 s。这可以通过三种方式实现。</p><p id="c1ff" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">a)直接用“s”替换“p”。</p><p id="787d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如前所述，我们可以使用一个替换操作将“p”替换为“s”。</p><p id="36f5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">成本= 2。</p><p id="731a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">b)使用插入+插入</p><p id="9aec" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">从 p 到 s，我们可以把 s 插入到 p 中得到 ps。然后我们可以删除 p，得到一个凝视的 s。请注意，在字符串中插入一个“s”的开销已经计算为(0，1)，等于 1。并且删除一个字符的成本是已知的，等于 1。因此，总成本将等于:</p><p id="5668" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">(插入一个‘s’的成本+删除一个‘p’的成本)= 1+1 = 2。</p><p id="061d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">c)使用删除+插入</p><p id="30f4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">要从' p '转到' s '，我们可以删除' p '得到一个空字符串。然后我们可以在空字符串中插入“s”得到“p”。请注意，删除一个“p”以获得一个空字符串的成本已经计算为(1，0)，等于 1。并且插入一个字符的成本是已知的，等于 1。因此，总成本将等于:</p><p id="77b4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">(删除‘p’的代价+插入‘s’的代价)= 1+1 = 2。</p><p id="c067" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">理想情况下，我们会比较所有 3 个选项的成本，并将最小成本分配给(1，1)。但在这种情况下，所有 3 个选项的成本都等于 2，因此我们将 2 指定为(1，1)。因此，从“p”到“s”的最小编辑距离等于 2。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es lz"><img src="../Images/5af2411611c56becbed3a09195ffe98a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BXTvMbgy8ru2STB67Rhlkg.jpeg"/></div></div></figure><p id="dcd2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">因此，为了填充矩阵中的任何单元，分别知道左侧、上部和相邻左上位置的值将是有帮助的。利用这一点，我们可以利用一些已经执行过的计算，而不需要再次执行它们。</p><p id="07fc" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">要填写第一列，我们可以使用下面的公式:</p><p id="72f4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">D[i，j] = D[i-1，j] +删除成本</p><p id="6853" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这等于:</p><p id="8719" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">D[i，j] = D[i-1，j] + 1。</p><p id="a672" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">因此，要填充第一列中的任何值，只需在前一个值上加 1。在填充了第一列中的所有值后，我们的矩阵如下所示:</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es ly"><img src="../Images/789d593ebfc5c391e4a07b40afd1fa89.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oMKt0NE3MqafX4QQANLNEQ.jpeg"/></div></div></figure><p id="9a48" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">同样，要填写第一行，我们可以使用下面的公式:</p><p id="1f46" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">D[i，j] = D[i，j+1] +插入成本</p><p id="285e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这等于:</p><p id="e294" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">D[i，j] = D[i +1，j] + 1。</p><p id="107e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">因此，要填充第一行中的任何值，只需在前一个值上加 1。在第一行中填入所有值后，我们的矩阵如下所示:</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es ma"><img src="../Images/53d01764c2a006f629057450a64879d0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yBm_c20Ln02IeJOV7ElURw.jpeg"/></div></div></figure><p id="6ad3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在我们将推广这个方法来填充矩阵的其余部分。请记住，我们可以通过左上单元格或相邻的左上单元格到达一个单元格。我们将通过这 3 种方式计算到达单元的成本，并为我们的单元选择 3 个值中的最低值。我们将归纳之前完成的计算，形成如下所示的最终公式。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es lv"><img src="../Images/0de674186f23b3fce569ca9973b002a3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OvnfMwgQVGujnDIe0fCiYg.jpeg"/></div></div></figure><p id="ce28" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">第一个公式通过左侧单元格，第二个公式通过右侧单元格，第三个公式通过相邻的上部单元格。对于第三个公式，如果源[i]和目标[j]相同，则公式为</p><p id="ca29" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">D[i-1，j-1] +0</p><p id="2f1a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果源[i]和目标[j]不同，则公式为</p><p id="575a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">D[i-1，j-1] +重置成本</p><p id="8241" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">运筹学</p><p id="490f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">D[i-1，j-1] + 2(因为替换成本= 2)。</p><p id="886f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在，您可以使用概括的公式来获得最终的矩阵。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es lu"><img src="../Images/892410b064ca603bbedf6cf52be474ac.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NcqjTv5tAFJKaKMR7psuYA.jpeg"/></div></div></figure><p id="e223" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">(4，4)处的值等于 4，表示源单词“play”和目标单词“stay”之间的最小编辑距离。这里值得注意的一点是(2，2)处的值等于 4。此后，对角线值(3，3)和(4，4)不变。这是因为源[2:4]和目标[2:4]是相同的，即“是”，因此不需要更多的编辑，这就是值不变的原因。</p><p id="1706" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在我们将编写一个函数 min_edit_distance，它将计算源单词和目标单词之间的最小编辑距离。该函数有 5 个参数:source，target，ins_cost = 1，del_cost = 1，rep_cost = 2。source 是源字符串，target 是目标字符串，ins_cost、del_cost、rep_cost 分别是删除、插入和替换开销。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es je"><img src="../Images/c7b0d52371b81541f862799f51a9d3c3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zMj-B2obBXi56rlUZ0xx5Q.png"/></div></div></figure><p id="96c0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在我们将在几个字符串上运行这个函数，看看结果。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es je"><img src="../Images/812e317ed03ab7857b592b08a8eb2c70.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*G4YxZE37XHXoJpsMqWvXNg.png"/></div></div></figure><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es je"><img src="../Images/0638f3fbadb537938fe71872a7a6f940.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*e-f2G-zgbqR2fgxNiPSpQw.png"/></div></div></figure><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es je"><img src="../Images/4fe292815bd91c030649e47123b62a77.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Iu5FPgdEtgQdUvAtR-57FQ.png"/></div></div></figure><p id="7777" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如您所见，我们的函数正确地返回了作为输入给出的单词对的成本矩阵。您可以通过手动计算这对单词的最小编辑距离来交叉检查输出。</p><p id="07fb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这就是 python 中这个简单而有效的自动纠正模型的全部内容。如果你到了这里，我坚信你一定会觉得很有趣。</p><p id="a910" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果代码中有可以优化模型的建议或修改或任何一般反馈，请随意在评论部分留下一些话，我将非常乐意为之工作。</p><p id="383f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">祝你好运:)</p></div></div>    
</body>
</html>