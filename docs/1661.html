<html>
<head>
<title>Speed up your Wordpress by loading 3rd party scripts on interaction</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">通过在交互中加载第三方脚本来加速你的Wordpress</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/speed-up-your-wordpress-by-loading-3rd-party-scripts-on-interaction-1abd146e87f?source=collection_archive---------4-----------------------#2021-03-31">https://medium.com/nerd-for-tech/speed-up-your-wordpress-by-loading-3rd-party-scripts-on-interaction-1abd146e87f?source=collection_archive---------4-----------------------#2021-03-31</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="8e5c" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">节省带宽并动态加载资源</h2></div><p id="0d79" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">Wordpress是一个非常受欢迎的内容管理系统，但是它的健壮性有一些缺点。你可能会面临性能问题，除非你的网站是非常好的优化，或者你只是在后端使用它，因为前端是静态生成的。然而，如果你运行了完整的Wordpress并且使用了第三方脚本，考虑动态加载它们。</p><p id="9498" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们可以使用<a class="ae jt" href="https://v8.dev/features/dynamic-import" rel="noopener ugc nofollow" target="_blank"> dynamic import() </a>在交互时延迟加载脚本，而不是在初始加载时加载所有资源，例如当用户单击按钮或滚动组件时。(这篇文章是关于Wordpress的，所以我们真的可以使用动态导入吗？请继续阅读，寻找答案。)</p><p id="9064" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">更具体地说，我将向您展示如何动态加载两个不同的库:</p><ul class=""><li id="0886" class="ju jv hi iz b ja jb jd je jg jw jk jx jo jy js jz ka kb kc bi translated"><a class="ae jt" href="https://www.jacklmoore.com/colorbox/" rel="noopener ugc nofollow" target="_blank">Colorbox</a>(jQuery的一个轻量级可定制lightbox插件)</li><li id="8e97" class="ju jv hi iz b ja kd jd ke jg kf jk kg jo kh js jz ka kb kc bi translated"><a class="ae jt" href="https://developers.google.com/maps/documentation/javascript/overview" rel="noopener ugc nofollow" target="_blank">谷歌地图JavaScript API </a>。</li></ul><p id="baac" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这些库是常用的，但是在我向你展示如何在交互中加载它们之前，让我们看看在Wordpress中加载Javascript文件的标准方式是什么，以及我们可能会面临什么挑战。</p><figure class="kj kk kl km fd kn er es paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="er es ki"><img src="../Images/930da5f3fbd8a5c41298797100e78af0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*VVKceY0JpkwIbGcc"/></div></div><figcaption class="ku kv et er es kw kx bd b be z dx translated">照片由<a class="ae jt" href="https://unsplash.com/@launchpresso?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">启动按压</a>上的<a class="ae jt" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a></figcaption></figure><h1 id="4225" class="ky kz hi bd la lb lc ld le lf lg lh li io lj ip lk ir ll is lm iu ln iv lo lp bi translated">将WP脚本入队</h1><p id="cdf6" class="pw-post-body-paragraph ix iy hi iz b ja lq ij jc jd lr im jf jg ls ji jj jk lt jm jn jo lu jq jr js hb bi translated">有一个functions.php文件，在那里我们必须使用<a class="ae jt" href="https://developer.wordpress.org/reference/functions/wp_enqueue_script/" rel="noopener ugc nofollow" target="_blank"><em class="lv">WP _ enqueue _ script</em></a>函数。例如，要加载一个<a class="ae jt" href="https://github.com/ganlanyuan/tiny-slider" rel="noopener ugc nofollow" target="_blank">微型滑块</a>库，我们可以执行以下操作:</p><pre class="kj kk kl km fd lw lx ly lz aw ma bi"><span id="df7d" class="mb kz hi lx b fi mc md l me mf"><em class="lv">function</em> my_scripts() {</span><span id="7a59" class="mb kz hi lx b fi mg md l me mf"><strong class="lx hj">wp_enqueue_script( ‘tiny-slider’,   ‘https://cdnjs.cloudflare.com/ajax/libs/tiny-slider/2.9.3/min/tiny-slider.js', array(), ‘20210327’, true );</strong></span><span id="b8cb" class="mb kz hi lx b fi mg md l me mf">// other scripts<br/>}<br/>add_action( 'wp_enqueue_scripts', 'my_scripts' );</span></pre><p id="b103" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这个函数中的所有脚本都被插入到网站的末尾(在结束的body标签之前)。为了减少请求的数量，我们可以将它们连接起来，并可能创建包含所有第三方代码的vendor.min.js。</p><p id="17d8" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如果我们只在某个页面(例如主页)上需要脚本，我们可以编写If语句并只在那里对其进行排队:</p><pre class="kj kk kl km fd lw lx ly lz aw ma bi"><span id="d994" class="mb kz hi lx b fi mc md l me mf"><em class="lv">if</em> (is_front_page()) { wp_enqueue_script(...) }</span></pre><p id="db58" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这就是我们在Wordpress中排列脚本的方式。这仍然给我们留下了性能问题。我们如何动态地加载它们呢？</p></div><div class="ab cl mh mi gp mj" role="separator"><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm"/></div><div class="hb hc hd he hf"><h1 id="abea" class="ky kz hi bd la lb mo ld le lf mp lh li io mq ip lk ir mr is lm iu ms iv lo lp bi translated">Javascript动态导入()和Wordpress</h1><p id="a94b" class="pw-post-body-paragraph ix iy hi iz b ja lq ij jc jd lr im jf jg ls ji jj jk lt jm jn jo lu jq jr js hb bi translated">如果您熟悉Javascript promises，您也会轻松处理动态导入，因为导入会加载一个模块并返回一个promise。在普通JS中，它看起来像这样:</p><pre class="kj kk kl km fd lw lx ly lz aw ma bi"><span id="2ab5" class="mb kz hi lx b fi mc md l me mf">import('module-name')<br/>.then( //do something here )<br/>.catch(err =&gt; { console.log(err) });</span></pre><blockquote class="mt mu mv"><p id="78b9" class="ix iy lv iz b ja jb ij jc jd je im jf mw jh ji jj mx jl jm jn my jp jq jr js hb bi translated">注意:也可以使用async/await语法。</p></blockquote><p id="9daf" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">但是在Wordpress中我们会有一个问题。由于WP的本质和它的文件系统，我们不能像在我们的主JS文件中那样使用它。我们最终会得到以下错误:</p><pre class="kj kk kl km fd lw lx ly lz aw ma bi"><span id="64c7" class="mb kz hi lx b fi mc md l me mf">ReferenceError: require is not defined</span></pre><p id="a080" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><a class="ae jt" href="https://developer.wordpress.org/block-editor/reference-guides/packages/packages-lazy-import/" rel="noopener ugc nofollow" target="_blank"><strong class="iz hj">@ WordPress/lazy-import</strong>T5】</a></p><p id="b151" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我发现了模仿动态导入()行为的<a class="ae jt" href="https://developer.wordpress.org/block-editor/reference-guides/packages/packages-lazy-import/" rel="noopener ugc nofollow" target="_blank">@ WordPress/lazy-import</a>NPM包，但是有一点很重要:</p><blockquote class="mt mu mv"><p id="67f1" class="ix iy lv iz b ja jb ij jc jd je im jf mw jh ji jj mx jl jm jn my jp jq jr js hb bi translated"><em class="hi">目前这种对</em> <code class="du mz na nb lx b">import</code> <em class="hi">的对齐是表面的，模块解析仍然使用</em><a class="ae jt" href="https://nodejs.org/docs/latest-v12.x/api/modules.html#modules_require_id" rel="noopener ugc nofollow" target="_blank"><em class="hi">CommonJS</em></a><code class="du mz na nb lx b"><a class="ae jt" href="https://nodejs.org/docs/latest-v12.x/api/modules.html#modules_require_id" rel="noopener ugc nofollow" target="_blank">require</a></code><em class="hi">，而不是更新的</em> <a class="ae jt" href="https://nodejs.org/docs/latest-v14.x/api/esm.html" rel="noopener ugc nofollow" target="_blank"> <em class="hi"> ES模块支持</em> </a> <em class="hi">。</em></p></blockquote><p id="c453" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">看起来WP和动态导入不能很好的结合在一起。安装require.js或设置webpack来启用代码分割看起来也是一项令人生畏的任务，这不是理想的方法。</p></div><div class="ab cl mh mi gp mj" role="separator"><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm"/></div><div class="hb hc hd he hf"><h2 id="9acb" class="mb kz hi bd la nc nd ne le nf ng nh li jg ni nj lk jk nk nl lm jo nm nn lo no bi translated"><a class="ae jt" href="https://www.toptal.com/designers/htmlarrows/symbols/black-right-pointing-index/" rel="noopener ugc nofollow" target="_blank"><strong class="ak"/></a><strong class="ak"/>自定义脚本加载器</h2><p id="0d96" class="pw-post-body-paragraph ix iy hi iz b ja lq ij jc jd lr im jf jg ls ji jj jk lt jm jn jo lu jq jr js hb bi translated">Google的一位工程经理Addy Osmani 写了一篇非常好的文章《交互模式的导入》，详细讨论了动态导入、第三方代码和相关技术的使用。正如他所说:</p><blockquote class="mt mu mv"><p id="fedd" class="ix iy lv iz b ja jb ij jc jd je im jf mw jh ji jj mx jl jm jn my jp jq jr js hb bi translated">第三方资源经常被添加到页面中，而没有充分考虑它们如何适应网站的整体负载。同步加载的第三方脚本会阻塞浏览器解析器，并会延迟水合。如果可能，3P脚本应该使用async/defer(或其他方法)加载，以确保1P脚本不会缺乏网络带宽。除非它们很关键，否则它们是使用交互导入等模式转移到延迟后加载的良好候选。</p></blockquote><p id="908f" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">对于普通的JS实现，他为我们提供了下面的脚本，我们可以将它放入Wordpress中。</p><figure class="kj kk kl km fd kn"><div class="bz dy l di"><div class="nr ns l"/></div></figure><p id="9024" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">它用我们需要的模块创建一个脚本标签，并把它附加到主体中。我们可以这样使用它:</p><pre class="kj kk kl km fd lw lx ly lz aw ma bi"><span id="0701" class="mb kz hi lx b fi mc md l me mf"><em class="lv">const</em> loader = new scriptLoader();</span><span id="dee3" class="mb kz hi lx b fi mg md l me mf">loader.load(['moduleURL']).then(() <em class="lv">=&gt;</em> {});</span></pre><p id="4457" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">现在让我们描述一下利用这个脚本的具体场景。</p><h1 id="7b51" class="ky kz hi bd la lb lc ld le lf lg lh li io lj ip lk ir ll is lm iu ln iv lo lp bi translated">外观也叫假组件</h1><p id="9c88" class="pw-post-body-paragraph ix iy hi iz b ja lq ij jc jd lr im jf jg ls ji jj jk lt jm jn jo lu jq jr js hb bi translated">外观是模拟基本体验的占位符组件。例如，它可以是Youtube视频播放器的图像或地图。我们不需要嵌入和加载必要的资源，我们可以节省带宽，只在用户与facade交互后加载它们。用户可能会点击、悬停或滚动组件。</p><figure class="kj kk kl km fd kn er es paragraph-image"><div class="er es nt"><img src="../Images/114e77bb24e5bffa2e9d7a12749a30bb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1268/format:webp/1*3NFQzFzpqespxq_biKkReA.png"/></div><figcaption class="ku kv et er es kw kx bd b be z dx translated"><a class="ae jt" href="https://addyosmani.com/blog/import-on-interaction/" rel="noopener ugc nofollow" target="_blank"> Youtube facade save +540KB </a></figcaption></figure><h2 id="5191" class="mb kz hi bd la nc nd ne le nf ng nh li jg ni nj lk jk nk nl lm jo nm nn lo no bi translated"><strong class="ak">装载彩盒</strong></h2><p id="726c" class="pw-post-body-paragraph ix iy hi iz b ja lq ij jc jd lr im jf jg ls ji jj jk lt jm jn jo lu jq jr js hb bi translated">我们有一个图像库，我们想在点击后显示在colorbox。用户实际上可能永远不会点击图像来查看弹出窗口中的大图。如果我们可以节省几千字节，为什么还要加载库呢？</p><p id="cb29" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">画廊本身不是一个门面，但它与我们可以推迟的功能有关。在下面的例子中，当用户将鼠标悬停在图库中的任何图像上时，我会加载colorbox。点击后，库已被加载，弹出窗口显示。</p><figure class="kj kk kl km fd kn er es paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="er es nu"><img src="../Images/a58190df7848e29ef7f03a2bf0f61464.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9Afqav8hkQtJPkMHQAKGuQ.png"/></div></div><figcaption class="ku kv et er es kw kx bd b be z dx translated">将鼠标悬停在任何图像上都会加载颜色盒库</figcaption></figure><pre class="kj kk kl km fd lw lx ly lz aw ma bi"><span id="647d" class="mb kz hi lx b fi mc md l me mf">var appendedColorbox = false;</span><span id="cb81" class="mb kz hi lx b fi mg md l me mf">$( 'body' ).on( 'mouseenter', '.gallery-image', <em class="lv">function</em>() {</span><span id="44f7" class="mb kz hi lx b fi mg md l me mf"><em class="lv">  const</em> loader = new lpa.scriptLoader();  <br/>  // check if the library was already loaded<br/>  <em class="lv">if</em>(appendedColorbox) {<em class="lv">return</em>};</span><span id="a7f2" class="mb kz hi lx b fi mg md l me mf">loader.load(['https://cdnjs.cloudflare.com/ajax/libs/jquery.colorbox/1.6.4/jquery.colorbox-min.js'])<br/>  .then(() <em class="lv">=&gt;</em> {<br/>    appendedColorbox = true;<br/>  });</span><span id="bbab" class="mb kz hi lx b fi mg md l me mf">});</span></pre><p id="121b" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在这段代码中，我们监听“mouseenter”事件，初始化scriptLoader并加载colorbox库。</p><h2 id="5f26" class="mb kz hi bd la nc nd ne le nf ng nh li jg ni nj lk jk nk nl lm jo nm nn lo no bi translated"><a class="ae jt" href="https://developers.google.com/maps/documentation/javascript/examples/programmatic-load-button#maps_programmatic_load_button-javascript" rel="noopener ugc nofollow" target="_blank">延迟加载动态地图</a></h2><p id="d42c" class="pw-post-body-paragraph ix iy hi iz b ja lq ij jc jd lr im jf jg ls ji jj jk lt jm jn jo lu jq jr js hb bi translated">下面是一个合适的外观示例。不是完全加载的谷歌地图，而是只有一个带有按钮的地图图像，上面写着加载动态地图。</p><figure class="kj kk kl km fd kn er es paragraph-image"><div class="er es nv"><img src="../Images/3c20c0780f6ff9dcb081a6399a90adba.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/1*cKDmfbG1-W2zfm8LyLTrkA.gif"/></div></figure><p id="79b7" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这个例子取自谷歌官方网站，它使用静态地图API。不幸的是，我们的自定义脚本加载器不支持谷歌地图(它抛出了CORS策略错误)，而且<strong class="iz hj">谷歌有自己的加载器</strong>我们必须使用<a class="ae jt" href="https://www.npmjs.com/package/@googlemaps/js-api-loader" rel="noopener ugc nofollow" target="_blank">@ Google maps/js-API-loader</a>。</p><h1 id="eee9" class="ky kz hi bd la lb lc ld le lf lg lh li io lj ip lk ir ll is lm iu ln iv lo lp bi translated">摘要</h1><p id="875f" class="pw-post-body-paragraph ix iy hi iz b ja lq ij jc jd lr im jf jg ls ji jj jk lt jm jn jo lu jq jr js hb bi translated">当加载第三方资源时，交互模式的导入非常有用和重要。在这篇文章中，我主要关注如何将它集成到Wordpress中，因为它仍然是最流行的CMS之一。因为它不是无头的，我们应该考虑性能影响。</p><p id="5b61" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">通过利用facade技术，我们可以通过动态加载资源来节省大量的千字节。由于Wordpress的工作方式，我们不得不克服一些挑战，但是感谢Addy Osmani的脚本加载器，我们能够在交互中加载脚本。</p></div></div>    
</body>
</html>