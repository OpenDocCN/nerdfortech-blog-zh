<html>
<head>
<title>Understanding AdaBoost</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">了解 AdaBoost</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/understanding-adaboost-5f1f1750160d?source=collection_archive---------11-----------------------#2021-02-22">https://medium.com/nerd-for-tech/understanding-adaboost-5f1f1750160d?source=collection_archive---------11-----------------------#2021-02-22</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="600d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">AdaBoost 是自适应学习算法，它以顺序的方式反复调用弱学习算法进行学习。它适应个体弱假设的错误率。这是它名字的基础——“ada”的意思是适应的。这是一个整体增压模型。</p><p id="df28" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">首先让我们看看什么是升压，然后了解 AdaBoost 是如何工作的。</p><h1 id="ac5f" class="jd je hi bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">助推</h1><p id="1871" class="pw-post-body-paragraph if ig hi ih b ii kb ik il im kc io ip iq kd is it iu ke iw ix iy kf ja jb jc hb bi translated">助推是一种将一群弱学习者组合成强学习者的技术。</p><p id="232f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">弱学习者是性能很差的分类器(准确率比随机猜测略好)。相比之下，强学习者是具有任意高准确度的分类器。</p><p id="f19e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Boosting 思想是按顺序训练弱学习者，每个人都试图纠正其前任。这意味着，算法总是要学习一些并不总是完全准确的东西，但通过顺序纠正错误，它提高了预测能力。</p><figure class="kh ki kj kk fd kl er es paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="er es kg"><img src="../Images/6ff31b2fa9995fce536882309e133538.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Mn8JMQ9Lw4cvjUJE3ruZjw.png"/></div></div><figcaption class="ks kt et er es ku kv bd b be z dx translated">面向数据科学的图像</figcaption></figure><p id="d970" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在 boosting 中选择和组合弱学习者的方式取决于方法/算法。例如 AdaBoost、Gradientboost、XGboost。</p><h1 id="b76d" class="jd je hi bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">adaboost 算法</h1><p id="ac83" class="pw-post-body-paragraph if ig hi ih b ii kb ik il im kc io ip iq kd is it iu ke iw ix iy kf ja jb jc hb bi translated">AdaBoost 算法首先在原始数据集上拟合一个弱分类器，产生一个输出假设，然后迭代地重新加权错误分类的数据，以拟合下一个弱分类器。每个弱学习器被分配一个系数，使得得到的提升分类器的训练误差之和最小。</p><p id="4ba4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">训练 AdaBoost 分类器包括迭代学习以与弱学习者的表现相关的方式加权的弱分类器，并将它们添加到最终的强分类器。在添加弱学习者之后，输入数据权重被调整，称为“重新加权”。</p><p id="6021" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">重新加权意味着错误分类的输入数据将获得更多权重，而正确分类的数据将失去权重。因此，下一个弱学习者更关注先前弱学习者误分类的数据。</p><p id="6347" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">AdaBoost 分类器中常用的弱学习器是称为决策树桩的单分裂决策树。</p><figure class="kh ki kj kk fd kl er es paragraph-image"><div class="er es kw"><img src="../Images/ecbb2806e5021f41f37cf412c00ffc9e.png" data-original-src="https://miro.medium.com/v2/resize:fit:742/format:webp/1*R4KP_xeCSbNQZHjmfN3Fxg.png"/></div><figcaption class="ks kt et er es ku kv bd b be z dx translated">作者图片</figcaption></figure><h1 id="bb29" class="jd je hi bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">分类器的系数</h1><p id="6ad5" class="pw-post-body-paragraph if ig hi ih b ii kb ik il im kc io ip iq kd is it iu ke iw ix iy kf ja jb jc hb bi translated">AdaBoost 使用重新加权的样本数据训练一系列分类器(弱学习器)，根据误差为各个分类器生成系数<strong class="ih hj"> α </strong>。这个系数决定了这个弱分类器对最终组合分类器的贡献。</p><p id="9588" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> α </strong>查看分类器产生的错误。从下图中可以看出，当误差较大时，<strong class="ih hj"> α </strong>较小，即在投票中有误差的分类器重要性较低。当误差较低时，<strong class="ih hj"> α </strong>较大，这意味着在投票中较高的重要性。</p><figure class="kh ki kj kk fd kl er es paragraph-image"><div class="er es kx"><img src="../Images/df77017c738d85842ac36183937501a4.png" data-original-src="https://miro.medium.com/v2/resize:fit:768/format:webp/1*8SQiGQ-Qwn_kKZp8NDx9sQ.png"/></div><figcaption class="ks kt et er es ku kv bd b be z dx translated">图像编码器包</figcaption></figure><p id="8dc9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">最终组合分类器的预测是通过加权投票完成的。当测试数据通过每个分类器时，预测输出将是将数据分类到特定类别的每个分类器的系数总和的最大值。</p><p id="e3fd" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">从下面的例子可以详细理解这个过程。</p><h1 id="b6cb" class="jd je hi bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">例子</h1><p id="2e1a" class="pw-post-body-paragraph if ig hi ih b ii kb ik il im kc io ip iq kd is it iu ke iw ix iy kf ja jb jc hb bi translated">假设有 2 个蓝色和棕色类，用于训练的样本数据集有 8 个点(4 个黑色和 4 个黄色)，如果输出应将所有黑色点分类为蓝色类，将所有黄色点分类为棕色类:</p><p id="a50b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">对于第一次迭代，所有点的权重都是 1/8。当数据传递到第一个弱分类器时，它预测 3 个点属于蓝色类，5 个点属于棕色类。</p><figure class="kh ki kj kk fd kl er es paragraph-image"><div class="er es ky"><img src="../Images/979e3f83f8dcbf8cb677758ccfa75780.png" data-original-src="https://miro.medium.com/v2/resize:fit:1388/format:webp/1*ec6N_v37yPivK4RZT2CwdQ.png"/></div><figcaption class="ks kt et er es ku kv bd b be z dx translated">作者图片</figcaption></figure><p id="c19e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">因此，第一分类器将 1 个黑点误分类为棕色类。因此，对于第二次迭代，该错误分类的黑点权重增加，而其他点的权重减少。即误分类黑点的权重增加到<strong class="ih hj"> 5/12 </strong>，剩余点的权重减少到<strong class="ih hj"> 1/12 </strong>(在任何时候，所有样本数据的权重之和应该总是 1。因此，执行权重的归一化)。</p><p id="3899" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在，新的加权数据集通过第二个分类器。</p><figure class="kh ki kj kk fd kl er es paragraph-image"><div class="er es kz"><img src="../Images/4d165418d03a3df3bc4896af7833ceff.png" data-original-src="https://miro.medium.com/v2/resize:fit:1376/format:webp/1*nHbOrCW5ACXEzeV3iulQVw.png"/></div><figcaption class="ks kt et er es ku kv bd b be z dx translated">作者图片</figcaption></figure><p id="e0cf" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">第二分类器将 5 个点分类为蓝色类，将 3 个点分类为棕色类。虽然该分类器正确地将先前误分类的黑点分类到蓝色类别，但是该分类器将一个黄色点误分类到棕色类别。因此，再次调整权重，使得错误分类的黄点的权重增加，而正确分类的数据的权重减少，即，新的更新的权重将是 1/16，1/16，1/16，<strong class="ih hj"> 6/16，4/16 </strong>，1/16，1/16，1/16(权重被归一化以使总和为 1)。</p><p id="8988" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这个训练过程一直持续到所有的训练数据点都被正确地分类到蓝色和棕色类别中。</p><p id="d204" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在上面的<strong class="ih hj">例子中</strong>经过训练，如果我们最终得到 5 个弱分类器，每个分类器的<strong class="ih hj"> α(系数)</strong>为 0.8，0.6，0.3，0.5，0.4。</p><p id="26a7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">假设对于<strong class="ih hj">一个</strong> <strong class="ih hj">测试</strong>数据点，如果具有<strong class="ih hj"> α </strong> 0.4 和 0.6 的 2 个分类器预测该测试数据点属于蓝色类，并且具有<strong class="ih hj"> α </strong> 0.8，0.3，0.5 的 3 个分类器预测该测试点属于棕色类，则最终预测将是具有最高加权投票的类。即具有最大总和<strong class="ih hj"> α的类别。</strong></p><p id="fc08" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">即最大值为 0.4 +0.6 =1.0(蓝色级)和 0.3+0.5+0.4 = 1.6(棕色级)。所以，最终输出是该点属于布朗类(因为 sum=1.6)。</p><h1 id="0513" class="jd je hi bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">伪代码</h1><p id="eea1" class="pw-post-body-paragraph if ig hi ih b ii kb ik il im kc io ip iq kd is it iu ke iw ix iy kf ja jb jc hb bi translated">这是 AdaBoost 算法的伪代码。</p><ol class=""><li id="535f" class="la lb hi ih b ii ij im in iq lc iu ld iy le jc lf lg lh li bi translated">初始化输入数据的权重 W: W1，W2，W3，…，Wn=1/n</li><li id="e66c" class="la lb hi ih b ii lj im lk iq ll iu lm iy ln jc lf lg lh li bi translated">对于每次迭代，i = 1: T</li></ol><ul class=""><li id="f79d" class="la lb hi ih b ii ij im in iq lc iu ld iy le jc lo lg lh li bi translated">使用由 w 加权的数据训练每个弱学习算法。这产生弱分类器假设<strong class="ih hj"> C </strong>。</li><li id="f54b" class="la lb hi ih b ii lj im lk iq ll iu lm iy ln jc lo lg lh li bi translated">使用以下公式计算分类器系数α</li></ul><figure class="kh ki kj kk fd kl er es paragraph-image"><div class="er es lp"><img src="../Images/36567172fb5949ab90fa885d689fcb2f.png" data-original-src="https://miro.medium.com/v2/resize:fit:360/format:webp/1*z9Wm4JTiuNe9wagESZZAHQ.png"/></div><figcaption class="ks kt et er es ku kv bd b be z dx translated">面向数据科学的图像</figcaption></figure><p id="3f02" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">其中误差是错误分类数据的权重之和</p><ul class=""><li id="0213" class="la lb hi ih b ii ij im in iq lc iu ld iy le jc lo lg lh li bi translated">将权重更新为:</li></ul><figure class="kh ki kj kk fd kl er es paragraph-image"><div class="er es lq"><img src="../Images/83ade9ef9342c49daf6146728d4bf1f0.png" data-original-src="https://miro.medium.com/v2/resize:fit:600/format:webp/0*LJ83GWyu0Jhq4l-n.png"/></div><figcaption class="ks kt et er es ku kv bd b be z dx translated">面向数据科学的图像</figcaption></figure><figure class="kh ki kj kk fd kl er es paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="er es lq"><img src="../Images/2ccab0edb32db44658c21072847cfc27.png" data-original-src="https://miro.medium.com/v2/resize:fit:600/format:webp/0*8R6wlnpiQVgxdokC.png"/></div></div><figcaption class="ks kt et er es ku kv bd b be z dx translated">面向数据科学的图像</figcaption></figure><ul class=""><li id="def4" class="la lb hi ih b ii ij im in iq lc iu ld iy le jc lo lg lh li bi translated">归一化权重，使权重之和等于 1</li></ul><p id="4d49" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">3.模型的输出通过加权投票完成。预测是将数据分类到特定类别 k 的每个分类器的系数之和的最大值</p><figure class="kh ki kj kk fd kl er es paragraph-image"><div class="er es lr"><img src="../Images/46e7f0d1b0d62522c2a7b810ba601e70.png" data-original-src="https://miro.medium.com/v2/resize:fit:758/format:webp/1*wypDAuLRfE0zgyiOJ0k89g.png"/></div><figcaption class="ks kt et er es ku kv bd b be z dx translated">面向数据科学的图像</figcaption></figure><h1 id="eb17" class="jd je hi bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">用 Python 实现</h1><p id="db7f" class="pw-post-body-paragraph if ig hi ih b ii kb ik il im kc io ip iq kd is it iu ke iw ix iy kf ja jb jc hb bi translated">Scikit-learn 提供 AdaBoost 分类器的实现。我们所需要做的就是用数据填充 AdaBoost 分类器，并传递参数，如要使用哪个弱学习算法以及 boosting 的迭代次数等。一切都是在 AdaBoost 分类器中完成的。</p><p id="f305" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">class sk learn . ensemble . adaboostclassifier(base _ estimator，n_estimators，learning_rate，algorithm，random_state) </strong></p><p id="fb59" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">kaggle 的示例代码片段:</p><pre class="kh ki kj kk fd ls lt lu lv aw lw bi"><span id="1781" class="lx je hi lt b fi ly lz l ma mb">from sklearn.ensemble import AdaBoostClassifier<br/>model=AdaBoostClassifier(base_estimator=DecisionTreeClassifier(max_depth=2),learning_rate=0.1,n_estimators=100,) <br/>model.fit(train_X,train_y) <br/>prediction=model.predict(test_X)<br/>print('The accuracy is',metrics.accuracy_score(test_y,prediction))</span></pre><p id="6147" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">以下是 AdaBoost 分类器的<strong class="ih hj">参数</strong>:</p><ol class=""><li id="8e95" class="la lb hi ih b ii ij im in iq lc iu ld iy le jc lf lg lh li bi translated">这个参数告诉 AdaBoost 要选择哪个弱学习分类器。默认值是 max_depth = 1 的决策树分类器。</li><li id="7593" class="la lb hi ih b ii lj im lk iq ll iu lm iy ln jc lf lg lh li bi translated"><strong class="ih hj"> n_estimators </strong>:该参数给出了估算器(迭代)的最大数量，在该数量时增强终止。默认值为 50。</li><li id="b979" class="la lb hi ih b ii lj im lk iq ll iu lm iy ln jc lf lg lh li bi translated"><strong class="ih hj"> learning_rate </strong>:该参数告诉分类器的学习对输入数据权重的贡献。如果学习率降低，则输入权重会降低 learning_rate 倍，从而迫使模型训练速度变慢。默认值为 1。低学习率需要更多的 n 估计量。</li><li id="29b4" class="la lb hi ih b ii lj im lk iq ll iu lm iy ln jc lf lg lh li bi translated"><strong class="ih hj">算法</strong>:该参数告知 SAMME 或 SAMME 的哪个升压算法。r 待定。萨姆。r 要求 base_estimator 支持类概率的计算。SAMME 支持多分类。默认为 SAMME.R。</li><li id="c3c3" class="la lb hi ih b ii lj im lk iq ll iu lm iy ln jc lf lg lh li bi translated"><strong class="ih hj"> random_state </strong>:该参数影响返回结果的再现性。默认值为无。</li></ol><h1 id="694b" class="jd je hi bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">AdaBoost 的利与弊</h1><p id="c581" class="pw-post-body-paragraph if ig hi ih b ii kb ik il im kc io ip iq kd is it iu ke iw ix iy kf ja jb jc hb bi translated"><strong class="ih hj">优点:</strong></p><ol class=""><li id="1d18" class="la lb hi ih b ii ij im in iq lc iu ld iy le jc lf lg lh li bi translated">它快速、简单且易于编程。</li><li id="b73b" class="la lb hi ih b ii lj im lk iq ll iu lm iy ln jc lf lg lh li bi translated">减少偏差</li><li id="b224" class="la lb hi ih b ii lj im lk iq ll iu lm iy ln jc lf lg lh li bi translated">它被扩展到二进制分类以外的问题</li></ol><p id="05b4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">缺点:</strong></p><ol class=""><li id="091f" class="la lb hi ih b ii ij im in iq lc iu ld iy le jc lf lg lh li bi translated">它易受噪音影响</li><li id="6a57" class="la lb hi ih b ii lj im lk iq ll iu lm iy ln jc lf lg lh li bi translated">可能导致数据过度拟合</li></ol><h1 id="8b5a" class="jd je hi bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">来源</h1><ul class=""><li id="797c" class="la lb hi ih b ii kb im kc iq mc iu md iy me jc lo lg lh li bi translated">增压算法解释:</li></ul><p id="6486" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><a class="ae mf" href="https://towardsdatascience.com/boosting-algorithms-explained-d38f56ef3f30" rel="noopener" target="_blank">https://towards data science . com/boosting-algorithms-explained-d 38 f 56 ef 3 f 30</a></p><ul class=""><li id="dca6" class="la lb hi ih b ii ij im in iq lc iu ld iy le jc lo lg lh li bi translated">在 Python 中理解和实现 AdaBoost 算法；</li></ul><p id="56e5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><a class="ae mf" href="https://coderspacket.com/understanding-and-implementing-adaboost-algorithm-ensemble-learning" rel="noopener ugc nofollow" target="_blank">https://coders packet . com/understanding-and-implementing-AdaBoost-algorithm-ensemble-learning</a></p><ul class=""><li id="5c5b" class="la lb hi ih b ii ij im in iq lc iu ld iy le jc lo lg lh li bi translated">AdaBoost 算法:</li></ul><p id="55a5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">https://www.educba.com/adaboost-algorithm/<a class="ae mf" href="https://www.educba.com/adaboost-algorithm/" rel="noopener ugc nofollow" target="_blank"/></p><p id="afcb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="mg">原载于 2021 年 2 月 22 日 https://numpyninja.com<em class="mg"/><a class="ae mf" href="https://www.numpyninja.com/post/understanding-adaboost" rel="noopener ugc nofollow" target="_blank">。</a></em></p></div></div>    
</body>
</html>