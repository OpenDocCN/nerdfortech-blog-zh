<html>
<head>
<title>A Crash Course in Caching</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">缓存速成班</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/getting-that-cache-money-1f93aea4f6ef?source=collection_archive---------6-----------------------#2021-03-08">https://medium.com/nerd-for-tech/getting-that-cache-money-1f93aea4f6ef?source=collection_archive---------6-----------------------#2021-03-08</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="7091" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">缓存原理介绍</h2></div><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ix"><img src="../Images/2e205ac9407ca0cc1b47d33b6466c088.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*no_PF_nw_F2ttDzR"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">使用缓存提高应用速度</figcaption></figure><h1 id="f6ce" class="jn jo hi bd jp jq jr js jt ju jv jw jx io jy ip jz ir ka is kb iu kc iv kd ke bi translated">观众</h1><p id="80a2" class="pw-post-body-paragraph kf kg hi kh b ki kj ij kk kl km im kn ko kp kq kr ks kt ku kv kw kx ky kz la hb bi translated">本文的目标读者是对互联网功能、当代应用程序架构和 AWS 有合理理解的开发人员。</p><p id="fa56" class="pw-post-body-paragraph kf kg hi kh b ki lb ij kk kl lc im kn ko ld kq kr ks le ku kv kw lf ky kz la hb bi translated">它将涵盖什么是更一般意义上的缓存，使用它背后的动机，然后深入到具体的实现。</p><h1 id="4b13" class="jn jo hi bd jp jq jr js jt ju jv jw jx io jy ip jz ir ka is kb iu kc iv kd ke bi translated">争吵</h1><p id="8937" class="pw-post-body-paragraph kf kg hi kh b ki kj ij kk kl km im kn ko kp kq kr ks kt ku kv kw kx ky kz la hb bi translated">高速缓存将先前使用或计算的数据存储在高速数据存储中，以使其比在主存储层中更快可用。一般来说，我们会使用硬件，如内存。</p><p id="dbcd" class="pw-post-body-paragraph kf kg hi kh b ki lb ij kk kl lc im kn ko ld kq kr ks le ku kv kw lf ky kz la hb bi translated">例如，我们可能会将喜欢的外卖保存为配送应用程序中的收藏夹。我们不是每次都在应用程序中搜索外卖，而是去我们最喜欢的部分。这实际上充当了我们的缓存。</p><p id="cd53" class="pw-post-body-paragraph kf kg hi kh b ki lb ij kk kl lc im kn ko ld kq kr ks le ku kv kw lf ky kz la hb bi translated">高速缓存的优势包括:</p><ul class=""><li id="0b4c" class="lg lh hi kh b ki lb kl lc ko li ks lj kw lk la ll lm ln lo bi translated"><strong class="kh hj">降低数据库成本:</strong>如果您的数据库实施按 IOPS(每秒输入/输出)收费，那么高速缓存可以帮助降低成本。</li><li id="76c8" class="lg lh hi kh b ki lp kl lq ko lr ks ls kw lt la ll lm ln lo bi translated"><strong class="kh hj">降低后端负载:</strong>如果相同的查询正在轰击后端，那么通过引入缓存，我们可以降低后端负载。这与上述降低数据库成本的观点相结合，因为这意味着我们的主数据存储可以更小。</li><li id="2671" class="lg lh hi kh b ki lp kl lq ko lr ks ls kw lt la ll lm ln lo bi translated"><strong class="kh hj">提高应用程序性能</strong>:如前所述，缓存结果的检索要快得多。</li><li id="883d" class="lg lh hi kh b ki lp kl lq ko lr ks ls kw lt la ll lm ln lo bi translated"><strong class="kh hj">可预测的性能:</strong>传统数据存储上的高流量事件会导致锁定和其他性能问题。通过高吞吐量缓存，我们可以减少这种情况。</li><li id="3092" class="lg lh hi kh b ki lp kl lq ko lr ks ls kw lt la ll lm ln lo bi translated"><strong class="kh hj">消除数据库热点:</strong>我们数据库中的一些数据可能比其他数据被更频繁地访问。纯粹基于此来扩展我们的整个数据库是没有意义的。</li></ul><p id="1d2d" class="pw-post-body-paragraph kf kg hi kh b ki lb ij kk kl lc im kn ko ld kq kr ks le ku kv kw lf ky kz la hb bi translated">现在，我们已经从概念上介绍了缓存及其优势，让我们深入了解使用案例。</p><h2 id="044c" class="lu jo hi bd jp lv lw lx jt ly lz ma jx ko mb mc jz ks md me kb kw mf mg kd mh bi translated">CDN 缓存</h2><p id="154d" class="pw-post-body-paragraph kf kg hi kh b ki kj ij kk kl km im kn ko kp kq kr ks kt ku kv kw kx ky kz la hb bi translated">首先，让我们回顾一下内容交付网络(CDN)的目的。</p><p id="b407" class="pw-post-body-paragraph kf kg hi kh b ki lb ij kk kl lc im kn ko ld kq kr ks le ku kv kw lf ky kz la hb bi translated">CDN 是遍布全球的许多服务器，目的是提供互联网内容的快速传送。它允许有效加载互联网内容资产，如 HTML、CSS、JavaScript、视频和图像。</p><p id="7ba1" class="pw-post-body-paragraph kf kg hi kh b ki lb ij kk kl lc im kn ko ld kq kr ks le ku kv kw lf ky kz la hb bi translated">例如，我们可能在伦敦托管我们的服务器，但是在费城访问网页。通过在纽约建立一个存在点(POP)或边缘服务器，我们可以更快地将内容传送到费城。</p><p id="7261" class="pw-post-body-paragraph kf kg hi kh b ki lb ij kk kl lc im kn ko ld kq kr ks le ku kv kw lf ky kz la hb bi translated">总体而言，cdn 通过规避 DDOS 攻击，缩短了网站加载时间，降低了带宽成本，提高了内容可用性并提高了安全性。</p><p id="3640" class="pw-post-body-paragraph kf kg hi kh b ki lb ij kk kl lc im kn ko ld kq kr ks le ku kv kw lf ky kz la hb bi translated">AWS CDN 产品是<a class="ae mi" href="https://aws.amazon.com/cloudfront/" rel="noopener ugc nofollow" target="_blank"> CloudFront </a>，它可以通过<a class="ae mi" href="https://aws.amazon.com/lambda/edge/" rel="noopener ugc nofollow" target="_blank"> Lambda@Edge </a>提供的计算能力得到增强。CloudFront 服务器充当缓存，位于边缘位置，提供资产的缓存版本。</p><p id="23d6" class="pw-post-body-paragraph kf kg hi kh b ki lb ij kk kl lc im kn ko ld kq kr ks le ku kv kw lf ky kz la hb bi translated">例如，我们可能从一个 S3 桶提供一个静态网站。然后，我们可以设置 CloudFront 来缓存站点，并设置 edge Lambda 来向请求添加安全头。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es mj"><img src="../Images/b3abdac67072ef9a048a8dcf66e5db1e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1162/format:webp/1*jWN95S0x4PQWoJPDvYp0mw.png"/></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">在 AWS 中使用 CDN 缓存信息的示例</figcaption></figure><h2 id="cbe0" class="lu jo hi bd jp lv lw lx jt ly lz ma jx ko mb mc jz ks md me kb kw mf mg kd mh bi translated">DNS 缓存</h2><p id="9c86" class="pw-post-body-paragraph kf kg hi kh b ki kj ij kk kl km im kn ko kp kq kr ks kt ku kv kw kx ky kz la hb bi translated">在介绍 DNS 缓存之前，我们先介绍一下 DNS。</p><p id="b47d" class="pw-post-body-paragraph kf kg hi kh b ki lb ij kk kl lc im kn ko ld kq kr ks le ku kv kw lf ky kz la hb bi translated">当我们在浏览器中加载一个网站时，我们输入一个 URL，比如<code class="du mk ml mm mn b">https://medium.com</code>。然后，我们的浏览器向路由器询问该网站的 IP 地址，以便检索文件。路由器转到 DNS 服务器并找到 IP 地址，之后你的浏览器就可以加载页面了。</p><p id="9b08" class="pw-post-body-paragraph kf kg hi kh b ki lb ij kk kl lc im kn ko ld kq kr ks le ku kv kw lf ky kz la hb bi translated">DNS 缓存是您机器上的一个临时数据库，包含最近 URL 到 IP 地址映射的记录。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es mo"><img src="../Images/fa364c05c57fbac9b664b1ac7fe8af6a.png" data-original-src="https://miro.medium.com/v2/resize:fit:578/format:webp/1*s2UsVhhuTqwuWy59OtxZBA.png"/></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">DNS 解析和缓存的示例流程</figcaption></figure><p id="6273" class="pw-post-body-paragraph kf kg hi kh b ki lb ij kk kl lc im kn ko ld kq kr ks le ku kv kw lf ky kz la hb bi translated">值得注意的是，内部的 ISP 和 DNS 服务器也会做自己的缓存！</p><h2 id="7441" class="lu jo hi bd jp lv lw lx jt ly lz ma jx ko mb mc jz ks md me kb kw mf mg kd mh bi translated">Web 缓存</h2><p id="0438" class="pw-post-body-paragraph kf kg hi kh b ki kj ij kk kl km im kn ko kp kq kr ks kt ku kv kw kx ky kz la hb bi translated">Web 缓存通过在缓存中保留 HTTP 响应和 web 资源来提高网站的响应能力。这个缓存可以驻留在浏览器中，或者在服务器端，它使用一个反向代理(比如<a class="ae mi" href="https://varnish-cache.org/intro/index.html#intro" rel="noopener ugc nofollow" target="_blank"> Varnish </a>)或者一个 web 应用加速器。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es mp"><img src="../Images/aa189a25f9af58496d342f508e34f23a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7peEEF8vtHQnJ2HII3WZJg.png"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">HTTP 缓存层的一个例子</figcaption></figure><p id="6467" class="pw-post-body-paragraph kf kg hi kh b ki lb ij kk kl lc im kn ko ld kq kr ks le ku kv kw lf ky kz la hb bi translated">这两者(和 cdn)都是由 HTTP 缓存头驱动的。它们驻留在 HTTP 响应上，并允许资源告诉缓存将它们存储多长时间。</p><p id="a51f" class="pw-post-body-paragraph kf kg hi kh b ki lb ij kk kl lc im kn ko ld kq kr ks le ku kv kw lf ky kz la hb bi translated">需要注意的核心头是<code class="du mk ml mm mn b">Cache-Control</code>,它指出谁应该缓存响应、何时缓存以及缓存多长时间。总的来说，它具有以下形式:</p><pre class="iy iz ja jb fd mq mn mr ms aw mt bi"><span id="3bdf" class="lu jo hi mn b fi mu mv l mw mx">Cache-Control: public/private, max-age=0, no-cache/no-store, must-revalidate, proxy-revalidate, no-transform</span></pre><ul class=""><li id="ddae" class="lg lh hi kh b ki lb kl lc ko li ks lj kw lk la ll lm ln lo bi translated"><strong class="kh hj"> Public/ Private: </strong> Public 让缓存引擎知道可以缓存响应，即使它通常与身份验证相关联。我们可以通过提供最大年龄来间接暗示这一点。Private 让浏览器知道它可以缓存它，但是服务器不能，因为它与用户的私人信息相关联。</li><li id="c451" class="lg lh hi kh b ki lp kl lq ko lr ks ls kw lt la ll lm ln lo bi translated"><strong class="kh hj">最长时间:</strong>这是响应可以再次使用的最长时间(秒)。例如，<code class="du mk ml mm mn b">max-age=60</code>表示从发出请求起 60 秒内可以从缓存中检索到资产。</li><li id="ba29" class="lg lh hi kh b ki lp kl lq ko lr ks ls kw lt la ll lm ln lo bi translated"><strong class="kh hj">无缓存/无存储:</strong>无缓存强制向服务器发出请求，以检查其是否仍然有效(通常使用<a class="ae mi" href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/ETag" rel="noopener ugc nofollow" target="_blank"> ETag </a>头)。如果高速缓存条目仍然有效，则不需要下载。没有比这更简单的存储了，它阻止了所有级别的所有缓存。</li><li id="1fb7" class="lg lh hi kh b ki lp kl lq ko lr ks ls kw lt la ll lm ln lo bi translated"><strong class="kh hj">必须重新验证:</strong>当响应变得过时(缓存条目已用尽)时使用，告知缓存必须对具有源的响应进行端到端验证，并且不使用过时的资产。</li><li id="7ff6" class="lg lh hi kh b ki lp kl lq ko lr ks ls kw lt la ll lm ln lo bi translated"><strong class="kh hj">代理重新验证:</strong>这与“必须重新验证”相同，但仅适用于代理级别。例如，一个经过身份验证的用户可能在浏览器中缓存了可以重用的响应，但是在代理级别缓存的任何响应都需要重新验证。</li><li id="415e" class="lg lh hi kh b ki lp kl lq ko lr ks ls kw lt la ll lm ln lo bi translated"><strong class="kh hj">无转换:</strong>这告诉任何中间缓存不要修改响应。</li></ul><h2 id="eb3e" class="lu jo hi bd jp lv lw lx jt ly lz ma jx ko mb mc jz ks md me kb kw mf mg kd mh bi translated">会话缓存</h2><p id="7744" class="pw-post-body-paragraph kf kg hi kh b ki kj ij kk kl km im kn ko kp kq kr ks kt ku kv kw kx ky kz la hb bi translated">有关会议的概述，请点击<a class="ae mi" href="https://jc1175.medium.com/cookies-sessions-and-jwt-the-very-very-basics-73dc706125e6" rel="noopener">此处</a>查看相关文章。</p><p id="2df3" class="pw-post-body-paragraph kf kg hi kh b ki lb ij kk kl lc im kn ko ld kq kr ks le ku kv kw lf ky kz la hb bi translated">我们可以用几种方式处理会话。一种是将用户的会话存储在处理用户请求的特定节点上，并每次将它们重定向到该节点(粘性会话)。另一种方法是在应用程序中设置一个专用的会话缓存层，供所有节点访问。这通常会使用一个键/值存储。</p><p id="3f1d" class="pw-post-body-paragraph kf kg hi kh b ki lb ij kk kl lc im kn ko ld kq kr ks le ku kv kw lf ky kz la hb bi translated">在 AWS 中，我们可能会使用类似于<a class="ae mi" href="https://redis.io/" rel="noopener ugc nofollow" target="_blank"> Redis </a>或<a class="ae mi" href="https://memcached.org/" rel="noopener ugc nofollow" target="_blank"> Memcached </a>的东西，我们可以在下面简化的 AWS 架构中看到。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es my"><img src="../Images/85c500b3afb2a85d5df1e34f3475bf1c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dqo3-K6I_aDeyHQ6Sgu4JQ.png"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">显示用于会话管理的缓存的简化 AWS 体系结构。</figcaption></figure><h2 id="d489" class="lu jo hi bd jp lv lw lx jt ly lz ma jx ko mb mc jz ks md me kb kw mf mg kd mh bi translated">数据库缓存</h2><p id="a6cf" class="pw-post-body-paragraph kf kg hi kh b ki kj ij kk kl km im kn ko kp kq kr ks kt ku kv kw kx ky kz la hb bi translated">内存缓存可以帮助减轻数据库的一些压力。如果您经常访问只读数据，那么将这些数据存储在缓存中而不是永久存储中可能是有意义的。这可以在数据库本身、本地应用服务器或类似的会话上完成，它可以使用专用的缓存层。</p><p id="6964" class="pw-post-body-paragraph kf kg hi kh b ki lb ij kk kl lc im kn ko ld kq kr ks le ku kv kw lf ky kz la hb bi translated">通过在数据库上缓存，我们可以自动处理直写(更新的数据如何影响我们的缓存值)。然而，缓存将与数据库位于同一个服务器上，这意味着它需要与整个数据库引擎一起伸缩。</p><p id="b644" class="pw-post-body-paragraph kf kg hi kh b ki lb ij kk kl lc im kn ko ld kq kr ks le ku kv kw lf ky kz la hb bi translated">通过在我们的应用服务器上进行缓存，我们缓解了其中的一些问题，但是我们现在只能访问一个节点上的缓存，如果它关闭，我们将会丢失缓存。</p><p id="3050" class="pw-post-body-paragraph kf kg hi kh b ki lb ij kk kl lc im kn ko ld kq kr ks le ku kv kw lf ky kz la hb bi translated">专用缓存层可以解决这一问题，但会带来延迟，因为必须发出请求。对于这个和前面的解决方案，我们还面临当数据更新时更新缓存值的问题。一个狡猾的逻辑！</p><h2 id="1671" class="lu jo hi bd jp lv lw lx jt ly lz ma jx ko mb mc jz ks md me kb kw mf mg kd mh bi translated">通用缓存</h2><p id="2695" class="pw-post-body-paragraph kf kg hi kh b ki kj ij kk kl km im kn ko kp kq kr ks kt ku kv kw kx ky kz la hb bi translated">到目前为止，您已经了解了这个要点，缓存可以用在应用程序中任何有用的地方。它根本不是什么灵丹妙药，但却非常有用！</p><h2 id="d583" class="lu jo hi bd jp lv lw lx jt ly lz ma jx ko mb mc jz ks md me kb kw mf mg kd mh bi translated">关于从缓存中获取数据的快速说明</h2><p id="8516" class="pw-post-body-paragraph kf kg hi kh b ki kj ij kk kl km im kn ko kp kq kr ks kt ku kv kw kx ky kz la hb bi translated">我相信你已经意识到，缓存不是无限的。我们需要以某种方式删除条目。一种方法是引入生存时间(TTL)——当我们向缓存中添加一个条目时，我们给它一段我们希望它停留的时间，之后它将被删除。</p><p id="4d1a" class="pw-post-body-paragraph kf kg hi kh b ki lb ij kk kl lc im kn ko ld kq kr ks le ku kv kw lf ky kz la hb bi translated">但是，当我们的缓存填满且 TTL 尚未过期时，我们还有其他选择:</p><ul class=""><li id="3154" class="lg lh hi kh b ki lb kl lc ko li ks lj kw lk la ll lm ln lo bi translated"><strong class="kh hj">无驱逐:</strong>缓存抛出错误。</li><li id="1129" class="lg lh hi kh b ki lp kl lq ko lr ks ls kw lt la ll lm ln lo bi translated"><strong class="kh hj"> FIFO(先进先出)/ LIFO(后进先出):</strong>要放入缓存的第一个/最后一个条目被逐出。</li><li id="0d08" class="lg lh hi kh b ki lp kl lq ko lr ks ls kw lt la ll lm ln lo bi translated"><strong class="kh hj"> LFU(最少使用)/ LRU(最近最少使用):</strong> <em class="mz"> </em>具有最少命中/最早命中的条目被驱逐。</li><li id="ada4" class="lg lh hi kh b ki lp kl lq ko lr ks ls kw lt la ll lm ln lo bi translated"><strong class="kh hj"> TLRU(时间感知最近最少使用):</strong>没有 TTL 的最近最少使用的条目被驱逐。</li><li id="8a1e" class="lg lh hi kh b ki lp kl lq ko lr ks ls kw lt la ll lm ln lo bi translated"><strong class="kh hj"> SLRU(分段 LRU): </strong>缓存一分为二——试用和受保护。第一次缓存命中将条目置于试用状态，第二次缓存命中将条目置于受保护状态。最近最少使用的试用条目被驱逐。</li><li id="7927" class="lg lh hi kh b ki lp kl lq ko lr ks ls kw lt la ll lm ln lo bi translated"><strong class="kh hj"> MRU(最近使用):</strong> <em class="mz"> </em>最近使用的条目被驱逐。</li><li id="9f2f" class="lg lh hi kh b ki lp kl lq ko lr ks ls kw lt la ll lm ln lo bi translated"><strong class="kh hj"> RR(随机替换):</strong>随机条目被驱逐。</li></ul><h2 id="c0ca" class="lu jo hi bd jp lv lw lx jt ly lz ma jx ko mb mc jz ks md me kb kw mf mg kd mh bi translated">工作示例</h2><p id="997b" class="pw-post-body-paragraph kf kg hi kh b ki kj ij kk kl km im kn ko kp kq kr ks kt ku kv kw kx ky kz la hb bi translated">让我们用一个使用<a class="ae mi" href="https://www.h2database.com/html/main.html" rel="noopener ugc nofollow" target="_blank"> H2 </a>、<a class="ae mi" href="https://redis.io/" rel="noopener ugc nofollow" target="_blank"> Redis </a>进行缓存，以及使用<a class="ae mi" href="https://spring.io/projects/spring-data" rel="noopener ugc nofollow" target="_blank"> Spring 数据</a>和<a class="ae mi" href="https://docs.spring.io/spring-data/data-redis/docs/current/reference/html/" rel="noopener ugc nofollow" target="_blank"> Spring 数据 Redis </a>进行连接的例子来说明这一切。我们将实现一个简单的系统来检索用户并缓存他们。储存库可以在这里找到<a class="ae mi" href="https://github.com/JamesCollerton/Spring-Caching" rel="noopener ugc nofollow" target="_blank"/>。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es na"><img src="../Images/3e2cc37404eb221e28f183a30ddf44bf.png" data-original-src="https://miro.medium.com/v2/resize:fit:854/format:webp/1*966kXMyr4VKRVHDxImKyHQ.png"/></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">我们的示例应用程序的基本轮廓</figcaption></figure><p id="2f58" class="pw-post-body-paragraph kf kg hi kh b ki lb ij kk kl lc im kn ko ld kq kr ks le ku kv kw lf ky kz la hb bi translated">首先，我们使用<a class="ae mi" href="https://start.spring.io/" rel="noopener ugc nofollow" target="_blank"> Spring Initializr </a>设置 Spring 项目。不可能在一个页面中显示所有的依赖项，所以请查看存储库的 pom 文件以获得完整的列表。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es nb"><img src="../Images/73a4d7131aeb87730d46fd084f508374.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5nbPvszyYi8ICWMabackpQ.png"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">使用 Spring Initializr 设置缓存示例</figcaption></figure><p id="e9d0" class="pw-post-body-paragraph kf kg hi kh b ki lb ij kk kl lc im kn ko ld kq kr ks le ku kv kw lf ky kz la hb bi translated">一旦设置完成，我们还需要在本地安装 Redis。我用的是<a class="ae mi" href="https://brew.sh/" rel="noopener ugc nofollow" target="_blank">家酿</a>。</p><pre class="iy iz ja jb fd mq mn mr ms aw mt bi"><span id="dcdc" class="lu jo hi mn b fi mu mv l mw mx">brew install redis</span></pre><p id="bc0e" class="pw-post-body-paragraph kf kg hi kh b ki lb ij kk kl lc im kn ko ld kq kr ks le ku kv kw lf ky kz la hb bi translated">然后，我们使用以下命令启动服务器运行:</p><pre class="iy iz ja jb fd mq mn mr ms aw mt bi"><span id="5497" class="lu jo hi mn b fi mu mv l mw mx">redis-server /usr/local/etc/redis.conf</span></pre><p id="7a3d" class="pw-post-body-paragraph kf kg hi kh b ki lb ij kk kl lc im kn ko ld kq kr ks le ku kv kw lf ky kz la hb bi translated">我们将实现两个端点，一个用于检索采用延迟加载的用户，另一个用于持久化新用户，使用直写缓存。</p><ul class=""><li id="3ccb" class="lg lh hi kh b ki lb kl lc ko li ks lj kw lk la ll lm ln lo bi translated"><strong class="kh hj">延迟加载:</strong>这是指我们在加载数据时将数据放入缓存。如果我请求 Id 为“1”的用户，那么我也将把它加载到我的缓存中。</li><li id="6e8f" class="lg lh hi kh b ki lp kl lq ko lr ks ls kw lt la ll lm ln lo bi translated"><strong class="kh hj">直写:</strong>这是我们在保存数据时将数据放入缓存的时候。如果我创建一个 Id 为' 2 '的新用户，那么我也将把它加载到我的缓存中。</li></ul><p id="f73a" class="pw-post-body-paragraph kf kg hi kh b ki lb ij kk kl lc im kn ko ld kq kr ks le ku kv kw lf ky kz la hb bi translated">我们还将为缓存条目使用 TTL(生存时间)。</p><p id="c998" class="pw-post-body-paragraph kf kg hi kh b ki lb ij kk kl lc im kn ko ld kq kr ks le ku kv kw lf ky kz la hb bi translated">类别结构如下所示:</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es nc"><img src="../Images/56658bd714e14cae3c4f8ea853696ddc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1252/format:webp/1*IhA9XN1mnyBkLO98upbY4g.png"/></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">我们的示例项目的 Spring 类结构</figcaption></figure><p id="8e32" class="pw-post-body-paragraph kf kg hi kh b ki lb ij kk kl lc im kn ko ld kq kr ks le ku kv kw lf ky kz la hb bi translated">首先，我们设置应用程序的主类:</p><pre class="iy iz ja jb fd mq mn mr ms aw mt bi"><span id="0def" class="lu jo hi mn b fi mu mv l mw mx">@SpringBootApplication<br/>@EnableJpaRepositories(<strong class="mn hj">"com.example.cacheexample.repository.db"</strong>)<br/>@EnableRedisRepositories(<strong class="mn hj">"com.example.cacheexample.repository.cache"</strong>)<br/><strong class="mn hj">public class </strong>CacheexampleApplication {<br/><br/>   <strong class="mn hj">public static void </strong>main(String[] args) {<br/>      SpringApplication.<em class="mz">run</em>(CacheexampleApplication.<strong class="mn hj">class</strong>, args);<br/>   }<br/><br/>}</span></pre><p id="f5f0" class="pw-post-body-paragraph kf kg hi kh b ki lb ij kk kl lc im kn ko ld kq kr ks le ku kv kw lf ky kz la hb bi translated">我们可以看到，我们在一个包中使存储库能够连接到我们的数据库，在另一个包中使存储库能够连接到 Redis。在我们的<code class="du mk ml mm mn b">application.properties</code>文件中，我们关闭了任何自动发现存储库的功能，以防止混淆:</p><pre class="iy iz ja jb fd mq mn mr ms aw mt bi"><span id="ad08" class="lu jo hi mn b fi mu mv l mw mx">spring.data.jpa.repositories.enabled=false<br/>spring.data.redis.repositories.enabled=false</span></pre><p id="0f13" class="pw-post-body-paragraph kf kg hi kh b ki lb ij kk kl lc im kn ko ld kq kr ks le ku kv kw lf ky kz la hb bi translated">让我们看看如何配置我们的应用程序:</p><pre class="iy iz ja jb fd mq mn mr ms aw mt bi"><span id="e085" class="lu jo hi mn b fi mu mv l mw mx">@Configuration<br/><strong class="mn hj">public class </strong>CacheConfiguration {<br/><br/>    @Bean<br/>    JedisConnectionFactory jedisConnectionFactory() {<br/>        RedisStandaloneConfiguration redisStandaloneConfiguration = <strong class="mn hj">new </strong>RedisStandaloneConfiguration(<strong class="mn hj">"localhost"</strong>, 6379);<br/>        <strong class="mn hj">return new </strong>JedisConnectionFactory(redisStandaloneConfiguration);<br/>    }<br/><br/>    @Bean<br/>    <strong class="mn hj">public </strong>RedisTemplate&lt;?, ?&gt; redisTemplate() {<br/>        RedisTemplate&lt;?, ?&gt; redisTemplate = <strong class="mn hj">new </strong>RedisTemplate&lt;&gt;();<br/>         redisTemplate.setConnectionFactory(jedisConnectionFactory());<br/>        <strong class="mn hj">return </strong>redisTemplate;<br/>    }<br/><br/>}</span></pre><p id="688a" class="pw-post-body-paragraph kf kg hi kh b ki lb ij kk kl lc im kn ko ld kq kr ks le ku kv kw lf ky kz la hb bi translated">我们将 Redis 设置为连接到我们刚刚启动的本地实例。<code class="du mk ml mm mn b">data.sql</code>文件在我们的 H2 数据库中创建了一个表，并设置了一些初始数据:</p><pre class="iy iz ja jb fd mq mn mr ms aw mt bi"><span id="82cd" class="lu jo hi mn b fi mu mv l mw mx"><strong class="mn hj">DROP TABLE </strong>IF <strong class="mn hj">EXISTS </strong>users;<br/><br/><strong class="mn hj">CREATE TABLE </strong>users (<br/>  id    <strong class="mn hj">INT </strong>AUTO_INCREMENT  <strong class="mn hj">PRIMARY KEY</strong>,<br/>  name  <strong class="mn hj">VARCHAR</strong>(250) <strong class="mn hj">NOT NULL<br/></strong>);<br/><br/><strong class="mn hj">INSERT INTO </strong>users (name) <strong class="mn hj">VALUES<br/>  </strong>(<strong class="mn hj">'Sarah'</strong>),<br/>  (<strong class="mn hj">'June'</strong>),<br/>  (<strong class="mn hj">'Elizabeth'</strong>);</span></pre><p id="ae7a" class="pw-post-body-paragraph kf kg hi kh b ki lb ij kk kl lc im kn ko ld kq kr ks le ku kv kw lf ky kz la hb bi translated">这与我们的模型类相匹配:</p><pre class="iy iz ja jb fd mq mn mr ms aw mt bi"><span id="c4e2" class="lu jo hi mn b fi mu mv l mw mx">@Data<br/>@Entity<br/>@Table(name = <strong class="mn hj">"users"</strong>)<br/>@RedisHash(value = <strong class="mn hj">"User"</strong>, timeToLive = 5)<br/><strong class="mn hj">public class </strong>User <strong class="mn hj">implements </strong>Serializable {<br/><br/>    @Id<br/>    @GeneratedValue(strategy = GenerationType.<strong class="mn hj"><em class="mz">IDENTITY</em></strong>)<br/>    <strong class="mn hj">private </strong>Long <strong class="mn hj">id</strong>;<br/><br/>    @NotEmpty<br/>    <strong class="mn hj">private </strong>String <strong class="mn hj">name</strong>;<br/><br/>}</span></pre><p id="82e1" class="pw-post-body-paragraph kf kg hi kh b ki lb ij kk kl lc im kn ko ld kq kr ks le ku kv kw lf ky kz la hb bi translated">请注意我们是如何在数据库中将用户声明为一个实体的，同时也是一个具有 5 秒 TTL 的 Redis 值。</p><p id="8bc1" class="pw-post-body-paragraph kf kg hi kh b ki lb ij kk kl lc im kn ko ld kq kr ks le ku kv kw lf ky kz la hb bi translated">从这里我们公开两个端点。一个通过 Id 获取用户(使用延迟加载)，一个持久化新用户(使用直写)。</p><pre class="iy iz ja jb fd mq mn mr ms aw mt bi"><span id="53cb" class="lu jo hi mn b fi mu mv l mw mx">@Slf4j<br/>@Controller<br/><strong class="mn hj">public class </strong>UserController {<br/><br/>    @Autowired<br/>    <strong class="mn hj">private </strong>UserService <strong class="mn hj">userService</strong>;<br/><br/>    @GetMapping(<strong class="mn hj">"/user/{id}"</strong>)<br/>    <strong class="mn hj">public </strong>ResponseEntity&lt;User&gt; getUser(@PathVariable String id) {<br/>        <strong class="mn hj"><em class="mz">log</em></strong>.info(<strong class="mn hj">"Retrieving user with Id {}"</strong>, id);<br/>        <strong class="mn hj">return </strong>ResponseEntity.<em class="mz">ok</em>(<strong class="mn hj">userService</strong>.getUser(id));<br/>    }<br/><br/>    @PostMapping(<strong class="mn hj">"/user"</strong>)<br/>    <strong class="mn hj">public </strong>ResponseEntity&lt;User&gt; createUser(@Validated @RequestBody User user) {<br/>        <strong class="mn hj"><em class="mz">log</em></strong>.info(<strong class="mn hj">"Persisting user with name {}"</strong>, user.getName());<br/>        <strong class="mn hj">return </strong>ResponseEntity.<em class="mz">ok</em>(<strong class="mn hj">userService</strong>.createUser(user));<br/>    }<br/><br/>}</span></pre><p id="77e8" class="pw-post-body-paragraph kf kg hi kh b ki lb ij kk kl lc im kn ko ld kq kr ks le ku kv kw lf ky kz la hb bi translated">这两者都传递给服务类:</p><pre class="iy iz ja jb fd mq mn mr ms aw mt bi"><span id="74ad" class="lu jo hi mn b fi mu mv l mw mx">@Slf4j<br/>@Service<br/><strong class="mn hj">public class </strong>UserService {<br/><br/>    @Autowired<br/>    <strong class="mn hj">private </strong>UserDao <strong class="mn hj">userDao</strong>;<br/><br/>    <strong class="mn hj">public </strong>User getUser(String id) {<br/>        <strong class="mn hj"><em class="mz">log</em></strong>.info(<strong class="mn hj">"Calling DAO to get user with Id {}"</strong>, id);<br/>        <strong class="mn hj">return userDao</strong>.getUser(Long.<em class="mz">parseLong</em>(id));<br/>    }<br/><br/>    <strong class="mn hj">public </strong>User createUser(User user) {<br/>        <strong class="mn hj"><em class="mz">log</em></strong>.info(<strong class="mn hj">"Calling DAO to persist new user with name {}"</strong>, user.getName());<br/>        <strong class="mn hj">return userDao</strong>.createUser(user);<br/>    }<br/>}</span></pre><p id="ae69" class="pw-post-body-paragraph kf kg hi kh b ki lb ij kk kl lc im kn ko ld kq kr ks le ku kv kw lf ky kz la hb bi translated">然后传递给<code class="du mk ml mm mn b">DAO</code>类，该类充当数据库和缓存之间的中介。这是一个界面:</p><pre class="iy iz ja jb fd mq mn mr ms aw mt bi"><span id="076e" class="lu jo hi mn b fi mu mv l mw mx"><strong class="mn hj">public interface </strong>UserDao {<br/>    User getUser(Long id);<br/>    User createUser(User user);<br/>}</span></pre><p id="7771" class="pw-post-body-paragraph kf kg hi kh b ki lb ij kk kl lc im kn ko ld kq kr ks le ku kv kw lf ky kz la hb bi translated">然后有一个具体的实现。</p><pre class="iy iz ja jb fd mq mn mr ms aw mt bi"><span id="9d48" class="lu jo hi mn b fi mu mv l mw mx">@Slf4j<br/>@Repository<br/><strong class="mn hj">public class </strong>UserDaoImpl <strong class="mn hj">implements </strong>UserDao {<br/><br/>    @Autowired<br/>    <strong class="mn hj">private </strong>UserDatabaseRepository <strong class="mn hj">userDatabaseRepository</strong>;<br/><br/>    @Autowired<br/>    <strong class="mn hj">private </strong>UserCacheRepository <strong class="mn hj">userCacheRepository</strong>;<br/><br/>    @Override<br/>    <strong class="mn hj">public </strong>User getUser(Long id) {<br/><br/>        <strong class="mn hj"><em class="mz">log</em></strong>.info(<strong class="mn hj">"Checking in cache for user with Id {}"</strong>, id);<br/><br/>        Optional&lt;User&gt; userCacheOptional = <strong class="mn hj">userCacheRepository</strong>.findById(id);<br/><br/>        <strong class="mn hj"><em class="mz">log</em></strong>.info(<strong class="mn hj">"Retrieved cache result for user with Id {}"</strong>, id);<br/><br/>        <strong class="mn hj">return </strong>userCacheOptional.orElseGet(() -&gt; {<br/><br/>            <strong class="mn hj"><em class="mz">log</em></strong>.info(<strong class="mn hj">"No user with Id {} in cache"</strong>, id);<br/><br/>            Optional&lt;User&gt; optionalUser = <strong class="mn hj">userDatabaseRepository</strong>.findById(id);<br/><br/>            <strong class="mn hj"><em class="mz">log</em></strong>.info(<strong class="mn hj">"Retrieved user with Id {} from database"</strong>, id);<br/><br/>            User user = optionalUser.orElseThrow(() -&gt; <strong class="mn hj">new </strong>RuntimeException(<strong class="mn hj">"User not found"</strong>));<br/><br/>            <strong class="mn hj"><em class="mz">log</em></strong>.info(<strong class="mn hj">"Persisting user with Id {} to cache"</strong>, id);<br/><br/>            User cacheUser = <strong class="mn hj">userCacheRepository</strong>.save(user);<br/><br/>            <strong class="mn hj"><em class="mz">log</em></strong>.info(<strong class="mn hj">"Persisted user with Id {} to cache"</strong>, cacheUser.getId());<br/><br/>            <strong class="mn hj">return </strong>user;<br/><br/>        });<br/><br/>    }<br/><br/>    @Override<br/>    <strong class="mn hj">public </strong>User createUser(User user) {<br/><br/>        <strong class="mn hj"><em class="mz">log</em></strong>.info(<strong class="mn hj">"Creating a new user in the database with name {}"</strong>, user.getName());<br/><br/>        User newUser = <strong class="mn hj">userDatabaseRepository</strong>.save(user);<br/><br/>        <strong class="mn hj"><em class="mz">log</em></strong>.info(<strong class="mn hj">"Saved new user in the database Id {}, name {}"</strong>, user.getId(), user.getName());<br/><br/>        <strong class="mn hj">userCacheRepository</strong>.save(newUser);<br/><br/>        <strong class="mn hj"><em class="mz">log</em></strong>.info(<strong class="mn hj">"Saved new user in the cache Id {}, name {}"</strong>, user.getId());<br/><br/>        <strong class="mn hj">return </strong>newUser;<br/>    }<br/>}</span></pre><p id="90c5" class="pw-post-body-paragraph kf kg hi kh b ki lb ij kk kl lc im kn ko ld kq kr ks le ku kv kw lf ky kz la hb bi translated">这才是我们真正感兴趣的！在<code class="du mk ml mm mn b">get</code>方法中，我们检查用户是否在缓存中。如果没有，我们从数据库中获取它们，并把它们放在缓存中。在<code class="du mk ml mm mn b">put</code>方法中，我们将它们保存到数据库中，然后保存到缓存中！</p><p id="bfd9" class="pw-post-body-paragraph kf kg hi kh b ki lb ij kk kl lc im kn ko ld kq kr ks le ku kv kw lf ky kz la hb bi translated">让我们来看看它的运行情况。首先，让我们请求获取 Id 为<code class="du mk ml mm mn b">1</code>的用户。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es nd"><img src="../Images/6e4a5c57d7d1588f7bf0e67a8b325334.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7CEagqqfot7fXGpQNY0VqA.png"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">用于检索 Id 为 1 的用户的日志文件</figcaption></figure><p id="529f" class="pw-post-body-paragraph kf kg hi kh b ki lb ij kk kl lc im kn ko ld kq kr ks le ku kv kw lf ky kz la hb bi translated">从日志中我们可以看到，缓存中没有 Id 为<code class="du mk ml mm mn b">1</code>的用户，所以我们访问了数据库并将结果写入缓存。如果我们在不到五秒钟的时间内再次到达同一个端点，我们将收到以下消息:</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es nd"><img src="../Images/16c97e732e4fcbe68adb46ea8d7c47f7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pBuxcYmQIrLeWFK_O_QDzA.png"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">用于检索 Id 为 1 的缓存用户的日志文件</figcaption></figure><p id="24a5" class="pw-post-body-paragraph kf kg hi kh b ki lb ij kk kl lc im kn ko ld kq kr ks le ku kv kw lf ky kz la hb bi translated">现在我们不再使用数据库，而是完全依赖 Redis。如果我们把它放 5 秒钟，试着回到第一个案例。</p><p id="34f8" class="pw-post-body-paragraph kf kg hi kh b ki lb ij kk kl lc im kn ko ld kq kr ks le ku kv kw lf ky kz la hb bi translated">最后，让我们持久化并检索一个新用户。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ne"><img src="../Images/eb8c05340f75c00dac592410146bb7a5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oJepYsrrONOAFtPM1c6_eQ.png"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">保存新用户 Becca 的日志文件</figcaption></figure><p id="9635" class="pw-post-body-paragraph kf kg hi kh b ki lb ij kk kl lc im kn ko ld kq kr ks le ku kv kw lf ky kz la hb bi translated">在这里，我们可以看到我们保存了用户“Becca ”,并将她保存到缓存中。立即找回她给了我们:</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es nf"><img src="../Images/0fdab7ea26c54132be34476a0dbc951f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*m8tlXZuxONG0AwIBACR08Q.png"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">用于从缓存中检索新用户 Becca 的日志文件</figcaption></figure><p id="6451" class="pw-post-body-paragraph kf kg hi kh b ki lb ij kk kl lc im kn ko ld kq kr ks le ku kv kw lf ky kz la hb bi translated">我们在那里找到了她。</p><h1 id="460e" class="jn jo hi bd jp jq jr js jt ju jv jw jx io jy ip jz ir ka is kb iu kc iv kd ke bi translated">结论</h1><p id="be39" class="pw-post-body-paragraph kf kg hi kh b ki kj ij kk kl km im kn ko kp kq kr ks kt ku kv kw kx ky kz la hb bi translated">总之，我们已经讨论了在当代应用程序中可以使用缓存的许多地方，并在一个工作示例中演示了它们。</p></div></div>    
</body>
</html>