<html>
<head>
<title>Solidity Exception And Error Handling</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">可靠性异常和错误处理</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/solidity-exception-and-error-handling-d1ebfae85552?source=collection_archive---------2-----------------------#2021-09-15">https://medium.com/nerd-for-tech/solidity-exception-and-error-handling-d1ebfae85552?source=collection_archive---------2-----------------------#2021-09-15</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div class="er es if"><img src="../Images/deffb813583b41ac113f773da7d5be3a.png" data-original-src="https://miro.medium.com/v2/resize:fit:608/format:webp/1*oSNRgoB-4m2IOenj0jRhdw.jpeg"/></div></figure><h1 id="b95d" class="im in hi bd io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj bi translated">介绍</h1><p id="b405" class="pw-post-body-paragraph jk jl hi jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh hb bi translated">写合同是稳健的根本目的。然而，编写契约需要可靠的错误和异常处理。错误和异常是编程中的规范，而可靠性为管理这两者提供了充足的基础设施。编写具有适当的错误和异常管理的健壮契约是最佳实践之一。事件是坚固性的另一个重要组成部分。我们知道一个调用契约中的函数的调用者；然而，我们还没有讨论任何一种机制，通过这种机制，契约可以通知它的调用者关于它的状态和其他方面的变化。这通常是有活动的地方。事件是事件驱动程序的一个邻域，它支持程序内的更改，并主动通知调用者这些更改。打电话的人可以随意使用或忽略这些信息。最后，异常和事件都在很大程度上使用了EVM提供的日志记录功能。</p><h1 id="828a" class="im in hi bd io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj bi translated">错误处理</h1><p id="4cc8" class="pw-post-body-paragraph jk jl hi jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh hb bi translated">在撰写合同时，经常会无意中引入错误，因此撰写健壮的合同可能是一种很好的实践，并将被遵循。在编程世界中，错误是生活中的现实，编写无错误的契约可能是一项需要的技能。错误可能发生在设计时或运行时。Solidity被编译成字节码，编译时会在设计时对任何语法错误进行设计级检查。然而，运行时错误更难捕捉，通常发生在执行契约时。检查契约中可能的运行时错误是很重要的，但是更重要的是写下防御性的、健壮的契约来监视设计时和运行时错误。运行时错误的例子有气体用尽错误、被零除错误、数据类型溢出错误、数组索引外错误等等。在Solidity的4.10版本之前，只有一个throw语句可用于错误处理。开发人员必须写下多个if…else语句来查看值，并在出错时抛出。throw语句消耗所有提供的气体，并返回到第一个状态。对于建筑师和开发者来说，这通常不是一个完美的情况，因为未使用的气体应该返回给呼叫者。从4.10版本开始，Solidity引入了新的错误处理结构，因此抛出<br/>被废弃了。这些是断言、要求和回复语句。值得注意的是没有尝试..捕捉语句或构造来捕捉错误和异常。</p><h1 id="c169" class="im in hi bd io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj bi translated">所需语句</h1><p id="4d1c" class="pw-post-body-paragraph jk jl hi jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh hb bi translated">单词requires表示约束。声明require语句意味着声明运行该函数的先决条件；换句话说，这意味着在执行后续代码行之前声明应该满足的约束。指定的语句在单个参数中接受:一篇新闻稿，其计算结果为真或假布尔值。如果语句的求值结果为假，则会引发异常并停止执行。未使用的气体被返回给呼叫者，因此状态被反转到第一个。指定的语句导致revert操作码，该操作码负责恢复状态并返回未使用的gas。下面的代码说明了指定语句的使用:</p><figure class="kk kl km kn fd ij er es paragraph-image"><div class="er es kj"><img src="../Images/ae39c400ec117132032ce03f016a7589.png" data-original-src="https://miro.medium.com/v2/resize:fit:640/format:webp/0*XisjTDxGvTeeKiav.png"/></div></figure><p id="b313" class="pw-post-body-paragraph jk jl hi jm b jn ko jp jq jr kp jt ju jv kq jx jy jz kr kb kc kd ks kf kg kh hb bi translated">让我们看一下前面截图中描述的后续函数:<br/> 1。ValidInt8:这个函数使用了一些必需的语句。在构造中，新闻稿检查大于或等于零的值。如果该语句为真，则执行转到后续语句。如果这个语句是假的，就会抛出一个异常并停止执行。随后的requires语句检查该值是否小于255或者是否足以达到255。如果参数大于255，则该语句的计算结果为false并引发异常。<br/> 2。shouldbeven:<a class="ae ki" href="https://www.technologiesinindustry4.com/" rel="noopener ugc nofollow" target="_blank">这个函数具有相同的性质。这个函数需要检查传入的参数是奇数还是偶数。</a>如果自变量是偶数，则执行传递到随后的语句；否则，将引发异常。指定的语句应该用于验证传入函数的所有参数和值。这表明，如果命名了另一个契约中的另一个函数或同一契约中的另一个函数，甚至应该使用指定的函数来检查传入的值。指定的函数应该习惯于在使用变量之前检查变量的当前状态。如果require抛出一个异常，这应该意味着传递给函数的值不是函数所期望的，调用者应该在将值发送给契约之前修改它。</p><h1 id="87ca" class="im in hi bd io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj bi translated">断言语句</h1><p id="a7d7" class="pw-post-body-paragraph jk jl hi jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh hb bi translated">assert语句的语法与specified语句相似。如果它接受了一个新闻稿，那么应该评估一个真实或虚假的价值。在这种情况下，执行要么前进到后续语句，要么抛出异常。未使用的气体不会返回给调用者，而是被assert消耗掉。状态反转到第一种。assert函数会导致无效的操作码，这可能会导致状态反转并消耗所有gas。前面显示的函数已经扩展，增加了主要变量。但是，请记住，添加两个变量可能会导致溢出异常。这通常使用assert语句来验证；如果返回true，则返回值，否则抛出异常。<br/>下面的屏幕截图展示了assert函数的使用:</p><figure class="kk kl km kn fd ij er es paragraph-image"><div class="er es kj"><img src="../Images/26000c12c51fc7cccd20f74f527fbfef.png" data-original-src="https://miro.medium.com/v2/resize:fit:640/format:webp/0*sXYrsDjqGYuzJZAj.png"/></div></figure><p id="f5ed" class="pw-post-body-paragraph jk jl hi jm b jn ko jp jq jr kp jt ju jv kq jx jy jz kr kb kc kd ks kf kg kh hb bi translated">require应该用于来自表面的值，assert应该用于在执行之前验证函数和契约的当前状态和条件。<a class="ae ki" href="https://www.technologiesinindustry4.com/" rel="noopener ugc nofollow" target="_blank">考虑断言处理我们无法预测的运行时异常。</a>一旦你认为一个当前状态已经变得不一致，不应该继续执行，就应该使用assert语句。</p><h1 id="f9ad" class="im in hi bd io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj bi translated">revert语句</h1><p id="1876" class="pw-post-body-paragraph jk jl hi jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh hb bi translated">revert语句非常类似于指定的函数。但是，它不评估任何语句，也不依赖于任何状态或语句。点击revert语句意味着抛出一个异常，伴随着未使用气体的返回，并恢复到其原始状态。在下面的示例中，当使用if条件检查传入值时，将引发异常；如果if条件评估结果为假，则执行revert函数。这会导致异常和执行停止，如下面的屏幕截图所示:</p><figure class="kk kl km kn fd ij er es paragraph-image"><div class="er es kj"><img src="../Images/224bdda4781b1583246f926dbe1e09ce.png" data-original-src="https://miro.medium.com/v2/resize:fit:640/format:webp/0*tfA3K9ReISHlDFOk.png"/></div></figure><p id="8947" class="pw-post-body-paragraph jk jl hi jm b jn ko jp jq jr kp jt ju jv kq jx jy jz kr kb kc kd ks kf kg kh hb bi translated">更多详情请访问:<a class="ae ki" href="https://www.technologiesinindustry4.com/2021/05/solidity-exception-and-error-handling.html" rel="noopener ugc nofollow" target="_blank">https://www . technologiesinindustry 4 . com/2021/05/solidity-exception-and-error-handling . html</a></p></div></div>    
</body>
</html>