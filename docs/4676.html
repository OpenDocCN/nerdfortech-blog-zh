<html>
<head>
<title>Change component content from outside.</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">从外部更改组件内容。</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/change-component-content-from-outside-e6dc8382b3bb?source=collection_archive---------17-----------------------#2021-08-01">https://medium.com/nerd-for-tech/change-component-content-from-outside-e6dc8382b3bb?source=collection_archive---------17-----------------------#2021-08-01</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="aa46" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">角度模板</h2></div><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ix"><img src="../Images/1d19181423791c320698f9fec95fe617.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*t-R_jzA-aSkMvXFt0MpjtA.png"/></div></div></figure><p id="24be" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">如果我们可以创建一个组件并在其中放入任何内容，那会怎么样？这要怎么做？我们创建主组件(骨架)，在不改变主组件的情况下改变内部内容。这种方法给了我们很多好处。</p><p id="5bd6" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">在 angular 中，这个特性调用模板。我们将使用三个项目:ng-template、ng-container 和 ngTemplateOutlet。</p><p id="8fb1" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">让我们举一个小例子，我们将讨论所有这些项目。</p><p id="f2f1" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">首先，我们创建一个标题。Ng-container 是我们将看到 Ng 模板的地方。NgTemplateOutlet 是 ng-template 项目上的一个链接。如果我们没有传递 headerTemplate，我们将看到一个默认模板。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es kf"><img src="../Images/fd75a2c62ed0c33c5887bbab58043b70.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*G8A2q2ZFpw4nSLE5J_lpgw.png"/></div></div></figure><p id="54df" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">在 app 组件中，我们使用两个版本的 header 组件。第一个使用默认的模板，对于第二个，我们有一个在 header 组件中传递的模板。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es kg"><img src="../Images/ba56b95ac014ea33c089939e1be9054f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*w7Ph4R40tKkT4h5HPljeGg.png"/></div></div></figure><p id="988b" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">因此，我们拥有内容不同的相同组件。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es kh"><img src="../Images/c8ebd5ad84e88cf5e76b7fa98fe8b668.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3fDVque9eyu2mCBIpVJ6pw.png"/></div></div></figure><p id="e8f4" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">如果你需要仔细看看这个项目，这里有链接。</p></div><div class="ab cl kj kk gp kl" role="separator"><span class="km bw bk kn ko kp"/><span class="km bw bk kn ko kp"/><span class="km bw bk kn ko"/></div><div class="hb hc hd he hf"><p id="5c36" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated"><em class="kq">原载于 2021 年 8 月 1 日</em><a class="ae ki" href="https://tomorrowmeannever.wordpress.com/2021/08/01/1665/" rel="noopener ugc nofollow" target="_blank"><em class="kq">【http://tomorrowmeannever.wordpress.com】</em></a><em class="kq">。</em></p></div></div>    
</body>
</html>