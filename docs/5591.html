<html>
<head>
<title>Python vs C++ Series: Mutable, Immutable, and Copy Assignment</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python vs C++系列:可变、不可变和复制赋值</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/python-vs-c-series-mutable-immutable-and-copy-assignment-d95c0ea73879?source=collection_archive---------8-----------------------#2021-10-20">https://medium.com/nerd-for-tech/python-vs-c-series-mutable-immutable-and-copy-assignment-d95c0ea73879?source=collection_archive---------8-----------------------#2021-10-20</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="5919" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><a class="ae jd" rel="noopener" href="/nerd-for-tech/python-vs-c-series-getter-setter-and-property-e92d7801c21a"> Python vs C++系列</a>的第三篇文章是关于不变性的——对象一旦被创建就不能被修改。</p><p id="2193" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">(注意，本系列中的 Python 代码假设使用 Python 3.7 或更高版本)</p><h1 id="c579" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">C++中的 Const 和 Constexpr</h1><p id="0eb3" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">C++支持两种不变性概念:<em class="kh"> const </em>和<em class="kh"> constexpr </em>。为了声明一个对象是不可变的，我们在定义一个对象时使用<em class="kh"> const </em>或者<em class="kh"> constexpr </em>。当然，当我们考虑 C++中的不可变性时，还有比这更多的细节，但一般来说，所有对象都是默认可变的。</p><pre class="ki kj kk kl fd km kn ko kp aw kq bi"><span id="8322" class="kr jf hi kn b fi ks kt l ku kv">void main()<br/>{<br/>    int nonConstVariable = 0; // Non-const object<br/>    const int constVariable = 0; // Const object<br/>    constexpr int secondsPerHour = 60 * 60; // Const expression<br/>}<!-- --> </span></pre><p id="b515" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">本文在一般情况下使用单词 mutable，所以不要与 C++ <a class="ae jd" href="https://en.cppreference.com/w/cpp/keyword/mutable" rel="noopener ugc nofollow" target="_blank"> mutable </a>关键字混淆，该关键字允许类成员是可变的，即使其类实例是<em class="kh"> const </em>或允许由<em class="kh"> const </em>方法修改的类成员。</p><pre class="ki kj kk kl fd km kn ko kp aw kq bi"><span id="9b35" class="kr jf hi kn b fi ks kt l ku kv">class MyClass<br/>{<br/>    public:<br/>        int variable1 = 0;<br/>        mutable int variable2 = 0;<br/>};<br/><br/>void main()<br/>{<br/>    const MyClass myClass; // Const object<br/>    myClass.variable2 = 10; // Ok because variable2 is mutable<br/>    myClass.variable1 = 10; // Error; myClass object is const<br/>}</span></pre><h1 id="f8d6" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">Python 中的可变性和不变性</h1><p id="7a1d" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">与默认情况下每个对象都是可变的 C++不同，Python 对象的不变性是由其类型决定的。下面的列表总结了一些常见的可变和不可变数据类型。</p><p id="aa96" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">(详见<a class="ae jd" href="https://docs.python.org/3/library/stdtypes.html" rel="noopener ugc nofollow" target="_blank">内置类型</a></p><h1 id="8f3f" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">Python 中不可变是什么意思？</h1><p id="25d6" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">当我们刚接触 Python 时，我们可能认为 Python 中的一切都是可变的，因为我们可以更新我们想要的任何对象。例如，下面的代码可以正常工作。</p><pre class="ki kj kk kl fd km kn ko kp aw kq bi"><span id="24ee" class="kr jf hi kn b fi ks kt l ku kv">variable = 10<br/>variable = "string"<br/>variable = 2.0<br/>variable = [1, 2, 3]</span></pre><p id="dad1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">然而，更新对象的意义在不可变对象和可变对象之间是不同的。当把一个对象赋给一个变量时，我们可以认为该变量是一个指向该对象的命名指针(我们将在复制赋值一节中详细讨论这一点)。如果在我们更新变量的时候对象是不可变的，我们实际上是把它指向了另一个对象，Python 的垃圾回收会把原来的对象回收，如果不再使用的话。相反，如果一个变量指向一个可变对象，当我们更新这个变量时，这个可变对象就会被修改。</p><p id="1b05" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们可以使用内置函数<a class="ae jd" href="https://docs.python.org/3/library/functions.html#id" rel="noopener ugc nofollow" target="_blank"> id </a>来验证我们更新的对象是否还是同一个对象。<em class="kh"> id </em>函数返回一个对象的标识(对象在内存中的地址)。下面的例子展示了不变性在 Python 中的表现，以及我们如何使用<em class="kh"> id </em>函数来检查对象的身份。此外，我们使用<a class="ae jd" href="https://docs.python.org/3/library/functions.html#hex" rel="noopener ugc nofollow" target="_blank">十六进制</a>函数将<em class="kh"> id </em>输出转换为十六进制格式，因此它看起来更像一个内存地址。</p><pre class="ki kj kk kl fd km kn ko kp aw kq bi"><span id="f7b4" class="kr jf hi kn b fi ks kt l ku kv"># int is immutable type<br/>integer = 10<br/>print(f"integer: {integer}; address: {hex(id(integer))}")<br/># integer: 10; address: 0x7f7a7b35fa50<br/>integer = 20<br/>print(f"integer: {integer}; address: {hex(id(integer))}")<br/># integer: 20; address: 0x7f7a7b35fb90<br/><br/># str is immutable type<br/>string = "hello"<br/>print(f"string: {string}; address: {hex(id(string))}")<br/># string: hello; address: 0x7f7a7b205370<br/>string = "world"<br/>print(f"string: {string}; address: {hex(id(string))}")<br/># string: world; address: 0x7f7a7b205470<br/><br/># list is mutable type<br/>list_var = [1, 2, 3]<br/>print(f"list_var: {list_var}; address: {hex(id(list_var))}")<br/># list_var: [1, 2, 3]; address: 0x7f7a7b259840<br/>list_var.append(4)<br/>print(f"list_var: {list_var}; address: {hex(id(list_var))}")<br/># list_var: [1, 2, 3, 4]; address: 0x7f7a7b259840<br/><br/># dictionary is mutable type<br/>dict_var = {"key1": "value1"}<br/>print(f"dict_var: {dict_var}; address: {hex(id(dict_var))}")<br/># dict_var: {'key1': 'value1'}; address: 0x7f7a7b2cf500<br/>dict_var["key2"] = "value2"<br/>print(f"dict_var: {dict_var}; address: {hex(id(dict_var))}")<br/># dict_var: {'key1': 'value1', 'key2': 'value2'}; address: 0x7f7a7b2cf500</span></pre><p id="801b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们可以看到变量<em class="kh"> integer </em>和<em class="kh"> string </em>在更新前后的地址是不同的，这意味着这两个变量在更新后指向新的对象(<em class="kh"> 20 </em>和<em class="kh"> world </em>)。相反，<em class="kh"> list_var </em>和<em class="kh"> dict_var </em>是可变的，所以更新前后地址保持不变。因此，它们仍然指向相同的对象。</p><p id="b3fe" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为什么了解 Python 对象的可变性和不变性是至关重要的？</p><p id="7cb5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这是因为如果我们对 Python 对象的不变性视而不见，我们可能会对它们的行为感到惊讶，有时不小心使用可变对象会导致错误。下面的小节将讨论一些对于 C++背景的人来说不太直观的场景。</p><h1 id="31c5" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">使用可变值作为默认函数参数</h1><p id="e5f6" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">Python 的<a class="ae jd" href="https://docs.python.org/3/tutorial/controlflow.html#default-argument-values" rel="noopener ugc nofollow" target="_blank">默认参数</a>特性允许我们在定义函数时为函数参数提供默认值。然而，如果我们的默认值是可变类型，它们的行为可能不是我们所期望的。参见下面的示例。</p><pre class="ki kj kk kl fd km kn ko kp aw kq bi"><span id="4b9d" class="kr jf hi kn b fi ks kt l ku kv"># Use an empty list as the default value.<br/>def my_function_1(parameter: List = []) -&gt; None:<br/>    parameter.append(10)<br/>    print(parameter)</span></pre><p id="e9fc" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在这个例子中，我们定义了一个函数(<em class="kh"> my_function_1 </em>)，并使用一个空列表作为默认值。然后我们试着多次不提供参数调用这个函数。</p><pre class="ki kj kk kl fd km kn ko kp aw kq bi"><span id="70b7" class="kr jf hi kn b fi ks kt l ku kv">my_function_1()<br/># [10]<br/>my_function_1()<br/># [10, 10]<br/>my_function_1()<br/># [10, 10, 10]</span></pre><p id="3e36" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果我们运行代码，我们会注意到<em class="kh">参数</em>保持我们每次追加的值(即<em class="kh"> 10 </em>)。所以第三次输出变成<em class="kh">【10，10，10】</em>。其行为实际上类似于我们在 C++中的函数中定义一个<em class="kh">静态</em>变量——静态变量只初始化一次，并且即使在函数调用过程中也保持该值。</p><p id="0b65" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">如何避免这种情况？</strong></p><p id="0342" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果有必要使用可变类型，比如<em class="kh"> list </em>(这很常见)，我们应该使用<em class="kh"> None </em>作为缺省值，使用<a class="ae jd" href="https://docs.python.org/3/library/typing.html#typing.Optional" rel="noopener ugc nofollow" target="_blank"> Optional </a>进行类型检查(使用<em class="kh"> Optional </em>告诉类型检查器该值可以是<em class="kh"> None </em>或期望的类型)。这种方式保证了无论何时我们调用函数而不提供参数时，<em class="kh">参数</em>都是新的。参见下面的示例。</p><pre class="ki kj kk kl fd km kn ko kp aw kq bi"><span id="abba" class="kr jf hi kn b fi ks kt l ku kv"># Use None as the default value. And use Optional for type checking<br/>def my_function_2(parameter: Optional[List] = None) -&gt; None:<br/>    if parameter:<br/>        parameter.append(10)<br/>    else:<br/>        parameter = [10]<br/>    print(parameter)</span></pre><p id="fe47" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这一次，如果我们多次调用函数(<em class="kh"> my_function_2 </em>)而没有提供参数，<em class="kh">参数</em>将不会保存上一次调用的值。</p><pre class="ki kj kk kl fd km kn ko kp aw kq bi"><span id="0acf" class="kr jf hi kn b fi ks kt l ku kv">my_function_2()<br/># [10]<br/>my_function_2()<br/># [10]</span></pre><p id="f3eb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">简而言之，不要使用可变类型作为函数参数的默认值。如果参数需要可变类型，使用<em class="kh"> None </em>作为默认值。</p><h1 id="6b1b" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">类变量的行为</h1><p id="aa20" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">第二种情况发生在我们使用可变变量作为类变量的时候。Python 中的一个<a class="ae jd" href="https://docs.python.org/3/tutorial/classes.html#class-and-instance-variables" rel="noopener ugc nofollow" target="_blank">类变量</a>被所有实例共享。场景类似于 C++类变量(即，用<em class="kh">静态</em>声明一个类变量)。要在 Python 中定义一个类变量，请在类内部但在任何方法外部定义一个变量。在下面的例子中，我们用一个可变变量(<em class="kh"> mutable_member </em>)、一个不可变变量(<em class="kh"> immutable_member </em>)和几个实例变量定义了一个类(<em class="kh"> MyClass </em>)。</p><pre class="ki kj kk kl fd km kn ko kp aw kq bi"><span id="6891" class="kr jf hi kn b fi ks kt l ku kv">from typing import List<br/><br/>class MyClass:<br/>    # Mutable class variable. Shared by all instances<br/>    mutable_member: List = []<br/><br/>    # Immutable class variable.<br/>    # Shared by all instances unless an instance binds<br/>    # this variable to something else.<br/>    immutable_member: int = 0<br/><br/>    def __init__(self) -&gt; None:<br/>        # Instance variables are unique to each instance.<br/>        self.immutable_instance_variable: int = 0<br/>        self.mutable_instance_variable: List = []</span></pre><p id="df68" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">由于类变量由所有实例共享，如果变量是可变类型，那么变量的改变将影响该类的所有实例。在我们更新类变量之前，让我们检查它们的值和内存地址。</p><pre class="ki kj kk kl fd km kn ko kp aw kq bi"><span id="457c" class="kr jf hi kn b fi ks kt l ku kv">print(f"MyClass.mutable_member: {MyClass.mutable_member}")<br/># MyClass.mutable_member: []<br/>print(f"MyClass.mutable_member address: {hex(id(MyClass.mutable_member))}")<br/># MyClass.mutable_member address: 0x7f0f7092fe40<br/>print(f"MyClass.immutable_member address: {hex(id(MyClass.immutable_member))}")<br/># MyClass.immutable_member address: 0x7f0f70b34910<br/><br/>class1 = MyClass()<br/>print(f"class1.mutable_member: {class1.mutable_member}")<br/># class1.mutable_member: []<br/>print(f"class1.mutable_member address: {hex(id(class1.mutable_member))}")<br/># class1.mutable_member address: 0x7f0f7092fe40<br/>print(f"class1.immutable_member address: {hex(id(class1.immutable_member))}")<br/># class1.immutable_member address: 0x7f0f70b34910<br/><br/>class2 = MyClass()<br/>print(f"class2.mutable_member: {class2.mutable_member}")<br/># class2.mutable_member: []<br/>print(f"class2.mutable_member address: {hex(id(class2.mutable_member))}")<br/># class2.mutable_member address: 0x7f0f7092fe40<br/>print(f"class2.immutable_member address: {hex(id(class2.immutable_member))}")<br/># class2.immutable_member address: 0x7f0f70b34910</span></pre><p id="8275" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在这里，我们可以看到<em class="kh"> class1 </em>和<em class="kh"> class2 </em>的<em class="kh"> mutable_member </em>和<em class="kh"> immutable_member </em>都指向相同的对象，它们与<em class="kh"> MyClass </em>相同。</p><p id="392c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在，让我们更新可变类变量，并打印出它们的值。</p><pre class="ki kj kk kl fd km kn ko kp aw kq bi"><span id="cdcc" class="kr jf hi kn b fi ks kt l ku kv"># Update the mutable class variable<br/>class1.mutable_member.append(10)<br/>print(f"class1.mutable_member: {class1.mutable_member}")<br/># class1.mutable_member: [10]<br/>print(f"class2.mutable_member: {class2.mutable_member}")<br/># class2.mutable_member: [10]</span></pre><p id="28d6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">该更新会影响<em class="kh"> MyClass </em>的所有实例。</p><p id="d587" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">不可变类变量怎么样？</strong></p><p id="d1f5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">当我们更新一个不可变的类变量时，行为有一点不同。现在，让我们从<em class="kh"> class1 </em>更新<em class="kh">不可变成员</em>，并打印出两个实例<em class="kh"> class1 </em>和<em class="kh"> class2 </em>的地址。</p><pre class="ki kj kk kl fd km kn ko kp aw kq bi"><span id="1aba" class="kr jf hi kn b fi ks kt l ku kv"># Update the immutable class variable<br/>class1.immutable_member = 20<br/>print(f"class1.immutable_member: {class1.immutable_member}")<br/># class1.immutable_member: 20<br/>print(f"class1.immutable_member address: {hex(id(class1.immutable_member))}")<br/># class1.immutable_member address: 0x7f0f70b34b90<br/>print(f"class2.immutable_member: {class2.immutable_member}")<br/># class2.immutable_member: 0<br/>print(f"class2.immutable_member address: {hex(id(class2.immutable_member))}")<br/># class2.immutable_member address: 0x7f0f70b34910</span></pre><p id="52b0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">输出显示<em class="kh">class 1 . immutable _ member</em>不再绑定到<em class="kh">my class . immutable _ member</em>。</p><p id="1da8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果我们创建一个新的<em class="kh"> MyClass </em>实例<em class="kh"> class3 </em>，它的类变量仍然绑定到<em class="kh"> MyClass </em>的类变量。</p><pre class="ki kj kk kl fd km kn ko kp aw kq bi"><span id="08af" class="kr jf hi kn b fi ks kt l ku kv">class3 = MyClass()<br/>print(f"class3.immutable_member: {class3.immutable_member}")<br/># class3.immutable_member: 0<br/>print(f"class3.immutable_member address: {hex(id(class3.immutable_member))}")<br/># class3.immutable_member address: 0x7f0f70b34910<br/>print(f"MyClass.immutable_member address: {hex(id(MyClass.immutable_member))}")<br/># MyClass.immutable_member address: 0x7f0f70b34910</span></pre><p id="57fa" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">因此，类变量由所有实例共享。对于一个可变的类变量，如果我们修改它，这种改变将影响所有的实例，然而，对于一个不可变的类变量，如果我们从一个类实例改变它，这个实例的变量不再绑定到原来的类变量。</p><p id="8c85" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">此外，值得一提的是，实例变量对于每个类实例都是唯一的，不管其可变性如何。</p><pre class="ki kj kk kl fd km kn ko kp aw kq bi"><span id="33ba" class="kr jf hi kn b fi ks kt l ku kv"># Instance variables are unique to each instance<br/>class1.mutable_instance_variable.append(30)<br/>print(f"class1.mutable_instance_variable: {class1.mutable_instance_variable}")<br/># class1.mutable_instance_variable: [30]<br/>print(<br/>    f"class1.mutable_instance_variable address: "<br/>    f"{hex(id(class1.mutable_instance_variable))}"<br/>)<br/># class1.mutable_instance_variable address: 0x7f0f709e6140<br/>print(f"class2.mutable_instance_variable: {class2.mutable_instance_variable}")<br/># class2.mutable_instance_variable: []<br/>print(<br/>    f"class2.mutable_instance_variable address: "<br/>    f"{hex(id(class2.mutable_instance_variable))}"<br/>)<br/># class2.mutable_instance_variable address: 0x7f0f709e6180</span></pre><h1 id="7989" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">复制分配</h1><p id="dbbc" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">在 Python 中使用赋值操作符(例如，<em class="kh"> x = 10 </em>)不会创建对象的副本。相反，它在变量和对象之间建立了一个绑定。在处理不可变对象时，这种行为不是问题。赋值操作符将在变量和不可变对象的新目标之间创建一个新的绑定。我们可以使用<a class="ae jd" href="https://docs.python.org/3/reference/expressions.html#is" rel="noopener ugc nofollow" target="_blank"> is </a>操作符来检查两个对象是否是同一个对象(我们也可以像前面的例子一样使用<em class="kh"> id </em>函数)。下面的例子展示了不可变对象上的赋值操作行为和<em class="kh"> is </em>操作符的用法。</p><pre class="ki kj kk kl fd km kn ko kp aw kq bi"><span id="98e9" class="kr jf hi kn b fi ks kt l ku kv"># Copy an immutable object<br/>my_string = "hello"<br/>my_string_copy = my_string<br/># They both bind to the same object.<br/>print(my_string is my_string_copy)<br/># True<br/><br/># After we update one variable, they bind to two different objects.<br/>my_string_copy += " world"<br/>print(my_string is my_string_copy)<br/># False<br/><br/># Of course, their values are different.<br/>print(f"my_string: {my_string}")<br/># my_string: hello<br/>print(f"my_string_copy: {my_string_copy}")<br/># my_string_copy: hello world</span></pre><h1 id="3e0d" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">复制模块和浅层复制</h1><p id="ddec" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">我们知道拷贝赋值只是在对象和目标之间创建一个绑定，那么我们如何创建一个对象的拷贝呢？Python 提供了一个<a class="ae jd" href="https://docs.python.org/3/library/copy.html" rel="noopener ugc nofollow" target="_blank">复制</a>模块，提供了浅层和深层复制操作。以下示例使用<a class="ae jd" href="https://docs.python.org/3/library/copy.html#copy.copy" rel="noopener ugc nofollow" target="_blank"> copy.copy </a>函数从可变对象(<em class="kh"> value </em>)创建副本(<em class="kh"> value_copy </em>)。</p><pre class="ki kj kk kl fd km kn ko kp aw kq bi"><span id="a41b" class="kr jf hi kn b fi ks kt l ku kv">import copy<br/><br/># Define a mutable object.<br/>value = [1, 2, 3]<br/>print(hex(id(value)))<br/># 0x7fc0df486380<br/><br/># Copy assignment just creates binding.<br/>value_bind = value<br/>print(hex(id(value_bind)))<br/># 0x7fc0df486380<br/><br/># Use copy.copy function to perform shallow copy.<br/>value_copy = copy.copy(value)<br/>print(hex(id(value_copy)))<br/># 0x7fc0df4af740<br/><br/># Update the copied variable.<br/>value_copy.append(4)<br/>print(value_copy)<br/># [1, 2, 3, 4]<br/><br/># The update does not affect the original variable.<br/>print(value)<br/># [1, 2, 3]</span></pre><p id="da97" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在这个例子中，<em class="kh"> value_copy </em>变量独立于<em class="kh"> value </em>变量。另外，值得一提的是，<em class="kh"> copy.copy </em>函数仍然为不可变对象创建对象和目标之间的绑定。</p><p id="515c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">可变复合对象或不可变复合对象上的浅拷贝包含可变复合对象</strong></p><p id="6e1b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><a class="ae jd" href="https://docs.python.org/3/library/copy.html" rel="noopener ugc nofollow" target="_blank">浅拷贝</a>发生在 C++中处理包含指针的复合对象(如类)时；副本复制指针，但不复制指针指向的对象(见下图)。</p><figure class="ki kj kk kl fd kx er es paragraph-image"><div class="er es kw"><img src="../Images/b0573ad491ef1f64169caf95a30e1343.png" data-original-src="https://miro.medium.com/v2/resize:fit:802/format:webp/0*VVfZhjijKVzjsSUL.png"/></div></figure><p id="e8e5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">因此，<em class="kh">对象 A </em>和<em class="kh">对象 B </em>的指针所指向的<em class="kh">对象</em>成为共享的。</p><p id="8cee" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">由于 Python 中的<a class="ae jd" href="https://docs.python.org/3/library/copy.html#copy.copy" rel="noopener ugc nofollow" target="_blank"> copy.copy </a>函数执行的是浅层复制，所以在复制一个包含可变复合对象的复合对象时，会出现上面提到的情况，无论顶层复合对象是可变的还是不可变的。以下示例演示了浅层复制方案。</p><pre class="ki kj kk kl fd km kn ko kp aw kq bi"><span id="c15e" class="kr jf hi kn b fi ks kt l ku kv">import copy<br/><br/># Create an object with an mutable object,<br/># and print out its memory address.<br/>compound_object = {"key1": 123, "key2": [1, 2, 3]}<br/>print(hex(id(compound_object)))<br/># 0x7fbd2b61d480<br/><br/># Use copy.copy to create a copy of the compound_object.<br/># and print out its memory address.<br/>compound_object_copy = copy.copy(compound_object)<br/>print(hex(id(compound_object_copy)))<br/># 0x7fbd2b61d540<br/><br/># The address shows compound_object_copy is a different object<br/># from compound_object.<br/># However, if we print out the address of the key2 value<br/># from both compound_object and compound_object_copy,<br/># they are the same object.<br/>print(hex(id(compound_object["key2"])))<br/># 0x7fbd2b5561c0<br/>print(hex(id(compound_object_copy["key2"])))<br/># 0x7fbd2b5561c0<br/><br/># Since key2 is shared, if we update it, the change will<br/># affect both compound_object and compound_object_copy.<br/>compound_object_copy["key2"].append(4)<br/>print(compound_object_copy)<br/># {'key1': 123, 'key2': [1, 2, 3, 4]}<br/>print(compound_object)<br/># {'key1': 123, 'key2': [1, 2, 3, 4]}</span></pre><p id="fefc" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">使用 copy.deepcopy 函数进行深度复制</strong></p><p id="94fb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果我们要执行深度复制，我们应该使用<a class="ae jd" href="https://docs.python.org/3/library/copy.html#copy.deepcopy" rel="noopener ugc nofollow" target="_blank"> copy.deepcopy </a>来代替。请参见下面的示例。</p><pre class="ki kj kk kl fd km kn ko kp aw kq bi"><span id="4cce" class="kr jf hi kn b fi ks kt l ku kv">import copy<br/><br/># Create an object with an mutable object,<br/># and print out its memory address.<br/>compound_object = {"key1": 123, "key2": [1, 2, 3]}<br/>print(hex(id(compound_object)))<br/># 0x7fbba9d11480<br/><br/># Use copy.deepcopy to create a copy of the compound_object.<br/># and print out its memory address.<br/>compound_object_copy = copy.deepcopy(compound_object)<br/>print(hex(id(compound_object_copy)))<br/># 0x7fbba9c3b600<br/><br/># Also print out the address of the key2 value from both<br/># compound_object and compound_object_copy, and they are<br/># different objects.<br/>print(hex(id(compound_object["key2"])))<br/># 0x7fbba9c4a180<br/>print(hex(id(compound_object_copy["key2"])))<br/># 0x7fbba9c6d9c0<br/><br/># Therefore, if we update the key2 value from compound_object_copy,<br/># it does not affect compound_object.<br/>compound_object_copy["key2"].append(4)<br/>print(compound_object_copy)<br/># {'key1': 123, 'key2': [1, 2, 3, 4]}<br/>print(compound_object)<br/># {'key1': 123, 'key2': [1, 2, 3]}</span></pre><h1 id="e4b4" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">结论</h1><p id="23bf" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">Python 对象的不变性是由其类型定义的。了解哪些数据类型是可变的，哪些是不可变的，以及在某些情况下使用可变对象时的行为，对于避免编写错误代码至关重要。</p><p id="eb64" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">(所有示例代码也可在<a class="ae jd" href="https://github.com/shunsvineyard/shunsvineyard/tree/main/python_vs_cpp_series/mutable_immutable_and_copy_assignment" rel="noopener ugc nofollow" target="_blank">mutable _ immutable _ and _ copy _ assignment</a>获得)</p></div><div class="ab cl la lb gp lc" role="separator"><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf"/></div><div class="hb hc hd he hf"><p id="9ffe" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="kh">原载于 2021 年 10 月 19 日</em><a class="ae jd" href="https://shunsvineyard.info/2021/10/19/python-vs-c-series-mutable-immutable-and-copy-assignment/" rel="noopener ugc nofollow" target="_blank"><em class="kh">https://shunsvineyard . info</em></a><em class="kh">。</em></p></div></div>    
</body>
</html>