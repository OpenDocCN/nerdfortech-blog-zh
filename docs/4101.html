<html>
<head>
<title>K-means algorithm: a (very) simple implementation in Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">K-means算法:一个(非常)简单的Python实现</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/k-means-algorithm-in-4-parts-5dfe1d773303?source=collection_archive---------5-----------------------#2021-07-07">https://medium.com/nerd-for-tech/k-means-algorithm-in-4-parts-5dfe1d773303?source=collection_archive---------5-----------------------#2021-07-07</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/8f3906126997736b18fe248872a59709.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*xy-cQ1NC-0YNTqHf"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">Gert RDA valasevi it在<a class="ae iu" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure></div><div class="ab cl iv iw gp ix" role="separator"><span class="iy bw bk iz ja jb"/><span class="iy bw bk iz ja jb"/><span class="iy bw bk iz ja"/></div><div class="hb hc hd he hf"><p id="772d" class="pw-post-body-paragraph jc jd hi je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hb bi ka translated"><span class="l kb kc kd bm ke kf kg kh ki di">在本系列的</span>中，我们将介绍K-means算法，从一个简单的Python实现开始，以理解其背后的逻辑。我们将了解如何选择最佳的集群数量，然后我们将转向约束版本，我们希望对集群施加最小或最大的大小限制。最后，我们将为K-means的变量选择构建一个简单的贪婪算法，这在我们处理具有许多特征的数据集时特别有用。</p><p id="8c6f" class="pw-post-body-paragraph jc jd hi je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hb bi translated"><strong class="je hj">K-means背后的理念</strong></p><p id="06b4" class="pw-post-body-paragraph jc jd hi je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hb bi translated">K-means是一种无监督学习聚类算法，它有助于识别数据集中具有某些相似性的组(注意:数据集应该是标准化的)。这相当简单，由5个基本步骤组成:</p><p id="bec2" class="pw-post-body-paragraph jc jd hi je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hb bi translated"><strong class="je hj">第一步:</strong>选择聚类数:这里我们选择k=3。在<a class="ae iu" href="https://fmarthoz.medium.com/k-means-algorithm-in-4-parts-7540d0f33339" rel="noopener">第二部分</a>中，我们将看到如何最优选择k。</p><pre class="kj kk kl km fd kn ko kp kq aw kr bi"><span id="9cb1" class="ks kt hi ko b fi ku kv l kw kx">k = 3</span></pre><p id="a58e" class="pw-post-body-paragraph jc jd hi je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hb bi translated"><strong class="je hj">第二步:</strong>从数据集中选取k个随机点，作为质心。质心只是一组点的中心点，实际上它是该组中所有点坐标的平均值。</p><pre class="kj kk kl km fd kn ko kp kq aw kr bi"><span id="34d9" class="ks kt hi ko b fi ku kv l kw kx">centroids=X.sample(k)</span></pre><p id="fa5f" class="pw-post-body-paragraph jc jd hi je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hb bi translated">这可以从下面看出:</p><figure class="kj kk kl km fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ky"><img src="../Images/ae55dc82240a05860e8582ed46d6fcf5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rz9SWK13ahBijDaZEZHHWQ.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">红色十字:随机选择3个数据点，用作步骤2中的质心</figcaption></figure><p id="868e" class="pw-post-body-paragraph jc jd hi je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hb bi translated"><strong class="je hj">步骤3: </strong>将每个数据点分配到其最近的质心，并创建k个聚类</p><pre class="kj kk kl km fd kn ko kp kq aw kr bi"><span id="411d" class="ks kt hi ko b fi ku kv l kw kx"># for each row we calculate the distance to each centroid<br/>    d=[]<br/>    for i in range(0,k):<br/>        d.append([distance(x[1],centroids.iloc[i,:]) for x in X.iterrows()])<br/>        <br/># We assign each point to the nearest centroid<br/>clusters=[]<br/>d=np.asarray(d)<br/>for j in range(0,len(d[0])):<br/>    clusters.append(np.argmin(d[0:k,j]))</span></pre><figure class="kj kk kl km fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ky"><img src="../Images/9daf56d0bf2c8e624547232fba91d66b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Sf43pZFfqgWdRZPzU0PAAA.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">指定给最近质心的点，创建3个簇</figcaption></figure><p id="7461" class="pw-post-body-paragraph jc jd hi je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hb bi translated"><strong class="je hj">步骤4: </strong>重新计算每个聚类的新质心</p><pre class="kj kk kl km fd kn ko kp kq aw kr bi"><span id="9e9e" class="ks kt hi ko b fi ku kv l kw kx">for m in range(0,k):<br/>    centroids.iloc[m,:]=(centroid(X[pd.Series(clusters)==m]))</span></pre><p id="1c16" class="pw-post-body-paragraph jc jd hi je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hb bi translated">您可以在下面看到结果:</p><figure class="kj kk kl km fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ky"><img src="../Images/cd805e05962f8e9741c5b68bdce85877.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6ChLPl5BlGhmYCE3EN8etw.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">每个簇的新质心</figcaption></figure><p id="05e2" class="pw-post-body-paragraph jc jd hi je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hb bi translated"><strong class="je hj">步骤5: </strong>重复步骤3和4，直到达到某些标准。这里我们简单地使用一组迭代次数，在本例中为10次:</p><pre class="kj kk kl km fd kn ko kp kq aw kr bi"><span id="6803" class="ks kt hi ko b fi ku kv l kw kx">iter=10<br/>for j in range(0,iter):<br/>    ... code ...</span></pre><p id="97be" class="pw-post-body-paragraph jc jd hi je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hb bi translated">这不是最好的停止标准，最好是在质心从一次迭代到下一次迭代都没有变化时停止。</p><p id="7b03" class="pw-post-body-paragraph jc jd hi je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hb bi translated">这是完整的代码。</p><figure class="kj kk kl km fd ij"><div class="bz dy l di"><div class="kz la l"/></div></figure><p id="43e1" class="pw-post-body-paragraph jc jd hi je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hb bi translated">在某些情况下，我们最终会得到大小非常不同的集群。有没有办法设置集群大小的上限和下限？这是第3部分的主题。</p><figure class="kj kk kl km fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ky"><img src="../Images/a3ea31aef8d22abb56e36241da7229ec.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BnzGd1rndzHEZj-DXS3b5A.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">10次迭代后k=3的最终结果</figcaption></figure></div></div>    
</body>
</html>