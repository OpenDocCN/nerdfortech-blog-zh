<html>
<head>
<title>Writing unit tests in Golang Part 2: Mocking</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用Golang编写单元测试第2部分:模仿</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/writing-unit-tests-in-golang-part-2-mocking-d4fa1701a3ae?source=collection_archive---------0-----------------------#2021-09-13">https://medium.com/nerd-for-tech/writing-unit-tests-in-golang-part-2-mocking-d4fa1701a3ae?source=collection_archive---------0-----------------------#2021-09-13</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div class="er es if"><img src="../Images/c3663740435b1fdfc51fd63bf6749a1f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vvKoWX7jOlzUK5VDSYM0Dw.png"/></div></figure><p id="8c27" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">如果您还没有阅读本系列的第1部分，请不要忘记查看一下。</p><div class="jk jl ez fb jm jn"><a rel="noopener follow" target="_blank" href="/nerd-for-tech/writing-unit-tests-in-golang-part-1-introducing-testify-c0d458442412"><div class="jo ab dw"><div class="jp ab jq cl cj jr"><h2 class="bd hj fi z dy js ea eb jt ed ef hh bi translated">用Golang编写单元测试第1部分:引入证明</h2><div class="ju l"><h3 class="bd b fi z dy js ea eb jt ed ef dx translated">单元测试是为程序的单个组件(也就是最小的部分)编写测试的一种方式。目的…</h3></div><div class="jv l"><p class="bd b fp z dy js ea eb jt ed ef dx translated">medium.com</p></div></div><div class="jw l"><div class="jx l jy jz ka jw kb ik jn"/></div></div></a></div><p id="d436" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi kc translated"><span class="l kd ke kf bm kg kh ki kj kk di">在</span>软件开发中，一个程序通常由许多层和功能组成，这意味着多个代码块必须一起工作。因此，对于程序员来说，创建这样一个测试来检查所有部分都正常工作是很痛苦的。单独测试每个代码块会好得多。这是因为使用较少的代码更容易检测到错误或开发特性。如果所有的代码都在工作，那么整个程序都在工作。</p><p id="98eb" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">我们已经知道单元测试是一种验证程序的每个最小部分的测试。你可能会问…“如果，我的代码(或者我的函数)和其他模块交互怎么办？像数据库、网络服务器等。在编写测试时，我真的必须连接或传输数据到那些模块吗？”</p><p id="80a0" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">答案是:<strong class="io hj"> <em class="kl">不</em> </strong>我鼓励你不要这样做。</p><p id="5552" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">下一个问题是“那怎么做呢？我如何在不实际操作的情况下测试与其他模块交互的代码？”。</p><p id="83fc" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">答案是:你可以<strong class="io hj"> <em class="kl">模仿</em> </strong>你的代码与其他模块交互的地方。模仿是创建一个存根(一个假的，一个不是真的，随便你怎么说)代码的一种方式，它可以替代整个代码的一些功能。它的目的是使测试更容易，因为您可以自由地控制那些存根函数的输入和输出，这允许您只关注业务逻辑。</p><h1 id="9539" class="km kn hi bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">例子</h1><h2 id="43aa" class="lk kn hi bd ko ll lm ln ks lo lp lq kw ix lr ls la jb lt lu le jf lv lw li lx bi translated">这个想法</h2><p id="5d30" class="pw-post-body-paragraph im in hi io b ip ly ir is it lz iv iw ix ma iz ja jb mb jd je jf mc jh ji jj hb bi translated">我正在创建一台带有打印机组件的计算机。计算机将有一个叫做<code class="du md me mf mg b">PrintA4</code>的功能，它可以把我们提供的任何内容打印在A4纸上。打印机也将有自己的功能称为<code class="du md me mf mg b">Print</code>，它将打印我们提供的任何内容和纸张大小。</p><h2 id="3a79" class="lk kn hi bd ko ll lm ln ks lo lp lq kw ix lr ls la jb lt lu le jf lv lw li lx bi translated">代码</h2><p id="cfa0" class="pw-post-body-paragraph im in hi io b ip ly ir is it lz iv iw ix ma iz ja jb mb jd je jf mc jh ji jj hb bi translated">下面的代码演示了一个将被用作模拟示例的应用程序。有一个字段为<code class="du md me mf mg b">Pr</code>的<code class="du md me mf mg b">Computer</code>结构。<code class="du md me mf mg b">Pr</code>字段实现了<code class="du md me mf mg b">Printer</code>接口。<code class="du md me mf mg b">Printer</code>接口有一个方法<code class="du md me mf mg b">Print</code>。另外，<code class="du md me mf mg b">MyPrinter</code>是一个拥有方法<code class="du md me mf mg b">Print</code>的结构。可以看到<code class="du md me mf mg b">MyPrinter</code>实现了接口<code class="du md me mf mg b">Printer</code>。<code class="du md me mf mg b">Computer</code>结构有一个方法<code class="du md me mf mg b">PrintA4</code>。</p><figure class="mh mi mj mk fd ij"><div class="bz dy l di"><div class="ml mm l"/></div><figcaption class="mn mo et er es mp mq bd b be z dx translated">模拟演示的代码</figcaption></figure><p id="f1e7" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">现在，我们想测试调用<code class="du md me mf mg b">Pr.Print</code>的函数<code class="du md me mf mg b">PrintA4</code>(第12行)。这段代码中的打印机就像我们前面讨论过的“其他模块”。为了测试<code class="du md me mf mg b">PrintA4</code>，我们实际上并不需要从打印机中打印出来。因此，我们将创建一个存根函数，模拟接口<code class="du md me mf mg b">Printer</code>的函数<code class="du md me mf mg b">Print</code>。测试代码如下所示。</p><figure class="mh mi mj mk fd ij"><div class="bz dy l di"><div class="ml mm l"/></div><figcaption class="mn mo et er es mp mq bd b be z dx translated">模拟演示的测试代码</figcaption></figure><p id="cc49" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><a class="ae mr" href="https://github.com/stretchr/testify" rel="noopener ugc nofollow" target="_blank">作证</a>的另一个主要特点是嘲讽。evidence为您提供了一个<code class="du md me mf mg b">mock</code>包，您可以创建自己的模拟对象来测试您的代码。</p><p id="e473" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">在第10~21行，我创建了一个模拟对象。这个对象将模仿<code class="du md me mf mg b">Printer</code>接口。在第30行，您可以看到模拟对象调用了方法<code class="du md me mf mg b">On</code>。该方法设置给定模拟函数的期望值。如示例所示，我已经设置了一个期望，函数<code class="du md me mf mg b">Print</code>将接收两个参数，分别是<code class="du md me mf mg b">"A4"</code>和<code class="du md me mf mg b">"hello world"</code>。之后，它调用<code class="du md me mf mg b">Return</code>告诉模拟对象reutrn <code class="du md me mf mg b">nil</code>作为它的返回值。</p><p id="dc5e" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">第37行，调用<code class="du md me mf mg b">PrintA4</code>时，会调用<code class="du md me mf mg b">Pr.Print</code>。在生产中，它应该调用对象<code class="du md me mf mg b">MyPrinter</code>的<code class="du md me mf mg b">Print</code>，但在这种情况下，它将调用对象<code class="du md me mf mg b">PrinterMock</code>的<code class="du md me mf mg b">Print</code>。这太棒了，因为我们实际上不需要调用真正的函数。我们不必与其他模块交互，只需与我们的存根函数交互即可。这使得代码可测试并且更容易调试。</p><p id="130b" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">最后，我们用<code class="du md me mf mg b">AssertExpectations</code>函数断言我们的期望。该函数验证存根函数的输入是正确的，并且存根函数被正确调用。</p><h1 id="8b84" class="km kn hi bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">使用模仿生成模仿</h1><p id="a38b" class="pw-post-body-paragraph im in hi io b ip ly ir is it lz iv iw ix ma iz ja jb mb jd je jf mc jh ji jj hb bi translated">一个问题浮现在你的脑海里“如果…如果我的函数有很多对象呢？如果在我的函数中有许多不同对象的函数调用，我需要编写所有这些模拟吗？”</p><p id="8407" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">答案是:嗯<strong class="io hj"> <em class="kl">有但实际上没有</em> </strong>。</p><p id="c166" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">嘲弄是一个非常方便的软件包，可以为你生成嘲弄。这样，您就不必自己编写模拟了，因为有一个自动化工具为您处理这样的工作。</p><p id="9e83" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">要使用嘲弄，你可以简单地输入<br/> <code class="du md me mf mg b">go get github.com/vektra/mockery/v2/.../</code> <br/>然后再输入<code class="du md me mf mg b">go rungithub.com/vektra/mockery/v2 --all</code>。</p><p id="010b" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">模拟将自动生成到<code class="du md me mf mg b">mocks</code>文件夹中。从<code class="du md me mf mg b">Printer</code>接口生成的示例代码如下所示。</p><figure class="mh mi mj mk fd ij"><div class="bz dy l di"><div class="ml mm l"/></div><figcaption class="mn mo et er es mp mq bd b be z dx translated">生成代码的示例</figcaption></figure><p id="8fb4" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">第二部分到此结束。在下一部分，我将讨论测试套件，这是我们将讨论的最后一个主题。现在，请继续关注并快乐编码！</p><h1 id="ee6f" class="km kn hi bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">参考</h1><p id="4d12" class="pw-post-body-paragraph im in hi io b ip ly ir is it lz iv iw ix ma iz ja jb mb jd je jf mc jh ji jj hb bi translated"><a class="ae mr" href="https://dev.to/chseki/how-i-mock-unit-tests-in-golang-3dcp" rel="noopener ugc nofollow" target="_blank">克里斯蒂安·塞基</a> <br/>写的《我如何在Golang中模仿单元测试》<a class="ae mr" href="https://www.myhatchpad.com/insight/mocking-techniques-for-go/" rel="noopener ugc nofollow" target="_blank">凯尔·约斯特写的《模仿围棋技巧》</a></p><h1 id="c045" class="km kn hi bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">看我的其他文章</h1><div class="jk jl ez fb jm jn"><a rel="noopener follow" target="_blank" href="/nerd-for-tech/flutter-2-null-safety-in-a-nutshell-f20aeb74772"><div class="jo ab dw"><div class="jp ab jq cl cj jr"><h2 class="bd hj fi z dy js ea eb jt ed ef hh bi translated">扑2:简而言之，零安全</h2><div class="ju l"><h3 class="bd b fi z dy js ea eb jt ed ef dx translated">你的flutter应用程序听起来不安全！</h3></div><div class="jv l"><p class="bd b fp z dy js ea eb jt ed ef dx translated">medium.com</p></div></div><div class="jw l"><div class="ms l jy jz ka jw kb ik jn"/></div></div></a></div><div class="jk jl ez fb jm jn"><a href="https://siraphobk.medium.com/flutter-basics-the-differences-between-stateless-widget-and-stateful-widget-3f66cec639b0" rel="noopener follow" target="_blank"><div class="jo ab dw"><div class="jp ab jq cl cj jr"><h2 class="bd hj fi z dy js ea eb jt ed ef hh bi translated">Flutter基础知识:无状态小部件和有状态小部件之间的区别</h2><div class="ju l"><h3 class="bd b fi z dy js ea eb jt ed ef dx translated">Flutter中的Widget是什么？理解有状态和无状态Wigets。</h3></div><div class="jv l"><p class="bd b fp z dy js ea eb jt ed ef dx translated">siraphobk.medium.com</p></div></div><div class="jw l"><div class="mt l jy jz ka jw kb ik jn"/></div></div></a></div></div></div>    
</body>
</html>