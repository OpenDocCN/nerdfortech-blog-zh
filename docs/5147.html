<html>
<head>
<title>Coroutine &amp; Retrofit</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">协程和翻新</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/coroutines-fc8a7ec2ce35?source=collection_archive---------1-----------------------#2021-09-02">https://medium.com/nerd-for-tech/coroutines-fc8a7ec2ce35?source=collection_archive---------1-----------------------#2021-09-02</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="a304" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">使用协程和改造以及其他后台任务</h2></div><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ix"><img src="../Images/f057f3f8e1857c0bd123465dd1aa805d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*u3IjD13EgKyfby4MD6SAmw.jpeg"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">来自<a class="ae jn" href="https://www.pexels.com/photo/woman-writing-on-whiteboard-3861943/?utm_content=attributionCopyText&amp;utm_medium=referral&amp;utm_source=pexels" rel="noopener ugc nofollow" target="_blank">像素</a>的<a class="ae jn" href="https://www.pexels.com/@thisisengineering?utm_content=attributionCopyText&amp;utm_medium=referral&amp;utm_source=pexels" rel="noopener ugc nofollow" target="_blank">this is 工程</a>的照片</figcaption></figure><p id="3106" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">人们可以把协程看作一个轻量级线程。像线程一样，协程可以并行运行，互相等待，互相通信。最大的区别是协程非常便宜，几乎是免费的:我们可以创建成千上万个协程，并且在性能方面付出很少。另一方面，线程的启动和维护成本很高。</p><p id="b36d" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">协程可以被认为是 AsyncTask 的替代品，用于在后台执行任务，同时希望应用程序能够响应。不再需要自己管理线程。Coroutine 提供了一种非常简单的方法来减轻主线程的负担，并在任务完成后将结果返回给主线程。</p><h2 id="62f4" class="kk kl hi bd km kn ko kp kq kr ks kt ku jx kv kw kx kb ky kz la kf lb lc ld le bi translated">为什么我们需要协程？</h2><p id="b789" class="pw-post-body-paragraph jo jp hi jq b jr lf ij jt ju lg im jw jx lh jz ka kb li kd ke kf lj kh ki kj hb bi translated">它帮助您管理长时间运行的任务，否则这些任务可能会阻塞主线程并导致您的应用程序变得无响应<br/> <strong class="jq hj">注</strong> -协程是 Android 上异步编程的推荐解决方案</p><h1 id="34ca" class="lk kl hi bd km ll lm ln kq lo lp lq ku io lr ip kx ir ls is la iu lt iv ld lu bi translated"><strong class="ak">协程的特性</strong></h1><p id="0388" class="pw-post-body-paragraph jo jp hi jq b jr lf ij jt ju lg im jw jx lh jz ka kb li kd ke kf lj kh ki kj hb bi translated"><strong class="jq hj">轻量级</strong>:由于支持<a class="ae jn" href="https://kotlinlang.org/docs/reference/coroutines/basics.html" rel="noopener ugc nofollow" target="_blank"> <em class="lv">挂起</em> </a>，所以可以在单线程上运行多个协程，不会阻塞协程运行的线程。挂起比阻塞节省内存，同时支持许多并发操作。<br/> <strong class="jq hj">更少内存泄漏</strong>:使用<a class="ae jn" href="https://kotlinlang.org/docs/reference/coroutines/basics.html#structured-concurrency" rel="noopener ugc nofollow" target="_blank"> <em class="lv">结构化并发</em> </a>运行一个范围内的操作。<br/> <strong class="jq hj">内置取消支持</strong> : <a class="ae jn" href="https://kotlinlang.org/docs/reference/coroutines/cancellation-and-timeouts.html" rel="noopener ugc nofollow" target="_blank">取消</a>通过运行的协程层次自动传播。</p><p id="efb6" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">分解协程生成器:</p><ul class=""><li id="4af3" class="lw lx hi jq b jr js ju jv jx ly kb lz kf ma kj mb mc md me bi translated"><code class="du mf mg mh mi b">launch</code> —这个构建器只是启动一个新的协程，并返回一个对它的引用，作为一个没有结果的<code class="du mf mg mh mi b">Job</code>对象。如果你想阻止当前线程，而不是启动你可以使用<code class="du mf mg mh mi b">runBlocking</code>建设者代替。</li><li id="b3c1" class="lw lx hi jq b jr mj ju mk jx ml kb mm kf mn kj mb mc md me bi translated"><code class="du mf mg mh mi b">async</code> —该构建器启动新的协程，并返回对它的引用作为可能有结果的<code class="du mf mg mh mi b">Deferred</code>类型对象。它通常与<code class="du mf mg mh mi b">await</code>一起使用，后者是一个挂起函数，可以在不阻塞当前线程的情况下等待结果。</li></ul><p id="cb9f" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">和<code class="du mf mg mh mi b">Dispatchers.Main</code>——这不是一个协程构建器，但是我们将它传递给我们的<code class="du mf mg mh mi b">launch</code>构建器，以便通知 Android 系统，我们将需要在协程执行期间的某个时间点更新 UI 线程。</p><h1 id="75ce" class="lk kl hi bd km ll lm ln kq lo lp lq ku io lr ip kx ir ls is la iu lt iv ld lu bi translated">调度员的类型</h1><p id="e16a" class="pw-post-body-paragraph jo jp hi jq b jr lf ij jt ju lg im jw jx lh jz ka kb li kd ke kf lj kh ki kj hb bi translated">主要有 4 种类型的调度程序。</p><ol class=""><li id="603f" class="lw lx hi jq b jr js ju jv jx ly kb lz kf ma kj mo mc md me bi translated">主调度员</li><li id="fccf" class="lw lx hi jq b jr mj ju mk jx ml kb mm kf mn kj mo mc md me bi translated">IO 调度程序</li><li id="d905" class="lw lx hi jq b jr mj ju mk jx ml kb mm kf mn kj mo mc md me bi translated">默认调度程序</li><li id="12cd" class="lw lx hi jq b jr mj ju mk jx ml kb mm kf mn kj mo mc md me bi translated">不受限制的调度员</li></ol><h2 id="078d" class="kk kl hi bd km kn ko kp kq kr ks kt ku jx kv kw kx kb ky kz la kf lb lc ld le bi translated">主调度员:</h2><p id="8323" class="pw-post-body-paragraph jo jp hi jq b jr lf ij jt ju lg im jw jx lh jz ka kb li kd ke kf lj kh ki kj hb bi translated">它启动主线程中的协程。它主要用于我们需要在协程中执行 UI 操作的时候，因为 UI 只能从主线程(也称为 UI 线程)中更改。</p><h2 id="fdde" class="kk kl hi bd km kn ko kp kq kr ks kt ku jx kv kw kx kb ky kz la kf lb lc ld le bi translated">IO 调度员:</h2><p id="4d0d" class="pw-post-body-paragraph jo jp hi jq b jr lf ij jt ju lg im jw jx lh jz ka kb li kd ke kf lj kh ki kj hb bi translated">它启动 IO 线程中的协程，用于执行所有数据操作，如联网、从数据库中读取或写入、读取或写入文件，例如:从数据库中获取数据是 IO 操作，在 IO 线程上完成。</p><h2 id="2e0e" class="kk kl hi bd km kn ko kp kq kr ks kt ku jx kv kw kx kb ky kz la kf lb lc ld le bi translated">默认调度程序:</h2><p id="6240" class="pw-post-body-paragraph jo jp hi jq b jr lf ij jt ju lg im jw jx lh jz ka kb li kd ke kf lj kh ki kj hb bi translated">它在默认线程中启动协程。当我们计划进行复杂和长时间运行的计算时，我们应该选择这个选项，这可能会阻塞主线程并冻结 UI，例如:假设我们需要进行 10，000 次计算，并且我们正在 UI 线程即主线程上进行所有这些计算，如果我们等待结果或 10，000 次计算，直到那时我们的主线程将被阻塞，我们的 UI 将被冻结，从而导致糟糕的用户体验。所以在这种情况下，我们需要使用默认线程。在 GlobalScope 中启动协同例程时使用的默认调度程序由 Dispatchers 表示。默认使用共享的后台线程池，所以启动(Dispatchers。Default) { … }使用与 GlobalScope.launch { … }相同的调度程序。</p><h2 id="abc3" class="kk kl hi bd km kn ko kp kq kr ks kt ku jx kv kw kx kb ky kz la kf lb lc ld le bi translated">不受限制的调度程序:</h2><p id="c504" class="pw-post-body-paragraph jo jp hi jq b jr lf ij jt ju lg im jw jx lh jz ka kb li kd ke kf lj kh ki kj hb bi translated">顾名思义，不受限制的调度程序不局限于任何特定的线程。它在当前调用帧中执行协程的初始延续，并让协程在相应挂起函数使用的任何线程中恢复，而不强制任何特定的线程策略。或者用更简单的语言来说，一个不受限制的调度程序在调用者线程中启动一个协程，但是只到第一个暂停点。挂起后，它恢复线程中的协程，这完全由被调用的挂起函数决定。<br/> <em class="lv">非受限调度程序适用于既不消耗 CPU 时间也不更新任何受限于特定线程的共享数据(如 UI)的协程。</em></p><h2 id="13ee" class="kk kl hi bd km kn ko kp kq kr ks kt ku jx kv kw kx kb ky kz la kf lb lc ld le bi translated">调度员之间的区别。IO 和调度员。默认</h2><p id="29bd" class="pw-post-body-paragraph jo jp hi jq b jr lf ij jt ju lg im jw jx lh jz ka kb li kd ke kf lj kh ki kj hb bi translated">不同的是调度员。默认限制为 CPU 核心数，最小值为 2，最大值为 N，其中 N 是存在的 CPU 核心数。因此，一次只能有 N 个任务并行运行。</p><p id="b3c6" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">在 IO 调度程序上，默认情况下有 64 个线程，因此该调度程序上最多可以运行 64 个并行任务。</p><p id="6a71" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">其思想是 IO 调度程序花费大量时间等待(IO 阻塞)，而默认调度程序则用于 CPU 密集型任务，在这种情况下很少或根本没有睡眠。</p></div><div class="ab cl mp mq gp mr" role="separator"><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu"/></div><div class="hb hc hd he hf"><p id="9eb5" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">到目前为止，您已经熟悉了与协程相关的各种术语。让我们直接进入实施阶段。</p><p id="5087" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">第一步是包含你的项目需要的所有依赖关系，如下所述</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="mw mx l"/></div></figure><p id="df15" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">第二步<strong class="jq hj">是创建我们的接口类，并定义负责定义 API Url 的方法。</strong></p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="mw mx l"/></div></figure><p id="a7c7" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><em class="lv">从</em> <code class="du mf mg mh mi b"><em class="lv">Retrofit 2.6.0</em></code> <em class="lv">开始的改进现在包括了对函数上 Kotlin </em> <code class="du mf mg mh mi b"><em class="lv">suspend</em></code> <em class="lv">修饰符的内置支持，这意味着代替了<code class="du mf mg mh mi b">Call&lt;T&gt;</code>的</em>，我们现在有了一个在我们的接口函数中定义了<code class="du mf mg mh mi b">suspend </code>修饰符的函数。根据改装文档，<strong class="jq hj">该功能将在后台表现为正常的</strong> <code class="du mf mg mh mi b"><strong class="jq hj">Call.enqueue</strong></code> <strong class="jq hj">操作。</strong></p><p id="8169" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">协程中的暂停函数是一个可以启动、暂停和恢复的函数。</p><p id="0949" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">我们将我们的响应包装在<code class="du mf mg mh mi b">Response</code>对象中，以获取关于我们的请求响应的元数据，例如像响应代码这样的信息。</p><p id="f69d" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">第三步是创建我们的 ApiInterfaceBuilder 类，它负责创建我们的改型客户端</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="mw mx l"/></div></figure><p id="6c5a" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">现在，我们已经完成了与 API 相关的所有设置。我们的第四步也是最后一步是从我们的活动中调用 API 并获取它的响应。</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="mw mx l"/></div></figure><p id="ec9d" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">让我们更深入地了解这里发生了什么。我们使用了调度员。IO，因为根据提供的文档，所有与网络相关的操作都应该使用它来完成。launch 关键字只是启动一个新的协程，并不将结果返回给调用者。getCustomerList()方法在后台线程上运行，一旦它完成，我们希望在主线程上得到结果。我们使用 withContext()方法将执行从一个线程转移到另一个线程。调度员。Main 指定 withContext()方法将在主线程上运行，因此所有与 UI 相关的操作都应该在该方法中完成</p><p id="90a0" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><em class="lv">暂时就这样吧！！<br/>感谢您的阅读，不要忘记与您的开发伙伴分享:)</em></p></div></div>    
</body>
</html>