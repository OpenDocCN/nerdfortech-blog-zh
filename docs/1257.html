<html>
<head>
<title>Reactdroid — Reactive MVI Architecture for Android— Part 2</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">react droid——Android的反应式MVI架构——第2部分</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/reactdroid-reactive-mvi-architecture-for-android-part-2-44c3c2810f52?source=collection_archive---------12-----------------------#2021-03-11">https://medium.com/nerd-for-tech/reactdroid-reactive-mvi-architecture-for-android-part-2-44c3c2810f52?source=collection_archive---------12-----------------------#2021-03-11</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><h2 id="fabe" class="hg hh hi bd b fp hj hk hl hm hn ho dx hp translated" aria-label="kicker paragraph">移动应用中的反应式编程——一次旅行</h2><div class=""/><div class=""><h2 id="1f9b" class="pw-subtitle-paragraph io hr hi bd b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf dx translated">一个全面的移动开发库，采用纯Kotlin内核设计，并扩展了Android层。快速、结构化和可靠的应用程序开发—第2部分— Redux</h2></div><h2 id="91a6" class="jg jh hi bd ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc ho bi translated">介绍</h2><p id="56ce" class="pw-post-body-paragraph kd ke hi kf b kg kh is ki kj kk iv kl jr km kn ko jv kp kq kr jz ks kt ku kv hb bi translated">在<a class="ae kw" rel="noopener" href="/@gguymi/587726a5045f">之前的文章</a>中，我们学习了<a class="ae kw" rel="noopener" href="/@gguymi/587726a5045f"> <em class="kx">如何</em> </a>实现一个<a class="ae kw" rel="noopener" href="/nerd-for-tech/react-redux-in-kotlin-for-truly-native-mobile-development-25229937d4f"> <em class="kx">反应</em>——就像<em class="kx"> Kotlin中的</em></a>架构。这一部分将从我们停下来的地方继续向我们展示<em class="kx">如何使用<a class="ae kw" href="https://github.com/ReactiveX/RxKotlin" rel="noopener ugc nofollow" target="_blank"> <em class="kx"> RxKotlin </em> </a>实现一个<a class="ae kw" rel="noopener" href="/nerd-for-tech/react-redux-in-kotlin-for-truly-native-mobile-development-25229937d4f"> <em class="kx"> Redux </em> -like </a>架构。这两个组成了<a class="ae kw" href="https://github.com/GuyMichael/Reactdroid" rel="noopener ugc nofollow" target="_blank"> <em class="kx"> Reactdroid </em> </a>库，在<em class="kx"> GitHub </em> 上有<a class="ae kw" href="https://github.com/GuyMichael/Reactdroid" rel="noopener ugc nofollow" target="_blank">可用。</a></em></p><blockquote class="ky kz la"><p id="e7e0" class="kd ke kx kf b kg lb is ki kj lc iv kl ld le kn ko lf lg kq kr lh li kt ku kv hb bi translated">本文假设你对<a class="ae kw" rel="noopener" href="/nerd-for-tech/react-redux-in-kotlin-for-truly-native-mobile-development-25229937d4f"> <em class="hi"> React </em>、<em class="hi"> Redux </em> </a>和<a class="ae kw" href="http://reactivex.io/" rel="noopener ugc nofollow" target="_blank"> <em class="hi"> rx </em> </a>有所熟悉。</p></blockquote><figure class="lk ll lm ln fd lo er es paragraph-image"><div role="button" tabindex="0" class="lp lq di lr bf ls"><div class="er es lj"><img src="../Images/aefebf23a23cb39524a253335c6141a8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kJPTyzvTeuqRVX0rlpzBlQ.jpeg"/></div></div><figcaption class="lv lw et er es lx ly bd b be z dx translated">Redux定义了单向数据流。像雨林一样:水蒸发(发送)到云(存储)，云将它们合并在一起，然后下雨(通知)到每个人:)</figcaption></figure></div><div class="ab cl lz ma gp mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="hb hc hd he hf"><h1 id="5ddc" class="mg jh hi bd ji mh mi mj jm mk ml mm jq ix mn iy ju ja mo jb jy jd mp je kc mq bi translated">(类似Redux的架构是如何搭建的)？</h1><p id="6896" class="pw-post-body-paragraph kd ke hi kf b kg kh is ki kj kk iv kl jr km kn ko jv kp kq kr jz ks kt ku kv hb bi translated"><a class="ae kw" rel="noopener" href="/@gguymi/587726a5045f">提醒你</a>——在高层次上，<em class="kx"> Reactdroid </em>的<em class="kx"> Kotlin </em>内核是这样构造的:</p><figure class="lk ll lm ln fd lo er es paragraph-image"><div class="er es mr"><img src="../Images/55f630655e10de467c7be6a05d2ad311.png" data-original-src="https://miro.medium.com/v2/resize:fit:868/format:webp/1*FpE9uM0Ln5dCT2Qjtb1L8A.png"/></div><figcaption class="lv lw et er es lx ly bd b be z dx translated">反应性类固醇的科特林核心</figcaption></figure><p id="db4a" class="pw-post-body-paragraph kd ke hi kf b kg lb is ki kj lc iv kl jr le kn ko jv lg kq kr jz li kt ku kv hb bi translated">今天我们就来聊聊<em class="kx"> Reactdroid </em>的<em class="kx"> Redux </em>内核及其<em class="kx">存储</em>。</p></div><div class="ab cl lz ma gp mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="hb hc hd he hf"><h1 id="795e" class="mg jh hi bd ji mh mi mj jm mk ml mm jq ix mn iy ju ja mo jb jy jd mp je kc mq bi translated">我们将在本文中讨论的内容</h1><ol class=""><li id="1b5b" class="ms mt hi kf b kg kh kj kk jr mu jv mv jz mw kv mx my mz na bi translated"><em class="kx">商店</em>类</li><li id="ed77" class="ms mt hi kf b kg nb kj nc jr nd jv ne jz nf kv mx my mz na bi translated"><em class="kx">存储</em>的API—<em class="kx">subscribe()</em>&amp;<em class="kx">dispatch()</em></li><li id="3136" class="ms mt hi kf b kg nb kj nc jr nd jv ne jz nf kv mx my mz na bi translated"><em class="kx">存储</em>的<em class="kx">全局状态</em>及其<em class="kx">存储键</em></li><li id="efb6" class="ms mt hi kf b kg nb kj nc jr nd jv ne jz nf kv mx my mz na bi translated"><em class="kx">储存</em>的<em class="kx">减速器</em></li><li id="ce44" class="ms mt hi kf b kg nb kj nc jr nd jv ne jz nf kv mx my mz na bi translated"><em class="kx">将</em> <a class="ae kw" rel="noopener" href="/@gguymi/587726a5045f#47f2">我们的<em class="kx">组件</em> </a>连接到<em class="kx">商店</em></li></ol><p id="6c76" class="pw-post-body-paragraph kd ke hi kf b kg lb is ki kj lc iv kl jr le kn ko jv lg kq kr jz li kt ku kv hb bi translated">下一篇文章将会更深入地探讨<em class="kx">商店</em>是如何运作的。</p></div><div class="ab cl lz ma gp mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="hb hc hd he hf"><h1 id="18ed" class="mg jh hi bd ji mh mi mj jm mk ml mm jq ix mn iy ju ja mo jb jy jd mp je kc mq bi translated">商店</h1><p id="da99" class="pw-post-body-paragraph kd ke hi kf b kg kh is ki kj kk iv kl jr km kn ko jv kp kq kr jz ks kt ku kv hb bi translated"><a class="ae kw" href="https://redux.js.org/api/store/" rel="noopener ugc nofollow" target="_blank">商店<em class="kx"/></a>是<em class="kx">全局状态</em>管理器。人们可以<em class="kx">订阅</em>它——以接收<em class="kx">全局状态</em>变化更新；并且<em class="kx">将</em>分派给它——以更新<em class="kx">全局状态</em>。</p><p id="66e8" class="pw-post-body-paragraph kd ke hi kf b kg lb is ki kj lc iv kl jr le kn ko jv lg kq kr jz li kt ku kv hb bi translated">这个<a class="ae kw" href="https://www.geeksforgeeks.org/unidirectional-data-flow/" rel="noopener ugc nofollow" target="_blank"><em class="kx">1-方向流</em> </a>是这样的(本文将涵盖一切) :</p><figure class="lk ll lm ln fd lo er es paragraph-image"><div class="er es ng"><img src="../Images/32ac1959bd944e17ce43d75d8dafc795.png" data-original-src="https://miro.medium.com/v2/resize:fit:1082/format:webp/1*6EXu0Vp8y7B9JOvZs1Hp8w.png"/></div><figcaption class="lv lw et er es lx ly bd b be z dx translated">Reactdroid的存储调度流程(单向)</figcaption></figure></div><div class="ab cl lz ma gp mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="hb hc hd he hf"><p id="5b0e" class="pw-post-body-paragraph kd ke hi kf b kg lb is ki kj lc iv kl jr le kn ko jv lg kq kr jz li kt ku kv hb bi translated">让我们创建我们的<em class="kx">商店</em>。<a class="ae kw" rel="noopener" href="/@gguymi/587726a5045f#7c93">与<em class="kx">组件</em> </a>相同，我们将使用一个<em class="kx">抽象类</em>用于特定于平台的<em class="kx">基类</em>到<em class="kx">扩展</em>(例如在<em class="kx"> Android </em> — <code class="du nh ni nj nk b">AndroidStore</code>)。扩展<em class="kx">类</em>将使用<a class="ae kw" href="https://www.baeldung.com/kotlin/objects" rel="noopener ugc nofollow" target="_blank"> <em class="kx">科特林的</em> </a> <code class="du nh ni nj nk b"><a class="ae kw" href="https://www.baeldung.com/kotlin/objects" rel="noopener ugc nofollow" target="_blank">object</a></code>(单例)。</p><figure class="lk ll lm ln fd lo"><div class="bz dy l di"><div class="nl nm l"/></div><figcaption class="lv lw et er es lx ly bd b be z dx translated">Reactdroid的存储声明。简化。</figcaption></figure><p id="847a" class="pw-post-body-paragraph kd ke hi kf b kg lb is ki kj lc iv kl jr le kn ko jv lg kq kr jz li kt ku kv hb bi translated">这个<em class="kx">构造函数</em>由两个参数组成:</p><ol class=""><li id="8102" class="ms mt hi kf b kg lb kj lc jr nn jv no jz np kv mx my mz na bi translated"><code class="du nh ni nj nk b">mainReducer</code> —将持有<em class="kx">库</em>的所有<em class="kx">减速器</em>(作为<code class="du nh ni nj nk b">List</code>)</li><li id="e2d2" class="ms mt hi kf b kg nb kj nc jr nd jv ne jz nf kv mx my mz na bi translated"><code class="du nh ni nj nk b">preloadedState </code>—<strong class="kf hs">初始</strong> <em class="kx">状态</em>用于<strong class="kf hs"> app启动时</strong></li></ol><p id="4c44" class="pw-post-body-paragraph kd ke hi kf b kg lb is ki kj lc iv kl jr le kn ko jv lg kq kr jz li kt ku kv hb bi translated">并且唯一的成员是(全局)<code class="du nh ni nj nk b">state</code>对象，如果给定，则用<code class="du nh ni nj nk b">preloadedState</code>(例如来自<em class="kx"> API服务器</em>的一些<em class="kx">状态</em>)初始化，或者用<code class="du nh ni nj nk b">mainReducer</code>提供的<em class="kx">还原器</em>-定义的应用程序初始状态初始化(例如根据本地DB的一些<em class="kx">状态</em>)。</p></div><div class="ab cl lz ma gp mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="hb hc hd he hf"><h2 id="4dd0" class="jg jh hi bd ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc ho bi translated">商店的API</h2><p id="117a" class="pw-post-body-paragraph kd ke hi kf b kg kh is ki kj kk iv kl jr km kn ko jv kp kq kr jz ks kt ku kv hb bi translated"><em class="kx">商店</em>的核心API由两个方法组成— <code class="du nh ni nj nk b">subscribe()</code>和<code class="du nh ni nj nk b">dispatch()</code>。<br/>一个给<em class="kx">订阅</em>的<em class="kx">全局状态</em>更新，另一个更新它。</p><p id="b933" class="pw-post-body-paragraph kd ke hi kf b kg lb is ki kj lc iv kl jr le kn ko jv lg kq kr jz li kt ku kv hb bi translated">下面是这两个API的(非常)简化的声明:</p><figure class="lk ll lm ln fd lo"><div class="bz dy l di"><div class="nl nm l"/></div><figcaption class="lv lw et er es lx ly bd b be z dx translated">商店的API。非常简化。</figcaption></figure><p id="335c" class="pw-post-body-paragraph kd ke hi kf b kg lb is ki kj lc iv kl jr le kn ko jv lg kq kr jz li kt ku kv hb bi translated"><a class="ae kw" href="https://github.com/GuyMichael/Reactdroid/blob/master/reactdroid/src/main/java/com/guymichael/kotlinflux/model/Store.kt" rel="noopener ugc nofollow" target="_blank">实际上</a>，这个声明要复杂得多，有<a class="ae kw" href="https://www.baeldung.com/kotlin/generics" rel="noopener ugc nofollow" target="_blank">泛型</a>和<a class="ae kw" href="https://reactjs.org/docs/higher-order-components.html" rel="noopener ugc nofollow" target="_blank">hoc</a>等等。但是我们现在真的没有时间，下面的文章会更深入😉。</p><blockquote class="ky kz la"><p id="4bc0" class="kd ke kx kf b kg lb is ki kj lc iv kl ld le kn ko lf lg kq kr lh li kt ku kv hb bi translated">提醒一下，<em class="hi"> Redux </em>(以及<em class="hi"> Store </em>)与<em class="hi">React</em>——<a class="ae kw" href="https://react-redux.js.org/introduction/quick-start" rel="noopener ugc nofollow" target="_blank">没有任何关系，除非我们将它们绑定在一起</a> <em class="hi">(用一个</em>组件<em class="hi">——专用</em>订阅<em class="hi">方法)</em>。<br/>因此，<em class="hi">存储</em>是一个独立的<em class="hi">全局状态</em>管理器，任何人都可以通过使用一个纯<a class="ae kw" href="https://www.journaldev.com/22594/rxjava-observables-observers" rel="noopener ugc nofollow" target="_blank"> <em class="hi">接收观察器</em> </a>而不是<em class="hi">组件</em>来<em class="hi">订阅</em>。</p></blockquote></div><div class="ab cl lz ma gp mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="hb hc hd he hf"><h2 id="4d4e" class="jg jh hi bd ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc ho bi translated">全球国家</h2><p id="297a" class="pw-post-body-paragraph kd ke hi kf b kg kh is ki kj kk iv kl jr km kn ko jv kp kq kr jz ks kt ku kv hb bi translated"><a class="ae kw" href="https://redux.js.org/introduction/core-concepts" rel="noopener ugc nofollow" target="_blank">全局状态</a>持有整个app的整体<em class="kx">状态</em>。<br/>这意味着它应该能够容纳<strong class="kf hs">任何</strong>类型的<em class="kx">物体</em>，否则我们会受到很大的限制。难怪，它只是一个<code class="du nh ni nj nk b">HashMap</code>:)</p><figure class="lk ll lm ln fd lo"><div class="bz dy l di"><div class="nl nm l"/></div><figcaption class="lv lw et er es lx ly bd b be z dx translated">Reactdroid的全局状态。</figcaption></figure><p id="db25" class="pw-post-body-paragraph kd ke hi kf b kg lb is ki kj lc iv kl jr le kn ko jv lg kq kr jz li kt ku kv hb bi translated"><code class="du nh ni nj nk b">map</code>将一个<code class="du nh ni nj nk b">String</code>键映射到<code class="du nh ni nj nk b">Any?</code> <em class="kx">对象</em>(可空)值。<br/>此外，正如你所看到的，底层的<code class="du nh ni nj nk b">map</code>是<code class="du nh ni nj nk b"><a class="ae kw" href="https://www.journaldev.com/20235/kotlin-visibility-modifiers-public-protected-internal-private#internal-modifier" rel="noopener ugc nofollow" target="_blank">internal</a></code>——我们将使用‘getters’来轻松地从中检索值——因为这个<code class="du nh ni nj nk b">map</code>将会很大，有很多层次结构。</p><p id="dda3" class="pw-post-body-paragraph kd ke hi kf b kg lb is ki kj lc iv kl jr le kn ko jv lg kq kr jz li kt ku kv hb bi translated">虽然这个<code class="du nh ni nj nk b">map</code>的键是原始的<code class="du nh ni nj nk b">String</code>，但是从<em class="kx">全局状态</em>中更新和检索需要<em class="kx">存储键</em>。</p></div><div class="ab cl lz ma gp mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="hb hc hd he hf"><h2 id="aa15" class="jg jh hi bd ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc ho bi translated">全局状态的存储密钥</h2><p id="ee80" class="pw-post-body-paragraph kd ke hi kf b kg kh is ki kj kk iv kl jr km kn ko jv kp kq kr jz ks kt ku kv hb bi translated"><em class="kx"> StoreKey </em>基本上只是一个<em class="kx">返回</em>一个<code class="du nh ni nj nk b">String</code>的<a class="ae kw" href="https://www.javatpoint.com/java-8-functional-interfaces" rel="noopener ugc nofollow" target="_blank"> <em class="kx">功能接口</em> </a>。<br/>那个<code class="du nh ni nj nk b">String</code>是指<em class="kx">全局状态</em>的<code class="du nh ni nj nk b">map</code>键。<br/>实际中的键将是<em class="kx">枚举</em>(或者可能是<em class="kx"> Kotlin </em>的<a class="ae kw" href="https://kotlinlang.org/docs/sealed-classes.html" rel="noopener ugc nofollow" target="_blank"> <em class="kx">密封类</em> </a>)，它将实现这个<em class="kx">接口</em>:</p><figure class="lk ll lm ln fd lo"><div class="bz dy l di"><div class="nl nm l"/></div><figcaption class="lv lw et er es lx ly bd b be z dx translated">用于将值检索/分派到存储区的StoreKey。简化。</figcaption></figure><p id="ea2c" class="pw-post-body-paragraph kd ke hi kf b kg lb is ki kj lc iv kl jr le kn ko jv lg kq kr jz li kt ku kv hb bi translated">为什么不直接用<em class="kx">弦</em>？嗯，随着我们的深入，这将变得更加清楚，但是，例如，这样我们可以将一个<em class="kx"> StoreKey </em>绑定到一个特定的<em class="kx"> Reducer </em>并向其添加“getters ”,以方便地从<em class="kx">存储</em>中检索其各自的值。</p><blockquote class="ky kz la"><p id="f379" class="kd ke kx kf b kg lb is ki kj lc iv kl ld le kn ko lf lg kq kr lh li kt ku kv hb bi translated">注意:这就是我们与<em class="hi">JavaScript</em><em class="hi">Redux</em>的不同之处，后者需要原始字符串作为<em class="hi">键。</em></p></blockquote></div><div class="ab cl lz ma gp mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="hb hc hd he hf"><h2 id="de24" class="jg jh hi bd ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc ho bi translated">渐缩管</h2><p id="ff1e" class="pw-post-body-paragraph kd ke hi kf b kg kh is ki kj kk iv kl jr km kn ko jv kp kq kr jz ks kt ku kv hb bi translated">这部分不太直观。和我在一起🤓。<br/><em class="kx">存储</em>同时保存<em class="kx">全局状态</em>和<em class="kx">减速器</em> (s)，简单来说，<em class="kx">减速器</em> (s)帮助更新<em class="kx">全局状态</em>。就是这样。</p><p id="455b" class="pw-post-body-paragraph kd ke hi kf b kg lb is ki kj lc iv kl jr le kn ko jv lg kq kr jz li kt ku kv hb bi translated">现在我们冷静下来了，我们也说一下，每个<em class="kx">减速器</em>负责更新自己的那部分蛋糕；对不起，<em class="kx">全局状态</em>。<br/>例如，每个<em class="kx">减速器</em>可能在我们的应用程序中负责不同的功能。有道理？</p><p id="be89" class="pw-post-body-paragraph kd ke hi kf b kg lb is ki kj lc iv kl jr le kn ko jv lg kq kr jz li kt ku kv hb bi translated"><a class="ae kw" href="https://www.techopedia.com/definition/16447/state-machine" rel="noopener ugc nofollow" target="_blank">状态机</a>是这样的:</p><figure class="lk ll lm ln fd lo er es paragraph-image"><div class="er es nq"><img src="../Images/184a93a54b9472290ae16911f6db88e5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1360/format:webp/1*qnTDp81f8pKIOPY8cMSgpQ.png"/></div><figcaption class="lv lw et er es lx ly bd b be z dx translated">储存异径管单向流动</figcaption></figure><p id="034b" class="pw-post-body-paragraph kd ke hi kf b kg lb is ki kj lc iv kl jr le kn ko jv lg kq kr jz li kt ku kv hb bi translated">在每个<em class="kx">调度</em>时，每个<em class="kx">减速器</em>接收3个参数:<br/> <em class="kx">前一状态</em>、(<em class="kx">存储</em> ) <em class="kx">键</em>和<em class="kx">值。</em>利用它们，每个<em class="kx">减速器</em>产生一个新的“小”<em class="kx">全局状态</em>——以取代蛋糕中与其相关的部分；不好意思，<em class="kx">全局状态</em>。<br/>最后，<em class="kx">商店</em>将所有“小”部分合并到“大”部分<em class="kx">全局状态</em>中，并通知其<em class="kx">订户</em>。</p><p id="e052" class="pw-post-body-paragraph kd ke hi kf b kg lb is ki kj lc iv kl jr le kn ko jv lg kq kr jz li kt ku kv hb bi translated">说够了，让我们来制造<em class="kx">减速器</em>:</p><figure class="lk ll lm ln fd lo"><div class="bz dy l di"><div class="nl nm l"/></div><figcaption class="lv lw et er es lx ly bd b be z dx translated">Reactdroid减速器。简化。</figcaption></figure><p id="616c" class="pw-post-body-paragraph kd ke hi kf b kg lb is ki kj lc iv kl jr le kn ko jv lg kq kr jz li kt ku kv hb bi translated">正如你所看到的，<em class="kx">构造器</em>接受一个【子】<em class="kx">归约器</em>的<code class="du nh ni nj nk b">List</code>——这就是我们如何创建<code class="du nh ni nj nk b">mainReducer</code>的，它被<em class="kx">存储</em>接收到它的<em class="kx">构造器</em>。</p><p id="9401" class="pw-post-body-paragraph kd ke hi kf b kg lb is ki kj lc iv kl jr le kn ko jv lg kq kr jz li kt ku kv hb bi translated"><code class="du nh ni nj nk b">onNewAction</code>回调由<em class="kx">商店</em>在每个<em class="kx">派单</em>上调用，请求新的<em class="kx">全球状态</em>零件。</p><p id="7912" class="pw-post-body-paragraph kd ke hi kf b kg lb is ki kj lc iv kl jr le kn ko jv lg kq kr jz li kt ku kv hb bi translated">是的，你没看错——全局<em class="kx">状态</em>的<em class="kx">缩减器</em>的“小”部分和<em class="kx">存储</em>的“大”部分，合并的全局<em class="kx">状态</em>，具有相同的类型——<code class="du nh ni nj nk b">GlobalState</code>。<br/>由于<em class="kx">全局状态</em>基本上只是一个<code class="du nh ni nj nk b">HashMap</code>，因此我们有一个大的<em class="kx">散列表</em>来保存多个较小的<em class="kx">散列表</em>——每个<em class="kx">缩减器</em>一个散列表。像这样:</p><figure class="lk ll lm ln fd lo"><div class="bz dy l di"><div class="nl nm l"/></div><figcaption class="lv lw et er es lx ly bd b be z dx translated">“原始”应用程序全局状态的示例</figcaption></figure><p id="b69a" class="pw-post-body-paragraph kd ke hi kf b kg lb is ki kj lc iv kl jr le kn ko jv lg kq kr jz li kt ku kv hb bi translated">最后，<code class="du nh ni nj nk b">getDefaultState()</code>方法主要用于app启动，此时<em class="kx">商店</em>将从所有减速器的默认<em class="kx">状态</em>中创建其初始<em class="kx">全局状态</em>。<br/>例如，一个<em class="kx">缩减器</em>可能是一个<em class="kx">数据缩减器</em>，它返回所有的数据库数据，这就是我们在应用启动时将数据库加载到<em class="kx">存储</em>的方式:)</p><p id="7df2" class="pw-post-body-paragraph kd ke hi kf b kg lb is ki kj lc iv kl jr le kn ko jv lg kq kr jz li kt ku kv hb bi translated">综上所述:<em class="kx">减速器</em>的<code class="du nh ni nj nk b">onNewAction</code>就是它如何控制整体<em class="kx">全局状态</em>的一个特定的、较小的部分。<br/>和<em class="kx">店</em>一样，将<em class="kx">扩展</em>为<a class="ae kw" href="https://www.baeldung.com/kotlin/objects" rel="noopener ugc nofollow" target="_blank"> <em class="kx"> Kotlin </em> </a> <code class="du nh ni nj nk b"><a class="ae kw" href="https://www.baeldung.com/kotlin/objects" rel="noopener ugc nofollow" target="_blank">object</a></code>(单胞胎)。</p></div><div class="ab cl lz ma gp mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="hb hc hd he hf"><h1 id="9697" class="mg jh hi bd ji mh mi mj jm mk ml mm jq ix mn iy ju ja mo jb jy jd mp je kc mq bi translated">总结流程</h1><p id="424c" class="pw-post-body-paragraph kd ke hi kf b kg kh is ki kj kk iv kl jr km kn ko jv kp kq kr jz ks kt ku kv hb bi translated">在我们用一个<em class="kx">连接组件</em>的例子结束本文之前，让我们再看一下流程图，总结一下正在发生的事情，现在我们已经理解了所有的部分:</p><figure class="lk ll lm ln fd lo er es paragraph-image"><div class="er es ng"><img src="../Images/32ac1959bd944e17ce43d75d8dafc795.png" data-original-src="https://miro.medium.com/v2/resize:fit:1082/format:webp/1*6EXu0Vp8y7B9JOvZs1Hp8w.png"/></div><figcaption class="lv lw et er es lx ly bd b be z dx translated">Reactdroid的存储调度流程(单向)</figcaption></figure><ol class=""><li id="d654" class="ms mt hi kf b kg lb kj lc jr nn jv no jz np kv mx my mz na bi translated">一个<em class="kx">组件</em>(例如)<em class="kx">调度</em>一个<em class="kx">动作</em> ( <em class="kx"> StoreKey </em>，<em class="kx"> value </em>)。</li><li id="bc35" class="ms mt hi kf b kg nb kj nc jr nd jv ne jz nf kv mx my mz na bi translated"><em class="kx">存储</em>在其所有<em class="kx">减速器</em>上执行<code class="du nh ni nj nk b">onNewAction</code>，并接收一个“小”<em class="kx">全局状态</em>列表。</li><li id="4e7c" class="ms mt hi kf b kg nb kj nc jr nd jv ne jz nf kv mx my mz na bi translated"><em class="kx">商店</em>将所有“小”部分合并成1个“大”<em class="kx">全局状态</em>并更新其<br/> <code class="du nh ni nj nk b">var state: GlobalState</code></li><li id="b2d7" class="ms mt hi kf b kg nb kj nc jr nd jv ne jz nf kv mx my mz na bi translated"><em class="kx">商店</em>通知所有<em class="kx">用户</em>新的<em class="kx">状态</em>，例如<em class="kx">组件</em>。</li></ol><p id="f968" class="pw-post-body-paragraph kd ke hi kf b kg lb is ki kj lc iv kl jr le kn ko jv lg kq kr jz li kt ku kv hb bi translated">我们完了💪。让我们回顾一下我们所做的一切的简化版本，以便透视:</p><figure class="lk ll lm ln fd lo"><div class="bz dy l di"><div class="nl nm l"/></div><figcaption class="lv lw et er es lx ly bd b be z dx translated">Reactroid的Redux实现概述。简化。</figcaption></figure><p id="4bc1" class="pw-post-body-paragraph kd ke hi kf b kg lb is ki kj lc iv kl jr le kn ko jv lg kq kr jz li kt ku kv hb bi translated">这个，就在那里👆，是<em class="kx"> Redux </em>，在<em class="kx"> Kotlin </em>🤘<em class="kx">T13】🤓 🤘<em class="kx">。</em></em></p></div><div class="ab cl lz ma gp mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="hb hc hd he hf"><h1 id="1b7b" class="mg jh hi bd ji mh mi mj jm mk ml mm jq ix mn iy ju ja mo jb jy jd mp je kc mq bi translated">我们的第一个连接组件</h1><p id="9c01" class="pw-post-body-paragraph kd ke hi kf b kg kh is ki kj kk iv kl jr km kn ko jv kp kq kr jz ks kt ku kv hb bi translated">还记得上一篇文章中的<a class="ae kw" rel="noopener" href="/@gguymi/587726a5045f#e3bd"> <em class="kx">按钮组件</em>吗？它的<em class="kx">文本</em>受它的(<em class="kx">组件</em>)父控件控制。让我们改为<em class="kx">将</em>连接到<em class="kx">商店</em>:</a></p><figure class="lk ll lm ln fd lo"><div class="bz dy l di"><div class="nl nm l"/></div><figcaption class="lv lw et er es lx ly bd b be z dx translated">与存储区连接的button组件</figcaption></figure><p id="f923" class="pw-post-body-paragraph kd ke hi kf b kg lb is ki kj lc iv kl jr le kn ko jv lg kq kr jz li kt ku kv hb bi translated">我们的<em class="kx">按钮</em>的<em class="kx">文本</em>现在是<em class="kx">连接</em>到<em class="kx">存储</em>而不是由它的父节点控制。在一个实际的应用程序中，这意味着你可以将<strong class="kf hs">许多</strong> <em class="kx">组件</em>连接到<em class="kx">商店</em>中的同一个<em class="kx">值</em> (s)，所以当它被更新时，<strong class="kf hs">所有的</strong>都被自动地重新<em class="kx">渲染</em>。没有麻烦。<br/>此外，与<a class="ae kw" rel="noopener" href="/@gguymi/587726a5045f#e3bd"> <em class="kx">前一个</em> </a>相反，这个例子中的父节点不会在按钮点击时重新<em class="kx">呈现</em>，因为它更新的是<em class="kx">存储</em>而不是它的<em class="kx">own state</em>——这也是一个很好的补充。</p><p id="de05" class="pw-post-body-paragraph kd ke hi kf b kg lb is ki kj lc iv kl jr le kn ko jv lg kq kr jz li kt ku kv hb bi translated">我们将在下一篇文章中讨论<em class="kx">连接</em>方法是如何工作的…</p><blockquote class="ky kz la"><p id="5e9c" class="kd ke kx kf b kg lb is ki kj lc iv kl ld le kn ko lf lg kq kr lh li kt ku kv hb bi translated">注意:<em class="hi"> Reactdroid </em>的<em class="hi"> mapStateToProps </em>是两个<a class="ae kw" href="https://redux.js.org/" rel="noopener ugc nofollow" target="_blank">‘real’<em class="hi">Redux Connect</em></a>方法的合并:<a class="ae kw" href="https://react-redux.js.org/api/connect" rel="noopener ugc nofollow" target="_blank"><em class="hi">mapStateToProps</em>+<em class="hi">merge props</em></a>。</p></blockquote></div><div class="ab cl lz ma gp mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="hb hc hd he hf"><h1 id="f779" class="mg jh hi bd ji mh mi mj jm mk ml mm jq ix mn iy ju ja mo jb jy jd mp je kc mq bi translated">摘要</h1><p id="835c" class="pw-post-body-paragraph kd ke hi kf b kg kh is ki kj kk iv kl jr km kn ko jv kp kq kr jz ks kt ku kv hb bi translated">我们现在(几乎)知道如何为<em class="kx"> Kotlin </em>创建我们自己的<em class="kx"> Redux </em>实现！正如你可能理解的那样，事情远不止如此。接下来的文章将更深入，进入<em class="kx">连接的</em> <a class="ae kw" href="https://reactjs.org/docs/higher-order-components.html" rel="noopener ugc nofollow" target="_blank"> HOC </a>和<a class="ae kw" href="https://github.com/ReactiveX/RxKotlin" rel="noopener ugc nofollow" target="_blank"> RxKotlin </a>实现的<em class="kx">商店</em>。我希望你和我一样兴奋:)<br/>在那里见(即将到来！)</p></div></div>    
</body>
</html>