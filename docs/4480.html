<html>
<head>
<title>Convert Files and Folders Structures to Bash Scripts, with NodeJS</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用NodeJS将文件和文件夹结构转换成Bash脚本</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/convert-files-and-folders-structures-to-bash-scripts-with-nodejs-de2c29d036cd?source=collection_archive---------17-----------------------#2021-07-22">https://medium.com/nerd-for-tech/convert-files-and-folders-structures-to-bash-scripts-with-nodejs-de2c29d036cd?source=collection_archive---------17-----------------------#2021-07-22</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="f497" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这是一个简单的NodeJS应用程序，它将一个源文件夹作为输入，并生成一个Bash脚本。Bash脚本在源文件夹中有所有文件的内容和文件夹的结构，它可以在执行时重新创建它们。</p><p id="aadd" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这里有源代码:<a class="ae jd" href="https://github.com/alexadam/folders-to-script" rel="noopener ugc nofollow" target="_blank">https://github.com/alexadam/folders-to-script</a></p><p id="27a2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">第一步，遍历源文件夹中的所有文件:</p><pre class="je jf jg jh fd ji jj jk jl aw jm bi"><span id="e014" class="jn jo hi jj b fi jp jq l jr js">const fs = require("fs")<br/>const path = require("path")</span><span id="fc4b" class="jn jo hi jj b fi jt jq l jr js">const listFiles = (dirPath, result) =&gt; {<br/> files = fs.readdirSync(dirPath)</span><span id="fe77" class="jn jo hi jj b fi jt jq l jr js"> result = result || ['#!/bin/sh']</span><span id="e5df" class="jn jo hi jj b fi jt jq l jr js"> for (const file of files) {<br/>   ///...<br/> }</span><span id="8944" class="jn jo hi jj b fi jt jq l jr js"> return result<br/>}</span><span id="ee0f" class="jn jo hi jj b fi jt jq l jr js">const allFiles = listFiles(rootPath)</span><span id="61e1" class="jn jo hi jj b fi jt jq l jr js">fs.writeFileSync('./result.sh', allFiles.join('\n'))</span></pre><p id="de1a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果<strong class="ih hj">文件</strong>是一个目录，添加一个<code class="du ju jv jw jj b">mkdir -p</code>命令:</p><pre class="je jf jg jh fd ji jj jk jl aw jm bi"><span id="55c8" class="jn jo hi jj b fi jp jq l jr js">for (const file of files) {<br/> if (fs.statSync(dirPath + "/" + file).isDirectory()) {<br/> result.push(`mkdir -p ${path.join(dirPath, "/",  file).replace(rootPath, '.')}`)<br/> result = listFiles(dirPath + "/" + file, result)<br/> } <br/>}</span></pre><p id="e271" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">否则，根据扩展名测试<strong class="ih hj">文件</strong>是二进制还是文本:</p><pre class="je jf jg jh fd ji jj jk jl aw jm bi"><span id="6ea9" class="jn jo hi jj b fi jp jq l jr js">const textExt = ['txt', 'md', 'html', 'json', 'js', 'jsx', 'ts', 'tsx'];<br/>const binaryExt = ['jpg', 'png', 'gif', 'pdf', 'mp3', 'mp4'];</span><span id="79d4" class="jn jo hi jj b fi jt jq l jr js">const getFileExt = (filePath) =&gt; filePath.split('.').pop()</span><span id="eca0" class="jn jo hi jj b fi jt jq l jr js">...<br/>    else {<br/>      const filePath = path.join(dirPath, "/", file);<br/>      const fileExt = getFileExt(filePath);<br/>      const fileContent = fs.readFileSync(filePath);</span><span id="9ece" class="jn jo hi jj b fi jt jq l jr js">      if (textExt.includes(fileExt)) {<br/>        result.push(`<br/>cat &gt; ${path.join(dirPath, "/", file).replace(rootPath, '.')} &lt;&lt; "EOF"<br/>${fileContent}<br/>EOF<br/>`)<br/>      } else if (binaryExt.includes(fileExt)) {<br/>        const bindata = fileContent.toString('binary');<br/>        const hexdata = new Buffer(bindata, 'ascii').toString('hex');<br/>        result.push(`echo '${hexdata}' | xxd -r -p &gt; ${path.join(dirPath, "/", file).replace(rootPath, '.')}`)<br/>      }<br/>    }<br/>...</span></pre><p id="a1b3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">二进制文件存储为十六进制字符串。</p><p id="eb29" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">您可以在<em class="jx"> textExt </em>或<em class="jx"> binaryExt </em>数组中添加/删除文件扩展名。</p><p id="6a9d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这是完整的NodeJS脚本:</p><pre class="je jf jg jh fd ji jj jk jl aw jm bi"><span id="5adf" class="jn jo hi jj b fi jp jq l jr js">const fs = require("fs")<br/>const path = require("path")</span><span id="ae0f" class="jn jo hi jj b fi jt jq l jr js">const rootPath = process.argv[2]</span><span id="54bf" class="jn jo hi jj b fi jt jq l jr js">const textExt = ['txt', 'md', 'html', 'json', 'js', 'jsx', 'ts', 'tsx'];<br/>const binaryExt = ['jpg', 'png', 'gif', 'pdf', 'mp3', 'mp4'];</span><span id="22fb" class="jn jo hi jj b fi jt jq l jr js">const getFileExt = (filePath) =&gt; filePath.split('.').pop()</span><span id="c3d0" class="jn jo hi jj b fi jt jq l jr js">const listFiles = (dirPath, result) =&gt; {<br/>  files = fs.readdirSync(dirPath)</span><span id="abcb" class="jn jo hi jj b fi jt jq l jr js">  result = result || ['#!/bin/sh']</span><span id="d56f" class="jn jo hi jj b fi jt jq l jr js">  for (const file of files) {<br/>    if (fs.statSync(dirPath + "/" + file).isDirectory()) {<br/>      result.push(`mkdir -p ${path.join(dirPath, "/", file).replace(rootPath, '.')}`)<br/>      result = listFiles(dirPath + "/" + file, result)<br/>    } else {<br/>      const filePath = path.join(dirPath, "/", file);<br/>      const fileExt = getFileExt(filePath);<br/>      const fileContent = fs.readFileSync(filePath);</span><span id="7c31" class="jn jo hi jj b fi jt jq l jr js">      if (textExt.includes(fileExt)) {<br/>        result.push(`<br/>cat &gt; ${path.join(dirPath, "/", file).replace(rootPath, '.')} &lt;&lt; "EOF"<br/>${fileContent}<br/>EOF<br/>`)<br/>      } else if (binaryExt.includes(fileExt)) {<br/>        const bindata = fileContent.toString('binary');<br/>        const hexdata = new Buffer(bindata, 'ascii').toString('hex');<br/>        result.push(`echo '${hexdata}' | xxd -r -p &gt; ${path.join(dirPath, "/", file).replace(rootPath, '.')}`)<br/>      }<br/>    }<br/>  }</span><span id="427e" class="jn jo hi jj b fi jt jq l jr js">  return result<br/>}</span><span id="248c" class="jn jo hi jj b fi jt jq l jr js">const allFiles = listFiles(rootPath)</span><span id="4c18" class="jn jo hi jj b fi jt jq l jr js">fs.writeFileSync('./result.sh', allFiles.join('\n'))</span></pre><p id="3718" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">用<code class="du ju jv jw jj b">node index.js test</code> - &gt;测试它，它会生成一个Bash脚本文件，名为<a class="ae jd" href="http://result.sh" rel="noopener ugc nofollow" target="_blank"> <em class="jx"> result.sh </em> </a></p><p id="c233" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">然后，在一个空目录中，用<code class="du ju jv jw jj b">sh result.sh</code>执行脚本。</p></div></div>    
</body>
</html>