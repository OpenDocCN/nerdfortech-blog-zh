<html>
<head>
<title>Behind the Scene of JVM</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JVM的幕后</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/behind-the-scene-of-jvm-5698267a439a?source=collection_archive---------6-----------------------#2021-05-06">https://medium.com/nerd-for-tech/behind-the-scene-of-jvm-5698267a439a?source=collection_archive---------6-----------------------#2021-05-06</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/819b319eea23d2993bb3904e91e30624.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*785rzqX1mtva5Wjr"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">约纳斯·勒普在<a class="ae iu" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="bbd2" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">尽管大多数Java开发人员对JVM有基本的了解，但他们几乎不知道在这个JVM下到底发生了什么。你可能已经知道这个神奇的短语，即<em class="jt">“JVM是为了把你的字节码转换成机器码”</em>。虽然没有错，但是JVM不仅仅是为了将字节码转换成机器码。因此，在这篇文章中，我将讨论JVM架构以及它是如何工作的。</p><p id="3fbc" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在进入JVM之前，您需要知道有两种类型的虚拟机。分别是<strong class="ix hj">基于系统的虚拟机(SVM </strong>)和<strong class="ix hj">基于应用的虚拟机(AVM) </strong>。</p><p id="163e" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">🔹<strong class="ix hj">基于系统的虚拟机(SVM) </strong></p><p id="728f" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">支持向量机需要一个或多个硬件组件，它可以创建多个工作环境。这些环境彼此完全独立。</p><p id="b605" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">示例:VMWare、VirtualBox</p><p id="b79a" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">🔹<strong class="ix hj">基于应用的虚拟机(AVM) </strong></p><p id="1eef" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">AVM也称为基于进程的虚拟机。AVM不需要任何硬件组件，它基本上是一个软件/过程，帮助您创建运行其他程序的平台。</p><p id="d3b1" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">例如:Java程序的JVM，Java程序的CLR。网络程序</p><p id="796e" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如上所述，JVM是一个基于应用的虚拟机，它完全是一个规范。那么我们怎样才能让JVM进入我们的机器呢？您只是不能将JVM下载或安装到您的机器上。记住JVM只是一个进程，它在你开始运行Java程序之前是不存在的。那么当你执行一个Java程序时，JVM是如何存在的呢？这就是JRE的由来。</p><p id="3132" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">Java运行时环境(JRE)，是运行Java应用程序所需的最小环境。当您将JRE下载并安装到您的机器上时，它会部署一个特定的代码，该代码需要在任何时候创建一个JVM实例。</p><h2 id="0f75" class="ju jv hi bd jw jx jy jz ka kb kc kd ke jg kf kg kh jk ki kj kk jo kl km kn ko bi translated">创建JVM的实例</h2><p id="601f" class="pw-post-body-paragraph iv iw hi ix b iy kp ja jb jc kq je jf jg kr ji jj jk ks jm jn jo kt jq jr js hb bi translated">那么JRE如何知道何时创建JVM的实例呢？在您的机器上，您可以使用终端或特定的IDE(例如IntelliJ IDEA，Eclipse)编写Java程序。在这个场景中，我将使用终端创建一个名为“Student”的Java文件。</p><p id="2324" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">创建Java文件后，您必须使用Java编译器将这个Java文件编译成一个类文件。转到Java文件目录并简单地输入，</p><blockquote class="ku kv kw"><p id="8bb1" class="iv iw jt ix b iy iz ja jb jc jd je jf kx jh ji jj ky jl jm jn kz jp jq jr js hb bi translated"><strong class="ix hj">" Javac student . Java "</strong><em class="hi">在终端上点击回车。</em></p></blockquote><p id="2380" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">它会把你的java文件编译成一个类文件。现在您可以使用下面的命令运行这个类文件，</p><blockquote class="ku kv kw"><p id="e285" class="iv iw jt ix b iy iz ja jb jc jd je jf kx jh ji jj ky jl jm jn kz jp jq jr js hb bi translated"><strong class="ix hj">【Java Student】</strong><em class="hi">在终端上点击回车。</em></p></blockquote><p id="ce6d" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">因此，此时它要求您的操作系统提供一个JVM实例来运行这个类文件。然后它创建一个非demon线程，并从初始类(带有main方法的类)开始执行。JVM的实例将一直存在，直到最后一个非demon线程存在。</p></div><div class="ab cl la lb gp lc" role="separator"><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf"/></div><div class="hb hc hd he hf"><h1 id="5b16" class="lh jv hi bd jw li lj lk ka ll lm ln ke lo lp lq kh lr ls lt kk lu lv lw kn lx bi translated">JVM架构内部</h1><p id="39e5" class="pw-post-body-paragraph iv iw hi ix b iy kp ja jb jc kq je jf jg kr ji jj jk ks jm jn jo kt jq jr js hb bi translated">在JVM体系结构中，有3个主要组件，分别命名为，<strong class="ix hj">类加载器，存储区，执行引擎。</strong></p><figure class="lz ma mb mc fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ly"><img src="../Images/8cbb9e08f69f94e6c7da403a88b5c098.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DVnqRmetNKFEZrcZA8JoQA.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">JVM架构(图片:【https://javatutorial.net/jvm-explained】T2</figcaption></figure><h1 id="9ab7" class="lh jv hi bd jw li md lk ka ll me ln ke lo mf lq kh lr mg lt kk lu mh lw kn lx bi translated"><strong class="ak"> 1。类别加载器</strong></h1><p id="24b2" class="pw-post-body-paragraph iv iw hi ix b iy kp ja jb jc kq je jf jg kr ji jj jk ks jm jn jo kt jq jr js hb bi translated">每当我们运行一个java程序时，那些编译好的类文件就会被加载到类加载器中。JVM中有3个内置的类装入器，</p><ul class=""><li id="8a5c" class="mi mj hi ix b iy iz jc jd jg mk jk ml jo mm js mn mo mp mq bi translated">引导类装入器</li><li id="cfc6" class="mi mj hi ix b iy mr jc ms jg mt jk mu jo mv js mn mo mp mq bi translated">扩展类加载器</li><li id="44d6" class="mi mj hi ix b iy mr jc ms jg mt jk mu jo mv js mn mo mp mq bi translated">系统类装入器</li></ul><p id="32fc" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">除了这些内置的类加载器之外，你还可以在Java中直接创建一个<strong class="ix hj">“用户定义的类加载器”</strong>。</p><p id="5eb0" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">类加载器有3个子组件，分别称为<strong class="ix hj">加载、链接和初始化。</strong></p><h2 id="051a" class="ju jv hi bd jw jx jy jz ka kb kc kd ke jg kf kg kh jk ki kj kk jo kl km kn ko bi translated"><strong class="ak"> 1.1加载</strong></h2><p id="13d8" class="pw-post-body-paragraph iv iw hi ix b iy kp ja jb jc kq je jf jg kr ji jj jk ks jm jn jo kt jq jr js hb bi translated">这个加载阶段的主要职责是将编译好的类加载到内存区域。通常，加载过程从主类开始(带有Main方法的类)。在将每个类加载到内存区域之前，这个加载阶段将执行以下任务:</p><ul class=""><li id="ff74" class="mi mj hi ix b iy iz jc jd jg mk jk ml jo mm js mn mo mp mq bi translated">读取完全限定的类名</li><li id="450a" class="mi mj hi ix b iy mr jc ms jg mt jk mu jo mv js mn mo mp mq bi translated">读取直接父类信息</li><li id="9b2f" class="mi mj hi ix b iy mr jc ms jg mt jk mu jo mv js mn mo mp mq bi translated">读取可变信息</li><li id="c867" class="mi mj hi ix b iy mr jc ms jg mt jk mu jo mv js mn mo mp mq bi translated">检查它是否与类/接口/枚举相关</li></ul><p id="118e" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">每当一个类第一次加载时，JVM从一个类类型创建一个对象。这个类类型对象只为每个类创建1个，并将存储在堆区域中。</p><h2 id="83af" class="ju jv hi bd jw jx jy jz ka kb kc kd ke jg kf kg kh jk ki kj kk jo kl km kn ko bi translated"><strong class="ak"> 1.2链接</strong></h2><p id="62e2" class="pw-post-body-paragraph iv iw hi ix b iy kp ja jb jc kq je jf jg kr ji jj jk ks jm jn jo kt jq jr js hb bi translated">链接分为三个部分，即<strong class="ix hj">验证、准备和解决。</strong></p><p id="7a72" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">🔹<strong class="ix hj"> <em class="jt">验证</em> </strong></p><p id="f89a" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在这个验证阶段，它使用一个名为“<strong class="ix hj">字节码验证器</strong>的子程序来验证类，并确保它可以安全执行。因此，它验证类是否由有效的编译器编译，以及类文件是否根据正确的java结构/格式编写。</p><p id="160d" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如果在这个阶段验证失败，JVM抛出一个异常(java.lang.VerifyError)并终止java应用程序。</p><p id="5932" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">🔹<strong class="ix hj"> <em class="jt">准备</em> </strong></p><p id="371e" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在这个阶段，它为类文件中的所有变量分配默认值。每种数据类型都有特定的默认值。例如，对于布尔变量，它会将“false”指定为默认值，而“0”是整数变量的默认值。</p><p id="dcb5" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">🔹<strong class="ix hj">决议<em class="jt">决议</em>决议</strong></p><p id="9e6a" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">所以，在程序中，我们创建对象并频繁使用它们。创建对象时，我们用不同的名称定义它们。但是JVM不能理解这些特定于域的名称。所以，为了让机器理解它，JVM用它替换了一个符号引用/链接。</p><h2 id="64de" class="ju jv hi bd jw jx jy jz ka kb kc kd ke jg kf kg kh jk ki kj kk jo kl km kn ko bi translated">1.3初始化</h2><p id="c5fa" class="pw-post-body-paragraph iv iw hi ix b iy kp ja jb jc kq je jf jg kr ji jj jk ks jm jn jo kt jq jr js hb bi translated">初始化是类装入器的最后一个阶段，在这个阶段，它分配我们在java文件中定义的所有实数值。此外，如果类有任何静态块，将在初始化阶段执行。</p><h1 id="21e9" class="lh jv hi bd jw li md lk ka ll me ln ke lo mf lq kh lr mg lt kk lu mh lw kn lx bi translated">2.存储区(运行时数据区)</h1><p id="5bd7" class="pw-post-body-paragraph iv iw hi ix b iy kp ja jb jc kq je jf jg kr ji jj jk ks jm jn jo kt jq jr js hb bi translated">内存区有5个子区，分别命名为:<strong class="ix hj">方法区、堆区、栈、PC寄存器、</strong>和<strong class="ix hj">本机方法区</strong>。</p><p id="24f0" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">前两个区域<em class="jt">(方法区，堆区)</em>每个JVM只创建1个。这意味着它不关心你的程序是否有多个线程，那些线程必须在它们之间共享这两个线程。但是其他三个区域<em class="jt">(堆栈、PC寄存器、本地方法区域)</em>是为每个线程创建的。</p><p id="027b" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj"> <em class="jt"> 2.1)方法区</em> </strong> —方法区保存所有类级别的信息和数据，如变量信息，包括静态变量。</p><p id="ef6b" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj"> <em class="jt"> 2.2)堆区</em> </strong> —堆区保存所有对象及其信息。</p><p id="7493" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj"> <em class="jt"> 2.3)堆栈</em> </strong> —堆栈存储方法及其信息。如上所述，每个线程创建一个堆栈。如果一个线程有几个方法，那么在堆栈中为每个方法创建一个堆栈框架。</p><p id="21ad" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj"> <em class="jt"> 2.4) PC寄存器</em> </strong> —它保存关于非本机方法下一次执行的信息。如果下一次执行是关于本地方法的，那么PC寄存器会变得未定义。在本地方法执行之后，PC寄存器获取关于非本地方法下一次执行的信息。</p><p id="bd9c" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj"> <em class="jt"> 2.5)原生方法区</em> </strong> —如果你程序加载了一个原生方法，该原生方法的信息将被存储在这里。</p><blockquote class="ku kv kw"><p id="a23e" class="iv iw jt ix b iy iz ja jb jc jd je jf kx jh ji jj ky jl jm jn kz jp jq jr js hb bi translated">提示:java中的本地方法基本上就是方法，但是是用其他语言编写的，比如C和C++。</p></blockquote><h1 id="2050" class="lh jv hi bd jw li md lk ka ll me ln ke lo mf lq kh lr mg lt kk lu mh lw kn lx bi translated">3.执行引擎</h1><p id="8f67" class="pw-post-body-paragraph iv iw hi ix b iy kp ja jb jc kq je jf jg kr ji jj jk ks jm jn jo kt jq jr js hb bi translated">这是字节码实际执行的地方。执行引擎下有3个组件，解释器、JIT编译器和垃圾收集器。</p><p id="3164" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj"> <em class="jt"> 3.1)解释器</em> </strong></p><p id="269e" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">解释器将字节码解释(转换)成机器代码，并逐行执行。它可以快速解释字节代码行，但是如果有一个方法调用了多次，那么每个方法调用都需要一个新的解释。这使得执行速度慢了很多。</p><p id="740d" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj"> <em class="jt"> 3.2) JIT编译器</em> </strong></p><p id="3bd2" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">每当有一个方法被多次调用时，解释器就面临一个问题。这就是JIT编译器拯救世界的地方。JIT编译器所做的是，将整个字节码编译成机器码。那么这个机器码将直接用于那些“重复的方法调用”。通过这种方式，它比解释器快得多。</p><p id="be45" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj"> <em class="jt"> 3.3)垃圾收集器</em> </strong></p><p id="514a" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">垃圾收集器是一个总是在后台运行的恶魔线程。垃圾收集器的主要任务是检查堆区域中任何“未使用的对象”并销毁它们。因此，它通过销毁那些未使用/不可到达的对象来从堆区域释放内存。</p></div><div class="ab cl la lb gp lc" role="separator"><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf"/></div><div class="hb hc hd he hf"><h2 id="0259" class="ju jv hi bd jw jx jy jz ka kb kc kd ke jg kf kg kh jk ki kj kk jo kl km kn ko bi translated">参考</h2><p id="d7e9" class="pw-post-body-paragraph iv iw hi ix b iy kp ja jb jc kq je jf jg kr ji jj jk ks jm jn jo kt jq jr js hb bi translated"><em class="jt"> Java虚拟机</em>。2016.[视频]导演K. Dinesh。<a class="ae iu" href="https://www.youtube.com/playlist?list=PLD-mYtebG3X-rF1hU16AC3Rf9E-mAAkXJ:" rel="noopener ugc nofollow" target="_blank">https://www.youtube.com/playlist?list = PLD-myte BG 3 x-RF 1 Hu 16 AC 3 RF 9 e-maak XJ:</a>YouTube。</p><figure class="lz ma mb mc fd ij"><div class="bz dy l di"><div class="mw mx l"/></div></figure></div></div>    
</body>
</html>