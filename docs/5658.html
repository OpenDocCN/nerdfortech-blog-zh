<html>
<head>
<title>Leveraging Salesforce Using a Client Written In Angular</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用用Angular编写的客户端利用Salesforce</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/leveraging-salesforce-using-a-client-written-in-angular-36fe949ef69b?source=collection_archive---------4-----------------------#2021-10-28">https://medium.com/nerd-for-tech/leveraging-salesforce-using-a-client-written-in-angular-36fe949ef69b?source=collection_archive---------4-----------------------#2021-10-28</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/a7304ff3a2498b1bc42d3b32276a02e1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oXe2Si1qyz_BQjtDUQoQrQ.jpeg"/></div></div></figure><p id="1a20" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在<a class="ae jo" href="https://dzone.com/articles/leveraging-salesforce-without-using-salesforce" rel="noopener ugc nofollow" target="_blank">“使用Spring Boot利用sales force</a>”文章中，我介绍了引入Spring Boot服务的过程，该服务将利用成熟的Salesforce RESTful API。该服务的目标是充当中间件层；这样，未在Salesforce中编写的客户可以检索和更新存储在Salesforce中的联系人数据。该后端服务实现了自己的缓存层，以提供更快的响应时间，并减少了调用Salesforce的次数。</p><p id="27d7" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在“<a class="ae jo" href="https://dzone.com/articles/leveraging-salesforce-using-a-client-written-in-sv" rel="noopener ugc nofollow" target="_blank">使用用Svelte编写的客户端利用Salesforce</a>”中，我介绍了一个用Svelte编写的简单客户端，它使得使用内嵌编辑器更新Salesforce数据成为可能—同样，不需要实际使用sales force客户端。</p><p id="2ad2" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">“<a class="ae jo" href="https://dzone.com/articles/leveraging-salesforce-using-a-client-written-in-vu" rel="noopener ugc nofollow" target="_blank">使用Vue.js编写的客户端利用Salesforce】”文章介绍了一个使用Vue.js框架的客户端应用程序，以进一步与Spring Boot服务进行交互。使用Vue.js，最终的客户端不仅能够从Salesforce读取数据，还能够通过服务器发送的事件(SSE)实现处理和显示对Salesforce数据的更新。</a></p><p id="566f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">本系列的第四篇文章“<a class="ae jo" href="https://dzone.com/articles/leveraging-salesforce-using-mobile-applications-wr" rel="noopener ugc nofollow" target="_blank">利用使用React Native编写(一次)的移动应用程序的Salesforce】”介绍了利用React Native编写的单一源代码库的Android和iOS设备的原生移动应用程序。这种新的客户端产品允许高级管理人员监控Salesforce数据的进度。</a></p><p id="95e0" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在本文中，我们将使用Angular框架来完成一个新的特性请求。在本例中，来自Salesforce的相同联系人数据将在下拉列表中使用，以避免具有不同的联系人数据来源。</p><h1 id="8188" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">重温示例用例</h1><p id="7a36" class="pw-post-body-paragraph iq ir hi is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hb bi translated">让我们简要回顾一下我们的示例用例:业务呼叫中心即将发起一场大型营销活动。然而，他们最近发现，为联系人列表生成的标题大约90%都是不正确的。</p><p id="99e5" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">一个实习生团队一直在使用Svelte客户端更新联系人，管理团队一直在使用Vue.js客户端监控更新，包括服务器发送的显示为toast消息的事件。高管们一直在使用他们的Android和iOS设备从已经部署的本地客户端监控进度。</p><p id="4d41" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">负责新widget产品线的功能团队已经意识到他们也可以从存储在Salesforce中的联系信息中受益。小部件应用程序中添加了以下要求:</p><ol class=""><li id="7539" class="ks kt hi is b it iu ix iy jb ku jf kv jj kw jn kx ky kz la bi translated">新的小部件表单需要一个联系人字段。</li><li id="4e50" class="ks kt hi is b it lb ix lc jb ld jf le jj lf jn kx ky kz la bi translated">联系人字段的选择选项将是一个下拉列表。</li><li id="19f9" class="ks kt hi is b it lb ix lc jb ld jf le jj lf jn kx ky kz la bi translated">源数据将是来自Salesforce的联系人的动态列表。</li><li id="32cb" class="ks kt hi is b it lb ix lc jb ld jf le jj lf jn kx ky kz la bi translated">每个选项都将显示联系人的全名以及括号中的头衔(如果有的话)。</li><li id="d0ec" class="ks kt hi is b it lb ix lc jb ld jf le jj lf jn kx ky kz la bi translated">随着对Salesforce中的联系人进行更改，联系人选择选项列表应自动更新(包括职位值)。</li></ol><p id="347d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">小部件产品线的特性团队正计划马上开始这项工作，并且应该根据本系列之前完成的工作的结果准备好他们需要的一切。</p><p id="0dcc" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">作为参考，下面是整个系列中使用的Spring Boot服务的链接:</p><p id="b5cd" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><a class="ae jo" href="https://gitlab.com/johnjvester/salesforce-integration-service" rel="noopener ugc nofollow" target="_blank">https://git lab . com/johnj vester/sales force-integration-service</a></p><h1 id="5a19" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">为什么有棱角？</h1><p id="bb54" class="pw-post-body-paragraph iq ir hi is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hb bi translated"><a class="ae jo" href="https://angular.io/" rel="noopener ugc nofollow" target="_blank"> Angular </a>是一个基于类型脚本的web客户端框架，由<a class="ae jo" href="https://en.wikipedia.org/wiki/Google" rel="noopener ugc nofollow" target="_blank"> Google </a>领导，由一个非常大的开源社区提供支持。在我在本系列中使用的所有框架中，Angular无疑是最大的——几乎到了称它为平台可能更好的地步。</p><p id="4048" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">使用角度的一些好处如下:</p><ol class=""><li id="6853" class="ks kt hi is b it iu ix iy jb ku jf kv jj kw jn kx ky kz la bi translated">旨在处理企业web应用程序，适应下一代设计模式，包括<a class="ae jo" href="https://en.wikipedia.org/wiki/Progressive_web_application" rel="noopener ugc nofollow" target="_blank">渐进式web应用程序</a>。</li><li id="a338" class="ks kt hi is b it lb ix lc jb ld jf le jj lf jn kx ky kz la bi translated">继续与专门的开源社区一起发展。这导致了一个令人印象深刻的bug/解决时间框架和一个第三方解决方案或依赖项的大型库，可以添加到任何现代Angular项目中。</li><li id="d6c2" class="ks kt hi is b it lb ix lc jb ld jf le jj lf jn kx ky kz la bi translated">由谷歌支持，作为技术巨头的主要网络客户端框架，包括<a class="ae jo" href="https://en.wikipedia.org/wiki/Gmail" rel="noopener ugc nofollow" target="_blank"> Gmail </a>、<a class="ae jo" href="https://en.wikipedia.org/wiki/Microsoft_Office" rel="noopener ugc nofollow" target="_blank">微软Office </a>、<a class="ae jo" href="https://en.wikipedia.org/wiki/PayPal" rel="noopener ugc nofollow" target="_blank"> PayPal </a>、<a class="ae jo" href="https://en.wikipedia.org/wiki/Upwork" rel="noopener ugc nofollow" target="_blank"> Upwork </a>(自由职业程序)和<a class="ae jo" href="https://en.wikipedia.org/wiki/Samsung" rel="noopener ugc nofollow" target="_blank">三星</a>。</li></ol><p id="8c3b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">就我个人而言，从2014年初开始，我就参与了同时在AngularJS和Angular上运行的企业web应用程序。虽然Angular是为处理大规模应用程序而设计的，但我在使用相同的框架处理小而简单的应用程序方面也同样成功。</p><h1 id="0b04" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">Angular入门</h1><p id="dd4b" class="pw-post-body-paragraph iq ir hi is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hb bi translated">对于本文，我决定走出自己的舒适区，尝试Angular的第12版。(作为一个参考点，我最后一次使用版本9是去年在我的“<a class="ae jo" href="https://dzone.com/articles/using-heroku-to-quickly-build-a-multi-tenant-saas" rel="noopener ugc nofollow" target="_blank">使用Heroku快速构建多租户SaaS产品</a>系列”中为我嫂子编写的健身应用程序。)</p><p id="4377" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">因为我的Angular命令行界面(CLI)仍然是版本9，所以我需要使用以下命令来升级到版本12的Angular CLI:</p><p id="2e68" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><code class="du lg lh li lj b">npm install -g @angular/cli</code></p><p id="e060" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">第一次使用的用户也可以使用这个命令。</p><p id="3561" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">发出一个<code class="du lg lh li lj b">ng version</code>命令为我提供了以下结果:</p><pre class="lk ll lm ln fd lo lj lp lq aw lr bi"><span id="5efe" class="ls jq hi lj b fi lt lu l lv lw">_                      _                 ____ _     ___<br/>    / \   _ __   __ _ _   _| | __ _ _ __     / ___| |   |_ _|<br/>   / △ \ | '_ \ / _` | | | | |/ _` | '__|   | |   | |    | |<br/>  / ___ \| | | | (_| | |_| | | (_| | |      | |___| |___ | |<br/> /_/   \_\_| |_|\__, |\__,_|_|\__,_|_|       \____|_____|___|<br/>                |___/</span><span id="a958" class="ls jq hi lj b fi lx lu l lv lw">Angular CLI: 12.2.0<br/>Node: 14.15.5<br/>Package Manager: npm 6.14.11<br/>OS: darwin x64</span><span id="13d6" class="ls jq hi lj b fi lx lu l lv lw">Angular:<br/>...</span><span id="d1eb" class="ls jq hi lj b fi lx lu l lv lw">Package                      Version<br/>------------------------------------------------------<br/><a class="ae jo" href="http://twitter.com/angular" rel="noopener ugc nofollow" target="_blank">@angular</a>-devkit/architect    0.1202.0 (cli-only)<br/><a class="ae jo" href="http://twitter.com/angular" rel="noopener ugc nofollow" target="_blank">@angular</a>-devkit/core         12.2.0 (cli-only)<br/><a class="ae jo" href="http://twitter.com/angular" rel="noopener ugc nofollow" target="_blank">@angular</a>-devkit/schematics   12.2.0 (cli-only)<br/><a class="ae jo" href="http://twitter.com/schematics/angular" rel="noopener ugc nofollow" target="_blank">@schematics/angular</a>          12.2.0 (cli-only)</span></pre><p id="8712" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">为了创建新的Angular 12应用程序，我发出了以下Angular CLI命令:</p><p id="4edb" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><code class="du lg lh li lj b">ng new salesforce-integration-angular</code></p><p id="c607" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">Angular CLI在名为salesforce-integration-angular的新文件夹中创建了该应用程序。下面是该命令的一些输出的摘要:</p><pre class="lk ll lm ln fd lo lj lp lq aw lr bi"><span id="70bd" class="ls jq hi lj b fi lt lu l lv lw">? Would you like to add Angular routing? No<br/>? Which stylesheet format would you like to use? CSS<br/>...<br/>✔ Packages installed successfully.</span></pre><p id="00e2" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">此时，我使用ng serve命令来显示新创建的Angular应用程序:</p><figure class="lk ll lm ln fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ly"><img src="../Images/32b9bce78d53d3494152ef73b525650b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*S1SLQ1S4AdqQ8r7mmRIedg.png"/></div></div></figure><p id="31c7" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">当然，这并不多，但至少Angular应用程序在几秒钟内就开始了。</p><h1 id="e0da" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">添加一些依赖项</h1><p id="0ee3" class="pw-post-body-paragraph iq ir hi is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hb bi translated">小部件应用程序的需求包含一个有趣的业务规则。为了避免不得不滚回页面顶部，我捕获了以下信息:</p><blockquote class="lz ma mb"><p id="bfa5" class="iq ir mc is b it iu iv iw ix iy iz ja md jc jd je me jg jh ji mf jk jl jm jn hb bi translated"><em class="hi">随着Salesforce中联系人的更改，联系人选择选项列表应自动更新(包括职位值)</em></p></blockquote><p id="fae6" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这一要求转化为窗口小部件应用程序必须维护联系人对象的当前状态。也就是说，联系人列表信息总是需要是最新的。</p><p id="0b4a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在“利用使用Vue.js编写的客户端的Salesforce”文章中，当存储在Salesforce中的联系人的状态发生变化时，Spring Boot服务被更新为广播SSE。角度应用程序也需要监听这些相同的SSE。</p><p id="15a3" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">然而，对于Angular应用程序，我决定使用<a class="ae jo" href="https://ngrx.io/guide/store" rel="noopener ugc nofollow" target="_blank"> @ngrx/store </a>，这是一个受Redux启发的用于Angular应用程序的全局状态管理——由<a class="ae jo" href="https://rxjs.dev/" rel="noopener ugc nofollow" target="_blank"> RxJS </a>提供支持。这意味着我将从Spring Boot连接SSEs来维护浏览器中Salesforce联系人的状态。然后，小部件组件可以采用一种反应式设计，以总是获得最新的更改——而不必再次调用Spring Boot服务。</p><p id="b867" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">将ngrx/store依赖项添加到Angular 12应用程序需要一个简单的命令:</p><p id="38a3" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><code class="du lg lh li lj b">npm install @ngrx/store --save</code></p><p id="d9e8" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">将这个依赖项添加到项目中后，我就可以专注于在Angular中创建小部件组件了。</p><h1 id="042b" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">创建小部件组件</h1><p id="1b19" class="pw-post-body-paragraph iq ir hi is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hb bi translated">对于这个简单的例子，启动Angular 12应用程序将呈现一个新的小部件表单。因为我们保持事情简单，所以表单看起来像这样:</p><figure class="lk ll lm ln fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mg"><img src="../Images/95696c861b955c73ac79dad8d4552d6e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Pr4oUqahqWMvtbWheHEtdw.png"/></div></div></figure><p id="8a69" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">模型字段将是自由格式的文本字段，联系人字段将包含Salesforce联系人的动态列表，通过与NgRx通信的SSE监听器保持最新。</p><p id="86bf" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">使用Angular CLI创建新组件需要以下命令:</p><p id="fc1d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><code class="du lg lh li lj b">ng generate component widget</code></p><p id="c94f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">Angular CLI响应以下状态更新:</p><pre class="lk ll lm ln fd lo lj lp lq aw lr bi"><span id="9302" class="ls jq hi lj b fi lt lu l lv lw">CREATE src/app/widget/widget.component.css (0 bytes)<br/>CREATE src/app/widget/widget.component.html (21 bytes)<br/>CREATE src/app/widget/widget.component.spec.ts (626 bytes)<br/>CREATE src/app/widget/widget.component.ts (275 bytes)<br/>UPDATE src/app/app.module.ts (727 bytes)</span></pre><p id="54ee" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">因此，已经创建了一个小部件组件，并可以在Angular 12应用程序的/src/app/widget文件夹中使用。</p><h1 id="a4bf" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">配置NgRx</h1><p id="4677" class="pw-post-body-paragraph iq ir hi is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hb bi translated">这里没有包括所有关于配置NgRx的必要信息，下面的NgRx网站链接提供了大量的细节:</p><p id="6902" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><a class="ae jo" href="https://ngrx.io/guide/store#ngrxstore" rel="noopener ugc nofollow" target="_blank">https://ngrx.io/guide/store#ngrxstore</a></p><p id="4c7e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">本文档的一部分包括下图:</p><figure class="lk ll lm ln fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/8d140abd2ef1203a7024a8de42183a88.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iOC2HaKvG4mb7LwbdxvrFg.png"/></div></div></figure><p id="7776" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">概括地说，我们将向Angular 12应用程序添加以下元素:</p><ol class=""><li id="979e" class="ks kt hi is b it iu ix iy jb ku jf kv jj kw jn kx ky kz la bi translated">ContactService:对Spring Boot进行API调用，允许我们接收联系人。</li><li id="c664" class="ks kt hi is b it lb ix lc jb ld jf le jj lf jn kx ky kz la bi translated">EventService:连接到在Spring Boot服务中运行的SSE URI。</li><li id="3bd5" class="ks kt hi is b it lb ix lc jb ld jf le jj lf jn kx ky kz la bi translated">ContactEffect:注册事件侦听器并从Spring Boot服务加载原始联系人。</li><li id="aa4b" class="ks kt hi is b it lb ix lc jb ld jf le jj lf jn kx ky kz la bi translated">ContactAction:描述从ContactService调度的事件。</li><li id="9ac2" class="ks kt hi is b it lb ix lc jb ld jf le jj lf jn kx ky kz la bi translated">ContactReducer:确保正在处理状态更改。</li><li id="40b5" class="ks kt hi is b it lb ix lc jb ld jf le jj lf jn kx ky kz la bi translated">ContactSelector:从商店中选择并获取联系信息。</li><li id="3288" class="ks kt hi is b it lb ix lc jb ld jf le jj lf jn kx ky kz la bi translated">WidgetComponent:侦听ContactAction并从ContactSelector接收数据。</li></ol><p id="fa33" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">让我们深入代码，看看这在TypeScript中是什么样子。</p><h1 id="96bb" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">联系服务</h1><p id="fa5c" class="pw-post-body-paragraph iq ir hi is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hb bi translated">ContactService处理对本系列中一直使用的Spring Boot服务的基本API调用。Angular 12客户端将简单地调用<code class="du lg lh li lj b"> /contacts</code> URI，并返回一个包含联系对象列表的“observable ”:</p><pre class="lk ll lm ln fd lo lj lp lq aw lr bi"><span id="a9cc" class="ls jq hi lj b fi lt lu l lv lw">export class ContactService {<br/>  constructor(private http: HttpClient) { }</span><span id="1733" class="ls jq hi lj b fi lx lu l lv lw">getContacts(): Observable&lt;Contact[]&gt; {<br/>    return this.http.get&lt;Contact[]&gt;( environment.api + '/contacts')<br/>      .pipe(<br/>        retry(1),<br/>        catchError(this.handleError)<br/>      )<br/>  }<br/>}</span></pre><h1 id="b0c3" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">事件服务</h1><p id="1d8c" class="pw-post-body-paragraph iq ir hi is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hb bi translated">EventService建立了与Spring Boot URI的连接，后者正在广播SSE更新。我添加了<code class="du lg lh li lj b">getServerSentEvent() </code>方法来建立连接:</p><pre class="lk ll lm ln fd lo lj lp lq aw lr bi"><span id="a89b" class="ls jq hi lj b fi lt lu l lv lw">getServerSentEvent(): Observable&lt;any&gt; {<br/>    return Observable.create((observer: { next: (arg0: any) =&gt; void; error: (arg0: any) =&gt; void; }) =&gt; {<br/>      const eventSource = this.setSource();<br/>      eventSource.onmessage = event =&gt; {<br/>        this.zone.run(() =&gt; {<br/>          observer.next(event);<br/>        });<br/>      };<br/>      eventSource.onerror = error =&gt; {<br/>        this.zone.run(() =&gt; {<br/>          observer.error(error);<br/>        });<br/>      };<br/>    });<br/>  }</span></pre><p id="ef30" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">当一个SSE到达时，调用<code class="du lg lh li lj b">_onMessage()</code>方法:</p><pre class="lk ll lm ln fd lo lj lp lq aw lr bi"><span id="4afa" class="ls jq hi lj b fi lt lu l lv lw">private _onMessage(e: MessageEvent): void {<br/>    const message = JSON.parse(e.data);<br/>    if (message) {<br/>      this.dispatchActionInNgZone(processSseUpdate(message));<br/>    }<br/>  }</span></pre><p id="ac85" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这又会将操作分派到NgZone中:</p><pre class="lk ll lm ln fd lo lj lp lq aw lr bi"><span id="5968" class="ls jq hi lj b fi lt lu l lv lw">private dispatchActionInNgZone(action: Action): void {<br/>    this.zone.run(() =&gt; this.store.dispatch(action));<br/>  }</span></pre><h1 id="1eab" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">接触效应</h1><p id="7b91" class="pw-post-body-paragraph iq ir hi is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hb bi translated">ContactEffect向EventService注册一个事件侦听器，根据收到的SSE消息更新联系人，并从Spring Boot服务加载原始联系人。</p><pre class="lk ll lm ln fd lo lj lp lq aw lr bi"><span id="5d4c" class="ls jq hi lj b fi lt lu l lv lw">registerEventListener$ = createEffect(<br/>    () =&gt;<br/>      this.actions$.pipe(<br/>        ofType(ContactActionTypes.AllContactsLoaded),<br/>        tap(action =&gt; {<br/>          this.eventListenerService.register();<br/>        }),<br/>        repeat()<br/>      ),<br/>    { dispatch: false }<br/>  );</span><span id="5d80" class="ls jq hi lj b fi lx lu l lv lw">updateContactFromSSE$ = createEffect(() =&gt;<br/>    this.actions$.pipe(<br/>      ofType(processSseUpdate),<br/>      map( payload =&gt; {<br/>        const anyContact:any = (payload as any);<br/>        const contact = (anyContact as Contact);<br/>        const updatedAction:Update&lt;Contact&gt; = {<br/>          id: contact.id,<br/>          changes: { ...contact }<br/>        };<br/>        return new ContactUpdated({contact: updatedAction});<br/>      })<br/>    )<br/>  );</span><span id="0888" class="ls jq hi lj b fi lx lu l lv lw">loadAllContacts$ = this.actions$.pipe(<br/>      ofType&lt;AllContactsRequested&gt;(ContactActionTypes.AllContactsRequested),<br/>      mergeMap(() =&gt; this.contactService.getContacts()),<br/>      map(contacts =&gt; { new AllContactsLoaded({ contacts })} )<br/>    );</span></pre><h1 id="a74a" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">接触动作</h1><p id="a47f" class="pw-post-body-paragraph iq ir hi is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hb bi translated">ContactAction描述从ContactService调度的事件。</p><pre class="lk ll lm ln fd lo lj lp lq aw lr bi"><span id="4baf" class="ls jq hi lj b fi lt lu l lv lw">export enum ContactActionTypes {<br/>  AllContactsRequested = '[Contact API] All Contacts Requested',<br/>  AllContactsLoaded = '[Contact API] All Contacts Loaded',<br/>  ContactUpdated = '[Contact API] Contact Updated'<br/>}</span><span id="b396" class="ls jq hi lj b fi lx lu l lv lw">export class AllContactsRequested implements Action {<br/>  readonly type = ContactActionTypes.AllContactsRequested;<br/>}</span><span id="f7ee" class="ls jq hi lj b fi lx lu l lv lw">export class AllContactsLoaded implements Action {<br/>  readonly type = ContactActionTypes.AllContactsLoaded;<br/>  constructor(public payload: { contacts: Contact[] }) { }<br/>}</span><span id="ba47" class="ls jq hi lj b fi lx lu l lv lw">export class ContactUpdated implements Action {<br/>  readonly type = ContactActionTypes.ContactUpdated;<br/>  constructor(public payload: { contact: Update&lt;Contact&gt; }) { }<br/>}</span><span id="fb11" class="ls jq hi lj b fi lx lu l lv lw">export type ContactActions = AllContactsRequested |  AllContactsLoaded | ContactUpdated;</span></pre><h1 id="8763" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">接触还原剂</h1><p id="5db5" class="pw-post-body-paragraph iq ir hi is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hb bi translated">ContactReducer确保状态更改得到处理。</p><pre class="lk ll lm ln fd lo lj lp lq aw lr bi"><span id="bdad" class="ls jq hi lj b fi lt lu l lv lw">export function contactReducer(state = initialContactsState, action: ContactActions): ContactsState {<br/>  switch(action.type) {<br/>    case ContactActionTypes.AllContactsLoaded:<br/>      return adapter.setAll(action.payload.contacts, {...state, allContactsLoaded: true });<br/>    case ContactActionTypes.ContactUpdated:<br/>      return adapter.updateOne(action.payload.contact, state);<br/>    default: {<br/>      return state;<br/>    }<br/>  }<br/>}</span></pre><h1 id="10e4" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">WidgetComponent</h1><p id="6056" class="pw-post-body-paragraph iq ir hi is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hb bi translated">最后，WidgetComponent利用所有NgRx状态管理元素，通过Spring Boot服务和SSE URI提供来自Salesforce的动态和自我更新的联系信息列表。</p><p id="93be" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><code class="du lg lh li lj b">ngOnInit()</code>方法连接到NgRx存储，然后接收联系人的原始列表:</p><pre class="lk ll lm ln fd lo lj lp lq aw lr bi"><span id="8424" class="ls jq hi lj b fi lt lu l lv lw">ngOnInit(): void {<br/>    this.widget.model = "Some Model Description Goes Here";</span><span id="fbfa" class="ls jq hi lj b fi lx lu l lv lw">this.contactService.getContacts().subscribe((data) =&gt; {<br/>      this.store.dispatch(new AllContactsLoaded({ contacts: data }));<br/>      this.loading = false;<br/>    });<br/>  }</span></pre><p id="bb73" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">NgRx实施就绪后，更新将在通过SSE URI从Spring Boot服务收到时进行处理。</p><p id="acb5" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">为了确保小部件组件在Angular启动时显示，我将app.component.html文件缩减为一行:</p><p id="fc0c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><code class="du lg lh li lj b">&lt;widget&gt;&lt;/widget&gt;</code></p><h1 id="09c6" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">使用角度应用程序</h1><p id="d989" class="pw-post-body-paragraph iq ir hi is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hb bi translated">使用Angular CLI中的<code class="du lg lh li lj b">ng serve</code>,我们启动Angular 12应用程序，上面的所有更改都已就绪。</p><p id="de87" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这将显示小组件表单，在下拉列表中显示来自Salesforce的联系人数据:</p><figure class="lk ll lm ln fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mh"><img src="../Images/b4e67b91a12bb82688de3e27b6a93f1c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qD7lJ5JpBO70GNDI2BGF4w.png"/></div></div></figure><p id="1a87" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">使用下面的cURL命令，我将Rose Gonzales的标题从“SVP，采购”更新为“SVP，信息技术”</p><pre class="lk ll lm ln fd lo lj lp lq aw lr bi"><span id="f84c" class="ls jq hi lj b fi lt lu l lv lw">curl --location --request PATCH '<a class="ae jo" href="http://localhost:9999/contacts/0035e000008eXq0AAE'" rel="noopener ugc nofollow" target="_blank">http://localhost:9999/contacts/0035e000008eXq0AAE'</a> \<br/>--header 'Content-Type: application/json' \<br/>--data-raw '{<br/>    "Title": "SVP, Information Technology"<br/>}'</span></pre><p id="539b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">PATCH命令产生了HTTP状态代码202(已接受),并返回了以下有效负载:</p><pre class="lk ll lm ln fd lo lj lp lq aw lr bi"><span id="001b" class="ls jq hi lj b fi lt lu l lv lw">{<br/>    "attributes": {<br/>        "type": "Contact",<br/>        "url": "/services/data/v52.0/sobjects/Contact/0035e000008eXq0AAE"<br/>    },<br/>    "id": "0035e000008eXq0AAE",<br/>    "Name": "Rose Gonzalez",<br/>    "Title": "SVP, Information Technology",<br/>    "Department": "Procurement"<br/>}</span></pre><p id="b146" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">无需对小部件表单进行任何更改，下拉列表选项现在如下所示:</p><figure class="lk ll lm ln fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mi"><img src="../Images/0eda80dcb53c775493a1786b492f8e57.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-IR1cox3eUICc8xWphauJA.png"/></div></div></figure><p id="5944" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">请注意Rose Gonzalez的联系人头衔是如何自动更改的。</p><h1 id="5055" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">结论</h1><p id="b746" class="pw-post-body-paragraph iq ir hi is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hb bi translated">从2021年开始，我一直努力按照以下使命宣言生活，我觉得这可以适用于任何IT专业人士:</p><blockquote class="lz ma mb"><p id="2dc4" class="iq ir mc is b it iu iv iw ix iy iz ja md jc jd je me jg jh ji mf jk jl jm jn hb bi translated"><em class="hi">“将您的时间集中在提供扩展您知识产权价值的特性/功能上。将框架、产品和服务用于其他一切。”</em></p><p id="61d6" class="iq ir mc is b it iu iv iw ix iy iz ja md jc jd je me jg jh ji mf jk jl jm jn hb bi translated"><em class="hi">-j·维斯特</em></p></blockquote><p id="e9dd" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在本文中，我使用Angular 12创建了一个widgets组件，其中包括一个联系人下拉列表，该列表中填充了来自Salesforce实现的数据。我添加了NgRx状态管理功能来监听来自Spring Boot的SSE消息，以便保持联系人列表是最新的。在这种情况下，我利用了强大的NgRx状态管理框架来完成这项工作——只需要对小部件组件做很少的修改。</p><p id="8ccf" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">与我使用Svelte、Vue.js和React Native的经历类似，创建一个随时可以部署的组件的时间非常快，以分钟而不是小时来衡量。就像在本系列的所有文章中一样，我们已经能够使用Salesforce而不实际使用Salesforce客户端。</p><p id="b852" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">当然，生产就绪的场景需要做一些额外的工作来准备这个应用程序供“黄金时间”使用。</p><p id="747a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如果您对用于Angular客户端的源代码感兴趣，只需导航到GitLab上的以下存储库:</p><p id="2061" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><a class="ae jo" href="https://gitlab.com/johnjvester/salesforce-integration-angular" rel="noopener ugc nofollow" target="_blank">https://git lab . com/johnj vester/sales force-integration-angular</a></p><p id="4a42" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在本系列的下一篇文章中，我计划将事情转变180度，在Salesforce生态系统之外使用Lightning Web Components (LWC)。</p><p id="971c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">祝你今天过得愉快！</p></div></div>    
</body>
</html>