<html>
<head>
<title>Building Unit Of Work Support for JDBI in Dropwizard Part — II</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在 Dropwizard 中为 JDBI 构建工作单元支持—第二部分</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/building-unit-of-work-support-for-jdbi-in-dropwizard-part-ii-4857ca6c48cf?source=collection_archive---------0-----------------------#2020-05-10">https://medium.com/nerd-for-tech/building-unit-of-work-support-for-jdbi-in-dropwizard-part-ii-4857ca6c48cf?source=collection_archive---------0-----------------------#2020-05-10</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/4c590da840d28f961366bb91c673514c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dYt8c3eSiryJyGQ2es6nwA.png"/></div></div></figure><p id="6de9" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在本文中，我们继续我们的<a class="ae jo" rel="noopener" href="/@aman_garg/building-unit-of-work-support-for-jdbi-in-dropwizard-1e6fafbf46d6">旅程</a>在 Dropwizard 中构建对 JDBI 工作单元的支持。</p><p id="7476" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">回想一下我们应该遵循的计划:</p><figure class="jq jr js jt fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es jp"><img src="../Images/0b68fd75534bf06279741493c15ad0c8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*t7tur2dzauh23i1nzx61iQ.png"/></div></div><figcaption class="ju jv et er es jw jx bd b be z dx translated">第一部分是关于代码与“混乱”处理逻辑的清晰分离</figcaption></figure><p id="0aa1" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们必须确保每个<code class="du jy jz ka kb b">Dao</code>方法都被调用，当且仅当它被附加到一个托管的<code class="du jy jz ka kb b">handle</code>时。我们可以通过创建一个 Dao 的<code class="du jy jz ka kb b">proxy</code>来做到这一点，它在执行任何方法之前将自己附加到一个<code class="du jy jz ka kb b">handle</code>上。<code class="du jy jz ka kb b">proxy</code>扮演着两个重要的角色。</p><ul class=""><li id="b606" class="kc kd hi is b it iu ix iy jb ke jf kf jj kg jn kh ki kj kk bi translated"><code class="du jy jz ka kb b"><strong class="is hj">Intercept</strong></code>所有方法调用，即成为代理处理程序。</li><li id="4ba3" class="kc kd hi is b it kl ix km jb kn jf ko jj kp jn kh ki kj kk bi translated">将底层对象(真实对象)附加到一个<code class="du jy jz ka kb b">handle</code></li></ul><p id="a4e7" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在，<code class="du jy jz ka kb b"><strong class="is hj">java.lang.reflect</strong></code>为我们提供了一种为接口列表生成代理的方法。我们需要做的就是实现<code class="du jy jz ka kb b"><strong class="is hj">InvocationHandler</strong></code>并提供如何<em class="kq">拦截</em>调用并好好利用它的实现。</p><blockquote class="kr ks kt"><p id="6fff" class="iq ir kq is b it iu iv iw ix iy iz ja ku jc jd je kv jg jh ji kw jk jl jm jn hb bi translated">注意，只能通过<code class="du jy jz ka kb b"><strong class="is hj">InvocationHandler</strong></code>为一系列接口创建代理，而不能为抽象类或具体类创建代理。因为我们的<code class="du jy jz ka kb b">Dao</code>是一个<code class="du jy jz ka kb b">SqlObject</code>，它只不过是一个接口，所以我们准备好了。对于前者，有<code class="du jy jz ka kb b"><a class="ae jo" href="https://github.com/cglib/cglib" rel="noopener ugc nofollow" target="_blank"><strong class="is hj">CGLib</strong></a></code>这样的库存在。事实上，这就是<a class="ae jo" href="https://site.mockito.org/" rel="noopener ugc nofollow" target="_blank"> Mockito </a>生成代理的方式。</p></blockquote><p id="962c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">然而，对于我们必须将<code class="du jy jz ka kb b">underlying object </code>连接到手柄的部分，我们首先需要有<code class="du jy jz ka kb b">handle</code>本身。出现了几个问题</p><ul class=""><li id="f0f1" class="kc kd hi is b it iu ix iy jb ke jf kf jj kg jn kh ki kj kk bi translated">我们如何得到<code class="du jy jz ka kb b">handle</code>？它是全局作用域、请求作用域还是非作用域？</li><li id="a806" class="kc kd hi is b it kl ix km jb kn jf ko jj kp jn kh ki kj kk bi translated">谁来清除<code class="du jy jz ka kb b">handle</code>？它将如何初始化？</li></ul><p id="cbce" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这些都是有效的问题。这绝对不应该是一个<code class="du jy jz ka kb b">proxy</code>的责任。我们的代理应该简单地依赖于提供这种功能的<code class="du jy jz ka kb b">abstraction</code>。这种<code class="du jy jz ka kb b">abstraction</code>的实现可以很容易地交换或修改，而不会影响核心代理。</p><figure class="jq jr js jt fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es kx"><img src="../Images/6f1f86322145bd9b5ff270e489f0ab6a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FJ534jkY__HM-niYm6rV6A.png"/></div></div><figcaption class="ju jv et er es jw jx bd b be z dx translated">我们的代理蓝图</figcaption></figure><p id="6a17" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">简单来说，这就是我们的<code class="du jy jz ka kb b">proxy handler</code>的样子。我们只是<code class="du jy jz ka kb b">override</code>的<code class="du jy jz ka kb b">invoke()</code>也就是<code class="du jy jz ka kb b">InvocationHandler</code>所指定的契约。这里很少有值得一提的事情:</p><ul class=""><li id="525a" class="kc kd hi is b it iu ix iy jb ke jf kf jj kg jn kh ki kj kk bi translated"><code class="du jy jz ka kb b"><strong class="is hj">JdbiHandleManager</strong></code>是我们为解决<code class="du jy jz ka kb b">handle</code>的责任问题而创建的抽象。现在我们的<code class="du jy jz ka kb b">Proxy</code>仅仅依赖于由<code class="du jy jz ka kb b">AllArgs</code>构造器传递的抽象。对<code class="du jy jz ka kb b">handleManager.get()</code>的调用给了我们句柄。我们将在后面看到如何实现这样一个<code class="du jy jz ka kb b"> Handle Manager</code></li><li id="aa66" class="kc kd hi is b it kl ix km jb kn jf ko jj kp jn kh ki kj kk bi translated"><code class="du jy jz ka kb b"><strong class="is hj">Class&lt;T&gt; underlying</strong></code>保存将为其创建代理的<code class="du jy jz ka kb b">Dao</code>的类或类型。</li><li id="6cf0" class="kc kd hi is b it kl ix km jb kn jf ko jj kp jn kh ki kj kk bi translated">真正的方法仍然要在为底层类创建的对象上执行。然而，这一次，由于调用了<code class="du jy jz ka kb b"><strong class="is hj">handle.attach(underlying)</strong></code>，它将被附加到手柄上</li><li id="a9ca" class="kc kd hi is b it kl ix km jb kn jf ko jj kp jn kh ki kj kk bi translated">敏锐的读者可能会看到，每次调用<code class="du jy jz ka kb b">Dao</code>方法都会执行这个方法。但是我们已经覆盖了我们自己，因为<code class="du jy jz ka kb b">handles</code>一旦附着到<code class="du jy jz ka kb b"><strong class="is hj">SQLObject</strong></code>就是幂等的。</li><li id="35af" class="kc kd hi is b it kl ix km jb kn jf ko jj kp jn kh ki kj kk bi translated">只要<code class="du jy jz ka kb b">handle</code>有效(不是<code class="du jy jz ka kb b">closed</code>，多次调用这个方法没有任何意义。如果我们没有这个保证，我们将不得不保留第一个<code class="du jy jz ka kb b">invocation</code>的跟踪/计数器，并且只在第一次调用 attach。</li></ul><figure class="jq jr js jt fd ij"><div class="bz dy l di"><div class="ky kz l"/></div></figure><p id="3750" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如您所见，代理现在给了我们一种方法，以声明的方式将对象附加到一个公共句柄。如果我们没有这样做，我们将不得不用<code class="du jy jz ka kb b">handle.attach(dao)</code>调用来丢弃我们的应用程序代码库</p><p id="fa2c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在我们的代理处理程序已经创建好了。让我们演示一下如何创建实际的<code class="du jy jz ka kb b"><strong class="is hj">proxies</strong></code>。</p><blockquote class="kr ks kt"><p id="3170" class="iq ir kq is b it iu iv iw ix iy iz ja ku jc jd je kv jg jh ji kw jk jl jm jn hb bi translated">而不是像下面这样创建我们的刀</p></blockquote><pre class="jq jr js jt fd la kb lb lc aw ld bi"><span id="35a9" class="le lf hi kb b fi lg lh l li lj">Dao dao = <strong class="kb hj">handle</strong>.attach(Dao.class)</span></pre><blockquote class="kr ks kt"><p id="c8c2" class="iq ir kq is b it iu iv iw ix iy iz ja ku jc jd je kv jg jh ji kw jk jl jm jn hb bi translated">我们以这种方式创造它们</p></blockquote><pre class="jq jr js jt fd la kb lb lc aw ld bi"><span id="310a" class="le lf hi kb b fi lg lh l li lj">Dao dao = (Dao) <strong class="kb hj">Reflection.newProxy</strong>(Dao.class, new ManagedHandleInvocationHandler&lt;&gt;(handleManager, Dao.class));</span></pre><p id="40a4" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">虽然这一开始看起来很复杂，但是只需要在一个地方完成，在那里你初始化你的依赖项，比如在一个<code class="du jy jz ka kb b">Guice Module</code>中</p><figure class="jq jr js jt fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lk"><img src="../Images/7c1e659e9e99d5a304f496fc810e77c7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nlkFm_rT2PvCWxJ_3broxg.png"/></div></div><figcaption class="ju jv et er es jw jx bd b be z dx translated">代理对 Dao 的调用，并为每个调用注入一个句柄</figcaption></figure><p id="04af" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">有了这个设计，你可能想看看它在现实中是如何实现的。另外,<code class="du jy jz ka kb b"><strong class="is hj">handle manager</strong></code>只是一个简单的接口。</p><figure class="jq jr js jt fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ll"><img src="../Images/032087b45b26c3659ac09353e205665c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_EAolPDcpJmX9Dayh8SuTA.png"/></div></div><figcaption class="ju jv et er es jw jx bd b be z dx translated">还有更多方法，但与本讨论无关</figcaption></figure><h1 id="118d" class="lm lf hi bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">第二部分</h1><figure class="jq jr js jt fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mj"><img src="../Images/aa13865a2bcdd8ae37aaa42f304d5dcf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KSO-uwZYogYMxDyFuEz6Mw.png"/></div></div><figcaption class="ju jv et er es jw jx bd b be z dx translated">第二部分是关于赋予手柄生命。</figcaption></figure><p id="2bfd" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">为了只见树木不见森林，让我们重新确立我们希望实现的目标。</p><ul class=""><li id="da2b" class="kc kd hi is b it iu ix iy jb ke jf kf jj kg jn kh ki kj kk bi translated">一个<code class="du jy jz ka kb b">request</code>被接收并且将由一个<code class="du jy jz ka kb b">Dropwizard thread</code>服务。</li><li id="6d64" class="kc kd hi is b it kl ix km jb kn jf ko jj kp jn kh ki kj kk bi translated">作为读操作的一部分，一个<code class="du jy jz ka kb b">GET</code>T5 可以与多个<code class="du jy jz ka kb b">Dao</code>对话。通常<code class="du jy jz ka kb b">GET’s</code>执行只读操作。</li><li id="eab9" class="kc kd hi is b it kl ix km jb kn jf ko jj kp jn kh ki kj kk bi translated">一个<code class="du jy jz ka kb b">POST</code> <code class="du jy jz ka kb b">request</code>可能与多个<code class="du jy jz ka kb b">Dao</code>方法对话，即多个<code class="du jy jz ka kb b">SQL objects</code>方法，并且希望将它们作为一个公共事务的一部分来执行。</li><li id="c6ef" class="kc kd hi is b it kl ix km jb kn jf ko jj kp jn kh ki kj kk bi translated">可能有<code class="du jy jz ka kb b">POST</code> <code class="du jy jz ka kb b">request</code>不需要事务开销。</li><li id="9945" class="kc kd hi is b it kl ix km jb kn jf ko jj kp jn kh ki kj kk bi translated">请求可以服务于静态资产/回退，而无需与<code class="du jy jz ka kb b">database</code>或<code class="du jy jz ka kb b">Dao</code>对话</li></ul><p id="0a08" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">有了这个，我们就知道我们的系统会有什么样的表现了。</p><ul class=""><li id="0f6a" class="kc kd hi is b it iu ix iy jb ke jf kf jj kg jn kh ki kj kk bi translated"><code class="du jy jz ka kb b"><strong class="is hj">Initialise</strong></code>每个需要对话的请求的句柄<code class="du jy jz ka kb b">Dao</code></li><li id="0c17" class="kc kd hi is b it kl ix km jb kn jf ko jj kp jn kh ki kj kk bi translated">可选地，<code class="du jy jz ka kb b"><strong class="is hj">begin</strong></code>一个事务，如果一个请求是<code class="du jy jz ka kb b">POST</code>并且想要一个事务，还记得我们的中心块<code class="du jy jz ka kb b"><strong class="is hj">@JdbiUnitOfWork</strong></code>注释吗？理想情况下，只有用这个注释的方法才应该在事务上下文中执行。</li><li id="64e3" class="kc kd hi is b it kl ix km jb kn jf ko jj kp jn kh ki kj kk bi translated"><code class="du jy jz ka kb b"><strong class="is hj">Rollback</strong></code>执行过程中出现异常时的事务。</li><li id="4a49" class="kc kd hi is b it kl ix km jb kn jf ko jj kp jn kh ki kj kk bi translated">总是<code class="du jy jz ka kb b"><strong class="is hj">commit</strong></code>请求执行成功时的事务。</li><li id="f9a0" class="kc kd hi is b it kl ix km jb kn jf ko jj kp jn kh ki kj kk bi translated">每个请求的句柄</li></ul><p id="b347" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我在<strong class="is hj">中用粗体</strong>标出了关键功能。我们已经看到 a <code class="du jy jz ka kb b">Jdbi Handle</code>为我们提供了这样的操作。</p><figure class="jq jr js jt fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mk"><img src="../Images/497912c09329b155cd5bd5f4b795618d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jXsvLvrR22M4QrvWTEsRWw.png"/></div></div><figcaption class="ju jv et er es jw jx bd b be z dx translated">核心句柄 API</figcaption></figure><p id="344d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这给了我们一个线索，这些只有句柄的函数可以被<code class="du jy jz ka kb b">delegated</code>指定给特定的<code class="du jy jz ka kb b">aspect</code>或<code class="du jy jz ka kb b">special wrapper class</code>。我们稍后将回到这一点。</p><p id="d03c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">剩下要解决的唯一问题是干净地实现上面的逻辑，以便它是可维护的。理论上，我们可以做到以下几点:</p><figure class="jq jr js jt fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ml"><img src="../Images/f7a321d6b09fcb3a2e8e7acc9cb593d3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_F8w4p7_EN5MVUF-f8aoLg.png"/></div></div><figcaption class="ju jv et er es jw jx bd b be z dx translated">手动摆弄把手</figcaption></figure><p id="d5e3" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这有以下<em class="kq">缺点</em>:</p><ul class=""><li id="a1ed" class="kc kd hi is b it iu ix iy jb ke jf kf jj kg jn kh ki kj kk bi translated"><strong class="is hj">破坏了</strong>我们为创建<code class="du jy jz ka kb b">proxy</code>所做的所有努力，因为我们仍然必须自己管理句柄操作，比如开始、关闭。</li><li id="a51d" class="kc kd hi is b it kl ix km jb kn jf ko jj kp jn kh ki kj kk bi translated">容易出错，需要在所有方法中使用<code class="du jy jz ka kb b">duplicated</code>。还有，我说了处理<code class="du jy jz ka kb b">exceptions</code>吗？</li></ul><figure class="jq jr js jt fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mm"><img src="../Images/d02e486ed0868c91d7c47cc60f25ca1f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9OperjmmIwP5W24hS1fX_g.png"/></div></div><figcaption class="ju jv et er es jw jx bd b be z dx translated">你能想象对每个方法都这样做吗？</figcaption></figure><figure class="jq jr js jt fd ij"><div class="bz dy l di"><div class="mn kz l"/></div></figure><p id="285f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如果我们仔细观察，我们所需要的是在执行 a <code class="du jy jz ka kb b">request lifecycle</code>期间适当的<code class="du jy jz ka kb b">hooks</code>。幸运的是，对我们来说，Jersey 为我们提供了所谓的事件监视器和应用程序监听器。</p><p id="2c19" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">创建应用程序监听器非常简单。</p><figure class="jq jr js jt fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es jp"><img src="../Images/498ef657587769f72a7538bb644a1a7c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NjLf48z9c3SnNCZ7ePkgnA.png"/></div></div></figure><p id="fe7b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们实现了由<code class="du jy jz ka kb b">Jersey</code>提供的<code class="du jy jz ka kb b">ApplicationEventListener</code>,并覆盖了关键方法<code class="du jy jz ka kb b">onRequest()</code>,每当环境要为一个新的<code class="du jy jz ka kb b">request</code>提供服务时，该方法就会被执行。</p><ul class=""><li id="3da3" class="kc kd hi is b it iu ix iy jb ke jf kf jj kg jn kh ki kj kk bi translated">我们提供了一种不监听在<code class="du jy jz ka kb b">excluded set</code>中指定的<code class="du jy jz ka kb b">URIs</code>事件的方法。这种设置可以在应用程序的驱动程序中配置，也可以选择<code class="du jy jz ka kb b">injected</code>。这样，不与<code class="du jy jz ka kb b">Dao</code>对话的请求没有开销。这可以包括来自“<em class="kq"> ELB </em>”服务器或“<em class="kq">静态资产</em>”唯一资源 API 的请求</li><li id="ea90" class="kc kd hi is b it kl ix km jb kn jf ko jj kp jn kh ki kj kk bi translated">如果请求方法是<code class="du jy jz ka kb b">GET</code>，我们将它绑定到一个<code class="du jy jz ka kb b">Get Request Listener</code></li><li id="794c" class="kc kd hi is b it kl ix km jb kn jf ko jj kp jn kh ki kj kk bi translated">如果请求方法是<code class="du jy jz ka kb b">POST</code>，我们将它绑定到一个<code class="du jy jz ka kb b">Non GET Request listener</code></li></ul><p id="f63b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">你可能会问为什么我们在<code class="du jy jz ka kb b">request type</code>上创造了<code class="du jy jz ka kb b"><strong class="is hj">two</strong></code>个不同的<code class="du jy jz ka kb b">listeners</code>。这和休息哲学有很大关系。<code class="du jy jz ka kb b">Get</code>请求并不意味着在服务器上创建/更新资源。因此，它们不需要在事务中执行。但是，他们仍然需要创建/关闭一个句柄。</p><h2 id="ca19" class="le lf hi bd ln mo mp mq lr mr ms mt lv jb mu mv lz jf mw mx md jj my mz mh na bi translated">让我们来看看一个<code class="du jy jz ka kb b">GET Request listener</code>是如何实现的</h2><figure class="jq jr js jt fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es nb"><img src="../Images/dbe1a9f3377d3cb9fb90f93ff8e6ee67.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*J7fmpM_n0SvxyndVDeS3UA.png"/></div></div><figcaption class="ju jv et er es jw jx bd b be z dx translated">基于请求生命周期，我们初始化并关闭句柄</figcaption></figure><ul class=""><li id="6834" class="kc kd hi is b it iu ix iy jb ke jf kf jj kg jn kh ki kj kk bi translated"><code class="du jy jz ka kb b"><strong class="is hj">Handle only</strong></code>特种作战已经转移到一个新的职业，叫做<code class="du jy jz ka kb b"><strong class="is hj">JdbiTransactionAspect</strong></code>，它很好的完成了这些任务。关键是要注意，每个请求都会创建一个新的实例。它不是单一的。</li><li id="5eaa" class="kc kd hi is b it kl ix km jb kn jf ko jj kp jn kh ki kj kk bi translated">每当一个请求是<code class="du jy jz ka kb b">matched</code>到一个匹配的<code class="du jy jz ka kb b">resource method</code>，我们初始化<code class="du jy jz ka kb b">handle</code>。</li><li id="85ab" class="kc kd hi is b it kl ix km jb kn jf ko jj kp jn kh ki kj kk bi translated">每当一个<code class="du jy jz ka kb b">request</code>为<code class="du jy jz ka kb b">finished</code>(不管有无异常)，我们就<code class="du jy jz ka kb b">close</code>这个<code class="du jy jz ka kb b">handle</code></li></ul><p id="d1dd" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><em class="kq">简单的</em>、<em class="kq">宣示性的</em>和<em class="kq">美观的</em>。Jersey " <code class="du jy jz ka kb b"><strong class="is hj">FINISHED</strong></code>"不管有没有异常，事件都保证会执行，这正是我们想要的。它们有点像我们在上面显式创建的 finally 块。</p><p id="7f0c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如果你读过<code class="du jy jz ka kb b">Jersey Request events</code>，你会发现我们在<code class="du jy jz ka kb b"><strong class="is hj">RESOURCE_METHOD_START</strong></code>之前跳过了很多事件，为什么我们不在<a class="ae jo" href="https://github.com/jersey/jersey/blob/faa809da43538ce31076b50f969b4bd64caa5ac9/core-server/src/main/java/org/glassfish/jersey/server/monitoring/RequestEvent.java#L77" rel="noopener ugc nofollow" target="_blank">更早的阶段</a>初始化一个句柄，而不是在资源方法中？</p><p id="6dad" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">答案是，这取决于用例。很多时候，服务器上没有与<code class="du jy jz ka kb b">request</code>匹配的资源，这就是我们看到<code class="du jy jz ka kb b">404</code>没有找到的时候。我们是否希望<code class="du jy jz ka kb b"><strong class="is hj">initialise</strong></code>和<code class="du jy jz ka kb b"><strong class="is hj">close</strong></code>为 404 设计一个手柄？</p><p id="8b7b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我不这么认为。因此，只有当一个<code class="du jy jz ka kb b">request</code>匹配某个特定的方法时，才会执行这个操作。但是，您的里程可能会有所不同。</p><p id="fc4d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">让我们看看如何实现非 GET 请求监听器</strong></p><p id="72b1" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">上面的实现很简单。有<em class="kq">没有</em>有<code class="du jy jz ka kb b"><em class="kq">transactions</em></code>。正如您可能已经猜到的，现在是我们将<code class="du jy jz ka kb b">request</code>生命周期事件绑定到适当的<code class="du jy jz ka kb b">handle</code>方法的时候了。</p><p id="ccfd" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">您可能想暂停一下，看看在一个<code class="du jy jz ka kb b">transaction</code>的上下文中，什么<code class="du jy jz ka kb b">request event</code>应该绑定到什么句柄方法。你的小抄是<a class="ae jo" href="https://github.com/jersey/jersey/blob/faa809da43538ce31076b50f969b4bd64caa5ac9/core-server/src/main/java/org/glassfish/jersey/server/monitoring/RequestEvent.java#L65" rel="noopener ugc nofollow" target="_blank">这里</a></p><figure class="jq jr js jt fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es nc"><img src="../Images/b9c604d6d760cb2a6581f0a5b600ed31.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZIGiU0vAUHjDad_TiSr3xQ.png"/></div></div><figcaption class="ju jv et er es jw jx bd b be z dx translated">基于请求生命周期，我们还可以选择管理一个事务</figcaption></figure><p id="d26e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如你所见，与<code class="du jy jz ka kb b">GET listener</code>有一些相似之处。然而，应注意以下几点</p><ul class=""><li id="2692" class="kc kd hi is b it iu ix iy jb ke jf kf jj kg jn kh ki kj kk bi translated">这一次，我们的<code class="du jy jz ka kb b"><strong class="is hj">initialise</strong></code>不仅挂钩<code class="du jy jz ka kb b"><strong class="is hj">initialises</strong></code>一个句柄，还挂钩<code class="du jy jz ka kb b"><strong class="is hj">begins</strong></code>一个事务(如果它检测到该方法是事务性的)</li><li id="c373" class="kc kd hi is b it kl ix km jb kn jf ko jj kp jn kh ki kj kk bi translated"><code class="du jy jz ka kb b"><strong class="is hj">RESP_FILTERS_START</strong></code>是我们开始<code class="du jy jz ka kb b"><strong class="is hj">committing</strong></code>请求的地方。此时，该方法已经提供了响应，这表明执行成功，我们可以提交事务了。</li><li id="8bed" class="kc kd hi is b it kl ix km jb kn jf ko jj kp jn kh ki kj kk bi translated"><code class="du jy jz ka kb b"><strong class="is hj">ON_EXCEPTION</strong></code>每当异常上升到顶层时执行。这类似于我们的<code class="du jy jz ka kb b"> catch(Exception ex)</code>块，但在<code class="du jy jz ka kb b">request</code>级别。当我们看到这一点，我们回滚</li><li id="87c0" class="kc kd hi is b it kl ix km jb kn jf ko jj kp jn kh ki kj kk bi translated">最后总是执行<code class="du jy jz ka kb b"><strong class="is hj">FINISHED</strong></code>和<code class="du jy jz ka kb b"><strong class="is hj">closes</strong></code>我们的句柄。这一步很重要。如果我们没有把手，我们就会泄漏一个把手，很快就会失去把手，这绝对不是我们希望在<em class="kq">生产</em>中看到的</li></ul><figure class="jq jr js jt fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es nd"><img src="../Images/82e49e79609c1e3ddbdc1169d9dc115d.png" data-original-src="https://miro.medium.com/v2/resize:fit:816/format:webp/1*xOcUiKn1JS7cjPY0UC_6fQ.png"/></div></div><figcaption class="ju jv et er es jw jx bd b be z dx translated">30 秒是默认的 Tomcat 连接池超时。我们永远不想看到这一幕</figcaption></figure><blockquote class="kr ks kt"><p id="c55a" class="iq ir kq is b it iu iv iw ix iy iz ja ku jc jd je kv jg jh ji kw jk jl jm jn hb bi translated">我们如何知道一个请求需要被包装在一个事务上下文中？</p></blockquote><p id="e7c7" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们转向我们的自定义注释<code class="du jy jz ka kb b">@JdbiUnitOfWork</code>如果一个资源方法用这样的注释来注释，我们标记一个事务边界。<br/>注意，这类似于<code class="du jy jz ka kb b">UnitOfWork</code>的行为。事实上，这个设计很大程度上受到工作单元方面<a class="ae jo" href="https://github.com/dropwizard/dropwizard/blob/master/dropwizard-hibernate/src/main/java/io/dropwizard/hibernate/UnitOfWorkAspect.java" rel="noopener ugc nofollow" target="_blank">实现</a>的启发</p><p id="3809" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">其余的方法非常简单明了。注意，如果一个资源方法是非事务性的，即没有用<code class="du jy jz ka kb b">@JdbiUnitOfWork</code>注释，那么方法<code class="du jy jz ka kb b"><strong class="is hj">commit</strong></code>和<code class="du jy jz ka kb b"><strong class="is hj">rollback</strong></code>什么都不做。</p><figure class="jq jr js jt fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ne"><img src="../Images/ef0b987701c47bed5538e90b12106cbf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UCuRItJWWgb2fYRLmZ_ZYw.png"/></div></div><figcaption class="ju jv et er es jw jx bd b be z dx translated">我们的非 GET 事务性请求监听器的缺失和琐碎部分</figcaption></figure><h2 id="2dec" class="le lf hi bd ln mo mp mq lr mr ms mt lv jb mu mv lz jf mw mx md jj my mz mh na bi translated">最后一个关键部分，交易方面</h2><p id="339e" class="pw-post-body-paragraph iq ir hi is b it nf iv iw ix ng iz ja jb nh jd je jf ni jh ji jj nj jl jm jn hb bi translated">注意，在本文的前面，我们讨论了句柄提供的核心功能。我们还讨论了如何抽象核心句柄操作。</p><p id="7c18" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><code class="du jy jz ka kb b"><strong class="is hj">JbdiTransactionAspect</strong></code>就是用来填补这个空白的。它在关键的句柄方法上提供了一个包装器，整个代码都围绕着这些方法旋转。</p><figure class="jq jr js jt fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es nk"><img src="../Images/9777f6c43cbbc0ee9d20396a8a02c032.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tvatZveifxpnPHW6W9MkvA.png"/></div></div><figcaption class="ju jv et er es jw jx bd b be z dx translated">核心句柄操作的简单包装</figcaption></figure><p id="1c44" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在实践中，我们有几个 try-catch 来保护句柄上的操作。你可能想看看这里的<a class="ae jo" href="https://github.com/isopropylcyanide/dropwizard-jdbi-unitofwork/blob/master/src/main/java/com/github/isopropylcyanide/jdbiunitofwork/core/JdbiTransactionAspect.java" rel="noopener ugc nofollow" target="_blank"/></p><p id="dfd3" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们抽象这些操作的原因是，如果将来<code class="du jy jz ka kb b"><strong class="is hj">begin()</strong></code>被重命名为<code class="du jy jz ka kb b"><strong class="is hj">newBegin()</strong></code>，我们只需要修改一个类。另外对付我们自己的<code class="du jy jz ka kb b">handle manager</code>比对付一个核心<code class="du jy jz ka kb b">handle</code>要好</p><h1 id="13fa" class="lm lf hi bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">将它们结合在一起</h1><p id="f45e" class="pw-post-body-paragraph iq ir hi is b it nf iv iw ix ng iz ja jb nh jd je jf ni jh ji jj nj jl jm jn hb bi translated">唷，我们已经经历了许多概念和责任。然而，如果我们不能把所有的东西粘在一起，那就什么也得不到。就这么办吧。</p><ul class=""><li id="2700" class="kc kd hi is b it iu ix iy jb ke jf kf jj kg jn kh ki kj kk bi translated">将<code class="du jy jz ka kb b">JDBI application listener </code>绑在运动衫<code class="du jy jz ka kb b">environment</code>上</li></ul><figure class="jq jr js jt fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es nl"><img src="../Images/d42f491c9b3afef45af8baf7fed0de7e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6S1_45TPojvZWDBaX3lutw.png"/></div></div><figcaption class="ju jv et er es jw jx bd b be z dx translated">绑定我们的侦听器、排除的路径和句柄管理器</figcaption></figure><ul class=""><li id="1a0c" class="kc kd hi is b it iu ix iy jb ke jf kf jj kg jn kh ki kj kk bi translated">所有应用<code class="du jy jz ka kb b">Dao</code>都需要<code class="du jy jz ka kb b">proxied</code>并注入到自己喜欢的依赖注入框架中。如果你喜欢冒险，你可以手工制作。然而，<code class="du jy jz ka kb b"><a class="ae jo" href="https://github.com/isopropylcyanide/dropwizard-jdbi-unitofwork/blob/master/src/main/java/com/github/isopropylcyanide/jdbiunitofwork/JdbiUnitOfWorkModule.java" rel="noopener ugc nofollow" target="_blank">module</a></code>可能会让你的生活更轻松。</li><li id="3e90" class="kc kd hi is b it kl ix km jb kn jf ko jj kp jn kh ki kj kk bi translated">用<code class="du jy jz ka kb b">JdbiUnitOfWork</code>开始注释您的资源方法</li></ul><figure class="jq jr js jt fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es nm"><img src="../Images/3a6811d4617654e65767927b0e0c431b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*n9hBtJ0ItTXhbKw5shghag.png"/></div></div><figcaption class="ju jv et er es jw jx bd b be z dx translated">我们的 POST 方法现在将在事务边界中执行</figcaption></figure><p id="0899" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">仅此而已。我们已经实现了。我们的设计是<code class="du jy jz ka kb b">modular</code>和<code class="du jy jz ka kb b">extensible</code>足以支持<code class="du jy jz ka kb b">customisation</code>。例如，您甚至可以选择对<code class="du jy jz ka kb b">GET</code>方法和许多其他定制进行交易初始化。</p><p id="effd" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">敏锐的读者可能已经注意到以下几点</p><ul class=""><li id="1a63" class="kc kd hi is b it iu ix iy jb ke jf kf jj kg jn kh ki kj kk bi translated">但是我们如何继续谈论 T8 和 T9 呢？</li><li id="6026" class="kc kd hi is b it kl ix km jb kn jf ko jj kp jn kh ki kj kk bi translated">我们如何处理<code class="du jy jz ka kb b">scoping</code>？或者单个<code class="du jy jz ka kb b">handle</code> at 线程、请求、应用。</li><li id="9143" class="kc kd hi is b it kl ix km jb kn jf ko jj kp jn kh ki kj kk bi translated">如果我们想在一个请求中创建与不同的<code class="du jy jz ka kb b">Dao</code>对话的<code class="du jy jz ka kb b">multiple threads</code>呢？我们如何与子句柄共享一个父句柄？</li></ul><blockquote class="kr ks kt"><p id="bb14" class="iq ir kq is b it iu iv iw ix iy iz ja ku jc jd je kv jg jh ji kw jk jl jm jn hb bi translated">这是一篇很长的文章。我想暂时在这里结束。如果你感兴趣的话，我会在第三部分贴出一个<a class="ae jo" rel="noopener" href="/@aman_garg/building-unit-of-work-support-for-jdbi-in-dropwizard-part-iii-d9d0b1e245c3?postPublishedType=initial">来继续解决上面提到的问题。</a></p><p id="f527" class="iq ir kq is b it iu iv iw ix iy iz ja ku jc jd je kv jg jh ji kw jk jl jm jn hb bi translated">像往常一样，这个项目可以在 Github 和 Maven Central 上找到。一定要去看看，留下评论:)</p></blockquote></div></div>    
</body>
</html>