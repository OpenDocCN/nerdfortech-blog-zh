<html>
<head>
<title>Minimum Insertion Steps to Make a String Palindrome — Day 66</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">形成字符串回文的最少插入步骤——第 66 天</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/minimum-insertion-steps-to-make-a-string-palindrome-day-66-f4b3ac170a33?source=collection_archive---------4-----------------------#2021-02-02">https://medium.com/nerd-for-tech/minimum-insertion-steps-to-make-a-string-palindrome-day-66-f4b3ac170a33?source=collection_archive---------4-----------------------#2021-02-02</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/47eb9f66956e77ddde2dc3db0fc7b6eb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*ElcU8fLAE6VLexIc"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated"><a class="ae iu" href="https://unsplash.com/@designecologist?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">设计生态学家</a>在<a class="ae iu" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="8b28" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">今天的问题是最长公共子序列的另一个变体。</p></div><div class="ab cl jt ju gp jv" role="separator"><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy"/></div><div class="hb hc hd he hf"><p id="eb9f" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><a class="ae iu" href="https://leetcode.com/problems/minimum-insertion-steps-to-make-a-string-palindrome/" rel="noopener ugc nofollow" target="_blank">T9】1312</a><strong class="ix hj">。创建字符串回文的最小插入步骤</strong></p><p id="c78e" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">给定一个字符串<code class="du ka kb kc kd b">s</code>。在一个步骤中，您可以在字符串的任何索引处插入任何字符。</p><p id="8d2b" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">返回<em class="ke">使<code class="du ka kb kc kd b">s</code>回文的最小步数</em>。</p><p id="10cf" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">回文字符串是一个向前和向后都一样的字符串。</p><p id="d26e" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">例 1: </strong></p><pre class="kf kg kh ki fd kj kd kk kl aw km bi"><span id="3915" class="kn ko hi kd b fi kp kq l kr ks"><strong class="kd hj">Input:</strong> s = "zzazz"<br/><strong class="kd hj">Output:</strong> 0<br/><strong class="kd hj">Explanation:</strong> The string "zzazz" is already palindrome we don't need any insertions.</span></pre><p id="c66d" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">例二:</strong></p><pre class="kf kg kh ki fd kj kd kk kl aw km bi"><span id="97e3" class="kn ko hi kd b fi kp kq l kr ks"><strong class="kd hj">Input:</strong> s = "mbadm"<br/><strong class="kd hj">Output:</strong> 2<br/><strong class="kd hj">Explanation:</strong> String can be "mbdadbm" or "mdbabdm".</span></pre><p id="6ad4" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">例 3: </strong></p><pre class="kf kg kh ki fd kj kd kk kl aw km bi"><span id="77d0" class="kn ko hi kd b fi kp kq l kr ks"><strong class="kd hj">Input:</strong> s = "leetcode"<br/><strong class="kd hj">Output:</strong> 5<br/><strong class="kd hj">Explanation:</strong> Inserting 5 characters the string becomes "leetcodocteel".</span></pre><p id="5211" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">例 4: </strong></p><pre class="kf kg kh ki fd kj kd kk kl aw km bi"><span id="46a3" class="kn ko hi kd b fi kp kq l kr ks"><strong class="kd hj">Input:</strong> s = "g"<br/><strong class="kd hj">Output:</strong> 0</span></pre><p id="7642" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">例 5: </strong></p><pre class="kf kg kh ki fd kj kd kk kl aw km bi"><span id="f676" class="kn ko hi kd b fi kp kq l kr ks"><strong class="kd hj">Input:</strong> s = "no"<br/><strong class="kd hj">Output:</strong> 1</span></pre><p id="8888" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">约束:</strong></p><ul class=""><li id="4bf5" class="kt ku hi ix b iy iz jc jd jg kv jk kw jo kx js ky kz la lb bi translated"><code class="du ka kb kc kd b">1 &lt;= s.length &lt;= 500</code></li><li id="5646" class="kt ku hi ix b iy lc jc ld jg le jk lf jo lg js ky kz la lb bi translated"><code class="du ka kb kc kd b">s</code>的所有字符都是小写英文字母。</li></ul></div><div class="ab cl jt ju gp jv" role="separator"><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy"/></div><div class="hb hc hd he hf"><p id="86a3" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">几天前我们已经解决了最长的回文子序列。如果你需要复习，你可以点击这个<a class="ae iu" href="https://atharayil.medium.com/longest-palindromic-subsequence-day-63-python-b5da4959c2a5" rel="noopener">链接</a>。我们将分两部分解决给定的问题。问题的第一部分是使用最长的回文子序列。让我们回忆一下最长回文子序列的代码。</p><pre class="kf kg kh ki fd kj kd kk kl aw km bi"><span id="b4f7" class="kn ko hi kd b fi kp kq l kr ks">class LongestPalindromeSubseqFinder:<br/>    def longestPalindromeSubseq(self, s: str) -&gt; int:<br/>        memo = [[0 for j in range(len(s)+1)]for i in range(len(s)+1)]<br/>        rev_s = s[::-1]<br/>        for i in range(1, len(memo)):<br/>            for j in range(1, len(memo[0])):<br/>                if s[i-1] == rev_s[j-1]:<br/>                    memo[i][j] = memo[i-1][j-1]+1<br/>                else:<br/>                    memo[i][j] = max(memo[i][j-1], memo[i-1][j])<br/>        return memo[-1][-1]</span></pre><p id="8fca" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在上面的代码中，我们将得到最长的回文子序列的长度。</p><p id="c159" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">剩下的字符是什么？剩余的字符不构成回文子序列的一部分。如果我们可以得到一个不构成回文子序列的额外字符的列表，我们可以通过插入这些额外字符将字符串转换成回文字符串。</p><p id="1fca" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">让我们举一个例子，</p><figure class="kf kg kh ki fd ij er es paragraph-image"><div class="er es lh"><img src="../Images/cfcbc861741fde7e186fd1da0719ef29.png" data-original-src="https://miro.medium.com/v2/resize:fit:1180/format:webp/1*ITmup4OAe0G7-XN3qq27UQ.png"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">最少插入示例</figcaption></figure><p id="7094" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">解决这个问题的第二部分是找到完整字符串的长度和最长公共子序列的长度之差。</p><p id="eac0" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">让我们来看看代码片段。</p><pre class="kf kg kh ki fd kj kd kk kl aw km bi"><span id="42f0" class="kn ko hi kd b fi kp kq l kr ks">class MinInsertionsFinder:<br/>    def minInsertions(self, s: str) -&gt; int:<br/>        memo = [[0 for j in range(len(s)+1)]for i in range(len(s)+1)]<br/>        rev_s = s[::-1]<br/>        for i in range(1, len(memo)):<br/>            for j in range(1, len(memo[0])):<br/>                if s[i-1] == rev_s[j-1]:<br/>                    memo[i][j] = memo[i-1][j-1] + 1<br/>                else:<br/>                    memo[i][j] = max(memo[i][j-1], memo[i-1][j])<br/>        return(len(s) - memo[-1][-1])</span></pre><p id="81bf" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如果问题是找到最小删除使字符串回文，我们可以使用相同的逻辑。</p><p id="1587" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">复杂性分析。</strong></p><p id="ec97" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">时间复杂度</strong></p><p id="2fd6" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们正在遍历一个大小为 N 的 2D 数组，因此时间复杂度为 O(N)，其中 N 是字符串的大小。</p><p id="9264" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">空间复杂性。</strong></p><p id="8ef6" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们正在创建一个大小为 N 的 2D 数组，因此空间复杂度为 O(N)，其中 N 是字符串的大小。</p></div><div class="ab cl jt ju gp jv" role="separator"><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy"/></div><div class="hb hc hd he hf"><p id="6f9e" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">链接到阿迪亚·维尔马的视频</p><figure class="kf kg kh ki fd ij"><div class="bz dy l di"><div class="li lj l"/></div></figure></div></div>    
</body>
</html>