<html>
<head>
<title>Solving: moveZerosToEnd</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">求解:移动零结束</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/solving-movezerostoend-760342d64026?source=collection_archive---------19-----------------------#2021-04-18">https://medium.com/nerd-for-tech/solving-movezerostoend-760342d64026?source=collection_archive---------19-----------------------#2021-04-18</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div class="er es if"><img src="../Images/3506df78ef32aa924529696f7763babf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1012/format:webp/1*EP0ytcStGI7JKkN3a3SuKw.png"/></div></figure><p id="adf3" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">在本文中，我将用Javascript以几种不同的方式来解决moveZerosToEnd问题。我将介绍我解决这个问题的过程，并讨论它的重要性。</p><p id="f3cc" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">我们开始吧！</p><h1 id="aa89" class="jk jl hi bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">问题</h1><h2 id="fca3" class="ki jl hi bd jm kj kk kl jq km kn ko ju ix kp kq jy jb kr ks kc jf kt ku kg kv bi translated">给定一个静态大小的整数数组<code class="du kw kx ky kz b">arr</code>，将数组中的所有零移动到数组的末尾。您应该保留数组中项目的相对顺序。</h2><h2 id="f1ba" class="ki jl hi bd jm kj kk kl jq km kn ko ju ix kp kq jy jb kr ks kc jf kt ku kg kv bi translated">我们应该实现一个比简单的暴力更有效的解决方案。</h2><p id="1561" class="pw-post-body-paragraph im in hi io b ip la ir is it lb iv iw ix lc iz ja jb ld jd je jf le jh ji jj hb bi translated"><strong class="io hj">例子:</strong></p><pre class="lf lg lh li fd lj kz lk ll aw lm bi"><span id="1ebc" class="ki jl hi kz b fi ln lo l lp lq">input:  arr = [1, 10, 0, 2, 8, 3, 0, 0, 6, 4, 0, 5, 7, 0]<br/>output: [1, 10, 2, 8, 3, 6, 4, 5, 7, 0, 0, 0, 0, 0]</span></pre><p id="1a3d" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><strong class="io hj">约束:</strong></p><ul class=""><li id="5830" class="lr ls hi io b ip iq it iu ix lt jb lu jf lv jj lw lx ly lz bi translated"><strong class="io hj">【时限】5000ms </strong></li><li id="e1cb" class="lr ls hi io b ip ma it mb ix mc jb md jf me jj lw lx ly lz bi translated"><strong class="io hj">【输入】数组.整数</strong> <code class="du kw kx ky kz b">arr</code> → 0 ≤数组长度≤ 20</li><li id="1852" class="lr ls hi io b ip ma it mb ix mc jb md jf me jj lw lx ly lz bi translated"><strong class="io hj">【输出】array.integer </strong></li></ul><p id="af9b" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">我们来分析一下问题。我们所做的在概念上非常简单，如果在非零值之前有一个零值，将零值移动到它后面，同时保持非零值的相对顺序。</p><p id="33ba" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">让我们考虑几种方法:</p><p id="8112" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">方法1:</p><p id="f888" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">一种想法是遍历数组，将任何非零值推入非零数组，将任何零值推入onlyZeros数组。然后在一个新数组中展开两个数组，非零数组首先展开。</p><p id="036b" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">方法2:</p><p id="6e37" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">另一个想法是循环遍历数组，当我们遇到一个0时暂停，然后继续搜索数组，直到遇到一个非零值。此时，我们可以交换这两个值，最终返回一个末尾全是零的数组。</p><p id="56ac" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">让我们来比较一下这两种方法:</p><h2 id="4e8b" class="ki jl hi bd jm kj kk kl jq km kn ko ju ix kp kq jy jb kr ks kc jf kt ku kg kv bi translated">方法1</h2><figure class="lf lg lh li fd ij er es paragraph-image"><div class="er es mf"><img src="../Images/7f427750f783b2bebc0ddc4dc9da1675.png" data-original-src="https://miro.medium.com/v2/resize:fit:982/format:webp/1*xdqyq5fuWJANsQ7FoGAdtA.png"/></div></figure><p id="079c" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">通过第37-47行，我们可以看到非零和零数组通过一个简单的forLoop进行实例化和填充，if语句将值过滤到两个数组中。</p><p id="4ee5" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">在第48行，我们创建了一个新的数组，用spread操作符将两个数组组合在一起。</p><p id="aaaf" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">最后，因为我们想返回给我们的同一个数组，所以我们再次遍历给定的参数，并用给定索引的相应值替换每个值。</p><p id="bd81" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">时间复杂度归结为O(n ),而空间复杂度也是如此。</p><p id="ce9f" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">如果你想出了这个方法——干得好！简单有效！</p><h2 id="b548" class="ki jl hi bd jm kj kk kl jq km kn ko ju ix kp kq jy jb kr ks kc jf kt ku kg kv bi translated">方法2</h2><figure class="lf lg lh li fd ij er es paragraph-image"><div class="er es mg"><img src="../Images/9877398dafdebabb36a1ba91e84770d0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1158/format:webp/1*7YGz-57uH5GuZ3QxZ7HkdQ.png"/></div></figure><p id="dedb" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">我们立即看到这里有一个嵌套循环。第一个循环遍历数组，检查每个值，看它是否等于0。如果是这样，我们进入另一个迭代，从i+1开始，下一个值是j。如果下一个值也为零，循环将继续，直到遇到非零值或结束循环的剩余部分。一旦j命中一个具有非零值的索引，我们将这些值分别存储在iVal和jVal中，并交换I索引和j索引处的值。</p><p id="6779" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">这背后的逻辑是合理的。我们循环遍历，在零值处暂停，搜索下一个非零值并交换它们的位置。</p><p id="8faa" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">如果你找到了这个解决方案，那太好了。没什么问题。</p><p id="a3e0" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">然而，它目前的运行速度是O(n )…我们如何才能让它更高效呢？</p><p id="453e" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">很明显，我们想摆脱嵌套循环。让我们看看这里的循环到底在做什么。</p><p id="ef89" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">第一个循环在零值处暂停。第二个循环在非零值处暂停。</p><p id="7474" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">所以我们真正需要知道的基本部分是当前零值(第一个循环)和下一个非零值(嵌套循环)的索引。</p><p id="9ddc" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">我们如何做到这一点？</p><p id="66c0" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">引入“指针”。</p><p id="0eba" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">我们可以创建“指向”我们关注的指数的变量，并允许我们交换这些指数的值以获得期望的结果。同时对嵌套循环进行转义！</p><h2 id="27d1" class="ki jl hi bd jm kj kk kl jq km kn ko ju ix kp kq jy jb kr ks kc jf kt ku kg kv bi translated">方法2 —优化</h2><p id="fcf4" class="pw-post-body-paragraph im in hi io b ip la ir is it lb iv iw ix lc iz ja jb ld jd je jf le jh ji jj hb bi translated">这种方法使用类似于quickSelect的思想，通过非零值对数组进行分区。我们要做的是，遍历数组，当我们遇到非零值时，增加“写”指针和“读”指针，如果我们没有遇到非零值，我们将继续增加“读”指针，而“写”指针将停留在最左边的零的索引处。因此，当我们继续读取数组的值时，跟踪具有零值的索引。当我们遇到非零值时，我们将交换“读取”和“写入”索引的值。</p><p id="59bb" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">它看起来会像这样:</p><figure class="lf lg lh li fd ij er es paragraph-image"><div class="er es mh"><img src="../Images/de69a4a828b2e845c9b7dbf3da40d7fe.png" data-original-src="https://miro.medium.com/v2/resize:fit:696/format:webp/1*-z9RYzA2EbgsAAj50K7rRA.png"/></div></figure><p id="72ac" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">请注意，对于索引0–2，arr[read]和arr[write]的值将是相同的，因此当您“交换”它们时，您只是将相同的值替换到数组的索引中。</p><p id="e789" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">一旦我们达到一个零值，写指针就一直指向该值的索引。同时读指针继续。</p><p id="f45d" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">一旦读指针命中非零值，它将把其索引处的值与存储在写指针中的索引处的值交换。</p><figure class="lf lg lh li fd ij er es paragraph-image"><div role="button" tabindex="0" class="mj mk di ml bf mm"><div class="er es mi"><img src="../Images/b776bbe6a4adf06bf045038dd6686ed0.png" data-original-src="https://miro.medium.com/v2/resize:fit:706/format:webp/1*YPtq9OYzJNBjaFWoJp7HpA.png"/></div></div></figure><p id="36eb" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">现在我们已经把它形象化了一点。让我们看看代码。</p><figure class="lf lg lh li fd ij er es paragraph-image"><div class="er es mn"><img src="../Images/4d1ebac16d69a48a7ab2cc2162822d4c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1076/format:webp/1*U5ueunjy4rOgRCIeepHWkg.png"/></div></figure><p id="f209" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">这里我们可以看到，我们已经将这种方法的第一个版本简化为一个循环，使用一个if语句来检查读取值是否非零。</p><p id="8bed" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">通过声明写指针并仅在非零值期间递增，我们取代了对嵌套循环的需要，而是可以简单地继续读取值并等待，直到我们找到非零值的索引来交换索引的值。</p><p id="6ac7" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">时间复杂度从O(n)简化为O(n ),而空间复杂度保持在O(1)的可爱常数时间，因为除了指针读取和写入之外，不需要额外的空间。</p><h2 id="cf23" class="ki jl hi bd jm kj kk kl jq km kn ko ju ix kp kq jy jb kr ks kc jf kt ku kg kv bi translated">结论</h2><p id="8802" class="pw-post-body-paragraph im in hi io b ip la ir is it lb iv iw ix lc iz ja jb ld jd je jf le jh ji jj hb bi translated">我认为了解不同的方法如何仍然能够提供可用的结果是有帮助的，我希望这种分解也说明了，无论您使用什么逻辑来解决问题，仍然有一种以低效/幼稚的方式使用该逻辑的方法——这意味着，如果您遵循您的逻辑并进入一段不那么高效的代码，有可能有一种更有效的方法使用相同的逻辑来编写它。所以不是你的逻辑感！这只是你解决方案的第一稿，每一遍都会变得更好！</p><p id="8513" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">希望这有所帮助！</p></div></div>    
</body>
</html>