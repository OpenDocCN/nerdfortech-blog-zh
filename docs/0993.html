<html>
<head>
<title>React Redux in Kotlin —for truly Native Mobile Development</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Kotlin 中的 React Redux 实现真正的原生移动开发</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/react-redux-in-kotlin-for-truly-native-mobile-development-25229937d4f?source=collection_archive---------10-----------------------#2021-02-28">https://medium.com/nerd-for-tech/react-redux-in-kotlin-for-truly-native-mobile-development-25229937d4f?source=collection_archive---------10-----------------------#2021-02-28</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><h2 id="fba4" class="hg hh hi bd b fp hj hk hl hm hn ho dx hp translated" aria-label="kicker paragraph">移动应用中的反应式编程——一次旅行</h2><div class=""/><div class=""><h2 id="99f6" class="pw-subtitle-paragraph io hr hi bd b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf dx translated">当前的原生移动开发已经过时，几乎被 JavaScript 框架淹没。让我们改变这种状况，从向他们学习开始</h2></div><h2 id="5109" class="jg jh hi bd ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc ho bi translated">介绍</h2><p id="03f3" class="pw-post-body-paragraph kd ke hi kf b kg kh is ki kj kk iv kl jr km kn ko jv kp kq kr jz ks kt ku kv hb bi translated">在第一部分的<a class="ae kw" rel="noopener" href="/@gguymi/3675ce94ccf5">中，我们谈到了<em class="kx">为什么</em>当前的本地移动开发方法已经过时。<br/>这开始了我们探索本地应用的反应式架构的旅程，在<em class="kx">Kotlin</em>(</a><a class="ae kw" href="https://kotlinlang.org/docs/multiplatform.html" rel="noopener ugc nofollow" target="_blank">multi platform？</a>)。</p><p id="dd3f" class="pw-post-body-paragraph kd ke hi kf b kg ky is ki kj kz iv kl jr la kn ko jv lb kq kr jz lc kt ku kv hb bi translated">在本部分中，我们将讨论<em class="kx">什么是建议的方法——在<em class="kx"> Kotlin </em>中<em class="kx"> React </em>和<em class="kx"> Redux </em>。<br/>下一部分将是关于<em class="kx">如何</em>实现和使用它。</em></p><p id="4d49" class="pw-post-body-paragraph kd ke hi kf b kg ky is ki kj kz iv kl jr la kn ko jv lb kq kr jz lc kt ku kv hb bi translated">来了<em class="kx">什么</em>和<em class="kx">怎么</em>那么！</p><figure class="le lf lg lh fd li er es paragraph-image"><div role="button" tabindex="0" class="lj lk di ll bf lm"><div class="er es ld"><img src="../Images/f40ea112d4a66b52211696af3cd5f330.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*39n7G-hbWy9nXxb3W7dx7Q.jpeg"/></div></div><figcaption class="lp lq et er es lr ls bd b be z dx translated">当事情变得不容易时，停下来，放松，找一个不同的视角，一个更高的角度。</figcaption></figure></div><div class="ab cl lt lu gp lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="hb hc hd he hf"><h1 id="d86b" class="ma jh hi bd ji mb mc md jm me mf mg jq ix mh iy ju ja mi jb jy jd mj je kc mk bi translated">(建议的方法)是什么？</h1><p id="b65e" class="pw-post-body-paragraph kd ke hi kf b kg kh is ki kj kk iv kl jr km kn ko jv kp kq kr jz ks kt ku kv hb bi translated">要了解一个好的应用架构是什么样子，我建议学习<a class="ae kw" href="https://reactjs.org/tutorial/tutorial.html#overview" rel="noopener ugc nofollow" target="_blank"> <em class="kx"> React </em> </a>和<a class="ae kw" href="https://redux.js.org/introduction/core-concepts" rel="noopener ugc nofollow" target="_blank"><em class="kx">Redux</em></a><em class="kx">—</em>的原理，并应用它们的方法来满足我们的本地开发需求。</p><blockquote class="ml mm mn"><p id="31b1" class="kd ke kx kf b kg ky is ki kj kz iv kl mo la kn ko mp lb kq kr mq lc kt ku kv hb bi translated">如果你已经熟悉了<em class="hi"> React-Redux </em>，你可以直接跳到下一篇文章——这篇文章解释了<em class="hi">如何从头开始构建</em><a class="ae kw" href="https://github.com/GuyMichael/Reactdroid" rel="noopener ugc nofollow" target="_blank"><em class="hi">React droid</em></a><em class="hi"/>。</p></blockquote><p id="3f88" class="pw-post-body-paragraph kd ke hi kf b kg ky is ki kj kz iv kl jr la kn ko jv lb kq kr jz lc kt ku kv hb bi translated">如果你想从我这里学习，请继续阅读。</p><blockquote class="ml mm mn"><p id="2afa" class="kd ke kx kf b kg ky is ki kj kz iv kl mo la kn ko mp lb kq kr mq lc kt ku kv hb bi translated"><em class="hi">编辑:在完成这个系列的时候，Android 终于发布了一个稳定版的</em><a class="ae kw" href="https://developer.android.com/jetpack/compose" rel="noopener ugc nofollow" target="_blank"><em class="hi">JetpackCompose</em></a><em class="hi">，基本上模仿了 React 的功能组件。与</em> <a class="ae kw" href="https://kotlinlang.org/docs/coroutines-overview.html" rel="noopener ugc nofollow" target="_blank"> <em class="hi">协同例程</em> </a> <em class="hi">和</em><a class="ae kw" href="https://reduxkotlin.org/" rel="noopener ugc nofollow" target="_blank"><em class="hi">Kotlin-Redux</em></a><em class="hi">一起，它是一个强大的“包”，通过一些努力，它可以一起用于解决我在这里介绍的许多概念。<br/>虽然所有这些都是真实的(并且您应该熟悉上面的技术)，我们将在这个系列中学习的概念是</em> <strong class="kf hs"> <em class="hi"> </em> </strong> <em class="hi">现在</em> <strong class="kf hs"> <em class="hi"> </em> </strong> <em class="hi">甚至</em><strong class="kf hs"><em class="hi"/></strong><em class="hi">——随着编写移动应用程序的“标准”方式越来越接近提到的概念。</em></p></blockquote></div><div class="ab cl lt lu gp lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="hb hc hd he hf"><h2 id="57f5" class="jg jh hi bd ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc ho bi translated">React 和 Redux 方法</h2><p id="3f42" class="pw-post-body-paragraph kd ke hi kf b kg kh is ki kj kk iv kl jr km kn ko jv kp kq kr jz ks kt ku kv hb bi translated">从高层次来说，<em class="kx"> React </em>是一个简单的 UI 架构——<em class="kx">基于组件的</em>；而<em class="kx"> Redux </em>是一个应用状态架构，它管理单个<strong class="kf hs">全局</strong>应用状态<em class="kx"/></p><p id="a7ca" class="pw-post-body-paragraph kd ke hi kf b kg ky is ki kj kz iv kl jr la kn ko jv lb kq kr jz lc kt ku kv hb bi translated">总之，<em class="kx"> React-Redux </em>为管理应用程序的 UI 和<em class="kx">数据</em> + <em class="kx">状态</em>提供了一个极好的结构。而当在<em class="kx"> Kotin、</em>中实现时，它的<em class="kx"> </em>一无所有<em class="kx"> </em>缺开发福佑。</p></div><div class="ab cl lt lu gp lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="hb hc hd he hf"><h2 id="d09f" class="jg jh hi bd ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc ho bi translated">简单地回答</h2><p id="7af9" class="pw-post-body-paragraph kd ke hi kf b kg kh is ki kj kk iv kl jr km kn ko jv kp kq kr jz ks kt ku kv hb bi translated">由于是基于<a class="ae kw" href="https://en.wikipedia.org/wiki/Component-based_software_engineering" rel="noopener ugc nofollow" target="_blank"> <em class="kx">组件的</em> </a>架构，<em class="kx"> React </em>主要是围绕单个<em class="kx">类</em>—<em class="kx">组件</em>及其 2 个成员——一个<em class="kx">状态</em>和一个<em class="kx">道具</em>(如果你已经熟悉<em class="kx">React</em>——我正在设置【T77</p><p id="796d" class="pw-post-body-paragraph kd ke hi kf b kg ky is ki kj kz iv kl jr la kn ko jv lb kq kr jz lc kt ku kv hb bi translated"><em class="kx">反应</em> <em class="kx">部件</em>在<em class="kx"> Kotlin </em>中基本上会是这样的:</p><figure class="le lf lg lh fd li"><div class="bz dy l di"><div class="mr ms l"/></div><figcaption class="lp lq et er es lr ls bd b be z dx translated">Kotlin 中 React 组件的简化声明</figcaption></figure><h2 id="08cd" class="jg jh hi bd ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc ho bi translated">该组件</h2><p id="33ae" class="pw-post-body-paragraph kd ke hi kf b kg kh is ki kj kk iv kl jr km kn ko jv kp kq kr jz ks kt ku kv hb bi translated"><em class="kx">组件</em>是一个<em class="kx">类</em>/模型，它单独负责更新/管理/ <em class="kx">渲染</em>UI 的某个部分。它没有别的目的。像一个<em class="kx">安卓</em> <em class="kx">视图</em>但是要多得多。</p><p id="dc2e" class="pw-post-body-paragraph kd ke hi kf b kg ky is ki kj kz iv kl jr la kn ko jv lb kq kr jz lc kt ku kv hb bi translated">由于<em class="kx">组件</em>是唯一管理 UI 的模型，它同时充当最底层的 UI 元素——例如一个<em class="kx">文本</em>或一个<em class="kx">按钮</em>；最上面的是一整个屏幕。像<em class="kx"> LinearLayouts </em>和<em class="kx"> Android </em>中的简单<em class="kx">视图</em>，只不过在这里，一切都只是一个<em class="kx">组件</em>。</p></div><div class="ab cl lt lu gp lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="hb hc hd he hf"><h2 id="77e9" class="jg jh hi bd ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc ho bi translated">组件的呈现()</h2><p id="5084" class="pw-post-body-paragraph kd ke hi kf b kg kh is ki kj kk iv kl jr km kn ko jv kp kq kr jz ks kt ku kv hb bi translated"><em class="kx">组件</em>只有<strong class="kf hs">一个</strong>地方可以/应该更新 UI——方法<code class="du mt mu mv mw b">render()</code>。</p><p id="0add" class="pw-post-body-paragraph kd ke hi kf b kg ky is ki kj kz iv kl jr la kn ko jv lb kq kr jz lc kt ku kv hb bi translated">其背后的想法既天才又荒谬:不是让单独的 UI 更新调用“躲避”在代码周围——你永远无法保证没有冲突/错误/漏洞，更不用说<em class="kx">轻松测试</em>所有可能性——而是有一个单一的地方一次性更新所有内容— <code class="du mt mu mv mw b">render()</code>。</p><p id="9ce2" class="pw-post-body-paragraph kd ke hi kf b kg ky is ki kj kz iv kl jr la kn ko jv lb kq kr jz lc kt ku kv hb bi translated">你答对了——这意味着每当一个<em class="kx">组件</em> <em class="kx">呈现</em>它的 UI 部分时，它会一次更新所有的 UI 部分😱。暂时忘掉效率吧，我们稍后会谈到它——会好起来的——这就是<em class="kx">反应</em>的天才之处(的一部分)。</p><p id="9b4e" class="pw-post-body-paragraph kd ke hi kf b kg ky is ki kj kz iv kl jr la kn ko jv lb kq kr jz lc kt ku kv hb bi translated">每次调用<code class="du mt mu mv mw b">render()</code> <em class="kx"> </em>方法时，<em class="kx">组件</em>使用其<em class="kx">状态+属性</em>模型/ <em class="kx">对象</em>来相应地更新 UI——因此，<em class="kx">状态+道具的特定设置，</em>将总是转换为屏幕上完全相同的 UI—<em class="kx">确定性— </em>这是<em class="kx">函数式编程</em>的一个重要方面。</p><p id="2796" class="pw-post-body-paragraph kd ke hi kf b kg ky is ki kj kz iv kl jr la kn ko jv lb kq kr jz lc kt ku kv hb bi translated">在<em class="kx">科特林</em>中，它看起来像这样:</p><figure class="le lf lg lh fd li"><div class="bz dy l di"><div class="mr ms l"/></div><figcaption class="lp lq et er es lr ls bd b be z dx translated">Kotlin 中 React 组件的基本原理。简化了的</figcaption></figure><h2 id="2cf7" class="jg jh hi bd ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc ho bi translated">(自己的)国家</h2><p id="3b8c" class="pw-post-body-paragraph kd ke hi kf b kg kh is ki kj kk iv kl jr km kn ko jv kp kq kr jz ks kt ku kv hb bi translated"><em class="kx">组件</em> <em class="kx">类</em>的第一个<em class="kx">成员</em>是(自己)<em class="kx">状态。<br/> </em>它只是一个<em class="kx">类</em> / <em class="kx">对象</em>/模型，表示——嗯——组件<em class="kx">的</em> t 的<em class="kx"> </em>内部<em class="kx"> </em>状态<em class="kx">；</em>是一个(' child') <em class="kx">文本</em> / <em class="kx">按钮组件</em>的当前文本(<code class="du mt mu mv mw b">String</code>，或者是一个复杂的<code class="du mt mu mv mw b">Object</code> <em class="kx"> </em>，代表<strong class="kf hs">屏幕上某一时刻的一切</strong>。</p><p id="1cfd" class="pw-post-body-paragraph kd ke hi kf b kg ky is ki kj kz iv kl jr la kn ko jv lb kq kr jz lc kt ku kv hb bi translated">围绕它的逻辑也很简单:每当<em class="kx">状态</em>改变时，保存它的<em class="kx">组件</em>必须更新 UI(重新<em class="kx">呈现</em>)。</p><p id="3496" class="pw-post-body-paragraph kd ke hi kf b kg ky is ki kj kz iv kl jr la kn ko jv lb kq kr jz lc kt ku kv hb bi translated">是的，你也说对了——每次时间<strong class="kf hs">任何东西</strong>在<em class="kx">状态</em>发生变化，<strong class="kf hs">整个</strong> <em class="kx">组件</em>都要重新<em class="kx">——渲染</em>。这意味着，如果那个<em class="kx">组件</em>是整个屏幕——每当<strong class="kf hs">任何东西</strong>在屏幕的<em class="kx">状态</em>发生变化的时候<strong class="kf hs">，整个<strong class="kf hs">屏幕都必须重新<em class="kx">渲染</em>😱😱😱。</strong></strong></p><p id="b0e1" class="pw-post-body-paragraph kd ke hi kf b kg ky is ki kj kz iv kl jr la kn ko jv lb kq kr jz lc kt ku kv hb bi translated">少了什么？一种从外部与那个<em class="kx">组件</em>进行通信的方式——那个特定的<em class="kx">组件的 API。</em>这(也)是一个<em class="kx">Android/iOS</em>T30】View 的一大缺失，顺便说一下。</p><p id="cbac" class="pw-post-body-paragraph kd ke hi kf b kg ky is ki kj kz iv kl jr la kn ko jv lb kq kr jz lc kt ku kv hb bi translated">进入时，<em class="kx">道具</em>。</p></div><div class="ab cl lt lu gp lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="hb hc hd he hf"><h2 id="dab9" class="jg jh hi bd ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc ho bi translated">道具</h2><p id="33d7" class="pw-post-body-paragraph kd ke hi kf b kg kh is ki kj kk iv kl jr km kn ko jv kp kq kr jz ks kt ku kv hb bi translated">Props 只是 properties 的简称。<br/> <em class="kx"> Props </em>是一个<em class="kx">组件的</em><em class="kx"/>API，简单地用某个<em class="kx">组件特有的模型来表示。</em>它就像<em class="kx">状态</em>，真的，除了它被外部('父')<em class="kx">组件</em>使用，与那个('子')<em class="kx">组件通信。<br/> </em>我再重复一遍，更简单:</p><p id="ea1b" class="pw-post-body-paragraph kd ke hi kf b kg ky is ki kj kz iv kl jr la kn ko jv lb kq kr jz lc kt ku kv hb bi translated">一个【拥有】<em class="kx">状态</em>是一个<em class="kx">私有</em> <em class="kx">对象，一个<em class="kx">组件</em>使用</em>知道什么+什么时候给<em class="kx">渲染</em>。</p><p id="5d44" class="pw-post-body-paragraph kd ke hi kf b kg ky is ki kj kz iv kl jr la kn ko jv lb kq kr jz lc kt ku kv hb bi translated">一个<em class="kx">道具</em>是一个<em class="kx">公共</em> <em class="kx">对象，</em>被‘外人’用来告诉一个<em class="kx">组件</em>什么+什么时候<em class="kx">渲染——</em>一个<em class="kx"> API </em>，由一个<em class="kx">对象</em>表示，而不是很多方法。</p><p id="cc15" class="pw-post-body-paragraph kd ke hi kf b kg ky is ki kj kz iv kl jr la kn ko jv lb kq kr jz lc kt ku kv hb bi translated">而你第三次得到了这个权利:<br/>一个<em class="kx">组件</em>响<em class="kx">——每当<em class="kx">状态</em>、<strong class="kf hs">或</strong> <em class="kx">道具</em>改变时，渲染</em>。每次都是。</p><p id="b8ce" class="pw-post-body-paragraph kd ke hi kf b kg ky is ki kj kz iv kl jr la kn ko jv lb kq kr jz lc kt ku kv hb bi translated">让我们把例子变得复杂一点。这一次，让我们看看使用/ <em class="kx">扩展</em> 2 <em class="kx">组件</em>会是什么样子，其中一个是<em class="kx"> TextComponent </em>的“父”组件，从而控制它:</p><figure class="le lf lg lh fd li"><div class="bz dy l di"><div class="mr ms l"/></div><figcaption class="lp lq et er es lr ls bd b be z dx translated">一个包含两个组件的层次结构——一个“父”通过它的属性控制一些(“子”)文本。</figcaption></figure></div><div class="ab cl lt lu gp lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="hb hc hd he hf"><h2 id="9d43" class="jg jh hi bd ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc ho bi translated">反应摘要</h2><p id="2e5f" class="pw-post-body-paragraph kd ke hi kf b kg kh is ki kj kk iv kl jr km kn ko jv kp kq kr jz ks kt ku kv hb bi translated">因此，现在我们有了完整的画面:<em class="kx"> React </em>中的<br/>，整个 UI 是由多个<em class="kx">组件</em>以单向层次结构构建的，其中最顶层的<em class="kx">组件</em>，例如一个完整的<em class="kx">屏幕</em>，包含了它的整个<em class="kx">状态</em>，并将派生的<em class="kx">道具</em>传递给它的“孩子”(更小的 UI 元素)，以控制它们<em class="kx">呈现的内容</em>。<br/>那些‘孩子’可以更新他们的‘父母’的一些变化(通过<em class="kx">回调</em>)，在这种情况下‘父母’可以更新其<em class="kx"> ownState </em>，导致整个层级(从该父及以下)重新<em class="kx">呈现</em>。</p><p id="8599" class="pw-post-body-paragraph kd ke hi kf b kg ky is ki kj kz iv kl jr la kn ko jv lb kq kr jz lc kt ku kv hb bi translated">稍后，我会告诉你为什么<code class="du mt mu mv mw b">ownState</code>应该很少被使用(<em class="kx"> Redux </em>用于营救)，所以，我们基本上只需要记住两个模型——<em class="kx">组件</em>和<em class="kx">道具</em>😉这有多简单？！</p><blockquote class="mx"><p id="b8af" class="my mz hi bd na nb nc nd ne nf ng kv dx translated">一个组件可以被看作一个(无状态的)数学函数，有一个输入(Props)和一个输出(UI)，没有副作用。UI 架构中的函数式编程</p></blockquote></div><div class="ab cl lt lu gp lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="hb hc hd he hf"><h2 id="6d95" class="jg jh hi bd ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc ho bi translated">Redux 方法</h2><p id="08e4" class="pw-post-body-paragraph kd ke hi kf b kg kh is ki kj kk iv kl jr km kn ko jv kp kq kr jz ks kt ku kv hb bi translated"><em class="kx"> React </em>是一个 UI 架构，定义了 UI 组件如何相互通信，<em class="kx"> Redux </em>是一个<em class="kx">全局状态，</em> <a class="ae kw" rel="noopener" href="/swlh/understanding-flux-architecture-9060e5a0399c"> <em class="kx"> Flux </em> </a>架构，管理整个 app 的整个<em class="kx">状态</em>。从根本上说，它与 UI 没有任何关系——除非我们创建了绑定。</p><p id="3c4c" class="pw-post-body-paragraph kd ke hi kf b kg ky is ki kj kz iv kl jr la kn ko jv lb kq kr jz lc kt ku kv hb bi translated"><em class="kx"> React-Redux </em>背后的想法是，取代(必然性)让 UI 组件“包含”它们之间的应用程序的<em class="kx">状态</em>，我们通过一个独立于 UI 的模型(<em class="kx"> GlobalState Object </em>)来分离关注点。例如，这意味着当您使用一些<em class="kx"> API </em>从<em class="kx">获取</em>一些<em class="kx">数据</em>时，这些数据会被保存到<em class="kx">全局状态</em>，而不是保存到<em class="kx">组件的内部(自己)<em class="kx">状态</em>。</em></p><p id="cfb4" class="pw-post-body-paragraph kd ke hi kf b kg ky is ki kj kz iv kl jr la kn ko jv lb kq kr jz lc kt ku kv hb bi translated"><em class="kx">全局状态对象</em>由<em class="kx">存储</em>持有。没什么特别的:</p><figure class="le lf lg lh fd li"><div class="bz dy l di"><div class="mr ms l"/></div><figcaption class="lp lq et er es lr ls bd b be z dx translated">简化的 Redux 存储，保存 GlobalState 对象。在科特林</figcaption></figure></div><div class="ab cl lt lu gp lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="hb hc hd he hf"><h2 id="c0eb" class="jg jh hi bd ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc ho bi translated">全球国家</h2><p id="fba6" class="pw-post-body-paragraph kd ke hi kf b kg kh is ki kj kk iv kl jr km kn ko jv kp kq kr jz ks kt ku kv hb bi translated">所以<em class="kx">全局状态</em>只是一个(巨大的)<em class="kx">对象</em>。你可以把它想象成一个<code class="du mt mu mv mw b">HashMap&lt;String, Object/Any?&gt;</code>，<em class="kx">把状态</em>‘keys’(<code class="du mt mu mv mw b">String</code>)映射到(任何类型，<em class="kx">可空的</em>)值。</p><p id="1af1" class="pw-post-body-paragraph kd ke hi kf b kg ky is ki kj kz iv kl jr la kn ko jv lb kq kr jz lc kt ku kv hb bi translated"><em class="kx">全局状态</em>的流程非常简单，它只是利用了围绕<em class="kx">道具的<em class="kx">反应</em>逻辑— </em>每当<em class="kx">全局状态</em>改变时，所有监听(<em class="kx">连接</em> ) <em class="kx">组件</em>得到通知，计算/派生/ <em class="kx">从新的<em class="kx">全局状态</em>减少</em>它们的<em class="kx">道具</em>，如果它们的新<em class="kx">道具</em></p><p id="cd4a" class="pw-post-body-paragraph kd ke hi kf b kg ky is ki kj kz iv kl jr la kn ko jv lb kq kr jz lc kt ku kv hb bi translated">是的，你说得没错——每次发生<strong class="kf hs">任何事情</strong>发生变化，应用程序中的<strong class="kf hs">任何地方</strong>(<em class="kx">全局状态</em>)——<strong class="kf hs">所有</strong>相关的<em class="kx">组件</em>，可能是所有组件——re<em class="kx">——render</em>😱🤯😱🤯😱🤯。是啊…别担心。</p><figure class="le lf lg lh fd li"><div class="bz dy l di"><div class="mr ms l"/></div><figcaption class="lp lq et er es lr ls bd b be z dx translated">简化的全球状态模型，在科特林。只是一张带有字符串键的地图。</figcaption></figure><p id="78a6" class="pw-post-body-paragraph kd ke hi kf b kg ky is ki kj kz iv kl jr la kn ko jv lb kq kr jz lc kt ku kv hb bi translated">有了<em class="kx"> Redux </em>，<em class="kx">组件</em>的<em class="kx"> Props </em>通常是直接从<em class="kx">global state</em>——它保存着 app 的<em class="kx">数据/缓存</em>——而不是从它们的父<em class="kx"> ownState </em>中派生出来的。<strong class="kf hs">省略了使用<em class="kx"> ownState 的需要。</em>T51】</strong></p><p id="d670" class="pw-post-body-paragraph kd ke hi kf b kg ky is ki kj kz iv kl jr la kn ko jv lb kq kr jz lc kt ku kv hb bi translated">下面是上面的<strong class="kf hs">父节点和文本子节点</strong>的例子如何使用<em class="kx"> Redux 存储</em>，而不是父节点的<em class="kx"> ownState </em>来控制文本:</p><figure class="le lf lg lh fd li"><div class="bz dy l di"><div class="mr ms l"/></div><figcaption class="lp lq et er es lr ls bd b be z dx translated">由两个组件组成的层次结构——一个“父级”和一些(“子级”)文本——派生自全局状态。</figcaption></figure><p id="8451" class="pw-post-body-paragraph kd ke hi kf b kg ky is ki kj kz iv kl jr la kn ko jv lb kq kr jz lc kt ku kv hb bi translated">现在我们有了。<em class="kx"> React Redux </em>在行动。最少的 UI 代码，没有逻辑代码。关注点分离。</p></div><div class="ab cl lt lu gp lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="hb hc hd he hf"><h2 id="6f46" class="jg jh hi bd ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc ho bi translated">冗余摘要</h2><p id="bf34" class="pw-post-body-paragraph kd ke hi kf b kg kh is ki kj kk iv kl jr km kn ko jv kp kq kr jz ks kt ku kv hb bi translated">我们将在下一篇文章中更深入地研究<em class="kx">Redux</em>——因为尽管它非常简单，而且只是<em class="kx">反应式编程</em>的术语，但在开始时它可能会让人不知所措。总体思路如上所述——一个<em class="kx">全局状态</em>，其中<em class="kx">组件</em>可以更新(例如，由于一些<em class="kx">按钮点击</em>或<em class="kx">文本输入</em>)——这又通知回所有(监听<em class="kx">/连接的】</em> <em class="kx">组件</em>，导致它们中的一些/全部/没有一个重新<em class="kx">——渲染</em></p></div><div class="ab cl lt lu gp lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="hb hc hd he hf"><h2 id="3cce" class="jg jh hi bd ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc ho bi translated">React-Redux，组合</h2><p id="fd08" class="pw-post-body-paragraph kd ke hi kf b kg kh is ki kj kk iv kl jr km kn ko jv kp kq kr jz ks kt ku kv hb bi translated"><em class="kx"> Redux </em>方法，与<em class="kx"> React </em>方法一起，形成了一个<em class="kx"> MVI </em>式的架构，它能够完成伟大的事情。</p><p id="dedb" class="pw-post-body-paragraph kd ke hi kf b kg ky is ki kj kz iv kl jr la kn ko jv lb kq kr jz lc kt ku kv hb bi translated">想想其中的含义:</p><ul class=""><li id="374a" class="nh ni hi kf b kg ky kj kz jr nj jv nk jz nl kv nm nn no np bi translated">不是一次又一次地在屏幕(<em class="kx">活动、片段、视图</em>)之间传递和<em class="kx">序列化</em>数据，它只是存在于全局范围内(并通过<em class="kx">道具</em>，在<em class="kx">组件的渲染</em>内自动提供给你)。</li><li id="71f1" class="nh ni hi kf b kg nq kj nr jr ns jv nt jz nu kv nm nn no np bi translated">这也意味着你不再关心<em class="kx">在屏幕旋转之间保持</em>一个<em class="kx">活动</em>的状态——反正状态已经在全局范围内保存了。</li><li id="4104" class="nh ni hi kf b kg nq kj nr jr ns jv nt jz nu kv nm nn no np bi translated">这意味着你不需要复杂的缓存机制(数据库)<em class="kx">数据</em>—<em class="kx">数据</em>(一旦加载)只是出现在全局状态中。</li><li id="a813" class="nh ni hi kf b kg nq kj nr jr ns jv nt jz nu kv nm nn no np bi translated">这意味着你可以在应用关闭时保存全局状态，甚至在登录时从服务器发送序列化的状态，整个应用立即处于你想要的状态，包括哪个屏幕打开，什么文本放在哪里，甚至列表的滚动位置。</li><li id="90be" class="nh ni hi kf b kg nq kj nr jr ns jv nt jz nu kv nm nn no np bi translated">您可以很容易地测试任何可能的 UI 状态，而不需要手动/编程地做任何动作来“到达那里”——您只需要注入一个特定的状态来表示您想要看到的 UI。它是<em class="kx">确定性的</em>——相同的状态将总是呈现相同的 UI。</li><li id="342e" class="nh ni hi kf b kg nq kj nr jr ns jv nt jz nu kv nm nn no np bi translated">不再有“此文本在哪里更新？”，或者“如果在此之前点击会发生什么？”问题类型——所有 UI 都放在一个方法中，每次都以完全相同的方式、完全相同的顺序执行。</li><li id="d83a" class="nh ni hi kf b kg nq kj nr jr ns jv nt jz nu kv nm nn no np bi translated">由于应用程序的状态是全局的，多个 UI 元素可以并且应该在同一状态下同步。所以不需要在同一个屏幕的两个元素之间直接通信，也不需要在不同屏幕的两个元素之间(！).例如，您可以在应用程序的<em class="kx">设置页面</em>中更改应用程序的调色板——使用全局状态——整个应用程序中的所有 UI 元素(例如 back-stack <em class="kx"> Activities </em>)会立即更新以反映这一点。无需自定义代码。</li></ul><p id="9cd2" class="pw-post-body-paragraph kd ke hi kf b kg ky is ki kj kz iv kl jr la kn ko jv lb kq kr jz lc kt ku kv hb bi translated">我的意思是，既然你知道所有这些(以及更多)都是可能的，你还能回到你的 Android 项目吗？我知道我不能。</p><blockquote class="ml mm mn"><p id="eecf" class="kd ke kx kf b kg ky is ki kj kz iv kl mo la kn ko mp lb kq kr mq lc kt ku kv hb bi translated">我向你保证，这一切只是冰山一角。这只是你通过使用<em class="hi">反应-还原</em>方法获得的直接利益的一部分。等着看<a class="ae kw" href="https://github.com/GuyMichael/Reactdroid" rel="noopener ugc nofollow" target="_blank"> <em class="hi"> Reactdroid </em> </a>和<a class="ae kw" href="https://github.com/GuyMichael/ReactdroidApp" rel="noopener ugc nofollow" target="_blank"><em class="hi">react droid app</em></a>库能做什么吧。</p></blockquote></div><div class="ab cl lt lu gp lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="hb hc hd he hf"><h1 id="934f" class="ma jh hi bd ji mb mc md jm me mf mg jq ix mh iy ju ja mi jb jy jd mj je kc mk bi translated">摘要</h1><p id="668d" class="pw-post-body-paragraph kd ke hi kf b kg kh is ki kj kk iv kl jr km kn ko jv kp kq kr jz ks kt ku kv hb bi translated">这篇文章是关于<em class="kx"> React-Redux </em>，一个基于<em class="kx">组件</em>、<em class="kx"> MVI </em> <em class="kx"> Flux </em>的应用程序开发方法——还有一个提示——它可以在<em class="kx"> Kotlin </em>中完成，对于真正的原生移动开发，甚至可以在<a class="ae kw" href="https://blog.jetbrains.com/kotlin/2020/08/kotlin-multiplatform-mobile-goes-alpha/#:~:text=Kotlin%20Multiplatform%20Mobile%20(KMM)%20is,both%20iOS%20and%20Android%20applications.&amp;text=It%20includes%20the%20new%20KMM,code%20in%20the%20same%20IDE." rel="noopener ugc nofollow" target="_blank"> <em class="kx">多平台</em> </a>中完成。我希望你学到了一些东西。我希望它让你看到了可能性。<br/>请在下面留下您的评论和/或问题。</p><p id="2e72" class="pw-post-body-paragraph kd ke hi kf b kg ky is ki kj kz iv kl jr la kn ko jv lb kq kr jz lc kt ku kv hb bi translated">所以…这就是<em class="kx">什么</em>。在<a class="ae kw" href="https://link.medium.com/llMGhOzt0eb" rel="noopener">下一篇</a>中，最后我们会谈到<em class="kx">如何— </em>如何能在<em class="kx">科特林</em>中实现，从基础开始；以及如何使用它(例如在<em class="kx"> Android </em>中)会是什么样子。<a class="ae kw" href="https://link.medium.com/llMGhOzt0eb" rel="noopener">这里是</a>。</p></div></div>    
</body>
</html>