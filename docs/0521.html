<html>
<head>
<title>How to get unique values in an Elm list</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在 Elm 列表中获得唯一值</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/how-to-get-unique-values-in-an-elm-list-d91ec7dfd0e?source=collection_archive---------1-----------------------#2021-01-08">https://medium.com/nerd-for-tech/how-to-get-unique-values-in-an-elm-list-d91ec7dfd0e?source=collection_archive---------1-----------------------#2021-01-08</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="5fbf" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">你这样做:</p><pre class="jd je jf jg fd jh ji jj jk aw jl bi"><span id="0e02" class="jm jn hi ji b fi jo jp l jq jr">unique : List a -&gt; List a<br/>unique l = <br/>    let<br/>        incUnique : a -&gt; List a -&gt; List a<br/>        incUnique elem lst = <br/>            case List.member elem lst of<br/>                True -&gt; lst<br/>               False -&gt; elem :: lst<br/>    in<br/>        List.foldr incUnique [] l</span></pre><p id="cc2f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">给你。玩得开心！</p></div><div class="ab cl js jt gp ju" role="separator"><span class="jv bw bk jw jx jy"/><span class="jv bw bk jw jx jy"/><span class="jv bw bk jw jx"/></div><div class="hb hc hd he hf"><p id="702b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">哦，还在这里？让我们看看这是怎么回事。</p><p id="95e8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">所以，你在 Elm 中有一个列表，你想得到其中唯一的值。也没有办法编写一个简单的命令式循环来遍历列表。列表。折叠救援。我们有两种折叠方式可以使用:<em class="jz"> foldl </em>(向左折叠)和<em class="jz"> foldr </em>(折叠……你可以想出来)。左边和右边是指操作的结合性。</p><p id="caa6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">假设你有列表[2，2，3，4]。如果您折叠列表，这意味着您将检查列表中的两个项目，并应用一些功能，例如，使用+操作折叠此列表将得到:</p><pre class="jd je jf jg fd jh ji jj jk aw jl bi"><span id="e07e" class="jm jn hi ji b fi jo jp l jq jr">( 2 + ( 2 + ( 3 + ( 4 ) ) ) )</span></pre><figure class="jd je jf jg fd kb er es paragraph-image"><div class="er es ka"><img src="../Images/cb7cae55c2b93c6d69655e4be23e8632.png" data-original-src="https://miro.medium.com/v2/resize:fit:672/format:webp/1*mILUsEgxtpEsZqpjKDKbZA.png"/></div></figure><p id="7ab2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">顺便说一下，这是右结合律，所以我做了一个 foldr。看着图表，我们可以更清楚地看到发生了什么。在那里，我们的函数<em class="jz"> f </em>是<em class="jz"> + </em>操作，我们的种子是<em class="jz"> 0 </em>。</p><p id="2a16" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">文件夹将如下所示:</p><pre class="jd je jf jg fd jh ji jj jk aw jl bi"><span id="fe11" class="jm jn hi ji b fi jo jp l jq jr">( ( ( ( 2 ) + 2 ) + 3 ) + 4 )</span></pre><p id="659a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在 Elm 中，我们有<em class="jz"> List.foldl </em>和<em class="jz"> List.foldr </em>。除了要应用的函数和列表之外，我们还必须提供一个种子值来应用于列表的第一个元素，例如，如果我们的种子是 0，我们将有一个如下所示的 foldr:</p><pre class="jd je jf jg fd jh ji jj jk aw jl bi"><span id="4538" class="jm jn hi ji b fi jo jp l jq jr">( 2 + ( 2 + ( 3 + ( 4 + 0) ) ) )</span></pre><p id="68eb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这就是折叠的工作原理。我们可以用它来进行更高级的数据结构遍历，但是在这里我们只使用它来查找唯一值。我们将从一个空列表(我们的种子)开始，检查原始列表中的元素是否在这个新列表中。如果是，我们什么也不做。如果不是，我们将它们添加到那个列表中(或者说，我们用那个列表的元素加上新元素创建一个新列表，因为在 Elm land 中没有可变性)。</p><p id="c39d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们定义我们的功能:</p><pre class="jd je jf jg fd jh ji jj jk aw jl bi"><span id="87a2" class="jm jn hi ji b fi jo jp l jq jr">incUnique : a -&gt; List a -&gt; List a<br/>incUnique elem lst =<br/> case List.member elem lst of<br/> True -&gt; lst<br/> False -&gt; elem :: lst</span></pre><p id="b33a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这个函数接收一个列表元素和一个列表。如果该元素是该列表的成员，则返回该列表。如果不是，它返回一个新的列表，包含接收列表的所有元素加上接收的元素。然后我们用这个函数折叠。</p><pre class="jd je jf jg fd jh ji jj jk aw jl bi"><span id="79a2" class="jm jn hi ji b fi jo jp l jq jr">someList = [ 2, 2, 3, 4]<br/>List.foldr incUnique [] someList</span></pre><p id="4aae" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">事情是这样的</p><pre class="jd je jf jg fd jh ji jj jk aw jl bi"><span id="de84" class="jm jn hi ji b fi jo jp l jq jr">( incUnique 2 ( incUnique 2 ( incUnique 3 ( incUnique 4 [] ) ) ) )<br/>( incUnique 2 ( incUnique 2 ( incUnique 3 [4] ) ) )<br/>( incUnique 2 ( incUnique 2 [3, 4] ) )<br/>( incUnique 2 [2, 3, 4] )<br/>( [2, 3, 4] )</span></pre><p id="6a0a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">看，我们从右边开始折叠。如果我们从左边折叠呢？</p><pre class="jd je jf jg fd jh ji jj jk aw jl bi"><span id="ad24" class="jm jn hi ji b fi jo jp l jq jr">( incUnique 4 ( incUnique 3 ( incUnique 2 ( incUnique 2 [] ) ) ) )<br/>( incUnique 4 ( incUnique 3 ( incUnique 2 [2] ) ) )<br/>( incUnique 4 ( incUnique 3 [2] ) )<br/>( incUnique 4 [3, 2] )<br/>( [4, 3, 2] )</span></pre><p id="0087" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">不太清楚我们从左边折叠，因为列表元素总是函数的左操作数。这导致列表在表达式中看起来颠倒了。事实证明，我们的最终结果也反转了原始列表，删除了重复的列表。这是因为我们的函数<em class="jz"> incUnique </em>在列表的前面添加了新元素。如果它被添加到列表的后面，<em class="jz"> foldr </em>将反转列表，<em class="jz"> foldl </em>将保持顺序。回到上图，想象一下左折会是什么样子。</p><p id="7663" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">将所有这些放在一起:</p><pre class="jd je jf jg fd jh ji jj jk aw jl bi"><span id="cda9" class="jm jn hi ji b fi jo jp l jq jr">unique : List a -&gt; List a<br/>unique l = <br/>    let<br/>        incUnique : a -&gt; List a -&gt; List a<br/>        incUnique elem lst = <br/>            case List.member elem lst of<br/>                True -&gt; lst<br/>                False -&gt; elem :: lst<br/>    in<br/>        List.foldr incUnique [] l</span></pre></div></div>    
</body>
</html>