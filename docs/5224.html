<html>
<head>
<title>Basics of Unit Testing In React</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">React 中单元测试的基础</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/basics-of-unit-testing-in-react-e38b7ed3be1b?source=collection_archive---------7-----------------------#2021-09-09">https://medium.com/nerd-for-tech/basics-of-unit-testing-in-react-e38b7ed3be1b?source=collection_archive---------7-----------------------#2021-09-09</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/cda5f6f6ff6f44e5df7a7ded0226c793.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WuyH7VrluEqPmbWTkXF8JQ.png"/></div></div></figure><p id="221a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">大家好，这次我带来了另一篇关于 React 中单元测试基础的文章。所以不浪费任何时间，让我们从单元测试的基础开始。</p><p id="1c76" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">测试</strong>是执行程序的过程，目的是发现错误。</p><p id="5d91" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">通常测试分为三类。</p><ul class=""><li id="5d83" class="jo jp hi is b it iu ix iy jb jq jf jr jj js jn jt ju jv jw bi translated">功能测试</li><li id="6156" class="jo jp hi is b it jx ix jy jb jz jf ka jj kb jn jt ju jv jw bi translated">非功能测试或性能测试</li><li id="4735" class="jo jp hi is b it jx ix jy jb jz jf ka jj kb jn jt ju jv jw bi translated">维护(回归和维护)</li></ul><p id="e352" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">今天的话题属于功能测试。</p><p id="e1fd" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">让我们从定义什么是<strong class="is hj">单元测试</strong>开始:</p><blockquote class="kc kd ke"><p id="dae0" class="iq ir kf is b it iu iv iw ix iy iz ja kg jc jd je kh jg jh ji ki jk jl jm jn hb bi translated">单元测试软件测试的一种类型，对软件的单个单元或组件进行测试。目的是验证软件代码的<strong class="is hj">每个单元</strong>是否按预期执行。</p></blockquote><p id="ac02" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">单元测试由<strong class="is hj">开发人员</strong>在应用程序的开发(编码阶段)</strong>期间完成。单元测试隔离一段代码并验证其正确性。单元可以是单独的函数、方法、过程、模块或对象。</p><p id="b94b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">为了执行单元测试，我们需要编写测试用例，所以你可能会问什么是测试用例。</p><blockquote class="kc kd ke"><p id="7537" class="iq ir kf is b it iu iv iw ix iy iz ja kg jc jd je kh jg jh ji ki jk jl jm jn hb bi translated"><strong class="is hj">测试用例</strong>是一组条件或变量，在这些条件或变量下，测试人员将确定被测系统是否满足需求或正常工作。</p></blockquote><p id="7d20" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们必须在<strong class="is hj">测试套件</strong>中包装我们的测试用例。</p><blockquote class="kc kd ke"><p id="dd18" class="iq ir kf is b it iu iv iw ix iy iz ja kg jc jd je kh jg jh ji ki jk jl jm jn hb bi translated">一个测试套件，通常称为“验证套件”，是一个测试用例的集合，旨在用于测试一个软件程序，以显示它具有一些指定的行为集。</p></blockquote><p id="27c3" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在我们该谈谈<strong class="is hj">断言</strong>，断言用于验证<strong class="is hj">测试用例</strong>并帮助我们了解<strong class="is hj">测试用例</strong>是通过还是失败。</p><p id="c728" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在让我们试着理解为什么我们要使用 TDD( <strong class="is hj">测试驱动开发</strong>)来创建一个 React.js 组件？</p><p id="4b8b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">TDD 给我们的代码带来了许多好处——高测试覆盖率的一个好处是，它支持简单的代码重构，同时保持代码的整洁和功能性。</p><p id="0c06" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如果您以前创建过 React.js 组件，那么您会意识到代码增长非常快。它填充了许多由与状态变化和服务调用相关的语句引起的复杂条件。</p><p id="371f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">每个缺少单元测试的组件都有遗留的代码，这些代码变得难以维护。</p><h1 id="f034" class="kj kk hi bd kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg bi translated">我们如何对 React.js 组件进行单元测试？</h1><p id="ecb4" class="pw-post-body-paragraph iq ir hi is b it lh iv iw ix li iz ja jb lj jd je jf lk jh ji jj ll jl jm jn hb bi translated">我们可以使用许多策略来测试 React.js 组件:</p><ul class=""><li id="aef8" class="jo jp hi is b it iu ix iy jb jq jf jr jj js jn jt ju jv jw bi translated">我们可以验证当某个事件被调度时，我们的<code class="du lm ln lo lp b">props</code>中的特定函数被调用。</li><li id="c17a" class="jo jp hi is b it jx ix jy jb jz jf ka jj kb jn jt ju jv jw bi translated">我们还可以在给定当前组件状态的情况下获得<code class="du lm ln lo lp b">render</code>函数的结果，并将其与预定义的布局进行匹配。</li><li id="4728" class="jo jp hi is b it jx ix jy jb jz jf ka jj kb jn jt ju jv jw bi translated">我们甚至可以检查组件的子组件数量是否与预期数量相匹配。</li></ul><p id="5b7c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">为了使用这些策略，我们将使用两个方便的工具在 React.js 中进行测试:<a class="ae lq" href="https://facebook.github.io/jest/" rel="noopener ugc nofollow" target="_blank"> Jest </a>和<a class="ae lq" href="https://github.com/airbnb/enzyme" rel="noopener ugc nofollow" target="_blank"> Enzyme </a>。</p><h1 id="62b9" class="kj kk hi bd kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg bi translated">使用 Jest 创建单元测试</h1><p id="bd03" class="pw-post-body-paragraph iq ir hi is b it lh iv iw ix li iz ja jb lj jd je jf lk jh ji jj ll jl jm jn hb bi translated">Jest 是由脸书创建的开源测试框架，与 React.js 有很好的集成。它包括一个用于测试执行的命令行工具，类似于 Jasmine 和 Mocha 提供的工具。</p><p id="470f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">它还允许我们用几乎为零的配置创建模拟函数，并提供了一组非常好的匹配器，使得断言更容易阅读。</p><p id="f00e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">此外，它提供了一个非常好的特性，叫做“快照测试”，帮助我们检查和验证组件渲染结果。</p><p id="5b69" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在让我们开始写一些代码来理解如何测试我们的组件。</p><p id="1eca" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">使用断言</strong></p><pre class="lr ls lt lu fd lv lp lw lx aw ly bi"><span id="0aac" class="lz kk hi lp b fi ma mb l mc md">var assert = require(‘assert’);</span><span id="de88" class="lz kk hi lp b fi me mb l mc md">describe(‘Basic Mocha String Test’, function (){</span><span id="ab5e" class="lz kk hi lp b fi me mb l mc md">it(‘should return number of characters in a<br/>string’, function () {<br/>assert.equal(“Hello”.length, 4);<br/>});</span><span id="0183" class="lz kk hi lp b fi me mb l mc md">it(‘should return first character of the string’,function () {<br/>assert.equal(“Hello”.charAt(0),‘H’);<br/>});</span><span id="1696" class="lz kk hi lp b fi me mb l mc md">});</span></pre><p id="139e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">让我们试着理解上面的代码试图做什么:-</p><p id="8401" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">断言</strong>有助于确定测试的状态。<br/> <strong class="is hj">描述</strong>是一个保存测试集合的函数。它有两个参数，第一个是被测功能的有意义的名称，第二个是包含一个或多个测试的函数。我们也可以嵌套 describe。<br/> <strong class="is hj"> IT </strong>也是一个函数，它实际上是一个测试本身，有两个参数，第一个参数是测试的名称，第二个参数是保存测试主体的函数。</p><p id="2582" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">有时我们在组件中使用第三方库，当我们试图运行我们的测试用例时，它不起作用，因为我们的测试库不知道那个库。对于这样的场景，我们可以使用 jest 创建模拟函数。</p><p id="845a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">模拟函数也被称为“间谍”，因为它们让您可以窥探被其他代码间接调用的函数的行为，而不仅仅是测试输出。</p><p id="aaa5" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">让我们假设我们正在测试一个函数<code class="du lm ln lo lp b">forEach</code>的实现，该函数为所提供的数组中的每一项调用一个回调。</p><pre class="lr ls lt lu fd lv lp lw lx aw ly bi"><span id="0446" class="lz kk hi lp b fi ma mb l mc md">function forEach(items, callback) {<br/>for (let index = 0; index &lt; items.length; index++) {<br/>callback(items[index]);<br/>}<br/>}</span></pre><p id="86c3" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">为了测试这个函数，我们可以使用一个模拟函数，并检查模拟函数的状态，以确保回调按预期被调用。</p><pre class="lr ls lt lu fd lv lp lw lx aw ly bi"><span id="c279" class="lz kk hi lp b fi ma mb l mc md">const mockCallback = jest.fn(x =&gt; 42 + x);</span><span id="335b" class="lz kk hi lp b fi me mb l mc md">forEach([0, 1], mockCallback);</span><span id="6a7d" class="lz kk hi lp b fi me mb l mc md"><em class="kf">// The mock function is called twice</em></span><span id="429f" class="lz kk hi lp b fi me mb l mc md">expect(mockCallback.mock.calls.length).toBe(2);</span><span id="7a9d" class="lz kk hi lp b fi me mb l mc md"><em class="kf">// The first argument of the first call to the function was 0</em></span><span id="c544" class="lz kk hi lp b fi me mb l mc md">expect(mockCallback.mock.calls[0][0]).toBe(0);</span><span id="f226" class="lz kk hi lp b fi me mb l mc md"><em class="kf">// The first argument of the second call to the function was 1</em></span><span id="dda7" class="lz kk hi lp b fi me mb l mc md">expect(mockCallback.mock.calls[1][0]).toBe(1);</span><span id="b45b" class="lz kk hi lp b fi me mb l mc md"><em class="kf">// The return value of the first call to the function was 42</em></span><span id="e5f1" class="lz kk hi lp b fi me mb l mc md">expect(mockCallback.mock.results[0].value).toBe(42);</span></pre><p id="1872" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">。模拟</strong>属性:-所有模拟函数都有这个特殊的<strong class="is hj">。mock </strong>属性，它保存了关于函数如何被调用以及函数返回了什么的数据。</p><p id="22ab" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">正如我所说的，我们也可以模仿第三方模块，这里有一个例子</p><pre class="lr ls lt lu fd lv lp lw lx aw ly bi"><span id="fe4a" class="lz kk hi lp b fi ma mb l mc md">jest.mock('axios');</span><span id="e4f2" class="lz kk hi lp b fi me mb l mc md">test('should fetch users', () =&gt; {</span><span id="ee90" class="lz kk hi lp b fi me mb l mc md">const users = [{name: 'Bob'}];</span><span id="4fe8" class="lz kk hi lp b fi me mb l mc md">const response = {data: users};</span><span id="7170" class="lz kk hi lp b fi me mb l mc md">axios.get.mockResolvedValue(response);</span><span id="3bc9" class="lz kk hi lp b fi me mb l mc md"><em class="kf">// or you could use the following depending on your use case:</em></span><span id="c47b" class="lz kk hi lp b fi me mb l mc md"><em class="kf">// axios.get.mockImplementation(() =&gt; Promise.resolve(</em>response<em class="kf">))</em></span><span id="6866" class="lz kk hi lp b fi me mb l mc md">return Users.all().then(data =&gt; expect(data).toEqual(users));</span><span id="22dd" class="lz kk hi lp b fi me mb l mc md">});</span></pre><h1 id="de3c" class="kj kk hi bd kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg bi translated">使用酶挂载 React.js 组件</h1><p id="f67f" class="pw-post-body-paragraph iq ir hi is b it lh iv iw ix li iz ja jb lj jd je jf lk jh ji jj ll jl jm jn hb bi translated">Enzyme 提供了一种挂载和遍历 React.js 组件树的机制。这将帮助我们访问它自己的属性和状态以及它的子属性，以便运行我们的断言。</p><p id="16e8" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">Enzyme 为元件安装提供了两个基本功能:<code class="du lm ln lo lp b">shallow</code>和<code class="du lm ln lo lp b">mount</code>。<code class="du lm ln lo lp b">shallow</code>函数只在内存中加载根组件，而<code class="du lm ln lo lp b">mount</code>加载整个 DOM 树。</p><p id="c657" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">enzyme 是 React 的一个 JavaScript 测试工具，它使测试 React 组件的输出变得更加容易。用于完整 DOM 呈现的 mount( <Component/>)非常适合这样的用例，其中您的组件可能会与 DOM APIs 交互，或者可能需要完整的生命周期来全面测试<br/>组件(即 componentDidMount 等)。)</p><p id="87b5" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">Mount 是测试 componentDidMount 和 componentDidUpdate 的唯一方法。包括子组件的完整渲染。需要一个 DOM (JSdom)。</p><p id="67b6" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">用于浅层渲染的<strong class="is hj">Shallow</strong>(&lt;Component/&gt;)对于约束自己将一个组件作为一个单元进行测试，并确保您的测试不会间接断言子组件的行为是非常有用的。</p><h1 id="28a8" class="kj kk hi bd kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg bi translated">简单的浅层</h1><p id="6869" class="pw-post-body-paragraph iq ir hi is b it lh iv iw ix li iz ja jb lj jd je jf lk jh ji jj ll jl jm jn hb bi translated">通话:</p><ul class=""><li id="7a72" class="jo jp hi is b it iu ix iy jb jq jf jr jj js jn jt ju jv jw bi translated">构造器</li><li id="f28b" class="jo jp hi is b it jx ix jy jb jz jf ka jj kb jn jt ju jv jw bi translated">提供；给予</li></ul><h1 id="077a" class="kj kk hi bd kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg bi translated">浅+深</h1><p id="cff6" class="pw-post-body-paragraph iq ir hi is b it lh iv iw ix li iz ja jb lj jd je jf lk jh ji jj ll jl jm jn hb bi translated">通话:</p><ul class=""><li id="2e45" class="jo jp hi is b it iu ix iy jb jq jf jr jj js jn jt ju jv jw bi translated">componentWillReceiveProps</li><li id="3424" class="jo jp hi is b it jx ix jy jb jz jf ka jj kb jn jt ju jv jw bi translated">shouldComponentUpdate</li><li id="227f" class="jo jp hi is b it jx ix jy jb jz jf ka jj kb jn jt ju jv jw bi translated">组件将更新</li><li id="7b5c" class="jo jp hi is b it jx ix jy jb jz jf ka jj kb jn jt ju jv jw bi translated">提供；给予</li></ul><h1 id="ce5f" class="kj kk hi bd kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg bi translated">浅层+卸载</h1><p id="81ae" class="pw-post-body-paragraph iq ir hi is b it lh iv iw ix li iz ja jb lj jd je jf lk jh ji jj ll jl jm jn hb bi translated">通话:</p><ul class=""><li id="9123" class="jo jp hi is b it iu ix iy jb jq jf jr jj js jn jt ju jv jw bi translated">组件将卸载</li></ul><blockquote class="kc kd ke"><p id="18cb" class="iq ir kf is b it iu iv iw ix iy iz ja kg jc jd je kh jg jh ji ki jk jl jm jn hb bi translated">浅层的例子:-</p></blockquote><p id="1b5d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">基本示例</strong></p><pre class="lr ls lt lu fd lv lp lw lx aw ly bi"><span id="4bb2" class="lz kk hi lp b fi ma mb l mc md">it('should render three &lt;Foo /&gt; components', () =&gt; {<br/> const wrapper = shallow(&lt;MyComponent /&gt;);<br/> expect(wrapper.find(Foo)).to.have.length(3);<br/> });</span></pre><p id="26a1" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">传递子组件时渲染子组件</strong></p><pre class="lr ls lt lu fd lv lp lw lx aw ly bi"><span id="2bec" class="lz kk hi lp b fi ma mb l mc md">it('should render children when passed in', () =&gt; {<br/> const wrapper = shallow(<br/>  &lt;MyComponent&gt;<br/>    &lt;div className="unique" /&gt;<br/>  &lt;/MyComponent&gt;<br/>  );<br/> expect(wrapper.contains(&lt;div className="unique" /&gt;)).to.be.true;<br/> });</span></pre><p id="21e3" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">刺激的咔哒声:- </strong></p><pre class="lr ls lt lu fd lv lp lw lx aw ly bi"><span id="1ec0" class="lz kk hi lp b fi ma mb l mc md">it('simulates click events', () =&gt; {<br/> const onButtonClick = sinon.spy();<br/> const wrapper = shallow(<br/> &lt;Foo onButtonClick={onButtonClick} /&gt;<br/> );<br/> wrapper.find('button').simulate('click');<br/> expect(onButtonClick.calledOnce).to.be.true;<br/> });</span></pre><p id="e18a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在我们来说说<strong class="is hj"> SPY </strong>，一个测试 SPY 就是<strong class="is hj">为它所有的<a class="ae lq" href="https://sinonjs.org/releases/latest/spy-call" rel="noopener ugc nofollow" target="_blank">调用</a>记录参数、返回值、</strong> <code class="du lm ln lo lp b"><strong class="is hj">this</strong></code> <strong class="is hj">的值以及抛出的异常(如果有的话)</strong>的函数。有两种类型的间谍:一些是匿名函数，而另一些包装测试系统中已经存在的方法。</p><p id="2470" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">sinon.spy(object，“method”)创建一个封装现有函数的 spy。</p><p id="699d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">例子</p><p id="2e21" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们可以检查一个函数被调用了多少次</p><pre class="lr ls lt lu fd lv lp lw lx aw ly bi"><span id="90a0" class="lz kk hi lp b fi ma mb l mc md">it('should call save once', function() {   <br/> let save = sinon.spy(Database, 'save');<br/> setupNewUser({ name: 'test' }, function() { });    <br/> save.restore();   <br/> sinon.assert.calledOnce(save); <br/>});</span></pre><p id="2773" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们可以检查传递给函数的参数是什么</p><pre class="lr ls lt lu fd lv lp lw lx aw ly bi"><span id="5c7e" class="lz kk hi lp b fi ma mb l mc md">it('should pass object with correct values to save', function() {    <br/> let save = sinon.spy(Database, 'save');<br/> let info = { name: 'test' };<br/> let expectedUser = {name:info.name, nameLowercase: info.name.toLowerCase()};</span><span id="7a6b" class="lz kk hi lp b fi me mb l mc md"> setupNewUser(info, function() { });<br/> save.restore(); <br/> sinon.assert.calledWith(save, expectedUser);<br/>});</span></pre><p id="0399" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">最后，我还想介绍一下存根，存根就像间谍一样，但是它们取代了目标函数。你可以使用 stubs 来控制一个方法的行为，以强制一个代码路径(比如抛出错误)或者阻止对外部资源的调用(比如 HTTP APIs)。</p><p id="d6ef" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">存根有一些常见的用途:</p><ul class=""><li id="8b60" class="jo jp hi is b it iu ix iy jb jq jf jr jj js jn jt ju jv jw bi translated">您可以使用它们来替换有问题的代码</li><li id="92c2" class="jo jp hi is b it jx ix jy jb jz jf ka jj kb jn jt ju jv jw bi translated">您可以使用它们来触发本来不会触发的代码路径，比如错误处理</li><li id="e88b" class="jo jp hi is b it jx ix jy jb jz jf ka jj kb jn jt ju jv jw bi translated">您可以使用它们来帮助更容易地测试异步代码</li></ul><p id="f45b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">示例:-</p><p id="29bf" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们前面的例子使用了 Database.save，如果我们在运行测试之前没有设置数据库，这可能会成为一个问题。因此，使用存根而不是间谍可能是个好主意。</p><pre class="lr ls lt lu fd lv lp lw lx aw ly bi"><span id="c9ad" class="lz kk hi lp b fi ma mb l mc md">it('should pass object with correct values to save', function() {<br/> let save = sinon.stub(Database, 'save');<br/> let info = { name: 'test' };<br/> let expectedUser = {name: info.name, nameLowercase: info.name.toLowerCase()};<br/> setupNewUser(info, function() { });<br/> save.restore();<br/> sinon.assert.calledWith(save, expectedUser); <br/>});</span></pre><p id="542d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">存根也可以用来触发不同的代码路径。</strong></p><pre class="lr ls lt lu fd lv lp lw lx aw ly bi"><span id="1f42" class="lz kk hi lp b fi ma mb l mc md">it('should pass the error into the callback if save fails', function() {<br/> let expectedError = new Error('oops');<br/> let save = sinon.stub(Database, 'save');<br/> save.throws(expectedError);<br/> let callback = sinon.spy();<br/> setupNewUser({ name: 'foo' }, callback);<br/> save.restore();<br/> sinon.assert.calledWith(callback, expectedError); <br/>});</span></pre><p id="de77" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">希望你喜欢我的文章，谢谢。</p></div></div>    
</body>
</html>