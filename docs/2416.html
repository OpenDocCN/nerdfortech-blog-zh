<html>
<head>
<title>How to write unit test of app based on Android Architecture Components and Coroutine</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何基于Android架构组件和协程编写app的单元测试</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/how-to-write-unit-test-of-app-based-on-android-architecture-components-and-coroutine-8e5473f6674c?source=collection_archive---------6-----------------------#2021-05-05">https://medium.com/nerd-for-tech/how-to-write-unit-test-of-app-based-on-android-architecture-components-and-coroutine-8e5473f6674c?source=collection_archive---------6-----------------------#2021-05-05</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><blockquote class="if ig ih"><p id="bcf9" class="ii ij ik il b im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg hb bi translated">单元测试是应用测试策略中的基础测试。通过针对您的代码创建和运行单元测试，您可以轻松地验证各个单元的逻辑是否正确。在每次构建后运行单元测试有助于您快速捕捉和修复由应用程序代码更改引入的软件退化。</p><p id="52cb" class="ii ij ik il b im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg hb bi translated">单元测试通常以可重复的方式测试最小可能代码单元(可以是方法、类或组件)的功能。当您需要验证应用程序中特定代码部分的逻辑时，您应该构建单元测试。例如，如果您正在对一个类进行单元测试，您的测试可能会检查该类是否处于正确的状态。典型地，代码单元被孤立地测试；您的测试只影响和监控那个单元的变化。你可以使用依赖提供者，比如Robolectric或者一个<a class="ae jh" href="https://en.wikipedia.org/wiki/Mock_object" rel="noopener ugc nofollow" target="_blank"> mocking framework </a>来隔离你的单元和它的依赖。</p><p id="6cb7" class="ii ij ik il b im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg hb bi translated"><a class="ae jh" href="https://developer.android.com/training/testing/unit-testing" rel="noopener ugc nofollow" target="_blank">https://developer.android.com/training/testing/unit-testing</a></p></blockquote><p id="292d" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it ji iv iw ix jj iz ja jb jk jd je jf jg hb bi translated">正如谷歌的文件中所说，单元测试是软件开发中保证交付质量的重要环节。所以我将介绍如何给Android App编写单元测试。在本教程中，我们将使用<code class="du jl jm jn jo b">JUnit</code>、<code class="du jl jm jn jo b"><a class="ae jh" href="https://www.spekframework.org/setup-android/" rel="noopener ugc nofollow" target="_blank">Spek</a></code>和<code class="du jl jm jn jo b"><a class="ae jh" href="https://github.com/mockk/mockk" rel="noopener ugc nofollow" target="_blank">Mockk</a></code>。</p><h1 id="7d70" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">先决条件</h1><p id="d4f2" class="pw-post-body-paragraph ii ij hi il b im kn io ip iq ko is it ji kp iw ix jj kq ja jb jk kr je jf jg hb bi translated">在本教程中，我们将解决根据<a class="ae jh" rel="noopener" href="/nerd-for-tech/android-architecture-components-tutorial-7e822cdf2f00">https://medium . com/nerd-for-tech/Android-architecture-components-tutorial-7e 822 CDF 2f 00</a>构建的app的单元测试。所以让我们根据上面的教程来搭建这个app。</p><p id="21ba" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it ji iv iw ix jj iz ja jb jk jd je jf jg hb bi translated">app构建成功后，让我们检查<code class="du jl jm jn jo b">com.ovlesser.pexels(test)</code>包下的单元测试，你会发现有一个名为<code class="du jl jm jn jo b">ExampleUnitTest</code>的文件，它是由模板生成的。我们会离开它，创建我们自己的单元测试。</p><h2 id="ca56" class="ks jq hi bd jr kt ku kv jv kw kx ky jz ji kz la kd jj lb lc kh jk ld le kl lf bi translated">安装Spek插件</h2><p id="1c79" class="pw-post-body-paragraph ii ij hi il b im kn io ip iq ko is it ji kp iw ix jj kq ja jb jk kr je jf jg hb bi translated">我们需要做的第一件事是在Android Studio中安装<code class="du jl jm jn jo b">Spek</code> / <code class="du jl jm jn jo b">Spek Framework</code>插件。</p><p id="66d3" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it ji iv iw ix jj iz ja jb jk jd je jf jg hb bi translated">启动Android Studio，从菜单中打开<code class="du jl jm jn jo b">Android Studio</code> / <code class="du jl jm jn jo b">Preferences</code> / <code class="du jl jm jn jo b">Plugins</code>。然后搜索<code class="du jl jm jn jo b">Spek</code>，安装<code class="du jl jm jn jo b">Spek</code>和<code class="du jl jm jn jo b">Spek Framework</code>。安装完成后，您可能需要重启Android Studio。</p><h2 id="1a2a" class="ks jq hi bd jr kt ku kv jv kw kx ky jz ji kz la kd jj lb lc kh jk ld le kl lf bi translated">为单元测试添加依赖项</h2><p id="303b" class="pw-post-body-paragraph ii ij hi il b im kn io ip iq ko is it ji kp iw ix jj kq ja jb jk kr je jf jg hb bi translated">打开<code class="du jl jm jn jo b">build.gradle(Module: Pexels.app)</code>并将以下依赖关系添加到<code class="du jl jm jn jo b">dependencies</code>块和<code class="du jl jm jn jo b">Sync Now</code>中。</p><pre class="lg lh li lj fd lk jo ll lm aw ln bi"><span id="8c1e" class="ks jq hi jo b fi lo lp l lq lr"><em class="ik">// Unit testing<br/></em>testImplementation 'org.jetbrains.kotlin:kotlin-reflect:1.4.10'<br/>testImplementation "org.spekframework.spek2:spek-dsl-jvm:2.0.9"<br/>testImplementation "org.spekframework.spek2:spek-runner-junit5:2.0.9"<br/>testImplementation 'org.jetbrains.kotlinx:kotlinx-coroutines-test:1.4.3'<br/>testImplementation "org.assertj:assertj-core:3.15.0"<br/>implementation "org.jetbrains.kotlin:kotlin-stdlib-jdk8:$kotlin_version"</span><span id="ca9c" class="ks jq hi jo b fi ls lp l lq lr"><em class="ik">// Mocking for Kotlin<br/></em>testImplementation "io.mockk:mockk:1.10.0"<br/>testImplementation "io.mockk:mockk-agent-jvm:1.11.0"</span></pre><h2 id="0b2c" class="ks jq hi bd jr kt ku kv jv kw kx ky jz ji kz la kd jj lb lc kh jk ld le kl lf bi translated">创建单元测试类</h2><p id="bad1" class="pw-post-body-paragraph ii ij hi il b im kn io ip iq ko is it ji kp iw ix jj kq ja jb jk kr je jf jg hb bi translated">添加完依赖项后，让我们在<code class="du jl jm jn jo b">com.ovlesser.pexels(test)</code>包下创建几个新包<code class="du jl jm jn jo b">com.ovlesser.pexels.ui.home</code>和<code class="du jl jm jn jo b">com.ovlesser.pexels.ui.detail</code>。我们还需要在<code class="du jl jm jn jo b">com.ovlesser.pexels.ui.home</code>包下为<code class="du jl jm jn jo b">HomeViewModel</code>创建几个单元测试类<code class="du jl jm jn jo b">HomeViewModelTest</code>，在<code class="du jl jm jn jo b">com.ovlesser.pexels.ui.detail</code>包下为<code class="du jl jm jn jo b">DetailViewModel</code>创建<code class="du jl jm jn jo b">DetailViewModeTest</code>。</p><p id="158c" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it ji iv iw ix jj iz ja jb jk jd je jf jg hb bi translated">为什么我们只创建两个测试类？那是因为根据<code class="du jl jm jn jo b">MVVM</code>模式，app包含了<code class="du jl jm jn jo b">Model (M)</code>、<code class="du jl jm jn jo b">View (V) </code>和<code class="du jl jm jn jo b">ViewModel (VM)</code>三个部分。但是<code class="du jl jm jn jo b">Model</code>只是数据，不需要测试任何方法，而且<code class="du jl jm jn jo b">View</code>是UI相关的，需要用单元测试来测试。所以当编写单元测试时，我们将只关注<code class="du jl jm jn jo b">ViewModel</code>部分。这就是为什么我们只需要两个测试类来覆盖<code class="du jl jm jn jo b">HomeViewModel</code>类和<code class="du jl jm jn jo b">DetailViewModel</code>类。</p><p id="ac99" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it ji iv iw ix jj iz ja jb jk jd je jf jg hb bi translated">好了，让我们先为<code class="du jl jm jn jo b">DetailViewModel</code>写单元测试，因为这个类比<code class="du jl jm jn jo b">HomeViewModel</code>简单。我们将只为<code class="du jl jm jn jo b">DetailViewModel</code>类的构造添加单元测试。</p><h2 id="6376" class="ks jq hi bd jr kt ku kv jv kw kx ky jz ji kz la kd jj lb lc kh jk ld le kl lf bi translated">DetailViewModelTest</h2><p id="26a8" class="pw-post-body-paragraph ii ij hi il b im kn io ip iq ko is it ji kp iw ix jj kq ja jb jk kr je jf jg hb bi translated">让我们打开<code class="du jl jm jn jo b">DetailViewModelTest.kt</code>，并将<code class="du jl jm jn jo b">DetailViewModelTest</code>类更改如下:</p><pre class="lg lh li lj fd lk jo ll lm aw ln bi"><span id="ae12" class="ks jq hi jo b fi lo lp l lq lr">class DetailViewModelTest: Spek(<strong class="jo hj">{<br/>    <br/>}</strong>)</span></pre><p id="7c04" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it ji iv iw ix jj iz ja jb jk jd je jf jg hb bi translated">这是一个带有Spek的测试类的框架。</p><p id="b9c5" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it ji iv iw ix jj iz ja jb jk jd je jf jg hb bi translated">我们需要在这个类中添加下面的<code class="du jl jm jn jo b">Application</code>类的模拟对象，因为<code class="du jl jm jn jo b">DetailViewModel</code>类有一个<code class="du jl jm jn jo b">application</code>对象的参数</p><pre class="lg lh li lj fd lk jo ll lm aw ln bi"><span id="3d7d" class="ks jq hi jo b fi lo lp l lq lr">val mockApplication = <em class="ik">mockk</em>&lt;Application&gt;() <strong class="jo hj">{<br/>    </strong><em class="ik">every </em><strong class="jo hj">{ </strong><em class="ik">applicationContext </em><strong class="jo hj">} </strong>returns <em class="ik">mockk</em>()<br/><strong class="jo hj">}</strong></span></pre><p id="9c2d" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it ji iv iw ix jj iz ja jb jk jd je jf jg hb bi translated">并实例化一个<code class="du jl jm jn jo b">Photo</code>对象，作为<code class="du jl jm jn jo b">DetailViewModel</code>类的另一个参数如下:</p><pre class="lg lh li lj fd lk jo ll lm aw ln bi"><span id="c48c" class="ks jq hi jo b fi lo lp l lq lr">val photo = Data.Photo(id = 123, width = 200, height = 120)</span></pre><p id="750b" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it ji iv iw ix jj iz ja jb jk jd je jf jg hb bi translated">并声明一个变量<code class="du jl jm jn jo b">detailViewModel</code>作为测试对象，如下所示:</p><pre class="lg lh li lj fd lk jo ll lm aw ln bi"><span id="9d98" class="ks jq hi jo b fi lo lp l lq lr">lateinit var detailViewModel: DetailViewModel</span></pre><p id="a8ca" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it ji iv iw ix jj iz ja jb jk jd je jf jg hb bi translated">注意，我们只是声明了它而没有实例化它，因为在<code class="du jl jm jn jo b">constructor</code> / <code class="du jl jm jn jo b">init</code>块中有一些<code class="du jl jm jn jo b">LiveData</code>更新，由于此类<code class="du jl jm jn jo b">LiveData</code>更新不能在<code class="du jl jm jn jo b">Main</code>线程中执行，这将触发以下错误:</p><pre class="lg lh li lj fd lk jo ll lm aw ln bi"><span id="ad6c" class="ks jq hi jo b fi lo lp l lq lr">Method getMainLooper in android.os.Looper not mocked. See <a class="ae jh" href="http://g.co/androidstudio/not-mocked" rel="noopener ugc nofollow" target="_blank">http://g.co/androidstudio/not-mocked</a> for details.</span></pre><p id="1c48" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it ji iv iw ix jj iz ja jb jk jd je jf jg hb bi translated">我们将通过以下方法修复它。</p><pre class="lg lh li lj fd lk jo ll lm aw ln bi"><span id="19fb" class="ks jq hi jo b fi lo lp l lq lr">beforeGroup <strong class="jo hj">{<br/>    </strong>ArchTaskExecutor.getInstance().setDelegate(object : TaskExecutor() {<br/>        override fun executeOnDiskIO(runnable: Runnable) {<br/>            runnable.run()<br/>        }<br/><br/>        override fun isMainThread(): Boolean {<br/>            return true<br/>        }<br/><br/>        override fun postToMainThread(runnable: Runnable) {<br/>            runnable.run()<br/>        }<br/>    })<br/>    detailViewModel = <em class="ik">spyk</em>(DetailViewModel(photo, mockApplication))<br/><strong class="jo hj">}</strong></span></pre><p id="507a" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it ji iv iw ix jj iz ja jb jk jd je jf jg hb bi translated">如图所示，我们覆盖了<code class="du jl jm jn jo b">beforeGroup</code>块中的<code class="du jl jm jn jo b">ArchTaskExecutor</code>，它将在真正的测试代码运行之前运行。这段代码确保我们可以无错地运行<code class="du jl jm jn jo b">LiveData</code>更新。</p><p id="5ffb" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it ji iv iw ix jj iz ja jb jk jd je jf jg hb bi translated">我们还在<code class="du jl jm jn jo b">beforeGroup</code>块中实例化了<code class="du jl jm jn jo b">detailViewModel</code>对象。它将被成功创建，因为我们已经覆盖了<code class="du jl jm jn jo b">ArchTaskExecutor</code>。</p><p id="fe7a" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it ji iv iw ix jj iz ja jb jk jd je jf jg hb bi translated">而<code class="du jl jm jn jo b">spyk</code>是<code class="du jl jm jn jo b">Mockk</code>的一个关键字，通过它<code class="du jl jm jn jo b">detailViewModel</code>对象可以包含真实属性和模拟属性。</p><p id="15ce" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it ji iv iw ix jj iz ja jb jk jd je jf jg hb bi translated">然后让我们编写如下所示的测试用例:</p><pre class="lg lh li lj fd lk jo ll lm aw ln bi"><span id="d974" class="ks jq hi jo b fi lo lp l lq lr"><em class="ik">describe</em>("init") <strong class="jo hj">{<br/>    </strong>it("should init successfully") <strong class="jo hj">{<br/>        </strong>assertThat(detailViewModel.photo.<em class="ik">value</em>).isEqualTo(photo)<br/>    <strong class="jo hj">}<br/><br/>    </strong>it("should return correct size") <strong class="jo hj">{<br/>        </strong>detailViewModel.size.observeForever <strong class="jo hj">{<br/>            </strong>assertThat(detailViewModel.size.<em class="ik">value</em>).isEqualTo("${photo.width} * ${photo.height}")<br/>        <strong class="jo hj">}<br/>        </strong>detailViewModel.size.removeObserver <strong class="jo hj">{}<br/>    }<br/>}</strong></span></pre><p id="6e18" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it ji iv iw ix jj iz ja jb jk jd je jf jg hb bi translated">如图所示，我们有两个测试用例来测试<code class="du jl jm jn jo b">DetailViewModel</code>类的初始化:验证<code class="du jl jm jn jo b">LiveData</code>属性<code class="du jl jm jn jo b">detailViewModel.photo</code>设置成功，验证另一个<code class="du jl jm jn jo b">LiveData</code>属性<code class="du jl jm jn jo b">detailViewModel.size</code>将返回正确的值。</p><p id="825a" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it ji iv iw ix jj iz ja jb jk jd je jf jg hb bi translated">小心，我们需要观察带有<code class="du jl jm jn jo b">LiveData.observeForever</code>的<code class="du jl jm jn jo b">LiveData</code>属性<code class="du jl jm jn jo b">detailViewModel.size</code>，一旦<code class="du jl jm jn jo b">LiveData</code>的值改变，就会触发lambda函数。</p><p id="5045" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it ji iv iw ix jj iz ja jb jk jd je jf jg hb bi translated">现在让我们通过点击<code class="du jl jm jn jo b">DetailViewModelTest</code>类前的绿色小三角形来运行单元测试，我们会发现两个测试通过了。</p><p id="21a8" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it ji iv iw ix jj iz ja jb jk jd je jf jg hb bi translated">这是一个非常简单的用<code class="du jl jm jn jo b">Spek</code> / <code class="du jl jm jn jo b">Mockk</code>进行单元测试的例子。我们将为<code class="du jl jm jn jo b">HomeViewModel</code>类添加更复杂的单元测试。</p><h2 id="0beb" class="ks jq hi bd jr kt ku kv jv kw kx ky jz ji kz la kd jj lb lc kh jk ld le kl lf bi translated">HomeViewModelTest</h2><p id="8c14" class="pw-post-body-paragraph ii ij hi il b im kn io ip iq ko is it ji kp iw ix jj kq ja jb jk kr je jf jg hb bi translated">让我们打开<code class="du jl jm jn jo b">HomeViewModelTest.kt</code>，它应该在<code class="du jl jm jn jo b">com.ovlesser.pexels(test).ui.home</code>包里，把骨架写成如下:</p><pre class="lg lh li lj fd lk jo ll lm aw ln bi"><span id="b42a" class="ks jq hi jo b fi lo lp l lq lr">class HomeViewModelTest: Spek(<strong class="jo hj">{<br/>    </strong>val mockApplication = <em class="ik">mockk</em>&lt;Application&gt;() <strong class="jo hj">{<br/>        </strong><em class="ik">every </em><strong class="jo hj">{ </strong><em class="ik">applicationContext </em><strong class="jo hj">} </strong>returns <em class="ik">mockk</em>()<br/>    <strong class="jo hj">}<br/>    </strong>lateinit var homeViewModel: HomeViewModel<br/><br/>    beforeGroup <strong class="jo hj">{<br/>        </strong>ArchTaskExecutor.getInstance().setDelegate(object : TaskExecutor() {<br/>            override fun executeOnDiskIO(runnable: Runnable) {<br/>                runnable.run()<br/>            }<br/><br/>            override fun isMainThread(): Boolean {<br/>                return true<br/>            }<br/><br/>            override fun postToMainThread(runnable: Runnable) {<br/>                runnable.run()<br/>            }<br/>        })<br/>        homeViewModel = <em class="ik">spyk</em>(HomeViewModel(mockApplication))<br/>    <strong class="jo hj">}<br/>}</strong>)</span></pre><p id="a423" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it ji iv iw ix jj iz ja jb jk jd je jf jg hb bi translated">如图所示，它与<code class="du jl jm jn jo b">DetailViewModelTest</code>类非常相似。</p><p id="0d7c" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it ji iv iw ix jj iz ja jb jk jd je jf jg hb bi translated">让我们添加第一个测试用例如下:</p><pre class="lg lh li lj fd lk jo ll lm aw ln bi"><span id="8593" class="ks jq hi jo b fi lo lp l lq lr"><em class="ik">describe</em>("init") <strong class="jo hj">{<br/>    </strong>it("should init successfully") <strong class="jo hj">{<br/>        </strong>homeViewModel.data.observeForever <strong class="jo hj">{<br/>            </strong>Assertions.assertThat(homeViewModel.data.<em class="ik">value</em>).isEqualTo()<br/>        <strong class="jo hj">}<br/>    }<br/>}</strong></span></pre><p id="ce3a" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it ji iv iw ix jj iz ja jb jk jd je jf jg hb bi translated">我们会发现第一个问题，<code class="du jl jm jn jo b">homeViewModel.data.value</code>的预期结果是什么？我们不知道，因为这个值来自<code class="du jl jm jn jo b">pexelsPhotoRepository</code>和<code class="du jl jm jn jo b">database.pexelsPhotoDao.getPhotos()</code>。它来自数据库，取决于数据库中保存的数据。更糟糕的是，数据库中的数据可能会发生变化，因为我们正在发送HTTP请求从后端服务获取新数据，一旦请求成功返回，新数据可能会被插入到数据库中。</p><p id="55ce" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it ji iv iw ix jj iz ja jb jk jd je jf jg hb bi translated">所以我们会发现数据库和网络服务是<code class="du jl jm jn jo b">HomeViewModel</code>类的依赖项，而<code class="du jl jm jn jo b">HomeViewModel</code>类中的数据依赖于它的依赖项。这违反了单元测试的隔离原则。因此，我们需要模拟所有这些依赖关系，并确保模拟的依赖关系会给出我们期望的值。</p><p id="8871" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it ji iv iw ix jj iz ja jb jk jd je jf jg hb bi translated">让我们检查一下<code class="du jl jm jn jo b">HomeViewModel</code>类的实现，我们会发现网络服务的实例<code class="du jl jm jn jo b">PexelApi.retrofitService</code>在<code class="du jl jm jn jo b">PexelsPhotoRepository</code>类中，<code class="du jl jm jn jo b">PexelsPhotoRepository</code>实例在<code class="du jl jm jn jo b">HomeViewModel</code>类中，数据库对象也在<code class="du jl jm jn jo b">HomeViewModel</code>类中被实例化，并被传递给<code class="du jl jm jn jo b">PexelsPhotoRepository</code>实例。它们是完全耦合的，很难隔离。所以我们需要做的第一件事就是根据<code class="du jl jm jn jo b">Dependency Injection (DI)</code>的原则修改这些类。</p><p id="d7f5" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it ji iv iw ix jj iz ja jb jk jd je jf jg hb bi translated">我们将改变<code class="du jl jm jn jo b">HomeViewModel</code>类的签名，使其依赖关系可以被注入，因为当真正的应用程序运行和单元测试运行时，我们需要不同的依赖关系。因此，我们需要将<code class="du jl jm jn jo b">HomeViewModel</code>类的签名更改如下:</p><pre class="lg lh li lj fd lk jo ll lm aw ln bi"><span id="ef3d" class="ks jq hi jo b fi lo lp l lq lr">class HomeViewModel(apiService: PexelsApiService? = null, dao: PexelsPhotoDao? = null, application: Application) : AndroidViewModel(application)</span></pre><p id="a17f" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it ji iv iw ix jj iz ja jb jk jd je jf jg hb bi translated">如你所见，我们在<code class="du jl jm jn jo b">HomeViewModel</code>的构造函数中为依赖注入引入了两个额外的可选参数<code class="du jl jm jn jo b">apiService</code>和<code class="du jl jm jn jo b">dao</code>。但是我们将它们设置为可选的，因为我们不想在真正的应用程序运行时注入它们。我以后会解释的。</p><p id="b817" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it ji iv iw ix jj iz ja jb jk jd je jf jg hb bi translated">接下来，我们需要将pexelsPhotoRepository的实例化改为</p><pre class="lg lh li lj fd lk jo ll lm aw ln bi"><span id="bfbf" class="ks jq hi jo b fi lo lp l lq lr">private val pexelsPhotoRepository = PexelsPhotoRepository(apiService = apiService, dao = dao ?: <em class="ik">getDatabase</em>(application).pexelsPhotoDao)</span></pre><p id="f1b0" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it ji iv iw ix jj iz ja jb jk jd je jf jg hb bi translated">将<code class="du jl jm jn jo b">apiService</code>和<code class="du jl jm jn jo b">dao</code>传入储存库。请注意，我们使用的是真实数据库<code class="du jl jm jn jo b">HomeViewModel</code>、<code class="du jl jm jn jo b">dao</code>的参数是<code class="du jl jm jn jo b">null</code>，这是真实应用运行的情况。</p><p id="47f1" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it ji iv iw ix jj iz ja jb jk jd je jf jg hb bi translated">我们还需要将内部类<code class="du jl jm jn jo b">HomeViewModel.Fatory</code>的<code class="du jl jm jn jo b">create</code>方法从</p><pre class="lg lh li lj fd lk jo ll lm aw ln bi"><span id="847d" class="ks jq hi jo b fi lo lp l lq lr">return HomeViewModel(app) as T</span></pre><p id="fc6f" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it ji iv iw ix jj iz ja jb jk jd je jf jg hb bi translated">到</p><pre class="lg lh li lj fd lk jo ll lm aw ln bi"><span id="7087" class="ks jq hi jo b fi lo lp l lq lr">return HomeViewModel(application = app) as T</span></pre><p id="7b76" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it ji iv iw ix jj iz ja jb jk jd je jf jg hb bi translated">因为我们改变了<code class="du jl jm jn jo b">HomeViewModel</code>类的构造函数的签名。</p><p id="1ccb" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it ji iv iw ix jj iz ja jb jk jd je jf jg hb bi translated">然后我们会注意到在创建<code class="du jl jm jn jo b">pexelsPhotoRepository</code>对象时的错误，因为在<code class="du jl jm jn jo b">PexelsPhotoRepository</code>类的构造函数中没有新的参数。让我们通过更改该类的构造函数来添加它们，如下所示:</p><pre class="lg lh li lj fd lk jo ll lm aw ln bi"><span id="b974" class="ks jq hi jo b fi lo lp l lq lr">class PexelsPhotoRepository(<br/>    private val apiService: PexelsApiService? = PexelApi.retrofitService,<br/>    private val dao: PexelsPhotoDao) {</span></pre><p id="ea9f" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it ji iv iw ix jj iz ja jb jk jd je jf jg hb bi translated">同上，我们将使用真实的<code class="du jl jm jn jo b">PexelApi</code>。retrofitService如果参数<code class="du jl jm jn jo b">apiService</code>为空，表示真正的app正在运行。</p><p id="231b" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it ji iv iw ix jj iz ja jb jk jd je jf jg hb bi translated">我们还需要将这个存储库类中的所有<code class="du jl jm jn jo b">database.pexelsPhotoDao</code>更改为<code class="du jl jm jn jo b">dao</code>，以确保我们使用的是传入的<code class="du jl jm jn jo b">dao</code>。</p><p id="592b" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it ji iv iw ix jj iz ja jb jk jd je jf jg hb bi translated">好了，我们已经根据依赖注入的原则做了修改。让我们先运行应用程序，以确保我们没有搞砸任何事情。</p><p id="d3c5" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it ji iv iw ix jj iz ja jb jk jd je jf jg hb bi translated">现在我们已经能够在运行单元测试时注入模拟的<code class="du jl jm jn jo b">ApiService</code>和模拟的<code class="du jl jm jn jo b">dao</code>。因此，让我们实现被嘲笑的依赖。</p><h2 id="796d" class="ks jq hi bd jr kt ku kv jv kw kx ky jz ji kz la kd jj lb lc kh jk ld le kl lf bi translated">测试锁</h2><p id="1856" class="pw-post-body-paragraph ii ij hi il b im kn io ip iq ko is it ji kp iw ix jj kq ja jb jk kr je jf jg hb bi translated">首先，让我们在<code class="du jl jm jn jo b">com.ovlesser.pexels(test).ui.home</code>包中创建一个新文件TestingMocks，并创建一个MockApiService类，如下所示:</p><pre class="lg lh li lj fd lk jo ll lm aw ln bi"><span id="0e71" class="ks jq hi jo b fi lo lp l lq lr">class MockApiService(var result: Data): PexelsApiService {<br/>    override fun getData(keyword: String, pageIndex: Int, perPage: Int) = MockCall&lt;Data&gt;(result)<br/><br/>    override suspend fun getDataCoroutine(keyword: String, pageIndex: Int, perPage: Int) = result<br/>}</span></pre><p id="70a0" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it ji iv iw ix jj iz ja jb jk jd je jf jg hb bi translated">及其所属的<code class="du jl jm jn jo b">MockCall</code>类如下所示:</p><pre class="lg lh li lj fd lk jo ll lm aw ln bi"><span id="2ad5" class="ks jq hi jo b fi lo lp l lq lr">class MockCall&lt;T&gt;(result: Data): Call&lt;T&gt; {<br/>    override fun clone(): Call&lt;T&gt; {<br/>        <em class="ik">TODO</em>("Not yet implemented")<br/>    }<br/><br/>    override fun execute(): Response&lt;T&gt; {<br/>        <em class="ik">TODO</em>("Not yet implemented")<br/>    }<br/><br/>    override fun enqueue(callback: Callback&lt;T&gt;) {<br/>        <em class="ik">TODO</em>("Not yet implemented")<br/>    }<br/><br/>    override fun isExecuted(): Boolean {<br/>        <em class="ik">TODO</em>("Not yet implemented")<br/>    }<br/><br/>    override fun cancel() {<br/>        <em class="ik">TODO</em>("Not yet implemented")<br/>    }<br/><br/>    override fun isCanceled(): Boolean {<br/>        <em class="ik">TODO</em>("Not yet implemented")<br/>    }<br/><br/>    override fun request(): Request {<br/>        <em class="ik">TODO</em>("Not yet implemented")<br/>    }<br/><br/>    override fun timeout(): Timeout {<br/>        <em class="ik">TODO</em>("Not yet implemented")<br/>    }<br/><br/>}</span></pre><p id="140a" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it ji iv iw ix jj iz ja jb jk jd je jf jg hb bi translated">正如我们看到的，我们模仿了方法<code class="du jl jm jn jo b">getData</code>，它将返回由<code class="du jl jm jn jo b">MockCall</code>包装的输入值，以及<code class="du jl jm jn jo b">getDataCoroutine</code>，它将直接返回输入值。</p><p id="ac55" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it ji iv iw ix jj iz ja jb jk jd je jf jg hb bi translated">我们还需要创建另一个模拟类<code class="du jl jm jn jo b">MockDao</code>，来模拟<code class="du jl jm jn jo b">PexelsPhotoDao</code>类，如下所示:</p><pre class="lg lh li lj fd lk jo ll lm aw ln bi"><span id="316b" class="ks jq hi jo b fi lo lp l lq lr">class MockDao( val data: Data): PexelsPhotoDao {<br/>    private val _photos = MutableLiveData&lt;List&lt;DatabasePexelsPhoto&gt;&gt;()<br/><br/>    override fun getPhotos(): LiveData&lt;List&lt;DatabasePexelsPhoto&gt;&gt; {<br/>        _photos.<em class="ik">value </em>= data.photos.<em class="ik">asDatabaseModel</em>()<br/>        return _photos<br/>    }<br/><br/>    override fun insertAll(photos: List&lt;DatabasePexelsPhoto&gt;) {<br/>        _photos.<em class="ik">value </em>= photos<br/>    }<br/><br/>    override fun clearAll() {<br/>        _photos.<em class="ik">value </em>= <em class="ik">emptyList</em>()<br/>    }<br/>}</span></pre><p id="0aca" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it ji iv iw ix jj iz ja jb jk jd je jf jg hb bi translated">我们也覆盖了<code class="du jl jm jn jo b">PexelsPhotoDao</code>类的方法。</p><p id="151b" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it ji iv iw ix jj iz ja jb jk jd je jf jg hb bi translated">现在我们已经有了<code class="du jl jm jn jo b">ApiService</code>和<code class="du jl jm jn jo b">dao</code>的模拟类，让我们回到<code class="du jl jm jn jo b">HomeViewModelTest</code>类并添加下面的代码</p><pre class="lg lh li lj fd lk jo ll lm aw ln bi"><span id="b2e7" class="ks jq hi jo b fi lo lp l lq lr">val data = Data( photos = <em class="ik">listOf</em>(Data.Photo(id = 111), Data.Photo(id = 222), Data.Photo(id = 333)), totalResults = 3)<br/>val mockApiService = MockApiService(data)<br/>val mockDao = MockDao(data)</span></pre><p id="b90b" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it ji iv iw ix jj iz ja jb jk jd je jf jg hb bi translated">在这段代码中，我们用一些数据创建了两个模拟对象<code class="du jl jm jn jo b">mockApiService</code>和<code class="du jl jm jn jo b">mockDao</code>，所以这些模拟对象会用这些数据模拟回报。然后我们能够验证它们。</p><p id="c41e" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it ji iv iw ix jj iz ja jb jk jd je jf jg hb bi translated">然后，我们需要将这些被模仿的对象注入到<code class="du jl jm jn jo b">homeViewModel</code>对象中，如下所示:</p><pre class="lg lh li lj fd lk jo ll lm aw ln bi"><span id="5182" class="ks jq hi jo b fi lo lp l lq lr">homeViewModel = <em class="ik">spyk</em>(HomeViewModel(apiService = mockApiService, dao = mockDao, application = mockApplication))</span></pre><p id="d9a2" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it ji iv iw ix jj iz ja jb jk jd je jf jg hb bi translated">现在，<code class="du jl jm jn jo b">homeViewModel</code>并不依赖真正的网络服务或真正的数据库。然后我们可以将测试用例<code class="du jl jm jn jo b">init</code>的断言改为</p><pre class="lg lh li lj fd lk jo ll lm aw ln bi"><span id="e1f4" class="ks jq hi jo b fi lo lp l lq lr">Assertions.assertThat(homeViewModel.data.<em class="ik">value</em>).isEqualTo(data)</span></pre><p id="4dff" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it ji iv iw ix jj iz ja jb jk jd je jf jg hb bi translated">让我们运行这个测试用例，您会发现它通过了。</p><p id="586a" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it ji iv iw ix jj iz ja jb jk jd je jf jg hb bi translated">现在让我们添加更多的测试用例来测试<code class="du jl jm jn jo b">HomeViewModel</code>类的其他公共方法，如下所示:</p><pre class="lg lh li lj fd lk jo ll lm aw ln bi"><span id="b774" class="ks jq hi jo b fi lo lp l lq lr"><em class="ik">describe</em>("#${HomeViewModel::refreshRepository.name}") <strong class="jo hj">{<br/>    </strong>it("should return") <strong class="jo hj">{<br/>        </strong>homeViewModel.refreshRepository("")<br/>        Assertions.assertThat(homeViewModel.status.<em class="ik">value</em>).isEqualTo(PexelsApiStatus.<em class="ik">DONE</em>)<br/>    <strong class="jo hj">}<br/>}<br/><br/></strong><em class="ik">describe</em>("#${HomeViewModel::displayPhotoDetails.name}") <strong class="jo hj">{<br/>    </strong>it("should return") <strong class="jo hj">{<br/>        </strong>val photo = Data.Photo(id = 123)<br/>        homeViewModel.displayPhotoDetails(photo)<br/>        Assertions.assertThat(homeViewModel.selectedPhoto.<em class="ik">value</em>).isEqualTo(photo)<br/>    <strong class="jo hj">}<br/>}<br/><br/></strong><em class="ik">describe</em>("#${HomeViewModel::displayPhotoDetailComplete.name}") <strong class="jo hj">{<br/>    </strong>it("should return null") <strong class="jo hj">{<br/>        </strong>homeViewModel.displayPhotoDetailComplete()<br/>        Assertions.assertThat(homeViewModel.selectedPhoto.<em class="ik">value</em>).isNull()<br/>    <strong class="jo hj">}<br/>}</strong></span></pre><p id="7373" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it ji iv iw ix jj iz ja jb jk jd je jf jg hb bi translated">让我们点击<code class="du jl jm jn jo b">HomeViewModelTest</code>类前面的绿色三角形，我们将看到4个测试通过。</p><p id="6887" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it ji iv iw ix jj iz ja jb jk jd je jf jg hb bi translated">到目前为止，我们已经为<code class="du jl jm jn jo b">DetailViewModel</code>和<code class="du jl jm jn jo b">HomeViewModel</code>增加了单元测试。</p><p id="f29c" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it ji iv iw ix jj iz ja jb jk jd je jf jg hb bi translated">另外，如果我们想用协程测试这样的方法，还有一个问题需要解决，如下所示:</p><p id="0f2f" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it ji iv iw ix jj iz ja jb jk jd je jf jg hb bi translated">我们需要在<code class="du jl jm jn jo b">HomeViewModelTest</code>类声明上方添加以下注释:</p><pre class="lg lh li lj fd lk jo ll lm aw ln bi"><span id="6b1b" class="ks jq hi jo b fi lo lp l lq lr">@ObsoleteCoroutinesApi<br/>@ExperimentalCoroutinesApi</span></pre><p id="3e14" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it ji iv iw ix jj iz ja jb jk jd je jf jg hb bi translated">并创建一个新的<code class="du jl jm jn jo b">newSingleThreadContext</code> <em class="ik"> </em>实例如下:</p><pre class="lg lh li lj fd lk jo ll lm aw ln bi"><span id="f6eb" class="ks jq hi jo b fi lo lp l lq lr">val mainThreadSurrogate = <em class="ik">newSingleThreadContext</em>("UI thread")</span></pre><p id="416c" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it ji iv iw ix jj iz ja jb jk jd je jf jg hb bi translated">并在<code class="du jl jm jn jo b">beforeGroup</code>块中分派该线程上下文，如下所示:</p><pre class="lg lh li lj fd lk jo ll lm aw ln bi"><span id="e3fe" class="ks jq hi jo b fi lo lp l lq lr">Dispatchers.<em class="ik">setMain</em>(mainThreadSurrogate)</span></pre><p id="eec0" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it ji iv iw ix jj iz ja jb jk jd je jf jg hb bi translated">并在<code class="du jl jm jn jo b">afterGroup</code>中添加重置所有上下文，如下所示:</p><pre class="lg lh li lj fd lk jo ll lm aw ln bi"><span id="77b2" class="ks jq hi jo b fi lo lp l lq lr">afterGroup <strong class="jo hj">{<br/>    </strong>ArchTaskExecutor.getInstance().setDelegate(null)<br/>    Dispatchers.<em class="ik">resetMain</em>()<br/>    mainThreadSurrogate.close()<br/><strong class="jo hj">}</strong></span></pre><p id="7c0a" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it ji iv iw ix jj iz ja jb jk jd je jf jg hb bi translated">本教程没有涵盖单元测试的所有代码，而是给出了一些关于如何编写单元测试以及如何模拟与<code class="du jl jm jn jo b">Spek</code>和<code class="du jl jm jn jo b">Mockk</code>的依赖关系的例子。</p><p id="5bca" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it ji iv iw ix jj iz ja jb jk jd je jf jg hb bi translated">感谢浏览我的教程，欢迎任何反馈。</p></div></div>    
</body>
</html>