<html>
<head>
<title>Variable hoisting in Javascript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Javascript 中的变量提升</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/variable-hoisting-in-javascript-9dcc5d6886ba?source=collection_archive---------9-----------------------#2021-03-24">https://medium.com/nerd-for-tech/variable-hoisting-in-javascript-9dcc5d6886ba?source=collection_archive---------9-----------------------#2021-03-24</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/ed4bad4813e81b4fe0e6b6a2c26fa021.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Cql_y4i-tEoLjK3dVP7B2Q.jpeg"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">照片由<a class="ae iu" href="https://unsplash.com/@sapegin?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Artem Sapegin </a>在<a class="ae iu" rel="noopener ugc nofollow" target="_blank" href="/s/photos/javascript?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText"> Unsplash </a>上拍摄</figcaption></figure><h1 id="2c14" class="iv iw hi bd ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js bi translated">介绍</h1><p id="7987" class="pw-post-body-paragraph jt ju hi jv b jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq hb bi translated">让我们首先从回答这个问题开始:<strong class="jv hj"> <em class="kr">下面给出的代码输出会是什么？</em>T11】</strong></p><figure class="kt ku kv kw fd ij er es paragraph-image"><div class="er es ks"><img src="../Images/3b8693e3555fb86758fee332b5cfe4a0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1020/format:webp/1*mQWV1b5dQHzaJoY0wWtQog.png"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">产量是多少？</figcaption></figure><p id="50f0" class="pw-post-body-paragraph jt ju hi jv b jw kx jy jz ka ky kc kd ke kz kg kh ki la kk kl km lb ko kp kq hb bi translated">如果您猜测输出为<code class="du lc ld le lf b">undefined</code>，那么您是正确的！这是吊装。从逻辑上讲，这应该会产生一个错误，因为您试图访问在 log 语句之后声明的变量，但这并没有发生。为什么？让我们理解！</p><p id="7a29" class="pw-post-body-paragraph jt ju hi jv b jw kx jy jz ka ky kc kd ke kz kg kh ki la kk kl km lb ko kp kq hb bi translated">提升发生在全局执行上下文的创建阶段。全局执行上下文有两个执行阶段:<em class="kr">创建</em>和<em class="kr">执行</em>。</p><h1 id="9640" class="iv iw hi bd ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js bi translated">技术上发生了什么？</h1><p id="f128" class="pw-post-body-paragraph jt ju hi jv b jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq hb bi translated">在<em class="kr">创建</em>阶段，Javascript 引擎将变量声明添加到内存中，并用值<code class="du lc ld le lf b">undefined</code>初始化它。因此，你得到的值是<code class="du lc ld le lf b">undefined</code>。</p><p id="b80d" class="pw-post-body-paragraph jt ju hi jv b jw kx jy jz ka ky kc kd ke kz kg kh ki la kk kl km lb ko kp kq hb bi translated">在<em class="kr">执行</em>阶段，代码将如下所示:</p><figure class="kt ku kv kw fd ij er es paragraph-image"><div class="er es lg"><img src="../Images/7b765a7b3ce664fd861acbdf997e6593.png" data-original-src="https://miro.medium.com/v2/resize:fit:956/format:webp/1*1cUL8N283y0Rq0Aw1t-quw.png"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">在执行阶段，代码看起来会像这样。</figcaption></figure><blockquote class="lh li lj"><p id="cfe0" class="jt ju kr jv b jw kx jy jz ka ky kc kd lk kz kg kh ll la kk kl lm lb ko kp kq hb bi translated"><strong class="jv hj">注</strong>:上面的代码只是让你理解的东西。引擎实际上并不移动顶部的代码。代码保持键入时的状态。</p></blockquote><p id="794b" class="pw-post-body-paragraph jt ju hi jv b jw kx jy jz ka ky kc kd ke kz kg kh ki la kk kl km lb ko kp kq hb bi translated">太好了！这是吊装！</p><blockquote class="lh li lj"><p id="3343" class="jt ju kr jv b jw kx jy jz ka ky kc kd lk kz kg kh ll la kk kl lm lb ko kp kq hb bi translated"><strong class="jv hj">注意</strong> : Javascript 只提升声明，不提升初始化。这意味着无论何时遇到一个声明，它都会以一个未定义的值添加到内存中。实际的初始化值不是在编译时添加到内存中，而是在运行时添加。</p></blockquote><h1 id="f7a5" class="iv iw hi bd ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js bi translated">如果变量根本不存在呢？</h1><p id="13d3" class="pw-post-body-paragraph jt ju hi jv b jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq hb bi translated">这是理解吊装的一个大问题。当 Javascript 代码中存在声明时，就会发生提升(声明的位置也很重要)。让我们举一个例子。让我们运行这段代码:</p><figure class="kt ku kv kw fd ij er es paragraph-image"><div class="er es ln"><img src="../Images/012b4203ed54b35a04a19f3d95ca1c4c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1006/format:webp/1*eBNZk6YD7bgSgxh4Z2hcbA.png"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">这段代码的输出是什么？</figcaption></figure><p id="b6fa" class="pw-post-body-paragraph jt ju hi jv b jw kx jy jz ka ky kc kd ke kz kg kh ki la kk kl km lb ko kp kq hb bi translated">代码的输出是:</p><figure class="kt ku kv kw fd ij er es paragraph-image"><div class="er es lo"><img src="../Images/550e53c90ce8ca739bf6a4270e95cc8b.png" data-original-src="https://miro.medium.com/v2/resize:fit:786/format:webp/1*vs9F1RpbnCFW9sQgXYNIRA.png"/></div></figure><p id="e831" class="pw-post-body-paragraph jt ju hi jv b jw kx jy jz ka ky kc kd ke kz kg kh ki la kk kl km lb ko kp kq hb bi translated">因此，当变量不存在(没有声明)时，提升将不工作。</p><h1 id="f397" class="iv iw hi bd ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js bi translated">如果变量的范围不同呢？</h1><p id="39bf" class="pw-post-body-paragraph jt ju hi jv b jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq hb bi translated">让我们了解一下，如果变量在函数内部声明，而在函数外部访问，会发生什么。让我们考虑这个代码:</p><figure class="kt ku kv kw fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lp"><img src="../Images/de5e06213a341b8436323e6d7c66ca73.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vcsHg9pwAALFL11drwkn6w.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">这段代码的输出会是什么？</figcaption></figure><p id="eb60" class="pw-post-body-paragraph jt ju hi jv b jw kx jy jz ka ky kc kd ke kz kg kh ki la kk kl km lb ko kp kq hb bi translated">从逻辑上讲，由于局部变量和作用域的概念，不能在外部访问<code class="du lc ld le lf b">count</code>变量。因此，我们可以猜测输出应该还是一个错误。以下是输出:</p><figure class="kt ku kv kw fd ij er es paragraph-image"><div class="er es lo"><img src="../Images/550e53c90ce8ca739bf6a4270e95cc8b.png" data-original-src="https://miro.medium.com/v2/resize:fit:786/format:webp/1*vs9F1RpbnCFW9sQgXYNIRA.png"/></div></figure><p id="13b8" class="pw-post-body-paragraph jt ju hi jv b jw kx jy jz ka ky kc kd ke kz kg kh ki la kk kl km lb ko kp kq hb bi translated">所以，我们猜对了！我们不能访问<code class="du lc ld le lf b">counter()</code>函数范围之外的变量。但是吊装呢？为什么没有发生吊装？原因是因为执行上下文。当 Javascript 代码执行时，会创建一个全局执行上下文。因此，全局范围内的任何变量都被提升，但在这种情况下，<code class="du lc ld le lf b">count</code>变量在函数<code class="du lc ld le lf b">counter()</code>中被初始化和声明。<code class="du lc ld le lf b">counter()</code>函数有它的执行上下文！记住，<em class="kr">提升发生在每个执行上下文</em>中。因此，如果我们在计数器函数中的变量声明前添加一个<code class="du lc ld le lf b">console.log()</code>语句，变量<code class="du lc ld le lf b">count</code>将被提升。让我们来测试一下吧！代码:</p><figure class="kt ku kv kw fd ij er es paragraph-image"><div class="er es lq"><img src="../Images/fc1576afbff7e61dffaf9891861d94fe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1010/format:webp/1*7F_kYSnnIkUzd72a87owlQ.png"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">输出会是什么？</figcaption></figure><p id="778a" class="pw-post-body-paragraph jt ju hi jv b jw kx jy jz ka ky kc kd ke kz kg kh ki la kk kl km lb ko kp kq hb bi translated">是的，正如我们预测的那样，我们得到的输出是<code class="du lc ld le lf b">undefined</code>。</p><h1 id="8346" class="iv iw hi bd ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js bi translated">同名变量在不同作用域声明怎么办？</h1><p id="d1bb" class="pw-post-body-paragraph jt ju hi jv b jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq hb bi translated">这又是一个令人兴奋的问题！让我们考虑这个代码:</p><figure class="kt ku kv kw fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lr"><img src="../Images/78470c31b9dea436548e02fa236ff8d8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WTG64w8NJu-oW2zes3kGcA.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">输出会是什么？</figcaption></figure><p id="14bd" class="pw-post-body-paragraph jt ju hi jv b jw kx jy jz ka ky kc kd ke kz kg kh ki la kk kl km lb ko kp kq hb bi translated">让我们从逻辑上来看这个问题。由于提升，第 1 行的<code class="du lc ld le lf b">console.log(count)</code>将打印<code class="du lc ld le lf b">undefined</code>。在这之后，函数<code class="du lc ld le lf b">counter()</code>被添加到调用堆栈中，并且<code class="du lc ld le lf b">counter()</code>函数有了它的执行上下文。由于变量<code class="du lc ld le lf b">count</code>在<code class="du lc ld le lf b">counter()</code>功能执行上下文中被提升，第 5 行的<code class="du lc ld le lf b">console.log()</code>将再次变为<code class="du lc ld le lf b">undefined</code>。接下来，第 9 行的<code class="du lc ld le lf b">console.log()</code>将打印<code class="du lc ld le lf b">2</code>，因为声明的<code class="du lc ld le lf b">count</code>变量将被赋值为<code class="du lc ld le lf b">2</code>。在执行阶段，它看起来像这样:</p><figure class="kt ku kv kw fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lr"><img src="../Images/d1dccba5c27cd00f6922e47e23d89df3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zZHinRx3n-MI1kmLjQpZIw.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">在执行阶段，它看起来会像这样。</figcaption></figure><p id="5e4b" class="pw-post-body-paragraph jt ju hi jv b jw kx jy jz ka ky kc kd ke kz kg kh ki la kk kl km lb ko kp kq hb bi translated">对于那些想知道的人，为什么前面代码中第 5 行的<code class="du lc ld le lf b">console.log()</code>语句没有打印出值:1？这是因为范围链。由于<code class="du lc ld le lf b">console.log()</code>语句在函数内(局部范围)，Javascript 将在<code class="du lc ld le lf b">counter()</code>函数内寻找变量<code class="du lc ld le lf b">count</code>。如果它遇到了变量，它将提供对遇到的变量的引用。否则，Javascript 将开始在全局范围内寻找变量(沿着范围链)。在我们的例子中，由于变量<code class="du lc ld le lf b">count</code>在<code class="du lc ld le lf b">counter()</code>函数的执行上下文中被提升，Javascript 返回存储在内存中的初始值(<code class="du lc ld le lf b">undefined</code>)。</p><blockquote class="lh li lj"><p id="9279" class="jt ju kr jv b jw kx jy jz ka ky kc kd lk kz kg kh ll la kk kl lm lb ko kp kq hb bi translated"><strong class="jv hj">注意</strong>:提升发生在创建阶段。上述过程发生在执行阶段，因此 Javascript 可以返回变量的值。</p></blockquote><p id="832e" class="pw-post-body-paragraph jt ju hi jv b jw kx jy jz ka ky kc kd ke kz kg kh ki la kk kl km lb ko kp kq hb bi translated">以下是上述代码的执行上下文的可视化表示:</p><figure class="kt ku kv kw fd ij"><div class="bz dy l di"><div class="ls lt l"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">可视化工具链接:<a class="ae iu" href="https://ui.dev/javascript-visualizer/" rel="noopener ugc nofollow" target="_blank">https://ui.dev/javascript-visualizer/</a></figcaption></figure></div><div class="ab cl lu lv gp lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="hb hc hd he hf"><p id="236a" class="pw-post-body-paragraph jt ju hi jv b jw kx jy jz ka ky kc kd ke kz kg kh ki la kk kl km lb ko kp kq hb bi translated">现在，这都是关于可变提升。如果发生了提升，但是我们收到一个错误，该怎么办？让我们了解他们！</p><p id="33da" class="pw-post-body-paragraph jt ju hi jv b jw kx jy jz ka ky kc kd ke kz kg kh ki la kk kl km lb ko kp kq hb bi translated">让我们考虑一个例子。看一下这个简单的代码，然后猜猜输出会是什么:</p><figure class="kt ku kv kw fd ij er es paragraph-image"><div class="er es mb"><img src="../Images/37b11c67c637d8a898bcd26db871b021.png" data-original-src="https://miro.medium.com/v2/resize:fit:910/format:webp/1*czGzX6K17H4s-DrdBry4tQ.png"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">输出会是什么？</figcaption></figure><p id="884f" class="pw-post-body-paragraph jt ju hi jv b jw kx jy jz ka ky kc kd ke kz kg kh ki la kk kl km lb ko kp kq hb bi translated">嗯，如果你猜的是<code class="du lc ld le lf b">undefined</code>，那你就不正确。在这里，事情变得复杂。如果执行<strong class="jv hj"> </strong>这段代码，我们会得到一个错误:</p><figure class="kt ku kv kw fd ij er es paragraph-image"><div class="er es lo"><img src="../Images/e583ee744a45c9a091be481c921803fc.png" data-original-src="https://miro.medium.com/v2/resize:fit:786/format:webp/1*WfJy5GwjvVsU9e-iBsY7pg.png"/></div></figure><p id="d830" class="pw-post-body-paragraph jt ju hi jv b jw kx jy jz ka ky kc kd ke kz kg kh ki la kk kl km lb ko kp kq hb bi translated">为什么我们会收到一个错误？这是因为所谓的<strong class="jv hj">时间死区。</strong>当引擎遇到带有<code class="du lc ld le lf b">let</code>关键字的变量时，它会将变量添加到内存中，而不进行任何初始化(发生提升，但没有<code class="du lc ld le lf b">undefined</code>的值)。只有当引擎在运行时遇到它的实际声明(<code class="du lc ld le lf b">let count = 0</code>)时，变量才会被初始化。如果声明不包括初始化(<code class="du lc ld le lf b">let count;</code>)，那么引擎将为<code class="du lc ld le lf b">count</code>变量赋值<code class="du lc ld le lf b">undefined</code>。总之，在运行时引擎评估<code class="du lc ld le lf b">count</code>变量初始化之前，不能访问该变量。这被称为<strong class="jv hj">时间死区</strong>。我们收到这个错误是因为我们试图在变量创建和初始化之间访问<code class="du lc ld le lf b">count</code>变量。</p><blockquote class="lh li lj"><p id="9f56" class="jt ju kr jv b jw kx jy jz ka ky kc kd lk kz kg kh ll la kk kl lm lb ko kp kq hb bi translated"><strong class="jv hj">注意</strong> : Javascript 吊声明(<code class="du lc ld le lf b">var</code>、<code class="du lc ld le lf b">let</code>、<code class="du lc ld le lf b">const</code>、<code class="du lc ld le lf b">function</code>、<code class="du lc ld le lf b">class</code>)。这里唯一的概念是<code class="du lc ld le lf b">let</code>和<code class="du lc ld le lf b">const</code>声明没有初始化，但是<code class="du lc ld le lf b">var</code>声明是用<code class="du lc ld le lf b">undefined</code>初始化的。</p></blockquote><h1 id="c95f" class="iv iw hi bd ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js bi translated">结论</h1><p id="3f18" class="pw-post-body-paragraph jt ju hi jv b jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq hb bi translated">提升并不意味着 Javascript 代码被引擎移到顶部。它基于一个叫做词汇环境的概念。提升不仅发生在变量上。它出现在类、函数、变量等声明中。提升是默认的 Javascript 行为。为了避免提升的后果(未定义的变量)，我们应该在作用域的顶部声明我们的变量。</p></div><div class="ab cl lu lv gp lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="hb hc hd he hf"><p id="f624" class="pw-post-body-paragraph jt ju hi jv b jw kx jy jz ka ky kc kd ke kz kg kh ki la kk kl km lb ko kp kq hb bi translated">我的下一篇文章将讨论 Javascript 中的函数提升。如果你喜欢这篇文章，掌声会激励我写更多这样的文章😃。</p></div></div>    
</body>
</html>