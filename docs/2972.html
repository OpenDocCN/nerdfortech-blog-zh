<html>
<head>
<title>Swift Leetcode Series: Evaluate Reverse Polish Notation</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Swift Leetcode系列:评估反向波兰符号</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/swift-leetcode-series-evaluate-reverse-polish-notation-9ee82c527f68?source=collection_archive---------16-----------------------#2021-05-25">https://medium.com/nerd-for-tech/swift-leetcode-series-evaluate-reverse-polish-notation-9ee82c527f68?source=collection_archive---------16-----------------------#2021-05-25</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="18a8" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">堆栈+表达式= Leetcode 150🚀 🚀 🚀</h2></div><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ix"><img src="../Images/3f1ffb7db8d92c31e15aeb9798990937.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*R5ribEkCJM2gtNZofVhHlQ.png"/></div></div></figure><div class="jj jk ez fb jl jm"><a href="https://theswiftnerd.com/evaluate-reverse-polish-notation-leetcode/" rel="noopener  ugc nofollow" target="_blank"><div class="jn ab dw"><div class="jo ab jp cl cj jq"><h2 class="bd hj fi z dy jr ea eb js ed ef hh bi translated">评估反向波兰符号(Leetcode 150)</h2><div class="jt l"><h3 class="bd b fi z dy jr ea eb js ed ef dx translated">难度:链接:第25天:May Leetcode Challenge评估一个算术表达式在逆向波兰中的值…</h3></div><div class="ju l"><p class="bd b fp z dy jr ea eb js ed ef dx translated">theswiftnerd.com</p></div></div><div class="jv l"><div class="jw l jx jy jz jv ka jh jm"/></div></div></a></div><p id="043e" class="pw-post-body-paragraph kb kc hi kd b ke kf ij kg kh ki im kj kk kl km kn ko kp kq kr ks kt ku kv kw hb bi translated">点击上面的链接，阅读Swift Nerd博客上的完整故事。</p><h1 id="3355" class="kx ky hi bd kz la lb lc ld le lf lg lh io li ip lj ir lk is ll iu lm iv ln lo bi translated">问题描述</h1><p id="dc31" class="pw-post-body-paragraph kb kc hi kd b ke lp ij kg kh lq im kj kk lr km kn ko ls kq kr ks lt ku kv kw hb bi translated">评估<a class="ae lu" href="http://en.wikipedia.org/wiki/Reverse_Polish_notation" rel="noopener ugc nofollow" target="_blank">反向波兰符号</a>中算术表达式的值。</p><p id="6edf" class="pw-post-body-paragraph kb kc hi kd b ke kf ij kg kh ki im kj kk kl km kn ko kp kq kr ks kt ku kv kw hb bi translated">有效的运算符有<code class="du lv lw lx ly b">+</code>、<code class="du lv lw lx ly b">-</code>、<code class="du lv lw lx ly b">*</code>和<code class="du lv lw lx ly b">/</code>。每个操作数可以是整数或其他表达式。</p><p id="c703" class="pw-post-body-paragraph kb kc hi kd b ke kf ij kg kh ki im kj kk kl km kn ko kp kq kr ks kt ku kv kw hb bi translated"><strong class="kd hj">注意</strong>两个整数之间的除法应该向零截断。</p><p id="1a76" class="pw-post-body-paragraph kb kc hi kd b ke kf ij kg kh ki im kj kk kl km kn ko kp kq kr ks kt ku kv kw hb bi translated">保证给定的RPN表达式总是有效的。这意味着表达式将始终计算结果，并且不会有任何被零除的操作。</p><h1 id="6c60" class="kx ky hi bd kz la lb lc ld le lf lg lh io li ip lj ir lk is ll iu lm iv ln lo bi translated">例子</h1><pre class="iy iz ja jb fd lz ly ma mb aw mc bi"><span id="e8d0" class="md ky hi ly b fi me mf l mg mh"><strong class="ly hj">Input:</strong> tokens = ["2","1","+","3","*"]<br/><strong class="ly hj">Output:</strong> 9<br/><strong class="ly hj">Explanation:</strong> ((2 + 1) * 3) = 9</span><span id="7153" class="md ky hi ly b fi mi mf l mg mh"><strong class="ly hj">Input:</strong> tokens = ["4","13","5","/","+"]<br/><strong class="ly hj">Output:</strong> 6<br/><strong class="ly hj">Explanation:</strong> (4 + (13 / 5)) = 6</span><span id="5585" class="md ky hi ly b fi mi mf l mg mh"><strong class="ly hj">Input:</strong> tokens = ["10","6","9","3","+","-11","*","/","*","17","+","5","+"]<br/><strong class="ly hj">Output:</strong> 22<br/><strong class="ly hj">Explanation:</strong> ((10 * (6 / ((9 + 3) * -11))) + 17) + 5<br/>= ((10 * (6 / (12 * -11))) + 17) + 5<br/>= ((10 * (6 / -132)) + 17) + 5<br/>= ((10 * 0) + 17) + 5<br/>= (0 + 17) + 5<br/>= 17 + 5<br/>= 22</span></pre><h1 id="e82c" class="kx ky hi bd kz la lb lc ld le lf lg lh io li ip lj ir lk is ll iu lm iv ln lo bi translated">限制</h1><ul class=""><li id="3ab7" class="mj mk hi kd b ke lp kh lq kk ml ko mm ks mn kw mo mp mq mr bi translated"><code class="du lv lw lx ly b">1 &lt;= tokens.length &lt;= 104</code></li><li id="5e73" class="mj mk hi kd b ke ms kh mt kk mu ko mv ks mw kw mo mp mq mr bi translated"><code class="du lv lw lx ly b">tokens[i]</code>可以是运算符:<code class="du lv lw lx ly b">"+"</code>、<code class="du lv lw lx ly b">"-"</code>、<code class="du lv lw lx ly b">"*"</code>或<code class="du lv lw lx ly b">"/"</code>，也可以是范围<code class="du lv lw lx ly b">[-200, 200]</code>内的整数。</li></ul><h1 id="436f" class="kx ky hi bd kz la lb lc ld le lf lg lh io li ip lj ir lk is ll iu lm iv ln lo bi translated">解决办法</h1><p id="ce0c" class="pw-post-body-paragraph kb kc hi kd b ke lp ij kg kh lq im kj kk lr km kn ko ls kq kr ks lt ku kv kw hb bi translated">我们可以立即想到一种强力方法，在这种方法中，我们可以动态地评估结果。然而，当我们需要回溯一个嵌套表达式时，问题就出现了。<em class="mx">例如:</em></p><pre class="iy iz ja jb fd lz ly ma mb aw mc bi"><span id="c632" class="md ky hi ly b fi me mf l mg mh">Input : ["4","13","5","/","+"]<br/>Result : (4 + (13 / 5)) = 6</span></pre><p id="ebc2" class="pw-post-body-paragraph kb kc hi kd b ke kf ij kg kh ki im kj kk kl km kn ko kp kq kr ks kt ku kv kw hb bi translated">在这种情况下，我们可能不得不反向追踪整个数组，这将增加它的复杂度到O(N2)。我们需要想出一个更好的方法。</p><p id="45ce" class="pw-post-body-paragraph kb kc hi kd b ke kf ij kg kh ki im kj kk kl km kn ko kp kq kr ks kt ku kv kw hb bi translated">如果你知道<a class="ae lu" href="https://en.wikipedia.org/wiki/Reverse_Polish_notation" rel="noopener ugc nofollow" target="_blank">反向波兰符号</a>的历史，它是专门设计来通过更有效地使用<strong class="kd hj">堆栈</strong>使计算更容易。使用堆栈将使我们能够获得最后两个操作数，并轻松地存储结果值以供将来计算。因为给定输入总是有效的反向波兰表达式，因此我们在任何操作符之前至少有两个操作数(+ / — *)。还有一点需要注意的是，在<strong class="kd hj"> /和- </strong>的情况下，操作数的顺序很重要。所以如果输入是<strong class="kd hj">3 2—</strong>，那么结果应该是<strong class="kd hj">3–2</strong>而不是<strong class="kd hj">2–3</strong>。我们可以通过使用堆栈的顶部作为第二个操作数，并在其之后弹出的值作为第一个操作数来确保这一点。我们还需要将结果推回到堆栈中，最终结果会留在堆栈中，我们可以返回。</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="my mz l"/></div></figure><h1 id="1066" class="kx ky hi bd kz la lb lc ld le lf lg lh io li ip lj ir lk is ll iu lm iv ln lo bi translated">复杂性分析</h1><p id="301b" class="pw-post-body-paragraph kb kc hi kd b ke lp ij kg kh lq im kj kk lr km kn ko ls kq kr ks lt ku kv kw hb bi translated">我们对输入数组进行线性迭代，并弹出最后两个元素，以防遇到O(1)操作的操作符。因此，这是一个O(N)算法。对于空间，我们使用一个堆栈，在最坏的情况下，它会一次包含所有的元素。</p><p id="7b3e" class="pw-post-body-paragraph kb kc hi kd b ke kf ij kg kh ki im kj kk kl km kn ko kp kq kr ks kt ku kv kw hb bi translated"><strong class="kd hj">时间= O(N) </strong></p><p id="5d54" class="pw-post-body-paragraph kb kc hi kd b ke kf ij kg kh ki im kj kk kl km kn ko kp kq kr ks kt ku kv kw hb bi translated"><strong class="kd hj">空间= O(N) </strong></p></div><div class="ab cl na nb gp nc" role="separator"><span class="nd bw bk ne nf ng"/><span class="nd bw bk ne nf ng"/><span class="nd bw bk ne nf"/></div><div class="hb hc hd he hf"><p id="dd63" class="pw-post-body-paragraph kb kc hi kd b ke kf ij kg kh ki im kj kk kl km kn ko kp kq kr ks kt ku kv kw hb bi translated">感谢您的阅读。如果你喜欢这篇文章，并发现它很有用，请分享并像野火一样传播它！</p><p id="b55f" class="pw-post-body-paragraph kb kc hi kd b ke kf ij kg kh ki im kj kk kl km kn ko kp kq kr ks kt ku kv kw hb bi translated">你可以在<a class="ae lu" href="https://theswiftnerd.com/" rel="noopener ugc nofollow" target="_blank">网站</a>|<a class="ae lu" href="https://www.linkedin.com/in/varunrathi28/" rel="noopener ugc nofollow" target="_blank">LinkedIn</a>|<a class="ae lu" href="https://github.com/varunrathi28" rel="noopener ugc nofollow" target="_blank">Github</a>上找到我</p></div></div>    
</body>
</html>