# 逐步完善，50 年过去了

> 原文：<https://medium.com/nerd-for-tech/stepwise-refinement-50-years-on-196b2684d261?source=collection_archive---------11----------------------->

![](img/6d24738cf3d3d4b4cddfbd1d741d6df6.png)

布雷特·乔丹在 [Unsplash](https://unsplash.com?utm_source=medium&utm_medium=referral) 上的照片

**1971 年**，尼古拉斯·沃斯写了一篇经典论文:[逐步求精的程序开发](http://sunnyday.mit.edu/16.355/wirth-refinement.html)。在这篇论文中，他得出了四个结论；其中最后一个是:

> **4。对一个小程序开发的详细阐述形成了一个长故事，这表明精心编程不是一个微不足道的课题。如果这篇文章有助于消除人们普遍认为的只要编程语言足够强大，可用的计算机足够快，编程就很容易的看法，那么它就实现了它的一个目的。**

我们可以将此应用于任何复杂系统的设计。一个好的设计应该展示整体的完整性和清晰的目的。最终解决方案的完整性源于一系列可追溯的处理特定挑战的精心设计，可能围绕实现选择或与环境的交互。需要传达的不仅仅是这些讨论的结果，还有他们创造的*故事。*

不要认为逐步细化意味着对架构视图上的每个框和线进行简单的系统化扩展，不规则地重复，直到我们将它转化为云服务和业务逻辑的代码。一点也不。这是一个复杂而冗长的往复过程，各种模式的应用，以及不断的重构。然而贯穿这一切的是一个*叙事*带我们从目的到实现。这是令人兴奋的，令人愉快的，这正是我认为尼克劳斯所说的。

尽管是在五十年前写的，还是有必要仔细看看他的每一个结论以及它们与今天系统设计和构建的相关性。

首先:

> **1。**程序构建由一系列细化步骤组成。在每一步中，给定的任务被分解成许多子任务。任务描述中的每个细化都可能伴随着数据描述的细化，这些数据构成了子任务之间的通信方式。程序和数据结构描述的细化应该并行进行。

只要对*程序* → *系统*和*任务* → *组件*进行合理的替换，就会得到:

> **1’。** *系统*的构建由一系列的细化步骤组成。在每个步骤中，给定的*组件*被分解成多个子*组件*。在*组件*的描述中的每个细化可以伴随着构成子*组件*之间的通信手段的数据描述的细化。对*组件*和数据结构描述的细化应平行进行。

这是一个有用的简洁视图，展示了架构师和设计师如何在复杂的环境中管理复杂系统的方法。Wirth 没有限制“任务”的性质，因此它可以是操作系统进程、服务、Hadoop 集群，以及任何需要的东西。数据的结构化同等重要——任何系统图上的**行**都和方框一样重要。

让我们仔细阅读剩下的结论，同时在心里做同样的假设，因为我们是系统架构师而不是程序员。

> **2。**以这种方式获得的模块化程度将决定程序适应目的的变化或扩展或执行环境(语言、计算机)的变化的难易程度。

从架构角度来说，我们寻求模块之间的内聚性和松散耦合。我们寻求避免技术锁定。我们预见并拥抱变化。

> **3a。**在逐步细化的过程中，应尽可能长时间地使用对当前问题自然的符号。符号在细化过程中的发展方向是由程序最终必须被指定的语言决定的，也就是说，符号最终变得相同。因此，这种语言应该允许我们尽可能自然清晰地表达设计过程中出现的程序和数据的结构。

“手边问题的自然概念”——特定领域语言！不要在没有充分了解问题的情况下就急于找到解决方案；根据问题进行工作。在最适合表达问题的语言和用于实现问题的语言之间建立映射。这些天，我们可能在谈论一种符号，比如说，云的形成或地形脚本可以从这种符号中派生出来。或者 API，它们在领域中应该是有意义的，不受基于实现的过早决策的约束。

> **3b。**同时，它必须在提炼过程中给出指导，通过展示那些基本特征和结构化原则，这些原则是执行程序的机器所固有的。

“它”就是 DSL。通过我们的替换， *machine* 指的是一个执行环境，它可能不仅仅是一台机器；*程序*当然是指我们在一些复杂但协调的方案中执行任务的组件集合。我们应该增强我们的 DSL，以便能够反映我们的首选实现。这可能是基本的语法、合适的库或一些注释方法——以指示组件边界或并发执行。

> **3c。值得注意的是，很难找到一种语言能在较低程度上满足这些重要要求，而这种语言仍然是编程教学中最广泛使用的语言:Fortran。**

Fortran？突然，我们想起这是 20 世纪 70 年代早期。但是，我们必须问，JavaScript 适合“手头的问题”吗？云的形成，JSON 还是 YAML？可能不会——沃思尖刻的评论仍然是正确的。

> **3d。**每个细化都意味着基于一组设计标准的许多设计决策。这些标准包括效率、存储经济性、清晰度和结构的规则性。

带来非功能性需求。

> **3e。必须教育学生意识到所涉及的决策，批判性地检查和拒绝解决方案，有时即使就结果而言它们是正确的；他们必须学会根据这些标准来权衡设计方案的各个方面。**

进入建筑权衡分析。这就是区分好的和一般的，一般的和坏的。这里恰当的决策将导致系统正常工作——它们将满足功能需求，并且可能在大部分时间都是正常的。这里好的决策将会产生有效的系统——它们将满足 nfr，并且它们将随着时间的推移继续发展和改进。

> **3f。特别是，必须教会他们撤销早先的决定，并支持，如果必要的话，甚至到高层。相对较短的样本问题通常足以说明这一点；没有必要为此目的构建操作系统。**

简而言之，避免技术债，愿意重因子。不要满足于第一个选择，但要不断寻求更好的，即使你没有选择它的奢侈。

沃思的第四个也是最后一个结论是我们开始时的结论；精炼的叙述(也许)和结果一样重要。如果你只是根据一个有效的系统来判断的话，这可能并不明显。在以后的许多年里，拥有叙述将使任何人更容易理解系统和驱动其设计的力量，从而安全和自信地进行改变，以使系统适应新的要求、新的环境，并利用当时不可用或不明智的新机会。逐步细化；字面上和比喻上。

*修改自 2021 年 7 月的原始博文。*