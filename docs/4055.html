<html>
<head>
<title>Sort Colors</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">排序颜色</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/sort-colors-a0f5e7354b6d?source=collection_archive---------29-----------------------#2021-07-04">https://medium.com/nerd-for-tech/sort-colors-a0f5e7354b6d?source=collection_archive---------29-----------------------#2021-07-04</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><h1 id="2b8e" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated"><strong class="ak">问题陈述</strong></h1><div class="jd je ez fb jf jg"><a href="https://leetcode.com/problems/sort-colors/" rel="noopener  ugc nofollow" target="_blank"><div class="jh ab dw"><div class="ji ab jj cl cj jk"><h2 class="bd hj fi z dy jl ea eb jm ed ef hh bi translated">排序颜色- LeetCode</h2><div class="jn l"><h3 class="bd b fi z dy jl ea eb jm ed ef dx translated">给定一个数组 nums，包含 n 个红色、白色或蓝色的对象，对它们进行排序，使相同颜色的对象…</h3></div><div class="jo l"><p class="bd b fp z dy jl ea eb jm ed ef dx translated">leetcode.com</p></div></div><div class="jp l"><div class="jq l jr js jt jp ju jv jg"/></div></div></a></div><h1 id="1bbd" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated"><strong class="ak">天真的解决方案</strong></h1><p id="cadf" class="pw-post-body-paragraph jw jx hi jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt hb bi translated">解决这个问题的第一个方法是对数组进行排序。因此，如果我们使用像合并排序这样的排序技术，这种方法将在<em class="ku"> O(nlogn) </em>中工作。这就是这个问题的天真解决方案。</p><pre class="kv kw kx ky fd kz la lb lc aw ld bi"><span id="37a7" class="le ig hi la b fi lf lg l lh li">class Solution:<br/>    def sortColors(self, nums: List[int]) -&gt; None:<br/>        nums.sort()</span></pre><p id="824e" class="pw-post-body-paragraph jw jx hi jy b jz lj kb kc kd lk kf kg kh ll kj kk kl lm kn ko kp ln kr ks kt hb bi translated"><em class="ku">时间复杂度:O(nlogn) </em></p><p id="0709" class="pw-post-body-paragraph jw jx hi jy b jz lj kb kc kd lk kf kg kh ll kj kk kl lm kn ko kp ln kr ks kt hb bi translated"><em class="ku">空间复杂度:没有多余的空间</em></p><h1 id="711c" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated"><strong class="ak">高效解决方案</strong></h1><p id="dddd" class="pw-post-body-paragraph jw jx hi jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt hb bi translated">高效的方法是取 3 个指针，即<strong class="jy hj"> <em class="ku">低</em></strong><em class="ku"/><strong class="jy hj"><em class="ku">高</em></strong><em class="ku"/>和<em class="ku"> </em> <strong class="jy hj"> <em class="ku">中</em> </strong>。从第 0 个索引开始将<em class="ku">低位</em>和<em class="ku">中间</em>指针和<em class="ku">高位</em>指针指向最后一个索引。现在考虑 3 种情况:</p><ol class=""><li id="31c4" class="lo lp hi jy b jz lj kd lk kh lq kl lr kp ls kt lt lu lv lw bi translated">一旦<em class="ku">中</em>指针到达值为 0 的元素，就将其与<em class="ku">低</em>指针值交换，并将两个指针都增加 1。</li><li id="8270" class="lo lp hi jy b jz lx kd ly kh lz kl ma kp mb kt lt lu lv lw bi translated">如果<em class="ku">中间</em>指针到达值为 1 的元素，那么简单地将<em class="ku">中间</em>指针增加 1</li><li id="80dc" class="lo lp hi jy b jz lx kd ly kh lz kl ma kp mb kt lt lu lv lw bi translated">如果<em class="ku">中</em>指针到达值为 2 的元素，则将其与<em class="ku">高</em>指针值交换，并减少<em class="ku">高</em>指针。</li></ol><p id="9676" class="pw-post-body-paragraph jw jx hi jy b jz lj kb kc kd lk kf kg kh ll kj kk kl lm kn ko kp ln kr ks kt hb bi translated">这将持续到中间≤高。</p><pre class="kv kw kx ky fd kz la lb lc aw ld bi"><span id="7ebc" class="le ig hi la b fi lf lg l lh li">class Solution:<br/>    def sortColors(self, nums: List[int]) -&gt; None:<br/>        low = 0<br/>        high = len(nums) - 1<br/>        mid = 0<br/>        while (mid &lt;= high):<br/>            if nums[mid] == 0:<br/>                nums[low], nums[mid] = nums[mid], nums[low]<br/>                low += 1<br/>                mid += 1<br/>            elif nums[mid] == 1:<br/>                mid += 1<br/>            else:<br/>                nums[high], nums[mid] = nums[mid], nums[high]<br/>                high -= 1<br/>        return nums</span></pre><p id="772c" class="pw-post-body-paragraph jw jx hi jy b jz lj kb kc kd lk kf kg kh ll kj kk kl lm kn ko kp ln kr ks kt hb bi translated">在这个解决方案中，我们确保 low 左边的所有元素都是 0，high 右边的所有元素都是 2。</p><p id="c7ba" class="pw-post-body-paragraph jw jx hi jy b jz lj kb kc kd lk kf kg kh ll kj kk kl lm kn ko kp ln kr ks kt hb bi translated"><em class="ku">时间复杂度:O(n) </em></p><p id="77b6" class="pw-post-body-paragraph jw jx hi jy b jz lj kb kc kd lk kf kg kh ll kj kk kl lm kn ko kp ln kr ks kt hb bi translated"><em class="ku">空间复杂度:O(1) </em></p><p id="4516" class="pw-post-body-paragraph jw jx hi jy b jz lj kb kc kd lk kf kg kh ll kj kk kl lm kn ko kp ln kr ks kt hb bi translated">这个问题就这么多了。如果你有任何疑问或者想让我就任何具体问题写博客，请写下来。</p><p id="8264" class="pw-post-body-paragraph jw jx hi jy b jz lj kb kc kd lk kf kg kh ll kj kk kl lm kn ko kp ln kr ks kt hb bi translated">继续求解！</p></div></div>    
</body>
</html>