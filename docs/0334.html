<html>
<head>
<title>Java Memory Explained</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Java 内存解释</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/java-memory-explained-43de6de157be?source=collection_archive---------1-----------------------#2020-10-03">https://medium.com/nerd-for-tech/java-memory-explained-43de6de157be?source=collection_archive---------1-----------------------#2020-10-03</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="4aa2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">每个 Java 应用程序都需要内存才能在 JVM 上运行。该内存取自运行应用程序的系统的可用<strong class="ih hj"> RAM </strong>。有两种内存:堆栈和堆。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es jd"><img src="../Images/3cdd565ae8d0d2386c2c0117487b1d45.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hrmy-d6MACHKFmHubRXBJA.png"/></div></div></figure><h1 id="c881" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">堆</h1><p id="3f85" class="pw-post-body-paragraph if ig hi ih b ii kn ik il im ko io ip iq kp is it iu kq iw ix iy kr ja jb jc hb bi translated">它是 RAM 中用来存储 Java 中的临时变量或原始数据类型的区域。它还存储在堆中物理创建的对象的引用。</p><p id="cf1c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">它以<strong class="ih hj">后进先出(LIFO) </strong>格式存储函数创建的变量，并在函数退出时释放所有分配的内存。</p><p id="668e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在 Java 中，堆栈是为每个线程管理的，所以它的作用域在线程内。与堆的大小相比，它更小。</p><p id="c0b4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">堆栈更快，因为与堆相比，内存分配/释放更简单。</p><p id="9197" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">当方法调用发生时，将在该线程的堆栈上创建一个新的堆栈框架。堆栈将包含局部变量、参数、返回地址等。</p><h1 id="b830" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">许多</h1><p id="de90" class="pw-post-body-paragraph if ig hi ih b ii kn ik il im ko io ip iq kp is it iu kq iw ix iy kr ja jb jc hb bi translated">这是一个较大的 RAM 区域，用于动态内存分配。所有 Java 对象都存储在堆中，对象的范围是整个应用程序。</p><p id="23c3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">内存管理由我们在 heap 中管理，但未使用的对象由<strong class="ih hj">垃圾收集器</strong>自动清除。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es ks"><img src="../Images/83707a2d180e3a9aa1887e8712d039d2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DQCJWGvERtOBV3nB4kpt-A.png"/></div></div><figcaption class="kt ku et er es kv kw bd b be z dx translated">一个程序如何在栈和堆中给 Java 变量和对象分配内存？</figcaption></figure></div><div class="ab cl kx ky gp kz" role="separator"><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc"/></div><div class="hb hc hd he hf"><h1 id="7fba" class="jp jq hi bd jr js le ju jv jw lf jy jz ka lg kc kd ke lh kg kh ki li kk kl km bi translated">堆划分:年轻一代和老一代</h1><p id="3fd5" class="pw-post-body-paragraph if ig hi ih b ii kn ik il im ko io ip iq kp is it iu kq iw ix iy kr ja jb jc hb bi translated">垃圾收集在堆内存上运行，以<strong class="ih hj">移除没有任何引用的对象</strong>。引用意味着堆栈中没有指针指向堆中某处存在的对象。</p><p id="92a7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">堆分为<strong class="ih hj"> 2 个部分</strong>:年轻一代和老一代进行高效的垃圾收集。<strong class="ih hj">年轻一代</strong>(堆的第一部分)进一步分为三部分:</p><ul class=""><li id="28a6" class="lj lk hi ih b ii ij im in iq ll iu lm iy ln jc lo lp lq lr bi translated"><strong class="ih hj">伊甸园</strong>是对象在<strong class="ih hj">第一次初始化</strong>时存储的地方。比 S0 和 S1 的总和还要大。</li><li id="7392" class="lj lk hi ih b ii ls im lt iq lu iu lv iy lw jc lo lp lq lr bi translated"><strong class="ih hj"> Survivor 0 (S0) </strong>是运行次要 GC 时对象移入的位置。当 Eden 空间已满时，运行次要 GC。不使用的对象被从年轻一代中移除，而使用过的对象被移动到幸存者空间。</li><li id="e134" class="lj lk hi ih b ii ls im lt iq lu iu lv iy lw jc lo lp lq lr bi translated"><strong class="ih hj">幸存者 1 (S1) </strong></li></ul><p id="41d8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为年轻一代对象设置阈值以被认为是老一代。当阈值被突破时，对象被移动到老一代。</p><p id="828e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">老一代(</strong><strong class="ih hj"/>堆<strong class="ih hj"> ) </strong>的第二部分是用来<strong class="ih hj">存放长寿命对象</strong>。它也需要被垃圾收集。这是由名为<strong class="ih hj">主 GC </strong>的进程完成的。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es lx"><img src="../Images/233eb2540da82502896f1b66ab7a50dc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*z9yKoVeIMoHFzRt7dOgOzg.png"/></div></div><figcaption class="kt ku et er es kv kw bd b be z dx translated">堆分裂成年轻和老一代</figcaption></figure></div><div class="ab cl kx ky gp kz" role="separator"><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc"/></div><div class="hb hc hd he hf"><h1 id="ed73" class="jp jq hi bd jr js le ju jv jw lf jy jz ka lg kc kd ke lh kg kh ki li kk kl km bi translated">需要记住的要点</h1><ol class=""><li id="3825" class="lj lk hi ih b ii kn im ko iq ly iu lz iy ma jc mb lp lq lr bi translated">在 Java 8 中，PermGen 被重命名为元空间，这个元空间有一个无限制的默认最大大小。相反，Java 7 和更早版本的 PermGen 在 32 位 JVM 上的默认最大大小是 64 MB，在 64 位版本上是 82 MB。</li><li id="7b04" class="lj lk hi ih b ii ls im lt iq lu iu lv iy lw jc mb lp lq lr bi translated">在 Java 7 之前，被拘留的字符串通常保存在 PermGen 中。这有时会导致以下异常:<code class="du mc md me mf b"><strong class="ih hj">java.lang.OutOfMemoryError: PermGen </strong>space</code></li><li id="1eb8" class="lj lk hi ih b ii ls im lt iq lu iu lv iy lw jc mb lp lq lr bi translated">每当需要调整 PermGen/Metaspace 的大小时，JVM 都会像处理标准堆一样进行。调整这些空间的大小需要一个完整的 GC。</li><li id="5a0f" class="lj lk hi ih b ii ls im lt iq lu iu lv iy lw jc mb lp lq lr bi translated">如果<strong class="ih hj">栈</strong>中没有剩余内存用于存储函数调用或局部变量，JVM 将抛出<code class="du mc md me mf b"><strong class="ih hj">java.lang.StackOverFlowError</strong></code>，而如果没有更多<strong class="ih hj">堆空间</strong>用于创建对象，JVM 将抛出<code class="du mc md me mf b"><strong class="ih hj">java.lang.OutOfMemoryError</strong>: Java Heap Space</code>。</li><li id="9659" class="lj lk hi ih b ii ls im lt iq lu iu lv iy lw jc mb lp lq lr bi translated"><strong class="ih hj"> -Xss </strong>设置线程堆栈大小。线程堆栈是分配给每个 Java 线程供其内部使用的内存区域。这是线程存储其本地执行状态的地方。堆栈的默认值因平台而异。</li><li id="7003" class="lj lk hi ih b ii ls im lt iq lu iu lv iy lw jc mb lp lq lr bi translated"><strong class="ih hj"> -Xms </strong>和<strong class="ih hj"> -Xmx </strong>用于定义堆内存的启动初始和最大大小。</li><li id="ec2b" class="lj lk hi ih b ii ls im lt iq lu iu lv iy lw jc mb lp lq lr bi translated">所有 Java 对象都存储在堆内存中。</li><li id="a404" class="lj lk hi ih b ii ls im lt iq lu iu lv iy lw jc mb lp lq lr bi translated"><strong class="ih hj">字符串是不可变的</strong>，每当一个新的字符串值赋给一个变量，堆中就会创建一个新的对象，栈中的引用变量指向堆中的那个位置。</li></ol><h1 id="bb1a" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">结论</h1><p id="57ed" class="pw-post-body-paragraph if ig hi ih b ii kn ik il im ko io ip iq kp is it iu kq iw ix iy kr ja jb jc hb bi translated">我试图写 Java 应用程序如何在 RAM 中为它的变量和对象分配内存。程序的哪个部分存储在内存的哪个部分？在我的下一篇文章中，我将尝试讲述 Java 中的垃圾收集是如何工作的。</p><p id="0535" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">感谢阅读！</p></div></div>    
</body>
</html>