<html>
<head>
<title>Avoid Telescoping constructors with the Builder pattern</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">避免使用构建器模式伸缩构造器</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/avoid-telescoping-constructors-with-the-builder-pattern-2114b75360b7?source=collection_archive---------10-----------------------#2021-05-25">https://medium.com/nerd-for-tech/avoid-telescoping-constructors-with-the-builder-pattern-2114b75360b7?source=collection_archive---------10-----------------------#2021-05-25</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div class="er es if"><img src="../Images/73d4733fc687c1548c15b414918d7889.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/1*BNwThGhIiSF3B0dbOVI-ew.jpeg"/></div><figcaption class="im in et er es io ip bd b be z dx translated">图片来自<a class="ae iq" href="https://pixabay.com/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=516559" rel="noopener ugc nofollow" target="_blank"> Pixabay </a>的<a class="ae iq" href="https://pixabay.com/users/sttimm-265330/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=516559" rel="noopener ugc nofollow" target="_blank"> Steffi Timm </a></figcaption></figure><p id="c867" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi jp translated"><span class="l jq jr js bm jt ju jv jw jx di">在</span>有些情况下，一个应用需要多个 C <em class="jy">构造器</em>。这可能是由于用户的要求。但是多重<em class="jy">构造函数</em>的问题是，如果参数太多，你的代码可能会变得难看(太复杂)。看看下面的例子。</p><figure class="jz ka kb kc fd ij"><div class="bz dy l di"><div class="kd ke l"/></div></figure><p id="0d33" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">然而，一些程序员并没有像上面那样实现<em class="jy">构造函数</em>，而是使用了所谓的<em class="jy">伸缩</em>构造函数<em class="jy">。</em></p><p id="4b96" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">因此，这里有一个如何使用<em class="jy">伸缩构造函数</em>的例子。这只是一种方法(在这个例子中你可以看到<em class="jy">构造函数</em>引用前面的<em class="jy">构造函数</em>来赋值)。</p><p id="1b0f" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">按照这种方法，一个<em class="jy">伸缩构造器</em>中可以有多个<em class="jy">构造器</em>，每个<em class="jy">构造器</em>可以根据参数使用另一个<em class="jy">构造器</em>。(自己看下面的例子)。</p><figure class="jz ka kb kc fd ij"><div class="bz dy l di"><div class="kd ke l"/></div></figure><p id="def5" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">这里是<em class="jy">伸缩</em> <em class="jy">构造器</em>的另一种方法，与上面不同。</p><figure class="jz ka kb kc fd ij"><div class="bz dy l di"><div class="kd ke l"/></div></figure><p id="d586" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">但是这是一个糟糕的方法(使用<em class="jy">伸缩构造函数</em>)。因为这有点复杂，你可以看到我们到处传递空值(有太多的<em class="jy">空值</em>，我们很容易得到<em class="jy">空值指针异常</em>)。所以，这就是我们要用构建器模式来回答的问题。</p><blockquote class="kf kg kh"><p id="e0cd" class="ir is jy it b iu iv iw ix iy iz ja jb ki jd je jf kj jh ji jj kk jl jm jn jo hb bi translated">你可能认为我们可以使用<em class="hi">设置器</em>，来分配变量值，而不是有多个<em class="hi">构造器</em>。但是 setter<em class="hi"/>的问题是它们不是不可变的。因此，一旦创建了对象，任何人都可以对其进行更改。因此<em class="hi">设置器</em>在某些情况下可能不是理想的选择。</p></blockquote><p id="4447" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">所以让我们来看看如何一步一步地解决这个问题。我们正在进行“<em class="jy">一个员工的月薪是如何产生的</em>”的考试场景。在月薪中，我们有<em class="jy">员工姓名、员工邮箱、基本工资、车补</em>和<em class="jy">奖金</em>等变量。</p><p id="b8a5" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">首先，我们将所有这些变量放入<code class="du kl km kn ko b">MonthlySalary </code>类，并将另一个名为<code class="du kl km kn ko b">builder</code>的<em class="jy">静态</em> <em class="jy">内部类</em>添加到<code class="du kl km kn ko b">MonthlySalary </code>类中。</p><figure class="jz ka kb kc fd ij"><div class="bz dy l di"><div class="kd ke l"/></div></figure><p id="8137" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">因为我们有两个“必备”参数(<code class="du kl km kn ko b">empId</code>、<code class="du kl km kn ko b">basicSalary</code>)，我们将把它们作为参数传递给<em class="jy">构造函数</em>。所以，在对象创建时，它们总是被传递(如下)。</p><pre class="jz ka kb kc fd kp ko kq kr aw ks bi"><span id="930c" class="kt ku hi ko b fi kv kw l kx ky">  // required parameter<br/>  public MonthlySalaryBuilder(String empId, String basicSalary) {<br/>     this.empId = empId;<br/>     this.basicSalary = basicSalary;<br/>  }</span></pre><p id="1978" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">现在，让我们创建一些方法来为其他变量赋值。并且让我们把我们的<code class="du kl km kn ko b">MonthlySalary</code>类的变量<code class="du kl km kn ko b">final</code>(所以它们是不可变的)。</p><p id="524b" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">例如:</p><pre class="jz ka kb kc fd kp ko kq kr aw ks bi"><span id="fb9f" class="kt ku hi ko b fi kv kw l kx ky">  //set value of employee email<br/>  public MonthlySalaryBuilder addEmpEmail(String empEmail) {<br/>      this.empEmail = empEmail;<br/>      return this;<br/>  }</span></pre><p id="b05d" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">好了，现在我们差不多完成了。为了完成一切，添加一个名为<code class="du kl km kn ko b">build()</code>的方法来返回一个<code class="du kl km kn ko b">MonthlySalary</code>和一个<code class="du kl km kn ko b">toString()</code>的实例。</p><figure class="jz ka kb kc fd ij"><div class="bz dy l di"><div class="kd ke l"/></div></figure><p id="f9ce" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">输出:</p><pre class="jz ka kb kc fd kp ko kq kr aw ks bi"><span id="9ba9" class="kt ku hi ko b fi kv kw l kx ky">Employee Salary (telescoping-1) - Id: EMP-TC-1 Email: null Basic salary: null Motor car allowance: null Bonus: null</span><span id="8635" class="kt ku hi ko b fi kz kw l kx ky">Employee Salary (telescoping-2) - Id: EMP-TC-2 Email: null Basic salary: null Motor car allowance: null Bonus: null</span><span id="3e9f" class="kt ku hi ko b fi kz kw l kx ky">Employee Salary (Builder) - Id: EMP0001 Email: johnDoe@gmail.com Basic salary: 999.0 Motor car allowance: 250.0 Bonus: null</span></pre><p id="65b1" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">现在你可以看到，我们用构建器模式得到了相同的结果，但是我们没有使用多个<em class="jy">构造器</em>，任何<em class="jy">设置器</em>，而且我们的属性也是不可变的。此外，我们不需要传递任何空值。假设你有一个有 10 个参数的构造函数，你想在运动中传递一个参数。对于其余的参数，您必须传递 9 个空值。</p><p id="444d" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">然而，缺点之一是最初你必须做一些实现构建器模式的编码。</p><p id="1b3e" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">我希望您已经理解了构建器模式的概念。如果你正在寻找上述代码，我已经把它们保存在我的回购这里。</p><div class="la lb ez fb lc ld"><a href="https://github.com/Hasitha-Su/Krish-LP-Training.git" rel="noopener  ugc nofollow" target="_blank"><div class="le ab dw"><div class="lf ab lg cl cj lh"><h2 class="bd hj fi z dy li ea eb lj ed ef hh bi translated">hasit ha-Su/Krish-LP-培训</h2><div class="lk l"><h3 class="bd b fi z dy li ea eb lj ed ef dx translated">通过在 GitHub 上创建一个帐户，为 Hasitha-Su/Krish-LP-Training 开发做出贡献。</h3></div><div class="ll l"><p class="bd b fp z dy li ea eb lj ed ef dx translated">github.com</p></div></div><div class="lm l"><div class="ln l lo lp lq lm lr ik ld"/></div></div></a></div></div><div class="ab cl ls lt gp lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="hb hc hd he hf"><h2 id="3bf2" class="kt ku hi bd lz ma mb mc md me mf mg mh jc mi mj mk jg ml mm mn jk mo mp mq mr bi translated">参考</h2><figure class="jz ka kb kc fd ij"><div class="bz dy l di"><div class="ms ke l"/></div></figure><div class="la lb ez fb lc ld"><a href="https://www.journaldev.com/1425/builder-design-pattern-in-java" rel="noopener  ugc nofollow" target="_blank"><div class="le ab dw"><div class="lf ab lg cl cj lh"><h2 class="bd hj fi z dy li ea eb lj ed ef hh bi translated">Java - JournalDev 中的生成器设计模式</h2><div class="lk l"><h3 class="bd b fi z dy li ea eb lj ed ef dx translated">今天我们将研究 java 中的构建器模式。生成器设计模式是一种创造性的设计模式，就像工厂…</h3></div><div class="ll l"><p class="bd b fp z dy li ea eb lj ed ef dx translated">www.journaldev.com</p></div></div><div class="lm l"><div class="mt l lo lp lq lm lr ik ld"/></div></div></a></div></div></div>    
</body>
</html>