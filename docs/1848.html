<html>
<head>
<title>What is a Java Agent and what is it for?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">什么是Java代理，它有什么用途？</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/what-is-a-java-agent-and-what-is-it-for-7a7896729c76?source=collection_archive---------5-----------------------#2021-04-10">https://medium.com/nerd-for-tech/what-is-a-java-agent-and-what-is-it-for-7a7896729c76?source=collection_archive---------5-----------------------#2021-04-10</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div class="er es if"><img src="../Images/4f18a6c2cf9afb43749401061b8899b6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1024/format:webp/1*PqorzZ7V4hcNdeIhDeMk1g.png"/></div></figure><p id="aa78" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">最近，我们在那些帖子中看到了如何执行一些监控任务。今天我们将看到Java代理，它们是什么以及它们是如何工作的。这也可以帮助我们执行监测任务等。在这篇文章中，我们将尝试解释一些东西，首先是一些理论，然后是例子的帮助。</p><p id="5549" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">什么是Java代理？，它们基本上是Java库，包括实现Java Instrumentation API的类。从JDK 1.5版开始提供。这是一个非常简单的API，但同时也非常强大。它为应用程序检测奠定了基础。</p><p id="5870" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">这个工具的主要功能是允许我们向某些类添加代码。有了这个附加功能，我们将能够重新编译主要用于监控和分析或事件记录的数据。允许我们获得有关应用程序的重要信息，这可以帮助我们解决问题或获得数据，否则这是不可能的。</p><p id="869c" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">这个插装API的主要特点是改变虚拟机正在执行的类的字节码。通过这种改变，我们将能够执行前面指出的操作。</p><p id="8a6c" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">但是让我们来关注一下，创建一个Java代理需要什么？我们只需遵循以下三个步骤:</p><ol class=""><li id="f001" class="jk jl hi io b ip iq it iu ix jm jb jn jf jo jj jp jq jr js bi translated">制定具体的方法。</li><li id="e242" class="jk jl hi io b ip jt it ju ix jv jb jw jf jx jj jp jq jr js bi translated">创建并正确配置清单。MF文件。</li><li id="2359" class="jk jl hi io b ip jt it ju ix jv jb jw jf jx jj jp jq jr js bi translated">告诉虚拟机用Java代理考虑我们的库。</li></ol><p id="ed2e" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">开发方法取决于我们何时希望代理与JVM中应用程序的执行相关联。检测API将为我们提供两种不同的方法:</p><ul class=""><li id="65c7" class="jk jl hi io b ip iq it iu ix jm jb jn jf jo jj jy jq jr js bi translated">premain :它将允许在JVM中执行任何其他应用程序之前执行Java代理及其相关方法。在JVM启动时必须指示Java代理。</li><li id="e795" class="jk jl hi io b ip jt it ju ix jv jb jw jf jx jj jy jq jr js bi translated"><em class="jz"> agentmain </em>:一旦JVM已经在运行一个应用程序，它将允许Java代理的执行。这种关联必须以编程方式完成。</li></ul><p id="c613" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">清单的创建。MF文件必须手动完成，尽管它可以通过maven插件包含在相关联的jar中。在这个文件中，我们必须配置不同的属性。一方面，它是包含Java代理方法及其行为属性的类。主要的有:</p><ul class=""><li id="4e97" class="jk jl hi io b ip iq it iu ix jm jb jn jf jo jj jy jq jr js bi translated">Premain-Class:表示实现<em class="jz"> premain </em>方法的类。</li><li id="a8a6" class="jk jl hi io b ip jt it ju ix jv jb jw jf jx jj jy jq jr js bi translated">Agent-Class:表示实现<em class="jz"> agentmain </em>方法的类。</li><li id="ef10" class="jk jl hi io b ip jt it ju ix jv jb jw jf jx jj jy jq jr js bi translated">Can-Redefine-Classes:表示Java代理是否可以重定义它所干涉的类。</li><li id="1da2" class="jk jl hi io b ip jt it ju ix jv jb jw jf jx jj jy jq jr js bi translated">Can-Retransform-Classes:这允许指明Java代理是否可以转换干扰类。</li></ul><p id="cf98" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">一旦我们开发了执行逻辑的方法并正确配置了清单文件，我们就可以生成库了。为此，我们可以使用几个maven插件，这将使我们的工作更容易:</p><ul class=""><li id="faae" class="jk jl hi io b ip iq it iu ix jm jb jn jf jo jj jy jq jr js bi translated">maven-shade-plugin:它允许我们创建包含依赖项的库，以防万一。</li><li id="db97" class="jk jl hi io b ip jt it ju ix jv jb jw jf jx jj jy jq jr js bi translated">maven-jar-plugin:允许我们将清单文件与要创建的库相关联。</li></ul><figure class="ka kb kc kd fd ij"><div class="bz dy l di"><div class="ke kf l"/></div></figure><p id="3cb0" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">一旦我们有了这个库，第三步就是将它与JVM关联起来。如前所述，这可以通过两种方式实现:</p><p id="65a4" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">如果我们已经实现了<em class="jz"> premain </em>方法并配置了Premain-Class属性，我们将不得不在启动我们想要干扰的应用程序时指明库。示例:</p><pre class="ka kb kc kd fd kg kh ki kj aw kk bi"><span id="aa67" class="kl km hi kh b fi kn ko l kp kq">java -javaagent:/full/path/to/javaAgent.jar -jar app.jar</span></pre><p id="21ec" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">如果我们实现了<em class="jz"> agentmain </em>方法并配置了代理类属性，我们必须通过Java Attach API以编程方式关联Java代理。</p><pre class="ka kb kc kd fd kg kh ki kj aw kk bi"><span id="bbe7" class="kl km hi kh b fi kn ko l kp kq">File agentFile = Paths.get("agent.jar").toFile();<br/>VirtualMachine jvm = VirtualMachine.attach(VirtualMachine.list().get(<strong class="kh hj">0</strong>).id());<br/>jvm.loadAgent(agentFile.getAbsolutePath());<br/>// jvm.detach(); //to finish association</span></pre><p id="2672" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">现在我们知道了理论，所以我们可以去实践了。让我们看几个例子。一个简单基本，另一个稍微复杂一点。</p><p id="9691" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">在最简单的例子中，我们将只实现<em class="jz"> premain </em>方法，并且我们将设置几个与其执行相关的日志。</p><figure class="ka kb kc kd fd ij"><div class="bz dy l di"><div class="ke kf l"/></div></figure><p id="3d38" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">例如，如果我们执行典型的<em class="jz">静态void main </em>方法，并添加java代理作为JVM参数，我们可以看到类似如下的输出:</p><pre class="ka kb kc kd fd kg kh ki kj aw kk bi"><span id="3adc" class="kl km hi kh b fi kn ko l kp kq">[INFO ] 2021-03-04 [main] BasicAgentExample - Start from premain. agentArgs: null<br/>[INFO ] 2021-03-04 [main] BasicAgentExample - Classname: sun/misc/PostVMInitHook</span><span id="ae62" class="kl km hi kh b fi kr ko l kp kq">....</span></pre><p id="3792" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">正如我们所看到的，如果我们稍微看一下Instrumentation对象中可用的方法，我们将有可能转换或重新定义一个类的功能。但是这必须通过修改这些类的字节的复杂操作来完成。</p><p id="014e" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">在下面这个更复杂的例子中，我们将转换将要干预的类。但是正如我们已经指出的，这些操作是复杂的。因此，为了更容易地执行它们，我们将利用<a class="ae ks" href="https://github.com/raphw/byte-buddy" rel="noopener ugc nofollow" target="_blank">字节伙伴库</a>。</p><p id="7ac6" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">这个例子的想法是创建一个Java代理，它允许我们测量某个方法被调用了多少次。此外，我们还将过滤我们想要干预的类，避免在我们不感兴趣的类上执行任务，例如来自JVM的那些类。在我们的例子中，我们将只干预那些扩展抽象类的类中的方法。</p><p id="ff21" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">首先，我们实现了<em class="jz"> premain </em>方法:</p><figure class="ka kb kc kd fd ij"><div class="bz dy l di"><div class="ke kf l"/></div></figure><p id="fcb8" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><em class="jz"> AgentBuilder </em>构造函数将允许我们通过<em class="jz"> type </em>方法和<em class="jz"> ElementMatchers </em>实用程序来指示我们想要干预的元素。<em class="jz"> transform </em>方法将允许我们指出我们想要在类的哪个元素上执行转换，在这个例子中是在已经通过过滤器的类的方法上。</p><p id="5cce" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">下一步是创建一个<em class="jz">通知</em>，它是一个与方面编程(AOP)相关的元素，允许我们在特定的点执行代码。我们创建的<em class="jz">建议</em>可以有不同的类型，这取决于我们希望它们何时被考虑到那个固定点:在那个特定点之前或之后。在这个例子中，我们将在访问满足过滤器的方法之前执行我们的<em class="jz">建议</em>。</p><figure class="ka kb kc kd fd ij"><div class="bz dy l di"><div class="ke kf l"/></div></figure><p id="ec95" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">现在我们只需要创建我们想要工具化的类。</p><figure class="ka kb kc kd fd ij"><div class="bz dy l di"><div class="ke kf l"/></div></figure><p id="b919" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">为了测试我们的Java代理，我们将执行上面显示的类。在清单文件中正确指示Java代理库和实现该代理的类。输出如下所示:</p><pre class="ka kb kc kd fd kg kh ki kj aw kk bi"><span id="8534" class="kl km hi kh b fi kn ko l kp kq">[INFO ] 2021-03-04 [main]  - CounterMeasureAdvice: Enter into: public static int ExampleThree.fibonacci(int)<br/>[INFO ] 2021-03-04 [main]  - Origin public static int ExampleThree.fibonacci(int) invoked 14 times<br/>[INFO ] 2021-03-04 [main]  - CounterMeasureAdvice: Enter into: public static int ExampleThree.fibonacci(int)<br/>[INFO ] 2021-03-04 [main]  - Origin public static int ExampleThree.fibonacci(int) invoked 15 times</span></pre><p id="f17a" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">可以看到，Java代理的使用有很多可能性。即使有了Byte Buddy库，也可以用简单的方式做复杂的事情。</p></div></div>    
</body>
</html>