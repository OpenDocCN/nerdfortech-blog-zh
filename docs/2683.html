<html>
<head>
<title>Floating-point rounding error in computers</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">计算机中的浮点舍入误差</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/floating-point-rounding-error-in-computers-6485cc26f5e8?source=collection_archive---------10-----------------------#2021-05-16">https://medium.com/nerd-for-tech/floating-point-rounding-error-in-computers-6485cc26f5e8?source=collection_archive---------10-----------------------#2021-05-16</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/fb4b63809e82357fa614c7fdb14f92c3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*DSM7LXN1z-dcyvMF"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated"><a class="ae iu" href="https://news.sky.com/" rel="noopener ugc nofollow" target="_blank">https://news.sky.com/</a></figcaption></figure><p id="1b40" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi jt translated">海湾战争期间，1991年2月，美国在沙特阿拉伯的爱国者导弹系统未能跟踪和拦截伊拉克的飞毛腿导弹。飞毛腿导弹击中了美国军营，造成28名士兵死亡，100多人受伤。后来发现这是由时间转换中的舍入误差引起的。</p></div><div class="ab cl kc kd gp ke" role="separator"><span class="kf bw bk kg kh ki"/><span class="kf bw bk kg kh ki"/><span class="kf bw bk kg kh"/></div><div class="hb hc hd he hf"><blockquote class="kj kk kl"><p id="6d72" class="iv iw km ix b iy iz ja jb jc jd je jf kn jh ji jj ko jl jm jn kp jp jq jr js hb bi translated">在进一步阅读之前，我建议你阅读我的关于<strong class="ix hj"/><a class="ae iu" href="https://hasithas.medium.com/how-computers-handle-floating-point-numbers-bfe9b08b4bc?source=your_stories_page-------------------------------------" rel="noopener"><strong class="ix hj">计算机如何处理浮点数</strong></a><strong class="ix hj"/>的文章，以理解我在这里谈论的一些事情。</p></blockquote><p id="ddf2" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">停止向下滚动，并尝试猜测以下代码的答案。嗯，应该不会太难😅。(这些代码没有语法问题。他们完全执行得很好；你只需要猜测输出)。</p><p id="f68c" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">问题01: </strong></p><figure class="kq kr ks kt fd ij"><div class="bz dy l di"><div class="ku kv l"/></div></figure><p id="eaa4" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">问题02: </p><figure class="kq kr ks kt fd ij"><div class="bz dy l di"><div class="ku kv l"/></div></figure><p id="9c2e" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">好的。所以我希望你花时间去猜测上面两个代码的输出。</p><p id="33ce" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">所以，如果你期待问题1的答案是<code class="du kw kx ky kz b">99.99</code>，我不得不说你错了…！实际输出如下所示。</p><p id="61f0" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">问题1的输出:</p><pre class="kq kr ks kt fd la kz lb lc aw ld bi"><span id="39e4" class="le lf hi kz b fi lg lh l li lj">Salary of 1st month: 33.333333333333336<br/>Salary of 2nd month: 33.333333333333336<br/>Salary of 3rd month: 33.333333333333336<br/>Totoal: 100.0</span></pre><p id="1cae" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">(你一定想知道<code class="du kw kx ky kz b">100 / 3.0 </code>怎么会是<code class="du kw kx ky kz b"> 33.333333333333336</code>。别急，我来告诉你怎么做)。</p><p id="b60b" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">对于问题2，如果你认为答案是类似<code class="du kw kx ky kz b">99, 100, or 101</code>的东西，那你就完全错了。这段代码只会给你一个无限循环(如下)。</p><p id="bac6" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">问题2的输出:</p><pre class="kq kr ks kt fd la kz lb lc aw ld bi"><span id="440a" class="le lf hi kz b fi lg lh l li lj">-26447.799999895626<br/>-26447.899999895624<br/>-26447.999999895623<br/>-26448.09999989562<br/>-26448.19999989562<br/>-26448.29999989562<br/>-26448.399999895617<br/>-26448.499999895615<br/>-26448.599999895614<br/>-26448.699999895613<br/>-26448.79999989561<br/>-26448.89999989561<br/>-26448.99999989561<br/>-26449.099999895607<br/>-26449.199999895605<br/>-26449.299999895604<br/>-26449.399999895602</span></pre><p id="af96" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在<a class="ae iu" href="https://hasithas.medium.com/how-computers-handle-floating-point-numbers-bfe9b08b4bc?source=your_stories_page-------------------------------------" rel="noopener">我之前的文章</a>中，当我们将9.1转换为IEEE 754标准时，我们得到了答案。<code class="du kw kx ky kz b">0100000100010001100110011001100<strong class="ix hj">1</strong></code>。</p><figure class="kq kr ks kt fd ij er es paragraph-image"><div class="er es lk"><img src="../Images/ef4db5d2457d89754672c0d70c6ac2b9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1078/format:webp/0*jJHgJewhCf2hh9QJ.png"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">IEEE 754标准中的9.1</figcaption></figure><p id="a884" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">但是一个计算机/ IEEE-754浮点转换器的回答是<code class="du kw kx ky kz b">010000010 0010001100110011001101<strong class="ix hj">0</strong></code>和我们预想的不一样。</p><blockquote class="kj kk kl"><p id="a294" class="iv iw km ix b iy iz ja jb jc jd je jf kn jh ji jj ko jl jm jn kp jp jq jr js hb bi translated">希望你注意到两者的最后一点是不一样的。</p></blockquote><p id="1ad6" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这是如何发生的，当计算机有23位的空间时，它寻找第24位。如果第24位是1，计算机将截掉其余的位，并将这个1加到第23位上。(如果第24位是0，反正无所谓)。</p><p id="a4d1" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">(如果这是一个双精度浮点数，也会发生同样的情况。如果你第54位有1，电脑会在第53位加1)。</p><p id="377e" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">因此，根据我们在前一篇文章中的计算，第24位是<code class="du kw kx ky kz b">1</code>，因为<code class="du kw kx ky kz b">1100</code>是循环的。</p><figure class="kq kr ks kt fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ll"><img src="../Images/8cbd55181a71ff0f157a635e1832fb93.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xUsHnaKxgnBa6kBF0SQgyQ.png"/></div></div></figure><p id="a47c" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">当第24位(<code class="du kw kx ky kz b">1</code>)加到第23位(<code class="du kw kx ky kz b">0</code>)时，9.1的IEEE 754标准值变为<code class="du kw kx ky kz b">01000001000100011001100110011010</code>。所以舍入问题是我们的答案和计算机的答案不同的原因。</p><p id="afed" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">现在，让我们看看这个二进制数是如何转换回原来的浮点值的。</p><p id="9890" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">作为该过程的第一步，指数(<code class="du kw kx ky kz b">10000010</code>)被转换成十进制，答案是<code class="du kw kx ky kz b">130</code>。现在应该从130中减去指数偏差(<code class="du kw kx ky kz b">127</code>)以获得指数值(<code class="du kw kx ky kz b">130 - 127 = 3</code>)。</p><figure class="kq kr ks kt fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lm"><img src="../Images/cfc7f6454e1da3258a1da465533b6d19.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fgrSd6pKNR8OV1pRDBZcrg.png"/></div></div></figure><p id="3d1f" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">接下来，我们需要将尾数转换回它的浮点值。如果您还记得在上一篇文章中我们是如何将浮点转换成二进制的，那么现在我们只需要做相反的事情。</p><p id="11a4" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如果位值为0，不影响回答。因此，您可以忽略它，只计算1。</p><figure class="kq kr ks kt fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ln"><img src="../Images/5513c85bc32e3c8151578a3a936e48dc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PuM8QLIiut4_x_cMIJ_lLw.png"/></div></div></figure><p id="d474" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">现在我们已经计算了<code class="du kw kx ky kz b">exponent = 8</code>和<code class="du kw kx ky kz b">mantissa = 0.137500048</code></p><p id="e145" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">所以在上一篇文章中，我们把尾数转换成IEEE 754标准时，省略了前导“1”。所以省略的“1”现在应该加到尾数上。</p><p id="2cde" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><code class="du kw kx ky kz b">1.137500048 = 0.137500048 + 1</code></p><p id="01cf" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">现在，尾数的新值应该乘以指数值</p><p id="17a0" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><code class="du kw kx ky kz b">9.10000038 = 1.137500048 * 3</code></p><p id="343d" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">所以当我们把9.1转换成IEEE 754，再把它转换回浮点时，我们没有得到9.1；我们得到的是<code class="du kw kx ky kz b">9.10000038</code></p><p id="08ce" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">因此，每当计算机将浮点转换为IEEE 754标准并将其转换回浮点时，由于这种舍入问题，我们总是会将它与其他值一起返回。</p><p id="f436" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">现在让我们回到问题2中的循环，做一些修改。</p><figure class="kq kr ks kt fd ij"><div class="bz dy l di"><div class="ku kv l"/></div></figure><p id="ecdf" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">输出:</p><pre class="kq kr ks kt fd la kz lb lc aw ld bi"><span id="8f82" class="le lf hi kz b fi lg lh l li lj">0.9000000000000187<br/>0.8000000000000187<br/>0.7000000000000187<br/>0.6000000000000187<br/>0.5000000000000188<br/>0.4000000000000188<br/>0.3000000000000188<br/>0.2000000000000188<br/>0.1000000000000188<br/>1.8790524691780774E-14</span></pre><p id="6ebd" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">现在你可以看到，它将停止，而不是无限循环。所以纵观这些值，你会发现<code class="du kw kx ky kz b">i </code>并没有达到0，但是由于舍入问题而增加的额外值，它超过了0。</p></div><div class="ab cl kc kd gp ke" role="separator"><span class="kf bw bk kg kh ki"/><span class="kf bw bk kg kh ki"/><span class="kf bw bk kg kh"/></div><div class="hb hc hd he hf"><h2 id="c370" class="le lf hi bd lo lp lq lr ls lt lu lv lw jg lx ly lz jk ma mb mc jo md me mf mg bi translated">那么Java中这个问题的解决方法是什么呢？</h2><p id="919c" class="pw-post-body-paragraph iv iw hi ix b iy mh ja jb jc mi je jf jg mj ji jj jk mk jm jn jo ml jq jr js hb bi translated">您可以使用Java BigDecimal类，而不是使用double或float或财务任务、军事用途和科学计算。BigDecimal类可以非常精确地处理非常大和非常小的浮点数。</p><p id="ede9" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">看看问题1和2中的问题是如何用Java BigDecimal类解决的。</p><figure class="kq kr ks kt fd ij"><div class="bz dy l di"><div class="ku kv l"/></div></figure><h2 id="c06f" class="le lf hi bd lo lp lq lr ls lt lu lv lw jg lx ly lz jk ma mb mc jo md me mf mg bi translated">参考</h2><figure class="kq kr ks kt fd ij"><div class="bz dy l di"><div class="mm kv l"/></div></figure><div class="mn mo ez fb mp mq"><a href="https://dzone.com/articles/never-use-float-and-double-for-monetary-calculatio" rel="noopener  ugc nofollow" target="_blank"><div class="mr ab dw"><div class="ms ab mt cl cj mu"><h2 class="bd hj fi z dy mv ea eb mw ed ef hh bi translated">为什么在货币计算中不应该使用浮点数和双精度数</h2><div class="mx l"><h3 class="bd b fi z dy mv ea eb mw ed ef dx translated">浮点数和双精度数对金融(甚至军事)世界都是有害的，永远不要把它们用于货币计算。如果…</h3></div><div class="my l"><p class="bd b fp z dy mv ea eb mw ed ef dx translated">dzone.com</p></div></div><div class="mz l"><div class="na l nb nc nd mz ne io mq"/></div></div></a></div><div class="mn mo ez fb mp mq"><a href="https://www.geeksforgeeks.org/bigdecimal-class-java/" rel="noopener  ugc nofollow" target="_blank"><div class="mr ab dw"><div class="ms ab mt cl cj mu"><h2 class="bd hj fi z dy mv ea eb mw ed ef hh bi translated">Java中的BigDecimal类- GeeksforGeeks</h2><div class="mx l"><h3 class="bd b fi z dy mv ea eb mw ed ef dx translated">BigDecimal类提供了对双精度数的运算，用于算术、小数位数处理、舍入、比较、格式…</h3></div><div class="my l"><p class="bd b fp z dy mv ea eb mw ed ef dx translated">www.geeksforgeeks.org</p></div></div><div class="mz l"><div class="nf l nb nc nd mz ne io mq"/></div></div></a></div></div></div>    
</body>
</html>