<html>
<head>
<title>The ‘Promise’ Model — Part 3 — Android Support</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">“承诺”模型——第 3 部分——Android 支持</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/the-promise-model-part-3-android-support-9522adda8b5a?source=collection_archive---------7-----------------------#2021-02-12">https://medium.com/nerd-for-tech/the-promise-model-part-3-android-support-9522adda8b5a?source=collection_archive---------7-----------------------#2021-02-12</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><h2 id="70ae" class="hg hh hi bd b fp hj hk hl hm hn ho dx hp translated" aria-label="kicker paragraph">移动应用中的反应式编程——一次旅行</h2><div class=""/><div class=""><h2 id="55e1" class="pw-subtitle-paragraph io hr hi bd b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf dx translated">一个异步任务链接工具，建立在 Kotlin 的“Promise”模型之上，专门设计用于支持 Android 上下文和主线程</h2></div><h2 id="c7e2" class="jg jh hi bd ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc ho bi translated">介绍</h2><p id="0e82" class="pw-post-body-paragraph kd ke hi kf b kg kh is ki kj kk iv kl jr km kn ko jv kp kq kr jz ks kt ku kv hb bi translated">这是关于科特林的“承诺”模型<a class="ae kw" rel="noopener" href="/nerd-for-tech/the-promise-model-in-kotlin-1c121f22d35a">的 3 篇文章的最后一篇。<br/>这一部分集中在一个特定的<em class="kx"> Promise </em>扩展——一个 Android Promise 类。它将<em class="kx">主线程</em>支持和<em class="kx">作用域</em>添加到<em class="kx">承诺</em>链中，以便在作用域终止时自动<em class="kx">取消</em>——例如，一个<em class="kx"> Android 视图</em>被<em class="kx">分离</em>。</a></p><h1 id="9dc4" class="ky jh hi bd ji kz la lb jm lc ld le jq ix lf iy ju ja lg jb jy jd lh je kc li bi translated">我们将在本文中做什么</h1><p id="911b" class="pw-post-body-paragraph kd ke hi kf b kg kh is ki kj kk iv kl jr km kn ko jv kp kq kr jz ks kt ku kv hb bi translated">假设你<a class="ae kw" rel="noopener" href="/nerd-for-tech/the-promise-model-in-kotlin-1c121f22d35a">阅读了第一部分</a>，你将学习如何扩展我们构建的<em class="kx"> Promise </em>模型，以便为其添加功能——在这种情况下，GitHub 上提供了<em class="kx"> Android </em>功能(<a class="ae kw" href="https://github.com/GuyMichael/APromise" rel="noopener ugc nofollow" target="_blank">，看看吧！</a>)。<br/>我们将从<em class="kx">作用域</em> ( <em class="kx">上下文</em>)开始，以<em class="kx">主线程</em>支持结束。<br/>这意味着我们将不再停留在纯粹的<em class="kx">科特林- </em>依赖区。<br/>移动应用<em class="kx">反应式编程</em>系列的下一篇文章将会谈到<em class="kx"> Reactdroid </em>架构——一个<em class="kx">反应式，MVI </em>架构用于<em class="kx"> Kotlin </em>和<em class="kx"> Android </em>。</p><figure class="lk ll lm ln fd lo er es paragraph-image"><div role="button" tabindex="0" class="lp lq di lr bf ls"><div class="er es lj"><img src="../Images/bf171f961b982610ec48ea8102f1b470.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tpfBRCzVR9_pvHU2GoJFEg.jpeg"/></div></div><figcaption class="lv lw et er es lx ly bd b be z dx translated">范围界定(在任务链中)就像在炎热的晴天滑雪——你必须在雪化之前完成下山的任务(上下文终止)。Val Thorens 滑雪场</figcaption></figure></div><div class="ab cl lz ma gp mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="hb hc hd he hf"><p id="07d8" class="pw-post-body-paragraph kd ke hi kf b kg mg is ki kj mh iv kl jr mi kn ko jv mj kq kr jz mk kt ku kv hb bi translated">关于任务链的范围界定，意味着将某些任务的<em class="kx">绑定到<em class="kx">范围</em>的<em class="kx">，因此当所述<em class="kx">范围</em>不再相关时，我们期望整个任务链停止，实际上<em class="kx">取消了</em>任务链。在<em class="kx">安卓</em>中，最常见的<em class="kx">作用域</em>是一个<code class="du ml mm mn mo b">Context</code>。实际上，我认为<em class="kx">上下文</em>比<em class="kx">范围</em>更直观，但是我想把<em class="kx">上下文</em>的一般概念与<em class="kx"> Android </em>模型<code class="du ml mm mn mo b">Context</code>区分开来。我的头已经疼了😅我想我们可以继续了。</em></em></p><p id="8ff6" class="pw-post-body-paragraph kd ke hi kf b kg mg is ki kj mh iv kl jr mi kn ko jv mj kq kr jz mk kt ku kv hb bi translated">让我们考虑下面的例子，并讨论它来解释什么是<em class="kx">作用域</em>，特别是关于任务链和<em class="kx">权限</em>:</p><figure class="lk ll lm ln fd lo"><div class="bz dy l di"><div class="mp mq l"/></div><figcaption class="lv lw et er es lx ly bd b be z dx translated">查看权限中绑定的简单示例</figcaption></figure><p id="6445" class="pw-post-body-paragraph kd ke hi kf b kg mg is ki kj mh iv kl jr mi kn ko jv mj kq kr jz mk kt ku kv hb bi translated">简单地说，我们希望<em class="kx">将</em>绑定<em class="kx">一个</em>到一个<em class="kx"> Android 视图</em>，这样，如果在<code class="du ml mm mn mo b">delay</code>结束之前，所述<em class="kx">视图</em>被<em class="kx">销毁</em>(或者<em class="kx">将</em>从其<em class="kx">上下文/活动</em>中分离出来)，那么<code class="du ml mm mn mo b">then</code>将不会被调用——在这种情况下，跳过动画。</p><p id="45fc" class="pw-post-body-paragraph kd ke hi kf b kg mg is ki kj mh iv kl jr mi kn ko jv mj kq kr jz mk kt ku kv hb bi translated">重要的是细节:</p><ol class=""><li id="59e1" class="mr ms hi kf b kg mg kj mh jr mt jv mu jz mv kv mw mx my mz bi translated">我们不想把<code class="du ml mm mn mo b">mView</code>放在某个全球范围内，所以不泄露它的意思，我们想让<em class="kx">的观点</em>得到破坏；我们不想在<em class="kx">内存</em>中保存它，因为在<em class="kx">应用程序</em>不再使用它之后——这被称为<em class="kx">泄漏</em>。<br/>即使那不是<em class="kx">泄露</em>，一个‘死’的<em class="kx">视图</em>也没有用。</li><li id="761f" class="mr ms hi kf b kg na kj nb jr nc jv nd jz ne kv mw mx my mz bi translated">默认情况下，<em class="kx"> rx </em>中的<em class="kx">延迟</em>动作延续了<em class="kx">计算</em>线程上的链(记住，我们在<em class="kx"> rx </em>的<em class="kx">单个</em>之上构建了<em class="kx">承诺</em>)。<br/>所以，如果你直接用<em class="kx"> rx 使用一些自定义<em class="kx">视图作用域</em>，那么</em>这个<code class="du ml mm mn mo b">then</code>调用，在<code class="du ml mm mn mo b">delay</code>之后，将被<em class="kx">主线程</em>调用，导致<em class="kx">崩溃</em>，因为你不能使用<em class="kx"> Android 视图</em>离开<em class="kx">主线程</em>😖。<br/> <em class="kx"> APromise </em>为您处理这个令人头疼的问题——默认情况下从您调用<code class="du ml mm mn mo b">delay</code>的线程恢复，并允许轻松地切换到任何其他线程(<code class="du ml mm mn mo b">thenOn</code>)。</li><li id="2dbd" class="mr ms hi kf b kg na kj nb jr nc jv nd jz ne kv mw mx my mz bi translated">我们可以定义两种类型的<em class="kx">作用域</em>，一种是如果某个<em class="kx">上下文</em>终止，则<em class="kx">取消</em>所有内容，另一种是跳过特定任务，但让任务链正常继续。顺便说一下，上面的例子显示了第一种情况——如果<em class="kx">视图</em>终止，整个链将<em class="kx">取消</em>。</li></ol></div><div class="ab cl lz ma gp mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="hb hc hd he hf"><p id="6b33" class="pw-post-body-paragraph kd ke hi kf b kg mg is ki kj mh iv kl jr mi kn ko jv mj kq kr jz mk kt ku kv hb bi translated">底线是，<em class="kx">作用域/上下文，</em>特别是当与<em class="kx">异步</em>任务结合时，会引发一些非常恼人的问题，导致代码开销和令人头疼的问题。</p><p id="ea6f" class="pw-post-body-paragraph kd ke hi kf b kg mg is ki kj mh iv kl jr mi kn ko jv mj kq kr jz mk kt ku kv hb bi translated">举个令人头疼的例子——你在<em class="kx"> Android 中写了多少次这种代码？</em></p><figure class="lk ll lm ln fd lo"><div class="bz dy l di"><div class="mp mq l"/></div><figcaption class="lv lw et er es lx ly bd b be z dx translated">臭名昭著的广播接收机开销</figcaption></figure><p id="24fc" class="pw-post-body-paragraph kd ke hi kf b kg mg is ki kj mh iv kl jr mi kn ko jv mj kq kr jz mk kt ku kv hb bi translated">不会了。说真的。当您读完这个系列时，假设您至少采用了一些技术(更不用说整个库了)，您将永远不会在您的项目中使用这样的代码😫。我们正在进行完全反应。<br/>哭够了。回去工作。</p></div><div class="ab cl lz ma gp mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="hb hc hd he hf"><h1 id="bcb9" class="ky jh hi bd ji kz nf lb jm lc ng le jq ix nh iy ju ja ni jb jy jd nj je kc li bi translated">“完美”模式</h1><p id="bcca" class="pw-post-body-paragraph kd ke hi kf b kg kh is ki kj kk iv kl jr km kn ko jv kp kq kr jz ks kt ku kv hb bi translated"><em class="kx">创建这个工具的第一步</em>将只是<em class="kx">扩展</em>承诺<em class="kx">模型并覆盖它的 API 以返回类型<em class="kx">承诺</em>而不是仅仅<em class="kx">承诺</em>。之后，我们会添加一些很酷的功能。让我们开始吧:</em></p><figure class="lk ll lm ln fd lo"><div class="bz dy l di"><div class="mp mq l"/></div><figcaption class="lv lw et er es lx ly bd b be z dx translated">扩展 Promise 模型来添加定制特性非常容易</figcaption></figure><p id="be83" class="pw-post-body-paragraph kd ke hi kf b kg mg is ki kj mh iv kl jr mi kn ko jv mj kq kr jz mk kt ku kv hb bi translated">还记得我们谈到的的<a class="ae kw" rel="noopener" href="/nerd-for-tech/the-promise-model-in-kotlin-1c121f22d35a#4df8">createInstanceImpl 吗？在这里。只是一个专用于<em class="kx">扩展</em>类来重新定义(<em class="kx">覆盖</em>)返回类型的方法。</a></p><p id="e772" class="pw-post-body-paragraph kd ke hi kf b kg mg is ki kj mh iv kl jr mi kn ko jv mj kq kr jz mk kt ku kv hb bi translated">如你所见，我们必须<em class="kx">覆盖</em>所有(我们想要的)API，以便将它们的结果转换为<em class="kx">权限</em>。否则，用法会很难，因为类型会在链的中间从<em class="kx">承诺</em>变为<em class="kx">承诺</em>，就像这样:</p><figure class="lk ll lm ln fd lo"><div class="bz dy l di"><div class="mp mq l"/></div><figcaption class="lv lw et er es lx ly bd b be z dx translated">当我们在扩展 Promise APIs 时没有覆盖它，会发生什么</figcaption></figure><p id="276b" class="pw-post-body-paragraph kd ke hi kf b kg mg is ki kj mh iv kl jr mi kn ko jv mj kq kr jz mk kt ku kv hb bi translated">就是这样！<br/> -无需覆盖<code class="du ml mm mn mo b">execute</code>。它是<code class="du ml mm mn mo b">Promise.</code> <br/>中的<em class="kx">最终</em>——无需再次进入<em class="kx">链接动作</em><em class="kx">——</em>你只需覆盖先前的 API。</p><p id="e7a8" class="pw-post-body-paragraph kd ke hi kf b kg mg is ki kj mh iv kl jr mi kn ko jv mj kq kr jz mk kt ku kv hb bi translated">😡如果这种做法让你生气，请继续阅读下面的<em class="kx">注释</em>。<br/>😃如果你高兴，就跳过它，让我们有一些乐趣，好吗:)</p></div><div class="ab cl lz ma gp mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="hb hc hd he hf"><p id="4679" class="pw-post-body-paragraph kd ke hi kf b kg mg is ki kj mh iv kl jr mi kn ko jv mj kq kr jz mk kt ku kv hb bi translated">愤怒的读者请注意:有一个很好的技巧可以克服这个问题——需要覆盖所有的 API。您只需用扩展该类的泛型类型来定义该类。但是在这个特殊的例子(Promise)中，我觉得这会给最终的使用增加太多的开销(在 Kotlin 不能推断出 Promise 类型的情况下，需要显式地编写泛型代码)，比它所能帮助的要多。最终，它的超级容易只是覆盖所有的方法，演员是安全的，由于 <code class="du ml mm mn mo b">createInstanceImpl</code> <em class="kx">，与 20 多年前的常识相反，来源于</em> <a class="ae kw" href="https://stackoverflow.com/questions/26335959/what-is-the-cost-of-casting-in-java-is-it-a-good-idea-to-avoid-it?lq=1" rel="noopener ugc nofollow" target="_blank"> <em class="kx">并不总是低效的</em> </a> <em class="kx">。<br/>无论如何，这里有一个替代方案，它省略了覆盖(和强制转换)的需要:</em></p><figure class="lk ll lm ln fd lo"><div class="bz dy l di"><div class="mp mq l"/></div><figcaption class="lv lw et er es lx ly bd b be z dx translated">承诺的替代声明，省略覆盖所有 API 的需要</figcaption></figure></div><div class="ab cl lz ma gp mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="hb hc hd he hf"><h1 id="3e0a" class="ky jh hi bd ji kz nf lb jm lc ng le jq ix nh iy ju ja ni jb jy jd nj je kc li bi translated">范围'权限'</h1><p id="6ecf" class="pw-post-body-paragraph kd ke hi kf b kg kh is ki kj kk iv kl jr km kn ko jv kp kq kr jz ks kt ku kv hb bi translated">在我们的<em class="kx">任务</em>中有两种处理<em class="kx">范围</em>的方法:</p><ol class=""><li id="b628" class="mr ms hi kf b kg mg kj mh jr mt jv mu jz mv kv mw mx my mz bi translated">当<em class="kx">范围</em>终止时(如<em class="kx">视图脱离</em>)监听并立即取消<em class="kx">任务。</em>这种方法有助于<em class="kx">取消</em>整个链条。</li><li id="d727" class="mr ms hi kf b kg na kj nb jr nc jv nd jz ne kv mw mx my mz bi translated">将<em class="kx">作用域</em>(例如<em class="kx">视图</em>)缓存在<a class="ae kw" href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.native.ref/-weak-reference/" rel="noopener ugc nofollow" target="_blank"> <em class="kx"> WeakReference </em> </a>中，并检查它在下一个动作(例如“then”)时是否“活动”。这种方法有助于跳过特定的任务，而不是<em class="kx">取消</em>所有事情。</li></ol><p id="54e4" class="pw-post-body-paragraph kd ke hi kf b kg mg is ki kj mh iv kl jr mi kn ko jv mj kq kr jz mk kt ku kv hb bi translated">这两种方法都依赖于一些相当复杂的实用方法，但它们也非常有趣，会教会你很多关于<em class="kx"> Promise/APromise </em>的用法和功能。<br/>所以我们要做的是从头开始:)我们将在本文的结尾指定这些实用程序，供真正的书呆子阅读😎。</p></div><div class="ab cl lz ma gp mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="hb hc hd he hf"><h2 id="fb15" class="jg jh hi bd ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc ho bi translated">侦听范围终止</h2><p id="8a23" class="pw-post-body-paragraph kd ke hi kf b kg kh is ki kj kk iv kl jr km kn ko jv kp kq kr jz ks kt ku kv hb bi translated">如果我们想在<em class="kx">范围</em>终止时自动<em class="kx">取消</em>我们的<em class="kx">约定</em>，我们需要监听/等待它终止，然后<em class="kx">取消</em>的<code class="du ml mm mn mo b">APromise</code>。让我们来看看下面的例子——一个<em class="kx">任务</em>的方法，当一个<em class="kx">活动</em>被<em class="kx">销毁</em>时，实现这样的<em class="kx">自动取消</em>到<em class="kx">取消</em>和<em class="kx">任务</em>:</p><figure class="lk ll lm ln fd lo"><div class="bz dy l di"><div class="mp mq l"/></div><figcaption class="lv lw et er es lx ly bd b be z dx translated">APromise 的 autoCancel 方法，用于在活动被销毁时取消 APromise</figcaption></figure><p id="9768" class="pw-post-body-paragraph kd ke hi kf b kg mg is ki kj mh iv kl jr mi kn ko jv mj kq kr jz mk kt ku kv hb bi translated">解释在代码中的注释中，但是我将详细说明:</p><ol class=""><li id="9ae9" class="mr ms hi kf b kg mg kj mh jr mt jv mu jz mv kv mw mx my mz bi translated">它使用另一个<em class="kx">任务</em>来等待<em class="kx">活动</em>的<em class="kx"> </em>的<code class="du ml mm mn mo b">onDestroy</code>。<br/>当它发生时，另一个<em class="kx">委托</em>将<em class="kx">取消</em>【我们】(<code class="du ml mm mn mo b">this</code> ) <em class="kx">委托</em>。<br/> <code class="du ml mm mn mo b">ViewUtils.waitForDestroy(Activity)</code>是一个(神奇的)实用方法，我们将在本文末尾介绍。</li><li id="5f12" class="mr ms hi kf b kg na kj nb jr nc jv nd jz ne kv mw mx my mz bi translated">它使用我们现在才看到的<code class="du ml mm mn mo b">APromise.doOnExecution()</code>来<em class="kx">执行</em>另一个<code class="du ml mm mn mo b">waitForDestroy()</code> <em class="kx">指令</em>。<br/>这只是另一种方法，在你的<em class="kx">承诺</em>已经实际开始运行的时候，帮助你运行一些代码(<em class="kx">执行</em>)。正如您所记得的，我们的<em class="kx">承诺</em>是异步的，并且是可以在方法之间传递的<em class="kx">一等公民</em> 。因此，我们不能假设它什么时候会执行，所以在它执行之前，我们不应该做任何动作——当有人调用你的方法时，你想做的所有动作(例如<code class="du ml mm mn mo b">autoCancel</code>或某种类型的<code class="du ml mm mn mo b">then</code>)应该放在<code class="du ml mm mn mo b">doOnExecution</code>中，就像上面的例子一样。</li><li id="a22d" class="mr ms hi kf b kg na kj nb jr nc jv nd jz ne kv mw mx my mz bi translated">在<em class="kx">活动</em>在【我方】<em class="kx">委托</em>完成(<em class="kx">解决/拒绝</em> ) <em class="kx">之前<em class="kx">未被</em>销毁的“标准”情况下，使用<code class="du ml mm mn mo b">finally()</code>到<em class="kx">取消</em><code class="du ml mm mn mo b">waitForDestroy()</code><em class="kx">委托</em>。</em></li><li id="5b40" class="mr ms hi kf b kg na kj nb jr nc jv nd jz ne kv mw mx my mz bi translated">完全相同的方法用于为<em class="kx">视图</em>创建一个<em class="kx">自动取消</em>方法，除了它使用(神奇的)实用方法<code class="du ml mm mn mo b">ViewUtils.waitForDetach(View)</code>)</li></ol><p id="9e79" class="pw-post-body-paragraph kd ke hi kf b kg mg is ki kj mh iv kl jr mi kn ko jv mj kq kr jz mk kt ku kv hb bi translated">使用这个<code class="du ml mm mn mo b">autoCancel</code>，我们可以很容易地为我们的<em class="kx">委托</em>创建有用的‘then’，例如，一个‘delay while alive’方法，来<em class="kx">延迟</em>一些‘then’(一个<em class="kx">消费者</em>)但是<em class="kx">取消</em>如果一个<em class="kx">活动</em>终止:</p><figure class="lk ll lm ln fd lo"><div class="bz dy l di"><div class="mp mq l"/></div><figcaption class="lv lw et er es lx ly bd b be z dx translated">延迟消费者，但如果一些活动在之前终止，则取消</figcaption></figure><p id="acd8" class="pw-post-body-paragraph kd ke hi kf b kg mg is ki kj mh iv kl jr mi kn ko jv mj kq kr jz mk kt ku kv hb bi translated">现在，使用<code class="du ml mm mn mo b">delayWhileAlive</code>，我们可以，例如，<em class="kx">在未来某个时间向</em>发送一些<em class="kx">分析 API </em>，除非<em class="kx">活动</em>在此之前终止:</p><figure class="lk ll lm ln fd lo"><div class="bz dy l di"><div class="mp mq l"/></div><figcaption class="lv lw et er es lx ly bd b be z dx translated">除非上下文在预定时间之前终止，否则不要采取进一步的措施</figcaption></figure><p id="5c15" class="pw-post-body-paragraph kd ke hi kf b kg mg is ki kj mh iv kl jr mi kn ko jv mj kq kr jz mk kt ku kv hb bi translated">很好。不需要处理<em class="kx">泄漏</em>，不需要有一些<em class="kx">定时器</em>并在<em class="kx"> onDestroy </em>中检查它以知道是否发送<em class="kx">事件</em>。只需定义<em class="kx"> onCreate </em>中的所有内容，然后忘掉它。<br/>当然，您可以使用<code class="du ml mm mn mo b">autoCancel(View)</code>来完成类似的任务，使用<em class="kx">视图</em>来代替。</p></div><div class="ab cl lz ma gp mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="hb hc hd he hf"><h2 id="bb81" class="jg jh hi bd ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc ho bi translated">缓存范围而不是立即取消</h2><p id="3afa" class="pw-post-body-paragraph kd ke hi kf b kg kh is ki kj kk iv kl jr km kn ko jv kp kq kr jz ks kt ku kv hb bi translated"><em class="kx">委托</em>用来处理<em class="kx">范围</em>的另一种方法是只缓存<em class="kx">上下文</em>(使用<code class="du ml mm mn mo b">WeakReference&lt;T&gt;</code>)，当链中的某个任务即将运行时，检查<em class="kx">引用</em>是否仍然保存<em class="kx">上下文</em>(<em class="kx">为空</em>)。<br/>如果<em class="kx">对象</em>还在，继续任务，但如果不在(<em class="kx"> null </em>，就跳过它(或者<em class="kx">取消/拒绝</em>整个<em class="kx">委托</em>)。</p><p id="e3c6" class="pw-post-body-paragraph kd ke hi kf b kg mg is ki kj mh iv kl jr mi kn ko jv mj kq kr jz mk kt ku kv hb bi translated"><em class="kx">注意:一个</em><a class="ae kw" href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.native.ref/-weak-reference/" rel="noopener ugc nofollow" target="_blank"><em class="kx">weak reference</em></a><em class="kx">，基本上是一个持有另一个对象(</em> <code class="du ml mm mn mo b"><em class="kx">T</em></code> <em class="kx">)的对象，但是如果‘没有其他人’再使用/持有它，就释放它，让垃圾收集器做它的事情。简单地说，它的意思是‘如果我是最后一个持有这个对象的人，请释放它’。防止漏水的好工具。</em></p><p id="ef18" class="pw-post-body-paragraph kd ke hi kf b kg mg is ki kj mh iv kl jr mi kn ko jv mj kq kr jz mk kt ku kv hb bi translated">让我们来看看下面的例子——一个实用方法，我们将把它注入到<code class="du ml mm mn mo b">WeakReference&lt;View<em class="kx">&gt;</em></code>类中(通过使用<a class="ae kw" href="https://kotlinlang.org/docs/extensions.html" rel="noopener ugc nofollow" target="_blank"> <em class="kx"> Kotlin 扩展</em> </a>)来帮助我们检查<em class="kx">视图</em>是否“活动”:</p><figure class="lk ll lm ln fd lo"><div class="bz dy l di"><div class="mp mq l"/></div><figcaption class="lv lw et er es lx ly bd b be z dx translated">如果' alive '则获取持有的视图，否则为 null</figcaption></figure><p id="ba50" class="pw-post-body-paragraph kd ke hi kf b kg mg is ki kj mh iv kl jr mi kn ko jv mj kq kr jz mk kt ku kv hb bi translated">太好了，现在我们可以轻松地持有<em class="kx">视图</em>(没有<em class="kx">泄露</em>它们)并轻松地检索它们——不需要检查它们的<code class="du ml mm mn mo b">Context</code>是否有效，甚至不需要检查它们是否被<em class="kx">附加到<em class="kx">窗口</em>上。</em></p><p id="7484" class="pw-post-body-paragraph kd ke hi kf b kg mg is ki kj mh iv kl jr mi kn ko jv mj kq kr jz mk kt ku kv hb bi translated">使用<code class="du ml mm mn mo b">getIfAlive()</code>,我们可以很容易地为我们的<em class="kx">委托</em>定义更有用的“then ”,例如，一个“thenWithView”方法，它使用“缓存”方法来调用某个<em class="kx">消费者</em>,前提是一个<em class="kx">视图</em>是“活动的”,但如果它不是“活动的”,就不取消整个链——只是跳过那个<em class="kx">消费者</em>:</p><figure class="lk ll lm ln fd lo"><div class="bz dy l di"><div class="mp mq l"/></div><figcaption class="lv lw et er es lx ly bd b be z dx translated">如果某个视图是“死的”,则跳过其消费者的“那么”</figcaption></figure><p id="defa" class="pw-post-body-paragraph kd ke hi kf b kg mg is ki kj mh iv kl jr mi kn ko jv mj kq kr jz mk kt ku kv hb bi translated">现在，使用<code class="du ml mm mn mo b">thenWithView</code>，我们可以，例如，<em class="kx">获取</em>一些<em class="kx"> API </em>并<em class="kx">缓存</em>其结果(不管任何作用域/ <em class="kx">视图</em>)，然后<em class="kx">动画化</em>一些<em class="kx">视图</em>——仅当“活动”时——然后发送一些关于整个过程的<em class="kx">分析</em>:</p><figure class="lk ll lm ln fd lo"><div class="bz dy l di"><div class="mp mq l"/></div><figcaption class="lv lw et er es lx ly bd b be z dx translated">如果某个视图是“死的”,只跳过特定的“然后”</figcaption></figure><p id="b99e" class="pw-post-body-paragraph kd ke hi kf b kg mg is ki kj mh iv kl jr mi kn ko jv mj kq kr jz mk kt ku kv hb bi translated">很好。不需要处理<em class="kx">泄露</em>，也不需要检查我们<em class="kx">视图</em>的<em class="kx">上下文</em>状态。只要定义我们想要做什么，如果它是“活的”(并获得一个参考！)并继续建链。<br/>当然，您可以使用<code class="du ml mm mn mo b">thenWithActivity(Activity)</code>来做类似的任务，使用<em class="kx">活动</em>来代替。</p></div><div class="ab cl lz ma gp mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="hb hc hd he hf"><h2 id="f84c" class="jg jh hi bd ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc ho bi translated">检查点—在我们继续之前</h2><p id="e7eb" class="pw-post-body-paragraph kd ke hi kf b kg kh is ki kj kk iv kl jr km kn ko jv kp kq kr jz ks kt ku kv hb bi translated">使用这两种方法还有许多更有趣的可能性，但是您可以尝试一下和/或看看<a class="ae kw" href="https://github.com/GuyMichael/APromise/blob/master/apromise/src/main/java/com/guymichael/apromise/APromise.kt" rel="noopener ugc nofollow" target="_blank">源代码</a>，因为这篇文章已经太长了，我们必须展示<em class="kx">主线程</em>支持，并看看我们之前谈到的那些神奇的实用程序:)</p><p id="d7ba" class="pw-post-body-paragraph kd ke hi kf b kg mg is ki kj mh iv kl jr mi kn ko jv mj kq kr jz mk kt ku kv hb bi translated">如果这对你今天来说足够了，感谢你的阅读，请不要犹豫，把你的意见写在下面！如果你像我一样是个真正的书呆子，让我们来玩玩线程和一些实用方法🤓。</p></div><div class="ab cl lz ma gp mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="hb hc hd he hf"><h1 id="5db7" class="ky jh hi bd ji kz nf lb jm lc ng le jq ix nh iy ju ja ni jb jy jd nj je kc li bi translated">主线程支持</h1><p id="cf2d" class="pw-post-body-paragraph kd ke hi kf b kg kh is ki kj kk iv kl jr km kn ko jv kp kq kr jz ks kt ku kv hb bi translated">你可能知道，<em class="kx"> Android </em>的<em class="kx">主线程</em>是你在处理 UI ( <em class="kx">活动、视图</em>等时唯一可以使用的线程。)和其他一些东西。当我们使用异步任务时，这是很困难的，异步任务最好运行在其他线程上。<br/>需要记住的唯一重要的事情是，有<em class="kx"> rx </em> ( <em class="kx">单个</em>)动作自动改变链的线程(<em class="kx">下游</em>)，如果我们不想让使用<em class="kx">委托</em>变得困难和模糊，我们需要恢复到<em class="kx">主线程</em>(或一些其他线程)。</p><h2 id="f679" class="jg jh hi bd ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc ho bi translated">APromise.delay()，APromise.timeout()</h2><p id="c7b7" class="pw-post-body-paragraph kd ke hi kf b kg kh is ki kj kk iv kl jr km kn ko jv kp kq kr jz ks kt ku kv hb bi translated">我们将只讨论“延迟”,因为“超时”在线程方面是一样的。</p><figure class="lk ll lm ln fd lo"><div class="bz dy l di"><div class="mp mq l"/></div></figure><p id="6efa" class="pw-post-body-paragraph kd ke hi kf b kg mg is ki kj mh iv kl jr mi kn ko jv mj kq kr jz mk kt ku kv hb bi translated">这个想法很简单——所以忽略所有那些循环和调度程序，让我们简单地说:<em class="kx"> Promise </em>的<code class="du ml mm mn mo b">delay(ms: Long, resumeOn: Scheduler)</code>为我们提供了一种在指定线程上的<em class="kx">延迟</em>之后继续的方法(因为<em class="kx"> Single </em>的<em class="kx">延迟</em>会自动改变链以在某个<em class="kx">计算</em>线程上运行)。<br/>所以我们要做的是，告诉<em class="kx"> Promise </em>的<em class="kx"> delay </em>在“当前”线程上继续，也就是说，最初调用<em class="kx"> delay </em>的线程。<br/>就这样。我们只是通过隐藏和修复来解决这个问题。<br/>如果不能推断出“当前”线程，将使用<em class="kx">主线程</em>作为后备。</p><p id="d93e" class="pw-post-body-paragraph kd ke hi kf b kg mg is ki kj mh iv kl jr mi kn ko jv mj kq kr jz mk kt ku kv hb bi translated"><em class="kx">注意:实际上，通常会使用主线程，因为大多数线程不会有弯针。但是这对于现在来说太高级了，而且你可能会在 99%的时间里使用主线程的指令。所以不用担心。</em></p></div><div class="ab cl lz ma gp mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="hb hc hd he hf"><h2 id="e115" class="jg jh hi bd ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc ho bi translated">APromise.thenOnMainThread</h2><p id="c181" class="pw-post-body-paragraph kd ke hi kf b kg kh is ki kj kk iv kl jr km kn ko jv kp kq kr jz ks kt ku kv hb bi translated">由于<em class="kx"> Promise </em>提供了一个<code class="du ml mm mn mo b">thenOn</code>动作，可以很容易地移动到任何你想要的<em class="kx"> rx 调度器</em>(<em class="kx">a Promise</em>也有)，我们可以创建一个 helper 方法来很容易地在<em class="kx">主线程</em>上继续一个链:</p><figure class="lk ll lm ln fd lo"><div class="bz dy l di"><div class="mp mq l"/></div></figure><p id="69ff" class="pw-post-body-paragraph kd ke hi kf b kg mg is ki kj mh iv kl jr mi kn ko jv mj kq kr jz mk kt ku kv hb bi translated">还有一些有用的 creator 方法，比如:<br/> <code class="du ml mm mn mo b">APromise.delayOnMainThread(ms: Long, consumer)</code>在做某件事之前轻松等待(并在主线程上做)；<br/> <code class="du ml mm mn mo b">APromise.postAtEndOfMainExecutionQueue(consumer)</code>，其行为类似于<code class="du ml mm mn mo b">View.post()</code>——做一些“现在”的事情，但是非阻塞的(一旦当前方法和先前调用的函数/任务完成)—但是不需要<em class="kx">视图。<br/> </em>还有很多……但是你要抓住要点。</p><p id="7a46" class="pw-post-body-paragraph kd ke hi kf b kg mg is ki kj mh iv kl jr mi kn ko jv mj kq kr jz mk kt ku kv hb bi translated">这就是线程处理！让我们以(神奇的)实用方法结束:)</p></div><div class="ab cl lz ma gp mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="hb hc hd he hf"><h1 id="ea3b" class="ky jh hi bd ji kz nf lb jm lc ng le jq ix nh iy ju ja ni jb jy jd nj je kc li bi translated">有用的实用方法</h1><p id="ce1d" class="pw-post-body-paragraph kd ke hi kf b kg kh is ki kj kk iv kl jr km kn ko jv kp kq kr jz ks kt ku kv hb bi translated">正如我<em class="kx">之前答应</em>(呵呵)你的，下面是两个非常有用的实用方法(<a class="ae kw" href="https://github.com/GuyMichael/APromise/blob/master/apromise/src/main/java/com/guymichael/apromise/ViewUtils.kt" rel="noopener ugc nofollow" target="_blank">这里定义为</a>)供我们在创建令人敬畏的<em class="kx">命令</em>动作时使用，甚至直接使用:<code class="du ml mm mn mo b">waitForDestroy(Activity)</code>和<code class="du ml mm mn mo b">waitForDetach(View)</code>。<br/>它们是使用(也)有用的<em class="kx">承诺</em>创建者<code class="du ml mm mn mo b">Promise.ofCallback()</code>创建的(也可用于<em class="kx">承诺</em>)。<br/>所以我们将从回调的<em class="kx">开始，然后继续讨论它们。</em></p><h2 id="9d66" class="jg jh hi bd ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc ho bi translated">Promise.ofCallback</h2><p id="0927" class="pw-post-body-paragraph kd ke hi kf b kg kh is ki kj kk iv kl jr km kn ko jv kp kq kr jz ks kt ku kv hb bi translated">这是一个<em class="kx">承诺</em>创建器，它将标准回调“转换”为<em class="kx">承诺</em>。它非常有用，你可能会经常用到。例如，它可以将<a class="ae kw" href="https://developer.android.com/reference/com/google/android/play/core/tasks/Task" rel="noopener ugc nofollow" target="_blank"> <em class="kx">安卓</em>的<em class="kx">任务</em> </a>，或者<a class="ae kw" href="https://developer.android.com/reference/android/animation/Animator.AnimatorListener" rel="noopener ugc nofollow" target="_blank"> <em class="kx">安卓的动画师</em> </a>转换为<em class="kx">任务</em>。<br/>这个强大的函数可以帮助你轻松地将代码中的每一个回调转换成<em class="kx"> Promise/APromise </em>以便在代码中只使用<em class="kx"> Promises </em>。不会再有试镜了，永远不会。声明一次，永远使用。</p><p id="19c4" class="pw-post-body-paragraph kd ke hi kf b kg mg is ki kj mh iv kl jr mi kn ko jv mj kq kr jz mk kt ku kv hb bi translated">下面是 Callback 的<em class="kx">的简化版，后面是详细解释:</em></p><figure class="lk ll lm ln fd lo"><div class="bz dy l di"><div class="mp mq l"/></div><figcaption class="lv lw et er es lx ly bd b be z dx translated">ofCallback()的简化实现，用于将回调转换为承诺</figcaption></figure><p id="43ac" class="pw-post-body-paragraph kd ke hi kf b kg mg is ki kj mh iv kl jr mi kn ko jv mj kq kr jz mk kt ku kv hb bi translated">这没什么特别的，真的。一个<em class="kx"> rx 单</em>创建者给你一个<em class="kx">发射器</em>，它只是一个‘送货员’，你通知它成功和失败——它通知<em class="kx">单。这正是我们所做的。我们传递那个<em class="kx">发射器</em>，它基本上是一个<em class="kx">接口</em>，有两个方法:<em class="kx"> onSuccess </em>和<em class="kx"> onError </em>。<br/>他们将从任何“标准”回调中被调用(成功或失败时)，他们将控制<em class="kx">单</em>，因此<em class="kx">承诺</em>。很简单。<br/>实际的实现稍微复杂一点，因为它用另一个实例(姑且称之为<em class="kx"> PromiseEmitter </em>)包装了<em class="kx">发射器</em>，以允许一些高级用法，但想法是完全一样的。</em></p><p id="bf5f" class="pw-post-body-paragraph kd ke hi kf b kg mg is ki kj mh iv kl jr mi kn ko jv mj kq kr jz mk kt ku kv hb bi translated">所以现在我们可以将任何回调转换成承诺，或者在我们的例子中，转换成承诺。我们开始吧！</p></div><div class="ab cl lz ma gp mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="hb hc hd he hf"><h2 id="62e1" class="jg jh hi bd ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc ho bi translated">ViewUtils.waitForDestroy</h2><p id="7666" class="pw-post-body-paragraph kd ke hi kf b kg kh is ki kj kk iv kl jr km kn ko jv kp kq kr jz ks kt ku kv hb bi translated">有多少次你想知道当一个<em class="kx">活动</em>被<em class="kx">销毁</em>——从那个<em class="kx">活动</em>之外，或者只是没有添加开销代码到它的<em class="kx">销毁</em>？<br/>让我们创建一个助手方法，只需一行简单的代码就能完成:</p><figure class="lk ll lm ln fd lo"><div class="bz dy l di"><div class="mp mq l"/></div><figcaption class="lv lw et er es lx ly bd b be z dx translated">等待一个活动的结束，并转化为一个承诺。简化了一点。</figcaption></figure><p id="165a" class="pw-post-body-paragraph kd ke hi kf b kg mg is ki kj mh iv kl jr mi kn ko jv mj kq kr jz mk kt ku kv hb bi translated">它看起来有点长，因为我编辑它是为了更容易解释——实际代码实际上要短得多——不过这个想法非常简单，让我们从头开始:</p><ol class=""><li id="138d" class="mr ms hi kf b kg mg kj mh jr mt jv mu jz mv kv mw mx my mz bi translated">我们准备一个<em class="kx"> WeakReference </em>来举办<em class="kx">活动</em></li><li id="313d" class="mr ms hi kf b kg na kj nb jr nc jv nd jz ne kv mw mx my mz bi translated">我们从那个<em class="kx">弱引用</em>中创建(并且<em class="kx">返回</em>)一个<em class="kx">委托</em>。<br/> <code class="du ml mm mn mo b">ofWeakRefOrCancel</code>只是一个简单的<em class="kx">委托</em>创建器，它在继续<em class="kx">自动取消</em>之前检查参考是否保持<em class="kx">空值</em>。我们需要它，因为我们总是定义我们的<em class="kx">承诺</em>异步，意思是，我们假设它们不会立即被调用。所以据我们所知，<em class="kx"> waitForDestroy </em>可以在<em class="kx">活动</em>被销毁很久之后<em class="kx">被执行。<br/>这甚至不是将回调转换为<em class="kx">回调的一部分… <br/> </em>在<em class="kx">内，然后等待</em>是实际的逻辑/call-to-ofCallback。</em></li><li id="89fa" class="mr ms hi kf b kg na kj nb jr nc jv nd jz ne kv mw mx my mz bi translated">我们调用回调函数的<em class="kx">并传递两个参数:</em></li></ol><ul class=""><li id="1860" class="mr ms hi kf b kg mg kj mh jr mt jv mu jz mv kv nk mx my mz bi translated">回调创建器——它创建了一个<em class="kx"> Android </em>的<em class="kx">应用程序的实例。ActivityLifecycleCallback </em>在<em class="kx">活动</em>被破坏时通知<em class="kx">发射器</em>。<br/>它还将其注册到<em class="kx">应用程序</em>中。不要担心，在<em class="kx">承诺</em>被<em class="kx">执行</em>之前，回调创建者不会被调用，所以这是一个<em class="kx">注册</em>您的回调的完美地方。</li><li id="cc34" class="mr ms hi kf b kg na kj nb jr nc jv nd jz ne kv nk mx my mz bi translated">最后一个动作——它被称为 always，当<em class="kx">承诺</em>终止时(甚至在<em class="kx">取消</em>时),这就是我们<em class="kx">取消</em>回调的地方。</li></ul><p id="09f7" class="pw-post-body-paragraph kd ke hi kf b kg mg is ki kj mh iv kl jr mi kn ko jv mj kq kr jz mk kt ku kv hb bi translated">真的就是这样。在我们继续之前，让我提醒你一下<em class="kx"> Android </em>的回调<em class="kx">应用。ActivityLifecycleCallback </em>不是类型化的，它不会检查您收到的<em class="kx">活动</em>是否对您很重要(<code class="du ml mm mn mo b">A</code>)。事实上，每当<em class="kx">任何</em> <em class="kx">活动</em>有<em class="kx">任何</em>生命周期事件时，它都会告诉您。<br/>在<a class="ae kw" href="https://github.com/GuyMichael/APromise/blob/master/apromise/src/main/java/com/guymichael/apromise/ViewUtils.kt" rel="noopener ugc nofollow" target="_blank">源代码</a>中，你可以看到我使用了一个专用的实现(<em class="kx">on activity destroyed listener</em>)来为我做这件事。没什么特别的。思路和上图一模一样。</p><p id="4d7a" class="pw-post-body-paragraph kd ke hi kf b kg mg is ki kj mh iv kl jr mi kn ko jv mj kq kr jz mk kt ku kv hb bi translated">从现在开始，当我们需要知道一个<em class="kx">活动</em>何时被<em class="kx">销毁</em>时，我们所需要的就是这个:</p><figure class="lk ll lm ln fd lo"><div class="bz dy l di"><div class="mp mq l"/></div><figcaption class="lv lw et er es lx ly bd b be z dx translated">waitForDestroy 的用法示例</figcaption></figure><p id="0d05" class="pw-post-body-paragraph kd ke hi kf b kg mg is ki kj mh iv kl jr mi kn ko jv mj kq kr jz mk kt ku kv hb bi translated">多酷啊。提示:与<code class="du ml mm mn mo b">View.waitForDetach</code>一起，它是我们接下来将讨论的<em class="kx"> Reactdroid </em>架构的关键构建模块:)</p></div><div class="ab cl lz ma gp mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="hb hc hd he hf"><h2 id="3cb7" class="jg jh hi bd ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc ho bi translated">ViewUtils.waitForDetach</h2><p id="9cf9" class="pw-post-body-paragraph kd ke hi kf b kg kh is ki kj kk iv kl jr km kn ko jv kp kq kr jz ks kt ku kv hb bi translated">使用完全相同的方法，我们可以等待<em class="kx">视图</em>到<em class="kx">从<em class="kx">窗口</em>中分离</em>。这次我将展示没有所有注释的压缩版本。我也不会解释它——没有必要——这是完全相同的方法:</p><figure class="lk ll lm ln fd lo"><div class="bz dy l di"><div class="mp mq l"/></div><figcaption class="lv lw et er es lx ly bd b be z dx translated">等待视图分离并转换为承诺</figcaption></figure><p id="aa5f" class="pw-post-body-paragraph kd ke hi kf b kg mg is ki kj mh iv kl jr mi kn ko jv mj kq kr jz mk kt ku kv hb bi translated">用法是:</p><figure class="lk ll lm ln fd lo"><div class="bz dy l di"><div class="mp mq l"/></div></figure><p id="dac4" class="pw-post-body-paragraph kd ke hi kf b kg mg is ki kj mh iv kl jr mi kn ko jv mj kq kr jz mk kt ku kv hb bi translated">它改变了你的生活还是什么？它确实改变了我！</p></div><div class="ab cl lz ma gp mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="hb hc hd he hf"><h1 id="7184" class="ky jh hi bd ji kz nf lb jm lc ng le jq ix nh iy ju ja ni jb jy jd nj je kc li bi translated">摘要</h1><p id="1d7a" class="pw-post-body-paragraph kd ke hi kf b kg kh is ki kj kk iv kl jr km kn ko jv kp kq kr jz ks kt ku kv hb bi translated">在本文中，我们学习了如何<em class="kx">扩展</em>我们在<a class="ae kw" rel="noopener" href="/nerd-for-tech/the-promise-model-in-kotlin-1c121f22d35a">以前的文章</a>中创建的<em class="kx">承诺</em>模型/单子——我们通过学习如何用<em class="kx">权限</em> ( <em class="kx">范围</em>和<em class="kx">线程处理</em>)专门支持<em class="kx"> Android </em>来做到这一点，同时，我们学习了如何转换任何<em class="kx">回调</em></p><p id="2cc8" class="pw-post-body-paragraph kd ke hi kf b kg mg is ki kj mh iv kl jr mi kn ko jv mj kq kr jz mk kt ku kv hb bi translated">这就结束了这个系列的<em class="kx">承诺</em>部分——移动应用中的<em class="kx">反应式编程——</em>，并打开了真正有趣的东西的大门:在<em class="kx"> Kotlin </em>中的<em class="kx">反应式、MVI </em>架构，它目前支持<em class="kx"> Android </em>，但也可以轻松支持<em class="kx"> iOS </em>到<em class="kx"> Kotlin 多平台</em>。</p><p id="fbde" class="pw-post-body-paragraph kd ke hi kf b kg mg is ki kj mh iv kl jr mi kn ko jv mj kq kr jz mk kt ku kv hb bi translated">敬请关注。下次见，祝你愉快:)</p></div></div>    
</body>
</html>