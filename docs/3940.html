<html>
<head>
<title>Quick Select Algorithm</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">快速选择算法</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/quick-select-algorithm-17ac146b6218?source=collection_archive---------2-----------------------#2021-06-30">https://medium.com/nerd-for-tech/quick-select-algorithm-17ac146b6218?source=collection_archive---------2-----------------------#2021-06-30</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="9eaa" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">快速选择是快速排序算法的一种变体。这是在未排序的数组中找到第k个最小/最大元素的优化方法。</p><h2 id="3a67" class="jd je hi bd jf jg jh ji jj jk jl jm jn iq jo jp jq iu jr js jt iy ju jv jw jx bi translated">算法:</h2><ul class=""><li id="a53f" class="jy jz hi ih b ii ka im kb iq kc iu kd iy ke jc kf kg kh ki bi translated">该算法的划分部分与快速排序相同。</li><li id="5b9f" class="jy jz hi ih b ii kj im kk iq kl iu km iy kn jc kf kg kh ki bi translated">在分区函数根据pivot排列列表中的元素并返回pivot_index之后，我们不再递归pivot索引的两侧，而是只递归包含所需元素的部分</li></ul><figure class="kp kq kr ks fd kt er es paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="er es ko"><img src="../Images/c8240f55143a9effae5763e75d5b3cc2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1144/format:webp/1*J2MwBiAh1M26Fd3A-oFFdg.jpeg"/></div></div></figure><h2 id="2e5e" class="jd je hi bd jf jg jh ji jj jk jl jm jn iq jo jp jq iu jr js jt iy ju jv jw jx bi translated">时间复杂度分析:</h2><p id="57fe" class="pw-post-body-paragraph if ig hi ih b ii ka ik il im kb io ip iq la is it iu lb iw ix iy lc ja jb jc hb bi translated">最坏的情况:最坏的情况发生在我们选择最大/最小的元素作为轴心的时候。</p><figure class="kp kq kr ks fd kt er es paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="er es ld"><img src="../Images/7a8fa90ae2df58f03caff3f4ad4c2b88.png" data-original-src="https://miro.medium.com/v2/resize:fit:840/format:webp/1*ovVTPcO_G_G0N_VzcPEpFA.jpeg"/></div></div></figure><p id="db29" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">最好的情况:最好的情况发生在我们把列表分成两半，并且只继续我们感兴趣的那一半的时候。</p><figure class="kp kq kr ks fd kt er es paragraph-image"><div class="er es le"><img src="../Images/6208c362b454bb87fdfde58a652f4026.png" data-original-src="https://miro.medium.com/v2/resize:fit:654/format:webp/1*zW9qGu9bRQMOaEQnIZveDg.jpeg"/></div></figure><p id="bca9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">快速选择的平均时间复杂度是O(n)(从O(nlogn)-快速排序减少)。最坏情况的时间复杂度仍然是O(n ),但是通过使用随机枢轴，在大多数情况下可以避免最坏情况。因此，平均而言，快速选择提供了一个O(n)的解决方案来查找未排序列表中第k个最大/最小的元素。</p><h2 id="3c7a" class="jd je hi bd jf jg jh ji jj jk jl jm jn iq jo jp jq iu jr js jt iy ju jv jw jx bi translated">练习:数组中第k个最大的元素[ LeetCode — 215]</h2><p id="64b8" class="pw-post-body-paragraph if ig hi ih b ii ka ik il im kb io ip iq la is it iu lb iw ix iy lc ja jb jc hb bi translated">问题链接:</p><div class="lf lg ez fb lh li"><a href="https://leetcode.com/problems/kth-largest-element-in-an-array/" rel="noopener  ugc nofollow" target="_blank"><div class="lj ab dw"><div class="lk ab ll cl cj lm"><h2 class="bd hj fi z dy ln ea eb lo ed ef hh bi translated">数组中第k个最大的元素- LeetCode</h2><div class="lp l"><h3 class="bd b fi z dy ln ea eb lo ed ef dx translated">提高你的编码技能，迅速找到工作。这是扩展你的知识和做好准备的最好地方…</h3></div><div class="lq l"><p class="bd b fp z dy ln ea eb lo ed ef dx translated">leetcode.com</p></div></div><div class="lr l"><div class="ls l lt lu lv lr lw ky li"/></div></div></a></div><p id="2011" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">问题描述:</p><p id="ce13" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">给定一个整数数组<code class="du lx ly lz ma b">nums</code>和一个整数<code class="du lx ly lz ma b">k</code>，返回数组中最大的元素<code class="du lx ly lz ma b">kth</code><em class="mb"><em class="mb">。</em></em></p><p id="1a75" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">注意，它是排序顺序中最大的<code class="du lx ly lz ma b">kth</code>元素，而不是<code class="du lx ly lz ma b">kth</code>独特元素。</p><figure class="kp kq kr ks fd kt er es paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="er es mc"><img src="../Images/ed5bc66aaf8d871a068339ca40fd72b8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cYJ6nhuNIv_RH2tYbRPp0A.jpeg"/></div></div></figure><h2 id="2c25" class="jd je hi bd jf jg jh ji jj jk jl jm jn iq jo jp jq iu jr js jt iy ju jv jw jx bi translated">解决方案1:简单易行</h2><p id="f1db" class="pw-post-body-paragraph if ig hi ih b ii ka ik il im kb io ip iq la is it iu lb iw ix iy lc ja jb jc hb bi translated">对给定的输入列表进行逆序排序，并打印第k个元素。时间复杂度为O(nlogn)。</p><h2 id="e2ef" class="jd je hi bd jf jg jh ji jj jk jl jm jn iq jo jp jq iu jr js jt iy ju jv jw jx bi translated">解决方案2:使用最大堆</h2><p id="6839" class="pw-post-body-paragraph if ig hi ih b ii ka ik il im kb io ip iq la is it iu lb iw ix iy lc ja jb jc hb bi translated">构建一个最大堆，提取元素k次。最后提取的元素将是答案。建立最大堆的时间复杂度为O(n ),执行堆化操作的时间复杂度为O(logn)。所以整体复杂度会是O(n+klogn)。</p><p id="6b87" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">以上解决方案足够体面，给你想要的答案。但是在面试中，要求你解决O(n)中的问题。</p><h2 id="f14e" class="jd je hi bd jf jg jh ji jj jk jl jm jn iq jo jp jq iu jr js jt iy ju jv jw jx bi translated">解决方案3:快速选择</h2><p id="755a" class="pw-post-body-paragraph if ig hi ih b ii ka ik il im kb io ip iq la is it iu lb iw ix iy lc ja jb jc hb bi translated">快速选择允许我们平均在O(n)内解决问题。使用随机化枢纽，我们可以在大多数情况下避免最坏的情况。因此，当在面试中被问到时，快速选择应该是你的答案，因为它给出了一个更好的时间复杂性解决方案。</p><figure class="kp kq kr ks fd kt"><div class="bz dy l di"><div class="md me l"/></div></figure></div></div>    
</body>
</html>