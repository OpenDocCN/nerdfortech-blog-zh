<html>
<head>
<title>[angular] All about the ViewContainerRef</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">[angular]关于 ViewContainerRef 的所有内容</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/angular-viewcontainerref-a1e8d08eabc2?source=collection_archive---------0-----------------------#2021-12-05">https://medium.com/nerd-for-tech/angular-viewcontainerref-a1e8d08eabc2?source=collection_archive---------0-----------------------#2021-12-05</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/0a02bdea84df7afc8d76afd98c06dc90.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*ycfGBXD9V0knl36x"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated"><a class="ae iu" href="https://unsplash.com/@erdaest?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Erda Estremera </a>在<a class="ae iu" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="5cc8" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj"> ViewContainerRef(VCR) </strong>表示一个容器，可以在其中附加一个或多个视图。<br/>它基本上是所有模板语法施展魔法的地方。</p><p id="5e4f" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">大多数时候，我们用标记编写模板来创建一个新视图，我们也可以用这个<strong class="ix hj"> VCR 按需创建视图</strong>。</p><h2 id="814c" class="jt ju hi bd jv jw jx jy jz ka kb kc kd jg ke kf kg jk kh ki kj jo kk kl km kn bi translated"><strong class="ak"> |如何访问 ViewContainerRef。</strong></h2><p id="4d6b" class="pw-post-body-paragraph iv iw hi ix b iy ko ja jb jc kp je jf jg kq ji jj jk kr jm jn jo ks jq jr js hb bi translated">ViewChild 可以通过添加令牌选项<strong class="ix hj">{ read:ViewContainerRef }</strong>访问模板上<strong class="ix hj"> <em class="kt">元素</em> </strong>的<strong class="ix hj"> VCR </strong>或者访问<strong class="ix hj"> <em class="kt">组件宿主</em> </strong>，注入对实例化的依赖。</p><p id="b345" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">注意</strong>，ng-template 也可以提供 viewContainerRef，这就是我们如何创建结构化指令。</p><pre class="ku kv kw kx fd ky kz la lb aw lc bi"><span id="c9fa" class="jt ju hi kz b fi ld le l lf lg">@Component({<br/>  selector: 'my-app',<br/>  template: `<br/>    &lt;h1&gt;See console to See viewContainer&lt;/h1&gt;<br/>    &lt;ul&gt;<br/>      &lt;li&gt;&lt;span #span&gt;this is html element&lt;/span&gt;&lt;/li&gt;<br/>      &lt;li&gt;&lt;custom-comp #custom&gt;&lt;/custom-comp&gt;&lt;/li&gt;<br/>      &lt;li&gt;&lt;ng-template #template [ngIf]="true"&gt;this is template&lt;/ng-template&gt;&lt;/li&gt;<br/>   &lt;/ul&gt;`,</span><span id="9477" class="jt ju hi kz b fi lh le l lf lg">})<br/>export class AppComponent implements AfterViewInit {<br/>  @ViewChild('span', { read: ViewContainerRef }) span;<br/>  @ViewChild('custom', { read: ViewContainerRef }) custom;<br/>  @ViewChild('template', { read: ViewContainerRef }) template;</span><span id="8d27" class="jt ju hi kz b fi lh le l lf lg">  constructor(private viewContainerRef: ViewContainerRef) {}</span><span id="c8d7" class="jt ju hi kz b fi lh le l lf lg">  ngAfterViewInit() {<br/>    console.log('&gt;&gt;&gt;hostElement', this.viewContainerRef);<br/>    console.log('&gt;&gt;&gt;htmlElement', this.span);<br/>    console.log('&gt;&gt;&gt;customElement', this.custom);<br/>    console.log('&gt;&gt;&gt;ngTemplate', this.template);<br/>  }</span><span id="cf1f" class="jt ju hi kz b fi lh le l lf lg">}</span></pre><div class="li lj ez fb lk ll"><a href="https://stackblitz.com/edit/angular-ivy-5rrwvf?file=src/app/app.component.ts" rel="noopener  ugc nofollow" target="_blank"><div class="lm ab dw"><div class="ln ab lo cl cj lp"><h2 class="bd hj fi z dy lq ea eb lr ed ef hh bi translated">viewContainerRef - StackBlitz</h2><div class="ls l"><h3 class="bd b fi z dy lq ea eb lr ed ef dx translated">编辑描述</h3></div><div class="lt l"><p class="bd b fp z dy lq ea eb lr ed ef dx translated">stackblitz.com</p></div></div><div class="lu l"><div class="lv l lw lx ly lu lz io ll"/></div></div></a></div><h2 id="9437" class="jt ju hi bd jv jw jx jy jz ka kb kc kd jg ke kf kg jk kh ki kj jo kk kl km kn bi translated">|通过<strong class="ak"> *ngIf </strong>创建视图的示例</h2><p id="d87b" class="pw-post-body-paragraph iv iw hi ix b iy ko ja jb jc kp je jf jg kq ji jj jk kr jm jn jo ks jq jr js hb bi translated">我们知道 ngIf 是结构指令。去掉糖衣部分，都是一样的。</p><pre class="ku kv kw kx fd ky kz la lb aw lc bi"><span id="ea78" class="jt ju hi kz b fi ld le l lf lg">&lt;div *ngIf="true"&gt;hey, show me!!!&lt;/div&gt;</span><span id="04ab" class="jt ju hi kz b fi lh le l lf lg">// is same as the later.</span><span id="9cdc" class="jt ju hi kz b fi lh le l lf lg">&lt;ng-template [ngIf]="true"&gt;&lt;div&gt;hey, show me!!!&lt;/div&gt;&lt;/ng-template&gt;</span></pre><p id="a202" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">ngIf 如何按需改变模板？</p><pre class="ku kv kw kx fd ky kz la lb aw lc bi"><span id="ee76" class="jt ju hi kz b fi ld le l lf lg">private <strong class="kz hj">_updateView</strong>() {  <br/>  <br/>  <strong class="kz hj">if</strong> (<strong class="kz hj">this._context.$implicit</strong>) { <br/>    <em class="kt">// if ngIf is true</em></span><span id="a2bf" class="jt ju hi kz b fi lh le l lf lg">    if (!this._thenViewRef) { // if no thenView created..       <br/>      <strong class="kz hj">this._viewContainer.clear();</strong><br/>      this._elseViewRef = null;<br/>      if (this._thenTemplateRef) {          <br/>        this._thenViewRef =            <br/>       this.<strong class="kz hj">_viewContainer.createEmbeddedView</strong>(this._thenTemplateRef, this._context);        <br/>      }      <br/>    }<br/>    <br/>  } <strong class="kz hj">else</strong> {  <br/>     <em class="kt">// if ngIf is false</em><br/>  <br/>    if (!this._elseViewRef) { // if no elseView created..<br/>      <strong class="kz hj">this._viewContainer.clear(); </strong>       <br/>      this._thenViewRef = null;        <br/>      if (this._elseTemplateRef) {          <br/>        this._elseViewRef =              this.<strong class="kz hj">_viewContainer.createEmbeddedView</strong>(this._elseTemplateRef, this._context);        <br/>      }      <br/>    }<br/>    <br/>  }  </span><span id="137d" class="jt ju hi kz b fi lh le l lf lg">}</span></pre><div class="li lj ez fb lk ll"><a href="https://github.com/angular/angular/blob/master/packages/common/src/directives/ng_if.ts" rel="noopener  ugc nofollow" target="_blank"><div class="lm ab dw"><div class="ln ab lo cl cj lp"><h2 class="bd hj fi z dy lq ea eb lr ed ef hh bi translated">角度/ng_if.ts 在主角度/角度</h2><div class="ls l"><h3 class="bd b fi z dy lq ea eb lr ed ef dx translated">此文件包含双向 Unicode 文本，其解释或编译可能与下面显示的不同…</h3></div><div class="lt l"><p class="bd b fp z dy lq ea eb lr ed ef dx translated">github.com</p></div></div><div class="lu l"><div class="ma l lw lx ly lu lz io ll"/></div></div></a></div><p id="b6e5" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这里有两种主要的方法，我们将更深入地研究它们。</p><ul class=""><li id="9790" class="mb mc hi ix b iy iz jc jd jg md jk me jo mf js mg mh mi mj bi translated"><strong class="ix hj"> _viewContainer(录像机)。createEmbeddedView(…) </strong></li><li id="f048" class="mb mc hi ix b iy mk jc ml jg mm jk mn jo mo js mg mh mi mj bi translated"><strong class="ix hj">_ 查看容器(VCR)。clear() </strong></li></ul><h2 id="0a9d" class="jt ju hi bd jv jw jx jy jz ka kb kc kd jg ke kf kg jk kh ki kj jo kk kl km kn bi translated">| vcr . createembedded view &amp; vcr . clear</h2><p id="c34d" class="pw-post-body-paragraph iv iw hi ix b iy ko ja jb jc kp je jf jg kq ji jj jk kr jm jn jo ks jq jr js hb bi translated"><strong class="ix hj"> createEmbeddedView </strong>从<strong class="ix hj"> TemplateRef 创建<strong class="ix hj"> ViewRef 的类型(</strong> EmbeddedViewRef 扩展 ViewRef <strong class="ix hj"> ) </strong>。</strong></p><p id="d2fd" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj"> ViewRef </strong>负责渲染视图，它扩展了<strong class="ix hj">changededetorref</strong>。<br/> <strong class="ix hj"> VCR </strong> <strong class="ix hj">容纳 1 个以上的 ViewRef </strong>，调用<strong class="ix hj"> createEmbeddedView </strong>会导致向容器追加新视图而不是替换。</p><p id="6342" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">要移除所有嵌入的视图，调用<strong class="ix hj"> VCR.clear()，</strong>现有视图将被分离并销毁。</p><figure class="ku kv kw kx fd ij er es paragraph-image"><div class="er es mp"><img src="../Images/93fe2b2372374aea3c410c5cdd405947.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/1*9gUon4RpW2Qiooie0rxCBw.gif"/></div></figure><div class="li lj ez fb lk ll"><a href="https://stackblitz.com/edit/angular-ivy-b25uva?file=src/app/app.component.ts" rel="noopener  ugc nofollow" target="_blank"><div class="lm ab dw"><div class="ln ab lo cl cj lp"><h2 class="bd hj fi z dy lq ea eb lr ed ef hh bi translated">viewcontainerref . createembeddedview-stack blitz</h2><div class="ls l"><h3 class="bd b fi z dy lq ea eb lr ed ef dx translated">编辑描述</h3></div><div class="lt l"><p class="bd b fp z dy lq ea eb lr ed ef dx translated">stackblitz.com</p></div></div><div class="lu l"><div class="mq l lw lx ly lu lz io ll"/></div></div></a></div><p id="72eb" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如果你不想破坏视图，只是从容器中取出，<strong class="ix hj"> VCR.detach </strong>就是你要找的。</p><h2 id="9efc" class="jt ju hi bd jv jw jx jy jz ka kb kc kd jg ke kf kg jk kh ki kj jo kk kl km kn bi translated">| VCR.detach() &amp; VRC.insert()</h2><div class="li lj ez fb lk ll"><a href="https://stackblitz.com/edit/angular-ivy-k7zuph?file=src/app/app.component.ts" rel="noopener  ugc nofollow" target="_blank"><div class="lm ab dw"><div class="ln ab lo cl cj lp"><h2 class="bd hj fi z dy lq ea eb lr ed ef hh bi translated">viewcontainerref . detach-stack blitz</h2><div class="ls l"><h3 class="bd b fi z dy lq ea eb lr ed ef dx translated">编辑描述</h3></div><div class="lt l"><p class="bd b fp z dy lq ea eb lr ed ef dx translated">stackblitz.com</p></div></div><div class="lu l"><div class="mr l lw lx ly lu lz io ll"/></div></div></a></div><p id="fc77" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">分离</strong>不会破坏视图，并保持它的元素原样，当您<strong class="ix hj">将</strong>插回时，任何与角度无关的状态都可以保留。</p><figure class="ku kv kw kx fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ms"><img src="../Images/d3342a2f1dc6e528568a61d7423b1806.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WqedqaaecX75T13jo9LE3g.png"/></div></div></figure><p id="0634" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这就是为什么，举例来说，黄色背景色仍然保留后，重新连接。</p><h2 id="9b1d" class="jt ju hi bd jv jw jx jy jz ka kb kc kd jg ke kf kg jk kh ki kj jo kk kl km kn bi translated">| ViewContainerRef 的其他方法</h2><p id="de72" class="pw-post-body-paragraph iv iw hi ix b iy ko ja jb jc kp je jf jg kq ji jj jk kr jm jn jo ks jq jr js hb bi translated">根据 viewContainer 的名称，您可能认为 viewRefs 位于 VCR.element 内部，但它们实际上是作为兄弟元素出现的。</p><figure class="ku kv kw kx fd ij er es paragraph-image"><div class="er es mt"><img src="../Images/09377dfe7a41e39d9730defe16e7e5d3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1384/format:webp/1*ucrTwmY2duDk6Xt-NnCfJQ.png"/></div></figure><p id="8a71" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">ViewContainerRef.element 引用视图的<strong class="ix hj"> ElementRef </strong>。<br/>可以是自定义元素，元素节点，甚至是注释节点。这就是为什么所有视图都位于 VCR.element.nativeElement 旁边。</p><p id="8c42" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">现在我们知道了如何创建模板视图，我们还能创建组件吗？</p><p id="bb8c" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">是的，VCR 也提供了<strong class="ix hj">创建组件</strong>的方法</p><p id="21cb" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">以前它需要 componentFactory，但现在它已被弃用，您可以传递组件本身。</p><pre class="ku kv kw kx fd ky kz la lb aw lc bi"><span id="c282" class="jt ju hi kz b fi ld le l lf lg">abstract <strong class="kz hj">createComponent</strong>&lt;C&gt;(componentType: <a class="ae iu" href="https://angular.io/api/core/Type" rel="noopener ugc nofollow" target="_blank">Type</a>&lt;C&gt;, options?: { index?: number; injector?: <a class="ae iu" href="https://angular.io/api/core/Injector" rel="noopener ugc nofollow" target="_blank">Injector</a>; ngModuleRef?: <a class="ae iu" href="https://angular.io/api/core/NgModuleRef" rel="noopener ugc nofollow" target="_blank">NgModuleRef</a>&lt;unknown&gt;; projectableNodes?: Node[][]; }): <a class="ae iu" href="https://angular.io/api/core/ComponentRef" rel="noopener ugc nofollow" target="_blank">ComponentRef</a>&lt;C&gt;</span></pre><div class="li lj ez fb lk ll"><a href="https://angular.io/api/core/ViewContainerRef#createcomponent" rel="noopener  ugc nofollow" target="_blank"><div class="lm ab dw"><div class="ln ab lo cl cj lp"><h2 class="bd hj fi z dy lq ea eb lr ed ef hh bi translated">有角的</h2><div class="ls l"><h3 class="bd b fi z dy lq ea eb lr ed ef dx translated">Angular 是一个构建移动和桌面 web 应用程序的平台。加入数百万开发者的社区…</h3></div><div class="lt l"><p class="bd b fp z dy lq ea eb lr ed ef dx translated">angular.io</p></div></div></div></a></div><figure class="ku kv kw kx fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mu"><img src="../Images/714fd6fd062e33b554af13ad0d376030.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZFyld2vMCS80ya5Ro-M0mQ.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">已弃用…</figcaption></figure><p id="88f4" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">现在组件也可以像模板一样<strong class="ix hj">保存</strong>。</p><pre class="ku kv kw kx fd ky kz la lb aw lc bi"><span id="60b2" class="jt ju hi kz b fi ld le l lf lg">// componentRef is returned by createComponent method.</span><span id="6a42" class="jt ju hi kz b fi lh le l lf lg">this.componentRef = this.viewContainerRef.createComponent(...);</span><span id="1809" class="jt ju hi kz b fi lh le l lf lg">// you can detach without destroying<br/>this.viewContainerRef.detach(0);</span><span id="81e5" class="jt ju hi kz b fi lh le l lf lg">// also reattach it with preserved elements.<br/>this.viewContainerRef.insert(this.componentRef.hostView, 0);</span></pre><p id="0b04" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi">:)</p></div></div>    
</body>
</html>