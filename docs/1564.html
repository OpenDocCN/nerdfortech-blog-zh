<html>
<head>
<title>(React Native) Custom Search Bar with Google Places Autocomplete API</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">(React Native)带有 Google Places 自动完成 API 的自定义搜索栏</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/react-native-custom-search-bar-with-google-places-autocomplete-api-69b1c98de6a0?source=collection_archive---------1-----------------------#2021-03-26">https://medium.com/nerd-for-tech/react-native-custom-search-bar-with-google-places-autocomplete-api-69b1c98de6a0?source=collection_archive---------1-----------------------#2021-03-26</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/458fab26e73e106842316823a261fe19.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pqYylPMKI9zzbFs5IAF0HA.png"/></div></div></figure><p id="21ee" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在许多应用程序中，当你输入时，你会看到一些建议列在搜索栏的正下方。为了在 React Native 中实现这个特性，有一个名为“<a class="ae jo" href="https://github.com/FaridSafi/react-native-google-places-autocomplete" rel="noopener ugc nofollow" target="_blank">React-Native-Google-places-autocomplete</a>”的库。然而，实现相同特性的简单版本并不困难。如果你能建立自己的搜索栏，你将在样式和功能上有更大的灵活性。在本文中，我将向您展示如何使用自动完成功能构建您自己的搜索栏。</p><h1 id="800e" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">我的环境</h1><ul class=""><li id="89c6" class="kn ko hi is b it kp ix kq jb kr jf ks jj kt jn ku kv kw kx bi translated">反应性:0.63.4</li><li id="c903" class="kn ko hi is b it ky ix kz jb la jf lb jj lc jn ku kv kw kx bi translated">打字稿:3.8.3</li><li id="06e2" class="kn ko hi is b it ky ix kz jb la jf lb jj lc jn ku kv kw kx bi translated">大苏尔马科斯:11.1</li></ul><h1 id="4a09" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">关于 iOS 和 Android 上潜在编译问题的说明</h1><ul class=""><li id="c1a9" class="kn ko hi is b it kp ix kq jb kr jf ks jj kt jn ku kv kw kx bi translated"><strong class="is hj"> iOS: <br/> </strong>如果你尝试使用<code class="du ld le lf lg b">npx react-native run-ios</code>在模拟器上运行该应用，可能无法运行。在撰写本文时，React 原生版本(v 0.63.4)使用的<code class="du ld le lf lg b">Flipper</code>库似乎有问题。如果你遇到了编译错误，你可以尝试从 Xcode 运行应用程序，或者你可以尝试从<a class="ae jo" href="https://github.com/facebook/react-native/issues/30836" rel="noopener ugc nofollow" target="_blank">GitHub 问题</a>的临时解决方案。在我写这篇文章的时候，React Native 0.64 已经发布了，所以希望这个问题在那个补丁中得到解决。</li><li id="fdfc" class="kn ko hi is b it ky ix kz jb la jf lb jj lc jn ku kv kw kx bi translated"><strong class="is hj"> Android: <br/> </strong>如果您最近将操作系统升级到 macOS Big Sur，<code class="du ld le lf lg b">npx react-native run-android</code>可能会因为<code class="du ld le lf lg b">JAVA_HOME</code>路径配置的问题而无法正常工作。为了让它工作，我卸载了旧版本的 Java(版本 9)，通过<code class="du ld le lf lg b">Homebrew</code>从<code class="du ld le lf lg b">AdoptOpenJDK</code>安装了<code class="du ld le lf lg b">jEnv</code>和一些 Java 版本。在 macOS 上设置 Java 环境已经离题了，所以我不会在本文中涉及。然而，我在这篇文章的结尾留下了一些关于这个问题的文章的参考，所以你可以参考它们。</li></ul></div><div class="ab cl lh li gp lj" role="separator"><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm"/></div><div class="hb hc hd he hf"><h1 id="5769" class="jp jq hi bd jr js lo ju jv jw lp jy jz ka lq kc kd ke lr kg kh ki ls kk kl km bi translated">1.生成并设置项目</h1><p id="ece1" class="pw-post-body-paragraph iq ir hi is b it kp iv iw ix kq iz ja jb lt jd je jf lu jh ji jj lv jl jm jn hb bi translated">为了生成项目，您可以使用 React Native 社区中的 Typescript 模板。</p><pre class="lw lx ly lz fd ma lg mb mc aw md bi"><span id="96f0" class="me jq hi lg b fi mf mg l mh mi"><strong class="lg hj">npx react-native init YourProjectName --template react-native-template-typescript</strong></span></pre><p id="46b7" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">注意:</strong>如果你全局安装了旧版本的<code class="du ld le lf lg b">react-native</code>或<code class="du ld le lf lg b">react-native-cli</code>，上面的命令就不起作用，需要卸载才能使其工作。有关更多信息，请参见来自 https://reactnative.dev/docs/typescript<a class="ae jo" href="https://reactnative.dev/docs/typescript" rel="noopener ugc nofollow" target="_blank">和 https://github.com/react-native-community/cli</a><a class="ae jo" href="https://github.com/react-native-community/cli" rel="noopener ugc nofollow" target="_blank">的 React 土著社区的官方文档。</a></p><p id="4657" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">当我生成这个项目时，由于某些原因，它附带了旧版本的<code class="du ld le lf lg b">eslint</code>和<code class="du ld le lf lg b">jest</code>。所以，我按照下面的步骤更新了它们。</p><pre class="lw lx ly lz fd ma lg mb mc aw md bi"><span id="4648" class="me jq hi lg b fi mf mg l mh mi">// Uninstall @react-native-community/eslint-config once to work with the latest configuration, and re-install<br/><strong class="lg hj">npm uninstall @react-native-community/eslint-config &amp;&amp; npm i -D @react-native-community/eslint-config</strong></span><span id="15cb" class="me jq hi lg b fi mj mg l mh mi">// Uninstall eslint and re-install<br/><strong class="lg hj">npm uninstall eslint &amp;&amp; npm i -D eslint</strong></span><span id="e2d2" class="me jq hi lg b fi mj mg l mh mi">// Uninstall jest related dependencies and re-install<br/><strong class="lg hj">npm uninstall jest @types/jest babel-jest</strong> <strong class="lg hj">&amp;&amp; npm i -D jest @types/jest babel-jest</strong></span></pre><p id="8b78" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这些命令应该将依赖项更新到最新配置的版本。你可以选择用下面的命令添加<code class="du ld le lf lg b">typescript-eslint</code>插件和<code class="du ld le lf lg b">prettier</code>。</p><pre class="lw lx ly lz fd ma lg mb mc aw md bi"><span id="12a1" class="me jq hi lg b fi mf mg l mh mi">// Add the typescript plugin for eslint<strong class="lg hj"><br/>npm i -D @typescript-eslint/parser @typescript-eslint/eslint-plugin</strong></span><span id="18f0" class="me jq hi lg b fi mj mg l mh mi">// Add prettier<br/><strong class="lg hj">npm i -D prettier eslint-config-prettier eslint-plugin-prettier</strong></span></pre><p id="8b90" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这对于基本的项目设置应该足够了。</p><h1 id="cadc" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">2.构建基本搜索栏视图</h1><p id="edb8" class="pw-post-body-paragraph iq ir hi is b it kp iv iw ix kq iz ja jb lt jd je jf lu jh ji jj lv jl jm jn hb bi translated">接下来，我们需要创建一个搜索栏组件。创建一个名为“components”的文件夹，并将组件文件放在该目录下。然后，添加以下代码。这只是用基本样式显示搜索栏的代码，所以我不会详细解释。</p><pre class="lw lx ly lz fd ma lg mb mc aw md bi"><span id="219c" class="me jq hi lg b fi mf mg l mh mi">// ./components/SearchBarWithAutocomplete.tsx</span><span id="d05f" class="me jq hi lg b fi mj mg l mh mi"><strong class="lg hj">import React, { FunctionComponent } from 'react'<br/>import {<br/>  StyleSheet,<br/>  View,<br/>  TextInput,<br/>  ViewStyle<br/>} from 'react-native'</strong></span><span id="7d06" class="me jq hi lg b fi mj mg l mh mi"><strong class="lg hj">type SearchBarProps = {<br/>  value: string<br/>  style?: ViewStyle | ViewStyle[]<br/>  onChangeText: (text: string) =&gt; void<br/>}</strong></span><span id="d0e6" class="me jq hi lg b fi mj mg l mh mi"><strong class="lg hj">const SearchBarWithAutocomplete: FunctionComponent&lt;SearchBarProps&gt; = props =&gt; {<br/>  const {<br/>    value,<br/>    style,<br/>    onChangeText<br/>  } = props</strong></span><span id="79cf" class="me jq hi lg b fi mj mg l mh mi"><strong class="lg hj">  const {<br/>    container,<br/>    inputStyle<br/>  } = styles<br/>  const passedStyles = Array.isArray(style) ? Object.assign({}, ...style) : style</strong></span><span id="21c9" class="me jq hi lg b fi mj mg l mh mi"><strong class="lg hj">return (<br/>    &lt;View style={[container, { ...passedStyles }]}&gt;<br/>      &lt;TextInput<br/>        style={inputStyle}<br/>        placeholder='Search by address'<br/>        placeholderTextColor='gray'<br/>        value={value}<br/>        onChangeText={onChangeText}<br/>        returnKeyType='search'<br/>      /&gt;<br/>    &lt;/View&gt;<br/>  )<br/>}</strong></span><span id="63f8" class="me jq hi lg b fi mj mg l mh mi"><strong class="lg hj">const styles = StyleSheet.create({<br/>  container: {<br/>    justifyContent: 'center'<br/>  },<br/>  inputStyle: {<br/>    paddingVertical: 16,<br/>    paddingHorizontal: 16,<br/>    backgroundColor: '#cfcfcf',<br/>    borderRadius: 20,<br/>    color: 'black',<br/>    fontSize: 16<br/>  }<br/>})</strong></span><span id="0d3f" class="me jq hi lg b fi mj mg l mh mi"><strong class="lg hj">export default SearchBarWithAutocomplete</strong></span></pre><p id="63f3" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们还需要修改下面的<code class="du ld le lf lg b">App.tsx</code>文件来显示我们刚刚创建的搜索栏。</p><pre class="lw lx ly lz fd ma lg mb mc aw md bi"><span id="f1fa" class="me jq hi lg b fi mf mg l mh mi">// App.tsx</span><span id="8d51" class="me jq hi lg b fi mj mg l mh mi"><strong class="lg hj">import React, { useState } from 'react'<br/>import {<br/>  SafeAreaView,<br/>  StyleSheet,<br/>  StatusBar,<br/>  View<br/>} from 'react-native'</strong></span><span id="00ae" class="me jq hi lg b fi mj mg l mh mi"><strong class="lg hj">import SearchBarWithAutocomplete from './components/SearchBarWithAutocomplete'</strong></span><span id="9f3e" class="me jq hi lg b fi mj mg l mh mi"><strong class="lg hj">const App = () =&gt; {<br/>  const [search, setSearch] = useState({ term: '' })</strong></span><span id="6602" class="me jq hi lg b fi mj mg l mh mi"><strong class="lg hj">const { container, body } = styles</strong></span><span id="0d99" class="me jq hi lg b fi mj mg l mh mi"><strong class="lg hj">return (<br/>    &lt;&gt;<br/>      &lt;StatusBar barStyle="dark-content" /&gt;<br/>      &lt;SafeAreaView style={container}&gt;<br/>        &lt;View style={body}&gt;<br/>          &lt;SearchBarWithAutocomplete<br/>            value={search.term}<br/>            onChangeText={(text) =&gt; setSearch({ term: text })}<br/>          /&gt;<br/>        &lt;/View&gt;<br/>      &lt;/SafeAreaView&gt;<br/>    &lt;/&gt;<br/>  )<br/>}</strong></span><span id="faa2" class="me jq hi lg b fi mj mg l mh mi"><strong class="lg hj">const styles = StyleSheet.create({<br/>  container: {<br/>    flex: 1<br/>  },<br/>  body: {<br/>    paddingHorizontal: 20<br/>  }<br/>})</strong></span><span id="2c81" class="me jq hi lg b fi mj mg l mh mi"><strong class="lg hj">export default App</strong></span></pre><p id="e4eb" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如果您构建并运行您的应用程序，您应该会看到屏幕上显示的搜索栏。</p><h1 id="7e57" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">3.获取 Google Places API 密钥</h1><p id="813e" class="pw-post-body-paragraph iq ir hi is b it kp iv iw ix kq iz ja jb lt jd je jf lu jh ji jj lv jl jm jn hb bi translated">为了实现自动完成功能，我们需要为 Google Places API 获取一个 API。</p><h2 id="8bbc" class="me jq hi bd jr mk ml mm jv mn mo mp jz jb mq mr kd jf ms mt kh jj mu mv kl mw bi translated">3.1.去谷歌云平台</h2><p id="f2ec" class="pw-post-body-paragraph iq ir hi is b it kp iv iw ix kq iz ja jb lt jd je jf lu jh ji jj lv jl jm jn hb bi translated">访问<a class="ae jo" href="https://console.cloud.google.com/google/maps-apis/" rel="noopener ugc nofollow" target="_blank">谷歌云平台控制台</a>获取 API 密钥使用“谷歌地图 Javascript API”。</p><h2 id="a58b" class="me jq hi bd jr mk ml mm jv mn mo mp jz jb mq mr kd jf ms mt kh jj mu mv kl mw bi translated">3.2.创建项目并启用 API</h2><p id="c6ba" class="pw-post-body-paragraph iq ir hi is b it kp iv iw ix kq iz ja jb lt jd je jf lu jh ji jj lv jl jm jn hb bi translated">首先，在控制台上创建一个新项目，并导航到左侧抽屉导航中的“<strong class="is hj">API 和服务</strong>”。然后，点击仪表板上的“<strong class="is hj">启用 API 和服务</strong>”。</p><figure class="lw lx ly lz fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mx"><img src="../Images/949a2df3e53eca385775b90f4cb3d692.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*aODPJJfAg8vJC_v2_FC8wA.png"/></div></div><figcaption class="my mz et er es na nb bd b be z dx translated">API 和服务仪表板</figcaption></figure><p id="9998" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在下一个屏幕上，搜索“<strong class="is hj"> Places API </strong>”并启用它。</p><figure class="lw lx ly lz fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es nc"><img src="../Images/fe8a756d660f09327d6e0e3bd4039a6f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9bqPKB2cG86RzhqqNXyyrw.png"/></div></div></figure><h2 id="39ca" class="me jq hi bd jr mk ml mm jv mn mo mp jz jb mq mr kd jf ms mt kh jj mu mv kl mw bi translated">3.3.生成 API 密钥</h2><p id="65f6" class="pw-post-body-paragraph iq ir hi is b it kp iv iw ix kq iz ja jb lt jd je jf lu jh ji jj lv jl jm jn hb bi translated">启用 API 后，您需要创建一个密钥来实际使用 API。导航到“<strong class="is hj">API&amp;服务</strong>”下的“<strong class="is hj">凭证</strong>，点击屏幕中上方的“<strong class="is hj">创建凭证</strong>，选择“API key”。</p><figure class="lw lx ly lz fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es nd"><img src="../Images/7b883e4cbb5539e0e60d0aa243c09565.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*K86kvW1dk8v-UAn3vvnpdg.png"/></div></div><figcaption class="my mz et er es na nb bd b be z dx translated">在“API 和服务”下选择“凭据”</figcaption></figure><figure class="lw lx ly lz fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ne"><img src="../Images/305d678a4c3b377ce3242c199b97cc6f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LC_jhUVUoZknzwOHTjiWRA.png"/></div></div><figcaption class="my mz et er es na nb bd b be z dx translated">选择“API 密钥”</figcaption></figure><p id="df7e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这将生成一个 API 密钥，所以请将它保存在安全的地方，因为您以后需要它来使用应用程序中的 API。</p><figure class="lw lx ly lz fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es nf"><img src="../Images/635ceaa261ea7b00414f57a10427b2ee.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dRIUzpTvdaCCbEa1Y2bwJQ.png"/></div></div><figcaption class="my mz et er es na nb bd b be z dx translated">记下这把钥匙</figcaption></figure><h2 id="2dde" class="me jq hi bd jr mk ml mm jv mn mo mp jz jb mq mr kd jf ms mt kh jj mu mv kl mw bi translated">3.4 创建一个计费帐户，并将其与项目关联</h2><p id="9e5d" class="pw-post-body-paragraph iq ir hi is b it kp iv iw ix kq iz ja jb lt jd je jf lu jh ji jj lv jl jm jn hb bi translated">为了从 API 获得结果，您的 Google Cloud 项目需要有一个链接到您的项目的计费帐户。您可以创建一个计费账户，并在<strong class="is hj">“计费”</strong>页面将其链接到您的项目。</p><figure class="lw lx ly lz fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ng"><img src="../Images/e82ccdc8809b45c7f05c6a9c52c08897.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3i12B_ekR-BXAa3GXZU-ig.png"/></div></div><figcaption class="my mz et er es na nb bd b be z dx translated">创建一个计费帐户，并将其链接到您的项目</figcaption></figure><p id="b82e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">注意:为了避免不必要的账单</strong>，我建议你<strong class="is hj">在本教程结束时在 Google Cloud 控制台上禁用 API 或删除项目</strong>。</p><h1 id="20c3" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">4.实现向 API 发送请求的功能</h1><p id="e9a9" class="pw-post-body-paragraph iq ir hi is b it kp iv iw ix kq iz ja jb lt jd je jf lu jh ji jj lv jl jm jn hb bi translated">现在，我们需要修改应用程序，以便能够使用 API 键向 Places API 发送请求。首先，用下面的命令安装<code class="du ld le lf lg b"><strong class="is hj">axios</strong></code> <strong class="is hj"> </strong>，这个库用于发送 HTTP 请求。</p><pre class="lw lx ly lz fd ma lg mb mc aw md bi"><span id="3b74" class="me jq hi lg b fi mf mg l mh mi"><strong class="lg hj">npm i axios</strong></span></pre><p id="2134" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">接下来，修改<code class="du ld le lf lg b">App.tsx</code>文件，如下所示。</p><pre class="lw lx ly lz fd ma lg mb mc aw md bi"><span id="7fa5" class="me jq hi lg b fi mf mg l mh mi">// App.tsx<br/>// Duplicates are omitted and replaced with "..."</span><span id="800b" class="me jq hi lg b fi mj mg l mh mi">import React, { useState } from 'react'<br/>import {<br/>  ...<br/>} from 'react-native'<br/><strong class="lg hj">// ==== Change No.1 ====<br/>import axios from 'axios'</strong></span><span id="f00b" class="me jq hi lg b fi mj mg l mh mi">import SearchBarWithAutocomplete from './components/SearchBarWithAutocomplete'</span><span id="4ab3" class="me jq hi lg b fi mj mg l mh mi"><strong class="lg hj">// ==== Change No.2 ====<br/>const GOOGLE_PACES_API_BASE_URL = 'https://maps.googleapis.com/maps/api/place'</strong></span><span id="c839" class="me jq hi lg b fi mj mg l mh mi"><strong class="lg hj">// ==== Change No.3 ====<br/>/**<br/> * Prediction's type returned from Google Places Autocomplete API<br/> * </strong><a class="ae jo" href="https://developers.google.com/places/web-service/autocomplete#place_autocomplete_results" rel="noopener ugc nofollow" target="_blank"><strong class="lg hj">https://developers.google.com/places/web-service/autocomplete#place_autocomplete_results</strong></a><strong class="lg hj"><br/>*/<br/>export type PredictionType = {<br/>  description: string<br/>  place_id: string<br/>  reference: string<br/>  matched_substrings: any[]<br/>  tructured_formatting: Object<br/>  terms: Object[]<br/>  types: string[]<br/>}</strong></span><span id="cb61" class="me jq hi lg b fi mj mg l mh mi">const App = () =&gt; {<br/>  <strong class="lg hj">// === Change No.4 ====</strong><br/>  const [search, setSearch] = useState({ term: ''<strong class="lg hj">, fetchPredictions: false</strong> })<br/>  <strong class="lg hj">// ==== Change No.5 ====<br/>  const [predictions, setPredictions] = useState&lt;PredictionType[]&gt;([])</strong></span><span id="2d9d" class="me jq hi lg b fi mj mg l mh mi">  const { container, body } = styles</span><span id="a275" class="me jq hi lg b fi mj mg l mh mi"><strong class="lg hj">  // ==== Change No.6 ====</strong><br/>  <strong class="lg hj">/**<br/>   * Grab predictions on entering text<br/>   *    by sending reqyest to Google Places API.<br/>   * API details: </strong><a class="ae jo" href="https://developers.google.com/maps/documentation/places/web-service/autocomplete" rel="noopener ugc nofollow" target="_blank"><strong class="lg hj">https://developers.google.com/maps/documentation/places/web-service/autocomplete</strong></a><strong class="lg hj"><br/>  */</strong><br/>  <strong class="lg hj">const onChangeText = async () =&gt; {</strong><br/><strong class="lg hj">    if (search.term.trim() === '') return<br/>    if (!search.fetchPredictions) return</strong></span><span id="b0bf" class="me jq hi lg b fi mj mg l mh mi"><strong class="lg hj">    const apiUrl = `${GOOGLE_PACES_API_BASE_URL}/autocomplete/json?key=${env.GOOGLE_API_KEY}&amp;input=${search.term}`<br/>    try {<br/>      const result = await axios.request({<br/>        method: 'post',<br/>        url: apiUrl<br/>      })<br/>      if (result) {<br/>        const { data: { predictions } } = result<br/>        setPredictions(predictions)<br/>      }<br/>    } catch (e) {<br/>      console.log(e)<br/>    }<br/>  }</strong></span><span id="a3d5" class="me jq hi lg b fi mj mg l mh mi"><strong class="lg hj">  // ==== Change No. 7====<br/>  /**<br/>   * Grab lattitude and longitude on prediction tapped<br/>   *    by sending another reqyest using the place id.<br/>   * You can check what kind of information you can get at:<br/>   *    </strong><a class="ae jo" href="https://developers.google.com/maps/documentation/places/web-service/details#PlaceDetailsRequests" rel="noopener ugc nofollow" target="_blank"><strong class="lg hj">https://developers.google.com/maps/documentation/places/web-service/details#PlaceDetailsRequests</strong></a><strong class="lg hj"><br/>  */<br/>  const onPredictionTapped = async (placeId: string, description: string) =&gt; {<br/>    const apiUrl = `${GOOGLE_PACES_API_BASE_URL}/details/json?key=${env.GOOGLE_API_KEY}&amp;place_id=${placeId}`<br/>    try {<br/>      const result = await axios.request({<br/>        method: 'post',<br/>        url: apiUrl<br/>      })<br/>      if (result) {<br/>        const { data: { result: { geometry: { location } } } } = result<br/>        const { lat, lng } = location<br/>        setShowPredictions(false)<br/>        setSearch({ term: description })<br/>      }<br/>    } catch (e) {<br/>      console.log(e)<br/>    }<br/>  }</strong></span><span id="3353" class="me jq hi lg b fi mj mg l mh mi">return (<br/>    &lt;&gt;<br/>      &lt;StatusBar barStyle="dark-content" /&gt;<br/>      &lt;SafeAreaView style={container}&gt;<br/>        &lt;View style={body}&gt;<br/>          &lt;SearchBarWithAutocomplete<br/>            value={search.term}<br/>            <strong class="lg hj">// ==== Change No. 8 ====<br/>     </strong>       <strong class="lg hj">onChangeText={(text) =&gt; {<br/>              setSearch({ term: text, fetchPredictions: true })<br/>              onChangeText()<br/>            }}</strong><br/>            <strong class="lg hj">showPredictions={showPredictions}<br/>            predictions={predictions}<br/>            onPredictionTapped={onPredictionTapped}</strong><br/>          /&gt;<br/>        &lt;/View&gt;<br/>      &lt;/SafeAreaView&gt;<br/>    &lt;/&gt;<br/>  )<br/>}</span><span id="2154" class="me jq hi lg b fi mj mg l mh mi">const styles = StyleSheet.create({<br/>  container: {<br/>    flex: 1<br/>  },<br/>  body: {<br/>    paddingHorizontal: 20<br/>  }<br/>})</span><span id="ce89" class="me jq hi lg b fi mj mg l mh mi">export default App</span></pre><p id="7614" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">以下是对这些变化的解释。</p><ol class=""><li id="7a39" class="kn ko hi is b it iu ix iy jb nh jf ni jj nj jn nk kv kw kx bi translated">进口<code class="du ld le lf lg b">axios</code></li><li id="e906" class="kn ko hi is b it ky ix kz jb la jf lb jj lc jn nk kv kw kx bi translated">将基本 URL 存储在常量中，以便可以重复使用</li><li id="e88a" class="kn ko hi is b it ky ix kz jb la jf lb jj lc jn nk kv kw kx bi translated">根据谷歌的官方 API 文档定义<code class="du ld le lf lg b">PredictionType</code></li><li id="f4fc" class="kn ko hi is b it ky ix kz jb la jf lb jj lc jn nk kv kw kx bi translated">将<code class="du ld le lf lg b">fetchPredictions</code>添加到<code class="du ld le lf lg b">search</code>状态<br/> <code class="du ld le lf lg b">fetchPredictions</code>用于决定 app 是否应该向 API 发送请求。</li><li id="e1d2" class="kn ko hi is b it ky ix kz jb la jf lb jj lc jn nk kv kw kx bi translated">添加一个新的状态<br/> <code class="du ld le lf lg b">predictions</code>:预测显示</li><li id="ae8d" class="kn ko hi is b it ky ix kz jb la jf lb jj lc jn nk kv kw kx bi translated"><code class="du ld le lf lg b">onChangeText</code>方法<br/>文本改变时调用的方法。它通过向 API 发送请求来获取要显示的预测数据。如果输入为空，它会立即返回，这样就不会发送不必要的请求。<br/>如果<code class="du ld le lf lg b">fetchPredictions</code>设置为<code class="du ld le lf lg b">false</code>也会立即返回。这一行是必要的，以防止应用程序发送请求时，我们更新预测点击搜索栏中的文本。</li><li id="7bc1" class="kn ko hi is b it ky ix kz jb la jf lb jj lc jn nk kv kw kx bi translated"><code class="du ld le lf lg b">onPredictionTapped</code>方法<br/>点击预测时调用的方法。它根据预测信息发送另一个请求，以获取更详细的信息，如纬度和经度。这个应用程序不使用纬度和经度，但如果你想在地图上使用搜索栏，这个功能会很方便。它还将整个地址设置到搜索栏中，而不显示预测。</li><li id="2a65" class="kn ko hi is b it ky ix kz jb la jf lb jj lc jn nk kv kw kx bi translated">将方法和预测向下传递到搜索栏组件</li></ol><p id="3866" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">此外，在搜索栏组件的类型定义中添加新的属性来解决林挺错误。类型定义现在应该是这样的。</p><pre class="lw lx ly lz fd ma lg mb mc aw md bi"><span id="caf7" class="me jq hi lg b fi mf mg l mh mi">// ./components/SearchBarWithAutocomplete.tsx</span><span id="3372" class="me jq hi lg b fi mj mg l mh mi"><strong class="lg hj">// ==== Change No. 1 ====<br/>import { PredictionType } from '../App'</strong></span><span id="5740" class="me jq hi lg b fi mj mg l mh mi">type SearchBarProps = {<br/>  value: string<br/>  style?: ViewStyle | ViewStyle[]<br/>  onChangeText: (text: string) =&gt; void<br/>  <strong class="lg hj">// ==== Change No. 2====<br/>  predictions: PredictionType[]<br/>  showPredictions: boolean<br/>  onPredictionTapped: (placeId: string, description: string) =&gt; void</strong><br/>}</span></pre><ol class=""><li id="22e3" class="kn ko hi is b it iu ix iy jb nh jf ni jj nj jn nk kv kw kx bi translated">从<code class="du ld le lf lg b">App.tsx</code> <br/>导入<code class="du ld le lf lg b">PredictionType</code>为了组织类型，保持项目的整洁，你也可以有一个存储类型定义的文件，将它们导入到其他文件中。例如，您可以创建一个名为<code class="du ld le lf lg b">types.ts</code>的文件，并在那里存储类型定义。</li><li id="f787" class="kn ko hi is b it ky ix kz jb la jf lb jj lc jn nk kv kw kx bi translated">添加新的道具类型</li></ol><h1 id="dc59" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">5.显示预测</h1><p id="af09" class="pw-post-body-paragraph iq ir hi is b it kp iv iw ix kq iz ja jb lt jd je jf lu jh ji jj lv jl jm jn hb bi translated">此时，应用程序应该能够获得必要的数据来显示。接下来，我们将修改搜索栏组件以显示预测。</p><pre class="lw lx ly lz fd ma lg mb mc aw md bi"><span id="2868" class="me jq hi lg b fi mf mg l mh mi">// SearchBarWithAutocomplete.tsx<br/>// Duplicates are omitted and replaced with "..."</span><span id="913d" class="me jq hi lg b fi mj mg l mh mi"><strong class="lg hj">// ==== Change No.1 ====</strong><br/>import React, { FunctionComponent<strong class="lg hj">, useState</strong> } from 'react'<br/><strong class="lg hj">// ==== Change No.2 ====<br/></strong>import {<br/>  ...<br/>  <strong class="lg hj">FlatList,<br/>  TouchableOpacity,<br/>  Text</strong><br/>} from 'react-native'</span><span id="d593" class="me jq hi lg b fi mj mg l mh mi">...</span><span id="5267" class="me jq hi lg b fi mj mg l mh mi">const SearchBarWithAutocomplete: FunctionComponent&lt;SearchBarProps&gt; = props =&gt; {<br/>  <strong class="lg hj">// ==== Change No.3 ====</strong><br/>  <strong class="lg hj">const [inputSize, setInputSize] = useState({ width: 0, height: 0 })</strong></span><span id="f7ba" class="me jq hi lg b fi mj mg l mh mi">  const {<br/>    value,<br/>    style,<br/>    onChangeText,<br/>    <strong class="lg hj">// ==== Change No.4 ====<br/></strong>    <strong class="lg hj">onPredictionTapped,<br/>    predictions,<br/>    showPredictions</strong><br/>  } = props</span><span id="6e62" class="me jq hi lg b fi mj mg l mh mi">  const {<br/>    container,<br/>    inputStyle<br/>  } = styles<br/>  const passedStyles = Array.isArray(style) ? Object.assign({}, ...style) : style<br/>  <strong class="lg hj">// ==== Change No.5 ====<br/>  const inputBottomRadius = showPredictions ?<br/>    {<br/>      borderBottomLeftRadius: 0,<br/>      borderBottomRightRadius: 0<br/>    }<br/>    :<br/>    {<br/>      borderBottomLeftRadius: 20,<br/>      borderBottomRightRadius: 20<br/>    }</strong></span><span id="136d" class="me jq hi lg b fi mj mg l mh mi"><strong class="lg hj">  // ==== Change No.6 ====<br/>  const _renderPredictions = (predictions: PredictionType[]) =&gt; {<br/>    const {<br/>      predictionsContainer,<br/>      predictionRow<br/>    } = styles<br/>    const calculatedStyle = { <br/>      width: inputSize.width<br/>    }<br/>    <br/>    return (<br/>      &lt;FlatList<br/>        data={predictions}<br/>        renderItem={({ item, index }) =&gt; {<br/>          return (<br/>            &lt;TouchableOpacity<br/>              style={predictionRow}<br/>              onPress={() =&gt; onPredictionTapped(item.place_id, item.description)}<br/>            &gt;<br/>              &lt;Text<br/>                numberOfLines={1}<br/>              &gt;<br/>                {item.description}<br/>              &lt;/Text&gt;<br/>            &lt;/TouchableOpacity&gt;<br/>          )<br/>        }}<br/>        keyExtractor={(item) =&gt; item.place_id}<br/>        keyboardShouldPersistTaps='handled'<br/>        style={[predictionsContainer, calculatedStyle]}<br/>      /&gt;<br/>    )<br/>  }</strong></span><span id="275d" class="me jq hi lg b fi mj mg l mh mi">return (<br/>    &lt;View style={[container, { ...passedStyles }]}&gt;<br/>      &lt;TextInput<br/>        <strong class="lg hj">// ==== Change No.7 ====<br/> </strong>       style={<strong class="lg hj">[inputStyle, inputBottomRadius]</strong>}<br/>        placeholder='Search by address'<br/>        placeholderTextColor='gray'<br/>        value={value}<br/>        onChangeText={onChangeText}<br/>        returnKeyType='search'<br/>        <strong class="lg hj">// ==== Change No.8 ====<br/>        onLayout={(event) =&gt; {<br/>          const { height, width } = event.nativeEvent.layout<br/>          setInputSize({ height, width })<br/>        }}</strong><br/>      /&gt;<br/>      <strong class="lg hj">// ==== Change No.9 ====<br/>      {showPredictions &amp;&amp; _renderPredictions(predictions)}</strong><br/>    &lt;/View&gt;<br/>  )<br/>}</span><span id="b822" class="me jq hi lg b fi mj mg l mh mi">const styles = StyleSheet.create({<br/>  ...<strong class="lg hj"><br/>  // ==== Change No.10 ====<br/>  predictionsContainer: {<br/>    backgroundColor: '#cfcfcf',<br/>    padding: 10,<br/>    borderBottomLeftRadius: 10,<br/>    borderBottomRightRadius: 10<br/>  },<br/>  predictionRow: {<br/>    paddingBottom: 15,<br/>    marginBottom: 15,<br/>    borderBottomColor: 'black',<br/>    borderBottomWidth: 1,<br/>  }</strong><br/>})</span><span id="3597" class="me jq hi lg b fi mj mg l mh mi">export default SearchBarWithAutocomplete</span></pre><p id="4b4c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这里是变化的总结。</p><ol class=""><li id="f3e9" class="kn ko hi is b it iu ix iy jb nh jf ni jj nj jn nk kv kw kx bi translated">从<code class="du ld le lf lg b">react</code>进口<code class="du ld le lf lg b">useState</code></li><li id="29e0" class="kn ko hi is b it ky ix kz jb la jf lb jj lc jn nk kv kw kx bi translated">从<code class="du ld le lf lg b">react-native</code>导入<code class="du ld le lf lg b">FlatList</code>、<code class="du ld le lf lg b">TouchableOpacity</code>和<code class="du ld le lf lg b">Text</code></li><li id="4bc9" class="kn ko hi is b it ky ix kz jb la jf lb jj lc jn nk kv kw kx bi translated">添加新状态<code class="du ld le lf lg b">inputSize<br/>inputSize</code>用于匹配预测框宽度和<code class="du ld le lf lg b">TextInput</code>宽度。当<code class="du ld le lf lg b">TextInput</code>被渲染时，其宽度和高度将通过<code class="du ld le lf lg b">onLayout</code> prop 存储在该状态下。</li><li id="6e20" class="kn ko hi is b it ky ix kz jb la jf lb jj lc jn nk kv kw kx bi translated">提取新道具</li><li id="9245" class="kn ko hi is b it ky ix kz jb la jf lb jj lc jn nk kv kw kx bi translated">调整输入风格<br/>显示预测时调整输入风格。否则，由于<code class="du ld le lf lg b">borderBottomRadius</code>，在<code class="du ld le lf lg b">TextInput</code>和预测值之间会有多余的空间。</li><li id="e196" class="kn ko hi is b it ky ix kz jb la jf lb jj lc jn nk kv kw kx bi translated"><code class="du ld le lf lg b">_renderPredictions</code>方法<br/><code class="du ld le lf lg b">_renderPredictions</code>方法用于渲染<code class="du ld le lf lg b">TextInput</code>正下方的预测。</li><li id="0993" class="kn ko hi is b it ky ix kz jb la jf lb jj lc jn nk kv kw kx bi translated">应用输入样式更改</li><li id="dde2" class="kn ko hi is b it ky ix kz jb la jf lb jj lc jn nk kv kw kx bi translated">通过<code class="du ld le lf lg b">onLayout</code>设置<code class="du ld le lf lg b">inputSize</code></li><li id="94ed" class="kn ko hi is b it ky ix kz jb la jf lb jj lc jn nk kv kw kx bi translated">当<code class="du ld le lf lg b">showPredictions</code>为<code class="du ld le lf lg b">true</code>时渲染预测</li><li id="a562" class="kn ko hi is b it ky ix kz jb la jf lb jj lc jn nk kv kw kx bi translated">预测的样式</li></ol><p id="fb22" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在，当您在搜索栏中键入一些内容时，您应该会看到预测。</p><h1 id="8c16" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">6.我们当前实施的一个关键问题</h1><p id="22d3" class="pw-post-body-paragraph iq ir hi is b it kp iv iw ix kq iz ja jb lt jd je jf lu jh ji jj lv jl jm jn hb bi translated">现在，应用程序能够从 API 获得预测，并在应用程序中显示它们。然而，有一个问题。在我们当前的实现中，每次用户输入内容时，应用程序都会发送一个请求。这在性能方面可能非常糟糕。为了解决这个问题，我们可以使用<code class="du ld le lf lg b"><strong class="is hj">debounce</strong></code> <strong class="is hj"> </strong>函数<strong class="is hj">。</strong></p><h1 id="9e15" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">7.什么是去抖功能？</h1><p id="fe46" class="pw-post-body-paragraph iq ir hi is b it kp iv iw ix kq iz ja jb lt jd je jf lu jh ji jj lv jl jm jn hb bi translated"><code class="du ld le lf lg b">debounce</code>函数用于延迟函数调用。例如，当它用于搜索栏时，它等待用户停止输入，这样它就不会进行不必要的函数调用。</p><p id="6461" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">你可能想知道为什么我们不能只使用内置的 JavaScript 函数<code class="du ld le lf lg b">setTimeout</code>。<code class="du ld le lf lg b">setTimeout</code>的问题是传递给它的回调仍然会在每次检测到依赖关系的变化时被调用。它可以延迟函数调用，但是没有它执行的次数是一样的。</p><h1 id="466b" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">8.创建一个自定义挂钩“useDebounce”</h1><p id="3df4" class="pw-post-body-paragraph iq ir hi is b it kp iv iw ix kq iz ja jb lt jd je jf lu jh ji jj lv jl jm jn hb bi translated">现在，为了在我们的应用程序中拥有<code class="du ld le lf lg b">debounce</code>功能，我们将实现一个自定义的<code class="du ld le lf lg b">useDebounce</code>钩子。用下面的代码创建一个名为<code class="du ld le lf lg b">hooks</code>的目录，并在该目录下放置一个名为<code class="du ld le lf lg b">useDebounce.ts</code>的文件。</p><pre class="lw lx ly lz fd ma lg mb mc aw md bi"><span id="cf5a" class="me jq hi lg b fi mf mg l mh mi">// useDebounce.ts</span><span id="c4a3" class="me jq hi lg b fi mj mg l mh mi"><strong class="lg hj">import { useCallback, useEffect } from "react"</strong></span><span id="f073" class="me jq hi lg b fi mj mg l mh mi"><strong class="lg hj">/**<br/> * </strong><a class="ae jo" href="http://twitter.com/param" rel="noopener ugc nofollow" target="_blank"><strong class="lg hj">@param</strong></a><strong class="lg hj"> { (...args: any[]) =&gt; any } fn - A callback function to use debounce effect on.<br/> * </strong><a class="ae jo" href="http://twitter.com/param" rel="noopener ugc nofollow" target="_blank"><strong class="lg hj">@param</strong></a><strong class="lg hj"> { number } delay - A number that indicates how much time it waits.<br/> * </strong><a class="ae jo" href="http://twitter.com/param" rel="noopener ugc nofollow" target="_blank"><strong class="lg hj">@param</strong></a><strong class="lg hj"> { any[] } deps - A dependency list.<br/> * <br/>*/<br/>export const useDebounce = (<br/>  fn: (...args: any[]) =&gt; any,<br/>  delay: number,<br/>  deps: any[]<br/>) =&gt; {<br/>  /**<br/>   * Store the memoized version of the callback.<br/>   * It changes only when one of the dependencies has has changed.<br/>   * See official documentation at: </strong><a class="ae jo" href="https://reactjs.org/docs/hooks-reference.html#usecallback" rel="noopener ugc nofollow" target="_blank"><strong class="lg hj">https://reactjs.org/docs/hooks-reference.html#usecallback</strong></a><strong class="lg hj"><br/>   * */<br/>  const callback = useCallback(fn, deps)</strong></span><span id="6f21" class="me jq hi lg b fi mj mg l mh mi"><strong class="lg hj">  /**<br/>   * useEffect gets re-called whenever "callback" changes.<br/>   * You can add "delay" to the second argument array,<br/>   *    if you want to change "delay" dynamically.<br/>   * */<br/>  useEffect(() =&gt; {<br/>    // Call the memoized version of callback after the delay<br/>    const handler = setTimeout(() =&gt; {<br/>      callback()<br/>    }, delay)</strong></span><span id="3ab7" class="me jq hi lg b fi mj mg l mh mi"><strong class="lg hj">    /**<br/>     * Clear timeout when useEffect gets re-called,<br/>     *    in other words, when "callback" changes.<br/>     * */<br/>    return () =&gt; {<br/>      clearTimeout(handler)<br/>    }<br/>  }, [callback])<br/>}</strong></span></pre><p id="ad5c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我在代码中留下了一些注释来解释每一行，但是基本上，如果用户在一段延迟时间内没有键入任何东西，它所做的只是执行传递的回调函数。</p><h1 id="b874" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">9.修改应用程序以使用“<code class="du ld le lf lg b">useDebounce"</code>挂钩</h1><p id="c817" class="pw-post-body-paragraph iq ir hi is b it kp iv iw ix kq iz ja jb lt jd je jf lu jh ji jj lv jl jm jn hb bi translated">最后，我们需要修改应用程序来使用我们刚刚创建的<code class="du ld le lf lg b">useDebounce</code>钩子。对<code class="du ld le lf lg b">App.tsx</code>进行以下更改。</p><pre class="lw lx ly lz fd ma lg mb mc aw md bi"><span id="766b" class="me jq hi lg b fi mf mg l mh mi">// App.tsx<br/>// Duplicates are omitted and replaced with "..."</span><span id="ee24" class="me jq hi lg b fi mj mg l mh mi">import React, { useState } from 'react'</span><span id="a175" class="me jq hi lg b fi mj mg l mh mi"><strong class="lg hj">// Change No.1<br/>import { useDebounce } from './hooks/useDebounce'</strong></span><span id="115c" class="me jq hi lg b fi mj mg l mh mi">...</span><span id="6d89" class="me jq hi lg b fi mj mg l mh mi">const App = () =&gt; {<br/>  ...</span><span id="2093" class="me jq hi lg b fi mj mg l mh mi">  const onChangeText = async () =&gt; {<br/>    if (search.term.trim() === '') return<br/>    if (!search.fetchPredictions) return</span><span id="6cc0" class="me jq hi lg b fi mj mg l mh mi">    const apiUrl = `${GOOGLE_PACES_API_BASE_URL}/autocomplete/json?key=${env.GOOGLE_API_KEY}&amp;input=${search.term}`<br/>    try {<br/>      const result = await axios.request({<br/>        method: 'post',<br/>        url: apiUrl<br/>      })<br/>      if (result) {<br/>        const { data: { predictions } } = result<br/>        setPredictions(predictions)<br/>        setShowPredictions(true)<br/>      }<br/>    } catch (e) {<br/>      console.log(e)<br/>    }<br/>  }<br/>  <strong class="lg hj">// Change No.2</strong><br/>  <strong class="lg hj">useDebounce(onChangeText, 1000, [search.term])</strong></span><span id="d4e2" class="me jq hi lg b fi mj mg l mh mi">  ...</span><span id="6157" class="me jq hi lg b fi mj mg l mh mi">return (<br/>    &lt;&gt;<br/>      &lt;StatusBar barStyle="dark-content" /&gt;<br/>      &lt;SafeAreaView style={container}&gt;<br/>        &lt;View style={body}&gt;<br/>          &lt;SearchBarWithAutocomplete<br/>            value={search.term}<br/>            <strong class="lg hj">// Change No.3<br/>            onChangeText={(text) =&gt; {<br/>              setSearch({ term: text, fetchPredictions: true })<br/>            }}</strong><br/>            showPredictions={showPredictions}<br/>            predictions={predictions}<br/>            onPredictionTapped={onPredictionTapped}<br/>          /&gt;<br/>        &lt;/View&gt;<br/>      &lt;/SafeAreaView&gt;<br/>    &lt;/&gt;<br/>  )<br/>}</span></pre><ol class=""><li id="a0ac" class="kn ko hi is b it iu ix iy jb nh jf ni jj nj jn nk kv kw kx bi translated">导入<code class="du ld le lf lg b">useDebounce</code></li><li id="395c" class="kn ko hi is b it ky ix kz jb la jf lb jj lc jn nk kv kw kx bi translated">在<code class="du ld le lf lg b">onChangeText<br/></code>下添加调用<code class="du ld le lf lg b">useDebounce</code>的代码行，每当它检测到<code class="du ld le lf lg b">search.term</code>的变化时就会被调用。</li><li id="c612" class="kn ko hi is b it ky ix kz jb la jf lb jj lc jn nk kv kw kx bi translated">更换<code class="du ld le lf lg b">SearchBarWithAutocomplete<br/></code>的<code class="du ld le lf lg b">onChangeText</code>支柱从<code class="du ld le lf lg b">onChangeText</code>支柱上删除线<code class="du ld le lf lg b">onChangeText()</code>，因为不再需要它。</li></ol><p id="5c23" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在，你不应该看到预测，直到你停止输入一秒钟。</p></div><div class="ab cl lh li gp lj" role="separator"><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm"/></div><div class="hb hc hd he hf"><p id="f1dd" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">本文到此为止。</p><p id="5516" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">你可以在<a class="ae jo" href="https://github.com/KentaKodashima/RNCustomSearchBarWithGooglePlacesAutocomplete" rel="noopener ugc nofollow" target="_blank">我的 GitHub 库</a>找到完整的代码。</p><h2 id="ff17" class="me jq hi bd jr mk ml mm jv mn mo mp jz jb mq mr kd jf ms mt kh jj mu mv kl mw bi translated">参考</h2><ul class=""><li id="0df2" class="kn ko hi is b it kp ix kq jb kr jf ks jj kt jn ku kv kw kx bi translated"><strong class="is hj">洛达什官方文件— _。去抖:<br/>【https://lodash.com/docs/4.17.15#debounce】<a class="ae jo" href="https://lodash.com/docs/4.17.15#debounce" rel="noopener ugc nofollow" target="_blank"/></strong></li><li id="29c4" class="kn ko hi is b it ky ix kz jb la jf lb jj lc jn ku kv kw kx bi translated"><strong class="is hj">JavaScript 中的去抖——提高你的应用性能:<br/></strong><a class="ae jo" href="https://levelup.gitconnected.com/debounce-in-javascript-improve-your-applications-performance-5b01855e086" rel="noopener ugc nofollow" target="_blank">https://level up . git connected . com/de bounce-in-JavaScript-Improve-Your-applications-Performance-5b 01855 e086</a></li><li id="c430" class="kn ko hi is b it ky ix kz jb la jf lb jj lc jn ku kv kw kx bi translated"><strong class="is hj">去抖解释——如何让你的 JavaScript 等待你的用户完成打字:<br/></strong><a class="ae jo" href="https://www.freecodecamp.org/news/debounce-explained-how-to-make-your-javascript-wait-for-your-user-to-finish-typing-2/" rel="noopener ugc nofollow" target="_blank">https://www . freecodecamp . org/news/de bounce-Explained-How-To-Make-Your-JavaScript-Wait-Your-User-To-Finish-Typing-2/</a></li><li id="82e4" class="kn ko hi is b it ky ix kz jb la jf lb jj lc jn ku kv kw kx bi translated"><strong class="is hj">stack overflow—React Hook 如何使用油门或去抖？:<br/></strong><a class="ae jo" href="https://stackoverflow.com/questions/54666401/how-to-use-throttle-or-debounce-with-react-hook" rel="noopener ugc nofollow" target="_blank">https://stack overflow . com/questions/54666401/how-to-use-throttle-or-de bounce-with-react-hook</a></li><li id="7fb8" class="kn ko hi is b it ky ix kz jb la jf lb jj lc jn ku kv kw kx bi translated"><strong class="is hj"> GitHub 问题—无法从 XCode 中的框构建 react native:找不到“event2/event-config.h”文件# 30836:<br/></strong><a class="ae jo" href="https://github.com/facebook/react-native/issues/30836" rel="noopener ugc nofollow" target="_blank">https://github.com/facebook/react-native/issues/30836</a></li><li id="72d1" class="kn ko hi is b it ky ix kz jb la jf lb jj lc jn ku kv kw kx bi translated"><strong class="is hj">升级到 macOS Big Sur v11.0.1 后的错误 JAVA _ HOME:<br/></strong><a class="ae jo" href="https://stackoverflow.com/questions/64917779/wrong-java-home-after-upgrade-to-macos-big-sur-v11-0-1" rel="noopener ugc nofollow" target="_blank">https://stack overflow . com/questions/64917779/error-JAVA-HOME-after-upgrade-to-MAC OS-Big-Sur-v 11-0-1</a></li><li id="e969" class="kn ko hi is b it ky ix kz jb la jf lb jj lc jn ku kv kw kx bi translated"><strong class="is hj">如何在 MacOS 上卸载 Java:【https://explainjava.com/uninstall-java-macos/】</strong><a class="ae jo" href="https://explainjava.com/uninstall-java-macos/" rel="noopener ugc nofollow" target="_blank"/></li><li id="6549" class="kn ko hi is b it ky ix kz jb la jf lb jj lc jn ku kv kw kx bi translated"><strong class="is hj">使用 Homebrew 和 JEnv 在 MacOS 上安装 Java:<br/></strong><a class="ae jo" href="https://dev.to/gabethere/installing-java-on-a-mac-using-homebrew-and-jevn-12m8" rel="noopener ugc nofollow" target="_blank">https://dev . to/gabethere/Installing-Java-on-a-MAC-using-home brew-and-jevn-12 M8</a></li><li id="8538" class="kn ko hi is b it ky ix kz jb la jf lb jj lc jn ku kv kw kx bi translated"><strong class="is hj"> GitHub 资源库—AdoptOpenJDK/home brew-open JDK:<br/></strong><a class="ae jo" href="https://github.com/AdoptOpenJDK/homebrew-openjdk" rel="noopener ugc nofollow" target="_blank">https://github.com/AdoptOpenJDK/homebrew-openjdk</a></li><li id="b3fa" class="kn ko hi is b it ky ix kz jb la jf lb jj lc jn ku kv kw kx bi translated"><strong class="is hj"> GitHub 资源库—jenv/jenv:<br/></strong><a class="ae jo" href="https://github.com/jenv/jenv" rel="noopener ugc nofollow" target="_blank">https://github.com/jenv/jenv</a></li></ul></div></div>    
</body>
</html>