<html>
<head>
<title>LeetCode — Single Number</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">LeetCode —单一数字</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/leetcode-single-number-308915bcc307?source=collection_archive---------3-----------------------#2022-02-12">https://medium.com/nerd-for-tech/leetcode-single-number-308915bcc307?source=collection_archive---------3-----------------------#2022-02-12</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><h1 id="e12a" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">问题陈述</h1><p id="15a6" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">给定一个<strong class="jf hj">非空的</strong>整数数组<em class="kb">num</em>，每个元素出现<em class="kb">两次</em>，除了一个。找到那个单身的。</p><p id="d734" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated">您必须实现一个具有线性运行时复杂性的解决方案，并且只使用恒定的额外空间。</p><p id="0ec2" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated">问题陈述摘自:<a class="ae kh" href="https://leetcode.com/problems/single-number" rel="noopener ugc nofollow" target="_blank">https://leetcode.com/problems/single-number</a>。</p><p id="8758" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated"><strong class="jf hj">例 1: </strong></p><pre class="ki kj kk kl fd km kn ko kp aw kq bi"><span id="edc5" class="kr ig hi kn b fi ks kt l ku kv">Input: nums = [2, 2, 1]<br/>Output: 1</span></pre><p id="635a" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated"><strong class="jf hj">例 2: </strong></p><pre class="ki kj kk kl fd km kn ko kp aw kq bi"><span id="cc3e" class="kr ig hi kn b fi ks kt l ku kv">Input: nums = [4, 1, 2, 1, 2]<br/>Output: 4</span></pre><p id="7373" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated"><strong class="jf hj">例 3: </strong></p><pre class="ki kj kk kl fd km kn ko kp aw kq bi"><span id="b014" class="kr ig hi kn b fi ks kt l ku kv">Input: nums = [1]<br/>Output: 1</span></pre><p id="f00a" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated"><strong class="jf hj">约束:</strong></p><pre class="ki kj kk kl fd km kn ko kp aw kq bi"><span id="9bc1" class="kr ig hi kn b fi ks kt l ku kv">- 1 &lt;= nums.length &lt;= 3 * 10^4<br/>- -3 * 10^4 &lt;= nums[i] &lt;= 3 * 10^4<br/>- Each element in the array appears twice except for one element which appears only once.</span></pre><h1 id="8969" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">说明</h1><h2 id="13d9" class="kr ig hi bd ih kw kx ky il kz la lb ip jo lc ld it js le lf ix jw lg lh jb li bi translated">强力解决方案</h2><p id="6d2a" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">强力解决方案是检查每个元素是否出现一次。一旦找到只出现一次的元素，我们就返回该元素。上述方法的时间复杂度为<strong class="jf hj"> O(N ) </strong>。</p><p id="759d" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated">通过使用散列，时间复杂度可以降低到<strong class="jf hj"> O(N) </strong>。我们遍历数组中的所有元素，并将它们放入哈希表中。数组元素将是哈希表中的键，它的值将是该元素在数组中出现的次数。</p><p id="acf1" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated">这种方法的 C++代码片段如下:</p><pre class="ki kj kk kl fd km kn ko kp aw kq bi"><span id="b95a" class="kr ig hi kn b fi ks kt l ku kv">int singleNumber(vector&lt;int&gt;&amp; nums) {<br/>    map&lt;int, int&gt; m;<br/><br/>    for(int i = 0; i &lt; nums.size(); i++) {<br/>        m[nums[i]]++;<br/>    }<br/><br/>    for(auto const &amp; [key, value]: m) {<br/>        if(value == 1) {<br/>            return key;<br/>        }<br/>    }<br/><br/>    return -1;<br/>}</span></pre><p id="8678" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated">时间复杂度降低到了<strong class="jf hj"> O(N) </strong>，但是空间复杂度增加到了<strong class="jf hj"> O(N) </strong>。</p><h2 id="f26c" class="kr ig hi bd ih kw kx ky il kz la lb ip jo lc ld it js le lf ix jw lg lh jb li bi translated">优化解决方案</h2><p id="cf25" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">通过使用单个 int 变量，我们可以将空间复杂度降低到<strong class="jf hj"> O(1) </strong>。我们可以用算术异或运算符<strong class="jf hj"> ^ </strong>。当操作数相似时，XOR 运算符返回 0。</p><pre class="ki kj kk kl fd km kn ko kp aw kq bi"><span id="8639" class="kr ig hi kn b fi ks kt l ku kv">3 ^ 1<br/>=&gt; 2<br/><br/>3 ^ 2<br/>=&gt; 0<br/><br/>3 ^ 0<br/>=&gt; 3</span></pre><p id="3873" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated">由于数组中的每个元素除了一个以外都出现了两次，所以对所有重复元素的 XOR 运算将返回 0。并且对任何非零数字与零进行 XOR 运算将返回相同的数字。我们需要迭代数组，并对所有元素执行 XOR 运算。</p><p id="d6a9" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated">现在我们来检查一下算法。</p><pre class="ki kj kk kl fd km kn ko kp aw kq bi"><span id="65d3" class="kr ig hi kn b fi ks kt l ku kv">- initialize singleNum = 0<br/><br/>- loop for i = 0; i &lt; nums.size(); i++<br/>  - singleNum ^= nums[i]<br/><br/>- return singleNum</span></pre><p id="6ea5" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated">让我们来看看我们在<strong class="jf hj"> C++ </strong>、<strong class="jf hj"> Golang </strong>和<strong class="jf hj"> Javascript </strong>中的解决方案。</p><h2 id="4288" class="kr ig hi bd ih kw kx ky il kz la lb ip jo lc ld it js le lf ix jw lg lh jb li bi translated">C++解决方案</h2><pre class="ki kj kk kl fd km kn ko kp aw kq bi"><span id="af68" class="kr ig hi kn b fi ks kt l ku kv">class Solution {<br/>public:<br/>    int singleNumber(vector&lt;int&gt;&amp; nums) {<br/>        int singleNum = 0;<br/><br/>        for(int i = 0; i &lt; nums.size(); i++) {<br/>            singleNum ^= nums[i];<br/>        }<br/><br/>        return singleNum;<br/>    }<br/>};</span></pre><h2 id="34a7" class="kr ig hi bd ih kw kx ky il kz la lb ip jo lc ld it js le lf ix jw lg lh jb li bi translated">戈朗溶液</h2><pre class="ki kj kk kl fd km kn ko kp aw kq bi"><span id="8ce7" class="kr ig hi kn b fi ks kt l ku kv">f<!-- -->unc singleNumber(nums []int) int {<br/>    singleNum := 0<br/><br/>    for i := 0; i &lt; len(nums); i++ {<br/>        singleNum ^= nums[i]<br/>    }<br/><br/>    return singleNum<br/>}</span></pre><h2 id="284c" class="kr ig hi bd ih kw kx ky il kz la lb ip jo lc ld it js le lf ix jw lg lh jb li bi translated">Javascript 解决方案</h2><pre class="ki kj kk kl fd km kn ko kp aw kq bi"><span id="639f" class="kr ig hi kn b fi ks kt l ku kv">var singleNumber = function(nums) {<br/>    let singleNum = 0;<br/><br/>    for(let i = 0; i &lt; nums.length; i++) {<br/>        singleNum ^= nums[i];<br/>    }<br/><br/>    return singleNum;<br/>};</span></pre><p id="0fa8" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated">让我们试运行一下我们的算法，看看解决方案是如何工作的。</p><pre class="ki kj kk kl fd km kn ko kp aw kq bi"><span id="9ee7" class="kr ig hi kn b fi ks kt l ku kv">Input: nums = [4, 1, 2, 1, 2]<br/><br/>Step 1: singleNum = 0<br/><br/>Step 2: loop for i = 0; i &lt; nums.size()<br/>          0 &lt; 5<br/>          true<br/><br/>          singleNum ^= nums[i]<br/>                     = singleNum ^ nums[0]<br/>                     = 0 ^ 4<br/>                     = 4<br/><br/>          i++<br/>          i = 1<br/><br/>Step 3: i &lt; nums.size()<br/>          1 &lt; 5<br/>          true<br/><br/>          singleNum ^= nums[i]<br/>                     = singleNum ^ nums[1]<br/>                     = 4 ^ 1<br/>                     = 5<br/><br/>          i++<br/>          i = 2<br/><br/>Step 4: i &lt; nums.size()<br/>          2 &lt; 5<br/>          true<br/><br/>          singleNum ^= nums[i]<br/>                     = singleNum ^ nums[2]<br/>                     = 5 ^ 2<br/>                     = 7<br/><br/>          i++<br/>          i = 3<br/><br/>Step 5: i &lt; nums.size()<br/>          3 &lt; 5<br/>          true<br/><br/>          singleNum ^= nums[i]<br/>                     = singleNum ^ nums[3]<br/>                     = 7 ^ 1<br/>                     = 6<br/><br/>          i++<br/>          i = 4<br/><br/>Step 6: i &lt; nums.size()<br/>          4 &lt; 5<br/>          true<br/><br/>          singleNum ^= nums[i]<br/>                     = singleNum ^ nums[4]<br/>                     = 6 ^ 2<br/>                     = 4<br/><br/>          i++<br/>          i = 5<br/><br/>Step 7: i &lt; nums.size()<br/>          5 &lt; 5<br/>          false<br/><br/>Step 8: return singleNum<br/><br/>So we return the answer as 4.</span></pre></div><div class="ab cl lj lk gp ll" role="separator"><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo"/></div><div class="hb hc hd he hf"><p id="099f" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated"><em class="kb">原载于</em><a class="ae kh" href="https://alkeshghorpade.me/post/leetcode-single-number" rel="noopener ugc nofollow" target="_blank"><em class="kb">https://alkeshghorpade . me</em></a><em class="kb">。</em></p></div></div>    
</body>
</html>