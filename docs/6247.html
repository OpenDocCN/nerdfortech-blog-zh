<html>
<head>
<title>LeetCode — Balanced Binary Tree</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">平衡二叉树</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/leetcode-balanced-binary-tree-c80f02e2ac58?source=collection_archive---------1-----------------------#2022-01-22">https://medium.com/nerd-for-tech/leetcode-balanced-binary-tree-c80f02e2ac58?source=collection_archive---------1-----------------------#2022-01-22</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><h1 id="c9a0" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">问题陈述</h1><p id="a823" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">给定一棵二叉树，确定它是否是高度平衡的。</p><p id="6831" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">对于这个问题，高度平衡的二叉树被定义为:</p><pre class="kg kh ki kj fd kk kl km kn aw ko bi"><span id="1c1c" class="kp ig hi kl b fi kq kr l ks kt">a binary tree in which the left and right subtrees of every node differ in height by no more than 1.</span></pre><p id="0fd9" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">问题陈述摘自:<a class="ae ku" href="https://leetcode.com/problems/balanced-binary-tree" rel="noopener ugc nofollow" target="_blank">https://leetcode.com/problems/balanced-binary-tree</a></p><p id="b9ec" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated"><strong class="jf hj">例一:</strong></p><figure class="kg kh ki kj fd kw er es paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="er es kv"><img src="../Images/ca1e34a16a5ce4c68c3f2225ee79320a.png" data-original-src="https://miro.medium.com/v2/resize:fit:684/format:webp/0*x8hHRKyq-7PMhLso.png"/></div></div></figure><pre class="kg kh ki kj fd kk kl km kn aw ko bi"><span id="03e3" class="kp ig hi kl b fi kq kr l ks kt">Input: root = [3, 9, 20, null, null, 15, 7] <br/>Output: true</span></pre><p id="6f21" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated"><strong class="jf hj">例二:</strong></p><figure class="kg kh ki kj fd kw er es paragraph-image"><div class="er es ld"><img src="../Images/8969ec02cfd2c7410dfde65f62aba31c.png" data-original-src="https://miro.medium.com/v2/resize:fit:904/format:webp/0*c47g8f_61T80VQjK.png"/></div></figure><pre class="kg kh ki kj fd kk kl km kn aw ko bi"><span id="8d7e" class="kp ig hi kl b fi kq kr l ks kt">Input: root = [1, 2, 2, 3, 3, null, null, 4, 4] <br/>Output: false</span></pre><p id="02c5" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated"><strong class="jf hj">例3: </strong> <strong class="jf hj">约束:</strong></p><pre class="kg kh ki kj fd kk kl km kn aw ko bi"><span id="bf23" class="kp ig hi kl b fi kq kr l ks kt">- The number of nodes in the tree is in the range [0, 5000] <br/>- -10^4 &lt;= Node.val &lt;= 10^4</span></pre><h1 id="afae" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">说明</h1><h2 id="3e34" class="kp ig hi bd ih le lf lg il lh li lj ip jo lk ll it js lm ln ix jw lo lp jb lq bi translated">强力方法</h2><p id="bb87" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">验证树是否平衡的强力方法是获得左右子树的高度。如果差值不超过1，则返回true，否则返回false。</p><p id="db26" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">上述方法的一个C++片段如下所示:</p><pre class="kg kh ki kj fd kk kl km kn aw ko bi"><span id="f6dc" class="kp ig hi kl b fi kq kr l ks kt">int height(node* node) {<br/>    if (node == NULL)<br/>        return 0;<br/><br/>    return 1 + max(height(node-&gt;left), height(node-&gt;right));<br/>}<br/><br/>bool isBalanced(node* root) {<br/>    int leftHeight, rightHeight;<br/><br/>    if (root == NULL)<br/>        return 1;<br/><br/>    leftHeight = height(root-&gt;left);<br/>    rightHeight = height(root-&gt;right);<br/><br/>    if (abs(leftHeight - rightHeight) &lt;= 1 &amp;&amp; isBalanced(root-&gt;left) &amp;&amp; isBalanced(root-&gt;right))<br/>        return 1;<br/><br/>    return 0;<br/>}</span></pre><p id="df83" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">上述方法的时间复杂度为O(N ) 。</p><h2 id="bd86" class="kp ig hi bd ih le lf lg il lh li lj ip jo lk ll it js lm ln ix jw lo lp jb lq bi translated">优化解决方案</h2><p id="60a9" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">如果我们仔细观察这种方法，我们可以在高度递归函数中计算左右子树的差异。如果在任何时间点左右子树之间的差大于1，我们返回false。</p><p id="ec35" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">我们先检查一下算法。</p><pre class="kg kh ki kj fd kk kl km kn aw ko bi"><span id="7f14" class="kp ig hi kl b fi kq kr l ks kt">// isBalanced function<br/>1. - if root == nullptr<br/>     - return true<br/><br/>2. - return height(root) != -1<br/><br/>// height function<br/>3. - if root == nullptr<br/>     - return 0<br/><br/>4. - set leftHeight = height(root-&gt;left)<br/>5. - set rightHeight = height(root-&gt;right)<br/><br/>6. - if leftHeight == -1 || rightHeight == -1 || abs(leftHeight - rightHeight) &gt; 1<br/>     - return -1<br/><br/>7. - return 1 + max(leftHeight, rightHeight)</span></pre><p id="ed8a" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">在<strong class="jf hj"> isBalanced </strong>函数中，我们首先检查树是否为空。如果它是空的，我们返回true。如果没有，我们将根传递给高度函数。</p><p id="95b0" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">在<strong class="jf hj">高度</strong>函数中，我们检查根是否为空。我们为空元素返回0。</p><p id="667f" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">在步骤4和5，我们递归地调用左右子树。在步骤6中，我们检查leftHeight或rightHeight是否为-1，或者左右高度之间的绝对差是否大于1。如果差值大于1，则返回-1。流程退回到步骤2并验证是否<em class="lr"> -1！= -1 </em>。这是错误的，表明树是不平衡的。否则我们在步骤7返回，<em class="lr"> 1 + max(leftHeight，rightHeight) </em></p><h2 id="bc37" class="kp ig hi bd ih le lf lg il lh li lj ip jo lk ll it js lm ln ix jw lo lp jb lq bi translated">C++解决方案</h2><pre class="kg kh ki kj fd kk kl km kn aw ko bi"><span id="0c63" class="kp ig hi kl b fi kq kr l ks kt">class Solution {<br/>public:<br/>    int height(TreeNode* root) {<br/>        if(root == nullptr) {<br/>            return 0;<br/>        }<br/><br/>        int leftHeight = height(root-&gt;left);<br/>        int rightHeight = height(root-&gt;right);<br/><br/>        if(leftHeight == -1 || rightHeight == -1 || abs(leftHeight - rightHeight) &gt; 1) {<br/>            return -1;<br/>        }<br/><br/>        return 1 + max(leftHeight, rightHeight);<br/>    }<br/><br/>    bool isBalanced(TreeNode* root) {<br/>        if(root == nullptr) {<br/>            return true;<br/>        }<br/><br/>        return height(root) != -1;<br/>    }<br/>};</span></pre><h2 id="bfe6" class="kp ig hi bd ih le lf lg il lh li lj ip jo lk ll it js lm ln ix jw lo lp jb lq bi translated">戈朗溶液</h2><pre class="kg kh ki kj fd kk kl km kn aw ko bi"><span id="8171" class="kp ig hi kl b fi kq kr l ks kt">func maximum(a, b int) int {<br/>    if a &gt; b {<br/>        return a<br/>    } else {<br/>        return b<br/>    }<br/>}<br/><br/>func height(root *TreeNode) int {<br/>    if root == nil {<br/>        return 0;<br/>    }<br/><br/>    leftHeight := height(root.Left)<br/>    rightHeight := height(root.Right)<br/><br/>    if leftHeight == -1 || rightHeight == -1 || int(math.Abs(float64(leftHeight - rightHeight))) &gt; 1 {<br/>        return -1<br/>    }<br/><br/>    return 1 + maximum(leftHeight, rightHeight)<br/>}<br/><br/>func isBalanced(root *TreeNode) bool {<br/>    if root == nil {<br/>        return true<br/>    }<br/><br/>    return height(root) != -1<br/>}</span></pre><h2 id="481b" class="kp ig hi bd ih le lf lg il lh li lj ip jo lk ll it js lm ln ix jw lo lp jb lq bi translated">Javascript解决方案</h2><pre class="kg kh ki kj fd kk kl km kn aw ko bi"><span id="bb9a" class="kp ig hi kl b fi kq kr l ks kt">var height = function(root) {<br/>    if(root === null) {<br/>        return 0;<br/>    }<br/><br/>    let leftHeight = height(root.left);<br/>    let rightHeight = height(root.right);<br/><br/>    if(leftHeight == -1 || rightHeight == -1 || Math.abs(leftHeight - rightHeight) &gt; 1) {<br/>        return -1;<br/>    }<br/><br/>    return 1 + Math.max(leftHeight, rightHeight);<br/>};<br/><br/>var isBalanced = function(root) {<br/>    if(root === null) {<br/>        return true;<br/>    }<br/><br/>    return height(root) != -1;<br/>};</span></pre><p id="d3ce" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">让我们试运行一下我们的算法，看看解决方案是如何工作的。</p><pre class="kg kh ki kj fd kk kl km kn aw ko bi"><span id="7bac" class="kp ig hi kl b fi kq kr l ks kt">Input: root = [3, 9, 20, null, null, 15, 7]<br/><br/>      root<br/>        |<br/>       [3, 9, 20, null, null, 15, 7]<br/><br/>// In isBalanced function<br/>Step 1: if root == nullptr<br/>           false<br/><br/>Step 2: return height(root) != -1<br/><br/>// In height function<br/><br/>       root<br/>        |<br/>       [3, 9, 20, null, null, 15, 7]<br/><br/>Step 3: if root == nullptr<br/>           false<br/><br/>Step 4: leftHeight = height(root-&gt;left)<br/>        root-&gt;left points to 9<br/><br/>          root<br/>           |<br/>       [3, 9, 20, null, null, 15, 7]<br/><br/>Step 5: if root == nullptr<br/>           false<br/><br/>Step 6: leftHeight = height(root-&gt;left)<br/>        root-&gt;left points to null<br/>        So we get back here with value as 0 and it calls the next step.<br/><br/>        rightHeight = height(root-&gt;right)<br/>        root-&gt;right points to null<br/>        So we get back here with a value of 0, and it calls the next step.<br/><br/>        leftHeight = 0<br/>        rightHeight = 0<br/>        abs(0 - 0) &gt; 1<br/>        false<br/><br/>        if(leftHeight == -1 || rightHeight == -1 || abs(leftHeight - rightHeight) &gt; 1)<br/>          false<br/><br/>        return 1 + max(leftHeight, rightHeight)<br/>               1 + max(0, 0)<br/>               1<br/><br/>Step 7: We fallback to Step 4 and execute the next line<br/>        rightHeight = height(root-&gt;right)<br/>        root-&gt;right points to 20<br/><br/>             root<br/>              |<br/>       [3, 9, 20, null, null, 15, 7]<br/><br/>Step 9: if root == nullptr<br/>           false<br/><br/>Step 10: leftHeight = height(root-&gt;left)<br/>         root-&gt;left points to 15<br/><br/>                              root<br/>                               |<br/>        [3, 9, 20, null, null, 15, 7]<br/><br/>Step 11: if root == nullptr<br/>           false<br/><br/>Step 12: leftHeight = height(root-&gt;left)<br/>         root-&gt;left points to null<br/>         So we get back here with value as 0 and it calls the next step.<br/><br/>         rightHeight = height(root-&gt;right)<br/>         root-&gt;right points to null<br/>         So we get back here with a value of 0, and it calls the next step.<br/><br/>         leftHeight = 0<br/>         rightHeight = 0<br/>         abs(0 - 0) &gt; 1<br/>         false<br/><br/>         if(leftHeight == -1 || rightHeight == -1 || abs(leftHeight - rightHeight) &gt; 1)<br/>           false<br/><br/>         return 1 + max(leftHeight, rightHeight)<br/>                1 + max(0, 0)<br/>                1<br/><br/>Step 13: We fallback to step 10 and execute next line<br/>         rightHeight = height(root-&gt;right)<br/>         root-&gt;right points to 7<br/><br/>                                 root<br/>                                   |<br/>        [3, 9, 20, null, null, 15, 7]<br/><br/>Step 14: if root == nullptr<br/>           false<br/><br/>Step 15: leftHeight = height(root-&gt;left)<br/>         root-&gt;left points to null<br/>         So we get back here with value as 0 and it calls the next step.<br/><br/>         rightHeight = height(root-&gt;right)<br/>         root-&gt;right points to null<br/>         So we get back here with a value of 0, and it calls the next step.<br/><br/>         leftHeight = 0<br/>         rightHeight = 0<br/>         abs(0 - 0) &gt; 1<br/>         false<br/><br/>         if(leftHeight == -1 || rightHeight == -1 || abs(leftHeight - rightHeight) &gt; 1)<br/>           false<br/><br/>         return 1 + max(leftHeight, rightHeight)<br/>                1 + max(0, 0)<br/>                1<br/><br/>Step 16: We fallback to Step 7 and execute next lines<br/>         leftHeight = 1<br/>         rightHeight = 1<br/>         abs(1 - 1) &gt; 1<br/>         false<br/><br/>         if(leftHeight == -1 || rightHeight == -1 || abs(leftHeight - rightHeight) &gt; 1)<br/>           false<br/><br/>         return 1 + max(leftHeight, rightHeight)<br/>                1 + max(1, 1)<br/>                2<br/><br/>Step 17: We fallback to Step 2 and execute next lines<br/>         leftHeight = 1<br/>         rightHeight = 2<br/>         abs(1 - 2) &gt; 1<br/>         false<br/><br/>         if(leftHeight == -1 || rightHeight == -1 || abs(leftHeight - rightHeight) &gt; 1)<br/>           false<br/><br/>         return 1 + max(leftHeight, rightHeight)<br/>                1 + max(1, 2)<br/>                3<br/><br/>Step 18: We return back to isBalanced function and execute the last return part<br/>         return height(root) != -1<br/>           3 != -1<br/>           true<br/><br/>So we return the answer as true.</span></pre></div><div class="ab cl ls lt gp lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="hb hc hd he hf"><p id="38cb" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated"><em class="lr">原载于</em><a class="ae ku" href="https://alkeshghorpade.me/post/leetcode-balanced-binary-tree" rel="noopener ugc nofollow" target="_blank"><em class="lr">https://alkeshghorpade . me</em></a><em class="lr">。</em></p></div></div>    
</body>
</html>