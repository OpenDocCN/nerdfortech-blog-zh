<html>
<head>
<title>How a SQL Statement is processed in Oracle?| Interview Q&amp; A</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Oracle中如何处理SQL语句？|采访问答</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/how-a-sql-statement-is-processed-in-oracle-ede6a831d83?source=collection_archive---------1-----------------------#2021-12-07">https://medium.com/nerd-for-tech/how-a-sql-statement-is-processed-in-oracle-ede6a831d83?source=collection_archive---------1-----------------------#2021-12-07</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="20e2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这里我们将了解oracle中的SQL语句处理步骤</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es jd"><img src="../Images/88b5088ca497618d809df17e30cf923a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1120/format:webp/1*EmYq0qzyAq4NzD5UheoHyA.png"/></div></figure><p id="2d43" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">语法检查:</strong></p><p id="953c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Oracle服务器在执行语句之前会遵循一些步骤</p><p id="9880" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">语法检查:</p><p id="e95a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">语义检查:</strong></p><p id="4b52" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">一旦语法检查通过，服务器接下来要做的就是应用语义检查。</p><p id="dc9a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这意味着，我们的表在数据库中，哪些列会在那里，select * from table name，这是存储在数据字典缓存中的。</p><p id="be7f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">所以它从那里获取信息。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es jl"><img src="../Images/47377824d1926e1265559283ebf4363f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1236/format:webp/1*RR-5W5Q3_r8Y9Qo59EkcEA.png"/></div></figure><p id="7a36" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">权限检查:</strong></p><p id="ce7e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">下一步是检查特权。在这里，它将决定运行查询的用户是否有适当的权限来运行它。</p><p id="0cec" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这也存储在数据字典缓存中。</p><p id="3672" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果用户没有该权限，它将返回一个类似上述步骤的错误，并结束执行。</p><p id="1dc9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">其余步骤不执行。如果所有这些步骤都成功了，那么是时候继续前进了。</p><p id="2d50" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">私有SQL区:</strong></p><p id="cecc" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">因为我们将处理一个查询并将它存储在内存中以便用游标处理，所以它创建了一个私有的</p><p id="568b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">用户PGA中的SQL区域。该查询的结果将暂时存储在这里。一旦用户断开连接，分配的内存将返回给SGA。</p><p id="43f7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">查询执行:</strong></p><p id="e215" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">查询执行的下一步将是找到一个执行计划。我们知道，如果一个</p><p id="1f7c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">查询之前执行，它的执行计划存储在共享池中的共享SQL区域，因此服务器检查任何现有的执行计划。</p><p id="b089" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果是，我们现在将通过一个非常昂贵的过程，直接执行我们的查询。现在我需要解释一下。</p><p id="06d1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">软解析/库缓存命中- </strong>我们的查询在共享池中找到。</p><p id="dad4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">硬解析/库缓存缺失- </strong>共享池中未找到我们的查询</p><p id="d16f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在Hardparse中，我们还有三个阶段</p><p id="19c8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> 1)分配的共享SQL: </strong></p><p id="fa9d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">硬解析的第一步是为此在共享SQL区域中分配一些内存。因为新的执行计划会写在这里。</p><p id="bfca" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这种分配可能需要一点时间，因为如果共享SQL区域已满，它将删除一个旧的区域，为新的区域腾出空间，等等。</p><p id="3de1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> 2)优化:</strong></p><p id="639a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">那么接下来就是“优化”了。优化是性能调优过程中最重要的事情。我们将主要调整我们的查询以获得更好的优化。</p><p id="44f6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">优化器只不过是一个软件，它将我们的查询作为输入，并返回最佳执行计划。我们知道一个查询可以用许多不同的方式执行。</p><p id="98c0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">优化器是用来在这么多方法中选择最佳执行计划的。</p><p id="b319" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">通常，一个优化器需要计算几个执行计划，并在一秒钟内选择其中一个。</p><p id="ea89" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">但是，您可以更改优化级别并增加这个时间间隔。所以优化器可以多计算一些时间，也许它可以返回一个更好的执行计划。</p><p id="037d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> 3)行来源生成过程:</strong></p><p id="b438" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">一旦创建了执行计划，就开始行来源生成过程。</p><p id="9e08" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">它获取执行计划并生成执行步骤。</p><p id="e76d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">例如，首先从客户的表中获取数据，然后对其进行排序，然后在获取的同时从products表中获取数据，连接这些，对其进行排序等。</p><p id="9591" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">但基本上，它会找出如何从表中获取数据以及如何操作数据等。</p><p id="6be1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">一旦生成了行源，就使用这些步骤执行语句，并将结果返回给用户。</p><p id="81c1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">因此，SQL查询的执行就是这样。</p><p id="d66d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果您再次运行相同的查询，而不是再次解析它或在共享SQL区域中搜索</p><p id="345c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">它直接转到该执行计划在库缓存中的确切位置。</p><p id="2d57" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">一旦我们运行一个查询，它的执行计划就存储在库缓存中。</p><p id="f302" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">此外，该执行计划的rowid也存储在私有SQL区域中。</p><p id="8957" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">因此，一旦您运行相同的语句，它会直接使用它所拥有的rowid访问库缓存，并快速找到执行计划。</p><p id="1bac" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">无需再次在库缓存中搜索该散列。</p><p id="7ca9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">它并不保留我们执行的每个查询的所有地址。</p><p id="c8db" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">默认情况下，它只保留其中的50个。但这是可以改变的。解析是一项非常昂贵的操作。</p><p id="cd06" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">很多时候，比执行力还贵。</p><p id="725f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">所以我们将特别避免查询的解析过程。即使是软解析也是一个昂贵的过程。为了避免这种情况，我们可以使用结果缓存。</p><p id="996e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这意味着如果你的SQL语法是正确的。如果没有，它将立即返回一个错误。</p><p id="cb1a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">语义检查:</p><p id="757e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">一旦语法检查通过，服务器接下来要做的就是应用语义检查。</p><p id="9200" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这意味着，我们的表在数据库中，哪些列会在那里，select * from table name，这是存储在数据字典缓存中的。</p><p id="6b81" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">所以它从那里获取信息。</p><p id="356d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">权限检查:</p><p id="6f9b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">下一步是检查特权。在这里，它将决定运行查询的用户是否有适当的权限来运行它。</p><p id="3c7d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这也存储在数据字典缓存中。</p><p id="2dc8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果用户没有该权限，它将返回一个类似上述步骤的错误，并结束执行。</p><p id="ec18" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">其余步骤不执行。如果所有这些步骤都成功了，那么是时候继续前进了。</p><p id="3a9a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">私有SQL区域:</p><p id="1ec1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">因为我们将处理一个查询并将它存储在内存中以便用游标处理，所以它创建了一个私有的</p><p id="80f9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">用户PGA中的SQL区域。该查询的结果将暂时存储在这里。一旦用户断开连接，分配的内存将返回给SGA。</p><p id="3d02" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">查询执行:</p><p id="7897" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">查询执行的下一步将是找到一个执行计划。我们知道，如果一个</p><p id="265d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">查询被执行之前，其执行计划被存储在共享池中的共享SQL区域。</p><p id="84e0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">因此服务器检查任何现有的执行计划。</p><p id="b16e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果是，我们现在将通过一个非常昂贵的过程，直接执行我们的查询。现在我需要解释一下。</p><p id="18f6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">软解析/库缓存命中—我们的查询在共享池中找到。</p><p id="6a90" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">硬解析/库高速缓存缺失—在共享池中找不到我们的查询</p><p id="5b6e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">1)分配的共享SQL</p><p id="ff27" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">硬解析的第一步是为此在共享SQL区域中分配一些内存。因为</p><p id="61f4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">新的执行计划将写在这里。</p><p id="4d3f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这种分配可能需要一点时间，因为如果共享SQL区域已满，它将删除一个旧的区域</p><p id="1e42" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为新房子腾出一个房间，等等。</p><p id="e366" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">2)优化</p><p id="3923" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">那么接下来就是“优化”了。性能中最重要的是优化</p><p id="d736" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">调谐过程。我们将主要调整我们的查询以获得更好的优化。</p><p id="0fb2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">优化器只不过是一个软件，它将我们的查询作为输入，并返回最佳执行结果</p><p id="7aa1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">计划。我们知道一个查询可以用许多不同的方式执行。</p><p id="3885" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">优化器是用来在这么多方法中选择最佳执行计划的。</p><p id="85ff" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">通常，一个优化器需要计算几个执行计划，并在一秒钟内选择其中一个。</p><p id="40bc" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">但是，您可以更改优化级别并增加这个时间间隔。所以优化器可以计算</p><p id="f94d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">也许它能返回一个更好的执行计划。</p><p id="6e33" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">3)行来源生成过程:</p><p id="bacc" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">一旦创建了执行计划</p><p id="a386" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">然后，行来源生成过程开始。</p><p id="b16f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">它获取执行计划并生成执行步骤。</p><p id="5340" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">例如，首先，从客户的表中获取数据，然后对其进行排序，再从产品中获取数据</p><p id="e8c0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">桌子</p><p id="6560" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在得到它的同时，加入这些，排序等等。</p><p id="dc37" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">你会在接下来的讲座中看到细节。</p><p id="0ca2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">但基本上，它会找出如何从表中获取数据以及如何操作数据等。</p><p id="740a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">一旦生成了行源，使用这些步骤，语句被执行，结果</p><p id="d33e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">被返回给用户。</p><p id="aaf6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">因此，SQL查询的执行就是这样。</p><p id="e8c8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果您再次运行相同的查询，而不是再次解析它或在共享SQL区域中搜索</p><p id="8622" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">它直接转到该执行计划在库缓存中的确切位置。</p><p id="7432" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">一旦我们运行一个查询，它的执行计划就存储在库缓存中。</p><p id="c58b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">此外，该执行计划的rowid也存储在私有SQL区域中。</p><p id="f77d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">因此，一旦您运行相同的语句，它将直接使用它所拥有的rowid访问库缓存并找到</p><p id="ef7c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">迅速执行计划。</p><p id="1496" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">无需再次在库缓存中搜索该散列。</p><p id="4df6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">它并不保留我们执行的每个查询的所有地址。</p><p id="3ab5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">默认情况下，它只保留其中的50个。但这是可以改变的。解析是一项非常昂贵的操作。</p><p id="af7c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">很多时候，比执行力还贵。</p><p id="d0b7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">所以我们将特别避免查询的解析过程。甚至柔软</p></div></div>    
</body>
</html>