<html>
<head>
<title>Interfaces in Golang</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">戈兰语界面</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/interfaces-in-golang-f9df59b0b71e?source=collection_archive---------6-----------------------#2021-03-07">https://medium.com/nerd-for-tech/interfaces-in-golang-f9df59b0b71e?source=collection_archive---------6-----------------------#2021-03-07</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/fad7768bc4149c00189d5ce6f35e91cb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pFaeNO48gYlRMQii977cQg.jpeg"/></div></div></figure><p id="6bbc" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在我使用Golang的几年中，我遇到过几次涉及接口使用的讨论。参数范围从:</p><blockquote class="jo jp jq"><p id="3fc9" class="iq ir jr is b it iu iv iw ix iy iz ja js jc jd je jt jg jh ji ju jk jl jm jn hb bi translated">为什么我们不像C++、Java等典型的静态语言那样用类型定义来定义接口呢？</p><p id="efb7" class="iq ir jr is b it iu iv iw ix iy iz ja js jc jd je jt jg jh ji ju jk jl jm jn hb bi translated">此包是否应导出接口以及实现该接口的公开类型？</p><p id="3edd" class="iq ir jr is b it iu iv iw ix iy iz ja js jc jd je jt jg jh ji ju jk jl jm jn hb bi translated">这个函数应该返回一个接口而不是具体类型吗？</p></blockquote><p id="5980" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">让我们试着逐一解决这些问题。</p><h2 id="e1c3" class="jv jw hi bd jx jy jz ka kb kc kd ke kf jb kg kh ki jf kj kk kl jj km kn ko kp bi translated">为什么我们不像C++、Java等典型的静态语言那样用类型定义来定义接口呢？</h2><p id="91f3" class="pw-post-body-paragraph iq ir hi is b it kq iv iw ix kr iz ja jb ks jd je jf kt jh ji jj ku jl jm jn hb bi translated">在C++、Java等语言中，需要指定一个类型实现一个接口，如下面给出的代码所示:</p><figure class="kv kw kx ky fd ij"><div class="bz dy l di"><div class="kz la l"/></div></figure><p id="30b0" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在这样的语言中，为对象定义接口使得编译器能够为指向函数的对象形成调度表。</p><p id="33a7" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">Go没有传统的调度表，在方法调度期间可以依赖接口值。它实际上更像是一种自由式调度机制，需要在接口值赋值期间做一些工作——它为所指向的具体类型生成一个小型查找哈希表。如果你想进一步阅读，这里有一篇很棒的博文。</p><p id="2d22" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">尽管有点贵，但这使得go有一个更干净的类型系统，没有为每种类型定义接口的负担。</p><p id="8422" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">对于开发者来说，这意味着<strong class="is hj">实现的对象<em class="jr">不需要<em class="jr">显式地</em>说它实现了它，</em></strong>如下面的代码所示:</p><figure class="kv kw kx ky fd ij"><div class="bz dy l di"><div class="kz la l"/></div></figure><p id="048e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">因此，任何结构都可以简单地通过实现其方法签名来满足接口。它有几个优点，如:</p><ul class=""><li id="6dad" class="lc ld hi is b it iu ix iy jb le jf lf jj lg jn lh li lj lk bi translated">使得在单元测试中使用模拟对象代替真实对象更加容易。</li><li id="c970" class="lc ld hi is b it ll ix lm jb ln jf lo jj lp jn lh li lj lk bi translated">有助于增强代码库各部分之间的分离。</li></ul><h2 id="fa58" class="jv jw hi bd jx jy jz ka kb kc kd ke kf jb kg kh ki jf kj kk kl jj km kn ko kp bi translated">此包是否应导出接口以及实现该接口的公开类型？</h2><p id="ded9" class="pw-post-body-paragraph iq ir hi is b it kq iv iw ix kr iz ja jb ks jd je jf kt jh ji jj ku jl jm jn hb bi translated">简短的回答是:</p><blockquote class="jo jp jq"><p id="c9fe" class="iq ir jr is b it iu iv iw ix iy iz ja js jc jd je jt jg jh ji ju jk jl jm jn hb bi translated">除非必要，否则不要导出任何接口。</p></blockquote><p id="3853" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如果您的包的消费者需要某种程度的“控制反转”，他们可以在自己的范围内定义接口。</p><p id="fbf0" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">然而，在某些情况下，人们可能希望标准化某项功能的使用方式。以golang错误界面为例。</p><pre class="kv kw kx ky fd lq lr ls lt aw lu bi"><span id="f8e4" class="jv jw hi lr b fi lv lw l lx ly">type error interface {</span><span id="4117" class="jv jw hi lr b fi lz lw l lx ly">     Error() string</span><span id="12c6" class="jv jw hi lr b fi lz lw l lx ly">}</span></pre><p id="0dd9" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">它是标准库中的内置接口，用于标准化错误行为。社区中还有其他关于标准化某些行为的讨论，例如拥有一个通用的<a class="ae lb" href="https://groups.google.com/g/golang-dev/c/F3l9Iz1JX4g/discussion" rel="noopener ugc nofollow" target="_blank">登录</a>界面。类似地，在公司范围内表示一些常见行为以提供一致性和代码可重用性可能是有用的。然而，在这种情况下，要确保接口很小，也就是1-2个方法。</p><h2 id="b2e2" class="jv jw hi bd jx jy jz ka kb kc kd ke kf jb kg kh ki jf kj kk kl jj km kn ko kp bi translated">这个包应该返回一个接口而不是具体类型吗？</h2><p id="1db9" class="pw-post-body-paragraph iq ir hi is b it kq iv iw ix kr iz ja jb ks jd je jf kt jh ji jj ku jl jm jn hb bi translated">根据CodeReviewComments，<a class="ae lb" href="https://github.com/golang/go/wiki/CodeReviewComments#interfaces" rel="noopener ugc nofollow" target="_blank"> Go接口通常属于使用接口类型值的包，而不是实现那些值的包。</a></p><p id="ab9c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">然而<a class="ae lb" href="https://golang.org/doc/effective_go#generality" rel="noopener ugc nofollow" target="_blank">有效go </a> docs也补充说</p><blockquote class="jo jp jq"><p id="74d4" class="iq ir jr is b it iu iv iw ix iy iz ja js jc jd je jt jg jh ji ju jk jl jm jn hb bi translated">如果某个类型的存在只是为了实现某个接口，并且永远不会在该接口之外导出方法，则没有必要导出该类型本身。</p></blockquote><p id="ea9f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">但问题是你如何识别这样的场景？你怎么知道该类型在将来没有附加值？以我的经验，答案是“等”。不要一开始就返回接口，而是等到你的代码发展到需要它们的时候。正如罗布·派克所说:</p><blockquote class="ma"><p id="b053" class="mb mc hi bd md me mf mg mh mi mj jn dx translated">“不要用界面来设计，要发现它们。”</p></blockquote><p id="0a13" class="pw-post-body-paragraph iq ir hi is b it mk iv iw ix ml iz ja jb mm jd je jf mn jh ji jj mo jl jm jn hb bi translated">当您的包中有多个类型实现相同的方法签名时，公开接口的一个很好的提示是<strong class="is hj">。如果你看看标准库中的<code class="du mp mq mr lr b">http</code>包，你会发现它内部有多个<code class="du mp mq mr lr b">http.Handler</code>接口的实现。</strong></p><p id="8d6d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在混乱的情况下，寻找一些<strong class="is hj">危险信号是有帮助的，这些信号可以表明你可能使用了错误的接口</strong>。有些是:</p><h2 id="a312" class="jv jw hi bd jx jy jz ka kb kc kd ke kf jb kg kh ki jf kj kk kl jj km kn ko kp bi translated">你的接口没有将API从变化中分离出来。</h2><p id="43ba" class="pw-post-body-paragraph iq ir hi is b it kq iv iw ix kr iz ja jb ks jd je jf kt jh ji jj ku jl jm jn hb bi translated">想象一个用于发送电子邮件的第三方api客户端包的实现，例如<a class="ae lb" href="https://sendgrid.com/" rel="noopener ugc nofollow" target="_blank"> SendGrid </a></p><figure class="kv kw kx ky fd ij"><div class="bz dy l di"><div class="kz la l"/></div></figure><p id="0b34" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在想象一下，<code class="du mp mq mr lr b">SendGrid</code>会有新的实现吗？<br/>如果SendGrid被比如说<code class="du mp mq mr lr b">Mailjet</code>所取代，很可能会有一个不同的电子邮件发送服务的新实现。因此，您可以重写代码来返回具体的类型。</p><p id="bd74" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">再想象一下，你想给这个被很多人使用的接口添加一个新方法，你如何在不破坏代码的情况下给它添加一个新方法呢？</p><figure class="kv kw kx ky fd ij"><div class="bz dy l di"><div class="kz la l"/></div></figure><p id="0ad6" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">通过公开结构类型本身，您可以向结构本身添加新方法，而无需密集的重构</p><h2 id="8e9f" class="jv jw hi bd jx jy jz ka kb kc kd ke kf jb kg kh ki jf kj kk kl jj km kn ko kp bi translated">你的接口有不止一两个方法。</h2><p id="842e" class="pw-post-body-paragraph iq ir hi is b it kq iv iw ix kr iz ja jb ks jd je jf kt jh ji jj ku jl jm jn hb bi translated">你的界面有太多的方法会降低它的可用性。以<code class="du mp mq mr lr b">fmt.Stringer</code>接口为例，它只有一个方法签名，即</p><pre class="kv kw kx ky fd lq lr ls lt aw lu bi"><span id="bc07" class="jv jw hi lr b fi lv lw l lx ly">type Stringer interface {</span><span id="262c" class="jv jw hi lr b fi lz lw l lx ly">     String() string</span><span id="fae7" class="jv jw hi lr b fi lz lw l lx ly">}</span></pre><p id="17fd" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">并且在标准库中的30个地方使用，不包括测试。您可以在标准库中找到类似的其他示例，如<code class="du mp mq mr lr b">http.Handler</code>、<code class="du mp mq mr lr b">io.Reader</code>等。</p><p id="3d1e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在想象一个有5-6个方法的接口，它实际上只能在1-2个地方使用，因为不是所有的类型都能实现大量的方法。</p><blockquote class="ma"><p id="f0b6" class="mb mc hi bd md me mf mg mh mi mj jn dx translated">接口越大，抽象性越弱。</p></blockquote><h2 id="3618" class="jv jw hi bd jx jy ms ka kb kc mt ke kf jb mu kh ki jf mv kk kl jj mw kn ko kp bi translated">结论:</h2><p id="9017" class="pw-post-body-paragraph iq ir hi is b it kq iv iw ix kr iz ja jb ks jd je jf kt jh ji jj ku jl jm jn hb bi translated">Golang中的接口可能很难掌握，一般建议遵循经验法则。在一般规则有例外的情况下，等着看你的代码如何发展，并做出相应的调整。</p></div></div>    
</body>
</html>