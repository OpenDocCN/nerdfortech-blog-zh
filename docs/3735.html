<html>
<head>
<title>Bonus: You Shall Not Pass!! — Player Boundaries</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">奖励:你不能通过！！—玩家边界</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/bonus-you-shall-not-pass-player-boundaries-8e0a6e59aa8a?source=collection_archive---------17-----------------------#2021-06-21">https://medium.com/nerd-for-tech/bonus-you-shall-not-pass-player-boundaries-8e0a6e59aa8a?source=collection_archive---------17-----------------------#2021-06-21</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="023a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">目标</strong>:防止玩家把手伸到屏幕外</p><p id="8251" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这是更高级的<strong class="ih hj"/>，因为我计划在未来的教程中更好地探索一些主题，所以把这作为<strong class="ih hj">的奖励</strong>，也许以后会回来这里更好地理解。</p><p id="bf5a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">问题很简单:现在玩家可以迈出第一步了(太可爱了！)它可以<strong class="ih hj">突破屏幕侧</strong> …如果我们不阻止它！</p><p id="a07d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">有两种方法，一种<strong class="ih hj">更简单，但更混乱</strong>涉及一个简单的球员位置检查，与一些经验值相比，我们可以从检查员那里得到，并认为是屏幕边界。另一个，我更喜欢，更"<strong class="ih hj">程序化</strong>"，我们将得到实时的屏幕边界，它甚至可能在游戏过程中改变，因为与游戏摄像机配置有关。当然是<strong class="ih hj">更复杂</strong>，但也不是不可能。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es jd"><img src="../Images/3489b2b5658b0ca50f1261e517fb7f24.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kZr1r3-bnCoUumqNDdlZIg.png"/></div></div></figure><p id="96eb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">好吧，我把它写成伪代码:我们必须让播放器停在屏幕边界；但是要做到这一点，我们必须得到这些界限；但要做到这一点，我们必须定义它们，例如使用相机所看到的大小。</p><p id="5bc3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">首先，让我们创建一个新的C#脚本，并将其命名为<strong class="ih hj">Cameron borders。</strong></p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es jp"><img src="../Images/64e093429bdfdf3001e6b4941142d060.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_nlyg_siS9QvO7DgPyY_Mw.png"/></div></div></figure><p id="3419" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们以通常的方式定义一些<strong class="ih hj">变量</strong>:如果需要频繁调用，减少构造函数调用。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es jq"><img src="../Images/21f6385510163edf24956a743fe6a6c7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mwb0Lunp2xt2s1THc5C3DQ.png"/></div></div></figure><p id="9fc1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">好的，我们需要更深入地研究:<strong class="ih hj"> _cameraVisual </strong>将存储摄像机看到的屏幕的x和y尺寸，初始化为一些随机的邪恶值。<strong class="ih hj"> _camera </strong>是camera组件上的一个句柄，然后我定义了一个_cameraVisual作为<strong class="ih hj">属性</strong>来获得对它的<strong class="ih hj"> public </strong>访问。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es jr"><img src="../Images/cb4df46b9a552dbd2859853027602e73.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uO5oMmuGCLOJ24W_I9Oa2w.png"/></div></div></figure><p id="c6f1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这里我们将相机组件分配给_camera，我们需要它来获取一些值。这不是开始，所以在开始时只做一次。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es js"><img src="../Images/e19d51df3c0c0db617463e68f139ff40.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7qVyY4BCjys-YhGoVGQxJA.png"/></div></div></figure><p id="821b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">一个不错的部分:一个私有方法UpdateCameraVisual <strong class="ih hj"> () </strong>，这里我们调用<strong class="ih hj"> Screen </strong>类属性，width和height，以便计算<strong class="ih hj">纵横比</strong>。也许有更简单的方法…但是我从来没有想到过！</p><p id="9774" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在真正的东西是:视觉的y分量是由相机的<strong class="ih hj"> orthographicSize </strong>属性获得的，只代表垂直尺寸的一半，但这正是我们所需要的。水平分量由y乘以纵横比得出。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es jt"><img src="../Images/6a60f8733c02a85a500bf0ffacd94bc8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1264/format:webp/1*CE5FBkjtfxonphkqpcE3vg.png"/></div></figure><p id="b77d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们通过调用<strong class="ih hj"> Update() </strong>中的方法来结束这个类。</p><p id="e640" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">回到player类，让我们添加两个新的变量:一个Cameron borders脚本的句柄(<strong class="ih hj">_ Cameron borders</strong>)和一个存储player <strong class="ih hj">位置的vector3】(耶，3甚至在2D)。</strong></p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es ju"><img src="../Images/0f8f16f22a92fb51d0dc9da124041cd0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Q9qxDf3LVdqsyOePw889YQ.png"/></div></div></figure><p id="8732" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在Start()中，我们可以通过检查我们正在寻找的相机对象是否存在(非空)来安全地将camera borders链接到组件。为了搜索相机对象，我使用了方法<strong class="ih hj"> GameObject。FindGameObjectWithTag(" main camera ")</strong>，这一点相当不言自明。在检查员视图中显示了<strong class="ih hj">标签</strong>。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es jv"><img src="../Images/381b4c71c0cc414bd682269aa1d300f5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tUowS61-qGBKGOUplawhWw.png"/></div></div></figure><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es jw"><img src="../Images/47304ab27146511ece79bcb588723d9a.png" data-original-src="https://miro.medium.com/v2/resize:fit:910/format:webp/1*kNSpO5RxZsAhkPgA8VsCww.png"/></div></figure><p id="a8c5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">调试。LogError() </strong>将在控制台中显示指定的字符串，标记为Error。</p><p id="6bc4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在问题的核心。让我们写一个新的私有方法<strong class="ih hj"> CheckBounds() </strong>，这里我们将把我们的逻辑。基本上，我们将使用一个强大的方法:<strong class="ih hj"> Mathf来设置位置的vector3值。</strong>钳()。该方法要求检查一个浮点值，一个浮点值代表最小值，另一个代表最大值。如果在最小值和最大值之间，或者在最小值(如果更小)或最大值(如果更大)之间，它返回一个等于最初传递的浮点值。太棒了！</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es jx"><img src="../Images/0efa8e797ff058963250623a49f15684.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2TPU_Mqvfa9YXM4-bT7ckQ.png"/></div></div></figure><p id="214b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在我们在Update()中调用这个方法，就可以开始了。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es jy"><img src="../Images/296ffc6441b8b92e4bef774b6d1a3e20.png" data-original-src="https://miro.medium.com/v2/resize:fit:1028/format:webp/1*472NBkShku2qbZrXlGAoPw.png"/></div></figure><p id="df52" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">结果如下:</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es jz"><img src="../Images/aeb49d5922acf923c9f5c5464a92e5fc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*KlXf3seEmhSZrt1CD1-57A.gif"/></div></div></figure><p id="7b6e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在关闭之前还有一件事:我选择这个方法是因为这样的话，如果我修改相机，边界会随之更新。也就是说，这是通过从检查器中更改相机组件中的<strong class="ih hj">大小</strong>值来完成的。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es ka"><img src="../Images/017c1beeb8dc028354db8925e94d3b38.png" data-original-src="https://miro.medium.com/v2/resize:fit:934/format:webp/1*bbP1we_60J9yPO51E5oX7w.png"/></div></figure></div></div>    
</body>
</html>