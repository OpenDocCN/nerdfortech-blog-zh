# Swift 托收简介

> 原文：<https://medium.com/nerd-for-tech/introduction-to-swift-collections-81a8a8b526d0?source=collection_archive---------8----------------------->

![](img/aa85d372084eac05f1833fee59a357a2.png)

集合类型是对相关项目进行分组的一种方式。Swift 目前为存储价值集合提供三种基本但重要的数据结构:

**数组**——有序的值集合。
**设置** -唯一值的无序集合。
**字典** -键值关联的无序集合。

它们满足了我们的大部分用例，但是您是否遇到过我们可能需要更多功能的需求。当我们想要混合和匹配这些数据结构时，就像我们想要一个有序的集合一样，我们总是很难。
我们所有人都必须创建自定义函数来满足我们的需求。

![](img/fe8996f1c31de695c721b8d50c464c67.png)

不再有自定义实现。我们现在可以用更少的努力写出更快的代码。

一个新的开源包专注于扩展可用的数据结构集，从而帮助我们在 Swift 标准库提供的功能之外开发更多功能。
在收集包的初始版本中，提供了三种最常被请求的数据结构。

## 双端队列

Deque(读作“deck”)或双端队列在某种意义上像数组一样工作，它是*有序的、可变的，并且可以被随机访问*。关键区别在于 *Deque* 支持两端插入和删除。

*队列*的一些关键特征是:

*   有`popFirst`和`prepend`等操作可以插入和移除前面的元件。`popFirst`返回移除的元素，如果是空数组则返回 nil。
*   前置一个元素对于*队列*是一个常数时间操作，但是对于*数组*是一个线性时间操作。
*   就像数组一样，非空*dequee*的第一个元素的索引始终为零。
*   写入时拷贝优化也适用于*队列*，即每个拷贝共享相同的底层存储，除非其中一个拷贝被修改。
*   在*数组*的前面插入新数据相对较慢，因为需要移动现有元素来腾出空间。相比之下， *Deque* 使用一个循环缓冲区来存储它的元素，这允许在集合的两端进行有效的插入和移除。
*   我们还可以使用一些 *MutableCollection* 和*RangeReplaceableCollection*方法来访问和变更集合的元素。

为了更好地理解，让我们看一个例子:

就像数组一样，访问任意偏移量的元素对于 Deque 来说是一个常量时间操作。

尽管一个*队列*的接口与一个*数组*的接口非常相似，但是操作具有不同的性能特征。在 *Deques* 中，靠近前端的突变预计会明显更快，但是*数组*对于一般的随机访问查找来说可能会稍微快一些。所以建议不要盲目的用 *Deques* 替换所有数组，除非需要。

## 有序集合

数组和集合的强大混合体。唯一的要求是元素类型应该符合*散列*协议。

> 追加元素(包括确保它的惟一性)是 OrderedSet 的一个常量时间操作。

*订购套件*的一些主要特点是:

*   它确保有序列表中的每个元素只出现一次。
*   OrderedSet 以用户指定的顺序维护其元素，并支持高效的成员随机访问遍历。
*   使用`elements`属性可以将*有序集合*的成员提取为*数组*。这是以最小的开销完成的，因为它使用标准数组值来存储元素。
*   *有序集合*提供了一个有效的*无序视图*，它的元素符合`SetAlgebra`。
*   *OrderedSet* 通过维护一个成员数组和该数组中的一个索引哈希表来实现。与普通的旧集合相比，有序集合通常会使用更少的内存，因为存储在哈希表中的索引通常可以比标准 Int 编码更少的位。
*   如果两个有序集以相同的顺序包含相同的元素，则认为它们相等。

*   *有序集*实现了大部分`SetAlgebra`需求，但不是全部。具体来说，它支持成员测试`contains(_:)`以及所有高级集合操作，如`union(_:)`、`intersection(_:)`或`isSubset(of:)`。返回有序集的操作通常会保留元素在其输入中的顺序。
*   像`isSubset(of:)`这样的谓词倾向于忽略元素排序。

![](img/de4cc6ad7b33c261e1b5b1c8cc9a51e0.png)

让我们看看下面的例子，以便更好地理解:

## **有序字典**

它是键值对的有序集合。

*有序字典*的一些关键特性是:

*   它使用哈希表来维护唯一性，并高效地查找这些特定键的对应值。
*   像*数组*一样，OrderedDictionary 维护用户指定的元素顺序，并支持对其条目的高效随机访问遍历。
*   *OrderedDictionary* 的几乎所有操作都与普通的*字典*相同，比如我们可以使用基于键的下标高效地查找和添加值。
*   它使用整数作为索引。就像数组一样，第一个元素的索引始终为零。
*   任何使用下标 setter 的新条目都会将该元素附加到字典的末尾。所以默认情况下，元素的顺序就是它们被插入的顺序。
*   就像数组相等一样，如果两个 OrderedDictionaries 以相同的顺序包含相同的元素，则它们被视为相等。 *OrderedDictionary* 只有当其值可等价时才符合可等价。

*   当元素的顺序很重要时，或者当您需要访问集合中不同位置的元素时，OrderedDictionary 是对*字典*的有用替代。

如上例所示，为了避免基于键的下标和基于索引的下标之间的歧义， *OrderedDictionary* 不直接符合集合。相反，它提供了对键值对的随机访问视图。就像标准字典一样，这个字典也提供轻量级的键和值视图。

随着这些新数据结构的发布，包含新数据结构的门槛甚至更高了。然而，我们仍然希望在未来向该集合包添加更多条目，从而显著提高真实世界 Swift 代码的性能和正确性。

![](img/b1ad7f71836a7db1ea89eb30343552a3.png)

# 参考

 [## 推出 Swift 系列

### 我很高兴地宣布 Swift Collections，这是一个新的开源包，致力于扩展可用的 Swift…

swift.org](https://swift.org/blog/swift-collections/)  [## 苹果/swift-系列

### Swift Collections 是一个针对 Swift 编程语言的数据结构实现的开源包。阅读…

github.com](https://github.com/apple/swift-collections)