<html>
<head>
<title>[Learn Intermediate Go] How does context work?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">【学习中级围棋】语境是如何起作用的？</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/learn-intermediate-go-how-does-context-work-1898704c649b?source=collection_archive---------1-----------------------#2021-07-13">https://medium.com/nerd-for-tech/learn-intermediate-go-how-does-context-work-1898704c649b?source=collection_archive---------1-----------------------#2021-07-13</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="12ba" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">首先，什么是语境？</p><p id="5d55" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在这个上下文(͡❛ ͜ʖ ͡❛)中，上下文是一个控制围棋最终期限的结构。它由上下文包提供。</p><p id="eb61" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">你可能会问，什么截止日期？它可以用于任何事情，但是它最初的意图是用于单个服务器请求中操作的截止时间。如果你不确定那是什么意思，不要担心！这将在下面的章节中解释。</p><h1 id="91ec" class="jd je hi bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">柔和的介绍</h1><p id="3f55" class="pw-post-body-paragraph if ig hi ih b ii kb ik il im kc io ip iq kd is it iu ke iw ix iy kf ja jb jc hb bi translated">上下文有三个主要元素:</p><ul class=""><li id="f3b6" class="kg kh hi ih b ii ij im in iq ki iu kj iy kk jc kl km kn ko bi translated">取消</li><li id="7674" class="kg kh hi ih b ii kp im kq iq kr iu ks iy kt jc kl km kn ko bi translated">截止日期/超时</li><li id="58d9" class="kg kh hi ih b ii kp im kq iq kr iu ks iy kt jc kl km kn ko bi translated">键值对</li></ul><p id="38f1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">取消是允许您手动取消上下文的功能。</p><p id="6e2e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">截止日期和超时可以被认为是“有计划的”取消。虽然不是你打电话取消，但它是由机器控制的，基于你给的时间值。</p><p id="510d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">上下文也可以携带自己的键值对。通常，它包含与单个请求相关的信息。我不会在这里讨论它们，因为这很简单，而且与上下文没有什么特别的关系。</p><p id="50f6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在上下文包中，您会注意到有6种方法来构造上下文。您可以结合使用以上六种功能，将以上三种功能附加到上下文中:</p><ul class=""><li id="8305" class="kg kh hi ih b ii ij im in iq ki iu kj iy kk jc kl km kn ko bi translated"><code class="du ku kv kw kx b">WithCancel</code>:取消</li><li id="f057" class="kg kh hi ih b ii kp im kq iq kr iu ks iy kt jc kl km kn ko bi translated"><code class="du ku kv kw kx b">WithDeadline</code>和<code class="du ku kv kw kx b">WithTimeout</code>:截止/超时<em class="ky">和</em>取消</li><li id="9be6" class="kg kh hi ih b ii kp im kq iq kr iu ks iy kt jc kl km kn ko bi translated"><code class="du ku kv kw kx b">WithValue</code>:键值对</li><li id="40dd" class="kg kh hi ih b ii kp im kq iq kr iu ks iy kt jc kl km kn ko bi translated"><code class="du ku kv kw kx b">Background</code>和<code class="du ku kv kw kx b">TODO</code>:无</li></ul><figure class="la lb lc ld fd le er es paragraph-image"><div role="button" tabindex="0" class="lf lg di lh bf li"><div class="er es kz"><img src="../Images/619d67e21f2913f4984bb4cd770b30de.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*eEDytqMj6RB2Y4qUuGY_QA.jpeg"/></div></div></figure><p id="7a44" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">你可能对<code class="du ku kv kw kx b">Background</code>和<code class="du ku kv kw kx b">TODO</code>很好奇。如果它们没有任何用途，为什么它们会存在？</p><p id="4752" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><code class="du ku kv kw kx b">Background</code>通常用作其他类型上下文的“根”,因为其他类型的上下文必须有一个“父”上下文。当你不想要一个截止日期，但是你仍然需要传递一个上下文变量(例如，一个函数期望一个上下文作为它的参数)时，也可以使用它。</p><p id="f917" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">(如果你理解了它为什么这样命名就更容易了。假设您正在主线程上传递一个没有取消的上下文。该操作可能会无限期运行，冻结主线程——这不是您想要的。一个<code class="du ku kv kw kx b">background</code>是用来传递给“后台”进程的，它不需要阻塞其他进程。)</p><p id="34dd" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><code class="du ku kv kw kx b">Background</code>和<code class="du ku kv kw kx b">TODO</code>内部等价。</p><h1 id="3fcd" class="jd je hi bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">截止日期/超时是如何工作的？</h1><p id="d12c" class="pw-post-body-paragraph if ig hi ih b ii kb ik il im kc io ip iq kd is it iu ke iw ix iy kf ja jb jc hb bi translated">期限机制非常简单。上下文对象持有截止日期，当截止日期过后，<code class="du ku kv kw kx b">cancel</code>就是上下文(我知道我们还没有介绍过<code class="du ku kv kw kx b">cancel</code>是如何工作的。下一节会解释！).如果你好奇的话，它会用时间来看时间。AfterFunc函数。</p><p id="7f42" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果父上下文的截止时间先于子上下文，子上下文也会被取消。</p><p id="167a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">反之不成立-取消子上下文不会取消父上下文。</p><p id="e71d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">超时与截止日期完全相同，只是截止日期被设置为相对于当前的时间(构建上下文的时间)。</p><h1 id="c2f5" class="jd je hi bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">取消是如何工作的？</h1><p id="a1de" class="pw-post-body-paragraph if ig hi ih b ii kb ik il im kc io ip iq kd is it iu ke iw ix iy kf ja jb jc hb bi translated">好了，有趣的部分来了！</p><p id="d4d7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们来看一下<code class="du ku kv kw kx b">Context</code>接口的签名:</p><pre class="la lb lc ld fd ll kx lm ln aw lo bi"><span id="d195" class="lp je hi kx b fi lq lr l ls lt">type Context interface {<br/>    Done() &lt;-chan struct{}<br/>    Err() error<br/>    Deadline() (deadline time.Time, ok bool)<br/>    Value(key interface{}) interface{}<br/>}</span></pre><p id="b3ab" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在，请特别注意<code class="du ku kv kw kx b">Done</code>功能。它返回一个空结构的通道。</p><p id="d15e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果你熟悉其他语言，你可以把它想象成一个<code class="du ku kv kw kx b">Future</code>对象。也就是说，它现在可能没有任何值，但将来某个时候会有一个值。</p><p id="ea9f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这个“未来”在上下文被取消时解决(准确地说，通道被关闭)——通过显式取消或截止时间/超时。<code class="du ku kv kw kx b">Err()</code>函数现在也将返回一个非零错误。</p><p id="4f54" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">就是这样。这就是当它被取消时上下文所做的一切。</p><p id="7e9b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">当上下文被取消</strong>时，上下文不会神奇地取消操作本身。</p><p id="c6a4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果您是获取上下文的函数的最终被调用方<strong class="ih hj">,您应该处理上下文的取消。</strong></p><p id="4dd6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">很多时候，你只是一个函数的<strong class="ih hj">调用者</strong>，来自第三方库，获取上下文。您可以简单地将上下文传递给它:</p><figure class="la lb lc ld fd le"><div class="bz dy l di"><div class="lu lv l"/></div></figure><p id="be89" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">或者用您选择在<em class="ky">您的</em>层中应用的超时/截止时间来包装它:</p><figure class="la lb lc ld fd le"><div class="bz dy l di"><div class="lu lv l"/></div></figure><p id="a676" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">并且库将(希望)在它们的末端处理上下文。</p><p id="b456" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">以下是超时时间为2秒的上下文如何随时间变化的直观表示:</p><figure class="la lb lc ld fd le er es paragraph-image"><div class="er es lw"><img src="../Images/8b99b432b5046544ac23ccc445565404.png" data-original-src="https://miro.medium.com/v2/resize:fit:1180/format:webp/1*b-I2l44F9cX1Fxv8vJaFuA.png"/></div></figure><figure class="la lb lc ld fd le er es paragraph-image"><div class="er es lw"><img src="../Images/d20d10e7776cda685044943734085582.png" data-original-src="https://miro.medium.com/v2/resize:fit:1180/format:webp/1*DY36ol2EaVj97fuMrkWVjQ.png"/></div></figure><figure class="la lb lc ld fd le er es paragraph-image"><div class="er es lw"><img src="../Images/e481fd27eef7aed1c306d500f91f0079.png" data-original-src="https://miro.medium.com/v2/resize:fit:1180/format:webp/1*z7ijhosYbWcm4WEawvlHhQ.png"/></div></figure><h1 id="4a8c" class="jd je hi bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">例子</h1><p id="e55b" class="pw-post-body-paragraph if ig hi ih b ii kb ik il im kc io ip iq kd is it iu ke iw ix iy kf ja jb jc hb bi translated">下面是示例代码(完整代码可以在<a class="ae lx" href="https://github.com/sanggonlee/learn_intermediate_go/02_context/main.go" rel="noopener ugc nofollow" target="_blank">https://github . com/sanggonlee/learn _ intermediate _ go/02 _ context/main . go</a>中看到)。它演示了当其他操作同时运行时，当其中一个操作返回错误时，如何取消其他操作。</p><p id="4c71" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><code class="du ku kv kw kx b">asyncutil.Collect</code>函数所做的就是:获取三个<code class="du ku kv kw kx b">returnErrAfterNSeconds</code>函数，同时运行它们，并从它们那里收集任何错误。</p><figure class="la lb lc ld fd le"><div class="bz dy l di"><div class="lu lv l"/></div></figure><p id="a0da" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">看到<code class="du ku kv kw kx b">returnErrAfterNSeconds</code>的3个调用了吗？</p><ul class=""><li id="324f" class="kg kh hi ih b ii ij im in iq ki iu kj iy kk jc kl km kn ko bi translated">第一个调用将在1秒钟后向通道发送一个<code class="du ku kv kw kx b">nil</code>错误。</li><li id="ecdb" class="kg kh hi ih b ii kp im kq iq kr iu ks iy kt jc kl km kn ko bi translated">第二次调用将在2秒后发送非<code class="du ku kv kw kx b">nil</code>错误。</li><li id="5790" class="kg kh hi ih b ii kp im kq iq kr iu ks iy kt jc kl km kn ko bi translated">第三个调用将在3秒后发送一个<code class="du ku kv kw kx b">nil</code>错误。</li></ul><p id="80a3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">因此，在不考虑上下文的情况下，我们期望输出是:</p><pre class="la lb lc ld fd ll kx lm ln aw lo bi"><span id="3fb0" class="lp je hi kx b fi lq lr l ls lt">Error: err</span></pre><p id="1b83" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">因为只有第二个调用解决了一个错误。</p><p id="b1af" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">实际控制台输出:</p><pre class="la lb lc ld fd ll kx lm ln aw lo bi"><span id="efe9" class="lp je hi kx b fi lq lr l ls lt">Error: err<br/>Error: context canceled</span></pre><p id="016a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">最初，只有第二次调用<code class="du ku kv kw kx b">returnErrAfterNSeconds</code>函数会返回一个错误。但是第三个调用也失败了，因为第二个调用一结束，它就取消了上下文并传播到第三个调用。</p><p id="a34d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">注意，在<code class="du ku kv kw kx b">returnErrAfterNSeconds</code>函数中，上下文取消被显式地处理为一个错误:</p><pre class="la lb lc ld fd ll kx lm ln aw lo bi"><span id="603a" class="lp je hi kx b fi lq lr l ls lt">case &lt;-ctx.Done():<br/>	errs &lt;- ctx.Err()</span></pre><p id="f99d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">正在进行的图表:</p><figure class="la lb lc ld fd le er es paragraph-image"><div role="button" tabindex="0" class="lf lg di lh bf li"><div class="er es ly"><img src="../Images/80ae51b9efc55966129756b9cc687554.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Hw6-ypE7VHVk9gqYx3_8Jw.png"/></div></div></figure><h1 id="ea0d" class="jd je hi bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">更多示例</h1><p id="760d" class="pw-post-body-paragraph if ig hi ih b ii kb ik il im kc io ip iq kd is it iu ke iw ix iy kf ja jb jc hb bi translated">我再抛几个例子帮助你理解。如果你已经理解了上下文是如何工作的，你可以跳过这一节！</p><p id="b919" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">你可以在<a class="ae lx" href="https://github.com/sanggonlee/learn_intermediate_go/tree/master/02_context/examples" rel="noopener ugc nofollow" target="_blank">https://github . com/sanggonlee/learn _ intermediate _ go/tree/master/02 _ context/examples</a>中找到完整的代码。</p><h2 id="3c86" class="lp je hi bd jf lz ma mb jj mc md me jn iq mf mg jr iu mh mi jv iy mj mk jz ml bi translated"><strong class="ak">仅取消</strong></h2><p id="8621" class="pw-post-body-paragraph if ig hi ih b ii kb ik il im kc io ip iq kd is it iu ke iw ix iy kf ja jb jc hb bi translated">对于下面的代码，控制台将打印什么？</p><figure class="la lb lc ld fd le"><div class="bz dy l di"><div class="lu lv l"/></div></figure><p id="2768" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">输出:</p><pre class="la lb lc ld fd ll kx lm ln aw lo bi"><span id="07fa" class="lp je hi kx b fi lq lr l ls lt">After 1 second: &lt;nil&gt;<br/>After 3 seconds: &lt;nil&gt;<br/>Context done!<br/>After 5 seconds: context canceled</span></pre><p id="ce43" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这里，上下文没有任何超时或截止时间。相反，我们在等待4秒后手动取消它。我们在1秒、3秒和5秒后检查<code class="du ku kv kw kx b">ctx.Err()</code>，看看在哪个阶段上下文被取消了。由于上下文在4秒时被取消，5秒后的上下文现在包含错误。</p><h2 id="6f99" class="lp je hi bd jf lz ma mb jj mc md me jn iq mf mg jr iu mh mi jv iy mj mk jz ml bi translated"><strong class="ak">超时</strong></h2><p id="71a4" class="pw-post-body-paragraph if ig hi ih b ii kb ik il im kc io ip iq kd is it iu ke iw ix iy kf ja jb jc hb bi translated">对于下面的代码，控制台将打印什么？</p><figure class="la lb lc ld fd le"><div class="bz dy l di"><div class="lu lv l"/></div></figure><p id="0fe2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">输出:</p><pre class="la lb lc ld fd ll kx lm ln aw lo bi"><span id="0a26" class="lp je hi kx b fi lq lr l ls lt">After 1 second: &lt;nil&gt;<br/>After 3 seconds: &lt;nil&gt;<br/>Context done!<br/>After 5 seconds: context deadline exceeded</span></pre><p id="3398" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这次我们使用<code class="du ku kv kw kx b">WithTimeout</code>将上下文的超时设置为4秒，并且永远不要手动取消它。效果与上一个示例相同，但是请注意，我们得到了一个不同的错误:“超过了上下文截止时间”</p><h2 id="9446" class="lp je hi bd jf lz ma mb jj mc md me jn iq mf mg jr iu mh mi jv iy mj mk jz ml bi translated"><strong class="ak">超时前取消</strong></h2><p id="26e0" class="pw-post-body-paragraph if ig hi ih b ii kb ik il im kc io ip iq kd is it iu ke iw ix iy kf ja jb jc hb bi translated">对于下面的代码，控制台将打印什么？</p><figure class="la lb lc ld fd le"><div class="bz dy l di"><div class="lu lv l"/></div></figure><p id="20b3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">输出:</p><pre class="la lb lc ld fd ll kx lm ln aw lo bi"><span id="eb63" class="lp je hi kx b fi lq lr l ls lt">After 1 second: &lt;nil&gt;<br/>Context done!<br/>After 3 seconds: context canceled<br/>After 5 seconds: context canceled</span></pre><p id="b0d7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这次我们同时使用超时和手动取消。尽管超时设置为4秒，但手动取消会在2秒后发生。因此，上下文在3秒后出现“上下文已取消”错误，而不是“超过截止时间”错误。</p><p id="2573" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">请注意，4秒钟后(即截止日期后)，错误仍然显示为“上下文已取消”。所以我们知道语境一旦被取消就不会改变。</p><h1 id="d184" class="jd je hi bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">其他重要注意事项</h1><ul class=""><li id="d13d" class="kg kh hi ih b ii kb im kc iq mm iu mn iy mo jc kl km kn ko bi translated">上下文是线程安全的(更确切地说，是goroutine安全的)。这使得上下文对于控制并发设置中的取消非常有用，如第一个示例代码所示。</li><li id="ba1a" class="kg kh hi ih b ii kp im kq iq kr iu ks iy kt jc kl km kn ko bi translated">上下文是不可变的。<code class="du ku kv kw kx b">context</code>包中没有一个API允许您改变上下文对象。您只能在现有上下文的基础上<em class="ky">创建</em>一个“子”上下文。</li><li id="d67a" class="kg kh hi ih b ii kp im kq iq kr iu ks iy kt jc kl km kn ko bi translated">虽然很有用，但是键值对不应该被过度使用。它不提供类型安全，并且容易发生键冲突，因为上下文可以跨多个库/应用程序使用</li></ul><h1 id="f9d7" class="jd je hi bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">结束语</h1><p id="1398" class="pw-post-body-paragraph if ig hi ih b ii kb ik il im kc io ip iq kd is it iu ke iw ix iy kf ja jb jc hb bi translated">在我看来，上下文很容易成为Go语言新手最常见的知识缺口。这不是最容易理解的一个，但却在很多地方使用！</p><p id="23e3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我希望您现在对Go中的上下文更加熟悉了。感谢您的阅读。</p><h1 id="d859" class="jd je hi bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">LIG系列是什么？</h1><p id="9a82" class="pw-post-body-paragraph if ig hi ih b ii kb ik il im kc io ip iq kd is it iu ke iw ix iy kf ja jb jc hb bi translated"><em class="ky"> Learn中级围棋系列旨在帮助你填补基础围棋教程之外的一些知识空白。它旨在包含从通常让你沮丧的事情中提取的精华，或者在基础教程之后的第一个项目中你错过了什么。目标受众:</em></p><ul class=""><li id="9bfe" class="kg kh hi ih b ii ij im in iq ki iu kj iy kk jc kl km kn ko bi translated"><em class="ky">你有学习另一种语言的经验，但是刚开始学，或者</em></li><li id="221e" class="kg kh hi ih b ii kp im kq iq kr iu ks iy kt jc kl km kn ko bi translated"><em class="ky">你刚刚完成了一个基础教程(例如围棋之旅)，但不确定如何获得进一步的知识，或者</em></li><li id="927f" class="kg kh hi ih b ii kp im kq iq kr iu ks iy kt jc kl km kn ko bi translated"><em class="ky">你已经写了几个月的围棋了，但是你想填补一些知识上的空白</em></li></ul><p id="8a79" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">目录(它们不是按顺序排列的——你可以按你想要的任何顺序阅读！):</p><ol class=""><li id="1dab" class="kg kh hi ih b ii ij im in iq ki iu kj iy kk jc mp km kn ko bi translated"><a class="ae lx" href="https://sanggon.medium.com/learn-intermediate-go-go-modules-c2f88f176fa6" rel="noopener"> <em class="ky"> Go模块</em> </a></li><li id="248b" class="kg kh hi ih b ii kp im kq iq kr iu ks iy kt jc mp km kn ko bi translated"><a class="ae lx" href="https://sanggon.medium.com/learn-intermediate-go-how-does-context-work-1898704c649b" rel="noopener"> <em class="ky">语境是如何工作的？</em> </a></li></ol></div></div>    
</body>
</html>