<html>
<head>
<title>(Daily Coding Problem: March 9th, 2020) Shortest Possible Path in a Maze</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">(每日编码问题:2020年3月9日)迷宫中最短的可能路径</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/daily-coding-problem-march-9th-2020-shortest-possible-path-in-a-maze-566152ef4e4a?source=collection_archive---------0-----------------------#2020-03-10">https://medium.com/nerd-for-tech/daily-coding-problem-march-9th-2020-shortest-possible-path-in-a-maze-566152ef4e4a?source=collection_archive---------0-----------------------#2020-03-10</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><figure class="hh hi ez fb hj hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es hg"><img src="../Images/37ea23b3ef6f874e9b53dadb131a5c4a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dSIXq4P6nAitj_j2aotU2w.jpeg"/></div></div></figure><div class=""/><p id="50b7" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">嘿伙计们，欢迎回来！这个博客是我们每天解决一个问题系列的延续，感谢<a class="ae jo" href="https://www.dailycodingproblem.com/" rel="noopener ugc nofollow" target="_blank"> <strong class="is hu">日常编码问题</strong> </a> <strong class="is hu">。</strong></p></div><div class="ab cl jp jq gp jr" role="separator"><span class="js bw bk jt ju jv"/><span class="js bw bk jt ju jv"/><span class="js bw bk jt ju"/></div><div class="hb hc hd he hf"><p id="cb86" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hu">问题:- </strong>给你一个M乘N的矩阵，由表示棋盘的布尔型组成。每个真布尔值代表一面墙。每个假布尔表示一个你可以在上面行走的瓷砖。</p><p id="083a" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">给定此矩阵、起始坐标和结束坐标，返回从起点到达结束坐标所需的最少步数。如果没有可能的路径，则返回null。你可以上下左右移动。你不能穿越墙壁。你不能绕过木板的边缘。</p><p id="64e8" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">例如，给定以下板:</p><pre class="jw jx jy jz fd ka kb kc kd aw ke bi"><span id="50da" class="kf kg ht kb b fi kh ki l kj kk">[[f, f, f, f],<br/>[t, t, f, t],<br/>[f, f, f, f],<br/>[f, f, f, f]]</span></pre><p id="33f7" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">start = <code class="du kl km kn kb b">(3, 0)</code>(左下角)和end = <code class="du kl km kn kb b">(0, 0)</code>(左上角)，到达终点所需的最少步数是7，因为我们需要通过<code class="du kl km kn kb b">(1, 2)</code>，因为第二排的其他地方都有墙。</p></div><div class="ab cl jp jq gp jr" role="separator"><span class="js bw bk jt ju jv"/><span class="js bw bk jt ju jv"/><span class="js bw bk jt ju"/></div><div class="hb hc hd he hf"><p id="d56f" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hu">解法:- <br/> </strong>看完问题，脑海里浮现的初始算法是<strong class="is hu"> DP </strong>(动态编程)。</p><p id="eca1" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">下面提到的是我看到这个问题后想到的主意</p><pre class="jw jx jy jz fd ka kb kc kd aw ke bi"><span id="bb36" class="kf kg ht kb b fi kh ki l kj kk">1 + min(dist(i-1,j), dist(i+1,j), dist(i,j-1), dist(i,j+1));</span></pre><p id="885e" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在做了一次测试后，我发现这将会是一个无限循环。因此，我开始寻找各种迷宫解决算法，这时候我遇到了<a class="ae jo" href="https://en.wikipedia.org/wiki/Lee_algorithm" rel="noopener ugc nofollow" target="_blank"> <strong class="is hu">李算法</strong> </a> <strong class="is hu">。</strong></p><p id="edfe" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在，在进入最终解决方案之前，让我们先看一下李的算法。</p><p id="0188" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">根据维基百科的文章，<strong class="is hu"> Lee算法</strong>是基于<a class="ae jo" href="https://en.wikipedia.org/wiki/Breadth-first_search" rel="noopener ugc nofollow" target="_blank">广度优先搜索</a>的<a class="ae jo" href="https://en.wikipedia.org/wiki/Maze_router" rel="noopener ugc nofollow" target="_blank">迷宫路由问题</a>的一种可能的解决方案。如果存在的话，它总是给出一个最优解，但是很慢并且需要相当大的内存。</p><ol class=""><li id="2318" class="ko kp ht is b it iu ix iy jb kq jf kr jj ks jn kt ku kv kw bi translated">创建一个空队列和一个空2d数组来标记访问过的节点。</li><li id="125c" class="ko kp ht is b it kx ix ky jb kz jf la jj lb jn kt ku kv kw bi translated">检查起始坐标上是否有墙(如果矩阵有“t”值)。如果是，则返回-1或整数。MAX_VALUE否则，将距离标记为0的起点坐标推入队列，并将元素标记为已访问。</li><li id="3512" class="ko kp ht is b it kx ix ky jb kz jf la jj lb jn kt ku kv kw bi translated">重复下面提到的步骤，直到队列不为空- <br/> a .从队列中弹出一个元素。<br/> <br/> b .检查弹出的元素是否是目的坐标，如果是，<strong class="is hu">返回弹出元素的距离。</strong> <br/> <br/> c .将所有有效元素向4个方向(上、下、左、右)推送，距离为队列中<strong class="is hu">弹出元素距离+1 </strong>。<br/> <br/>有效元素是符合以下标准的元素:-</li></ol><pre class="jw jx jy jz fd ka kb kc kd aw ke bi"><span id="f197" class="kf kg ht kb b fi kh ki l kj kk">isValid(boolean value, int M, int N, boolean visit, int i, int j) {<br/>   return !(i &lt; 0 || j &lt; 0 || i &gt;= M || j &gt;= N || !value || visit)<br/>}</span></pre><p id="e17b" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">4.如果队列为空，则返回-1或整数。MAX_VALUE，因为没有到达目的地坐标的路径。</p></div><div class="ab cl jp jq gp jr" role="separator"><span class="js bw bk jt ju jv"/><span class="js bw bk jt ju jv"/><span class="js bw bk jt ju"/></div><div class="hb hc hd he hf"><p id="044a" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">下面是基于这种方法的问题的java代码实现</p><figure class="jw jx jy jz fd hk"><div class="bz dy l di"><div class="lc ld l"/></div></figure></div><div class="ab cl jp jq gp jr" role="separator"><span class="js bw bk jt ju jv"/><span class="js bw bk jt ju jv"/><span class="js bw bk jt ju"/></div><div class="hb hc hd he hf"><p id="f995" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hu">时间复杂度:- </strong> O(MN) <strong class="is hu"> <br/>空间复杂度:- </strong> O(MN)</p></div><div class="ab cl jp jq gp jr" role="separator"><span class="js bw bk jt ju jv"/><span class="js bw bk jt ju jv"/><span class="js bw bk jt ju"/></div><div class="hb hc hd he hf"><p id="ead0" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hu">为更好地理解数据结构和算法而阅读的书籍- </strong></p><ul class=""><li id="b252" class="ko kp ht is b it iu ix iy jb kq jf kr jj ks jn le ku kv kw bi translated"><a class="ae jo" href="https://amzn.to/2NmpRoy" rel="noopener ugc nofollow" target="_blank">数据结构和算法变得简单:数据结构和算法难题，第二版</a></li></ul><figure class="jw jx jy jz fd hk er es paragraph-image"><div class="er es lf"><img src="../Images/0e365336c5214bdb38df31fa32eced56.png" data-original-src="https://miro.medium.com/v2/resize:fit:772/format:webp/1*QZBxfsSj3KQVqvMBCu82RA.jpeg"/></div></figure></div><div class="ab cl jp jq gp jr" role="separator"><span class="js bw bk jt ju jv"/><span class="js bw bk jt ju jv"/><span class="js bw bk jt ju"/></div><div class="hb hc hd he hf"><p id="fedf" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">以上是我的观点，非常感谢你阅读我的博客。我将继续这个系列，继续讨论日常问题。如需进一步讨论，请随时联系我，电话号码是<em class="lg">divyabiyani26@gmail.com。</em></p></div></div>    
</body>
</html>