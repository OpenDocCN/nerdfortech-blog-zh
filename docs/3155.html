<html>
<head>
<title>Inverse Data Flow in React (Children, go talk to your parents…)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">React中的逆向数据流(孩子，去和父母说吧……)</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/inverse-data-flow-in-react-children-go-talk-to-your-parents-58437e9e57a7?source=collection_archive---------10-----------------------#2021-05-31">https://medium.com/nerd-for-tech/inverse-data-flow-in-react-children-go-talk-to-your-parents-58437e9e57a7?source=collection_archive---------10-----------------------#2021-05-31</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="9af9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">当开始使用React和useState时，我遇到的一个常见问题是，当不同的组件相互交互时，要确保DOM被正确地呈现。确保父组件接收来自其子组件的信息被称为反向数据流，没有它，您的DOM的状态将无法正确呈现。</p><p id="7a4a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">假设页面上有一组项目。在该页面上，您可以看到作为单独卡片的所有项目列表，并且您可以在这些项目中进行搜索。因为你是有组织的，并且喜欢给你的应用程序的每个功能赋予它自己的组件，你的组件模型在父子关系方面看起来应该是这样的:</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es jd"><img src="../Images/3457fe4cf89bf4e7c4233e6741eda95b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uh7-4PAOACpqfVHVxG64Aw.png"/></div></div></figure><p id="f010" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这就是我们假设的父组件与其子(和孙)组件的关系。React在决定将数据放在哪里时的惯例是在最低的公共父模型中获取数据，以便依赖于该信息的每个子组件都可以访问它。</p><p id="f1ea" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在React中，我们拥有将属性或道具从父组件传递给子组件的绝妙工具。这些可以是我们想要的任何JS对象，通常是一个数组。在这个例子中，我们将传递数组、对象和最重要的函数。如果你对这个概念不太熟悉，在继续阅读之前，请点击这里仔细阅读。</p><p id="08ea" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">由于搜索和列表组件依赖于同一个数组，主页将是我们从后端调用信息的地方，如下所示:</p><pre class="je jf jg jh fd jq jr js jt aw ju bi"><span id="6e5c" class="jv jw hi jr b fi jx jy l jz ka">import {useEffect, useState} from 'React'<br/>import Search from './Search'<br/>import ListOfItems from './ListOfItems'</span><span id="0d04" class="jv jw hi jr b fi kb jy l jz ka">function MainPage(){<br/>  const [array, setArray] = useState([])</span><span id="a875" class="jv jw hi jr b fi kb jy l jz ka">  useEffect(() =&gt; {<br/>    fetch('https://www.backend.URL')<br/>      .then(res =&gt; res.json())<br/>      .then(data =&gt; setArray(data))<br/>  }, [])</span><span id="4284" class="jv jw hi jr b fi kb jy l jz ka">  return (  <br/>    &lt;div&gt;<br/>      &lt;Search /&gt;<br/>      &lt;ListOfItems array={array} /&gt;<br/>    &lt;/div&gt;<br/>  )<br/>}</span></pre><p id="75c5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在我们的物品列表组件中，我们将映射来自父组件的作为道具给出的数组，并将该数组中的对象传递给物品卡片，如下所示:</p><pre class="je jf jg jh fd jq jr js jt aw ju bi"><span id="42fc" class="jv jw hi jr b fi jx jy l jz ka">import ItemCard from './ItemCard'</span><span id="f611" class="jv jw hi jr b fi kb jy l jz ka">function ListOfItems({array}){<br/>  const itemArray = array.map(itemObject =&gt;<br/>    &lt;ItemCard key={itemObject.id} item={itemObject} /&gt;<br/>  )<br/>  return (<br/>    &lt;div&gt;<br/>      {itemArray}<br/>    &lt;/div&gt;<br/>  )<br/>}</span><span id="0ba0" class="jv jw hi jr b fi kb jy l jz ka">export default ListOfItems</span></pre><p id="5c06" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">最后是我们的物品卡片，我们将显示每件物品的信息，如下所示:</p><pre class="je jf jg jh fd jq jr js jt aw ju bi"><span id="25c8" class="jv jw hi jr b fi jx jy l jz ka">function ItemCard({item}){<br/>  return(<br/>    &lt;div&gt;<br/>      &lt;h2&gt;item.name&lt;/h2&gt;<br/>      &lt;p&gt;item.content&lt;/p&gt;<br/>      &lt;button&gt;Delete this item!&lt;/button&gt;<br/>    &lt;/div&gt;<br/>  )<br/>}</span><span id="1b7f" class="jv jw hi jr b fi kb jy l jz ka">export default ItemCard</span></pre><p id="fa4d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">删除按钮会影响条目列表组件状态和搜索组件状态，但是我们如何让子组件(条目卡片)告诉它的父组件它做了什么来确保DOM正确呈现呢？我们不希望我们的用户看到已经删除的项目，或者搜索它们。进入我们的朋友，回拨。</p><p id="1d1f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">当用户单击删除按钮时，需要发生两件事。首先，我们需要以delete方法的形式获取后端数据，以便从数据库中实际删除该项。这将发生在我们的项目卡组件中。其次，项目卡组件需要告诉其父组件(在本例中是祖父母)该项目已被删除，并相应地更新DOM。为此，我们将在主页面组件中定义一个函数来处理删除操作，并将其作为一个prop向下传递，以便在删除时由项目卡调用。</p><pre class="je jf jg jh fd jq jr js jt aw ju bi"><span id="2269" class="jv jw hi jr b fi jx jy l jz ka">import {useEffect, useState} from 'React'<br/>import Search from './Search'<br/>import ListOfItems from './ListOfItems'</span><span id="1770" class="jv jw hi jr b fi kb jy l jz ka">function MainPage(){<br/>  const [array, setArray] = useState([])</span><span id="5637" class="jv jw hi jr b fi kb jy l jz ka">  useEffect(() =&gt; {<br/>    fetch('https://www.backend.URL')<br/>      .then(res =&gt; res.json())<br/>      .then(data =&gt; setArray(data))<br/>  }, [])</span><span id="667b" class="jv jw hi jr b fi kb jy l jz ka">  function onDelete(id){<br/>    const updatedArray = array.filter(item =&gt;<br/>      item.id !== id<em class="kc"><br/>    </em>)<br/>    setArray(updatedArray)<br/>  }</span><span id="7ca3" class="jv jw hi jr b fi kb jy l jz ka">  return (  <br/>    &lt;div&gt;<br/>      &lt;Search /&gt;<br/>      &lt;ListOfItems array={array} onDelete={onDelete}/&gt;<br/>    &lt;/div&gt;<br/>  )<br/>}</span></pre><p id="8f15" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这里，onDelete被赋予一个ID，并在我们的原始数组中进行搜索。然后，它排除ID与给定ID匹配的所有项目，并返回一个新数组。注意，我们没有在主页中调用这个函数。我们只是在这里定义它。然后，它通过项目列表组件传递到按钮所在的项目卡。</p><pre class="je jf jg jh fd jq jr js jt aw ju bi"><span id="8000" class="jv jw hi jr b fi jx jy l jz ka">import ItemCard from './ItemCard'</span><span id="d14e" class="jv jw hi jr b fi kb jy l jz ka">function ListOfItems({array, onDelete}){<br/>  const itemArray = array.map(itemObject =&gt;<br/>    &lt;ItemCard key={itemObject.id} item={itemObject} <br/>      onDelete={onDelete}/&gt;<br/>  )<br/>  return (<br/>    &lt;div&gt;<br/>      {itemArray}<br/>    &lt;/div&gt;<br/>  )<br/>}</span><span id="c243" class="jv jw hi jr b fi kb jy l jz ka">export default ListOfItems</span></pre><p id="26f1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">最后，我们在fetch方法中调用这个onDelete函数，以确定如何处理fetch的响应。</p><pre class="je jf jg jh fd jq jr js jt aw ju bi"><span id="5b23" class="jv jw hi jr b fi jx jy l jz ka">function ItemCard({item, onDelete}){<br/>  const {id, name, content} = item</span><span id="4298" class="jv jw hi jr b fi kb jy l jz ka">  function handleClick(){<br/>    fetch(`https://www.backend.URL/${id}`, {<br/>      method: "DELETE",<br/>    })<br/>    .then(res =&gt; res.json())<br/>    .then(() =&gt; onDelete(id))<br/>  }</span><span id="5b39" class="jv jw hi jr b fi kb jy l jz ka">  return(<br/>    &lt;div&gt;<br/>      &lt;h2&gt;{name}&lt;/h2&gt;<br/>      &lt;p&gt;{content}&lt;/p&gt;<br/>      &lt;button onClick={handleClick}&gt;Delete this item!&lt;/button&gt;<br/>    &lt;/div&gt;<br/>  )<br/>}</span><span id="b939" class="jv jw hi jr b fi kb jy l jz ka">export default ItemCard</span></pre><p id="d70a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">注意这里我们也在<a class="ae jp" rel="noopener" href="/@lcriswell/destructuring-props-in-react-b1c295005ce0">析构</a>我们的Item object prop以使ID可以被获取。如果不这样做，我们的handleClick函数将不会知道您试图删除哪个项目。现在你问搜索组件呢？让我们再做一遍。这会变得稍微复杂一点，但是请继续关注我。你能做到的！</p><p id="bf9d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">从主页组件开始，我们将定义我们希望搜索组件如何影响DOM。此外，我们需要映射一个过滤后的数组，而不是原来的后端数组，因此我们将为此创建一个变量，并将其作为一个属性传递给我们的项目列表组件。</p><pre class="je jf jg jh fd jq jr js jt aw ju bi"><span id="f860" class="jv jw hi jr b fi jx jy l jz ka">import {useEffect, useState} from 'React'<br/>import Search from './Search'<br/>import ListOfItems from './ListOfItems'</span><span id="a781" class="jv jw hi jr b fi kb jy l jz ka">function MainPage(){<br/>  const [array, setArray] = useState([])<br/>  const [searchedItem, setSearchedItem] = useState("")</span><span id="3542" class="jv jw hi jr b fi kb jy l jz ka">  useEffect(() =&gt; {<br/>      fetch('https://www.backend.URL')<br/>        .then(res =&gt; res.json())<br/>        .then(data =&gt; setArray(data))<br/>  }, [])</span><span id="22bf" class="jv jw hi jr b fi kb jy l jz ka">  function onDelete(id){<br/>    const updatedArray = array.filter(item =&gt;<br/>      item.id !== id<em class="kc"><br/>    </em>)<br/>    setArray(updatedArray)<br/>  }</span><span id="8be9" class="jv jw hi jr b fi kb jy l jz ka">  function onSearch(e){<br/>    setSearchedItem(e)<br/>  }</span><span id="59d0" class="jv jw hi jr b fi kb jy l jz ka">  const searchedArray = array.filter(item =&gt; {<br/>   if(item.name.toLowerCase().includes(searchedItem.toLowerCase())){<br/>    return true<br/>    } <br/>  })</span><span id="fb43" class="jv jw hi jr b fi kb jy l jz ka">  return (  <br/>    &lt;div&gt;<br/>      &lt;Search searchedItem={searchedItem} onSearch={onSearch}/&gt;<br/>      &lt;ListOfItems array={searchedArray} onDelete={onDelete}/&gt;<br/>    &lt;/div&gt;<br/>  )<br/>}</span></pre><p id="06d7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这里我们必须包含第二个useState，这样React就知道用户在搜索什么。就像我们的删除按钮一样，我们在父节点中定义onSearch，并在子节点中调用它。</p><pre class="je jf jg jh fd jq jr js jt aw ju bi"><span id="4d1f" class="jv jw hi jr b fi jx jy l jz ka">function Search({searchedItem, onSearch}){<br/>  return(<br/>    &lt;div&gt;<br/>      &lt;input type="text"<br/>             value={searchedItem} <br/>             onChange={e =&gt; onSearch(e.target.value)}&gt;<br/>      &lt;/input&gt;<br/>    &lt;/div&gt;<br/>  )<br/>}</span><span id="ca54" class="jv jw hi jr b fi kb jy l jz ka">export default Search</span></pre><p id="7f99" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">onSearch所做的是设置用户输入的值，并将其发送回主页，这样React就可以计算出根据什么来过滤我们的原始数组。这样做的结果是，当用户键入他们想要的内容时，您的项目列表会在您的页面上实时变化。相当甜蜜！</p><p id="b3a3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">正如一位出色的教师告诉我的，记住这个工作流的另一种方式是，对于父组件和子组件，您应该定义down并调用up。我们在主页面(父页面)组件中定义了onDelete和onSearch，然后将其发送给子页面。当它们被调用时(物品卡片中的onDelete或搜索中的onSearch)，该动作被发送回父项。</p><p id="0767" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">希望这有助于消除在DOM操作中使用state时的一些困惑。如果没有，这里有一些链接指向这篇文章所依赖的一些帮助主题。</p><blockquote class="kd ke kf"><p id="4ade" class="if ig kc ih b ii ij ik il im in io ip kg ir is it kh iv iw ix ki iz ja jb jc hb bi translated"><a class="ae jp" href="https://www.w3schools.com/js/js_htmldom.asp" rel="noopener ugc nofollow" target="_blank">什么是DOM？</a></p><p id="fcbd" class="if ig kc ih b ii ij ik il im in io ip kg ir is it kh iv iw ix ki iz ja jb jc hb bi translated"><a class="ae jp" href="https://reactjs.org/docs/hooks-state.html" rel="noopener ugc nofollow" target="_blank">反应使用状态挂钩</a></p><p id="6254" class="if ig kc ih b ii ij ik il im in io ip kg ir is it kh iv iw ix ki iz ja jb jc hb bi translated"><a class="ae jp" href="https://reactjs.org/docs/hooks-effect.html" rel="noopener ugc nofollow" target="_blank">反应使用效果挂钩</a></p></blockquote></div></div>    
</body>
</html>