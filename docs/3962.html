<html>
<head>
<title>Generating k-combinations with recursion in JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用JavaScript递归生成k-组合</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/july-2-generating-k-combinations-with-recursion-in-javascript-71ef2b90b44b?source=collection_archive---------3-----------------------#2021-07-01">https://medium.com/nerd-for-tech/july-2-generating-k-combinations-with-recursion-in-javascript-71ef2b90b44b?source=collection_archive---------3-----------------------#2021-07-01</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div class="er es if"><img src="../Images/4b3aff4bebbd1139d58e40018de87a73.png" data-original-src="https://miro.medium.com/v2/resize:fit:800/1*9EeiIvWac60p3O3MsDH0Dw.gif"/></div><figcaption class="im in et er es io ip bd b be z dx translated">图片来源:冰屋</figcaption></figure><p id="d218" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">众所周知，我喜欢游戏——因为它们的教育价值和娱乐价值。没有比写游戏更好的学习编码的方法了。即使是简单的游戏也有规则、等级、状态和条件——解决这些问题所需的技能与工程师用来解决现实世界问题的技能没有什么不同。</p><p id="b693" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如果我正在学习一门新的编程语言，我通常做的第一件事就是尝试编写一个游戏，这个游戏通常是<strong class="is hj"> poker。</strong>对我来说，扑克是无尽快乐和愉悦的源泉，因为它是一个令人上瘾的逻辑谜题——当然，它被巧妙地伪装成了赌场赌博游戏。今天，让我们重温一下我写的关于扑克的一篇非常老的博客文章<a class="ae jo" href="https://joshgoestoflatiron.medium.com/december-16-possible-hands-and-holds-in-a-ruby-poker-machine-9d61de22e948" rel="noopener">的主题，并使用它来探索两个重要的、被广泛讨论的软件工程概念:<strong class="is hj"> k组合</strong>和<strong class="is hj">头/尾递归。</strong></a></p><h1 id="149b" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">背景:K基金会</h1><p id="f580" class="pw-post-body-paragraph iq ir hi is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hb bi translated">在数学和比较科学中，<strong class="is hj"> <em class="ks">组合</em>是从集合中无序选择的项目。</strong>如果顺序很重要，那就叫做<strong class="is hj"> <em class="ks">排列</em>；</strong>两者密切相关，对组合/排列的研究被称为<strong class="is hj"> <em class="ks">组合学</em>。这个领域非常广阔，有很多非常重要的应用:</strong></p><ul class=""><li id="988a" class="kt ku hi is b it iu ix iy jb kv jf kw jj kx jn ky kz la lb bi translated"><strong class="is hj">性能评估:</strong>在通信系统上生成路由排列以比较性能</li><li id="6718" class="kt ku hi is b it lc ix ld jb le jf lf jj lg jn ky kz la lb bi translated"><strong class="is hj">分子生物学:</strong>产生原子、分子、DNA、基因或蛋白质的组合/排列</li><li id="7c3a" class="kt ku hi is b it lc ix ld jb le jf lf jj lg jn ky kz la lb bi translated"><strong class="is hj">自然语言处理:</strong>生成词性组合/排列的文本匹配算法</li><li id="0c77" class="kt ku hi is b it lc ix ld jb le jf lf jj lg jn ky kz la lb bi translated">运筹学:用组合学解决作业调度和资源分配问题</li><li id="2df2" class="kt ku hi is b it lc ix ld jb le jf lf jj lg jn ky kz la lb bi translated"><strong class="is hj">数据挖掘和取证:</strong>为什么不生成<code class="du lh li lj lk b">SELECT ... WHERE ...</code>命令的组合来寻找丢失的数据或隐藏的数据或犯罪证据？</li><li id="f453" class="kt ku hi is b it lc ix ld jb le jf lf jj lg jn ky kz la lb bi translated">广义而言，<strong class="is hj">图像、声音、温度、压力、电导率等物理世界的测量值中的任何模式匹配</strong></li></ul><p id="cd45" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">所有的卡牌游戏都是组合学游戏；</strong>这副牌是我们的收藏，手牌大小是我们的<em class="ks"> k. </em>五张Jacks或更好的牌，<a class="ae jo" href="https://joshgoestoflatiron.medium.com/december-16-possible-hands-and-holds-in-a-ruby-poker-machine-9d61de22e948" rel="noopener">游戏Vegas video poker基于</a>，是一个52组合5游戏；德州扑克和其他梭哈扑克品种是52-组合-7游戏。</p><h1 id="fb3f" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">正面我赢，反面你输</h1><p id="da67" class="pw-post-body-paragraph iq ir hi is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hb bi translated">一些流行的语言有内置的方法，比如Ruby的<code class="du lh li lj lk b">combination()</code>和Python的<code class="du lh li lj lk b">itertools</code>，但是<strong class="is hj"> JavaScript，可悲的是，没有原生/低级组合函数</strong>。为了拓宽我们的知识面，满足我们对惩罚的欲望，让我们使用<strong class="is hj">递归来编写我们自己的JS <code class="du lh li lj lk b">combination()</code>方法。</strong> ( <em class="ks">请记住，有许多组合学算法，其中许多与我将讨论的递归方法非常不同，并且可能比它快得多……但是对它们进行详细的比较/讨论是博士候选人的工作——</em>而不是中等博客作者的工作。)</p><p id="92f8" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">首先，快速回顾一下我以前的博客文章中的递归<a class="ae jo" href="https://joshgoestoflatiron.medium.com/december-28-finding-paths-on-a-grid-in-ruby-with-recursion-53e83bfa99e8" rel="noopener">:</a><strong class="is hj">递归通过重复解决一个相同但较小的问题(基础案例)来解决一个大问题(T21递归案例)。基本情况看起来和递归情况一样——只是规模更小。<strong class="is hj">递归只在程序最终到达基础用例时才起作用；如果没有达到基本情况，递归方法将无限重复。</strong></strong></p><figure class="lm ln lo lp fd ij er es paragraph-image"><div class="er es ll"><img src="../Images/6149b8a89ef35873c7410b74f38c78b6.png" data-original-src="https://miro.medium.com/v2/resize:fit:874/format:webp/1*7TuKuAHYNbORqMTzIS6lIQ.jpeg"/></div><figcaption class="im in et er es io ip bd b be z dx translated">我不会为这个迷因的照片信用而烦恼，因为它似乎从时间的黎明就开始四处飘荡</figcaption></figure><p id="da47" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我没有讨论的一个重要区别存在于<strong class="is hj">头递归</strong>和<strong class="is hj">尾递归之间；</strong>递归调用可能在基本情况处理之前<em class="ks">(在函数的顶部或“头部”)，或者在</em>基本情况之后<em class="ks">(在底部或“尾部”)。我已经用下面的两个<code class="du lh li lj lk b">factorial()</code>函数说明了这一点，它们做同样的事情:</em></p><pre class="lm ln lo lp fd lq lk lr ls aw lt bi"><span id="0800" class="lu jq hi lk b fi lv lw l lx ly">const headFactorial = n =&gt; {<br/>  if ( n &gt; 1 ) return n * headFactorial( n - 1 );<br/>  else return 1;<br/>}</span><span id="5d51" class="lu jq hi lk b fi lz lw l lx ly">const tailFactorial = n =&gt; {<br/>  if ( n === 1 ) return 1;<br/>  else return n * tailFactorial( n - 1 );<br/>}</span></pre><p id="6201" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这两种递归风格看起来微不足道，但是您将在下面看到，在我们生成k-组合的方法中，选择是非常重要的。</p><h1 id="e443" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">凭借我们的力量…</h1><p id="984e" class="pw-post-body-paragraph iq ir hi is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hb bi translated">如果一个集合有<em class="ks"> n </em>个元素，则来自该集合的<em class="ks"> k </em>个组合的数量可以表示为一个带有阶乘的<a class="ae jo" href="https://en.wikipedia.org/wiki/Binomial_coefficient" rel="noopener ugc nofollow" target="_blank">二项式系数</a>:</p><figure class="lm ln lo lp fd ij er es paragraph-image"><div class="er es ma"><img src="../Images/5c88bc91751fabecfca04d36d44a26a4.png" data-original-src="https://miro.medium.com/v2/resize:fit:620/format:webp/1*UkfJCjKreGaD7-LTzyJt9A.png"/></div></figure><p id="fb89" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这写起来很简单，但是在我们的扑克例子(52-combo-5)中，它导致了一些令人头痛的数学问题…</p><figure class="lm ln lo lp fd ij er es paragraph-image"><div role="button" tabindex="0" class="mc md di me bf mf"><div class="er es mb"><img src="../Images/0e71e93d4166e5b697b012feda7eb302.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TdPjOkpV3--qQScfC1BAQw.png"/></div></div></figure><p id="8c81" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">…因此，让我们通过一些因素来清理它:</p><figure class="lm ln lo lp fd ij er es paragraph-image"><div role="button" tabindex="0" class="mc md di me bf mf"><div class="er es mg"><img src="../Images/39eda739c0f3430035edc1b4ae301c1f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RtXj5oLwkzESTg9vTyN2LQ.png"/></div></div></figure><p id="ded5" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">当你想象自己在牌桌上抽一手牌，以一种更具体的方式来思考时，这就很有意义了。抽第一张牌时，你有52张牌可供选择，抽第二张牌时，你有51种可能性，依此类推。想想看:<strong class="is hj">这真的不意味着每一个组合都只是前面的组合，其余的组合都加在了后面吗？</strong></p><p id="dc41" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">让我们用下面的方法来检验这个假设。它使用尾部递归，但它也<strong class="is hj">跟踪集合的头部<em class="ks">和尾部</em>我们在递归时为</strong>生成组合:</p><pre class="lm ln lo lp fd lq lk lr ls aw lt bi"><span id="10e3" class="lu jq hi lk b fi lv lw l lx ly">const combinations = ( collection, combinationLength ) =&gt; {<br/>  let head, tail, result = [];<br/>  if ( combinationLength &gt; collection.length || combinationLength &lt; 1 ) { return []; }<br/>  if ( combinationLength === collection.length ) { return [ collection ]; }<br/>  if ( combinationLength === 1 ) { return collection.map( element =&gt; [ element ] ); }<br/>  for ( let i = 0; i &lt; collection.length - combinationLength + 1; i++ ) {<br/>    head = collection.slice( i, i + 1 );<br/>    tail = combinations( collection.slice( i + 1 ), combinationLength - 1 );<br/>    for ( let j = 0; j &lt; tail.length; j++ ) { result.push( head.concat( tail[ j ] ) ); }<br/>  }<br/>  return result;<br/>}</span></pre><p id="994e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">逐行分解:首先我们定义一个<code class="du lh li lj lk b">head</code>和<code class="du lh li lj lk b">tail</code>来跟踪我们到目前为止的进展，然后定义三种基本情况:</p><ul class=""><li id="12f2" class="kt ku hi is b it iu ix iy jb kv jf kw jj kx jn ky kz la lb bi translated">然后，如果<code class="du lh li lj lk b">combinationLength</code>大于集合的大小，或者如果<code class="du lh li lj lk b">combinationLength</code>为零，我们返回一个空数组<code class="du lh li lj lk b">[]</code>。</li><li id="c93e" class="kt ku hi is b it lc ix ld jb le jf lf jj lg jn ky kz la lb bi translated">如果<code class="du lh li lj lk b">combinationLength</code>等于集合大小，那么只有一个可能的组合，即整个集合——所以我们在一个数组中返回整个集合。</li><li id="d896" class="kt ku hi is b it lc ix ld jb le jf lf jj lg jn ky kz la lb bi translated">如果是<code class="du lh li lj lk b">combinationLength === 1</code>，我们可能的组合只是单个元素——所以我们将集合<code class="du lh li lj lk b">map()</code> ped作为长度为1的单个数组(组合)返回给它的元素。</li></ul><p id="597b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">否则，我们将遍历集合并开始循环！</p><ul class=""><li id="eae4" class="kt ku hi is b it iu ix iy jb kv jf kw jj kx jn ky kz la lb bi translated">我们的<code class="du lh li lj lk b">head</code>将是一个单元素的数组:由<code class="du lh li lj lk b">for()</code>循环中的<code class="du lh li lj lk b">i</code>定义的当前索引处的元素。</li><li id="a9bc" class="kt ku hi is b it lc ix ld jb le jf lf jj lg jn ky kz la lb bi translated">我们的<code class="du lh li lj lk b">tail</code>将是一个递归调用<strong class="is hj">的结果，其中</strong> <code class="du lh li lj lk b"><strong class="is hj">combinationLength</strong></code> <strong class="is hj">递减1——记住，如果不递减，我们将永远循环并崩溃！</strong>我们将<code class="du lh li lj lk b">tail</code>中的每个元素添加到<code class="du lh li lj lk b">head</code>的末尾，因为每个元素代表一个新的组合，所以我们将每次<code class="du lh li lj lk b">push</code>添加到<code class="du lh li lj lk b">result</code>。</li><li id="24d3" class="kt ku hi is b it lc ix ld jb le jf lf jj lg jn ky kz la lb bi translated">最后，当然，当我们完成循环时。</li></ul><p id="a901" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">当它不那么抽象时，更容易想象，所以让我们在<code class="du lh li lj lk b">console</code>中测试一下:</p><pre class="lm ln lo lp fd lq lk lr ls aw lt bi"><span id="5619" class="lu jq hi lk b fi lv lw l lx ly">const deck = [<br/>  'Two of Clubs',      'Two of Diamonds',   'Two of Hearts',<br/>  'Two of Spades',     'Three of Clubs',    'Three of Diamonds',<br/>  'Three of Hearts',   'Three of Spades',   'Four of Clubs',<br/>  <em class="ks">...trust me they're all there</em><br/>];</span><span id="9609" class="lu jq hi lk b fi lz lw l lx ly">const possibleHands = combinations( deck, 5 );</span><span id="c066" class="lu jq hi lk b fi lz lw l lx ly">console.log( possibleHands.length );<br/>  -&gt; 2598960<br/>console.log( possibleHands.slice( 0, 5 ) );<br/>  -&gt; [<br/>    [ 'Two of Clubs', 'Two of Diamonds', 'Two of Hearts', 'Two of Spades', 'Three of Clubs' ],<br/>    [ 'Two of Clubs', 'Two of Diamonds', 'Two of Hearts', 'Two of Spades', 'Three of Diamonds' ],<br/>    [ 'Two of Clubs', 'Two of Diamonds', 'Two of Hearts', 'Two of Spades', 'Three of Hearts' ],<br/>    [ 'Two of Clubs', 'Two of Diamonds', 'Two of Hearts', 'Two of Spades', 'Three of Spades' ],<br/>    [ 'Two of Clubs', 'Two of Diamonds', 'Two of Hearts', 'Two of Spades', 'Four of Clubs' ]<br/>]</span></pre><p id="f5c6" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们可以看到，这种方法从一副52张牌中生成了可能的五手牌的正确数量:<strong class="is hj"> 2，598，960，</strong>与<code class="du lh li lj lk b">( 52 * 51 * 50 * 49 * 48 ) / ( 5 * 4 * 3 * 2 )</code>的结果相同(如果你不相信我，你自己去查)。</p><p id="444b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">让我们试着用一个更小的集合生成组合，并添加一些<code class="du lh li lj lk b">console.log</code>来看看发生了什么:</p><pre class="lm ln lo lp fd lq lk lr ls aw lt bi"><span id="45fe" class="lu jq hi lk b fi lv lw l lx ly">const combinations = ( collection, combinationLength ) =&gt; {<br/>  let head, tail, result = [];<br/>  if ( combinationLength &gt; collection.length || combinationLength &lt; 1 ) { return []; }<br/>  if ( combinationLength === collection.length ) { return [ collection ]; }<br/>  if ( combinationLength === 1 ) { return collection.map( element =&gt; [ element ] ); }<br/>  for ( let i = 0; i &lt; collection.length - combinationLength + 1; i++ ) {<br/>    head = collection.slice( i, i + 1 );<br/>    <strong class="lk hj">console.log( "head: ", head );<br/></strong>    tail = combinations( collection.slice( i + 1 ), combinationLength - 1 );<br/>    <strong class="lk hj">console.log( "tail: ", tail );<br/></strong>    for ( let j = 0; j &lt; tail.length; j++ ) { result.push( head.concat( tail[ j ] ) ); }<br/>  }<br/>  return result;<br/>}</span><span id="2e11" class="lu jq hi lk b fi lz lw l lx ly">const oneThroughFive = [ 1, 2, 3, 4, 5 ];</span></pre><p id="ad0b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">例如，如果您将它复制到一个节点控制台并运行<code class="du lh li lj lk b">combinations( oneThroughFive, 3 )</code>，您将看到如下所示的日志溢出:</p><pre class="lm ln lo lp fd lq lk lr ls aw lt bi"><span id="773d" class="lu jq hi lk b fi lv lw l lx ly">head:  [ 1 ]<br/>head:  [ 2 ]<br/>tail:  [ [ 3 ], [ 4 ], [ 5 ] ]<br/>head:  [ 3 ]<br/>tail:  [ [ 4 ], [ 5 ] ]<br/>head:  [ 4 ]<br/>tail:  [ [ 5 ] ]<br/>tail:  [ [ 2, 3 ], [ 2, 4 ], [ 2, 5 ], [ 3, 4 ], [ 3, 5 ], [ 4, 5 ] ]<br/>head:  [ 2 ]<br/>head:  [ 3 ]<br/>tail:  [ [ 4 ], [ 5 ] ]<br/>head:  [ 4 ]<br/>tail:  [ [ 5 ] ]<br/>tail:  [ [ 3, 4 ], [ 3, 5 ], [ 4, 5 ] ]<br/>head:  [ 3 ]<br/>tail:  [ [ 4, 5 ] ]<br/>[<br/>  [ 1, 2, 3 ], [ 1, 2, 4 ],<br/>  [ 1, 2, 5 ], [ 1, 3, 4 ],<br/>  [ 1, 3, 5 ], [ 1, 4, 5 ],<br/>  [ 2, 3, 4 ], [ 2, 3, 5 ],<br/>  [ 2, 4, 5 ], [ 3, 4, 5 ]<br/>]</span></pre><p id="9075" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这非常清楚地显示了一些有趣的事情:<strong class="is hj">我们从来没有真正打印过任何</strong> <code class="du lh li lj lk b"><strong class="is hj">tail</strong></code> <strong class="is hj"> s，直到我们完成了循环或者到达了我们的一个基本案例！</strong><code class="du lh li lj lk b">head</code>始终是该系列中的单一元素，加上来自<code class="du lh li lj lk b">tail</code>的可能组合——确保组合永不重复。下图直观地展示了当我们遍历带有<code class="du lh li lj lk b">3</code>的<code class="du lh li lj lk b">combinationLength</code>的集合<code class="du lh li lj lk b">oneThroughFive</code>时，这一切是如何发生的:</p><figure class="lm ln lo lp fd ij er es paragraph-image"><div role="button" tabindex="0" class="mc md di me bf mf"><div class="er es mh"><img src="../Images/bb5f9d1554c6c5f379aff0749cb62c90.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*asNRSKf0bCxifsWZeY9pDA.png"/></div></div></figure><h1 id="c3c9" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated"><strong class="ak">结论</strong></h1><p id="c4b0" class="pw-post-body-paragraph iq ir hi is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hb bi translated">我们用来生成k-组合的所有巧妙跟踪都不可能用头部递归来实现。也有相反的例子:许多排序算法不可能使用尾部递归。还有更多最适合其他类型问题的递归例子:所谓的<em class="ks">循环</em>或<em class="ks">相互递归，</em>其中两个或更多方法递归地相互调用，最广为人知的是来自河内<a class="ae jo" href="https://en.wikipedia.org/wiki/Tower_of_Hanoi" rel="noopener ugc nofollow" target="_blank"> <strong class="is hj">塔</strong>谜题</a>的CompSci学生。</p><figure class="lm ln lo lp fd ij er es paragraph-image"><div class="er es mi"><img src="../Images/79a13cacd072d2824655979f703c2a67.png" data-original-src="https://miro.medium.com/v2/resize:fit:600/format:webp/1*A42dG5EKUCd7qNM9fB7jKA.jpeg"/></div><figcaption class="im in et er es io ip bd b be z dx translated">每当一位计算机科学教授用递归解决汉诺塔问题时，一位技术天使就展翅高飞了(图片来源:维基共享资源)</figcaption></figure><p id="2fc9" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">递归也有缺点——最大的缺点，我之前提到过，是它的潜在指数增长可能会让你的代码慢如蜗牛。如果您一直在将这段代码复制到Node中，您会注意到从一副52张牌中生成可能的牌需要几秒钟<em class="ks"/>——对于快节奏的扑克游戏来说，这并不理想。</p><p id="8607" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">所有这些都揭示了当考虑递归解决你在工程生涯中面临的问题时，仔细规划和研究的重要性。在尝试递归解决方案之前，考虑你需要的速度和你的应用程序的规模——尽管递归经常是笨拙和不切实际的，但它偶尔也是天赐之物！</p></div></div>    
</body>
</html>