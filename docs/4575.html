<html>
<head>
<title>AODV Routing Protocol Network Simulation</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">AODV 路由协议网络仿真</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/aodv-routing-protocol-network-simulation-53f3a23918aa?source=collection_archive---------5-----------------------#2021-07-27">https://medium.com/nerd-for-tech/aodv-routing-protocol-network-simulation-53f3a23918aa?source=collection_archive---------5-----------------------#2021-07-27</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="b9d5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> Ad-hoc 按需距离矢量路由协议</strong>用于移动或无线 Ad-hoc 网络(<strong class="ih hj"> MANETs </strong>或<strong class="ih hj"> WANETs </strong>)。ad-hoc 网络是由两个或更多节点构建的临时分布式网络，用于传输数据包，而不需要典型的基础设施，如路由器和接入点。自组织网络中的节点遵循<strong class="ih hj">对等网络(P2P) </strong>。<strong class="ih hj"> AODV </strong>协议是由<strong class="ih hj">诺基亚研究中心</strong>、<strong class="ih hj">加州大学</strong>和<strong class="ih hj">辛辛那提大学</strong>联合开发的。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es jd"><img src="../Images/3569dbf0f25a6d472d015db2542e1381.png" data-original-src="https://miro.medium.com/v2/resize:fit:1230/format:webp/1*Ov61ZrypqrTffvQH3YEquw.png"/></div><figcaption class="jl jm et er es jn jo bd b be z dx translated">我做的^u^</figcaption></figure><p id="b005" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">可以用来模拟网络协议的模拟器有<strong class="ih hj"> NS2 </strong>，<strong class="ih hj"> NS3 </strong>，<strong class="ih hj"> OMNeT++ </strong>，<strong class="ih hj"> NetSim </strong>等多种。这里我用的是<strong class="ih hj"> NS2 </strong>，一个开源的事件驱动模拟器。<strong class="ih hj"> NS2 是用 C++和 Otcl </strong>写的，<strong class="ih hj">模拟还得用 tcl 脚本</strong>写。NS2 是一个非常老的模拟器，开始于 1995 年，是 NS-1 的修订版。虽然我用的是 2011 年发布的 Ubuntu 20.04.1 的 2.35 版本，而且运行得很好，所以不用担心:)</p><p id="a9c8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> NS2 </strong>执行<strong class="ih hj"> TCL </strong>脚本，生成<strong class="ih hj">跟踪文件</strong>和<strong class="ih hj">网络动画文件</strong>。跟踪文件用于分析模拟，如吞吐量、能耗。<strong class="ih hj">网络动画文件</strong>由<strong class="ih hj"> Nam(版本 1.15) </strong>执行，它将模拟制作成动画。</p><p id="a051" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">节点<strong class="ih hj">使用 AODV </strong>定义的<strong class="ih hj">消息发现路由</strong>，分别是<strong class="ih hj">路由请求- RREQ </strong>、<strong class="ih hj">路由回复- RREP </strong>、<strong class="ih hj">路由错误- RERR </strong>。发起节点向其所有邻居广播<strong class="ih hj"> RREQ </strong>消息，拥有到目的节点的路由的节点沿反向路由向发起节点广播<strong class="ih hj"> RREP </strong>消息。如果到发起节点的相邻节点没有到目的地的路由，则它依次广播<strong class="ih hj"> RREQ </strong>消息，保持到发起节点的反向路由。如果一个节点失去了与它的下一跳节点目的地的连接，它向所有接收到<strong class="ih hj"> RREP </strong>消息的节点广播<strong class="ih hj"> RERR </strong>消息。</p><h2 id="de05" class="jp jq hi bd jr js jt ju jv jw jx jy jz iq ka kb kc iu kd ke kf iy kg kh ki kj bi translated">由 AODV 维护的路由表条目</h2><ul class=""><li id="d4ae" class="kk kl hi ih b ii km im kn iq ko iu kp iy kq jc kr ks kt ku bi translated">目标 IP 地址</li><li id="4992" class="kk kl hi ih b ii kv im kw iq kx iu ky iy kz jc kr ks kt ku bi translated">目标序列号</li><li id="84f7" class="kk kl hi ih b ii kv im kw iq kx iu ky iy kz jc kr ks kt ku bi translated">有效的目的地序号标志</li><li id="2270" class="kk kl hi ih b ii kv im kw iq kx iu ky iy kz jc kr ks kt ku bi translated">其他状态和路由标志</li><li id="5f34" class="kk kl hi ih b ii kv im kw iq kx iu ky iy kz jc kr ks kt ku bi translated">网络接口</li><li id="51c9" class="kk kl hi ih b ii kv im kw iq kx iu ky iy kz jc kr ks kt ku bi translated">跳跃总数</li><li id="24fc" class="kk kl hi ih b ii kv im kw iq kx iu ky iy kz jc kr ks kt ku bi translated">下一跳</li><li id="7b7d" class="kk kl hi ih b ii kv im kw iq kx iu ky iy kz jc kr ks kt ku bi translated">前体列表</li><li id="bbe3" class="kk kl hi ih b ii kv im kw iq kx iu ky iy kz jc kr ks kt ku bi translated">一生</li></ul><h2 id="a701" class="jp jq hi bd jr js jt ju jv jw jx jy jz iq ka kb kc iu kd ke kf iy kg kh ki kj bi translated">实现模拟</h2><p id="9c1b" class="pw-post-body-paragraph if ig hi ih b ii km ik il im kn io ip iq la is it iu lb iw ix iy lc ja jb jc hb bi translated">首先设置一些变量，这些变量稍后将用于节点配置。这里是一个非数字索引的数组。<strong class="ih hj"> val(停止)</strong>是模拟的结束时间。<strong class="ih hj"> val(x) </strong>，<strong class="ih hj"> val(y) </strong>将用于定义地形。<strong class="ih hj"> val(nn) </strong>表示使用的节点数。<strong class="ih hj"> val(rp) </strong>包含路由协议的类型，在本例中是<strong class="ih hj"> AODV </strong>。</p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="ld le l"/></div></figure><p id="b1f1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> val(ifq) </strong>是优先考虑路由协议数据包的接口队列，而<strong class="ih hj"> val(ifqlen) </strong>是队列的最大长度。<strong class="ih hj"> val(ant) </strong>将天线类型定义为全向，这意味着它可以在所有方向上接收和发射。<strong class="ih hj"> var(prop) </strong>被设置为 TwoRayGround，这是无线电传播期间的衰减模型(1/r⁴).<strong class="ih hj"> val(netif) </strong>包含网络接口的值。网络接口层充当硬件接口，由移动节点用来访问信道，并且它被设置为<strong class="ih hj"> Phy/WirelessPhy </strong>。</p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="ld le l"/></div></figure><p id="642f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">第 1 行生成<strong class="ih hj"> NS </strong>模拟器对象实例，并将其分配给变量<strong class="ih hj"> ns </strong>。第 2 行创建一个空的跟踪文件<strong class="ih hj"> ns_aodv.tr </strong>，并将其赋给变量<strong class="ih hj"> tf </strong>。<strong class="ih hj"> trace-all </strong>命令以特定格式跟踪所有事件。第 6 行创建<strong class="ih hj"> NAM </strong>可视化文件<strong class="ih hj"> ns_aodv.nam </strong>并将其分配给<strong class="ih hj"> nf </strong>。第 7 行告诉模拟器以<strong class="ih hj"> NAM </strong>格式记录轨迹。第 10 行将地形设置为平面网格。<strong class="ih hj"> god 对象</strong>存储从一个节点到另一个节点所需的最短跳数表。</p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="ld le l"/></div></figure><p id="ae5d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">上面用我们在开始时定义的变量配置了节点。其他一些参数如<strong class="ih hj"> agentTrace </strong>在我们的例子中跟踪 UDP，<strong class="ih hj"> routerTrace </strong>跟踪路由中涉及的数据包，<strong class="ih hj"> macTrace </strong>跟踪 MAC 协议数据包，<strong class="ih hj"> movementTrace </strong>跟踪节点的运动。</p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="ld le l"/></div></figure><p id="641b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这里，第一个循环分配节点的初始位置，第二个循环提供拓扑内节点的<strong class="ih hj">随机移动</strong>。</p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="ld le l"/></div></figure><p id="91a2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在上面的代码中，我们正在创建一个<strong class="ih hj"> UDP </strong>的对象，并将其附加到我们的<strong class="ih hj">节点 5 号</strong>，这将是<strong class="ih hj">发起节点</strong>。此外，创建一个<strong class="ih hj">接收器</strong>并将其附加到<strong class="ih hj">目的节点</strong>、<strong class="ih hj">2 号节点</strong>。<strong class="ih hj"> CBR(恒定比特率)</strong>是我们的流量源，它将生成通过<strong class="ih hj"> UDP </strong>发送的数据包。</p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="ld le l"/></div></figure><p id="29dc" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">第一个“for 循环”使用 nam 的初始位置<strong class="ih hj">初始化所有节点，第二个“for 循环”在模拟结束时重置所有节点。</strong></p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="ld le l"/></div></figure><p id="8318" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">使用关键字<strong class="ih hj"> global </strong>是因为我们使用了在<strong class="ih hj"> proc finish </strong>(过程)范围之外声明的变量。<strong class="ih hj"> flush-trace </strong>命令将所有轨迹保存到各自的文件中。模拟开始于<strong class="ih hj"> $ns 运行</strong>。</p><h1 id="0dc2" class="lf jq hi bd jr lg lh li jv lj lk ll jz lm ln lo kc lp lq lr kf ls lt lu ki lv bi translated">模拟</h1><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="lx ly di lz bf ma"><div class="er es lw"><img src="../Images/b446a069dcc1596ec88402b59efb6bbe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*qMEMQ5yh96MOIH0upkwxlw.gif"/></div></div></figure><h2 id="e1ce" class="jp jq hi bd jr js jt ju jv jw jx jy jz iq ka kb kc iu kd ke kf iy kg kh ki kj bi translated">在 GitHub 上获得完整的代码、跟踪文件分析、模拟视频<a class="ae mb" href="https://github.com/abhinav-bhardwaj/AODV-Routing-Network-Simulation" rel="noopener ugc nofollow" target="_blank"/></h2><div class="mc md ez fb me mf"><a href="https://github.com/abhinav-bhardwaj/AODV-Routing-Network-Simulation" rel="noopener  ugc nofollow" target="_blank"><div class="mg ab dw"><div class="mh ab mi cl cj mj"><h2 class="bd hj fi z dy mk ea eb ml ed ef hh bi translated">GitHub-abhinav-bhardwaj/AODV-路由-网络-模拟:自组织按需距离矢量路由…</h2><div class="mm l"><h3 class="bd b fi z dy mk ea eb ml ed ef dx translated">Ad-hoc 按需距离矢量路由协议 NS2 2.35(网络模拟器 2 版本 2.35) Nam 1.15(网络…</h3></div><div class="mn l"><p class="bd b fp z dy mk ea eb ml ed ef dx translated">github.com</p></div></div><div class="mo l"><div class="mp l mq mr ms mo mt jj mf"/></div></div></a></div><h2 id="a20b" class="jp jq hi bd jr js jt ju jv jw jx jy jz iq ka kb kc iu kd ke kf iy kg kh ki kj bi translated"><a class="ae mb" href="https://www.linkedin.com/in/abhinav-dubey-007001/" rel="noopener ugc nofollow" target="_blank">在 LinkedIn 上与我联系— Abhinav Dubey </a></h2></div></div>    
</body>
</html>