<html>
<head>
<title>Raw Sockets with Python: Sniffing and network packet injections.</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python 的原始套接字:嗅探和网络数据包注入。</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/raw-sockets-with-python-sniffing-and-network-packet-injections-486043061bd5?source=collection_archive---------0-----------------------#2019-09-02">https://medium.com/nerd-for-tech/raw-sockets-with-python-sniffing-and-network-packet-injections-486043061bd5?source=collection_archive---------0-----------------------#2019-09-02</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="2159" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">该元素提供了一种绕过数据包的整个网络堆栈遍历并将其直接传递给应用程序的方法。有多种方法可以创建原始套接字。这次我们将使用<code class="du jd je jf jg b">PF_PACKET</code>接口。</p><p id="9bf4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在常规的套接字编程中，我们需要创建一个<strong class="ih hj"> TCP / UDP 服务器</strong>，在这里网卡将把数据包向上传递到 IP 栈(IP 处理)，这些数据包将在客户端应用程序中被接收。</p><p id="fe74" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">简单来说，通过使用<strong class="ih hj">原始套接字</strong>，我们可以为网络堆栈生成一个快速的<strong class="ih hj">快捷方式</strong>。</p><p id="04eb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">做一些内存闪回:OSI 模型标准化了计算机系统远程通信的通信功能，而不考虑其底层内部结构。</p><p id="6387" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">OSI 模型包括:(按执行的角色分类)</p><ul class=""><li id="5be8" class="jh ji hi ih b ii ij im in iq jj iu jk iy jl jc jm jn jo jp bi translated"><em class="jq">用户应用或应用层</em></li><li id="dd7b" class="jh ji hi ih b ii jr im js iq jt iu ju iy jv jc jm jn jo jp bi translated"><em class="jq">插座接口</em></li><li id="079d" class="jh ji hi ih b ii jr im js iq jt iu ju iy jv jc jm jn jo jp bi translated"><em class="jq"> TCP/UDP 处理</em></li><li id="3602" class="jh ji hi ih b ii jr im js iq jt iu ju iy jv jc jm jn jo jp bi translated"><em class="jq"> IP 处理</em></li><li id="6ee3" class="jh ji hi ih b ii jr im js iq jt iu ju iy jv jc jm jn jo jp bi translated"><em class="jq">协议族处理例程(LPF) </em> =从原始套接字到应用</li><li id="b0f0" class="jh ji hi ih b ii jr im js iq jt iu ju iy jv jc jm jn jo jp bi translated"><em class="jq">网卡驱动</em></li></ul><p id="7959" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">它是一个软件接口，用于在 OSI(设备驱动器)的第 2 层发送/接收数据包。所有接收到的数据包都将包含所有报头和数据。所有发送的数据包都将由内核不加修改地传输到介质。支持使用 Berkley 包过滤(BPF)进行过滤</p><h1 id="910f" class="jw jx hi bd jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt bi translated">了解数据包报头</h1><p id="a723" class="pw-post-body-paragraph if ig hi ih b ii ku ik il im kv io ip iq kw is it iu kx iw ix iy ky ja jb jc hb bi translated">为了使这个解释简单一点，我们必须确保以太网封装了一切。(我觉得这个不是 100%准确)</p><p id="5bed" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">以太网(封装)-&gt; IP -&gt; TCP -&gt;应用程序(分层方法)</p><p id="8877" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">前 14 个字节代表<strong class="ih hj">以太网头</strong>，具体是<strong class="ih hj">以太网包数据</strong></p><p id="8ea2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">0–6 =<strong class="ih hj">ethd host</strong>(目的 MAC 地址)</p><p id="969c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">6–11 =<strong class="ih hj">eths host</strong>(源 MAC 地址)</p><p id="3c09" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">12–14 =<strong class="ih hj">EthType</strong>(正在使用的 IP 或其他内部协议)</p><p id="537f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">接下来的字节进入 IP 头，然后是 TCP，然后是应用程序</p><p id="14a3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">0–3 =版本 4–7 = IHL 8–15 =服务类型 16–31 =总长度</p><p id="6b8f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">以及其他信息，如标识、生存时间、协议、标志、片段偏移量、报头校验和、源地址、目的地址、选项、填充等</p><p id="a467" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">总共大约代表 20 个字节</p><p id="6b45" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">解析数据的顺序与发送和接收的顺序相同。</p><h1 id="6d5d" class="jw jx hi bd jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt bi translated">将二进制数据提取到变量中</h1><p id="00f0" class="pw-post-body-paragraph if ig hi ih b ii ku ik il im kv io ip iq kw is it iu kx iw ix iy ky ja jb jc hb bi translated">当数据通过网络发送时，它实际上被转换成网络字节顺序:大端格式</p><p id="6b51" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">当我们发送数据时，我们必须确保格式是 NBO (Big Endian)，这是解压缩并在应用程序中使用的，我们需要确保使用<code class="du jd je jf jg b">struct.unpack()</code>进行相应的数据转换，最后一个返回元组格式的头信息，您将处理该信息以检索字符串可理解的值。</p><p id="903f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">对于<code class="du jd je jf jg b">rawSniffer.py</code>(应该作为根用户运行)，如果你有适当的权限或根用户，你可以使用原始套接字</p><p id="13ee" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">两个副主题:<em class="jq">理解数据包报头</em>和<em class="jq">将二进制数据提取到变量中</em>代表原始套接字上的嗅探角色。</p><h1 id="fbff" class="jw jx hi bd jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt bi translated">使用原始套接字的包注入</h1><p id="4754" class="pw-post-body-paragraph if ig hi ih b ii ku ik il im kv io ip iq kw is it iu kx iw ix iy ky ja jb jc hb bi translated">这提供了将原始数据包注入网络的能力，显然，您可以估计来自网络的响应。</p><p id="28a5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">以下代码旨在用于独立测试，事实上，原始套接字不太容易移植，使用原始套接字构造包有点困难。这是完全不可伸缩的。</p><p id="cbc4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为了便于追踪，您可以使用<code class="du jd je jf jg b">tcpdump</code>或任何其他工具进行流量分析，如 Wireshark。</p><p id="d85e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><code class="du jd je jf jg b">tcpdump -i eth0 -vv -XX</code></p><p id="f8af" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">您可以在我的 gist 页面上查看用 Python 编写的原始嗅探器和原始数据包注入的代码示例:</p><p id="c003" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">使用 Python 的原始套接字:嗅探和网络数据包注入:<a class="ae kz" href="http://bit.ly/32i793l" rel="noopener ugc nofollow" target="_blank">http://bit.ly/32i793l</a></p></div></div>    
</body>
</html>