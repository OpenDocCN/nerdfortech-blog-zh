<html>
<head>
<title>Concept of serialization</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">序列化的概念</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/concept-of-serialization-2b35c16f64d?source=collection_archive---------1-----------------------#2020-05-24">https://medium.com/nerd-for-tech/concept-of-serialization-2b35c16f64d?source=collection_archive---------1-----------------------#2020-05-24</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="bbb4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">计算机科学新手？你并不孤单。这是给你的。</p><p id="ae7f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">任何计算机程序的真正本质都在于我们组织数据(数据结构)的能力有多强，操纵数据(算法)的能力有多强。这就是为什么大多数公司会测试应聘者在数据结构和算法方面的技能。数据结构在决定算法的整体效率方面起着关键作用。例如，一个数组插入的线性时间复杂度，而栈或队列它只有常数时间。</p></div><div class="ab cl jd je gp jf" role="separator"><span class="jg bw bk jh ji jj"/><span class="jg bw bk jh ji jj"/><span class="jg bw bk jh ji"/></div><div class="hb hc hd he hf"><p id="18b3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">例如，在一段代码中，你要在一个数据结构上做很多操作，比如一个数组或者一个hashmap。完成后，如果您想保存数据结构的内容以便进一步分析数据，该怎么办呢？想从朋友的电脑上读取数据结构怎么办？这里出现了序列化的概念。简单来说，<strong class="ih hj">序列化</strong>是一种将复杂数据结构以可读格式保存到磁盘上的方法。相反，<strong class="ih hj">反序列化</strong>只是读回之前保存的数据。</p><p id="324f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">序列化的概念是各种领域中非常常见的方法。你可能已经听说过类似<code class="du jk jl jm jn b">JSON, XML, YAML, Protobuf</code>等技术。这些都是简单而强大的技术，在不同的地方使用。Google的Protobuf是一种更加通用和独立于语言的技术。毕竟，最流行的JSON是NoSQL数据库程序的基础。</p><p id="7408" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">下面是一个简单的例子。</strong></p><pre class="jp jq jr js fd jt jn ju jv aw jw bi"><span id="c05e" class="jx jy hi jn b fi jz ka l kb kc">Array: <br/>A = [ 1, 2, 3] <br/>B = [ 4, 5, 6] </span></pre><p id="9d4d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为了在JSON中序列化这两个数组，我们可以做的是使用数组的名称作为“key ”,这个键的值就是数组的值。我们可以将它保存在一个文件中，以便将来阅读。</p><p id="db12" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><code class="du jk jl jm jn b">JSON: { "A" : [ 1, 2, 3], "B" : [ 4, 5, 6] }</code></p><p id="cca5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">序列化数据的真正优势在于它的可移植性。先前保存的JSON文件可以传输到任何地方，最终用户可以简单地反序列化它。在JSON反序列化期间，任何内容<code class="du jk jl jm jn b">[]</code>都作为数组元素读取，而<code class="du jk jl jm jn b">" "</code>作为变量的键。这种序列化数据可以是独立于语言的。您可以序列化Python代码中的数据，并从Java代码中读取JSON文件。上面提到的一些技术旨在消除语言障碍。</p></div><div class="ab cl jd je gp jf" role="separator"><span class="jg bw bk jh ji jj"/><span class="jg bw bk jh ji jj"/><span class="jg bw bk jh ji"/></div><div class="hb hc hd he hf"><p id="399f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">我的Boost C++序列化工作:</strong></p><p id="165c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">当我从事序列化工作时，我是软件工程的新手。所以，我费了很大劲才把代码编译好。我所面临的一些问题包含在这篇文章的底部。</p><p id="c9da" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在探索了序列化的一些概念之后，我决定使用Boost库。Boost的文档并不像我在Python上做了大量工作后所期望的那样用户友好。小心点！</p></div><div class="ab cl jd je gp jf" role="separator"><span class="jg bw bk jh ji jj"/><span class="jg bw bk jh ji jj"/><span class="jg bw bk jh ji"/></div><div class="hb hc hd he hf"><p id="41ed" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">与我上面解释的JSON格式不同，我将用C++代码将序列化数据写入一个文本文件。如果您不想要可移植性，并防止用户直接打开文件，那么您也可以序列化为二进制文件。和往常一样，您可以通过写入JSON文件在Python中尝试这个概念，序列化的数据是高度可移植的。</p><p id="5a3f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">无论STL容器(vector、map或unordered_map)是什么，都可以使用重载的<code class="du jk jl jm jn b">&amp;</code>或<code class="du jk jl jm jn b">&lt;&lt; &gt;&gt;</code>操作符来实现序列化和反序列化。就这么简单！换句话说，我们可以称这些操作为“保存&amp;加载”。</p><pre class="jp jq jr js fd jt jn ju jv aw jw bi"><span id="2b3b" class="jx jy hi jn b fi jz ka l kb kc">/* Serialization */<br/>// Create an output archive <br/>std::ofstream ofs( "file.bin" ); <br/>boost::archive::text_oarchive ar(ofs); <br/>// Save the data<br/>ar &amp; serialized;  // where serialized is a map or array</span><span id="ac50" class="jx jy hi jn b fi kd ka l kb kc">/* Deserialization */<br/>// Read the input archive <br/>std::ifstream ifs( "file.bin" ); <br/>boost::archive::text_iarchive ar(ifs); <br/>// Load the data <br/>ar &amp; deserialized;  // where deserialized is a map or array</span></pre><p id="5af0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">使用二进制文件保存和加载，可以通过以下方式完成:</p><pre class="jp jq jr js fd jt jn ju jv aw jw bi"><span id="0e62" class="jx jy hi jn b fi jz ka l kb kc">/* Serialization */<br/>std::string file("file.bin");<br/>std::ofstream ofs(file.c_str(), std::ios::binary);<br/>boost::archive::binary_oarchive ar(ofs);<br/>ar &amp; serialized; </span><span id="9d57" class="jx jy hi jn b fi kd ka l kb kc">/* Deserialization */ <br/>std::string file("file.bin");<br/>std::ifstream ifs(gold_file.c_str(), std::ios::binary);<br/>boost::archive::binary_iarchive ar(ifs);<br/>ar &amp; deserialized;</span></pre><p id="7b75" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">实际问题:<br/> </strong>这听起来可能很天真，但老实说，我确实面临过一些编译错误。不过，有一种方法很容易解决。</p><ul class=""><li id="ffb9" class="ke kf hi ih b ii ij im in iq kg iu kh iy ki jc kj kk kl km bi translated">问题#1: <br/>错误的头包括。在我的案例中，我使用了地图。我只需要一个头球<code class="du jk jl jm jn b">map.hpp</code>。但是我确实有很多其他的头文件，比如<code class="du jk jl jm jn b">unordered_map.hpp</code>、<code class="du jk jl jm jn b">map.hpp</code>、<code class="du jk jl jm jn b">boost_unordered_map.hpp</code>、<code class="du jk jl jm jn b">set.hpp</code>以及其他几个文件。所以，编译器搞混了，在错误的地方寻找定义。<br/>幸运的是，抛出错误的boost头文件中有一条注释，写着remove other includes。</li><li id="0acd" class="ke kf hi ih b ii kn im ko iq kp iu kq iy kr jc kj kk kl km bi translated">问题2: <br/>我没有以正确的方式进行序列化。我的意思是，如果我有一个存储在变量中的映射，我所要做的就是序列化<code class="du jk jl jm jn b">ar &amp; var;</code>。但是我写了一个for循环，一个元素一个元素的迭代和序列化(<code class="du jk jl jm jn b">it-&gt;first</code>和<code class="du jk jl jm jn b">it-&gt;second</code>)，弄得太复杂了。确实有效。但是问题出现在反序列化期间。我如何迭代来逐元素反序列化？这些boost模板通过反向读取文件来完成这项工作。所以<code class="du jk jl jm jn b">&amp;</code>操作符就是我们所需要的。</li></ul><p id="2a52" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">经过一段时间的努力和学习，我终于成功了。我还编写了一个小的测试用例来读取现有的二进制文件，并检查它是否与当前文件匹配。</p></div></div>    
</body>
</html>