<html>
<head>
<title>Strobogrammatic Number II — Day 91(Python)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">频闪信号编号II —第91天(Python)</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/strobogrammatic-number-ii-day-91-python-900e1ec91acc?source=collection_archive---------9-----------------------#2021-03-09">https://medium.com/nerd-for-tech/strobogrammatic-number-ii-day-91-python-900e1ec91acc?source=collection_archive---------9-----------------------#2021-03-09</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/b0a6996b156711e5891d869a6965d121.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*YaVMzCQjW3cpNm8f"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">照片由<a class="ae iu" href="https://unsplash.com/@soologue?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">金智秀</a>在<a class="ae iu" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="2ac6" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">今天的问题是leetcode上一个中等标签的问题。让我们看看问题陈述。</p></div><div class="ab cl jt ju gp jv" role="separator"><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy"/></div><div class="hb hc hd he hf"><p id="9b2a" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><a class="ae iu" href="https://leetcode.com/problems/strobogrammatic-number-ii/" rel="noopener ugc nofollow" target="_blank"> <strong class="ix hj"> 247 </strong> </a> <strong class="ix hj">。频闪信号编号II </strong></p><p id="0f17" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">给定一个整数<code class="du ka kb kc kd b">n</code>，返回所有长度为<code class="du ka kb kc kd b">n</code>的<strong class="ix hj">频闪信号数</strong>。你可以按<strong class="ix hj">任何顺序</strong>返回答案。</p><p id="54da" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">一个<strong class="ix hj">闪光数字</strong>是一个旋转<code class="du ka kb kc kd b">180</code>度后看起来相同的数字(上下颠倒)。</p><p id="bc6b" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">例1: </p><pre class="ke kf kg kh fd ki kd kj kk aw kl bi"><span id="decf" class="km kn hi kd b fi ko kp l kq kr"><strong class="kd hj">Input:</strong> n = 2<br/><strong class="kd hj">Output:</strong> ["11","69","88","96"]</span></pre><p id="06f4" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">例2: </strong></p><pre class="ke kf kg kh fd ki kd kj kk aw kl bi"><span id="ed82" class="km kn hi kd b fi ko kp l kq kr"><strong class="kd hj">Input:</strong> n = 1<br/><strong class="kd hj">Output:</strong> ["0","1","8"]</span></pre><p id="be02" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">约束:</strong></p><ul class=""><li id="c34c" class="ks kt hi ix b iy iz jc jd jg ku jk kv jo kw js kx ky kz la bi translated"><code class="du ka kb kc kd b">1 &lt;= n &lt;= 14</code></li></ul></div><div class="ab cl jt ju gp jv" role="separator"><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy"/></div><div class="hb hc hd he hf"><p id="86df" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在我们开始解决这个问题之前，让我们先了解一下什么是频闪数字。一个<strong class="ix hj">频闪数字</strong>是一个旋转180度看起来不变的数字。那么<strong class="ix hj">是哪些频闪号码呢？0，1，8是频闪的数字。6和9一起使用时，形成频闪数字。</strong></p><p id="ecdc" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们有“n ”,它是我们形成的数字中的位数，如果它们形成一个频闪数字，就必须进行检查。</p><p id="e3b2" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">解决这个问题的一种方法是创建一个字典，存储每个可以形成频闪数字的数字及其相应的值。</p><pre class="ke kf kg kh fd ki kd kj kk aw kl bi"><span id="a664" class="km kn hi kd b fi ko kp l kq kr">char_list = ["0", "1", "6", "8", "9"]<br/>strobogrammatic_dict = {"0":"0","1":"1","6":"9","8":"8","9":"6"}</span></pre><p id="2d53" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们将使用2根弦；一个保存数字形成另一个保存其可能的旋转数。当位数等于n时，如果形成的数等于一个旋转数中保存的数，我们会将其保存为结果的一部分。</p><pre class="ke kf kg kh fd ki kd kj kk aw kl bi"><span id="7c69" class="km kn hi kd b fi ko kp l kq kr">class StrobogrammaticFinder:<br/>  def findStrobogrammatic(self, n: int) -&gt; List[str]:<br/>      output = []<br/>      char_list = ["0", "1", "6", "8", "9"]<br/>      strobo_dict = {"0":"0","1":"1","6":"9","8":"8","9":"6"}<br/>      def dfs(tmp, st_tmp):<br/>          if len(tmp) == n:<br/>             if tmp == st_tmp[::-1]:<br/>                if str(int(tmp)) == tmp:<br/>                   output.append(tmp)<br/>             return<br/>          for i in range(len(char_list)):<br/>              dfs(tmp+char_list[i],st_tmp+strobo_dict[char_list[i]])<br/>           <br/>      dfs("","")<br/>      return(output)</span></pre><h1 id="32d4" class="lb kn hi bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">复杂性分析。</h1><p id="65a2" class="pw-post-body-paragraph iv iw hi ix b iy ly ja jb jc lz je jf jg ma ji jj jk mb jm jn jo mc jq jr js hb bi translated"><strong class="ix hj">时间复杂度</strong></p><p id="1f2f" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">对于所有的n位数，我们有5位数可供选择。因此时间复杂性是O(5^N).</p><p id="9760" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">空间复杂度</strong></p><p id="c517" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">因为我们递归地调用dfs函数，并且内部递归调用以堆栈的形式存储。空间复杂性是O(5^N).</p></div><div class="ab cl jt ju gp jv" role="separator"><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy"/></div><div class="hb hc hd he hf"><p id="36df" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">当我们在leetcode上运行这段代码时，我们可能会遇到超时错误。有没有减少通话次数的方法？</p><p id="6a8a" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们必须找到所有n个地方的数字吗？我们可以试着只找到一半吗？如果我们找到刚好到一半的位置，我们可以旋转这个数并将其设置为另一半。或者更好的是，我们从两个极端位置开始向内移动。</p><p id="9313" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">让我们看看如何编码。</p><pre class="ke kf kg kh fd ki kd kj kk aw kl bi"><span id="52f6" class="km kn hi kd b fi ko kp l kq kr">class StrobogrammaticFinder:<br/>  def findStrobogrammatic(self, n: int) -&gt; List[str]:<br/>        output = []<br/>        # Create a dictionary<br/>        strobo_dict = {"0":"0","1":"1","6":"9","8":"8","9":"6"}<br/>        start = 0<br/>        end = n-1<br/>        #Create a list of size n initialised with None<br/>        result = [None]*n<br/>        self.dfs(start, end, result, strobo_dict, output)<br/>        return output<br/>    <br/>  def dfs(self, start, end, result, strobo_dict, output):<br/>        if start &gt; end:<br/>            output.append(''.join(result))<br/>            return<br/>        #For each number in the dictionary<br/>        for each_num in strobo_dict:<br/>            #if it is single digit number<br/>            if start!= end and each_num == '0' and start == 0:<br/>                continue<br/>            # if we have reached the middle<br/>            if start == end and each_num in ('6','9'):<br/>                continue<br/>                <br/>            result[start], result[end] = each_num, strobo_dict[each_num]<br/>            self.dfs(start+1, end-1, result, strobo_dict, output)</span></pre><h1 id="2cd5" class="lb kn hi bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">复杂性分析。</h1><p id="d021" class="pw-post-body-paragraph iv iw hi ix b iy ly ja jb jc lz je jf jg ma ji jj jk mb jm jn jo mc jq jr js hb bi translated"><strong class="ix hj">时间复杂度</strong></p><p id="627e" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">对于所有的n位数，我们有5位数可以选择，但是在上面的代码中，我们从两个极端位置开始向内移动。因此时间复杂性是O(5^(N/2)).</p><p id="afc0" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">空间复杂度</strong></p><p id="9010" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">因为我们递归地调用dfs函数，并且内部递归调用以堆栈的形式存储。空间复杂性是O(5^(N/2)).</p></div></div>    
</body>
</html>