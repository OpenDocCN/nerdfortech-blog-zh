<html>
<head>
<title>C# — Class, Struct, Record, Record Struct</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">C# —类、结构、记录、记录结构</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/c-class-struct-record-record-struct-d3b21c57d9bb?source=collection_archive---------0-----------------------#2022-08-16">https://medium.com/nerd-for-tech/c-class-struct-record-record-struct-d3b21c57d9bb?source=collection_archive---------0-----------------------#2022-08-16</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="e3da" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我想是时候花时间去了解他们了。这是我的尝试。</p><p id="2983" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我不打算详细介绍类，因为它们是最常用的，本文主要解释什么时候使用结构就足够了，以及记录的用途。</p><h1 id="8a57" class="jd je hi bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">1-概述如何定义它们，无示例。</h1><p id="b587" class="pw-post-body-paragraph if ig hi ih b ii kb ik il im kc io ip iq kd is it iu ke iw ix iy kf ja jb jc hb bi translated">从 MS 文档中。</p><p id="a135" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">记录:</strong>一个<strong class="ih hj">类或结构</strong>，它为使用<strong class="ih hj">数据模型</strong>提供了<strong class="ih hj">特殊语法</strong> <strong class="ih hj">和行为</strong>。</p><p id="8d32" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">类:</strong>一个构造，通过将其他类型、方法和事件的变量组合在一起，使您能够创建自己的自定义类型。</p><p id="6b6c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> Struct </strong>:一种值类型，通常用于封装相关变量的<strong class="ih hj">小组</strong>。</p><p id="1c9e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> Record Struct </strong>:与 Record 类似的定义，但是当您想要指定它将用于一个 Struct，而不是一个类。</p><p id="2e25" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这很好，但还不够。在引入记录之前，我们有类和结构。我们先去那些吧。</p><h1 id="ce96" class="jd je hi bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">2 —结构(struct)与类(class)。</h1><p id="af31" class="pw-post-body-paragraph if ig hi ih b ii kb ik il im kc io ip iq kd is it iu ke iw ix iy kf ja jb jc hb bi translated">让我们看看这里的一个结构，它看起来很像一个类:</p><figure class="kg kh ki kj fd kk er es paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="er es et"><img src="../Images/bd6204dba33254f72072b2cc54887269.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bPlDvxxKKqddAEd1-UMy_g.png"/></div></div></figure><p id="e233" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">从 MS 文档中:</p><p id="a799" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">结构类型有<em class="kr">值语义</em>。类类型有<em class="kr">引用语义</em> </strong>。这听起来很重要:-)。</p><figure class="kg kh ki kj fd kk er es paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="er es ks"><img src="../Images/282490dd7e36a25939a960cd86304401.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sA6N_SQ28IvEm7o1Szj1cQ.png"/></div></div></figure><h1 id="ae73" class="jd je hi bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">2 —关于结构的更多信息</h1><p id="cfa6" class="pw-post-body-paragraph if ig hi ih b ii kb ik il im kc io ip iq kd is it iu ke iw ix iy kf ja jb jc hb bi translated">同样来自 MS docs:通常，您使用结构类型来设计以数据为中心的小型类型，这些类型提供很少或不提供行为。因为结构类型具有值语义，我们建议您定义<em class="kr">不可变的</em>结构类型。</p><p id="b63d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为了使上面的结构不可变，我们可以对它使用 readonly(c# 7.3 及更高版本)。</p><pre class="kg kh ki kj fd kt ku kv kw aw kx bi"><span id="db07" class="ky je hi ku b fi kz la l lb lc">public <strong class="ku hj">readonly </strong>struct Name</span></pre><p id="fe8f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果我们这样做，我们需要删除设置；从 F 和 L 属性中，它可以编译。一旦我们这样做了，我们就可以在构造函数中为结构的只读字段/属性设置值，但仅此而已。这意味着，即使是结构的成员也不能更改这些字段/属性。</p><p id="a21c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">注意:如果我们有一个引用类型，比如一个列表，它将是不可变的，因为你不能给它赋值，但是它可以改变自己，因为列表可以添加和删除元素。</p><p id="17c6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们的结构现在可以是:</p><pre class="kg kh ki kj fd kt ku kv kw aw kx bi"><span id="65f0" class="ky je hi ku b fi kz la l lb lc">public <strong class="ku hj">readonly </strong>struct Name<br/>{<br/>     public string F { get;  }<br/>     public string L { get;  }<br/>     <strong class="ku hj">public List&lt;string&gt; SomeList { get; }</strong></span><span id="5e72" class="ky je hi ku b fi ld la l lb lc">     public Name(string f, string l)<br/>     {<br/>          F = f;<br/>          L = l;<br/>          SomeList = new List&lt;string&gt;();<br/>          SomeList.Add("how");<br/>          SomeList.Add("are");<br/>          SomeList.Add("you");<br/>          SomeList.Add("?");<br/>     }<br/>     public void ChangeList()<br/>     {<br/>          <strong class="ku hj">this.SomeList.Add("??");</strong><br/>     }<br/>     public override string ToString() =&gt; $"{F} {L}";<br/>}</span></pre><p id="8d85" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在结构上调用 ChangeList 方法将起作用。？将被添加。然而，试图用同样的方法给 SomeList 分配一个新的列表会产生编译错误。</p><p id="35a8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">从 C#9 开始，属性也可以获得一个<strong class="ih hj"> init 访问器</strong>。仅 init 设置器仅在对象构造期间为属性或索引器元素赋值。这增强了不变性，因此一旦对象被初始化，就不能再被更改。</p><p id="0369" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在上面的结构中，我们可以</p><pre class="kg kh ki kj fd kt ku kv kw aw kx bi"><span id="1571" class="ky je hi ku b fi kz la l lb lc">public string? F { get; <strong class="ku hj">init</strong>; }<br/>public string? L { get; <strong class="ku hj">init</strong>; }<br/>//the constructor has not changed</span><span id="3a45" class="ky je hi ku b fi ld la l lb lc">//then create it like<br/>Name theN = new Name { F<strong class="ku hj">= </strong>"Michael", L<strong class="ku hj">=</strong> "Jackson"};</span></pre><p id="d9ed" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">从 C#10 开始，你也可以拥有一个结构，并创建它的副本，只改变一些字段。举个例子更简单。使用前面的结构，您可以这样创建 3 个实例:</p><pre class="kg kh ki kj fd kt ku kv kw aw kx bi"><span id="97a7" class="ky je hi ku b fi kz la l lb lc">Name name1 = new Name { F= "Michael", L= "Jackson"};<br/>Name name2 = name1 <strong class="ku hj">with</strong> { L = "Jordan" };<br/>Name name3 = name1 <strong class="ku hj">with </strong>{ L = "Knight" };</span><span id="2d2a" class="ky je hi ku b fi ld la l lb lc">Console.WriteLine(name1);<br/>Console.WriteLine(name2);<br/>Console.WriteLine(name3);</span><span id="cce3" class="ky je hi ku b fi ld la l lb lc">Michael Jackson<br/>Michael Jordan<br/>Michael Knight</span></pre><h1 id="8646" class="jd je hi bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">3 —关于结构和类的更多信息。</h1><p id="5b41" class="pw-post-body-paragraph if ig hi ih b ii kb ik il im kc io ip iq kd is it iu ke iw ix iy kf ja jb jc hb bi translated">如前所述，结构是值类型，类是引用类型。除此之外:</p><p id="86c6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">结构类型不能从其他类或结构类型继承，也不能是类的基。但是，结构类型可以实现接口。</p><p id="eb54" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">不能在结构类型中声明终结器。</p><p id="77bd" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在 C# 11 之前，结构类型的构造函数必须初始化该类型的所有实例字段。</p><p id="225e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在 C# 10 之前，你不能声明一个无参数的构造函数。</p><p id="2d48" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在 C# 10 之前，不能在声明时初始化实例字段或属性。</p><p id="fc94" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">结构通过值传递，尽管您可以使用 ref 来指示它应该通过引用传递。</p><p id="ec2c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">从 7.2 开始，您还可以用 ref 关键字将结构声明为引用类型，但是它们的局限性超出了本文的范围。</p><h1 id="abef" class="jd je hi bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">4 —记录与类和结构</h1><p id="c385" class="pw-post-body-paragraph if ig hi ih b ii kb ik il im kc io ip iq kd is it iu ke iw ix iy kf ja jb jc hb bi translated">记录给了类和结构一点额外的东西。如果你打算在一个类中使用它们，就用 record 代替 class，如果你打算在结构中使用它们，就用“record struct”。也可以做“记录类”但没必要。</p><p id="f006" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">您可以使用位置参数来创建和实例化具有<strong class="ih hj">不可变</strong>属性的类型。</p><pre class="kg kh ki kj fd kt ku kv kw aw kx bi"><span id="9324" class="ky je hi ku b fi kz la l lb lc">public record Name( string first, string second );</span><span id="c2e1" class="ky je hi ku b fi ld la l lb lc">//create with<br/>Name name = new Name("Michael", "Jackson");</span><span id="cb45" class="ky je hi ku b fi ld la l lb lc">Console.WriteLine(name); //Name { first = Michael, second = Jackson }</span></pre><p id="285f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在类中使用引用相等的相同方法和操作符(如<a class="ae le" href="https://docs.microsoft.com/en-us/dotnet/api/system.object.equals#system-object-equals(system-object)" rel="noopener ugc nofollow" target="_blank">O</a>objects。Equals(Object)和==)，表示记录中的<a class="ae le" href="https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/builtin-types/record#value-equality" rel="noopener ugc nofollow" target="_blank"> v </a>值相等。</p><pre class="kg kh ki kj fd kt ku kv kw aw kx bi"><span id="8486" class="ky je hi ku b fi kz la l lb lc">public <strong class="ku hj">record </strong>RecordName( string first, string second );</span><span id="ad48" class="ky je hi ku b fi ld la l lb lc">public <strong class="ku hj">class </strong>ClassName<br/>{<br/>   public string First { get; set; }<br/>   public string Last { get; set; }<br/>   public ClassName(string first, string last)<br/>   {<br/>      this.First = first;<br/>      this.Last = last;<br/>   }<br/>}<br/>...<br/>RecordName recName1 = new RecordName("Michael", "Jackson");<br/>RecordName recName2 = new RecordName("Michael", "Jackson");<br/>ClassName className1 = new ClassName("Michael", "Jackson");<br/>ClassName className2 = new ClassName("Michael", "Jackson");<br/>Console.WriteLine(recName1.Equals(recName2));//<strong class="ku hj">True</strong><br/>Console.WriteLine(className1.Equals(className2));//<strong class="ku hj">False</strong></span></pre><p id="1a3f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">您可以将<strong class="ih hj">和表达式</strong>一起用于记录(就像上面显示的以 c# 10 开始的结构)</p><p id="8628" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">记录的<code class="du lf lg lh ku b">ToString</code>方法创建一个格式化的字符串，显示对象的类型名及其所有公共属性的名称和值。</p><p id="7b69" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">一个记录可以从另一个记录继承。记录不能从类继承，类也不能从记录继承(对于记录类类型，而不是记录结构类型)。</p><pre class="kg kh ki kj fd kt ku kv kw aw kx bi"><span id="d61f" class="ky je hi ku b fi kz la l lb lc">public <strong class="ku hj">abstract record</strong> RecordName<br/>{<br/>   public string <strong class="ku hj">First </strong>{ get; set; }<br/>   public string <strong class="ku hj">Last </strong>{ get; set; }<br/>}<br/>public record <strong class="ku hj">RecordNameDer : RecordName</strong><br/>{<br/>   public string <strong class="ku hj">Middle </strong>{ get; set; }<br/>}<br/>...<br/>RecordNameDer name = new RecordNameDer  { <strong class="ku hj">First </strong>= "Michael", <strong class="ku hj">Last </strong>= "Jackson", <strong class="ku hj">Middle </strong>= "Joseph" };</span><span id="6fea" class="ky je hi ku b fi ld la l lb lc">//or could have also done<br/>public abstract<strong class="ku hj"> record RecordName</strong>(string First,string Last);<br/>public <strong class="ku hj">record RecordNameDer</strong>(string First, string Last, string Middle) <strong class="ku hj">: RecordName</strong>(First, Last);<br/>...<br/>RecordNameDer name = new RecordNameDer ("Michael", "Jackson","Joseph" );</span></pre><p id="b9eb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">记录结构与结构的不同之处在于编译器综合了相等的方法和<code class="du lf lg lh ku b">ToString</code>。编译器为位置记录结构合成了一个<code class="du lf lg lh ku b">Deconstruct</code>方法。</p><p id="0dd1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">要使两个记录变量相等，<strong class="ih hj">运行时类型必须相等</strong>。这意味着，如果我们有 2 个不同类型的记录，它们来自同一个库，并且有相同的字段和值，它们仍然是不同的，因为它们的类型不一样。</p><h1 id="6dd4" class="jd je hi bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">5 —那么什么时候使用记录呢？</h1><p id="7a83" class="pw-post-body-paragraph if ig hi ih b ii kb ik il im kc io ip iq kd is it iu ke iw ix iy kf ja jb jc hb bi translated">当您的数据不应该更改时，记录很有用。记录可以从其他记录中继承，所以当你不需要一个完整的类来满足你的需求时，拥有这样的记录是很好的。</p><p id="8b42" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">当您希望基于值对实例进行比较时，记录也很方便。</p><p id="dd0d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">至于结构和类，结构更受限制，所以当你需要继承和引用比较时，你可能需要类。</p><p id="b90a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">到目前为止就是这样。希望能再清楚一点。</p></div></div>    
</body>
</html>