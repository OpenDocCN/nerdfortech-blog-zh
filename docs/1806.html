<html>
<head>
<title>UX Policies — Part 2</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">UX政策—第二部分</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/ux-policies-5ce77bc26304?source=collection_archive---------13-----------------------#2021-04-07">https://medium.com/nerd-for-tech/ux-policies-5ce77bc26304?source=collection_archive---------13-----------------------#2021-04-07</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="5c94" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">UX模式</h2></div><p id="2902" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这是系列文章的一部分。目标、基础、项目结构、文章摘要见 <a class="ae ju" href="https://sites.google.com/view/migueltt/home_en" rel="noopener ugc nofollow" target="_blank"> <em class="jt"> Android::简体</em> </a></p><p id="73c5" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="iz hj">务必先阅读</strong> <a class="ae ju" href="https://miguelt.medium.com/ux-policies-bbbb432dc5fc" rel="noopener"> <strong class="iz hj"> UX政策篇第一部分:问题</strong> </a> <strong class="iz hj">！</strong></p><p id="2202" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">知识库:<a class="ae ju" href="https://gitlab.com/migueltt/simpleandroid" rel="noopener ugc nofollow" target="_blank">https://gitlab.com/migueltt/simpleandroid</a></p></div><div class="ab cl jv jw gp jx" role="separator"><span class="jy bw bk jz ka kb"/><span class="jy bw bk jz ka kb"/><span class="jy bw bk jz ka"/></div><div class="hb hc hd he hf"><p id="13d5" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi kc translated"><span class="l kd ke kf bm kg kh ki kj kk di"> B </span>基于<a class="ae ju" href="https://miguelt.medium.com/ux-policies-bbbb432dc5fc" rel="noopener">第一部分</a>，你的应用应该根据你的需求有一个标准化的结构，定义适用于所有屏幕的导航和交互的主要UI组件，除了一些例外。</p><p id="35b4" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">此时，您可能已经非常熟悉这些<a class="ae ju" href="https://material.io/components?platform=android" rel="noopener ugc nofollow" target="_blank">模式和组件</a>，但是请继续阅读！最后，为了给整个项目提供结构，我将向您展示这个策略是什么样子的。另外，结尾有个转折。</p></div><div class="ab cl jv jw gp jx" role="separator"><span class="jy bw bk jz ka kb"/><span class="jy bw bk jz ka kb"/><span class="jy bw bk jz ka"/></div><div class="hb hc hd he hf"><p id="98f7" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">首先，有5件重要的事情需要考虑:</p><ol class=""><li id="9f5e" class="kl km hi iz b ja jb jd je jg kn jk ko jo kp js kq kr ks kt bi translated"><code class="du ku kv kw kx b">Drawer</code>和<code class="du ku kv kw kx b">BottomSheetDialog</code>包含一个<code class="du ku kv kw kx b">NavigationView</code></li><li id="72ac" class="kl km hi iz b ja ky jd kz jg la jk lb jo lc js kq kr ks kt bi translated"><code class="du ku kv kw kx b">NavigationView</code>项目被定义为XML资源中的菜单<code class="du ku kv kw kx b">&lt;item..&gt;</code>。<code class="du ku kv kw kx b">android:id</code>必须与导航图中使用的相同——这样，当选择一个项目时，它会自动通知<code class="du ku kv kw kx b">nav-controller</code>导航到该目的地</li><li id="33cf" class="kl km hi iz b ja ky jd kz jg la jk lb jo lc js kq kr ks kt bi translated"><code class="du ku kv kw kx b">BottomNavigationView</code>和<code class="du ku kv kw kx b">NavigationView</code>可能包含它们自己的<code class="du ku kv kw kx b">Menu</code> XML资源，这取决于你想如何组织你的<code class="du ku kv kw kx b">destinations</code></li><li id="1ede" class="kl km hi iz b ja ky jd kz jg la jk lb jo lc js kq kr ks kt bi translated"><code class="du ku kv kw kx b">Toolbars</code>(顶部或底部)和<code class="du ku kv kw kx b">Drawer</code>可以同步工作——对于顶层<code class="du ku kv kw kx b">android:id</code>,<code class="du ku kv kw kx b">Toolbar</code>显示3条图标，而对于非顶层，显示一个后退箭头图标</li><li id="13b4" class="kl km hi iz b ja ky jd kz jg la jk lb jo lc js kq kr ks kt bi translated">导航图必须被认为是你所有导航需求的真实来源——这意味着，没有更多的片段事务或定制解决方案来创建片段——应用程序必须始终使用<code class="du ku kv kw kx b">destination</code>来浏览“屏幕”</li></ol><figure class="le lf lg lh fd li er es paragraph-image"><div role="button" tabindex="0" class="lj lk di ll bf lm"><div class="er es ld"><img src="../Images/840cba689f8536222f806408eeb17e72.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XMcVzQw7NRQzmhTFJ_MhCg.png"/></div></div><figcaption class="lp lq et er es lr ls bd b be z dx translated">UI组件关系</figcaption></figure><p id="5d21" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这种结构将允许您毫不费力地添加新模块，因为所有组件都将同步，而不必添加自定义代码，因此，这应该是您在添加新功能时的长期策略:</p><ul class=""><li id="a455" class="kl km hi iz b ja jb jd je jg kn jk ko jo kp js lt kr ks kt bi translated">定义一个新的模块(片段、视图模型等),将相关的类分组到一个包中——只关注模块的特性</li><li id="b43d" class="kl km hi iz b ja ky jd kz jg la jk lb jo lc js lt kr ks kt bi translated">将你的<code class="du ku kv kw kx b">destinations</code>加入导航图</li><li id="eb81" class="kl km hi iz b ja ky jd kz jg la jk lb jo lc js lt kr ks kt bi translated">向<code class="du ku kv kw kx b">Menu</code>资源中添加新条目</li></ul></div><div class="ab cl jv jw gp jx" role="separator"><span class="jy bw bk jz ka kb"/><span class="jy bw bk jz ka kb"/><span class="jy bw bk jz ka"/></div><div class="hb hc hd he hf"><p id="9d41" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="iz hj">其次</strong>，使用现成的组件来定义应用程序要使用的UX模式，以简化开发——以后您可以随着对架构的熟悉而改进。</p><p id="94f0" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">以下是六种常见的UX模式(截至2021年4月)，你现在可以使用标准的Android Material组件来实现:</p><ul class=""><li id="9fc2" class="kl km hi iz b ja jb jd je jg kn jk ko jo kp js lt kr ks kt bi translated"><strong class="iz hj">工具栏+抽屉</strong>:传统方式。只有一个顶部工具栏，左边的<code class="du ku kv kw kx b">Drawer</code>包含导航项目。这里没有问题，唯一的问题是这种模式看起来和感觉都很旧。在大屏幕上，你的应用很难使用——用户必须“触及”左上角来激活<code class="du ku kv kw kx b">Drawer</code>，或者交换双手来滑动左边缘——这与系统范围的手势导航相冲突。</li></ul><figure class="le lf lg lh fd li er es paragraph-image"><div class="er es lu"><img src="../Images/ef50b266a124066d61f215230e7a3b1d.png" data-original-src="https://miro.medium.com/v2/resize:fit:600/1*luwTCiccOhEME6fRKHaJzw.gif"/></div><figcaption class="lp lq et er es lr ls bd b be z dx translated">工具栏和抽屉</figcaption></figure><ul class=""><li id="6f68" class="kl km hi iz b ja jb jd je jg kn jk ko jo kp js lt kr ks kt bi translated">底部导航视图:一种新的方法，但是只有当你有多达5个目的地时才有用。为了适应其他目的地，你必须引入一个顶部工具栏。只有当你100%确定你可以把所有的目的地放在底部时，才使用这种方法——人们可能会争辩说<code class="du ku kv kw kx b">BottomNavigationView</code>应该只包含顶部的<code class="du ku kv kw kx b">destinations</code>，其他二级屏幕应该使用不同的机制出现，比如菜单。</li></ul><figure class="le lf lg lh fd li er es paragraph-image"><div class="er es lu"><img src="../Images/78155f67449e4cda724ec17d85f66497.png" data-original-src="https://miro.medium.com/v2/resize:fit:600/1*RWGvYV5tfyHxzJQMPq5zoQ.gif"/></div><figcaption class="lp lq et er es lr ls bd b be z dx translated">底部导航视图</figcaption></figure><ul class=""><li id="f46c" class="kl km hi iz b ja jb jd je jg kn jk ko jo kp js lt kr ks kt bi translated"><strong class="iz hj">工具栏+抽屉+底部导航-视图</strong>:前两种模式的混合。这解决了仅使用<code class="du ku kv kw kx b">BottomNavigationView</code>时的问题，因为<code class="du ku kv kw kx b">Drawer</code>可以显示额外的<code class="du ku kv kw kx b">destinations</code>。在某些情况下，您可能希望在<code class="du ku kv kw kx b">Drawer</code>中显示所有目的地。</li></ul><figure class="le lf lg lh fd li er es paragraph-image"><div class="er es lu"><img src="../Images/d7e91591ba5f7d26a7f7e8fb31bf8e7c.png" data-original-src="https://miro.medium.com/v2/resize:fit:600/1*Z70gImqx4kAkOmhtTXiTmQ.gif"/></div><figcaption class="lp lq et er es lr ls bd b be z dx translated">工具栏、抽屉和底部导航视图</figcaption></figure><ul class=""><li id="b7fd" class="kl km hi iz b ja jb jd je jg kn jk ko jo kp js lt kr ks kt bi translated"><strong class="iz hj">底部-应用程序栏+抽屉</strong>:这种模式在过去几年里已经成为一种常态。让你更容易与应用程序互动，因为一切都可以用一只手操作，尤其是在大显示屏上。通常包含一个<code class="du ku kv kw kx b">Drawer</code>，默认情况下它出现在左手边，对于右手用户来说激活有点困难。您可以通过使用<code class="du ku kv kw kx b">android:layoutDirection</code>来解决这个问题，但是要小心，因为您必须在子组件上显式地设置这样的属性，如果用户在从右向左的语言环境中，这可能会搞砸。使用<code class="du ku kv kw kx b">BottomAppBar</code>的好处是<code class="du ku kv kw kx b">FloatingActionButton</code>可以很好地放在一个摇篮里，这个摇篮也可以在运行时修改为右边，转换为<code class="du ku kv kw kx b">scale</code>或<code class="du ku kv kw kx b">slide</code>。</li></ul><figure class="le lf lg lh fd li er es paragraph-image"><div class="er es lu"><img src="../Images/a166275add0b9a416b1a66e718127499.png" data-original-src="https://miro.medium.com/v2/resize:fit:600/1*srF3U72t66Q_pLXMO3g1Kw.gif"/></div><figcaption class="lp lq et er es lr ls bd b be z dx translated">底部应用栏和抽屉</figcaption></figure><ul class=""><li id="2692" class="kl km hi iz b ja jb jd je jg kn jk ko jo kp js lt kr ks kt bi translated"><strong class="iz hj">底部应用栏+底部表单对话框</strong>:和上一个一样，但是用了<code class="du ku kv kw kx b">BottomSheetDialogFragment</code>代替了<code class="du ku kv kw kx b">Drawer</code>。下面的动画在底部工作表中显示了一个标题，这可能是你不应该包含在你的应用程序中的。</li></ul><figure class="le lf lg lh fd li er es paragraph-image"><div class="er es lu"><img src="../Images/cb7aa94781790ec1cc000cbbfb1cd283.png" data-original-src="https://miro.medium.com/v2/resize:fit:600/1*lFZHYk0jBs2N1a8_M6URXw.gif"/></div><figcaption class="lp lq et er es lr ls bd b be z dx translated">底部应用程序栏和底部表单</figcaption></figure><ul class=""><li id="d8c0" class="kl km hi iz b ja jb jd je jg kn jk ko jo kp js lt kr ks kt bi translated"><strong class="iz hj">工具栏+抽屉+底部应用栏+底部导航视图</strong>:这是一种非标准模式，因为它混合了所有以前的模式(除了底部表单)。这里的主要目的是为用户提供对某些模块的快速访问。如果你有3或5个主<code class="du ku kv kw kx b">destinations</code>，我建议不要用这种模式，因为其中一个会被中间的<code class="du ku kv kw kx b">FloatingActionButton</code>切断——见下面的动画。在这种情况下，<code class="du ku kv kw kx b">FloatingActionButton</code>托架被推动(偏移)了一些倾角，以避免切断某些物品。只有当你真的需要那个<code class="du ku kv kw kx b">FloatingActionButton</code>摇篮的时候才使用这个模式。</li></ul><figure class="le lf lg lh fd li er es paragraph-image"><div class="er es lu"><img src="../Images/eddb25b23841f7f20b2098541691f4ca.png" data-original-src="https://miro.medium.com/v2/resize:fit:600/1*IJ5c48hrJ679A4EeH6MAnw.gif"/></div></figure><p id="055f" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="iz hj">现在，转折</strong>。所有的动画实际上都在同一个应用程序中。而且没有，app没有多个<code class="du ku kv kw kx b">Activities</code>或者<code class="du ku kv kw kx b">Fragments</code>，只有一个<code class="du ku kv kw kx b">Activity</code>。</p><blockquote class="lv lw lx"><p id="a02c" class="ix iy jt iz b ja jb ij jc jd je im jf ly jh ji jj lz jl jm jn ma jp jq jr js hb bi translated"><a class="ae ju" href="https://gitlab.com/migueltt/simpleandroid" rel="noopener ugc nofollow" target="_blank"> Simple::Android project </a>使用多种可在运行时更改的XML布局定义了所有这六种模式——查看变体<code class="du ku kv kw kx b">debug</code>中的<code class="du ku kv kw kx b"><a class="ae ju" href="https://gitlab.com/migueltt/simpleandroid/-/blob/develop/app/src/debugQA/java/com/simpleandroid/modules/ActivityMain.kt" rel="noopener ugc nofollow" target="_blank">ActivityMain</a></code>。</p></blockquote><figure class="le lf lg lh fd li er es paragraph-image"><div class="er es lu"><img src="../Images/0850a6018c81c02c8ccbd223e46f9078.png" data-original-src="https://miro.medium.com/v2/resize:fit:600/1*OelXWLN-AnozdaQ-vhx8Iw.gif"/></div><figcaption class="lp lq et er es lr ls bd b be z dx translated">UX风格切换器</figcaption></figure><ul class=""><li id="f7ef" class="kl km hi iz b ja jb jd je jg kn jk ko jo kp js lt kr ks kt bi translated">每个UX模式都是使用独立的XML布局定义的</li><li id="2319" class="kl km hi iz b ja ky jd kz jg la jk lb jo lc js lt kr ks kt bi translated">每个XML布局都使用ViewBinding，允许我们为每个布局定义扩展函数——参见<a class="ae ju" href="https://miguelt.medium.com/decoupling-binding-57566dc7b17d" rel="noopener">解耦绑定</a></li><li id="7c88" class="kl km hi iz b ja ky jd kz jg la jk lb jo lc js lt kr ks kt bi translated">从<code class="du ku kv kw kx b"><a class="ae ju" href="https://gitlab.com/migueltt/simpleandroid/-/blob/develop/app/src/main/java/com/simpleandroid/modules/settings/FragmentSettings.kt" rel="noopener ugc nofollow" target="_blank">FragmentSettings</a></code>，用户可以改变UX风格</li><li id="fae4" class="kl km hi iz b ja ky jd kz jg la jk lb jo lc js lt kr ks kt bi translated">除了我们将在下一部分描述的其他功能外，还允许改变风格</li><li id="9a5e" class="kl km hi iz b ja ky jd kz jg la jk lb jo lc js lt kr ks kt bi translated">动画展示了在保持<code class="du ku kv kw kx b">Fragment</code>和导航状态的同时，整体结构是如何变化的</li></ul><p id="e4a4" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">当然，你的应用不需要这么复杂——你只需要选择一种UX风格。这个运行时UX开关只是作为一个概念验证添加的，用来展示实现一个简单而有效的Android架构是多么容易。</p><p id="d30d" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">查看<a class="ae ju" href="https://miguelt.medium.com/ux-policies-part-3-d6937e2dda57" rel="noopener"> UX政策——第3部分:实施</a>,了解如何在不影响项目期限的情况下实现同样的简单性。</p></div></div>    
</body>
</html>