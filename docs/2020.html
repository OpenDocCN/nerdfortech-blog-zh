<html>
<head>
<title>Correlate Integration Events With The Command That Triggered Them In Application Insights</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在Application Insights中将集成事件与触发它们的命令相关联</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/correlate-background-jobs-or-integration-events-with-the-initial-command-in-application-insights-2b549e574a51?source=collection_archive---------4-----------------------#2021-04-17">https://medium.com/nerd-for-tech/correlate-background-jobs-or-integration-events-with-the-initial-command-in-application-insights-2b549e574a51?source=collection_archive---------4-----------------------#2021-04-17</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="5c08" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">通过后台作业或集成事件遥测关联扩展应用洞察的分布式跟踪</h2></div><p id="292e" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><a class="ae jt" href="https://docs.microsoft.com/en-us/azure/azure-monitor/app/app-insights-overview" rel="noopener ugc nofollow" target="_blank"> Application Insights </a>是监控您系统的绝佳工具。配置也非常简单——因为它是微软的产品，你只需要在Visual Studio中点击“添加应用洞察”,一切都准备好了。您将开始获得从应用程序异常到主机CPU性能的各种日志。</p><figure class="jv jw jx jy fd jz er es paragraph-image"><div role="button" tabindex="0" class="ka kb di kc bf kd"><div class="er es ju"><img src="../Images/401332e06b0948354e7212ef60f5295f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TpmQnBULGSR_HF1A0K-dmw.png"/></div></div><figcaption class="kg kh et er es ki kj bd b be z dx translated">你完全不用定制代码就能得到这个</figcaption></figure><p id="572c" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">Application Insights的一个真正酷的地方是分布式跟踪在默认情况下是启用的。换句话说，一个请求从您的前端开始，执行一个API端点，该端点查询数据库，并在返回结果之前调用另一个HTTP集成或服务——当您检查日志时，所有这些操作都是相互关联的。</p><figure class="jv jw jx jy fd jz er es paragraph-image"><div role="button" tabindex="0" class="ka kb di kc bf kd"><div class="er es kk"><img src="../Images/414a9a971891b604168cffceb433b942.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hTrEwGdJEMUU1q2caJ8hdQ.png"/></div></div><figcaption class="kg kh et er es ki kj bd b be z dx translated">这个贪婪的请求对数据库进行了6次查询</figcaption></figure><p id="6eeb" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">不过，有一件事不是开箱即用的，那就是后台作业和集成事件(除非你使用<a class="ae jt" href="https://docs.microsoft.com/en-us/azure/azure-monitor/app/custom-operations-tracking#service-bus-queue" rel="noopener ugc nofollow" target="_blank">微软Azure服务总线客户端</a>)。</p><h2 id="c94b" class="kl km hi bd kn ko kp kq kr ks kt ku kv jg kw kx ky jk kz la lb jo lc ld le lf bi translated">关联后台作业和集成事件</h2><p id="e450" class="pw-post-body-paragraph ix iy hi iz b ja lg ij jc jd lh im jf jg li ji jj jk lj jm jn jo lk jq jr js hb bi translated">假设我们有一个设置，其中一个命令可以引发一个集成事件:</p><pre class="jv jw jx jy fd ll lm ln lo aw lp bi"><span id="2155" class="kl km hi lm b fi lq lr l ls lt">public async Task CommandHandler(Command command)<br/>{<br/>    // business logic code</span><span id="8afd" class="kl km hi lm b fi lu lr l ls lt">    await dbContext.SaveAsync();<br/>    await eventDispatcher.Publish(new MyEvent());<br/>}</span></pre><p id="f638" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">继续我们的例子，我们有基础设施代码设置，它启动所有的处理程序作为后台作业(例如，我们可以使用<a class="ae jt" href="https://www.hangfire.io/" rel="noopener ugc nofollow" target="_blank"> Hangfire </a>)。<br/>在监控环境中，当检查日志时，我们希望<code class="du lv lw lx lm b">MyEvent</code>的所有处理程序都与初始命令/请求相关联，就像我们在上面看到的数据库查询一样。<br/>但是，如果我们记录命令和事件处理程序，我们会看到:</p><figure class="jv jw jx jy fd jz er es paragraph-image"><div class="er es ly"><img src="../Images/457121b163b0ec53e696645f8d0e0650.png" data-original-src="https://miro.medium.com/v2/resize:fit:1278/format:webp/1*P84xymO1H4CxUlDcX_N_Kg.png"/></div></figure><p id="d83a" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">与应用洞察中的操作相关的<code class="du lv lw lx lm b">Operation ID</code>则不同。这意味着它们将在Application Insights门户中显示为完全不同的请求，我们将无法知道这些集成事件源自何处。这将使得在查找bug时检查我们的日志更加困难。<br/>这是因为后台作业服务在另一个上下文中执行。它也可以是一个消息队列，甚至可以在不同的机器上执行。因此，Application Insights为这些方法分配了新的操作ID。</p><p id="2551" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">对此的解决方案？<em class="lz">我们需要在转到另一个上下文(后台作业)之前获取操作ID，在那里传播它，然后在另一个上下文的跟踪客户端中设置它。</em>让我们看看如何完成这些步骤。</p><p id="ec45" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这就是我们从Application Insights获取当前操作ID的方式，就在我们引发集成事件和切换上下文之前。</p><figure class="jv jw jx jy fd jz"><div class="bz dy l di"><div class="ma mb l"/></div></figure><p id="2b56" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">基本上我们正在创建一个假的<code class="du lv lw lx lm b">RequestTelemetry</code>并用遥测上下文初始化它。我们必须使用<code class="du lv lw lx lm b">OperationCorrelationTelemetryInitializer</code>来初始化定制的遥测请求——因为初始化器知道当前的上下文和它需要分配给请求遥测的所有必要的遥测属性，操作ID就是其中之一。你可能很想使用<code class="du lv lw lx lm b">System.Diagnostics.Activity.Current.RootId</code>作为操作ID，这可能行得通，但是如果你查看初始化器的<a class="ae jt" href="https://github.com/microsoft/ApplicationInsights-dotnet/blob/develop/BASE/src/Microsoft.ApplicationInsights/Extensibility/OperationCorrelationTelemetryInitializer.cs" rel="noopener ugc nofollow" target="_blank">代码</a>，你会看到它做了一系列检查来确保正确的属性被初始化。<br/>如果你想知道<code class="du lv lw lx lm b">telemetryConfiguration</code>是从哪里来的，你只需通过构造函数注入<code class="du lv lw lx lm b">TelemetryConfiguration</code>。</p><p id="e507" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">既然我们有了可以关联不同监控事件的操作ID，我们需要将它传递给另一个后台上下文。我们可以这样做的一个方法是向我们的<code class="du lv lw lx lm b">MyEvent</code>对象添加一个包，它将包含操作ID。</p><p id="4811" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">一旦进入后台上下文，并且有了操作ID，我们需要将操作ID传递回Application Insights tracker，这样它就可以与调用命令相关联。<br/>我们可以在事件处理程序上创建一个简单的装饰器，如下所示:</p><figure class="jv jw jx jy fd jz"><div class="bz dy l di"><div class="ma mb l"/></div></figure><p id="fe74" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们应该总是使用<code class="du lv lw lx lm b">RequestTelemetry</code>或<code class="du lv lw lx lm b">DependencyTelemetry</code>，并在它们上面设置操作ID(和任何其他属性)。我们可以设置操作的名称，添加自定义属性如数据等等。我们不应该直接在<code class="du lv lw lx lm b">TelemetryClient</code>上设置操作ID，因为这将使它对所有遥测使用相同的ID！<br/>为了让事件处理程序中的所有后续遥测数据再次自动关联，比如HTTP请求和数据库查询，我们需要用一个启动/停止操作来包装处理程序。<br/> <code class="du lv lw lx lm b">StartOperation</code>会对您的请求进行适当的初始化。我们只需要用从事件包中获得的值覆盖操作ID。一旦我们开始操作，所有后续的监控事件将自动关联到同一个操作ID。一旦我们呼叫<code class="du lv lw lx lm b">StopOperation</code>，所有操作的遥测数据将被发送到应用洞察。</p><figure class="jv jw jx jy fd jz er es paragraph-image"><div role="button" tabindex="0" class="ka kb di kc bf kd"><div class="er es mc"><img src="../Images/e3c78c7ac84a95751b1ae56f32baede3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-2iyMwM0NcxKQfoS8EOTzA.png"/></div></div><figcaption class="kg kh et er es ki kj bd b be z dx translated">操作ID相同，这意味着它们是相关的，可以一起调查</figcaption></figure><p id="eef4" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">为了让我们看到我们所做工作的最终结果，下面是Application Insights现在如何跟踪更复杂的场景:</p><ul class=""><li id="a360" class="md me hi iz b ja jb jd je jg mf jk mg jo mh js mi mj mk ml bi translated">命令查询/写入数据库并调用3个HTTP依赖项</li><li id="922f" class="md me hi iz b ja mm jd mn jg mo jk mp jo mq js mi mj mk ml bi translated">该命令还会引发两个集成事件</li><li id="db40" class="md me hi iz b ja mm jd mn jg mo jk mp jo mq js mi mj mk ml bi translated">每个集成事件都会查询数据库</li><li id="8827" class="md me hi iz b ja mm jd mn jg mo jk mp jo mq js mi mj mk ml bi translated">其中一个集成事件调用一个HTTP依赖项</li></ul><figure class="jv jw jx jy fd jz er es paragraph-image"><div role="button" tabindex="0" class="ka kb di kc bf kd"><div class="er es mr"><img src="../Images/d2439a0ed90efd69bd4a9c45d439ed9d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8Z31qnJU0Ku7BBnmEFMooA.png"/></div></div><figcaption class="kg kh et er es ki kj bd b be z dx translated">最上面是初始命令及其依赖项。下面的集成事件具有特定的类型，并且还会跟踪匿名数据。</figcaption></figure><h2 id="0b97" class="kl km hi bd kn ko kp kq kr ks kt ku kv jg kw kx ky jk kz la lb jo lc ld le lf bi translated">结论</h2><p id="d9ca" class="pw-post-body-paragraph ix iy hi iz b ja lg ij jc jd lh im jf jg li ji jj jk lj jm jn jo lk jq jr js hb bi translated">虽然您仍然可以在不关联集成事件的情况下调试大多数问题，但是您可以肯定，有一次您会遇到这样的错误，您会想知道哪个命令引发了集成事件，以及它们的属性是什么。不要让你能预料到这种情况并做好准备的时刻到来。</p></div></div>    
</body>
</html>