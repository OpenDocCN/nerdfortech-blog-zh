<html>
<head>
<title>Customise and resize sheets in SwiftUI</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在 SwiftUI 中自定义和调整工作表大小</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/customise-and-resize-sheets-in-swiftui-df9fae7c369b?source=collection_archive---------1-----------------------#2021-10-01">https://medium.com/nerd-for-tech/customise-and-resize-sheets-in-swiftui-df9fae7c369b?source=collection_archive---------1-----------------------#2021-10-01</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><figure class="hh hi ez fb hj hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es hg"><img src="../Images/11b13fd9af9b3a8a0c9111cf892a4d72.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_Cc-B7EIum0wOLowc7QG6w.png"/></div></div><figcaption class="hr hs et er es ht hu bd b be z dx translated">鸣谢:苹果公司(WWDC`21 会议 10063)</figcaption></figure><div class=""/><p id="1b1e" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">这个故事的标题与 WWDC`21 session <a class="ae js" href="https://developer.apple.com/videos/play/wwdc2021/10063/" rel="noopener ugc nofollow" target="_blank"> 10063 </a>类似，只是在 WWDC 的标题中有“UIKit”而不是“SwiftUI”。</p><p id="89cd" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">你猜对了，我们会做一个三明治。</p><p id="7758" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">为了确保你能了解这篇文章中的更多内容，我强烈建议你先看看前面提到的 WWDC 会议。</p><h1 id="d7aa" class="jt ju hx bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated"><strong class="ak">问题陈述</strong></h1><ol class=""><li id="6727" class="kr ks hx iw b ix kt jb ku jf kv jj kw jn kx jr ky kz la lb bi translated">SwiftUI 太固执己见了(确实如此)。尤其是关于视图控制器，尤其是关于已呈现的视图控制器。<code class="du lc ld le lf b">.sheet(...)</code>、<code class="du lc ld le lf b">.fullScreenCover(...)</code>和<code class="du lc ld le lf b">.popover(...)</code>修饰符是 iOS 15 上 UIKit 必须提供的非常基本的简化。</li><li id="b1d1" class="kr ks hx iw b ix lg jb lh jf li jj lj jn lk jr ky kz la lb bi translated">SwiftUI 没有关于通过 UIKit APIs 呈现 SwiftUI 视图的 UIKit 接口指南。我猜这是因为 UIKit 中呈现状态的管理很混乱(你稍后会看到原因)，苹果想用 SwiftUI 中有限的固执己见的 API 来掩盖这一点。</li></ol><h2 id="e78f" class="ll ju hx bd jv lm ln lo jz lp lq lr kd jf ls lt kh jj lu lv kl jn lw lx kp ly bi translated"><strong class="ak">swift ui 不支持的用例</strong></h2><ul class=""><li id="e91b" class="kr ks hx iw b ix kt jb ku jf kv jj kw jn kx jr lz kz la lb bi translated">定制<code class="du lc ld le lf b">.sheet(...)</code>调节器的棘爪，以配置可调整尺寸的板材</li><li id="f3e6" class="kr ks hx iw b ix lg jb lh jf li jj lj jn lk jr lz kz la lb bi translated">自定义<code class="du lc ld le lf b">.popover(...)</code>修改器的卡位来配置可调整大小的页面，当场景的水平尺寸等级为紧凑时，弹出窗口会适应这些页面。</li><li id="1ba6" class="kr ks hx iw b ix lg jb lh jf li jj lj jn lk jr lz kz la lb bi translated">模态呈现风格<code class="du lc ld le lf b">.custom</code>，定制交互式过渡和定制所呈现视图控制器的大小</li><li id="5362" class="kr ks hx iw b ix lg jb lh jf li jj lj jn lk jr lz kz la lb bi translated">“在当前背景下”的演示</li><li id="443b" class="kr ks hx iw b ix lg jb lh jf li jj lj jn lk jr lz kz la lb bi translated">相同类型的真实来源的不同呈现风格(SwiftUI 中有三个修饰符<code class="du lc ld le lf b">.sheet(item: ...)</code>、<code class="du lc ld le lf b">.popover(item: ...)</code>、<code class="du lc ld le lf b">.fullScreenCover(item: ...)</code>，而不是用呈现风格参数化的单个修饰符)。假设我们有 2 个项目，第一个项目我们想显示<code class="du lc ld le lf b">.sheet</code>，第二个项目我们想在<code class="du lc ld le lf b">.sheet</code>消失后显示<code class="du lc ld le lf b">.fullScreenCover</code>。即使我们在第一个修改器后进行第二个修改器的兔子洞之旅，SwiftUI 也不会显示我们想要的。对于第二个项目，它将重用第一个项目的呈现样式，即，它将第二次呈现工作表，而不是全屏覆盖，不注意不同的修饰符</li><li id="4a6e" class="kr ks hx iw b ix lg jb lh jf li jj lj jn lk jr lz kz la lb bi translated">定制显示的视图控制器的首选属性，如:</li></ul><pre class="ma mb mc md fd me lf mf mg aw mh bi"><span id="f883" class="ll ju hx lf b fi mi mj l mk ml"><strong class="lf hy">public</strong> <strong class="lf hy">var</strong> definesPresentationContext<strong class="lf hy"><br/>public</strong> <strong class="lf hy">var</strong> disablesAutomaticKeyboardDismissal<br/><strong class="lf hy">public</strong> <strong class="lf hy">var</strong> focusGroupIdentifier<br/><strong class="lf hy">public</strong> <strong class="lf hy">var</strong> isModalInPresentation<strong class="lf hy"><br/>public</strong> <strong class="lf hy">var</strong> modalPresentationCapturesStatusBarAppearance<strong class="lf hy"><br/>public</strong> <strong class="lf hy">var</strong> modalTransitionStyle<strong class="lf hy"><br/>public</strong> <strong class="lf hy">var</strong> preferredContentSize<br/><strong class="lf hy">public</strong> <strong class="lf hy">var</strong> preferredScreenEdgesDeferringSystemGestures<br/><strong class="lf hy">public</strong> <strong class="lf hy">var</strong> preferredStatusBarStyle<br/><strong class="lf hy">public</strong> <strong class="lf hy">var</strong> preferredStatusBarUpdateAnimation<br/><strong class="lf hy">public</strong> <strong class="lf hy">var</strong> prefersPointerLocked<br/><strong class="lf hy">public</strong> <strong class="lf hy">var</strong> prefersHomeIndicatorAutoHidden<br/><strong class="lf hy">public</strong> <strong class="lf hy">var</strong> providesPresentationContextTransitionStyle<strong class="lf hy"><br/>public</strong> <strong class="lf hy">var</strong> restoresFocusAfterTransition</span></pre><p id="cda9" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">如果这些使用案例中有任何一个是您的，欢迎加入我们——这个故事正是为您而写的！</p><h2 id="dc36" class="ll ju hx bd jv lm ln lo jz lp lq lr kd jf ls lt kh jj lu lv kl jn lw lx kp ly bi translated"><strong class="ak"> SwiftUI 没有关于与 UIKit 接口以呈现 SwiftUI 视图的指南</strong></h2><p id="8849" class="pw-post-body-paragraph iu iv hx iw b ix kt iz ja jb ku jd je jf mm jh ji jj mn jl jm jn mo jp jq jr hb bi translated">在上述列表中找到我的用例后，我意识到唯一的解决机会是做一个<strong class="iw hy">三明治</strong>。面包的底部和顶部将代表 SwiftUI presenteR 视图和 SwiftUI presenteD 视图，中间最美味的部分将它们粘合在一起并控制演示，将由 UIKit 表示。</p><p id="d6e2" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">但这可能吗？我建议你在继续阅读之前花几分钟时间，想想你将如何实现这样一个三明治。</p></div><div class="ab cl mp mq gp mr" role="separator"><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu"/></div><div class="hb hc hd he hf"><figure class="ma mb mc md fd hk"><div class="bz dy l di"><div class="mw mx l"/></div></figure><h1 id="2da3" class="jt ju hx bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">三明治溶液</h1><h2 id="61de" class="ll ju hx bd jv lm ln lo jz lp lq lr kd jf ls lt kh jj lu lv kl jn lw lx kp ly bi translated">要求</h2><ol class=""><li id="0b28" class="kr ks hx iw b ix kt jb ku jf kv jj kw jn kx jr ky kz la lb bi translated">与 SwiftUI 提供的 API(即<code class="du lc ld le lf b">.sheet(...)</code>)类似，但没有上述限制——我们需要两个修饰符来表示，一个由 Bool <code class="du lc ld le lf b">isPresented</code>控制，另一个由可选的可识别的<code class="du lc ld le lf b">item</code>控制。此外，由于 SwiftUI 不允许实例化<code class="du lc ld le lf b">DismissAction</code> struct，我们将需要一个内置的<code class="du lc ld le lf b">isPresented</code>和<code class="du lc ld le lf b">dismiss</code>环境值的模拟，但是我们的自定义值将反映和控制我们的表示状态。</li><li id="f8db" class="kr ks hx iw b ix lg jb lh jf li jj lj jn lk jr ky kz la lb bi translated">SwiftUI 视图底部夹层部分的生命周期——处理表示逻辑的地方，应该合并并正确处理嵌套 UIKit 视图控制器表示图的混乱生命周期。您可能知道，UIKit 中的表示可以嵌套，已表示的视图控制器可以在其自身之上表示下一个视图控制器，因此我们在需要时消除正确的视图控制器很重要。</li></ol><p id="2893" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">我已经构建了一个名为<a class="ae js" href="https://github.com/edudnyk/SheeKit" rel="noopener ugc nofollow" target="_blank"><strong class="iw hy">shee kit</strong></a><strong class="iw hy"/>的库，它实现了这些需求。</p><p id="16c3" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">它的灵感来自 Mauricio T Zaquia 的<a class="ae js" href="https://github.com/mtzaquia/UIKitPresentationModifier" rel="noopener ugc nofollow" target="_blank">UIKitPresentationModifier</a>library，但是有一些非常重要的不同和增强。</p><h2 id="c6f6" class="ll ju hx bd jv lm ln lo jz lp lq lr kd jf ls lt kh jj lu lv kl jn lw lx kp ly bi translated">实施的关键支柱</h2><ol class=""><li id="8b04" class="kr ks hx iw b ix kt jb ku jf kv jj kw jn kx jr ky kz la lb bi translated">允许通过<code class="du lc ld le lf b">UIViewControllerProxy</code>定制首选显示的视图控制器参数</li></ol><figure class="ma mb mc md fd hk"><div class="bz dy l di"><div class="na mx l"/></div><figcaption class="hr hs et er es ht hu bd b be z dx translated">呈现的视图控制器负载的片段</figcaption></figure><p id="f7c0" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">2.支持所有与 SwiftUI 兼容的模态展示风格，不要从<code class="du lc ld le lf b">UIWindow</code>中移除展示视图控制器</p><figure class="ma mb mc md fd hk"><div class="bz dy l di"><div class="na mx l"/></div><figcaption class="hr hs et er es ht hu bd b be z dx translated">受支持的模式演示样式的片段</figcaption></figure><p id="fe86" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">3.支持<code class="du lc ld le lf b">SheetProperties</code>中的所有<code class="du lc ld le lf b">UISheetPresentationController</code>属性</p><figure class="ma mb mc md fd hk"><div class="bz dy l di"><div class="na mx l"/></div><figcaption class="hr hs et er es ht hu bd b be z dx translated">表单呈现控制器有效负载的片段</figcaption></figure><p id="ae7d" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">4.通过尽可能简单的 SwiftUI API 提供所有这些强大的功能</p><figure class="ma mb mc md fd hk"><div class="bz dy l di"><div class="na mx l"/></div><figcaption class="hr hs et er es ht hu bd b be z dx translated">演示修饰符片段——演示的入口点</figcaption></figure><h1 id="4729" class="jt ju hx bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">与 UIKit 演示交互</h1><p id="d8d5" class="pw-post-body-paragraph iu iv hx iw b ix kt iz ja jb ku jd je jf mm jh ji jj mn jl jm jn mo jp jq jr hb bi translated">最难的部分…</p><p id="2c52" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">经过多次试验和错误，我得出的结论是:</p><blockquote class="nb nc nd"><p id="9cf9" class="iu iv ne iw b ix iy iz ja jb jc jd je nf jg jh ji ng jk jl jm nh jo jp jq jr hb bi translated">SwiftUI 中唯一能够管理任何与<code class="du lc ld le lf b">UIViewController</code>相关的生命周期的是<code class="du lc ld le lf b">UIViewControllerRepresentable</code></p></blockquote><p id="db9d" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">这听起来很明显，但对我来说，这不是我尝试的第一个，甚至不是第二个想法。也许吧，因为没有人会马上想到创建多余的<code class="du lc ld le lf b">UIViewController</code>，它除了成为其父级的<strong class="iw hy"> SwiftUI 管理的子级之外什么也不做，它还呈现了</strong>。显然，这是整个实现中最重要的特性。</p><p id="02d5" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">为了处理关于交互式解散的回调(这是演示生命周期的一部分)，我们还需要让<code class="du lc ld le lf b">UIPresentationController</code>中的<code class="du lc ld le lf b">delegate</code>——以及<code class="du lc ld le lf b">UIViewControllerRepresentable</code>套件中的<code class="du lc ld le lf b">Coordinator</code>最适合这个角色。<code class="du lc ld le lf b">AdaptiveDelegate</code>实例将是我们的<code class="du lc ld le lf b">Coordinator</code>。</p><figure class="ma mb mc md fd hk"><div class="bz dy l di"><div class="na mx l"/></div><figcaption class="hr hs et er es ht hu bd b be z dx translated">与 UIKit 接口的最初想法片段</figcaption></figure><h2 id="7041" class="ll ju hx bd jv lm ln lo jz lp lq lr kd jf ls lt kh jj lu lv kl jn lw lx kp ly bi translated">知道你驳回了什么</h2><p id="5ef2" class="pw-post-body-paragraph iu iv hx iw b ix kt iz ja jb ku jd je jf mm jh ji jj mn jl jm jn mo jp jq jr hb bi translated">在 UIKit 中，一些控制表示状态的工具是不明确的。</p><ol class=""><li id="ad75" class="kr ks hx iw b ix iy jb jc jf ni jj nj jn nk jr ky kz la lb bi translated">当你调用视图控制器的<code class="du lc ld le lf b">.dismiss(animated:completion:)</code>方法时，它可以:</li></ol><ul class=""><li id="65d4" class="kr ks hx iw b ix iy jb jc jf ni jj nj jn nk jr lz kz la lb bi translated">消除嵌套的<code class="du lc ld le lf b">presentedViewController</code>(如果有)</li><li id="a21d" class="kr ks hx iw b ix lg jb lh jf li jj lj jn lk jr lz kz la lb bi translated">如果存在被调用者或其父代，请将其关闭</li></ul><p id="e91a" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">如果在同一个被调用者上调用<code class="du lc ld le lf b">dismiss(animated:completion:)</code>两次，这两种情况都可能发生。</p><p id="b780" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">2.如果您在过流上下文呈现模式下从视图控制器 VC1 呈现视图控制器 VC2，并且<code class="du lc ld le lf b">VC1.definesPresentationContext == false</code>，<code class="du lc ld le lf b">VC1.presentedViewController</code>将是<code class="du lc ld le lf b">nil</code>，而<code class="du lc ld le lf b">VC2.presentingViewController</code>将不是<code class="du lc ld le lf b">nil</code>。</p><p id="8698" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">这是一个模棱两可的烂摊子，但我们总得设法处理它。幸运的是，我们可以将我们给出的托管控制器(<code class="du lc ld le lf b">sheetHost</code>)归属于<code class="du lc ld le lf b">Item.ID</code>，它标识了底部夹层部件中<code class="du lc ld le lf b">SheetPresenterControllerRepresentable</code>的状态与当前呈现的视图控制器之间的对应关系。然后，关于是否需要解除<code class="du lc ld le lf b">sheetHost</code>的决定如下:</p><ul class=""><li id="312f" class="kr ks hx iw b ix iy jb jc jf ni jj nj jn nk jr lz kz la lb bi translated">当我们显示图纸主体时，我们为其分配项目标识符:</li></ul><pre class="ma mb mc md fd me lf mf mg aw mh bi"><span id="61a0" class="ll ju hx lf b fi mi mj l mk ml">sheetHost.itemId = <!-- -->SheetPresenterControllerRepresentable.item.id</span></pre><ul class=""><li id="c717" class="kr ks hx iw b ix iy jb jc jf ni jj nj jn nk jr lz kz la lb bi translated">当当前显示的视图控制器<code class="du lc ld le lf b">sheetHost.itemId</code>的标识符与<code class="du lc ld le lf b">SheetPresenterControllerRepresentable.item.id</code>匹配时，我们什么也不做</li><li id="21ba" class="kr ks hx iw b ix lg jb lh jf li jj lj jn lk jr lz kz la lb bi translated">当当前呈现的视图控制器的标识符<code class="du lc ld le lf b">sheetHost.itemId</code>不为零并且与<code class="du lc ld le lf b">SheetPresenterControllerRepresentable.item.id</code>不匹配时，我们使<code class="du lc ld le lf b">sheetHost.itemId</code>无效，并消除<code class="du lc ld le lf b">sheetHost</code></li><li id="5821" class="kr ks hx iw b ix lg jb lh jf li jj lj jn lk jr lz kz la lb bi translated">我们从不在<code class="du lc ld le lf b">sheetHost.itemId == nil</code>时调用<code class="du lc ld le lf b">sheetHost.presentingViewController</code>上的 dissolve——这确保了我们在正确的时间解除正确的控制器。</li></ul><figure class="ma mb mc md fd hk"><div class="bz dy l di"><div class="na mx l"/></div><figcaption class="hr hs et er es ht hu bd b be z dx translated">与 UIKit 接口——托管表单内容的托管控制器的片段</figcaption></figure><figure class="ma mb mc md fd hk"><div class="bz dy l di"><div class="na mx l"/></div><figcaption class="hr hs et er es ht hu bd b be z dx translated">与 UIKit 接口—SheetPresenterControllerRepresentable 中的表示和消除逻辑片段</figcaption></figure><p id="04ec" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">最后，将<code class="du lc ld le lf b">SheetPresenterControllerRepresentable</code>注入 SwiftUI 视图图形的修饰符</p><figure class="ma mb mc md fd hk"><div class="bz dy l di"><div class="na mx l"/></div><figcaption class="hr hs et er es ht hu bd b be z dx translated">与 UIKit 接口—SheetPresenterControllerRepresentable 中的表示和消除逻辑片段</figcaption></figure><p id="0980" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">还有其他准备好呈现的证据，比如等待<code class="du lc ld le lf b">presenter.view</code>获取<code class="du lc ld le lf b">window</code>，或者将<code class="du lc ld le lf b">presenter</code>添加到最近的父节点，以防 SwiftUI 只将<code class="du lc ld le lf b">presenter</code>的<code class="du lc ld le lf b">view</code>注入视图层次结构，而不将<code class="du lc ld le lf b">presenter</code>注入视图控制器层次结构，这是 iOS 13 的情况。我不会在这个故事中涉及这些额外的检查，因为它碰巧已经很长了。如果你很好奇，你可以在 SheeKit <a class="ae js" href="https://github.com/edudnyk/SheeKit/tree/main/Sources" rel="noopener ugc nofollow" target="_blank">库</a>中看到完整的实现。</p><p id="cbd0" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">我用演示应用程序录制了演示 SheeKit 功能的视频。</p><figure class="ma mb mc md fd hk"><div class="bz dy l di"><div class="nl mx l"/></div><figcaption class="hr hs et er es ht hu bd b be z dx translated">演示</figcaption></figure><p id="a5c5" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">感谢阅读！不要犹豫，让我知道你对 SheeKit 的看法。</p></div></div>    
</body>
</html>