<html>
<head>
<title>Practically understanding time complexities of Recursive and Iterative functions</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">实际理解递归和迭代函数的时间复杂性</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/practically-understanding-time-complexities-of-recursive-and-iterative-functions-95238525c145?source=collection_archive---------5-----------------------#2021-03-07">https://medium.com/nerd-for-tech/practically-understanding-time-complexities-of-recursive-and-iterative-functions-95238525c145?source=collection_archive---------5-----------------------#2021-03-07</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="cfb6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们将考虑斐波纳契函数来比较递归和迭代函数的时间复杂度。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es jd"><img src="../Images/c565250f0eb9bb15671523f8bb3c44c0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Mt9LV-9qsnTV2OJV"/></div></div><figcaption class="jp jq et er es jr js bd b be z dx translated">在<a class="ae jt" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上由<a class="ae jt" href="https://unsplash.com/@aronvisuals?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Aron 视觉</a>拍摄的照片</figcaption></figure></div><div class="ab cl ju jv gp jw" role="separator"><span class="jx bw bk jy jz ka"/><span class="jx bw bk jy jz ka"/><span class="jx bw bk jy jz"/></div><div class="hb hc hd he hf"><h1 id="4eb0" class="kb kc hi bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated"><strong class="ak">基本定义</strong></h1><ol class=""><li id="674b" class="kz la hi ih b ii lb im lc iq ld iu le iy lf jc lg lh li lj bi translated">递归:函数不断直接或间接调用自身的过程。</li><li id="d41f" class="kz la hi ih b ii lk im ll iq lm iu ln iy lo jc lg lh li lj bi translated">迭代:某一组指令重复执行的过程。</li></ol><h1 id="6812" class="kb kc hi bd kd ke lp kg kh ki lq kk kl km lr ko kp kq ls ks kt ku lt kw kx ky bi translated"><strong class="ak">递归和迭代斐波那契计算的算法</strong></h1><ol class=""><li id="d867" class="kz la hi ih b ii lb im lc iq ld iu le iy lf jc lg lh li lj bi translated">递归的</li></ol><pre class="je jf jg jh fd lu lv lw lx aw ly bi"><span id="5628" class="lz kc hi lv b fi ma mb l mc md">recursivefib(n):<br/>   <strong class="lv hj">if</strong> n &lt;2<br/>       <strong class="lv hj">return</strong> n<br/>   <strong class="lv hj">return</strong> recursivefib(n - 1) + recursivefib(n - 2)</span></pre><p id="b36b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">2.重复的</p><pre class="je jf jg jh fd lu lv lw lx aw ly bi"><span id="84de" class="lz kc hi lv b fi ma mb l mc md">iterativefib(n):<br/>    x=0, y=1<br/>    <strong class="lv hj">if</strong> n&lt;2<br/>        <strong class="lv hj">return</strong> n<br/>    for (i=2; i&lt;=n; i++)<br/>   {<br/>      z=x+y<br/>      x=y<br/>      y=z<br/>   }<br/>   <strong class="lv hj">return</strong> y</span></pre><p id="b5ed" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">正如在算法中观察到的，递归函数一直调用自己，直到达到基本条件(<em class="me">即 n &lt; 2 </em>)。而迭代函数使用<em class="me"> for </em>循环重复执行一组指令(本例中为<em class="me">:z = x+y；x = y；y = z；</em>)。</p><p id="de6e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在递归算法中，<em class="me"> if </em>语句花费恒定的时间，但是递归语句(<em class="me">recursivefib(n-1)+recursivefib(n-2))</em>花费的时间取决于输入。递归调用使用堆栈，因此输入越大，需要的堆栈数量就越多。</p><p id="7a1b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在迭代算法中，<em class="me"> if </em>语句花费恒定时间，但是<em class="me">用于</em>循环所花费的时间取决于输入。for 循环中的语句(在本例中)花费的时间是恒定的。所以那些语句会根据输入重复执行。</p><p id="178b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">那么现在让我们看看迭代和递归函数在现实中需要多少时间。为此，我使用内置的 Java 函数来计算这两个函数所花费的时间。</p><p id="831b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">计算递归和迭代函数所需时间的 Java 代码:</p><pre class="je jf jg jh fd lu lv lw lx aw ly bi"><span id="a374" class="lz kc hi lv b fi ma mb l mc md"><strong class="lv hj">import</strong> <strong class="lv hj">java.util.Scanner</strong>;<br/><br/><strong class="lv hj">public</strong> <strong class="lv hj">class</strong> <strong class="lv hj">Fibonacci</strong> {<br/>    <strong class="lv hj">public</strong> <strong class="lv hj">static</strong> <strong class="lv hj">void</strong> <strong class="lv hj">main</strong>(String[] args) {<br/><br/>        Scanner sc = <strong class="lv hj">new</strong> Scanner(System.in);<br/>        System.out.print("Enter N: ");<br/>        <strong class="lv hj">int</strong> n = sc.nextInt();<br/>        sc.close(); <br/><br/>        <strong class="lv hj">if</strong>(n&lt;<strong class="lv hj">0</strong>)<br/>        {<br/>        	System.out.println("No Negative Numbers allowed");<br/>        	<strong class="lv hj">return</strong>;<br/>        }<br/>        <br/>        <strong class="lv hj">long</strong> time;<br/><br/>        System.out.println("Iterative Function:");<br/>        time = System.currentTimeMillis();<br/>        System.out.printf("Sequence Number at index %d = %d \n", n, iterativefib(n));<br/>        System.out.printf("Time using Iteration: %d ms\n", System.currentTimeMillis() - time);<br/>        <br/>        System.out.println("Recursive Function:");<br/>        time = System.currentTimeMillis();<br/>        System.out.printf("Sequence Number at index %d = %d \n", n, recursivefib(n));<br/>        System.out.printf("Time using Recursion: %d ms\n", System.currentTimeMillis() - time);<br/>    }<br/><br/><br/>    <strong class="lv hj">static</strong> <strong class="lv hj">long</strong> <strong class="lv hj">recursivefib</strong>(<strong class="lv hj">int</strong>  n) {<br/>        <strong class="lv hj">if</strong> (n&lt;<strong class="lv hj">2</strong>) <br/>            <strong class="lv hj">return</strong> n;<br/>        <strong class="lv hj">return</strong> <strong class="lv hj">recursivefib</strong>(n - <strong class="lv hj">1</strong>) + <strong class="lv hj">recursivefib</strong>(n - <strong class="lv hj">2</strong>);<br/>    }<br/>    <br/>    <strong class="lv hj">static</strong> <strong class="lv hj">long</strong> <strong class="lv hj">iterativefib</strong>(<strong class="lv hj">int</strong> n) {<br/>        <strong class="lv hj">long</strong> f1 = <strong class="lv hj">0</strong>, f2 = <strong class="lv hj">1</strong>, f3;<br/>        <strong class="lv hj">if</strong>(n&lt;<strong class="lv hj">2</strong>)<br/>        	<strong class="lv hj">return</strong> n;<br/>        <strong class="lv hj">for</strong> (<strong class="lv hj">int</strong> i = <strong class="lv hj">2</strong>; i &lt;=n; i++) {<br/>            f3 = f1 + f2;<br/>            f1 = f2;<br/>            f2 = f3;<br/>        }<br/>        <strong class="lv hj">return</strong> f2;<br/>    }<br/>}</span></pre><p id="6fe4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在让我们看看随着输入大小的增加，我们会得到什么样的输出:</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es mf"><img src="../Images/d645dc836a2f8b0b99e3566c37db6b0f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7jKb9AXJ4EOyggcjRZwQDA.png"/></div></div></figure><blockquote class="mg mh mi"><p id="95e7" class="if ig me ih b ii ij ik il im in io ip mj ir is it mk iv iw ix ml iz ja jb jc hb bi translated">注意:我们在输出中得到的时间取决于许多因素，比如系统中运行的进程数量，而不仅仅是函数本身。所以当你在你的终端运行代码时，输出可能有点不同，但是函数的行为是一样的。同样，在上面的代码中，包含了打印输出的时间，所以如果您想排除打印时间，可以相应地修改代码。</p></blockquote><p id="f954" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在我们有了递归和迭代函数的时间需求的真实场景。因此，让我们简单讨论一下时间复杂性和递归 v/s 迭代函数的行为。</p><ul class=""><li id="5bca" class="kz la hi ih b ii ij im in iq mm iu mn iy mo jc mp lh li lj bi translated">求递归的时间复杂度比迭代的时间复杂度更复杂。</li><li id="f493" class="kz la hi ih b ii lk im ll iq lm iu ln iy lo jc mp lh li lj bi translated">如上所述，递归一次又一次地调用同一个函数，这导致了很大的开销，因为每次递归调用都需要它自己的堆栈。</li><li id="0c81" class="kz la hi ih b ii lk im ll iq lm iu ln iy lo jc mp lh li lj bi translated">而迭代只是相同代码块的重复，这使得代码更大，但与递归相比没有大的开销。</li><li id="65ff" class="kz la hi ih b ii lk im ll iq lm iu ln iy lo jc mp lh li lj bi translated">在递归的情况下，我们可以通过使用递归调用生成的递归树来计算时间复杂度。递归树的递归方程给出为<em class="me"> T(n) = T(n-1) + T(n-2) + c </em></li><li id="f76c" class="kz la hi ih b ii lk im ll iq lm iu ln iy lo jc mp lh li lj bi translated">通过求解上述递推方程，我们得到时间复杂度为 O(2^n).</li><li id="163d" class="kz la hi ih b ii lk im ll iq lm iu ln iy lo jc mp lh li lj bi translated">上述时间复杂度是指数的，这从对应于输入 N 的输出中显示的值可以明显看出。随着 N 值的增加，使用递归计算第 N 个斐波那契数所需的时间也是指数增加的。</li><li id="949d" class="kz la hi ih b ii lk im ll iq lm iu ln iy lo jc mp lh li lj bi translated">在迭代的情况下，首先观察到对于较小的 N 值，所需的时间比递归 Fibonacci 函数多，但是随着 N 值的增加，并且在 N 的某个值之后，迭代 Fibonacci 函数所需的时间总是小于递归 Fibonacci 函数所需的时间。</li><li id="921b" class="kz la hi ih b ii lk im ll iq lm iu ln iy lo jc mp lh li lj bi translated">递归中的指数行为是由嵌套调用及其相应的堆栈开销造成的。</li></ul></div><div class="ab cl ju jv gp jw" role="separator"><span class="jx bw bk jy jz ka"/><span class="jx bw bk jy jz ka"/><span class="jx bw bk jy jz"/></div><div class="hb hc hd he hf"><p id="eb33" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">对于任何技术或其他错误，随时与我联系，以便进一步的读者受益。</p><p id="4d76" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">感谢您的阅读。知识就是力量，所以不断获取！😈</p><p id="f09d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在<a class="ae jt" href="https://github.com/gandhidevansh" rel="noopener ugc nofollow" target="_blank"> GitHub </a>上关注我吧！</p></div></div>    
</body>
</html>