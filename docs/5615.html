<html>
<head>
<title>Flutter: Chat notifications using FCM in a socket.io powered chat app</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Flutter:在 socket.io 支持的聊天应用中使用 FCM 的聊天通知</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/flutter-chat-notifications-using-fcm-in-a-socket-io-powered-chat-app-7fabe6a3d912?source=collection_archive---------1-----------------------#2021-10-24">https://medium.com/nerd-for-tech/flutter-chat-notifications-using-fcm-in-a-socket-io-powered-chat-app-7fabe6a3d912?source=collection_archive---------1-----------------------#2021-10-24</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/d366f876481c80383294abf8f293451a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YA9TBWNyfAm6F20XwTwjYA.png"/></div></div></figure><p id="6339" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">前阵子写了一篇<a class="ae jo" rel="noopener" href="/nerd-for-tech/flutter-a-chat-app-in-flutter-using-a-socket-io-service-88be02a388d6">文章</a>关于如何在 flutter 中使用 socket.io 服务创建聊天 app。该应用程序将用户连接到 websocket 服务，并支持实时对话。虽然用户可以在线聊天，但当他们离开应用程序时，应用程序会将他们与 websocket 断开连接。这个限制将我们带到了聊天应用的下一个主要需求:当应用在后台运行时接收聊天通知。<br/>受我上一篇文章的启发，这里我将添加使用 FCM (Firebase Cloud Messaging)接收聊天通知的功能。</p><blockquote class="jp jq jr"><p id="b3b8" class="iq ir js is b it iu iv iw ix iy iz ja jt jc jd je ju jg jh ji jv jk jl jm jn hb bi translated">注意:在这篇文章中，我只讲述了 ANDROID 设备的变化。</p></blockquote><h1 id="be2d" class="jw jx hi bd jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt bi translated">先决条件</h1><p id="2ee3" class="pw-post-body-paragraph iq ir hi is b it ku iv iw ix kv iz ja jb kw jd je jf kx jh ji jj ky jl jm jn hb bi translated">本文是我上一篇文章的延续:<strong class="is hj"> </strong> <a class="ae jo" rel="noopener" href="/nerd-for-tech/flutter-a-chat-app-in-flutter-using-a-socket-io-service-88be02a388d6"> <em class="js"> Flutter:一款在 Flutter 中使用 Socket 的聊天 app。IO 服务</em></a>T9】。请按照那里的步骤前进。</p><h1 id="5618" class="jw jx hi bd jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt bi translated">步骤 1:创建一个新的 Firebase 应用程序</h1><p id="2caf" class="pw-post-body-paragraph iq ir hi is b it ku iv iw ix kv iz ja jb kw jd je jf kx jh ji jj ky jl jm jn hb bi translated">按照这里的步骤<a class="ae jo" href="https://sharma-vikashkr.medium.com/firebase-how-to-setup-an-app-in-firebase-9ddbacfe8ad1" rel="noopener">创建一个新的 Firebase 应用程序。不要忘记下载生成的<em class="js"> google-services.json </em>并将 Firebase SDKs 添加到您的 android 项目中。</a></p><h1 id="d8b9" class="jw jx hi bd jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt bi translated">步骤 2:添加所需的依赖项</h1><p id="3d57" class="pw-post-body-paragraph iq ir hi is b it ku iv iw ix kv iz ja jb kw jd je jf kx jh ji jj ky jl jm jn hb bi translated">在 flutter <em class="js"> chat_app </em>中，在项目的<em class="js"> pubspec.yaml </em>中添加特性所需的新依赖项。</p><pre class="kz la lb lc fd ld le lf lg aw lh bi"><span id="f3f8" class="li jx hi le b fi lj lk l ll lm"><strong class="le hj">firebase_core: ^1.7.0</strong> <em class="js"># required for initializing firebase app<br/></em><strong class="le hj">firebase_messaging: ^10.0.8</strong> <em class="js"># required for sending/receiving messages through FCM<br/></em><strong class="le hj">flutter_local_notifications: ^6.0.0</strong> <em class="js"># required to show chat notifications</em></span></pre><p id="b156" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">下载上面添加的新依赖项。</p><pre class="kz la lb lc fd ld le lf lg aw lh bi"><span id="36d1" class="li jx hi le b fi lj lk l ll lm"><strong class="le hj">$ flutter pub get</strong></span></pre><h1 id="c617" class="jw jx hi bd jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt bi translated">第 3 步:让你的应用程序接收通知</h1><p id="66ac" class="pw-post-body-paragraph iq ir hi is b it ku iv iw ix kv iz ja jb kw jd je jf kx jh ji jj ky jl jm jn hb bi translated">为了创建本地通知，您需要在您的<em class="js">Android/app/src/main/Android manifest . XML</em>中添加所需的意图过滤器。</p><pre class="kz la lb lc fd ld le lf lg aw lh bi"><span id="a7a6" class="li jx hi le b fi lj lk l ll lm">&lt;intent-filter&gt;<br/>    &lt;action android:name="FLUTTER_NOTIFICATION_CLICK" /&gt;<br/>    &lt;category android:name="android.intent.category.DEFAULT" /&gt;<br/>&lt;/intent-filter&gt;</span></pre><h1 id="bf6d" class="jw jx hi bd jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt bi translated">步骤 4:初始化 Firebase 消息传递和本地通知</h1><p id="0d85" class="pw-post-body-paragraph iq ir hi is b it ku iv iw ix kv iz ja jb kw jd je jf kx jh ji jj ky jl jm jn hb bi translated">在 lib 中创建一个新的 dart 文件<em class="js">firebase/messaging . dart</em>，并在其中初始化 FCM 和本地通知。</p><pre class="kz la lb lc fd ld le lf lg aw lh bi"><span id="7ae8" class="li jx hi le b fi lj lk l ll lm">import 'package:firebase_core/firebase_core.dart';<br/>import 'package:firebase_messaging/firebase_messaging.dart';<br/>import 'package:flutter_local_notifications/flutter_local_notifications.dart';<br/><br/>final FirebaseMessaging _fcm = FirebaseMessaging.<em class="js">instance</em>;<br/>FlutterLocalNotificationsPlugin _flutterLocalNotificationsPlugin;<br/><br/><strong class="le hj">initializeMessaging</strong>() async {<br/>  <strong class="le hj">await Firebase.<em class="js">initializeApp</em>();</strong><br/>  _flutterLocalNotificationsPlugin = FlutterLocalNotificationsPlugin();<br/>  const AndroidInitializationSettings initializationSettingsAndroid = AndroidInitializationSettings("@mipmap/ic_launcher");<br/>  final InitializationSettings initializationSettings = InitializationSettings(android: initializationSettingsAndroid);<br/>  await <strong class="le hj">_flutterLocalNotificationsPlugin.initialize</strong>(initializationSettings, onSelectNotification: selectionNotification);<br/><br/>  <strong class="le hj">FirebaseMessaging.<em class="js">onMessage</em>.listen</strong>((RemoteMessage message) async {<br/>    print("onMessage: $message");<br/>    await <strong class="le hj">handleMessage</strong>(message);<br/>  });<br/>}<br/><br/>Future&lt;dynamic&gt; selectionNotification(String payload) async {<br/>  print('payload: $payload');<br/>}<br/><br/><strong class="le hj">handleMessage</strong>(RemoteMessage message) async {<br/>  const AndroidNotificationDetails androidPlatformChannelSpecifics =<br/>      AndroidNotificationDetails('CHAT', "CHAT", 'CHAT', importance: Importance.<em class="js">max</em>, priority: Priority.<em class="js">high</em>, showWhen: true);<br/>  const NotificationDetails platformChannelSpecifics = NotificationDetails(android: androidPlatformChannelSpecifics);<br/>  await _flutterLocalNotificationsPlugin.show(0, "New Messages", message.data['sender'] + ": " + message.data['message'], platformChannelSpecifics,<br/>      payload: 'CHAT');<br/>}<br/><br/>Future&lt;void&gt; <strong class="le hj">firebaseMessagingBackgroundHandler</strong>(RemoteMessage message) async {<br/>  <strong class="le hj">await initializeMessaging();</strong><br/>  const AndroidNotificationDetails androidPlatformChannelSpecifics =<br/>      AndroidNotificationDetails('CHAT', "CHAT", 'CHAT', importance: Importance.<em class="js">max</em>, priority: Priority.<em class="js">high</em>, showWhen: true);<br/>  const NotificationDetails platformChannelSpecifics = NotificationDetails(android: androidPlatformChannelSpecifics);<br/>  await _flutterLocalNotificationsPlugin.show(0, "New Messages", message.data['sender'] + ": " + message.data['message'], platformChannelSpecifics,<br/>      payload: 'CHAT');<br/>}</span><span id="5dee" class="li jx hi le b fi ln lk l ll lm">Future&lt;String&gt; <strong class="le hj">getFCMToken</strong>() async {<br/>  return await _fcm.getToken();<br/>}</span></pre><p id="4e16" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><em class="js">Firebase . initialize app()</em>使用您在 android 项目中下载的<em class="js"> google-services.json </em>初始化 Firebase 应用程序。</p><p id="1eb6" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">firebase messaging . on message . listen()监听 FCM 消息并调用<em class="js"> handleMessage() </em>在您的设备中显示通知。这将在应用程序处于前台时处理通知。</p><p id="87b9" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><em class="js">firebasemesagingbackgroundhandler()</em>当应用在后台时处理 FCM 消息。</p><p id="4af1" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">getFCMToken()返回 FCM 注册令牌。websocket 服务将使用此令牌向离线(未连接到 websocket)设备发送 FCM 消息。</p><blockquote class="jp jq jr"><p id="d1aa" class="iq ir js is b it iu iv iw ix iy iz ja jt jc jd je ju jg jh ji jv jk jl jm jn hb bi translated">注意:不要在 firebase/messaging.dart 中创建任何类，因为 firebasemesagingbackgroundhandler()是一个匿名函数。</p></blockquote><p id="469d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">最后，从<em class="js"> main.dart </em>初始化 FCM。</p><pre class="kz la lb lc fd ld le lf lg aw lh bi"><span id="17d6" class="li jx hi le b fi lj lk l ll lm">void main() async {<br/>  <strong class="le hj">WidgetsFlutterBinding.<em class="js">ensureInitialized</em>();<br/>  initializeMessaging(); FirebaseMessaging.<em class="js">onBackgroundMessage</em>(firebaseMessagingBackgroundHandler);</strong><br/>  ...<br/>  runApp(MyApp());<br/>}</span></pre><h1 id="0402" class="jw jx hi bd jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt bi translated">步骤 5:在连接时向 websocket 服务发送 FCM 令牌</h1><p id="ad28" class="pw-post-body-paragraph iq ir hi is b it ku iv iw ix kv iz ja jb kw jd je jf kx jh ji jj ky jl jm jn hb bi translated">在这一步，我们将让 websocket 服务知道用户的 FCM 令牌。在 chat.dart 中，当连接到 websocket 时，添加查询以发送用户名和 FCM 令牌。</p><pre class="kz la lb lc fd ld le lf lg aw lh bi"><span id="9f78" class="li jx hi le b fi lj lk l ll lm"><strong class="le hj">String registrationToken = await getFCMToken();</strong><br/>socket = IO.io('&lt;websocket_url&gt;', &lt;String, dynamic&gt;{<br/>  'transports': ['websocket'],<br/>  'autoConnect': false,<br/>  <strong class="le hj">'query': {<br/>    'userName': widget.user,<br/>    'registrationToken': registrationToken<br/>  }</strong><br/>});<br/>socket.connect();</span></pre></div><div class="ab cl lo lp gp lq" role="separator"><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt"/></div><div class="hb hc hd he hf"><p id="668f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">颤振变化完成。我们现在将讨论文章中讨论的 websocket 服务:<a class="ae jo" rel="noopener" href="/nerd-for-tech/nestjs-chat-server-in-nestjs-backed-by-mongodb-687da9aa30bb"> NestJs:由 MongoDB </a>支持的 NestJs 中的聊天服务器。</p><h1 id="b67e" class="jw jx hi bd jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt bi translated">步骤#6:维护服务器上的所有连接用户</h1><p id="7dce" class="pw-post-body-paragraph iq ir hi is b it ku iv iw ix kv iz ja jb kw jd je jf kx jh ji jj ky jl jm jn hb bi translated">在<em class="js"> src/chat/chat.service.ts </em>中，维护一个所有用户和连接用户的并发列表。</p><pre class="kz la lb lc fd ld le lf lg aw lh bi"><span id="fbc2" class="li jx hi le b fi lj lk l ll lm">  private <strong class="le hj">allUsers </strong>= [];<br/>  private <strong class="le hj">connectedUsers </strong>= [];</span><span id="265e" class="li jx hi le b fi ln lk l ll lm">  <strong class="le hj">userConnected</strong>(userName: string, registrationToken: string) {<br/>    let user = { userName: userName, registrationToken: registrationToken };<br/>    const filteredUsers = this.allUsers.filter(u =&gt; u.userName === userName);<br/>    if (filteredUsers.length == 0) {<br/>      this.allUsers.push(user);<br/>    } else {<br/>      user = filteredUsers[0];<br/>      user.registrationToken = registrationToken;<br/>    }<br/>    this.connectedUsers.push(userName);<br/>    console.log("All Users", this.allUsers);<br/>    console.log("Connected Users", this.connectedUsers);<br/>  }</span><span id="deba" class="li jx hi le b fi ln lk l ll lm">  <strong class="le hj">userDisconnected</strong>(userName: string) {<br/>    let userIndex = this.connectedUsers.indexOf(userName);<br/>    this.connectedUsers.splice(userIndex, 1);<br/>    console.log("All Users", this.allUsers);<br/>    console.log("Connected Users", this.connectedUsers);<br/>  }</span></pre><p id="07bf" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><em class="js"> userConnected() </em>在<em class="js"> allUsers </em>和<em class="js"> connectedUsers </em>列表中添加一个用户(带有 FCM 令牌)。</p><p id="851e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><em class="js"> userDisconnected() </em>从<em class="js"> connectedUsers </em>列表中删除用户。</p><h1 id="c067" class="jw jx hi bd jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt bi translated">步骤 7:从 websocket 处理程序调用相应的方法</h1><p id="272c" class="pw-post-body-paragraph iq ir hi is b it ku iv iw ix kv iz ja jb kw jd je jf kx jh ji jj ky jl jm jn hb bi translated">在<em class="js">src/chat/chat . gateway . ts</em>中，提取 flutter app 发送的查询参数<em class="js">userName</em>&amp;<em class="js">registration token</em>(上面的步骤#5)，调用上面添加的相应方法。</p><pre class="kz la lb lc fd ld le lf lg aw lh bi"><span id="769d" class="li jx hi le b fi lj lk l ll lm">  <strong class="le hj">handleConnection</strong>(socket: any) {<br/>    <strong class="le hj">const query = socket.handshake.query;</strong><br/>    console.log('Connect', query);<br/>    <strong class="le hj">this.chatService.userConnected(query.userName, query.registrationToken);</strong><br/>    process.nextTick(async () =&gt; {<br/>      socket.emit('allChats', await this.chatService.getChats());<br/>    });<br/>  }</span><span id="872a" class="li jx hi le b fi ln lk l ll lm">  <strong class="le hj">handleDisconnect</strong>(socket: any) {<br/>    <strong class="le hj">const query = socket.handshake.query;</strong><br/>    console.log('Disconnect', socket.handshake.query);<br/>    <strong class="le hj">this.chatService.userDisconnected(query.userName);</strong><br/>  }</span></pre><h1 id="fd6b" class="jw jx hi bd jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt bi translated">步骤 8:设置 Firebase 管理</h1><p id="4694" class="pw-post-body-paragraph iq ir hi is b it ku iv iw ix kv iz ja jb kw jd je jf kx jh ji jj ky jl jm jn hb bi translated">在项目的<em class="js"> package.json </em>中添加 firebase-admin 依赖项。</p><pre class="kz la lb lc fd ld le lf lg aw lh bi"><span id="7576" class="li jx hi le b fi lj lk l ll lm">  "dependencies": {<br/>    ...<br/>    <strong class="le hj">"firebase-admin": "^10.0.0",</strong><br/>    ...<br/>  },</span></pre><p id="ec62" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">安装新的依赖项:</p><pre class="kz la lb lc fd ld le lf lg aw lh bi"><span id="7478" class="li jx hi le b fi lj lk l ll lm"><strong class="le hj">$ npm install</strong></span></pre><p id="d841" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在 tsconfig.json 中，添加以下编译器选项以允许解析 json 模块:</p><pre class="kz la lb lc fd ld le lf lg aw lh bi"><span id="2cb4" class="li jx hi le b fi lj lk l ll lm">"resolveJsonModule": true,<br/>"allowJs": true,</span></pre><p id="0a90" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">按照这里的步骤在同一个 firebase 项目中设置一个 firebase 服务帐户。下载生成的<em class="js"> serviceAccountKey.json </em>并放置在<em class="js"> src/auth </em>中。在同一个路径<em class="js"> src/auth </em>中，创建另一个文件<em class="js"> firebaseAdmin.ts </em>来初始化 firebaseAdmin 并导出初始化后的 app。</p><pre class="kz la lb lc fd ld le lf lg aw lh bi"><span id="fd69" class="li jx hi le b fi lj lk l ll lm">import * as firebase from 'firebase-admin';<br/><strong class="le hj">import * as serviceAccount from './serviceAccountKey.json';</strong></span><span id="0350" class="li jx hi le b fi ln lk l ll lm">const firebase_params = {<br/>    type: serviceAccount.type,<br/>    projectId: serviceAccount.project_id,<br/>    privateKeyId: serviceAccount.private_key_id,<br/>    privateKey: serviceAccount.private_key,<br/>    clientEmail: serviceAccount.client_email,<br/>    clientId: serviceAccount.client_id,<br/>    authUri: serviceAccount.auth_uri,<br/>    tokenUri: serviceAccount.token_uri,<br/>    authProviderX509CertUrl: serviceAccount.auth_provider_x509_cert_url,<br/>    clientC509CertUrl: serviceAccount.client_x509_cert_url<br/>}</span><span id="3ed8" class="li jx hi le b fi ln lk l ll lm"><strong class="le hj">const defaultApp = firebase.initializeApp({<br/>    credential: firebase.credential.cert(firebase_params),<br/>    databaseURL: "</strong><a class="ae jo" href="https://fir-auth-bd895.firebaseio.com" rel="noopener ugc nofollow" target="_blank"><strong class="le hj">&lt;</strong></a><strong class="le hj">firebase_db_url&gt;"<br/>});</strong></span><span id="7a44" class="li jx hi le b fi ln lk l ll lm">export {<br/>    defaultApp<br/>}</span></pre><h1 id="8029" class="jw jx hi bd jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt bi translated">步骤 9:向断开连接的用户发送 FCM 消息</h1><p id="e947" class="pw-post-body-paragraph iq ir hi is b it ku iv iw ix kv iz ja jb kw jd je jf kx jh ji jj ky jl jm jn hb bi translated">在<em class="js">src/chat/chat . service . ts</em>中，创建一个向断开连接的用户发送 FCM 消息的方法。</p><pre class="kz la lb lc fd ld le lf lg aw lh bi"><span id="ba29" class="li jx hi le b fi lj lk l ll lm">async <strong class="le hj">sendMessagesToOfflineUsers</strong>(chat: any) {<br/>    var messagePayload = {<br/>      data: {<br/>        type: "CHAT",<br/>        title: 'chat',<br/>        message: chat.message,<br/>        sender: chat.sender,<br/>        recipient: chat.recipient,<br/>        time: chat.time<br/>      },<br/>      <strong class="le hj">tokens: []</strong><br/>    };<br/>    <strong class="le hj">const userTokens = this.allUsers.filter(user =&gt; !this.connectedUsers.includes(user.userName)).map(user =&gt; { return user.registrationToken });</strong><br/>    if (userTokens.length == 0) {<br/>      return;<br/>    }<br/>    <strong class="le hj">messagePayload.tokens = userTokens;</strong><br/>    try {<br/>      <strong class="le hj">await defaultApp.messaging().sendMulticast(messagePayload);</strong><br/>    } catch (ex) {<br/>      console.log(JSON.stringify(ex));<br/>    }<br/>  }</span></pre><p id="e3df" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">最后，当新的聊天到达<em class="js">src/chat/chat . gateway . ts</em>时调用这个方法。</p><pre class="kz la lb lc fd ld le lf lg aw lh bi"><span id="e829" class="li jx hi le b fi lj lk l ll lm">  @Bind(MessageBody(), ConnectedSocket())<br/>  @SubscribeMessage('chat')<br/>  async handleNewMessage(chat: Chat, sender: any) {<br/>    console.log('New Chat', chat);<br/>    await this.chatService.saveChat(chat);<br/>    sender.emit('newChat', chat);<br/>    sender.broadcast.emit('newChat', chat);<br/>    <strong class="le hj">await this.chatService.sendMessagesToOfflineUsers(chat);</strong><br/>  }</span></pre><h1 id="0d42" class="jw jx hi bd jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt bi translated">步骤 10:让我们验证一下</h1><p id="e47b" class="pw-post-body-paragraph iq ir hi is b it ku iv iw ix kv iz ja jb kw jd je jf kx jh ji jj ky jl jm jn hb bi translated">我已经在本地启动了聊天服务，并使用<a class="ae jo" href="https://ngrok.com/" rel="noopener ugc nofollow" target="_blank"> <strong class="is hj"> ngrok </strong> </a>从一个公共 URL 到这个服务。<br/>我使用<a class="ae jo" href="https://amritb.github.io/socketio-client-tool/v1/#" rel="noopener ugc nofollow" target="_blank"> socket.io 客户端工具</a>连接到聊天服务，使用虚拟查询参数模拟消息传递:</p><pre class="kz la lb lc fd ld le lf lg aw lh bi"><span id="b322" class="li jx hi le b fi lj lk l ll lm">{“query”: {“userName”: “Khushboo”, “registrationToken”: “”}}</span></pre><p id="aae7" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我正在 android 模拟器中运行 flutter 应用程序，并访问与另一个用户的聊天。</p><p id="2159" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">当两个用户都连接时，用户可以通过 websocket 进行对话。</p><figure class="kz la lb lc fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lv"><img src="../Images/bb74da5c16e02d677820dab23f9d5d5b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UspkFICGTyL-WDo79oDaSQ.png"/></div></div></figure><p id="caf8" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">当 android 用户离开聊天时，它可以通过 FCM 接收聊天通知。</p><figure class="kz la lb lc fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lw"><img src="../Images/bffc596897b20aa9a2015ae8c5b14cde.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bjz0a1jwcSaL37NvWDRtOQ.png"/></div></div></figure></div><div class="ab cl lo lp gp lq" role="separator"><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt"/></div><div class="hb hc hd he hf"><blockquote class="jp jq jr"><p id="3c9f" class="iq ir js is b it iu iv iw ix iy iz ja jt jc jd je ju jg jh ji jv jk jl jm jn hb bi translated">代码库:<em class="hi"><br/></em><a class="ae jo" href="https://github.com/sharmavikashkr/chat_app_flutter" rel="noopener ugc nofollow" target="_blank">https://github.com/sharmavikashkr/chat_app_flutter</a><br/><a class="ae jo" href="https://github.com/sharmavikashkr/chat-service-nestjs" rel="noopener ugc nofollow" target="_blank">https://github.com/sharmavikashkr/chat-service-nestjs</a></p></blockquote></div></div>    
</body>
</html>