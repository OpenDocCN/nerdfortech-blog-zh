<html>
<head>
<title>Vue.js and Symfony forms</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Vue.js和Symfony表单</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/vue-js-and-symfony-forms-ba5139f77f5f?source=collection_archive---------2-----------------------#2021-05-09">https://medium.com/nerd-for-tech/vue-js-and-symfony-forms-ba5139f77f5f?source=collection_archive---------2-----------------------#2021-05-09</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="053c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如何将<strong class="ih hj"> Symfony </strong>中的<strong class="ih hj"> Vue.js </strong>请求作为正常表单提交处理</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es jd"><img src="../Images/7efedfcc1fc3fd4f7b961adf7512f4f7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*unD28396N31q-UBk.png"/></div></div></figure><p id="e2ef" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Symfony为我们提供了<code class="du jp jq jr js b">symfony/form</code>包，这使得处理呈现和提交表单比以往更加容易。很快，随着新的“<a class="ae jt" href="https://symfony.com/blog/new-in-symfony-5-3-form-handler-helper" rel="noopener ugc nofollow" target="_blank">表单处理助手</a>”的出现，这将变得更加容易，但这不是这里的重点。</p><p id="f9bf" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">当我第一次开始使用<strong class="ih hj"> Vue.js </strong>时让我恼火的是，我非常喜欢对直接在<strong class="ih hj">分支</strong> ( <em class="ju">非常方便</em>)中呈现的表单说<em class="ju">再见</em>。</p><p id="407f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我已经开始为<strong class="ih hj"> Vue.js </strong>寻找一些<em class="ju">表单生成器</em>包。有几个，但是到目前为止我一个都不喜欢。在最坏的情况下，我可以用类似于<code class="du jp jq jr js b">/get-form-view</code>的某种API方法来呈现表单，但这与的<strong class="ih hj"> Vue.js </strong>工作流/概念是如此的<strong class="ih hj">。</strong></p><p id="79e2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">因此...我开始问自己并思考:</p></div><div class="ab cl jv jw gp jx" role="separator"><span class="jy bw bk jz ka kb"/><span class="jy bw bk jz ka kb"/><span class="jy bw bk jz ka"/></div><div class="hb hc hd he hf"><p id="75a8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">"<em class="ju">如何在</em><strong class="ih hj"><em class="ju">vue . js</em></strong><em class="ju">中渲染表单，并在</em><strong class="ih hj"><em class="ju">Symfony</em></strong><em class="ju">中处理？虽然我可以像Twig处理它一样停止渲染表单——但我肯定希望保留由</em> <strong class="ih hj"> <em class="ju"> Symfony </em> </strong>提供的表单验证/处理功能。”</p></div><div class="ab cl jv jw gp jx" role="separator"><span class="jy bw bk jz ka kb"/><span class="jy bw bk jz ka kb"/><span class="jy bw bk jz ka"/></div><div class="hb hc hd he hf"><p id="66d9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这里有几个问题需要解决:</p><ul class=""><li id="9591" class="kc kd hi ih b ii ij im in iq ke iu kf iy kg jc kh ki kj kk bi translated"><strong class="ih hj"> csrf </strong>令牌的处理，</li><li id="f954" class="kc kd hi ih b ii kl im km iq kn iu ko iy kp jc kh ki kj kk bi translated">重建<strong class="ih hj">要求<em class="ju">”</em></strong><em class="ju">其结构必须与</em><strong class="ih hj"><em class="ju">Symfony</em></strong><em class="ju">标准格式提交</em> <strong class="ih hj"> <em class="ju">”、</em> </strong>中提供的结构相同</li></ul><p id="6440" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi kq translated"><span class="l kr ks kt bm ku kv kw kx ky di">C</span>T64】SRF令牌</p><h1 id="9cb3" class="kz la hi bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated"><strong class="ak">后端</strong></h1><p id="e249" class="pw-post-body-paragraph if ig hi ih b ii lx ik il im ly io ip iq lz is it iu ma iw ix iy mb ja jb jc hb bi translated">默认情况下，用<code class="du jp jq jr js b">symfony/form</code>包创建的每个表单都打开了CSRF令牌验证。这进一步意味着提供给表单处理器<strong class="ih hj">的每个请求必须</strong>包含CSRF令牌。这里有几个解决方案，我将使用我为我的案例找到的2个。</p></div><div class="ab cl jv jw gp jx" role="separator"><span class="jy bw bk jz ka kb"/><span class="jy bw bk jz ka kb"/><span class="jy bw bk jz ka"/></div><div class="hb hc hd he hf"><p id="9a55" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">坏的那个(除非只是你的私人项目)——<em class="ju">禁用CSR令牌验证</em> </strong></p><p id="c2e3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">每个表单类(意味着它从<code class="du jp jq jr js b">Symfony\Component\Form\AbstractType</code>扩展而来)都允许我们关闭CSRF验证。</p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="mc md l"/></div></figure><p id="4af4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">虽然这对于小型私人项目或内部项目来说没问题，但对于公众可访问的项目来说却是一个大问题。</p></div><div class="ab cl jv jw gp jx" role="separator"><span class="jy bw bk jz ka kb"/><span class="jy bw bk jz ka kb"/><span class="jy bw bk jz ka"/></div><div class="hb hc hd he hf"><p id="22a5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">用Vue.js调用发送和处理csrf令牌</strong> — <strong class="ih hj">好办法</strong></p><ol class=""><li id="8d4f" class="kc kd hi ih b ii ij im in iq ke iu kf iy kg jc me ki kj kk bi translated">首先要做的是…像上面一样禁用<code class="du jp jq jr js b">csrf_protection</code>。</li></ol><p id="b28f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">2.现在我们需要<code class="du jp jq jr js b">CsrfTokenValidatorService</code></p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="mc md l"/></div></figure><p id="ce8d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">3.现在必须在两个地方检查令牌</p><ul class=""><li id="32c0" class="kc kd hi ih b ii ij im in iq ke iu kf iy kg jc kh ki kj kk bi translated">正如我在另一篇文章中所写的那样(<a class="ae jt" rel="noopener" href="/@Volmarg/vue-js-and-symfony-user-authentication-19ca983126d"> <strong class="ih hj">这里是</strong> </a>)，每个请求都要经过<code class="du jp jq jr js b">Authenticator</code>——所以请求必须在其中得到验证，因为这在触发<code class="du jp jq jr js b">KernelRequestEvent</code>之前被称为<strong class="ih hj"/></li><li id="dc4e" class="kc kd hi ih b ii kl im km iq kn iu ko iy kp jc kh ki kj kk bi translated"><code class="du jp jq jr js b">KernelRequest::REQUEST</code></li></ul><p id="55a9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> KernelRequestListener </strong></p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="mc md l"/></div></figure><p id="3db0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">认证者</strong></p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="mc md l"/></div></figure><p id="2607" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">4.我们还需要传递CSRF令牌的路线</p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="mc md l"/></div></figure><h1 id="c648" class="kz la hi bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">前端</h1><p id="7ee3" class="pw-post-body-paragraph if ig hi ih b ii lx ik il im ly io ip iq lz is it iu ma iw ix iy mb ja jb jc hb bi translated">现在，我没有在每个<strong class="ih hj"> Axios </strong>调用中一遍又一遍地添加<code class="du jp jq jr js b">getCsrf</code>，而是编写了自己的插件来处理带有csrf令牌调用的post调用。</p><p id="f7a1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">插件</strong></p><p id="be93" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">简单地说，这个插件做了两件事:</p><ul class=""><li id="4fa2" class="kc kd hi ih b ii ij im in iq ke iu kf iy kg jc kh ki kj kk bi translated">来电后端:"<em class="ju">嘿——给我CSRF令牌——为了这个</em><strong class="ih hj"><em class="ju">UUID</em></strong><em class="ju"/>，</li><li id="a248" class="kc kd hi ih b ii kl im km iq kn iu ko iy kp jc kh ki kj kk bi translated">然后打第二个电话“<em class="ju">嘿——我拿到了UUID的CSRF，请检查一下，让我过去”</em></li></ul><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="mc md l"/></div></figure><p id="aeb9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">当然，没有人说必须在ajax调用完成的时候获取令牌，也可以在<code class="du jp jq jr js b">beforeMount</code>中获取令牌，然后以表单形式提供，我认为没有理由这样做，因为我们无论如何都必须为令牌进行通信。</p><p id="6e03" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">因此..如果我们提供假的csrf令牌，它实际上能正确工作吗？<strong class="ih hj">是</strong> —我用代码中的硬编码令牌做了一个测试，请求被<strong class="ih hj">拒绝</strong>。</p><p id="fdcf" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">不是完美的解决方案</strong></p><p id="1859" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">虽然这听起来并不完美，但它的工作方式与Symfony处理CSRF令牌的方式非常相似:</p><ul class=""><li id="7972" class="kc kd hi ih b ii ij im in iq ke iu kf iy kg jc kh ki kj kk bi translated">它使用<code class="du jp jq jr js b">form_name</code>而不是<code class="du jp jq jr js b">UUID</code>，</li><li id="773b" class="kc kd hi ih b ii kl im km iq kn iu ko iy kp jc kh ki kj kk bi translated">它根据每个请求生成新的令牌，</li></ul></div><div class="ab cl jv jw gp jx" role="separator"><span class="jy bw bk jz ka kb"/><span class="jy bw bk jz ka kb"/><span class="jy bw bk jz ka"/></div><div class="hb hc hd he hf"><p id="4f46" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi kq translated"><span class="l kr ks kt bm ku kv kw kx ky di">R</span>R<strong class="ih hj">e构建请求</strong></p><p id="3399" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在，一旦CSRF令牌验证开始工作，实际上最简单的部分就来了。我们只需要一个逻辑，它将<em class="ju">"接受</em><strong class="ih hj"><em class="ju">Axios</em></strong><em class="ju">请求— json" </em>，并将其转换成在<strong class="ih hj"> Symfony </strong>中正常使用的适当请求数据。</p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="mc md l"/></div></figure><p id="0d37" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">就像这样使用它:</p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="mc md l"/></div></figure></div><div class="ab cl jv jw gp jx" role="separator"><span class="jy bw bk jz ka kb"/><span class="jy bw bk jz ka kb"/><span class="jy bw bk jz ka"/></div><div class="hb hc hd he hf"><p id="3aa3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">我对这个方案的想法</strong></p><p id="fe3b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我在这里得到的唯一主要关注是，<code class="du jp jq jr js b">getCsrf</code>路线应该隐藏在认证之后，并且只有<code class="du jp jq jr js b">login</code>应该被允许不经过认证就通过它，否则根据“<em class="ju">伪造形式</em>”和复制的前端逻辑，任何人都可以很容易地获取CSRF令牌。</p><p id="4f6a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">其他不错的“以防万一”保护将只是检查请求来自哪里——如果在我们的域之外——阻止它，因此没有人会得到令牌。</p><p id="7f63" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">除此之外，只是需要花一点时间来理解如何生成CSRF令牌、验证它、处理请求等等——所以第一次这样做很耗时，但除此之外，它可以被复制和重新应用。</p><p id="224e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">嘿……Symfony表单验证正常工作了！</p></div></div>    
</body>
</html>