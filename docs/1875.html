<html>
<head>
<title>Secure your firebase's google-services.json file in android</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在android中保护你的firebase的google-services.json文件</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/secure-your-firebases-google-services-json-file-in-android-16680f8e5fb4?source=collection_archive---------3-----------------------#2021-04-11">https://medium.com/nerd-for-tech/secure-your-firebases-google-services-json-file-in-android-16680f8e5fb4?source=collection_archive---------3-----------------------#2021-04-11</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/809e19415b76502af17df6baf7a3b883.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*buwRtr4cMKeoBpXLCulXtg.jpeg"/></div></div></figure><p id="23a7" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如今，firebase通常用于android项目，因为它提供了一个快速记录崩溃的解决方案，提供了一个存储应用程序数据的数据库，以及许多其他东西。在android应用程序中实现firebase最常用的方法包括从firebase控制台下载<strong class="is hj"> google-services.json </strong>文件，并将其放在我们项目的应用程序目录中。这个文件负责在应用程序启动时自动初始化firebase。<br/>但是你知道吗，这个文件包含了一些不应该泄露的重要密钥和网址，因为它可能会破坏你的应用程序的安全性。此外，你有没有想过，在逆向工程的帮助下，从你的应用程序中获取那些密钥和URL有多容易？<br/>如果你使用一些逆向工程工具如<a class="ae jo" href="https://ibotpeaches.github.io/Apktool/install/" rel="noopener ugc nofollow" target="_blank"> Apktool </a>来反编译你的apk，那么你会发现这些键出现在你的应用程序的strings.xml文件中，如下图所示</p><figure class="jq jr js jt fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es jp"><img src="../Images/0d165fcb57cb51980dee24932a35fedd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tAZ9GguVeghOGQjHNH860A.png"/></div></div></figure><p id="fdbc" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">任何人都可以提取它，并可能篡改您的应用程序的安全性。</p><p id="7f17" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如何将键和URL存储在strings.xml中？<br/> 基本上，firebase会在编译时将这些来自<strong class="is hj"> google-services.json </strong>文件的密钥放入strings.xml文件，并在自动初始化时使用它们。<br/>那么，是否有可能停止这种做法，使这些密钥和URL无法从我们的应用程序中检索出来，从而有助于减少篡改应用程序的机会？<br/>答案是<strong class="is hj">是的。</strong></p><figure class="jq jr js jt fd ij er es paragraph-image"><div class="er es ju"><img src="../Images/623cf528860c99df0d3786b5a788efbd.png" data-original-src="https://miro.medium.com/v2/resize:fit:660/1*ZQMHL5RDGMEtp3dtetBtJQ.gif"/></div></figure><p id="971d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如何做到这一点？<br/> 第一步是从<strong class="is hj"> google-services.json </strong>文件中获取所需的密钥，如下文中的<em class="jv">所示，并将它们存储在您的应用程序中。你可以看看我以前的<a class="ae jo" href="https://mittalkartik1.medium.com/secret-management-in-android-c2a44f23fc59" rel="noopener">文章</a>来了解如何在android中安全地存储密钥。</em></p><figure class="jq jr js jt fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es jw"><img src="../Images/e000ccedc0743af43353625cfd335912.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qfhK8GQBFVw8IeeaHeHXng.png"/></div></div></figure><p id="4178" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">将这些密钥存储在应用程序中后，您可以从应用程序中删除<strong class="is hj"> google-services.json </strong>文件。同样，如果你已经在你的应用级build.gradle文件中添加了下面一行，那么你必须<strong class="is hj">移除</strong>这一行。</p><pre class="jq jr js jt fd jx jy jz ka aw kb bi"><span id="6dcf" class="kc kd hi jy b fi ke kf l kg kh">apply plugin: ‘com.google.gms.google-services’</span></pre><p id="9004" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在，您想通过将以下代码添加到清单文件来禁用firebase的自动初始化—</p><pre class="jq jr js jt fd jx jy jz ka aw kb bi"><span id="0127" class="kc kd hi jy b fi ke kf l kg kh">&lt;provider<br/>    android:name="com.google.firebase.provider.FirebaseInitProvider"<br/>    android:authorities="${applicationId}.firebaseinitprovider"<br/>    tools:node="remove"<br/>    /&gt;</span></pre><p id="d1ed" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在，最后一步是手动初始化firebase，方法是放置您之前从<strong class="is hj"> google-services.json </strong>文件中获得的相应密钥——</p><figure class="jq jr js jt fd ij"><div class="bz dy l di"><div class="ki kj l"/></div></figure><p id="e79e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">注意—如果您已经在项目中添加了firebase crashlytics，那么您必须在应用程序级'<em class="jv"> build.gradle </em>'文件中添加以下代码，以防止在发布时自动将映射文件上传到firebase crashlytics:-</p><pre class="jq jr js jt fd jx jy jz ka aw kb bi"><span id="756b" class="kc kd hi jy b fi ke kf l kg kh">android <strong class="jy hj">{<br/>    </strong><em class="jv">//...<br/>    </em>buildTypes <strong class="jy hj">{<br/>        </strong>release <strong class="jy hj">{<br/>            </strong><em class="jv">//...<br/>            </em><strong class="jy hj"><em class="jv">firebaseCrashlytics {<br/>                mappingFileUploadEnabled false<br/>            }</em><br/>        }<br/>    }<br/>}</strong></span></pre><p id="7b20" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">但是在阻止映射文件的自动上传后，您的信息将不会被保留，您将不再看到崩溃发生的特定行号和活动名称，如您在下面的截图中所见——</p><figure class="jq jr js jt fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es kk"><img src="../Images/9622c3ce8ad295cf08e3897f98de998d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pOuRVpKIyCdGGG6ycItXrQ.png"/></div></div></figure><p id="b6ef" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">但是不要担心，为了保存信息并获得正确的崩溃报告，您必须将以下代码添加到应用程序的<strong class="is hj"> proguard-rules.pro </strong>文件中</p><figure class="jq jr js jt fd ij"><div class="bz dy l di"><div class="ki kj l"/></div></figure></div><div class="ab cl kl km gp kn" role="separator"><span class="ko bw bk kp kq kr"/><span class="ko bw bk kp kq kr"/><span class="ko bw bk kp kq"/></div><div class="hb hc hd he hf"><h1 id="a0ef" class="ks kd hi bd kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo bi translated"><strong class="ak">更新—2022年2月13日</strong></h1><p id="25ed" class="pw-post-body-paragraph iq ir hi is b it lp iv iw ix lq iz ja jb lr jd je jf ls jh ji jj lt jl jm jn hb bi translated">如果您在firebase crashlytics中得到混乱的崩溃报告，那么您可能需要在生成apk后手动上传一个映射文件到firebase。但是由于firebase没有为此提供任何官方文档，我们将使用android studio来定制上传映射文件的gradle任务，这样就可以实现了。</p><p id="82bf" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">但是在开始之前，让我们看看当你生成一个apk时，在后台发生了什么—</p><blockquote class="lu lv lw"><p id="62ed" class="iq ir jv is b it iu iv iw ix iy iz ja lx jc jd je ly jg jh ji lz jk jl jm jn hb bi translated">因此，基本上，当你生成一个apk时，firebase crashlytics会在<strong class="is hj"><em class="hi">injectCrashlyticsMappingFileId</em></strong>gradle task的帮助下生成一个<strong class="is hj"> UUID </strong>，并将其与应用关联起来。之后，执行<strong class="is hj"><em class="hi">uploadCrashlyticsMappingFile</em></strong><em class="hi"/>grad任务，将映射文件上传到特定UUID的firebase。因此，最终，当特定apk中发生崩溃时，firebase将检查apk中存在的属于crashlytics UUID的映射文件，以消除崩溃报告的影响。</p></blockquote><figure class="jq jr js jt fd ij er es paragraph-image"><div class="er es ma"><img src="../Images/714f936500ebce20aa3210cbfb42123f.png" data-original-src="https://miro.medium.com/v2/resize:fit:800/1*fcwLWixk10G27dEqiHOM-Q.gif"/></div></figure><h1 id="05db" class="ks kd hi bd kt ku mb kw kx ky mc la lb lc md le lf lg me li lj lk mf lm ln lo bi translated">第一步</h1><p id="37a8" class="pw-post-body-paragraph iq ir hi is b it lp iv iw ix lq iz ja jb lr jd je jf ls jh ji jj lt jl jm jn hb bi translated">你需要在你的应用级'<em class="jv"> build.gradle' </em>中再次将<strong class="is hj"><em class="jv">mappingFileUploadEnabled</em></strong>设置为<strong class="is hj"> true </strong>，如果你之前已经将此设置为false。这将确保我们每次生成apk时都会生成一个32位的UUID。</p><pre class="jq jr js jt fd jx jy jz ka aw kb bi"><span id="4f39" class="kc kd hi jy b fi ke kf l kg kh">android <strong class="jy hj">{<br/>    </strong><em class="jv">//...<br/>    </em>buildTypes <strong class="jy hj">{<br/>        </strong>release <strong class="jy hj">{<br/>            </strong><em class="jv">//...<br/>            </em><strong class="jy hj"><em class="jv">firebaseCrashlytics {<br/>                mappingFileUploadEnabled true<br/>            }</em><br/>        }<br/>    }<br/>}</strong></span></pre><h1 id="4ccc" class="ks kd hi bd kt ku mb kw kx ky mc la lb lc md le lf lg me li lj lk mf lm ln lo bi translated">第二步</h1><p id="37f2" class="pw-post-body-paragraph iq ir hi is b it lp iv iw ix lq iz ja jb lr jd je jf ls jh ji jj lt jl jm jn hb bi translated">您需要通过在您的项目级<em class="jv"> build.gradle </em>的底部添加以下代码来限制<strong class="is hj">uploadcrashlyticsmappingfilererelease</strong>任务的执行</p><figure class="jq jr js jt fd ij"><div class="bz dy l di"><div class="ki kj l"/></div></figure><blockquote class="lu lv lw"><p id="88b7" class="iq ir jv is b it iu iv iw ix iy iz ja lx jc jd je ly jg jh ji lz jk jl jm jn hb bi translated">注意—任务名称可能会有所不同，这取决于您要为其生成apk的构建风格。例如，如果您有一个构建变体“uat ”,那么任务的名称将是uploadCrashlyticsMappingFile<strong class="is hj">Uat</strong>Release。</p></blockquote><h1 id="226d" class="ks kd hi bd kt ku mb kw kx ky mc la lb lc md le lf lg me li lj lk mf lm ln lo bi translated">第三步</h1><p id="03fc" class="pw-post-body-paragraph iq ir hi is b it lp iv iw ix lq iz ja jb lr jd je jf ls jh ji jj lt jl jm jn hb bi translated">为您想要的构建变体生成apk。成功创建apk后，将生成一个32位UUID和映射文件，用于手动上传映射文件。</p><h1 id="712a" class="ks kd hi bd kt ku mb kw kx ky mc la lb lc md le lf lg me li lj lk mf lm ln lo bi translated">步骤4</h1><p id="0aa0" class="pw-post-body-paragraph iq ir hi is b it lp iv iw ix lq iz ja jb lr jd je jf ls jh ji jj lt jl jm jn hb bi translated">现在，您需要替换您在项目级<em class="jv"> build.gradle </em>中添加的代码，如下所示。另外，请注意，语法可能会根据您要使用的gradle版本而有所不同。为此，我使用了gradle版本<strong class="is hj"> 7.2 </strong>。</p><figure class="jq jr js jt fd ij"><div class="bz dy l di"><div class="ki kj l"/></div></figure><ul class=""><li id="12fb" class="mg mh hi is b it iu ix iy jb mi jf mj jj mk jn ml mm mn mo bi translated"><strong class="is hj"> <em class="jv"> mappingFileId </em> </strong> —它是一个32位的UUID，将从<em class="jv">com _ crashlytics _ build _ id</em><strong class="is hj"><em class="jv">中获得。</em> </strong> <em class="jv"> xml </em>文件存在于"<em class="jv">/app/build/generated/crashlytics/RES/{ build variant }/values "</em>路径中，如下图所示—</li></ul><figure class="jq jr js jt fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mp"><img src="../Images/8c6ae3a8bbe484bad6d35d2a9f9c77d0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uygyhisLsWzgp-mkc0MOyw.png"/></div></div></figure><ul class=""><li id="b6c0" class="mg mh hi is b it iu ix iy jb mi jf mj jj mk jn ml mm mn mo bi translated"><strong class="is hj"><em class="jv">path _ to _ mapping _ file</em></strong><em class="jv">—是已经生成的映射文件的绝对路径</em>出现在<em class="jv">"/app/build/outputs/mapping/{ build variant }/mapping . txt " path</em>中，如下图所示—</li></ul><figure class="jq jr js jt fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mq"><img src="../Images/7e3c529e17ffdf0dabb541d223c893b3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ib91ZMhqfyam4rwqkRRZLw.png"/></div></div></figure><ul class=""><li id="7603" class="mg mh hi is b it iu ix iy jb mi jf mj jj mk jn ml mm mn mo bi translated"><strong class="is hj"><em class="jv">path _ to _ resource _ root</em></strong><em class="jv">—</em>为此，您需要创建一个名为“<em class="jv">values . XML”</em>的文件，并将其放在“values”命名文件夹中，并使用values文件夹的父目录的绝对路径。例如，如果values.xml的路径是"<em class="jv">C:\ \ Users \ \ HP \ \ Downloads \ \ values \ \ values . XML "</em>，那么'<em class="jv"> path_to_resource_root' </em>将是"<em class="jv"> C:\\Users\\HP\\Downloads "。</em>values . XML文件的内容如下所示</li></ul><pre class="jq jr js jt fd jx jy jz ka aw kb bi"><span id="d5f7" class="kc kd hi jy b fi ke kf l kg kh">&lt;?xml version="1.0" encoding="utf-8"?&gt;<br/>&lt;resources&gt;<br/>    &lt;string name="google_app_id" translatable="false"&gt;           <strong class="jy hj"><em class="jv">mobilesdk_app_id </em></strong>&lt;/string&gt;<br/>&lt;/resources&gt;</span></pre><h1 id="044d" class="ks kd hi bd kt ku mb kw kx ky mc la lb lc md le lf lg me li lj lk mf lm ln lo bi translated">第五步</h1><p id="62eb" class="pw-post-body-paragraph iq ir hi is b it lp iv iw ix lq iz ja jb lr jd je jf ls jh ji jj lt jl jm jn hb bi translated">最后一步是使用android studio中的终端执行您之前在项目级<em class="jv"> build.gradle </em>中指定的定制任务，如下所示</p><pre class="jq jr js jt fd jx jy jz ka aw kb bi"><span id="7504" class="kc kd hi jy b fi ke kf l kg kh">gradlew uploadCrashlyticsMappingFileRelease</span></pre><p id="fc94" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">等待任务执行完成，现在就可以开始了。</p></div><div class="ab cl kl km gp kn" role="separator"><span class="ko bw bk kp kq kr"/><span class="ko bw bk kp kq kr"/><span class="ko bw bk kp kq"/></div><div class="hb hc hd he hf"><p id="0f98" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">感谢您阅读这篇文章。如果你遇到任何问题，请告诉我。你可以在<a class="ae jo" href="https://www.linkedin.com/in/kartik-mittal-18ab23106" rel="noopener ugc nofollow" target="_blank"> LinkedIn </a>和<a class="ae jo" href="https://www.facebook.com/kartik.mittal.7739" rel="noopener ugc nofollow" target="_blank">脸书</a>上联系我。</p></div></div>    
</body>
</html>