<html>
<head>
<title>Play Bach: let a neural network play for you. Part 2</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">演奏巴赫:让一个神经网络为你演奏。第二部分</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/play-bach-let-a-neural-network-play-for-you-part-2-3ee01b729057?source=collection_archive---------22-----------------------#2021-05-28">https://medium.com/nerd-for-tech/play-bach-let-a-neural-network-play-for-you-part-2-3ee01b729057?source=collection_archive---------22-----------------------#2021-05-28</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="cb6a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我不知道如何演奏音乐。但是我仍然可以玩音乐。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es jd"><img src="../Images/e054d759a2498c19ce9f7714c79ee848.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zwjE2HENTU0lrvAZa_V40w.jpeg"/></div></div></figure><blockquote class="jp jq jr"><p id="34e9" class="if ig js ih b ii ij ik il im in io ip jt ir is it ju iv iw ix jv iz ja jb jc hb bi translated">这是一系列文章的一部分，这些文章将探讨该项目的许多方面，包括静态MIDI文件生成、实时流、Tensorflow/Keras顺序和功能模型、LSTM、过拟合和欠拟合、注意机制、嵌入层、多头模型、概率分布、向TensorflowLite的转换、TPU/硬件加速器的使用、在多个平台(Raspberry PI、edge设备)上运行应用程序等。</p></blockquote><p id="ea9d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">参见第一部分。<a class="ae jw" rel="noopener" href="/nerd-for-tech/play-bach-let-a-neural-network-play-for-you-part-3-9f59c9a5d57f">第三部。</a></p><p id="4d77" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">完整的代码可以在github 的<a class="ae jw" href="https://github.com/pabou38/play_bach" rel="noopener ugc nofollow" target="_blank">上找到</a></p><p id="6bbf" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们来看看准备数据和训练第一个神经网络的过程。</p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="jx jy l"/></div><figcaption class="jz ka et er es kb kc bd b be z dx translated">接受戈德堡变奏曲的训练。用小号演奏</figcaption></figure><h1 id="2a11" class="kd ke hi bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">数据。</h1><p id="8b1e" class="pw-post-body-paragraph if ig hi ih b ii lb ik il im lc io ip iq ld is it iu le iw ix iy lf ja jb jc hb bi translated">第一步是获取一些你最喜欢的作曲家的MIDI文件。然后你可以使用<a class="ae jw" href="https://web.mit.edu/music21/" rel="noopener ugc nofollow" target="_blank"> Music21 python库</a>从那些MIDI文件中提取一系列音符。</p><p id="d5c0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为了这个教程，我选择了大提琴独奏<a class="ae jw" href="http://www.jsbach.net/midi/midi_solo_cello.html" rel="noopener ugc nofollow" target="_blank"> <strong class="ih hj"> <em class="js">组曲</em> </strong> </a> <strong class="ih hj"> <em class="js">，BWV 1007到1012 </em> </strong>(我爱巴保罗·卡萨尔斯)</p><p id="b665" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这个语料库总共有32487个音符/和弦/休止符<em class="js">(前10个元素的示例:['G2 '，' R '，' R '，' D3 '，' B3 '，' A3 '，' B3 '，' D3 '，' B3 '，' D3']) </em>和129个<strong class="ih hj">唯一的</strong>音符/和弦<em class="js">(前5个的示例:['A2 '，' A2)。F#3 '，' A2。F3 '，' A3 '，' A3。B3']) </em></p><p id="1488" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">正如您所记得的(参考。第1部分)，神经网络只接受数字作为输入。把音符/和弦转换成整数的一个简单方法是创建一个字典，比如(' A2 '，0)，(' A2。F#3 '，1)，(' A2。F3 '，2)，(' A3 '，3)，(' A3。B3》，4)等。在该序列中，音符A2由整数0表示，和弦A2。f '除以整数1，依此类推…</p><p id="c078" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">下一步是将语料库转换成实际的训练数据。训练样本是一系列(n+1)个音符。我使用n=40，稍后会解释原因。因此，从我的32487个元素的语料库中，我获得了32447个训练样本的列表。每个样本是40个整数(40个音符)的列表，后跟一个整数(第41个音符)。</p><p id="a1c9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">列表是python对象，但是神经网络想要被喂以<strong class="ih hj">张量</strong>。把张量想象成一个多维的数字矩阵。将列表转换成张量的过程称为<strong class="ih hj">向量化</strong>。一旦完成，张量就可以输入网络进行训练。</p><p id="57ed" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="js">作为补充说明:神经网络允许张量处理中的大量并行性，并且一种计算架构针对张量进行了优化:</em> <a class="ae jw" href="https://en.wikipedia.org/wiki/Graphics_processing_unit" rel="noopener ugc nofollow" target="_blank"> <em class="js"> GPU </em> </a> <em class="js">，又名图形处理单元，又名您的优秀老玩家显卡。如果你没有图形处理器，就别想训练什么像样的网络。在通用CPU上训练，即使是最快的CPU，也是无法忍受的</em></p><h1 id="1082" class="kd ke hi bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">我们的第一个模型。</h1><p id="6c62" class="pw-post-body-paragraph if ig hi ih b ii lb ik il im lc io ip iq ld is it iu le iw ix iy lf ja jb jc hb bi translated">深度学习中的‘深度’一词是指一个神经网络是一个层的堆叠，有很多层(是一个很深的堆叠)。</p><p id="4017" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">下图描绘了我们的第一个模型的堆叠。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es lg"><img src="../Images/6b21bacdf6312c18d01735eec621256a.png" data-original-src="https://miro.medium.com/v2/resize:fit:900/format:webp/1*T4-ownmRK7jj3Qhlnjwsbw.png"/></div></figure><p id="4776" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们的神经网络由四种类型的层组成:</p><ul class=""><li id="ebb0" class="lh li hi ih b ii ij im in iq lj iu lk iy ll jc lm ln lo lp bi translated">输入层:在堆栈的顶部，这一层“接收”训练数据(张量)。[None，40，129]表示网络期望输入张量是40个数字的序列，每个数字是1到129之间的值。这就是我们准备训练数据的方式，所以一切都很好。无意味着网络不关心有多少样本可用(在我们的例子中是32447)</li><li id="8b20" class="lh li hi ih b ii lq im lr iq ls iu lt iy lu jc lm ln lo lp bi translated">输出层(称为softmax)是底层。(无，129)意味着，给定一个输入张量(40的序列)，网络将预测第41个，这可以是1到129之间的任何值(即网络知道的任何音符/和弦)。</li><li id="a606" class="lh li hi ih b ii lq im lr iq ls iu lt iy lu jc lm ln lo lp bi translated">处理层:在这种情况下，他们是<a class="ae jw" href="https://en.wikipedia.org/wiki/Long_short-term_memory" rel="noopener ugc nofollow" target="_blank"> LSTM </a>，又名长期短期记忆(如果人类也有这样的处理层不是很好吗？).我们的堆栈中有两个LSTM层。可以说LSTMs专门从<strong class="ih hj"> <em class="js">序列中学习。</em> </strong></li><li id="f2dd" class="lh li hi ih b ii lq im lr iq ls iu lt iy lu jc lm ln lo lp bi translated">正常化、ReLU、辍学形式的一些白色魔法。这些层基本上确保了网络在训练期间不会失控。</li></ul><p id="c88c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">LSTM层的数量(在我们的例子中是2)和它们的大小(300)被称为<strong class="ih hj">超参数</strong>。这些超参数的设置是你自己的，没有固定的规则。这是你的技能，你的直觉。这是一个反复试验的过程。只要找到一个配置，给出好的结果，不需要花费时间来训练。</p><p id="21d9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">通过这种配置，我们的神经网络包含1，278，429个内部变量。这超过了一百万，但在深度学习领域，这仍然是一个非常小的数字。这些变量是随机初始化的，训练的魔法是调整它们，这样，在最后，它们共同识别出一只猫和一只狗，或者在我们的例子中，给定前40个音符，预测第41个音符。</p></div><div class="ab cl lv lw gp lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="hb hc hd he hf"><h1 id="5ca2" class="kd ke hi bd kf kg mc ki kj kk md km kn ko me kq kr ks mf ku kv kw mg ky kz la bi translated">用数据训练模型。</h1><p id="0741" class="pw-post-body-paragraph if ig hi ih b ii lb ik il im lc io ip iq ld is it iu le iw ix iy lf ja jb jc hb bi translated">训练过程是一个循环:</p><ul class=""><li id="c75a" class="lh li hi ih b ii ij im in iq lj iu lk iy ll jc lm ln lo lp bi translated">获取一个训练样本(40个整数，代表40个音符)，并将其转换为张量</li><li id="1708" class="lh li hi ih b ii lq im lr iq ls iu lt iy lu jc lm ln lo lp bi translated">将该张量输入模型(即输入层)</li><li id="b620" class="lh li hi ih b ii lq im lr iq ls iu lt iy lu jc lm ln lo lp bi translated">神经网络随后将执行大量张量运算，这涉及到内部变量；最后，网络将生成第41个音符的预测(在它知道的129个音符/和弦中)。</li><li id="66a1" class="lh li hi ih b ii lq im lr iq ls iu lt iy lu jc lm ln lo lp bi translated">然后，训练过程将查看网络是否正确，即预测是否是实际的第41个音符。<em class="js">将此步骤视为计算网络预测和“基本事实”之间的“误差”,我们知道这一点，因为在训练期间，我们知道第41个音符的真实值。</em></li><li id="8c53" class="lh li hi ih b ii lq im lr iq ls iu lt iy lu jc lm ln lo lp bi translated">如果不正确，算法会调整内部变量，以便下一次将相同的张量呈现给网络时，网络的预测将最接近事实，即误差将更低(形式上更低，这里有一个定理)。当然，在训练开始时，网络是正确的可能性为零(记住计算是基于随机初始化的内部变量)。</li><li id="a89d" class="lh li hi ih b ii lq im lr iq ls iu lt iy lu jc lm ln lo lp bi translated">令人作呕地重复</li></ul><p id="c225" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">没什么更多的了。</p><p id="b4cd" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">实际上，这种做法略有不同，但原理是相同的:</p><ul class=""><li id="5777" class="lh li hi ih b ii ij im in iq lj iu lk iy ll jc lm ln lo lp bi translated">网络通常一次被馈送许多训练样本。这叫做<strong class="ih hj"><em class="js"/></strong><em class="js">(如64个样本)</em>。误差计算和内部变量调整算法在每个批次后运行。</li><li id="a81b" class="lh li hi ih b ii lq im lr iq ls iu lt iy lu jc lm ln lo lp bi translated">当所有可用的训练样本都被输入后，然后…重新开始。一个这样的周期被称为一个<strong class="ih hj"> <em class="js">时期。</em>T11】</strong></li><li id="0d25" class="lh li hi ih b ii lq im lr iq ls iu lt iy lu jc lm ln lo lp bi translated">当误差“足够小”或者在每个历元之后没有显著减少时，训练停止(不需要浪费计算资源)。</li><li id="6420" class="lh li hi ih b ii lq im lr iq ls iu lt iy lu jc lm ln lo lp bi translated">你(人类)实际上是去喝杯咖啡，而你的GPU将电能转化为热能。</li></ul><p id="16f8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">最后，网络将具有利用可用训练样本以及网络架构和超参数的选择所能实现的最低可能误差。这120万个变量的值就是训练好的网络。</p></div><div class="ab cl lv lw gp lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="hb hc hd he hf"><h1 id="ccd1" class="kd ke hi bd kf kg mc ki kj kk md km kn ko me kq kr ks mf ku kv kw mg ky kz la bi translated">捕捉，以及如何观看你的模型。</h1><p id="8b13" class="pw-post-body-paragraph if ig hi ih b ii lb ik il im lc io ip iq ld is it iu le iw ix iy lf ja jb jc hb bi translated">在每个批次/时期后，误差在数学上减少？看起来好得难以置信。是的，这里有一个陷阱。网络只会在处理<strong class="ih hj">训练样本时变得更好。</strong>不能保证网络在其他输入上有良好的性能(参见第1部分关于泛化)。</p><p id="df80" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">因此，目标是确保网络对训练集之外的输入(即“看不见的输入”)表现良好(低误差、准确预测)。</p><p id="297f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为了检查这是否实际发生，可用的训练数据被分成3组:</p><ul class=""><li id="764c" class="lh li hi ih b ii ij im in iq lj iu lk iy ll jc lm ln lo lp bi translated">“<strong class="ih hj">训练集</strong>”:批量数据，用于实际训练。这个集合将被网络一批接一批、一个接一个地“看到”。</li><li id="71de" class="lh li hi ih b ii lq im lr iq ls iu lt iy lu jc lm ln lo lp bi translated">“<strong class="ih hj">验证集</strong>”:不用于内部变量调整算法<em class="js">(我无意中说漏了嘴，这个算法叫做随机梯度下降和使用偏导数代数)</em>，而是用于计算每个历元之后的误差/精度。因此，验证集上的误差演变是训练是否进展顺利的良好指示。</li><li id="b143" class="lh li hi ih b ii lq im lr iq ls iu lt iy lu jc lm ln lo lp bi translated">“<strong class="ih hj">测试集</strong>”:从未在训练期间使用，但用于计算完全训练的模型的性能。在某种程度上，测试集是用来给模型“惊喜”的，因为模型在训练期间根本没有机会“适应”这些数据。一旦投入运行，它就是模型性能的最佳代理。</li></ul><p id="7836" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">查看下图，了解训练的情况(错误的别称)，特别是<strong class="ih hj">准确度</strong>图(准确度是网络预测正确的时间百分比的度量)。</p><p id="95a0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">该图的纵轴是训练集和验证集的准确度；图表的横轴是纪元。正如预期的那样，训练集的准确性(自动)提高了。要监控的是验证集的准确性。在我们的例子中，在大约50个时期后，它增加并稳定在大约60%的准确度。60%是该模型的最大精度，不值得计算更多的历元。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es mh"><img src="../Images/e3c9daf2c2ad110d62229e1bee6b1aea.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ewgOHpaoX6GTfqrL8PsI-A.png"/></div></div></figure><p id="7960" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">注意，60%的准确率意味着网络<strong class="ih hj">确实了解了</strong>一些东西。有129个可能的输出，如果网络是随机猜测的，它将是正确的1/129，即0.7%的时间，而不是60%。</p><p id="54f5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果60%的准确率不够好，那么回到你的模型架构，回到你选择的超参数，获得更多更好的训练数据…再试一次。</p><p id="7fe5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在下一节中，我们将看看在训练过程中可能出错的地方，以及如何使用训练好的模型来生成实际的音乐。</p><p id="d2da" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">敬请期待！！！！</p><p id="3abd" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="js">——————如果你对细节不感兴趣，就不要越过这条线——————</em></p><p id="0653" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这是定义我们模型的实际张量流代码。</p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="mi jy l"/></div></figure><p id="5e55" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">第1行到第16行描述了我们深度学习模型中的各个层。</p><p id="20f4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">然后，在第18到22行，选择一些特定的算法用于训练:</p><ul class=""><li id="eea4" class="lh li hi ih b ii ij im in iq lj iu lk iy ll jc lm ln lo lp bi translated">如何用数学方法计算误差</li><li id="cd08" class="lh li hi ih b ii lq im lr iq ls iu lt iy lu jc lm ln lo lp bi translated">使用什么方法来调整内部变量(在我们的例子中是“adam”，这是一个算法的名字，还有许多其他的)</li><li id="b80e" class="lh li hi ih b ii lq im lr iq ls iu lt iy lu jc lm ln lo lp bi translated">训练算法应该计算什么度量(它总是计算损失，并且我们也想要准确性)</li></ul><p id="85a8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">“编译”指令创建模型。Is还没有经过训练。你将在下一部分看到这一部分</p><p id="a422" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">那么，越界值得吗？</p></div></div>    
</body>
</html>