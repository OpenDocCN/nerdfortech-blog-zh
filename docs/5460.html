<html>
<head>
<title>When Services Have a Need for Speed…</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">当服务需要速度时…</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/when-you-have-a-need-for-speed-ea810fcecea4?source=collection_archive---------4-----------------------#2021-10-04">https://medium.com/nerd-for-tech/when-you-have-a-need-for-speed-ea810fcecea4?source=collection_archive---------4-----------------------#2021-10-04</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="53fa" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">反应式微服务可以是答案！</h2></div><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ix"><img src="../Images/d71d53937a751b8f685f0f72fa742b37.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MeWqMn9srQCR4H1TLHuT6g.jpeg"/></div></div></figure><p id="5d2e" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated"><strong class="jl hj"> <em class="kf">当您需要高性能、低延迟、可靠性和可扩展性时，反应式微服务是21世纪解决您问题的答案。为什么不花几分钟看看为什么呢？</em>T3】</strong></p><p id="ca84" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">多年来，我们一直在使用流行的SOA技术(如Spring Boot和Jakarta RESTful Web服务)构建同步的请求-响应应用程序。但是在21世纪的今天，当谈到高性能、低延迟、可靠性和可扩展性时，这些20世纪的技术正在耗尽。我们需要找到更好的方法。</p><h2 id="b24f" class="kg kh hi bd ki kj kk kl km kn ko kp kq js kr ks kt jw ku kv kw ka kx ky kz la bi translated">微服务</h2><p id="4f13" class="pw-post-body-paragraph jj jk hi jl b jm lb ij jo jp lc im jr js ld ju jv jw le jy jz ka lf kc kd ke hb bi translated">像你们中的许多人一样，我们转向微服务架构模式来克服这些问题。我们发现模式本身只能解决一些问题——直到我们发现了拼图中缺少的那一块。问题是我们用SOA的方式做微服务——使用同步请求-响应API。</p><h2 id="b631" class="kg kh hi bd ki kj kk kl km kn ko kp kq js kr ks kt jw ku kv kw ka kx ky kz la bi translated">同步的问题是</h2><p id="02aa" class="pw-post-body-paragraph jj jk hi jl b jm lb ij jo jp lc im jr js ld ju jv jw le jy jz ka lf kc kd ke hb bi translated">因为微服务是松散耦合的，并通过消息传递进行通信——如果消息传递是同步的，所使用的处理线程将花费大量时间等待，而不是工作。现代计算机速度如此之快，以至于我们往往会忘记操作系统管理线程需要多少处理周期。上下文切换是一项相当繁重的工作，有时会占用超过50%的CPU周期——这些周期不执行应用程序的工作。这让我们想到了拼图中缺失的一块，<strong class="jl hj"> <em class="kf">反应式微服务</em> </strong>。</p><h2 id="ca82" class="kg kh hi bd ki kj kk kl km kn ko kp kq js kr ks kt jw ku kv kw ka kx ky kz la bi translated">反应系统</h2><p id="76cf" class="pw-post-body-paragraph jj jk hi jl b jm lb ij jo jp lc im jr js ld ju jv jw le jy jz ka lf kc kd ke hb bi translated">如<a class="ae lg" href="https://www.reactivemanifesto.org/" rel="noopener ugc nofollow" target="_blank"> <strong class="jl hj"> <em class="kf">反应式宣言</em> </strong> </a>中所述，构建为<em class="kf">反应式系统</em>的应用更加灵活、松散耦合并且<a class="ae lg" href="https://www.reactivemanifesto.org/glossary#Scalability" rel="noopener ugc nofollow" target="_blank">可扩展</a>。这使得它们更容易开发和修改。他们对失败的容忍度明显更高，当失败真的发生时，他们优雅地面对，而不是灾难。反应式系统反应灵敏，给用户有效的互动反馈。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es lh"><img src="../Images/03411a16b31dbe8d7a5dbd696f339c10.png" data-original-src="https://miro.medium.com/v2/resize:fit:600/format:webp/1*24Il2NQESb4OG9kSaG7vJQ.png"/></div></div><figcaption class="li lj et er es lk ll bd b be z dx translated"><strong class="bd ki">图1:无功系统属性</strong></figcaption></figure><p id="05b2" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">反应式系统依靠<a class="ae lg" href="https://www.reactivemanifesto.org/glossary#Asynchronous" rel="noopener ugc nofollow" target="_blank">异步</a> <a class="ae lg" href="https://www.reactivemanifesto.org/glossary#Message-Driven" rel="noopener ugc nofollow" target="_blank">消息传递</a>来建立组件之间的边界，确保松耦合、隔离和<a class="ae lg" href="https://www.reactivemanifesto.org/glossary#Location-Transparency" rel="noopener ugc nofollow" target="_blank">位置透明</a>。异步消息传递是现代高性能和高吞吐量系统中的关键和常见属性。</p><p id="e403" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">如果你想知道更多为什么反应式系统这么快，这个17分钟的YouTube视频，<a class="ae lg" href="https://youtu.be/eRxLfUIMJwk" rel="noopener ugc nofollow" target="_blank"> <strong class="jl hj"> <em class="kf">什么是反应式系统？</em> </strong> </a>，很好的解释了无功系统的优点。</p><h2 id="8a88" class="kg kh hi bd ki kj kk kl km kn ko kp kq js kr ks kt jw ku kv kw ka kx ky kz la bi translated">反应式行动者模型微服务</h2><p id="de57" class="pw-post-body-paragraph jj jk hi jl b jm lb ij jo jp lc im jr js ld ju jv jw le jy jz ka lf kc kd ke hb bi translated">反应式微服务因素的形状由其主要目的决定。微服务参与者的核心是一个<em class="kf">反应式</em>异步消息处理器。它被设计和优化为使用单线程一次处理一条消息，尽可能地快速高效。很像<a class="ae lg" href="https://www.peerbits.com/blog/why-nodejs-fast-and-its-best-use-cases.html" rel="noopener ugc nofollow" target="_blank"><strong class="jl hj"><em class="kf">node . js</em></strong></a><strong class="jl hj"><em class="kf"/></strong>它是一个高性能的、异步的消息处理器。</p><p id="0272" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">微服务优化处理的消息属于<a class="ae lg" href="https://docs.google.com/document/d/16bSPSb-_gzi3QZADhdU4NceHSoXjuldXfPldfCBLbCA/edit?usp=sharing" rel="noopener ugc nofollow" target="_blank"> <em class="kf">表述性状态转移</em> </a> <em class="kf"> </em>架构风格。有三种基本的消息类别:任务(请求)、响应和错误。这些信息可以通过以下两种方式之一传递:</p><ol class=""><li id="96eb" class="lm ln hi jl b jm jn jp jq js lo jw lp ka lq ke lr ls lt lu bi translated">作为异步REST消息。</li><li id="ae36" class="lm ln hi jl b jm lv jp lw js lx jw ly ka lz ke lr ls lt lu bi translated">作为<a class="ae lg" href="https://prateek-ashtikar512.medium.com/microservices-design-patterns-event-carried-state-transfer-c4b66a58df00" rel="noopener"> <em class="kf">事件承载的状态转移</em> </a>或ECST事件。</li></ol><p id="7e27" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated"><em class="kf">消息总是异步发送或作为事件发布。没有同步消息传递。每条消息都被发送到微服务逻辑地址或发布到事件主题。每个微服务参与者都有一个附属的</em> <strong class="jl hj">邮箱</strong> <em class="kf">为其缓冲输入输出消息。</em></p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ma"><img src="../Images/bab39d648c06982eea3e582266106185.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*wkFQMS9IrmjUyWMB.png"/></div></div><figcaption class="li lj et er es lk ll bd b be z dx translated"><strong class="bd ki">图2:微服演员解剖</strong></figcaption></figure><h2 id="08aa" class="kg kh hi bd ki kj kk kl km kn ko kp kq js kr ks kt jw ku kv kw ka kx ky kz la bi translated">包扎</h2><p id="aaf2" class="pw-post-body-paragraph jj jk hi jl b jm lb ij jo jp lc im jr js ld ju jv jw le jy jz ka lf kc kd ke hb bi translated">异步反应式角色模型微服务是满足21世纪需求的21世纪技术。如果没有API网关、负载平衡器和其他占用CPU周期的附加组件的附加层，传统的请求-响应SOA APIs无法满足现代云部署应用程序的性能、可伸缩性和可靠性要求。如果这个想法对你有意义，我们推荐阅读:</p><ul class=""><li id="e9c2" class="lm ln hi jl b jm jn jp jq js lo jw lp ka lq ke mb ls lt lu bi translated"><a class="ae lg" rel="noopener" href="/nerd-for-tech/designing-microservices-4130bc41c046"> <strong class="jl hj">设计微服务</strong> </a></li><li id="140d" class="lm ln hi jl b jm lv jp lw js lx jw ly ka lz ke mb ls lt lu bi translated"><a class="ae lg" rel="noopener" href="/nerd-for-tech/anatomy-of-a-microservice-c52b3cb30d30">T5【解剖微服】T6</a></li></ul></div></div>    
</body>
</html>