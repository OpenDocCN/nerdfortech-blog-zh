<html>
<head>
<title>Kotlin Delegation</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Kotlin代表团</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/kotlin-delegation-92acfaeb3b8b?source=collection_archive---------4-----------------------#2021-05-27">https://medium.com/nerd-for-tech/kotlin-delegation-92acfaeb3b8b?source=collection_archive---------4-----------------------#2021-05-27</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="65c5" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">Kotlin委托属性</h2></div><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ix"><img src="../Images/d49452b6eef70beadcff97ce2277dd12.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ip7uOVxbVcT_uVawvD1C_w.png"/></div></div></figure><p id="cb50" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">在本文中，我们将探索什么是Kotlin委托，什么是Kotlin委托属性。首先，让我们讨论一下委托的一般含义。</p><h2 id="06f5" class="kf kg hi bd kh ki kj kk kl km kn ko kp js kq kr ks jw kt ku kv ka kw kx ky kz bi translated">什么是代表？</h2><p id="71fd" class="pw-post-body-paragraph jj jk hi jl b jm la ij jo jp lb im jr js lc ju jv jw ld jy jz ka le kc kd ke hb bi translated">Kotlin delegate是一个常规属性，它将获取和设置(读/写)其值的负担转移到与之相关的另一个函数。Kotlin提供了几种不同类型的代表团。</p><h2 id="564b" class="kf kg hi bd kh ki kj kk kl km kn ko kp js kq kr ks jw kt ku kv ka kw kx ky kz bi translated">Kotlin委托属性</h2><p id="c779" class="pw-post-body-paragraph jj jk hi jl b jm la ij jo jp lb im jr js lc ju jv jw ld jy jz ka le kc kd ke hb bi translated">Kotlin为几种委托提供了标准的工厂方法。</p><h2 id="0530" class="kf kg hi bd kh ki kj kk kl km kn ko kp js kq kr ks jw kt ku kv ka kw kx ky kz bi translated">惰性初始化</h2><p id="a8d3" class="pw-post-body-paragraph jj jk hi jl b jm la ij jo jp lb im jr js lc ju jv jw ld jy jz ka le kc kd ke hb bi translated">当需要初始化一个变量或常数时，惰性初始化很重要。在下面显示的代码片段中，通过关键字的<em class="lf">表示我们将使用一个<em class="lf">委托</em>来初始化<em class="lf">init by azy</em>常量的值。<em class="lf"> </em>表示如果需要，我们将只在块内运行一次代码。一旦第一次调用<em class="lf">initby azy</em>时，Kotlin会将该值隐藏起来，并在将来的引用中使用该值。</em></p><p id="491a" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">但是安卓视图的<em class="lf">惰性</em>初始化有一个潜在的问题。如果视图像这样被隐藏起来，它会保存对上下文的引用，这可能会导致内存泄漏。</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="lg lh l"/></div><figcaption class="li lj et er es lk ll bd b be z dx translated">惰性初始化</figcaption></figure><h2 id="7b45" class="kf kg hi bd kh ki kj kk kl km kn ko kp js kq kr ks jw kt ku kv ka kw kx ky kz bi translated">可观察量</h2><p id="116f" class="pw-post-body-paragraph jj jk hi jl b jm la ij jo jp lb im jr js lc ju jv jw ld jy jz ka le kc kd ke hb bi translated"><strong class="jl hj"> <em class="lf">可观察的</em> </strong>委托属性在每次值改变时被要求做某事时很方便。如果我们看看下面给出的代码片段，最初<em class="lf"> observableData </em>是0，而<em class="lf">是ValueChanged </em>是false。</p><p id="a116" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">在给<em class="lf"> observableData赋值后，</em>存储的值被改变，并且<em class="lf">被赋值的</em>变为真<em class="lf">。</em>每次回调函数都是在值更新后才被调用。</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="lg lh l"/></div><figcaption class="li lj et er es lk ll bd b be z dx translated">Kotlin可观察到</figcaption></figure><h2 id="797c" class="kf kg hi bd kh ki kj kk kl km kn ko kp js kq kr ks jw kt ku kv ka kw kx ky kz bi translated">可否决</h2><p id="8b90" class="pw-post-body-paragraph jj jk hi jl b jm la ij jo jp lb im jr js lc ju jv jw ld jy jz ka le kc kd ke hb bi translated"><strong class="jl hj"> <em class="lf">可否决</em> </strong>委托与<strong class="jl hj"> <em class="lf">可观察</em> </strong>委托非常相似。唯一的区别是回调应该有一个条件来更新变量的值。在以下示例中，新值应大于或等于0，以更新<em class="lf">否决数据</em>。只有在满足这个条件后，才会调用回调。</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="lg lh l"/></div><figcaption class="li lj et er es lk ll bd b be z dx translated">Kotlin可否决</figcaption></figure><p id="8a49" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">当处理代码中不断变化的属性时，惰性初始化、可观察的和可否决的委托属性变得方便和有用。我相信本文有助于您更好地理解<strong class="jl hj"> <em class="lf">科特林委托</em> </strong>属性。</p></div></div>    
</body>
</html>