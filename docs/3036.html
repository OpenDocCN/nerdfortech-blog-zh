<html>
<head>
<title>Week Two: React Hooks</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">第二周:反应钩</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/week-two-react-hooks-b72068e0cf6c?source=collection_archive---------20-----------------------#2021-05-27">https://medium.com/nerd-for-tech/week-two-react-hooks-b72068e0cf6c?source=collection_archive---------20-----------------------#2021-05-27</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/6b98ded314b7f9d2d9de54620b50a913.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ekAaIKWgXzC234te55vRZA.png"/></div></div></figure><p id="c4b1" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这是我的<a class="ae jo" href="https://dhash.medium.com/my-weekly-react-learning-series-c94d129a6c21" rel="noopener"> react 学习系列</a>的第三部分，在这里，我每周发布一篇关于 react 学习进展的文章，并分享有用的资源和材料，帮助我更好地理解概念并提高我的 javascript 技能。</p><p id="8b72" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">按照我为自己制定的学习路线，钩子是下一个目标，我在本周介绍了基本的和必须知道的钩子，并将在接下来的几周介绍高级钩子和定制钩子。本文中涉及的挂钩是，</p><ol class=""><li id="1a49" class="jp jq hi is b it iu ix iy jb jr jf js jj jt jn ju jv jw jx bi translated">使用状态</li><li id="da1f" class="jp jq hi is b it jy ix jz jb ka jf kb jj kc jn ju jv jw jx bi translated">使用效果</li><li id="f6c7" class="jp jq hi is b it jy ix jz jb ka jf kb jj kc jn ju jv jw jx bi translated">使用上下文</li><li id="894d" class="jp jq hi is b it jy ix jz jb ka jf kb jj kc jn ju jv jw jx bi translated">用户教育</li></ol><p id="b8a4" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">为了理解 React 钩子，我们首先需要理解为什么在 React <strong class="is hj"> V16.8.0 </strong>中引入了偶数钩子，它们到底在解决什么问题？为了首先找到这些问题的答案，我们需要理解什么是<strong class="is hj"> <em class="kd">函数式编程</em> </strong>以及在过去几个月中它超越 OOP 的原因</p><h1 id="886b" class="ke kf hi bd kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb bi translated">函数式编程</h1><figure class="ld le lf lg fd ij er es paragraph-image"><div class="er es lc"><img src="../Images/0f664a0fc1f32fac172bce909043c863.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/format:webp/1*936RQW_ZBR_WqOu_tJRwjQ.png"/></div><figcaption class="lh li et er es lj lk bd b be z dx translated">信用:makememe.org</figcaption></figure><h2 id="8f87" class="ll kf hi bd kg lm ln lo kk lp lq lr ko jb ls lt ks jf lu lv kw jj lw lx la ly bi translated">什么是函数式编程？</h2><p id="d01f" class="pw-post-body-paragraph iq ir hi is b it lz iv iw ix ma iz ja jb mb jd je jf mc jh ji jj md jl jm jn hb bi translated">根据 FreeCodeCamp 的说法，函数式编程是一种编程风格，其中解决方案是简单的<em class="kd">隔离函数</em>，在函数范围之外没有任何副作用<em class="kd">。</em></p><ul class=""><li id="ba25" class="jp jq hi is b it iu ix iy jb jr jf js jj jt jn me jv jw jx bi translated"><strong class="is hj">独立函数:</strong>这意味着不依赖于程序的状态，包括易受变化影响的全局变量，因此函数独立工作，只做程序员分配给它们的工作。</li><li id="8f83" class="jp jq hi is b it jy ix jz jb ka jf kb jj kc jn me jv jw jx bi translated"><strong class="is hj">简单纯函数:</strong>相同的输入总是给出相同的输出。</li><li id="86f3" class="jp jq hi is b it jy ix jz jb ka jf kb jj kc jn me jv jw jx bi translated"><strong class="is hj">函数无副作用或副作用有限:</strong>函数之外的整个程序状态的任何变化都受到控制，不会影响函数或其工作。</li><li id="3687" class="jp jq hi is b it jy ix jz jb ka jf kb jj kc jn me jv jw jx bi translated">函数式编程有一个无状态的编程模型。</li></ul><p id="cbe6" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">除了上面提到的(<em class="kd">是 react 钩子和函数组件</em>的主要构建模块)函数式编程的特性和好处之外，函数式编程范例还有很多优点，比如，代码更少，更少的错误，并发性，容易递归等等。</p><h1 id="eea7" class="ke kf hi bd kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb bi translated">回到钩子上来…</h1><figure class="ld le lf lg fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mf"><img src="../Images/ef4dcf7597a2a565fde4a4704ac7fae3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5SYwsBkdGdQvCbnXeRpn3A.jpeg"/></div></div><figcaption class="lh li et er es lj lk bd b be z dx translated">图片来源:Pinterest</figcaption></figure><h1 id="44b4" class="ke kf hi bd kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb bi translated">什么是钩子？</h1><p id="8bbb" class="pw-post-body-paragraph iq ir hi is b it lz iv iw ix ma iz ja jb mb jd je jf mc jh ji jj md jl jm jn hb bi translated">根据 react 官方文件，</p><p id="4b29" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">挂钩是 React 16.8 版本中的新增功能，它允许你使用状态和其他 React 特性，比如生命周期方法，而无需编写类</p><p id="91ce" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">React 中的功能组件只不过是一种将功能相互隔离的功能编程范例，以便它们可以执行自己的操作，而不受外界的任何干扰。</p><h1 id="cf1f" class="ke kf hi bd kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb bi translated">4 个最常用的挂钩。</h1><h2 id="ba1b" class="ll kf hi bd kg lm ln lo kk lp lq lr ko jb ls lt ks jf lu lv kw jj lw lx la ly bi translated">1.使用状态()</h2><ul class=""><li id="161f" class="jp jq hi is b it lz ix ma jb mg jf mh jj mi jn me jv jw jx bi translated"><strong class="is hj">什么是 useState()钩子？</strong>这是一个钩子，它允许你在功能组件中有状态变量，你把初始状态传递给这个函数，它返回一个带有当前状态值的变量，当屏幕重新呈现时，另一个函数更新这个值。</li><li id="17a4" class="jp jq hi is b it jy ix jz jb ka jf kb jj kc jn me jv jw jx bi translated"><strong class="is hj">我们传递什么给 useState()？【useState()的参数是一个初始状态，如果你需要的话，它可以是一个数字或者一个字符串。</strong></li><li id="e49b" class="jp jq hi is b it jy ix jz jb ka jf kb jj kc jn me jv jw jx bi translated">【useState 返回()什么？它返回两个值，当前状态和一个更新当前状态的函数，请看下面的例子。</li></ul><pre class="ld le lf lg fd mj mk ml mm aw mn bi"><span id="7614" class="ll kf hi mk b fi mo mp l mq mr">const [foo, setFoo] = useState('bar') </span></pre><p id="94c7" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在上面提到的例子中，foo 最初被设置为字符串‘bar’，我们调用 set Foo(‘something’)函数，它将 Foo 的值从‘bar’设置为‘something’。</p><p id="3c46" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">从钩子开始的时候，还有一点需要注意，钩子会导致组件的状态改变，从而重新呈现组件。</p><h2 id="daec" class="ll kf hi bd kg lm ln lo kk lp lq lr ko jb ls lt ks jf lu lv kw jj lw lx la ly bi translated">2.useEffect()</h2><p id="64dd" class="pw-post-body-paragraph iq ir hi is b it lz iv iw ix ma iz ja jb mb jd je jf mc jh ji jj md jl jm jn hb bi translated">根据官方纪录片，效果挂钩让你在功能组件中执行副作用。简而言之，发生在正常组件评估和渲染循环之外的任务。</p><p id="e159" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们分别处理这些效果，以便这些副作用不会中断 react 组件的正常 UI 呈现。</p><pre class="ld le lf lg fd mj mk ml mm aw mn bi"><span id="f1c0" class="ll kf hi mk b fi mo mp l mq mr">useEffecct( () =&gt; {...}, []</span></pre><p id="c662" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">useEffect 有两个参数，</p><ol class=""><li id="e904" class="jp jq hi is b it iu ix iy jb jr jf js jj jt jn ju jv jw jx bi translated">一个应该在每个组件评估之后执行的函数，是你的副作用代码所在的地方。</li><li id="38d5" class="jp jq hi is b it jy ix jz jb ka jf kb jj kc jn ju jv jw jx bi translated">第二个参数是一个数组，这就是所谓的依赖关系数组，第一个参数，即函数将只运行，如果提到的依赖关系被改变。</li></ol><p id="3333" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">关于 useEffect 钩子需要注意的另一件重要事情是<strong class="is hj">清理函数，</strong>无论你在 useEffect 中返回什么都是你的清理函数。</p><pre class="ld le lf lg fd mj mk ml mm aw mn bi"><span id="1221" class="ll kf hi mk b fi mo mp l mq mr">useEffect(() =&gt; {<br/>    effect<br/>    return () =&gt; {<br/>        cleanup<br/>    }<br/>}, []) </span></pre><p id="a74b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这个函数将在组件解除关联时执行，重要的是删除不必要的行为并防止内存泄漏。</p><h2 id="d627" class="ll kf hi bd kg lm ln lo kk lp lq lr ko jb ls lt ks jf lu lv kw jj lw lx la ly bi translated">3.useContext()</h2><p id="9947" class="pw-post-body-paragraph iq ir hi is b it lz iv iw ix ma iz ja jb mb jd je jf mc jh ji jj md jl jm jn hb bi translated">上下文提供了一种通过组件树传递数据的方式，而不必在每一层手动向下传递属性。是的，就是这个。</p><p id="426c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">创建 useContext()挂钩的三个步骤，</p><ul class=""><li id="ea25" class="jp jq hi is b it iu ix iy jb jr jf js jj jt jn me jv jw jx bi translated"><strong class="is hj">创建上下文:</strong>const creating context = react . Create context(null)；</li><li id="e157" class="jp jq hi is b it jy ix jz jb ka jf kb jj kc jn me jv jw jx bi translated"><strong class="is hj">用 provider </strong>包装并传递上下文值，即要向下传递的值。</li><li id="a01c" class="jp jq hi is b it jy ix jz jb ka jf kb jj kc jn me jv jw jx bi translated"><strong class="is hj">导出:</strong>导出默认创建上下文</li></ul><p id="9358" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">接下来，我们希望子组件访问数据，并将其作为“props”数据传递。添加的上下文数据可由子组件通过使用“useContext”关键字来访问。</p><h2 id="eef3" class="ll kf hi bd kg lm ln lo kk lp lq lr ko jb ls lt ks jf lu lv kw jj lw lx la ly bi translated">4.useReducer()</h2><p id="c58f" class="pw-post-body-paragraph iq ir hi is b it lz iv iw ix ma iz ja jb mb jd je jf mc jh ji jj md jl jm jn hb bi translated">哦天啊！这一部分花了我几天时间来完成，我可以自己实现它，但是，我会尽我所能，至少让理论部分对你来说更容易。</p><ul class=""><li id="7f19" class="jp jq hi is b it iu ix iy jb jr jf js jj jt jn me jv jw jx bi translated">useReducer 是一个用于状态管理的钩子。</li><li id="b48e" class="jp jq hi is b it jy ix jz jb ka jf kb jj kc jn me jv jw jx bi translated">它是 useState 的替代方案，实际上，useState hook 是使用 useReducer 构建的。</li><li id="1144" class="jp jq hi is b it jy ix jz jb ka jf kb jj kc jn me jv jw jx bi translated">它的工作与 javascript 的 reducer 数组函数密切相关。</li></ul><p id="6dd1" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">为了更好地理解，我们来看一个例子。</p><pre class="ld le lf lg fd mj mk ml mm aw mn bi"><span id="68d6" class="ll kf hi mk b fi mo mp l mq mr">const [count, dispatch] = useReducer(reducer, initialState)</span></pre><ol class=""><li id="c3d1" class="jp jq hi is b it iu ix iy jb jr jf js jj jt jn ju jv jw jx bi translated"><strong class="is hj">计数，</strong>为当前状态。</li><li id="1aba" class="jp jq hi is b it jy ix jz jb ka jf kb jj kc jn ju jv jw jx bi translated"><strong class="is hj">分派，</strong>用来分派一个新的动作。这是一个一旦通过 reducer 函数调度动作就自动触发的函数，接收最新的状态快照，并返回新的和更新的状态。</li></ol><p id="77fa" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">很复杂，我同意！把它分解成简单的步骤，</p><ul class=""><li id="a2ae" class="jp jq hi is b it iu ix iy jb jr jf js jj jt jn me jv jw jx bi translated">useReducer 定义了一个初始状态。</li><li id="9e08" class="jp jq hi is b it jy ix jz jb ka jf kb jj kc jn me jv jw jx bi translated">提供一个包含更新状态的操作的函数。</li><li id="c71a" class="jp jq hi is b it jy ix jz jb ka jf kb jj kc jn me jv jw jx bi translated">触发调度相对于初始状态计算的更新状态。</li></ul><p id="a493" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">useReducer 挂钩的理论部分的最后一点是，在这种情况下，当两者都用于状态管理和服务器完全相同的目的时，一个人应该使用 useState 和 useReducer。</p><p id="f20b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">根据<a class="ae jo" href="https://css-tricks.com/getting-to-know-the-usereducer-react-hook/" rel="noopener ugc nofollow" target="_blank"> css-tricks </a>，“如果你的状态的一个元素依赖于你的状态的另一个元素的值，那么几乎总是使用 useReducer”</p><p id="1eca" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">经验法则是使用 useReducerto 来处理复杂状态，尤其是初始状态基于其他元素状态的情况。</p></div><div class="ab cl ms mt gp mu" role="separator"><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx"/></div><div class="hb hc hd he hf"><p id="15e2" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我希望这篇文章给了你 react 钩子的基础知识，并且从这里你可以查找一些沙盒例子并且有一个更好的理解。下面我附上一些我提到的所有钩子的文章的详细参考，在那里你可以看到更复杂的例子和对特定钩子的更深入的理解。</p></div><div class="ab cl ms mt gp mu" role="separator"><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx"/></div><div class="hb hc hd he hf"><p id="da6b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">[1]<a class="ae jo" href="https://blog.logrocket.com/a-guide-to-usestate-in-react-ecb9952e406c/" rel="noopener ugc nofollow" target="_blank">https://blog . log rocket . com/a-guide-to-use state-in-react-ECB 9952 e 406 c/</a></p><p id="9c49" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">[2]<a class="ae jo" rel="noopener" href="/swlh/react-hook-a-guide-to-learning-useeffect-11687e777aeb">https://medium . com/swlh/react-hook-a-guide-to-learning-use effect-11687 e 777 aeb</a></p><p id="473a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><a class="ae jo" href="https://www.robinwieruch.de/react-usecontext-hook" rel="noopener ugc nofollow" target="_blank">https://www.robinwieruch.de/react-usecontext-hook</a></p><p id="46b2" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">[4]<a class="ae jo" href="https://css-tricks.com/getting-to-know-the-usereducer-react-hook/" rel="noopener ugc nofollow" target="_blank">https://CSS-tricks . com/getting-to-know-the-user educer-react-hook/</a></p></div></div>    
</body>
</html>