<html>
<head>
<title>Clean Code: Formatting (Source code structure)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">干净代码:格式化(源代码结构)</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/clean-code-formatting-source-code-structure-f3021575d79?source=collection_archive---------3-----------------------#2021-06-17">https://medium.com/nerd-for-tech/clean-code-formatting-source-code-structure-f3021575d79?source=collection_archive---------3-----------------------#2021-06-17</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><figure class="hh hi ez fb hj hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es hg"><img src="../Images/1c5a71674ca84c4c9ff40a3a2640bbd8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Vb_wqyuUKxVef_ILT15TMA.jpeg"/></div></div></figure><div class=""/><div class=""><h2 id="87cb" class="pw-subtitle-paragraph iq hs ht bd b ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh dx translated">“我也喜欢敲打代码、保存，还有让编辑帮我清理格式。”—T . L .罗宾逊</h2></div><p id="af60" class="pw-post-body-paragraph jj jk ht jl b jm jn iu jo jp jq ix jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">本文是干净代码系列的第四篇。让我们跳进去，学习如何编写格式！</p><blockquote class="kf kg kh"><p id="7b9f" class="jj jk ki jl b jm jn iu jo jp jq ix jr kj jt ju jv kk jx jy jz kl kb kc kd ke hb bi translated"><strong class="jl hu">为什么代码格式很重要？</strong> <br/>代码格式化是关于沟通，而沟通对于称职的开发者来说是业务的第一顺序。<br/>编码的类型和可读性树立了先例，即使在原始代码被修改之后，这些先例也将继续影响维护和可扩展性。</p></blockquote><p id="b2b5" class="pw-post-body-paragraph jj jk ht jl b jm jn iu jo jp jq ix jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi km translated"><span class="l kn ko kp bm kq kr ks kt ku di"> B </span>如果线条宽度不均匀，字体大小不一，并且到处都是换行符，则很难阅读这些书。代码也是如此。<br/>保持缩进、换行符和格式兼容，使代码透明且易于阅读。</p><figure class="kw kx ky kz fd hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es kv"><img src="../Images/07c14a5c14ba3f7c157be14bdd66bff0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*zSOLFV_qw1LOTeC8"/></div></div><figcaption class="la lb et er es lc ld bd b be z dx translated">混乱代码与格式化代码</figcaption></figure><p id="f63a" class="pw-post-body-paragraph jj jk ht jl b jm jn iu jo jp jq ix jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">进入这一章时，我很好奇这一章是否真的教会了我什么。大多数格式化都是用当前的IDEs为我们自动完成的。您还可以安装支持格式化的软件，例如，如果任何内容的格式不正确，则会出现警报或错误。(将详细讨论。)</p><p id="f356" class="pw-post-body-paragraph jj jk ht jl b jm jn iu jo jp jq ix jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">当我们谈论格式时，最重要的不是尊重单一的风格，而是在任何地方都要尊重相同的标准。如果你已经建立了自己的格式化过程，只要它是好的。为了阅读和理解代码，指导代码的格式非常重要。</p><p id="6da6" class="pw-post-body-paragraph jj jk ht jl b jm jn iu jo jp jq ix jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">您可以选取各种控制代码格式的基本规则，然后一致地应用这些规则。如果你为团队或委员会工作，那么一套单一的格式化规则应该由团队决定，所有的参与者都应该遵守。它让您拥有一个集成的方法，您可以在其中使用这些准则进行格式化。</p><p id="b6ec" class="pw-post-body-paragraph jj jk ht jl b jm jn iu jo jp jq ix jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">基本上，对于一个文件可以有多少行代码以及在这方面每行有多少个字符是最佳的，有各种指导原则。你找不到神奇的计数，但你可以感觉到，因为有这么多行的代码和滚动是刺激性的。</p><p id="7130" class="pw-post-body-paragraph jj jk ht jl b jm jn iu jo jp jq ix jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">在格式化代码时，必须考虑以下场景。</p><ol class=""><li id="d792" class="le lf ht jl b jm jn jp jq js lg jw lh ka li ke lj lk ll lm bi translated"><strong class="jl hu">纵向分离概念。</strong></li><li id="f368" class="le lf ht jl b jm ln jp lo js lp jw lq ka lr ke lj lk ll lm bi translated"><strong class="jl hu">相关码应垂直密集出现。</strong></li><li id="0d4b" class="le lf ht jl b jm ln jp lo js lp jw lq ka lr ke lj lk ll lm bi translated"><strong class="jl hu">声明与用途相近的变量。</strong></li><li id="fb94" class="le lf ht jl b jm ln jp lo js lp jw lq ka lr ke lj lk ll lm bi translated"><strong class="jl hu">从属功能应关闭。</strong></li><li id="9c64" class="le lf ht jl b jm ln jp lo js lp jw lq ka lr ke lj lk ll lm bi translated"><strong class="jl hu">关闭类似功能。</strong></li><li id="80e5" class="le lf ht jl b jm ln jp lo js lp jw lq ka lr ke lj lk ll lm bi translated"><strong class="jl hu">向下放置功能。</strong></li><li id="d3fc" class="le lf ht jl b jm ln jp lo js lp jw lq ka lr ke lj lk ll lm bi translated"><strong class="jl hu">保持短路线。</strong></li><li id="bce8" class="le lf ht jl b jm ln jp lo js lp jw lq ka lr ke lj lk ll lm bi translated"><strong class="jl hu">不要使用水平对齐。</strong></li><li id="47c3" class="le lf ht jl b jm ln jp lo js lp jw lq ka lr ke lj lk ll lm bi translated"><strong class="jl hu">使用空白区关联相关事物，取消弱相关事物的关联。</strong></li><li id="f7ab" class="le lf ht jl b jm ln jp lo js lp jw lq ka lr ke lj lk ll lm bi translated"><strong class="jl hu">不要打破缺口。</strong></li></ol><p id="b61e" class="pw-post-body-paragraph jj jk ht jl b jm jn iu jo jp jq ix jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">让我们详细看看这些标准；</p><h2 id="d8f6" class="ls lt ht bd lu lv lw lx ly lz ma mb mc js md me mf jw mg mh mi ka mj mk ml mm bi translated"><strong class="ak"> #01。垂直分离概念。</strong></h2><p id="b1a7" class="pw-post-body-paragraph jj jk ht jl b jm mn iu jo jp mo ix jr js mp ju jv jw mq jy jz ka mr kc kd ke hb bi translated">应该垂直维护彼此相似的概念。这条定律显然不适用于不同的文件定义。但是如果没有正当理由，松散关联的定义就不能被拆分到单独的目录中。<br/>垂直区分应该反映这两个定义在理解对方方面的价值，它们之间的关系如此密切，以至于它们属于同一个源文件。</p><div class="kw kx ky kz fd ab cb"><figure class="ms hk mt mu mv mw mx paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><img src="../Images/1adb61fc86dc89aa071151adac7ac186.png" data-original-src="https://miro.medium.com/v2/resize:fit:736/format:webp/1*qxgj3f2U5SvxPzxis3NHSQ.png"/></div></figure><figure class="ms hk my mu mv mw mx paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><img src="../Images/7c16b267ecc51713012987299dde9553.png" data-original-src="https://miro.medium.com/v2/resize:fit:1266/format:webp/1*VrK06Eb7Ii0ug5NifxPzLg.png"/></div></figure></div><p id="2df1" class="pw-post-body-paragraph jj jk ht jl b jm jn iu jo jp jq ix jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated"><strong class="jl hu">不好的例子:</strong></p><pre class="kw kx ky kz fd mz na nb nc aw nd bi"><span id="74e9" class="ls lt ht na b fi ne nf l ng nh">import java.util.regex.*;<br/>public class BoldWidget extends ParentWidget {<br/>public static final String REGEXP = “‘’’.+?’’’”;<br/>private static final Pattern pattern = Pattern.compile(“‘’’(.+?)’’’”,<br/>Pattern.MULTILINE + Pattern.DOTALL);<br/>public BoldWidget(ParentWidget parent, String text) throws Exception {<br/>super(parent);<br/>Matcher match = pattern.matcher(text); match.find(); addChildWidgets(match.group(1));}<br/>public String render() throws Exception { StringBuffer html = new StringBuffer(“&lt;b&gt;”); html.append(childHtml()).append(“&lt;/b&gt;”); return html.toString();<br/>} }</span></pre><p id="5f05" class="pw-post-body-paragraph jj jk ht jl b jm jn iu jo jp jq ix jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated"><strong class="jl hu">好例子:</strong></p><pre class="kw kx ky kz fd mz na nb nc aw nd bi"><span id="01f6" class="ls lt ht na b fi ne nf l ng nh">package fitnesse.wikitext.widgets;</span><span id="64ba" class="ls lt ht na b fi ni nf l ng nh">import java.util.regex.*;</span><span id="ed8c" class="ls lt ht na b fi ni nf l ng nh">public class BoldWidget extends ParentWidget {<br/>   public static final String REGEXP = "'''.+?'''";<br/>   private static final Pattern pattern = <br/>   Pattern.compile("'''(.+?)'''",<br/>   Pattern.MULTILINE + Pattern.DOTALL <br/>);</span><span id="32a3" class="ls lt ht na b fi ni nf l ng nh">public BoldWidget(ParentWidget parent, String text) throws Exception { <br/>   super(parent);<br/>   Matcher match = pattern.matcher(text);<br/>   match.find();<br/>   addChildWidgets(match.group(1)); <br/>} </span><span id="4f07" class="ls lt ht na b fi ni nf l ng nh">public String render() throws Exception { <br/>  StringBuffer html = new StringBuffer("&lt;b&gt;");<br/>  html.append(childHtml()).append("&lt;/b&gt;"); <br/>  return html.toString();</span><span id="0d6b" class="ls lt ht na b fi ni nf l ng nh">  } <br/>}</span></pre><h2 id="4cd6" class="ls lt ht bd lu lv lw lx ly lz ma mb mc js md me mf jw mg mh mi ka mj mk ml mm bi translated">#02.<strong class="ak">相关代码应该垂直密集出现。</strong></h2><p id="4c5b" class="pw-post-body-paragraph jj jk ht jl b jm mn iu jo jp mo ix jr js mp ju jv jw mq jy jz ka mr kc kd ke hb bi translated">如果清晰划分定义，垂直密度意味着紧密互动。因此，紧密相连的代码行在垂直方向上看起来应该很粗。</p><p id="1ba4" class="pw-post-body-paragraph jj jk ht jl b jm jn iu jo jp jq ix jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated"><strong class="jl hu">不好的例子:</strong></p><pre class="kw kx ky kz fd mz na nb nc aw nd bi"><span id="31c8" class="ls lt ht na b fi ne nf l ng nh">public class PropertyConfig {</span><span id="a085" class="ls lt ht na b fi ni nf l ng nh">  /**<br/>  * The class name of the reporter listener */</span><span id="88f2" class="ls lt ht na b fi ni nf l ng nh">private String m_className;</span><span id="4e4d" class="ls lt ht na b fi ni nf l ng nh">  /**<br/>  * The properties of the reporter listener */</span><span id="0fae" class="ls lt ht na b fi ni nf l ng nh">private List&lt;Property&gt; m_properties = new ArrayList&lt;Property&gt;();</span><span id="0312" class="ls lt ht na b fi ni nf l ng nh">  public void addProperty(Property property) {<br/>    m_properties.add(property);</span><span id="e318" class="ls lt ht na b fi ni nf l ng nh">}</span></pre><p id="0e32" class="pw-post-body-paragraph jj jk ht jl b jm jn iu jo jp jq ix jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">看看这个例子中的无意义注释是如何打破instance的两个变量之间的紧密联系的。</p><p id="d49c" class="pw-post-body-paragraph jj jk ht jl b jm jn iu jo jp jq ix jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated"><strong class="jl hu">好例子:</strong></p><pre class="kw kx ky kz fd mz na nb nc aw nd bi"><span id="7859" class="ls lt ht na b fi ne nf l ng nh">public class PropertyConfig { <br/>  private String m_className;<br/>  private List&lt;Property&gt; m_properties = new ArrayList&lt;Property&gt;();</span><span id="bf74" class="ls lt ht na b fi ni nf l ng nh">public void addProperty(Property property) {<br/>  m_properties.add(property);<br/>}</span></pre><p id="e996" class="pw-post-body-paragraph jj jk ht jl b jm jn iu jo jp jq ix jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">它在这里“满眼都是”。你可以看到，在这个课程中有两个变量和一个过程，你的思维和眼睛不会移动太远。你必须使用更多的头部和眼睛运动来达到与上一个例子相同的解释程度。</p><h2 id="220c" class="ls lt ht bd lu lv lw lx ly lz ma mb mc js md me mf jw mg mh mi ka mj mk ml mm bi translated">#03.<strong class="ak">声明与其用法相近的变量。</strong></h2><div class="kw kx ky kz fd ab cb"><figure class="ms hk nj mu mv mw mx paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><img src="../Images/521b1f86b1427c3f335c060338136134.png" data-original-src="https://miro.medium.com/v2/resize:fit:1054/format:webp/1*p9mrCXk-qvONzE3Ax2GJbg.png"/></div></figure><figure class="ms hk nk mu mv mw mx paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><img src="../Images/ea12d05403ba9b9f6a89633c8d1e8661.png" data-original-src="https://miro.medium.com/v2/resize:fit:948/format:webp/1*eYPUrBReiuxzJWAiiwI9fg.png"/></div></figure></div><p id="ecd6" class="pw-post-body-paragraph jj jk ht jl b jm jn iu jo jp jq ix jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">变量的声明应该尽可能与它们的使用位置相似。在第一行你不需要声明一个变量，只需要在第15行使用它。</p><h2 id="ee8f" class="ls lt ht bd lu lv lw lx ly lz ma mb mc js md me mf jw mg mh mi ka mj mk ml mm bi translated">#04.<strong class="ak">相关功能应关闭。</strong></h2><p id="15d7" class="pw-post-body-paragraph jj jk ht jl b jm mn iu jo jp mo ix jr js mp ju jv jw mq jy jz ka mr kc kd ke hb bi translated">相关函数应该分组在一起。函数名首选子函数。这有助于您非常快速地阅读代码，而无需在代码中的各个地方走得太远。</p><p id="6a29" class="pw-post-body-paragraph jj jk ht jl b jm jn iu jo jp jq ix jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">如果一个功能调用另一个功能，它应该是垂直相似的，如果必要，调用方应该在街道上方。这为软件创建了一个正常的流程。</p><h2 id="4bf3" class="ls lt ht bd lu lv lw lx ly lz ma mb mc js md me mf jw mg mh mi ka mj mk ml mm bi translated">#05.<strong class="ak">类似功能应该关闭。</strong></h2><p id="83b1" class="pw-post-body-paragraph jj jk ht jl b jm mn iu jo jp mo ix jr js mp ju jv jw mq jy jz ka mr kc kd ke hb bi translated">一些编码比特倾向于接近其他比特。它们在概念上是相关的。亲和力越大，它们之间的垂直空间就越小。</p><p id="f25e" class="pw-post-body-paragraph jj jk ht jl b jm jn iu jo jp jq ix jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">正如我们所看到的，这种相似性可以基于直接的依赖，比如一个函数调用另一个函数，或者一个向量函数。但是对亲和力的其他潜在解释仍然存在。亲和力可以由作为一组功能的相关活动来诱导。</p><p id="695d" class="pw-post-body-paragraph jj jk ht jl b jm jn iu jo jp jq ix jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated"><strong class="jl hu">好例子:</strong></p><pre class="kw kx ky kz fd mz na nb nc aw nd bi"><span id="45e8" class="ls lt ht na b fi ne nf l ng nh">public class <strong class="na hu">Assert</strong> {</span><span id="8a8c" class="ls lt ht na b fi ni nf l ng nh"> static public void <strong class="na hu">assertTrue</strong>(String message, boolean condition) {<br/>   if (!condition) fail(message);<br/>}</span><span id="07d5" class="ls lt ht na b fi ni nf l ng nh">static public void <strong class="na hu">assertTrue</strong>(boolean condition) { <br/>  assertTrue(null, condition);<br/>}</span><span id="fb16" class="ls lt ht na b fi ni nf l ng nh">static public void <strong class="na hu">assertFalse</strong>(String message, boolean condition) {<br/>  assertTrue(message, !condition);<br/>}</span><span id="17bd" class="ls lt ht na b fi ni nf l ng nh">static public void <strong class="na hu">assertFalse</strong>(boolean condition) {<br/>  assertFalse(null, condition);<br/>} <br/>…</span></pre><p id="6bd7" class="pw-post-body-paragraph jj jk ht jl b jm jn iu jo jp jq ix jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">上述功能彼此紧密相关，因为它们共享相似的命名方案并修改基本任务。他们互相命名是次要的。他们都想靠近在一起，即使他们不愿意。</p><h2 id="bc13" class="ls lt ht bd lu lv lw lx ly lz ma mb mc js md me mf jw mg mh mi ka mj mk ml mm bi translated">#06.<strong class="ak">把职能放在向下的方向。</strong></h2><figure class="kw kx ky kz fd hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es nl"><img src="../Images/abeeb578efac5a7a476e143eb3320025.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CB0jUDfQI8yDqwXA_Er_Yg.png"/></div></div></figure><p id="e842" class="pw-post-body-paragraph jj jk ht jl b jm jn iu jo jp jq ix jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">我们通常希望调用函数中的依赖关系指向下方。像在报纸上一样，我们首先期待最相关的想法，我们期待它们以最少污染的数据呈现。低细节应该最后完成。这有助于浏览源文件，而不必深究信息，从最初的几个函数中获得空间。</p><h2 id="f559" class="ls lt ht bd lu lv lw lx ly lz ma mb mc js md me mf jw mg mh mi ka mj mk ml mm bi translated">#07.<strong class="ak">保持行短。</strong></h2><figure class="kw kx ky kz fd hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es nm"><img src="../Images/bd126d46127cf3a13268108cf06883e1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0eU-kOx8TEoitAXrLr7Bvg.png"/></div></div></figure><p id="776f" class="pw-post-body-paragraph jj jk ht jl b jm jn iu jo jp jq ix jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">我们将有比以前更宽的水平线，因为窗口比以前更大。<br/>以前的标准是80个字符，但现在100-120个字符也可以。<br/>理由是大多数人不会水平滚动阅读我们的代码。<br/>因此，最好保持短行。</p><h2 id="746d" class="ls lt ht bd lu lv lw lx ly lz ma mb mc js md me mf jw mg mh mi ka mj mk ml mm bi translated">#08.<strong class="ak">不要使用水平对齐。</strong></h2><p id="a59e" class="pw-post-body-paragraph jj jk ht jl b jm mn iu jo jp mo ix jr js mp ju jv jw mq jy jz ka mr kc kd ke hb bi translated">我们可能不需要水平对齐变量的声明。<br/>例如，我们可能不必做以下事情:</p><p id="6b2e" class="pw-post-body-paragraph jj jk ht jl b jm jn iu jo jp jq ix jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated"><strong class="jl hu">不好的例子:</strong></p><pre class="kw kx ky kz fd mz na nb nc aw nd bi"><span id="590c" class="ls lt ht na b fi ne nf l ng nh">let num    = 1;<br/>let value  = 2;</span></pre><p id="b863" class="pw-post-body-paragraph jj jk ht jl b jm jn iu jo jp jq ix jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">我们可以把它保持为:</p><p id="af5e" class="pw-post-body-paragraph jj jk ht jl b jm jn iu jo jp jq ix jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated"><strong class="jl hu">好例子:</strong></p><pre class="kw kx ky kz fd mz na nb nc aw nd bi"><span id="1d85" class="ls lt ht na b fi ne nf l ng nh">let num = 1;<br/>let value = 2;</span></pre><p id="67a0" class="pw-post-body-paragraph jj jk ht jl b jm jn iu jo jp jq ix jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">我们可以自动允许代码格式器调整这种间距。</p><p id="b0ea" class="pw-post-body-paragraph jj jk ht jl b jm jn iu jo jp jq ix jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated"><strong class="jl hu">不好的例子:</strong></p><pre class="kw kx ky kz fd mz na nb nc aw nd bi"><span id="c41c" class="ls lt ht na b fi ne nf l ng nh">private   Long            requestParsingTimeLimit;<br/>protected Request         request;<br/>private   FitNesseContent context;<br/>this.context =            context;<br/>input =                   s.getInputStream()<br/>requestParsingTimeLimit = 900;</span></pre><p id="ad71" class="pw-post-body-paragraph jj jk ht jl b jm jn iu jo jp jq ix jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">然而，我认为这种排列是多余的。排列似乎显示了错误的内容，把我的视线拉走了。</p><h2 id="c6ef" class="ls lt ht bd lu lv lw lx ly lz ma mb mc js md me mf jw mg mh mi ka mj mk ml mm bi translated">#09.<strong class="ak">用空格联想相关事物，解除弱相关。</strong></h2><p id="eef8" class="pw-post-body-paragraph jj jk ht jl b jm mn iu jo jp mo ix jr js mp ju jv jw mq jy jz ka mr kc kd ke hb bi translated">某些空格应该在这些实体之间的水平代码行中。变量和操作符之间的空格是引入的好地方。运算符和文字之间也有很大的区别。</p><p id="adbb" class="pw-post-body-paragraph jj jk ht jl b jm jn iu jo jp jq ix jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">我们不要求进程名和最初的括号之间有空格。运算符和变量或文字之间的区别不是很大。<br/>我们需要在闭合手镯、粗箭头和箭头功能的开口支架之间留出空间。</p><p id="91aa" class="pw-post-body-paragraph jj jk ht jl b jm jn iu jo jp jq ix jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">例如，一个干净的水平格式类可能如下所示:</p><p id="118d" class="pw-post-body-paragraph jj jk ht jl b jm jn iu jo jp jq ix jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated"><strong class="jl hu">好例子:</strong></p><pre class="kw kx ky kz fd mz na nb nc aw nd bi"><span id="b32d" class="ls lt ht na b fi ne nf l ng nh">class Calculator {<br/>  constructor(a, b) {<br/>    this.a = a;<br/>    this.b = b;<br/>  }<br/>  <br/>  add() {<br/>    return this.a + this.b;<br/>  }<br/>  <br/>  subtract() {<br/>    return this.a - this.b;<br/>  } <br/> <br/>  multiply() {<br/>    return this.a * this.b;<br/>  }<br/>  <br/>  divide() {<br/>    return this.a / this.b;<br/>  }<br/>}</span></pre><p id="7db7" class="pw-post-body-paragraph jj jk ht jl b jm jn iu jo jp jq ix jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">算术用户之间有一个空格，进程名和它的左括号之间没有空格。</p><p id="001a" class="pw-post-body-paragraph jj jk ht jl b jm jn iu jo jp jq ix jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">每行也少于120个字符。</p><h2 id="9d92" class="ls lt ht bd lu lv lw lx ly lz ma mb mc js md me mf jw mg mh mi ka mj mk ml mm bi translated">#10.<strong class="ak">不破缩进。</strong></h2><p id="9777" class="pw-post-body-paragraph jj jk ht jl b jm mn iu jo jp mo ix jr js mp ju jv jw mq jy jz ka mr kc kd ke hb bi translated">尊重所有代码中的常规缩进非常重要，即使你偶尔想打破这个标准。你会很快发现FOR或IF子句等所做的动作。遵照这条规则。</p><p id="6c80" class="pw-post-body-paragraph jj jk ht jl b jm jn iu jo jp jq ix jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">使用新的IDE和软件，在任何地方都可以很快地使用相同的缩进。</p><p id="bdea" class="pw-post-body-paragraph jj jk ht jl b jm jn iu jo jp jq ix jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">例如:</p><p id="0601" class="pw-post-body-paragraph jj jk ht jl b jm jn iu jo jp jq ix jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated"><strong class="jl hu">不好的例子:</strong></p><pre class="kw kx ky kz fd mz na nb nc aw nd bi"><span id="7ef8" class="ls lt ht na b fi ne nf l ng nh">const loop = ()=&gt;{if(true){for(let x of [1,2,3]){console.log(x)}}};</span></pre><p id="2228" class="pw-post-body-paragraph jj jk ht jl b jm jn iu jo jp jq ix jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">这比阅读起来要困难得多:</p><p id="0324" class="pw-post-body-paragraph jj jk ht jl b jm jn iu jo jp jq ix jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated"><strong class="jl hu">好例子:</strong></p><pre class="kw kx ky kz fd mz na nb nc aw nd bi"><span id="2f33" class="ls lt ht na b fi ne nf l ng nh">const loop = () =&gt; {<br/>  if (true) {<br/>    for (let x of [1, 2, 3]) {<br/>      console.log(x)<br/>    }<br/>  }<br/>};</span></pre><h1 id="05c4" class="nn lt ht bd lu no np nq ly nr ns nt mc iz nu ja mf jc nv jd mi jf nw jg ml nx bi translated">代码格式化工具</h1><p id="52ca" class="pw-post-body-paragraph jj jk ht jl b jm mn iu jo jp mo ix jr js mp ju jv jw mq jy jz ka mr kc kd ke hb bi translated">回忆所有关于正确格式的规则可能很费力。基本原理得到了简单的保护，一份完整的报告已经写好了。因此，您可以使用一系列工具来提高自动化和轻松的格式化，以减少您的工作量。</p><h1 id="d448" class="nn lt ht bd lu no np nq ly nr ns nt mc iz nu ja mf jc nv jd mi jf nw jg ml nx bi translated">在线工具</h1><p id="62c8" class="pw-post-body-paragraph jj jk ht jl b jm mn iu jo jp mo ix jr js mp ju jv jw mq jy jz ka mr kc kd ke hb bi translated">有一组工具，您可以向其中添加代码并发布更可爱的版本:</p><ul class=""><li id="aabe" class="le lf ht jl b jm jn jp jq js lg jw lh ka li ke ny lk ll lm bi translated"><a class="ae nz" href="https://www.freeformatter.com/html-formatter.html" rel="noopener ugc nofollow" target="_blank"> <strong class="jl hu"> HTML格式器</strong> </a></li><li id="d08e" class="le lf ht jl b jm ln jp lo js lp jw lq ka lr ke ny lk ll lm bi translated"><a class="ae nz" href="http://www.phpformatter.com/" rel="noopener ugc nofollow" target="_blank">T5】PHP格式化程序T7】</a></li><li id="8ba2" class="le lf ht jl b jm ln jp lo js lp jw lq ka lr ke ny lk ll lm bi translated"><a class="ae nz" href="https://www.codebeautifier.com/" rel="noopener ugc nofollow" target="_blank"> <strong class="jl hu"> CSS格式器和美化器</strong> </a></li><li id="d0c1" class="le lf ht jl b jm ln jp lo js lp jw lq ka lr ke ny lk ll lm bi translated"><a class="ae nz" href="https://beautifier.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="jl hu"> JavaScript美化器</strong> </a></li></ul><h1 id="8c6a" class="nn lt ht bd lu no np nq ly nr ns nt mc iz nu ja mf jc nv jd mi jf nw jg ml nx bi translated">代码编辑器插件</h1><p id="6bf0" class="pw-post-body-paragraph jj jk ht jl b jm mn iu jo jp mo ix jr js mp ju jv jw mq jy jz ka mr kc kd ke hb bi translated">ide中还有许多插件/扩展，例如:</p><div class="kw kx ky kz fd ab cb"><figure class="ms hk oa mu mv mw mx paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><img src="../Images/4054b5057740498a2a4d6670e3df244b.png" data-original-src="https://miro.medium.com/v2/resize:fit:656/format:webp/0*nXgkVvgCTM1YBPQ6.png"/></div></figure><figure class="ms hk ob mu mv mw mx paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><img src="../Images/51232fd72ce1debb6c8942561d3d863c.png" data-original-src="https://miro.medium.com/v2/resize:fit:574/format:webp/0*U3yjm73XeVGocNpN.png"/></div></figure><figure class="ms hk oc mu mv mw mx paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><img src="../Images/0157fc0f694bb3c88b0f9a946baf03e0.png" data-original-src="https://miro.medium.com/v2/resize:fit:774/format:webp/0*aUSFjEQCi9uID3gl.png"/></div></figure></div><ul class=""><li id="6a65" class="le lf ht jl b jm jn jp jq js lg jw lh ka li ke ny lk ll lm bi translated"><a class="ae nz" href="https://prettier.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="jl hu">更漂亮. io </strong> </a>(适用于Atom、Espresso、Sublime Text、WebStorm、VSCode等)</li></ul><blockquote class="kf kg kh"><p id="9cc2" class="jj jk ki jl b jm jn iu jo jp jq ix jr kj jt ju jv kk jx jy jz kl kb kc kd ke hb bi translated">Prettier是固执己见的代码的格式化程序。通过解析您的代码，并根据自己的准则重新打印(考虑了最大行长度和换行代码),它实施了一个标准化的模板。</p></blockquote><ul class=""><li id="48fd" class="le lf ht jl b jm jn jp jq js lg jw lh ka li ke ny lk ll lm bi translated"><a class="ae nz" href="https://stylelint.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="jl hu">棉绒</strong> </a></li></ul><blockquote class="kf kg kh"><p id="9faf" class="jj jk ki jl b jm jn iu jo jp jq ix jr kj jt ju jv kk jx jy jz kl kb kc kd ke hb bi translated">一个强大和现代的棉绒，以防止错误和实施您的公约类型。</p></blockquote><ul class=""><li id="9392" class="le lf ht jl b jm jn jp jq js lg jw lh ka li ke ny lk ll lm bi translated"><a class="ae nz" href="https://palantir.github.io/tslint/" rel="noopener ugc nofollow" target="_blank"> <strong class="jl hu"> ES/TSLint </strong> </a></li></ul><blockquote class="kf kg kh"><p id="414c" class="jj jk ki jl b jm jn iu jo jp jq ix jr kj jt ju jv kk jx jy jz kl kb kc kd ke hb bi translated">TSLint是一个可扩展的静态分析工具，它监视TypeScript代码的可读性、维护和功能。它在当前的编辑器和构建环境中受到普遍支持，并且可以适应您自己的lint规则、设置和格式化程序。</p></blockquote><ul class=""><li id="0d13" class="le lf ht jl b jm jn jp jq js lg jw lh ka li ke ny lk ll lm bi translated"><a class="ae nz" href="https://marketplace.visualstudio.com/items?itemName=kisstkondoros.vscode-codemetrics" rel="noopener ugc nofollow" target="_blank"> <strong class="jl hu">代码度量</strong> </a></li></ul><blockquote class="kf kg kh"><p id="c4bd" class="jj jk ki jl b jm jn iu jo jp jq ix jr kj jt ju jv kk jx jy jz kl kb kc kd ke hb bi translated">现代软件系统日益增长的复杂性也使得代码变得稳定和可维护。代码度量为开发人员提供了他们所生产的代码的更深入的视图。使用代码度量，开发人员可以理解哪些风格和/或方法可以被更仔细地返工或检查。项目团队应该识别可能的威胁，考虑整个项目状态，并监控软件开发的成功。</p></blockquote><figure class="kw kx ky kz fd hk er es paragraph-image"><div class="er es od"><img src="../Images/13d03d216e0fe203bd3f46691fd4dac0.png" data-original-src="https://miro.medium.com/v2/resize:fit:256/0*53sMxsku6DTPNPsv"/></div></figure><ul class=""><li id="f2fd" class="le lf ht jl b jm jn jp jq js lg jw lh ka li ke ny lk ll lm bi translated"><a class="ae nz" href="https://atom.io/packages/atom-beautify" rel="noopener ugc nofollow" target="_blank"> <strong class="jl hu">原子美化</strong> </a></li><li id="a955" class="le lf ht jl b jm ln jp lo js lp jw lq ka lr ke ny lk ll lm bi translated"><a class="ae nz" href="https://packagecontrol.io/packages/HTML-CSS-JS%20Prettify" rel="noopener ugc nofollow" target="_blank"> <strong class="jl hu"> HTML-CSS-JS美化崇高文字</strong> </a></li></ul><h2 id="cab5" class="ls lt ht bd lu lv lw lx ly lz ma mb mc js md me mf jw mg mh mi ka mj mk ml mm bi translated">结论</h2><p id="b79f" class="pw-post-body-paragraph jj jk ht jl b jm mn iu jo jp mo ix jr js mp ju jv jw mq jy jz ka mr kc kd ke hb bi translated">代码格式可以提高代码的可读性和解释能力。在项目开始时，旨在确定并准备在必要和适当的情况下修改这些法规。</p><p id="8f42" class="pw-post-body-paragraph jj jk ht jl b jm jn iu jo jp jq ix jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">注意，最短的规则是最好的！</p><blockquote class="oe"><p id="c0a6" class="of og ht bd oh oi oj ok ol om on ke dx translated">不要浪费时间手工格式化你的代码。花在编写更多代码上的时间会更好。利用外面令人惊奇的现代工具。</p></blockquote></div></div>    
</body>
</html>