<html>
<head>
<title>Recreate Flexible Content with Gatsby &amp; Netlify CMS</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Gatsby &amp; Netlify CMS重新创建灵活的内容</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/reacreate-flexible-content-with-gatsby-netlify-cms-8c34ee308919?source=collection_archive---------19-----------------------#2021-04-16">https://medium.com/nerd-for-tech/reacreate-flexible-content-with-gatsby-netlify-cms-8c34ee308919?source=collection_archive---------19-----------------------#2021-04-16</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><figure class="hh hi ez fb hj hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es hg"><img src="../Images/a438c4e524cae9942c61196acfe71f04.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*tC45irTa6xhFK3rs"/></div></div><figcaption class="hr hs et er es ht hu bd b be z dx translated">费伦茨·阿尔马西在<a class="ae hv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><div class=""/><h1 id="37c3" class="iv iw hy bd ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js bi translated">如果你是一个WordPress开发者，那么你一定听说过一个叫做高级定制域的插件和一个灵活的内容域，它允许编辑轻松地生成新页面。</h1><p id="f452" class="pw-post-body-paragraph jt ju hy jv b jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq hb bi translated">当我开始更多地进入JAMStack时，我想在Gatsby中重建ACF的灵活内容领域。可以把WordPress作为一个无头的CMS来使用，一些无头的CMS已经实现了某种替代方案。Prismic有切片(不幸的是，您不能在字段中创建多个可重复的字段)。</p><p id="2802" class="pw-post-body-paragraph jt ju hy jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated"><strong class="jv hz">对于较小的项目，WordPress或Prismic可能太复杂。在这种情况下，我通常选择我最喜欢的平面文件CMS——Netlify CMS。</strong></p><p id="9b12" class="pw-post-body-paragraph jt ju hy jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">Netlify CMS提供你需要的一切，它是开源的，可以免费使用。唯一缺少的是什么？灵活的内容字段。幸运的是，有了beta特性——手动初始化和列表字段的变量类型,我们可以很容易地创建一个复制ACF灵活内容的解决方案。</p><h1 id="94af" class="iv iw hy bd ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js bi translated">为什么使用灵活的内容是一个好主意？</h1><p id="4d2c" class="pw-post-body-paragraph jt ju hy jv b jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq hb bi translated">高级定制字段的灵活内容允许编辑人员<strong class="jv hz">在没有开发人员参与的情况下快速做出重大更改。创建新页面是一件轻而易举的事，为转换而优化也更容易。</strong></p><p id="e30b" class="pw-post-body-paragraph jt ju hy jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">使用单一模板可能不是组织内容的最佳方式，尤其是当您想要快速测试新的更改时。这就是为什么<strong class="jv hz">基于组件的模块化设计为您提供了更大的灵活性。</strong></p><p id="9433" class="pw-post-body-paragraph jt ju hy jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated"><strong class="jv hz">它降低了开发和维护成本。</strong>网站是产生商业价值的工具。你构建的系统越好，它在没有任何代码变化的情况下持续的时间就越长。</p><h1 id="6703" class="iv iw hy bd ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js bi translated">Netlify CMS的灵活内容—配置</h1><p id="8dc4" class="pw-post-body-paragraph jt ju hy jv b jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq hb bi translated">代码示例假设使用手动初始化，<a class="ae hv" href="https://mrkaluzny.com/blog/dry-netlify-cms-config-with-manual-initialization/" rel="noopener ugc nofollow" target="_blank">查看这篇关于DRY Netlify CMS配置的文章</a>以了解更多信息。</p><p id="f31a" class="pw-post-body-paragraph jt ju hy jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">我强烈建议使用这种配置来代替标准配置，以获得最佳的开发体验。手动初始化利用了javascript文件而不是YAML，这使得长期维护更加容易。</p><p id="7289" class="pw-post-body-paragraph jt ju hy jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">您可以查看我的<a class="ae hv" href="https://github.com/clean-commit/gatsby-starter-henlo" rel="noopener ugc nofollow" target="_blank">Gatsby started called Henlo</a>来查看该配置的示例，并将其作为起点。</p><p id="fc98" class="pw-post-body-paragraph jt ju hy jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">对于每个灵活的内容项(在本文中我称之为部分),我们需要2个文件。一个JSX文件渲染部分(我倾向于放置它们)。/src/Sections '文件夹)和CMS的配置文件('。/src/cms/sections/'文件夹)。</p><h1 id="3eb8" class="iv iw hy bd ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js bi translated">准备Netlify CMS配置</h1><p id="d76b" class="pw-post-body-paragraph jt ju hy jv b jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq hb bi translated">首先，我们必须为集合设置一个配置，我们将使用它来创建包含节的页面。</p><pre class="kw kx ky kz fd la lb lc ld aw le bi"><span id="e3c2" class="lf iw hy lb b fi lg lh l li lj"><em class="lk">import</em> seo <em class="lk">from</em> '@/cms/partials/seo'<br/><em class="lk">import</em> hero <em class="lk">from</em> '@/cms/sections/hero'<br/>...</span><span id="8f8d" class="lf iw hy lb b fi ll lh l li lj"><em class="lk">const</em> services = {<br/>  name: 'pages',<br/>  label: 'Pages',<br/>  editor: {<br/>    preview: false,<br/>  },<br/>  folder: 'content/pages',<br/>  slug: '{{slug}}',<br/>  create: true,<br/>  fields: [<br/>	  {<br/>		  label: 'Layout'<br/>		  name: 'layout'<br/>		  widget: 'hidden',<br/>		  <em class="lk">default</em>: 'page',<br/>	  }<br/>    {<br/>      label: 'Title',<br/>      name: 'title',<br/>      widget: 'string',<br/>      required: true,<br/>    },<br/>    {<br/>      label: 'Slug',<br/>      name: 'slug',<br/>      widget: 'string',<br/>      required: true,<br/>    },<br/>    {<br/>      label: 'Sections',<br/>      name: 'sections',<br/>      widget: 'list',<br/>      types: [<br/>        hero,<br/>        ...<br/>      ],<br/>    },<br/>    seo,<br/>  ],<br/>}</span><span id="9147" class="lf iw hy lb b fi ll lh l li lj"><em class="lk">export</em> <em class="lk">default</em> services</span></pre><p id="618f" class="pw-post-body-paragraph jt ju hy jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">在这个例子中，我使用一个javascript文件为Netlify CMS生成一个集合。查看这篇<a class="ae hv" href="https://mrkaluzny.com/blog/dry-netlify-cms-config-with-manual-initialization/" rel="noopener ugc nofollow" target="_blank">关于Netlify CMS配置</a>的文章，了解为什么它比YAML文件更好。</p><p id="8d53" class="pw-post-body-paragraph jt ju hy jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">要使用的最重要的字段是<code class="du lm ln lo lb b">layout</code>。我使用它们来传递用于呈现该内容类型的模板文件的名称。</p><p id="a8cd" class="pw-post-body-paragraph jt ju hy jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">正如你所看到的，我添加了2个部分——SEO部分，处理SEO内容和英雄部分。将这些字段分离到不同的文件中，可以更容易地维护组件并在整个项目中重用它们。</p><p id="7337" class="pw-post-body-paragraph jt ju hy jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">这里是英雄部分的配置示例。</p><pre class="kw kx ky kz fd la lb lc ld aw le bi"><span id="7144" class="lf iw hy lb b fi lg lh l li lj"><em class="lk">const</em> hero = {<br/>  label: 'Hero',<br/>  name: 'hero',<br/>  widget: 'object',<br/>  collapsed: false,<br/>  fields: [<br/>    {<br/>      label: 'Title',<br/>      name: 'title',<br/>      widget: 'string',<br/>      required: false,<br/>    },<br/>    {<br/>      label: 'Subtitle',<br/>      name: 'subtitle',<br/>      widget: 'string',<br/>      required: false,<br/>    },<br/>    {<br/>      label: 'Content',<br/>      name: 'content',<br/>      widget: 'markdown',<br/>      required: false,<br/>    },<br/>  ],<br/>}</span><span id="dab6" class="lf iw hy lb b fi ll lh l li lj"><em class="lk">export</em> <em class="lk">default</em> hero</span></pre><p id="b77a" class="pw-post-body-paragraph jt ju hy jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">现在我们已经有了Netlify CMS的初始配置，我们可以开始从我们的集合生成页面了。</p><h1 id="5c88" class="iv iw hy bd ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js bi translated">通过Gatsby &amp; Netlify使用灵活的内容生成页面</h1><p id="75af" class="pw-post-body-paragraph jt ju hy jv b jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq hb bi translated">另一个要遵循的良好实践是利用父组件来管理我们的部分。这样，您可以向其他模板或页面添加部分。</p><h1 id="0962" class="iv iw hy bd ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js bi translated">创建截面生成器组件</h1><p id="f233" class="pw-post-body-paragraph jt ju hy jv b jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq hb bi translated">组件的想法非常简单。我最近与Prismic合作的一个项目给了我灵感，<a class="ae hv" href="https://prismic.io/docs/technologies/tutorial-3-create-homepage-slices-gatsby#4.-update-the-slicezone-component" rel="noopener ugc nofollow" target="_blank">这个组件模仿SliceZone组件</a>。</p><p id="c776" class="pw-post-body-paragraph jt ju hy jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">添加新的部分就像导入组件并将其与部分类型(Netlify CMS配置中的对象名称)匹配一样简单。</p><pre class="kw kx ky kz fd la lb lc ld aw le bi"><span id="8ae4" class="lf iw hy lb b fi lg lh l li lj"><em class="lk">import</em> React <em class="lk">from</em> 'react'<br/><em class="lk">import</em> { graphql } <em class="lk">from</em> 'gatsby'</span><span id="f11a" class="lf iw hy lb b fi ll lh l li lj"><em class="lk">import</em> Hero <em class="lk">from</em> '@/Sections/Hero'</span><span id="eb06" class="lf iw hy lb b fi ll lh l li lj"><em class="lk">export</em> <em class="lk">default</em> <em class="lk">function</em> SectionsGenerator({ sections }) {<br/>	<em class="lk">const</em> sectionsComponents = {<br/>		hero: Hero<br/>	}<br/>	<br/>	<em class="lk">const</em> sectionsContent = sections.map((section, key) =&gt; {<br/>		<em class="lk">const</em> Section = sectionsComponents[section.type]<br/>		<em class="lk">if</em> (Section) {<br/>			<em class="lk">return</em> &lt;Section key={key} data={section} /&gt;<br/>		}<br/>		<em class="lk">return</em> &lt;div&gt;{section.type}&lt;/div&gt;<br/>	})<br/>	<br/>	<em class="lk">return</em> (<br/>		&lt;&gt;<br/>			{sectionsContent}<br/>		&lt;/&gt;<br/>	)<br/>}</span><span id="ada0" class="lf iw hy lb b fi ll lh l li lj"><em class="lk">export</em> <em class="lk">const</em> query = graphql`<br/>  fragment Sections on MarkdownRemarkFrontmatter {<br/>    sections {<br/>      id<br/>      type<br/>      title<br/>      subtitle<br/>      content<br/>  }<br/>}<br/>`</span></pre><p id="fce5" class="pw-post-body-paragraph jt ju hy jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">此外，我建议在同一个文件中创建一个graphql片段。通过一次导入，我们可以将数据传递给查询，并将部分呈现给项目中的任何模板页面(请参见下一个代码示例)</p><h1 id="9c09" class="iv iw hy bd ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js bi translated">准备呈现页面的模板</h1><p id="ced6" class="pw-post-body-paragraph jt ju hy jv b jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq hb bi translated">我们的模板必须做一件事——获取部分数据并将它们作为道具传递给<code class="du lm ln lo lb b">SectionsGenerator</code>组件。</p><p id="8437" class="pw-post-body-paragraph jt ju hy jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">使用这种方法，还可以对每个页面使用单一布局。使用<code class="du lm ln lo lb b">useStaticQuery</code>钩子可以给每个部分添加额外的数据。</p><pre class="kw kx ky kz fd la lb lc ld aw le bi"><span id="77ce" class="lf iw hy lb b fi lg lh l li lj"><em class="lk">import</em> React <em class="lk">from</em> 'react'<br/><em class="lk">import</em> { graphql } <em class="lk">from</em> 'gatsby'</span><span id="d76a" class="lf iw hy lb b fi ll lh l li lj"><em class="lk">import</em> Layout <em class="lk">from</em> '@/components/Layout'<br/><em class="lk">import</em> SectionsGenerator <em class="lk">from</em> '@/components/SectionsGenerator'</span><span id="5680" class="lf iw hy lb b fi ll lh l li lj"><em class="lk">import</em> SEO <em class="lk">from</em> '@/components/SEO/Seo'</span><span id="5abd" class="lf iw hy lb b fi ll lh l li lj"><em class="lk">const</em> SectionPageTemplate = ({ data }) =&gt; {<br/>  <em class="lk">const</em> sections = data.frontmatter.sections<br/>  <em class="lk">return</em> (<br/>    &lt;&gt;<br/>      &lt;SectionsGenerator sections={sections} /&gt;<br/>    &lt;/&gt;<br/>  )<br/>}</span><span id="7e7f" class="lf iw hy lb b fi ll lh l li lj"><em class="lk">const</em> LandingPage = ({ data }) =&gt; {<br/>  <em class="lk">return</em> (<br/>    &lt;Layout hideNav={true}&gt;<br/>      &lt;SEO data={data.page.frontmatter.seo} /&gt;<br/>      &lt;SectionPageTemplate data={data.page} /&gt;<br/>    &lt;/Layout&gt;<br/>  )<br/>}</span><span id="04b6" class="lf iw hy lb b fi ll lh l li lj"><em class="lk">export</em> <em class="lk">default</em> SectionPage</span><span id="67bb" class="lf iw hy lb b fi ll lh l li lj"><em class="lk">export</em> <em class="lk">const</em> sectionsPageQuery = graphql`<br/>  query SectionPage($id: String!) {<br/>    page: markdownRemark(id: { eq: $id }) {<br/>      id<br/>      fields {<br/>        slug<br/>      }<br/>      html<br/>      frontmatter {<br/>        title<br/>        ...Sections<br/>        ...SEO<br/>      }<br/>    }<br/>  }<br/>`</span></pre><p id="d2af" class="pw-post-body-paragraph jt ju hy jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">通过编写一个片段，无论项目支持多少个部分，我们的查询都会非常短。</p><h1 id="cc65" class="iv iw hy bd ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js bi translated">配置Gatsby-node以使用具有灵活内容的Netlify CMS</h1><p id="08d6" class="pw-post-body-paragraph jt ju hy jv b jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq hb bi translated">所有组件准备就绪后，我们可以继续进行<code class="du lm ln lo lb b">gatsby-node</code>配置。</p><pre class="kw kx ky kz fd la lb lc ld aw le bi"><span id="1ec6" class="lf iw hy lb b fi lg lh l li lj">exports.createPages = ({ actions, graphql }) =&gt; {<br/>  <em class="lk">const</em> { createPage } = actions</span><span id="48a9" class="lf iw hy lb b fi ll lh l li lj">  <em class="lk">return</em> graphql(`<br/>    {<br/>      allMarkdownRemark(limit: 1000) {<br/>        edges {<br/>          node {<br/>            id<br/>            fields {<br/>              slug<br/>            }<br/>            frontmatter {<br/>              layout<br/>              title<br/>              slug<br/>            }<br/>          }<br/>        }<br/>      }<br/>    }<br/>  `).then((result) =&gt; {<br/>    <em class="lk">if</em> (result.errors) {<br/>      result.errors.forEach((e) =&gt; console.error(e.toString()))<br/>      // return Promise.reject(result.errors);<br/>    }</span><span id="5cb3" class="lf iw hy lb b fi ll lh l li lj">    // Filter out the footer, navbar, and meetups so we don't create pages for those<br/>    <em class="lk">const</em> postOrPage = result.data.allMarkdownRemark.edges.filter((edge) =&gt; {<br/>	    <em class="lk">let</em> layout = edge.node.frontmatter.layout<br/>	    <em class="lk">return</em> layout == <em class="lk">null</em> || layout == 'hidden'<br/>    })</span><span id="68f6" class="lf iw hy lb b fi ll lh l li lj">    postOrPage.forEach((edge) =&gt; {<br/>      <em class="lk">const</em> id = edge.node.id<br/>      <em class="lk">let</em> component = path.resolve(<br/>        `src/templates/${String(edge.node.frontmatter.layout)}.js`,<br/>      )<br/>      <em class="lk">if</em> (fs.existsSync(component)) {<br/>        <em class="lk">switch</em> (edge.node.frontmatter.layout) {<br/>          <em class="lk">case</em> 'page':<br/>            createPage({<br/>              path: `/${Helper.slugify(edge.node.frontmatter.slug)}/`,<br/>              component,<br/>              context: {<br/>                id,<br/>              },<br/>            })<br/>            <em class="lk">break</em><br/>            ...<br/>        }<br/>      }<br/>    })<br/>  })<br/>}</span></pre><p id="8521" class="pw-post-body-paragraph jt ju hy jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">为了生成正确的slug，我们必须利用添加到集合中每个页面的slug字段。通过这种方式，编辑可以更新URL来创建许多页面，甚至是有层次结构的页面(尽管这不会反映在Netlify CMS的UI中)。</p><p id="79ce" class="pw-post-body-paragraph jt ju hy jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">在我的项目中，我倾向于在URL中使用斜杠，这有助于避免Gatsby和Netlify的一些SEO优化问题。</p><p id="a049" class="pw-post-body-paragraph jt ju hy jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">我用一个助手来清理网页的网址，并确保它不会引起任何问题。</p><h1 id="db61" class="iv iw hy bd ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js bi translated">请注意这些问题</h1><p id="3c04" class="pw-post-body-paragraph jt ju hy jv b jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq hb bi translated">有一个问题，如果我们试图创建一个页面并调用一个不存在的元素，页面生成将会失败。为什么？</p><p id="2c50" class="pw-post-body-paragraph jt ju hy jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated"><strong class="jv hz"> Gatsby根据我们提供的内容推断字段的类型。</strong>如果该字段的内容不存在，则构建过程失败。为了避免这个问题，我们必须让盖茨比知道会发生什么。</p><p id="6843" class="pw-post-body-paragraph jt ju hy jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">我们这样做，但是在<code class="du lm ln lo lb b">gatsby-node.js</code>文件中定义类型。这是我在为Clean Commit网站设计新的登陆页面时写的一个例子。</p><pre class="kw kx ky kz fd la lb lc ld aw le bi"><span id="91ba" class="lf iw hy lb b fi lg lh l li lj">exports.createSchemaCustomization = ({ actions }) =&gt; {<br/>  actions.createTypes(`<br/>    type Button {<br/>      text: String<br/>      link: String<br/>    }</span><span id="c104" class="lf iw hy lb b fi ll lh l li lj">    type List {<br/>      title: String<br/>      content: String<br/>    }</span><span id="1474" class="lf iw hy lb b fi ll lh l li lj">    type Form {<br/>      provider: String<br/>      title: String<br/>      formid: Int<br/>      redirect: String<br/>      button: String<br/>    }</span><span id="40cc" class="lf iw hy lb b fi ll lh l li lj">    type FAQ {<br/>      question: String<br/>      answer: String<br/>    }</span><span id="86d0" class="lf iw hy lb b fi ll lh l li lj">    type MarkdownRemarkFrontmatterSections @infer {<br/>      id: String<br/>      type: String<br/>      subheader: String<br/>      title: String<br/>      subtitle: String<br/>      background: String<br/>      content: String<br/>      variant: String<br/>      video: String<br/>      bulletpoints: [String]<br/>      secondarycontent: String<br/>      button: Button<br/>      list: [List]<br/>      form: Form<br/>      faqs: [FAQ]<br/>    }<br/>  `)<br/>}</span></pre><p id="710b" class="pw-post-body-paragraph jt ju hy jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">我们准备了17个不同的部分，我们的团队可以用它们来创建新的登录页面和服务。有了定义的类型，我们可以安全地部署网站，在构建过程中不会出现任何问题。</p><h1 id="1105" class="iv iw hy bd ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js bi translated">部分字段命名</h1><p id="32cf" class="pw-post-body-paragraph jt ju hy jv b jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq hb bi translated">使用Netlify CMS创建灵活的内容体验不同于其他任何无头CMS。此时，没有办法只查询一个部分的内容。这就是为什么字段的命名约定必须一致(否则您将花费大量时间编写自定义类型定义)。</p><p id="feb7" class="pw-post-body-paragraph jt ju hy jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">这就是为什么在多个部分中重用相同的名称并尽可能保持一致非常重要。对于Clean Commit的登录页面，几乎每个部分都使用<code class="du lm ln lo lb b">title</code>、<code class="du lm ln lo lb b">content</code>、<code class="du lm ln lo lb b">subheader</code>和<code class="du lm ln lo lb b">button</code>字段。所以在你做项目的时候要记住这一点！</p><p id="5e7e" class="pw-post-body-paragraph jt ju hy jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">如果你想了解这个解决方案是如何工作的，你可以创建什么，看看干净提交服务页面，如<a class="ae hv" href="https://cleancommit.io/services/website-development/" rel="noopener ugc nofollow" target="_blank">网站开发</a>、<a class="ae hv" href="https://cleancommit.io/services/app-development/" rel="noopener ugc nofollow" target="_blank">应用程序开发</a>或<a class="ae hv" href="https://cleancommit.io/services/frontend-development/" rel="noopener ugc nofollow" target="_blank">前端开发</a>。</p><p id="598b" class="pw-post-body-paragraph jt ju hy jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">与我的团队一起，我们为Netlify CMS创建(并积极维护)了我们自己的<a class="ae hv" href="https://github.com/clean-commit/gatsby-starter-henlo" rel="noopener ugc nofollow" target="_blank"> Gatsby Starter，名为Henlo</a>——来看看吧，给我们一些爱！</p><h1 id="acb3" class="iv iw hy bd ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js bi translated">如何在Netlify CMS中创建灵活的内容字段</h1><ul class=""><li id="7e5a" class="lp lq hy jv b jw jx ka kb ke lr ki ls km lt kq lu lv lw lx bi translated">使用手动初始化使配置文件管理更容易。</li><li id="44c4" class="lp lq hy jv b jw ly ka lz ke ma ki mb km mc kq lu lv lw lx bi translated">利用列表小部件和使用类型选项</li><li id="de12" class="lp lq hy jv b jw ly ka lz ke ma ki mb km mc kq lu lv lw lx bi translated">创建一个组件来呈现每个部分组件</li><li id="ddc7" class="lp lq hy jv b jw ly ka lz ke ma ki mb km mc kq lu lv lw lx bi translated">将该组件添加到您想要使用它模板中</li><li id="2bb0" class="lp lq hy jv b jw ly ka lz ke ma ki mb km mc kq lu lv lw lx bi translated">定义节中使用的字段类型，以避免Gatsby中类型推断的构建错误</li></ul></div></div>    
</body>
</html>