<html>
<head>
<title>Postgres — BRIN Index with Update/Delete</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Postgres —带更新/删除的布林索引</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/postgres-brin-index-77b2b8128aef?source=collection_archive---------7-----------------------#2021-03-08">https://medium.com/nerd-for-tech/postgres-brin-index-77b2b8128aef?source=collection_archive---------7-----------------------#2021-03-08</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/c9c9e30daf0cb2dd7490ae47976f6365.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*N4V-V9m4hmJNNrZ92y0TOQ.jpeg"/></div></div></figure><p id="9af6" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><em class="jo"> PostgreSQL </em>是一个受欢迎的<em class="jo">开放</em> - <em class="jo">来源</em>关系数据库，在 AWS、Azure 和 GCP 等大型云玩家中提供了许多功能和产品，使其成为首选数据库。Postgres 支持许多不同类型的索引，如 Gin/Gist/Partial/BRIN。我读到了 BRIN 的概念，并对它进行了进一步的探索。以下是我对布林指数的理解。</p><p id="2645" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">什么是布林指数？</strong></p><p id="1075" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">BRIN 代表“<strong class="is hj">块范围索引</strong>”。它存储索引创建时由参数 pages_per_range 定义的块范围的最大/最小值。</p><pre class="jp jq jr js fd jt ju jv jw aw jx bi"><span id="c100" class="jy jz hi ju b fi ka kb l kc kd">create index idx_test on test using brin (last_updated_date) with (pages_per_range = 32);</span></pre><p id="7ee3" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">默认情况下，pages_per_range 为 128，这意味着对于 8kb 的块大小，将按 128*8Kb=1Mb 的块计算最小值/最大值。</p><p id="0243" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">Btree Index 在索引结构中存储列值，而 BRIN 只存储各个块范围的最大/最小信息。这就是为什么布林指数比三棵树指数小得多。</p><p id="d7cb" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">使用模式和反模式:</strong></p><ol class=""><li id="8d8a" class="ke kf hi is b it iu ix iy jb kg jf kh jj ki jn kj kk kl km bi translated">由于 BRIN 索引只存储定义了 BRIN 索引块、列的相邻范围的高值和低值，所以数据应该以排序的方式出现。如果数据没有排序，那么 BRIN Index 不能有效地过滤掉数据，需要接触更多的表块。</li><li id="b1a3" class="ke kf hi is b it kn ix ko jb kp jf kq jj kr jn kj kk kl km bi translated">Btree 索引在 B+树结构中存储列信息，因此通过树的分支遍历树以获得特定值更容易。而在 BRIN 中检查一个值需要扫描 BRIN 索引结构的所有页面。因此，如果一个查询只选择了很少的记录，那么使用 Btree 索引和查询来过滤表中的大量数据是合适的，BRIN 索引更有意义。</li><li id="3506" class="ke kf hi is b it kn ix ko jb kp jf kq jj kr jn kj kk kl km bi translated">表上应该没有(或很少)更新/删除。更新/删除导致块中的死元组，这些元组稍后通过清空过程释放。一旦进行了清空，这些块就是空闲列表的一部分(在 Postgres 中，没有像 Oracle 那样的<strong class="is hj"> PCTUSED </strong>参数),新行将进入这些块孔，从而改变这些块的最小/最大范围，使其落入更大的范围内(假设数据按照第 1 点中提到的方式排序)。</li><li id="1978" class="ke kf hi is b it kn ix ko jb kp jf kq jj kr jn kj kk kl km bi translated">在索引列上筛选数据，然后在同一列上进行排序的查询，Btree 索引更合适，因为它以排序的方式存储数据，因此可以避免排序。而 BRIN Index 需要在过滤掉数据后进行排序。</li></ol><p id="e784" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">在具有高 DML 活动的表上演示 BRIN 索引用法:</strong></p><ul class=""><li id="ca5a" class="ke kf hi is b it iu ix iy jb kg jf kh jj ki jn ks kk kl km bi translated">用于检查表中空闲空间块的扩展。</li></ul><pre class="jp jq jr js fd jt ju jv jw aw jx bi"><span id="a349" class="jy jz hi ju b fi ka kb l kc kd">create extension pg_freespacemap;</span></pre><ul class=""><li id="95bc" class="ke kf hi is b it iu ix iy jb kg jf kh jj ki jn ks kk kl km bi translated">创建测试表并填充 100M 行。</li></ul><pre class="jp jq jr js fd jt ju jv jw aw jx bi"><span id="3662" class="jy jz hi ju b fi ka kb l kc kd">CREATE TABLE test (id bigint);</span><span id="998a" class="jy jz hi ju b fi kt kb l kc kd">INSERT INTO test SELECT g.id FROM generate_series(1, 10000000) AS g (id);</span><span id="ef14" class="jy jz hi ju b fi kt kb l kc kd">create index idx_test on test using brin (id) with (pages_per_range = 8);</span></pre><ul class=""><li id="4b9a" class="ke kf hi is b it iu ix iy jb kg jf kh jj ki jn ks kk kl km bi translated">检查表格中的块数和每个块的平均行数。</li></ul><pre class="jp jq jr js fd jt ju jv jw aw jx bi"><span id="2c3e" class="jy jz hi ju b fi ka kb l kc kd">SELECT count(*) FROM pg_freespace(‘test’);<br/>44248</span><span id="08f8" class="jy jz hi ju b fi kt kb l kc kd">select 10000000/44248; --rows/blocks<br/>225</span></pre><ul class=""><li id="8d3a" class="ke kf hi is b it iu ix iy jb kg jf kh jj ki jn ks kk kl km bi translated">使用布林索引获取记录</li></ul><pre class="jp jq jr js fd jt ju jv jw aw jx bi"><span id="0254" class="jy jz hi ju b fi ka kb l kc kd">postgres=&gt; explain analyze select count(*) from test where id &gt; 2000000 and id &lt; 3000000;<br/>QUERY PLAN<br/>Aggregate (cost=62215.24..62215.25 rows=1 width=8) (actual time=621.741..621.741 rows=1 loops=1)<br/>-&gt; Bitmap Heap Scan on test (cost=344.79..59698.52 rows=1006689 width=0) (actual time=47.769..358.479 rows=999999 loops=1)<br/>Recheck Cond: ((id &gt; 2000000) AND (id &lt; 3000000))<br/><strong class="ju hj">Rows Removed by Index Recheck: 1633</strong><br/><strong class="ju hj">Heap Blocks: lossy=4432</strong><br/>-&gt; Bitmap Index Scan on idx_test (cost=0.00..93.11 rows=1007049 width=0) (actual time=47.722..47.723 rows=44320 loops=1)<br/>Index Cond: ((id &gt; 2000000) AND (id &lt; 3000000))</span></pre><ul class=""><li id="dbd5" class="ke kf hi is b it iu ix iy jb kg jf kh jj ki jn ks kk kl km bi translated">在每个表块中创建孔，并向其中插入新数据(最坏的情况)。</li></ul><pre class="jp jq jr js fd jt ju jv jw aw jx bi"><span id="1fd0" class="jy jz hi ju b fi ka kb l kc kd">--currently all blocks are fully packed<br/>select * from pg_freespace(‘test’) where avail != 0;<br/>0</span><span id="3eab" class="jy jz hi ju b fi kt kb l kc kd">--delete record from each of the table block<br/>delete from TEST where mod(id,100) = 0;<br/>DELETE 100000</span><span id="57f6" class="jy jz hi ju b fi kt kb l kc kd">--run vacuum to remove dead tuples<br/>vacuum test;</span><span id="f0af" class="jy jz hi ju b fi kt kb l kc kd">--all the blocks now having free space<br/>select count(*) from pg_freespace(‘test’) where avail != 0;<br/>44248</span><span id="b953" class="jy jz hi ju b fi kt kb l kc kd">--insert same number of rows as we deleted and in increment “id” order. It will occupy all the existing free space.</span><span id="f3d1" class="jy jz hi ju b fi kt kb l kc kd">INSERT INTO test SELECT g.id FROM generate_series(10000000, 10100000) AS g (id);</span><span id="de1b" class="jy jz hi ju b fi kt kb l kc kd">--no block with free space now<br/>select count(*) from pg_freespace(‘test’) where avail != 0;<br/>0</span></pre><ul class=""><li id="29d1" class="ke kf hi is b it iu ix iy jb kg jf kh jj ki jn ks kk kl km bi translated">运行 vacuum 以更新布林指数</li></ul><pre class="jp jq jr js fd jt ju jv jw aw jx bi"><span id="9419" class="jy jz hi ju b fi ka kb l kc kd">vacuum test;</span></pre><ul class=""><li id="c2c1" class="ke kf hi is b it iu ix iy jb kg jf kh jj ki jn ks kk kl km bi translated">再次运行查询(<strong class="is hj">堆块</strong>和<strong class="is hj">被索引重新检查移除的行</strong>显著增加)</li></ul><pre class="jp jq jr js fd jt ju jv jw aw jx bi"><span id="2637" class="jy jz hi ju b fi ka kb l kc kd">QUERY PLAN<br/>Aggregate (cost=61994.96..61994.97 rows=1 width=8) (actual time=624.274..624.275 rows=1 loops=1)<br/>-&gt; Bitmap Heap Scan on test (cost=337.11..59554.91 rows=976018 width=0) (actual time=156.340..425.839 rows=990000 loops=1)<br/>Recheck Cond: ((id &gt; 2000000) AND (id &lt; 3000000))<br/><strong class="ju hj">Rows Removed by Index Recheck: 2011280</strong><br/><strong class="ju hj">Heap Blocks: lossy=13280</strong><br/>-&gt; Bitmap Index Scan on idx_test (cost=0.00..93.10 rows=997987 width=0) (actual time=1.240..1.241 rows=132800 loops=1)<br/>Index Cond: ((id &gt; 2000000) AND (id &lt; 3000000))</span></pre><p id="cda3" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">结束语:</strong>老实说，我认为 BRIN 概念对于数据量巨大且需要进行批处理的数据仓库查询更有用。BTree 索引降低了对大数据量的 DML 操作的速度，更紧凑的 BRIN 更有意义。</p><p id="abeb" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我在亚马逊红移上看过一个类似的概念，叫做排序键/区域映射。在这里，Sort Key 强制对 copy 语句中的整批行进行排序。此外，红移块大小是 1 MB，这是不可变的，这意味着对表的任何更新，即使触及一行，它也会将整个块和更改的数据复制到较新的块中。</p></div></div>    
</body>
</html>