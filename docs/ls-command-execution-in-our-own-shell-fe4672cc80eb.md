# 外壳是如何工作的？

> 原文：<https://medium.com/nerd-for-tech/ls-command-execution-in-our-own-shell-fe4672cc80eb?source=collection_archive---------18----------------------->

![](img/09f68d675887bd09109337cfea0d04d4.png)

大事由小事组成。在这里，我将用非常简单的语言解释当我们键入“ls -l *时，shell 会做什么。命令行中的 c"。这有助于理解什么是命令行解释器(重视它),或者作为在 C 编程中编写自己的 shell 的资源。

# 贝壳

**第一步。**每个**外壳都是一个 bucle** 从屏幕上这样写的提示开始:

```
$
```

或者:

```
username@hostname:~$
```

或者:

```
username@hostname /etc/mail>
```

将要打印的提示保存在文件 **/etc/bashrc** 中设置的一个名为 **PS1** 的变量中。

有些人觉得很有创意，编辑了这个默认值来显示日期和时间、内核版本、你所在的完整路径，甚至可以用不同的颜色来显示！

**第二步。**C 函数 **getline** 从命令行中写入的输入中获取一行，并保存在字符数组中，我们这里称之为全字符串。

```
char *fullstring[] = {ls -l *.c};
```

**第三步。**分析字符串，判断数组是否为空，不做任何事情，再次显示提示，或者数组是否为 **EOF** 。当你在命令行中键入 **Ctrl +D** 时，它被解释为 EOF，这意味着**E**nd**O**F**F**文件。这是一个在“stdio.h”中声明的宏，意思是-1，如果找到 EOF，shell 必须退出。

**第四步。**一个循环遍历整个字符串，寻找**扩展** *。当它找到一个扩展时，它遍历下一个字符，直到它找到一个空格或一个新行。c "然后逐个比较工作目录中的文件名，将它们的名称保存在一个名为 expansion 的数组中，如下所示:

```
char *expansion = {file0.c file1.c file2.c}
```

**第五步。**这个' *。c '在原始数组中被替换为所有以。在当前目录下，改变数组的原始大小。

```
char *fullstring[] = {ls -l file0.c file1.c file2.c};
```

**步骤六。**字符串由 C 函数 **strtok 分析。**每次在字符串中发现一个空格，它就把字符串分成一个新的部分。

**步骤 7。**所有的令牌都保存在一个指针数组中，如下所示:

```
char *arrayofparts[] = {
                  "ls",       ->token0
                  "-l",       ->token1
                  "file0.c",  ->token2
                  "file1.c",  ->token3
                  "file2.c",  ->token4
                  NULL        ->token5
};
```

**步骤 8。**当我们有一个过于频繁使用的命令时(像 gcc 用所有的标志来编译漂亮的程序)，你可以声明一个别名来避免多次编写相同的长字符串。这是针对一个名为**别名**的 C 函数，shell 必须检查命令“ls”是否是别名。如果找到别名，它将被其所有内容替换。

**第九步。**外壳有**内置功能**，不依赖于你电脑或虚拟机上已经有的程序。所以，“ls”是和包含的内置比较的。如果发现一个内置函数，就直接执行它。

**第十步。**计算机或虚拟机中的可执行文件可以在非常不同的目录中找到。你的机器有一个名为 **PATH** 的**环境变量**。它列出了所有这些地方。所以，需要在变量 PATH 包含的所有目录中搜索“ls”。您可以在您的机器中检查这些路径:

```
$ echo $PATH
```

或者

```
$ env
```

假设 shell 是用 C 编写的，它可以使用宏的声明来处理全局变量，如下所示:

```
extern char **environ;
```

或者它可以使用第三个主要原型:

```
int main(int ac, char **av, char **env);
```

在任何情况下，所有的环境都被分割成行，以比较行的开头是否与" PATH= "相同。ls 位于目录 bin 中，因此，它被更改为/bin/ls。

**步骤 11。**如果在这些目录中的任何一个中找到该程序，shell 将使用 **fork** 系统调用创建一个**子函数**，并使用系统调用 wait 等待**直到该子函数被完全执行。子进程使用 **execve** 来执行/bin/ls。Execve 也需要环境变量。**

然后 ls 打印所有以结尾的文件的详细描述。c 在当前目录中并返回零。

```
$ ls
5_helper2.c  builtins_list.c  helpers_print.c       README.md  str_tok.c
a.out        execute.c        helpers_string.c      shell.c    tokenize.c
builtins.c   find_in_path.c   man_1_simple_shell.1  shell.h
```

**第十二步。**命令 ls 的返回值打印在**标准误差**中。如果 ls 成功结束，则标准误差显示为零。如果您键入以下内容，则可以显示该标准:

```
$ echo $?
```

**第十三步。**再次显示提示。

```
$ 
```

**第 14 步。Getline 等待来自命令行的新指令。**

# 我的团队

![](img/dc773768df170c539a5053b606e97972.png)

霍尔伯顿学校

我们自己的 shell 版本是由我在霍尔伯顿学校的团队创造的:

*   Jerson Perez，全栈开发人员
*   Edher Ramirez，全栈开发人员
*   Natalia Vera，全栈开发人员

它可以在我们的 [git 库](https://github.com/Naveduran/simple_shell)中找到。让我们知道你的问题和意见！

# **关于我**

我是一名来自霍尔伯顿学校的充满激情的软件开发人员，也是一名来自国立大学的心理学家。在我的一生中，我一直在发展有价值的专业技能，成为一个好的倾听者、批判性思考者和团队成员。我被认为是一个非常聪明和有同情心的人。无论是在工作还是学术生活中，我都想创造有意义的经历，并激励我的伴侣。我一直很专注，也很好奇。

如果你想和我建立联系，请在 GitHub 或 T2 Twitter 上关注我。

我希望你喜欢这次阅读，感谢你的关注。

娜塔莉亚·维拉·杜兰制作。