<html>
<head>
<title>Swift Leetcode Series : Find First and Last Position of Element in Sorted Array</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Swift Leetcode 系列:查找排序数组中元素的第一个和最后一个位置</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/swift-leetcode-series-find-first-and-last-position-of-element-in-sorted-array-6ca2475b33d0?source=collection_archive---------13-----------------------#2021-04-29">https://medium.com/nerd-for-tech/swift-leetcode-series-find-first-and-last-position-of-element-in-sorted-array-6ca2475b33d0?source=collection_archive---------13-----------------------#2021-04-29</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="d29f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">✅ ✅ ✅与二分搜索法魔术队</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es jd"><img src="../Images/7086ad1cc74d8ed92245b6a9546a52a0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*i16sxFdYgzkN7fAyMNrJcg.png"/></div></div><figcaption class="jp jq et er es jr js bd b be z dx translated">Leetcode 34</figcaption></figure><div class="jt ju ez fb jv jw"><a href="https://theswiftnerd.com/find-first-and-last-position-in-sorted-array-leetcode/" rel="noopener  ugc nofollow" target="_blank"><div class="jx ab dw"><div class="jy ab jz cl cj ka"><h2 class="bd hj fi z dy kb ea eb kc ed ef hh bi translated">查找排序数组中元素的第一个和最后一个位置(Leetcode 34)</h2><div class="kd l"><h3 class="bd b fi z dy kb ea eb kc ed ef dx translated">难度:链接:四月 Leetcode 挑战:第 29 天给定一个按升序排列的整数 num 数组，找出…</h3></div><div class="ke l"><p class="bd b fp z dy kb ea eb kc ed ef dx translated">theswiftnerd.com</p></div></div><div class="kf l"><div class="kg l kh ki kj kf kk jn jw"/></div></div></a></div><p id="bc1a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">你也可以在 Swift Nerd 博客上阅读完整的故事，以及上面链接上的其他有趣的故事。</p><h1 id="384d" class="kl km hi bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li bi translated">问题描述</h1><p id="eed7" class="pw-post-body-paragraph if ig hi ih b ii lj ik il im lk io ip iq ll is it iu lm iw ix iy ln ja jb jc hb bi translated">给定一个按升序排序的整数数组<code class="du lo lp lq lr b">nums</code>，找出给定<code class="du lo lp lq lr b">target</code>值的开始和结束位置。</p><p id="001a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果在数组中没有找到<code class="du lo lp lq lr b">target</code>，返回<code class="du lo lp lq lr b">[-1, -1]</code>。</p><p id="4ce8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">跟进:</strong>你能写一个有<code class="du lo lp lq lr b">O(log n)</code>运行时间复杂度的算法吗？</p><h1 id="a3fc" class="kl km hi bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li bi translated">例子</h1><pre class="je jf jg jh fd ls lr lt lu aw lv bi"><span id="6b10" class="lw km hi lr b fi lx ly l lz ma"><strong class="lr hj">Input:</strong> nums = [5,7,7,8,8,10], target = 8<br/><strong class="lr hj">Output:</strong> [3,4]</span><span id="7988" class="lw km hi lr b fi mb ly l lz ma"><strong class="lr hj">Input:</strong> nums = [], target = 0<br/><strong class="lr hj">Output:</strong> [-1,-1]</span></pre><h1 id="fea8" class="kl km hi bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li bi translated">限制</h1><ul class=""><li id="068d" class="mc md hi ih b ii lj im lk iq me iu mf iy mg jc mh mi mj mk bi translated"><code class="du lo lp lq lr b">0 &lt;= nums.length &lt;= 105</code></li><li id="e685" class="mc md hi ih b ii ml im mm iq mn iu mo iy mp jc mh mi mj mk bi translated"><code class="du lo lp lq lr b">-109 &lt;= nums[i] &lt;= 109</code></li><li id="2c9c" class="mc md hi ih b ii ml im mm iq mn iu mo iy mp jc mh mi mj mk bi translated"><code class="du lo lp lq lr b">nums</code>为非递减数组。</li><li id="3898" class="mc md hi ih b ii ml im mm iq mn iu mo iy mp jc mh mi mj mk bi translated"><code class="du lo lp lq lr b">-109 &lt;= target &lt;= 109</code></li></ul><h1 id="783a" class="kl km hi bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li bi translated">解决办法</h1><p id="e84f" class="pw-post-body-paragraph if ig hi ih b ii lj ik il im lk io ip iq ll is it iu lm iw ix iy ln ja jb jc hb bi translated">一个简单直接的解决方案是迭代数组，并使用两个变量跟踪第一个和最后一个位置。这将是一个线性操作，非常容易实现，但是，这不是一个最佳的解决方案。每当我们得到一个排序数组时，我们都应该考虑对数复杂度。我们应该利用的属性是排序数组中任何元素的，大于它的元素在右边，小于它的元素在左边。哪种算法能让我们做到这一点？</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es mq"><img src="../Images/a9412ed48006e96aeb53e4235a37155a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*wD3opnHEhrHqgxi8.png"/></div></div></figure><h1 id="e6cb" class="kl km hi bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li bi translated">二进位检索</h1><p id="1fa5" class="pw-post-body-paragraph if ig hi ih b ii lj ik il im lk io ip iq ll is it iu lm iw ix iy ln ja jb jc hb bi translated">排序数组和二分搜索法总是携手并进。我们可以修改普通二分搜索法来查找第一个/最后一个位置，首先查找目标的索引，然后查找比目标稍大的数字的索引。</p><p id="1b20" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">首先，我们可以在<strong class="ih hj"> T </strong>上执行标准的左二分搜索法(<strong class="ih hj"> find </strong>)。接下来，我们可以通过检查存储在第一次搜索结果中的值(<strong class="ih hj"> N[Tleft] </strong>)来查看<strong class="ih hj"> T </strong>是否已经存在于<strong class="ih hj"> N </strong>中。如果我们在那个索引处没有找到<strong class="ih hj"> T </strong>，那么<strong class="ih hj"> T </strong>在<strong class="ih hj"> N </strong>中不存在，我们应该<strong class="ih hj">返回[-1，-1] </strong>。</p><p id="fa94" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">否则，我们仍然需要在<strong class="ih hj"> N </strong>中找到<strong class="ih hj"> T </strong>值范围的右端。为此，我们可以再次使用<strong class="ih hj">查找</strong>，这次使用下一个整数(<strong class="ih hj"> T + 1 </strong>)。由于这将在<strong class="ih hj"> T </strong>值范围的末端之后找到索引<em class="mr">，我们可以仅向后移动一个位置来找到<strong class="ih hj"> T </strong>范围的末端。</em></p><p id="816f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">另一种方法是创建两个函数，一个用于寻找下界，另一个用于寻找上界。由于两者都将使用二分搜索法，渐近界限将在 LogN 内。这种方法很简单，但有点多余，虽然我们可以在一个函数中通过传递一个类似标志的标识符来表示我们想向左还是向右。</p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="ms mt l"/></div></figure><h1 id="0841" class="kl km hi bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li bi translated">复杂性分析</h1><ul class=""><li id="396f" class="mc md hi ih b ii lj im lk iq me iu mf iy mg jc mh mi mj mk bi translated"><strong class="ih hj"> <em class="mr">时间复杂度:O(log N) </em> </strong> <em class="mr">为二分搜索法</em></li><li id="e560" class="mc md hi ih b ii ml im mm iq mn iu mo iy mp jc mh mi mj mk bi translated"><strong class="ih hj"> <em class="mr">空间复杂度:O(1) </em> </strong></li></ul></div><div class="ab cl mu mv gp mw" role="separator"><span class="mx bw bk my mz na"/><span class="mx bw bk my mz na"/><span class="mx bw bk my mz"/></div><div class="hb hc hd he hf"><p id="d513" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">感谢您的阅读。如果你喜欢这篇文章，并发现它很有用，请分享并像野火一样传播它！</p><p id="9bf1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">你可以在<a class="ae nb" href="https://theswiftnerd.com/" rel="noopener ugc nofollow" target="_blank">the swift nerd</a>|<a class="ae nb" href="https://www.linkedin.com/in/varunrathi28/" rel="noopener ugc nofollow" target="_blank">LinkedIn</a>|<a class="ae nb" href="https://github.com/varunrathi28" rel="noopener ugc nofollow" target="_blank">Github</a>上找到我</p></div></div>    
</body>
</html>