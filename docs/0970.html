<html>
<head>
<title>Variables in JavaScript, Scope and Hoisting</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript 中的变量、范围和提升</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/variables-in-javascript-scope-and-hoisting-b8e5e767fc01?source=collection_archive---------8-----------------------#2021-02-26">https://medium.com/nerd-for-tech/variables-in-javascript-scope-and-hoisting-b8e5e767fc01?source=collection_archive---------8-----------------------#2021-02-26</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/fbf4e98c522f4ad7e488531b02852123.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7xTXow_-857z7zzEyAj0pw.jpeg"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">图片来源:Unsplash</figcaption></figure><p id="789c" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">变量是任何编程语言的基础和最重要的部分。它们用于存储在程序的进一步执行中使用的值。</p><p id="c7d8" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">你可以把变量想象成一个盒子，我们可以在里面储存一些东西，比如值。</p><p id="e324" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">在 JavaScript 中，变量可以存储任何类型的值。它可以是数字、字符串、布尔值、数组、对象等等。我不想在本文中讨论数据类型，我们将在另一篇文章中讨论它们。让我们只关注一个变量。</p><blockquote class="js jt ju"><p id="450b" class="iu iv jv iw b ix iy iz ja jb jc jd je jw jg jh ji jx jk jl jm jy jo jp jq jr hb bi translated"><strong class="iw hj">让我们看看如何在 JavaScript 中使用变量:</strong></p></blockquote><ol class=""><li id="c571" class="jz ka hi iw b ix iy jb jc jf kb jj kc jn kd jr ke kf kg kh bi translated">声明一个变量</li><li id="f42f" class="jz ka hi iw b ix ki jb kj jf kk jj kl jn km jr ke kf kg kh bi translated">在其中赋值</li><li id="e270" class="jz ka hi iw b ix ki jb kj jf kk jj kl jn km jr ke kf kg kh bi translated">使用它</li></ol><p id="342d" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">就这么简单。</p><blockquote class="js jt ju"><p id="271f" class="iu iv jv iw b ix iy iz ja jb jc jd je jw jg jh ji jx jk jl jm jy jo jp jq jr hb bi translated"><strong class="iw hj">来点实际的:</strong></p></blockquote><pre class="kn ko kp kq fd kr ks kt ku aw kv bi"><span id="f1cc" class="kw kx hi ks b fi ky kz l la lb"><strong class="ks hj">var x;</strong>            <em class="jv">/Declare a variable</em></span><span id="932d" class="kw kx hi ks b fi lc kz l la lb"><strong class="ks hj">x=10;  </strong>           <em class="jv">/Assign a value in it</em></span><span id="be4f" class="kw kx hi ks b fi lc kz l la lb"><strong class="ks hj">console.log(x);</strong>   <em class="jv">/Use it</em></span></pre></div><div class="ab cl ld le gp lf" role="separator"><span class="lg bw bk lh li lj"/><span class="lg bw bk lh li lj"/><span class="lg bw bk lh li"/></div><div class="hb hc hd he hf"><p id="5227" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">在 ES6 之前使用<strong class="iw hj"> <em class="jv"> var </em> </strong>作为变量关键字，但是在 ES6 之后有两个新的关键字用于分配变量<strong class="iw hj"> <em class="jv"> let </em> </strong>和<strong class="iw hj"> <em class="jv"> const。</em> </strong></p><p id="3588" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">但是为什么<strong class="iw hj"> <em class="jv">让</em> </strong>和<strong class="iw hj"> <em class="jv">保持不变呢？</em>T25】</strong></p><p id="f1b9" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">要理解<strong class="iw hj"> <em class="jv">让</em> </strong>和<strong class="iw hj"> <em class="jv"> const </em> </strong>的重要性，首先我们需要了解两个 JavaScript 特性:</p><h2 id="4c99" class="kw kx hi bd lk ll lm ln lo lp lq lr ls jf lt lu lv jj lw lx ly jn lz ma mb mc bi translated">范围和提升</h2></div><div class="ab cl ld le gp lf" role="separator"><span class="lg bw bk lh li lj"/><span class="lg bw bk lh li lj"/><span class="lg bw bk lh li"/></div><div class="hb hc hd he hf"><h1 id="f14e" class="md kx hi bd lk me mf mg lo mh mi mj ls mk ml mm lv mn mo mp ly mq mr ms mb mt bi translated"><strong class="ak">我们先来讨论一下作用域:</strong></h1><h2 id="0fe8" class="kw kx hi bd lk ll lm ln lo lp lq lr ls jf lt lu lv jj lw lx ly jn lz ma mb mc bi translated">作用域仅仅意味着变量在什么范围内可以被访问。</h2><p id="6b84" class="pw-post-body-paragraph iu iv hi iw b ix mu iz ja jb mv jd je jf mw jh ji jj mx jl jm jn my jp jq jr hb bi translated">在 JavaScript 中，有两种类型作用域:</p><ol class=""><li id="59eb" class="jz ka hi iw b ix iy jb jc jf kb jj kc jn kd jr ke kf kg kh bi translated">全球范围</li><li id="6d7a" class="jz ka hi iw b ix ki jb kj jf kk jj kl jn km jr ke kf kg kh bi translated">局部范围</li></ol><blockquote class="mz"><p id="70f7" class="na nb hi bd nc nd ne nf ng nh ni jr dx translated">没明白吗？</p></blockquote><p id="cb5f" class="pw-post-body-paragraph iu iv hi iw b ix nj iz ja jb nk jd je jf nl jh ji jj nm jl jm jn nn jp jq jr hb bi translated">好的，别担心。让我们实际地做它。考虑以下代码:</p><pre class="kn ko kp kq fd kr ks kt ku aw kv bi"><span id="7014" class="kw kx hi ks b fi ky kz l la lb">var global = 'i am a global variable';<br/>function doSomething() {                <br/>  var local = 'i am a local variable';  <br/>  console.log(local);                   <br/>}                                       <br/>console.log(global);<br/>console.log(local);</span></pre><p id="c35d" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw hj">输出:</strong></p><pre class="kn ko kp kq fd kr ks kt ku aw kv bi"><span id="f32c" class="kw kx hi ks b fi ky kz l la lb">something</span><span id="3420" class="kw kx hi ks b fi lc kz l la lb">ReferenceError: local is not defined<br/>    at Object.&lt;anonymous&gt; (C:\Users\user\Desktop\demo\app.js:7:13)</span></pre><blockquote class="mz"><p id="2950" class="na nb hi bd nc nd ne nf ng nh ni jr dx translated"><em class="no">什么是</em>参考错误<em class="no">？</em></p></blockquote><p id="a120" class="pw-post-body-paragraph iu iv hi iw b ix nj iz ja jb nk jd je jf nl jh ji jj nm jl jm jn nn jp jq jr hb bi translated">如果你在上面的程序中看到，我声明了两个变量<strong class="iw hj"> <em class="jv">【全局】</em> </strong>和<strong class="iw hj"> <em class="jv">局部。</em>T49】</strong></p><p id="0cb1" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw hj">局部</strong>变量在<strong class="iw hj"> doSomething </strong>函数中，所以你不能在函数外访问它。这意味着变量 local 的范围在函数内，即<strong class="iw hj">局部范围。</strong></p><p id="2d69" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">但是变量<strong class="iw hj"> global </strong>是在函数外部声明的，所以你可以从任何地方访问它。因此变量 global 在<strong class="iw hj">全局范围内。</strong></p></div><div class="ab cl ld le gp lf" role="separator"><span class="lg bw bk lh li lj"/><span class="lg bw bk lh li lj"/><span class="lg bw bk lh li"/></div><div class="hb hc hd he hf"><p id="1ec9" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">在 ES6 之后，本地范围被进一步分成两部分:</p><ol class=""><li id="fc29" class="jz ka hi iw b ix iy jb jc jf kb jj kc jn kd jr ke kf kg kh bi translated"><strong class="iw hj"> var </strong>的功能范围(功能)</li><li id="dc17" class="jz ka hi iw b ix ki jb kj jf kk jj kl jn km jr ke kf kg kh bi translated"><strong class="iw hj">的阻塞范围(条件或循环)让</strong>和<strong class="iw hj">保持不变</strong></li></ol><blockquote class="js jt ju"><p id="84ba" class="iu iv jv iw b ix iy iz ja jb jc jd je jw jg jh ji jx jk jl jm jy jo jp jq jr hb bi translated"><strong class="iw hj">看看下面的代码:</strong></p></blockquote><pre class="kn ko kp kq fd kr ks kt ku aw kv bi"><span id="b192" class="kw kx hi ks b fi ky kz l la lb">function doSomething() {<br/>  if (1&lt;2) {<br/>    var cow = 'cow';<br/>    let dog = 'dog';<br/>    const cat = 'cat';</span><span id="e1a5" class="kw kx hi ks b fi lc kz l la lb">    console.log(cow);   //cow<br/>    console.log(dog);   //dog<br/>    console.log(cat);   //cat<br/>  }<br/>  console.log(cow);     //cow<br/>  console.log(dog);     //ReferenceError: dog is not defined<br/>  console.log(cat);     //ReferenceError: cat is not defined<br/>}<br/>doSomething();</span></pre><p id="76ea" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">如你所见，如果我们试图在<strong class="iw hj"> if </strong>(块范围)之外访问<strong class="iw hj"> let </strong>和<strong class="iw hj"> const </strong>变量，它会给出<strong class="iw hj"> ReferenceError </strong>。然而<strong class="iw hj"> var </strong>变量在<strong class="iw hj">函数范围内完美地完成了它的工作。</strong></p><p id="1f44" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">也就是说，<strong class="iw hj"> var </strong>的范围是<strong class="iw hj">函数范围</strong>其中<strong class="iw hj"> let </strong>和<strong class="iw hj"> const </strong>的范围是<strong class="iw hj">块范围。</strong></p><h1 id="f45d" class="md kx hi bd lk me np mg lo mh nq mj ls mk nr mm lv mn ns mp ly mq nt ms mb mt bi translated"><strong class="ak">我们先来讨论一下吊装:</strong></h1><p id="be78" class="pw-post-body-paragraph iu iv hi iw b ix mu iz ja jb mv jd je jf mw jh ji jj mx jl jm jn my jp jq jr hb bi translated"><strong class="iw hj"> <em class="jv">定义</em> </strong>:当一个变量或函数被声明时，它的声明被移动到它们作用域的顶部。</p><blockquote class="mz"><p id="69de" class="na nb hi bd nc nd nu nv nw nx ny jr dx translated">见鬼了。</p></blockquote><blockquote class="js jt ju"><p id="b1dc" class="iu iv jv iw b ix nj iz ja jb nk jd je jw nl jh ji jx nm jl jm jy nn jp jq jr hb bi translated"><strong class="iw hj">我们来简化一下:</strong></p></blockquote><p id="1629" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">看看下面的情况；</p><ol class=""><li id="92e3" class="jz ka hi iw b ix iy jb jc jf kb jj kc jn kd jr ke kf kg kh bi translated"><strong class="iw hj">试图在变量被声明和初始化之前访问该变量</strong></li></ol><pre class="kn ko kp kq fd kr ks kt ku aw kv bi"><span id="272c" class="kw kx hi ks b fi ky kz l la lb">console.log(name);  //access name before it defined or initialized<br/>var name='person';  //define and initialize after it been accessed</span><span id="be0d" class="kw kx hi ks b fi lc kz l la lb">/* Output */<br/>undefined</span></pre><p id="dc6d" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">2.<strong class="iw hj">试图在变量初始化之前访问变量，但没有声明它</strong></p><pre class="kn ko kp kq fd kr ks kt ku aw kv bi"><span id="c172" class="kw kx hi ks b fi ky kz l la lb">console.log(name);  //access name before it defined or initialized<br/>name='person';      //initialize name without it defined</span><span id="3179" class="kw kx hi ks b fi lc kz l la lb">/* Output */<br/>ReferenceError: name is not defined</span></pre><p id="c08d" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">正如我们所看到的，如果我们在变量被声明和初始化之前访问它，它会返回未定义。然而，如果我们<em class="jv">在变量初始化之前访问它而没有声明它</em>，它会返回一个 ReferenceError。</p><p id="96e6" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">在<strong class="iw hj">第二个条件</strong>中，我们在访问变量<strong class="iw hj"> <em class="jv">名称</em> </strong>之前似乎没有声明它，所以它给出了一个 ReferenceError，但是在<strong class="iw hj">第一个条件</strong>中发生的事情是，JavaScript 在访问变量<strong class="iw hj">名称</strong>之前自动声明了变量<strong class="iw hj">名称</strong>，因为我们在变量前面放了一个<strong class="iw hj"> <em class="jv"> var </em> </strong>关键字。</p><pre class="kn ko kp kq fd kr ks kt ku aw kv bi"><span id="4e07" class="kw kx hi ks b fi ky kz l la lb">//How we write it       |     //How JavaScirpt Manipulate it<br/>console.log(name);      |     var name;<br/>var name='person';      |     console.log(name);<br/>                        |     name='person';</span><span id="74e8" class="kw kx hi ks b fi lc kz l la lb">/* Output */<br/>undefined</span></pre><blockquote class="js jt ju"><p id="7748" class="iu iv jv iw b ix iy iz ja jb jc jd je jw jg jh ji jx jk jl jm jy jo jp jq jr hb bi translated">让我们来看看关于吊装的大图:</p></blockquote><pre class="kn ko kp kq fd kr ks kt ku aw kv bi"><span id="0717" class="kw kx hi ks b fi ky kz l la lb">var statement = true;<br/>function checkHoisting() {<br/>  //var statement;  /* Javascript automatically declared it here */<br/>  if(1&gt;2){<br/>    var statement = false;<br/>  }<br/>  console.log(statement);<br/>}<br/>checkHoisting();</span><span id="904f" class="kw kx hi ks b fi lc kz l la lb">//Output: undefined</span></pre><p id="1297" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">看到这个例子，人们可以很容易地预测输出应该是<em class="jv">真</em>。但是由于<strong class="iw hj">提升</strong>属性 JavaScript 声明了一个<em class="jv">新的</em>语句变量 top 在<strong class="iw hj">检查提升</strong>函数之上，该函数未初始化，因此输出为<strong class="iw hj">未定义</strong>。</p><p id="0ee3" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">这种类型的输出可能会导致奇怪的错误。</p><h2 id="db59" class="kw kx hi bd lk ll lm ln lo lp lq lr ls jf lt lu lv jj lw lx ly jn lz ma mb mc bi translated">但是在 let 或 const 的情况下，这种情况根本不会发生。让我们看看</h2><pre class="kn ko kp kq fd kr ks kt ku aw kv bi"><span id="798e" class="kw kx hi ks b fi ky kz l la lb">let statement = true;<br/>function checkHoisting() {<br/>  if(1&gt;2){<br/>    let statement = false;<br/>  }<br/>  console.log(statement);   //the global statement variable<br/>}<br/>checkHoisting();<br/>//Output: true</span></pre><p id="2175" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">Let 和 Const 不参与提升行为，因为它们是块范围变量。</p><blockquote class="js jt ju"><p id="68e7" class="iu iv jv iw b ix iy iz ja jb jc jd je jw jg jh ji jx jk jl jm jy jo jp jq jr hb bi translated">让我们看看另一个场景:</p></blockquote><pre class="kn ko kp kq fd kr ks kt ku aw kv bi"><span id="f437" class="kw kx hi ks b fi ky kz l la lb">var statement = true;<br/>var statement = false;<br/>console.log(statement); // Output:false</span><span id="42da" class="kw kx hi ks b fi lc kz l la lb">let done = true;<br/>let done = false;<br/>console.log(done);      //Output:SyntaxError: Identifier 'done' has     already been declared</span></pre><p id="f560" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">这里发生了什么？你能猜到原因吗？</p><p id="34bf" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">我来简化一下。</p><p id="5a66" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">当我们用不同的值用 var 再次声明一个变量时，那么由于提升行为，这个变量的值用最新的值更新了，因而输出是 false。</p><p id="9576" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">但是在<strong class="iw hj"> let </strong>和<strong class="iw hj"> const </strong>的情况下，由于它们没有遵循提升属性，它抛出一个<strong class="iw hj"> SyntaxError </strong> <em class="jv">表示标识符‘done’已经被声明。</em></p><p id="9c36" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">这种变量重复也会导致错误。</p></div><div class="ab cl ld le gp lf" role="separator"><span class="lg bw bk lh li lj"/><span class="lg bw bk lh li lj"/><span class="lg bw bk lh li"/></div><div class="hb hc hd he hf"><h1 id="0e83" class="md kx hi bd lk me mf mg lo mh mi mj ls mk ml mm lv mn mo mp ly mq mr ms mb mt bi translated">结论:</h1><p id="c342" class="pw-post-body-paragraph iu iv hi iw b ix mu iz ja jb mv jd je jf mw jh ji jj mx jl jm jn my jp jq jr hb bi translated">由于范围和提升的原因，<strong class="iw hj"> var </strong>关键字可能会导致 w 不希望出现的不可预测的结果。所以根据<strong class="iw hj"> ES6 </strong>的特性，最好使用<strong class="iw hj"> let </strong>和<strong class="iw hj"> const </strong>来代替 var，以减少我们代码的混乱和错误。</p><p id="c27e" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">也就是说，这就是这篇文章的全部内容。我希望这篇文章可以帮助你理解 JavaScript 中的变量的作用域和提升属性。</p><p id="3085" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">随意评论。</p><p id="4775" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">到时候见。</p></div></div>    
</body>
</html>