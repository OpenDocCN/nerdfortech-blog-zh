<html>
<head>
<title>Hindi Character Recognition on Android using TensorFlow Lite</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用 TensorFlow Lite 在 Android 上识别印地语字符</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/hindi-character-recognition-on-android-using-tensorflow-lite-9948b428905c?source=collection_archive---------1-----------------------#2022-09-15">https://medium.com/nerd-for-tech/hindi-character-recognition-on-android-using-tensorflow-lite-9948b428905c?source=collection_archive---------1-----------------------#2022-09-15</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="ccc1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果您曾经想要构建一个用于文本识别的图像分类器，我假设您可能已经实现了 TensorFlow 官方示例中的经典<a class="ae jd" href="https://www.tensorflow.org/js/tutorials/training/handwritten_digit_cnn" rel="noopener ugc nofollow" target="_blank"> <strong class="ih hj">手写数字识别</strong> </a>应用程序。</p><p id="2a04" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">通常被称为计算机视觉的“Hello World ”,它是 ML 初学者构建分类器应用程序的一个很好的起点。构建自己的自定义分类器来识别任何字符不是很好吗？从今天开始，我们将构建一个印地语字符识别器，但是您可以随意选择一个数据集，或者简单地跟随我。听起来很刺激，对吧？</p><p id="3005" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们将建立一个能够识别印地语字符的机器学习模型，而且也是从头开始。我们不仅要构建一个 ML 模型，还要将它部署在 Android 移动应用程序上。因此，本文将作为一个端到端的教程，涵盖构建和部署 ML 应用程序所需的几乎所有内容。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es je"><img src="../Images/40a8427ff06731e76c52d0fa96b6cc68.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CWOu1YOTXev0Np-VkcMnIw.png"/></div></div><figcaption class="jq jr et er es js jt bd b be z dx translated">端到端流</figcaption></figure><p id="33d3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我会尽可能简单明了地解释一切。你兴奋吗？我非常。</p><h2 id="a3f4" class="ju jv hi bd jw jx jy jz ka kb kc kd ke iq kf kg kh iu ki kj kk iy kl km kn ko bi translated">数据准备</h2><p id="f075" class="pw-post-body-paragraph if ig hi ih b ii kp ik il im kq io ip iq kr is it iu ks iw ix iy kt ja jb jc hb bi translated">为了训练一个应该产生良好结果的机器学习模型，我们需要大量数据。你一定听说过 MNIST 数字数据库，对吗？让我们回忆一下。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es ku"><img src="../Images/09ea82efb11f10b9554e16d85ccd2461.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VOP5sC-T2EWm8RmBNGpCUg.png"/></div></div><figcaption class="jq jr et er es js jt bd b be z dx translated">MNIST 数字数据集</figcaption></figure><p id="040d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">MNIST，因为它代表“修改的国家标准和技术研究所”，是一个流行的手写数字识别数据库，有超过 60，000 个数字 0-9 的图像。现在，了解 MNIST 数据库的外观和格式很重要，因为我们将合成一个“类似 MNIST”的印地语字符数据集。</p><p id="2a0e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">MNIST 数据集中的每个数字都是 28 x 28 的二进制图像，颜色为白色，背景为黑色。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div class="er es kv"><img src="../Images/9feb7a83e33adcca65c1c28d5f16ee05.png" data-original-src="https://miro.medium.com/v2/resize:fit:532/format:webp/1*PD-T5A3Bqu1BpI9QEsKm4A.png"/></div><figcaption class="jq jr et er es js jt bd b be z dx translated">MNIST 数字的例子</figcaption></figure><p id="4071" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">好了，现在我们有了这个想法，让我们合成我们自己的印地语字符数据集。我已经将数据集保存在我的<a class="ae jd" href="https://github.com/NSTiwari/Hindi-Character-Recognition-on-Android-using-TensorFlow-Lite" rel="noopener ugc nofollow" target="_blank"> <strong class="ih hj"> GitHub 库</strong> </a>中。随意克隆存储库并下载数据集。</p><p id="93a9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">该数据集包含所有的印地语元音、辅音和数字。这些图像必须转换成 NumPy 数组(。npz)，以便进行模型训练。下面的脚本将帮助您进行转换。</p><p id="5510" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">导入依赖关系<br/> </strong>我们从导入所需的依赖关系和库开始</p><pre class="jf jg jh ji fd kw kx ky kz aw la bi"><span id="04b2" class="ju jv hi kx b fi lb lc l ld le">import tensorflow as tf<br/>from tensorflow import keras<br/>from PIL import Image<br/>import os<br/><br/>import numpy as np<br/>import matplotlib.pyplot as plt<br/>import random<br/><br/>!pip install -q kaggle<br/>!pip install -q kaggle-cli<br/>print(tf.__version__)</span><span id="f195" class="ju jv hi kx b fi lf lc l ld le">os.environ['KAGGLE_USERNAME'] = "&lt;your_kaggle_username&gt;"<br/>os.environ['KAGGLE_KEY'] = "&lt;your_kaggle_key&gt;"<br/>!kaggle datasets download -d nstiwari/hindi-character-recognition --unzip</span></pre><p id="9b4e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">将 JPG 图像转换成 NPZ (NumPy array)格式<br/> </strong>现在需要将训练图像转换成。npz 格式，以便作为输入传递。</p><pre class="jf jg jh ji fd kw kx ky kz aw la bi"><span id="3edd" class="ju jv hi kx b fi lb lc l ld le"><strong class="kx hj"># Converts all the images inside HindiCharacterRecognition/raw_images/10 into NPZ format.</strong><br/>path_to_files = "/content/HindiCharacterRecognition/raw_images/10/"<br/>vectorized_images = []<br/><br/>for _, file in enumerate(os.listdir(path_to_files)):<br/>   image = Image.open(path_to_files + file)<br/>   image_array = np.array(image)<br/>   vectorized_images.append(image_array)<br/>np.savez("./10.npz", DataX=vectorized_images)</span></pre><p id="d0ab" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">加载训练图像 NumPy 数组<br/> </strong>将训练图像矢量化到 NumPy 数组中。换句话说，所有训练图像的像素在值[0，255]之间被矢量化成单个'。npz '文件。</p><pre class="jf jg jh ji fd kw kx ky kz aw la bi"><span id="53d4" class="ju jv hi kx b fi lb lc l ld le">path = "./HindiCharacterRecognition/vectorized_images/numeral_images.npz"<br/>with np.load(path) as data:<br/>    #load DataX as train_data<br/>    train_images = data['DataX']</span></pre><p id="aad6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">Load the training labels NumPy array<br/></strong>类似地，各个训练图像的标签也被矢量化并捆绑成单个的’。npz '文件。与 images 数组不同，labels 数组包含从 0 到 n-1 的离散值，其中 n =类的数量。</p><pre class="jf jg jh ji fd kw kx ky kz aw la bi"><span id="0756" class="ju jv hi kx b fi lb lc l ld le">path = "./HindiCharacterRecognition/vectorized_labels/numeral_labels.npz"<br/>with np.load(path) as data:<br/>    #load DataX as train_data<br/>    train_labels = data['DataX']</span></pre><p id="ff6b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在此示例中，我为 5 个班级(३、अ、क、प和न.)训练模型该数据集涵盖了所有的元音、辅音和数字，因此您可以随意选择任何类别。</p><pre class="jf jg jh ji fd kw kx ky kz aw la bi"><span id="6bcb" class="ju jv hi kx b fi lb lc l ld le">NO_OF_CLASSES = 5  <strong class="kx hj"># Change the no. of classes according to your custom dataset</strong></span></pre><p id="bf53" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">归一化输入图像<br/> </strong>这里，我们通过将每个像素除以 255 来归一化输入图像，使得每个像素保持在[0，1]之间的值。</p><p id="c029" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">值为 0 的像素是完全暗的(黑色)，而值为 1 的像素是白色的。0 到 1 之间的任何值都是灰色的，其强度取决于最接近的一端。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div class="er es lg"><img src="../Images/e7d6e123828e0c0547a6168204b38c61.png" data-original-src="https://miro.medium.com/v2/resize:fit:570/format:webp/1*uX-8h98t-PDm2qDCLQz6Ig.png"/></div><figcaption class="jq jr et er es js jt bd b be z dx translated">色阶在 0 和 1 之间</figcaption></figure><pre class="jf jg jh ji fd kw kx ky kz aw la bi"><span id="bffd" class="ju jv hi kx b fi lb lc l ld le"><strong class="kx hj"># Normalize the input image so that each pixel value is between 0 to 1.</strong><br/>train_images = train_images / 255.0<br/>print('Pixels are normalized.')</span></pre><p id="dc76" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">检查图像和标签阵列的形状</strong></p><ul class=""><li id="d5d9" class="lh li hi ih b ii ij im in iq lj iu lk iy ll jc lm ln lo lp bi translated">图像数组的形状应该是(X，28，28 ),其中 X =图像的数量。</li><li id="4866" class="lh li hi ih b ii lq im lr iq ls iu lt iy lu jc lm ln lo lp bi translated">标签数组的形状应该是(X，)。</li></ul><p id="40f5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="lv">注意:当然，图像的数量和标签的数量必须相等。</em></p><pre class="jf jg jh ji fd kw kx ky kz aw la bi"><span id="aee4" class="ju jv hi kx b fi lb lc l ld le">train_images.shape<br/>train_labels.shape</span></pre><p id="a13c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">可视化训练数据</strong></p><pre class="jf jg jh ji fd kw kx ky kz aw la bi"><span id="e138" class="ju jv hi kx b fi lb lc l ld le"><strong class="kx hj"># Show the first 50 images in the training dataset.</strong><br/>j = 0<br/>plt.figure(figsize = (10, 10))<br/>for i in range(550, 600): # Try playing with difference ranges in interval of 50. Example: range(250, 300)<br/>   j = j + 1<br/>   plt.subplot(10, 5, j)<br/>   plt.xticks([])<br/>   plt.yticks([])<br/>   plt.grid(False)<br/>   plt.imshow(train_images[i], cmap = plt.cm.gray)<br/>   plt.xlabel(train_labels[i])<br/>plt.show()</span></pre><figure class="jf jg jh ji fd jj er es paragraph-image"><div class="er es lw"><img src="../Images/4a44fb96c01abbd09734ed0f3af2704a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1352/format:webp/1*UL_FvyIjyt6yr_YKjWC3KA.png"/></div><figcaption class="jq jr et er es js jt bd b be z dx translated">数据集预览</figcaption></figure><p id="5709" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">唷，那是一些工作。最后，我们完成了第一步。我们的数据集现在看起来很完美，可以开始训练了。</p><h2 id="47de" class="ju jv hi bd jw jx jy jz ka kb kc kd ke iq kf kg kh iu ki kj kk iy kl km kn ko bi translated">模特培训</h2><p id="6929" class="pw-post-body-paragraph if ig hi ih b ii kp ik il im kq io ip iq kr is it iu ks iw ix iy kt ja jb jc hb bi translated">好的，目前为止还不错。主游戏现在开始。先说模特培训。</p><p id="bb99" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在下面的单元格中，我们定义了模型的层，并设置了超参数，如优化器、损失函数、量化模型性能的指标、类的数量和时期。</p><pre class="jf jg jh ji fd kw kx ky kz aw la bi"><span id="e440" class="ju jv hi kx b fi lb lc l ld le"><strong class="kx hj"># Define the model architecture.</strong><br/>model = keras.Sequential([<br/>   keras.layers.InputLayer(input_shape=(28, 28)),<br/>   keras.layers.Reshape(target_shape = (28, 28, 1)),<br/>   keras.layers.Conv2D(filters=32, kernel_size = (3, 3), activation = tf.nn.relu),<br/>   keras.layers.Conv2D(filters=64, kernel_size = (3, 3), activation = tf.nn.relu),<br/>   keras.layers.MaxPooling2D(pool_size = (2, 2)),<br/>   keras.layers.Dropout(0.25),<br/>   keras.layers.Flatten(),<br/>   keras.layers.Dense(NO_OF_CLASSES)<br/>])<br/><br/><strong class="kx hj"># Define how to train the model</strong><br/>model.compile(optimizer = 'adam',<br/>              loss = tf.keras.losses.SparseCategoricalCrossentropy(from_logits = True),<br/>              metrics = ['accuracy'])<br/><br/><strong class="kx hj"># Train the digit classification model</strong><br/>model.fit(train_images, train_labels, epochs = 50)<br/>model.summary()</span></pre><p id="de98" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我花了大约 30-45 分钟训练 5 个班的模型，每个班大约有 200 张图像。训练模型的时间将根据您为用例选择的类和图像/每个类的数量而变化。在模特训练的时候，去喝点咖啡。</p><h2 id="fd3c" class="ju jv hi bd jw jx jy jz ka kb kc kd ke iq kf kg kh iu ki kj kk iy kl km kn ko bi translated">量化</h2><p id="55a1" class="pw-post-body-paragraph if ig hi ih b ii kp ik il im kq io ip iq kr is it iu ks iw ix iy kt ja jb jc hb bi translated">我们已经写了一半了。Keras 模型(. h5)准备就绪。然而，为了能够在移动应用程序上使用该模型，我们需要量化该模型，并将其转换为 TF Lite 格式，这是原始 TF 模型的简化版本。</p><p id="42aa" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">量化允许在模型的准确性和大小之间进行适当的权衡。随着精度的微小降低，模型的大小可以显著减小，从而使其部署更容易。</p><p id="e417" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">将 TF 模型转换成 TF Lite 模型<br/> </strong>将 Keras 模型转换成 TF Lite 格式需要几个步骤。首先，模型简单地转换成 TF Lite，而不执行量化。</p><pre class="jf jg jh ji fd kw kx ky kz aw la bi"><span id="f5f3" class="ju jv hi kx b fi lb lc l ld le"><strong class="kx hj"># Convert Keras model to TF Lite format.</strong><br/>converter = tf.lite.TFLiteConverter.from_keras_model(model)<br/>tflite_float_model = converter.convert()<br/><br/>with open('model.tflite', 'wb') as f:<br/>   f.write(tflite_float_model)<br/><br/><strong class="kx hj"># Show model size in KBs.</strong><br/>float_model_size = len(tflite_float_model) / 1024<br/>print('Float model size = %dKBs.' % float_model_size)</span></pre><p id="79b9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在，我们使用量化将模型重新转换为 TF Lite。这大大减小了模型的大小。</p><pre class="jf jg jh ji fd kw kx ky kz aw la bi"><span id="7555" class="ju jv hi kx b fi lb lc l ld le"><strong class="kx hj"># Re-convert the model to TF Lite using quantization.</strong><br/>converter.optimizations = [tf.lite.Optimize.DEFAULT]<br/>tflite_quantized_model = converter.convert()<br/><br/><strong class="kx hj"># Show model size in KBs.</strong><br/>quantized_model_size = len(tflite_quantized_model) / 1024<br/>print('Quantized model size = %dKBs,' % quantized_model_size)<br/>print('which is about %d%% of the float model size.'\ % (quantized_model_size * 100 / float_model_size))</span></pre><p id="b286" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">最终的 TF Lite 模型已经完成。现在，我们需要导出模型以便能够使用它。</p><pre class="jf jg jh ji fd kw kx ky kz aw la bi"><span id="2d43" class="ju jv hi kx b fi lb lc l ld le"><strong class="kx hj"># Save the quantized model to file to the Downloads directory</strong><br/>f = open('mnist.tflite', "wb")<br/>f.write(tflite_quantized_model)<br/>f.close()<br/><br/><strong class="kx hj"># Download the digit classification model</strong><br/>from google.colab import files<br/>files.download('mnist.tflite')<br/><br/>print('`mnist.tflite` has been downloaded')</span></pre><p id="7767" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">快好了。我们现在有了 TF Lite 模型，可以部署在 Android 应用程序上。你可以在这里 找到整个 Colab 笔记本<a class="ae jd" href="https://github.com/NSTiwari/Hindi-Character-Recognition-on-Android-using-TensorFlow-Lite/blob/main/Hindi_Character_Recognition.ipynb" rel="noopener ugc nofollow" target="_blank"> <strong class="ih hj">。</strong></a></p><h2 id="aa00" class="ju jv hi bd jw jx jy jz ka kb kc kd ke iq kf kg kh iu ki kj kk iy kl km kn ko bi translated">部署模型</h2><p id="b53e" class="pw-post-body-paragraph if ig hi ih b ii kp ik il im kq io ip iq kr is it iu ks iw ix iy kt ja jb jc hb bi translated">我定制了 TensorFlow 开发的<strong class="ih hj"> </strong>原<strong class="ih hj"> </strong> <a class="ae jd" href="https://github.com/tensorflow/examples/tree/master/lite/examples/digit_classifier/android" rel="noopener ugc nofollow" target="_blank"> <strong class="ih hj">数字分类器</strong> </a>应用，改善其观感。在步骤 1 中，您可能已经克隆了存储库。在这种情况下，您应该可以找到<strong class="ih hj"> Android_App </strong>目录。</p><p id="1cfa" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">将<code class="du lx ly lz kx b">mnist.tflite</code>模型文件复制到<code class="du lx ly lz kx b">Hindi-Character-Recognition-on-Android-using-TensorFlow-Lite/Android_App/app/src/main/assets</code>目录下。</p><p id="208b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">接下来，在 Android Studio 中打开项目，让它自己构建一段时间。一旦项目构建完成，打开<code class="du lx ly lz kx b">DigitClassifier.kt</code>文件，编辑<strong class="ih hj">行 333 </strong>，将<code class="du lx ly lz kx b">&lt;your_no_of_output_classes&gt;</code>替换为模型中输出类的数量。</p><p id="36ab" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">同样，在<code class="du lx ly lz kx b">DigitClassifier.kt</code>文件中，通过根据您的自定义数据集设置标签名称来编辑<strong class="ih hj">第 118 行到第 132 行</strong>。</p><p id="4d96" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">最后，再次构建项目并将其安装在您的 Android 手机上，享受您自己定制的印地语字符识别应用程序。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div class="er es ma"><img src="../Images/2465184d5aafb56387b287140be7f106.png" data-original-src="https://miro.medium.com/v2/resize:fit:548/1*BxcEKPtEat_0XbHB-KCGQg.gif"/></div><figcaption class="jq jr et er es js jt bd b be z dx translated">最终应用</figcaption></figure><p id="1b01" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">所以，这是这个博客的总结。简单总结一下:</p><ul class=""><li id="1496" class="lh li hi ih b ii ij im in iq lj iu lk iy ll jc lm ln lo lp bi translated">我们从数据准备开始，为由元音、辅音和数字组成的印地语字符合成一个类似 MNIST 的数据集；对图像和标签进行矢量化，以输入神经网络。</li><li id="5261" class="lh li hi ih b ii lq im lr iq ls iu lt iy lu jc lm ln lo lp bi translated">接下来，我们通过添加 Keras 层来构建模型，然后配置超参数并开始模型训练。</li><li id="65dd" class="lh li hi ih b ii lq im lr iq ls iu lt iy lu jc lm ln lo lp bi translated">在 TF 模型被训练之后，我们将其量化并转换为 TF Lite 格式，以准备部署。</li><li id="8c40" class="lh li hi ih b ii lq im lr iq ls iu lt iy lu jc lm ln lo lp bi translated">最后，我们构建了一个 Android 应用程序(虽然不是从零开始，因为这超出了本博客的范围)，并在其上部署了我们的分类器模型。</li></ul><p id="0242" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我希望你像我喜欢写博客一样喜欢它。如果你想就此谈得更多，请随时通过<a class="ae jd" href="http://www.linkedin.com/in/tiwari-nitin" rel="noopener ugc nofollow" target="_blank"> <strong class="ih hj"> LinkedIn </strong> </a>与我联系。请继续关注更多关于机器学习的有趣话题，我将在这里讲述端到端的例子。</p><h2 id="d7aa" class="ju jv hi bd jw jx jy jz ka kb kc kd ke iq kf kg kh iu ki kj kk iy kl km kn ko bi translated">资源</h2><ul class=""><li id="d84e" class="lh li hi ih b ii kp im kq iq mb iu mc iy md jc lm ln lo lp bi translated"><a class="ae jd" href="https://www.tensorflow.org/js/tutorials/training/handwritten_digit_cnn" rel="noopener ugc nofollow" target="_blank"> <strong class="ih hj">手写数字识别</strong></a><strong class="ih hj">:</strong>tensor flow 关于训练手写数字识别器的教程。</li><li id="4c9e" class="lh li hi ih b ii lq im lr iq ls iu lt iy lu jc lm ln lo lp bi translated"><a class="ae jd" href="https://github.com/tensorflow/examples/tree/master/lite/examples/digit_classifier/android" rel="noopener ugc nofollow" target="_blank"> <strong class="ih hj">数字分类器</strong></a><strong class="ih hj">:</strong>tensor flow 在 Android 上进行数字分类的官方示例。</li></ul></div></div>    
</body>
</html>