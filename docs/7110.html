<html>
<head>
<title>Background Work in Xamarin.Forms. Part #2 — Xamarin.iOS</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Xamarin.Forms 中的背景工作。第 2 部分— Xamarin.iOS</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/background-work-in-xamarin-forms-part-2-xamarin-ios-ff22037a7b60?source=collection_archive---------0-----------------------#2022-07-29">https://medium.com/nerd-for-tech/background-work-in-xamarin-forms-part-2-xamarin-ios-ff22037a7b60?source=collection_archive---------0-----------------------#2022-07-29</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><figure class="hh hi ez fb hj hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es hg"><img src="../Images/eda8231c6b665fc3e681ce24bf5eae37.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*46PXgG9TZnISQjFFjsVqjg.png"/></div></div></figure><div class=""/><div class=""><h2 id="896f" class="pw-subtitle-paragraph iq hs ht bd b ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh dx translated">这一次，我们将讨论在 iOS 设备上运行后台程序的可能解决方案。我们将触及位置更新和区域监控，因为这是最常见的情况。</h2></div><p id="110a" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">大家好👋！！！正如副标题中提到的，我们将触及位置更新和区域监控，因为这是最常见的情况，但其他更新，如后台推送通知、音频或 AirPlay 将不会被涵盖，因为这是非常具体的用法，更适合设备在自己单独的博客帖子中使用。</p><div class="hh hi ez fb hj ke"><a rel="noopener follow" target="_blank" href="/nerd-for-tech/background-work-in-xamarin-forms-part-1-xamarin-android-63f629e73f9"><div class="kf ab dw"><div class="kg ab kh cl cj ki"><h2 class="bd hu fi z dy kj ea eb kk ed ef hs bi translated">Xamarin.Forms 中的背景工作。第 1 部分— Xamarin。机器人</h2><div class="kl l"><h3 class="bd b fi z dy kj ea eb kk ed ef dx translated">如果我们需要在后台运行一些工作，我们应该选择什么？它应该是一个工人，服务或简单的任务运行…</h3></div><div class="km l"><p class="bd b fp z dy kj ea eb kk ed ef dx translated">medium.com</p></div></div><div class="kn l"><div class="ko l kp kq kr kn ks hp ke"/></div></div></a></div><p id="b7c8" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">任务。运行—本机。Net 运行后台任务的方式已经在第 1 部分很好地介绍过了，我想刚刚提到的是，它为 iOS 提供了同样的可能性，以及同样的优点和局限性。这里要提一点很重要的是，在 iOS 应用被隐藏后不久，它就停止执行所有后台任务。这就是为什么如果你想确保你已经完成了你的工作或者你的任务可能需要一些值得注意的时间，你需要使用<code class="du kt ku kv kw b">BGTaskScheduler</code>。</p><p id="24f2" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">这两部分的所有源代码都可以从 GitHub 获得:</p><div class="hh hi ez fb hj ke"><a href="https://github.com/bbenetskyy/ios-bg-worker" rel="noopener  ugc nofollow" target="_blank"><div class="kf ab dw"><div class="kg ab kh cl cj ki"><h2 class="bd hu fi z dy kj ea eb kk ed ef hs bi translated">GitHub-bbenetskyy/IOs-BG-worker</h2><div class="kl l"><h3 class="bd b fi z dy kj ea eb kk ed ef dx translated">此存储库已由所有者存档。它现在是只读的。此时您不能执行该操作。你…</h3></div><div class="km l"><p class="bd b fp z dy kj ea eb kk ed ef dx translated">github.com</p></div></div><div class="kn l"><div class="kx l kp kq kr kn ks hp ke"/></div></div></a></div></div><div class="ab cl ky kz gp la" role="separator"><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld"/></div><div class="hb hc hd he hf"><h1 id="d17f" class="lf lg ht bd lh li lj lk ll lm ln lo lp iz lq ja lr jc ls jd lt jf lu jg lv lw bi translated">用<code class="du kt ku kv kw b">BGTaskScheduler</code>运行原生后台任务</h1><p id="c10c" class="pw-post-body-paragraph ji jj ht jk b jl lx iu jn jo ly ix jq jr lz jt ju jv ma jx jy jz mb kb kc kd hb bi translated">在我们开始之前，我需要提一下，我们将实现在博客的<a class="ae mc" rel="noopener" href="/nerd-for-tech/background-work-in-xamarin-forms-part-1-xamarin-android-63f629e73f9"> Part # </a> 1 中创建和使用的<a class="ae mc" href="https://gist.github.com/bbenetskyy/1ae9beb57705bf281a7418d329d95a53" rel="noopener ugc nofollow" target="_blank"> IBackgroundWorker </a>。请到那里复制它的定义。</p><p id="bb8c" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">为了展示它是如何工作的，我将创建重复的工作。后台工作将什么都不得到，并在被调用时记录到屏幕时间。</p><figure class="me mf mg mh fd hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es md"><img src="../Images/bfdc7eff6d6c4d5c0f283dd5d4258825.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PlY8k1yokf4EGp-sHnghBA.png"/></div></div><figcaption class="mi mj et er es mk ml bd b be z dx translated">背景工作更新</figcaption></figure><p id="8daa" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">为了达到这个目的，我们需要给<code class="du kt ku kv kw b">NSTimer -&gt; CreateRepeatingScheduledTimer</code>设置一些冷却时间。对于这个例子，我将使用 5 秒，但苹果公司建议使用 5 到 15 分钟进行这样的重复，但如果你的任务需要更多的执行时间或更长的延迟，30 分钟也可以。</p><figure class="me mf mg mh fd hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es mm"><img src="../Images/cc901450bbd137b25cd76e9d5145acd2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mjLdi1WbxX0bhfuYczhZlw.png"/></div></div><figcaption class="mi mj et er es mk ml bd b be z dx translated"><code class="du kt ku kv kw b">CreateRepeatingScheduledTimer definition</code></figcaption></figure><p id="657d" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">作为一个动作，我们将通过一个超时回调来传递我们将要创建<code class="du kt ku kv kw b">taskId</code>的函数，以确保我们完成该任务。</p><figure class="me mf mg mh fd hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es mn"><img src="../Images/a6d50f9d46c2e6acf16f29dde085dcb0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*T_3BFHKS6ZMeaCcxnvCSVg.png"/></div></div><figcaption class="mi mj et er es mk ml bd b be z dx translated">NSTimer 的设置</figcaption></figure><p id="c3cf" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">下一步是在<code class="du kt ku kv kw b">info.plist</code>文件中注册我们的背景模式和背景标识符</p><figure class="me mf mg mh fd hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es mo"><img src="../Images/dd9665bd47e8205259e672de9368bc8d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mqD1ifFRyqoi0CbAdYmtSg.png"/></div></div><figcaption class="mi mj et er es mk ml bd b be z dx translated">后台任务更新的 info.plist 设置</figcaption></figure><p id="c779" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">下一步是在<code class="du kt ku kv kw b">AppDelegate -&gt; FinishedLaunching</code>内部注册我们的后台工作人员。这里我们需要在共享任务调度器内部注册由我们的<code class="du kt ku kv kw b">CFBundleIdentifier</code>新建的<code class="du kt ku kv kw b">NSOperationQueue</code>。在共享应用程序中，设置最小的后台获取时间间隔。这里推荐使用 iOS 提供的<code class="du kt ku kv kw b">UIApplication.BackgroundFetchIntervalMinimum</code>。</p><figure class="me mf mg mh fd hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es mp"><img src="../Images/a6957c5995ae2aa7dc4c22c4d509150b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oomrRLA-Nn8XpzB1fWvr4g.png"/></div></div><figcaption class="mi mj et er es mk ml bd b be z dx translated">刷新标识符常数</figcaption></figure><figure class="me mf mg mh fd hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es mq"><img src="../Images/e7f222b4e63d13702c2a56adf0f29d99.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*K1z2IAeRWGniIbo2Fy1SIg.png"/></div></div><figcaption class="mi mj et er es mk ml bd b be z dx translated">AppDelegate FinishedLauching 方法</figcaption></figure><p id="942b" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">我们的启动处理程序任务将询问我们的后台工作程序是否有任何可用的工作，如果有任何可用的工作，就运行它。当我们的应用程序隐藏时，所有这些都将在后台执行。</p><blockquote class="mr ms mt"><p id="d7bc" class="ji jj mu jk b jl jm iu jn jo jp ix jq mv js jt ju mw jw jx jy mx ka kb kc kd hb bi translated">但是如果你完全关闭你的应用程序，iOS 系统将不会调用你的后台工作，因为你需要寻找一些自定义推送通知或类似的解决方法。</p></blockquote><figure class="me mf mg mh fd hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es my"><img src="../Images/3952393d59cb1b266da28f093abec6a6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YZzaoh2nB31R3ATVu_kyxg.png"/></div></div><figcaption class="mi mj et er es mk ml bd b be z dx translated">开始后台同步工作</figcaption></figure><figure class="me mf mg mh fd hk"><div class="bz dy l di"><div class="mz na l"/></div><figcaption class="mi mj et er es mk ml bd b be z dx translated">后台工作器实现</figcaption></figure><p id="1fa8" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated"><a class="ae mc" href="https://github.com/bbenetskyy/ios-bg-worker/blob/master/sample/sample/sample.iOS/AppDelegate.cs" rel="noopener ugc nofollow" target="_blank">您可以在存储库中找到 AppDelegate 代码。</a></p><p id="d8a2" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">我们需要做的最后两件事是:</p><ol class=""><li id="76da" class="nb nc ht jk b jl jm jo jp jr nd jv ne jz nf kd ng nh ni nj bi translated">当系统执行 Fetch 时，我们需要返回任何新数据是否可用的信息。</li></ol><figure class="me mf mg mh fd hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es nk"><img src="../Images/07f519d895f3cffc40643e1a886446f7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4k28g0xOyj5C7ZLuqIUtKQ.png"/></div></div><figcaption class="mi mj et er es mk ml bd b be z dx translated">执行提取方法</figcaption></figure><p id="dbef" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">2.向后台调度程序提交一个关于我们共享的后台工作程序的请求，这是我们在<code class="du kt ku kv kw b">FinishedLaunching</code>方法中设置的</p><figure class="me mf mg mh fd hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es nl"><img src="../Images/4747e92b1a4743bed6d4faebf7a0f39d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BxngyhKUZjqn2Sx0aUpkRg.png"/></div></div><figcaption class="mi mj et er es mk ml bd b be z dx translated">确实进入了后台方法</figcaption></figure></div><div class="ab cl ky kz gp la" role="separator"><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld"/></div><div class="hb hc hd he hf"><h1 id="b00a" class="lf lg ht bd lh li lj lk ll lm ln lo lp iz lq ja lr jc ls jd lt jf lu jg lv lw bi translated">iOS 中的位置更新</h1><p id="08c8" class="pw-post-body-paragraph ji jj ht jk b jl lx iu jn jo ly ix jq jr lz jt ju jv ma jx jy jz mb kb kc kd hb bi translated">这次我们从<code class="du kt ku kv kw b">info.plist</code>设置开始。我们需要设置位置使用描述和多一个背景模式</p><figure class="me mf mg mh fd hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es nm"><img src="../Images/1fb86df1b4ae4ff225e42e46cef680cb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TwU6r3fk_alpFzVNorvFpA.png"/></div></div><figcaption class="mi mj et er es mk ml bd b be z dx translated">info.plist 后台位置更新和区域监控设置</figcaption></figure><p id="7d2b" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">这里重要的是，如果我们想在后台接收位置更新，设置并稍后请求<code class="du kt ku kv kw b">Location Always</code></p><figure class="me mf mg mh fd hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es nn"><img src="../Images/14737ae9a647dc187300967197e51bb7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TBWf6XhwxpsqA2E8HT48rg.png"/></div></div><figcaption class="mi mj et er es mk ml bd b be z dx translated">请求位置总是权限</figcaption></figure><figure class="me mf mg mh fd hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es no"><img src="../Images/b728ba5ff484c8d0a89a8ce4c34bffe1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pPnvgDL5CkaERYshvXvPzg.png"/></div></div><figcaption class="mi mj et er es mk ml bd b be z dx translated">位置和区域工作更新</figcaption></figure><p id="8de8" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">现在我们可以通过在<code class="du kt ku kv kw b">CLLocationManager</code>订阅事件<code class="du kt ku kv kw b">LocationsUpdated</code>来设置位置更新。</p><p id="442a" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">为此，我们需要:</p><ol class=""><li id="6ae1" class="nb nc ht jk b jl jm jo jp jr nd jv ne jz nf kd ng nh ni nj bi translated">创建<code class="du kt ku kv kw b">CLLocationManager</code>的实例</li><li id="67af" class="nb nc ht jk b jl np jo nq jr nr jv ns jz nt kd ng nh ni nj bi translated">禁用自动位置暂停</li><li id="9b70" class="nb nc ht jk b jl np jo nq jr nr jv ns jz nt kd ng nh ni nj bi translated">除了我们的许可请求之外，如果系统版本高于 8(所以每次🤪)</li><li id="5340" class="nb nc ht jk b jl np jo nq jr nr jv ns jz nt kd ng nh ni nj bi translated">而如果系统版本高于 9(所以每次🤪)我们需要允许后台位置更新</li><li id="1ade" class="nb nc ht jk b jl np jo nq jr nr jv ns jz nt kd ng nh ni nj bi translated">之后，如果位置服务可用，我们可以设置所需的精度并订阅位置更新</li><li id="b0e9" class="nb nc ht jk b jl np jo nq jr nr jv ns jz nt kd ng nh ni nj bi translated">做完这些后，我们可以开始更新位置了🤩</li></ol><figure class="me mf mg mh fd hk"><div class="bz dy l di"><div class="mz na l"/></div></figure><p id="417c" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">您可能注意到了，我检查了上次执行时间，并且每隔一段时间(延迟)才运行一次自己的事件。如果您想接收任何位置更新(如果您在高速公路上，每秒钟会发生多次事件)，只需移除那个<code class="du kt ku kv kw b">if</code>就可以了。</p><p id="6e77" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">与之前的模拟器截图相比，下面是模拟<code class="du kt ku kv kw b">Freeway Drive</code>的效果:</p><figure class="me mf mg mh fd hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es md"><img src="../Images/358045f87ce49410f627ce93e1681317.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oO_IMRQbphJRZNB0O-VMDQ.png"/></div></div><figcaption class="mi mj et er es mk ml bd b be z dx translated">随时更新位置，没有任何延迟</figcaption></figure></div><div class="ab cl ky kz gp la" role="separator"><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld"/></div><div class="hb hc hd he hf"><h1 id="dcbd" class="lf lg ht bd lh li lj lk ll lm ln lo lp iz lq ja lr jc ls jd lt jf lu jg lv lw bi translated">iOS 中的区域监控</h1><p id="de0a" class="pw-post-body-paragraph ji jj ht jk b jl lx iu jn jo ly ix jq jr lz jt ju jv ma jx jy jz mb kb kc kd hb bi translated">令人惊讶的是，这里几乎和我们的位置更新一样，相同的权限，相同的信息列表修改。所以让我们立即进入肉的部分😝。</p><ol class=""><li id="fd2a" class="nb nc ht jk b jl jm jo jp jr nd jv ne jz nf kd ng nh ni nj bi translated">创建<code class="du kt ku kv kw b">CLLocationManager</code>的实例</li><li id="ae4c" class="nb nc ht jk b jl np jo nq jr nr jv ns jz nt kd ng nh ni nj bi translated">禁用自动位置暂停</li><li id="d87d" class="nb nc ht jk b jl np jo nq jr nr jv ns jz nt kd ng nh ni nj bi translated">除了我们的许可请求之外，如果系统版本高于 8(所以每次🤪)</li><li id="f92b" class="nb nc ht jk b jl np jo nq jr nr jv ns jz nt kd ng nh ni nj bi translated">而如果系统版本高于 9(所以每次🤪)我们需要允许后台位置更新</li><li id="cc9f" class="nb nc ht jk b jl np jo nq jr nr jv ns jz nt kd ng nh ni nj bi translated">之后，如果定位服务可用并且<strong class="jk hu">监控服务可用</strong></li><li id="e3a2" class="nb nc ht jk b jl np jo nq jr nr jv ns jz nt kd ng nh ni nj bi translated">我们可以设置所需的精度并订阅<code class="du kt ku kv kw b">region</code>事件</li><li id="cea5" class="nb nc ht jk b jl np jo nq jr nr jv ns jz nt kd ng nh ni nj bi translated">做完这些后，我们可以开始更新位置了🤩</li></ol><figure class="me mf mg mh fd hk"><div class="bz dy l di"><div class="mz na l"/></div></figure></div><div class="ab cl ky kz gp la" role="separator"><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld"/></div><div class="hb hc hd he hf"><p id="459a" class="pw-post-body-paragraph ji jj ht jk b jl jm iu jn jo jp ix jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">这就是我想在这两个博客帖子中涵盖的所有内容😆关于在 Android 和 iOS 中运行一些常见的后台任务。希望这些能帮助你决定什么时候使用<code class="du kt ku kv kw b">.Net Task.Run</code>，什么时候使用本地解决方案。</p><figure class="me mf mg mh fd hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es nu"><img src="../Images/3432f5bf8d527381e7740449fbee0f3a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nPH3ANHJgIeukcXA_4SO6g.png"/></div></div></figure></div></div>    
</body>
</html>