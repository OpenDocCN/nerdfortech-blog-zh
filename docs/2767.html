<html>
<head>
<title>How I Stopped Coding Repetitive Service Components with Kong</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">我是如何用孔停止编写重复的服务组件的</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/how-i-stopped-coding-repetitive-service-components-with-kong-1308be4000e3?source=collection_archive---------8-----------------------#2021-05-19">https://medium.com/nerd-for-tech/how-i-stopped-coding-repetitive-service-components-with-kong-1308be4000e3?source=collection_archive---------8-----------------------#2021-05-19</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/846b359ed1293be64d7c038d7997df0e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yQX_dmWxzFJ-mr0fY10a_w.jpeg"/></div></div></figure><figure class="iq ir is it fd ij"><div class="bz dy l di"><div class="iu iv l"/></div></figure><p id="3f1f" class="pw-post-body-paragraph iw ix hi iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt hb bi translated">在过去的 10 年里，我一直在构建 RESTful 服务，作为通过咨询机会分配给我的项目的特性团队成员，或者作为一名全职公司员工。这代表了我职业生涯的三分之一，也是我最享受的。</p><p id="f424" class="pw-post-body-paragraph iw ix hi iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt hb bi translated">然而，在所有这些年里，当系统成为应用程序现代化计划的一部分时，我感觉我在一遍又一遍地学习相同的课程:</p><ol class=""><li id="4275" class="ju jv hi iy b iz ja jd je jh jw jl jx jp jy jt jz ka kb kc bi translated">不要用另一个伪装成现代化服务的整体来代替一个整体。</li><li id="7005" class="ju jv hi iy b iz kd jd ke jh kf jl kg jp kh jt jz ka kb kc bi translated">避免接受不良的数据模型，以符合现代化的系统。</li><li id="68ae" class="ju jv hi iy b iz kd jd ke jh kf jl kg jp kh jt jz ka kb kc bi translated">永远不要假设现有的程序逻辑是 100%正确的。</li><li id="a08a" class="ju jv hi iy b iz kd jd ke jh kf jl kg jp kh jt jz ka kb kc bi translated">安全性和身份应该抽象/整合到更高的级别。</li><li id="86f9" class="ju jv hi iy b iz kd jd ke jh kf jl kg jp kh jt jz ka kb kc bi translated">日志记录、监控和路由应包含在初始设计中。</li></ol><p id="962d" class="pw-post-body-paragraph iw ix hi iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt hb bi translated">这些经验中的每一个都可以成为一本致力于正确实现应用程序现代化的出版物的焦点。更确切地说，对于这份出版物，我将把重点放在支持成功运行的应用程序上——尽管这五条经验(如上)都失败了。</p><h1 id="aead" class="ki kj hi bd kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf bi translated">我们生活的世界</h1><p id="bf1a" class="pw-post-body-paragraph iw ix hi iy b iz lg jb jc jd lh jf jg jh li jj jk jl lj jn jo jp lk jr js jt hb bi translated">在我认真对待计算机编程的几年前，有一首歌叫《我们生活的世界》，是由一个叫做<a class="ae ll" href="https://en.wikipedia.org/wiki/Wang_Chung_(band)" rel="noopener ugc nofollow" target="_blank">王聪</a> <a class="ae ll" href="https://en.wikipedia.org/wiki/Wang_Chung_(band))." rel="noopener ugc nofollow" target="_blank">的新浪潮乐队演唱的。</a>那首歌中负面的歌词讲述了一个重要的世界和我们自己行动的结果。很多时候，作为 API 的消费者，当我试图浏览非标准 API 和意想不到的体验时，我会感觉到这首歌的核心在我的血管中流动。</p><p id="820c" class="pw-post-body-paragraph iw ix hi iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt hb bi translated">一些让我指尖麻木的痛点:</p><ul class=""><li id="265b" class="ju jv hi iy b iz ja jd je jh jw jl jx jp jy jt lm ka kb kc bi translated">强迫我对每个请求发送不必要的授权</li><li id="ab4a" class="ju jv hi iy b iz kd jd ke jh kf jl kg jp kh jt lm ka kb kc bi translated">违反核心设计标准的 RESTful 调用(获取变化的数据)</li><li id="42b6" class="ju jv hi iy b iz kd jd ke jh kf jl kg jp kh jt lm ka kb kc bi translated">仅仅因为遗留系统的需求而执行补充的 API 调用</li><li id="48b6" class="ju jv hi iy b iz kd jd ke jh kf jl kg jp kh jt lm ka kb kc bi translated">没有良好的机制来正确调试和解决问题</li></ul><p id="fbc9" class="pw-post-body-paragraph iw ix hi iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt hb bi translated">事实上，如今许多基于服务的应用程序都遵循类似于下图所示的设计:</p><figure class="iq ir is it fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ln"><img src="../Images/4ee925e73513d6472cae1e00bb85361a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SCv70Xvh1BerhArWm3NjDg.png"/></div></div></figure><p id="d48c" class="pw-post-body-paragraph iw ix hi iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt hb bi translated">在这个例子中，每个服务都在服务层实现了六个公共组件。这导致了必须手动管理的重复——尤其是当底层源代码(如上所示)使用不同的语言和框架时。</p><p id="148f" class="pw-post-body-paragraph iw ix hi iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt hb bi translated">作为一名特性开发人员，我努力寻找更有效率的方法。我寻找方法来最大化我分配的时间，以满足接受标准，并使业务规则导致成功的产品增强。最重要的是，我想避免我的指尖在我这个年龄变得麻木。</p><h1 id="fd0e" class="ki kj hi bd kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf bi translated">后来我找到了孔…</h1><p id="9942" class="pw-post-body-paragraph iw ix hi iy b iz lg jb jc jd lh jf jg jh li jj jk jl lj jn jo jp lk jr js jt hb bi translated">如果如上图被重构并合并，如下图所示，会怎么样？</p><figure class="iq ir is it fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ln"><img src="../Images/b67ac3d15dcc4ce3063d71b6dd28a8fe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Ij9GtlMTEYTXi3SRH__Shw.png"/></div></div></figure><p id="076a" class="pw-post-body-paragraph iw ix hi iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt hb bi translated">在上面的例子中，所有重复的组件被整合到一个分布式微服务抽象层中，这个抽象层通常被称为 API 网关。事实上，我在 Kong 的云原生 API 网关产品(也称为“Kong Gateway ”)中发现了这个设计。</p><p id="dfd6" class="pw-post-body-paragraph iw ix hi iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt hb bi translated"><strong class="iy hj">孔关口</strong></p><p id="04ad" class="pw-post-body-paragraph iw ix hi iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt hb bi translated"><a class="ae ll" href="https://github.com/Kong/kong" rel="noopener ugc nofollow" target="_blank"> Kong Gateway </a>产品允许我的服务层 API 的复杂性减少到一组端点(或 URIs ),集中于满足一组业务需求和功能。通常，重复的组件(如身份验证、日志记录和安全性)由网关处理，可以从服务层设计中删除。<br/>除了原图中显示的通用组件外，Kong Gateway 还提供了其他功能:</p><ul class=""><li id="8ffc" class="ju jv hi iy b iz ja jd je jh jw jl jx jp jy jt lm ka kb kc bi translated">动态负载平衡</li><li id="20ce" class="ju jv hi iy b iz kd jd ke jh kf jl kg jp kh jt lm ka kb kc bi translated">健康检查</li><li id="f033" class="ju jv hi iy b iz kd jd ke jh kf jl kg jp kh jt lm ka kb kc bi translated">服务发现</li><li id="49aa" class="ju jv hi iy b iz kd jd ke jh kf jl kg jp kh jt lm ka kb kc bi translated">无服务器</li><li id="6c60" class="ju jv hi iy b iz kd jd ke jh kf jl kg jp kh jt lm ka kb kc bi translated">使聚集</li><li id="e5c8" class="ju jv hi iy b iz kd jd ke jh kf jl kg jp kh jt lm ka kb kc bi translated">可量测性</li><li id="8d2c" class="ju jv hi iy b iz kd jd ke jh kf jl kg jp kh jt lm ka kb kc bi translated">表演</li></ul><p id="0549" class="pw-post-body-paragraph iw ix hi iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt hb bi translated">Kong Gateway 最大的优点是它是一个云原生(平台无关)开源软件(OSS)解决方案，几乎可以在任何地方使用。使用 OSS 产品也没有许可费用。</p><h1 id="25a5" class="ki kj hi bd kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf bi translated">库马</h1><p id="a727" class="pw-post-body-paragraph iw ix hi iy b iz lg jb jc jd lh jf jg jh li jj jk jl lj jn jo jp lk jr js jt hb bi translated">从更广的层面来看，<a class="ae ll" href="https://github.com/kumahq/kuma" rel="noopener ugc nofollow" target="_blank">库马</a>是另一款面向服务网格和微服务管理的平台无关 OSS 解决方案，支持 Kubernetes、虚拟机(VM)甚至裸机环境的控制平面。孔将捐赠给了云计算原生计算基金会(简称)，并且仍然积极地为不断发展的代码库做出贡献。</p><p id="d1aa" class="pw-post-body-paragraph iw ix hi iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt hb bi translated">虽然 Kong Gateway 是位于请求者和服务之间的一个单独的层，但库马采用了一种“sidecar”模式——类似于摩托车上的 sidecar。然而，这种边车不是为乘客提供额外的空间，而是连接到单独的集装箱上——因此形成了一个“网”而不是一个单独的层。</p><p id="c1e8" class="pw-post-body-paragraph iw ix hi iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt hb bi translated">库马利用<a class="ae ll" href="https://www.envoyproxy.io/" rel="noopener ugc nofollow" target="_blank">Envoy</a>——一个开源的 edge 和服务代理——通过一致的可观察性来可视化任何程序领域。除了高级用户界面，孔库马还包括三个关键功能:</p><ul class=""><li id="2da8" class="ju jv hi iy b iz ja jd je jh jw jl jx jp jy jt lm ka kb kc bi translated">通用控制平面</li><li id="d4f9" class="ju jv hi iy b iz kd jd ke jh kf jl kg jp kh jt lm ka kb kc bi translated">轻量级数据平面</li><li id="92fd" class="ju jv hi iy b iz kd jd ke jh kf jl kg jp kh jt lm ka kb kc bi translated">自动的</li></ul><figure class="iq ir is it fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lo"><img src="../Images/f5f53bfb88dc4911fe0d69a874a07796.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mGQVHEjXZ6SCv72grwfsAA.png"/></div></div></figure><p id="49f3" class="pw-post-body-paragraph iw ix hi iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt hb bi translated">借助库马，分布式环境可以利用核心的 Kong 网关特性和功能，同时还包括以下方面:</p><ul class=""><li id="124b" class="ju jv hi iy b iz ja jd je jh jw jl jx jp jy jt lm ka kb kc bi translated">多区域支持</li><li id="6952" class="ju jv hi iy b iz kd jd ke jh kf jl kg jp kh jt lm ka kb kc bi translated">细粒度的服务和流量策略</li><li id="cab9" class="ju jv hi iy b iz kd jd ke jh kf jl kg jp kh jt lm ka kb kc bi translated">水平可伸缩</li><li id="bb33" class="ju jv hi iy b iz kd jd ke jh kf jl kg jp kh jt lm ka kb kc bi translated">支持关键任务使用案例</li></ul><h1 id="3ade" class="ki kj hi bd kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf bi translated">孔入口控制器</h1><p id="1c82" class="pw-post-body-paragraph iw ix hi iy b iz lg jb jc jd lh jf jg jh li jj jk jl lj jn jo jp lk jr js jt hb bi translated">对于那些使用 Kubernetes 进行容器编排的组织，Kong 创建了<a class="ae ll" href="https://github.com/Kong/kubernetes-ingress-controller" rel="noopener ugc nofollow" target="_blank"> Kong Ingress Controller </a>，它可以跨 Kubernetes 集群实现认证、转换和其他功能(通过插件)。</p><p id="6e69" class="pw-post-body-paragraph iw ix hi iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt hb bi translated">Kong 入口控制器更新了标准 Kubernetes 实现，如下所示:</p><figure class="iq ir is it fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lp"><img src="../Images/f36dd9dd55b357047a26f863940eb09f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FzNtlCP8Bz9GP_qrb0Xqnw.png"/></div></div></figure><p id="ef0b" class="pw-post-body-paragraph iw ix hi iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt hb bi translated">有了 Kong 入口控制器，Kong 网关产品中提到的特性就可以通过插件架构来访问。上面的例子中描述了六个插件。</p><h1 id="583d" class="ki kj hi bd kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf bi translated">孔网关(OSS)在行动</h1><p id="8a26" class="pw-post-body-paragraph iw ix hi iy b iz lg jb jc jd lh jf jg jh li jj jk jl lj jn jo jp lk jr js jt hb bi translated">我想采取孔网关(OSS)进行测试驱动，所以我用 Spring Boot 创建了一个非常简单的 URI:</p><ul class=""><li id="51a5" class="ju jv hi iy b iz ja jd je jh jw jl jx jp jy jt lm ka kb kc bi translated">/accounts-检索帐户对象的列表(<a class="ae ll" href="http://localhost:8888/accounts" rel="noopener ugc nofollow" target="_blank">http://localhost:8888/accounts</a>)</li></ul><p id="e82c" class="pw-post-body-paragraph iw ix hi iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt hb bi translated">此 URI 背后的数据将是静态的，并在服务启动时创建。几分钟后，我的本地机器的端口 8888 上的服务就可用了:</p><figure class="iq ir is it fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lq"><img src="../Images/41ad020a0f90feb39b5e55e83f21a3c6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tkrjgb5MR-ZRvKmgFVQogA.png"/></div></div></figure><p id="0dc8" class="pw-post-body-paragraph iw ix hi iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt hb bi translated">为了简单起见，我决定使用 MacBook Pro 系统和 Docker 中的 PostgreSQL 数据库运行 Kong Gateway。<br/> <strong class="iy hj">在 MacBook Pro 上安装孔</strong></p><p id="a3cf" class="pw-post-body-paragraph iw ix hi iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt hb bi translated">使用<a class="ae ll" href="https://brew.sh/" rel="noopener ugc nofollow" target="_blank">家酿</a>包管理器，我用几个命令安装了 Kong Gateway:</p><pre class="iq ir is it fd lr ls lt lu aw lv bi"><span id="3f5a" class="lw kj hi ls b fi lx ly l lz ma">╭─john.vester@jvc ~/projects/jvc/kong <br/>╰─$ brew tap kong/kong<br/>╭─john.vester@jvc ~/projects/jvc/kong <br/>╰─$ brew install kong</span></pre><p id="090d" class="pw-post-body-paragraph iw ix hi iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt hb bi translated">完成后，执行以下命令来验证 Kong Gateway 2 . 4 . 0 版是否已正确安装:</p><pre class="iq ir is it fd lr ls lt lu aw lv bi"><span id="4236" class="lw kj hi ls b fi lx ly l lz ma">╭─john.vester@jvc ~/projects/jvc/kong <br/>╰─$ kong version <br/>2.4.0</span></pre><h1 id="b3ef" class="ki kj hi bd kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf bi translated">使用 Docker 安装和配置 PostgreSQL</h1><p id="42f0" class="pw-post-body-paragraph iw ix hi iy b iz lg jb jc jd lh jf jg jh li jj jk jl lj jn jo jp lk jr js jt hb bi translated">为了让 PostgreSQL 通过 Docker 作为我的数据库运行，我从[ <a class="ae ll" href="https://hub.docker.com/_/postgres" rel="noopener ugc nofollow" target="_blank"> Docker Hub </a> ]下载了最新版本的 Postgres:</p><pre class="iq ir is it fd lr ls lt lu aw lv bi"><span id="bfee" class="lw kj hi ls b fi lx ly l lz ma">╭─john.vester@jvc ~/projects/jvc/kong <br/>╰─$ docker pull postgres</span></pre><p id="cdea" class="pw-post-body-paragraph iw ix hi iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt hb bi translated">一旦 Docker 映像准备就绪，PostgreSQL 就会在 Docker 中启动:</p><pre class="iq ir is it fd lr ls lt lu aw lv bi"><span id="ed26" class="lw kj hi ls b fi lx ly l lz ma"><br/>╭─john.vester@jvc ~/projects/jvc/kong <br/>╰─$ docker run — name postgres -e POSTGRES_PASSWORD=some-password -d -p 5432:5432 postgres</span><span id="0989" class="lw kj hi ls b fi mb ly l lz ma">763a9303b586ea8953717ea6c68fa04437301fe367a5a85b43d5d1fa8523fba6</span></pre><p id="bc3f" class="pw-post-body-paragraph iw ix hi iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt hb bi translated">随着数据库的运行，Kong 网关的元素被添加到正在运行的实例中:</p><pre class="iq ir is it fd lr ls lt lu aw lv bi"><span id="907e" class="lw kj hi ls b fi lx ly l lz ma">CREATE USER kong; <br/>CREATE DATABASE kong OWNER kong;</span></pre><p id="7dee" class="pw-post-body-paragraph iw ix hi iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt hb bi translated">数据库准备的最后一步是执行以下命令:</p><pre class="iq ir is it fd lr ls lt lu aw lv bi"><span id="d00b" class="lw kj hi ls b fi lx ly l lz ma">╭─john.vester@jvc ~/projects/jvc/kong <br/>╰─$ kong migrations bootstrap -c /etc/kong/kong.conf</span><span id="e071" class="lw kj hi ls b fi mb ly l lz ma">…<br/>41 migrations processed<br/>41 executed<br/>Database is up-to-date</span></pre><h1 id="fee7" class="ki kj hi bd kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf bi translated">配置 Kong 网关</h1><p id="8d61" class="pw-post-body-paragraph iw ix hi iy b iz lg jb jc jd lh jf jg jh li jj jk jl lj jn jo jp lk jr js jt hb bi translated">数据库迁移完成后，孔网关准备启动:</p><pre class="iq ir is it fd lr ls lt lu aw lv bi"><span id="9ff5" class="lw kj hi ls b fi lx ly l lz ma">╭─john.vester@jvc ~/projects/jvc/kong <br/>╰─$ kong start -c /etc/kong/kong.conf<br/>Kong started</span></pre><p id="d2c8" class="pw-post-body-paragraph iw ix hi iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt hb bi translated">随着孔网关的设置和准备工作的进行，下一步是集中精力配置上面提到的的。第一步是使用以下 cURL 将 Spring Boot RESTful 服务配置为“account-service ”:</p><pre class="iq ir is it fd lr ls lt lu aw lv bi"><span id="d1d2" class="lw kj hi ls b fi lx ly l lz ma">curl — location — request POST ‘<a class="ae ll" href="http://localhost:8001/services'" rel="noopener ugc nofollow" target="_blank">http://localhost:8001/services'</a> \<br/> — header ‘Content-Type: application/x-www-form-urlencoded’ \<br/> — data-urlencode ‘name=account-service’ \<br/> — data-urlencode ‘url=<a class="ae ll" href="http://localhost:8888/accounts'" rel="noopener ugc nofollow" target="_blank">http://localhost:8888/accounts'</a></span></pre><p id="6202" class="pw-post-body-paragraph iw ix hi iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt hb bi translated">这会导致以下响应—引用 Postgres 中存储的配置数据:</p><pre class="iq ir is it fd lr ls lt lu aw lv bi"><span id="f144" class="lw kj hi ls b fi lx ly l lz ma">{<br/> “connect_timeout”: 60000,<br/> “path”: “/accounts”,<br/> “read_timeout”: 60000,<br/> “name”: “account-service”,<br/> “write_timeout”: 60000,<br/> “created_at”: 1618933968,<br/> “updated_at”: 1618933968,<br/> “tls_verify”: null,<br/> “id”: “7ba5d84c-0b4d-454a-83b3–5381d4e52c61”,<br/> “tls_verify_depth”: null,<br/> “retries”: 5,<br/> “tags”: null,<br/> “ca_certificates”: null,<br/> “port”: 8888,<br/> “client_certificate”: null,<br/> “host”: “localhost”,<br/> “protocol”: “http”<br/>}</span></pre><p id="ef43" class="pw-post-body-paragraph iw ix hi iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt hb bi translated">接下来为名为“account-service”的主机创建一个路由，将从调用 Spring Boot 服务的地方引用该路由:</p><pre class="iq ir is it fd lr ls lt lu aw lv bi"><span id="ceed" class="lw kj hi ls b fi lx ly l lz ma">curl — location — request POST ‘<a class="ae ll" href="http://localhost:8001/services/account-service/routes'" rel="noopener ugc nofollow" target="_blank">http://localhost:8001/services/account-service/routes'</a> \<br/> — header ‘Content-Type: application/x-www-form-urlencoded’ \<br/> — data-urlencode ‘hosts[]=account-service’</span></pre><p id="6b3c" class="pw-post-body-paragraph iw ix hi iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt hb bi translated">cURL 命令的结果从 Kong Gateway 生成以下 JSON 响应:</p><pre class="iq ir is it fd lr ls lt lu aw lv bi"><span id="eb41" class="lw kj hi ls b fi lx ly l lz ma">{<br/> “headers”: null,<br/> “name”: null,<br/> “hosts”: [<br/> “account-service”<br/> ],<br/> “created_at”: 1618936295,<br/> “path_handling”: “v0”,<br/> “id”: “d70a3bf2–4a82–4ec5-a644–90806c53f5b5”,<br/> “protocols”: [<br/> “http”,<br/> “https”<br/> ],<br/> “paths”: null,<br/> “request_buffering”: true,<br/> “response_buffering”: true,<br/> “destinations”: null,<br/> “methods”: null,<br/> “https_redirect_status_code”: 426,<br/> “preserve_host”: false,<br/> “strip_path”: true,<br/> “regex_priority”: 0,<br/> “updated_at”: 1618936295,<br/> “snis”: null,<br/> “sources”: null,<br/> “service”: {<br/> “id”: “7ba5d84c-0b4d-454a-83b3–5381d4e52c61”<br/> },<br/> “tags”: null<br/>}</span></pre><p id="eeaa" class="pw-post-body-paragraph iw ix hi iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt hb bi translated">此时，可以使用以下 cURL 通过 Kong 网关检索“帐户-服务”路由:</p><pre class="iq ir is it fd lr ls lt lu aw lv bi"><span id="e188" class="lw kj hi ls b fi lx ly l lz ma">curl — location — request GET ‘<a class="ae ll" href="http://localhost:8000/'" rel="noopener ugc nofollow" target="_blank">http://localhost:8000/'</a> \<br/> — header ‘Host: account-service’</span></pre><p id="fa22" class="pw-post-body-paragraph iw ix hi iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt hb bi translated">它从 Spring Boot 服务返回预期的 JSON 数据:</p><pre class="iq ir is it fd lr ls lt lu aw lv bi"><span id="41fc" class="lw kj hi ls b fi lx ly l lz ma">[<br/> {<br/> “id”: 1,<br/> “name”: “Eric”<br/> },<br/> {<br/> “id”: 2,<br/> “name”: “Finn”<br/> },<br/> {<br/> “id”: 3,<br/> “name”: “Nicole”<br/> },<br/> {<br/> “id”: 4,<br/> “name”: “John”<br/> },<br/> {<br/> “id”: 5,<br/> “name”: “Sydney”<br/> }<br/>]</span></pre><p id="5033" class="pw-post-body-paragraph iw ix hi iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt hb bi translated">成功！这与直接击中时的数据完全相同，只是通过了孔关口。</p><h1 id="53f9" class="ki kj hi bd kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf bi translated">添加速率限制插件</h1><p id="5a0a" class="pw-post-body-paragraph iw ix hi iy b iz lg jb jc jd lh jf jg jh li jj jk jl lj jn jo jp lk jr js jt hb bi translated">接下来，我使用以下 cURL 在 Kong 网关中实现了速率限制插件:</p><pre class="iq ir is it fd lr ls lt lu aw lv bi"><span id="e6eb" class="lw kj hi ls b fi lx ly l lz ma">curl -X POST <a class="ae ll" href="http://localhost:8001/services/account-service/plugins" rel="noopener ugc nofollow" target="_blank">http://localhost:8001/services/account-service/plugins</a> \ <br/> — data “name=rate-limiting” \ <br/> — data “config.second=1” \ <br/> — data “config.minute=3” \<br/> — data “config.policy=local”</span></pre><p id="4a17" class="pw-post-body-paragraph iw ix hi iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt hb bi translated">这种配置虽然有限制，但每秒钟只允许一个帐户服务请求，每分钟最多三个请求。</p><p id="c634" class="pw-post-body-paragraph iw ix hi iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt hb bi translated">这个帖子的提交产生了以下响应负载:</p><pre class="iq ir is it fd lr ls lt lu aw lv bi"><span id="2a9e" class="lw kj hi ls b fi lx ly l lz ma">{<br/> “route”: null,<br/> “tags”: null,<br/> “name”: “rate-limiting”,<br/> “config”: {<br/> “year”: null,<br/> “path”: null,<br/> “limit_by”: “consumer”,<br/> “hide_client_headers”: false,<br/> “second”: 1,<br/> “minute”: 3,<br/> “redis_timeout”: 2000,<br/> “redis_database”: 0,<br/> “redis_host”: null,<br/> “redis_port”: 6379,<br/> “policy”: “local”,<br/> “hour”: null,<br/> “header_name”: null,<br/> “redis_password”: null,<br/> “fault_tolerant”: true,<br/> “day”: null,<br/> “month”: null<br/> },<br/> “protocols”: [<br/> “grpc”,<br/> “grpcs”,<br/> “http”,<br/> “https”<br/> ],<br/> “created_at”: 1618947648,<br/> “service”: {<br/> “id”: “7ba5d84c-0b4d-454a-83b3–5381d4e52c61”<br/> },<br/> “consumer”: null,<br/> “id”: “a3d8532a-0464–4117-bbfd-716300966fe7”,<br/> “enabled”: true<br/>}</span></pre><p id="5517" class="pw-post-body-paragraph iw ix hi iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt hb bi translated">现在，当对以下 URL 进行多次调用时:</p><pre class="iq ir is it fd lr ls lt lu aw lv bi"><span id="e6ac" class="lw kj hi ls b fi lx ly l lz ma">curl — location — request GET ‘<a class="ae ll" href="http://localhost:8000/'" rel="noopener ugc nofollow" target="_blank">http://localhost:8000/'</a> \<br/> — header ‘Host: account-service’</span></pre><p id="8387" class="pw-post-body-paragraph iw ix hi iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt hb bi translated">Kong 网关抛出一个 429(请求太多)HTTP 响应，其有效负载如下:</p><pre class="iq ir is it fd lr ls lt lu aw lv bi"><span id="557e" class="lw kj hi ls b fi lx ly l lz ma">{<br/> “message”: “API rate limit exceeded”<br/>}</span></pre><p id="c522" class="pw-post-body-paragraph iw ix hi iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt hb bi translated">使用 Kong Gateway 的开源版本，可以按照上面提到的相同模式轻松添加以下插件:</p><ul class=""><li id="13cf" class="ju jv hi iy b iz ja jd je jh jw jl jx jp jy jt lm ka kb kc bi translated">基本和 JWT 身份验证</li><li id="3c33" class="ju jv hi iy b iz kd jd ke jh kf jl kg jp kh jt lm ka kb kc bi translated">CORS 和知识产权限制</li><li id="db46" class="ju jv hi iy b iz kd jd ke jh kf jl kg jp kh jt lm ka kb kc bi translated">ACL 和请求大小限制</li><li id="9b69" class="ju jv hi iy b iz kd jd ke jh kf jl kg jp kh jt lm ka kb kc bi translated">调用无服务器功能</li><li id="67fd" class="ju jv hi iy b iz kd jd ke jh kf jl kg jp kh jt lm ka kb kc bi translated">数据转换</li><li id="c7b3" class="ju jv hi iy b iz kd jd ke jh kf jl kg jp kh jt lm ka kb kc bi translated">多个日志记录选项</li></ul><h1 id="f04b" class="ki kj hi bd kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf bi translated">结论</h1><p id="0493" class="pw-post-body-paragraph iw ix hi iy b iz lg jb jc jd lh jf jg jh li jj jk jl lj jn jo jp lk jr js jt hb bi translated">如果我要为任何 IT 专业人士起草一份简明的使命陈述，那会非常简单:</p><blockquote class="mc md me"><p id="701e" class="iw ix mf iy b iz ja jb jc jd je jf jg mg ji jj jk mh jm jn jo mi jq jr js jt hb bi translated">将您的时间集中在提供扩展知识产权价值的特性/功能上。将框架、产品和服务用于其他一切。</p></blockquote><p id="dd84" class="pw-post-body-paragraph iw ix hi iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt hb bi translated">Kong 提供的产品和服务不仅避免了服务层的重复，而且在许多情况下，从功能开发人员的头脑中抽象出了公共组件。这种方法的结果允许一个精简的代码库，并关注于满足验收标准。</p><p id="c8ac" class="pw-post-body-paragraph iw ix hi iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt hb bi translated">Kong 自己也遵循相同的任务声明，允许来自 Kong Gateway 的方面作为 Kong Ingress 控制器产品中的插件来实现。因此，组件只需配置一次，就可以随处使用。</p><p id="02c6" class="pw-post-body-paragraph iw ix hi iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt hb bi translated">Kong 采用了一种平台无关的方法，允许遗留应用程序在短期或长期内使用相同的服务。因此，支持本出版物引言中提到的棘手问题变得不那么重要了。</p><p id="2e47" class="pw-post-body-paragraph iw ix hi iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt hb bi translated">祝你今天过得愉快！</p></div></div>    
</body>
</html>