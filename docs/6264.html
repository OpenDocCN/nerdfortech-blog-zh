<html>
<head>
<title>Lambda Event Filtering</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">λ事件过滤</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/lambda-event-filtering-397f98df2370?source=collection_archive---------1-----------------------#2022-01-26">https://medium.com/nerd-for-tech/lambda-event-filtering-397f98df2370?source=collection_archive---------1-----------------------#2022-01-26</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><figure class="hh hi ez fb hj hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es hg"><img src="../Images/e247ebced7e917ebc674760339656817.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fVnfTD39uIOocf-lRBcrvg.jpeg"/></div></div><figcaption class="hr hs et er es ht hu bd b be z dx translated">由<a class="ae hv" href="https://unsplash.com/s/photos/filter-net?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上<a class="ae hv" href="https://unsplash.com/@numoonchld?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Raghavendra Saralaya </a>拍摄的照片</figcaption></figure><div class=""/><p id="c6fd" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">选择你真正感兴趣的。</p><p id="0bc6" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如果没有事件过滤，每个事件/消息都会被发送给 lambda 使用。这导致 lambda 代码的实现效率低下且复杂，只能处理特定的事件(如插入和删除)。在 2021 re:Invent 上，AWS 宣布我们可以在为 SQS、Kinesis &amp; Dynmaodb 流创建事件源映射时过滤事件。发布后，事件源映射对象的架构图如下。</p><figure class="ju jv jw jx fd hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es jt"><img src="../Images/a443fd31a2b4ef26b57fc65ed8c73d7a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DQSF1fZnBRZ0iGZQ-EsNyg.png"/></div></div><figcaption class="hr hs et er es ht hu bd b be z dx translated">作者图片</figcaption></figure><p id="d4d0" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><em class="jy">在上图中，源系统(SQS、Kinesis 或 Dynamodb) &amp;目标 lambda 函数已被移除，仅聚焦于贴图对象。</em></p><p id="fdf6" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">从上图中，我们看到过滤器在批处理之前和轮询服务之后被应用。这有两个直接的意义:</p><ol class=""><li id="d445" class="jz ka hy ix b iy iz jc jd jg kb jk kc jo kd js ke kf kg kh bi translated">过滤器减少了将被批处理的事件数量。这意味着计入批处理的过滤事件减少了。</li><li id="af38" class="jz ka hy ix b iy ki jc kj jg kk jk kl jo km js ke kf kg kh bi translated">过滤器位于轮询服务之后，这意味着所有事件都是从源中读取的。在 SQS 的情况下，不匹配的事件/消息将被标记为已处理和已删除。所以他们迷路了。在 Kinesis 和 Dynamo 中，我们有持久的流，所以我们可以重放事件，或者可以有多个消费者和处理不匹配的事件。这意味着在 SQS 中使用事件过滤时，我们应该使用扇出模式，并且能够处理不匹配的事件。</li><li id="b115" class="jz ka hy ix b iy ki jc kj jg kk jk kl jo km js ke kf kg kh bi translated">因为过滤器是在轮询之后，这意味着我们为所有 get messages API 调用付费。所以这个成本没有减少。</li><li id="0201" class="jz ka hy ix b iy ki jc kj jg kk jk kl jo km js ke kf kg kh bi translated">由于发送给 lambda 的消息较少，处理时间会减少，因为我们不必实现过滤逻辑。</li><li id="f742" class="jz ka hy ix b iy ki jc kj jg kk jk kl jo km js ke kf kg kh bi translated">对复杂过滤器类型或更多过滤器规则应用过滤器会增加一些延迟。虽然 AWS 没有记录，但在大多数情况下，这是非常少的，但对于延迟敏感的应用程序，这需要在生产前进行基准测试。</li></ol><h2 id="9565" class="kn ko hy bd kp kq kr ks kt ku kv kw kx jg ky kz la jk lb lc ld jo le lf lg lh bi translated">过滤规则</h2><p id="70ce" class="pw-post-body-paragraph iv iw hy ix b iy li ja jb jc lj je jf jg lk ji jj jk ll jm jn jo lm jq jr js hb bi translated">在一个事件源映射上，我们最多可以有 5 个不同的规则。过滤器规则与事件桥规则相同。语法如下所示:</p><pre class="ju jv jw jx fd ln lo lp lq aw lr bi"><span id="44fe" class="kn ko hy lo b fi ls lt l lu lv">{<br/>  "Filters": [<br/>    {<br/>      "Pattern": <br/>        "&lt;STRING REPRESENTATION OF JSON&gt;"<br/>    }<br/>  ]<br/>}</span><span id="2ce0" class="kn ko hy lo b fi lw lt l lu lv"># EVENT PATTERN IN JOSN<br/>{ <br/>  "Metadata1": [ rule1 ], <br/>  "data": {<br/>    "Data1": [ rule2 ] <br/>    }<br/>  }<br/>}</span></pre><p id="096e" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">注意:为了可读性，我设置了过滤器的格式。如果使用 CDK，我们可以使用 JSON.dumps()方法。</p><h2 id="508b" class="kn ko hy bd kp kq kr ks kt ku kv kw kx jg ky kz la jk lb lc ld jo le lf lg lh bi translated">完整规则语法</h2><figure class="ju jv jw jx fd hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es lx"><img src="../Images/5fddc5c091933aab4f5b5c8e100f7f45.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hDP5kr9fU95ksEEI3yI0kA.png"/></div></div><figcaption class="hr hs et er es ht hu bd b be z dx translated">源 AWS 文档</figcaption></figure><p id="cb3a" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hz">注意:</strong> Lambda 评估传入消息<code class="du ly lz ma lo b">body</code>的格式以及我们针对<code class="du ly lz ma lo b">body</code>的过滤模式的格式。如果不匹配，Lambda 会丢弃消息。所以我们需要确保您的<code class="du ly lz ma lo b">FilterCriteria</code>中的<code class="du ly lz ma lo b">body</code>的格式与我们从您的 SQS 收到的消息中的<code class="du ly lz ma lo b">body</code>的预期格式相匹配。对于 Kinesis &amp; Dynamodb，我们需要确保过滤标准中的数据字段&amp;数据字段(data，Dynamodb)都是 JSON 格式</p><h2 id="145f" class="kn ko hy bd kp kq kr ks kt ku kv kw kx jg ky kz la jk lb lc ld jo le lf lg lh bi translated">配料复习</h2><p id="1278" class="pw-post-body-paragraph iv iw hy ix b iy li ja jb jc lj je jf jg lk ji jj jk ll jm jn jo lm jq jr js hb bi translated">通过批处理，我们可以增加每次调用传递给函数的平均记录数。这有助于减少调用次数和优化成本。如果应用批处理，当满足以下任一条件时，将调用 Lambda 函数:</p><ul class=""><li id="607b" class="jz ka hy ix b iy iz jc jd jg kb jk kc jo kd js mb kf kg kh bi translated">有效负载大小达到 6MB(Lambda 的最大有效负载)</li><li id="0792" class="jz ka hy ix b iy ki jc kj jg kk jk kl jo km js mb kf kg kh bi translated">批处理窗口达到其最大值</li><li id="2d6e" class="jz ka hy ix b iy ki jc kj jg kk jk kl jo km js mb kf kg kh bi translated">批次大小达到其最大值。</li></ul><p id="0555" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">对于 SQS 源代码，由于事件是作为一个整体批处理的，所以单个消息中的失败会将所有内容都视为失败。为了避免这种情况，我们可以报告哪个消息 id 失败了。为此，我们在 FunctionResponseTypes 中使用 ReportBatchItemFailures。然后在响应中，我们添加了以下内容:</p><pre class="ju jv jw jx fd ln lo lp lq aw lr bi"><span id="0eb8" class="kn ko hy lo b fi ls lt l lu lv">{<br/>    "batchItemFailures": [          <br/>        {             <br/>          "itemIdentifier": "id2"<br/>        },         <br/>        { <br/>          "itemIdentifier": "id4"<br/>        }     <br/>    ] <br/>}</span></pre><p id="caef" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">批中的消息数量还取决于以下配置:</p><blockquote class="mc md me"><p id="92c7" class="iv iw jy ix b iy iz ja jb jc jd je jf mf jh ji jj mg jl jm jn mh jp jq jr js hb bi translated">接收消息等待时间<br/>传递延迟(SQS) <br/>可见性超时<br/>Lambda 并发</p></blockquote><p id="5160" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">享受无服务器！！</p></div></div>    
</body>
</html>