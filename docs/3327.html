<html>
<head>
<title>Microservices (Part 2) — Best Practices</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">微服务(第 2 部分)——最佳实践</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/microservices-part-2-best-practices-4ac68eea0990?source=collection_archive---------13-----------------------#2021-06-06">https://medium.com/nerd-for-tech/microservices-part-2-best-practices-4ac68eea0990?source=collection_archive---------13-----------------------#2021-06-06</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/300701981292f6baceaab52eec52542f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xpVIyi0YaLFM09rcPaKwNg.jpeg"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">图 1:最佳实践(来源:Google)</figcaption></figure><p id="ef6d" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">为了成功实现微服务架构，开发人员需要遵循一套最佳实践。让我们来讨论一下这些最佳实践。</p><h1 id="2938" class="js jt hi bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">设计</h1><p id="8800" class="pw-post-body-paragraph iu iv hi iw b ix kq iz ja jb kr jd je jf ks jh ji jj kt jl jm jn ku jp jq jr hb bi translated">在实现微服务架构之前，对系统的边界进行建模是非常重要的。设计系统的开发人员必须对特定领域的流程和规则有非常清晰的理解。设计应该是一个<strong class="iw hj">领域驱动的设计</strong>。</p><p id="6068" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw hj">领域驱动设计</strong> -</p><p id="95c5" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><em class="kv">领域驱动设计是一种软件开发方法，它将开发集中在对领域模型的编程上，该模型对领域的过程和规则有丰富的理解。</em></p><p id="208e" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">—马丁·弗劳尔。</p><h1 id="f51b" class="js jt hi bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">硬编码值</h1><ul class=""><li id="f004" class="kw kx hi iw b ix kq jb kr jf ky jj kz jn la jr lb lc ld le bi translated">硬编码值是计算机程序中的固定参数，不修改程序就不能更改。</li></ul><p id="ef97" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">在微服务架构中，代码应该总是动态的。应用程序中运行的服务实例集是动态变化的。这些实例具有动态分配的网络位置。因此，主机名、URL 等不应该被硬编码，因为它们可以动态改变。</p><h1 id="0c3e" class="js jt hi bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">记录</h1><p id="751e" class="pw-post-body-paragraph iu iv hi iw b ix kq iz ja jb kr jd je jf ks jh ji jj kt jl jm jn ku jp jq jr hb bi translated">日志记录是软件开发过程的一个重要部分。在微服务架构中实现这个日志记录过程存在一些挑战。这是因为有许多服务，它们只通过定义明确的接口相互通信。因此，正常的测井程序将不适用。</p><p id="065e" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">假设应用程序有网络问题。开发人员可能会尝试查看日志并找出原因。但是日志文件夹可能包含来自不同服务的日志，因此很难识别正确的日志。</p><h2 id="888e" class="lf jt hi bd ju lg lh li jy lj lk ll kc jf lm ln kg jj lo lp kk jn lq lr ko ls bi translated"><strong class="ak">关联 ID </strong></h2><p id="ff1c" class="pw-post-body-paragraph iu iv hi iw b ix kq iz ja jb kr jd je jf ks jh ji jj kt jl jm jn ku jp jq jr hb bi translated">一种在微服务架构中实现日志记录的有效方法。相关 ID 也称为事务 ID，包含在每个消息中。关联 ID 取自发起事件，这个惟一的 ID 记录在每个调用服务中。因此，更容易找到信息的流向。</p><h2 id="e031" class="lf jt hi bd ju lg lh li jy lj lk ll kc jf lm ln kg jj lo lp kk jn lq lr ko ls bi translated"><strong class="ak">记录有价值的信息</strong></h2><p id="7cba" class="pw-post-body-paragraph iu iv hi iw b ix kq iz ja jb kr jd je jf ks jh ji jj kt jl jm jn ku jp jq jr hb bi translated">记录太多的信息会影响系统的性能。然而，记录太少的信息会使开发人员在出现 bug 时难以识别错误。因此，日志应该包含适量的信息，这些信息可能对其他人识别进程有潜在的价值。</p><h2 id="e043" class="lf jt hi bd ju lg lh li jy lj lk ll kc jf lm ln kg jj lo lp kk jn lq lr ko ls bi translated">时间</h2><p id="46c9" class="pw-post-body-paragraph iu iv hi iw b ix kq iz ja jb kr jd je jf ks jh ji jj kt jl jm jn ku jp jq jr hb bi translated">“时间戳”是日志的重要组成部分。微服务是分布式的，因此时间可能不会以正确的方式跨所有服务同步。在这种情况下，日志文件可能包含顺序不正确的时间戳。为了克服这个问题，有 Lamport、矢量时钟等技术。</p><h1 id="2434" class="js jt hi bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">微服务中的版本控制</h1><p id="7083" class="pw-post-body-paragraph iu iv hi iw b ix kq iz ja jb kr jd je jf ks jh ji jj kt jl jm jn ku jp jq jr hb bi translated">有两种执行版本控制的通用方法(不考虑架构)。</p><h2 id="9a14" class="lf jt hi bd ju lg lh li jy lj lk ll kc jf lm ln kg jj lo lp kk jn lq lr ko ls bi translated">1.语义版本控制</h2><p id="c75b" class="pw-post-body-paragraph iu iv hi iw b ix kq iz ja jb kr jd je jf ks jh ji jj kt jl jm jn ku jp jq jr hb bi translated">语义版本化使用<strong class="iw hj"> 3 个非负整数</strong>来表示一个版本。整数:</p><ul class=""><li id="d6dc" class="kw kx hi iw b ix iy jb jc jf lt jj lu jn lv jr lb lc ld le bi translated"><strong class="iw hj">主要:</strong>上一版本与当前版本不兼容时增加。</li><li id="e535" class="kw kx hi iw b ix lw jb lx jf ly jj lz jn ma jr lb lc ld le bi translated"><strong class="iw hj">次要:</strong>上一版本兼容当前版本时增加。</li><li id="cca4" class="kw kx hi iw b ix lw jb lx jf ly jj lz jn ma jr lb lc ld le bi translated">补丁:作为新版本一部分的一个 bug 修复。这个新版本也与以前的版本兼容。</li></ul><p id="aeb3" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">通常在应用程序包含许多不同模块时使用。</p><h2 id="99f4" class="lf jt hi bd ju lg lh li jy lj lk ll kc jf lm ln kg jj lo lp kk jn lq lr ko ls bi translated">2.日历版本控制</h2><p id="c8af" class="pw-post-body-paragraph iu iv hi iw b ix kq iz ja jb kr jd je jf ks jh ji jj kt jl jm jn ku jp jq jr hb bi translated">类似于语义版本控制，但是使用日历日期而不是非负整数。这些日期包含年、月和日的组合。通常在应用程序有时间限制时使用。这意味着支持和可用期是由持续时间驱动的，而不是由使用量驱动的。</p><blockquote class="mb mc md"><p id="3e7e" class="iu iv kv iw b ix iy iz ja jb jc jd je me jg jh ji mf jk jl jm mg jo jp jq jr hb bi translated"><strong class="iw hj"> <em class="hi">语义版本化更适合微服务架构。</em>T11】</strong></p></blockquote><p id="155b" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">有一些特定于微服务的特殊版本控制技术。</p><ul class=""><li id="a602" class="kw kx hi iw b ix iy jb jc jf lt jj lu jn lv jr lb lc ld le bi translated">基于 URL 的版本控制</li><li id="2f25" class="kw kx hi iw b ix lw jb lx jf ly jj lz jn ma jr lb lc ld le bi translated">标题驱动的版本控制。</li></ul><p id="fae6" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw hj">示例</strong></p><p id="a2b8" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw hj">假设:</strong>有两个服务，即服务“A”和服务“B”。“A”服务使用来自服务“B”的数据。开发人员升级服务“B ”,它改变了服务 B 的数据库结构。</p><p id="7733" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">如果开发人员部署这个新系统，服务“A”将会中断。这是因为服务“B”中的数据库结构发生了变化。</p><p id="6444" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw hj">那么我们能做什么呢？</strong></p><p id="593d" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">我们可以使用版本控制。我们可以创建两个版本，并要求用户升级到新版本。所有用户升级到新版本需要一些时间。两个版本都将启动并运行到那时。有许多部署框架可以高效地完成这一过程。</p><h1 id="64bb" class="js jt hi bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">微服务中的授权和认证</h1><p id="6966" class="pw-post-body-paragraph iu iv hi iw b ix kq iz ja jb kr jd je jf ks jh ji jj kt jl jm jn ku jp jq jr hb bi translated">微服务架构包含不同的服务。如果每个服务都试图验证用户，系统将会很慢并且效率低下。因此，身份验证和授权过程应该以不同的方式实现。</p><p id="f690" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">在微服务架构中，</p><ul class=""><li id="408f" class="kw kx hi iw b ix iy jb jc jf lt jj lu jn lv jr lb lc ld le bi translated">集中式服务用于执行这些过程。</li><li id="f152" class="kw kx hi iw b ix lw jb lx jf ly jj lz jn ma jr lb lc ld le bi translated">有 WS02 身份服务器、OAuth2orize 等解决方案可以实现这一点。</li></ul><p id="1d33" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">最好的方法是有一个单独的身份验证服务。</p><h1 id="81fa" class="js jt hi bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">依赖性管理</h1><p id="9d6e" class="pw-post-body-paragraph iu iv hi iw b ix kq iz ja jb kr jd je jf ks jh ji jj kt jl jm jn ku jp jq jr hb bi translated">微服务架构的主要原则是让每个服务独立运行。它们基本上被建模为孤立的单元。因此，这些服务中的每一个都应该可以独立部署，没有共享的依赖关系。</p><h1 id="2fda" class="js jt hi bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">签订可执行的合同</h1><p id="24a4" class="pw-post-body-paragraph iu iv hi iw b ix kq iz ja jb kr jd je jf ks jh ji jj kt jl jm jn ku jp jq jr hb bi translated">指客户和公司签订合同的过程。这份合同是可执行的。这个合同可能包括一组定义明确的测试。这些测试将在每个应用程序构建中执行。</p><h1 id="2b64" class="js jt hi bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">容错</h1><p id="1045" class="pw-post-body-paragraph iu iv hi iw b ix kq iz ja jb kr jd je jf ks jh ji jj kt jl jm jn ku jp jq jr hb bi translated">在任何给定的系统中，故障都是常见的。请考虑下表。</p><figure class="mi mj mk ml fd ij er es paragraph-image"><div class="er es mh"><img src="../Images/f1a77d8f7b49ada4c9480f97da397347.png" data-original-src="https://miro.medium.com/v2/resize:fit:1198/format:webp/1*XKIE7r_AdJbx_EEnVSk4OQ.png"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">图 2:每年的停机时间</figcaption></figure><p id="91fb" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">可用性为 99.999%的系统每年仍有 5 分 15 秒的停机时间。微服务架构包含多种服务。因此，这种停机时间通常要长得多。</p><p id="18ac" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw hj"> <em class="kv">微服务:快速失效、无声失效、回退</em> </strong></p><p id="5cc5" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw hj">可能的措施</strong></p><ul class=""><li id="28f7" class="kw kx hi iw b ix iy jb jc jf lt jj lu jn lv jr lb lc ld le bi translated">花费时间超过定义阈值的超时调用。</li><li id="7c95" class="kw kx hi iw b ix lw jb lx jf ly jj lz jn ma jr lb lc ld le bi translated">为每个依赖项维护一个线程池。</li><li id="a8ca" class="kw kx hi iw b ix lw jb lx jf ly jj lz jn ma jr lb lc ld le bi translated">使用断路器在给定时间内阻止对目标服务的所有请求。</li></ul><blockquote class="mb mc md"><p id="1a48" class="iu iv kv iw b ix iy iz ja jb jc jd je me jg jh ji mf jk jl jm mg jo jp jq jr hb bi translated">注意:接下来的文章将描述容错中使用的模式。</p></blockquote><h1 id="0511" class="js jt hi bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">证明文件</h1><p id="bccc" class="pw-post-body-paragraph iu iv hi iw b ix kq iz ja jb kr jd je jf ks jh ji jj kt jl jm jn ku jp jq jr hb bi translated">指清楚地解释软件或服务应该如何操作的文档。它可以有文字或插图。这个文档对于开发人员和其他人员清楚地理解特定的服务非常重要。Swagger 是一个流行的开源工具，有助于记录任何规模的 API。这可用于在微服务架构中执行文档编制。</p><p id="2a7a" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">本文的下一部分(第 3 部分)解释了可用于微服务架构的流行设计模式。</p><p id="1251" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">我使用了 Krishntha Dinesh 先生的以下播放列表来收集所需的信息。</p><figure class="mi mj mk ml fd ij"><div class="bz dy l di"><div class="mn mo l"/></div></figure></div><div class="ab cl mp mq gp mr" role="separator"><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu"/></div><div class="hb hc hd he hf"><h1 id="921c" class="js jt hi bd ju jv mw jx jy jz mx kb kc kd my kf kg kh mz kj kk kl na kn ko kp bi translated">参考</h1><div class="nb nc ez fb nd ne"><a href="https://dzone.com/articles/authentication-and-authorization-in-microservices" rel="noopener  ugc nofollow" target="_blank"><div class="nf ab dw"><div class="ng ab nh cl cj ni"><h2 class="bd hj fi z dy nj ea eb nk ed ef hh bi translated">微服务中的认证和授权- DZone 微服务</h2><div class="nl l"><h3 class="bd b fi z dy nj ea eb nk ed ef dx translated">微服务架构作为实施解决方案的首选架构，已经获得了很大的市场份额…</h3></div><div class="nm l"><p class="bd b fp z dy nj ea eb nk ed ef dx translated">dzone.com</p></div></div><div class="nn l"><div class="no l np nq nr nn ns io ne"/></div></div></a></div><div class="nb nc ez fb nd ne"><a href="https://stackify.com/microservice-logging/" rel="noopener  ugc nofollow" target="_blank"><div class="nf ab dw"><div class="ng ab nh cl cj ni"><h2 class="bd hj fi z dy nj ea eb nk ed ef hh bi translated">微服务日志记录:使分布式系统中的调试更容易</h2><div class="nl l"><h3 class="bd b fi z dy nj ea eb nk ed ef dx translated">在过去的几年中，软件设计和交付的主要发展之一是从…</h3></div><div class="nm l"><p class="bd b fp z dy nj ea eb nk ed ef dx translated">stackify.com</p></div></div><div class="nn l"><div class="nt l np nq nr nn ns io ne"/></div></div></a></div><div class="nb nc ez fb nd ne"><a href="https://martinfowler.com/bliki/DomainDrivenDesign.html" rel="noopener  ugc nofollow" target="_blank"><div class="nf ab dw"><div class="ng ab nh cl cj ni"><h2 class="bd hj fi z dy nj ea eb nk ed ef hh bi translated">bliki:域名驱动设计</h2><div class="nl l"><h3 class="bd b fi z dy nj ea eb nk ed ef dx translated">领域驱动设计是一种软件开发方法，它将开发集中在对领域模型编程上…</h3></div><div class="nm l"><p class="bd b fp z dy nj ea eb nk ed ef dx translated">martinfowler.com</p></div></div><div class="nn l"><div class="nu l np nq nr nn ns io ne"/></div></div></a></div></div></div>    
</body>
</html>