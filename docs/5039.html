<html>
<head>
<title>LeetCode Median of Two Sorted Arrays</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">两个排序数组的LeetCode中值</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/leetcode-median-of-two-sorted-arrays-9c1eb048c9fa?source=collection_archive---------6-----------------------#2021-08-22">https://medium.com/nerd-for-tech/leetcode-median-of-two-sorted-arrays-9c1eb048c9fa?source=collection_archive---------6-----------------------#2021-08-22</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><h1 id="4939" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">问题陈述</h1><p id="7ff9" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">分别给定两个大小为<strong class="jf hj"> m </strong>和<strong class="jf hj"> n </strong>的排序数组<strong class="jf hj"> nums1 </strong>和<strong class="jf hj"> nums2 </strong>，返回两个排序数组的中间值<strong class="jf hj">。</strong></p><p id="85f5" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">整体运行时间复杂度应该是<strong class="jf hj"> O(log (m+n)) </strong>。</p><p id="97cf" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">问题陈述摘自:<a class="ae kg" href="https://leetcode.com/problems/median-of-two-sorted-arrays" rel="noopener ugc nofollow" target="_blank">https://leetcode.com/problems/median-of-two-sorted-arrays</a></p><p id="3a83" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated"><strong class="jf hj">例1: </strong></p><pre class="kh ki kj kk fd kl km kn ko aw kp bi"><span id="2b40" class="kq ig hi km b fi kr ks l kt ku">Input: nums1 = [1, 3], nums2 = [2]<br/>Output: 2.00000<br/>Explanation: merged array = [1, 2, 3] and median is 2.</span></pre><p id="179e" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated"><strong class="jf hj">例2: </strong></p><pre class="kh ki kj kk fd kl km kn ko aw kp bi"><span id="f407" class="kq ig hi km b fi kr ks l kt ku">Input: nums1 = [1, 2], nums2 = [3, 4]<br/>Output: 2.50000<br/>Explanation: merged array = [1, 2, 3, 4] and median is (2 + 3) / 2 = 2.5.</span></pre><p id="482e" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated"><strong class="jf hj">例3: </strong></p><pre class="kh ki kj kk fd kl km kn ko aw kp bi"><span id="5730" class="kq ig hi km b fi kr ks l kt ku">Input: nums1 = [0, 0], nums2 = [0, 0]<br/>Output: 0.00000</span></pre><p id="0e6a" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated"><strong class="jf hj">例4: </strong></p><pre class="kh ki kj kk fd kl km kn ko aw kp bi"><span id="8103" class="kq ig hi km b fi kr ks l kt ku">Input: nums1 = [], nums2 = [1]<br/>Output: 1.00000</span></pre><p id="4b12" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated"><strong class="jf hj">例5: </strong></p><pre class="kh ki kj kk fd kl km kn ko aw kp bi"><span id="f20d" class="kq ig hi km b fi kr ks l kt ku">Input: nums1 = [2], nums2 = []<br/>Output: 2.00000</span></pre><p id="ff06" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated"><strong class="jf hj">约束:</strong></p><pre class="kh ki kj kk fd kl km kn ko aw kp bi"><span id="889e" class="kq ig hi km b fi kr ks l kt ku">- nums1.length == m<br/>- nums2.length == n<br/>- 0 &lt;= m &lt;= 1000<br/>- 0 &lt;= n &lt;= 1000<br/>- 1 &lt;= m + n &lt;= 2000<br/>- -10^6 &lt;= nums1[i], nums2[i] &lt;= 10^6</span></pre><h1 id="764a" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">说明</h1><h2 id="9126" class="kq ig hi bd ih kv kw kx il ky kz la ip jo lb lc it js ld le ix jw lf lg jb lh bi translated">强力解决方案</h2><p id="8dcc" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">最简单的线性解决方案是创建一个新数组。因为给定的数组是排序的，所以以有效的方式合并排序的数组。</p><p id="8ea6" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">一旦它们被合并</p><ol class=""><li id="9dc7" class="li lj hi jf b jg kb jk kc jo lk js ll jw lm ka ln lo lp lq bi translated">如果<strong class="jf hj"> m + n </strong>为奇数，则中值为新数组中的<strong class="jf hj"> (m + n)/2 </strong>索引。</li><li id="66b9" class="li lj hi jf b jg lr jk ls jo lt js lu jw lv ka ln lo lp lq bi translated">如果<strong class="jf hj"> m + n </strong>为偶数，则中值为索引<strong class="jf hj">((m+n)/2–1)</strong>和<strong class="jf hj"> (m+n)/2 </strong>处元素的平均值。</li></ol><p id="b985" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">一小段C++代码如下所示:</p><pre class="kh ki kj kk fd kl km kn ko aw kp bi"><span id="f21c" class="kq ig hi km b fi kr ks l kt ku">int i = 0; // index of input array ar1[]<br/>int j = 0; // index of input array ar2[]<br/>int count;<br/>int m1 = -1, m2 = -1;<br/><br/>if((m + n) % 2 == 1) {<br/>    for (count = 0; count &lt;= (n + m)/2; count++) {<br/>        if(i != n &amp;&amp; j != m)<br/>        {<br/>            m1 = (ar1[i] &gt; ar2[j]) ? ar2[j++] : ar1[i++];<br/>        }<br/>        else if(i &lt; n)<br/>        {<br/>            m1 = ar1[i++];<br/>        }<br/>        // for case when j&lt;m,<br/>        else<br/>        {<br/>            m1 = ar2[j++];<br/>        }<br/>    }<br/>    return m1;<br/>} else {<br/>    for (count = 0; count &lt;= (n + m)/2; count++) {<br/>        m2 = m1;<br/>        if(i != n &amp;&amp; j != m)<br/>        {<br/>            m1 = (ar1[i] &gt; ar2[j]) ? ar2[j++] : ar1[i++];<br/>        }<br/>        else if(i &lt; n)<br/>        {<br/>            m1 = ar1[i++];<br/>        }<br/>        // for case when j&lt;m,<br/>        else<br/>        {<br/>            m1 = ar2[j++];<br/>        }<br/>    }<br/>    return (m1 + m2)/2;<br/>}</span></pre><h2 id="bf60" class="kq ig hi bd ih kv kw kx il ky kz la ip jo lb lc it js ld le ix jw lf lg jb lh bi translated">二进位检索</h2><p id="124a" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">我们可以避免创建一个额外的大小为m + n的数组。由于这两个数组已经排序，我们可以使用二分搜索法来划分数组，并找到中间值。</p><h2 id="3d4f" class="kq ig hi bd ih kv kw kx il ky kz la ip jo lb lc it js ld le ix jw lf lg jb lh bi translated">算法</h2><pre class="kh ki kj kk fd kl km kn ko aw kp bi"><span id="f3e8" class="kq ig hi km b fi kr ks l kt ku">- initialize m = nums1.size, n = nums2.size<br/><br/>- if m &gt; n<br/>    call the algorithm for (nums2, nums1) sequence<br/><br/>- initialize starts = 0, ends = m, partitionX, partitionY,<br/>  maxLeftX, maxLeftY, minRightX, minRightY.<br/><br/>- loop while( starts &lt;= ends )<br/><br/>  - set partitionX = (starts + ends)/2<br/><br/>  - set partitionY = ((m + n + 1)/2 - partitionX)<br/><br/>  - set maxLeftX = partitionX == 0 ? INT_MIN : nums1[partitionX - 1]<br/>        minRightX = partitionX == m ? INT_MAX : nums1[partitionX]<br/><br/>  - set maxLeftY = partitionY == 0 ? INT_MIN : nums2[partitionY - 1]<br/>        minRightY = partitionY == n ? INT_MAX : nums2[partitionY]<br/><br/>  - if maxLeftX &lt;= minRightY &amp;&amp; maxLeftY &lt;= minRightX<br/>    // when the above case is satisfied,<br/>    // we need to find the median based on array size is even or odd<br/><br/>    - if (m + n) % 2 == 0<br/>      // if array size is even we need to add the max value from left side<br/>      // with min value from right side<br/>      - return (max(maxLeftX, maxLeftY) + min(minRightX, minRightY))/2<br/>    - else<br/>      // if array size is odd we return the max of the two array's left hand-side value.<br/>      - return max(maxLeftX, maxLeftY)<br/><br/>  - else if maxLeftX &gt; minRightY<br/><br/>    // means we have to decrease size of A's partition<br/>    - ends = partitionX - 1<br/><br/>  - else<br/><br/>    // means we have to set starts to A's partition + 1<br/>    - starts = partitionX + 1</span></pre><p id="1238" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated"><strong class="jf hj"> C++解决方案</strong></p><pre class="kh ki kj kk fd kl km kn ko aw kp bi"><span id="8868" class="kq ig hi km b fi kr ks l kt ku">class Solution {<br/>public:<br/>    double findMedianSortedArrays(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) {<br/>        int m = nums1.size();<br/>        int n = nums2.size();<br/><br/>        if(m &gt; n){<br/>            return findMedianSortedArrays(nums2, nums1);<br/>        }<br/><br/>        int starts = 0;<br/>        int ends = m;<br/>        int partitionX, partitionY;<br/>        int maxLeftX, maxLeftY;<br/>        int minRightX, minRightY;<br/><br/>        while(starts &lt;= ends){<br/>            partitionX = (starts + ends)/2;<br/>            partitionY = ((m + n + 1)/2 - partitionX);<br/><br/>            maxLeftX = partitionX == 0 ? INT_MIN : nums1[partitionX - 1];<br/>            minRightX = partitionX == m ? INT_MAX : nums1[partitionX];<br/><br/>            maxLeftY = partitionY == 0 ? INT_MIN : nums2[partitionY - 1];<br/>            minRightY = partitionY == n ? INT_MAX : nums2[partitionY];<br/><br/>            if(maxLeftX &lt;= minRightY &amp;&amp; maxLeftY &lt;= minRightX){<br/>                if((m+n)%2 == 0){<br/>                    return double(max(maxLeftX, maxLeftY) + min(minRightX, minRightY))/2;<br/>                } else {<br/>                    return double(max(maxLeftX, maxLeftY));<br/>                }<br/>            } else if (maxLeftX &gt; minRightY){<br/>                ends = partitionX - 1;<br/>            } else {<br/>                starts = partitionX + 1;<br/>            }<br/>        }<br/>    }<br/>};</span></pre><p id="20ce" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated"><strong class="jf hj">戈朗解决方案</strong></p><pre class="kh ki kj kk fd kl km kn ko aw kp bi"><span id="b982" class="kq ig hi km b fi kr ks l kt ku">var (<br/>    maxInt = int(^uint(0) &gt;&gt; 1)<br/>    minInt = -maxInt - 1<br/>)<br/><br/><br/>func findMedianSortedArrays(nums1 []int, nums2 []int) float64 {<br/>    m, n := len(nums1), len(nums2)<br/><br/>    if m &gt; n {<br/>        return findMedianSortedArrays(nums2, nums1)<br/>    }<br/><br/>    middle := (m + n + 1)/2<br/>    starts, ends := 0, m<br/>    var partitionX, partitionY, maxLeftX, maxLeftY, minRightX, minRightY int<br/><br/>    for starts &lt;= ends {<br/>        partitionX = (starts + ends)/2<br/>        partitionY = middle - partitionX<br/>        maxLeftX = maxLeft(partitionX, nums1)<br/>        maxLeftY = maxLeft(partitionY, nums2)<br/>        minRightX = minRight(partitionX, nums1)<br/>        minRightY = minRight(partitionY, nums2)<br/><br/>        if maxLeftX &lt;= minRightY &amp;&amp; maxLeftY &lt;= minRightX {<br/>            left := max(maxLeftX, maxLeftY)<br/>            if (m + n) % 2 != 0 {<br/>                return float64(left)<br/>            }<br/>            right := min(minRightX, minRightY)<br/>            return float64((left + right))/2.0<br/>        }<br/>        if maxLeftX &gt; minRightY {<br/>            ends = partitionX-1<br/>            continue<br/>        }<br/>        starts = partitionX+1<br/>        continue<br/>    }<br/><br/>    if n%2 != 0 {<br/>        return float64(nums2[n / 2])<br/>    }<br/>    return float64(nums2[n / 2] + nums2[n / 2 - 1])/2.0<br/>}<br/><br/>func max(a, b int) int {<br/>    if a &gt; b {<br/>        return a<br/>    }<br/>    return b<br/>}<br/><br/>func min(a, b int) int {<br/>    if a &lt; b {<br/>        return a<br/>    }<br/>    return b<br/>}<br/><br/>func maxLeft(position int, array []int) int {<br/>    if position-1 &lt; 0 || position-1 &gt;= len(array) {<br/>        return minInt<br/>    }<br/>    return array[position-1]<br/>}<br/><br/>func minRight(position int, array []int) int {<br/>    if position &lt; 0 || position &gt;= len(array) {<br/>        return maxInt<br/>    }<br/>    return array[position]<br/>}</span></pre><p id="e337" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated"><strong class="jf hj"> Javascript解决方案</strong></p><pre class="kh ki kj kk fd kl km kn ko aw kp bi"><span id="4ca8" class="kq ig hi km b fi kr ks l kt ku">var findMedianSortedArrays = function(nums1, nums2) {<br/>    if(nums1.length &gt; nums2.length) {<br/>        return findMedianSortedArrays(nums2, nums1);<br/>    }<br/><br/>    let m = nums1.length;<br/>    let n = nums2.length;<br/>    let starts = 0, ends = m;<br/><br/>    while(starts &lt;= ends) {<br/>        const partitionX = (starts + ends) &gt;&gt; 1;<br/>        const partitionY = ((m + n + 1) &gt;&gt; 1) - partitionX;<br/><br/>        const maxLeftX = partitionX == 0 ? Number.NEGATIVE_INFINITY : nums1[partitionX - 1]<br/>        const maxLeftY = partitionY == 0 ? Number.NEGATIVE_INFINITY : nums2[partitionY - 1]<br/><br/>        const minRightX = partitionX == nums1.length ? Number.POSITIVE_INFINITY : nums1[partitionX]<br/>        const minRightY = partitionY == nums2.length ? Number.POSITIVE_INFINITY : nums2[partitionY ]<br/><br/>        if(maxLeftX &lt;= minRightY &amp;&amp; maxLeftY &lt;= minRightX) {<br/>            const lowMax = Math.max(maxLeftX, maxLeftY);<br/>            if(( m + n ) % 2 == 1)<br/>                return lowMax;<br/>            return (lowMax + Math.min(minRightX, minRightY)) / 2;<br/>        } else if(maxLeftX &lt; minRightY) {<br/>            starts = partitionX + 1;<br/>        } else<br/>            ends = partitionX - 1;<br/>    }<br/>};</span></pre><p id="7836" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">让我们试运行一下我们的算法，看看解决方案是如何工作的。</p><pre class="kh ki kj kk fd kl km kn ko aw kp bi"><span id="5129" class="kq ig hi km b fi kr ks l kt ku">Input: nums1 = [1, 3], nums2 = [2]<br/><br/>Step 1: m = nums1.size()<br/>        m = 2<br/><br/>        n = nums2.size()<br/>        n = 1<br/><br/>Step 2: m &gt; n<br/>        2 &gt; 1<br/>        true<br/><br/>        return findMedianSortedArrays(nums2, nums1);<br/><br/>Step 3: m = num1.size()<br/>        m = 1<br/><br/>        n = nums2.size()<br/>        n = 2<br/><br/>Step 4: m &gt; n<br/>        1 &gt; 2<br/>        false<br/><br/>Step 5: starts = 0<br/>        ends = m<br/>        ends = 1<br/><br/>        declare partitionX, partitionY, maxLeftX, maxLeftY, minRightX, minRightY<br/><br/>Step 6: starts &lt;= ends<br/>        0 &lt;= 1<br/>        partitionX = (starts + ends)/2<br/>                   = (0 + 1)/2<br/>                   = 0<br/><br/>        partitionY = ((m + n + 1)/2 - partitionX)<br/>                   = (1 + 2 + 1)/2 - 0<br/>                   = 4/2<br/>                   = 2<br/><br/>        maxLeftX = partitionX == 0 ? INT_MIN : nums1[partitionX - 1]<br/>                 = 0 == 0<br/>                 = true<br/>                 = INT_MIN<br/><br/>        minRightX = partitionX == m ? INT_MAX : nums1[partitionX]<br/>                  = 0 == 1<br/>                  = false<br/>                  = nums1[0]<br/>                  = 2<br/><br/>        maxLeftY = partitionY == 0 ? INT_MIN : nums2[partitionY - 1]<br/>                 = 2 == 0<br/>                 = false<br/>                 = nums2[partitionY - 1]<br/>                 = nums2[2 - 1]<br/>                 = nums2[1]<br/>                 = 3<br/><br/>        minRightY = partitionY == n ? INT_MAX : nums2[partitionY]<br/>                  = 2 == 2<br/>                  = true<br/>                  = INT_MAX<br/><br/>        if maxLeftX &lt;= minRightY &amp;&amp; maxLeftY &lt;= minRightX<br/>           INT_MIN &lt;= INT_MAX &amp;&amp; 3 &lt;= 2<br/>           true &amp;&amp; false<br/><br/>        else if maxLeftX &gt; minRightY<br/>                INT_MIN &gt; INT_MAX<br/>                false<br/>        else<br/>            starts = partitionX + 1<br/>            starts = 0 + 1<br/>            starts = 1<br/><br/>Step 7: starts &lt;= ends<br/>        1 &lt;= 1<br/><br/>        partitionX = (starts + ends)/2<br/>                   = (1 + 1)/2<br/>                   = 1<br/><br/>        partitionY = ((m + n + 1)/2 - partitionX)<br/>                   = (1 + 2 + 1)/2 - 1<br/>                   = 4/2 - 1<br/>                   = 2 - 1<br/>                   = 1<br/><br/>        maxLeftX = partitionX == 0 ? INT_MIN : nums1[partitionX - 1]<br/>                 = 1 == 0<br/>                 = true<br/>                 = nums1[partitionX - 1]<br/>                 = nums1[1 - 1]<br/>                 = nums1[0]<br/>                 = 2<br/><br/>        minRightX = partitionX == m ? INT_MAX : nums1[partitionX]<br/>                  = 1 == 1<br/>                  = true<br/>                  = INT_MAX<br/><br/>        maxLeftY = partitionY == 0 ? INT_MIN : nums2[partitionY - 1]<br/>                 = 1 == 0<br/>                 = false<br/>                 =  nums2[partitionY - 1]<br/>                 = nums2[1 - 1]<br/>                 = nums2[0]<br/>                 = 1<br/><br/>        minRightY = partitionY == n ? INT_MAX : nums2[partitionY]<br/>                  = 1 == 2<br/>                  = false<br/>                  = nums2[partitionY]<br/>                  = nums2[1]<br/>                  = 3<br/><br/>        if maxLeftX &lt;= minRightY &amp;&amp; maxLeftY &lt;= minRightX<br/>           2 &lt;= 3 &amp;&amp; 1 &lt;= 3<br/>           true &amp;&amp; true<br/>           true<br/><br/>           (m + n) % 2 == 0<br/>           (2 + 1) % 2 == 0<br/>           3 % 2 == 0<br/>           1 == 0<br/>           false<br/><br/>           return double(max(maxLeftX, maxLeftY))<br/>                  double(max(2, 1))<br/>                  double(2)<br/><br/>So we return 2.0000.</span></pre></div><div class="ab cl lw lx gp ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="hb hc hd he hf"><p id="be4d" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated"><em class="md">原发布于</em><a class="ae kg" href="https://alkeshghorpade.me/post/leetcode-median-of-two-sorted-arrays" rel="noopener ugc nofollow" target="_blank"><em class="md">https://alkeshghorpade . me</em></a><em class="md">。</em></p></div></div>    
</body>
</html>