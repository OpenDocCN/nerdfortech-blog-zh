<html>
<head>
<title>Bloom filter: No means NO!, Yes means a Maybe.</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">布鲁姆滤镜:没有就是没有！，Yes 表示一个也许。</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/bloom-filter-no-means-no-yes-means-a-maybe-4223e5d4cdd5?source=collection_archive---------4-----------------------#2019-07-24">https://medium.com/nerd-for-tech/bloom-filter-no-means-no-yes-means-a-maybe-4223e5d4cdd5?source=collection_archive---------4-----------------------#2019-07-24</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="bcce" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">喜欢这个标题吗？</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es jd"><img src="../Images/5e323ebe9fbfc2d4bfb2259dbe820e07.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Ibg6pAXoNsjY1VSwyGwcZg.png"/></div></div></figure><p id="5e33" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我想不出比这更简单的方法来描述布隆过滤器的概率行为。用专业术语来说，<strong class="ih hj">布隆过滤器</strong>是一个</p><ul class=""><li id="8b95" class="jp jq hi ih b ii ij im in iq jr iu js iy jt jc ju jv jw jx bi translated">节省空间</li><li id="6020" class="jp jq hi ih b ii jy im jz iq ka iu kb iy kc jc ju jv jw jx bi translated">盖然论的</li><li id="338a" class="jp jq hi ih b ii jy im jz iq ka iu kb iy kc jc ju jv jw jx bi translated">集合成员检查</li><li id="aa06" class="jp jq hi ih b ii jy im jz iq ka iu kb iy kc jc ju jv jw jx bi translated">数据结构</li></ul><p id="be34" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们一个一个来。</p><p id="b0b8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">集合成员检查:</strong> Bloom filter 告诉我们一个项目是否在项目集合中。它在恒定的空间和时间 O(k)中这样做，其中 k 是散列函数的数目。它不需要存储整个集合本身。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es kd"><img src="../Images/3091382a821c1134c0ed19c72230fec0.png" data-original-src="https://miro.medium.com/v2/resize:fit:516/format:webp/1*CbxvgeshOI7CkCocVbvnaQ.jpeg"/></div></figure><p id="ac16" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">概率:</strong>它可能保证也可能不保证物品的存在。但是可以保证它不存在。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es ke"><img src="../Images/36ceb8ab383149b26b44b36055d3ac16.png" data-original-src="https://miro.medium.com/v2/resize:fit:786/format:webp/1*5r6aUyM2Zx_Qulm3-K0SCQ.png"/></div></figure><p id="c9d9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">稍后将详细介绍。</p><p id="83aa" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">节省空间:</strong>它本身不存储数据。它使用一个位数组来实现。例如，您可以用大约 40MB 的空间表示 1000 万条记录。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es kf"><img src="../Images/5362ffb3317a1b66e11e347223937936.png" data-original-src="https://miro.medium.com/v2/resize:fit:606/format:webp/1*ClaXEtCqWxYsCZahNYnxJw.png"/></div></figure><p id="d253" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">数据结构:</strong>我们都知道什么是数据结构。:)</p><p id="71c3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">布隆过滤器使用比特阵列，最初全部设置为零。布隆过滤器利用散列函数来设置位数组的位值。使用哈希函数，需要快速和独立，如<strong class="ih hj">杂音</strong>和<strong class="ih hj"> FNV </strong>。很多实现都有<strong class="ih hj"> MD5 </strong>，还有<strong class="ih hj"> HashMix </strong>函数。</p><p id="6821" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">当我们在布隆过滤器中添加一个密钥时，该密钥被多个函数散列，然后相应的输出值被用于将该位置的比特设置为 1。当我们检查一个密钥的存在时，我们再次散列该密钥并检查是否所有的位(由散列函数给出)都被设置为 1。如果任一位被设置为 0，则意味着该密钥不存在。</p><p id="02c3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们使用 murmur2 和 FNV 哈希函数快速浏览一下 Bloom filter，看看我们如何获得误报和漏报。我们创建一个 32 位数组，所有元素都设置为 0。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es kg"><img src="../Images/d792c516174a50442dbb63ed5bde2fe4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1322/format:webp/1*XrKBaPPf5GXO7KdpH7nOhw.png"/></div></figure><p id="df17" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们将字符串“amitsinghrathore”传递给 murmur2 和 FNV 函数，这两个函数在需要将位设置为 1 的地方生成索引。在这个例子中是 8，16。类似地，我们添加“amit ”,它返回索引 12 和 0。所以我们把这里的位设为 1。</p><p id="53da" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们又增加了一些值。</p><p id="c9ba" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">amitsinghrathore → [8，16]，amit → [12，0]，amitsingh → [1，31]，amitrathore → [4，13]，singh → [6，28]，rathore → [24，6]，amitkumar → [7，4])</p><p id="f5c2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们以下面的数组结束。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es kh"><img src="../Images/6e52cdde60face0a107e0cc1ee044062.png" data-original-src="https://miro.medium.com/v2/resize:fit:1312/format:webp/1*GN6lCFwqH4etVi7XVXa8ew.png"/></div></div></figure><p id="eef8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在，让我们看看如果我们寻找一个不存在的字符串会发生什么。</p><p id="de73" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">arathore → [15，19]如果我们查看数组中的[15]和[19]，我们会发现值[0，0]。因为我们在列表中得到一个零，所以 Bloom filter 可以有把握地说这个名字不存在。</p><p id="dd15" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们检查一下“阿古玛”。</p><p id="fa49" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">阿古玛→ [24，6]。在数组中，第 24 位和第 6 位都包含 1。[1，1]导致 bloom filter 说它可能存在，尽管我们从未添加这个键/名称。这叫做假阳性。这是由于哈希函数中的冲突造成的。</p><p id="1c82" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">布隆过滤器中的假阳性概率是，<strong class="ih hj">p</strong>=<strong class="ih hj">(1-(1–1/m)^kn)^k</strong>)。</p><p id="dd2f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">其中<strong class="ih hj"> n </strong>是存储在数组中的元素数量。<strong class="ih hj"> m </strong>是数组的大小，<strong class="ih hj"> k </strong>是使用的哈希函数的数量。</p><p id="5294" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">使用明确否的概念，许多应用程序使用布隆过滤器来检查不存在并减少磁盘读取开销。卡桑德拉就是这样一个例子。它使用一个 bloom filter 来检查是否需要扫描表(在磁盘上)。如果布隆过滤器说它找不到密钥，那么应用程序确定它不需要扫描表。这减少了磁盘扫描操作的开销。</p><p id="5c33" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">布隆过滤器存储器需求、散列函数的数量和假阳性概率相互依赖。</p><blockquote class="ki"><p id="0266" class="kj kk hi bd kl km kn ko kp kq kr jc dx translated"><strong class="ak"> <em class="ks"> m/n = -1.44 *log2(假阳性概率)</em> </strong></p></blockquote><p id="b804" class="pw-post-body-paragraph if ig hi ih b ii kt ik il im ku io ip iq kv is it iu kw iw ix iy kx ja jb jc hb bi translated">要尝试不同的组合，试试这个。</p><div class="ky kz ez fb la lb"><a href="https://hur.st/bloomfilter/" rel="noopener  ugc nofollow" target="_blank"><div class="lc ab dw"><div class="ld ab le cl cj lf"><h2 class="bd hj fi z dy lg ea eb lh ed ef hh bi translated">布隆过滤器计算器</h2><div class="li l"><h3 class="bd b fi z dy lg ea eb lh ed ef dx translated">计算你的布鲁姆过滤器的最佳大小，看看一个给定的过滤器可以容纳多少个项目，或者只是欣赏曲线…</h3></div><div class="lj l"><p class="bd b fp z dy lg ea eb lh ed ef dx translated">hur.st</p></div></div></div></a></div><p id="b12a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">链接:</p><div class="ky kz ez fb la lb"><a href="https://asecuritysite.com/encryption/bloom" rel="noopener  ugc nofollow" target="_blank"><div class="lc ab dw"><div class="ld ab le cl cj lf"><h2 class="bd hj fi z dy lg ea eb lh ed ef hh bi translated">布隆过滤器</h2><div class="li l"><h3 class="bd b fi z dy lg ea eb lh ed ef dx translated">布隆过滤器被用来创建一个关于一个项目是否在一个数据结构中的概率猜测，并且被创建…</h3></div><div class="lj l"><p class="bd b fp z dy lg ea eb lh ed ef dx translated">asecuritysite.com</p></div></div></div></a></div><div class="ky kz ez fb la lb"><a href="http://cassandra.apache.org/doc/latest/operating/bloom_filters.html" rel="noopener  ugc nofollow" target="_blank"><div class="lc ab dw"><div class="ld ab le cl cj lf"><h2 class="bd hj fi z dy lg ea eb lh ed ef hh bi translated">证明文件</h2><div class="li l"><h3 class="bd b fi z dy lg ea eb lh ed ef dx translated">当您需要可伸缩性和高可用性时，Apache Cassandra 数据库是正确的选择</h3></div><div class="lj l"><p class="bd b fp z dy lg ea eb lh ed ef dx translated">cassandra.apache.org</p></div></div></div></a></div><p id="b3dd" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Python 代码:</p><pre class="je jf jg jh fd lk ll lm ln aw lo bi"><span id="d8f4" class="lp lq hi ll b fi lr ls l lt lu">pip3 install bloom-filter</span><span id="f71c" class="lp lq hi ll b fi lv ls l lt lu">from bloom_filter import BloomFilter</span><span id="c9a2" class="lp lq hi ll b fi lv ls l lt lu">blm_fltr = BloomFilter(max_elements=1000, error_rate=0.1)<br/>assert "user1" in blm_fltr is False<br/>blm_fltr.add('user1')<br/>assert "user1" in blm_fltr is True<br/>blm_fltr.add('user2')</span></pre><h1 id="b573" class="lw lq hi bd lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms bi translated">供选择的</h1><h2 id="0353" class="lp lq hi bd lx mt mu mv mb mw mx my mf iq mz na mj iu nb nc mn iy nd ne mr nf bi translated">布谷鸟过滤器</h2><p id="7937" class="pw-post-body-paragraph if ig hi ih b ii ng ik il im nh io ip iq ni is it iu nj iw ix iy nk ja jb jc hb bi translated">Cuckoo 过滤器是一种类似的数据结构，支持快速集合成员检查。Cuckoo filter 提供删除、有限计数和有界误报概率，同时仍然保持类似的空间复杂度。它使用 cuckoo 散列来解决冲突，并维护一个紧凑的 cuckoo 散列表。</p><blockquote class="nl nm nn"><p id="a00f" class="if ig no ih b ii ij ik il im in io ip np ir is it nq iv iw ix nr iz ja jb jc hb bi translated">众所周知，布谷鸟在其他鸟类的巢中产卵，一旦卵孵化，幼鸟通常会将宿主的卵从巢中排出。Cuckoo 散列表在处理要插入到 Cuckoo 散列表中被占用的“桶”中的项目时采用了类似的行为。</p></blockquote><p id="ef6d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">布谷鸟过滤器可能会返回假阴性(删除后)。</p><h2 id="50c1" class="lp lq hi bd lx mt mu mv mb mw mx my mf iq mz na mj iu nb nc mn iy nd ne mr nf bi translated">超对数</h2><p id="1f2d" class="pw-post-body-paragraph if ig hi ih b ii ng ik il im nh io ip iq ni is it iu nj iw ix iy nk ja jb jc hb bi translated">超对数是一种概率基数估计算法。总之，这是通过从一组均匀分布的随机数中找到前导零的最大数量来实现的。如果随机数有 n 个最大前导零，则集合中的相异元素是<code class="du ns nt nu ll b">2^n</code>。这是非常高效的内存。</p><blockquote class="nl nm nn"><p id="065d" class="if ig no ih b ii ij ik il im in io ip np ir is it nq iv iw ix nr iz ja jb jc hb bi translated"><em class="hi">使用 1.5 kB 的内存，超对数算法能够以 2%的典型精度(标准误差)估计&gt; </em> <code class="du ns nt nu ll b"><em class="hi">10^9 </em></code> <em class="hi">的基数。</em></p></blockquote><p id="fbb8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><a class="ae nv" href="https://prestodb.io/" rel="noopener ugc nofollow" target="_blank">很快</a>，一个分布式 SQL 查询引擎使用 HyperLogLog 提供一个名为<code class="du ns nt nu ll b">APPROX_DISTINCT</code>的函数来近似计算不同元素的数量。</p><p id="bd74" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">希望这有所帮助。</p></div></div>    
</body>
</html>