<html>
<head>
<title>Thinking Recursively #2 in Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python中的递归思维#2</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/thinking-recursively-2-in-python-8d742bf2d79a?source=collection_archive---------6-----------------------#2021-08-19">https://medium.com/nerd-for-tech/thinking-recursively-2-in-python-8d742bf2d79a?source=collection_archive---------6-----------------------#2021-08-19</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="620e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这是我第二篇关于如何用python递归思考的文章。在我的<a class="ae jd" rel="noopener" href="/nerd-for-tech/thinking-recursively-1-with-python-ac48ae78201a">上一篇文章</a>中，我已经解决了一些基本的递归问题。在这篇文章中，我们将解决两个复杂的递归问题，这将改善你的递归思维方式。让我们直入主题吧。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es je"><img src="../Images/5f48adaea5cb76634efc8292cd034d1a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*toZYWzxITKOCNwBVI8KzsA.jpeg"/></div></div><figcaption class="jq jr et er es js jt bd b be z dx translated">照片由<a class="ae jd" href="https://unsplash.com/@groovelanddesigns?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Grooveland Designs </a>在<a class="ae jd" href="https://unsplash.com/s/photos/spiral?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><h2 id="74a7" class="ju jv hi bd jw jx jy jz ka kb kc kd ke iq kf kg kh iu ki kj kk iy kl km kn ko bi translated">之字形阵列</h2><p id="980b" class="pw-post-body-paragraph if ig hi ih b ii kp ik il im kq io ip iq kr is it iu ks iw ix iy kt ja jb jc hb bi translated">给定一个数组，判断元素是否呈锯齿形。锯齿形意味着奇数位置的元素应该比它们相邻的元素小(或大)。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es ku"><img src="../Images/21d5612bca45519c6426889521a3e326.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kD5w_AXFpYFIAoAFwizQ0g.png"/></div></div></figure><p id="6544" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果你仔细观察这个问题，我们的逻辑看起来是这样的</p><pre class="jf jg jh ji fd kv kw kx ky aw kz bi"><span id="0783" class="ju jv hi kw b fi la lb l lc ld">arr[0]<strong class="kw hj">&lt;</strong>arr[1]<strong class="kw hj">&gt;</strong>arr[2]<strong class="kw hj">&lt;</strong>arr[3]<strong class="kw hj">&gt;</strong>arr[4]….. (for low-high zig-zag array)<br/>DOWN -- UP -- DOWN -- UP -- DOWN -- ...</span></pre><figure class="jf jg jh ji fd jj"><div class="bz dy l di"><div class="le lf l"/></div></figure><pre class="jf jg jh ji fd kv kw kx ky aw kz bi"><span id="e248" class="ju jv hi kw b fi la lb l lc ld">def isZigZag(arr): <br/>    return isUpDown(arr) or isDownUp(arr)</span></pre><p id="192b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我选择<code class="du lg lh li kw b"><strong class="ih hj">logical or </strong></code>的原因是，如果它是一个<strong class="ih hj"> <em class="lj">高低</em> </strong>之字形数组或一个<strong class="ih hj"> <em class="lj">低高</em> </strong>之字形数组，那么它就是一个之字形数组。</p><p id="b291" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">输入:[1，5，2，4，1，6]</p><pre class="jf jg jh ji fd kv kw kx ky aw kz bi"><span id="00e4" class="ju jv hi kw b fi la lb l lc ld">isZigZag([1,5,2,4,1,6])<br/>= isUpDown([1,5,2,4,1,6]) or isDownUp([1,5,2,4,1,6])<br/>= <strong class="kw hj">False</strong> or isDownUp([1,5,2,4,1,6])<br/>= isDownUp([1,5,2,4,1,6])</span><span id="34f8" class="ju jv hi kw b fi lk lb l lc ld">=<strong class="kw hj">((1&lt;5) and isUpDown([5,2,4,1,6]))</strong> <br/>=(True and <strong class="kw hj">(5&gt;2 and isDownUp([2,4,1,6]))</strong><br/>=(True and (True and <strong class="kw hj">( 2&lt;4  and isUpDown([4,1,6])) </strong>)<strong class="kw hj"><br/></strong>=(True and (True and (True and <strong class="kw hj">(4&gt;1 and isDownUp([1,6]))</strong>))<br/>=(True and (True and (True and (True and <strong class="kw hj">(1&lt;6 and isUpDown([6]))))<br/></strong>=(True and (True and (True and (True and (True and <strong class="kw hj">True</strong>))))#basecase<br/>= <strong class="kw hj">True</strong></span></pre><p id="dd00" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们可以把上面两个函数结合起来，递归地写成，</p><figure class="jf jg jh ji fd jj"><div class="bz dy l di"><div class="le lf l"/></div></figure></div><div class="ab cl ll lm gp ln" role="separator"><span class="lo bw bk lp lq lr"/><span class="lo bw bk lp lq lr"/><span class="lo bw bk lp lq"/></div><div class="hb hc hd he hf"><h2 id="0250" class="ju jv hi bd jw jx jy jz ka kb kc kd ke iq kf kg kh iu ki kj kk iy kl km kn ko bi translated">列表的置换</h2><p id="4327" class="pw-post-body-paragraph if ig hi ih b ii kp ik il im kq io ip iq kr is it iu ks iw ix iy kt ja jb jc hb bi translated">我将告诉你，我们如何能够达到一个纯粹的递归方式找到一个列表的排列(没有回溯)。这个方法并不乐观，但它确实让你理解了递归。</p><p id="7de4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">给定一个名单{arr₀，arr₁,….arrₙ}.我们可以找到列表的排列</p><ol class=""><li id="f904" class="ls lt hi ih b ii ij im in iq lu iu lv iy lw jc lx ly lz ma bi translated">如果我们有从{arr₁,….开始的列表排列arrₙ}</li><li id="533b" class="ls lt hi ih b ii mb im mc iq md iu me iy mf jc lx ly lz ma bi translated">然后，我们在步骤1中得到的每个置换子数组的所有位置插入<code class="du lg lh li kw b">arr₀</code>。为了更好地理解，</li></ol><p id="dd7d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">考虑列表[1，2，3]</p><pre class="jf jg jh ji fd kv kw kx ky aw kz bi"><span id="b8ec" class="ju jv hi kw b fi la lb l lc ld">Step 1: Find the permutation of [2,3]. It is<strong class="kw hj"> [ [2,3], [3,2] ]<br/></strong>Step 2: Insert 1 at all the positions of each of the permutation sub-arrays.  </span><span id="4f5d" class="ju jv hi kw b fi lk lb l lc ld">Permutation[0] = [2,3]   //<strong class="kw hj">first sub-array</strong> of permutation([2,3])<br/>Insert 1 at index 0 =  [1,2,3]<br/>Insert 1 at index 1 =  [2,1,3]<br/>Insert 1 at index 2 =  [2,3,1]</span><span id="3009" class="ju jv hi kw b fi lk lb l lc ld">#############################################</span><span id="7f52" class="ju jv hi kw b fi lk lb l lc ld">Permutation[1] = [3,2]   //<strong class="kw hj">second sub-array </strong><br/>Insert 1 at index 0 =  [1,3,2]<br/>Insert 1 at index 1 =  [3,1,2]<br/>Insert 1 at index 2 =  [3,2,1]</span></pre><p id="c442" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这就是我们如何递归地推导出一个列表的排列。</p><p id="fc43" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">首先，让我们编写一个函数interleave()，它只执行<strong class="ih hj">步骤2。</strong></p><figure class="jf jg jh ji fd jj"><div class="bz dy l di"><div class="le lf l"/></div></figure><p id="ef01" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">考虑输入:<code class="du lg lh li kw b">arr = <strong class="ih hj">[2,3,4]</strong>, elementTobeInserted = 1</code></p><p id="9bb1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">下面是调用栈的样子，(你一定会理解下面的解释😊)</p><blockquote class="mg mh mi"><p id="397d" class="if ig lj ih b ii ij ik il im in io ip mj ir is it mk iv iw ix ml iz ja jb jc hb bi translated">下面的缩进表示<strong class="ih hj">新的调用堆栈</strong></p></blockquote><pre class="jf jg jh ji fd kv kw kx ky aw kz bi"><span id="30b0" class="ju jv hi kw b fi la lb l lc ld"><br/>&gt;&gt;interleave(1,[2,3,4])<br/>1.  res = [1,2,3,4]  #line 12, the possibility that we know for sure<br/>    head = 2<br/>    tail = [3,4]<br/>    #line 14 =&gt; <strong class="kw hj">interleave(elementToBeInserted,tail)</strong> <br/>                <strong class="kw hj">interleave(1, [3,4] )</strong> will be called<br/>                res = [1,3,4]<br/>                head = 3<br/>                tail = [4]<br/>                #line 14 =&gt; <strong class="kw hj">interleave(1,[4])</strong><br/>                            res = [1,4] <br/>                            head = 4<br/>                            tail =[]<br/>                            #line 14 =&gt; interleave(1,[])<br/>                                        <strong class="kw hj">returns [[1]] #base-case</strong></span><span id="a325" class="ju jv hi kw b fi lk lb l lc ld"><strong class="kw hj">                            </strong>otherPossiblitiesArr = [[1]]<br/>                            add 4(head) to the front =&gt; [[<strong class="kw hj">4</strong>,1]]<strong class="kw hj"><br/>                            returns </strong>[<strong class="kw hj">[1,4],</strong>[4,1]]<strong class="kw hj"> </strong></span><span id="5194" class="ju jv hi kw b fi lk lb l lc ld">                otherPossiblitiesArr= [[1,4],[4,1]]<br/>                Add 3(head) to the front =&gt; [[<strong class="kw hj">3</strong>,1,4],[<strong class="kw hj">3</strong>,4,1]]<br/>                returns [<strong class="kw hj">[1,3,4]</strong>,[3,1,4],[3,4,1]]<br/>              </span><span id="32e8" class="ju jv hi kw b fi lk lb l lc ld">   otherPossiblitiesArr = [<strong class="kw hj">[1,3,4]</strong>,[3,1,4],[3,4,1]]<br/>   add 2(head) to the front =&gt; [[<strong class="kw hj">2</strong>,1,3,4],[<strong class="kw hj">2</strong>,3,1,4],[<strong class="kw hj">2</strong>,3,4,1]]<br/>   returns [<strong class="kw hj">[1,2,3,4]</strong>,[2,1,3,4],[2,3,1,4],[2,3,4,1]]</span></pre><p id="2a33" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我希望看到调用栈能清楚地告诉你函数是如何工作的。让我们编写置换函数，它将使用上面的<code class="du lg lh li kw b">interleave()</code>函数来推导给定列表的所有置换。</p><figure class="jf jg jh ji fd jj"><div class="bz dy l di"><div class="le lf l"/></div></figure><pre class="jf jg jh ji fd kv kw kx ky aw kz bi"><span id="ad71" class="ju jv hi kw b fi la lb l lc ld">&gt;&gt;&gt;permutation([1,2,3,4])<br/>#call stack<br/>&gt;&gt; head = 1<br/>   tail = [2,3,4]<br/>   tailPerm = permutation([2,3,4])<br/>            &gt;&gt;head = [2]<br/>              tail = [3,4]<br/>              tailPerm = permutation([3,4])<br/>                       &gt;&gt;head = 3<br/>                         tail = [4]<br/>                         tailPerm = permutation([4])<br/>                                    returns <strong class="kw hj">[[4]]</strong> #base-case<br/>                         <br/>                         <em class="lj">loop 1:</em> interleave(3,[4]) = [[3,4],[4,3]]<br/>                         returns <strong class="kw hj">[[3,4],[4,3]]</strong><br/>              <br/>              <em class="lj">loop 1: </em>interleave(2,[3,4])= [[2,3,4],[3,2,4],[3,4,2]]<br/>              <em class="lj">loop 2: </em>interleave(2,[4,3])= [[2,4,3],[4,2,3],[4,3,2]]<br/>              returns <strong class="kw hj">[[2,3,4],[3,2,4],[3,4,2],<br/>                       [2,4,3],[4,2,3],[4,3,2]]</strong><br/>   <br/>   <em class="lj">loop 1:</em>interleave(1,[2,3,4]) = [[1,2,3,4],[2,1,3,4],[2,3,1,4],[2,3,4,1]]<br/>   .....<br/>   <em class="lj">loop 6:</em> interleave(1,[4,3,2]) = [[1,4,3,2],[4,1,3,2],[4,3,1,2],[4,3,2,1]]</span><span id="8c52" class="ju jv hi kw b fi lk lb l lc ld">   returns <strong class="kw hj">[[1,2,3,4],[2,1,3,4],[2,3,1,4],[2,3,4,1],.....,[4,3,2,1]]</strong></span></pre><p id="2f8f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">你可以看到它有多优雅🦄解决方案是，这都是关于理解子问题。一旦你不把每个问题看成一个整体，而是看成一堆子问题，递归思考就很容易了。</p></div><div class="ab cl ll lm gp ln" role="separator"><span class="lo bw bk lp lq lr"/><span class="lo bw bk lp lq lr"/><span class="lo bw bk lp lq"/></div><div class="hb hc hd he hf"><p id="cc20" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我希望你喜欢这篇文章并理解递归函数的工作原理。如果你真的喜欢这类递归函数，我强烈建议你学习一门函数式编程语言(<a class="ae jd" href="https://www.youtube.com/watch?v=EfmyKgYjNP8&amp;list=PL3pGy4HtqwD2-bYXI3_4LWQyafXp4-olc" rel="noopener ugc nofollow" target="_blank"> Haskell </a>可能是个不错的起点)。</p><p id="111d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">谢谢🙏为了阅读。拍手声👏如果你喜欢这篇文章。我将在接下来的文章中写更多关于递归函数的内容。</p></div></div>    
</body>
</html>