<html>
<head>
<title>Game Over! It- Time to try again!</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">游戏结束！是时候再试一次了！</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/game-over-time-to-try-again-d0779507d56b?source=collection_archive---------20-----------------------#2021-04-25">https://medium.com/nerd-for-tech/game-over-time-to-try-again-d0779507d56b?source=collection_archive---------20-----------------------#2021-04-25</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="2539" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">离开生活？重播继续乐趣！</h2></div><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ix"><img src="../Images/779e53eb324ec82420f71fb94503a140.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*scv4ZePrPIqF-hANIsAAFw.jpeg"/></div></div></figure><p id="cd53" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">现在每个游戏都有某种形式的屏幕游戏。已经没有生命了？没有在期限内实现主要目标？没子弹了，不能再保护自己了？这种情况通常会导致屏幕上的游戏，或者至少是游戏的行为。至于太空射手，当你没有生命的时候，你会在屏幕上面对游戏。</p><p id="255a" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">让我们把这件事做完！</p></div><div class="ab cl kf kg gp kh" role="separator"><span class="ki bw bk kj kk kl"/><span class="ki bw bk kj kk kl"/><span class="ki bw bk kj kk"/></div><div class="hb hc hd he hf"><p id="3cfe" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated"><strong class="jl hj">准备编码<br/> </strong>在我们开始实现这里的逻辑之前，我们需要一些文本框来写入文本。</p><ul class=""><li id="5766" class="km kn hi jl b jm jn jp jq js ko jw kp ka kq ke kr ks kt ku bi translated"><em class="kv"> (2x)右击画布&gt; UI &gt;文本</em></li><li id="446b" class="km kn hi jl b jm kw jp kx js ky jw kz ka la ke kr ks kt ku bi translated">重命名游戏对象，以明确它是哪个文本框。我们需要一个文本框说“游戏结束”和一个告诉玩家如何重新开始游戏。</li><li id="5c94" class="km kn hi jl b jm kw jp kx js ky jw kz ka la ke kr ks kt ku bi translated">将文本更改为“游戏结束”和“按‘R’重新开始！”</li><li id="df40" class="km kn hi jl b jm kw jp kx js ky jw kz ka la ke kr ks kt ku bi translated">默认文本非常小。改变尺寸让它看起来更吸引人！<br/> <em class="kv">我对游戏结束使用了80号字体，重启文本使用了28号字体</em></li><li id="368a" class="km kn hi jl b jm kw jp kx js ky jw kz ka la ke kr ks kt ku bi translated">你可能已经注意到文本似乎已经消失了。这是因为文本比文本框区域大。我们可以做两件事:<br/> - (1)使用矩形工具(‘T’键作为快捷键)缩放文本框，使文本适合<br/> - (2)将<em class="kv">水平溢出</em>和<em class="kv">垂直溢出</em> <em class="kv">改为“溢出”</em></li><li id="02f4" class="km kn hi jl b jm kw jp kx js ky jw kz ka la ke kr ks kt ku bi translated">将文本放在您认为合适的位置。</li><li id="d0fc" class="km kn hi jl b jm kw jp kx js ky jw kz ka la ke kr ks kt ku bi translated">如果需要，根据自己的喜好调整颜色和字体</li></ul><p id="e563" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">完成后，你的游戏视图可以是这样的:</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es lb"><img src="../Images/43d82f39cca08d63fb55a8d6afd2e23e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wMvU4dQ5SSkq5-iLZuP52Q.png"/></div></div></figure></div><div class="ab cl kf kg gp kh" role="separator"><span class="ki bw bk kj kk kl"/><span class="ki bw bk kj kk kl"/><span class="ki bw bk kj kk"/></div><div class="hb hc hd he hf"><p id="e073" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated"><strong class="jl hj">编码闪烁行为<br/> </strong>现在是有趣的部分，通过代码给这些文本框一些行为！</p><p id="e8de" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">我们像往常一样开始，我们需要两个类型为<em class="kv">文本的变量。由于我们将所有与用户界面相关的东西都存储到了用户界面管理器中，我们也将把这些句柄放在<em class="kv">用户界面管理器. cs </em>脚本中:</em></p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es lc"><img src="../Images/f658feafb1374dab548239f9ac48efad.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JdzjVKTkxWjlFl6DfbSWZg.png"/></div></div></figure><p id="bff0" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">那么，我们想拿它们怎么办呢？我们想要创建一个闪烁的效果。有多种方法可以实现这样的闪烁效果，但是为了简单起见，让我们只改变显示的文本！</p><ul class=""><li id="6029" class="km kn hi jl b jm jn jp jq js ko jw kp ka kq ke kr ks kt ku bi translated">一个闪烁效果是<em class="kv">重复</em>。因此，我们需要在指定的时间后更改时间。一个<em class="kv">协程</em>非常适合这个工作！</li><li id="0812" class="km kn hi jl b jm kw jp kx js ky jw kz ka la ke kr ks kt ku bi translated">我们不知道玩家会看到这个屏幕多久，也不知道何时会触发重播。因此，我们需要一个<em class="kv">无休止的while循环</em>。</li><li id="e69b" class="km kn hi jl b jm kw jp kx js ky jw kz ka la ke kr ks kt ku bi translated">在这个循环中，我们需要改变显示的文本。</li></ul><p id="de56" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">这将是我们刚刚写下的逻辑:</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ld"><img src="../Images/14bc6e4496752b67acd9820288d5c701.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*azT5SfHeu7GtZ8EekUD7Pg.png"/></div></div></figure></div><div class="ab cl kf kg gp kh" role="separator"><span class="ki bw bk kj kk kl"/><span class="ki bw bk kj kk kl"/><span class="ki bw bk kj kk"/></div><div class="hb hc hd he hf"><p id="dcd9" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated"><strong class="jl hj">调用方法<br/></strong></p><ul class=""><li id="816d" class="km kn hi jl b jm jn jp jq js ko jw kp ka kq ke kr ks kt ku bi translated">玩家还剩0条命</li><li id="91be" class="km kn hi jl b jm kw jp kx js ky jw kz ka la ke kr ks kt ku bi translated">这将导致调用该方法</li></ul><p id="27c3" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">还记得我们创建的将当前玩家的生活形象化为精灵的switch语句吗？我们省略了<em class="kv">案例0 </em>部分。现在是时候填写并调用协程了！</p><ul class=""><li id="aa44" class="km kn hi jl b jm jn jp jq js ko jw kp ka kq ke kr ks kt ku bi translated">我们只需要启用两个文本框，然后让它们闪烁</li></ul><p id="6dda" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">在<em class="kv"> UpdateLives([…]) </em>方法中，将这些行添加到案例0中:</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es le"><img src="../Images/ae64ccaf0dbfa8ec75acdfed45057949.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IDxx-AerAeI7H-GF3yruJw.png"/></div></div></figure></div><div class="ab cl kf kg gp kh" role="separator"><span class="ki bw bk kj kk kl"/><span class="ki bw bk kj kk kl"/><span class="ki bw bk kj kk"/></div><div class="hb hc hd he hf"><p id="c1e8" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated"><strong class="jl hj">重启时禁用GameOver消息<br/> </strong>文本框现在在闪烁。然而，当我们重启游戏时，文本框并没有消失。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es lb"><img src="../Images/4a240cebfcf33a9f98948ef156a1f952.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*1-n6SW-_l-iYJ4JbEoPVIQ.gif"/></div></div></figure><p id="d468" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">这很容易解决。我们只需要在游戏一开始就禁用这两个游戏对象。让我们为此创建一个新方法，并在<em class="kv"> void Start(): </em>中调用它</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es lf"><img src="../Images/004a81dcd95d26932b62d2812df43f7a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rbQAg85Dtom7Dj0gIkJmwg.png"/></div></div></figure><p id="186e" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">现在我们有了预期的行为:</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es lb"><img src="../Images/70fe609c9ca960c7ad6d966bbd21f9bb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*OtfLDQ6rQbI0J6bhQKXE4Q.gif"/></div></div></figure></div><div class="ab cl kf kg gp kh" role="separator"><span class="ki bw bk kj kk kl"/><span class="ki bw bk kj kk kl"/><span class="ki bw bk kj kk"/></div><div class="hb hc hd he hf"><p id="9a75" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated"><strong class="jl hj">重启的能力<br/> </strong>玩家不会有Unity编辑器简单的重启游戏。我们需要为此创建一些逻辑！</p><ul class=""><li id="3c24" class="km kn hi jl b jm jn jp jq js ko jw kp ka kq ke kr ks kt ku bi translated">如果玩家处于游戏结束状态并按下R键，游戏应该重新载入</li><li id="a92a" class="km kn hi jl b jm kw jp kx js ky jw kz ka la ke kr ks kt ku bi translated">如果玩家不在游戏结束状态，按R键没有任何作用</li></ul><p id="b116" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">为了检查当前状态，我们应该创建一个bool变量。但是，我们将创建一个新的<em class="kv">游戏管理器</em>脚本，而不是将它放入UIManager脚本中，我们将在任何想要使用场景管理的时候使用它。</p><ul class=""><li id="565c" class="km kn hi jl b jm jn jp jq js ko jw kp ka kq ke kr ks kt ku bi translated">创建新的<em class="kv">游戏管理器</em>游戏对象</li><li id="3db5" class="km kn hi jl b jm kw jp kx js ky jw kz ka la ke kr ks kt ku bi translated">创建一个名为<em class="kv">游戏管理器</em>的新脚本</li><li id="a316" class="km kn hi jl b jm kw jp kx js ky jw kz ka la ke kr ks kt ku bi translated">将刚刚创建的脚本附加到游戏管理器游戏对象上</li><li id="6306" class="km kn hi jl b jm kw jp kx js ky jw kz ka la ke kr ks kt ku bi translated">打开脚本</li></ul><p id="9641" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">我们想要检查玩家是否已经结束游戏。这很容易用一个布尔值来完成！此外，游戏结束序列存储在UI管理器中。因此，我们需要一个UI管理器脚本的句柄。</p><ul class=""><li id="9d8b" class="km kn hi jl b jm jn jp jq js ko jw kp ka kq ke kr ks kt ku bi translated">创建一个bool来检查游戏结束状态</li><li id="b5fb" class="km kn hi jl b jm kw jp kx js ky jw kz ka la ke kr ks kt ku bi translated">创建UIManager脚本的句柄</li></ul><p id="dd6a" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">完成后，脚本的变量部分可以如下所示:</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es lg"><img src="../Images/fb8b0601ec7c2ea62bb58edc326e47ce.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/1*JMa9iq76lU6eVu2poCIPng.png"/></div></figure></div><div class="ab cl kf kg gp kh" role="separator"><span class="ki bw bk kj kk kl"/><span class="ki bw bk kj kk kl"/><span class="ki bw bk kj kk"/></div><div class="hb hc hd he hf"><p id="b8c2" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated"><strong class="jl hj">创建实际逻辑<br/> </strong>照常开始。</p><ul class=""><li id="fed7" class="km kn hi jl b jm jn jp jq js ko jw kp ka kq ke kr ks kt ku bi translated">创建UIManager的句柄</li><li id="51d9" class="km kn hi jl b jm kw jp kx js ky jw kz ka la ke kr ks kt ku bi translated">空-检查句柄！</li></ul><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es lh"><img src="../Images/40693564790a9f43edae2fc07bcaef7f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LsUkTVdXFyx6PK9L6Vu4qw.png"/></div></div></figure><p id="c14e" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">现在是重启逻辑的时候了！<br/> <em class="kv">如果玩家按下R键并处于游戏结束状态，则重新载入场景</em></p><p id="47ec" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">将它分解成小块，我们需要检查以下内容:</p><ul class=""><li id="177b" class="km kn hi jl b jm jn jp jq js ko jw kp ka kq ke kr ks kt ku bi translated">查看州立大学的比赛</li><li id="cf4d" class="km kn hi jl b jm kw jp kx js ky jw kz ka la ke kr ks kt ku bi translated">检查是否按下了键盘上的R键。<br/> <em class="kv">记住一个按键随时可能发生！</em></li><li id="2dcb" class="km kn hi jl b jm kw jp kx js ky jw kz ka la ke kr ks kt ku bi translated">如果两者都适用，请重新加载场景</li></ul><p id="1a99" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">我们检查两个必须满足的条件。否则，我们不想检查R键上的输入。if语句的完美用法！</p><blockquote class="li lj lk"><p id="bf20" class="jj jk kv jl b jm jn ij jo jp jq im jr ll jt ju jv lm jx jy jz ln kb kc kd ke hb bi translated">如果你想乱搞场景，Unity有个方法叫<em class="hi">scene management</em>integrated。为了能够使用这种方法，您需要集成<em class="hi"> UnityEngine。脚本顶部的场景管理库。</em></p></blockquote><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es lo"><img src="../Images/380947edb1dc52391d17e39bc88de9cc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5p0pdq_4WRvsIlL4l-gF8A.png"/></div></div></figure></div><div class="ab cl kf kg gp kh" role="separator"><span class="ki bw bk kj kk kl"/><span class="ki bw bk kj kk kl"/><span class="ki bw bk kj kk"/></div><div class="hb hc hd he hf"><p id="4646" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">最后，我们需要最后一个小方法来让玩家重新开始游戏。因为我们想从<em class="kv"> UIManager.cs </em>脚本中调用它，所以我们需要使它成为一个公共方法。</p><p id="147a" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">目的很简单。将bool设置为true。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es lg"><img src="../Images/0793b002d11ed21b783dbd4de4b8da6b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/1*yEVSCNt4xnU8xDgkLDa6ow.png"/></div></figure><p id="bcfd" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">这就是我们所需要的！</p></div><div class="ab cl kf kg gp kh" role="separator"><span class="ki bw bk kj kk kl"/><span class="ki bw bk kj kk kl"/><span class="ki bw bk kj kk"/></div><div class="hb hc hd he hf"><p id="dcdc" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated"><strong class="jl hj">最后的小细节让它按预期工作<br/> </strong>我们想在玩家没有生命的时候调用这个方法。剩余生命的检查在<em class="kv"> UIManager.cs </em>脚本中。</p><ul class=""><li id="bdac" class="km kn hi jl b jm jn jp jq js ko jw kp ka kq ke kr ks kt ku bi translated">打开UIManager脚本</li><li id="0e52" class="km kn hi jl b jm kw jp kx js ky jw kz ka la ke kr ks kt ku bi translated">搜索UpdateLives([…])方法</li><li id="3914" class="km kn hi jl b jm kw jp kx js ky jw kz ka la ke kr ks kt ku bi translated">在switch语句内部，点击<em class="kv"> case 0 </em></li><li id="4446" class="km kn hi jl b jm kw jp kx js ky jw kz ka la ke kr ks kt ku bi translated">在游戏管理器上调用刚刚创建的<em class="kv"> GameOver() </em>方法。</li></ul><p id="b9d1" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">您可能已经注意到您将收到一个错误。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es lp"><img src="../Images/3204d5ce391eeb5eed73ed2df8a2ec9f.png" data-original-src="https://miro.medium.com/v2/resize:fit:948/format:webp/1*bR2I2ocLNFgif8BJp0FPIQ.png"/></div></figure><p id="d57c" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">没关系。让我们来看看为什么会出现这个错误。</p><ul class=""><li id="939e" class="km kn hi jl b jm jn jp jq js ko jw kp ka kq ke kr ks kt ku bi translated">我们试图访问的方法在GameManager脚本中。</li><li id="1573" class="km kn hi jl b jm kw jp kx js ky jw kz ka la ke kr ks kt ku bi translated">我们希望从UIManager调用该方法。</li><li id="f633" class="km kn hi jl b jm kw jp kx js ky jw kz ka la ke kr ks kt ku bi translated">然而，UIManager脚本并不知道我们有一个GameManager脚本。</li><li id="99ca" class="km kn hi jl b jm kw jp kx js ky jw kz ka la ke kr ks kt ku bi translated">我们没有它的句柄，因此无法访问脚本中的方法。</li></ul><p id="f750" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">幸运的是，这个问题很容易解决。我们只需要以通常的方式创建一个GameManager脚本的句柄。变量&gt;句柄&gt; NullCheck</p></div><div class="ab cl kf kg gp kh" role="separator"><span class="ki bw bk kj kk kl"/><span class="ki bw bk kj kk kl"/><span class="ki bw bk kj kk"/></div><div class="hb hc hd he hf"><p id="9b70" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated"><strong class="jl hj">管用！<br/> </strong>现在一切都设置好了，应该可以按预期运行了！</p><p id="e389" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">让我们看看最终的结果:</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es lb"><img src="../Images/4f2364122d0a808dce8f54915c5333f6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*zb6yDvvLxTytLSDaZxRWiw.gif"/></div></div></figure></div></div>    
</body>
</html>