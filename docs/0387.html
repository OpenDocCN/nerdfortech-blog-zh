<html>
<head>
<title>Learning Go — Functions</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">学习围棋—功能</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/learning-go-functions-b63c8a125afd?source=collection_archive---------3-----------------------#2020-11-20">https://medium.com/nerd-for-tech/learning-go-functions-b63c8a125afd?source=collection_archive---------3-----------------------#2020-11-20</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/f5bb59682f6053470d75c70cac45c605.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AJAGtpn_f7wMFdcwFn95LA.png"/></div></div></figure><h1 id="3aa2" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">功能</h1><p id="2a6e" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">函数是一段代码，它接受一些输入，对输入进行一些处理，并产生一些输出。Go 中的<strong class="jq hj">函数是一等公民</strong>类似于 javascript。</p><h2 id="6bb8" class="km ir hi bd is kn ko kp iw kq kr ks ja jz kt ku je kd kv kw ji kh kx ky jm kz bi translated">申报</h2><p id="0355" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">Go 中的一个函数是用<strong class="jq hj"> func </strong>关键字声明的。一个函数有一个<strong class="jq hj">名</strong>，一个逗号分隔的<strong class="jq hj">输入参数列表</strong>及其类型，<strong class="jq hj">结果类型</strong>，以及一个<strong class="jq hj">主体。</strong></p><pre class="la lb lc ld fd le lf lg lh aw li bi"><span id="4c05" class="km ir hi lf b fi lj lk l ll lm">func &lt;name&gt;(arg &lt;type&gt;) &lt;return type&gt; {<br/>     //body<br/>     return &lt;val&gt;<br/>}</span></pre><p id="d5a5" class="pw-post-body-paragraph jo jp hi jq b jr ln jt ju jv lo jx jy jz lp kb kc kd lq kf kg kh lr kj kk kl hb bi translated"><strong class="jq hj"> <em class="ls">例题</em> </strong></p><pre class="la lb lc ld fd le lf lg lh aw li bi"><span id="71aa" class="km ir hi lf b fi lj lk l ll lm">func firstFn(arg1 int, arg2 int) int {<br/>     val := arg1 + arg2<br/>     fmt.Println("I am a method and my value is : ", val)<br/>     return val<br/>}</span></pre><h2 id="66ec" class="km ir hi bd is kn ko kp iw kq kr ks ja jz kt ku je kd kv kw ji kh kx ky jm kz bi translated">调用函数</h2><p id="c5dc" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">调用方法只是使用函数名并传递必要的参数。对于有任何编程经验的人来说非常容易理解。</p><pre class="la lb lc ld fd le lf lg lh aw li bi"><span id="6f63" class="km ir hi lf b fi lj lk l ll lm">firstFn(5)</span></pre><p id="ca2b" class="pw-post-body-paragraph jo jp hi jq b jr ln jt ju jv lo jx jy jz lp kb kc kd lq kf kg kh lr kj kk kl hb bi translated">我想上面的示例函数让事情变得清楚了。这是一个非常简单的函数。有一些重要的事情要记住。</p><ul class=""><li id="e893" class="lt lu hi jq b jr ln jv lo jz lv kd lw kh lx kl ly lz ma mb bi translated">参数是可选的。只有当你的函数需要调用函数的值时，它们才是必需的。</li><li id="dde2" class="lt lu hi jq b jr mc jv md jz me kd mf kh mg kl ly lz ma mb bi translated">返回类型是可选的。只有当函数返回一个有意义的值时，才有必要使用返回类型和返回语句。</li></ul></div><div class="ab cl mh mi gp mj" role="separator"><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm"/></div><div class="hb hc hd he hf"><blockquote class="mo"><p id="f5b2" class="mp mq hi bd mr ms mt mu mv mw mx kl dx translated">让我们围绕 Go 中函数的声明和初始化来讨论一些语法规则。</p></blockquote><blockquote class="my mz na"><p id="f0c0" class="jo jp ls jq b jr nb jt ju jv nc jx jy nd ne kb kc nf ng kf kg nh ni kj kk kl hb bi translated"><strong class="jq hj">函数参数分组</strong></p></blockquote><pre class="la lb lc ld fd le lf lg lh aw li bi"><span id="dfba" class="km ir hi lf b fi lj lk l ll lm">func secondFn(arg1, arg2, arg3 int, arg4, arg5 string, emp *Employee) int {<br/>     fmt.Println("I am a method and my value is : ", arg1)<br/>     return arg1<br/>}</span></pre><p id="fdec" class="pw-post-body-paragraph jo jp hi jq b jr ln jt ju jv lo jx jy jz lp kb kc kd lq kf kg kh lr kj kk kl hb bi translated">观察函数参数。您可以将具有相同类型的变量分组，用分隔符(，)分隔，并且为所有变量声明一次类型。arg1、arg2、arg3 是 int 类型，arg4、arg5 是 string 类型。</p></div><div class="ab cl mh mi gp mj" role="separator"><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm"/></div><div class="hb hc hd he hf"><blockquote class="my mz na"><p id="edd0" class="jo jp ls jq b jr ln jt ju jv lo jx jy nd lp kb kc nf lq kf kg nh lr kj kk kl hb bi translated"><strong class="jq hj">具有多个返回值的函数</strong></p></blockquote><pre class="la lb lc ld fd le lf lg lh aw li bi"><span id="7e82" class="km ir hi lf b fi lj lk l ll lm">func thirdFn(arg1, arg2, arg3 int, arg4, arg5 string) (int, string) {<br/>   fmt.Println("I am a method and my value is : ", arg1)<br/>   return arg1, arg5<br/>}</span></pre><p id="62af" class="pw-post-body-paragraph jo jp hi jq b jr ln jt ju jv lo jx jy jz lp kb kc kd lq kf kg kh lr kj kk kl hb bi translated">函数在 Go 中可以返回多个值。对于有 java 背景的人来说这是最酷的特性，因为 java 函数只能返回一个值。<br/>观察返回类型和返回语句是如何从单值返回函数变化而来的</p><pre class="la lb lc ld fd le lf lg lh aw li bi"><span id="1731" class="km ir hi lf b fi lj lk l ll lm">func thirdFn(arg1, arg2, arg3 int, arg4, arg5 string) <strong class="lf hj">(int, string)</strong></span></pre><p id="5856" class="pw-post-body-paragraph jo jp hi jq b jr ln jt ju jv lo jx jy jz lp kb kc kd lq kf kg kh lr kj kk kl hb bi translated">返回类型是用逗号分隔的<strong class="jq hj"/>和括在双引号内的<strong class="jq hj">。</strong></p><pre class="la lb lc ld fd le lf lg lh aw li bi"><span id="916d" class="km ir hi lf b fi lj lk l ll lm">return arg1, arg5</span></pre><p id="31c9" class="pw-post-body-paragraph jo jp hi jq b jr ln jt ju jv lo jx jy jz lp kb kc kd lq kf kg kh lr kj kk kl hb bi translated"><strong class="jq hj"> return </strong>已经提供了相应的<strong class="jq hj">返回值，以逗号分隔</strong>和<strong class="jq hj">的顺序，如函数签名</strong>中的 return type 所声明。</p><blockquote class="my mz na"><p id="116a" class="jo jp ls jq b jr ln jt ju jv lo jx jy nd lp kb kc nf lq kf kg nh lr kj kk kl hb bi translated">多值函数的用例将在与 Go 中的错误处理相关的文章中得到更多的强调，其中函数返回值以及错误(如果有的话)。调用者可以在使用函数的值之前检查错误值。</p></blockquote></div><div class="ab cl mh mi gp mj" role="separator"><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm"/></div><div class="hb hc hd he hf"><blockquote class="my mz na"><p id="3535" class="jo jp ls jq b jr ln jt ju jv lo jx jy nd lp kb kc nf lq kf kg nh lr kj kk kl hb bi translated"><strong class="jq hj">用作数值</strong></p></blockquote><p id="342b" class="pw-post-body-paragraph jo jp hi jq b jr ln jt ju jv lo jx jy jz lp kb kc kd lq kf kg kh lr kj kk kl hb bi translated">函数可以是匿名的，即没有名字。它们是为小范围声明的。例子</p><pre class="la lb lc ld fd le lf lg lh aw li bi"><span id="909b" class="km ir hi lf b fi lj lk l ll lm">func main() {<br/>    func() {<br/>        fmt.Println("i am anonymous func")<br/>    }()<br/>}</span></pre><p id="8f71" class="pw-post-body-paragraph jo jp hi jq b jr ln jt ju jv lo jx jy jz lp kb kc kd lq kf kg kh lr kj kk kl hb bi translated">注意，该函数以关键字<strong class="jq hj"> func </strong>开始，但没有名称<strong class="jq hj"/>。函数体作为块位于花括号内。函数定义后有一个 Paran thesis<strong class="jq hj">()</strong>。这是函数执行所必需的。<br/>函数的作用域只在<strong class="jq hj"> main() </strong>函数内部。</p><p id="cd71" class="pw-post-body-paragraph jo jp hi jq b jr ln jt ju jv lo jx jy jz lp kb kc kd lq kf kg kh lr kj kk kl hb bi translated">这些匿名函数可以赋给一个变量。函数可以使用被赋予的变量来调用。</p><pre class="la lb lc ld fd le lf lg lh aw li bi"><span id="b814" class="km ir hi lf b fi lj lk l ll lm">func main() {<br/>   var fn func() = func() {<br/>      fmt.Println("i am func")<br/>   }<br/>   fn()<br/>}</span></pre><p id="6b8a" class="pw-post-body-paragraph jo jp hi jq b jr ln jt ju jv lo jx jy jz lp kb kc kd lq kf kg kh lr kj kk kl hb bi translated">该函数还可以添加参数，这些参数可以在调用该函数时被提供值。</p><pre class="la lb lc ld fd le lf lg lh aw li bi"><span id="127d" class="km ir hi lf b fi lj lk l ll lm">func main() {<br/>    var fn = func(arg1 int) {<br/>       fmt.Println("i am func with : ", arg1)<br/>    }<br/>    fn(5)<br/>}</span></pre></div><div class="ab cl mh mi gp mj" role="separator"><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm"/></div><div class="hb hc hd he hf"><blockquote class="my mz na"><p id="310f" class="jo jp ls jq b jr ln jt ju jv lo jx jy nd lp kb kc nf lq kf kg nh lr kj kk kl hb bi translated"><strong class="jq hj">功能关闭</strong></p></blockquote><p id="e234" class="pw-post-body-paragraph jo jp hi jq b jr ln jt ju jv lo jx jy jz lp kb kc kd lq kf kg kh lr kj kk kl hb bi translated">当即使在父函数已经执行之后，子函数仍然保持父作用域的环境时，就创建了闭包。这有助于传播已经通过父函数内的封闭范围匿名函数执行的函数的字段。</p><pre class="la lb lc ld fd le lf lg lh aw li bi"><span id="635c" class="km ir hi lf b fi lj lk l ll lm">function<!-- --> <!-- -->foo(arg1 int) { <!-- --> <!-- -->    function<!-- --> <!-- -->inner(arg2 int) int { <!-- --> <!-- -->        return<!-- --> <!-- -->arg1 + arg2<!-- --> <!-- -->    } <!-- --> <!-- -->    return<!-- --> <!-- -->inner<!-- --> <!-- -->} <!-- --> <!-- -->var<!-- --> <!-- -->fooInner = foo(5)<!-- --> <!-- -->fmt.Println(fooInner(4))</span></pre></div><div class="ab cl mh mi gp mj" role="separator"><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm"/></div><div class="hb hc hd he hf"><h1 id="62cc" class="iq ir hi bd is it nj iv iw ix nk iz ja jb nl jd je jf nm jh ji jj nn jl jm jn bi translated">方法</h1><p id="a44e" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">方法是 Go 中特殊类型的函数。除了正常的函数签名，它们还有一个额外的<strong class="jq hj">接收器</strong>。</p><pre class="la lb lc ld fd le lf lg lh aw li bi"><span id="f508" class="km ir hi lf b fi lj lk l ll lm">func (&lt;var&gt; &lt;type&gt;) &lt;name&gt;() &lt;return_type&gt;{<br/>   /* function body*/<br/>}</span></pre><blockquote class="my mz na"><p id="6387" class="jo jp ls jq b jr ln jt ju jv lo jx jy nd lp kb kc nf lq kf kg nh lr kj kk kl hb bi translated"><strong class="jq hj">带值接收器的方法</strong></p></blockquote><p id="261e" class="pw-post-body-paragraph jo jp hi jq b jr ln jt ju jv lo jx jy jz lp kb kc kd lq kf kg kh lr kj kk kl hb bi translated">示例—从上面的员工结构中调用。</p><pre class="la lb lc ld fd le lf lg lh aw li bi"><span id="480b" class="km ir hi lf b fi lj lk l ll lm">type Employee struct {<br/>   id int<br/>   name string<br/>   dept []string<br/>}</span><span id="c655" class="km ir hi lf b fi no lk l ll lm">func main() {<br/>    emp := Employee{<br/>        id: 123,<br/>        name: "prateek",<br/>        dept: []string{<br/>             "Technology",<br/>             "MFP",<br/>             "Delivery",<br/>        },<br/>    }<br/>    fmt.Println(emp)<br/>    emp = emp.setEmpName()<br/>    fmt.Println(emp)<br/>}</span><span id="4676" class="km ir hi lf b fi no lk l ll lm">func (e Employee) setEmpName()  {<br/>   e.name = "Hari"<br/>}</span><span id="935d" class="km ir hi lf b fi no lk l ll lm">Result<br/>{123 prateek [Technology MFP Delivery]}<br/>{123 Hari [Technology MFP Delivery]}</span></pre><p id="6441" class="pw-post-body-paragraph jo jp hi jq b jr ln jt ju jv lo jx jy jz lp kb kc kd lq kf kg kh lr kj kk kl hb bi translated">使用方法观察名称的变化。</p><blockquote class="my mz na"><p id="ed83" class="jo jp ls jq b jr ln jt ju jv lo jx jy nd lp kb kc nf lq kf kg nh lr kj kk kl hb bi translated"><strong class="jq hj">带指针接收器的方法</strong></p></blockquote><pre class="la lb lc ld fd le lf lg lh aw li bi"><span id="200f" class="km ir hi lf b fi lj lk l ll lm">func (e *Employee) SetEmpName() {<br/>   e.name = "sridhar"<br/>}</span></pre><p id="6c99" class="pw-post-body-paragraph jo jp hi jq b jr ln jt ju jv lo jx jy jz lp kb kc kd lq kf kg kh lr kj kk kl hb bi translated">如果使用上面的方法而不是值为 reciever 的方法，那么在原始结构实例 emp 中更新<strong class="jq hj">值，而不从函数 SetEmpName() </strong>返回任何值。对于指针类型，这是意料之中的。</p></div><div class="ab cl mh mi gp mj" role="separator"><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm"/></div><div class="hb hc hd he hf"><h1 id="0493" class="iq ir hi bd is it nj iv iw ix nk iz ja jb nl jd je jf nm jh ji jj nn jl jm jn bi translated">具有任意数量参数的函数</h1><p id="b9c1" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">在 Go 中，我们可以在类型前使用<strong class="jq hj"> … </strong>在函数中设置任意数量的参数。</p><pre class="la lb lc ld fd le lf lg lh aw li bi"><span id="58f1" class="km ir hi lf b fi lj lk l ll lm">func multiParams(values ...int) (*int) {<br/>   fmt.Println(values)<br/>   result := 0<br/>   for _, val := range values {<br/>      fmt.Println(val)<br/>      result += val<br/>   }<br/>   return &amp;result<br/>}</span><span id="9d56" class="km ir hi lf b fi no lk l ll lm">func main() {<br/>   sum := multiParams(1, 2, 4, 5)<br/>   fmt.Println(*sum)<br/>}</span><span id="d809" class="km ir hi lf b fi no lk l ll lm">Result<br/>12</span></pre><p id="72f2" class="pw-post-body-paragraph jo jp hi jq b jr ln jt ju jv lo jx jy jz lp kb kc kd lq kf kg kh lr kj kk kl hb bi translated">这里我们到了帖子的结尾。<strong class="jq hj">你可以在帖子上评论任何细节或不一致的问题。我将在以后的文章中讨论各种主题——常量、枚举器、延迟、错误处理和 Go 中的死机</strong></p></div></div>    
</body>
</html>