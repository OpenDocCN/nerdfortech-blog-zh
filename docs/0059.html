<html>
<head>
<title>Leveraging Async Metrics Using Aspects</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用方面利用异步度量</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/leveraging-async-metrics-using-aspects-81838b9b887e?source=collection_archive---------0-----------------------#2019-09-30">https://medium.com/nerd-for-tech/leveraging-async-metrics-using-aspects-81838b9b887e?source=collection_archive---------0-----------------------#2019-09-30</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="3b75" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">metrics是一个了不起的库，它提供了各种工具。在<code class="du jd je jf jg b">Dropwizard</code>应用程序中使用的默认度量注册表来自<code class="du jd je jf jg b">Codahale metrics</code>。</p><p id="6531" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们希望利用Dropwizard指标进行异步回调。类似于返回期货的方法的<code class="du jd je jf jg b">@Timed / @ExceptionMetered</code>。</p><p id="a361" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这些用于标记带注释对象的方法的注释使得代码可读性更好，并且将标记度量的不必要样板文件与业务逻辑分开。</p><figure class="jj jk jl jm fd jn er es paragraph-image"><div role="button" tabindex="0" class="jo jp di jq bf jr"><div class="er es ji"><img src="../Images/b6b352c4931da7d4aaad4ee72a4e73dc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*g4CkdSH5rRDVcWwb8x7toQ.png"/></div></div><figcaption class="ju jv et er es jw jx bd b be z dx translated">它在同步模式下如何工作，在异步模式下如何不工作</figcaption></figure><p id="495a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">然而，第二种方法不会产生正确的结果，好像调用线程将工作分派给fork-join池中的另一个<code class="du jd je jf jg b">thread</code>，然后这个<strong class="ih hj">方法执行完成而不等待结果</strong>。</p><p id="6ab6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">理想情况下，我们希望标记我们的度量标准，并在回调解决<code class="du jd je jf jg b">successfully</code>或<code class="du jd je jf jg b">exceptionally</code>时找出一种方法来做事情。</p><blockquote class="jy"><p id="0c85" class="jz ka hi bd kb kc kd ke kf kg kh jc dx translated">我们正在寻找方法来模拟和创建标准和流行的度量注释的异步变体</p></blockquote><figure class="kj kk kl km kn jn er es paragraph-image"><div role="button" tabindex="0" class="jo jp di jq bf jr"><div class="er es ki"><img src="../Images/0024b4697cb88c741ae71ae514d758a9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*96uJTFXdhYp8lFoneYgBhg.png"/></div></div><figcaption class="ju jv et er es jw jx bd b be z dx translated">我们正在寻找的变体</figcaption></figure><p id="db4d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">显而易见的处理方法如下。</p><figure class="jj jk jl jm fd jn er es paragraph-image"><div role="button" tabindex="0" class="jo jp di jq bf jr"><div class="er es ko"><img src="../Images/2374a9432de53a3e8ab80cf02b0b0088.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8A50hsF75xfJ-dgDdZvevQ.png"/></div></div><figcaption class="ju jv et er es jw jx bd b be z dx translated">琐碎的变通办法</figcaption></figure><p id="dd97" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">然而，上面的解决方法通过注入<code class="du jd je jf jg b">Metric Registry</code>和相应的<code class="du jd je jf jg b">meters</code>污染了我们的逻辑。如果我们想要做的只是在回调解析上标记度量，这很快就会变得混乱。</p><blockquote class="kp kq kr"><p id="586c" class="if ig ks ih b ii ij ik il im in io ip kt ir is it ku iv iw ix kv iz ja jb jc hb bi translated">因此，问题是在不污染业务逻辑的情况下，巧妙地标记这些未来的度量标准。沿着基于注释的解决方案的某个地方，它是可读的和声明性的。</p></blockquote><p id="3936" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">GitHub上的<a class="ae jh" href="https://github.com/isopropylcyanide/async-metrics-codahale" rel="noopener ugc nofollow" target="_blank">这里</a>有完整的源代码。该项目也可以在Maven Central上获得。</p><figure class="jj jk jl jm fd jn er es paragraph-image"><div role="button" tabindex="0" class="jo jp di jq bf jr"><div class="er es kw"><img src="../Images/03dfe0898fd49904133bf57ae9ba6ed1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Q5bXosBgi4B-unH7-F67bg.png"/></div></div><figcaption class="ju jv et er es jw jx bd b be z dx">.</figcaption></figure><p id="7a6c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">替代解决方案</strong> <br/>按照领域驱动设计的范例，我们可以尝试在未来引入一个包装器，比如说<code class="du jd je jf jg b">MetricedFuture</code>。<code class="du jd je jf jg b">MetricedFuture</code>将提供挂钩，在成功/错误解析后将在其中填充指标</p><figure class="jj jk jl jm fd jn er es paragraph-image"><div role="button" tabindex="0" class="jo jp di jq bf jr"><div class="er es kx"><img src="../Images/b8f3119452be4106c6674a7c0fb94c51.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pF4ZAqnxxg0GtL9D3Lrl3A.png"/></div></div><figcaption class="ju jv et er es jw jx bd b be z dx translated">MetricedFuture。我们的完整包装</figcaption></figure><p id="0af7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">然而，这很快变得不可维护。这些挂钩只能确保当被覆盖的方法被调用时，度量会被填充。例如，在这种情况下，当调用<code class="du jd je jf jg b"><strong class="ih hj">thenApply()</strong></code>时，指标不会运行。</p><p id="80b1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">优点</strong></p><ul class=""><li id="bded" class="ky kz hi ih b ii ij im in iq la iu lb iy lc jc ld le lf lg bi translated">我们更加明确地表示，我们将在完成后标记指标。</li><li id="68a9" class="ky kz hi ih b ii lh im li iq lj iu lk iy ll jc ld le lf lg bi translated">不涉及魔法。包装纸就在眼前。</li><li id="f782" class="ky kz hi ih b ii lh im li iq lj iu lk iy ll jc ld le lf lg bi translated">没有外部依赖性</li></ul><p id="27a9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">缺点</strong></p><ul class=""><li id="3c80" class="ky kz hi ih b ii ij im in iq la iu lb iy lc jc ld le lf lg bi translated">无法处理所有方法的挂钩</li><li id="3b48" class="ky kz hi ih b ii lh im li iq lj iu lk iy ll jc ld le lf lg bi translated">用包装器丢弃代码库</li><li id="2711" class="ky kz hi ih b ii lh im li iq lj iu lk iy ll jc ld le lf lg bi translated">当涉及到排除某些指标时，就不是那么微不足道了</li><li id="182e" class="ky kz hi ih b ii lh im li iq lj iu lk iy ll jc ld le lf lg bi translated">排除某些方法的度量标准并不简单</li></ul><h1 id="015f" class="lm ln hi bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated"><strong class="ak">提议的解决方案</strong></h1><p id="5084" class="pw-post-body-paragraph if ig hi ih b ii mk ik il im ml io ip iq mm is it iu mn iw ix iy mo ja jb jc hb bi translated">关于我们试图解决的用例，我们注意到一件事。我们正在发布业务回访完成情况的指标。这是一个贯穿各领域的问题。</p><blockquote class="kp kq kr"><p id="1af4" class="if ig ks ih b ii ij ik il im in io ip kt ir is it ku iv iw ix kv iz ja jb jc hb bi translated">横切关注点是计划中影响其他关注点的方面。在设计和实现中，这些问题通常无法从系统的其余部分中清晰地分解出来，并且可能导致分散(代码重复)、缠结(系统之间的显著依赖性)，或者两者兼而有之。</p></blockquote><p id="3d97" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">上面清楚地提到了我们的替代解决方案的问题。好在这种问题之前已经解决了。<code class="du jd je jf jg b">AspectJ</code>就是这样一种工具。</p><blockquote class="kp kq kr"><p id="3db5" class="if ig ks ih b ii ij ik il im in io ip kt ir is it ku iv iw ix kv iz ja jb jc hb bi translated">AspectJ支持横切关注点的清晰模块化，比如错误检查和处理、同步、上下文敏感行为、性能优化、监控和日志记录、调试支持和多对象协议</p></blockquote><p id="7c2d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们的用例在<code class="du jd je jf jg b">AspectJ</code>提供的工具范围内。对于如何解决这个问题，我们也有一个大致的想法。</p><ul class=""><li id="4a21" class="ky kz hi ih b ii ij im in iq la iu lb iy lc jc ld le lf lg bi translated">创建<code class="du jd je jf jg b">Aspects</code>，保存当它们匹配特定的<code class="du jd je jf jg b">pointcut</code>(最好是注释)时触发的通知</li><li id="9dbd" class="ky kz hi ih b ii lh im li iq lj iu lk iy ll jc ld le lf lg bi translated"><code class="du jd je jf jg b">Around</code>建议可以用来编织<code class="du jd je jf jg b">joinpoint</code>的度量逻辑</li><li id="0a60" class="ky kz hi ih b ii lh im li iq lj iu lk iy ll jc ld le lf lg bi translated">标注或标记上述方法所建议的方法</li></ul><p id="ae34" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">下面的代码片段给出了实现的思路</p><figure class="jj jk jl jm fd jn er es paragraph-image"><div role="button" tabindex="0" class="jo jp di jq bf jr"><div class="er es mp"><img src="../Images/9bb13ddb0ae4af81a5002dbb79495bac.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pWy17Ho5TMrOwqccgTteHg.png"/></div></div><figcaption class="ju jv et er es jw jx bd b be z dx translated">示例方面:标记异步方法的度量</figcaption></figure><figure class="jj jk jl jm fd jn er es paragraph-image"><div class="er es mq"><img src="../Images/35f9e773f7fba31c968ad354aa2bda49.png" data-original-src="https://miro.medium.com/v2/resize:fit:1372/format:webp/1*vqGNVXqNbAii4f90ZlcdVg.png"/></div><figcaption class="ju jv et er es jw jx bd b be z dx translated">我们的自定义注释</figcaption></figure><figure class="jj jk jl jm fd jn er es paragraph-image"><div class="er es mr"><img src="../Images/91a717a4a2734673de86ecca75703479.png" data-original-src="https://miro.medium.com/v2/resize:fit:904/format:webp/1*owhdu0IYkr4GX5D1051ZNw.png"/></div><figcaption class="ju jv et er es jw jx bd b be z dx translated">如何使用这个注释</figcaption></figure><p id="2d2d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这正是我们想要的。只需一个注释，我们就能够将定制代码编织到业务逻辑中。</p><p id="db61" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">权衡</strong> <br/>引入<code class="du jd je jf jg b">AspectJ</code>也不简单。</p><p id="bb8c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">优点</strong></p><ul class=""><li id="194a" class="ky kz hi ih b ii ij im in iq la iu lb iy lc jc ld le lf lg bi translated">编织代码而不污染业务逻辑是一个bug plus</li><li id="9201" class="ky kz hi ih b ii lh im li iq lj iu lk iy ll jc ld le lf lg bi translated">要禁用某个方面，只需移除注释或触发器</li><li id="4d1a" class="ky kz hi ih b ii lh im li iq lj iu lk iy ll jc ld le lf lg bi translated">度量逻辑可以独立变化。</li><li id="a53e" class="ky kz hi ih b ii lh im li iq lj iu lk iy ll jc ld le lf lg bi translated">不需要处理所有的钩子，因为方法保证在继续之后执行</li><li id="acd7" class="ky kz hi ih b ii lh im li iq lj iu lk iy ll jc ld le lf lg bi translated">方面可以单独测试</li><li id="3aac" class="ky kz hi ih b ii lh im li iq lj iu lk iy ll jc ld le lf lg bi translated">好的测试可以确保方面的误用。</li></ul><p id="4444" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">缺点</strong></p><ul class=""><li id="e934" class="ky kz hi ih b ii ij im in iq la iu lb iy lc jc ld le lf lg bi translated"><code class="du jd je jf jg b">AspectJ library</code>需要介绍一下。随之而来的是一个新的构建插件<code class="du jd je jf jg b">aspectj-rt</code>来编织类。</li><li id="0c06" class="ky kz hi ih b ii lh im li iq lj iu lk iy ll jc ld le lf lg bi translated">与<code class="du jd je jf jg b">aspect</code>相关的次要学习曲线。然而，任何新概念都是如此</li><li id="9d39" class="ky kz hi ih b ii lh im li iq lj iu lk iy ll jc ld le lf lg bi translated">虽然我们确保只处理实用程序代码(metrics | logs ),但这看起来似乎很神奇</li><li id="1e1a" class="ky kz hi ih b ii lh im li iq lj iu lk iy ll jc ld le lf lg bi translated">成为<code class="du jd je jf jg b">misused</code>的可能性。一点改变任何未来的决心。最大的缺点是需要有好的测试。</li><li id="dfe2" class="ky kz hi ih b ii lh im li iq lj iu lk iy ll jc ld le lf lg bi translated">Lombok + AspectJ有点乱。<code class="du jd je jf jg b">Load</code>需要做时间编织而不是<code class="du jd je jf jg b">compile</code>时间</li></ul><h1 id="0a24" class="lm ln hi bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated"><strong class="ak">用途</strong></h1><p id="9212" class="pw-post-body-paragraph if ig hi ih b ii mk ik il im ml io ip iq mm is it iu mn iw ix iy mo ja jb jc hb bi translated">我介绍了<code class="du jd je jf jg b">Timers</code>、<code class="du jd je jf jg b">Exception Meters</code>和<code class="du jd je jf jg b">Meters</code>标准的基本情况。为了便于安装，它们被绑定在一个Guice模块中。</p><figure class="jj jk jl jm fd jn er es paragraph-image"><div role="button" tabindex="0" class="jo jp di jq bf jr"><div class="er es ms"><img src="../Images/783fd08332582b0f41a96b00b62a11de.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yNSE-4eBHyfvucJkcJc75A.png"/></div></div></figure><p id="6e7d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">跳过方面编织代码的单元测试</strong></p><p id="8c87" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">将方面与业务逻辑结合在一起非常好。然而，这也扰乱了测试。单元测试方法不应该经过<code class="du jd je jf jg b">advices</code>。那违背了目的。我们多么希望存在以下注释</p><figure class="jj jk jl jm fd jn er es paragraph-image"><div class="er es mt"><img src="../Images/6032b6c58c525482a67b0d873354e837.png" data-original-src="https://miro.medium.com/v2/resize:fit:872/format:webp/1*Om6QJDfLIJtGIwYQWBkG1w.png"/></div><figcaption class="ju jv et er es jw jx bd b be z dx translated">理想世界中的注解</figcaption></figure><p id="acfc" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">然而，事实并非如此。因此，在执行建议时，我们需要快速判断我们是否来自测试环境。这看起来很复杂，但这是我在写作时唯一知道的方法。此外，没有简单的方法可以清晰地识别测试环境。</p><figure class="jj jk jl jm fd jn er es paragraph-image"><div role="button" tabindex="0" class="jo jp di jq bf jr"><div class="er es mu"><img src="../Images/e20c3830bcfb5a280dcb369328005d9b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FatR5crdACkUHFQdpUnWBQ.png"/></div></div><figcaption class="ju jv et er es jw jx bd b be z dx translated">现在必须在正确的环境中过滤的方面。</figcaption></figure><p id="75f0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果<strong class="ih hj"> isTestEnv </strong>被设置，方面简单地让方法在没有任何逻辑的情况下继续进行。否则，我们做我们的逻辑。</p><h1 id="d548" class="lm ln hi bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated">Guice AOP</h1><p id="aa5e" class="pw-post-body-paragraph if ig hi ih b ii mk ik il im ml io ip iq mm is it iu mn iw ix iy mo ja jb jc hb bi translated">在阅读了这本<a class="ae jh" href="https://learning.oreilly.com/library/view/dependency-injection-design/9781933988559/" rel="noopener ugc nofollow" target="_blank">书</a>之后，我意识到方法拦截也可以通过类似堆栈的方法(因为我们有多个<code class="du jd je jf jg b">advices</code>)毫不费力地通过Guice AOP来完成。Guice是一个流行的依赖注入框架。</p><p id="78c7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">虽然我们上面的异步方法是正确的，但是有一些限制</p><ul class=""><li id="0acd" class="ky kz hi ih b ii ij im in iq la iu lb iy lc jc ld le lf lg bi translated">对<code class="du jd je jf jg b"><strong class="ih hj">Aspect-J library</strong></code>的依赖</li><li id="70b4" class="ky kz hi ih b ii lh im li iq lj iu lk iy ll jc ld le lf lg bi translated">依赖于<code class="du jd je jf jg b"><strong class="ih hj">ajc</strong></code> java编译器来编织方面</li><li id="4e8c" class="ky kz hi ih b ii lh im li iq lj iu lk iy ll jc ld le lf lg bi translated">如上所示，在单元测试模式下运行时，<code class="du jd je jf jg b"><strong class="ih hj"> skip advices</strong></code>出现难看的代码</li><li id="ff2e" class="ky kz hi ih b ii lh im li iq lj iu lk iy ll jc ld le lf lg bi translated"><code class="du jd je jf jg b"><strong class="ih hj">Special build plugins</strong></code>编织类</li></ul><p id="cf05" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><code class="du jd je jf jg b">Guice AOP</code>使用<code class="du jd je jf jg b">AOP Alliance</code>，而我们使用<code class="du jd je jf jg b">AspectJ</code>作为主要依赖项。如果你们想看Guice口味的版本，请在下面的评论中告诉我。</p><p id="260b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">大大简化了创建<strong class="ih hj">方法拦截器</strong>的过程。事实上，在生产中成功使用<code class="du jd je jf jg b">AspectJ</code>一年多之后，我决定继续使用<code class="du jd je jf jg b">Guice AOP</code>来实现</p><p id="7cb7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">最好的部分是，除了一些方法签名之外，捕获指标的逻辑保持不变。这就是接口标准化的力量。两个明显不同的AOP提供者，但是他们仍然有很多共同点。</p><figure class="jj jk jl jm fd jn er es paragraph-image"><div role="button" tabindex="0" class="jo jp di jq bf jr"><div class="er es mv"><img src="../Images/81dda4e64475bec6ba9bfebd8b6a9e87.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1R_fdCRfszIlJ4x0hxmYag.png"/></div></div><figcaption class="ju jv et er es jw jx bd b be z dx translated">绑定拦截器</figcaption></figure><p id="9098" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们已经平稳地运行了<code class="du jd je jf jg b">Guice AOP</code>版本一段时间了。不过也有一些警告。在下列情况下，Guice无法截获这些方法:</p><ul class=""><li id="1898" class="ky kz hi ih b ii ij im in iq la iu lb iy lc jc ld le lf lg bi translated"><code class="du jd je jf jg b"><strong class="ih hj">Guice did not create the target instance</strong></code> <br/>这是显而易见的。使用<code class="du jd je jf jg b">new ..()</code>创建的对象不在Guice的权限之内，因此它们的方法不能被告知。</li><li id="9c15" class="ky kz hi ih b ii lh im li iq lj iu lk iy ll jc ld le lf lg bi translated"><code class="du jd je jf jg b"><strong class="ih hj">Method or class is final</strong></code> <strong class="ih hj"> <br/> </strong>如果你知道代理是如何工作的，你就能猜出这个。没有一些混乱的字节码操作(<code class="du jd je jf jg b">PowerMockito</code>或增强的库，如<code class="du jd je jf jg b">CGLIB</code>)，类和方法不能被代理/窥探/模仿</li><li id="9809" class="ky kz hi ih b ii lh im li iq lj iu lk iy ll jc ld le lf lg bi translated"><code class="du jd je jf jg b"><strong class="ih hj">Method is private</strong></code> <br/>私有方法不能被拦截，除非AOP层重置了可见性修饰符。安全地说，不要建议私有方法</li></ul><p id="3c27" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">至此，我们结束了关于为异步完成的方法提供度量的讨论。我们看了以下内容。</p><ul class=""><li id="b576" class="ky kz hi ih b ii ij im in iq la iu lb iy lc jc ld le lf lg bi translated">强力设计</li><li id="cd63" class="ky kz hi ih b ii lh im li iq lj iu lk iy ll jc ld le lf lg bi translated">包装/委托设计</li><li id="43d8" class="ky kz hi ih b ii lh im li iq lj iu lk iy ll jc ld le lf lg bi translated"><strong class="ih hj">面向方面设计</strong>(以及后来的GuiceAOP，一个专门的版本)</li></ul><p id="e46e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">根据你的里程，你可以选择一个浮动你的船。</p></div></div>    
</body>
</html>