<html>
<head>
<title>Genetic Algorithm: 8 Queens Problem</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">遗传算法:8皇后问题</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/genetic-algorithm-8-queens-problem-b01730e673fd?source=collection_archive---------0-----------------------#2021-05-18">https://medium.com/nerd-for-tech/genetic-algorithm-8-queens-problem-b01730e673fd?source=collection_archive---------0-----------------------#2021-05-18</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="de32" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在我最近关于人工智能(CS4100)的讲座中，我遇到了一个有趣的概念:遗传算法。正如Stuart等人在“人工智能:现代方法”中所描述的，进化算法可以被视为随机波束搜索的变体，它试图复制生物学中自然选择的隐喻。教科书是这样描述该算法的:“存在一个个体(状态)群体，其中最适合的(最高值)个体产生后代(继承状态)来填充下一代，这一过程称为重组。”当我第一次听说这个概念时，它让我想起了这个<a class="ae jd" href="https://www.youtube.com/watch?v=qv6UVOQ0F44" rel="noopener ugc nofollow" target="_blank">视频</a>，一个使用遗传算法学习玩超级马里奥世界的神经网络，这是我仍然希望有一天尝试并实现的东西。这个概念看起来很抽象，但却非常有意义。毕竟，你可以把一个朝着解决方案努力的算法看作是进化。在这篇博文中，我将应用一个简单的遗传算法来解决经典的8皇后问题。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div class="er es je"><img src="../Images/34da8efa6ba9d6241e5b4ec3c0f168ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:914/format:webp/0*ScgscJU4q5zWf6lk.png"/></div><figcaption class="jm jn et er es jo jp bd b be z dx translated">8皇后问题的解决方案。</figcaption></figure><p id="d60a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">8皇后问题很简单。在8×8的棋盘上，女王可以水平、垂直和对角移动任意数量的方格。通常情况下，棋盘上每一面都有一个皇后，但在这个问题中，有8个。这可以推广到NxN板上的N个皇后。目标是在棋盘上放置8个皇后，这样每对皇后就不会互相攻击。在上图中，你可以看到每个女王都不在另一个女王的视线范围内。下面是一个不是解决方案的董事会状态示例:</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div class="er es jq"><img src="../Images/fc0b24630013cc61975ada05b68b6689.png" data-original-src="https://miro.medium.com/v2/resize:fit:786/format:webp/1*LOpSpi35ZU3rS4v8hGCVdQ.png"/></div><figcaption class="jm jn et er es jo jp bd b be z dx translated">这张图片取自AIMA的教科书</figcaption></figure><p id="efd5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">第4和第7列的一对皇后正在对角攻击对方。</p><p id="831d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为了应用遗传算法框架，我们需要将棋盘状态转换成可行的输入。在遗传算法中，群体中的每个个体都是有限字母表上的一个字符串，类似于DNA序列。我们可以把棋盘转换成一串数字，使得每个数字的索引是列号，每个索引处的数字是行号，从左下方开始。上图会转换成16257483。在这个实验中，我将每个字符串表示为一个列表，所以[1，6，2，5，7，4，8，3]。</p><p id="e33e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">下图是遗传算法工作原理的概要:</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="er es jr"><img src="../Images/e3c9bf58b44b3332bae10eb7eed929b2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4GniD0F0CVP_b4trJKWakg.png"/></div></div><figcaption class="jm jn et er es jo jp bd b be z dx translated">这张图片取自AIMA的教科书</figcaption></figure><p id="ccc3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">首先，我随机选择了一个人口规模= 10的人群。然后，我决定使用一个适应度函数来模拟算法的“自然选择”过程。最简单的一个是没有攻击性的女王对的数量。这个问题的解决方案是8选2，即可能的皇后对的数量。在下面的代码中，我定义NUM_QUEENS = 8。</p><pre class="jf jg jh ji fd jw jx jy jz aw ka bi"><span id="9bb5" class="kb kc hi jx b fi kd ke l kf kg">def fitness_score(seq):<br/>    score = 0<br/>    <br/>    for row in range(NUM_QUEENS):<br/>        col = seq[row]<br/>        <br/>        for other_row in range(NUM_QUEENS):<br/>            <br/>            #queens cannot pair with itself<br/>            if other_row == row:<br/>                continue<br/>            if seq[other_row] == col:<br/>                continue<br/>            if other_row + seq[other_row] == row + col:<br/>                continue<br/>            if other_row - seq[other_row] == row - col:<br/>                continue<br/>            #score++ if every pair of queens are non-attacking.<br/>            score += 1<br/>    <br/>    #divide by 2 as pairs of queens are commutative<br/>    return score/2</span></pre><p id="f280" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">接下来是选择过程。我们定义一个混合数ρ，它是一个后代的父母数。正常情况下ρ = 2，(或者无性繁殖ρ = 1)。然而，由于这只是一个模拟，我们可以选择ρ &gt; 2。为了选择亲本，一种方法是选择随机的n个个体，并使ρ适应性得分最高的个体成为亲本。在这个实验中，我将父母的数量限制在人口规模的一半，并选择了概率与他们的健康分数成比例的父母。</p><p id="d4ed" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">然后，我们有交叉。当ρ = 2时，我随机选择了一个交叉点(列表中的索引)。第一亲本的第一部分与第二亲本的第二部分杂交产生后代。对第二个后代重复这一过程。下图显示了发生的情况:</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div class="er es kh"><img src="../Images/6bd56489ba61b8bf2dbca71d31b2bb8c.png" data-original-src="https://miro.medium.com/v2/resize:fit:924/format:webp/0*uKPGKswwE8NY540p.png"/></div></figure><p id="eb18" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">例如，我们有双亲1234和5678，其中交叉点是2，那么产生的后代是1278和3456。</p><p id="e3f8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我还想考虑ρ &gt; 2，所以我决定以这种方式实现交叉:在[0，NUM_QUEENS]之间生成ρ-1个随机交叉点。使用这些交叉点，我们将生成由ρ个亲本组合而成的后代的排列。给定x个父母，就会有x个选择ρ * ρ！后代。在下面的代码中，我定义了MIXING_NUMBER = 2。</p><pre class="jf jg jh ji fd jw jx jy jz aw ka bi"><span id="14a4" class="kb kc hi jx b fi kd ke l kf kg">import itertools</span><span id="6d8f" class="kb kc hi jx b fi ki ke l kf kg">def crossover(parents):<br/>    <br/>    #random indexes to to cross states with<br/>    cross_points = random.sample(range(NUM_QUEENS), MIXING_NUMBER - 1)<br/>    offsprings = []<br/>    <br/>    #all permutations of parents<br/>    permutations = list(itertools.permutations(parents, MIXING_NUMBER))<br/>    <br/>    for perm in permutations:<br/>        offspring = []<br/>        <br/>        #track starting index of sublist<br/>        start_pt = 0<br/>        <br/>        for parent_idx, cross_point in enumerate(cross_points):    #doesn't account for last parent<br/>            <br/>            #sublist of parent to be crossed<br/>            parent_part = perm[parent_idx][start_pt:cross_point]<br/>            offspring.append(parent_part)<br/>            <br/>            #update index pointer<br/>            start_pt = cross_point<br/>            <br/>        #last parent<br/>        last_parent = perm[-1]<br/>        parent_part = last_parent[cross_point:]<br/>        offspring.append(parent_part)<br/>        <br/>        #flatten the list since append works kinda differently<br/>        offsprings.append(list(itertools.chain(*offspring)))<br/>    <br/>    return offsprings</span></pre><p id="c19a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">最后是突变。对于序列中的每一个数，都有一个任意的突变率= 0.05，即变成一个不同的数。</p><pre class="jf jg jh ji fd jw jx jy jz aw ka bi"><span id="f085" class="kb kc hi jx b fi kd ke l kf kg">def mutate(seq):<br/>    for row in range(len(seq)):<br/>        if random.random() &lt; MUTATION_RATE:<br/>            seq[row] = random.randrange(NUM_QUEENS)<br/>    <br/>    return seq</span></pre><p id="68dd" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">使用我们编写的函数，我在参数POPULATION_SIZE = 10、NUM_QUEENS = 8、MIXING_NUMBER = 2和MUTATION_RATE = 0.05上测试了该算法。以下是试运行的初始群体:</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div class="er es kj"><img src="../Images/1d98e80658771159a0072b75831db328.png" data-original-src="https://miro.medium.com/v2/resize:fit:802/format:webp/1*-ZFag96yP0hXhzfXCfadWw.png"/></div></figure><p id="594f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">当我生成随机人群时，我没有想到适应度分数会这么高。最高分是22分，离28分的目标只差6分。为了检查我是否只是运气好，我随机生成了100，000个棋盘状态，得到的平均健康分数为20.13518，标准差为2.3889，所以22是正常的。</p><p id="9643" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">运行算法后，在第162代上找到了解。这出乎意料地快，所以我试着再运行一次。这一次，差不多用了3000代。我的猜测是，一个随机的正向突变可能发生在加速进化或幸运重组的过程中。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div class="er es kk"><img src="../Images/75fb9c7acef2d764741d8a4ffddb9ee0.png" data-original-src="https://miro.medium.com/v2/resize:fit:762/format:webp/1*mBGzU2dOqBn59sq56Ndb-Q.png"/></div></figure><p id="5fab" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">运行该算法200次，我获得了以下统计数据:3813.53代的平均值和27558.146的标准偏差。看标准差，很明显，出了问题。最高世代为377241，最低世代为10。至于377241异常值，我猜测种群中有一些个体具有高适应值，但在棋盘上有重复的位置，导致重组的变异很低，因此算法必须依靠突变来摆脱死锁。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div class="er es kl"><img src="../Images/a4afd26d70ac7d41c8b0dd9e41de7307.png" data-original-src="https://miro.medium.com/v2/resize:fit:606/format:webp/1*yke1ymj5vB75FBJRREcjRw.png"/></div></figure><figure class="jf jg jh ji fd jj er es paragraph-image"><div class="er es km"><img src="../Images/b630e65caad429d0267077d2be0d1ed7.png" data-original-src="https://miro.medium.com/v2/resize:fit:586/format:webp/1*SOkYXAQAZfbQ41Acz5d6zA.png"/></div></figure><p id="9572" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果我们看看第一季度和第三季度之间的结果，我们的均值和标准差不会太远。当我使用异常值移除函数从<a class="ae jd" href="https://stackoverflow.com/questions/11686720/is-there-a-numpy-builtin-to-reject-outliers-from-a-list" rel="noopener ugc nofollow" target="_blank">堆栈溢出</a>中调整结果时，距离中值的中值小于值m=2，统计数据看起来更有希望。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="er es kn"><img src="../Images/9fc69f37569dde4ef70bab02fb0c42c6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XkS6GNpQRJdGAeHPmvTPJg.png"/></div></div><figcaption class="jm jn et er es jo jp bd b be z dx translated">虚线是平均值</figcaption></figure><p id="815f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果我们看一个猜测正确解的纯蛮力方法，假设生成个体时是正态分布，得到解的概率大概是P(解)= 0.0005。猜对答案的概率是0.5，大约需要1386代，或者0.95的概率需要5990代。与平均值280相比，遗传算法平均要快21倍。总之，使用遗传算法是解决8皇后问题的一种方法。</p><p id="4eb7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">总的来说，这个实验是探索遗传算法的一种有趣的方式。客观地说，我不认为遗传算法是解决8皇后问题的最好方法，而且我怀疑学术束搜索会更有效。如果我们在混合棋盘状态和放置皇后的背景下观察重组，它确实看起来像是随机产生的后代，而不是“更强”的后代。我认为我可以进一步探索的一些其他实验将会看到算法对N个皇后的作用，或者增加混合数，这将产生更多随机的后代。</p><p id="b18b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">代码可在:<a class="ae jd" href="https://github.com/chengxi600/RLStuff/blob/master/Genetic%20Algorithms/8Queens_GA.ipynb" rel="noopener ugc nofollow" target="_blank">https://github . com/cheng i600/rl stuff/blob/master/Genetic % 20 algorithms/8 queens _ ga . ipynb</a>获得</p></div></div>    
</body>
</html>