<html>
<head>
<title>You probably don’t want that concurrency for speed in Go</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">您可能不希望在 Go 中为了速度而使用并发</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/you-probably-dont-want-that-concurrency-in-go-109421e8d23?source=collection_archive---------6-----------------------#2021-05-25">https://medium.com/nerd-for-tech/you-probably-dont-want-that-concurrency-in-go-109421e8d23?source=collection_archive---------6-----------------------#2021-05-25</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><h1 id="9b6f" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">序幕</h1><p id="4409" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">我有机会回顾了一些提交给我公司不同资历的开发人员职位的技术挑战。挑战是写一个简单的命令行实用程序，并在 Go。我不会透露细节，但它涉及到对多个“东西”进行迭代，并对每个“东西”做一些事情。</p><p id="cc9d" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">令我惊讶的是，如此多的申请人在挑战中使用并发性，以努力并行工作。挑战没有要求优化最佳运行时间，并且<em class="kg">肯定</em>没有要求并行性(尽管我们将大部分方向留给了申请人的自由)。这让我不禁好奇，“为什么会这样？”。</p><p id="330d" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">我很快就能得出结论——<strong class="jf hj">因为 Go 中的并发性是<em class="kg">所以</em>容易</strong>。</p><p id="3aab" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">如果挑战是在 Python 中，他们会使用<code class="du kh ki kj kk b">multiprocessing</code>或<code class="du kh ki kj kk b">asyncio</code>库吗？如果是在 Java 里，他们会用<code class="du kh ki kj kk b">ExecutorService</code>吗？我不是这些语言的专家，但我对此表示怀疑。</p><p id="6557" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">从心理学的角度来看，我其实可以理解他们。即使在围棋中，并发也是一个相对高级的概念，我们可以在技术挑战中更好地表达我们的知识，对吗？:)我过去也站在那一边，也为在围棋中学会这样的优雅而激动不已。不幸的是，在这种情况下，它给我留下了相反的印象。</p><h1 id="8bfe" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">真实交易</h1><p id="c11e" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">好吧，那交易是什么？使用并发性有什么问题，我是说你永远不应该使用它吗？</p><p id="abfc" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">当我想到并发时，人们可能想使用它有两个主要原因:</p><ul class=""><li id="c20e" class="kl km hi jf b jg kb jk kc jo kn js ko jw kp ka kq kr ks kt bi translated">不能按顺序完成的事情或者更复杂的事情</li><li id="7ee3" class="kl km hi jf b jg ku jk kv jo kw js kx jw ky ka kq kr ks kt bi translated">运行时性能</li></ul><p id="da23" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">这里我们就讲第二个。</p><p id="549a" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">事实是，并发程序比顺序程序引入了更多的复杂性。而且在很多时候，<strong class="jf hj">性能的轻微提升并不值得它所换取的可读性。</strong></p><p id="b919" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">并发程序也伴随着死锁、灵活性降低和其他并发错误的风险。总的来说，它对可维护性有相当大的影响。</p><p id="f434" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">但是如果你仍然想做呢？</p><h1 id="5505" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">真的会更快吗？</h1><p id="4bb6" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">最近我有机会看了一下<a class="ae kz" href="https://golang.org/pkg/io/#MultiWriter" rel="noopener ugc nofollow" target="_blank"> io 的源代码。多作者</a>。</p><p id="ddbd" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">它可用于将相同的数据写入多个 IO 目的地。例如，在处理<a class="ae kz" href="https://github.com/sanggonlee/plum" rel="noopener ugc nofollow" target="_blank"> plum </a>时，我需要将一个 JSON 流写到三个目的地:WebSocket 连接、一个文件和 STDOUT(用于日志记录)。</p><p id="c0af" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">看到 io 的源代码如此简单，您可能会感到惊讶。MultiWriter 的<code class="du kh ki kj kk b">Write</code>方法是:</p><figure class="lb lc ld le fd lf er es paragraph-image"><div class="er es la"><img src="../Images/e5dbe8d3a7395cba2807b4507b3c0688.png" data-original-src="https://miro.medium.com/v2/resize:fit:1166/format:webp/1*fpt0B3bUX9btKyhw4J_3TQ.png"/></div><figcaption class="li lj et er es lk ll bd b be z dx translated">来源:https://golang.org/src/io/multi.go?#L58<a class="ae kz" href="https://golang.org/src/io/multi.go?#L58" rel="noopener ugc nofollow" target="_blank"/></figcaption></figure><p id="231f" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">它只是迭代多个编写器并调用它们的<code class="du kh ki kj kk b">Write</code>方法。</p><p id="475d" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">但是哦不！是顺序的！难道我们不应该并行运行它们以获得尽可能高的性能吗，因为写入字节可能会很昂贵？您应该在 Go source repository 中创建一个 pull 请求来解决这个问题吗？</p><p id="1bfb" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">不需要，我为此创建了一个包:<a class="ae kz" href="https://github.com/sanggonlee/not_so_impressive_go/blob/master/asyncwriter/multi_writer.go" rel="noopener ugc nofollow" target="_blank"> AsyncMultiWriter </a>。它与 MultiWriter 完全相同，只是每个 Writer 上的<code class="du kh ki kj kk b">Write</code>是并发执行的。</p><p id="5616" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">以下是 AsyncMultiWriter 和 MultiWriter 之间的基准测试结果，共有 3 个编写器:</p><pre class="lb lc ld le fd lm kk ln lo aw lp bi"><span id="e114" class="lq ig hi kk b fi lr ls l lt lu">BenchmarkAsyncMultiWriter_Write_3_writers-8       596774             21188 ns/op</span><span id="7922" class="lq ig hi kk b fi lv ls l lt lu">BenchmarkMultiWriter_Write_3_writers-8            595705             18871 ns/op</span><span id="0df1" class="lq ig hi kk b fi lv ls l lt lu">BenchmarkAsyncMultiWriter_Write_8_writers-8       150171             66789 ns/op</span><span id="050c" class="lq ig hi kk b fi lv ls l lt lu">BenchmarkMultiWriter_Write_8_writers-8            267482             63881 ns/op</span><span id="65a2" class="lq ig hi kk b fi lv ls l lt lu">BenchmarkAsyncMultiWriter_Write_20_writers-8       76065            227821 ns/op</span><span id="473c" class="lq ig hi kk b fi lv ls l lt lu">BenchmarkMultiWriter_Write_20_writers-8            72504            175907 ns/op</span></pre><p id="55a6" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">对于少于 8 个写入者，并行版本比顺序版本慢<em class="kg"/>。</p><p id="32e5" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">怎么会这样呢？</p><ul class=""><li id="3760" class="kl km hi jf b jg kb jk kc jo kn js ko jw kp ka kq kr ks kt bi translated">首先，每个操作没有<em class="kg">那么</em>昂贵(写大约 3.6KB)。如果要写的数据更大，异步版本的性能会更好(本杰明·巴罗斯指出了这一点，值得称赞)。</li><li id="1684" class="kl km hi jf b jg ku jk kv jo kw js kx jw ky ka kq kr ks kt bi translated">第二，并发的 CPU 密集型工作可能没有你想象的那么好。性能提升来自于通过并行方式利用多个内核。但也来源于 go routine 之间的屈服(即<a class="ae kz" href="https://en.wikipedia.org/wiki/Coroutine" rel="noopener ugc nofollow" target="_blank">协程</a>)。在这种情况下，每个操作都将忙于写数据，没有机会让位于其他 goroutines。</li><li id="c225" class="kl km hi jf b jg ku jk kv jo kw js kx jw ky ka kq kr ks kt bi translated">第三，进程间的通信总会有开销——例如同步、访问共享资源等。这对于小规模的运营尤其不利。</li></ul><p id="6358" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">第二点告诉我们，当您运行多个<em class="kg">阻塞操作</em>时，您将从并发性中获益更多。例如，假设您正在为昂贵的 API 发送多个 HTTP 请求。并发运行它们会有所帮助，因为当一个进程等待响应并空闲时，它可以进行上下文切换，并将 CPU 用于其他进程。</p><h1 id="cf40" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">外卖食品</h1><p id="ef4a" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">以下是 TLDRs:</p><ul class=""><li id="b984" class="kl km hi jf b jg kb jk kc jo kn js ko jw kp ka kq kr ks kt bi translated">在诉诸并发之前，先采用更简单、可读性更强的解决方案。</li><li id="e440" class="kl km hi jf b jg ku jk kv jo kw js kx jw ky ka kq kr ks kt bi translated">如果您确实需要优化性能，请始终进行基准测试。根据各种输入参数对顺序版本和并发版本进行基准测试。根据要处理的项目数量以及处理每个项目的成本，结果可能会有很大差异。</li><li id="70d7" class="kl km hi jf b jg ku jk kv jo kw js kx jw ky ka kq kr ks kt bi translated">关于何时使用并发的一个很好的经验法则是:每个进程会阻塞(空闲等待)很长时间吗？</li></ul><p id="aea1" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">如果你还没有这样做，我强烈推荐你观看罗布·派克的演讲。这是一个令人惊叹的演讲，如果你对并发性的理解不是 100%，你会学到很多东西。</p><p id="1b58" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">感谢您的阅读。</p></div></div>    
</body>
</html>