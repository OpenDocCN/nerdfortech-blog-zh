<html>
<head>
<title>Linked-List in Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python中的链表</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/linked-list-in-python-e61552fec1a4?source=collection_archive---------4-----------------------#2021-09-26">https://medium.com/nerd-for-tech/linked-list-in-python-e61552fec1a4?source=collection_archive---------4-----------------------#2021-09-26</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/3a185395074216f2f2a0c9e1fc020ebc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cGfM4ZJg_gBU12lXEqGfdA.jpeg"/></div></div></figure><p id="1144" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">Python使用List作为动态数组来存储数据。列表在连续内存位置存储数据。在列表开头插入和删除元素的复杂度为O(n)。因为这些操作需要整个元素列表向前移动一个位置。</p><p id="a98f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">列表算法复杂度:</strong></p><pre class="jo jp jq jr fd js jt ju jv aw jw bi"><span id="e4f0" class="jx jy hi jt b fi jz ka l kb kc">Find by Index : O(1)<br/>Find by Value : O(n)<br/>Traversal : O(n)<br/>Insert Element : O(n)<br/>Delete Element : O(n)</span></pre><p id="fc09" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">为了解决这个问题，有另一种线性数据结构——链表。链表存储分散位置的数据，使用引用指针指向下一个元素。链表的每个节点都包含数据和对下一个节点的引用。头指针用于引用第一个节点。在空链表的情况下，头指针指向null。</p><p id="4a38" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如果我们比较两者，链表比数组有两个主要优点。<br/> 1。您不需要预先分配空间。<br/> 2。插入/删除更容易</p><p id="5ba9" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">链表的算法复杂度:</strong></p><pre class="jo jp jq jr fd js jt ju jv aw jw bi"><span id="867b" class="jx jy hi jt b fi jz ka l kb kc">Insert Element at Beginning : O(1)<br/>Delete Element at Beginning : O(1)<br/>Insert/Delete Element at End : O(n)<br/>Traversal : O(n)<br/>Access Element by Value : O(n)</span></pre><p id="4f91" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在，让我们跳到编码部分，下面的操作在代码中是可用的。</p><ul class=""><li id="63df" class="kd ke hi is b it iu ix iy jb kf jf kg jj kh jn ki kj kk kl bi translated">访问第n个节点</li><li id="f0f0" class="kd ke hi is b it km ix kn jb ko jf kp jj kq jn ki kj kk kl bi translated">按值搜索元素</li><li id="3d48" class="kd ke hi is b it km ix kn jb ko jf kp jj kq jn ki kj kk kl bi translated">在开头插入</li><li id="7f16" class="kd ke hi is b it km ix kn jb ko jf kp jj kq jn ki kj kk kl bi translated">在末尾插入</li><li id="d251" class="kd ke hi is b it km ix kn jb ko jf kp jj kq jn ki kj kk kl bi translated">在指定索引处插入</li><li id="b06a" class="kd ke hi is b it km ix kn jb ko jf kp jj kq jn ki kj kk kl bi translated">在指定索引后插入</li><li id="6225" class="kd ke hi is b it km ix kn jb ko jf kp jj kq jn ki kj kk kl bi translated">在指定值后插入</li><li id="3820" class="kd ke hi is b it km ix kn jb ko jf kp jj kq jn ki kj kk kl bi translated">将列表转换为链接列表</li><li id="57b3" class="kd ke hi is b it km ix kn jb ko jf kp jj kq jn ki kj kk kl bi translated">获取链表的长度</li><li id="b191" class="kd ke hi is b it km ix kn jb ko jf kp jj kq jn ki kj kk kl bi translated">移除指定索引处的元素</li><li id="dc5b" class="kd ke hi is b it km ix kn jb ko jf kp jj kq jn ki kj kk kl bi translated">按值删除</li></ul><figure class="jo jp jq jr fd ij"><div class="bz dy l di"><div class="kr ks l"/></div></figure><p id="4d33" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">链表有以下缺点:<br/> 1-不允许随机访问，需要顺序遍历才能访问元素。<br/> 2-需要额外的内存空间来存储next_node指针。<br/> 3阵列具有更好的缓存局部性，性能更高。</p></div></div>    
</body>
</html>