<html>
<head>
<title>LeetCode — Product of Array Except Self</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">LeetCode —除自身以外的数组乘积</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/leetcode-product-of-array-except-self-fb40b9fcafdb?source=collection_archive---------4-----------------------#2021-10-17">https://medium.com/nerd-for-tech/leetcode-product-of-array-except-self-fb40b9fcafdb?source=collection_archive---------4-----------------------#2021-10-17</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><h1 id="1f86" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">问题陈述</h1><p id="5645" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">给定一个整数数组<strong class="jf hj"> nums </strong>，返回<em class="kb">一个数组</em> <strong class="jf hj"> answer </strong>使得answer【I】<em class="kb">等于nums中除nums【I】</em>以外的所有元素的乘积。</p><p id="6c32" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated">nums的任何前缀或后缀的乘积<strong class="jf hj">保证</strong>适合32位整数。</p><p id="ad24" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated">您必须编写一个在不使用除法运算的情况下运行时间为O(n) 的算法。</p><p id="1ded" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated">问题陈述摘自:<a class="ae kh" href="https://leetcode.com/problems/product-of-array-except-self" rel="noopener ugc nofollow" target="_blank">https://leetcode.com/problems/product-of-array-except-self</a></p><p id="7b49" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated"><strong class="jf hj">例1: </strong></p><pre class="ki kj kk kl fd km kn ko kp aw kq bi"><span id="1247" class="kr ig hi kn b fi ks kt l ku kv">Input: nums = [1, 2, 3, 4] <br/>Output: [24, 12, 8, 6]</span></pre><p id="e1e2" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated"><strong class="jf hj">例2: </strong></p><pre class="ki kj kk kl fd km kn ko kp aw kq bi"><span id="5913" class="kr ig hi kn b fi ks kt l ku kv">Input: nums = [-1, 1, 0, -3, 3] <br/>Output: [0, 0, 9, 0, 0]</span></pre><p id="02c8" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated"><strong class="jf hj">约束:</strong></p><pre class="ki kj kk kl fd km kn ko kp aw kq bi"><span id="991e" class="kr ig hi kn b fi ks kt l ku kv">- 2 &lt;= nums.length &lt;= 10^5 - <br/>-30 &lt;= nums[i] &lt;= 30 <br/>- The product of any prefix or suffix of nums is guaranteed to fit in a 32-bit integer.</span></pre><p id="5d76" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated"><strong class="jf hj">跟进</strong>:你能解决O(1)额外空间复杂度的问题吗？(输出数组不作为空间复杂度分析的额外空间。)</p><h1 id="2bf5" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">说明</h1><h2 id="ab3e" class="kr ig hi bd ih kw kx ky il kz la lb ip jo lc ld it js le lf ix jw lg lh jb li bi translated">强力方法</h2><p id="f78f" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">根据问题陈述，我们不能使用除法运算符。我们可以想到的第一种方法是使用两个嵌套的for循环，并在索引不匹配时将这两个数字相乘。</p><p id="6b65" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated">上述解决方案的一小段C++代码如下所示:</p><pre class="ki kj kk kl fd km kn ko kp aw kq bi"><span id="97b1" class="kr ig hi kn b fi ks kt l ku kv">vector&lt;int&gt; answer(nums.size(), 0);<br/><br/>for(int i = 0; i &lt; nums.size(); i++){<br/>    product = 1;<br/><br/>    for(int j = 0; j &lt; nums.size(); j++){<br/>        if(i != j){<br/>            product *= nums[j];<br/>        }<br/>    }<br/><br/>    answer[i] = product;<br/>}</span></pre><p id="b932" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated">上述方法的问题是时间复杂性。上述方法的时间复杂度为<strong class="jf hj"> O(N ) </strong>。</p><h2 id="b482" class="kr ig hi bd ih kw kx ky il kz la lb ip jo lc ld it js le lf ix jw lg lh jb li bi translated">划一减税办法</h2><p id="68c2" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">我们可以通过从左到右和从右到左计算元素的乘积，将上面的解优化为<strong class="jf hj"> O(N) </strong>。</p><p id="b3b7" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated">让我们检查一下算法</p><pre class="ki kj kk kl fd km kn ko kp aw kq bi"><span id="a930" class="kr ig hi kn b fi ks kt l ku kv">- initialize vector&lt;int&gt;answer, i<br/>- set product = 1<br/><br/>- loop for i = 0; i &lt; nums.size(); i++<br/>  - append answer.push_back(product)<br/>  - set product = product * nums[i]<br/><br/>- reset product = 1<br/><br/>- loop for i = nums.size() - 1; i &gt;= 0; i--<br/>  - set answer[i] = answer[i]*product<br/>  - product *= nums[i]<br/><br/>- return answer</span></pre><h2 id="9927" class="kr ig hi bd ih kw kx ky il kz la lb ip jo lc ld it js le lf ix jw lg lh jb li bi translated">C++解决方案</h2><pre class="ki kj kk kl fd km kn ko kp aw kq bi"><span id="467b" class="kr ig hi kn b fi ks kt l ku kv">class Solution {<br/>public:<br/>    vector&lt;int&gt; productExceptSelf(vector&lt;int&gt;&amp; nums) {<br/>        vector&lt;int&gt; answer;<br/>        int product = 1, i;<br/><br/>        for(i = 0; i &lt; nums.size(); i++){<br/>            answer.push_back(product);<br/>            product *= nums[i];<br/>        }<br/><br/>        product = 1;<br/>        for(i = nums.size() - 1; i &gt;= 0; i--){<br/>            answer[i] *= product;<br/>            product *= nums[i];<br/>        }<br/><br/>        return answer;<br/>    }<br/>};</span></pre><h2 id="46d1" class="kr ig hi bd ih kw kx ky il kz la lb ip jo lc ld it js le lf ix jw lg lh jb li bi translated">戈朗溶液</h2><pre class="ki kj kk kl fd km kn ko kp aw kq bi"><span id="bc71" class="kr ig hi kn b fi ks kt l ku kv">func productExceptSelf(nums []int) []int {<br/>    answer := make([]int, len(nums))<br/>    product := 1<br/><br/>    for i := 0; i &lt; len(nums); i++ {<br/>        answer[i] = product<br/>        product *= nums[i]<br/>    }<br/><br/>    product = 1<br/><br/>    for i := len(nums) - 1; i &gt;= 0; i-- {<br/>        answer[i] *= product<br/>        product *= nums[i]<br/>    }<br/><br/>    return answer<br/>}</span></pre><h2 id="bae4" class="kr ig hi bd ih kw kx ky il kz la lb ip jo lc ld it js le lf ix jw lg lh jb li bi translated">Javascript解决方案</h2><pre class="ki kj kk kl fd km kn ko kp aw kq bi"><span id="d3c6" class="kr ig hi kn b fi ks kt l ku kv">var productExceptSelf = function(nums) {<br/>    var answer = [];<br/>    let product = 1;<br/><br/>    for(let i = 0; i &lt; nums.length; i++){<br/>        answer[i] = product;<br/>        product *= nums[i];<br/>    }<br/><br/>    product = 1;<br/><br/>    for(let i = nums.length - 1; i &gt;= 0; i--){<br/>        answer[i] *= product;<br/>        product *= nums[i];<br/>    }<br/><br/>    return answer;<br/>};</span></pre><p id="0410" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated">让我们试运行一下我们的算法，看看解决方案是如何工作的。</p><pre class="ki kj kk kl fd km kn ko kp aw kq bi"><span id="f944" class="kr ig hi kn b fi ks kt l ku kv">Input: nums = [1, 2, 3, 4]<br/><br/>Step 1: vector&lt;int&gt; answer<br/>        int product = 1, i<br/><br/>Step 2: loop for i = 0; i &lt; nums.size()<br/>        0 &lt; 4<br/>        true<br/><br/>        answer.push_back(product)<br/>        answer.push_back(1)<br/>        answer = [1]<br/><br/>        product *= nums[i]<br/>        product = product * nums[0]<br/>                = 1 * 1<br/>                = 1<br/><br/>        i++<br/>        i = 1<br/><br/>Step 3: loop for i &lt; nums.size()<br/>        1 &lt; 4<br/>        true<br/><br/>        answer.push_back(product)<br/>        answer.push_back(1)<br/>        answer = [1, 1]<br/><br/>        product *= nums[i]<br/>        product = product * nums[1]<br/>                = 1 * 2<br/>                = 2<br/><br/>        i++<br/>        i = 2<br/><br/>Step 4: loop for i &lt; nums.size()<br/>        2 &lt; 4<br/>        true<br/><br/>        answer.push_back(product)<br/>        answer.push_back(2)<br/>        answer = [1, 1, 2]<br/><br/>        product *= nums[i]<br/>        product = product * nums[2]<br/>                = 2 * 3<br/>                = 6<br/><br/>        i++<br/>        i = 3<br/><br/>Step 5: loop for i &lt; nums.size()<br/>        3 &lt; 4<br/>        true<br/><br/>        answer.push_back(product)<br/>        answer.push_back(6)<br/>        answer = [1, 1, 2, 6]<br/><br/>        product *= nums[i]<br/>        product = product * nums[3]<br/>                = 6 * 4<br/>                = 24<br/><br/>        i++<br/>        i = 4<br/><br/>Step 6: loop for i &lt; nums.size()<br/>        4 &lt; 4<br/>        false<br/><br/>Step 7: product = 1<br/><br/>Step 8: loop for i = nums.size() - 1; i &gt;= 0<br/>        i = 4 - 1 = 3<br/>        i &gt;= 0<br/>        3 &gt;= 0<br/>        true<br/><br/>        answer[i] *= product<br/>                  = answer[3] * product<br/>                  = 6 * 1<br/>                  = 6<br/><br/>        product *= nums[i]<br/>                 = product * nums[3]<br/>                 = 1 * 4<br/>                 = 4<br/><br/>        i--<br/>        i = 2<br/><br/>Step 9: loop for i &gt;= 0<br/>        2 &gt;= 0<br/>        true<br/><br/>        answer[i] *= product<br/>                  = answer[2] * product<br/>                  = 2 * 4<br/>                  = 8<br/><br/>        product *= nums[i]<br/>                 = product * nums[2]<br/>                 = 4 * 3<br/>                 = 12<br/><br/>        i--<br/>        i = 1<br/><br/>Step 10: loop for i &gt;= 0<br/>        1 &gt;= 0<br/>        true<br/><br/>        answer[i] *= product<br/>                  = answer[1] * product<br/>                  = 1 * 12<br/>                  = 12<br/><br/>        product *= nums[i]<br/>                 = product * nums[1]<br/>                 = 12 * 2<br/>                 = 24<br/><br/>        i--<br/>        i = 0<br/><br/>Step 11: loop for i &gt;= 0<br/>        0 &gt;= 0<br/>        true<br/><br/>        answer[i] *= product<br/>                  = answer[0] * product<br/>                  = 1 * 24<br/>                  = 24<br/><br/>        product *= nums[i]<br/>                 = product * nums[0]<br/>                 = 24 * 1<br/>                 = 24<br/><br/>        i--<br/>        i = -1<br/><br/>Step 12: loop for i &gt;= 0<br/>         -1 &gt;= 0<br/>         false<br/><br/>Step 13: return answer<br/><br/>So the answer is [24, 12, 8, 6]</span></pre></div><div class="ab cl lj lk gp ll" role="separator"><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo"/></div><div class="hb hc hd he hf"><p id="2cb0" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated"><em class="kb">原载于</em><a class="ae kh" href="https://alkeshghorpade.me/post/leetcode-product-of-array-except-self" rel="noopener ugc nofollow" target="_blank"><em class="kb">https://alkeshghorpade . me</em></a><em class="kb">。</em></p></div></div>    
</body>
</html>