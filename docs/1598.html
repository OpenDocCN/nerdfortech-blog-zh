<html>
<head>
<title>How to write or understand performant code in React Web Application</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在 React Web 应用程序中编写或理解性能代码</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/how-to-write-or-understand-performant-code-react-web-application-for-beginners-bdea8157abeb?source=collection_archive---------10-----------------------#2021-03-27">https://medium.com/nerd-for-tech/how-to-write-or-understand-performant-code-react-web-application-for-beginners-bdea8157abeb?source=collection_archive---------10-----------------------#2021-03-27</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/8933e4fa3854e49902a096a7f2866351.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*y6C4nSvy2Woe0m7bWEn4BA.png"/></div></div></figure><p id="0e18" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">大家好，我是 Sachin Rawal，我是一名在行业中有十年经验的前沿技术专家。</p><p id="cda0" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我想分享我在 react 应用程序和工作方式方面的经验，以及如何提高性能。</p><p id="d196" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我想强调的第一件事是，我们不应该试图在开发后提高应用程序的性能，我的意思是，我们应该总是试图实现<strong class="is hj">高性能代码，</strong>要么你先编写更好的代码，要么以后修复它，但无论如何你必须在性能上努力。</p><p id="e7df" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如今，每一个寻求快速渲染和快速渲染的客户不仅仅是指 FCP(第一幅内容丰富的画)或 TTI(互动时间)</p><p id="b3d4" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们通常会忽略许多其他方面，例如 CLS(累积布局偏移)，这是一种没有用户交互的布局偏移，CLS 的原因是代码编写方式错误(我知道大多数人会说这是主观的，这是我们的要求，但下面的图片可以帮助您理解我所说的错误代码)</p></div><div class="ab cl jo jp gp jq" role="separator"><span class="jr bw bk js jt ju"/><span class="jr bw bk js jt ju"/><span class="jr bw bk js jt"/></div><div class="hb hc hd he hf"><p id="d929" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这是一只鸽子的形象，他打算飞！！</p><figure class="jw jx jy jz fd ij er es paragraph-image"><div class="er es jv"><img src="../Images/a7b776fed71148a00a6fc8ac4befd860.png" data-original-src="https://miro.medium.com/v2/resize:fit:498/format:webp/1*JRy-QxHLfI4X68vWkoPh3w.jpeg"/></div></figure><p id="d7f2" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在鸽子在飞，但这是正确的方式吗？</p><figure class="jw jx jy jz fd ij er es paragraph-image"><div class="er es ka"><img src="../Images/1fb878b27a2124961953d12bf29d6004.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*N-Na1Jz0vzfPTAMN0JO6oQ.jpeg"/></div></figure><p id="b017" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">这就是我对错误代码的理解。</strong></p><p id="1444" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在，我将为您提供一些提示/建议或信息，帮助您在发展前后提高绩效。</p></div><div class="ab cl jo jp gp jq" role="separator"><span class="jr bw bk js jt ju"/><span class="jr bw bk js jt ju"/><span class="jr bw bk js jt"/></div><div class="hb hc hd he hf"><h2 id="5f4d" class="kb kc hi bd kd ke kf kg kh ki kj kk kl jb km kn ko jf kp kq kr jj ks kt ku kv bi translated"><strong class="ak"> <em class="kw">第三方工具/插件或模块</em> </strong></h2><blockquote class="kx ky kz"><p id="467d" class="iq ir la is b it iu iv iw ix iy iz ja lb jc jd je lc jg jh ji ld jk jl jm jn hb bi translated">在添加任何插件之前，一定要考虑它是否真的需要，如果需要，一定要比较插件和它们的大小。</p><p id="3c64" class="iq ir la is b it iu iv iw ix iy iz ja lb jc jd je lc jg jh ji ld jk jl jm jn hb bi translated"><em class="hi">例如:你想实现数据格式化器，你唯一的需求是实现格式化的数据(明显考虑到项目的整体情况)</em></p><p id="2d1a" class="iq ir la is b it iu iv iw ix iy iz ja lb jc jd je lc jg jh ji ld jk jl jm jn hb bi translated"><em class="hi">您已经实现了 react-datetime(假设是下载量最大的)，现在运行良好，但是您是否比较或探索了其他选项？比如反应时刻，哪个比这个轻？</em></p></blockquote><h2 id="2b88" class="kb kc hi bd kd ke kf kg kh ki kj kk kl jb km kn ko jf kp kq kr jj ks kt ku kv bi translated"><strong class="ak"> <em class="kw">功能实现</em> </strong></h2><blockquote class="kx ky kz"><p id="5ce1" class="iq ir la is b it iu iv iw ix iy iz ja lb jc jd je lc jg jh ji ld jk jl jm jn hb bi translated"><em class="hi">总是调用函数，而不是内联编写，例如:</em></p><p id="0b10" class="iq ir la is b it iu iv iw ix iy iz ja lb jc jd je lc jg jh ji ld jk jl jm jn hb bi translated"><em class="hi">避免这种:<br/> </em> <strong class="is hj"> <em class="hi"> &lt;按钮 onClick = {()=&gt;setShow(true)}&gt;点击我&lt;/按钮&gt; </em> </strong></p><p id="e0ab" class="iq ir la is b it iu iv iw ix iy iz ja lb jc jd je lc jg jh ji ld jk jl jm jn hb bi translated">用这个:<br/> <strong class="is hj"> <em class="hi"> &lt;按钮 onClick={this.handleClick} &gt;点击我&lt;/按钮&gt; </em> </strong></p><p id="6e70" class="iq ir la is b it iu iv iw ix iy iz ja lb jc jd je lc jg jh ji ld jk jl jm jn hb bi translated"><strong class="is hj"> <em class="hi">原因</em> </strong> <em class="hi">:函数是一类具有特殊属性的对象，因此 react 无法对其进行比较。</em></p></blockquote><h2 id="14d5" class="kb kc hi bd kd ke kf kg kh ki kj kk kl jb km kn ko jf kp kq kr jj ks kt ku kv bi translated">使用数组属性，如映射、过滤器等</h2><blockquote class="kx ky kz"><p id="6967" class="iq ir la is b it iu iv iw ix iy iz ja lb jc jd je lc jg jh ji ld jk jl jm jn hb bi translated"><em class="hi">在使用</em><strong class="is hj"><em class="hi">map</em></strong><em class="hi">的时候，我们不应该把 index 作为一个 key 来传递，让我们用例子来试着理解一下。</em></p></blockquote><figure class="jw jx jy jz fd ij er es paragraph-image"><div class="er es le"><img src="../Images/fc0168aec412ebbf2d446bb823c8285b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1266/1*he6guawxBMx1JUqI1NrzqQ.gif"/></div></figure><blockquote class="kx ky kz"><p id="342c" class="iq ir la is b it iu iv iw ix iy iz ja lb jc jd je lc jg jh ji ld jk jl jm jn hb bi translated"><em class="hi">在上面的 gif 中，我在购物车中添加了 3 件带有地图的产品，它们的索引像是 1-2-3，现在我删除了第二件产品</em> <strong class="is hj"> <em class="hi">索引</em> </strong> <em class="hi">应该是 1-2，对吗？</em></p><p id="da0b" class="iq ir la is b it iu iv iw ix iy iz ja lb jc jd je lc jg jh ji ld jk jl jm jn hb bi translated"><em class="hi">但这是不对的，因为我们删除了第二个产品，它不应该更新第三个产品的索引，因为现在第三个产品的索引是</em><strong class="is hj"><em class="hi">【2】</em></strong></p><p id="a896" class="iq ir la is b it iu iv iw ix iy iz ja lb jc jd je lc jg jh ji ld jk jl jm jn hb bi translated"><em class="hi">理想情况下应该是 1–3，因为我移除了第二个产品(我希望我的解释清楚)</em></p></blockquote><h2 id="6034" class="kb kc hi bd kd ke kf kg kh ki kj kk kl jb km kn ko jf kp kq kr jj ks kt ku kv bi translated">重新渲染问题</h2><blockquote class="kx ky kz"><p id="91ac" class="iq ir la is b it iu iv iw ix iy iz ja lb jc jd je lc jg jh ji ld jk jl jm jn hb bi translated"><em class="hi">不必要的渲染是任何开发人员或客户的眼中钉，为了避免这种情况，我们应该使用。</em></p></blockquote><h2 id="dc2c" class="kb kc hi bd kd ke kf kg kh ki kj kk kl jb km kn ko jf kp kq kr jj ks kt ku kv bi translated">避免在 props 中使用 spread 运算符</h2><blockquote class="kx ky kz"><p id="fea6" class="iq ir la is b it iu iv iw ix iy iz ja lb jc jd je lc jg jh ji ld jk jl jm jn hb bi translated"><em class="hi">避免使用导致重新渲染的不必要的道具例如:</em><strong class="is hj"><em class="hi">&lt;Component {…props }/&gt;<br/></em></strong>Use this:<br/><strong class="is hj">&lt;Component propval = { value } newpropval = { newpropval }/&gt;<em class="hi">Reason</em></strong><em class="hi">:通过这种方式发送道具，我们会发送不必要的未使用的道具，这些道具可能会导致重新渲染</em></p></blockquote><h2 id="312b" class="kb kc hi bd kd ke kf kg kh ki kj kk kl jb km kn ko jf kp kq kr jj ks kt ku kv bi translated"><strong class="ak">避免直列造型</strong></h2><blockquote class="kx ky kz"><p id="369e" class="iq ir la is b it iu iv iw ix iy iz ja lb jc jd je lc jg jh ji ld jk jl jm jn hb bi translated"><em class="hi">渲染时避免对象文字或渲染时的内联样式导致重新渲染，例如&lt;组件样式={{margin:0}} / &gt; </em></p></blockquote><h2 id="78ea" class="kb kc hi bd kd ke kf kg kh ki kj kk kl jb km kn ko jf kp kq kr jj ks kt ku kv bi translated"><em class="kw">服务器端渲染(NextJS ) </em></h2><blockquote class="kx ky kz"><p id="04fb" class="iq ir la is b it iu iv iw ix iy iz ja lb jc jd je lc jg jh ji ld jk jl jm jn hb bi translated"><em class="hi">在 SSR 的帮助下，你可以在服务器上生成你的网页，这样你的网页就会加载得很快，要了解 Nextjs 或 SSR，请查看这个:</em><a class="ae lf" href="https://nextjs.org/" rel="noopener ugc nofollow" target="_blank">https://nextjs.org/</a></p></blockquote><h2 id="8a83" class="kb kc hi bd kd ke kf kg kh ki kj kk kl jb km kn ko jf kp kq kr jj ks kt ku kv bi translated"><strong class="ak">使用动态导入(NextJS ) </strong></h2><blockquote class="kx ky kz"><p id="8eea" class="iq ir la is b it iu iv iw ix iy iz ja lb jc jd je lc jg jh ji ld jk jl jm jn hb bi translated"><em class="hi">正如我们所知，健壮应用程序的内容高度有点大，例如，您可以看到亚马逊列表页面的页面高度</em>这是亚马逊的主页(可见屏幕)</p></blockquote><figure class="jw jx jy jz fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lg"><img src="../Images/14c7d69b3f42bcfbae227e55e6fd31a3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NOtTc4zYTIaV0kGRtc55zQ.png"/></div></div></figure><p id="026a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在卷轴之后，有相当多的部分</p><figure class="jw jx jy jz fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lh"><img src="../Images/f471c91f454e45c53f75babf143873e1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MpERCC75XOXixfsk25J1Yg.png"/></div></div></figure><p id="44b4" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们不应该加载这些或在我们的可见页面中添加这些模块，无论是应该延迟加载还是作为动态导入加载，它也可以将代码分割成不同的块，并减少初始负载</p><h2 id="5ca4" class="kb kc hi bd kd ke kf kg kh ki kj kk kl jb km kn ko jf kp kq kr jj ks kt ku kv bi translated"><strong class="ak">检测不必要的重新渲染</strong></h2><blockquote class="kx ky kz"><p id="4969" class="iq ir la is b it iu iv iw ix iy iz ja lb jc jd je lc jg jh ji ld jk jl jm jn hb bi translated">还有一个更重要的插件 WHY-do-YOU-UPDATE——库检测不必要的组件渲染。具体来说，它指出了组件的 render 方法被调用的情况，即使没有发生变化</p></blockquote></div><div class="ab cl jo jp gp jq" role="separator"><span class="jr bw bk js jt ju"/><span class="jr bw bk js jt ju"/><span class="jr bw bk js jt"/></div><div class="hb hc hd he hf"><p id="57b2" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">不是这样的:)我们有 100 多种方法可以改进我们的 web 应用程序，但是通过这些，我们可以给它一个开始，并探索另一种改进的方法。</p><p id="24d8" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">感谢你阅读这篇文章。<br/>也许我错过了应该在列表中的，或者也许你的想法不同，因为所有的五个手指并不相等，对吗？我将非常感谢任何反馈</strong></p></div></div>    
</body>
</html>