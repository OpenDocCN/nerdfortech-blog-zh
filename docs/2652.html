<html>
<head>
<title>Understanding Threads in Java</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">理解Java中的线程</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/understanding-threads-in-java-1f5a074d5753?source=collection_archive---------2-----------------------#2021-05-15">https://medium.com/nerd-for-tech/understanding-threads-in-java-1f5a074d5753?source=collection_archive---------2-----------------------#2021-05-15</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/047c6c1ea1b804549816eff94cefe567.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*PHV9FWVka0vMZeds"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">由<a class="ae iu" href="https://unsplash.com/@marusyaionova?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Maria Ionova </a>在<a class="ae iu" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a> B上拍摄的照片</figcaption></figure><h2 id="9935" class="iv iw hi bd ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js bi translated">什么是<strong class="ak">螺纹？？</strong></h2><p id="c2aa" class="pw-post-body-paragraph jt ju hi jv b jw jx jy jz ka kb kc kd jg ke kf kg jk kh ki kj jo kk kl km kn hb bi translated">这是通过进程代码执行<strong class="jv hj">的流程，进程可以包含多个线程，称为<strong class="jv hj">多线程。</strong>基本上它是一个多重执行流程。所以在某个时间运行多个任务。这是大多数人误解的地方，假设有一个运行10分钟的进程，并不能保证为这个进程创建10个线程会将时间减少到1分钟，因为在一个程序中可能会运行相关的任务。但是时间可以减少到7或8秒，这取决于过程。线程用于在后台执行复杂的任务，而不会干扰主进程。</strong></p><figure class="kp kq kr ks fd ij er es paragraph-image"><div class="er es ko"><img src="../Images/bdbe2fcf76199fa48f69c3845d1922d5.png" data-original-src="https://miro.medium.com/v2/resize:fit:562/format:webp/1*L2hjJPJHZlTOs07L-Wuubw.jpeg"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">多任务处理</figcaption></figure><p id="0e36" class="pw-post-body-paragraph jt ju hi jv b jw kt jy jz ka ku kc kd jg kv kf kg jk kw ki kj jo kx kl km kn hb bi translated">如上图所示，有两种类型的多线程。在基于过程的环境中，比方说，程序员通常边编码边听音乐，有时他们可能会从互联网上下载任何文档。也就是说，他们同时在做多件事。这些任务是独立的，如果上述进程中的一个被终止(关闭程序)，不会影响其中任何一个。在基于线程的多任务处理中，每个线程都属于同一个主进程。通常一个主线程会被分成多个任务。假设100分钟内要处理100个文件。通过使用两个线程，这些过程可能在不到100分钟内完成。但是没有办法通过增加线程的数量来帮助在1秒钟内或在任何时间内完成任务。因为拿同一个文件反复处理是没有意义的。这个解释只是为了澄清，而不是真实的生活场景，它只是线程及其局限性的一个基本概念。</p><h1 id="f373" class="ky iw hi bd ix kz la lb jb lc ld le jf lf lg lh jj li lj lk jn ll lm ln jr lo bi translated">线程生命周期</h1><figure class="kp kq kr ks fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lp"><img src="../Images/fd951a0b54ebd7315f65d3b6cefa1ce3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kNkBnKP2QAqNsGnlqkJhHw.jpeg"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">(图片:baeldung.com)</figcaption></figure><p id="ca78" class="pw-post-body-paragraph jt ju hi jv b jw kt jy jz ka ku kc kd jg kv kf kg jk kw ki kj jo kx kl km kn hb bi translated">在生命周期中，有7种状态。让我们讨论一下，</p><h2 id="71d8" class="iv iw hi bd ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js bi translated">新的</h2><p id="633b" class="pw-post-body-paragraph jt ju hi jv b jw jx jy jz ka kb kc kd jg ke kf kg jk kh ki kj jo kk kl km kn hb bi translated">这是创建线程的状态。</p><h2 id="7373" class="iv iw hi bd ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js bi translated">就绪/可运行</h2><p id="e971" class="pw-post-body-paragraph jt ju hi jv b jw jx jy jz ka kb kc kd jg ke kf kg jk kh ki kj jo kk kl km kn hb bi translated">当<code class="du lq lr ls lt b">start()</code>方法被调用到特定线程时，它将从<strong class="jv hj">新</strong>状态切换到<strong class="jv hj">就绪或可运行</strong>状态</p><h2 id="7480" class="iv iw hi bd ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js bi translated">运转</h2><p id="5861" class="pw-post-body-paragraph jt ju hi jv b jw jx jy jz ka kb kc kd jg ke kf kg jk kh ki kj jo kk kl km kn hb bi translated">当调用<code class="du lq lr ls lt b">run()</code>方法时，线程将切换到运行状态。这意味着当进程执行时。但是它可能会回到就绪/可运行状态，然后回到运行状态，这种情况也可能会一次又一次地发生。</p><h2 id="9bf5" class="iv iw hi bd ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js bi translated">堵塞的</h2><p id="6236" class="pw-post-body-paragraph jt ju hi jv b jw jx jy jz ka kb kc kd jg ke kf kg jk kh ki kj jo kk kl km kn hb bi translated">这是一个线程阻塞锁的状态，因为另一个线程已经获得了这个锁。</p><h2 id="fad6" class="iv iw hi bd ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js bi translated">等待</h2><p id="99c4" class="pw-post-body-paragraph jt ju hi jv b jw jx jy jz ka kb kc kd jg ke kf kg jk kh ki kj jo kk kl km kn hb bi translated">在这种状态下，线程将永远等待，直到出现任何中断。通常调用<code class="du lq lr ls lt b">join()</code>或<code class="du lq lr ls lt b">wait()</code>方法会将线程置于等待状态。</p><h2 id="6242" class="iv iw hi bd ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js bi translated">定时等待</h2><p id="3484" class="pw-post-body-paragraph jt ju hi jv b jw jx jy jz ka kb kc kd jg ke kf kg jk kh ki kj jo kk kl km kn hb bi translated">当调用<code class="du lq lr ls lt b">sleep()</code>方法或<code class="du lq lr ls lt b">join()</code>或<code class="du lq lr ls lt b">wait()</code>方法时，这种状态称为<strong class="jv hj">定时等待。</strong>名字本身说明了线程将等待某个给定的时间。</p><h2 id="a7a6" class="iv iw hi bd ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js bi translated">死亡的</h2><p id="30db" class="pw-post-body-paragraph jt ju hi jv b jw jx jy jz ka kb kc kd jg ke kf kg jk kh ki kj jo kk kl km kn hb bi translated">这种状态代表过程的完成。</p></div><div class="ab cl lu lv gp lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="hb hc hd he hf"><h1 id="c32d" class="ky iw hi bd ix kz mb lb jb lc mc le jf lf md lh jj li me lk jn ll mf ln jr lo bi translated">如何用Java创建一个线程？</h1><p id="7c71" class="pw-post-body-paragraph jt ju hi jv b jw jx jy jz ka kb kc kd jg ke kf kg jk kh ki kj jo kk kl km kn hb bi translated">在Java中，有两种创建线程的方法，</p><ul class=""><li id="c487" class="mg mh hi jv b jw kt ka ku jg mi jk mj jo mk kn ml mm mn mo bi translated">通过扩展线程类</li><li id="9bb9" class="mg mh hi jv b jw mp ka mq jg mr jk ms jo mt kn ml mm mn mo bi translated">通过实现可运行接口</li></ul><p id="cab0" class="pw-post-body-paragraph jt ju hi jv b jw kt jy jz ka ku kc kd jg kv kf kg jk kw ki kj jo kx kl km kn hb bi translated">让我们一个一个检查一下，</p><h2 id="4269" class="iv iw hi bd ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js bi translated">扩展线程类</h2><p id="ddce" class="pw-post-body-paragraph jt ju hi jv b jw jx jy jz ka kb kc kd jg ke kf kg jk kh ki kj jo kk kl km kn hb bi translated">在这里，我将使用两个类。因此，要创建一个线程，我们需要用Thread类扩展Printer类，如下面的代码所示。</p><figure class="kp kq kr ks fd ij"><div class="bz dy l di"><div class="mu mv l"/></div></figure><p id="701f" class="pw-post-body-paragraph jt ju hi jv b jw kt jy jz ka ku kc kd jg kv kf kg jk kw ki kj jo kx kl km kn hb bi translated">现在要运行线程，我们必须在Application类的main方法中创建一个thread类的实例，并调用该实例的<code class="du lq lr ls lt b">start()</code>,正如我在下面的代码中提到的。</p><figure class="kp kq kr ks fd ij"><div class="bz dy l di"><div class="mu mv l"/></div></figure><p id="ff06" class="pw-post-body-paragraph jt ju hi jv b jw kt jy jz ka ku kc kd jg kv kf kg jk kw ki kj jo kx kl km kn hb bi translated">所以如果我运行这个应用程序，我会得到这样的输出，</p><pre class="kp kq kr ks fd mw lt mx my aw mz bi"><span id="7cde" class="iv iw hi lt b fi na nb l nc nd">Main thread is running....<br/>Child thread is running....</span></pre><h2 id="2a00" class="iv iw hi bd ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js bi translated">关于通过扩展线程类创建线程的事实，</h2><ul class=""><li id="f708" class="mg mh hi jv b jw jx ka kb jg ne jk nf jo ng kn ml mm mn mo bi translated">不一定要在线程类中重写run方法。让我们看看为什么，当我调用<code class="du lq lr ls lt b">start()</code>时，它会检查打印机线程。由于我这里没有<code class="du lq lr ls lt b">start()</code>方法，它将检查父类Thread class。在线程类中会有一个<code class="du lq lr ls lt b">start()</code>并调用<code class="du lq lr ls lt b">run()</code>方法。因此，当调用run方法时，它将调用打印机线程类，因为它没有<code class="du lq lr ls lt b">run()</code>方法，它将检查线程类，但它不做任何事情。在run方法中，如果目标被设置，那么它将执行<code class="du lq lr ls lt b">target.run()</code>方法。在我们的例子中，我们没有任何目标，所以什么都不要做。这就是它成功的原因。<br/>所以如果我们没有覆盖run方法，这意味着我们没有做任何任务，因为所有线程的进程都必须转到<code class="du lq lr ls lt b">run()</code>方法。这只有在我们扩展线程类时才有效。但是当我们实现runnable接口时，java程序会强迫你覆盖<code class="du lq lr ls lt b">run()</code>方法。因为这就是我们接下来要看的runnable接口的行为。</li><li id="a678" class="mg mh hi jv b jw mp ka mq jg mr jk ms jo mt kn ml mm mn mo bi translated">从上面的代码片段中可以看出，尽管在主线程中打印句子之前调用了<code class="du lq lr ls lt b">start()</code>方法(在Application类的第7行),但它是在主线程打印之后打印的。这意味着，不能保证调用<code class="du lq lr ls lt b">start()</code>方法会立即运行线程，这完全取决于JRE(基于操作系统)。在前一点中，我提到了<code class="du lq lr ls lt b">target</code>，它是一个可运行的对象。在我们的例子中，打印机对象，所以如果它有<code class="du lq lr ls lt b">run()</code>方法，那么它将执行它，如果没有，它将得到超类并执行<code class="du lq lr ls lt b">run()</code>方法，如我之前所说。让我们看一些例子，</li></ul><p id="997b" class="pw-post-body-paragraph jt ju hi jv b jw kt jy jz ka ku kc kd jg kv kf kg jk kw ki kj jo kx kl km kn hb bi translated">所以在这个子线程中，应该打印从1到10的内容。</p><figure class="kp kq kr ks fd ij"><div class="bz dy l di"><div class="mu mv l"/></div></figure><p id="687e" class="pw-post-body-paragraph jt ju hi jv b jw kt jy jz ka ku kc kd jg kv kf kg jk kw ki kj jo kx kl km kn hb bi translated">在主线程中，应该打印从1到100的内容</p><figure class="kp kq kr ks fd ij"><div class="bz dy l di"><div class="mu mv l"/></div></figure><p id="ab7d" class="pw-post-body-paragraph jt ju hi jv b jw kt jy jz ka ku kc kd jg kv kf kg jk kw ki kj jo kx kl km kn hb bi translated">所以我运行这个程序几次来测试结果。(我只取了输出的前几行，以避免文章中有太多多余的空格)</p><blockquote class="nh"><p id="279d" class="ni nj hi bd nk nl nm nn no np nq kn dx translated">第一次输出</p></blockquote><pre class="nr ns nt nu nv mw lt mx my aw mz bi"><span id="dbf5" class="iv iw hi lt b fi na nb l nc nd">Main thread is running....<br/>Child thread is running....<br/>main 0<br/>child 0<br/>child 1<br/>main 1<br/>main 2<br/>main 3<br/>child 2<br/>main 4<br/>child 3<br/>main 5<br/>child 4<br/>main 6<br/>.<br/>.</span></pre><blockquote class="nh"><p id="9cb4" class="ni nj hi bd nk nl nw nx ny nz oa kn dx translated">第二次输出</p></blockquote><pre class="nr ns nt nu nv mw lt mx my aw mz bi"><span id="37eb" class="iv iw hi lt b fi na nb l nc nd">Main thread is running....<br/>Child thread is running....<br/>child 0<br/>main 0<br/>main 1<br/>main 2<br/>child 1<br/>main 3<br/>child 2<br/>main 4<br/>child 3<br/>main 5<br/>child 4<br/>main 6<br/>.<br/>.</span></pre><blockquote class="nh"><p id="43c9" class="ni nj hi bd nk nl nw nx ny nz oa kn dx translated">第三次输出</p></blockquote><pre class="nr ns nt nu nv mw lt mx my aw mz bi"><span id="8c85" class="iv iw hi lt b fi na nb l nc nd">Main thread is running....<br/>Child thread is running....<br/>child 0<br/>main 0<br/>child 1<br/>main 1<br/>child 2<br/>main 2<br/>child 3<br/>main 3<br/>child 4<br/>main 4<br/>child 5<br/>main 5<br/>child 6<br/>main 6<br/>.<br/>.</span></pre><p id="e03c" class="pw-post-body-paragraph jt ju hi jv b jw kt jy jz ka ku kc kd jg kv kf kg jk kw ki kj jo kx kl km kn hb bi translated">所以从上面的结果来看，每次执行都有不同的顺序，所以这给出了一个结论，即无论何时调用<code class="du lq lr ls lt b">start()</code>方法，都不能保证线程会立即启动。这是因为<strong class="jv hj">线程调度器</strong>决定了哪个线程应该运行(排序),这完全取决于我上面提到的JRE(基于操作系统)。</p><ul class=""><li id="8008" class="mg mh hi jv b jw kt ka ku jg mi jk mj jo mk kn ml mm mn mo bi translated">如果我们在没有<code class="du lq lr ls lt b">start()</code>方法的情况下调用<code class="du lq lr ls lt b">run()</code>方法会发生什么？让我们找出答案，</li></ul><figure class="kp kq kr ks fd ij"><div class="bz dy l di"><div class="mu mv l"/></div></figure><figure class="kp kq kr ks fd ij"><div class="bz dy l di"><div class="mu mv l"/></div></figure><p id="6b50" class="pw-post-body-paragraph jt ju hi jv b jw kt jy jz ka ku kc kd jg kv kf kg jk kw ki kj jo kx kl km kn hb bi translated">所以当我运行上面的程序时，我得到了如下输出:</p><pre class="kp kq kr ks fd mw lt mx my aw mz bi"><span id="0493" class="iv iw hi lt b fi na nb l nc nd">Main thread is running....<br/>Child thread is running....<br/>main main 0<br/>child Thread-0 0<br/>main main 1<br/>child Thread-0 1<br/>main main 2<br/>child Thread-0 2<br/>main main 3<br/>child Thread-0 3<br/>main main 4<br/>child Thread-0 4<br/>main main 5<br/>child Thread-0 5<br/>main main 6<br/>main main 7<br/>main main 8<br/>main main 9<br/>main main 10<br/>child Thread-0 6<br/>child Thread-0 7<br/>child Thread-0 8<br/>child Thread-0 9<br/>main main 11<br/>main main 12<br/>main main 13<br/>main main 14<br/>main main 15<br/>main main 16<br/>main main 17<br/>main main 18<br/>main main 19<br/>main main 20<br/>.<br/>.<br/>.<br/>main main 99</span></pre><p id="4c3d" class="pw-post-body-paragraph jt ju hi jv b jw kt jy jz ka ku kc kd jg kv kf kg jk kw ki kj jo kx kl km kn hb bi translated">从上面的输出可以看出，我得到了线程名，因为在代码中，我为当前线程调用了<code class="du lq lr ls lt b">getName()</code>。让我们看看，</p><figure class="kp kq kr ks fd ij"><div class="bz dy l di"><div class="mu mv l"/></div></figure><p id="643b" class="pw-post-body-paragraph jt ju hi jv b jw kt jy jz ka ku kc kd jg kv kf kg jk kw ki kj jo kx kl km kn hb bi translated">如你所见，我去掉了start方法，只使用了run方法，得到了如下输出:</p><pre class="kp kq kr ks fd mw lt mx my aw mz bi"><span id="22ee" class="iv iw hi lt b fi na nb l nc nd">Child thread is running....<br/>child main 0<br/>child main 1<br/>child main 2<br/>child main 3<br/>child main 4<br/>child main 5<br/>child main 6<br/>child main 7<br/>child main 8<br/>child main 9<br/>Main thread is running....<br/>main main 0<br/>main main 1<br/>main main 2<br/>main main 3<br/>main main 4<br/>main main 5<br/>.<br/>.<br/>.<br/>main main 99</span></pre><p id="e9eb" class="pw-post-body-paragraph jt ju hi jv b jw kt jy jz ka ku kc kd jg kv kf kg jk kw ki kj jo kx kl km kn hb bi translated">因此，从输出中可以看出，它在执行main之前先执行child，因为<code class="du lq lr ls lt b">run()</code>方法不会产生威胁，这意味着在这个场景中我们只有一个线程。因此它作为普通方法调用执行。所以<code class="du lq lr ls lt b">start()</code>方法是必要的，因为每当这个方法被调用时，JVM将处理许多事情，例如，检查线程是否已经存在，线程是否准备好运行，然后它将在寄存器中注册并将其添加到线程池中，最后它将调用<code class="du lq lr ls lt b">run()</code>方法。因此，如果我们在没有<code class="du lq lr ls lt b">start() </code>方法的情况下调用<code class="du lq lr ls lt b">run()</code>方法，那么这就不是一个多线程场景。</p><ul class=""><li id="4d7b" class="mg mh hi jv b jw kt ka ku jg mi jk mj jo mk kn ml mm mn mo bi translated">如果我们在Thread类中重写<code class="du lq lr ls lt b">start()</code>方法会发生什么？<br/>是的，但是让我们假设我们在<code class="du lq lr ls lt b">Printer class</code>中调用<code class="du lq lr ls lt b">start()</code>方法，它所做的是，它将寻找直接类并且它有方法，所以它将运行并且它不会去超类创建线程。那么有什么方法可以创建线程，甚至覆盖<code class="du lq lr ls lt b">start()</code>方法呢？答案是肯定的，我们可以，只要把<code class="du lq lr ls lt b">super.start()</code>放在Printer类的<code class="du lq lr ls lt b">start()</code>方法中。</li><li id="c371" class="mg mh hi jv b jw mp ka mq jg mr jk ms jo mt kn ml mm mn mo bi translated">如果我们重载了<code class="du lq lr ls lt b">run()</code>方法会发生什么？<br/>是的，但是线程类的start方法总是不带参数调用。</li><li id="735f" class="mg mh hi jv b jw mp ka mq jg mr jk ms jo mt kn ml mm mn mo bi translated">大多数程序员认为，一旦主线程终止，java程序就会终止。但实际上它不是一个守护线程，所以子线程实际上可以继续。我们能做的是，通过在主类中给出<code class="du lq lr ls lt b">printer.setDaemon(true);</code>，我们可以将打印机线程对象更改为守护线程。此时，当您运行程序时，当主线程结束时，子线程也应该结束，但您可能会注意到，即使在主线程结束后，子线程仍会运行一段时间，因为当主线程打印最后一行时，子线程已经处理了特定的值，并且由于打印所花费的时间而发生了延迟。</li><li id="2cb3" class="mg mh hi jv b jw mp ka mq jg mr jk ms jo mt kn ml mm mn mo bi translated">这种方法的主要缺点是，当我们将Thread类扩展到那个特定的类时，我们将会失去类的层次结构，因为Java不支持多重继承。</li></ul><figure class="kp kq kr ks fd ij er es paragraph-image"><div class="er es ob"><img src="../Images/2a0590fea3150d7dc25d42edd875b169.png" data-original-src="https://miro.medium.com/v2/resize:fit:762/format:webp/1*MpLGv4eK0oMbUncxGz6IHw.jpeg"/></div></figure><h2 id="0320" class="iv iw hi bd ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js bi translated">实现可运行接口</h2><figure class="kp kq kr ks fd ij"><div class="bz dy l di"><div class="mu mv l"/></div></figure><p id="341d" class="pw-post-body-paragraph jt ju hi jv b jw kt jy jz ka ku kc kd jg kv kf kg jk kw ki kj jo kx kl km kn hb bi translated">在上面的代码中，我们使用了实现Runnable，而不是从Thread类扩展。</p><figure class="kp kq kr ks fd ij"><div class="bz dy l di"><div class="mu mv l"/></div></figure><p id="1cae" class="pw-post-body-paragraph jt ju hi jv b jw kt jy jz ka ku kc kd jg kv kf kg jk kw ki kj jo kx kl km kn hb bi translated">Runnable接口是一个<strong class="jv hj"> SAM(单一抽象方法)</strong>它只有一个名为run的方法，仅此而已。在这种情况下，我们没有中间线程类，所以我们没有人来实现<code class="du lq lr ls lt b">run()</code>方法。所以我们在这里做的是，我们从一个名为<code class="du lq lr ls lt b">thread</code>的线程类中创建一个实例(这意味着我们可以将Runnable instance传递给它，正如我在前面的线程创建方法中提到的，也可以给出线程行为)，我将对象<code class="du lq lr ls lt b">printer</code>作为参数传递给线程实例。现在<code class="du lq lr ls lt b">printer</code>是一个<strong class="jv hj">可运行类</strong>。这就是我从线程实例调用start方法的原因。我得到的输出如下，</p><pre class="kp kq kr ks fd mw lt mx my aw mz bi"><span id="7eea" class="iv iw hi lt b fi na nb l nc nd">Main thread is running....<br/>Child thread is running....<br/>main main 0<br/>child  0<br/>main main 1<br/>child  1<br/>main main 2<br/>child  2<br/>main main 3<br/>child  3<br/>child  4<br/>child  5<br/>main main 4<br/>child  6<br/>main main 5<br/>child  7<br/>main main 6<br/>child  8<br/>main main 7<br/>child  9<br/>main main 8<br/>child  10<br/>main main 9<br/>child  11<br/>Main thread Ends here<br/>child  12<br/>child  13<br/>child  14<br/>child  15<br/>child  16<br/>child  17<br/>child  18<br/>child  19<br/>===========================</span></pre><p id="63eb" class="pw-post-body-paragraph jt ju hi jv b jw kt jy jz ka ku kc kd jg kv kf kg jk kw ki kj jo kx kl km kn hb bi translated">这是第二种方法中创建线程的方法。</p><p id="989e" class="pw-post-body-paragraph jt ju hi jv b jw kt jy jz ka ku kc kd jg kv kf kg jk kw ki kj jo kx kl km kn hb bi translated">Thread类中有八个构造函数，</p><ul class=""><li id="6d79" class="mg mh hi jv b jw kt ka ku jg mi jk mj jo mk kn ml mm mn mo bi translated">线程()</li></ul><pre class="kp kq kr ks fd mw lt mx my aw mz bi"><span id="c9bd" class="iv iw hi lt b fi na nb l nc nd">Thread T1 = new Thread();</span></pre><ul class=""><li id="f335" class="mg mh hi jv b jw kt ka ku jg mi jk mj jo mk kn ml mm mn mo bi translated">线程(可运行目标)</li></ul><pre class="kp kq kr ks fd mw lt mx my aw mz bi"><span id="3567" class="iv iw hi lt b fi na nb l nc nd">Thread T2 = new Thread(printer);</span></pre><ul class=""><li id="d731" class="mg mh hi jv b jw kt ka ku jg mi jk mj jo mk kn ml mm mn mo bi translated">线程(字符串名称)</li></ul><pre class="kp kq kr ks fd mw lt mx my aw mz bi"><span id="03a2" class="iv iw hi lt b fi na nb l nc nd">Thread T3 = new Thread(name:"printerThread");</span></pre><ul class=""><li id="b0cb" class="mg mh hi jv b jw kt ka ku jg mi jk mj jo mk kn ml mm mn mo bi translated">威胁(可运行目标，字符串名称)</li></ul><pre class="kp kq kr ks fd mw lt mx my aw mz bi"><span id="4184" class="iv iw hi lt b fi na nb l nc nd">Thread T4 = new Thread(printer, name:"printerThread");</span></pre><ul class=""><li id="61c0" class="mg mh hi jv b jw kt ka ku jg mi jk mj jo mk kn ml mm mn mo bi translated">线程(线程组组，字符串名称)</li></ul><pre class="kp kq kr ks fd mw lt mx my aw mz bi"><span id="d26c" class="iv iw hi lt b fi na nb l nc nd">Thread T5 = new Thread(new ThreadGroup(),name:"printerThread");</span></pre><ul class=""><li id="8715" class="mg mh hi jv b jw kt ka ku jg mi jk mj jo mk kn ml mm mn mo bi translated">线程(线程组组，可运行目标)</li></ul><pre class="kp kq kr ks fd mw lt mx my aw mz bi"><span id="b8bf" class="iv iw hi lt b fi na nb l nc nd">Thread T6 = new Thread(new ThreadGroup(),printer);</span></pre><ul class=""><li id="2154" class="mg mh hi jv b jw kt ka ku jg mi jk mj jo mk kn ml mm mn mo bi translated">线程(线程组组，可运行目标，字符串名称)</li></ul><pre class="kp kq kr ks fd mw lt mx my aw mz bi"><span id="5afd" class="iv iw hi lt b fi na nb l nc nd">Thread T7 = new Thread(new ThreadGroup(),printer,name:"printerThread");</span></pre><ul class=""><li id="0657" class="mg mh hi jv b jw kt ka ku jg mi jk mj jo mk kn ml mm mn mo bi translated">线程(线程组组、可运行目标、字符串名称、长堆栈大小)</li></ul></div><div class="ab cl lu lv gp lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="hb hc hd he hf"><h1 id="973e" class="ky iw hi bd ix kz mb lb jb lc mc le jf lf md lh jj li me lk jn ll mf ln jr lo bi translated">线程优先级</h1><p id="98b0" class="pw-post-body-paragraph jt ju hi jv b jw jx jy jz ka kb kc kd jg ke kf kg jk kh ki kj jo kk kl km kn hb bi translated">每个线程都有一个线程优先级，它将根据优先级运行。而I到10是Java中线程优先级的范围。基本上10是最高优先级，1是最低优先级，5是正常优先级。</p><p id="878c" class="pw-post-body-paragraph jt ju hi jv b jw kt jy jz ka ku kc kd jg kv kf kg jk kw ki kj jo kx kl km kn hb bi translated">让我们看看如何设置线程优先级，</p><figure class="kp kq kr ks fd ij"><div class="bz dy l di"><div class="mu mv l"/></div></figure><p id="dc79" class="pw-post-body-paragraph jt ju hi jv b jw kt jy jz ka ku kc kd jg kv kf kg jk kw ki kj jo kx kl km kn hb bi translated">因此，要设置优先级，我们必须对线程调用setPriority方法。在我们的例子中，线程的名字是<code class="du lq lr ls lt b">thread</code>。所以我调用了上面代码中的方法(第9行),并将其设置为最低优先级线程。</p><h2 id="d91d" class="iv iw hi bd ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js bi translated">关于线程优先级的事实</h2><ul class=""><li id="8293" class="mg mh hi jv b jw jx ka kb jg ne jk nf jo ng kn ml mm mn mo bi translated">大多数程序员认为5是每个线程的默认优先级，但事实并非如此。假设有两个线程T1(主线程)和T2(子线程)，这两个线程的线程优先级都设置为5。实际上不会有任何变化。实际上在线程优先级中有一个规则，它是主线程的默认优先级值s 5，因为它是由系统创建的。此后，创建的任何线程都将继承父线程优先级值。因此，在创建T1时，优先级将为5，一旦我们从T1创建T2，它也将采用相同的值，即使我们没有设置任何值。但是稍后我们可以通过调用特定线程的<code class="du lq lr ls lt b">setPriority()</code>方法来设置优先级。</li><li id="6c0a" class="mg mh hi jv b jw mp ka mq jg mr jk ms jo mt kn ml mm mn mo bi translated">当我们给不在11范围内的优先级值时，会发生什么呢？我试着通过将线程优先级设为11来运行一个程序，得到的输出如下:</li></ul><pre class="kp kq kr ks fd mw lt mx my aw mz bi"><span id="3b01" class="iv iw hi lt b fi na nb l nc nd">Exception in thread "main" java.lang.IllegalArgumentException<br/>    at java.base/java.lang.Thread.setPriority(Thread.java:1137)<br/>    at threadSample.Application.main(Application.java:9)</span></pre><p id="1f5c" class="pw-post-body-paragraph jt ju hi jv b jw kt jy jz ka ku kc kd jg kv kf kg jk kw ki kj jo kx kl km kn hb bi translated">如你所见，我在说<code class="du lq lr ls lt b">IllegalArgumentException</code>时出错了。所以它不可能自动设置为10。</p><ul class=""><li id="e95e" class="mg mh hi jv b jw kt ka ku jg mi jk mj jo mk kn ml mm mn mo bi translated">当我们分别为线程T1和T2赋予优先级值1和10时会发生什么？<br/>大多数时候执行的顺序不会有什么大的区别。是的，JVM会监听优先级，但是我们不能确定JVM会相应地这么做。因此，如果你想知道它是如何工作的，我们必须在实际项目中实现它，我们有办法使用<strong class="jv hj">线程转储</strong>来查看。在那里所有线程的状态将被记录。</li></ul></div><div class="ab cl lu lv gp lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="hb hc hd he hf"><h1 id="7265" class="ky iw hi bd ix kz mb lb jb lc mc le jf lf md lh jj li me lk jn ll mf ln jr lo bi translated">线程中的其他方法</h1><h2 id="e7e2" class="iv iw hi bd ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js bi translated">连接方法</h2><p id="8493" class="pw-post-body-paragraph jt ju hi jv b jw jx jy jz ka kb kc kd jg ke kf kg jk kh ki kj jo kk kl km kn hb bi translated">假设有两个线程T1和T2。T1希望等待T2完成任务，那么T1应该在T2线程上调用join方法。我们还可以设置T1等待的时间。让我们看看调用join方法的方法有哪些。</p><p id="40e3" class="pw-post-body-paragraph jt ju hi jv b jw kt jy jz ka ku kc kd jg kv kf kg jk kw ki kj jo kx kl km kn hb bi translated"><code class="du lq lr ls lt b">T2.join()</code>——这将永远等待，或者直到T2死去</p><p id="a84b" class="pw-post-body-paragraph jt ju hi jv b jw kt jy jz ka ku kc kd jg kv kf kg jk kw ki kj jo kx kl km kn hb bi translated"><code class="du lq lr ls lt b">T2.join(long millis)</code>—这将等待<code class="du lq lr ls lt b">millis</code>毫秒，等待该线程终止。</p><p id="e372" class="pw-post-body-paragraph jt ju hi jv b jw kt jy jz ka ku kc kd jg kv kf kg jk kw ki kj jo kx kl km kn hb bi translated"><code class="du lq lr ls lt b">T2.join(long millis,int nanos)</code> —这将等待<code class="du lq lr ls lt b">millis</code>毫秒加<code class="du lq lr ls lt b">nanos</code>纳秒，等待线程死亡。</p><p id="3847" class="pw-post-body-paragraph jt ju hi jv b jw kt jy jz ka ku kc kd jg kv kf kg jk kw ki kj jo kx kl km kn hb bi translated">因此，无论何时调用join方法，线程都将从运行状态进入等待状态。在本例中，T1线程将进入等待状态。让我们看看在什么情况下T1会回到运行状态，</p><ol class=""><li id="2062" class="mg mh hi jv b jw kt ka ku jg mi jk mj jo mk kn oc mm mn mo bi translated">T2完成了它进程</li><li id="5dcb" class="mg mh hi jv b jw mp ka mq jg mr jk ms jo mt kn oc mm mn mo bi translated">超时(仅当设置了时间时)</li><li id="5ce6" class="mg mh hi jv b jw mp ka mq jg mr jk ms jo mt kn oc mm mn mo bi translated">当它被中断时</li></ol><h2 id="62d4" class="iv iw hi bd ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js bi translated">产量法</h2><p id="65e3" class="pw-post-body-paragraph jt ju hi jv b jw jx jy jz ka kb kc kd jg ke kf kg jk kh ki kj jo kk kl km kn hb bi translated">当调用<code class="du lq lr ls lt b">yield()</code>方法时，它将向调度程序发送一个提示，表明当前线程愿意放弃对处理器的当前使用。它是一个本机方法，因为它不是用Java实现的。假设有三个线程T1、T2和T3。所以一旦T1调用了<code class="du lq lr ls lt b">yield()</code>方法，调度程序会把机会给其他线程，但不确定T2或T3是否立即得到了机会。假设T2获得了机会，一旦它在那一刻完成，我们也不能说调度程序会将机会给T1。它完全依赖于称为<strong class="jv hj">原语调度</strong>的过程，如果平台不支持这个过程，那么你将无法看到这些类型的执行。</p><h2 id="50fb" class="iv iw hi bd ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js bi translated">睡眠方法</h2><p id="6f3c" class="pw-post-body-paragraph jt ju hi jv b jw jx jy jz ka kb kc kd jg ke kf kg jk kh ki kj jo kk kl km kn hb bi translated">当调用此方法时，它可以等待一段时间。这里有两种不同方法来调用这个方法，</p><ol class=""><li id="9f19" class="mg mh hi jv b jw kt ka ku jg mi jk mj jo mk kn oc mm mn mo bi translated"><code class="du lq lr ls lt b">sleep(long millis)</code>方法，这是一个本地方法，我们可以简单地在参数中给出睡眠时间。</li><li id="515a" class="mg mh hi jv b jw mp ka mq jg mr jk ms jo mt kn oc mm mn mo bi translated"><code class="du lq lr ls lt b">sleep(long millis,int nanos)</code>不是本地方法的方法(用Java实现)。</li></ol><p id="e7db" class="pw-post-body-paragraph jt ju hi jv b jw kt jy jz ka ku kc kd jg kv kf kg jk kw ki kj jo kx kl km kn hb bi translated">因此，如果睡眠时间结束或有任何中断，那么线程将回到运行状态。</p><h2 id="4382" class="iv iw hi bd ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js bi translated">中断方法</h2><p id="431b" class="pw-post-body-paragraph jt ju hi jv b jw jx jy jz ka kb kc kd jg ke kf kg jk kh ki kj jo kk kl km kn hb bi translated">当调用此方法时，特定线程将从等待状态返回到就绪状态。这就是为什么在调用sleep方法时，我们应该包含try catch方法，如下所示:</p><pre class="kp kq kr ks fd mw lt mx my aw mz bi"><span id="f78d" class="iv iw hi lt b fi na nb l nc nd">try {<br/>     Thread.sleep(1000);<br/>} catch (InterruptedException e) {<br/>    // TODO Auto-generated catch block<br/>    e.printStackTrace();<br/>}</span></pre><p id="7e1e" class="pw-post-body-paragraph jt ju hi jv b jw kt jy jz ka ku kc kd jg kv kf kg jk kw ki kj jo kx kl km kn hb bi translated">因此，要中断线程，我们必须调用如下方法:</p><pre class="kp kq kr ks fd mw lt mx my aw mz bi"><span id="7e07" class="iv iw hi lt b fi na nb l nc nd">thread.interrupt();</span></pre><p id="2fde" class="pw-post-body-paragraph jt ju hi jv b jw kt jy jz ka ku kc kd jg kv kf kg jk kw ki kj jo kx kl km kn hb bi translated">在我们的例子中，假设<code class="du lq lr ls lt b">thread</code>休眠了5000毫秒，一旦我们调用上面的方法，它就会回到就绪状态。这里需要注意的是，一个中断只适用于一种睡眠方法。如果我们在不睡觉的<code class="du lq lr ls lt b">thread</code>上调用这个方法呢。一旦调用了<code class="du lq lr ls lt b">sleep()</code>方法，它将等待并执行<code class="du lq lr ls lt b">interrupt()</code>方法，直到它不再做任何事情。</p></div><div class="ab cl lu lv gp lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="hb hc hd he hf"><p id="8bd1" class="pw-post-body-paragraph jt ju hi jv b jw kt jy jz ka ku kc kd jg kv kf kg jk kw ki kj jo kx kl km kn hb bi translated"><strong class="jv hj">同步</strong>部分将在另一篇文章中讨论。</p><h1 id="3f88" class="ky iw hi bd ix kz la lb jb lc ld le jf lf lg lh jj li lj lk jn ll lm ln jr lo bi translated">参考</h1><p id="226c" class="pw-post-body-paragraph jt ju hi jv b jw jx jy jz ka kb kc kd jg ke kf kg jk kh ki kj jo kk kl km kn hb bi translated">我参考了下面的YouTube播放列表来写这篇文章，它是由<a class="od oe ge" href="https://medium.com/u/26403c4bd160?source=post_page-----1f5a074d5753--------------------------------" rel="noopener" target="_blank"> Krishantha Dinesh </a>制作的。</p><figure class="kp kq kr ks fd ij"><div class="bz dy l di"><div class="of mv l"/></div></figure><p id="57e3" class="pw-post-body-paragraph jt ju hi jv b jw kt jy jz ka ku kc kd jg kv kf kg jk kw ki kj jo kx kl km kn hb bi translated">我还引用了以下内容来完成这篇文章，</p><div class="og oh ez fb oi oj"><a href="https://docs.oracle.com/javase/7/docs/api/java/lang/Thread.html" rel="noopener  ugc nofollow" target="_blank"><div class="ok ab dw"><div class="ol ab om cl cj on"><h2 class="bd hj fi z dy oo ea eb op ed ef hh bi translated">线程(Java平台SE 7)</h2><div class="oq l"><h3 class="bd b fi z dy oo ea eb op ed ef dx translated">每个线程都有一个优先级。优先级较高的线程优先于优先级较低的线程执行…</h3></div><div class="or l"><p class="bd b fp z dy oo ea eb op ed ef dx translated">docs.oracle.com</p></div></div></div></a></div><div class="og oh ez fb oi oj"><a href="https://www.baeldung.com/java-thread-lifecycle" rel="noopener  ugc nofollow" target="_blank"><div class="ok ab dw"><div class="ol ab om cl cj on"><h2 class="bd hj fi z dy oo ea eb op ed ef hh bi translated">Java中线程的生命周期| Baeldung</h2><div class="oq l"><h3 class="bd b fi z dy oo ea eb op ed ef dx translated">在本文中，我们将详细讨论Java中的一个核心概念——线程的生命周期。我们将使用快速…</h3></div><div class="or l"><p class="bd b fp z dy oo ea eb op ed ef dx translated">www.baeldung.com</p></div></div><div class="os l"><div class="ot l ou ov ow os ox io oj"/></div></div></a></div></div></div>    
</body>
</html>