<html>
<head>
<title>Using abstract classes to design enemies | Unity</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用抽象类设计敌人| Unity</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/using-abstract-classes-to-design-enemies-unity-60c39c793a66?source=collection_archive---------3-----------------------#2021-10-07">https://medium.com/nerd-for-tech/using-abstract-classes-to-design-enemies-unity-60c39c793a66?source=collection_archive---------3-----------------------#2021-10-07</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><h2 id="31a8" class="hg hh hi bd b fp hj hk hl hm hn ho dx hp translated" aria-label="kicker paragraph">统一指南</h2><div class=""/><div class=""><h2 id="e124" class="pw-subtitle-paragraph io hr hi bd b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf dx translated">关于如何使用抽象类在Unity中实现敌人的快速指南</h2></div><figure class="jh ji jj jk fd jl er es paragraph-image"><div role="button" tabindex="0" class="jm jn di jo bf jp"><div class="er es jg"><img src="../Images/4949a48caff5695f82ee0b9fc3a43865.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*b1G2BdnQG9BGWTOom7Q6nw.gif"/></div></div></figure><p id="b064" class="pw-post-body-paragraph js jt hi ju b jv jw is jx jy jz iv ka kb kc kd ke kf kg kh ki kj kk kl km kn hb bi translated">目标:使用抽象类在Unity的2D游戏中实现敌人的机制。</p><p id="a59b" class="pw-post-body-paragraph js jt hi ju b jv jw is jx jy jz iv ka kb kc kd ke kf kg kh ki kj kk kl km kn hb bi translated">在上一篇文章中，我介绍了<a class="ae ko" rel="noopener" href="/nerd-for-tech/implementing-a-jump-mechanic-unity-6420b106e47a">如何用Unity </a>为我们的玩家实现一个跳跃机制。现在，是时候开始在我们的2D游戏中使用抽象类或虚拟方法来实现敌人的机制了。</p><figure class="jh ji jj jk fd jl er es paragraph-image"><div role="button" tabindex="0" class="jm jn di jo bf jp"><div class="er es jg"><img src="../Images/11f63c6c58b6d52041703dc766dd65c8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*njeRLLj_yakdlIMWBwD1Xg.png"/></div></div></figure><h1 id="8ff8" class="kp kq hi bd kr ks kt ku kv kw kx ky kz ix la iy lb ja lc jb ld jd le je lf lg bi translated">创造敌人</h1><h2 id="05fd" class="lh kq hi bd kr li lj lk kv ll lm ln kz kb lo lp lb kf lq lr ld kj ls lt lf ho bi translated">精灵</h2><p id="582a" class="pw-post-body-paragraph js jt hi ju b jv lu is jx jy lv iv ka kb lw kd ke kf lx kh ki kj ly kl km kn hb bi translated">首先，让我们用精灵创建几个新的游戏对象来代表我们游戏的新敌人。出于我们的目的，我们将使用蜘蛛和苔藓巨人的精灵:</p><div class="jh ji jj jk fd ab cb"><figure class="lz jl ma mb mc md me paragraph-image"><div role="button" tabindex="0" class="jm jn di jo bf jp"><img src="../Images/875f74f51b35e334a59345626a807504.png" data-original-src="https://miro.medium.com/v2/resize:fit:1362/1*iwTYspLvDLIdZnQutk2w9w.gif"/></div></figure><figure class="lz jl mf mb mc md me paragraph-image"><div role="button" tabindex="0" class="jm jn di jo bf jp"><img src="../Images/559b62a3c43cf1879a0e451dbe51c190.png" data-original-src="https://miro.medium.com/v2/resize:fit:640/format:webp/1*RZBxM5iPu6U-DdOY7UV9Vw.png"/></div></figure></div><h2 id="4a86" class="lh kq hi bd kr li lj lk kv ll lm ln kz kb lo lp lb kf lq lr ld kj ls lt lf ho bi translated">班级</h2><p id="4771" class="pw-post-body-paragraph js jt hi ju b jv lu is jx jy lv iv ka kb lw kd ke kf lx kh ki kj ly kl km kn hb bi translated">然后，为了使用抽象类实现我们的敌人，让我们创建3个新的C#脚本:</p><ul class=""><li id="291f" class="mg mh hi ju b jv jw jy jz kb mi kf mj kj mk kn ml mm mn mo bi translated">敌军</li></ul><p id="4a74" class="pw-post-body-paragraph js jt hi ju b jv jw is jx jy jz iv ka kb kc kd ke kf kg kh ki kj kk kl km kn hb bi translated">这个类将是抽象的，它将代表我们在游戏中使用的每个敌人子类的基础。</p><ul class=""><li id="e9dc" class="mg mh hi ju b jv jw jy jz kb mi kf mj kj mk kn ml mm mn mo bi translated">苔藓巨人</li></ul><p id="fff2" class="pw-post-body-paragraph js jt hi ju b jv jw is jx jy jz iv ka kb kc kd ke kf kg kh ki kj kk kl km kn hb bi translated">这个子类将从敌人类继承，并将处理主要的敌人机械和苔藓巨人机械。</p><ul class=""><li id="db6b" class="mg mh hi ju b jv jw jy jz kb mi kf mj kj mk kn ml mm mn mo bi translated">蜘蛛；状似蜘蛛的物体；星形轮；十字叉；连接柄；十字头</li></ul><p id="e54c" class="pw-post-body-paragraph js jt hi ju b jv jw is jx jy jz iv ka kb kc kd ke kf kg kh ki kj kk kl km kn hb bi translated">这个子类将从敌人类继承，并将处理主要的敌人机制和蜘蛛机制。</p><div class="jh ji jj jk fd ab cb"><figure class="lz jl mp mb mc md me paragraph-image"><div role="button" tabindex="0" class="jm jn di jo bf jp"><img src="../Images/7eb2213952832b3685e42236fe52cfbc.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/1*Im42yKOi-5FRGhK2e5ALBQ.gif"/></div></figure><figure class="lz jl mp mb mc md me paragraph-image"><div role="button" tabindex="0" class="jm jn di jo bf jp"><img src="../Images/8851322814c827e6d26f37822b6a820c.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/1*ELRCYwWhGISl7bFbtEXb1g.gif"/></div></figure><figure class="lz jl mp mb mc md me paragraph-image"><div role="button" tabindex="0" class="jm jn di jo bf jp"><img src="../Images/a3f07dafe76e64b8d10e7630300b71de.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/1*GqC7Du_4XdbBid-SLm8wuA.gif"/></div></figure></div><p id="ed57" class="pw-post-body-paragraph js jt hi ju b jv jw is jx jy jz iv ka kb kc kd ke kf kg kh ki kj kk kl km kn hb bi translated">现在，为了表明<strong class="ju hs">敌人</strong>级将是敌人子类的基础，让我们:</p><ul class=""><li id="6fa0" class="mg mh hi ju b jv jw jy jz kb mi kf mj kj mk kn ml mm mn mo bi translated">打开<strong class="ju hs">敌人</strong>脚本，添加<strong class="ju hs"> <em class="mq">摘要</em> </strong>关键字:</li></ul><figure class="jh ji jj jk fd jl er es paragraph-image"><div class="er es mr"><img src="../Images/0af7a6506a16b8b051a572bd175e037c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1388/1*KoMbyKXR_wZRyailkt6dRA.gif"/></div></figure><blockquote class="ms mt mu"><p id="b469" class="js jt mq ju b jv jw is jx jy jz iv ka mv kc kd ke mw kg kh ki mx kk kl km kn hb bi translated">注意:指出<strong class="ju hs">敌人</strong>类是<strong class="ju hs">抽象</strong>很重要，这样我们可以在其中创建抽象方法。</p></blockquote><ul class=""><li id="5a2d" class="mg mh hi ju b jv jw jy jz kb mi kf mj kj mk kn ml mm mn mo bi translated">开启<strong class="ju hs">苔藓巨人</strong>和<strong class="ju hs">蜘蛛</strong>职业，将<strong class="ju hs">单行为</strong>的继承改为<strong class="ju hs">敌人</strong>:</li></ul><figure class="jh ji jj jk fd jl er es paragraph-image"><div role="button" tabindex="0" class="jm jn di jo bf jp"><div class="er es my"><img src="../Images/79f617ca02dfad186e18b9ebdff502a1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*mwtBCuT4gngnS2mID_wo5g.gif"/></div></div></figure><figure class="jh ji jj jk fd jl er es paragraph-image"><div role="button" tabindex="0" class="jm jn di jo bf jp"><div class="er es mz"><img src="../Images/6859aa6f5077f32dadfd1fe6eb9e552e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dXyaIK2gqYks1onbJyuHzQ.png"/></div></div></figure><h2 id="9773" class="lh kq hi bd kr li lj lk kv ll lm ln kz kb lo lp lb kf lq lr ld kj ls lt lf ho bi translated">变量</h2><p id="cc3c" class="pw-post-body-paragraph js jt hi ju b jv lu is jx jy lv iv ka kb lw kd ke kf lx kh ki kj ly kl km kn hb bi translated">现在，正如我们所知，每个敌人子类都继承自<strong class="ju hs">敌人</strong>类，我们可以创建新的变量，我们知道每个敌人都需要这些变量(比如生命值、速度或被击败后会掉落的宝石):</p><figure class="jh ji jj jk fd jl er es paragraph-image"><div role="button" tabindex="0" class="jm jn di jo bf jp"><div class="er es na"><img src="../Images/a56ef55a19fe379f9856d3ae9384ef1e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*O_Ssk8vnJk7GqyDK7haFiA.png"/></div></div><figcaption class="nb nc et er es nd ne bd b be z dx translated">不要忘记使用<strong class="bd kr">【serialize field】</strong>能够通过检查器修改值。</figcaption></figure><blockquote class="ms mt mu"><p id="38ec" class="js jt mq ju b jv jw is jx jy jz iv ka mv kc kd ke mw kg kh ki mx kk kl km kn hb bi translated">注意:我们需要将变量设置为<strong class="ju hs"> protected </strong>(或<strong class="ju hs"> public </strong>)以便能够读取和使用敌人子类中的变量。</p></blockquote><p id="32c9" class="pw-post-body-paragraph js jt hi ju b jv jw is jx jy jz iv ka kb kc kd ke kf kg kh ki kj kk kl km kn hb bi translated">这样，我们就可以将各自的脚本附加到我们的敌人身上，并通过检查器修改其值:</p><div class="jh ji jj jk fd ab cb"><figure class="lz jl nf mb mc md me paragraph-image"><div role="button" tabindex="0" class="jm jn di jo bf jp"><img src="../Images/1b137b27f2dfbaeeec76c971249a0417.png" data-original-src="https://miro.medium.com/v2/resize:fit:1010/1*_tJTC_ja5EEqR-KfkI8AHg.gif"/></div></figure><figure class="lz jl ng mb mc md me paragraph-image"><div role="button" tabindex="0" class="jm jn di jo bf jp"><img src="../Images/229a2ed8d8e3f9bce2a45f9e70af3250.png" data-original-src="https://miro.medium.com/v2/resize:fit:992/1*Cj9b1TfQCSlPzHRgDt9WHg.gif"/></div></figure></div><h2 id="8ace" class="lh kq hi bd kr li lj lk kv ll lm ln kz kb lo lp lb kf lq lr ld kj ls lt lf ho bi translated">虚拟方法</h2><p id="1a61" class="pw-post-body-paragraph js jt hi ju b jv lu is jx jy lv iv ka kb lw kd ke kf lx kh ki kj ly kl km kn hb bi translated">现在，让我们实现一个每个敌人都可以从基类实现的方法:<strong class="ju hs">攻击</strong>。通过使用一个虚拟方法，我们能够在敌人子类中使用或覆盖它。让我们声明<strong class="ju hs">虚拟攻击</strong>方法，并在调用它时打印一条消息:</p><figure class="jh ji jj jk fd jl er es paragraph-image"><div role="button" tabindex="0" class="jm jn di jo bf jp"><div class="er es nh"><img src="../Images/6a233ca4063ac43452cefb8cdd04fef7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*h4UwgTw5GTKtwoaiUs2j4A.png"/></div></div></figure><p id="3238" class="pw-post-body-paragraph js jt hi ju b jv jw is jx jy jz iv ka kb kc kd ke kf kg kh ki kj kk kl km kn hb bi translated">然后，让我们在敌人子类中声明<strong class="ju hs">覆盖攻击</strong>方法。使用override关键字，我们能够覆盖来自<strong class="ju hs">敌人</strong>基类的方法，或者通过使用<strong class="ju hs">基类在新的实现中调用它。进攻</strong>线:</p><div class="jh ji jj jk fd ab cb"><figure class="lz jl ni mb mc md me paragraph-image"><div role="button" tabindex="0" class="jm jn di jo bf jp"><img src="../Images/ed68d8f6310c018efce82d69a48f781a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1024/format:webp/1*zyvBtiW_UcvbgUmaUJSgJg.png"/></div></figure><figure class="lz jl nj mb mc md me paragraph-image"><div role="button" tabindex="0" class="jm jn di jo bf jp"><img src="../Images/0ce89c68f559603e500f6da320ee422b.png" data-original-src="https://miro.medium.com/v2/resize:fit:978/format:webp/1*WTA8D-EmaT33W4Cc4c9O5Q.png"/></div></figure></div><p id="c163" class="pw-post-body-paragraph js jt hi ju b jv jw is jx jy jz iv ka kb kc kd ke kf kg kh ki kj kk kl km kn hb bi translated">现在，为了看看虚拟方法是如何工作的，让我们使用<strong class="ju hs">敌人</strong>子类中的<strong class="ju hs">开始</strong>方法来调用<strong class="ju hs">攻击</strong>方法:</p><figure class="jh ji jj jk fd jl er es paragraph-image"><div class="er es nk"><img src="../Images/f52e6d471c7b05b2f698268710514d70.png" data-original-src="https://miro.medium.com/v2/resize:fit:1212/format:webp/1*la0O6TAGZkydOJNBgwVaYQ.png"/></div></figure><p id="72ed" class="pw-post-body-paragraph js jt hi ju b jv jw is jx jy jz iv ka kb kc kd ke kf kg kh ki kj kk kl km kn hb bi translated">如果我们用Unity运行游戏，我们将能够看到来自<strong class="ju hs">敌人</strong>基类的<strong class="ju hs">攻击</strong>方法首先被调用(感谢<strong class="ju hs"> base。Attack </strong>)然后子类中的攻击方法继续执行:</p><figure class="jh ji jj jk fd jl er es paragraph-image"><div class="er es nl"><img src="../Images/08210398dcf2821fafcb593b2dd1e02c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1028/format:webp/1*1cWB7jjbtxfYME5zbS7Bvg.png"/></div></figure><h2 id="aec1" class="lh kq hi bd kr li lj lk kv ll lm ln kz kb lo lp lb kf lq lr ld kj ls lt lf ho bi translated">抽象方法</h2><p id="51b9" class="pw-post-body-paragraph js jt hi ju b jv lu is jx jy lv iv ka kb lw kd ke kf lx kh ki kj ly kl km kn hb bi translated">最后，让我们为基类实现一个抽象方法。抽象方法意味着在其子类中实现相同的方法是强制性的。例如，让我们将<strong class="ju hs"> Update </strong>方法实现为一个抽象方法:</p><blockquote class="ms mt mu"><p id="5e8d" class="js jt mq ju b jv jw is jx jy jz iv ka mv kc kd ke mw kg kh ki mx kk kl km kn hb bi translated">注意:当我们在<strong class="ju hs">抽象</strong>类中声明一个<strong class="ju hs">抽象</strong>方法时，我们不能定义任何功能。</p></blockquote><figure class="jh ji jj jk fd jl er es paragraph-image"><div class="er es nm"><img src="../Images/8aca8677f476a715496b59cc79c55003.png" data-original-src="https://miro.medium.com/v2/resize:fit:1380/format:webp/1*mn7LpcvOB1W57wqK0T1Khg.png"/></div></figure><p id="3f2c" class="pw-post-body-paragraph js jt hi ju b jv jw is jx jy jz iv ka kb kc kd ke kf kg kh ki kj kk kl km kn hb bi translated">一旦<strong class="ju hs"> Update </strong>被声明为抽象方法，我们将能够看到编译器在<strong class="ju hs"> Enemy: </strong>的子类中显示一个错误</p><figure class="jh ji jj jk fd jl er es paragraph-image"><div role="button" tabindex="0" class="jm jn di jo bf jp"><div class="er es nn"><img src="../Images/ec83d42a5795821ebd3c2a51770048fc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PGKBA_xv6NVyBNI2Nu6MPg.png"/></div></div></figure><p id="ed99" class="pw-post-body-paragraph js jt hi ju b jv jw is jx jy jz iv ka kb kc kd ke kf kg kh ki kj kk kl km kn hb bi translated">显示这个错误是因为我们应该在子类中强制实现<strong class="ju hs"> Update </strong>方法。因此，为了解决这个问题，让我们在<strong class="ju hs"> MossGiant </strong>和<strong class="ju hs"> Spider </strong>子类中实现<strong class="ju hs">覆盖更新</strong>方法:</p><figure class="jh ji jj jk fd jl er es paragraph-image"><div class="er es no"><img src="../Images/89c8e45540bdd46708f48ff8a8c6a0ce.png" data-original-src="https://miro.medium.com/v2/resize:fit:1312/format:webp/1*DpJijL568vIhfQg_-XDsaQ.png"/></div></figure><p id="c937" class="pw-post-body-paragraph js jt hi ju b jv jw is jx jy jz iv ka kb kc kd ke kf kg kh ki kj kk kl km kn hb bi translated">这样我们可以确保我们创建的每个敌人都强制实现了<strong class="ju hs"> Update </strong>方法。通过使用抽象类或虚拟方法，我们能够交付一组功能性的、有组织的类，它们使用类似的机制，就像我们游戏中的敌人。</p><p id="5bd0" class="pw-post-body-paragraph js jt hi ju b jv jw is jx jy jz iv ka kb kc kd ke kf kg kh ki kj kk kl km kn hb bi translated">就这样，我们用抽象类实现了Unity的敌人机制！:d .我会在下一篇文章中看到你，在那里我会继续用Unity开发我们的2D游戏。</p></div><div class="ab cl np nq gp nr" role="separator"><span class="ns bw bk nt nu nv"/><span class="ns bw bk nt nu nv"/><span class="ns bw bk nt nu"/></div><div class="hb hc hd he hf"><blockquote class="ms mt mu"><p id="4311" class="js jt mq ju b jv jw is jx jy jz iv ka mv kc kd ke mw kg kh ki mx kk kl km kn hb bi translated"><em class="hi">如果你想更多地了解我，欢迎登陆</em><a class="ae ko" href="https://www.linkedin.com/in/fas444/" rel="noopener ugc nofollow" target="_blank"><strong class="ju hs"><em class="hi">LinkedIn</em></strong></a><strong class="ju hs"><em class="hi"/></strong><em class="hi">或访问我的</em> <a class="ae ko" href="http://fernandoalcasan.com/" rel="noopener ugc nofollow" target="_blank"> <strong class="ju hs"> <em class="hi">网站</em> </strong> </a> <em class="hi"> :D </em></p></blockquote></div></div>    
</body>
</html>