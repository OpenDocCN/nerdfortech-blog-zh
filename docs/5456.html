<html>
<head>
<title>Java Virtual Machine(JVM) Architecture</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Java虚拟机(JVM)架构</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/java-virtual-machine-jvm-architecture-87b5bdd47403?source=collection_archive---------0-----------------------#2021-10-04">https://medium.com/nerd-for-tech/java-virtual-machine-jvm-architecture-87b5bdd47403?source=collection_archive---------0-----------------------#2021-10-04</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="cd0c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">无论您是否使用过Java编写程序，您可能在某个时候听说过Java虚拟机(JVM)。对于Java开发人员来说，理解Java虚拟机(JVM)的体系结构和Java的工作方式非常重要，这样才能及时充分地利用它。</p><p id="3abf" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在本文中，我们将学习更多关于JVM的知识，它是如何工作的，以及组成它的各种组件。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es jd"><img src="../Images/bf1ab99fff3ff4f55ef6c56a532897bb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*931bEfFbFljJv5EYBXOugQ.jpeg"/></div></div><figcaption class="jp jq et er es jr js bd b be z dx translated">虚拟机（Java Virtual Machine的缩写）</figcaption></figure><p id="32e9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在JVM之前，我们先来了解一下Java。</p><h1 id="1c96" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">Java是什么？</h1><p id="b871" class="pw-post-body-paragraph if ig hi ih b ii kr ik il im ks io ip iq kt is it iu ku iw ix iy kv ja jb jc hb bi translated">Java是一种强大的通用编程语言。它用于开发桌面和移动应用程序、大数据处理、嵌入式系统等等。据拥有Java的甲骨文公司称，Java在全球30亿台设备上运行，这使得Java成为最受欢迎的编程语言之一。</p><h2 id="bdfb" class="kw ju hi bd jv kx ky kz jz la lb lc kd iq ld le kh iu lf lg kl iy lh li kp lj bi translated"><strong class="ak">Java的组件</strong></h2><p id="f500" class="pw-post-body-paragraph if ig hi ih b ii kr ik il im ks io ip iq kt is it iu ku iw ix iy kv ja jb jc hb bi translated">了解Java的组成部分是学习Java的必要条件。这些组件有助于高效开发各种Java解决方案。用Java写完程序后，必须把它转换成机器语言，这样它才能被计算机理解和执行。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es lk"><img src="../Images/3969ca66dacd30ac0d4b15efc261926a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1302/format:webp/1*DiwEAkHJUkeH4Io0eHWWfw.png"/></div><figcaption class="jp jq et er es jr js bd b be z dx translated">Java组件</figcaption></figure><blockquote class="ll lm ln"><p id="fdca" class="if ig lo ih b ii ij ik il im in io ip lp ir is it lq iv iw ix lr iz ja jb jc hb bi translated">1.Java开发工具包。<br/>(JDK)2。Java运行时环境。<br/>(JRE)3。Java虚拟机。(JVM)</p></blockquote><h2 id="5141" class="kw ju hi bd jv kx ky kz jz la lb lc kd iq ld le kh iu lf lg kl iy lh li kp lj bi translated">Java运行时环境与Java开发工具包</h2><p id="e83d" class="pw-post-body-paragraph if ig hi ih b ii kr ik il im ks io ip iq kt is it iu ku iw ix iy kv ja jb jc hb bi translated">Java运行时环境(JRE)和Java开发工具包(JDK)是两种最常见的Java发行版。Java运行时环境(JRE)由Java虚拟机(JVM)和Java类库组成。这些提供了运行Java程序所需的能力。JDK还包括编写Java程序所需的开发工具。JDK由三部分组成:Java编译器、Java虚拟机和Java类库。</p><h1 id="2335" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">什么是虚拟机？</h1><p id="6bc7" class="pw-post-body-paragraph if ig hi ih b ii kr ik il im ks io ip iq kt is it iu ku iw ix iy kv ja jb jc hb bi translated">在我们进入JVM之前，让我们回顾一下虚拟机(VM)的概念。一台物理机可以运行多个虚拟机，每个虚拟机都有自己的操作系统和应用程序。这些虚拟机相互隔离。</p><p id="7a13" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">VM中主要有两个类别，如下图所示:</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es ls"><img src="../Images/ade853fb6957ed085d90af557191ea8b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*z0Lt5kO4KuB29dpEO0N1kQ.png"/></div></div><figcaption class="jp jq et er es jr js bd b be z dx translated">虚拟机类型</figcaption></figure><ol class=""><li id="3e49" class="lt lu hi ih b ii ij im in iq lv iu lw iy lx jc ly lz ma mb bi translated"><strong class="ih hj">基于系统的虚拟机(SVM)</strong>——这为你创造了一个为多个用户或多个实例工作的环境。这些环境是完全独立的。</li><li id="e6f2" class="lt lu hi ih b ii mc im md iq me iu mf iy mg jc ly lz ma mb bi translated"><strong class="ih hj">基于应用的虚拟机(AVM)或基于进程的虚拟机</strong>——在这里，它将允许你在主机上运行一个应用程序。您可能有帮助我们运行其他程序的软件或应用程序。<br/> eg -JVM，CLR-公共语言运行时→Helps。net来创建虚拟机。，<br/>PVM-鹦鹉虚拟机→创建动态语言环境。没有硬件，但它创造了一个平台或环境来运行某种语言作为输入，并将其转换为其他人可以理解的不同语言或不同输出。</li></ol><h1 id="060c" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">什么是Java虚拟机？</h1><p id="f8cd" class="pw-post-body-paragraph if ig hi ih b ii kr ik il im ks io ip iq kt is it iu ku iw ix iy kv ja jb jc hb bi translated">Java虚拟机(JVM)是一个为Java程序提供运行时环境的引擎。它将Java字节码转换成机器码。Java虚拟机(JVM)是Java运行环境(JRE)的组成部分。JVM完全是一个规范。</p><p id="8cac" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">当你下载JRE时，JVM也随之而来。当您安装JRE时，它将部署可以创建JVM的所有代码。如果我们在windows机器上安装JRE，它将部署代码，这将需要为windows环境创建JVM。如果我们在mac环境上安装JRE，它将部署代码来创建用于mac环境的JVM。</p><p id="a281" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">将为每个程序构建一个Java虚拟机(JVM)实例。结果，在程序完成后，JVM实例被销毁。JVM还将创建一个非守护进程(用户线程)线程来执行Java程序。</p><h2 id="b22b" class="kw ju hi bd jv kx ky kz jz la lb lc kd iq ld le kh iu lf lg kl iy lh li kp lj bi translated"><strong class="ak">Java虚拟机的生命周期</strong></h2><ul class=""><li id="be50" class="lt lu hi ih b ii kr im ks iq mh iu mi iy mj jc mk lz ma mb bi translated">当java应用程序启动时，会创建一个JVM运行时实例。当应用程序完成时，实例终止。</li><li id="7b27" class="lt lu hi ih b ii mc im md iq me iu mf iy mg jc mk lz ma mb bi translated">如果在同一台计算机上同时启动三个java应用程序，将会有三个java虚拟机实例在运行</li><li id="ef1e" class="lt lu hi ih b ii mc im md iq me iu mf iy mg jc mk lz ma mb bi translated">每个java应用程序都在自己的java虚拟机中运行。</li></ul><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es ml"><img src="../Images/5f4672d21638c63803773420f84f42fd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1042/format:webp/1*Tur-pSbx3tZOgy1rTEopWw.png"/></div><figcaption class="jp jq et er es jr js bd b be z dx translated">每个应用程序的JVM</figcaption></figure><p id="2470" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">JVM将在两种情况下被销毁，例如:</p><ol class=""><li id="8bda" class="lt lu hi ih b ii ij im in iq lv iu lw iy lx jc ly lz ma mb bi translated">如果没有运行非守护线程。此时，JVM将强制终止所有活动的守护进程线程。</li><li id="8a49" class="lt lu hi ih b ii mc im md iq me iu mf iy mg jc ly lz ma mb bi translated">如果Java app杀了自己(通过调用System.exit()方法)。</li></ol><p id="8876" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">而且很明显，JVM一旦崩溃就会被摧毁。</p><h2 id="f4cf" class="kw ju hi bd jv kx ky kz jz la lb lc kd iq ld le kh iu lf lg kl iy lh li kp lj bi translated">JVM的组件</h2><p id="fcfb" class="pw-post-body-paragraph if ig hi ih b ii kr ik il im ks io ip iq kt is it iu ku iw ix iy kv ja jb jc hb bi translated">JVM由三个组件组成，它们是</p><ol class=""><li id="4452" class="lt lu hi ih b ii ij im in iq lv iu lw iy lx jc ly lz ma mb bi translated">类加载器——加载类文件</li><li id="56ee" class="lt lu hi ih b ii mc im md iq me iu mf iy mg jc ly lz ma mb bi translated">内存区域-存储类</li><li id="5e69" class="lt lu hi ih b ii mc im md iq me iu mf iy mg jc ly lz ma mb bi translated">执行引擎-执行/提供运行时环境</li></ol><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es mm"><img src="../Images/2d51273c8e9f27ddd571110c17efd800.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6LjzhFkFkzON62364zBUlw.png"/></div></div><figcaption class="jp jq et er es jr js bd b be z dx translated">JVM组件</figcaption></figure><p id="9cb2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们更深入地了解一下每个组件。</p><h1 id="0252" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">1.类装入器</h1><p id="d60e" class="pw-post-body-paragraph if ig hi ih b ii kr ik il im ks io ip iq kt is it iu ku iw ix iy kv ja jb jc hb bi translated">它负责以下三项活动</p><ol class=""><li id="a516" class="lt lu hi ih b ii ij im in iq lv iu lw iy lx jc ly lz ma mb bi translated">装货</li><li id="0dae" class="lt lu hi ih b ii mc im md iq me iu mf iy mg jc ly lz ma mb bi translated">连接</li><li id="811f" class="lt lu hi ih b ii mc im md iq me iu mf iy mg jc ly lz ma mb bi translated">初始化</li></ol><h2 id="effc" class="kw ju hi bd jv kx ky kz jz la lb lc kd iq ld le kh iu lf lg kl iy lh li kp lj bi translated">装货</h2><p id="8ba1" class="pw-post-body-paragraph if ig hi ih b ii kr ik il im ks io ip iq kt is it iu ku iw ix iy kv ja jb jc hb bi translated">该组件将为您加载类。引导类加载器、扩展类加载器、应用程序类加载器是三个有助于实现它的类加载器。</p><p id="93d2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">JVM的类加载器子系统负责加载类文件(。类)存储到内存中。当我们运行一个Java程序时，类装入器首先装入它。当JVM加载一个类时，它在方法区域存储以下信息。</p><ul class=""><li id="445a" class="lt lu hi ih b ii ij im in iq lv iu lw iy lx jc mk lz ma mb bi translated">加载的类的完全限定名。</li><li id="6930" class="lt lu hi ih b ii mc im md iq me iu mf iy mg jc mk lz ma mb bi translated">加载的类的直接父类。(如果没有父类，JVM会将加载的类作为父类)</li><li id="84b4" class="lt lu hi ih b ii mc im md iq me iu mf iy mg jc mk lz ma mb bi translated">是否该”。“class”文件是一个类、接口或枚举。</li><li id="557a" class="lt lu hi ih b ii mc im md iq me iu mf iy mg jc mk lz ma mb bi translated">关于修饰符、变量和方法信息的细节，等等。</li></ul><p id="f1f6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">加载点类文件后，JVM立即在堆内存上为加载的类创建一个类型为<strong class="ih hj"> java.lang.Class. </strong>的对象。该类类型对象是java.lang包中预定义的类对象。程序员可以使用Class类对象来获取关于类的方法、变量和构造函数等信息。</p><h2 id="71e5" class="kw ju hi bd jv kx ky kz jz la lb lc kd iq ld le kh iu lf lg kl iy lh li kp lj bi translated">连接</h2><ol class=""><li id="0258" class="lt lu hi ih b ii kr im ks iq mh iu mi iy mj jc ly lz ma mb bi translated">验证-字节码验证器将验证生成的字节码是否正确，如果验证失败，我们将得到验证错误。</li><li id="44b8" class="lt lu hi ih b ii mc im md iq me iu mf iy mg jc ly lz ma mb bi translated">prepare-对于所有静态变量，内存将被分配并赋予默认值。</li><li id="4de9" class="lt lu hi ih b ii mc im md iq me iu mf iy mg jc ly lz ma mb bi translated">resolve-所有符号内存引用都被替换为方法区域中的原始引用。</li></ol><h2 id="6229" class="kw ju hi bd jv kx ky kz jz la lb lc kd iq ld le kh iu lf lg kl iy lh li kp lj bi translated"><strong class="ak">初始化</strong></h2><p id="c034" class="pw-post-body-paragraph if ig hi ih b ii kr ik il im ks io ip iq kt is it iu ku iw ix iy kv ja jb jc hb bi translated">这是类加载过程的最后一步，所有静态变量都被赋予它们的初始值，静态块被执行。</p><h1 id="1546" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">2.<strong class="ak">记忆区</strong></h1><p id="f316" class="pw-post-body-paragraph if ig hi ih b ii kr ik il im ks io ip iq kt is it iu ku iw ix iy kv ja jb jc hb bi translated">JVM的内存区域是存储数据的地方。方法区、堆区、堆栈、程序计数器(PC)寄存器和本机方法区是JVM内存区的五个子区。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es mn"><img src="../Images/4122bf140db4074710fd0a4e689ad544.png" data-original-src="https://miro.medium.com/v2/resize:fit:1204/format:webp/1*mX0Y3ae62pS9w7EiHN-AGQ.jpeg"/></div><figcaption class="jp jq et er es jr js bd b be z dx translated">JVM的内存区域</figcaption></figure><p id="c3ac" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">类区</strong>-每个类的类级数据都存储在这里，比如运行时常量池、字段和方法数据，以及方法代码。</p><p id="cc27" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">Heap</strong>——堆区是在虚拟机启动时创建的，从这里为所有类实例和数组分配内存，代表运行时数据区。</p><p id="4d54" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">堆栈</strong>——在Java中，堆栈内存用于静态内存分配和线程执行。这是专为每根线打造的。当线程启动时，JVM创建一个单独的运行时堆栈，在其中存储方法调用。对于每个方法调用，将产生一个帧并将其推入运行时堆栈的存储中。当一个框架的方法调用完成时，它被销毁。</p><p id="92f1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">程序计数器寄存器- </strong>每个线程都有自己的PC寄存器，用来存储当前执行指令的地址。一旦指令完成，PC寄存器将被下一条指令更新。</p><p id="70a7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">本地方法区- </strong>这将存储关于本地方法的信息，这些方法是用Java以外的语言编写的，比如C或C++。每个新线程都有自己的本地方法堆栈，就像堆栈和PC寄存器一样。</p><h1 id="f405" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">3.执行引擎</h1><p id="8ce4" class="pw-post-body-paragraph if ig hi ih b ii kr ik il im ks io ip iq kt is it iu ku iw ix iy kv ja jb jc hb bi translated">执行引擎将运行分配给内存区域的字节码。执行引擎逐个读取字节码并执行它。它将包含三个部分。</p><p id="bce5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">解释器</strong>-读取字节，解释它们，然后逐个执行。解释器的基本缺点是，当同一个方法被多次调用时，每次都需要一个新的解释，因此会降低系统的性能。JIT编译器就是为它提供的解决方案。</p><p id="f342" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> JIT编译器(即时编译器)</strong>-运行时环境包括即时(JIT)编译器。通过在运行时将字节码编译成机器码，它有助于Java应用程序的性能。</p><p id="9c35" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">垃圾收集器</strong>——顾名思义，就是收集不用的材料的工具。垃圾收集会在JVM上处理这个问题。它跟踪JVM堆区域中的每个项目，并删除不需要的项目。<br/>标记和清扫是垃圾收集器使用的两个简单步骤:</p><blockquote class="ll lm ln"><p id="253d" class="if ig lo ih b ii ij ik il im in io ip lp ir is it lq iv iw ix lr iz ja jb jc hb bi translated">标记——垃圾收集器在这里识别哪个内存块正在使用，哪个没有被<br/>清除——它删除在“标记”阶段识别的对象</p></blockquote><h1 id="e8e4" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">参考</h1><ol class=""><li id="3ba6" class="lt lu hi ih b ii kr im ks iq mh iu mi iy mj jc ly lz ma mb bi translated">2021，Java虚拟机架构讲解，【视频】-【https://www.youtube.com/watch?v=jnpuRvRdTgI T4】</li><li id="d5ae" class="lt lu hi ih b ii mc im md iq me iu mf iy mg jc ly lz ma mb bi translated">2020，Java架构与组件，[文档]-<a class="ae mo" href="https://www.lsraheja.org/wp-content/uploads/2020/04/SYBSCIT-SEM-IV-Core-Java-Unit-I-II.pdf" rel="noopener ugc nofollow" target="_blank">https://www . lsraheja . org/WP-content/uploads/2020/04/SYBSCIT-SEM-IV-Core-Java-Unit-I-ii . pdf</a></li><li id="d12e" class="lt lu hi ih b ii mc im md iq me iu mf iy mg jc ly lz ma mb bi translated">2016，什么是JVM，【视频】-<a class="ae mo" href="https://www.youtube.com/watch?v=bUtIIWbaFKc" rel="noopener ugc nofollow" target="_blank">https://www.youtube.com/watch?v=bUtIIWbaFKc</a></li></ol></div></div>    
</body>
</html>