<html>
<head>
<title>Learning Go — Maps &amp; Structs</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">学习围棋—地图和结构</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/learning-go-maps-structs-5e131869bd96?source=collection_archive---------0-----------------------#2020-11-20">https://medium.com/nerd-for-tech/learning-go-maps-structs-5e131869bd96?source=collection_archive---------0-----------------------#2020-11-20</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/f5bb59682f6053470d75c70cac45c605.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AJAGtpn_f7wMFdcwFn95LA.png"/></div></div></figure><p id="7ccf" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这篇文章致力于Go中的另一种数据类型——<strong class="is hj">映射</strong>和<strong class="is hj">结构</strong>。我们开始吧！</p><h1 id="d145" class="jo jp hi bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated"><strong class="ak">地图</strong></h1><p id="1675" class="pw-post-body-paragraph iq ir hi is b it km iv iw ix kn iz ja jb ko jd je jf kp jh ji jj kq jl jm jn hb bi translated">Map是存储<key value="">对的数据结构。映射的键只能是值类型数据类型，即可以将int、string、array作为键。不能将类似切片的引用类型作为映射键。地图可以初始化为</key></p><figure class="kr ks kt ku fd ij"><div class="bz dy l di"><div class="kv kw l"/></div></figure><blockquote class="kx ky kz"><p id="6744" class="iq ir la is b it iu iv iw ix iy iz ja lb jc jd je lc jg jh ji ld jk jl jm jn hb bi translated"><strong class="is hj">注意</strong>:注意地图打印的顺序。&lt;键，值&gt;对以lex键排序打印。</p></blockquote><h2 id="2a47" class="le jp hi bd jq lf lg lh ju li lj lk jy jb ll lm kc jf ln lo kg jj lp lq kk lr bi translated"><strong class="ak">添加一个&lt;键，值&gt;对</strong></h2><pre class="kr ks kt ku fd ls lt lu lv aw lw bi"><span id="5ca9" class="le jp hi lt b fi lx ly l lz ma">makeMap["Punjab"] = 180<br/>fmt.Println(makeMap["Punjab"])</span><span id="e33e" class="le jp hi lt b fi mb ly l lz ma"><strong class="lt hj">Result</strong><br/>180</span></pre><h2 id="c9d3" class="le jp hi bd jq lf lg lh ju li lj lk jy jb ll lm kc jf ln lo kg jj lp lq kk lr bi translated"><strong class="ak">访问一个值</strong></h2><p id="ce97" class="pw-post-body-paragraph iq ir hi is b it km iv iw ix kn iz ja jb ko jd je jf kp jh ji jj kq jl jm jn hb bi translated">访问一个值类似于数组<strong class="is hj"> [] </strong>操作符。</p><pre class="kr ks kt ku fd ls lt lu lv aw lw bi"><span id="37ba" class="le jp hi lt b fi lx ly l lz ma">fmt.Println(makeMap["UP"])</span><span id="f418" class="le jp hi lt b fi mb ly l lz ma"><strong class="lt hj">Result</strong><br/>235</span></pre><h2 id="7e39" class="le jp hi bd jq lf lg lh ju li lj lk jy jb ll lm kc jf ln lo kg jj lp lq kk lr bi translated"><strong class="ak">删除一个&lt;键，值&gt;对</strong></h2><p id="6ef2" class="pw-post-body-paragraph iq ir hi is b it km iv iw ix kn iz ja jb ko jd je jf kp jh ji jj kq jl jm jn hb bi translated">要删除map中的一个条目，我们可以使用内部的<strong class="is hj"> delete() </strong>方法。</p><pre class="kr ks kt ku fd ls lt lu lv aw lw bi"><span id="bb73" class="le jp hi lt b fi lx ly l lz ma">fmt.Println(makeMap)<br/>delete(makeMap, "Punjab")<br/>fmt.Println(makeMap["Punjab"])<br/>fmt.Println(makeMap)</span><span id="e296" class="le jp hi lt b fi mb ly l lz ma"><strong class="lt hj">Result</strong><br/>map[Delhi:150 Karnataka:150 MP:175 Maharashtra:200 Punjab:180 Rajasthan:165 UP:235]<br/>0  // Instead of returning an error or nil, <strong class="lt hj">we get a 0?</strong><br/>map[Delhi:150 Karnataka:150 MP:175 Maharashtra:200 Rajasthan:165 UP:235]</span></pre></div><div class="ab cl mc md gp me" role="separator"><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh"/></div><div class="hb hc hd he hf"><blockquote class="mj"><p id="1575" class="mk ml hi bd mm mn mo mp mq mr ms jn dx translated">→重新访问<br/>如果您观察到<strong class="ak">结果中的第二条语句，</strong>我们<strong class="ak">得到一个0值</strong>用于打印关键字<strong class="ak">“Punjab”</strong>post，将其从地图中删除。这是令人困惑的，为什么我们得到任何值时，键已被删除。为了解决这个问题，可以使用什么来代替<strong class="ak">访问地图</strong>中的键</p></blockquote><pre class="mt mu mv mw mx ls lt lu lv aw lw bi"><span id="d460" class="le jp hi lt b fi lx ly l lz ma">punjabPop, ok := statePop["Punjab"]<br/>fmt.Println(punjabPop, ok)</span><span id="fb49" class="le jp hi lt b fi mb ly l lz ma"><strong class="lt hj">Result</strong><br/>0 false  // false indicates that key was not found. This can be used to verify for the presence of key and then using the value.</span></pre><blockquote class="kx ky kz"><p id="0257" class="iq ir la is b it iu iv iw ix iy iz ja lb jc jd je lc jg jh ji ld jk jl jm jn hb bi translated">注意:ok不是必须的，但它是围棋中遵循的惯例。这是一个布尔变量。</p></blockquote><h2 id="0a22" class="le jp hi bd jq lf lg lh ju li lj lk jy jb ll lm kc jf ln lo kg jj lp lq kk lr bi translated"><strong class="ak">地图的长度</strong></h2><p id="95f0" class="pw-post-body-paragraph iq ir hi is b it km iv iw ix kn iz ja jb ko jd je jf kp jh ji jj kq jl jm jn hb bi translated">使用<strong class="is hj"> len() </strong>函数可以确定地图的长度。</p><pre class="kr ks kt ku fd ls lt lu lv aw lw bi"><span id="87cc" class="le jp hi lt b fi lx ly l lz ma">fmt.Println("Length of map : ", len(makeMap))</span><span id="e5bc" class="le jp hi lt b fi mb ly l lz ma"><strong class="lt hj">Result</strong><br/>Length of map : 6</span></pre></div><div class="ab cl mc md gp me" role="separator"><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh"/></div><div class="hb hc hd he hf"><h2 id="ec6c" class="le jp hi bd jq lf lg lh ju li lj lk jy jb ll lm kc jf ln lo kg jj lp lq kk lr bi translated"><strong class="ak">作为参考类型的地图</strong></h2><p id="0218" class="pw-post-body-paragraph iq ir hi is b it km iv iw ix kn iz ja jb ko jd je jf kp jh ji jj kq jl jm jn hb bi translated">地图是一种引用类型。因此，如果一个变量<strong class="is hj"> x被赋予另一个映射</strong>变量的值，x开始引用该映射。在x上所做的任何改变也会改变底层地图。</p><pre class="kr ks kt ku fd ls lt lu lv aw lw bi"><span id="3781" class="le jp hi lt b fi lx ly l lz ma">cloneMap := makeMap<br/>fmt.Println("makeMap : ", makeMap)<br/>fmt.Println("cloneMap : ",cloneMap)<br/>cloneMap["Maharashtra"] = 190<br/>fmt.Println("makeMap : ", makeMap)<br/>fmt.Println("cloneMap : ",cloneMap)</span><span id="7f22" class="le jp hi lt b fi mb ly l lz ma"><strong class="lt hj">Result</strong><br/>makeMap : map[Delhi:150 Karnataka:150 MP:175 Maharashtra:200 Rajasthan:165 UP:235]<br/>cloneMap : map[Delhi:150 Karnataka:150 MP:175 Maharashtra:200 Rajasthan:165 UP:235]<br/>makeMap : map[Delhi:150 Karnataka:150 MP:175 Maharashtra:190 Rajasthan:165 UP:235]<br/>cloneMap : map[Delhi:150 Karnataka:150 MP:175 Maharashtra:190 Rajasthan:165 UP:235]</span></pre></div><div class="ab cl mc md gp me" role="separator"><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh"/></div><div class="hb hc hd he hf"><h1 id="fe42" class="jo jp hi bd jq jr my jt ju jv mz jx jy jz na kb kc kd nb kf kg kh nc kj kk kl bi translated"><strong class="ak">结构</strong></h1><p id="ac36" class="pw-post-body-paragraph iq ir hi is b it km iv iw ix kn iz ja jb ko jd je jf kp jh ji jj kq jl jm jn hb bi translated">一个<strong class="is hj">struct</strong>(“structure”的缩写)是一个带有声明数据类型的数据字段的集合。Go能够通过组合一个或多个类型来声明和创建自己的数据类型，包括内置和用户定义的类型。结构中的每个数据字段都是用已知类型声明的，该类型可以是内置类型或其他用户定义的类型。</p><p id="7ad4" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如果你在过去的编程经验中练习过<strong class="is hj"> C </strong>，那么struct对你来说很容易理解。</p><figure class="kr ks kt ku fd ij"><div class="bz dy l di"><div class="kv kw l"/></div></figure><h2 id="db24" class="le jp hi bd jq lf lg lh ju li lj lk jy jb ll lm kc jf ln lo kg jj lp lq kk lr bi translated">观察:</h2><ol class=""><li id="50af" class="nd ne hi is b it km ix kn jb nf jf ng jj nh jn ni nj nk nl bi translated">结构定义在<strong class="is hj"> func main() </strong>之外声明</li><li id="2c2d" class="nd ne hi is b it nm ix nn jb no jf np jj nq jn ni nj nk nl bi translated">struct实例是在<strong class="is hj"> func main() </strong>中声明的</li><li id="c939" class="nd ne hi is b it nm ix nn jb no jf np jj nq jn ni nj nk nl bi translated">在实例化过程中，字段被赋予一个值。</li><li id="dc81" class="nd ne hi is b it nm ix nn jb no jf np jj nq jn ni nj nk nl bi translated"><strong class="is hj">、</strong>、<strong class="is hj"> }、</strong>以尾随逗号结束。如果没有逗号，你会得到错误。</li></ol><h2 id="b2d4" class="le jp hi bd jq lf lg lh ju li lj lk jy jb ll lm kc jf ln lo kg jj lp lq kk lr bi translated"><strong class="ak">不同的实例化方法</strong></h2><p id="8c14" class="pw-post-body-paragraph iq ir hi is b it km iv iw ix kn iz ja jb ko jd je jf kp jh ji jj kq jl jm jn hb bi translated"><strong class="is hj">位置声明— </strong>我们可以在初始化期间赋值时省略字段名。Go将根据字段声明的顺序，自动将值映射到定义中的相应字段。<strong class="is hj">我不推荐</strong>这样做，因为如果有一天，定义在预声明的字段之间添加了一个新字段，那么Go编译器会按照新的字段声明顺序映射值，这会产生一个错误。</p><pre class="kr ks kt ku fd ls lt lu lv aw lw bi"><span id="f161" class="le jp hi lt b fi lx ly l lz ma">emp2 := Employee{<br/>   123,<br/>   "prateek",<br/>   []string {<br/>      "Technology",<br/>      "MFP",<br/>      "Delivery",<br/>   },<br/>}</span></pre><blockquote class="kx ky kz"><p id="707c" class="iq ir la is b it iu iv iw ix iy iz ja lb jc jd je lc jg jh ji ld jk jl jm jn hb bi translated"><strong class="is hj">注意:</strong>正如在这篇<a class="ae nr" href="https://guptaprateektechtalks.wordpress.com/2020/04/04/learning-go-variables/" rel="noopener ugc nofollow" target="_blank">文章</a>中所讨论的，如果<strong class="is hj">以大写字母开始命名，那么结构定义和字段可以在当前包之外公开。</strong></p></blockquote><h2 id="db10" class="le jp hi bd jq lf lg lh ju li lj lk jy jb ll lm kc jf ln lo kg jj lp lq kk lr bi translated"><strong class="ak">速记符号</strong></h2><p id="81d5" class="pw-post-body-paragraph iq ir hi is b it km iv iw ix kn iz ja jb ko jd je jf kp jh ji jj kq jl jm jn hb bi translated">这个简写符号是匿名结构。这仅在使用它的函数中可用，而不是在包级别。</p><pre class="kr ks kt ku fd ls lt lu lv aw lw bi"><span id="ea6e" class="le jp hi lt b fi lx ly l lz ma">doc := struct {<br/>   name string<br/>}{name: "prateek"}<br/>fmt.Println("Doctor : ", doc)</span><span id="5873" class="le jp hi lt b fi mb ly l lz ma">Result<br/>Doctor : {prateek}</span></pre><h2 id="d717" class="le jp hi bd jq lf lg lh ju li lj lk jy jb ll lm kc jf ln lo kg jj lp lq kk lr bi translated"><strong class="ak">结构是值类型</strong></h2><p id="232f" class="pw-post-body-paragraph iq ir hi is b it km iv iw ix kn iz ja jb ko jd je jf kp jh ji jj kq jl jm jn hb bi translated"><strong class="is hj">与映射不同，结构是值类型，而不是引用类型</strong>。当变量值被赋予结构变量值时，该值被复制。对新变量的更改不会对原始结构产生副作用。</p><pre class="kr ks kt ku fd ls lt lu lv aw lw bi"><span id="a2b6" class="le jp hi lt b fi lx ly l lz ma">anotherDoc := doc<br/>anotherDoc.name = "gupta"<br/>fmt.Println("doc Doctor : ", doc)<br/>fmt.Println("anotherDoc Doctor : ", anotherDoc)</span><span id="10ef" class="le jp hi lt b fi mb ly l lz ma"><strong class="lt hj">Result</strong><br/>doc Doctor : {prateek}<br/>anotherDoc Doctor : {gupta}</span></pre><h2 id="f2e4" class="le jp hi bd jq lf lg lh ju li lj lk jy jb ll lm kc jf ln lo kg jj lp lq kk lr bi translated"><strong class="ak">访问结构的值</strong></h2><p id="60b9" class="pw-post-body-paragraph iq ir hi is b it km iv iw ix kn iz ja jb ko jd je jf kp jh ji jj kq jl jm jn hb bi translated">可以使用<strong class="is hj">点(.)</strong>操作员。</p><pre class="kr ks kt ku fd ls lt lu lv aw lw bi"><span id="a390" class="le jp hi lt b fi lx ly l lz ma">fmt.Printf( "Employee id : %v and name : %v and departments : %v", <br/>emp.id, emp.name, emp.dept)</span><span id="58ac" class="le jp hi lt b fi mb ly l lz ma"><strong class="lt hj">Result<br/></strong>Employee id : 123 and name : prateek and departments : [Technology MFP Delivery]</span></pre><h2 id="5d10" class="le jp hi bd jq lf lg lh ju li lj lk jy jb ll lm kc jf ln lo kg jj lp lq kk lr bi translated"><strong class="ak"> &amp;【地址】操作员</strong></h2><p id="93b2" class="pw-post-body-paragraph iq ir hi is b it km iv iw ix kn iz ja jb ko jd je jf kp jh ji jj kq jl jm jn hb bi translated">就像数组一样，<strong class="is hj"> &amp; </strong>在结构上也很相似。如果裁判更新了值，则被引用的结构会被修改。</p><pre class="kr ks kt ku fd ls lt lu lv aw lw bi"><span id="772f" class="le jp hi lt b fi lx ly l lz ma">refDoc := &amp;doc<br/>refDoc.name = "gupta"<br/>fmt.Println("doc Doctor : ", doc)<br/>fmt.Println("refDoc Doctor : ", refDoc)</span><span id="3dc5" class="le jp hi lt b fi mb ly l lz ma"><strong class="lt hj">Result</strong><br/>doc Doctor : {gupta}<br/>refDoc Doctor : &amp;{gupta}</span></pre><h2 id="8da2" class="le jp hi bd jq lf lg lh ju li lj lk jy jb ll lm kc jf ln lo kg jj lp lq kk lr bi translated"><strong class="ak">嵌套结构</strong></h2><p id="8b23" class="pw-post-body-paragraph iq ir hi is b it km iv iw ix kn iz ja jb ko jd je jf kp jh ji jj kq jl jm jn hb bi translated">围棋<strong class="is hj">没有<em class="la">传承</em>。</strong>代替<strong class="is hj">跟随<em class="la">构图</em>。</strong> Go不遵循IsA关系，而是遵循hasA关系。<strong class="is hj">嵌套结构</strong>就是实现这一点的方法。</p><pre class="kr ks kt ku fd ls lt lu lv aw lw bi"><span id="2dfc" class="le jp hi lt b fi lx ly l lz ma">type Person struct {<br/>   name string<br/>   age int<br/>}</span><span id="e2e6" class="le jp hi lt b fi mb ly l lz ma">type Profession struct {<br/>   Person<br/>   myProfession string<br/>}</span><span id="fe97" class="le jp hi lt b fi mb ly l lz ma">func main() {<br/>myProf := Profession{<br/>   Person : Person{<br/>      name : "prateek",<br/>      age : 27,<br/>   },<br/>   myProfession: "Engineer",<br/>}<br/>fmt.Println(myProf)</span><span id="e262" class="le jp hi lt b fi mb ly l lz ma">yourProf := Profession{}<br/>yourProf.name = "prateek"<br/>yourProf.age = 27<br/>yourProf.myProfession = "Engineer"<br/>fmt.Println(yourProf)<br/>}</span><span id="1d9f" class="le jp hi lt b fi mb ly l lz ma"><strong class="lt hj">Result</strong><br/>{{prateek 27} Engineer}<br/>{{prateek 27} Engineer}</span></pre><p id="444e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">观察<strong class="is hj">结构人在结构职业中的嵌套。<br/> </strong>可以观察变量<strong class="is hj"> myProf </strong>和<strong class="is hj"> yourProf。</strong>两者都是初始化结构体的不同方法。</p><h2 id="349c" class="le jp hi bd jq lf lg lh ju li lj lk jy jb ll lm kc jf ln lo kg jj lp lq kk lr bi translated"><strong class="ak">标签</strong></h2><p id="367e" class="pw-post-body-paragraph iq ir hi is b it km iv iw ix kn iz ja jb ko jd je jf kp jh ji jj kq jl jm jn hb bi translated">标记是突出显示结构中验证规则的一种方式。您可以<strong class="is hj">将规则标记到结构内部的字段</strong>，并使用<strong class="is hj">反射库</strong>将这些映射的规则打印/返回到字段。</p><pre class="kr ks kt ku fd ls lt lu lv aw lw bi"><span id="cf21" class="le jp hi lt b fi lx ly l lz ma">// Updated the previously declared Person struct with tags</span><span id="657a" class="le jp hi lt b fi mb ly l lz ma">type Person struct {<br/>   name string `required max : "10"`<br/>   age int `required min &gt; 18 and max &lt; 80`<br/>}</span><span id="45c8" class="le jp hi lt b fi mb ly l lz ma">type Profession struct {<br/>   Person<br/>   myProfession string<br/>}</span><span id="3cee" class="le jp hi lt b fi mb ly l lz ma">refPerson := reflect.TypeOf(Person{})<br/>field, _ := refPerson.FieldByName("name")<br/>fmt.Println(field.Tag)</span><span id="c266" class="le jp hi lt b fi mb ly l lz ma"><strong class="lt hj">Result</strong><br/>required max : "10"</span></pre></div><div class="ab cl mc md gp me" role="separator"><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh"/></div><div class="hb hc hd he hf"><p id="9bf2" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这里我们到了帖子的结尾。我们今天讨论了<strong class="is hj">贴图</strong>和<strong class="is hj">结构</strong>。我们讨论了很多关于声明的东西，不同的声明和初始化方法，标签和使用。</p><p id="a965" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我将在下一期的<strong class="is hj">学习围棋系列文章中回来。</strong>在此之前，如果你发现任何差异，或者如果你想让这篇文章更好，请发表你的<strong class="is hj">评论，如果你觉得有用，请</strong> <strong class="is hj">分享</strong>。</p></div></div>    
</body>
</html>