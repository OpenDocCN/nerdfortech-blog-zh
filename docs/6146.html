<html>
<head>
<title>LeetCode — Search in Rotated Sorted Array</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">LeetCode —在旋转排序数组中搜索</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/leetcode-search-in-rotated-sorted-array-3a5c3487dc4e?source=collection_archive---------0-----------------------#2022-01-06">https://medium.com/nerd-for-tech/leetcode-search-in-rotated-sorted-array-3a5c3487dc4e?source=collection_archive---------0-----------------------#2022-01-06</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><h1 id="2129" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">问题陈述</h1><p id="bab3" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">有一个按升序排序的整数数组<em class="kb"> nums </em>(具有<strong class="jf hj">不同的</strong>值)。</p><p id="baed" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated">在传递给你的函数之前，<em class="kb"> nums </em>被<strong class="jf hj">可能在一个未知的旋转索引<code class="du kh ki kj kk b">k (1 &lt;= k &lt; nums.length)</code>处旋转</strong>，这样得到的数组是* <a class="ae kl" href="https://alkeshghorpade.me/post/leetcode-search-in-rotated-sorted-array" rel="noopener ugc nofollow" target="_blank"> nums[k]，nums[k + 1]，...，nums[n - 1]，nums[0]，nums[1]，...，nums[k - 1] </a> ( <strong class="jf hj"> 0 索引</strong>)。例如，<em class="kb">【0，1，2，4，5，6，7】</em>可能在枢轴索引 3 处旋转，变成<em class="kb">【4，5，6，7，0，1，2】</em>。</p><p id="37f2" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated">给定数组<em class="kb">nums</em>nums<strong class="jf hj">后</strong>可能的旋转和一个整数<em class="kb"> target </em>，如果<em class="kb">在 nums 中则返回<em class="kb"> target </em>的索引，如果不在 nums 中则返回-1</em>。</p><p id="042e" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated">你必须写一个运行时复杂度为<code class="du kh ki kj kk b">O(log n)</code>的算法。</p><p id="ff57" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated">问题陈述摘自:<a class="ae kl" href="https://leetcode.com/problems/search-in-rotated-sorted-array" rel="noopener ugc nofollow" target="_blank">https://leet code . com/problems/search-in-rotated-sorted-array</a></p><p id="d648" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated"><strong class="jf hj">例 1: </strong></p><pre class="km kn ko kp fd kq kk kr ks aw kt bi"><span id="9784" class="ku ig hi kk b fi kv kw l kx ky">Input: nums = [4, 5, 6, 7, 0, 1, 2], target = 0 <br/>Output: 4</span></pre><p id="0bb5" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated"><strong class="jf hj">例 2: </strong></p><pre class="km kn ko kp fd kq kk kr ks aw kt bi"><span id="2e71" class="ku ig hi kk b fi kv kw l kx ky">Input: nums = [4, 5, 6, 7, 0, 1, 2], target = 3 <br/>Output: -1</span></pre><p id="6bd9" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated"><strong class="jf hj">例 3: </strong></p><pre class="km kn ko kp fd kq kk kr ks aw kt bi"><span id="0429" class="ku ig hi kk b fi kv kw l kx ky">Input: nums = [1], target = 0 <br/>Output: -1</span></pre><p id="c4aa" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated"><strong class="jf hj">约束:</strong></p><pre class="km kn ko kp fd kq kk kr ks aw kt bi"><span id="8174" class="ku ig hi kk b fi kv kw l kx ky">- 1 &lt;= nums.length &lt;= 5000 <br/>- 10^4 &lt;= nums[i] &lt;= 10^4 <br/>- All values of nums are unique. <br/>- nums is an ascending array that is possibly rotated. <br/>- -10^4 &lt;= target &lt;= 10^4</span></pre><h1 id="e506" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">说明</h1><h2 id="9931" class="ku ig hi bd ih kz la lb il lc ld le ip jo lf lg it js lh li ix jw lj lk jb ll bi translated">二分搜索法双通</h2><p id="7470" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">最简单的解决方案是找到 pivot 元素。元素小于前一个元素的索引。然后，我们在两个子数组之一上调用二分搜索法。如果我们找到目标元素，我们返回索引或返回-1。</p><p id="5750" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated">该方法的一个 C++代码片段如下所示:</p><pre class="km kn ko kp fd kq kk kr ks aw kt bi"><span id="2b58" class="ku ig hi kk b fi kv kw l kx ky">int rotatedBinarySearch(int arr[], int n, int key) {<br/>    int pivot = findPivot(arr, 0, n - 1);<br/><br/>    if (pivot == -1)<br/>        return binarySearch(arr, 0, n - 1, key);<br/><br/>    if (arr[pivot] == key)<br/>        return pivot;<br/><br/>    if (arr[0] &lt;= key)<br/>        return binarySearch(arr, 0, pivot - 1, key);<br/><br/>    return binarySearch(arr, pivot + 1, n - 1, key);<br/>}<br/><br/>int findPivot(int arr[], int low, int high) {<br/>    if (high &lt; low)<br/>        return -1;<br/><br/>    if (high == low)<br/>        return low;<br/><br/>    int mid = (low + high) / 2;<br/>    if (mid &lt; high &amp;&amp; arr[mid] &gt; arr[mid + 1])<br/>        return mid;<br/><br/>    if (mid &gt; low &amp;&amp; arr[mid] &lt; arr[mid - 1])<br/>        return (mid - 1);<br/><br/>    if (arr[low] &gt;= arr[mid])<br/>        return findPivot(arr, low, mid - 1);<br/><br/>    return findPivot(arr, mid + 1, high);<br/>}<br/><br/>int binarySearch(int arr[], int low, int high, int key) {<br/>    if (high &lt; low)<br/>        return -1;<br/><br/>    int mid = (low + high) / 2;<br/>    if (key == arr[mid])<br/>        return mid;<br/><br/>    if (key &gt; arr[mid])<br/>        return binarySearch(arr, (mid + 1), high, key);<br/><br/>    return binarySearch(arr, low, (mid - 1), key);<br/>}</span></pre><p id="abf3" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated">该方法的时间复杂度为<strong class="jf hj"> O(logN) </strong>，空间复杂度为<strong class="jf hj"> O(1) </strong>。</p><h2 id="dd58" class="ku ig hi bd ih kz la lb il lc ld le ip jo lf lg it js lh li ix jw lj lk jb ll bi translated">二分搜索法一张通行证</h2><p id="6670" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">我们可以在一次循环中找到目标元素，而不是迭代数组两次，一次是为了找到支点，然后在其中一个子数组中找到目标数字。</p><p id="a501" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated">标准的二分搜索法方法需要改变。我们需要将左右索引传递给我们的搜索函数，并根据中间的元素考虑数组的左半部分或右半部分。</p><p id="a608" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated">我们先检查一下算法。</p><pre class="km kn ko kp fd kq kk kr ks aw kt bi"><span id="eff5" class="ku ig hi kk b fi kv kw l kx ky">// searchIndex function<br/>- set mid = low + high / 2<br/><br/>- if low &gt; high<br/>  - return -1<br/><br/>- if nums[mid] == target<br/>  - return mid<br/><br/>- if nums[low] &lt;= nums[mid]<br/>  - if nums[low] &lt;= target &amp;&amp; nums[mid] &gt;= target<br/>    - return searchIndex(nums, low, mid - 1, target)<br/>  - else<br/>    - return searchIndex(nums, mid + 1, high, target)<br/>- else<br/>  - if nums[high] &gt;= target &amp;&amp; nums[mid] &lt;= target<br/>    - return searchIndex(nums, mid + 1, high, target)<br/>  - else<br/>    - return searchIndex(nums, low, mid - 1, target)<br/><br/>// search function<br/>- searchIndex(nums, 0, nums.size() - 1, target)</span></pre><h2 id="81ff" class="ku ig hi bd ih kz la lb il lc ld le ip jo lf lg it js lh li ix jw lj lk jb ll bi translated">C++解决方案</h2><pre class="km kn ko kp fd kq kk kr ks aw kt bi"><span id="bbac" class="ku ig hi kk b fi kv kw l kx ky">class Solution {<br/>static int searchIndex(vector&lt;int&gt;&amp; nums, int left, int right, int target){<br/>    int mid = (left + right) / 2;<br/>    if(left &gt; right){<br/>        return -1;<br/>    }<br/><br/>    if(nums[mid] == target){<br/>        return mid;<br/>    }<br/><br/>    if(nums[left] &lt;= nums[mid]){<br/>        if(nums[left] &lt;= target &amp;&amp; nums[mid] &gt;= target){<br/>            return searchIndex(nums, left, mid - 1, target);<br/>        } else {<br/>            return searchIndex(nums, mid + 1, right, target);<br/>        }<br/>    } else {<br/>        if(nums[right] &gt;= target &amp;&amp; nums[mid] &lt;= target){<br/>            return searchIndex(nums, mid + 1, right, target);<br/>        } else {<br/>            return searchIndex(nums, left, mid - 1, target);<br/>        }<br/>    }<br/>};<br/><br/>public:<br/>    int search(vector&lt;int&gt;&amp; nums, int target) {<br/>        return searchIndex(nums, 0, nums.size() - 1, target);<br/>    }<br/>};</span></pre><h2 id="5116" class="ku ig hi bd ih kz la lb il lc ld le ip jo lf lg it js lh li ix jw lj lk jb ll bi translated">戈朗溶液</h2><pre class="km kn ko kp fd kq kk kr ks aw kt bi"><span id="8cc6" class="ku ig hi kk b fi kv kw l kx ky">func searchIndex(nums []int, left, right, target int) int {<br/>    mid := (left + right) / 2<br/><br/>    if left &gt; right {<br/>        return -1<br/>    }<br/><br/>    if nums[mid] == target {<br/>        return mid<br/>    }<br/><br/>    if nums[left] &lt;= nums[mid] {<br/>        if nums[left] &lt;= target &amp;&amp; nums[mid] &gt;= target {<br/>            return searchIndex(nums, left, mid - 1, target)<br/>        } else {<br/>            return searchIndex(nums, mid + 1, right, target)<br/>        }<br/>    } else {<br/>        if nums[right] &gt;= target &amp;&amp; nums[mid] &lt;= target {<br/>            return searchIndex(nums, mid + 1, right, target)<br/>        } else {<br/>            return searchIndex(nums, left, mid - 1, target)<br/>        }<br/>    }<br/>}<br/><br/>func search(nums []int, target int) int {<br/>    return searchIndex(nums, 0, len(nums) - 1, target)<br/>}</span></pre><h2 id="12c7" class="ku ig hi bd ih kz la lb il lc ld le ip jo lf lg it js lh li ix jw lj lk jb ll bi translated">Javascript 解决方案</h2><pre class="km kn ko kp fd kq kk kr ks aw kt bi"><span id="1c68" class="ku ig hi kk b fi kv kw l kx ky">var searchIndex = function(nums, left, right, target) {<br/>    let mid = (left + right) / 2;<br/><br/>    if(left &gt; mid) {<br/>        return -1;<br/>    }<br/><br/>    if(nums[mid] == target) {<br/>        return mid;<br/>    }<br/><br/>    if (nums[left] &lt;= nums[mid]) {<br/>        if(nums[left] &lt;= target &amp;&amp; nums[mid] &gt;= target) {<br/>            return searchIndex(nums, left, mid - 1, target);<br/>        } else {<br/>            return searchIndex(nums, mid + 1, right, target);<br/>        }<br/>    } else {<br/>        if(nums[right] &gt;= target &amp;&amp; nums[mid] &lt;= target) {<br/>            return searchIndex(nums, mid + 1, right, target);<br/>        } else {<br/>            return searchIndex(nums, left, mid - 1, target);<br/>        }<br/>    }<br/>};<br/><br/>var search = function(nums, target) {<br/>  return searchIndex(nums, 0, nums.length - 1, target);<br/>};</span></pre><p id="3b3d" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated">让我们试着解决这个问题。</p><pre class="km kn ko kp fd kq kk kr ks aw kt bi"><span id="4b55" class="ku ig hi kk b fi kv kw l kx ky">Input: nums = [4, 5, 6, 7, 0, 1, 2], target = 0<br/><br/>Step 1: // search function<br/>        searchIndex(nums, 0, nums.size() - 1, target)<br/><br/>// searchIndex function<br/>Step 2: int mid = (left + right) / 2<br/>        mid = (0 + 6) / 2<br/>            = 6 / 2<br/>            = 3<br/><br/>        if nums[mid] == target<br/>           nums[3] == 0<br/>           7 == 0<br/>           false<br/><br/>        if nums[left] &lt;= nums[mid]<br/>           nums[0] &lt;= nums[3]<br/>           4 &lt;= 7<br/>           true<br/><br/>           if nums[left] &lt;= target &amp;&amp; nums[mid] &gt;= target<br/>              nums[0] &lt;= 0 &amp;&amp; nums[3] &gt;= 0<br/>              4 &lt;= 0 &amp;&amp; 7 &gt;= 0<br/>              false<br/><br/>              return searchIndex(nums, mid + 1, right, target)<br/>                     searchIndex(nums, 4, 6, 0)<br/><br/>// searchIndex(nums, 4, 6, target)<br/>Step 3: int mid = (left + right) / 2<br/>        mid = (4 + 6) / 2<br/>            = 10 / 2<br/>            = 5<br/><br/>        if nums[mid] == target<br/>           nums[5] == 0<br/>           1 == 0<br/>           false<br/><br/>        if nums[left] &lt;= nums[mid]<br/>           nums[4] &lt;= nums[5]<br/>           0 &lt;= 1<br/>           true<br/><br/>           if nums[left] &lt;= target &amp;&amp; nums[mid] &gt;= target<br/>              nums[4] &lt;= 0 &amp;&amp; nums[5] &gt;= 0<br/>              0 &lt;= 0 &amp;&amp; 1 &gt;= 0<br/>              true<br/><br/>              return searchIndex(nums, left, mid - 1, target)<br/>                     searchIndex(nums, 4, 4, 0)<br/><br/>// searchIndex(nums, 4, 4, 0)<br/>Step 4: int mid = (left + right) / 2<br/>        mid = (4 + 4) / 2<br/>            = 8 / 2<br/>            = 4<br/><br/>        if nums[mid] == target<br/>           nums[4] == 0<br/>           0 == 0<br/>           return mid<br/>           return 4<br/><br/>The flow backtracks from step 4 to step 1.<br/><br/>We return the answer as 4.</span></pre></div><div class="ab cl lm ln gp lo" role="separator"><span class="lp bw bk lq lr ls"/><span class="lp bw bk lq lr ls"/><span class="lp bw bk lq lr"/></div><div class="hb hc hd he hf"><p id="c389" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated"><em class="kb">原载于</em><a class="ae kl" href="https://alkeshghorpade.me/post/leetcode-search-in-rotated-sorted-array" rel="noopener ugc nofollow" target="_blank"><em class="kb">https://alkeshghorpade . me</em></a><em class="kb">。</em></p></div></div>    
</body>
</html>