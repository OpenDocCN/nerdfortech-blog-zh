# Rails 自定义类型—作为单个值或自定义类型值的数组

> 原文：<https://medium.com/nerd-for-tech/rails-custom-type-as-a-single-value-or-as-an-array-of-custom-type-values-ec14e840ce2c?source=collection_archive---------4----------------------->

您是否曾经需要在特定类型的数据库中存储一些信息？当然，我想。我们都使用字符串、整数、小数等，尤其是在使用 PostgreSQL 的情况下也使用数组(pg 数组)。但是如果我们需要一个尚不存在的类型呢？对我们正在构建的应用程序来说更独特的东西。Rails 让我们了解了这一点:

**自定义类型**

那么，让我们来看看自定义类型是如何工作的！

# 预期结果

首先，让我们快速定义我们想要实现的目标。我们的 Rails 示例应用程序将有一个支付模型，它有三个属性:

*   数量
*   货币
*   可能的货币

因此，我们在这里进行了深入的研究，不仅将“普通”属性定义为自定义类型，还使用 PostgreSQL 为 possible _ currencies 定义了这些自定义类型的数组(使用 pg 数组)。现在不要想太多，我们一会儿将逐个介绍。首先，我们需要运行迁移并创建模型。我们还需要调整一些配置。

1.  告诉模型哪些属性是自定义类型的
2.  注册类型，以便它可以在应用程序启动时加载

首先，我们开始将自定义类型添加到非数组属性中，然后我们将修改它，使其只支持一个单独的自定义类型的元素数组。最后我们把两者都带到了一起，那就继续吧！

# Currency:自定义类型的单值属性

## 描述类型的值

为了简单起见，让我们定义一种货币类型，在这种货币类型中，我们不出所料地存储一种单一货币(我知道有货币宝石，这只是为了说明)。但是我们为什么需要它呢？在这种情况下，我们希望在一种货币中实现某些行为。我们希望货币能够以字符串格式、ISO 4217 码、符号(例如€)显示自己，我们还希望能够将货币字符串解析回其货币类，并查看所有可能的货币。为此，我们描述了一个“货币”模块，并将单一货币作为类添加到其中，在这里我们描述了所提到的方法:

单个类，例如' Currency::EUR '是我们希望保存到数据库并希望从数据库中获取的值。因此，有了一个具有此类属性的模型，即“支付”模型，我们可以

payment . last . currency . iso
=>'欧元'

这意味着我们从货币属性中得到的值必须像

Payment.last.currency
= >货币::欧元

因此，当我们从数据库中检索值时，它需要自动保持不变。让我们看看我们如何能做到这一点。

## 创建货币类型

为此，Rails 给了我们一个类‘active record::Type::Value’来继承，它给了我们创建自定义类型所需的 4 个方法。

*   **类型**:定义我们如何在数据库中实际保存它。
*   **cast** :将用户输入转化为对象。一旦我们将货币值(' Currency::EUR ')赋给对象的货币属性，就会调用这个方法。
*   **序列化**:将值翻译成数据库可以理解的东西(在本例中是字符串)。一旦我们将对象保存到数据库中，就会调用这个方法。
*   **反序列化**:当我们从数据库记录中实例化一笔付款时，将数据库可理解的字符串翻译成货币值。

这些方法中的每一个都需要一个参数“值”。因为我们从来没有真正显式地调用过这些方法(Rails 为我们做了这些)，所以我们只需要知道这些参数是什么。这随方法的不同而不同。这个参数或者是我们分配给对象属性的值(强制转换)，或者是对象属性的实际值(序列化)，或者是来自数据库的字符串(反序列化)。

在数据库中，我们希望将货币保存为字符串(如“eur”)，但如果我们读取支付对象的值，我们希望它是一个货币类，如“Currency::EUR”。所以，我们可以这样做:

首先，我们说我们希望它是数据库中的一个字符串，方法是在 type 方法中说“string”。如果您还记得迁移，那实际上就是数据库列的类型！

在给一个支付对象赋值时，我们给货币属性一个字符串(就像它来自一个表单一样),它需要被转换成一个货币类。只有当我们保存对象时，serialize 方法才会将类转换为字符串(我们在类中定义的)并保存它。为了检查这一点，您可以使用类似 Postico 的东西来读取您的数据库。如果我们现在想从数据库中读取付款，将使用' deserialize '方法反序列化该字符串，这样我们就可以再次访问货币类。在 irb 中尝试:

为了检查这是否真的按照我们想要的方式工作，我们还可以添加一些规格:

现在我们已经拥有了单值自定义类型所需的一切，让我们看看如何对数组进行自定义。

# 货币:自定义类型元素的数组

现在，我们希望为我们的支付提供一组货币类。所以这是可行的:

payment . last . possible _ currences
=>[货币::欧元，货币::美元]

这里唯一需要更改的是 currency_type.rb，以便它能够正确地序列化和反序列化值。

*   **cast** :我们为属性提供了一个货币字符串数组`['eur '，' usd']，该属性将被转换为货币类。
*   **serialize** :在保存到数据库时，我们需要将这个 Ruby 数组转换成一个 pg 字符串数组。为此，对数组的每个元素调用“to_s ”,以便它表示货币类的字符串值。
*   **反序列化**:当我们从数据库中检索付款时，我们需要将 pg 数组转换回 Ruby 数组。这将为我们提供一个类似`['eur '，' usd']`的字符串数组，然后我们将它转换为一个货币类`[Currency::EUR，Currency::USD]`数组

也许在这里展示规格更有意义:

下面是类型文件:

在 irb 中查看:

# 把它放在一起

现在，我们已经分别了解了非阵列和阵列实施，让我们从规格开始将它们放在一起:

所以基本上，它应该两者都做，取决于你给它什么，对吗？让我们快速定义这些方法:

*   **cast** :我们以字符串的形式提供类，就像它们来自一个表单一样。因此， **cast** 需要决定是将单个货币字符串转换成货币类，还是将货币字符串数组转换成货币类数组。
*   **序列化**:如果是数组，需要将 Ruby 数组转换成 pg 数组。然而，如果它是一个单一的货币类，它只需要将它转换成一个字符串。
*   **反序列化**:这有点复杂，因为我们需要检查数据库中的值是否是 pg 数组。我们只需通过检查 PostgreSQL 文档中的分隔符来实现这一点。如果是一个，我们把它解码成一个 Ruby 数组，并对字符串进行常量化。如果不是，那就是我们保持不变的单一货币。

所以，就这样了。当然，这不能只用于货币。只要想想飞船的类型，让你的想象力自由流动。希望这篇小文章对你有帮助。随意评论，伸手！

祝一切顺利，

凯文