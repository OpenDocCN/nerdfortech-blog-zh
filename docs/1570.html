<html>
<head>
<title>Graph Traversal in Python: Dijkstra’s Search</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python 中的图遍历:Dijkstra 的搜索</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/graph-traversal-in-python-dijkstras-search-895c1d5aa1b1?source=collection_archive---------7-----------------------#2021-03-26">https://medium.com/nerd-for-tech/graph-traversal-in-python-dijkstras-search-895c1d5aa1b1?source=collection_archive---------7-----------------------#2021-03-26</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="edae" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">之前我们已经学习了最基本的图搜索算法:宽度优先搜索(BFS)和深度优先搜索(T2)。这两种基本算法有一个共同点，即它们的边没有权重。什么是重量？简单地说，它们是“道路长度”或“两个城市之间的距离”。</p><p id="0f5a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">图的权重准确地反映了真实世界的空间域，尽管如果需要，它们可以表示更抽象的情况。但是现在，一个“地图模型”足以让我们理解一个图和图的遍历。一个没有权重和有权重的图可以如下图所示:我们再次使用了之前的例子，以便于比较相似性和差异。线上的数字(或称为边)是任意指定的节点间的“距离”。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es je"><img src="../Images/48c17957259defa11c0351f3ad18c901.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DMYUD22BuwCRKs3EYw_s2A.png"/></div></div></figure><p id="dbf1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">BFS 和 DFS 没有考虑权重，这在现实中是不可能的，因为每条路都有各自的长度。当我们决定选择哪条道路时，我们需要考虑它们的长度。Dijkstra 的搜索是在进行节点遍历时涉及边权重的算法之一。</p><p id="c13b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">形象地说，选择一个起点和终点让算法计算是一个很好的时机。理想情况下，我们可以获得总距离、路径节点或路径数量。但是没有！不会有目的地！Dijkstra 算法盲目地去任何地方，并返回到每个点的所有最短路径。</p><p id="0de0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">什么？！有什么意义？每一分？事实上，你得到了你想要的，在所有的道路中，有一条是你想要的。但是它不会直接指向你想要的点(为了节省一些计算成本)。</p><p id="fbe8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在没关系，让我们先理解它，以后再去理解它。</p><p id="240f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这里使用了相同的图形示例。只是我们需要存储节点之间的距离:数据以“字典的字典”的形式存储，以便我们可以检索节点的节点和节点之间的权重。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div class="er es jq"><img src="../Images/5cdbac77e11f7e919d671c624708759c.png" data-original-src="https://miro.medium.com/v2/resize:fit:656/format:webp/1*a0OL-YpwHMuGAViXr36R0A.png"/></div></figure><pre class="jf jg jh ji fd jr js jt ju aw jv bi"><span id="7e24" class="jw jx hi js b fi jy jz l ka kb">graph={<br/>    'A':{'B':2,'C':3},<br/>    'B':{'D':3,'E':1},<br/>    'C':{'F':2},<br/>    'D':{},<br/>    'E':{'F':1},<br/>    'F':{}<br/>}<br/>graph['A']# return {'B':2,'C':3}, which are the subnode of A<br/>graph['A']['B']# return 2, which is the distance of A and B</span></pre><p id="5800" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在让我们编码算法。简而言之，如下，但是我们将一步一步地解释它是如何发展到这一步的。</p><pre class="jf jg jh ji fd jr js jt ju aw jv bi"><span id="1307" class="jw jx hi js b fi jy jz l ka kb">import heapq<br/>def dijkstra(graph,node):</span><span id="47f2" class="jw jx hi js b fi kc jz l ka kb">    distances={node:float('inf') for node in graph}<br/>    distances[node]=0<br/>    came_from={node:None for node in graph}</span><span id="8e12" class="jw jx hi js b fi kc jz l ka kb">    queue=[(0,node)]<br/>    <br/>    while queue:<br/>        current_distance,current_node=heapq.heappop(queue)<br/>        # relaxation<br/>        for next_node,weight in graph[current_node].items():<br/>            distance_temp=current_distance+weight<br/>            if distance_temp&lt;distances[next_node]:<br/>                distances[next_node]=distance_temp<br/>                came_from[next_node]=current_node<br/>                heapq.heappush(queue,(distance_temp,next_node))<br/>    return distances,came_from</span><span id="42c3" class="jw jx hi js b fi kc jz l ka kb">dijkstra(graph,'A')<br/># return {'A': 0, 'B': 2, 'C': 3, 'D': 5, 'E': 3, 'F': 4},<br/># {'A': None, 'B': 'A', 'C': 'A', 'D': 'B', 'E': 'B', 'F': 'E'}</span><span id="ef9f" class="jw jx hi js b fi kc jz l ka kb"># the result means for example, 'A' to 'A' is 0, 'A' to 'B' is 2<br/># the shortest path: for example, 'A' to 'F', we start from 'F'<br/># and trace back. 'F' comes from 'E', 'E' from 'B', 'B' from 'A'</span></pre><p id="1cf1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">尝试其他类似例子:</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div class="er es kd"><img src="../Images/99c540bc0aad8692814f2bff4cf35f83.png" data-original-src="https://miro.medium.com/v2/resize:fit:1072/format:webp/1*Sy52spr0QCFwazxHnVFGow.png"/></div></figure><pre class="jf jg jh ji fd jr js jt ju aw jv bi"><span id="e61d" class="jw jx hi js b fi jy jz l ka kb">graph={<br/>    'U':{'V':2,'W':5,'X':1},<br/>    'V':{'U':2,'X':2,'W':3},<br/>    'W':{'V':3,'U':5,'X':3,'Y':1,'Z':5},<br/>    'X':{'U':1,'V':2,'W':3,'Y':1},<br/>    'Y':{'X':1,'W':1,'Z':1},<br/>    'Z':{'W':5,'Y':1}<br/>}<br/>dijkstra(graph,'X')</span><span id="0d0b" class="jw jx hi js b fi kc jz l ka kb">#returns:<br/>#{'U': 1, 'V': 2, 'W': 2, 'X': 0, 'Y': 1, 'Z': 2},<br/># {'U': 'X', 'V': 'X', 'W': 'Y', 'X': None, 'Y': 'X', 'Z': 'Y'}</span></pre><p id="f445" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">如果不用看算法讲解，可以把剩下的部分跳出来。</strong></p></div><div class="ab cl ke kf gp kg" role="separator"><span class="kh bw bk ki kj kk"/><span class="kh bw bk ki kj kk"/><span class="kh bw bk ki kj"/></div><div class="hb hc hd he hf"><p id="fc32" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们回忆一下前面的算法，看看是什么构成了算法的核心行:</p><pre class="jf jg jh ji fd jr js jt ju aw jv bi"><span id="1e5d" class="jw jx hi js b fi jy jz l ka kb"># for BFS, the "queue" structure ensured the breadth first scanning<br/>queue.append(node)<br/>s=queue.pop(0)</span><span id="acf8" class="jw jx hi js b fi kc jz l ka kb"># for DFS, the "stack" plays the trick of depth first scanning<br/>queue.append(node)<br/>s=queue.pop()</span></pre><p id="907e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">对于 Dijkstra 的搜索，一个临时容器以类似的方式构建，但是没有弹出左邻右舍的元素。最小值被弹出。我们用 heapq 库实现了最小距离选择。下面几行构建了 Dijkstra 搜索的核心代码，用它搜索算法是假函数，但是我们仍然需要其他的辅助行来使它工作。</p><pre class="jf jg jh ji fd jr js jt ju aw jv bi"><span id="80f3" class="jw jx hi js b fi jy jz l ka kb">import heapq<br/>queue.append(node)<br/>distance,node=heapq.heappop(queue)</span></pre><p id="e7cb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们与 BFS 和 DFS 做同样的事情:</p><pre class="jf jg jh ji fd jr js jt ju aw jv bi"><span id="294f" class="jw jx hi js b fi jy jz l ka kb">import heapq<br/>def dijkstra(graph,node):</span><span id="2d86" class="jw jx hi js b fi kc jz l ka kb">    queue=[(0,node)]<br/>    <br/>    while queue:<br/>        current_distance,current_node=heapq.heappop(queue)<br/>        <br/>        for next_node,weight in graph[current_node].items():<br/>            #do somthing here!<br/>    return #something!</span></pre><p id="7c97" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们关心的是从起始节点到那个节点的距离/路径。所以我们需要两个容器来存储这些信息。我们在循环之前构建容器，并使用 while 循环来填充正确的信息。</p><pre class="jf jg jh ji fd jr js jt ju aw jv bi"><span id="2af2" class="jw jx hi js b fi jy jz l ka kb">import heapq<br/>def dijkstra(graph,node):</span><span id="5835" class="jw jx hi js b fi kc jz l ka kb">    distances={node:float('inf') for node in graph}<br/>    distances[node]=0<br/>    came_from={node:None for node in graph}</span><span id="2d1d" class="jw jx hi js b fi kc jz l ka kb">    queue=[(0,node)]<br/>    <br/>    while queue:<br/>        current_distance,current_node=heapq.heappop(queue)<br/>        # relaxation<br/>        for next_node,weight in graph[current_node].items():<br/>            distance_temp=current_distance+weight<br/>            if distance_temp&lt;distances[next_node]:<br/>                distances[next_node]=distance_temp<br/>                came_from[next_node]=current_node<br/>                heapq.heappush(queue,(distance_temp,next_node))<br/>    return distances,came_from</span><span id="16db" class="jw jx hi js b fi kc jz l ka kb">dijkstra(graph,'A')<br/># return {'A': 0, 'B': 2, 'C': 3, 'D': 5, 'E': 3, 'F': 4},<br/># {'A': None, 'B': 'A', 'C': 'A', 'D': 'B', 'E': 'B', 'F': 'E'}</span><span id="88c5" class="jw jx hi js b fi kc jz l ka kb"># the result means for example, 'A' to 'A' is 0, 'A' to 'B' is 2<br/># the shortest path: for example, 'A' to 'F', we start from 'F'<br/># and trace back. 'F' comes from 'E', 'E' from 'B', 'B' from 'A'</span></pre><p id="f4fc" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">等等，突然冒出一个术语“放松”，那是什么？它仅仅意味着:选择最小的，只记录最小的。但是我们如何存储第一个值呢？有比空白小的值吗？我们不能创造空白的容器，而是一个装满无限大数的容器。通过这样做，我们无论如何都可以存储第一个值并用更小的值(如果有的话)替换它。</p></div><div class="ab cl ke kf gp kg" role="separator"><span class="kh bw bk ki kj kk"/><span class="kh bw bk ki kj kk"/><span class="kh bw bk ki kj"/></div><div class="hb hc hd he hf"><p id="aa05" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">其中一个例子的更多说明:如果你喜欢说明，浏览下图将有助于你的理解。</p><p id="fb3a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">从任何节点开始，从该节点发展并扩展到它的所有子节点。如果累积距离变小，则更新累积距离(这称为松弛)。</p><p id="1c77" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这里的关键点是。heappop()方法相比较，弹出的距离最小。Dijkstra 与 BFS 相似，但唯一的区别是较小的值<strong class="ih hj">插队</strong>！</p><pre class="jf jg jh ji fd jr js jt ju aw jv bi"><span id="609c" class="jw jx hi js b fi jy jz l ka kb">heapq.heappop(queue)</span></pre><figure class="jf jg jh ji fd jj er es paragraph-image"><div class="er es kd"><img src="../Images/99c540bc0aad8692814f2bff4cf35f83.png" data-original-src="https://miro.medium.com/v2/resize:fit:1072/format:webp/1*Sy52spr0QCFwazxHnVFGow.png"/></div></figure><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es kl"><img src="../Images/79c50a3e704e766c0411f0889d86d313.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iS2ilYFsYq-mkM7-7zXhIw.png"/></div></div></figure><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es km"><img src="../Images/af0cfff068b4515297531ddd8e3203d5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Jit--a9pybgADGIMPrrl5A.png"/></div></div></figure><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es kn"><img src="../Images/227f92e76e9ae9c2d260cf325e8b35cd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tCuZ0CTdBiOLwqcm6KqOtw.png"/></div></div></figure><figure class="jf jg jh ji fd jj er es paragraph-image"><div class="er es ko"><img src="../Images/f0909be2d830dc748e1330411be0ec42.png" data-original-src="https://miro.medium.com/v2/resize:fit:722/format:webp/1*FRbUxmanAxKfyOdF1xdF-g.png"/></div></figure></div></div>    
</body>
</html>