<html>
<head>
<title>WebClient Error Handling made Easy</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">WebClient错误处理变得简单</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/webclient-error-handling-made-easy-4062dcf58c49?source=collection_archive---------0-----------------------#2021-10-14">https://medium.com/nerd-for-tech/webclient-error-handling-made-easy-4062dcf58c49?source=collection_archive---------0-----------------------#2021-10-14</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="b7f0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">许多读者可能熟悉WebClient及其各种用法，但是为了便于解释，让我重申一下显而易见的内容；).</p><blockquote class="jd je jf"><p id="de43" class="if ig jg ih b ii ij ik il im in io ip jh ir is it ji iv iw ix jj iz ja jb jc hb bi translated"><strong class="ih hj">什么是WebClient？</strong></p></blockquote><p id="13d0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">它是作为Spring Reactive web模块的一部分引入的，因此在使用反应堆栈的场景中，它为RestTemplate提供了一个替代方案。但是不要搞错了！。对于正常的功能，我们也可以使用相同的方法，您需要等待服务呼叫结束，才能继续执行剩余的功能。这被称为<em class="jg">阻塞操作。<br/> </em>因此WebClient可以支持同步和非同步操作。</p><figure class="jl jm jn jo fd jp er es paragraph-image"><div role="button" tabindex="0" class="jq jr di js bf jt"><div class="er es jk"><img src="../Images/c00532b5545e91df6ca06ada7a4583b4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jckMFPKog1wpwdPFoG-3NQ.png"/></div></div></figure></div><div class="ab cl jw jx gp jy" role="separator"><span class="jz bw bk ka kb kc"/><span class="jz bw bk ka kb kc"/><span class="jz bw bk ka kb"/></div><div class="hb hc hd he hf"><blockquote class="jd je jf"><p id="2a50" class="if ig jg ih b ii ij ik il im in io ip jh ir is it ji iv iw ix jj iz ja jb jc hb bi translated"><strong class="ih hj">如何处理错误？</strong></p></blockquote><p id="4ce7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这里的假设是，读者了解webclient的基础知识以及如何使用它，因此我将直接进入错误处理部分。如果你们需要知道如何开始使用webclient，请告诉我。好的，我们开始吧。使用webclient时，有多种方法可以处理错误。我将解释最简单的方法，让你们去探索其他可能的方法。</p><figure class="jl jm jn jo fd jp er es paragraph-image"><div role="button" tabindex="0" class="jq jr di js bf jt"><div class="er es kd"><img src="../Images/4814aad6b86e8d2bcc3a7d0a78d8c40e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*d8-3VnInWlg76cGtJaZd4Q.jpeg"/></div></div><figcaption class="ke kf et er es kg kh bd b be z dx translated">处理错误，真的</figcaption></figure><p id="aa38" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">但是在我们进入方法之前，<em class="jg">总是记得扩展</em><strong class="ih hj"><em class="jg">runtime exception</em></strong><em class="jg">到你正在定义的异常，具体到WebClient </em>中的用法。这让事情变得简单多了。</p><pre class="jl jm jn jo fd ki kj kk kl aw km bi"><span id="79c8" class="kn ko hi kj b fi kp kq l kr ks">public class UserDefinedException extends RuntimeException {</span><span id="a418" class="kn ko hi kj b fi kt kq l kr ks">//your class definition which includes error attributes... etc</span><span id="3cc5" class="kn ko hi kj b fi kt kq l kr ks">}</span></pre><ul class=""><li id="4414" class="ku kv hi ih b ii ij im in iq kw iu kx iy ky jc kz la lb lc bi translated"><strong class="ih hj"> <em class="jg">初始化网络客户端</em> </strong></li></ul><p id="d67b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们可以定义一个ExchangeFilterFunction，它将根据相关的错误状态代码封装错误。</p><pre class="jl jm jn jo fd ki kj kk kl aw km bi"><span id="7bad" class="kn ko hi kj b fi kp kq l kr ks">public static ExchangeFilterFunction errorHandler() {<br/>    return ExchangeFilterFunction.<em class="jg">ofResponseProcessor</em>(clientResponse -&gt; {<br/>        if (clientResponse.statusCode().is5xxServerError()) {<br/>            return clientResponse.bodyToMono(String.class)<br/>                    .flatMap(errorBody -&gt; Mono.<em class="jg">error</em>(new UserDefinedException1(errorBody)));<br/>        } else if (clientResponse.statusCode().is4xxClientError()) {<br/>            return clientResponse.bodyToMono(String.class)<br/>                    .flatMap(errorBody -&gt; Mono.<em class="jg">error</em>(new UserDefinedException2(errorBody)));<br/>        } else {<br/>            return Mono.<em class="jg">just</em>(clientResponse);<br/>        }<br/>    });<br/>}</span></pre><p id="8c67" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">正如代码块中提到的，每当发生5XX/4XX错误时，我们可以抛出一个用户定义的异常，然后根据这些用户定义的异常执行错误处理逻辑。一旦定义了这个错误处理程序，我们就可以在WebClient初始化中添加它。</p><pre class="jl jm jn jo fd ki kj kk kl aw km bi"><span id="d275" class="kn ko hi kj b fi kp kq l kr ks">WebClient webClient() {<br/>    return WebClient<br/>            .<em class="jg">builder</em>()<br/>            .filter(errorHandler())<br/>            .baseUrl("baseURL")<br/>            .build();<br/>}</span></pre><p id="e297" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">因此，现在无论在哪里使用这个webclient，所有的错误都会自动用定制的异常进行包装，这是我们在前面的步骤中声明的。</p><ul class=""><li id="69a2" class="ku kv hi ih b ii ij im in iq kw iu kx iy ky jc kz la lb lc bi translated"><strong class="ih hj"> <em class="jg">在执行服务时调用</em> </strong></li></ul><p id="d4a2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">前面的方法更像是一种通用的方法，但是，可能会有我们只需要处理特定错误代码的场景。在这种情况下，我们可以在执行webclient时实现错误处理逻辑，如下所述</p><pre class="jl jm jn jo fd ki kj kk kl aw km bi"><span id="d4fc" class="kn ko hi kj b fi kp kq l kr ks">try {<br/>String response = webClient.get()<br/>        .retrieve()<br/>        .onStatus(httpStatus -&gt; httpStatus.value() == &lt;desired Status code&gt;,<br/>                error -&gt; Mono.<em class="jg">error</em>(new UserDefinedException("error Body")))<br/>        .bodyToMono(String.class)<br/>        .block();<br/>} catch(UserDefinedException userDefinedException) {<br/>  //exception handling logic<br/>}</span></pre><p id="0fd1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在上面提到的代码片段中，我们可以替换任何我们想要的状态，并相应地处理错误。好的一面是您可以有多个onStatus()，因此您可以根据您的业务需求处理多个状态代码。</p><ul class=""><li id="949f" class="ku kv hi ih b ii ij im in iq kw iu kx iy ky jc kz la lb lc bi translated">让我们再试一次；) </li></ul><p id="56b8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">到目前为止，涵盖的场景都是基本和直接的场景，但实际上，当出现错误时，通常遵循的流程是</p><ol class=""><li id="4327" class="ku kv hi ih b ii ij im in iq kw iu kx iy ky jc ld la lb lc bi translated">根据错误，进行特定次数的重试</li><li id="a26f" class="ku kv hi ih b ii le im lf iq lg iu lh iy li jc ld la lb lc bi translated">重试次数用尽后，抛出特定错误。</li></ol><pre class="jl jm jn jo fd ki kj kk kl aw km bi"><span id="bacc" class="kn ko hi kj b fi kp kq l kr ks">try {<br/>UserDefinedResponse response = webClient<br/>        .post()<br/>        .body(Mono.<em class="jg">just</em>(userDefinedRequest), Map.class)<br/>        .retrieve()<br/>        .bodyToMono(UserDefinedResponse.class)<br/>        .onErrorResume(Mono::<em class="jg">error</em>)<br/>        .retryWhen(Retry.<em class="jg">backoff</em>(3, Duration.<em class="jg">of</em>(2, ChronoUnit.<em class="jg">SECONDS</em>))<br/>                .onRetryExhaustedThrow((retryBackoffSpec, retrySignal) -&gt;<br/>new UserDefinedException(retrySignal.failure())))<br/>        .block();<br/>} catch(UserDefinedException userDefinedException){<br/>//Error Handling logic<br/>}</span></pre><p id="1585" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">上面提到的代码片段显示了如何使用webclient实现指数重试。<strong class="ih hj"> <em class="jg"> Retry.backoff(3，Duration.of(2，ChronoUnit。秒)，</em>，</strong>这一行封装了重试所需的逻辑。</p><ul class=""><li id="f37a" class="ku kv hi ih b ii ij im in iq kw iu kx iy ky jc kz la lb lc bi translated"><strong class="ih hj"> 3 </strong>表示在执行耗尽逻辑之前要执行的最大重试次数</li><li id="8ba5" class="ku kv hi ih b ii le im lf iq lg iu lh iy li jc kz la lb lc bi translated"><strong class="ih hj"> 2秒</strong>表示第一次回退开始前的最小时间。</li></ul><p id="0c56" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">一旦重试次数用完<strong class="ih hj"> onRetryExhaustedThrow() </strong>就会被执行，这样我们就可以按照我们的业务逻辑来处理错误。</p></div><div class="ab cl jw jx gp jy" role="separator"><span class="jz bw bk ka kb kc"/><span class="jz bw bk ka kb kc"/><span class="jz bw bk ka kb"/></div><div class="hb hc hd he hf"><blockquote class="jd je jf"><p id="618c" class="if ig jg ih b ii ij ik il im in io ip jh ir is it ji iv iw ix jj iz ja jb jc hb bi translated"><strong class="ih hj">结尾</strong></p></blockquote><p id="e009" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这只是各种各样的概述，还有各种其他的可能性可以探索。在从事spring boot API开发时，我在使用WebClient处理错误时遇到了困难，因此我想记录我在错误处理中采用的所有方法。建议和反馈总是受欢迎的，所以请添加您的方法或见解，因为与您已经知道的方法相比，您是如何找到这些方法的。:).编码人快乐！！！。</p></div></div>    
</body>
</html>