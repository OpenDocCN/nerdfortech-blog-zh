<html>
<head>
<title>Boost Your React Applications with React.memo, useCallback, and useMemo</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用React.memo、useCallback和useMemo增强React应用程序</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/boost-your-react-apps-with-react-memo-usecallback-and-usememo-52dfe9575ec6?source=collection_archive---------1-----------------------#2021-05-10">https://medium.com/nerd-for-tech/boost-your-react-apps-with-react-memo-usecallback-and-usememo-52dfe9575ec6?source=collection_archive---------1-----------------------#2021-05-10</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/3af2aba56100afa4a7a8b5f2e34f50fc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YpPd_ht_5M1Q0pVksBsrFw.png"/></div></div></figure><p id="9af6" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们热爱的众多原因之一💙反应过来就是因为真的快。React在幕后做了大量的工作来保证所有的东西都能有效渲染。因此，在大多数情况下，性能不是我们需要担心的事情。然而，我们可能会遇到这样的情况，我们发现我们的组件渲染的比他们需要的要多，因此，我们的应用程序变慢了。🐢🐢</p><p id="ca05" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">嗨！我是Ernesto，在这篇文章中，我将讨论如何使用<code class="du jo jp jq jr b">React.memo</code>、<code class="du jo jp jq jr b">useCallback</code>和<code class="du jo jp jq jr b">useMemo</code>让我们的React应用程序像风一样运行。⚡</p></div><div class="ab cl js jt gp ju" role="separator"><span class="jv bw bk jw jx jy"/><span class="jv bw bk jw jx jy"/><span class="jv bw bk jw jx"/></div><div class="hb hc hd he hf"><h1 id="b343" class="jz ka hi bd kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw bi translated">反应备忘录🧠</h1><p id="41d2" class="pw-post-body-paragraph iq ir hi is b it kx iv iw ix ky iz ja jb kz jd je jf la jh ji jj lb jl jm jn hb bi translated">这是React 16.6.0发布以来最酷的特性之一。顾名思义，<code class="du jo jp jq jr b">React.memo</code>⚛️允许我们通过记忆过程来提升功能组件的性能。它类似于用于类组件的<code class="du jo jp jq jr b">PureComponent</code>。</p><blockquote class="lc ld le"><p id="c044" class="iq ir lf is b it iu iv iw ix iy iz ja lg jc jd je lh jg jh ji li jk jl jm jn hb bi translated"><code class="du jo jp jq jr b">React.memo</code>是<a class="ae lj" href="https://reactjs.org/docs/higher-order-components.html" rel="noopener ugc nofollow" target="_blank">高阶分量</a> (HOC)，是取一个分量，返回一个新分量的函数。</p></blockquote><p id="2393" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><code class="du jo jp jq jr b">React.memo</code>取一个函数组件，返回一个<a class="ae lj" href="https://en.wikipedia.org/wiki/Memoization" rel="noopener ugc nofollow" target="_blank">记忆的</a>(优化)组件。</p><p id="a436" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">迷茫？😐让我们看一个例子。😁——<em class="lf">你可以查看我的代号</em><a class="ae lj" href="https://codepen.io/netoTests/pen/wvWVBxZ" rel="noopener ugc nofollow" target="_blank"><em class="lf"/></a><em class="lf">中的例子。✒ </em></p><pre class="lk ll lm ln fd lo jr lp lq aw lr bi"><span id="80a2" class="ls ka hi jr b fi lt lu l lv lw">//Child Component<br/>const ChildComponent = (props) =&gt; {<br/>  //This message is printed when the component renders<br/>  console.log("ChildComponent rendered")<br/><br/>  return (<br/>    &lt;div className="box"&gt;<br/>      &lt;h1&gt;Child Component&lt;/h1&gt;<br/>      &lt;h2&gt;{props.name}&lt;/h2&gt;<br/>      &lt;p&gt;This component does not change, so it should not render&lt;/p&gt;<br/>    &lt;/div&gt;<br/>  )<br/>}<br/></span><span id="1cfd" class="ls ka hi jr b fi lx lu l lv lw">//Main Component<br/>const MainComponent = () =&gt; {<br/>  const [value, setValue] = React.useState(0)<br/>  handleClick = () =&gt; {<br/>    setValue(value =&gt; value + 1)<br/>  };<br/><br/>  return (<br/>    &lt;div&gt;<br/>      &lt;h1 className="title"&gt;React.memo example&lt;/h1&gt;<br/>      &lt;div className="box"&gt;<br/>        &lt;div&gt;{value}&lt;/div&gt;<br/>        &lt;button onClick={handleClick}&gt;+&lt;/button&gt;<br/>      &lt;/div&gt;<br/>      {/*Child component, its prop does not change*/}<br/>      &lt;ChildComponent name="Ernesto"/&gt;<br/>    &lt;/div&gt;<br/>  )<br/>}</span></pre><p id="0379" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们有一个用<code class="du jo jp jq jr b">name</code>道具渲染<code class="du jo jp jq jr b">ChildComponent</code>的<code class="du jo jp jq jr b">MainComponent</code>。<code class="du jo jp jq jr b">MainComponent</code>有一个状态，如果它改变了，组件会重新渲染。</p><p id="9b1f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">有道理，对吧？🤔如果一个组件改变了，它应该重新渲染，如果没有改变，就不应该。</p><p id="1107" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">然而，当我们点击+按钮并改变<code class="du jo jp jq jr b">MainComponent</code>状态时，<code class="du jo jp jq jr b">ChildComponent</code>也会重新渲染。如果你检查控制台，你会看到<em class="lf">“子组件渲染”</em>消息。</p><figure class="lk ll lm ln fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ly"><img src="../Images/b7ac17d81d7b5f53a109fca6fd10e5bc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*16OGeCsP922fG0k-"/></div></div></figure><p id="2dc2" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这是不必要的重新渲染，因为<code class="du jo jp jq jr b">ChildComponent</code>根本没有改变；唯一改变的是<code class="du jo jp jq jr b">MainComponent</code>。</p><p id="44af" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">怎么才能解决这个问题？🤨嗯，现在是<code class="du jo jp jq jr b">React.memo</code>来救援的时候了。我们唯一要做的就是将我们的<code class="du jo jp jq jr b">ChildComponent</code>包装在<code class="du jo jp jq jr b">React.memo()</code>函数中。</p><pre class="lk ll lm ln fd lo jr lp lq aw lr bi"><span id="b189" class="ls ka hi jr b fi lt lu l lv lw">//Child Component<br/>//We use React.memo<br/>const ChildComponent = React.memo((props) =&gt; {<br/>  //This message is printed when the component renders<br/>  console.log("ChildComponent rendered")<br/><br/>  return (<br/>    &lt;div className="box"&gt;<br/>      &lt;h1&gt;Child Component&lt;/h1&gt;<br/>      &lt;h2&gt;{props.name}&lt;/h2&gt;<br/>      &lt;p&gt;This component does not change, so it should not render&lt;/p&gt;<br/>    &lt;/div&gt;<br/>  )<br/>})</span></pre><p id="0a4b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在，如果你看到控制台，<em class="lf">“child component rendered”</em>消息应该只出现一次，当你点击+按钮并改变状态时，这条消息不会显示，因为<code class="du jo jp jq jr b">ChildComponent</code>没有重新渲染。😎</p><figure class="lk ll lm ln fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lz"><img src="../Images/9488b61dee14d7bf498ac3499b624b1f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*8Y8NzW-KOH-yNoAY"/></div></div></figure><p id="0f62" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><code class="du jo jp jq jr b">React.memo</code>比较传递给组件的道具。如果与上次相同，<code class="du jo jp jq jr b">React.memo</code>将使用之前的渲染结果，并跳过重新渲染过程。</p><blockquote class="lc ld le"><p id="0264" class="iq ir lf is b it iu iv iw ix iy iz ja lg jc jd je lh jg jh ji li jk jl jm jn hb bi translated">记住<code class="du jo jp jq jr b">React.memo</code>只找道具变化。这意味着如果你的函数组件有一个状态(带<code class="du jo jp jq jr b">useState</code>钩子)，当状态改变时，它仍然会重新呈现。</p></blockquote><h1 id="e489" class="jz ka hi bd kb kc ma ke kf kg mb ki kj kk mc km kn ko md kq kr ks me ku kv kw bi translated">使用回调🏹并使用备忘录🔥</h1><p id="165b" class="pw-post-body-paragraph iq ir hi is b it kx iv iw ix ky iz ja jb kz jd je jf la jh ji jj lb jl jm jn hb bi translated">这两个挂钩可能会有点混淆。😵它们都接收一个函数和一个依赖项数组作为参数，并且只有当其中一个依赖项发生变化时，它们才会计算一个新值。</p><pre class="lk ll lm ln fd lo jr lp lq aw lr bi"><span id="0795" class="ls ka hi jr b fi lt lu l lv lw">//useCallback returns a memoized function<br/>const memoizedCallback = useCallback(() =&gt; {<br/>  doSomething();<br/>}, [dependencies]);</span><span id="6851" class="ls ka hi jr b fi lx lu l lv lw">//useMemo returns a memoized value<br/>const memoizedValue = useMemo(() =&gt; {<br/>    return computeExpensiveValue()<br/>}, [dependencies]);</span></pre><p id="228c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">不同的是<code class="du jo jp jq jr b">useMemo</code>会返回一个记忆化的值，函数传递的结果，而<code class="du jo jp jq jr b">useCallback</code>会返回记忆化的函数本身。</p><p id="79e6" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">让我们看看如何以及何时使用它们。😉</p><h2 id="c179" class="ls ka hi bd kb mf mg mh kf mi mj mk kj jb ml mm kn jf mn mo kr jj mp mq kv mr bi translated">使用回调</h2><p id="4a03" class="pw-post-body-paragraph iq ir hi is b it kx iv iw ix ky iz ja jb kz jd je jf la jh ji jj lb jl jm jn hb bi translated">这在向优化的子组件传递回调时特别有用。所以<code class="du jo jp jq jr b">useCallback</code>总是和<code class="du jo jp jq jr b">React.memo</code>一起工作。</p><p id="c233" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们将把前面的例子稍微改变一下。——<em class="lf">你可以在</em> <a class="ae lj" href="https://codepen.io/netoTests/pen/OJXKVdN" rel="noopener ugc nofollow" target="_blank"> <em class="lf">我的笔友</em> </a> <em class="lf">里查例子。✒ </em></p><pre class="lk ll lm ln fd lo jr lp lq aw lr bi"><span id="6f7f" class="ls ka hi jr b fi lt lu l lv lw">//Child Component<br/>const ChildComponent = React.memo((props) =&gt; {<br/>  console.log("ChildComponent rendered")</span><span id="de8a" class="ls ka hi jr b fi lx lu l lv lw">  return (<br/>    &lt;div className="box"&gt;<br/>      &lt;h1&gt;Child Component&lt;/h1&gt;<br/>      &lt;h2&gt;{props.name}&lt;/h2&gt;<br/>      &lt;p&gt;This component does not change, so it should not re-render&lt;/p&gt;<br/>      {/*Button that will change the state of its parent component*/}<br/>      &lt;button onClick={props.handle}&gt;+&lt;/button&gt;<br/>    &lt;/div&gt;<br/>  )<br/>})<br/></span><span id="fdbb" class="ls ka hi jr b fi lx lu l lv lw">//Main Component<br/>const App = () =&gt; {<br/>  const [value, setValue] = React.useState(0)<br/>  handleClick = () =&gt; {<br/>    setValue(value =&gt; value + 1)<br/>  };</span><span id="7962" class="ls ka hi jr b fi lx lu l lv lw">  return (<br/>    &lt;div className="main-comp"&gt;<br/>        &lt;h1 className="title"&gt;Main Component&lt;/h1&gt;<br/>        &lt;div className="box"&gt;<br/>          &lt;div&gt;{value}&lt;/div&gt;<br/>        &lt;/div&gt;<br/>        {/*Pass the handleClick function through props*/}<br/>        &lt;ChildComponent name="Ernesto" handle={handleClick}/&gt;<br/>    &lt;/div&gt;<br/>  )<br/>}</span></pre><p id="3dc2" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在，改变<code class="du jo jp jq jr b">MainComponent</code>状态的按钮在<code class="du jo jp jq jr b">ChildComponent</code>内部；因此，我们必须从<code class="du jo jp jq jr b">MainComponent</code>中传递包含<code class="du jo jp jq jr b">handleClick</code>功能的<code class="du jo jp jq jr b">handle</code>属性。</p><p id="4b89" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如果你去控制台，你会注意到每次我们点击按钮时<em class="lf">“child component rendered”</em>消息再次出现。我们正在使用<code class="du jo jp jq jr b">React.memo</code>，但是组件仍然在重新渲染。发生了什么事？🥴</p><figure class="lk ll lm ln fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ms"><img src="../Images/36d4fa83fc6f7ed38dd5c371bbc33a6c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*UgCsSz45LoN9RA1D"/></div></div></figure><p id="a08e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这是因为每次<code class="du jo jp jq jr b">MainComponent</code>状态改变时，一个新的<code class="du jo jp jq jr b">handleClick</code>函数就会被创建。这意味着每次我们点击+按钮时，<code class="du jo jp jq jr b">ChildComponent</code>的<code class="du jo jp jq jr b">handle</code>道具是不同的。这就是<code class="du jo jp jq jr b">React.memo</code>不起作用的原因；<code class="du jo jp jq jr b">handle</code>道具在变。</p><p id="e13a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们可以通过使用<code class="du jo jp jq jr b">useCallback</code>钩子来记忆<code class="du jo jp jq jr b">handleClick</code>函数来解决这个问题。</p><pre class="lk ll lm ln fd lo jr lp lq aw lr bi"><span id="0e0f" class="ls ka hi jr b fi lt lu l lv lw">//Main Component<br/>const App = () =&gt; {<br/>  const [value, setValue] = React.useState(0)<br/>  //useCallback hook<br/>  const handleClick = useCallback(() =&gt; {<br/>    setValue(value =&gt; value + 1)<br/>  }, []);<br/><br/>  return (<br/>    &lt;div className="main-comp"&gt;<br/>        &lt;h1 className="title"&gt;Main Component&lt;/h1&gt;<br/>        &lt;div className="box"&gt;<br/>          &lt;div&gt;{value}&lt;/div&gt;<br/>        &lt;/div&gt;<br/>        {/*Pass the handleClick memoized function through props*/}<br/>        &lt;ChildComponent name="Ernesto" handle={handleClick}/&gt;<br/>    &lt;/div&gt;<br/>  )<br/>}</span></pre><p id="592c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">请注意，依赖项数组是空的；这意味着该函数将只创建一次。所以<code class="du jo jp jq jr b">MainComponent</code>的<code class="du jo jp jq jr b">handle</code>道具永远不变。😎</p><figure class="lk ll lm ln fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mt"><img src="../Images/a715da5ddfa37af52023755c7baf5dec.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*5SOhHg7wEW8k8HF7"/></div></div></figure><h2 id="bb07" class="ls ka hi bd kb mf mg mh kf mi mj mk kj jb ml mm kn jf mn mo kr jj mp mq kv mr bi translated">使用备忘录</h2><p id="4054" class="pw-post-body-paragraph iq ir hi is b it kx iv iw ix ky iz ja jb kz jd je jf la jh ji jj lb jl jm jn hb bi translated">当我们必须计算一个过大的值时，我们使用<code class="du jo jp jq jr b">useMemo</code>，我们不希望每次组件重新渲染时都要重新计算一次。</p><p id="b0c0" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们来举个例子。——<em class="lf">你可以在</em> <a class="ae lj" href="https://codepen.io/netoTests/pen/QWEezwZ" rel="noopener ugc nofollow" target="_blank"> <em class="lf">我的CodePen </em> </a> <em class="lf">里查例子。✒ </em></p><pre class="lk ll lm ln fd lo jr lp lq aw lr bi"><span id="acdc" class="ls ka hi jr b fi lt lu l lv lw">//Function that computes an exessive value<br/>const heavyProcess = (times) =&gt; {<br/>  for (let i = 0; i &lt; times; i++) {<br/>    console.log('Go ...', i + 1);<br/>  }<br/>  return `Heavy process done (result: ${times})`;<br/>};<br/><br/>//Main Component<br/>const MainComponent = () =&gt; {<br/>  const [value, setValue] = React.useState(0)<br/>  handleClick = () =&gt; {<br/>    setValue(value =&gt; value + 1)<br/>  };<br/>//The returned value is saved<br/>const heavyProcessValue = heavyProcess(1000)<br/><br/>  return (<br/>    &lt;div className="main-comp"&gt;<br/>        &lt;h1 className="title"&gt;Main Component&lt;/h1&gt;<br/>        &lt;div className="box"&gt;<br/>          &lt;div&gt;{value}&lt;/div&gt;<br/>          {/*The returned value is printed*/}<br/>          &lt;p&gt;{heavyProcessValue}&lt;/p&gt;<br/>          &lt;button onClick={handleClick}&gt;+&lt;/button&gt;<br/>        &lt;/div&gt;<br/>    &lt;/div&gt;<br/>  )<br/>}</span></pre><p id="5e38" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们用<code class="du jo jp jq jr b">heavyProcess</code>函数模拟一个繁重的过程，它将从1到1000的数字打印到控制台，并返回最后打印的数字(1000)。我们的<code class="du jo jp jq jr b">MainComponent</code>有一个简单的计数器，它打印<code class="du jo jp jq jr b">heavyProcess</code>函数的返回值。</p><p id="bea7" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如果你去控制台，你会注意到每次我们点击+按钮，从1到1000的所有数字都会被打印出来。因此，每次组件重新呈现时(由于其状态的变化),<code class="du jo jp jq jr b">heavyProcess</code>再次执行。</p><figure class="lk ll lm ln fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mu"><img src="../Images/7d95c5ce1df3089501e192fb91e4a151.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*sr-xypvAm3IeoleH"/></div></div></figure><p id="23c6" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这一次，<code class="du jo jp jq jr b">useMemo</code>会救我们。我们将用它来记忆计算出的值。</p><pre class="lk ll lm ln fd lo jr lp lq aw lr bi"><span id="5c43" class="ls ka hi jr b fi lt lu l lv lw">//Main Component<br/>const MainComponent = () =&gt; {<br/>  const [value, setValue] = React.useState(0)<br/>  handleClick = () =&gt; {<br/>    setValue(value =&gt; value + 1)<br/>  };<br/>  //The returned memoized value is saved with useMemo<br/>  const memoizedHeavyProcessValue = React.useMemo(() =&gt; {<br/>    return heavyProcess(1000)<br/>  }, [])</span><span id="27c0" class="ls ka hi jr b fi lx lu l lv lw">  return (<br/>    &lt;div className="main-comp"&gt;<br/>        &lt;h1 className="title"&gt;Main Component&lt;/h1&gt;<br/>        &lt;div className="box"&gt;<br/>          &lt;div&gt;{value}&lt;/div&gt;<br/>          {/*The memoized value is printed*/}<br/>          &lt;p&gt;{memoizedHeavyProcessValue}&lt;/p&gt;<br/>          &lt;button onClick={handleClick}&gt;+&lt;/button&gt;<br/>        &lt;/div&gt;<br/>    &lt;/div&gt;<br/>  )<br/>}</span></pre><p id="54fb" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在，我们传递的不是<code class="du jo jp jq jr b">heavyProcess</code>函数返回的值，而是<code class="du jo jp jq jr b">useMemo</code>钩子给我们的记忆值；仅当其中一个依赖关系发生变化时，才会再次计算该值。在我们的例子中，数组是空的，这意味着这个值只被计算一次。😎</p><blockquote class="lc ld le"><p id="fc98" class="iq ir lf is b it iu iv iw ix iy iz ja lg jc jd je lh jg jh ji li jk jl jm jn hb bi translated">不要忘记<code class="du jo jp jq jr b">useMemo</code>钩子的第一个参数中的<code class="du jo jp jq jr b">return</code>语句。</p></blockquote><figure class="lk ll lm ln fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mv"><img src="../Images/0f9be8d4c6e4020d0356f40dc5e5972a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*a2JkKU-UzBmGoJ2I"/></div></div></figure><h1 id="2bf1" class="jz ka hi bd kb kc ma ke kf kg mb ki kj kk mc km kn ko md kq kr ks me ku kv kw bi translated">结论</h1><ul class=""><li id="30e0" class="mw mx hi is b it kx ix ky jb my jf mz jj na jn nb nc nd ne bi translated">使用<code class="du jo jp jq jr b">React.memo</code>跳过⏭函数组件中不必要的渲染。如果你想要类似于类组件的东西，使用<code class="du jo jp jq jr b">PureComponent</code>。</li><li id="e7fa" class="mw mx hi is b it nf ix ng jb nh jf ni jj nj jn nb nc nd ne bi translated">当你想通过回调的时候使用<code class="du jo jp jq jr b">useCallback</code>钩子🏹通过道具传递给子组件。</li><li id="ea7c" class="mw mx hi is b it nf ix ng jb nh jf ni jj nj jn nb nc nd ne bi translated">当您想记忆一个过大的值时，使用<code class="du jo jp jq jr b">useMemo</code>挂钩🔥由函数返回，比如获取大量数据的HTTP请求。</li></ul><p id="b4b5" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">请记住，在你开始优化你的应用程序之前，你应该先衡量一下成本。⚖:否则，你将优化那些可能不需要优化的东西。😉</p><p id="7967" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">感谢阅读！📖如果这篇文章对你有帮助，请为它鼓掌。🖐，如果你有任何贡献、意见、疑问或建议，请告诉我。对我提高内容帮助很大。😃</p><p id="3d9e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">下一篇文章再见。👋</p></div><div class="ab cl js jt gp ju" role="separator"><span class="jv bw bk jw jx jy"/><span class="jv bw bk jw jx jy"/><span class="jv bw bk jw jx"/></div><div class="hb hc hd he hf"><h1 id="1a09" class="jz ka hi bd kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw bi translated">资源</h1><ul class=""><li id="72ec" class="mw mx hi is b it kx ix ky jb my jf mz jj na jn nb nc nd ne bi translated">【https://reactjs.org/docs/react-api.html#reactmemo T2】号</li><li id="db00" class="mw mx hi is b it nf ix ng jb nh jf ni jj nj jn nb nc nd ne bi translated">【https://reactjs.org/docs/hooks-reference.html#usecallback T4】</li><li id="f02c" class="mw mx hi is b it nf ix ng jb nh jf ni jj nj jn nb nc nd ne bi translated"><a class="ae lj" href="https://reactjs.org/docs/hooks-reference.html#usememo" rel="noopener ugc nofollow" target="_blank">https://reactjs.org/docs/hooks-reference.html#usememo</a></li></ul></div><div class="ab cl js jt gp ju" role="separator"><span class="jv bw bk jw jx jy"/><span class="jv bw bk jw jx jy"/><span class="jv bw bk jw jx"/></div><div class="hb hc hd he hf"><p id="69f5" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><em class="lf">最初发布于</em><a class="ae lj" href="https://ernestoangulo.hashnode.dev/are-you-still-using-cmd-let-me-introduce-you-to-wsl" rel="noopener ugc nofollow" target="_blank"><em class="lf">https://ernesto angulo . hash node . dev .</em></a></p></div></div>    
</body>
</html>