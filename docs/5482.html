<html>
<head>
<title>Oh No - Another Publishing Android Artifacts to Maven Central Guide?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">哦，不-另一个发布Android工件到Maven中央指南？</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/oh-no-another-publishing-android-artifacts-to-maven-central-guide-9d7f300ebd74?source=collection_archive---------1-----------------------#2021-10-08">https://medium.com/nerd-for-tech/oh-no-another-publishing-android-artifacts-to-maven-central-guide-9d7f300ebd74?source=collection_archive---------1-----------------------#2021-10-08</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/bc5ad3167bfeb6d90200ad39e0d5c70a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kpy6bKisxkpSK1U99GvkaA.png"/></div></div></figure><p id="f972" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">是的，这是另一个关于如何将Android工件发布到Maven Central的指南。与其他指南不同，它涵盖了额外的“东西”:</p><ul class=""><li id="0cc6" class="jo jp hi is b it iu ix iy jb jq jf jr jj js jn jt ju jv jw bi translated">Gradle使用<strong class="is hj"> Kotlin DSL </strong>构建文件。</li><li id="6084" class="jo jp hi is b it jx ix jy jb jz jf ka jj kb jn jt ju jv jw bi translated">发布<strong class="is hj"> AAR文件</strong>工件。</li><li id="86de" class="jo jp hi is b it jx ix jy jb jz jf ka jj kb jn jt ju jv jw bi translated">发布包括一个<strong class="is hj">源Jar </strong>文件(hello <code class="du kc kd ke kf b">withSourcesJar</code>)。</li><li id="19bf" class="jo jp hi is b it jx ix jy jb jz jf ka jj kb jn jt ju jv jw bi translated">该出版物包括一个<strong class="is hj"> Javadoc Jar </strong>文件(hello <code class="du kc kd ke kf b">withJavadocJar</code>)。</li><li id="7df4" class="jo jp hi is b it jx ix jy jb jz jf ka jj kb jn jt ju jv jw bi translated">该出版物通过<strong class="is hj"> CI/CD </strong>渠道发布。</li><li id="ae88" class="jo jp hi is b it jx ix jy jb jz jf ka jj kb jn jt ju jv jw bi translated">我有没有提到这是<strong class="is hj"> Android only </strong>？</li></ul><p id="dafb" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">对于那些不喜欢阅读的人，这里有我的两个使用解释发布机制的回复:</p><ul class=""><li id="9fce" class="jo jp hi is b it iu ix iy jb jq jf jr jj js jn jt ju jv jw bi translated"><a class="ae kg" href="https://github.com/1gravity/Android-RTEditor" rel="noopener ugc nofollow" target="_blank">https://github.com/1gravity/Android-RTEditor</a></li><li id="b2f9" class="jo jp hi is b it jx ix jy jb jz jf ka jj kb jn jt ju jv jw bi translated"><a class="ae kg" href="https://github.com/1gravity/Android-ColorPicker" rel="noopener ugc nofollow" target="_blank">https://github.com/1gravity/Android-ColorPicker</a></li></ul><h1 id="716c" class="kh ki hi bd kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le bi translated">Sonatype OSSRH</h1><p id="d3f4" class="pw-post-body-paragraph iq ir hi is b it lf iv iw ix lg iz ja jb lh jd je jf li jh ji jj lj jl jm jn hb bi translated">Maven Central实际上只是多个存储库的一个门面。一个这样的储存库是<a class="ae kg" href="https://central.sonatype.org/publish/publish-guide/" rel="noopener ugc nofollow" target="_blank"> Sonatype OSSRH </a>。为了发布您的工件，您需要一个他们的帐户(或者另一个库提供者)。有一堆关于如何开户和正确配置的好文章。我将在这里引用这些并完成它(这是一个繁琐的过程，所以请确保您有时间…):</p><ul class=""><li id="f587" class="jo jp hi is b it iu ix iy jb jq jf jr jj js jn jt ju jv jw bi translated"><a class="ae kg" href="https://central.sonatype.org/publish/publish-guide/" rel="noopener ugc nofollow" target="_blank">https://central.sonatype.org/publish/publish-guide</a></li><li id="e5a9" class="jo jp hi is b it jx ix jy jb jz jf ka jj kb jn jt ju jv jw bi translated"><a class="ae kg" href="https://mrcurious.medium.com/publishing-your-android-kotlin-library-to-maven-central-in-2021-df263a4f2cbc" rel="noopener">https://Mr好奇. medium . com/publishing-your-Android-kot Lin-library-to-maven-central-in-2021-df 263 a4 F2 CBC</a></li><li id="eef0" class="jo jp hi is b it jx ix jy jb jz jf ka jj kb jn jt ju jv jw bi translated"><a class="ae kg" href="https://getstream.io/blog/publishing-libraries-to-mavencentral-2021/" rel="noopener ugc nofollow" target="_blank">https://getstream . io/blog/publishing-libraries-to-maven central-2021</a></li><li id="8653" class="jo jp hi is b it jx ix jy jb jz jf ka jj kb jn jt ju jv jw bi translated"><a class="ae kg" href="https://dev.to/madhead/no-bullshit-guide-on-publishing-your-gradle-projects-to-maven-central-3ok4" rel="noopener ugc nofollow" target="_blank">https://dev . to/mad head/no-bullsh-guide-on-publishing-your-grad le-projects-to-maven-central-3ok 4</a></li><li id="8b77" class="jo jp hi is b it jx ix jy jb jz jf ka jj kb jn jt ju jv jw bi translated"><a class="ae kg" href="https://www.waseefakhtar.com/android/publishing-your-first-android-library-to-mavencentral/" rel="noopener ugc nofollow" target="_blank">https://www . waseefakhtar . com/Android/publishing-your-first-Android-library-to-maven central</a></li></ul><h1 id="20b1" class="kh ki hi bd kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le bi translated">插件</h1><p id="fa75" class="pw-post-body-paragraph iq ir hi is b it lf iv iw ix lg iz ja jb lh jd je jf li jh ji jj lj jl jm jn hb bi translated">此时的假设是:</p><ul class=""><li id="2fc5" class="jo jp hi is b it iu ix iy jb jq jf jr jj js jn jt ju jv jw bi translated">您拥有Sonatype OSSRH的<strong class="is hj">账户</strong>。</li><li id="da4e" class="jo jp hi is b it jx ix jy jb jz jf ka jj kb jn jt ju jv jw bi translated">您使用Sonatype OSSRH创建了一个存储库，并验证了您的域名的<strong class="is hj">所有权。</strong></li><li id="2139" class="jo jp hi is b it jx ix jy jb jz jf ka jj kb jn jt ju jv jw bi translated">您为签名工件创建了一个<strong class="is hj"> GPG密钥对</strong>，发布了您的公钥并导出了您的私钥。</li><li id="769c" class="jo jp hi is b it jx ix jy jb jz jf ka jj kb jn jt ju jv jw bi translated">你已经有一个用Kotlin DSL构建文件的app了(对比Groovy构建文件)-&gt; <strong class="is hj"> build.gradle.kts </strong>。</li></ul><p id="65b9" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在，第一步是向您的构建文件添加两个插件:</p><pre class="lk ll lm ln fd lo kf lp lq aw lr bi"><span id="6696" class="ls ki hi kf b fi lt lu l lv lw">plugins <strong class="kf hj">{<br/>    </strong>id("com.android.library")<br/><strong class="kf hj">    id("maven-publish")<br/>    id("signing")<br/>}</strong></span></pre><ul class=""><li id="25a3" class="jo jp hi is b it iu ix iy jb jq jf jr jj js jn jt ju jv jw bi translated"><a class="ae kg" href="https://docs.gradle.org/current/userguide/publishing_maven.html" rel="noopener ugc nofollow" target="_blank"><strong class="is hj">Maven-publish</strong></a><strong class="is hj">:</strong>提供了将构建工件发布到<a class="ae kg" href="http://maven.apache.org/" rel="noopener ugc nofollow" target="_blank"> Apache Maven </a>存储库中的能力</li><li id="3214" class="jo jp hi is b it jx ix jy jb jz jf ka jj kb jn jt ju jv jw bi translated"><a class="ae kg" href="https://docs.gradle.org/current/userguide/publishing_signing.html" rel="noopener ugc nofollow" target="_blank"> <strong class="is hj">签名</strong> </a> <strong class="is hj"> : </strong>用于对组成出版物的所有工件和元数据文件进行签名</li></ul><h1 id="8bba" class="kh ki hi bd kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le bi translated">出版</h1><p id="3c3a" class="pw-post-body-paragraph iq ir hi is b it lf iv iw ix lg iz ja jb lh jd je jf li jh ji jj lj jl jm jn hb bi translated">第二步是创建并配置<em class="lx">发布</em>扩展，将它添加到您的gradle构建文件中:</p><pre class="lk ll lm ln fd lo kf lp lq aw lr bi"><span id="12dc" class="ls ki hi kf b fi lt lu l lv lw">afterEvaluate <strong class="kf hj">{<br/>    </strong><em class="lx">publishing </em><strong class="kf hj">{<br/>        </strong>publications {<br/>            <strong class="kf hj">// here goes your configuration</strong><br/>        }<br/>    }<br/>}</span></pre><p id="5e7f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><code class="du kc kd ke kf b">afterEvaluate</code>确保项目已经被评估并且可以在配置块中被访问。</p><p id="1a3a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">配置包括三个步骤:</p><ol class=""><li id="103c" class="jo jp hi is b it iu ix iy jb jq jf jr jj js jn ly ju jv jw bi translated">配置存储库</li><li id="4e49" class="jo jp hi is b it jx ix jy jb jz jf ka jj kb jn ly ju jv jw bi translated">配置发布</li><li id="8c2f" class="jo jp hi is b it jx ix jy jb jz jf ka jj kb jn ly ju jv jw bi translated">在艺术品上签名</li></ol><pre class="lk ll lm ln fd lo kf lp lq aw lr bi"><span id="a663" class="ls ki hi kf b fi lt lu l lv lw">afterEvaluate <strong class="kf hj">{<br/>    </strong><em class="lx">publishing </em><strong class="kf hj">{<br/>        </strong>publications <strong class="kf hj">{<br/>            <em class="lx">// 1. configure repositories<br/>            // 2. configure publication<br/>            // 3. sign the artifacts<br/></em></strong>        }<br/>    }<br/>}</span></pre><h2 id="61df" class="ls ki hi bd kj lz ma mb kn mc md me kr jb mf mg kv jf mh mi kz jj mj mk ld ml bi translated">仓库</h2><p id="949b" class="pw-post-body-paragraph iq ir hi is b it lf iv iw ix lg iz ja jb lh jd je jf li jh ji jj lj jl jm jn hb bi translated">这部分配置定义了目标存储库。在我们的例子中，它是Sonatype OSSRH，或者是发布或者是快照存储库。</p><figure class="lk ll lm ln fd ij"><div class="bz dy l di"><div class="mm mn l"/></div></figure><p id="ee7f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">目标储存库的确定基于版本名称。带有“-SNAPSHOT”后缀的版本将被上载到快照存储库中。</p><h2 id="f769" class="ls ki hi bd kj lz ma mb kn mc md me kr jb mf mg kv jf mh mi kz jj mj mk ld ml bi translated">出版</h2><p id="c263" class="pw-post-body-paragraph iq ir hi is b it lf iv iw ix lg iz ja jb lh jd je jf li jh ji jj lj jl jm jn hb bi translated">配置发布非常简单。</p><p id="31a1" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">首先，我们定义要发布的工件:</p><pre class="lk ll lm ln fd lo kf lp lq aw lr bi"><span id="ec75" class="ls ki hi kf b fi lt lu l lv lw">from(<em class="lx">project</em>.<em class="lx">components</em>["release"])<br/>artifact(<em class="lx">tasks</em>.<em class="lx">named</em>&lt;Jar&gt;("withJavadocJar"))<br/>artifact(<em class="lx">tasks</em>.<em class="lx">named</em>&lt;Jar&gt;("withSourcesJar"))</span></pre><p id="3082" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><code class="du kc kd ke kf b">project.components["release"]</code>是Android项目产生的工件，如果是Android库，应该是一个<em class="lx"> aar </em>文件。另外两行将Javadoc和源jar文件声明为要发布的工件。在本文的后面，我将解释这两个工件是如何产生的。</p><p id="31b0" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">配置的其余部分定义了Maven POM文件，这是一个Maven项目(项目元信息)的XML表示。</p><p id="3b5b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">需要配置的最重要的属性是<em class="lx"> groupId </em>、<em class="lx"> artifactId </em>和<em class="lx">版本</em>(例如对于<code class="du kc kd ke kf b">com.android.tools.build:gradle:7.0.2</code>，<em class="lx"> groupId </em>是<em class="lx">com . Android . tools . build</em>、<em class="lx"> artifactId </em>是<em class="lx">grade</em>、<em class="lx">版本</em>显然是<em class="lx"> 7.0.2 所有其他属性都是可选参数，用于定义软件许可证、标识公司/开发者、源代码等。</em></p><figure class="lk ll lm ln fd ij"><div class="bz dy l di"><div class="mm mn l"/></div></figure><p id="7a34" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如你所见，所有属性都是从<code class="du kc kd ke kf b">project.properties</code>中读取的，这些属性是在一个<code class="du kc kd ke kf b">gradle.properties</code>文件中定义的(项目或库特定属性文件)。下面是这样一个属性文件的例子:<a class="ae kg" href="https://github.com/1gravity/Android-RTEditor/blob/master/RTEditor/gradle.properties" rel="noopener ugc nofollow" target="_blank">https://github . com/1 gravity/Android-rt editor/blob/master/rt editor/grad le . properties</a>。</p><p id="9416" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">注意，存储库的用户名和密码没有在项目属性文件中定义，而是应该在您的<code class="du kc kd ke kf b">~/.gradle/gradle.properties</code>文件中定义(~代表您的主目录)，这样凭证就不会提交给源代码控制。如果没有该文件，您需要创建它并添加凭据:</p><pre class="lk ll lm ln fd lo kf lp lq aw lr bi"><span id="ef43" class="ls ki hi kf b fi lt lu l lv lw">ossUsername=&lt;your OSS user&gt;<br/>ossPassword=&lt;your OSS password&gt;</span></pre><h2 id="856b" class="ls ki hi bd kj lz ma mb kn mc md me kr jb mf mg kv jf mh mi kz jj mj mk ld ml bi translated">签署</h2><p id="bc02" class="pw-post-body-paragraph iq ir hi is b it lf iv iw ix lg iz ja jb lh jd je jf li jh ji jj lj jl jm jn hb bi translated">对工件进行签名很简单:</p><pre class="lk ll lm ln fd lo kf lp lq aw lr bi"><span id="f0f5" class="ls ki hi kf b fi lt lu l lv lw"><em class="lx">signing </em><strong class="kf hj">{<br/>    </strong>sign(<em class="lx">publishing</em>.<em class="lx">publications</em>.getByName(publicationName))<br/><strong class="kf hj">}</strong></span></pre><p id="1df8" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">签名插件使用您之前创建的密钥(参见“您为签名工件创建了一个<strong class="is hj"> GPG密钥对</strong>，发布了您的公钥并导出了您的私钥”)。插件需要您在<code class="du kc kd ke kf b">~/.gradle/gradle.properties</code>文件中定义的<em class="lx">私钥</em>文件、<em class="lx"> keyId </em>和<em class="lx">密码</em>。将此添加到文件中:</p><pre class="lk ll lm ln fd lo kf lp lq aw lr bi"><span id="bff0" class="ls ki hi kf b fi lt lu l lv lw">signing.secretKeyRingFile=/&lt;user&gt;/.gnupg/secring.gp<br/>g<br/>signing.keyId=&lt;last 8 characters of your key id&gt;<br/>signing.password=&lt;the password&gt;</span></pre><p id="a34a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">注意<code class="du kc kd ke kf b">~/.gnupg/secring.gpg</code>不能工作，因为Android不能解析到你的主目录。</p><p id="8918" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">就是这样。如果您从项目目录运行<code class="du kc kd ke kf b">./gradlew publish</code>，它将构建您的库并将其发布到Sonatype OSSRH。您仍然需要手动关闭和发布库，虽然这也可以自动化，但您应该熟悉手动过程:<a class="ae kg" href="https://central.sonatype.org/publish/release/" rel="noopener ugc nofollow" target="_blank">https://central.sonatype.org/publish/release/</a>。</p><h2 id="a7f6" class="ls ki hi bd kj lz ma mb kn mc md me kr jb mf mg kv jf mh mi kz jj mj mk ld ml bi translated">使用CI/CD签名</h2><p id="aa5e" class="pw-post-body-paragraph iq ir hi is b it lf iv iw ix lg iz ja jb lh jd je jf li jh ji jj lj jl jm jn hb bi translated">大多数构建管道将秘密作为字符串读取，而不是从文件中读取(就像我们上面使用的<code class="du kc kd ke kf b">secretKeyRingFile</code>)。虽然有很多方法可以将文件送入管道(关于位桶管道的描述可以在<a class="ae kg" rel="noopener" href="/nerd-for-tech/ci-cd-for-android-using-bitbucket-pipelines-and-gradle-play-publisher-f00d6047ecb5">这里</a>找到)，但这是一个相当麻烦的过程。最好完全避免文件。</p><p id="400e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在我们的例子中，我们可以通过在创建签名任务之前调用<code class="du kc kd ke kf b">useInMemoryPgpKeys</code>来使用内存中的PGP密钥和密码:</p><figure class="lk ll lm ln fd ij"><div class="bz dy l di"><div class="mm mn l"/></div></figure><p id="4892" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如果在本地编译，这三个参数将从属性文件中读取，所以将这些值放在您的<em class="lx"> ~/中。gradle/gradle.properties </em>文件:</p><pre class="lk ll lm ln fd lo kf lp lq aw lr bi"><span id="7d9b" class="ls ki hi kf b fi lt lu l lv lw">signingKeyId=&lt;last 8 characters of your key id&gt;<br/>signingKeyPassword=&lt;the password&gt;<br/>signingKey=&lt;the key&gt;</span></pre><p id="581e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">密钥需要被“保护”,这意味着转换为完全由纯文本模式/ ASCII字符组成的文件的加密表示。它还需要去掉典型的包装器<em class="lx"> gpg </em>来包装实际的密钥(“--”BEGIN PGP私有密钥块— -”部分)。</p><p id="6e71" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">使用这个一行程序获得关键值:</p><pre class="lk ll lm ln fd lo kf lp lq aw lr bi"><span id="b376" class="ls ki hi kf b fi lt lu l lv lw">gpg --export-secret-keys --armor &lt;KEY_ID&gt; |grep -v '\-\-' |grep -v '=.' |tr -d '\n'</span></pre><p id="991a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">要在构建管道中运行它，您需要在相应的秘密管理器中配置秘密。对于GitHub，这看起来像这样:</p><figure class="lk ll lm ln fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mo"><img src="../Images/bf4e9024a7daa2856c559db4a8145c48.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*u9iaz8H8qOzxupYezj6u2g.png"/></div></div></figure><p id="3b03" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">定义管道时，您需要将机密作为参数传递给gradle/gradlew。</p><p id="576f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">对于<a class="ae kg" href="https://github.com/features/actions" rel="noopener ugc nofollow" target="_blank"> GitHub动作</a>，语法是:</p><pre class="lk ll lm ln fd lo kf lp lq aw lr bi"><span id="dabc" class="ls ki hi kf b fi lt lu l lv lw">./gradlew -PossUsername=${{ secrets.OSSRH_USERNAME }}</span></pre><p id="ef61" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">对于<a class="ae kg" href="https://support.atlassian.com/bitbucket-cloud/docs/get-started-with-bitbucket-pipelines/" rel="noopener ugc nofollow" target="_blank">位桶流水线</a>，语法是:</p><pre class="lk ll lm ln fd lo kf lp lq aw lr bi"><span id="f147" class="ls ki hi kf b fi lt lu l lv lw">./gradlew -PossUsername=$OSSRH_USERNAME</span></pre><h1 id="72db" class="kh ki hi bd kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le bi translated">withSourcesJar</h1><p id="fbd9" class="pw-post-body-paragraph iq ir hi is b it lf iv iw ix lg iz ja jb lh jd je jf li jh ji jj lj jl jm jn hb bi translated">在Java项目中，有一种为源代码和Javadoc创建Jar文件的简单方法:</p><pre class="lk ll lm ln fd lo kf lp lq aw lr bi"><span id="b832" class="ls ki hi kf b fi lt lu l lv lw"><em class="lx">java </em><strong class="kf hj">{<br/>    </strong>withSourcesJar()<br/>    withJavadocJar()<br/><strong class="kf hj">}</strong></span></pre><p id="f5a4" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">不幸的是，这在Android项目中不起作用。不过，使用withSourcesJar进行复制相当简单:</p><pre class="lk ll lm ln fd lo kf lp lq aw lr bi"><span id="a71e" class="ls ki hi kf b fi lt lu l lv lw"><em class="lx">tasks </em><strong class="kf hj">{<br/>   </strong><em class="lx">register</em>&lt;Jar&gt;("withSourcesJar") <strong class="kf hj">{<br/>        </strong><em class="lx">archiveClassifier</em>.set("sources")<br/>        from(<em class="lx">android</em>.sourceSets.getByName("main").java.srcDirs)<br/>    <strong class="kf hj">}<br/>}</strong></span></pre><p id="2107" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这将注册一个名为<code class="du kc kd ke kf b">withSourcesJar</code>的任务。它创建一个jar文件(因此有了<code class="du kc kd ke kf b">Jar</code>类型定义，并使用Android源目录(<code class="du kc kd ke kf b"><em class="lx">android</em>.sourceSets.getByName(“main”).java.srcDirs</code>)作为Jar文件的输入。</p><h1 id="db26" class="kh ki hi bd kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le bi translated">withJavadocJar</h1><p id="1878" class="pw-post-body-paragraph iq ir hi is b it lf iv iw ix lg iz ja jb lh jd je jf li jh ji jj lj jl jm jn hb bi translated">为Javadoc创建jar文件同样简单:</p><pre class="lk ll lm ln fd lo kf lp lq aw lr bi"><span id="0eac" class="ls ki hi kf b fi lt lu l lv lw"><em class="lx">tasks </em>{<br/>   <em class="lx">archiveClassifier</em>.set("javadoc")<br/>   dependsOn(named("withJavadoc"))<br/>   val destination = <em class="lx">named</em>&lt;Javadoc&gt;("withJavadoc")<br/>                        .get()<br/>                        .<em class="lx">destinationDir<br/>   </em>from(destination)<br/>}</span></pre><p id="da16" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">唯一的问题是，在创建Jar文件之前，我们需要先创建Javadoc。正如您在上面看到的，我们引用了一个名为<code class="du kc kd ke kf b">withJavadoc</code>的任务来创建实际的文档:</p><figure class="lk ll lm ln fd ij"><div class="bz dy l di"><div class="mm mn l"/></div></figure><h1 id="ae00" class="kh ki hi bd kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le bi translated">摘要</h1><p id="8e87" class="pw-post-body-paragraph iq ir hi is b it lf iv iw ix lg iz ja jb lh jd je jf li jh ji jj lj jl jm jn hb bi translated">这是所有放在一起的代码:</p><figure class="lk ll lm ln fd ij"><div class="bz dy l di"><div class="mm mn l"/></div></figure><p id="e56c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">此处使用了该代码:</p><div class="mp mq ez fb mr ms"><a href="https://github.com/1gravity/Android-RTEditor/blob/master/RTEditor/build.gradle.kts" rel="noopener  ugc nofollow" target="_blank"><div class="mt ab dw"><div class="mu ab mv cl cj mw"><h2 class="bd hj fi z dy mx ea eb my ed ef hh bi translated">Android-rt editor/build . grad le . kts at master 1 gravity/Android-rt editor</h2><div class="mz l"><h3 class="bd b fi z dy mx ea eb my ed ef dx translated">Android RTEditor是一个面向Android的富文本编辑器组件，可以用作EditText的插件…</h3></div><div class="na l"><p class="bd b fp z dy mx ea eb my ed ef dx translated">github.com</p></div></div><div class="nb l"><div class="nc l nd ne nf nb ng io ms"/></div></div></a></div><p id="fd8e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">还有这里:</p><div class="mp mq ez fb mr ms"><a href="https://github.com/1gravity/Android-ColorPicker/blob/master/library/build.gradle.kts" rel="noopener  ugc nofollow" target="_blank"><div class="mt ab dw"><div class="mu ab mv cl cj mw"><h2 class="bd hj fi z dy mx ea eb my ed ef hh bi translated">Android-color picker/build . gradle . kts at master 1 gravity/Android-color picker</h2><div class="mz l"><h3 class="bd b fi z dy mx ea eb my ed ef dx translated">Android颜色选择器是一个设计精美的颜色选择器，显示在一个对话框中…</h3></div><div class="na l"><p class="bd b fp z dy mx ea eb my ed ef dx translated">github.com</p></div></div><div class="nb l"><div class="nh l nd ne nf nb ng io ms"/></div></div></a></div><p id="931b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">像往常一样，如果你有建议或问题，请不要犹豫，发表意见。</p><p id="a3d7" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">编码快乐！</p><h1 id="5e75" class="kh ki hi bd kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le bi translated">附录</h1><p id="91d6" class="pw-post-body-paragraph iq ir hi is b it lf iv iw ix lg iz ja jb lh jd je jf li jh ji jj lj jl jm jn hb bi translated">如果你认为在Maven Central上发布很麻烦，你并不孤单。在我看来，有一个更好/更容易的选择:<a class="ae kg" rel="noopener" href="/nerd-for-tech/the-better-maven-central-90d7e529d606">更好的Maven Central </a>。</p></div></div>    
</body>
</html>