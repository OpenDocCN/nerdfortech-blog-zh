# 分布式系统中的裂脑

> 原文：<https://medium.com/nerd-for-tech/split-brain-in-distributed-systems-252b0d4d122e?source=collection_archive---------0----------------------->

在具有中央(或领导)服务器的分布式环境中，如果中央服务器死亡，系统必须迅速找到替代品，否则，系统会迅速恶化。分布式系统中有两个或更多活跃领导者的场景被称为裂脑。在这篇文章中，让我们来了解一下大脑分裂的含义以及我们如何处理它。

![](img/fc2eb12df2693c1c94e49d01a3fce7b2.png)

照片由[杰克森煨](https://unsplash.com/@simmerdownjpg?utm_source=medium&utm_medium=referral)在 [Unsplash](https://unsplash.com?utm_source=medium&utm_medium=referral)

裂脑是服务器群集的一种状态，在这种状态下，节点彼此分离，并且在处理传入的 I/O 操作时发生冲突。服务器可能会不一致地记录相同的数据或争夺资源。这通常会在节点等待如何解决冲突的指示时关闭集群，这会导致服务器停机，甚至更糟的是数据损坏。

## 问题

其中一个问题是，我们无法真正知道领导者是已经永远停止了，还是已经经历了间歇性的故障，如 stop-the-world GC 暂停或暂时的网络中断。然而，集群必须继续前进，选择新的领导者。如果最初的领导者有间歇性的失败，我们现在发现自己有一个所谓的**僵尸领导者**。僵尸领导者可以被定义为被系统认为已经死亡并且已经重新联机的领导者节点。另一个节点已经取代了它的位置，但是僵尸首领可能还不知道。该系统现在有两个活跃的领导者，他们可能会发出相互冲突的命令。系统如何检测这样的场景，使得系统中的所有节点可以忽略来自旧引导者的请求，并且旧引导者本身可以检测到它不再是引导者？

## 解决办法

每次选出新的领导人，世代号就会增加。这意味着如果老领导的代号是“1”，那么新领导的代号将是“2”。这个代号包含在从领导者发送到其他节点的每个请求中。这样，节点现在可以通过简单地信任具有最高数字的领导者来容易地区分真正的领导者。世代号应该保存在磁盘上，以便在服务器重新启动后仍然可用。一种方法是将它与每个条目一起存储在预写日志中。

## 例子

**Kafka** :为了处理 Split-brain(我们可以有多个活动的控制器代理)，Kafka 使用了“**纪元编号**”，这是一个简单的单调递增的数字，用来表示服务器的代。

HDFS:ZooKeeper 用于确保任何时候只有一个 NameNode 是活动的。纪元编号作为每个事务 ID 的一部分进行维护，以反映 NameNode 的生成。

希望这篇文章有助于理解分布式系统中的裂脑问题以及如何减轻它们，下次再见！