<html>
<head>
<title>KMM UI Architecture - Part 2</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">KMM 用户界面架构-第二部分</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/kmm-ui-architecture-part-2-e52b84aeb94d?source=collection_archive---------4-----------------------#2022-06-15">https://medium.com/nerd-for-tech/kmm-ui-architecture-part-2-e52b84aeb94d?source=collection_archive---------4-----------------------#2022-06-15</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex if ig ih ii er es paragraph-image"><div class="ab fe cl ij"><img src="../Images/5e2a07f0b557b4d3a92cd13978fab8fe.png" data-original-src="https://miro.medium.com/v2/format:webp/1*HvKqTjPsKIe8kW1JrAWgPA.png"/></div></figure><h1 id="fede" class="im in hi bd io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj bi translated">介绍</h1><p id="7641" class="pw-post-body-paragraph jk jl hi jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh hb bi translated">这是两篇系列文章的第 2 部分:</p><ul class=""><li id="5d9a" class="ki kj hi jm b jn kk jr kl jv km jz kn kd ko kh kp kq kr ks bi translated">第 1 部分:常见用户界面模式的总结以及我们从中学到的东西</li><li id="3ea1" class="ki kj hi jm b jn ku jr kv jv kw jz kx kd ky kh kp kq kr ks bi translated"><a class="ae kt" rel="noopener" href="/p/e52b84aeb94d"> <strong class="jm hj">第二部分</strong> </a> <strong class="jm hj">:为 Kotlin 多平台创建一个简单的、适应性强的、可预测的和可组合的 UI 框架</strong></li></ul><p id="f3da" class="pw-post-body-paragraph jk jl hi jm b jn kk jp jq jr kl jt ju jv kz jx jy jz la kb kc kd lb kf kg kh hb bi translated">第 1 部分中讨论的模式/框架是为 Kotlin 多平台定义 UI 框架的灵感来源。我们从他们那里得到的基本想法是:</p><ul class=""><li id="af6f" class="ki kj hi jm b jn kk jr kl jv km jz kn kd ko kh kp kq kr ks bi translated">模型和视图之间的数据流是不可变的</li><li id="3bbe" class="ki kj hi jm b jn ku jr kv jv kw jz kx kd ky kh kp kq kr ks bi translated">数据单向地从视图流向模型，然后返回</li><li id="5b4e" class="ki kj hi jm b jn ku jr kv jv kw jz kx kd ky kh kp kq kr ks bi translated">数据流是被动的</li><li id="7b87" class="ki kj hi jm b jn ku jr kv jv kw jz kx kd ky kh kp kq kr ks bi translated">每一个关注点都被映射到一个组件或一个功能上，以便进行清晰的分离</li><li id="29c4" class="ki kj hi jm b jn ku jr kv jv kw jz kx kd ky kh kp kq kr ks bi translated">功能是一等公民</li></ul><p id="eb46" class="pw-post-body-paragraph jk jl hi jm b jn kk jp jq jr kl jt ju jv kz jx jy jz la kb kc kd lb kf kg kh hb bi translated">仍然不清楚的是:</p><ol class=""><li id="9720" class="ki kj hi jm b jn kk jr kl jv km jz kn kd ko kh lc kq kr ks bi translated">如何分解/组合用户界面和业务逻辑</li><li id="e1f2" class="ki kj hi jm b jn ku jr kv jv kw jz kx kd ky kh lc kq kr ks bi translated">状态应该如何存储，是存储在单一的集中存储中，还是存储在分散的、特定于业务逻辑组件的状态中</li></ol><p id="8872" class="pw-post-body-paragraph jk jl hi jm b jn kk jp jq jr kl jt ju jv kz jx jy jz la kb kc kd lb kf kg kh hb bi translated">在<a class="ae kt" href="https://dev.to/feresr/a-case-against-the-mvi-architecture-pattern-1add" rel="noopener ugc nofollow" target="_blank">https://dev . to/feresr/a-case-against-the-mvi-architecture-pattern-1 add</a>中，针对第 1 点提出了一些很好的问题，显然，围绕单个商店与多个商店以及本地状态容器的问题，正在进行大量的讨论。</p><p id="6fae" class="pw-post-body-paragraph jk jl hi jm b jn kk jp jq jr kl jt ju jv kz jx jy jz la kb kc kd lb kf kg kh hb bi translated">我在这里采取的方法是尽可能不固执己见，支持不同的“风格”。目标是为业务逻辑和状态容器创建一个支持集中和分散方法的框架。</p><h1 id="08d0" class="im in hi bd io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj bi translated">架构目标</h1><p id="2738" class="pw-post-body-paragraph jk jl hi jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh hb bi translated">帮助形成该解决方案的架构目标是:</p><ul class=""><li id="56fb" class="ki kj hi jm b jn kk jr kl jv km jz kn kd ko kh kp kq kr ks bi translated">与平台无关:这是一个 KMM 框架，所以这是显而易见的。</li><li id="7e6b" class="ki kj hi jm b jn ku jr kv jv kw jz kx kd ky kh kp kq kr ks bi translated">Be <strong class="jm hj">反应式</strong>:反应式用户界面在最近几年已经成为标准，这是有充分理由的。</li><li id="61b7" class="ki kj hi jm b jn ku jr kv jv kw jz kx kd ky kh kp kq kr ks bi translated">Be <strong class="jm hj"> composable </strong>:能够将 ui 分解成小组件，然后再将它们组合成更大的组件。</li><li id="be56" class="ki kj hi jm b jn ku jr kv jv kw jz kx kd ky kh kp kq kr ks bi translated">尽可能不固执己见:支持不同的技术、编程风格、应用程序复杂性和团队规模。</li><li id="fc0e" class="ki kj hi jm b jn ku jr kv jv kw jz kx kd ky kh kp kq kr ks bi translated"><strong class="jm hj">极简</strong>和<strong class="jm hj">轻量级</strong>:一些现有的框架非常全面，但也很重，需要编写大量的样板代码(例如<a class="ae kt" href="https://arkivanov.github.io/Decompose/" rel="noopener ugc nofollow" target="_blank">分解</a>)。组件之间的严格契约(导致样板代码)在大型团队中至关重要，但是当速度至关重要时(以及在小型团队中)，它们会降低团队的生产力。应该支持更严格的方法，但不是强制执行。</li><li id="b281" class="ki kj hi jm b jn ku jr kv jv kw jz kx kd ky kh kp kq kr ks bi translated">可预测性<strong class="jm hj"/>:执行的顺序(同步和异步)和并发模型必须明确规定，并导致可预测和可重复的结果。</li></ul><h1 id="512b" class="im in hi bd io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj bi translated">科特林集团</h1><p id="a88d" class="pw-post-body-paragraph jk jl hi jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh hb bi translated"><code class="du ld le lf lg b">Kotlin Bloc</code>是满足这些架构目标的框架的名称。Bloc 代表商业逻辑组件，这个术语是由谷歌创造的，在动荡的世界<a class="ae kt" href="https://bloclibrary.dev/#/" rel="noopener ugc nofollow" target="_blank">中很流行。完整的框架文档可以在这里找到:</a><a class="ae kt" href="https://1gravity.github.io/Kotlin-Bloc" rel="noopener ugc nofollow" target="_blank">https://1gravity.github.io/Kotlin-Bloc</a>。</p><h2 id="a025" class="lh in hi bd io li lj lk is ll lm ln iw jv lo lp ja jz lq lr je kd ls lt ji lu bi translated">概观</h2><figure class="lw lx ly lz fd ii er es paragraph-image"><div role="button" tabindex="0" class="ma mb di mc bf md"><div class="er es lv"><img src="../Images/0825900b9475c325bcccdab6512537ec.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*1FUK78kqNSuuoJBQ"/></div></div></figure><p id="320b" class="pw-post-body-paragraph jk jl hi jm b jn kk jp jq jr kl jt ju jv kz jx jy jz la kb kc kd lb kf kg kh hb bi translated">该框架有两个主要部分:</p><ul class=""><li id="2994" class="ki kj hi jm b jn kk jr kl jv km jz kn kd ko kh kp kq kr ks bi translated"><strong class="jm hj">块</strong>(业务逻辑组件)封装了应用程序的业务逻辑。它从视图接收<strong class="jm hj">动作</strong>，处理这些动作并输出<strong class="jm hj">建议</strong>和可选的<strong class="jm hj">副作用</strong>。</li><li id="214b" class="ki kj hi jm b jn ku jr kv jv kw jz kx kd ky kh kp kq kr ks bi translated"><strong class="jm hj">块状态</strong>保存组件的<strong class="jm hj">状态</strong>。它独立于实际的块，以支持不同的场景，如:<br/> -在业务逻辑组件之间共享状态<br/> -保持状态(数据库、网络)<br/> -使用像 Redux 这样的全局状态容器</li></ul><p id="7464" class="pw-post-body-paragraph jk jl hi jm b jn kk jp jq jr kl jt ju jv kz jx jy jz la kb kc kd lb kf kg kh hb bi translated"><strong class="jm hj">视图</strong>显然也是一个重要的组件，但从技术上讲不是框架的一部分(尽管有许多<a class="ae kt" href="https://1gravity.github.io/Kotlin-Bloc/docs/extensions/overview" rel="noopener ugc nofollow" target="_blank">扩展</a>支持/简化不同目标平台的实现)。</p><p id="370f" class="pw-post-body-paragraph jk jl hi jm b jn kk jp jq jr kl jt ju jv kz jx jy jz la kb kc kd lb kf kg kh hb bi translated">不出所料，颤振阻止命名法也用于这种结构的一些其它部件/子部件:</p><ul class=""><li id="52bd" class="ki kj hi jm b jn kk jr kl jv km jz kn kd ko kh kp kq kr ks bi translated">一个<strong class="jm hj">接收器</strong>是任意数据的目的地，用于将数据从一个组件发送到另一个组件。Bloc 有一个用于<strong class="jm hj">动作</strong>的接收器，而 BlocState 有一个用于<strong class="jm hj">提议</strong>的接收器。</li><li id="8fe3" class="ki kj hi jm b jn ku jr kv jv kw jz kx kd ky kh kp kq kr ks bi translated"><strong class="jm hj">流</strong>是异步数据的来源。流总是“热”的，这意味着无论组件是否在监听(或订阅或收集- &gt;同一事物的不同名称)，数据都会被发出。一个块有两个流，一个用于<strong class="jm hj">状态</strong>，一个用于<strong class="jm hj">副作用</strong>，而一个块状态有一个用于<strong class="jm hj">状态</strong>。</li></ul><h2 id="bd78" class="lh in hi bd io li lj lk is ll lm ln iw jv lo lp ja jz lq lr je kd ls lt ji lu bi translated">集团</h2><p id="75a3" class="pw-post-body-paragraph jk jl hi jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh hb bi translated">下图描述了块的内部工作方式:</p><figure class="lw lx ly lz fd ii er es paragraph-image"><div role="button" tabindex="0" class="ma mb di mc bf md"><div class="er es me"><img src="../Images/b5a9e124394cb9d6ad894b38e708a9d2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*mRdT3Bvk5yGa8On0"/></div></div></figure><p id="425f" class="pw-post-body-paragraph jk jl hi jm b jn kk jp jq jr kl jt ju jv kz jx jy jz la kb kc kd lb kf kg kh hb bi translated">挡块的主要部件有<strong class="jm hj">减速器</strong>、<strong class="jm hj">挂钩</strong>和<strong class="jm hj">启动器</strong>。</p><p id="7c1c" class="pw-post-body-paragraph jk jl hi jm b jn kk jp jq jr kl jt ju jv kz jx jy jz la kb kc kd lb kf kg kh hb bi translated"><strong class="jm hj"> 1。减速器</strong></p><blockquote class="mf mg mh"><p id="be7d" class="jk jl mi jm b jn kk jp jq jr kl jt ju mj kz jx jy mk la kb kc ml lb kf kg kh hb bi translated"><em class="hi">reducer 是一个函数，它接收当前状态和一个动作对象，在必要时决定如何更新状态，并返回新的状态:</em><code class="du ld le lf lg b"><em class="hi">(state, action) =&gt; newState</em></code><em class="hi"><br/>(</em><a class="ae kt" href="https://redux.js.org/tutorials/fundamentals/part-2-concepts-data-flow" rel="noopener ugc nofollow" target="_blank"><em class="hi">https://redux . js . org/tutorials/fundamentals/part-2-concepts-data-flow</em></a><em class="hi">)</em></p></blockquote><p id="2400" class="pw-post-body-paragraph jk jl hi jm b jn kk jp jq jr kl jt ju jv kz jx jy jz la kb kc kd lb kf kg kh hb bi translated">以上定义是 Redux reducer 的官方定义，并且抓住了它的本质，尽管<code class="du ld le lf lg b">Kotlin Bloc</code>上下文中的 reducer 稍微复杂一些:</p><pre class="lw lx ly lz fd mm lg mn mo aw mp bi"><span id="d868" class="lh in hi lg b fi mq mr l ms mt">suspend (State, Action, CoroutineScope) -&gt; Proposal</span></pre><p id="277a" class="pw-post-body-paragraph jk jl hi jm b jn kk jp jq jr kl jt ju jv kz jx jy jz la kb kc kd lb kf kg kh hb bi translated">与 Redux 减压器相比，这款减压器:</p><ol class=""><li id="ca98" class="ki kj hi jm b jn kk jr kl jv km jz kn kd ko kh lc kq kr ks bi translated">悬浮</li><li id="dd9f" class="ki kj hi jm b jn ku jr kv jv kw jz kx kd ky kh lc kq kr ks bi translated">将协同作用域作为参数(在<code class="du ld le lf lg b">State</code>和<code class="du ld le lf lg b">Action</code>之上)</li><li id="3931" class="ki kj hi jm b jn ku jr kv jv kw jz kx kd ky kh lc kq kr ks bi translated">返回一个<code class="du ld le lf lg b">Proposal</code>而不是<code class="du ld le lf lg b">State</code></li></ol><p id="8d94" class="pw-post-body-paragraph jk jl hi jm b jn kk jp jq jr kl jt ju jv kz jx jy jz la kb kc kd lb kf kg kh hb bi translated">有不同类型的减速器，我们将在最后一章“不同类型”中详细讨论。这里有一个简单的例子:</p><pre class="lw lx ly lz fd mm lg mn mo aw mp bi"><span id="3d9e" class="lh in hi lg b fi mq mr l ms mt">// single-action reducer<br/>reduce&lt;Increment&gt; { state + 1 }<br/>reduce&lt;Decrement&gt; { state - 1 }</span><span id="b32c" class="lh in hi lg b fi mu mr l ms mt">// catch-all reducer<br/>reduce {<br/>    when (action) {<br/>        Increment -&gt; state + 1<br/>        Decrement -&gt; state - 1<br/>    }<br/>}</span></pre><p id="5bc1" class="pw-post-body-paragraph jk jl hi jm b jn kk jp jq jr kl jt ju jv kz jx jy jz la kb kc kd lb kf kg kh hb bi translated"><strong class="jm hj"> 2。Thunk </strong></p><p id="b1db" class="pw-post-body-paragraph jk jl hi jm b jn kk jp jq jr kl jt ju jv kz jx jy jz la kb kc kd lb kf kg kh hb bi translated">虽然 reducers 是异步执行的，但它们的预期目的是及时更新<code class="du ld le lf lg b">State</code>,以确保用户界面响应用户输入并更新“没有”可察觉的延迟。应使用<code class="du ld le lf lg b">Thunk</code>执行较长时间的运行操作:</p><blockquote class="mf mg mh"><p id="4a13" class="jk jl mi jm b jn kk jp jq jr kl jt ju mj kz jx jy mk la kb kc ml lb kf kg kh hb bi translated">单词“thunk”是一个编程术语，意思是“一段做一些延迟工作的代码”。我们可以编写一个函数体或代码，用于以后执行工作，而不是现在执行一些逻辑。<br/><a class="ae kt" href="https://redux.js.org/usage/writing-logic-thunks" rel="noopener ugc nofollow" target="_blank"><em class="hi">https://redux.js.org/usage/writing-logic-thunks</em></a></p></blockquote><p id="2600" class="pw-post-body-paragraph jk jl hi jm b jn kk jp jq jr kl jt ju jv kz jx jy jz la kb kc kd lb kf kg kh hb bi translated"><code class="du ld le lf lg b">Kotlin Bloc</code>上下文中的<code class="du ld le lf lg b">Thunk</code>正是上述定义所暗示的，尽管它的实现，尤其是它的执行与 Redux thunk 完全不同。后者是一个函数，作为一个动作被分派给 Redux store，并由 redux-thunk 中间件处理，“我们的”thunk 不是作为一个动作被分派，而是通过对发送给<code class="du ld le lf lg b">Bloc</code>的<code class="du ld le lf lg b">Action</code>作出反应，以与触发 reducer 相同的方式被触发。还有更多不同之处:</p><ol class=""><li id="68a3" class="ki kj hi jm b jn kk jr kl jv km jz kn kd ko kh lc kq kr ks bi translated">这是一个暂停功能</li><li id="7e69" class="ki kj hi jm b jn ku jr kv jv kw jz kx kd ky kh lc kq kr ks bi translated">它采用一个协同作用域作为参数(在<code class="du ld le lf lg b">GetState</code>、<code class="du ld le lf lg b">Action</code>和<code class="du ld le lf lg b">Dispatcher</code>参数旁边)</li><li id="8e56" class="ki kj hi jm b jn ku jr kv jv kw jz kx kd ky kh lc kq kr ks bi translated"><code class="du ld le lf lg b">Actions</code>的调度遵循严格的规则(此处解释<a class="ae kt" href="https://1gravity.github.io/Kotlin-Bloc/docs/architecture/bloc/thunk#execution" rel="noopener ugc nofollow" target="_blank"/></li></ol><p id="91cb" class="pw-post-body-paragraph jk jl hi jm b jn kk jp jq jr kl jt ju jv kz jx jy jz la kb kc kd lb kf kg kh hb bi translated">这里有一个简单的例子:</p><pre class="lw lx ly lz fd mm lg mn mo aw mp bi"><span id="4a73" class="lh in hi lg b fi mq mr l ms mt">thunk&lt;Load&gt; {<br/>    dispatch(Loading)<br/>    val result = repository.load()<br/>    dispatch(Loaded(result))<br/>}</span><span id="f0ce" class="lh in hi lg b fi mu mr l ms mt">reduce&lt;Loading&gt; {<br/>    state.copy(loading = true)<br/>}</span><span id="a71b" class="lh in hi lg b fi mu mr l ms mt">reduce&lt;Loaded&gt; {<br/>    state.copy(loading = false, items = action.result)<br/>}</span></pre><p id="8764" class="pw-post-body-paragraph jk jl hi jm b jn kk jp jq jr kl jt ju jv kz jx jy jz la kb kc kd lb kf kg kh hb bi translated"><strong class="jm hj"> 3。初始值设定项</strong></p><p id="df8e" class="pw-post-body-paragraph jk jl hi jm b jn kk jp jq jr kl jt ju jv kz jx jy jz la kb kc kd lb kf kg kh hb bi translated">初始化器是创建块时执行的函数。它们类似于 thunks，因为它们可以执行异步代码并分派动作由其他 thunks 和 reducers 处理。与 thunks 不同，初始化器只在块的生命周期中执行一次。</p><pre class="lw lx ly lz fd mm lg mn mo aw mp bi"><span id="23cb" class="lh in hi lg b fi mq mr l ms mt">onCreate { <br/>    if (state.isEmpty()) dispatch(Load) <br/>}</span></pre><h2 id="f10d" class="lh in hi bd io li lj lk is ll lm ln iw jv lo lp ja jz lq lr je kd ls lt ji lu bi translated">BlocState</h2><p id="6d9a" class="pw-post-body-paragraph jk jl hi jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh hb bi translated"><code class="du ld le lf lg b">BlocState</code>是<code class="du ld le lf lg b">State</code>的实际持有者，是异步状态数据(<code class="du ld le lf lg b">StateStream</code>)的来源，也是<code class="du ld le lf lg b">Proposals</code>(潜在地)改变其状态的<code class="du ld le lf lg b">Sink</code>。它的界面很简单:</p><pre class="lw lx ly lz fd mm lg mn mo aw mp bi"><span id="23ef" class="lh in hi lg b fi mq mr l ms mt">// StateStream<br/>public val value: State<br/>public suspend fun collect(collector: FlowCollector&lt;State&gt;)</span><span id="b4db" class="lh in hi lg b fi mu mr l ms mt">// Sink<br/>public fun send(proposal: Proposal)</span></pre><p id="1ecd" class="pw-post-body-paragraph jk jl hi jm b jn kk jp jq jr kl jt ju jv kz jx jy jz la kb kc kd lb kf kg kh hb bi translated">默认的 BlocState 实现采用一个<code class="du ld le lf lg b">accept()</code>函数来接受/拒绝<strong class="jm hj">提议</strong>作为对<strong class="jm hj">状态</strong>的更新(取自<a class="ae kt" href="https://sam.js.org/" rel="noopener ugc nofollow" target="_blank"> SAM </a>):</p><figure class="lw lx ly lz fd ii er es paragraph-image"><div role="button" tabindex="0" class="ma mb di mc bf md"><div class="er es mv"><img src="../Images/4926b0248d9b144346db230047579ec0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*8i9DGS0CgD3SFVau"/></div></div></figure><p id="e4a5" class="pw-post-body-paragraph jk jl hi jm b jn kk jp jq jr kl jt ju jv kz jx jy jz la kb kc kd lb kf kg kh hb bi translated">由于 Bloc 和 BlocState 之间的明显区别，我们可以很容易地将一个特定的 BlocState 与另一个 Bloc state 交换，例如，从我们的<a class="ae kt" href="https://1gravity.github.io/Kotlin-Bloc/docs/examples/todo" rel="noopener ugc nofollow" target="_blank"> todo 应用程序示例</a>:</p><pre class="lw lx ly lz fd mm lg mn mo aw mp bi"><span id="a9ad" class="lh in hi lg b fi mq mr l ms mt">fun toDoBloc(context: BlocContext) = bloc&lt;List&lt;ToDo&gt;, ToDoAction&gt;(<br/>    context = context,<br/><strong class="lg hj">    </strong><a class="ae kt" href="https://1gravity.github.io/Kotlin-Bloc/docs/examples/todo" rel="noopener ugc nofollow" target="_blank"><strong class="lg hj">blocState = PersistingToDoState() </strong></a><br/>) {</span></pre><p id="e80d" class="pw-post-body-paragraph jk jl hi jm b jn kk jp jq jr kl jt ju jv kz jx jy jz la kb kc kd lb kf kg kh hb bi translated"><code class="du ld le lf lg b">PersistingToDoState</code>顾名思义就是持久地存储待办数据。更改一行代码可以改变这种行为(对块透明):</p><pre class="lw lx ly lz fd mm lg mn mo aw mp bi"><span id="ca71" class="lh in hi lg b fi mq mr l ms mt">fun toDoBloc(context: BlocContext) = bloc&lt;List&lt;ToDo&gt;, ToDoAction&gt;(<br/>    context = context,<br/>    <strong class="lg hj">blocState = blocState(emptyList())     </strong><br/>) {</span></pre><h1 id="183e" class="im in hi bd io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj bi translated">不同的风格</h1><p id="eeff" class="pw-post-body-paragraph jk jl hi jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh hb bi translated">如前所述，我们希望支持不同的编程风格，以支持不同类型的应用程序、不同的复杂程度、不同的团队规模和不同的做事方式。</p><h2 id="06c2" class="lh in hi bd io li lj lk is ll lm ln iw jv lo lp ja jz lq lr je kd ls lt ji lu bi translated">集团</h2><p id="ccac" class="pw-post-body-paragraph jk jl hi jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh hb bi translated">支持这些目标的一个特征是<strong class="jm hj">全包</strong>与<strong class="jm hj">单作用</strong>减速器，这使得编写更多整体式减速器或更孤立的减速器成为可能:</p><figure class="lw lx ly lz fd ii"><div class="bz dy l di"><div class="mw mx l"/></div></figure><p id="8393" class="pw-post-body-paragraph jk jl hi jm b jn kk jp jq jr kl jt ju jv kz jx jy jz la kb kc kd lb kf kg kh hb bi translated">相同的语法也可以用于 thunks 和副作用:</p><pre class="lw lx ly lz fd mm lg mn mo aw mp bi"><span id="4d57" class="lh in hi lg b fi mq mr l ms mt">thunk&lt;Load&gt; { ... }<br/>thunk&lt;Save&gt; { ... }<br/>thunk { <br/>    when(action) {<br/>        Load -&gt; ...<br/>        Save -&gt; ...<br/>    }<br/>}</span><span id="78c6" class="lh in hi lg b fi mu mr l ms mt">sideEffect&lt;Load&gt; { ... }<br/>sideEffect { ... }</span></pre><p id="afbe" class="pw-post-body-paragraph jk jl hi jm b jn kk jp jq jr kl jt ju jv kz jx jy jz la kb kc kd lb kf kg kh hb bi translated">“<a class="ae kt" href="https://orbit-mvi.org/" rel="noopener ugc nofollow" target="_blank">轨道</a>”模型将这个想法推进了一步。<a class="ae kt" href="https://orbit-mvi.org/" rel="noopener ugc nofollow" target="_blank"> Orbit </a>框架有一个<code class="du ld le lf lg b">ContainerHost</code>的概念，用于想要启动 Orbit <code class="du ld le lf lg b">intents</code>的类:</p><figure class="lw lx ly lz fd ii"><div class="bz dy l di"><div class="mw mx l"/></div></figure><p id="271d" class="pw-post-body-paragraph jk jl hi jm b jn kk jp jq jr kl jt ju jv kz jx jy jz la kb kc kd lb kf kg kh hb bi translated">因为任何类都可以是一个<code class="du ld le lf lg b">ContainerHost</code>类，所以任何类都可以包含 reducer 代码来解决本文<a class="ae kt" href="https://dev.to/feresr/a-case-against-the-mvi-architecture-pattern-1add" rel="noopener ugc nofollow" target="_blank">中提出的主要问题。</a></p><p id="a9c5" class="pw-post-body-paragraph jk jl hi jm b jn kk jp jq jr kl jt ju jv kz jx jy jz la kb kc kd lb kf kg kh hb bi translated"><code class="du ld le lf lg b">Kotlin Bloc</code>有<code class="du ld le lf lg b"><a class="ae kt" href="https://1gravity.github.io/Kotlin-Bloc/docs/architecture/blocowner/bloc_owner" rel="noopener ugc nofollow" target="_blank">BlocOwners</a></code>的概念，一个可以被任何类实现的接口，允许我们使用 Orbit/MVVM+语法:</p><figure class="lw lx ly lz fd ii"><div class="bz dy l di"><div class="mw mx l"/></div></figure><p id="d15d" class="pw-post-body-paragraph jk jl hi jm b jn kk jp jq jr kl jt ju jv kz jx jy jz la kb kc kd lb kf kg kh hb bi translated">因此，我们可以声明 reducers 并认为是“构建器风格”(集中在一个构建器块中)或“BlocOwner 风格”(分散)。显然，我们也可以使用常规的 Kotlin 特性来分解/组合业务逻辑代码(比如将 reducer 代码提取到单独的函数中，或者使用扩展函数)。</p><h2 id="ccb5" class="lh in hi bd io li lj lk is ll lm ln iw jv lo lp ja jz lq lr je kd ls lt ji lu bi translated">BlocState</h2><p id="35f4" class="pw-post-body-paragraph jk jl hi jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh hb bi translated">支持“不固执己见”目标的另一个重要特性是状态容器(BlocState)和实际业务逻辑(Bloc)之间的分离，以及两者之间的交互遵循严格协议的事实。这允许我们在<strong class="jm hj">单店</strong>与<strong class="jm hj">多店</strong>与<strong class="jm hj">地方州</strong>战略(或三者的组合)之间进行选择。</p><p id="6b80" class="pw-post-body-paragraph jk jl hi jm b jn kk jp jq jr kl jt ju jv kz jx jy jz la kb kc kd lb kf kg kh hb bi translated">例如，我们可以在集团之间共享状态:</p><pre class="lw lx ly lz fd mm lg mn mo aw mp bi"><span id="4a96" class="lh in hi lg b fi mq mr l ms mt">// define the shared state<br/>private val commonState = blocState&lt;BookState&gt;(BookState.Empty)</span><span id="ef43" class="lh in hi lg b fi mu mr l ms mt">// first Bloc to use the commonState<br/>private val clearBloc = bloc&lt;BookState, BookAction.Clear&gt;(<br/>  context, <br/>  commonState<br/>) {<br/>  // business logic<br/>}</span><span id="bfdc" class="lh in hi lg b fi mu mr l ms mt">// second Bloc to use the commonState<br/>private val loadBloc = bloc&lt;BookState, BookAction&gt;(<br/>  context, <br/>  commonState<br/>) {<br/>  // business logic<br/>}</span></pre><p id="99f6" class="pw-post-body-paragraph jk jl hi jm b jn kk jp jq jr kl jt ju jv kz jx jy jz la kb kc kd lb kf kg kh hb bi translated">我们还可以使用像 Redux 这样的全局状态容器来跨所有业务逻辑组件共享状态:</p><figure class="lw lx ly lz fd ii er es paragraph-image"><div role="button" tabindex="0" class="ma mb di mc bf md"><div class="er es my"><img src="../Images/df36d847c78569be06ae0c81d70c606f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*iRw1aJ8Vd2PPwb0x"/></div></div></figure><p id="a018" class="pw-post-body-paragraph jk jl hi jm b jn kk jp jq jr kl jt ju jv kz jx jy jz la kb kc kd lb kf kg kh hb bi translated">事实上，<code class="du ld le lf lg b">Kotlin Bloc</code>带有一个<a class="ae kt" href="https://1gravity.github.io/Kotlin-Bloc/docs/extensions/redux/redux_motivation" rel="noopener ugc nofollow" target="_blank"> Redux 适配器</a>，它将 Redux 存储转换为 BlocState 并支持<a class="ae kt" href="https://redux.js.org/usage/deriving-data-selectors" rel="noopener ugc nofollow" target="_blank">记忆选择器功能</a>。</p><h1 id="2a91" class="im in hi bd io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj bi translated">摘要</h1><p id="b029" class="pw-post-body-paragraph jk jl hi jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh hb bi translated"><code class="du ld le lf lg b">Kotlin Bloc</code>是一个简单且可组合的 Kotlin 多平台 UI 框架，它将适应您的编程风格，并能很好地集成到现有的应用程序中。它在实现业务逻辑、状态容器和如何不太死板地连接到用户界面之间找到了最佳点。</p><p id="5064" class="pw-post-body-paragraph jk jl hi jm b jn kk jp jq jr kl jt ju jv kz jx jy jz la kb kc kd lb kf kg kh hb bi translated">感谢您的阅读，感谢您在评论区的反馈。</p></div></div>    
</body>
</html>