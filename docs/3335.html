<html>
<head>
<title>Introduction to Modern JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">现代JavaScript简介</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/introduction-to-modern-javascript-7f50316a7e47?source=collection_archive---------21-----------------------#2021-06-06">https://medium.com/nerd-for-tech/introduction-to-modern-javascript-7f50316a7e47?source=collection_archive---------21-----------------------#2021-06-06</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/030aefba4272fa71303569a1219885d9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*OfzhG0Waltg3iLbg.png"/></div></div></figure><p id="36b8" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">JavaScript是世界上最流行的编程语言之一。它可以用于构建web/移动应用程序、实时网络应用程序、命令行工具等。2015年，ECMA发布了名为ECMAScript 6 (ES 6)的新版本。该规范为JavaScript定义了许多新特性。让我们看看这篇文章中的那些特性。</p><h1 id="29a4" class="jo jp hi bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">声明变量和常数</h1><p id="bed5" class="pw-post-body-paragraph iq ir hi is b it km iv iw ix kn iz ja jb ko jd je jf kp jh ji jj kq jl jm jn hb bi translated">在ES6之前，<code class="du kr ks kt ku b">var</code>关键字用于声明任何种类的变量。但是这个关键词有很多问题。</p><ul class=""><li id="59f6" class="kv kw hi is b it iu ix iy jb kx jf ky jj kz jn la lb lc ld bi translated">不支持<strong class="is hj">块范围</strong>变量。换句话说，用<code class="du kr ks kt ku b">var</code>关键字声明的变量在整个脚本中都是可见的。因此很难确保变量名不会与脚本重复。</li><li id="25a9" class="kv kw hi is b it le ix lf jb lg jf lh jj li jn la lb lc ld bi translated">它没有办法让一个<strong class="is hj">最终变量</strong>或者<strong class="is hj">常量</strong>。</li></ul><p id="2c2d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">相反，ES6引入了两个名为<strong class="is hj"> let </strong>和<strong class="is hj"> const </strong>的独立关键字来管理这些困难。<code class="du kr ks kt ku b">let</code>关键字用于声明变量，它将在脚本中的特定范围/块内可见。</p><figure class="lj lk ll lm fd ij"><div class="bz dy l di"><div class="ln lo l"/></div></figure><p id="d4cb" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在这个例子中，我使用关键字<code class="du kr ks kt ku b">let</code>声明了两个变量。sum变量仅在calculateTotal函数内部可见。元素变量仅在for循环中可见。这被称为块范围变量。如果有人试图从函数外部访问sum变量，它将抛出一个名为“ReferenceError”的错误。</p><figure class="lj lk ll lm fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lp"><img src="../Images/3e351ac0ed13803599e977e0e793cdcd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*n_PsjGamh6jQCkvaEVlU9Q.png"/></div></div><figcaption class="lq lr et er es ls lt bd b be z dx translated">引用错误的错误消息</figcaption></figure><p id="54ac" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">ES6引入的另一个关键词是<code class="du kr ks kt ku b">const</code>关键词。它用于声明在整个脚本中应该是不可变的常数。</p><figure class="lj lk ll lm fd ij"><div class="bz dy l di"><div class="ln lo l"/></div></figure><p id="c5c4" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">因此我们得到了一个名为“TypeError”的错误。</p><figure class="lj lk ll lm fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lu"><img src="../Images/23b161912b45a515f26b822ccc3b264f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BIOsOwHQTEhI1uefoaI8pA.png"/></div></div><figcaption class="lq lr et er es ls lt bd b be z dx translated">TypeError的错误消息</figcaption></figure><p id="a6b7" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">大多数开发人员在处理引用类型变量时会混淆<code class="du kr ks kt ku b">const</code>关键字。因为他们认为如果对象被声明为常量，它将是不可变的。实际上，这个变量保存的是内存地址而不是对象。所以，内存地址是不可变的。但这并不意味着您不能更改对象中的键值对。</p><figure class="lj lk ll lm fd ij"><div class="bz dy l di"><div class="ln lo l"/></div></figure><p id="42ec" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这是一个完全正确的说法。</p><figure class="lj lk ll lm fd ij er es paragraph-image"><div class="er es lv"><img src="../Images/d4764a7b3a282cac421a078620d25e99.png" data-original-src="https://miro.medium.com/v2/resize:fit:1310/format:webp/1*Z77PbJd5rJGWe-CB9EvdnQ.png"/></div><figcaption class="lq lr et er es ls lt bd b be z dx translated">上述代码的输出</figcaption></figure></div><div class="ab cl lw lx gp ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="hb hc hd he hf"><h1 id="99d7" class="jo jp hi bd jq jr md jt ju jv me jx jy jz mf kb kc kd mg kf kg kh mh kj kk kl bi translated">对象冻结()和密封()方法</h1><p id="dcda" class="pw-post-body-paragraph iq ir hi is b it km iv iw ix kn iz ja jb ko jd je jf kp jh ji jj kq jl jm jn hb bi translated">在上面的例子中，你可以看到我们可以给对象添加其他属性，即使它被声明为常量。要克服它，可以使用<strong class="is hj"> freeze() </strong>和<strong class="is hj"> seal() </strong>方法。顾名思义，这两种方法都用于创建不可扩展的对象。</p><p id="c511" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">冻结()方法— </strong>防止属性扩展和删除。如果是第一级值，它将冻结属性值。换句话说，它不能冻结内部物体。</p><figure class="lj lk ll lm fd ij"><div class="bz dy l di"><div class="ln lo l"/></div></figure><p id="c389" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在上面的例子中，我试图改变四个不同的属性。</p><ol class=""><li id="1a1d" class="kv kw hi is b it iu ix iy jb kx jf ky jj kz jn mi lb lc ld bi translated">添加新属性—不可能</li><li id="292e" class="kv kw hi is b it le ix lf jb lg jf lh jj li jn mi lb lc ld bi translated">移除属性—不可能</li><li id="783a" class="kv kw hi is b it le ix lf jb lg jf lh jj li jn mi lb lc ld bi translated">更改属性—不可能</li><li id="75b9" class="kv kw hi is b it le ix lf jb lg jf lh jj li jn mi lb lc ld bi translated">更改内部对象属性—可能</li></ol><figure class="lj lk ll lm fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lp"><img src="../Images/ef34a2689c75030f909597e07097f6d9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QlXiAbh_wkIkEzT1KV8Eww.png"/></div></div><figcaption class="lq lr et er es ls lt bd b be z dx translated">上述代码的输出</figcaption></figure><p id="ef4f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj"> Seal()方法</strong> —防止属性扩展和删除。但是它不能阻止属性值的变化。</p><figure class="lj lk ll lm fd ij"><div class="bz dy l di"><div class="ln lo l"/></div></figure><p id="6f09" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">输出，</p><figure class="lj lk ll lm fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mj"><img src="../Images/9fe069781ff38c1e58b24ee480385938.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GEeAD6nWxTEvPDr3msrY3w.png"/></div></div><figcaption class="lq lr et er es ls lt bd b be z dx translated">上述代码的输出</figcaption></figure></div><div class="ab cl lw lx gp ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="hb hc hd he hf"><h1 id="1918" class="jo jp hi bd jq jr md jt ju jv me jx jy jz mf kb kc kd mg kf kg kh mh kj kk kl bi translated">箭头功能</h1><p id="1139" class="pw-post-body-paragraph iq ir hi is b it km iv iw ix kn iz ja jb ko jd je jf kp jh ji jj kq jl jm jn hb bi translated">数组函数是一种非常好的方法，可以更简洁地编写相同的函数。将回调函数作为方法参数传递非常有用。</p><figure class="lj lk ll lm fd ij"><div class="bz dy l di"><div class="ln lo l"/></div></figure><p id="b545" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">您可以看到箭头函数去除了代码中的额外噪声。让我们看看普通函数到箭头函数的转换。</p><figure class="lj lk ll lm fd ij"><div class="bz dy l di"><div class="ln lo l"/></div></figure><p id="22ee" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">首先，我们可以把函数关键字的粗箭头替换掉(第一步:去掉函数关键字，在参数和代码块之间放一个粗箭头。).如果代码块只有一行，则不需要花括号。如果是return语句，return关键字也被删除(步骤2)。</p><p id="ca68" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如果函数只有一个参数，我们也可以去掉括号。</p><pre class="lj lk ll lm fd mk ku ml mm aw mn bi"><span id="aa98" class="mo jp hi ku b fi mp mq l mr ms">const printName = name =&gt; console.log('Hello, ' + name);</span></pre><p id="a766" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">简单并不是这些箭头函数的唯一好处。让我们看看箭头函数的一些好处。</p><p id="179f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们都知道常规函数中的<code class="du kr ks kt ku b">this</code>关键字引用的是<strong class="is hj">窗口对象</strong>(浏览器中)或者<strong class="is hj">全局对象</strong>(节点中)。但是如果我们在一个对象中使用<code class="du kr ks kt ku b">this</code>关键字，它引用当前对象。让我们用一个恰当的例子来解释它。</p><p id="543f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在对象的方法中调用此关键字。</p><figure class="lj lk ll lm fd ij"><div class="bz dy l di"><div class="ln lo l"/></div></figure><p id="3087" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">输出，</p><figure class="lj lk ll lm fd ij er es paragraph-image"><div class="er es mt"><img src="../Images/3d5c0f9ae7e42545b44111827705acfc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1074/format:webp/1*BMELBkiV6H-nEBjFmhEsnw.png"/></div></figure><p id="2787" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">你可以看到<code class="du kr ks kt ku b">this</code>关键字引用了当前对象。但在常规函数中是不同的。</p><figure class="lj lk ll lm fd ij"><div class="bz dy l di"><div class="ln lo l"/></div></figure><p id="75e2" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">输出，</p><figure class="lj lk ll lm fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lp"><img src="../Images/cdffe88b543b157546395b4252bd7d49.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*F8-h6O1cZW5o2ALvbaK9Jg.png"/></div></div></figure><p id="26a0" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">你可以清楚地看到常规函数中的<code class="du kr ks kt ku b">this</code>关键字引用了全局对象。那么，会发生什么呢一个常规函数在一个对象的方法内部调用<code class="du kr ks kt ku b">this</code>关键字。</p><figure class="lj lk ll lm fd ij"><div class="bz dy l di"><div class="ln lo l"/></div></figure><p id="b13f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这里，我在第10行传递了一个常规函数作为回调函数。因此，<code class="du kr ks kt ku b">this.title</code>在这个常规函数中是未定义的。因为该函数将全局对象作为关键字<code class="du kr ks kt ku b">this</code>引用。</p><figure class="lj lk ll lm fd ij er es paragraph-image"><div class="er es mu"><img src="../Images/0f05c712c9f3aca4758d8fd8b58cd183.png" data-original-src="https://miro.medium.com/v2/resize:fit:1058/format:webp/1*P7cY-RVaTjQg0-K0sZiuDA.png"/></div><figcaption class="lq lr et er es ls lt bd b be z dx translated">上述代码的输出</figcaption></figure><p id="b939" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">有几种方法可以克服这个问题。</p><pre class="lj lk ll lm fd mk ku ml mm aw mn bi"><span id="0c27" class="mo jp hi ku b fi mp mq l mr ms">let self = this;</span></pre><p id="d199" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">首先，我们需要在showTags方法中定义self变量。那么我们可以用它来代替<code class="du kr ks kt ku b">this</code>关键字。很少有其他方式像<code class="du kr ks kt ku b">thisArg</code>论证、<code class="du kr ks kt ku b">bind(this)</code>方法等。但是这些都是解决这个问题的模式。在现代JavaScript中，箭头函数可以用来求解。因为箭头函数从包含函数继承了<code class="du kr ks kt ku b">this</code>。</p><figure class="lj lk ll lm fd ij"><div class="bz dy l di"><div class="ln lo l"/></div></figure><p id="58e1" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">输出，</p><figure class="lj lk ll lm fd ij er es paragraph-image"><div class="er es mv"><img src="../Images/32d264a528b421cfed18c4c6b16e24e3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1150/format:webp/1*fIphHM_leqp1Oj5-ejXVnA.png"/></div><figcaption class="lq lr et er es ls lt bd b be z dx translated">上述代码的输出</figcaption></figure><p id="7d96" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">所以，我想你通过使用箭头函数理解了程序的简单性。</p></div><div class="ab cl lw lx gp ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="hb hc hd he hf"><h1 id="df17" class="jo jp hi bd jq jr md jt ju jv me jx jy jz mf kb kc kd mg kf kg kh mh kj kk kl bi translated">现代JavaScript中的对象</h1><p id="a0dd" class="pw-post-body-paragraph iq ir hi is b it km iv iw ix kn iz ja jb ko jd je jf kp jh ji jj kq jl jm jn hb bi translated">在ECMAScript中，对象声明也有一些小的变化。但是简化代码真的很有用。让我们看看这些变化。</p><figure class="lj lk ll lm fd ij"><div class="bz dy l di"><div class="ln lo l"/></div></figure><p id="9636" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">您可以看到deliveryTime变量在第2行被初始化。此外，我在第8行中为对象的一个键使用了相同的名称。所以，它没有通常的键值对。原因是如果我们使用相同的名字作为一个对象和另一个变量的键，它不需要显式地提到它。</p><p id="d450" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如果对象有<strong class="is hj">动态属性</strong>(键会随情况而变)，我们可以用方括号把变量名括起来。在本例中，第9行有一个名为status的属性。可以根据prepareStatus、deliveryStatus等情况进行更改。</p></div><div class="ab cl lw lx gp ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="hb hc hd he hf"><h1 id="22b9" class="jo jp hi bd jq jr md jt ju jv me jx jy jz mf kb kc kd mg kf kg kh mh kj kk kl bi translated">模板文字</h1><p id="7aa9" class="pw-post-body-paragraph iq ir hi is b it km iv iw ix kn iz ja jb ko jd je jf kp jh ji jj kq jl jm jn hb bi translated">在ES6之前，<strong class="is hj">转义符</strong>用于指定新行、单引号等。用这种方式创建自定义模板有点难看。模板文字用于克服这些困难。此外，它还在模板中引入了动态属性。</p><figure class="lj lk ll lm fd ij"><div class="bz dy l di"><div class="ln lo l"/></div></figure><p id="78fd" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">你可以看到第1行和第7到13行是一样的。但是第7到13行是文本的实际格式。所以，你可以很容易地理解模板的实际方式。我认为这将是非常好的功能，如果你用这样的模板工作。</p></div><div class="ab cl lw lx gp ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="hb hc hd he hf"><h1 id="c0e1" class="jo jp hi bd jq jr md jt ju jv me jx jy jz mf kb kc kd mg kf kg kh mh kj kk kl bi translated">班级</h1><p id="66c7" class="pw-post-body-paragraph iq ir hi is b it km iv iw ix kn iz ja jb ko jd je jf kp jh ji jj kq jl jm jn hb bi translated">实际上，现代JavaScript更多地与面向对象的概念相关。如果你来自Java。NET背景，你已经熟悉了OOP的概念。尽管不尽相同，但仍有一些相似的行为。先看班级创建。</p><p id="bd18" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">首先，您必须使用<code class="du kr ks kt ku b">class</code>关键字来定义类范围。然后在代码块中创建构造函数。如果你懂Java，你就知道构造函数必须有类名。但是这里的构造函数是由关键字<code class="du kr ks kt ku b">constructor</code>创建的。</p><figure class="lj lk ll lm fd ij"><div class="bz dy l di"><div class="ln lo l"/></div></figure><p id="5c20" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在这里，我创建了两个名为“Student”和“SemesterOneStudent”的类。此外，SemesterOneStudent是从Student继承的。因此，studentDetails方法在子类中被覆盖。如果您仔细阅读代码，您可以在第38到40行看到类似的代码，如方法覆盖。因此，您可以很容易地覆盖JavaScript中的方法。</p><p id="8101" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">输出，</p><figure class="lj lk ll lm fd ij er es paragraph-image"><div class="er es mw"><img src="../Images/ffc7ee43c0ad9307e82b91c4f3b21b07.png" data-original-src="https://miro.medium.com/v2/resize:fit:1308/format:webp/1*nn2tqc_km02rgYx_P2a62Q.png"/></div><figcaption class="lq lr et er es ls lt bd b be z dx translated">上述代码的输出</figcaption></figure></div><div class="ab cl lw lx gp ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="hb hc hd he hf"><h1 id="7318" class="jo jp hi bd jq jr md jt ju jv me jx jy jz mf kb kc kd mg kf kg kh mh kj kk kl bi translated">扩散算子和剩余算子</h1><p id="d944" class="pw-post-body-paragraph iq ir hi is b it km iv iw ix kn iz ja jb ko jd je jf kp jh ji jj kq jl jm jn hb bi translated">spread操作符是现代JavaScript中一个很酷的特性，可以从数组或对象中提取所有元素。这对于创建克隆、合并两个数组/对象等非常有用。如果一个函数有不同数量的参数，则使用rest运算符。让我们看一些例子来理解它。</p><figure class="lj lk ll lm fd ij"><div class="bz dy l di"><div class="ln lo l"/></div></figure><p id="44b7" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">输出，</p><figure class="lj lk ll lm fd ij er es paragraph-image"><div class="er es mx"><img src="../Images/b11fa3f2a4abb86428601922dfc3289b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1236/format:webp/1*1VsvEo8rJjhzQsehuH_MnQ.png"/></div></figure><p id="46bb" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">正如你所看到的，这些操作符在处理数组和对象时非常有用。</p><h1 id="b0dc" class="jo jp hi bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">承诺</h1><p id="15e3" class="pw-post-body-paragraph iq ir hi is b it km iv iw ix kn iz ja jb ko jd je jf kp jh ji jj kq jl jm jn hb bi translated">众所周知，JavaScript是一种异步编程语言。承诺用于处理这种异步行为。在现实世界中，承诺是一些可能以两种不同结果结束的陈述。时过境迁，承诺要么兑现，要么拒绝。但是完成其中一项需要时间。它将保持“挂起状态”,直到解决该问题。</p><ul class=""><li id="1b2d" class="kv kw hi is b it iu ix iy jb kx jf ky jj kz jn la lb lc ld bi translated"><strong class="is hj">待定— </strong>之前的初始状态为“已履行”或“已拒绝”。</li><li id="f6dd" class="kv kw hi is b it le ix lf jb lg jf lh jj li jn la lb lc ld bi translated"><strong class="is hj">完成— </strong>操作成功完成。</li><li id="99ea" class="kv kw hi is b it le ix lf jb lg jf lh jj li jn la lb lc ld bi translated"><strong class="is hj">拒绝— </strong>操作失败。</li></ul><p id="fd27" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">让我们通过一个恰当的例子来理解它。</p><figure class="lj lk ll lm fd ij"><div class="bz dy l di"><div class="ln lo l"/></div></figure><p id="5a7d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">HTTP请求到达服务器并发回响应需要时间。所以，这个过程应该等到响应回来。因此，它被一个承诺所包裹(第5行到第12行)。接下来让我们看看如何使用<strong class="is hj">，catch，</strong>和<strong class="is hj">最后是</strong>方法。</p><p id="ed3f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如果任务成功解决，则调用<code class="du kr ks kt ku b">then</code>方法。如果没有，它调用<code class="du kr ks kt ku b">catch</code>方法。无论如何，这个过程要么完成，要么被拒绝。最后，这个<code class="du kr ks kt ku b">finally</code>方法被调用。这与Java finally关键字非常相似。</p><p id="59da" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">另一种方法是使用<strong class="is hj">异步函数</strong>和<strong class="is hj"> await </strong>关键字。实际上，它是建立在承诺之上的，它只是语言中的语法糖，允许我们以同步模式编写异步代码。让我们看看它是如何发生的。</p><figure class="lj lk ll lm fd ij"><div class="bz dy l di"><div class="ln lo l"/></div></figure></div><div class="ab cl lw lx gp ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="hb hc hd he hf"><p id="e55c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">所以，我知道这不是对现代JavaScript特性的完整解释。希望这篇文章对开始学习这些很酷的功能有帮助。快乐学习！</p><h1 id="3b47" class="jo jp hi bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">参考</h1><figure class="lj lk ll lm fd ij"><div class="bz dy l di"><div class="my lo l"/></div></figure><figure class="lj lk ll lm fd ij"><div class="bz dy l di"><div class="my lo l"/></div></figure><div class="mz na ez fb nb nc"><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript" rel="noopener  ugc nofollow" target="_blank"><div class="nd ab dw"><div class="ne ab nf cl cj ng"><h2 class="bd hj fi z dy nh ea eb ni ed ef hh bi translated">JavaScript | MDN</h2><div class="nj l"><h3 class="bd b fi z dy nh ea eb ni ed ef dx translated">JavaScript (JS)是一种轻量级、解释型或即时编译的编程语言，具有一流的…</h3></div><div class="nk l"><p class="bd b fp z dy nh ea eb ni ed ef dx translated">developer.mozilla.org</p></div></div><div class="nl l"><div class="nm l nn no np nl nq io nc"/></div></div></a></div></div></div>    
</body>
</html>