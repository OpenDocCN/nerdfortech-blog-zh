<html>
<head>
<title>C# Types [Value, Reference] Explained</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">C#类型[值，引用]解释</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/c-types-value-reference-explained-fc8b9014285d?source=collection_archive---------9-----------------------#2021-03-12">https://medium.com/nerd-for-tech/c-types-value-reference-explained-fc8b9014285d?source=collection_archive---------9-----------------------#2021-03-12</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="d3a3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi jd translated">在 C#中我们可以找到三种不同的类型，值类型、引用类型和指针类型。在本文中，我们将关注引用&amp;值类型。</p><p id="0c56" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">那么什么是引用和值类型呢？</p><figure class="jn jo jp jq fd jr er es paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="er es jm"><img src="../Images/152e0d2611fa7db530cfdfe92b97c196.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TDEmofYpLDmMxiiFOfkvFg.png"/></div></div></figure><h1 id="50c2" class="jy jz hi bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated"><strong class="ak">主要区别</strong></h1><p id="2c23" class="pw-post-body-paragraph if ig hi ih b ii kw ik il im kx io ip iq ky is it iu kz iw ix iy la ja jb jc hb bi translated">值类型和引用类型的主要区别在于它们的赋值。</p><pre class="jn jo jp jq fd lb lc ld le aw lf bi"><span id="3c7b" class="lg jz hi lc b fi lh li l lj lk">int a = 5;<br/>int b = a;<br/>b++;</span></pre><p id="1956" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在上面的例子中，我们将变量“a”的值赋给变量“b”，之后，我们增加 b 的值。</p><p id="6efd" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">b 的值是多少，a 的值是多少？<br/>嗯，你可能知道 b 的值现在是 6，a 的值仍然是 5。</p><p id="eedc" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">其原因是因为在赋值时，我们在通过值赋值的<strong class="ih hj">调用中将值从 a 复制到 b。</strong></p><p id="033c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">但是，是不是一直都是那样的？让我们看看下面的例子:</p><pre class="jn jo jp jq fd lb lc ld le aw lf bi"><span id="b48d" class="lg jz hi lc b fi lh li l lj lk">SampleClass instance = new SampleClass();<br/>instance.age = 45;</span><span id="21e8" class="lg jz hi lc b fi ll li l lj lk">SampleClass second = instance;<br/>second.age = 60;</span><span id="e728" class="lg jz hi lc b fi ll li l lj lk">Console.WriteLine(second.age);<br/>Console.WriteLine(instance.age);</span></pre><p id="9009" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在上面的例子中，两个输出都是 60，原因是类是引用类型，这意味着在我们赋值后它们指向内存中的同一个位置，当我们改变 second 时，实例也会改变。</p></div><div class="ab cl lm ln gp lo" role="separator"><span class="lp bw bk lq lr ls"/><span class="lp bw bk lq lr ls"/><span class="lp bw bk lq lr"/></div><div class="hb hc hd he hf"><h1 id="1b33" class="jy jz hi bd ka kb lt kd ke kf lu kh ki kj lv kl km kn lw kp kq kr lx kt ku kv bi translated">为什么我们会有这个？</h1><p id="bafd" class="pw-post-body-paragraph if ig hi ih b ii kw ik il im kx io ip iq ky is it iu kz iw ix iy la ja jb jc hb bi translated">在我们看到了引用和值类型之后，问题来了。为什么我想要引用类型？为什么我要在内存中创建一个实例作为我的另一个实例？</p><p id="79e2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">假设我们有一个函数，它获取一个未知大小的字符串数组。(数组也是一种引用类型)。</p><p id="07c9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在这种情况下，考虑一下如果数组有 100，000 个值，计算机复制数组的所有元素需要多少时间。</p><pre class="jn jo jp jq fd lb lc ld le aw lf bi"><span id="ae50" class="lg jz hi lc b fi lh li l lj lk">public static void Main(string[] args)<br/>{ <br/>  int[] arr = new int[100000];<br/>  CallMyFunc(arr);<br/>}</span><span id="28b9" class="lg jz hi lc b fi ll li l lj lk">public static void CallMyFunc(int[] a)<br/>{<br/>  Console.WriteLine("Pow!");<br/>}</span></pre><p id="725a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在上面的例子中，如果数组是值类型，那么将所有值复制到“a”参数中会花费很多时间。</p><p id="1f57" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这就是为什么我们既有值类型又有引用类型，当涉及到像整数那样的小尺寸复制时，复制整数值不会花很多时间，因为它只有 4 个字节。</p><p id="8f5f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">但是，在上面的例子中，它必须将 100000 * 4 = 400000 字节复制到一个新参数中(如果数组是值类型)。</p></div><div class="ab cl lm ln gp lo" role="separator"><span class="lp bw bk lq lr ls"/><span class="lp bw bk lq lr ls"/><span class="lp bw bk lq lr"/></div><div class="hb hc hd he hf"><h1 id="c8d9" class="jy jz hi bd ka kb lt kd ke kf lu kh ki kj lv kl km kn lw kp kq kr lx kt ku kv bi translated">如何通过引用调用生成值类型</h1><p id="3937" class="pw-post-body-paragraph if ig hi ih b ii kw ik il im kx io ip iq ky is it iu kz iw ix iy la ja jb jc hb bi translated">让我们假设你有一个名为“Pow”的函数，你希望你的函数通过引用的方式在调用中得到一个整数。</p><p id="b113" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">C#提供了两种方法来做到这一点，<strong class="ih hj"> ref &amp; out。</strong></p><pre class="jn jo jp jq fd lb lc ld le aw lf bi"><span id="ad74" class="lg jz hi lc b fi lh li l lj lk">public static void Main(string[] args)<br/>{<br/>  int a = 5;<br/>  Pow(ref a); //now a value is 6<br/>  Console.WriteLine(a); //prints 6<br/>}</span><span id="5659" class="lg jz hi lc b fi ll li l lj lk">public static void AddToA(ref int b)<br/>{<br/>  b++;<br/>}</span></pre><p id="781f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在上面的例子中，我们使用了<strong class="ih hj"> ref </strong>，通过它，我们也引用了调用函数，这意味着我们获得了地址，通过这样做，我们可以改变参数和调用值。</p><pre class="jn jo jp jq fd lb lc ld le aw lf bi"><span id="7f30" class="lg jz hi lc b fi lh li l lj lk">public static void Main(string[] args)<br/>{<br/>  Pow(out int b);<br/>  Console.WriteLine(b); //prints 5<br/>}</span><span id="b77a" class="lg jz hi lc b fi ll li l lj lk">public static void AddToB(out int c)<br/>{<br/>  c = 5;<br/>}</span></pre><p id="8454" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">out 关键字强制在函数中初始化，这意味着在函数结束后，我们可以确定 b 存储了一个值。因为它强制在函数内部初始化，所以我们可以在主程序的调用中声明变量，正如你在上面看到的。</p><p id="4d0a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果我们没有“c = 5”这一行，就会抛出一个错误，因为我们不能创建一个使用 out 关键字的函数，也不能初始化它得到的值。</p><pre class="jn jo jp jq fd lb lc ld le aw lf bi"><span id="c97b" class="lg jz hi lc b fi lh li l lj lk">public static void Main(string[] args)<br/>{<br/>  int b = 7;<br/>  Pow(out b);<br/>  Console.WriteLine(b); //prints 5<br/>}</span><span id="6787" class="lg jz hi lc b fi ll li l lj lk">public static void AddToB(out int c)<br/>{<br/> c = 5;<br/>}</span></pre><p id="faa0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们也可以使用已经声明的变量和 out 关键字。使用这些关键字，我们可以引用调用者并改变他的值，我们也可以在同一个函数中“返回”多个值。</p></div><div class="ab cl lm ln gp lo" role="separator"><span class="lp bw bk lq lr ls"/><span class="lp bw bk lq lr ls"/><span class="lp bw bk lq lr"/></div><div class="hb hc hd he hf"><h1 id="3e44" class="jy jz hi bd ka kb lt kd ke kf lu kh ki kj lv kl km kn lw kp kq kr lx kt ku kv bi translated">ReferenceEquals 函数</h1><p id="9ad9" class="pw-post-body-paragraph if ig hi ih b ii kw ik il im kx io ip iq ky is it iu kz iw ix iy la ja jb jc hb bi translated">如果要检查两种类型是否指向同一个地址。您可以使用 ReferecneEquals 函数</p><pre class="jn jo jp jq fd lb lc ld le aw lf bi"><span id="a3fc" class="lg jz hi lc b fi lh li l lj lk">SampleClass a = new SampleClass();<br/>SampleClass b = a;</span><span id="968d" class="lg jz hi lc b fi ll li l lj lk">Console.WriteLine(ReferenceEquals(a, b)); //true<br/>Console.WriteLine(ReferenceEquals(a, new SampleClass())); //false</span></pre></div><div class="ab cl lm ln gp lo" role="separator"><span class="lp bw bk lq lr ls"/><span class="lp bw bk lq lr ls"/><span class="lp bw bk lq lr"/></div><div class="hb hc hd he hf"><h1 id="a95d" class="jy jz hi bd ka kb lt kd ke kf lu kh ki kj lv kl km kn lw kp kq kr lx kt ku kv bi translated">为什么字符串是引用类型？</h1><p id="e971" class="pw-post-body-paragraph if ig hi ih b ii kw ik il im kx io ip iq ky is it iu kz iw ix iy la ja jb jc hb bi translated">我们都知道字符串就像值类型一样工作。当我们把一个变量赋给另一个变量，然后我们改变其中一个，并不会导致另一个也改变。</p><p id="dc57" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">喜欢这个例子:</p><pre class="jn jo jp jq fd lb lc ld le aw lf bi"><span id="6cc0" class="lg jz hi lc b fi lh li l lj lk">string a = "Nice Article!";<br/>string b = a;<br/>b += " By Gilad Bar Ilan"; //a still holds "Nice Article!"</span></pre><p id="1064" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">然而，如果我们在改变之前写 ReferenceEquals，我们就会得到 True</p><pre class="jn jo jp jq fd lb lc ld le aw lf bi"><span id="8f8b" class="lg jz hi lc b fi lh li l lj lk">string a = "Nice Article!";<br/>string b = a;<br/>Console.WriteLine(ReferenceEquals(a,b)); //prints true</span></pre><p id="7a9e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这样做的原因是因为每次我们链接一个新的值到一个字符串，这个字符串就会在内存中创建一个新的实例，在我们这样做之后，他就不再与之前的字符串相关了。</p><p id="dc91" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">因为字符串是不可变的，我们看到字符串的行为就像值类型。</p><h2 id="2da9" class="lg jz hi bd ka ly lz ma ke mb mc md ki iq me mf km iu mg mh kq iy mi mj ku mk bi translated"><strong class="ak">如果字符串是可变的</strong></h2><pre class="jn jo jp jq fd lb lc ld le aw lf bi"><span id="2444" class="lg jz hi lc b fi lh li l lj lk">string a = "hello world";<br/>string b = a;<br/>a[0] = 'b';</span></pre><p id="ce75" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">那么上面的代码也必须改变“b”变量。</p><h2 id="7356" class="lg jz hi bd ka ly lz ma ke mb mc md ki iq me mf km iu mg mh kq iy mi mj ku mk bi translated">那么，为什么字符串是引用类型呢？</h2><p id="9b00" class="pw-post-body-paragraph if ig hi ih b ii kw ik il im kx io ip iq ky is it iu kz iw ix iy la ja jb jc hb bi translated">在整个讨论之后出现了一个问题，为什么 string 是一个引用类型？</p><p id="c687" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">嗯，这和我们之前讲过的有关。让我们假设字符串是值类型，在这种情况下，如果我们有一个长度为 100，000 个字符的字符串。</p><p id="70b3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这会使我们的程序运行得非常慢，通过使它成为引用类型，我们可以使我们的程序运行得更快。</p><p id="4847" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">通过将字符串作为引用类型而不是值类型，我们必须做出的唯一让步是字符串是不可变的。</p><h1 id="0d82" class="jy jz hi bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">结构和类</h1><p id="8563" class="pw-post-body-paragraph if ig hi ih b ii kw ik il im kx io ip iq ky is it iu kz iw ix iy la ja jb jc hb bi translated">结构和类是值类型和引用类型的很好的例子。</p><p id="58a9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">结构是值类型，类是引用类型。</p><p id="6ffd" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">当我们谈论像 KeyValuePair 结构这样的小块数据时，我们宁愿使用 struct，因为复制这种 struct 并不慢。</p><p id="b17f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">每当我们谈到需要一段时间才能复制的大块数据时，我们宁愿使用一个类，并通过引用进行复制。</p></div><div class="ab cl lm ln gp lo" role="separator"><span class="lp bw bk lq lr ls"/><span class="lp bw bk lq lr ls"/><span class="lp bw bk lq lr"/></div><div class="hb hc hd he hf"><p id="f382" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">恭喜你，现在你知道引用和值类型的区别了！</p></div></div>    
</body>
</html>