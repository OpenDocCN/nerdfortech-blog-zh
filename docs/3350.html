<html>
<head>
<title>Build the Forest in Python Series: AVL Tree</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">构建Python系列中的森林:AVL树</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/build-the-forest-in-python-series-avl-tree-73f09abc0e1?source=collection_archive---------36-----------------------#2021-06-06">https://medium.com/nerd-for-tech/build-the-forest-in-python-series-avl-tree-73f09abc0e1?source=collection_archive---------36-----------------------#2021-06-06</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="18e2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在<a class="ae jd" href="https://shunsvineyard.info/2021/04/30/build-the-forest-in-python-series-red-black-tree/" rel="noopener ugc nofollow" target="_blank">红黑树</a>的讨论之后，本文将实现自平衡二叉查找树的另一个变种:AVL树。</p><h1 id="8521" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">项目设置</h1><p id="5bda" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">遵循与<a class="ae jd" href="https://shunsvineyard.info/build-the-forest-series/" rel="noopener ugc nofollow" target="_blank">构建森林系列</a>中其他文章相同的风格和假设，实现假设为Python 3.9或更新版本。本文为我们的项目添加了两个模块:<em class="kh"> avl_tree.py </em>用于avl树实现，以及<em class="kh"> test_avl_tree.py </em>用于其单元测试。添加这两个文件后，我们的项目布局如下:</p><pre class="ki kj kk kl fd km kn ko kp aw kq bi"><span id="15eb" class="kr jf hi kn b fi ks kt l ku kv">forest-python<br/>├── forest<br/>│   ├── __init__.py<br/>│   ├── binary_trees<br/>│   │   ├── __init__.py<br/>│   │   ├── avl_tree.py<br/>│   │   ├── binary_search_tree.py<br/>│   │   ├── double_threaded_binary_tree.py<br/>│   │   ├── red_black_tree.py<br/>│   │   ├── single_threaded_binary_trees.py<br/>│   │   └── traversal.py<br/>│   └── tree_exceptions.py<br/>└── tests<br/>    ├── __init__.py<br/>    ├── conftest.py<br/>    ├── test_avl_tree.py<br/>    ├── test_binary_search_tree.py<br/>    ├── test_double_threaded_binary_tree.py<br/>    ├── test_red_black_tree.py<br/>    ├── test_single_threaded_binary_trees.py<br/>    └── test_traversal.py</span></pre><p id="a0e4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">(完整代码可从<a class="ae jd" href="https://github.com/shunsvineyard/forest-python" rel="noopener ugc nofollow" target="_blank"> forest-python </a>获得)</p><h1 id="d0cb" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">什么是AVL树？</h1><p id="3f48" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">AVL树(以发明家阿德尔森-维尔斯基和兰迪斯命名)是一种自我平衡的二叉查找树。除了二进制搜索树属性之外，AVL树维护AVL树属性以保持其平衡:</p><ul class=""><li id="4a2b" class="kw kx hi ih b ii ij im in iq ky iu kz iy la jc lb lc ld le bi translated">对于AVL树中的每个节点，其左侧子树和右侧子树的高度最多相差一。</li></ul><p id="d4fe" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">该属性也称为<strong class="ih hj">平衡因子</strong>，可以改写为以下公式:</p><figure class="ki kj kk kl fd lg er es paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="er es lf"><img src="../Images/2a07fb2b26f4d459f12e21e4385b768c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Y9Cvh-hIckTsxBNB0wDjWg.png"/></div></div></figure><p id="2853" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果一个节点的平衡因子&gt; 0，我们称之为<strong class="ih hj">左重</strong>。如果一个节点的平衡因子&lt;为0，我们称之为<strong class="ih hj">右重</strong>。如果一个节点的平衡因子= 0，称为<strong class="ih hj">平衡</strong>。</p><p id="fb27" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">(注意，有人把平衡因子定义为它的右子树的高度——它的左子树的高度。在这种情况下，左重成为节点的平衡因子&lt; 0, whereas right-heavy happens when a node’s balance factor &gt; 0。然而，无论使用哪种定义，AVL树的概念都是相同的。)</p><p id="7293" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">下图显示了一个典型的AVL树。</p><figure class="ki kj kk kl fd lg er es paragraph-image"><div class="er es ln"><img src="../Images/6aaa10569d92c96174b0958b89fc96ae.png" data-original-src="https://miro.medium.com/v2/resize:fit:962/format:webp/0*Vy4PDMnLlD7I_rD_.png"/></div></figure><p id="327c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在上图中，BF表示一个节点的平衡因子。节点下的数字是节点的高度。如果节点为空，即<em class="kh"> None </em>，则其高度为-1。这种方式使得计算节点的平衡因子更加容易。</p><h1 id="14eb" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">构建AVL树</h1><p id="858d" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">本节将介绍AVL树的实现，以及实现选择背后的一些想法。</p><h1 id="26c9" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">结节</h1><p id="1ab2" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">我们不是每次需要时都计算节点的高度，而是将高度存储在每个节点中。因此，该节点的结构比二叉查找树节点多一个字段。</p><figure class="ki kj kk kl fd lg er es paragraph-image"><div class="er es lo"><img src="../Images/c1b89c31786308b72fe96a4780f17305.png" data-original-src="https://miro.medium.com/v2/resize:fit:564/format:webp/0*Xk8v06sp86wilKXq.png"/></div></figure><p id="6f7f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">存储高度节省了计算时间，因此我们不需要每次检查平衡系数时都计算高度。但是，这是有代价的——当AVL树被修改时，比如插入一个节点或者删除一个节点，我们需要保持高度是最新的。关于高度更新的更多细节将在插入和删除部分提供。</p><p id="c2c2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">像其他二叉树节点一样，我们利用<a class="ae jd" href="https://www.python.org/dev/peps/pep-0557/" rel="noopener ugc nofollow" target="_blank">数据类</a>来定义AVL树节点。</p><pre class="ki kj kk kl fd km kn ko kp aw kq bi"><span id="234d" class="kr jf hi kn b fi ks kt l ku kv">from dataclasses import dataclass<br/><br/>@dataclass<br/>class Node:<br/>    """AVL Tree node definition."""<br/><br/>    key: Any<br/>    data: Any<br/>    left: Optional["Node"] = None<br/>    right: Optional["Node"] = None<br/>    parent: Optional["Node"] = None<br/>    height: int = 0</span></pre><h1 id="19e6" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">课程概述</h1><p id="f985" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">像<a class="ae jd" href="https://shunsvineyard.info/build-the-forest-series/" rel="noopener ugc nofollow" target="_blank">构建森林</a>项目中的其他类型的二叉树一样，AVL tree类也有类似的功能。</p><pre class="ki kj kk kl fd km kn ko kp aw kq bi"><span id="68dc" class="kr jf hi kn b fi ks kt l ku kv">class AVLTree:<br/><br/>    def __init__(self) -&gt; None:<br/>        self.root: Optional[Node] = None<br/><br/>    def __repr__(self) -&gt; str:<br/>        """Provie the tree representation to visualize its layout."""<br/>        if self.root:<br/>            return (<br/>                f"{type(self)}, root={self.root}, "<br/>                f"tree_height={str(self.get_height(self.root))}"<br/>            )<br/>        return "empty tree"<br/><br/>    def search(self, key: Any) -&gt; Optional[Node]:<br/>        …<br/><br/>    def insert(self, key: Any, data: Any) -&gt; None:<br/>        …<br/><br/>    def delete(self, key: Any) -&gt; None:<br/>        …<br/><br/>    @staticmethod<br/>    def get_leftmost(node: Node) -&gt; Node:<br/>        …<br/><br/>    @staticmethod<br/>    def get_rightmost(node: Node) -&gt; Node:<br/>        …<br/><br/>    @staticmethod<br/>    def get_successor(node: Node) -&gt; Optional[Node]:<br/>        …<br/><br/>    @staticmethod<br/>    def get_predecessor(node: Node) -&gt; Optional[Node]:<br/>        …<br/><br/>    @staticmethod<br/>    def get_height(node: Optional[Node]) -&gt; int:<br/>        …<br/><br/>    def _get_balance_factor(self, node: Optional[Node]) -&gt; int:<br/>        …<br/><br/>    def _left_rotate(self, node_x: Node) -&gt; None:<br/>        …<br/><br/>    def _right_rotate(self, node_x: Node) -&gt; None:<br/>        …<br/><br/>    def _insert_fixup(self, new_node: Node) -&gt; None:<br/>        …<br/><br/>    def _transplant(self, deleting_node: Node, replacing_node: Optional[Node]) -&gt; None:<br/>        …<br/><br/>    def _delete_no_child(self, deleting_node: Node) -&gt; None:<br/>        …<br/><br/>    def _delete_one_child(self, deleting_node: Node) -&gt; None:<br/>        …<br/><br/>    def _delete_fixup(self, fixing_node: Node) -&gt; None:<br/>        …</span></pre><p id="e6a1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们可以像常规二叉查找树一样精确地实现AVL树的大部分功能，例如搜索和大部分辅助功能。我们也可以使用<a class="ae jd" href="https://shunsvineyard.info/2021/03/17/build-the-forest-in-python-series-binary-tree-traversal/" rel="noopener ugc nofollow" target="_blank">二叉树遍历</a>中的遍历函数来遍历AVL树。</p><p id="2d22" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">插入和删除是可能导致AVL树不平衡的两种操作。因此，<em class="kh"> AVLTree </em>类有帮助保持树平衡的方法，包括<em class="kh"> _left_rotate() </em>、<em class="kh"> _right_rotate() </em>、<em class="kh"> _insert_fixup() </em>和<em class="kh"> _delete_fixup() </em>。由于这些助手方法主要保持AVL树的平衡，我们将它们定义为私有函数，对客户端代码透明。</p><h1 id="627c" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">旋转</h1><p id="7a2f" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">插入或删除后恢复违反的AVL树属性的方法是旋转(类似于<a class="ae jd" href="https://shunsvineyard.info/2021/04/30/build-the-forest-in-python-series-red-black-tree/#6-rotations" rel="noopener ugc nofollow" target="_blank">红黑树:旋转</a>)。</p><p id="4cfd" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">下图演示了AVL树属性可能被破坏的四种情况:左-左、左-右、右-左和右-右。</p><figure class="ki kj kk kl fd lg er es paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="er es lp"><img src="../Images/7366f72fc0f1579ea8351b151700aacc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*hcfiOw5qTughNPHW.png"/></div></div></figure><p id="3328" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">当我们处理一个不平衡的AVL树时，我们总是从最底层的不平衡节点开始(即，节点要么是<em class="kh"> BF &gt; 1 </em>要么是<em class="kh"> BF &lt; -1 </em>)。例如，上图中的节点23是最底部的不平衡节点。然后检查其具有较高高度的<strong class="ih hj">子节点的平衡系数。如果最底层的不平衡节点是左重的(即BF &gt; 0)，而其高度较高的子节点是左重的，则为左-左情况(上图中最左边的情况)。如果身高较高的孩子的平衡系数为右重(即BF &lt; 0)，则为左右情况(上图中第二个最左边的情况)。图中的其他情况(左右和左右)与左右情况和左右情况对称。</strong></p><p id="a136" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">下面的小节展示了旋转是如何重新平衡不平衡的。</p><h2 id="a4b7" class="kr jf hi bd jg lq lr ls jk lt lu lv jo iq lw lx js iu ly lz jw iy ma mb ka mc bi translated">右旋转(左-左情况)</h2><p id="77d0" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">对于左-左的情况，我们在最底部的不平衡节点(本例中的节点23)上执行右旋转。旋转后，节点17成为节点23的父节点。此外，节点17和节点23的高度和平衡因子在旋转后都发生了变化。</p><figure class="ki kj kk kl fd lg er es paragraph-image"><div class="er es md"><img src="../Images/ae0b4703d0b0f7105a0dfaa6231e455e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1382/format:webp/0*iQzgIgPZORdbjuxs.png"/></div></figure><h2 id="1bae" class="kr jf hi bd jg lq lr ls jk lt lu lv jo iq lw lx js iu ly lz jw iy ma mb ka mc bi translated">左右旋转(左右情况)</h2><p id="2508" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">如果最底部的不平衡节点是左重的，但是它的子节点(具有更高的高度)是右重的，我们首先在子节点(本例中为节点17)上执行左旋转，然后在最底部的不平衡节点(节点23)上执行右旋转。</p><figure class="ki kj kk kl fd lg er es paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="er es me"><img src="../Images/777cf9639df61328f93e734a830232b9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*LeMchKWDrtovUikk.png"/></div></div></figure><p id="16f9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">请注意，只有涉及旋转的节点才会更改其平衡系数和高度。例如，向左旋转后，节点17和节点21会更改其高度和平衡因子(以黄色高亮显示)。向右旋转后，只有节点21和节点23更改其高度和平衡因子(绿色的高度)。</p><h2 id="927d" class="kr jf hi bd jg lq lr ls jk lt lu lv jo iq lw lx js iu ly lz jw iy ma mb ka mc bi translated">左右旋转(左右旋转)</h2><p id="8639" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">左右情况与左右情况对称。因此，我们先执行右旋转，然后执行左旋转。</p><figure class="ki kj kk kl fd lg er es paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="er es mf"><img src="../Images/494091feb275c8deaf86ae01ac2cd9fe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*QxMJP9w3qjxYT2-y.png"/></div></div></figure><h2 id="0b79" class="kr jf hi bd jg lq lr ls jk lt lu lv jo iq lw lx js iu ly lz jw iy ma mb ka mc bi translated">向左旋转(右-右情况)</h2><p id="1bc7" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">右-右的情况与左-左的情况对称。所以我们可以进行左旋转使其平衡。</p><figure class="ki kj kk kl fd lg er es paragraph-image"><div class="er es mg"><img src="../Images/a2a674b02074ca4a4339a6d5c70882e0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1232/format:webp/0*0H-9I2WZnuAFr9Z9.png"/></div></figure><h2 id="b938" class="kr jf hi bd jg lq lr ls jk lt lu lv jo iq lw lx js iu ly lz jw iy ma mb ka mc bi translated">摘要</h2><p id="9e6c" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">下表总结了不平衡情况及其解决方案。</p><figure class="ki kj kk kl fd lg er es paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="er es mh"><img src="../Images/2df9b6115604a901511d011a72d2d268.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Nwz8soVrXhjlput5bSOi2w.png"/></div></div></figure><h1 id="63ee" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">插入</h1><p id="73e8" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">在AVL树中插入有一个实质性的效果:更新高度。因此，当我们将一个节点插入AVL树时，新节点可能会改变树的高度，从而违反AVL树属性。当这种情况发生时，我们执行特定的旋转来重新平衡树。</p><p id="2bd4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在实现插入函数之前，我们需要理解插入是如何改变高度的。首先，注意要插入的新节点在插入后必须成为叶节点。因此，新节点的高度必须为0，其平衡因子也为0。此外，如果新节点的父节点在新节点插入之前有一个子节点，则父节点和整个树的高度保持不变:没有高度变化，没有AVL-tree-property冲突。</p><figure class="ki kj kk kl fd lg er es paragraph-image"><div class="er es mi"><img src="../Images/ce6aa71fe2cd6b2b6e434f8db853bdae.png" data-original-src="https://miro.medium.com/v2/resize:fit:1082/format:webp/0*zp3qFgotg_F1eKIC.png"/></div></figure><p id="4b54" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">第二，只有当新节点的父节点在插入之前没有子节点时，高度才会发生变化。在这种情况下，我们将新节点的祖先的高度一直更新到根节点(如下图所示)，只有新节点的祖先有高度更新。当高度改变时，这意味着可能会发生潜在的AVL树属性冲突。</p><figure class="ki kj kk kl fd lg er es paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="er es mj"><img src="../Images/65aa6c1e2ab4f184e1cbd3c483b7d188.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*3oGcg18G68Apw7x8.png"/></div></div></figure><p id="9336" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">(上图不违反AVL-tree-property。然而，我们将在以下部分处理AVL树在插入后变得不平衡的情况。)</p><p id="873a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">插入算法由常规的二叉查找树插入算法修改而来。</p><ol class=""><li id="121b" class="kw kx hi ih b ii ij im in iq ky iu kz iy la jc mk lc ld le bi translated">以与二叉查找树插入相同的方式插入高度为0的新节点:通过从根开始遍历树并沿途将新节点的键与每个节点的键进行比较，找到插入新节点的正确位置(即新节点的父节点)。</li><li id="8a41" class="kw kx hi ih b ii ml im mm iq mn iu mo iy mp jc mk lc ld le bi translated">更新高度，并通过从新节点追溯到根节点来检查违反的AVL-tree-property是否发生。在返回到根的过程中，如果需要的话，在途中更新每个节点的高度。如果我们发现一个不平衡的节点，执行一定的旋转来平衡它。旋转后，插入结束。如果没有找到不平衡的节点，则插入在到达根节点并更新其高度后完成。</li></ol><pre class="ki kj kk kl fd km kn ko kp aw kq bi"><span id="9967" class="kr jf hi kn b fi ks kt l ku kv">def insert(self, key: Any, data: Any) -&gt; None:<br/>    new_node = Node(key=key, data=data)<br/>    parent: Optional[Node] = None<br/>    current: Optional[Node] = self.root<br/>    while current:<br/>        parent = current<br/>        if new_node.key &lt; current.key:<br/>            current = current.left<br/>        elif new_node.key &gt; current.key:<br/>            current = current.right<br/>        else:<br/>            raise tree_exceptions.DuplicateKeyError(key=new_node.key)<br/>    new_node.parent = parent<br/>    # If the tree is empty, set the new node to be the root.<br/>    if parent is None:<br/>        self.root = new_node<br/>    else:<br/>        if new_node.key &lt; parent.key:<br/>            parent.left = new_node<br/>        else:<br/>            parent.right = new_node<br/><br/>        # After the insertion, fix the broken AVL-tree-property.<br/>        # If the parent has two children after inserting the new node,<br/>        # it means the parent had one child before the insertion.<br/>        # In this case, neither AVL-tree property breaks nor<br/>        # heights update requires.<br/>        if not (parent.left and parent.right):<br/>            self._insert_fixup(new_node)</span></pre><h2 id="811e" class="kr jf hi bd jg lq lr ls jk lt lu lv jo iq lw lx js iu ly lz jw iy ma mb ka mc bi translated">固定</h2><p id="9bcd" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">正如轮换部分提到的，有四种潜在的不平衡情况。并且我们执行特定的旋转来恢复AVL树属性。在我们修正了AVL树属性之后，AVL树就变得平衡了。不需要继续追踪祖先的平衡因子。以下小节描述了每种情况下的修复。</p><p id="3565" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">左-左格</p><figure class="ki kj kk kl fd lg er es paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="er es mq"><img src="../Images/fec9444cd187b83b78b29a3074686635.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*i2K5mKbn0TaoIrHo.png"/></div></div></figure><p id="6fff" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在上图中，我们添加了节点19。插入后，我们开始检查从节点17开始的节点19的祖先的平衡因子。然后，我们发现节点37的平衡因子不平衡且左倾。我们还需要检查其具有更高高度的子对象，以确定要执行哪个旋转。在插入的情况下，具有更高高度的子节点必须出现在包含新节点的路径中，即在这种情况下的节点23，因为节点23的平衡因子在插入后是1。我们认为这是一个左-左病例。</p><p id="4d26" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">所以我们在节点37上执行右旋转。右旋转后，节点23成为新的根，节点37成为节点23的右子节点。请注意，只有参与旋转的节点的高度和平衡系数会发生变化。所以，在这种情况下，只有节点23和节点37有高度，平衡因子改变了。</p><p id="02eb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">为什么不需要在旋转后继续检查祖先的平衡系数？</strong></p><p id="7c48" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在插入之前，节点37的高度是2，节点23的高度是1。插入后，节点37的高度变为3，节点23的高度变为2。然后我们进行了轮换。旋转后，节点23占据了节点37的原始位置，节点23的高度变为2，节点37的高度变为1。因此，相同位置的高度保持不变，即根(节点37)在插入之前具有高度2；旋转后，根(节点23)的高度仍为2。换句话说，如果节点37在旋转之前有一个父节点(比如说<em class="kh"> x </em>，那么在旋转之后，<em class="kh"> x </em>的左子节点就变成了节点23，但是x的高度不受影响。所以，我们不需要在旋转之后继续检查x的祖先的高度。</p><p id="ef04" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">左右格</p><figure class="ki kj kk kl fd lg er es paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="er es mr"><img src="../Images/1bf57bdab956653474757c69c9d3f414.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*veAq_PQL-KTGY9-M.png"/></div></div></figure><p id="6b50" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在我们通过检查最底部的不平衡节点(节点37)及其具有更高高度的子节点(节点23)的平衡因子来识别这是左右情况之后，我们在节点23上执行向左旋转，因此它变成了左右情况。然后，我们在不平衡的节点(节点37)上执行右旋转。之后，我们恢复被侵犯的AVL树属性。</p><p id="f48f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">左右格</p><figure class="ki kj kk kl fd lg er es paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="er es mr"><img src="../Images/9e529e594799498d971666af2163c96d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*i3Ya1hTWsiF4k0Xr.png"/></div></div></figure><p id="bb90" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这种情况与左右情况是对称的，所以我们在不平衡节点(节点37)的右子节点(节点43)上执行右，所以它变成了右-右情况。然后，我们在不平衡节点(节点37)上执行向左旋转。之后，我们修复被违反的AVL树属性。</p><p id="7baf" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">右-右格</p><figure class="ki kj kk kl fd lg er es paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="er es mq"><img src="../Images/fc2dbb8da12908d044e69d0a03960e41.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*Of-n2X_wjORRvdxu.png"/></div></div></figure><p id="d3ac" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">右-右的情况与左-左的情况是对称的，所以我们可以通过执行左旋转来恢复它的AVL-tree属性。</p><p id="2480" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在修复分析之后，我们可以像下面这样实现<em class="kh"> _insert_fixup </em>函数。注意，我们总是在沿着树向上走的时候和旋转之前更新节点的高度。</p><pre class="ki kj kk kl fd km kn ko kp aw kq bi"><span id="6fda" class="kr jf hi kn b fi ks kt l ku kv">def _insert_fixup(self, new_node: Node) -&gt; None:<br/>    parent = new_node.parent<br/><br/>    while parent:<br/>        parent.height = 1 + max(<br/>            self.get_height(parent.left), self.get_height(parent.right)<br/>        )<br/>        grandparent = parent.parent<br/>        # grandparent is unbalanced<br/>        if grandparent:<br/>            if self._get_balance_factor(grandparent) &gt; 1:<br/>                # Case Left-Left<br/>                if self._get_balance_factor(parent) &gt;= 0:<br/>                    self._right_rotate(grandparent)<br/>                # Case Left-Right<br/>                elif self._get_balance_factor(parent) &lt; 0:<br/>                    self._left_rotate(parent)<br/>                    self._right_rotate(grandparent)<br/>                # Since the fixup does not affect the ancestor of the unbalanced<br/>                # node, exit the loop to complete the fixup process.<br/>                break<br/>            elif self._get_balance_factor(grandparent) &lt; -1:<br/>                # Case Right-Right<br/>                if self._get_balance_factor(parent) &lt;= 0:<br/>                    self._left_rotate(grandparent)<br/>                # Case Right-Left<br/>                elif self._get_balance_factor(parent) &gt; 0:<br/>                    self._right_rotate(parent)<br/>                    self._left_rotate(grandparent)<br/>                # Since the fixup does not affect the ancestor of the unbalanced<br/>                # node, exit the loop to complete the fixup process.<br/>                break<br/>        parent = parent.parent</span></pre><h1 id="f888" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">搜索</h1><p id="f3d9" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">搜索功能与<a class="ae jd" href="https://shunsvineyard.info/2021/03/13/build-the-forest-in-python-series-binary-search-tree/#8-search" rel="noopener ugc nofollow" target="_blank">二叉查找树:搜索</a>相同。</p><h1 id="9f9c" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">删除</h1><p id="c4fd" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">AVL树删除的基本思想类似于常规二叉查找树。要删除的节点有三种情况:没有子节点、只有一个子节点和两个子节点。我们也使用同样的<em class="kh">移植</em>方法，将<em class="kh">删除节点</em>的子树替换为<em class="kh">替换节点</em>的子树。</p><p id="be4a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">移植</strong></p><p id="4e67" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="kh">移植</em>方法与<a class="ae jd" href="https://shunsvineyard.info/2021/03/13/build-the-forest-in-python-series-binary-search-tree/#9-delete" rel="noopener ugc nofollow" target="_blank">二叉查找树相同:删除</a>。</p><pre class="ki kj kk kl fd km kn ko kp aw kq bi"><span id="763b" class="kr jf hi kn b fi ks kt l ku kv">def _transplant(self, deleting_node: Node, replacing_node: Optional[Node]) -&gt; None:<br/>    if deleting_node.parent is None:<br/>        self.root = replacing_node<br/>    elif deleting_node == deleting_node.parent.left:<br/>        deleting_node.parent.left = replacing_node<br/>    else:<br/>        deleting_node.parent.right = replacing_node<br/><br/>    if replacing_node:<br/>        replacing_node.parent = deleting_node.parent</span></pre><p id="9240" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">与插入类似，AVL树删除可能会更新树的高度，并可能违反AVL树属性，因此我们需要检查AVL树是否变得不平衡，并在删除后修复它。</p><p id="cc2a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">整个删除过程类似于常规的二叉查找树，只是做了一些修改。</p><ol class=""><li id="f276" class="kw kx hi ih b ii ij im in iq ky iu kz iy la jc mk lc ld le bi translated">找到要删除的节点(<em class="kh"> deleting_node </em>)。</li><li id="22b0" class="kw kx hi ih b ii ml im mm iq mn iu mo iy mp jc mk lc ld le bi translated">如果<em class="kh"> deleting_node </em>没有子节点，使用<em class="kh">移植</em>方法将<em class="kh"> deleting_node </em>替换为<em class="kh"> None </em>。然后，执行修复操作。</li><li id="f957" class="kw kx hi ih b ii ml im mm iq mn iu mo iy mp jc mk lc ld le bi translated">如果<em class="kh"> deleting_node </em>只有一个子节点，使用<em class="kh">移植</em>方法替换只有一个子节点的<em class="kh"> deleting_node </em>。然后执行修复操作。</li><li id="71c4" class="kw kx hi ih b ii ml im mm iq mn iu mo iy mp jc mk lc ld le bi translated">如果<em class="kh">删除节点</em>有两个子节点，找到<em class="kh">删除节点</em>的后继节点作为<em class="kh">替换节点</em>。然后，将<em class="kh"> deleting_node </em>的键和数据替换为<em class="kh"> replacing_node </em>的键和数据，这样<em class="kh"> deleting_node </em>被<em class="kh"> replacing_node </em>替换，但保持其原来的平衡因子和高度(即没有高度和平衡因子的改变意味着没有AVL-tree-property违例)。之后删除<em class="kh"> replacing_node </em>，与步骤2(无子节点)或步骤3(只有一个子节点)相同。</li></ol><p id="7ab7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为了使实现更加清晰，我们定义了<em class="kh"> _delete_no_child </em>方法用于待删除节点没有子节点的情况，而<em class="kh"> _delete_one_child </em>方法用于待删除节点只有一个子节点的情况。如果删除的节点有两个子节点，我们可以相应地重用<em class="kh"> _delete_no_child </em>和<em class="kh"> _delete_one_child </em>。此外，由于要删除的节点有两个子节点，分别使用<em class="kh"> _delete_no_child </em>和<em class="kh"> _delete_one_child </em>，所以只有这两个方法需要调用<em class="kh"> _delete_fixup </em>函数来修复不平衡的节点。因此，我们可以如下实现<em class="kh"> delete </em>、<em class="kh"> _delete_no_child </em>和<em class="kh"> _delete_one_child </em>函数。</p><pre class="ki kj kk kl fd km kn ko kp aw kq bi"><span id="19bd" class="kr jf hi kn b fi ks kt l ku kv">def delete(self, key: Any) -&gt; None:<br/>    if self.root and (deleting_node := self.search(key=key)):<br/>        # Case: no child<br/>        if (deleting_node.left is None) and (deleting_node.right is None):<br/>            self._delete_no_child(deleting_node=deleting_node)<br/>        # Case: Two children<br/>        elif deleting_node.left and deleting_node.right:<br/>            replacing_node = self.get_leftmost(node=deleting_node.right)<br/>            # Replace the deleting node with the replacing node,<br/>            # but keep the replacing node in place.<br/>            deleting_node.key = replacing_node.key<br/>            deleting_node.data = replacing_node.data<br/>            if replacing_node.right:  # The replacing node cannot have left child.<br/>                self._delete_one_child(deleting_node=replacing_node)<br/>            else:<br/>                self._delete_no_child(deleting_node=replacing_node)<br/>        # Case: one child<br/>        else:<br/>            self._delete_one_child(deleting_node=deleting_node)<br/><br/>def _delete_no_child(self, deleting_node: Node) -&gt; None:<br/>    parent = deleting_node.parent<br/>    self._transplant(deleting_node=deleting_node, replacing_node=None)<br/>    if parent:<br/>        self._delete_fixup(fixing_node=parent)<br/><br/>def _delete_one_child(self, deleting_node: Node) -&gt; None:<br/>    parent = deleting_node.parent<br/>    replacing_node = (<br/>        deleting_node.right if deleting_node.right else deleting_node.left<br/>    )<br/>    self._transplant(deleting_node=deleting_node, replacing_node=replacing_node)<br/>    if parent:<br/>        self._delete_fixup(fixing_node=parent)</span></pre><h2 id="ee40" class="kr jf hi bd jg lq lr ls jk lt lu lv jo iq lw lx js iu ly lz jw iy ma mb ka mc bi translated">固定</h2><p id="4b74" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">我们知道删除操作可能会改变高度并违反AVL-tree-property。像插入一样，有四种潜在的不平衡情况。并且我们执行特定的旋转来恢复AVL树属性。我们还从最底层的不平衡节点开始修复过程。最底层的不平衡节点必须是要删除的节点的祖先之一。然而，与插入修正不同，不平衡平衡因子可能会在我们执行旋转的节点上传播。因此，在我们恢复最底层的不平衡节点后，我们需要检查它的父节点。如果它的父代变得不平衡，修复它。重复这个过程，直到我们到达根，根也是平衡的。</p><p id="eaee" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">没有孩子</p><p id="0c25" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">就像我们在rotations部分提到的，有四种情况会违反AVL-tree-property。下图显示了这四种情况，以及如果要删除的节点没有子节点，如何恢复它们的平衡因子。</p><figure class="ki kj kk kl fd lg er es paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="er es ms"><img src="../Images/ce2bfec46086b354cc1fb52e6630ea83.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*UizgbP4q_PFe30BW.png"/></div></div></figure><p id="6290" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">一个孩子</p><p id="2945" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">下面两张图片演示了这四种情况。</p><p id="18f6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">不平衡节点偏左</strong></p><figure class="ki kj kk kl fd lg er es paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="er es mq"><img src="../Images/6b995bdc8469c385edaa436ce3d0f097.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*sap_tzxoAvuCrCXx.png"/></div></div></figure><p id="ac59" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">不平衡节点偏右</strong></p><figure class="ki kj kk kl fd lg er es paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="er es mq"><img src="../Images/06103123891b85e34fe433fcef0d4472.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*5ylXVolHxIfK6rHp.png"/></div></div></figure><p id="3017" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">两个孩子</p><p id="a992" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">像其他二叉树的删除一样，我们可以将两个子案例看作两个子案例:替换节点是<em class="kh"> deleting_node </em>的直接子节点，而<em class="kh"> replacing_node </em>是deleting_node的最左边的节点。在任何一种情况下，我们都可以通过将<em class="kh"> deleting_node </em>替换为<em class="kh"> replacing_node </em>来将两个孩子的情况转换为非孩子的情况或一个孩子的情况，但保持原来的高度和平衡因子。这样做，我们不会改变高度和平衡系数。之后，我们删除<em class="kh">替换_节点</em>，它就变成了无子案例或者有子案例。下图显示了两个孩子删除是如何工作的，以及如何修复它的不平衡。</p><p id="6346" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">替换节点是删除节点的直接子节点</strong></p><figure class="ki kj kk kl fd lg er es paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="er es mt"><img src="../Images/0e1652aeb546b52eef9a8ccbf1ea44dc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*83s-4hwTPFrZVhFT.png"/></div></div></figure><p id="c390" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">替换节点是删除节点最左边的节点</strong></p><figure class="ki kj kk kl fd lg er es paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="er es mu"><img src="../Images/17e768bdb0d301281abddc257d6d57d3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*76jd1Kn-jmKRHVcW.png"/></div></div></figure><p id="dcfc" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">完整修复操作的实现如下。类似于插入，我们在沿着树向上走的时候更新节点的高度。</p><pre class="ki kj kk kl fd km kn ko kp aw kq bi"><span id="8bdf" class="kr jf hi kn b fi ks kt l ku kv">def _delete_fixup(self, fixing_node: Node) -&gt; None:<br/>    while fixing_node:<br/>        fixing_node.height = 1 + max(<br/>            self.get_height(fixing_node.left), self.get_height(fixing_node.right)<br/>        )<br/><br/>        if self._get_balance_factor(fixing_node) &gt; 1:<br/>            # Case Left-Left<br/>            if self._get_balance_factor(fixing_node.left) &gt;= 0:<br/>                self._right_rotate(fixing_node)<br/>            # Case Left-Right<br/>            elif self._get_balance_factor(fixing_node.left) &lt; 0:<br/>                # The fixing node's left child cannot be empty<br/>                self._left_rotate(fixing_node.left)<br/>                self._right_rotate(fixing_node)<br/>        elif self._get_balance_factor(fixing_node) &lt; -1:<br/>            # Case Right-Right<br/>            if self._get_balance_factor(fixing_node.right) &lt;= 0:<br/>                self._left_rotate(fixing_node)<br/>            # Case Right-Left<br/>            elif self._get_balance_factor(fixing_node.right) &gt; 0:<br/>                # The fixing node's right child cannot be empty<br/>                self._right_rotate(fixing_node.right)<br/>                self._left_rotate(fixing_node)<br/><br/>        fixing_node = fixing_node.parent</span></pre><h1 id="b7c4" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">辅助功能</h1><p id="d31f" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">辅助功能，如获取最左边的节点和获取节点的后继者，与<a class="ae jd" href="https://shunsvineyard.info/2021/03/13/build-the-forest-in-python-series-binary-search-tree/#13-auxiliary-functions" rel="noopener ugc nofollow" target="_blank">二叉查找树:辅助功能</a>相同，实现可在<a class="ae jd" href="https://github.com/shunsvineyard/forest-python/blob/main/forest/binary_trees/avl_tree.py" rel="noopener ugc nofollow" target="_blank"> Github库</a>获得。唯一不同于二叉查找树的辅助功能是获取高度的功能。</p><h2 id="1afd" class="kr jf hi bd jg lq lr ls jk lt lu lv jo iq lw lx js iu ly lz jw iy ma mb ka mc bi translated">获得高度</h2><p id="c11d" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">因为每个节点都存储了它的高度，所以获取节点的高度变得非常简单:只需返回高度。</p><pre class="ki kj kk kl fd km kn ko kp aw kq bi"><span id="7ba7" class="kr jf hi kn b fi ks kt l ku kv">@staticmethod<br/>def get_height(node: Optional[Node]) -&gt; int:<br/>    if node:<br/>        return node.height<br/>    # None has height -1<br/>    return -1</span></pre><h1 id="5aca" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">横越</h1><p id="443a" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">尽管AVL树节点比正常的二叉查找树节点多了一个字段(即<em class="kh">高度</em>，我们仍然可以使用我们在<a class="ae jd" href="https://shunsvineyard.info/2021/03/17/build-the-forest-in-python-series-binary-tree-traversal/" rel="noopener ugc nofollow" target="_blank">二叉树遍历</a>中所做的精确实现来遍历AVL树。我们需要做的唯一修改是添加AVL树作为支持的类型。</p><pre class="ki kj kk kl fd km kn ko kp aw kq bi"><span id="8a8e" class="kr jf hi kn b fi ks kt l ku kv"># Alisa for the supported node types. For type checking.<br/>SupportedNode = Union[None, binary_search_tree.Node, avl_tree.Node]<br/><br/>SupportedTree = Union[binary_search_tree.BinarySearchTree, avl_tree.AVLTree]<br/>"""Alisa for the supported tree types. For type checking."""</span></pre><p id="6ea1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">(完整源代码见<a class="ae jd" href="https://github.com/shunsvineyard/forest-python/blob/main/forest/binary_trees/traversal.py" rel="noopener ugc nofollow" target="_blank"> traversal.py </a>)</p><p id="bda0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">支持的类型用于类型检查，正如我们在<a class="ae jd" href="https://shunsvineyard.info/2021/03/17/build-the-forest-in-python-series-binary-tree-traversal/#1-function-interface" rel="noopener ugc nofollow" target="_blank">二叉树遍历:函数接口</a>中讨论的。</p><h1 id="3286" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">试验</h1><p id="4e05" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">和往常一样，我们应该尽可能多地对代码进行单元测试。检查<a class="ae jd" href="https://github.com/shunsvineyard/forest-python/blob/main/tests/test_avl_tree.py" rel="noopener ugc nofollow" target="_blank"> test_avl_tree.py </a>进行完整的单元测试。</p><h1 id="861b" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">分析</h1><p id="3b01" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">AVL树是一种自平衡二叉查找树，它的高度为O(lg n)，其中n是节点的数量(这可以通过利用斐波那契数来证明。更多细节见<a class="ae jd" href="https://en.wikipedia.org/wiki/AVL_tree#Properties" rel="noopener ugc nofollow" target="_blank"> AVL树维基百科</a>。因此，AVL树的时间复杂度可以总结在下表中。</p><figure class="ki kj kk kl fd lg er es paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="er es mv"><img src="../Images/d93564c6df24f1bed6fe1a9e47db0afd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oe5znN9eu0uhnm5kiqDjvw.png"/></div></div></figure><h1 id="9f7f" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">例子</h1><p id="e712" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">像红黑树一样，AVL树由于其自平衡能力而被广泛应用于软件程序中。例如，本节使用我们在这里实现的AVL树来实现一个键值映射<em class="kh">。</em></p><pre class="ki kj kk kl fd km kn ko kp aw kq bi"><span id="79e4" class="kr jf hi kn b fi ks kt l ku kv">from typing import Any, Optional<br/><br/>from forest.binary_trees import avl_tree<br/>from forest.binary_trees import traversal<br/><br/>class Map:<br/>    """Key-value Map implemented using AVL Tree."""<br/><br/>    def __init__(self) -&gt; None:<br/>        self._avlt = avl_tree.AVLTree()<br/><br/>    def __setitem__(self, key: Any, value: Any) -&gt; None:<br/>        """Insert (key, value) item into the map."""<br/>        self._avlt.insert(key=key, data=value)<br/><br/>    def __getitem__(self, key: Any) -&gt; Optional[Any]:<br/>        """Get the data by the given key."""<br/>        node = self._avlt.search(key=key)<br/>        if node:<br/>            return node.data<br/>        return None<br/><br/>    def __delitem__(self, key: Any) -&gt; None:<br/>        """Remove a (key, value) pair from the map."""<br/>        self._avlt.delete(key=key)<br/><br/>    def __iter__(self) -&gt; traversal.Pairs:<br/>        """Iterate the data in the map."""<br/>        return traversal.inorder_traverse(tree=self._avlt)<br/><br/>    @property<br/>    def empty(self) -&gt; bool:<br/>        """Return `True` if the map is empty; `False` otherwise."""<br/>        return self._avlt.empty<br/><br/>if __name__ == "__main__":<br/><br/>    # Initialize the Map instance.<br/>    contacts = Map()<br/><br/>    # Add some items.<br/>    contacts["Mark"] = "mark@email.com"<br/>    contacts["John"] = "john@email.com"<br/>    contacts["Luke"] = "luke@email.com"<br/><br/>    # Retrieve an email<br/>    print(contacts["Mark"])<br/><br/>    # Delete one item.<br/>    del contacts["John"]<br/><br/>    # Check the deleted item.<br/>    print(contacts["John"])  # This will print None<br/><br/>    # Iterate the items.<br/>    for contact in contacts:<br/>        print(contact)</span></pre><p id="0bdd" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">(完整示例可从<a class="ae jd" href="https://github.com/shunsvineyard/forest-python/blob/main/examples/avlt_map.py" rel="noopener ugc nofollow" target="_blank"> avlt_map.py </a>获得)</p><h1 id="78c2" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">摘要</h1><p id="c69b" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">与红黑树一样，AVL树在插入和删除操作上引入了一些复杂性以保持其平衡，但AVL树的自平衡能力为基本操作提供了O(lg n)的时间复杂性，这比常规二叉查找树的性能更好。</p></div><div class="ab cl mw mx gp my" role="separator"><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb"/></div><div class="hb hc hd he hf"><p id="d675" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="kh">原载于2021年6月6日</em><a class="ae jd" href="https://shunsvineyard.info/2021/06/06/build-the-forest-in-python-series-avl-tree/" rel="noopener ugc nofollow" target="_blank"><em class="kh">https://shunsvineyard . info</em></a><em class="kh">。</em></p></div></div>    
</body>
</html>