<html>
<head>
<title>Best practices for error catching and handling</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">错误捕获和处理的最佳实践</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/best-practices-for-error-catching-and-handling-2247325042c9?source=collection_archive---------18-----------------------#2021-07-26">https://medium.com/nerd-for-tech/best-practices-for-error-catching-and-handling-2247325042c9?source=collection_archive---------18-----------------------#2021-07-26</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/43030f2288b15f462c44f1eb452512b7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OsGiwoE7xS8SPMTHfkiZlA.jpeg"/></div></div></figure><p id="e82e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">捕捉和处理错误是<a class="ae jo" href="https://programmingduck.com/articles/errors" rel="noopener ugc nofollow" target="_blank">错误处理</a>的重要组成部分。</p><p id="864c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">以下是一些最佳实践。一般来说，最好:</p><ul class=""><li id="e720" class="jp jq hi is b it iu ix iy jb jr jf js jj jt jn ju jv jw jx bi translated">非常彻底地检查你的错误</li><li id="aa1b" class="jp jq hi is b it jy ix jz jb ka jf kb jj kc jn ju jv jw jx bi translated">首先进行错误检查</li><li id="127c" class="jp jq hi is b it jy ix jz jb ka jf kb jj kc jn ju jv jw jx bi translated">尽早在适当的地方处理错误</li><li id="6d6e" class="jp jq hi is b it jy ix jz jb ka jf kb jj kc jn ju jv jw jx bi translated">(例外情况)尽可能在 try 块中使用最少的代码</li><li id="ba70" class="jp jq hi is b it jy ix jz jb ka jf kb jj kc jn ju jv jw jx bi translated">还原状态和资源，以便程序可以继续正确执行</li></ul><p id="d320" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">以下是更详细的最佳实践。</p><p id="1c61" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">(注:对于本文，“错误”在<a class="ae jo" href="https://programmingduck.com/articles/error-meaning" rel="noopener ugc nofollow" target="_blank">术语中定义——错误和非错误</a>。这意味着你可能抛出一个异常或者返回一个错误值。它不仅仅意味着“不可恢复的错误”。)</p><figure class="kd ke kf kg fd ij"><div class="bz dy l di"><div class="kh ki l"/></div></figure><h1 id="7ef0" class="kj kk hi bd kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg bi translated">非常彻底地检查你的错误</h1><p id="3aab" class="pw-post-body-paragraph iq ir hi is b it lh iv iw ix li iz ja jb lj jd je jf lk jh ji jj ll jl jm jn hb bi translated">不幸的是，程序员并不完美。我们制造 bug，犯错误。事实上，我们经常这样做。这就是为什么我们有这么多的纠错工具来帮助我们。</p><p id="3f73" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">所以，一般来说，你应该假设程序中所有可能失败的东西都会失败。其他你没有想到的事情也会失败。</p><p id="1bcb" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">为了最小化这个问题，你应该非常彻底地检查你的错误。总是捕捉所有可能的异常并检查所有的错误值。然后，适当地处理它们。</p><h1 id="3c48" class="kj kk hi bd kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg bi translated">首先检查错误</h1><p id="c18b" class="pw-post-body-paragraph iq ir hi is b it lh iv iw ix li iz ja jb lj jd je jf lk jh ji jj ll jl jm jn hb bi translated">这是一个文体惯例。</p><p id="6b86" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在你的代码中，最好先做错误检查。将正常的程序执行留到以后。</p><p id="9e06" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">例如，在抛出异常的方法中，尝试检查错误并尽早抛出异常。</p><p id="e498" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">下面是一个代码示例:</p><pre class="kd ke kf kg fd lm ln lo lp aw lq bi"><span id="1812" class="lr kk hi ln b fi ls lt l lu lv">class Example<br/>{<br/>    public void Foo(string a)<br/>    {<br/>        if (a.Length === 0)<br/>        {<br/>            throw new InvalidArgumentException("Parameter {a} must not be the empty string.");<br/>        }<br/>        // normal program execution<br/>    }<br/>}</span></pre><p id="d773" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">方法<code class="du lw lx ly ln b">Foo</code>从错误检查开始。之后是正常的代码执行。</p><p id="c76e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">避免做这样的事情:</p><pre class="kd ke kf kg fd lm ln lo lp aw lq bi"><span id="9154" class="lr kk hi ln b fi ls lt l lu lv">class Example<br/>{<br/>    public void Foo(string a)<br/>    {<br/>        // do some "normal program execution" that doesn't need parameter `a`<br/><br/>        // check parameter `a` right before you need it<br/>        if (a.Length === 0)<br/>        {<br/>            throw new InvalidArgumentException("Parameter {a} must not be the empty string.");<br/>        }<br/>        // more normal program execution<br/>    }<br/>}</span></pre><p id="eea2" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在这段代码中，<code class="du lw lx ly ln b">Foo</code>执行一些代码。然后，它对参数<code class="du lw lx ly ln b">a</code>进行一些错误检查。</p><p id="c7ae" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">同样的原理也适用于检查错误值。在继续正常程序执行之前，请尝试检查错误。</p><p id="fe93" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">下面是一个代码示例:</p><pre class="kd ke kf kg fd lm ln lo lp aw lq bi"><span id="0aa9" class="lr kk hi ln b fi ls lt l lu lv">function foo() {<br/>  const result = bar();<br/><br/>  if (result.error) {<br/>    // handle error<br/>  }<br/><br/>  else {<br/>    // normal code execution<br/>  }<br/>}</span></pre><p id="8fa8" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">上面的代码首先检查错误。然后，它继续正常的程序执行。</p><p id="03c4" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这将你的代码组织成可识别的块。首先是错误，然后是正常代码。它使你的代码更容易浏览和理解。</p><p id="4676" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这也有助于调试。当抛出一个错误时，将会运行不太正常的代码。这减少了调试时必须检查的代码量。</p><figure class="kd ke kf kg fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lz"><img src="../Images/a6229c55d969f084ebdaebed0758840c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*qsKmboLlfK9Y6D2M.jpg"/></div></div></figure><h1 id="4082" class="kj kk hi bd kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg bi translated">在第一个适当的地方处理错误</h1><p id="b42e" class="pw-post-body-paragraph iq ir hi is b it lh iv iw ix li iz ja jb lj jd je jf lk jh ji jj ll jl jm jn hb bi translated">有时候，你不能立即处理错误。您可能需要将它们传播到更高级别的代码中。</p><p id="fdd6" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">为了展示这一点，考虑这个例子:您有一个在文件系统中搜索文件的函数。如果它找到了，就读取它的内容。否则，它将引发异常。代码应该如何处理这个异常？它应该:</p><ul class=""><li id="d7dd" class="jp jq hi is b it iu ix iy jb jr jf js jj jt jn ju jv jw jx bi translated">让程序崩溃？</li><li id="e9fd" class="jp jq hi is b it jy ix jz jb ka jf kb jj kc jn ju jv jw jx bi translated">创建新文件？</li><li id="b3e8" class="jp jq hi is b it jy ix jz jb ka jf kb jj kc jn ju jv jw jx bi translated">在不同的位置搜索备份文件？</li><li id="874d" class="jp jq hi is b it jy ix jz jb ka jf kb jj kc jn ju jv jw jx bi translated">通知用户找不到文件并要求他们尝试不同的文件？</li></ul><p id="7d38" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">文件系统代码不知道。如果文件找不到，不同的程序想要不同的行为。这意味着文件系统代码不能有硬编码的行为来处理异常。</p><p id="667b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">相反，应该在更合适的地方处理异常。能决定如何应对的地方。通常，这意味着调用堆栈中的某些代码位置更高。因此，异常(或错误值)需要传播到那个地方。</p><p id="7cd5" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">对于异常，这意味着您应该让异常冒泡。然后，在你要处理它的地方放一个 try / catch 块。</p><p id="5f5b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">对于错误值，您必须手动返回它们，直到它们到达调用堆栈中的正确位置。</p><p id="f757" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">说到这里，你要在<strong class="is hj">第一</strong>适当的地方处理错误。不要把它们传播到不必要的高度。您越早处理错误，它们就越接近引发它们的代码。这使得代码的执行流更容易跟踪和理解。</p><p id="551c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">下面是一个代码示例，我们在数据库中搜索一条记录:</p><pre class="kd ke kf kg fd lm ln lo lp aw lq bi"><span id="b624" class="lr kk hi ln b fi ls lt l lu lv">// server.js<br/>import { getSpriteById } from './myDatabase.js';<br/><br/>app.get('/:spriteId', async (req, res) =&gt; {<br/>  const spriteId = req.spriteId;<br/>  try {<br/>    await getSpriteById(spriteId);<br/>  } catch (error) {<br/>    // exception from database is handled here.<br/>    // In this case, it responds with a 404.<br/>    res.sendStatus(404);<br/>    return;<br/>  }<br/>  res.send('Sprite found');<br/>});<br/><br/>app.post('/foo', async (req, res) =&gt; {<br/>  const spriteId = req.body.spriteId;<br/>  try {<br/>    await getSpriteById(spriteId);<br/>  } catch (error) {<br/>    // exception from database is handled here.<br/>    // In this case, it redirects<br/>    // to another page for the user to fill in correct information<br/>    res.redirect('/form');<br/>    return;<br/>  }<br/>  res.send('Data accepted');<br/>});<br/><br/>// myDatabase.js<br/>const db = await connectToDatabase('connectionString');<br/><br/>const getSpriteById = async (spriteId) =&gt; {<br/>  // throws exception if it doesn't find the record<br/>  const sprite = await db.findById(spriteId);<br/>  return sprite;<br/>};<br/><br/>export { getSpriteById };</span></pre><p id="dcac" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">(顺便说一下，代码是伪代码，如果你真的运行它，就不要指望它能工作。然而，它展示了这一点。)</p><p id="3a8a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在这个例子中，函数<code class="du lw lx ly ln b">getSpriteById</code>搜索数据库。如果它没有找到它正在寻找的记录，它将抛出一个异常。它本身不处理错误。相反，<code class="du lw lx ly ln b">server.js</code>中的处理程序决定如何处理错误。这两个处理程序都有 try / catch 块，它们根据需要以不同的方式处理异常。</p><h1 id="8e4f" class="kj kk hi bd kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg bi translated">(例外情况)注意在 try 块中放了多少代码</h1><p id="4d76" class="pw-post-body-paragraph iq ir hi is b it lh iv iw ix li iz ja jb lj jd je jf lk jh ji jj ll jl jm jn hb bi translated">在每个 try / catch 块中放置尽可能少的代码被认为是最佳实践。这意味着您可能需要多个 try / catch 块，而不是一个。</p><p id="64ca" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这样做的好处是:</p><ul class=""><li id="9138" class="jp jq hi is b it iu ix iy jb jr jf js jj jt jn ju jv jw jx bi translated">很容易看出哪些代码引发了哪些异常(以及哪些代码没有引发异常)</li><li id="601b" class="jp jq hi is b it jy ix jz jb ka jf kb jj kc jn ju jv jw jx bi translated">它更清楚地“分离关注点”。每个 try / catch 块都是一个独立的功能块。这使得将它重构为一个独立的函数更加容易。</li><li id="6a03" class="jp jq hi is b it jy ix jz jb ka jf kb jj kc jn ju jv jw jx bi translated">它可以防止意外吞掉异常。如果你想都没想就在<code class="du lw lx ly ln b">try</code>中放了一些代码，就会发生这种情况。该代码可能会抛出一个您没有准备好处理的异常。但是，它会被夹在<code class="du lw lx ly ln b">catch</code>中(并可能被错误处理)。然后，程序将继续执行，可能会产生错误的结果。</li></ul><p id="7dd0" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">当某些代码行可能抛出相同类型的异常时，这也是一种解决方案，但是每种情况都需要不同的处理。</p><p id="8f95" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">另一方面，使用小的 try / catch 块会使代码更加冗长。</p><p id="595c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">最后，你需要务实。记住好处和坏处。然后，做出你的决定。通常，正确性和清晰性更重要，即使它们更冗长。但是，有时候让代码更简洁也是可以的，尤其是如果你觉得正确性和清晰性不会受到太大影响的话。</p><p id="6c65" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">例如，这段代码可以进一步分离，但仍然相当不错:</p><pre class="kd ke kf kg fd lm ln lo lp aw lq bi"><span id="830f" class="lr kk hi ln b fi ls lt l lu lv">BufferedReader bufferedReader = null;<br/>try {<br/>    bufferedReader = new BufferedReader(new FileReader("path"));<br/>    String line = bufferedReader.readLine();<br/>    while (line != null) {<br/>        doSomething(line);<br/>        line = bufferedReader.readLine();<br/>    }<br/>} catch (FileNotFoundException | IOException e) {<br/>    e.printStackTrace();<br/>} finally {<br/>    try {<br/>        bufferedReader.close();<br/>    } catch (IOException e) {<br/>        e.printStackTrace();<br/>    }<br/>}</span></pre><p id="6913" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">下面是同一个例子分开更多:</p><pre class="kd ke kf kg fd lm ln lo lp aw lq bi"><span id="007e" class="lr kk hi ln b fi ls lt l lu lv">BufferedReader bufferedReader = null;<br/>try {<br/>    bufferedReader = new BufferedReader(new FileReader("path"));<br/><br/>    try {<br/>        String line = bufferedReader.readLine();<br/>        while (line != null) {<br/>            doSomething(line);<br/>            line = bufferedReader.readLine();<br/>        }<br/>    } catch (IOException e) {<br/>        e.printStackTrace();<br/>    }<br/><br/>} catch (FileNotFoundException e) {<br/>    e.printStackTrace();<br/>} finally {<br/>    try {<br/>        bufferedReader.close();<br/>    } catch (IOException e) {<br/>        e.printStackTrace();<br/>    }<br/>}</span></pre><p id="4912" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如果每个<code class="du lw lx ly ln b">catch</code>块需要不同的代码，那么第二个版本是必要的。否则，您可以选择任何一个版本。</p><p id="83c2" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">(最好的解决方案可能是使用一个<code class="du lw lx ly ln b">with</code> / <code class="du lw lx ly ln b">using</code> / <code class="du lw lx ly ln b">try-with-resources</code>语句，或者你的编程语言的等效语句。它会在结束时自动关闭<code class="du lw lx ly ln b">bufferedReader</code>。上面的代码只是为了展示这一点。)</p><figure class="kd ke kf kg fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lz"><img src="../Images/224552732175dda694b713599d7341ed.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*le_ctXfP8u4uM2MF.jpg"/></div></div></figure><h1 id="4fef" class="kj kk hi bd kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg bi translated">还原状态和资源</h1><p id="48ae" class="pw-post-body-paragraph iq ir hi is b it lh iv iw ix li iz ja jb lj jd je jf lk jh ji jj ll jl jm jn hb bi translated">如果您成功地处理了一个错误，那么程序应该能够继续正确地执行。它应该继续运行，就好像错误从未发生过一样。</p><p id="fda6" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这意味着您需要:</p><ul class=""><li id="63e7" class="jp jq hi is b it iu ix iy jb jr jf js jj jt jn ju jv jw jx bi translated">将状态恢复到正确的状态</li><li id="84d8" class="jp jq hi is b it jy ix jz jb ka jf kb jj kc jn ju jv jw jx bi translated">关闭任何由错误代码引起的副作用</li></ul><h1 id="454d" class="kj kk hi bd kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg bi translated">恢复状态</h1><p id="bdce" class="pw-post-body-paragraph iq ir hi is b it lh iv iw ix li iz ja jb lj jd je jf lk jh ji jj ll jl jm jn hb bi translated">从错误中恢复后，您的程序需要有正确的状态。如果没有，那你还没有真正恢复。</p><p id="cfc5" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这意味着您可能需要在错误处理代码中修复或恢复程序的状态。</p><p id="62d1" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这里有一个例子。</p><p id="34c2" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">假设你有一个布尔变量。布尔变量应该以<code class="du lw lx ly ln b">false</code>开始。然而，当一些代码正在运行时，您将其设置为<code class="du lw lx ly ln b">true</code>。最后，你再把它设置成<code class="du lw lx ly ln b">false</code>。</p><p id="27f8" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">但是，如果程序在某一点出错，变量不会被重置。这将使您的程序处于不良状态，即使错误已经得到处理。</p><p id="65b6" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">以下是一些“危险代码”的示例，如果发生错误，这些代码将具有无效状态:</p><pre class="kd ke kf kg fd lm ln lo lp aw lq bi"><span id="bfc6" class="lr kk hi ln b fi ls lt l lu lv">let isBusy = false;<br/><br/>async function handleUserEvent(event) {<br/>  if (!isBusy) {<br/>    isBusy = true;<br/>    // do something asynchronous which may throw an exception, for example:<br/>    // await doSomething()<br/>    isBusy = false;<br/>  }<br/>}</span></pre><p id="5916" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如果<code class="du lw lx ly ln b">handleUserEvent</code>出错，<code class="du lw lx ly ln b">isBusy</code>的值将永远保持<code class="du lw lx ly ln b">false</code>。<code class="du lw lx ly ln b">handleUserEvent</code>将无法再次正常运行。</p><p id="6abc" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">因此，如果出现错误，您需要手动重置状态。</p><p id="5b35" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">下面是一个代码示例:</p><pre class="kd ke kf kg fd lm ln lo lp aw lq bi"><span id="c571" class="lr kk hi ln b fi ls lt l lu lv">let isBusy = false;<br/><br/>async function handleUserEvent(event) {<br/>  if (!isBusy) {<br/>    isBusy = true;<br/>    try {<br/>      // do something asynchronous which may throw an exception, for example:<br/>      // await doSomething()<br/>    } finally {<br/>      isBusy = false; // fix the state<br/>      // exception is sent higher up because there's no catch block<br/>    }<br/>  }<br/>}<br/><br/>// equivalent example<br/>async function handleUserEvent(event) {<br/>  if (!isBusy) {<br/>    isBusy = true;<br/>    try {<br/>      // do something asynchronous which may throw an exception, for example:<br/>      // await doSomething()<br/>    } catch (error) {<br/>      isBusy = false; // fix the state<br/>      throw error;<br/>    }<br/>    isBusy = false;<br/>  }<br/>}</span></pre><p id="fcb7" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在本例中，如果在<code class="du lw lx ly ln b">handleUserEvent</code>中出现错误，则没有问题。状态恢复，之后<code class="du lw lx ly ln b">handleUserEvent</code>将正确执行。</p><p id="2d07" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">同样的原则适用于调用堆栈中的所有代码。假设函数<code class="du lw lx ly ln b">bar</code>出现错误。但是，您处理函数<code class="du lw lx ly ln b">foo</code>中的错误，这是调用堆栈中的第 5 个函数调用。为了让程序处于有效状态，您需要确保您已经修复了从<code class="du lw lx ly ln b">bar</code>到<code class="du lw lx ly ln b">foo</code>的所有状态。</p><figure class="kd ke kf kg fd ij er es paragraph-image"><div class="er es ma"><img src="../Images/a6470ac8ce4689eaa51ed0d3391b5239.png" data-original-src="https://miro.medium.com/v2/resize:fit:676/format:webp/0*puuGBuVxDnrZoSip.png"/></div></figure><p id="f698" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">基本上，这意味着您可能需要调用堆栈中不同函数的许多中间 try / catch 块。你在每一个中修正状态。这样，如果错误被更高层处理，所有中间代码的状态都已被修复。他们可以再次运行，就好像什么都没发生。</p><p id="d2bd" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">例如:</p><pre class="kd ke kf kg fd lm ln lo lp aw lq bi"><span id="fa00" class="lr kk hi ln b fi ls lt l lu lv">// handleUserEvent<br/>import foo from './foo.js';<br/><br/>// this is the top-level function<br/>async function handleUserEvent() {<br/>  try {<br/>    await foo();<br/>  } catch (error) { // handle the error at the top level<br/>    // record error<br/>    // display message to user that action didn't work<br/>  }<br/>}<br/><br/>// foo.js<br/>import bar from './bar.js';<br/><br/>let isBusy = false;<br/><br/>async function foo() {<br/>  if (isBusy) {<br/>    return;<br/>  }<br/>  isBusy = true;<br/>  try {<br/>    await bar();<br/>  } finally {<br/>    isBusy = false; // restore this module's state<br/>    // exception is sent further up because there is no catch block<br/>  }<br/>}<br/><br/>export default foo;<br/><br/>// bar.js<br/>let isBusy = false;<br/><br/>async function bar() {<br/>  if (isBusy) {<br/>    return;<br/>  }<br/>  try {<br/>    // do something asynchronous which may throw an exception, for example:<br/>    // await doSomething()<br/>  } finally {<br/>    isBusy = false; // restore this module's state<br/>    // exception is sent further up because there is no catch block<br/>  }<br/>}<br/><br/>export default bar;</span></pre><p id="6a52" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">(是的，我知道例子中的代码很不自然，但希望它能说明问题😅)</p><h1 id="09b6" class="kj kk hi bd kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg bi translated">密切的副作用</h1><p id="5bc6" class="pw-post-body-paragraph iq ir hi is b it lh iv iw ix li iz ja jb lj jd je jf lk jh ji jj ll jl jm jn hb bi translated">有些副作用是成对出现的。例如，如果你打开一个文件，你也应该关闭它。让它开着可能不安全。</p><p id="c61c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">所以，确保这样的资源被适当地释放。</p><p id="f66d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如果使用异常:</p><ul class=""><li id="1a60" class="jp jq hi is b it iu ix iy jb jr jf js jj jt jn ju jv jw jx bi translated">使用<code class="du lw lx ly ln b">with</code>积木。如果发生错误，它们会自动关闭资源。一些例子是 Python 中的<code class="du lw lx ly ln b">with</code>、Java 中的<code class="du lw lx ly ln b">try-with-resources</code>或 C#中的<code class="du lw lx ly ln b">using</code>。</li><li id="a667" class="jp jq hi is b it jy ix jz jb ka jf kb jj kc jn ju jv jw jx bi translated">否则，使用<code class="du lw lx ly ln b">finally</code>块(或不同编程语言中的等效块)</li></ul><p id="c818" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如果使用错误值，将“关闭”代码放在适当的地方。它应该在错误情况和非错误情况下都运行。</p><p id="337d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这里有一个关于<code class="du lw lx ly ln b">finally</code>的例子:</p><pre class="kd ke kf kg fd lm ln lo lp aw lq bi"><span id="39df" class="lr kk hi ln b fi ls lt l lu lv">// pseudocode<br/><br/>let file;<br/>try {<br/>  file = openFile('foo.txt'); // open the resource<br/>  writeToFile(file, 'bar');<br/>} catch (error) {<br/>  // code to handle exceptions<br/>} finally {<br/>  close(file); // close the resource<br/>}</span></pre><p id="a352" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">以下是一个带有错误值的示例:</p><pre class="kd ke kf kg fd lm ln lo lp aw lq bi"><span id="3a09" class="lr kk hi ln b fi ls lt l lu lv">// pseudocode<br/><br/>const [fileError, file] = openFile('foo.txt');<br/>if (fileError) {<br/>  // handle error<br/>  close(file);<br/>  return;<br/>}<br/>const [writeError, _] = writeToFile(file.value, 'bar');<br/>if (writeError) {<br/>  // handle error<br/>}<br/>close(file);</span></pre><h1 id="ae7b" class="kj kk hi bd kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg bi translated">最终注释</h1><p id="96e6" class="pw-post-body-paragraph iq ir hi is b it lh iv iw ix li iz ja jb lj jd je jf lk jh ji jj ll jl jm jn hb bi translated">所以这就是这篇文章。我希望你觉得有用。</p><p id="d287" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">一如既往，如果有任何遗漏，或者有任何异议，或者有任何意见或反馈，请在下面留下您的评论。</p><p id="1081" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">对于接下来的步骤，我建议看看<a class="ae jo" href="https://programmingduck.com/articles/errors" rel="noopener ugc nofollow" target="_blank">错误处理系列</a>中的其他文章。</p><p id="3407" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">好的，谢谢，下次见。</p><h1 id="9703" class="kj kk hi bd kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg bi translated">信用</h1><p id="bb70" class="pw-post-body-paragraph iq ir hi is b it lh iv iw ix li iz ja jb lj jd je jf lk jh ji jj ll jl jm jn hb bi translated">图像制作者名单:</p><ul class=""><li id="f090" class="jp jq hi is b it iu ix iy jb jr jf js jj jt jn ju jv jw jx bi translated">网络——照片由 Raghavendra Saralaya 在 Unsplash 上拍摄</li><li id="a64f" class="jp jq hi is b it jy ix jz jb ka jf kb jj kc jn ju jv jw jx bi translated">箭头-照片由你好我是尼克在 Unsplash</li><li id="8648" class="jp jq hi is b it jy ix jz jb ka jf kb jj kc jn ju jv jw jx bi translated">树屋中的松鼠——照片由 Joakim Honkasalo 在 Unsplash 上拍摄</li></ul></div><div class="ab cl mb mc gp md" role="separator"><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg"/></div><div class="hb hc hd he hf"><p id="8460" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><em class="mi">原载于 2021 年 7 月 26 日 https://programmingduck.com</em><a class="ae jo" href="https://programmingduck.com/articles/error-catching-handling" rel="noopener ugc nofollow" target="_blank"><em class="mi"/></a><em class="mi">。</em></p></div></div>    
</body>
</html>