<html>
<head>
<title>Using WorkManager — Android</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用工作管理器— Android</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/using-workmanager-android-f7a70781d3ff?source=collection_archive---------3-----------------------#2021-10-22">https://medium.com/nerd-for-tech/using-workmanager-android-f7a70781d3ff?source=collection_archive---------3-----------------------#2021-10-22</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/a3f50b016062adfd1aae44991b4ffd53.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xtC2p77xq-rNrIgXKKpwLQ.jpeg"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">照片由<a class="ae iu" href="https://www.pexels.com/@jeshoots-com-147458?utm_content=attributionCopyText&amp;utm_medium=referral&amp;utm_source=pexels" rel="noopener ugc nofollow" target="_blank">JESHOOTS.com</a>从<a class="ae iu" href="https://www.pexels.com/photo/black-twin-bell-alarm-desk-clock-on-table-714701/?utm_content=attributionCopyText&amp;utm_medium=referral&amp;utm_source=pexels" rel="noopener ugc nofollow" target="_blank">派克斯</a>拍摄</figcaption></figure><p id="0f64" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">工作管理器适用于不需要立即运行的工作，即使应用程序退出或设备重启，也需要<strong class="ix hj">可靠运行</strong>。对于长期运行的后台任务，推荐使用工作管理器</p><p id="4905" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">例如:</p><ul class=""><li id="0612" class="jt ju hi ix b iy iz jc jd jg jv jk jw jo jx js jy jz ka kb bi translated">向后端服务发送日志或分析</li><li id="11d3" class="jt ju hi ix b iy kc jc kd jg ke jk kf jo kg js jy jz ka kb bi translated">定期将应用程序数据与服务器同步</li></ul><p id="794d" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在Workmanger之前，有不同的作业调度API，其中一些工作在特定的android版本上，或者需要安装google play服务。</p><p id="5683" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">另一方面，WorkManager可以在冰淇淋三明治以上的所有android版本上工作，并且独立于google play服务<br/>之外，WorkManager使用基于以下标准的底层作业调度服务:</p><figure class="ki kj kk kl fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es kh"><img src="../Images/3957b3b2597a251507786345a01d5656.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NeyRYZFErHogkJPVHgw-eQ.png"/></div></div></figure><h2 id="9342" class="km kn hi bd ko kp kq kr ks kt ku kv kw jg kx ky kz jk la lb lc jo ld le lf lg bi translated"><strong class="ak">工作管理器的优势</strong></h2><ul class=""><li id="caf0" class="jt ju hi ix b iy lh jc li jg lj jk lk jo ll js jy jz ka kb bi translated">与以前的API相比，WorkManager的一个优点是，您可以定义约束，以便仅在满足这些约束时才执行任务。例如，您希望仅在设备连接到Wifi时下载用户喜爱的音乐。</li><li id="c8aa" class="jt ju hi ix b iy kc jc kd jg ke jk kf jo kg js jy jz ka kb bi translated">WorkManager还允许您链接您的请求，以便它们按顺序运行，并且一个请求只有在成功执行之前才会执行</li><li id="ea94" class="jt ju hi ix b iy kc jc kd jg ke jk kf jo kg js jy jz ka kb bi translated">工作管理器允许您使用灵活的调度窗口<a class="ae iu" href="https://developer.android.com/topic/libraries/architecture/workmanager/how-to/define-work" rel="noopener ugc nofollow" target="_blank">安排工作</a>运行<a class="ae iu" href="https://developer.android.com/reference/androidx/work/OneTimeWorkRequest" rel="noopener ugc nofollow" target="_blank">一次</a>或<a class="ae iu" href="https://developer.android.com/reference/androidx/work/PeriodicWorkRequest" rel="noopener ugc nofollow" target="_blank">重复</a>。还可以标记和命名工作，允许您安排独特的、可替换的工作，并一起监控或取消工作组。此外，WorkManager坚持节能功能和最佳实践，如<a class="ae iu" href="https://developer.android.com/training/monitoring-device-state/doze-standby" rel="noopener ugc nofollow" target="_blank">瞌睡模式</a>，因此您不必担心。</li><li id="c471" class="jt ju hi ix b iy kc jc kd jg ke jk kf jo kg js jy jz ka kb bi translated">有时工作会失败。WorkManager提供了<a class="ae iu" href="https://developer.android.com/topic/libraries/architecture/workmanager/how-to/define-work#retries_backoff" rel="noopener ugc nofollow" target="_blank">灵活的重试策略</a>，包括一个可配置的<a class="ae iu" href="https://developer.android.com/reference/androidx/work/BackoffPolicy" rel="noopener ugc nofollow" target="_blank">指数退避策略</a>。</li></ul><p id="7db0" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">对于工作管理器，我们需要在我们的项目Gradle中有一个工作运行时ktx依赖项</p><pre class="ki kj kk kl fd lm ln lo lp aw lq bi"><span id="51d0" class="km kn hi ln b fi lr ls l lt lu">implementation "androidx.work:work-runtime-ktx:2.5.0"</span></pre><h1 id="220b" class="lv kn hi bd ko lw lx ly ks lz ma mb kw mc md me kz mf mg mh lc mi mj mk lf ml bi translated"><strong class="ak">实现工作管理器需要2个步骤</strong></h1><h1 id="e7ba" class="lv kn hi bd ko lw lx ly ks lz ma mb kw mc md me kz mf mg mh lc mi mj mk lf ml bi translated"><strong class="ak">第一步</strong></h1><p id="a43d" class="pw-post-body-paragraph iv iw hi ix b iy lh ja jb jc li je jf jg mm ji jj jk mn jm jn jo mo jq jr js hb bi translated">创建一个Worker类，您可以在其中定义要在后台执行的工作。</p><figure class="ki kj kk kl fd ij"><div class="bz dy l di"><div class="mp mq l"/></div></figure><p id="c663" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">dowork()方法异步运行，也就是说，它不会在任务执行时暂停我们的主UI线程。dowork()应该返回一个结果来显示工作成功完成。我们还可以将输出作为结果的一部分。</p><p id="fd20" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在上面显示的用例中，我们正在获取用户列表。如果获取了所有用户，我们将返回Result.success()。如果有任何异常，我们将返回Result.retry()，它将告诉WorkManger根据重试策略稍后再试一次</p><h1 id="74b1" class="lv kn hi bd ko lw lx ly ks lz ma mb kw mc md me kz mf mg mh lc mi mj mk lf ml bi translated">第二步</h1><p id="6d21" class="pw-post-body-paragraph iv iw hi ix b iy lh ja jb jc li je jf jg mm ji jj jk mn jm jn jo mo jq jr js hb bi translated">工作管理器允许两种方式来安排工作</p><ul class=""><li id="9f3a" class="jt ju hi ix b iy iz jc jd jg jv jk jw jo jx js jy jz ka kb bi translated"><a class="ae iu" href="https://developer.android.com/reference/androidx/work/OneTimeWorkRequest" rel="noopener ugc nofollow" target="_blank"> OneTimeWorkRequest </a> <br/>如果您想要安排您的工作，并且它应该只执行一次，那么就使用OneTimeWorkRequest</li><li id="5af1" class="jt ju hi ix b iy kc jc kd jg ke jk kf jo kg js jy jz ka kb bi translated">如果您希望定期重复您的工作，您可以使用PeriodicWorkRequest</li></ul><p id="3746" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在下面的例子中，我们将使用<a class="ae iu" href="https://developer.android.com/reference/androidx/work/PeriodicWorkRequest" rel="noopener ugc nofollow" target="_blank"> PeriodicWorkRequest </a>，因为我们需要定期每隔几分钟同步数据。</p><figure class="ki kj kk kl fd ij"><div class="bz dy l di"><div class="mp mq l"/></div></figure><p id="5f0f" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们设置了一些限制，只是说WorkManger要启动网络，电池不能太低。</p><p id="8ffe" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在PeriodicWorkRequest。构建器我们需要定义repeatInterval，这意味着在多少时间间隔后应该再次执行任务。在这里，我们使用PeriodicWorkRequest。<em class="mr">MIN _ PERIODIC _ INTERVAL _ MILLIS</em>表示15分钟。因此，我们的任务将每隔15分钟运行一次。</p><p id="5c03" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><em class="mr">暂时就这样吧！！<br/>感谢您的阅读，不要忘记与您的开发伙伴分享:)</em></p></div></div>    
</body>
</html>