<html>
<head>
<title>Show some love for Mocha api tests! Testing #2</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">对Mocha api测试表现出一些热爱吧！测试#2</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/show-some-love-for-mocha-api-tests-testing-2-342fcd250aeb?source=collection_archive---------10-----------------------#2021-03-18">https://medium.com/nerd-for-tech/show-some-love-for-mocha-api-tests-testing-2-342fcd250aeb?source=collection_archive---------10-----------------------#2021-03-18</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><h1 id="89e5" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">介绍</h1><p id="81fc" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">这是第一部分的延续，你可以在这里找到<a class="ae kb" href="https://liudas-demikis.medium.com/show-some-love-for-mocha-api-tests-setting-up-1-4ba486fbdf4b" rel="noopener">。在这一部分，我们将深入实际的api测试。我将向你展示一些用Javascript改编的设计模式，我们将在没有任何模仿或存根的情况下进行全面测试。</a></p></div><div class="ab cl kc kd gp ke" role="separator"><span class="kf bw bk kg kh ki"/><span class="kf bw bk kg kh ki"/><span class="kf bw bk kg kh"/></div><div class="hb hc hd he hf"><h1 id="ebf2" class="if ig hi bd ih ii kj ik il im kk io ip iq kl is it iu km iw ix iy kn ja jb jc bi translated">让我们开始吧</h1><p id="2662" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">首先，我们必须设置一个测试和Mocha脚本来运行它。我们可以通过按照模式<code class="du ko kp kq kr b">tests/**/*.test.js</code>在<code class="du ko kp kq kr b">tests/</code>目录中创建任何测试来做到这一点。开始测试的命令非常简单:<code class="du ko kp kq kr b">mocha tests/**/*.test.js —-reporter dot</code>。</p><figure class="kt ku kv kw fd kx er es paragraph-image"><div role="button" tabindex="0" class="ky kz di la bf lb"><div class="er es ks"><img src="../Images/121a0354ed83c2480a6804fd2ddbcfca.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KItvxNoc_OgbqBh3ZcjpHw.png"/></div></div><figcaption class="le lf et er es lg lh bd b be z dx translated">npm运行测试命令</figcaption></figure><p id="f2c3" class="pw-post-body-paragraph jd je hi jf b jg li ji jj jk lj jm jn jo lk jq jr js ll ju jv jw lm jy jz ka hb bi translated">示例测试由定义测试套件的单个<code class="du ko kp kq kr b">describe</code>块和一个用例<code class="du ko kp kq kr b">it</code>块组成。</p><figure class="kt ku kv kw fd kx er es paragraph-image"><div role="button" tabindex="0" class="ky kz di la bf lb"><div class="er es ln"><img src="../Images/696ae38b0719146376d1aecd7694492d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1256/format:webp/1*cLE514h2gEsAvbY2XtreVA.png"/></div></div><figcaption class="le lf et er es lg lh bd b be z dx translated">第一个示例测试</figcaption></figure><p id="41ed" class="pw-post-body-paragraph jd je hi jf b jg li ji jj jk lj jm jn jo lk jq jr js ll ju jv jw lm jy jz ka hb bi translated">现在我将在我的<code class="du ko kp kq kr b">tests/</code>目录中创建两个模块— <code class="du ko kp kq kr b">util.js</code>和<code class="du ko kp kq kr b">create.js</code>。</p><p id="5ccc" class="pw-post-body-paragraph jd je hi jf b jg li ji jj jk lj jm jn jo lk jq jr js ll ju jv jw lm jy jz ka hb bi translated">Util模块负责所有的测试基础设施，从其他文件导出所有东西，收集模型等等。现在，它将在每次测试和配置<code class="du ko kp kq kr b">mongoConnectionString</code>之前清理数据库。</p><figure class="kt ku kv kw fd kx er es paragraph-image"><div role="button" tabindex="0" class="ky kz di la bf lb"><div class="er es lo"><img src="../Images/7d9707c765867c3fbd23cb6e854f0fbe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XeeN9c8wgdGz17OtgfzA2Q.png"/></div></div><figcaption class="le lf et er es lg lh bd b be z dx translated">负责设置测试基础设施的util.ts文件</figcaption></figure><p id="2e5b" class="pw-post-body-paragraph jd je hi jf b jg li ji jj jk lj jm jn jo lk jq jr js ll ju jv jw lm jy jz ka hb bi translated">Create module基本上是Javascript中一种经过改编的工厂设计模式。别害怕，我不会用类和花哨的OOP东西。我将为我们系统中的每个数据库模型创建两个函数。一个负责创建实体(数据传输对象)的DTO，另一个负责将实际项目插入数据库。当我们想要用现有的实体预先设置数据库，或者我们想要通过POST api端点创建数据库中不存在的东西时，这将非常方便。</p><figure class="kt ku kv kw fd kx er es paragraph-image"><div role="button" tabindex="0" class="ky kz di la bf lb"><div class="er es lp"><img src="../Images/e11fe5b57c36a1ee398c7620083bb3f0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*igt4pPaqM6SLzXPmwq-8gw.png"/></div></div><figcaption class="le lf et er es lg lh bd b be z dx translated">create.js文件的行为类似于工厂设计模式</figcaption></figure><p id="998c" class="pw-post-body-paragraph jd je hi jf b jg li ji jj jk lj jm jn jo lk jq jr js ll ju jv jw lm jy jz ka hb bi translated">不要偷懒，明确定义所有的字段。另外，一个好的做法是为每个带字段名后缀的字符串字段使用唯一标识符。这只是帮助我调试测试的东西。</p></div><div class="ab cl kc kd gp ke" role="separator"><span class="kf bw bk kg kh ki"/><span class="kf bw bk kg kh ki"/><span class="kf bw bk kg kh"/></div><div class="hb hc hd he hf"><h1 id="06a4" class="if ig hi bd ih ii kj ik il im kk io ip iq kl is it iu km iw ix iy kn ja jb jc bi translated">测试</h1><p id="83df" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">我喜欢从定义每个api端点的主要测试用例及块开始。</p><figure class="kt ku kv kw fd kx er es paragraph-image"><div role="button" tabindex="0" class="ky kz di la bf lb"><div class="er es lr"><img src="../Images/7e1cd7c545a3e49578f40d1d57e8d139.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CVTNap4_-2xpB2L4sQ4UPA.png"/></div></div><figcaption class="le lf et er es lg lh bd b be z dx translated">/api/items资源的所有测试用例</figcaption></figure><p id="1b55" class="pw-post-body-paragraph jd je hi jf b jg li ji jj jk lj jm jn jo lk jq jr js ll ju jv jw lm jy jz ka hb bi translated">如你所见，有两种类型的测试——失败之路和快乐之路。我在测试各种场景，尤其是不好的场景。通常每个api端点都有认证和授权检查。例如不发送令牌、发送无效令牌、不具有所需的权限等。有时测试用例可能包括节流——当您预期收到429太多请求错误之类的东西时。这个例子非常基本和简单——测试与数据库的交互、一些验证位和restful api指南检查。</p><p id="30fd" class="pw-post-body-paragraph jd je hi jf b jg li ji jj jk lj jm jn jo lk jq jr js ll ju jv jw lm jy jz ka hb bi translated">你问我们怎么调用api？这很简单——我们将使用<code class="du ko kp kq kr b">supertest</code>。当然我们要先装上<code class="du ko kp kq kr b">npm i -D supertest</code>。</p><p id="6366" class="pw-post-body-paragraph jd je hi jf b jg li ji jj jk lj jm jn jo lk jq jr js ll ju jv jw lm jy jz ka hb bi translated">现在让我们从GET /api/items端点开始。</p><figure class="kt ku kv kw fd kx er es paragraph-image"><div role="button" tabindex="0" class="ky kz di la bf lb"><div class="er es ls"><img src="../Images/af2ca6aecfcf5bd5b5e3c4facf896931.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*G1deLlB3O2RGLPFwa3SuJg.png"/></div></div><figcaption class="le lf et er es lg lh bd b be z dx translated">首次获取/API/项目测试</figcaption></figure><p id="59e8" class="pw-post-body-paragraph jd je hi jf b jg li ji jj jk lj jm jn jo lk jq jr js ll ju jv jw lm jy jz ka hb bi translated">很简单，对吧？基本上，我用<code class="du ko kp kq kr b">supertest</code>函数<code class="du ko kp kq kr b">request</code>调用我的<code class="du ko kp kq kr b">express</code>应用程序，并期待一些结果。我总是喜欢检查像<code class="du ko kp kq kr b">Content-Type</code>这样的标题和我自己设置的标题— <code class="du ko kp kq kr b">X-Total-Count</code>。最后我要做的是——除了一个空数组——真正的身体。现在让我们试着创建一些东西并再次调用api。</p><figure class="kt ku kv kw fd kx er es paragraph-image"><div role="button" tabindex="0" class="ky kz di la bf lb"><div class="er es lt"><img src="../Images/206034ab4f3c933b5152eb82d82fefac.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pK3cLvG8o5MS7ggr4fNInA.png"/></div></div><figcaption class="le lf et er es lg lh bd b be z dx translated">GET /api/items第二次测试</figcaption></figure><p id="de07" class="pw-post-body-paragraph jd je hi jf b jg li ji jj jk lj jm jn jo lk jq jr js ll ju jv jw lm jy jz ka hb bi translated">我引入了断言库— <code class="du ko kp kq kr b">NodeJs</code> native <code class="du ko kp kq kr b">assert</code>。我看不出有什么好的理由使用像<code class="du ko kp kq kr b">chai</code>这样的库来实现简单的断言，这些断言可以通过使用环境提供给你的东西来实现。</p></div><div class="ab cl kc kd gp ke" role="separator"><span class="kf bw bk kg kh ki"/><span class="kf bw bk kg kh ki"/><span class="kf bw bk kg kh"/></div><div class="hb hc hd he hf"><p id="6b59" class="pw-post-body-paragraph jd je hi jf b jg li ji jj jk lj jm jn jo lk jq jr js ll ju jv jw lm jy jz ka hb bi translated">所以我再次调用api，但是使用数据库中预先插入的项目，我希望它们返回。我还引入了<code class="du ko kp kq kr b">mapToTestDTO</code>函数，我把它想象成一个适配器模式——我把响应和预期资源都改造成相同的结构。让我们通过编写最后一个测试用例来结束GET /api/items测试。</p><figure class="kt ku kv kw fd kx er es paragraph-image"><div role="button" tabindex="0" class="ky kz di la bf lb"><div class="er es lu"><img src="../Images/08f9e606a009755597051fd6dc989c7f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*g3B7FUSUtq6VxqJR6LpSuQ.png"/></div></div><figcaption class="le lf et er es lg lh bd b be z dx translated">获取/api/items最后一个测试用例</figcaption></figure><p id="32ce" class="pw-post-body-paragraph jd je hi jf b jg li ji jj jk lj jm jn jo lk jq jr js ll ju jv jw lm jy jz ka hb bi translated">仅此而已。我们设置查询只返回一个项目，但是我们仍然期望<code class="du ko kp kq kr b">X-Total-Count</code>是3，因为它不受查询的影响。</p></div><div class="ab cl kc kd gp ke" role="separator"><span class="kf bw bk kg kh ki"/><span class="kf bw bk kg kh ki"/><span class="kf bw bk kg kh"/></div><div class="hb hc hd he hf"><p id="5b59" class="pw-post-body-paragraph jd je hi jf b jg li ji jj jk lj jm jn jo lk jq jr js ll ju jv jw lm jy jz ka hb bi translated">我不会像对这个测试那样关注所有的测试，但是我仍然会向您展示所有的实现并给出一些见解。接下来让我们做GET /api/items/:id端点。</p><figure class="kt ku kv kw fd kx er es paragraph-image"><div role="button" tabindex="0" class="ky kz di la bf lb"><div class="er es lv"><img src="../Images/d7df2a2a977ad20930129fd96b1d5d32.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-jy0WAOvXiCbT5LSPmFJZA.png"/></div></div><figcaption class="le lf et er es lg lh bd b be z dx translated">GET /api/items/:id测试</figcaption></figure><p id="afd3" class="pw-post-body-paragraph jd je hi jf b jg li ji jj jk lj jm jn jo lk jq jr js ll ju jv jw lm jy jz ka hb bi translated">所以这是不言自明的。当给出无效的Mongo id时，第一个测试套件预计会出现验证错误，它得到了一个错误。</p><p id="e67d" class="pw-post-body-paragraph jd je hi jf b jg li ji jj jk lj jm jn jo lk jq jr js ll ju jv jw lm jy jz ka hb bi translated">当数据库为空时，第二个测试预期NotFound错误。当里面什么都没有的时候，你能归还什么？</p><p id="466a" class="pw-post-body-paragraph jd je hi jf b jg li ji jj jk lj jm jn jo lk jq jr js ll ju jv jw lm jy jz ka hb bi translated">第三次测试再次预期NotFound错误，即使数据库不为空，但给出了随机<em class="lq">有效</em> id。</p><p id="0231" class="pw-post-body-paragraph jd je hi jf b jg li ji jj jk lj jm jn jo lk jq jr js ll ju jv jw lm jy jz ka hb bi translated">最后一个测试只期望返回一个项目。</p></div><div class="ab cl kc kd gp ke" role="separator"><span class="kf bw bk kg kh ki"/><span class="kf bw bk kg kh ki"/><span class="kf bw bk kg kh"/></div><div class="hb hc hd he hf"><p id="8308" class="pw-post-body-paragraph jd je hi jf b jg li ji jj jk lj jm jn jo lk jq jr js ll ju jv jw lm jy jz ka hb bi translated">现在我们必须创造一些东西。我们将测试POST /api/items端点。这将有一些额外的验证逻辑。</p><figure class="kt ku kv kw fd kx er es paragraph-image"><div role="button" tabindex="0" class="ky kz di la bf lb"><div class="er es lw"><img src="../Images/45efd55ec6f5a158c71339902a43fb7c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LLhr8KBHshfkOmww98UMJg.png"/></div></div><figcaption class="le lf et er es lg lh bd b be z dx translated">帖子/API/项目</figcaption></figure><p id="5bce" class="pw-post-body-paragraph jd je hi jf b jg li ji jj jk lj jm jn jo lk jq jr js ll ju jv jw lm jy jz ka hb bi translated">第一个测试检查当我发送空主体时发生了什么——我相应地得到一个错误。</p><p id="37b4" class="pw-post-body-paragraph jd je hi jf b jg li ji jj jk lj jm jn jo lk jq jr js ll ju jv jw lm jy jz ka hb bi translated">第二个测试尝试发送一串无意义的内容，并再次对请求做出相应的响应。</p><p id="96b5" class="pw-post-body-paragraph jd je hi jf b jg li ji jj jk lj jm jn jo lk jq jr js ll ju jv jw lm jy jz ka hb bi translated">第三个有一些额外的逻辑。创建项目后，我们获取位置头值并提取id。头看起来像下面的<code class="du ko kp kq kr b">/api/items/:id</code>。用这个id，我向数据库发出一个请求，并验证新项目是用我的body有效载荷值创建的。</p></div><div class="ab cl kc kd gp ke" role="separator"><span class="kf bw bk kg kh ki"/><span class="kf bw bk kg kh ki"/><span class="kf bw bk kg kh"/></div><div class="hb hc hd he hf"><p id="5359" class="pw-post-body-paragraph jd je hi jf b jg li ji jj jk lj jm jn jo lk jq jr js ll ju jv jw lm jy jz ka hb bi translated">是时候做些更新了。你看不到任何新的东西，只是我们在更新已经存在的项目，而不是在许多验证通过后创建新的项目。</p><figure class="kt ku kv kw fd kx er es paragraph-image"><div role="button" tabindex="0" class="ky kz di la bf lb"><div class="er es lx"><img src="../Images/d8bb20a2ac5da82158fef1fb5e497b47.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Yui1pOt9ba5e1yHxGaOhkw.png"/></div></div><figcaption class="le lf et er es lg lh bd b be z dx translated">PUT /api/items/:id第1部分</figcaption></figure><figure class="kt ku kv kw fd kx er es paragraph-image"><div role="button" tabindex="0" class="ky kz di la bf lb"><div class="er es ly"><img src="../Images/fdc41c44d0404e2d8dd3f65c4fbbaf3a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Lg3on1OJ4SJnBi0N45SuCQ.png"/></div></div><figcaption class="le lf et er es lg lh bd b be z dx translated">PUT /api/items/:id第2部分</figcaption></figure><p id="3e25" class="pw-post-body-paragraph jd je hi jf b jg li ji jj jk lj jm jn jo lk jq jr js ll ju jv jw lm jy jz ka hb bi translated">你已经看过大部分了。NotFound和id验证基本上取自GET /api/items/:id测试，主体验证是POST /api/items的副本，也是最后一个——update有一点不同，但它仍然非常类似于POST endpoint。不要害怕重用你的东西，只是不要过于复杂，有时一个好的复制和粘贴比复杂的设计模式更好。</p></div><div class="ab cl kc kd gp ke" role="separator"><span class="kf bw bk kg kh ki"/><span class="kf bw bk kg kh ki"/><span class="kf bw bk kg kh"/></div><div class="hb hc hd he hf"><p id="72ef" class="pw-post-body-paragraph jd je hi jf b jg li ji jj jk lj jm jn jo lk jq jr js ll ju jv jw lm jy jz ka hb bi translated">最后一个——删除。它基本上有一个先决条件—为了删除一个项目，它必须存在于数据库中。让我们试试。</p><figure class="kt ku kv kw fd kx er es paragraph-image"><div role="button" tabindex="0" class="ky kz di la bf lb"><div class="er es lz"><img src="../Images/8bd4e925e8e4ce6e6dd6f01e001cea5e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ny8HWnn9KCHa2N0IH1V66g.png"/></div></div><figcaption class="le lf et er es lg lh bd b be z dx translated">删除/api/items/:id</figcaption></figure><p id="f7eb" class="pw-post-body-paragraph jd je hi jf b jg li ji jj jk lj jm jn jo lk jq jr js ll ju jv jw lm jy jz ka hb bi translated">就是这样！一旦我们验证了id的完整性和项目的存在，我们可以期待它被删除。</p></div><div class="ab cl kc kd gp ke" role="separator"><span class="kf bw bk kg kh ki"/><span class="kf bw bk kg kh ki"/><span class="kf bw bk kg kh"/></div><div class="hb hc hd he hf"><h1 id="3fbe" class="if ig hi bd ih ii kj ik il im kk io ip iq kl is it iu km iw ix iy kn ja jb jc bi translated">最后润色</h1><p id="3f54" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">尝试为观察或开发模式配置Mocha测试脚本。它的<em class="lq">超级</em>快，它对所有文件的变化都有反应。您甚至可以使用简单的save命令或在终端中键入<code class="du ko kp kq kr b">rs</code>来重新运行它。它的美妙之处在于，在监视模式下，您不必重启整个Mocha运行时环境，它会一直运行，只需等待命令来启动实际的测试用例。</p><figure class="kt ku kv kw fd kx er es paragraph-image"><div role="button" tabindex="0" class="ky kz di la bf lb"><div class="er es ma"><img src="../Images/82daf154ac3e4d8ce013109a138f2aff.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VY9e-W-7f0dLsfefS_tuoQ.png"/></div></div><figcaption class="le lf et er es lg lh bd b be z dx translated">测试:观察脚本</figcaption></figure></div><div class="ab cl kc kd gp ke" role="separator"><span class="kf bw bk kg kh ki"/><span class="kf bw bk kg kh ki"/><span class="kf bw bk kg kh"/></div><div class="hb hc hd he hf"><p id="c327" class="pw-post-body-paragraph jd je hi jf b jg li ji jj jk lj jm jn jo lk jq jr js ll ju jv jw lm jy jz ka hb bi translated">利用<code class="du ko kp kq kr b">.only</code>和<code class="du ko kp kq kr b">.skip</code>关键词的力量。您可以将这些添加到任何<code class="du ko kp kq kr b">describe</code>和/或<code class="du ko kp kq kr b">it</code>模块上。<code class="du ko kp kq kr b">Only</code>会不会<em class="lq">只</em>运行你选择的这些测试<code class="du ko kp kq kr b">skip</code> …显然<em class="lq">会跳过</em>它们！</p></div><div class="ab cl kc kd gp ke" role="separator"><span class="kf bw bk kg kh ki"/><span class="kf bw bk kg kh ki"/><span class="kf bw bk kg kh"/></div><div class="hb hc hd he hf"><p id="62e1" class="pw-post-body-paragraph jd je hi jf b jg li ji jj jk lj jm jn jo lk jq jr js ll ju jv jw lm jy jz ka hb bi translated">也有不同的测试记者，我只是喜欢用<code class="du ko kp kq kr b">--reporter dot</code>。以下是其他选项的示例:</p><figure class="kt ku kv kw fd kx er es paragraph-image"><div role="button" tabindex="0" class="ky kz di la bf lb"><div class="er es mb"><img src="../Images/e5743fbbb0f882202692d3a4a6c3ee4b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-QRiBIE7DR3TAN00XNzqcg.png"/></div></div><figcaption class="le lf et er es lg lh bd b be z dx translated">记者点</figcaption></figure><figure class="kt ku kv kw fd kx er es paragraph-image"><div role="button" tabindex="0" class="ky kz di la bf lb"><div class="er es mc"><img src="../Images/729e66e5296dc0d3de8ed50e4e9e496d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9guIzYDIgkhTpPLPFJDWEQ.png"/></div></div><figcaption class="le lf et er es lg lh bd b be z dx translated">无报告者标志，或默认报告者</figcaption></figure><figure class="kt ku kv kw fd kx er es paragraph-image"><div role="button" tabindex="0" class="ky kz di la bf lb"><div class="er es md"><img src="../Images/9008b9c747a4ace1a53d16fad5b9188a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AAex9AAsRy44-Q5g-OVU4w.png"/></div></div><figcaption class="le lf et er es lg lh bd b be z dx translated">记者nyan</figcaption></figure><p id="7bb5" class="pw-post-body-paragraph jd je hi jf b jg li ji jj jk lj jm jn jo lk jq jr js ll ju jv jw lm jy jz ka hb bi translated">还有许多不同的记者库，例如:<code class="du ko kp kq kr b">mocha-simple-html-reporter</code>、<code class="du ko kp kq kr b">mocha-teamcity-reporter</code>等。您可以像安装其他库一样安装它们，并使用Mocha <code class="du ko kp kq kr b">--reporter</code>标志。</p><h1 id="b3ca" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">最后的话</h1><p id="7af1" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated"><em class="lq">总是</em>测试你的应用。我一点也不反对单元测试，我认为所有的测试都会带来额外的价值，无论是单元、集成、api还是e2e。作为一名主要的后端开发人员，我最重视API测试。它们也很好地用一个公共的和众所周知的TDD框架实现了。此外，设计良好的api测试可以作为团队中其他开发人员的某种文档。</p><p id="39c2" class="pw-post-body-paragraph jd je hi jf b jg li ji jj jk lj jm jn jo lk jq jr js ll ju jv jw lm jy jz ka hb bi translated">我们可以用Mocha非常快速地进行api测试，我们可以避免不必要的模仿，我们可以测试完整和真实的后端流程。这不仅允许您测试与数据库的交互，还允许您测试各种事情，例如安全扫描、节流、日志记录、审计等等。不要害怕测试，表现出对Mocha api测试的热爱！</p></div></div>    
</body>
</html>