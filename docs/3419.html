<html>
<head>
<title>Get started with Test Driven Development in Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python 测试驱动开发入门</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/get-started-with-test-driven-development-in-python-88686b11cbe1?source=collection_archive---------12-----------------------#2021-06-09">https://medium.com/nerd-for-tech/get-started-with-test-driven-development-in-python-88686b11cbe1?source=collection_archive---------12-----------------------#2021-06-09</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/ea3949dd16a97dc3e209415633c0a686.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*c36eeJuGzo-Hx6wV_5aP2A.jpeg"/></div></div></figure><h2 id="f148" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">让我们来看看 TDD 如何为博客的创建和访问创建一个命令行应用程序:</h2><p id="473a" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jb jz ka kb jf kc kd ke jj kf kg kh ki hb bi translated">让我们从一个博客应用开始。它可以有一个最小的元素，这是一个职位，将始终有两个属性标题和内容。它是博客的一部分，博客可以包含属性和帖子以及许多其他元数据。</p><p id="def6" class="pw-post-body-paragraph jo jp hi jq b jr kj jt ju jv kk jx jy jb kl ka kb jf km kd ke jj kn kg kh ki hb bi translated">这将帮助我们为我们的应用程序创建最小的单元。这是一个帖子的类，也是一个博客的类。另外，添加一个表示对象的 API，编写并返回一个 JSON 方法。</p><figure class="ko kp kq kr fd ij"><div class="bz dy l di"><div class="ks kt l"/></div></figure><p id="d896" class="pw-post-body-paragraph jo jp hi jq b jr kj jt ju jv kk jx jy jb kl ka kb jf km kd ke jj kn kg kh ki hb bi translated">在编写测试之前，总是要考虑这个问题:它是否依赖于任何其他文件或任何其他系统，如数据库或网页等。</p><p id="c72a" class="pw-post-body-paragraph jo jp hi jq b jr kj jt ju jv kk jx jy jb kl ka kb jf km kd ke jj kn kg kh ki hb bi translated">当你看到一个小的 post-class 时，有一种不添加测试的诱惑，但是当代码增长和扩展时，这是必需的。</p><p id="c4cd" class="pw-post-body-paragraph jo jp hi jq b jr kj jt ju jv kk jx jy jb kl ka kb jf km kd ke jj kn kg kh ki hb bi translated">任何不依赖于其他东西的测试:都可以放在单元测试中。</p><p id="8f42" class="pw-post-body-paragraph jo jp hi jq b jr kj jt ju jv kk jx jy jb kl ka kb jf km kd ke jj kn kg kh ki hb bi translated">每个测试类必须从一个特定的其他类继承，这个类是<em class="ku">测试用例</em>，它是<em class="ku">单元测试</em>库的一部分。</p><p id="ba58" class="pw-post-body-paragraph jo jp hi jq b jr kj jt ju jv kk jx jy jb kl ka kb jf km kd ke jj kn kg kh ki hb bi translated">编写测试用例就像为退休存钱一样。这是一种安全措施，它确保当你的系统改变时，你有一点东西提醒你过去做过的事情，测试也是系统应该如何工作的事实来源。</p><figure class="ko kp kq kr fd ij"><div class="bz dy l di"><div class="ks kt l"/></div></figure></div><div class="ab cl kv kw gp kx" role="separator"><span class="ky bw bk kz la lb"/><span class="ky bw bk kz la lb"/><span class="ky bw bk kz la"/></div><div class="hb hc hd he hf"><p id="c502" class="pw-post-body-paragraph jo jp hi jq b jr kj jt ju jv kk jx jy jb kl ka kb jf km kd ke jj kn kg kh ki hb bi translated">TDD 就是在你实现之前，思考你要实现什么。</p><p id="9aab" class="pw-post-body-paragraph jo jp hi jq b jr kj jt ju jv kk jx jy jb kl ka kb jf km kd ke jj kn kg kh ki hb bi translated">TDD 不是考虑所有的排列并编写一个满足它的片段，而是考虑基本情况，编写代码来解决这个问题并扩展排列，然后扩展代码。</p></div><div class="ab cl kv kw gp kx" role="separator"><span class="ky bw bk kz la lb"/><span class="ky bw bk kz la lb"/><span class="ky bw bk kz la"/></div><div class="hb hc hd he hf"><figure class="ko kp kq kr fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/572c9ae24f12fb7f75e929ca5497e487.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3onLH4mA0PqG5OiICNrt9A.jpeg"/></div></div></figure><p id="0604" class="pw-post-body-paragraph jo jp hi jq b jr kj jt ju jv kk jx jy jb kl ka kb jf km kd ke jj kn kg kh ki hb bi translated">一个 create post 方法不会只测试一个单元，而是两个单元，如果它们成功地交付了一个构成集成测试的结果。</p><figure class="ko kp kq kr fd ij"><div class="bz dy l di"><div class="ks kt l"/></div></figure><p id="adc9" class="pw-post-body-paragraph jo jp hi jq b jr kj jt ju jv kk jx jy jb kl ka kb jf km kd ke jj kn kg kh ki hb bi translated">该应用程序是我们整个系统的视图，它不是一个单元或集成，属于系统测试。贯穿整个系统的测试类型。</p><p id="6d28" class="pw-post-body-paragraph jo jp hi jq b jr kj jt ju jv kk jx jy jb kl ka kb jf km kd ke jj kn kg kh ki hb bi translated">如果一个函数返回一个可以在测试用例中比较的值，我们就比较对象，但是如果这个函数打印到控制台并且没有返回值呢？</p><p id="9544" class="pw-post-body-paragraph jo jp hi jq b jr kj jt ju jv kk jx jy jb kl ka kb jf km kd ke jj kn kg kh ki hb bi translated">它需要的是读取整个输出并取出所需的值，因此在这种情况下我们将使用“补丁”。</p><p id="605e" class="pw-post-body-paragraph jo jp hi jq b jr kj jt ju jv kk jx jy jb kl ka kb jf km kd ke jj kn kg kh ki hb bi translated">当我们给一个对象打补丁时，它会在上面写很多帮助方法来完成任务，这是 python 中的一个 apache 函数。</p><p id="d20f" class="pw-post-body-paragraph jo jp hi jq b jr kj jt ju jv kk jx jy jb kl ka kb jf km kd ke jj kn kg kh ki hb bi translated">当你给某个东西打补丁时，它所做的就是用“模拟”替换打补丁的函数，让你看看它是否是用等等调用的，它给了你一个非常好的助手，所以当你给打印函数打补丁时，打印本身并没有被调用，它总是模拟的。所以当我们调用应用程序，而不是打印博客时，实际的打印功能已经被嘲笑了，所以它不会做任何事情。每次我们用调用它的参数调用它时，模仿者都会记住。</p><p id="f49d" class="pw-post-body-paragraph jo jp hi jq b jr kj jt ju jv kk jx jy jb kl ka kb jf km kd ke jj kn kg kh ki hb bi translated">当我们在修补的输入(或函数)中返回值时，它将在每次调用函数时返回相同的值。所以我们可以使用 mocked_input.side_effect，它会在调用函数时一个接一个地调用值。</p><p id="b3ad" class="pw-post-body-paragraph jo jp hi jq b jr kj jt ju jv kk jx jy jb kl ka kb jf km kd ke jj kn kg kh ki hb bi translated">设置是您可以在测试用例中定义的任务，它将在每次测试之前重新运行。</p><figure class="ko kp kq kr fd ij"><div class="bz dy l di"><div class="ks kt l"/></div></figure><p id="5567" class="pw-post-body-paragraph jo jp hi jq b jr kj jt ju jv kk jx jy jb kl ka kb jf km kd ke jj kn kg kh ki hb bi translated">我们学习了测试命令行应用程序，我们看了单元测试库，模拟和修补，我们看了测试驱动的开发。</p><p id="8c45" class="pw-post-body-paragraph jo jp hi jq b jr kj jt ju jv kk jx jy jb kl ka kb jf km kd ke jj kn kg kh ki hb bi translated">以下是完整资源库的链接:</p><div class="lc ld ez fb le lf"><a href="https://github.com/PurpleState/TDD-blog/tree/main/blog" rel="noopener  ugc nofollow" target="_blank"><div class="lg ab dw"><div class="lh ab li cl cj lj"><h2 class="bd hj fi z dy lk ea eb ll ed ef hh bi translated">purple state/TDD-博客</h2><div class="lm l"><h3 class="bd b fi z dy lk ea eb ll ed ef dx translated">用 TDD - PurpleState/TDD-blog 编写的命令行设置示例</h3></div><div class="ln l"><p class="bd b fp z dy lk ea eb ll ed ef dx translated">github.com</p></div></div><div class="lo l"><div class="lp l lq lr ls lo lt io lf"/></div></div></a></div></div><div class="ab cl kv kw gp kx" role="separator"><span class="ky bw bk kz la lb"/><span class="ky bw bk kz la lb"/><span class="ky bw bk kz la"/></div><div class="hb hc hd he hf"><h2 id="cb68" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">关于创建 python 项目时为何以及如何始终使用虚拟环境的简短说明:</h2><p id="8bd0" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jb jz ka kb jf kc kd ke jj kf kg kh ki hb bi translated">虚拟环境用于应用分离。每个项目都应该有自己的虚拟环境，这样您在其中安装的任何库都应该独立于您计算机上的任何其他项目。以便旧项目可以使用旧库，新项目可以使用新库。它们很小，不占用很多内存。这是一个很好的实践。Venv(或您的虚拟环境)可以作为项目解释器添加。</p><p id="1b34" class="pw-post-body-paragraph jo jp hi jq b jr kj jt ju jv kk jx jy jb kl ka kb jf km kd ke jj kn kg kh ki hb bi translated">您还可以在空闲时间研究一些测试技术，比如边界值分析和等价划分。</p><p id="8944" class="pw-post-body-paragraph jo jp hi jq b jr kj jt ju jv kk jx jy jb kl ka kb jf km kd ke jj kn kg kh ki hb bi translated">旁注:方法是类中的函数，函数是不在类中的函数。</p></div></div>    
</body>
</html>