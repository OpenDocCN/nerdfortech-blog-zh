<html>
<head>
<title>React Virtual Dom and Memo on Performance</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">对虚拟 Dom 和 Memo 的性能作出反应</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/react-virtual-dom-and-memo-hooks-on-performance-8b9498d7b3e1?source=collection_archive---------10-----------------------#2021-05-23">https://medium.com/nerd-for-tech/react-virtual-dom-and-memo-hooks-on-performance-8b9498d7b3e1?source=collection_archive---------10-----------------------#2021-05-23</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="ddc9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在本文中，我将描述 react 用来提高渲染性能的概念。我将详细解释<strong class="ih hj">虚拟 Dom </strong>概念<strong class="ih hj">，Memo，useMemo hook </strong>包括，</p><ul class=""><li id="1d86" class="jd je hi ih b ii ij im in iq jf iu jg iy jh jc ji jj jk jl bi translated">他们是什么？</li><li id="f0d5" class="jd je hi ih b ii jm im jn iq jo iu jp iy jq jc ji jj jk jl bi translated">他们是如何提高绩效的？</li><li id="8f1c" class="jd je hi ih b ii jm im jn iq jo iu jp iy jq jc ji jj jk jl bi translated">什么时候使用它们？</li><li id="4af6" class="jd je hi ih b ii jm im jn iq jo iu jp iy jq jc ji jj jk jl bi translated">什么时候应该避免？</li></ul><p id="7f2e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">首先，我有一个想法，它们是孤立的概念/钩子，反应获得性能的使用。但是，我错了。这些是以某种方式相互联系的，在这种方式下，您的应用程序致力于性能的提升。让我们详细研究一下每一个问题。</p><h1 id="6308" class="jr js hi bd jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko bi translated"><strong class="ak">虚拟 Dom (VDOM) </strong></h1><figure class="kq kr ks kt fd ku er es paragraph-image"><div role="button" tabindex="0" class="kv kw di kx bf ky"><div class="er es kp"><img src="../Images/3484af14dc5199479db6e7dbd8ee9a6b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tabGh6h0piD0_0LZOqywaQ.png"/></div></div></figure><p id="19a9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">当加载网页时，浏览器创建页面的文档对象模型。简单地说，它被构造成一个对象树。那 VDOM 是什么？嗯，它是 react 应用程序中位于 DOM 之上的一种抽象层。React 所做的是直接与 VDOM 互动。而不是真正的 dom。然后<strong class="ih hj"> ReactDom </strong>库将与实际的 Dom 交互，并仅在 DOM 操作中应用更新的元素。</p><p id="d359" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">ReactDom 通过比较新渲染的 VDOM 和以前的 VDOM 来识别 VDOM 中的更新元素。这个过程叫做<strong class="ih hj">差<em class="lb">。</em> </strong>如果有任何变化，那么变化的元素将在 dom 中更新。这个过程被称为<strong class="ih hj">对账</strong>。如果它们相等，那么根本没有实际的 DOM 操作。这将导致性能提升，因为您节省了更新实际 DOM 的次数和元素数量，因为实际 DOM 更新与处理 diffing <strong class="ih hj"> </strong>相比很慢，因为它们会导致 UI 元素的实际重新绘制。</p><p id="10f1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">React 已经为您完成了这一优化。但是有必要了解它们，以确定事情是如何在幕后运作的。</p><p id="10ab" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们看看下面的例子。这是一个简单的 react 应用程序，将在下一行显示“Hello，world”和键入的姓名。“Hello”组件不会改变您在输入中键入的任何内容。但是“Name”组件应该更改为我们在输入框中键入的值。因为当名称状态改变时，Hello 和 Name 组件都包含在 App 组件中，所以 App 组件会自动重新呈现每个子组件。因此，每次用户输入内容时，都会调用不必要的重新渲染。这可以通过控制台日志观察到。</p><figure class="kq kr ks kt fd ku er es paragraph-image"><div class="er es lc"><img src="../Images/4c6fe9ad4ef4e273a3d1bde06eb50bff.png" data-original-src="https://miro.medium.com/v2/resize:fit:1374/format:webp/1*IxIN1Hg_qhcfbm06CMYXvA.png"/></div></figure><p id="cb5a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">确实，即使您的应用程序执行不必要的<strong class="ih hj">重新呈现</strong>，协调过程也会解决问题。但是，想想一个有大量子组件的大组件试图进行不必要的重新渲染。然后，我们应该考虑一些可能影响性能的方面，如以下原因。</p><ul class=""><li id="7427" class="jd je hi ih b ii ij im in iq jf iu jg iy jh jc ji jj jk jl bi translated">重新渲染再次执行渲染功能和功能组件</li><li id="1090" class="jd je hi ih b ii jm im jn iq jo iu jp iy jq jc ji jj jk jl bi translated">区分过程将对一大组元素执行</li></ul><p id="8963" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为了克服这个性能问题，react 引入了<strong class="ih hj">备忘录</strong>。</p><h1 id="b6b4" class="jr js hi bd jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko bi translated">备忘录</h1><p id="55cd" class="pw-post-body-paragraph if ig hi ih b ii ld ik il im le io ip iq lf is it iu lg iw ix iy lh ja jb jc hb bi translated">Memo 代表记忆。在 React 中，它所做的是当组件渲染发生时，它将被缓存。当组件试图使用相同属性重新渲染时，将返回缓存的值，而不是执行函数。这有助于具有大量子组件的组件 a 获得显著的性能提升，而这些子组件与重新渲染无关。我们只需将组件包装在“React.memo”中，如下所示。</p><figure class="kq kr ks kt fd ku er es paragraph-image"><div class="er es li"><img src="../Images/e0d6011262247f92fda13ec51a5c2713.png" data-original-src="https://miro.medium.com/v2/resize:fit:830/format:webp/1*bLziSQafarcUm7w3bblqXQ.png"/></div><figcaption class="lj lk et er es ll lm bd b be z dx translated">对 Hello 组件使用 React 备忘录</figcaption></figure><p id="9423" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">假设我们想将显示消息从 App 组件传递给 Hello 组件。我将创建一个 msg 对象，并将其作为道具传递。然后你突然意识到备忘录不起作用了。这是因为备忘录做了一个肤浅的比较。因为每次重新渲染改变一个对象的引用备忘录认为这是一个新的对象。因此，每次父组件呈现时，react 都会呈现 Hello 组件。</p><figure class="kq kr ks kt fd ku er es paragraph-image"><div role="button" tabindex="0" class="kv kw di kx bf ky"><div class="er es ln"><img src="../Images/44b7308e3ab8c4a002c6d13fe74f47ef.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cX03c9A5KtbzjivCMmwE8Q.png"/></div></div><figcaption class="lj lk et er es ll lm bd b be z dx translated">备忘录不起作用</figcaption></figure><p id="2cb1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为了解决这个问题，我们可以传递一个<strong class="ih hj">客户平等</strong> <strong class="ih hj">函数</strong>作为备忘录的参数。然后，如果条件<strong class="ih hj">满足，它应该返回真</strong>表示不重新渲染。返回 false 将重新呈现组件。</p><figure class="kq kr ks kt fd ku er es paragraph-image"><div class="er es lo"><img src="../Images/a487db4adad4112ed32ef18a0620bf94.png" data-original-src="https://miro.medium.com/v2/resize:fit:1158/format:webp/1*PeYnyRNINH6Syfy2ygbRcw.png"/></div><figcaption class="lj lk et er es ll lm bd b be z dx translated">自定义等价函数</figcaption></figure><p id="d11d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">作为这个自定义“areEqual”函数的替代，React 引入了<strong class="ih hj"> useMemo </strong>钩子。当所提供的相关性发生变化时，它还会返回存储的值。</p><figure class="kq kr ks kt fd ku er es paragraph-image"><div class="er es lp"><img src="../Images/a6219d55c28f906ebb248451c1cabaf3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1190/format:webp/1*T_i1Vsp6Jq-8CcEMGpSRrg.png"/></div><figcaption class="lj lk et er es ll lm bd b be z dx translated">使用备忘录用法</figcaption></figure><p id="7a80" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">由于以下原因，React 没有将备忘录作为默认实施。</p><ul class=""><li id="6e60" class="jd je hi ih b ii ij im in iq jf iu jg iy jh jc ji jj jk jl bi translated">对于小组件来说，这并不真正有益。相反，它还额外执行一些比较功能。</li><li id="fbd1" class="jd je hi ih b ii jm im jn iq jo iu jp iy jq jc ji jj jk jl bi translated">内存消耗</li></ul><p id="10db" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">所以使用 ReactMemo 是有机会成本的。到处用 memo 不是一个好的解决办法。因此，更好的办法是了解何时使用备忘录。以下是备忘录有用的几种情况</p><ul class=""><li id="1267" class="jd je hi ih b ii ij im in iq jf iu jg iy jh jc ji jj jk jl bi translated">如果组件为相似的道具呈现相同的内容</li><li id="a646" class="jd je hi ih b ii jm im jn iq jo iu jp iy jq jc ji jj jk jl bi translated">如果内容以高频率呈现(例如:股票数据更新)</li><li id="beb4" class="jd je hi ih b ii jm im jn iq jo iu jp iy jq jc ji jj jk jl bi translated">如果一个部件相当重</li></ul></div></div>    
</body>
</html>