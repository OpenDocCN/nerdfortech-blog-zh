<html>
<head>
<title>Preprocessing the data</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">预处理数据</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/preprocessing-the-data-536d4a5ed358?source=collection_archive---------10-----------------------#2021-05-19">https://medium.com/nerd-for-tech/preprocessing-the-data-536d4a5ed358?source=collection_archive---------10-----------------------#2021-05-19</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="f463" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在这篇博客中，让我们讨论所有的预处理方法。这个博客可能看起来很大，但它非常有效。</p><p id="2e0a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">数据的质量决定了机器学习算法的性能。质量是指预处理后的数据。因此，预处理对于建立模型是非常必要的。</p><p id="c7ca" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">下面是预处理的方法，</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es jd"><img src="../Images/59b557ce7268a5b06e460f209c3b12d8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dt50zfxoJ3yLDdwH7LnmCg.png"/></div></div><figcaption class="jp jq et er es jr js bd b be z dx translated">各种预处理方法</figcaption></figure><h1 id="66f5" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">1.处理缺失值:</h1><p id="52f7" class="pw-post-body-paragraph if ig hi ih b ii kr ik il im ks io ip iq kt is it iu ku iw ix iy kv ja jb jc hb bi translated">大多数机器学习算法不支持空值数据。所以需要处理空值</p><h2 id="1363" class="kw ju hi bd jv kx ky kz jz la lb lc kd iq ld le kh iu lf lg kl iy lh li kp lj bi translated">1.1-插补</h2><p id="5039" class="pw-post-body-paragraph if ig hi ih b ii kr ik il im ks io ip iq kt is it iu ku iw ix iy kv ja jb jc hb bi translated">插补是用替代值替换缺失数据的过程。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es lk"><img src="../Images/bb8bab5f785aa7808595c7abd7b6390d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*O3Rfh_Yyu-VblSLo_8BwiA.png"/></div></div><figcaption class="jp jq et er es jr js bd b be z dx translated">平均插补</figcaption></figure><p id="1377" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">被替代的值是均值，它的<strong class="ih hj">均值插补</strong></p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es ll"><img src="../Images/36dc0589a703e2e9a2650efccebded03.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gRmLjKn-19EfIT4vUuiVGQ.png"/></div></div><figcaption class="jp jq et er es jr js bd b be z dx translated">中位数插补</figcaption></figure><p id="5de4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果替代值是中位数，则其<strong class="ih hj">中位数插补</strong></p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es lm"><img src="../Images/a5d188da24564556b1e4a95ec6121c08.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5dRwkXgbnp5ZzU8xwoW09g.png"/></div></div><figcaption class="jp jq et er es jr js bd b be z dx translated">模式插补</figcaption></figure><p id="60a1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果替代值为众数，则为众数插补。</p><h2 id="d568" class="kw ju hi bd jv kx ky kz jz la lb lc kd iq ld le kh iu lf lg kl iy lh li kp lj bi translated">1.2-以缺失值为目标的列预测:</h2><p id="9348" class="pw-post-body-paragraph if ig hi ih b ii kr ik il im ks io ip iq kt is it iu ku iw ix iy kv ja jb jc hb bi translated">将具有缺失值的属性视为目标，其余属性视为要素，然后预测该目标并替换缺失值。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es ln"><img src="../Images/86d51fbc7232f8647193a893a3cdaf39.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4pHL0xqlvho0CooJDC2Arw.png"/></div></div></figure><p id="91c8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这里，我们可以通过将身高作为目标属性来预测身高。</p><h2 id="7986" class="kw ju hi bd jv kx ky kz jz la lb lc kd iq ld le kh iu lf lg kl iy lh li kp lj bi translated">1.3-省略列:</h2><p id="3b11" class="pw-post-body-paragraph if ig hi ih b ii kr ik il im ks io ip iq kt is it iu ku iw ix iy kv ja jb jc hb bi translated">当一个特定的列有超过 50%的缺失值时，我们可以忽略它。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es lo"><img src="../Images/94f4da348ffdd1a1ce26f452a7c8f6e1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LS8Sl1ObdzWuMQ3Wm9zk8A.png"/></div></div></figure><h2 id="ad6d" class="kw ju hi bd jv kx ky kz jz la lb lc kd iq ld le kh iu lf lg kl iy lh li kp lj bi translated">1.4-创建类别:</h2><p id="2fd1" class="pw-post-body-paragraph if ig hi ih b ii kr ik il im ks io ip iq kt is it iu ku iw ix iy kv ja jb jc hb bi translated">最常见和最流行的方法是将分类列中缺失的值建模为一个新的类别，称为<strong class="ih hj">“未知”</strong></p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es lp"><img src="../Images/2bf42e15cef56ec7e1a5f57496cdc97e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Dz6gsrKRoqVFBZBxGZQ9RA.png"/></div></div><figcaption class="jp jq et er es jr js bd b be z dx translated">创建类别</figcaption></figure><p id="7054" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在这里，您可以看到缺失值被归类为未知。</p><h2 id="b002" class="kw ju hi bd jv kx ky kz jz la lb lc kd iq ld le kh iu lf lg kl iy lh li kp lj bi translated">1.5-继续使用支持缺失值的算法:</h2><p id="50e8" class="pw-post-body-paragraph if ig hi ih b ii kr ik il im ks io ip iq kt is it iu ku iw ix iy kv ja jb jc hb bi translated">我们可以使用某些支持数据中缺失值的机器学习算法。</p><h1 id="d5c4" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">2.功能选择:</h1><p id="e2ee" class="pw-post-body-paragraph if ig hi ih b ii kr ik il im ks io ip iq kt is it iu ku iw ix iy kv ja jb jc hb bi translated">要素选择是选择对您感兴趣的预测变量或输出贡献最大的要素的过程。</p><p id="fbd1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">数据中包含不相关的要素会降低模型的准确性，并使模型基于不相关的要素进行学习。</p><p id="ba8d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果数据集包含 100 个要素，我们无法全部处理。会消耗更多的时间。因此，需要选择一个对预测变量或输出贡献最大的重要特征。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es lq"><img src="../Images/9672296186fcb9fe3fa13a21811415f1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gXLKmCWxomdgLHUuZDRfdA.png"/></div></div></figure><h2 id="c214" class="kw ju hi bd jv kx ky kz jz la lb lc kd iq ld le kh iu lf lg kl iy lh li kp lj bi translated"><strong class="ak">2.1-过滤方法:</strong></h2><p id="0efd" class="pw-post-body-paragraph if ig hi ih b ii kr ik il im ks io ip iq kt is it iu ku iw ix iy kv ja jb jc hb bi translated">它测量特征(独立变量)的相关性，并且比包装器方法更快，因为它们不涉及训练模型。</p><p id="86ce" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">2 . 1 . 1-相关性:</strong></p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es lr"><img src="../Images/d5cb1daa1986d8b8fb8523648e536957.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AwpdVQPBg7kuN1WPVDHeSw.png"/></div></div></figure><p id="ecd5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这里，随着指定的增加，年收入和月收入增加。</p><p id="f6f5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我在单独的博客中讨论了相关性</p><div class="ls lt ez fb lu lv"><a rel="noopener follow" target="_blank" href="/nerd-for-tech/correlation-and-types-1812c058159d"><div class="lw ab dw"><div class="lx ab ly cl cj lz"><h2 class="bd hj fi z dy ma ea eb mb ed ef hh bi translated">相关性和类型</h2><div class="mc l"><h3 class="bd b fi z dy ma ea eb mb ed ef dx translated">相关性是定量/定性变量之间的关系</h3></div><div class="md l"><p class="bd b fp z dy ma ea eb mb ed ef dx translated">medium.com</p></div></div><div class="me l"><div class="mf l mg mh mi me mj jn lv"/></div></div></a></div><p id="330d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> 2.1.2 卡方检验:</strong></p><p id="2cc8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">相关性是关于两个连续变量之间的线性关系。卡方通常是关于两个分类变量的独立性。</p><p id="5e9d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">了解博客下面可变访问的类型</p><div class="ls lt ez fb lu lv"><a rel="noopener follow" target="_blank" href="/nerd-for-tech/types-of-variables-cc44a85507c1"><div class="lw ab dw"><div class="lx ab ly cl cj lz"><h2 class="bd hj fi z dy ma ea eb mb ed ef hh bi translated">变量的类型</h2><div class="mc l"><h3 class="bd b fi z dy ma ea eb mb ed ef dx translated">每当我们构建一个 Ml 模型时，我们需要了解数据集中的变量，以决定使用哪个 ML 模型…</h3></div><div class="md l"><p class="bd b fp z dy ma ea eb mb ed ef dx translated">medium.com</p></div></div><div class="me l"><div class="mk l mg mh mi me mj jn lv"/></div></div></a></div><p id="e20a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">它表明一个分类变量的值是否依赖于另一个分类变量的值。卡方有助于衡量关系。</p><p id="a62b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> 2.1.3-LDA: </strong></p><p id="a577" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">LDA 是一种降维技术。它减少了数据集中的维度(即变量)数量，同时尽可能多地保留信息。</p><p id="c641" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">对于分类问题更有利。</p><p id="236d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">2 . 1 . 4-方差分析:</strong></p><p id="9441" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">ANOVA——方差分析</p><p id="7bde" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">特征变量的方差决定了它对响应方差的影响程度。</p><p id="9d73" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果方差较低，则意味着该特性对响应没有影响，反之亦然。</p><h2 id="3d9d" class="kw ju hi bd jv kx ky kz jz la lb lc kd iq ld le kh iu lf lg kl iy lh li kp lj bi translated">2.2-包装方法:</h2><p id="f4db" class="pw-post-body-paragraph if ig hi ih b ii kr ik il im ks io ip iq kt is it iu ku iw ix iy kv ja jb jc hb bi translated"><strong class="ih hj">2 . 2 . 1-正向选择:</strong></p><p id="a330" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这是从没有特征开始的迭代方法。在每次迭代中，不断添加最能改进我们模型的特性。如果添加一个新的变量不能提高模型的性能，则删除该变量。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es ml"><img src="../Images/5c541ddae33f4103896408b99c0a11a9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*u_AQdLcmFxOq5IeXQedFnQ.png"/></div></div><figcaption class="jp jq et er es jr js bd b be z dx translated">预选</figcaption></figure><p id="8a2a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在这里，我们在每次迭代时都将每个变量添加到模型中，在第 4 次迭代时，当我们添加 c4 时，模型的性能会降低，因此我们不应该使用该变量，所以我们跳过了。</p><p id="08fe" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">2 . 2 . 2-反向淘汰:</strong></p><p id="af62" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">正向选择的逆向过程就是逆向淘汰。是从所有特征开始的迭代方法。</p><p id="d0cc" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这个过程删除了在每次迭代中降低模型性能的最不重要的变量。</p><p id="390a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">重复该过程，直到在去除特征时没有观察到改进。</p><p id="8832" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">2 . 2 . 3-递归特征消除:</strong></p><p id="9fed" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这是一个贪婪的优化算法，旨在找到最佳性能的特征子集。</p><p id="bb01" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这个过程重复地创建模型，并在每次迭代中保留性能最好或最差的特性。它用剩下的特征构造下一个模型，直到所有的特征都用完。</p><p id="5367" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这种方法根据要素被消除的顺序对其进行排序。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es ml"><img src="../Images/79764ba3c64524231d23e85798cc1a4d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fzV6b14xLtlFCnRlW71Cxw.png"/></div></div><figcaption class="jp jq et er es jr js bd b be z dx translated">反向特征消除</figcaption></figure><h2 id="aa9a" class="kw ju hi bd jv kx ky kz jz la lb lc kd iq ld le kh iu lf lg kl iy lh li kp lj bi translated">2.2-嵌入式方法:</h2><p id="c57e" class="pw-post-body-paragraph if ig hi ih b ii kr ik il im ks io ip iq kt is it iu ku iw ix iy kv ja jb jc hb bi translated"><strong class="ih hj">套索和岭回归:</strong></p><p id="1e4d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这是降低模型复杂性和防止过度拟合的简单技术。</p><p id="aad5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">以免在单独的博客中讨论山脊和套索。</p><h1 id="2eb9" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">3-删除重复项:</h1><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es mm"><img src="../Images/40d7ef1aa363e3c0757d8097796cf141.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*J6cP1m91yXkQn2urzWDwgA.png"/></div></div></figure><p id="9d80" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在训练监督算法时，通常的假设是，</p><ol class=""><li id="e919" class="mn mo hi ih b ii ij im in iq mp iu mq iy mr jc ms mt mu mv bi translated">数据点是独立且同分布的。</li><li id="1c5e" class="mn mo hi ih b ii mw im mx iq my iu mz iy na jc ms mt mu mv bi translated">训练和测试数据是从同一个分布中抽取的。</li></ol><p id="1bf0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">根据这些假设，您不应该丢弃相同的数据点。</p><h1 id="761c" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">4.数据争论:</h1><p id="26c3" class="pw-post-body-paragraph if ig hi ih b ii kr ik il im ks io ip iq kt is it iu ku iw ix iy kv ja jb jc hb bi translated">数据争论或管理是将原始数据清理、结构化并丰富为所需格式的过程，以便在更短的时间内做出更好的决策。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es nb"><img src="../Images/ba0e0d2688214921a75a9f5a42c56ae3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3hm3oeW6mhEPkuLlhbntDQ.png"/></div></div></figure><p id="9d88" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">希望这个博客能给数据预处理提供一个好主意。我会试着解释新博客中的每一个话题。</p><p id="3af5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">谢谢你！:-)</p></div></div>    
</body>
</html>