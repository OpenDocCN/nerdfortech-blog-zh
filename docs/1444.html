<html>
<head>
<title>A Non-Scary Introduction to The Wondrous World of Git</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">对 Git 奇妙世界的简单介绍</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/a-non-scary-introduction-to-the-wondrous-world-of-git-eb213643a4e8?source=collection_archive---------7-----------------------#2021-03-19">https://medium.com/nerd-for-tech/a-non-scary-introduction-to-the-wondrous-world-of-git-eb213643a4e8?source=collection_archive---------7-----------------------#2021-03-19</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="d710" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">你需要知道的 Git 命令，简单解释，有动手的例子！</h2></div><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ix"><img src="../Images/9254247343327a35a3b67406b9c8b5d0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vvj_erU5iYqN3q3pxQotiw.png"/></div></div></figure><p id="092d" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">无论你选择哪种编程语言，也无论你为哪家公司工作，你都会使用 Git。</p><p id="eaac" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">我在 AliceCode 做志愿者，教十几岁的女孩编程。上个月，我向我的团队介绍了 Git，在看到他们努力之后，我注意到了一个新手不理解的所有事情(还没有！)</p><p id="3892" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">在这篇博文中，我们将学习基本的 git 命令，并看到它们的实际应用。动手意味着它涉及积极参与/使用，而不仅仅是理论。</p><p id="1996" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">与其他教程相比，对我来说，展示与 git 的通信流，以及当您认为可以工作的命令不工作时的样子是很重要的。</p><p id="15c7" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">为了便于访问，这里有一个目录:</p><pre class="iy iz ja jb fd kf kg kh ki aw kj bi"><span id="e4e6" class="kk kl hi kg b fi km kn l ko kp"><a class="ae kq" href="#ad79" rel="noopener ugc nofollow">Let's Start With The Basics</a><br/>  <a class="ae kq" href="#ec68" rel="noopener ugc nofollow">Hello world, this is the command-line</a><br/>  <a class="ae kq" href="#a5be" rel="noopener ugc nofollow">Creating the Initial State</a><br/><a class="ae kq" href="#99f9" rel="noopener ugc nofollow">Story Time + Hands-on</a></span></pre><p id="752c" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">下面是我们将要讨论的命令列表:</p><pre class="iy iz ja jb fd kf kg kh ki aw kj bi"><span id="ad9a" class="kk kl hi kg b fi km kn l ko kp">git init<br/>git clone<br/>git add<br/>git commit<br/>git push<br/>git branch<br/>git checkout<br/>git status<br/>git log<br/>git fetch</span></pre><p id="9ec6" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">我们可以开始了吗？</p><h1 id="ad79" class="kr kl hi bd ks kt ku kv kw kx ky kz la io lb ip lc ir ld is le iu lf iv lg lh bi translated">让我们从基础开始</h1><p id="76f4" class="pw-post-body-paragraph jj jk hi jl b jm li ij jo jp lj im jr js lk ju jv jw ll jy jz ka lm kc kd ke hb bi translated"><a class="ae kq" href="https://git-scm.com/" rel="noopener ugc nofollow" target="_blank"> <strong class="jl hj"> <em class="ln"> Git </em> </strong> </a>是一个版本控制系统，可以让你管理和跟踪你的源代码历史。<br/><a class="ae kq" href="https://github.com/" rel="noopener ugc nofollow" target="_blank"><strong class="jl hj"><em class="ln">GitHub</em></strong></a><strong class="jl hj"><em class="ln"/></strong>是一家使用 Git 进行软件开发和版本控制的互联网托管提供商。<br/>如果你有另一台主机，你可以使用<strong class="jl hj"> Git </strong>而不用<strong class="jl hj"> GitHub </strong>，但这里我们将使用 GitHub。</p><p id="d78e" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">Git 可以变得很复杂，每个命令都有几个<strong class="jl hj"> <em class="ln">命令行</em> </strong> <strong class="jl hj"> <em class="ln">标志</em> </strong>和选项，但今天只是简单介绍一下基础知识！</p><h2 id="ec68" class="kk kl hi bd ks lo lp lq kw lr ls lt la js lu lv lc jw lw lx le ka ly lz lg ma bi translated">你好，世界，这是命令行</h2><p id="682d" class="pw-post-body-paragraph jj jk hi jl b jm li ij jo jp lj im jr js lk ju jv jw ll jy jz ka lm kc kd ke hb bi translated"><strong class="jl hj">命令行界面</strong> (CLI)是您电脑上的一个程序，允许您创建和删除文件、运行程序以及浏览文件夹和文件。在 Mac 上叫<strong class="jl hj">终端</strong>，在 Windows 上叫<strong class="jl hj">命令提示符</strong>。不管你使用哪种操作系统，通常都称它为终端，我也是这样做的。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es mb"><img src="../Images/cef3b8e835a9cedb3923027f777a2209.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*zlkpMj-eTrxW31iw.png"/></div></div><figcaption class="mc md et er es me mf bd b be z dx translated">现在<em class="mg">你知道我在创建本教程时在哪个操作系统上工作；)</em></figcaption></figure><p id="773b" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated"><strong class="jl hj"> <em class="ln">命令行标志</em> </strong>是为命令行程序指定选项的常用方式，通常是用一个连字符或两个连字符。比如:<code class="du mh mi mj kg b">git commit -m "message"</code> - &gt; -m 是表示提交消息的标志，“消息”是消息本身。</p><p id="33a3" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">使用终端时您应该知道的事情:</p><ul class=""><li id="e63e" class="mk ml hi jl b jm jn jp jq js mm jw mn ka mo ke mp mq mr ms bi translated"><code class="du mh mi mj kg b">mkdir</code>创建一个目录(文件夹)</li><li id="783a" class="mk ml hi jl b jm mt jp mu js mv jw mw ka mx ke mp mq mr ms bi translated"><code class="du mh mi mj kg b">cd &lt;DIRECTORY&gt;</code>进入文件夹内</li><li id="51bf" class="mk ml hi jl b jm mt jp mu js mv jw mw ka mx ke mp mq mr ms bi translated"><code class="du mh mi mj kg b">./</code>是当前目录，<code class="du mh mi mj kg b">../</code>是父目录，所以您可能会看到这样的文件名:<code class="du mh mi mj kg b">./file_in_current_folder.txt</code></li><li id="1f8d" class="mk ml hi jl b jm mt jp mu js mv jw mw ka mx ke mp mq mr ms bi translated">键盘上的<strong class="jl hj"> ↑、↓ </strong>将让您导航之前的命令</li><li id="8754" class="mk ml hi jl b jm mt jp mu js mv jw mw ka mx ke mp mq mr ms bi translated"><strong class="jl hj">选项卡</strong>键将自动完成名称</li></ul><p id="46db" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">比如说:</p><pre class="iy iz ja jb fd kf kg kh ki aw kj bi"><span id="0f9b" class="kk kl hi kg b fi km kn l ko kp">PS C:\Projects&gt; mkdir git-hands-on<br/>PS C:\Projects&gt; cd gi&lt;TAB&gt; <strong class="kg hj">–becomes–&gt;</strong> PS C:\Projects&gt; cd git-hands-on<br/>PS C:\Projects\git-hands-on&gt; ↑ <strong class="kg hj">–becomes–&gt;</strong> PS C:\Projects\git-hands-on&gt; cd git-hands-on</span></pre><p id="9a7f" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">我创造了一个现实的场景，你可能会遇到自己。你可以只通过阅读来学习，但我相信它更有教育意义(也更令人愉快！)跟着走。因此，如果你决定动手，请遵循下一节的步骤。<br/>如果没有，可以跳转到<a class="ae kq" href="https://cupofcode.blog/?p=653&amp;preview=true&amp;_thumbnail_id=655#hands-on" rel="noopener ugc nofollow" target="_blank">后续章节的故事</a>。</p><h2 id="a5be" class="kk kl hi bd ks lo lp lq kw lr ls lt la js lu lv lc jw lw lx le ka ly lz lg ma bi translated">创建初始状态</h2><p id="f49b" class="pw-post-body-paragraph jj jk hi jl b jm li ij jo jp lj im jr js lk ju jv jw ll jy jz ka lm kc kd ke hb bi translated">首先你需要安装 git ( <a class="ae kq" href="https://www.youtube.com/watch?v=2j7fD92g-gE" rel="noopener ugc nofollow" target="_blank">这里</a>是 Windows 的教程)并注册<a class="ae kq" href="https://github.com/" rel="noopener ugc nofollow" target="_blank"> GitHub </a>。</p><p id="4cec" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">之后，您需要创建一个类似于我的例子中的项目。为此，您需要:</p><ol class=""><li id="9ea1" class="mk ml hi jl b jm jn jp jq js mm jw mn ka mo ke my mq mr ms bi translated">创建一个新文件夹，命名为<code class="du mh mi mj kg b">git-hands-on</code></li><li id="c526" class="mk ml hi jl b jm mt jp mu js mv jw mw ka mx ke my mq mr ms bi translated">进入<code class="du mh mi mj kg b">git-hands-on</code>文件夹，创建三个文件:<code class="du mh mi mj kg b">Loris_file.txt</code>、<code class="du mh mi mj kg b">Olivias_file.txt</code>和<code class="du mh mi mj kg b">mutual_file.txt</code></li><li id="d3fb" class="mk ml hi jl b jm mt jp mu js mv jw mw ka mx ke my mq mr ms bi translated">在 GitHub 中，创建一个新的存储库，命名为“<em class="ln"> git-hands-on </em>”。</li><li id="0e85" class="mk ml hi jl b jm mt jp mu js mv jw mw ka mx ke my mq mr ms bi translated">在终端中打开你的项目文件夹(打开终端并<code class="du mh mi mj kg b">cd</code>到你的项目文件夹)。</li><li id="d370" class="mk ml hi jl b jm mt jp mu js mv jw mw ka mx ke my mq mr ms bi translated">按照 GitHub 提供的快速设置:(别忘了把<code class="du mh mi mj kg b">&lt;USERNAME&gt;</code>改成你的 GitHub 用户名！)</li></ol><pre class="iy iz ja jb fd kf kg kh ki aw kj bi"><span id="51b1" class="kk kl hi kg b fi km kn l ko kp">git init<br/>git add .<br/>git commit -m “first commit”<br/>git branch -M main<br/>git remote add origin https://github.com/&lt;USERNAME&gt;/git-hands-on.git<br/>git push -u origin main</span></pre><p id="eec5" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">这是做什么的？我会告诉你，但是每个命令在博客中都有自己的部分，所以不要担心！让我们从所有的 git 命令都以<code class="du mh mi mj kg b">git</code>开始说起。</p><ol class=""><li id="0c1a" class="mk ml hi jl b jm jn jp jq js mm jw mn ka mo ke my mq mr ms bi translated"><code class="du mh mi mj kg b">git init</code>在你的项目上初始化 git。需要明确的是，这只会发生在项目的创建中，而不会发生在克隆中！所以当你在一个现有的项目上工作时，你不需要做这一步。</li><li id="96ab" class="mk ml hi jl b jm mt jp mu js mv jw mw ka mx ke my mq mr ms bi translated"><code class="du mh mi mj kg b">git add .</code>将所有文件添加到提交中(我们将详细讨论)。</li><li id="a398" class="mk ml hi jl b jm mt jp mu js mv jw mw ka mx ke my mq mr ms bi translated"><code class="du mh mi mj kg b">git commit -m “first commit"</code>在本地保存更改<strong class="jl hj">，并显示消息“首次提交”。本地<em class="ln">是什么意思？这是一个很好的问题，我将在动手操作部分回答它！</em></strong></li><li id="66d7" class="mk ml hi jl b jm mt jp mu js mv jw mw ka mx ke my mq mr ms bi translated"><code class="du mh mi mj kg b">git branch -M main</code>将创建一个名为<code class="du mh mi mj kg b">main</code>的远程分支。(什么是分支？你会看到的！)</li><li id="a959" class="mk ml hi jl b jm mt jp mu js mv jw mw ka mx ke my mq mr ms bi translated"><code class="du mh mi mj kg b">git remote add origin</code>将本地目录连接到远程 git 存储库。</li><li id="0e71" class="mk ml hi jl b jm mt jp mu js mv jw mw ka mx ke my mq mr ms bi translated"><code class="du mh mi mj kg b">git push -u origin main</code>将提交推送到远程主分支。</li></ol><p id="2282" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">之后，在 GitHub 中，我们会看到这个:</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es mz"><img src="../Images/27a5bb375a380f768a400d2b6d653a03.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*QzkKXjeJUAbyoR5g.png"/></div></div></figure><p id="066b" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">点击提交<em class="ln">第一次提交</em>将显示我们的文本文件:<code class="du mh mi mj kg b">Loris_file.txt</code>、<code class="du mh mi mj kg b">Olivias_file.txt</code>和<code class="du mh mi mj kg b">mutual_file.txt</code>。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es na"><img src="../Images/91ab645bb623e59f217930fb3594fdd2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*17pTzMaEIa-OS1gK.png"/></div></div></figure><p id="1f69" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">所以你已经知道我们的故事围绕着奥利维亚和萝莉。我使用一个 GitHub 帐号，但是我想模仿两个不同的女人在两台不同的电脑上工作。为此，我将在我的计算机上创建两个目录(=文件夹)，并且我将以作者的名字开始每条提交消息。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es nb"><img src="../Images/7144f613f681c32b05d914395982d162.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*GBJYkakywjejKR1c.png"/></div></div></figure><p id="de36" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">重要提示:尽管我将解释我们在这里会遇到的每个命令和响应，但我还是强烈建议您阅读每个命令的完整响应。大多数情况下，输出——尤其是错误消息——会提供您需要的所有信息！</p><p id="8108" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">现在我们准备开始了！想听故事吗？</p><h1 id="99f9" class="kr kl hi bd ks kt ku kv kw kx ky kz la io lb ip lc ir ld is le iu lf iv lg lh bi translated">故事时间！</h1><p id="5959" class="pw-post-body-paragraph jj jk hi jl b jm li ij jo jp lj im jr js lk ju jv jw ll jy jz ka lm kc kd ke hb bi translated">认识一下奥利维亚和罗莉，她们在同一个团队工作。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es nc"><img src="../Images/5a624d0274d34c4adc7e8931a31733e1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*rQXJzplOynxFrwiT.png"/></div></div></figure><p id="1e39" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">Lori 和 Olivia 开始着手一个名为<code class="du mh mi mj kg b">git-hands-on</code>的项目，该项目有一个分支<code class="du mh mi mj kg b">main</code>。<br/>克隆项目后，他们将开始使用不同的方法工作:<br/> <strong class="jl hj">萝莉</strong>将在她的本地<code class="du mh mi mj kg b">main</code>分支上工作，当她完成后将推送到远程<code class="du mh mi mj kg b">main</code>。<br/> <strong class="jl hj"> Olivia </strong>将创建她自己的分支，也将该分支推送到远程，并且将更新它而不是<code class="du mh mi mj kg b">main</code>。当她完成时— <strong class="jl hj">奥利维亚</strong>会将完成的代码推送到<code class="du mh mi mj kg b">main</code>。萝莉会更快完成，这意味着她不会遇到任何冲突——但<strong class="jl hj">奥利维亚</strong>会！</p><p id="811d" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">听起来很复杂？！不要担心，到这篇博文结束时，事情会变得简单起来！</p><h2 id="d131" class="kk kl hi bd ks lo lp lq kw lr ls lt la js lu lv lc jw lw lx le ka ly lz lg ma bi translated">故事情节</h2><p id="9017" class="pw-post-body-paragraph jj jk hi jl b jm li ij jo jp lj im jr js lk ju jv jw ll jy jz ka lm kc kd ke hb bi translated">因此，让我们明确一下我们今天将看到的内容:</p><pre class="iy iz ja jb fd kf kg kh ki aw kj bi"><span id="5f0f" class="kk kl hi kg b fi km kn l ko kp">1. <a class="ae kq" href="#9a47" rel="noopener ugc nofollow">Lori - clones the project</a><br/>2. <a class="ae kq" href="#3560" rel="noopener ugc nofollow">Olivia - creates her own branch: dev/olivia</a><br/>3. <a class="ae kq" href="#2e73" rel="noopener ugc nofollow">Lori - add, commit, push changes to remote main</a><br/>4. <a class="ae kq" href="#e592" rel="noopener ugc nofollow">Olivia - pulls Lori's changes from remote main</a><br/>5. <a class="ae kq" href="#39c2" rel="noopener ugc nofollow">Olivia - add, commit, push changes to remote dev/olivia</a><br/>6. <a class="ae kq" href="#f492" rel="noopener ugc nofollow">Lori and Olivia update the same file</a><br/>7. <a class="ae kq" href="#6b2f" rel="noopener ugc nofollow">Olivia - facing and fixing conflicts!</a></span></pre><p id="b332" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">你准备好开始了吗！？</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es nd"><img src="../Images/1fb30d781e8f9229d07c87a68b0978ea.png" data-original-src="https://miro.medium.com/v2/resize:fit:1100/format:webp/0*FL9BT2kSwu3ENttd.jpg"/></div></figure><h1 id="9a47" class="kr kl hi bd ks kt ku kv kw kx ky kz la io lb ip lc ir ld is le iu lf iv lg lh bi translated">1.Lori 克隆了这个项目</h1><pre class="iy iz ja jb fd kf kg kh ki aw kj bi"><span id="46f6" class="kk kl hi kg b fi km kn l ko kp">git clone https://github.com/&lt;USERNAME&gt;/REPOSITORY</span></pre><p id="1db2" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">GitHub 里有个项目叫<em class="ln"> git-hands-on </em>。奥利维亚和罗莉需要把它克隆到他们的电脑上，这样他们就可以开始工作了！考虑到<strong class="jl hj">远程</strong> ( <code class="du mh mi mj kg b">main</code>)上只有一个分支，默认为女性会有一个<strong class="jl hj">本地</strong> <code class="du mh mi mj kg b">main</code>分支。</p><p id="ba8c" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">当您用<code class="du mh mi mj kg b">git clone</code>克隆一个存储库时，它会自动创建一个名为<em class="ln"> origin </em>的<strong class="jl hj">远程</strong>连接，指向 GitHub 中克隆的存储库。这意味着我们有一个名为<code class="du mh mi mj kg b">origin main</code>的主分支的远程版本。有时我会说<code class="du mh mi mj kg b">remote</code>，有时我会说<code class="du mh mi mj kg b">origin</code>，但我的意思是一样的。</p><p id="be45" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">对于 Olivia 和 Lori 来说，这一步看起来是一样的，所以让我们看看 Lori 是怎么做的:</p><h1 id="4708" class="kr kl hi bd ks kt ku kv kw kx ky kz la io lb ip lc ir ld is le iu lf iv lg lh bi translated">洛里的终端:</h1><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ne"><img src="../Images/cec5e02a8e4362e0aca6ea05155d59c2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2-AbzmFYjR64zn-HX7MK0A.png"/></div></div></figure><p id="8f72" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">注意，克隆完成后，洛里用<code class="du mh mi mj kg b">cd .\git-hands-on\</code>命令进入了<code class="du mh mi mj kg b">git-hands-on</code>文件夹。使用<code class="du mh mi mj kg b">ls</code>我们可以看到目录的内容，在我们的例子中是三个文本文件。</p><p id="8728" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">Olivia 也做了同样的事情，现在我们在远程(GitHub 中)和本地的每台笔记本电脑上都有 main。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es nc"><img src="../Images/2de59ffa3ad92d9962350ab164c5ba85.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*YIukd41OYEgH8d57.png"/></div></div></figure><h1 id="3560" class="kr kl hi bd ks kt ku kv kw kx ky kz la io lb ip lc ir ld is le iu lf iv lg lh bi translated">2.Olivia——创建自己的分支:dev/olivia</h1><p id="12f0" class="pw-post-body-paragraph jj jk hi jl b jm li ij jo jp lj im jr js lk ju jv jw ll jy jz ka lm kc kd ke hb bi translated">创建一个新的分支有几个原因:有时根据作者来分离(正如您将在本例中看到的)，有时根据特性。如果你想得到某人的帮助，这也很好:他们可以提取你的分支，以及你所有的修改，并在他们的本地计算机上运行它。</p><p id="1268" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">所以奥利维亚想创建自己的分支机构:</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es nf"><img src="../Images/5283de891b270fe1c07e055e60024647.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JUcQ_VjdRsdVeakhqWGcjQ.png"/></div></div></figure><p id="f71f" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">我们在这里看到了什么？</p><ol class=""><li id="0b09" class="mk ml hi jl b jm jn jp jq js mm jw mn ka mo ke my mq mr ms bi translated"><code class="du mh mi mj kg b">git branch</code>向我们展示本地现有的分支机构。到目前为止我们只有<code class="du mh mi mj kg b">main</code>。</li><li id="0eb7" class="mk ml hi jl b jm mt jp mu js mv jw mw ka mx ke my mq mr ms bi translated"><code class="du mh mi mj kg b">git checkout -b dev/olivia</code>创建一个新的分支<strong class="jl hj">，从我们当前所在的分支</strong>派生而来(在我们的例子中是本地<code class="du mh mi mj kg b">main</code>)。当我说派生时，我的意思是无论本地<code class="du mh mi mj kg b">main</code>发生了什么变化，我们的新分支也会发生变化。</li><li id="bfd9" class="mk ml hi jl b jm mt jp mu js mv jw mw ka mx ke my mq mr ms bi translated"><code class="du mh mi mj kg b">git branch</code>向我们展示了<code class="du mh mi mj kg b">main</code>和<code class="du mh mi mj kg b">dev/olivia</code>。</li><li id="7a20" class="mk ml hi jl b jm mt jp mu js mv jw mw ka mx ke my mq mr ms bi translated"><code class="du mh mi mj kg b">git checkout main</code>会把我们正在做的分支改成<code class="du mh mi mj kg b">main</code>。</li><li id="20bc" class="mk ml hi jl b jm mt jp mu js mv jw mw ka mx ke my mq mr ms bi translated"><code class="du mh mi mj kg b">git checkout noSuchBranch</code>将显示错误，因为您试图切换到不存在的分支。澄清一下，<code class="du mh mi mj kg b">git checkout <strong class="jl hj">-b</strong> &lt;NAME&gt;</code>创建一个新分支，<code class="du mh mi mj kg b">git checkout &lt;NAME&gt;</code>切换到一个分支。</li></ol><p id="2081" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">注意，<code class="du mh mi mj kg b">dev/olivia</code>分支<strong class="jl hj">只存在于 Olivia 的 git 上的本地</strong>，而不在远程。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es nc"><img src="../Images/5d0c20e454ef8a66bc0d9c08e3f2bc40.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*lLj-rQ8pEgxDv6W1.png"/></div></div></figure><h1 id="2e73" class="kr kl hi bd ks kt ku kv kw kx ky kz la io lb ip lc ir ld is le iu lf iv lg lh bi translated">3.Lori —添加、提交、推送对远程 main 的更改</h1><p id="8aff" class="pw-post-body-paragraph jj jk hi jl b jm li ij jo jp lj im jr js lk ju jv jw ll jy jz ka lm kc kd ke hb bi translated">这一步是关于更新远程<code class="du mh mi mj kg b">main</code>分支。这是本教程的一大部分，也是你使用 git 的一大部分。通常，循环是:添加、提交、推送。<code class="du mh mi mj kg b">add</code>添加将要提交的更新，<code class="du mh mi mj kg b">commit</code>提交变更，<code class="du mh mi mj kg b">push</code>推送代码。<code class="du mh mi mj kg b">add, commit, push</code>当我们完成我们的任务，测试它，并且它是好的时候发生！</p><h2 id="d250" class="kk kl hi bd ks lo lp lq kw lr ls lt la js lu lv lc jw lw lx le ka ly lz lg ma bi translated">命令背后的含义</h2><p id="915c" class="pw-post-body-paragraph jj jk hi jl b jm li ij jo jp lj im jr js lk ju jv jw ll jy jz ka lm kc kd ke hb bi translated">有点像寄包裹。你<strong class="jl hj">添加</strong>物品，<strong class="jl hj">将包裹</strong>提交给邮局，<strong class="jl hj">将包裹</strong>推送给员工。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es nb"><img src="../Images/ad61b8b430358deb8a962ac11ae7d64c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*hqA5pvhkPAaRxYR-.png"/></div></div></figure><p id="896f" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">这是一个很好的类比，因为您可以将多个项目添加到同一个包中(<code class="du mh mi mj kg b">git add</code>在<code class="du mh mi mj kg b">git commit</code>之前多次)。<br/>您也可以在同一次就诊中递送多个包裹(<code class="du mh mi mj kg b">git commit</code>多次在<code class="du mh mi mj kg b">git push</code>之前)。</p><p id="89f4" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">建议尽可能多地添加到相同的提交中(在合理的范围内)。没有必要提交你所做的每一个改变。当你完成任务或达到一个有意义的里程碑时，提交它。</p><p id="c47a" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">假设我在三个文件中做了更改:a、b 和 c。我选择哪个选项并不重要:</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ng"><img src="../Images/c92c491d0ba0bfe84f7ba519dd6cd3f2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*q5oPqrET8uT52hPa0BvOvA.png"/></div></div></figure><p id="1fe2" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">输出看起来是一样的:我已经提交了 3 个文件。<br/>还要注意，在同一个命令中添加多个文件是用空格完成的:<code class="du mh mi mj kg b">git add a b c</code>。</p><p id="8913" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">然而，当使用单次/多次提交时，输出是不同的:</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es mz"><img src="../Images/2ef6150a852c72b3b501d25bbd31cb5d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pQsTCqpSvi5VuHSQFQnlLA.png"/></div></div></figure><p id="48fd" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">当您单独提交每个文件时，就像右边的例子一样，您最终会提交三个不同的文件。git 存储库中的多次提交，没有任何好的理由，会变得相当混乱。</p><p id="9de2" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">这也是一个很好的地方来说明提交消息可以帮助你！所以要明智地使用它们，不要写无意义的消息，比如“更新”(更新哪里？！)，“ifat”(哪些文件？哪个功能？)，等等。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es nb"><img src="../Images/1d1e85e96eb7763214b849b2d0a494e7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*byjzhSUnyOzNtj7_.png"/></div></div></figure><p id="943d" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">如果你试图推而不承诺，这就像去邮局寄包裹——没有包裹。如果你试着承诺而不添加，这就像带着一个空盒子来到邮局——他们不会接受的。</p><p id="9c78" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">需要看到才相信？让我们看看当您尝试推送*nothing*或提交*nothing*时会发生什么:</p><pre class="iy iz ja jb fd kf kg kh ki aw kj bi"><span id="3a96" class="kk kl hi kg b fi km kn l ko kp">PS C:\Projects\git-hands-on&gt; <strong class="kg hj">git status</strong><br/>On branch main<br/>Your branch is up to date with ‘origin/main’.</span><span id="4181" class="kk kl hi kg b fi nh kn l ko kp">nothing to commit, working tree clean</span><span id="322d" class="kk kl hi kg b fi nh kn l ko kp">PS C:\Projects\git-hands-on&gt; <strong class="kg hj">git push</strong><br/>Everything up-to-date</span><span id="c222" class="kk kl hi kg b fi nh kn l ko kp">PS C:\Projects\git-hands-on&gt; <strong class="kg hj">git commit -m “empty commit”</strong><br/>On branch main<br/>Your branch is up to date with ‘origin/main’.</span><span id="c725" class="kk kl hi kg b fi nh kn l ko kp">nothing to commit, working tree clean</span></pre><p id="4638" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">你注意到一个我们还没有提到的命令了吗？<code class="du mh mi mj kg b">git status</code>！<br/> <code class="du mh mi mj kg b">git status</code>显示了我们工作的状态:改变的文件，被<strong class="jl hj">添加</strong>到提交的文件，被<strong class="jl hj">提交</strong>的文件，等等。</p><p id="a7bc" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">在我们的例子中，我们有<code class="du mh mi mj kg b">nothing to commit, working tree clean</code>。当我们<em class="ln">试图不顾一切地推动</em>时，它不会做任何事情，因为<code class="du mh mi mj kg b">Everything is up-to-date</code>。</p><p id="115e" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">由于<code class="du mh mi mj kg b">nothing to commit, working tree clean</code>，我们的<em class="ln">尝试提交</em> *nothing*也被阻塞。</p><h2 id="a23f" class="kk kl hi bd ks lo lp lq kw lr ls lt la js lu lv lc jw lw lx le ka ly lz lg ma bi translated">回到故事！</h2><p id="c50e" class="pw-post-body-paragraph jj jk hi jl b jm li ij jo jp lj im jr js lk ju jv jw ll jy jz ka lm kc kd ke hb bi translated">Lori 正在她的本地<code class="du mh mi mj kg b">main</code>分支上工作，现在想要将她的代码推送到<strong class="jl hj">远程 main。</strong></p><p id="387f" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">让我们看看她的终端:</p><div class="iy iz ja jb fd ab cb"><figure class="ni jc nj nk nl nm nn paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><img src="../Images/230a3f9d276f31b42466abf7c3bede01.png" data-original-src="https://miro.medium.com/v2/resize:fit:882/format:webp/1*rEiJtop0OQJ7fKkvg_h4Wg.png"/></div></figure><figure class="ni jc no nk nl nm nn paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><img src="../Images/be836200eb9e764691265b9cff8397ed.png" data-original-src="https://miro.medium.com/v2/resize:fit:1120/format:webp/1*_bGKkGlBbOZqkxwTDFIWEQ.png"/></div></figure></div><p id="b2db" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">那么我们在这里看到了什么？</p><ol class=""><li id="e48b" class="mk ml hi jl b jm jn jp jq js mm jw mn ka mo ke my mq mr ms bi translated"><code class="du mh mi mj kg b">git status</code>只是为了表明还没有发生什么事情。</li><li id="db53" class="mk ml hi jl b jm mt jp mu js mv jw mw ka mx ke my mq mr ms bi translated"><code class="du mh mi mj kg b">Loris_file.txt</code>的变化:我加了<em class="ln">“这里有更新！”</em>文件的结尾。</li><li id="ffec" class="mk ml hi jl b jm mt jp mu js mv jw mw ka mx ke my mq mr ms bi translated"><code class="du mh mi mj kg b">git status</code>向我们展示了还没有提交的变更，这意味着我们还没有用<code class="du mh mi mj kg b">git add</code>添加它们。我们还可以在这里看到哪个文件发生了变化:<code class="du mh mi mj kg b">modified: Loris_file.txt</code></li><li id="b054" class="mk ml hi jl b jm mt jp mu js mv jw mw ka mx ke my mq mr ms bi translated"><code class="du mh mi mj kg b">git diff Loris_file.txt</code>向我们展示了文件中到底发生了什么变化。</li><li id="aab7" class="mk ml hi jl b jm mt jp mu js mv jw mw ka mx ke my mq mr ms bi translated"><code class="du mh mi mj kg b">git add ./Loris_file.txt</code>将文件添加到提交中。</li><li id="784c" class="mk ml hi jl b jm mt jp mu js mv jw mw ka mx ke my mq mr ms bi translated"><code class="du mh mi mj kg b">git status</code>添加后，向我们显示现在有<code class="du mh mi mj kg b">changes to be committed</code>。</li><li id="2799" class="mk ml hi jl b jm mt jp mu js mv jw mw ka mx ke my mq mr ms bi translated"><code class="du mh mi mj kg b">git commit -m ...</code>提交变更，并显示消息<em class="ln">萝莉–更新的洛里斯 _ 文件. txt </em></li><li id="2fff" class="mk ml hi jl b jm mt jp mu js mv jw mw ka mx ke my mq mr ms bi translated"><code class="du mh mi mj kg b">git push ...</code>将 Lori 的提交推送到分支<code class="du mh mi mj kg b">origin main</code></li></ol><p id="0bbf" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated"><strong class="jl hj">这是 Lori 提交后我们的状态:</strong></p><ul class=""><li id="f17c" class="mk ml hi jl b jm jn jp jq js mm jw mn ka mo ke mp mq mr ms bi translated">Olivia 的本地——Olivia 在两个分支中都有原始代码:<code class="du mh mi mj kg b">main</code>和<code class="du mh mi mj kg b">dev/olivia</code></li><li id="f0bf" class="mk ml hi jl b jm mt jp mu js mv jw mw ka mx ke mp mq mr ms bi translated">Lori 是本地的——Lori 对原始代码进行了修改</li><li id="ebce" class="mk ml hi jl b jm mt jp mu js mv jw mw ka mx ke mp mq mr ms bi translated">Remote — <code class="du mh mi mj kg b">origin main</code>在原始代码上有 Lori 的修改</li></ul><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es nc"><img src="../Images/523af58434d99a6ab769143aec26264c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*WYHhnyGHWRnZPkn2.png"/></div></div></figure><h1 id="e592" class="kr kl hi bd ks kt ku kv kw kx ky kz la io lb ip lc ir ld is le iu lf iv lg lh bi translated">4.Olivia —从远程 main 获取 Lori 的更改</h1><p id="d200" class="pw-post-body-paragraph jj jk hi jl b jm li ij jo jp lj im jr js lk ju jv jw ll jy jz ka lm kc kd ke hb bi translated">正如我们在上一节中看到的，Olivia 不再更新代码中的最新变化。一个有趣的方法是让两位女士运行<code class="du mh mi mj kg b">git log</code>命令。<code class="du mh mi mj kg b">git log</code>显示了存储库中不同分支的提交。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ng"><img src="../Images/ef9a8f95d9d15912d559e694a6529f9b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RRue4T0ui7l6nzWmfbNkeg.png"/></div></div></figure><p id="2301" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">先说萝莉的终端。我们可以看到她的 git 知道 3 个分支:origin/main、origin/HEAD 和 local main。老实说，我不知道<code class="du mh mi mj kg b">origin/HEAD</code>有什么故事，但这不重要。我总是在<code class="du mh mi mj kg b">origin/main</code>旁边看到它，所以我们暂时忽略它。</p><p id="508d" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">我们还可以看到<code class="du mh mi mj kg b">origin/main</code>与 Lori 的本地<code class="du mh mi mj kg b">main</code>是最新的，总共有 2 次提交。</p><p id="e620" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">现在，让我们看看奥利维亚的终端:</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es mz"><img src="../Images/d9150b51509d7b993cf25f64a7c27e6e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*r2Dgsk48XKBQ8srwxdfVuA.png"/></div></div></figure><p id="2f63" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">哇哇哇！您是否注意到只有初始提交，但是这里说本地分支与原始主分支是最新的？？？</p><p id="e75c" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">除非 Lori 告诉她，否则 Olivia 知道的唯一方法就是尝试从远程获取更改。这并不意味着奥利维亚需要每五分钟拉一次。理想情况下，奥利维亚会在完成工作后拉，就在推之前。如果奥利维亚在推之前没有拉<strong class="jl hj">——git 将阻止她推。</strong></p><p id="d703" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">另外，请注意，在 Olivia 的终端上，我们看到她有 4 个分支，因为她创建了她的本地<code class="du mh mi mj kg b">dev/olivia</code>。</p><p id="3ade" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">怎样才能让奥利维亚意识到遥控器的变化？</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es np"><img src="../Images/54209a7daf3f56de434fa7889624dff3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BUrHvZMuQZJtGlciu_G9Vg.png"/></div></div></figure><p id="26cf" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">那么，我们这里有什么？</p><ol class=""><li id="453d" class="mk ml hi jl b jm jn jp jq js mm jw mn ka mo ke my mq mr ms bi translated"><code class="du mh mi mj kg b">git pull</code>靠自己没用，因为它不知道从哪里拉！如果我们在<code class="du mh mi mj kg b">main</code>上，这是显而易见的，因为我们从远程主服务器克隆了本地主服务器。<code class="du mh mi mj kg b">dev/olivia</code> branch 是从本地 main“诞生”的，它还没有遥控器。<br/>正如我们从终端看到的，我们可以用命令<code class="du mh mi mj kg b">git branch --set-upstream-to=origin/ dev/olivia</code>定义遥控器。还有另一种方法，你接下来会看到。</li><li id="3c68" class="mk ml hi jl b jm mt jp mu js mv jw mw ka mx ke my mq mr ms bi translated"><code class="du mh mi mj kg b">git pull origin main</code>告诉 git 从哪里拉。我们还可以在这里看到发生了什么变化。</li><li id="b3ee" class="mk ml hi jl b jm mt jp mu js mv jw mw ka mx ke my mq mr ms bi translated"><code class="du mh mi mj kg b">git log</code>，就是为了看和最初<code class="du mh mi mj kg b">git log</code>的区别。在下面的截图中我们会看得更清楚。</li></ol><p id="f550" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">这是奥利维亚的终端拉后:</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ng"><img src="../Images/a8d4246743c1af79939e782d2729c2f3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AO7TBvINALx6eD7XrLaj2A.png"/></div></div></figure><p id="924f" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated"><code class="du mh mi mj kg b">dev/olivia</code>是我们拉入的分支，所以用 origin/main 是最新的。另一方面，本地 main 仍处于初始提交状态。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es nc"><img src="../Images/5a6702cee6729898c63a1f2771dbcd11.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*Qt8bnvWCmqpfZ-8P.png"/></div></div></figure><h1 id="39c2" class="kr kl hi bd ks kt ku kv kw kx ky kz la io lb ip lc ir ld is le iu lf iv lg lh bi translated">5.Olivia —向远程开发人员/olivia 添加、提交、推送更改</h1><p id="cd62" class="pw-post-body-paragraph jj jk hi jl b jm li ij jo jp lj im jr js lk ju jv jw ll jy jz ka lm kc kd ke hb bi translated">既然 Olivia 了解了最新情况，她就继续处理她的文件。完成后，她想远程推送，以备后用。她不能只做<code class="du mh mi mj kg b">git push</code>因为没有<code class="du mh mi mj kg b">origin/dev/olivia</code>。她需要创造一个！</p><p id="0a0c" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">那么，如何创建远程分支呢？有两种方法可以做到。第一种方法是创建一个空的远程分支，然后推送到它。第二种方法是像往常一样创建一个 commit，并使用 push 创建远程分支—这就是我们将在下面看到的:</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es nq"><img src="../Images/b69c1b88c73967c1b47dcf23a1a5f5b7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nxtGnIv-_QmAXbdWai3FRw.png"/></div></div></figure><p id="a7b6" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">那么，我们这里有什么？</p><ol class=""><li id="765e" class="mk ml hi jl b jm jn jp jq js mm jw mn ka mo ke my mq mr ms bi translated">这些我们已经知道了。</li><li id="4a86" class="mk ml hi jl b jm mt jp mu js mv jw mw ka mx ke my mq mr ms bi translated"><code class="du mh mi mj kg b">git push -u origin dev/olivia</code>-u 标志用于<em class="ln">上游</em>，仅在新分支的第一次推送中需要。</li></ol><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="ab fe cl nr"><img src="../Images/05b52f43292629ecce0fe75e53b7af41.png" data-original-src="https://miro.medium.com/v2/format:webp/1*Nhz5Uo8tFkw3kw7mLMIAtg.png"/></div></figure><p id="968b" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">突击测验！在奥利维亚的终端中写下<code class="du mh mi mj kg b">git log</code>后我们会看到什么？提交了多少次，每个分支在哪里？</p><p id="578b" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">让我们看看你是否正确:</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ng"><img src="../Images/de1353dc8074ffee332a1d4f52406dbb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pqIIpl5TS3jMj72FrUQJmQ.png"/></div></div></figure><p id="42cf" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">奥利维亚在<code class="du mh mi mj kg b">dev/olivia</code>上工作，并在从原点总管拉出后将其推至其远程分支<strong class="jl hj">。</strong></p><ul class=""><li id="5bd9" class="mk ml hi jl b jm jn jp jq js mm jw mn ka mo ke mp mq mr ms bi translated">dev/olivia 和 origin/dev/olivia 提交了 3 次，是最新的</li><li id="b0a3" class="mk ml hi jl b jm mt jp mu js mv jw mw ka mx ke mp mq mr ms bi translated">origin/main 有两个提交—初始提交和 Lori 提交</li><li id="3a63" class="mk ml hi jl b jm mt jp mu js mv jw mw ka mx ke mp mq mr ms bi translated">本地 main 只有初始提交</li></ul><h2 id="ab3f" class="kk kl hi bd ks lo lp lq kw lr ls lt la js lu lv lc jw lw lx le ka ly lz lg ma bi translated">有趣的事实:有时 git 是无法解释的</h2><p id="4421" class="pw-post-body-paragraph jj jk hi jl b jm li ij jo jp lj im jr js lk ju jv jw ll jy jz ka lm kc kd ke hb bi translated">好吧，我肯定这是可以解释的，但我不知道为什么会发生下面的事情。好消息是——为了使用 git，你不需要理解所有的事情</p><p id="6f77" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">所以，我想从本地<code class="du mh mi mj kg b">dev/olivia</code>更新<code class="du mh mi mj kg b">origin/main</code>。我原以为一个简单的<code class="du mh mi mj kg b">git push origin main</code>会推送到远程主界面，但是由于某种原因，它尝试了从主界面推送到主界面:<code class="du mh mi mj kg b">! [rejected] main -&gt; main</code>。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ns"><img src="../Images/a6a5d3356fc6eb7d2f2a3ed77486821c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*beMQckrla_V4fmTaKpqKXw.png"/></div></div></figure><p id="67a6" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">那么，如果我们想更新<code class="du mh mi mj kg b">remote main</code>，又无法通过本地<code class="du mh mi mj kg b">dev/olivia</code>来完成，该怎么办呢？我们可以更新<strong class="jl hj">本地</strong> <code class="du mh mi mj kg b">main</code>并从那里推送:</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es nt"><img src="../Images/06c526bef6d1ab2618bbe04ff080e62b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nvAmSnIVEvyIAwMR9jCDRg.png"/></div></div></figure><p id="7ce1" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">我们在这里看到了什么？</p><ol class=""><li id="2f2b" class="mk ml hi jl b jm jn jp jq js mm jw mn ka mo ke my mq mr ms bi translated"><code class="du mh mi mj kg b">git checkout main</code>切换到分支干线。</li><li id="c82e" class="mk ml hi jl b jm mt jp mu js mv jw mw ka mx ke my mq mr ms bi translated"><code class="du mh mi mj kg b">git pull origin dev/olivia</code>更新代码。</li><li id="0f02" class="mk ml hi jl b jm mt jp mu js mv jw mw ka mx ke my mq mr ms bi translated"><code class="du mh mi mj kg b">git push origin main</code>更新远程主分支。</li></ol><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es nb"><img src="../Images/0d92a59cb0de9fb2868adb46e3dc73a7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*gF29SJEXPCmLY_vE.png"/></div></div></figure><p id="fa92" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">现在当 Olivia 写<code class="du mh mi mj kg b">git log</code>时，我们可以看到所有的分支都是最新的。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es nu"><img src="../Images/fafd6988a504fc79f9db9962f785ad4e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AG40DoRVM2YUN4dOb_nVrQ.png"/></div></div></figure><h1 id="f492" class="kr kl hi bd ks kt ku kv kw kx ky kz la io lb ip lc ir ld is le iu lf iv lg lh bi translated">6.Lori 和 Olivia 更新了同一个文件</h1><p id="3c1c" class="pw-post-body-paragraph jj jk hi jl b jm li ij jo jp lj im jr js lk ju jv jw ll jy jz ka lm kc kd ke hb bi translated">您可能已经注意到项目中有一个名为<code class="du mh mi mj kg b">mutual_file.txt</code>的文件。这一步，<strong class="jl hj"> Lori </strong>会更新并推送到<code class="du mh mi mj kg b">origin/main</code>，而<strong class="jl hj"> Olivia </strong>会更新并推送到<code class="du mh mi mj kg b">origin/dev/olivia</code>。</p><p id="769d" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">让我们从奥利维亚开始:</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es np"><img src="../Images/6c6a2591892948f9d7ca5c390aef09a5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3JM__ojnhkihUz_dqRqazA.png"/></div></div></figure><p id="d30a" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">我们在这里看到了什么？</p><ol class=""><li id="c792" class="mk ml hi jl b jm jn jp jq js mm jw mn ka mo ke my mq mr ms bi translated"><code class="du mh mi mj kg b">git checkout dev/olivia</code>切换分支。</li><li id="798b" class="mk ml hi jl b jm mt jp mu js mv jw mw ka mx ke my mq mr ms bi translated"><code class="du mh mi mj kg b">nodepad .\mutual_file.txt</code>在记事本中打开该文件，我们可以进行更改并保存。这只是在终端中显示 Olivia 对文件进行了更改的一种方式。</li><li id="37d8" class="mk ml hi jl b jm mt jp mu js mv jw mw ka mx ke my mq mr ms bi translated">到现在为止，我们对这些已经很熟悉了。</li><li id="8473" class="mk ml hi jl b jm mt jp mu js mv jw mw ka mx ke my mq mr ms bi translated"><code class="du mh mi mj kg b">git branch --set-upstream-to=origin/dev/olivia</code>–之前，我们试图从这个分支推进到<code class="du mh mi mj kg b">origin/main</code>，因此这会将上游设置为 Olivia 的分支。只是为了确保我们能推进到那里。</li><li id="2607" class="mk ml hi jl b jm mt jp mu js mv jw mw ka mx ke my mq mr ms bi translated">最后，老熟人<code class="du mh mi mj kg b">git push</code>。</li></ol><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es nc"><img src="../Images/294b46faf62a1c8c2c9475ad89af44a1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*c2bgrdQ72JiGu7PD.png"/></div></div></figure><p id="c21b" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">在上面的图片中，你可以看到，我在代表提交的圆圈中添加了字母。粉色圆圈是 Lori 提交的，绿色圆圈是 Olivia 提交的。关于信件:<br/> L =对<code class="du mh mi mj kg b">Loris_file.txt</code>的更新<br/> O =对<code class="du mh mi mj kg b">Olivias_file.txt</code>的更新<br/> m =对<code class="du mh mi mj kg b">mutual_file.txt</code>的更新</p><p id="f515" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">奥利维亚的更新很简单。对于萝莉，事情会变得有点棘手。让我们看看她的终端:</p><div class="iy iz ja jb fd ab cb"><figure class="ni jc nv nk nl nm nn paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><img src="../Images/4a1197865adf4fc463ac809a09563556.png" data-original-src="https://miro.medium.com/v2/resize:fit:964/format:webp/1*R12AZmFVQ0o55SUwP4123g.png"/></div></figure><figure class="ni jc nw nk nl nm nn paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><img src="../Images/3cb2771a654155c05f04d00ef4ef2c9b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1038/format:webp/1*s0VA9sIKHpNL_yABMc8Gww.png"/></div></figure></div><p id="98b9" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">那么，我们这里有什么？</p><ol class=""><li id="3b67" class="mk ml hi jl b jm jn jp jq js mm jw mn ka mo ke my mq mr ms bi translated"><code class="du mh mi mj kg b">nodepad .\mutual_file.txt</code>向我们展示 Lori 对文件进行了更改。</li><li id="6b31" class="mk ml hi jl b jm mt jp mu js mv jw mw ka mx ke my mq mr ms bi translated"><code class="du mh mi mj kg b">git add, git commit</code>，我们现在已经很熟悉了。</li><li id="2fbe" class="mk ml hi jl b jm mt jp mu js mv jw mw ka mx ke my mq mr ms bi translated"><code class="du mh mi mj kg b">git status</code>在每个命令之后，我强烈建议您阅读响应。</li><li id="0806" class="mk ml hi jl b jm mt jp mu js mv jw mw ka mx ke my mq mr ms bi translated">最后，<code class="du mh mi mj kg b">git log</code>，看看我们的立场。</li></ol><p id="70fe" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">等一下！！<code class="du mh mi mj kg b">git log</code>显示出一些怪异的东西。我们知道自从提交了<code class="du mh mi mj kg b">Loris_file.txt</code>更新之后<code class="du mh mi mj kg b">origin main</code>已经被更新了。我们知道<strong class="jl hj"> Olivia </strong>从她的分支(<em class="ln">“Olivia-修改的 Olivia 的文件】</em>)推送到<code class="du mh mi mj kg b">origin main</code>的变更！如果<strong class="jl hj">萝莉</strong>推前不拉，更新到最新版本——她的推会被拒绝！！</p><p id="b4a4" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">下面是这个问题的形象化描述:</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es nc"><img src="../Images/1dd499c48bd89aeae6b5f33f337f8a5e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*kH6Fp8ResqFYSh1D.png"/></div></div></figure><p id="94d6" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">现在是了解今天最后一个 git 命令的好时机:<code class="du mh mi mj kg b">git fetch</code>。<br/> <strong class="jl hj"> git fetch </strong>是告诉你的<strong class="jl hj"> local </strong> git 从原来的<strong class="jl hj">中获取最新的元数据信息，而</strong>不做任何文件传输。它正在检查是否有任何可用的更改。<strong class="jl hj"> git pull，</strong>另一方面，<strong class="jl hj">和</strong>从远程库带来(复制)那些变更。</p><p id="6328" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">让我们看看 Lori 获取更改后会发生什么:</p><div class="iy iz ja jb fd ab cb"><figure class="ni jc nx nk nl nm nn paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><img src="../Images/2faac899ce272968c81d4de0f96d3c70.png" data-original-src="https://miro.medium.com/v2/resize:fit:952/format:webp/1*s65QPTTO6o2TOWnl8v8JTA.png"/></div></figure><figure class="ni jc ny nk nl nm nn paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><img src="../Images/bf10caf472bbcfda71610c71448c2c2b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1050/format:webp/1*35L5YwArVHaKFYKxCnVZ7g.png"/></div></figure></div><p id="e461" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">所以，你知道我要问什么…我们这里有什么？</p><ol class=""><li id="f880" class="mk ml hi jl b jm jn jp jq js mm jw mn ka mo ke my mq mr ms bi translated"><code class="du mh mi mj kg b">git fetch</code>通知我们变更，其中出现分支<code class="du mh mi mj kg b">dev/olivia</code>(<em class="ln">*【新分支】dev/Olivia-&gt;origin/dev/Olivia</em>)。</li><li id="1a36" class="mk ml hi jl b jm mt jp mu js mv jw mw ka mx ke my mq mr ms bi translated"><code class="du mh mi mj kg b">git log</code>证明没有文件被更新——本地主文件没有改变。</li><li id="c390" class="mk ml hi jl b jm mt jp mu js mv jw mw ka mx ke my mq mr ms bi translated"><code class="du mh mi mj kg b">git pull origin main</code>确实做出了改变，以一种我们以前从未见过的方式:<em class="ln">由‘递归’策略做出的合并。</em></li><li id="fc06" class="mk ml hi jl b jm mt jp mu js mv jw mw ka mx ke my mq mr ms bi translated"><code class="du mh mi mj kg b">git log</code>向我们展示了一个不是女士们创建的提交:<em class="ln">合并 https://github.com/IfatNeumann/git-hands-on.</em>的“主”分支为什么会这样？奥利维亚的承诺在哪里？</li></ol><h2 id="f0f8" class="kk kl hi bd ks lo lp lq kw lr ls lt la js lu lv lc jw lw lx le ka ly lz lg ma bi translated"><code class="du mh mi mj kg b">Merge branch 'main'</code>提交</h2><p id="0460" class="pw-post-body-paragraph jj jk hi jl b jm li ij jo jp lj im jr js lk ju jv jw ll jy jz ka lm kc kd ke hb bi translated">合并<a class="ae kq" href="https://github.com/IfatNeumann/git-hands-on" rel="noopener ugc nofollow" target="_blank">https://github.com/IfatNeumann/git-hands-on</a>的分支‘主’</p><p id="1882" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">递归合并是当我们在从<code class="du mh mi mj kg b">origin</code>拉取变更之前<strong class="jl hj">在本地创建提交时发生的事情。</strong></p><p id="af8a" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">为了澄清，Lori 已经创建了一个提交，并且没有基于最新版本的代码。基于最新版本的代码提交是通过在提交之前<strong class="jl hj">从原点拉取来完成的。这也是有意义的，因为为了确保你的代码是好的并且不破坏任何东西——你需要确保它与项目的其余部分一起工作，就像现在一样。</strong></p><p id="7668" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">如果萝莉没有先拉就试着推，它会被拒绝。在提交更改后从原点提取更改，“强制”git 一个接一个地组织提交，即使它们最初具有相同的父状态。我说的父状态是指它们都基于代码的相同状态。</p><p id="36b6" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">让我们看看它在存储库中的样子:</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es nc"><img src="../Images/4b2a9e183725a62aaa6fc056201fbd36.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*iNzgC8RGQ7a6hRHe.png"/></div></div></figure><p id="5177" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">既然我们了解了这一点，让我们继续讨论 Lori 的终端:</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es nz"><img src="../Images/ad00efc62b9cb0cd11b23abfb237ea1c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9EG9xdglkA8_ORcXALS4ew.png"/></div></div></figure><p id="5d72" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated"><code class="du mh mi mj kg b">git status</code>向我们展示了 Lori 的本地 main 领先<code class="du mh mi mj kg b">origin/main</code>两次提交。它们是她的原始提交(改变相互文件)和递归合并提交。让我们看看<code class="du mh mi mj kg b">origin/main</code>在 GitHub 中的样子:</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es nc"><img src="../Images/ea3d59793ed2e3135ad2d555c3c7b73a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*HaGgYHXRBEyqhbWk.png"/></div></div></figure><p id="b2e1" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated"><code class="du mh mi mj kg b">origin/main</code>现在有 5 次提交。如上图所示，如果您查看两次提交的代码，Olivia 的提交和自动递归合并提交，您会发现它们包含相同的更改。</p><p id="5be1" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">哇，这是一个很长的故事！此时分支的状态如下:</p><ul class=""><li id="7b47" class="mk ml hi jl b jm jn jp jq js mm jw mn ka mo ke mp mq mr ms bi translated">Olivia 更新了共同文件，并将更改推送到她的远程分支</li><li id="3ad7" class="mk ml hi jl b jm mt jp mu js mv jw mw ka mx ke mp mq mr ms bi translated">Lori 更新了双方的文件，并将更改推送到 main</li></ul><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es nc"><img src="../Images/71852e969893c0cec8d41fe6ee9683f3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*MmP-FEdoH9O-MBUU.png"/></div></div></figure><h1 id="6b2f" class="kr kl hi bd ks kt ku kv kw kx ky kz la io lb ip lc ir ld is le iu lf iv lg lh bi translated">7.冲突！</h1><p id="4590" class="pw-post-body-paragraph jj jk hi jl b jm li ij jo jp lj im jr js lk ju jv jw ll jy jz ka lm kc kd ke hb bi translated">如你所见，我们的两位女士修改了同一个文件，这肯定会造成冲突。只是时间问题。</p><p id="c983" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">时间到了！让我们看着它发生吧！</p><p id="2911" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">因此，假设 Olivia 希望获得最新的主版本:</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es oa"><img src="../Images/43dd0ff2cd139c3b324683a9897afbc3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qAXC0uCOSYNeO0q1xxua8Q.png"/></div></div></figure><p id="3c4a" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">代码中的冲突是怎样的？在我们的例子中，就像这样:</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es nb"><img src="../Images/a7ecb59295e999b808cac97c0cdf9321.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*hLHcZPCyZ6-KBpwE.png"/></div></div></figure><ul class=""><li id="5645" class="mk ml hi jl b jm jn jp jq js mm jw mn ka mo ke mp mq mr ms bi translated"><code class="du mh mi mj kg b">&lt;&lt;&lt;&lt;&lt;&lt; HEAD</code>标记您在本地存储库中的代码</li><li id="441c" class="mk ml hi jl b jm mt jp mu js mv jw mw ka mx ke mp mq mr ms bi translated"><code class="du mh mi mj kg b">======</code>标记头部结束和引入变化开始的位置</li><li id="1094" class="mk ml hi jl b jm mt jp mu js mv jw mw ka mx ke mp mq mr ms bi translated"><code class="du mh mi mj kg b">&gt;&gt;&gt;&gt;&gt;&gt;</code>标志着传入代码的结束</li></ul><p id="11e0" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">如果您的文件中多次出现冲突，您将会有多个&lt;&lt;&gt; &gt;的三元组。</p><p id="112a" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">当您看到冲突时，您需要选择是要保留您现有的版本，用引入的更改替换它，还是两者都保留。如果使用<a class="ae kq" href="https://en.wikipedia.org/wiki/Microsoft_Visual_Studio" rel="noopener ugc nofollow" target="_blank"> Visual Studio </a>(集成开发环境，如截图所示)，一键完成，生活变得更轻松。在上图中，可以看到选项:<code class="du mh mi mj kg b">Accept Current Change | Accept Incoming Change | Accept Both Changes</code>。</p><p id="fc30" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">在我们的情况下，奥利维亚会选择两者都保留。</p><p id="0f77" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">决定保留哪个代码后，你会怎么做？运行命令<code class="du mh mi mj kg b">git status</code>给了我们答案:</p><div class="iy iz ja jb fd ab cb"><figure class="ni jc ob nk nl nm nn paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><img src="../Images/b20a3d5f3878d994b2504d84f2b22153.png" data-original-src="https://miro.medium.com/v2/resize:fit:650/format:webp/1*m_1KETWiX9M0om-MgcKmIA.png"/></div></figure><figure class="ni jc oc nk nl nm nn paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><img src="../Images/c7b9b06fcdf4cd624aa125ad585c7c53.png" data-original-src="https://miro.medium.com/v2/resize:fit:698/format:webp/1*xIM5Ib5RQV6PA9AwTiUoMA.png"/></div></figure><figure class="ni jc od nk nl nm nn paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><img src="../Images/b5e69decc695d0d47f243eaf8b7171a5.png" data-original-src="https://miro.medium.com/v2/resize:fit:656/format:webp/1*AzuqG2NxqIiv5JV-8jElgQ.png"/></div></figure></div><p id="68d4" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">我们在这里看到了什么？</p><ol class=""><li id="b093" class="mk ml hi jl b jm jn jp jq js mm jw mn ka mo ke my mq mr ms bi translated">根据<code class="du mh mi mj kg b">git status</code>的说法，我们需要<em class="ln">修复冲突并运行“git commit”</em>，并且我们还有<em class="ln">未合并的路径:并且应该使用“git add…”</em></li><li id="9238" class="mk ml hi jl b jm mt jp mu js mv jw mw ka mx ke my mq mr ms bi translated">命令<code class="du mh mi mj kg b">git add .</code>后我得到了回应:<br/> <code class="du mh mi mj kg b">Changes to be committed:<br/>modified: mutual_file.txt</code></li><li id="9234" class="mk ml hi jl b jm mt jp mu js mv jw mw ka mx ke my mq mr ms bi translated"><code class="du mh mi mj kg b">Changes not staged for commit:<br/>(use "git add ..." to update what will be committed)<br/>modified: mutual_file.txt</code> <br/>我发现这有点奇怪，就像它说修改后的文件将被提交，也不准备提交，所以我做了一个额外的<code class="du mh mi mj kg b">git add .</code>和<code class="du mh mi mj kg b">git status</code>。只是为了确定一下。</li><li id="cfaf" class="mk ml hi jl b jm mt jp mu js mv jw mw ka mx ke my mq mr ms bi translated">在提交之后，我尝试了推送到 main，但是得到的回应是<code class="du mh mi mj kg b">Everything is up to date</code>。所以我用了我以前用过的方法:</li><li id="a3e3" class="mk ml hi jl b jm mt jp mu js mv jw mw ka mx ke my mq mr ms bi translated">按下<code class="du mh mi mj kg b">origin/dev/olivia</code>，切换到本地主电源，从远程<code class="du mh mi mj kg b">origin/dev/olivia</code>中拉出更改，然后按下<code class="du mh mi mj kg b">origin/main</code>。</li></ol><h1 id="76b5" class="kr kl hi bd ks kt ku kv kw kx ky kz la io lb ip lc ir ld is le iu lf iv lg lh bi translated">就是这样！</h1><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es oe"><img src="../Images/6cd4ae882391d465c69d1ac7c02a9418.png" data-original-src="https://miro.medium.com/v2/resize:fit:900/format:webp/0*vF44v6ypkdE3aB9v.jpg"/></div></figure><p id="2711" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">现在您可以毫无问题地使用 git 了！</p><p id="c5a1" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">今天我们学到了很多:命令行界面，git，GitHub，它是如何工作的，并复习了基本命令:</p><pre class="iy iz ja jb fd kf kg kh ki aw kj bi"><span id="8e58" class="kk kl hi kg b fi km kn l ko kp">git init<br/>git clone<br/>git add<br/>git commit<br/>git push<br/>git branch<br/>git checkout<br/>git status<br/>git log<br/>git fetch</span></pre><p id="8f2e" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">我们还看到了现实生活中使用的命令，并了解了如何解决冲突！</p><p id="dbc9" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">如果你感到有点不知所措，这是正常的。git 的奇妙世界让人难以理解，掌握它需要实践！</p><p id="a439" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">今天之后，看到 git 并没有看起来那么可怕，你觉得你准备好学习更多了吗？因为我有一些非常有用的命令可以在以后的博客文章中与你分享！</p></div><div class="ab cl of og gp oh" role="separator"><span class="oi bw bk oj ok ol"/><span class="oi bw bk oj ok ol"/><span class="oi bw bk oj ok"/></div><div class="hb hc hd he hf"><p id="efb0" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">我希望你喜欢阅读这篇文章，并学到一些新的东西！想多读点？点击<a class="ae kq" href="https://cupofcode.blog/tips-for-students-dr-erez-sheiner/" rel="noopener ugc nofollow" target="_blank">这里</a>看看巴尔伊兰大学的杰出讲师 Erez Sheiner 给学生们的建议！</p><p id="4d22" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">我很想听听你的想法，以下是联系我的方式:<br/>https://www.facebook.com/cupofcode.blog/<a class="ae kq" href="https://www.facebook.com/cupofcode.blog/" rel="noopener ugc nofollow" target="_blank">脸书</a>T3】insta gram:<a class="ae kq" href="https://www.instagram.com/cupofcode.blog/" rel="noopener ugc nofollow" target="_blank">https://www.instagram.com/cupofcode.blog/</a>T6】邮箱:cupofcode.blog@gmail.com</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es om"><img src="../Images/f751844ec85512978be3e1e88fe599b4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*Cfsry-GQfE_VuaIY.png"/></div></div></figure></div></div>    
</body>
</html>