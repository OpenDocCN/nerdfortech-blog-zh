<html>
<head>
<title>Building a PostgreSQL API in JavaScript with Express and Sequelize (Part 2): migrations and controllers</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用 Express 和 Sequelize 在 JavaScript 中构建 PostgreSQL API(第 2 部分):迁移和控制器</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/june-22-building-a-postgresql-api-in-javascript-with-express-and-sequelize-part-2-57a166814545?source=collection_archive---------3-----------------------#2021-06-22">https://medium.com/nerd-for-tech/june-22-building-a-postgresql-api-in-javascript-with-express-and-sequelize-part-2-57a166814545?source=collection_archive---------3-----------------------#2021-06-22</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div class="er es if"><img src="../Images/7112dfb172bc2a3e4bdd332918941193.png" data-original-src="https://miro.medium.com/v2/resize:fit:960/1*vGenVV9tSD5CCYLG9y3_CA.gif"/></div></figure><p id="584d" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">是时候继续我的<strong class="io hj">基础 JavaScript web API 食谱</strong>  <strong class="io hj">的第一部分了。这是一个很大的话题，当我们停止时，我们只是完成了设置:创建一个基本的 Express 应用程序，配置我们的环境，并配置 Sequelize。在这一集，我们将进入主要事件:模型、关联和迁移。如果你愿意，可以随意派生和克隆这个库；下面的指令前/后有分支，用于检查进度。</strong></p><h1 id="073a" class="jl jm hi bd jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki bi translated"><strong class="ak"> 5。创建您的数据库</strong></h1><p id="aa47" class="pw-post-body-paragraph im in hi io b ip kj ir is it kk iv iw ix kl iz ja jb km jd je jf kn jh ji jj hb bi translated">在创建模型之前，我们必须使用我们在<code class="du ko kp kq kr b">database.config.js</code>中为 Sequelize 留下的指令<strong class="io hj">创建我们的数据库</strong>。对于任何习惯于 Rails 的人来说，这个命令应该会敲响警钟。我们不妨为它添加一个快捷方式到我们在<code class="du ko kp kq kr b">package.json</code>的<code class="du ko kp kq kr b">“scripts”</code>:</p><pre class="ks kt ku kv fd kw kr kx ky aw kz bi"><span id="420c" class="la jm hi kr b fi lb lc l ld le">...<br/>"scripts": {<br/>   "dev": "nodemon -r dotenv/config index.js",<br/><strong class="kr hj">   "db:create": "sequelize-cli db:create"<br/></strong>},<br/>...</span></pre><p id="a840" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">Sequelize 默认为 PostreSQL 的默认端口，<code class="du ko kp kq kr b">5432</code>；通过在<code class="du ko kp kq kr b">database.config.js</code>的<code class="du ko kp kq kr b">module.exports</code>中添加一个键来指定一个不同的端口。</p><p id="1ef0" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">现在交叉手指运行<code class="du ko kp kq kr b">yarn db:create</code>，您应该会看到类似这样的内容:</p><pre class="ks kt ku kv fd kw kr kx ky aw kz bi"><span id="944f" class="la jm hi kr b fi lb lc l ld le">Loaded configuration file "app/config/database.config.js".<br/>Using environment "development".<br/>Database <em class="lf">my_express_app_development</em> created.<br/>✨  Done in 1.11s.</span></pre><p id="08e3" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><strong class="io hj"> Qapla！</strong>快速浏览一下 Postgres，确认我们已经成功创建了一个名为<code class="du ko kp kq kr b">my_express_app_development</code>的数据库:</p><figure class="ks kt ku kv fd ij er es paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="er es lg"><img src="../Images/2e320105dafb0db54de7cc3b7a86ca39.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8DK5WYWkQusvV_69ZnFWXQ.png"/></div></div></figure><h1 id="7965" class="jl jm hi bd jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki bi translated">6.创建模型和迁移</h1><p id="0b2b" class="pw-post-body-paragraph im in hi io b ip kj ir is it kk iv iw ix kl iz ja jb km jd je jf kn jh ji jj hb bi translated"><strong class="io hj">我讨厌抽象的软件教程</strong>——每个模型都叫<code class="du ko kp kq kr b">BelongsToModel</code>或者<code class="du ko kp kq kr b">HasManyModel</code>，每个关联都叫<code class="du ko kp kq kr b">Association</code>等等。让我们创建<code class="du ko kp kq kr b">User</code>和<code class="du ko kp kq kr b">Post</code>来代替:一个<code class="du ko kp kq kr b">User</code>有许多<code class="du ko kp kq kr b">Post</code>并且一个<code class="du ko kp kq kr b">Post</code>属于一个用户。要为<code class="du ko kp kq kr b">User</code> s 创建一个数据库条目，我们需要创建一个带有属性的模型，这个模型将链接到一个表及其列。我们现在只从两列开始:<code class="du ko kp kq kr b">username</code>和<code class="du ko kp kq kr b">email</code>。</p><p id="007d" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">在您的终端中，运行 Rails: <code class="du ko kp kq kr b">yarn sequelize-cli model:generate --name User --attributes username:string,email:string</code>中的<code class="du ko kp kq kr b">rails g model</code>的等价物。<strong class="io hj">在</strong> <code class="du ko kp kq kr b"><strong class="io hj">--attributes</strong></code> <strong class="io hj">标志后指定属性时，只使用逗号，不要使用空格！</strong>它非常快，所以您应该立即看到一条消息，确认您刚刚自动生成了两个文件:一个名为<code class="du ko kp kq kr b">models/user.js</code>的模型文件和一个带有日期戳的迁移文件，如:<code class="du ko kp kq kr b">20210622153117-create-user.js</code>:</p><pre class="ks kt ku kv fd kw kr kx ky aw kz bi"><span id="d736" class="la jm hi kr b fi lb lc l ld le">New model was created at <em class="lf">.../app/models/user.js .</em><br/>New migration was created at <em class="lf">.../app/migrations/20210622153117-create-user.js .</em><br/>✨  Done in 0.34s.</span></pre><p id="db73" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><code class="du ko kp kq kr b">user.js</code>定义了我们的模型及其属性，并为我们提供了一个定义未来关联的框架(稍后会详细介绍)…</p><pre class="ks kt ku kv fd kw kr kx ky aw kz bi"><span id="c368" class="la jm hi kr b fi lb lc l ld le">'use strict';</span><span id="2cea" class="la jm hi kr b fi ll lc l ld le">const { Model } = require( 'sequelize' );</span><span id="fb41" class="la jm hi kr b fi ll lc l ld le">module.exports = ( sequelize, DataTypes ) =&gt; {<br/>   class User extends Model {<br/>   /**<br/>   * Helper method for defining associations.<br/>   * This method is not a part of Sequelize lifecycle.<br/>   * The `models/index` file will call this method automatically.<br/>   */<br/><strong class="kr hj">      static associate( models ) {<br/>         // define association here<br/>      }</strong><br/>   };<br/>   User.init( {<br/><strong class="kr hj">      username: DataTypes.STRING,<br/>      email: DataTypes.STRING</strong><br/>   }, {<br/>      sequelize,<br/>      modelName: 'User',<br/>   } );<br/>   return User;<br/>};</span></pre><p id="bb26" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">…但是要开始创建数据/行，我们需要运行我们的迁移，<code class="du ko kp kq kr b">...-create-user.js</code>:</p><pre class="ks kt ku kv fd kw kr kx ky aw kz bi"><span id="39ac" class="la jm hi kr b fi lb lc l ld le">'use strict';<br/>module.exports = {<br/>   up: async (queryInterface, Sequelize) =&gt; {<br/>      await queryInterface.createTable('Users', {<br/>         id: {<br/>            allowNull: false,<br/>            autoIncrement: true,<br/>            primaryKey: true,<br/>            type: Sequelize.INTEGER<br/>         },<br/>         username: {<br/>            type: Sequelize.STRING<br/>         },<br/>         email: {<br/>            type: Sequelize.STRING<br/>         },<br/>         createdAt: {<br/>            allowNull: false,<br/>            type: Sequelize.DATE<br/>         },<br/>         updatedAt: {<br/>            allowNull: false,<br/>            type: Sequelize.DATE<br/>         }<br/>      });<br/>   },<br/>   down: async (queryInterface, Sequelize) =&gt; {<br/>      await queryInterface.dropTable('Users');<br/>   }<br/>};</span></pre><p id="d03c" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">一个顺序迁移模块<code class="du ko kp kq kr b">.exports</code>有两个功能:用于迁移表的<code class="du ko kp kq kr b">up</code>和用于删除表的<code class="du ko kp kq kr b">down</code>。请注意:</p><ul class=""><li id="8d73" class="lm ln hi io b ip iq it iu ix lo jb lp jf lq jj lr ls lt lu bi translated"><code class="du ko kp kq kr b"><strong class="io hj">up()</strong></code> <strong class="io hj">和</strong> <code class="du ko kp kq kr b"><strong class="io hj">down()</strong></code> <strong class="io hj">都是</strong> <code class="du ko kp kq kr b"><strong class="io hj">async</strong></code> <strong class="io hj">函数，</strong>是因为 Sequelize 需要等待一个数据库连接。</li><li id="d6b9" class="lm ln hi io b ip lv it lw ix lx jb ly jf lz jj lr ls lt lu bi translated">对于<code class="du ko kp kq kr b">createTable</code>，Sequelize 生成一个选项散列——根据需要随意添加/保留/删除这些熟悉的、有用的、不言自明的验证:<code class="du ko kp kq kr b">allowNull</code>、<code class="du ko kp kq kr b">defaultValue</code>、<code class="du ko kp kq kr b">unique</code>等等。</li><li id="82a0" class="lm ln hi io b ip lv it lw ix lx jb ly jf lz jj lr ls lt lu bi translated">当然，Sequelize 也像 ActiveRecord 一样添加了一个主键、<code class="du ko kp kq kr b">id</code>以及<code class="du ko kp kq kr b">createdAt</code>和<code class="du ko kp kq kr b">updatedAt</code>时间戳。</li></ul><p id="8e5f" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">在我们迁移之前，让我们强化为重要任务编写脚本的习惯。最好编写一个用于迁移的程序，另一个用于生成迁移(如果我们需要更新表的话),还有一个用于重置数据库，这样我们就不会得到一堆重复的主键:</p><pre class="ks kt ku kv fd kw kr kx ky aw kz bi"><span id="009f" class="la jm hi kr b fi lb lc l ld le">...<br/>"scripts": {<br/>   "dev": "nodemon -r dotenv/config index.js",<br/>   "db:create": "sequelize-cli db:create",<strong class="kr hj"><br/>   </strong><strong class="kr hj">"db:migrate": "sequelize-cli db:migrate",<br/>   "db:g:migration": "sequelize-cli migration:generate --name",<br/>   </strong><strong class="kr hj">"db:reset": "sequelize-cli db:drop &amp;&amp; sequelize-cli db:create &amp;&amp; sequelize-cli db:migrate"</strong><br/>}<br/>...</span></pre><p id="6931" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">运行<code class="du ko kp kq kr b">yarn db:migrate</code>，Sequelize 会将<code class="du ko kp kq kr b">User</code>迁移到你的 PostgreSQL 数据库中。它会显示一条确认消息，如下所示:</p><pre class="ks kt ku kv fd kw kr kx ky aw kz bi"><span id="6afe" class="la jm hi kr b fi lb lc l ld le">Loaded configuration file "app/config/database.config.js".<br/>Using environment "development".<br/>== 20210622153117-create-user: migrating =======<br/>== 20210622153117-create-user: migrated (0.021s)</span><span id="37e2" class="la jm hi kr b fi ll lc l ld le">✨  Done in 1.08s.</span></pre><p id="ae94" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">您也可以在您的 Postgres 客户端中亲自查看。它们都为此提供了一个 CLI。有些像 SQLPro 或 Postico 提供了一个类似电子表格的 GUI，这比重复输入<code class="du ko kp kq kr b">SELECT … FROM …</code>要简单一些。</p><p id="7e21" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><code class="du ko kp kq kr b">add</code>、<code class="du ko kp kq kr b">commit</code>和<code class="du ko kp kq kr b">push</code>提交您的进度。</p><h1 id="f9e0" class="jl jm hi bd jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki bi translated">7.创建关系并用种子数据测试它们</h1><p id="3ba8" class="pw-post-body-paragraph im in hi io b ip kj ir is it kk iv iw ix kl iz ja jb km jd je jf kn jh ji jj hb bi translated">现在我们创建一个<code class="du ko kp kq kr b">Post</code>模型，定义<code class="du ko kp kq kr b">User</code> s 和<code class="du ko kp kq kr b">Post</code> s 的关系，有四种顺序关系:<code class="du ko kp kq kr b">hasOne</code>、<code class="du ko kp kq kr b">belongsTo</code>、<code class="du ko kp kq kr b">hasMany</code>、<code class="du ko kp kq kr b">belongsToMany</code>；为了使本教程简单，我们将创建一个<code class="du ko kp kq kr b">hasMany</code> / <code class="du ko kp kq kr b">belongsTo</code>关系。有关关系的更多细节，请查阅后续文档。</p><p id="b56d" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">我们的帖子会有一个标题和一些文本内容，所以运行<code class="du ko kp kq kr b">sequelize model:create --name Post --attributes title:string,content:string</code>；和前面一样，这将创建一个模型文件和相应的迁移文件。但是这一次在我们迁移之前，我们将开始从<strong class="io hj">向</strong> <code class="du ko kp kq kr b"><strong class="io hj">Post</strong></code> <strong class="io hj"> s </strong>添加一个 <code class="du ko kp kq kr b"><strong class="io hj">belongsTo()</strong></code> <strong class="io hj">关联，如下所示:</strong></p><pre class="ks kt ku kv fd kw kr kx ky aw kz bi"><span id="7360" class="la jm hi kr b fi lb lc l ld le"><em class="lf">// ...-create-post.js<br/></em>'use strict';<br/>module.exports = {<br/>   up: async (queryInterface, Sequelize) =&gt; {<br/>      await queryInterface.createTable('Users', {<br/>         id: {...},<br/>         title: {...},<br/>         content: {...},<br/>         createdAt: {...},<br/>         updatedAt: {...},<br/><strong class="kr hj">         userId: {<br/>            type: Sequelize.INTEGER,<br/>            references: {<br/>               model: "Users",<br/>               key: "id",<br/>               as: "userId"<br/>            }<br/>         }</strong><br/>      });<br/>   },<br/>...<br/>};</span></pre><p id="30a6" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">在这个迁移文件中，我们将为给定的<code class="du ko kp kq kr b">Post</code> <code class="du ko kp kq kr b">belongsTo()</code>添加一列<code class="du ko kp kq kr b">userId</code>。该列需要的选项包括该列的<code class="du ko kp kq kr b">type</code>和<code class="du ko kp kq kr b">references</code>，它们告诉 Sequelize 所属模型的名称、键和别名。</p><p id="3c43" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">在<code class="du ko kp kq kr b">user.js</code>中，让我们通过填充方法<code class="du ko kp kq kr b">associations()</code>来构建这个关系的<code class="du ko kp kq kr b">hasMany()</code>部分:</p><pre class="ks kt ku kv fd kw kr kx ky aw kz bi"><span id="fc52" class="la jm hi kr b fi lb lc l ld le">module.exports = ( sequelize, DataTypes ) =&gt; {<br/>   class User extends Model {<br/>      static associate( models ) {<br/><strong class="kr hj">         </strong><strong class="kr hj">User.hasMany( models.Post, {<br/>            foreignKey: 'userId',<br/>            as: 'users',<br/>         } );</strong><br/>      }<br/>   };<br/>   ...<br/>};</span></pre><p id="0ef8" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">我们将对<code class="du ko kp kq kr b">post.js</code>中的<code class="du ko kp kq kr b">associations</code>方法做同样的事情，创建关系的<code class="du ko kp kq kr b">belongsTo()</code>部分。请注意，我们使用 Sequelize 的<code class="du ko kp kq kr b">onDelete</code>选项来启用级联删除——无论何时删除发布它的<code class="du ko kp kq kr b">User</code>,它都会从数据库中消失:</p><pre class="ks kt ku kv fd kw kr kx ky aw kz bi"><span id="f54c" class="la jm hi kr b fi lb lc l ld le">module.exports = ( sequelize, DataTypes ) =&gt; {<br/>   class Post extends Model {<br/>      static associate( models ) {<br/><strong class="kr hj">         </strong><strong class="kr hj">Post.belongsTo( models.User, {<br/>            foreignKey: 'userId',<br/>            onDelete: 'CASCADE',<br/>         } );</strong><br/>      }<br/>   };<br/>   ...<br/>};</span></pre><p id="c3b9" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">现在让我们创建一些种子数据——我们应该在开始创建控制器和路线之前测试我们的关系。自然地，我们还将通过<code class="du ko kp kq kr b">package.json</code>来定义用于生成种子文件和播种/重新播种数据的脚本:</p><pre class="ks kt ku kv fd kw kr kx ky aw kz bi"><span id="36ae" class="la jm hi kr b fi lb lc l ld le">...<br/>"scripts": {<br/>   "dev": "nodemon -r dotenv/config index.js",<br/>   "db:create": "sequelize-cli db:create",<br/>   <!-- -->"db:migrate": "sequelize-cli db:migrate",<br/>   "db:g:migration": "sequelize-cli migration:generate --name",<br/>   <!-- -->"db:reset": "sequelize-cli db:drop &amp;&amp; sequelize-cli db:create &amp;&amp; sequelize-cli db:migrate",<br/>   <strong class="kr hj">"db:g:seed": "sequelize-cli seed:generate --name",<br/>   "db:seeds": "sequelize-cli db:seed:all",<br/>   </strong><strong class="kr hj">"db:reseed": "sequelize-cli db:drop &amp;&amp; sequelize-cli db:create &amp;&amp; sequelize-cli db:migrate &amp;&amp; sequelize-cli db:seed:all"</strong><br/>}<br/>...</span></pre><p id="15ce" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">现在让我们为每个模型运行一次<code class="du ko kp kq kr b">g:seed</code>，每次都有一个名称，如:<code class="du ko kp kq kr b">yarn db:g:seed userSeeds &amp;&amp; yarn db:g:seed postSeeds.</code>在<code class="du ko kp kq kr b">app/seeders</code>中，您将看到用您提供的名称和时间戳生成的种子文件:</p><pre class="ks kt ku kv fd kw kr kx ky aw kz bi"><span id="1571" class="la jm hi kr b fi lb lc l ld le">New seed was created at .../app/seeders/20210622174800-userSeeds.js .<br/>✨  Done in 0.77s.</span><span id="2db9" class="la jm hi kr b fi ll lc l ld le">...</span><span id="e465" class="la jm hi kr b fi ll lc l ld le">New seed was created at .../app/seeders/20210622174800-postSeeds.js .<br/>✨  Done in 1.03s.</span></pre><p id="1fe1" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">就像迁移一样，Sequelize seeder 模块有两个<code class="du ko kp kq kr b">.exports</code>，都是<code class="du ko kp kq kr b">async</code>函数:<code class="du ko kp kq kr b">up</code>更改数据库，而<code class="du ko kp kq kr b">down</code>在必要时删除这些更改。让我们使用一些对应于 SQL 命令的序列函数来填充这些内容:</p><pre class="ks kt ku kv fd kw kr kx ky aw kz bi"><span id="cb09" class="la jm hi kr b fi lb lc l ld le"><em class="lf">// ...-userSeeds.js<br/></em>'use strict';</span><span id="a4ee" class="la jm hi kr b fi ll lc l ld le">module.exports = {</span><span id="5dcd" class="la jm hi kr b fi ll lc l ld le"><strong class="kr hj">up: async (queryInterface, Sequelize) =&gt; {<br/>      return await queryInterface.bulkInsert( "Users", [<br/>         { username: "Josh", email: "josh@hirejoshfrank.com", createdAt: new Date(), updatedAt: new Date() }<br/></strong>      <strong class="kr hj">] );<br/>   },</strong></span><span id="1ec7" class="la jm hi kr b fi ll lc l ld le"><strong class="kr hj">   down: async (queryInterface, Sequelize) =&gt; {<br/>      return await queryInterface.bulkDelete( "Users", null, {} );<br/>   }</strong></span><span id="653a" class="la jm hi kr b fi ll lc l ld le">};</span><span id="e3e0" class="la jm hi kr b fi ll lc l ld le"><em class="lf">// ...-postSeeds.js<br/></em>'use strict';</span><span id="e0b6" class="la jm hi kr b fi ll lc l ld le">module.exports = {</span><span id="f909" class="la jm hi kr b fi ll lc l ld le"><strong class="kr hj">up: async (queryInterface, Sequelize) =&gt; {<br/>      return await queryInterface.bulkInsert( "Posts", [<br/>         { title: "Josh's first post", content: "I see a ship in the harbor", userId: 1, createdAt: new Date(), updatedAt: new Date() },<br/>         { title: "Josh's second post", content: "I can and shall obey", userId: 1, createdAt: new Date(), updatedAt: new Date() }<br/>      ] );</strong><br/>   <strong class="kr hj">},</strong></span><span id="260a" class="la jm hi kr b fi ll lc l ld le"><strong class="kr hj">   down: async (queryInterface, Sequelize) =&gt; {<br/>      return await queryInterface.bulkDelete( "Posts", null, {} );<br/>   }</strong></span><span id="5a80" class="la jm hi kr b fi ll lc l ld le">};</span></pre><p id="c381" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">Sequelize 给了我们大量的查询选项！这里我们使用了行对象，每个对象都包括条目的<code class="du ko kp kq kr b">createdAt</code>和<code class="du ko kp kq kr b">updatedAt</code>时间戳；Sequelize 友好地让我们使用一个普通的<code class="du ko kp kq kr b">new Date()</code>来做这个。还要注意，我们为归属者提供了一个<code class="du ko kp kq kr b">userId</code>(<code class="du ko kp kq kr b">Post</code>s)。</p><p id="5f4c" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">如果一切都按照我们的计划进行，当您运行<code class="du ko kp kq kr b">yarn db:seeds</code>时，您应该会看到下面乐观的、类似 Rails 的消息:</p><pre class="ks kt ku kv fd kw kr kx ky aw kz bi"><span id="c38e" class="la jm hi kr b fi lb lc l ld le">Loaded configuration file "app/config/database.config.js".<br/>Using environment "development".<br/>== 20210622153117-create-user: migrating =======<br/>== 20210622153117-create-user: migrated (0.016s)</span><span id="ec0a" class="la jm hi kr b fi ll lc l ld le">== 20210622172615-create-post: migrating =======<br/>== 20210622172615-create-post: migrated (0.011s)</span></pre><p id="88d0" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">如果 Sequelize 运行时没有碰到<code class="du ko kp kq kr b">allowNull: false</code>或我们迁移中的任何其他验证，<strong class="io hj">这意味着我们的关系正在成功地工作！</strong>使用<code class="du ko kp kq kr b">SELECT * FROM “Users"</code>和<code class="du ko kp kq kr b">SELECT * FROM “Posts"</code>在您的 Postgres 客户端中确认您的数据库看起来应该是这样的:</p><div class="ks kt ku kv fd ab cb"><figure class="ma ij mb mc md me mf paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><img src="../Images/64f807c80f58a2f10c946f015feba11d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1066/format:webp/1*GoC-LwgNhBThaqrye5ib5Q.png"/></div></figure><figure class="ma ij mg mc md me mf paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><img src="../Images/a8e3ef593f4f36e52a6c37050ee1a652.png" data-original-src="https://miro.medium.com/v2/resize:fit:936/format:webp/1*UPwwi2nEC8EdOVNfhRHkIw.png"/></div></figure></div><h1 id="c5b4" class="jl jm hi bd jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki bi translated">8。创建控制器和路线</h1><p id="659e" class="pw-post-body-paragraph im in hi io b ip kj ir is it kk iv iw ix kl iz ja jb km jd je jf kn jh ji jj hb bi translated">让我们将所有这些结合到一个真正的工作 API 中——这是所有这些大惊小怪的原因——这样我们就可以在 HTTP/JSON 中看到这些模型和关系，而不仅仅是在 SQL 控制台中。我们将通过<strong class="io hj">创建控制器</strong>(在<code class="du ko kp kq kr b">/app</code>中为它们创建一个文件夹)并开始<strong class="io hj">定义</strong> <strong class="io hj">路径</strong>来完成，这些路径指向那些控制器的动作。我们现在只从<code class="du ko kp kq kr b">show</code>路线/行动开始。</p><p id="3de0" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">从项目的根目录运行<code class="du ko kp kq kr b">mkdir app/controllers</code>为控制器创建一个文件夹。然后<code class="du ko kp kq kr b">touch postsController.js</code>并用下面的代码填充它:</p><pre class="ks kt ku kv fd kw kr kx ky aw kz bi"><span id="51f8" class="la jm hi kr b fi lb lc l ld le">const Post = require('../models').Post;</span><span id="2ccc" class="la jm hi kr b fi ll lc l ld le">exports.show = ( request, response ) =&gt; {<br/>   return Post.findByPk( request.params.postId, {} )<br/>      .then( post =&gt; {<br/>         if ( !post ) { response.status( 404 ).send( { error: "Post not found" } ); }<br/>         else { response.status( 200 ).send( post ); }<br/>      } )<br/>      .catch( error =&gt; response.status( 400 ).send( error ) );<br/>};</span></pre><p id="bb13" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">Sequelize 控制器<code class="du ko kp kq kr b">exports</code>都是当用户访问一条路线时调用的函数，所以它们以 HTTP <code class="du ko kp kq kr b">request</code> s 和 JSON <code class="du ko kp kq kr b">response</code> s 作为参数。<code class="du ko kp kq kr b">Model.findByPk()</code>完全按照它在 can 上说的做:接受一个数据库索引和一个 options 对象作为参数，并返回相应的数据库行。这都是用<code class="du ko kp kq kr b">.then().catch()</code>链接起来的，所以如果请求中的数据库索引有效，我们可以发送一个带有数据的<code class="du ko kp kq kr b">200</code>响应，如果无效，则发送一个<code class="du ko kp kq kr b">400</code> / <code class="du ko kp kq kr b">404</code>响应。</p><p id="3621" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">接下来，<code class="du ko kp kq kr b">touch app/controllers/index.js</code>并输入刚才下面的两行代码；当我们开始定义路线时，需要<code class="du ko kp kq kr b">require()</code>控制器快速方便地动作:</p><pre class="ks kt ku kv fd kw kr kx ky aw kz bi"><span id="0c25" class="la jm hi kr b fi lb lc l ld le">const posts = require( "./postsController.js" );</span><span id="fa92" class="la jm hi kr b fi ll lc l ld le">module.exports = { posts };</span></pre><p id="f6aa" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">现在让我们从项目的根目录运行<code class="du ko kp kq kr b">mkdir app/routes &amp;&amp; touch app/routes/index.js</code>来创建一个路由文件夹和一个路由文件。随着项目的增长，您可能会决定按模型(即<code class="du ko kp kq kr b">postRoutes</code>、<code class="du ko kp kq kr b">userRoutes</code>等)来分离路由文件。但是现在，我们将把所有的路线放在一个文件中，<code class="du ko kp kq kr b">app/routes/index.js</code>，包含下面的代码:</p><pre class="ks kt ku kv fd kw kr kx ky aw kz bi"><span id="bc30" class="la jm hi kr b fi lb lc l ld le">const postsController = require( "../controllers" ).posts;</span><span id="15d2" class="la jm hi kr b fi ll lc l ld le">module.exports = app =&gt; {<br/>   // Post routes //<br/>   app.get( "/posts/:postId", postsController.show );<br/>};</span></pre><p id="cfc1" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">最后，让我们将刚刚在主<code class="du ko kp kq kr b">app.js</code>文件中创建的<code class="du ko kp kq kr b">require</code>文件一直放到项目的根目录下:</p><pre class="ks kt ku kv fd kw kr kx ky aw kz bi"><span id="46b8" class="la jm hi kr b fi lb lc l ld le">require( "dotenv" ).config();<br/>const express = require( "express" );<br/>const cors = require( "cors" );<br/>const app = express();</span><span id="1422" class="la jm hi kr b fi ll lc l ld le">app.use( express.json() );<br/>app.use( express.urlencoded( { extended: true } ) );<br/>app.use( cors( { origin: `http://localhost:${ process.env.PORT }` } ) );</span><span id="ee60" class="la jm hi kr b fi ll lc l ld le"><strong class="kr hj">require( "./app/routes" )( app );</strong></span><span id="43c5" class="la jm hi kr b fi ll lc l ld le">app.get( "/", ( request, response ) =&gt; response.send( "Test" ) );</span><span id="5672" class="la jm hi kr b fi ll lc l ld le">app.listen( process.env.PORT, () =&gt; console.log( `Listening: port ${ process.env.PORT }` ) );</span></pre><p id="460b" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">现在，终于，当我们用<code class="du ko kp kq kr b">yarn dev</code>启动我们的应用程序时，我们应该会看到熟悉的<code class="du ko kp kq kr b">Listening: port 3000</code>消息，告诉我们我们的应用程序正在运行并无错误地监听。这意味着如果你打开一个新的终端并运行<code class="du ko kp kq kr b">curl localhost:3000/posts/1</code>，你会看到我们种子的第一个<code class="du ko kp kq kr b">Post</code>:</p><pre class="ks kt ku kv fd kw kr kx ky aw kz bi"><span id="b86a" class="la jm hi kr b fi lb lc l ld le">{"id":1,"title":"Josh's first post","content":"I see a ship in the harbor","createdAt":"2021-06-22T19:39:30.140Z","updatedAt":"2021-06-22T19:39:30.140Z","userId":1}</span></pre><p id="bc98" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">在使用<code class="du ko kp kq kr b">yarn dev</code>运行应用程序的终端窗口中，会闪现一条消息，确认 Sequelize 运行了一条 SQL 命令:</p><pre class="ks kt ku kv fd kw kr kx ky aw kz bi"><span id="fb9d" class="la jm hi kr b fi lb lc l ld le">Executing (default): SELECT "id", "title", "content", "createdAt", "updatedAt", "userId" FROM "Posts" AS "Post" WHERE "Post"."id" = '1';</span></pre><p id="5c47" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">让我们<code class="du ko kp kq kr b">touch app/controllers/usersController.js</code>并添加一些<code class="du ko kp kq kr b">User</code>路线——但是这一次我们每次<code class="du ko kp kq kr b">show</code>一个<code class="du ko kp kq kr b">User</code>时就序列化<code class="du ko kp kq kr b">Post</code> s。我们将在<code class="du ko kp kq kr b">User.findByPk()</code>中使用一个带选项的对象来代替空对象。然后，我们将把那个<code class="du ko kp kq kr b">usersController</code>中的动作合并到一些新的路线中，并添加到<code class="du ko kp kq kr b">controllers/index.js</code>和<code class="du ko kp kq kr b">routes/index.js</code>中:</p><pre class="ks kt ku kv fd kw kr kx ky aw kz bi"><span id="c3dd" class="la jm hi kr b fi lb lc l ld le"><em class="lf">// usersController.js</em></span><span id="0271" class="la jm hi kr b fi ll lc l ld le">const User = require('../models').User;<br/><strong class="kr hj">const Post = require('../models').Post;</strong></span><span id="9b3d" class="la jm hi kr b fi ll lc l ld le"><strong class="kr hj">const userOptions = {<br/>   include: [<br/>      {<br/>         model: Post,<br/>         as: "posts"<br/>      }<br/>   ]<br/>};</strong></span><span id="3c28" class="la jm hi kr b fi ll lc l ld le">exports.show = ( request, response ) =&gt; {<br/>   return User.findByPk( request.params.userId, <strong class="kr hj">userOptions</strong> )<br/>      .then( user =&gt; {<br/>         if ( !user ) { response.status( 404 ).send( { error: "User not found" } ); }<br/>         else { response.status( 200 ).send( user ); }<br/>      } )<br/>      .catch( error =&gt; response.status( 400 ).send( error ) );<br/>}</span><span id="5ad1" class="la jm hi kr b fi ll lc l ld le"><em class="lf">// controllers/index.js</em></span><span id="4316" class="la jm hi kr b fi ll lc l ld le"><strong class="kr hj">const users = require( "./usersController.js" );<br/></strong>const posts = require( "./postsController.js" );</span><span id="4f5e" class="la jm hi kr b fi ll lc l ld le">module.exports = { posts, users };</span><span id="670b" class="la jm hi kr b fi ll lc l ld le"><em class="lf">// routes/index.js</em></span><span id="5b2f" class="la jm hi kr b fi ll lc l ld le">const postsController = require( "../controllers" ).posts;<br/><strong class="kr hj">const usersController = require( "../controllers" ).users;</strong></span><span id="9545" class="la jm hi kr b fi ll lc l ld le">module.exports = app =&gt; {<br/>   // Post routes //<br/>   app.get( "/posts/:postId", postsController.show );<br/>   <strong class="kr hj">// User routes //<br/>   app.get( "/users/:userId", usersController.show );</strong><br/>};</span></pre><p id="4ed7" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">现在，<code class="du ko kp kq kr b">curl localhost:3000/users/1</code>终端命令将为您提供带有<code class="du ko kp kq kr b">userId</code>和<code class="du ko kp kq kr b">1</code>的<code class="du ko kp kq kr b">User</code>，以及该用户在响应中序列化的两个帖子:</p><pre class="ks kt ku kv fd kw kr kx ky aw kz bi"><span id="cbf2" class="la jm hi kr b fi lb lc l ld le">{"id":1,"username":"Josh","email":"<a class="ae jk" href="mailto:josh@hirejoshfrank.com" rel="noopener ugc nofollow" target="_blank">josh@hirejoshfrank.com</a>","createdAt":"2021-06-22T19:39:30.132Z","updatedAt":"2021-06-22T19:39:30.132Z","posts":[{"id":1,"title":"Josh's first post","content":"I see a ship in the harbor","createdAt":"2021-06-22T19:39:30.140Z","updatedAt":"2021-06-22T19:39:30.140Z","userId":1},{"id":2,"title":"Josh's second post","content":"I can and shall obey","createdAt":"2021-06-22T19:39:30.140Z","updatedAt":"2021-06-22T19:39:30.140Z","userId":1}]}%</span></pre><h1 id="4495" class="jl jm hi bd jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki bi translated">接下来</h1><p id="2b41" class="pw-post-body-paragraph im in hi io b ip kj ir is it kk iv iw ix kl iz ja jb km jd je jf kn jh ji jj hb bi translated">我们现在有了两个简单的模型和它们之间的工作关系<code class="du ko kp kq kr b">hasMany</code> / <code class="du ko kp kq kr b">belongsTo</code>，以及处理它们的路线和控制器。<strong class="io hj">这使它成为一个基本的、有效的 web API，</strong>这是一个不小的成就！但是还有很多事情要做。我想在这个系列中至少增加 2 篇文章:一篇是用<code class="du ko kp kq kr b">bcrypt</code>和<code class="du ko kp kq kr b">jsonwebtokens</code>添加 auth 的演练，另一篇是关于部署你的应用的。关于这个主题还有很多值得强调的地方，敬请关注！</p></div></div>    
</body>
</html>