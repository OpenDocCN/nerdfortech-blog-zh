<html>
<head>
<title>Tips for Code Optimization in Unity</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Unity 中的代码优化技巧</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/tips-for-code-optimization-in-unity-947b1fd9b6a9?source=collection_archive---------5-----------------------#2021-08-11">https://medium.com/nerd-for-tech/tips-for-code-optimization-in-unity-947b1fd9b6a9?source=collection_archive---------5-----------------------#2021-08-11</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="3332" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在上一篇文章中，我们解释了 Unity 提供的最好的工具之一是 Unity Profiler(<a class="ae jd" rel="noopener" href="/nerd-for-tech/unity-profiler-101-fcfa4ea7ee2">Unity Profiler 101</a>)。分析器可以帮助您识别代码的哪个部分实际上导致了一些性能问题。我们开始吧。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div class="er es je"><img src="../Images/d0f49c49bdb30cd04d65e5e20df8061c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/1*8VDTuI1hjxqYs4q5uXg07w.gif"/></div></figure><blockquote class="jm jn jo"><p id="9acd" class="if ig jp ih b ii ij ik il im in io ip jq ir is it jr iv iw ix js iz ja jb jc hb bi translated">获取组件</p></blockquote><p id="ecf2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">获得任何对象的组件都是 unity 开发的重要部分，通常我们通过 GetComponent 获得脚本或刚体或对象的材质。</p><p id="f07e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">有时你得到组件而没有先缓存它。例如，假设您想要更改立方体的颜色。您可以在更新中执行以下操作:</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="ju jv di jw bf jx"><div class="er es jt"><img src="../Images/b8c0d23c6304164cf7803514082056c8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AoTtqGDOMf_i7l0KWf7MHA.png"/></div></div></figure><p id="1b3b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这将得到对象的每一个单独的帧的组件来改变对象的颜色。如果您使用 profiler 来检查这一点，您会发现从长远来看，这将导致一些垃圾收集和性能问题。一个代码可能没什么坏处，但是想象一下做不止一次。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="ju jv di jw bf jx"><div class="er es jy"><img src="../Images/316c542b4010b6bc74cf1b32db30381e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qLjoKWs97MWgQ7YLRp1zUA.jpeg"/></div></div><figcaption class="jz ka et er es kb kc bd b be z dx translated">Profiler:上述代码导致了性能问题</figcaption></figure><p id="3f22" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为了帮助改进这一点，您必须总是缓存您的组件，然后在 Awake 或 Start 中找到它，然后对该组件做您想做的任何事情。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="ju jv di jw bf jx"><div class="er es kd"><img src="../Images/c9be4633cc9bb2e0bdadc59c3d17cc5c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BUYJgm6tud063xQQztqVbQ.png"/></div></div></figure><p id="fc55" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">组件的这种缓存也应该对变量进行，总是缓存以提高性能。</p><blockquote class="jm jn jo"><p id="d1b8" class="if ig jp ih b ii ij ik il im in io ip jq ir is it jr iv iw ix js iz ja jb jc hb bi translated">新关键字</p></blockquote><p id="42bf" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">“New”关键字就像获取组件一样，用于创建新的变量或向量。如果不明智地经常使用，可能会导致性能问题。</p><p id="30b8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">假设您想要使用用户输入来改变对象的位置。您可以在更新中使用以下内容:</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="ju jv di jw bf jx"><div class="er es ke"><img src="../Images/1ead889d6d174dd41d46a37064191117.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*F2j9brCU0XgWFoRRYm5s9A.png"/></div></div></figure><p id="c70a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这将在用户每次按下 D 键时创建一个新的向量。更好的方法是缓存一个位置向量 3，然后重用同一个向量，就像这样:</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="ju jv di jw bf jx"><div class="er es kf"><img src="../Images/1d73d682a32d408119d825119a8f8286.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*U0BQgU8LNIapJI16YlT4tQ.png"/></div></div><figcaption class="jz ka et er es kb kc bd b be z dx translated">缓存变量并重用它们而不是 NEW 关键字</figcaption></figure><blockquote class="jm jn jo"><p id="c39f" class="if ig jp ih b ii ij ik il im in io ip jq ir is it jr iv iw ix js iz ja jb jc hb bi translated">收益回报新</p></blockquote><p id="d012" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">就像变量的新关键字一样，IEnumerators 要求您让步，以便执行其中的代码。</p><p id="f977" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">yield return 每次运行时都需要创建一个“新”变量(例如 WaitForSeconds())。当你有很多协程时，这肯定会导致垃圾收集和性能问题。不要每次都创建一个新的 WaitForSeconds，而是缓存它并像变量一样重用它。以下是方法:</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="ju jv di jw bf jx"><div class="er es kg"><img src="../Images/11607fb878feb312ac513d8ce67c6a6e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8hOv6n72sAJ6c_oMnGqEKA.png"/></div></div><figcaption class="jz ka et er es kb kc bd b be z dx translated">高效协同程序</figcaption></figure><p id="a602" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">通过缓存 WaitForSeconds，而不是在 IEnumerator 中创建一个新的 WaitForSeconds，您几乎可以消除由这个协程创建的垃圾收集，从长远来看，可以提高应用程序的性能。</p></div></div>    
</body>
</html>