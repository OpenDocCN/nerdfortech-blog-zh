<html>
<head>
<title>React Context, async calls with hooks, Redux like architecture and combine context providers with Typescript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">React上下文、带钩子的异步调用、Redux like架构以及将上下文提供者与Typescript相结合</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/react-context-async-calls-with-hooks-redux-like-architecture-and-combine-context-providers-with-ee95ca87b455?source=collection_archive---------2-----------------------#2019-12-03">https://medium.com/nerd-for-tech/react-context-async-calls-with-hooks-redux-like-architecture-and-combine-context-providers-with-ee95ca87b455?source=collection_archive---------2-----------------------#2019-12-03</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/b2556d80c27377e7d88a0f841d2775e7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*xClk0SMU0CVEUmVv.jpg"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">图片来自<a class="ae iu" href="https://www.robinwieruch.de/static/dbb6b6b256b589aad81a3ed374590f4d/2b1a3/banner.jpg" rel="noopener ugc nofollow" target="_blank">https://www . robinwieruch . de/static/dbb 6b 6 b 589 aad 81 a3 ed 374590 f4d/2b1a 3/banner . jpg</a></figcaption></figure><p id="0e9c" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们在这里有一个简单的任务，我们需要用React上下文实现状态管理，处理一些异步调用，在坚持redux概念的同时这样做，最后将所有东西组合在一个单一存储提供者中。</p><p id="100e" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">比方说，我们有一个web应用程序，它有一些用户验证、一些网站配置，当然还有错误处理。</p></div><div class="ab cl jt ju gp jv" role="separator"><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy"/></div><div class="hb hc hd he hf"><p id="3add" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">总体架构和原理</strong></p><p id="9b4b" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们希望实现组件没有异步调用，状态通过reducers改变，我们合并提供者，这样代码更干净，更容易推理。</p><p id="f3dd" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj"> <em class="ka">文件夹结构</em> </strong></p><pre class="kb kc kd ke fd kf kg kh ki aw kj bi"><span id="147b" class="kk kl hi kg b fi km kn l ko kp">src---</span><span id="adb1" class="kk kl hi kg b fi kq kn l ko kp">...<br/>      context---<br/>              auth---<br/>                     actions.ts<br/>                     reducer.ts<br/>                     types.ts<br/>                     index.ts<br/>              configuration---<br/>                     actions.ts<br/>                     reducer.ts<br/>                     types.ts<br/>                     index.ts</span><span id="c565" class="kk kl hi kg b fi kq kn l ko kp">error---<br/>                     actions.ts<br/>                     reducer.ts<br/>                     types.ts<br/>                     index.ts<br/>              index.tsx<br/>      pages---<br/>              Login.tsx<br/>              Configuration.tsx<br/>              ErrorBaner.tsx</span><span id="7535" class="kk kl hi kg b fi kq kn l ko kp">...</span></pre></div><div class="ab cl jt ju gp jv" role="separator"><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy"/></div><div class="hb hc hd he hf"><p id="1892" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">显示错误</strong></p><p id="7f14" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj"> <em class="ka">上下文/错误/类型. ts </em> </strong></p><pre class="kb kc kd ke fd kf kg kh ki aw kj bi"><span id="de28" class="kk kl hi kg b fi km kn l ko kp"><em class="ka">import </em>{ <em class="ka">GeneralErrorModel </em>} <em class="ka">from </em>'...';</span><span id="de07" class="kk kl hi kg b fi kq kn l ko kp"><em class="ka">export const </em>SET_GENERAL_ERROR = 'SET_GENERAL_ERROR';<br/><em class="ka">export const </em>CLEAR_GENERAL_ERROR = 'CLEAR_GENERAL_ERROR';</span><span id="da76" class="kk kl hi kg b fi kq kn l ko kp"><em class="ka">export interface SetGeneralErrorAction </em>{<br/>  type: <em class="ka">typeof </em>SET_GENERAL_ERROR;<br/>  payload: <em class="ka">GeneralErrorModel</em>;<br/>}</span><span id="6be1" class="kk kl hi kg b fi kq kn l ko kp"><em class="ka">export interface ClearGeneralErrorAction </em>{<br/>  type: <em class="ka">typeof </em>CLEAR_GENERAL_ERROR;<br/>}</span></pre><p id="9af6" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj"> <em class="ka">上下文/错误/动作. ts </em> </strong></p><pre class="kb kc kd ke fd kf kg kh ki aw kj bi"><span id="61b0" class="kk kl hi kg b fi km kn l ko kp"><em class="ka">import </em>{ <em class="ka">GeneralErrorModel </em>} <em class="ka">from </em>'...';<br/><em class="ka">import </em>{<br/>  CLEAR_GENERAL_ERROR,<br/>  <em class="ka">ClearGeneralErrorAction</em>,<br/>  SET_GENERAL_ERROR,<br/>  <em class="ka">SetGeneralErrorAction<br/></em>} <em class="ka">from </em>'./types';</span><span id="08c5" class="kk kl hi kg b fi kq kn l ko kp"><em class="ka">export const </em>setGeneralErrorAction = (<br/>  <em class="ka">error</em>: <em class="ka">GeneralErrorModel</em>,<br/>  <em class="ka">dispatch</em>: (<em class="ka">action</em>: <em class="ka">SetGeneralErrorAction</em>) =&gt; <em class="ka">void<br/></em>): <em class="ka">void </em>=&gt; {<br/>  <em class="ka">dispatch</em>({<br/>    type: SET_GENERAL_ERROR,<br/>    payload: <em class="ka">error<br/>  </em>});<br/>};</span><span id="3909" class="kk kl hi kg b fi kq kn l ko kp"><em class="ka">export const </em>clearGeneralErrorAction = (<br/>  <em class="ka">dispatch</em>: (<em class="ka">action</em>: <em class="ka">ClearGeneralErrorAction</em>) =&gt; <em class="ka">void<br/></em>): <em class="ka">void </em>=&gt; {<br/>  <em class="ka">dispatch</em>({<br/>    type: CLEAR_GENERAL_ERROR<br/>  });<br/>};</span></pre><p id="a88b" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj"> <em class="ka">上下文/错误/reducer.ts </em> </strong></p><pre class="kb kc kd ke fd kf kg kh ki aw kj bi"><span id="0659" class="kk kl hi kg b fi km kn l ko kp"><em class="ka">import </em>{ <em class="ka">GeneralErrorModel </em>} <em class="ka">from </em>'../../shared/models';<br/><em class="ka">import </em>{ <em class="ka">ClearGeneralErrorAction</em>, <em class="ka">SetGeneralErrorAction </em>} <em class="ka">from </em>'./types';</span><span id="ed09" class="kk kl hi kg b fi kq kn l ko kp"><em class="ka">export const </em>initialErrorState: <em class="ka">GeneralErrorModel </em>= {<br/>  message: ''<br/>};</span><span id="16b9" class="kk kl hi kg b fi kq kn l ko kp"><em class="ka">export const </em>errorReducer = (<br/>  <em class="ka">state</em>: <em class="ka">GeneralErrorModel </em>= initialErrorState,<br/>  <em class="ka">action</em>: <em class="ka">SetGeneralErrorAction </em>| <em class="ka">ClearGeneralErrorAction<br/></em>): <em class="ka">GeneralErrorModel </em>=&gt; {<br/>  <em class="ka">switch </em>(<em class="ka">action</em>.type) {<br/>    <em class="ka">case </em>'SET_GENERAL_ERROR':<br/>      <em class="ka">return </em>{<br/>        ...<em class="ka">state</em>,<br/>        ...action.payload<br/>      };<br/>    <em class="ka">case </em>'CLEAR_GENERAL_ERROR':<br/>      <em class="ka">return </em>initialErrorState;<br/>    <em class="ka">default</em>:<br/>      <em class="ka">return state</em>;<br/>  }<br/>};</span></pre><p id="341f" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">用户认证</strong></p><p id="3202" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">T25】context/auth/types . tsT27】</strong></p><pre class="kb kc kd ke fd kf kg kh ki aw kj bi"><span id="bb37" class="kk kl hi kg b fi km kn l ko kp"><em class="ka">import </em>{ <em class="ka">UserModel </em>} <em class="ka">from </em>'...';</span><span id="71a0" class="kk kl hi kg b fi kq kn l ko kp"><em class="ka">export const </em>SET_USER = 'SET_USER';<br/><em class="ka">export const </em>CLEAR_USER = 'CLEAR_USER';</span><span id="6ac6" class="kk kl hi kg b fi kq kn l ko kp"><em class="ka">export interface ClearUserAction </em>{<br/>  type: <em class="ka">typeof </em>CLEAR_USER;<br/>}</span><span id="5e12" class="kk kl hi kg b fi kq kn l ko kp"><em class="ka">export interface SetUserAction </em>{<br/>  type: <em class="ka">typeof </em>SET_USER;<br/>  payload: <em class="ka">UserModel</em>;<br/>}</span></pre><p id="07dc" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj"><em class="ka">context/auth/actions . ts</em></strong></p><pre class="kb kc kd ke fd kf kg kh ki aw kj bi"><span id="3628" class="kk kl hi kg b fi km kn l ko kp"><em class="ka">import </em>{ <em class="ka">UserModel </em>} <em class="ka">from </em>'...';<br/><em class="ka">import </em>{<br/>  CLEAR_USER,<br/>  <em class="ka">ClearUserAction</em>,<br/>  SET_USER,<br/>  <em class="ka">SetUserAction<br/></em>} <em class="ka">from </em>'./types';</span><span id="0b02" class="kk kl hi kg b fi kq kn l ko kp"><em class="ka">export const </em>setUserAction = (<br/>  <em class="ka">user</em>: <em class="ka">UserModel</em>,<br/>  <em class="ka">dispatch</em>: (<em class="ka">action</em>: <em class="ka">SetUserAction</em>) =&gt; <em class="ka">void<br/></em>): <em class="ka">void </em>=&gt; {<br/>  <em class="ka">dispatch</em>({<br/>    type: SET_USER,<br/>    payload: <em class="ka">user<br/>  </em>});<br/>};</span><span id="72c4" class="kk kl hi kg b fi kq kn l ko kp"><em class="ka">export const </em>clearUserAction = (<br/>  <em class="ka">dispatch</em>: (<em class="ka">action</em>: <em class="ka">ClearUserAction</em>) =&gt; <em class="ka">void<br/></em>): <em class="ka">void </em>=&gt; {<br/>  <em class="ka">dispatch</em>({<br/>    type: CLEAR_USER<br/>  });<br/>};</span></pre><p id="7569" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">T33】context/auth/reducer . tsT35】</strong></p><pre class="kb kc kd ke fd kf kg kh ki aw kj bi"><span id="1157" class="kk kl hi kg b fi km kn l ko kp"><em class="ka">import </em>{ <em class="ka">UserModel </em>} <em class="ka">from </em>'../../shared/models';<br/><em class="ka">import </em>{<br/>  SET_USER,<br/>  CLEAR_USER,<br/>  <em class="ka">ClearUserAction</em>,<br/>  <em class="ka">SetUserAction<br/></em>} <em class="ka">from </em>'./types';</span><span id="bd17" class="kk kl hi kg b fi kq kn l ko kp"><em class="ka">export const </em>initialUserState: <em class="ka">UserModel </em>= {<br/>  email: '',<br/>  id: ''<br/>};</span><span id="ac08" class="kk kl hi kg b fi kq kn l ko kp"><em class="ka">export const </em>userReducer = (<br/>  <em class="ka">state</em>: <em class="ka">UserModel </em>= initialUserState,<br/>  <em class="ka">action</em>: <em class="ka">SetUserAction </em>| <em class="ka">ClearUserAction<br/></em>): <em class="ka">UserModel </em>=&gt; {<br/>  <em class="ka">switch </em>(<em class="ka">action</em>.type) {<br/>    <em class="ka">case </em>SET_USER:<br/>      <em class="ka">return </em>{<br/>        ...<em class="ka">state</em>,<br/>        ...action.payload<br/>      };<br/>    <em class="ka">case </em>CLEAR_USER:<br/>      <em class="ka">return </em>initialUserState;<br/>    <em class="ka">default</em>:<br/>      <em class="ka">return state</em>;<br/>  }<br/>};</span></pre></div><div class="ab cl jt ju gp jv" role="separator"><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy"/></div><div class="hb hc hd he hf"><p id="003e" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">现在我们想从组件中提取分派，组件本身不应该知道我们是如何处理动作的，它应该只使用上下文，而不用担心它的内部实现。这很容易做到，而且在我看来，它确实有助于分离我们的应用层之间的关注点。让我们从错误上下文开始。</p><p id="4422" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj"> <em class="ka">上下文/错误/索引. ts </em> </strong></p><pre class="kb kc kd ke fd kf kg kh ki aw kj bi"><span id="d3e5" class="kk kl hi kg b fi km kn l ko kp"><em class="ka">import </em>React, {<br/>  createContext,<br/>  useReducer,<br/>  useContext,<br/>  ComponentProps,<br/>  FC<br/>} <em class="ka">from </em>'react';<br/><em class="ka">import </em>{ <em class="ka">GeneralErrorModel </em>} <em class="ka">from </em>'...';<br/><em class="ka">import </em>{ errorReducer, initialErrorState } <em class="ka">from </em>'./reducer';<br/><em class="ka">import </em>{ clearGeneralErrorAction, setGeneralErrorAction } <em class="ka">from </em>'./actions';</span><span id="e054" class="kk kl hi kg b fi kq kn l ko kp"><em class="ka">interface ErrorContext </em>{<br/>  state: <em class="ka">GeneralErrorModel</em>;<br/>  setError: (<em class="ka">error</em>: <em class="ka">GeneralErrorModel</em>) =&gt; <em class="ka">void</em>;<br/>  clearError: () =&gt; <em class="ka">void</em>;<br/>}</span><span id="5b30" class="kk kl hi kg b fi kq kn l ko kp"><em class="ka">const </em>ErrorContext = createContext&lt;<em class="ka">ErrorContext</em>&gt;({} <em class="ka">as ErrorContext</em>);</span><span id="f5ba" class="kk kl hi kg b fi kq kn l ko kp"><em class="ka">export const </em>useErrorContext =<br/>  (): <em class="ka">ErrorContext </em>=&gt; useContext(ErrorContext);</span><span id="4171" class="kk kl hi kg b fi kq kn l ko kp"><em class="ka">export const </em>ErrorContextProvider = ({<br/>  <em class="ka">children<br/></em>}: ComponentProps&lt;FC&gt;): JSX.Element =&gt; {</span><span id="3573" class="kk kl hi kg b fi kq kn l ko kp"><em class="ka">const </em>[state, dispatch] =<br/>    useReducer(errorReducer, initialErrorState);</span><span id="a541" class="kk kl hi kg b fi kq kn l ko kp"><em class="ka">const </em>setError = (<em class="ka">error</em>: <em class="ka">GeneralErrorModel</em>): <em class="ka">void </em>=&gt; {<br/>    setGeneralErrorAction(<em class="ka">error</em>, dispatch);<br/>  };</span><span id="b140" class="kk kl hi kg b fi kq kn l ko kp"><em class="ka">const </em>clearError = (): <em class="ka">void </em>=&gt; {<br/>    clearGeneralErrorAction(dispatch);<br/>  };</span><span id="ed40" class="kk kl hi kg b fi kq kn l ko kp"><em class="ka">return </em>(<br/>    &lt;ErrorContext.Provider <em class="ka">value</em>={{ state, setError, clearError }}&gt;<br/>      {<em class="ka">children</em>}<br/>    &lt;/ErrorContext.Provider&gt;<br/>  );<br/>};</span></pre><p id="7089" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">现在我们只需要在ErrorBanner组件中使用ErrorContext。</p><pre class="kb kc kd ke fd kf kg kh ki aw kj bi"><span id="a87d" class="kk kl hi kg b fi km kn l ko kp"><em class="ka">import </em>React <em class="ka">from </em>'react';<br/><em class="ka">import </em>{ useErrorContext } <em class="ka">from </em>'...';</span><span id="085f" class="kk kl hi kg b fi kq kn l ko kp"><em class="ka">export const </em>ErrorBanner = (): JSX.Element =&gt; {<br/>  <em class="ka">const </em>{ state, clearError } = useErrorContext();</span><span id="1e3a" class="kk kl hi kg b fi kq kn l ko kp"><em class="ka">if </em>(!state.message) {<br/>    <em class="ka">return </em>&lt;&gt;&lt;/&gt;;<br/>  }</span><span id="b16f" class="kk kl hi kg b fi kq kn l ko kp"><em class="ka">return </em>(<br/>    &lt;div <em class="ka">className</em>={'error-banner'}&gt;<br/>      &lt;span className="error-message"&gt;{state.message}&lt;/span&gt;<br/>      &lt;span <em class="ka">key</em>="close" <em class="ka">className</em>="close" <em class="ka">onClick</em>={clearError} /&gt;<br/>  );<br/>};</span></pre><p id="b264" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这很容易，因为逻辑非常简单，只需设置和清除错误，但是如何处理<strong class="ix hj"> auth </strong>我们有一个Http调用和可能的错误，让我们看看如何处理这个问题。</p></div><div class="ab cl jt ju gp jv" role="separator"><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy"/></div><div class="hb hc hd he hf"><p id="bb00" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">但在此之前，我想休息一下，谈谈我们的应用程序对外部服务的HTTP请求。<br/> </strong>在这一点上，我们已经可以推导出，如果你想把它做对你就用函数来做，甚至更好的高阶函数，但是为什么呢？让我解释一下，使用定制钩子(HOFs)的好处不仅仅是用钩子写代码，因为这在社区里很流行，最重要的一点是，在你写为钩子的函数中，你可以访问上下文，这真的很酷，允许你做比你想象的更多的事情。因此，让我们为HTTP调用创建一个通用钩子。</p><p id="d6f4" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj"> <em class="ka">使用Http.ts </em> </strong></p><pre class="kb kc kd ke fd kf kg kh ki aw kj bi"><span id="56bd" class="kk kl hi kg b fi km kn l ko kp"><em class="ka">import </em>axios, { AxiosResponse, AxiosError } <em class="ka">from </em>'axios';<br/><em class="ka">import </em>{ useErrorContext } <em class="ka">from </em>'...';</span><span id="dcdf" class="kk kl hi kg b fi kq kn l ko kp"><em class="ka">interface </em>UseHttp {<br/>  get: &lt;T&gt;(url: <em class="ka">string</em>) =&gt; Promise&lt;AxiosResponse&lt;T&gt;&gt;;<br/>  post: &lt;T&gt;(url: <em class="ka">string</em>, payload: <em class="ka">any</em>) =&gt; Promise&lt;AxiosResponse&lt;T&gt;&gt;;<br/>}</span><span id="0ad3" class="kk kl hi kg b fi kq kn l ko kp"><em class="ka">export const </em>useHttp = () =&gt; {<br/>  <em class="ka">const </em>{ clearError, setError } = useErrorContext();</span><span id="6def" class="kk kl hi kg b fi kq kn l ko kp">axios.interceptors.request.use(req =&gt; {<br/>    clearError();</span><span id="7bce" class="kk kl hi kg b fi kq kn l ko kp"><em class="ka">return req</em>;<br/>  });</span><span id="cee6" class="kk kl hi kg b fi kq kn l ko kp">axios.interceptors.response.use(<br/>    <em class="ka">res </em>=&gt; {<br/>      <em class="ka">return res</em>;<br/>    },<br/>    (<em class="ka">error</em>: AxiosError) =&gt; {<br/>      <em class="ka">if </em>(!<em class="ka">error</em>.response) {<br/>        <em class="ka">return</em>;<br/>      }<br/>      setError(<em class="ka">error</em>.response.data);<br/>    }<br/>  );</span><span id="08b1" class="kk kl hi kg b fi kq kn l ko kp"><em class="ka">const </em>formatUrl = (<em class="ka">partialUrl</em>: <em class="ka">string</em>): <em class="ka">string </em>=&gt; {<br/>    <em class="ka">return </em>`${process.env.REACT_APP_API_URL}/${<em class="ka">partialUrl</em>}`;<br/>  };</span><span id="0fec" class="kk kl hi kg b fi kq kn l ko kp"><em class="ka">const </em>get = <em class="ka">async </em>&lt;T&gt;(<em class="ka">url</em>: <em class="ka">string</em>): <em class="ka">Promise</em>&lt;AxiosResponse&lt;T&gt;&gt; =&gt; {<br/>    <em class="ka">return </em>axios.get(formatUrl(<em class="ka">url</em>));<br/>  };</span><span id="dd33" class="kk kl hi kg b fi kq kn l ko kp"><em class="ka">const </em>post = &lt;T&gt;(<br/>    <em class="ka">url</em>: <em class="ka">string</em>,<br/>    <em class="ka">payload</em>: <em class="ka">any<br/>  </em>):<em class="ka">Promise</em>&lt;AxiosResponse&lt;T&gt;&gt; =&gt; {<br/>    <em class="ka">return </em>axios.post(formatUrl(<em class="ka">url</em>), <em class="ka">payload</em>);<br/>  };</span><span id="5645" class="kk kl hi kg b fi kq kn l ko kp"><em class="ka">return </em>{ get, post };<br/>};</span></pre><p id="8f09" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">哇！我们可以在每个HTTP请求上设置和清除错误，而不必担心内层的错误，这很酷。现在让我们创建这个通用钩子的专门化，这样我们就可以处理具体的问题。</p><p id="9c81" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们有auth Http调用，所以我们将创建useAuthHttp挂钩。</p><p id="1fa3" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">T5】useauthhttp . tsT7】</strong></p><pre class="kb kc kd ke fd kf kg kh ki aw kj bi"><span id="f73a" class="kk kl hi kg b fi km kn l ko kp"><em class="ka">import </em>{ useHttp } <em class="ka">from </em>'./useHttp';<br/><em class="ka">import </em>jwt <em class="ka">from </em>'jsonwebtoken';</span><span id="2cd2" class="kk kl hi kg b fi kq kn l ko kp"><em class="ka">import </em>{ <em class="ka">UserModel</em>, <em class="ka">LoginResponseModel </em>} <em class="ka">from </em>'...';<br/><em class="ka">import </em>{ ApiEndPointsEnum } <em class="ka">from </em>'...';</span><span id="29bd" class="kk kl hi kg b fi kq kn l ko kp"><em class="ka">interface UseAuthHttp </em>{<br/>  loginUser: (<br/>    <em class="ka">email</em>: <em class="ka">string</em>,<br/>    <em class="ka">password</em>: <em class="ka">string<br/>  </em>) =&gt; <em class="ka">Promise</em>&lt;<em class="ka">UserModel </em>| <em class="ka">null</em>&gt;;<br/>}</span><span id="49bc" class="kk kl hi kg b fi kq kn l ko kp"><em class="ka">export const </em>useAuthHttp = (): <em class="ka">UseAuthHttp </em>=&gt; {<br/>  <em class="ka">const </em>{ post } = useHttp();</span><span id="59f4" class="kk kl hi kg b fi kq kn l ko kp"><em class="ka">const </em>loginUser = <em class="ka">async </em>(<br/>    <em class="ka">email</em>: <em class="ka">string</em>,<br/>    <em class="ka">password</em>: <em class="ka">string<br/>  </em>): <em class="ka">Promise</em>&lt;<em class="ka">UserModel </em>| <em class="ka">null</em>&gt; =&gt; {<br/>    <em class="ka">const </em>response = <br/>      <em class="ka">await </em>post&lt;<em class="ka">LoginResponseModel&gt;</em>(ApiEndPointsEnum.<em class="ka">Login</em>, {<br/>        <em class="ka">email</em>,<br/>        <em class="ka">password<br/>      </em>});</span><span id="3ba8" class="kk kl hi kg b fi kq kn l ko kp"><em class="ka">return </em>response<br/>      ? jwt.verify(<br/>          response.data.token,process.env.REACT_APP_JWT_SECRET<br/>        )<br/>      : <em class="ka">null</em>;<br/>  };</span><span id="a1e5" class="kk kl hi kg b fi kq kn l ko kp"><em class="ka">return </em>{ loginUser };<br/>};</span></pre><p id="3d79" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">正如您在这里看到的，我们不必担心失败的请求，这里我们只担心响应中的auth token。</p><p id="6869" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们现在可以继续我们在auth上下文上的工作。</p></div><div class="ab cl jt ju gp jv" role="separator"><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy"/></div><div class="hb hc hd he hf"><p id="779c" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj"><em class="ka">context/auth/index . ts</em></strong></p><pre class="kb kc kd ke fd kf kg kh ki aw kj bi"><span id="fbfe" class="kk kl hi kg b fi km kn l ko kp"><em class="ka">import </em>React, {<br/>  ComponentProps,<br/>  createContext,<br/>  FC,<br/>  useContext,<br/>  useReducer<br/>} <em class="ka">from </em>'react';</span><span id="1476" class="kk kl hi kg b fi kq kn l ko kp"><em class="ka">import </em>{ <em class="ka">UserModel </em>} <em class="ka">from </em>'...';<br/><em class="ka">import </em>{ initialUserState, userReducer } <em class="ka">from </em>'./reducer';<br/><em class="ka">import </em>{ useAuthHttp } <em class="ka">from </em>'../../shared/http';<br/><em class="ka">import </em>{ clearUserAction, setUserAction } <em class="ka">from </em>'./actions';</span><span id="e352" class="kk kl hi kg b fi kq kn l ko kp"><em class="ka">interface UserContext </em>{<br/>  state: <em class="ka">UserModel</em>;<br/>  login: (<em class="ka">email</em>: <em class="ka">string</em>, <em class="ka">password</em>: <em class="ka">string</em>) =&gt; <em class="ka">void</em>;<br/>  logout: () =&gt; <em class="ka">void</em>;<br/>  isAuthenticated: () =&gt; <em class="ka">boolean</em>;<br/>}</span><span id="d4fd" class="kk kl hi kg b fi kq kn l ko kp"><em class="ka">const </em>UserContext = createContext&lt;<em class="ka">UserContext</em>&gt;({} <em class="ka">as UserContext</em>);</span><span id="a155" class="kk kl hi kg b fi kq kn l ko kp"><em class="ka">export const </em>useUserContext =<br/>  (): <em class="ka">UserContext </em>=&gt; useContext(UserContext);</span><span id="c8bc" class="kk kl hi kg b fi kq kn l ko kp"><em class="ka">export const </em>UserContextProvider = ({<br/>  <em class="ka">children<br/></em>}: ComponentProps&lt;FC&gt;): JSX.Element =&gt; {</span><span id="4d98" class="kk kl hi kg b fi kq kn l ko kp"><em class="ka">const </em>[state, dispatch] =<br/>    useReducer(userReducer, initialUserState);</span><span id="7709" class="kk kl hi kg b fi kq kn l ko kp"><em class="ka">const </em>{ loginUser } = useAuthHttp();</span><span id="1901" class="kk kl hi kg b fi kq kn l ko kp"><em class="ka">const </em>isAuthenticated = (): <em class="ka">boolean </em>=&gt; {<br/>    <em class="ka">return </em>!!state.id;<br/>  };</span><span id="6ff2" class="kk kl hi kg b fi kq kn l ko kp"><em class="ka">const </em>login = <em class="ka">async </em>(<br/>    <em class="ka">email</em>: <em class="ka">string</em>,<br/>    <em class="ka">password</em>: <em class="ka">string<br/>  </em>): <em class="ka">Promise</em>&lt;<em class="ka">void</em>&gt; =&gt; {<br/>    <em class="ka">const </em>user = <em class="ka">await </em>loginUser(<em class="ka">email</em>, <em class="ka">password</em>);<br/>    <em class="ka">if </em>(user) {<br/>      setUserAction(user, dispatch);<br/>    }<br/>  };</span><span id="9478" class="kk kl hi kg b fi kq kn l ko kp"><em class="ka">const </em>logout = (): <em class="ka">void </em>=&gt; {<br/>    clearUserAction(dispatch);<br/>  };</span><span id="fb3a" class="kk kl hi kg b fi kq kn l ko kp"><em class="ka">return </em>(<br/>    &lt;UserContext.Provider<br/>      <em class="ka">value</em>={{state, login, logout, isAuthenticated }}<br/>    &gt;<br/>      {<em class="ka">children</em>}<br/>    &lt;/UserContext.Provider&gt;<br/>  );<br/>};</span></pre><p id="59f7" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj"><em class="ka">log in . tsx</em></strong>(<em class="ka">我就不重点说验证之类的了，这只是为了故事上下文。如果你对此感兴趣，你可以阅读下面的故事</em></p><div class="kr ks ez fb kt ku"><a rel="noopener follow" target="_blank" href="/@rasha08/react-custom-validation-hooks-7699416907e6"><div class="kv ab dw"><div class="kw ab kx cl cj ky"><h2 class="bd hj fi z dy kz ea eb la ed ef hh bi translated">React，自定义验证挂钩</h2><div class="lb l"><h3 class="bd b fi z dy kz ea eb la ed ef dx translated">表单域验证总是需要的，但是你不应该被吸引去使用一些流行的库…</h3></div><div class="lc l"><p class="bd b fp z dy kz ea eb la ed ef dx translated">medium.com</p></div></div></div></a></div><pre class="kb kc kd ke fd kf kg kh ki aw kj bi"><span id="ba93" class="kk kl hi kg b fi km kn l ko kp"><em class="ka">import </em>React, { ChangeEvent, useEffect, useState } <em class="ka">from </em>'react';<br/><em class="ka">...</em></span><span id="e3f8" class="kk kl hi kg b fi kq kn l ko kp"><em class="ka">import </em>{ useUserContext } <em class="ka">from </em>'...';</span><span id="165b" class="kk kl hi kg b fi kq kn l ko kp">...<br/><em class="ka">export const </em>Login = (): JSX.Element =&gt; {<br/>  <em class="ka">const </em>[email, setEmail] = useState('');<br/>  <em class="ka">const </em>[password, setPassword] = useState('');</span><span id="742e" class="kk kl hi kg b fi kq kn l ko kp"><em class="ka">const </em>{ login } = useUserContext();</span><span id="1f16" class="kk kl hi kg b fi kq kn l ko kp"><em class="ka">const </em>onEmailChange = ({<br/>    target: { <em class="ka">value </em>}<br/>  }: ChangeEvent&lt;<em class="ka">HTMLInputElement</em>&gt;): <em class="ka">void </em>=&gt; {<br/>    setEmail(<em class="ka">value</em>);<br/>  };</span><span id="d862" class="kk kl hi kg b fi kq kn l ko kp"><em class="ka">const </em>onPasswordChange = ({<br/>    target: { <em class="ka">value </em>}<br/>  }: ChangeEvent&lt;<em class="ka">HTMLInputElement</em>&gt;): <em class="ka">void </em>=&gt; {<br/>    setPassword(<em class="ka">value</em>);<br/>  };</span><span id="34e7" class="kk kl hi kg b fi kq kn l ko kp"><em class="ka">const </em>loginUser = (): <em class="ka">void </em>=&gt; {<br/>    login(email, password);<br/>  };</span><span id="9342" class="kk kl hi kg b fi kq kn l ko kp"><em class="ka">return </em>(<br/>    &lt;Container <em class="ka">maxWidth</em>="md"&gt;<br/>      &lt;TextField<br/>        <em class="ka">label</em>="Email"<br/>        <em class="ka">onChange</em>={onEmailChange} <br/>        value={email}<em class="ka"><br/>      </em>/&gt;<br/>      &lt;TextField<br/>        <em class="ka">type</em>="password"<br/>        <em class="ka">label</em>="Password"<br/>        <em class="ka">onChange</em>={onPasswordChange}<br/>        value={password}<em class="ka"><br/>      </em>/&gt;</span><span id="5d6a" class="kk kl hi kg b fi kq kn l ko kp">&lt;Button <em class="ka">onClick</em>={loginUser}&gt;Login&lt;/Button&gt;<br/>    &lt;/Container&gt;<br/>  );<br/>};</span></pre></div><div class="ab cl jt ju gp jv" role="separator"><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy"/></div><div class="hb hc hd he hf"><p id="cfc4" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">配置<br/> </strong>这里还是老样子，我们有类型、动作、reducer、上下文，对Http请求使用ConfigHttp，所以为了后面的故事，没必要再去扔那个了。</p></div><div class="ab cl jt ju gp jv" role="separator"><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy"/></div><div class="hb hc hd he hf"><p id="cc55" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">组合上下文提供者<br/> </strong>这是更好的选择，这不是必须的，但我认为如果你有多个上下文提供者，一些组件需要使用，这是必须的。我们只需要看看上下文提供者，只是反应组件。</p><p id="1aca" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">组合组件<em class="ka">。tsx</em>T27】</strong></p><pre class="kb kc kd ke fd kf kg kh ki aw kj bi"><span id="17e7" class="kk kl hi kg b fi km kn l ko kp"><em class="ka">import </em>React, { ComponentProps, FC } <em class="ka">from </em>'react';</span><span id="ca7c" class="kk kl hi kg b fi kq kn l ko kp"><em class="ka">export const </em>combineComponents = (...<em class="ka">components</em>: FC&lt;<em class="ka">any</em>&gt;[]): FC =&gt; {<br/>  return components<br/>    .reverse()<br/>    .reduce(<br/>      (<em class="ka">AccumulatedComponents</em>, <em class="ka">CurrentComponent</em>) =&gt; {<br/>        <em class="ka">return </em>({ <em class="ka">children </em>}: ComponentProps&lt;FC&gt;): JSX.Element =&gt; {<br/>          <em class="ka">return </em>(<br/>            &lt;AccumulatedComponents&gt;<br/>              &lt;CurrentComponent&gt;{<em class="ka">children</em>}&lt;/CurrentComponent&gt;<br/>            &lt;/AccumulatedComponents&gt;<br/>          );<br/>        };<br/>      },<br/>      ({ <em class="ka">children </em>}) =&gt; &lt;&gt;{<em class="ka">children</em>}&lt;/&gt;<em class="ka"><br/>    </em>);<br/>};</span></pre><p id="1628" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我知道这可能看起来令人困惑，但我们只是在这里堆叠组件作为包装。和我在一起，我保证你很快就会看到好处。</p><p id="2ddd" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">最后，让我们创建一个组合的上下文提供者，并在我们的应用程序<strong class="ix hj"> <em class="ka"> index.tsx </em> </strong>中提供它，就像我们对redux所做的那样。</p><p id="32b7" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">T33】store/index . tsxT35】</strong></p><pre class="kb kc kd ke fd kf kg kh ki aw kj bi"><span id="b5d3" class="kk kl hi kg b fi km kn l ko kp"><em class="ka">import </em>{ ErrorContextProvider } <em class="ka">from </em>'./error';<br/><em class="ka">import </em>{ AuthContextProvider } <em class="ka">from </em>'./auth';<br/>import { ConfigurationContextProvider } from './configuration';</span><span id="6735" class="kk kl hi kg b fi kq kn l ko kp"><em class="ka">import </em>{ combineComponents } <em class="ka">from </em>'../shared/utils';</span><span id="6a20" class="kk kl hi kg b fi kq kn l ko kp"><em class="ka">export const </em>AppContextProvider = combineComponents(<br/>  ErrorContextProvider,<br/>  AuthContextProvider,<br/>  ConfigurationContextProvider<br/>);</span></pre><p id="0756" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这里重要的是要知道提供者的依赖关系，如果有的话，我们对ErrorContext上的useHttp hook有一个依赖关系，当我们在Auth和Configuration上下文中使用这个钩子时，我们需要在依赖关系之前提供ErrorContextProvider。</p></div><div class="ab cl jt ju gp jv" role="separator"><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy"/></div><div class="hb hc hd he hf"><p id="addf" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">T37】src/index . tsxT39】</strong></p><pre class="kb kc kd ke fd kf kg kh ki aw kj bi"><span id="8e71" class="kk kl hi kg b fi km kn l ko kp"><em class="ka">import </em>ReactDOM <em class="ka">from </em>'react-dom';<br/><em class="ka">import </em>{ AppContextProvider } <em class="ka">from </em>'./context';<br/><em class="ka">import </em>App <em class="ka">from </em>'./App';<br/><em class="ka">import </em>* <em class="ka">as </em>serviceWorker <em class="ka">from </em>'./serviceWorker';<br/><br/><em class="ka">import </em>'./styles.scss';<br/><br/>ReactDOM.render(<br/>  &lt;AppContextProvider&gt;<br/>    &lt;App /&gt;<br/>  &lt;/AppContextProvider&gt;,<br/>  document.getElementById('root')<br/>);<br/><em class="ka"><br/></em>serviceWorker.unregister();</span></pre></div><div class="ab cl jt ju gp jv" role="separator"><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy"/></div><div class="hb hc hd he hf"><p id="8dc4" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">那就是我们现在可以在应用程序的任何地方使用我们的上下文。这些是你可以用redux架构开发大规模应用程序的原则。</p></div></div>    
</body>
</html>