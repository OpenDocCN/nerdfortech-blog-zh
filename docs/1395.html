<html>
<head>
<title>Merging Sorted Arrays:</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">合并排序后的数组:</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/merging-sorted-arrays-167623708d15?source=collection_archive---------18-----------------------#2021-03-16">https://medium.com/nerd-for-tech/merging-sorted-arrays-167623708d15?source=collection_archive---------18-----------------------#2021-03-16</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="f9d7" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">准备合并排序算法(Javascript)</h2></div><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ix"><img src="../Images/0a6254d87e29013527e4ec3489036831.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jz08jMr3DYpduMLhr7OKRw.png"/></div></div></figure><p id="4713" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">为了更好地理解合并排序算法的工作原理，最好从学习如何实现合并两个数组的函数开始。</p><h2 id="c5f3" class="kf kg hi bd kh ki kj kk kl km kn ko kp js kq kr ks jw kt ku kv ka kw kx ky kz bi translated">时间复杂度:</h2><p id="1c24" class="pw-post-body-paragraph jj jk hi jl b jm la ij jo jp lb im jr js lc ju jv jw ld jy jz ka le kc kd ke hb bi translated">因为我们需要两个不同的数组，它们的长度可以不同，所以时间复杂度是:<strong class="jl hj"> O(n +m) </strong></p><h2 id="1ab8" class="kf kg hi bd kh ki kj kk kl km kn ko kp js kq kr ks jw kt ku kv ka kw kx ky kz bi translated">工作原理:</h2><p id="7d1f" class="pw-post-body-paragraph jj jk hi jl b jm la ij jo jp lb im jr js lc ju jv jw ld jy jz ka le kc kd ke hb bi translated">这个函数将对以相同方式排序的数组进行比较。<br/>为了比较它们，我们将创建两个变量(<em class="lf"> i </em>和<em class="lf"> j </em>)来处理每个数组的索引，并创建一个数组来存储结果。<br/>然后我们将使用while循环对它们进行迭代，直到<em class="lf"> i </em>或<em class="lf"> j </em>等于它们各自数组的长度。<br/>如果<em class="lf"> arr[i] </em>小于<em class="lf"> arr[j] </em>，我们将把<em class="lf"> arr[i] </em>推送到结果中，并给I加+1，以比较下一个元素与<em class="lf"> arr[j] </em>。<br/>如果<em class="lf"> arr[j] </em>小于<em class="lf"> arr[i] </em>我们将做相反的事情。我们将继续这样做，直到用完其中一个数组。然后，我们将把另一个数组中所有剩余的元素放入结果中。</p><h2 id="fa25" class="kf kg hi bd kh ki kj kk kl km kn ko kp js kq kr ks jw kt ku kv ka kw kx ky kz bi translated">伪代码:</h2><pre class="iy iz ja jb fd lg lh li lj aw lk bi"><span id="91dd" class="kf kg hi lh b fi ll lm l ln lo">// Create a function that accepts 2 arrays sorted in the same way.</span><span id="2739" class="kf kg hi lh b fi lp lm l ln lo">// Create an empty array where we'll push the smallest value when <br/>   comparing both arrays.</span><span id="374c" class="kf kg hi lh b fi lp lm l ln lo">// While we have elements to compare:</span><span id="9704" class="kf kg hi lh b fi lp lm l ln lo">// If the value of the first array is less than the value of the <br/>   second array, push the value of the first array and move one <br/>   index forward.</span><span id="4429" class="kf kg hi lh b fi lp lm l ln lo">// If the value of the first array is greater than the value of the <br/>   second array. Push the value of the second array and move one <br/>   index forward.</span><span id="56d8" class="kf kg hi lh b fi lp lm l ln lo">// Once we have no more elements to compare within one of the <br/>   arrays, push all the remaining values from the other array.</span></pre><h2 id="0814" class="kf kg hi bd kh ki kj kk kl km kn ko kp js kq kr ks jw kt ku kv ka kw kx ky kz bi translated">代码:</h2><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="lq lr l"/></div></figure></div></div>    
</body>
</html>